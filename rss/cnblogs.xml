<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>gitbook 入门教程之发布电子书 - 雪之梦技术驿站</title>
<link>http://www.cnblogs.com/snowdreams1006/p/10674385.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/snowdreams1006/p/10674385.html</guid>
<description>&lt;h2 id=&quot;输出目标文件&quot;&gt;输出目标文件&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;语法格式: gitbook build [book] [output]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;默认情况下,&lt;code&gt;gitbook&lt;/code&gt; 输出方式是静态网站,其实 &lt;code&gt;gitbook&lt;/code&gt; 的输出方式有三种: &lt;code&gt;website&lt;/code&gt;, &lt;code&gt;json&lt;/code&gt;,和 &lt;code&gt;ebook&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;只不过另外两种不是很常用,更多情况下我们是使用静态网页搭建个人官网,或托管到第三方平台,或部署到私有云服务器,但不管怎么样,还是离不开生成这一步.&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 默认输出格式: `website`
$ gitbook build --format=website

# 更改输出格式: `json`
$ gitbook build --format=json

# 更改输出格式: `ebook`
$ gitbook build --format=ebook&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;默认情况下输出目录: &lt;code&gt;_book/&lt;/code&gt;,整个项目的入口文件是: &lt;code&gt;index.html&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;集成-github-网站&quot;&gt;集成 &lt;code&gt;github&lt;/code&gt; 网站&lt;/h2&gt;
&lt;p&gt;本教程的电子书源码和输出文件均托管到 &lt;code&gt;github&lt;/code&gt; 网站,所以这里介绍下如何利用 &lt;code&gt;Github Pages&lt;/code&gt; 静态网页服务与 &lt;code&gt;gitbook&lt;/code&gt; 进行集成.&lt;/p&gt;
&lt;h3 id=&quot;什么是-github-pages&quot;&gt;什么是 &lt;code&gt;GitHub Pages&lt;/code&gt; ?&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Github Pages&lt;/code&gt; 是 &lt;code&gt;github&lt;/code&gt; 网站推出的一种&lt;strong&gt;免费&lt;/strong&gt;的静态网页托管服务,适合搭建静态的项目主页或个人官网.&lt;/p&gt;
&lt;p&gt;其中,网站项目的源码直接托管在 &lt;code&gt;github&lt;/code&gt; 仓库中,当仓库文件更新后,该仓库所关联的网站自动更新,从而实现了源码与官网的联动更新.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-26f5e910adcc74ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;gitbook-publish-github-pages-preview.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;3.3428571428571&quot;&gt;
&lt;p&gt;如果想了解更多详情,请参考&lt;a href=&quot;https://pages.github.com/&quot;&gt;官网&lt;/a&gt;: &lt;a href=&quot;https://pages.github.com/&quot; class=&quot;uri&quot;&gt;https://pages.github.com/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;怎么做-github-pages&quot;&gt;怎么做 &lt;code&gt;GitHub Pages&lt;/code&gt; ?&lt;/h3&gt;
&lt;p&gt;每个账号&lt;strong&gt;有且只有一个&lt;/strong&gt;主页站点,但允许&lt;strong&gt;无限制&lt;/strong&gt;多的项目站点.&lt;/p&gt;
&lt;p&gt;啥是主页站点,项目站点又是啥?&lt;/p&gt;
&lt;p&gt;别急,让我先举个例子看一下最终效果.&lt;/p&gt;
&lt;p&gt;假如用户名: &lt;code&gt;zhangsan&lt;/code&gt; 名下有四个公开仓库,一个仓库名叫做: &lt;code&gt;zhangsan.github.io&lt;/code&gt;,另外三种分别是: &lt;code&gt;project01&lt;/code&gt;,&lt;code&gt;project02&lt;/code&gt;,&lt;code&gt;project03&lt;/code&gt; .&lt;/p&gt;
&lt;p&gt;如果想要对外暴露上述四个仓库作为我们的静态网站,那么最终效果就是下面这样的.&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;注意将 &lt;code&gt;zhangsan&lt;/code&gt; 替换成自己的 &lt;code&gt;github&lt;/code&gt; 用户名,否则八成是打不开网站,除非真的有 &lt;code&gt;zhangsan&lt;/code&gt; 这个用户.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其实上述规则很好理解,&lt;code&gt;github&lt;/code&gt; 网站作为一个托管中心,有成千上万的用户在使用 &lt;code&gt;github&lt;/code&gt; 并且每个用户的用户名都是唯一并且不同的,因此 &lt;code&gt;*.github.io&lt;/code&gt; 通配符域名刚好充当命名空间.&lt;/p&gt;
&lt;p&gt;可以预料的是,不仅仅有 &lt;code&gt;&amp;lt;username&amp;gt;.github.io&lt;/code&gt; 这种二级域名,说不定还有 &lt;code&gt;api.github.io&lt;/code&gt;,&lt;code&gt;docs.github.io&lt;/code&gt; 等等,毕竟只需要购买 &lt;code&gt;*.github.io&lt;/code&gt; 通配符域名证书就可以支持任意多的二级域名了,感谢 &lt;code&gt;github&lt;/code&gt; 赠送我们免费的 &lt;code&gt;https&lt;/code&gt; 网站.&lt;/p&gt;
&lt;p&gt;说到这里,不得不吐槽下 &lt;code&gt;gitbook&lt;/code&gt; 的命名空间策略了,&lt;code&gt;gitbook&lt;/code&gt; 也有自己的电子书托管服务,但访问地址是 &lt;code&gt;&amp;lt;username&amp;gt;.gitbook.io/&amp;lt;namespace&amp;gt;&lt;/code&gt; .&lt;/p&gt;
&lt;p&gt;很显然,&lt;code&gt;gitbook&lt;/code&gt; 没有区分主页站点和项目站点,相当于全部都是项目站点,缺少主次之分.&lt;/p&gt;
&lt;p&gt;闲言少叙,既然知道了输入内容和输出效果,那么接下来的任务就是了解中间过程了,让我们一起探讨下怎么发布网站吧!&lt;/p&gt;
&lt;h4 id=&quot;主页站点&quot;&gt;主页站点&lt;/h4&gt;
&lt;h5 id=&quot;创建-username.github.io-公开仓库&quot;&gt;创建 &lt;code&gt;&amp;lt;username&amp;gt;.github.io&lt;/code&gt; 公开仓库&lt;/h5&gt;
&lt;p&gt;前往 &lt;a href=&quot;https://github.com/&quot; class=&quot;uri&quot;&gt;https://github.com/&lt;/a&gt; 网站创建名为 &lt;code&gt;&amp;lt;username&amp;gt;.github.io&lt;/code&gt; 的公开仓库.&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;比如我的用户名是: &lt;code&gt;snowdreams1006&lt;/code&gt; ,那么我的主页站点仓库就是: &lt;code&gt;snowdreams1006.github.io&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;创建首页-index.html-文件&quot;&gt;创建首页 &lt;code&gt;index.html&lt;/code&gt; 文件&lt;/h5&gt;
&lt;p&gt;不管是在线直接创建 &lt;code&gt;index.html&lt;/code&gt; 还是克隆到本地创建 &lt;code&gt;index.html&lt;/code&gt; ,最终的 &lt;code&gt;&amp;lt;username&amp;gt;.github.io&lt;/code&gt; 仓库一定要有 &lt;code&gt;index.html&lt;/code&gt; 首页文件.&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 克隆到本地
$ git clone https://github.com/username/username.github.io

# 切换到项目
$ cd username.github.io

# 创建 `index.html` 文件
$ echo &quot;Hello World&quot; &amp;gt; index.html

# 推送到远程仓库
$ git add --all
$ git commit -m &quot;Initial commit&quot;
$ git push -u origin master&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;访问主页站点-httpsusername.github.io&quot;&gt;访问主页站点 &lt;code&gt;https://username.github.io&lt;/code&gt;&lt;/h5&gt;
&lt;p&gt;打开浏览器,输入网址: &lt;a href=&quot;https://username.github.io/&quot; class=&quot;uri&quot;&gt;https://username.github.io&lt;/a&gt; 访问主页站点,显示的内容正是我们刚刚提交的 &lt;code&gt;index.html&lt;/code&gt; 文件内容.&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果没有正常显示,清除浏览器缓存强制刷新试试看!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;项目站点&quot;&gt;项目站点&lt;/h4&gt;
&lt;p&gt;相比主页站点来说,项目站点命名比较随意了,作为静态网站不可或缺的文件仍然是 &lt;code&gt;index.html&lt;/code&gt;.&lt;/p&gt;
&lt;h5 id=&quot;创建首页-index.html-文件-1&quot;&gt;创建首页 &lt;code&gt;index.html&lt;/code&gt; 文件&lt;/h5&gt;
&lt;p&gt;创建首页文件并添加测试内容,方便待会在线访问项目站点测试是否部署成功.&lt;/p&gt;
&lt;h5 id=&quot;设置-github-pages-选项&quot;&gt;设置 &lt;code&gt;GitHub Pages&lt;/code&gt; 选项&lt;/h5&gt;
&lt;p&gt;点击仓库首页右上方设置(&lt;code&gt;Settings&lt;/code&gt;)选项卡,往下翻到 &lt;code&gt;GitHub Pages&lt;/code&gt; 选项,选择源码目录,根据实际情况选择源码来源于 &lt;code&gt;master&lt;/code&gt; 分支还是其他分支或者&lt;code&gt;docs/&lt;/code&gt; 目录.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-92b3ef55b85acac1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;gitbook-publish-project-setting.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;方便起见,选择第一个 &lt;code&gt;master&lt;/code&gt; 分支即可,注意下面的主题和这一步的来源只能两者选其一,否则主题优先级更高!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;访问主页站点-httpsusername.github.iorepository&quot;&gt;访问主页站点 &lt;code&gt;https://username.github.io/&amp;lt;repository&amp;gt;&lt;/code&gt;&lt;/h5&gt;
&lt;p&gt;打开浏览器,输入网址: &lt;a href=&quot;https://username.github.io/repository&quot; class=&quot;uri&quot;&gt;https://username.github.io/repository&lt;/a&gt; 访问项目站点,显示的内容正是我们刚刚提交的 &lt;code&gt;index.html&lt;/code&gt; 文件内容.&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果没有正常显示,清除浏览器缓存强制刷新试试看!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;如何集成-gitbook&quot;&gt;如何集成 &lt;code&gt;gitbook&lt;/code&gt; ?&lt;/h3&gt;
&lt;p&gt;我们已经知道 &lt;code&gt;Github Pages&lt;/code&gt; 是提供静态网站的免费托管,而 &lt;code&gt;gitbook&lt;/code&gt; 默认生成的内容就是静态网站,两者如何结合自然不用我多说了吧?&lt;/p&gt;
&lt;p&gt;&lt;code&gt;gitbook&lt;/code&gt; 默认输出目录 &lt;code&gt;_book/&lt;/code&gt; 包括了静态网站所需的全部资源,其中就包括 &lt;code&gt;index.html&lt;/code&gt; 首页文件.&lt;/p&gt;
&lt;p&gt;因此我们只需要每次生成后将 &lt;code&gt;_book/&lt;/code&gt; 整个目录复制到项目根目录,那么推送到远程仓库时自然就是输出后静态网站了啊!&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 生成静态网站
$ gitbook build

# 复制到项目根目录
$ cp -r _book/* .

# 添加到本地版本库
$ git add .
$ git commit -m &quot;publish&quot;

# 推送到远程仓库
$ git push origin master&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;现在登录 &lt;code&gt;github&lt;/code&gt; 网站看一下静态网站是否成功上传以及访问主页站点或项目站点看一下最新内容是否成功渲染吧!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;本节我们学习 &lt;code&gt;gitbook&lt;/code&gt; 有三种输出方式,其中默认的网页输出最为常用.&lt;/p&gt;
&lt;p&gt;除此之外,还讲解了如何与 &lt;code&gt;github pages&lt;/code&gt; 进行结合,从而实现源码和网站的自动更新维护.&lt;/p&gt;
&lt;p&gt;如果源码没有托管到 &lt;code&gt;github&lt;/code&gt; 这种第三方服务商,你也可以搭建自己的服务器,比如将 &lt;code&gt;_book/&lt;/code&gt; 目录全部扔到 &lt;code&gt;nginx&lt;/code&gt; 服务器做静态资源服务器等.&lt;/p&gt;
&lt;p&gt;毕竟,源码和输出内容都在你手中,想怎么玩还不是自己说了算?&lt;/p&gt;
</description>
<pubDate>Mon, 08 Apr 2019 15:38:00 +0000</pubDate>
<dc:creator>雪之梦技术驿站</dc:creator>
<og:description>输出目标文件 语法格式: gitbook build [book] [output] 默认情况下, 输出方式是静态网站,其实 的输出方式有三种: , ,和 . 只不过另外两种不是很常用,更多情况下我们</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/snowdreams1006/p/10674385.html</dc:identifier>
</item>
<item>
<title>数据结构（一）：链表 - 漫漫芜</title>
<link>http://www.cnblogs.com/sheshouxin/p/10659456.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sheshouxin/p/10659456.html</guid>
<description>&lt;p&gt;&lt;strong&gt;链表&lt;/strong&gt;：由一系列不必再内存中相连的结构组成，每一个结构均含有表元素和指向后继结构的指针。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;与数组、列表的主要区别&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;内存不连续；&lt;/li&gt;
&lt;li&gt;不能通过下标随机访问。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;插入、删除操作效率高，时间复杂度为o(1)；&lt;/li&gt;
&lt;li&gt;内存利用率高，不会浪费内存；&lt;/li&gt;
&lt;li&gt;大小不固定，扩展灵活；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;随机访问性差，查找效率低，时间复杂度为o(n)；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;实现一个链表：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Node(object):
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;定义链表元素类&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;(self, value=None, next=&lt;span&gt;None):
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         self.value =&lt;span&gt; value
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         self.next =&lt;span&gt; next
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SingleLinkList(object):
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         self.head = Node()  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 头节点没有数据，仅作为链表访问的起点&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         self.tail =&lt;span&gt; self.head
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         self.length =&lt;span&gt; 0
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; append(self, value):
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         node =&lt;span&gt; Node(value)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         self.tail.next =&lt;span&gt; node
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         self.tail =&lt;span&gt; node
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         self.length += 1
&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; appendleft(self, value):
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;将节点插入到head后面&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;         node =&lt;span&gt; Node(value)
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; self.head.next &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; None:  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 判断链表是否插入过元素&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;             firstnode =&lt;span&gt; self.head.next
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             node.next =&lt;span&gt; firstnode
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             self.head.next =&lt;span&gt; node
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             self.head.next =&lt;span&gt; node
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             self.tail =&lt;span&gt; node
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         self.length += 1
&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; iter_node(self):
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;构造生成器用于遍历链表节点&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;         curnode =&lt;span&gt; self.head.next
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; curnode &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; self.tail:
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;             &lt;span&gt;yield&lt;/span&gt;&lt;span&gt; curnode
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;             curnode =&lt;span&gt; curnode.next
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;yield&lt;/span&gt;&lt;span&gt; curnode
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; 
&lt;span&gt;40&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__iter__&lt;/span&gt;&lt;span&gt;(self):
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;通过生成器，使链表可被for循环遍历&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; node &lt;span&gt;in&lt;/span&gt;&lt;span&gt; self.iter_node():
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;             &lt;span&gt;yield&lt;/span&gt;&lt;span&gt; node.value
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; 
&lt;span&gt;45&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__len__&lt;/span&gt;&lt;span&gt;(self):
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; self.length
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; 
&lt;span&gt;48&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; remove(self, value):
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; curnode &lt;span&gt;in&lt;/span&gt;&lt;span&gt; self.iter_node():
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; curnode.next &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; None &lt;span&gt;and&lt;/span&gt; curnode.next.value ==&lt;span&gt; value:
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;                 node =&lt;span&gt; curnode.next
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;                 curnode.next =&lt;span&gt; node.next
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;                 &lt;span&gt;del&lt;/span&gt;&lt;span&gt; node
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;                 self.length -= 1
&lt;span&gt;55&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; 0  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 删除成功&lt;/span&gt;
&lt;span&gt;56&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; -1  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 删除失败&lt;/span&gt;
&lt;span&gt;57&lt;/span&gt; 
&lt;span&gt;58&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; popleft(self):
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;删除链表第一个节点&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;60&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; self.length &amp;gt;&lt;span&gt; 0:
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;             node =&lt;span&gt; self.head.next
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;             self.head.next =&lt;span&gt; node.next
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt;             self.length -= 1
&lt;span&gt;64&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; node.value
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;             &lt;span&gt;raise&lt;/span&gt; Exception(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;LinkList is empty&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上代码定义了一个单链表类，并实现了常用的添加、删除链表元素的方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;双端链表&lt;/strong&gt;：单链表无法满足有些倒叙遍历链表的需求，因此需要双端链表。双端链表的实现只需要在单链表的基础上增加一个指向前一节点的指针即可，却极大的简化了某些针对节点的操作，如删除某节点的时间复杂度直接变为o(1)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;循环双端链表&lt;/strong&gt;：将双端链表的头节点与尾节点链接起来，就是循环双端链表。&lt;/p&gt;
&lt;p&gt;代码实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Node(object):
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;(self, value=None, next=None, prev=&lt;span&gt;None):
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         self.value, self.next, self.prev =&lt;span&gt; value, next, prev
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CircularDoubleLinkList(object):
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         self.head = Node()  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 头节点没有数据，仅作为链表访问的起点&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         self.tail =&lt;span&gt; self.head
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         self.length =&lt;span&gt; 0
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; append(self, value):
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         node =&lt;span&gt; Node(value, self.head, self.tail)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         self.tail.next =&lt;span&gt; node
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         self.head.prev =&lt;span&gt; node
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         self.tail =&lt;span&gt; node
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         self.length += 1
&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; appendleft(self, value):
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         node =&lt;span&gt; Node(value)
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; self.head.next &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; None:
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             nextnode =&lt;span&gt; self.head.next
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             node.next =&lt;span&gt; nextnode
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             node.prev =&lt;span&gt; self.head
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             nextnode.prev =&lt;span&gt; node
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             self.head.next =&lt;span&gt; node
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             node.prev =&lt;span&gt; self.head
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             node.next =&lt;span&gt; self.head
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             self.head.next =&lt;span&gt; node
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             self.head.prev =&lt;span&gt; node
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             self.tail =&lt;span&gt; node
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         self.length += 1
&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; iter_node(self):
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;构造生成器用于遍历链表节点&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;         curnode =&lt;span&gt; self.head.next
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; curnode &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; self.tail:
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;             &lt;span&gt;yield&lt;/span&gt;&lt;span&gt; curnode
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;             curnode =&lt;span&gt; curnode.next
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;         &lt;span&gt;yield&lt;/span&gt;&lt;span&gt; curnode
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; 
&lt;span&gt;43&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__iter__&lt;/span&gt;&lt;span&gt;(self):
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;通过生成器，使链表可被for循环遍历&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; node &lt;span&gt;in&lt;/span&gt;&lt;span&gt; self.iter_node():
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;             &lt;span&gt;yield&lt;/span&gt;&lt;span&gt; node.value
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; 
&lt;span&gt;48&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__len__&lt;/span&gt;&lt;span&gt;(self):
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; self.length
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; 
&lt;span&gt;51&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; remove(self, node):
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;注意参数是node&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;53&lt;/span&gt;         prevnode =&lt;span&gt; node.prev
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;         nextnode =&lt;span&gt; node.next
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; node &lt;span&gt;is&lt;/span&gt;&lt;span&gt; self.tail:
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;             self.tail =&lt;span&gt; prevnode
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;         prevnode.next =&lt;span&gt; nextnode
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;         nextnode.prev =&lt;span&gt; prevnode
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;         self.length -= 1
&lt;span&gt;60&lt;/span&gt; 
&lt;span&gt;61&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; iter_node_reverse(self):
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;         curnode =&lt;span&gt; self.tail
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; curnode &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; self.head:
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;             &lt;span&gt;yield&lt;/span&gt;&lt;span&gt; curnode
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;             curnode = curnode.prev
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Mon, 08 Apr 2019 15:25:00 +0000</pubDate>
<dc:creator>漫漫芜</dc:creator>
<og:description>数据结构链表的python实现</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sheshouxin/p/10659456.html</dc:identifier>
</item>
<item>
<title>Koa 中的错误处理 - 刘哇勇</title>
<link>http://www.cnblogs.com/Wayou/p/error_handling_in_koajs.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Wayou/p/error_handling_in_koajs.html</guid>
<description>&lt;p&gt;不像 express 中在末尾处注册一个声明为 &lt;code&gt;(err, req, res, next)&lt;/code&gt; 中间件的方式，koa 刚好相反，在开头进行注册。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;11&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-smi&quot;&gt;app&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;use&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;async&lt;/span&gt; (&lt;span class=&quot;pl-smi&quot;&gt;ctx&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;next&lt;/span&gt;) &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
  &lt;span class=&quot;pl-k&quot;&gt;try&lt;/span&gt; {
    &lt;span class=&quot;pl-k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;next&lt;/span&gt;();
  } &lt;span class=&quot;pl-k&quot;&gt;catch&lt;/span&gt; (err) {
    &lt;span class=&quot;pl-smi&quot;&gt;ctx&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;status&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;err&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;status&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;500&lt;/span&gt;;
    &lt;span class=&quot;pl-smi&quot;&gt;ctx&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;body&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;err&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;message&lt;/span&gt;;
    &lt;span class=&quot;pl-smi&quot;&gt;ctx&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;app&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;emit&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;error&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, err, ctx);
  }
});
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样程序中任何报错都会收敛到此处。此时可以方便地将错误打印到页面，开发时非常便捷。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-diff&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-mi1&quot;&gt;&lt;span class=&quot;pl-mi1&quot;&gt;+&lt;/span&gt;     ctx.app.emit('error', err, ctx);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;koa 也建议通过 app 来派发错误，然后通过监听 app 上的 &lt;code&gt;error&lt;/code&gt; 事件对这些错误做进一步的统一处理和集中管理。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-smi&quot;&gt;app&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;on&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;error&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, (&lt;span class=&quot;pl-smi&quot;&gt;err&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;ctx&lt;/span&gt;) &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
  &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;/*&lt;/span&gt; 错误的集中处理:&lt;/span&gt;
&lt;span class=&quot;pl-c&quot;&gt;   *  log 出来&lt;/span&gt;
&lt;span class=&quot;pl-c&quot;&gt;   *  写入日志&lt;/span&gt;
&lt;span class=&quot;pl-c&quot;&gt;   *  写入数据库&lt;/span&gt;
&lt;span class=&quot;pl-c&quot;&gt;   *   ...&lt;/span&gt;
&lt;span class=&quot;pl-c&quot;&gt;   &lt;span class=&quot;pl-c&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;
});
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一个错误捕获并打印到页面的示例：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;16&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;Koa&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;koa&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;app&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Koa&lt;/span&gt;();

&lt;span class=&quot;pl-smi&quot;&gt;app&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;use&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;async&lt;/span&gt; (&lt;span class=&quot;pl-smi&quot;&gt;ctx&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;next&lt;/span&gt;) &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
  &lt;span class=&quot;pl-k&quot;&gt;try&lt;/span&gt; {
    &lt;span class=&quot;pl-k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;next&lt;/span&gt;();
  } &lt;span class=&quot;pl-k&quot;&gt;catch&lt;/span&gt; (err) {
    &lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;status&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;err&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;status&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;500&lt;/span&gt;;
    &lt;span class=&quot;pl-smi&quot;&gt;ctx&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;status&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; status;
    &lt;span class=&quot;pl-smi&quot;&gt;ctx&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;html&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;;
    &lt;span class=&quot;pl-smi&quot;&gt;ctx&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;body&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;pl-s&quot;&gt;    &amp;lt;b&amp;gt;&lt;span class=&quot;pl-s1&quot;&gt;&lt;span class=&quot;pl-pse&quot;&gt;${&lt;/span&gt;status&lt;span class=&quot;pl-pse&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&amp;lt;/b&amp;gt; &lt;span class=&quot;pl-s1&quot;&gt;&lt;span class=&quot;pl-pse&quot;&gt;${&lt;/span&gt;err&lt;span class=&quot;pl-pse&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;pl-s&quot;&gt;    &lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;&lt;/span&gt;;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; emmit&lt;/span&gt;
    &lt;span class=&quot;pl-smi&quot;&gt;ctx&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;app&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;emit&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;error&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, err, ctx);
  }
});

&lt;span class=&quot;pl-smi&quot;&gt;app&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;use&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;ctx&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
  &lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;hello&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;;
  a &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;hello world!&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;; &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; TypeError: Assignment to constant variable.&lt;/span&gt;
  &lt;span class=&quot;pl-smi&quot;&gt;ctx&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;body&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; a;
});

&lt;span class=&quot;pl-smi&quot;&gt;app&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;on&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;error&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, (&lt;span class=&quot;pl-smi&quot;&gt;err&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;ctx&lt;/span&gt;) &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
  &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;error&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;Ooops..&lt;span class=&quot;pl-cce&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, err);
});

&lt;span class=&quot;pl-smi&quot;&gt;app&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;listen&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;3000&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过 &lt;code&gt;node server.js&lt;/code&gt; 启动后访问页面可看到命令行的错误输出。&lt;br/&gt;如果使用 pm2，可通过 &lt;code&gt;—no-daemon&lt;/code&gt; 参数使其停留在在命令行以查看输出。&lt;br/&gt;如果不使用上述参数，可通过 &lt;code&gt;pm2 logs [app-name]&lt;/code&gt; 来查看。&lt;/p&gt;
&lt;h3&gt;&lt;code&gt;ctx.throw&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;朴素的抛错方式需要手动设置状态码及信息对客户端的可见性。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Error&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;err msg&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
&lt;span class=&quot;pl-smi&quot;&gt;err&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;status&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;401&lt;/span&gt;;
&lt;span class=&quot;pl-smi&quot;&gt;err&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;expose&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;true&lt;/span&gt;;
&lt;span class=&quot;pl-k&quot;&gt;throw&lt;/span&gt; err;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;expose&lt;/code&gt; 决定是否会返回错误详情给客户端，否则只展示状态对应的错误文案，比如 500 会在浏览器中展示为 &lt;code&gt;Internal Server Error&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;而通过 &lt;a href=&quot;https://github.com/koajs/koa/blob/master/docs/api/context.md#ctxthrowstatus-msg-properties&quot;&gt;&lt;code&gt;ctx.throw&lt;/code&gt;&lt;/a&gt; 这个 helper 方法会更加简洁。&lt;br/&gt;上面的代码片段等价于:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-smi&quot;&gt;ctx&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;throw&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;401&lt;/span&gt;, &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;err msg&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果不指定状态码，默认为 500。5xx 类错误 &lt;code&gt;expose&lt;/code&gt; 默认为 &lt;code&gt;false&lt;/code&gt;，即不会将错误信息返回到 response。&lt;/p&gt;
&lt;p&gt;抛错时还可以传递一些额外数据，这些数据会合并到错误对象上，在处理错误的地方可以从 &lt;code&gt;error&lt;/code&gt; 上获取。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;13&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-smi&quot;&gt;app&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;use&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;ctx&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
  &lt;span class=&quot;pl-smi&quot;&gt;ctx&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;throw&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;401&lt;/span&gt;, &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;access_denied&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, { user&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; { name&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;foo&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; } });
});

&lt;span class=&quot;pl-smi&quot;&gt;app&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;on&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;error&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, (&lt;span class=&quot;pl-smi&quot;&gt;err&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;ctx&lt;/span&gt;) &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
  &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;error&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;Ooops..&lt;span class=&quot;pl-cce&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;err&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;user&lt;/span&gt;);
});
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;参考&lt;/h3&gt;
</description>
<pubDate>Mon, 08 Apr 2019 15:17:00 +0000</pubDate>
<dc:creator>刘哇勇</dc:creator>
<og:description>不像 express 中在末尾处注册一个声明为 (err, req, res, next) 中间件的方式，koa 刚好相反，在开头进行注册。 app.use(async (ctx, next) =&amp;g</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Wayou/p/error_handling_in_koajs.html</dc:identifier>
</item>
<item>
<title>static 和 final 和 static final - HA_Tinker</title>
<link>http://www.cnblogs.com/HA-Tinker/p/10674226.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/HA-Tinker/p/10674226.html</guid>
<description>&lt;p&gt;众所周知，static 是静态修饰关键字:可以修饰变量,程序块,方法,类。&lt;/p&gt;
&lt;p&gt;1.修饰变量。&lt;/p&gt;
&lt;p&gt;得知:如果static修饰的是变量，则JVM会将将其分配在内存堆上，该变量就与对象无关，所有对该变量的引用都指向同一个地址。&lt;/p&gt;
&lt;p&gt;因此我们使用该变量的时候，直接指明类的静态变量，当然修饰符必须 public&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
1 public class&lt;span&gt; StaticBean {
2     public static String A = &quot;A&quot;&lt;span&gt;;
3 }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用方式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
1 public static void main(String[] args) throws&lt;span&gt; Exception{
2 &lt;span&gt;        System.out.println(StaticBean.A);
3     }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.修饰程序块，猜猜输出结果是什么?。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 1 public class&lt;span&gt; BaseTest {
 2     
 3     static&lt;span&gt;{
 4         System.out.println(&quot;B&quot;&lt;span&gt;);
 5 &lt;span&gt;    }
 6 
 7     public static void main(String[] args) throws&lt;span&gt; Exception{
 8 &lt;span&gt;        System.out.println(&quot;A&quot;);
 9 &lt;span&gt;    }
10 }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结论:JVM就会优先加载静态块中代码，因此会优先输出B，static 修饰代码块，这主要用于系统初始化。&lt;/p&gt;

&lt;p&gt;3.修饰方法：在外部调用静态方法时，可以使用&quot;类名.方法名&quot;的方式，也可以使用&quot;对象名.方法名&quot;的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象，静态方法在访问本类的成员时，只允许访问静态成员，而不允许访问实例成员变量和实例方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
public class StaticBean {&lt;br/&gt;public static String A = &quot;A&quot;;&lt;br/&gt;public String D;&lt;br/&gt;public static void getMessage(){&lt;br/&gt;System.out.println(A);&lt;br/&gt;System.out.println(D);&lt;br/&gt;}&lt;br/&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面代码,哪句是错误的,很显然。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
System.out.println(D);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4.修饰类。在我们的熟知之中，static 修饰符一般用于修饰变量，程序块，方法，但是什么时候使用static来修饰类呢？&lt;/p&gt;
&lt;p&gt;内部类。如果在外部类声明为static，程序会编译都不会过。&lt;/p&gt;
&lt;p&gt;内部类特点如下:&lt;/p&gt;
&lt;div readability=&quot;13&quot;&gt;
&lt;p&gt;1.不持有外部类的引用（普通内部类持有）&lt;br/&gt;2.可以直接创建实例，不需要先创建外部类（普通内部类需要）&lt;br/&gt;3.可以有静态成员变量、方法（普通内部类不行）和非静态成员变量、方法&lt;br/&gt;4.只可以直接访问外部类静态成员，不可以直接访问外部类的非静态成员（普通内部类可以），需要通过传入外部类引用的方式才能访问&lt;/p&gt;
5.加载一个类时，其内部类不会同时被加载。一个类被加载，当且仅当其某个静态成员（静态域、构造器、静态方法等）被调用时发生&lt;/div&gt;

&lt;p&gt;那就很简单引出，什么时候会使用静态内部类呢？ 我们来看下以下一个例子&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 1 public class&lt;span&gt; Outer {
 2     private int i = 0&lt;span&gt;;
 3 
 4     public&lt;span&gt; Outer() {
 5         i++&lt;span&gt;;
 6         System.out.println(&quot;=====init Outer &quot;+i+&quot;====&quot;&lt;span&gt;);
 7 
 8 &lt;span&gt;    }
 9 
10     public static&lt;span&gt; Outer getInstance(){
11         return&lt;span&gt; Inner.INSTANCE;
12 &lt;span&gt;    }
13     //静态内部类
14     public static class&lt;span&gt; Inner{
15         private static final Outer INSTANCE = new&lt;span&gt; Outer();
16 &lt;span&gt;    }
17 }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调用方&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
1 public class&lt;span&gt; BaseTest {
2     public static void main(String[] args) throws&lt;span&gt; Exception{
3         for(int i = 0; i &amp;lt; 1000;i++&lt;span&gt;) {
4 &lt;span&gt;            Outer.getInstance();
5 &lt;span&gt;        }
6 &lt;span&gt;    }
7 }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
=====init Outer 1====
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们总结下:&lt;/p&gt;
&lt;p&gt;由于 INSTANCE 是常量，因此只能赋值一次；它还是静态的，因此随着内部类一起加载，这种也是单例懒汉模式的一种实现方式，同时保证了线程安全。&lt;/p&gt;

&lt;p&gt;final 关键字可以用来修饰类，方法和变量&lt;/p&gt;
&lt;p&gt;1.修饰类&lt;/p&gt;
&lt;p&gt;表示该类不允许被继承，final类中的成员方法都会被隐式的指定为final方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
public final class&lt;span&gt; FinalBean {

    public  void&lt;span&gt; test(){

    }
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.修饰方法&lt;/p&gt;
&lt;p&gt;表示该方法不能被重写，一个类的private方法会隐式的被指定为final方法。&lt;/p&gt;
&lt;p&gt;以下例子SunFinalBean的test方法报错。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
public class&lt;span&gt; FinalBean {

    public final void&lt;span&gt; test(){

    }

    public class SunFinalBean extends&lt;span&gt; FinalBean{
        public void&lt;span&gt; test(){
            
        }
    }
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.修饰变量&lt;/p&gt;
&lt;p&gt;表示该变量必须初始化，且值不能改变。如果是基本类型则值不能改变，如果是引用类型，则引用地址不能改变，但是这个引用所指向的对象里面的内容还是可以改变的。&lt;/p&gt;
&lt;p&gt; 猜猜看，以下那句通不过编译器编译。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
public class&lt;span&gt; FinalBean {
    private final int i = 0&lt;span&gt;;
    private final int&lt;span&gt; j;
    private final String name = &quot;&quot;&lt;span&gt;;

    public&lt;span&gt; FinalBean(){
        j = 1&lt;span&gt;;
        this.name.concat(&quot;123&quot;&lt;span&gt;);
        this.name = &quot;123&quot;&lt;span&gt;;
    }
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这句，记住final的原理即可理解，那为什么this.name.concat(&quot;123&quot;);不会报错呢，因为底层实现是返回一个新的String对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
this.name = &quot;123&quot;;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;那static final 一起用：&lt;/p&gt;
&lt;p&gt;static修饰的属性强调它们只有一个，final修饰的属性表明是一个常数（创建后不能被修改）。static final修饰的属性表示一旦给值，就不可修改，并且可以通过类名访问。&lt;/p&gt;
&lt;p&gt;static final也可以修饰方法，表示该方法不能重写，可以在不new对象的情况下调用。&lt;/p&gt;
</description>
<pubDate>Mon, 08 Apr 2019 15:09:00 +0000</pubDate>
<dc:creator>HA_Tinker</dc:creator>
<og:description>众所周知，static 是静态修饰关键字:可以修饰变量,程序块,方法,类。 1.修饰变量。 得知:如果static修饰的是变量，则JVM会将将其分配在内存堆上，该变量就与对象无关，所有对该变量的引用都</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/HA-Tinker/p/10674226.html</dc:identifier>
</item>
<item>
<title>[C#]参数验证一种方式 - MeetYan</title>
<link>http://www.cnblogs.com/MeetYan/p/10674204.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MeetYan/p/10674204.html</guid>
<description>&lt;blockquote&gt;
&lt;ol readability=&quot;1.8564356435644&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;在调用方法的时候我们需要对输入参数进行验证，譬如非空，只能数字类型等；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;一些参数验证都是非常通用的，所以可以累积后续不断完善；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;这种写法源于之前很早看到一篇博客后续完善，具体地址忘记了，所以现在Github项目采用协议:MIT，非常抱歉；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-0.35555555555556&quot;&gt;
&lt;p&gt;GitHub地址：&lt;a href=&quot;https://github.com/YanZhiwei/MasterChief&quot;&gt;MasterChief&lt;/a&gt; &lt;a href=&quot;https://github.com/YanZhiwei/MasterChief/blob/master/MasterChief.DotNet4.Utilities/Operator/ValidateOperator.cs&quot;&gt;参数验证代码&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;欢迎Star，欢迎PR；&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;代码实现&quot;&gt;1. 代码实现&lt;/h3&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;using System;
using System.IO;
using System.Text.RegularExpressions;
using MasterChief.DotNet4.Utilities.Common;
using MasterChief.DotNet4.Utilities.Model;
 
namespace MasterChief.DotNet4.Utilities.Operator
{
    /// &amp;lt;summary&amp;gt;
    ///     参数验证帮助类
    /// &amp;lt;/summary&amp;gt;
    public static class ValidateOperator
    {
        #region Methods
 
        /// &amp;lt;summary&amp;gt;
        ///     验证初始化
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;returns&amp;gt;Validation&amp;lt;/returns&amp;gt;
        public static Validation Begin()
        {
            return null;
        }
 
        /// &amp;lt;summary&amp;gt;
        ///     需要验证的正则表达式
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;validation&quot;&amp;gt;Validation&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;checkFactory&quot;&amp;gt;委托&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;pattern&quot;&amp;gt;正则表达式&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;argumentName&quot;&amp;gt;参数名称&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;Validation&amp;lt;/returns&amp;gt;
        public static Validation Check(this Validation validation, Func&amp;lt;bool&amp;gt; checkFactory, string pattern,
            string argumentName)
        {
            return Check&amp;lt;ArgumentException&amp;gt;(validation, checkFactory,
                string.Format(ValidateResource.ParameterCheck_Match2, argumentName));
        }
 
        /// &amp;lt;summary&amp;gt;
        ///     自定义参数检查
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;typeparam name=&quot;TException&quot;&amp;gt;泛型&amp;lt;/typeparam&amp;gt;
        /// &amp;lt;param name=&quot;validation&quot;&amp;gt;Validation&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;checkedFactory&quot;&amp;gt;委托&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;message&quot;&amp;gt;自定义错误消息&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;Validation&amp;lt;/returns&amp;gt;
        /// 时间：2016/7/19 11:37
        /// 备注：
        public static Validation Check&amp;lt;TException&amp;gt;(this Validation validation, Func&amp;lt;bool&amp;gt; checkedFactory,
            string message)
            where TException : Exception
        {
            if (checkedFactory())
                return validation ?? new Validation
                {
                    IsValid = true
                };
 
            var exception = (TException) Activator.CreateInstance(typeof(TException), message);
            throw exception;
        }
 
        /// &amp;lt;summary&amp;gt;
        ///     检查指定路径的文件夹必须存在，否则抛出&amp;lt;see cref=&quot;DirectoryNotFoundException&quot; /&amp;gt;异常。
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;validation&quot;&amp;gt;Validation&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;data&quot;&amp;gt;判断数据&amp;lt;/param&amp;gt;
        /// &amp;lt;exception cref=&quot;ArgumentNullException&quot;&amp;gt;ArgumentNullException&amp;lt;/exception&amp;gt;
        /// &amp;lt;exception cref=&quot;DirectoryNotFoundException&quot;&amp;gt;DirectoryNotFoundException&amp;lt;/exception&amp;gt;
        /// &amp;lt;returns&amp;gt;Validation&amp;lt;/returns&amp;gt;
        public static Validation CheckDirectoryExist(this Validation validation, string data)
        {
            return Check&amp;lt;DirectoryNotFoundException&amp;gt;(validation, () =&amp;gt; Directory.Exists(data),
                string.Format(ValidateResource.ParameterCheck_DirectoryNotExists, data));
        }
 
        /// &amp;lt;summary&amp;gt;
        ///     检查文件类型
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;validation&quot;&amp;gt;Validation&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;actualFileExt&quot;&amp;gt;实际文件类型；eg: .xls&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;expectFileExt&quot;&amp;gt;期待文件类型&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public static Validation CheckedFileExt(this Validation validation, string actualFileExt,
            string[] expectFileExt)
        {
            var allowFileExts = expectFileExt.ToString(&quot;,&quot;);
            return Check&amp;lt;FileNotFoundException&amp;gt;(validation, () =&amp;gt; expectFileExt.ContainIgnoreCase(actualFileExt),
                string.Format(ValidateResource.ParameterCheck_FileExtCompare, allowFileExts));
        }
 
        /// &amp;lt;summary&amp;gt;
        ///     检查文件类型
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;validation&quot;&amp;gt;Validation&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;actualFileExt&quot;&amp;gt;实际文件类型；eg: .xls&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;expectFileExt&quot;&amp;gt;期待文件类型&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public static Validation CheckedFileExt(this Validation validation, string actualFileExt, string expectFileExt)
        {
            return Check&amp;lt;FileNotFoundException&amp;gt;(validation, () =&amp;gt; actualFileExt.CompareIgnoreCase(expectFileExt),
                string.Format(ValidateResource.ParameterCheck_FileExtCompare, expectFileExt));
        }
 
        /// &amp;lt;summary&amp;gt;
        ///     检查指定路径的文件必须存在，否则抛出&amp;lt;see cref=&quot;FileNotFoundException&quot; /&amp;gt;异常。
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;validation&quot;&amp;gt;Validation&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;data&quot;&amp;gt;参数&amp;lt;/param&amp;gt;
        /// &amp;lt;exception cref=&quot;ArgumentNullException&quot;&amp;gt;当文件路径为null时&amp;lt;/exception&amp;gt;
        /// &amp;lt;exception cref=&quot;FileNotFoundException&quot;&amp;gt;当文件路径不存在时&amp;lt;/exception&amp;gt;
        /// &amp;lt;returns&amp;gt;Validation&amp;lt;/returns&amp;gt;
        public static Validation CheckFileExists(this Validation validation, string data)
        {
            return Check&amp;lt;FileNotFoundException&amp;gt;(validation, () =&amp;gt; File.Exists(data),
                string.Format(ValidateResource.ParameterCheck_FileNotExists, data));
        }
 
        /// &amp;lt;summary&amp;gt;
        ///     检查参数必须大于[或可等于，参数canEqual]指定值，否则抛出&amp;lt;see cref=&quot;ArgumentOutOfRangeException&quot; /&amp;gt;异常。
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;typeparam name=&quot;T&quot;&amp;gt;参数类型。&amp;lt;/typeparam&amp;gt;
        /// &amp;lt;param name=&quot;validation&quot;&amp;gt;Validation&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;value&quot;&amp;gt;判断数据&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;paramName&quot;&amp;gt;参数名称。&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;target&quot;&amp;gt;要比较的值。&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;canEqual&quot;&amp;gt;是否可等于。&amp;lt;/param&amp;gt;
        /// &amp;lt;exception cref=&quot;ArgumentOutOfRangeException&quot;&amp;gt;ArgumentOutOfRangeException&amp;lt;/exception&amp;gt;
        /// &amp;lt;returns&amp;gt;Validation&amp;lt;/returns&amp;gt;
        public static Validation CheckGreaterThan&amp;lt;T&amp;gt;(this Validation validation, T value, string paramName, T target,
            bool canEqual)
            where T : IComparable&amp;lt;T&amp;gt;
        {
            // bool flag = canEqual ? value.CompareTo(target) &amp;gt;= 0 : value.CompareTo(target) &amp;gt; 0;
            var format = canEqual
                ? ValidateResource.ParameterCheck_NotGreaterThanOrEqual
                : ValidateResource.ParameterCheck_NotGreaterThan;
            return Check&amp;lt;ArgumentOutOfRangeException&amp;gt;(validation,
                () =&amp;gt; canEqual ? value.CompareTo(target) &amp;gt;= 0 : value.CompareTo(target) &amp;gt; 0,
                string.Format(format, paramName, target));
        }
 
        /// &amp;lt;summary&amp;gt;
        ///     检查参数必须小于[或可等于，参数canEqual]指定值，否则抛出&amp;lt;see cref=&quot;ArgumentOutOfRangeException&quot; /&amp;gt;异常。
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;typeparam name=&quot;T&quot;&amp;gt;参数类型。&amp;lt;/typeparam&amp;gt;
        /// &amp;lt;param name=&quot;validation&quot;&amp;gt;Validation&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;value&quot;&amp;gt;判断数据&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;paramName&quot;&amp;gt;参数名称。&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;target&quot;&amp;gt;要比较的值。&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;canEqual&quot;&amp;gt;是否可等于。&amp;lt;/param&amp;gt;
        /// &amp;lt;exception cref=&quot;ArgumentOutOfRangeException&quot;&amp;gt;ArgumentOutOfRangeException&amp;lt;/exception&amp;gt;
        /// &amp;lt;returns&amp;gt;Validation&amp;lt;/returns&amp;gt;
        public static Validation CheckLessThan&amp;lt;T&amp;gt;(this Validation validation, T value, string paramName, T target,
            bool canEqual)
            where T : IComparable&amp;lt;T&amp;gt;
        {
            var format = canEqual
                ? ValidateResource.ParameterCheck_NotLessThanOrEqual
                : ValidateResource.ParameterCheck_NotLessThan;
            return Check&amp;lt;ArgumentOutOfRangeException&amp;gt;(validation,
                () =&amp;gt; canEqual ? value.CompareTo(target) &amp;lt;= 0 : value.CompareTo(target) &amp;lt; 0,
                string.Format(format, paramName, target));
        }
 
        /// &amp;lt;summary&amp;gt;
        ///     验证是否在范围内
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;validation&quot;&amp;gt;Validation&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;data&quot;&amp;gt;输入项&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;min&quot;&amp;gt;最小值&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;max&quot;&amp;gt;最大值&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;argumentName&quot;&amp;gt;参数名称&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;Validation&amp;lt;/returns&amp;gt;
        public static Validation InRange(this Validation validation, int data, int min, int max, string argumentName)
        {
            return Check&amp;lt;ArgumentOutOfRangeException&amp;gt;(validation, () =&amp;gt; data &amp;gt;= min &amp;amp;&amp;amp; data &amp;lt;= max,
                string.Format(ValidateResource.ParameterCheck_Between, argumentName, min, max));
        }
 
        /// &amp;lt;summary&amp;gt;
        ///     是否是中文
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;validation&quot;&amp;gt;Validation&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;data&quot;&amp;gt;中文&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;argumentName&quot;&amp;gt;参数名称&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;Validation&amp;lt;/returns&amp;gt;
        public static Validation IsChinses(this Validation validation, string data, string argumentName)
        {
            return Check(validation, () =&amp;gt; CheckHelper.IsChinses(data), RegexPattern.ChineseCheck, argumentName);
        }
 
        /// &amp;lt;summary&amp;gt;
        ///     是否是电子邮箱
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;validation&quot;&amp;gt;Validation&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;email&quot;&amp;gt;需要验证的邮箱&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;argumentName&quot;&amp;gt;参数名称&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;Validation&amp;lt;/returns&amp;gt;
        public static Validation IsEmail(this Validation validation, string email, string argumentName)
        {
            return Check(validation, () =&amp;gt; CheckHelper.IsEmail(email), RegexPattern.EmailCheck, argumentName);
        }
 
        /// &amp;lt;summary&amp;gt;
        ///     是否是文件路径
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;validation&quot;&amp;gt;Validation&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;data&quot;&amp;gt;路径&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;Validation&amp;lt;/returns&amp;gt;
        public static Validation IsFilePath(this Validation validation, string data)
        {
            return Check&amp;lt;ArgumentException&amp;gt;(validation, () =&amp;gt; CheckHelper.IsFilePath(data),
                string.Format(ValidateResource.ParameterCheck_IsFilePath, data));
        }
 
        /// &amp;lt;summary&amp;gt;
        ///     是否是十六进制字符串
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;validation&quot;&amp;gt;Validation&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;data&quot;&amp;gt;验证数据&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;argumentName&quot;&amp;gt;参数名称&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;Validation&amp;lt;/returns&amp;gt;
        public static Validation IsHexString(this Validation validation, string data, string argumentName)
        {
            return Check(validation, () =&amp;gt; CheckHelper.IsHexString(data), RegexPattern.HexStringCheck, argumentName);
        }
 
        /// &amp;lt;summary&amp;gt;
        ///     是否是身份证号码
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;validation&quot;&amp;gt;Validation&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;data&quot;&amp;gt;验证数据&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;argumentName&quot;&amp;gt;参数名称&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;Validation&amp;lt;/returns&amp;gt;
        public static Validation IsIdCard(this Validation validation, string data, string argumentName)
        {
            return Check(validation, () =&amp;gt; CheckHelper.IsIdCard(data), RegexPattern.IdCardCheck, argumentName);
        }
 
        /// &amp;lt;summary&amp;gt;
        ///     是否是整数
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;validation&quot;&amp;gt;Validation&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;data&quot;&amp;gt;需要检测的字符串&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;argumentName&quot;&amp;gt;参数名称&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;Validation&amp;lt;/returns&amp;gt;
        public static Validation IsInt(this Validation validation, string data, string argumentName)
        {
            return Check(validation, () =&amp;gt; CheckHelper.IsInt(data), RegexPattern.IntCheck, argumentName);
        }
 
        /// &amp;lt;summary&amp;gt;
        ///     是否是IP
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;validation&quot;&amp;gt;Validation&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;data&quot;&amp;gt;需要检测到IP&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;argumentName&quot;&amp;gt;参数名称&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;Validation&amp;lt;/returns&amp;gt;
        public static Validation IsIp(this Validation validation, string data, string argumentName)
        {
            return Check(validation, () =&amp;gt; CheckHelper.IsIp4Address(data), RegexPattern.IpCheck, argumentName);
        }
 
        /// &amp;lt;summary&amp;gt;
        ///     是否是数字
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;validation&quot;&amp;gt;Validation&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;data&quot;&amp;gt;需要检测的字符串&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;argumentName&quot;&amp;gt;参数名称&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;Validation&amp;lt;/returns&amp;gt;
        public static Validation IsNumber(this Validation validation, string data, string argumentName)
        {
            return Check(validation, () =&amp;gt; CheckHelper.IsNumber(data), RegexPattern.NumberCheck, argumentName);
        }
 
        /// &amp;lt;summary&amp;gt;
        ///     是否是合法端口
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;validation&quot;&amp;gt;Validation&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;data&quot;&amp;gt;参数值&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;paramName&quot;&amp;gt;参数名称&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;Validation&amp;lt;/returns&amp;gt;
        public static Validation IsPort(this Validation validation, string data, string paramName)
        {
            return Check&amp;lt;ArgumentException&amp;gt;(validation, () =&amp;gt; CheckHelper.IsValidPort(data),
                string.Format(ValidateResource.ParameterCheck_Port, paramName));
        }
 
        /// &amp;lt;summary&amp;gt;
        ///     是否是邮政编码
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;validation&quot;&amp;gt;Validation&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;data&quot;&amp;gt;邮政编码&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;argumentName&quot;&amp;gt;参数名称&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;Validation&amp;lt;/returns&amp;gt;
        public static Validation IsPoseCode(this Validation validation, string data, string argumentName)
        {
            return Check(validation, () =&amp;gt; CheckHelper.IsPoseCode(data), RegexPattern.PostCodeCheck, argumentName);
        }
 
        /// &amp;lt;summary&amp;gt;
        ///     判断字符串是否是要求的长度
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;validation&quot;&amp;gt;Validation&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;input&quot;&amp;gt;验证的字符串&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;requireLength&quot;&amp;gt;要求的长度&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;argumentName&quot;&amp;gt;参数名称&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;Validation&amp;lt;/returns&amp;gt;
        public static Validation IsRequireLen(this Validation validation, string input, int requireLength,
            string argumentName)
        {
            return Check&amp;lt;ArgumentException&amp;gt;(
                validation,
                () =&amp;gt; input.Length == requireLength,
                string.Format(ValidateResource.ParameterCheck_StringLength, argumentName, requireLength));
        }
 
        /// &amp;lt;summary&amp;gt;
        ///     判断类型是否能序列化
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;validation&quot;&amp;gt;Validation&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;data&quot;&amp;gt;输入项&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;Validation&amp;lt;/returns&amp;gt;
        /// 时间：2016-01-14 9:57
        /// 备注：
        public static Validation IsSerializable(this Validation validation, object data)
        {
            return Check&amp;lt;ArgumentException&amp;gt;(validation, () =&amp;gt; data.GetType().IsSerializable,
                $&quot;该参数类型{data.GetType().FullName}不能序列化！&quot;);
        }
 
        /// &amp;lt;summary&amp;gt;
        ///     是否是URL
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;validation&quot;&amp;gt;Validation&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;data&quot;&amp;gt;url&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;argumentName&quot;&amp;gt;参数名称&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;Validation&amp;lt;/returns&amp;gt;
        public static Validation IsUrl(this Validation validation, string data, string argumentName)
        {
            return Check(validation, () =&amp;gt; CheckHelper.IsURL(data), RegexPattern.UrlCheck, argumentName);
        }
 
        /// &amp;lt;summary&amp;gt;
        ///     验证参数不能等于某个值
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;validation&quot;&amp;gt;Validation&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;data&quot;&amp;gt;输入项&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;equalObj&quot;&amp;gt;比较项&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;argumentName&quot;&amp;gt;参数名称&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;Validation&amp;lt;/returns&amp;gt;
        public static Validation NotEqual(this Validation validation, object data, object equalObj, string argumentName)
        {
            return Check&amp;lt;ArgumentException&amp;gt;(validation, () =&amp;gt; data != equalObj,
                string.Format(ValidateResource.ParameterCheck_NotEqual, argumentName, data));
        }
 
        /// &amp;lt;summary&amp;gt;
        ///     验证非空
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;validation&quot;&amp;gt;Validation&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;data&quot;&amp;gt;输入项&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;argumentName&quot;&amp;gt;参数名称&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;Validation&amp;lt;/returns&amp;gt;
        public static Validation NotNull(this Validation validation, object data, string argumentName)
        {
            return Check&amp;lt;ArgumentNullException&amp;gt;(validation, () =&amp;gt; CheckHelper.NotNull(data),
                string.Format(ValidateResource.ParameterCheck_NotNull, argumentName));
        }
 
        /// &amp;lt;summary&amp;gt;
        ///     不能为空或者NULL验证
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;validation&quot;&amp;gt;Validation&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;input&quot;&amp;gt;输入项&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;argumentName&quot;&amp;gt;参数名称&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;Validation&amp;lt;/returns&amp;gt;
        public static Validation NotNullOrEmpty(this Validation validation, string input, string argumentName)
        {
            return Check&amp;lt;ArgumentNullException&amp;gt;(validation, () =&amp;gt; !string.IsNullOrEmpty(input),
                string.Format(ValidateResource.ParameterCheck_NotNullOrEmpty_String, argumentName));
        }
 
        /// &amp;lt;summary&amp;gt;
        ///     需要验证的正则表达式
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;validation&quot;&amp;gt;Validation&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;input&quot;&amp;gt;需要匹配的输入项&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;pattern&quot;&amp;gt;正则表达式&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;argumentName&quot;&amp;gt;参数名称&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;Validation&amp;lt;/returns&amp;gt;
        public static Validation RegexMatch(this Validation validation, string input, string pattern,
            string argumentName)
        {
            return Check&amp;lt;ArgumentException&amp;gt;(validation, () =&amp;gt; Regex.IsMatch(input, pattern),
                string.Format(ValidateResource.ParameterCheck_Match, input, argumentName));
        }
 
        #endregion Methods
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;使用方法&quot;&gt;2. 使用方法&lt;/h3&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;        public IEnumerable&amp;lt;T&amp;gt; SqlQuery&amp;lt;T&amp;gt;(string sql, IDbDataParameter[] parameters)
        {
            ValidateOperator.Begin()
                .NotNullOrEmpty(sql, &quot;Sql语句&quot;)
                .NotNull(parameters, &quot;sql对应参数&quot;);
            var dataParameters = CreateParameter(parameters);
            return CurrentConnection.Query&amp;lt;T&amp;gt;(sql, dataParameters, CurrentTransaction);
        }&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 08 Apr 2019 15:05:00 +0000</pubDate>
<dc:creator>MeetYan</dc:creator>
<og:description>1. 在调用方法的时候我们需要对输入参数进行验证，譬如非空，只能数字类型等； 2. 一些参数验证都是非常通用的，所以可以累积后续不断完善； 3. 这种写法源于之前很早看到一篇博客后续完善，具体地址忘记</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/MeetYan/p/10674204.html</dc:identifier>
</item>
<item>
<title>Vue 父子组件传值 props - Company</title>
<link>http://www.cnblogs.com/fandong90/p/10674195.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fandong90/p/10674195.html</guid>
<description>&lt;p&gt;     1、Vue 的渲染周期：&lt;/p&gt;
&lt;p&gt;      &lt;img src=&quot;https://cn.vuejs.org/images/lifecycle.png&quot; alt=&quot;vue生命周期&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/699403/201904/699403-20190408224535616-886199146.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;                          vue 如何实现响应式追踪。&lt;/p&gt;
&lt;p&gt;                  &lt;img src=&quot;https://img2018.cnblogs.com/blog/699403/201904/699403-20190408224222780-790582460.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　　　　　父子组件通信有很多方式，今天单独聊下props 的方式。我们通过查找官方文档很容发现，props传值有静态和动态两种传值方式。&lt;/p&gt;
&lt;p&gt;                  当然props 还提供许多验证，使数据更加严谨。&lt;/p&gt;
&lt;p&gt;                  在使用父子传值时，出现了, 按照文档说明，例如：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &amp;lt;template&amp;gt;
&lt;span&gt; 2&lt;/span&gt;     &amp;lt;div v-&lt;span&gt;if&lt;/span&gt;=&quot;data&quot;&amp;gt;&lt;span&gt;{{parentName}}
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         
&lt;span&gt; 4&lt;/span&gt;         &amp;lt;input type=&quot;text&quot;  v-model=&quot;parentName&quot; /&amp;gt;
&lt;span&gt; 5&lt;/span&gt;     &amp;lt;/div&amp;gt;
&lt;span&gt; 6&lt;/span&gt; &amp;lt;/template&amp;gt;
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &amp;lt;script&amp;gt;
&lt;span&gt; 9&lt;/span&gt; export &lt;span&gt;default&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt; props:{
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;     parentName:String 
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt; },
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt; data(){
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         data:&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.parentName
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt; },
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;  
&lt;span&gt;19&lt;/span&gt; &lt;span&gt; beforeCreate(){
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;      console.log(&quot;child beforeCreate&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt; },
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt; created(){
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;      console.log(&quot;child created&quot;+&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.parentName);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt; },
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt; mounted(){
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;      console.log(&quot;child data Mounted&quot;+&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.parentName);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt; },
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt; beforeMount(){
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;      console.log(&quot;beforeMount data&quot;+&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.parentName);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt; },
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt; beforeUpdate(){
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;      console.log(&quot;beforeUpdate data&quot;+&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.parentName)
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt; }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &amp;lt;/script&amp;gt;
&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt; &amp;lt;style&amp;gt;
&lt;span&gt;39&lt;/span&gt; 
&lt;span&gt;40&lt;/span&gt; &amp;lt;/style&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;父组件引用：&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:javascript;collapse:true;;gutter:true;&quot;&gt;
&amp;lt;template&amp;gt;
    &amp;lt;div&amp;gt;    &amp;lt;child  :parent-name=&quot;name&quot;/&amp;gt;
    &amp;lt;input   type=&quot;text&quot; v-model=&quot;name&quot; /&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
import child from './child.vue'
export default {
   components:{
       child
   },
   data(){
       return {
           name:&quot;asda&quot;
       }
   },
   beforeCreate(){
       console.log(&quot;parent beforeCreate&quot;)
   },
   created(){
       console.log(&quot;parent created&quot;)
       
   },
   beforeMount(){
       console.log(&quot;parent beforeMount&quot;)
   },
   mounted(){
       console.log(&quot; parent mounted&quot;)
        this.name=&quot;hahshdf&quot;
   }
}
&amp;lt;/script&amp;gt;

&amp;lt;style&amp;gt;

&amp;lt;/style&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　突然想到，这个父子组件渲染的顺序如何，如上述代码，&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/699403/201904/699403-20190408225141235-78861052.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;     如图所示，渲染顺序是从子组件先挂载后，父组件在挂载。这个渲染顺序可以决定我何时传值，比较。&lt;/p&gt;
&lt;p&gt;     从执行渲染顺序来说，给子组件的props 中赋值，应该在父组件挂载前，最好是在子组件创建前即 beforeCreate 方法后，赋值。 切不可在beforeCreate 赋值，会导致未定义错误。&lt;/p&gt;
&lt;p&gt;    如果在父组件挂载后，赋值会出现什么情况呢。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/699403/201904/699403-20190408225704126-2073631657.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  没错，和你猜想的很对，会触发子组件的更新事件，会导致局部在渲染。&lt;/p&gt;
&lt;p&gt;  看文档提示，一般的props 传值，可以作为data（）方法的中return的初始值使用，在作为初始值使用时，切记&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
data(){
    return {
        data:this.propsValue
        }
   }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这个是从新返回一个新值，this.propsValue 改变不会再影响data 的值。&lt;/p&gt;
&lt;p&gt;     最后说一句，现在vue 是单向的数据流，即 改变父组件中的值，可以影响子组件的值，但是改变子组件的值，父组件的值不变。&lt;/p&gt;



</description>
<pubDate>Mon, 08 Apr 2019 15:02:00 +0000</pubDate>
<dc:creator>Company</dc:creator>
<og:description>1、Vue 的渲染周期： vue 如何实现响应式追踪。 父子组件通信有很多方式，今天单独聊下props 的方式。我们通过查找官方文档很容发现，props传值有静态和动态两种传值方式。 当然props</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fandong90/p/10674195.html</dc:identifier>
</item>
<item>
<title>Redis 缓存应用实战 - -Finley-</title>
<link>http://www.cnblogs.com/Finley/p/10674101.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Finley/p/10674101.html</guid>
<description>&lt;p&gt;为了提高系统吞吐量，我们经常在业务架构中引入缓存层。&lt;/p&gt;
&lt;p&gt;缓存通常使用 Redis / Memcached 等高性能内存缓存来实现, 本文以 Redis 为例讨论缓存应用中面临的一些问题。&lt;/p&gt;

&lt;p&gt;当执行写操作后，需要保证从缓存读取到的数据与数据库中持久化的数据是一致的，因此需要对缓存进行更新。&lt;/p&gt;
&lt;p&gt;因为涉及到数据库和缓存两步操作，难以保证更新的原子性。&lt;/p&gt;
&lt;p&gt;在设计更新策略时，我们需要考虑多个方面的问题:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对系统吞吐量的影响：比如更新缓存会比删除缓存减少数据库查询压力&lt;/li&gt;
&lt;li&gt;并发安全性：并发读写时某些异常操作顺序可能造成数据不一致(缓存中长期存储旧数据)&lt;/li&gt;
&lt;li&gt;更新失败的影响：若执行过程中某个操作失败，如何对业务影响降到最小&lt;/li&gt;
&lt;li&gt;检测和修复故障的难度: 并发问题导致缓存中存储旧数据比操作失败导致的数据更难检测&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;一般来说操作失败出现的概率较小，且通常会在日志中留下较为详细的信息比较容易修复数据。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;而并发异常造成的数据不一致则非常难以检测，且多在流量高峰时发生可能造成较多数据不一致，需要更加重视。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;并发异常通常由于后开始的线程却先完成操作导致，我们可以把这种现象称为“抢跑”。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;更新缓存有两种方式:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;删除失效缓存: 读取时会因为未命中缓存而从数据库中读取新的数据并更新到缓存中&lt;/li&gt;
&lt;li&gt;更新缓存: 直接将新的数据写入缓存覆盖过期数据&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;更新缓存和更新数据库有两种顺序：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;先数据库后缓存&lt;/li&gt;
&lt;li&gt;先缓存后数据库&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;两两组合共有四种更新策略，现在我们逐一进行分析。&lt;/p&gt;
&lt;p&gt;四种策略都存在问题，一般来说先更新数据库再删除缓存是四种策略中一致性最好的策略，但仍需具体场景具体分析选择。&lt;/p&gt;
&lt;h2 id=&quot;先更新数据库再删除缓存&quot;&gt;先更新数据库，再删除缓存&lt;/h2&gt;
&lt;p&gt;若数据库更新成功，删除缓存操作失败，则此后读到的都是缓存中过期的数据，造成不一致问题。&lt;/p&gt;
&lt;p&gt;缓存操作失败在会在日志中留下错误信息，在系统恢复正常后比较容易检测和修复数据。&lt;/p&gt;
&lt;p&gt;若线程A试图读取某个数据而缓存未命中，在线程A读取数据库后写入缓存前，线程B完成了更新操作。此时，缓存中仍是旧数据，导致与数据库不一致。&lt;/p&gt;
&lt;p&gt;对于 list、hash 或计数器等缓存来说，更新缓存实现难度较大(且难以保证一致性)而重建缓存的难度较低，此时采用后删除缓存的策略较好。&lt;/p&gt;
&lt;p&gt;因为缓存删除后读操作会直接访问数据库，可能对数据库造成很大压力。这一问题在热点数据上非常明显。比如热门文章的阅读数或者某个大V的粉丝数，它们的读写都非常频繁。&lt;/p&gt;
&lt;p&gt;当缓存被清除后，线程A会读取数据库试图重建缓存，在重建完成前线程B也试图读取该数据。此时线程B缓存未命中而去读取数据库，从而给数据库带来不必要的压力。&lt;/p&gt;
&lt;p&gt;对于热点数据，若即时性和一致性要求较低时建议采用延迟更新的策略，若一致性要求略高则采用加(分布式)锁的方式。&lt;/p&gt;
&lt;h2 id=&quot;先更新数据库再更新缓存&quot;&gt;先更新数据库，再更新缓存&lt;/h2&gt;
&lt;p&gt;同删除缓存策略一样，若数据库更新成功缓存更新失败则会造成数据不一致问题。&lt;/p&gt;
&lt;p&gt;缓存更新失败的问题较为少见且比较容易处理，但后更新缓存的模式存在难以解决的并发问题。&lt;/p&gt;
&lt;p&gt;若线程A试图写入数据a, 随后线程B试图将该数据更新为b。若线程B后完成了数据库的写入, 但却抢在线程A之前完成了缓存更新。此时数据库中值为b(线程B后提交事务), 而缓存中值为a(线程A后写入缓存), 为不一致状态。&lt;/p&gt;
&lt;h2 id=&quot;先删除缓存再更新数据库&quot;&gt;先删除缓存，再更新数据库&lt;/h2&gt;
&lt;p&gt;若数据库写入延时较大，此种方案可能出现风险。 考虑这样的情景:&lt;/p&gt;
&lt;p&gt;若线程A试图更新数据, 线程B在线程A删除缓存后、提交数据库事务前尝试读取该数据。则因为数据库未更新，线程B从数据库中读出旧数据写入缓存中, 导致缓存中一直是旧数据。&lt;/p&gt;
&lt;h2 id=&quot;先更新缓存再更新数据库&quot;&gt;先更新缓存，再更新数据库&lt;/h2&gt;
&lt;p&gt;若缓存更新成功数据库更新失败， 则此后读到的都是未持久化的数据。因为缓存中的数据是易失的，这种状态非常危险。&lt;/p&gt;
&lt;p&gt;因为数据库因为键约束导致写入失败的可能性较高，所以这种策略风险较大。&lt;/p&gt;
&lt;h2 id=&quot;异步更新&quot;&gt;异步更新&lt;/h2&gt;
&lt;p&gt;双写更新的逻辑复杂，一致性问题较多。现在我们可以采用订阅数据库更新的方式来更新缓存。&lt;/p&gt;
&lt;p&gt;阿里巴巴开源了mysql数据库binlog的增量订阅和消费组件 - &lt;a href=&quot;https://github.com/alibaba/canal&quot;&gt;canal&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;我们可以采用API服务器只写入数据库，而另一个线程订阅数据库 binlog 增量进行缓存更新，则可以轻松地保证缓存更新顺序与数据事务提交顺序一致。&lt;/p&gt;

&lt;p&gt;为了避免无效数据占用缓存，我们通常不会在缓存中存储空对象，但这种策略会造成缓存穿透问题。&lt;/p&gt;
&lt;p&gt;若要查询的数据不存在，那么当然不可能从缓存中查到这个数据，按照缓存未命中即访问数据库的逻辑，所有对不存在数据的查询都会到达数据库，这种现象称作缓存穿透。&lt;/p&gt;
&lt;p&gt;为了减少无意义的数据库访问，我们可以缓存表示数据不存在的占位符。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通常来说访问已被删除的对象造成缓存穿透的概率较高, 因此删除数据时应在缓存中放置表示已被删除占位符。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;另一种常见的缓存穿透场景是访问集合式缓存&lt;/strong&gt;，比如访问没有评论的文章的评论页，或者未发表过文章的用户主页。这种场景可以使用占位符避免缓存穿透, 也可以先检查缓存中的评论计数器或文章计数器防止缓存穿透。&lt;/p&gt;

&lt;p&gt;Redis 提供了 List、Hash、Set 和 SortedSet 等数据结构，我们可以将其称为集合式缓存。&lt;/p&gt;
&lt;p&gt;集合式缓存通常更新的逻辑较为复杂(或者难以保证一致性)而重建逻辑较为简单，同时重建缓存时也可能带来更大的数据库压力。&lt;/p&gt;
&lt;p&gt;计数器式缓存同样具有更新逻辑复杂、重建简单但重建缓存时数据库压力大的特点，因此作者也将其归入集合式缓存。计数器的复杂度在计数的对象状态机复杂时尤为明显，如计数某个用户公开文章和全部文章数。&lt;/p&gt;
&lt;p&gt;以文章的评论列表为例，当 Redis 缓存中评论列表为空时，可能有两种原因:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;缓存未命中&lt;/li&gt;
&lt;li&gt;评论列表确实为空&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;除了上一节提到的防止缓存击穿外，更新缓存的逻辑也需要分别处理两种情况&lt;/strong&gt;。若缓存未命中而直接插入新评论，则可能导致评论列表中只有这一条新评论而没有更早评论的情况。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;作者建议集合式缓存中元素应为不可变的对象或对象ID&lt;/strong&gt;。仍以评论列表为例，若在 List 或 SortedSet 中直接存储序列化后的评论对象，则只有知道对象的全部字段才能定位该评论。&lt;/p&gt;
&lt;p&gt;在修改评论后，我们难以获得原评论的内容定位或修改的难度较高。若某条评论存在于多个集合式缓存中，则需要多处修改。&lt;/p&gt;
&lt;p&gt;此外，完整的评论对象字节数远大于ID, 在需要多处存储时使用ID可以节省大量内存。&lt;/p&gt;

&lt;p&gt;在上文中提到过，当线程A缓存未命中时会尝试从数据库读取数据以重建缓存。若在线程A重建缓存完成前，线程B尝试读取该数据同样会发生缓存未命中，导致重复读取数据库，造成数据库资源浪费。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;若重建过程涉及较多操作 Redis 无法保证其原子性时，我们同样也需要使用加锁的方式保证重建操作的原子性避免并发异常&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;check-lock-check&quot;&gt;Check-Lock-Check&lt;/h2&gt;
&lt;p&gt;重建问题与单例模式中多线程同时调用 getInstance() 方法导致对象被重复创建的问题类似，我们同样可以采用 Check-Lock-Check 模式解决。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;即当线程缓存未命中后阻塞试图加(分布式)锁，成功获得锁后再次检查缓存是否已被创建。若缓存仍未被重建则进入读数据库重建流程&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;事务&quot;&gt;事务&lt;/h2&gt;
&lt;p&gt;同样的，使用 Watch 命令监视要重建的 KEY 并使用 Multi 命令开始事务重建该缓存。Redis 事务也可以达到避免重复建立的目的，但是无法避免重复读取数据库，且在集群条件下 Redis 事务可能受到较多限制。&lt;/p&gt;
&lt;p&gt;使用 Redis 事务进行重建的示例:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; WATCH a
OK
127.0.0.1:6379&amp;gt; MULTI
OK
127.0.0.1:6379&amp;gt; set a 1
QUEUED
127.0.0.1:6379&amp;gt; EXEC
1) OK&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;开启两个客户端模拟竞争的情况:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;client-1&amp;gt; WATCH b
OK
client-1&amp;gt; MULTI
OK
client-1&amp;gt; set b 2
QUEUED
client-2&amp;gt; set b 1
OK
client-1&amp;gt; EXEC
(nil)&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;乐观锁&quot;&gt;乐观锁&lt;/h2&gt;
&lt;p&gt;如果说上文通过加锁的方式避免并发问题可以认为是悲观锁的思路，对于写入竞争不激烈的场景可以使用 RENAMENX 命令来实现乐观锁。&lt;/p&gt;
&lt;p&gt;当需要重建缓存时，我们需要创建一个临时的键并在其上完成重建操作, 因为临时键只有一个线程访问，无需担心原子性和各种并发问题。&lt;/p&gt;
&lt;p&gt;重建完成后使用 RENAMENX 或 RENAME 命令原子性地将其重命名为正式的键提供给所有线程访问。&lt;/p&gt;
&lt;h2 id=&quot;离线数据处理&quot;&gt;离线数据处理&lt;/h2&gt;
&lt;p&gt;我们可以将脏数据放入 SET 或 HASH 中以进行离线更新。如上文提到的热门文章的访问数，我们可以使用 HINCRBY 命令将文章ID及其访问数增量放入 HASH 表中， 使用 HSCAN 命令单线程的遍历，将增量持久化到数据库或线上缓存。&lt;/p&gt;
&lt;p&gt;需要注意的问题是: 在 HSCAN 命令扫描 HASH 表的过程中, 该 HASH 表内容发生变化可能导致并发问题。特别是当 HSCAN 命令执行过程中新增 field 可能导致重复访问。&lt;/p&gt;
&lt;p&gt;因此我们需要将线上脏数据 Hash 重命名到临时键中，在不会发生改变的临时键中单线程的进行遍历。&lt;/p&gt;
&lt;p&gt;HSCAN 和 SSCAN 命令遍历的过程较长，遍历线程可能会被中断。若担心数据丢失，则可以按一定规则生成临时键, 这样可以方便检查有哪些临时键尚未被消费完毕。&lt;/p&gt;
&lt;h2 id=&quot;临时键的生成&quot;&gt;临时键的生成&lt;/h2&gt;
&lt;p&gt;在集群环境中，可能仅支持相同 Slot 下的 RENAME 和 RENAMENX 命令。因此， 我们可以使用 HashKey 机制保证临时键和原键在同一个Slot中。&lt;/p&gt;
&lt;p&gt;若原键为 &quot;original&quot; 我们则可以生成临时键为 &quot;{original}-1&quot;, 花括号表示仅由花括号内部的子串进行哈希来决定 Slot, &quot;{original}-1&quot; 一定会与 &quot;original&quot; 处于相同 Slot 中。&lt;/p&gt;
&lt;p&gt;使用临时键的目的是为了单线程的进行操作避免并发问题，因此务必检查临时键是否已被其它线程占用。&lt;/p&gt;
&lt;p&gt;临时键有两种生成策略:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;原键加随机值: 如 &quot;{original}-kGi3X1&quot;, 这种方法的优点是随机键冲突的概率较小但是难以扫描库中有哪些临时键&lt;/li&gt;
&lt;li&gt;原键加计数器: 如 &quot;{original}-1&quot;、&quot;{original}-2&quot;, 这种方法的有点是容易扫描库中有哪些临时键可以用于离线数据处理，但是冲突的概率较高&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;SortedSet 作为 Redis 中唯一的可排序和可范围查找的数据结构可以进行一些比较灵活的应用。&lt;/p&gt;
&lt;h2 id=&quot;延时队列&quot;&gt;延时队列&lt;/h2&gt;
&lt;p&gt;在对一致性没有较高要求的场景可以使用 SortedSet 充当延时队列，将消息的内容作为 member, 预定执行时间的UNIX时间戳作为 score。&lt;/p&gt;
&lt;p&gt;调用 ZRANGEBYSCORE 方法轮询预定执行时间早于当前时间的消息并发送给 Msg Consumer 处理。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; ZADD DelayQueue 155472822 msg
(integer) 1
127.0.0.1:6379&amp;gt; ZRANGEBYSCORE DelayQueue 0 1554728933 WITHSCORES
1) &quot;msg&quot;
2) &quot;1554728822&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;必要时可以选用富类型 Java 客户端 Redisson 提供的 RDelayedQueue, 它实现了更完善的延时队列。&lt;/p&gt;
&lt;p&gt;由于 Redis 持久化机制等原因，任何基于 Redis 的队列都不可能提供高一致性的服务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;请勿在高一致性要求的业务场景下使用 Redis 做消息队列&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;滑动窗口&quot;&gt;滑动窗口&lt;/h2&gt;
&lt;p&gt;在如热搜或限流之类的业务场景中我们需要快速查询过去一小时内被搜索最多的关键词。&lt;/p&gt;
&lt;p&gt;与延时队列类似，将关键词作为 SortedSet 的 member, 发生的UNIX时间戳作为 score。&lt;/p&gt;
&lt;p&gt;使用 ZRANGEBYSCORE 命令查询某个时间段内发生的事件， ZREMRANGEBYSCORE 命令移除过旧的数据。&lt;/p&gt;

&lt;p&gt;阅读本文的读者应有一定的 Redis 缓存使用经验，因此一些基本常识放在最后以尽量避免浪费读者的时间。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;IO操作的耗时通常远高于CPU计算，尽量使用 MGET 等批量命令或 Pipeline 机制来减少 IO 时间，切勿循环进行 Redis 读写等IO操作&lt;/li&gt;
&lt;li&gt;Redis 使用IO复用模型内核单线程模式，保证命令执行原子性和串行性。(至写作时 Redis 4.0 版本仍是如此，此后很可能引入多线程内核)&lt;/li&gt;
&lt;li&gt;Redis 的RDB和AOF都采用异步持久化的模式，无法保证Redis崩溃后完全不丢失数据。 因此请勿将Redis用于一致性要求较高的业务场景。&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Mon, 08 Apr 2019 14:43:00 +0000</pubDate>
<dc:creator>-Finley-</dc:creator>
<og:description>缓存更新一致性、缓存击穿问题、集合式缓存、缓存应用中常见的并发问题及常见应用方式的探讨</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Finley/p/10674101.html</dc:identifier>
</item>
<item>
<title>机器学习导图系列（2）：概念 - CaiYongji</title>
<link>http://www.cnblogs.com/takeurhand/p/10673731.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/takeurhand/p/10673731.html</guid>
<description>&lt;p&gt;机器学习导图系列教程旨在帮助引导开发者对机器学习知识网络有一个系统的概念，其中具体释义并未完善，需要开发者自己探索才能对具体知识有深入的掌握。本项目灵感来自Daniel Formoso的github开源项目。本文作者对其项目进行翻译、整理、批注等二次创作，其中不乏生僻的数学名词，对于没有留过学的作者来说费了很多功夫。我又将导图整理成了知识卡片，方便大家查看。由于机器学习的知识网络很大，导致完整的导图过大，文章中的图片可能经过压缩，如需完整图片可查看github项目&lt;strong&gt;machine-learning-mindmap-cn&lt;/strong&gt;下载高清原图。本系列还在持续创作中，你的点赞、留言、star都会成为我持续创作的动力。&lt;/p&gt;
&lt;p&gt;machine-learning-mindmap-cn: &lt;a href=&quot;https://github.com/caiyongji/machine-learning-mindmap-cn&quot; class=&quot;uri&quot;&gt;https://github.com/caiyongji/machine-learning-mindmap-cn&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;机器学习导图系列分为五大模块。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;机器学习数据处理&lt;/li&gt;
&lt;li&gt;机器学习概念&lt;/li&gt;
&lt;li&gt;机器学习过程&lt;/li&gt;
&lt;li&gt;机器学习算法&lt;/li&gt;
&lt;li&gt;机器学习模型及神经网络模型&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/678094/201904/678094-20190408214733911-446749586.png&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;动机&quot;&gt;动机&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/678094/201904/678094-20190408214749702-1151082908.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;性能分析&quot;&gt;性能分析&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/678094/201904/678094-20190408214759538-179574173.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;调参&quot;&gt;调参&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/678094/201904/678094-20190408214813145-1772614286.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;类型&quot;&gt;类型&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/678094/201904/678094-20190408214825313-871791813.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;种类&quot;&gt;种类&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/678094/201904/678094-20190408214832902-1044856427.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;分类&quot;&gt;分类&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/678094/201904/678094-20190408214841674-950954788.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;学习方法&quot;&gt;学习方法&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/678094/201904/678094-20190408214851813-2031573776.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;分类学&quot;&gt;分类学&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/678094/201904/678094-20190408215000261-793335995.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;选择标准&quot;&gt;选择标准&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/678094/201904/678094-20190408214907968-563007697.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;库&quot;&gt;库&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/678094/201904/678094-20190408214915397-1194944552.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;你随手就是一个赞。&lt;/p&gt;
</description>
<pubDate>Mon, 08 Apr 2019 13:49:00 +0000</pubDate>
<dc:creator>CaiYongji</dc:creator>
<og:description>机器学习导图系列教程旨在帮助引导开发者对机器学习知识网络有一个系统的概念，其中具体释义并未完善，需要开发者自己探索才能对具体知识有深入的掌握。本项目灵感来自Daniel Formoso的github开</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/takeurhand/p/10673731.html</dc:identifier>
</item>
<item>
<title>结合JDK源码看设计模式——组合模式 - 方块人</title>
<link>http://www.cnblogs.com/Cubemen/p/10673712.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Cubemen/p/10673712.html</guid>
<description>&lt;p&gt;　　相信大家都打开过层级很多很多的文件夹。如果把第一个文件夹看作是树的根节点的话，下面的子文件夹就可以看作一个子节点。不过最终我们寻找的还是文件夹中的文件，文件可以看做是叶子节点。下面我们介绍一种模式，与这种树级结构息息相关。当然，今天的主角是HashMap。接下来我们一起来看HashMap中到底是怎么跟树级结构进行挂钩的。&lt;/p&gt;

&lt;p&gt;　　将对象组合成树形结构以表示“部分-整体”的一个层次结构，使客户端对单个对象和组合对象保持一致的方式处理。&lt;/p&gt;

&lt;h3&gt;1、客户端可以忽略组合对象与单个对象的差异&lt;/h3&gt;
&lt;p&gt;　　注意组合模式中的概念，当客户端使用组合模式的时候是对单个对象和组合对象保持一致的方式处理，而不是不同的方式处理。所以如果客户端可以忽略组合对象和单个对象的差异时，才用组合模式。&lt;/p&gt;
&lt;h3&gt;2、处理一个树形结构&lt;/h3&gt;
&lt;p&gt;　　这里就很好理解了，组合模式就是处理树形结构的&lt;/p&gt;

&lt;h3&gt;　　1、抽象构件：总的抽象类或者接口，定义一些通用的方法，比如新增、删除。&lt;/h3&gt;
&lt;h3&gt;　　2、中间构件：继承或者实现抽象构件，定义&lt;span&gt;存储方式&lt;/span&gt;，并针对特殊需要重写抽象构件的方法。&lt;/h3&gt;
&lt;h3&gt;　　3、叶子节点：继承或者实现抽象构件，并针对特殊需要重写抽象构件的方法。&lt;/h3&gt;
&lt;p&gt;　　叶子节点需要实现或者继承抽象构件，如果有需要也可以添加到中间构件上。就比如说我现在进入D盘，D盘就是一个抽象构件，无论在D盘哪里，我都可以执行新建，删除操作。中间构件就相当于文件夹，里面定义了相应的存储方式，加入的文件是叶子节点，并且会按照这种方式来存储，同时这个中间构件也可以选择再加入一个其他中间构件或者自己。叶子节点就可以看作文件。注意，在组合模式下所有类都需要直接或者间接，继承或实现总的抽象构件。下面讲HashMap中的putAll()方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; HashMap&amp;lt;K,V&amp;gt; &lt;span&gt;extends&lt;/span&gt; AbstractMap&amp;lt;K,V&amp;gt;
    &lt;span&gt;implements&lt;/span&gt; Map&amp;lt;K,V&amp;gt;&lt;span&gt;, Cloneable, Serializable {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; putAll(Map&amp;lt;? &lt;span&gt;extends&lt;/span&gt; K, ? &lt;span&gt;extends&lt;/span&gt; V&amp;gt;&lt;span&gt; m) {
        putMapEntries(m, &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; putMapEntries(Map&amp;lt;? &lt;span&gt;extends&lt;/span&gt; K, ? &lt;span&gt;extends&lt;/span&gt; V&amp;gt; m, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; evict) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; s =&lt;span&gt; m.size();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (s &amp;gt; 0&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (table == &lt;span&gt;null&lt;/span&gt;) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; pre-size&lt;/span&gt;
                &lt;span&gt;float&lt;/span&gt; ft = ((&lt;span&gt;float&lt;/span&gt;)s / loadFactor) + 1.0F&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; t = ((ft &amp;lt; (&lt;span&gt;float&lt;/span&gt;)MAXIMUM_CAPACITY) ?&lt;span&gt;
                         (&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)ft : MAXIMUM_CAPACITY);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (t &amp;gt;&lt;span&gt; threshold)
                    threshold &lt;/span&gt;=&lt;span&gt; tableSizeFor(t);
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (s &amp;gt;&lt;span&gt; threshold)
                resize();
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Map.Entry&amp;lt;? &lt;span&gt;extends&lt;/span&gt; K, ? &lt;span&gt;extends&lt;/span&gt; V&amp;gt;&lt;span&gt; e : m.entrySet()) {
                K key &lt;/span&gt;=&lt;span&gt; e.getKey();
                V value &lt;/span&gt;=&lt;span&gt; e.getValue();
                putVal(hash(key), key, value, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;, evict);
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面是简化的HashMap。我们看见putAll方法传入的是Map对象，Map就是一个抽象构件（同时这个构件中只支持键值对的存储格式），而HashMap是一个中间构件，HashMap中的Node节点就是叶子节点。说到中间构件就会有规定的存储方式。HashMap中的存储方式是一个静态内部类的数组Node&amp;lt;K,V&amp;gt;[] tab。下面是简化的具体代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; HashMap&amp;lt;K,V&amp;gt; &lt;span&gt;extends&lt;/span&gt; AbstractMap&amp;lt;K,V&amp;gt;
    &lt;span&gt;implements&lt;/span&gt; Map&amp;lt;K,V&amp;gt;&lt;span&gt;, Cloneable, Serializable {
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Node&amp;lt;K,V&amp;gt; &lt;span&gt;implements&lt;/span&gt; Map.Entry&amp;lt;K,V&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; hash;
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt;&lt;span&gt; K key;
        V value;
        Node&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; next;

        Node(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; hash, K key, V value, Node&amp;lt;K,V&amp;gt;&lt;span&gt; next) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.hash =&lt;span&gt; hash;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.key =&lt;span&gt; key;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.value =&lt;span&gt; value;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.next =&lt;span&gt; next;
        }
　　
&lt;/span&gt;&lt;span&gt;final&lt;/span&gt; V putVal(&lt;span&gt;int&lt;/span&gt; hash, K key, V value, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; onlyIfAbsent,
               &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; evict) {
    Node&lt;/span&gt;&amp;lt;K,V&amp;gt;[] tab; Node&amp;lt;K,V&amp;gt; p; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n, i;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((tab = table) == &lt;span&gt;null&lt;/span&gt; || (n = tab.length) == 0&lt;span&gt;)
        n &lt;/span&gt;= (tab =&lt;span&gt; resize()).length;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((p = tab[i = (n - 1) &amp;amp; hash]) == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
        tab[i] &lt;/span&gt;= newNode(hash, key, value, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        Node&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; e; K k;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (p.hash == hash &amp;amp;&amp;amp;&lt;span&gt;
            ((k &lt;/span&gt;= p.key) == key || (key != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; key.equals(k))))
            e &lt;/span&gt;=&lt;span&gt; p;
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (p &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; TreeNode)
            e &lt;/span&gt;= ((TreeNode&amp;lt;K,V&amp;gt;)p).putTreeVal(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, tab, hash, key, value);
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; binCount = 0; ; ++&lt;span&gt;binCount) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((e = p.next) == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    p.next &lt;/span&gt;= newNode(hash, key, value, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (binCount &amp;gt;= TREEIFY_THRESHOLD - 1) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; -1 for 1st&lt;/span&gt;
&lt;span&gt;                        treeifyBin(tab, hash);
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                }
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e.hash == hash &amp;amp;&amp;amp;&lt;span&gt;
                    ((k &lt;/span&gt;= e.key) == key || (key != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; key.equals(k))))
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                p &lt;/span&gt;=&lt;span&gt; e;
            }
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e != &lt;span&gt;null&lt;/span&gt;) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; existing mapping for key&lt;/span&gt;
            V oldValue =&lt;span&gt; e.value;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!onlyIfAbsent || oldValue == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                e.value &lt;/span&gt;=&lt;span&gt; value;
            afterNodeAccess(e);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; oldValue;
        }
    }
    &lt;/span&gt;++&lt;span&gt;modCount;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (++size &amp;gt;&lt;span&gt; threshold)
        resize();
    afterNodeInsertion(evict);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　所以我们调用put方法实际上是加入一个叶子节点，而我们调用putAll相当于把其他Map下面的文件夹中的文件拷贝过来。还有Hashtable也可以看作一个中间构件，里面的putAll方法同样是适合放入实现Map接口的对象。这里如果将Hashtable的这个中间构件放入HashMap中，那么我们这些方法还能用吗。答案是能用，组合模式处理的就是一致性的问题。Map接口中的方法，比如put()，remove()，到下面的中间构件中其实都是一致的功能，不过就是不同的中间构件中的处理方式可能会有细微的差别。下面是我的测试代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
　　Map&amp;lt;Integer,String&amp;gt; rootmap=new HashMap&amp;lt;Integer,String&amp;gt;();&lt;br/&gt;　　rootmap.put(1,&quot;HashMap文件1&quot;);&lt;br/&gt;　　Map&amp;lt;Integer,String&amp;gt; map1=new Hashtable&amp;lt;Integer,String&amp;gt;();&lt;br/&gt;　　map1.put(2,&quot;Hashtable文件1&quot;);&lt;br/&gt;　　map1.put(3,&quot;Hashtable文件2&quot;);&lt;br/&gt;　　map1.put(4,&quot;Hashtable文件3&quot;);&lt;br/&gt;　　rootmap.putAll(map1);&lt;br/&gt;　　System.out.println(rootmap);
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt; } }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1646058/201904/1646058-20190408203739343-395195742.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　上面实现将Hashtable中的键值对放入HashMap中。如果放在组合模式下，你就可以看作是将Hashtable这个中间构件下的文件拷贝到HashMap这个中间构件中。在我们电脑里文件任何类型的文件都可以拷到其他任意地方。但是用来理解Map这个抽象构件的就不行，因为实现Map接口的类只支持放入键值对格式的叶子节点，如果不是（比如说ArrayList）就不行，这是底层方法不支持。同时我们回到组合模式上重要的一点：一致性，Map下面添加都是put方法，需要传入两个值，List下都是add方法，只需要传入一个值，如果List中的可以通过调用putAll方法放入Map里，那么我该怎么给List赋key或value呢。（不是说不能有put(1,list)这样的操作，而是说在组合模式下操作时候需要有一致性，并且这里说的组合模式针对的是putAll方法，与其他方法无关）&lt;/p&gt;

&lt;p&gt;　　这里只是解析了HashMap中的putAll组合模式。在平常写代码的过程中要使用组合模式，就需要先定义一个抽象类或者接口。在这里就可以看作是抽象构件，主要实现一些基本的通用的功能。接着如果有需要就要定义一个中间构件，并且实现抽象构件，里面的方法可以根据特殊需要重写。而且这个类最重要的是要有存储结构在里面，用Map存储，或者用List存储等等都可以。接着就是我们真正的叶子节点，同样是继承或实现抽象构件，里面的方法可以根据特殊需要重写。当你看完这篇博客，你可以再去看定义和适用场景，说不定收获会更大。&lt;/p&gt;
</description>
<pubDate>Mon, 08 Apr 2019 13:48:00 +0000</pubDate>
<dc:creator>方块人</dc:creator>
<og:description>前言： 相信大家都打开过层级很多很多的文件夹。如果把第一个文件夹看作是树的根节点的话，下面的子文件夹就可以看作一个子节点。不过最终我们寻找的还是文件夹中的文件，文件可以看做是叶子节点。下面我们介绍一种</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Cubemen/p/10673712.html</dc:identifier>
</item>
<item>
<title>java并发编程 | 线程详解 - 叫我明羽</title>
<link>http://www.cnblogs.com/cmyxn/p/10673601.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cmyxn/p/10673601.html</guid>
<description>&lt;p&gt;&lt;strong&gt;个人网站：&lt;a href=&quot;https://chenmingyu.top/concurrent-thread/&quot; class=&quot;uri&quot;&gt;https://chenmingyu.top/concurrent-thread/&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;进程与线程&quot;&gt;进程与线程&lt;/h4&gt;
&lt;p&gt;进程：操作系统在运行一个程序的时候就会为其创建一个进程（比如一个java程序），进程是资源分配的最小单位，一个进程包含多个线程&lt;/p&gt;
&lt;p&gt;线程：线程是cpu调度的最小单位，每个线程拥有各自的计数器，对战和局部变量等属性，并且能过访问共享的内存变量&lt;/p&gt;
&lt;h5 id=&quot;线程的状态&quot;&gt;线程的状态&lt;/h5&gt;
&lt;p&gt;java线程的生命周期总共包括6个阶段：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;初始状态：线程被创建，但是还没有调用&lt;code&gt;start()&lt;/code&gt;方法&lt;/li&gt;
&lt;li&gt;运行状态：java中将就绪状态和运行状态统称为运行状态&lt;/li&gt;
&lt;li&gt;阻塞状态：线程阻塞，线程等待进入&lt;code&gt;synchronized&lt;/code&gt;修饰的代码块或方法&lt;/li&gt;
&lt;li&gt;等待状态：线程进入等待状态，需要调用&lt;code&gt;notify()&lt;/code&gt;或&lt;code&gt;notifyAll()&lt;/code&gt;进行唤醒&lt;/li&gt;
&lt;li&gt;超时等待状态：线程进入等待状态，在指定时间后自行返回&lt;/li&gt;
&lt;li&gt;终止状态：线程执行完毕&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在某一时刻，线程只能处于其中的一个状态&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/4/8/169fd21d959cf429?w=660&amp;amp;h=448&amp;amp;f=png&amp;amp;s=146130&quot;/&gt;&lt;/p&gt;
&lt;p&gt;线程初始化后，调用&lt;code&gt;start()&lt;/code&gt;方法变为运行状态，调用&lt;code&gt;wait()&lt;/code&gt;，&lt;code&gt;join()&lt;/code&gt;等方法，线程由运行状态变为等待状态，调用&lt;code&gt;notify()&lt;/code&gt;或&lt;code&gt;notifyAll()&lt;/code&gt;等方法，线程由等待状态变成运行状态，超时等待状态就是在等待状态基础上加了时间限制，超过规定时间，自动更改为运行状态，当需要执行同步方法时，如果没有获得锁，这时线程状态就变为阻塞状态，直到获取到锁，变为运行状态，当执行完线程的&lt;code&gt;run()&lt;/code&gt;方法后，线程变为终止状态&lt;/p&gt;
&lt;h5 id=&quot;创建线程&quot;&gt;创建线程&lt;/h5&gt;
&lt;p&gt;创建线程有三种方式&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;继承&lt;code&gt;Thread&lt;/code&gt;类&lt;/li&gt;
&lt;li&gt;实现&lt;code&gt;Runnable&lt;/code&gt;接口&lt;/li&gt;
&lt;li&gt;实现&lt;code&gt;Callable&lt;/code&gt;接口&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;继承&lt;code&gt;Thread&lt;/code&gt;类&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * @author: chenmingyu
 * @date: 2019/4/8 15:13
 * @description: 继承Thread类
 */
public class ThreadTest extends Thread{

    @Override
    public void run() {
        IntStream.range(0,10).forEach(i-&amp;gt;{
            System.out.println(this.getName()+&quot;:&quot;+i);
        });
    }

    public static void main(String[] args) {
        Thread thread = new ThreadTest();
        thread.start();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;实现runnable接口&quot;&gt;实现&lt;code&gt;Runnable&lt;/code&gt;接口&lt;/h5&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * @author: chenmingyu
 * @date: 2019/4/8 15:18
 * @description: 实现Runnable接口
 */
public class RunnableTest implements Runnable {

    @Override
    public void run() {
        IntStream.range(0,10).forEach(i-&amp;gt;{
            System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i);
        });
    }

    public static void main(String[] args) {
        Runnable runnable = new RunnableTest();
        new Thread(runnable,&quot;RunnableTest&quot;).start();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;实现callable接口&quot;&gt;实现&lt;code&gt;Callable&lt;/code&gt;接口&lt;/h5&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * @author: chenmingyu
 * @date: 2019/4/8 15:23
 * @description: 实现Callable接口
 */
public class CallableTest implements Callable&amp;lt;Integer&amp;gt; {

    @Override
    public Integer call() throws Exception {
        IntStream.range(0,10).forEach(i-&amp;gt;{
            System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i);
        });
        return -1;
    }

    public static void main(String[] args) throws Exception {
        Callable callable = new CallableTest();
        FutureTask futureTask = new FutureTask(callable);
        new Thread(futureTask,&quot;future&quot;).start();
        System.out.println(&quot;result:&quot;+futureTask.get());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;线程的暂停恢复停止&quot;&gt;线程的暂停，恢复，停止&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;不安全的线程暂停，恢复，停止操作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Thread&lt;/code&gt;提供的过期方法可以实现对线程进行暂停&lt;code&gt;suspend()&lt;/code&gt;，恢复&lt;code&gt;resume()&lt;/code&gt;，停止&lt;code&gt;stop()&lt;/code&gt;的操作&lt;/p&gt;
&lt;p&gt;例：创建一个线程，&lt;code&gt;run()&lt;/code&gt;中循环输出当前时间，在&lt;code&gt;main()&lt;/code&gt;方法中对新建线程进行暂停，恢复，停止的操作&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * @author: chenmingyu
 * @date: 2019/4/8 15:51
 * @description: 线程的暂停，恢复，停止
 */
public class OperationThread implements Runnable{

    @Override
    public void run() {
        while (true){
            try {
                TimeUnit.SECONDS.sleep(1L);
                System.out.println(Thread.currentThread().getName()+&quot;运行中：&quot;+LocalTime.now());
            }catch (InterruptedException e){
                System.err.println(e.getMessage());
            }
        }
    }

    public static void main(String[] args) throws Exception{
        Runnable runnable = new OperationThread();
        Thread thread = new Thread(runnable,&quot;operationThread&quot;);
        /**
         * 启动，输出当前时间
         */
        thread.start();
        TimeUnit.SECONDS.sleep(3L);

        /**
         * 线程暂停，不在输出当前时间
         */
        System.out.println(&quot;此处暂停：&quot;+LocalTime.now());
        thread.suspend();
        TimeUnit.SECONDS.sleep(3L);

        /**
         * 线程恢复，继续输出当前时间
         */
        System.out.println(&quot;此处恢复：&quot;+LocalTime.now());
        thread.resume();
        TimeUnit.SECONDS.sleep(3L);

        /**
         * 线程停止，不在输出当前时间
         */
        thread.stop();
        System.out.println(&quot;此处停止：&quot;+LocalTime.now());
        TimeUnit.SECONDS.sleep(3L);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/4/8/169fd220d787ad94?w=357&amp;amp;h=211&amp;amp;f=png&amp;amp;s=17645&quot;/&gt;&lt;br/&gt;因为是过期方法，所以不推荐使用，使用&lt;code&gt;suspend()&lt;/code&gt;方法后，线程不会释放已经占有的资源，就进入睡眠状态，容易引发死锁问题，而使用&lt;code&gt;stop()&lt;/code&gt;方法终结一个线程是不会保证线程的资源正常释放的，可能会导致程序异常&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;安全的线程暂停，恢复，停止操作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;线程安全的暂停，恢复操作可以使用等待/通知机制代替，安全的停止操作可以用线程是否被中断进行判断&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;安全的线程暂停，恢复（等待/通知机制）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;相关方法：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;notify()&lt;/td&gt;
&lt;td&gt;通知一个在对象上等待的线程，使其重wait()方法中返回，前提是该线程获得了对象的锁&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;notifyAll()&lt;/td&gt;
&lt;td&gt;通知所有等待在该对象上的线程&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;wait()&lt;/td&gt;
&lt;td&gt;调用该方法线程进入等待状态，只有等待另外线程的通知或被中断才会返回，调用该方法会释放对象的锁&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;wait(long)&lt;/td&gt;
&lt;td&gt;超时等待一段时间（毫秒），如果超过时间就返回&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;wait(long,int)&lt;/td&gt;
&lt;td&gt;对于超时时间耕细粒度的控制，可以达到纳秒&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;例：创建一个名为&lt;code&gt;waitThread&lt;/code&gt;的线程，在&lt;code&gt;run()&lt;/code&gt;方法,使用中使用&lt;code&gt;synchronized&lt;/code&gt;进行加锁，以变量&lt;code&gt;flag&lt;/code&gt;为条件进行&lt;code&gt;while&lt;/code&gt;循环，在循环中调用&lt;code&gt;LOCK.wait()&lt;/code&gt;方法，此时会释放对象锁，由&lt;code&gt;main()&lt;/code&gt;方法获得锁，调用&lt;code&gt;LOCK.notify()&lt;/code&gt;方法通知&lt;code&gt;LOCK&lt;/code&gt;对象上等待的&lt;code&gt;waitThread&lt;/code&gt;线程，将其置为阻塞状态，并将变量&lt;code&gt;flag&lt;/code&gt;置为&lt;code&gt;true&lt;/code&gt;，当&lt;code&gt;waitThread&lt;/code&gt;线程再次获取对象锁之后继续执行余下代码&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * @author: chenmingyu
 * @date: 2019/4/8 20:00
 * @description: wait/notify
 */
public class WaitNotifyTest {

    private static Object LOCK = new Object();
    private static Boolean FLAG = Boolean.TRUE;


    public static void main(String[] args) throws InterruptedException{
        Runnable r = new WaitThread();
        new Thread(r,&quot;waitThread&quot;).start();
        TimeUnit.SECONDS.sleep(1L);
        synchronized (LOCK){
            System.out.println(Thread.currentThread().getName()+&quot;唤醒waitThread线程：&quot;+LocalTime.now());
            /**
             * 线程状态由等待状态变为阻塞状态
             */
            LOCK.notify();
            /**
             * 只有当前线程释放对象锁，waitThread获取到LOCK对象的锁之后才会从wait()方法中返回
             */
            TimeUnit.SECONDS.sleep(2L);
            FLAG = Boolean.FALSE;
        }
    }

    public static class WaitThread implements Runnable {
        @Override
        public void run() {
            /**
             * 加锁
             */
            synchronized (LOCK){
                while (FLAG){
                    try {
                        System.out.println(Thread.currentThread().getName()+&quot;运行中：&quot;+LocalTime.now());
                        /**
                         * 线程状态变为等待状态
                         */
                        LOCK.wait();
                        /**
                         * 再次获得对象锁之后，才会执行
                         */
                        System.out.println(Thread.currentThread().getName()+&quot;被唤醒：&quot;+LocalTime.now());
                    }catch (InterruptedException e){
                        System.err.println(e.getMessage());
                    }
                }
            }
            System.out.println(Thread.currentThread().getName()+&quot;即将停止：&quot;+LocalTime.now());
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/4/8/169fd22326e062c9?w=388&amp;amp;h=100&amp;amp;f=png&amp;amp;s=10732&quot;/&gt;&lt;br/&gt;可以看到在&lt;code&gt;mian&lt;/code&gt;线程调用&lt;code&gt;LOCK.notify()&lt;/code&gt;方法后，沉睡了2s才释放对象锁，&lt;code&gt;waitThread&lt;/code&gt;线程在获得对象锁之后执行余下代码&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;安全的线程停止操作(中断标识)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;线程的安全停止操作是利用线程的中断标识来实现，线程的中断属性表示一个运行汇总的线程是否被其他线程进行了中断操作，其他线程通过调用该线程的&lt;code&gt;interrupt()&lt;/code&gt;方法对其进行中断操作，而该线程通过检查自身是否被中断来进行响应，当一个线程被中断可以使用&lt;code&gt;Thread.interrupted()&lt;/code&gt;方法对当前线程的中断标识位进行复位&lt;/p&gt;
&lt;p&gt;例：新建一个线程，&lt;code&gt;run&lt;/code&gt;方法中使用&lt;code&gt;Thread.currentThread().isInterrupted()&lt;/code&gt;是否中断作为判断条件，在主线程中使用&lt;code&gt;thread.interrupt()&lt;/code&gt;方法对子线程进行中断操作，用来达到终止线程的操作，这种方式会让子线程可以去清理资源或一些别的操作，而使用&lt;code&gt;stop()&lt;/code&gt;方法则会会直接终止线程&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * @author: chenmingyu
 * @date: 2019/4/8 20:47
 * @description: 中断
 */
public class InterruptTest {
    
    public static void main(String[] args) throws InterruptedException {
        Runnable r = new StopThread();
        Thread thread = new Thread(r,&quot;stopThread&quot;);
        thread.start();
        TimeUnit.SECONDS.sleep(1L);
        System.out.println(Thread.currentThread().getName()+&quot;对stopThread线程进行中断：&quot;+LocalTime.now());
        thread.interrupt();
    }

    public static class StopThread implements Runnable {
        @Override
        public void run() {
            while (!Thread.currentThread().isInterrupted()){
                System.out.println(Thread.currentThread().getName()+&quot;运行中：&quot;+LocalTime.now());
            }
            System.out.println(Thread.currentThread().getName()+&quot;停止：&quot;+LocalTime.now());
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;未完待续...&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考：java并发编程的艺术&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 08 Apr 2019 13:32:00 +0000</pubDate>
<dc:creator>叫我明羽</dc:creator>
<og:description>个人网站： 'https://chenmingyu.top/concurrent thread/' 进程与线程 进程：操作系统在运行一个程序的时候就会为其创建一个进程（比如一个java程序），进程是资</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cmyxn/p/10673601.html</dc:identifier>
</item>
</channel>
</rss>