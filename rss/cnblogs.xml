<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Windows 支持 OpenSSH 了！ - sparkdev</title>
<link>http://www.cnblogs.com/sparkdev/p/10166061.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sparkdev/p/10166061.html</guid>
<description>&lt;p&gt;&lt;span&gt;从 Win10 1809 和 Windows Server 2019 开始 Windows 开始支持 OpenSSH Server。本文介绍一下其基本的概念和配置方法，本文演示用的环境为 Win10 1809(ssh 客户端)和 Windows Server 2019(ssh 服务器)。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;OpenSSH 客户端程序默认已经被系统安装好了，打开 Settings-&amp;gt;Apps-&amp;gt;Manage optional features 面板就可以看到：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/952033/201812/952033-20181223221242458-833263915.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而 OpenSSH Server 默认没有安装，需要用户手动安装。点击上图中的 &quot;Add a feature&quot; 按钮，然后选择 OpenSSH Server，并点击 &quot;Install&quot; 按钮：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/952033/201812/952033-20181223221323946-125463532.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;开启服务&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;安装完成后打开服务管理器，把 OpenSSH Authentication Agent 服务和 OpenSSH SSH Server 服务都设置为自启动，并启动这两个服务：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/952033/201812/952033-20181223221416682-1445089775.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;监听端口&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;启动服务后可以通过 netstat 命令查看 SSH Server 服务是不是已经开始监听默认的 22 号端口了：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/952033/201812/952033-20181223221456333-1862174148.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;防火墙规则&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;在安装 OpenSSH Server 的时候会在防火墙的入站规则中添加一条记录让防火墙放行对 22 号端口的访问：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/952033/201812/952033-20181223221535450-94522261.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;服务器端的配置文件目录&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;服务器端的配置文件在 C:\ProgramData\ssh 目录中，注意 C:\ProgramData 是一个隐藏目录：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/952033/201812/952033-20181223221626498-2044023134.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Windows 系统中 OpenSSH 的安装目录为 C:\Windows\System32\OpenSSH，不管是客户端程序还是服务器端程序都这这个目录中：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/952033/201812/952033-20181223223048383-1723234869.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;OpenSSH 服务器端程序的默认配置文件 sshd_config_default 也在这个目录中。这个目录会被添加到 PATH 环境变量中：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/952033/201812/952033-20181223221712979-171246262.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这样就可以在 PowerShell 中直接执行相关的命令而无需写出完整的路径。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;因为 SSH 客户端所在的目录被添加到了 PATH 环境变量中，在 PowerShell 中可以直接执行 OpenSSH 客户端的命令，比如 ssh：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/952033/201812/952033-20181223221819625-1500747622.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;连接远程 Linux 主机&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;使用 ssh 命令连接一下 Linux 主机，笔者的 Linux 主机为 Ubuntu16.04，可以连接，但是欢迎信息显示了两次：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/952033/201812/952033-20181223221855510-908813096.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;查看 ssh 命令的版本为 7.7.2.1：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/952033/201812/952033-20181223221924916-1075605117.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在另外一台机器上用个老一点的版本(7.6.0.0)试了试：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/952033/201812/952033-20181223221956353-957114987.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;没有发现重复输出欢迎信息的问题，判断可能是新版本引入的 bug。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;连接远程 Windows 主机&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;当 Windows 系统中安装好 OpenSSH Server 并开始监听端口后就可以通过远程的客户端来连接了。连接远程 Windows 主机与连接远程 Linux 主机相同，下面是通过密码登录的方式(nick 是 Windows 系统中的一个本地用户)：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/952033/201812/952033-20181223222057224-650210683.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;连接成功后默认的 shell 是 Windows Command shell (cmd.exe) 程序：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/952033/201812/952033-20181223222130848-1626157774.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在 Windows 系统中，PowerShell 已逐渐成为主流，我们可以把默认的 shell 设置为 PowerShell。其实就是在&lt;strong&gt;运行 OpenSSH Server 的 Windows 系统的注册表中&lt;/strong&gt;添加一个配置项，注册表路径为 HKEY_LOCAL_MACHINE\SOFTWARE\OpenSSH，项的名称为 DefaultShell，项的值为 C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe。我们可以以管理员身份启动 PowerShell，然后执行下面的命令完成注册表项的添加：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;gt; New-ItemProperty -Path &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;HKLM:\SOFTWARE\OpenSSH&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -Name DefaultShell -Value &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -PropertyType String -Force
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/952033/201812/952033-20181223222215363-880960397.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在重新连接远程服务器，默认的 shell 已经变成了 PowerShell：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/952033/201812/952033-20181223222249521-1341317281.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;前面我们介绍的 ssh 命令都是通过密码认证连接服务器的，下面介绍通过秘钥认证的方式登录服务器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;ssh-keygen 命令&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;ssh-keygen 命令用来生成公钥认证使用的秘钥对，创建的秘钥一般都和 ssh 客户端的配置一起保存在用户家目录下的 .ssh 目录中(与 Linux 系统中类似)：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/952033/201812/952033-20181223222348576-864069885.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;执行 ssh-keygen 命令：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&amp;gt; &lt;span&gt;ssh-keygen&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/952033/201812/952033-20181223222423581-1270593652.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;默认情况下一路回车就可以了，使用默认的文件名称和存放目录：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/952033/201812/952033-20181223222459115-149930597.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;遗憾的是 Windows 下目前还没有提供 ssh-copy-id 命令，需要手动把用户的公钥添加到远程主机系统中的用户的  authorized_keys 文件中。具体在运行 OpenSSH Server 的主机上的操作步骤如下：&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;在用户家目录下创建 .ssh 目录&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;打开 PowerShell，进入用户的家目录，用 mkdir 命令创建 .ssh 目录：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&amp;gt;&lt;span&gt; cd ~
&lt;/span&gt;&amp;gt; mkdir .ssh
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/952033/201812/952033-20181223222532969-1925326452.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;创建 authorized_keys 文件并加入公钥&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;在 PowerShell 中执行 notepad .ssh\authorized_keys 命令创建文本文件，把客户端的公钥复制到这个文件中并保存。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;把文本文件的名称修改为 authorized_keys：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/952033/201812/952033-20181223222617252-964136744.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;修改 ssh 服务的配置文件&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;以管理员权限打开 PowerShell，执行命令 notepad C:\ProgramData\ssh\sshd_config。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;注释掉配置文件中的最后两行然后保存：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;Match Group administrators&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;       AuthorizedKeysFile __PROGRAMDATA__/ssh/administrators_authorized_keys&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;最后在服务管理器器中重启 OpenSSH SSH Server 服务，然后客户端就可以通过公钥认证的方式登录到远程服务器了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;注意：&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;一定不要用 Repair-AuthorizedKeyPermission 命令修复 .ssh\authorized_keys 文件的权限。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;也不要以下面的方式创建 .ssh\authorized_keys 文件：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
echo &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;publickey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;gt;&lt;span&gt; .ssh\authorized_keys
echo &lt;/span&gt;&lt;span&gt;$null&lt;/span&gt; &amp;gt; .ssh\authorized_keys
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;OpenSSH 的支持让系统管理员有了一个方便的工具来管理 Windows 系统，相信 OpenSSH + PowerShell 的组合将成为管理 Windows 系统的黄金搭档。本文只是介绍了一些入门的概念，但给人的感觉是 Windows 上的 OpenSSH 工具尚需打磨(问题挺多的，按照文档配置个公钥认证就把人搞吐了)。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;参考：&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;a href=&quot;https://github.com/powershell/Win32-OpenSSH/wiki&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;PowerShell/Win32-OpenSSH&lt;/span&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://docs.microsoft.com/zh-cn/windows-server/administration/openssh/openssh_overview&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;OpenSSH in Windows&lt;/span&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://github.com/PowerShell/Win32-OpenSSH/issues/1306#issuecomment-448095381&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;解决公钥认证问题&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 23 Dec 2018 23:04:00 +0000</pubDate>
<dc:creator>sparkdev</dc:creator>
<og:description>从 Win10 1809 和 Windows Server 2019 开始 Windows 开始支持 OpenSSH Server。本文介绍一下其基本的概念和配置方法，本文演示用的环境为 Win10</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sparkdev/p/10166061.html</dc:identifier>
</item>
<item>
<title>Linux基础命令---bzmore - 一生有你llx</title>
<link>http://www.cnblogs.com/wj78080458/p/10064527.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wj78080458/p/10064527.html</guid>
<description>&lt;p&gt;&lt;strong&gt;bzmore&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      将bzip压缩过的文件解压到标准输出，同时也可以将普通文件显示到标准输出。该指令可以实现分屏显示，并且不会删除压缩包。bzmore是一个过滤器，它允许在软拷贝终端上一次检查压缩或纯文本文件。bzmore可以处理使用bzip2压缩的文件，也可以处理未压缩的文件。如果文件不存在，bzmore将查找同名文件，并添加.bz2后缀。Bzmore通常在每个屏幕后暂停，打印-更多-在屏幕底部。如果用户然后键入回车，则会显示多一行。如果用户点击一个空格，则会显示另一个屏幕。其他可能性将在后面列举。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;     此命令的适用范围：RedHat、RHEL、Ubuntu、CentOS、SUSE、openSUSE、Fedora。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;strong&gt;、语法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;     bzmore &lt;/strong&gt;&lt;strong&gt;文件 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;strong&gt;、选项列表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;     Bzmore在文件“/etc/Tercap”中查找以确定终端特性，并确定默认窗口大小。在能够显示24行的终端上，默认窗口大小为22行。在bzmore暂停时可能键入的其他序列及其效果如下(i是可选的整数参数，默认为1)：&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;15&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;28%&quot;&gt;
&lt;p&gt;命令&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;71%&quot;&gt;
&lt;p&gt;说明&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;28%&quot;&gt;
&lt;p&gt;i&amp;lt;space&amp;gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;71%&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;多显示i行(或另一个屏幕，如果没有给出参数)&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;28%&quot;&gt;
&lt;p&gt;ctrl+D&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;71%&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;多显示11行(“滚动”)。如果给定i，则滚动大小设置为i。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;28%&quot;&gt;
&lt;p&gt;d&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;71%&quot;&gt;
&lt;p&gt;同上&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;28%&quot;&gt;
&lt;p&gt;iz&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;71%&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;与键入空格相同，但如果有i，则会成为新的窗口大小。请注意，窗口大小将恢复到当前文件末尾的默认值。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;28%&quot;&gt;
&lt;p&gt;is&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;71%&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;跳过i行，然后打印出满屏幕&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;28%&quot;&gt;
&lt;p&gt;if&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;71%&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;跳过i屏幕，打印一整行的屏幕&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;28%&quot;&gt;
&lt;p&gt;q | Q&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;71%&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;停止读取当前文件；继续下一个文件(如果有的话)&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;28%&quot;&gt;
&lt;p&gt;e | q&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;71%&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;当输出提示符--More-- (Next  file:  file时，此命令将导致bzmore退出。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;28%&quot;&gt;
&lt;p&gt;s&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;71%&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;当输出提示符--More-- (Next  file:  file时，此命令将导致bzmore跳过下一个文件，然后继续&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;28%&quot;&gt;
&lt;p&gt;=&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;71%&quot;&gt;
&lt;p&gt;显示当前的行号&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;28%&quot;&gt;
&lt;p&gt;i/expr&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;71%&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;搜索正则表达式expr的第i次出现。如果找不到模式，bzmore将继续到下一个文件(如果有的话)。否则，会显示一个屏幕，在找到表达式的位置之前开始两行。用户的擦除和删除字符可用于编辑正则表达式。通过第一列的擦除将取消搜索命令。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;28%&quot;&gt;
&lt;p&gt;in&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;71%&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;搜索输入的最后一个正则表达式的第i次出现&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;28%&quot;&gt;
&lt;p&gt;！command&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;71%&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;使用命令唤醒shell。字符‘！’在“命令”中，将替换为前面的shell命令。序列“\！”改为“！”&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;28%&quot;&gt;
&lt;p&gt;：q | ：Q&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;71%&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;停止读取当前文件；转到下一个文件(如果有的话)(与q或Q相同)。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;28%&quot;&gt;
&lt;p&gt;.&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;71%&quot;&gt;
&lt;p&gt;重复前面的命令&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;     这些命令立即生效，即不需要键入回车。在给出命令字符本身的时间之前，用户可以点击行终止字符来取消正在形成的数值参数。此外，用户还可以点击擦除字符来重新显示-更多的消息。&lt;/p&gt;
&lt;p&gt;     在任何时候，当输出被发送到终端时，用户可以按退出键(通常是Control-\)。Bzmore将停止发送输出，并显示通常的“--More--”提示。然后，用户可以正常方式输入上述命令之一。不幸的是，当这样做时，会丢失一些输出，因为当退出信号发生时，终端输出队列中等待的任何字符都会被刷新。&lt;/p&gt;
&lt;p&gt;     该程序将终端设置为noecho模式，以便输出可以连续。因此，您键入的内容将不会显示在您的终端上，除了‘/’和‘！’命令。&lt;/p&gt;
&lt;p&gt;     如果标准输出不是teletype，那么bzmore就像bzcat一样，只是在每个文件之前打印一个头。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;strong&gt;、实例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1）解压bz2文件&lt;/p&gt;
&lt;table class=&quot;a&quot; border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;1.5&quot;&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;836&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;code&gt;[root@localhost weijie]# &lt;strong&gt;bzmore 2.c.bz2             //&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;&lt;strong&gt;将内容解压到标准输出，不删除压缩包&lt;/strong&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;------&amp;gt; 2.c.bz2 &amp;lt;------&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;123&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;23&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;212&lt;/code&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;2）显示普通文件&lt;/p&gt;
&lt;table class=&quot;a&quot; border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;836&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;[root@localhost weijie]# &lt;strong&gt;bzmore 1.c                 //&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;&lt;strong&gt;直接显示普通文件&lt;/strong&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;------&amp;gt; 1.c &amp;lt;------&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;hello world, &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;i am david. &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;i love linux, &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;love code.&lt;/code&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</description>
<pubDate>Sun, 23 Dec 2018 22:54:00 +0000</pubDate>
<dc:creator>一生有你llx</dc:creator>
<og:description>bzmore 将bzip压缩过的文件解压到标准输出，同时也可以将普通文件显示到标准输出。该指令可以实现分屏显示，并且不会删除压缩包。bzmore是一个过滤器，它允许在软拷贝终端上一次检查压缩或纯文本文</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wj78080458/p/10064527.html</dc:identifier>
</item>
<item>
<title>设计模式——迭代器模式(遍历王者荣耀和英雄联盟英雄信息) - cdream</title>
<link>http://www.cnblogs.com/cdream-zs/p/10166700.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cdream-zs/p/10166700.html</guid>
<description>&lt;blockquote readability=&quot;6.6347826086957&quot;&gt;
&lt;p&gt;本文首发于&lt;a href=&quot;https://icdream.github.io/2018/12/18/designpattern05/&quot;&gt;cdream&lt;/a&gt;的个人博客，点击获得更好的阅读体验！&lt;/p&gt;
&lt;p&gt;欢迎转载，转载请注明出处。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文主要讲述迭代器模式，并使用遍历不同数据结构的王者荣耀和英雄联盟英雄作为例子帮助大家理解，最后附上阿离美图一张！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws3.sinaimg.cn/large/006tNbRwly1fyceqjouq1j316a088gmo.jpg&quot; alt=&quot;image-20181219220835618&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;一概述&quot;&gt;一、概述&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;迭代器模式&lt;/strong&gt;(Iterator pattern):提供一种方法顺序访问一个聚合对象中的各个元素，而又不用暴露聚合底层的实现。&lt;/p&gt;
&lt;p&gt;迭代器模式比较常见的设计模式，对于熟悉java集合的我们来说，会经常用到迭代器。当我们需要写一个方法来遍历集合，又不想针对不同的集合实现不同的方法，就可以使用迭代器来完成。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;迭代器模式主要解决两个问题&lt;/strong&gt;：&lt;br/&gt;1.聚集元素在访问和遍历时，不必要暴露底层数据结构(without exposing its representation)&lt;br/&gt;2.当为一个新的聚集定义遍历操作时，不需要改变接口&lt;/p&gt;
&lt;h2 id=&quot;二结构&quot;&gt;二、结构&lt;/h2&gt;
&lt;p&gt;UML图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws2.sinaimg.cn/large/006tNbRwly1fyb94cpr01j30y00m0go8.jpg&quot; alt=&quot;image-20181218220839386&quot;/&gt;&lt;/p&gt;
&lt;p&gt;主要角色：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;聚合的接口&lt;/strong&gt;(Aggregate)：提供一个共同的接口，给所有的聚合使用，将客户代码从聚合的实现中解耦。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;聚合的具体实现&lt;/strong&gt;(ConcreateAggregate)：这个具体实现会持有一个对象的集合，并实现createIterator()方法，通过这个方法可以返回一个对象的集合的迭代器。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;迭代器接口&lt;/strong&gt;(Iterator)：这是一个迭代器接口，我们可以在里面定义一些方法，利用这些方法可以在集合元素之间游走。可以使用java自带的java.util.Iterator，也可以根据我们自己需要来定义一个Iterator。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;迭代器具体实现&lt;/strong&gt;(ConcreteIterator)：由具体聚合提供一个工厂方法来实现具体迭代器，这个迭代器负责管理目前遍历的位置。&lt;/p&gt;
&lt;h2 id=&quot;三输出所有王者荣耀和英雄联盟的英雄信息&quot;&gt;三、输出所有王者荣耀和英雄联盟的英雄信息&lt;/h2&gt;
&lt;h3 id=&quot;源代码&quot;&gt;源代码&lt;/h3&gt;
&lt;p&gt;假设当前有这样一个需求，我们需要一个小助手，可以同时向用户展示王者荣耀和英雄联盟中的英雄信息，但是两款游戏维护英雄使用数据结构不同，一个数组，现在我们用迭代器来完成这个功能&lt;/p&gt;
&lt;p&gt;定义英雄的实体类，包括姓名、性别、描述&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Hero {
    private String name;
    private String sex;
    private String desc;

    public Hero(String name, String sex, String desc) {
        this.name = name;
        this.sex = sex;
        this.desc = desc;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getSex() {
        return sex;
    }

    public void setSex(String sex) {
        this.sex = sex;
    }

    public String getDesc() {
        return desc;
    }

    public void setDesc(String desc) {
        this.desc = desc;
    }

    @Override
    public String toString() {
        return &quot;Hero{&quot; +
                &quot;name='&quot; + name + '\'' +
                &quot;, sex='&quot; + sex + '\'' +
                &quot;, desc='&quot; + desc + '\'' +
                '}';
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建王者荣耀英雄类&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class HOKHeros {
    static final int MAX_HERO_COUNT = 10;
    int heroCount = 0;
    private Hero[] hokHeros = new Hero[MAX_HERO_COUNT];

    public HOKHeros() {
        Hero gsl = new Hero(&quot;公孙离&quot;, &quot;妹子&quot;, &quot;我觉得阿离是最漂亮的女英雄~&quot;);
        Hero lbqh = new Hero(&quot;鲁班七号&quot;, &quot;男&quot;, &quot;智商250&quot;);
        Hero wzt = new Hero(&quot;武则天&quot;, &quot;女&quot;, &quot;贼贵&quot;);
        hokHeros[0] = gsl;
        hokHeros[1] = lbqh;
        hokHeros[2] = wzt;
        this.heroCount = 3;
    }

    public Hero[] getHokHeros() {
        return hokHeros;
    }

    public void addHero(Hero hero) {
        if (heroCount &amp;gt;= MAX_HERO_COUNT) {
            System.out.println(&quot;已经不能放更多英雄了！&quot;);
        } else {
            hokHeros[this.heroCount] = hero;
            this.heroCount += 1;
        }
    }

    public Iterator&amp;lt;Hero&amp;gt; createIterator(){
        return new HOKHerosIterator(hokHeros);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;数组没有继承迭代器接口，所以我们自己实现一个！&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class HOKHerosIterator implements Iterator&amp;lt;Hero&amp;gt; {
    private int position = 0;
    private Hero[] heroes;

    public HOKHerosIterator(Hero[] heroes) {
        this.heroes = heroes;
    }

    @Override
    public boolean hasNext() {
        if (heroes.length &amp;lt;= position || heroes[position] == null) {
            return false;
        }
        return true;
    }

    @Override
    public Hero next() {
        Hero hero = heroes[position];
        position += 1;
        return hero;
    }


}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建英雄联盟英雄类&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class LOLHeros {
    private ArrayList&amp;lt;Hero&amp;gt; heroes;

    public LOLHeros() {
        heroes = new ArrayList&amp;lt;&amp;gt;();
        Hero gl = new Hero(&quot;盖伦&quot;, &quot;男&quot;, &quot;初始英雄&quot;);
        Hero rw = new Hero(&quot;锐雯&quot;, &quot;女&quot;, &quot;贼秀&quot;);
        Hero ys = new Hero(&quot;亚索&quot;, &quot;男&quot;, &quot;很厉害的样子&quot;);
        heroes.add(gl);
        heroes.add(rw);
        heroes.add(ys);
    }

    public ArrayList&amp;lt;Hero&amp;gt; getHeroes() {
        return heroes;
    }
    public void addHere(Hero hero){
        heroes.add(hero);
    }
    public Iterator&amp;lt;Hero&amp;gt; createIterator(){
        return heroes.iterator();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;小助手&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class HeroHelper {
    private Iterator iterator;

    public HeroHelper(Iterator iterator) {
        this.iterator = iterator;
    }

    public HeroHelper() {
    }

    public void showHeros() {
        while (iterator.hasNext()) {
            System.out.println(iterator.next());
        }
    }

    public void setIterator(Iterator iterator) {
        this.iterator = iterator;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试类&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Test {
    public static void main(String[] args) {
        HOKHeros hokHeros = new HOKHeros();
        LOLHeros lolHeros = new LOLHeros();

        HeroHelper heroHelper = new HeroHelper();
        heroHelper.setIterator(hokHeros.createIterator());
        System.out.println(&quot;------&quot;);
        heroHelper.showHeros();
        heroHelper.setIterator(lolHeros.createIterator());
        heroHelper.showHeros();
    }
}
结果
Hero{name='公孙离', sex='妹子', desc='我觉得阿离是最漂亮的女英雄~'}
Hero{name='鲁班七号', sex='男', desc='智商250'}
Hero{name='武则天', sex='女', desc='贼贵'}
------
Hero{name='盖伦', sex='男', desc='初始英雄'}
Hero{name='锐雯', sex='女', desc='贼秀'}
Hero{name='亚索', sex='男', desc='很厉害的样子'}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面可以看出，迭代器需要两个核心方法hashNext(),next(),在java中还提供了remove()方法，根据需要我们可以自己实现迭代器，例如上文中，王者荣耀是用数组来储存英雄，我们手动实现了一个迭代器。&lt;/p&gt;
&lt;p&gt;小助手并不需要清楚每款游戏在底层是如何储存英雄，但是只要可以创建迭代器，小助手就可以帮我们遍历英雄列表。&lt;/p&gt;
&lt;p&gt;想象如果两款游戏&lt;strong&gt;没有实现迭代器&lt;/strong&gt;接口，是不是就得在小助手里自己手写两个不同的for循环？&lt;/p&gt;
&lt;p&gt;如果新加入了doto的英雄列表，它是用Hashtable来维护英雄列表的，我们现在就可以让它提供createItorator就可以，但若不使用迭代器，是不是就需要对小助手进行修改？&lt;/p&gt;
&lt;h3 id=&quot;java中的集合&quot;&gt;java中的集合&lt;/h3&gt;
&lt;p&gt;java的集合并未将迭代器单独创建一个类，而是将迭代器作为集合的内部类，这样迭代器可以自由操作集合内元素，即保证了聚合对象的封装又能实现迭代器模式。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public classArrayList&amp;lt;E&amp;gt; extends AbstractList&amp;lt;E&amp;gt;
implements List&amp;lt;E&amp;gt;, RandomAccess, Cloneable, java.io.Serializable{
    private class Itr implements Iterator&amp;lt;E&amp;gt; {
        int cursor;       // index of next element to return
        int lastRet = -1; // index of last element returned; -1 if no such
        int expectedModCount = modCount;

        Itr() {}

        public boolean hasNext() {
            return cursor != size;
        }

        @SuppressWarnings(&quot;unchecked&quot;)
        public E next() {
            checkForComodification();
            int i = cursor;
            if (i &amp;gt;= size)
                throw new NoSuchElementException();
            Object[] elementData = ArrayList.this.elementData;
            if (i &amp;gt;= elementData.length)
                throw new ConcurrentModificationException();
            cursor = i + 1;
            return (E) elementData[lastRet = i];
        }

        public void remove() {
            if (lastRet &amp;lt; 0)
                throw new IllegalStateException();
            checkForComodification();

            try {
                ArrayList.this.remove(lastRet);
                cursor = lastRet;
                lastRet = -1;
                expectedModCount = modCount;
            } catch (IndexOutOfBoundsException ex) {
                throw new ConcurrentModificationException();
            }
        }

        @Override
        @SuppressWarnings(&quot;unchecked&quot;)
        public void forEachRemaining(Consumer&amp;lt;? super E&amp;gt; consumer) {
            Objects.requireNonNull(consumer);
            final int size = ArrayList.this.size;
            int i = cursor;
            if (i &amp;gt;= size) {
                return;
            }
            final Object[] elementData = ArrayList.this.elementData;
            if (i &amp;gt;= elementData.length) {
                throw new ConcurrentModificationException();
            }
            while (i != size &amp;amp;&amp;amp; modCount == expectedModCount) {
                consumer.accept((E) elementData[i++]);
            }
            // update once at end of iteration to reduce heap write traffic
            cursor = i;
            lastRet = i - 1;
            checkForComodification();
        }

        final void checkForComodification() {
            if (modCount != expectedModCount)
                throw new ConcurrentModificationException();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;像这个ArrayList，内部主干是一个数组，但是别为对外提供获取该数组的方法，不过利用内部类依然实现了迭代器模式。&lt;/p&gt;
&lt;p&gt;如果读过ArrayList源码，会注意modCount这个成员变量，用来记录ArrayList被修改次数(add,remove,set这类方法都会给modCount加1)，在迭代器中checkForComodification()，用来实现fail-fast机制，当我们一个线程在使用迭代器遍历时，如果另一个线程对集合进行了修改，就会抛出异常。&lt;/p&gt;
&lt;h2 id=&quot;四优缺点&quot;&gt;四、优缺点&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;客户端不需要要了解具体底层实现，可以使用迭代器进行遍历&lt;/li&gt;
&lt;li&gt;符合开闭原则，当我们需要新添加一个聚合时，不需要对客户端进行修改，只需要使聚合实现迭代器接口就可以&lt;/li&gt;
&lt;li&gt;封装良好，客户端只需要迭代器就可以遍历，而不需要知道具体的迭代器算法&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对于简单的遍历，实现迭代器较为繁琐，用户可能更喜欢用for来进行遍历。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;五总结&quot;&gt;五、总结&lt;/h2&gt;
&lt;p&gt;迭代器模式在平时遍码过程中使用的频率并不高，但是了解迭代器却能加深我们对集合的了解。在java类中，除了Iterator外，Iterable、ListIterator也值得我们去了解~有兴趣的同学可以进行阅读。&lt;/p&gt;
&lt;p&gt;掌握迭代器模式要把握住在不了解聚合底层实现的情况下进行遍历这个核心即可，一般来说，如果我们需要实现一个集合，就需要提供这个集合的迭代器。&lt;/p&gt;
&lt;p&gt;另外，迭代器模式与工厂模式结合可以发挥巨大的威力！&lt;/p&gt;
&lt;p&gt;希望本文对想要学习迭代器的小伙伴有所帮助，最后附离妹美图一张！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws3.sinaimg.cn/large/006tNbRwly1fycegvyflpj31c00u014f.jpg&quot; alt=&quot;公孙离2&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;本文参考&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;http://product.dangdang.com/20021171.html&quot;&gt;Head First 设计模式,Eric Freeman &amp;amp;Elisabeth Freeman with Kathy Sierra &amp;amp; Bert Bates&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Iterator_pattern&quot;&gt;Iterator pattern，wiki&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/java-my-life/archive/2012/04/17/2453861.html&quot;&gt;《JAVA与模式》之迭代子模式&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Sun, 23 Dec 2018 22:36:00 +0000</pubDate>
<dc:creator>cdream</dc:creator>
<og:description>本文首发于</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cdream-zs/p/10166700.html</dc:identifier>
</item>
<item>
<title>单元测试框架之unittest(二) - davieyang</title>
<link>http://www.cnblogs.com/davieyang/p/10162363.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/davieyang/p/10162363.html</guid>
<description>&lt;h2&gt;一、摘要&lt;/h2&gt;
&lt;p&gt;本章笔者将详细介绍组织测试代码的相关内容，所用的测试例子会是冒泡排序，笔者在从业这么久之后回想很多面试都要问冒泡排序，虽然不知道为什么要问这个，但还是希望大家掌握，它与自动化测试关系不大属于python的基础范畴&lt;/p&gt;
&lt;p&gt;在上一篇内容中我们展示了一个小例子，在代码的前两行是如下内容&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; unittest
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; TestStringMethods(unittest.TestCase): 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它的意义何在呢？ import unittest 导入unittest模块，使得我们可以使用它，class TestStringMethods(unittest.TestCase): 新创建的测试类继承了unittest.TestCase，使得我们可以是使用TestCase里的特性&lt;/p&gt;
&lt;p&gt;那么它有哪些主要特性呢？&lt;/p&gt;
&lt;p&gt; 1、测试用例，当我们的测试类继承了unittest.TestCase，若以“def test_xxx(self):”这样的命名方式（test开头）在测试类中定义函数时，它就会被unittest认为是一条测试方法；然而就像我们做手动测试用例的时候，总有一些原则在，那么在写自动化测试用例时有哪些主要的原则呢？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;每一个测试用例必须是完全独立的，从而能够单独执行，也可以组团执行&lt;/li&gt;
&lt;li&gt;每一个测试用例必须有断言，从而在测试失败的情况下断言异常和一条解释性的语句(AssertionError)将会抛出，此时unittest将会将这条用例标识为失败，其他的异常类型将会被认为是错误(error)&lt;/li&gt;
&lt;li&gt;在设计测试用例时要尽可能考虑后续维护的问题，我们要尽可能的减少修改测试代码，从而能够满足快速的迭代测试&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;2、setUp()：这个函数也继承自unittest.TestCase，它的作用是用来完成每一个测试方法执行前的准备工作，如果setUp()方法执行的时候出现异常，那么unittest框架认为测试出现了错误，测试方法是不会被执行的&lt;/p&gt;
&lt;p&gt;3、tearDown(): 同样继承自unittest.TestCase，它的作用是每一个测试方法执行完后的清理工作，如果setUp()执行成功，那么测试方法执行成功还是失败，tearDown()方法都会被执行&lt;/p&gt;
&lt;p&gt;4、setUpClass(): 同样继承自unittest.TestCase，它的作用是完成在所有测试方法执行前（包括setUp()），单元测试的前期准备工作，必须用@classmethod修饰，整个测试类只执行一次&lt;/p&gt;
&lt;p&gt;5、tearDownClass(): 同样继承自unittest.TestCase，它的作用是完成在所有测试方法执行后（包括tearDown()），单元测试的清理工作，必须用@classmethod修饰，整个测试类只执行一次&lt;/p&gt;
&lt;p&gt;6、还有一种特例，最简单的测试用例只需要通过覆盖runTest()方法来执行自定义的测试代码，我们称之为静态方法，测试方法名不能重复，也意味着测试类中只能有一个runTest()方法，很显然这样的方式会导致很多冗余代码&lt;/p&gt;
&lt;p&gt;7、使用了1到5测试特性构建测试用例的，我们称之为动态方法&lt;/p&gt;
&lt;h2&gt;二、实例代码&lt;/h2&gt;
&lt;p&gt;下边将用实例代码详细展示如上概念，待测代码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; BubbleSort(object):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, mylist):
        self.myList &lt;/span&gt;=&lt;span&gt; mylist
        self.length &lt;/span&gt;=&lt;span&gt; len(mylist)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; ascending_order(self):
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(self.length-1&lt;span&gt;):
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; j &lt;span&gt;in&lt;/span&gt; range(self.length-1-&lt;span&gt;i):
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; self.myList[j] &amp;gt; self.myList[j + 1&lt;span&gt;]:
                    self.myList[j], self.myList[j&lt;/span&gt;+1] = self.myList[j+1&lt;span&gt;], self.myList[j]
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; self.myList

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; descending_order(self):
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(self.length-1&lt;span&gt;):
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; j &lt;span&gt;in&lt;/span&gt; range(self.length-1-&lt;span&gt;i):
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; self.myList[j] &amp;lt; self.myList[j + 1&lt;span&gt;]:
                    self.myList[j], self.myList[j&lt;/span&gt;+1] = self.myList[j+1&lt;span&gt;], self.myList[j]
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; self.myList
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; unittest
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; Util.BubbleSort &lt;span&gt;import&lt;/span&gt;&lt;span&gt; BubbleSort


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestBubbleSort(unittest.TestCase):  
    @classmethod
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; setUpClass(cls):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;execute setUpClass\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

    @classmethod
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; tearDownClass(cls):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;execute tearDownClass\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; setUp(self):
        self.list1 &lt;/span&gt;= [2, 10, 25, 30, 45, 100, 325&lt;span&gt;]
        self.list3 &lt;/span&gt;= [325, 10, 25, 45, 30, 100, 2&lt;span&gt;]
        self.list4 &lt;/span&gt;= [11, 3, 41, 101, 327, 26, 46&lt;span&gt;]
        self.list2 &lt;/span&gt;= [327, 101, 46, 41, 26, 11, 3&lt;span&gt;]

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; tearDown(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;execute tearDown\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; test_descending_order(self):
        bls &lt;/span&gt;=&lt;span&gt; BubbleSort(self.list4)
        self.list5 &lt;/span&gt;=&lt;span&gt; bls.descending_order()
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(self.list5)
        self.assertEqual(self.list5, self.list2)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; test_ascending_order(self):
        bls &lt;/span&gt;=&lt;span&gt; BubbleSort(self.list3)
        self.list6 &lt;/span&gt;=&lt;span&gt; bls.ascending_order()
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(self.list6)
        self.assertEqual(self.list6, self.list1)


&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    unittest.main()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行结果应该是&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;..
execute setUpClass
&lt;/span&gt;----------------------------------------------------------------------&lt;span&gt;

Ran &lt;/span&gt;&lt;span&gt;2&lt;/span&gt; tests &lt;span&gt;in&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;.001s

[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;, &lt;span&gt;25&lt;/span&gt;, &lt;span&gt;30&lt;/span&gt;, &lt;span&gt;45&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;, &lt;span&gt;325&lt;/span&gt;&lt;span&gt;]
OK
execute tearDown

[&lt;/span&gt;&lt;span&gt;327&lt;/span&gt;, &lt;span&gt;101&lt;/span&gt;, &lt;span&gt;46&lt;/span&gt;, &lt;span&gt;41&lt;/span&gt;, &lt;span&gt;26&lt;/span&gt;, &lt;span&gt;11&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;&lt;span&gt;]
execute tearDown

execute tearDownClass


Process finished with exit code &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;三、代码解析&lt;/h2&gt;
&lt;p&gt;从测试用例的设计和运行结果结合看，意义印证了摘要当中提及的TestCase的特性&lt;/p&gt;

</description>
<pubDate>Sun, 23 Dec 2018 17:46:00 +0000</pubDate>
<dc:creator>davieyang</dc:creator>
<og:description>一、摘要 本章笔者将详细介绍组织测试代码的相关内容，所用的测试例子会是冒泡排序，笔者在从业这么久之后回想很多面试都要问冒泡排序，虽然不知道为什么要问这个，但还是希望大家掌握，它与自动化测试关系不大属于</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/davieyang/p/10162363.html</dc:identifier>
</item>
<item>
<title>[python] python django web 开发 —— 15分钟送到会用（只能送你到这了） - beautifulzzzz</title>
<link>http://www.cnblogs.com/zjutlitao/p/9919922.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zjutlitao/p/9919922.html</guid>
<description>&lt;h4 id=&quot;安装python环境&quot;&gt;1、安装python环境&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;1.1 安装python包管理器：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;wget https://bootstrap.pypa.io/get-pip.py
sudo python get-pip.py&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt; &lt;br/&gt;&lt;strong&gt;1.2 安装python虚拟环境virtualenv virtualenvwrapper&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先说明下为什么要装这两个包：&lt;/p&gt;
&lt;p&gt;First, it’s important to understand that a virtual environment is a special tool used to keep the dependencies required by different projects in separate places by creating isolated, independent Python environments for each of them.&lt;/p&gt;
&lt;p&gt;In short, it solves the “Project X depends on version 1.x, but Project Y needs 4.x” dilemma. It also keeps your global site-packages neat, tidy, and free from clutter.&lt;/p&gt;
&lt;p&gt;If you would like a full explanation on why Python virtual environments are good practice, absolutely give this excellent blog post on RealPython a read.&lt;/p&gt;
&lt;p&gt;用虚拟开发环境可以为每个工程提供独立的python开发环境、独立的包、独立的版本，每个独立的环境会在~/.virtualenvs/下形成资源包～&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;sudo pip install virtualenv virtualenvwrapper
sudo rm -rf ~/.cache/pip&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;之后在~/.profile文件最后添加下面几行：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# virtualenv and virtualenvwrapper
export WORKON_HOME=$HOME/.virtualenvs
source /usr/local/bin/virtualenvwrapper.sh&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;之后如果想用python虚拟环境，在每次打开一个新的terminal就要执行一次source ~/.profile&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;source ~/.profile&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来我们生成一个python虚拟环境来用于python-web的开发提供环境：（这里用的是python2.7)&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mkvirtualenv python_web -p python2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;：再次说明python虚拟环境是完全独立的，也就是说在python_web的环境下安装的python包，步适用于全局；在全局安装的包，不适合python_web。&lt;/p&gt;
&lt;p&gt;如何验证你如何将python_web环境生成好了呢？——新开一个terminal，执行下列命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;source ~/.profile
workon python_web&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果terminal前面的文字变成了(python_web)表明成功创建了名为cv的python虚拟环境；&lt;/p&gt;

&lt;h4 id=&quot;安装django&quot;&gt;2、安装Django&lt;/h4&gt;
&lt;p&gt;从官网上得知2.7版本的python可使用最高1.11版本的Django，因此在python_web环境中安装：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;pip install Django==1.11&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试Django有没有安装成功，进入python命令交互模式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import django
django.VERSION&lt;/code&gt;
&lt;/pre&gt;

&lt;h4 id=&quot;第一个例子hello-world&quot;&gt;3、第一个例子hello world&lt;/h4&gt;
&lt;p&gt;找到你的django-admin.py文件，并把它加入系统路径。如果用的是setup.py工具安装的Django，django-admin.py应该已被加入了系统路径中。我的django-admin.py的目录为:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/root/.virtualenvs/python_web/lib/python2.7/site-packages/django/bin &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;进入该目录下，运行如下命令，新建一个项目：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;python django-admin.py startproject mysite&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;startproject命令创建一个目录，包含一个名为mysite的文件夹和一个名为manage.py的文件。其中mysite文件夹下包含有四个文件，分别为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;(python_web) ➜  mysite tree
.
├── db.sqlite3
├── manage.py
└── mysite
    ├── __init__.py
    ├── settings.py
    ├── urls.py
    └── wsgi.py&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了安装后更多的体验，让我们运行一下django开发服务器看看我们的准系统。django开发服务是可用在开发期间的，一个内建的，轻量的web服务。 我们提供这个服务器是为了让你快速开发站点，也就是说在准备发布产品之前，无需进行产品级 Web 服务器（比如 Apache）的配置工作。 开发服务器监测你的代码并自动加载它，这样你会很容易修改代码而不用重启动服务。如果你还没启动服务器的话，请切换到你的项目目录里 (cd mysite)，运行下面的命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;python manage.py runserver&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你会看到如下内容：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Django version 1.11, using settings 'mysite.settings'
Starting development server at http://127.0.0.1:3000/
Quit the server with CTRL-BREAK&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这将会在端口3000启动一个本地服务器, 并且只能从你的这台电脑连接和访问。 既然服务器已经运行起来了，现在用网页浏览器访问 http://127.0.0.1:8000/ 。 你应该可以看到一个令人赏心悦目的淡蓝色Django欢迎页面。 表明它开始工作了。&lt;/p&gt;
&lt;p&gt;但是我的服务器搭在阿里云上，并且绑定了phage.cc的域名，因此可以通过这样的方式使之能访问：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;python manage.py runserver 0.0.0.0:3000&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注：0.0.0.0”这个IP地址，告诉服务器去侦听任意的网络接口。&lt;br/&gt;注：采用phage.cc:3000去访问会报错误 &lt;code&gt;alid HTTP_HOST header: 'www.phage.cc:3000'. You may need to add u'www.phage.cc' to ALLOWED_HOSTS.&lt;/code&gt; 可以通过添加允许来实现通过：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;settings.py : ALLOWED_HOSTS = [u'www.phage.cc']&lt;/code&gt;
&lt;/pre&gt;

&lt;h4 id=&quot;自己建视图&quot;&gt;4、自己建视图&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;4.1 静态视图hello world&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在文件夹mysite中新建一个views.py的文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from django.http import HttpResponse

def hello(request):
    return HttpResponse(&quot;Hello world&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这段代码中：我们定义一个叫做hello 的视图函数，这个函数只有简单的一行代码： 它仅仅返回一个HttpResponse对象，这个对象包含了文本“Hello world”。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;每个视图函数至少要有一个参数，通常被叫作request。 这是一个触发这个视图、包含当前Web请求信息的对象，是类django.http.HttpRequest的一个实例。在这个示例中，我们虽然不用request做任何事情，然而它仍必须是这个视图的第一个参数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;视图函数的名称并不重要；并不一定非得以某种特定的方式命名才能让 Django 识别它。 在这里我们把它命名为：hello，是因为这个名称清晰的显示了视图的用意。&lt;/p&gt;
&lt;p&gt; &lt;br/&gt;&lt;strong&gt;4.2 URLconf将视图和URL绑定（类似nodejs中的路由)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;URLconf 就像是 Django 所支撑网站的目录。 它的本质是 URL 模式以及要为该 URL 模式调用的视图函数之间的映射表。 你就是以这种方式告诉 Django，对于这个 URL 调用这段代码，对于那个 URL 调用那段代码。&lt;/p&gt;
&lt;p&gt;这个映射表在urls.py中，我们想要实现访问/hello/调用hello视图，返回hello world需要做下面样子修改：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from django.conf.urls import url

urlpatterns = [
    url(r'^hello/$', hello),
]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt; 这里的^hello/$是正则表达式，匹配所有/hello/形式的请求。&lt;/p&gt;
&lt;p&gt;之后我们运行该服务器，在浏览器中可以访问hello视图： http://www.phage.cc:3000/hello/&lt;/p&gt;
&lt;p&gt; &lt;br/&gt;&lt;strong&gt;4.3 动态内容视图请求当前时间&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在views.py中添加一个新视图current_datatime：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from django.http import HttpResponse
import datetime

def hello(request):
    return HttpResponse(&quot;Hello world&quot;)

def current_datetime(request):
    now = datetime.datetime.now()
    html = &quot;&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;It is now %s.&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&quot; % now
    return HttpResponse(html)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;类似hello视图，这里用了python的datetime工具，获取时间并合成一个html字符串，作为视图返回。&lt;/p&gt;
&lt;p&gt;同理，我们也需要在urls.py中做url映射：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from django.conf.urls import url
from mysite.views import hello, current_datetime

urlpatterns = [
    url(r'^hello/$', hello),
    url(r'^time/$', current_datetime),
]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样我们通过访问 http://www.phage.cc:3000/time/ 可以获取time视图返回。&lt;/p&gt;
&lt;p&gt; &lt;br/&gt;&lt;strong&gt;4.4 动态URL视图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在我们的&lt;code&gt;current_datetime&lt;/code&gt; 视图范例中，尽管内容是动态的，但是URL （ /time/ ）是静态的。 在 大多数动态web应用程序，URL通常都包含有相关的参数。 举个例子，一家在线书店会为每一本书提供一个URL，如：/books/243/、/books/81196/。&lt;/p&gt;
&lt;p&gt;让我们创建第三个视图来显示当前时间和加上时间偏差量的时间，设计是这样的： /time/plus/1/ 显示当前时间＋1个小时的页面 /time/plus/2/ 显示当前时间＋2个小时的页面 /time/plus/3/ 显示当前时间＋3个小时的页面，以此类推。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt; 在java或php中有可能见到这样的实现：/time/plus?hours=3，但这样被认为不漂亮&lt;/p&gt;
&lt;p&gt;之前我们已经看到url是以正则表达式的形式出现，因此想要实现/time/plus/xxx/也就比较容易了：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from django.conf.urls import url
from mysite.views import hello, current_datetime, hours_ahead

urlpatterns = [
    url(r'^hello/$', hello),
    url(r'^time/$', current_datetime),
    url(r'^time/plus/(\d{1,2})/$', hours_ahead),
]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么我们如是实现hours_ahead来接收请求中的xxx数字呢？&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from django.http import Http404, HttpResponse
import datetime

...
def hours_ahead(request, offset):
    try:
        offset = int(offset)
    except ValueError:
        raise Http404()
    dt = datetime.datetime.now() + datetime.timedelta(hours=offset)
    html = &quot;&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;In %s hour(s), it will be %s.&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&quot; % (offset, dt)
    return HttpResponse(html)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;hours_ahead 和我们以前写的 current_datetime 很象，关键的区别在于： 它多了一个额外参数，时间差。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt; offset 是从匹配的URL里提取出来的。 例如：如果请求URL是/time/plus/3/，那么offset将会是3；如果请求URL是/time/plus/21/，那么offset将会是21。请注意：捕获值永远都是字符串（string）类型，而不会是整数（integer）类型，即使这个字符串全由数字构成（如：“21”）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt; 在这里我们命名变量为 offset ，你也可以任意命名它，只要符合Python 的语法。 变量名是无关紧要的，重要的是它的位置，它是这个函数的第二个 参数 (在 request 的后面）。 你还可以使用关键字来定义它，而不是用 位置。&lt;/p&gt;

&lt;h4 id=&quot;模板&quot;&gt;5、模板&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;5.1 最简单的模板DEMO&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;模板的好处是将python和html分开，下面是一个最简单的例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def template_test(request):
    now = datetime.datetime.now()
    t = Template(&quot;&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;It is now {{ current_date }}.&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&quot;);
    html = t.render(Context({'current_date': now}))
    return HttpResponse(html)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的例子在html中嵌入一个 current_date 变量，通过context给变量赋值，通过render来渲染。除了双大括号表示的变量，还有循环、条件等各种玩法： https://docs.djangoproject.com/en/2.1/ref/templates/builtins/ 。&lt;/p&gt;
&lt;p&gt; &lt;br/&gt;&lt;strong&gt;5.2 将html和python彻底分离&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;但是上面我们并没有真正将html和python分离，更进一步的做法是将html单独放置：&lt;/p&gt;
&lt;p&gt;1) 在mysite下新建一个文件夹：templates，并在其中新建一个template_test1.html：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;It is now {{ current_date }}.&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2) 而我们的template_test就能改造成：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def template_test1(request):
    now = datetime.datetime.now()
    t = get_template('template_test1.html');
    html = t.render({'current_date': now})
    return HttpResponse(html)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3) 最后我们得通过下面方法让get_template的输入参数不用写完整路径：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;TEMPLATES = [
    {
    'BACKEND': 'django.template.backends.django.DjangoTemplates',
    'DIRS': [os.path.join(os.path.dirname(__file__), 'templates').replace('\\','/'),],
    'APP_DIRS': True,
    'OPTIONS': {&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;我们还可以用render_to_response来简化template_test操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def template_test2(request):
    now = datetime.datetime.now()
    return render_to_response('template_test1.html', {'current_date': now})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt; &lt;br/&gt;&lt;strong&gt;5.3 模板继承&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个多页面的网站，其每个页面可能会有相同的头部、尾部的结构，主页面的内容存在更新变动。如果我们为每个页面单独创建一个独立的html将会产生大量冗余，此外如果我们想要对所有页面的头部做一个修改，也将比较麻烦。此时我们可以采用模板的思想来完美解决这个问题：&lt;/p&gt;
&lt;p&gt;1）新建一个母版html（base.html)&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;(python_web) ➜  templates git:(master) cat base.html 
&amp;lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot;&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
    &amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;{% block title %}{% endblock %}&amp;lt;/title&amp;gt;
    &amp;lt;/head&amp;gt;
    &amp;lt;body&amp;gt;
    &amp;lt;h1&amp;gt;My helpful timestamp site&amp;lt;/h1&amp;gt;
    {% block content %}{% endblock %}
    {% block footer %}
    &amp;lt;hr&amp;gt;
    &amp;lt;p&amp;gt;Thanks for visiting my site.&amp;lt;/p&amp;gt;
    {% endblock %}
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2) 创建一个继承base.html的template_test2_use_base_1.html:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;(python_web) ➜  templates git:(master) cat template_test2_use_base_1.html 
{% extends &quot;base.html&quot; %}

{% block title %}The current time{% endblock %}

{% block content %}
&amp;lt;p&amp;gt;It is now {{ current_date }}.&amp;lt;/p&amp;gt;
{% endblock %}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3) 再创建一个继承base.html的template_test2_use_base_2.html:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;(python_web) ➜  templates git:(master) cat template_test2_use_base_2.html 
{% extends &quot;base.html&quot; %}

{% block title %}Future time{% endblock %}

{% block content %}
&amp;lt;p&amp;gt;In {{ hour_offset  }} hour(s), it will be {{ next_time  }}.&amp;lt;/p&amp;gt;
{% endblock %}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可见base.html中的{% block title %}{% endblock %} 、{% block content %}{% endblock %} 、{% block footer %}{% endblock %} 都可以被继承者们重新实现！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;当然，如果继承者没有实现，则不会显示。&lt;/p&gt;

&lt;h4 id=&quot;python-django的数据库操作&quot;&gt;6、python django的数据库操作&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;6.1 安装MYSQL数据库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们先在linux上安装数据库：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;sudo apt-get install mysql-server
sudo apt-get install libmysqlclient-dev&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装过程中会提示设置密码什么的，注意设置了不要忘了，安装完成之后可以使用如下命令来检查是否安装成功：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;sudo netstat -tap | grep mysql&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过上述命令检查之后，如果看到有mysql 的socket处于 listen 状态则表示安装成功。&lt;/p&gt;
&lt;p&gt;登陆mysql数据库可以通过如下命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql -u root -p&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;-u 表示选择登陆的用户名， -p 表示登陆的用户密码，上面命令输入之后会提示输入密码，此时输入密码就可以登录到mysql。&lt;/p&gt;
&lt;p&gt;下面是一些命令行中操作的DEMO，可做今后参考：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysqladmin -u root -p create blog
mysql  mysql -u root -p
show databases;
use blog;

CREATE TABLE IF NOT EXISTS `blog_table`(
   `blogId` BIGINT UNSIGNED,
   `url` VARCHAR(100) NOT NULL,
   `title` VARCHAR(1000) NOT NULL,
   `support` INT UNSIGNED,
   `pageView` INT UNSIGNED,
   PRIMARY KEY ( `blogId` )
)ENGINE=InnoDB DEFAULT CHARSET=utf8;

CREATE TABLE IF NOT EXISTS `tag_table`(
   `tagId` INT UNSIGNED AUTO_INCREMENT,
   `tagName` VARCHAR(100) NOT NULL,
   PRIMARY KEY ( `tagId` )
)ENGINE=InnoDB DEFAULT CHARSET=utf8;

CREATE TABLE IF NOT EXISTS `blog_tag_relation_table`(
   `relationId` INT UNSIGNED AUTO_INCREMENT,
   `blogId` BIGINT UNSIGNED,
   `tagId` INT UNSIGNED,
   PRIMARY KEY ( `relationId` )
)ENGINE=InnoDB DEFAULT CHARSET=utf8;

show tables;
desc blog_table;
desc tag_table;
desc blog_tag_relation_table;

//change blogId int 2 bigint
alter table blog_table change blogId blogId BIGINT UNSIGNED;
//show data
select * from blog_table;
//delete data
delete from blog_table where blogId=201801021423;

INSERT INTO blog_table(blogId,url,title,support,pageView) 
VALUES(201801021423,'http://106.14.226.191:3000/blog/201607281658.html','[商业_法务] 1、公司一款新消费类电子产品如何快速全面的专利保护',0,0);

//too short
alter table blog_table change title title VARCHAR(1000) NOT NULL;


INSERT INTO tag_table(tagId,tagName) 
VALUES(0,'硬件_模拟电路');

select * from blog_table;
select * from tag_table;
select * from blog_tag_relation_table;

delete from blog_table where blogId&amp;gt;0;
delete from tag_table where tagId&amp;gt;=0;
delete from blog_tag_relation_table where relationId &amp;gt;= 0;

select a.title , a.url, b.tagName from blog_table a, tag_table b, blog_tag_relation_table c WHERE a.blogId = c.blogId AND a.blogId = 201602021408 AND b.tagId = c.tagId;

select a.title , a.url, b.tagName from blog_table a, tag_table b, blog_tag_relation_table c WHERE a.blogId = c.blogId AND b.tagId = c.tagId ORDER BY b.tagId;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了python操作mysql需要执行下面命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;pip install MySQL-python&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt; &lt;br/&gt;&lt;strong&gt;6.2 配置及测试数据库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在settings.py中下面几项是对数据库的配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;DATABASES = {
    'default': {
    'ENGINE': 'django.db.backends.mysql',
    'NAME': 'pyserver',
    'USER': 'root',
    'PASSWORD': '123456',
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一旦在输入了那些设置并保存之后应当测试一下你的配置。 我们可以在&lt;code&gt;mysite&lt;/code&gt; 项目目录下执行&lt;code&gt;python manage.py shell&lt;/code&gt; 来进行测试(没有错误表示成功):&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from django.db import connection
cursor = connection.cursor()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt; &lt;br/&gt;&lt;strong&gt;6.3 创建books app&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;mysite&lt;/code&gt; 项目文件下输入下面的命令来创建&lt;code&gt;books&lt;/code&gt; app：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;python manage.py startapp books&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个命令并没有输出什么，它只在 mysite 的目录里创建了一个 books 目录。 让我们来看看这个目录的内容：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;(python_web) ➜  books tree
.
├── admin.py
├── apps.py
├── __init__.py
├── migrations
│   └── __init__.py
├── models.py
├── tests.py
└── views.py&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个目录包含了这个app的模型和视图。&lt;/p&gt;
&lt;p&gt; &lt;br/&gt;&lt;strong&gt;6.4 编写模型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;编辑&lt;code&gt;models.py&lt;/code&gt; :&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from django.db import models

class Publisher(models.Model):
    name = models.CharField(max_length=30)
    address = models.CharField(max_length=50)
    city = models.CharField(max_length=60)
    state_province = models.CharField(max_length=30)
    country = models.CharField(max_length=50)
    website = models.URLField()

class Author(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=40)
    email = models.EmailField()

class Book(models.Model):
    title = models.CharField(max_length=100)
    authors = models.ManyToManyField(Author)
    publisher = models.ForeignKey(Publisher)
    publication_date = models.DateField()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Publisher 模块相当于SQL语句：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;CREATE TABLE &quot;books_publisher&quot; (
    &quot;id&quot; serial NOT NULL PRIMARY KEY,
    &quot;name&quot; varchar(30) NOT NULL,
    &quot;address&quot; varchar(50) NOT NULL,
    &quot;city&quot; varchar(60) NOT NULL,
    &quot;state_province&quot; varchar(30) NOT NULL,
    &quot;country&quot; varchar(50) NOT NULL,
    &quot;website&quot; varchar(200) NOT NULL
);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt; &lt;br/&gt;&lt;strong&gt;6.5 由模型自动生成创建表SQL&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;再次编辑settings.py，将下面列出选项加&lt;code&gt;#&lt;/code&gt;注释掉，并添加&lt;code&gt;‘mysite.books’&lt;/code&gt; 到&lt;code&gt;INSTALLED_APPS&lt;/code&gt; 的末尾：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;INSTALLED_APPS = [
    #'django.contrib.admin',
    #'django.contrib.auth',
    #'django.contrib.contenttypes',
    #'django.contrib.sessions',
    #'django.contrib.messages',
    #'django.contrib.staticfiles',
    'books', 
]

MIDDLEWARE = [
    #'django.middleware.security.SecurityMiddleware',
    #'django.contrib.sessions.middleware.SessionMiddleware',
    #'django.middleware.common.CommonMiddleware',
    #'django.middleware.csrf.CsrfViewMiddleware',
    #'django.contrib.auth.middleware.AuthenticationMiddleware',
    #'django.contrib.messages.middleware.MessageMiddleware',
    #'django.middleware.clickjacking.XFrameOptionsMiddleware',
]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你可能会执行python manage.py validate ，然后你会特别伤心的看到人家提示Unknown command: 'validate'Type 'manage.py help' for usage.，对吧？所以你要用如下这个命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;python manage.py check&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后你还想生成sql语句，你就运行了python manage.py sqlall books,错误提示是Unknown command: 'sqlall'Type 'manage.py help' for usage.同样如果你想提交sql语句到数据库而运行syncdb，错误提示是Unknown command: 'syncdb'&lt;/p&gt;
&lt;p&gt;Type 'manage.py help' for usage. 为什么没有这些命令，因为它们被淘汰了。所以你只需运行如下的命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;python manage.py makemigrations books    #用来检测数据库变更和生成数据库迁移文件
python manage.py migrate     #用来迁移数据库(直接到数据库)
python manage.py sqlmigrate books 0001 # 用来把数据库迁移文件转换成数据库语言&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt; &lt;br/&gt;&lt;strong&gt;6.6 基本数据访问&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一旦你创建了模型，Django自动为这些模型提供了高级的Python API。 运行 python manage.py shell 并输入下面的内容试试看：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from books.models import Publisher
&amp;gt;&amp;gt;&amp;gt; p1 = Publisher(name='Apress', address='2855 Telegraph Avenue',
...     city='Berkeley', state_province='CA', country='U.S.A.',
...     website='http://www.apress.com/')
&amp;gt;&amp;gt;&amp;gt; p1.save()
&amp;gt;&amp;gt;&amp;gt; p2 = Publisher(name=&quot;O'Reilly&quot;, address='10 Fawcett St.',
...     city='Cambridge', state_province='MA', country='U.S.A.',
...     website='http://www.oreilly.com/')
&amp;gt;&amp;gt;&amp;gt; p2.save()
&amp;gt;&amp;gt;&amp;gt; publisher_list = Publisher.objects.all()
&amp;gt;&amp;gt;&amp;gt; publisher_list
[&amp;lt;Publisher: Publisher object&amp;gt;, &amp;lt;Publisher: Publisher object&amp;gt;]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其他常用基本操作如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;创建：&lt;code&gt;p1 = Publisher.objects.create(....)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;修改：&lt;code&gt;p1.name = 'Apress Publishing'&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;过滤：&lt;code&gt;Publisher.objects.filter(country=&quot;U.S.A.&quot;, state_province=&quot;CA&quot;)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;单个：&lt;code&gt;Publisher.objects.get(name=&quot;Apress&quot;)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;排序：&lt;code&gt;Publisher.objects.order_by(&quot;state_province&quot;, &quot;address&quot;)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;查询：&lt;code&gt;Publisher.objects.filter(country=&quot;U.S.A.&quot;).order_by(&quot;-name&quot;)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;数组：&lt;code&gt;Publisher.objects.order_by('name')[0]&lt;/code&gt; or &lt;code&gt;[0:2]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;多个：&lt;code&gt;Publisher.objects.filter(id=52).update(name='Apress Publishing')&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;保存：&lt;code&gt;p.save()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;删除：&lt;code&gt;p.delete()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;上述操作除了删除，每个操作之后都别忘了保存！&lt;/p&gt;

&lt;h4 id=&quot;站点管理&quot;&gt;7、站点管理&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;7.1 基本操作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;编辑settings.py:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'books', 
]

MIDDLEWARE = [
    #'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    #'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    #'django.middleware.clickjacking.XFrameOptionsMiddleware',
]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;之后运行&lt;code&gt;python manage.py migrate&lt;/code&gt;这一步将生成管理界面使用的额外数据库表。 当你把'django.contrib.auth'加进INSTALLED_APPS后，第一次运行syncdb命令时, 系统会请你创建一个超级用户。 如果你不这么作，你需要运行python manage.py createsuperuser来另外创建一个admin的用户帐号，否则你将不能登入admin（我这里设置user:admin password:xxxxxx）&lt;/p&gt;
&lt;p&gt;将admin访问配置在URLconf(记住，在urls.py中)&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from django.conf.urls import url
from django.contrib import admin
from django.conf.urls import include
#from mysite.views import hello
from mysite.views import hello, current_datetime, hours_ahead, template_test, template_test1, template_test2, template_test3, template_test4

admin.autodiscover()

urlpatterns = [
    url(r'^admin/', include(admin.site.urls)),
    ...
]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时运行&lt;code&gt;python manage.py runserver 0.0.0.0:8080&lt;/code&gt;，然后在浏览器中访问： http://www.phage.cc:8080/admin/&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;NameError: name 'include' is not defined错误需要from django.conf.urls import include;&lt;br/&gt;&lt;strong&gt;注：&lt;/strong&gt;django nginx admin css丢失需要在settings.py中INSTALLED_APPS中加&lt;a href=&quot;https://stackoverflow.com/questions/17804743/django-admin-py-unknown-command-collectstatic&quot;&gt;django.contrib.staticfiles&lt;/a&gt;;&lt;/p&gt;
&lt;p&gt; &lt;br/&gt;&lt;strong&gt;7.2 管理工具简介&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;管理界面的设计是针对非技术人员的，所以它应该是自我解释的。 尽管如此，这里简单介绍一下它的基本特性：&lt;/p&gt;
&lt;p&gt;1）登录页面（用户名密码就是刚刚生成的admin,xxxxxxxxx）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://tuchuang.beautifulzzzz.com:3000/?path=/dc/3356d30d5026f2eaebbdc2a3b8f987.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;你要使用你原来设置的超级用户的用户名和密码。 如果无法登录，请运行&lt;code&gt;python manage.py createsuperuser&lt;/code&gt; ，确保你已经创建了一个超级用户。&lt;/p&gt;
&lt;p&gt;2）一旦登录了，你将看到管理页面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://tuchuang.beautifulzzzz.com:3000/?path=/bd/ae3f04da3d71d4da306a1cdce4dc15.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个页面列出了管理工具中可编辑的所有数据类型。 现在，由于我们还没有创建任何模块，所以这个列表只有寥寥数条类目： 它仅有两个默认的管理-编辑模块：用户组(Groups)和用户(Users)。&lt;/p&gt;
&lt;p&gt;3）点进去USER可以添加、修改、删除等操作，非常方便：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://tuchuang.beautifulzzzz.com:3000/?path=/03/40e5899d5ebbebcd1dceac4766fb32.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;br/&gt;&lt;strong&gt;7.3 将其他Models加入到Admin管理中&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有一个关键步骤我们还没做。 让我们将自己的模块加入管理工具中，这样我们就能够通过这个漂亮的界面添加、修改和删除数据库中的对象了。 我们将继续第五章中的&lt;code&gt;book&lt;/code&gt; 例子。在其中，我们定义了三个模块： Publisher 、 Author 和 Book 。&lt;/p&gt;
&lt;p&gt;编辑&lt;code&gt;mysite/books/admin.py&lt;/code&gt;，然后输入：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# -*- coding: utf-8 -*-
from __future__ import unicode_literals

from django.contrib import admin
from books.models import Publisher, Author, Book

admin.site.register(Publisher)
admin.site.register(Author)
admin.site.register(Book)

# Register your models here.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重启服务器，现在再去admin主页，就会看到Publisher 、 Author 和 Book模块，这样就能编辑这些模块了！&lt;/p&gt;
&lt;p&gt; &lt;br/&gt;&lt;strong&gt;7.4 工作原理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当服务启动时，Django从&lt;code&gt;url.py&lt;/code&gt; 引导URLconf，然后执行&lt;code&gt;admin.autodiscover()&lt;/code&gt; 语句。 这个函数遍历INSTALLED_APPS配置，并且寻找相关的 admin.py文件。 如果在指定的app目录下找到admin.py，它就执行其中的代码。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;books&lt;/code&gt; 应用程序目录下的&lt;code&gt;admin.py&lt;/code&gt; 文件中，每次调用&lt;code&gt;admin.site.register()&lt;/code&gt; 都将那个模块注册到管理工具中。 管理工具只为那些明确注册了的模块显示一个编辑/修改的界面。&lt;/p&gt;
&lt;p&gt; &lt;br/&gt;&lt;strong&gt;7.5 设置字段可选&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li&gt;可以为空：&lt;code&gt;email = models.EmailField(**blank=True** )&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;自定义字段标签：&lt;code&gt;email = models.EmailField(blank=True, **verbose_name='e-mail'** )&lt;/code&gt;&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;自定义列表：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  class Author(models.Model):
      first_name = models.CharField(max_length=30)
      last_name = models.CharField(max_length=40)
      email = models.EmailField(blank=True, verbose_name='e-mail')

      **def __unicode__(self):**
      **return u'%s %s' % (self.first_name, self.last_name)**&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;更多展示自定义可以参考&lt;a href=&quot;http://djangobook.py3k.cn/2.0/chapter06/&quot;&gt;[12]. The Django Book - 第六章 Django站点管理&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;表单&quot;&gt;8、表单&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;8.1 URL相关信息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;HttpRequest对象包含当前请求URL的一些信息：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;request.path&lt;/td&gt;
&lt;td&gt;除域名以外的请求路径，以正斜杠开头&lt;/td&gt;
&lt;td&gt;&quot;/hello/&quot;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;request.get_host()&lt;/td&gt;
&lt;td&gt;主机名（比如，通常所说的域名）&lt;/td&gt;
&lt;td&gt;&quot;127.0.0.1:8000&quot; or &quot;www.example.com&quot;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;request.get_full_path()&lt;/td&gt;
&lt;td&gt;请求路径，可能包含查询字符串&lt;/td&gt;
&lt;td&gt;&quot;/hello/?print=true&quot;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;request.is_secure()&lt;/td&gt;
&lt;td&gt;如果通过HTTPS访问，则此方法返回True， 否则返回False&lt;/td&gt;
&lt;td&gt;True 或者 False&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt; &lt;br/&gt;&lt;strong&gt;8.2 一个简单的SEARCH表单&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;views.search()&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def search(request):
    error = False
    if 'q' in request.GET:
    q = request.GET['q']
    if not q:
        error = True
    else:
        books = Book.objects.filter(title__icontains=q)
        return render_to_response('search_results.html',{'books': books, 'query': q})
    return render_to_response('search_form.html',{'error': error})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;search_form.html&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;html&amp;gt;
    &amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;Search&amp;lt;/title&amp;gt;
    &amp;lt;/head&amp;gt;
    &amp;lt;body&amp;gt;
    {% if error %}
        &amp;lt;p style=&quot;color: red;&quot;&amp;gt;Please submit a search term.&amp;lt;/p&amp;gt;
    {% endif %}
    &amp;lt;form action=&quot;&quot; method=&quot;get&quot;&amp;gt;
        &amp;lt;input type=&quot;text&quot; name=&quot;q&quot;&amp;gt;
        &amp;lt;input type=&quot;submit&quot; value=&quot;Search&quot;&amp;gt;
    &amp;lt;/form&amp;gt;
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;search_results.html&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;p&amp;gt;You searched for: &amp;lt;strong&amp;gt;{{ query  }}&amp;lt;/strong&amp;gt;&amp;lt;/p&amp;gt;

{% if books %}
    &amp;lt;p&amp;gt;Found {{ books|length  }} book{{ books|pluralize  }}.&amp;lt;/p&amp;gt;
    &amp;lt;ul&amp;gt;
    {% for book in books %}
    &amp;lt;li&amp;gt;{{ book.title  }}&amp;lt;/li&amp;gt;
    {% endfor %}
    &amp;lt;/ul&amp;gt;
{% else %}
    &amp;lt;p&amp;gt;No books matched your search criteria.&amp;lt;/p&amp;gt;
{% endif %}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;更高级的用法我们在后面的DEMO中介绍！&lt;/p&gt;

&lt;h4 id=&quot;实战-实操一个github上1.6k-star量的博客系统&quot;&gt;9、实战-实操一个github上1.6K star量的博客系统&lt;/h4&gt;
&lt;p&gt;项目地址： https://github.com/zmrenwu/django-blog-tutorial&lt;br/&gt;项目master： https://github.com/zmrenwu&lt;/p&gt;
&lt;p&gt; &lt;br/&gt;&lt;strong&gt;9.1 将项目部署在我们买AliYun上&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下载项目到本地：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cd ~/App/
git clone https://github.com/zmrenwu/django-blog-tutorial.git&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建并激活虚拟环境（一定要注意是python3）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;virtualenv blogproject_env -p python3
source blogproject_env/bin/activate&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装依赖并数据迁移（sqlite的）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;pip install -r requirements.txt
python manage.py migrate&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建后台管理员账户并启动服务器（我这里其他端口被占用，因此用8080）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;python manage.py createsuperuser
python manage.py runserver 0.0.0.0:8080&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于我们不是在本地运行，因此还得在settings.py中添加: &lt;code&gt;ALLOWED_HOSTS = [u'www.phage.cc']&lt;/code&gt; 。此时，便可以访问 http://www.phage.cc:8080/admin/ 对品类、文章、标签、用户等进行管理了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://tuchuang.beautifulzzzz.com:3000/?path=/c7/6e4ba90a99047a14e95f1646fdc6a3.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;访问： http://www.phage.cc:8080/ 便可看到我们在后台添加的 python-django 文章：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://tuchuang.beautifulzzzz.com:3000/?path=/46/75e4336ead9266e7b369b0df2aebb6.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;br/&gt;&lt;strong&gt;9.2 代码解析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先看看所有支持的url入口配置文件：/blog/urls.py&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from django.conf.urls import url

from . import views

app_name = 'blog'
urlpatterns = [
    url(r'^$', views.IndexView.as_view(), name='index'),
    url(r'^post/(?P&amp;lt;pk&amp;gt;[0-9]+)/$', views.PostDetailView.as_view(), name='detail'),
    url(r'^archives/(?P&amp;lt;year&amp;gt;[0-9]{4})/(?P&amp;lt;month&amp;gt;[0-9]{1,2})/$', views.ArchivesView.as_view(), name='archives'),
    url(r'^category/(?P&amp;lt;pk&amp;gt;[0-9]+)/$', views.CategoryView.as_view(), name='category'),
    url(r'^tag/(?P&amp;lt;pk&amp;gt;[0-9]+)/$', views.TagView.as_view(), name='tag'),
    # url(r'^search/$', views.search, name='search'),
]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其主页调用views.IndexView.as_view()实现的，但是为什么有第三个参数name='idnex'呢？我们看/blog/view.py的IndexView就明白了，这里类IndexView继承Django的Generic display views来实现的，看一下&lt;a href=&quot;https://docs.djangoproject.com/en/2.1/ref/class-based-views/generic-display/&quot;&gt;Generic display views&lt;/a&gt;中的ListViewd的用法就明白了。其他的各种入口则依此类推：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class IndexView(ListView):
...

class PostDetailView(DetailView):
...

class ArchivesView(ListView):
...

class CategoryView(ListView):
...

class TagView(ListView):
...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们倒着分析各个入口的实现（倒着由浅入深），看第一个TagView的实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class TagView(ListView):
    model = Post
    template_name = 'blog/index.html'
    context_object_name = 'post_list'

    def get_queryset(self):
        tag = get_object_or_404(Tag, pk=self.kwargs.get('pk'))
        return super(TagView, self).get_queryset().filter(tags=tag)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;TagView继承ListView：重设置model和tempale_name为会导致 —— 通用视图将查询数据库以获取指定model（Post）的所有记录，然后呈现位于/templates/blog/index.html的模板；而context_object_name重定义的意义在于 —— your own name for the list as a template variable；重写get_queryset方法 —— 从数据库中过滤出所有tag，将get_queryset方法添加到基于类的自定义视图中，并指定order_by()。&lt;/p&gt;
&lt;p&gt;这里的get_object_or_404的功能在于如果找不到记录，就引发Http404异常的快捷方式，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Learn/Server-side/Django/Generic_views&quot;&gt;见下面的例子&lt;/a&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def book_detail_view(request, primary_key):
    try:
        book = Book.objects.get(pk=primary_key)
    except Book.DoesNotExist:
        raise Http404('Book does not exist')
    
    return render(request, 'catalog/book_detail.html', context={'book': book})

利用get_object_or_404来实现：

from django.shortcuts import get_object_or_404

def book_detail_view(request, primary_key):
    book = get_object_or_404(Book, pk=primary_key)
    return render(request, 'catalog/book_detail.html', context={'book': book})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来的CategoryView、ArchivesView和TagView一样，我们重点看PostDetailView和IndexView：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class IndexView(ListView):
    model = Post
    template_name = 'blog/index.html'
    context_object_name = 'post_list'
    paginate_by = 10

    def get_context_data(self, **kwargs):
    ...
    
    def pagination_data(self, paginator, page, is_paginated):
    ...  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面已经介绍：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;model ： 将 model 指定为 Post，告诉 Django 我要获取的模型是 Post。&lt;/li&gt;
&lt;li&gt;template_name ： 指定这个视图渲染的模板。&lt;/li&gt;
&lt;li&gt;context_object_name ： 指定获取的模型列表数据保存的变量名。这个变量会被传递给模板。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;等效于：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;blog/views.py

def index(request):
    post_list = Post.objects.all()
    return render(request, 'blog/index.html', context={'post_list': post_list})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而PostDetailView则继承了DetailView，该模板用于从数据库中取出一条记录并渲染，其中model、template、context_object_name和ListView类似；这里覆写了get方法是为了阅读量加1的运算，同时注意到用super继承了原来的response并返回；覆写 get_object 方法的目的是因为需要对 post 的 body 值进行渲染；覆写 get_context_data 的目的是因为除了将 post 传递给模板外（DetailView 已经帮我们完成），还要把评论表单、post 下的评论列表传递给模板。&lt;/p&gt;
&lt;p&gt;更详细的操作大家可以从GIT上获取： https://github.com/zmrenwu/django-blog-tutorial&lt;/p&gt;

&lt;p&gt;: &lt;strong&gt;完～&lt;/strong&gt;&lt;br/&gt;: &lt;strong&gt;大家觉得不错，可以点推荐给更多人～&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;link&quot;&gt;LINK&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/zjutlitao/p/8261688.html&quot;&gt;[1]. 02、PI3安装openCV开发环境做图像识别(详细版)&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/maybe2030/p/4600872.html&quot;&gt;[2]. 利用Django进行Web开发系列（一）&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://zzk.cnblogs.com/s?t=b&amp;amp;w=python%20web&quot;&gt;[3]. 博客园python web关键词搜索&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://djangobook.py3k.cn/2.0/chapter01/&quot;&gt;[4]. The Django Book&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://djangobook.py3k.cn/2.0/chapter03/&quot;&gt;[5]. The Django Book - 第三章 视图和URL配置&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://docs.djangoproject.com/en/2.1/ref/templates/builtins/&quot;&gt;[6]. Built-in template tags and filters&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://djangobook.py3k.cn/2.0/chapter05/&quot;&gt;[7]. The Django Book - 第五章 模型&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.linuxidc.com/Linux/2016-07/133128.htm&quot;&gt;[8]. Ubuntu下安装MySQL及简单操作&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://pypi.org/project/MySQL-python/&quot;&gt;[9]. MySQL-python 1.2.5&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/yy_menghuanjie/article/details/51332075&quot;&gt;[10]. 在Django中使用数据库遇到的问题&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://stackoverflow.com/questions/28444614/django-manage-py-unknown-command-syncdb&quot;&gt;[11]. Django manage.py Unknown command: 'syncdb'&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://djangobook.py3k.cn/2.0/chapter06/&quot;&gt;[12]. The Django Book - 第六章 Django站点管理&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://django-book.readthedocs.io/en/latest/chapter06.html&quot;&gt;[13]. Chapter 6: The Django Admin Site&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://gsl.mit.edu/media/programs/south-africa-summer-2015/materials/djangobook.pdf&quot;&gt;[14]. The Django Book PDF&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://djangobook.py3k.cn/2.0/chapter08/&quot;&gt;[15]. The Django Book - 第八章：高级视图和URL配置&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Learn/Server-side/Django/Generic_views&quot;&gt;[16]. Django Tutorial Part 6: Generic list and detail views&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.zmrenwu.com/post/33/&quot;&gt;[17]. 基于类的通用视图：ListView 和 DetailView&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;@beautifulzzzz
智能硬件、物联网，热爱技术，关注产品
博客：http://blog.beautifulzzzz.com
园友交流群：414948975&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sun, 23 Dec 2018 17:35:00 +0000</pubDate>
<dc:creator>beautifulzzzz</dc:creator>
<og:description>1、安装python环境 1.1 安装python包管理器： wget https://bootstrap.pypa.io/get pip.py sudo python get pip.py &amp;nbs</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zjutlitao/p/9919922.html</dc:identifier>
</item>
<item>
<title>SOLDI原则之DIP：依赖倒置原则 - coderidea</title>
<link>http://www.cnblogs.com/xiaoyao2011/p/10166607.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaoyao2011/p/10166607.html</guid>
<description>&lt;p&gt;&lt;span&gt;本篇介绍软件设计原则之一DIP：依赖倒置原则。很多知识回头来看会有新的理解。看到一句话，一段文字，一个观点有了新的理解，醍醐灌顶的感觉。这种感觉像是一种惊喜。古语说：温故而知新。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;DIP：依赖倒置原则&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;a.高层模块不应该依赖于低层模块。二者都应该依赖于抽象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;b.抽象不应该依赖于细节。细节应该依赖于抽象。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;层次化&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Booch曾经说过：“所有结构良好的面向对象架构都具有清晰的层次定义，每个层次通过一个定义良好的、受控的接口向外提供了一组内聚的服务”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;倒置的接口所有权&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里的倒置不仅仅是依赖关系的倒置，它也是&lt;strong&gt;接口所有权的倒置&lt;/strong&gt;。我们通常会认为工具库应该拥有它们自己的接口。但是当应用了DIP时，我们发现往往是客户拥有抽象接口，而它们的服务者从这些抽象接口派生。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;依赖于抽象&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;该启发式规则建议不应该依赖于具体类——也就是说应该终止于抽象类或接口。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们在应用程序中所编写的大多数的类是不稳定的。我们不想直接依赖于这些不稳定的具体类。通过把它们隐藏在抽象接口的后面，可以隔离它们的不稳定性。但这不是一个完整的解决方案，常常，如果一个不稳定的接口必须要变化时，这个变化一定会影响到表示该类的接口。这种变化还是破坏了由抽象接口维系的隔离性。如果看得更远一些，认为是由客户模块或层来声明它们需要的服务接口，那么仅当客户需要时才会对接口进行改变。这样，改变实现抽象接口的类就不会影响到客户。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么我们来聊下我们应用中常用的架构类型，微软为了展示.Net企业系统开发的能力。曾经发布过一个PetShop作为范例，后来很多企业系统的架构都采用了参照了或简化了此架构设计。标准的三层架构。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;1&quot;&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/323522/201812/323522-20181224005254395-1458457626.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;从上图所知，业务层对数据访问层抽象出来的IDAL模块，除了解除了向下的依赖之外，对于其上的业务逻辑层，相同仅存在弱依赖关系。那么来看这个设计满足了DIP：依赖倒置原则的高层模块不应该依赖于低层模块，二者都应该依赖于抽象。 传统的软件开发，比如结构化分析和设计，总是倾向于创建一些高层模块依赖于低层模块、策略依赖于细节的软件结构。实际上这些方法的目的之一就是要定义子程序层次结构，该层次结构描述了高层模块怎么调用低层模块。一个设计良好的面向对象程序（如上图所示的Petshop ),其依赖程序结构相当于传统的过程式方法设计的通常结构而言就是被“倒置“了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;那么IDAL接口层的所有权属于谁的&lt;/strong&gt;？以前一直有这个疑问直到看到这一章疑问解决了。通常认为IDAL接口层属于DAl层，那是不对的。&lt;strong&gt;这里的IDAL接口层的所有权是属于BLL层了，接口所有权倒置&lt;/strong&gt;了。通过倒置这些依赖关系，我们创建了一个更灵活、更持久、更易改变的结构。高层模块BLL不在直接依赖DAL层，而依赖抽象IDAL接口层。则层与层之间的关系就是松散耦合的。假设此时必须要改动数据访问层的实现，仅仅重新实现IDAL的接口定义，那么业务逻辑层就不会受到影响。毕竟，无论是SQLServerDAL还是OracalDAL与业务逻辑层实现没有直接的关系。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;面象对象的程序设计倒置了依赖关系，使得细节和策略依赖于抽象，并且常常是客户拥有服务接口。依赖关系的倒置正是好的面向对象设计的标志所在。是实现许多面向对象技术所宣称的好处的基本低层机制。它的正确应用对于创建重用的框架来说是必需的。同时它对于构建在变化面前富有弹性也是重要的。由于抽象和细节彼此隔离，所以代码也非常容易维护。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;其实最深的体会是对接口所有权倒置的理解。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;代码示例地址：&lt;/strong&gt;&lt;a href=&quot;https://github.com/tianyaxiang/ApplicationArchitecture&quot; target=&quot;_blank&quot;&gt;https://github.com/tianyaxiang/ApplicationArchitecture&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本文首发于个人微信公众号：webguan ；欢迎您的关注&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;img class=&quot;has&quot; src=&quot;https://img-blog.csdn.net/20180825235533667?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpYW55YXhpYW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 23 Dec 2018 16:52:00 +0000</pubDate>
<dc:creator>coderidea</dc:creator>
<og:description>本篇介绍软件设计原则之一DIP：依赖倒置原则。很多知识回头来看会有新的理解。看到一句话，一段文字，一个观点有了新的理解，醍醐灌顶的感觉。这种感觉像是一种惊喜。古语说：温故而知新。 DIP：依赖倒置原则</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaoyao2011/p/10166607.html</dc:identifier>
</item>
<item>
<title>Spring IOC容器启动流程源码解析(四)——初始化单实例bean阶段 - takumiCX</title>
<link>http://www.cnblogs.com/takumicx/p/10162811.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/takumicx/p/10162811.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;h2 id=&quot;引言&quot;&gt;1. 引言&lt;/h2&gt;
&lt;p&gt;之前开了一个解读IOC容器启动源码的坑&lt;a href=&quot;https://www.cnblogs.com/takumicx/p/9757492.html&quot;&gt;Spring IOC容器启动流程源码解析(一)——容器概念详解及源码初探&lt;/a&gt;,不过由于最近比较忙,这个坑挖了却一直没时间填。最近在看分布式事务相关的开源项目,碰到了一些Spring AOP相关的问题,比如Spring AOP中的增强逻辑是何时以何种方式织入目标类中的;多个切面的执行顺序如何确定;如何以反射的方式调用事务方法等等,才发现我对Spring AOP的底层了解的还是太少了。Spring AOP默认使用动态代理的方式在运行时织入切面,这个动态代理对象需要由Spring容器创建并进行管理。因而,深入了解Spring AOP的前提就是熟悉IOC容器创建一个实例的过程,这个过程清晰了,自然也就找到了继续深入研究Spring AOP的入口。趁着这个机会就先来好好梳理下IOC容器创建实例的流程,顺便也把解读IOC容器启动源码这个大坑的第四部分(初始化单实例bean)先填了,其实这也是整个IOC容器启动流程中最重要的阶段,这部分内容非常复杂,细节相当多,对这部分的讲解主要还是以梳理流程为主,知道容器初始化单实例bean的过程分为哪几个阶段,每个阶段主要做了哪些工作,解决了哪些重要的问题,一些和容器核心功能无关的细节可以适当忽略,这样分清主次更有助于理解。&lt;/p&gt;
&lt;h2 id=&quot;初始化bean的入口&quot;&gt;2. 初始化bean的入口&lt;/h2&gt;
&lt;p&gt;整个IOC容器的启动过程都包含在容器抽象类&lt;code&gt;AbstractApplicationContext&lt;/code&gt;的模板方法&lt;code&gt;refresh()&lt;/code&gt;中&lt;br/&gt;在这之前已经创建了核心容器BeanFactory,完成了bean定义信息的加载解析和注册,对于用户定义的每一个bean,创建一个对应的BeanDefinition,以beanName为key,Definition为value保存在核心容器beanFactory的map中。&lt;br/&gt;这个时候还没有真正创建Bean,而是创建了一个Bean的设计图——BeanDefinition,之后可以根据这个BeanDefinition创建真正的Bean实例。完成核心容器的创建后,还会注册一些容器的基础组件,之后才会来到启动容器最重要的阶段——初始化bean的阶段,这部分的入口在&lt;code&gt;finishBeanFactoryInitialization(beanFactory)&lt;/code&gt;方法中,如下箭头所示&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1422237/201812/1422237-20181223190909674-576203158.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;进入finishBeanFactoryInitialization(beanFactory)方法,在真正进行初始化动作前还会有一些准备工作,这部分内容因为不是特别重要,就在这顺便提及下&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1422237/201812/1422237-20181223190925116-1179305374.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面这部分逻辑中,容器提前初始化了两类特殊的bean,一类是ConversionService,可以进行属性值的转化,比如将前端传过来的特定格式的时间字符串转化为Date对象,功能和PropertyEditor类似;另一类则是实现了LoadTimeWeaverAware接口的Bean,这部分和Spring中的LTW(LoadTimeWeaving)相关,尽管也是AOP,但并不是Spring AOP中的默认实现。初始化时通过调用BeanFactory的getBean(..)方法实现的,这个方法其实才是初始化bean的真正入口,不过后面还会碰到,这里就跳过。进入箭头所指的方法,从方法名可以得知,下面这部分还是属于准备阶段的次要内容&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//获取所有BeanDefinition的beanName
List&amp;lt;String&amp;gt; beanNames = new ArrayList&amp;lt;&amp;gt;(this.beanDefinitionNames);

// Trigger initialization of all non-lazy singleton beans...
//遍历所有beanName
for (String beanName : beanNames) {
   RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);

   //如果bean不是抽象的且单例且非懒加载则通过if条件
   if (!bd.isAbstract() &amp;amp;&amp;amp; bd.isSingleton() &amp;amp;&amp;amp; !bd.isLazyInit()) {

      if (isFactoryBean(beanName)) {
         //如果是实现FactoryBean接口的bean
         Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);
         if (bean instanceof FactoryBean) {
            final FactoryBean&amp;lt;?&amp;gt; factory = (FactoryBean&amp;lt;?&amp;gt;) bean;
            boolean isEagerInit;
            if (System.getSecurityManager() != null &amp;amp;&amp;amp; factory instanceof SmartFactoryBean) {
               isEagerInit = AccessController.doPrivileged((PrivilegedAction&amp;lt;Boolean&amp;gt;)
                           ((SmartFactoryBean&amp;lt;?&amp;gt;) factory)::isEagerInit,
                     getAccessControlContext());
            }
            else {
               isEagerInit = (factory instanceof SmartFactoryBean &amp;amp;&amp;amp;
                     ((SmartFactoryBean&amp;lt;?&amp;gt;) factory).isEagerInit());
            }
            if (isEagerInit) {
               //初始化bean的真正入口
               getBean(beanName);
            }
         }
      }
      else {
         //不是FactoryBean则执行这里,这是初始化bean的真正入口
         getBean(beanName);
      }
   }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里会拿到之前注册的所有BeanDefinition,进行初始化的条件判断,如果Bean被设置为单例(scope=singleton)且非懒加载(lazy-init=false)则会开始真正的初始化流程,如果这其中任一条件不满足,则在容器启动的过程中是不会初始化这个bean的。之后的处理逻辑根据bean是否为FactoryBean类型而有所不同,但最后多会调用getBean()方法,这个方法其实才是初始化bean的真正的入口方法。&lt;/p&gt;
&lt;h2 id=&quot;尝试从当前容器及其父容器的缓存中获取bean&quot;&gt;3 尝试从当前容器及其父容器的缓存中获取bean&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;@Override
public Object getBean(String name) throws BeansException {
   return doGetBean(name, null, null, false);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这其实是一个相当通用的方法,它的真正含义其实是供客户端从容器中获取bean,若客户端想要的bean不存在,容器当然会创建并初始化它,但bean可能已经创建好并缓存在容器中,那么直接把缓存的对象返回给客户端就好,所以这个方法的前缀是get而不是create。不过我们是在IOC容器的启动流程中去分析这个方法,这个上下文环境下,所有bean都还未创建,所以这就相当于一个初始化方法。进入内部的doGetBean()方法,这个方法比较长,但是流程还是比较清晰的。&lt;/p&gt;
&lt;h3 id=&quot;获取真正的beanname&quot;&gt;3.1 获取真正的beanName&lt;/h3&gt;
&lt;p&gt;这是transformedBeanName(name)做的工作&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//对原始的beanName进行转化,获取真实的beanName,如果是FactoryBean则去除前缀'&amp;amp;',如果是别名则通过
//别名获取真实的名称
final String beanName = transformedBeanName(name);
Object bean;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;尝试从当前容器的缓存中获取bean&quot;&gt;3.2 尝试从当前容器的缓存中获取bean&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;// 从缓存中获取bean若缓存中不存在则从其ObjectFactory中获取,若ObjectFactory不存在则返回null
Object sharedInstance = getSingleton(beanName);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个getSingleton(beanName)比较值得讲,一是因为后面还会见到,二是它和spring解决bean循环依赖的方式有关,因而有必要理解其实现原理。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Nullable
protected Object getSingleton(String beanName, boolean allowEarlyReference) {

   //先尝试从singletonObjects这个缓存map中获取,这是个全局的缓存,里面存放着真正创建完成的bean
   //单例的bean只会被创建一次,之后便会缓存在这个map中供客户端重复获取
   Object singletonObject = this.singletonObjects.get(beanName);
   //如果缓存中不存在该name的bean且该bean正在创建过程中
   if (singletonObject == null &amp;amp;&amp;amp; isSingletonCurrentlyInCreation(beanName)) {
      //同步
      synchronized (this.singletonObjects) {
         //尝试从earlySingletonObjects这个缓存map中获取bean,这个map中的bean并未真正创建完成
         //但是提前暴露出来用来解决依赖问题

         singletonObject = this.earlySingletonObjects.get(beanName);
         if (singletonObject == null &amp;amp;&amp;amp; allowEarlyReference) {
            //若依旧未获取到则从singletonFactories这个map中获取其工厂
            ObjectFactory&amp;lt;?&amp;gt; singletonFactory = this.singletonFactories.get(beanName);
            if (singletonFactory != null) {
               //成功获取该bean的工厂实例
               //调用工厂方法获取bean
               singletonObject = singletonFactory.getObject();
               //将该bean加入earlySingletonObjects这个map中
               this.earlySingletonObjects.put(beanName, singletonObject);
               //将创建该bean的工厂从singletonFactories中移除
               this.singletonFactories.remove(beanName);
            }
         }
      }
   }
   return singletonObject;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从缓存中获取bean的流程并不复杂,但是因为涉及到3个Map,所以逻辑有点绕。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;全局缓存singletonObjects&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;/**
 * Cache of singleton objects: bean name to bean instance.
 */
private final Map&amp;lt;String, Object&amp;gt; singletonObjects = new ConcurrentHashMap&amp;lt;&amp;gt;(256);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个map用来缓存真正创建完成的bean,真正创建完成是指对象存在且所有属性/依赖已经注入且所有初始化操作已经完成。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;提前暴露bean的缓存earlySingletonObjects&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;/**
 * Cache of early singleton objects: bean name to bean instance.
 */
private final Map&amp;lt;String, Object&amp;gt; earlySingletonObjects = new HashMap&amp;lt;&amp;gt;(16);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个map中的bean并为真正创建完成,但是提前放在这个map中暴露出来,主要是为了解决循环依赖问题。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;bean工厂缓存singletonFactories&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;/**
 * Cache of singleton factories: bean name to ObjectFactory.
 */
private final Map&amp;lt;String, ObjectFactory&amp;lt;?&amp;gt;&amp;gt; singletonFactories = new HashMap&amp;lt;&amp;gt;(16);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个map中缓存的是用来获取bean的工厂ObjectFactopry,这个工厂中有一个刚创建完成但是未注入属性也未进行初始化的bean,当从工厂中取出这个bean后,该bean会缓存到earlySingletonObjects这个map中,并且对应的工厂会从singletonFactories移除。&lt;/p&gt;
&lt;p&gt;为什么要搞的这么复杂?这和Spring解决bean之间的循环依赖的思路有关:Spring在创建Bean A时如果发现A依赖于B会先去创建B,这个发现的时机其实是在为A注入属性时,此时bean A其实已经被创建,但是还未进行任何属性赋值和初始化操作,此时会将这个原始的bean A封装在一个ObjectFactory工厂中,保存在singletonFactories缓存,之后在创建B的过程中如果又需要创建A则会从缓存中获取A的工厂,调用其getObject()方法获取其实力,并将实例对象A放入earlySingletonObjects这个缓存中,之后将对应的ObjectFactory从singletonFactories中移除。&lt;br/&gt;因而&lt;code&gt;getSingleton()&lt;/code&gt;的逻辑就是根据beanName先从全局缓存中查找bean,没找到再从工厂缓存查找其工厂,找到就从工厂中取出,没找到上的话则返回null。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 从缓存中获取bean若缓存中不存在则从其ObjectFactory中获取,若ObjectFactory不存在则返回null
Object sharedInstance = getSingleton(beanName);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;从父容器中查找bean&quot;&gt;3.3 从父容器中查找bean&lt;/h3&gt;
&lt;p&gt;这里我们假设之前没有从当前容器的缓存中找到bean,这样比较符合初始化语境。这时候sharedInstance为null,接着会尝试从当前容器的父容器中去获取&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Check if bean definition exists in this factory.
//获取父容器,尝试从父容器中获取
BeanFactory parentBeanFactory = getParentBeanFactory();
if (parentBeanFactory != null &amp;amp;&amp;amp; !containsBeanDefinition(beanName)) {
   // Not found -&amp;gt; check parent.
   String nameToLookup = originalBeanName(name);
   if (parentBeanFactory instanceof AbstractBeanFactory) {
      //递归从父容器中获取想要的bean
      return ((AbstractBeanFactory) parentBeanFactory).doGetBean(
            nameToLookup, requiredType, args, typeCheckOnly);
   }
   else if (args != null) {
      // Delegation to parent with explicit args.
      return (T) parentBeanFactory.getBean(nameToLookup, args);
   }
   else if (requiredType != null) {
      // No args -&amp;gt; delegate to standard getBean method.
      return parentBeanFactory.getBean(nameToLookup, requiredType);
   }
   else {
      return (T) parentBeanFactory.getBean(nameToLookup);
   }
}

if (!typeCheckOnly) {
   markBeanAsCreated(beanName);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;逻辑可以简化为:获取当前容器的父容器并递归调用getBean()方法进行查找&lt;/p&gt;
&lt;h3 id=&quot;解析bean的依赖&quot;&gt;3.4 解析bean的依赖&lt;/h3&gt;
&lt;p&gt;这里有解析bean依赖的操作,原来我一直以为这里就是递归创建依赖bean的入口,但其实这里正如注释所言,只是为了保证当前bean的所有依赖bean已经初始化完毕,&lt;br/&gt;真正开始解析bean之间的依赖关系其实是在后面为bean注入属性时,当发现bean A依赖于bean B时,会暂停A的属性注入和初始化操作转而去创建B。所以这部分不是很重要,了解下即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Guarantee initialization of beans that the current bean depends on.
//保证该bean所有依赖的bean已经初始化完毕
String[] dependsOn = mbd.getDependsOn();
if (dependsOn != null) {
   for (String dep : dependsOn) {
      if (isDependent(beanName, dep)) {
         throw new BeanCreationException(mbd.getResourceDescription(), beanName,
               &quot;Circular depends-on relationship between '&quot; + beanName + &quot;' and '&quot; + dep + &quot;'&quot;);
      }
      //记录与当前bean有关的依赖关系
      registerDependentBean(dep, beanName);
      try {
         //先尝试获取该bean所依赖的bean
         getBean(dep);
      }
      catch (NoSuchBeanDefinitionException ex) {
         throw new BeanCreationException(mbd.getResourceDescription(), beanName,
               &quot;'&quot; + beanName + &quot;' depends on missing bean '&quot; + dep + &quot;'&quot;, ex);
      }
   }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;再一次尝试从缓存中获取&quot;&gt;3.5 再一次尝试从缓存中获取&lt;/h3&gt;
&lt;p&gt;这里再一次调用了getSingleton()方法,不过这次传递了一个实现ObjectFactory接口的匿名内部类(lambda语法简化),&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@FunctionalInterface
public interface ObjectFactory&amp;lt;T&amp;gt; {

   /**
    * Return an instance (possibly shared or independent)
    * of the object managed by this factory.
    * @return the resulting instance
    * @throws BeansException in case of creation errors
    */
   T getObject() throws BeansException;

}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;// Create bean instance.
if (mbd.isSingleton()) {
   //走到这里说明bean的定义是单实例的

   //尝试从全局缓存中获取bean,若没获取到则通过BeanDefinition信息创建bean,并清理相关缓存
   sharedInstance = getSingleton(beanName, () -&amp;gt; {
      try {
         return createBean(beanName, mbd, args);
      }
      catch (BeansException ex) {
         // Explicitly remove instance from singleton cache: It might have been put there
         // eagerly by the creation process, to allow for circular reference resolution.
         // Also remove any beans that received a temporary reference to the bean.
         destroySingleton(beanName);
         throw ex;
      }
   });
   //从FactoryBean中获取真正的bean实例
   bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1422237/201812/1422237-20181223191020272-2046545368.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先还是会尝试从全局缓存中获取bean,如果不存在才会调用工厂的getObject()方法去创建该bean,这个匿名内部类的getObject()方法又调用了createBean()方法,这个方法定义在&lt;code&gt;AbstractBeanFactory&lt;/code&gt;这个抽象工厂类中,不过具体实现在其子类&lt;code&gt;AbstractAutowireCapableBeanFactory&lt;/code&gt;,这个类中的createBean()才是真正创建Bean的方法&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1422237/201812/1422237-20181223191034844-479878963.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;真正创建bean的方法createbean&quot;&gt;4. 真正创建Bean的方法createBean()&lt;/h2&gt;
&lt;p&gt;兜兜转转终于来到了最重要的真正创建bean的方法,来到这个方法,说明从缓存中获取bean的尝试失败,转为真正创建并初始化它。&lt;/p&gt;
&lt;h3 id=&quot;实例化bean的前置处理&quot;&gt;4.1 实例化bean的前置处理&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;解析class&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;//根据设置的class属性或者根据className来解析Class
Class&amp;lt;?&amp;gt; resolvedClass = resolveBeanClass(mbd, beanName);
if (resolvedClass != null &amp;amp;&amp;amp; !mbd.hasBeanClass() &amp;amp;&amp;amp; mbd.getBeanClassName() != null) {
   mbdToUse = new RootBeanDefinition(mbd);
   mbdToUse.setBeanClass(resolvedClass);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;对override属性进行标记及验证&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;// Prepare method overrides.
try {

   //2.对override属性进行标记及验证
   mbdToUse.prepareMethodOverrides();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里和Spring的方法注入功能相关,Spring除了有构造器注入、属性注入和工厂方法注入外还有方法注入&lt;br/&gt;spring的bean配置中存在lookup-method和replace-method两个配置,这两个放在BeanDefinition的methodOverrides属性中&lt;br/&gt;如果bean实例化的时候检测到methodOverrides属性,会动态的为当前bean生成动态代理并使用相关拦截器对bean做增强,&lt;br/&gt;其底层通过CGLib在运行期动态操作Class字节码实现&lt;br/&gt;比如bean定义中的标签指定的方法,Spring会为其提供动态实现,通过这种方式实现依赖注入有个好处&lt;br/&gt;方便为单实例bean的多实例属性注入依赖且与Spring容器没有耦合;还有一种标签,可以使用某个bean&lt;br/&gt;的方法替换另一个bean的方法。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;实例化前的后置处理器回调&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里应该是初始化bean的流程中第一个允许用户进行回调的扩展点。&lt;br/&gt;在讲解这部分源码前先了解下一个特殊的后置处理器——InstantiationAwareBeanPostProcessor&lt;br/&gt;它扩展自BeanPostProcessor&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1422237/201812/1422237-20181223191116691-857637863.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;它内部定义了三个回调方法,其中比较重要的是下面这个&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Nullable
default Object postProcessBeforeInstantiation(Class&amp;lt;?&amp;gt; beanClass, String beanName) throws BeansException {
   return null;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在对象实例化前回调,可以通过回调该方法返回一个代理对象来替代默认的对象实例化过程&lt;/p&gt;
&lt;p&gt;好了可以开始讲这部分的源码了&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;try {
   // Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.
   //实例化bean之前的处理,会获取所有的InstantiationAwareBeanPostProcessor,执行其回调方法
   //这部分和Spring AOP相关
   Object bean = resolveBeforeInstantiation(beanName, mbdToUse);
   //短路控制,实例化bean之前的前置处理过程返回的bean如果不为空,则直接返回该bean
   if (bean != null) {
      return bean;
   }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * Apply before-instantiation post-processors, resolving whether there is a
 * before-instantiation shortcut for the specified bean.
 * @param beanName the name of the bean
 * @param mbd the bean definition for the bean
 * @return the shortcut-determined bean instance, or {@code null} if none
 */
@Nullable
protected Object resolveBeforeInstantiation(String beanName, RootBeanDefinition mbd) {
   Object bean = null;
   //尚未被解析
   if (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) {
      // Make sure bean class is actually resolved at this point.
      if (!mbd.isSynthetic() &amp;amp;&amp;amp; hasInstantiationAwareBeanPostProcessors()) {
         Class&amp;lt;?&amp;gt; targetType = determineTargetType(beanName, mbd);
         if (targetType != null) {
            // 执行实例化前置方法
            bean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName);
            if (bean != null) {
               //执行实例化后置方法
               bean = applyBeanPostProcessorsAfterInitialization(bean, beanName);
            }
         }
      }
      mbd.beforeInstantiationResolved = (bean != null);
   }
   return bean;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;@Nullable
protected Object applyBeanPostProcessorsBeforeInstantiation(Class&amp;lt;?&amp;gt; beanClass, String beanName) {
   for (BeanPostProcessor bp : getBeanPostProcessors()) {
      if (bp instanceof InstantiationAwareBeanPostProcessor) {
         InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
         Object result = ibp.postProcessBeforeInstantiation(beanClass, beanName);
         if (result != null) {
            return result;
         }
      }
   }
   return null;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;获取后处理器并回调的逻辑封装在resolveBeforeInstantiation()方法中,注意这里的返回值,如果返回值不为null,直接return,不走后面的实例化流程了。&lt;br/&gt;值得一提的是,通过Spring在这里提供的扩展点,确实有可能返回一个代理对象,那么Spring AOP生成的动态代理对象是这里生成的吗?很遗憾,通常情况并不是,除非你做了相关的自定义设置。&lt;br/&gt;当resolveBeforeInstantiation)()方法返回的结果为null,会执行后续的常规实例化操作。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;try {
   Object beanInstance = doCreateBean(beanName, mbdToUse, args);
   if (logger.isTraceEnabled()) {
      logger.trace(&quot;Finished creating instance of bean '&quot; + beanName + &quot;'&quot;);
   }
   return beanInstance;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;doCreateBean是实例化bean的核心方法&lt;/p&gt;
&lt;h3 id=&quot;选择合适的策略创建bean实例&quot;&gt;4.2 选择合适的策略创建bean实例&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;// Instantiate the bean.
BeanWrapper instanceWrapper = null;

if (mbd.isSingleton()) {
   instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);
}
if (instanceWrapper == null) {
   //实例化bean,这里根据BeanDefinition创建BeanWrapper
   instanceWrapper = createBeanInstance(beanName, mbd, args);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;createBeanInstance()里面是创建bean实例(准确来说是个bean的wrapper对象)的过程,这个过程设计两类策略的选择&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ol&gt;&lt;li&gt;选择合适的构造器&lt;br/&gt;这部分内容比较长,就不贴源码了,核心思想是：如果设置了factory-method属性,则使用工厂方法创建实例,否则根据参数的个数和类型选择构造器进行实例化,这里因为解析构造器比较花时间所以做了&lt;br/&gt;缓存处理,使得整个逻辑变得更加复杂。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;2.选择实例化策略实例化对象&lt;br/&gt;选择了合适的构造器后,容器会根据bean的定义中是否存在需要动态改变的方法(lookup-method,replace-method)选择不同的实例化策略:不存在则直接使用反射创建对象;存在则使用cglib生成子类的方式动态的&lt;br/&gt;进行方法替换。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;@Override
public Object instantiate(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner,
      final Constructor&amp;lt;?&amp;gt; ctor, Object... args) {

   //判断是否有需要动态改变(lookup-method动态重写,replace-method动态替换)的方法
   if (!bd.hasMethodOverrides()) {
      if (System.getSecurityManager() != null) {
         // use own privileged to change accessibility (when security is on)
         AccessController.doPrivileged((PrivilegedAction&amp;lt;Object&amp;gt;) () -&amp;gt; {
            ReflectionUtils.makeAccessible(ctor);
            return null;
         });
      }
      //不存在需要动态改变的方法,直接使用反射创建对象
      return BeanUtils.instantiateClass(ctor, args);
   }
   else {
      //存在需要动态改变的方法,使用cglib生成子类的方式动态替换原有方法
      return instantiateWithMethodInjection(bd, beanName, owner, ctor, args);
   }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;填充bean的属性解析依赖递归创建依赖的bean&quot;&gt;4.3 填充bean的属性,解析依赖,递归创建依赖的bean&lt;/h3&gt;
&lt;p&gt;之前只是创建了一个空的bean,为bean的属性进行赋值通过下面的方法完成&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;populateBean(beanName, mbd, instanceWrapper);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;整个过程可以分为4步:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1.获取所有的InstantiationAwareBeanPostProcessor,执行其postProcessAfterInstantiation方法,只要其中一个处理器返回false,将终止属性填充直接返回,这部分代码在下面&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;//调用InstantiationAwareBeanPostProcessor的实例化后置处理方法
if (!mbd.isSynthetic() &amp;amp;&amp;amp; hasInstantiationAwareBeanPostProcessors()) {
   for (BeanPostProcessor bp : getBeanPostProcessors()) {
      if (bp instanceof InstantiationAwareBeanPostProcessor) {
         InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
         if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) {
            //其中一个处理器的回调方法返回false,则跳出循环
            continueWithPropertyPopulation = false;
            break;
         }
      }
   }
}

if (!continueWithPropertyPopulation) {
   //不执行后续的属性填充操作,直接返回
   return;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;2.根据注入类型,递归初始化依赖的bean&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;//根据名称或者类型进行依赖注入
if (mbd.getResolvedAutowireMode() == AUTOWIRE_BY_NAME || mbd.getResolvedAutowireMode() == AUTOWIRE_BY_TYPE) {
   MutablePropertyValues newPvs = new MutablePropertyValues(pvs);
   // Add property values based on autowire by name if applicable.
   //按名称进行依赖注入
   if (mbd.getResolvedAutowireMode() == AUTOWIRE_BY_NAME) {
      autowireByName(beanName, mbd, bw, newPvs);
   }
   // Add property values based on autowire by type if applicable.
   //按类型进行依赖注入
   if (mbd.getResolvedAutowireMode() == AUTOWIRE_BY_TYPE) {
      autowireByType(beanName, mbd, bw, newPvs);
   }
   pvs = newPvs;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里尝试为bean注入依赖,可以按名称或者按类型进行注入。这里才是真正开始进行依赖解析并递归创建bean的地方,以autowireByName()为入口一探究竟&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1422237/201812/1422237-20181223191301078-339162028.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1处开始递归创建依赖的bean&lt;br/&gt;2处则是讲与当前bean有关的依赖关系进行注册,主要是填充两个map&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void registerDependentBean(String beanName, String dependentBeanName) {
   String canonicalName = canonicalName(beanName);

   //dependentBeanMap&amp;lt;String(beanName),Set&amp;lt;String&amp;gt;(依赖于前者的所有beanName集合)&amp;gt;
   synchronized (this.dependentBeanMap) {
      Set&amp;lt;String&amp;gt; dependentBeans =
            this.dependentBeanMap.computeIfAbsent(canonicalName, k -&amp;gt; new LinkedHashSet&amp;lt;&amp;gt;(8));
      if (!dependentBeans.add(dependentBeanName)) {
         //已经存在
         return;
      }
   }

   //dependenciesForBeanMap&amp;lt;String(beanName), Set&amp;lt;String&amp;gt;(被前者依赖的所有beanName集合)&amp;gt;
   synchronized (this.dependenciesForBeanMap) {
      Set&amp;lt;String&amp;gt; dependenciesForBean =
            this.dependenciesForBeanMap.computeIfAbsent(dependentBeanName, k -&amp;gt; new LinkedHashSet&amp;lt;&amp;gt;(8));
      dependenciesForBean.add(canonicalName);
   }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;dependentBeanMap:value为依赖于当前bean的所有bean的beanName集合&lt;br/&gt;dependenciesForBeanMap:value为当前bean所依赖的所有bean的beanName集合&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;3.将所有待填充的属性保存在PropertyValues中,进一步处理&lt;br/&gt;主要是获取所有的InstantiationAwareBeanPostProcessor并回调其postProcessPropertyValues方法&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;for (BeanPostProcessor bp : getBeanPostProcessors()) {
   if (bp instanceof InstantiationAwareBeanPostProcessor) {
      InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
      PropertyValues pvsToUse = ibp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);
      if (pvsToUse == null) {
         if (filteredPds == null) {
            filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);
         }
         pvsToUse = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);
         if (pvsToUse == null) {
            return;
         }
      }
      pvs = pvsToUse;
   }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;4.执行属性填充&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;if (pvs != null) {
   applyPropertyValues(beanName, mbd, bw, pvs);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这步执行完毕,bean的所有依赖就都已经注入,所有属性都已经填充完毕了&lt;/p&gt;
&lt;h3 id=&quot;初始化bean&quot;&gt;4.4 初始化bean&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;exposedObject = initializeBean(beanName, exposedObject, mbd);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1422237/201812/1422237-20181223191320385-1485837927.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1.如果bean实现了相关Aware接口:BeanNameAware,BeanClassLoaderAware,BeanFactoryAware,则回调其相应的set方法&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;private void invokeAwareMethods(final String beanName, final Object bean) {
   if (bean instanceof Aware) {
      if (bean instanceof BeanNameAware) {
         ((BeanNameAware) bean).setBeanName(beanName);
      }
      if (bean instanceof BeanClassLoaderAware) {
         ClassLoader bcl = getBeanClassLoader();
         if (bcl != null) {
            ((BeanClassLoaderAware) bean).setBeanClassLoader(bcl);
         }
      }
      if (bean instanceof BeanFactoryAware) {
         ((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.this);
      }
   }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;2.回调BeanPostProcessor的初始化前置方法&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1422237/201812/1422237-20181223191342472-2073592576.png&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;@Override
public Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName)
      throws BeansException {

   Object result = existingBean;
   for (BeanPostProcessor processor : getBeanPostProcessors()) {
      //回调其初始化前置方法
      Object current = processor.postProcessBeforeInitialization(result, beanName);
      if (current == null) {
         return result;
      }
      result = current;
   }
   return result;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;3.执行初始化方法&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里的初始化方法有两种,一种是用户在定义bean时配置的init-method,一种是InitialLizingBean接口的的afterProperties()方法&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1422237/201812/1422237-20181223191407241-1238810599.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;4.回调BeanPostProcessor的初始化后置方法&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;@Override
public Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName)
      throws BeansException {

   Object result = existingBean;
   for (BeanPostProcessor processor : getBeanPostProcessors()) {
      //回调初始化后置方法
      Object current = processor.postProcessAfterInitialization(result, beanName);
      if (current == null) {
         return result;
      }
      result = current;
   }
   return result;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到这里基本上IOC容器创建bean的流程就结束了,只有还有一些无关紧要的内容,就不贴源码了。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;5. 总结&lt;/h2&gt;
&lt;p&gt;本来还希望容器初始化单实例bean这部分内容能够讲的简单清晰,主次分明些,想不到还是写成了流水账,唯一值得欣慰的地方大概是终于把容器启动流程中最复杂也是最重要的阶段——初始化单实例bean的过程好好梳理了一遍,想继续探讨AOP源码的话也能找到切入点了。最后以下面这张图作为总结吧,基本理清了容器实例化bean的过程以及解决循环依赖的思路。&lt;/p&gt;
&lt;p&gt;假设要创建的bean A和B之间存在循环依赖,整个过程如下图所示&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1422237/201812/1422237-20181223191424641-933178314.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;6. 参考资料&lt;/h2&gt;
&lt;p&gt;《spring源码深度解析》&lt;/p&gt;
</description>
<pubDate>Sun, 23 Dec 2018 16:18:00 +0000</pubDate>
<dc:creator>takumiCX</dc:creator>
<og:description>[TOC] 1. 引言 之前开了一个解读IOC容器启动源码的坑</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/takumicx/p/10162811.html</dc:identifier>
</item>
<item>
<title>【swupdate文档 四】SWUpdate:使用默认解析器的语法和标记 - zqb-all</title>
<link>http://www.cnblogs.com/zqb-all/p/10166493.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zqb-all/p/10166493.html</guid>
<description>&lt;h2 id=&quot;介绍&quot;&gt;介绍&lt;/h2&gt;
&lt;p&gt;SWUpdate使用库“libconfig”作为镜像描述的默认解析器。&lt;br/&gt;但是，可以扩展SWUpdate并添加一个自己的解析器，&lt;br/&gt;以支持不同于libconfig的语法和语言。&lt;br/&gt;在examples目录中，有一个用Lua编写的，支持解析XML形式 描述文件的解析器。&lt;/p&gt;
&lt;p&gt;使用默认解析器，则sw-description遵循libconfig手册中描述的语法规则。&lt;br/&gt;请参阅http://www.hyperrealm.com/libconfig/libconfig_manual.html&lt;br/&gt;以了解基本类型。 整个描述必须包含在sw-description文件中:&lt;br/&gt;SWUpdate不允许使用#include指令。 下面的例子更好地解释了当前实现的标记:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;software =
{
    version = &quot;0.1.0&quot;;
    description = &quot;Firmware update for XXXXX Project&quot;;

    hardware-compatibility: [ &quot;1.0&quot;, &quot;1.2&quot;, &quot;1.3&quot;];

    /* partitions tag is used to resize UBI partitions */
    partitions: ( /* UBI Volumes */
        {
            name = &quot;rootfs&quot;;
            device = &quot;mtd4&quot;;
            size = 104896512; /* in bytes */
        },
        {
            name = &quot;data&quot;;
            device = &quot;mtd5&quot;;
            size = 50448384; /* in bytes */
        }
    );


    images: (
        {
            filename = &quot;rootfs.ubifs&quot;;
            volume = &quot;rootfs&quot;;
        },
        {
            filename = &quot;swupdate.ext3.gz.u-boot&quot;;
            volume = &quot;fs_recovery&quot;;
        },
        {
            filename = &quot;sdcard.ext3.gz&quot;;
            device = &quot;/dev/mmcblk0p1&quot;;
            compressed = true;
        },
        {
            filename = &quot;bootlogo.bmp&quot;;
            volume = &quot;splash&quot;;
        },
        {
            filename = &quot;uImage.bin&quot;;
            volume = &quot;kernel&quot;;
        },
        {
            filename = &quot;fpga.txt&quot;;
            type = &quot;fpga&quot;;
        }
    );

    files: (
        {
            filename = &quot;README&quot;;
            path = &quot;/README&quot;;
            device = &quot;/dev/mmcblk0p1&quot;;
            filesystem = &quot;vfat&quot;
        }
    );

    scripts: (
        {
            filename = &quot;erase_at_end&quot;;
            type = &quot;lua&quot;;
        },
        {
            filename = &quot;display_info&quot;;
            type = &quot;lua&quot;;
        }
    );

    bootenv: (
        {
            filename = &quot;bootloader-env&quot;;
            type = &quot;bootloader&quot;;
        },
        {
            name = &quot;vram&quot;;
            value = &quot;4M&quot;;
        },
        {
            name = &quot;addfb&quot;;
            value = &quot;setenv bootargs ${bootargs} omapfb.vram=1:2M,2:2M,3:2M omapdss.def_disp=lcd&quot;
        }
    );
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第一个标签是“软件”。整个描述包含在这个标签中。 可以使用 特定的板级设置_&lt;br/&gt;_对每个设备的设置进行分组。&lt;/p&gt;
&lt;h2 id=&quot;处理配置的差异&quot;&gt;处理配置的差异&lt;/h2&gt;
&lt;p&gt;这个概念可以扩展到交付单个映像，在其中包含用于多个不同设备的发布。&lt;br/&gt;每个设备都有自己的内核、dtb和根文件系统，或者它们可以共享某些部分。&lt;/p&gt;
&lt;p&gt;目前，这是通过编写自己的解析器来管理的(并且已经在实际项目中使用)，&lt;br/&gt;解析器在识别出软件当前运行在什么设备上之后，检查必须安装哪些镜像。&lt;br/&gt;因为外部解析器可以用Lua编写，而且它是完全可定制的，&lt;br/&gt;所以每个人都可以设置自己的规则。&lt;br/&gt;对于这个特定的例子，sw-description是用XML格式编写的，&lt;br/&gt;带有标识来标记每个设备对应的镜像。要运行它需要liblxp库。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;software version=&quot;1.0&quot;&amp;gt;
  &amp;lt;name&amp;gt;Update Image&amp;lt;/name&amp;gt;
  &amp;lt;version&amp;gt;1.0.0&amp;lt;/version&amp;gt;
  &amp;lt;description&amp;gt;Firmware for XXXXX Project&amp;lt;/description&amp;gt;

  &amp;lt;images&amp;gt;
    &amp;lt;image device=&quot;firstdevice&quot; version=&quot;0.9&quot;&amp;gt;
      &amp;lt;stream name=&quot;dev1-uImage&quot; type=&quot;ubivol&quot; volume=&quot;kernel&quot; /&amp;gt;
      &amp;lt;stream name=&quot;dev1.dtb&quot; type=&quot;ubivol&quot; volume=&quot;dtb&quot; /&amp;gt;
      &amp;lt;stream name=&quot;dev1-rootfs.ubifs&quot; type=&quot;ubivol&quot; volume=&quot;rootfs&quot;/&amp;gt;
      &amp;lt;stream name=&quot;dev1-uboot-env&quot; type=&quot;uboot&quot; /&amp;gt;
      &amp;lt;stream name=&quot;raw_vfat&quot; type=&quot;raw&quot; dest=&quot;/dev/mmcblk0p4&quot; /&amp;gt;
      &amp;lt;stream name=&quot;sdcard.lua&quot; type=&quot;lua&quot; /&amp;gt;
    &amp;lt;/image&amp;gt;

    &amp;lt;image device=&quot;seconddevice&quot; version=&quot;0.9&quot;&amp;gt;
      &amp;lt;stream name=&quot;dev2-uImage&quot; type=&quot;ubivol&quot; volume=&quot;kernel&quot; /&amp;gt;
      &amp;lt;stream name=&quot;dev2.dtb&quot; rev=&quot;0.9&quot; type=&quot;ubivol&quot; volume=&quot;dtb&quot; /&amp;gt;
      &amp;lt;stream name=&quot;dev2-rootfs.ubifs&quot; type=&quot;ubivol&quot; volume=&quot;rootfs&quot;/&amp;gt;
    &amp;lt;/image&amp;gt;
  &amp;lt;/images&amp;gt;
&amp;lt;/software&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;支持本例子的解析器位于/examples目录中。&lt;br/&gt;通过识别哪个是正在运行的设备，解析器返回一个表，&lt;br/&gt;其中包含必须安装的镜像及其关联的处理程序。&lt;/p&gt;
&lt;p&gt;读取交付的镜像时，SWUpdate将忽略解析器处理列表之外的所有镜像。&lt;br/&gt;通过这种方式，可以使用单个交付镜像来更新多个设备。&lt;/p&gt;
&lt;p&gt;默认解析器也支持多个设备。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;software =
{
    version = &quot;0.1.0&quot;;

    target-1 = {
            images: (
                    {
                            ...
                    }
            );
    };

    target-2 = {
            images: (
                    {
                            ...
                    }
            );
    };
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过这种方式，可以使用单个镜像为你的所有设备提供软件。&lt;/p&gt;
&lt;p&gt;默认情况下，硬件信息是从 /etc/hwrevision 文件中提取的。&lt;br/&gt;文件应包含单行信息，格式如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;boardname&amp;gt; &amp;lt;revision&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Where:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&amp;lt;revision&amp;gt; 将用于与硬件兼容列表匹配&lt;/li&gt;
&lt;li&gt;&amp;lt;boardname&amp;gt; 可用于对板子的具体设置进行分组&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;软件集合&quot;&gt;软件集合&lt;/h2&gt;
&lt;p&gt;软件集合和操作模式可用于实现双拷贝策略。&lt;br/&gt;最简单的情况是为固件映像定义两个安装位置， 并在调用 SWUpdate&lt;br/&gt;时选择适当的镜像。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;software =
{
        version = &quot;0.1.0&quot;;

        stable = {
                copy-1: {
                        images: (
                        {
                                device = &quot;/dev/mtd4&quot;
                                ...
                        }
                        );
                }
                copy-2: {
                        images: (
                        {
                                device = &quot;/dev/mtd5&quot;
                                ...
                        }
                        );
                }
        };
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过这种方式，可以指定 copy-1 安装到 /dev/mtd4 ， 而 copy-2 安装到&lt;br/&gt;/dev/mtd5 。 通过正确选择安装位置， SWUpdate 将更新另一个插槽中的固件。&lt;/p&gt;
&lt;p&gt;具体镜像的选择方法超出了SWUpdate的范围内， 用户要负责调用 SWUpdate&lt;br/&gt;并传入适当的设置。&lt;/p&gt;
&lt;h2 id=&quot;查找文件元素的优先级&quot;&gt;查找文件元素的优先级&lt;/h2&gt;
&lt;p&gt;SWUpdate根据以下优先级搜索sdw-description文件中的条目:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;尝试 &amp;lt;boardname&amp;gt;.&amp;lt;selection&amp;gt;.&amp;lt;mode&amp;gt;.&amp;lt;entry&amp;gt;&lt;/li&gt;
&lt;li&gt;尝试 &amp;lt;selection&amp;gt;.&amp;lt;mode&amp;gt;.&amp;lt;entry&amp;gt;&lt;/li&gt;
&lt;li&gt;尝试 &amp;lt;boardname&amp;gt;.&amp;lt;entry&amp;gt;&lt;/li&gt;
&lt;li&gt;尝试 &amp;lt;entry&amp;gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;举一个例子。下面的sw-description描述了一组板子的发布。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;software =
{
        version = &quot;0.1.0&quot;;

        myboard = {
            stable = {
                copy-1: {
                        images: (
                        {
                                device = &quot;/dev/mtd4&quot;
                                ...
                        }
                        );
                }
                copy-2: {
                        images: (
                        {
                                device = &quot;/dev/mtd5&quot;
                                ...
                        }
                        );
                }
            }
        }

        stable = {
            copy-1: {
                  images: (
                      {
                           device = &quot;/dev/mtd6&quot;
                                ...
                      }
                   );
            }
            copy-2: {
                   images: (
                   {
                           device = &quot;/dev/mtd7&quot;
                                ...
                   }
                   );
            }
        }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 &lt;em&gt;myboard&lt;/em&gt; 上运行时，SWUpdate会搜索并找到myboard.stable.copy1(2)。&lt;br/&gt;当在其他板子上运行时，SWUpdate则无法找到一个与板子名字对应的条目，&lt;br/&gt;那它就会退回到没有指定板子名字的版本。&lt;br/&gt;这样就可以使用一个发布版本，适配拥有完全不同硬件的不同板子。 例如,&lt;br/&gt;myboard 可以是eMMC和ext4文件系统，而另一个设备可以是raw flash并安装&lt;br/&gt;UBI文件系统。然而，它们都是同一版本的不同格式，可以在sw-description中一起描述。&lt;br/&gt;重要的是，要理解SWUpdate在解析期间如何按优先级扫描条目。&lt;/p&gt;
&lt;h2 id=&quot;使用链接&quot;&gt;使用链接&lt;/h2&gt;
&lt;p&gt;sw-description可能变得非常复杂。&lt;br/&gt;让我们假设只有一个板子，但是存在多个硬件版本，它们在硬件上是不同的。&lt;br/&gt;这些版本中有些可以统一处理，有些则需要特殊的部分。&lt;br/&gt;一种方法(但不是唯一的方法!)是添加 &lt;em&gt;mode&lt;/em&gt; 并使用 -e stable,&amp;lt;rev number&amp;gt;&lt;br/&gt;做选择。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;software =
{
    version = &quot;0.1.0&quot;;

    myboard = {
            stable = {

        hardware-compatibility: [&quot;1.0&quot;, &quot;1.2&quot;, &quot;2.0&quot;, &quot;1.§, &quot;3.0&quot;, &quot;3.1&quot;];
        rev-1.0: {
            images: (
                ...
            );
            scripts: (
                ...
            );
        }
        rev-1.2: {
            hardware-compatibility: [&quot;1.2&quot;];
            images: (
                ...
            );
            scripts: (
                ...
            );
        }
        rev-2.0: {
            hardware-compatibility: [&quot;2.0&quot;];
            images: (
                ...
            );
            scripts: (
                               ...
            );
        }
        rev-1.3: {
            hardware-compatibility: [&quot;1.3&quot;];
            images: (
                                ...
            );
            scripts: (
                                ...
            );
        }

        rev-3.0:
        {
            hardware-compatibility: [&quot;3.0&quot;];
            images: (
                ...
            );
            scripts: (
                ...
            );
                }
        rev-3.1:
        {
            hardware-compatibility: [&quot;3.1&quot;];
            images: (
                ...
            );
            scripts: (
                ...
            );
        }
         }
        }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果它们每个都需要一个单独的部分，那么这是一种方法。&lt;br/&gt;尽管如此，更可能的情况时，不同的修订版本可以被当成一类，&lt;br/&gt;例如，具有相同主要修订号的板子可能具有相同的安装说明。&lt;br/&gt;在这个例子中，则可导出三个分组，rev1.X, rev2.X 和 rev3.X。&lt;br/&gt;链接允许将部分分组在一起。当SWUpdate搜索组&lt;br/&gt;(images、files、scripts、bootenv)时，如果发现“ref”，&lt;br/&gt;它将用字符串的值替换树中的当前路径。这样，上面的例子可以这样写:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;software =
{
            version = &quot;0.1.0&quot;;

            myboard = {
            stable = {

                    hardware-compatibility: [&quot;1.0&quot;, &quot;1.2&quot;, &quot;2.0&quot;, &quot;1.3, &quot;3.0&quot;, &quot;3.1&quot;];
                    rev-1x: {
                            images: (
                               ...
                            );
                            scripts: (
                                ...
                            );
                    }
                    rev1.0 = {
                            ref = &quot;#./rev-1x&quot;;
                    }
                    rev1.2 = {
                            ref = &quot;#./rev-1x&quot;;
                    }
                    rev1.3 = {
                            ref = &quot;#./rev-1x&quot;;
                    }
                    rev-2x: {
                            images: (
                                 ...
                            );
                            scripts: (
                                 ...
                            );
                    }
                    rev2.0 = {
                            ref = &quot;#./rev-2x&quot;;
                    }

                    rev-3x: {
                            images: (
                                 ...
                            );
                            scripts: (
                                  ...
                            );
                }
                    rev3.0 = {
                            ref = &quot;#./rev-3x&quot;;
                    }
                    rev3.1 = {
                            ref = &quot;#./rev-3x&quot;;
                    }
         }
        }
   }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种链接可以是绝对的，也可以是相对的。关键字 &lt;em&gt;ref&lt;/em&gt; 用于指示一个链接。&lt;br/&gt;如果找到链接，SWUpdate将遍历树，并将当前路径替换为 &quot;ref&quot;&lt;br/&gt;指向的字符串中的值。 用于链接的规则很简单：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;必须以字符 '#' 开头&lt;/li&gt;
&lt;li&gt;&quot;.&quot; 指向树中的当前层级，即 &quot;ref&quot; 的父级&lt;/li&gt;
&lt;li&gt;&quot;..&quot; 指向树中的父级&lt;/li&gt;
&lt;li&gt;&quot;/&quot; 在链接中用作字段分隔符&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;一个相对路径有许多前导 &quot;../&quot; 以从当前位置移动到树的高层级节点&lt;br/&gt;在下面的例子中，rev40设置了一个链接到 &quot;common&quot;, 在那可以找到 &quot;images&quot;。&lt;br/&gt;这也是通过链接到父节点中的一个部分来设置的。 路径&lt;br/&gt;software.myboard.stable.common.images 被替换为&lt;br/&gt;software.myboard.stable.trythis&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;software =
{
  version = {
      ref = &quot;#./commonversion&quot;;
  }

  hardware-compatibility = [&quot;rev10&quot;, &quot;rev11&quot;, &quot;rev20&quot;];

  commonversion = &quot;0.7-linked&quot;;

pc:{
  stable:{

    common:{
    images =
    {
      ref = &quot;#./../trythis&quot;;
    }
      };

    trythis:(
    {
    filename = &quot;rootfs1.ext4&quot;;
    device = &quot;/dev/mmcblk0p8&quot;;
    type = &quot;raw&quot;;
    } ,
    {
    filename = &quot;rootfs5.ext4&quot;;
    device = &quot;/dev/mmcblk0p7&quot;;
    type = &quot;raw&quot;;
    }
      );
    pdm3rev10:
      {
      images:(
      {
      filename = &quot;rootfs.ext3&quot;; device = &quot;/dev/mmcblk0p2&quot;;}
    );
      uboot:(
      { name = &quot;bootpart&quot;;
      value = &quot;0:2&quot;;}
    );
      };
      pdm3rev11 =
      {
    ref = &quot;#./pdm3rev10&quot;;
      }
      pdm3rev20 =
      {
    ref = &quot;#./pdm3rev10&quot;;
      }
      pdm3rev40 =
      {
    ref = &quot;#./common&quot;;
      }
    };
  };
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以通过链接重定向sw-description中的每个条目，就像上面示例中的 &quot;version&quot;&lt;br/&gt;属性那样。&lt;/p&gt;
&lt;h2 id=&quot;硬件兼容性&quot;&gt;硬件兼容性&lt;/h2&gt;
&lt;p&gt;硬件兼容性: [ &quot;major.minor&quot;, &quot;major.minor&quot;, ... ]&lt;/p&gt;
&lt;p&gt;它列出了与此软件镜像兼容的硬件修订版本。&lt;/p&gt;
&lt;p&gt;例子:&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;hardware-compatibility: [ &quot;1.0&quot;, &quot;1.2&quot;, &quot;1.3&quot;];&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这意味着该软件可以兼容硬件修订版本1.0, 1.2 和 1.3,但不能兼容1.1&lt;br/&gt;和其他未在此明确列出的版本。&lt;br/&gt;如何找到正在运行SWUpdate的板子的修订版本，是另一件事情了。&lt;br/&gt;这里并没有假设如何获得修订版本（可以通过GPIOs,EEPROM等),&lt;br/&gt;每个项目都可以自由选择最合适的方式。&lt;br/&gt;在启动SWUpdate之前，结果必须写入文件/etc/hwrevision(如果配置中&lt;br/&gt;指定了另一个文件，则必须写入对应的文件)。&lt;/p&gt;
&lt;h2 id=&quot;partitions-ubi-布局&quot;&gt;partitions : UBI 布局&lt;/h2&gt;
&lt;p&gt;此标记允许更改UBI卷的布局。&lt;br/&gt;请注意，此处不涉及MTDs，它们是由设备树配置的，&lt;br/&gt;或者直接在内核中以另一种方式配置的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;partitions: (
    {
        name = &amp;lt;volume name&amp;gt;;
        size = &amp;lt;size in bytes&amp;gt;;
        device = &amp;lt;MTD device&amp;gt;;
    },
);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所有字段都是强制的。SWUpdate搜索所选名称的卷并调整大小，&lt;br/&gt;如果不存在具有给定名称的卷，则创建新卷。&lt;br/&gt;在后一种情况下，它是在连接到&quot;device&quot;所指定MTD设备的UBI设备上创建的。&lt;br/&gt;&quot;device&quot;可以以数字(如 &quot;mtd4&quot;)或名字(及MTD设备的名字，如&lt;br/&gt;&quot;ubi_partition&quot;) 的方式给出。UBI设备的连接是自动进行的。&lt;/p&gt;
&lt;h2 id=&quot;images&quot;&gt;images&lt;/h2&gt;
&lt;p&gt;标签 &quot;images&quot; 收集安装到系统中的映像。 语法是:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;images: (
    {
        filename[mandatory] = &amp;lt;Name in CPIO Archive&amp;gt;;
        volume[optional] = &amp;lt;destination volume&amp;gt;;
        device[optional] = &amp;lt;destination volume&amp;gt;;
        mtdname[optional] = &amp;lt;destination mtd name&amp;gt;;
        type[optional] = &amp;lt;handler&amp;gt;;
        /* optionally, the image can be copied at a specific offset */
        offset[optional] = &amp;lt;offset&amp;gt;;
        /* optionally, the image can be compressed if it is in raw mode */
        compressed;
    },
    /* Next Image */
    .....
);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;volume&lt;/em&gt; 仅用于将镜像安装到UBI卷中。 &lt;em&gt;volume&lt;/em&gt; 和 &lt;em&gt;device&lt;/em&gt; 不能同时使用。&lt;br/&gt;如果设置了device,则会自动选中裸数据处理程序(raw handler)。&lt;/p&gt;
&lt;p&gt;以下时一个更新UBI卷的例子:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
    filename = &quot;core-image-base.ubifs&quot;;
    volume = &quot;rootfs&quot;;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;要以裸数据形式更新体格镜像，语法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
    filename = &quot;core-image-base.ext3&quot;;
    device = &quot;/dev/mmcblk0p1&quot;;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;要将镜像写入到一个指定偏移处，语法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
    filename = &quot;u-boot.bin&quot;;
    device = &quot;/dev/mmcblk0p1&quot;;
    offset = &quot;16K&quot;;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;偏移量可处理以下乘法后缀:K=1024和M=1024*1024。&lt;/p&gt;
&lt;p&gt;但是，在裸数据模式下写flash必须以一种特殊的方式进行管理。&lt;br/&gt;Flash在写入之前必须先擦除，并且写入NAND时必须处理坏块和ECC错误。&lt;br/&gt;因此，必须选择处理程序&quot;flash&quot;:&lt;/p&gt;
&lt;p&gt;例如，要将内核复制到NAND闪存的MTD7中:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
    filename = &quot;uImage&quot;;
    device = &quot;mtd7&quot;;
    type = &quot;flash&quot;;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;filename&lt;/em&gt; 是必须的。它是由流提取的文件的名称。 &lt;em&gt;volume&lt;/em&gt;&lt;br/&gt;仅在UBI卷中是强制性的。它不应该在其他情况下使用。&lt;/p&gt;
&lt;p&gt;另外，对于处理程序 &quot;flash&quot;，可以指定 &lt;em&gt;mtdname&lt;/em&gt; 来代替设备名称:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
    filename = &quot;uImage&quot;;
    mtdname = &quot;kernel&quot;;
    type = &quot;flash&quot;;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;files&quot;&gt;Files&lt;/h2&gt;
&lt;p&gt;可以复制单个文件而不是完整镜像。&lt;br/&gt;这不是首选的方法，但是可以用于调试或特殊目的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;files: (
    {
        filename = &amp;lt;Name in CPIO Archive&amp;gt;;
        path = &amp;lt;path in filesystem&amp;gt;;
        device[optional] = &amp;lt;device node &amp;gt;;
        filesystem[optional] = &amp;lt;filesystem for mount&amp;gt;;
        properties[optional] = {create-destination = &quot;true&quot;;}
    }
);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&quot;files&quot; 部分中的条目会作为单个文件进行管理。 &quot;filename&quot; 和 &quot;path&quot;&lt;br/&gt;属性是必须的。 属性 &quot;device&quot; 和 &quot;filesystem&quot; 是可选的;&lt;br/&gt;它们用于告诉SWUpdate，在将&quot;filename&quot;拷贝到&quot;path&quot;之前&lt;br/&gt;先挂载设备(以给定的文件系统类型进行挂载，如 &quot;ext4&quot;)。&lt;br/&gt;如果没有指定&quot;device&quot;和&quot;filesystem&quot;，&lt;br/&gt;则&quot;filename&quot;会被拷贝到当前根文件系统的&quot;path&quot;。&lt;/p&gt;
&lt;p&gt;一般来说，如果目标路径不存在，swupdate不会复制文件。&lt;br/&gt;可以使用特殊属性&quot;create-destination&quot;更改此行为。&lt;/p&gt;
&lt;h2 id=&quot;scripts&quot;&gt;Scripts&lt;/h2&gt;
&lt;p&gt;脚本按照它们被放入sw-description文件的顺序运行。&lt;br/&gt;脚本的结果由SWUpdate进行评估，如果结果是&amp;lt;&amp;gt; 0，则停止更新并报错。&lt;/p&gt;
&lt;p&gt;它们在执行之前会被复制到一个临时目录中，&lt;br/&gt;并且它们的名字在同一个cpio归档中必须是惟一的。&lt;/p&gt;
&lt;p&gt;如果没有给出类型，SWUpdate默认为 &quot;lua&quot;。&lt;/p&gt;
&lt;h3 id=&quot;lua&quot;&gt;Lua&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;scripts: (
    {
        filename = &amp;lt;Name in CPIO Archive&amp;gt;;
        type = &quot;lua&quot;;
    },
);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Lua脚本使用内部解释器运行。&lt;/p&gt;
&lt;p&gt;它们必须具有下列函数中的至少一个:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function preinst()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;SWUpdate扫描所有脚本并检查preinst函数。在安装镜像之前调用它。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function postinst()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;SWUpdate扫描所有脚本并检查postinst函数。它是在安装镜像之后调用的。&lt;/p&gt;
&lt;h3 id=&quot;shellscript&quot;&gt;shellscript&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;scripts: (
    {
        filename = &amp;lt;Name in CPIO Archive&amp;gt;;
        type = &quot;shellscript&quot;;
    },
);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Shell脚本通过system命令调用。&lt;br/&gt;SWUpdate扫描所有脚本，并在安装镜像之前和之后调用它们。&lt;br/&gt;SWUpdate将'preinst'或'postinst'作为脚本的第一个参数传递。&lt;br/&gt;如果定义了data属性，它的值将作为最后一个参数传递给脚本。&lt;/p&gt;
&lt;h3 id=&quot;preinstall&quot;&gt;preinstall&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;scripts: (
    {
        filename = &amp;lt;Name in CPIO Archive&amp;gt;;
        type = &quot;preinstall&quot;;
    },
);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;preinstall 是通过system命令调用的shell脚本。&lt;br/&gt;SWUpdate扫描所有脚本并在安装映像之前调用它们。&lt;br/&gt;如果定义了data属性，它的值将作为最后一个参数传递给脚本。&lt;/p&gt;
&lt;h3 id=&quot;postinstall&quot;&gt;postinstall&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;scripts: (
    {
        filename = &amp;lt;Name in CPIO Archive&amp;gt;;
        type = &quot;postinstall&quot;;
    },
);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;postinstall 是通过system命令调用的shell脚本。&lt;br/&gt;SWUpdate扫描所有脚本，并在安装镜像后调用它们。&lt;br/&gt;如果定义了data属性，它的值将作为最后一个参数传递给脚本。&lt;/p&gt;
&lt;h2 id=&quot;bootloader&quot;&gt;bootloader&lt;/h2&gt;
&lt;p&gt;有两种方法可以更新引导加载程序(当前支持U-Boot、GRUB和EFI Boot Guard)&lt;br/&gt;的环境变量。 第一种方法是添加一个包含要更改的变量列表的文件，&lt;br/&gt;并将“bootloader”设置为镜像的类型。&lt;br/&gt;这将通知SWUpdate调用引导加载程序处理程序来处理文件&lt;br/&gt;(需要在配置中启用引导加载程序处理程序)。&lt;br/&gt;对于所有受支持的引导加载程序，都有一个引导加载程序处理程序。 必须从&lt;br/&gt;menuconfig 的引导加载程序选择菜单中选择适当的引导加载程序。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;bootenv: (
    {
        filename = &quot;bootloader-env&quot;;
        type = &quot;bootloader&quot;;
    },
)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;文件的格式在U-boot文档中有描述。每一行都是如下格式&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;name of variable&amp;gt;  &amp;lt;value&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果值缺失，则变量将被去掉。 在当前实现中，GRUB和EFI Boot Guard&lt;br/&gt;的环境变量修改也继承了上述文件格式。&lt;/p&gt;
&lt;p&gt;第二种方法是在组设置中定义需要更改的变量:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;bootenv: (
    {
        name = &amp;lt;Variable name&amp;gt;;
        value = &amp;lt;Variable value&amp;gt;;
    },
)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;SWUpdate将在内部生成一个脚本，该脚本将传递给&lt;br/&gt;引导加载程序处理程序，用于调整环境变量。&lt;/p&gt;
&lt;p&gt;为了向后兼容以前构建的 .swu 镜像，&quot;uboot&quot; 组名仍然作为别名支持。&lt;br/&gt;但是，它实际上已经被弃用了，不建议继续使用它。&lt;/p&gt;
&lt;h2 id=&quot;特定的板级设置&quot;&gt;特定的板级设置&lt;/h2&gt;
&lt;p&gt;每个设置都可以放在与板名匹配的自定义标记下。&lt;br/&gt;此机制可用于以板卡特有的方式覆盖特定设置。&lt;/p&gt;
&lt;p&gt;假设硬件信息文件 /etc/hwrevision 包含以下条目:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;my-board 0.1.0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以及以下描述:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;software =
{
        version = &quot;0.1.0&quot;;

        my-board = {
                bootenv: (
                {
                        name = &quot;bootpart&quot;;
                        value = &quot;0:2&quot;;
                }
                );
        };

        bootenv: (
        {
                name = &quot;bootpart&quot;;
                value = &quot;0:1&quot;;
        }
        );
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;SWUpdate将在这个板子的引导加载程序环境中将 bootpart 设置为 0:2 。&lt;br/&gt;对于所有其他板子， bootpart 将被设置为 0:1 。&lt;br/&gt;特定于板子的设置优先于默认作用域的设置。&lt;/p&gt;
&lt;h2 id=&quot;软件集合和操作模式&quot;&gt;软件集合和操作模式&lt;/h2&gt;
&lt;p&gt;软件集合和操作模式扩展了描述文件语法，&lt;br/&gt;以提供对之前介绍的所有配置标记的叠加分组。 这种机制类似于&lt;br/&gt;特定的板级设置_ ,可用于实现双拷贝策略，&lt;br/&gt;或者用单个更新文件内同时交付稳定和不稳定版本的镜像。&lt;/p&gt;
&lt;p&gt;该机制使用放置在 software 标签范围内的自定义用户定义标签。&lt;br/&gt;标签不能使用以下名字: version, hardware-compatibility, uboot, bootenv,&lt;br/&gt;files, scripts, partitions, images&lt;/p&gt;
&lt;p&gt;示例描述文件:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;software =
{
        version = &quot;0.1&quot;;

        hardware-compatibility = [ &quot;revA&quot; ];

        /* differentiate running image modes/sets */
        stable:
        {
                main:
                {
                        images: (
                        {
                                filename = &quot;rootfs.ext3&quot;;
                                device = &quot;/dev/mmcblk0p2&quot;;
                        }
                        );

                        bootenv: (
                        {
                                name = &quot;bootpart&quot;;
                                value = &quot;0:2&quot;;
                        }
                        );
                };
                alt:
                {
                        images: (
                        {
                                filename = &quot;rootfs.ext3&quot;;
                                device = &quot;/dev/mmcblk0p1&quot;;
                        }
                        );

                        bootenv: (
                        {
                                name = &quot;bootpart&quot;;
                                value = &quot;0:1&quot;;
                        }
                        );
                };

        };
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个配置描述了一个名为 stable 的软件集合。&lt;br/&gt;并为这个集合指定了两个不同的镜像安装位置: /dev/mmcblk0p1 和&lt;br/&gt;/dev/mmcblk0p2 分别用于 main 模式和 alt 模式。&lt;/p&gt;
&lt;p&gt;该特性可以通过显式指定集合和模式来实现双拷贝策略。&lt;/p&gt;
&lt;h2 id=&quot;检查已安装软件的版本&quot;&gt;检查已安装软件的版本&lt;/h2&gt;
&lt;p&gt;SWUpdate支持可选地验证子镜像是否已经被安装了，&lt;br/&gt;如果要安装的版本完全相同，则可以跳过它的安装。&lt;br/&gt;这在安装某些高风险镜像或需要加速升级过程的情况下是非常有用的。&lt;/p&gt;
&lt;p&gt;一种情况是需要更新引导加载程序。在大多数情况下，&lt;br/&gt;不需要升级引导加载程序，但是实践表明，在某些情况下， 确实有必要升级 -&lt;br/&gt;项目经理应该承担这个风险。&lt;br/&gt;经过如此，始终将引导加载程序镜像作为.swu文件的一部分是更好的，&lt;br/&gt;这样可以在单个文件中获得设备的整个发行版，但是设备应该仅在必要时安装它。&lt;/p&gt;
&lt;p&gt;SWUpdate搜索包含已安装映像的所有版本信息的文件(默认位置是/etc/sw-versions)。&lt;br/&gt;这个文件必须在运行SWUpdate之前生成。&lt;/p&gt;
&lt;p&gt;文件必须包含成对的信息，即镜像名称和版本:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;name of component&amp;gt; &amp;lt;version&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;版本是一个字符串，可以有任何值。例如:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;bootloader              2015.01-rc3-00456-gd4978d
kernel                  3.17.0-00215-g2e876af&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在sw-description中，可选属性 &quot;name&quot;、&quot;version&quot;&lt;br/&gt;和&quot;install-if-different&quot;提供了连接。&lt;br/&gt;name和version将用于与版本文件中的数据进行比较。&lt;br/&gt;install-if-different则是一个布尔值，用于对此镜像启用版本检查。&lt;br/&gt;这样就可以只对要安装的镜像们的一个子集进行版本检查。&lt;/p&gt;
&lt;h2 id=&quot;嵌入脚本&quot;&gt;嵌入脚本&lt;/h2&gt;
&lt;p&gt;可以将脚本嵌入到sw-description中。这在许多情况下非常有用，&lt;br/&gt;因为一些参数只有在目标上实际运行时知道。&lt;br/&gt;脚本是全局的，面向所有部分，但是它可以包含几个函数，&lt;br/&gt;这些函数可以针对sw-description文件中的每个条目。&lt;/p&gt;
&lt;p&gt;这些属性用于嵌入脚本:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;embedded-script = &quot;&amp;lt;Lua code&quot;&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;必须考虑到解析器已经在运行，双引号的使用可能会干扰解析器。&lt;br/&gt;因此，脚本中的每个双引号都必须转义。&lt;/p&gt;
&lt;p&gt;这意味着像这样的一个简单的Lua代码:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;print (&quot;Test&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改改成这样:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;print (\&quot;Test\&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不然解析器会认为脚本已经关闭，并产生一个错误。&lt;br/&gt;有关如何使用它的示例，请参见示例目录。&lt;br/&gt;文件或镜像中的任何条目都可以触发脚本中的一个函数。 &quot;hook&quot;&lt;br/&gt;属性告诉解析器加载脚本并搜索钩子属性指向的函数。例如:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;files: (
    {
        filename = &quot;examples.tar&quot;;
        type = &quot;archive&quot;;
        path = &quot;/tmp/test&quot;;
        hook = &quot;set_version&quot;;
        preserve-attributes = true;
    }
);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在解析条目之后，解析器运行hook所指向的Lua函数。&lt;br/&gt;如果Lua未被激活，解析器将引发一个错误，&lt;br/&gt;因为必须解析带有嵌入脚本的sw-description，但解释器不可用。&lt;br/&gt;每个Lua函数接收一个带有当前条目设置的表作为参数。 Lua钩子的格式是:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function lua_hook(image)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数image是一个表，其关键字是有效属性的列表。&lt;br/&gt;如果一个属性包含了&quot;-&quot;，则会被替换为&quot;_&quot;，因为Lua中不能使用 &quot;-&quot;。&lt;br/&gt;这意味着，如下例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;install-if-different ==&amp;gt; install_if_different
install-directly     ==&amp;gt; install_directly&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以在Lua脚本中更改属性，并在返回时接管值。 Lua函数必须返回2个值:&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;一个布尔值，指示解析是否正确&lt;/li&gt;
&lt;li&gt;镜像表或nil以表示应该跳过该镜像&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;例子:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function set_version(image)
    print (\&quot;RECOVERY_STATUS.RUN: \&quot;.. swupdate.RECOVERY_STATUS.RUN)
        for k,l in pairs(image) do
                swupdate.trace(\&quot;image[\&quot; .. tostring(k) .. \&quot;] = \&quot; .. tostring(l))
        end
    image.version = \&quot;1.0\&quot;
    image.install_if_different = true
    return true, image
end&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该示例为已安装镜像设置了一个版本。&lt;br/&gt;通常，这是在运行时从目标读取数据检测到的。&lt;/p&gt;
&lt;h2 id=&quot;属性参考&quot;&gt;属性参考&lt;/h2&gt;
&lt;p&gt;在sw-description中有4个主要部分:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;images: 条目是镜像，SWUpdate对它们一无所知。&lt;/li&gt;
&lt;li&gt;files: 条目是文件，SWUpdate需要一个用于它们的文件系统。&lt;br/&gt;这通常用于从tar-ball展开或更新单个文件。&lt;/li&gt;
&lt;li&gt;scripts:&lt;br/&gt;所有条目都被视为可执行文件，它们将被运行两次(作为安装前和安装后脚本)。&lt;/li&gt;
&lt;li&gt;bootenv:条目是引导加载程序环境变量名及其值的键值对。&lt;/li&gt;
&lt;/ul&gt;&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;33.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;filename&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;images files scripts&lt;/td&gt;
&lt;td&gt;在cpio存档中找到的文件名。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;volume&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;images&lt;/td&gt;
&lt;td&gt;仅在 type = “ubivol”时使用。 指明镜像将安装到哪个UBI卷。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;ubipartition&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;images&lt;/td&gt;
&lt;td&gt;仅在 type = “ubivol”时使用。 要创建或调整大小的UBI卷。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;7&quot;&gt;&lt;td&gt;device&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;images files&lt;/td&gt;
&lt;td&gt;在/dev下可找到的设备节点，或者是到它的 符号链接。 可以指定为绝对路径，或/dev 下的名字。例如，如果/dev/mtd-dev是一个 指向/dev/mtd3的链接，则 “mtd3”, “mtd-dtb”,”/dev/mtd3”和”/dev/mtd-dtb” 均是有效的名字。 用法取决于具体处理程序。 对于文件，用于指明哪个设备用于挂载 “filesystem”，如果未指定，则使用当前的 根文件系统。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;filesystem&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;files&lt;/td&gt;
&lt;td&gt;指示文件安装位置的文件系统类型。 仅在设置了”device”属性时使用。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;path&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;files&lt;/td&gt;
&lt;td&gt;用于文件:指示用于安装文件的路径 (绝对路径)。如果设置了”device” 和 “filesystem”, Swupdate将在以指定文件 系统类型挂载设备后再安装文件。 (路径总是相对于挂载点而言的)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;8&quot;&gt;&lt;td&gt;preserve-attributes&lt;/td&gt;
&lt;td&gt;bool&lt;/td&gt;
&lt;td&gt;files&lt;/td&gt;
&lt;td&gt;标记，用于控制从归档文件解压文件时 是否保留下列属性 (当然，前提是目标文件系统支持它们): timestamp, uid/gid (numeric), perms, file attributes, extended attributes&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;type&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;images files scripts&lt;/td&gt;
&lt;td&gt;处理程序的字符串标识符， 它是由处理程序在注册自身时设置的。 例如: “ubivol”, “raw”, “rawfile”&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;compressed&lt;/td&gt;
&lt;td&gt;bool&lt;/td&gt;
&lt;td&gt;images files&lt;/td&gt;
&lt;td&gt;标记，用于指示”filename”是zlib压缩的， 在安装之前必须先解压&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;installed-directly&lt;/td&gt;
&lt;td&gt;bool&lt;/td&gt;
&lt;td&gt;images&lt;/td&gt;
&lt;td&gt;标志，用于指示镜像需流式更新到目标中, 不需要任何临时副本。 并非所有处理程序都支持流式更新。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;name&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;bootenv&lt;/td&gt;
&lt;td&gt;要设置的引导程序环境变量的名字。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;value&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;bootenv&lt;/td&gt;
&lt;td&gt;要赋给引导加载程序环境变量的值。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;name&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;images files&lt;/td&gt;
&lt;td&gt;标识sw-component的名称，它可以是任何 字符串，将与sw-versions中的条目做比较&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;version&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;images files&lt;/td&gt;
&lt;td&gt;sw-component的版本，可以是任何字符串， 将与sw-version中的条目做比较&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;description&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;swupdate归档文件的用户友好的描述 (可使用任意字符串)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;install-if-different&lt;/td&gt;
&lt;td&gt;bool&lt;/td&gt;
&lt;td&gt;images files&lt;/td&gt;
&lt;td&gt;标志 如果设置了，名字和版本会于版本文件中 的条目做比较。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;encrypted&lt;/td&gt;
&lt;td&gt;bool&lt;/td&gt;
&lt;td&gt;images files scripts&lt;/td&gt;
&lt;td&gt;标志 如果设置了, 文件会被加密并必须先解密后 安装。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;data&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;images files scripts&lt;/td&gt;
&lt;td&gt;用于将任意数据传递给处理程序。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;sha256&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;images files scripts&lt;/td&gt;
&lt;td&gt;镜像、文件或脚本的sha256哈希值。 用于签名镜像的校验。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;embedded-script&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;嵌入sw-description文件中的Lua代码。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;offset&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;images&lt;/td&gt;
&lt;td&gt;可选的目的位置的偏移量。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;hook&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;images files&lt;/td&gt;
&lt;td&gt;解析条目时要调用的函数(Lua)的名称。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;mtdname&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;images&lt;/td&gt;
&lt;td&gt;要更新的MTD的名称。仅被flash处理程序 用来代替具体的设备节点名，以识别要 更新的MTD。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;本文地址 &lt;a href=&quot;https://www.cnblogs.com/zqb-all/p/10166493.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/zqb-all/p/10166493.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译自 swupdate 文档 &lt;a href=&quot;https://sbabic.github.io/swupdate/sw-description.html&quot; class=&quot;uri&quot;&gt;https://sbabic.github.io/swupdate/sw-description.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;有更新会在github上发布 &lt;a href=&quot;https://zqb-all.github.io/swupdate/sw-description.html&quot; class=&quot;uri&quot;&gt;https://zqb-all.github.io/swupdate/sw-description.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 23 Dec 2018 15:50:00 +0000</pubDate>
<dc:creator>zqb-all</dc:creator>
<og:description>SWUpdate:使用默认解析器的语法和标记 =================================== 介绍 SWUpdate使用库“libconfig”作为镜像描述的默认解析器。 但是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zqb-all/p/10166493.html</dc:identifier>
</item>
<item>
<title>[SCOI2012] 喵星球上的点名 - YoungNeal</title>
<link>http://www.cnblogs.com/YoungNeal/p/10166505.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/YoungNeal/p/10166505.html</guid>
<description>&lt;h3 id=&quot;description&quot;&gt;Description&lt;/h3&gt;
&lt;p&gt;给定 &lt;span class=&quot;math inline&quot;&gt;\(N\)&lt;/span&gt; 个姓名串和 &lt;span class=&quot;math inline&quot;&gt;\(M\)&lt;/span&gt; 个点名串。询问每个点名串点到了多少姓名和每个姓名串被点到了几次。&lt;span class=&quot;math inline&quot;&gt;\(N\leq 5\cdot 10^4,M\leq 10^5\)&lt;/span&gt;。&lt;/p&gt;
&lt;h3 id=&quot;sol&quot;&gt;Sol&lt;/h3&gt;
&lt;p&gt;卡了我一周90分的题原来是数组开小我就艹了我就&lt;/p&gt;
&lt;p&gt;最开始以为是 &lt;span class=&quot;math inline&quot;&gt;\(AC\)&lt;/span&gt; 自动机裸题但是细想了一下发现并不会，还是老老实实想 &lt;span class=&quot;math inline&quot;&gt;\(SA\)&lt;/span&gt; 。&lt;/p&gt;
&lt;p&gt;首先要把这些串连在一起，然后跑一遍 &lt;span class=&quot;math inline&quot;&gt;\(SA\)&lt;/span&gt; ，可以先求出每个点名串到底点到了多少姓名串（也就是说在 &lt;span class=&quot;math inline&quot;&gt;\(SA\)&lt;/span&gt; 上有多少位置和点名串的 &lt;span class=&quot;math inline&quot;&gt;\(LCP\)&lt;/span&gt; 是点名串自己），发现这个在 &lt;span class=&quot;math inline&quot;&gt;\(SA\)&lt;/span&gt; 上是一段区间，可以二分左右端点求出。时间复杂度 &lt;span class=&quot;math inline&quot;&gt;\(O(n\log n)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;然后这两问分别考虑，第一问就相当于区间数颜色，可以离线+树状数组解决。就是按照区间右端点排序，如果当前的值 &lt;span class=&quot;math inline&quot;&gt;\(a[i]=x\)&lt;/span&gt;，那就在 &lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt; 处 &lt;span class=&quot;math inline&quot;&gt;\(+1\)&lt;/span&gt;，在 &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt; 上一次出现的位置 &lt;span class=&quot;math inline&quot;&gt;\(las[x]\)&lt;/span&gt; 处 &lt;span class=&quot;math inline&quot;&gt;\(-1\)&lt;/span&gt;。然后统计区间 &lt;span class=&quot;math inline&quot;&gt;\([L,R]\)&lt;/span&gt; 直接树状数组上查就好了。这个算法的核心思路是保证相同数字的贡献只有 &lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt;，也就是说每个颜色只会在前缀和数组中出现 &lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt; 次。这部分时间复杂度 &lt;span class=&quot;math inline&quot;&gt;\(O(n\log n)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;第二问就是求每个颜色被几个不同的区间覆盖了。这个同样离线，对于一个区间 &lt;span class=&quot;math inline&quot;&gt;\([L,R]\)&lt;/span&gt;，我们在扫到 &lt;span class=&quot;math inline&quot;&gt;\(L\)&lt;/span&gt; 位置的时候在 &lt;span class=&quot;math inline&quot;&gt;\(L\)&lt;/span&gt; 处 &lt;span class=&quot;math inline&quot;&gt;\(+1\)&lt;/span&gt;，扫到 &lt;span class=&quot;math inline&quot;&gt;\(R+1\)&lt;/span&gt; 的时候撤销 &lt;span class=&quot;math inline&quot;&gt;\(L\)&lt;/span&gt; 的 &lt;span class=&quot;math inline&quot;&gt;\(+1\)&lt;/span&gt; 操作。做到 &lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt; 位置的时候，设 &lt;span class=&quot;math inline&quot;&gt;\(a[i]=x\)&lt;/span&gt;，记录 &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt; 上一次出现的位置 &lt;span class=&quot;math inline&quot;&gt;\(las[x]\)&lt;/span&gt;，那 &lt;span class=&quot;math inline&quot;&gt;\(ans[x]\)&lt;/span&gt; 就要加上 &lt;span class=&quot;math inline&quot;&gt;\((las[x],i]\)&lt;/span&gt; 的和。正确性就是如果一个区间覆盖了某个数，肯定会在左端点之后第一个出现这个数的位置统计上答案。这里的时间复杂度也是 &lt;span class=&quot;math inline&quot;&gt;\(O(n\log n)\)&lt;/span&gt;。&lt;/p&gt;
&lt;h3 id=&quot;code&quot;&gt;Code&lt;/h3&gt;
&lt;p&gt;这道题写的是真的丑...&lt;/p&gt;
&lt;p&gt;把压行的都改掉了发现还是丑...&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using std::min;
using std::max;
using std::swap;
using std::vector;
typedef double db;
typedef long long ll;
#define pb(A) push_back(A)
#define pii std::pair&amp;lt;int,int&amp;gt;
#define all(A) A.begin(),A.end()
#define mp(A,B) std::make_pair(A,B)
const int N=1e6+5;
const int M=1e4+5;
// wtf?????
// 把m开大就过了？？？？？？？
// 卡了老子一周的狗题？？？？
int ans[N],ans2[N],st[N][20],fs[N],len[N];
int s[N],tot,sa[N],rk[N],height[N],lg[N],f[N];
int n,m,num,x[N],y[N],c[N],belong[N][2],las[N];//belong=2 refers to question

struct Ques{
    int l,r,idx;
    friend bool operator&amp;lt;(Ques a,Ques b){
        return a.r&amp;lt;b.r;
    }
}ques[N];

struct qu{
    int type,x;
    qu(){}
    qu(int a,int b){type=a,x=b;}
};

std::vector&amp;lt;qu&amp;gt; v[N];

void add(int *f,int x,int y){
    while(x&amp;lt;=tot) 
        f[x]+=y,x+=x&amp;amp;-x;
}

int query(int *f,int x){
    int now=0;
    while(x) now+=f[x],x-=x&amp;amp;-x;
    return now;
}

void getsa(int m=100001){
    for(int i=1;i&amp;lt;=tot;i++) c[x[i]=s[i]]++;
    for(int i=1;i&amp;lt;=m;i++) c[i]+=c[i-1];
    for(int i=tot;i;i--) sa[c[x[i]]--]=i;
    for(int k=1;num=0,k&amp;lt;=tot;k&amp;lt;&amp;lt;=1){
        for(int i=tot-k+1;i&amp;lt;=tot;i++) y[++num]=i;
        for(int i=1;i&amp;lt;=tot;i++) if(sa[i]&amp;gt;k) y[++num]=sa[i]-k;
        for(int i=0;i&amp;lt;=m;i++) c[i]=0;
        for(int i=1;i&amp;lt;=tot;i++) c[x[i]]++;
        for(int i=1;i&amp;lt;=m;i++) c[i]+=c[i-1];
        for(int i=tot;i;i--) sa[c[x[y[i]]]--]=y[i];
        swap(x,y),x[sa[1]]=num=1;
        for(int i=2;i&amp;lt;=tot;i++) x[sa[i]]=y[sa[i]]==y[sa[i-1]] and y[sa[i]+k]==y[sa[i-1]+k]?num:++num;
        if(num==tot) return;m=num;
    } 
}

void getheight(int k=0){
    for(int i=1;i&amp;lt;=tot;i++) 
        rk[sa[i]]=i;
    for(int i=1;i&amp;lt;=tot;i++){
        if(rk[i]==1) continue;
        if(k) k--;
        int j=sa[rk[i]-1];
        while(i+k&amp;lt;=tot and j+k&amp;lt;=tot and s[i+k]==s[j+k]) k++;
        height[rk[i]]=k;
    }
}

void getst(){
    for(int i=2;i&amp;lt;=tot;i++) 
        lg[i]=lg[i-1]+((1&amp;lt;&amp;lt;lg[i-1]+1)==i);
    for(int i=1;i&amp;lt;=tot;i++) 
        st[i][0]=height[i];
    for(int k=1;k&amp;lt;=lg[tot];k++)
        for(int i=1;i+(1&amp;lt;&amp;lt;k)-1&amp;lt;=tot;i++)
            st[i][k]=min(st[i][k-1],st[i+(1&amp;lt;&amp;lt;k-1)][k-1]);
}

int getint(){
    int X=0,w=0;char ch=getchar();
    while(!isdigit(ch))w|=ch=='-',ch=getchar();
    while( isdigit(ch))X=X*10+ch-48,ch=getchar();
    if(w) return -X;return X;
}

int query(int x,int y){
    if(x==y) return tot-sa[x]+1;
    if(x&amp;gt;y) swap(x,y);x++;
    int k=lg[y-x+1];
    return min(st[x][k],st[y-(1&amp;lt;&amp;lt;k)+1][k]);
}

signed main(){
    n=getint(),m=getint();int cnt=10001;
    for(int i=1;i&amp;lt;=n;i++){
        if(i!=1) 
            s[++tot]=++cnt;
        int lenn=getint();
        for(int j=1;j&amp;lt;=lenn;j++) 
            s[++tot]=getint()+1,belong[tot][0]=1,belong[tot][1]=i;
        s[++tot]=++cnt;
        lenn=getint();
        for(int j=1;j&amp;lt;=lenn;j++) 
            s[++tot]=getint()+1,belong[tot][0]=1,belong[tot][1]=i;
    }
    for(int i=1;i&amp;lt;=m;i++){
        s[++tot]=++cnt;
        len[i]=getint();fs[i]=tot+1;
        for(int j=1;j&amp;lt;=len[i];j++) 
            s[++tot]=getint()+1,belong[tot][0]=2,belong[tot][1]=i;
    } 
    getsa(),getheight(),getst();
    for(int i=1;i&amp;lt;=m;i++){
        //rk[fs[i]]
        int l=1,r=rk[fs[i]],now=0;
        while(l&amp;lt;=r){
            int mid=l+r&amp;gt;&amp;gt;1;
            if(query(mid,rk[fs[i]])&amp;gt;=len[i]) now=mid,r=mid-1;
            else l=mid+1;
        } 
        ques[i].l=now;l=rk[fs[i]],r=tot,now=0;
        while(l&amp;lt;=r){
            int mid=l+r&amp;gt;&amp;gt;1;
            if(query(rk[fs[i]],mid)&amp;gt;=len[i]) now=mid,l=mid+1;
            else r=mid-1;
        } 
        ques[i].r=now;ques[i].idx=i;
    } 
    std::sort(ques+1,ques+1+m);int ptr=1;
    for(int i=1;i&amp;lt;=tot;i++){
        if(belong[sa[i]][0]==1 and las[belong[sa[i]][1]]) 
            add(f,las[belong[sa[i]][1]],-1);
        if(belong[sa[i]][0]==1) 
            add(f,i,1),las[belong[sa[i]][1]]=i;
        while(ptr&amp;lt;=m and ques[ptr].r==i){
            ans[ques[ptr].idx]=query(f,ques[ptr].r)-query(f,ques[ptr].l-1);
            ptr++;
        }
    } 
    for(int i=1;i&amp;lt;=m;i++) 
        printf(&quot;%d\n&quot;,ans[i]);
    memset(f,0,sizeof f);memset(las,0,sizeof las);
    for(int i=1;i&amp;lt;=m;i++) 
        v[ques[i].l].pb(qu(1,ques[i].l)),v[ques[i].r].pb(qu(-1,ques[i].l));
    for(int i=1;i&amp;lt;=tot;i++){
        for(auto x:v[i])
            if(x.type==1)
                add(f,x.x,x.type);
        if(belong[sa[i]][0]==1) 
            ans2[belong[sa[i]][1]]+=query(f,i)-query(f,las[belong[sa[i]][1]]);
        if(belong[sa[i]][0]==1) 
            las[belong[sa[i]][1]]=i;
        for(auto x:v[i])
            if(x.type==-1)
                add(f,x.x,x.type);
    } for(int i=1;i&amp;lt;=n;i++) 
        printf(&quot;%d%c&quot;,ans2[i],i==n?'\n':' ');
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sun, 23 Dec 2018 15:46:00 +0000</pubDate>
<dc:creator>YoungNeal</dc:creator>
<og:description>SA+离线树状数组。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/YoungNeal/p/10166505.html</dc:identifier>
</item>
<item>
<title>通过编写一个简单的日志类库来加深了解C#的文件访问控制 - 如兹</title>
<link>http://www.cnblogs.com/ruzi/p/10166506.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ruzi/p/10166506.html</guid>
<description>&lt;p&gt;在程序的开发调试过程及发布运行后的状态监控中，日志都有着极其重要的分量，通过在关键逻辑节点将关键数据记录到日志文件当中能帮助我们尽快找到程序问题所在。网上有不少专业成熟的日志组件可用，比如log4net和nlog等，由其专业及受欢迎程度可见日志在一个程序中的重要性。&lt;/p&gt;
&lt;p&gt;我只用过log4net，而在用log4net写日志的过程中慢慢觉着太繁琐了点，不就写个日志吗？为毛搞得那么复杂？各种配置让我有点抓狂。&lt;/p&gt;
&lt;p&gt;于是我就想，自己来吧！&lt;/p&gt;
&lt;p&gt;首先分析一下一个基本的日志类库应该具有的基本功能及实现的时候需要注意和解决的问题：&lt;/p&gt;
&lt;h2&gt;1.关于日志文件的写入&lt;/h2&gt;
&lt;p&gt;写日志并不是简单的打开一个文件然后写入数据然后关闭了事，无论是web程序还是桌面程序，首要问题是多线程争抢写入一个日志文件的访问控制，次要问题是要允许其它进程在写入进程未释放日志文件时日志文件能被读取——试想如果日志在写的时候不能被读取那日志将毫无价值。&lt;/p&gt;
&lt;p&gt;为了解决多线程写入的问题，多线程写入的数据将被缓存在一个StringBuilder对象中，而后由一个专门的写文件线程来负责取出数据写入到日志文件，以此来保证只有一个线程对日志文件进行写操作，如果再解决在文件流未关闭的情况下让其它进程或线程能读取日志内容，那问题就都不是问题了，而在文件流未关闭的情况下要让其它进程或线程能读取日志内容只需要在打开或创建日志文件的FileStream时指定System.IO.FileShare参数为Read即可。&lt;/p&gt;
&lt;h2&gt;2.关于日志文件的读取&lt;/h2&gt;
&lt;p&gt;文件写入成功后会有读取进行查看及分析的需求。内容较少的时候直接记事本打开即可，但是日志较大的时候就费劲了，虽然也有一些专门的软件能打开大文本文件，可打开日志文件有时并不是只为了看上一眼而已，很可能需要提取一些受关注的数据做个统计分析，比如提取某个操作的耗时来做瓶颈参考，因此有必要实现对大文本文件的读取，在读取过程中进行数据的留存分析。&lt;/p&gt;
&lt;p&gt;对大文本文件的读取当然要按块来读取，比如一次读取10M字节，这样即便是几个G的文件也没几次可读的，重要的是不能截断单词和宽字符，所以每读取到指定字节数(如10M字节)的数据后需要根据指定的参考字符(如换行符、空格、逗号、句号等)做偏移计算。&lt;/p&gt;
&lt;p&gt;对文件的读取在创建文件的读取流的时候必须要指定System.IO.FileShare参数为ReadWrite，否则对正在被写入或未被释放的文件的访问将被拒绝，因为写入的进程已经获得了写入权限，作为后来的读取者一定要允许其它进程可以对文件读写，要不然冲突就是一定的了。&lt;/p&gt;
&lt;h2&gt;3.关于日志的清理&lt;/h2&gt;
&lt;p&gt;随着程序常年运行，日志积累得越来越多，而日志应该都有一定的时效性，过了时效期后的日志就没有什么价值了，所以应该对日志做定时的清理操作，因此写日志的时候应该有一个默认的时效值，使日志在到期之后自动删除，以免无限增多浪费了磁盘空间，毕竟磁盘空间是十分有限的。&lt;/p&gt;

&lt;p&gt;下面开始上代码：&lt;/p&gt;
&lt;p&gt;新建一个 .Net Standard 类库，命名 Logger ，在类库中添加一个 Core 文件夹，在 Core 文件夹添加以下文件：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;ILog.cs 接口&lt;/li&gt;
&lt;li&gt;Log.cs 密封的接口实现类(不对程序集外提供访问)&lt;/li&gt;
&lt;li&gt;TextFileReader.cs 文本文件读取&lt;/li&gt;
&lt;li&gt;Factory.cs 工厂类(生产和维护日志对象)&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_c11808d6-00cc-46f6-9caa-65adac2bc710&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_c11808d6-00cc-46f6-9caa-65adac2bc710&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c11808d6-00cc-46f6-9caa-65adac2bc710&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Logger.Core
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; ILog
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;void&lt;/span&gt; Write(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; logInfo);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;void&lt;/span&gt; WriteFormat(&lt;span&gt;string&lt;/span&gt; format, &lt;span&gt;params&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt;[] args);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;void&lt;/span&gt;&lt;span&gt; SaveLogToFile();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ClearLogFile();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;ILog.cs&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46.5&quot;&gt;&lt;img id=&quot;code_img_closed_efbd9fb6-accd-4ba9-9da3-524f0595477b&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_efbd9fb6-accd-4ba9-9da3-524f0595477b&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_efbd9fb6-accd-4ba9-9da3-524f0595477b&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;88&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Logger.Core
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt;     &lt;span&gt;internal&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Log : ILog
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; System.Text.StringBuilder logSource = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; logFilePre = &lt;span&gt;string&lt;/span&gt;&lt;span&gt;.Empty;
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; System.IO.FileStream fileStream = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; DateTime logFileScanLastTime =&lt;span&gt; DateTime.Now;
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; logFileRetentionDays = &lt;span&gt;90&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt; 
&lt;span&gt; 11&lt;/span&gt; 
&lt;span&gt; 12&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; Log(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; logFilePre)
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt;             : &lt;span&gt;this&lt;/span&gt;(logFilePre, &lt;span&gt;90&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt; 
&lt;span&gt; 16&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; Log(&lt;span&gt;string&lt;/span&gt; logFilePre, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; logFileRetentionDays)
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.logFilePre =&lt;span&gt; logFilePre;
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.logSource = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; System.Text.StringBuilder();
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (logFileRetentionDays &amp;lt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt;                 logFileRetentionDays = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.logFileRetentionDays =&lt;span&gt; logFileRetentionDays;
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt; &lt;span&gt;            Factory.SetFileThreadStart();
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt; 
&lt;span&gt; 29&lt;/span&gt; 
&lt;span&gt; 30&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt;&lt;span&gt; System.IO.FileStream GetFileStream()
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;System.IO.Directory.Exists(Factory.logsDirPath))
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt; &lt;span&gt;                System.IO.Directory.CreateDirectory(Factory.logsDirPath);
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt; &lt;span&gt;            System.IO.FileStream fs;
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt;             &lt;span&gt;string&lt;/span&gt; FilePath = System.IO.Path.Combine(Factory.logsDirPath, &lt;span&gt;this&lt;/span&gt;.logFilePre + DateTime.Now.ToString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yyyyMMdd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.log&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;System.IO.File.Exists(FilePath))
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (fileStream != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt; &lt;span&gt;                    fileStream.Close();
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt;                 fileStream = fs = &lt;span&gt;new&lt;/span&gt; System.IO.FileStream(FilePath, System.IO.FileMode.CreateNew, System.IO.FileAccess.Write, System.IO.FileShare.Read, &lt;span&gt;1024&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;
&lt;span&gt; 47&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (fileStream != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt;                     fs =&lt;span&gt; fileStream;
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt;
&lt;span&gt; 53&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt;                     fileStream = fs = &lt;span&gt;new&lt;/span&gt; System.IO.FileStream(FilePath, System.IO.FileMode.Open, System.IO.FileAccess.Write, System.IO.FileShare.Read, &lt;span&gt;1024&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; fs;
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; GetLogText()
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt;             &lt;span&gt;string&lt;/span&gt; s = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (logSource.Length &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt;                 &lt;span&gt;lock&lt;/span&gt;&lt;span&gt; (logSource)
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt;                     s =&lt;span&gt; logSource.ToString();
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt; &lt;span&gt;                    logSource.Clear();
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; s;
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt; 
&lt;span&gt; 73&lt;/span&gt; 
&lt;span&gt; 74&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Write(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; logInfo)
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;
&lt;span&gt; 77&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (logSource == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt;                     logSource = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; System.Text.StringBuilder();
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt;                 &lt;span&gt;lock&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt;                     logSource.AppendFormat(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{0} {1}{2}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, DateTime.Now.ToString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yyyy-MM-dd HH:mm:ss,fff&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;), logInfo, System.Environment.NewLine);
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt;             &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; { }
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; WriteFormat(&lt;span&gt;string&lt;/span&gt; format, &lt;span&gt;params&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt;[] args)
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;
&lt;span&gt; 92&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (logSource == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt;                     logSource = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; System.Text.StringBuilder();
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt;                 &lt;span&gt;lock&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;                     logSource.AppendFormat(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{0} &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, DateTime.Now.ToString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yyyy-MM-dd HH:mm:ss,fff&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; &lt;span&gt;                    logSource.AppendFormat(format, args);
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt; &lt;span&gt;                    logSource.Append(System.Environment.NewLine);
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt;             &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; { }
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; SaveLogToFile()
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;
&lt;span&gt;109&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt;                 &lt;span&gt;string&lt;/span&gt; logInfo =&lt;span&gt; GetLogText();
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (logInfo.Length &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt;                     System.IO.FileStream fs =&lt;span&gt; GetFileStream();
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt;                     &lt;span&gt;byte&lt;/span&gt;[] buffer =&lt;span&gt; System.Text.UTF8Encoding.UTF8.GetBytes(logInfo);
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt;                     &lt;span&gt;long&lt;/span&gt; lockBegin =&lt;span&gt; fs.Length;
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt;                     &lt;span&gt;long&lt;/span&gt; lockEnd =&lt;span&gt; buffer.Length;
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt;                     fs.Position =&lt;span&gt; lockBegin;
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt; &lt;span&gt;                    fs.Lock(lockBegin, lockEnd);
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;fs.WriteAsync(buffer, 0, buffer.Length);&lt;/span&gt;
&lt;span&gt;120&lt;/span&gt;                     fs.Write(buffer, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, buffer.Length);
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt; &lt;span&gt;                    fs.Unlock(lockBegin, lockEnd);
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt; &lt;span&gt;                    fs.Flush();
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;fs.Close();&lt;/span&gt;
&lt;span&gt;124&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;126&lt;/span&gt;             &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; { }
&lt;/span&gt;&lt;span&gt;127&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;128&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ClearLogFile()
&lt;/span&gt;&lt;span&gt;129&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; ((DateTime.Now - logFileScanLastTime).TotalMinutes &amp;lt; &lt;span&gt;5&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;131&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;132&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;134&lt;/span&gt;             logFileScanLastTime =&lt;span&gt; DateTime.Now;
&lt;/span&gt;&lt;span&gt;135&lt;/span&gt;             System.IO.DirectoryInfo directoryInfo = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; System.IO.DirectoryInfo(Factory.logsDirPath);
&lt;/span&gt;&lt;span&gt;136&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;directoryInfo.Exists)
&lt;/span&gt;&lt;span&gt;137&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;138&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;139&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;140&lt;/span&gt;             System.IO.FileInfo[] files = directoryInfo.GetFiles(&lt;span&gt;this&lt;/span&gt;.logFilePre + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*.log&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, System.IO.SearchOption.TopDirectoryOnly);
&lt;/span&gt;&lt;span&gt;141&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (files == &lt;span&gt;null&lt;/span&gt; || files.Length &amp;lt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;142&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;143&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;144&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;145&lt;/span&gt;             DateTime time = DateTime.Now.AddDays(&lt;span&gt;0&lt;/span&gt; -&lt;span&gt; logFileRetentionDays);
&lt;/span&gt;&lt;span&gt;146&lt;/span&gt;             &lt;span&gt;foreach&lt;/span&gt; (System.IO.FileInfo file &lt;span&gt;in&lt;/span&gt;&lt;span&gt; files)
&lt;/span&gt;&lt;span&gt;147&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;148&lt;/span&gt;                 &lt;span&gt;try&lt;/span&gt;
&lt;span&gt;149&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;150&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (file.CreationTime &amp;lt;&lt;span&gt; time)
&lt;/span&gt;&lt;span&gt;151&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;152&lt;/span&gt; &lt;span&gt;                        file.Delete();
&lt;/span&gt;&lt;span&gt;153&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;154&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;155&lt;/span&gt;                 &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; { }
&lt;/span&gt;&lt;span&gt;156&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;157&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;158&lt;/span&gt; 
&lt;span&gt;159&lt;/span&gt; 
&lt;span&gt;160&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;161&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;Log.cs&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;&lt;img id=&quot;code_img_closed_0ab078a6-e27c-4536-ae25-d6e9dba21fb4&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_0ab078a6-e27c-4536-ae25-d6e9dba21fb4&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_0ab078a6-e27c-4536-ae25-d6e9dba21fb4&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;91&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Logger.Core
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TextFileReader
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt;         &lt;span&gt;bool&lt;/span&gt; _readStart = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt;         &lt;span&gt;bool&lt;/span&gt; _readEnd = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt;         System.IO.FileStream _stream = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt;         System.Text.Encoding _code = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt;         &lt;span&gt;long&lt;/span&gt; _fileLength = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt;         &lt;span&gt;long&lt;/span&gt; _currentPosition = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt;         &lt;span&gt;string&lt;/span&gt; _readStr = &lt;span&gt;string&lt;/span&gt;&lt;span&gt;.Empty;
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; _readBytes = &lt;span&gt;1024&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt;         &lt;span&gt;string&lt;/span&gt; _filePath = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt;         &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[] _defaultOffsetStrArray = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[] { System.Environment.NewLine, &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;?&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;？&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;；&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt;         &lt;span&gt;string&lt;/span&gt;[] _offsetStrArray = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt; 
&lt;span&gt; 17&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; ReadStr {
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt;             &lt;span&gt;get&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; _readStr; }
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; FilePath {
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt;             &lt;span&gt;get&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; _filePath; }
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt;             &lt;span&gt;set&lt;/span&gt; { _filePath =&lt;span&gt; value; }
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; ReadBytes {
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt;             &lt;span&gt;get&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt; _readBytes &amp;lt; &lt;span&gt;1024&lt;/span&gt; ? &lt;span&gt;1024&lt;/span&gt;&lt;span&gt; : _readBytes; }
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt;             &lt;span&gt;set&lt;/span&gt; { _readBytes =&lt;span&gt; value; }
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] OffsetStrArray {
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt;             &lt;span&gt;get&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt; (_offsetStrArray == &lt;span&gt;null&lt;/span&gt;|| _offsetStrArray.Length &amp;lt; &lt;span&gt;1&lt;/span&gt;)?&lt;span&gt; _defaultOffsetStrArray : _offsetStrArray; }
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt;             &lt;span&gt;set&lt;/span&gt; { _offsetStrArray =&lt;span&gt; value; }
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt; 
&lt;span&gt; 33&lt;/span&gt; 
&lt;span&gt; 34&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; TextFileReader() {
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt;             _offsetStrArray =&lt;span&gt; _defaultOffsetStrArray;
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; TextFileReader(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; FilePath)
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.FilePath =&lt;span&gt; FilePath;
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt;             _offsetStrArray =&lt;span&gt; _defaultOffsetStrArray;
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; GetPosition(&lt;span&gt;string&lt;/span&gt; readStr, &lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] offsetStrArray)
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; position = -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; offsetStrArray.Length; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt;                 position =&lt;span&gt; readStr.LastIndexOf(offsetStrArray[i]);
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (position &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; position;
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; Read()
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;_readStart)
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt; &lt;span&gt;            { 
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;System.IO.FileShare.ReadWrite：允许其它程序读写文件(重要，否则很可能会与负责写入的程序冲突而被拒绝访问)&lt;/span&gt;
&lt;span&gt; 60&lt;/span&gt;                 _stream = &lt;span&gt;new&lt;/span&gt; System.IO.FileStream(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.FilePath, System.IO.FileMode.Open, System.IO.FileAccess.Read, System.IO.FileShare.ReadWrite);
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt;                 _code = GetType(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.FilePath);
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt;                 _currentPosition = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt;                 _fileLength =&lt;span&gt; _stream.Length;
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt;                 _readStart = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (_currentPosition &amp;lt;&lt;span&gt; _fileLength)
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;                 &lt;span&gt;byte&lt;/span&gt;[] readBuffer = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.ReadBytes];
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置读取位置&lt;/span&gt;
&lt;span&gt; 70&lt;/span&gt; &lt;span&gt;                _stream.Seek(_currentPosition, System.IO.SeekOrigin.Begin);
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;本次实际读到的字节数&lt;/span&gt;
&lt;span&gt; 72&lt;/span&gt;                 &lt;span&gt;int&lt;/span&gt; currentReadBytes = _stream.Read(readBuffer, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, readBuffer.Length);
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;读取位置偏移&lt;/span&gt;
&lt;span&gt; 74&lt;/span&gt;                 _currentPosition +=&lt;span&gt; currentReadBytes;
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt; 
&lt;span&gt; 76&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;实际读到的字节少于指定的字节数(在读到最后一批时)&lt;/span&gt;
&lt;span&gt; 77&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (currentReadBytes &amp;lt;&lt;span&gt; _readBytes)
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt;                     &lt;span&gt;byte&lt;/span&gt;[] temp = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[currentReadBytes];
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt;                     &lt;span&gt;int&lt;/span&gt; index = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt;                     &lt;span&gt;while&lt;/span&gt; (index &amp;lt;&lt;span&gt; currentReadBytes)
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt;                         temp[index] =&lt;span&gt; readBuffer[index];
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt;                         index++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;                     readBuffer =&lt;span&gt; temp;
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt;                 _readStr =&lt;span&gt; _code.GetString(readBuffer);
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果没有读到最后一个字节则计算位置偏移&lt;/span&gt;
&lt;span&gt; 90&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (_currentPosition &amp;lt;&lt;span&gt; _fileLength)
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt;                     &lt;span&gt;int&lt;/span&gt; offsetStrPosition = GetPosition(_readStr, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.OffsetStrArray);
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (offsetStrPosition &amp;gt; &lt;span&gt;0&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;找到内容则计算位置偏移&lt;/span&gt;
&lt;span&gt; 94&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;提取将被移除的内容&lt;/span&gt;
&lt;span&gt; 96&lt;/span&gt;                         &lt;span&gt;string&lt;/span&gt; removeStr = _readStr.Substring(offsetStrPosition + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;移除内容&lt;/span&gt;
&lt;span&gt; 98&lt;/span&gt;                         _readStr = _readStr.Remove(offsetStrPosition + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;位置后退&lt;/span&gt;
&lt;span&gt;100&lt;/span&gt;                         _currentPosition = _currentPosition -&lt;span&gt; _code.GetBytes(removeStr).Length;
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;105&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt;                 _readEnd = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt; &lt;span&gt;                _stream.Dispose();
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; !&lt;span&gt;_readEnd;
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;         
&lt;span&gt;112&lt;/span&gt; 
&lt;span&gt;113&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; System.Text.Encoding GetType(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; fullname)
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt;             System.IO.FileStream fs = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; System.IO.FileStream(fullname, System.IO.FileMode.Open, System.IO.FileAccess.Read, System.IO.FileShare.ReadWrite);
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt;             System.Text.Encoding r =&lt;span&gt; GetType(fs);
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt; &lt;span&gt;            fs.Close();
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; r;
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; System.Text.Encoding GetType(System.IO.FileStream fs)
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt;             &lt;span&gt;byte&lt;/span&gt;[] Unicode = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] { &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFE&lt;/span&gt;, &lt;span&gt;0x41&lt;/span&gt;&lt;span&gt; };
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;             &lt;span&gt;byte&lt;/span&gt;[] UnicodeBIG = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] { &lt;span&gt;0xFE&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0x00&lt;/span&gt;&lt;span&gt; };
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt;             &lt;span&gt;byte&lt;/span&gt;[] UTF8 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] { &lt;span&gt;0xEF&lt;/span&gt;, &lt;span&gt;0xBB&lt;/span&gt;, &lt;span&gt;0xBF&lt;/span&gt;&lt;span&gt; };
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt;             System.Text.Encoding reVal =&lt;span&gt; System.Text.Encoding.Default;
&lt;/span&gt;&lt;span&gt;126&lt;/span&gt; 
&lt;span&gt;127&lt;/span&gt;             System.IO.BinaryReader r = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; System.IO.BinaryReader(fs, System.Text.Encoding.Default);
&lt;/span&gt;&lt;span&gt;128&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt;&lt;span&gt; i;
&lt;/span&gt;&lt;span&gt;129&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt;.TryParse(fs.Length.ToString(), &lt;span&gt;out&lt;/span&gt;&lt;span&gt; i);
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt;             &lt;span&gt;byte&lt;/span&gt;[] ss =&lt;span&gt; r.ReadBytes(i);
&lt;/span&gt;&lt;span&gt;131&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (IsUTF8Bytes(ss) || (ss[&lt;span&gt;0&lt;/span&gt;] == &lt;span&gt;0xEF&lt;/span&gt; &amp;amp;&amp;amp; ss[&lt;span&gt;1&lt;/span&gt;] == &lt;span&gt;0xBB&lt;/span&gt; &amp;amp;&amp;amp; ss[&lt;span&gt;2&lt;/span&gt;] == &lt;span&gt;0xBF&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;132&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt;                 reVal =&lt;span&gt; System.Text.Encoding.UTF8;
&lt;/span&gt;&lt;span&gt;134&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;135&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (ss[&lt;span&gt;0&lt;/span&gt;] == &lt;span&gt;0xFE&lt;/span&gt; &amp;amp;&amp;amp; ss[&lt;span&gt;1&lt;/span&gt;] == &lt;span&gt;0xFF&lt;/span&gt; &amp;amp;&amp;amp; ss[&lt;span&gt;2&lt;/span&gt;] == &lt;span&gt;0x00&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;136&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;137&lt;/span&gt;                 reVal =&lt;span&gt; System.Text.Encoding.BigEndianUnicode;
&lt;/span&gt;&lt;span&gt;138&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;139&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (ss[&lt;span&gt;0&lt;/span&gt;] == &lt;span&gt;0xFF&lt;/span&gt; &amp;amp;&amp;amp; ss[&lt;span&gt;1&lt;/span&gt;] == &lt;span&gt;0xFE&lt;/span&gt; &amp;amp;&amp;amp; ss[&lt;span&gt;2&lt;/span&gt;] == &lt;span&gt;0x41&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;140&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;141&lt;/span&gt;                 reVal =&lt;span&gt; System.Text.Encoding.Unicode;
&lt;/span&gt;&lt;span&gt;142&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;143&lt;/span&gt; &lt;span&gt;            r.Close();
&lt;/span&gt;&lt;span&gt;144&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; reVal;
&lt;/span&gt;&lt;span&gt;145&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;146&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; IsUTF8Bytes(&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] data)
&lt;/span&gt;&lt;span&gt;147&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;148&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; charByteCounter = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;149&lt;/span&gt;             &lt;span&gt;byte&lt;/span&gt;&lt;span&gt; curByte;
&lt;/span&gt;&lt;span&gt;150&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; data.Length; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;151&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;152&lt;/span&gt;                 curByte =&lt;span&gt; data[i];
&lt;/span&gt;&lt;span&gt;153&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (charByteCounter == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;154&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;155&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (curByte &amp;gt;= &lt;span&gt;0x80&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;156&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;157&lt;/span&gt;                         &lt;span&gt;while&lt;/span&gt; (((curByte &amp;lt;&amp;lt;= &lt;span&gt;1&lt;/span&gt;) &amp;amp; &lt;span&gt;0x80&lt;/span&gt;) != &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;158&lt;/span&gt; &lt;span&gt;                        {
&lt;/span&gt;&lt;span&gt;159&lt;/span&gt;                             charByteCounter++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;160&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;161&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; (charByteCounter == &lt;span&gt;1&lt;/span&gt; || charByteCounter &amp;gt; &lt;span&gt;6&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;162&lt;/span&gt; &lt;span&gt;                        {
&lt;/span&gt;&lt;span&gt;163&lt;/span&gt;                             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;164&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;165&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;166&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;167&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;168&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;169&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; ((curByte &amp;amp; &lt;span&gt;0xC0&lt;/span&gt;) != &lt;span&gt;0x80&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;170&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;171&lt;/span&gt;                         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;172&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;173&lt;/span&gt;                     charByteCounter--&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;174&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;175&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;176&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (charByteCounter &amp;gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;177&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;178&lt;/span&gt;                 &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Exception(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;非预期的byte格式&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;179&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;180&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;181&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;182&lt;/span&gt; 
&lt;span&gt;183&lt;/span&gt; 
&lt;span&gt;184&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;185&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;TextFileReader.cs&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36.5&quot;&gt;&lt;img id=&quot;code_img_closed_89d1a819-6bc0-4a2e-9814-943e4e1a5333&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_89d1a819-6bc0-4a2e-9814-943e4e1a5333&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_89d1a819-6bc0-4a2e-9814-943e4e1a5333&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;68&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Logger.Core
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Factory
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; setFileThreadCreateLockObj = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; loggerCreateLockObj = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; logsDirPath = System.IO.Path.Combine(AppDomain.CurrentDomain.BaseDirectory, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;logs&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;internal&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; System.Collections.Generic.Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, ILog&amp;gt; loggerDic = &lt;span&gt;new&lt;/span&gt; System.Collections.Generic.Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, ILog&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;internal&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; System.Threading.Thread setFileThread = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;internal&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; SetFileThreadStartFunc(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; obj)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 &lt;span&gt;try&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                     &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt; key &lt;span&gt;in&lt;/span&gt;&lt;span&gt; loggerDic.Keys)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;                        loggerDic[key].SaveLogToFile();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;                        loggerDic[key].ClearLogFile();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                     System.Threading.Thread.Sleep(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                 &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; { }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; SetFileThreadStart()
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (setFileThread == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                 &lt;span&gt;lock&lt;/span&gt;&lt;span&gt; (setFileThreadCreateLockObj)
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (setFileThread == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;                         setFileThread = &lt;span&gt;new&lt;/span&gt; System.Threading.Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; System.Threading.ParameterizedThreadStart(SetFileThreadStartFunc));
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                         setFileThread.IsBackground = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                         setFileThread.Start(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; ILog GetLogger()
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; GetLogger(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Trace&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ILog GetLogger(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; LogFilePre)
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; GetLogger(LogFilePre, &lt;span&gt;90&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ILog GetLogger(&lt;span&gt;string&lt;/span&gt; logFilePre, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; logFileRetentionDays)
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;             logFilePre =&lt;span&gt; GetLogFilePre(logFilePre);
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (loggerDic.ContainsKey(logFilePre))
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; loggerDic[logFilePre];
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;57&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;                 &lt;span&gt;lock&lt;/span&gt;&lt;span&gt; (loggerCreateLockObj)
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (loggerDic.ContainsKey(logFilePre))
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;                         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; loggerDic[logFilePre];
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;                     &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;65&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;                         ILog _logger = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Log(logFilePre, logFileRetentionDays);
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt; &lt;span&gt;                        loggerDic.Add(logFilePre, _logger);
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;                         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; _logger;
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; GetLogFilePre(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; logFilePre)
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(logFilePre))
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt; 
&lt;span&gt;77&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt;                 logFilePre = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Trace&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;80&lt;/span&gt;             logFilePre =&lt;span&gt; logFilePre.ToLower();
&lt;/span&gt;&lt;span&gt;81&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!logFilePre.EndsWith(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;82&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;83&lt;/span&gt;                 logFilePre = logFilePre + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;84&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;85&lt;/span&gt;             logFilePre = logFilePre.Substring(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;).ToUpper() + logFilePre.Substring(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;86&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; logFilePre;
&lt;/span&gt;&lt;span&gt;87&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;88&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; System.Collections.Generic.List&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; GetLogFilePreList()
&lt;/span&gt;&lt;span&gt;89&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;90&lt;/span&gt;             System.Collections.Generic.List&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; reval = &lt;span&gt;new&lt;/span&gt; System.Collections.Generic.List&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;91&lt;/span&gt;             &lt;span&gt;foreach&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt; key &lt;span&gt;in&lt;/span&gt;&lt;span&gt; loggerDic.Keys)
&lt;/span&gt;&lt;span&gt;92&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;93&lt;/span&gt; &lt;span&gt;                reval.Add(key);
&lt;/span&gt;&lt;span&gt;94&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;95&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; reval;
&lt;/span&gt;&lt;span&gt;96&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;97&lt;/span&gt; 
&lt;span&gt;98&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;99&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;Factory.cs&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;以上是实现日志功能的核心代码，下面在类库项目下直接添加两个静态类：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;LogWriter.cs 负责写，定义了常规的 Fatal , Error , Info , Debug 等方法及默认的日志时效期&lt;/li&gt;
&lt;li&gt;LogReader.cs 负责读，如获取日志类型列表，获取日志文件列表，或取日志文件的TextFileReader对象等&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38.5&quot;&gt;&lt;img id=&quot;code_img_closed_03373cf0-72f0-45cf-8e0c-55917890744d&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_03373cf0-72f0-45cf-8e0c-55917890744d&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_03373cf0-72f0-45cf-8e0c-55917890744d&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;72&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Logger
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LogWriter
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Core.ILog Debug()
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; Core.Factory.GetLogger(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Debug&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Core.ILog Debug(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; logInfo)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             Core.ILog logger =&lt;span&gt; Debug();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            logger.Write(logInfo);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; logger;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Core.ILog Debug(&lt;span&gt;string&lt;/span&gt; format, &lt;span&gt;params&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt;[] args)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             Core.ILog logger =&lt;span&gt; Debug();
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            logger.WriteFormat(format, args);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; logger;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Core.ILog Info()
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; Core.Factory.GetLogger(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Info&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;60&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Core.ILog Info(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; logInfo)
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             Core.ILog logger =&lt;span&gt; Info();
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;            logger.Write(logInfo);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; logger;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Core.ILog Info(&lt;span&gt;string&lt;/span&gt; format, &lt;span&gt;params&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt;[] args)
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;             Core.ILog logger =&lt;span&gt; Info();
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;            logger.WriteFormat(format, args);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; logger;
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Core.ILog Error()
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; Core.Factory.GetLogger(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Error&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;60&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Core.ILog Error(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; logInfo)
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;             Core.ILog logger =&lt;span&gt; Error();
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;            logger.Write(logInfo);
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; logger;
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Core.ILog Error(&lt;span&gt;string&lt;/span&gt; format, &lt;span&gt;params&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt;[] args)
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;             Core.ILog logger =&lt;span&gt; Error();
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;            logger.WriteFormat(format, args);
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; logger;
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Core.ILog Fatal()
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; Core.Factory.GetLogger(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Fatal&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;60&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Core.ILog Fatal(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; logInfo)
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;             Core.ILog logger =&lt;span&gt; Fatal();
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; &lt;span&gt;            logger.Write(logInfo);
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; logger;
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Core.ILog Fatal(&lt;span&gt;string&lt;/span&gt; format, &lt;span&gt;params&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt;[] args)
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;             Core.ILog logger =&lt;span&gt; Fatal();
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt; &lt;span&gt;            logger.WriteFormat(format, args);
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; logger;
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;LogWriter.cs&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_2163165d-6142-4bdc-b580-2128eae043bc&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_2163165d-6142-4bdc-b580-2128eae043bc&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_2163165d-6142-4bdc-b580-2128eae043bc&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Logger
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LogReader
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; System.Collections.Generic.List&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; GetLogFilePreList()
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Core.Factory.GetLogFilePreList();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; System.IO.FileInfo[] GetLogFiles(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; logFilePre)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             System.IO.DirectoryInfo dir = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; System.IO.DirectoryInfo(Core.Factory.logsDirPath);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;dir.Exists)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; System.IO.FileInfo[] { };
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             logFilePre =&lt;span&gt; Core.Factory.GetLogFilePre(logFilePre);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             System.IO.FileInfo[] fis = dir.GetFiles(logFilePre + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*.log&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, System.IO.SearchOption.TopDirectoryOnly);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (fis == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                 fis = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; System.IO.FileInfo[] { };
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; fis;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Core.TextFileReader GetTextFileReader(System.IO.FileInfo logFileInfo)
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             Core.TextFileReader textFileReader = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Core.TextFileReader(logFileInfo.FullName);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             textFileReader.ReadBytes = &lt;span&gt;1024&lt;/span&gt; * &lt;span&gt;1024&lt;/span&gt; * &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; textFileReader;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;LogReader&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;新建一个控制台程序来测试一下，测试代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38.5&quot;&gt;&lt;img id=&quot;code_img_closed_6c8f1fb4-d05c-4619-b101-737112914ed2&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_6c8f1fb4-d05c-4619-b101-737112914ed2&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_6c8f1fb4-d05c-4619-b101-737112914ed2&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;72&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt;         &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;            Writer();
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; &lt;span&gt;            Reader();
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt;         &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Writer()
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt; &lt;span&gt;6&lt;/span&gt;; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt;                 System.Threading.Thread thread = &lt;span&gt;new&lt;/span&gt; System.Threading.Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; System.Threading.ParameterizedThreadStart(WriterFunc));
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt;                 thread.IsBackground = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt; &lt;span&gt;                thread.Start(i);
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt;         &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; WriterFunc(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; num)
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; threadNum = (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)num;
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt;             &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt;                 Logger.LogWriter.Info(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;这是线程{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, threadNum);
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt;                 Logger.LogWriter.Error(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;这是线程{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, threadNum);
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt;                 Logger.LogWriter.Fatal(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;这是线程{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, threadNum);
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt;                 System.Threading.Thread.Sleep(&lt;span&gt;10&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt;         &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Reader()
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt;             &lt;span&gt;string&lt;/span&gt; cmd = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt;             &lt;span&gt;while&lt;/span&gt; (cmd != &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt;                 Console.Write(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;输入 r 读取日志：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt;                 cmd =&lt;span&gt; Console.ReadLine();
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt; 
&lt;span&gt; 37&lt;/span&gt;             System.Collections.Generic.List&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; preList =&lt;span&gt; Logger.LogReader.GetLogFilePreList();
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (preList.Count &amp;lt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt;                 Console.ForegroundColor =&lt;span&gt; ConsoleColor.Red;
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt;                 Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;未能检索到日志记录！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt; &lt;span&gt;                Console.ResetColor();
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; &lt;span&gt;                Reader();
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-----------------------------------------------------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt; 
&lt;span&gt; 47&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;编号\t类型前缀&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt;             Console.ForegroundColor =&lt;span&gt; ConsoleColor.Red;
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; preList.Count; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt;                 Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{0}\t{1}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, i + &lt;span&gt;1&lt;/span&gt;, preList[i]+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt; &lt;span&gt;            Console.ResetColor();
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-----------------------------------------------------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt; 
&lt;span&gt; 56&lt;/span&gt;             Console.Write(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;输入编号读取日志文件列表：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; preNum = GetInputNum(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;, preList.Count);
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt; 
&lt;span&gt; 59&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; files = Logger.LogReader.GetLogFiles(preList[preNum-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (files.Length &amp;lt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt;                 Console.ForegroundColor =&lt;span&gt; ConsoleColor.Red;
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt;                 Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;未能检索到日志文件！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt; &lt;span&gt;                Console.ResetColor();
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt; &lt;span&gt;                Reader();
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-----------------------------------------------------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt; 
&lt;span&gt; 69&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;编号\t日志文件&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt;             Console.ForegroundColor =&lt;span&gt; ConsoleColor.Red;
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; files.Length; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt;                 Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{0}\t{1}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, i + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;, System.IO.Path.GetFileName(files[i].FullName));
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt; &lt;span&gt;            Console.ResetColor();
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-----------------------------------------------------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt; 
&lt;span&gt; 78&lt;/span&gt;             Console.Write(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;输入编号读取日志：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; fileNum = GetInputNum(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;, files.Length);
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-----------------------------------------------------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt; 
&lt;span&gt; 82&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; reader = Logger.LogReader.GetTextFileReader(files[fileNum - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt;             &lt;span&gt;while&lt;/span&gt;&lt;span&gt; (reader.Read())
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt; &lt;span&gt;                Console.Write(reader.ReadStr);
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt; 
&lt;span&gt; 88&lt;/span&gt; &lt;span&gt;            Console.WriteLine();
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt; 
&lt;span&gt; 90&lt;/span&gt; &lt;span&gt;            Reader();
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt; 
&lt;span&gt; 92&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt;         &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; GetInputNum(&lt;span&gt;int&lt;/span&gt; min, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; max)
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; num = -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt;             &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt;                 &lt;span&gt;string&lt;/span&gt; inputNum =&lt;span&gt; Console.ReadLine();
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;                 &lt;span&gt;bool&lt;/span&gt; flag = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (System.Text.RegularExpressions.Regex.IsMatch(inputNum, &lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;^\d{1,9}$&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt;                     num =&lt;span&gt; Convert.ToInt32(inputNum);
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt;                     flag = num &amp;lt;= max &amp;amp;&amp;amp; num &amp;gt;=&lt;span&gt; min;
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;flag)
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt;                     Console.Write(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;输入不合法，请重新输入：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt;                     num = -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;111&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; num;
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;Program.cs&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;程序运行截图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1563651/201812/1563651-20181223232354382-186436755.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;至此，一个日志类库就算完成了。&lt;/p&gt;
&lt;p&gt;鉴于个人水平问题，不敢妄言更高效或更优雅，但是可以集成到其它项目中工作了，该代码作者在公司的实际项目中有使用。&lt;/p&gt;
&lt;p&gt;不用各种繁杂的配置，想写就写，如果想要添加一个其它类型的日志只要在LogWriter.cs中增加方法即可。&lt;/p&gt;

&lt;p&gt;（^_^）大神莫笑，小菜莫怕，欢迎善意的沟通和交流！&lt;/p&gt;

</description>
<pubDate>Sun, 23 Dec 2018 15:46:00 +0000</pubDate>
<dc:creator>如兹</dc:creator>
<og:description>写日志并不是简单的打开一个文件然后写入数据然后关闭了事，无论是web程序还是桌面程序，首要问题是多线程争抢写入一个日志文件的访问控制，次要问题是要允许其它进程在写入进程未释放日志文件时日志文件能被读取</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ruzi/p/10166506.html</dc:identifier>
</item>
</channel>
</rss>