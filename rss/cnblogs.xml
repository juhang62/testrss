<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（八） - 阿星Plus</title>
<link>http://www.cnblogs.com/meowv/p/13124967.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/meowv/p/13124967.html</guid>
<description>&lt;h2 id=&quot;系列文章&quot;&gt;系列文章&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/meowv/p/12896177.html&quot;&gt;基于 abp vNext 和 .NET Core 开发博客项目 - 使用 abp cli 搭建项目&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/meowv/p/12896898.html&quot;&gt;基于 abp vNext 和 .NET Core 开发博客项目 - 给项目瘦身，让它跑起来&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/meowv/p/12909558.html&quot;&gt;基于 abp vNext 和 .NET Core 开发博客项目 - 完善与美化，Swagger登场&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/meowv/p/12913676.html&quot;&gt;基于 abp vNext 和 .NET Core 开发博客项目 - 数据访问和代码优先&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/meowv/p/12916613.html&quot;&gt;基于 abp vNext 和 .NET Core 开发博客项目 - 自定义仓储之增删改查&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/meowv/p/12924409.html&quot;&gt;基于 abp vNext 和 .NET Core 开发博客项目 - 统一规范API，包装返回模型&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/meowv/p/12924859.html&quot;&gt;基于 abp vNext 和 .NET Core 开发博客项目 - 再说Swagger，分组、描述、小绿锁&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/meowv/p/12935693.html&quot;&gt;基于 abp vNext 和 .NET Core 开发博客项目 - 接入GitHub，用JWT保护你的API&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/meowv/p/12943699.html&quot;&gt;基于 abp vNext 和 .NET Core 开发博客项目 - 异常处理和日志记录&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/meowv/p/12956696.html&quot;&gt;基于 abp vNext 和 .NET Core 开发博客项目 - 使用Redis缓存数据&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/meowv/p/12961014.html&quot;&gt;基于 abp vNext 和 .NET Core 开发博客项目 - 集成Hangfire实现定时任务处理&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/meowv/p/12966092.html&quot;&gt;基于 abp vNext 和 .NET Core 开发博客项目 - 用AutoMapper搞定对象映射&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/meowv/p/12971041.html&quot;&gt;基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（一）&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/meowv/p/12974439.html&quot;&gt;基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（二）&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/meowv/p/12980301.html&quot;&gt;基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（三）&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/meowv/p/12987623.html&quot;&gt;基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（一）&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/meowv/p/12994914.html&quot;&gt;基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（二）&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/meowv/p/13039883.html&quot;&gt;基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（三）&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/meowv/p/13043084.html&quot;&gt;基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（四）&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/meowv/p/13046603.html&quot;&gt;基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（五）&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/meowv/p/13061975.html&quot;&gt;基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（一）&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/meowv/p/13065295.html&quot;&gt;基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（二）&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/meowv/p/13081035.html&quot;&gt;基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（三）&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/meowv/p/13088303.html&quot;&gt;基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（四）&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/meowv/p/13096000.html&quot;&gt;基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（五）&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/meowv/p/13124303.html&quot;&gt;基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（六）&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/meowv/p/13124533.html&quot;&gt;基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（七）&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;&lt;p&gt;上一篇完成了标签模块和友情链接模块的所有功能，本篇来继续完成博客最后的模块，文章的管理。&lt;/p&gt;
&lt;h2 id=&quot;文章列表--删除&quot;&gt;文章列表 &amp;amp; 删除&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/891843/202006/891843-20200614200844738-638855159.png&quot; alt=&quot;1&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;先将分页查询的列表给整出来，这块和首页的分页列表是类似的，就是多了个Id字段。&lt;/p&gt;
&lt;p&gt;先添加两条路由规则。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;@page &quot;/admin/posts&quot;
@page &quot;/admin/posts/{page:int}&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;新建返回数据默认&lt;code&gt;QueryPostForAdminDto.cs&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;//QueryPostForAdminDto.cs
using System.Collections.Generic;

namespace Meowv.Blog.BlazorApp.Response.Blog
{
    public class QueryPostForAdminDto
    {
        /// &amp;lt;summary&amp;gt;
        /// 年份
        /// &amp;lt;/summary&amp;gt;
        public int Year { get; set; }

        /// &amp;lt;summary&amp;gt;
        /// Posts
        /// &amp;lt;/summary&amp;gt;
        public IEnumerable&amp;lt;PostBriefForAdminDto&amp;gt; Posts { get; set; }
    }
}

//PostBriefForAdminDto.cs
namespace Meowv.Blog.BlazorApp.Response.Blog
{
    public class PostBriefForAdminDto : PostBriefDto
    {
        /// &amp;lt;summary&amp;gt;
        /// 主键
        /// &amp;lt;/summary&amp;gt;
        public int Id { get; set; }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后添加所需的参数：当前页码、限制条数、总页码、文章列表返回数据模型。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;/// &amp;lt;summary&amp;gt;
/// 当前页码
/// &amp;lt;/summary&amp;gt;
[Parameter]
public int? page { get; set; }

/// &amp;lt;summary&amp;gt;
/// 限制条数
/// &amp;lt;/summary&amp;gt;
private int Limit = 15;

/// &amp;lt;summary&amp;gt;
/// 总页码
/// &amp;lt;/summary&amp;gt;
private int TotalPage;

/// &amp;lt;summary&amp;gt;
/// 文章列表数据
/// &amp;lt;/summary&amp;gt;
private ServiceResult&amp;lt;PagedList&amp;lt;QueryPostForAdminDto&amp;gt;&amp;gt; posts;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在初始化函数&lt;code&gt;OnInitializedAsync()&lt;/code&gt;中调用API获取文章数据.&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;/// &amp;lt;summary&amp;gt;
/// 初始化
/// &amp;lt;/summary&amp;gt;
protected override async Task OnInitializedAsync()
{
    var token = await Common.GetStorageAsync(&quot;token&quot;);
    Http.DefaultRequestHeaders.Add(&quot;Authorization&quot;, $&quot;Bearer {token}&quot;);

    // 设置默认值
    page = page.HasValue ? page : 1;

    await RenderPage(page);
}

/// &amp;lt;summary&amp;gt;
/// 点击页码重新渲染数据
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;page&quot;&amp;gt;&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
private async Task RenderPage(int? page)
{
    // 获取数据
    posts = await Http.GetFromJsonAsync&amp;lt;ServiceResult&amp;lt;PagedList&amp;lt;QueryPostForAdminDto&amp;gt;&amp;gt;&amp;gt;($&quot;/blog/admin/posts?page={page}&amp;amp;limit={Limit}&quot;);

    // 计算总页码
    TotalPage = (int)Math.Ceiling((posts.Result.Total / (double)Limit));
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在初始化中判断page参数，如果没有值给他设置一个默认值1。&lt;code&gt;RenderPage(int? page)&lt;/code&gt;方法是调用API返回数据，并计算出总页码值。&lt;/p&gt;
&lt;p&gt;最后在页面上进行数据绑定。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;AdminLayout&amp;gt;
    @if (posts == null)
    {
        &amp;lt;Loading /&amp;gt;
    }
    else
    {
        &amp;lt;div class=&quot;post-wrap archive&quot;&amp;gt;
            &amp;lt;NavLink style=&quot;float:right&quot; href=&quot;/admin/post&quot;&amp;gt;&amp;lt;h3&amp;gt;📝~~~ 新增文章 ~~~📝&amp;lt;/h3&amp;gt;&amp;lt;/NavLink&amp;gt;
            @if (posts.Success &amp;amp;&amp;amp; posts.Result.Item.Any())
            {
                @foreach (var item in posts.Result.Item)
                {
                    &amp;lt;h3&amp;gt;@item.Year&amp;lt;/h3&amp;gt;
                    @foreach (var post in item.Posts)
                    {
                        &amp;lt;article class=&quot;archive-item&quot;&amp;gt;
                            &amp;lt;NavLink title=&quot;❌删除&quot; @onclick=&quot;@(async () =&amp;gt; await DeleteAsync(post.Id))&quot;&amp;gt;❌&amp;lt;/NavLink&amp;gt;
                            &amp;lt;NavLink title=&quot;📝编辑&quot; @onclick=&quot;@(async () =&amp;gt; await Common.NavigateTo($&quot;/admin/post/{post.Id}&quot;))&quot;&amp;gt;📝&amp;lt;/NavLink&amp;gt;
                            &amp;lt;NavLink target=&quot;_blank&quot; class=&quot;archive-item-link&quot; href=&quot;@(&quot;/post&quot; + post.Url)&quot;&amp;gt;@post.Title&amp;lt;/NavLink&amp;gt;
                            &amp;lt;span class=&quot;archive-item-date&quot;&amp;gt;@post.CreationTime&amp;lt;/span&amp;gt;
                        &amp;lt;/article&amp;gt;
                    }
                }
                &amp;lt;nav class=&quot;pagination&quot;&amp;gt;
                    @for (int i = 1; i &amp;lt;= TotalPage; i++)
                    {
                        var _page = i;

                        if (page == _page)
                        {
                            &amp;lt;span class=&quot;page-number current&quot;&amp;gt;@_page&amp;lt;/span&amp;gt;
                        }
                        else
                        {
                            &amp;lt;a class=&quot;page-number&quot; @onclick=&quot;@(() =&amp;gt; RenderPage(_page))&quot; href=&quot;/admin/posts/@_page&quot;&amp;gt;@_page&amp;lt;/a&amp;gt;
                        }
                    }
                &amp;lt;/nav&amp;gt;
            }
            else
            {
                &amp;lt;ErrorTip /&amp;gt;
            }
        &amp;lt;/div&amp;gt;
    }
&amp;lt;/AdminLayout&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;HTML内容放在组件&lt;code&gt;AdminLayout&lt;/code&gt;中，当 posts 没加载完数据的时候显示加载组件&lt;code&gt;&amp;lt;Loading /&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在页面上循环遍历文章数据和翻页页码，每篇文章标题前面添加两个按钮删除和编辑，同时单独加了一个新增文章的按钮。&lt;/p&gt;
&lt;p&gt;删除文章调用&lt;code&gt;DeleteAsync(int id)&lt;/code&gt;方法，需要传递参数，当前文章的id。&lt;/p&gt;
&lt;p&gt;新增和编辑按钮都跳转到&quot;/admin/post&quot;页面，当编辑的时候将id也传过去即可，路由规则为：&quot;/admin/post/{id}&quot;。&lt;/p&gt;
&lt;p&gt;删除文章``方法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;/// &amp;lt;summary&amp;gt;
/// 删除文章
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;id&quot;&amp;gt;&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
private async Task DeleteAsync(int id)
{
    // 弹窗确认
    bool confirmed = await Common.InvokeAsync&amp;lt;bool&amp;gt;(&quot;confirm&quot;, &quot;\n💥💢真的要干掉这篇该死的文章吗💢💥&quot;);

    if (confirmed)
    {
        var response = await Http.DeleteAsync($&quot;/blog/post?id={id}&quot;);

        var result = await response.Content.ReadFromJsonAsync&amp;lt;ServiceResult&amp;gt;();

        if (result.Success)
        {
            await RenderPage(page);
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;删除之前进行二次确认，避免误删，当确认删除之后调用删除文章API，最后重新渲染数据即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/891843/202006/891843-20200614202156563-532339787.gif&quot; alt=&quot;2&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;新增--更新文章&quot;&gt;新增 &amp;amp; 更新文章&lt;/h2&gt;
&lt;p&gt;完成了后台文章列表的查询和删除，现在整个博客模块功能就差新增和更新文章了，胜利就在前方，冲啊。&lt;/p&gt;
&lt;p&gt;这块的开发工作耗费了我太多时间，因为想使用 markdown 来写文章，找了一圈下来没有一个合适的组件，所以退而求次只能选择现有的markdown编辑器来实现了。&lt;/p&gt;
&lt;p&gt;我这里选择了开源的编辑器&lt;code&gt;Editor.md&lt;/code&gt;，有需要的可以去 Github 自己下载，&lt;a href=&quot;https://github.com/pandao/editor.md&quot;&gt;https://github.com/pandao/editor.md&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;将下载的资源包解压放在 wwwroot 文件夹下，默认是比较大的，而且还有很多示例文件，我已经将其精简了一番，可以去我 Github 下载使用。&lt;/p&gt;
&lt;p&gt;先来看下最终的成品效果吧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/891843/202006/891843-20200614214938404-633246509.png&quot; alt=&quot;3&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;是不是感觉还可以，废话不多说，接下里告诉大家如何实现。&lt;/p&gt;
&lt;p&gt;在 Admin 文件夹下添加&lt;code&gt;post.razor&lt;/code&gt;组件，设置路由，并且引用一个样式文件，在页面中引用样式文件好像不太符合标准，不过无所谓了，这个后台就自己用，而且还就这一个页面用得到。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;@page &quot;/admin/post&quot;
@page &quot;/admin/post/{id:int}&quot;

&amp;lt;link href=&quot;./editor.md/css/editormd.css&quot; rel=&quot;stylesheet&quot; /&amp;gt;

&amp;lt;AdminLayout&amp;gt;
    ...
&amp;lt;/AdminLayout&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;把具体HTML内容放在组件&lt;code&gt;AdminLayout&lt;/code&gt;中。&lt;/p&gt;
&lt;p&gt;因为新增和编辑放在同一个页面上，所以当id参数不为空的时候需要添加一个id参数，同时默认一进来就让页面显示加载中的组件，当页面和数据加载完成后在显示具体的内容，所以在指定一个布尔类型的是否加载参数&lt;code&gt;isLoading&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;我们的编辑器主要依赖JavaScript实现的，所以这里不可避免要使用到JavaScript了。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;app.js&lt;/code&gt;中添加几个全局函数。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;switchEditorTheme: function () {
    editor.setTheme(localStorage.editorTheme || 'default');
    editor.setEditorTheme(localStorage.editorTheme === 'dark' ? 'pastel-on-dark' : 'default');
    editor.setPreviewTheme(localStorage.editorTheme || 'default');
},
renderEditor: async function () {
        await this._loadScript('./editor.md/lib/zepto.min.js').then(function () {
            func._loadScript('./editor.md/editormd.js').then(function () {
                editor = editormd(&quot;editor&quot;, {
                    width: &quot;100%&quot;,
                    height: 700,
                    path: './editor.md/lib/',
                    codeFold: true,
                    saveHTMLToTextarea: true,
                    emoji: true,
                    atLink: false,
                    emailLink: false,
                    theme: localStorage.editorTheme || 'default',
                    editorTheme: localStorage.editorTheme === 'dark' ? 'pastel-on-dark' : 'default',
                    previewTheme: localStorage.editorTheme || 'default',
                    toolbarIcons: function () {
                        return [&quot;bold&quot;, &quot;del&quot;, &quot;italic&quot;, &quot;quote&quot;, &quot;ucwords&quot;, &quot;uppercase&quot;, &quot;lowercase&quot;, &quot;h1&quot;, &quot;h2&quot;, &quot;h3&quot;, &quot;h4&quot;, &quot;h5&quot;, &quot;h6&quot;, &quot;list-ul&quot;, &quot;list-ol&quot;, &quot;hr&quot;, &quot;link&quot;, &quot;image&quot;, &quot;code&quot;, &quot;preformatted-text&quot;, &quot;code-block&quot;, &quot;table&quot;, &quot;datetime&quot;, &quot;html-entities&quot;, &quot;emoji&quot;, &quot;watch&quot;, &quot;preview&quot;, &quot;fullscreen&quot;, &quot;clear&quot;, &quot;||&quot;, &quot;save&quot;]
                    },
                    toolbarIconsClass: {
                        save: &quot;fa-check&quot;
                    },
                    toolbarHandlers: {
                        save: function () {
                            func._shoowBox();
                        }
                    },
                    onload: function () {
                        this.addKeyMap({
                            &quot;Ctrl-S&quot;: function () {
                                func._shoowBox();
                            }
                        });
                    }
                });
            });
        });
},
_shoowBox: function () {
    DotNet.invokeMethodAsync('Meowv.Blog.BlazorApp', 'showbox');
},
_loadScript: async function (url) {
    let response = await fetch(url);
    var js = await response.text();
    eval(js);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;renderEditor&lt;/code&gt;主要实现了动态加载JavaScript代码，将markdown编辑器渲染出来。这里不多说，都是&lt;code&gt;Editor.md&lt;/code&gt;示例里面的代码。&lt;/p&gt;
&lt;p&gt;为了兼容暗黑色主题，这里还加了一个切换编辑器主题的JavaScript方法，&lt;code&gt;switchEditorTheme&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;_shoowBox&lt;/code&gt;就厉害了，这个方法是调用的.NET组件中的方法，前面我们用过了在Blazor中调用JavaScript，这里演示了JavaScript中调用Blazor中的组件方法。&lt;/p&gt;
&lt;p&gt;现在将所需的几个参数都添加到代码中。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;/// &amp;lt;summary&amp;gt;
/// 定义一个委托方法，用于组件实例方法调用
/// &amp;lt;/summary&amp;gt;
private static Func&amp;lt;Task&amp;gt; action;

/// &amp;lt;summary&amp;gt;
/// 默认隐藏Box
/// &amp;lt;/summary&amp;gt;
private bool Open { get; set; } = false;

/// &amp;lt;summary&amp;gt;
/// 修改时的文章Id
/// &amp;lt;/summary&amp;gt;
[Parameter]
public int? Id { get; set; }

/// &amp;lt;summary&amp;gt;
/// 格式化的标签
/// &amp;lt;/summary&amp;gt;
private string tags { get; set; }

/// &amp;lt;summary&amp;gt;
/// 默认显示加载中
/// &amp;lt;/summary&amp;gt;
private bool isLoading = true;

/// &amp;lt;summary&amp;gt;
/// 文章新增或者修改输入参数
/// &amp;lt;/summary&amp;gt;
private PostForAdminDto input;

/// &amp;lt;summary&amp;gt;
/// API返回的分类列表数据
/// &amp;lt;/summary&amp;gt;
private ServiceResult&amp;lt;IEnumerable&amp;lt;QueryCategoryForAdminDto&amp;gt;&amp;gt; categories;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;大家看看注释就知道参数是做什么的了。&lt;/p&gt;
&lt;p&gt;现在我们在初始化函数中将所需的数据通过API获取到。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;/// &amp;lt;summary&amp;gt;
/// 初始化
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
protected override async Task OnInitializedAsync()
{
    action = ChangeOpenStatus;

    var token = await Common.GetStorageAsync(&quot;token&quot;);
    Http.DefaultRequestHeaders.Add(&quot;Authorization&quot;, $&quot;Bearer {token}&quot;);

    if (Id.HasValue)
    {
        var post = await Http.GetFromJsonAsync&amp;lt;ServiceResult&amp;lt;PostForAdminDto&amp;gt;&amp;gt;($&quot;/blog/admin/post?id={Id}&quot;);

        if (post.Success)
        {
            var _post = post.Result;
            input = new PostForAdminDto
            {
                Title = _post.Title,
                Author = _post.Author,
                Url = _post.Url,
                Html = _post.Html,
                Markdown = _post.Markdown,
                CategoryId = _post.CategoryId,
                Tags = _post.Tags,
                CreationTime = _post.CreationTime
            };

            tags = string.Join(&quot;,&quot;, input.Tags);
        }
    }
    else
    {
        input = new PostForAdminDto()
        {
            Author = &quot;阿星Plus&quot;,
            CreationTime = DateTime.Now
        };
    }

    categories = await Http.GetFromJsonAsync&amp;lt;ServiceResult&amp;lt;IEnumerable&amp;lt;QueryCategoryForAdminDto&amp;gt;&amp;gt;&amp;gt;(&quot;/blog/admin/categories&quot;);

    // 渲染编辑器
    await Common.InvokeAsync(&quot;window.func.renderEditor&quot;);

    // 关闭加载
    isLoading = !isLoading;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;action是一个异步的委托，在初始化中执行了&lt;code&gt;ChangeOpenStatus&lt;/code&gt;方法，这个方法等会说，然后获取&lt;code&gt;localStorage&lt;/code&gt;中token的值。&lt;/p&gt;
&lt;p&gt;通过参数Id是否有值来判断当前是新增文章还是更新文章，如果有值就是更新文章，这时候需要根据id去将文章的数据拿到赋值给&lt;code&gt;PostForAdminDto&lt;/code&gt;对象展示在页面上，如果没有可以添加几个默认值给&lt;code&gt;PostForAdminDto&lt;/code&gt;对象。&lt;/p&gt;
&lt;p&gt;因为文章需要分类和标签的数据，同时这里将分类的数据也查出来，标签默认是List列表，将其转换成字符串类型。&lt;/p&gt;
&lt;p&gt;但完成上面操作后，调用JavaScript方法&lt;code&gt;renderEditor&lt;/code&gt;渲染渲染编辑器，最后关闭加载，显示页面。&lt;/p&gt;
&lt;p&gt;现在来看看页面。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;AdminLayout&amp;gt;
    @if (isLoading)
    {
        &amp;lt;Loading /&amp;gt;
    }
    else
    {
        &amp;lt;div class=&quot;post-box&quot;&amp;gt;
            &amp;lt;div class=&quot;post-box-item&quot;&amp;gt;
                &amp;lt;input type=&quot;text&quot; placeholder=&quot;标题&quot; autocomplete=&quot;off&quot; @bind=&quot;@input.Title&quot; @bind:event=&quot;oninput&quot; @onclick=&quot;@(() =&amp;gt; { Open = false; })&quot; /&amp;gt;
                &amp;lt;input type=&quot;text&quot; placeholder=&quot;作者&quot; autocomplete=&quot;off&quot; @bind=&quot;@input.Author&quot; @bind:event=&quot;oninput&quot; @onclick=&quot;@(() =&amp;gt; { Open = false; })&quot; /&amp;gt;
            &amp;lt;/div&amp;gt;
            &amp;lt;div class=&quot;post-box-item&quot;&amp;gt;
                &amp;lt;input type=&quot;text&quot; placeholder=&quot;URL&quot; autocomplete=&quot;off&quot; @bind=&quot;@input.Url&quot; @bind:event=&quot;oninput&quot; @onclick=&quot;@(() =&amp;gt; { Open = false; })&quot; /&amp;gt;
                &amp;lt;input type=&quot;text&quot; placeholder=&quot;时间&quot; autocomplete=&quot;off&quot; @bind=&quot;@input.CreationTime&quot; @bind:format=&quot;yyyy-MM-dd HH:mm:sss&quot; @bind:event=&quot;oninput&quot; @onclick=&quot;@(() =&amp;gt; { Open = false; })&quot; /&amp;gt;
            &amp;lt;/div&amp;gt;
            &amp;lt;div id=&quot;editor&quot;&amp;gt;
                &amp;lt;textarea style=&quot;display:none;&quot;&amp;gt;@input.Markdown&amp;lt;/textarea&amp;gt;
            &amp;lt;/div&amp;gt;

            &amp;lt;Box OnClickCallback=&quot;@SubmitAsync&quot; Open=&quot;@Open&quot; ButtonText=&quot;发布&quot;&amp;gt;
                &amp;lt;div class=&quot;box-item&quot;&amp;gt;
                    &amp;lt;b&amp;gt;分类：&amp;lt;/b&amp;gt;
                    @if (categories.Success &amp;amp;&amp;amp; categories.Result.Any())
                    {
                        @foreach (var item in categories.Result)
                        {
                            &amp;lt;label&amp;gt;&amp;lt;input type=&quot;radio&quot; name=&quot;category&quot; value=&quot;@item.Id&quot; @onchange=&quot;@(() =&amp;gt; { input.CategoryId = item.Id; })&quot; checked=&quot;@(item.Id == input.CategoryId)&quot; /&amp;gt;@item.CategoryName&amp;lt;/label&amp;gt;
                        }
                    }
                &amp;lt;/div&amp;gt;
                &amp;lt;div class=&quot;box-item&quot;&amp;gt;&amp;lt;/div&amp;gt;
                &amp;lt;div class=&quot;box-item&quot;&amp;gt;
                    &amp;lt;b&amp;gt;标签：&amp;lt;/b&amp;gt;
                    &amp;lt;input type=&quot;text&quot; @bind=&quot;@tags&quot; @bind:event=&quot;oninput&quot; /&amp;gt;
                &amp;lt;/div&amp;gt;
            &amp;lt;/Box&amp;gt;
        &amp;lt;/div&amp;gt;
    }
&amp;lt;/AdminLayout&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;添加了四个input框，分别用来绑定标题、作者、URL、时间，&lt;code&gt;&amp;lt;div id=&quot;editor&quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;/code&gt;中为编辑器所需。&lt;/p&gt;
&lt;p&gt;然后我这里还是把之前的弹窗组件搞出来了，执行逻辑不介绍了，在弹窗组件中自定义显示分类和标签的内容，将获取到的分类和标签绑定到具体位置。&lt;/p&gt;
&lt;p&gt;每个分类都是一个radio标签，并且对应一个点击事件，点哪个就把当前分类的Id赋值给&lt;code&gt;PostForAdminDto&lt;/code&gt;对象。&lt;/p&gt;
&lt;p&gt;所有的input框都使用&lt;code&gt;@bind&lt;/code&gt;和&lt;code&gt;@bind:event&lt;/code&gt;绑定数据和获取数据。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Box&lt;/code&gt;弹窗组件这里自定义了按钮文字，&lt;code&gt;ButtonText=&quot;发布&quot;&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;/// &amp;lt;summary&amp;gt;
/// 改变Open状态，通知组件渲染
/// &amp;lt;/summary&amp;gt;
private async Task ChangeOpenStatus()
{
    Open = true;

    var markdown = await Common.InvokeAsync&amp;lt;string&amp;gt;(&quot;editor.getMarkdown&quot;);
    var html = await Common.InvokeAsync&amp;lt;string&amp;gt;(&quot;editor.getHTML&quot;);

    if (string.IsNullOrEmpty(input.Title) || string.IsNullOrEmpty(input.Url) ||
        string.IsNullOrEmpty(input.Author) || string.IsNullOrEmpty(markdown) ||
        string.IsNullOrEmpty(html))
    {
        await Alert();
    }

    input.Html = html;
    input.Markdown = markdown;

    StateHasChanged();
}

/// &amp;lt;summary&amp;gt;
/// 暴漏给JS执行，弹窗确认框
/// &amp;lt;/summary&amp;gt;
[JSInvokable(&quot;showbox&quot;)]
public static void ShowBox()
{
    action.Invoke();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;/// &amp;lt;summary&amp;gt;
/// alert提示
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
private async Task Alert()
{
    Open = false;

    await Common.InvokeAsync(&quot;alert&quot;, &quot;\n💥💢好像漏了点什么吧💢💥&quot;);
    return;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在可以来看看&lt;code&gt;ChangeOpenStatus&lt;/code&gt;方法了，这个是改变当前弹窗状态的一个方法。为什么需要这个方法呢?&lt;/p&gt;
&lt;p&gt;因为在Blazor中JavaScript想要调用组件内的方法，方法必须是静态的，那么只能通过这种方式去实现了，在静态方法是不能够直接改变弹窗的状态值的。&lt;/p&gt;
&lt;p&gt;其实也可以不用这么麻烦，因为我在编辑器上自定义了一个按钮，为了好看一些所以只能曲折一点，嫌麻烦的可以直接在页面上搞个按钮执行保存数据逻辑也是一样的。&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;JSInvokable&lt;/code&gt;Attribute需要在&lt;code&gt;_Imports.razor&lt;/code&gt;中添加命名空间&lt;code&gt;@using Microsoft.JSInterop&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ChangeOpenStatus&lt;/code&gt;中获取到文章内容：HTML和markdown，赋值给&lt;code&gt;PostForAdminDto&lt;/code&gt;对象，要先进行判断页面上的几个参数是否有值，没值的话给出提示执行&lt;code&gt;Alert()&lt;/code&gt;方法，最后使用&lt;code&gt;StateHasChanged()&lt;/code&gt;通知组件其状态已更改。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Alert&lt;/code&gt;方法就是调用原生的JavaScript&lt;code&gt;alert&lt;/code&gt;方法，给出一个提示。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ShowBox&lt;/code&gt;就是暴漏给JavaScript的方法，使用&lt;code&gt;DotNet.invokeMethodAsync('Meowv.Blog.BlazorApp', 'showbox');&lt;/code&gt;进行调用。&lt;/p&gt;
&lt;p&gt;那么现在一切都正常进行的情况下，点击编辑器上自定义的保存按钮，页面上值不为空的情况下就会弹出我们的弹窗组件&lt;code&gt;Box&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;最后在弹窗组件的回调方法中执行新增文章还是更新文章。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;/// &amp;lt;summary&amp;gt;
/// 确认按钮点击事件
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
private async Task SubmitAsync()
{
    if (string.IsNullOrEmpty(tags) || input.CategoryId == 0)
    {
        await Alert();
    }

    input.Tags = tags.Split(&quot;,&quot;);

    var responseMessage = new HttpResponseMessage();

    if (Id.HasValue)
        responseMessage = await Http.PutAsJsonAsync($&quot;/blog/post?id={Id}&quot;, input);
    else
        responseMessage = await Http.PostAsJsonAsync(&quot;/blog/post&quot;, input);

    var result = await responseMessage.Content.ReadFromJsonAsync&amp;lt;ServiceResult&amp;gt;();
    if (result.Success)
    {
        await Common.NavigateTo(&quot;/admin/posts&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打开弹窗后执行回调事件之前还是要判断值是否为空，为空的情况下还是给出&lt;code&gt;alert&lt;/code&gt;提示，此时将tags标签还是转换成List列表，根据Id是否有值去执行新增数据或者更新数据，最终成功后跳转到文章列表页。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/891843/202006/891843-20200614215750117-640132844.gif&quot; alt=&quot;4&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/891843/202006/891843-20200614215755962-368836717.gif&quot; alt=&quot;5&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本片到这里就结束了，主要攻克了在Blazor中使用Markdown编辑器实现新增和更新文章，这个系列差不多就快结束了，预计还有2篇的样子，感谢各位的支持。&lt;/p&gt;
&lt;p&gt;开源地址：&lt;a href=&quot;https://github.com/Meowv/Blog/tree/blog_tutorial&quot;&gt;https://github.com/Meowv/Blog/tree/blog_tutorial&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 17 Jun 2020 00:54:00 +0000</pubDate>
<dc:creator>阿星Plus</dc:creator>
<og:description>系列文章 基于 abp vNext 和 .NET Core 开发博客项目 - 使用 abp cli 搭建项目 基于 abp vNext 和 .NET Core 开发博客项目 - 给项目瘦身，让它跑起来</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/meowv/p/13124967.html</dc:identifier>
</item>
<item>
<title>Spring Cloud Alibaba系列（四）使用gateway作为服务网关 - Java旅途</title>
<link>http://www.cnblogs.com/zhixie/p/13150402.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhixie/p/13150402.html</guid>
<description>&lt;h2 id=&quot;什么是网关&quot;&gt;什么是网关&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;在微服务架构里，服务的粒度被进一步细分，各个业务服务可以被独立的设计、开发、测试、部署和管理。这时，各个独立部署单元可以用不同的开发测试团队维护，可以使用不同的编程语言和技术平台进行设计，这就要求必须使用一种语言和平台无关的服务协议作为各个单元间的通讯方式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;换句话说就是网关为所有的请求提供了统一的入口，方便我们对服务请求和响应做统一管理。&lt;/p&gt;
&lt;h2 id=&quot;为什么要用网关&quot;&gt;为什么要用网关&lt;/h2&gt;
&lt;p&gt;API 网关是一个处于应用程序或服务（提供 REST API 接口服务）之前的系统，用来管理授权、访问控制和流量限制等，这样 REST API 接口服务就被 API 网关保护起来，对所有的调用者透明。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/05/06/UkVGCHc68yYTzjO.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;什么是gateway&quot;&gt;什么是gateway&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Spring Cloud Gateway是Spring官方基于Spring 5.0，Spring Boot 2.0和Project Reactor等技术开发的网关，Spring Cloud Gateway旨在为微服务架构提供一种简单而有效的统一的API路由管理方式。Spring Cloud Gateway作为Spring Cloud生态系中的网关，目标是替代ZUUL，其不仅提供统一的路由方式，并且基于Filter链的方式提供了网关基本的功能，例如：安全，监控/埋点，和限流等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;gateway工作原理&quot;&gt;gateway工作原理&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/05/06/UXRmb5Cclh9Wjrz.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;客户端向Spring Cloud网关发出请求。如果网关处理程序映射确定请求与路由匹配，则将其发送到网关Web处理程序。该处理程序运行通过特定于请求的过滤器链发送请求。过滤器由虚线分隔的原因是，过滤器可以在发送代理请求之前或之后执行逻辑。执行所有“前置”过滤器逻辑，然后发出代理请求。发出代理请求后，将执行“后”过滤器逻辑。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;路由规则&quot;&gt;路由规则&lt;/h2&gt;
&lt;p&gt;路由和过滤器是gateway中非常重要的两个概念，gateway本身提供了非常丰富的路由规则和多种过滤器来适配我们的需求。gateway提供了11种路由规则，分别是：&lt;/p&gt;
&lt;ul readability=&quot;8&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;后置路由谓词工厂&lt;/p&gt;
&lt;p&gt;该谓词匹配在当前日期时间之后发生的请求。参数名为 After&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;前置路由谓词工厂&lt;/p&gt;
&lt;p&gt;该谓词匹配当前日期时间之前发生的请求。参数名为 Before&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;时间段路由谓词工厂&lt;/p&gt;
&lt;p&gt;该谓词匹配在datetime1之后和datetime2之前发生的请求。参数名为 Between&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;cookie路由谓词工厂&lt;/p&gt;
&lt;p&gt;该谓词匹配具有给定名称的cookie，并且值匹配正则表达式。参数名为 Cookie&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;标头路由谓词工厂&lt;/p&gt;
&lt;p&gt;该谓词与具有给定名称的标头匹配，并且值与正则表达式匹配。参数名为 Header&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;主机路由谓词工厂&lt;/p&gt;
&lt;p&gt;该谓词是指由路由进行匹配，匹配多个路由时用,隔开。参数名为 Host&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;方法路由谓词工厂&lt;/p&gt;
&lt;p&gt;该参数是一个或多个要匹配的HTTP方法。参数名为 Method&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;路径路由谓词工厂&lt;/p&gt;
&lt;p&gt;该谓词是指在请求路径上加一个前缀，以此来匹配。参数名为 Path&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查询路由谓词工厂&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;RemoteAddr路由谓词工厂&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重量路线谓词工厂&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其中，我们比较常用的就是&lt;strong&gt;路径路由谓词工厂&lt;/strong&gt;，配合StripPrefix GatewayFilter工厂，实现我们的路由匹配转发。&lt;/p&gt;
&lt;p&gt;路径路由谓词工厂配置如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;spring:
  cloud:
    gateway:
          discovery:
          locator:
                enabled: true # 开启从注册中心动态创建路由的功能，利用微服务名称进行路由
      routes:
          # 路由id，建议配合服务名
        - id: demo_route 
          #匹配路由名
          uri: lb://demo-provider 
          predicates:
          # 断言，路径相匹配的进行路由
          - Path=/demo/** 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置的含义就是，如果请求路径中是/demo/**，则转发到demo-provider服务。&lt;/p&gt;
&lt;h2 id=&quot;网关过滤器&quot;&gt;网关过滤器&lt;/h2&gt;
&lt;p&gt;在spring cloud gateway 2.2.2.RELEASE版本中，已经默认实现了30种过滤器。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;序号&lt;/th&gt;
&lt;th&gt;过滤器工厂&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;49.5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;AddRequestHeader&lt;/td&gt;
&lt;td&gt;为原始请求添加Header&lt;/td&gt;
&lt;td&gt;Header的名称及值&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;AddRequestParameter&lt;/td&gt;
&lt;td&gt;为原始请求添加请求参数&lt;/td&gt;
&lt;td&gt;参数名称及值&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;AddResponseHeader&lt;/td&gt;
&lt;td&gt;为原始响应添加Header&lt;/td&gt;
&lt;td&gt;Header的名称及值&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;DedupeResponseHeader&lt;/td&gt;
&lt;td&gt;剔除响应头中重复的值&lt;/td&gt;
&lt;td&gt;需要去重的Header名称及去重策略&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;Hystrix&lt;/td&gt;
&lt;td&gt;为路由引入Hystrix的断路器保护&lt;/td&gt;
&lt;td&gt;HystrixCommand的名称&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;CircuitBreaker&lt;/td&gt;
&lt;td&gt;为路由引入Resilience4J断路器保护&lt;/td&gt;
&lt;td&gt;CircuitBreaker的名称&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;FallbackHeaders&lt;/td&gt;
&lt;td&gt;为fallbackUri的请求头中添加具体的异常信息&lt;/td&gt;
&lt;td&gt;Header的名称&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td/&gt;
&lt;td&gt;MapRequestHeader&lt;/td&gt;
&lt;td&gt;更新原始请求中的Header&lt;/td&gt;
&lt;td&gt;Header的值&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;PrefixPath&lt;/td&gt;
&lt;td&gt;为原始请求头添加前缀&lt;/td&gt;
&lt;td&gt;前缀路径&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;PreserveHostHeader&lt;/td&gt;
&lt;td&gt;为请求添加preserverHostHeader=true的属性，路由过滤器会检查该属性以决定是否要发送原始的host&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;RequestRateLimiter&lt;/td&gt;
&lt;td&gt;用于对请求限流，限流算法为令牌桶&lt;/td&gt;
&lt;td&gt;keyResolver、rateLimiter、statusCode、denyEmptyKey、emptyKeyStatus&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;12&lt;/td&gt;
&lt;td&gt;RedirectTo&lt;/td&gt;
&lt;td&gt;将原始请求重定向到指定的url&lt;/td&gt;
&lt;td&gt;http状态码及重定向的url&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;13&lt;/td&gt;
&lt;td&gt;RemoveHopByHopHeadersFilter&lt;/td&gt;
&lt;td&gt;为原始请求删除IETF组织规定的一系列Header&lt;/td&gt;
&lt;td&gt;默认就会启用，可以通过配置指定仅删除哪些Header&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;14&lt;/td&gt;
&lt;td&gt;RemoveRequestHeader&lt;/td&gt;
&lt;td&gt;为原始请求删除某个Header&lt;/td&gt;
&lt;td&gt;Header名称&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;15&lt;/td&gt;
&lt;td&gt;RemoveResponseHeader&lt;/td&gt;
&lt;td&gt;为原始响应删除某个Header&lt;/td&gt;
&lt;td&gt;Header名称&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;RewritePath&lt;/td&gt;
&lt;td&gt;重写原始的请求路径&lt;/td&gt;
&lt;td&gt;原始路径正则表达式以及重写后路径的正则表达式&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td/&gt;
&lt;td&gt;RewriteLocationResponseHeader&lt;/td&gt;
&lt;td&gt;重写响应头的&lt;code&gt;Location&lt;/code&gt; 的值&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;18&lt;/td&gt;
&lt;td&gt;RewriteResponseHeader&lt;/td&gt;
&lt;td&gt;重写原始响应中的某个Header&lt;/td&gt;
&lt;td&gt;Header名称，值的正则表达式，重写后的值&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;19&lt;/td&gt;
&lt;td&gt;SaveSession&lt;/td&gt;
&lt;td&gt;在转发请求之前，强制执行&lt;code&gt;WebSession::save&lt;/code&gt;操作&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;20&lt;/td&gt;
&lt;td&gt;SecureHeaders&lt;/td&gt;
&lt;td&gt;为原始响应添加一系列起安全作用的响应头&lt;/td&gt;
&lt;td&gt;无，支持修改这些安全响应头的值&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;21&lt;/td&gt;
&lt;td&gt;SetPath&lt;/td&gt;
&lt;td&gt;修改原始的请求路径&lt;/td&gt;
&lt;td&gt;修改后的值&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;22&lt;/td&gt;
&lt;td&gt;SetRequestHeader&lt;/td&gt;
&lt;td&gt;修改原始请求中的某个Header的值&lt;/td&gt;
&lt;td&gt;Header名称，修改后的值&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;23&lt;/td&gt;
&lt;td&gt;SetResponseHeader&lt;/td&gt;
&lt;td&gt;修改原始响应中某个Header的值&lt;/td&gt;
&lt;td&gt;Header名称，修改后的值&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;24&lt;/td&gt;
&lt;td&gt;SetStatus&lt;/td&gt;
&lt;td&gt;修改原始响应的状态码&lt;/td&gt;
&lt;td&gt;HTTP 状态码，可以是数字，也可以是字符串&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;25&lt;/td&gt;
&lt;td&gt;StripPrefix&lt;/td&gt;
&lt;td&gt;用于截断原始请求的路径&lt;/td&gt;
&lt;td&gt;使用数字表示要截断的路径的数量&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;26&lt;/td&gt;
&lt;td&gt;Retry&lt;/td&gt;
&lt;td&gt;针对不同的响应进行重试&lt;/td&gt;
&lt;td&gt;retries、statuses、methods、series&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;27&lt;/td&gt;
&lt;td&gt;RequestSize&lt;/td&gt;
&lt;td&gt;设置允许接收最大请求包的大小。如果请求包大小超过设置的值，则返回 &lt;code&gt;413 Payload Too Large&lt;/code&gt;设置允许接收最大请求包的大小。如果请求包大小超过设置的值，则返回 &lt;code&gt;413 Payload Too Large&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;请求包大小，单位为字节，默认值为5M&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;28&lt;/td&gt;
&lt;td&gt;ModifyRequestBody&lt;/td&gt;
&lt;td&gt;在转发请求之前修改原始请求体内容&lt;/td&gt;
&lt;td&gt;修改后的请求体内容&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;29&lt;/td&gt;
&lt;td&gt;ModifyResponseBody&lt;/td&gt;
&lt;td&gt;修改原始响应体的内容&lt;/td&gt;
&lt;td&gt;修改后的响应体内容&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;30&lt;/td&gt;
&lt;td&gt;Default&lt;/td&gt;
&lt;td&gt;为所有路由添加过滤器&lt;/td&gt;
&lt;td&gt;过滤器工厂名称及值&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;这里比较常用的如第25种，配置如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;spring:
  cloud:
    gateway:
          discovery:
          locator:
                enabled: true # 开启从注册中心动态创建路由的功能，利用微服务名称进行路由
      routes:
                  # 路由id，建议配合服务名
        - id: demo_route 
          #匹配路由名
          uri: lb://demo-provider 
          predicates:
                  # 断言，路径相匹配的进行路由
          - Path=/demo/** 
          filters:
          - StripPrefix=1
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一般情况下我们配合path路由使用，这里的意思是假如，我们的demo-provider服务种有一个/test的接口，实际上我们的请求路径经过网关时应该时/demo/test，这样就能把这个路由分发到demo-provider服务中，但是分发过去的路由是/demo/test，和我们实际的/test接口不一样。这时候我们用StripPrefix=1，来截取掉一级路由，这样转发过去的路由就是/test了。&lt;/p&gt;
&lt;h2 id=&quot;自定义网关过滤器&quot;&gt;自定义网关过滤器&lt;/h2&gt;
&lt;p&gt;除了上面提供的30种过滤器外，我们还可以实现自定义的过滤器。&lt;/p&gt;
&lt;h3 id=&quot;1-实现gatewayfilter接口和ordered接口&quot;&gt;1. 实现GatewayFilter接口和Ordered接口&lt;/h3&gt;
&lt;p&gt;gatewayFilter接口是为了实现请求过滤，ordered接口是为了给过滤器设定优先级，值越大级别越低。&lt;/p&gt;
&lt;p&gt;想要实现一个自定义的过滤器，无非就是两个步骤：&lt;strong&gt;1.实现过滤器，2.将过滤器添加到具体路由上。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class TokenGatewayFilter implements GatewayFilter, Ordered {
    @Override
    public Mono&amp;lt;Void&amp;gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) {

        System.out.println(&quot;这里处理自身逻辑&quot;);

        return chain.filter(exchange);
    }

    @Override
    public int getOrder() {
        return 0;
    }
}

@Configuration
class RouteConfiguration{

    @Bean
    public RouteLocator routeLocator(RouteLocatorBuilder builder){

        return builder.routes().route( r-&amp;gt;
                r.path(&quot;/demo/**&quot;)
                .uri(&quot;lb://demo-provider &quot;)
                .filter(new TokenGatewayFilter())
                .id(&quot;demo_route &quot;))
                .build();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;2继承abstractgatewayfilterfactory类&quot;&gt;2.继承AbstractGatewayFilterFactory类&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Component
public class TokenCheckGatewayFilterFactory extends AbstractGatewayFilterFactory&amp;lt;TokenCheckGatewayFilterFactory.Config&amp;gt; {
    public TokenCheckGatewayFilterFactory() {
        super(Config.class);
    }

    @Override
    public List&amp;lt;String&amp;gt; shortcutFieldOrder() {
        return Arrays.asList(&quot;enabled&quot;);
    }
    @Override
    public GatewayFilter apply(Config config) {
        return (exchange, chain) -&amp;gt; {
                system.out.println(&quot;这里处理自身逻辑&quot;)
            return chain.filter(exchange);
        };

    }

    public static class Config {
        // 控制是否开启认证
        private boolean enabled = true;

        public Config() {}

        public boolean isEnabled() {
            return enabled;
        }

        public void setEnabled(boolean enabled) {
            this.enabled = enabled;
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我们可以直接在application.yml中为需要过滤的路由添加这个过滤器。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;spring:
  cloud:
    gateway:
      routes:
        - id: demo_route # 路由id，建议配合服务名
          uri: lb://demo-provider #匹配路由名
          predicates:
          - Path=/demo/** # 断言，路径相匹配的进行路由
          filters:
          - TokenCheck=true
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;需要注意的是，这个地方自定义的过滤器名称必须是XXGatewayFilterFactory，并且配置文件中配置过滤器时名字必须时这个XX&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;当然，我们也可以为每个路由都添加这个过滤器，可以直接这样写配置，而不用在每个路由上都去写。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;spring:
  cloud:
    gateway:
      default-filters:
        - TokenCheck=true
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;3实现globalfilter和ordered&quot;&gt;3.实现GlobalFilter和ordered&lt;/h3&gt;
&lt;p&gt;这个GlobalFilter从名字中就可以看出，是一个全局过滤器，也就是说实现这个接口后，所有的请求都会被过滤，我们就不需要在去找往某个路由中加过滤器了。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Component
public class TokenGlobalFilter implements GlobalFilter, Ordered {
    @Override
    public Mono&amp;lt;Void&amp;gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        System.out.println(&quot;这里处理自身逻辑&quot;);
        return chain.filter(exchange);
    }

    @Override
    public int getOrder() {
        return 0;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上就是实现自定义网关过滤器的三种方式了。实际开发中根据需求来实现合适的过滤器就可以了。&lt;/p&gt;
</description>
<pubDate>Wed, 17 Jun 2020 00:43:00 +0000</pubDate>
<dc:creator>Java旅途</dc:creator>
<og:description>什么是网关 在微服务架构里，服务的粒度被进一步细分，各个业务服务可以被独立的设计、开发、测试、部署和管理。这时，各个独立部署单元可以用不同的开发测试团队维护，可以使用不同的编程语言和技术平台进行设计，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhixie/p/13150402.html</dc:identifier>
</item>
<item>
<title>HashSet扩容机制在时间和空间上的浪费，远大于你的想象 - 一线码农</title>
<link>http://www.cnblogs.com/huangxincheng/p/13150401.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huangxincheng/p/13150401.html</guid>
<description>&lt;h2 id=&quot;一：背景&quot;&gt;一：背景&lt;/h2&gt;
&lt;h3 id=&quot;1-讲故事&quot;&gt;1. 讲故事&lt;/h3&gt;
&lt;p&gt;自从这个纯内存项目进了大客户之后，搞得我现在对内存和CPU特别敏感，跑一点数据内存几个G的上下，特别没有安全感，总想用windbg抓几个dump看看到底是哪一块导致的，是我的代码还是同事的代码？ 很多看过我博客的老朋友总是留言让我出一套windbg的系列或者视频，我也不会呀，没办法，人在江湖飘，迟早得挨上几刀，逼着也得会几个花架子😄😄😄，废话不多说，这一篇就来看看 HashSet 是如何扩容的。&lt;/p&gt;
&lt;h2 id=&quot;二：hashset的扩容机制&quot;&gt;二：HashSet的扩容机制&lt;/h2&gt;
&lt;h3 id=&quot;1-如何查看&quot;&gt;1. 如何查看&lt;/h3&gt;
&lt;p&gt;了解如何扩容，最好的办法就是翻看HashSet底层源码，最粗暴的入口点就是 &lt;code&gt;HashSet.Add&lt;/code&gt; 方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://huangxincheng.oss-cn-hangzhou.aliyuncs.com/img/20200616222221.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从图中可以看到最后的初始化是用 &lt;code&gt;Initialize&lt;/code&gt; 的，而且里面有这么一句神奇的代码: &lt;code&gt;int prime = HashHelpers.GetPrime(capacity);&lt;/code&gt;，从字面意思看是获取一个质数，哈哈，有点意思，什么叫质数？ 简单说就是只能被 1 和 自身 整除的数就叫做质数，那好奇心就来了，一起看看质数是怎么算的吧！ 再次截图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://huangxincheng.oss-cn-hangzhou.aliyuncs.com/img/20200616223636.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从图中看，HashSet底层为了加速默认定义好了 72 个质数，最大的一个质数是 &lt;code&gt;719w&lt;/code&gt;，换句话就是说当元素个数大于 719w 的时候，就只能使用 &lt;code&gt;IsPrime&lt;/code&gt; 方法动态计算质数，如下代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;
public static bool IsPrime(int candidate)
{
        if ((candidate &amp;amp; 1) != 0)
        {
                int num = (int)Math.Sqrt(candidate);
                for (int i = 3; i &amp;lt;= num; i += 2)
                {
                        if (candidate % i == 0)
                        {
                                return false;
                        }
                }
                return true;
        }
        return candidate == 2;
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看完了整个流程，我想你应该明白了，当你第一次Add的时候，默认的空间占用是 72 个预定义中最小的一个质数 3，看过我之前文章的朋友知道List的默认大小是4，后面就是简单粗暴的 &lt;code&gt;* 2&lt;/code&gt; 处理，如下代码。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;
private void EnsureCapacity(int min)
{
        if (_items.Length &amp;lt; min)
        {
                int num = (_items.Length == 0) ? 4 : (_items.Length * 2);
        }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;2-hashset-二次扩容探究&quot;&gt;2. HashSet 二次扩容探究&lt;/h3&gt;
&lt;p&gt;当HashSet的个数达到3之后，很显然要进行二次扩容，这一点不像List用一个 &lt;code&gt;EnsureCapacity&lt;/code&gt; 方法搞定就可以了，然后细看一下怎么扩容。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://huangxincheng.oss-cn-hangzhou.aliyuncs.com/img/20200616225642.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;
public static int ExpandPrime(int oldSize)
{
        int num = 2 * oldSize;
        if ((uint)num &amp;gt; 2146435069u &amp;amp;&amp;amp; 2146435069 &amp;gt; oldSize)
        {
                return 2146435069;
        }
        return GetPrime(num);
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从图中可以看到，最后的扩容是在 &lt;code&gt;ExpandPrime&lt;/code&gt; 方法中完成的，流程就是先 &lt;code&gt;* 2&lt;/code&gt;， 再取最接近上限的一个质数，也就是 7 ，然后将 7 作为 HashSet 新的Size，如果你非要看演示，我就写一小段代码证明一下吧，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://huangxincheng.oss-cn-hangzhou.aliyuncs.com/img/20200616230347.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;2-您嗅出风险了吗？&quot;&gt;2. 您嗅出风险了吗？&lt;/h3&gt;
&lt;h4 id=&quot;1-时间上的风险&quot;&gt;&amp;lt;1&amp;gt; 时间上的风险&lt;/h4&gt;
&lt;p&gt;为了方便演示，我把 72 个预定义的最后几个质数显示出来。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;
public static readonly int[] primes = new int[72]
{
        2009191,
        2411033,
        2893249,
        3471899,
        4166287,
        4999559,
        5999471,
        7199369
};

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也就是说，当HashSet的元素个数为 &lt;code&gt;2893249&lt;/code&gt; 的时候触发扩容变成了 &lt;code&gt;2893249 * 2 =&amp;gt; 5786498&lt;/code&gt; 最接近的一个质数为：&lt;code&gt;5999471&lt;/code&gt;，也就是 &lt;code&gt;289w&lt;/code&gt; 暴增到了 &lt;code&gt;599w&lt;/code&gt;，一下子就是 &lt;code&gt;599w -289w = 310w&lt;/code&gt; 的空间虚占，这可是增加了两倍多哦，吓人不？ 下面写个代码验证下。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;
        static void Main(string[] args)
        {
            var hashSet = new HashSet&amp;lt;int&amp;gt;(Enumerable.Range(0, 2893249));

            hashSet.Add(int.MaxValue);

            Console.Read();
        }

0:000&amp;gt; !clrstack -l

000000B8F4DBE500 00007ffaf00132ae ConsoleApplication3.Program.Main(System.String[]) [C:\4\ConsoleApp1\ConsoleApp1\Program.cs @ 16]
    LOCALS:
        0x000000B8F4DBE538 = 0x0000020e0b8fcc08
0:000&amp;gt; !DumpObj /d 0000020e0b8fcc08
Name:        System.Collections.Generic.HashSet`1[[System.Int32, System.Private.CoreLib]]
Size:        64(0x40) bytes
File:        C:\Program Files\dotnet\shared\Microsoft.NETCore.App\5.0.0-preview.5.20278.1\System.Collections.dll
Fields:
              MT    Field   Offset                 Type VT     Attr            Value Name
00007ffaf0096d10  4000017        8       System.Int32[]  0 instance 0000020e2025e9f8 _buckets
00007ffaf00f7ad0  4000018       10 ...ivate.CoreLib]][]  0 instance 0000020e2bea1020 _slots
00007ffaeffdf828  4000019       28         System.Int32  1 instance          2893250 _count
0:000&amp;gt; !DumpObj /d 0000020e2025e9f8
Name:        System.Int32[]
Size:        23997908(0x16e2dd4) bytes
Array:       Rank 1, Number of elements 5999471, Type Int32 (Print Array)
Fields:
None


&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://huangxincheng.oss-cn-hangzhou.aliyuncs.com/img/20200617000133.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而且最重要的是，这里是一次性扩容的，&lt;span&gt;而非像redis中实现的那样渐进式扩容&lt;/span&gt;，时间开销也是大家值得注意的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://huangxincheng.oss-cn-hangzhou.aliyuncs.com/img/20200617074603.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;2-空间上的风险&quot;&gt;&amp;lt;2&amp;gt; 空间上的风险&lt;/h3&gt;
&lt;p&gt;这个有什么风险呢？可以看一下：289w 和 599w 两个HashSet的占用空间大小，这也是我最敏感的。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;
        static void Main(string[] args)
        {
            var hashSet1 = new HashSet&amp;lt;int&amp;gt;(Enumerable.Range(0, 2893249));

            var hashSet2 = new HashSet&amp;lt;int&amp;gt;(Enumerable.Range(0, 2893249));
            hashSet2.Add(int.MaxValue);

            Console.Read();
        }

0:000&amp;gt; !clrstack -l
OS Thread Id: 0x4a44 (0)
000000B1B4FEE460 00007ffaf00032ea ConsoleApplication3.Program.Main(System.String[]) [C:\4\ConsoleApp1\ConsoleApp1\Program.cs @ 18]
    LOCALS:
        0x000000B1B4FEE4B8 = 0x000001d13363cc08
        0x000000B1B4FEE4B0 = 0x000001d13363d648

0:000&amp;gt; !objsize 0x000001d13363cc08
sizeof(000001D13363CC08) = 46292104 (0x2c25c88) bytes (System.Collections.Generic.HashSet`1[[System.Int32, System.Private.CoreLib]])
0:000&amp;gt; !objsize 0x000001d13363d648
sizeof(000001D13363D648) = 95991656 (0x5b8b768) bytes (System.Collections.Generic.HashSet`1[[System.Int32, System.Private.CoreLib]])

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到， hashSet1的占用： &lt;code&gt;46292104 / 1024 / 1024 = 44.1M&lt;/code&gt;， hashSet2 的占用 : &lt;code&gt;95991656 / 1024 / 1024 = 91.5M&lt;/code&gt;,一下子就浪费了： &lt;code&gt;91.5 - 44.1 = 47.4M&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果你真以为仅仅浪费了 47.4M 的话，那你就大错特错了，不要忘了底层在扩容的时候，使用新的 size 覆盖了老的 size，而这个 老的 size 集合在GC还没有回收的时候会一直占用堆上空间的，这个能听得懂吗？ 如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://huangxincheng.oss-cn-hangzhou.aliyuncs.com/img/20200617001535.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;要验证的话可以用 windbg 去托管堆上抓一下 &lt;code&gt;Slot[] m_slots&lt;/code&gt; 和 &lt;code&gt;int[] m_buckets&lt;/code&gt; 两个数组，我把代码修改如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;
    static void Main(string[] args)
    {
        var hashSet2 = new HashSet&amp;lt;int&amp;gt;(Enumerable.Range(0, 2893249));
        hashSet2.Add(int.MaxValue);
        Console.Read();
    }


0:011&amp;gt; !dumpheap -stat
00007ffaf84f7ad0        3    123455868 System.Collections.Generic.HashSet`1+Slot[[System.Int32, System.Private.CoreLib]][]

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://huangxincheng.oss-cn-hangzhou.aliyuncs.com/img/20200617002748.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里就拿 &lt;code&gt;Slot[]&lt;/code&gt; 说事，从上面代码可以看到，托管堆上有三个 &lt;code&gt;Slot[]&lt;/code&gt; 数组，这就有意思了，怎么有三个哈，是不是有点懵逼，没关系，我们将三个 Slot[] 的地址找出来，一个一个看。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;
0:011&amp;gt; !DumpHeap /d -mt 00007ffaf84f7ad0
         Address               MT     Size
0000016c91308048 00007ffaf84f7ad0 16743180     
0000016c928524b0 00007ffaf84f7ad0 34719012     
0000016ce9e61020 00007ffaf84f7ad0 71993676  

0:011&amp;gt; !gcroot 0000016c91308048
Found 0 unique roots (run '!gcroot -all' to see all roots).
0:011&amp;gt; !gcroot 0000016c928524b0
Found 0 unique roots (run '!gcroot -all' to see all roots).
0:011&amp;gt; !gcroot 0000016ce9e61020
Thread 2b0c:
    0000006AFAB7E5F0 00007FFAF84132AE ConsoleApplication3.Program.Main(System.String[]) [C:\4\ConsoleApp1\ConsoleApp1\Program.cs @ 15]
        rbp-18: 0000006afab7e618
            -&amp;gt;  0000016C8000CC08 System.Collections.Generic.HashSet`1[[System.Int32, System.Private.CoreLib]]
            -&amp;gt;  0000016CE9E61020 System.Collections.Generic.HashSet`1+Slot[[System.Int32, System.Private.CoreLib]][]

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面可以看到，我通过 gcroot 去找这三个地址的引用根，有两个是没有的，最后一个有的自然就是新的 &lt;code&gt;599w&lt;/code&gt; 的size，对不对，接下来用 &lt;code&gt;!do&lt;/code&gt; 打出这三个地址的值。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;
0:011&amp;gt; !do 0000016c91308048
Name:        System.Collections.Generic.HashSet`1+Slot[[System.Int32, System.Private.CoreLib]][]
Size:        16743180(0xff7b0c) bytes
Array:       Rank 1, Number of elements 1395263, Type VALUETYPE (Print Array)
Fields:
None

0:011&amp;gt; !do 0000016c928524b0
Name:        System.Collections.Generic.HashSet`1+Slot[[System.Int32, System.Private.CoreLib]][]
Size:        34719012(0x211c524) bytes
Array:       Rank 1, Number of elements 2893249, Type VALUETYPE (Print Array)
Fields:
None

0:011&amp;gt; !do 0000016ce9e61020
Name:        System.Collections.Generic.HashSet`1+Slot[[System.Int32, System.Private.CoreLib]][]
Size:        71993676(0x44a894c) bytes
Array:       Rank 1, Number of elements 5999471, Type VALUETYPE (Print Array)
Fields:
None

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面的 &lt;code&gt;Rank 1, Number of elements&lt;/code&gt; 信息中可以看到，原来托管堆不仅有扩容前的Size ：&lt;code&gt;2893249&lt;/code&gt;，还有更前一次的扩容Size: &lt;code&gt;1395263&lt;/code&gt;，所以按这种情况算： 托管堆上的总大小近似为： &lt;code&gt;23.7M + 47.4M + 91.5M = 162.6M&lt;/code&gt;，我去，不简单把。。。 也就是说：托管堆上有 &lt;code&gt;162.6 - 91.5 =71.1M&lt;/code&gt; 的未回收垃圾 ➕ 刚才的 47.4M 的空间虚占用，总浪费为:&lt;code&gt;118.5M&lt;/code&gt;，但愿我没有算错。。。&lt;/p&gt;
&lt;h3 id=&quot;3-有解决方案吗？&quot;&gt;3. 有解决方案吗？&lt;/h3&gt;
&lt;p&gt;在List中大家可以通过 &lt;code&gt;Capacity&lt;/code&gt; 去控制List的Size，但是很遗憾，在 HashSet 中并没有类似的解决方案，只有一个很笨拙的裁剪方法: &lt;code&gt;TrimExcess&lt;/code&gt;，用于将当前Size扩展到最接近的 质数 值， 如下代码所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;
public void TrimExcess()
{
        int prime = HashHelpers.GetPrime(m_count);
        Slot[] array = new Slot[prime];
        int[] array2 = new int[prime];
        int num = 0;
        for (int i = 0; i &amp;lt; m_lastIndex; i++)
        {
                if (m_slots[i].hashCode &amp;gt;= 0)
                {
                        array[num] = m_slots[i];
                        int num2 = array[num].hashCode % prime;
                        array[num].next = array2[num2] - 1;
                        array2[num2] = num + 1;
                        num++;
                }
        }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;应用到本案例就是将 &lt;code&gt;289w&lt;/code&gt; 限制到 &lt;code&gt;347w&lt;/code&gt;，仍然有 &lt;code&gt;58w&lt;/code&gt;的空间占用。 如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://huangxincheng.oss-cn-hangzhou.aliyuncs.com/img/20200617004650.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;三：-总结&quot;&gt;三： 总结&lt;/h2&gt;
&lt;p&gt;HashSet的时间和空间上虚占远比你想象的大很多，而且实占也不小，因为底层用到了双数组 &lt;code&gt;m_slots&lt;/code&gt; 和 &lt;code&gt;m_buckets&lt;/code&gt;，每个Slot还有三个元素: &lt;code&gt;struct Slot { int hashCode;internal int next;internal T value; }&lt;/code&gt;，所以了解完原理之后谨慎着用吧。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;如您有更多问题与我互动，扫描下方进来吧&quot;&gt;如您有更多问题与我互动，扫描下方进来吧~&lt;/h3&gt;
&lt;hr/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/214741/202005/214741-20200522143723695-575216767.png&quot; width=&quot;600&quot; height=&quot;200&quot; alt=&quot;图片名称&quot; align=&quot;center&quot;/&gt;</description>
<pubDate>Wed, 17 Jun 2020 00:43:00 +0000</pubDate>
<dc:creator>一线码农</dc:creator>
<og:description>一：背景 1. 讲故事 自从这个纯内存项目进了大客户之后，搞得我现在对内存和CPU特别敏感，跑一点数据内存几个G的上下，特别没有安全感，总想用windbg抓几个dump看看到底是哪一块导致的，是我的代</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/huangxincheng/p/13150401.html</dc:identifier>
</item>
<item>
<title>深入理解 EF Core：EF Core 读取数据时发生了什么？ - LiamWang</title>
<link>http://www.cnblogs.com/willick/p/13150393.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/willick/p/13150393.html</guid>
<description>&lt;p&gt;阅读本文大概需要 11 分钟。&lt;/p&gt;
&lt;blockquote readability=&quot;6.4099616858238&quot;&gt;
&lt;p&gt;原文：&lt;a href=&quot;https://bit.ly/2UMiDLb&quot;&gt;https://bit.ly/2UMiDLb&lt;/a&gt;&lt;br/&gt;作者：Jon P Smith&lt;br/&gt;翻译：王亮&lt;br/&gt;声明：我翻译技术文章不是逐句翻译的，而是根据我自己的理解来表述的。其中可能会去除一些本人实在不知道如何组织但又不影响理解的句子。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文将为你详细描绘 EF Core 从数据库中读取数据的“幕后”视图。我将揭开两种数据库读取方式的面纱：一个是普通的查询，另一个是使用 AsNoTracking 方法的非跟踪查询。我还将通过一个实验来演示我是如何解决我的一个客户遇到的性能问题。&lt;/p&gt;
&lt;p&gt;我假设你对 EF Core 已经有了一定的认识，但在深入学习之前，我们先来了解一下如何使用 EF Core，以确保我们已经掌握了一些基本知识。这是一个“深入研究”的课题，所以我准备大量的技术细节，希望我的描述方式你能理解。&lt;/p&gt;
&lt;p&gt;本文是“深入理解 EF Core”系列中的第一篇。以下是本系列文章列表：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当 EF Core 从数据库读取数据时发生了什么？（本文）&lt;/li&gt;
&lt;li&gt;当 EF Core 写入数据到数据库时发生了什么？（敬请期待）&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;概要&quot;&gt;概要&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;EF Core 有两种方法从数据库中读取数据（也称为查询）：普通 LINQ 查询和包含 AsNoTracking 方法的非跟踪 LINQ 查询。&lt;/li&gt;
&lt;li&gt;这两种方法查询的返回类（被称为实体类），它连接的其它的实体类（即所谓的导航属性）也被同时加载，但这两种法如何连接及连接的内容是不一样的。&lt;/li&gt;
&lt;li&gt;普通查询接受的是 DbContext 执行读取时所有数据的副本——此时的实体类称为被跟踪。这允许加载的实体类参与数据库的更新操作。&lt;/li&gt;
&lt;li&gt;普通查询还会有一些其它的复杂底层实现，称为关系修补(fixup)，用于描述读入的实体类和其他被跟踪实体之间的连接关系。&lt;/li&gt;
&lt;li&gt;AsNoTracked 非跟踪查询没有副本，所以它没有被跟踪——这意味着它比普通查询更快。这也意味着它不会用于数据库的写操作。&lt;/li&gt;
&lt;li&gt;最后，我将展示 EF Core 普通查询中一个鲜为人知的特性，以此作为示例，说明通过导航属性连接实体类的关系是多么智能。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;ef-core-如何读取数据库数据&quot;&gt;EF Core 如何读取数据库数据&lt;/h2&gt;
&lt;p&gt;提示：如果你已经对 EF Core 有一定的认识，那么你可以跳过这一节，这部分只是一个如何读取数据库的例子。&lt;/p&gt;
&lt;p&gt;为了能让你更好地理解，我先描述一个数据库结构，然后再给出一个简单的数据库读取示例。下面是一些基本表的结构和它们之间的关系。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qn-tc.geekgist.com/202006/17085341&quot; alt=&quot; &quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这些表被映射到具有类似名称的类，例如 Book、BookAuthor、Author，这些类的属性名称与表的字段名称相同。由于篇幅有限，我不打算展开来讲这些类，但您可以在我的 GitHub 仓库&lt;sup&gt;[1]&lt;/sup&gt;中查看这些类。&lt;/p&gt;
&lt;p&gt;EF Core 读取数据库需要下面五部分：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;数据库服务器，如 SQL server, Sqlite, PostgreSQL 等。&lt;/li&gt;
&lt;li&gt;具有数据的数据库。&lt;/li&gt;
&lt;li&gt;映射到数据表的类（称为实体类）。&lt;/li&gt;
&lt;li&gt;一个继承 DbContext 的类，该类包含 EF Core 的配置。&lt;/li&gt;
&lt;li&gt;最后，从数据库读取数据的命令。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;下面的单元测试代码来自我的 GitHub 创库&lt;sup&gt;[2]&lt;/sup&gt;，展示了一个简单的示例，它从现有数据库中读取 4 个 Book 实体及其关联的 BookAuthor 和 Authors 实体。&lt;/p&gt;
&lt;p&gt;仓库地址：&lt;a href=&quot;https://bit.ly/2Yza7QQ&quot;&gt;https://bit.ly/2Yza7QQ&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;[Fact]
public void TestBookCountAuthorsOk()
{
    //SETUP
    var options = SqliteInMemory.CreateOptions&amp;lt;EfCoreContext&amp;gt;();
    //code to set up the database with four books, two with the same Author
    using (var context = new EfCoreContext(options))
    {
        //ATTEMPT
        var books = context.Books
            .Include(r =&amp;gt; r.AuthorsLink)
            .ThenInclude(r =&amp;gt; r.Author)
            .ToList();

        //VERIFY
        books.Count.ShouldEqual(4);
        books.SelectMany(x =&amp;gt; x.AuthorsLink.Select(y =&amp;gt; y.Author))
            .Distinct().Count().ShouldEqual(3);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在，如果我们将单元测试代码对应到上面的 5 部分，结果是这样的：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;数据库服务器&lt;/strong&gt;——第 5 行：我选择了一个 Sqlite 数据库服务器，在本例中是 &lt;code&gt;SqliteInMemory.CreateOptions&lt;/code&gt; 方法，它使用我的一个 NuGet 包 EfCore.TestSupport 创建了一个内存数据库（内存中的数据库对于单元测试非常有用，因为你可以为这个测试建立一个新的空数据库）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;具有数据的数据库&lt;/strong&gt;——第 6 行：我将在下一篇文章介绍数据是如何写入数据库的，现在假设有一个数据库包含 4 本书信息，其中两本书的作者是同一个人。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;实体类&lt;/strong&gt;——代码里这里没有展示，但是你可以在这里查看这些类&lt;sup&gt;[1]&lt;/sup&gt;。其中有一个 Books 实体类，通过一个名为 BookAuhor 的实体类多对多关联 Authors 实体类。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一个继承 DbContext 的类&lt;/strong&gt;——第 7 行：EfCoreContext 类继承了 DbContext 类并配置了从类到数据库的映射关系（你可以在我的 GitHub 仓库&lt;sup&gt;[3]&lt;/sup&gt; 中查看该类）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;从数据库读取数据的命令&lt;/strong&gt;——第 10 到 13 行，这是一个查询：
&lt;ul&gt;&lt;li&gt;第 10 行 — context 为 EfCoreContext 的实例，通过它访问你的数据库，&lt;code&gt;.Books&lt;/code&gt; 表示您希望访问 Books 表。&lt;/li&gt;
&lt;li&gt;第 11 行 — Include 被称为贪婪加载，它告诉 EF Core 当它加载 Books 时，也应该加载关联到的所有 BookAuthor 实体类。&lt;/li&gt;
&lt;li&gt;第 12 行 — ThenInclude 是继续贪婪加载，它告诉 EF Core 当它加载一个 BookAuthor 时，它也应该加载关联到该 BookAuthor 的 Author 实体类。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;所有这一切查询出来是一个结果集，其中有普通属性，像 Books 的 Title 属性；有关联实体类的导航属性，像 Books 的 AuthorsLink 属性。&lt;/p&gt;
&lt;p&gt;这个示例称为查询或读取，也是四种数据库访问类型之一，即 CRUD(新增、读取、更新和删除)。我将在下一篇文章中介绍新增和更新。&lt;/p&gt;
&lt;h2 id=&quot;ef-core-如何表示读取的数据&quot;&gt;EF Core 如何表示读取的数据&lt;/h2&gt;
&lt;p&gt;当你查询数据库时，EF Core 会将数据库返回的数据转换为实体类并填充导航属性的值。在本节中，我们将研究两种类型的查询步骤——普通查询(即没有 AsNoTracking 方法，也称为读写查询)和添加了 AsNoTracking 方法的非跟踪查询(称为只读查询)。&lt;/p&gt;
&lt;p&gt;我们先来看一下最初 LINQ 语句是如何转换成数据库相应的查询命令然后返回数据的。对于我们将要看到的两种类型的查询来说，这是很常见的操作。关于查询的第一部分，请参见下图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qn-tc.geekgist.com/202006/17085458&quot; alt=&quot; &quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有一些非常复杂的代码将你的 LINQ 转换为数据库查询命令，但这些内部细节我们不必关心。如果你的 LINQ 不能被翻译，你会从 EF Core 得到一个异常消息，其中包含类似“不能被翻译”的描述词语。此外，当数据返回时，像 Value Converters&lt;sup&gt;[4]&lt;/sup&gt; 这样的特性可能会调整数据。&lt;/p&gt;
&lt;p&gt;本节展示了查询的第一部分，其中 LINQ 被转换为数据库命令并返回所有正确的值。现在我们来看查询的第二部分，在这里 EF Core 获取返回值并将它们转换为实体类的实例，并填充导航属性。我们将分别看看两种类型的查询。&lt;/p&gt;
&lt;h3 id=&quot;1-普通查询读写查询&quot;&gt;1. 普通查询(读写查询)&lt;/h3&gt;
&lt;p&gt;普通查询读取数据的方式可以修改数据并更新到数据库，这就是我将其称为读写查询的原因。它不会自动更新数据(请参阅下一篇文章，了解如何写入数据库)。如果你要更新数据，你的查询必须是读写查询。&lt;/p&gt;
&lt;p&gt;我在介绍中给出的示例执行的是一个普通读写查询，读取带有 AuthorsLink 实例的示例。下面是该示例的查询部分的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;var books = context.Books
    .Include(r =&amp;gt; r.AuthorsLink)
    .ThenInclude(r =&amp;gt; r.Author)
    .ToList();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后 EF Core 通过三个步骤将这些值转换并填充含有导航属性的实体类。下图显示了这三个步骤以及生成的实体类及其导航属性的实体类。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qn-tc.geekgist.com/202006/17085508&quot; alt=&quot; &quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;让我们来分析一下这三个步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;创建类并填充数据&lt;/strong&gt;。它接受数据库返回的值，并填充非导航(称为标量)属性、字段等。在 Book 实体类中，是 BookId(主键)、Title 等属性——参见上图左下角浅蓝色矩形。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;修补关联关系&lt;/strong&gt;。首先是填入主键和外键的信息，它们定义如何相互关联数据。然后，EF Core 使用这些键设置实体类之间的导航属性(如图中蓝色粗线所示)。这个关系的修补所需的信息不仅是查询读入的实体类，它还会查看 DbContext 中跟踪的每个实体，并填充导航属性。这是一个强大的功能，但你的被跟踪实体越多，所需消耗时间也越多——这就是为什么需要 AsNoTracking 来实现更快的查询。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;创建跟踪快照&lt;/strong&gt;。跟踪快照是返回给用户的实体类的一个副本，加上它所隐藏的与每个实体类的关联关系——若一个实体处于被跟踪状态，这意味着它将会发生修改并会写入到数据库中。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;2-非跟踪查询只读查询&quot;&gt;2. 非跟踪查询(只读查询)&lt;/h3&gt;
&lt;p&gt;非跟踪查询，即使用 AsNoTracking 方法的查询，是一个只读查询。这意味着，当 SaveChanges 方法被调用时，你读取的任何内容都不会被写入数据库。非跟踪查询的查询效率更高，在下一节中，我将介绍非跟踪查询以及与普通查询的其他区别。&lt;/p&gt;
&lt;p&gt;在前文的示例之后，我修改了查询代码，添加了下面的 AsNoTracking 方法(请看第 2 行)：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;var books = context.Books
    .AsNoTracking()
    .Include(r =&amp;gt; r.AuthorsLink)
    .ThenInclude(r =&amp;gt; r.Author)
    .ToList();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的 LINQ 查询只有上面的普通查询的前两个步骤（没有第三个步骤）。下图显示了 AsNoTracking 查询的步骤。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qn-tc.geekgist.com/202006/17085532&quot; alt=&quot; &quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;步骤如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;创建类并填充数据&lt;/strong&gt;。它接受数据库返回的值，并填充非导航(称为标量)属性、字段等。在 Book 实体类中，是 BookId(主键)、Title 等属性——参见上图左下角浅蓝色矩形。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;修补关联关系&lt;/strong&gt;。首先是填入主键和外键的信息，它们定义如何相互关联数据。然后，EF Core 使用这些键设置实体类之间的导航属性(如图中蓝色粗线所示)。这个关系的修补所需的信息不仅是查询读入的实体类，它还会查看 DbContext 中跟踪的每个实体，并填充导航属性。这是一个强大的功能，但你的被跟踪实体越多，所需消耗时间也越多——这就是为什么需要 AsNoTracking 来实现更快的查询。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;普通查询和非跟踪查询的区别&quot;&gt;普通查询和非跟踪查询的区别&lt;/h3&gt;
&lt;p&gt;现在让我们比较这两种查询比较明显的区别。&lt;/p&gt;
&lt;ol readability=&quot;3&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;非跟踪查询查询的性能更好。使用非跟踪查询查询的主要原因是性能。非跟踪查询查询表现为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;稍微快一点，使用的内存稍微少一点，因为它不需要创建跟踪快照。&lt;/li&gt;
&lt;li&gt;避免没有必要的跟踪快照可以提高 SaveChanges 的性能，因为它不必检查跟踪快照以查找更改。&lt;/li&gt;
&lt;li&gt;稍微快一点，因为修补关联关系时没有所谓的身份解析。这就是为什么你会得到两个具有相同数据的 Author 实例。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;非跟踪查询修补关联关系时只链接查询中的实体。在普通查询中，我已经说过修补关联关系时连接的是查询中的实体和当前跟踪的实体，但是非跟踪查询只修补查询中的实体关系。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;非跟踪查询并不总是代表数据库关系。这两种类型查询之间的关系修补的另一个区别是，非跟踪查询关系修补更快，它不需要标识的解析。这可以为数据库中的同一行生成多个实例——见上图右下角蓝色的 Author 实体和注释。如果只是向用户显示数据，那么这种差异并不重要，但是如果具有业务逻辑，那么多个实例不能正确反映数据的结构，就可能会有问题。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;对层级数据有用的关系修补特性&quot;&gt;对层级数据有用的关系修补特性&lt;/h2&gt;
&lt;p&gt;关联关系修补的步骤是非常智能的，特别是在普通查询中。下面我想向你展示我是如何利用关系修补的特性来解决一个客户项目中的性能问题的。&lt;/p&gt;
&lt;p&gt;我曾在一家公司工作，那里的许多数据处理都是层次化结构的，即数据具有一系列深度不确定的关联关系。问题是我必须先解析整个层次结构，然后才能呈现这些数据。我最初是通过贪婪的方式加载前两个层级，然后显式地加载更深的层级来实现这一点的。它可以工作，但是性能非常慢，并且数据库因大量单数据库访问而超载。&lt;/p&gt;
&lt;p&gt;这不得不让我思考解决办法，如果普通查询的关系修补那么智能的话，它能帮助我提高查询的性能吗？它可以！让我给你举一个公司员工的例子。下图显示了我们想要加载的公司的层次结构。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qn-tc.geekgist.com/202006/17085549&quot; alt=&quot; &quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;你可以接龙式地使用 .Include(x =&amp;gt; x.WorksForMe).ThenInclude(x =&amp;gt; x.WorksForMe)… 等等来加载所需的层级信息，但结果是一个 .Include(x =&amp;gt; x.WorksForMe) 就够了。因为 EF Core 的关系修补为你做了剩下的事情，这一点很惊奇，但也很有用。&lt;/p&gt;
&lt;p&gt;例如，如果我想查询角色为 Development 的所有员工(每个员工都有一个名为 WhatTheyDo 的属性和名为 Role 的属性，该 Role 包含他们工作的部门)，我可以这样编写代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;var devDept = context.Employees
    .Include(x =&amp;gt; x.WorksFromMe)
    .Where(x =&amp;gt; x.WhatTheyDo.HasFlag(Roles.Development))
    .ToList();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这将创建一个查询，用于加载角色为 Development 的所有员工，并且在员工实体类上修补与 WorksFoMe 导航属性(集合)和 Manager 导航属性(单个)的关系。通过只执行一个查询，既提高了查询花费的时间，又减少了数据库服务器上的负载。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;你已经看到了两种类型的查询，我称之为 a)普通的读写查询，和 b) 非跟踪的只读查询。对于每一种查询类型，我都向你展示了 EF Core “幕后”是如何读取数据并展示的。他们工作方式的不同也表现出他们的优势和劣势。&lt;/p&gt;
&lt;p&gt;非跟踪查询是只读查询的解决方案，因为它比普通读写查询更快。但是您应该记住关系修补的机制，它可以在数据库只有一个关系的情况下创建类的多个实例。&lt;/p&gt;
&lt;p&gt;普通的读写查询是查询跟踪实体的解决方案，这意味着你可以在创建、更新和删除数据时使用它们。普通的读写查询确实会占用更多的时间和内存资源，但是有一些有用的特性，比如自动链接到其他被跟踪的实体类实例。&lt;/p&gt;
&lt;p&gt;我希望这篇文章对您有用。祝你编程快乐！&lt;/p&gt;
&lt;p&gt;[1]. &lt;a href=&quot;https://bit.ly/2MXK3ZY&quot;&gt;https://bit.ly/2MXK3ZY&lt;/a&gt;&lt;br/&gt;[2]. &lt;a href=&quot;https://bit.ly/2Yza7QQ&quot;&gt;https://bit.ly/2Yza7QQ&lt;/a&gt;&lt;br/&gt;[3]. &lt;a href=&quot;https://bit.ly/2Y0UORO&quot;&gt;https://bit.ly/2Y0UORO&lt;/a&gt;&lt;br/&gt;[4]. &lt;a href=&quot;https://bit.ly/2YEyg8j&quot;&gt;https://bit.ly/2YEyg8j&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 17 Jun 2020 00:39:00 +0000</pubDate>
<dc:creator>LiamWang</dc:creator>
<og:description>阅读本文大概需要 11 分钟。 原文：https://bit.ly/2UMiDLb 作者：Jon P Smith 翻译：王亮 声明：我翻译技术文章不是逐句翻译的，而是根据我自己的理解来表述的。其中可能</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/willick/p/13150393.html</dc:identifier>
</item>
<item>
<title>Nginx入门学习 - Johnson木木</title>
<link>http://www.cnblogs.com/Johnson-lin/p/13150368.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Johnson-lin/p/13150368.html</guid>
<description>&lt;p&gt;nginx 是HTTP和反向代理服务器，邮件代理服务器和通用TCP/UDP代理服务器。总之一句话，nginx很火很牛逼就对了。&lt;/p&gt;

&lt;p&gt;下载地址：&lt;a href=&quot;http://nginx.org/en/download.html&quot;&gt;http://nginx.org/en/download.html&lt;/a&gt;；&lt;br/&gt;mainline:最新版本&lt;br/&gt;stable:稳定版本&lt;br/&gt;下载命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;wget [下载地址]
tar -zxvf [压缩包]
&lt;/code&gt;
&lt;/pre&gt;

&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;auto：辅助configure文件的执行&lt;br/&gt;CHANGES：不同版本的特性&lt;br/&gt;conf：示例文件&lt;br/&gt;configure：用于生成中间文件，执行编译前的必须动作&lt;br/&gt;contrib：vim nginx文件时显示的样式，用法 cp contrib/vim/* ~/.vim/&lt;br/&gt;html:：nginx的默认html文件&lt;br/&gt;man：nginx的帮助文件&lt;br/&gt;src：nginx源代码&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;.&lt;code&gt;configure --xxx&lt;/code&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;--prefix=PATH nginx安装目录的前缀&lt;br/&gt;--with-xxx 默认不会编译进nginx，需要则写到命令行&lt;br/&gt;--without-xxx 默认编译进nginx，不需要则写到命令行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最普通的&lt;code&gt;configure&lt;/code&gt;编译命令为&lt;br/&gt;&lt;code&gt;.configure --prefix=/usr/local/nginx&lt;/code&gt;&lt;br/&gt;执行完命令则生成objs目录，存放中间文件，objs/ngx_modules.c 文件决定哪些模块安装到nginx。&lt;/p&gt;
&lt;p&gt;make编译：&lt;code&gt;make&lt;/code&gt;，执行完后生成大量的中间文件，都会存放到&lt;code&gt;objs/src&lt;/code&gt;目录中。&lt;br/&gt;安装：&lt;code&gt;make install&lt;/code&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;-c 指定配置文件&lt;br/&gt;-g 指定配置的指令&lt;br/&gt;-p 指定运行目录&lt;br/&gt;-s stop 立刻停止服务； quit 优雅的停止服务；reload 重载配置文件；reopen 重新开始记录日志文件&lt;br/&gt;-t 测试配置文件语法是否有错误&lt;br/&gt;-v 版本信息&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;重载配置文件&quot;&gt;重载配置文件&lt;/h2&gt;
&lt;p&gt;修改nginx配置文件的内容后，需要nginx重新加载配置文件&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;nginx -s reload
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;热部署&quot;&gt;热部署&lt;/h2&gt;
&lt;p&gt;nginx正在运行的时候，此时需要升级nginx版本。只需要更新nginx二进制文件。&lt;br/&gt;先备份旧的nginx：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;cp /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx.old
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用最新的nginx二进制文件 替换掉正在使用的nginx二进制文件。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;cp -r nginx /usr/local/nginx/sbin/ -f
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看正在运行的nginx的master进程&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;ps -ef | grep nginx
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;告诉正在运行nginx的master，需要进行nginx升级&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;kill -USR2 [正在运行的nginx master进程ID]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行完命令后会启动新的nginx进程，然后告知旧的nginx master进程，请优雅的关闭所有旧的worker进程&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;kill -WINCH [旧的nginx master进程ID]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后会发现旧的nginx worker进程已经全部关闭，发现master进程还在。如果新的nginx版本发生的错误，可以回退到旧的nginx master进程中，执行&lt;code&gt;nginx -s reload&lt;/code&gt;会回退到旧版本&lt;/p&gt;
&lt;h2 id=&quot;日志切割&quot;&gt;日志切割&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# 先把日志文件先备份
mv access.log access_bak.log

# 进行日志切割,执行完命令会重新生成access.log 文件
nginx -s reopen
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一般情况下会后台做一个bash脚本，定时进行日志切割。&lt;/p&gt;

&lt;p&gt;nginx 配置&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# 日志格式，main为日志格式命名
log_format  main  '$remote_addr - $remote_user [$time_local] &quot;$request&quot; '
                   '$status $body_bytes_sent &quot;$http_referer&quot; '
                   '&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;'; 
        
gzip on; # 对文件进行压缩传送
gzip_min_length 1; # 小于 1 字节则不进行压缩。
gzip_comp_level 2; # 压缩级别
gzip_types image/jpeg image/gif; # 对这些文件才进行压缩

server {
    listen 80; # 监听端口
    server_name localhost; # 域名
        
        # 记录access_log日志（每一个请求都会记录）, 使用main的log_format进行记录
        access_log /logs/blog.log main; 

    # url匹配的路径
    location / { 
            alias  code/; # 指 nginx的安装目录下 eg：/usr/local/nginx/code
            # autoindex on; # 共享静态资源
            # set $limit_rate 10k; # nginx每秒传输 10k字节 到浏览器当中
    }
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;可以建立多个上游服务，当有请求进来的时候，nginx可以根据负载均衡算法代理给多台上游服务器工作。nginx配置&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# 上游服务
# local 为上游服务器名
upstream local {
     # 其中一台上游服务器，可以配置多台
         # 127.0.0.1:8080 代表只有本机能访问8080端口
    server 127.0.0.1:8080; 
}

# 反向代理缓存    缓存路径                   内存关键字，10m
proxy_cache_path /tmp/nginxcache levels=1:2 keys_zone=my_cache:10m max_size=10g;
inactive=60m use_temp_path=off;

server {
        listen 80;
    server_name colablog.cn; # 域名
        
        # 记录access_log日志（每一个请求都会记录）, 使用main的log_format进行记录
        access_log /logs/blog.log main; 

    # url匹配的路径
    location / { 
            # doc http://nginx.org/en/docs/http/ngx_http_proxy_module.html
            # proxy_set_header 反向代理服务器把客户端请求的信息，设置到请求头中发送到上游服务
            proxy_set_header Host $host; # 域名
                proxy_set_header X-Real-IP $remote_addr; # 客户端地址
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                
                # 使用哪个缓存，对应上面的keys_zone
                proxy_cache my_cache;
                # 缓存的路径
                proxy_cache_key $hots$uri$is_args$args;
                # 对于这些响应不缓存
                proxy_cache_valid 200 304 302 1d;
        
            # 代理到上游服务
            proxy_pass http://local;
    }
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;安装-2&quot;&gt;安装&lt;/h2&gt;
&lt;p&gt;你可以快速使用 &lt;code&gt;apt install&lt;/code&gt;或者 &lt;code&gt;yum install&lt;/code&gt;，也可以在&lt;a href=&quot;https://www.goaccess.cc/?mod=download&quot;&gt;官网&lt;/a&gt;中查看编译安装的方式。&lt;br/&gt;运行goaccess命令&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# goaccess /usr/local/nginx/logs/access.log -o /usr/local/nginx/html/report.html --real-time-html --time=format='%H:%M:%S' --date-format='%d/%b/%Y' --log-format=COMBINED
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;--real-time-html 代表实时更新页面&lt;/p&gt;
&lt;p&gt;nginx.conf配置文件&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;    # 日志格式
    log_format  main  '$remote_addr - $remote_user [$time_local] &quot;$request&quot; '
                  '$status $body_bytes_sent &quot;$http_referer&quot; '
                  '&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;';

    server {
        listen 80;
        server_name: localhost;
        # 日志记录
        access_log logs/access.log main;
        
        # 指定页面
        location /report.html {
            alias /usr/local/nginx/html/report.html;
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后访问 &lt;code&gt;http://localhost/report.html&lt;/code&gt;，就可以看到下面这么高大上的界面了。&lt;br/&gt;&lt;img src=&quot;http://qiniublog.colablog.cn/5165b755-ee18-46e1-9556-227cae5459b7.jpg&quot; alt=&quot;nginxaccesslog.jpg&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;如果你有域名的话，只需要两行命令可以快速把你的 &lt;a href=&quot;http://xn--eqrt2g&quot;&gt;http://域名&lt;/a&gt; 变成 &lt;a href=&quot;https://xn--eqrt2g&quot;&gt;https://域名&lt;/a&gt;。&lt;br/&gt;ubuntu版本下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;apt install python-certbot-nginx
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;centos版本下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;yum install python2-certbot-nginx
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用&lt;code&gt;certbot&lt;/code&gt;命令帮我们下载证书和自动配置好nginx.conf，&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;certbot --nginx --nginx-server-root=/usr/local/nginx/conf/ -d [你的域名]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行了上面的命令后会有两个选项，第一个选项是可以访问http或者https，不会进行重定向；而第二个选项则是访问http的时候重定向到https中。&lt;br/&gt;就这样就搞定了，是不是很简单。&lt;/p&gt;

&lt;p&gt;Nginx初次入门的小白，文章若有错误的地方，请用力的指出。&lt;/p&gt;
&lt;p&gt;参考文章：&lt;a href=&quot;https://time.geekbang.org/course/intro/100020301&quot;&gt;极客时间：Nginx核心知识100讲&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;2.6190476190476&quot;&gt;
&lt;p&gt;个人博客网址： &lt;a href=&quot;https://colablog.cn/&quot;&gt;https://colablog.cn/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果我的文章帮助到您，可以关注我的微信公众号，第一时间分享文章给您&lt;br/&gt;&lt;img src=&quot;http://qiniuyun.colablog.cn/%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg&quot; alt=&quot;微信公众号&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 17 Jun 2020 00:21:00 +0000</pubDate>
<dc:creator>Johnson木木</dc:creator>
<og:description>简介 nginx 是HTTP和反向代理服务器，邮件代理服务器和通用TCP/UDP代理服务器。总之一句话，nginx很火很牛逼就对了。 download 下载地址：http://nginx.org/en</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Johnson-lin/p/13150368.html</dc:identifier>
</item>
<item>
<title>.Net Core微服务入门全纪录（四）——Ocelot-API网关（上） - xhznl</title>
<link>http://www.cnblogs.com/xhznl/p/13092535.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xhznl/p/13092535.html</guid>
<description>&lt;p&gt;上一篇【&lt;a href=&quot;https://www.cnblogs.com/xhznl/p/13096891.html&quot;&gt;.Net Core微服务入门全纪录（三）——Consul-服务注册与发现（下）&lt;/a&gt;】已经使用Consul完成了服务的注册与发现，实际中光有服务注册与发现往往是不够的，我们需要一个统一的入口来连接客户端与服务。&lt;/p&gt;

&lt;p&gt;官网：&lt;a href=&quot;https://ocelot.readthedocs.io/&quot;&gt;https://ocelot.readthedocs.io/&lt;/a&gt;&lt;br/&gt;Ocelot正是为.Net微服务体系提供一个统一的入口点，称为：Gateway（网关）。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;上手Ocelot：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;首先创建一个空的asp.net core web项目。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202006/610959-20200614170112051-1111424782.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;注意ocelot.json是我们添加的Ocelot的配置文件，记得设置生成时复制到输出目录。ocelot.json的文件名不是固定的，可以自己定义。&lt;/p&gt;
&lt;p&gt;NuGet安装一下Ocelot：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202006/610959-20200614165355576-719151292.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;只需简单的修改几处默认代码：&lt;br/&gt;Program.cs：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public class Program
    {
        public static void Main(string[] args)
        {
            CreateHostBuilder(args).Build().Run();
        }

        public static IHostBuilder CreateHostBuilder(string[] args) =&amp;gt;
            Host.CreateDefaultBuilder(args)
                .ConfigureAppConfiguration((hostingContext, config) =&amp;gt;
                {
                    config.AddJsonFile(&quot;ocelot.json&quot;);
                })
                .ConfigureWebHostDefaults(webBuilder =&amp;gt;
                {
                    webBuilder.UseStartup&amp;lt;Startup&amp;gt;();
                });
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Startup.cs：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public class Startup
    {
        // This method gets called by the runtime. Use this method to add services to the container.
        // For more information on how to configure your application, visit https://go.microsoft.com/fwlink/?LinkID=398940
        public void ConfigureServices(IServiceCollection services)
        {
            //添加ocelot服务
            services.AddOcelot();
        }

        // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.
        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
        {
            //设置Ocelot中间件
            app.UseOcelot().Wait();
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ocelot.json：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
  &quot;Routes&quot;: [
    {
      &quot;DownstreamPathTemplate&quot;: &quot;/products&quot;,
      &quot;DownstreamScheme&quot;: &quot;http&quot;,
      &quot;DownstreamHostAndPorts&quot;: [
        {
          &quot;Host&quot;: &quot;localhost&quot;,
          &quot;Port&quot;: 9050
        },
        {
          &quot;Host&quot;: &quot;localhost&quot;,
          &quot;Port&quot;: 9051
        },
        {
          &quot;Host&quot;: &quot;localhost&quot;,
          &quot;Port&quot;: 9052
        }
      ],
      &quot;UpstreamPathTemplate&quot;: &quot;/products&quot;,
      &quot;UpstreamHttpMethod&quot;: [
        &quot;Get&quot;
      ],
      &quot;LoadBalancerOptions&quot;: {
        &quot;Type&quot;: &quot;RoundRobin&quot; //负载均衡，轮询机制 LeastConnection/RoundRobin/NoLoadBalancer/CookieStickySessions
      }
    },
    {
      &quot;DownstreamPathTemplate&quot;: &quot;/orders&quot;,
      &quot;DownstreamScheme&quot;: &quot;http&quot;,
      &quot;DownstreamHostAndPorts&quot;: [
        {
          &quot;Host&quot;: &quot;localhost&quot;,
          &quot;Port&quot;: 9060
        },
        {
          &quot;Host&quot;: &quot;localhost&quot;,
          &quot;Port&quot;: 9061
        },
        {
          &quot;Host&quot;: &quot;localhost&quot;,
          &quot;Port&quot;: 9062
        }
      ],
      &quot;UpstreamPathTemplate&quot;: &quot;/orders&quot;,
      &quot;UpstreamHttpMethod&quot;: [
        &quot;Get&quot;
      ],
      &quot;LoadBalancerOptions&quot;: {
        &quot;Type&quot;: &quot;RoundRobin&quot; //负载均衡，轮询机制 LeastConnection/RoundRobin/NoLoadBalancer/CookieStickySessions
      }
    }
  ],
  &quot;GlobalConfiguration&quot;: {
    &quot;BaseUrl&quot;: &quot;http://localhost:9070&quot;
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们先暂时忽略Consul，将服务实例的地址都写在配置文件中。要知道Consul、Ocelot等组件都是可以独立存在的。&lt;br/&gt;配置文件中的Routes节点用来配置路由，Downstream代表下游，也就是服务实例，Upstream代表上游，也就是客户端。我们的路径比较简单，只有/products、/orders，路径中如果有不固定参数则使用{}匹配。我们这个配置的意思呢就是客户端访问网关的/orders、/products，网关会转发给服务实例的/orders、/products，注意这个上游的路径不一定要和下游一致，比如上游路径可以配置成/api/orders，/xxx都可以。&lt;br/&gt;LoadBalancerOptions节点用来配置负载均衡，Ocelot内置了 LeastConnection、RoundRobin、NoLoadBalancer、CookieStickySessions 4种负载均衡策略。&lt;br/&gt;BaseUrl节点就是配置我们ocelot网关将要运行的地址。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;运行gateway：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;目前不考虑网关集群，就不放在docker里了。直接控制台执行：`dotnet Ocelot.APIGateway.dll --urls=&quot;http://*:9070&quot;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202006/610959-20200614184332541-1501130617.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;用浏览器测试一下：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202006/610959-20200614184855090-549409108.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202006/610959-20200614185019340-1915263540.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;测试正常，我们通过网关可以正常的访问到服务实例。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;接下来继续改造客户端代码：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202006/610959-20200614185314359-771408665.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;因为改动太多就直接新建一个GatewayServiceHelper来做。&lt;br/&gt;GatewayServiceHelper：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    /// &amp;lt;summary&amp;gt;
    /// 通过gateway调用服务
    /// &amp;lt;/summary&amp;gt;
    public class GatewayServiceHelper : IServiceHelper
    {
        public async Task&amp;lt;string&amp;gt; GetOrder()
        {
            var Client = new RestClient(&quot;http://localhost:9070&quot;);
            var request = new RestRequest(&quot;/orders&quot;, Method.GET);

            var response = await Client.ExecuteAsync(request);
            return response.Content;
        }

        public async Task&amp;lt;string&amp;gt; GetProduct()
        {
            var Client = new RestClient(&quot;http://localhost:9070&quot;);
            var request = new RestRequest(&quot;/products&quot;, Method.GET);

            var response = await Client.ExecuteAsync(request);
            return response.Content;
        }

        public void GetServices()
        {
            throw new NotImplementedException();
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在Startup中修改一下注入的类型，别的就不用改了，这就是依赖注入的好处之一。。。&lt;br/&gt;Startup.ConfigureServices()：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//注入IServiceHelper
//services.AddSingleton&amp;lt;IServiceHelper, ServiceHelper&amp;gt;();
            
//注入IServiceHelper
services.AddSingleton&amp;lt;IServiceHelper, GatewayServiceHelper&amp;gt;();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Startup.Configure()：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//程序启动时 获取服务列表
//serviceHelper.GetServices();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行客户端测试：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202006/610959-20200614190357965-1065989945.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好了，现在客户端对服务的调用都通过网关进行中转，客户端再也不用去关心那一堆服务实例的地址，只需要知道网关地址就可以了。另外，服务端也避免了服务地址直接暴露给客户端。这样做对客户端，服务都非常友好。&lt;/p&gt;
&lt;p&gt;至于我们的api网关呢，又要说到服务发现的问题了。目前我们的服务地址是写在ocelot.json配置文件里的，当然这种做法在服务实例不经常变化的情况下是没有问题的，一旦服务变化，需要人为的修改配置文件，这又显得不太合理了。&lt;/p&gt;
&lt;p&gt;当然，强大的Ocelot为我们提供了服务发现的方案。&lt;/p&gt;
&lt;p&gt;代码放在：&lt;a href=&quot;https://github.com/xiajingren/NetCoreMicroserviceDemo&quot;&gt;https://github.com/xiajingren/NetCoreMicroserviceDemo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;未完待续...&lt;/p&gt;
</description>
<pubDate>Wed, 17 Jun 2020 00:17:00 +0000</pubDate>
<dc:creator>xhznl</dc:creator>
<og:description>前言 上一篇【.Net Core微服务入门全纪录（三）——Consul-服务注册与发现（下）】已经使用Consul完成了服务的注册与发现，实际中光有服务注册与发现往往是不够的，我们需要一个统一的入口来</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xhznl/p/13092535.html</dc:identifier>
</item>
<item>
<title>java并发编程 --并发问题的根源及主要解决方法 - zzzzMing</title>
<link>http://www.cnblogs.com/listenfwind/p/13149718.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/listenfwind/p/13149718.html</guid>
<description>&lt;p&gt;首先，我们要知道并发要解决的是什么问题？并发要解决的是单进程情况下硬件资源无法充分利用的问题。而造成这一问题的主要原因是CPU-内存-磁盘三者之间速度差异实在太大。如果将CPU的速度比作火箭的速度，那么内存的速度就像火车，而最惨的磁盘，基本上就相当于人双腿走路。&lt;/p&gt;
&lt;p&gt;这样造成的一个问题，就是CPU快速执行完它的任务的时候，很长时间都会在等待磁盘或是内存的读写。&lt;/p&gt;
&lt;p&gt;计算机的发展有一部分就是如何重复利用资源，解决硬件资源之间效率的不平衡，而后就有了多进程，多线程的发展。并且演化出了各种为多进程（线程）服务的东西：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;CPU增加缓存机制，平衡与内存的速度差异&lt;/li&gt;
&lt;li&gt;增加了多个概念，CPU时间片，程序计数器，线程切换等，用以更好得服务并发场景&lt;/li&gt;
&lt;li&gt;编译器的指令优化，希望在&lt;strong&gt;内部&lt;/strong&gt;充分利用硬件资源&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;但是这样一来，也会带来新的并发问题，归结起来主要有三个。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;由于缓存导致的可见性问题&lt;/li&gt;
&lt;li&gt;线程切换带来的原子性问题&lt;/li&gt;
&lt;li&gt;编译器优化带来的有序性问题&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们分别介绍这几个：&lt;/p&gt;
&lt;h3 id=&quot;缓存导致的可见性&quot;&gt;缓存导致的可见性&lt;/h3&gt;
&lt;p&gt;CPU为了平衡与内存之间的性能差异，引入了CPU缓存，这样CPU执行指令修改数据的时候就可以批量直接读写CPU缓存的内存，一个阶段后再将数据写回到内存。&lt;/p&gt;
&lt;p&gt;但由于现在多核CPU技术的发展，各个线程可能运行在不同CPU核上面，每个CPU核各有各自的CPU缓存。前面说到对变量的修改通常都会先写入CPU缓存，再写回内存。这就会出现这样一种情况，线程1修改了变量A，但此时修改后的变量A只存储在CPU缓存中。这时候线程B去内存中读取变量A，依旧只读取到旧的值，这就是可见性问题。&lt;/p&gt;
&lt;h3 id=&quot;线程切换带来的原子性&quot;&gt;线程切换带来的原子性&lt;/h3&gt;
&lt;p&gt;为了更充分得利用CPU，引入了CPU时间片时间片的概念。进程或线程通过争用CPU时间片，让CPU可以更加充分得利用。&lt;/p&gt;
&lt;p&gt;比如在进行读写磁盘等耗时高的任务时，就可以将宝贵的CPU资源让出来让其他线程去获取CPU并执行任务。&lt;/p&gt;
&lt;p&gt;但这样的切换也会导致问题，那就是会破坏线程某些任务的原子性。比如java中简单的一条语句count += 1。&lt;/p&gt;
&lt;p&gt;映射到CPU指令有三条，读取count变量指令，变量加1指令，变量写回指令。虽然在高级语言（java）看来它就是一条指令，但实际上确是三条CPU指令，并且这三条指令的原子性无法保证。也就是说，可能在执行到任意一条指令的时候被打断，CPU被其他线程抢占了。而这个期间变量值可能会被修改，这里就会引发数据不一致的情况了。所以高并发场景下，很多时候都会通过锁实现原子性。而这个问题也是很多并发问题的源头。&lt;/p&gt;
&lt;h3 id=&quot;编译器优化带来的有序性&quot;&gt;编译器优化带来的有序性&lt;/h3&gt;
&lt;p&gt;因为现在程序员编写的都是高级语言，编译器需要将用户的代码转成CPU可以执行的指令。&lt;/p&gt;
&lt;p&gt;同时，由于计算机领域的不断发展，编译器也越来越智能，它会自动对程序员编写的代码进行优化，而优化中就有可能出现实际执行代码顺序和编写的代码顺序不一样的情况。&lt;/p&gt;
&lt;p&gt;而这种破坏程序有序性的行为，在有些时候会出现一些非常微妙且难以察觉的并发编程bug。&lt;/p&gt;
&lt;p&gt;举个简单的例子，我们常见的单例模式是这样的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Singleton {
 
 private Singleton() {}

 private static Singleton sInstance;

 public static Singleton getInstance() {

    if (sInstance == null) {    //第一次验证是否为null
      synchronized (Singleton.class) {   //加锁
        if (sInstance == null) {          //第二次验证是否为null
          sInstance = new Singleton();  //创建对象
                 }
             }
         }
    return sInstance;
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;即通过两段判断加锁来保证单例的成功生成，但在极小的概率下，可能会出现异常情况。原因就出现在&lt;strong&gt;sInstance = new Singleton()&lt;/strong&gt;;这一行代码上。这行代码，我们理解的执行顺序应该是这样：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;为Singleton象分配一个内存空间。&lt;/li&gt;
&lt;li&gt;在分配的内存空间实例化对象。&lt;/li&gt;
&lt;li&gt;把Instance 引用地址指向内存空间。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;但在实际编译的过程中，编译器有可能会帮我们进行优化，优化完它的顺序可能变成如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;为Singleton对象分配一个内存空间。&lt;/li&gt;
&lt;li&gt;把instance 引用地址指向内存空间。&lt;/li&gt;
&lt;li&gt;在分配的内存空间实例化对象。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;按照优化完的顺序，当并发访问的时候，可能会出现这样的情况&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;A线程进入方法进行第1次instance == null判断。&lt;/li&gt;
&lt;li&gt;此时A线程发现instance 为null 所以对Singleton.class加锁。&lt;/li&gt;
&lt;li&gt;然后A线程进入方法进行第2次instance == null判断。&lt;/li&gt;
&lt;li&gt;然后A线程发现instance 为null，开始进行对象实例化。&lt;/li&gt;
&lt;li&gt;为对象分配一个内存空间。&lt;br/&gt;6.把Instance 引用地址指向内存空间（而就在这个指令完成后，线程B进入了方法）。&lt;/li&gt;
&lt;li&gt;B线程首先进入方法进行第1次instance == null判断。&lt;/li&gt;
&lt;li&gt;B线程此时发现instance 不为null ，所以它会直接返回instance (而此时返回的instance 是A线程还没有初始化完成的对象)&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;最终线程B拿到的instance 是一个没有实例化对象的空内存地址，所以导致instance使用的过程中造成程序错误。解决办法很简单，可以给sInstance对象加上一个关键字，volatile，这样编译器就不会乱优化，有关volatile的具体内容后续再细说。&lt;/p&gt;

&lt;p&gt;通过上面的介绍，其实可以归纳无论是CPU缓存，线程切换还是编译器优化乱序，出现问题的核心都是因为多个线程要并发读写某个变量或并发执行某段代码。那么我们可以控制，一次只让一个线程执行变量读写就可以了，这就是&lt;strong&gt;互斥&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;而在某些时候，互斥还不够，还需要一定的条件。比如一个生产者一个消费者并发，生产者向队列存东西，消费者向队列拿东西。那么生产者写的时候要保证存的时候队列不是满的，消费者要保证拿的时候队列非空。这种线程与线程间需要通信协作的情况，称为&lt;strong&gt;同步&lt;/strong&gt;，&lt;strong&gt;同步可以说是更复杂的互斥&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;既然知道了并发编程的根源以及同步和互斥，那我们来看看有哪些解决的思路。其实一共也就三种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;避免共享&lt;/li&gt;
&lt;li&gt;Immutability（不变性）&lt;/li&gt;
&lt;li&gt;管程及其他工具&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面我们分别说说这三种方案的优缺点&lt;/p&gt;
&lt;h3 id=&quot;避免共享&quot;&gt;避免共享&lt;/h3&gt;
&lt;p&gt;我们先来说说避免共享，其实避免共享说是线程本地存储技术，在java中指的一般就是Threadlocal。ThreadLocal会为每个线程提供一个本地副本，每个线程都只会修改自己的ThreadLocal变量。这样一来就不会出现共享变量，也就不会出现冲突了。&lt;/p&gt;
&lt;p&gt;其实现原理是在ThreadLocal内部维护一个ThreadLocalMap，每次有线程要获取对应变量的时候，先获取当前线程，然后根据不同线程取不同的值，典型的以空间换时间。&lt;/p&gt;
&lt;p&gt;所以ThreadLocal还是比较适用于需要共享资源，且资源占用空间不大的情况。比如一些连接的session啊等等。但是这种模式应用场景也较为有限，比如需要同步情况就难以胜任。&lt;/p&gt;
&lt;h3 id=&quot;immutability（不变性）&quot;&gt;Immutability（不变性）&lt;/h3&gt;
&lt;p&gt;Immutability在函数式中用得比较多，函数式编程的一个主要目的是要写出无副作用的代码，有关什么是无副作用可以参考我以前的文章&lt;a href=&quot;https://www.cnblogs.com/listenfwind/p/11209383.html&quot;&gt;Scala函数式编程指南（一） 函数式思想介绍&lt;/a&gt;。而无副作用的一个主要特点就是变量都是Immutability即不可变的，即创建对象后不会再修改对象，比如scala默认的变量和数据结构都是不可变的。而在java中，不变性变量即通过final修饰的变量，如String，Long，Double等类型都是Immutability的，它们的内部实现都是基于final关键字的。&lt;/p&gt;
&lt;p&gt;那这又和并发编程有什么关系呢？其实啊，并发问题很大部分原因就是因为线程切换破坏了原子性，这又导致线程随意对变量的读写破坏了数据的一致性。而不变性就不必担心这个问题，因为变量都是不变，不可写只能读的。在这种编程模式下，你要修改一个变量，那么只能新生成一个。这样做的好处很明显，但坏处也是显而易见，那就是引入了额外的编程复杂度，丧失了代码的可读性和易用性。&lt;/p&gt;
&lt;p&gt;因为如此，不变性的并发解决方案其实相对而已没那么广泛，其中比较有代表性的算是Actor并发编程模型，我以前也有讨论过，有兴趣可以看看&lt;a href=&quot;https://www.cnblogs.com/listenfwind/p/9963489.html&quot;&gt;Actor模型浅析 一致性和隔离性&lt;/a&gt;，这种编程模型和常规并发解决方案有很显著的差异。按我的了解，Acctor模式多用在分布式系统的一些协调功能，比如维持集群中多个机器的心跳通信等等。如果在单机并发环境下，还是下面要介绍的管程类工具才是利器。&lt;/p&gt;
&lt;h3 id=&quot;管程及其他工具&quot;&gt;管程及其他工具&lt;/h3&gt;
&lt;p&gt;其实最早的操作系统中，解决并发问题用的是信号量，信号量通过两个原子操作wait(S)，和signal(S)（俗称P，V操作）来实现访问资源互斥和同步。比如下面这个小例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//整型信号量定义
int S;

//P操作
wait(S){
  while(S&amp;lt;=0);
  S--;
}

//V操作
signal(S){
  S++;
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;虽然信号量方便有效，但信号量要对每个共享资源都实现对应的P和V操作，这使得并发编程中可能要出现大量的P，V操作，并且这部分内容难以抽象出来。&lt;/p&gt;
&lt;p&gt;为了更好地实现同步互斥，于是就产生了管程（即Monitor，也有翻译为监视器），值得一提的是，管程也有几种模型，分别是：Hasen模型，Hoare模型和MESA模型。其中MESA模型应用最广泛，java也是参考自MESA模型。这里简单介绍下管程的理论知识，这部分内容参考自&lt;a href=&quot;https://blog.csdn.net/qq_34666857/article/details/102948786&quot;&gt;进程同步机制-----为进程并发执行保驾护航&lt;/a&gt;，希望了解更多管程理论知识的童鞋可以看看。&lt;/p&gt;
&lt;p&gt;我们来通过一个经典的生产-消费队列来解释，如下图&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1011838/202004/1011838-20200427155319999-1253618940.jpg&quot; alt=&quot;管程介绍&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们先解释下图中右半部分的内容，右上角有一个等待调用的线程队列，管程中每次只能有一个线程在执行任务，所以多个任务需要等待。然后是各个名词的意思，生产-消费需要往队列写入和取出东西，&lt;strong&gt;这里的队列就是共享变量&lt;/strong&gt;，&lt;strong&gt;对共享资源进行操作称之为过程（入队和出队两个过程）&lt;/strong&gt;。而向队列写入和取出是有条件的，写入的时候队列必须是非满的，取出的时候队列必须是非空的，&lt;strong&gt;这两个条件被称为条件变量&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;然后再来看看左半部分的内容，假设线程T1读取共享变量（即队列），此时发现队列为空（条件变量之一），那么T1此时需要等待，去哪里等呢？去条件变量&lt;strong&gt;队列不能为空&lt;/strong&gt;对应的队列中去等待。此时另一个线程T2向共享变量队列写数据，通过了条件变量&lt;strong&gt;队列不能满&lt;/strong&gt;，那么写完后就会通知线程T1。但因为管程的限制，管程中只能有一个线程在执行，所以T1线程不能立即执行，它会回到右上角的线程等待队列等待（不同的管程模型在这里是有分歧的，比如Hasen模型是立即中断T2线程让队列中下一个线程执行）。&lt;/p&gt;
&lt;p&gt;解释完这个图，管程的概念也就呼之欲出了，&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;hansen对管程的定义如下：一个管程定义了一个数据结构和能力为并发进程所执行（在该数据结构上）的一组操作，这组操作能同步进程和改变管程中的数据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本质上，管程是对共享资源以及对共享资源的操作抽象成变量和方法，要操作共享变量仅能通过管程提供的方法（比如上面的入队和出队）间接访问。所以你会发现管程其实和面向对象的理念是十分相近的，在java中，主要提供了低层次了synchronized关键字和wait()，notify()等方法。同时还提供了高层次的ReenTrantLock和Condition来实现管程模型。&lt;/p&gt;
&lt;p&gt;以上~&lt;/p&gt;
</description>
<pubDate>Wed, 17 Jun 2020 00:15:00 +0000</pubDate>
<dc:creator>zzzzMing</dc:creator>
<og:description>并发问题的根源在哪 首先，我们要知道并发要解决的是什么问题？并发要解决的是单进程情况下硬件资源无法充分利用的问题。而造成这一问题的主要原因是CPU-内存-磁盘三者之间速度差异实在太大。如果将CPU的速</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/listenfwind/p/13149718.html</dc:identifier>
</item>
<item>
<title>精美图文讲解Java AQS 共享式获取同步状态以及Semaphore的应用 - 日拱一兵</title>
<link>http://www.cnblogs.com/FraserYu/p/13150328.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/FraserYu/p/13150328.html</guid>
<description>&lt;p&gt;| &lt;strong&gt;好看请赞，养成习惯&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;你有一个思想，我有一个思想，我们交换后，一个人就有两个思想&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;If you can NOT explain it simply, you do NOT understand it well enough&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;现陆续将Demo代码和技术文章整理在一起 &lt;a href=&quot;https://github.com/FraserYu/learnings&quot;&gt;Github实践精选&lt;/a&gt; ，方便大家阅读查看，本文同样收录在此，觉得不错，还请Star🌟&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202006/1583165-20200617075640968-960783658.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看到本期内容这么少，是不是心动了呢？&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;上一篇万字长文 &lt;a href=&quot;https://dayarch.top/p/java-aqs-and-reentrantlock.html&quot;&gt;Java AQS队列同步器以及ReentrantLock的应用&lt;/a&gt; 为我们读 JUC 源码以及其设计思想做了足够多的铺垫，接下来的内容我将重点说明差异化，如果有些童鞋不是能很好的理解文中的一些内容，强烈建议回看上一篇文章，搞懂基础内容，接下来的阅读真会轻松加愉快&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;AQS 中我们介绍了独占式获取同步状态的多种情形：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;独占式获取锁&lt;/li&gt;
&lt;li&gt;可响应中断的独占式获取锁&lt;/li&gt;
&lt;li&gt;有超时限制的独占式获取锁&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;AQS 提供的模版方法里面还差共享式获取同步状态没有介绍，所以我们今天来揭开这个看似神秘的面纱&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202006/1583165-20200617075641283-1771699100.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;aqs-中的共享式获取同步状态&quot;&gt;AQS 中的共享式获取同步状态&lt;/h2&gt;
&lt;p&gt;独占式是你中没我，我中没你的的一种互斥形式，共享式显然就不是这样了，所以他们的唯一区别就是：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;同一时刻能否有多个线程同时获取到同步状态&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单来说，就是这样滴：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202006/1583165-20200617075641836-72943338.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们知道同步状态 state 是维护在 AQS 中的，抛开可重入锁的概念，我在上篇文章中也提到了，独占式和共享式控制同步状态 state 的区别仅仅是这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202006/1583165-20200617075642177-1747186693.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以说想了解 AQS 的 xxxShared 的模版方法，只需要知道它是怎么控制 state 的就好了&lt;/p&gt;
&lt;h3 id=&quot;aqs共享式获取同步状态源码分析&quot;&gt;AQS共享式获取同步状态源码分析&lt;/h3&gt;
&lt;p&gt;为了帮助大家更好的回忆内容，我将上一篇文章的两个关键内容粘贴在此处，帮助大家快速回忆，关于共享式，大家只需要关注【骚紫色】就可以了&lt;/p&gt;
&lt;h4 id=&quot;自定义同步器需要重写的方法&quot;&gt;自定义同步器需要重写的方法&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202006/1583165-20200617075642503-1189568103.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;aqs-提供的模版方法&quot;&gt;AQS 提供的模版方法&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202006/1583165-20200617075643513-1400486656.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;故事就从这里说起吧 (你会发现和独占式惊人的相似)，关键代码都加了注释&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    public final void acquireShared(int arg) {
        // 同样调用自定义同步器需要重写的方法，非阻塞式的尝试获取同步状态，如果结果小于零，则获取同步状态失败
        if (tryAcquireShared(arg) &amp;lt; 0)
                // 调用 AQS 提供的模版方法，进入等待队列
            doAcquireShared(arg);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;进入 &lt;code&gt;doAcquireShared&lt;/code&gt; 方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    private void doAcquireShared(int arg) {
        // 创建共享节点「SHARED」，加到等待队列中
        final Node node = addWaiter(Node.SHARED);
        boolean failed = true;
        try {
            boolean interrupted = false;
                // 进入“自旋”，这里并不是纯粹意义上的死循环，在独占式已经说明过
            for (;;) {
                // 同样尝试获取当前节点的前驱节点
                final Node p = node.predecessor();
                // 如果前驱节点为头节点，尝试再次获取同步状态
                if (p == head) {
                        // 在此以非阻塞式获取同步状态
                    int r = tryAcquireShared(arg);
                        // 如果返回结果大于等于零，才能跳出外层循环返回
                    if (r &amp;gt;= 0) {
                        // 这里是和独占式的区别
                        setHeadAndPropagate(node, r);
                        p.next = null; // help GC
                        if (interrupted)
                            selfInterrupt();
                        failed = false;
                        return;
                    }
                }
                if (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;
                    parkAndCheckInterrupt())
                    interrupted = true;
            }
        } finally {
            if (failed)
                cancelAcquire(node);
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面代码第 18 行我们提到和独占式获取同步状态的区别，贴心的给大家一个更直观的对比：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202006/1583165-20200617075645135-1387709377.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;差别只在这里，所以我们就来看看 &lt;code&gt;setHeadAndPropagate(node, r)&lt;/code&gt; 到底干了什么，我之前说过 JDK 源码中的方法命名绝大多数还是非常直观的，该方法直译过来就是 【设置头并且传播/繁衍】。独占式只是设置了头，共享式除了设置头还多了一个传播，你的疑问应该已经来了：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;啥是传播，为什么会有传播这个设置呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;想了解这个问题，你需要先知道非阻塞共享式获取同步状态返回值的含义：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202006/1583165-20200617075645688-877089215.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里说的传播其实说的是 &lt;code&gt;propagate &amp;gt; 0&lt;/code&gt; 的情况，道理也很简单，当前线程获取同步状态成功了，还有剩余的同步状态可用于其他线程获取，&lt;strong&gt;那就要通知在等待队列的线程，让他们尝试获取剩余的同步状态&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果要让等待队列中的线程获取到通知，需要线程调用 release 方法实现的&lt;/strong&gt;。接下来，我们走近 &lt;code&gt;setHeadAndPropagate&lt;/code&gt; 一探究竟，验证一下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;  // 入参，node： 当前节点
        // 入参，propagate：获取同步状态的结果值，即上面方法中的变量 r
        private void setHeadAndPropagate(Node node, int propagate) {
                // 记录旧的头部节点，用于下面的check
        Node h = head; 
                // 将当前节点设置为头节点
        setHead(node);
        
                // 通过 propagate 的值和 waitStatus 的值来判断是否可以调用 doReleaseShared 方法
        if (propagate &amp;gt; 0 || h == null || h.waitStatus &amp;lt; 0 ||
            (h = head) == null || h.waitStatus &amp;lt; 0) {
            Node s = node.next;
                // 如果后继节点为空或者后继节点为共享类型，则进行唤醒后继节点
                                // 这里后继节点为空意思是只剩下当前头节点了，另外这里的 s == null 也是判断空指针的标准写法
            if (s == null || s.isShared())
                doReleaseShared();
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面方法的大方向作用我们了解了，但是代码中何时调用 &lt;code&gt;doReleaseShared&lt;/code&gt; 的判断逻辑还是挺让人费解的，为什么会有这么一大堆的判断，我们来逐个分析一下：&lt;/p&gt;
&lt;p&gt;这里的空判断有点让人头大，我们先挑出来说明一下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202006/1583165-20200617075646064-1658952400.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;排除了其他判断条件的干扰，接下来我们就专注分析 propagate 和 waitStatus 两个判断条件就可以了，这里再将 waitStatus 的几种状态展示在这里，帮助大家理解，【骚粉色】是我们一会要用到的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202006/1583165-20200617075646622-43253346.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;propagate &amp;gt; 0&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面已经说过了，如果成立，直接短路后续判断，然后根据 doReleaseShared 的判断条件进行释放&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;propagate &amp;gt; 0 不成立， h.waitStatus &amp;lt; 0 成立 &lt;strong&gt;（注意这里的h是旧的头节点）&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;什么时候 h.waitStatus &amp;lt; 0 呢？抛开 CONDITION 的使用，只剩下 SIGNAL 和 PROPAGATE，想知道这个答案，需要提前看一下 &lt;code&gt;doReleaseShared()&lt;/code&gt; 方法了：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    private void doReleaseShared() {
        for (;;) {
            Node h = head;
            if (h != null &amp;amp;&amp;amp; h != tail) {
                int ws = h.waitStatus;
                if (ws == Node.SIGNAL) {
                        // CAS 将头节点的状态设置为0                
                    if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))
                        continue;            // loop to recheck cases
                    // 设置成功后才能跳出循环唤醒头节点的下一个节点
                        unparkSuccessor(h);
                }
                else if (ws == 0 &amp;amp;&amp;amp;
                         // 将头节点状态CAS设置成 PROPAGATE 状态
                         !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))
                    continue;                // loop on failed CAS
            }
            if (h == head)                   // loop if head changed
                break;
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从 &lt;code&gt;doReleaseShared()&lt;/code&gt; 方法中可以看出：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果让 h.waitStatus &amp;lt; 0 成立，只能将其设置成 PROPAGATE = -3 的情况，设置成功的前提是 h 头节点 expected 的状态是 0；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果 h.waitStatus = 0，是上述代码第 8 行 CAS 设置成功，然后唤醒等待中的线程&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以猜测，当前线程执行到 h.waitStatus &amp;lt; 0 的判断前，有另外一个线程刚好执行了 &lt;code&gt;doReleaseShared()&lt;/code&gt; 方法，将 waitStatus 又设置成PROPAGATE = -3&lt;/p&gt;
&lt;p&gt;这个理解有点绕，我们还是来画个图理解一下吧：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202006/1583165-20200617075647530-920585638.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可能有同学还是不太能理解这么写的道理，我们一直说 propagate &amp;lt;&amp;gt; = 0 的情况，propagate = 0 代表的是&lt;strong&gt;当时/当时/当时&lt;/strong&gt; 尝试获取同步状态没成功，但是之后可能又有共享状态被释放了，所以上面的逻辑是以防这种万一，你懂的，严谨的并发就是要防止一切万一，现在结合这个情景再来理解上面的判断你是否豁然开朗了呢？&lt;/p&gt;
&lt;p&gt;继续向下看，&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;前序条件不成立，(h = head) == null || h.waitStatus &amp;lt; 0 &lt;strong&gt;注意这里的h是新的头节点）&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有了上面铺垫，这个就直接画个图就更好理解啦，其实就是没有那么巧有另外一个线程掺合了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202006/1583165-20200617075648315-982613795.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;相信到这里你应该理解共享式获取同步状态的全部过程了吧，至于&lt;strong&gt;非阻塞共享式获取同步状态&lt;/strong&gt;和&lt;strong&gt;带有超时时间获取同步状态&lt;/strong&gt;，结合本文讲的 setHeadAndPropagate 逻辑和独占式获取同步状态的实现过程过程来看，真是一毛一样，这里就不再累述了，赶紧打开你的 IDE 去验证一下吧&lt;/p&gt;
&lt;p&gt;我们分析了AQS 的模版方法，还一直没说 &lt;code&gt;tryAcquireShared(arg)&lt;/code&gt; 这个方法是如何被重写的，想要了解这个，我们就来看一看共享式获取同步状态的经典应用 Semaphore&lt;/p&gt;
&lt;h2 id=&quot;semaphore-的应用及源码分析&quot;&gt;Semaphore 的应用及源码分析&lt;/h2&gt;
&lt;h3 id=&quot;semaphore-概念&quot;&gt;Semaphore 概念&lt;/h3&gt;
&lt;p&gt;Semaphore 中文多翻译为 【信号量】，我还特意查了一下剑桥辞典的英文解释：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202006/1583165-20200617075648760-1981102432.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其实就是信号标志（two flags），比如红绿灯，每个交通灯产生两种不同行为&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Flag1-红灯：停车&lt;/li&gt;
&lt;li&gt;Flag2-绿灯：行车&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在 Semaphore 里面，什么时候是红灯，什么时候是绿灯，其实就是靠 &lt;code&gt;tryAcquireShared(arg)&lt;/code&gt; 的结果来表示的&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;获取不到共享状态，即为红灯&lt;/li&gt;
&lt;li&gt;获取到共享状态，即为绿灯&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以我们走近 Semaphore ，来看看它到底是怎么应用 AQS 的，又是怎样重写 &lt;code&gt;tryAcquireShared(arg)&lt;/code&gt; 方法的&lt;/p&gt;
&lt;h3 id=&quot;semaphore-源码分析&quot;&gt;Semaphore 源码分析&lt;/h3&gt;
&lt;p&gt;先看一下类结构&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202006/1583165-20200617075649288-2140811626.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看到这里你是否有点跌眼镜，和 ReentrantLock 相似的可怕吧，如果你有些陌生，再次强烈建议你回看上一篇文章 &lt;a href=&quot;https://dayarch.top/p/java-aqs-and-reentrantlock.html&quot;&gt;Java AQS队列同步器以及ReentrantLock的应用&lt;/a&gt; ，这里直接提速对比看公平和非公平两种重写的 &lt;code&gt;tryAcquireShared(arg)&lt;/code&gt; 方法，没有意外，公平与否，就是判断是否有前驱节点&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202006/1583165-20200617075649688-2001832591.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;方法内部只是计算 state 的剩余值，那 state 的初始值是多少怎么设置呢？当然也就是构造方法了：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;               public Semaphore(int permits) {
        // 默认仍是非公平的同步器，至于为什么默认是非公平的，在上一篇文章中也特意说明过
        sync = new NonfairSync(permits);
    }
    
    NonfairSync(int permits) {
                super(permits);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;super 方法，就会将初始值给到 AQS 中的 state&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202006/1583165-20200617075650088-868296355.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也许你发现了，当我们把 permits 设置为1 的时候，不就是 ReentrantLock 的互斥锁了嘛，说的一点也没错，我们用 Semaphore 也能实现基本互斥锁的效果&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
static int count;
//初始化信号量
static final Semaphore s 
    = new Semaphore(1);
//用信号量保证互斥    
static void addOne() {
  s.acquire();
  try {
    count+=1;
  } finally {
    s.release();
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;But（英文听力中的重点），Semaphore 肯定不是为这种特例存在的，它是共享式获取同步状态的一种实现。如果使用信号量，我们通常会将 permits 设置成大于1的值，不知道你是否还记得我曾在 &lt;a href=&quot;https://dayarch.top/p/why-we-need-to-use-threadpool.html&quot;&gt;为什么要使用线程池?&lt;/a&gt; 一文中说到的池化概念，在同一时刻，允许多个线程使用连接池，每个连接被释放之前，不允许其他线程使用。所以说 &lt;strong&gt;Semaphore 可以允许多个线程访问一个临界区&lt;/strong&gt;，最终很好的做到一个&lt;strong&gt;限流/限流/限流&lt;/strong&gt; 的作用&lt;/p&gt;
&lt;p&gt;虽然 Semaphore 能很好的提供限流作用，说实话，Semaphore 的限流作用比较单一，我在实际工作中使用 Semaphore 并不是很多，如果真的要用高性能限流器，Guava RateLimiter 是一个非常不错的选择，我们后面会做分析，有兴趣的可以提前了解一下&lt;/p&gt;
&lt;p&gt;关于 Semaphore 源码，就这么三下五除二的结束了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202006/1583165-20200617075650459-1412391735.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;不知你有没有感觉到，我们的节奏明显加快了，好多原来分散的点在被疯狂的串联起来，如果按照这个方式来阅读 JUC 源码，相信你也不会一头扎进去迷失方向，然后沮丧的退出 JUC 吧，然后面试背诵答案，然后忘记，然后再背诵？&lt;/p&gt;
&lt;p&gt;跟上节奏，关于共享式获取同步状态，Semaphore 只不过是非常经典的应用，ReadWriteLock 和 CountDownLatch 日常应用还是非常广泛的，我们接下来就陆续聊聊它们吧&lt;/p&gt;
&lt;h2 id=&quot;灵魂追问&quot;&gt;灵魂追问&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;Semaphore 的 permits 设置成1 “等同于” 简单的互斥锁实现，那它和 ReentrantLock 的区别还是挺大的，都有哪些区别呢？&lt;/li&gt;
&lt;li&gt;你在项目中是如何使用 Semaphore 的呢？&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;Java 并发实战&lt;/li&gt;
&lt;li&gt;Java 并发编程的艺术&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/anlian523/article/details/106319294&quot;&gt;https://blog.csdn.net/anlian523/article/details/106319294&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Tue, 16 Jun 2020 23:57:00 +0000</pubDate>
<dc:creator>日拱一兵</dc:creator>
<og:description>| 好看请赞，养成习惯 你有一个思想，我有一个思想，我们交换后，一个人就有两个思想 If you can NOT explain it simply, you do NOT understand it</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/FraserYu/p/13150328.html</dc:identifier>
</item>
<item>
<title>小师妹学JVM之:深入理解JIT和编译优化-你看不懂系列 - flydean</title>
<link>http://www.cnblogs.com/flydean/p/jvm-jit-in-detail.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/flydean/p/jvm-jit-in-detail.html</guid>
<description>&lt;p&gt;小师妹已经学完JVM的简单部分了，接下来要进入的是JVM中比较晦涩难懂的概念，这些概念是那么的枯燥乏味，甚至还有点惹人讨厌，但是要想深入理解JVM，这些概念是必须的，我将会尽量尝试用简单的例子来解释它们，但一定会有人看不懂，没关系，这个系列本不是给所有人看的。&lt;/p&gt;
&lt;p&gt;更多精彩内容且看：&lt;/p&gt;

&lt;p&gt;小师妹:F师兄，我的基础已经打牢了吗？可以进入这么复杂的内容环节了吗？&lt;/p&gt;
&lt;p&gt;小师妹不试试怎么知道不行呢？了解点深入内容可以帮助你更好的理解之前的知识。现在我们开始吧。&lt;/p&gt;
&lt;p&gt;上次我们在讲java程序的处理流程的时候，还记得那通用的几步吧。&lt;/p&gt;
&lt;p&gt;小师妹：当然记得了，编写源代码，javac编译成字节码，加载到JVM中执行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200524212920415.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_0,text_aHR0cDovL3d3dy5mbHlkZWFuLmNvbQ==,size_35,color_8F8F8F,t_70&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对，其实在JVM的执行引擎中，有三个部分：解释器，JIT编译器和垃圾回收器。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200524221637660.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_0,text_aHR0cDovL3d3dy5mbHlkZWFuLmNvbQ==,size_35,color_8F8F8F,t_70&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;解释器会将前面编译生成的字节码翻译成机器语言，因为每次都要翻译，相当于比直接编译成机器码要多了一步，所以java执行起来会比较慢。&lt;/p&gt;
&lt;p&gt;为了解决这个问题，JVM引入了JIT(Just-in-Time)编译器，将热点代码编译成为机器码。&lt;/p&gt;

&lt;p&gt;小师妹你知道吗？在JDK8之前，HotSpot VM又分为三种。分别是 client VM, server VM, 和 minimal VM，分别用在客户端，服务器，和嵌入式系统。&lt;/p&gt;
&lt;p&gt;但是随着硬件技术的发展，这些硬件上面的限制都不是什么大事了。所以从JDK8之后，已经不再区分这些VM了，现在统一使用VM的实现来替代他们。&lt;/p&gt;
&lt;p&gt;小师妹，你觉得Client VM和Server VM的本质区别在哪一部分呢？&lt;/p&gt;
&lt;p&gt;小师妹，编译成字节码应该都是使用javac，都是同样的命令，字节码上面肯定是一样的。难点是在执行引擎上面的不同？&lt;/p&gt;
&lt;p&gt;说的对，因为Client VM和Server VM的出现，所以在JIT中出现了两种不同的编译器，C1 for Client VM， C2 for Server VM。&lt;/p&gt;
&lt;p&gt;因为javac的编译只能做少量的优化，其实大量的动态优化是在JIT中做的。C2相对于C1，其优化的程度更深，更加激进。&lt;/p&gt;
&lt;p&gt;为了更好的提升编译效率，JVM在JDK7中引入了分层编译Tiered compilation的概念。&lt;/p&gt;
&lt;p&gt;对于JIT本身来说，动态编译是需要占用用户内存空间的，有可能会造成较高的延迟。&lt;/p&gt;
&lt;p&gt;对于Server服务器来说，因为代码要服务很多个client，所以磨刀不误砍柴工，短暂的延迟带来永久的收益，听起来是可以接受的。&lt;/p&gt;
&lt;p&gt;Server端的JIT编译也不是立马进行的，它可能需要收集到足够多的信息之后，才进行编译。&lt;/p&gt;
&lt;p&gt;而对于Client来说，延迟带来的性能影响就需要进行考虑了。和Server相比，它只进行了简单的机器码的编译。&lt;/p&gt;
&lt;p&gt;为了满足不同层次的编译需求，于是引入了分层编译的概念。&lt;/p&gt;
&lt;p&gt;大概来说分层编译可以分为三层：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;第一层就是禁用C1和C2编译器，这个时候没有JIT进行。&lt;/li&gt;
&lt;li&gt;第二层就是只开启C1编译器，因为C1编译器只会进行一些简单的JIT优化，所以这个可以应对常规情况。&lt;/li&gt;
&lt;li&gt;第三层就是同时开启C1和C2编译器。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在JDK7中，你可以使用下面的命令来开启分层编译：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;-XX:+TieredCompilation
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而在JDK8之后，恭喜你，分层编译已经是默认的选项了，不用再手动开启。&lt;/p&gt;

&lt;p&gt;小师妹：F师兄，你刚刚讲到Server的JIT不是立马就进行编译的，它会等待一定的时间来搜集所需的信息，那么代码不是要从字节码转换成机器码？&lt;/p&gt;
&lt;p&gt;对的，这个过程就叫做OSR（On-Stack Replacement）。为什么叫OSR呢？我们知道JVM的底层实现是一个栈的虚拟机，所以这个替换实际上是一系列的Stack操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200528094011924.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_0,text_aHR0cDovL3d3dy5mbHlkZWFuLmNvbQ==,size_35,color_8F8F8F,t_70&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图所示，m1方法从最初的解释frame变成了后面的compiled frame。&lt;/p&gt;

&lt;p&gt;这个世界是平衡的，有阴就有阳，有优化就有反优化。&lt;/p&gt;
&lt;p&gt;小师妹：F师兄，为什么优化了之后还要反优化呢？这样对性能不是下降了吗？&lt;/p&gt;
&lt;p&gt;通常来说是这样的，但是有些特殊的情况下面，确实是需要进行反优化的。&lt;/p&gt;
&lt;p&gt;下面是比较常见的情况：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;需要调试的情况&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如果代码正在进行单个步骤的调试，那么之前被编译成为机器码的代码需要反优化回来，从而能够调试。&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;代码废弃的情况&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;当一个被编译过的方法，因为种种原因不可用了，这个时候就需要将其反优化。&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;优化之前编译的代码&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;有可能出现之前优化过的代码可能不够完美，需要重新优化的情况，这种情况下同样也需要进行反优化。&lt;/p&gt;

&lt;p&gt;除了JIT编译成机器码之外，JIT还有一下常见的代码优化方式，我们来一一介绍。&lt;/p&gt;
&lt;h2 id=&quot;inlining内联&quot;&gt;Inlining内联&lt;/h2&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;int a = 1;
int b = 2;
int result = add(a, b);
...
public int add(int x, int y) { return x + y; }
int result = a + b; //内联替换
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的add方法可以简单的被替换成为内联表达式。&lt;/p&gt;
&lt;h2 id=&quot;branch-prediction分支预测&quot;&gt;Branch Prediction分支预测&lt;/h2&gt;
&lt;p&gt;通常来说对于条件分支，因为需要有一个if的判断条件，JVM需要在执行完毕判断条件，得到返回结果之后，才能够继续准备后面的执行代码，如果有了分支预测，那么JVM可以提前准备相应的执行代码，如果分支检查成功就直接执行，省去了代码准备的步骤。&lt;/p&gt;
&lt;p&gt;比如下面的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// make an array of random doubles 0..1
double[] bigArray = makeBigArray();
for (int i = 0; i &amp;lt; bigArray.length; i++)
{
 double cur = bigArray[i];
 if (cur &amp;gt; 0.5) { doThis();} else { doThat();}
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;loop-unswitching&quot;&gt;Loop unswitching&lt;/h2&gt;
&lt;p&gt;如果我们在循环语句里面添加了if语句，为了提升并发的执行效率，可以将if语句从循环中提取出来：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;  int i, w, x[1000], y[1000];
  for (i = 0; i &amp;lt; 1000; i++) {
    x[i] += y[i];
    if (w)
      y[i] = 0;
  }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以改为下面的方式：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;  int i, w, x[1000], y[1000];
  if (w) {
    for (i = 0; i &amp;lt; 1000; i++) {
      x[i] += y[i];
      y[i] = 0;
    }
  } else {
    for (i = 0; i &amp;lt; 1000; i++) {
      x[i] += y[i];
    }
  }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;loop-unrolling展开&quot;&gt;Loop unrolling展开&lt;/h2&gt;
&lt;p&gt;在循环语句中，因为要不断的进行跳转，所以限制了执行的速度，我们可以对循环语句中的逻辑进行适当的展开：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt; int x;
 for (x = 0; x &amp;lt; 100; x++)
 {
     delete(x);
 }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;转变为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt; int x; 
 for (x = 0; x &amp;lt; 100; x += 5 )
 {
     delete(x);
     delete(x + 1);
     delete(x + 2);
     delete(x + 3);
     delete(x + 4);
 }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;虽然循环体变长了，但是跳转次数变少了，其实是可以提升执行速度的。&lt;/p&gt;
&lt;h2 id=&quot;escape-analysis逃逸分析&quot;&gt;Escape analysis逃逸分析&lt;/h2&gt;
&lt;p&gt;什么叫逃逸分析呢？简单点讲就是分析这个线程中的对象，有没有可能会被其他对象或者线程所访问，如果有的话，那么这个对象应该在Heap中分配，这样才能让对其他的对象可见。&lt;/p&gt;
&lt;p&gt;如果没有其他的对象访问，那么完全可以在stack中分配这个对象，栈上分配肯定比堆上分配要快，因为不用考虑同步的问题。&lt;/p&gt;
&lt;p&gt;我们举个例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;  public static void main(String[] args) {
    example();
  }
  public static void example() {
    Foo foo = new Foo(); //alloc
    Bar bar = new Bar(); //alloc
    bar.setFoo(foo);
  }
}

class Foo {}

class Bar {
  private Foo foo;
  public void setFoo(Foo foo) {
    this.foo = foo;
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的例子中，setFoo引用了foo对象，如果bar对象是在heap中分配的话，那么引用的foo对象就逃逸了，也需要被分配在heap空间中。&lt;/p&gt;
&lt;p&gt;但是因为bar和foo对象都只是在example方法中调用的，所以，JVM可以分析出来没有其他的对象需要引用他们，那么直接在example的方法栈中分配这两个对象即可。&lt;/p&gt;
&lt;p&gt;逃逸分析还有一个作用就是lock coarsening。&lt;/p&gt;
&lt;p&gt;为了在多线程环境中保证资源的有序访问，JVM引入了锁的概念，虽然锁可以保证多线程的有序执行，但是如果实在单线程环境中呢？是不是还需要一直使用锁呢？&lt;/p&gt;
&lt;p&gt;比如下面的例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public String getNames() {
     Vector&amp;lt;String&amp;gt; v = new Vector&amp;lt;&amp;gt;();
     v.add(&quot;Me&quot;);
     v.add(&quot;You&quot;);
     v.add(&quot;Her&quot;);
     return v.toString();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Vector是一个同步对象，如果是在单线程环境中，这个同步锁是没有意义的，因此在JDK6之后，锁只在被需要的时候才会使用。&lt;/p&gt;
&lt;p&gt;这样就能提升程序的执行效率。&lt;/p&gt;

&lt;p&gt;本文介绍了JIT的原理和一些基本的优化方式。后面我们会继续探索JIT和JVM的秘密，敬请期待。&lt;/p&gt;
&lt;blockquote readability=&quot;8.7106598984772&quot;&gt;
&lt;p&gt;本文作者：flydean程序那些事&lt;/p&gt;
&lt;p&gt;本文链接：&lt;a href=&quot;http://www.flydean.com/jvm-jit-in-detail/&quot;&gt;http://www.flydean.com/jvm-jit-in-detail/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文来源：flydean的博客&lt;/p&gt;
&lt;p&gt;欢迎关注我的公众号:程序那些事，更多精彩等着您！&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 16 Jun 2020 22:50:00 +0000</pubDate>
<dc:creator>flydean</dc:creator>
<og:description>简介 小师妹已经学完JVM的简单部分了，接下来要进入的是JVM中比较晦涩难懂的概念，这些概念是那么的枯燥乏味，甚至还有点惹人讨厌，但是要想深入理解JVM，这些概念是必须的，我将会尽量尝试用简单的例子来</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/flydean/p/jvm-jit-in-detail.html</dc:identifier>
</item>
<item>
<title>从字符串到常量池，一文看懂String类设计 - 程序员DMZ</title>
<link>http://www.cnblogs.com/daimzh/p/13150192.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/daimzh/p/13150192.html</guid>
<description>&lt;p&gt;看到这个标题，你肯定以为我又要讲这道面试题了&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//  这行代码创建了几个对象？
String s3 = new String(&quot;1&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;是的，没错，我确实要从这里开始&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vd3hfY2MzNDdiZTY5Ni9ibG9nSW1hZ2UvcmF3L21hc3Rlci9pbWFnZS0yMDIwMDYxNTIyMTQwODUwMC5wbmc?x-oss-process=image/format,png&quot; alt=&quot;image-20200615221408500&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这道题就算你没做过也肯定看到，总所周知，它创建了两个对象，一个位于堆上，一个位于常量池中。&lt;/p&gt;
&lt;p&gt;这个答案粗看起来是没有任何问题的，但是仔细思考确经不起推敲。&lt;/p&gt;
&lt;p&gt;如果你觉得我说的不对的话，那么可以思考下面这两个问题&lt;/p&gt;
&lt;ol readability=&quot;2&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;你说它创建了两个对象，那么这两个对象分别是怎样创建的呢？我们回顾下Java创建对象的方式，一共就这么几种&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用new关键字创建对象&lt;/li&gt;
&lt;li&gt;使用反射创建对象（包括Class类的&lt;code&gt;newInstance&lt;/code&gt;方法，以及Constructor类的&lt;code&gt;newInstance&lt;/code&gt;方法）&lt;/li&gt;
&lt;li&gt;使用clone复制一个对象&lt;/li&gt;
&lt;li&gt;反序列化得到一个对象&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;你说它创建了两个对象，那你告诉我除了new出来那个对象外，另外一个对象怎么创建出来的？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;堆跟常量池到底什么关系？不是说在&lt;code&gt;JDK1.7&lt;/code&gt;之后（含1.7版本）常量池已经移到了堆中了吗？如果说常量池本身就位于堆中的话，那么这种&lt;code&gt;一个对象在堆中，一个对象在常量池&lt;/code&gt;的说法还准确吗？&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如果你也产生过这些疑问的话，那么请耐心看完这篇文章！要解释上面的问题首先我们得对常量池有个准确的认知。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vd3hfY2MzNDdiZTY5Ni9ibG9nSW1hZ2UvcmF3L21hc3Rlci9pbWFnZS0yMDIwMDYxNTIyMTUwMjI2OC5wbmc?x-oss-process=image/format,png&quot; alt=&quot;image-20200615221502268&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;通常来说，我们提到的常量池分为三种&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;class文件中的常量池&lt;/li&gt;
&lt;li&gt;运行时常量池&lt;/li&gt;
&lt;li&gt;字符串常量池&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于这三种常量池，我们需要搞懂下面几个问题？&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;这个常量池在哪里？&lt;/li&gt;
&lt;li&gt;这个常量池用来干什么呢？&lt;/li&gt;
&lt;li&gt;这三者有什么关系？&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;接下来，我们带着这些问题往下看&lt;/p&gt;
&lt;h2 id=&quot;class文件中的常量池&quot;&gt;class文件中的常量池&lt;/h2&gt;
&lt;h3 id=&quot;位置在哪？&quot;&gt;位置在哪？&lt;/h3&gt;
&lt;p&gt;顾名思义，class文件中的常量池当然是位于class文件中，而&lt;strong&gt;class文件又是位于磁盘上&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;用来干什么的？&quot;&gt;用来干什么的？&lt;/h3&gt;
&lt;p&gt;在学习class文件中的常量池前，我们首选需要对class文件的结构有一定了解&lt;/p&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;Class文件是一组以8个字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在文&lt;/p&gt;
&lt;p&gt;件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数&lt;/p&gt;
&lt;p&gt;据，没有空隙存在。&lt;/p&gt;
&lt;p&gt;​ ------------《深入理解Java虚拟机》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;整个class文件的组成可以用下图来表示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vd3hfY2MzNDdiZTY5Ni9ibG9nSW1hZ2UvcmF3L21hc3Rlci9pbWFnZS0yMDIwMDYxNTIyNTAxNjYwNC5wbmc?x-oss-process=image/format,png&quot; alt=&quot;image-20200615225016604&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对本文而言，我们只关注其中的常量池部分，&lt;strong&gt;常量池可以理解为class文件中资源仓库&lt;/strong&gt;，它是class文件结构中与其它项目关联最多的数据类型，主要用于存放编译器生成的&lt;strong&gt;各种字面量(Literal)和符号引用(Symbolic References)&lt;/strong&gt;。&lt;br/&gt;&lt;strong&gt;字面量就是我们所说的常量概念，如文本字符串、被声明为final的常量值等&lt;/strong&gt;。&lt;br/&gt;&lt;strong&gt;符号引用是一组符号来描述所引用的目标&lt;/strong&gt;，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可（它与直接引用区分一下，直接引用一般是指向方法区的本地指针，相对偏移量或是一个能间接定位到目标的句柄）。一般包括下面三类常量：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;类和接口的全限定名&lt;/li&gt;
&lt;li&gt;字段的名称和描述符&lt;/li&gt;
&lt;li&gt;方法的名称和描述符&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;现在我们知道了class文件中常量池的作用：存放编译器生成的&lt;strong&gt;各种字面量(Literal)和符号引用(Symbolic References)&lt;/strong&gt;。很多时候知道了一个东西的概念并不能说你会了，对于程序员而言，如果你说你已经会了，那么最好的证明是你能够通过代码将其描述出来，所以，接下来，我想以一种直观的方式让大家感受到常量池的存在。通过分析一段简单代码的字节码，让大家能更好感知常量池的作用。&lt;/p&gt;
&lt;p&gt;​ &lt;em&gt;talk is cheap ,show me code&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;我们以下面这段代码为例，通过&lt;code&gt;javap&lt;/code&gt;来查看class文件中的具体内容，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * @author 程序员DMZ
 * @Date Create in 22:59 2020/6/15
 * @公众号 微信搜索：程序员DMZ
 */
public class Main {
    public static void main(String[] args) {
        String name = &quot;dmz&quot;;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;进入&lt;code&gt;Main.java&lt;/code&gt;文件所在目录，执行命令：&lt;code&gt;javac Main.java&lt;/code&gt; ，那么此时会在当前目录下生成对应的&lt;code&gt;Main.class文件&lt;/code&gt;。再执行命令：&lt;code&gt;javap -v -c Main.class&lt;/code&gt;，此时会得到如下的解析后的字节码信息&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class com.dmz.jvm.Main
  minor version: 0
  major version: 52
  flags: ACC_PUBLIC, ACC_SUPER
// 这里就是常量池了
Constant pool:
   #1 = Methodref          #4.#20         // java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V
   #2 = String             #21            // dmz
   #3 = Class              #22            // com/dmz/jvm/Main
   #4 = Class              #23            // java/lang/Object
   #5 = Utf8               &amp;lt;init&amp;gt;
   #6 = Utf8               ()V
   #7 = Utf8               Code
   #8 = Utf8               LineNumberTable
   #9 = Utf8               LocalVariableTable
  #10 = Utf8               this
  #11 = Utf8               Lcom/dmz/jvm/Main;
  #12 = Utf8               main
  #13 = Utf8               ([Ljava/lang/String;)V
  #14 = Utf8               args
  #15 = Utf8               [Ljava/lang/String;
  #16 = Utf8               name
  #17 = Utf8               Ljava/lang/String;
  #18 = Utf8               SourceFile
  #19 = Utf8               Main.java
  #20 = NameAndType        #5:#6          // &quot;&amp;lt;init&amp;gt;&quot;:()V
  #21 = Utf8               dmz
  #22 = Utf8               com/dmz/jvm/Main
  #23 = Utf8               java/lang/Object
 // 下面是方法表                           
{
  public com.dmz.jvm.Main();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V
         4: return
      LineNumberTable:
        line 7: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       5     0  this   Lcom/dmz/jvm/Main;

  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=1, locals=2, args_size=1
         // 可以看到方法表中的指令引用了常量池中的常量，这也是为什么说常量池是资源仓库的原因
         // 因为它会被class文件中的其它结构引用         
         0: ldc           #2                  // String dmz
         2: astore_1
         3: return
      LineNumberTable:
        line 9: 0
        line 10: 3
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       4     0  args   [Ljava/lang/String;
            3       1     1  name   Ljava/lang/String;
}
SourceFile: &quot;Main.java&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上面的字节码中，我们暂且关注常量池中的内容即可。主要看这两行&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;#2 = String             #14            // dmz
#14 = Utf8               dmz
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果要看懂这两行代码，我们需要对常量池中String类型常量的结构有一定了解，其结构如下：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;CONSTANT_String_info&lt;/th&gt;
&lt;th&gt;tag&lt;/th&gt;
&lt;th&gt;标志常量类型的标签&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td/&gt;
&lt;td&gt;index&lt;/td&gt;
&lt;td&gt;指向字符串字面量的索引&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;对应到我们上面的字节码中，tag=String，index=&lt;code&gt;#14&lt;/code&gt;，所以我们可以知道，&lt;code&gt;#2&lt;/code&gt;是一个字面量为&lt;code&gt;#14&lt;/code&gt;的字符串类型常量。而&lt;code&gt;#14&lt;/code&gt;对应的字面量信息（一个&lt;code&gt;Utf8&lt;/code&gt;类型的常量）就是&lt;code&gt;dmz&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;常量池作为资源仓库，最大的用处在于被class文件中的其它结构所引用，这个时候我们再将注意力放到main方法上来，对应的就是这三条指令&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;0: ldc           #2                  // String dmz
2: astore_1
3: return
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ldc&lt;/code&gt;：这个指令的作用是将对应的常量的引用压入操作数栈，在执行&lt;code&gt;ldc&lt;/code&gt;指令时会触发对它的符号引用进行解析，在上面例子中对应的符号引用就是&lt;code&gt;#2&lt;/code&gt;，也就是常量池中的第二个元素（这里就能看出方法表中就引用了常量池中的资源）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;astore_1&lt;/code&gt;：将操作数栈底元素弹出，存储到局部变量表中的1号元素&lt;/p&gt;
&lt;p&gt;&lt;code&gt;return&lt;/code&gt;：方法返回值为void，标志方法执行完成，将方法对应栈帧从栈中弹出&lt;/p&gt;
&lt;p&gt;下面我用画图的方式来画出整个流程，主要分为四步&lt;/p&gt;
&lt;ol readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;解析&lt;code&gt;ldc&lt;/code&gt;指令的符号引用（&lt;code&gt;#2&lt;/code&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;将&lt;code&gt;#2&lt;/code&gt;对应的常量的引用压入到操作数栈顶&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;将操作数栈的元素弹出并存储到局部变量表中&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;执行&lt;code&gt;return&lt;/code&gt;指令，方法执行结束，弹出栈区该方法对应的栈帧&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;第一步：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vd3hfY2MzNDdiZTY5Ni9ibG9nSW1hZ2UvcmF3L21hc3Rlci9pbWFnZS0yMDIwMDYxNjIxNTc0NTYzMy5wbmc?x-oss-process=image/format,png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在解析&lt;code&gt;#2&lt;/code&gt;这个符号引用时，会先到字符串常量池中查找是否存在对应字符串实例的引用，如果有的话，那么直接返回这个字符串实例的引用，如果没有的话，会创建一个字符串实例，那么将其添加到字符串常量池中（实际上是将其引用放入到一个哈希表中），之后再返回这个字符串实例对象的引用。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;到这里也能回答我们之前提出的那个问题了，一个对象是new出来的，另外一个是在解析常量池的时候JVM自动创建的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;第二步：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vd3hfY2MzNDdiZTY5Ni9ibG9nSW1hZ2UvcmF3L21hc3Rlci9pbWFnZS0yMDIwMDYxNjIxNTgzODQxNS5wbmc?x-oss-process=image/format,png&quot; alt=&quot;image-20200616215838415&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;将第一步得到的引用压入到操作数栈，此时这个字符串实例同时被操作数栈以及字符串常量池引用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第三步：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vd3hfY2MzNDdiZTY5Ni9ibG9nSW1hZ2UvcmF3L21hc3Rlci9pbWFnZS0yMDIwMDYxNjIyMDM0NDEwMi5wbmc?x-oss-process=image/format,png&quot; alt=&quot;image-20200616220344102&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;操作数栈中的引用弹出，并赋值给局部变量表中的1号位置元素，到这一步其实执行完了&lt;code&gt;String name = &quot;dmz&quot;&lt;/code&gt;这行代码。此时局部变量表中储存着一个指向堆中字符串实例的引用，并且这个字符串实例同时也被字符串常量池引用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第四步：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这一步我就不画图了，就是方法执行完成，栈帧弹出，非常简单。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;在上文中，我多次提到了&lt;strong&gt;字符串常量池&lt;/strong&gt;，它到底是个什么东西呢？我们还是分为两部分讨论&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;位置在哪?&lt;/li&gt;
&lt;li&gt;用来干什么的？&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;字符串常量池&quot;&gt;字符串常量池&lt;/h2&gt;
&lt;h3 id=&quot;位置在哪？-2&quot;&gt;位置在哪？&lt;/h3&gt;
&lt;p&gt;字符串常量池比较特殊，在&lt;code&gt;JDK1.7&lt;/code&gt;之前，其存在于永久代中，到&lt;code&gt;JDK1.7及&lt;/code&gt;之后，已经中永久代移到了堆中。当然，如果你非要说永久代也是堆的一部分那我也没办法。&lt;/p&gt;
&lt;p&gt;另外还要说明一点，经常有同学会将&lt;code&gt;方法区&lt;/code&gt;，&lt;code&gt;元空间&lt;/code&gt;，&lt;code&gt;永久代（permgen space）&lt;/code&gt;的概念混淆。请注意&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;方法区&lt;/code&gt;是&lt;code&gt;JVM&lt;/code&gt;在内存分配时需要遵守的规范，是一个理论，具体的实现可以因人而异&lt;/li&gt;
&lt;li&gt;&lt;code&gt;永久代&lt;/code&gt;是&lt;code&gt;hotspot&lt;/code&gt; 的&lt;code&gt;jdk1.8&lt;/code&gt;以前对方法区的实现，使用&lt;code&gt;jdk1.7&lt;/code&gt;的老司机肯定以前经常遇到过&lt;code&gt;java.lang.OutOfMemoryError: PremGen space&lt;/code&gt;异常。这里的&lt;code&gt;PermGen space&lt;/code&gt;其实指的就是方法区。不过方法区和&lt;code&gt;PermGen space&lt;/code&gt;又有着本质的区别。前者是&lt;code&gt;JVM的规范&lt;/code&gt;，而后者则是&lt;code&gt;JVM规范&lt;/code&gt;的一种实现，并且只有&lt;code&gt;HotSpot&lt;/code&gt;才有&lt;code&gt;PermGen space&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;元空间&lt;/code&gt;是&lt;code&gt;jdk1.8&lt;/code&gt;对方法区的实现，&lt;code&gt;jdk1.8&lt;/code&gt;彻底移除了永久代，其实，移除永久代的工作从&lt;code&gt;JDK 1.7&lt;/code&gt;就开始了。&lt;code&gt;JDK 1.7&lt;/code&gt;中，存储在永久代的部分数据就已经转移到Java Heap或者Native Heap。但永久代仍存在于&lt;code&gt;JDK 1.7&lt;/code&gt;中，并没有完全移除，譬如符号引用(Symbols)转移到了native heap；字面量(interned strings)转移到了Java heap；类的静态变量(class statics)转移到了Java heap。到&lt;code&gt;jdk1.8&lt;/code&gt;彻底移除了永久代，将JDK7中还剩余的永久代信息全部移到元空间，元空间相比对永久代最大的差别是，&lt;strong&gt;元空间使用的是本地内存（Native Memory）&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;用来干什么的？-2&quot;&gt;用来干什么的？&lt;/h3&gt;
&lt;p&gt;字符串常量池，顾名思义，肯定就是用来存储字符串的嘛，准确来说存储的是字符串实例对象的引用。我查阅了很多博客、资料，它们都会说，字符串常量池中存储的就是字符串对象。其实我们可以类比下面这段代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;HashSet&amp;lt;Person&amp;gt; persons = new HashSet&amp;lt;Person&amp;gt;;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在&lt;code&gt;persons&lt;/code&gt;这个集合中，存储的是&lt;code&gt;Person&lt;/code&gt;对象还是&lt;code&gt;Person&lt;/code&gt;对象对应的引用呢？&lt;/p&gt;
&lt;p&gt;所以，请大声跟我念三遍&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字符串常量池存储的是字符串实例对象的引用！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字符串常量池存储的是字符串实例对象的引用！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字符串常量池存储的是字符串实例对象的引用！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面我们来看R大博文下评论的一段话：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;简单来说，HotSpot VM里StringTable是个哈希表，里面存的是驻留字符串的引用（而不是驻留字符串实例自身）。也就是说某些普通的字符串实例被这个StringTable引用之后就等同被赋予了“驻留字符串”的身份。这个StringTable在每个HotSpot VM的实例里只有一份，被所有的类共享。类的运行时常量池里的CONSTANT_String类型的常量，经过解析（resolve）之后，同样存的是字符串的引用；解析的过程会去查询StringTable，以保证运行时常量池所引用的字符串与StringTable所引用的是一致的。&lt;/p&gt;
&lt;p&gt;​ ------R大博客&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从上面我们可以知道&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;字符串常量池本质就是一个哈希表&lt;/li&gt;
&lt;li&gt;字符串常量池中存储的是字符串实例的引用&lt;/li&gt;
&lt;li&gt;字符串常量池在被整个JVM共享&lt;/li&gt;
&lt;li&gt;在解析运行时常量池中的符号引用时，会去查询字符串常量池，确保运行时常量池中解析后的直接引用跟字符串常量池中的引用是一致的&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;为了更好理解上面的内容，我们需要去分析String中的一个方法-----&lt;code&gt;intern()&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;intern方法分析&quot;&gt;intern方法分析&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/** 
 * Returns a canonical representation for the string object. 
 * &amp;lt;p&amp;gt; 
 * A pool of strings, initially empty, is maintained privately by the 
 * class &amp;lt;code&amp;gt;String&amp;lt;/code&amp;gt;. 
 * &amp;lt;p&amp;gt; 
 * When the intern method is invoked, if the pool already contains a 
 * string equal to this &amp;lt;code&amp;gt;String&amp;lt;/code&amp;gt; object as determined by 
 * the {@link #equals(Object)} method, then the string from the pool is 
 * returned. Otherwise, this &amp;lt;code&amp;gt;String&amp;lt;/code&amp;gt; object is added to the 
 * pool and a reference to this &amp;lt;code&amp;gt;String&amp;lt;/code&amp;gt; object is returned. 
 * &amp;lt;p&amp;gt; 
 * It follows that for any two strings &amp;lt;code&amp;gt;s&amp;lt;/code&amp;gt; and &amp;lt;code&amp;gt;t&amp;lt;/code&amp;gt;, 
 * &amp;lt;code&amp;gt;s.intern()&amp;amp;nbsp;==&amp;amp;nbsp;t.intern()&amp;lt;/code&amp;gt; is &amp;lt;code&amp;gt;true&amp;lt;/code&amp;gt; 
 * if and only if &amp;lt;code&amp;gt;s.equals(t)&amp;lt;/code&amp;gt; is &amp;lt;code&amp;gt;true&amp;lt;/code&amp;gt;. 
 * &amp;lt;p&amp;gt; 
 * All literal strings and string-valued constant expressions are 
 * interned. String literals are defined in section 3.10.5 of the 
 * &amp;lt;cite&amp;gt;The Java&amp;amp;trade; Language Specification&amp;lt;/cite&amp;gt;. 
 * 
 * @return  a string that has the same contents as this string, but is 
 *          guaranteed to be from a pool of unique strings. 
 */  
public native String intern();  
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;String#intern&lt;/code&gt;方法中看到，这个方法是一个 native 的方法，但注释写的非常明了。“如果常量池中存在当前字符串, 就会直接返回当前字符串. 如果常量池中没有此字符串, 会将此字符串放入常量池中后, 再返回”。&lt;/p&gt;
&lt;p&gt;关于其详细的分析可以参考：美团：&lt;a href=&quot;https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html&quot;&gt;深入解析String#intern&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;珠玉在前，所以本文着重就分析下intern方法在&lt;code&gt;JDK&lt;/code&gt;不同版本下的差异，首先我们要知道引起差异的原因是因为&lt;strong&gt;&lt;code&gt;JDK1.7及之后&lt;/code&gt;将字符串常量池从永久代挪到了堆中。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我这里就以美团文章中的示例代码来进行分析，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static void main(String[] args) {
    String s = new String(&quot;1&quot;);
    s.intern();
    String s2 = &quot;1&quot;;
    System.out.println(s == s2);

    String s3 = new String(&quot;1&quot;) + new String(&quot;1&quot;);
    s3.intern();
    String s4 = &quot;11&quot;;
    System.out.println(s3 == s4);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打印结果是&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;jdk6 下&lt;code&gt;false false&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;jdk7 下&lt;code&gt;false true&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在美团的文章中已经对这个结果做了详细的解释，接下来我就用我的图解方式再分析一波这个过程&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;jdk6 执行流程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一步：&lt;/strong&gt;执行 &lt;code&gt;String s = new String(&quot;1&quot;)&lt;/code&gt;，要清楚这行代码的执行过程，我们还是得从字节码入手，这行代码对应的字节码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;  public static void main(java.lang.String[]);
    Code:
       0: new           #2                  // class java/lang/String
       3: dup
       4: ldc           #3                  // String 1
       6: invokespecial #4                  // Method java/lang/String.&quot;&amp;lt;init&amp;gt;&quot;:(Ljava/lang/String;)V
       9: astore_1
      10: return

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;new&lt;/code&gt; ：创建了一个类的实例（还没有调用构造器函数），并将其引用压入操作数栈顶&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dup&lt;/code&gt;：复制栈顶数值并将复制值压入栈顶，这是因为&lt;code&gt;invokespecial&lt;/code&gt;跟&lt;code&gt;astore_1&lt;/code&gt;各需要消耗一个引用&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ldc&lt;/code&gt;：解析常量池符号引用，将实际的直接引用压入操作数栈顶&lt;/p&gt;
&lt;p&gt;&lt;code&gt;invokespecial&lt;/code&gt;：弹出此时栈顶的常量引用及对象引用，执行&lt;code&gt;invokespecial&lt;/code&gt;指令，调用构造函数&lt;/p&gt;
&lt;p&gt;&lt;code&gt;astore_1&lt;/code&gt;：将此时操作数栈顶的元素弹出，赋值给局部变量表中1号元素（0号元素存的是main函数的参数）&lt;/p&gt;
&lt;p&gt;我们可以将上面整个过程分为两个阶段&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;解析常量&lt;/li&gt;
&lt;li&gt;调用构造函数创建对象并返回引用&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在解析常量的过程中，因为该字符串常量是第一次解析，所以会先在永久代中创建一个字符串实例对象，并将其引用添加到字符串常量池中。此时内存状态如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vd3hfY2MzNDdiZTY5Ni9ibG9nSW1hZ2UvcmF3L21hc3Rlci9pbWFnZS0yMDIwMDYxNzAxNTExOTg4NS5wbmc?x-oss-process=image/format,png&quot; alt=&quot;image-20200617015119885&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当真正通过new方式创建对象完成后，对应的内存状态如下，因为在分析&lt;code&gt;class文件中的常量池&lt;/code&gt;的时候已经对栈区做了详细的分析，所以这里就省略一些细节了，在执行完这行代码后，栈区存在一个引用，指向 了堆区的一个字符串实例内存状态对应如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vd3hfY2MzNDdiZTY5Ni9ibG9nSW1hZ2UvcmF3L21hc3Rlci9pbWFnZS0yMDIwMDYxNzAxNTMzMTA0MC5wbmc?x-oss-process=image/format,png&quot; alt=&quot;image-20200617015331040&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二步：&lt;/strong&gt;紧接着，我们调用了s的intern方法，对应代码就是 &lt;code&gt;s.intern()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;当intern方法执行时，因为此时字符串常量池中已经存在了一个字面量信息跟s相同的字符串的引用，所以此时内存状态不会发生任何改变。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第三步：&lt;/strong&gt;执行&lt;code&gt;String s2 = &quot;1&quot;&lt;/code&gt;,此时因为常量池中已经存在了字面量1的对应字符串实例的引用，所以，这里就直接返回了这个引用并且赋值给了局部变量s2。对应的内存状态如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vd3hfY2MzNDdiZTY5Ni9ibG9nSW1hZ2UvcmF3L21hc3Rlci9pbWFnZS0yMDIwMDYxNzAxNTczODUyMC5wbmc?x-oss-process=image/format,png&quot; alt=&quot;image-20200617015738520&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到这里就很清晰了，s跟s2指向两个不同的对象，所以s==s2肯定是false嘛~&lt;/p&gt;
&lt;p&gt;如果看过美团那篇文章的同学可能会有些疑惑，我在图中对常量池的描述跟美团文章图中略有差异，在美团那篇文章中，直接将具体的字符串实例放到了字符串常量池中，而在我上面的图中，字符串常量池存的永远时引用，它的图是这样画的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vd3hfY2MzNDdiZTY5Ni9ibG9nSW1hZ2UvcmF3L21hc3Rlci9pbWFnZS0yMDIwMDYxNzAxMDc0NDI1MC5wbmc?x-oss-process=image/format,png&quot; alt=&quot;image-20200617010744250&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;就我查阅的资料而言，我个人不赞同这种说法，常量池中应该保存的仅仅是引用。关于这个问题，我已经向美团的团队进行了留言，也请大佬出来纠错！&lt;/p&gt;
&lt;p&gt;接着我们分析s3跟s4，对应的就是这几行代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;String s3 = new String(&quot;1&quot;) + new String(&quot;1&quot;);
s3.intern();
String s4 = &quot;11&quot;;
System.out.println(s3 == s4);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们一行行分析，看看执行完后，内存的状态是什么样的&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一步：&lt;/strong&gt;&lt;code&gt;String s3 = new String(&quot;1&quot;) + new String(&quot;1&quot;)&lt;/code&gt;，执行完成后，堆区多了两个匿名对象，这个我们不用多关注，另外堆区还多了一个字面量为11的字符串实例，并且栈中存在一个引用指向这个实例&lt;/p&gt;
&lt;p&gt;[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-NVeeWKoO-1592334452491)(upload\image-20200617020742618.png)]&lt;/p&gt;
&lt;p&gt;实际上上图中还少了一个匿名的&lt;code&gt;StringBuilder&lt;/code&gt;的对象，这是因为当我们在进行字符串拼接时，编译器默认会创建一个&lt;code&gt;StringBuilder&lt;/code&gt;对象并调用其&lt;code&gt;append&lt;/code&gt;方法来进行拼接，最后再调用其&lt;code&gt;toString&lt;/code&gt;方法来转换成一个字符串，&lt;code&gt;StringBuilder&lt;/code&gt;的&lt;code&gt;toString&lt;/code&gt;方法其实就是new一个字符串&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public String toString() {
    // Create a copy, don't share the array
    return new String(value, 0, count);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这也是为什么在图中会说在堆上多了一个字面量为11的字符串实例的原因，因为实际上就是new出来的嘛！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二步：&lt;/strong&gt;&lt;code&gt;s3.intern()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;调用&lt;code&gt;intern&lt;/code&gt;方法后，因为字符串常量池中目前没有11这个字面量对应的字符串实例的应用，所以JVM会先从堆区复制一个字符串实例到永久代中，再将其引用添加到字符串常量池中，最终的内存状态就如下所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vd3hfY2MzNDdiZTY5Ni9ibG9nSW1hZ2UvcmF3L21hc3Rlci9pbWFnZS0yMDIwMDYxNzAyMTQyOTM5My5wbmc?x-oss-process=image/format,png&quot; alt=&quot;image-20200617021429393&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第三步：&lt;/strong&gt;&lt;code&gt;String s4 = &quot;11&quot;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这应该没啥好说的了吧，常量池中有了，直接指向对应的字符串实例&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vd3hfY2MzNDdiZTY5Ni9ibG9nSW1hZ2UvcmF3L21hc3Rlci9pbWFnZS0yMDIwMDYxNzAyMjMzNzU5Mi5wbmc?x-oss-process=image/format,png&quot; alt=&quot;image-20200617022337592&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到这里可以发现，s3跟s4指向的根本就是两个不同的对象，所以也返回false&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;jdk7 执行流程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在jdk1.7中，s跟s2的执行结果还是一样的，这是因为 &lt;code&gt;String s = new String(&quot;1&quot;)&lt;/code&gt;这行代码本身就创建了两个字符串对象，一个属于被常量池引用的驻留字符串，而另外一个只是堆上的一个普通字符串对象。跟1.6的区别在于，1.7中的驻留字符串位于堆上，而1.6中的位于方法区中，但是本质上它们还是两个不同的对象，在下面代码执行完后&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    String s = new String(&quot;1&quot;);
    s.intern();
    String s2 = &quot;1&quot;;
    System.out.println(s == s2);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;内存状态为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vd3hfY2MzNDdiZTY5Ni9ibG9nSW1hZ2UvcmF3L21hc3Rlci9pbWFnZS0yMDIwMDYxNzAyMzMwNDg2MC5wbmc?x-oss-process=image/format,png&quot; alt=&quot;image-20200617023304860&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是对于s3跟s4确不同了，因为在jdk1.7中不会再去复制字符串实例了，在intern方法执行时在发现堆上有对应的对象之后，直接将这个对应的引用添加到字符串常量池中，所以代码执行完，内存状态对应如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vd3hfY2MzNDdiZTY5Ni9ibG9nSW1hZ2UvcmF3L21hc3Rlci9pbWFnZS0yMDIwMDYxNzAyMzgzMjc4My5wbmc?x-oss-process=image/format,png&quot; alt=&quot;image-20200617023832783&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看到了吧，s3跟s4指向的同一个对象，这是因为intern方法执行时，直接s3这个引用复制到了常量池，之后执行&lt;code&gt;String s4= &quot;11&quot;&lt;/code&gt;的时候，直接再将常量池中的引用复制给了s4，所以s3==s4肯定为true啦。&lt;/p&gt;
&lt;p&gt;在理解了它们之间的差异之后，我们再来思考一个问题，假设我现在将代码改成这个样子，那么运行结果是什么样的呢？&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static void main(String[] args) {
    String s = new String(&quot;1&quot;);
    String sintern = s.intern();
    String s2 = &quot;1&quot;;
    System.out.println(sintern == s2);

    String s3 = new String(&quot;1&quot;) + new String(&quot;1&quot;);
    String s3intern = s3.intern();
    String s4 = &quot;11&quot;;
    System.out.println(s3intern == s4);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面这段代码运行起来结果会有差异吗？大家可以自行思考~&lt;/p&gt;
&lt;p&gt;在我们对字符串常量池有了一定理解之后会发现，其实通过&lt;code&gt;String name = &quot;dmz&quot;&lt;/code&gt;这行代码申明一个字符串，实际的执行逻辑就像下面这段伪代码所示&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
  * 这段代码逻辑类比于
  * &amp;lt;code&amp;gt;String s = &quot;字面量&quot;&amp;lt;/code&amp;gt;;这种方式申明一个字符串
  * 其中字面量就是在&quot;&quot;中的值
  *
  */
public String declareString(字面量) {
    String s;
    // 这是一个伪方法，标明会根据字面量的值到字符串值中查找是否存在对应String实例的引用
    s = findInStringTable(字面量);
    // 说明字符串池中已经存在了这个引用，那么直接返回
    if (s != null) {
        return s;
    }
    // 不存在这个引用，需要新建一个字符串实例，然后调用其intern方法将其拘留到字符串池中，
    // 最后返回这个新建字符串的引用
    s = new String(字面量);
    // 调用intern方法，将创建好的字符串放入到StringTable中,
    // 类似就是调用StringTable.add(s)这也的一个伪方法
    s.intern();
    return s;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;按照这个逻辑，我们将我们将上面思考题中的所有字面量进行替换，会发现不管在哪个版本中结果都应该返回true。&lt;/p&gt;
&lt;h2 id=&quot;运行时常量池&quot;&gt;运行时常量池&lt;/h2&gt;
&lt;h3 id=&quot;位置在哪？-3&quot;&gt;位置在哪？&lt;/h3&gt;
&lt;p&gt;位于方法区中，1.6在永久代，1.7在元空间中，永久代跟元空间都是对方法区的实现&lt;/p&gt;
&lt;h3 id=&quot;用来干什么？&quot;&gt;用来干什么？&lt;/h3&gt;
&lt;p&gt;jvm在执行某个类的时候，必须经过&lt;strong&gt;加载、连接、初始化&lt;/strong&gt;，而连接又包括验证# 位置在哪？&lt;/p&gt;
&lt;p&gt;位于方法区中，1.6在永久代，1.7在元空间中，永久代跟元空间都是对方法区的实现&lt;/p&gt;
&lt;h2 id=&quot;用来干什么？-2&quot;&gt;用来干什么？&lt;/h2&gt;
&lt;p&gt;jvm在执行某个类的时候，必须经过&lt;strong&gt;加载、连接、初始化&lt;/strong&gt;，而连接又包括验证、准备、解析三个阶段。而当类加载到内存中后，&lt;strong&gt;jvm就会将class常量池中的内容存放到运行时常量池中&lt;/strong&gt;，由此可知，&lt;strong&gt;运行时常量池也是每个类都有一个&lt;/strong&gt;。在上面我也说了，class常量池中存的是字面量和符号引用，也就是说他们存的并不是对象的实例，而是对象的符号引用值。而经过解析（resolve）之后，也就是把符号引用替换为直接引用，&lt;strong&gt;解析的过程会去查询全局字符串池，也就是我们上面所说的&lt;code&gt;StringTable&lt;/code&gt;，以保证运行时常量池所引用的字符串与全局字符串池中所引用的是一致的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;所以简单来说，&lt;strong&gt;运行时常量池就是用来存放class常量池中的内容的。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们将三者进行一个比较&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vd3hfY2MzNDdiZTY5Ni9ibG9nSW1hZ2UvcmF3L21hc3Rlci9pbWFnZS0yMDIwMDYxNzAyNTcyMTU4Ni5wbmc?x-oss-process=image/format,png&quot; alt=&quot;image-20200617025721586&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 环境1.7及以上
public class Clazz {
    public static void main(String[] args) {
        String s1 = new StringBuilder().append(&quot;ja&quot;).append(&quot;va1&quot;).toString();
        String s2 = s1.intern();
        System.out.println(s1==s2);
        
        String s5 = &quot;dmz&quot;;
        String s3 = new StringBuilder().append(&quot;d&quot;).append(&quot;mz&quot;).toString();
        String s4 = s3.intern();
        System.out.println(s3 == s4);

        String s7 = new StringBuilder().append(&quot;s&quot;).append(&quot;pring&quot;).toString();
        String s8 = s7.intern();
        String s6 = &quot;spring&quot;;
        System.out.println(s7 == s8);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;答案是true,false,true。大家可以仔细思考为什么，如有疑惑可以给我留言，或者进群交流！&lt;/p&gt;
&lt;p&gt;如果本文对你有帮助的话，记得点个赞吧！也欢迎关注我的公众号，微信搜索：程序员DMZ，或者扫描下方二维码，跟着我一起认认真真学Java,踏踏实实做一个coder。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vd3hfY2MzNDdiZTY5Ni9ibG9nSW1hZ2UvcmF3L21hc3Rlci8lRTUlODUlQUMlRTQlQkMlOTclRTUlOEYlQjcuanBn?x-oss-process=image/format,png&quot; alt=&quot;公众号&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我叫DMZ，一个在学习路上匍匐前行的小菜鸟！&lt;/p&gt;
&lt;p&gt;参考文章：&lt;/p&gt;
&lt;p&gt;R大博文：&lt;a href=&quot;https://www.iteye.com/blog/rednaxelafx-774673&quot;&gt;请别再拿“String s = new String(&quot;xyz&quot;);创建了多少个String实例”来面试了吧&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;R大知乎回答：&lt;a href=&quot;https://www.zhihu.com/question/57109429/answer/151717241&quot;&gt;JVM 常量池中存储的是对象还是引用呢？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://tangxman.github.io/2015/07/27/the-difference-of-java-string-pool/&quot;&gt;Java中几种常量池的区分&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/1b61feb2e336&quot;&gt;方法区，永久代和元空间&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;美团：&lt;a href=&quot;https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html&quot;&gt;深入解析String#intern&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;参考书籍：&lt;/p&gt;
&lt;p&gt;《深入理解Java虚拟机》第二版&lt;/p&gt;
&lt;p&gt;《深入理解Java虚拟机》第三版&lt;/p&gt;
&lt;p&gt;《Java虚拟机规范》&lt;/p&gt;
</description>
<pubDate>Tue, 16 Jun 2020 19:10:00 +0000</pubDate>
<dc:creator>程序员DMZ</dc:creator>
<og:description>从一道面试题开始 看到这个标题，你肯定以为我又要讲这道面试题了 // 这行代码创建了几个对象？ String s3 = new String(&amp;amp;quot;1&amp;amp;quot;); 是的，没错</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/daimzh/p/13150192.html</dc:identifier>
</item>
</channel>
</rss>