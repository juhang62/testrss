<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Spring Boot 之订制 logo - 静默虚空</title>
<link>http://www.cnblogs.com/jingmoxukong/p/10159493.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jingmoxukong/p/10159493.html</guid>
<description>&lt;p&gt;Spring Boot 启动时默认会显示以下 logo：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::        (v2.1.1.RELEASE)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实际上，Spring Boot 支持自定义 logo 的功能。&lt;/p&gt;
&lt;p&gt;让我们来看看如何实现的。&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;只要你在 &lt;code&gt;resources&lt;/code&gt; 目录下放置名为 &lt;code&gt;banner.txt&lt;/code&gt;、&lt;code&gt;banner.gif&lt;/code&gt; 、&lt;code&gt;banner.jpg&lt;/code&gt; 或 &lt;code&gt;banner.png&lt;/code&gt; 的文件，Spring Boot 会自动加载，将其作为启动时打印的 logo。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对于文本文件，Spring Boot 会将其直接输出。&lt;/li&gt;
&lt;li&gt;对于图像文件（ &lt;code&gt;banner.gif&lt;/code&gt; 、&lt;code&gt;banner.jpg&lt;/code&gt; 或 &lt;code&gt;banner.png&lt;/code&gt; ），Spring Boot 会将图像转为 ASCII 字符，然后输出。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;变量&quot;&gt;变量&lt;/h3&gt;
&lt;p&gt;banner.txt 文件中还可以使用变量来设置字体、颜色、版本号。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;9.6678966789668&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;${application.version}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;MANIFEST.MF&lt;/code&gt; 中定义的版本。如：&lt;code&gt;1.0&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;${application.formatted-version}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;MANIFEST.MF&lt;/code&gt; 中定义的版本，并添加一个 &lt;code&gt;v&lt;/code&gt; 前缀。如：&lt;code&gt;v1.0&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;${spring-boot.version}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Spring Boot 版本。如：&lt;code&gt;2.1.1.RELEASE&lt;/code&gt;.&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;${spring-boot.formatted-version}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Spring Boot 版本，并添加一个 &lt;code&gt;v&lt;/code&gt; 前缀。如：&lt;code&gt;v2.1.1.RELEASE&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5.265306122449&quot;&gt;&lt;td&gt;&lt;code&gt;${Ansi.NAME}&lt;/code&gt; (or &lt;code&gt;${AnsiColor.NAME}&lt;/code&gt;, &lt;code&gt;${AnsiBackground.NAME}&lt;/code&gt;, &lt;code&gt;${AnsiStyle.NAME}&lt;/code&gt;)&lt;/td&gt;
&lt;td&gt;ANSI 颜色、字体。更多细节，参考：&lt;a href=&quot;https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/ansi/AnsiPropertySource.java&quot;&gt;&lt;code&gt;AnsiPropertySource&lt;/code&gt;&lt;/a&gt;。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;${application.title}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;MANIFEST.MF&lt;/code&gt; 中定义的应用名。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;在 Spring Boot 项目中的 &lt;code&gt;resources&lt;/code&gt; 目录下添加一个名为 banner.txt 的文件，内容如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;${AnsiColor.BRIGHT_YELLOW}${AnsiStyle.BOLD}
 ________  ___  ___  ________   ___       __   ___  ___
|\   ___ \|\  \|\  \|\   ___  \|\  \     |\  \|\  \|\  \
\ \  \_|\ \ \  \\\  \ \  \\ \  \ \  \    \ \  \ \  \\\  \
 \ \  \ \\ \ \  \\\  \ \  \\ \  \ \  \  __\ \  \ \  \\\  \
  \ \  \_\\ \ \  \\\  \ \  \\ \  \ \  \|\__\_\  \ \  \\\  \
   \ \_______\ \_______\ \__\\ \__\ \____________\ \_______\
    \|_______|\|_______|\|__| \|__|\|____________|\|_______|
${AnsiBackground.WHITE}${AnsiColor.RED}${AnsiStyle.UNDERLINE}
:: Spring Boot ::             (v${spring-boot.version})
:: Spring Boot Tutorial ::    (v1.0.0)&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注：&lt;code&gt;${}&lt;/code&gt; 设置字体颜色的变量之间不能换行或空格分隔，否则会导致除最后一个变量外，都不生效。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;启动应用后，控制台将打印如下 logo：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://dunwu.test.upcdn.net/snap/20181221231330.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;推荐两个生成字符画的网站，可以将生成的字符串放入这个&lt;code&gt;banner.txt&lt;/code&gt; 文件：&lt;/p&gt;
&lt;h3 id=&quot;配置&quot;&gt;配置&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;application.properties&lt;/code&gt; 中与 Banner 相关的配置：&lt;/p&gt;
&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;# banner 模式。有三种模式：console/log/off
# console 打印到控制台（通过 System.out）
# log - 打印到日志中
# off - 关闭打印
spring.main.banner-mode = off
# banner 文件编码
spring.banner.charset = UTF-8
# banner 文本文件路径
spring.banner.location = classpath:banner.txt
# banner 图像文件路径（可以选择 png,jpg,gif 文件）
spring.banner.image.location = classpath:banner.gif
used).
# 图像 banner 的宽度（字符数）
spring.banner.image.width = 76
# 图像 banner 的高度（字符数）
spring.banner.image.height =
# 图像 banner 的左边界（字符数）
spring.banner.image.margin = 2
# 是否将图像转为黑色控制台主题
spring.banner.image.invert = false&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然，你也可以在 YAML 文件中配置，例如：&lt;/p&gt;
&lt;pre class=&quot;yml&quot;&gt;
&lt;code&gt;spring:
  main:
    banner-mode: off&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;编程&quot;&gt;编程&lt;/h3&gt;
&lt;p&gt;默认，Spring Boot 会注册一个 &lt;code&gt;SpringBootBanner&lt;/code&gt; 的单例 Bean，用来负责打印 Banner。&lt;/p&gt;
&lt;p&gt;如果想完全个人定制 Banner，可以这么做：先实现 &lt;code&gt;org.springframework.boot.Banner#printBanner&lt;/code&gt; 接口来自己定制 Banner。在将这个 Banner 通过 &lt;code&gt;SpringApplication.setBanner(…)&lt;/code&gt; 方法注入 Spring Boot。&lt;/p&gt;
&lt;h2 id=&quot;源码&quot;&gt;源码&lt;/h2&gt;
&lt;p&gt;完整示例：&lt;a href=&quot;https://github.com/dunwu/spring-boot-tutorial/tree/master/codes/core/sbe-core-banner&quot;&gt;源码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用方法：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;mvn clean package
cd target
java -jar sbe-core-banner.jar&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;引申和引用&quot;&gt;引申和引用&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;引申&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 21 Dec 2018 15:25:00 +0000</pubDate>
<dc:creator>静默虚空</dc:creator>
<og:description>Spring Boot 之订制 logo &lt;! TOC depthFrom:2 depthTo:3</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jingmoxukong/p/10159493.html</dc:identifier>
</item>
<item>
<title>论文笔记：语音情感识别（四）语音特征之声谱图，log梅尔谱，MFCC，deltas - PilgrimHui</title>
<link>http://www.cnblogs.com/liaohuiqiang/p/10159429.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liaohuiqiang/p/10159429.html</guid>
<description>&lt;p&gt;一：&lt;strong&gt;原始信号&lt;/strong&gt;&lt;br/&gt;从音频文件中读取出来的原始语音信号通常称为raw waveform，是一个一维数组，长度是由音频长度和采样率决定，比如采样率Fs为16KHz，表示一秒钟内采样16000个点，这个时候如果音频长度是10秒，那么raw waveform中就有160000个值，值的大小通常表示的是振幅。&lt;/p&gt;
&lt;p&gt;二：&lt;strong&gt;（线性）声谱图&lt;/strong&gt;&lt;br/&gt;（1）对原始信号进行分帧加窗后，可以得到很多帧，对每一帧做FFT（快速傅里叶变换），傅里叶变换的作用是把时域信号转为频域信号，把每一帧FFT后的频域信号（频谱图）在时间上堆叠起来就可以得到声谱图，其直观理解可以形象地表示为以下几个图，图源见参考资料[1]。&lt;br/&gt;（2）有些论文提到的DCT（离散傅里叶变换）和STFT（短时傅里叶变换）其实是差不多的东西。STFT就是对一系列加窗数据做FFT。而DCT跟FFT的关系就是：FFT是实现DCT的一种快速算法。&lt;br/&gt;（3）FFT有个参数N，表示对多少个点做FFT，如果一帧里面的点的个数小于N就会zero-padding到N的长度。对一帧信号做FFT后会得到N点的复数，这个点的模值就是该频率值下的幅度特性。每个点对应一个频率点，某一点n（n从1开始）表示的频率为&lt;span class=&quot;math inline&quot;&gt;\(F_n = (n-1)*Fs/N\)&lt;/span&gt;，第一个点（n=1，Fn等于0）表示直流信号，最后一个点N的下一个点（n=N+1，Fn=Fs时，实际上这个点是不存在的）表示采样频率Fs。&lt;br/&gt;（4）FFT后我们可以得到N个频点，频率间隔（也叫频率分辨率或）为 Fs / N，比如，采样频率为16000，N为1600，那么FFT后就会得到1600个点，频率间隔为10Hz，FFT得到的1600个值的模可以表示1600个频点对应的振幅。因为FFT具有对称性，当N为偶数时取N/2+1个点，当N为奇数时，取(N+1)/2个点，比如N为512时最后会得到257个值。&lt;br/&gt;（5）用python_speech_feature库时可以看到有三种声谱图，包括振幅谱，功率谱，log功率谱。振幅谱就是fft后取绝对值。功率谱就是在振幅谱的基础上平方然后除以N。log功率谱就是在功率谱的基础上取10倍lg，然后减去最大值。得到声谱图矩阵后可以通过matplotlib来画图。&lt;br/&gt;（6）常用的声谱图都是STFT得到的，另外也有用CQT（constant-Q transform）得到的，为了区分，将它们分别称为STFT声谱图和CQT声谱图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1160281/201812/1160281-20181221224530922-479480973.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1160281/201812/1160281-20181221224541923-1780314401.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1160281/201812/1160281-20181221224554397-162344585.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;三：&lt;strong&gt;梅尔声谱图&lt;/strong&gt;：&lt;br/&gt;（1）人耳听到的声音高低和实际（Hz）频率不呈线性关系，用Mel频率更符合人耳的听觉特性（这正是用Mel声谱图的一个动机，由人耳听力系统启发），即在1000Hz以下呈线性分布，1000Hz以上呈对数增长，Mel频率与Hz频率的关系为&lt;span class=&quot;math inline&quot;&gt;\(f_{mel} = 2595 \cdot lg(1+\frac{f}{700Hz})\)&lt;/span&gt;，如下图所示，图源见参考资料[2]。有另一种计算方式为&lt;span class=&quot;math inline&quot;&gt;\(f_{mel} = 1125 \cdot ln(1+\frac{f}{700Hz})\)&lt;/span&gt;。下面给出一个计算Mel声谱图的例子。另，python中可以用librosa调包得到梅尔声谱图。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1160281/201812/1160281-20181221224622095-1486888859.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）假设现在用10个Mel filterbank（一些论文会用40个，如果求MFCC一般是用26个然后在最后取前13个），为了获得filterbanks需要选择一个lower频率和upper频率，用300作为lower，8000作为upper是不错的选择。如果采样率是8000Hz那么upper频率应该限制为4000。然后用公式把lower和upper转为Mel频率，我们使用上述第二个公式（ln那条），可以得到401.25Mel 和 2834.99Mel。&lt;br/&gt;（3）因为用10个滤波器，所以需要12个点来划分出10个区间，在401.25Mel和2834.99Mel之间划分出12个点，m(i) = (401.25, 622.50, 843.75, 1065.00, 1286.25, 1507.50, 1728.74, 1949.99, 2171.24, 2392.49, 2613.74, 2834.99)。&lt;br/&gt;（4）然后把这些点转回Hz频率，h(i) = (300, 517.33, 781.90, 1103.97, 1496.04, 1973.32, 2554.33, 3261.62, 4122.63, 5170.76, 6446.70, 8000)。&lt;br/&gt;（5）把这些频率转为fft bin，f(i) = floor( (N+1)*h(i)/Fs)，N为FFT长度，默认为512，Fs为采样频率，默认为16000Hz，则f(i) = (9, 16, 25, 35, 47, 63, 81, 104, 132, 165, 206, 256)。这里256刚好对应512点FFT的8000Hz。&lt;br/&gt;（6）然后创建滤波器，第一个滤波器从第一个点开始，在第二个点到达最高峰，第三个点跌回零。第二个滤波器从第二个点开始，在第三个点到达最大值，在第四个点跌回零。以此类推。滤波器的示意图如下图所示，图源见参考资料[3]。可以看到随着频率的增加，滤波器的宽度也增加。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1160281/201812/1160281-20181221224736710-1682561520.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（7）接下来给出滤波器输出的计算公式，如下所示，其中m从1到M，M表示滤波器数量，这里是10。k表示点的编号，一个fft内256个点，k从1到256，表示了fft中的256个频点（k=0表示直流信号，算进来就是257个频点，为了简单起见这里省略k=0的情况）。&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[H_m(k) = \left\{\begin{matrix} \frac{k-f(m-1)}{f(m)-f(m-1)} &amp;amp; f(m-1) \leq k \leq f(m)\\ \frac{f(m+1)-k}{f(m+1)-f(m)} &amp;amp; f(m) \leq k \leq f(m+1) \\ 0 &amp;amp; others \\ \end{matrix}\right.\]&lt;/span&gt;&lt;br/&gt;（8）最后还要乘上fft计算出来的能量谱，关于能量谱在前一节（线性）声谱图中已经讲过了。将滤波器的输出应用到能量谱后得到的就是梅尔谱，具体应用公式如下，其中&lt;span class=&quot;math inline&quot;&gt;\(|X(k)|^2\)&lt;/span&gt;表示能量谱中第k个点的能量。以每个滤波器的频率范围内的输出作为权重，乘以能量谱中对应频率的对应能量，然后把这个滤波器范围内的能量加起来。举个例子，比如第一个滤波器负责的是9和16之间的那些点（在其它范围的点滤波器的输出为0），那么只对这些点对应的频率对应的能量做加权和。&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[MelSpec(m) = \sum_{k=f(m-1)}^{f(m+1)} H_m(k) * |X(k)|^2\]&lt;/span&gt;&lt;br/&gt;（9）这样计算后，对于一帧会得到M个输出。经常会在论文中看到说40个梅尔滤波器输出，指的就是这个（实际上前面说的梅尔滤波器输出是权重H，但是这里的意思应该是将滤波器输出应用到声谱后得到的结果，根据上下文可以加以区分）。然后在时间上堆叠多个“40个梅尔滤波器输出”就得到了梅尔尺度的声谱（梅尔谱），如果再取个log，就是log梅尔谱，log-Mels。&lt;br/&gt;（10）把滤波器范围内的能量加起来，可以解决一个问题，这个问题就是人耳是很难理解两个靠的很近的线性频率（就是和梅尔频率相对应的赫兹频率）之间不同。如果把一个频率区域的能量加起来，只关心在每个频率区域有多少能量，这样人耳就比较能区分，我们希望这种方式得到的（Mel）声谱图可以更加具有辨识度。最后取log的motivation也是源于人耳的听力系统，人对声音强度的感知也不是线性的，一般来说，要使声音的音量翻倍，我们需要投入8倍的能量，为了把能量进行压缩，所以取了log，这样，当x的log要翻倍的话，就需要增加很多的x。另外一个取log的原因是为了做倒谱分析得到MFCC，具体细节见下面MFCC的介绍。&lt;/p&gt;
&lt;p&gt;四：&lt;strong&gt;MFCC&lt;/strong&gt;&lt;br/&gt;（1）MFCC，梅尔频率的倒谱系数，是广泛应用于语音领域的特征，在这之前常用的是线性预测系数Linear Prediction Coefficients（LPCs）和线性预测倒谱系数（LPCCs），特别是用在HMM上。&lt;br/&gt;（2）先说一下获得MFCC的步骤，首先分帧加窗，然后对每一帧做FFT后得到（单帧）能量谱（具体步骤见上面线性声谱图的介绍），对线性声谱图应用梅尔滤波器后然后取log得到log梅尔声谱图（具体步骤见上面梅尔声谱图的介绍），然后对log滤波能量（log梅尔声谱）做DCT，离散余弦变换（傅里叶变换的一种），然后保留第二个到第13个系数，得到的这12个系数就是MFCC。&lt;br/&gt;（3）然后再大致说说MFCC的含义，下图第一个图（图源见参考资料[1]）是语音的频谱图，峰值是语音的主要频率成分，这些峰值称为共振峰，共振峰携带了声音的辨识（相当于人的身份证）。把这些峰值平滑地连起来得到的曲线称为频谱包络，包络描述了携带声音辨识信息的共振峰，所以我们希望能够得到这个包络来作为语音特征。频谱由频谱包络和频谱细节组成，如下第二个图（图源见参考资料[1]）所示，其中log X[k]代表频谱（注意图中给出的例子是赫兹谱，这里只是举例子，实际我们做的时候通常都是用梅尔谱），log H[k]代表频谱包络，log E[k]代表频谱细节。我们要做的就是从频谱中分离得到包络，这个过程也称为倒谱分析，下面就说说倒谱分析是怎么做的。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1160281/201812/1160281-20181221224852822-1848315135.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1160281/201812/1160281-20181221224902529-1572460338.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（4）要做的其实就是对频谱做FFT，在频谱上做FFT这个操作称为逆FFT，需要注意的是我们是在频谱的log上做的，因为这样做FFT后的结果x[k]可以分解成h[k]和e[k]的和。我们先看下图（图源见参考资料[1]），对包络log H[k]做IFFT的结果，可以看成“每秒4个周期的正弦波”，于是我们在伪频率轴上的4Hz上给一个峰值，记作h[k]。对细节log E[k]做IFFT的结果，可以看成“每秒100个周期的正弦波”，于是我们在伪频率轴上的100Hz上给一个峰值，记作e[k]。对频谱log X[k]做IFFT后的结果记作x[k]，这就是我们说的倒谱，它会等于h[k]和e[k]的叠加，如下第二个图所示。我们想要得到的就是包络对应的h[k]，而h[k]是x[k]的低频部分，只需要对x[k]取低频部分就可以得到了。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1160281/201812/1160281-20181221224927630-2116898656.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1160281/201812/1160281-20181221224944430-837617222.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（5）最后再总结一下得到MFCC的步骤，求线性声谱图，做梅尔滤波得到梅尔声谱图，求个log得到log梅尔谱，做倒谱分析也就是对log X[k]做DCT得到x[k]，取低频部分就可以得到倒谱向量，通常会保留第2个到第13个系数，得到12个系数，这12个系数就是常用的MFCC。图源见参考资料[1]。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1160281/201812/1160281-20181221225011597-1988899505.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;五：&lt;strong&gt;deltas，deltas-deltas&lt;/strong&gt;&lt;br/&gt;（1）deltas和deltas-deltas，看到很多人翻译成一阶差分和二阶差分，也被称为微分系数和加速度系数。使用它们的原因是，MFCC只是描述了一帧语音上的能量谱包络，但是语音信号似乎有一些动态上的信息，也就是MFCC随着时间的改变而改变的轨迹。有证明说计算MFCC轨迹并把它们加到原始特征中可以提高语音识别的表现。&lt;br/&gt;（2）以下是deltas的一个计算公式，其中t表示第几帧，N通常取2，c指的就是MFCC中的某个系数。deltas-deltas就是在deltas上再计算以此deltas。&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[d_t = \frac{\sum_{n=1}^{N} n(c_{t+n}-c_{t-n})}{2 \sum_{n=1}^{N} n^2}\]&lt;/span&gt;&lt;br/&gt;（3）对MFCC中每个系数都做这样的计算，最后会得到12个一阶差分和12个二阶差分，我们通常在论文中看到的“MFCC以及它们的一阶差分和二阶差分”指的就是这个。&lt;br/&gt;（4）值得一提的是deltas和deltas-deltas也可以用在别的参数上来表述动态特性，有论文中是直接在log Mels上做一阶差分和二阶差分的，&lt;a href=&quot;https://www.cnblogs.com/liaohuiqiang/p/10128835.html&quot;&gt;论文笔记：语音情感识别（二）声谱图+CRNN&lt;/a&gt;中3-D Convolutional Recurrent Neural Networks with Attention Model for Speech Emotion Recognition这篇论文就是这么做的。&lt;/p&gt;
&lt;p&gt;六：&lt;strong&gt;参考资料&lt;/strong&gt;&lt;br/&gt;[1] &lt;a href=&quot;http://www.speech.cs.cmu.edu/15-492/slides/03_mfcc.pdf&quot;&gt;CMU语音课程slides&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[2] &lt;a href=&quot;http://practicalcryptography.com/miscellaneous/machine-learning/guide-mel-frequency-cepstral-coefficients-mfccs/&quot;&gt;一个MFCC的介绍教程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[3] &lt;a href=&quot;https://blog.csdn.net/xiaoding133/article/details/8106672&quot;&gt;csdn-MFCC计算过程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[4] &lt;a href=&quot;https://www.cnblogs.com/BaroC/p/4283380.html&quot;&gt;博客园-MFCC学习笔记&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 21 Dec 2018 15:04:00 +0000</pubDate>
<dc:creator>PilgrimHui</dc:creator>
<og:description>介绍最近看语音情感识别论文中用到的各种语音特征，主要是声谱图（spectrogram），log梅尔声谱图（log-mels），MFCC和一阶差分（deltas），二阶差分（deltas-deltas）</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liaohuiqiang/p/10159429.html</dc:identifier>
</item>
<item>
<title>python字典类型 - 骏马金龙</title>
<link>http://www.cnblogs.com/f-ck-need-u/p/10159432.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/f-ck-need-u/p/10159432.html</guid>
<description>&lt;h2 id=&quot;字典类型简介&quot;&gt;字典类型简介&lt;/h2&gt;
&lt;p&gt;字典(dict)是存储key/value数据的容器，也就是所谓的map、hash、关联数组。无论是什么称呼，都是键值对存储的方式。&lt;/p&gt;
&lt;p&gt;在python中，dict类型使用大括号包围：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;D = {&quot;key1&quot;: &quot;value1&quot;,
     &quot;key2&quot;: &quot;value2&quot;,
     &quot;key3&quot;: &quot;value3&quot;}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;dict对象中存储的元素没有位置顺序，所以dict不是序列，不能通过索引的方式取元素。dict是按照key进行存储的，所以需要通过key作为定位元素的依据，比如取元素或修改key对应的value。比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;D['key1']     # 得到value1
D['key2']     # 得到value2
D['key3']     # 得到value3&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;字典的结构&quot;&gt;字典的结构&lt;/h2&gt;
&lt;p&gt;dict是一个hashtable数据结构，除了数据类型的声明头部分，还主要存储了3部分数据：一个hash值，两个指针。下面详细解释dict的结构。&lt;/p&gt;
&lt;p&gt;下面是一个Dict对象：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;D = {&quot;key1&quot;: &quot;value1&quot;,
     &quot;key2&quot;: &quot;value2&quot;,
     &quot;key3&quot;: &quot;value3&quot;}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它的结构图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733013/201812/733013-20181220205655540-1699450040.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个图很容易理解，key和value一一对应，只不过这里多加了一个hash值而已。但这只是便于理解的结构，它并非正确。看源码中对dict类型的简单定义。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;typedef struct {
    /* Cached hash code of me_key. */
    Py_hash_t me_hash;
    PyObject *me_key;
    PyObject *me_value;
} PyDictKeyEntry;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从源码中可知，一个hash值，这个hash值是根据key运用内置函数hash()来计算的，占用8字节(64位机器)。除了hash值，后面两个是指针，这两个指针分别是指向key、指向value的指针，每个指针占用一个机器字长，也即是说对于64位机器各占用8字节，所以一个dict的元素，除了实际的数据占用的内存空间，还额外占用24字节的空间。&lt;/p&gt;
&lt;p&gt;所以，正确的结构图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733013/201812/733013-20181220210134909-2091965768.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于存储dict元素的时候，首先根据key计算出hash值，然后将hash值存储到dict对象中，与每个hash值同时存储的还有两个引用，分别是指向key的引用和指向value的引用。&lt;/p&gt;
&lt;p&gt;如果要从dict中取出key对应的那个记录，则首先计算这个key的hash值，然后从dict对象中查找这个hash值，能找到说明有对应的记录，于是通过对应的引用可以找到key/value数据。&lt;/p&gt;
&lt;p&gt;dict是可变的，可以删除元素、增加元素、修改元素的value。这些操作的过程与上面的过程类似，都是先hash，并根据hash值来存储或检索元素。&lt;/p&gt;
&lt;p&gt;这里需要注意的是，在python中，能hashable的数据类型都必须是不可变类型的，所以列表、集合、字典不能作为dict的key，字符串、数值、元组都可以作为dict的key(类的对象实例也可以，因为自定义类的对象默认是不可变的)。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 字符串作为key
&amp;gt;&amp;gt;&amp;gt; D = {&quot;aa&quot;:&quot;aa&quot;,&quot;bb&quot;:&quot;bb&quot;}
&amp;gt;&amp;gt;&amp;gt; D
{'aa': 'aa', 'bb': 'bb'}

# 数值作为key
&amp;gt;&amp;gt;&amp;gt; D = {1:&quot;aa&quot;,&quot;bb&quot;:&quot;bb&quot;}
&amp;gt;&amp;gt;&amp;gt; D[1]
'aa'

# 元组作为key
&amp;gt;&amp;gt;&amp;gt; D = {(1,2):&quot;aa&quot;,&quot;bb&quot;:&quot;bb&quot;}
&amp;gt;&amp;gt;&amp;gt; D
{(1, 2): 'aa', 'bb': 'bb'}

# 列表作为key，报错
&amp;gt;&amp;gt;&amp;gt; D = {[1,2]:&quot;aa&quot;,&quot;bb&quot;:&quot;bb&quot;}
Traceback (most recent call last):
  File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;
TypeError: unhashable type: 'list'&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;字典元素的顺序改变&quot;&gt;字典元素的顺序改变&lt;/h3&gt;
&lt;p&gt;因为元素存储到dict的时候，都经过hash()计算，且存储的实际上是key对应的hash值，所以dict中各个元素是无序的，或者说无法保证顺序。所以，遍历dict得到的元素结果也是无序的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# python 3.5.2
&amp;gt;&amp;gt;&amp;gt; d = {'one': 1, 'two': 2, 'three': 3, 'four': 4}
&amp;gt;&amp;gt;&amp;gt; d
{'four': 4, 'two': 2, 'three': 3, 'one': 1}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;无序是理论上的。但是在python 3.7中，已经保证了python dict中元素的顺序和插入顺序是一致的。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Changed in version 3.7: Dictionary order is guaranteed to be insertion order. This behavior was an implementation detail of CPython from 3.6.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;# python 3.7.1
&amp;gt;&amp;gt;&amp;gt; d = {'one': 1, 'two': 2, 'three': 3, 'four': 4}
&amp;gt;&amp;gt;&amp;gt; d
{'one': 1, 'two': 2, 'three': 3, 'four': 4}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;虽保证了顺序，但后面介绍dict的时候，仍然将它当作无序来解释。&lt;/p&gt;
&lt;h3 id=&quot;字典和列表的比较&quot;&gt;字典和列表的比较&lt;/h3&gt;
&lt;p&gt;python中list是元素有序存储的序列代表，dict是元素无序存储的代表。它们都可变，是python中最灵活的两种数据类型。&lt;/p&gt;
&lt;p&gt;但是：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;dict的元素检索、增删改速度快，不会随着元素增多、减少而改变。但缺点是内存占用大&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;list的元素检索、增删改速度随着元素增多会越来越慢(当然实际影响并没有多大)，但是内存占用小&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;换句话说，dict是空间换时间，list是时间换空间。&lt;/p&gt;
&lt;p&gt;其实从dict和list的数据结构上很容易可以看出dict要比list占用的内存大。不考虑存储元素的实际数据空间，list存储每个元素只需一个指针共8字节(64位机器)即可保存，而dict至少需要24字节(64位机器)。&lt;/p&gt;
&lt;h2 id=&quot;构造字典&quot;&gt;构造字典&lt;/h2&gt;
&lt;p&gt;有几种构造字典的方式：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;使用大括号包围&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;使用dict()构造方法，dict()构造有3种方式：
&lt;ul&gt;&lt;li&gt;dict(key=value)&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;dict(DICT)&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;dict(iterable)，其中iterable的每个元素必须是两元素的数据对象，例如&lt;code&gt;(&quot;one&quot;,1)&lt;/code&gt;、&lt;code&gt;[&quot;two&quot;,2]&lt;/code&gt;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;后两种都可以结合第一种方式&lt;br/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;使用dict对象的fromkey()方法&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;使用dict对象的copy()方法&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;字典解析的方式。这个在后文再解释&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; D = {}     # 空字典
&amp;gt;&amp;gt;&amp;gt; type(D)
&amp;lt;class 'dict'&amp;gt;

&amp;gt;&amp;gt;&amp;gt; D = {&quot;key1&quot;: &quot;value1&quot;,
     &quot;key2&quot;: &quot;value2&quot;,
     &quot;key3&quot;: &quot;value3&quot;}
&amp;gt;&amp;gt;&amp;gt; D
{'key1': 'value1', 'key2': 'value2', 'key3': 'value3'}

&amp;gt;&amp;gt;&amp;gt; a = dict(one=1, two=2, three=3)
&amp;gt;&amp;gt;&amp;gt; b = {'one': 1, 'two': 2, 'three': 3}
&amp;gt;&amp;gt;&amp;gt; c = dict(zip(['one', 'two', 'three'], [1, 2, 3]))
&amp;gt;&amp;gt;&amp;gt; d = dict([('two', 2), ('one', 1), ('three', 3)])
&amp;gt;&amp;gt;&amp;gt; e = dict({'three': 3, 'one': 1, 'two': 2})
&amp;gt;&amp;gt;&amp;gt; f = dict([('two', 2), ('one', 1), ('three', 3)], four=4, five=5)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;fromkey(seq,value)&lt;/code&gt;是dict的类方法，所以可直接通过dict类名来调用(当然，使用已存在的对象来调用也没有问题)。它构造的字典的key来自于给定的序列，值来自于指定的第二个参数，如果没有第二个参数，则所有key的值默认为None。所以，第二个参数是构造新dict时的默认值。&lt;/p&gt;
&lt;p&gt;例如，构造一个5元素，key全为数值的字典：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; dict.fromkeys(range(5))
{0: None, 1: None, 2: None, 3: None, 4: None}

&amp;gt;&amp;gt;&amp;gt; dict.fromkeys(range(5), &quot;aa&quot;)
{0: 'aa', 1: 'aa', 2: 'aa', 3: 'aa', 4: 'aa'}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再例如，根据已有的dict来初始化一个新的dict：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; d = dict(one=1, two=2, three=3, four=4, five=5)

&amp;gt;&amp;gt;&amp;gt; dict.fromkeys(d)
{'one': None, 'two': None, 'three': None, 'four': None, 'five': None}

&amp;gt;&amp;gt;&amp;gt; dict.fromkeys(d, &quot;aa&quot;)
{'one': 'aa', 'two': 'aa', 'three': 'aa', 'four': 'aa', 'five': 'aa'}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为key的来源可以是任意序列，所以也可以从元组、列表、字符串中获取。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; dict.fromkeys(&quot;abcd&quot;,&quot;aa&quot;)
{'a': 'aa', 'b': 'aa', 'c': 'aa', 'd': 'aa'}

&amp;gt;&amp;gt;&amp;gt; L = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]
&amp;gt;&amp;gt;&amp;gt; dict.fromkeys(L)
{'a': None, 'b': None, 'c': None, 'd': None}

&amp;gt;&amp;gt;&amp;gt; T = (&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)
&amp;gt;&amp;gt;&amp;gt; dict.fromkeys(L)
{'a': None, 'b': None, 'c': None, 'd': None}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;dict的copy()方法会根据已有字典完全拷贝成一个新的字典副本。但需要注意的是，拷贝过程是浅拷贝。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; d = {'one': 1, 'two': 2, 'three': 3, 'four': 4}
&amp;gt;&amp;gt;&amp;gt; dd = d.copy()
&amp;gt;&amp;gt;&amp;gt; dd
{'three': 3, 'one': 1, 'two': 2, 'four': 4}

&amp;gt;&amp;gt;&amp;gt; id(d[&quot;one&quot;]), id(dd[&quot;one&quot;])
(10919424, 10919424)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;操作字典&quot;&gt;操作字典&lt;/h2&gt;
&lt;p&gt;官方手册：&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#mapping-types-dict&quot; class=&quot;uri&quot;&gt;https://docs.python.org/3/library/stdtypes.html#mapping-types-dict&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;dict的增删改查&quot;&gt;dict的增删改查&lt;/h3&gt;
&lt;p&gt;通过key即可检索到元素。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; d
{'one': 1, 'two': 2, 'three': 3}

&amp;gt;&amp;gt;&amp;gt; d[&quot;one&quot;]
1

&amp;gt;&amp;gt;&amp;gt; d[&quot;four&quot;] = 4
&amp;gt;&amp;gt;&amp;gt; d
{'one': 1, 'two': 2, 'three': 3, 'four': 4}

&amp;gt;&amp;gt;&amp;gt; d[&quot;ten&quot;]
Traceback (most recent call last):
  File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;
KeyError: 'ten'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于dict类型，检索不存在的key时会报错。但如果自己去定义dict的子类，那么可以自己重写&lt;code&gt;__missing__()&lt;/code&gt;方法来决定检索的key不存在时的行为。例如，对于不存在的键总是返回None。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; d = {'one': 1, 'two': 2, 'three': 3, 'four': 4}

&amp;gt;&amp;gt;&amp;gt; class mydict(dict):
...     def __missing__(self, key):
...         return None
...

&amp;gt;&amp;gt;&amp;gt; dd = mydict(d)
&amp;gt;&amp;gt;&amp;gt; dd
{'one': 1, 'two': 2, 'three': 3, 'four': 4}
&amp;gt;&amp;gt;&amp;gt; dd[&quot;ten&quot;]
&amp;gt;&amp;gt;&amp;gt; print(dd[&quot;ten&quot;])
None&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;get(key,default)方法&lt;/strong&gt;检索dict中的元素，如果元素存在，则返回对应的value，否则返回指定的default值，如果没有指定default，且检索的key又不存在，则返回None。这正好是上面自定义dict子类的功能。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; d = {'one': 1, 'two': 2, 'three': 3, 'four': 4}

&amp;gt;&amp;gt;&amp;gt; d.get(&quot;two&quot;)
2

&amp;gt;&amp;gt;&amp;gt; d.get(&quot;six&quot;,&quot;not exists&quot;)
'not exists'
&amp;gt;&amp;gt;&amp;gt; print(d.get(&quot;six&quot;))
None&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;len()&lt;/strong&gt;函数可以用来查看字典有多少个元素：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; d
{'three': 3, 'four': 4, 'two': 2, 'one': 1}
&amp;gt;&amp;gt;&amp;gt; len(d)
4&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;setdefault(key,default)&lt;/strong&gt;方法检索并设置一个key/value，如果key已存在，则直接返回对应的value，如果key不存在，则新插入这个key并指定其value为default并返回这个default，如果没有指定default，key又不存在，则默认为None。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; d.setdefault(&quot;one&quot;)
1

&amp;gt;&amp;gt;&amp;gt; d.setdefault(&quot;five&quot;)
{'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': None}

&amp;gt;&amp;gt;&amp;gt; d.setdefault(&quot;six&quot;,6)
6
&amp;gt;&amp;gt;&amp;gt; d
{'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': None, 'six': 6}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;update(key/value)&lt;/strong&gt;方法根据给定的key/value对更新已有的键，如果键不存在则新插入。key/value的表达方式有多种，只要能表达出key/value的配对行为就可以。比如已有的dict作为参数，key=value的方式，2元素的迭代容器对象。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; d
{'one': 1, 'two': 2, 'three': 3, 'four': 4}

&amp;gt;&amp;gt;&amp;gt; d.update(five=5, six=6)   # key=value的方式
&amp;gt;&amp;gt;&amp;gt; d
{'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5, 'six': 6}

&amp;gt;&amp;gt;&amp;gt; d.update({&quot;one&quot;:11, &quot;two&quot;:22})  # dict作为参数
&amp;gt;&amp;gt;&amp;gt; d
{'one': 11, 'two': 22, 'three': 3, 'four': 4, 'five': 5, 'six': 6}

&amp;gt;&amp;gt;&amp;gt; d.update([(&quot;five&quot;,55),(&quot;six&quot;,66)])  # 列表中2元素的元组
&amp;gt;&amp;gt;&amp;gt; d
{'one': 11, 'two': 22, 'three': 3, 'four': 4, 'five': 55, 'six': 66}

&amp;gt;&amp;gt;&amp;gt; d.update(((&quot;five&quot;,55),(&quot;six&quot;,66)))  # 这些都可以
&amp;gt;&amp;gt;&amp;gt; d.update(([&quot;five&quot;,55],[&quot;six&quot;,66]))
&amp;gt;&amp;gt;&amp;gt; d.update(zip([&quot;five&quot;,&quot;six&quot;],[55,66]))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;del D[KEY]&lt;/strong&gt;可以用来根据key删除字典D中给定的元素，如果元素不存在则报错。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; d = {'one': 1, 'two': 2, 'three': 3, 'four': 4}

&amp;gt;&amp;gt;&amp;gt; del d[&quot;four&quot;]
&amp;gt;&amp;gt;&amp;gt; d
{'three': 3, 'two': 2, 'one': 1}

&amp;gt;&amp;gt;&amp;gt; del d[&quot;five&quot;]
Traceback (most recent call last):
  File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;
KeyError: 'five'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;clear()&lt;/strong&gt;方法用来删除字典中所有元素。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; d = {'three': 3, 'four': 4, 'two': 2, 'one': 1}
&amp;gt;&amp;gt;&amp;gt; d.clear()
&amp;gt;&amp;gt;&amp;gt; d
{}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;pop(key,default)&lt;/strong&gt;用来移除给定的元素并返回移除的元素。但如果元素不存在，则返回default，如果不存在且没有给定default，则报错。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; d = {'three': 3, 'four': 4, 'two': 2, 'one': 1}

&amp;gt;&amp;gt;&amp;gt; d.pop(&quot;one&quot;)
1
&amp;gt;&amp;gt;&amp;gt; d.pop(&quot;five&quot;,&quot;hello world&quot;)
'hello world'
&amp;gt;&amp;gt;&amp;gt; d.pop(&quot;five&quot;)
Traceback (most recent call last):
  File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;
KeyError: 'five'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;popitem()&lt;/strong&gt;用于移除并返回一个&lt;code&gt;(key,value)&lt;/code&gt;元组对，每调用一次移除一个元素，没元素可移除后将报错。在python 3.7中保证以LIFO的顺序移除，在此之前不保证移除顺序。&lt;/p&gt;
&lt;p&gt;例如，下面是在python 3.5中的操作时(不保证顺序)：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; d
{'three': 3, 'four': 4, 'two': 2, 'one': 1}

&amp;gt;&amp;gt;&amp;gt; d.popitem()
('three', 3)
&amp;gt;&amp;gt;&amp;gt; d.popitem()
('four', 4)
&amp;gt;&amp;gt;&amp;gt; d.popitem()
('two', 2)
&amp;gt;&amp;gt;&amp;gt; d.popitem()
('one', 1)
&amp;gt;&amp;gt;&amp;gt; d.popitem()
Traceback (most recent call last):
  File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;
KeyError: 'popitem(): dictionary is empty'&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;测试&quot;&gt;测试&lt;/h3&gt;
&lt;p&gt;通过&lt;code&gt;d[key]&lt;/code&gt;的方式检索字典中的某个元素时，如果该元素不存在将报错。使用get()方法可以指定元素不存在时的默认返回值，而不报错。而设置元素时，可用通过直接赋值的方式，也可以通过setdefault()方法来为不存在的值设置默认值。&lt;/p&gt;
&lt;p&gt;重点在于元素是否存在于字典中。上面的几种方法能在检测元素是否存在时做出对应的操作，但字典作为容器，也可以直接用&lt;code&gt;in&lt;/code&gt;和&lt;code&gt;not in&lt;/code&gt;去测试元素的存在性。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; &quot;one&quot; in d
True
&amp;gt;&amp;gt;&amp;gt; &quot;one3&quot; in d
False
&amp;gt;&amp;gt;&amp;gt; &quot;one3&quot; not in d
True&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;迭代和dict视图&quot;&gt;迭代和dict视图&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;keys()&lt;/strong&gt;返回字典中所有的key组成的视图对象；&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;values()&lt;/strong&gt;返回字典中所有value组成的视图对象；&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;items()&lt;/strong&gt;返回字典中所有(key,value)元组对组成的视图对象；&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;iter(d)&lt;/strong&gt;函数返回字典中所有key组成的可迭代对象。等价于&lt;code&gt;iter(d.keys())&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;前3个方法返回的是字典视图对象，关于这个稍后再说。先看返回结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; d
{'three': 3, 'four': 4, 'two': 2, 'one': 1}

&amp;gt;&amp;gt;&amp;gt; d.keys()
dict_keys(['three', 'four', 'two', 'one'])
&amp;gt;&amp;gt;&amp;gt; list(d.keys())
['three', 'four', 'two', 'one']

&amp;gt;&amp;gt;&amp;gt; d.values()
dict_values([3, 4, 2, 1])

&amp;gt;&amp;gt;&amp;gt; d.items()
dict_items([('three', 3), ('four', 4), ('two', 2), ('one', 1)])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;iter(d)返回的是由key组成的可迭代对象。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; iter(d)
&amp;lt;dict_keyiterator object at 0x7f0ab9c9c4f8&amp;gt;

&amp;gt;&amp;gt;&amp;gt; for i in iter(d):print(i)
...
three
four
two
one&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;既然这些都返回key、value、item组成的&quot;列表&quot;对象(视图对象)，那么可以直接拿来迭代遍历。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; for i in d.keys():
...     print(i)
...
three
four
two
one

&amp;gt;&amp;gt;&amp;gt; for i in d.values():
...     print(i)
...
3
4
2
1

&amp;gt;&amp;gt;&amp;gt; for (key,value) in d.items():
...     print(key,&quot;--&amp;gt;&quot;,value)
...
three --&amp;gt; 3
four --&amp;gt; 4
two --&amp;gt; 2
one --&amp;gt; 1&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;dict视图对象&quot;&gt;dict视图对象&lt;/h2&gt;
&lt;p&gt;keys()、values()、items()返回字典视图对象。视图对象中的数据会随着原字典的改变而改变。如果知道关系型数据库里的视图，这很容易理解。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; d
{'one': 1, 'two': 2, 'three': 3, 'four': 4}
&amp;gt;&amp;gt;&amp;gt; d.keys()
dict_keys(['one', 'two', 'three', 'four'])

&amp;gt;&amp;gt;&amp;gt; list(d.keys())
['one', 'two', 'three', 'four']&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;字典视图对象是可迭代对象，可以用来一个个地生成对应数据，但它毕竟不是列表。如果需要得到列表，只需使用list()方法构造即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; list(d.keys())
['one', 'two', 'three', 'four']&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为字典试图是可迭代对象，所以可以进行测试存在性、迭代、遍历等。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;KEY in d.keys()

for key in d.keys(): ...
for value in d.values(): ...
for (key, value) in d.items(): ...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;字典的视图对象有两个函数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;len(obj_view)：返回视图对象的长度&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;iter(obj_view)：返回视图对象对应的可迭代对象&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; len(d.keys())
4

&amp;gt;&amp;gt;&amp;gt; iter(d.keys())
&amp;lt;dict_keyiterator object at 0x000001F0A7D9A9F8&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意，字典视图对象是可迭代对象，但并不是实际的列表，所以不能使用sort方法来排序，但可以使用sorted()内置函数来排序(按照key进行排序)。&lt;/p&gt;
&lt;p&gt;最后，视图对象是随原始字典动态改变的。修改原始字典，视图也会改变。例如:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; d = {'one': 1, 'two': 2, 'three': 3, 'four': 4}

&amp;gt;&amp;gt;&amp;gt; ks = d.keys()

&amp;gt;&amp;gt;&amp;gt; del d[&quot;one&quot;]
&amp;gt;&amp;gt;&amp;gt; k
dict_keys(['two', 'three', 'four'])&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;字典迭代和解析&quot;&gt;字典迭代和解析&lt;/h2&gt;
&lt;p&gt;字典自身有迭代器，如果需要迭代key，则不需要使用keys()来间接迭代。所以下面是等价的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;for key in d:
for key in d.keys()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关于字典解析，看几个示例即可理解：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; d = {k:v for (k,v) in zip([&quot;one&quot;,&quot;two&quot;,&quot;three&quot;],[1,2,3])}
&amp;gt;&amp;gt;&amp;gt; d
{'one': 1, 'two': 2, 'three': 3}

&amp;gt;&amp;gt;&amp;gt; d = {x : x ** 2 for x in [1,2,3,4]}
&amp;gt;&amp;gt;&amp;gt; d
{1: 1, 2: 4, 3: 9, 4: 16}

&amp;gt;&amp;gt;&amp;gt; d = {x : None for x in &quot;abcde&quot;}
&amp;gt;&amp;gt;&amp;gt; d
{'a': None, 'b': None, 'c': None, 'd': None, 'e': None}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 21 Dec 2018 14:58:00 +0000</pubDate>
<dc:creator>骏马金龙</dc:creator>
<og:description>字典类型简介 字典(dict)是存储key/value数据的容器，也就是所谓的map、hash、关联数组。无论是什么称呼，都是键值对存储的方式。 在python中，dict类型使用大括号包围： dic</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/f-ck-need-u/p/10159432.html</dc:identifier>
</item>
<item>
<title>salesforce零基础学习（九十一）Facet - zero.zhang</title>
<link>http://www.cnblogs.com/zero-zyq/p/10152801.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zero-zyq/p/10152801.html</guid>
<description>&lt;p&gt;说Facet以前，我们先说一下浏览器加载解析以及渲染的过程。浏览器获取一个HTML的文件时，会按照自上向下的顺序进行解析，并在加载过程中进行渲染。对html解析成DOM树，对CSS 解析成CSS Rule树，然后通过DOM数以及CSS Rule树构造Rendering树。&lt;/p&gt;
&lt;p&gt;接下来转回Facet，Facet是什么？有哪些的使用场景呢？&lt;/p&gt;
&lt;p&gt;Facet 可以理解成一个占位符，这个占位符用于对父组件的指定的部分进行重新渲染。 很多组件都有默认的渲染，如果默认的渲染的结果不是你想要得到的结果，可以使用facet进行重新的渲染。通过Facet对默认组件进行重新渲染，从而生成你想要的Rendering树，展示你想要的自定义的UI。&lt;/p&gt;
&lt;p&gt;因为Facet是一个占位符，所以Facet不会单独的出现在外层的组件，只会作为父元素组建的一个子进行出现。当然也不是所有的元素都可以使用Facet，只有部分的组件元素可以使用Facet。Facet既可以使用在lightning中，也可以使用到classic中。Facet在classic中使用 apex:facet 组件，在lightning中使用Aura.Component。&lt;/p&gt;
&lt;p&gt;classic中Facet可以搭配的常用的父组件有：&lt;/p&gt;
&lt;p&gt;apex:dataTable /apex:actionStatus / apex:column / apex:relatedList等，不同的组件支持的不同的自定义元素位置不同，具体可以查看API。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Classic使用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Demo举例：针对Notes / Attachment related list, 标准提供的功能无法隐藏add按钮，我们可以通过facet方式对apex:relatedList进行重新渲染，从而隐藏add按钮。apex:relatedList可以对body,footer以及header进行重新渲染，demo中我们只渲染header，感兴趣的可以操作其他的部分。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/910966/201812/910966-20181220224533905-1986287832.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;apex:page &lt;/span&gt;&lt;span&gt;standardController&lt;/span&gt;&lt;span&gt;=&quot;Account&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;apex:relatedList &lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;=&quot;CombinedAttachments&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;apex:facet &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;header&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　　 　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;table&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;br/&gt;　　　　　 　　&amp;lt;&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;br/&gt;　　　　　　　 　　&amp;lt;&lt;/span&gt;&lt;span&gt;td &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;pbTitle&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;br/&gt;　　　　　　　　　 　　&amp;lt;&lt;/span&gt;&lt;span&gt;h3&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Notes and Attachments&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h3&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;br/&gt;　　　　　　　　　 &amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;br/&gt;　　　　　　　 &amp;lt;/&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;br/&gt;　　　　　 &amp;lt;/&lt;/span&gt;&lt;span&gt;table&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;br/&gt;　　　  &amp;lt;/&lt;/span&gt;&lt;span&gt;apex:facet&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;apex:relatedList&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;apex:page&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;结果展示：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/910966/201812/910966-20181220224831463-1016216710.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; Lightning使用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;lightning中我们可以通过apex:attribute作为value provider作为参数传递以及使用，有两个主要属性，一个是name，一个是type，当type声明为Aura:Component或者Aura:Component[]情况下，可以在父组件中动态传递参数进行渲染以及解析。&lt;/p&gt;
&lt;p&gt;Demo举例：动态传递参数，加载时传递参数才解析（demo来源于官方文档）。&lt;/p&gt;
&lt;p&gt; c:facetHeader：此元素组件声明了一个header的attribute，类型为Aura.Component，当父元素组件引用此元素并且赋值情况下，便可以动态的加载赋值。这里面有一个{!v.body}需要说明，针对lightning，每个aura:component都会内置一个body的属性，当父调用此元素时，此元素内部的body部分便会作为v.body进行渲染。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:component&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:attribute &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;header&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;Aura.Component[]&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;header&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{!v.header}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;aura:component&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;c:helloFacet：此元素组件引用了facetHeader元素组件，其中 Nice body!将会作为facetHeader的body内容进行渲染，我们动态的赋值了header内容进行渲染。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:component&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    See how we set the header facet.&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;c:facetHeader&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        Nice body!
        &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:set &lt;/span&gt;&lt;span&gt;attribute&lt;/span&gt;&lt;span&gt;=&quot;header&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
            Hello Header!
        &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;aura:set&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;c:facetHeader&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;aura:component&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;结果展示：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/910966/201812/910966-20181221215539427-1833193620.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;此篇只是简单的介绍了Facet的使用，Facet针对classic的组件可以进行很多的定制，比如table展示哪些固定的列，apex:actionStatus 做loading效果的起始截止样式等。感兴趣的可以自行试验，篇中有问题的欢迎提出，有不懂的欢迎留言。&lt;/p&gt;
</description>
<pubDate>Fri, 21 Dec 2018 14:05:00 +0000</pubDate>
<dc:creator>zero.zhang</dc:creator>
<og:description>说Facet以前，我们先说一下浏览器加载解析以及渲染的过程。浏览器获取一个HTML的文件时，会按照自上向下的顺序进行解析，并在加载过程中进行渲染。对html解析成DOM树，对CSS 解析成CSS Ru</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zero-zyq/p/10152801.html</dc:identifier>
</item>
<item>
<title>java实现word转pdf在线预览（前端使用PDF.js；后端使用openoffice、aspose） - ph7seven</title>
<link>http://www.cnblogs.com/ph7seven/p/10158489.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ph7seven/p/10158489.html</guid>
<description>&lt;h2&gt;背景&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　之前一直是用户点击下载word文件到本地，然后使用office或者wps打开。需求优化，要实现可以直接在线预览，无需下载到本地然后再打开。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　随后开始上网找资料，网上资料一大堆，方案也各有不同，大概有这么几种方案：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1.word转html然后转pdf&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2.Openoffice + swftools + Flexmapper + jodconverter&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3.kkFileView&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　分析之后最后决定使用Openoffice+PDF.js方式实现&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;环境搭建&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　1.安装Openoffice，下载地址：http://www.openoffice.org/download/index.html&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　安装完成之后，cmd进入安装目录执行命令：soffice &quot;-accept=socket,host=localhost,port=8100;urp;StarOffice.ServiceManager&quot; -nologo -headless -nofirststartwizard&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1083688/201812/1083688-20181221181211940-300580376.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2.PDF.js，下载地址：http://mozilla.github.io/pdf.js/&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　下载之后解压，目录结构如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1083688/201812/1083688-20181221181641482-927102260.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1083688/201812/1083688-20181221181931429-1427366086.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1083688/201812/1083688-20181221182042517-749906151.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;代码实现&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　编码方面，分前端后：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　后端：java后端使用openoffice把word文档转换成pdf文件，返回流&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　前端：把PDF.js解压后的文件加到项目中，修改对应路径，PDF.js拿到后端返回的流直接展示&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;后端&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　项目使用springboot，pom文件添加依赖&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; openoffice word转pdf &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.artofsolving&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;jodconverter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2.2.1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.openoffice&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;jurt&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;3.0.1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.openoffice&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;ridl&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;3.0.1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.openoffice&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;juh&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;3.0.1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.openoffice&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;unoil&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;3.0.1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　application.properties配置openoffice服务地址与端口&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;openoffice.host=127.0.0.1
openoffice.port=8100&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　doc文件转pdf文件&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.BufferedInputStream;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.File;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.FileInputStream;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.OutputStream;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.net.ConnectException;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.servlet.http.HttpServletResponse;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.slf4j.Logger;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.slf4j.LoggerFactory;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Value;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Controller;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.RequestMapping;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.xxx.utils.Doc2PdfUtil;

@Controller
@RequestMapping(&lt;/span&gt;&quot;/doc2PdfController&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Doc2PdfController {
    @Value(&lt;/span&gt;&quot;${openoffice.host}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String OpenOfficeHost;
    @Value(&lt;/span&gt;&quot;${openoffice.port}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer OpenOfficePort;
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Logger logger = LoggerFactory.getLogger(Doc2PdfController.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
    
    @RequestMapping(&lt;/span&gt;&quot;/doc2pdf&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doc2pdf(String fileName,HttpServletResponse response){
        File pdfFile &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        OutputStream outputStream &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        BufferedInputStream bufferedInputStream &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        
        Doc2PdfUtil doc2PdfUtil &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Doc2PdfUtil(OpenOfficeHost, OpenOfficePort);
        
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;doc转pdf，返回pdf文件&lt;/span&gt;
            pdfFile =&lt;span&gt; doc2PdfUtil.doc2Pdf(fileName);
            outputStream &lt;/span&gt;=&lt;span&gt; response.getOutputStream();
            response.setContentType(&lt;/span&gt;&quot;application/pdf;charset=UTF-8&quot;&lt;span&gt;);  
            bufferedInputStream &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; BufferedInputStream(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileInputStream(pdfFile));  
            &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt; buffBytes[] = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[1024&lt;span&gt;];  
            outputStream &lt;/span&gt;=&lt;span&gt; response.getOutputStream();  
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; read = 0&lt;span&gt;;    
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; ((read = bufferedInputStream.read(buffBytes)) != -1&lt;span&gt;) {    
                outputStream.write(buffBytes, &lt;/span&gt;0&lt;span&gt;, read);    
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ConnectException e) {
            logger.info(&lt;/span&gt;&quot;****调用Doc2PdfUtil doc转pdf失败****&quot;&lt;span&gt;);
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
            e.printStackTrace();
        }  &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(outputStream != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    outputStream.flush();
                    outputStream.close();
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                    e.printStackTrace();
                }    
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(bufferedInputStream != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    bufferedInputStream.close();
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.File;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.net.ConnectException;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.slf4j.Logger;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.slf4j.LoggerFactory;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.artofsolving.jodconverter.DocumentConverter;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.artofsolving.jodconverter.openoffice.connection.OpenOfficeConnection;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.artofsolving.jodconverter.openoffice.connection.SocketOpenOfficeConnection;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.artofsolving.jodconverter.openoffice.converter.StreamOpenOfficeDocumentConverter;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Doc2PdfUtil {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; String OpenOfficeHost; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;openOffice服务地址&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; Integer OpenOfficePort; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;openOffice服务端口&lt;/span&gt;
    
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Doc2PdfUtil(){
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Doc2PdfUtil(String OpenOfficeHost, Integer OpenOfficePort){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.OpenOfficeHost =&lt;span&gt; OpenOfficeHost;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.OpenOfficePort =&lt;span&gt; OpenOfficePort;
    }
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Logger logger = LoggerFactory.getLogger(Doc2PdfUtil.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * doc转pdf
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; pdf文件路径
     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; ConnectException
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; File doc2Pdf(String fileName) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ConnectException{
        File docFile &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; File(fileName + &quot;.doc&quot;&lt;span&gt;);
        File pdfFile &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; File(fileName + &quot;.pdf&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (docFile.exists()) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;pdfFile.exists()) {
                OpenOfficeConnection connection &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SocketOpenOfficeConnection(OpenOfficeHost, OpenOfficePort);
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    connection.connect();
                    DocumentConverter converter &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StreamOpenOfficeDocumentConverter(connection);
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;最核心的操作，doc转pdf&lt;/span&gt;
&lt;span&gt;                    converter.convert(docFile, pdfFile);
                    connection.disconnect();
                    logger.info(&lt;/span&gt;&quot;****pdf转换成功，PDF输出：&quot; + pdfFile.getPath() + &quot;****&quot;&lt;span&gt;);
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (java.net.ConnectException e) {
                    logger.info(&lt;/span&gt;&quot;****pdf转换异常，openoffice服务未启动！****&quot;&lt;span&gt;);
                    e.printStackTrace();
                    &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; e;
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (com.artofsolving.jodconverter.openoffice.connection.OpenOfficeException e) {
                    System.out.println(&lt;/span&gt;&quot;****pdf转换器异常，读取转换文件失败****&quot;&lt;span&gt;);
                    e.printStackTrace();
                    &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; e;
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
                    e.printStackTrace();
                    &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; e;
                }
            }
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            logger.info(&lt;/span&gt;&quot;****pdf转换异常，需要转换的doc文档不存在，无法转换****&quot;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; pdfFile;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;前端&lt;/h3&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1083688/201812/1083688-20181221185041587-474981928.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　把pdfjs-2.0.943-dist下的两个文件夹build、web整体加到项目中，然后把viewer.html改成viewer.jsp，并调整了位置，去掉了默认的pdf文件compressed.tracemonkey-pldi-09.pdf，将来使用我们生成的文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　viewer.jsp、viewer.js注意点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1.引用的js、css路径要修改过来&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2.viewer.jsp中调用pdf/web/viewer.js，viewer.js中配置了默认的pdf文件路径，我们要动态生成pdf，因此需要修改，在jsp中定义一个参数DEFAULT_URL，然后在js中使用它&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3.jsp中写了一个ajax获取pdf流，之后赋值给DEFAULT_URL，然后再让viewer.js去加载，因此需要把/pdf/web/viewer.js放到ajax方法后面&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　4.viewer.js中把compressed.tracemonkey-pldi-09.pdf改成我们定义的变量DEFAULT_URL；pdf.worker.js的路径修改成对应路径&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1083688/201812/1083688-20181221190244729-743341425.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1083688/201812/1083688-20181221190448959-1705410293.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1083688/201812/1083688-20181221190526935-61653889.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;%&lt;/span&gt;&lt;span&gt;@ page language&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;java&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; contentType&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/html; charset=utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    pageEncoding&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;%&lt;/span&gt;&lt;span&gt;@ taglib uri&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://java.sun.com/jsp/jstl/core&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; prefix&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;
Copyright 2012 Mozilla Foundation

Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

Adobe CMap resources are covered by their own copyright but the same license:

    Copyright 1990-2015 Adobe Systems Incorporated.

See https://github.com/adobe-type-tools/cmap-resources
&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;dir&lt;/span&gt;&lt;span&gt;=&quot;ltr&quot;&lt;/span&gt;&lt;span&gt; mozdisallowselectionprint&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;viewport&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;width=device-width, initial-scale=1, maximum-scale=1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;google&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;notranslate&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;http-equiv&lt;/span&gt;&lt;span&gt;=&quot;X-UA-Compatible&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;IE=edge&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;c:set &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt;=&quot;qtpath&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;${pageContext.request.contextPath}&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt;&lt;span&gt; qtpath &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;${qtpath}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; fileName &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;${fileName}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;PDF.js viewer&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;


    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;link &lt;/span&gt;&lt;span&gt;rel&lt;/span&gt;&lt;span&gt;=&quot;stylesheet&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;${qtpath}/res/pdf/web/viewer.css&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;


&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; This snippet is used in production (included from viewer.html) &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;link &lt;/span&gt;&lt;span&gt;rel&lt;/span&gt;&lt;span&gt;=&quot;resource&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;application/l10n&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;${qtpath}/res/pdf/web/locale/locale.properties&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt; src&lt;/span&gt;&lt;span&gt;=&quot;${qtpath}/res/js/jquery/jquery-2.1.4.min.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; DEFAULT_URL &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注意，删除的变量在这里重新定义  &lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; PDFData &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;  
    $.ajax({  
        type:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;post&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,  
        async:&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,  &lt;/span&gt;&lt;span&gt;//
&lt;/span&gt;&lt;span&gt;        mimeType: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;text/plain; charset=x-user-defined&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,  
        url:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;${qtpath}/doc2PdfController/doc2pdf&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        data:{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;fileName&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:fileName},
        success:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(data){  
           PDFData &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; data;  
        }  
    });  
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; rawLength &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; PDFData.length;  
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;转换成pdf.js能直接解析的Uint8Array类型,见pdf.js-4068  &lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; array &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Uint8Array(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArrayBuffer(rawLength));    
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(i &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;; i &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt; rawLength; i&lt;/span&gt;&lt;span&gt;++&lt;/span&gt;&lt;span&gt;) {  
      array[i] &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; PDFData.charCodeAt(i) &lt;/span&gt;&lt;span&gt;&amp;amp;&lt;/span&gt; &lt;span&gt;0xff&lt;/span&gt;&lt;span&gt;;  
    }  
    DEFAULT_URL &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; array;
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt; src&lt;/span&gt;&lt;span&gt;=&quot;${qtpath}/res/pdf/build/pdf.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt; src&lt;/span&gt;&lt;span&gt;=&quot;${qtpath}/res/pdf/web/viewer.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

  ...&lt;span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt; 效果&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1083688/201812/1083688-20181221194055303-377547294.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;分割线&lt;/h2&gt;
&lt;p&gt;------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　本以为完美的实现了doc在线预览，上测试环境后发现了一个大坑，我们的doc文件不是在本地office创建后上传的，是其他同事用freemarker ftl模板生成的，这种生成的doc文件根本不是微软标准的doc，本质是xml数据结构，openoffice拿这种文件去转换pdf文件直接就报错了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1083688/201812/1083688-20181221212943604-1657074877.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt;　　上网查资料查了半天也没找到这种问题的解决方案，想想只能是放弃openoffice改用其他方法了（freemarker ftl生成doc这个肯定是不能动的）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　看到一些博客使用word--html--pdf生成pdf，还有的使用freemarker ftl xml 生成pdf感觉还是太繁琐了，我只是想拿现有的doc（虽然是freemarker ftl生成的）转换成pdf啊&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　继续看博客查资料，看到一种方法，使用aspose把doc转换成pdf，抱着试一试的心态在本地测试了下，没想到竟然成了，感觉太意外了，aspose方法超级简单，只要导入jar包，几行代码就可以搞定，并且转换速度比openoffice要快很多。很是奇怪，这么好用这么简单的工具为什么没在我一开始搜索word转pdf的时候就出现呢&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;aspose doc转pdf&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　在maven仓库搜索aspose，然后把依赖加入pom.xml发现jar包下载不下来，没办法，最后在csdn下载aspose jar包，然后mvn deploy到仓库&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　pom.xml&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; word转pdf maven仓库没有需要本地jar包发布到私服 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.aspose.words&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;aspose-words-jdk16&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;14.9.0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.BufferedInputStream;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.File;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.FileInputStream;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.OutputStream;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.net.ConnectException;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.servlet.http.HttpServletResponse;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.slf4j.Logger;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.slf4j.LoggerFactory;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Controller;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.RequestMapping;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.xxx.utils.Doc2PdfUtil;

@Controller
@RequestMapping(&lt;/span&gt;&quot;/doc2PdfController&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Doc2PdfController {
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Logger logger = LoggerFactory.getLogger(Doc2PdfController.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
    
    @RequestMapping(&lt;/span&gt;&quot;/doc2pdf&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doc2pdf(String fileName,HttpServletResponse response){
        File pdfFile &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        OutputStream outputStream &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        BufferedInputStream bufferedInputStream &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        String docPath &lt;/span&gt;= fileName + &quot;.doc&quot;&lt;span&gt;;
        String pdfPath &lt;/span&gt;= fileName + &quot;.pdf&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            pdfFile &lt;/span&gt;=&lt;span&gt; Doc2PdfUtil.doc2Pdf(docPath, pdfPath);
            outputStream &lt;/span&gt;=&lt;span&gt; response.getOutputStream();
            response.setContentType(&lt;/span&gt;&quot;application/pdf;charset=UTF-8&quot;&lt;span&gt;);  
            bufferedInputStream &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; BufferedInputStream(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileInputStream(pdfFile));  
            &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt; buffBytes[] = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[1024&lt;span&gt;];  
            outputStream &lt;/span&gt;=&lt;span&gt; response.getOutputStream();  
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; read = 0&lt;span&gt;;    
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; ((read = bufferedInputStream.read(buffBytes)) != -1&lt;span&gt;) {    
                outputStream.write(buffBytes, &lt;/span&gt;0&lt;span&gt;, read);    
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ConnectException e) {
            logger.info(&lt;/span&gt;&quot;****调用Doc2PdfUtil doc转pdf失败****&quot;&lt;span&gt;);
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
            e.printStackTrace();
        }  &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(outputStream != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    outputStream.flush();
                    outputStream.close();
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                    e.printStackTrace();
                }    
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(bufferedInputStream != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    bufferedInputStream.close();
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;　　Doc2PdfUtil.java&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.ByteArrayInputStream;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.File;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.FileOutputStream;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.slf4j.Logger;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.slf4j.LoggerFactory;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.aspose.words.License;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.aspose.words.SaveFormat;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Doc2PdfUtil {
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Logger logger = LoggerFactory.getLogger(Doc2PdfUtil.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * doc转pdf
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; docPath doc文件路径，包含.doc
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; pdfPath pdf文件路径，包含.pdf
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; File doc2Pdf(String docPath, String pdfPath){
        File pdfFile &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; File(pdfPath);
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            String s &lt;/span&gt;= &quot;&amp;lt;License&amp;gt;&amp;lt;Data&amp;gt;&amp;lt;Products&amp;gt;&amp;lt;Product&amp;gt;Aspose.Total for Java&amp;lt;/Product&amp;gt;&amp;lt;Product&amp;gt;Aspose.Words for Java&amp;lt;/Product&amp;gt;&amp;lt;/Products&amp;gt;&amp;lt;EditionType&amp;gt;Enterprise&amp;lt;/EditionType&amp;gt;&amp;lt;SubscriptionExpiry&amp;gt;20991231&amp;lt;/SubscriptionExpiry&amp;gt;&amp;lt;LicenseExpiry&amp;gt;20991231&amp;lt;/LicenseExpiry&amp;gt;&amp;lt;SerialNumber&amp;gt;8bfe198c-7f0c-4ef8-8ff0-acc3237bf0d7&amp;lt;/SerialNumber&amp;gt;&amp;lt;/Data&amp;gt;&amp;lt;Signature&amp;gt;sNLLKGMUdF0r8O1kKilWAGdgfs2BvJb/2Xp8p5iuDVfZXmhppo+d0Ran1P9TKdjV4ABwAgKXxJ3jcQTqE/2IRfqwnPf8itN8aFZlV3TJPYeD3yWE7IT55Gz6EijUpC7aKeoohTb4w2fpox58wWoF3SNp6sK6jDfiAUGEHYJ9pjU=&amp;lt;/Signature&amp;gt;&amp;lt;/License&amp;gt;&quot;&lt;span&gt;;
            ByteArrayInputStream is &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ByteArrayInputStream(s.getBytes());
            License license &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; License();
            license.setLicense(is);
            com.aspose.words.Document document &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; com.aspose.words.Document(docPath);
            document.save(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileOutputStream(pdfFile),SaveFormat.PDF);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            logger.info(&lt;/span&gt;&quot;****aspose doc转pdf异常&quot;&lt;span&gt;);
            e.printStackTrace();
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; pdfFile;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　aspose-words-jdk16-14.9.0.jar下载地址&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　https://download.csdn.net/download/u013279345/10868189&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 21 Dec 2018 13:14:00 +0000</pubDate>
<dc:creator>ph7seven</dc:creator>
<og:description>java word转pdf openoffice aspose</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ph7seven/p/10158489.html</dc:identifier>
</item>
<item>
<title>HEER-Easing Embedding Learning by Comprehensive Transcription of Heterogeneous Information Networks - 超然haha</title>
<link>http://www.cnblogs.com/chaoran/p/10156564.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chaoran/p/10156564.html</guid>
<description>&lt;p&gt;来源：KDD 2018&lt;/p&gt;


&lt;p&gt;注： 若有错误，欢迎指正&lt;/p&gt;

&lt;p&gt;这篇KDD’18的文章，没有按照常规的方法将所有的node嵌入到同一的空间，因为文章提出 node 因为连接的 edge 类型（type）不同，存在不兼容（incompatibility）的特性，所以最好能够根据不同的edge type来定义不同度量空间（metric space），保持同一个度量空间下，node的兼容性。&lt;/p&gt;

&lt;h2 id=&quot;8382-1545310065917&quot;&gt;1. Abstract&lt;/h2&gt;
&lt;p&gt;在本文中，作者认为异构信息网络（HIN）中隐含着丰富信息的同时也引入了潜在的不兼容性，为了保留HIN中丰富但可能不兼容的信息，提出对HIN的综合转录问题。还需要提供一种易于使用的方法来有效利用 HIN 中的信息。本文提出HEER方法： 通过对 HIN 的边缘表示，与正确学习的异构度量相结合。&lt;/p&gt;
&lt;h2 id=&quot;5730-1545310070892&quot;&gt;2. Introduction&lt;/h2&gt;
&lt;p&gt;网络嵌入学习节点的低维表示可以在原始网络中编码其语义信息，且容易和机器学习等方法相结合，可用于分类、链路预测。近来，研究人员证明了HIN 嵌入在作者识别等方面的有效性。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/31627de5e641db78150a36f76ef24cb1/xmlnote/B9D3A9B6BC524393B7515629D2D7881C/6168&quot; alt=&quot;&quot; width=&quot;634&quot; height=&quot;286&quot; data-media-type=&quot;image&quot; data-original=&quot;https://note.youdao.com/yws/public/resource/31627de5e641db78150a36f76ef24cb1/xmlnote/B9D3A9B6BC524393B7515629D2D7881C/6168&quot;/&gt;&lt;/div&gt;
&lt;p&gt;图 1 Network Embedding&lt;/p&gt;

&lt;p&gt;HIN 异构性不仅包含丰富的信息，还有潜在的不兼容的语义。传统的同构网络嵌入不论其类型，均等的处理所有节点和边，不会捕捉 HIN 的异质性。&lt;/p&gt;
&lt;p&gt;如图1，stan，musical，Ang Lee是不同类型的节点，因为musical和Ang Lee的embedding距离很远，会导致stan无法同时和两个embedding同时很近，因此需要学习两个不同的度量空间，从而stan分别在两个度量空间中与对应的node距离很近。&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/31627de5e641db78150a36f76ef24cb1/xmlnote/276BE00F2B5D4721B7EF438D1F041F4D/6145&quot; alt=&quot;&quot; width=&quot;542&quot; height=&quot;478&quot; data-media-type=&quot;image&quot; data-original=&quot;https://note.youdao.com/yws/public/resource/31627de5e641db78150a36f76ef24cb1/xmlnote/276BE00F2B5D4721B7EF438D1F041F4D/6145&quot;/&gt;&lt;/div&gt;
&lt;p&gt;图 2 异质网络嵌入学习中的不兼容现象&lt;/p&gt;

&lt;p&gt;为解决该问题，本文在计算相似度 s 时提出度量向量 μ&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/31627de5e641db78150a36f76ef24cb1/xmlnote/02790B01789C4459A0E85256DBF921EF/6154&quot; alt=&quot;&quot; width=&quot;477&quot; height=&quot;101&quot; data-media-type=&quot;image&quot; data-original=&quot;https://note.youdao.com/yws/public/resource/31627de5e641db78150a36f76ef24cb1/xmlnote/02790B01789C4459A0E85256DBF921EF/6154&quot;/&gt;&lt;/div&gt;
&lt;p&gt;该度量向量μ是对不同类型的关系来进行embedding，g_{uv}是表示u,v之间的边的embedding。通过定义该相似度函数，能够获得基于不同边类型r的相似度&lt;/p&gt;

&lt;h2 id=&quot;8032-1545357380843&quot;&gt;3. 嵌入 HINs 的边缘表示（HEER）&lt;/h2&gt;
&lt;h3 id=&quot;7215-1545356343434&quot;&gt;3.1. 方法思想&lt;/h3&gt;
&lt;p&gt;通过边缘表示和耦合度量的可用性，得到反应边的存在和类型的损失函数，通过最小化损失，同时更新节点嵌入、边缘嵌入和异构度量，保持输入HIN中的异质性。对不同的不兼容程度建模，其中两个边缘类型越相似，对应的指标越相似。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;综合转录 HIN 中的嵌入信息&lt;/li&gt;
&lt;li&gt;解决 HINs 中的语义不兼容&lt;/li&gt;
&lt;li&gt;利用边缘表示和异质矩阵&lt;/li&gt;
&lt;li&gt;使用神经网络学习节点和边的嵌入表示&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;1116-1545360731209&quot;&gt;3.2. 框架结构&lt;/h3&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/31627de5e641db78150a36f76ef24cb1/xmlnote/42A86D92639A4A8A806BD2828121C9D8/6158&quot; alt=&quot;&quot; width=&quot;852&quot; height=&quot;311&quot; data-media-type=&quot;image&quot; data-original=&quot;https://note.youdao.com/yws/public/resource/31627de5e641db78150a36f76ef24cb1/xmlnote/42A86D92639A4A8A806BD2828121C9D8/6158&quot;/&gt;&lt;/div&gt;
&lt;p&gt;图 3 HEER模型框架结构&lt;/p&gt;

&lt;h4 id=&quot;9040-1545361243207&quot;&gt;HIN Embedding 定义&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;输入一个异质网络&lt;/li&gt;
&lt;/ul&gt;&lt;div&gt;           &lt;img src=&quot;https://note.youdao.com/yws/public/resource/31627de5e641db78150a36f76ef24cb1/xmlnote/D9BABFE6B7C8465194F25E23D6D9C338/6249&quot; alt=&quot;&quot; width=&quot;256&quot; height=&quot;22&quot; data-media-type=&quot;image&quot; data-original=&quot;https://note.youdao.com/yws/public/resource/31627de5e641db78150a36f76ef24cb1/xmlnote/D9BABFE6B7C8465194F25E23D6D9C338/6249&quot;/&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;通过F网络学习出node embedding&lt;/li&gt;
&lt;/ul&gt;&lt;div&gt;           &lt;img src=&quot;https://note.youdao.com/yws/public/resource/31627de5e641db78150a36f76ef24cb1/xmlnote/E8777A8AE18E467DBBA986F2A37376D3/6254&quot; alt=&quot;&quot; width=&quot;106&quot; height=&quot;23&quot; data-media-type=&quot;image&quot; data-original=&quot;https://note.youdao.com/yws/public/resource/31627de5e641db78150a36f76ef24cb1/xmlnote/E8777A8AE18E467DBBA986F2A37376D3/6254&quot;/&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;之后通过g函数来学习出边的embedding&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;一对节点间可能有多种类型的边，g(u,v) 包含此类关系&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div&gt;            &lt;img src=&quot;https://note.youdao.com/yws/public/resource/31627de5e641db78150a36f76ef24cb1/xmlnote/267C754A3D3D4B629BB49FEE9EEADA23/6253&quot; alt=&quot;&quot; width=&quot;170&quot; height=&quot;25&quot; data-media-type=&quot;image&quot; data-original=&quot;https://note.youdao.com/yws/public/resource/31627de5e641db78150a36f76ef24cb1/xmlnote/267C754A3D3D4B629BB49FEE9EEADA23/6253&quot;/&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;通过type之间的相似度，也就是定义的相似度函数和原始连接关系共同作为ground truth&lt;/li&gt;
&lt;li&gt;最后训练出网络参数，从而能够学到网络的嵌入模型&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;类型接近度&lt;/h4&gt;
&lt;p&gt;对于每对节点（u，v）的边缘嵌入 guv&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/31627de5e641db78150a36f76ef24cb1/xmlnote/A3AA9702C57847ED81215F9F1419F741/6252&quot; alt=&quot;&quot; width=&quot;451&quot; height=&quot;95&quot; data-media-type=&quot;image&quot; data-original=&quot;https://note.youdao.com/yws/public/resource/31627de5e641db78150a36f76ef24cb1/xmlnote/A3AA9702C57847ED81215F9F1419F741/6252&quot;/&gt;&lt;/div&gt;
&lt;p&gt;μr 为特定类型嵌入表示，兼容的边类型共享相似的 μ&lt;/p&gt;
&lt;h4&gt; &lt;/h4&gt;
&lt;h4&gt;目标函数&lt;/h4&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/31627de5e641db78150a36f76ef24cb1/xmlnote/FCB1D8869A394153915E6E9C7F20A631/6250&quot; alt=&quot;&quot; width=&quot;415&quot; height=&quot;67&quot; data-media-type=&quot;image&quot; data-original=&quot;https://note.youdao.com/yws/public/resource/31627de5e641db78150a36f76ef24cb1/xmlnote/FCB1D8869A394153915E6E9C7F20A631/6250&quot;/&gt;&lt;/div&gt;
&lt;p&gt;（ KL 测量元权重和从嵌入表示得到的相似度间的差异）&lt;/p&gt;
&lt;p&gt;将（1）代入（2）考虑所有的边类型，得到&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/31627de5e641db78150a36f76ef24cb1/xmlnote/20772BBFED7346F3AEABD15FF51BA1A0/6251&quot; alt=&quot;&quot; width=&quot;423&quot; height=&quot;69&quot; data-media-type=&quot;image&quot; data-original=&quot;https://note.youdao.com/yws/public/resource/31627de5e641db78150a36f76ef24cb1/xmlnote/20772BBFED7346F3AEABD15FF51BA1A0/6251&quot;/&gt;&lt;/div&gt;

&lt;h2 id=&quot;5189-1545378077931&quot;&gt;4. Experiment&lt;/h2&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/31627de5e641db78150a36f76ef24cb1/xmlnote/3F2CEB2A9E3B45A990713B7F0DD7F0CA/6269&quot; alt=&quot;&quot; width=&quot;520&quot; height=&quot;259&quot; data-media-type=&quot;image&quot; data-original=&quot;https://note.youdao.com/yws/public/resource/31627de5e641db78150a36f76ef24cb1/xmlnote/3F2CEB2A9E3B45A990713B7F0DD7F0CA/6269&quot;/&gt;&lt;/div&gt;

&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/31627de5e641db78150a36f76ef24cb1/xmlnote/412C6A6C284849FCA01CBB3863A248D5/6272&quot; alt=&quot;&quot; width=&quot;522&quot; height=&quot;255&quot; data-media-type=&quot;image&quot; data-original=&quot;https://note.youdao.com/yws/public/resource/31627de5e641db78150a36f76ef24cb1/xmlnote/412C6A6C284849FCA01CBB3863A248D5/6272&quot;/&gt;&lt;/div&gt;

&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/31627de5e641db78150a36f76ef24cb1/xmlnote/4C5973E6C4AE4E6A884FAAB9B325C4C7/6274&quot; alt=&quot;&quot; width=&quot;880&quot; height=&quot;183&quot; data-media-type=&quot;image&quot; data-original=&quot;https://note.youdao.com/yws/public/resource/31627de5e641db78150a36f76ef24cb1/xmlnote/4C5973E6C4AE4E6A884FAAB9B325C4C7/6274&quot;/&gt;&lt;/div&gt;
&lt;p&gt;（边缘剔除率为0.4时）&lt;/p&gt;
&lt;h2&gt;5. 总结&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;HEER模型，能够建立异构网络中不同type之间的不兼容性，这是一种新的尝试，将不兼容的性质提出并通过不同度量空间来表示。&lt;/li&gt;
&lt;li&gt;HEER模型能够同时学习网络中节点的node embedding和边的edge embedding。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;局限性&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;没有考虑更复杂的网络结构信息，而是仅仅通过相邻节点的关系来确定embedding，更复杂的关系可以通过meta-path来找到，这也可能成为该论文未来的研究方向。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU1Mjc5NTg5OQ==&amp;amp;mid=2247483890&amp;amp;idx=1&amp;amp;sn=1eacd1791a7f560e7b279fc13998e4ab&amp;amp;chksm=fbfdea66cc8a6370e301df5024414761a0ae46fe893f8f4da68e660d14feeb44cd92c2f7a8f8&amp;amp;scene=21&amp;amp;token=1524641645&amp;amp;lang=zh_CN#wechat_redirect&quot; target=&quot;_blank&quot;&gt;KDD'18|异质信息网络嵌入学习&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 21 Dec 2018 12:15:00 +0000</pubDate>
<dc:creator>超然haha</dc:creator>
<og:description>这篇KDD’18的文章，没按照常规的方法将所有的node嵌入到同一的空间，提出 node 因为连接的 edge 类型不同，存在不兼容，提出一个保存异构性的HINs综合转录的方式</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chaoran/p/10156564.html</dc:identifier>
</item>
<item>
<title>Python异常处理回顾与总结 - 奥辰</title>
<link>http://www.cnblogs.com/chenhuabin/p/10158606.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenhuabin/p/10158606.html</guid>
<description>&lt;p&gt;　　在我们调试程序时，经常不可避免地出现意料之外的情况，导致程序不得不停止运行，然后提示大堆提示信息，大多是这种情况都是由异常引起的。异常的出现一方面是因为写代码时粗心导致的语法错误，这种错误在程序编译时就可以发现；另一方面也可能是因为程序逻辑错误，这种错误往往是不可避免地，只能通过异常处理来防止程序退出。&lt;/p&gt;

&lt;p&gt;　　Python自带的异常处理机制非常强大，提供了很多内置异常类，可向用户准确反馈出错信息。Python是面向对象语言，认为一切皆对象，所以异常也是对象。Python异常处理机制中的BaseException是所有内置异常的基类，但用户定义的类并不直接继承BaseException，所有的异常类都是从Exception继承，且都在exceptions模块中定义。Python自动将所有异常名称放在内建命名空间中，所以程序不必导入exceptions模块即可使用异常。&lt;/p&gt;
&lt;p&gt;　　Python内置异常类继承层次结构如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
BaseException  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 所有异常的基类&lt;/span&gt;

 +-- SystemExit  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 解释器请求退出&lt;/span&gt;

 +-- KeyboardInterrupt  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 用户中断执行(通常是输入^C)&lt;/span&gt;

 +-- GeneratorExit  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 生成器(generator)发生异常来通知退出&lt;/span&gt;

 +-- Exception  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 常规异常的基类&lt;/span&gt;

      +-- StopIteration  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 迭代器没有更多的值&lt;/span&gt;

      +-- StopAsyncIteration  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 必须通过异步迭代器对象的__anext__()方法引发以停止迭代&lt;/span&gt;

      +-- ArithmeticError  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 各种算术错误引发的内置异常的基类&lt;/span&gt;

      |    +-- FloatingPointError  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 浮点计算错误&lt;/span&gt;

      |    +-- OverflowError  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 数值运算结果太大无法表示&lt;/span&gt;

      |    +-- ZeroDivisionError  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 除(或取模)零 (所有数据类型)&lt;/span&gt;

      +-- AssertionError  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 当assert语句失败时引发&lt;/span&gt;

      +-- AttributeError  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 属性引用或赋值失败&lt;/span&gt;

      +-- BufferError  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 无法执行与缓冲区相关的操作时引发&lt;/span&gt;

      +-- EOFError  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 当input()函数在没有读取任何数据的情况下达到文件结束条件(EOF)时引发&lt;/span&gt;

      +-- ImportError  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 导入模块/对象失败&lt;/span&gt;

      |    +-- ModuleNotFoundError  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 无法找到模块或在在sys.modules中找到None&lt;/span&gt;

      +-- LookupError  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 映射或序列上使用的键或索引无效时引发的异常的基类&lt;/span&gt;

      |    +-- IndexError  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 序列中没有此索引(index)&lt;/span&gt;

      |    +-- KeyError  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 映射中没有这个键&lt;/span&gt;

      +-- MemoryError  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 内存溢出错误(对于Python 解释器不是致命的)&lt;/span&gt;

      +-- NameError  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 未声明/初始化对象 (没有属性)&lt;/span&gt;

      |    +-- UnboundLocalError  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 访问未初始化的本地变量&lt;/span&gt;

      +-- OSError  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 操作系统错误，EnvironmentError，IOError，WindowsError，socket.error，select.error和mmap.error已合并到OSError中，构造函数可能返回子类&lt;/span&gt;

      |    +-- BlockingIOError  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 操作将阻塞对象(e.g. socket)设置为非阻塞操作&lt;/span&gt;

      |    +-- ChildProcessError  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 在子进程上的操作失败&lt;/span&gt;

      |    +-- ConnectionError  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 与连接相关的异常的基类&lt;/span&gt;

      |    |    +-- BrokenPipeError  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 另一端关闭时尝试写入管道或试图在已关闭写入的套接字上写入&lt;/span&gt;

      |    |    +-- ConnectionAbortedError  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 连接尝试被对等方中止&lt;/span&gt;

      |    |    +-- ConnectionRefusedError  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 连接尝试被对等方拒绝&lt;/span&gt;

      |    |    +-- ConnectionResetError    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 连接由对等方重置&lt;/span&gt;

      |    +-- FileExistsError  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建已存在的文件或目录&lt;/span&gt;

      |    +-- FileNotFoundError  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 请求不存在的文件或目录&lt;/span&gt;

      |    +-- InterruptedError  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 系统调用被输入信号中断&lt;/span&gt;

      |    +-- IsADirectoryError  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 在目录上请求文件操作(例如 os.remove())&lt;/span&gt;

      |    +-- NotADirectoryError  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 在不是目录的事物上请求目录操作(例如 os.listdir())&lt;/span&gt;

      |    +-- PermissionError  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 尝试在没有足够访问权限的情况下运行操作&lt;/span&gt;

      |    +-- ProcessLookupError  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 给定进程不存在&lt;/span&gt;

      |    +-- TimeoutError  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 系统函数在系统级别超时&lt;/span&gt;

      +-- ReferenceError  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; weakref.proxy()函数创建的弱引用试图访问已经垃圾回收了的对象&lt;/span&gt;

      +-- RuntimeError  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 在检测到不属于任何其他类别的错误时触发&lt;/span&gt;

      |    +-- NotImplementedError  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 在用户定义的基类中，抽象方法要求派生类重写该方法或者正在开发的类指示仍然需要添加实际实现&lt;/span&gt;

      |    +-- RecursionError  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 解释器检测到超出最大递归深度&lt;/span&gt;

      +-- SyntaxError  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Python 语法错误&lt;/span&gt;

      |    +-- IndentationError  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 缩进错误&lt;/span&gt;

      |         +-- TabError  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Tab和空格混用&lt;/span&gt;

      +-- SystemError  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 解释器发现内部错误&lt;/span&gt;

      +-- TypeError  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 操作或函数应用于不适当类型的对象&lt;/span&gt;

      +-- ValueError  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 操作或函数接收到具有正确类型但值不合适的参数&lt;/span&gt;

      |    +-- UnicodeError  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 发生与Unicode相关的编码或解码错误&lt;/span&gt;

      |         +-- UnicodeDecodeError  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Unicode解码错误&lt;/span&gt;

      |         +-- UnicodeEncodeError  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Unicode编码错误&lt;/span&gt;

      |         +-- UnicodeTranslateError  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Unicode转码错误&lt;/span&gt;

      +-- Warning  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 警告的基类&lt;/span&gt;

           +-- DeprecationWarning  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 有关已弃用功能的警告的基类&lt;/span&gt;

           +-- PendingDeprecationWarning  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 有关不推荐使用功能的警告的基类&lt;/span&gt;

           +-- RuntimeWarning  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 有关可疑的运行时行为的警告的基类&lt;/span&gt;

           +-- SyntaxWarning  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 关于可疑语法警告的基类&lt;/span&gt;

           +-- UserWarning  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 用户代码生成警告的基类&lt;/span&gt;

           +-- FutureWarning  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 有关已弃用功能的警告的基类&lt;/span&gt;

           +-- ImportWarning  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 关于模块导入时可能出错的警告的基类&lt;/span&gt;

           +-- UnicodeWarning  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 与Unicode相关的警告的基类&lt;/span&gt;

           +-- BytesWarning  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 与bytes和bytearray相关的警告的基类&lt;/span&gt;

           +-- ResourceWarning  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 与资源使用相关的警告的基类。被默认警告过滤器忽略。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　当发生异常时，我们就需要对异常进行捕获，然后进行相应的处理。使用Python异常处理机制时，把可能发生错误的语句放在try模块里，用except来处理异常，每一个try，都必须至少对应一个except。Python异常处理机制常用的几种异常捕获和处理结构如下：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;第一种：try - except&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:

    &lt;/span&gt;&amp;lt;语句&amp;gt;

&lt;span&gt;except&lt;/span&gt;&lt;span&gt;:

    &lt;/span&gt;&amp;lt;异常处理&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这种结构使用简单，但可能会引发一些设计问题：尽管使用方便，但可能捕获与程序无关、意料之外的系统异常，而且可能意外拦截其他处理器的异常。例如，在Python中，即表示系统离开调用（sys.exit()）也会出发异常，然而这种异常我们通常不需要捕获。所以，这种结构尽量少用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; sys

&lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:

    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:

        a &lt;/span&gt;= int(input(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;请输入一个数字：&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; a==&lt;span&gt;0:

            sys.exit()

        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:

            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;您输入的数字是：{}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(a))

        time.sleep(&lt;/span&gt;1&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt;:

    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;发生异常了……&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　当输入数字0时，输出如下：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;请输入一个数字：0&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　发生异常了……&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　事实上，系统知识正常退出，并不算异常，但是只使用except，Python会将系统离开调用当做异常来捕获。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;（2）try-except&amp;lt;异常名&amp;gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:

    &lt;/span&gt;&amp;lt;语句&amp;gt;

 &lt;span&gt;except&lt;/span&gt; &amp;lt;异常名&amp;gt;&lt;span&gt; [as e]:

    &lt;/span&gt;&amp;lt;异常处理&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　except中，as e是可选的，意思是将捕获的异常类实例化对象赋值给e（当然也可以用其他变量名），在except下面的代码块中，我们将可以通过这个e访问异常实例化对象中的方法和数据。另外，except子句的个数理论上是不限的，不过不能将父类置于子类前面。在上文中提到，Exception类是所有Python异常类的父类，所以except Exception将可以捕获任何异常，换句话说，它是万能异常处理句式。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:

    a &lt;/span&gt;= int(input(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;请输入一个数字：&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))

&lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; ValueError as e:

    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(e)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;当输入一个非数字类字符时，输出如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　请输入a的值：j&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　invalid literal for int() with base 10: 'j'&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　如果输入b的值为0，输出如下：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　请输入a的值：1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　请输入b的值：0&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　division by zero&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　（3）try-except (&amp;lt;异常类1&amp;gt;, &amp;lt;异常类2&amp;gt;, ...)&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:

    &lt;/span&gt;&amp;lt;语句&amp;gt;

&lt;span&gt;except&lt;/span&gt; (&amp;lt;异常类1&amp;gt;, &amp;lt;异常类2&amp;gt;&lt;span&gt;, ...):

    &lt;/span&gt;&amp;lt;异常处理&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:

    a &lt;/span&gt;= int(input(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;请输入a的值：&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))

    b &lt;/span&gt;= int(input(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;请输入b的值：&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))

    c &lt;/span&gt;= a/&lt;span&gt;b

&lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; (ValueError , ZeroDivisionError) as e:

    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(e)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　当输入一个非数字类字符时，输出如下：&lt;/p&gt;
&lt;p&gt;　　&lt;em&gt;&lt;span&gt;请输入a的值：j&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;　　invalid literal for int() with base 10: 'j'&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　如果输入b的值为0，输出如下：&lt;/p&gt;
&lt;p&gt;　　&lt;em&gt;&lt;span&gt;请输入a的值：1&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;　　请输入b的值：0&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;　　division by zero&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;strong&gt;（4）try-except-else&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:

    &lt;/span&gt;&amp;lt;语句&amp;gt;

&lt;span&gt;except&lt;/span&gt; &amp;lt;异常名&amp;gt;&lt;span&gt;:

    &lt;/span&gt;&amp;lt;异常处理&amp;gt;

&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:

    &lt;/span&gt;&amp;lt;语句&amp;gt;  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; try语句中没有异常则执行此段代码&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　如果说except是在try中代码抛出异常时执行，那么else语句下面的代码将在try顺利执行（没有抛出任何异常）的情况下才会执行。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:

    a &lt;/span&gt;= int(input(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;请输入a的值：&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))

    b &lt;/span&gt;= int(input(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;请输入b的值：&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))

    c &lt;/span&gt;= a/&lt;span&gt;b

&lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; (ValueError , ZeroDivisionError) as e:

    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(e)

&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:

    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a/b的结果为：{}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.format(c))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　当输入a和b的值都为数字时，才会执行else部分代码，输出结果如下：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;　　请输入a的值：4&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;　　请输入b的值：2&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;　　a/b的结果为：2.0&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;（5）try-except-finally&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:

    &lt;/span&gt;&amp;lt;语句&amp;gt;

&lt;span&gt;except&lt;/span&gt; &amp;lt;异常类&amp;gt;&lt;span&gt;:

    &lt;/span&gt;&amp;lt;异常处理&amp;gt;

&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;:

    &lt;/span&gt;&amp;lt;语句&amp;gt;  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 不管try中代码是否抛出异常，都会执行此段代码&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　finally中的代码无论try中代码是否抛出异常都会执行。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:

    a &lt;/span&gt;= int(input(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;请输入a的值：&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))

    b &lt;/span&gt;= int(input(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;请输入b的值：&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))

    c &lt;/span&gt;= a/&lt;span&gt;b

&lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; (ValueError , ZeroDivisionError) as e:

    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(e)

&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:

    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a/b的结果为：{}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(c))

&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;:

    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;无论你输入什么值，finally都会执行……&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　有时候，异常可以作为代码运行的标志，通过主动触发异常可以改变代码的运行路线，从而提高代码健壮性。主动触发异常需使用raise关键字，其语法结构如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;raise&lt;/span&gt; [Exception [, args [, traceback]]]
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; fun(x , y):

    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:

        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;fun()方法开始执行……&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; isinstance(x,int) &lt;span&gt;and&lt;/span&gt;&lt;span&gt; isinstance(y,int):

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; x+&lt;span&gt;y

        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:

            &lt;/span&gt;&lt;span&gt;raise&lt;/span&gt; TypeError(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;类型错误&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception as e:

        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(e)

    &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;:

        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;fun()方法执行结束……&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

fun(&lt;/span&gt;2 , &lt;span&gt;'&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　输出结果：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;　　fun()方法开始执行……&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;　　类型错误&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;　　fun()方法执行结束……&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　assert语句根据后面的表达式的真假来控制程序流。 asset语法结构如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;assert&lt;/span&gt; expression,'information&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       若为expression结果为True，则往下执行。若为False，则中断程序并调用默认的异常处理器抛出AssertionError异常，同时输出指定的提示信息。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; fun(x):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;fun()方法开始执行……&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;assert&lt;/span&gt; x&amp;lt;0 , &lt;span&gt;'&lt;/span&gt;&lt;span&gt;抛出异常，x小于0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;fun()方法执行结束……&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
    fun(&lt;/span&gt;2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception as e:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(e)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　输出结果：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;　　fun()方法开始执行……&lt;/span&gt;&lt;/em&gt;&lt;br/&gt;&lt;em&gt;&lt;span&gt;　　抛出异常，x小于0&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　可以发现，打印输出第一行语句之后，由于断言失败，抛出异常，程序直接退出。&lt;/p&gt;

&lt;p&gt;　　with/as语句通常是作为try/finally语句的替代方案，不过with/as更加优雅。在有一些任务中，可能事先需要设置，然后不管在任务过程中是否顺利（有无异常抛出），最后后做清理工作。对于这种场景， with/as语句提供了一种非常方便的处理方式。一个很好的例子是文件处理，你需要获取一个文件句柄，从文件中读写数据，但不管读写数据是否有异常发生，最后都要关闭文件句柄。&lt;/p&gt;
&lt;p&gt;　　with/as语句的基本格式如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;with expression [as variable] :

    with&lt;/span&gt;-block
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在这里的expression会返回一个对象，as子句是可选的，当存在as子句时，expression返回的对象会赋值给variable。&lt;/p&gt;
&lt;p&gt;　　使用with/as语句将一段字符串写入文件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
with open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;data.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; , &lt;span&gt;'&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) as myfile:

    myfile.write(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;123456789&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

         不适用with&lt;/span&gt;/&lt;span&gt;as语句，如果要实现同样的效果，只能这么写：

&lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:

    myfile &lt;/span&gt;= open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;data.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; , &lt;span&gt;'&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

    myfile.write(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;123456789&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception as e:

    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(e)

&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;:

    myfile.close()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;         如果Python提供的内置异常内不满足使用要求，那么，可以自定义一个异常类。自定义异常类必须继承Exception类，并且在使用时，必须通过raise关键字自动触发。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyError(Exception):

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, info):

        self.info &lt;/span&gt;=&lt;span&gt; info

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__str__&lt;/span&gt;&lt;span&gt;(self):

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;{}：{}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.format(self.&lt;span&gt;__class__&lt;/span&gt; .&lt;span&gt;__name__&lt;/span&gt;&lt;span&gt;, self.info)

&lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:

    &lt;/span&gt;&lt;span&gt;raise&lt;/span&gt; MyError(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;自定义的异常……&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; MyError as e :

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(e)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　输出结果：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;　　MyError：自定义的异常……&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;　　本文是对Python异常处理机制的总结，较为全面的介绍了Python异常处理的常用内置类，即几种异常捕获/处理句式结构，主动触发异常，断言，with上下文管理协议，自定义异常类等内容。&lt;/p&gt;
</description>
<pubDate>Fri, 21 Dec 2018 11:44:00 +0000</pubDate>
<dc:creator>奥辰</dc:creator>
<og:description>本文是对Python异常处理机制的总结，较为全面的介绍了Python异常处理的常用内置类，即几种异常捕获/处理句式结构，主动触发异常，断言，with上下文管理协议，自定义异常类等内容。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenhuabin/p/10158606.html</dc:identifier>
</item>
<item>
<title>【Angular专题】 (3)装饰器decorator，一块语法糖 - 大史不说话</title>
<link>http://www.cnblogs.com/dashnowords/p/10158537.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dashnowords/p/10158537.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354575/201812/1354575-20181221192124146-466251465.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;一.-decorator装饰器&quot;&gt;一. Decorator装饰器&lt;/h2&gt;
&lt;p&gt;修饰器是&lt;code&gt;ES7&lt;/code&gt;加入的新特性，&lt;code&gt;Angular&lt;/code&gt;中进行了大量使用，有很多内置的修饰器，后端的同学一般称之为&lt;strong&gt;“注解”&lt;/strong&gt;。修饰器的作用，实际上就是设计模式中常说的&lt;strong&gt;装饰者模式&lt;/strong&gt;的一种实现，早在&lt;code&gt;ES6&lt;/code&gt;开始，设计模式原生化就已经是非常明显的趋势了，无论是&lt;code&gt;for..of..&lt;/code&gt;和&lt;code&gt;Iterator&lt;/code&gt;接口的配合内化了&lt;strong&gt;迭代者模式&lt;/strong&gt;，&lt;code&gt;Proxy&lt;/code&gt;对象实现的&lt;strong&gt;代理模式&lt;/strong&gt;等等，都可以看出&lt;code&gt;Javascript&lt;/code&gt;逐渐走向标准化的趋势和决心。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;装饰者模式&lt;/strong&gt;，是指在不必改变原类文件或使用继承的情况下，动态地扩展一个对象的功能，为对象增加额外特性的一种设计模式。考虑到&lt;code&gt;javascript&lt;/code&gt;中函数参数为对象时只传递地址这一特性，装饰者模式实际上是非常好复现的，掌握其基本知识对于理解&lt;code&gt;Angular&lt;/code&gt;技术栈的原理和执行流程是必不可少的，从结果的角度来看，使用装饰器和直接修改类的定义没有什么区别，但使用装饰器更符合&lt;strong&gt;开放封闭&lt;/strong&gt;原则，且更符合声明式的思想，本文着重分析&lt;code&gt;Typescript&lt;/code&gt;中支持的几种不同的装饰器用法。&lt;/p&gt;
&lt;h2 id=&quot;二.-typescript中的装饰器&quot;&gt;二. Typescript中的装饰器&lt;/h2&gt;
&lt;h3 id=&quot;类装饰器&quot;&gt;2.1 类装饰器&lt;/h3&gt;
&lt;p&gt;类装饰器，就是用来装饰类的，它只接受一个参数，就是被装饰的类。下面的示例使用&lt;code&gt;@testable&lt;/code&gt;修饰器为已定义的类加上一个&lt;code&gt;__testable&lt;/code&gt;属性:&lt;/p&gt;
&lt;pre class=&quot;ts&quot;&gt;
&lt;code&gt;//装饰器修改的是类定义的表现，故在javascript中模拟时需要直接将变化添加至原型上
function testable(target: Function):void{
    target.prototype.__testable = false;
}

//使用类装饰器
@testable
class Person{
    constructor(){}
}

//测试装饰后的结果
let person = new Person();
console.log(person.__testable);//false&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另一方面，我们可以使用工厂函数的方法生成一个可接收附加参数的装饰器，借助高阶函数的思路不难理解，例如&lt;code&gt;Angular&lt;/code&gt;中常见的这种形式:&lt;/p&gt;
&lt;pre class=&quot;ts&quot;&gt;
&lt;code&gt;//Angular中的组件定义
@Component({
    selector:'hero-detail',
    templateUrl:'hero-detail.html',
    styleUrls:['style.css']
})
export Class MyComponent{
    constructor(){}
}

//@Component装饰者类的作用机制可以理解为：
function Component(params:any){
    return function(target: Function):void{
        target.prototype.metadata = params;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样在组件被实例化时，就可以获取到传入的元数据信息。换句话说，&lt;code&gt;Component({...})&lt;/code&gt;执行后返回的函数才是真正的类装饰器，&lt;code&gt;Component&lt;/code&gt;是一个接受参数然后生成装饰器的函数，也就是&lt;strong&gt;装饰器工厂&lt;/strong&gt;，从元编程的角度来讲，相当于修改了&lt;code&gt;new&lt;/code&gt;操作符的行为。&lt;/p&gt;
&lt;h3 id=&quot;方法装饰器&quot;&gt;2.2 方法装饰器&lt;/h3&gt;
&lt;p&gt;方法修饰器声明在一个方法的声明之前，会被应用到方法的属性描述符上，可以用来检视，修改或者替换方法定义。它接收如下三个参数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1.静态成员时参数是类的构造函数，实例成员时传入类的原型对象。&lt;/li&gt;
&lt;li&gt;2.成员名&lt;/li&gt;
&lt;li&gt;3.成员属性描述符&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面的装饰器&lt;code&gt;@enumerable&lt;/code&gt;将被修饰对象修改为可枚举：&lt;/p&gt;
&lt;pre class=&quot;ts&quot;&gt;
&lt;code&gt;//方法装饰器，返回值会直接赋值给方法的属性描述符。
function enumerable(target: any, propertyKey: string, descriptor:PropertyDescriptor):void{
    descriptor.enumerable = true;
}

class Person{
    constructor(){}
    
    @enumerable//使用方法装饰器
    sayHi(){
        console.log('Hi');
    }
}

//测试装饰后的结果
let person = new Person();
console.log(person.__testable);//false&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;更常用的方式依然是利用高阶函数返回一个可被外部控制的装饰器：&lt;/p&gt;
&lt;pre class=&quot;ts&quot;&gt;
&lt;code&gt;function enumerable(value: boolean){
    return function (target: any, propertyKey: string, descriptor:PropertyDescriptor):void{
        descriptor.enumerable = true;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;访问器装饰器&quot;&gt;2.3 访问器装饰器&lt;/h3&gt;
&lt;p&gt;访问器，一般指属性的&lt;code&gt;get/set&lt;/code&gt;方法，和普通方法装饰器用法一致，需要注意的是typescript中不支持同时装饰一个成员的&lt;code&gt;get&lt;/code&gt;访问器和&lt;code&gt;set&lt;/code&gt;访问器。&lt;/p&gt;
&lt;h3 id=&quot;属性装饰器&quot;&gt;2.4 属性装饰器&lt;/h3&gt;
&lt;p&gt;属性装饰器表达式运行时接收两个参数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1.对于静态成员来说是类的构造函数，对于实例成员来说是类的原型对象。&lt;/li&gt;
&lt;li&gt;2.成员名&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Typescript官方文档给出的示例是这样的：&lt;/p&gt;
&lt;pre class=&quot;ts&quot;&gt;
&lt;code&gt;class Greeter {
    @format(&quot;Hello, %s&quot;) greeting: string;
    
    constructor(message: string){
        this.greeting = message;
    }
    
    greet(){
        let formatString = getFormat(this, 'greeting');
        return formatString.replace('s%',this.greeting);
    }
    
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后定义&lt;code&gt;@format&lt;/code&gt;装饰器和&lt;code&gt;getFormat&lt;/code&gt;函数:&lt;/p&gt;
&lt;pre class=&quot;ts&quot;&gt;
&lt;code&gt;.import &quot;reflect-metadata&quot;;

const formatMetadataKey = Symbol(&quot;format&quot;);

function format(formatString: string) {
    return Reflect.metadata(formatMetadataKey, formatString);
}

function getFormat(target: any, propertyKey: string) {
    return Reflect.getMetadata(formatMetadataKey, target, propertyKey);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;与方法装饰器相比，属性装饰器的形参列表中并没有属性描述符，因为目前没有办法在定义一个原型对象的成员时描述一个实例属性，也无法监视属性的初始化方法。&lt;strong&gt;TS中的属性描述符单独使用时只能用来监视类中是否声明了某个名字的属性&lt;/strong&gt;，示例中通过外部功能扩展了其实用性。Angular中最常见的属性修饰器就是&lt;code&gt;Input( )&lt;/code&gt;和&lt;code&gt;output( )&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;参数装饰器&quot;&gt;2.5 参数装饰器&lt;/h3&gt;
&lt;p&gt;参数装饰器一般用于装饰参数，在类构造函数或方法声明中装饰形参。&lt;/p&gt;
&lt;p&gt;它在运行时被当做函数调用，传入下列3个参数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1.静态成员时接收构造函数，实例成员时接收原型对象。&lt;/li&gt;
&lt;li&gt;2.成员名&lt;/li&gt;
&lt;li&gt;3.参数在函数参数列表中的索引。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;TS中参数装饰器单独使用时只能用来监视一个方法的参数是否被传入&lt;/strong&gt;，Typescript官方给出的示例如下：&lt;/p&gt;
&lt;pre class=&quot;ts&quot;&gt;
&lt;code&gt;class Greeter {
    greeting: string;

    constructor(message: string) {
        this.greeting = message;
    }

    @validate
    greet(@required name: string) {//此处使用了参数修饰符
        return &quot;Hello &quot; + name + &quot;, &quot; + this.greeting;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;两个装饰器的定义如下：&lt;/p&gt;
&lt;pre class=&quot;ts&quot;&gt;
&lt;code&gt;import &quot;reflect-metadata&quot;;
const requiredMetadataKey = Symbol('required');

/*
*@required参数装饰器
*实现的功能就是当函数的参数必须填入时，将相关信息存储到一个外部的数组中，可以看出参数装饰器并*未对参数本身做出什么修改。
*/
function required(target: Object, propertyKey:string | symbol, parameterIndex: number){
    let existingRequiredParameters: number[] = Reflect.getOwnMetadata(requiredMetadataKey, target, propertyKey) || [];
    existingRequiredParameters.push(parameterIndex);
    Reflect.defineMetadata(requiredMetadataKey, existingRequiredParameters, target, propertyKey);
}

/*
*@validate装饰器为方法装饰器
*展示了如何通过操作方法属性描述符中的value属性来实现方法的代理访问。
*/
function validate(target:any, propertyName: string, descriptor:TypedPropertyDescriptor&amp;lt;Function&amp;gt;){
    let method = descriptor.value;//方法的属性修饰符的value就是方法的函数表达式
    descriptor.value = function(){
        let requiredParameters: number[] = Reflect.getOwnMetadata(requiredMetadataKey, target, propertyName);//在外部存储中查找是否有必填参数
        if (requiredParameters){
            for(let parameterIndex of requiredParameters){
                if(parameterIndex &amp;gt;= arguments.length || arguments[parameterIndex] === undefined){
                    //传入参数不足或被约束参数为undefined时抛出错误。
                    throw new Error('Missing required argument');
                }
            }
        }
        return method.apply(this, arguments);//如果没有任何错误抛出则继续执行原函数
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;在Typescript中，装饰器的运行顺序基本依照参数装饰器，方法装饰器，访问符装饰器，属性装饰器，类装饰器这样的顺序来运行，所以参数装饰器和方法装饰器可以联合使用实现一些额外功能。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;三.-用es5代码模拟装饰器功能&quot;&gt;三. 用ES5代码模拟装饰器功能&lt;/h2&gt;
&lt;p&gt;用&lt;code&gt;ES5&lt;/code&gt;来模拟一下上述的方法装饰器和参数装饰器联合作用的例子，就很容易看出装饰器的作用：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;//使用ES5语法模拟装饰器
function Greeter(message){
    this.greeting = message;
}

Greeter.prototype.greet = function(name){
    return &quot;Hello &quot; + name + &quot;, &quot; + this.greeting;
}

//外部存储的必要性校验
requiredArray = {};

//参数装饰器
function requireDecorator(FnKey,paramsIndex){
    requiredArray[FnKey] = paramsIndex;
} 

//装饰器函数
function validateDecorator(Fn,FnKey){
    let method = Fn;
    return function(){
        let checkParamIndex = requiredArray[FnKey];
        if(checkParamIndex &amp;gt; arguments.length-1 || arguments[checkParamIndex] === undefined){
            throw new Error('params invalid');
        }
        return method.apply(this, arguments);
    }
}

//运行装饰
requireDecorator('greet',0);
Greeter.prototype.greet = validateDecorator(Greeter.prototype.greet, 'greet');

//测试装饰
let greeter = new Greeter('welcome to join the conference');
console.log(greeter.greet('Tony'));
console.log(greeter.greet());&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在node环境中运行一下就可以看到，&lt;code&gt;greet( )&lt;/code&gt;方法在未传入参数时会报错提示。&lt;/p&gt;
&lt;h2 id=&quot;四.-小结&quot;&gt;四. 小结&lt;/h2&gt;
&lt;p&gt;装饰器实际上就是一种更加简洁的代码书写方式，从代码表现来理解，就是使用闭包和高阶函数扩展或者修改了原来的表现，从功能角度来理解，达到了不修改内部实现的前提下动态扩展和修改类定义的目的。&lt;/p&gt;
</description>
<pubDate>Fri, 21 Dec 2018 11:23:00 +0000</pubDate>
<dc:creator>大史不说话</dc:creator>
<og:description>[TOC] 一. Decorator装饰器 修饰器是 加入的新特性， 中进行了大量使用，有很多内置的修饰器，后端的同学一般称之为 “注解” 。修饰器的作用，实际上就是设计模式中常说的 装饰者模式 的一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dashnowords/p/10158537.html</dc:identifier>
</item>
<item>
<title>一次线上问题引发的对于C#中相等判断的思考 - 西秀岭</title>
<link>http://www.cnblogs.com/xixiuling/p/10155822.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xixiuling/p/10155822.html</guid>
<description>&lt;p&gt;线上报来一个问题，说用户的数据丢失了。开发经过紧张的调查。终于找到了原因。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt; (newData.GetValue(rowIndex) ==&lt;span&gt; oldData.GetValue(rowIndex))
{

   ..................

}


&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; GetValue(&lt;span&gt;string fieldName)&lt;/span&gt;&lt;span&gt;)
{
    ...............&lt;br/&gt;return values[filedName];   //这是一个简单类型： int,string
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 问题出在了 if 中的比较上。  values[rowIndex] 中保存的是一个整数，开发认为两个整数比较实用 ==  就可以了。&lt;/p&gt;
&lt;p&gt;但是 values[rowIndex] 中的整数经过 GetValue返回后被作为 object 对象返回了，这时如果还使用 == 进行比较就会出现不等的情况。&lt;/p&gt;

&lt;p&gt;我们来看一个更全面的例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
{
    &lt;/span&gt;&lt;span&gt;object&lt;/span&gt; value1 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt;();
    &lt;/span&gt;&lt;span&gt;object&lt;/span&gt; value2 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt;();

    value1 &lt;/span&gt;= &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
    value2 &lt;/span&gt;= &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;

    Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;value1  == value2&lt;/span&gt;&lt;span&gt; {0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, (value1 ==&lt;span&gt; value2).ToString());
    Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;vvalue1.Equals(value2) {0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, value1.Equals(value2).ToString());
    Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;Equals(value1, value2)&lt;/span&gt;&lt;span&gt; {0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Equals(value1, value2).ToString());
    Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;ReferenceEquals(value1,value2)&lt;/span&gt;&lt;span&gt; {0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, ReferenceEquals(value1,value2).ToString());
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;p&gt;value1  == value2 False&lt;br/&gt;value1.Equals(value2) True&lt;br/&gt;Equals(value1, value2) True&lt;br/&gt;ReferenceEquals(value1,value2) False&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;如果我们将value1, value2 都定义为数字，但是一个是long，一个是uint.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
{
&lt;/span&gt; 　　 &lt;span&gt;long&lt;/span&gt; value1 = &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
     &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; value2 = &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;

     Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value1  == value2 {0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, (value1 ==&lt;span&gt; value2).ToString());
     Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value1.Equals(value2) {0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, value1.Equals(value2).ToString());
     Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Equals(value1, value2) {0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Equals(value1, value2).ToString());
     Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ReferenceEquals(value1,value2) {0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, ReferenceEquals(value1,value2).ToString());

   }    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看一下运行结果 ，使用  ==  ,和 value1.Equals  方法比较是相等的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
value1  ==&lt;span&gt; value2 True
value1.Equals(value2) True
Equals(value1, value2) False
ReferenceEquals(value1,value2) False&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;结合上面两个例子，我们定义一个long 变量, 一个unit 变量, 给它们赋值之后，再将这两个变量赋值给两个object 对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
 {
      &lt;/span&gt;&lt;span&gt;object&lt;/span&gt; value1 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt;();
      &lt;/span&gt;&lt;span&gt;object&lt;/span&gt; value2 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt;();

      &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; lgval = &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
      &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; ival = &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
            
      value1 &lt;/span&gt;=&lt;span&gt; lgval;
      value2 &lt;/span&gt;=&lt;span&gt; ival;
   
      Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lgval  == ival {0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, (lgval ==&lt;span&gt; ival).ToString());
      Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value1  == value2 {0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, (value1 ==&lt;span&gt; value2).ToString());
      Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value1.Equals(value2) {0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, value1.Equals(value2).ToString());
      Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Equals(value1, value2) {0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Equals(value1, value2).ToString());
      Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ReferenceEquals(value1,value2) {0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, ReferenceEquals(value1,value2).ToString());

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到，除去值类型 lgval 和 uval 相等外，其它都是不相等的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
lgval  ==&lt;span&gt; uval True
value1  &lt;/span&gt;==&lt;span&gt; value2 False
value1.Equals(value2) False
Equals(value1, value2) False
ReferenceEquals(value1,value2) False&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 是不是很抓狂? 到底什么情况下相等？什么情况下不等？我们先将上面的结果总结一下。&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;caption&gt; &lt;/caption&gt;
&lt;tbody readability=&quot;5.5&quot;&gt;&lt;tr readability=&quot;14&quot;&gt;&lt;td&gt; &lt;/td&gt;
&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;value1 和value2都是Object 对象&lt;/p&gt;
&lt;p&gt;含有&lt;span&gt;相同类型&lt;/span&gt;的值对象（int）&lt;/p&gt;
&lt;p&gt;含有相同的值&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;6&quot;&gt;
&lt;p&gt;value1 是long,value2 是 int&lt;/p&gt;
&lt;p&gt;含有相同的值&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;8&quot;&gt;
&lt;p&gt;value1 和value2都是Object 对象&lt;/p&gt;
&lt;p&gt;含有&lt;span&gt;不同类型&lt;/span&gt;的值对象(long,int)&lt;/p&gt;
&lt;p&gt;含有相同的值&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;pre&gt;
&lt;span&gt;value1  ==&lt;span&gt; value2&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;false &lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;true &lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; false&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;pre&gt;
&lt;span&gt;value1.Equals(value2)&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;true &lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;true &lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; false&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;pre&gt;
&lt;span&gt;Equals(value1, value2)&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; true&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;false &lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; false&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td readability=&quot;6&quot;&gt;
&lt;pre&gt;
&lt;span&gt;ReferenceEquals(value1,value2)&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td&gt; &lt;span&gt;false&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;false &lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; false&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;











&lt;p&gt;如果将一个值类型赋值给一个object 对象后，如何判断相等？ 微软官方也没有给出一个标准的说法。从测试的角度来看。&lt;/p&gt;
&lt;p&gt;两个比较的 object 中的内容如果类型相同，可以使用Equals 来进行比较。&lt;/p&gt;
&lt;p&gt;不过我个人还是建议如果是比较值，还是&lt;span&gt;转换为对应的值类型进行比较&lt;/span&gt;，这样比较清晰，不容易犯错，大家也不用搞清楚 == 和 Equals 之前的细微差别。&lt;/p&gt;

&lt;p&gt;ps: 如果object 的类型是 string , 上面的结果又会有所不同，有兴趣的同学可以自己尝试一下。&lt;/p&gt;

</description>
<pubDate>Fri, 21 Dec 2018 11:17:00 +0000</pubDate>
<dc:creator>西秀岭</dc:creator>
<og:description>线上报来一个问题，说用户的数据丢失了。开发经过紧张的调查。终于找到了原因。 问题出在了 if 中的比较上。 values[rowIndex] 中保存的是一个整数，开发认为两个整数比较实用 == 就可以</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xixiuling/p/10155822.html</dc:identifier>
</item>
<item>
<title>解决 openpyxl 垂直分页符和水平分页符同时添加的问题 - leetao94</title>
<link>http://www.cnblogs.com/leetao94/p/10158458.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/leetao94/p/10158458.html</guid>
<description>&lt;p&gt;十天前知乎上有人提问 &lt;a href=&quot;https://www.zhihu.com/question/305289263/answer/549313223&quot;&gt;python:openpyxl模块怎么给表格添加分页符？实现分页打印功能？&lt;/a&gt;,看到问题之后,我很快的给他了一个如何添加垂直分页符或水平分页符的示例,你以为问题就结束了?我是这么以为的,但是事实证明,我太天真了,就在我给出示例的几分钟后,他在我的回答下评论了,说是&lt;strong&gt;同时添加垂直分页符和水平分页符失败了&lt;/strong&gt;.&lt;br/&gt;我当时的第一反应:&lt;br/&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/006wYWbGly1fyegeyuiomj30j60j63z8.jpg&quot;/&gt;&lt;br/&gt;心里想着,肯定是他的写法有问题,毫不犹豫的回复到,&quot; 没有试过同时添加两种分页符的操作,默认是水平分页符,如果你先添加了垂直分页符的话,应该后面需要重新声明:openpyxl.worksheet.pagebreak.PageBreak.tagname = &quot;rowBreaks&quot;,听着自己飞快击打键盘的声音,自己不经有点飘飘然.就在沉浸在自己的YY当中,又过去了几分钟,他用正确的代码错误的结果狠狠的摔在了我的脸上:&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;col_break = openpyxl.worksheet.pagebreak.Break(5) #创建分页符，参数5：在第5/6中间分页
sheet1.page_breaks.tagname = 'rowBreaks' #分页符属性设置为行分页符
sheet1.page_breaks.append(col_break) #把分页符对象添加到sheet对象里

row_break = openpyxl.worksheet.pagebreak.Break(3) #创建分页符
sheet1.page_breaks.tagname = 'colBreaks' #分页符属性设置为列分页符
sheet1.page_breaks.append(row_break) #把分页符对象添加到sheet对象里&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&quot;结果是在第3和5列添加了两个垂直分页符，是哪里有问题？大师&quot;,他问道. 我看了一眼代码好像没有错,我的心有点慌了,双手开始微微颤抖起来,一遍又一遍地仔细地巡视着代码,视图找出错误反驳他,但是并没有,抱着最后的希望,我把他的代码复制到自己的文件中,然后敲下回车符, excel 文件静静的生成在目录下,这可能是我最后的希望了.拿鼠标的手不自觉的颤抖起来,那么小的屏幕,那么大的文件,鼠标怎么半天都没办法移动上去,我深吸一口气,控制住自己手,终于把鼠标一上去了,双击excel,闭上眼睛,再睁开,我知道,我错了.但是就这么放弃了吗?绝不!我要把这个问题打到!&lt;/p&gt;

&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&quot;是时候展示真正的技术了&quot;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;俗话说&quot;解铃还须系铃人&quot;,我们还得自己看一下问题代码:&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# example.py

from openpyxl import Workbook
from openpyxl.compat import range
from openpyxl.utils import get_column_letter
from openpyxl.worksheet.pagebreak import Break, PageBreak

wb = Workbook()
ws = wb.active

for row in range(1, 20):
    for col in range(1,30):
        _ = ws.cell(column=col, row=row, value=&quot;{0}&quot;.format(get_column_letter(col)))

col_break = Break(5) #创建分页符，参数5：在第5/6中间分页
ws.page_breaks.tagname = 'rowBreaks' #分页符属性设置为行分页符
ws.page_breaks.append(col_break) #把分页符对象添加到sheet对象里

row_break = Break(3) #创建分页符
ws.page_breaks.tagname = 'colBreaks' #分页符属性设置为列分页符
ws.page_breaks.append(row_break) #把分页符对象添加到sheet对象里

wb.save(filename = dest_filename) &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从代码上应该是后面的 page_breaks 把前面的覆盖了, 那让我们看看 page_breaks 究竟是什么东西.&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class Worksheet(_WorkbookChild):
   # 省略部分代码
      def _setup(self):
        self.page_breaks = PageBreak() # 再看 PageBreak

class PageBreak(Serialisable):
    tagname = &quot;rowBreaks&quot;
    # 省略部分代码
    def append(self, brk=None):
        &quot;&quot;&quot;
        Add a page break
        &quot;&quot;&quot;
        vals = list(self.brk)
        if not isinstance(brk, Break):
            brk = Break(id=self.count+1)
        vals.append(brk)
        self.brk = vals&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从 example 中我们不难发现,我们是通过修改 page_breaks 的 tag_name 去决定插入的分页符是垂直分页符还是水平分页符的.但是 page_breaks 现在只有一个 PageBreak 这就难怪后声明的会把前面的覆盖了,那么如果我们把 page_breaks 变成 PageBreak 的列表呢?&lt;/p&gt;

&lt;p&gt;说改咱就改啊,首先尝试修改 WorkSheet 类&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class Worksheet(_WorkbookChild):
   # 省略部分代码
      def _setup(self):
        self.page_breaks = [PageBreak()]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后再修改一下 example.py&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from openpyxl import Workbook
from openpyxl.compat import range
from openpyxl.utils import get_column_letter
from openpyxl.worksheet.pagebreak import Break, PageBreak

wb = Workbook()
dest_filename = 'empty_book.xlsx'

ws = wb.active
for row in range(1, 20):
    for col in range(1,30):
        _ = ws.cell(column=col, row=row, value=&quot;{0}&quot;.format(get_column_letter(col)))

rowPageBreak = PageBreak()
rowPageBreak.tagname = 'rowBreaks'

colPageBreak = PageBreak()
colPageBreak.tagname = 'colBreaks'

ws.page_breaks = [rowPageBreak, colPageBreak] 

ws.page_breaks[0].append(Break(id=5))  
ws.page_breaks[1].append(Break(id=3))
wb.save(filename = dest_filename)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;敲下回车,心里那个美滋滋,还没高兴几秒钟,就出问题了,果然做人还是得低调一点&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Traceback (most recent call last):
  File &quot;test.py&quot;, line 24, in &amp;lt;module&amp;gt;
    wb.save(filename = dest_filename)
  File &quot;F:\workspace\python\test_openpyxl\test_openpyxl\lib\site-packages\openpyxl\workbook\workbook.py&quot;, line 391, in save
    save_workbook(self, filename)
  File &quot;F:\workspace\python\test_openpyxl\test_openpyxl\lib\site-packages\openpyxl\writer\excel.py&quot;, line 284, in save_workbook
    writer.save(filename)
  File &quot;F:\workspace\python\test_openpyxl\test_openpyxl\lib\site-packages\openpyxl\writer\excel.py&quot;, line 266, in save
    self.write_data()
  File &quot;F:\workspace\python\test_openpyxl\test_openpyxl\lib\site-packages\openpyxl\writer\excel.py&quot;, line 83, in write_data
    self._write_worksheets()
  File &quot;F:\workspace\python\test_openpyxl\test_openpyxl\lib\site-packages\openpyxl\writer\excel.py&quot;, line 203, in _write_worksheets
    xml = ws._write()
  File &quot;F:\workspace\python\test_openpyxl\test_openpyxl\lib\site-packages\openpyxl\worksheet\worksheet.py&quot;, line 893, in _write
    return write_worksheet(self)
  File &quot;F:\workspace\python\test_openpyxl\test_openpyxl\lib\site-packages\openpyxl\writer\worksheet.py&quot;, line 151, in write_worksheet
    xf.write(ws.page_breaks.to_tree())
AttributeError: 'list' object has no attribute 'to_tree'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看了一眼错误信息,发现了从中作祟的家伙再 worksheet.py 的 151 行, 让我们悄悄地看一眼,打枪的不要.&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# worksheet.py
# 省略部分代码
            if ws.page_breaks:
                    xf.write(ws.page_breaks.to_tree())&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;原来是我们修改了 page_breaks 之后, page_breaks 有时候不再是孤家寡人了,我们需要考虑它有另外的 PageBreak 的情况了.&lt;/p&gt;

&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# worksheet.py
# 省略部分代码
            if ws.page_breaks:
                if isinstance(ws.page_breaks,list):
                    for page_break_item in ws.page_breaks:
                        xf.write(page_break_item.to_tree())
                else:
                    xf.write(ws.page_breaks.to_tree())&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;回车,毫无问题,人生啊就是这么寂寞如雪~~~&lt;/p&gt;

&lt;p&gt;已经在 openpyxl 提了相应的issue,目前再写测试用例,过段时间就提交 PR 了&lt;/p&gt;
</description>
<pubDate>Fri, 21 Dec 2018 10:54:00 +0000</pubDate>
<dc:creator>leetao94</dc:creator>
<og:description>前言 十天前知乎上有人提问</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/leetao94/p/10158458.html</dc:identifier>
</item>
</channel>
</rss>