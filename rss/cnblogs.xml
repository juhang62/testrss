<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>《Java编程思想》读书笔记-对象导论 - Lurker潜行者</title>
<link>http://www.cnblogs.com/lurker-yaojiang/p/10360651.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lurker-yaojiang/p/10360651.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;计算机是头脑延伸的工具，是一种不同类型的表达媒体。本文以背景性的和补充性的材料，介绍包括开发方法概述在内的面向对象程序设计(Object-oriented Programming,OOP)的基本概念。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文通过概念+代码的方式，来帮助读者了解面向对象程序设计的全貌。&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;抽象过程&lt;/h3&gt;
&lt;h5 id=&quot;-&quot;&gt;概念&lt;/h5&gt;
&lt;p&gt;机器模型：位于&lt;code&gt;解空间&lt;/code&gt;内，是对问题建模的地方；可以这样理解，汇编语言和命令式语言，在解决问题时要基于计算机的架构；因此架构限定了解决方案，所以说机器模型是解空间。&lt;/p&gt;
&lt;p&gt;实际待解决问题：&lt;code&gt;问题空间&lt;/code&gt;，是问题存在的地方&lt;/p&gt;
&lt;h5 id=&quot;-&quot;&gt;如何抽象&lt;/h5&gt;
&lt;p&gt;抽象的类型和质量，决定了人们所能够解决的问题的复杂性。抽象的类型指的是“所抽象的是什么”。一种是在机器模型和实际待解决问题的模型之间建立联系的抽象；另一种是只针对待解决问题建模。而面向对象则是向程序员提供表示问题空间中元素的工具，我们将问题空间中的元素及其在解空间中的表示称为“对象”。&lt;/p&gt;
&lt;h5 id=&quot;-&quot;&gt;面向对象程序设计的特性：&lt;/h5&gt;
&lt;ol&gt;&lt;li&gt;万物皆是对象；&lt;/li&gt;
&lt;li&gt;程序是对象的集合，对象间方法的调用是程序运行的基本表现；&lt;/li&gt;
&lt;li&gt;对象可以包含其他对象；&lt;/li&gt;
&lt;li&gt;每个对象都拥有其特定的类型；&lt;/li&gt;
&lt;li&gt;某一特定类型的所有对象都可以接收同样的方法调用；&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;什么是对象？对象具有状态、行为和标识。每一个对象都可以拥有内部数据和方法，并且可以唯一的与其他对象区分开来&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;-&quot;&gt;每个对象都应该都归属于一个类或接口&lt;/h3&gt;
&lt;h5 id=&quot;-&quot;&gt;名词解释&lt;/h5&gt;
&lt;p&gt;对象：具有状态、行为和标识的实体。如银行存款账户是一个类，那么具体的每个人的银行存款账户就是这个类目下的对象。&lt;/p&gt;
&lt;p&gt;类：可以看作类型来考虑。比如说鸟类，是动物中的其中一种类型。&lt;/p&gt;
&lt;h5 id=&quot;-&quot;&gt;类和对象&lt;/h5&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;所有的对象都是唯一的，但同时具有相同的特性和行为的对象也都归属于某个特定的类。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;类在Java中用关键词class表示。每个类的对象都具有某种共性和个性，如银行存款账户，每个账户中都有余额的属性，但每个账户中的余额又不同。在实际中，面向对象程序设计语言都用class关键字来表示数据类型，换而言之，每一个类都是一个数据类型。程序员可以自由地添加新的类（数据类型）来扩展编程语言，对实际问题进行处理。&lt;/p&gt;
&lt;h5 id=&quot;-&quot;&gt;对象的获取与方法调用&lt;/h5&gt;
&lt;p&gt;面向对象的挑战之一，就是在问题空间的元素和解空间的对象之间创建一对一的映射。&lt;/p&gt;
&lt;p&gt;获取有用对象，必须以某种方式对对象进行请求，使对象完成各种任务。类型决定接口，而接口决定对象能满足的请求。就比如鸟类型，其提供的接口有飞翔，因此其能满足飞翔的请求。在接口确定了某一特定对象能够发出的请求后，接口的实现掌控着请求的具体行为的展现方式。在类型中，每一个可能的请求都有一个方法与之关联，当向对象发送请求时，与之关联的方法就会被调用。&lt;/p&gt;
&lt;p&gt;一下代码是获取一个对象并调用其中的方法实例（你可以暂时不用理解，只需要知道形式即可，后面再反过来看就好）&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Light&lt;/span&gt; &lt;/span&gt;{
  
  &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;on&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{
    System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Light is on!&quot;&lt;/span&gt;);
  }
  
  &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;off&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{
    System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Light is off!&quot;&lt;/span&gt;);
  }

  
  &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String [] args)&lt;/span&gt; &lt;/span&gt;{
    
    Light lt = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Light();
    lt.on();
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;-&quot;&gt;对象是服务提供者&lt;/h3&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;程序通过调用其他对象提供的服务来向用户提供服务。程序员的目标就是去创建（或者最好是从现有的代码库中寻找）能够提供解决问题所需服务的一系列对象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为什么要把对象看作是服务提供者呢？&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;这是将问题分解为对象集合的一种合理方式。比如说，你正在创建一个簿记系统，那么，这个系统可以拆分为：我需要一个包括了预定义的簿记输入屏幕的对象、一个执行簿记计算的对象集合以及一个处理在不同的打印机上打印支票和开发票的对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;它有助于提高对象的内聚性。就像上面所定义的簿记系统，每个对象都可以很好地完成一项任务，但是它并不试图做更多的事情。职能太多，可能会导致对象的内聚性降低。简而言之，每个对象只做它该做的事。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;-&quot;&gt;程序访问权限控制&lt;/h3&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;将程序开发人员按照角色划分为&lt;code&gt;类创建者&lt;/code&gt;和&lt;code&gt;客户端程序员&lt;/code&gt;。类创建者创建新的数据类型，而客户端程序员在其应用中使用类创建者创建的新数据类型。如此一来，客户端程序员的主要目的就是收集各种用来实现快速应用开发的类；而类创建者的目的则是构建类，并向客户端程序员暴露必须的部分。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为什么类创建者需要对类的某些部分进行隐藏呢？或者说，为什么需要进行访问权限控制呢？&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;让客户端程序员无法触及他们不该触及的部分，让客户端程序员分清楚，哪些东西对他们来说是必须的，哪些是可以忽略的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;允许库设计者可以改变类内部的工作方式而不用担心会影响到客户端程序员。因为对客户端程序员所提供的那一部分可见的内容总是不变的，而库设计者改变的是其中隐藏的部分。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;java-&quot;&gt;Java的访问权限控制关键字&lt;/h5&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;修饰符&lt;/th&gt;
&lt;th&gt;类内部&lt;/th&gt;
&lt;th&gt;同包&lt;/th&gt;
&lt;th&gt;子类&lt;/th&gt;
&lt;th&gt;任何地方&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;private&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;protected&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;public&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h5 id=&quot;-&quot;&gt;访问权限关键字的修饰范围&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;public：可以修饰外部类、属性、方法；&lt;/li&gt;
&lt;li&gt;protected：只能修饰属性和方法；&lt;/li&gt;
&lt;li&gt;private：只能修饰属性、方法、内部类；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;-&quot;&gt;复用具体实现&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;代码复用是面向对象程序设计语言所提供的最了不起的优点之一。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;代码复用的基本方式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;直接使用该类的一个对象；&lt;/li&gt;
&lt;li&gt;可以将某个类的一个对象置于一个新类中，作为新类的成员出现；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;-&quot;&gt;类之家的关系&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;关系是指事物之间存在单向或者相互的作用力或者影响力的状态。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在两个类之间存在有关系和没关系两种情况，在有关系的情况下，其关系包括以下六种类型&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;类关系&lt;/th&gt;
&lt;th&gt;英文名&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;强权方&lt;/th&gt;
&lt;th&gt;UML图表示&lt;/th&gt;
&lt;th&gt;示例说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;16&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;继承&lt;/td&gt;
&lt;td&gt;extends&lt;/td&gt;
&lt;td&gt;父类与子类之间的关系：is-a&lt;/td&gt;
&lt;td&gt;父类&lt;/td&gt;
&lt;td&gt;空心三角+实线，空心三角指向父类&lt;/td&gt;
&lt;td&gt;鸟是动物&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;实现&lt;/td&gt;
&lt;td&gt;implements&lt;/td&gt;
&lt;td&gt;接口与实现类之间的关系：can-do&lt;/td&gt;
&lt;td&gt;接口&lt;/td&gt;
&lt;td&gt;空心三角+虚线，空心三角指向接口&lt;/td&gt;
&lt;td&gt;鸟实现了飞翔的接口&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;组合&lt;/td&gt;
&lt;td&gt;composition&lt;/td&gt;
&lt;td&gt;比聚合更强的关系：contains-a&lt;/td&gt;
&lt;td&gt;整体&lt;/td&gt;
&lt;td&gt;实心菱形+实线，实心菱形指向整体&lt;/td&gt;
&lt;td&gt;人类的头和身体是强组合关系&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;聚合&lt;/td&gt;
&lt;td&gt;aggregation&lt;/td&gt;
&lt;td&gt;暂时组装的关系：has-a&lt;/td&gt;
&lt;td&gt;组装方&lt;/td&gt;
&lt;td&gt;空心菱形+实线，空心菱形指向组装方&lt;/td&gt;
&lt;td&gt;狗和牵狗的绳子是聚合关系&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;依赖&lt;/td&gt;
&lt;td&gt;dependency&lt;/td&gt;
&lt;td&gt;一个类依赖于另一个类：depends-a&lt;/td&gt;
&lt;td&gt;被依赖方&lt;/td&gt;
&lt;td&gt;箭头+虚线，箭头指向被依赖方&lt;/td&gt;
&lt;td&gt;人喂小狗，小狗是喂这个动作的被依赖方&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;关联&lt;/td&gt;
&lt;td&gt;association&lt;/td&gt;
&lt;td&gt;类与类之间存在互相平等的使用关系：links-a&lt;/td&gt;
&lt;td&gt;平等&lt;/td&gt;
&lt;td&gt;实线&lt;/td&gt;
&lt;td&gt;人与信用卡的关系，人用信用卡，信用卡可以读取个人信息&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;-&quot;&gt;继承关系&lt;/h3&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;以现有类为基础，复制它，然后通过添加和修改这个副本来创建新类。当源类发生变化时，被修改的副本也会反应出这种变动。生物学中对科目的定义，用于解释继承关系再恰当不过。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;-&quot;&gt;相关名词定义&lt;/h5&gt;
&lt;p&gt;父类：又称源类、基类、超类；&lt;/p&gt;
&lt;p&gt;子类：又称导出类、继承类；&lt;/p&gt;
&lt;h5 id=&quot;-&quot;&gt;父类和子类&lt;/h5&gt;
&lt;p&gt;父类和子类之间的类型层次结构同时体现了他们之间的相似性和差异性。当继承现有类型时，也就创造了新的类型，同时子类又归属于父类的类型。这个新的类型不仅包括现有类型的所有成员，而且更重要的是它复制了父类的接口，这意味着所有对父类对象的调用同时可可以对子类对象发起，这遵循了编程原则之一的里氏替换原则。&lt;/p&gt;
&lt;p&gt;如果只是简单地继承一个类而不做其他任何事情，那么在父类接口中的方法将会直接继承到子类中。当需要使父类和子类产生差异时，有以下两种方式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;直接在子类中添加新的方法；在采用该种方案时需要仔细考虑是否存在父类也需要这些额外方法的可能性。&lt;/li&gt;
&lt;li&gt;覆写父类中的某个方法；该种方案需要在子类中定义与父类需覆写方法同名、同返回值类型、同方法参数类型的方法。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;那么继承是否应该只覆写父类的方法呢？&lt;/p&gt;
&lt;p&gt;如果继承只覆写了父类的方法，那么子类对象可以完全替代父类对象，这通常称之为&lt;code&gt;替代原则&lt;/code&gt;，在这种情况下的类关系称为&lt;code&gt;is-a&lt;/code&gt;；但有时又的确需要在子类中添加新的接口，这种情况下父类无法访问新添加的接口，这种情况下类关系为&lt;code&gt;is-like-a&lt;/code&gt;，这时这种父类与子类之间的关系，被视为&lt;code&gt;非存粹替代&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;多态&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在处理类层次关系的时候，如果把任意一个特定类型的对象可以当作其基类对象来对待，就使得人们可以编写出不依赖于特定类型的代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;-&quot;&gt;相关概念&lt;/h5&gt;
&lt;p&gt;前期绑定：编译器将产生对一个具体函数名字的调用，而在运行时需要将这个调用解析到将要被执行的代码的绝对地址（意味着运行前就需要知道具体代码的位置）。&lt;/p&gt;
&lt;p&gt;后期绑定：编译器只确保调用的方法存在，而且调用参数和返回值类型正确；在运行时，通过特殊代码，解析具体将要执行的代码的具体位置。&lt;/p&gt;
&lt;h5 id=&quot;-&quot;&gt;多态的实现理念&lt;/h5&gt;
&lt;p&gt;通过导出新的子类而轻松扩展设计的能力，是对改动进行封装的基本方式之一。&lt;/p&gt;
&lt;p&gt;在试图将子类对象当作其基类对象来看待时，需要解决的一个问题是：编译器无法精确地了解哪一段代码将会被执行。在OOP程序设计中，程序直到运行时才能够确定代码的位置。&lt;/p&gt;
&lt;p&gt;OOP程序设计语言使用了后期绑定的概念：编译器确保调用方法的存在，并对调用参数和返回值执行类型检查，但并不知道将被执行的确切代码。Java使用一小段特殊的代码来替代绝对地址调用，这段&lt;code&gt;特殊代码&lt;/code&gt;用来计算方法体的具体位置。Java默认是动态绑定的。&lt;/p&gt;
&lt;h5 id=&quot;-&quot;&gt;向上转型&lt;/h5&gt;
&lt;p&gt;把子类对象看作父类对象的过程，称作&lt;code&gt;向上转型&lt;/code&gt;。原因是在类图中，父类总是位于类图的顶部，把子类对象视为父类对象，即将子类类型向上推导。&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;单根继承&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Java中所有的类最终都继承自单一的基类：Object&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;单根继承结构保证所有对象都具备某些功能。Object是任何类的默认父类，是在哲学方向上继续宁的延伸思考。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;我是谁？&lt;/strong&gt;getClass()说明本质上是谁，而toString()是当前类的名片。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;我从哪里来？&lt;/strong&gt;Object()构造方法是生产对象的基本方式；clone()是繁殖对象的另一种方式。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;我到哪里去？&lt;/strong&gt;finalize()方法说明了对象的最终归属&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;我是否是独一无二的？&lt;/strong&gt;hashCode()和equals()就是判断与其他元素是否相同的一组方法。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;与其他人如何协调？&lt;/strong&gt;wait()和notify()方法是对象间通信和协作的一组方法。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;-&quot;&gt;容器&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;通常来说，如果不知道在解决某个特定问题时需要多少对象，或者他们将存活多久，那么就不可能知道如何存储这些对象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在Java标准类库中提供了大量容器。不同的容器提供了不同类型的接口和外部行为，同时对某些操作具有不同的效率。如List中的ArrayList和LinkedList由于底层实现的不同，具备不同的应用场景。&lt;/p&gt;
&lt;h5 id=&quot;-&quot;&gt;参数化类型&lt;/h5&gt;
&lt;p&gt;由于容器只存储Object，所以将对象引入置入容器时，被向上转型为Object，在取出类型时会丢失其类型。在一定程度上可以使用向下转型的方式来获取其实际类型，但是这样做存在风险。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;package&lt;/span&gt; a;

&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; java.util.*;

&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Container&lt;/span&gt; &lt;/span&gt;{
  &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String [] args)&lt;/span&gt; &lt;/span&gt;{
    List list = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; ArrayList();
    list.add(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Hello World!&quot;&lt;/span&gt;);
    list.add(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;);
    
    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(Object o : list) {
      
      String a = (String) o;
      System.out.println(a);
    }
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么用什么方式使容器记住这些对象究竟使什么类型呢？解决方案称为参数化类型，在Java中也称为泛型。表示方法为一对尖括号，中间包含类型信息。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;String&amp;gt;();&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这样一来，就限定了List中只能存放String类型的对象啦！当然，我们还是能够通过反射绕过这层验证，毕竟在编译后运行时，是去泛型的。&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;对象的创建和生命周期&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;在使用对象时，最关键的问题之一便是他们的生成和销毁方式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;-&quot;&gt;对象的创建&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;new Constructor();&lt;/strong&gt;：通过new关键词向堆中申请内存，通过Constructor来说明类的创建方式。&lt;/p&gt;
&lt;h5 id=&quot;-&quot;&gt;生命周期&lt;/h5&gt;
&lt;p&gt;Java采用&lt;code&gt;动态内存分配&lt;/code&gt;的方式。动态方式有个一般性假设：对象趋于变得复杂，所以查找和释放内存空间的开销不会对对象的创建造成重大冲击。动态方式所带来的更大的灵活性是解决一般化编程问题的要点。&lt;/p&gt;
&lt;p&gt;Java提供了被称为&lt;code&gt;垃圾收集器&lt;/code&gt;的机制，用来处理内存释放问题。垃圾收集器的运行基础是&lt;code&gt;单根继承结构&lt;/code&gt;和&lt;code&gt;只能在堆上创建对象&lt;/code&gt;的特性。&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;异常处理&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;错误处理始终是编程的难题之一。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;-&quot;&gt;什么是异常&lt;/h5&gt;
&lt;p&gt;异常是一种对象，其从出错点被&lt;code&gt;抛出&lt;/code&gt;，并被特定类型的异常处理器所&lt;code&gt;捕获&lt;/code&gt;。异常处理就像与程序正常执行路径并行的、在错误发生时执行的另一条路径。&lt;/p&gt;
&lt;h5 id=&quot;-&quot;&gt;异常的处理&lt;/h5&gt;
&lt;p&gt;异常不能被忽略，它保证一定会在某处得到处理。异常提供了一种从错误状态进行可靠恢复的途径。Java一开始就内置了异常处理，并强制你必须使用它。它是唯一可接受的错误报告方式。&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;并发编程&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在计算机编程中，存在着在同一时刻处理多个任务的思想。这些彼此独立运行的部分称为线程，同一时刻处理多个任务称为并发。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在单一处理器中，线程只是一种为单一处理器分配执行时间的手段，换而言之，如果只有一个处理器，那么多线程程序的运行不过是多个任务竞争使用处理器的性能。在多处理器的情况下，实现的才是真正意义上的并发，多处理器并行计算。&lt;/p&gt;
&lt;p&gt;多线程同时存在一个隐患，在存在共享资源的时候，可能会造成资源之间的竞争，进而造成死锁。所以在多线程修改共享资源时，必然在共享资源使用期进行锁定。&lt;/p&gt;
&lt;p&gt;在Java中，JDK1.5后提供了concurrent包支持更好的并发特性。&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;结语&lt;/h3&gt;
&lt;p&gt;以上是对象导论的一些基本概念，是继续阅读后面章节的非必要补充性材料。对于文中的一些代码段或概念，暂时不理解的，可以先放一放，等后面看完了，再回过来看就恍然大悟了。&lt;/p&gt;
&lt;p&gt;下一节将讲解对象并写第一个Java程序。欢迎关注我的微信公众号，可以更方便的获取每日推送&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1486497/201902/1486497-20190210235116712-1457876779.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
</description>
<pubDate>Sun, 10 Feb 2019 15:46:00 +0000</pubDate>
<dc:creator>Lurker潜行者</dc:creator>
<og:description>计算机是头脑延伸的工具，是一种不同类型的表达媒体。本文以背景性的和补充性的材料，介绍包括开发方法概述在内的面向对象程序设计(Object-oriented Programming,OOP)的基本概念。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lurker-yaojiang/p/10360651.html</dc:identifier>
</item>
<item>
<title>你真的了解字典(Dictionary)吗? - 码农阿宇</title>
<link>http://www.cnblogs.com/CoderAyu/p/10360608.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CoderAyu/p/10360608.html</guid>
<description>&lt;p&gt;半年前,我参加我现在所在公司的面试,面试官给了一道题,说有一个Y形的链表,知道起始节点,找出交叉节点.&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/liuzhenyulive/DictionaryMini/master/Pic/chain.gif&quot; alt=&quot;Y形链表&quot;/&gt;&lt;br/&gt;为了便于描述,我把上面的那条线路称为线路1,下面的称为线路2.&lt;/p&gt;
&lt;h2 id=&quot;思路1&quot;&gt;思路1&lt;/h2&gt;
&lt;p&gt;先判断线路1的第一个节点的下级节点是否是线路2的第一个节点,如果不是,再判断是不是线路2的第二个,如果也不是,判断是不是第三个节点,一直到最后一个.&lt;br/&gt;如果第一轮没找到,再按以上思路处理线路一的第二个节点,第三个,第四个... 找到为止.&lt;br/&gt;时间复杂度n&lt;sup&gt;2&lt;/sup&gt;,相信如果我用的是这种方法,可肯定被Pass了.&lt;/p&gt;
&lt;h2 id=&quot;思路2&quot;&gt;思路2&lt;/h2&gt;
&lt;p&gt;首先,我遍历线路2的所有节点,把节点的索引作为key,下级节点索引作为value存入字典中.&lt;br/&gt;然后,遍历线路1中节点,判断字典中是否包含该节点的下级节点索引的key,即&lt;code&gt;dic.ContainsKey((node.next)&lt;/code&gt; ,如果包含,那么该下级节点就是交叉节点了.&lt;br/&gt;时间复杂度是n.&lt;br/&gt;那么问题来了,面试官问我了,为什么时间复杂度n呢?你有没有研究过字典的&lt;code&gt;ContainsKey&lt;/code&gt;这个方法呢?难道它不是通过遍历内部元素来判断Key是否存在的呢?如果是的话,那时间复杂度还是n&lt;sup&gt;2&lt;/sup&gt;才是呀?&lt;br/&gt;我当时支支吾吾,确实不明白字典的工作原理,厚着面皮说 &quot;不是的,它是通过哈希表直接拿出来的,不用遍历&quot;,面试官这边是敷衍过去了,但在我心里却留下了一个谜,已经入职半年多了,欠下的技术债是时候还了.&lt;/p&gt;

&lt;p&gt;在看这篇文章前,不知道您使用字典的时候是否有过这样的疑问.&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;字典为什么能无限地Add呢?&lt;/li&gt;
&lt;li&gt;从字典中取Item速度非常快,为什么呢?&lt;/li&gt;
&lt;li&gt;初始化字典可以指定字典容量,这是否多余呢?&lt;/li&gt;
&lt;li&gt;字典的桶&lt;code&gt;buckets&lt;/code&gt; 长度为素数,为什么呢?&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;不管您以前有没有在心里问过自己这些问题,也不管您是否已经有了自己得答案,都让我们带着这几个问题接着往下走.&lt;/p&gt;

&lt;p&gt;什么是哈希函数?&lt;br/&gt;哈希函数又称散列函数,是一种从任何一种数据中创建小的数字“指纹”的方法。&lt;br/&gt;下面,我们看看JDK中Sting.GetHashCode()方法.&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public int hashCode() {
        int h = hash;
 //hash default value : 0 
        if (h == 0 &amp;amp;&amp;amp; value.length &amp;gt; 0) {
 //value : char storage
            char val[] = value;

            for (int i = 0; i &amp;lt; value.length; i++) {
                h = 31 * h + val[i];
            }
            hash = h;
        }
        return h;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到,无论多长的字符串,最终都会返回一个int值,当哈希函数确定的情况下,任何一个字符串的哈希值都是唯一且确定的.&lt;br/&gt;当然,这里只是找了一种最简单的字符数哈希值求法,理论上只要能把一个对象转换成唯一且确定值的函数,我们都可以把它称之为哈希函数.&lt;br/&gt;这是哈希函数的示意图.&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/liuzhenyulive/DictionaryMini/master/Pic/HashFunction.svg?sanitize=true&quot; alt=&quot;哈希函数示意图&quot;/&gt;&lt;br/&gt;所以,&lt;code&gt;一个对象的哈希值是确定且唯一的!&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;如何把哈希值和在集合中我们要的数据的地址关联起来呢?解开这个疑惑前我来看看一个这样不怎么恰当的例子:&lt;/p&gt;
&lt;p&gt;有一天,我不小心干了什么坏事,警察叔叔没有逮到我本人,但是他知道是一个叫&lt;code&gt;阿宇&lt;/code&gt;的干的,他要找我肯定先去我家,他怎么知道我家的地址呢?他不可能在全中国的家庭一个个去遍历,敲门,问&lt;code&gt;阿宇&lt;/code&gt;是你们家的熊孩子吗?&lt;/p&gt;
&lt;p&gt;正常应该是通过我的名字,找到我的身份证号码,然后我的身份证上登记着我的家庭地址(我们假设一个名字只能找到一张身份证).&lt;/p&gt;
&lt;p&gt;&lt;code&gt;阿宇&lt;/code&gt;-----&amp;gt; 身份证(身份证号码,家庭住址)------&amp;gt;我家&lt;/p&gt;
&lt;p&gt;我们就可以把由阿宇找到身份证号码的过程,理解为&lt;code&gt;哈希函数&lt;/code&gt;,身份证存储着我的号码的同时,也存储着我家的地址,身份证这个角色在字典中就是 &lt;code&gt;bucket&lt;/code&gt;,它起一个桥梁作用,当有人要找阿宇家在哪时,直接问它,准备错的,字典中,bucket存储着数据的内存地址(索引),我们要知道key对应的数据的内存地址,问buckets要就对了.&lt;/p&gt;
&lt;p&gt;key---&amp;gt;bucket的过程 ~= &lt;code&gt;阿宇&lt;/code&gt;-----&amp;gt;身份证 的过程.&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/liuzhenyulive/DictionaryMini/master/Pic/hashtable0.svg?sanitize=true&quot; alt=&quot;Alt text&quot;/&gt;&lt;/p&gt;
&lt;p&gt;警察叔叔通过家庭住址找到了我家之后,我家除了住我,还住着我爸,我妈,他敲门的时候,是我爸开门,于是问我爸爸,&lt;code&gt;阿宇&lt;/code&gt;在哪,我爸不知道,我爸便问我妈,儿子在哪?我妈告诉警察叔叔,我在书房呢.很好,警察叔叔就这样把我给逮住了.&lt;/p&gt;
&lt;p&gt;字典也是这样,因为key的哈希值范围很大的,我们不可能声明一个这么大的数组作为buckets,这样就太浪费了,我们做法时HashCode%BucketSize作为bucket的索引.&lt;/p&gt;
&lt;p&gt;假设Bucket的长度3,那么当key1的HashCode为2时,它数据地址就问buckets&lt;a href=&quot;http://www.cnblogs.com/CoderAyu/p/2%253=2&quot;&gt;2&lt;/a&gt;要,当key2的HashCode为5时,它的数据地址也是问buckets&lt;a href=&quot;http://www.cnblogs.com/CoderAyu/p/5%253=2&quot;&gt;2&lt;/a&gt;要的.&lt;/p&gt;
&lt;p&gt;这就导致同一个bucket可能有多个key对应,即下图中的Johon Smith和Sandra Dee,但是bucket只能记录一个内存地址(索引),也就是警察叔叔通过家庭地址找到我家时,正常来说,只有一个人过来开门,那么,如何找到也在这个家里的我的呢?我爸记录这我妈在厨房,我妈记录着我在书房,就这样,我就被揪出来了,我爸,我妈,我 就是字典中的一个entry.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/liuzhenyulive/DictionaryMini/master/Pic/hashtable1.svg?sanitize=true&quot; alt=&quot;Alt text&quot;/&gt;&lt;br/&gt;如果有一天,我妈妈老来得子又生了一个小宝宝,怎么办呢?很简单,我妈记录小宝宝的位置,那么我的只能巴结小宝宝,让小宝宝来记录我的位置了.&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/liuzhenyulive/DictionaryMini/master/Pic/hashtable2.svg?sanitize=true&quot; alt=&quot;Alt text&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/liuzhenyulive/DictionaryMini/master/Pic/hashtable3.svg?sanitize=true&quot; alt=&quot;Alt text&quot;/&gt;&lt;/p&gt;
&lt;p&gt;既然大的原理明白了,是不是要看看源码,来研究研究代码中字典怎么实现的呢?&lt;/p&gt;

&lt;p&gt;上次在苏州参加苏州微软技术俱乐部成立大会时,有幸参加了&lt;code&gt;蒋金楠&lt;/code&gt; 老师讲的Asp .net core框架解密,蒋老师有句话让我印象很深刻,&quot;学好一门技术的最好的方法,就是模仿它的样子,自己造一个出来&quot;于是他弄了个Asp .net core mini,所以我效仿蒋老师,弄了个DictionaryMini&lt;/p&gt;
&lt;p&gt;其源代码我放在了Github仓库,有兴趣的可以看看:&lt;a href=&quot;https://github.com/liuzhenyulive/DictionaryMini&quot; class=&quot;uri&quot;&gt;https://github.com/liuzhenyulive/DictionaryMini&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我觉得字典这几个方面值得了解一下:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;数据存储的最小单元的数据结构&lt;/li&gt;
&lt;li&gt;字典的初始化&lt;/li&gt;
&lt;li&gt;添加新元素&lt;/li&gt;
&lt;li&gt;字典的扩容&lt;/li&gt;
&lt;li&gt;移除元素&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;字典中还有其他功能,但我相信,只要弄明白的这几个方面的工作原理,我们也就恰中肯綮,他么问题也就迎刃而解了.&lt;/p&gt;
&lt;h2 id=&quot;数据存储的最小单元entry的数据结构&quot;&gt;数据存储的最小单元(Entry)的数据结构&lt;/h2&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;   private struct Entry
        {
            public int HashCode;
            public int Next;
            public TKey Key;
            public TValue Value;
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一个Entry包括该key的HashCode,以及下个Entry的索引Next,该键值对的Key以及数据Vaule.&lt;/p&gt;
&lt;h2 id=&quot;字典初始化&quot;&gt;字典初始化&lt;/h2&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;        private void Initialize(int capacity)
        {
            int size = HashHelpersMini.GetPrime(capacity);
            _buckets = new int[size];
            for (int i = 0; i &amp;lt; _buckets.Length; i++)
            {
                _buckets[i] = -1;
            }

            _entries = new Entry[size];

            _freeList = -1;
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;字典初始化时,首先要创建int数组,分别作为buckets和entries,其中buckets的index是key的&lt;code&gt;哈希值%size&lt;/code&gt;,它的value是数据在entries中的index,我们要取的数据就存在entries中.当某一个bucket没有指向任何entry时,它的value为-1.&lt;br/&gt;另外,很有意思得一点,buckets的数组长度是多少呢?这个我研究了挺久,发现取的是大于capacity的最小质数.&lt;/p&gt;
&lt;h2 id=&quot;添加新元素&quot;&gt;添加新元素&lt;/h2&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;  private void Insert(TKey key, TValue value, bool add)
        {
            if (key == null)
            {
                throw new ArgumentNullException();
            }
            //如果buckets为空,则重新初始化字典.
            if (_buckets == null) Initialize(0);
            //获取传入key的 哈希值
            var hashCode = _comparer.GetHashCode(key);
            //把hashCode%size的值作为目标Bucket的Index.
            var targetBucket = hashCode % _buckets.Length;
            //遍历判断传入的key对应的值是否已经添加字典中
            for (int i = _buckets[targetBucket]; i &amp;gt; 0; i = _entries[i].Next)
            {
                if (_entries[i].HashCode == hashCode &amp;amp;&amp;amp; _comparer.Equals(_entries[i].Key, key))
                {
                    //当add为true时,直接抛出异常,告诉给定的值已存在在字典中.
                    if (add)
                    {
                        throw new Exception(&quot;给定的关键字已存在!&quot;);
                    }
                    //当add为false时,重新赋值并退出.
                    _entries[i].Value = value;
                    return;
                }
            }
            //表示本次存储数据的数据在Entries中的索引
            int index;
            //当有数据被Remove时,freeCount会加1
            if (_freeCount &amp;gt; 0)
            {
                //freeList为上一个移除数据的Entries的索引,这样能尽量地让连续的Entries都利用起来.
                index = _freeList;
                _freeList = _entries[index].Next;
                _freeCount--;
            }
            else
            {
                //当已使用的Entry的数据等于Entries的长度时,说明字典里的数据已经存满了,需要对字典进行扩容,Resize.
                if (_count == _entries.Length)
                {
                    Resize();
                    targetBucket = hashCode % _buckets.Length;
                }
                //默认取未使用的第一个
                index = _count;
                _count++;
            }
            //对Entries进行赋值
            _entries[index].HashCode = hashCode;
            _entries[index].Next = _buckets[targetBucket];
            _entries[index].Key = key;
            _entries[index].Value = value;
            //用buckets来登记数据在Entries中的索引.
            _buckets[targetBucket] = index;
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;字典的扩容&quot;&gt;字典的扩容&lt;/h2&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;private void Resize()
        {
            //获取大于当前size的最小质数
            Resize(HashHelpersMini.GetPrime(_count), false);
        }
 private void Resize(int newSize, bool foreNewHashCodes)
        {
            var newBuckets = new int[newSize];
            //把所有buckets设置-1
            for (int i = 0; i &amp;lt; newBuckets.Length; i++) newBuckets[i] = -1;
            var newEntries = new Entry[newSize];
            //把旧的的Enties中的数据拷贝到新的Entires数组中.
            Array.Copy(_entries, 0, newEntries, 0, _count);
            if (foreNewHashCodes)
            {
                for (int i = 0; i &amp;lt; _count; i++)
                {
                    if (newEntries[i].HashCode != -1)
                    {
                        newEntries[i].HashCode = _comparer.GetHashCode(newEntries[i].Key);
                    }
                }
            }
            //重新对新的bucket赋值.
            for (int i = 0; i &amp;lt; _count; i++)
            {
                if (newEntries[i].HashCode &amp;gt; 0)
                {
                    int bucket = newEntries[i].HashCode % newSize;
                    newEntries[i].Next = newBuckets[bucket];
                    newBuckets[bucket] = i;
                }
            }

            _buckets = newBuckets;
            _entries = newEntries;
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;移除元素&quot;&gt;移除元素&lt;/h2&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;        //通过key移除指定的item
        public bool Remove(TKey key)
        {
            if (key == null)
                throw new Exception();

            if (_buckets != null)
            {
                //获取该key的HashCode
                int hashCode = _comparer.GetHashCode(key);
                //获取bucket的索引
                int bucket = hashCode % _buckets.Length;
                int last = -1;
                for (int i = _buckets[bucket]; i &amp;gt;= 0; last = i, i = _entries[i].Next)
                {
                    if (_entries[i].HashCode == hashCode &amp;amp;&amp;amp; _comparer.Equals(_entries[i].Key, key))
                    {
                        if (last &amp;lt; 0)
                        {
                            _buckets[bucket] = _entries[i].Next;
                        }
                        else
                        {
                            _entries[last].Next = _entries[i].Next;
                        }
                        //把要移除的元素置空.
                        _entries[i].HashCode = -1;
                        _entries[i].Next = _freeList;
                        _entries[i].Key = default(TKey);
                        _entries[i].Value = default(TValue);
                        //把该释放的索引记录在freeList中
                        _freeList = i;
                        //把空Entry的数量加1
                        _freeCount++;
                        return true;
                    }
                }
            }

            return false;
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我对.Net中的Dictionary的源码进行了精简,做了一个DictionaryMini,有兴趣的可以到我的github查看相关代码.&lt;br/&gt;&lt;a href=&quot;https://github.com/liuzhenyulive/DictionaryMini&quot; class=&quot;uri&quot;&gt;https://github.com/liuzhenyulive/DictionaryMini&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;字典为什么能无限地add呢&quot;&gt;字典为什么能无限地Add呢&lt;/h2&gt;
&lt;p&gt;向Dictionary中添加元素时,会有一步进行判断字典是否满了,如果满了,会用Resize对字典进行自动地扩容,所以字典不会向数组那样有固定的容量.&lt;/p&gt;
&lt;h2 id=&quot;为什么从字典中取数据这么快&quot;&gt;为什么从字典中取数据这么快&lt;/h2&gt;
&lt;p&gt;Key--&amp;gt;HashCode--&amp;gt;HashCode%Size--&amp;gt;Bucket Index--&amp;gt;Bucket--&amp;gt;Entry Index--&amp;gt;Value&lt;br/&gt;整个过程都没有通过&lt;code&gt;遍历&lt;/code&gt;来查找数据,一步到下一步的目的性时非常明确的,所以取数据的过程非常快.&lt;/p&gt;
&lt;h2 id=&quot;初始化字典可以指定字典容量这是否多余呢&quot;&gt;初始化字典可以指定字典容量,这是否多余呢&lt;/h2&gt;
&lt;p&gt;前面说过,当向字典中插入数据时,如果字典已满,会自动地给字典Resize扩容.&lt;br/&gt;扩容的标准时会把大于当前前容量的最小质数作为当前字典的容量,比如,当我们的字典最终存储的元素为15个时,会有这样的一个过程.&lt;br/&gt;new Dictionary()-------------------&amp;gt;size:3&lt;br/&gt;字典添加低3个元素----&amp;gt;Resize---&amp;gt;size:7&lt;br/&gt;字典添加低7个元素----&amp;gt;Resize---&amp;gt;size:11&lt;br/&gt;字典添加低11个元素---&amp;gt;Resize---&amp;gt;size:23&lt;/p&gt;
&lt;p&gt;可以看到一共进行了三次次Resize,如果我们预先知道最终字典要存储15个元素,那么我们可以用new Dictionary(15)来创建一个字典.&lt;/p&gt;
&lt;p&gt;new Dictionary(15)----------&amp;gt;size:23&lt;/p&gt;
&lt;p&gt;这样就不需要进行Resize了,可以想象,每次Resize都是消耗一定的时间资源的,需要把OldEnties Copy to NewEntries 所以我们在创建字典时,如果知道字典的中要存储的字典的元素个数,在创建字典时,就传入capacity,免去了中间的Resize进行扩容.&lt;/p&gt;
&lt;p&gt;Tips:&lt;br/&gt;即使指定字典容量capacity,后期如果添加的元素超过这个数量,字典也是会自动扩容的.&lt;/p&gt;
&lt;h2 id=&quot;为什么字典的桶buckets-长度为素数&quot;&gt;为什么字典的桶buckets 长度为素数&lt;/h2&gt;
&lt;p&gt;我们假设有这样的一系列keys,他们的分布范围时K={ 0, 1,..., 100 },又假设某一个buckets的长度m=12,因为3是12的一个因子,当key时3的倍数时,那么targetBucket也将会是3的倍数.&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;        Keys {0,12,24,36,...}
        TargetBucket将会是0.
        Keys {3,15,27,39,...}
        TargetBucket将会是3.
        Keys {6,18,30,42,...}
        TargetBucket将会是6.
        Keys {9,21,33,45,...}
        TargetBucket将会是9.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果Key的值是均匀分布的(K中的每一个Key中出现的可能性相同),那么Buckets的Length就没有那么重要了,但是如果Key不是均匀分布呢?&lt;br/&gt;想象一下,如果Key在3的倍数时出现的可能性特别大,其他的基本不出现,TargetBucket那些不是3的倍数的索引就基本不会存储什么数据了,这样就可能有2/3的Bucket空着,数据大量第聚集在0,3,6,9中.&lt;br/&gt;这种情况其实时很常见的。 例如，又一种场景，您根据对象存储在内存中的位置来跟踪对象,如果你的计算机的字节大小是4，而且你的Buckets的长度也为4,那么所有的内存地址都会时4的倍数,也就是说key都是4的倍数,它的HashCode也将会时4的倍数,导致所有的数据都会存储在TargetBucket=0(Key%4=0)的bucket中,而剩下的3/4的Buckets都是空的. 这样数据分布就非常不均匀了.&lt;br/&gt;K中的每一个key如果与Buckets的长度m有公因子,那么该数据就会存储在这个公因子的倍数为索引的bucket中.为了让数据尽可能地均匀地分布在Buckets中,我们要尽量减少m和K中的key的有公因子出现的可能性.那么,把Bucket的长度设为质数就是最佳选择了,因为质数的因子时最少的.这就是为什么每次利用Resize给字典扩容时会取大于当前size的最小质数的原因.&lt;br/&gt;确实,这一块可能有点难以理解,我花了好几天才研究明白,如果小伙伴们没有看懂建议看看这里.&lt;br/&gt;&lt;a href=&quot;https://cs.stackexchange.com/questions/11029/why-is-it-best-to-use-a-prime-number-as-a-mod-in-a-hashing-function/64191#64191&quot; class=&quot;uri&quot;&gt;https://cs.stackexchange.com/questions/11029/why-is-it-best-to-use-a-prime-number-as-a-mod-in-a-hashing-function/64191#64191&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最后,感谢大家耐着性子把这篇文章看完,欢迎fork DictionaryMini进行进一步的研究,谢谢大家的支持.&lt;br/&gt;&lt;a href=&quot;https://github.com/liuzhenyulive/DictionaryMini&quot; class=&quot;uri&quot;&gt;https://github.com/liuzhenyulive/DictionaryMini&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 10 Feb 2019 15:21:00 +0000</pubDate>
<dc:creator>码农阿宇</dc:creator>
<og:description>从一道亲身经历的面试题说起 半年前,我参加我现在所在公司的面试,面试官给了一道题,说有一个Y形的链表,知道起始节点,找出交叉节点. 为了便于描述,我把上面的那条线路称为线路1,下面的称为线路2. 思路</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CoderAyu/p/10360608.html</dc:identifier>
</item>
<item>
<title>语言之争与读书有感 - 溪源More</title>
<link>http://www.cnblogs.com/xiyuanMore/p/10360585.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiyuanMore/p/10360585.html</guid>
<description>&lt;p align=&quot;left&quot;&gt;　　移动互联网无处不在的今天，不同的学习方式让我们受益颇多。有人喜欢通过手机阅读各类技术专家的公众号分享；有人喜欢通过逛逛不同的博客，来了解当前时下的技术；也有人喜欢通过社区的形式，跟优秀的导师们一起梳理和发展技术发展的脉络。而我依然坚持着古老的学习理念、追求纸质书籍的实质感和仪式感，通过阅读作者的精美作品的形式来获取知识。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　当然，某种意义上讲，这种方式获取的知识或许是成本比较高的一种形式，因为..书越来越贵了。犹记得多少年前购买的技术书籍，约300页，大概只需20-30元，而如今，基本上都是六十元。当然，这也是因为读者越来越少，而印书的成本越来越贵的原。真正的好书，本来也值得花一点点钱去认真的拜读、认真品味其中的妙处。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　过年几天时间，我在家里认真的拜读了由阿里巴巴中间件团队技术改造过程中的若干问题而整理输出的技术书籍《企业IT架构转型之道-阿里巴巴中台战略思想与架构实践》。这本书系统的介绍了阿里巴巴启动中台战略的原因及架构演变之路，以及阿里巴巴为何会使用共享服务中心、以及共享服务中心搭建的原则和技术选型、高可用和高并发等问题。众所周知，阿里巴巴的技术栈主要都是Java，而笔者是一名.NET开发者，一直以来也是从事企业级架构开发的路线，我觉得这本书，值得大家来阅读。尤其是在语言之争死灰复燃的今天，更具有学习价值。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　阿里巴巴集团是国内开发者技术圈中梦想的技术殿堂，每一位阿里巴巴输出的优秀的技术人员，往往都会成为每家企业的开发者的典范，尤其是阿里巴巴输出的架构师，他们拥有丰富的高并发实战经验、具备广阔的视野和远景，更是成为IT业界最为珍贵的资源，阿里巴巴集团也输出了大量优秀的开源技术框架，这些无不令中国的开源技术社区获益颇多。可以毫不讳言的说，阿里巴巴集团对中国的开源技术社区做出的贡献几乎无可比拟。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　笔者认为，微软也是同样一家类似于阿里巴巴集团的优秀的技术企业，.NET也是一种优秀的技术，在过去若干年的发展历程中，如果不是由于微软的封闭政策，倒也不至于.NET与互联网逐渐绝缘。然而随着.NET CORE的开源，意味着这种局面实际上已经有所改观。.NET Core体系之中，提供了一系列的技术组件，可以让开发者们更加方便的应用，例如，.NET Core开发的服务，同样能够运行在容器之上，也可以使用UWP或Xamarin开发跨平台应用、同样也可以用.NET Core开发基于树莓派的程序，可以使用ML.NET进行机器学习的开发。可以说，其他语言能做的，.NET 同样可以实现。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　作为Java开发者，勿因为一时的所谓百分比而沾沾自喜，开发语言取得的美好成就，从来不是个人的成就，而是天时+地利+人和+偶然或必然。而作为.NET开发者，同样也无需自暴自弃，他山之石，可以攻玉的道理，大家实际上都非常清楚，作为.NET开发者，应当适当的涉猎与非本语言相关的技术资料来实现技术储备。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　笔者的上一篇文章中《由优劣语言之争引起的思考》,大部分的回复都是说，语言不过是解决问题的武器，优秀的开发者，往往善于使用不同的武器来解决问题，灵活的运用不同语言的特点，可以让开发者应对技术问题时，能够无往而不利。不管是.NET开发者也好，还是Java开发者也好，都承载着的是企业飞速发展的梦想，不同的语言，实际上都是为了推动企业快速进步的动力。尤其是在当今，微服务和容器技术的广泛应用，更是让语言不再成为企业开发者的鸿沟。在企业发展过程中，所遇到的无穷无尽的业务问题，才是开发者们真正需要考虑的核心问题。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　开发者应时刻保持创新精神。或许有相当一部分企业已经完成了企业级架构的建设，初步建设了较为完善的企业级信息化管理体系，这些系统的功能都已经比较稳定，或许只需要小范围的运营维护才行。然而，哪怕是百分之十的变更，也不得不让系统进行重构。如何让建设的系统能够成为宝贵的积累，而不是糟粕，让新的系统架构能够与时俱进，则往往需要开发者们具备创新意识。在企业级信息化体系中的创新者，不见得是来自于外部的创新者，而大部分往往是企业内部具有创新意识的优秀员工。尤其是掌握企业信息化系统核心业务流程和技术细节的开发者，更具有创新潜力。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　除此之外，作为开发者，最重要的心态，依然是开放的心态，海纳百川、包容万物，时刻学习。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
</description>
<pubDate>Sun, 10 Feb 2019 15:04:00 +0000</pubDate>
<dc:creator>溪源More</dc:creator>
<og:description>语言之争与读书有感 移动互联网无处不在的今天，不同的学习方式让我们受益颇多。有人喜欢通过手机阅读各类技术专家的公众号分享；有人喜欢通过逛逛不同的博客，来了解当前时下的技术；也有人喜欢通过社区的形式，跟</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiyuanMore/p/10360585.html</dc:identifier>
</item>
<item>
<title>Linux内核编程规范与代码风格 - trav</title>
<link>http://www.cnblogs.com/trav/p/10356415.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/trav/p/10356415.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;source: https://www.kernel.org/doc/html/latest/process/coding-style.html&lt;br/&gt;translated by trav, travmymail@gmail.com&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是一篇阐述Linux内核编程代码风格的文档，译者以学习为目的进行翻译。&lt;/p&gt;
&lt;h3 id=&quot;缩进&quot;&gt;1 缩进&lt;/h3&gt;
&lt;p&gt;Tab的宽度是八个字符，因此缩进的宽度也是八个字符。有些异教徒想让缩进变成四个字符，甚至是两个字符的宽度，这些人和那些把 PI 定义为 3 的人是一个路子的。&lt;/p&gt;
&lt;p&gt;注意：缩进的全部意义在于清晰地定义语句块的开始与结束，特别是当你盯着屏幕20个小时之后，你会发现长的缩进宽度的作用。&lt;/p&gt;
&lt;p&gt;现在有些人说八个字符的宽度太宽了，这会让代码往右移很远，在一块八十字符宽的屏幕上，这样的代码会很难阅读。对此的回答是，如果你写的代码需要超过三层的缩进，那么你把一切都搞砸了，你应该修复你的程序。&lt;/p&gt;
&lt;p&gt;简而言之，八个字符宽度的缩进让代码更容易阅读，并且额外的好处就是提醒你，不要在一个函数里写太多层的嵌套逻辑。请记住这个警示。&lt;/p&gt;
&lt;p&gt;switch语句的缩进方式是让case与switch对齐：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;switch (suffix) {
case 'G':
case 'g':
        mem &amp;lt;&amp;lt;= 30;
        break;
case 'M':
case 'm':
        mem &amp;lt;&amp;lt;= 20;
        break;
case 'K':
case 'k':
        mem &amp;lt;&amp;lt;= 10;
        /* fall through */
default:
        break;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不要在单独一行里写多个语句，除非你想干什么不为人知的事：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if (condition) do_this;
  do_something_everytime;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对了，不要把多个赋值语句放在同一行，内核的代码风格是十分简洁的，请尽量避免使用复杂的表达式。&lt;/p&gt;
&lt;p&gt;除了在注释、文档和Kconfig中，永远不要使用空格作为缩进，上面的例子是故意犯的错误。&lt;/p&gt;
&lt;p&gt;找一个像样的编辑器，不要在行末留有空格。&lt;/p&gt;
&lt;h3 id=&quot;换行&quot;&gt;2 换行&lt;/h3&gt;
&lt;p&gt;规范代码风格的目的是提高代码的可读性和维护性。&lt;/p&gt;
&lt;p&gt;单行的宽度限制为八十列，这是强烈推荐的设置。&lt;/p&gt;
&lt;p&gt;任何一行超过八十列宽度的语句都应该拆分成多个行，除非超过八十列的部分可以提高可读性且不会隐藏信息。拆分出来的子句长度总是应该比其主句要短，并且应该尽量靠右。这条法则同样适用于一个有很长的参数列表的函数头。然而，千万不要把用户可见的字符串，比如 printk 的信息，拆分成多行，因为这样会导致使用 grep 的时候找不到这些信息。&lt;/p&gt;
&lt;h3 id=&quot;括号与空格&quot;&gt;3 括号与空格&lt;/h3&gt;
&lt;p&gt;另一个关于 C 代码风格的议题就是大括号的位置。这个问题不像缩进那么具有技术性，我们并不能说某一种风格要在技术上优于另一种风格。但是我们更推荐的，就是有远见的 Kernighan 和 Ritchie 展示的方式，把左括号放在行末，把右括号放在行首：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if (x is true) {
        we do y
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这同样适用于其他非函数的语句块 (if, switch, for, while, do) ：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;switch (action) {
case KOBJ_ADD:
        return &quot;add&quot;;
case KOBJ_REMOVE:
        return &quot;remove&quot;;
case KOBJ_CHANGE:
        return &quot;change&quot;;
default:
        return NULL;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然而，有一个特殊的例子，就是函数：函数的左括号应该放在行首：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int function(int x)
{
        body of function
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;异教徒们会认为这样的风格是不一致的，但是所有有脑子的人都知道尽管是 K&amp;amp;R 也是不一致的(译者注：K&amp;amp;R这本书的第一版和第二版有不一致的地方)。除此之外，我们知道函数是很特殊的，在 C 语言中，你不能有嵌套函数。&lt;/p&gt;
&lt;p&gt;注意到，右括号一般是单独成一行的，除非右括号之后紧随着紧密结合的语句，例如 do-while 语句和 if 语句：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;do {
        body of do-loop
} while (condition);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以及&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if (x == y) {
        ..
} else if (x &amp;gt; y) {
        ...
} else {
        ....
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;依据：K&amp;amp;R&lt;/p&gt;
&lt;p&gt;注意到，这种风格应该在不降低可读性的前提下尽可能减少空行的数量。想一想，在一块只有 25 行的屏幕上，无用的换行少了，那么就有更多的空行来写注释。&lt;/p&gt;
&lt;p&gt;当单行语句可以解决的时候，不要使用没必要的括号：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if (condition)
        action();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以及&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if (condition)
        do_this();
else
        do_that();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这一点不适用于只有一个 case 有单行，其他 case 有多行的情况：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if (condition) {
        do_this();
        do_that();
} else {
        otherwise();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在一个循环中超过一个语句的情况也同样需要使用括号：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;while (condition) {
        if (test)
                do_something();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3.1 空格&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Linux 内核风格的空格主要用在一些关键字上，即在关键字之后添一个空格。值得关注的例外是一些长得像函数的关键字，比如：&lt;strong&gt;sizeof&lt;/strong&gt;, &lt;strong&gt;typeof&lt;/strong&gt;, &lt;strong&gt;alignof&lt;/strong&gt;, &lt;strong&gt;&lt;strong&gt;attribute&lt;/strong&gt;&lt;/strong&gt;，在 Linux 中，这些关键字的使用都会带上一对括号，尽管在 C 语言的使用上并不需要带上括号。&lt;/p&gt;
&lt;p&gt;所以在下面这些关键字之后添加一个空格：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if, switch, case, for, do, while&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是不要添加在 &lt;strong&gt;sizeof&lt;/strong&gt;, &lt;strong&gt;typeof&lt;/strong&gt;, &lt;strong&gt;alignof&lt;/strong&gt;, &lt;strong&gt;&lt;strong&gt;attribute&lt;/strong&gt;&lt;/strong&gt; 之后：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;s = sizeof(struct file);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不要在括号周围多此一举的添加空格，下面这个例子糟透了：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;s = sizeof( struct file );&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在声明指针或者返回值为指针的函数时，星号的位置应该紧靠着变量名或函数名，而不是类型名，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;char *linux_banner;
unsigned long long memparse(char *ptr, char **retptr);
char *match_strdup(substring_t *s);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在二元操作符和三元操作符周围添加一个空格，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;=  +  -  &amp;lt;  &amp;gt;  *  /  %  |  &amp;amp;  ^  &amp;lt;=  &amp;gt;=  ==  !=  ?  :&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是不要在一元操作符之后添加空格：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;amp;  *  +  -  ~  !  sizeof  typeof  alignof  __attribute__  defined&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不要在后缀的自增自减一元操作符之前添加空格：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;++  --&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不要在前缀的自增自减一元操作符之后添加空格：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;++  --&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不要在结构体成员操作符周围添加空格：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;.  -&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不要在行末添加多余的空格。一些编辑器的“智能”缩进会帮你在行首添加一些空格，好让你在下一行可以立即写代码。但是某些编辑器不会帮你把多余的空格给删掉，尽管你已经写完了一行代码。比如你只想留一行空行，但是编辑器却“好心”地帮你填上了一些空格。这样一来，你就在行末添加了多余的空格。&lt;/p&gt;
&lt;p&gt;Git 通常会警告你，让你除去这些多余的空格，并且可以帮你删掉这些东西。但是，如果你让 Git 一直帮你这样修补你的代码，这很可能导致代码行的上下错乱，之后的自动修补的失败。&lt;/p&gt;
&lt;h3 id=&quot;命名&quot;&gt;4 命名&lt;/h3&gt;
&lt;p&gt;C 是一种简洁粗旷的语言，因此，你的命名也应该是简洁的。C 程序员不会像 Modula-2 和 Pascal 程序员那样使用 ThisVariableIsATemporaryCounter 这种“可爱”的名字，一个 C 程序员会把这种变量命名为 tmp ，如此简洁易写。&lt;/p&gt;
&lt;p&gt;尽管看到一个混合大小写的名字让人皱眉，不过对于全局变量来说，一个具有描述性的名字还是很有必要的。去调用一个名为 foo 的全局函数同样让人难以接受。&lt;/p&gt;
&lt;p&gt;全局变量(只有当你真正需要的时候才用它)和全局函数需要使用描述性的名字。如果你有一个计算活跃用户数量的函数，你应该起这样一个名字 &lt;code&gt;count_active_users()&lt;/code&gt; 或者类似的，而不是这样一个名字 &lt;code&gt;cntusr()&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;起一个包含函数类型的名字(匈牙利命名法)是摧残大脑的行为，编译器知道函数的类型并且会检查类型，这样的名字不会起到任何帮助，它仅仅会迷惑程序员。所以，也难怪微软做出了那么多充满了 bug 的程序。&lt;/p&gt;
&lt;p&gt;局部变量名应该简短，如果你需要写一个循环，定义一个计数器，在不产生歧义的情况下，你大可命名为 i ，命名为 loop_counter 是生产力很低的行为。同样地，tmp 可以是任何类型的临时变量。&lt;/p&gt;
&lt;p&gt;如果你担心会弄混变量名，那么你遇到了另一个问题，你患上了函数增长荷尔蒙失调综合症。&lt;/p&gt;
&lt;h3 id=&quot;typedefs&quot;&gt;5 Typedefs&lt;/h3&gt;
&lt;p&gt;请不要使用 vps_t 这种东西，这是 typedef 的错误用法，当你看到&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;vps_t a;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种写法时，它究竟是个什么东西？相反，如果是这样的写法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;struct virtual_container *a;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你就很容易知道 a 代表着什么。&lt;/p&gt;
&lt;p&gt;很多人认为 typedef 是用来帮助提高可读性的，但是事实往往不是这样的。typedef 仅仅有如下用处：&lt;/p&gt;
&lt;p&gt;a. 封装对象(typedef 可以方便的隐藏对象)&lt;/p&gt;
&lt;p&gt;例如，pte_t 会把对象封装起来，你仅仅只能通过合适的“访问函数”(成员函数)来访问这个对象。&lt;/p&gt;
&lt;p&gt;注意：封装和“访问函数”(成员函数)本身就不是好东西，我们使用 pte_t 这种东西的理由就是，它指向的对象本身绝对没有东西可以访问(我们压根儿不使用封装和成员函数那一套)。&lt;/p&gt;
&lt;p&gt;b. 指明整数类型，这种抽象可以帮助我们避免一些使用 int 和 long 的疑虑&lt;/p&gt;
&lt;p&gt;u8/u16/u32 是完美的使用 typedef 的例子。&lt;/p&gt;
&lt;p&gt;注意：你必须要有明确的理由来使用这些用法，如果一些地方使用的本身就是 unsigned long ，那么你没有任何理由这样做&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;typedef unsigned long myflags_t;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是如果你有明确的理由来解释为什么在某种情况下使用 unsigned int，而在其他情况下使用 unsigned long，那么大可使用 typedef。&lt;/p&gt;
&lt;p&gt;c. 使用 sparse 去新建一个类型来做类型检查&lt;/p&gt;
&lt;p&gt;d. 在某些情况下新建一个与 C99 标准相等的类型&lt;/p&gt;
&lt;p&gt;尽管只需要花一小段眼睛和大脑的时间来适应新标准的类型，如 uint32_t，但是一些人还是反对使用他们。&lt;/p&gt;
&lt;p&gt;因此，你可以使用 Linux 独有的 u8/u16/u32/u64 和他们的有符号版本，也可以使用和他们等价的新标准的类型，他们的使用都不是强制的。&lt;/p&gt;
&lt;p&gt;当你所编辑的代码已经使用了某一种版本时，你应该按照原样使用相同的版本。&lt;/p&gt;
&lt;p&gt;e. 用户空间中的类型安全&lt;/p&gt;
&lt;p&gt;用户空间中的某些特定的结构体中，我们不能使用 C99 定义的新类型以及上述的 u32，取而代之，我们统一使用 __u32 之类的类型。&lt;/p&gt;
&lt;p&gt;也许还有其他情况，但是基本的规则就是，如果你不能满足上述其中一条情况，你就永远不要使用 typedef。&lt;/p&gt;
&lt;p&gt;通常，一个指针或者一个有可访问元素的结构体，都不应该使用 typedef。&lt;/p&gt;
&lt;h3 id=&quot;函数&quot;&gt;6 函数&lt;/h3&gt;
&lt;p&gt;函数应该短小精悍，一个函数只干一件事。一个函数的代码两个屏幕就应该装得下(ISO/ANSI标准屏幕大小是80x24)，简单说就是，做一件事并且把它做好。&lt;br/&gt;数的最大长度与函数的复杂度和缩进程度成反比，所以，如果你有一个简单的函数，函数里面只是需要处理一个又一个的 case，每个 case 只是干一些小事，函数长度长一些也没关系。&lt;/p&gt;
&lt;p&gt;然而，如果你的函数十分复杂，你怀疑一个不像你一样天才的高中生看不懂，你应该遵守函数最大的长度的限制，使用一些有描述性名称的辅助函数。如果你认为函数的性能至关重要，你可以让编译器把这些辅助函数编译成内联函数，一般情况下编译器可以比你做得更好。&lt;/p&gt;
&lt;p&gt;另一个测量函数的因素是局部变量的数量，他们不应该超出5-10个这个范围，否则你就犯了一些错误。重新思考这个函数，把它拆分成更小的几段。人类的大脑一般只能同时关注七件不同的事，更多需要关注的事情意味着更多的困扰。尽管你认为你是个天才，但是你也希望理解一段你两周之前写的代码。&lt;/p&gt;
&lt;p&gt;在源文件中，用一个空行分割不同的函数，如果函数需要导出到外部使用，那么它对应的 EXPORT 宏应当紧随在函数之后，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int system_is_up(void)
{
        return system_state == SYSTEM_RUNNING;
}
EXPORT_SYMBOL(system_is_up);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;函数原型中，参数名应该与参数类型引起写出来，尽管 C 语言允许只写上参数类型，但是我们更推荐参数名，因为这是一种为读者提供有价值信息的简单方式。&lt;/p&gt;
&lt;p&gt;不要在函数原型之前使用&lt;code&gt;extern&lt;/code&gt;关键字，因为这是不必要且多余的。&lt;/p&gt;
&lt;h3 id=&quot;集中函数出口&quot;&gt;7 集中函数出口&lt;/h3&gt;
&lt;p&gt;尽管许多人反对，但是 goto 语句频繁地以无条件跳转的形式被编译器使用。&lt;/p&gt;
&lt;p&gt;当函数有多个出口，并且返回之前需要做很多相似的工作时，比如清理空间，这时候 goto 语句是十分方便的。当然了，如果没有类似的清理工作要在返回之前做，那么直接返回即可。&lt;/p&gt;
&lt;p&gt;根据 goto 的作用来决定一个 label 的名字，如果 goto 语言要去释放缓存，那么&lt;code&gt;out_free_buffer:&lt;/code&gt;会是一个好名字。避免使用 GW-BASIC 的命名方式，比如 &lt;code&gt;err1:&lt;/code&gt; &lt;code&gt;err2:&lt;/code&gt;，因为当你需要新加或者删除某些函数出口时，你就需要重新排列标签数字，这会让代码的正确性难以得到保证。&lt;/p&gt;
&lt;p&gt;使用 goto 的理由如下：&lt;/p&gt;
&lt;p&gt;无条件跳转易于理解和阅读&lt;/p&gt;
&lt;p&gt;可以减少嵌套&lt;/p&gt;
&lt;p&gt;可以减少修改个别函数出口代码所造成的错误&lt;/p&gt;
&lt;p&gt;算是帮助编译器做了一些优化的工作&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int fun(int a)
{
        int result = 0;
        char *buffer;

        buffer = kmalloc(SIZE, GFP_KERNEL);
        if (!buffer)
                return -ENOMEM;

        if (condition1) {
                while (loop1) {
                        ...
                }
                result = 1;
                goto out_free_buffer;
        }
        ...
out_free_buffer:
        kfree(buffer);
        return result;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一个常见的 bug 被称作 one err bug，它长得像这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;err:
        kfree(foo-&amp;gt;bar);
        kfree(foo);
        return ret;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;bug 在于某些 goto 语句跳转到此时，foo 仍然是 NULL，修复此 bug 的简单方式就是将一个 label 拆分成两个，&lt;code&gt;err_free_bar:&lt;/code&gt; 和 &lt;code&gt;err_free_foo:&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;err_free_bar:
       kfree(foo-&amp;gt;bar);
err_free_foo:
       kfree(foo);
       return ret;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;事实上，你应该进行测试，模拟错误情况的发生，测试所有的出口代码。&lt;/p&gt;
&lt;h3 id=&quot;注释&quot;&gt;8 注释&lt;/h3&gt;
&lt;p&gt;注释是好的，但是要避免过分注释。永远不要去尝试解释你的代码如何工作，而是花时间在写出好的代码来，解释一段烂代码是浪费时间。&lt;/p&gt;
&lt;p&gt;一般来说，你应该去说明你的代码做了什么，而不是怎么做。同样地，尽量避免在函数体内写注释，如果你的函数如此复杂，以致于你需要在函数体内分几段注释来解释，那么你应该回到第六节去看看。你可以写一小段的注释来标记或者提醒大家哪些地方写得真聪明(或者真烂)，但是不要做得太过分。除此之外，你应该把注释写在函数开头，告诉人们这个函数干了什么，为什么要这样干。&lt;/p&gt;
&lt;p&gt;当你给 kernel API 进行注释的时候，请你使用 kernel-doc 的格式。具体参见 https://www.kernel.org/doc/html/latest/doc-guide/index.html#doc-guide&lt;/p&gt;
&lt;p&gt;多行注释推荐的格式如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/*
 * This is the preferred style for multi-line
 * comments in the Linux kernel source code.
 * Please use it consistently.
 *
 * Description:  A column of asterisks on the left side,
 * with beginning and ending almost-blank lines.
 */&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于在 net/ 和 drivers/net/ 中的文件，推荐的多行注释格式如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/* The preferred comment style for files in net/ and drivers/net
 * looks like this.
 *
 * It is nearly the same as the generally preferred comment style,
 * but there is no initial almost-blank line.
 */&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对一些数据和变量进行注释也是必要的，无论他们是基本类型的还是派生类型的。为了进行注释，你应该在一行内只声明一个变量，不要使用逗号进行多个声明，这让你有地方对每一个变量进行注释。&lt;/p&gt;
&lt;h3 id=&quot;你已经弄得一团糟&quot;&gt;9 你已经弄得一团糟&lt;/h3&gt;
&lt;p&gt;没关系，我们都犯过错。你的那些 Unix 的老手朋友们可能会告诉你，GNU emacs 能帮你自动地对 C 代码进行排版，你也注意到它确实可以。但是它默认的排版方式真的很糟糕，事实上，即便是在键盘上乱敲也比它来的好看。相信我，无数的猴子在 GNU emacs 上乱敲是不会做出好的程序的。&lt;/p&gt;
&lt;p&gt;因此，你可以选择直接把 GNU emacs 给删了，或者修一修它，让它恢复正常。如果你选择了后者，那么请把下面的东西拷贝到你的 .emacs 文件中：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;(defun c-lineup-arglist-tabs-only (ignored)
  &quot;Line up argument lists by tabs, not spaces&quot;
  (let* ((anchor (c-langelem-pos c-syntactic-element))
         (column (c-langelem-2nd-pos c-syntactic-element))
         (offset (- (1+ column) anchor))
         (steps (floor offset c-basic-offset)))
    (* (max steps 1)
       c-basic-offset)))

(add-hook 'c-mode-common-hook
          (lambda ()
            ;; Add kernel style
            (c-add-style
             &quot;linux-tabs-only&quot;
             '(&quot;linux&quot; (c-offsets-alist
                        (arglist-cont-nonempty
                         c-lineup-gcc-asm-reg
                         c-lineup-arglist-tabs-only))))))

(add-hook 'c-mode-hook
          (lambda ()
            (let ((filename (buffer-file-name)))
              ;; Enable kernel mode for the appropriate files
              (when (and filename
                         (string-match (expand-file-name &quot;~/src/linux-trees&quot;)
                                       filename))
                (setq indent-tabs-mode t)
                (setq show-trailing-whitespace t)
                (c-set-style &quot;linux-tabs-only&quot;)))))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这会让你的 emacs 更好地满足内核的代码风格。&lt;/p&gt;
&lt;p&gt;但是即使你不能让你的 emacs 恢复正常，也有解救方法：使用 indent 。&lt;/p&gt;
&lt;p&gt;同样的问题出现了，GNU indent 和 GNU emacs 有同样的问题，因此你需要一些命令行选项来进行配置。但是事情也没那么糟，因为 GNU indent 的制造者承认 K&amp;amp;R 的权威性，所以你只需要添加命令行参数 -kr -i8 (表示 K&amp;amp;R，8个字符宽的缩进)，或者使用 scripts/Lindent 也可以。&lt;/p&gt;
&lt;p&gt;indent 有很多命令行选项，特别是注释的格式化方面，你可以通过 man 帮助页面来查看，不过请记住：indent 不是用来修复烂程序的。&lt;/p&gt;
&lt;p&gt;注意：你也可以使用 clang-format 来完成这些格式化的工作，具体参见 https://www.kernel.org/doc/html/latest/process/clang-format.html#clangformat&lt;/p&gt;
&lt;h3 id=&quot;kconfig-配置文件&quot;&gt;10 Kconfig 配置文件&lt;/h3&gt;
&lt;p&gt;对于 Linux 中的 Kconfig 配置文件，他们的缩进是有所不同的。在 config 定义下的缩进是一个 tab，而里面的 help 文本是两个空格，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;config AUDIT
      bool &quot;Auditing support&quot;
      depends on NET
      help
        Enable auditing infrastructure that can be used with another
        kernel subsystem, such as SELinux (which requires this for
        logging of avc messages output).  Does not do system-call
        auditing without CONFIG_AUDITSYSCALL.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而对于有可能导致危险的动作(比如特定文件系统的写支持)，你应该在提示文本中直接指出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;config ADFS_FS_RW
      bool &quot;ADFS write support (DANGEROUS)&quot;
      depends on ADFS_FS
      ...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体细节参见 Documentation/kbuild/kconfig-language.txt&lt;/p&gt;
&lt;h3 id=&quot;数据结构&quot;&gt;11 数据结构&lt;/h3&gt;
&lt;p&gt;对于单线程环境里创建和销毁的一些数据结构，如果他们对于线程外是可见的，那么总是应该有引用计数。在内核里，垃圾收集器(GC)是不存在的，这意味着你必须对你使用过的数据进行引用计数。&lt;/p&gt;
&lt;p&gt;进行引用计数意味着你可以避免死锁，允许多个用户并行访问数据，并且不用担心数据因为睡眠或者其他原因而找不到。&lt;/p&gt;
&lt;p&gt;注意，锁不是引用计数的替代品。锁是为了保持数据的一致性，而引用计数是一种内存管理计数。通常这两种技术都是需要的，我们不要把他们搞混。&lt;/p&gt;
&lt;p&gt;当有多个不同类的使用者时，很多数据结构会使用二级引用计数。第二级的引用计数会统计第二级使用者的数量，只有当第二级引用计数递减至零时，全局的第一级引用计数才会减一。&lt;/p&gt;
&lt;p&gt;这种多级引用计数在内存管理(struct mm_struct: mm_users and mm_count)和文件系统(struct super_block: s_count and s_active)中都有使用。&lt;/p&gt;
&lt;p&gt;记住，如果其他线程可以发现并使用你的数据结构，而你却没有引用计数，那么这基本就是一个 bug。&lt;/p&gt;
&lt;h3 id=&quot;宏枚举与rtlreal-time-linux&quot;&gt;12 宏、枚举与RTL(Real Time Linux)&lt;/h3&gt;
&lt;p&gt;常量宏和枚举的命名都是大写的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#define CONSTANT 0x12345&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当定义一些有关联的常量时，使用枚举是一个很好的选择。&lt;/p&gt;
&lt;p&gt;定义宏一般都使用大写，但是函数宏可以使用小写。&lt;/p&gt;
&lt;p&gt;通常，我们更推荐把内联函数定义为宏。&lt;/p&gt;
&lt;p&gt;包含多条语句的宏应该包含在一个 do-while 循环体中：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#define macrofun(a, b, c)                       \
        do {                                    \
                if (a == 5)                     \
                        do_this(b, c);          \
        } while (0)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用宏时应该避免的情况：&lt;/p&gt;
&lt;p&gt;1) 影响程序控制流的宏&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#define FOO(x)                                  \
        do {                                    \
                if (blah(x) &amp;lt; 0)                \
                        return -EBUGGERED;      \
        } while (0)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是一个非常坏的坏主意。它看起来像个函数，然而却会导致调用者返回到上一层。宏的设计不要打断程序的控制流。&lt;/p&gt;
&lt;p&gt;2) 依赖局部变量的宏&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#define FOO(val) bar(index, val)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这看起来像个好东西，但其实糟透了，并且容易让人困扰。当其他人阅读这段代码时，他一个细微的改动可能导致严重的危害。&lt;/p&gt;
&lt;p&gt;3) 带参数的宏当作左值&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;FOO(x) = y;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果有人把 FOO 变成内联函数，那么这段代码就错了。&lt;/p&gt;
&lt;p&gt;4) 忘了优先级&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#define CONSTANT 0x4000
#define CONSTEXP (CONSTANT | 3)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用宏来定义常量的时候，必须要括上括号，带有参数的宏也要注意。&lt;/p&gt;
&lt;p&gt;5) 在定义宏函数时发生命名冲突&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#define FOO(x)                          \
({                                      \
        typeof(x) ret;                  \
        ret = calc_ret(x);              \
        (ret);                          \
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ret 是一个很容易和局部变量发生冲突的名字，而 __foo_ret 这样的名字则很少会发生冲突。&lt;/p&gt;
&lt;p&gt;C++ 手册全面地阐述了宏定义的细节，gcc 手册同样也阐述了汇编语言使用的 RTL 规则，具体请自行查看。&lt;/p&gt;
&lt;h3 id=&quot;打印内核信息&quot;&gt;13 打印内核信息&lt;/h3&gt;
&lt;p&gt;内核开发者喜欢被视为有素养的，好的英文拼写和准确的内核信息能给人留下好的印象，因此，不要使用一些单词的缩写，比如 dont，而是 do not 或者 don't。把提示信息写得尽可能准确、清晰、无二义。&lt;/p&gt;
&lt;p&gt;内核信息不需要在末尾加上句号&lt;/p&gt;
&lt;p&gt;在圆括号中打印数字(%d)没有任何意义，应该避免这样干。&lt;/p&gt;
&lt;p&gt;在&amp;lt;linux/device.h&amp;gt;中有许多驱动模型的诊断宏，你应该使用这些宏来确保消息匹配正确的设备和驱动，并正确的标记它们的级别：dev_err(), dev_warn(), dev_info(), and so forth。对于没有关联特定设备的消息，&amp;lt;linux/printk.h&amp;gt;中定义了 pr_notice(), pr_info(), pr_warn(), pr_err(), etc。&lt;/p&gt;
&lt;p&gt;编写好的调试信息是一项巨大的挑战，一旦你完成了，这些信息会对远程调试产生巨大帮助。调试信息与普通信息不同，pr_XXX() 函数在任何条件下都会进行打印，而 pr_debug() 却不是，这些与调试有关的函数默认都不会被编译，除非你定义了一个 DEBUG 宏或者 CONFIG_DYNAMIC_DEBUG 宏来显式地让编译器编译他们。还有一个惯例就是使用 VERBOSE_DEBUG 为那些已经开启 DEBUG 的用户添加 dev_vdbg() 消息。&lt;/p&gt;
&lt;p&gt;很多子系统在对应的 makefile 里都有 Kconfig 调试选项来打开 -DDEBUG，或者是在文件里定义宏 #define DEBUG。当调试信息可以被无条件打印，或者说已经编译了和调试有关的 #ifdef 段，那么 printk(KERN_DEBUG ...) 就可以用来打印调试信息。&lt;/p&gt;
&lt;h3 id=&quot;分配内存&quot;&gt;14 分配内存&lt;/h3&gt;
&lt;p&gt;内核提供了下面这些通用的内存分配器：kmalloc(), kzalloc(), kmalloc_array(), kcalloc(), vmalloc(), and vzalloc()。具体细节参见 API 文档。&lt;/p&gt;
&lt;p&gt;为一个结构体分配内存的形式最好是这样的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;p = kmalloc(sizeof(*p), ...);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另一种写出结构体名字的方式(sizeof(struct name))会破坏可读性并且给 bug 制造了机会：修改结构体名字却忘了修改对于的 sizeof 语句。&lt;/p&gt;
&lt;p&gt;另外，在 malloc 之前添加上一个强制的类型转换，把空类型的指针转换为特定类型的指针，这些是多此一举的操作，他们应当交给编译器来干，而不是你。&lt;/p&gt;
&lt;p&gt;分配一个数组的形式最好是这样的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;p = kmalloc_array(n, sizeof(...), ...);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;分配一个零数组的形式最好是这样的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;p = kcalloc(n, sizeof(...), ...);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;两种形式都会检查溢出，并且溢出发生时返回一个空指针 NULL。&lt;/p&gt;
&lt;h3 id=&quot;内联之灾&quot;&gt;15 内联之灾&lt;/h3&gt;
&lt;p&gt;一个很常见的误解就是，人们认为 gcc 有一种让他们的程序跑得更快的魔法，就是内联。然而，内联往往也有不合适的用法(例如第十二节提到的替换宏)。inline 关键字的泛滥，会使内核变大，从而使整个系统运行速度变慢，因为大内核会占用更多的CPU高速缓存，同时会导致可用内存页缓存减少。想象一下，一次页缓存未命中就会导致一次磁盘寻址，这至少耗费5毫秒。5毫秒足够CPU运行很多很多的指令。&lt;/p&gt;
&lt;p&gt;一个基本的原则就是，如果一个函数有3行以上的代码，就不要把它变成内联函数。有一个例外，若某个参数是一个编译时常数，且你确定因为这个常量，编译器在编译时能优化掉函数的大部分代码，那么加上 inline 关键字。kmalloc() 就是个很好的例子。&lt;/p&gt;
&lt;p&gt;人们经常主张可以给只用一次的静态函数加上 inline 关键字，这样不会有任何损失。虽然从技术上来说这样没错，但是实际上 gcc 会自动内联这些函数。&lt;/p&gt;
&lt;h3 id=&quot;函数返回值与名称&quot;&gt;16 函数返回值与名称&lt;/h3&gt;
&lt;p&gt;函数可以返回不同种类的值，但是最普遍的就是表示运行成功或失败的值。这样的值可以用预先定义好的错误码表示(-Exxx = failure, 0 = success)，或者一个布尔值(0 = failure, non-zero = success)&lt;/p&gt;
&lt;p&gt;混合两种方式会使代码变得复杂，并且很难找到 bug。如果C语言能明确区分整型和布尔型，那么编译器会替我们发现这个问题……但是它不会那么做。为了避免这种问题，一定要谨记如下约定：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;如果函数名是一个短语，表示的是一个动作，或者一个命令，那么返回值应该使用错误码的方式。
如果函数名是一句话，表示的是一个断言，那么应该使用布尔值的方式。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例如，add work 是一个动作，那么 add_work() 返回值为0则表示成功，-EBUSY表示失败。PCI device present是一个断言，那么 pci_dev_present() 返回值为1表示成功，0表示失败。&lt;/p&gt;
&lt;p&gt;可导出(EXPORT)的函数都应该遵守这个约定，私有(static)函数不需要，不过我建议你还是遵守。&lt;/p&gt;
&lt;p&gt;如果返回值是一些计算结果，那么当然不需要管这些东西。一般来说，计算结果出错了就表示失败了。典型的例子就是返回一个指针：使用 NULL 或者 ERR_PTR 来表示错误。&lt;/p&gt;
&lt;h3 id=&quot;不要重新发明内核宏&quot;&gt;17 不要重新发明内核宏&lt;/h3&gt;
&lt;p&gt;include/linux/kernel.h 头文件里定义了一些你可以使用的宏，你应该直接使用他们，而不是重新再定义一些新的宏。例如，如果你需要计算数组长度，使用提供的宏：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同样地，如果你需要计算结构体中某个成员的大小，使用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#define FIELD_SIZEOF(t, f) (sizeof(((t*)0)-&amp;gt;f))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果需要，里面还有做类型检查的 min() 和 max() 宏。仔细看看头文件中还定义了那些东西，如果里面有了，你就不要在自己的代码中重新定义了。&lt;/p&gt;
&lt;h3 id=&quot;多此一举的编辑器&quot;&gt;18 多此一举的编辑器&lt;/h3&gt;
&lt;p&gt;有些编辑器可以识别源文件中的配置信息，例如 emacs 可以识别这样的标记：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;-*- mode: c -*-&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者这样的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/*
Local Variables:
compile-command: &quot;gcc -DMAGIC_DEBUG_FLAG foo.c&quot;
End:
*/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Vim 可以识别：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/* vim:set sw=8 noet */&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不要在源代码中包含任何类似的内容。每个人都有自己的编辑器配置，你的源文件不应该影响他们。&lt;/p&gt;
&lt;h3 id=&quot;内联汇编&quot;&gt;19 内联汇编&lt;/h3&gt;
&lt;p&gt;在写一些与体系结构有关的代码中，你可能需要使用一些内联汇编调用CPU相关的接口或者和平台有关的功能，如果有这种需求，你大可使用汇编。但是如果C语言可以干的事，不要使用汇编。你应该尽可能地使用C语言来控制硬件。&lt;/p&gt;
&lt;p&gt;尽可能写一些辅助函数来实现相同的功能，而不是重复地写一些相同的代码，同时记住，内联汇编也可以使用C函数的参数。&lt;/p&gt;
&lt;p&gt;大的、重要的汇编函数应该独自写在一个 .S 文件中，并且编写对应的C头文件和函数原型，相应的函数原型应该添加 asmlinkage 关键字。&lt;/p&gt;
&lt;p&gt;你也许需要标记某些汇编代码为 volatile，避免 gcc 误把一些汇编移除掉。一般情况下，你不需要这样干，没必要的标记会影响优化。&lt;/p&gt;
&lt;p&gt;当一条汇编语句里包含多个指令时，每个指令分行写，并且除了最后一行外，在其他行的行末添加 \n\t 进行缩进和对齐：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;asm (&quot;magic %reg1, #42\n\t&quot;
     &quot;more_magic %reg2, %reg3&quot;
     : /* outputs */ : /* inputs */ : /* clobbers */);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;条件编译&quot;&gt;20 条件编译&lt;/h3&gt;
&lt;p&gt;无论在哪，不要在 .c 文件中使用条件编译命令(#if, #ifdef)，这样干会导致代码可读性降低并且代码逻辑混乱。取而代之，应该在 .c 文件对应的头文件中使用这些条件编译，并且在每个 #else  分支注明对应的版本信息。&lt;/p&gt;
&lt;p&gt;把同一个版本的所有函数都写在一个 #ifdef 中，不要在其中写一部分，而又在外部写一部分。&lt;/p&gt;
&lt;p&gt;在 #endif 之后写上一个注释，注明这个 #ifdef 块对应的内容：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#ifdef CONFIG_SOMETHING
...
#endif /* CONFIG_SOMETHING */&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;references&quot;&gt;References&lt;/h3&gt;
&lt;p&gt;The C Programming Language, Second Edition by Brian W. Kernighan and Dennis M. Ritchie. Prentice Hall, Inc., 1988. ISBN 0-13-110362-8 (paperback), 0-13-110370-9 (hardback).&lt;br/&gt;The Practice of Programming by Brian W. Kernighan and Rob Pike. Addison-Wesley, Inc., 1999. ISBN 0-201-61586-X.&lt;br/&gt;GNU manuals - where in compliance with K&amp;amp;R and this text - for cpp, gcc, gcc internals and indent, all available from http://www.gnu.org/manual/&lt;br/&gt;WG14 is the international standardization working group for the programming language C, URL: http://www.open-std.org/JTC1/SC22/WG14/&lt;br/&gt;Kernel process/coding-style.rst, by greg@kroah.com at OLS 2002: http://www.kroah.com/linux/talks/ols_2002_kernel_codingstyle_talk/html/&lt;/p&gt;
</description>
<pubDate>Sun, 10 Feb 2019 13:57:00 +0000</pubDate>
<dc:creator>trav</dc:creator>
<og:description>source: https://www.kernel.org/doc/html/latest/process/coding style.html translated by trav, travmym</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/trav/p/10356415.html</dc:identifier>
</item>
<item>
<title>.NET Core开发日志——OData - Ken.W</title>
<link>http://www.cnblogs.com/kenwoo/p/10360260.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kenwoo/p/10360260.html</guid>
<description>&lt;p&gt;OData，即Open Data Protocol，是由微软在2007年推出的一款开放协议，旨在通过简单、标准的方式创建和使用查询式及交互式RESTful API。&lt;/p&gt;

&lt;p&gt;在.NET Core中想要使用OData功能的话需要添加&lt;code&gt;Microsoft.AspNetCore.OData&lt;/code&gt;包。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;dotnet add package Microsoft.AspNetCore.OData&lt;/code&gt;
&lt;/pre&gt;

&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;public class Address
{
    public string City { get; set; }
    public string Street { get; set; }
}
public enum Category
{
    Book,
    Magazine,
    EBook
}
public class Press
{
    public int Id { get; set; }
    public string Name { get; set; }
    public string Email { get; set; }
    public Category Category { get; set; }
}
public class Book
{
    public int Id { get; set; }
    public string ISBN { get; set; }
    public string Title { get; set; }
    public string Author { get; set; }
    public decimal Price { get; set; }
    public Address Address { get; set; }
    public Press Press { get; set; }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;OData使用EDM，即Entity Data Model来描述数据的结构。在Startup文件中添加创建方法。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;private static IEdmModel GetEdmModel()
{
    var builder = new ODataConventionModelBuilder();
    builder.EntitySet&amp;lt;Book&amp;gt;(&quot;Books&quot;);
    builder.EntitySet&amp;lt;Press&amp;gt;(&quot;Presses&quot;);
    return builder.GetEdmModel();
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;在Startup文件的ConfigureServices方法里注册OData服务。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;services.AddOData();
services.AddMvc(options =&amp;gt;
    {
        options.EnableEndpointRouting = false;
    }).SetCompatibilityVersion(CompatibilityVersion.Version_2_2);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里要注意的是在.NET Core 2.2里，默认已经有终结点，所以要使用OData的终结点的话需要将默认选项禁用掉。&lt;/p&gt;

&lt;p&gt;同样在Startup文件里，在其Configure方法内将原来的注册路由内容改为注册OData的终结点。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;app.UseMvc(b =&amp;gt;
{
    b.MapODataServiceRoute(&quot;odata&quot;, &quot;odata&quot;, GetEdmModel());
});&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;运行程序后访问&lt;code&gt;https://localhost:5001/odata/$metadata&lt;/code&gt;地址，可以看到所有可用模型的元数据。&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;edmx:Edmx xmlns:edmx=&quot;http://docs.oasis-open.org/odata/ns/edmx&quot; Version=&quot;4.0&quot;&amp;gt;
    &amp;lt;edmx:DataServices&amp;gt;
        &amp;lt;Schema xmlns=&quot;http://docs.oasis-open.org/odata/ns/edm&quot; Namespace=&quot;Default&quot;&amp;gt;
            &amp;lt;EntityType Name=&quot;Book&quot;&amp;gt;
                &amp;lt;Key&amp;gt;
                    &amp;lt;PropertyRef Name=&quot;Id&quot;/&amp;gt;
                &amp;lt;/Key&amp;gt;
                &amp;lt;Property Name=&quot;Id&quot; Type=&quot;Edm.Int32&quot; Nullable=&quot;false&quot;/&amp;gt;
                &amp;lt;Property Name=&quot;ISBN&quot; Type=&quot;Edm.String&quot;/&amp;gt;
                &amp;lt;Property Name=&quot;Title&quot; Type=&quot;Edm.String&quot;/&amp;gt;
                &amp;lt;Property Name=&quot;Author&quot; Type=&quot;Edm.String&quot;/&amp;gt;
                &amp;lt;Property Name=&quot;Price&quot; Type=&quot;Edm.Decimal&quot; Nullable=&quot;false&quot;/&amp;gt;
                &amp;lt;Property Name=&quot;Address&quot; Type=&quot;Default.Address&quot;/&amp;gt;
                &amp;lt;NavigationProperty Name=&quot;Press&quot; Type=&quot;Default.Press&quot;/&amp;gt;
            &amp;lt;/EntityType&amp;gt;
            &amp;lt;EntityType Name=&quot;Press&quot;&amp;gt;
                &amp;lt;Key&amp;gt;
                    &amp;lt;PropertyRef Name=&quot;Id&quot;/&amp;gt;
                &amp;lt;/Key&amp;gt;
                &amp;lt;Property Name=&quot;Id&quot; Type=&quot;Edm.Int32&quot; Nullable=&quot;false&quot;/&amp;gt;
                &amp;lt;Property Name=&quot;Name&quot; Type=&quot;Edm.String&quot;/&amp;gt;
                &amp;lt;Property Name=&quot;Email&quot; Type=&quot;Edm.String&quot;/&amp;gt;
                &amp;lt;Property Name=&quot;Category&quot; Type=&quot;Default.Category&quot; Nullable=&quot;false&quot;/&amp;gt;
            &amp;lt;/EntityType&amp;gt;
            &amp;lt;ComplexType Name=&quot;Address&quot;&amp;gt;
                &amp;lt;Property Name=&quot;City&quot; Type=&quot;Edm.String&quot;/&amp;gt;
                &amp;lt;Property Name=&quot;Street&quot; Type=&quot;Edm.String&quot;/&amp;gt;
            &amp;lt;/ComplexType&amp;gt;
            &amp;lt;EnumType Name=&quot;Category&quot;&amp;gt;
                &amp;lt;Member Name=&quot;Book&quot; Value=&quot;0&quot;/&amp;gt;
                &amp;lt;Member Name=&quot;Magazine&quot; Value=&quot;1&quot;/&amp;gt;
                &amp;lt;Member Name=&quot;EBook&quot; Value=&quot;2&quot;/&amp;gt;
            &amp;lt;/EnumType&amp;gt;
            &amp;lt;EntityContainer Name=&quot;Container&quot;&amp;gt;
                &amp;lt;EntitySet Name=&quot;Books&quot; EntityType=&quot;Default.Book&quot;&amp;gt;
                    &amp;lt;NavigationPropertyBinding Path=&quot;Press&quot; Target=&quot;Presses&quot;/&amp;gt;
                &amp;lt;/EntitySet&amp;gt;
                &amp;lt;EntitySet Name=&quot;Presses&quot; EntityType=&quot;Default.Press&quot;/&amp;gt;
            &amp;lt;/EntityContainer&amp;gt;
        &amp;lt;/Schema&amp;gt;
    &amp;lt;/edmx:DataServices&amp;gt;
&amp;lt;/edmx:Edmx&amp;gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;本文实例中不考虑数据库的操作，故而使用hard code方式构建必要的模型对象。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class BooksController : ODataController
{
    private static IList&amp;lt;Book&amp;gt; Books {get; set;}
    public BooksController()
    {
        Books = new List&amp;lt;Book&amp;gt;
        {
            new Book
            {
                Id = 1,
                ISBN = &quot;111-0-321-56789-1&quot;,
                Title = &quot;Calculus&quot;,
                Price = 66.6m,
                Address = new Address
                {
                    City = &quot;Shanghai&quot;,
                    Street = &quot;Beijin Xi Road&quot;
                },
                Press = new Press
                {
                    Id = 1,
                    Name = &quot;Shanghai Tongji&quot;,
                    Category = Category.Book
                }
            },
            new Book
            {
                Id = 2,
                ISBN = &quot;222-2-654-00000-2&quot;,
                Title = &quot;Linear Algebra&quot;,
                Price = 53.2m,
                Address = new Address
                {
                    City = &quot;Shanghai&quot;,
                    Street = &quot;Beijin Dong Road&quot;
                },
                Press = new Press
                {
                    Id = 2,
                    Name = &quot;Shanghai Fudan&quot;,
                    Category = Category.EBook
                }
            }            
        };   
    }

    [EnableQuery]
    public IActionResult Get()
    {
        return Ok(Books);
    }

    [EnableQuery]
    public IActionResult Get(int key)
    {
        return Ok(Books.FirstOrDefault(b =&amp;gt; b.Id == key));
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;EnableQuery特性在需要高级查询的场景时必须添加。&lt;/p&gt;

&lt;p&gt;加入Controller之后，访问&lt;code&gt;https://localhost:5001/odata/Books&lt;/code&gt;地址，可得到所有Book数据。&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
    &quot;@odata.context&quot;: &quot;https://localhost:5001/odata/$metadata#Books&quot;,
    &quot;value&quot;: [
        {
            &quot;Id&quot;: 1,
            &quot;ISBN&quot;: &quot;111-0-321-56789-1&quot;,
            &quot;Title&quot;: &quot;Calculus&quot;,
            &quot;Author&quot;: null,
            &quot;Price&quot;: 66.6,
            &quot;Address&quot;: {
                &quot;City&quot;: &quot;Shanghai&quot;,
                &quot;Street&quot;: &quot;Beijin Xi Road&quot;
            }
        },
        {
            &quot;Id&quot;: 2,
            &quot;ISBN&quot;: &quot;222-2-654-00000-2&quot;,
            &quot;Title&quot;: &quot;Linear Algebra&quot;,
            &quot;Author&quot;: null,
            &quot;Price&quot;: 53.2,
            &quot;Address&quot;: {
                &quot;City&quot;: &quot;Shanghai&quot;,
                &quot;Street&quot;: &quot;Beijin Dong Road&quot;
            }
        }
    ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;访问&lt;code&gt;https://localhost:5001/odata/Books(1)&lt;/code&gt;地址，可得到key值为1的Book数据。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;{
    &quot;@odata.context&quot;: &quot;https://localhost:5001/odata/$metadata#Books/$entity&quot;,
    &quot;Id&quot;: 1,
    &quot;ISBN&quot;: &quot;111-0-321-56789-1&quot;,
    &quot;Title&quot;: &quot;Calculus&quot;,
    &quot;Author&quot;: null,
    &quot;Price&quot;: 66.6,
    &quot;Address&quot;: {
        &quot;City&quot;: &quot;Shanghai&quot;,
        &quot;Street&quot;: &quot;Beijin Xi Road&quot;
    }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;如果想要使用OData查询的高级功能，可以在注册终结点时额外加上相应的配置。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;app.UseMvc(b =&amp;gt;
{
    b.Select().Expand().Filter().OrderBy().MaxTop(100).Count();
    b.MapODataServiceRoute(&quot;odata&quot;, &quot;odata&quot;, GetEdmModel());
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;访问网址时加上所需的查询内容：&lt;br/&gt;&lt;code&gt;https://localhost:5001/odata/Books?$select=Id,Title&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
    &quot;@odata.context&quot;: &quot;https://localhost:5001/odata/$metadata#Books(Id,Title)&quot;,
    &quot;value&quot;: [
        {
            &quot;Id&quot;: 1,
            &quot;Title&quot;: &quot;Calculus&quot;
        },
        {
            &quot;Id&quot;: 2,
            &quot;Title&quot;: &quot;Linear Algebra&quot;
        }
    ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果想要按特定条件过滤数据内容的话也很容易：&lt;br/&gt;&lt;code&gt;https://localhost:5001/odata/Books?$filter=Price%20le%2060&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
    &quot;@odata.context&quot;: &quot;https://localhost:5001/odata/$metadata#Books&quot;,
    &quot;value&quot;: [
        {
            &quot;Id&quot;: 2,
            &quot;ISBN&quot;: &quot;222-2-654-00000-2&quot;,
            &quot;Title&quot;: &quot;Linear Algebra&quot;,
            &quot;Author&quot;: null,
            &quot;Price&quot;: 53.2,
            &quot;Address&quot;: {
                &quot;City&quot;: &quot;Shanghai&quot;,
                &quot;Street&quot;: &quot;Beijin Dong Road&quot;
            }
        }
    ]
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;不难看出，OData的真正魅力在于其对那些高级查询功能的支持，所以在创建RESTful API时，不妨考虑使用OData，这样应该能减少许多不必要的代码工作。&lt;/p&gt;
</description>
<pubDate>Sun, 10 Feb 2019 13:55:00 +0000</pubDate>
<dc:creator>Ken.W</dc:creator>
<og:description>简述 OData，即Open Data Protocol，是由微软在2007年推出的一款开放协议，旨在通过简单、标准的方式创建和使用查询式及交互式RESTful API。 类库 在.NET Core中</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kenwoo/p/10360260.html</dc:identifier>
</item>
<item>
<title>上周热点回顾（2.4-2.10） - 博客园团队</title>
<link>http://www.cnblogs.com/cmt/p/10360354.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cmt/p/10360354.html</guid>
<description>[unable to retrieve full-text content]热点随笔： · .NET和Java之争（叶伟民）· 虽然不抱希望但也愿.Net和Java之争暂得平息（hiroshi_cnblogs）· 《.NET和Java之争》一点随想（Lemon丶）· 《.NET和Java之争》 读后感（虫师）· 基于.NetCore的Redis5.0.3（最新版）快速入门、</description>
<pubDate>Sun, 10 Feb 2019 13:45:00 +0000</pubDate>
<dc:creator>博客园团队</dc:creator>
<og:description>热点随笔： · .NET和Java之争（叶伟民）· 虽然不抱希望但也愿.Net和Java之争暂得平息（hiroshi_cnblogs）· 《</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cmt/p/10360354.html</dc:identifier>
</item>
<item>
<title>[总结] 动态DP学习笔记 - YoungNeal</title>
<link>http://www.cnblogs.com/YoungNeal/p/10360291.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/YoungNeal/p/10360291.html</guid>
<description>&lt;p&gt;学习了一下动态DP&lt;/p&gt;
&lt;p&gt;问题的来源：&lt;br/&gt;给定一棵 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 个节点的树，点有点权，有 &lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt; 次修改单点点权的操作，回答每次操作之后的最大带权独立集大小。&lt;/p&gt;
&lt;p&gt;首先一个显然的 &lt;span class=&quot;math inline&quot;&gt;\(O(nm)\)&lt;/span&gt; 的做法就是每次做一遍树形DP（这也是我在noip考场上唯一拿到的部分分），直接考虑如何优化这个东西。&lt;/p&gt;
&lt;p&gt;简化一下问题，假如这棵树是一条链，那就变得很简单了，可以直接拿线段树维护矩阵加速。&lt;/p&gt;
&lt;p&gt;可是如果每个点不止有一个儿子呢？&lt;br/&gt;我们首先树剖一下。&lt;br/&gt;设 &lt;span class=&quot;math inline&quot;&gt;\(g[i][0]=\sum\limits_{j\in lightson} \max(f[j][0],f[j][1])\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(g[i][1]=a[i]+\sum\limits_{j\in lightson} f[j][0]\)&lt;/span&gt;&lt;br/&gt;即 &lt;span class=&quot;math inline&quot;&gt;\(g[i][0]\)&lt;/span&gt; 表示 &lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt; 的所有轻儿子的 &lt;span class=&quot;math inline&quot;&gt;\(\max(f[j][0],f[j][1])\)&lt;/span&gt; 之和，&lt;span class=&quot;math inline&quot;&gt;\(g[i][1]\)&lt;/span&gt; 表示 &lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt; 的所有轻儿子的 &lt;span class=&quot;math inline&quot;&gt;\(g[j][0]\)&lt;/span&gt; 之和与 &lt;span class=&quot;math inline&quot;&gt;\(a[i]\)&lt;/span&gt; 的和。&lt;/p&gt;
&lt;p&gt;那转移方程就可以改写为 &lt;span class=&quot;math inline&quot;&gt;\(f[i][0]=\max(g[i][0]+f[son[i]][0],g[i][0]+f[son[i]][1])\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(f[i][1]=g[i][1]+f[son[i]][0]\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这就可以放在线段树上维护矩阵了。&lt;br/&gt;即每个点维护一个 &lt;span class=&quot;math inline&quot;&gt;\(\quad\begin{matrix}g[i][0]&amp;amp;g[i][0]\\-\infty&amp;amp;g[i][1]\end{matrix}\)&lt;/span&gt;。然后在线段树上维护连乘积就好。&lt;/p&gt;
&lt;p&gt;还有一点就是修改的时候，要一直跳 &lt;span class=&quot;math inline&quot;&gt;\(top\)&lt;/span&gt;，可以这样理解：假设当前更改了点 &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt; 的点权，那么就会改变 &lt;span class=&quot;math inline&quot;&gt;\(f[top[x]]\)&lt;/span&gt; 的值，紧接着就会影响 &lt;span class=&quot;math inline&quot;&gt;\(g[fa[top[x]]]\)&lt;/span&gt; 的值，所以我们要一直向上跳 &lt;span class=&quot;math inline&quot;&gt;\(top\)&lt;/span&gt; 修改才能维护好。&lt;/p&gt;
&lt;p&gt;最后放一下代码:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#pragma GCC optimize(2)
#include&amp;lt;bits/stdc++.h&amp;gt;
using std::min;
using std::max;
using std::swap;
using std::vector;
typedef double db;
typedef long long ll;
#define pb(A) push_back(A)
#define pii std::pair&amp;lt;int,int&amp;gt;
#define all(A) A.begin(),A.end()
#define mp(A,B) std::make_pair(A,B)
const int N=1e5+5;
const int inf=1e9;
#define ls x&amp;lt;&amp;lt;1
#define rs x&amp;lt;&amp;lt;1|1
#define lss ls,l,mid,ql,qr
#define rss rs,mid+1,r,ql,qr

int tot,dfn[N],top[N],end[N];
int n,m,v[N],sze[N],son[N],f[N][2];
int cnt,head[N],g[N][2],fa[N],fs[N];

struct Edge{
    int to,nxt;
}edge[N&amp;lt;&amp;lt;1];

void add(int x,int y){
    edge[++cnt].to=y;
    edge[cnt].nxt=head[x];
    head[x]=cnt;
}

struct Mat{
    int a[3][3];
    Mat(){memset(a,0xcf,sizeof a);}
    friend Mat operator*(Mat x,Mat y){
        Mat z;
        for(int i=1;i&amp;lt;=2;i++)
            for(int k=1;k&amp;lt;=2;k++)
                for(int j=1;j&amp;lt;=2;j++)
                    z.a[i][j]=max(x.a[i][k]+y.a[k][j],z.a[i][j]);
        return z;
    }
}sum[N&amp;lt;&amp;lt;2],val[N];

int getint(){
    int X=0,w=0;char ch=getchar();
    while(!isdigit(ch))w|=ch=='-',ch=getchar();
    while( isdigit(ch))X=X*10+ch-48,ch=getchar();
    if(w) return -X;return X;
}

void dfs(int now){
    sze[now]=1;
    for(int i=head[now];i;i=edge[i].nxt){
        int to=edge[i].to;
        if(sze[to]) continue;
        fa[to]=now;dfs(to);
        sze[now]=sze[to];
        son[now]=sze[son[now]]&amp;gt;sze[to]?son[now]:to;
    }
}

void dfs(int now,int low){
    dfn[now]=++tot;top[now]=low;fs[tot]=now;
    if(son[now]) dfs(son[now],low);
    for(int i=head[now];i;i=edge[i].nxt){
        int to=edge[i].to;
        if(dfn[to]) continue;
        dfs(to,to);
        g[now][0]+=max(f[to][0],f[to][1]);
        g[now][1]+=f[to][0];
    } if(son[now]) end[now]=end[son[now]];
    else end[now]=now;
    g[now][1]+=v[now];
    f[now][0]=g[now][0]+max(f[son[now]][0],f[son[now]][1]);
    f[now][1]=g[now][1]+f[son[now]][0];
}

void pushup(int x){
    sum[x]=sum[ls]*sum[rs];
}

void build(int x,int l,int r){
    if(l==r) return sum[x]=val[fs[l]],void();
    int mid=l+r&amp;gt;&amp;gt;1; build(ls,l,mid),build(rs,mid+1,r);
    pushup(x);
}

void init(){
    for(int i=1;i&amp;lt;=n;i++)
        val[i].a[1][1]=val[i].a[1][2]=g[i][0],val[i].a[2][1]=g[i][1],val[i].a[2][2]=-inf;
    build(1,1,n);
}

Mat query(int x,int l,int r,int ql,int qr){
    if(ql&amp;lt;=l and r&amp;lt;=qr) return sum[x];
    int mid=l+r&amp;gt;&amp;gt;1;
    if(qr&amp;lt;=mid) return query(lss);
    if(ql&amp;gt;mid) return query(rss);
    return query(lss)*query(rss);
}

Mat ask(int x){
    return query(1,1,n,dfn[top[x]],dfn[end[x]]);
}

void modify(int x,int l,int r,int ql,int qr){
    if(l==r) return sum[x]=val[fs[l]],void();
    int mid=l+r&amp;gt;&amp;gt;1;
    ql&amp;lt;=mid?modify(lss):modify(rss);
    pushup(x);
}

void change(int x,int y){
    val[x].a[2][1]+=y-v[x]; v[x]=y;
    Mat pre,nxt;
    while(x){
        pre=ask(x);
        modify(1,1,n,dfn[x],dfn[x]);
        nxt=ask(x);
        x=fa[top[x]];
        val[x].a[1][1]+=max(nxt.a[1][1],nxt.a[2][1])-max(pre.a[1][1],pre.a[2][1]);
        val[x].a[1][2]=val[x].a[1][1];
        val[x].a[2][1]+=nxt.a[1][1]-pre.a[1][1];
    }
}

signed main(){
    n=getint(),m=getint();
    for(int i=1;i&amp;lt;=n;i++) v[i]=getint();
    for(int i=1;i&amp;lt;n;i++){
        int x=getint(),y=getint();
        add(x,y),add(y,x);
    } dfs(1),dfs(1,1),init();
    while(m--){
        int x=getint(),y=getint();
        change(x,y);
        Mat ans=ask(1);
        printf(&quot;%d\n&quot;,max(ans.a[1][1],ans.a[2][1]));
    } return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后两道例题：&lt;/p&gt;
&lt;h2 id=&quot;bzoj4712-洪水&quot;&gt;BZOJ4712 洪水&lt;/h2&gt;
&lt;h3 id=&quot;题意&quot;&gt;题意&lt;/h3&gt;
&lt;p&gt;给出一棵树，点有点权。多次增加某个点的点权，并在某一棵子树中询问：选出若干个节点，使得每个叶子节点到根节点的路径上至少有一个节点被选择，求选出的点的点权和的最小值。&lt;/p&gt;
&lt;h3 id=&quot;sol&quot;&gt;Sol&lt;/h3&gt;
&lt;p&gt;还是动态DP。&lt;/p&gt;
&lt;p&gt;先把DP式子列出来： &lt;span class=&quot;math inline&quot;&gt;\(f[i]=\min(a[i],\sum\limits_{j\in son[i]} f[j])\)&lt;/span&gt;，然后套路设 &lt;span class=&quot;math inline&quot;&gt;\(g[i]=\sum\limits_{j\in lightson[i]} f[j]\)&lt;/span&gt;，于是 &lt;span class=&quot;math inline&quot;&gt;\(f[i]=\min(a[i],g[i]+f[son[i]])\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;又可以写成矩阵相乘的形式：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{matrix}f[son[i]]\\0\end{matrix}\times \begin{matrix}g[i]&amp;amp;a[i]\\\infty&amp;amp;0\end{matrix}=\begin{matrix}f[i]\\0\end{matrix} \]&lt;/span&gt;&lt;br/&gt;然后动态DP就行了。&lt;/p&gt;
&lt;p&gt;需要注意一点的是在 &lt;span class=&quot;math inline&quot;&gt;\(change\)&lt;/span&gt; 函数里，&lt;span class=&quot;math inline&quot;&gt;\(pre,nxt\)&lt;/span&gt; 的矩阵应该是 &lt;span class=&quot;math inline&quot;&gt;\(ask(top[x])\)&lt;/span&gt; 而不是 &lt;span class=&quot;math inline&quot;&gt;\(ask(x)\)&lt;/span&gt;。&lt;/p&gt;
&lt;h2 id=&quot;noip2018-保卫王国&quot;&gt;NOIP2018 保卫王国&lt;/h2&gt;
&lt;h3 id=&quot;题意-1&quot;&gt;题意&lt;/h3&gt;
&lt;p&gt;给出一棵树，点有点权。每次强制选或不选两个节点，求最小权覆盖集。&lt;/p&gt;
&lt;h3 id=&quot;sol-1&quot;&gt;Sol&lt;/h3&gt;
&lt;p&gt;首先有个定理：最小权覆盖集=全集-最大权独立集。然后就是luogu模板题了。&lt;/p&gt;
</description>
<pubDate>Sun, 10 Feb 2019 13:20:00 +0000</pubDate>
<dc:creator>YoungNeal</dc:creator>
<og:description>动态DP。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/YoungNeal/p/10360291.html</dc:identifier>
</item>
<item>
<title>[线性DP][codeforces-1110D.Jongmah]一道花里胡哨的DP题 - fanwenlin</title>
<link>http://www.cnblogs.com/fanwl/p/10360286.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fanwl/p/10360286.html</guid>
<description>&lt;p&gt;题目来源: &lt;a href=&quot;https://codeforces.com/contest/1110/problem/D&quot;&gt;Codeforces - 1110D&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;题意：你有n张牌（1，2，3，...，m）你要尽可能多的打出[x,x+1,x+2] 或者[x,x,x]的牌型，问最多能打出多少种牌&lt;/p&gt;
&lt;p&gt;思路：&lt;/p&gt;
&lt;p&gt;1.三组[x,x+1,x+2]的效果等同于 [x,x,x],[x+1,x+1,x+1],[x+2,x+2,x+2]，所以每种顺子牌型最多打2次（如果多于2次，可以被少于3次的方案替代掉，因此忽略）&lt;/p&gt;
&lt;p&gt;2.对于每一种牌，用途只有四种。[i-2,i-1,i], [i-1,i,i+1], [i,i+1,i+2], [i,i,i]&lt;/p&gt;
&lt;p&gt;　我们可以枚举每张牌在四种用途里分别投入了多少&lt;/p&gt;
&lt;p&gt;　由简单的容斥原理，我们只需要枚举三种顺子牌型分别有x,y,z组，那么[i,i,i]就有(c[i]-x-y-z)/3组&lt;/p&gt;
&lt;p&gt;　于是我们就有了线性dp的思路&lt;/p&gt;
&lt;p&gt;　如果建立dp[maxn][3][3][3]，dp[i][x][y][z]表示在第i阶段，第i张牌用来组成三种牌型分别有x,y,z组的最优结果，有dp[i][x][y][z] = max{dp[i-1][?][x][y]} + z + (c[i] - x - y - z) / 3, ans = max{dp[n][?][0][0])&lt;/p&gt;
&lt;p&gt;　AC代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; #include &amp;lt;bits/stdc++.h&amp;gt;
&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; maxn = 1e6 + &lt;span&gt;5&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; c[maxn];
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; dp[maxn][&lt;span&gt;3&lt;/span&gt;][&lt;span&gt;3&lt;/span&gt;][&lt;span&gt;3&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; main(){
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;freopen(&quot;data.in&quot;,&quot;r&quot;,stdin);&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     ios::sync_with_stdio(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     cin.tie(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; cc,t;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     cin &amp;gt;&amp;gt; cc &amp;gt;&amp;gt;&lt;span&gt; n;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt;= cc; i++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         cin &amp;gt;&amp;gt;&lt;span&gt; t;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         c[t]++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt;= n; i++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; x = &lt;span&gt;0&lt;/span&gt;; x &amp;lt; &lt;span&gt;3&lt;/span&gt;; x++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; y = &lt;span&gt;0&lt;/span&gt;; y &amp;lt; &lt;span&gt;3&lt;/span&gt;; y++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; z = &lt;span&gt;0&lt;/span&gt;; z &amp;lt; &lt;span&gt;3&lt;/span&gt;; z++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt;(x + y + z &amp;gt; c[i])&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; t = &lt;span&gt;0&lt;/span&gt;; t &amp;lt; &lt;span&gt;3&lt;/span&gt;; t++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                         dp[i][x][y][z] = max(dp[i][x][y][z], dp[i-&lt;span&gt;1&lt;/span&gt;][t][x][y] + z + (c[i]-x-y-z)/&lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; ans;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; t = &lt;span&gt;0&lt;/span&gt;; t &amp;lt; &lt;span&gt;3&lt;/span&gt;; t++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         ans = max(ans, dp[n][t][&lt;span&gt;0&lt;/span&gt;][&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;     cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt;&lt;span&gt; endl;
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.仔细观察上面的代码，我们发现在状态转移过程中，两个方程中都有[x][y]，状态之间的联系太过紧密，可以尝试优化一下&lt;/p&gt;
&lt;p&gt;　如果建立dp[maxn][3][3]，少了一个维度，dp[i][x][y] 表示有x组[i-1,i,i+1],y组[i,i+1,i+2]时的最优结果，有dp[i][x][y] = max{dp[i-1][?][x] + y + (c[i] - ? - x - y)/3}&lt;/p&gt;
&lt;p&gt;　AC代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; #include &amp;lt;bits/stdc++.h&amp;gt;
&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; maxn = 1e6 + &lt;span&gt;5&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; c[maxn];
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; dp[maxn][&lt;span&gt;3&lt;/span&gt;][&lt;span&gt;3&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; main(){
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;freopen(&quot;data.in&quot;,&quot;r&quot;,stdin);&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     ios::sync_with_stdio(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     cin.tie(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; cc,t;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     cin &amp;gt;&amp;gt; cc &amp;gt;&amp;gt;&lt;span&gt; n;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt;= cc; i++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         cin &amp;gt;&amp;gt;&lt;span&gt; t;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         c[t]++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt;= n; i++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; x = &lt;span&gt;0&lt;/span&gt;; x &amp;lt; &lt;span&gt;3&lt;/span&gt;; x++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; y = &lt;span&gt;0&lt;/span&gt;; y &amp;lt; &lt;span&gt;3&lt;/span&gt;; y++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; z = &lt;span&gt;0&lt;/span&gt;; z &amp;lt; &lt;span&gt;3&lt;/span&gt;; z++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt;(x + y + z &amp;gt; c[i])&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                     dp[i][y][z] = max(dp[i][y][z], dp[i-&lt;span&gt;1&lt;/span&gt;][x][y] + z + (c[i]-x-y-z)/&lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; ans = dp[n][&lt;span&gt;0&lt;/span&gt;][&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt;&lt;span&gt; endl;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4.由于每一阶段的决策只与上一阶段有关，可以使用滚动数组进行进一步优化。&lt;/p&gt;
</description>
<pubDate>Sun, 10 Feb 2019 13:18:00 +0000</pubDate>
<dc:creator>fanwenlin</dc:creator>
<og:description>题目来源: Codeforces - 1110D 题意：你有n张牌（1，2，3，...，m）你要尽可能多的打出[x,x+1,x+2] 或者[x,x,x]的牌型，问最多能打出多少种牌 思路： 1.三组[</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fanwl/p/10360286.html</dc:identifier>
</item>
<item>
<title>前端交互体验核心之事件（一） - 他乡踏雪</title>
<link>http://www.cnblogs.com/ZheOneAndOnly/p/10355472.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ZheOneAndOnly/p/10355472.html</guid>
<description>&lt;ul&gt;&lt;li&gt;如何绑定事件处理函数&lt;/li&gt;
&lt;li&gt;事件处理程序的运行环境&lt;/li&gt;
&lt;li&gt;解除事件处理程序&lt;/li&gt;
&lt;li&gt;事件处理模型————冒泡、捕获&lt;/li&gt;
&lt;li&gt;默认事件&lt;/li&gt;
&lt;li&gt;事件对象&lt;/li&gt;
&lt;li&gt;事件委托&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;如何绑定、解除事件处理函数&lt;/h2&gt;
&lt;h4&gt;&lt;span&gt;一、绑定事件处理函数&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt; 1.ele.on xxx = function(event){}&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;兼容性好，但是一个元素的同一个事件只能绑定一个处理函数&lt;/li&gt;
&lt;li&gt;基本等同于写在HTML行间&lt;/li&gt;
&lt;li&gt;行间句柄绑定示例：&amp;lt;div style=&quot;width:100px;height:100px;background-color:red;&quot; onclick=&quot;console.log('谁点我了？')&quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;2.dom.addEventListener(‘事件类型‘，处理函数，false)；&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;IE9以下不兼容，可以为一个事件绑定多个处理程序（W3C标准）&lt;/li&gt;
&lt;li&gt;绑定同一个处理函数多次，不能执行多次&lt;/li&gt;
&lt;li&gt;第三个参数指定事件是否在捕获或冒泡阶段执行&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;3.dom.attachEvent('on'+ 事件类型 ， 处理函数)；&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;IE独有，一个事件同样可以绑定多个处理程序&lt;/li&gt;
&lt;li&gt;绑定同一个处理函数多次，可以执行多次&lt;/li&gt;
&lt;li&gt;示例：dom.attachEvent('onClick',function(){});&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;&lt;span&gt;二、事件处理程序的运行环境&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt; 1.ele.onxxx = function(event){}                  ==&amp;gt; 程序this指向是DOM元素本身。&lt;/p&gt;
&lt;p&gt; 2.dom.addEventListener(type,fun,false);  ==&amp;gt; 程序this指向是DOM元素本身。&lt;/p&gt;
&lt;p&gt; 3.dom.attachEvent('on' + Type ,fun);        ==&amp;gt;程序this指向是window。&lt;/p&gt;
&lt;p&gt;了解this指向规则可以访问我的另一篇博客：&lt;a href=&quot;https://www.cnblogs.com/ZheOneAndOnly/p/10226506.html&quot;&gt;JavaScript中的this指向规则&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 封装兼容性的事件绑定函数addEvent(elem,type,handle)方法：（这个方法没有考虑事件模型设置，还可以改进）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现全兼容性的事件函数绑定方法&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;addEventListener是w3c标准方法，IE9以下不兼容&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;attachEvent是ie的独有方法，但是this指向window，通过call修正this指向dom本身&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;on...方式不能绑定一个方法&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; addEvent(elem,type,handle){
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(elem.addEventListener){
        elem.addEventListener(type,handle,&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);    
    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(elem.attachEvent){
        elem.attachEvent(&lt;/span&gt;'on' + type, &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
            handle.call(elem); 
        });
    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{&lt;br/&gt;　　　　 type = type.substring(0,1).toUpperCase()+type.substring(1);
        elem[&lt;/span&gt;'on' + type] =&lt;span&gt; handle;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;&lt;span&gt;三、解除事件处理程序&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt; 1.ele.on XXX = function(){}的事件解除和应用：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;理解：句柄绑定的事件程序，是一个变量（属性）赋值的方式。&lt;/li&gt;
&lt;li&gt;解决方案：将值清空即等于解除绑定程序。&lt;/li&gt;
&lt;li&gt;实现：ele.on XXX = false/&quot;&quot;/null&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt; 应用：典型应用功能是网页内的点击跳转链接小广告，点击一次后再点击就不会出现跳转。（案例模拟逻辑，没有具体实现）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;
&amp;lt;div style=&quot;width: 100px;height: 100px;background-color: red;&quot;&amp;gt;&amp;lt;/div&amp;gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt;js&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; advDIV = document.getElementsByTaName('div')[0&lt;span&gt;];
advDIV.onclick &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    console.log(a);
    advDIV.onclick &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.dom.addEventListener(‘事件类型‘，处理函数，false)的事件解除：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;解除方法：dom.removeEventListener(‘事件类型‘，处理函数，false)&lt;/li&gt;
&lt;li&gt;理解：与绑定的DOM对象要一致，事件、函数、要一一对应。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; 3.dom.attachEvent('on'+ 事件类型 ， 处理函数)的事件解除：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;解除方法：dom.detachEvent('on' + type, fn)&lt;/li&gt;
&lt;li&gt;理解：与removeEventListener方法一致&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;解除事件处理程序需要注意的问题&lt;/span&gt;&lt;/strong&gt;（addEventListener、attachEvent）：若绑定匿名函数，则无法解除。比如直接在绑定函数时直接在绑定方法上写入函数表达式，这种绑定是无法解除的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
advDIV.addEventListener('click',&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    console.log(&lt;/span&gt;&quot;a&quot;&lt;span&gt;);
},&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;事件处理模型（冒泡、捕获）&lt;/h2&gt;
&lt;h4&gt;&lt;span&gt;四、事件冒泡&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;定义：结构上（非视觉上）嵌套关系的元素，会存在事件冒泡功能，即同一事件，自子元素冒泡向父元素。（自底向上）&lt;/p&gt;
&lt;p&gt;解析：事件冒泡就是嵌套的元素，同一事件在子元素上触发后，从子元素到父元素及祖辈元素依照嵌套层级关系逐个触发执行。&lt;/p&gt;
&lt;p&gt;实现：在绑定事件程序时，第三个参数设置为false(默认)及设置dom的事件触发模型为事件冒泡。（例如：&lt;span&gt;addEventListener('click',&lt;span&gt;function&lt;span&gt;(){...&lt;span&gt;},&lt;span&gt;false&lt;span&gt;);）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;wrapper&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;p&gt;点击测试&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt; 实例测试的事件采用句柄绑定的弹窗(句柄绑定可以默认触发事件冒泡)，浏览器如果有设置禁止弹窗无法测试，最后附上代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;html(为了让代码更清晰，css代码大家自己填充)&lt;/span&gt;
&amp;lt;div class=&quot;wrapper&quot;&amp;gt;
    &amp;lt;div class=&quot;content&quot;&amp;gt;
        &amp;lt;div class=&quot;box&quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;js（重点在于理解事件冒泡，事件绑定没有兼容IE9以下的浏览器）&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; wrapper = document.getElementsByClassName(&quot;wrapper&quot;)[0&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; content = document.getElementsByClassName(&quot;content&quot;)[0&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; box = document.getElementsByClassName(&quot;box&quot;)[0&lt;span&gt;];

wrapper.addEventListener(&lt;/span&gt;'click',&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    console.log(&lt;/span&gt;&quot;wrapper&quot;&lt;span&gt;);
 },&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
content.addEventListener(&lt;/span&gt;'click',&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    &lt;span&gt;console.log&lt;/span&gt;(&lt;/span&gt;&quot;console&quot;&lt;span&gt;);
 },&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
box.addEventListener(&lt;/span&gt;'click',&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    &lt;span&gt;console.log&lt;/span&gt;(&lt;/span&gt;&quot;box&quot;&lt;span&gt;);
 },&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;&lt;span&gt;五、事件捕获&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;定义：结构上（非视觉上）嵌套关系的元素，会存在事件捕获功能，即同一事件，自父元素捕获至子元素。（自上向下）&lt;/p&gt;
&lt;p&gt;解析：事件捕获就是嵌套的元素，同一事件在子元素上触发时，从顶层祖辈元素到父元素再到自身逐个被触发执行。&lt;/p&gt;
&lt;p&gt;实现：在绑定事件程序时，第三个参数设置为true及设置dom的事件触发模型为事件冒泡。（例如：&lt;span&gt;addEventListener('click',&lt;span&gt;function&lt;span&gt;(){...&lt;span&gt;},&lt;span&gt;true&lt;span&gt;);）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;由于句柄绑定事件程序不能设置事件模型，而句柄默认事件模型为事件冒泡，所以这里不能提供实例演示，下面代码提供参考：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
wrapper.addEventListener('click',&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    console.log(&lt;/span&gt;&quot;wrapper&quot;&lt;span&gt;);
 },&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
content.addEventListener(&lt;/span&gt;'click',&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    console.log(&lt;/span&gt;&quot;console&quot;&lt;span&gt;);
 },&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
box.addEventListener(&lt;/span&gt;'click',&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    console.log(&lt;/span&gt;&quot;box&quot;&lt;span&gt;);
 },&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;IE9以下的浏览器事件捕获没有事件捕获模型addEventListener( type, fun, true)只有IE9及以上浏览器兼容&lt;/li&gt;
&lt;li&gt;attachEvent('on' + type , fun)没有第三个控制事件模型的参数，实质上与句柄类似，默认事件模型为冒泡&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;&lt;span&gt;六、事件模型下事件程序的执行逻辑&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;触发顺序：先捕获，后冒泡&lt;/li&gt;
&lt;li&gt;捕获：从外层向内层执行&lt;/li&gt;
&lt;li&gt;冒泡：从内层向外层执行&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;后面两个逻辑其实就是时间模型的本身特性，这里的重点在第一个执行逻辑。其实前面有个设置事件模型的重要点没有讲，那就是同一个事件的同一个处理程序只能设置一种事件模型，但是同一个事件的不同处理程序可以设置不同的事件模型，所以就引出了先捕获后执行的事件处理逻辑。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
wrapper.addEventListener('click',&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    console.log(&lt;/span&gt;&quot;wrapper&quot;&lt;span&gt;);
},&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
content.addEventListener(&lt;/span&gt;'click',&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    console.log(&lt;/span&gt;&quot;console&quot;&lt;span&gt;);
},&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
box.addEventListener(&lt;/span&gt;'click',&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    console.log(&lt;/span&gt;&quot;box&quot;&lt;span&gt;);
},&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
wrapper.addEventListener(&lt;/span&gt;'click',&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    console.log(&lt;/span&gt;&quot;wrapperBubble&quot;&lt;span&gt;);
 },&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
content.addEventListener(&lt;/span&gt;'click',&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    console.log(&lt;/span&gt;&quot;consoleBubble&quot;&lt;span&gt;);
 },&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
box.addEventListener(&lt;/span&gt;'click',&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    console.log(&lt;/span&gt;&quot;boxBubble&quot;&lt;span&gt;);
 },&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行结果&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; wrapper&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; console&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; box&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; boxBubble&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; consoleBubble&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; wrapperBubble&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个先后更详细的来说应该是：先将事件的捕获模型的事件程序依次执行完再依次执行事件冒泡模型的事件程序。但是这里有一个很容易被忽略的问题，因为我这个示例代码是将捕获事件放到了前面，如果在后面呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
wrapper.addEventListener('click',&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    console.log(&lt;/span&gt;&quot;wrapperBubble&quot;&lt;span&gt;);
 },&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
content.addEventListener(&lt;/span&gt;'click',&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    console.log(&lt;/span&gt;&quot;consoleBubble&quot;&lt;span&gt;);
 },&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
box.addEventListener(&lt;/span&gt;'click',&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    console.log(&lt;/span&gt;&quot;boxBubble&quot;&lt;span&gt;);
 },&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);

wrapper.addEventListener(&lt;/span&gt;'click',&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    console.log(&lt;/span&gt;&quot;wrapper&quot;&lt;span&gt;);
},&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
content.addEventListener(&lt;/span&gt;'click',&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    console.log(&lt;/span&gt;&quot;console&quot;&lt;span&gt;);
},&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
box.addEventListener(&lt;/span&gt;'click',&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    console.log(&lt;/span&gt;&quot;box&quot;&lt;span&gt;);
},&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行结果&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; wrapper&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; console&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; boxBubble&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; box&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; consoleBubble&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; wrapperBubble&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这次有点惊喜了，box的执行逻辑发生了变化，但是我们暂时不考虑这个问题，从总体上来看开始遵循了先执行捕获模式的事件程序，然后执行冒泡模式的事件程序。那为什么box的执行循序会发生变化呢？&lt;/p&gt;
&lt;p&gt;这里需要注意的是，被事件模型被动触发的事件程序是按照先捕获后冒泡的原则，但是被主动触发事件的DOM执行的原则是事件执行（并非冒泡执行或捕获执行），所以会遵循先绑定先执行的原则。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注：focus,blur,change,submit,select等事件不冒泡。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;七、取消事件冒泡&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;在一些嵌套结构复杂的设计中，可能会出现不希望被子元素冒泡触发事件程序执行的情况，这时需要在子元素的事件程序中执行取消冒泡行为的方法（event.stopPropagation()），这个方法会&lt;span&gt;取消当前事件程序冒泡到父级元素&lt;/span&gt;。例如前面的冒泡事件坐下面修改：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
wrapper.addEventListener('click',&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    console.log(&lt;/span&gt;&quot;wrapperBubble&quot;&lt;span&gt;);
 },&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
content.addEventListener(&lt;/span&gt;'click',&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e){
    console.log(&lt;/span&gt;&quot;consoleBubble&quot;&lt;span&gt;);
    &lt;span&gt;e.stopPropagation();//取消&quot;content&quot;冒泡到&quot;wrapper&quot;&lt;/span&gt;
 },&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
box.addEventListener(&lt;/span&gt;'click',&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e){
    console.log(&lt;/span&gt;&quot;boxBubble&quot;&lt;span&gt;);
 },&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上示例中，当点击box会执行“boxBubble”,“contentBubble”。点击content时只触发自身事件程序。&lt;/p&gt;
&lt;p&gt;event.stopPropagation()是W3C的标准方法，但是任性IE（IE9以下）需要event.cancelBubble = true;属性来取消事件冒泡。所以需要我们实现一个兼容方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;封装取消冒泡的函数兼容方法stopBubble(event)&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; stopBubble(event){
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(event.stopPropagation){
        event.stopPropagation();
    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
        event.cancelBubble &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;默认事件与事件对象&lt;/h2&gt;
&lt;h4&gt;&lt;span&gt;八、默认事件及取消默认事件&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;常见的默认事件：表单事件，a标签跳转，右键菜单等。&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;取消默认事件的方法&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;return false;以对象属性的方式注册的事件才生效&lt;/li&gt;
&lt;li&gt;event.preventDefault();W3C标准方法，IE9以下不兼容&lt;/li&gt;
&lt;li&gt;event.returnValue = false;兼容IE（chrome也实现了）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; 例如：取消右键默认事件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
document.oncontextmenu = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(event){
    console.log(&lt;/span&gt;'a'&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;方法一： return false;&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;方法二： event.preventDefault(); (W3C标准)&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;方法三： event.returnValue = false;（兼容IE）&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;废话不多说，兼容方法走一波：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;封装阻止默认事件的函数cancelHandler(event);&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; cancelHandler(event){
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(event.preventDefault){
        event.preventDefault();
    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
        event.returnValue &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;关于取消a标签默认事件，引出的一系列思考？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在日常开发中，会经常将a标签作为按钮使用，我们知道a标签在没有设置连接的情况下，会默认有点击事件。当我们点击一个没有设置连接的a标签时会刷新页面，或者锚链接没有设置具体位置（连接内容只写了一个“#”）会跳转到页面最顶端。这时候我们就需要取消默认事件。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;没有设置连接的a标签，刷新页面&lt;/span&gt;
&amp;lt;a href=&quot;&quot;&amp;gt;dom&amp;lt;a&amp;gt; 

&lt;span&gt;//&lt;/span&gt;&lt;span&gt;没有具体锚定位置的a标签，回到页面顶端&lt;/span&gt;
&amp;lt;a href=&quot;#&quot;&amp;gt;dom&amp;lt;/a&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;取消a标签的默认事件&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; aDom = document.getElementsByTagName('a')[0&lt;span&gt;];
aDom.onclick &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e){
    console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
    cancelHandler(e);//使用了前面的兼容方法
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的示例演示了将a标签的点击事件修改成了自己的事件程序，并且阻止了a标签的默认事件触发。但是这是采用onclick的对象属性赋值的写法，如果有多个事件程序呢？是否每一次绑定事件程序都需要操作阻止指定呢？请看以下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;addEvent()是前面封装的绑定事件的兼容方法&lt;/span&gt;
addEvent(aDom,'click'&lt;span&gt;,aDomFn1);
addEvent(aDom,&lt;/span&gt;'click'&lt;span&gt;,aDomFn);

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; aDomFn(e){
    console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
    cancelHandler(e);
}
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; aDomFn1(e){
    console.log(&lt;/span&gt;&quot;我就不取消默认事件怎么滴&quot;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我特别将阻止默认事件的事件程序放到了后面绑定，但是当我点击a标签时，第一个事件程序运行完以后接着执行的是第二个事件程序，所以暂时得到的答案是，只要我们在对象的事件中任意事件程序设置一个阻止默认事件触发，就可以完全阻止这个对象的指定事件的默认事件的触发。（对于这个问题的底层实现还没做深入的研究，只能说是暂时的结论）&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;九、事件对象&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;获取事件对象&lt;/li&gt;
&lt;li&gt;获取事件源对象&lt;/li&gt;
&lt;li&gt;事件委托&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; 9.1.当浏览器引擎执行事件程序时，浏览器引擎会自动的向这个程序传入一个默认参数，这个参数就是事件对象，这个对象的属性记录了事件的各种属性，其中重要的有鼠标坐标点，事件模型状态、取消默认事件的属性和方法等，最重要的是还有一个事件源对象。（但是在IE9之前的浏览器这个事件对象不是作为参数传入的，而是被保存在window.event上）。所以兼容代码要来了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; fnEvent(e){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; event = e ||&lt;span&gt; window.event;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里是事件程序的具体代码&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;9.2.在事件冒泡和事件捕获中，我们知道了有些事件是被冒泡或者捕获执行的，在很多情况下我们需要在父级或者祖辈上执行事件程序，但又需要获取触发事件的DOM对象相关的数据，所以前面说事件对象上的事件源对象很重要。&lt;/p&gt;
&lt;p&gt;在事件对象上有target这个属性保存了触发事件的源对象DOM,IE（IE9以下）上的事件源对象属性是srcElement。在chrome上这两个属性都有。所以，封装兼容写法又得来一波：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;封装兼容性方法获取事件源对象&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; getTarget(e){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; event = e ||&lt;span&gt; window.event;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; target = event.target ||&lt;span&gt; event.srcElement;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; target;
} &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;9.3.初级前端必会的操作：事件委托&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;什么是事件委托？&lt;/li&gt;
&lt;li&gt;事件委托怎么实现？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; 假设我们有列表包含10个“li”，我们需要在点击每个“li”的的时候打印其文本内容，以我们通常的想法就是循环每个“li”添加click事件，且不说性能问题。如果li是动态添加呢？所以事件冒泡+事件源对象就可以展现它们的强大了。先看代码，直接回答第二个问题，第一个问题你自己机会有答案了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;
&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;1&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;2&amp;lt;/li&amp;gt;
...&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里省略100个li&lt;/span&gt;
&amp;lt;/ul&amp;gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt;js&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; ul = document.getElementsByTagName('ul')[0&lt;span&gt;];
ul.onclick &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (e) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; event = e || window.event;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取事件对象&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; target = event.target || event.srcElement;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取事件源&lt;/span&gt;
    console.log(target.innerText);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过事件源获取到点击的li的文本&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sun, 10 Feb 2019 12:47:00 +0000</pubDate>
<dc:creator>他乡踏雪</dc:creator>
<og:description>这篇博客适应于入门，当然js和DOM的事件应用本身就是入门级别的知识点，这篇博客只要介绍如何绑定事件、解除事件、事件处理模型、及一些浏览器兼容性问题。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ZheOneAndOnly/p/10355472.html</dc:identifier>
</item>
<item>
<title>Thread类详解 多线程中篇（二） - noteless</title>
<link>http://www.cnblogs.com/noteless/p/10354699.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/noteless/p/10354699.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;span&gt;Java.lang.Thread是Java应用程序员对Java多线程的第一站，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;Thread就是对Java线程本身的抽象&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;所以在Java中的线程编程概念中，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;一个Thread实例&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;一个线程&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;线程有哪些属性、行为，Thread大致就有哪些属性、行为。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;前文中有说到，Java线程通过Thread以及synchronized以及Object中的wait等对“控制、同步、通信”进行了抽象，synchronized关键字是同步，Object中的相关方法是通信，Thread中的信息主要是控制以及自身的行为，但是比如join方法，也可以被认为是用于“通信”，所以不要一概而论，也不要咬文嚼字，要注重背后的思维&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;69.5&quot;&gt;
&lt;h3&gt;&lt;span&gt;Thred概述&lt;/span&gt;&lt;/h3&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190207131229547-358891921.png&quot;&gt;&lt;img title=&quot;image_5c5bbdec_1820&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190207131230030-1313145917.png&quot; alt=&quot;image_5c5bbdec_1820&quot; width=&quot;231&quot; height=&quot;179&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;线程也是对程序运行的抽象描述，所以线程包括两部分信息：&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;一个是线程自身数据（元数据）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;另一个是将要执行的任务&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;自身数据又分为必备的控制信息以及行为。&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190207131230314-1239786499.png&quot;&gt;&lt;img title=&quot;image_5c5bbdec_23e&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190207131230672-1043284441.png&quot; alt=&quot;image_5c5bbdec_23e&quot; width=&quot;507&quot; height=&quot;261&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;也就是说一个Thread包括了三方面的信息：基本信息、线程自身的行为、线程任务&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190207131231073-1208779659.png&quot;&gt;&lt;img title=&quot;image_5c5bbdec_10c1&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190207131231340-1857174888.png&quot; alt=&quot;image_5c5bbdec_10c1&quot; width=&quot;685&quot; height=&quot;694&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;基本信息&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;如下图所示，基本信息包括下面这些&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;名称、id、优先级、状态、线程组、守护线程状态、堆栈信息跟踪&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;上下文类加载器设置、异常处理器设置 &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;是否存活、当前线程是否有权修改该线程&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190207131321929-1511019369.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div readability=&quot;66&quot;&gt;
&lt;h4&gt;&lt;span&gt;名称&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;线程是有名称的，有属性name，如果不指定名称，那么会生成thread-0，thread-1..........thread-N这种名称&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190207131232444-1677925908.png&quot;&gt;&lt;img title=&quot;image_5c5bbdec_614c&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190207131232680-1384426232.png&quot; alt=&quot;image_5c5bbdec_614c&quot; width=&quot;729&quot; height=&quot;235&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;  &lt;/span&gt;&lt;/div&gt;
&lt;h4&gt;&lt;span&gt;ID&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;如果类比到人的话，名称就是姓名，而ID就是身份证号，线程也有一个唯一的标识符&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;线程 ID 是一个正的 long 数，在创建该线程时生成，线程 ID 是唯一的，并终生不变&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;线程终止时，该线程 ID 可以被重新使用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在私有方法init方法中设置&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190207131232925-1117819515.png&quot;&gt;&lt;img title=&quot;image_5c5bbded_6a0e&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190207131233289-1954109256.png&quot; alt=&quot;image_5c5bbded_6a0e&quot; width=&quot;618&quot; height=&quot;387&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;  &lt;/span&gt;&lt;/div&gt;
&lt;h4&gt;&lt;span&gt;优先级&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;线程内部priority记录优先级&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;19&quot;&gt;
&lt;p&gt;&lt;span&gt;如果设置的值不在有效范围内，直接抛出异常&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;否则线程的优先级会被设置为“指定的 newPriority 和 该线程的线程组允许的最大优先级”两者中较小的那一个。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;简单说就是不能超过线程组的最大优先级，你工资再高也超不过你领导......&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;线程默认的优先级是NORM_PRIORITY=5，一般情况下不需要设置优先级&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;因为你设置了优先级并不一定总是完全按照你的想法进行，&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;前面说过，Java线程是操作系统原生线程的映射，要依赖操作系统&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;所以，万万不要业务逻辑依赖你自以为的线程优先级&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190207131233611-1940297212.png&quot;&gt;&lt;img title=&quot;image_5c5bbded_5c9b&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190207131233914-1710089109.png&quot; alt=&quot;image_5c5bbded_5c9b&quot; width=&quot;650&quot; height=&quot;383&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;  &lt;/span&gt;&lt;/div&gt;
&lt;h4&gt;&lt;span&gt;状态&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;类似进程，线程也是有专门的状态的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有内部类State&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190207131234139-2063761111.png&quot;&gt;&lt;img title=&quot;image_5c5bbded_7267&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190207131234330-1165792428.png&quot; alt=&quot;image_5c5bbded_7267&quot; width=&quot;281&quot; height=&quot;257&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;h4&gt;&lt;span&gt;线程组&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;线程组用于对线程进行管理，ThreadGroup&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;线程组表示一个线程的集合。此外，线程组也可以包含其他线程组&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;线程组构成一棵树，在树中，除了初始线程组外，每个线程组都有一个父线程组  &lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;守护线程状态&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;可以将一个Thread标记为守护线程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;守护线程，可以认为是后台线程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果没有任何一个非守护线程在运行，或者说在运行的线程都是守护线程，JVM将退出。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;全都是服务员，一个客人都没有，那还忙活个屁？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;需要注意的是，必须是线程启动前设置，不然你试试看，分分钟  throw new IllegalThreadStateException();&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;因为已启动尚未终止的就是isAlive==true&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190207131234526-572631689.png&quot;&gt;&lt;img title=&quot;image_5c5bbded_6cdb&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190207131234786-1868181490.png&quot; alt=&quot;image_5c5bbded_6cdb&quot; width=&quot;593&quot; height=&quot;290&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;  &lt;/span&gt;&lt;/div&gt;
&lt;h4&gt;&lt;span&gt;堆栈信息跟踪&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;简单的可以理解为线程运行时有一个“调用栈信息”，后续介绍  &lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;上下文类加载器设置&lt;/span&gt;&lt;/h4&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190207131235002-880402518.png&quot;&gt;&lt;img title=&quot;image_5c5bbded_719e&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190207131235212-1797111349.png&quot; alt=&quot;image_5c5bbded_719e&quot; width=&quot;615&quot; height=&quot;219&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;除非特别设置，否则contextClassLoader将会设置为与父线程同样的值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上线文类加载器是类加载机制的后门，打破了双亲委派模型，此处不对上下文类加载器进行介绍，也是一个比较重要的知识点。  &lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;异常处理器设置&lt;/span&gt;&lt;/h4&gt;
&lt;div readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;span&gt;线程在执行单元中是不允许抛出checked异常的，而且线程运行在自己的上下文中，派生它的线程将无法直接获得它运行中出现的异常信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以Java为我们提供异常处理器回调机制，异常处理器的设置就是这个作用   &lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;h4&gt;&lt;span&gt;是否存活&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;线程从启动之后，直到最终终止，这一个过程被称之为是活动状态&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;换句话说，一个线程start之后，除非他被终止，否则任何时刻都是true&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;isAlive就是用于检测线程是否处于活动状态  &lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;当前线程是否有权修改该线程&lt;/span&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;判定当前运行的线程是否有权修改该线程。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如线程Thread aThread，在main方法中调用aThread.checkAccess，此时当前线程是主线程main，目标是aThread&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么就是检测主线程是否有权利修改线程aThread&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;线程行为&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;Thread中的方法，有一些是线程本身的行为控制或者通信，另外还有一些相当于是工具类&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;还有一些被弃用了&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190207131235504-366983171.png&quot;&gt;&lt;img title=&quot;image_5c5bbded_7245&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190207131235783-950453943.png&quot; alt=&quot;image_5c5bbded_7245&quot; width=&quot;883&quot; height=&quot;1131&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190207131236003-1924293696.png&quot;&gt;&lt;img title=&quot;image_5c5bbded_2bcd&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190207131236289-625232350.png&quot; alt=&quot;image_5c5bbded_2bcd&quot; width=&quot;741&quot; height=&quot;256&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;h4&gt;&lt;span&gt;currentThread&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;返回对当前正在执行的线程对象的引用，线程是Thread，哪个Thread正在运行，那么就返回哪个对象就好了，返回类型就是Thread&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190207131236541-501429115.png&quot;&gt;&lt;img title=&quot;image_5c5bbded_1329&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190207131236812-482620442.png&quot; alt=&quot;image_5c5bbded_1329&quot; width=&quot;722&quot; height=&quot;146&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;h4&gt;&lt;span&gt;activeCount&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;返回的是当前线程，所在的线程组中，活动线程的个数&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190207131237004-514650160.png&quot;&gt;&lt;img title=&quot;image_5c5bbded_dea&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190207131237207-1692884644.png&quot; alt=&quot;image_5c5bbded_dea&quot; width=&quot;714&quot; height=&quot;72&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;h4&gt;&lt;span&gt;enumerate&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;线程的抽象是Thread，每一个线程都是一个Thread，既然是对象那么就有类似寻常对象的操作，比如保存到数组&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;enumerate就是用来讲当前线程的、所属线程组中的、以及子组中的每一个活动线程复制到指定的数组中，返回值为复制的线程的个数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;依赖于线程组中的相关方法&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190207131237387-796702299.png&quot;&gt;&lt;img title=&quot;image_5c5bbded_517&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190207131237618-2133752651.png&quot; alt=&quot;image_5c5bbded_517&quot; width=&quot;696&quot; height=&quot;73&quot; border=&quot;0&quot;/&gt;&lt;/a&gt; &lt;/span&gt;&lt;/div&gt;
&lt;div readability=&quot;15&quot;&gt;
&lt;h4&gt;&lt;span&gt;是否持有指定监视器的锁&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;如同前面提到过的互斥量，Java中同步时需要用到一个对象锁，如果一个线程请求的锁被别的线程获得，那么就需要进行等待，持有了锁就可以进入临界区。&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190207131237875-443861242.png&quot;&gt;&lt;img title=&quot;image_5c5bbded_3b73&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190207131238102-1209163384.png&quot; alt=&quot;image_5c5bbded_3b73&quot; width=&quot;505&quot; height=&quot;37&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;方法用于判断当前线程，当前线程、当前线程。针对于某个对象，是否持有对应的锁，当且仅当当前线程在指定的对象上保持监视器锁时，才返回 true。&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span&gt;如果 obj 为 null，抛出NPE    &lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;dumpStack&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;用于调试，将当前线程的信息打印到标准错误流&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190207131238424-1376108692.png&quot;&gt;&lt;img title=&quot;image_5c5bbded_e23&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190207131238701-701141374.png&quot; alt=&quot;image_5c5bbded_e23&quot; width=&quot;717&quot; height=&quot;198&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;线程任务&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;线程的任务核心是Runnable，内部持有一个Runnable target，构造时如果不进行设置那么为null&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190207131239002-1999265770.png&quot;&gt;&lt;img title=&quot;image_5c5bbded_74f&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190207131239208-537562100.png&quot; alt=&quot;image_5c5bbded_74f&quot; width=&quot;744&quot; height=&quot;122&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;调用start方法启动后，会调用run方法，如果不重写run方法，或者构造时不进程传递，那么target为null&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;很显然如果target，run方法就相当于一个空方法，也就是什么都不做。&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190207131239540-1993752829.png&quot;&gt;&lt;img title=&quot;image_5c5bbded_1283&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190207131239735-1324024636.png&quot; alt=&quot;image_5c5bbded_1283&quot; width=&quot;757&quot; height=&quot;128&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;简言之，Java对于线程以及线程任务，进行了抽象分离，对线程的抽象为Thread，而对于线程任务的抽象就是Runnable。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;Thread是Java对线程的抽象，所以他的属性信息自然与线程的概念是不谋而合和，本文对Thread中定义的一些属性进行了简单介绍，有些后续还会详细进行介绍&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Thread中的方法主要用于对线程进行控制也可以用作通信，还有一些是基于类设计层面的，添加进来的一些工具类，可以对线程的一些信息进行控制、获取&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;线程任务是通过Runnable进行抽象，简言之，Thread表示线程，Runnable表示任务。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;“分别是为了更好地重逢”放到这里非常合适，解耦是为了更好地协作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;线程本身和线程需要执行的任务进行分离，无论是从抽象概念上还是认知理解上，亦或者是二者独立的发展上，解耦都有多种好处&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190207131239908-373934117.png&quot;&gt;&lt;img title=&quot;image_5c5bbded_260c&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190207131240120-2000193750.png&quot; alt=&quot;image_5c5bbded_260c&quot; width=&quot;423&quot; height=&quot;195&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;彻底认清楚Thread的本质--线程概念的抽象，才能够更好的了解Thread中那些属性字段&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如你完全不了解IEEE754，何谈对Float的实现熟悉？概念都不清晰，哪来的清晰地实现？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Thread是对线程的抽象，封装了线程具有的一些属性和状态以及行为信息，具体就是体现在内部的字段和方法上，另外还有一些相当于工具类的存在的方法，也是构建在Thread中的，所以线程是Thread，Thread是线程概念的体现。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不管JVM内部如何映射，操作系统如何构建线程模型，Java开发者接触的就是Thread的实例对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;在Java这一面向对象的语言中，多线程编程就是“多Thread对象编程”&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们常说Java是纯粹的面向对象的编程语言，什么“封装、继承、多态”等等的，但是真的理解了面向对象的思维了么？这就是面向对象！万事万物都是对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 10 Feb 2019 12:35:00 +0000</pubDate>
<dc:creator>noteless</dc:creator>
<og:description>本文自顶而下的对于Thread的设计进行了拆解，从设计的角度分析了Thread的设计思维，通过本文的解读有助于理解Java这一面向对象的语言对于线程概念的封装</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/noteless/p/10354699.html</dc:identifier>
</item>
</channel>
</rss>