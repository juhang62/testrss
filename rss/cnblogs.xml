<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Oracle 10g RAC OCR、Voting disk更换 - AlfredZhao</title>
<link>http://www.cnblogs.com/jyzhao/p/10618658.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jyzhao/p/10618658.html</guid>
<description>&lt;p&gt;&lt;strong&gt;环境：&lt;/strong&gt;OEL 5.7 + Oracle 10.2.0.5 RAC&lt;br/&gt;&lt;strong&gt;需求：&lt;/strong&gt;更换存储，OCR、Voting disk同时需要更换到新存储。&lt;/p&gt;

&lt;p&gt;替换OCR（Oracle Cluster Registry）首先需要关闭RAC所有节点的crs，然后导出当前的ocr配置文件，手工修改ocr.loc文件后，导入ocr配置文件，可选择性创建ocrmirror。&lt;br/&gt;本次实验演示就是将原来的/dev/raw/raw1替换为/dev/raw/raw14，并创建ocrmirror为/dev/raw/raw15.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;--replace ocr
--两个节点关闭crs
/s01/oracle/product/10.2.0/crs_1/bin/crsctl stop crs
--ocrcheck
/s01/oracle/product/10.2.0/crs_1/bin/ocrcheck 
--导出ocr的配置
/s01/oracle/product/10.2.0/crs_1/bin/ocrconfig -export /tmp/ocrfile.dmp 
--查看文件大小
ls -lrt /tmp/ocrfile.dmp 
--两个节点修改ocr为新的/dev/raw/raw14
cat /etc/oracle/ocr.loc 
--导入ocr配置文件
/s01/oracle/product/10.2.0/crs_1/bin/ocrconfig -import /tmp/ocrfile.dmp 
/s01/oracle/product/10.2.0/crs_1/bin/ocrcheck 
--增加ocrmirror
/s01/oracle/product/10.2.0/crs_1/bin/ocrconfig -replace ocrmirror /dev/raw/raw15
/s01/oracle/product/10.2.0/crs_1/bin/ocrcheck
--最后查看ocr.loc文件
cat /etc/oracle/ocr.loc &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实际测试替换OCR的关键操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@rac1-server rules.d]# /s01/oracle/product/10.2.0/crs_1/bin/crsctl stop crs
[root@rac1-server rules.d]# /s01/oracle/product/10.2.0/crs_1/bin/ocrconfig -export /tmp/ocrfile.dmp 
[root@rac1-server rules.d]# vi /etc/oracle/ocr.loc 
ocrconfig_loc=/dev/raw/raw14
local_only=FALSE
[root@rac1-server rules.d]# /s01/oracle/product/10.2.0/crs_1/bin/ocrconfig -replace ocrmirror /dev/raw/raw15
[root@rac1-server rules.d]# /s01/oracle/product/10.2.0/crs_1/bin/ocrcheck
Status of Oracle Cluster Registry is as follows :
         Version                  :          2
         Total space (kbytes)     :      96144
         Used space (kbytes)      :       4652
         Available space (kbytes) :      91492
         ID                       : 1953645605
         Device/File Name         : /dev/raw/raw14
                                    Device/File integrity check succeeded
         Device/File Name         : /dev/raw/raw15
                                    Device/File integrity check succeeded

         Cluster registry integrity check succeeded

[root@rac1-server ~]#  cat /etc/oracle/ocr.loc 
#Device/file  getting replaced by device /dev/raw/raw15 
ocrconfig_loc=/dev/raw/raw14
ocrmirrorconfig_loc=/dev/raw/raw15
local_only=false
[root@rac1-server ~]# &lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;替换voting disk比较简单，只需要把新的voting disk加进来，然后把旧的删除即可。&lt;br/&gt;本次实验演示就是新加/dev/raw/raw11,/dev/raw/raw12,/dev/raw/raw13,然后将原来的/dev/raw/raw2删除。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;--replace voting disk
--which crsctl确认crsctl的全路径
/s01/oracle/product/10.2.0/crs_1/bin/crsctl
--查询当前的votedisk
crsctl query css votedisk
--添加新的votedisk
crsctl add css votedisk /dev/raw/raw11 -force
crsctl add css votedisk /dev/raw/raw12 -force
crsctl add css votedisk /dev/raw/raw13 -force
--删除旧的votedisk
crsctl delete css votedisk /dev/raw/raw2 -force&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实际替换voting disk的关键操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@rac1-server rules.d]# /s01/oracle/product/10.2.0/crs_1/bin/crsctl add css votedisk /dev/raw/raw11 
Cluster is not in a ready state for online disk addition
[root@rac1-server rules.d]# /s01/oracle/product/10.2.0/crs_1/bin/crsctl add css votedisk /dev/raw/raw11 -force
Now formatting voting disk: /dev/raw/raw11
successful addition of votedisk /dev/raw/raw11.
[root@rac1-server rules.d]# /s01/oracle/product/10.2.0/crs_1/bin/crsctl query css votedisk
 0.     0    /dev/raw/raw2
 1.     0    /dev/raw/raw11

located 2 votedisk(s).
[root@rac1-server rules.d]# /s01/oracle/product/10.2.0/crs_1/bin/crsctl add css votedisk /dev/raw/raw12 -force
Now formatting voting disk: /dev/raw/raw12
successful addition of votedisk /dev/raw/raw12.
[root@rac1-server rules.d]# /s01/oracle/product/10.2.0/crs_1/bin/crsctl add css votedisk /dev/raw/raw13 -force
Now formatting voting disk: /dev/raw/raw13
successful addition of votedisk /dev/raw/raw13.
[root@rac1-server rules.d]# /s01/oracle/product/10.2.0/crs_1/bin/crsctl query css votedisk
 0.     0    /dev/raw/raw2
 1.     0    /dev/raw/raw11
 2.     0    /dev/raw/raw12
 3.     0    /dev/raw/raw13

located 4 votedisk(s).
[root@rac1-server rules.d]# /s01/oracle/product/10.2.0/crs_1/bin/crsctl delete css votedisk /dev/raw/raw2
Cluster is not in a ready state for online disk removal
[root@rac1-server rules.d]# /s01/oracle/product/10.2.0/crs_1/bin/crsctl delete css votedisk /dev/raw/raw2 -force
successful deletion of votedisk /dev/raw/raw2.
[root@rac1-server rules.d]# /s01/oracle/product/10.2.0/crs_1/bin/crsctl query css votedisk
 0.     0    /dev/raw/raw11
 1.     0    /dev/raw/raw12
 2.     0    /dev/raw/raw13

located 3 votedisk(s).
[root@rac1-server rules.d]# &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;附录：本次实验环境：&lt;/strong&gt;&lt;br/&gt;1.旧存储模拟：4块盘：其中第1块盘分成了2个区，绑定为raw设备raw1和raw2，分别给ocr和voting disk使用，剩余3块是给ASM使用的：&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/846011/o_NewStorage3.png&quot;/&gt;&lt;br/&gt;2.新存储模拟：10块盘：其中前三块（raw11，raw12，raw13）给voting disk使用，第4块和第5块（raw14和raw15）给ocr使用：&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/846011/o_NewStorage2.png&quot;/&gt;&lt;br/&gt;3.使用新存储3块10G的盘和2块5G的盘分别新增DATADG和FRA2个ASM磁盘组，其中DATADG是Normal冗余，FRA是External冗余：&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/846011/o_NewStorage4.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 28 Mar 2019 15:55:00 +0000</pubDate>
<dc:creator>AlfredZhao</dc:creator>
<og:description>环境： OEL 5.7 + Oracle 10.2.0.5 RAC 需求： 更换存储，OCR、Voting disk同时需要更换到新存储。 '1.替换OCR' '2.替换voting disk' 1.</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jyzhao/p/10618658.html</dc:identifier>
</item>
<item>
<title>生产与学术之Pytorch模型导出为安卓Apk尝试记录 - lart</title>
<link>http://www.cnblogs.com/lart/p/10618665.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lart/p/10618665.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;写于 2019-01-08 的旧文, 当时是针对一个比赛的探索. 觉得可能对其他人有用, 就放出来分享一下&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://images.unsplash.com/photo-1535540878298-a155c6d065ef?ixlib=rb-1.2.1&amp;amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;amp;auto=format&amp;amp;fit=crop&amp;amp;w=750&amp;amp;q=80&quot; alt=&quot;upsplash&quot;/&gt;&lt;/p&gt;
&lt;p&gt;生产与学术, 真实的对立...&lt;/p&gt;
&lt;p&gt;这是我这两天对&lt;code&gt;pytorch深度学习-&amp;gt;android实际使用&lt;/code&gt;的这个流程的一个切身感受.&lt;/p&gt;
&lt;p&gt;说句实在的, 对于模型转换的探索, 算是我这两天最大的收获了...&lt;/p&gt;
&lt;p&gt;全部浓缩在了这里: &lt;a href=&quot;https://github.com/lartpang/DHSNet-PyTorch/blob/master/converter.ipynb&quot; class=&quot;uri&quot;&gt;https://github.com/lartpang/DHSNet-PyTorch/blob/master/converter.ipynb&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;鉴于github加载ipynb太慢, 这里可以使用这个链接 &lt;a href=&quot;https://nbviewer.jupyter.org/github/lartpang/DHSNet-PyTorch/blob/master/converter.ipynb&quot; class=&quot;uri&quot;&gt;https://nbviewer.jupyter.org/github/lartpang/DHSNet-PyTorch/blob/master/converter.ipynb&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;这两天&quot;&gt;这两天&lt;/h2&gt;
&lt;p&gt;最近在研究将pytorch的模型转换为独立的app, 网上寻找, 找到了一个流程: pytorch-&amp;gt;onnx-&amp;gt;caffe2-&amp;gt;android apk. 主要是基于这篇文章的启发: &lt;a href=&quot;https://zhuanlan.zhihu.com/p/32342366&quot;&gt;caffe2&amp;amp;pytorch之在移动端部署深度学习模型(全过程!)&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;这两天就在折腾这个工具链，为了导出onnx的模型, 不确定要基于怎样的网络, 是已经训练好的, 还是原始搭建网络后再训练来作为基础. 所以不断地翻阅&lt;a href=&quot;https://pytorch.org/tutorials/advanced/super_resolution_with_caffe2.html&quot;&gt;pytorch&lt;/a&gt;和&lt;a href=&quot;https://github.com/onnx/tutorials/tree/master/tutorials&quot;&gt;onnx&lt;/a&gt;的官方示例, 想要研究出来点什么, 可是, 都是自己手动搭建的模型. 而且使用的是预训练权重, 不是这样:&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def squeezenet1_1(pretrained=False, **kwargs):
    r&quot;&quot;&quot;SqueezeNet 1.1 model from the `official SqueezeNet repo
    &amp;lt;https://github.com/DeepScale/SqueezeNet/tree/master/SqueezeNet_v1.1&amp;gt;`_.
    SqueezeNet 1.1 has 2.4x less computation and slightly fewer parameters
    than SqueezeNet 1.0, without sacrificing accuracy.
    Args:
        pretrained (bool): If True, returns a model pre-trained on ImageNet
    &quot;&quot;&quot;
    model = SqueezeNet(version=1.1, **kwargs)
    if pretrained:
        model.load_state_dict(model_zoo.load_url(model_urls['squeezenet1_1']))
    return model
# Get pretrained squeezenet model
torch_model = squeezenet1_1(True)

from torch.autograd import Variable
batch_size = 1    # just a random number
# Input to the model
x = Variable(torch.randn(batch_size, 3, 224, 224), requires_grad=True)
# Export the model
torch_out = torch.onnx._export(
    torch_model,        # model being run
    x,                  # model input (or a tuple for multiple inputs)
    &quot;squeezenet.onnx&quot;,  # where to save the model (can be a file or file-like object)
    export_params=True) # store the trained parameter weights inside the model file&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;就是这样:&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# Create the super-resolution model by using the above model definition.
torch_model = SuperResolutionNet(upscale_factor=3)
# Load pretrained model weights
model_url = 'https://s3.amazonaws.com/pytorch/test_data/export/superres_epoch100-44c6958e.pth'
batch_size = 1    # just a random number
# Initialize model with the pretrained weights
torch_model.load_state_dict(model_zoo.load_url(model_url))
# set the train mode to false since we will only run the forward pass.
torch_model.train(False)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;两种都在载入预训练权重, 直接加载到搭建好的网络上. 对于我手头有的已经训练好的模型, 似乎并不符合这样的条件.&lt;/p&gt;
&lt;h3 id=&quot;导出整体模型&quot;&gt;导出整体模型&lt;/h3&gt;
&lt;p&gt;最后采用尽可能模仿上面的例子代码的策略, 将整个网络完整的导出(&lt;code&gt;torch.save(model)&lt;/code&gt;), 然后再仿照上面那样, 将完整的网络加载(&lt;code&gt;torch.load()&lt;/code&gt;)到转换的代码中, 照猫画虎, 以进一步处理.&lt;/p&gt;
&lt;blockquote readability=&quot;2.7115384615385&quot;&gt;
&lt;p&gt;这里也很大程度上受到这里的启发: &lt;a href=&quot;https://github.com/akirasosa/mobile-semantic-segmentation&quot; class=&quot;uri&quot;&gt;https://github.com/akirasosa/mobile-semantic-segmentation&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本来想尝试使用之前找到的不论效果还是性能都很强的R3Net进行转换, 可是, 出于作者搭建网络使用的特殊手段, 加上&lt;a href=&quot;http://www.cnblogs.com/lart/p/10618665.html#pickle和onnx的限制&quot;&gt;pickle和onnx的限制&lt;/a&gt;, 这个尝试没有奏效, 只好转回头使用之前学习的DHS-Net的代码, 因为它的实现是基于VGG的, 里面的搭建的网络也是需要修改来符合onnx的要求, 主要是更改上采样操作为转置卷积(也就是分数步长卷积, 这里顺带温习了下pytorch里的&lt;code&gt;nn.ConvTranspose2d()&lt;/code&gt;的&lt;a href=&quot;https://github.com/lartpang/Machine-Deep-Learning/issues/39&quot;&gt;计算方式&lt;/a&gt;), 因为pytorch的上采样在onnx转换过程中有很多的问题, 特别麻烦, 外加上修改最大池化的一个参数(&lt;code&gt;nn.MaxPool2d(kernel_size=2, stride=2, ceil_mode=False)&lt;/code&gt;的参数&lt;code&gt;ceil_mode&lt;/code&gt;改为&lt;code&gt;ceil_mode=False&lt;/code&gt;, 这里参考自前面的知乎专栏的那篇文章), 这样终于可以转换了, 为了方便和快速的测试, 我只是训练了一个epoch, 就直接导出模型, 这次终于可以顺利的&lt;code&gt;torch.save()&lt;/code&gt;了.&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;filename_opti = ('%s/model-best.pth' % check_root_model)
torch.save(model, filename_opti)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;之后便利用类似的代码进行了书写.&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;IMG_SIZE = 224
TMP_ONNX = 'cache/onnx/DHSNet.onnx'
MODEL_PATH = 'cache/opti/total-opti-current.pth'

# Convert to ONNX once
model = torch.load(MODEL_PATH).cuda()
model.train(False)

x = Variable(torch.randn(1, 3, 224, 224), requires_grad=True).cuda()
torch_out = torch.onnx._export(model, x, TMP_ONNX, export_params=True)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;caffe2模型转换&quot;&gt;caffe2模型转换&lt;/h3&gt;
&lt;p&gt;载入模型后, 便可以开始转换了, 这里需要安装caffe2, 官方推荐直接conda安装pytorch1每夜版即可, 会自动安装好依赖.&lt;/p&gt;
&lt;blockquote readability=&quot;19&quot;&gt;
&lt;p&gt;说起来这个conda, 就让我又爱又恨, 用它装pytorch从这里可以看出来, 确实不错, 对系统自身的环境没有太多的破坏, 可是用它装tensorflow-gpu的时候, 却是要自动把conda源里的cuda, cudnn工具包都给带上, 有时候似乎会破坏掉系统自身装载的cuda环境(? 不太肯定, 反正现在我不这样装, 直接上pip装, 干净又快速).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;之后的代码中, 主要的问题也就是tensor的cpu/cuda, 或者numpy的转换的问题了. 多尝试一下, 输出下类型就可以看到了.&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# Let's also save the init_net and predict_net to a file that we will later use for running them on mobile
with open('./cache/model_mobile/init_net.pb', &quot;wb&quot;) as fopen:
    fopen.write(init_net.SerializeToString())
with open('./cache/model_mobile/predict_net.pb', &quot;wb&quot;) as fopen:
    fopen.write(predict_net.SerializeToString())&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;预处理的补充&quot;&gt;预处理的补充&lt;/h3&gt;
&lt;p&gt;这里记录下, 查看pytorch的tensor的形状使用&lt;code&gt;tensor.size()&lt;/code&gt;方法, 查看numpy数组的形状则使用numpy数组的&lt;code&gt;adarray.shape&lt;/code&gt;方法, 而对于PIL(&lt;code&gt;from PIL import Image&lt;/code&gt;)读取的Image对象而言, 使用&lt;code&gt;Image.size&lt;/code&gt;查看, 而且, 这里只会显示宽和高的长度, 而且Image的对象, 是三维, 在于pytorch的tensor转换的时候, 或者输入网络的时候, 要注意添加维度, 而且要调整通道位置(&lt;code&gt;img = img.transpose(2, 0, 1)&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;由于网络保存的部分中, 只涉及到了网络的结构内的部分, 对于数据的预处理的部分并不涉及, 所以说要想真正的利用网络, 还得调整真实的输入, 来作为更适合网络的数据输入.&lt;/p&gt;
&lt;p&gt;要注意, 这里针对导出的模型的相关测试, 程实际上是&lt;strong&gt;按照测试网络的流程&lt;/strong&gt;来的.&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# load the resized image and convert it to Ybr format
mean = np.array([0.485, 0.456, 0.406])
std = np.array([0.229, 0.224, 0.225])
img = Image.open(&quot;./data/ILSVRC2012_test_00000004_224x224.jpg&quot;)
img = np.array(img)
img = img.astype(np.float64) / 255
img -= mean
img /= std
img = img.transpose(2, 0, 1)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;安卓的尝试&quot;&gt;安卓的尝试&lt;/h3&gt;
&lt;p&gt;首先安卓环境的配置就折腾了好久, 一堆破事, 真实的生产开发, 真心不易啊...&lt;/p&gt;
&lt;p&gt;这里最终还是失败了, 因为对于安卓的代码是在是不熟悉, 最起码的基础认知都不足, 只有这先前学习Java的一点皮毛知识, 根本不足以二次开发. 也就跑了跑几个完整的demo而已.&lt;/p&gt;
&lt;h4 id=&quot;aicamera&quot;&gt;&lt;a href=&quot;https://github.com/caffe2/AICamera&quot;&gt;AiCamera&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;这个跑通了, 但是这是个分类网络的例子, 对于我们要做的分割的任务而言, 有很多细节不一样.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;输入有差异: 比赛要求的是若是提交apk, 那么要求可以从相册读取图片, 而例子是从摄像头读取的视频数据流. 虽然也处理的是视频帧, 但是要我们再次补充的内容又多了起来, 还是那句话, android一窍不通.&lt;/li&gt;
&lt;li&gt;输出有差异: 自我猜测, 比赛为了测评, 输出必然也要输出到相册里, 不然何来测评一说?&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;aicamera-style-transfer&quot;&gt;&lt;a href=&quot;https://github.com/caffe2/AICamera-Style-Transfer&quot;&gt;AICamera-Style-Transfer&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;这个例子我们参考了一下, 只是因为它的任务是对摄像头视频流数据风格迁移, 而且会直接回显到手机屏幕上, 这里我们主要是想初步实现对于我们网络模型安卓迁移的测试, 在第一个例子的基础上能否实现初步的摄像头视频流的分割, 然后下一步再进一步满足比赛要求.&lt;/p&gt;
&lt;p&gt;可是, 尝试失败了. 虽然AS打包成了APK, &lt;a href=&quot;http://www.cnblogs.com/lart/p/10618665.html#打包apk安装&quot;&gt;手机也安装上了&lt;/a&gt;, 可是莫名的, 在&quot;loading...&quot;中便闪退了...&lt;/p&gt;
&lt;h4 id=&quot;jejunet&quot;&gt;&lt;a href=&quot;https://github.com/tantara/JejuNet&quot;&gt;JejuNet&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;这个例子很给力, 但是使用的是tensorflowlite, 虽然可以用, 能够实现下面的效果, 可是, 不会改.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/tantara/JejuNet/master/docs/20180726-current-results-deeplabv3_on_tf-lite.gif&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而且是量化网络, 准确率还是有待提升.&lt;/p&gt;
&lt;h2 id=&quot;最后的思考&quot;&gt;最后的思考&lt;/h2&gt;
&lt;p&gt;最后还是要思考一下的, 做个总结.&lt;/p&gt;
&lt;h3 id=&quot;没经验&quot;&gt;没经验&lt;/h3&gt;
&lt;p&gt;吃就吃在没经验的亏上了, 都是初次接触, 之前没怎么接触过安卓, 主要是安卓的开发对于电脑的配置要求太高了, 自己的笔记本根本不够玩的. 也就没有接触过了.&lt;/p&gt;
&lt;p&gt;外加上之前的研究学习, 主要是在学术的环境下搞得, 和实际的生产还有很大的距离, 科研与生产的分离, 这对于深度学习这一实际上更偏重实践的领域来说, 有些时候是尤为致命的. 关键时刻下不去手, 这多么无奈, 科学技术无法转化为实实在在的生产力, 忽然有些如梦一般的缥缈.&lt;/p&gt;
&lt;p&gt;当然, 最关键的还是, 没有仔细分析赛方的需求, 没有完全思考清楚, 直接就开干了, 这个鲁莽的毛病, 还是没有改掉, 浪费时间不说, 也无助于实际的进度. 赛方的说明含糊, 应该问清楚.&lt;/p&gt;
&lt;p&gt;若是担心时间, 那更应该看清楚要求, 切莫随意下手. 比赛说明里只是说要提交一个打包好的应用, 把环境, 依赖什么都处理好, 但是不一定是安卓apk呀, 可以有很多的形式, 但是这也只是最后的一点额外的辅助而已, 重点是模型的性能和效率呢.&lt;/p&gt;
&lt;p&gt;莫忘初心, 方得始终. 为什么我想到的是这句.&lt;/p&gt;
&lt;h3 id=&quot;下一步&quot;&gt;下一步&lt;/h3&gt;
&lt;p&gt;基本上就定了还是使用R3Net, 只能是进一步的细节修改了, 换换后面的循环结构了, 改改连接什么的.&lt;/p&gt;
&lt;p&gt;我准备再开始看论文, 学姐的论文可以看看, 似乎提出了一种很不错的后处理的方法, 效果提升很明显, 需要研究下.&lt;/p&gt;
&lt;h2 id=&quot;pickle和onnx的限制&quot;&gt;pickle和onnx的限制&lt;/h2&gt;
&lt;p&gt;pytorch的&lt;code&gt;torch.save(model)&lt;/code&gt;保存模型的时候, 模型架构的代码里&lt;strong&gt;不能使用一些特殊的构建形式&lt;/strong&gt;, &lt;a href=&quot;https://github.com/zijundeng/R3Net/blob/master/resnext/resnext_101_32x4d_.py&quot;&gt;R3Net的ResNeXt结构&lt;/a&gt;就用了, 主要是一些lambda结构, 虽然不是太清楚, 但是一般的搭建手段都是可以的.&lt;/p&gt;
&lt;p&gt;onnx对于pytorch的支持的操作, 在我的转化中, 主要是最大池化和上采样的问题, 前者可以修改&lt;code&gt;ceil_mode&lt;/code&gt;为&lt;code&gt;False&lt;/code&gt;, 后者则建议修改为转置卷积, 避免不必要的麻烦. 可见&lt;a href=&quot;http://www.cnblogs.com/lart/p/10618665.html#导出整体模型&quot;&gt;&quot;导出整体模型&quot;&lt;/a&gt;小节的描述.&lt;/p&gt;
&lt;h2 id=&quot;打包apk安装&quot;&gt;打包apk安装&lt;/h2&gt;
&lt;p&gt;这里主要是用release版本构建的apk.&lt;/p&gt;
&lt;p&gt;未签名的apk在我的mi 8se (android 8.1)上不能安装, 会解析失败, 需要签名, AS的签名的生成也很简单, 和生成apk在同一级上, 有生成的选项.&lt;/p&gt;
</description>
<pubDate>Thu, 28 Mar 2019 15:53:00 +0000</pubDate>
<dc:creator>lart</dc:creator>
<og:description>生产与学术 写于 2019 01 08 的旧文, 当时是针对一个比赛的探索. 觉得可能对其他人有用, 就放出来分享一下 生产与学术, 真实的对立... 这是我这两天对 的这个流程的一个切身感受. 说句</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lart/p/10618665.html</dc:identifier>
</item>
<item>
<title>TypeScript: type alias 与 interface - 刘哇勇</title>
<link>http://www.cnblogs.com/Wayou/p/type_alias_vs_interface.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Wayou/p/type_alias_vs_interface.html</guid>
<description>&lt;p&gt;官方文档中有关于两者对比的信息，隐藏在 TypeScript Handbook 中，见 &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/advanced-types.html&quot; rel=&quot;nofollow&quot;&gt;&lt;code&gt;Interfaces vs. Type Aliases&lt;/code&gt;&lt;/a&gt; 部分。&lt;/p&gt;
&lt;p&gt;但因为这一部分很久没更新了，所以其中描述的内容不一定全对。&lt;/p&gt;
&lt;p&gt;比如，&lt;/p&gt;
&lt;h3&gt;区别点之一：Type Alias 不会创建新的类型，体现在错误信息上。&lt;/h3&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;One difference is, that interfaces create a new name that is used everywhere. Type aliases don’t create a new name — for instance, error messages won’t use the alias name.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不完全正确。直接通过 type 定义的初始类型，是会创建相应的类型名称的。&lt;/p&gt;
&lt;p&gt;什么意思呢。就是说，不是使用 &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt; 等操作符创建的 union type 及 intersection type。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
type Person &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; {
  name&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; string;
  age&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; number;
};

&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; [x] Property 'age' is missing in type '{ name: string; }' but required in type 'Person'.ts(2741)&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt; bob&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; { 
  name&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;bob&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意这里错误信息使用的是类型 &lt;code&gt;Person&lt;/code&gt; 而不是对应的 plain object 对象。&lt;/p&gt;
&lt;h3&gt;区别点之二：type alias 不能被 &lt;code&gt;extends&lt;/code&gt; 和 &lt;code&gt;implements&lt;/code&gt;。&lt;/h3&gt;
&lt;p&gt;实际上在扩展和实现上二者已经没有区别，甚至可以混用，比如让一个 class 同时实现 interface 和 type alias 定义的类型。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;13&quot;&gt;
&lt;pre&gt;
type PointType &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; {
  x&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; number;
  y&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; number;
};

&lt;span class=&quot;pl-k&quot;&gt;interface&lt;/span&gt; PointInterface {
  a&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; number;
  b&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; number;
}

&lt;span class=&quot;pl-k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Shape&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;implements&lt;/span&gt; PointType, PointInterface {
  &lt;span class=&quot;pl-en&quot;&gt;constructor&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;4&lt;/span&gt;) {}
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;区别点之三：type alias 不能扩展和实现其他类型&lt;/h3&gt;
&lt;p&gt;不完全正确。因为通过正交操作符（intersection type） &lt;code&gt;&amp;amp;&lt;/code&gt; 可以达到 &lt;code&gt;extends&lt;/code&gt; 的目的。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;interface&lt;/span&gt; Person {
  name&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; string;
}

&lt;span class=&quot;pl-k&quot;&gt;interface&lt;/span&gt; Job {
  title&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; string;
}

type EmployeeType &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; Person &lt;span class=&quot;pl-k&quot;&gt;&amp;amp;&lt;/span&gt; Job;

&lt;span class=&quot;pl-k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Employee&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;implements&lt;/span&gt; EmployeeType {
  &lt;span class=&quot;pl-en&quot;&gt;constructor&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;Nobody&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;title&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;Noone&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;) {}
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面可以看到，两者大部分情况下不用过多区分。&lt;/p&gt;
&lt;p&gt;在使用了 union type 的时候，一些区别才开始显现。其实也算不得区别，因为只有 type alias 可通过 union type 定义。&lt;/p&gt;
&lt;h3&gt;当 type 包含 union type 时，该类型是不能被实现和扩展的。&lt;/h3&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;interface&lt;/span&gt; Triangle {
  area&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; number;
}

&lt;span class=&quot;pl-k&quot;&gt;interface&lt;/span&gt; Square {
  width&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; number;
  height&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; number;
}

type ShapeType &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; Triangle &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; Square;

&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; [x] An interface can only extend an object type or intersection of object types with statically known members.ts(2312)&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;interface&lt;/span&gt; MyShape &lt;span class=&quot;pl-k&quot;&gt;extends&lt;/span&gt; ShapeType; 


&lt;span class=&quot;pl-k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Shape&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;implements&lt;/span&gt; ShapeType{
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; [x] A class can only implement an object type or intersection of object types with statically known members.ts(2422)&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为 union type 描述的是一个&lt;strong&gt;或者&lt;/strong&gt;的状态，一个类不可能即是此类型也是另外种类型。interface 也不可能继承一个类型还不确定的类型。&lt;/p&gt;
&lt;h3&gt;类型合并&lt;/h3&gt;
&lt;p&gt;最明显的一点区别，是在进行类型合并（&lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/declaration-merging.html&quot; rel=&quot;nofollow&quot;&gt;Declaration Merging&lt;/a&gt;）的时候，type alias 是不会被合并的，而同名的多个 interface 会合并成一个。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;interface&lt;/span&gt; Person {
  name&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; string;
}
&lt;span class=&quot;pl-k&quot;&gt;interface&lt;/span&gt; Person {
  age&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; number;
}

&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt; person&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; {
  name&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;Bob&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;,
  age&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;9&lt;/span&gt;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于 type alias，存在同名时直接报错。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
type Person {  &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; [x] Duplicate identifier 'Person'.ts(2300)&lt;/span&gt;
  name&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; string;
}
type Person { &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; [x] Duplicate identifier 'Person'.ts(2300)&lt;/span&gt;
  age&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; number;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;明白这点对于三方库的作者来说很重要。假如你写了个 npm 包，导出的是 type，则使用者无法通过简单定义同名类型来进行扩充。&lt;/p&gt;
&lt;p&gt;所以，写库的时候，尽量使用 interface。&lt;/p&gt;
&lt;h3&gt;结论&lt;/h3&gt;
&lt;p&gt;官方推荐用 interface，其他无法满足需求的情况下用 type alias。&lt;/p&gt;
&lt;p&gt;但其实，因为 union type 和 intersection type 是很常用的，所以避免不了大量使用 type alias 的场景，一些复杂类型也需要通过组装后形成 type alias 来使用。所以，如果想保持代码统一，可尽量选择使用 type alias。通过上面的对比，type alias 其实可函盖 interface 的大部分场景。&lt;/p&gt;
&lt;p&gt;对于 React 组件中 props 及 state，使用 type alias，这样能够保证使用组件的地方不能随意在上面添加属性。如果有自定义需求，可通过 HOC （Higher-Order Components）二次封装。&lt;/p&gt;
&lt;p&gt;编写三方库时使用 interface，其更加灵活自动的类型合并可应对未知的复杂使用场景。&lt;/p&gt;
&lt;h3&gt;相关资料&lt;/h3&gt;
</description>
<pubDate>Thu, 28 Mar 2019 15:45:00 +0000</pubDate>
<dc:creator>刘哇勇</dc:creator>
<og:description>官方文档中有关于两者对比的信息，隐藏在 TypeScript Handbook 中，见 Interfaces vs. Type Aliases 部分。 但因为这一部分很久没更新了，所以其中描述的内容不</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Wayou/p/type_alias_vs_interface.html</dc:identifier>
</item>
<item>
<title>ThinkPHP 数据库操作(二) : 增删改查 - 键盘演绎青春</title>
<link>http://www.cnblogs.com/swjian/p/10618481.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/swjian/p/10618481.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;基本使用&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;可以直接使用数据库运行原生SQL操作了，支持 query （查询操作）和 execute （写入操作）方法，并且支持参数绑定。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
Db::query('select * from think_user where id=?',[8&lt;span&gt;]);
Db&lt;/span&gt;::execute('insert into think_user (id, name) values (?, ?)',[8,'thinkphp']);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也支持命名占位符绑定，例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
Db::query('select * from think_user where id=:id',['id'=&amp;gt;8&lt;span&gt;]);
Db&lt;/span&gt;::execute('insert into think_user (id, name) values (:id, :name)',['id'=&amp;gt;8,'name'=&amp;gt;'&lt;span&gt;thinkphp&lt;/span&gt;']);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以使用多个数据库连接，使用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Db::connect(&lt;span&gt;$config&lt;/span&gt;)-&amp;gt;query('select * from think_user where id=:id',['id'=&amp;gt;8]);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;config是一个单独的数据库配置，支持数组和字符串，也可以是一个数据库连接的配置参数名。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;查询数据&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;基本查询&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;查询一个数据使用：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; table方法必须指定完整的数据表名&lt;/span&gt;
Db::table('think_user')-&amp;gt;where('id',1)-&amp;gt;find();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　find 方法查询结果不存在，返回 null&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;查询数据集使用：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Db::table('think_user')-&amp;gt;where('status',1)-&amp;gt;select();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　select 方法查询结果不存在，返回空数组&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果设置了数据表前缀参数的话，可以使用&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
Db::name('user')-&amp;gt;where('id',1)-&amp;gt;&lt;span&gt;find();
Db&lt;/span&gt;::name('user')-&amp;gt;where('status',1)-&amp;gt;select();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　如果你的数据表没有使用表前缀功能，那么name和table方法的一样的效果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在 find 和 select 方法之前可以使用所有的链式操作方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　默认情况下，find和select方法返回的都是数组。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;助手函数&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;系统提供了一个 db 助手函数，可以更方便的查询：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
db('user')-&amp;gt;where('id',1)-&amp;gt;&lt;span&gt;find();
db(&lt;/span&gt;'user')-&amp;gt;where('status',1)-&amp;gt;select();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　注意：使用db助手函数默认每次都会重新连接数据库，而使用 Db::name 或者 Db::table 方法的话都 是单例的。db函数如果需要采用相同的链接，可以传入第三个参数，例如：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
db('user',[],&lt;span&gt;false&lt;/span&gt;)-&amp;gt;where('id',1)-&amp;gt;&lt;span&gt;find();
db(&lt;/span&gt;'user',[],&lt;span&gt;false&lt;/span&gt;)-&amp;gt;where('status',1)-&amp;gt;select();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;上面的方式会使用同一个数据库连接，第二个参数为数据库的连接参数，留空表示采用数据库配置文件的 配置。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;使用Query对象或闭包查询&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;或者使用查询对象进行查询，例如：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$query&lt;/span&gt; = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; \think\db\Query();
&lt;/span&gt;&lt;span&gt;$query&lt;/span&gt;-&amp;gt;table('think_user')-&amp;gt;where('status',1&lt;span&gt;);
Db&lt;/span&gt;::find(&lt;span&gt;$query&lt;/span&gt;&lt;span&gt;);
Db&lt;/span&gt;::select(&lt;span&gt;$query&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或者直接使用闭包函数查询，例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Db::select(&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;$query&lt;/span&gt;&lt;span&gt;){
　　&lt;/span&gt;&lt;span&gt;$query&lt;/span&gt;-&amp;gt;table('think_user')-&amp;gt;where('status',1&lt;span&gt;);
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;值和列查询&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;查询某个字段的值可以用&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回某个字段的值&lt;/span&gt;
Db::table('think_user')-&amp;gt;where('id',1)-&amp;gt;value('name');
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　value 方法查询结果不存在，返回 null&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;查询某一列的值可以用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回数组&lt;/span&gt;
Db::table('think_user')-&amp;gt;where('status',1)-&amp;gt;column('name'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 指定索引&lt;/span&gt;
Db::table('think_user')-&amp;gt;where('status',1)-&amp;gt;column('name','id');
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;column 方法查询结果不存在，返回空数组&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;数据集分批处理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如果你需要处理成千上百条数据库记录，可以考虑使用chunk方法，该方法一次获取结果集的一小块，然后填 充每一小块数据到要处理的闭包，该方法在编写处理大量数据库记录的时候非常有用。&lt;/p&gt;
&lt;p&gt;比如，我们可以全部用户表数据进行分批处理，每次处理 100 个用户记录：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
Db::table('think_user')-&amp;gt;chunk(100, &lt;span&gt;function&lt;/span&gt;(&lt;span&gt;$users&lt;/span&gt;&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;$users&lt;/span&gt; &lt;span&gt;as&lt;/span&gt; &lt;span&gt;$user&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;查询数据&lt;/span&gt;
&lt;span&gt;    }
});
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 或者交给回调方法myUserIterator处理&lt;/span&gt;
Db::table('think_user')-&amp;gt;chunk(100, 'myUserIterator');
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;你可以通过从闭包函数中返回false来中止对数据集的处理：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Db::table('think_user')-&amp;gt;chunk(100, &lt;span&gt;function&lt;/span&gt;(&lt;span&gt;$users&lt;/span&gt;&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 处理结果集...&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也支持在chunk方法之前调用其它的查询方法，例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
Db::table('think_user')-&amp;gt;where('score','&amp;gt;',80)-&amp;gt;chunk(100,&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;$users&lt;/span&gt;&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;$users&lt;/span&gt; &lt;span&gt;as&lt;/span&gt; &lt;span&gt;$user&lt;/span&gt;&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;//
&lt;/span&gt;&lt;span&gt;    }
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;JSON类型数据查询（mysql V5.0.1 ）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 查询JSON类型字段 （info字段为json类型）&lt;/span&gt;
Db::table('think_user')-&amp;gt;where('info$.email','thinkphp@qq.com')-&amp;gt;find();
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;添加数据&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;添加一条数据&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用 Db 类的 insert 方法向数据库提交数据&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$data&lt;/span&gt; = ['foo' =&amp;gt; 'bar', 'bar' =&amp;gt; 'foo'&lt;span&gt;];
Db&lt;/span&gt;::table('think_user')-&amp;gt;insert(&lt;span&gt;$data&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果你在 database.php 配置文件中配置了数据库前缀( prefix )，那么可以直接使用 Db 类的 name 方法提交数据&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Db::name('user')-&amp;gt;insert(&lt;span&gt;$data&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;insert 方法添加数据成功返回添加成功的条数，insert 正常情况返回 1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;添加数据后如果需要返回新增数据的自增主键，可以使用 getLastInsID 方法：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Db::name('user')-&amp;gt;insert(&lt;span&gt;$data&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;$userId&lt;/span&gt; = Db::name('user')-&amp;gt;getLastInsID();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或者直接使用 insertGetId 方法新增数据并返回主键值：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Db::name('user')-&amp;gt;insertGetId(&lt;span&gt;$data&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;insertGetId 方法添加数据成功返回添加数据的自增主键&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;添加多条数据&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;添加多条数据直接向 Db 类的 insertAll 方法传入需要添加的数据即可&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$data&lt;/span&gt; =&lt;span&gt; [
　　[&lt;/span&gt;'foo' =&amp;gt; 'bar', 'bar' =&amp;gt; 'foo'],&lt;span&gt;
　　[&lt;/span&gt;'foo' =&amp;gt; 'bar1', 'bar' =&amp;gt; 'foo1'],&lt;span&gt;
　　[&lt;/span&gt;'foo' =&amp;gt; 'bar2', 'bar' =&amp;gt; 'foo2'&lt;span&gt;]
];
Db&lt;/span&gt;::name('user')-&amp;gt;insertAll(&lt;span&gt;$data&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　insertAll 方法添加数据成功返回添加成功的条数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;助手函数&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加单条数据&lt;/span&gt;
db('user')-&amp;gt;insert(&lt;span&gt;$data&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加多条数据&lt;/span&gt;
db('user')-&amp;gt;insertAll(&lt;span&gt;$list&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;快捷更新&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;V5.0.5+ 以上版本封装的快捷更新方法 data ，可以配合 insert 使用。&lt;/p&gt;
&lt;p&gt;下面举个例子说明用法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Db::table('data'&lt;span&gt;)
&lt;/span&gt;-&amp;gt;data(['name'=&amp;gt;'tp','score'=&amp;gt;1000&lt;span&gt;])
&lt;/span&gt;-&amp;gt;insert();
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;更新数据&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;更新数据表中的数据&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Db::table('think_user'&lt;span&gt;)
&lt;/span&gt;-&amp;gt;where('id', 1&lt;span&gt;)
&lt;/span&gt;-&amp;gt;update(['name' =&amp;gt; 'thinkphp']);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果数据中包含主键，可以直接使用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Db::table('think_user'&lt;span&gt;)
&lt;/span&gt;-&amp;gt;update(['name' =&amp;gt; 'thinkphp','id'=&amp;gt;1]);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;update 方法返回影响数据的条数，没修改任何数据返回 0&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如果要更新的数据需要使用 SQL 函数或者其它字段，可以使用下面的方式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
Db::table('think_user'&lt;span&gt;)
&lt;/span&gt;-&amp;gt;where('id', 1&lt;span&gt;)
&lt;/span&gt;-&amp;gt;&lt;span&gt;update([
    &lt;/span&gt;'login_time' =&amp;gt; ['exp','now()'],
    'login_times' =&amp;gt; ['exp','login_times+1'],&lt;span&gt;
]);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;更新某个字段的值&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
Db::table('think_user'&lt;span&gt;)
    &lt;/span&gt;-&amp;gt;where('id',1&lt;span&gt;)
    &lt;/span&gt;-&amp;gt;setField('name', 'thinkphp');
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　setField 方法返回影响数据的条数，没修改任何数据字段返回 0&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;自增或自减一个字段的值&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;setInc/setDec 如不加第二个参数，默认值为1&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; score 字段加 1&lt;/span&gt;
Db::table('think_user'&lt;span&gt;)
    &lt;/span&gt;-&amp;gt;where('id', 1&lt;span&gt;)
    &lt;/span&gt;-&amp;gt;setInc('score'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; score 字段加 5&lt;/span&gt;
Db::table('think_user'&lt;span&gt;)
    &lt;/span&gt;-&amp;gt;where('id', 1&lt;span&gt;)
    &lt;/span&gt;-&amp;gt;setInc('score', 5&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; score 字段减 1&lt;/span&gt;
Db::table('think_user'&lt;span&gt;)
    &lt;/span&gt;-&amp;gt;where('id', 1&lt;span&gt;)
    &lt;/span&gt;-&amp;gt;setDec('score'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; score 字段减 5&lt;/span&gt;
Db::table('think_user'&lt;span&gt;)
    &lt;/span&gt;-&amp;gt;where('id', 1&lt;span&gt;)
    &lt;/span&gt;-&amp;gt;setDec('score', 5);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;延迟更新&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;setInc/setDec 支持延时更新，如果需要延时更新则传入第三个参数&lt;/p&gt;
&lt;p&gt;下例中延时10秒，给 score 字段增加1&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
Db::table('think_user')-&amp;gt;where('id', 1)-&amp;gt;setInc('score', 1, 10);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　setInc/setDec 方法返回影响数据的条数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;助手函数&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 更新数据表中的数据&lt;/span&gt;
db('user')-&amp;gt;where('id',1)-&amp;gt;update(['name' =&amp;gt; 'thinkphp'&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 更新某个字段的值&lt;/span&gt;
db('user')-&amp;gt;where('id',1)-&amp;gt;setField('name','thinkphp'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 自增 score 字段&lt;/span&gt;
db('user')-&amp;gt;where('id', 1)-&amp;gt;setInc('score'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 自减 score 字段&lt;/span&gt;
db('user')-&amp;gt;where('id', 1)-&amp;gt;setDec('score');
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;快捷更新（ V5.0.5+ ）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;V5.0.5+ 以上版本封装的 data 、 inc 、 dec 和 exp 方法属于链式操作方法，可以配合 update 使 用。&lt;/p&gt;
&lt;p&gt;下面举个例子说明用法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
Db::table('data'&lt;span&gt;)
&lt;/span&gt;-&amp;gt;where('id',1&lt;span&gt;)
&lt;/span&gt;-&amp;gt;inc('read'&lt;span&gt;)
&lt;/span&gt;-&amp;gt;dec('score',3&lt;span&gt;)
&lt;/span&gt;-&amp;gt;&lt;span&gt;exp&lt;/span&gt;('name','UPPER(name)'&lt;span&gt;)
&lt;/span&gt;-&amp;gt;update();
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;删除数据&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;删除数据表中的数据&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据主键删除&lt;/span&gt;
Db::table('think_user')-&amp;gt;delete(1&lt;span&gt;);
Db&lt;/span&gt;::table('think_user')-&amp;gt;delete([1,2,3&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 条件删除&lt;/span&gt;
Db::table('think_user')-&amp;gt;where('id',1)-&amp;gt;&lt;span&gt;delete();
Db&lt;/span&gt;::table('think_user')-&amp;gt;where('id','&amp;lt;',10)-&amp;gt;delete();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;delete 方法返回影响数据的条数，没有删除返回 0&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;助手函数&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据主键删除&lt;/span&gt;
db('user')-&amp;gt;delete(1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 条件删除&lt;/span&gt;
db('user')-&amp;gt;where('id',1)-&amp;gt;delete();
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Thu, 28 Mar 2019 15:45:00 +0000</pubDate>
<dc:creator>键盘演绎青春</dc:creator>
<og:description>基本使用 可以直接使用数据库运行原生SQL操作了，支持 query （查询操作）和 execute （写入操作）方法，并且支持参数绑定。 也支持命名占位符绑定，例如： 可以使用多个数据库连接，使用 c</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/swjian/p/10618481.html</dc:identifier>
</item>
<item>
<title>[个人网站搭建]·极简方式统计个人网页访问量（基于百度统计） - 小宋是呢</title>
<link>http://www.cnblogs.com/xiaosongshine/p/10618638.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaosongshine/p/10618638.html</guid>
<description>&lt;p&gt;个人主页--&amp;gt; &lt;a href=&quot;https://xiaosongshine.github.io/&quot; data-cke-saved-href=&quot;https://xiaosongshine.github.io/&quot;&gt;https://xiaosongshine.github.io/&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;个人网站搭建github地址：&lt;a href=&quot;https://github.com/xiaosongshine/djangoWebs&quot; data-cke-saved-href=&quot;https://github.com/xiaosongshine/djangoWebs&quot;&gt;https://github.com/xiaosongshine/djangoWebs&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;建好了网站，我们可以利用百度统计，可以很简单的看到自己网页的被访问次数。&lt;/p&gt;
&lt;p&gt;使用方式也特别简单，只需要注册百度统计账户，然后把一段代码拷贝到你的网页里，十分简单方便。&lt;/p&gt;
&lt;p&gt;实践演示照片：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;5&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://img-blog.csdnimg.cn/201903281655129.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9zb25nc2hpbmU=,size_16,color_FFFFFF,t_70&quot; alt=&quot;&quot; width=&quot;853&quot; height=&quot;480&quot; data-cke-saved-src=&quot;https://img-blog.csdnimg.cn/201903281655129.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9zb25nc2hpbmU=,size_16,color_FFFFFF,t_70&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://img-blog.csdnimg.cn/201903281655129.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9zb25nc2hpbmU=,size_16,color_FFFFFF,t_70&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;853&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;480&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h3&gt;1.注册百度统计站长版&lt;/h3&gt;
&lt;p&gt;百度搜索&quot;百度统计&quot;，打开网页后，点击右上角的&quot;注册&quot;。&lt;/p&gt;

&lt;p&gt;我们是为自己的网站统计流量，所以点击&quot;注册百度统计站长版&quot;。&lt;/p&gt;

&lt;p&gt;按要求填写注册信息。&lt;/p&gt;

&lt;h3&gt;2.部署到自己网页中&lt;/h3&gt;
&lt;p&gt;注册完成邮箱验证后，就能登录百度统计了，点开&quot;网站中心&quot;，再点击&quot;代码管理&quot;目录下的&quot;代码获取&quot;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：登陆后会让你输入个人网站，如果你已经有了个人网站，输入就可以了，如果还没有的话，就先自己写一个，不要和其他人一样就可以了。比如我输入的是 yansongsong.cn 但是其实我的网址正在审核中，还没有发放下来。你其实把代码部署在哪里，哪里据可以统计的。我主页实际访问地址是：&lt;/strong&gt;&lt;a href=&quot;http://118.25.101.147/&quot; data-cke-saved-href=&quot;http://118.25.101.147/&quot;&gt;http://118.25.101.147/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;你会获取到如下代码：（这是我的，大家要根据自己的来获取使用）&lt;/p&gt;
&lt;p&gt;1. 新版统计代码获取 &lt;/p&gt;
&lt;p&gt;此代码同时适用于PC端、移动端的页面，以异步加载形式进行加载，数据更准确、加载速度更快。请将此代码复制并粘贴到您要跟踪的每个网页中。&lt;/p&gt;

&lt;p&gt;2. 代码安装说明 &lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1. 请将代码添加到网站全部页面的&amp;lt;/head&amp;gt;标签前。&lt;strong&gt;（就是放在&amp;lt;head&amp;gt;&amp;lt;/head&amp;gt;之间）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;2. 建议在header.htm类似的页头模板页面中安装，以达到一处安装，全站皆有的效果。&lt;/li&gt;
&lt;li&gt;3. 如需在JS文件中调用统计分析代码，请直接去掉以下代码首尾的，&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;与&amp;lt;/script&amp;gt;后，放入JS文件中即可。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果代码安装正确，一般20分钟后，可以查看网站分析数据。&lt;/p&gt;
&lt;p&gt;3. 代码检测&lt;/p&gt;
&lt;p&gt;代码安装完成后，您可以在“&lt;a href=&quot;https://tongji.baidu.com/sc-web/27624413/home/js/check?siteId=13237992&quot; data-cke-saved-href=&quot;https://tongji.baidu.com/sc-web/27624413/home/js/check?siteId=13237992&quot;&gt;代码安装检查&lt;/a&gt;”页面自动检测或手动检测代码安装情况。&lt;/p&gt;
&lt;p&gt;小贴士：&lt;/p&gt;
&lt;p&gt;1.此代码不会影响您网站页面的显示，请您放心使用。&lt;/p&gt;
&lt;p&gt;2.如果您有技术上的疑问，可咨询您的网站管理员、托管公司，或者百度推广顾问。&lt;/p&gt;
&lt;p&gt;Please Enjoy Yourself。。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;欢迎大家访问我的&lt;a href=&quot;https://xiaosongshine.github.io/&quot; data-cke-saved-href=&quot;https://xiaosongshine.github.io/&quot;&gt;主页&lt;/a&gt;尝试一下，觉得有用的话，麻烦小小鼓励一下 &amp;gt;&amp;lt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;个人网站搭建github地址：&lt;a href=&quot;https://github.com/xiaosongshine/djangoWebs&quot; data-cke-saved-href=&quot;https://github.com/xiaosongshine/djangoWebs&quot;&gt;https://github.com/xiaosongshine/djangoWebs&lt;/a&gt; 欢迎访问&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 28 Mar 2019 15:43:00 +0000</pubDate>
<dc:creator>小宋是呢</dc:creator>
<og:description>[个人网站搭建]·极简方式统计个人网页访问量（基于百度统计） 个人主页--&gt; https://xiaosongshine.github.io/ 个人网站搭建github地址：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaosongshine/p/10618638.html</dc:identifier>
</item>
<item>
<title>Solr 17 - Solr的时间为什么比本地少8小时（附修改方法） - 马瘦风</title>
<link>http://www.cnblogs.com/shoufeng/p/10618571.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shoufeng/p/10618571.html</guid>
<description>&lt;p&gt;(1) 原因:&lt;/p&gt;
&lt;p&gt;Solr服务中默认使用的是UTC时间, 而中国本地时间为东八时区, 即比UTC标准时间多8小时.&lt;/p&gt;
&lt;p&gt;(2) 示例:&lt;/p&gt;
&lt;blockquote readability=&quot;14&quot;&gt;
&lt;p&gt;① 中国内地服务器时间为&lt;code&gt;2018-10-10 20:00:00&lt;/code&gt;, 系统将当前时间添加到Solr索引中时, Solr底层发现此时间的格式为&lt;code&gt;UTC + 8&lt;/code&gt;, 它将对该时间减去8小时处理, 然后建立相关索引.&lt;br/&gt;② 在查询上述添加的时间时, Solr直接将索引信息返回, 变为: &lt;code&gt;2018-10-10T12:00:00Z&lt;/code&gt; ==&amp;gt; 时间少了8小时.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;(3) 不同的时间格式:&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;UT, Universal Time, 世界时&lt;/strong&gt;: 是基于天体观察计算出来的时间, 是指英国格林尼治所在地的标准时间. 由于天体运行的一些不确定性(比如地球的自转并不是匀速的, 而且正在缓慢减速), 所以UT时间并不均匀.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;UTC, Universal Time Coordinate&lt;/strong&gt;: 协调世界时, 是基于原子时钟的时间, 是均匀的时间. 为了与UT时间保持较小的差距, UTC体系中增加了闰秒, 即某些年份的最后1分钟有61秒.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;GMT, Greenwish Mean Time, 格林尼治标准时间&lt;/strong&gt;: 是人们对UTC的另一种称法. 本初子午线被定义为英国伦敦郊区的皇家格林尼治天文台所在的经线, 此前人们将此地的时间当做标准时间, 但后来发现基于地球的时间并不准确, 在提出UTC概念后, 人们仍然自然地使用GMT来表达时间, 而此时的GMT == UTC.&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;通过Solr Admin (Solr Web界面)查看:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;(1) 进入Solr Admin, 点击左侧的&lt;code&gt;Java Properties&lt;/code&gt;菜单, 进入Java属性设置页面;&lt;/p&gt;
&lt;p&gt;(2) 下拉右侧的滚动条至底部, 可以看到时区属性, 如下图所示:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1438655/201903/1438655-20190328233102998-1808924987.jpg&quot; width=&quot;80%&quot; alt=&quot;Solr用户本地系统的时区&quot;/&gt;&lt;/p&gt;
&lt;p&gt;说明: 默认的时区为UTC, 上图是已经修改后的东八区(GMT+8).&lt;/p&gt;

&lt;h2 id=&quot;solr从数据库中同步数据的原理&quot;&gt;3.1 Solr从数据库中同步数据的原理&lt;/h2&gt;
&lt;p&gt;① 我们知道, Solr中的数据源有很多是类似于MySQL的关系型数据库, 也就是Solr通过其DIH(Data Import Handler)处理;&lt;/p&gt;
&lt;p&gt;② Solr在更新数据时, 会记录这些数据的最后更新时间戳, 保存在&lt;code&gt;Collection/conf&lt;/code&gt;目录下, 与&lt;code&gt;db-data-config.xml&lt;/code&gt;文件同级, 文件内容类似于:&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;#Thu Jan 24 15:03:58 CST 2019
_delta.last_index_time=2019-01-08T05\:48\:21Z
_full.last_index_time=2019-01-24T07\:03\:37Z
last_index_time=2019-01-24T07\:03\:37Z&lt;/code&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;③ 在向MySQL、MongoDB等数据库中写入数据时, 添加类似于&lt;code&gt;CreateTime&lt;/code&gt;的字段, 用于记录数据的入库时间戳;&lt;/p&gt;
&lt;p&gt;④ 通过比较Solr和数据库的更新时间戳, 完成对数据是否需要&lt;strong&gt;增量同步&lt;/strong&gt;的判断, 从而实现数据更新. 对比方式类似于:&lt;/p&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;!-- MySQL中增量同步数据的配置类似于 --&amp;gt;
&amp;lt;entity name=&quot;BookShop_delta&quot; 
     query=&quot;SELECT ID, Name, CreateTime FROM BookShop 
            WHERE CreateTime &amp;gt;= '${dataimporter.last_index_time}'&quot; pk=&quot;ID&quot;&amp;gt;
&amp;lt;field column=&quot;ID&quot; name=&quot;ID&quot; /&amp;gt;
&amp;lt;!-- ... --&amp;gt;
&amp;lt;/entity&amp;gt;

&amp;lt;!-- MongoDB中增量导入数据的配置类似于 --&amp;gt;
&amp;lt;entity name=&quot;_delta&quot; processor=&quot;MongoEntityProcessor&quot;
          query=&quot;{'CreateTime': {'$gte': ISODate('${dih.last_index_time}')}}&quot;
     collection=&quot;BookShop&quot; project=&quot;{_id:0, ID:1, Name:1, CreateTime:1}&quot;
     datasource=&quot;ShopMongo&quot; transformer=&quot;MongoMapperTransformer&quot; &amp;gt;    
&amp;lt;field column=&quot;ID&quot; name=&quot;ID&quot; /&amp;gt;
&amp;lt;!-- ... --&amp;gt;
&amp;lt;/entity&amp;gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;h2 id=&quot;为什么要修改时区&quot;&gt;3.2 为什么要修改时区&lt;/h2&gt;
&lt;p&gt;由上述分析可知, 修改时区的原因主要是: &lt;strong&gt;方便与数据库中数据的自动同步.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一般情况下, MySQL等数据库服务器的时区都与实际时区一致, 也就是东八区(GMT+8), 而Solr默认的时区是UTC, 与东八区(GMT+8)相差8个小时.&lt;/p&gt;
&lt;p&gt;这种差距导致我们无法直接根据Solr的更新时间戳和MySQL等数据库的更新时间戳进行比较, 从而使得数据的导入出现问题.&lt;/p&gt;
&lt;p&gt;==&amp;gt; 所以需要修改Solr的时区.&lt;/p&gt;
&lt;h2 id=&quot;如何修改时区&quot;&gt;3.3 如何修改时区&lt;/h2&gt;
&lt;p&gt;Solr的时区属性所在配置文件, 在&lt;code&gt;${SOLR_HOME}/bin&lt;/code&gt;下:&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;code&gt;solr.in.sh&lt;/code&gt;是Linux系统下的启动脚本, &lt;code&gt;solr.in.cmd&lt;/code&gt;是Windows系统下的启动脚本.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以Linux系统为例, 编辑&lt;code&gt;solr.in.sh&lt;/code&gt;文件:&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;vim /data/solr-cloud/solr-4.10.4/bin/solr.in.sh&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;找到&lt;code&gt;SOLR_TIMEZONE&lt;/code&gt;的相关配置: &lt;code&gt;SOLR_TIMEZONE=&quot;UTC&quot;&lt;/code&gt;, 可以看出默认的时区是UTC, 而且被注释掉了. 可将其修改为:&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;SOLR_TIMEZONE=&quot;UTC+8&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;保存退出后, 重启Solr服务, 然后再次进入Solr Admin管理界面, 查看&lt;code&gt;Java Properties&lt;/code&gt;菜单, 即可发现时区已经修改成功.&lt;/p&gt;
&lt;blockquote readability=&quot;0.80459770114943&quot;&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/xujiezhige/article/details/8215186&quot;&gt;UT,UTC,GMT时间区别&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/hanchao5272/article/details/79991164&quot;&gt;Linux+Solr+Zookeeper-04:修改Solr的时区TIMEZONE&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;16.040752351097&quot;&gt;

&lt;p&gt;作者: ma_shoufeng(马瘦风)&lt;/p&gt;
&lt;p&gt;出处: 博客园 &lt;a href=&quot;https://www.cnblogs.com/shoufeng&quot;&gt;马瘦风的博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;您的支持是对博主的极大鼓励, 感谢您的阅读.&lt;/p&gt;
&lt;p&gt;本文版权归博主所有, 欢迎转载, 但请保留此段声明, 并在文章页面明显位置给出原文链接, 否则博主保留追究相关人员法律责任的权利.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 28 Mar 2019 15:30:00 +0000</pubDate>
<dc:creator>马瘦风</dc:creator>
<og:description>Solr的时区为什么总是UTC? 从数据库同步数据到Solr, 为什么时间总是少了8小时? 要怎样修改Solr的默认时区?这篇文章来做个实践和探讨.</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shoufeng/p/10618571.html</dc:identifier>
</item>
<item>
<title>springboot之旅第二篇-配置 - 茶底世界</title>
<link>http://www.cnblogs.com/yuanqinnan/p/10618511.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuanqinnan/p/10618511.html</guid>
<description>&lt;h2&gt;一、引言&lt;/h2&gt;
&lt;p&gt;虽然springboot帮我们进行了自动配置，但配置还是不可避免的，比如最简单的端口号，数据库连接。但springboot的配置一般不用xml进行配置，而是yml和properties，选择他们当然是因为他们更方便。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;YAML（YAML Ain't Markup Language）是以&lt;span&gt;&lt;strong&gt;&lt;span&gt;数据为中心&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;的，所以比xml和json更适合做配置文件，我们看一个简单例子：配端口号&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;&lt;span&gt;&lt;span&gt;yaml的写法是：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;server:
  port: &lt;/span&gt;&lt;span&gt;8089&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;xml的写法是：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;server&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;port&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;8081&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;port&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;server&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;直观上我们就能看到yaml的写法更简练，xml用了很大的空间放在标签的开闭上，而yaml不需要，下面我们来细讲yaml的语法。&lt;/p&gt;
&lt;h2&gt;二、&lt;span class=&quot;md-expand&quot;&gt;YAML语法&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;yaml的基本语法是 &lt;span&gt;&lt;strong&gt;&lt;span&gt;k:(空格)v：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;表示一对键值对（空格必须有），以&lt;span&gt;&lt;strong&gt;&lt;span&gt;空格&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;的缩进来控制层级关系，只要是左对齐的一列数据，都是同一个层级的。且属性和值都是大小写敏感的。如：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;server:
  port: 8081
  path: /hello&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;我们重点看看值的写法，值的写法是指可以用哪些写法来写值，一般有：&lt;span&gt;&lt;strong&gt;字面量，对象、Map，数组&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;strong&gt;字面量&lt;/strong&gt;&lt;span&gt;：就是指普通的值（数字，字符串，布尔），这个写法就是直接k: v：方式，字符串默认不用加上单引号或者双引号，如果加了，那双引号和单引号是有区别的，区别在于是不是转义特殊字符，双引号会转义特殊字符，而单引号不会。如：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;name: &quot;yuanqinnan \n yuanyuan&quot; 输出；yuanqinnan 换行  yuanyuan
name: ‘yuanqinnan \n yuanyuan’：输出；yuanqinnan \n  yuanyuan&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;&lt;strong&gt;&lt;span&gt;对象、Map&lt;/span&gt;&lt;/strong&gt;&lt;span class=&quot;md-expand&quot;&gt;的写法也是普通的k: v 写法，在下一行来写对象的属性和值的关系。如&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;friends:
  lastName: zhangsan
  age: 20&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也可以一行完成&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
friends: {lastName: zhangsan,age: 18}
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;数组（List、Set）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;用- 值表示数组中的一个元素，如：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;pets:
 - cat
 - dog
 - pig&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;记得- 后要打空格，这也有一行写法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
pets: [cat,dog,pig]
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;三、配置文件注入&lt;/h2&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;配置文件写完，那么我们就要来使用了，下面讲配置文件值注入。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;第一种方式@&lt;span&gt;&lt;strong&gt;ConfigurationProperties&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;新建一个person类&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 将配置文件中配置的每一个属性的值，映射到这个组件中
 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定；
 *      prefix = &quot;person&quot;：配置文件中哪个下面的所有属性进行一一映射
 *
 * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能；
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Component
@ConfigurationProperties(prefix &lt;/span&gt;= &quot;person&quot;&lt;span&gt;)
@Data
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person  {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String lastName;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer age;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Boolean boss;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Date birth;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Map&amp;lt;String,Object&amp;gt;&lt;span&gt; maps;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; List&amp;lt;Object&amp;gt;&lt;span&gt; lists;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Dog dog;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里为了少些一些代码，引入lombok，增加依赖，这个不清楚的同学自行百度了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.projectlombok&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;lombok&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.18.2&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再建一个dog类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Data
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Dog {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer age;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后在配置文件中加入以下配置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;server:
  port: 8089
person:
    lastName: hello
    age: 18
    boss: false
    birth: 2017/12/12
    maps: {k1: v1,k2: 12}
    lists:
      - lisi
      - zhaoliu
    dog:
      name: 小狗
      age: 12&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里基本包含了我们需要的各种类型，直接在SpringbootLearnApplicationTests测试:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201903/1113901-20190328231238691-1013137827.png&quot; alt=&quot;&quot; width=&quot;574&quot; height=&quot;302&quot;/&gt;&lt;/p&gt;
&lt;p&gt;测试结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201903/1113901-20190328231307979-1658707279.png&quot; alt=&quot;&quot; width=&quot;570&quot; height=&quot;26&quot;/&gt;&lt;/p&gt;
&lt;p&gt;除了可以一次性注入之外，还有&lt;span class=&quot;md-expand&quot;&gt;另一种注入方式&lt;span&gt;&lt;strong&gt;&lt;span&gt;@Value&lt;/span&gt;&lt;/strong&gt; &lt;span&gt;,@Value支持字面量，${key}从环境变量、配置文件中获取值,支持#{Spel}表达式,怎么写呢？例子：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;支持${}&lt;/span&gt;
@Value(&quot;${person.lastName}&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String lastName;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;支持#{SpEL}&lt;/span&gt;
@Value(&quot;#{10*2}&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer age;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;支持字面量&lt;/span&gt;
@Value(&quot;true&quot;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;两者有以下的区别：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201903/1113901-20190328231609948-88564977.png&quot; alt=&quot;&quot; width=&quot;784&quot; height=&quot;220&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;&lt;strong&gt;&lt;span&gt;@ConfigurationProperties&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;默认从主配置文件中获取值，如果需要专门的配置文件则需要使用@&lt;span&gt;&lt;strong&gt;&lt;span&gt;PropertySource&lt;/span&gt;&lt;/strong&gt; &lt;span&gt;，写法如下：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
@PropertySource(value = {&quot;XXX&quot;})
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们应该怎么选择两种注入方式呢？&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;strong&gt;如果说，我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用@Value。&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;strong&gt;如果说，我们专门编写了一个javaBean来和配置文件进行映射，我们就直接使用@ConfigurationProperties。&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;这里还要注意Spring Boot里面没有Spring的配置文件，我们自己编写的配置文件，不能自动识别，什么意思呢？&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;如我们新建一个xml配置文件&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;beans &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;&lt;span&gt;
       xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt;
       xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;helloService&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;com.yuanqinnan.service.HelloService&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;beans&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;按照路径添加HelloService类，然后我们直接去获取bean,看看能不能取出来&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;测试方法：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Autowired
ApplicationContext ioc;
@Test
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; beanTest(){
    &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; b = ioc.containsBean(&quot;helloService&quot;&lt;span&gt;);
    System.out.println(b);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;结果是false,说明没有注入成功，这个时候我们需要使用@&lt;span&gt;&lt;strong&gt;&lt;span&gt;ImportResource&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;在启动类上加上&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
@ImportResource(locations = {&quot;classpath:beans.xml&quot;})
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样才能注入进来，因为springboot是不推荐使用xml文件而使用注解方式，我们一般这么写&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Configuration
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyAppConfig {

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将方法的返回值添加到容器中；容器中这个组件默认的id就是方法名&lt;/span&gt;
&lt;span&gt;    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; HelloService helloService2(){
        System.out.println(&lt;/span&gt;&quot;配置类@Bean给容器中添加组件了...&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HelloService();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样helloService2就注入进来了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Test
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; beanTest2(){
    &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; b = ioc.containsBean(&quot;helloService2&quot;&lt;span&gt;);
    System.out.println(b);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试结果为true。&lt;/p&gt;
&lt;h2&gt;四、多个文件&lt;span class=&quot;md-meta md-after&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;在实际开发中，我们可能会有多个配置文件，比如本地的配置，测试的配置，正式的配置，这个时候我们就可以使用，一般我们会命名为：application-{profile}.properties/yml，那我们新建2个配置文件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201903/1113901-20190328232152518-1362114359.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后在application.yml加上&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;spring:
  profiles:
    active: dev&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;这样我们可以方便的切换环境配置，那上线的时候我们想改动配置文件怎么办呢？带参数命令就可以实现&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;java -jar springboot-learn-0.0.1-SNAPSHOT.jar --spring.profiles.active=dev；&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;我们可以用多个文件来进行配置，那么就会有优先级的问题，springboot是怎么做的呢？&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件，并按照以下顺序进行扫描：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;1、根目录下:./config/&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;2、根目录下:./&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;3、类路径下:/config/&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;4、类路径下classpath:/&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;优先级由高到底，如果后面的文件有相同配置则不起作用，这些配置文件都是互补配置，我们可以将需要的配置文件分类进行写入。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;spingboot有很多自动配置类，并且为这些自动配置类提供了默认的properties，如数据库连接配置。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201903/1113901-20190328232248654-916878265.png&quot; alt=&quot;&quot; width=&quot;801&quot; height=&quot;151&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们根据这个properties，再进行相应的属性配置：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201903/1113901-20190328232319427-1673205731.png&quot; alt=&quot;&quot; width=&quot;795&quot; height=&quot;67&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;五、总结&lt;/h2&gt;
&lt;p&gt;SpringBoot启动会加载大量的自动配置类，我们看我们需要的功能有没有SpringBoot默认写好的自动配置类，我们再来看这个自动配置类中到底配置了哪些组件，（只要我们要用的组件有，我们就不需要再来配置了）给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们就可以在配置文件中指定这些属性的值。&lt;/p&gt;

&lt;p class=&quot;md-end-block md-focus&quot;&gt; &lt;/p&gt;



&lt;p class=&quot;md-end-block md-focus&quot;&gt; &lt;/p&gt;

</description>
<pubDate>Thu, 28 Mar 2019 15:27:00 +0000</pubDate>
<dc:creator>茶底世界</dc:creator>
<og:description>一、引言 虽然springboot帮我们进行了自动配置，但配置还是不可避免的，比如最简单的端口号，数据库连接。但springboot的配置一般不用xml进行配置，而是yml和properties，选择</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuanqinnan/p/10618511.html</dc:identifier>
</item>
<item>
<title>目标检测——IoU 计算 - xinet</title>
<link>http://www.cnblogs.com/q735613050/p/10618558.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/q735613050/p/10618558.html</guid>
<description>&lt;h2 id=&quot;iou-的计算&quot;&gt;Iou 的计算&lt;/h2&gt;
&lt;p&gt;我们先考虑一维的情况：令 &lt;span class=&quot;math inline&quot;&gt;\(A = [x_1,x_2], B = [y_1, y_2]\)&lt;/span&gt;，若想要 &lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt; 与 &lt;span class=&quot;math inline&quot;&gt;\(B\)&lt;/span&gt; 有交集，需要满足如下情况：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/685754/201903/685754-20190328230226115-1099323701.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;简言之，要保证 &lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(B\)&lt;/span&gt; 的最大值中最小的那个减去它们中的最小值中最大的那个即可获得公共部分，代码实现如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class Anchor:
    def __init__(self, base_size=16):
        self.base_size = base_size  # 滑动窗口的大小
        if not base_size:
            raise ValueError(&quot;Invalid base_size: {}.&quot;.format(base_size))
        self._anchor = np.array([1, 1, self.base_size, self.base_size]) - 1

    @property
    def anchor(self):
        return self._anchor

    @anchor.setter
    def anchor(self, new_anchor):
        self._anchor = new_anchor

    @property
    def w(self):
        '''
        锚框的宽度
        '''
        return self.anchor[2] - self.anchor[0] + 1

    @property
    def h(self):
        '''
        锚框的高度
        '''
        return self.anchor[3] - self.anchor[1] + 1

    @property
    def size(self):
        '''
        锚框的面积
        '''
        return self.w * self.h

    @property
    def _whctrs(self):
        &quot;&quot;&quot;
        Return x center, and y center for an anchor (window). 锚框的中心坐标
        &quot;&quot;&quot;
        x_ctr = self.anchor[0] + 0.5 * (self.w - 1)
        y_ctr = self.anchor[1] + 0.5 * (self.h - 1)
        return np.array([x_ctr, y_ctr])

    @staticmethod
    def _coordinate(aspect, ctr):
        '''
        依据宽高组合计算锚框的坐标
        '''
        k = (aspect - 1) / 2
        return np.concatenate([ctr - k, ctr + k], axis=1)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;先创建一个可以用来做运算的计算器，然后在此基础上计算二维的 IoU，即&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def iou(anchor, anchor1):
    A = Anchor()
    B = Anchor()
    A.anchor = anchor
    B.anchor = anchor1
    T = np.stack([A.anchor, B.anchor])
    xmin, ymin, xmax, ymax = np.split(T, 4, axis=1)
    w = xmax.min() - xmin.max()
    h = ymax.min() - ymin.max()
    I = w * h
    U = A.size + B.size - I
    return I / U&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面举一例子，并可视化：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/685754/201903/685754-20190328232423448-1369894650.png&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;img = np.ones((128 ,300, 3))  # 图片
anchor = [ 12.,   8., 195., 103.]
anchor1 = [ 28.,   8., 211., 103.]
iou(anchor, anchor1)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最终结果为：&lt;/p&gt;
&lt;pre class=&quot;sh&quot;&gt;
&lt;code&gt;0.8151364126804707&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 28 Mar 2019 15:26:00 +0000</pubDate>
<dc:creator>xinet</dc:creator>
<og:description>Iou 的计算 我们先考虑一维的情况：令 $A = [x_1,x_2], B = [y_1, y_2]$，若想要 $A$ 与 $B$ 有交集，需要满足如下情况： 简言之，要保证 $A$ 和 $B$ 的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/q735613050/p/10618558.html</dc:identifier>
</item>
<item>
<title>你真的知道final关键字吗？ - 农码关山北</title>
<link>http://www.cnblogs.com/dslx/p/10592120.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dslx/p/10592120.html</guid>
<description>&lt;h3&gt;&lt;span&gt;概述&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;final在英文中是最终的，不可更改的。在Java中final修饰变量，函数和类，就像这个单词的意思，一旦使用赋值之后不可更改。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;&lt;span&gt;final修饰的变量不可以被改变&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;finalTest类&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public &lt;span&gt;class&lt;span&gt; finalTest
{
    &lt;span&gt;private String test = &quot;test&quot;&lt;span&gt;;
    &lt;span&gt;//&lt;span&gt;final修饰的成员变量 第一种赋值方式
    &lt;span&gt;private &lt;span&gt;final &lt;span&gt;int a = 6&lt;span&gt;;

    &lt;span&gt;private &lt;span&gt;final &lt;span&gt;int&lt;span&gt; b;

    &lt;span&gt;private &lt;span&gt;final &lt;span&gt;int&lt;span&gt; c;

    &lt;span&gt;//&lt;span&gt;final修饰的静态成员变量 第一种赋值方式
    &lt;span&gt;private &lt;span&gt;final &lt;span&gt;static &lt;span&gt;int e = 6&lt;span&gt;;

    &lt;span&gt;private &lt;span&gt;final &lt;span&gt;static &lt;span&gt;int&lt;span&gt; f;

    &lt;span&gt;public&lt;span&gt; finalTest()
    {
        &lt;span&gt;//&lt;span&gt;final修饰的成员变量 第二种赋值方式
        b = 5&lt;span&gt;;
    }

    {
        &lt;span&gt;//&lt;span&gt;final修饰的成员变量 第三种赋值方式
        c = 5&lt;span&gt;;
    }

    &lt;span&gt;static&lt;span&gt;
    {
        &lt;span&gt;//&lt;span&gt;final修饰的静态成员变量 第二种赋值方式
        f = 6&lt;span&gt;;
    }

    &lt;span&gt;public &lt;span&gt;void test(&lt;span&gt;final &lt;span&gt;int&lt;span&gt; g)
    {
        &lt;span&gt;//&lt;span&gt;final 修饰的局部变量第一种方式
        &lt;span&gt;final &lt;span&gt;int d = 10&lt;span&gt;;

        &lt;span&gt;//&lt;span&gt;final 修饰的局部变量第二种赋值方式
        &lt;span&gt;final &lt;span&gt;int&lt;span&gt; h;
        h = 11&lt;span&gt;;

        &lt;span&gt;//&lt;span&gt;调用此函数的已经进行赋值，再次赋值会报错
        &lt;span&gt;//&lt;span&gt;g = 66;
&lt;span&gt;    }
    @Override
    &lt;span&gt;public&lt;span&gt; String toString()
    {
        &lt;span&gt;return&lt;span&gt; test;
    }

    &lt;span&gt;public &lt;span&gt;static &lt;span&gt;void&lt;span&gt; main(String[] args)
    {
        &lt;span&gt;final finalTest finalTest = &lt;span&gt;new&lt;span&gt; finalTest();
        &lt;span&gt;//&lt;span&gt;final修饰，无法被改变
        &lt;span&gt;//&lt;span&gt;finalTest = null;
&lt;span&gt;        System.out.println(finalTest);
        finalTest.test = &quot;test2&quot;&lt;span&gt;;
        System.out.println(finalTest);
    }
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;输出&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;test
test2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;final修饰基本数据类型，不能对基本数据类型重新赋值，基本数据类型变量不能被改变。但final修饰引用类型变量，&lt;strong&gt;不变的仅仅是他的一个引用&lt;/strong&gt;，只要引用地址不变，他里面的成员变量是&lt;strong&gt;可变&lt;/strong&gt;的。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;&lt;span&gt;final修饰的函数不可以被重写&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;finalTest类&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; finalTest
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test()
    {
        System.out.println(&lt;/span&gt;&quot;父类&quot;&lt;span&gt;);
    }
}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; finalTestChild &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; finalTest
{
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    public void test()
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;final修饰的函数可以被重载&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; test(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; a)
    {
        System.out.println(&lt;/span&gt;&quot;重载&quot;&lt;span&gt;);
    }
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;父类被final修饰的函数是无法被子类重写的，但final修饰的函数可以被重载。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;&lt;span&gt;final修饰的类不可以被继承&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;最典型是的例子是Java的String类，打开String类发现String类是被final所修饰。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;finalTest类&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1333075/201903/1333075-20190326164312717-1478243770.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;继承一个被final修饰的父类，就会报错。很明显Java设计人员不希望我们对String类进行修改，个人理解是因为String类过于强大，Java的设计人员出于安全考虑，不希望它有子类。 因为这样可能危及到系统安全。所以final类中所有的类都隐式指定为是final的，无法覆盖他们，我们只能使用他规定的函数。所以当我们希望自己的类不被人继承时，就可以指定为final。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;final的作用&lt;br/&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;ol readability=&quot;-2&quot;&gt;&lt;li&gt;&lt;span&gt;效率，JVM和Java都会缓存final变量并对函数，和类进行优化。&lt;/span&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;设计和安全，&lt;span&gt;上&quot;锁&quot;，不希望自己的类和函数被人随意改变。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;&lt;a href=&quot;https://www.cnblogs.com/noteless/p/10416678.html#0&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;&lt;span&gt;final的安全发布&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;创建一个对象，大致可以分为三个步骤&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;分配内存空间&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;将引用指向分配的内存空间&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;调用构造函数来初始化对象&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;这三个步骤不是原子的，执行到第二部，没进行初始化，此时如果这个对象能被当前范围之外的代码所使用，因为这时对象已经不是null了，被其他代码访问，会得到一个错误的结果。这就是&lt;strong&gt;不安全的发布。&lt;/strong&gt;所谓安全发布，简单理解就是对象的创建能够保障在被别人使用前，完成数据的构造设置，或者说一个对象使用时，已经进行初始化。但是Java对此并没有进行保障，需要自己进行保障设置，如锁机制等。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;对于final，当创建一个对象时，使用final关键字能够使得另一个线程不会访问到处于&quot;部分创建&quot;的对象。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;当构造函数退出时，final字段的值保证对访问构造对象的其他线程是可见的。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;一旦对象引用对其他线程可见，则其final成员也必须正确赋值。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;所以借助final，就如同是你对对象的创建访问加锁了一样，天然保障了对象的&lt;strong&gt;安全发布&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;许多并发错误都是没理解共享对象的既定规则，当发布一个对象时，必须明确说明对象的访问方式。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 28 Mar 2019 15:13:00 +0000</pubDate>
<dc:creator>农码关山北</dc:creator>
<og:description>概述 final在英文中是最终的，不可更改的。在Java中final修饰变量，函数和类，就像这个单词的意思，一旦使用赋值之后不可更改。 final修饰的变量不可以被改变 finalTest类 输出 f</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dslx/p/10592120.html</dc:identifier>
</item>
<item>
<title>python脚本实现ipv6的ddns功能 - 李欢欢</title>
<link>http://www.cnblogs.com/lihuanhuan/p/10618494.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lihuanhuan/p/10618494.html</guid>
<description>&lt;p&gt;话说在国家的推动下，ipv6地址已经开始优先在三大运营商推广，我自己家用的就是联通宽带100M光纤入户。有一次，不经意间发现，我们的光猫竟然获取到了ipv6地址，于是我开始浮想联翩。&lt;/p&gt;
&lt;p&gt;说干就干，我先是把光猫改成桥接模式，停止拨号，光猫的lan口连接华为路由器的wan口，再通过华为路由器拨号。&lt;/p&gt;
&lt;p&gt;奇迹出现了，我们家的华为路由器包括华为路由器连接的局域网设备，竟然都获取到了ipv6地址。&lt;strong&gt;最可怕的是，每个设备都获取到了一个公网的ipv6地址。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/35490/201903/35490-20190328230130081-753140786.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/35490/201903/35490-20190328230218182-1871108190.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/35490/201903/35490-20190328230246209-1196492079.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;虽然，这些设备获取到的ipv6地址，在哪都可以访问。但是，过1天问题又来了，这个ipv6地址竟然每天自动更新一次。&lt;/p&gt;
&lt;p&gt;为了让我们家的设备，可以有永久不变的地址，于是我打起了aliyun 域名的主意，因为阿里云域名支持AAAA记录的解析，就是支持ipv6地址解析到域名。&lt;/p&gt;
&lt;p&gt;我自己就花费一周时间，自己用python写出了一个ddns脚本，我已经放在了这里 https://gitlab.com/byygyy/ddns_ipv6.git&lt;/p&gt;
&lt;p&gt;总体的思路就是，先调用ailiyun的域名接口，获得一个record id，再利用这个record id再持续地更新域名地AAAA记录。&lt;/p&gt;
&lt;p&gt;最后，你就可以时刻访问你家地设备了。我已经写了一篇完整的文章，”利用ipv6技术，废旧笔记本变成server“：&lt;a href=&quot;https://www.cnblogs.com/lihuanhuan/p/10617431.html&quot;&gt;https://www.cnblogs.com/lihuanhuan/p/10617431.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;如果我的文章对您有帮助，你可以支持我的原创，感谢您花时间阅读。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/35490/201903/35490-20190328231018043-336948537.jpg&quot; alt=&quot;&quot; width=&quot;315&quot; height=&quot;420&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 28 Mar 2019 15:12:00 +0000</pubDate>
<dc:creator>李欢欢</dc:creator>
<og:description>话说在国家的推动下，ipv6地址已经开始优先在三大运营商推广，我自己家用的就是联通宽带100M光纤入户。有一次，不经意间发现，我们的光猫竟然获取到了ipv6地址，于是我开始浮想联翩。 说干就干，我先是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lihuanhuan/p/10618494.html</dc:identifier>
</item>
</channel>
</rss>