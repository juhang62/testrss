<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>如何管理团队知识？快速搭建一套管理工具 - 悟空聊架构</title>
<link>http://www.cnblogs.com/jackson0714/p/birddoc.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jackson0714/p/birddoc.html</guid>
<description>&lt;p&gt;&lt;span&gt;阅读全文需要15分钟，动手实践需要30分钟，请收藏点赞后再读。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;1.1 用户故事&lt;/h2&gt;
&lt;p&gt;我是一名开发人员，经常会迷失在寻找团队内的各种开发文档中，我期望有一个网站，所有文档都集中在这个网站中，我可以进行根据目录浏览，最好能支持搜索，而且我贡献的文档别人不知道，会再跑过来问我。&lt;/p&gt;
&lt;h2&gt;1.2 用户痛点&lt;/h2&gt;
&lt;p&gt;（1）文档存放位置杂乱&lt;/p&gt;
&lt;p&gt;（2）搜索文档困难&lt;/p&gt;
&lt;p&gt;（3）文档没有目录&lt;/p&gt;
&lt;p&gt;（4）文档普及度不高&lt;/p&gt;
&lt;h2&gt;1.3 产品团队深挖用户痛点&lt;/h2&gt;
&lt;p&gt;根据用户的痛点，产品团队设计了一个模型&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/414640/201904/414640-20190430110754977-193344140.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（1）左侧具有菜单导航栏&lt;/p&gt;
&lt;p&gt;（2）顶部具有搜索栏&lt;/p&gt;
&lt;p&gt;（3）可以通过网站的形式访问，方便用户访问&lt;/p&gt;

&lt;p&gt;这种团队管理工具有很多，很多大厂出了软件专门来做知识管理：&lt;/p&gt;
&lt;p&gt;比如xx笔记企业版&lt;/p&gt;
&lt;p&gt;这些大厂的软件必须购买企业版才能在团队内共享，且笔记很杂，不利于管理。而且根本就没有解决用户痛点。&lt;/p&gt;
&lt;p&gt;最后选择了vuePress来做，它的好处是可以用markdown语言来做笔记，让你专注于写作，还可以将笔记提交到gitlab进行管理，还有变更记录，而且高度支持自定义主题等等。&lt;/p&gt;
&lt;p&gt;于是我们选择了vuepress。官网链接：&lt;a href=&quot;https://v0.vuepress.vuejs.org/zh/&quot;&gt;https://v0.vuepress.vuejs.org/zh/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;官网也是用VuePress做的哦。但这个开源工具不是下载下来就可以直接用的，还有些开发工作需要做。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/414640/201904/414640-20190430112008454-953549886.png&quot; alt=&quot;&quot; width=&quot;682&quot; height=&quot;396&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外有人提出怎么不用GitBook ？&lt;/p&gt;
&lt;p&gt; GitBook 最大的问题在于当文件很多时，每次编辑后的重新加载时间长得令人无法忍受。它的默认主题导航结构也比较有限制性，并且，主题系统也不是 Vue 驱动的。GitBook 背后的团队如今也更专注于将其打造为一个商业产品而不是开源工具。 -- 来源vuepress&lt;/p&gt;

&lt;h2&gt;3.1 方案一 按照官网搭建&lt;/h2&gt;
&lt;h3 id=&quot;快速上手&quot;&gt;快速上手&lt;/h3&gt;
&lt;div class=&quot;warning custom-block&quot; readability=&quot;7&quot;&gt;
&lt;p class=&quot;custom-block-title&quot;&gt;注意&lt;/p&gt;
&lt;p&gt;请确保你的 Node.js 版本 &amp;gt;= 8。&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id=&quot;全局安装&quot;&gt;全局安装&lt;/h3&gt;
&lt;p&gt;如果你只是想尝试一下 VuePress，你可以全局安装它：&lt;/p&gt;

&lt;h3 id=&quot;现有项目&quot;&gt;现有项目&lt;/h3&gt;
&lt;p&gt;如果你想在一个现有项目中使用 VuePress，同时想要在该项目中管理文档，则应该将 VuePress 安装为本地依赖。作为本地依赖安装让你可以使用持续集成工具，或者一些其他服务（比如 Netlify）来帮助你在每次提交代码时自动部署。&lt;/p&gt;

&lt;div class=&quot;warning custom-block&quot; readability=&quot;7.8139534883721&quot;&gt;
&lt;p class=&quot;custom-block-title&quot;&gt;WARNING&lt;/p&gt;
&lt;p&gt;如果你的现有项目依赖了 webpack 3.x，推荐使用 &lt;a href=&quot;https://yarnpkg.com/en/&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Yarn&lt;/a&gt; 而不是 npm 来安装 VuePress。因为在这种情形下，npm 会生成错误的依赖树。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;接着，在 &lt;code&gt;package.json&lt;/code&gt; 里加一些脚本:&lt;/p&gt;

&lt;p&gt;然后就可以开始写作了:&lt;/p&gt;

&lt;p&gt;要生成静态的 HTML 文件，运行：&lt;/p&gt;

&lt;p&gt;默认情况下，文件将会被生成在 &lt;code&gt;.vuepress/dist&lt;/code&gt;，当然，你也可以通过 &lt;code&gt;.vuepress/config.js&lt;/code&gt; 中的 &lt;code&gt;dest&lt;/code&gt; 字段来修改，生成的文件可以部署到任意的静态文件服务器上，参考 &lt;a href=&quot;https://v0.vuepress.vuejs.org/zh/guide/deploy.html&quot;&gt;部署&lt;/a&gt; 来了解更多。&lt;/p&gt;
&lt;p&gt;这些步骤执行完后，只能看到搜索栏和标题，是没有菜单的，需要自己创建菜单。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/414640/201904/414640-20190430124411768-2063119041.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;3.2 方案二、用我的demo搭建&lt;/h2&gt;
&lt;h3&gt;3.2.2 如何创建菜单&lt;/h3&gt;
&lt;p&gt;上面只有搜索功能，没有菜单功能。修改config文件定义菜单，然后加上菜单对应的文件夹。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/414640/201905/414640-20190501175753583-1236259463.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;3.2.2 下载demo&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;我已经有一份做好的demo供大家使用&lt;/span&gt;，该demo的功能：展示接口文档，供第三方使用。功能如下图。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;github路径：&lt;a href=&quot;https://github.com/Jackson0714/BirdDoc&quot;&gt;https://github.com/Jackson0714/BirdDoc&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/414640/201905/414640-20190501175832163-277838830.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;3.3.3 如何编写文档&lt;/h3&gt;
&lt;p&gt;比如想增加一个删除优惠券的接口，可以在coupon目录下面创建一个delete.md文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/414640/201905/414640-20190501175245381-25554123.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后在config.js 文件配置菜单&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/414640/201905/414640-20190501175315250-996876631.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;如果已经安装了node.js和npm，则在根目录执行这条命令就可以运行起来了&lt;/p&gt;

&lt;p&gt; 这条命令其实就是执行&lt;span&gt;npm vuepress dev&lt;/span&gt;来进行实时编译&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/414640/201904/414640-20190430132912975-2119060846.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 编译完成后，会提示监听8080端口，可以打开http://localhost:8080查看效果&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/414640/201905/414640-20190501175944292-1793831289.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h2&gt;5.1 打包成静态文件&lt;/h2&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
npm run build
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;5.2 配置nginx和hosts&lt;/h2&gt;
&lt;p&gt;我是部署到ubuntu上的，需要创建nginx 配置文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
// 创建nginx配置文件&lt;br/&gt;sudo vim /etc/nginx/conf.d/interface.conf
// interface.conf
server {
    listen       8002;
    server_name  birddoc.com;

    location / {
        root   /home/user/project/github/BirdDoc/public;
        index  index.html index.htm;
        try_files $uri $uri/ =404;
    }
}
// 重启nginx服务
sudo service nginx restart
// 配置hosts文件，映射网站域名
sudo vim /etc/hosts
localhost birddoc.com
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;5.3 打开站点&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://birddoc.com:8002/&quot;&gt;http://birddoc.com:8002/&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;6.1 拉取代码&lt;/h2&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
git clone git@github.com:Jackson0714/BirdDoc.git
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;6.2 打包镜像文件&lt;/h2&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37.5&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot; readability=&quot;8&quot;&gt;
npm run build&lt;p&gt;&amp;gt; kidsplace-interface@1.0.0 build /home/workspace/BirdDoc/BirdDoc
&amp;gt; vuepress build


 WAIT  Extracting site metadata...
[9:59:39 AM] Compiling Client
[9:59:39 AM] Compiling Server
[9:59:45 AM] Compiled Server in 6s
[9:59:51 AM] Compiled Client in 13s
 WAIT  Rendering static HTML...

 DONE  Success! Generated static files in public.&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;生成静态文件，路径为 /home/workspace/BirdDoc/BirdDoc/public&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/414640/201905/414640-20190501100138464-2046059715.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;6.3 添加域名解析&lt;/h2&gt;
&lt;p&gt;在云服务器控制台 添加 birddoc.jay.club的域名解析，网站jay.club是我自己备案的网站。&lt;/p&gt;
&lt;p&gt;等待10分钟就生效了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/414640/201905/414640-20190501094706941-1115329334.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;6.4 修改nginx配置文件&lt;/h2&gt;
&lt;p&gt;监听通过birddoc.jay.club发来的请求，路由到静态文件目录 /home/workspace/BirdDoc/BirdDoc/public&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
server {
    listen       80;
    &lt;span&gt;server_name  birddoc.jayh.club;&lt;/span&gt;

    location / {
        root   /home/workspace/BirdDoc/BirdDoc/public;
        index  index.html index.htm;
        try_files $uri $uri/ =404;
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt; 6.5 打开网站&lt;/h2&gt;
&lt;p&gt;http://birddoc.jayh.club&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/414640/201905/414640-20190501100943947-1755771389.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;（临时网站，后面可能会停掉。）&lt;/p&gt;
&lt;h2&gt; 6.6 如何用jenkins部署&lt;/h2&gt;
&lt;p&gt;参考我之前写的文章：&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/jackson0714/p/deploy1.html&quot;&gt;1. 容器化部署一套云服务 第一讲 Jenkins（Docker + Jenkins + Yii2 + 云服务器)）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最后部署成功，控制台输出如下图：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/414640/201905/414640-20190501180024833-827294838.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;查看public目录下这些文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/414640/201905/414640-20190501164722569-382900739.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt; 6.7 如何自动部署&lt;/h2&gt;
&lt;p&gt;自动部署的方式很多&lt;/p&gt;
&lt;h3&gt;6.7.1 Jenkins 定时构建&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/414640/201905/414640-20190501170851088-1240438184.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;6.7.2 Crontab定时构建&lt;/h3&gt;
&lt;p&gt;注意：该脚本还有些编译问题未解决，仅供参考。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
/home/job/build.sh

#!/bin/bash
cd /home/workspace/BirdDoc/BirdDoc
/usr/bin/git pull
/usr/local/n/versions/node/10.15.3/bin/npm run build
currentTime=$(date)
echo $currentTime &amp;gt;&amp;gt; /home/job/build.log

crontab -e
* * * * * sleep 0; /home/job/build.sh &amp;gt;&amp;gt; /home/job/cron.log 2&amp;gt;&amp;amp;1 &amp;amp;
* * * * * sleep 5; /home/job/build.sh &amp;gt;&amp;gt; /home/job/cron.log 2&amp;gt;&amp;amp;1 &amp;amp;
* * * * * sleep 10; /home/job/build.sh &amp;gt;&amp;gt; /home/job/cron.log 2&amp;gt;&amp;amp;1 &amp;amp;
* * * * * sleep 15; /home/job/build.sh &amp;gt;&amp;gt; /home/job/cron.log 2&amp;gt;&amp;amp;1 &amp;amp;
* * * * * sleep 20; /home/job/build.sh &amp;gt;&amp;gt; /home/job/cron.log 2&amp;gt;&amp;amp;1 &amp;amp;
* * * * * sleep 25; /home/job/build.sh &amp;gt;&amp;gt; /home/job/cron.log 2&amp;gt;&amp;amp;1 &amp;amp;
* * * * * sleep 30; /home/job/build.sh &amp;gt;&amp;gt; /home/job/cron.log 2&amp;gt;&amp;amp;1 &amp;amp;
* * * * * sleep 35; /home/job/build.sh &amp;gt;&amp;gt; /home/job/cron.log 2&amp;gt;&amp;amp;1 &amp;amp;
* * * * * sleep 40; /home/job/build.sh &amp;gt;&amp;gt; /home/job/cron.log 2&amp;gt;&amp;amp;1 &amp;amp;
* * * * * sleep 45; /home/job/build.sh &amp;gt;&amp;gt; /home/job/cron.log 2&amp;gt;&amp;amp;1 &amp;amp;
* * * * * sleep 55; /home/job/build.sh &amp;gt;&amp;gt; /home/job/cron.log 2&amp;gt;&amp;amp;1 &amp;amp;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　遇到的问题：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('aa50e6a6-972c-4b39-8878-295e0f3be6f8')&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_aa50e6a6-972c-4b39-8878-295e0f3be6f8&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_aa50e6a6-972c-4b39-8878-295e0f3be6f8&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('aa50e6a6-972c-4b39-8878-295e0f3be6f8',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_aa50e6a6-972c-4b39-8878-295e0f3be6f8&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; SyntaxError: Block-scoped declarations (let, &lt;span&gt;const&lt;/span&gt;, function, &lt;span&gt;class&lt;/span&gt;&lt;span&gt;) not yet supported outside strict mode
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     at exports.runInThisContext (vm.js:&lt;span&gt;53&lt;/span&gt;:&lt;span&gt;16&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     at Module._compile (module.js:&lt;span&gt;374&lt;/span&gt;:&lt;span&gt;25&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     at Object.Module._extensions..js (module.js:&lt;span&gt;417&lt;/span&gt;:&lt;span&gt;10&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     at Module.load (module.js:&lt;span&gt;344&lt;/span&gt;:&lt;span&gt;32&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     at Function.Module._load (module.js:&lt;span&gt;301&lt;/span&gt;:&lt;span&gt;12&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     at Function.Module.runMain (module.js:&lt;span&gt;442&lt;/span&gt;:&lt;span&gt;10&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     at startup (node.js:&lt;span&gt;136&lt;/span&gt;:&lt;span&gt;18&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     at node.js:&lt;span&gt;966&lt;/span&gt;:&lt;span&gt;3&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; Already up-to-&lt;span&gt;date.
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; /usr/local/n/versions/node/&lt;span&gt;10.15&lt;/span&gt;.&lt;span&gt;3&lt;/span&gt;/lib/node_modules/npm/bin/npm-cli.js:&lt;span&gt;85&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;       let notifier = require(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;update-notifier&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)({pkg})
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;       ^^^
&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; SyntaxError: Block-scoped declarations (let, &lt;span&gt;const&lt;/span&gt;, function, &lt;span&gt;class&lt;/span&gt;&lt;span&gt;) not yet supported outside strict mode
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     at exports.runInThisContext (vm.js:&lt;span&gt;53&lt;/span&gt;:&lt;span&gt;16&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     at Module._compile (module.js:&lt;span&gt;374&lt;/span&gt;:&lt;span&gt;25&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     at Object.Module._extensions..js (module.js:&lt;span&gt;417&lt;/span&gt;:&lt;span&gt;10&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     at Module.load (module.js:&lt;span&gt;344&lt;/span&gt;:&lt;span&gt;32&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     at Function.Module._load (module.js:&lt;span&gt;301&lt;/span&gt;:&lt;span&gt;12&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     at Function.Module.runMain (module.js:&lt;span&gt;442&lt;/span&gt;:&lt;span&gt;10&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     at startup (node.js:&lt;span&gt;136&lt;/span&gt;:&lt;span&gt;18&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     at node.js:&lt;span&gt;966&lt;/span&gt;:&lt;span&gt;3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;6.7.3 Jenkins通过git提交代码触发构建&lt;/h3&gt;
&lt;p&gt;我配置了GitHub hook trigger for GITScm polling，但还是没有自动触发。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/414640/201905/414640-20190501173834985-340230510.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;6.8 如何用docker跑起来&lt;/h3&gt;
&lt;p&gt;后续再用docker run起来。&lt;/p&gt;

&lt;div id=&quot;MySignature&quot; readability=&quot;9.1883614088821&quot;&gt;
&lt;p&gt;&lt;br/&gt;作　　者：悟空聊架构 &lt;br/&gt;出　　处：&lt;a href=&quot;http://www.cnblogs.com/jackson0714/&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/jackson0714/&lt;/a&gt;&lt;br/&gt;关于作者：专注于移动开发。如有问题或建议，请多多赐教！&lt;br/&gt;版权声明：本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接。&lt;br/&gt;特此声明：所有评论和私信都会在第一时间回复。也欢迎园子的大大们指正错误，共同进步。或者&lt;a href=&quot;http://msg.cnblogs.com/msg/send/jackson0714&quot;&gt;直接私信&lt;/a&gt;我&lt;br/&gt;声援博主：如果您觉得文章对您有帮助，可以点击文章右下角&lt;strong&gt;&lt;span&gt;【&lt;a id=&quot;post-up&quot; onclick=&quot;votePost(5111347,'Digg')&quot; href=&quot;javascript:void(0);&quot;&gt;推荐&lt;/a&gt;】&lt;/span&gt;&lt;/strong&gt;一下。您的鼓励是作者坚持原创和持续写作的最大动力！ &lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/414640/201905/414640-20190501174331917-43146210.png&quot; alt=&quot;&quot; width=&quot;358&quot; height=&quot;358&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;悟空聊架构 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;关注我，带你每天进步一点点！&lt;/p&gt;
&lt;p&gt;还有111本书籍赠送~~&lt;/p&gt;

</description>
<pubDate>Sat, 04 May 2019 15:30:00 +0000</pubDate>
<dc:creator>悟空聊架构</dc:creator>
<og:description>阅读全文需要15分钟，动手实践需要30分钟，请收藏点赞后再读。 一、用互联网思维来看知识管理工具 1.1 用户故事 我是一名开发人员，经常会迷失在寻找团队内的各种开发文档中，我期望有一个网站，所有文档</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jackson0714/p/birddoc.html</dc:identifier>
</item>
<item>
<title>Docker环境下的前后端分离项目部署与运维（四）Linux系统构成和基本操作 - 进击的辣条</title>
<link>http://www.cnblogs.com/wyt007/p/10810389.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wyt007/p/10810389.html</guid>
<description>&lt;pre&gt;
--&lt;span&gt;查询已经开放的端口
firewall&lt;/span&gt;-cmd --permanent --list-&lt;span&gt;ports
&lt;/span&gt;--开放8080-&lt;span&gt;8085tcp端口
firewall&lt;/span&gt;-cmd --permanent --add-port=&lt;span&gt;8080&lt;/span&gt;-&lt;span&gt;8085&lt;/span&gt;/&lt;span&gt;tcp
&lt;/span&gt;--&lt;span&gt;重新加载
firewall&lt;/span&gt;-cmd --&lt;span&gt;reload
&lt;/span&gt;--关闭8080-&lt;span&gt;8085tcp端口
firewall&lt;/span&gt;-cmd --permanent --remove-port=&lt;span&gt;8080&lt;/span&gt;-&lt;span&gt;8085&lt;/span&gt;/&lt;span&gt;tcp
&lt;/span&gt;--&lt;span&gt;查询开放的端口服务
firewall&lt;/span&gt;-cmd --permanent --list-services
&lt;/pre&gt;</description>
<pubDate>Sat, 04 May 2019 15:20:00 +0000</pubDate>
<dc:creator>进击的辣条</dc:creator>
<og:description>Linux目录结构 Linux常用命令 ls：列出目录内容 mkdir &lt;name&gt;：创建文件夹 touch &lt;name&gt;：创建文件 cp &lt;source&gt; &lt;</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wyt007/p/10810389.html</dc:identifier>
</item>
<item>
<title>TensorFlow中的显存管理器——BFC Allocator - DeepLearningStack</title>
<link>http://www.cnblogs.com/deep-learning-stacks/p/10741859.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/deep-learning-stacks/p/10741859.html</guid>
<description>&lt;p&gt;作者：&lt;a href=&quot;https://www.cnblogs.com/deep-learning-stacks&quot; target=&quot;_blank&quot;&gt;DeepLearningStack&lt;/a&gt;，阿里巴巴算法工程师，开源TensorFlow Contributor]&lt;/p&gt;
&lt;p&gt;使用GPU训练时，一次训练任务无论是模型参数还是中间结果都需要占用大量显存。为了避免每次训练重新开辟显存带来计算之外的开销，一般框架的做法是在真正的训练任务开始前，将每个节点的输入和输出，以及模型参数的shape计算出来并全局开辟一次，例如Caffe就是这种做法。随着深度学习模型的发展和迭代，不仅模型训练的数据shape可能发生变化，就连模型本身在训练过程中也可能发生变化，那么按照固定shape一次开辟显存的做法就不能满足需求了。为此，TensorFlow重新设计了较为灵活的显存管理机制，它使用了名为BFC的分配算法，并通过BFC Allocator为每个Tensor分配满足需求的显存。本节我们将一起窥探BFC Allocator的设计思想。&lt;/p&gt;

&lt;h2&gt;为Tensor分配存储区的时机&lt;/h2&gt;
&lt;p&gt;在进入主题之前，让我们先思考一个问题：TensorFlow中的Tensor究竟是何时拿到所需存储区的呢？&lt;strong&gt;答案是在Tensor对象被创建时就立即进行分配。&lt;/strong&gt;在TensorFlow的一轮训练结束后，所有的Tensor都已经被释放，下一轮计算开始后会按照需求重新创建Tensor，并为其分配新的存储空间。下面的代码片段中我们可以看到Tensor创建时，使用Allocator分配存储区的代码段。&lt;/p&gt;
&lt;p&gt;在创建Tensor对象时需要传入一个Allocator，这个Allocator可以是任何实现类，在GPU上使用的就是BFCAllocator。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; Tensor::Tensor(Allocator* a, DataType type, &lt;span&gt;const&lt;/span&gt; TensorShape&amp;amp;&lt;span&gt; shape)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    : shape_(shape), buf_(nullptr) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;  set_dtype(type);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;  CHECK_NOTNULL(a);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; (shape_.num_elements() &amp;gt; &lt;span&gt;0&lt;/span&gt; || a-&amp;gt;&lt;span&gt;ShouldAllocateEmptyTensors()) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     CASES(type, buf_ = &lt;span&gt;new&lt;/span&gt; Buffer&amp;lt;T&amp;gt;&lt;span&gt;(a, shape.num_elements()));
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; (buf_ != nullptr &amp;amp;&amp;amp; buf_-&amp;gt;data() != nullptr &amp;amp;&amp;amp;&lt;span&gt; LogMemory::IsEnabled()) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     LogMemory::RecordTensorAllocation(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Unknown&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, LogMemory::UNKNOWN_STEP_ID,
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                                       *&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面代码的第6行创建了Buffer对象，它就是Tensor对象的实际存储区，让我们看看其构造函数的实现内容。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; emplate &amp;lt;typename T&amp;gt;
&lt;span&gt;2&lt;/span&gt; Buffer&amp;lt;T&amp;gt;::Buffer(Allocator*&lt;span&gt; a, int64 n,
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;                   &lt;span&gt;const&lt;/span&gt; AllocationAttributes&amp;amp;&lt;span&gt; allocation_attr)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     : BufferBase(a, a-&amp;gt;Allocate&amp;lt;T&amp;gt;(n, allocation_attr)), elem_(n) {}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的代码段重点在于第4行，因为在此处调用了Allocate函数，此时Buffer真正获得了一片实际的存储区。这已经能够说明存储区分配的时机是在一个Tensor对象被创建时立即发生的。&lt;/p&gt;
&lt;h2&gt;遇到的问题——显存分配与回收的性能需求&lt;/h2&gt;
&lt;p&gt;Tensor在每次创建时会得到存储区域，而每一轮训练都要重新创建新的Tensor，那么这里面临的一个问题：如此频繁的分配和回收存储区，如何才能做的高效？试想对于GPU来说，如果Allocate函数直接封装CUDA中昂贵的cudaMalloc函数，当Tensor被释放时直接调用cudaFree函数，那么训练速度将会因为这些overhead大打折扣。&lt;/p&gt;
&lt;h2&gt;解决问题的基本思路——存储池&lt;/h2&gt;
&lt;p&gt;如果你对操作系统这门课比较熟悉，那么应该很容易想到解决办法：将显存按照不同的大小一次性开辟出来，并组成存储池，每次调用Allocate函数时从存储池中获取，Tensor回收时将显存重新挂到存储池中。这样做确实可以满足性能需求，但是需要为此设计一个相对复杂的存储管理器。BFC Allocator就是TensorFlow中管理GPU显存的存储管理器。&lt;/p&gt;
&lt;p&gt;好了，需求和背景都已经了解了，接下来可以进入正题了，让我们先从原理开始说起。&lt;/p&gt;

&lt;p&gt;BFC的全称是Best-Fit with Coalescing。从TensorFlow源码注释中得知，BFC算法并非TensorFlow完全原创，而是dlmalloc的一个简单实现版本。dlmalloc是一款优秀的存储分配器，它以Doug Lea的名字命名，&lt;a href=&quot;http://g.oswego.edu/dl/html/malloc.html&quot; target=&quot;_blank&quot;&gt;这个站点&lt;/a&gt;包含了dlmalloc的详细说明，有兴趣的同学可以去看一看。之所以在TensorFlow中引入一个简单版本的dlmalloc算法，是因为该算法可以非常高效的按需分配和回收存储区，并尽可能减少存储碎片。&lt;/p&gt;

&lt;p&gt;核心在于将存储区划分成块，并挂入存储池中进行管理。将存储区划分成存储块时要满足以下要求。&lt;/p&gt;
&lt;p&gt;1. 块内地址是连续地址&lt;/p&gt;
&lt;p&gt;2. 存储池中的块要以每个块基地址升序排列，并组织成双向链表&lt;/p&gt;
&lt;p&gt;3. 高地址块的size大于低地址块的size&lt;/p&gt;
&lt;p&gt;TensorFlow将存储块以及相应的块信息抽象为一种叫做Chunk的数据结构。&lt;/p&gt;
&lt;h2&gt;核心数据结构&lt;/h2&gt;
&lt;h3&gt;Chunk&lt;/h3&gt;
&lt;p&gt;Chunk是BFC最核心的数据结构之一，在TensorFlow源码中是以struct来描述的。具体来说，一个Chunk代表一段连续的存储空间，BFC要求各个Chunk要按照基地址升序排列并组织成双向链表，下图展示了Chunk的结构以及Chunk之间的连接关系。初始时，每个Chunk都有自己的size，并且这些size都是以256字节为模。应当注意，&lt;strong&gt;每个Chunk或者完全被标记为使用，或者完全标记为空闲，不存在该Chunk内只有部分空间被使用的情况&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1437153/201904/1437153-20190420214100952-654999029.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;prev，next：这两个变量起到指针作用，分别指向前驱和后继Chunk。因为在BFC Allocator模块中多个chunk都被放入了vector中，所以这两个指针实际上就是前驱和后继的index&lt;/p&gt;
&lt;p&gt;ptr：该Chunk的起始存储地址，或者叫基地址&lt;/p&gt;
&lt;p&gt;size：该Chunk描述存储区的&lt;strong&gt;实际总大小&lt;/strong&gt;，每个Chunk的size是不同的，但都以256字节为模&lt;/p&gt;
&lt;p&gt;requested_size：该Chunk描述存储区的&lt;strong&gt;使用大小，&lt;/strong&gt;代表了用户请求使用的大小&lt;strong&gt;，&lt;/strong&gt;它一定小于等于size&lt;strong&gt;。&lt;/strong&gt;因为Chunk不能被部分使用，所以即使用户实际只使用requested_size，那么也只能将整个大小为size的Chunk全部分配出去，显然这可能会造成一些碎片的浪费&lt;/p&gt;
&lt;p&gt;allocation_id：该值如果不为0，则代表已经被标记为使用，反之则是空闲&lt;/p&gt;
&lt;p&gt;bin_num：代表该Chunk所在Bin的Index。Bin是另一个核心数据结构，下面将会做详细介绍&lt;/p&gt;
&lt;h3&gt;Bin&lt;/h3&gt;
&lt;p&gt;如果我们想查询某一块符合条件的空闲Chunk并取出，那么只能对双向链表做遍历，显然这个效率不是很高。为了加速查询某块Chunk的速度，可以在创建Chunk链表时按一定顺序排列，并将整个有序链表在逻辑上切分成多个段，为每个段记录所包含的Chunk的范围，这种结构就是Bin，它相当于一种索引。因此，Bin结构是为了方便Chunk的查询而出现的。在BFC Allocator中，每个段中Chunk的顺序是按照size和基地址升序排序的，每个Bin都设有自己的bin_size，该bin_size表示该段包含的最小Chunk的size。这样一来，用户端就可以根据所需要申请的Memory大小直接找到对应的Bin，然后在该Bin中遍历寻找适合的Chunk。为了能够根据bin_size直接定位到Bin，规定bin_size与bin_num的大小关系为：bin_size=256 * 2&lt;sup&gt;bin_num&lt;/sup&gt;。用户在申请Memory时，会将实际大小映射到最适合的bin_size上，然后再根据bin_size与bin_num的关系找到对应的Bin，进而在该段中遍历搜索。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1437153/201905/1437153-20190504144033445-910888917.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Bin中Chunk的是通过Set组织的，为了能在Set中体现双向链表的逻辑，只需要让Chunk在Set中按照规则升序排列，并修正前驱后继指针即可。指定Chunk顺序的Comparator代码段定义在Bin结构中，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Sort first by size and then use pointer address as a tie breaker.&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; &lt;span&gt;operator&lt;/span&gt;()(&lt;span&gt;const&lt;/span&gt;&lt;span&gt; ChunkHandle ha,
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;                 &lt;span&gt;const&lt;/span&gt; ChunkHandle hb) &lt;span&gt;const&lt;/span&gt;&lt;span&gt; NO_THREAD_SAFETY_ANALYSIS {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;   &lt;span&gt;const&lt;/span&gt; Chunk* a = allocator_-&amp;gt;&lt;span&gt;ChunkFromHandle(ha);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;   &lt;span&gt;const&lt;/span&gt; Chunk* b = allocator_-&amp;gt;&lt;span&gt;ChunkFromHandle(hb);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; (a-&amp;gt;size != b-&amp;gt;&lt;span&gt;size) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; a-&amp;gt;size &amp;lt; b-&amp;gt;&lt;span&gt;size;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;   &lt;span&gt;return&lt;/span&gt; a-&amp;gt;ptr &amp;lt; b-&amp;gt;&lt;span&gt;ptr;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;辅助工具类&lt;/h2&gt;
&lt;h2&gt;AllocationRegion与RegionManager&lt;/h2&gt;
&lt;p&gt;这两个类是起到辅助作用。BFC Allocator每次分配存储区时都以Chunk为单位，指向Chunk的指针又是ChunkHandle类型（实际为数组下标），但分配存储的最终目的是把Chunk中指向存储区域的头指针ptr分配给请求方。另外，当系统回收存储区时，面对的也是存储区的头指针，那么如果不能根据头指针找到Chunk和Bin信息，回收就不能成功。因此这里显然应该设计一系列接口和函数：&lt;strong&gt;它能够记录每次分配的Chunk，并且能够保存分配存储区的地址ptr与Chunk之间的映射关系&lt;/strong&gt;。AllocationRegion和RegionManager就是完成这些功能的接口。&lt;/p&gt;
&lt;p&gt;具体而言，AllocationRegion对应一次存储区分配的记录。一次存储区分配的信息包括起始地址ptr和存储区大小memory_size，这可能包括多个Chunk，所以该结构要记录此次分配中所包含所有Chunk的信息。RegionManager是AllocationRegion的管理器，它维护了AllocationRegion的数组。在RegionManager中，AllocationRegion数组是需要按照end_ptr地址排序的。&lt;/p&gt;
&lt;p&gt;利用RegionManager查询某个ptr所对应的ChunkHandle的时序图如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1437153/201905/1437153-20190504203539466-288395100.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这部分功能较为简单，所以不再展开代码逻辑，感兴趣的同学可以阅读这两个类的定义立即就能理解。&lt;/p&gt;

&lt;p&gt;介绍完基本结构和BFC的设计思想之后，就可以试着去理解具体的存储区分配和回收过程了。&lt;/p&gt;
&lt;h2&gt;Allocate流程&lt;/h2&gt;
&lt;h3&gt;AllocateRawInternal&lt;/h3&gt;
&lt;p&gt;这是BFCAllocator的为用户分配Chunk的总体流程。因为物理设备上实际的&lt;strong&gt;空闲&lt;/strong&gt;存储区已经被事先开辟好，并以Chunk的形式组织成了双向链表，那么BFC Allocator为用户分配存储区时直接从Chunk中获取即可。当双向链表中找不到合适的Chunk时，不得不向物理设备上申请更多存储空间，并创建新的Chunk放入到双向链表中，并挂入到B相应的Bin中。下面的流程图展示了这一过程，该过程涉及到了几个比较重要的子过程。它们分别是遍历搜索寻找最佳Chunk指针的FIndChunkPtr过程，当Chunk链表中不存在合适的Chunk以至于不得不向物理设备申请新存储空间的Extend过程，以及分配Chunk时为缓解碎片问题而出现的SplitChunk过程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1437153/201905/1437153-20190504225734983-60895445.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;整体流程的代码如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;*&lt;span&gt; BFCAllocator::AllocateRawInternal(size_t unused_alignment,
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;                                        size_t num_bytes,
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;                                         &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; dump_log_on_failure,
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;                                        uint64 freed_before) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; (num_bytes == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     VLOG(&lt;span&gt;2&lt;/span&gt;) &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tried to allocate 0 bytes&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; nullptr;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; First, always allocate memory of at least kMinAllocationSize
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; bytes, and always allocate multiples of kMinAllocationSize bytes
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; so all memory addresses are nicely byte aligned.&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;   size_t rounded_bytes =&lt;span&gt; RoundedBytes(num_bytes);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; The BFC allocator tries to find the best fit first.&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;   BinNum bin_num =&lt;span&gt; BinNumForSize(rounded_bytes);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;  mutex_lock l(lock_);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;   &lt;span&gt;void&lt;/span&gt;* ptr =&lt;span&gt; FindChunkPtr(bin_num, rounded_bytes, num_bytes, freed_before);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; (ptr !=&lt;span&gt; nullptr) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ptr;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Try to extend&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Extend(unused_alignment, rounded_bytes)) {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     ptr =&lt;span&gt; FindChunkPtr(bin_num, rounded_bytes, num_bytes, freed_before);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (ptr !=&lt;span&gt; nullptr) {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;       &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ptr;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; We searched all bins for an existing free chunk to use and
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; couldn't find one.  This means we must have run out of memory,
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Dump the memory log for analysis.&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (dump_log_on_failure) {
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;     LOG(WARNING) &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Allocator (&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; Name() &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) ran out of memory trying &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;                  &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;to allocate &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; strings::HumanReadableNumBytes(num_bytes)
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;                  &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.  Current allocation summary follows.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;    DumpMemoryLog(rounded_bytes);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;     LOG(WARNING) &amp;lt;&amp;lt;&lt;span&gt; RenderOccupancy();
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;   &lt;span&gt;return&lt;/span&gt;&lt;span&gt; nullptr;
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;FindChunkPtr过程&lt;/h3&gt;
&lt;p&gt;因为Chunk在每个Bin中都是按照size和基地址升序排列，所以搜索Chunk时只需顺序遍历free_chunks即可，首个找到的符合要求的Chunk即为所求。这个过程非常简单，不再以图的形式描述，只展示代码如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;*&lt;span&gt; BFCAllocator::FindChunkPtr(BinNum bin_num, size_t rounded_bytes,
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;                                 size_t num_bytes, uint64 freed_before) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; First identify the first bin that could satisfy rounded_bytes.&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;   &lt;span&gt;for&lt;/span&gt; (; bin_num &amp;lt; kNumBins; bin_num++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Start searching from the first bin for the smallest chunk that fits
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; rounded_bytes.&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     Bin* b =&lt;span&gt; BinFromIndex(bin_num);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (auto citer = b-&amp;gt;free_chunks.begin(); citer != b-&amp;gt;&lt;span&gt;free_chunks.end();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;          ++&lt;span&gt;citer) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;       &lt;span&gt;const&lt;/span&gt; BFCAllocator::ChunkHandle h = (*&lt;span&gt;citer);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;       BFCAllocator::Chunk* chunk =&lt;span&gt; ChunkFromHandle(h);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;       DCHECK(!chunk-&amp;gt;&lt;span&gt;in_use());
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;       &lt;span&gt;if&lt;/span&gt; (freed_before &amp;gt; &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; freed_before &amp;lt; chunk-&amp;gt;&lt;span&gt;freed_count) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;       &lt;span&gt;if&lt;/span&gt; (chunk-&amp;gt;size &amp;gt;=&lt;span&gt; rounded_bytes) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; We found an existing chunk that fits us that wasn't in use, so remove
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; it from the free bin structure prior to using.&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;         RemoveFreeChunkIterFromBin(&amp;amp;b-&amp;gt;&lt;span&gt;free_chunks, citer);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; If we can break the size of the chunk into two reasonably large
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; pieces, do so.  In any case don't waste more than
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; kMaxInternalFragmentation bytes on padding this alloc.&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;const&lt;/span&gt; int64 kMaxInternalFragmentation = &lt;span&gt;128&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;20&lt;/span&gt;;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 128mb&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (chunk-&amp;gt;size &amp;gt;= rounded_bytes * &lt;span&gt;2&lt;/span&gt; ||
&lt;span&gt;26&lt;/span&gt;             static_cast&amp;lt;int64&amp;gt;(chunk-&amp;gt;size) - rounded_bytes &amp;gt;=
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;                kMaxInternalFragmentation) {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;          SplitChunk(h, rounded_bytes);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;           chunk = ChunkFromHandle(h);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Update chunk pointer in case it moved&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; The requested size of the returned chunk is what the user
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; has allocated.&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;         chunk-&amp;gt;requested_size =&lt;span&gt; num_bytes;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Assign a unique id and increment the id counter, marking the
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; chunk as being in use.&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;         chunk-&amp;gt;allocation_id = next_allocation_id_++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; 
&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Update stats.&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt;         ++&lt;span&gt;stats_.num_allocs;
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;         stats_.bytes_in_use += chunk-&amp;gt;&lt;span&gt;size;
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;         stats_.peak_bytes_in_use =
&lt;span&gt;43&lt;/span&gt; &lt;span&gt;            std::max(stats_.peak_bytes_in_use, stats_.bytes_in_use);
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;         stats_.largest_alloc_size =
&lt;span&gt;45&lt;/span&gt;             std::max&amp;lt;std::size_t&amp;gt;(stats_.largest_alloc_size, chunk-&amp;gt;&lt;span&gt;size);
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; 
&lt;span&gt;47&lt;/span&gt;         VLOG(&lt;span&gt;4&lt;/span&gt;) &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Returning: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; chunk-&amp;gt;&lt;span&gt;ptr;
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (VLOG_IS_ON(&lt;span&gt;4&lt;/span&gt;&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;           LOG(INFO) &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; RenderOccupancy();
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; chunk-&amp;gt;&lt;span&gt;ptr;
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; 
&lt;span&gt;56&lt;/span&gt;   &lt;span&gt;return&lt;/span&gt;&lt;span&gt; nullptr;
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;SplitChunk过程&lt;/h3&gt;
&lt;p&gt;上图中没有展示出SplitChunk发生的位置，其实该过程是在FindChunkPtr中发生。在选取Chunk时，会有一定概率出现请求的size比所选的Chunk总size小很多的情况。因为每块Chunk只有in use或free两种状态，所以如果空闲的size比请求的size大很多，显然会造成该Chunk的实际使用率过低，这是一种浪费。BFC Allocator通过调用SplitChunk将Chunk分割成两部分来缓解这一问题。SplitChunk的功能顾名思义，就是将一块大的Chunk分割成两个部分。该过程发生在FindChunkPtr中，我们需要注意触发SplitChunk过程的条件，在代码中我们能看到这一函数的调用条件如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; If we can break the size of the chunk into two reasonably large
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; pieces, do so.  In any case don't waste more than
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; kMaxInternalFragmentation bytes on padding this alloc.&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; int64 kMaxInternalFragmentation = &lt;span&gt;128&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;20&lt;/span&gt;;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 128mb&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (chunk-&amp;gt;size &amp;gt;= rounded_bytes * &lt;span&gt;2&lt;/span&gt; ||
&lt;span&gt; 6&lt;/span&gt;     static_cast&amp;lt;int64&amp;gt;(chunk-&amp;gt;size) - rounded_bytes &amp;gt;=
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        kMaxInternalFragmentation) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;  SplitChunk(h, rounded_bytes);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;   chunk = ChunkFromHandle(h);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Update chunk pointer in case it moved&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从代码中可以清晰的看到，当以下两个条件之一满足时，SplitChunk过程将被触发。&lt;/p&gt;
&lt;p&gt;1. 当chunk的size是用户请求的round size两倍及以上时（用户请求的size会根据最小分配单元做round近似）&lt;/p&gt;
&lt;p&gt;2. 当chunk的size减去用户请求的round size后依然大于等于最大碎片限定时（128MB）&lt;/p&gt;
&lt;p&gt;在执行SplitChunk时，需要调整Chunk的前驱后继指针，这就是链表的基本操作，非常简单。另外，SplitChunk会产生新的Free Chunk，需要根据它的大小将它插入到对应的Bin中。&lt;/p&gt;
&lt;h3&gt;Extend过程&lt;/h3&gt;
&lt;p&gt;上面的流程图已经展示，只有在双向链表中不能找到合适的Chunk时，Extend过程才会被调用。它的调用说明现有的存储池中已经没有可以满足需求的存储区了，需要向物理设备申请，并创建新的Chunk，然后放入Bin中。向物理设备申请存储空间时，如果因为一次申请的空间较大而失败，会将请求空间做0.9因子的衰退，下面的代码段展示了这个细节。申请结束后，需要向region_manager中记录该次申请。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Try allocating.&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; size_t bytes =&lt;span&gt; std::min(curr_region_allocation_bytes_, available_bytes);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;* mem_addr = sub_allocator_-&amp;gt;&lt;span&gt;Alloc(alignment, bytes);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (mem_addr == nullptr &amp;amp;&amp;amp; !&lt;span&gt;started_backpedal_) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Only backpedal once.&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;   started_backpedal_ = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;   &lt;span&gt;static&lt;/span&gt; constexpr &lt;span&gt;float&lt;/span&gt; kBackpedalFactor = &lt;span&gt;0.9&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Try allocating less memory.&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;   &lt;span&gt;while&lt;/span&gt; (mem_addr ==&lt;span&gt; nullptr) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     bytes = RoundedBytes(bytes *&lt;span&gt; kBackpedalFactor);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (bytes &amp;lt; rounded_bytes) &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     mem_addr = sub_allocator_-&amp;gt;&lt;span&gt;Alloc(alignment, bytes);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;Deallocate流程&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;因为在回收时只知道存储空间首地址指针，并不知道其对应的Chunk，所以需要先借助region_manager等辅助工具获取其所对应的Chunk指针，然后考虑其前驱后继节点是否可以合并。下面展示了整体流程。因为Merge的过程即使链表合并的过程，比较简单，所以在此不再赘述。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1437153/201905/1437153-20190504221452222-244135340.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这部分对应的代码逻辑如下图所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; BFCAllocator::FreeAndMaybeCoalesce(BFCAllocator::ChunkHandle h) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;   Chunk* c =&lt;span&gt; ChunkFromHandle(h);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;   CHECK(c-&amp;gt;in_use() &amp;amp;&amp;amp; (c-&amp;gt;bin_num ==&lt;span&gt; kInvalidBinNum));
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Mark the chunk as no longer in use.&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;   c-&amp;gt;allocation_id = -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Optionally record the free time.&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (timing_counter_) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     c-&amp;gt;freed_count = timing_counter_-&amp;gt;&lt;span&gt;next();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Updates the stats.&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;   stats_.bytes_in_use -= c-&amp;gt;&lt;span&gt;size;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;   ChunkHandle coalesced_chunk =&lt;span&gt; h;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; If the next chunk is free, merge it into c and delete it.&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; (c-&amp;gt;next != kInvalidChunkHandle &amp;amp;&amp;amp; !ChunkFromHandle(c-&amp;gt;next)-&amp;gt;&lt;span&gt;in_use()) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; VLOG(8) &amp;lt;&amp;lt; &quot;Merging c-&amp;gt;next &quot; &amp;lt;&amp;lt; ChunkFromHandle(c-&amp;gt;next)-&amp;gt;ptr
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;         &amp;lt;&amp;lt; &quot; with c &quot; &amp;lt;&amp;lt; c-&amp;gt;ptr;&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;     RemoveFreeChunkFromBin(c-&amp;gt;&lt;span&gt;next);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     Merge(h, c-&amp;gt;&lt;span&gt;next);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; If the previous chunk is free, merge c into it and delete c.&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; (c-&amp;gt;prev != kInvalidChunkHandle &amp;amp;&amp;amp; !ChunkFromHandle(c-&amp;gt;prev)-&amp;gt;&lt;span&gt;in_use()) {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; VLOG(8) &amp;lt;&amp;lt; &quot;Merging c &quot; &amp;lt;&amp;lt; c-&amp;gt;ptr &amp;lt;&amp;lt; &quot; into c-&amp;gt;prev &quot;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;         &amp;lt;&amp;lt; ChunkFromHandle(c-&amp;gt;prev)-&amp;gt;ptr;&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt;     coalesced_chunk = c-&amp;gt;&lt;span&gt;prev;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     RemoveFreeChunkFromBin(c-&amp;gt;&lt;span&gt;prev);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;     Merge(c-&amp;gt;&lt;span&gt;prev, h);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt; &lt;span&gt;  InsertFreeChunkIntoBin(coalesced_chunk);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这是控制Allocator的一个选项，默认是False，此时会在设备上开辟最大限度的存储空间，并且全局只开辟一次。因为已经开辟了设备上的全部存储空间，所以若在双向链表中找不到合适的Chunk，那么将会直接报错OOM退出。当选项为True时，会经历多次存储空间的开辟，这完全取决于当前存储池中是否还有符合需求大小的Chunk。如果没有，则不断以2的n次方为基本大小进行开辟尝试，直到满足需求为止。那么这个值有什么用处呢？这取决于同一个Device是否允许被多个程序复用。比如在云基础设施上，如果能够开启Device复用，并打开Device的空分复用功能，那么将会大大提高集群资源的利用率。&lt;/p&gt;

&lt;p&gt;本文总结了TensorFlow中存储管理器——BFC Allocator。它的设计思路来自于经典来的dlmalloc分配算法，是Best fit coalecing的简单实现版本。BFC Allocator是为了应对TensorFlow中频繁分配释放存储空间需求的场景而出现的解决方案，通过事先将存储空间从物理设备上开辟好，并将这些空闲存储空间封装成Chunk，组织成有序双向链表，然后利用Bin这一种索引结构为Chunk的查询做加速，最终完成了高效的分配算法。在实际分配时，可能会遇到Chunk链表中不存在符合要求的空闲Chunk情况，这时候就可能需要向物理设备中再次开辟新的存储空间，这个过程被视为对Chunk链表的扩展，对应的过程是Extend。因为是按Chunk进行分配，势必可能造成存储碎片，为了解决碎片问题，BFC Allocator设计了SplitChunk和Merge函数。BFC Allocator是TensorFlow代码中比较精简的一个部分，该部分的代码难度较低，并且模块独立性较强，涉及到的代码量非常小，但是设计思想和功能却非常全面，非常适合初学者阅读和学习。&lt;/p&gt;
</description>
<pubDate>Sat, 04 May 2019 15:00:00 +0000</pubDate>
<dc:creator>DeepLearningStack</dc:creator>
<og:description>背景 作者：DeepLearningStack，阿里巴巴算法工程师，开源TensorFlow Contributor] 使用GPU训练时，一次训练任务无论是模型参数还是中间结果都需要占用大量显存。为了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/deep-learning-stacks/p/10741859.html</dc:identifier>
</item>
<item>
<title>Java核心技术梳理-异常处理 - 茶底世界</title>
<link>http://www.cnblogs.com/yuanqinnan/p/10810238.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuanqinnan/p/10810238.html</guid>
<description>&lt;h2&gt;一、引言&lt;/h2&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;异常总是不可避免的，就算我们自身的代码足够优秀，但却不能保证用户都按照我们想法进行输入，就算用户按照我们的想法进行输入，我们也不能保证操作系统稳定，另外还有网络环境等，不可控因素太多，异常也不可避免。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;但我们可以通过异常处理机制让程序有更好的容错性和兼容性，当程序出现异常时，系统自动生成Exception对象通知系统，从而将业务功能实现代码和错误处理代码分离。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;异常处理已经成为衡量一门语言是否成熟的标志之一，增加了异常处理机制后程序有更好的健壮性和容错性。&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block&quot;&gt;&lt;span&gt;二、&lt;/span&gt;&lt;span class=&quot;md-expand&quot;&gt;异常处理机制&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;我们希望系统有一种机制能够将错误处理代码和正常实现代码分离开，相当于一个if else,if中为正常实现代码，而else为错误的处理。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span class=&quot;md-expand&quot;&gt;2.1 &lt;/span&gt;&lt;span class=&quot;md-expand&quot;&gt;try...catch 捕获异常&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;我们按照上面的思路，java利用try catch来进行异常捕获。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;业务代码&lt;/span&gt;
&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(IOException ex){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;错误处理    &lt;/span&gt;
&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(Exception ex){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;错误处理代码&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当try块代码出错时，系统生成一个异常对象，并将对象抛给运行环境，这个过程叫做抛出异常，运行环境接收到异常对象是，会寻找处理该异常对象的catch代码块，找到合适的catch块，就将对象给其处理，如果找不到，则运行环境终止，程序也将退出。&lt;/p&gt;
&lt;h3&gt;2.2 异常类继承体系&lt;/h3&gt;
&lt;p&gt;Java提供了丰富的异常类，这些异常类有严格的继承关系&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201905/1113901-20190504223458890-896620832.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;从这个图可以看出异常主要分为两类，Error与Exception，Error错误一般是指与虚拟机相关的问题，如系统崩溃、虚拟机错误，这些错误无法恢复或不可能捕获，将导致应用程序崩溃，这些不需要我们去捕获。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;在捕获异常时我们通常把Exception类放在最后，因为按照异常捕获的机制，从上至下判断该异常对象是否是catch中的异常类或其异常子类，一旦比较成功则用此catch进行处理。如果将Exception类放在前面，那么就会进行直接进入其中，因为Exception类是所有异常类的父类，那排在它后面的异常类将永远得不到执行的机会，这种机制我们称为&lt;span&gt;&lt;strong&gt;先小后大&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block&quot;&gt;&lt;span&gt;2.3 &lt;/span&gt;多异常捕获&lt;/h3&gt;
&lt;p&gt;Java 7 开始，一个catch块中可以捕获多种类型的异常：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        Integer a &lt;/span&gt;= Integer.parseInt(args[0&lt;span&gt;]);
        Integer b &lt;/span&gt;= Integer.parseInt(args[1&lt;span&gt;]);
        Integer c &lt;/span&gt;= a /&lt;span&gt; b;
        System.out.println(c);

    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt; (IndexOutOfBoundsException |&lt;span&gt; NumberFormatException
            &lt;/span&gt;|&lt;span&gt; ArithmeticException ie) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;异常变量默认final，不能重新赋值&lt;/span&gt;
        ie = &lt;span&gt;new&lt;/span&gt; ArithmeticException(&quot;text&quot;&lt;span&gt;);

    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex) {

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;多个异常之间用竖线（|）隔开，并且异常变量默认final，不能重新赋值。&lt;/p&gt;
&lt;h3&gt;2.4 获取异常信息&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;异常捕获后我们想要查看异常信息，可以通过catch后的异常形参来获得，常用的方法如下：&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;1&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;getMessage()：返回异常的详细描述字符串。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;getStackTrace()：返回异常跟踪栈信息。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;printStackTrace()：将异常跟踪栈信息按照标准格式输出。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;printStackTrace(PrintStream p)：将异常跟踪栈信息输出到指定输出流。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;2.5 finally回收资源&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;在try里面打开的一些物理连接，需要显示的回收，但显然在try里面或者catch里面进行回收是不行的，try中一旦出现异常，回收可能不会执行到，而catch更不行，因为在没有异常时根本不会执行，于是异常处理机制提供了finally，finally块代码一定会被执行，即是try中执行了return语句也还是会执行。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;业务代码&lt;/span&gt;
}&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(XXXException xx){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;异常处理&lt;/span&gt;
}&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(XXXException xx){
    
}&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;资源回收&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;在异常处理中，try是必须的，没有try块，后面的catch和finally没有意义，catch和finally必须出现一个，finally块必须是最后。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;如果try块中有return语句，则会先执行finally，然后再执行return语句，如果try块中有exit语句，则不会执行finally,都直接退出虚拟机了当然不会再去执行。&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block&quot;&gt;&lt;span&gt;2.&lt;/span&gt;&lt;span class=&quot;md-expand&quot;&gt;6 自动关闭的try语句&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;每次都需要资源回收，显得有些麻烦，Java还支持一种写法，直接在try后申明资源，那么就可以替换掉finally，但这个资源必须实现Closeable或者AutoCloseable接口&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;try&lt;/span&gt;&lt;span&gt; (
        BufferedReader bufferedReader &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; BufferedReader(&lt;span&gt;new&lt;/span&gt; FileReader(&quot;&quot;&lt;span&gt;))
) {
    bufferedReader.read();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;三、&lt;span class=&quot;md-expand&quot;&gt;Checked异常与Runtime异常&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Java的异常分为两大类：Checked（可检查）异常和Runtime（运行时）异常，所有的RuntimeException类及其子类的实例就是Runtime异常，其他的都是Checked异常。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;对于Checked异常处理方式有两种，一种是明确知道如何处理该异常，用try catch来捕获异常，然后在catch中修复异常，一种是不知道如何处理，在定义方法时申明抛出异常。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Runtime异常无需显示申明抛出，需要捕获异常，就用try catch来实现。&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;3.1 使用throws声明抛出异常&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;使用throws声明的思路是：当前方法不知道如何处理这种类型的异常，则由上一级调用者处理，如果main方法也不知道如何处理，也可以使用throws抛给JVM，JVM的处理是，打印异常的跟踪栈信息，并终止程序。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;throws声明抛出只能在方法签名中使用，可以声明抛出多个异常类，多个异常类用逗号隔开，如：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
    FileInputStream fileInputStream &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; FileInputStream(&quot;&quot;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;申明了throws就不需要再使用try catch来捕获异常了。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;如果某段代码中调用了一个带throws声明的方法，那么必须用try catch来处理或者也带throws声明，如下例子：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        test();
    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
        e.printStackTrace();
    }

}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; test () &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException{
    FileInputStream fileInputStream &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; FileInputStream(&quot;&quot;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;这个时候要注意，子类方法声明抛出的异常应该是父类方法声明抛出异常的子类活相同，不允许比父类声明抛出的异常多。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;本人之前是C#开发，C#开发没有Checked异常，个人觉得这个Checked异常有些繁琐，它最大的作用仿佛是提醒开发处理异常，避免因为粗心而忘记处理异常，不知道是不是理解有误。&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;四、&lt;/span&gt;&lt;span class=&quot;md-expand&quot;&gt;使用throw抛出异常&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;程序出现错误，系统会抛出异常，有时候我们也想自行抛出异常，比如用户未登录，我们可能就直接抛出错误，这种自行抛出的异常一般都与业务相关，因为业务数据与既定不符，但是这种异常并不是一种错误，系统不会捕捉，就需要我们自行抛出。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;使用throw语句进行异常抛出，抛出的不是一个异常类，而是一个异常实例，而且每次只能抛出一个：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt; (user== &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Exception(&quot;用户不存在&quot;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里我们又要区分Checked异常与运行时异常，运行时异常申明非常简单，直接抛出即可，而Checked异常又要像之前一样，要么使用try catch，要么声明throws&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;检查时异常需要写try catch&lt;/span&gt;
&lt;span&gt;        test1();
    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
        e.printStackTrace();
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;运行时异常直接调用即可&lt;/span&gt;
&lt;span&gt;    test2();

}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; test1() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (1 &amp;gt; 0&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Exception(&quot;用户不存在&quot;&lt;span&gt;);
    }
}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test2() {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (1 &amp;gt; 0&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RuntimeException(&quot;用户不存在&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;4.1 自定义异常类&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;为了让错误更直观的表达信息，有时候我们需要自定义异常， 自定义异常很简单，只需要继承Exception或者RuntimeException基类，一般会提供两个构造器，一个空构造器，一个带有描述信息的构造器：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; GlobalException &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; RuntimeException {

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;无参构造器&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; GlobalException() {
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;带有错误描述信息的构造器&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; GlobalException(String msg) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(msg);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;4.2 异常链&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;在实际开发中，我们一般会分层开发，比较常用的是三层，表现出、业务逻辑层、数据库访问层，我们不会抛出数据库异常给用户，因为这些异常中有堆栈信息，很不安全，也非常的不友好。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;通常，我们捕获原始异常（可以写入日志），然后再抛出一个业务异常（通常是自定义的异常），这个业务异常可以提示用户异常的原因：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; update() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; GlobalException{
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行sql&lt;/span&gt;
&lt;span&gt;    }

    &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (SQLException ex){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;记录日志&lt;/span&gt;
&lt;span&gt;        ...
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;抛出自定义错误&lt;/span&gt;
            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; GlobalException(&quot;数据库报错&quot;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;记录日志&lt;/span&gt;
&lt;span&gt;        ...
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; GlobalException(&quot;未知错误！&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这种捕获一个异常然后抛出另一个异常，并将原始信息保存起来的是一种典型的链式处理（责任链模式）。&lt;/p&gt;
&lt;h2&gt;五、&lt;span class=&quot;md-expand&quot;&gt;异常处理规则&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;异常给系统带来了健壮性和容错性，但是使用异常处理并非如此简单，我们还要注意性能和结构的优化，有些规则我们必须了解，而这些规则的主要目标是：&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;0&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;程序代码混乱最小化。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;捕获并保留诊断信息。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;通知合适的人员&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;采用合适的方式结束异常。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;5.1 不要过度使用异常&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;什么叫过度使用异常呢？有两种情况，一是把异常和普通错误放在一起，使用异常来代替错误，什么意思呢？就是对一些我们已知或可控的错误进行异常处理，如一些业务逻辑判断，用户的输入等，并不是只有直接抛出异常这种选择，我们可以直接通过业务处理进行错误返回，而不是抛出错误，抛出错误的效率要低一些，只有对外部的、不能确定和预知的运行时错误使用异常。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;二就是使用异常来代替流程控制，异常处理机制的初衷是将不可以预期的错误和正常的业务代码分离，不应该用异常来进行流程控制。&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;5.2 不要使用过大的try块&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;不要把大量的业务代码放在try中，大量的业务代码意味着错误可能性也增大，也意味着一旦出错，分析错误的复杂度也增加，而且try中包含大量业务，可能后面紧跟的catch块也很多，我们会使用多个catch来捕获错误，这样代码也很臃肿，应该尽量细分try，去分别捕获并处理。&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;5.3 不要忽略捕获到的异常&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;不要忽略异常，当我们捕获到异常时，我们不要去忽略它，如果在catch中什么也不做，那是一种恐怖的做法，因为这意味着出现了错误我们并不知道（极特殊的情况例外，比如：一些可重试的业务处理），最起码的做法是打印错误日志，更进一步看是否可以修复错误，或者向上抛出错误。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 04 May 2019 14:49:00 +0000</pubDate>
<dc:creator>茶底世界</dc:creator>
<og:description>一、引言 异常总是不可避免的，就算我们自身的代码足够优秀，但却不能保证用户都按照我们想法进行输入，就算用户按照我们的想法进行输入，我们也不能保证操作系统稳定，另外还有网络环境等，不可控因素太多，异常也</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuanqinnan/p/10810238.html</dc:identifier>
</item>
<item>
<title>React的世界观及与Vue之比较 - 大唐西域都护</title>
<link>http://www.cnblogs.com/leegent/p/10794047.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/leegent/p/10794047.html</guid>
<description>&lt;p&gt;写在前面：本文谈论的是&lt;strong&gt;主观的个人感受&lt;/strong&gt;，不追求立场的“客观、公正”，因此我下面所说的很可能是错的，欢迎交流指正。&lt;/p&gt;

&lt;p&gt;我学习前端时，跟大部分beginner一样，学的第一个框架是Vue，入职后也一直写Vue。写了一年多，想换换口味了，于是决定最近的新项目改用React试试。用了大半个月后，我已经完全被这个迷人的框架洗脑了，特别是它背后的设计理念非常优秀，让人耳目一新。&lt;/p&gt;
&lt;p&gt;React的设计思想有何过人之处呢？拿它和Vue做个对比就清楚了。&lt;/p&gt;

&lt;h2&gt;Vue: 填模板游戏继续&lt;/h2&gt;
&lt;p&gt;Vue之所以成为国内前端初学者（包括我）的首选，一方面是因为中文文档写得好，更重要的原因则是它符合人们对于网页开发的传统认知。&lt;/p&gt;
&lt;p&gt;Vue虽然内部做了很多工作（如Virtual DOM），但暴露给开发者的体验更像是&lt;strong&gt;升级版的模板引擎&lt;/strong&gt;，类似于Jade、Handlerbars。模板引擎的作用就是在静态的模板上动态替换JS变量，以渲染出最终的页面。基于Vue的项目目录下，每个组件目录下都有html、css、js文件三足鼎立（或者集中到一个.vue文件里，但仍然是分开的三部分），html是静态模板，js管理动态的变量，整体结构非常的直观。&lt;/p&gt;
&lt;p&gt;此外，Vue在模板引擎的基础上增加了“双向绑定”功能，即用户输入造成的DOM变动可以反过来同步给关联的JS变量；并且自定义了一些v指令，大大简化了事件绑定、条件渲染、动态列表等常用功能的实现复杂度。这些因素使得Vue写起来既像模板引擎一样易于理解，又比模板引擎方便很多。我个人写Vue的时候，一般就是先写html模板，在此过程中把需要动态填充的数据定义出来，随手写个mock数据先占位；等模板写完了，再来写获取这些数据的js逻辑。&lt;/p&gt;
&lt;p&gt;也就是说，Vue的开发思路差不多就是“写模板-填模板”的套路，与jQuery时代一脉相承。&lt;/p&gt;
&lt;p&gt;这种套路上手容易，但是没什么发挥空间，写多了真的容易腻烦。而且在JS逻辑越来越复杂的情况下，状态管理非常麻烦，心智负担沉重。&lt;/p&gt;
&lt;p&gt;骚年，要不要换一种玩法试试？&lt;/p&gt;

&lt;h2&gt;React: 一种新的玩法&lt;/h2&gt;
&lt;p&gt;刚接触React的时候，是不是被嵌在js里的html（JSX）、满天飞的箭头函数、高阶函数等弄得有点不适应？反正我是脑阔疼了好一阵。&lt;/p&gt;
&lt;p&gt;但是进一步了解React后就会明白，这不是脸书的攻城狮们在耍帅或者故弄玄虚，而是这些语法真的能够更好地表达React的思想，帮助代码作者和读者thinking in React。&lt;/p&gt;
&lt;p&gt;React的核心思想是什么呢？不妨来看看Vue和React的组件对比。这是一个非常简单的组件——展示从父组件收到的message字符串：&lt;/p&gt;
&lt;p&gt;Vue的实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; demo.vue&lt;/span&gt;
&amp;lt;template&amp;gt;
    &amp;lt;div&amp;gt;{{message}}&amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;&lt;span&gt;
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; =&lt;span&gt; {
    props: ['&lt;/span&gt;&lt;span&gt;message']&lt;/span&gt;&lt;span&gt;
}
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;React的实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; demo.jsx&lt;/span&gt;
&lt;span&gt;
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; props =&amp;gt;&lt;span&gt; (
    &lt;/span&gt;&amp;lt;div&amp;gt;{props.message}&amp;lt;/div&amp;gt;
);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这两段代码一眼就能一个非常明显的不同点——Vue组件实现为一个有模板（template）、有数据（props）的&lt;strong&gt;对象&lt;/strong&gt;， React组件则实现为一个输入数据（props）、输出html片段（JSX）的&lt;strong&gt;函数&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;函数有什么特别呢？从数学上讲，函数本质上就是表示一种&lt;strong&gt;映射关系&lt;/strong&gt;。React受函数式编程思想的影响，&lt;strong&gt;将html视为数据映射的结果&lt;/strong&gt;。一个数据映射出一个html片段，所有的html片段拼起来，就形成了完整的页面DOM树。当然，React组件还可以是class形式，但只是为了更好地操作数据，最终render函数会完成映射这一步。这是一种截然不同于模板填充的思维方式，姑且称之为“&lt;strong&gt;映射思维&lt;/strong&gt;”。相应的，将变量绑定到模板上的思维方式就称之为“&lt;strong&gt;模板思维&lt;/strong&gt;”。理解这两种思维的对立非常重要，因为这是React与Vue等其他框架的核心差异所在。&lt;/p&gt;
&lt;p&gt;我画了如下两张图，尝试阐明模板思维与映射思维的不同：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/900937/201905/900937-20190504210912035-119393005.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这两种思维的根本分歧在于：&lt;strong&gt;视图层与数据层何者第一，何者第二&lt;/strong&gt;？或者说，是先有html再有js，还是先有js再有html？&lt;/p&gt;
&lt;p&gt;模板思维认为是先有html，再有js。正如上面图的左半部分所示，模板本身已经是一个接近完整的网页了，只不过其中几个变量没法确定，需要一点逻辑来动态填充，所以找了js这么个小弟来打打下手，把这几个变量给补上去。因此，在模板思维的世界观里，html居于主导地位，js服从于html的需要。&lt;/p&gt;
&lt;p&gt;映射思维却相反，认为js里的数据才是第一性的，html只不过是数据层向视图层的单向映射或者说投影，如上图右半部分所示，一个个数据的投影片段拼起来，组成了完整的html。在这个世界观里，&lt;strong&gt;数据是本体，视图是现象&lt;/strong&gt;，他们之间的关系就像一棵树与它的影子一样，要想改变影子，就必须改变树，而不能影子变了树没变。明白了这一点，React那些乍看之下有些奇怪的设定（如阻止input标签直接响应的用户输入），以及React社区对单向数据流的偏好（如Redux），就不难理解了。&lt;/p&gt;

&lt;h2&gt;孰优孰劣？&lt;/h2&gt;
&lt;p&gt;我可不想像很多文章那样偷懒地来一句“各有优劣”，再不痛不痒地分别列举几个优缺点完事。我，旗帜鲜明地认为，&lt;strong&gt;映射思维才是前端未来正确的发展方向&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在上古时代的网页里，js只是嵌在html里的一行或者一小段脚本，干着弹个提示、飞个广告之类的杂活，远远称不上一个完整的程序，说它是html的小弟或补充，一点问题也没有。但如今，页面越来越复杂，异步加载、动态渲染的开发模式越来越流行，在这种模式下，整个页面都是由js绘制出来的，正是因为js对页面有了完全的掌控权，才使得网页真正进化为“WebApp”，成为一个真正的程序，而不再是一个简单的、无逻辑的类XML标记语言文件，进而使得数据-视图层的分离及其映射关系的建立成为可能。&lt;/p&gt;
&lt;p&gt;在WebApp里，有一个原则显然应该被始终遵守——一致性，即用户看到的DOM元素状态应该与对应的js变量值保持一致。Vue的解决方案是双向绑定，React则实现了单向数据流，这都是从它们各自的世界观出发做出的自然而然的选择。但在我看来，视图=表象，&lt;strong&gt;不应该让表象承载实质，否则会导致形实关系的混乱&lt;/strong&gt;——自然法则允许通过修剪树来改变它的影子，难道也要允许通过改变影子反过来改变树吗？表象就应该是实质的忠实呈现，以及用户触达实质的媒介（事件绑定），不应越俎代庖。&lt;/p&gt;

&lt;p&gt;在模板思维看来，html模板和js数据都是实质，二者是并列的关系；在映射思维的世界观里，js数据是唯一的实质。&lt;/p&gt;
&lt;p&gt;“&lt;strong&gt;如无必要，勿增实体&lt;/strong&gt;”，我选择简单的那个方案。&lt;/p&gt;
&lt;p&gt;事实也是如此，学会了thinking in React，可以在编写复杂页面的时候，仍然保持逻辑清晰和极度舒适。&lt;/p&gt;
&lt;p&gt;真香！！！&lt;/p&gt;
</description>
<pubDate>Sat, 04 May 2019 14:46:00 +0000</pubDate>
<dc:creator>大唐西域都护</dc:creator>
<og:description>从设计哲学的角度认识React，很多技术细节自会豁然开朗</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/leegent/p/10794047.html</dc:identifier>
</item>
<item>
<title>spi-mem: 为SPI存储器生态带来一些一致性 - zqb-all</title>
<link>http://www.cnblogs.com/zqb-all/p/10810054.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zqb-all/p/10810054.html</guid>
<description>&lt;p&gt;在本文中，我们将介绍关于spi-mem Linux内核框架的工作，该框架将允许在SPI NOR设备和常规SPI设备以及SPI NAND设备上复用SPI控制器驱动程序。&lt;/p&gt;
&lt;h2 id=&quot;从spi到双线四线八线spi&quot;&gt;从SPI到双线、四线、八线SPI&lt;/h2&gt;
&lt;p&gt;在过去，SPI是一个简单的协议，总线上的所有设备只共享3根信号线:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;MISO: Master In Slave Out，主设备输入从设备输出线&lt;/li&gt;
&lt;li&gt;MOSI: Master Out Slave In，主设备输出从设备输入线&lt;/li&gt;
&lt;li&gt;SCLK: Serial Clock，时钟线&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908492/201905/908492-20190504215659040-1835640828.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外每个设备有一个独立信号线，用于选择我们想要通信的设备:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;SS: Slave Select，从设备选择线 (有时也称为片选线CS，Chip Select)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;但随后SPI存储出现了。它从较小且相对较慢的SPI NORs开始，如dataflash、EEPROMs和SRAMs，然后逐渐发展到较大的SPI NORs和SPI NANDs。像往常一样，当涉及到处理存储时，我们希望得到最佳性能表现。SPI总线的限制很快成为瓶颈，因此供应商决定添加更多的I/O线路，并使 MISO/MOSI 线可以双向通信。现在我们看到SPI控制器支持最多8路I/O。这就是业内所说的DualSPI QuadSPI和OctoSPI。&lt;/p&gt;
&lt;p&gt;为了在主从设备的数据传输中用上所有的I/O线，必须有某种主从设备之间的协议，这样双方才能知道，何时可以在I/O线上收发数据，应该使用多少根I/O线等。这些由一组从设备预定义的操作规定了如何进行，主设备必须遵循这组操作的规定，进入特定的发送或接收状态。SPI存储器操作通常包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1字节的操作码，表示将要进行从操作 (未来将很快会将出现2字节的操作码，请做好准备)&lt;/li&gt;
&lt;li&gt;0-N 字节的地址，其含义取决于操作码(可以是绝对内存地址，或其他含义)&lt;/li&gt;
&lt;li&gt;0-N 字节的哑字节，使得从设备有足够的时间来进入操作码请求的特定状态，同样，哑字节的数量时取决于操作码的&lt;/li&gt;
&lt;li&gt;0-N 字节的输入或输出数据，方向是取决于操作码&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;请注意，虽然这个协议倾向于被用于存储设备，但并没有什么能限制它只能用于存储设备，如果一些FPGA使用相同的协议来操作非存储设备，我也不会感到惊讶。&lt;/p&gt;
&lt;h2 id=&quot;linux-spi-生态&quot;&gt;Linux SPI 生态&lt;/h2&gt;
&lt;p&gt;Linux支持双线SPI和四线SPI模式已经有一段时间了(v3.12)， SPI设备驱动程序可以为每个SPI传输指定I/O通道的数量。使用这种方式，对SPI存储的操作可以被分为多次SPI传输，每次SPI传输使用预定义数量的I/O通道进行传输。&lt;/p&gt;
&lt;p&gt;这种方式可以正常工作，直到一些IP供应商决定让它们的SPI控制器更加智能，嵌入某种高级接口，可以在单个的步骤中执行SPI存储器的操作，而不是使用分开的多次传输操作。(事实上，大多数SPI控制器甚至比这更加智能，可以允许你直接将SPI存储映射到CPU的地址空间，但让我们先把这种情况留待以后处理吧)。在这种情况下，我们需要赋予SPI控制器更多的控制权，这样它就可以决定具体该做什么，而不必从一组分散的SPI传输命令中，重建SPI存储器操作。&lt;/p&gt;
&lt;p&gt;当时的决定是，将这些控制器专门用于一个任务，控制SPI NORs（当时这是唯一会用到双线和四线模式的情况），SPI NOR框架就是为此而创建的。&lt;/p&gt;
&lt;p&gt;由于这个决定，我们现在在Linux中有一个SPI NOR框架用于连接SPI NOR控制器驱动和SPI NOR的逻辑代码（&lt;a href=&quot;https://elixir.bootlin.com/linux/latest/source/drivers/mtd/spi-nor&quot;&gt;spi-nor 子系统&lt;/a&gt;），同时我们有常规的SPI控制器驱动，可以进行基础的SPI传输（&lt;a href=&quot;https://elixir.bootlin.com/linux/latest/source/drivers/spi&quot;&gt;spi 子系统&lt;/a&gt;）。然而，从硬件的角度看，能为SPI NOR提供特殊特性的SPI控制器，一般也拥有进行基本传输的能力，即可用于控制常规的SPI设备。不幸的是，基于当前的spi-nor 子系统和spi 子系统是分裂开来的情况，如果一个SPI控制器被spi-nor子系统的驱动支持了，它将无法被用于与spi子系统中的常规设备进行通信。&lt;/p&gt;
&lt;p&gt;作为一个针对这个问题的部分的解决方案，&lt;a href=&quot;https://elixir.bootlin.com/linux/latest/source/include/linux/spi/spi.h#L551&quot;&gt;-&amp;gt;spi_flash_read()&lt;/a&gt;操作被添加到&lt;a href=&quot;https://elixir.bootlin.com/linux/latest/ident/spi_controller&quot;&gt;结构体 spi_controller&lt;/a&gt;中，这允许spi子系统中的常规spi控制器驱动提供一个较优的方式，来从SPI NOR存储中读取数据，这种方式被通用SPI NOR驱动&lt;a href=&quot;https://elixir.bootlin.com/linux/latest/source/drivers/mtd/devices/m25p80.c#L157&quot;&gt;m25p80&lt;/a&gt;所使用。然而，这个解决方案是部分的，因为它只优化了读取，并且仅限于SPI NORs。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908492/201905/908492-20190504215720700-402997482.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在当前的架构中，我们有&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;SPI NOR框架，它包含与SPI NOR存储器通讯的协议。这个框架依赖于&lt;a href=&quot;https://elixir.bootlin.com/linux/latest/source/include/linux/mtd/spi-nor.h#L280&quot;&gt;结构体spi_nor&lt;/a&gt;中列出的接口，这些接口的实现是：&lt;/li&gt;
&lt;li&gt;专用的SPI NOR控制器，支持专用于SPI NORs的高级SPI控制器&lt;/li&gt;
&lt;li&gt;m25p80驱动，提供同样的接口，但基于常规SPI控制器驱动，可能具有-&amp;gt;spi_flash_read()的优化&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;是什么促使我们提出spi存储器接口&quot;&gt;是什么促使我们提出SPI存储器接口?&lt;/h2&gt;
&lt;p&gt;我们之前已经看到，基于SPI NOR框架，SPI NOR存储器已经得到了适当的支持。但NORs 并非SPI总线上唯一的存储设备，SPI NANDs 正在变得越来越流行。&lt;br/&gt;Peter Pan提出了一个遵循SPI NOR模型的，用于支持SPI NAND设备的&lt;a href=&quot;https://lwn.net/Articles/723694/&quot;&gt;框架&lt;/a&gt;: SPI控制器必须实现SPI NAND控制器接口才能控制SPI NAND。但是当我们更深入地参与到这个开发中时，我们很快意识到沿着这条路走会有多么麻烦，因为这意味着，如果SPI控制器想要同时控制两种设备，就必须同时实现SPI NOR和SPI NAND接口。当SPI NVRAM或任何其他类型的存储制造商决定采用SPI总线时，将会发生什么?再添加一个SPI控制器必须实现的接口？这听起来不是个好主意。&lt;/p&gt;
&lt;p&gt;因此我们决定用另外的方式解决这个问题，尝试找出SPI NANDs和SPI NORs的共同点。SPI NORs和SPI NANDs 指令集不同，行为和约束也不同(主要是由于NOR和NAND本身的不同)，但当与设备交互时，都遵循同样的SPI存储器操作语义，这也是高级控制器都在尝试优化的部分。&lt;/p&gt;
&lt;p&gt;SPI 存储器层只是提供一种方式给SPI控制器驱动，用于传递高级SPI存储器操作，而不是让它们处理SPI传输细节并自行尝试优化它们。这同样简化了SPI存储器驱动，因为它们只需要按照SPI存储器规范发送SPI存储器操作指令，不需要关心复杂的、不断发展的、依赖具体存储器的接口。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908492/201905/908492-20190504220445010-1210480635.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有了这个新的架构，SPI NOR和SPI NAND都可以基于相同的SPI控制器驱动进行支持了。m25p80驱动将被修改成，使用spi-mem接口，取代具有局限性的-&amp;gt;spi_flash_read()接口。目前，我们仍然有专用的SPI NOR控制器驱动，但最终目标是移除它们，并将它们移植为 drivers/spi 下的普通SPI控制器驱动。非常欢迎这方面的帮助和贡献。&lt;/p&gt;
&lt;h2 id=&quot;spi存储器api是什么样子的&quot;&gt;SPI存储器API是什么样子的?&lt;/h2&gt;
&lt;p&gt;SPI存储器的API 由 &lt;a href=&quot;https://git.kernel.org/pub/scm/linux/kernel/git/broonie/spi.git/tree/include/linux/spi/spi-mem.h?h=for-4.18&quot;&gt;include/linux/spi/spi-mem.h&lt;/a&gt; 描述。&lt;/p&gt;
&lt;p&gt;希望使用SPI存储器API的SPI设备驱动程序，应该将自己声明为spi_mem_drivers，并实现-&amp;gt;probe()和-&amp;gt;remove()函数。&lt;br/&gt;它们将被传入一个spi_mem对象，它只是一个围绕spi_device对象的简单包装，我们引入一个不同的对象的原因是，我们希望能够拓展spi_mem对象，并在需要时附加更多的信息（例如存储器类型，存储器组织方式和其他的高级SPI控制器可能需要的信息）。&lt;br/&gt;当驱动想要执行SPI存储器操作时，它将填充spi_mem_op结构并调用spi_mem_exec_op()。另外，可以使用spi_mem_supports_op()，测试一个SPI控制器是否支持特定的存储器操作，使用spi_mem_adjust_op_size()，获取控制器支持的最大传输大小，并尝试拆分数据传输以避免超出限制。&lt;/p&gt;
&lt;p&gt;现在让我们看下控制器端。一个希望优化SPI存储器操作的SPI控制器，可以实现spi_mem_ops接口，该接口包含三个直接对应用户API的方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;-&amp;gt;exec_op():执行存储器操作，如果不支持则返回-ENOTSUPP。&lt;/li&gt;
&lt;li&gt;-&amp;gt;supports_op(): 检查这个存储器操作是否支持。&lt;/li&gt;
&lt;li&gt;-&amp;gt;adjust_op_size(): 调整存储器操作的数据传输大小，以符合对齐要求和最大FIFO大小的约束。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;注意，当spi_mem_ops 没有实现时，core层将通过创建由多个SPI传输组成的SPI消息，来添加对该特性的通用支持，就像以前通用SPI NOR控制器驱动程序(名为m25p80)所做的那样。&lt;/p&gt;
&lt;p&gt;如你所见，这些API非常直截了当，所以希望有更多的SPI存储器驱动能够转换为使用它，而不是手动创建包含多个SPI传输的SPI消息。&lt;/p&gt;
&lt;h2 id=&quot;当前状态&quot;&gt;当前状态&lt;/h2&gt;
&lt;p&gt;一部分已经被贡献出去并合并，计划成为Linux 4.18的一部分：&lt;/p&gt;
&lt;h2 id=&quot;下一步是什么&quot;&gt;下一步是什么？&lt;/h2&gt;
&lt;p&gt;先进的SPI控制器不仅能够优化SPI存储器操作的执行，它们可以进一步将所有存储器访问的复杂性隐藏起来，提供一个直接映射的IOMEM区域，对此区域的访问会自动在总线上触发SPI存储器操作，为你完成数据的收发，这样的行为就像一个连接在并行的内存总线上的内存。可以想象，这将允许更高的吞吐量和更少的用于SPI存储器操作管理的CPU时间，但这同时也是一个难以通过常规的方式进行支持的功能。我们已经在linux-mtd邮件列表上发布了一个支持这种直接映射功能的&lt;a href=&quot;http://lists.infradead.org/pipermail/linux-mtd/2018-June/081460.html&quot;&gt;建议&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;如前所述，另一个具有挑战性的主题是，将所有的SPI NOR控制器驱动转换为基于SPI mem模型，以便所有的QSPI控制器都真正表现为SPI控制器而非SPI NOR控制器。这可能需要一些时间，因为目前在driver/mtd/spi-nor 下有10个驱动，我们只知道其中2个被转换为了SPI mem方法(fsl-quadspi和atmel-quadspi)。&lt;/p&gt;
&lt;p&gt;本文地址 &lt;a href=&quot;https://www.cnblogs.com/zqb-all/p/10810054.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/zqb-all/p/10810054.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译自 &lt;a href=&quot;https://bootlin.com/blog/spi-mem-bringing-some-consistency-to-the-spi-memory-ecosystem/&quot; class=&quot;uri&quot;&gt;https://bootlin.com/blog/spi-mem-bringing-some-consistency-to-the-spi-memory-ecosystem/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原作者 Boris Brezillon&lt;/p&gt;
</description>
<pubDate>Sat, 04 May 2019 14:12:00 +0000</pubDate>
<dc:creator>zqb-all</dc:creator>
<og:description>在本文中，我们将介绍关于spi mem Linux内核框架的工作，该框架将允许在SPI NOR设备和常规SPI设备以及SPI NAND设备上复用SPI控制器驱动程序。 从SPI到双线、四线、八线SPI</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zqb-all/p/10810054.html</dc:identifier>
</item>
<item>
<title>搭配 VS Code Remote 远程开发扩展在 WSL 下开发 - nczitzk</title>
<link>http://www.cnblogs.com/nczitzk/p/develop-in-wsl-with-vscode-remote.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nczitzk/p/develop-in-wsl-with-vscode-remote.html</guid>
<description>&lt;blockquote readability=&quot;3.3734939759036&quot;&gt;
&lt;p&gt;❗ 注意：远程开发扩展需要在 &lt;a href=&quot;http://code.visualstudio.com/insiders&quot;&gt;Visual Studio Code Insiders&lt;/a&gt; 上使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Visual Studio Code Remote - WSL 扩展允许你直接借助 VS Code 令 &lt;a href=&quot;https://docs.microsoft.com/windows/wsl&quot;&gt;「适用于 Linux 的 Windows 子系统」（WSL）&lt;/a&gt; 作为你的全职开发环境。你可以在基于 Linux 的环境中进行开发，使用 Linux 特有的的工具链和实用库，并在舒适的 Windows 中运行和调试基于 Linux 的应用程序。&lt;/p&gt;
&lt;p&gt;该扩展直接在 WSL 中运行命令和其它扩展，因此你可以编辑位于 WSL 中的文件或挂载在其上的 Windows 文件系统（例如 /mnt/c），而无需担心遇到文件路径问题、二进制兼容性或其它跨操作系统的难题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://code.visualstudio.com/assets/docs/remote/wsl/architecture-wsl.png&quot; alt=&quot;WSL Architecture&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这使得 VS Code 能够提供有着在本地进行开发一样效率的开发体验——包括完整的IntelliSense（代码补全）、代码导航和调试——无论你的代码在何处托管，都是如此。&lt;/p&gt;
&lt;h2&gt;上手&lt;/h2&gt;
&lt;h3&gt;安装&lt;/h3&gt;
&lt;p&gt;上手前你需要做的几件事情：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;安装对应你偏好的 Linux 发行版的 &lt;a href=&quot;https://docs.microsoft.com/windows/wsl/install-win10&quot;&gt;「适用于 Linux 的 Windows 子系统」&lt;/a&gt;。VS Code 将使用你安装的默认发行版，因此可以根据需要使用 &lt;a href=&quot;https://docs.microsoft.com/windows/wsl/wsl-config&quot;&gt;wslconfig.exe&lt;/a&gt; 更改默认发行版。&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;3.906976744186&quot;&gt;
&lt;p&gt;注意：WSL 确实存在一些 &lt;a href=&quot;https://code.visualstudio.com/docs/remote/wsl#_known-limitations&quot;&gt;已知的对于某些类型的开发的限制&lt;/a&gt;，这些限制也会影响你的 VS Code 体验。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol readability=&quot;1.30044345898&quot;&gt;&lt;li readability=&quot;-0.65822784810127&quot;&gt;
&lt;p&gt;在 Windows 端安装 &lt;a href=&quot;https://code.visualstudio.com/insiders/&quot;&gt;Visual Studio Code Insiders&lt;/a&gt;（而不是在 WSL 中）。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-0.55&quot;&gt;
&lt;p&gt;安装 &lt;a href=&quot;https://aka.ms/vscode-remote/download/extension&quot;&gt;Remote Development&lt;/a&gt; 扩展包。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1.9090909090909&quot;&gt;
&lt;p&gt;考虑在 Windows 端禁用 Git 的行尾结束符自动转换，方法是使用命令提示符运行：&lt;strong&gt;git config --global core.autocrlf false&lt;/strong&gt; 如果该项保持启用状态，由于行尾结束符的差异，此设置可能导致你未编辑的文件中出现了修改操作。有关详细信息，请参阅 &lt;a href=&quot;https://aka.ms/vscode-remote/download/extension&quot;&gt;提示和技巧&lt;/a&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;在 WSL 中打开文件夹&lt;/h3&gt;
&lt;p&gt;在 VS Code 中打开「适用于 Linux 的 Windows 子系统」中的文件夹与从命令提示符打开 Windows 文件夹非常相似。&lt;/p&gt;
&lt;ol readability=&quot;3&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;打开 WSL 终端窗口（使用开始菜单项或从命令提示符键入 &lt;strong&gt;wsl&lt;/strong&gt; ）。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;切换到你要在 VS Code 中打开的文件夹（包括但不限于 Windows 文件系统挂载点，如 &lt;strong&gt;/mnt/c&lt;/strong&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;在终端中输入 &lt;strong&gt;code-insiders .&lt;/strong&gt;。在第一次执行此操作时，你应该看到 VS code 在获取运行于 WSL 所需的组件。这应该只需要很短的时间，而且只需要执行一次。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;片刻之后，一个新的 VS Code 窗口将会出现，你将看到一个 VS Code 正在 WSL 中打开文件夹的通知。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://code.visualstudio.com/assets/docs/remote/wsl/wsl-starting-notification.png&quot; alt=&quot;WSL Starting notification&quot;/&gt;&lt;/p&gt;
&lt;p&gt;VS Code 现在将继续在 WSL 中配置自身，并在 WSL 中安装你在本地运行的任何 VS Code 扩展以优化性能。 VS Code 会对你通知它所获得的进展。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;完成后，你现在可以在左下角看到一个 WSL 小标识，你将能够像平常一样使用 VS Code！&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://code.visualstudio.com/assets/docs/remote/wsl/wsl-statusbar-indicator.png&quot; alt=&quot;WSL Status Bar Item&quot;/&gt;&lt;/p&gt;
&lt;p&gt;就是如此啦！你在此窗口中执行的任何 VS code 操作都将在 WSL 环境中执行，从编辑和文件操作到调试、使用终端等等都是如此。&lt;/p&gt;
&lt;h2&gt;管理扩展&lt;/h2&gt;
&lt;p&gt;VS Code 在以下两个位置之一运行扩展：在 UI / 客户端这边或在 WSL 中。虽然作用于 VS Code UI 的扩展（如主题和代码片段）是在本地安装的，但大多数扩展都将安装在 WSL 中。&lt;/p&gt;
&lt;p&gt;如果从「扩展」视图安装扩展，它将自动安装在正确的位置。一旦安装后，你可以根据类别分组确定扩展的安装位置。那将有「本地 - 已安装」的类别和一个安装在 WSL 的类别。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://code.visualstudio.com/assets/docs/remote/wsl/wsl-installed-remote-indicator.png&quot; alt=&quot;Workspace Extension Category&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://code.visualstudio.com/assets/docs/remote/wsl/wsl-local-installed-extensions.png&quot; alt=&quot;&amp;gt;Local Extension Category&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5.2847682119205&quot;&gt;
&lt;p&gt;注意：如果你是扩展作者并且你的扩展程序无法正常运行或安装在错误的位置，请参阅 &lt;a href=&quot;https://code.visualstudio.com/api/advanced-topics/remote-extensions&quot;&gt;支持远程开发&lt;/a&gt; 查看详情。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;实际需要远程运行的本地扩展在「本地 - 已安装」类别中显示为「已禁用」。你可以单击「安装」按钮在远程主机上安装扩展。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://code.visualstudio.com/assets/docs/remote/wsl/wsl-disabled-extensions.png&quot; alt=&quot;Disabled Extensions&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;高级：强制在本地/远程运行扩展&lt;/h3&gt;
&lt;p&gt;扩展通常为单独运行在本地或远程而设计和测试，而非对于两者。但是，如果扩展程序支持这项特性，则可以强制它在 &lt;strong&gt;settings.json&lt;/strong&gt; 文件中指定的特定位置运行。&lt;/p&gt;
&lt;p&gt;例如，下面的设置将强制 Docker 和 Debugger for Chrome 扩展程序 远程运行而不是默认在本地运行：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;json&quot;&gt;&quot;remote.extensionKind&quot;: {
    &quot;msjsdiag.debugger-for-chrome&quot;: &quot;workspace&quot;,
    &quot;peterjausovec.vscode-docker&quot;: &quot;workspace&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;值&lt;strong&gt;「ui」&lt;/strong&gt;而不是&lt;strong&gt;「workspace」&lt;/strong&gt;将强制扩展在本地 UI /客户端 端运行。 通常，除非在扩展程序的文档中另有说明，否则这应仅用于测试，因为它可以中断扩展。 了解详细信息，请参阅有关 &lt;a href=&quot;https://code.visualstudio.com/api/advanced-topics/remote-extensions&quot;&gt;支持远程开发&lt;/a&gt; 的文章。&lt;/p&gt;
&lt;h2&gt;在 WSL 中打开终端&lt;/h2&gt;
&lt;p&gt;从 VS Code 在 WSL 中打开终端很简单。在 WSL 中打开文件夹后，在 VS code (Terminal &amp;gt; New Terminal) 中打开的任何终端窗口将自动在 WSL 中运行，而不是在本地运行。&lt;/p&gt;
&lt;p&gt;你还可以使用此同一终端窗口中的 &lt;strong&gt;code-insiders&lt;/strong&gt; 命令行来执行许多操作，例如在 WSL 中打开新文件或文件夹。 键入 &lt;strong&gt;code-insiders --help&lt;/strong&gt; 以查看命令行中可用的选项。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://code.visualstudio.com/assets/docs/remote/wsl/code-command-in-terminal.png&quot; alt=&quot;Using the code CLI&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;在 WSL 中调试&lt;/h2&gt;
&lt;p&gt;在 WSL 中打开文件夹后，可以像在本地运行应用程序一样使用 VS Code 的调试器。例如，如果在 &lt;strong&gt;launch.json&lt;/strong&gt; 中选择一个启动配置并开始调试（F5），应用程序将在远程主机上启动并与调试器交互。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;.vscode/launch.json&lt;/strong&gt; 中有关配置 VS Code 调试功能的详细信息，请参阅 &lt;a href=&quot;https://code.visualstudio.com/docs/editor/debugging&quot;&gt;debugging&lt;/a&gt; 文档。&lt;/p&gt;
&lt;h2&gt;WSL 特定设置&lt;/h2&gt;
&lt;p&gt;在 WSL 中打开文件夹时，也会引用 VS Code 的本地用户设置。虽然这可以保持用户体验的一致性，但你可能希望更改本地计算机和 WSL 之间一些设置。幸运的是，一旦连接到 WSL，你还可以通过运行「首选项」来设置 WSL 特定设置：打开从命令选项板（F1）中打开「远程设置命令」或在设置编辑器中选择「远程」选项卡。这些将覆盖你在 WSL 中打开文件夹时所具有的任何本地设置。&lt;/p&gt;
&lt;h2&gt;已知限制&lt;/h2&gt;
&lt;p&gt;本节包含 WSL 常见已知问题的列表。目的不是提供完整的问题列表，而是强调 WSL 中常见的一些问题。&lt;/p&gt;
&lt;p&gt;在 &lt;a href=&quot;https://aka.ms/vscode-remote/wsl/issues&quot;&gt;这里浏览有关 WSL 的活跃问题列表&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;常见问题&lt;/h2&gt;
&lt;h3&gt;我应该如何更改「远程 - WSL」使用的发行版呢？&lt;/h3&gt;
&lt;p&gt;「远程 - WSL」扩展使用的是你的默认发行版，你可以通过 &lt;a href=&quot;https://docs.microsoft.com/windows/wsl/wsl-config&quot;&gt;wslconfig.exe&lt;/a&gt; 对其进行更改。&lt;/p&gt;
&lt;p&gt;例子如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;bash&quot;&gt;wslconfig /setdefault Ubuntu&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过以下命令得知你一已安装的发行版：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;bash&quot;&gt;wslconfig /l&lt;/code&gt;
&lt;/pre&gt;
&lt;h3&gt;我看到有关缺少库或依赖项的错误&lt;/h3&gt;
&lt;p&gt;某些扩展依赖于某些 WSL Linux 发行版原生安装缺失而找不到的库。你可以使用其包管理器将其他库添加到Linux发行版中。 对于基于 Ubuntu 和 Debian 的发行版，运行 &lt;strong&gt;sudo apt-get install &amp;lt;package&amp;gt;&lt;/strong&gt; 来安装所需的库。检查扩展的文档或提及的运行时信息以获取其它安装详细信息。&lt;/p&gt;
&lt;h3&gt;在WSL中运行时，VS Code Server 的连接要求是什么？&lt;/h3&gt;
&lt;p&gt;VS Code Server 需要与 &lt;strong&gt;update.code.visualstudio.com&lt;/strong&gt; 和 &lt;strong&gt;marketplace.visualstudio.com&lt;/strong&gt;的 HTTPS（端口443）连接。服务器和 VS code 客户端之间的所有其它通信都是通过经过身份验证的随机的本地 TCP 端口完成的。&lt;/p&gt;
&lt;h3&gt;作为扩展作者，我需要做什么？&lt;/h3&gt;
&lt;p&gt;VS Code 扩展 API 抽象出本地/远程详细信息，因此大多数扩展都可以在不进行修改的情况下工作。但是，如果扩展可以使用它们所需的任何 node 模块或运行时，则可能需要进行调整。 我们建议你测试扩展程序，以此来确定是否需要更新。有关详细信息，请参阅 &lt;a href=&quot;https://code.visualstudio.com/api/advanced-topics/remote-extensions&quot;&gt;支持远程开发&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;问题或反馈&lt;/h3&gt;
&lt;p&gt;本文由 &lt;a href=&quot;https://docs.microsoft.com/windows/wsl&quot;&gt;VS Code Remote 官方文档&lt;/a&gt; 翻译而成，同时发表在 &lt;a href=&quot;https://ethans.me/codes/develop-in-wsl-with-vscode-remote-zh_CN&quot; target=&quot;_blank&quot;&gt;ethans.me&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 04 May 2019 13:48:00 +0000</pubDate>
<dc:creator>nczitzk</dc:creator>
<og:description>Visual Studio Code Remote - WSL 扩展允许你直接借助 VS Code 令 「适用于 Linux 的 Windows 子系统」（WSL） 作为你的全职开发环境。你可以在基于</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nczitzk/p/develop-in-wsl-with-vscode-remote.html</dc:identifier>
</item>
<item>
<title>拉格朗日乘子法 - KKT条件 - 对偶问题 - massquantity</title>
<link>http://www.cnblogs.com/massquantity/p/10807311.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/massquantity/p/10807311.html</guid>
<description>&lt;p&gt;接下来准备写支持向量机，然而支持向量机和其他算法相比牵涉较多的数学知识，其中首当其冲的就是标题中的拉格朗日乘子法、KKT条件和对偶问题，所以本篇先作个铺垫。&lt;/p&gt;
&lt;p&gt;大部分机器学习算法最后都可归结为最优化问题。对于无约束优化问题： &lt;span class=&quot;math inline&quot;&gt;\(\min\limits_\boldsymbol{x} f(\boldsymbol{x})\)&lt;/span&gt; (本篇为形式统一，只考虑极小化问题)，一般可直接求导并用梯度下降或牛顿法迭代求得最优值。&lt;/p&gt;&lt;p&gt;对于含有等式约束的优化问题，即：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{aligned} {\min_{\boldsymbol{x}}} &amp;amp; \;\;{f(\boldsymbol{x})} \\ {\text { s.t. }} &amp;amp; \;\;{h_{i}(\boldsymbol{x}) = 0}, \quad i=1,2, \ldots, m \end{aligned} \]&lt;/span&gt;&lt;br/&gt;由于等式约束 &lt;span class=&quot;math inline&quot;&gt;\(h_i(\boldsymbol{x}) = 0\)&lt;/span&gt; 的存在，无法直接求导迭代求解。拉格朗日乘子法是解决此类问题的常用方法，其核心思想是将约束优化转化为无约束优化问题，即将有 &lt;span class=&quot;math inline&quot;&gt;\(d\)&lt;/span&gt; 个变量和 &lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt; 个等式约束条件的最优化问题转换为一个有 &lt;span class=&quot;math inline&quot;&gt;\((d + m)\)&lt;/span&gt; 个变量的函数求平稳点的问题。&lt;/p&gt;

&lt;center&gt;

&lt;/center&gt;
&lt;hr/&gt;&lt;p&gt;下面画图来直观理解拉格朗日乘子法，先看下左图： 黑色虚线为函数 &lt;span class=&quot;math inline&quot;&gt;\(f(x)\)&lt;/span&gt; 的等值线，红色实线为约束条件 &lt;span class=&quot;math inline&quot;&gt;\(h(x) = 0\)&lt;/span&gt; ，这里的关键是 &lt;span class=&quot;math inline&quot;&gt;\(f(x)\)&lt;/span&gt; 在极小点处必然与 &lt;span class=&quot;math inline&quot;&gt;\(h(x) = 0\)&lt;/span&gt; 相切，如下左图相切于黄色点 &lt;span class=&quot;math inline&quot;&gt;\(x_1\)&lt;/span&gt; 。为什么这么说？来看下右图： 如果 &lt;span class=&quot;math inline&quot;&gt;\(f(x)\)&lt;/span&gt; 与 &lt;span class=&quot;math inline&quot;&gt;\(h(x) = 0\)&lt;/span&gt; 不相切，则相交于两个黄色点，而由于 &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt; 是连续的，则必然能找到一个新的 &lt;span class=&quot;math inline&quot;&gt;\(x_2\)&lt;/span&gt; 使得 &lt;span class=&quot;math inline&quot;&gt;\(f(x_2)\)&lt;/span&gt; 更小，图中表示为蓝色虚线，使得在 &lt;span class=&quot;math inline&quot;&gt;\(x_2\)&lt;/span&gt; 处 &lt;span class=&quot;math inline&quot;&gt;\(f(x)\)&lt;/span&gt; 与 &lt;span class=&quot;math inline&quot;&gt;\(h(x) = 0\)&lt;/span&gt; 相切。&lt;/p&gt;
&lt;center&gt;

&lt;/center&gt;
&lt;p&gt;由于相交的两个黄色点不是极小点，梯度 &lt;span class=&quot;math inline&quot;&gt;\(\nabla f(x_1)\)&lt;/span&gt; 仍然会沿着 &lt;span class=&quot;math inline&quot;&gt;\(h(x) = 0\)&lt;/span&gt; 变化，因而在这两个点 &lt;span class=&quot;math inline&quot;&gt;\(\nabla f(x_1)\)&lt;/span&gt; 不与 &lt;span class=&quot;math inline&quot;&gt;\(h(x) = 0\)&lt;/span&gt; 的切线方向垂直，只有在极小点才会正交。&lt;/p&gt;&lt;p&gt;由此可以得出两个推论 (见下图)：&lt;/p&gt;
&lt;center&gt;

&lt;/center&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;(1). 对于 &lt;span class=&quot;math inline&quot;&gt;\(f(\boldsymbol{x})\)&lt;/span&gt; 的极小点 &lt;span class=&quot;math inline&quot;&gt;\(\boldsymbol{x}^*\)&lt;/span&gt; ，&lt;span class=&quot;math inline&quot;&gt;\(f(\boldsymbol{x})\)&lt;/span&gt; 在 &lt;span class=&quot;math inline&quot;&gt;\(\boldsymbol{x}^*\)&lt;/span&gt; 处的梯度 &lt;span class=&quot;math inline&quot;&gt;\(\nabla f(\boldsymbol{x}^*)\)&lt;/span&gt; 与 &lt;span class=&quot;math inline&quot;&gt;\(h(\boldsymbol{x}) = 0\)&lt;/span&gt; 的切线方向垂直&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;(2). 对于 &lt;span class=&quot;math inline&quot;&gt;\(f(\boldsymbol{x})\)&lt;/span&gt; 的极小点 &lt;span class=&quot;math inline&quot;&gt;\(\boldsymbol{x}^*\)&lt;/span&gt; ，&lt;span class=&quot;math inline&quot;&gt;\(h(\boldsymbol{x})\)&lt;/span&gt; 在 &lt;span class=&quot;math inline&quot;&gt;\(\boldsymbol{x}^*\)&lt;/span&gt; 处的梯度 &lt;span class=&quot;math inline&quot;&gt;\(\nabla h(\boldsymbol{x}^*)\)&lt;/span&gt; 与 &lt;span class=&quot;math inline&quot;&gt;\(h(\boldsymbol{x}) = 0\)&lt;/span&gt; 的切线方向垂直&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;对于第 (2) 点，可作如下证明： 设 &lt;span class=&quot;math inline&quot;&gt;\(\boldsymbol{x}(t)\)&lt;/span&gt; 为连续可微的函数，则有 &lt;span class=&quot;math inline&quot;&gt;\(h(\boldsymbol{x}(t)) = 0\)&lt;/span&gt; ，利用链式法则：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \frac{\text{d}}{\text{d} t} h(\boldsymbol{x}(t)) = \nabla h(\boldsymbol{x}(t)) \cdot \frac{\text{d}{\boldsymbol{x}(t)}}{\text{d}t} = 0 \]&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\frac{\text{d}{\boldsymbol{x}(t)}}{\text{d}t}\)&lt;/span&gt; 即为切线方向，所以本质上 &lt;span class=&quot;math inline&quot;&gt;\(h(\boldsymbol{x}) = 0\)&lt;/span&gt; 上任意一点的梯度 &lt;span class=&quot;math inline&quot;&gt;\(\nabla h(\boldsymbol{x})\)&lt;/span&gt; 都与其正交，&lt;span class=&quot;math inline&quot;&gt;\(\boldsymbol{x}^*\)&lt;/span&gt; 自然也不例外。&lt;/p&gt;&lt;p&gt;于是可以得出在极小点处 &lt;span class=&quot;math inline&quot;&gt;\(\nabla h(\boldsymbol{x}^*)\)&lt;/span&gt; 与 &lt;span class=&quot;math inline&quot;&gt;\(\nabla f(\boldsymbol{x}^*)\)&lt;/span&gt; 平行，即存在 &lt;span class=&quot;math inline&quot;&gt;\(\lambda \neq 0\)&lt;/span&gt; ，使得：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \nabla f(\boldsymbol{x}^*) + \lambda \nabla h(\boldsymbol{x}^*) = 0 \tag{1.1} \]&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\lambda\)&lt;/span&gt; 被称为拉格朗日乘子，下面定义拉格朗日函数：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \mathcal{L}(\boldsymbol{x}, \lambda) = f(\boldsymbol{x}) + \lambda \,h(\boldsymbol{x}) \tag{1.2} \]&lt;/span&gt;&lt;br/&gt;将上式分别对 &lt;span class=&quot;math inline&quot;&gt;\(\boldsymbol{x}\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(\lambda\)&lt;/span&gt; 求导置零，就分别得到 &lt;span class=&quot;math inline&quot;&gt;\((1.1)\)&lt;/span&gt; 式和等式约束 &lt;span class=&quot;math inline&quot;&gt;\(h(\boldsymbol{x}) = 0\)&lt;/span&gt; ，这样就将原约束优化问题转化为对 &lt;span class=&quot;math inline&quot;&gt;\(\mathcal{L}(\boldsymbol{x}, \lambda)\)&lt;/span&gt; 的无约束优化问题。 然而这个方法找出来的平稳点不一定都是原问题的极值点，如下左图是一个极值点，而下右图却不是极值点。&lt;/p&gt;
&lt;center&gt;

&lt;/center&gt;

&lt;center&gt;

&lt;/center&gt;
&lt;hr/&gt;&lt;p&gt;上面拉格朗日乘子法解决的是等式约束优化问题，而对于不等式约束优化问题也可解，只不过要加一些附加条件：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{aligned} {\min_{\boldsymbol{x}}} &amp;amp; \;\;{f(\boldsymbol{x})} \\ {\text { s.t. }} &amp;amp; \;\;{g_{i}(\boldsymbol{x}) \leqslant 0}, \quad i=1,2, \ldots, m \\ &amp;amp; \;\;{h_{j}(\boldsymbol{x}) = 0}, \quad j=1,2, \ldots, n \end{aligned} \]&lt;/span&gt;&lt;br/&gt;先下一个定义：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;对于一个不等式约束 &lt;span class=&quot;math inline&quot;&gt;\(g_j(\boldsymbol{x}) \leqslant 0\)&lt;/span&gt; ，若在 &lt;span class=&quot;math inline&quot;&gt;\(\boldsymbol{x}^*\)&lt;/span&gt; 处 &lt;span class=&quot;math inline&quot;&gt;\(g_j(\boldsymbol{x}^*) &amp;lt; 0\)&lt;/span&gt; ，那么称该不等式约束是 &lt;span class=&quot;math inline&quot;&gt;\(\boldsymbol{x}^*\)&lt;/span&gt; 处的不起作用约束；若在 &lt;span class=&quot;math inline&quot;&gt;\(\boldsymbol{x}^*\)&lt;/span&gt; 处 &lt;span class=&quot;math inline&quot;&gt;\(g_j(\boldsymbol{x}^*) = 0\)&lt;/span&gt; ，那么称该约束是 &lt;span class=&quot;math inline&quot;&gt;\(\boldsymbol{x}^*\)&lt;/span&gt; 处的起作用约束。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;对于该定义的直观解释见下图： 灰色部分为约束 &lt;span class=&quot;math inline&quot;&gt;\(g(\boldsymbol{x}) \leqslant 0\)&lt;/span&gt; 的可行域，若最优点 &lt;span class=&quot;math inline&quot;&gt;\(\boldsymbol{x}^*\)&lt;/span&gt; 在区域内 (下左图，&lt;span class=&quot;math inline&quot;&gt;\(g(\boldsymbol{x}) &amp;lt; 0\)&lt;/span&gt; ) ，则约束并没有起到”约束的作用“，这样可直接通过 &lt;span class=&quot;math inline&quot;&gt;\(\nabla f(\boldsymbol{x}) = 0\)&lt;/span&gt; 来获得最优点，这等价于让 &lt;span class=&quot;math inline&quot;&gt;\((1.1)\)&lt;/span&gt; 式中 &lt;span class=&quot;math inline&quot;&gt;\(\lambda = 0\)&lt;/span&gt; 。&lt;/p&gt;
&lt;p&gt;若最优点 &lt;span class=&quot;math inline&quot;&gt;\(\boldsymbol{x}^*\)&lt;/span&gt; 在区域边界上 (下右图，&lt;span class=&quot;math inline&quot;&gt;\(g(\boldsymbol{x}) = 0\)&lt;/span&gt; ) ，那么对于 &lt;span class=&quot;math inline&quot;&gt;\(f(\boldsymbol{x})\)&lt;/span&gt; 来说，在 &lt;span class=&quot;math inline&quot;&gt;\(\boldsymbol{x}^*\)&lt;/span&gt; 处是外部较大，内部较小，因为越靠近等值线中心 &lt;span class=&quot;math inline&quot;&gt;\(f(\boldsymbol{x})\)&lt;/span&gt; 越小； 而对于 &lt;span class=&quot;math inline&quot;&gt;\(g(\boldsymbol{x})\)&lt;/span&gt; 来说，在 &lt;span class=&quot;math inline&quot;&gt;\(\boldsymbol{x}\)&lt;/span&gt; 处的变化趋势是内部较小，外部较大，因为在内部 &lt;span class=&quot;math inline&quot;&gt;\(g(\boldsymbol{x}) \leqslant 0\)&lt;/span&gt; ，外部 &lt;span class=&quot;math inline&quot;&gt;\(g(\boldsymbol{x}) &amp;gt; 0\)&lt;/span&gt; 。这样 &lt;span class=&quot;math inline&quot;&gt;\(\nabla f(\boldsymbol{x}^*)\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(\nabla g(\boldsymbol{x}^*)\)&lt;/span&gt; 的方向必相反，此时 &lt;span class=&quot;math inline&quot;&gt;\(g(\boldsymbol{x}) = 0\)&lt;/span&gt;， 那么套用 &lt;span class=&quot;math inline&quot;&gt;\((1.1)\)&lt;/span&gt; 式可得 &lt;span class=&quot;math inline&quot;&gt;\(\lambda &amp;gt; 0\)&lt;/span&gt; 。&lt;/p&gt;
&lt;p&gt;综合这两种情况：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{cases} g(\boldsymbol{x}) &amp;lt; 0, &amp;amp; \lambda = 0 \\[1ex] g(\boldsymbol{x}) = 0, &amp;amp; \lambda &amp;gt; 0 \end{cases} \quad \Longrightarrow \quad \lambda \geqslant 0, \;\;\lambda \,g(\boldsymbol{x}) = 0 \tag{2.1} \]&lt;/span&gt;&lt;br/&gt;这被称为互补松弛条件 (&lt;span class=&quot;math inline&quot;&gt;\(\text{complementary slackness}\)&lt;/span&gt;) 。&lt;/p&gt;
&lt;center&gt;

&lt;/center&gt;
&lt;p&gt;由此推广到多个约束，定义广义拉格朗日函数：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \mathcal{L}(\boldsymbol{x}, \boldsymbol{\alpha}, \boldsymbol{\beta}) :=f(\boldsymbol{x})+\sum_{i=1}^{m} \alpha_{i} g_{i}(\boldsymbol{x})+\sum_{j=1}^{n} \beta_{j} h_{j}(\boldsymbol{x}) \tag{2.2} \]&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\boldsymbol{\alpha} \geqslant 0\)&lt;/span&gt; 为 KKT 乘子，&lt;span class=&quot;math inline&quot;&gt;\(\boldsymbol{\beta}\)&lt;/span&gt; 为拉格朗日乘子，其最优解满足：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{cases} g_i(\boldsymbol{x}) \leqslant 0, &amp;amp; i=1,2, \ldots, m \qquad\qquad(1) \\[1ex] {h_{j}(\boldsymbol{x}) = 0}, &amp;amp; j=1,2, \ldots, n \,\qquad\qquad(2) \\[1ex] \alpha_i \geqslant 0, &amp;amp; i=1,2, \ldots, m \qquad\qquad(3) \\[1ex] \alpha_i g_i(\boldsymbol{x}) = 0, &amp;amp; i=1,2, \ldots, m \qquad\qquad(4) \end{cases} \]&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\((1) \sim (2)\)&lt;/span&gt; 式为原问题的约束条件，&lt;span class=&quot;math inline&quot;&gt;\((3) \sim (4)\)&lt;/span&gt; 式上文定义中已证明。这就是不等式约束优化问题的 KKT 条件 (&lt;span class=&quot;math inline&quot;&gt;\(\text{Karush-Kuhn-Tucker Condition}\)&lt;/span&gt;)，KKT 条件是拉格朗日乘子法在不等式约束优化问题上的泛化。KKT 条件是极小点的必要条件，即满足 KKT 条件不一定是极小点，但极小点必满足 KKT 条件。&lt;/p&gt;

&lt;center&gt;

&lt;/center&gt;
&lt;hr/&gt;&lt;p&gt;将原始问题转化为对偶问题是求解带约束优化问题的一种方法，当然这不是唯一的方法，只不过转化为对偶问题后往往更容易求解，因而被广为应用。&lt;/p&gt;
&lt;p&gt;设原始优化问题为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{aligned} {\min_{\boldsymbol{x}}} &amp;amp; \;\;{f(\boldsymbol{x})} \\ {\text { s.t. }} &amp;amp; \;\;{g_{i}(\boldsymbol{x}) \leqslant 0}, \quad i=1,2, \ldots, m \\ &amp;amp; \;\;{h_{j}(\boldsymbol{x}) = 0}, \quad j=1,2, \ldots, n \end{aligned} \tag{3.1} \]&lt;/span&gt;&lt;br/&gt;其拉格朗日函数为 &lt;span class=&quot;math inline&quot;&gt;\(\mathcal{L}(\boldsymbol{x}, \boldsymbol{\alpha}, \boldsymbol{\beta}) =f(\boldsymbol{x})+\sum_{i=1}^{m} \alpha_{i} g_{i}(\boldsymbol{x})+\sum_{j=1}^{n} \beta_{j} h_{j}(\boldsymbol{x}), \;\;\alpha \geqslant 0\)&lt;/span&gt; 。若 &lt;span class=&quot;math inline&quot;&gt;\(\boldsymbol{x}\)&lt;/span&gt; 违反了一些约束 (即存在 &lt;span class=&quot;math inline&quot;&gt;\(i,j\)&lt;/span&gt; 使得 &lt;span class=&quot;math inline&quot;&gt;\({g_{i}(\boldsymbol{x}) \geqslant 0}\)&lt;/span&gt; 或 &lt;span class=&quot;math inline&quot;&gt;\(h_j(\boldsymbol{x}) \neq 0\)&lt;/span&gt; ) ，那么 &lt;span class=&quot;math inline&quot;&gt;\(\max\limits_{\boldsymbol{\alpha}, \boldsymbol{\beta}} \mathcal{L}(\boldsymbol{x}, \boldsymbol{\alpha}, \boldsymbol{\beta}) = \infty\)&lt;/span&gt; ，则：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{aligned} \min _{\boldsymbol{x}} \max _{\boldsymbol{\alpha}, \boldsymbol{\beta}} \mathcal{L}(\boldsymbol{x}, \boldsymbol{\alpha}, \boldsymbol{\beta}) = &amp;amp; \min _{\boldsymbol{x}}\left(f(\boldsymbol{x})+\max _{\boldsymbol{\alpha}, \boldsymbol{\beta}}\left(\sum_{i=1}^{m} \alpha_{i} g_{i}(\boldsymbol{x})+\sum_{j=1}^{n} \beta_{j} h_{j}(\boldsymbol{x})\right)\right) \\[1ex] = &amp;amp; \min_{\boldsymbol{x}}\left(f(\boldsymbol{x})+\left\{\begin{array}{l}{0}\,, &amp;amp; 若 \boldsymbol{x} \,满足约束 \\ {\infty}\,, &amp;amp; 若 \boldsymbol{x} \,不满足约束\end{array}\right.\right) \\[1ex] = &amp;amp; \min_{\boldsymbol{x}} f(\boldsymbol{x}), \;\;且 \boldsymbol{x} \, 满足约束 \end{aligned} \]&lt;/span&gt;&lt;br/&gt;这样原始优化问题 &lt;span class=&quot;math inline&quot;&gt;\((3.1)\)&lt;/span&gt; 就等价于：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{align*} \min _{\boldsymbol{x}} \max _{\boldsymbol{\alpha}, \boldsymbol{\beta}} &amp;amp; \;\; \mathcal{L}(\boldsymbol{x}, \boldsymbol{\alpha}, \boldsymbol{\beta}) \\ \text{s.t.} &amp;amp; \;\; \alpha_i \geqslant 0, \quad i=1,2, \ldots, m \end{align*} \]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;接下来定义 &lt;span class=&quot;math inline&quot;&gt;\((3.1)\)&lt;/span&gt; 式的对偶问题 (dual problem) 为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{align*} \max _{\boldsymbol{\alpha}, \boldsymbol{\beta}}\min _{\boldsymbol{x}} &amp;amp; \;\; \mathcal{L}(\boldsymbol{x}, \boldsymbol{\alpha}, \boldsymbol{\beta}) \\ \text{s.t.} &amp;amp; \;\; \alpha_i \geqslant 0, \quad i=1,2, \ldots, m \end{align*} \]&lt;/span&gt;&lt;br/&gt;对偶问题是原始问题的下界，即：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \max _{\boldsymbol{\alpha}, \boldsymbol{\beta}}\min _{\boldsymbol{x}} \mathcal{L}(\boldsymbol{x}, \boldsymbol{\alpha}, \boldsymbol{\beta}) \; \leq \; \min _{\boldsymbol{x}} \max _{\boldsymbol{\alpha}, \boldsymbol{\beta}} \mathcal{L}(\boldsymbol{x}, \boldsymbol{\alpha}, \boldsymbol{\beta}) \tag{3.2} \]&lt;/span&gt;&lt;br/&gt;上式为什么成立？因为任意值小于等于最大值，所以对于任意 &lt;span class=&quot;math inline&quot;&gt;\(\boldsymbol{\alpha}, \,\boldsymbol{\beta}\)&lt;/span&gt; ，&lt;span class=&quot;math inline&quot;&gt;\(\min _{\boldsymbol{x}} \mathcal{L}(\boldsymbol{x}, \boldsymbol{\alpha}, \boldsymbol{\beta}) \; \leq \; \min _{\boldsymbol{x}} \max _{\boldsymbol{\alpha}, \boldsymbol{\beta}} \mathcal{L}(\boldsymbol{x}, \boldsymbol{\alpha}, \boldsymbol{\beta})\)&lt;/span&gt; ，如果上式恒成立，则不等式左边的 &lt;span class=&quot;math inline&quot;&gt;\(\min _{\boldsymbol{x}} \mathcal{L}(\boldsymbol{x}, \boldsymbol{\alpha}, \boldsymbol{\beta})\)&lt;/span&gt; 的极大值 &lt;span class=&quot;math inline&quot;&gt;\(\max _{\boldsymbol{\alpha}, \boldsymbol{\beta}}\min _{\boldsymbol{x}} \mathcal{L}(\boldsymbol{x}, \boldsymbol{\alpha}, \boldsymbol{\beta})\)&lt;/span&gt; 一定小于等于 不等式右边的 &lt;span class=&quot;math inline&quot;&gt;\(\min _{\boldsymbol{x}} \max _{\boldsymbol{\alpha}, \boldsymbol{\beta}} \mathcal{L}(\boldsymbol{x}, \boldsymbol{\alpha}, \boldsymbol{\beta})\)&lt;/span&gt; ，这就是所谓的 ”极小的极大 &lt;span class=&quot;math inline&quot;&gt;\(\leqslant\)&lt;/span&gt; 极大的极小“ 。&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\((3.2)\)&lt;/span&gt; 式是不等式，所以该性质被称为弱对偶性 (weak duality)。若要等式成立，则为强对偶性 (strong duality)，需要满足 slater 条件：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(\text{slater}\)&lt;/span&gt; 条件： 原始问题为凸优化问题，即 &lt;span class=&quot;math inline&quot;&gt;\(f(\boldsymbol{x})\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(g(\boldsymbol{x})\)&lt;/span&gt; 为凸函数，&lt;span class=&quot;math inline&quot;&gt;\(h(\boldsymbol{x})\)&lt;/span&gt; 为仿射函数，且可行域中至少有一点使不等式约束严格成立时，强对偶性成立，对偶问题等价于原始问题。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;最后，利用强对偶性求出的 &lt;span class=&quot;math inline&quot;&gt;\(\boldsymbol{x}, \boldsymbol{\alpha}, \boldsymbol{\beta}\)&lt;/span&gt; 同时也是原始问题的最优解，所以依然满足 KKT 条件：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{cases} 原始问题可行: &amp;amp; g_i(\boldsymbol{x}) \leqslant 0, \;{h_{j}(\boldsymbol{x}) = 0} \\[1ex] 对偶问题可行: &amp;amp; \alpha_i \geqslant 0 \\[1ex] 互补松弛: &amp;amp; \alpha_i g_i(\boldsymbol{x}) = 0 \\[1ex] 拉格朗日平稳性: &amp;amp; \nabla_{\boldsymbol{x}}\mathcal{L}(\boldsymbol{x}, \boldsymbol{\alpha}, \boldsymbol{\beta}) = 0 \end{cases} \]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;/&lt;/p&gt;
</description>
<pubDate>Sat, 04 May 2019 11:22:00 +0000</pubDate>
<dc:creator>massquantity</dc:creator>
<og:description>接下来准备写支持向量机，然而支持向量机和其他算法相比牵涉较多的数学知识，其中首当其冲的就是标题中的拉格朗日乘子法、KKT条件和对偶问题，所以本篇先作个铺垫。 大部分机器学习算法最后都可归结为最优化问题</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/massquantity/p/10807311.html</dc:identifier>
</item>
<item>
<title>.NET作品集：基于svn 的.net 持续集成工具 - 叶鹏</title>
<link>http://www.cnblogs.com/jqbird/p/donetci.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jqbird/p/donetci.html</guid>
<description>&lt;p&gt;这个.net 持续集成作品还是在2014年的时候从事.net 软件项目开发的时候做的，当时部门还用着vs2008用vb.net做项目(现在也是)，项目代码极混乱，版本工具用的vss，而且用的不怎么顺，很多时候发布项目版本还是通过邮件发送代码vs工具手工编译打包的，并且安排了一个所谓的中高级.net开发人员每天的事情就是坐在那通过邮件收代码合并代码，打包编译，这个人请假了其他人还不会打包，主要是整个代码太乱了，只能部门经理打包，想想当年部门经理每天加班合并邮件里的开发代码的时候，觉得都不可思议，甚至有一次一个开发主管打包因为打包的时候代码的时候少发了一个页面文件并且上线到客户生产环境了，直接导致生产故障，被客户投诉，直接扣了20%绩效，而且每次我改完代码提交的时候经常少发文件，被管理员批。&lt;/p&gt;
&lt;p&gt;实在忍不住了跟这个版本管理员说“你就不能写个工具自动打包，哪怕弄个批处理也行啊”&lt;/p&gt;
&lt;p&gt;得到的答复是“你会写你写啊”，这样的产品研发部门我也是醉了。&lt;/p&gt;
&lt;p&gt;吃饭的时候跟部门经理聊到工具对提高生产力的问题的时候，我说我实在忍受不了公司的技术现状了，需要将部门vss工具替换到svn，引入一个持续集成工具或者做个自动打包脚本，部门经理跟我来了一句 “关键是管理流程，工具只是手段而已” ，当时就震惊石化了，部门的技术管理水平都烂成这样了还跟我谈管理，虽然心里一万草泥马奔腾，但是当时还是有勇气担当和闯进的，哪怕是用vss也要把持续集成工具做出来。&lt;/p&gt;

&lt;p&gt;领导还没同意用svn，还得用vss，最后发现vss的第三方接口开发实在问题太多了，几乎寸步难行，仅仅调通了代码获取，提交日志都获取不到。最后终于说服部门领导采用svn来管理代码了，并且同意我做这个持续集成工具，虽然我知道用git更好，但是我清楚公司开发的认知水平和技能，能够成功转到svn就不易了，话说当时三十几人没有一个会用git，要不也直接用git了。&lt;/p&gt;
&lt;p&gt;当时我已经知道有jenkins这样优秀的持续集成工具了，但是由于这个工具是基于java开发的，二次扩展方面对我们团队还是比较困难，想想自己如果能够持续造一个轮子把公司的开发管理平台一点点做出来，从需求bug管理、到需求评审、版本打包，版本发布一整套全做完善，也应该是很有意思的事情，如是带着个毕业生就开始干起来了。&lt;/p&gt;
&lt;p&gt;做的过程是没人能理解我在干什么，刚开始做出来的东西也是不太稳定，测试人员打包的时候就吐槽“什么烂东西”，最终大概花了2周时间把部门整个从vss切换到svn，并且这个工具已经基本可以使用了，并且花了很大精力把代码库从900多M缩减到100M以下，这个也是纯粹清理垃圾的活，很多项目上定制的代码没用了，都在主版本里，直接弄一各backup文件夹把工程代码放进去，而且一个项目模块方一个，而且是大量的重复，最后不得不写一个批处理来清理。&lt;/p&gt;
&lt;p&gt;最终工具还是做出来了，直接导致版本管理员这个古老的角色“失业”，安排写代码去了，并且领导又要求把需求管理和需求评审的登记功能做出来了，前后估计花了将近一个月时间，最终需求评审功能没啥鸟用，实行了一段时间后废弃。&lt;/p&gt;
&lt;p&gt;年底进行公司创新大赛评比的时候竟然入选了，当时让我先找个工具报告ppt的时候，内心也是排斥的，这都能算得上创新，只是重复造了个轮子罢了，到年会上竟然在那么热闹的场合介绍这玩意，看到其他小伙伴的创新更是天马行空的ppt之后，还是觉得不管多少还是为公司做了点实事，并且发了2000块钱辛苦费，心想这么简单的东西节省一个岗位成本加时间成本一年好歹有几十万吧，可见创新对公司确实是件好事，但是对个人的价格(不是价值)其实还很低廉的。&lt;/p&gt;

&lt;p&gt;这个作品的最终的展示如下&lt;/p&gt;
&lt;p&gt;产品首页，这个页面非常简单，连分页都没有，就是列出所有项目，而且最新发包的项目在最上面。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/94489/201905/94489-20190504150422548-587479901.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;项目管理首页，列出所有的项目清单，并且项目配置页面可以配置项目的svn地址，以及项目的基本信息。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/94489/201905/94489-20190504150738612-1746215395.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;单个项目的版本发布列表，这个界面是核心操作模块，通过点击版本发布可以发布测试版本和正式版本，并且2个版本是基于正式的代码svn分支和测试的分支，代码测试完成后再合并到正式分支发布正式版本，足够简单，老少皆宜。&lt;/p&gt;
&lt;p&gt;如果打包失败可以通过“查看日志”来查看编译失败的原因，通过“查看备注”可以查看提交的代码的提交记录和操作人，并且发布成功后才可以下载，由于这个东西还在用着，所以需要马克一下。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/94489/201905/94489-20190504151212411-1094100355.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;发布统计功能，这个功能也是当时领导比较关注的，看到有这么好的工具，赶紧搞一个统计，可以根据这个来做考核（为啥领导的思维都是啥都想到考核呢），做了一个非常好用的报表工具，那就是直接在页面上写sql统计代码（O(∩_∩)O）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/94489/201905/94489-20190504152215588-1860190451.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码打包控制台程序，没有在web页面实现jenkins那样的控制台程序，偷懒的方式在控制台程序里进行svn代码的获取以及调用系统的winrar软件来实现打包。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/94489/201905/94489-20190504153148789-1580807603.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这个持续集成工具实现的时候并没有太多参考jenkins，而是根据现有的技术空间和时间，快速的把每天人肉发包的问题解决掉。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/94489/201905/94489-20190504162053083-1935290266.png&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;技术栈&quot;&gt;技术栈&lt;/h2&gt;
&lt;ul readability=&quot;-0.97987927565392&quot;&gt;&lt;li&gt;.net framework 4.0&lt;/li&gt;
&lt;li&gt;.net mvc3&lt;/li&gt;
&lt;li&gt;sqlserver 2005&lt;/li&gt;
&lt;li&gt;razor 模板引擎&lt;/li&gt;
&lt;li&gt;dapper 轻量级orm框架&lt;/li&gt;
&lt;li&gt;vs2010 社区版本(现在换2017打开了)&lt;/li&gt;
&lt;li&gt;SharpSvn (svn接口)&lt;/li&gt;
&lt;li&gt;MsBuild （编译工具)&lt;/li&gt;
&lt;li&gt;winrar （压缩工具)&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;h2 id=&quot;代码结构&quot;&gt;代码结构&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/94489/201905/94489-20190504145529251-2002217192.png&quot;/&gt;&lt;br/&gt;从上之下分为以下工程目录结构：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Test&lt;/code&gt; 用于开发时候的单元测试&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Utry.CI&lt;/code&gt; Web应用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Utry.CIConsole&lt;/code&gt; 控制台应用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Utry.Core&lt;/code&gt; 业务层代码(采用领域架构模式)&lt;/li&gt;
&lt;li readability=&quot;-0.89473684210526&quot;&gt;
&lt;p&gt;&lt;code&gt;Utry.Framework&lt;/code&gt; 框架基础类库，其实都来自自己之前开发的cms程序里 &lt;a href=&quot;https://github.com/robotbird/jqpress.cms&quot;&gt;jqpres.cms&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;数据结构如下&quot;&gt;数据结构如下&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/94489/201905/94489-20190504173749015-758826244.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;CICheckItem&lt;/code&gt; 需求记录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CICodeLog&lt;/code&gt; 好像没用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CICodeMenu&lt;/code&gt; 不知道干啥的，好像没用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CIConfig&lt;/code&gt; 好像没用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CILog&lt;/code&gt; 版本发布的代码提交日志&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CIProjiect&lt;/code&gt; 项目表&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CIRelease&lt;/code&gt; 版本发布表&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CIReport&lt;/code&gt; 报表配置表&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CIReview&lt;/code&gt; 需求评审表&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CIReviewProblem&lt;/code&gt; 需求评审记录表&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CIUser&lt;/code&gt; 用户管理表&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CIUserOrg&lt;/code&gt; 组织管理表&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CIVersionPlan&lt;/code&gt; 版本发布计划&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;编译配置脚本&quot;&gt;编译配置脚本&lt;/h2&gt;
&lt;p&gt;这个脚本就是MsBuild 调用的脚本，其中{SlnName}为项目的 sln文件地址，项目会跟进配置信息进行替换。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;Project  xmlns=&quot;http://schemas.microsoft.com/developer/msbuild/2003&quot;&amp;gt;

&amp;lt;Import Project=&quot;$(MSBuildToolsPath)\Microsoft.CSharp.targets&quot; /&amp;gt;

  &amp;lt;PropertyGroup&amp;gt;
        &amp;lt;VName&amp;gt;{BranchName}_Release&amp;lt;/VName&amp;gt;
        &amp;lt;WebAppOutput&amp;gt;..\WebAppPublished&amp;lt;/WebAppOutput&amp;gt;
         &amp;lt;WebSiteOutput&amp;gt;..\WebSitePublished&amp;lt;/WebSiteOutput&amp;gt;
   
  &amp;lt;/PropertyGroup&amp;gt;

&amp;lt;ItemGroup&amp;gt;  
  &amp;lt;MySourceFiles Include=&quot;web\**\*.dll;web\**\*.aspx;web\**\*.js;web\**\*.css;web\**\*.jpg;web\**\*.config;web\**\*.gif;web\**\*.config;web\**\*.png;web\**\*.ascx;&quot;/&amp;gt;
&amp;lt;/ItemGroup&amp;gt; 

  &amp;lt;Target Name=&quot;build&quot;&amp;gt;
    &amp;lt;MsBuild Projects=&quot;{SlnName}&quot; Targets=&quot;$(BuildCmd)&quot; /&amp;gt;
   &amp;lt;/Target&amp;gt;
   
&amp;lt;/Project&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;调用winrar压缩打包部分代码&quot;&gt;调用winrar压缩打包部分代码&lt;/h2&gt;
&lt;p&gt;代码会通过根据注册表里是否有winrar安装信息，然后找到路径进行调用。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        /// &amp;lt;summary&amp;gt;  
        /// 生成Zip  
        /// &amp;lt;/summary&amp;gt;  
        /// &amp;lt;param name=&quot;path&quot;&amp;gt;文件夹路径&amp;lt;/param&amp;gt;  
        /// &amp;lt;param name=&quot;rarPath&quot;&amp;gt;生成压缩文件的路径&amp;lt;/param&amp;gt;  
        /// &amp;lt;param name=&quot;rarName&quot;&amp;gt;生成压缩文件的文件名&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;ignore&quot;&amp;gt;忽略的文件&amp;lt;/param&amp;gt;
        public static void CompressRar(String path, String rarPath, String rarName,string ignore)
        {
            try
            {
                String winRarPath = null;
                if (!ExistsRar(out winRarPath)) return;//验证WinRar是否安装。  

                //var pathInfo = String.Format(&quot;a -afzip -m0 -ep1 \&quot;{0}\&quot; \&quot;{1}\&quot;&quot;, rarName, path);
                var pathInfo = String.Format(&quot;a {2} -k -r -s -ep1  \&quot;{0}\&quot; \&quot;{1}\&quot;&quot;, rarName, path,ignore);

                #region WinRar 用到的命令注释

                //[a] 添加到压缩文件  
                //afzip 执行zip压缩方式，方便用户在不同环境下使用。（取消该参数则执行rar压缩）  
                //-m0 存储 添加到压缩文件时不压缩文件。共6个级别【0-5】，值越大效果越好，也越慢  
                //ep1 依名称排除主目录（生成的压缩文件不会出现不必要的层级）  
                //r   修复压缩档案  
                //t   测试压缩档案内的文件   
                //as  同步压缩档案内容    
                //-p  给压缩文件加密码方式为：-p123456  

                #endregion

                //打包文件存放目录  
                var process = new Process
                {
                    StartInfo = new ProcessStartInfo
                    {
                        FileName = winRarPath,//执行的文件名  
                        Arguments = pathInfo,//需要执行的命令  
                        UseShellExecute = false,//使用Shell执行  
                        WindowStyle = ProcessWindowStyle.Hidden,//隐藏窗体  
                        WorkingDirectory = rarPath,//rar 存放位置  
                        CreateNoWindow = true,//不显示窗体  
                    },
                };
                process.Start();//开始执行  
                process.WaitForExit();//等待完成并退出  
                process.Close();//关闭调用 cmd 的什么什么  
            }
            catch (Exception ex)
            {
                throw ex;
            }
        }&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/robotbird/donetci&quot; class=&quot;uri&quot;&gt;https://github.com/robotbird/donetci&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;为了防止部分同学无法访问Github，所以放oschina的gitee上了&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/robotbirdold/donetci&quot; class=&quot;uri&quot;&gt;https://gitee.com/robotbirdold/donetci&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;由于这个工具是根据当时的项目管理模式非常定制的，没有完全产品化的去做，况且现在jenkins已经非常好用了，这个轮子权大家学习(观摩)使用，如果真的谁有兴趣再想把这个轮子用起来，请微信robotbird798联系我吧，事隔这么多年才把这些东西发出来，初心还是对技术的不舍，在这个公司这么多年被安排着和妥协着从.net开发主管-&amp;gt;项目经理-&amp;gt;java开发-&amp;gt;产品经理-&amp;gt;部门经理-&amp;gt;? 的曲折之路，忽然发现人生走了很多的弯路，以前把大把的时间和热情奉献给公司，如今到了中年危机之时，才发现不过是炮灰，没有赢得一场战争，如今只能收拾残破的灵魂，重整旗鼓，为自己而战，为心中那份不灭的理想而战，前途不知道会怎样，但又如何呢，只要勤奋不至于不能养家糊口，至少为理想战斗过。&lt;/p&gt;
</description>
<pubDate>Sat, 04 May 2019 10:50:00 +0000</pubDate>
<dc:creator>叶鹏</dc:creator>
<og:description>作品背景 这个.net 持续集成作品还是在2014年的时候从事.net 软件项目开发的时候做的，当时部门还用着vs2008用vb.net做项目(现在也是)，项目代码极混乱，版本工具用的vss，而且用的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jqbird/p/donetci.html</dc:identifier>
</item>
<item>
<title>OceanBase分区表有什么不同？ - mq4096</title>
<link>http://www.cnblogs.com/mq44944/p/obparttable.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mq44944/p/obparttable.html</guid>
<description>&lt;p&gt; 分区表是ORACLE从8.0开始引入的功能，也是第一个支持物理分区的数据库，随后其他数据库纷纷跟进。分区表是一种“分而治之”的思想，通过将大表、索引分成可以独立管理的、小的片段(&lt;code&gt;Segment&lt;/code&gt;)，为海量数据访问提供了可伸缩的性能。自从 Oracle 引入分区技术以来，Oracle 公司在每次推出重要版本时都会对分区方法或功能上有所增强。在ORACLE 12c之前，ORACLE分区表始终在一个实例范围内，无法突破实例的存储空间瓶颈，12c之后ORACLE SHARDING 支持分区表的不同分区可以分布在不同的ORACLE实例里。这实际上是ORACLE吸收了其他分布式数据库中间件的优点而做的一个改进。&lt;/p&gt;
&lt;p&gt;OceanBase是阿里巴巴和蚂蚁金服完全自主研发的通用的分布式关系型数据库，从1.0版本开始OceanBase就支持分区表，功能逐步跟ORACLE分区表兼容，并且支持不同分区分布在集群的不同节点(机器)上。本文是对OceanBase分区表的能力做一个详细介绍。&lt;/p&gt;


&lt;p&gt;虽然“分区”的概念不是很新，但是“分区”对理解OceanBase的很多原理却是非常重要的。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;分区是一种水平拆分方案&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;从水平拆分设计上说，目前分布式数据库产品里有三种拆分途径。一是以Google、TiDB为代表的在存储层按定长块切片的，称为&lt;code&gt;Region&lt;/code&gt;，拆分细节对业务完全透明。二是以ORACLE、OceanBase为代表的使用分区表的多分区拆分，业务需要指定拆分策略和分片数，使用上基本上跟单表一样。三是以DRDS、TDSQL等为代表的分布式数据库中间件的分库分表拆分，业务使用的是一个逻辑表，实际数据存放在多个结构相同命名或位置不同的物理表上。&lt;/p&gt;
&lt;p&gt;OceanBase里一个非分区表只有一个分区，一个分区表有多个分区。&lt;strong&gt;分区就是表的子集。&lt;/strong&gt;OceanBase里单个分区只能在一个节点上，不同分区可以在不同节点上。&lt;/p&gt;
&lt;p&gt;分区的好处有：&lt;/p&gt;
&lt;ol class=&quot;list-paddingleft-2&quot; readability=&quot;2&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;提高可扩展性。分区表的不同分区可以分布在不同的机器上，使得单表能获得多机的处理能力，并且使得单表的容量可以超过单机的容量。性能也是同理。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;提高可管理性。对于数据操作的粒度可以控制在单个分区。例如按照时间分区的数据，可以通过drop一个分区来实现数据过期功能。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;提高性能。通过分区裁剪，可以快速定位到用户需要查询的分区。提高查询性能。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;&lt;strong&gt;分区是数据同步的最小单元&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;在OceanBase里，每个数据有三份，每个具体的分区也有三份，分布在不同的Zone里的不同节点上。每个分区有三份副本，副本内容相同，角色上有区分，是1个&lt;code&gt;leader&lt;/code&gt;副本和2个&lt;code&gt;follower&lt;/code&gt;副本。有时候会简单说1个主副本2个备副本。但是主备的概念容易引起误解。&lt;/p&gt;
&lt;p&gt;默认业务只有&lt;code&gt;leader&lt;/code&gt;副本提供读写服务，&lt;code&gt;follower&lt;/code&gt;副本只同步数据，不提供服务。特殊场景下，业务SQL使用弱一致性读Hint(即&lt;code&gt;read_consistency(weak)&lt;/code&gt;)可以就近读取&lt;code&gt;follower&lt;/code&gt;副本。此外&lt;code&gt;OBProxy&lt;/code&gt;的&lt;code&gt;LDC&lt;/code&gt;设置也可以做到就近读取某个合适的&lt;code&gt;follower&lt;/code&gt;副本(这个以后再细说)。数据的变更在&lt;code&gt;leader&lt;/code&gt;副本，事务提交的时候，&lt;code&gt;leader&lt;/code&gt;副本会就&lt;code&gt;Redo&lt;/code&gt;落盘发起表决，使用&lt;code&gt;Paxos&lt;/code&gt;协议。具体就是除了自己把&lt;code&gt;Redo&lt;/code&gt;落盘，同时还发往两个&lt;code&gt;follower&lt;/code&gt;副本，&lt;code&gt;follower&lt;/code&gt;副本收到&lt;code&gt;redo&lt;/code&gt;落盘后表决“成功”。同时&lt;code&gt;Follower&lt;/code&gt;副本开始应用该&lt;code&gt;Redo&lt;/code&gt;。三副本里只要有一半以上成员(2个副本)表决落盘成功，&lt;code&gt;leader&lt;/code&gt;副本上的业务的事务就提交成功返回消息给客户端。&lt;/p&gt;
&lt;p&gt;每个分区的三副本组成一个独立的&lt;code&gt;Paxos&lt;/code&gt;小组，相应的&lt;code&gt;Redo&lt;/code&gt;在副本之间传输。所以说分区是数据同步的最小单元。并且这种&lt;code&gt;Redo&lt;/code&gt;同步是自动的，不需要也不能干预的。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;分区是高可用的最小单元&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;每个分区的三副本会保持数据同步，目地是为了保证在&lt;code&gt;Leader&lt;/code&gt;副本不可用的时候选举出新的&lt;code&gt;Leader&lt;/code&gt;副本拥有全部的数据。&lt;code&gt;Paxos&lt;/code&gt;协议保证了&lt;code&gt;Redo&lt;/code&gt;会在至少一个&lt;code&gt;Follower&lt;/code&gt;副本里有(最终会所有&lt;code&gt;Follower&lt;/code&gt;副本都有)。三副本会跟OceanBase集群的&lt;code&gt;rootservice&lt;/code&gt;服务维持心跳，当&lt;code&gt;Leader&lt;/code&gt;副本不可用时，经过2个租约时间后&lt;code&gt;rootservice&lt;/code&gt;会选举出新的&lt;code&gt;Leader&lt;/code&gt;出来，在应用完&lt;code&gt;Redo&lt;/code&gt;后新&lt;code&gt;Leader&lt;/code&gt;提供读写服务。&lt;/p&gt;
&lt;p&gt;分区的选举是自动的，只要多数派存活，就不需要人工介入。所以说“分区”是高可用的最小单元。OceanBase的“切换”指的就是一个个&lt;code&gt;Leader&lt;/code&gt;分区重新选举的过程，并不是实例级别的“切换”。当一个机器节点挂掉后， 严格的说，其影响只是局部的数据(&lt;code&gt;Leader&lt;/code&gt;副本)的读写访问短暂中断)。在OceanBase里，一般不会说某台机器是主，某台机器是备，因为理论上所有的机器都可能存在&lt;code&gt;Leader&lt;/code&gt;副本，都能提供读写服务。&lt;/p&gt;


&lt;h2&gt; &lt;strong&gt;分区键&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;数据表中每一行中用于计算这一行属于哪一个分区的列的集合叫做分区键。由分区键构成的用于计算这一行属于哪一个分区的表达式叫做分区表达式。&lt;/p&gt;
&lt;p&gt;由于OceanBase的表是索引组织表(&lt;code&gt;IOT&lt;/code&gt;)，为了保证主键的含义：给定主键的查询能很快定位到所在的分区。所以分区键必须是主键的子集。如果这个表里面还含有唯一索引，那么分区键就必须是所有唯一索引列（包括主键列）交集的子集。&lt;/p&gt;
&lt;p&gt;Oracle的&lt;code&gt;IOT&lt;/code&gt;表和索引分区也有这个要求，堆表没这个要求。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;索引&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;分区表的索引分局部索引和全局索引。&lt;/p&gt;
&lt;p&gt;局部索引是局限在单个分区内的索引。对于非分区的普通表，它的索引存储是整个表的行按照索引键进行排序后的结果。对于分区表的局部索引是每个分区分别自己存储自己的行按照索引键进行排序后的结果，不是全局有序的。创建语句中需要带&lt;code&gt;local&lt;/code&gt;关键字，举个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt; `sbtest` (
`id` &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt; AUTO_INCREMENT,
`k` &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
`c` &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;(&lt;span&gt;120&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;''&lt;/span&gt;&lt;span&gt;,
`pad` &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;(&lt;span&gt;60&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;''&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;PRIMARY&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt;&lt;span&gt; (`id`, k)
) PARTITION &lt;/span&gt;&lt;span&gt;BY&lt;/span&gt; HASH(k) PARTITIONS &lt;span&gt;8&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;INDEX&lt;/span&gt; k_ind1 &lt;span&gt;ON&lt;/span&gt; `sbtest`(`k`) LOCAL;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;OceanBase 1.x版本由于不支持“全局一致性快照”功能，所以只支持局部索引，不支持全局索引。OceanBase 2.x版本支持全局索引。去掉上面的&lt;code&gt;LOCAL&lt;/code&gt;关键字就是全局索引。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;分区模式&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;根据数据分区的策略，分为三大类：&lt;/p&gt;
&lt;ol class=&quot;list-paddingleft-2&quot; readability=&quot;-1&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;code&gt;hash&lt;/code&gt;分区/&lt;code&gt;key&lt;/code&gt;分区。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;range&lt;/code&gt;分区/&lt;code&gt;range columns&lt;/code&gt;分区。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;list&lt;/code&gt;分区/&lt;code&gt;list columns&lt;/code&gt;分区。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;按照分区的维度，可以分为：&lt;/p&gt;
&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;
&lt;p&gt;一级分区。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;二级分区。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;二级分区是一级分区的二次拆分。所以一级分区有一个拆分键，二级分区有两个拆分键，并且两次拆分的策略可以不一样。&lt;/p&gt;
&lt;p&gt;二级分区支持下面几种分区策略组合：&lt;/p&gt;
&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;code&gt;hash&lt;/code&gt;&lt;span&gt; +&lt;span&gt; &lt;code&gt;hash&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;hash&lt;/code&gt;&lt;span&gt; +&lt;span&gt; &lt;code&gt;range&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;hash&lt;/code&gt;&lt;span&gt; +&lt;span&gt; &lt;code&gt;key&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;key&lt;/code&gt;&lt;span&gt; +&lt;span&gt; &lt;code&gt;key&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;range&lt;/code&gt;&lt;span&gt; +&lt;span&gt; &lt;code&gt;range&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;&lt;strong&gt;&lt;code&gt;hash&lt;/code&gt;分区&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Hash分区需要指定分区键和分区个数。通过hash的分区表达式计算得到一个整数，这个结果再跟分区个数取模得到具体这行数据属于那个分区。通常用于给定分区键的点查询，例如按照用户id来分区。hash分区通常能消除热点查询。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt; `sbtest` (
  `id` &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt; AUTO_INCREMENT,
  `k` &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  `c` &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;(&lt;span&gt;120&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;''&lt;/span&gt;&lt;span&gt;,
  `pad` &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;(&lt;span&gt;60&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;''&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;PRIMARY&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt;&lt;span&gt; (`id`, k)
) PARTITION &lt;/span&gt;&lt;span&gt;BY&lt;/span&gt; HASH(k) PARTITIONS &lt;span&gt;8&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;hash分区表达式不支持向量，即不支持 &lt;code&gt;hash by (c1,c2)&lt;/code&gt;。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;&lt;code&gt;key&lt;/code&gt;分区&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;key分区跟hash分区类似，也是通过对分区个数取模的方式来确定数据属于哪个分区。不同的是系统会对key分区键做一个内部默认默认的hash函数后再取模。所以用户通常没有办法自己通过简单的计算来得知某一行属于哪个分区。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt; `sbtest_x1` (
`id` &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt; AUTO_INCREMENT,
`k` &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
`c` &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;(&lt;span&gt;120&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;''&lt;/span&gt;&lt;span&gt;,
`pad` &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;(&lt;span&gt;60&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;''&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;PRIMARY&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt;&lt;span&gt; (`id`, c)
) PARTITION &lt;/span&gt;&lt;span&gt;BY&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt;(c) PARTITIONS &lt;span&gt;8&lt;/span&gt;; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;key&lt;/code&gt;分区跟&lt;code&gt;hash&lt;/code&gt;分区的区别：&lt;/p&gt;
&lt;ol class=&quot;list-paddingleft-2&quot; readability=&quot;-1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;hash&lt;/code&gt;分区表达式结果必须是整数，&lt;code&gt;key&lt;/code&gt;分区没有这个要求，支持字符列。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;hash&lt;/code&gt;分区的分区键支持表达式，&lt;code&gt;key&lt;/code&gt;分区不支持。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;&lt;strong&gt;&lt;code&gt;range&lt;/code&gt;分区和&lt;code&gt;range columns&lt;/code&gt;分区&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;range分区是按照分区表达式的范围来划分分区。通常用于对分区键需要按照范围的查询。例如通过按照时间字段进行范围分区，还有价格区间等一些分区方式。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;create&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; t1 (c1 &lt;span&gt;int&lt;/span&gt;, c2 &lt;span&gt;int&lt;/span&gt;&lt;span&gt;) 
partition &lt;/span&gt;&lt;span&gt;by&lt;/span&gt;&lt;span&gt; range(c1) (
partition p0 &lt;/span&gt;&lt;span&gt;values&lt;/span&gt; less than(&lt;span&gt;100&lt;/span&gt;&lt;span&gt;), 
partition p1 &lt;/span&gt;&lt;span&gt;values&lt;/span&gt; less than(&lt;span&gt;500&lt;/span&gt;&lt;span&gt;), 
partitions p2 &lt;/span&gt;&lt;span&gt;values&lt;/span&gt;&lt;span&gt; less than(maxvalue)
);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;range分区的限制和要求:&lt;/p&gt;
&lt;ol class=&quot;list-paddingleft-2&quot; readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;分区表达式的结果必须是整数类型。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;不能写向量，例如&lt;code&gt;partition by range(c1, c2)&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;range columns和range的区别是：&lt;/p&gt;
&lt;ol class=&quot;list-paddingleft-2&quot; readability=&quot;-1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;range columns分区不要求是整数，可以是任意类型。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;range columns分区不能写表达式，但是可以是向量。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;目前提供对&lt;code&gt;range&lt;/code&gt;分区的分区操作功能，能&lt;code&gt;add&lt;/code&gt;/&lt;code&gt;drop&lt;/code&gt;分区。&lt;code&gt;add&lt;/code&gt;分区现在只能加在最后，所以最后不能是maxvalue的分区。如果是maxvalue的分区要增加一个分区，只能做分区分裂(&lt;code&gt;split&lt;/code&gt;)。分区分裂还在研发中。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;&lt;code&gt;list&lt;/code&gt;分区和&lt;code&gt;list columns&lt;/code&gt;分区&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;list分区是根据枚举类型的值来划分分区的。主要用于枚举类型。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;create&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; t1 (c1 &lt;span&gt;int&lt;/span&gt;, c2 &lt;span&gt;int&lt;/span&gt;&lt;span&gt;) 
partition &lt;/span&gt;&lt;span&gt;by&lt;/span&gt;&lt;span&gt; list(c1) (
partition p0 &lt;/span&gt;&lt;span&gt;values&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; (&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;&lt;span&gt;), 
partition p1 &lt;/span&gt;&lt;span&gt;values&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; (&lt;span&gt;5&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt;&lt;span&gt;)， 
partition p2 &lt;/span&gt;&lt;span&gt;values&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; (&lt;span&gt;default&lt;/span&gt;&lt;span&gt;)
);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;list&lt;/code&gt;分区的限制和要求：&lt;/p&gt;
&lt;ol class=&quot;list-paddingleft-2&quot; readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;分区表达式的结果必须是整数。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;不能写向量，例如&lt;code&gt;partition by list(c1, c2)&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;list columns和list的区别是：&lt;/p&gt;
&lt;ol class=&quot;list-paddingleft-2&quot; readability=&quot;-1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;list columns&lt;/code&gt;分区不要求是整数，可以是任意类型。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;list columns&lt;/code&gt;分区不能写表达式，但可以是向量。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;&lt;strong&gt;二级分区&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;按照两个维度来把数据拆分成分区。&lt;br/&gt;最常用的地方就是类似用户账单领域，会按照user_id做hash分区，按照账单创建时间做range分区&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt; history_t(
&lt;/span&gt;&lt;span&gt;user_id&lt;/span&gt; &lt;span&gt;INT&lt;/span&gt;, gmt_create &lt;span&gt;DATETIME&lt;/span&gt;, info &lt;span&gt;VARCHAR&lt;/span&gt;(&lt;span&gt;20&lt;/span&gt;&lt;span&gt;), 
&lt;/span&gt;&lt;span&gt;PRIMARY&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt;(&lt;span&gt;user_id&lt;/span&gt;&lt;span&gt;, gmt_create))
PARTITION &lt;/span&gt;&lt;span&gt;BY&lt;/span&gt; HASH(&lt;span&gt;user_id&lt;/span&gt;&lt;span&gt;)
SUBPARTITION &lt;/span&gt;&lt;span&gt;BY&lt;/span&gt;&lt;span&gt; RANGE COLUMNS(gmt_create) 
SUBPARTITION TEMPLATE (
SUBPARTITION p0 &lt;/span&gt;&lt;span&gt;VALUES&lt;/span&gt; LESS THAN (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2014-11-11&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;), 
SUBPARTITION p1 &lt;/span&gt;&lt;span&gt;VALUES&lt;/span&gt; LESS THAN (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2015-11-11&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;), 
SUBPARTITION p2 &lt;/span&gt;&lt;span&gt;VALUES&lt;/span&gt; LESS THAN (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2016-11-11&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;), 
SUBPARTITION p3 &lt;/span&gt;&lt;span&gt;VALUES&lt;/span&gt;&lt;span&gt; LESS THAN (MAXVALUE)
)
PARTITIONS &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;; 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Oracle的二级分区支持每个一级分区的二级分区分区定义不一样。支持类似下面这种&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;create&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; t1 (c1 &lt;span&gt;int&lt;/span&gt;, c2 &lt;span&gt;int&lt;/span&gt;&lt;span&gt;) 
partition &lt;/span&gt;&lt;span&gt;by&lt;/span&gt;&lt;span&gt; range(c1) 
subpartition &lt;/span&gt;&lt;span&gt;by&lt;/span&gt;&lt;span&gt; hash(c2) (
partition p0 &lt;/span&gt;&lt;span&gt;values&lt;/span&gt; less than(&lt;span&gt;100&lt;/span&gt;&lt;span&gt;) (subpartition sp0), 
partition p1 &lt;/span&gt;&lt;span&gt;values&lt;/span&gt; less than(&lt;span&gt;200&lt;/span&gt;&lt;span&gt;) (subpartition sp2, subpartition sp3)
) ;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;一级分区p0下面有一个分区，而一级分区p1下面有两个分区。&lt;/p&gt;
&lt;p&gt;OceanBase暂时不支持这样的分区方式，必须用template的分区方式。这导致对于&lt;code&gt;range&lt;/code&gt;分区的分区操作&lt;code&gt;add&lt;/code&gt;/&lt;code&gt;drop&lt;/code&gt;，必须是&lt;code&gt;range&lt;/code&gt;分区做为一级分区的方式。所以强烈建议用&lt;code&gt;range + hash&lt;/code&gt;的分区方式，而不是&lt;code&gt;hash + range&lt;/code&gt;.&lt;/p&gt;


&lt;h2&gt;&lt;strong&gt;分区裁剪&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;当用户访问分区表时，往往只需要访问其中部分的分区。优化器根据SQL中所带的条件，避免访问无关分区的优化过程我们称之为“分区裁剪”(Partition Pruning)。分区裁剪是分区表提供的重要优化手段，通过分区的裁剪，SQL的执行效率可以得到大幅度的提升。用户可以利用分区裁剪的特性，在访问中加入定位分区的条件，避免访问无关数据，优化查询性能。&lt;/p&gt;
&lt;p&gt;分区裁剪本身是一个比较复杂的过程。优化器需要根据用户表的分区信息和SQL中给定的条件，抽取出相关的分区信息，由于SQL中的条件往往比较复杂，整个抽取逻辑的复杂性也随之增加，这一过程由OceanBase中的Query Range子模块完成。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
MySQL &lt;span&gt;[&lt;/span&gt;&lt;span&gt;sysbenchtest&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; explain &lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; sbtest &lt;span&gt;where&lt;/span&gt; k&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;264454&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\G
&lt;/span&gt;&lt;span&gt;***************************&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;. row &lt;span&gt;***************************&lt;/span&gt;&lt;span&gt;
Query &lt;/span&gt;&lt;span&gt;Plan&lt;/span&gt;: &lt;span&gt;=============================================&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;ID&lt;span&gt;|&lt;/span&gt;OPERATOR &lt;span&gt;|&lt;/span&gt;NAME &lt;span&gt;|&lt;/span&gt;EST. ROWS&lt;span&gt;|&lt;/span&gt;COST&lt;span&gt;|&lt;/span&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-------------------------------------------&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;&lt;span&gt;0&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;&lt;span&gt;TABLE&lt;/span&gt; SCAN&lt;span&gt;|&lt;/span&gt;sbtest(k_ind1)&lt;span&gt;|&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;&lt;span&gt;99&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;=============================================&lt;/span&gt;&lt;span&gt;

Outputs &lt;/span&gt;&lt;span&gt;&amp;amp;&lt;/span&gt;&lt;span&gt; filters:
&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-----------------------------------&lt;/span&gt;
&lt;span&gt;0&lt;/span&gt; &lt;span&gt;-&lt;/span&gt; output(&lt;span&gt;[&lt;/span&gt;&lt;span&gt;sbtest.id&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;, &lt;span&gt;[&lt;/span&gt;&lt;span&gt;sbtest.k&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;, &lt;span&gt;[&lt;/span&gt;&lt;span&gt;sbtest.c&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;, &lt;span&gt;[&lt;/span&gt;&lt;span&gt;sbtest.pad&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;), filter(nil),
access(&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;sbtest.k&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;, &lt;span&gt;[&lt;/span&gt;&lt;span&gt;sbtest.id&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;, &lt;span&gt;[&lt;/span&gt;&lt;span&gt;sbtest.c&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;, &lt;span&gt;[&lt;/span&gt;&lt;span&gt;sbtest.pad&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;), partitions(p6)

&lt;/span&gt;&lt;span&gt;1&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.01&lt;/span&gt; sec)
&lt;/pre&gt;&lt;/div&gt;



</description>
<pubDate>Sat, 04 May 2019 09:51:00 +0000</pubDate>
<dc:creator>mq4096</dc:creator>
<og:description>OceanBase是阿里巴巴和蚂蚁金服完全自主研发的通用的分布式关系型数据库，从1.0版本开始OceanBase就支持分区表，功能逐步跟ORACLE分区表兼容，并且支持不同分区分布在集群的不同节点(机</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mq44944/p/obparttable.html</dc:identifier>
</item>
</channel>
</rss>