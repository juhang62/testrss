<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>js闭包vs Java内部类 - 爱我-中华</title>
<link>http://www.cnblogs.com/jinliang374003909/p/10352464.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jinliang374003909/p/10352464.html</guid>
<description>&lt;p&gt;前言：&lt;/p&gt;
&lt;p&gt;       昨天写了一个关于Java内部的博客，在内部类的最后一点中谈到了Java闭包的概念，他是这样定义闭包的：&lt;span&gt;闭包是一个可调用的对象，它记录了一些信息，这些信息来自创建它的作用域。结合Java的内部类可以很好的理解这一点（如有需要可参考&lt;a href=&quot;https://www.cnblogs.com/jinliang374003909/p/10351877.html&quot; target=&quot;_blank&quot;&gt;ThinkInJava之内部类&lt;/a&gt;）。&lt;/span&gt;突然之间想到js中的闭包，一直都无法很好的理解，故借此又看了一下js中的闭包，对我个人而言，感悟良多，借此也与大家分享一下，希望可以帮助大家，并一起快乐的学习成长，天天向上。&lt;/p&gt;
&lt;h3&gt;零：js闭包概念（通过Java闭包和js嵌套函数和图一分析 ：纯个人 见解，欢迎评论和建议）&lt;/h3&gt;
&lt;p&gt;　　&lt;span&gt;js:闭包是一个返回给调用者的对象，而这个返回对象携带了一些调用者无法获取的信息&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;一：js中的对象定义（因为是针对闭包的学习就只简单介绍一种定义方法）　&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;script&amp;gt;
        &lt;span&gt;function&lt;/span&gt;&lt;span&gt; Car() { //定义class
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; color = &quot;blue&quot;&lt;span&gt;; //&lt;span&gt;定义属性&lt;/span&gt;
        }
        Car.prototype.getColor &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {  //&lt;span&gt;通过原型定义方法&lt;/span&gt;
            console.info(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.color) 
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.color;
        }
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; oCar1 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Car();//创建对象实例
        oCar1.getColor();  //调用方法
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;二：js中的变量作用域（全局变量和局部变量）&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; a = &quot;我是全局变量&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; myFunction() {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; b = &quot;我是局部变量&quot;  
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; a ;
}&lt;br/&gt;function my2(){&lt;br/&gt;　　consoke.info(b) #报错&lt;br/&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2.1  全局变量a&lt;/span&gt;：即属性window的属性，在同一页面内所有的js脚本，都共享同一个window对象，故共享全局变量a.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.2 局部变量b&lt;/span&gt; ：局部变量只能用于定义它函数内部。对于其他的函数或脚本代码是不可用的。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;备注：变量声明时如果不使用 &lt;strong&gt;var&lt;/strong&gt; 关键字，那么它就是一个全局变量，即便它在函数内定义。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;三：计数器困境（引入问题）　&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;解题思路：需要一个变量，这个变量需要在方法内访问并加一，多次调用该变量就是多次加一的和，故不能把该变量定义在方法的内部，如果把该变量定义在方法的内部就不能实现多次调用返回多次调用的和，故把该方法定义为全局变量如下，但这样定义该变量即不安全如调用方法2 &lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; counter = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; add() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; counter += 1&lt;span&gt;;
}
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; myFunction(){
    document.getElementById(&lt;/span&gt;&quot;demo&quot;).innerHTML =&lt;span&gt; add();
}
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; myFunction2(){
    counter &lt;/span&gt;= 100&lt;span&gt;;
    document.getElementById(&lt;/span&gt;&quot;demo&quot;).innerHTML =&lt;span&gt; add();
}
myFunction();
myFunction();//&lt;span&gt;实现多次调用返回，多次调用的和&lt;/span&gt;
##counter &lt;/span&gt;=2&lt;span&gt;
myFunction2();//&lt;span&gt;但如果调用该方法，就不返回多次调用的和   #因为是全局变量，任何脚本都可更改该变量的值，这样及其不不安全。&lt;/span&gt;
##counter &lt;/span&gt;=101
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;解题思路2:如果能把count变量隐藏起来不让其它js方法修改它不就行了吗？如果我们熟悉Java语言，用Java就很容易解决该问题。因为Java提供的修饰符private可以控制属性的访问限制。并定义一个唯一public方法设置该属性（就是把属性定义为私有的，并提供唯一的get和set方法，就这么简单）。然而如果把问题抛给js就很难解决这个问题了，以为js没有提供这样的修饰符，来控制访问属性。如何解决类似Java private成员的问题请看下面&lt;/p&gt;
&lt;h3&gt;&lt;em&gt;四&lt;/em&gt;：JS的 内嵌函数（类比Java内部类 ，我们发现嵌套函数及其的像Java的内部类😂）&lt;/h3&gt;
&lt;p&gt;　　JavaScript 支持嵌套函数。嵌套函数可以访问上一层的函数变量（我们可以这样理解：内部的变量可以访问其外面的变量，而外面的不能访问内部的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;一个简单的js嵌套函数&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; add() { //外部类
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; counter = 0&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; plus() { //嵌套函数   内部类
        counter &lt;/span&gt;+= 1&lt;span&gt;; //嵌套函数可以访问其外部的变量
    }
    plus();    
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; counter; 
}    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;类比Java ：Java内部类可以访问外围对象的所有属性包括私有属性，js的嵌套函数好行也有这个属性😄。&lt;/p&gt;
&lt;h3&gt;五：js立刻执行函数也叫函数的自我调用（顾名思义就是立刻执行），下面是一个立刻只能函数的写法　&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; aa =&lt;span&gt; (
        &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
            alert(&lt;/span&gt;&quot;sssss&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {};
        }
    )()
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;备注:当我们刷新当前页面时就会执行function方法并返回{}对象  //不需要手动调用该方法&lt;br/&gt;立即执行函数的写法有很多中以上是最常用的方式()(),下面也是立即函数的写法&lt;/span&gt;1 !function foo(){...}(); &lt;br/&gt;&lt;em id=&quot;__mceDel&quot;&gt;2 +function foo(){...}(); &lt;/em&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过立刻执行函数，并且返回一个空的对象，结合内嵌函数的特性，我们可知这个对象是可以访问外围的属性和方法的。&lt;/p&gt;
&lt;p&gt;然后我们分析：&lt;span&gt;利用嵌套函数和闭包的特性来分析下图&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
{&lt;span&gt;//&lt;/span&gt;&lt;span&gt;区域A（window）&lt;/span&gt;
    {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;区域B&lt;/span&gt;
         &lt;span&gt;return&lt;/span&gt; {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;区域C  &lt;/span&gt;
&lt;span&gt;             区域C返回到了区域A
        }
    }
}            &lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　图一&lt;/p&gt;
&lt;p&gt;结论如下&lt;/p&gt;
&lt;p&gt;1. &lt;span&gt;区域A不能访问区域B定义的数据&lt;/span&gt;，&lt;span&gt;故B就对A隐藏了&lt;/span&gt;。然而区域C可以访问区域B定义的数据，&lt;/p&gt;
&lt;p&gt;2&lt;span&gt;.区域C同过return返回给了区别A&lt;/span&gt;，如果区域C是一个方法，则A就可以调用这个方法，而这个方法是唯一能访问到B区域的(B提供了一个public方法共全局访问)。故B又提供了对A访问的方法。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这样就形成了一个js的闭包：（&lt;/span&gt;即闭包是一个返回给调用者的对象，而这个返回对象携带了一些调用者无法获取的信息）&lt;/p&gt;
&lt;p&gt;&lt;span&gt;备注：js方法也是对象&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;六：JS闭包，解决计数器困境&lt;/h3&gt;
&lt;p&gt;代码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; add = (&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; counter = 0&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt; () {&lt;span&gt;return&lt;/span&gt; counter += 1&lt;span&gt;;}
})();
 
add();
add();
add();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 计数器为 3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;备注1：js函数分类&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;函数声明&lt;/span&gt;：function fname(){...}; 使用function关键字声明一个函数，再指定一个函数名。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;函数表达式&lt;/span&gt;：var fname=function(){...}; 使用function关键字声明一个函数，但未给函数命名，最后将匿名函数赋予给一个变量。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;匿名函数&lt;/span&gt;：function(){}; 使用function关键字声明一个函数，但未给函数命名。（匿名函数也属于函数表达式。）&lt;/p&gt;
&lt;p&gt;&lt;span&gt;备注2：js解析机制&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　js:解析机制：分为编译和执行两个阶段。&lt;/p&gt;
&lt;p&gt;先编译：&lt;span&gt;有人也称预编译，js解析器会扫描整个js文件，把以var (定义变量)和function（定义方法）开头语句做变量提升。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;执行   ：&lt;span&gt;给定义的变量赋值，或执行相关方法（以括号‘()’结尾的语句，会当作方法来执行）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;利用js解析机制来来回答为什么函数会自我调用&lt;/p&gt;
&lt;p&gt;在执行阶段，js解析器发现该函数  1 : 没有以var或function开头。&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　　 2 : 并且以'()'括号结尾&lt;/p&gt;
&lt;p&gt;如果满足以上两个条件，没有特殊原因都会称为立刻执行函数。&lt;/p&gt;
&lt;p&gt;备注3: js立即执行函数 vs Java单例模式&lt;/p&gt;
&lt;p&gt;如果属性java的读者一定接触过单例模式：即一个应用系统中只允许拥有一个唯一的某个类型的实例对象，具体写法再次就不多介绍了。通过分析和观察立即执行函数，因为该函数的执行是在js解析器加载的时候执行的（可以类比为Java应用程序启动时加载单例），并且很难手动再次加载它（我是没有发现方法😄），故我们可以理解立即函数就是单例设计模型（没有研究过js的设计模型，也不知道有没有😄）。&lt;/p&gt;
&lt;p&gt;***************************************欢迎读者给出建议***********************************&lt;/p&gt;



</description>
<pubDate>Wed, 06 Feb 2019 16:00:00 +0000</pubDate>
<dc:creator>爱我-中华</dc:creator>
<og:description>前言： 昨天写了一个关于Java内部的博客，在内部类的最后一点中谈到了Java闭包的概念，他是这样定义闭包的：闭包是一个可调用的对象，它记录了一些信息，这些信息来自创建它的作用域。结合Java的内部类</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jinliang374003909/p/10352464.html</dc:identifier>
</item>
<item>
<title>学机器学习，不会数据分析怎么行——数据可视化分析(matplotlib) - iTryagain</title>
<link>http://www.cnblogs.com/csu-lmw/p/10354287.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/csu-lmw/p/10354287.html</guid>
<description>&lt;p&gt;前面两篇文章介绍了 python 中两大模块 pandas 和 numpy 的一些基本使用方法，然而，仅仅会处理数据还是不够的，我们需要学会怎么分析，毫无疑问，利用图表对数据进行分析是最容易的，通过图表可以很好地理解数据之间的关联性以及某些数据的变化趋势。因此，将在这篇博客中介绍 python 中可视化工具 matplotlib 的使用。&lt;/p&gt;

&lt;p&gt;matplotlib 的图像都位于 Figure 对象中，可以用 &lt;code&gt;plt.figure&lt;/code&gt; 创建一个新的 Figure&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot; lang=&quot;python&quot;&gt;fig = plt.figure()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;plt.figure&lt;/code&gt; 有一些选项，如 figsize(用于设置图片大小)。不能通过空 Figure 绘图，必须用 &lt;code&gt;add_subplot&lt;/code&gt; 创建一个或多个 subplot 才行&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot; lang=&quot;python&quot;&gt;ax1 = fig.add_subplot(2,2,1) # 2*2 的图像，选中的是4个subplot中的第一个
ax2 = fig.add_subplot(2,2,2)
ax3 = fig.add_subplot(2,2,3)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最终得到的图如下所示 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1413964/201902/1413964-20190206233545101-268485389.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 画三张图&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot; lang=&quot;python&quot;&gt;ax3.plot(np.random.randn(50).cumsum(),'k--') # k--表示线型
_ = ax1.hist(np.random.randn(100),bins=20,color='k',alpha=0.3)
ax2.scatter(np.arange(30),np.arange(30)+3*np.random.randn(30))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1413964/201902/1413964-20190206233549781-836653477.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 上图中只是三种图表类型，你可以在matplotlib的文档中找到各种图表类型。由于根据特定布局创建Figure和subplot是一件非常常见的任务，于是便出现了一个更为方便的方法 &lt;code&gt;plt.subplots&lt;/code&gt; ，它可以创建一个新的Figure，并返回一个含有已创建的subplot对象的NumPy数组&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot; lang=&quot;python&quot;&gt;fig, axes = plt.subplots(2,3)
axes&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1413964/201902/1413964-20190206233557870-1518563700.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 这种方法非常的实用，我们可以轻松对axes数据进行索引。我们还可以通过 &lt;code&gt;sharex&lt;/code&gt; 和 &lt;code&gt;sharey&lt;/code&gt; 指定 subplot 应该具有的X轴和Y轴。在比较相同范围的数据时，这也是非常实用的，否则，matplotlib 会自动缩放各图表的界限。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1413964/201902/1413964-20190206233615177-804830546.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;下面在介绍介绍如何添加图表的各个要素&lt;/p&gt;
&lt;h3&gt;标题、轴标签、刻度以及刻度标签&lt;/h3&gt;
&lt;p&gt;要修改X轴的刻度，最简单的方法是使用set_xticks和set_xticklabels。前者告诉matplotlib要将刻度放在数据范围中的哪些位置，默认情况下，这些位置也就是刻度标签。但我们可以通过set_xticklabels将任何其他的值作用于标签&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot; lang=&quot;python&quot;&gt;# 绘制一段随机漫步
fig = plt.figure()
ax = fig.add_subplot(1,1,1)
ax.plot(np.random.randn(1000).cumsum())
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1413964/201902/1413964-20190206233620878-2039856459.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot; lang=&quot;python&quot;&gt;ticks = ax.set_xticks([0,250,500,750,1000])
labels = ax.set_xticklabels(['one','two','three','four','five'])
ax.set_title('My first matplotlib plot')
ax.set_xlabel('stages')
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1413964/201902/1413964-20190206233633172-80521495.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt; 图例&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot; lang=&quot;python&quot;&gt;ax.plot(np.random.randn(1000).cumsum(),label = 'one')
ax.plot(np.random.randn(1000).cumsum(),'k--',label='two')
ax.plot(np.random.randn(1000).cumsum(),'k.',label='three')
ax.legend(loc='best') # loc 告诉matplotlib要将图例放在哪 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1413964/201902/1413964-20190206233639474-1956812267.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt; 注释&lt;/h2&gt;
&lt;p&gt;除标准的图标对象之外，你可能还希望绘制一些自定以的注解（比如文本、箭头或其他图形等）&lt;br/&gt;注解可以通过 &lt;code&gt;text&lt;/code&gt;, &lt;code&gt;arrow&lt;/code&gt;和&lt;code&gt;annotate&lt;/code&gt;等函数进行添加。&lt;code&gt;text&lt;/code&gt;可以将文本绘制在图表的指定坐标 (x,y)​ ，还可以加上一些自定以格式&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot; lang=&quot;python&quot;&gt;ax.text(x,y,'Hello World!', family='monospace', fontsize=10, verticalalignment=&quot;top&quot;, horizontalalignment=&quot;right&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;x,y:表示坐标值上的值&lt;br/&gt;string:表示说明文字&lt;br/&gt;fontsize:表示字体大小&lt;br/&gt;verticalalignment：垂直对齐方式 ，参数：[ ‘center’ | ‘top’ | ‘bottom’ | ‘baseline’ ]&lt;br/&gt;horizontalalignment：水平对齐方式 ，参数：[ ‘center’ | ‘right’ | ‘left’ ]  &lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot; lang=&quot;python&quot;&gt;x1 = np.random.normal(30, 3, 100)
x2 = np.random.normal(20, 2, 100)

plt.plot(x1, label = 'plot')
plt.plot(x2, label = '2nd plot')
plt.legend(bbox_to_anchor=(0., 1.02, 1., .102), loc=2,
           ncol=2, mode='expand', borderaxespad=0.)
plt.annotate('Important value', (55,20),
             xycoords='data',
             xytext=(5,38),
             arrowprops = dict(arrowstyle = '-&amp;gt;'))

plt.show()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1413964/201902/1413964-20190206233650466-1077335218.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; annotate(s='str' ,xy=(x,y) ,xytext=(l1,l2) ,..)&lt;/p&gt;
&lt;p&gt;s 为注释文本内容&lt;br/&gt;xy 为被注释的坐标点&lt;br/&gt;xytext 为注释文字的坐标位置&lt;br/&gt;xycoords 参数如下:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;figure points points from the lower left of the figure 点在图左下方&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;figure pixels pixels from the lower left of the figure 图左下角的像素&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;figure fraction fraction of figure from lower left 左下角数字部分axes&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;points points from lower left corner of axes 从左下角点的坐标axes&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;pixels pixels from lower left corner of axes 从左下角的像素坐标&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;axes fraction fraction of axes from lower left 左下角部分&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;data use the coordinate system of the object being annotated(default) 使用的坐标系统被注释的对象（默认）&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;polar(theta,r) if not native ‘data’ coordinates t&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;extcoords&lt;/code&gt; 设置注释文字偏移量&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;坐标系&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;9&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;'figure points'&lt;/td&gt;
&lt;td&gt;距离图形左下角的点数量&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;'figure pixels'&lt;/td&gt;
&lt;td&gt;距离图形左下角的像素数量&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;'figure fraction'&lt;/td&gt;
&lt;td&gt;0,0 是图形左下角，1,1 是右上角&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;'axes points'&lt;/td&gt;
&lt;td&gt;距离轴域左下角的点数量&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;'axes pixels'&lt;/td&gt;
&lt;td&gt;距离轴域左下角的像素数量&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;'axes fraction'&lt;/td&gt;
&lt;td&gt;0,0 是轴域左下角，1,1 是右上角&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;'data'&lt;/td&gt;
&lt;td&gt;使用轴域数据坐标系&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;code&gt;arrowprops&lt;/code&gt; #箭头参数,参数类型为字典dict&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;width the width of the arrow in points 点箭头的宽度&lt;/li&gt;
&lt;li&gt;headwidth the width of the base of the arrow head in points 在点的箭头底座的宽度&lt;/li&gt;
&lt;li&gt;headlength the length of the arrow head in points 点箭头的长度&lt;/li&gt;
&lt;li&gt;shrink fraction of total length to ‘shrink’ from both ends 总长度为分数“缩水”从两端&lt;/li&gt;
&lt;li&gt;facecolor 箭头颜色&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;bbox给标题增加外框 ，常用参数如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;boxstyle方框外形&lt;/li&gt;
&lt;li&gt;facecolor(简写fc)背景颜色&lt;/li&gt;
&lt;li&gt;edgecolor(简写ec)边框线条颜色&lt;/li&gt;
&lt;li&gt;edgewidth边框线条大小&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-python&quot; lang=&quot;python&quot;&gt;bbox=dict(boxstyle='round,pad=0.5', fc='yellow', ec='k',lw=1 ,alpha=0.5)  #fc为facecolor,ec为edgecolor,lw为lineweight
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;我们平时基本都是使用pandas处理数据，所以，能够利用pandas中内置的plot来画图会方便许多，下面将介绍几种常用图表的画法&lt;/p&gt;
&lt;h2&gt;线型图&lt;/h2&gt;
&lt;p&gt;Series 和 DataFrame 都有一个用于生成各类图表的plot方法。默认情况下为线型图&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot; lang=&quot;python&quot;&gt;s = pd.Series(np.random.randn(10).cumsum(),index=np.arange(0,100,10))
s.plot()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1413964/201902/1413964-20190206233700119-442435624.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 该Series对象的索引会被传给matplotlib，并用以绘制X轴。可以通过use_index=False禁用该功能。X轴的刻度和界限可以通过xticks和xlim选项进行调节，Y轴就用yticks和ylim。&lt;/p&gt;
&lt;p&gt;DataFrame的plot方法会在一个subplot中为各列绘制一条线，并自动创建图例&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot; lang=&quot;python&quot;&gt;df = pd.DataFrame(np.random.randn(10,4).cumsum(0),columns=['A','B','C','D'],index=np.arange(0,100,10))
df.plot()&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1413964/201902/1413964-20190206233706775-1748257566.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;em id=&quot;__mceDel&quot;&gt;Series.plot参数如下：&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;label 用于图例标签&lt;/li&gt;
&lt;li&gt;ax 要在其上进行绘制的matplotlib subplot对象。&lt;/li&gt;
&lt;li&gt;style 将要传给matplotlib的风格字符串（如'ko--'）&lt;/li&gt;
&lt;li&gt;alpha 图表的填充不透明度(0-1)&lt;/li&gt;
&lt;li&gt;kind 可以是'line' 'bar' 'barch' 'kde'&lt;/li&gt;
&lt;li&gt;logy 在Y轴上是同对数标尺&lt;/li&gt;
&lt;li&gt;use_index 将对象的索引用作刻度标签&lt;/li&gt;
&lt;li&gt;rot 旋转刻度标签(0-360)&lt;/li&gt;
&lt;li&gt;xticks 用作X轴刻度的值&lt;/li&gt;
&lt;li&gt;yticks 用作Y轴刻度的值&lt;/li&gt;
&lt;li&gt;xlim X轴的界限&lt;/li&gt;
&lt;li&gt;ylim Y轴的界限&lt;/li&gt;
&lt;li&gt;grid 显示轴网格线（默认打开）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;专用于DataFrame的plot参数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;subplots 将各个DataFrame列绘制到单独的subplot中&lt;/li&gt;
&lt;li&gt;sharex 如果subplots=True，则共用同一个X轴，包括刻度和界限&lt;/li&gt;
&lt;li&gt;sharey 如果subplots=True，则共用同一个Y轴&lt;/li&gt;
&lt;li&gt;figsize 表示图像大小的元组&lt;/li&gt;
&lt;li&gt;title 表示图像标题的字符串&lt;/li&gt;
&lt;li&gt;legend 添加一个subplot图例&lt;/li&gt;
&lt;li&gt;sort_columns 以字母表示顺序绘制各列，默认使用当前列顺序 &lt;em&gt;注：有关时间序列的处理这篇博客中暂时不写，将在后续博客中补充&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;柱状图&lt;/h2&gt;
&lt;p&gt;在生成线型图的代码中加上kind='bar'或kind='barh'即可生成柱状图。这时，Series和DataFrame的索引将会被用作X或Y刻度&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot; lang=&quot;python&quot;&gt;fig, axes = plt.subplots(2,1)
data = pd.Series(np.random.rand(16),index=list('abcdefghijklmnop'))
data.plot(kind='bar',ax=axes[0],color='k',alpha=0.8,figsize=(8,10))
data.plot(kind='barh',ax=axes[1],color='k',alpha=0.8,figsize=(8,10))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1413964/201902/1413964-20190206233713290-1310710561.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot; lang=&quot;python&quot;&gt;df = pd.DataFrame(np.random.rand(6,4),index=['one','two','three','four','five','six'],columns=pd.Index(['A','B','C','D'],name='Genus'))
df
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1413964/201902/1413964-20190206233719280-927849540.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot; lang=&quot;python&quot;&gt;df.plot(kind='bar')
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1413964/201902/1413964-20190206233723831-18912572.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot; lang=&quot;python&quot;&gt;df.plot(kind='barh',stacked=True) # 设置stacked为True生成堆叠图
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1413964/201902/1413964-20190206233729311-736914806.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注：柱状图可以利用value_counts图形化显示Series中各值出现的频率&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot; lang=&quot;python&quot;&gt;df.div(df.sum(1).astype(float),axis=0).plot(kind='barh',stacked=True)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1413964/201902/1413964-20190206233735417-1698183849.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;直方图和密度图&lt;/h2&gt;
&lt;p&gt;直方图是一种可以对值频率进行离散化显示的柱状图，。数据点被拆分到离散的、间隔均匀的面元中，绘制的时各面元中数据点的数量。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot; lang=&quot;python&quot;&gt;length = pd.DataFrame({'length': [10, 20,15,10,1,12,12,12,13,13,13,14,14,14,41,41,41,41,41,4,4,4,4]})
length.plot.hist()&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1413964/201902/1413964-20190206233743432-214814797.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;与直方图相关的一种图表类型时密度图，它是通过计算“可能会产生观测数据的连续概率分布的估计”而产生的。一般的过程是将该分布近似为一组核（即诸如正态（高斯）分布之类的较为简单的分布）。因此，密度图也被称作KDE图，调用plot时加上kind='kde'即可生成一张密度图（标准混合正态分布）。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;length.plot(kind='kde')
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1413964/201902/1413964-20190206233753962-734369881.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot; lang=&quot;python&quot;&gt;df4 = pd.DataFrame({'a': np.random.randn(1000) + 1, 'b': np.random.randn(1000), 'c': np.random.randn(1000) - 1}, index=range(1,1001), columns=['a', 'b', 'c'])  #bins=20表示数值分辨率，具体来说是将随机数设定一个范围，例如5.6，5.7，6.5，如果数值分辨率越低，则会将三个数分到5-7之间，如果数值分辨率越高，则会将5.6，5.7分到5-6之间，而6.5分到6-7之间；值越小表示分辨率越低，值越大表示分辨率越高；
df4.plot.hist(stacked=True, bins=20, alpha=0.5)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1413964/201902/1413964-20190206233758279-1054509067.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot; lang=&quot;python&quot;&gt;df4.diff().hist(color='k', alpha=0.5, bins=50) #可将DataFrame当中column分开
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这两种图表常常会被画在一起。直方图以规格化形式给出（以便给出面元化密度），然后再在其上绘制核密度估计。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;comp1 = np.random.normal(0,1,size=200)
comp2 = np.random.normal(10,2,size=200)
values = pd.Series(np.concatenate([comp1,comp2]))
values.hist(bins=100,alpha=0.3,color='k',normed=True)
values.plot(kind='kde')
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1413964/201902/1413964-20190206233802790-1145628352.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;散点图&lt;/h2&gt;
&lt;p&gt;散点图（scatter plot）是观察两个一维数据序列之间的关系的有效手段。matplotlib的scatter方法是绘制散点图的主要方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;df = pd.DataFrame(np.random.rand(50, 4), columns=['a', 'b', 'c', 'd'])
df.plot.scatter(x='a', y='b') # 以a列为X轴数值，b列为Y轴数值绘制散点图
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1413964/201902/1413964-20190206233807329-184847491.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果想将不同的散点图信息绘制到一张图片当中，需要利用不同的颜色和标签进行区分&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ax = df.plot.scatter(x='a', y='b', color='Blue', label='Group 1')
df.plot.scatter(x='c', y='d', color='Green', label='Group 2', ax=ax)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1413964/201902/1413964-20190206233811515-1760985814.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在探索式数据分析（EDA）工作中，同时观察一组变量的散点图是很有意义的，这也被称为散点图矩阵。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from sklearn.datasets import load_iris # 使用sklearn库里的iris数据集
iris_dataset = load_iris()
from sklearn.model_selection import train_test_split
X_train,X_test,y_train,y_test = train_test_split(iris_dataset['data'],iris_dataset['target'],random_state=0)
iris_dataframe=pd.DataFrame(X_train,columns=iris_dataset.feature_names)
grr = pd.plotting.scatter_matrix(iris_dataframe,marker='o',c = y_train,hist_kwds={'bins':20},figsize=(12,10))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1413964/201902/1413964-20190206233815960-1659717810.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;饼图&lt;/h2&gt;
&lt;p&gt;饼图展现的是百分比关系&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;series = pd.Series(4 * np.random.rand(4), index=['a', 'b', 'c', 'd'], name='series')
series.plot.pie(figsize=(6, 6))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1413964/201902/1413964-20190206233821487-714411141.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于DataFrame对象，每一个column都可独立绘制一张饼图，但需要利用subplots=True参数将，每个饼图绘制到同一张图中。 df = pd.DataFrame(3 * np.random.rand(4, 2), index=['a', 'b', 'c', 'd'], columns=['x', 'y']) df.plot.pie(subplots=True, figsize=(8, 4))&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1413964/201902/1413964-20190206233825034-1830669547.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;箱型图（略）&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;由于箱型图接触不多，涉及内容较多且较为重要，后面会另写一篇关于箱型图的博客&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;各种绘图方式对于缺失值的处理&lt;/h2&gt;
&lt;p&gt;Missing values are dropped, left out, or filled depending on the plot type&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;图表&lt;/th&gt;
&lt;th&gt;处理方式&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;Plot Type&lt;/td&gt;
&lt;td&gt;NaN Handling&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Line&lt;/td&gt;
&lt;td&gt;Leave gaps at NaNs&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Line (stacked)&lt;/td&gt;
&lt;td&gt;Fill 0’s&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Bar&lt;/td&gt;
&lt;td&gt;Fill 0’s&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Scatter&lt;/td&gt;
&lt;td&gt;Drop NaNs&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Histogram&lt;/td&gt;
&lt;td&gt;Drop NaNs (column-wise)&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Box&lt;/td&gt;
&lt;td&gt;Drop NaNs (column-wise)&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Area&lt;/td&gt;
&lt;td&gt;Fill 0’s&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;KDE&lt;/td&gt;
&lt;td&gt;Drop NaNs (column-wise)&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Hexbin&lt;/td&gt;
&lt;td&gt;Drop NaNs&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Pie&lt;/td&gt;
&lt;td&gt;Fill 0’s&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;上面是一些常用图的画法介绍，当然，我们还有很多可画的图如箱型图、区域面积图、等高线图等等，也能利用 matplotlib 来绘制地图，当然这些在这就暂时先不介绍了，以后需要了再一一补充。&lt;/p&gt;

&lt;p&gt;《利用python进行数据分析》第八章&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot;url&quot; href=&quot;https://blog.csdn.net/wangxingfan316/article/details/80033557&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/wangxingfan316/article/details/80033557&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot;url&quot; href=&quot;https://blog.csdn.net/genome_denovo/article/details/78322628&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/genome_denovo/article/details/78322628&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot;url&quot; href=&quot;https://blog.csdn.net/Notzuonotdied/article/details/77876080&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/Notzuonotdied/article/details/77876080&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 06 Feb 2019 15:52:00 +0000</pubDate>
<dc:creator>iTryagain</dc:creator>
<og:description>前言 前面两篇文章介绍了 python 中两大模块 pandas 和 numpy 的一些基本使用方法，然而，仅仅会处理数据还是不够的，我们需要学会怎么分析，毫无疑问，利用图表对数据进行分析是最容易的，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/csu-lmw/p/10354287.html</dc:identifier>
</item>
<item>
<title>算法初级面试题08——递归和动态规划的精髓、阶乘、汉诺塔、子序列和全排列、母牛问题、逆序栈、最小的路径和、数组累加成指定整数、背包问题 - kent鹏</title>
<link>http://www.cnblogs.com/xieyupeng/p/10354238.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xieyupeng/p/10354238.html</guid>
<description>&lt;div class=&quot;Section0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt; 第八课主要介绍递归和动态规划&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;


&lt;div class=&quot;Section4&quot; readability=&quot;28&quot;&gt;
&lt;p&gt;&lt;span&gt;介绍递归和动态规划&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;暴力递归：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1，把问题转化为规模缩小了的同类问题的子问题&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2，有明确的不需要继续进行递归的条件(base case)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3，有当得到了子问题的结果之后的决策过程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4，不记录每一个&lt;/span&gt;&lt;span&gt;子问题的解&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;动态规划&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1，从暴力递归中来&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2，将每一个子问题的解记录下来，避免重复计算&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3，把暴力递归的过程，抽象成了状态表达&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4，并且存在化简状态表达，使其更加简洁的可能&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;图灵引入的是：我不知道怎么算，但是我知道&lt;span&gt;怎么试&lt;/span&gt;。知道怎么暴力破解出来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;要学会，练习懂得怎么尝试。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;
&lt;h2&gt;题目一&lt;/h2&gt;
&lt;/p&gt;
&lt;div class=&quot;Section6&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span&gt;求n!的结果&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;循环&lt;/span&gt;是一个知道怎么算的过程（从1乘到n）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;递归&lt;/span&gt;是子问题拆分到最小问题的尝试过程。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1135185/201902/1135185-20190206203345971-1023806920.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Code_01_Factorial {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; getFactorial1(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (n == 1&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 1L&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (&lt;span&gt;long&lt;/span&gt;) n * getFactorial1(n - 1&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; getFactorial2(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n) {
        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; result = 1L&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 1; i &amp;lt;= n; i++&lt;span&gt;) {
            result &lt;/span&gt;*=&lt;span&gt; i;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; n = 5&lt;span&gt;;
        System.out.println(getFactorial1(n));
        System.out.println(getFactorial2(n));
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;
&lt;h2&gt;题目二&lt;/h2&gt;
&lt;/p&gt;
&lt;div class=&quot;Section8&quot; readability=&quot;27&quot;&gt;
&lt;p&gt;&lt;span&gt;汉诺塔问题（不能大压小，只能小压大）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;打印n层汉诺塔从最左边移动到最右边的全部过程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1135185/201902/1135185-20190206203837526-918448289.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;左中右另称为 from、to、help。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;划分子问题&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、先把1~n-1从from移动到help&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、把单独的n移动到to&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、1~n-1从help移动到to&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1135185/201902/1135185-20190206203853032-195288445.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;br clear=&quot;all&quot;/&gt;&lt;span&gt;时间复杂度就是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;T(n) = T(n-1) + 1 + T(n-1) = 2T(n-1)+1（一个等比公式）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;T(n-1)是移动到help&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1是从from直接移动到to&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;T(n-1)是把全部n-1挪回去&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;总的步数是2的N次方减一&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个题目要学会尝试。&lt;/span&gt;&lt;br clear=&quot;all&quot;/&gt;&lt;span&gt;也可以写六个移动的递归，来逐一实现步骤。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1135185/201902/1135185-20190206204040705-574072374.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; （该问题最基础的一个模型就是，一个竹竿上放了2个圆盘，需要先将最上面的那个移到辅助竹竿上，然后将最底下的圆盘移到目标竹竿，最后把辅助竹竿上的圆盘移回目标竹竿。）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Code_02_Hanoi {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; hanoi(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (n &amp;gt; 0&lt;span&gt;) {
            func(n, n, &lt;/span&gt;&quot;left&quot;, &quot;mid&quot;, &quot;right&quot;&lt;span&gt;);
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; func(&lt;span&gt;int&lt;/span&gt; rest, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; down, String from, String help, String to) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (rest == 1&lt;span&gt;) {
            System.out.println(&lt;/span&gt;&quot;move &quot; + down + &quot; from &quot; + from + &quot; to &quot; +&lt;span&gt; to);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            func(rest &lt;/span&gt;- 1, down - 1&lt;span&gt;, from, to, help);
            func(&lt;/span&gt;1&lt;span&gt;, down, from, help, to);
            func(rest &lt;/span&gt;- 1, down - 1&lt;span&gt;, help, from, to);
        }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;课堂上的代码
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;N 表示当前是 1~N的问题
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;一开始都在from上&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; process(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; N, String from, String to, String help) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (N == 1) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;就只有一个了，可以直接移动&lt;/span&gt;
            System.out.println(&quot;Move 1 from &quot; + from + &quot; to &quot; +&lt;span&gt; to);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;否则就是1~N的问题&lt;/span&gt;
            process(N - 1, from, help, to);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;把1~N-1个从from移动到help&lt;/span&gt;
            System.out.println(&quot;Move &quot; + N + &quot; from &quot; + from + &quot; to &quot; + to);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;单独把N移动到to&lt;/span&gt;
            process(N - 1, help, to, from);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第三步是挪回来,把在help上的挪到to&lt;/span&gt;
&lt;span&gt;        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; moveLeftToRight(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; N) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (N == 1&lt;span&gt;) {
            System.out.println(&lt;/span&gt;&quot;move 1 from left to right&quot;&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            moveLeftToMid(N &lt;/span&gt;- 1);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;先把N-1移动到中间&lt;/span&gt;
            System.out.println(&quot;move &quot; + N + &quot;from left to right&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;把N移动到目的地&lt;/span&gt;
            moveMidToRight(N - 1);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;再把N-1移动到目的地&lt;/span&gt;
&lt;span&gt;        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; moveRightToLeft(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; N) {

    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; moveLeftToMid(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; N) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (N == 1&lt;span&gt;) {
            System.out.println(&lt;/span&gt;&quot;move 1 from left to mid&quot;&lt;span&gt;);
        }
        moveLeftToRight(N &lt;/span&gt;- 1&lt;span&gt;);
        System.out.println(&lt;/span&gt;&quot;move &quot; + N + &quot;from left to mid&quot;&lt;span&gt;);
        moveRightToMid(N &lt;/span&gt;- 1&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; moveMidToLeft(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; N) {

    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; moveRightToMid(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; N) {

    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; moveMidToRight(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; N) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (N == 1&lt;span&gt;) {
            System.out.println(&lt;/span&gt;&quot;move 1 from mid to right&quot;&lt;span&gt;);
        }
        moveMidToLeft(N &lt;/span&gt;- 1&lt;span&gt;);
        System.out.println(&lt;/span&gt;&quot;move &quot; + N + &quot;from mid to right&quot;&lt;span&gt;);
        moveLeftToRight(N &lt;/span&gt;- 1&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; n = 3&lt;span&gt;;
        hanoi(n);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;
&lt;h2&gt;题目三&lt;/h2&gt;
&lt;/p&gt;
&lt;div class=&quot;Section10&quot; readability=&quot;26.5&quot;&gt;
&lt;p&gt;&lt;span&gt;打印一个字符串的全部子序列，包括空字符串&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;怎么把脑里面的尝试变成code，就是写递归的能力&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br clear=&quot;all&quot;/&gt;&lt;span&gt;尝试方法：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一开始是空字符串，经过0有两个决定要a和不要a，经过1也要决定要不要b，一直尝试下去，列举所有情况。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1135185/201902/1135185-20190206204456766-1778798553.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;br clear=&quot;all&quot;/&gt;&lt;span&gt;可以画一下你想尝试的图，先来个小规模的，再去写递归就没那么难写了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1135185/201902/1135185-20190206204510363-1781894687.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Code_03_Print_All_Subsquences {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; printAllSubsquence(String str) {
        &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;[] chs =&lt;span&gt; str.toCharArray();
        process(chs, &lt;/span&gt;0&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; process(&lt;span&gt;char&lt;/span&gt;[] chs, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; i) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i ==&lt;span&gt; chs.length) {
            System.out.println(String.valueOf(chs));
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        process(chs, i &lt;/span&gt;+ 1&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; tmp =&lt;span&gt; chs[i];
        chs[i] &lt;/span&gt;= 0;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用空格代替字符&lt;/span&gt;
        process(chs, i + 1&lt;span&gt;);
        chs[i] &lt;/span&gt;= tmp;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;直接使用字符&lt;/span&gt;
&lt;span&gt;    }
    
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    public static void function(String str) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        char[] chs = str.toCharArray();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        process(chs, 0, new ArrayList&amp;lt;Character&amp;gt;());
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    public static void process(char[] chs, int i, List&amp;lt;Character&amp;gt; res) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        if(i == chs.length) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            printList(res);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        List&amp;lt;Character&amp;gt; resKeep = copyList(res);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        resKeep.add(chs[i]);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        process(chs, i+1, resKeep);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        List&amp;lt;Character&amp;gt; resNoInclude = copyList(res);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        process(chs, i+1, resNoInclude);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    public static void printList(List&amp;lt;Character&amp;gt; res) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    public static List&amp;lt;Character&amp;gt; copyList(List&amp;lt;Character&amp;gt; list){
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        return null;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;课堂上的版本&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; printAllSub(&lt;span&gt;char&lt;/span&gt;[] str,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i,String res){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i == str.length){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;到达字符串的末尾，已经没有选择了&lt;/span&gt;
&lt;span&gt;            System.out.println(res);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        printAllSub(str,i&lt;/span&gt;+1,res+&quot; &quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不要当前字符的路&lt;/span&gt;
        printAllSub(str,i+1,res+str[i]);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;要当前字符的路&lt;/span&gt;
&lt;span&gt;    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; printAllPermutation(){

    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        String test &lt;/span&gt;= &quot;abc&quot;&lt;span&gt;;
        printAllSubsquence(test);
        printAllSub(test.toCharArray(),&lt;/span&gt;0,&quot;&quot;&lt;span&gt;);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;题目四&lt;/h2&gt;
&lt;/div&gt;
&lt;div class=&quot;Section11&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;打印一个字符串的全部排列&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;Section13&quot; readability=&quot;17.5&quot;&gt;
&lt;p&gt;&lt;span&gt;打印一个字符串的全部排列，要求不要出现重复的排列&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1135185/201902/1135185-20190206204718395-1414131527.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Code_04_Print_All_Permutations {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; printAllPermutations1(String str) {
        &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;[] chs =&lt;span&gt; str.toCharArray();
        process1(chs, &lt;/span&gt;0&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; process1(&lt;span&gt;char&lt;/span&gt;[] chs, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; i) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i ==&lt;span&gt; chs.length) {
            System.out.println(String.valueOf(chs));
        }
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = i; j &amp;lt; chs.length; j++&lt;span&gt;) {
            swap(chs, i, j);
            process1(chs, i &lt;/span&gt;+ 1&lt;span&gt;);
            swap(chs, i, j);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;回溯&lt;/span&gt;
&lt;span&gt;        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; printAllPermutations2(String str) {
        &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;[] chs =&lt;span&gt; str.toCharArray();
        process2(chs, &lt;/span&gt;0&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; process2(&lt;span&gt;char&lt;/span&gt;[] chs, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; i) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i ==&lt;span&gt; chs.length) {
            System.out.println(String.valueOf(chs));
        }
        HashSet&lt;/span&gt;&amp;lt;Character&amp;gt; set = &lt;span&gt;new&lt;/span&gt; HashSet&amp;lt;&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = i; j &amp;lt; chs.length; j++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;set.contains(chs[j])) {
                set.add(chs[j]);
                swap(chs, i, j);
                process2(chs, i &lt;/span&gt;+ 1&lt;span&gt;);
                //&lt;/span&gt;&lt;span&gt;swap(chs, i, j);&lt;/span&gt;
&lt;span&gt;            }
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; swap(&lt;span&gt;char&lt;/span&gt;[] chs, &lt;span&gt;int&lt;/span&gt; i, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; j) {
        &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; tmp =&lt;span&gt; chs[i];
        chs[i] &lt;/span&gt;=&lt;span&gt; chs[j];
        chs[j] &lt;/span&gt;=&lt;span&gt; tmp;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        String test1 &lt;/span&gt;= &quot;abc&quot;&lt;span&gt;;
        printAllPermutations1(test1);
        System.out.println(&lt;/span&gt;&quot;======&quot;&lt;span&gt;);
        printAllPermutations2(test1);
        System.out.println(&lt;/span&gt;&quot;======&quot;&lt;span&gt;);

        String test2 &lt;/span&gt;= &quot;acc&quot;&lt;span&gt;;
        printAllPermutations1(test2);
        System.out.println(&lt;/span&gt;&quot;======&quot;&lt;span&gt;);
        printAllPermutations2(test2);
        System.out.println(&lt;/span&gt;&quot;======&quot;&lt;span&gt;);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/div&gt;
&lt;p&gt;
&lt;h2&gt;题目五&lt;/h2&gt;
&lt;/p&gt;
&lt;div class=&quot;Section15&quot; readability=&quot;17.5&quot;&gt;
&lt;p&gt;&lt;span&gt;母牛每年生一只母牛，新出生的母牛成长三年后也能每年生一只母牛，假设不会死。求N年后，母牛的数量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br clear=&quot;all&quot;/&gt;&lt;span&gt;一遇到这种递推的题目，不知道怎么试，&lt;span&gt;先列出前几项&lt;/span&gt;，递推是有高度结构化的解的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1135185/201902/1135185-20190206211321693-334328346.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;br clear=&quot;all&quot;/&gt;&lt;span&gt;然后要想&lt;span&gt;为什么？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;F(n) = F(n-1) + F(n-3)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为牛都不会死，所以会有去年的牛F(n-1),三年前牛的数量，此时都可以生小牛，所以会有F(n-3)这部分。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1135185/201902/1135185-20190206211515428-137852217.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Code_05_Cow {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; cowNumber1(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (n &amp;lt; 1&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (n == 1 || n == 2 || n == 3&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; n;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; cowNumber1(n - 1) + cowNumber1(n - 3&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;非递归版本&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; cowNumber2(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (n &amp;lt; 1&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (n == 1 || n == 2 || n == 3&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; n;
        }
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; res = 3&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; pre = 2&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; prepre = 1&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; tmp1 = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; tmp2 = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 4; i &amp;lt;= n; i++&lt;span&gt;) {
            tmp1 &lt;/span&gt;=&lt;span&gt; res;
            tmp2 &lt;/span&gt;=&lt;span&gt; pre;
            res &lt;/span&gt;= res +&lt;span&gt; prepre;
            pre &lt;/span&gt;=&lt;span&gt; tmp1;
            prepre &lt;/span&gt;=&lt;span&gt; tmp2;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; res;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; n = 20&lt;span&gt;;
        System.out.println(cowNumber1(n));
        System.out.println(cowNumber2(n));
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;进阶&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Section16&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;如果每只母牛只能活10年，求N年后，母牛的数量。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;
&lt;h2&gt;题目六&lt;/h2&gt;
&lt;/p&gt;
&lt;div class=&quot;Section18&quot; readability=&quot;25&quot;&gt;
&lt;p&gt;&lt;span&gt;给你一个栈，请你逆序这个栈，不能申请额外的数据结构，只能使用递归函数。如何实现？&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;本题考查栈的操作和递归函数的设计，我们&lt;span&gt;需要设计出两个递归函数&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;递归函数一：&lt;/span&gt;将栈stack 的栈底元素返回并移除。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具体过程就是如下代码中的getAndRemoveLastElement 方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果从stack 的栈顶到栈底依次为3、2、1，这个函数的具体过程如下图所示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1135185/201902/1135185-20190206215721478-1196742887.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;递归函数二：&lt;/span&gt;逆序一个栈，就是题目要求实现的方法，具体过程就是如下代码中的reverse方法。该方法使用了上面提到的getAndRemoveLastElement 方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果从stack 的栈顶到栈底依次为3、2、1，reverse 函数的具体过程如图1-5 所示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1135185/201902/1135185-20190206215842325-1938353186.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;getAndRemoveLastElement 方法在图中简单表示为get 方法，表示移除并返回当前栈底元素。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Code_06_ReverseStackUsingRecursive {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 以1，2，3为例，从栈顶到栈底依次为3，2，1
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; reverse(Stack&amp;lt;Integer&amp;gt;&lt;span&gt; stack) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (stack.isEmpty()) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i = getAndRemoveLastElement(stack);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到栈底元素&lt;/span&gt;
        reverse(stack);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;递归，所以i依次为1，2，3&lt;/span&gt;
        stack.push(i);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;回溯，依次压入3，2，1&lt;/span&gt;
&lt;span&gt;    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到栈底元素并它移除，并且其它元素压回栈&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; getAndRemoveLastElement(Stack&amp;lt;Integer&amp;gt;&lt;span&gt; stack) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; result =&lt;span&gt; stack.pop();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (stack.isEmpty()) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; last =&lt;span&gt; getAndRemoveLastElement(stack);
            stack.push(result);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;回溯，将其它元素重新压回栈&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; last;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回栈底元素&lt;/span&gt;
&lt;span&gt;        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        Stack&lt;/span&gt;&amp;lt;Integer&amp;gt; test = &lt;span&gt;new&lt;/span&gt; Stack&amp;lt;Integer&amp;gt;&lt;span&gt;();
        test.push(&lt;/span&gt;1&lt;span&gt;);
        test.push(&lt;/span&gt;2&lt;span&gt;);
        test.push(&lt;/span&gt;3&lt;span&gt;);
        test.push(&lt;/span&gt;4&lt;span&gt;);
        test.push(&lt;/span&gt;5&lt;span&gt;);
        reverse(test);
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (!&lt;span&gt;test.isEmpty()) {
            System.out.println(test.pop());
        }

    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
&lt;h2&gt;题目七&lt;/h2&gt;
&lt;/p&gt;
&lt;div class=&quot;Section20&quot; readability=&quot;68&quot;&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;给你一个二维数组，二维数组中的每个数都是正数，要求从左上角走到右下角，每一步只能向右或者向下。沿途经过的数字要累加起来。返回最小的路径和。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;没见过的动态规划有一个统一的套路，&lt;span&gt;写出递归版本尝试版本后&lt;/span&gt;，得出来的动态规划的方法是高度套路的。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;&lt;span&gt;所有动态规划都是由暴力版本优化来的&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1135185/201902/1135185-20190206221400530-1553832154.png&quot; alt=&quot;&quot; width=&quot;546&quot; height=&quot;294&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;&lt;span&gt;问题划分为了：&lt;/span&gt;向下或者向右的结果，从中选最小的路径，就是最后的答案。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1135185/201902/1135185-20190206221430276-329873624.png&quot; alt=&quot;&quot; width=&quot;432&quot; height=&quot;339&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;课堂上的代码&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; walk(&lt;span&gt;int&lt;/span&gt;[][] matrix, &lt;span&gt;int&lt;/span&gt; i, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; j) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; x = matrix.length - 1&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; y = matrix[0].length - 1&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i == x &amp;amp;&amp;amp; j ==&lt;span&gt; y) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; matrix[i][j];
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i == x)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果i到达行底部，只能向右走。&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; matrix[i][j] + walk(matrix, i, j + 1&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (j == y)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果j到达列边界，只能向下走。&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; matrix[i][j] + walk(matrix, i + 1&lt;span&gt;, j);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;其他情况，需要对向下和向右进行对比，选出最优解&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; right = walk(matrix, i, j + 1&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; down = walk(matrix, i + 1&lt;span&gt;, j);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; matrix[i][j] +&lt;span&gt; Math.min(right, down);

    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p align=&quot;justify&quot;&gt;&lt;br clear=&quot;all&quot;/&gt;&lt;span&gt;暴力枚举有待优化：有大量的重复解产生，很多部分都重复计算。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;把重复计算的部分缓存起来，重复的时候直接调用就能省时间。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;什么样的尝试版本递归可以改成动态规划？&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;当把递归过程展开，发现有重复的状态，与到达它的路径是没有关系的，那么它一定能改成动态规划（无后效性问题）。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;有后效性的是，汉罗塔、N皇后问题（前面的举动会影响后面的结果）。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1135185/201902/1135185-20190206221722147-1114167057.png&quot; alt=&quot;&quot; width=&quot;648&quot; height=&quot;371&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;准备一个dp表&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;1、把需要的位置点出来&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;2、回到base case中把不被依赖的位置设置好（这题是最后一行/列），然后分析普遍位置是怎么依赖的（需要哪些位置的帮助），反过去就是整个计算顺序。 &lt;span&gt;依次计算，推到顶部就是答案。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1135185/201902/1135185-20190206221827083-1030433519.png&quot; alt=&quot;&quot; width=&quot;572&quot; height=&quot;366&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;类似一个搭积木的过程，堆积到一定条件就能出现答案。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1135185/201902/1135185-20190206221835115-1090956224.png&quot; alt=&quot;&quot; width=&quot;387&quot; height=&quot;336&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;78&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Code_07_MinPath {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; minPath1(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[][] matrix) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; process1(matrix, matrix.length - 1, matrix[0].length - 1&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从{i,j}出发，到达最右下角位置，最小路径和是多少？&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; process1(&lt;span&gt;int&lt;/span&gt;[][] matrix, &lt;span&gt;int&lt;/span&gt; i, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; j) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; res =&lt;span&gt; matrix[i][j];
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i == 0 &amp;amp;&amp;amp; j == 0&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; res;
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i == 0 &amp;amp;&amp;amp; j != 0&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; res + process1(matrix, i, j - 1&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i != 0 &amp;amp;&amp;amp; j == 0&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; res + process1(matrix, i - 1&lt;span&gt;, j);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; res + Math.min(process1(matrix, i, j - 1), process1(matrix, i - 1&lt;span&gt;, j));
    }
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;动态规划&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; minPath2(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[][] m) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (m == &lt;span&gt;null&lt;/span&gt; || m.length == 0 || m[0] == &lt;span&gt;null&lt;/span&gt; || m[0].length == 0&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; row =&lt;span&gt; m.length;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; col = m[0&lt;span&gt;].length;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;[][] dp = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[row][col];
        dp[&lt;/span&gt;0][0] = m[0][0&lt;span&gt;];
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第一列赋值&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 1; i &amp;lt; row; i++&lt;span&gt;) {
            dp[i][&lt;/span&gt;0] = dp[i - 1][0] + m[i][0&lt;span&gt;];
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第一行赋值&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = 1; j &amp;lt; col; j++&lt;span&gt;) {
            dp[&lt;/span&gt;0][j] = dp[0][j - 1] + m[0&lt;span&gt;][j];
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;最优赋值&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 1; i &amp;lt; row; i++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = 1; j &amp;lt; col; j++&lt;span&gt;) {
                dp[i][j] &lt;/span&gt;= Math.min(dp[i - 1][j], dp[i][j - 1]) +&lt;span&gt; m[i][j];
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; dp[row - 1][col - 1&lt;span&gt;];
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; for test&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[][] generateRandomMatrix(&lt;span&gt;int&lt;/span&gt; rowSize, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; colSize) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (rowSize &amp;lt; 0 || colSize &amp;lt; 0&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;[][] result = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[rowSize][colSize];
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i != result.length; i++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = 0; j != result[0].length; j++&lt;span&gt;) {
                result[i][j] &lt;/span&gt;= (&lt;span&gt;int&lt;/span&gt;) (Math.random() * 10&lt;span&gt;);
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;课堂上的代码&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; walk(&lt;span&gt;int&lt;/span&gt;[][] matrix, &lt;span&gt;int&lt;/span&gt; i, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; j) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; x = matrix.length - 1&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; y = matrix[0].length - 1&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i == x &amp;amp;&amp;amp; j ==&lt;span&gt; y) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; matrix[i][j];
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i == x)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果i到达行底部，只能向右走。&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; matrix[i][j] + walk(matrix, i, j + 1&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (j == y)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果j到达列边界，只能向下走。&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; matrix[i][j] + walk(matrix, i + 1&lt;span&gt;, j);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;其他情况，需要对向下和向右进行对比，选出最优解&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; right = walk(matrix, i, j + 1&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; down = walk(matrix, i + 1&lt;span&gt;, j);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; matrix[i][j] +&lt;span&gt; Math.min(right, down);

    }


    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;[][] m = {{1, 3, 5, 9}, {8, 1, 3, 4}, {5, 0, 6, 1}, {8, 8, 4, 0&lt;span&gt;}};
        System.out.println(minPath1(m));
        System.out.println(minPath2(m));

        m &lt;/span&gt;= generateRandomMatrix(6, 7&lt;span&gt;);
        System.out.println(minPath1(m));
        System.out.println(minPath2(m));
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 align=&quot;justify&quot;&gt;&lt;br clear=&quot;all&quot;/&gt;
题目八&lt;/h2&gt;
&lt;/div&gt;
&lt;div class=&quot;Section21&quot; readability=&quot;44.5&quot;&gt;
&lt;p&gt;&lt;span&gt;给你一个数组arr，和一个整数aim。如果可以任意选择arr中的数字，能不能累加得到aim，返回true或者false&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1135185/201902/1135185-20190206224354442-1203865710.png&quot; alt=&quot;&quot; width=&quot;625&quot; height=&quot;365&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;这是一个&lt;span&gt;无后效性问题&lt;/span&gt;。可以使用dp，不管之前做了什么选择，只要是之前的累加和、步数是固定的，返回值一定确定。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1135185/201902/1135185-20190206224413323-1707115062.png&quot; alt=&quot;&quot; width=&quot;595&quot; height=&quot;336&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;br clear=&quot;all&quot;/&gt;&lt;span&gt;i就是数组长度，sum的范围是全部数的和。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1135185/201902/1135185-20190206224434288-489092414.png&quot; alt=&quot;&quot; width=&quot;594&quot; height=&quot;351&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;首先查看递归的base case，分析出最后一行，只有aim对应的列是T其余全是F，通过&lt;span&gt;查看递归的规律&lt;/span&gt;，普遍的位置依赖的是两种情况，[i+1,sum]和[i+1,sum+arr[i]]，&lt;span&gt;逐个计算把整个dp数组填满&lt;/span&gt;。&lt;span&gt;如果aim超出sum&lt;/span&gt;，那肯定是计算不出来的，因为sum是数组全部数加起来的和。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最后计算出[0,0]的位置，可以直接返回。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br clear=&quot;all&quot;/&gt;&lt;span&gt;和题意没关系了。（从暴力递归中总结出来）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1135185/201902/1135185-20190206224543014-954059464.png&quot; alt=&quot;&quot; width=&quot;554&quot; height=&quot;317&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;有负数怎么办？要设计一下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1135185/201902/1135185-20190206224554204-765610011.png&quot; alt=&quot;&quot; width=&quot;550&quot; height=&quot;324&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Code_08_Money_Problem {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; money1(&lt;span&gt;int&lt;/span&gt;[] arr, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; aim) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; process1(arr, 0, 0&lt;span&gt;, aim);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; process1(&lt;span&gt;int&lt;/span&gt;[] arr, &lt;span&gt;int&lt;/span&gt; i, &lt;span&gt;int&lt;/span&gt; sum, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; aim) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (sum ==&lt;span&gt; aim)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; sum != aim&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (i ==&lt;span&gt; arr.length)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; process1(arr, i + 1, sum, aim) || process1(arr, i + 1, sum +&lt;span&gt; arr[i], aim);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; money2(&lt;span&gt;int&lt;/span&gt;[] arr, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; aim) {
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt;[][] dp = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;[arr.length + 1][aim + 1&lt;span&gt;];
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; dp.length; i++&lt;span&gt;) {
            dp[i][aim] &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;以目标金额为列的肯定为true&lt;/span&gt;
&lt;span&gt;        }
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = arr.length - 1; i &amp;gt;= 0; i--) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从最后一行开始&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = aim - 1; j &amp;gt;= 0; j--) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;aim往后的都超过，没必要看&lt;/span&gt;
                dp[i][j] = dp[i + 1][j];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过直接的下方的判断。&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (j + arr[i] &amp;lt;= aim) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果该数加上arr[i](当前可以累加的数)少于等于目标数。
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 有可能可行，通过查看加上了arr[i](当前可以累加的数)的状态来判断&lt;/span&gt;
                    dp[i][j] = dp[i][j] || dp[i + 1][j +&lt;span&gt; arr[i]];
                }
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; dp[0][0&lt;span&gt;];
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; check(&lt;span&gt;int&lt;/span&gt;[] arr,&lt;span&gt;int&lt;/span&gt; i,&lt;span&gt;int&lt;/span&gt; sum,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; aim){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i == arr.length){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断是否走到最后一步&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; sum ==&lt;span&gt; aim;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; check(arr,i+1,sum,aim) || check(arr,i+1,sum+&lt;span&gt;arr[i],aim);
    }



    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;[] arr = { 1, 4, 8&lt;span&gt; };
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; aim = 12&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        System.out.println(money1(arr, aim));
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        System.out.println(money2(arr, aim));&lt;/span&gt;
&lt;span&gt;
        System.out.println(check(arr,&lt;/span&gt;0,0&lt;span&gt;,aim));

    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;
&lt;h2&gt;题目九&lt;/h2&gt;
&lt;/p&gt;
&lt;div class=&quot;Section23&quot; readability=&quot;9&quot;&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;给定两个数组w和v，两个数组长度相等，w[i]表示第i件商品的重量，v[i]表示第i件商品的价值。 再给定一个整数bag，要求你挑选商品的重量加起来一定不能超过bag，返回满足这个条件下，你能获得的最大价值。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Code_09_Knapsack {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; maxValue1(&lt;span&gt;int&lt;/span&gt;[] c, &lt;span&gt;int&lt;/span&gt;[] p, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; bag) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; process1(c, p, 0, 0&lt;span&gt;, bag);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; process1(&lt;span&gt;int&lt;/span&gt;[] weights, &lt;span&gt;int&lt;/span&gt;[] values, &lt;span&gt;int&lt;/span&gt; i, &lt;span&gt;int&lt;/span&gt; alreadyweight, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; bag) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (alreadyweight &amp;gt;&lt;span&gt; bag) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i ==&lt;span&gt; weights.length) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;每次就两种情况：1、不拿商品 2、拿商品承担重量&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Math.max(
                process1(weights, values, i &lt;/span&gt;+ 1&lt;span&gt;, alreadyweight, bag),
                values[i] &lt;/span&gt;+ process1(weights, values, i + 1, alreadyweight +&lt;span&gt; weights[i], bag));
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;carat 克拉/重量  price 价值&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; maxValue2(&lt;span&gt;int&lt;/span&gt;[] c, &lt;span&gt;int&lt;/span&gt;[] p, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; bag) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;[][] dp = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[c.length + 1][bag + 1&lt;span&gt;];
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = c.length - 1; i &amp;gt;= 0; i--&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = bag; j &amp;gt;= 0; j--) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;超过bag将毫无意义&lt;/span&gt;
                dp[i][j] = dp[i + 1&lt;span&gt;][j];
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (j + c[i] &amp;lt;=&lt;span&gt; bag) {
                    dp[i][j] &lt;/span&gt;= Math.max(dp[i][j], p[i] + dp[i + 1][j +&lt;span&gt; c[i]]);
                }
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; dp[0][0&lt;span&gt;];
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;[] c = { 3, 2, 4, 7&lt;span&gt; };
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;[] p = { 5, 6, 3, 19&lt;span&gt; };
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; bag = 11&lt;span&gt;;
        System.out.println(maxValue1(c, p, bag));
        System.out.println(maxValue2(c, p, bag));
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


</description>
<pubDate>Wed, 06 Feb 2019 15:49:00 +0000</pubDate>
<dc:creator>kent鹏</dc:creator>
<og:description>第八课主要介绍递归和动态规划 第八课主要介绍递归和动态规划 介绍递归和动态规划 暴力递归： 1，把问题转化为规模缩小了的同类问题的子问题 2，有明确的不需要继续进行递归的条件(base case) 3</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xieyupeng/p/10354238.html</dc:identifier>
</item>
<item>
<title>IOS真机测试（已拥有个人开发者证书） - Solist</title>
<link>http://www.cnblogs.com/Solist/p/10354288.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Solist/p/10354288.html</guid>
<description>&lt;p&gt;创建真机调试证书并进行真机测试&lt;/p&gt;
&lt;p&gt;现在就已经大功告成了，只需要在运行中找到自己的设备（前提：手机连接着电脑），点击运行，程序就会出现在Iphone上了。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1598960/201902/1598960-20190206233240272-872128595.png&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;以下的其中一个是我的程序在手机上的运行截图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1598960/201902/1598960-20190206233259448-831698557.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1598960/201902/1598960-20190206233308108-60951541.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;猜一下哪个是iphone上真正的计算器&quot;&gt;猜一下哪个是Iphone上真正的计算器&lt;/h2&gt;
</description>
<pubDate>Wed, 06 Feb 2019 15:34:00 +0000</pubDate>
<dc:creator>Solist</dc:creator>
<og:description>创建真机调试证书并进行真机测试 步骤1 在启动台中点击其他，找到钥匙串访问。 步骤2 在打开的界面中点击右边的系统根证书，然后点击左上角的钥匙串访问，然后是证书助理，最后点击从证书颁发机构申请证书。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Solist/p/10354288.html</dc:identifier>
</item>
<item>
<title>如何在ASP.NET Core程序启动时运行异步任务（2） - LamondLu</title>
<link>http://www.cnblogs.com/lwqlun/p/10354149.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lwqlun/p/10354149.html</guid>
<description>&lt;blockquote readability=&quot;2.7222222222222&quot;&gt;
&lt;p&gt;原文：&lt;a href=&quot;https://andrewlock.net/running-async-tasks-on-app-startup-in-asp-net-core-part-2/&quot;&gt;Running async tasks on app startup in ASP.NET Core (Part 2)&lt;/a&gt;&lt;br/&gt;作者：Andrew Lock&lt;br/&gt;译者：Lamond Lu&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201902/65831-20190206215519247-618941604.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在我的&lt;a href=&quot;https://www.cnblogs.com/lwqlun/p/10346733.html&quot;&gt;上一篇博客&lt;/a&gt;中，我介绍了如何在ASP.NET Core应用程序启动时运行一些一次性异步任务。本篇博客将继续讨论上一篇的内容，如果你还没有读过，我建议你先读一下前一篇。&lt;/p&gt;
&lt;p&gt;在本篇博客中，我将展示上一篇博文中提出的“在&lt;code&gt;Program.cs&lt;/code&gt;中手动运行异步任务”的实现方法。该实现会使用一些简单的接口和类来封装应用程序启动时的运行任务逻辑。我还会展示一个替代方法，这个替代方法是在Kestral服务器启动时，使用&lt;code&gt;IServer&lt;/code&gt;接口。&lt;/p&gt;
&lt;h2 id=&quot;在应用程序启动时运行异步任务&quot;&gt;在应用程序启动时运行异步任务&lt;/h2&gt;
&lt;p&gt;这里我们先回顾一下上一遍博客内容，在上一篇中，我们试图寻找一种方案，允许我们在ASP.NET Core应用程序启动时执行一些异步任务。这些任务应该是在ASP.NET Core应用程序启动之前执行，但是由于这些任务可能需要读取配置或者使用服务，所以它们只能在ASP.NET Core的依赖注入容器配置完成后执行。数据库迁移，填充缓存都可以这种异步任务的使用场景。&lt;/p&gt;
&lt;p&gt;我们在一篇文章的末尾提出了一个相对完善的解决方案，这个方案是在&lt;code&gt;Program.cs&lt;/code&gt;中“手动”运行任务。运行任务的时机是在&lt;code&gt;IWebHostBuilder.Build()&lt;/code&gt;和&lt;code&gt;IWebHost.RunAsync()&lt;/code&gt;之间。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class Program
{
    public static async Task Main(string[] args)
    {
        IWebHost webHost = CreateWebHostBuilder(args).Build();

        using (var scope = webHost.Services.CreateScope())
        {
            var myDbContext = scope.ServiceProvider.GetRequiredService&amp;lt;MyDbContext&amp;gt;();

            await myDbContext.Database.MigrateAsync();
        }

        await webHost.RunAsync();
    }

    public static IWebHostBuilder CreateWebHostBuilder(string[] args) =&amp;gt;
        WebHost.CreateDefaultBuilder(args)
            .UseStartup&amp;lt;Startup&amp;gt;();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种实现方式是可行的，但是有点乱。这里我们将许多不应该属于&lt;code&gt;Program.cs&lt;/code&gt;职责的代码放在了&lt;code&gt;Program.cs&lt;/code&gt;中，让它看起来有点臃肿了，所以这里我们需要将数据库迁移相关的代码移到另外一个类中。&lt;/p&gt;
&lt;p&gt;这里更麻烦的问题是，我们必须要手动调用任务。如果你在多个应用程序中使用相同的模式，那么最好能改成自动调用任务。&lt;/p&gt;
&lt;h2 id=&quot;在依赖注入容器中注册启动任务&quot;&gt;在依赖注入容器中注册启动任务&lt;/h2&gt;
&lt;p&gt;这里我将使用基于&lt;code&gt;IStartupFilter&lt;/code&gt;和&lt;code&gt;IHostService&lt;/code&gt;使用的模式。它们允许你在依赖注入容器中注册它们的实现类，并在应用程序启动前获取到这些接口的所有实现类，并依次执行它们。&lt;/p&gt;
&lt;p&gt;所以，这里首先我们创建一个简单的接口来启动任务。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public interface IStartupTask
{
    Task ExecuteAsync(CancellationToken cancellationToken = default);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;并且创建一个在依赖注入容器中注册任务的便捷方法。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public static class ServiceCollectionExtensions
{
    public static IServiceCollection AddStartupTask&amp;lt;T&amp;gt;(this IServiceCollection services)
        where T : class, IStartupTask
        =&amp;gt; services.AddTransient&amp;lt;IStartupTask, T&amp;gt;();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后，我们添加一个扩展方法，在应用程序启动时找到所有已注册的IStartupTasks，按顺序运行它们，然后启动IWebHost：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public static class StartupTaskWebHostExtensions
{
    public static async Task RunWithTasksAsync(this IWebHost webHost, CancellationToken cancellationToken = default)
    {
        var startupTasks = webHost.Services.GetServices&amp;lt;IStartupTask&amp;gt;();
       
        foreach (var startupTask in startupTasks)
        {
            await startupTask.ExecuteAsync(cancellationToken);
        }

        await webHost.RunAsync(cancellationToken);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上就是所有的代码。&lt;/p&gt;
&lt;p&gt;下面为了看一下它的实际效果，我将继续使用上一篇中EF Core数据库迁移的例子&lt;/p&gt;
&lt;h2 id=&quot;例子异步迁移数据库&quot;&gt;例子：异步迁移数据库&lt;/h2&gt;
&lt;p&gt;实现&lt;code&gt;IStartupTask&lt;/code&gt;和实现&lt;code&gt;IStartupFilter&lt;/code&gt;非常的相似。你可以从依赖注入容器中注入服务。为了使用依赖注入容器中的服务，这里我们需要手动注入一个&lt;code&gt;IServiceProvider&lt;/code&gt;对象，并手动创建一个Scoped服务。&lt;/p&gt;
&lt;p&gt;EF Core的数据库迁移启动任务类似以下代码：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class MigratorStartupFilter: IStartupTask
{
    private readonly IServiceProvider _serviceProvider;
    public MigratorStartupFilter(IServiceProvider serviceProvider)
    {
        _serviceProvider = serviceProvider;
    }

    public Task ExecuteAsync(CancellationToken cancellationToken = default)
    {
        using(var scope = _seviceProvider.CreateScope())
        {
            var myDbContext = scope.ServiceProvider.GetRequiredService&amp;lt;MyDbContext&amp;gt;();

            await myDbContext.Database.MigrateAsync();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在，我们可以在&lt;code&gt;ConfigureServices&lt;/code&gt;方法中使用依赖注入容器添加启动任务了。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public void ConfigureServices(IServiceCollection services)
{
    services.MyDbContext&amp;lt;ApplicationDbContext&amp;gt;(options =&amp;gt;
        options.UseSqlServer(Configuration               
             .GetConnectionString(&quot;DefaultConnection&quot;)));

    services.AddMvc()
        .SetCompatibilityVersion(CompatibilityVersion.Version_2_1);

    services.AddStartupTask&amp;lt;MigrationStartupTask&amp;gt;();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后我们更新一下&lt;code&gt;Program.cs&lt;/code&gt;, 使用&lt;code&gt;RunWithTasksAsync()&lt;/code&gt;方法替换&lt;code&gt;Run()&lt;/code&gt;方法。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class Program
{
    public static async Task Main(string[] args)
    {
        await CreateWebHostBuilder(args)
            .Build()
            .RunWithTasksAsync();
    }

    public static IWebHostBuilder CreateWebHostBuilder(string[] args) =&amp;gt;
        WebHost.CreateDefaultBuilder(args)
            .UseStartup&amp;lt;Startup&amp;gt;();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上代码利用了C# 7.1中引入的异步Task Main的特性。从功能上来说，它与我上一篇博客中的手动代码等同，但是它有一些优点。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;它的任务实现代码没有放在&lt;code&gt;Program.cs&lt;/code&gt;中。&lt;/li&gt;
&lt;li&gt;由于上一条的优点，开发人员可以很容易的添加额外的任务。&lt;/li&gt;
&lt;li&gt;如果不运行任何任务，它的功能和&lt;code&gt;RunAsync&lt;/code&gt;是一样的&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于以上方案，有一个问题需要注意。这里我们定义的任务会在&lt;code&gt;IConfiguration&lt;/code&gt;和依赖注入容器配置完成之后运行，这也就意味着，当任务执行时，所有的&lt;code&gt;IStartupFilter&lt;/code&gt;都没有运行，中间件管道也没有配置。&lt;/p&gt;
&lt;p&gt;就我个人而言，我不认为这是一个问题，因为我暂时想不出任何可能。到目前为止，我所编写的任务都不依赖于&lt;code&gt;IStartupFilter&lt;/code&gt;和中间件管道。但这也并不意味着没有这种可能。&lt;/p&gt;
&lt;p&gt;不幸的是，使用当前的WebHost代码并没有简单的方法（尽管 在.NET Core 3.0中当ASP.NET Core作为IHostedService运行时，这可能会发生变化）。 问题是应用程序是引导（通过配置中间件管道并运行IStartupFilters）和启动在同一个函数中。 当你在Program.cs中调用&lt;code&gt;WebHost.Run()&lt;/code&gt;时，在内部程序会调用&lt;code&gt;WebHost.StartAsync&lt;/code&gt;，如下所示，为简洁起见,其中只包含了日志记录和一些其他次要代码：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public virtual async Task StartAsync(CancellationToken cancellationToken = default)
{
    _logger = _applicationServices.GetRequiredService&amp;lt;ILogger&amp;lt;WebHost&amp;gt;&amp;gt;();

   
    var application = BuildApplication();

    _applicationLifetime = _applicationServices.GetRequiredService&amp;lt;IApplicationLifetime&amp;gt;() as ApplicationLifetime;
    _hostedServiceExecutor = _applicationServices.GetRequiredService&amp;lt;HostedServiceExecutor&amp;gt;();
    var diagnosticSource = _applicationServices.GetRequiredService&amp;lt;DiagnosticListener&amp;gt;();
    var httpContextFactory = _applicationServices.GetRequiredService&amp;lt;IHttpContextFactory&amp;gt;();
    var hostingApp = new HostingApplication(application, _logger, diagnosticSource, httpContextFactory);

    await Server.StartAsync(hostingApp, cancellationToken).ConfigureAwait(false);

    _applicationLifetime?.NotifyStarted();

    await _hostedServiceExecutor.StartAsync(cancellationToken).ConfigureAwait(false);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里问题是我们想要在&lt;code&gt;BuildApplication()&lt;/code&gt;和&lt;code&gt;Server.StartAsync&lt;/code&gt;之间插入代码，但是现在没有这样做的机制。&lt;/p&gt;
&lt;p&gt;我不确定我所给出的解决方案是否优雅，但它可以工作，并为消费者提供更好的体验，因为他们不需要修改Program.cs&lt;/p&gt;
&lt;h2 id=&quot;使用iserver的替代方案&quot;&gt;使用&lt;code&gt;IServer&lt;/code&gt;的替代方案&lt;/h2&gt;
&lt;p&gt;为了实现在&lt;code&gt;BuildApplication()&lt;/code&gt;和&lt;code&gt;Server.StartAsync()&lt;/code&gt;之间运行异步代码，我能想到的唯一办法是我们自己的实现一个IServer实现（Kestrel）！ 对你来说，听到这个可能感觉非常可怕 - 但是我们真的不打算更换服务器，我们只是去装饰它。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class TaskExecutingServer : IServer
{
    private readonly IServer _server;
    private readonly IEnumerable&amp;lt;IStartupTask&amp;gt; _startupTasks;
    public TaskExecutingServer(IServer server, IEnumerable&amp;lt;IStartupTask&amp;gt; startupTasks)
    {
        _server = server;
        _startupTasks = startupTasks;
    }

    public async Task StartAsync&amp;lt;TContext&amp;gt;(IHttpApplication&amp;lt;TContext&amp;gt; application, CancellationToken cancellationToken)
    {
        foreach (var startupTask in _startupTasks)
        {
            await startupTask.ExecuteAsync(cancellationToken);
        }

        await _server.StartAsync(application, cancellationToken);
    }

    public IFeatureCollection Features =&amp;gt; _server.Features;
    public void Dispose() =&amp;gt; _server.Dispose();
    public Task StopAsync(CancellationToken cancellationToken) =&amp;gt; _server.StopAsync(cancellationToken);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;TaskExecutingServer&lt;/code&gt;在其构造函数中获取了一个&lt;code&gt;IServer&lt;/code&gt;实例 - 这是&lt;code&gt;ASP.NET Core&lt;/code&gt;注册的原始Kestral服务器。我们将大部分&lt;code&gt;IServer&lt;/code&gt;的接口实现直接委托给Kestrel，我们只是拦截对&lt;code&gt;StartAsync&lt;/code&gt;的调用并首先运行注入的任务。&lt;/p&gt;
&lt;p&gt;这个实现最困难部分是使装饰器正常工作。正如我在上一篇文章中所讨论的那样，使用带有默认ASP.NET Core容器的装饰可能会非常棘手。我通常使用Scrutor来创建装饰器，但是如果你不想依赖另一个库，你总是可以手动进行装饰， 但一定要看看Scrutor是如何做到这一点的！&lt;/p&gt;
&lt;p&gt;下面我们添加一个用于添加&lt;code&gt;IStartupTask&lt;/code&gt;的扩展方法， 这个扩展方法做了两件事，一是将&lt;code&gt;IStartupTask&lt;/code&gt;注册到依赖注入容器中，二是装饰了之前注册的&lt;code&gt;IServer&lt;/code&gt;实例（这里为了简洁，我省略了&lt;code&gt;Decorate&lt;/code&gt;方法的实现）。如果它发现&lt;code&gt;IServer&lt;/code&gt;已经被装饰，它会跳过第二步，这样你就可以安全的多次调用&lt;code&gt;AddStartupTask&lt;/code&gt;方法。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public static class ServiceCollectionExtensions
{
    public static IServiceCollection AddStartupTask&amp;lt;TStartupTask&amp;gt;(this IServiceCollection services)
        where TStartupTask : class, IStartupTask
        =&amp;gt; services
            .AddTransient&amp;lt;IStartupTask, TStartupTask&amp;gt;()
            .AddTaskExecutingServer();

    private static IServiceCollection AddTaskExecutingServer(this IServiceCollection services)
    {
        var decoratorType = typeof(TaskExecutingServer);
        if (services.Any(service =&amp;gt; service.ImplementationType == decoratorType))
        {
            return services;
        }

        return services.Decorate&amp;lt;IServer, TaskExecutingServer&amp;gt;();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用这两段代码，我们不再需要再对Program.cs文件进行任何更改，并且我们是在完全构建应用程序后执行我们的任务，这其中也包括IStartupFilters和中间件管道。&lt;/p&gt;
&lt;p&gt;启动过程的序列图现在看起来有点像这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201902/65831-20190206215559298-1703373608.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以上就是这种实现方式全部的内容。它的代码非常少, 以至于我自己都在考虑是否要自己编写一个库。不过最后我还是在&lt;a href=&quot;https://github.com/andrewlock/NetEscapades.AspNetCore.StartupTasks&quot;&gt;GitHub&lt;/a&gt;和&lt;a href=&quot;https://www.nuget.org/packages/NetEscapades.AspNetCore.StartupTasks/&quot;&gt;Nuget&lt;/a&gt;上创建了一个库NetEscapades.AspNetCore.StartupTasks&lt;/p&gt;
&lt;p&gt;这里我只编写了使用后一种&lt;code&gt;IServer&lt;/code&gt;实现的库，因为它更容易使用，而且Thomas Levesque已经编写针对第一种方法可用的&lt;a href=&quot;https://github.com/thomaslevesque/AspNetCore.AsyncInitialization/&quot;&gt;NuGet&lt;/a&gt;包。&lt;/p&gt;
&lt;p&gt;在GitHub的实现中，我手动构造了装饰器，以避免强制依赖Scrutor。 但最好的方法可能就是将代码复制并粘贴到您自己的项目中。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;在这篇博文中，我展示了两种在ASP.NET Core应用程序启动时异步运行任务的方法。 第一种方法需要稍微修改Program.cs，但是“更安全”，因为它不需要修改像IServer这样的内部实现细节。 第二种方法是装饰IServer，提供更好的用户体验，但感觉更加笨拙。&lt;/p&gt;
</description>
<pubDate>Wed, 06 Feb 2019 14:07:00 +0000</pubDate>
<dc:creator>LamondLu</dc:creator>
<og:description>在本篇博客中，我将展示上一篇博文中提出的Program.cs中手动运行异步任务”的实现方法。该实现会使用一些简单的接口和类来封装应用程序启动时的运行任务逻辑。我还会展示一个替代方法，这个替代方法是在K</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lwqlun/p/10354149.html</dc:identifier>
</item>
<item>
<title>多线程场景设计利器：分离方法的调用和执行——命令模式总结 - dashuai的博客</title>
<link>http://www.cnblogs.com/kubixuesheng/p/10353809.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kubixuesheng/p/10353809.html</guid>
<description>&lt;p&gt;个人感觉，&lt;span&gt;&lt;strong&gt;该模式主要还是在多线程程序的设计中比较常用&lt;/strong&gt;&lt;/span&gt;，尤其是一些异步任务执行的过程。但是本文还是打算先在单线程程序里总结它的用法，至于多线程环境中命令模式的用法，还是想在多线程的设计模式里重点总结。&lt;/p&gt;

&lt;p&gt;其实思路很简单，就是把方法的请求调用和具体执行过程分开，让客户端不知道该请求是如何、何时执行的。那么如何分开呢？&lt;/p&gt;
&lt;p&gt;其实没什么复杂的，就是使用 OO 思想，把对方法的请求封装为对象即可，然后在设计一个请求的接受者对象，当然还要有一个请求的发送者对象，请求本身也是一个对象。最后，请求要如何执行呢？&lt;/p&gt;
&lt;p&gt;故，除了请求对象，请求发送者，请求接受者，还要一个请求执行者——这里可以看成是客户端，而请求（其实叫命令、或者请求都是一样的意思，后文就用请求这个术语）最好设计为抽象的（或者接口）。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;也可得知，命令模式是对象的行为型的设计模式。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;模拟场景：在线教育平台售卖一些培训的视频课程，规定必须付费后才能观看，故管理员需要有开放课程观看和关闭课程观看权限的操作&lt;/p&gt;
&lt;p&gt;首先需要一个抽象的命令（请求）接口&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; ICommand { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 抽象的命令（请求）接口&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; execute();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后设计一个课程类——Lesson，它代表课程本身，也是命令（请求）的接受者，因为是对课程这个实体下命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Lesson { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 代表课程本身，也是命令（请求）的接受者，因为是对课程这个实体下命令&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Lesson(String name) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; openLesson() {
        System.out.println(&lt;/span&gt;&quot;可以观看课程：&quot; +&lt;span&gt; name);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; closeLesson() {
        System.out.println(&lt;/span&gt;&quot;不可以观看课程：&quot; +&lt;span&gt; name);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面是两个具体的命令类，分别实现命令接口，里面是有聚合关系，把课程 Lesson 的引用聚合到命令类，哪一个命令要对哪一个实体，不能写错，比如关闭对关闭。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CloseCommand &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; ICommand {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Lesson lesson;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; CloseCommand(Lesson lesson) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.lesson =&lt;span&gt; lesson;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; execute() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.lesson.closeLesson();
    }
}
&lt;/span&gt;&lt;span&gt;//////////////////////////////////////////////////////
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; OpenCommand &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; ICommand {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Lesson lesson;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; OpenCommand(Lesson lesson) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.lesson =&lt;span&gt; lesson;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; execute() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.lesson.openLesson();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;设计一个管理员类，作为命令（请求）的调用者，用来发出请求（命令），而命令的实际执行，交给了命令（请求）的接受者——Lesson&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Admin2 {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; ICommand commond;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCommond(ICommand commond) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.commond =&lt;span&gt; commond;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; executeCommond() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.commond.execute();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;客户端&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        Lesson lesson1 = &lt;span&gt;new&lt;/span&gt; Lesson(&quot;c++&quot;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 请求（命令）的接受者&lt;/span&gt;
        CloseCommand closeCommand1 = &lt;span&gt;new&lt;/span&gt; CloseCommand(lesson1); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 命令封装为对象&lt;/span&gt;
        OpenCommand openCommand1 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; OpenCommand(lesson1);
        Admin2 admin2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Admin2(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 请求（命令）的调用者：用来发出请求&lt;/span&gt;
        admin2.setCommond(openCommand1); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将命令传给调用者&lt;/span&gt;
&lt;span&gt;        admin2.executeCommond(); // 发出请求（命令），但是admin 并不知道这个请求（命令）发给了谁，是谁在执行这个请求（命令）
        admin2.setCommond(closeCommand1);
        admin2.executeCommond();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上就实现了请求调用和具体执行的分离（解耦）&lt;/p&gt;

&lt;p&gt;下面是一次执行多个命令的写法，也可以作为宏命令的实现&lt;/p&gt;
&lt;p&gt;命令接口和具体命令都不变，admin 变化如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Admin {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; List&amp;lt;ICommand&amp;gt; commondList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用 ArrayList 还能保证命令的顺序执行&lt;/span&gt;

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addCommond(ICommand commond) {
        commondList.add(commond);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; executeCommond() {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (ICommand commond : commondList) {
            commond.execute();
        }
        commondList.clear();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然这里用栈等数据结构去包装命令也是可以的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        Lesson lesson = &lt;span&gt;new&lt;/span&gt; Lesson(&quot;java&quot;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 请求（命令）的接受者&lt;/span&gt;
        CloseCommand closeCommand = &lt;span&gt;new&lt;/span&gt; CloseCommand(lesson); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 命令&lt;/span&gt;
        OpenCommand openCommand = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; OpenCommand(lesson);
        Admin admin &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Admin(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 请求（命令）的调用者：用来发出请求&lt;/span&gt;
        admin.addCommond(openCommand); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将命令传给调用者&lt;/span&gt;
&lt;span&gt;        admin.addCommond(closeCommand);
        admin.executeCommond();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;引申：空类型模式&lt;/h2&gt;
&lt;p&gt;再比如，使用静态数组去包装命令，这里引申一个空类型模式，就是说有一个类，这个类什么都不做，就是占位或者初始化用的，代替 null 类型。&lt;/p&gt;
&lt;p&gt;下面举一个例子，设计一个控制器，控制电灯的开关，闪烁，变暗，变亮等操作&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; ICommand2 {
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; execute(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 命令接口&lt;/span&gt;
&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;//////////////////////////////////
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; LightOffCommand &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; ICommand2 {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Light light;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; LightOffCommand(Light light) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.light =&lt;span&gt; light;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; execute() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.light.off();
    }
}
&lt;/span&gt;&lt;span&gt;//////////////////////////////////
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; LightOnCommand &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; ICommand2 {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Light light;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; LightOnCommand(Light light) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.light =&lt;span&gt; light;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; execute() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.light.on();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.light.zoomin();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.light.blink();
    }
}
&lt;/span&gt;&lt;span&gt;//////////////////////////////////
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; EmptyCommand &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; ICommand2 { // 空类型模式的体现
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; execute() {
        System.out.println(&lt;/span&gt;&quot;什么都不做&quot;&lt;span&gt;);
    }
}
&lt;/span&gt;&lt;span&gt;//////////////////////////////////
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Light {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Light() {
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; on() {
        System.out.println(&lt;/span&gt;&quot;电灯打开&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; off() {
        System.out.println(&lt;/span&gt;&quot;电灯关闭&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; zoomin() {
        System.out.println(&lt;/span&gt;&quot;灯光变强&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; zoomout() {
        System.out.println(&lt;/span&gt;&quot;灯光变弱&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; blink() {
        System.out.println(&lt;/span&gt;&quot;灯光闪烁&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; noBlink() {
        System.out.println(&lt;/span&gt;&quot;灯光停止闪烁&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面是一个控制器类，setCommand 方法可以设置某个命令和某个操作的对应关系，初始化时，使用空类型模式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MainController {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; ICommand2[] onCommands;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; ICommand2[] offCommands;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; MainController() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.onCommands = &lt;span&gt;new&lt;/span&gt; ICommand2[3&lt;span&gt;];
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.offCommands = &lt;span&gt;new&lt;/span&gt; ICommand2[2&lt;span&gt;];
        ICommand2 emptyCommand &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EmptyCommand();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 3; i++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.onCommands[i] =&lt;span&gt; emptyCommand;
        }
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 2; i++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.offCommands[i] =&lt;span&gt; emptyCommand;
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setCommand(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; idx, ICommand2 onCommand, ICommand2 offCommand) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.onCommands[idx] =&lt;span&gt; onCommand;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.offCommands[idx] =&lt;span&gt; offCommand;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; executeOnCommand(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; idx) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.onCommands[idx].execute();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; executeOffCommand(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; idx) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.offCommands[idx].execute();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;客户端&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
        MainController mainController = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MainController();
        Light roomLight &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Light();
        Light doorLight &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Light();
        LightOnCommand roomLightOnCommand &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LightOnCommand(roomLight);
        LightOffCommand roomLightOffCommand &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LightOffCommand(roomLight);
        LightOnCommand doorLightOnCommand &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LightOnCommand(doorLight);
        LightOffCommand doorLightOffCommand &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LightOffCommand(doorLight);

        mainController.setCommand(&lt;/span&gt;0&lt;span&gt;, roomLightOnCommand, roomLightOffCommand);
        mainController.setCommand(&lt;/span&gt;1&lt;span&gt;, doorLightOnCommand, doorLightOffCommand);

        mainController.executeOnCommand(&lt;/span&gt;0&lt;span&gt;);
        mainController.executeOffCommand(&lt;/span&gt;0&lt;span&gt;);
        mainController.executeOnCommand(&lt;/span&gt;1&lt;span&gt;);
        mainController.executeOffCommand(&lt;/span&gt;1&lt;span&gt;);
        mainController.executeOnCommand(&lt;/span&gt;2);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;通过封装对方法的请求调用和方法执行过程，并将其分离，也就是所谓的完全解耦了。&lt;/p&gt;
&lt;p&gt;故可以对方法的调用执行实现一些额外操作，比如记录日志，撤销某个方法的请求调用，或者实现一次请求，N 次执行某个方法等。&lt;/p&gt;
&lt;p&gt;在架构上，可以让程序易于扩展新的请求（命令）。&lt;/p&gt;

&lt;p&gt;这样做，在多线程环境下的好处是：&lt;/p&gt;
&lt;p&gt;1、&lt;span&gt;&lt;strong&gt;避免算法（策略）模块执行缓慢拖累调用方——抽象了需要等待的操作&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2、控制执行顺序，因为请求调用和具体执行分离，故执行顺序和调用顺序没有关系&lt;/p&gt;
&lt;p&gt;3、可以轻松实现请求的取消，或者反复执行某个请求&lt;/p&gt;
&lt;p&gt;4、请求调用和具体执行分离后，进一步把负责调用的机器和负责执行的机器分开，可以基于网络，实现分布式程序&lt;/p&gt;

&lt;p&gt;前面，无论在什么环境下，都提到了能撤销命令（请求），故命令模式经常和备忘录模式搭配使用。参考：&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/kubixuesheng/p/10353325.html&quot;&gt;保存快照和撤销功能的实现方案——备忘录模式总结&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;这里举一个很简单的例子，还是电灯开关的例子&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; ICommand3 {
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; execute();
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; undo(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 和 execute 执行相反的操作&lt;/span&gt;
&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;//////////////////////////////////
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; EmptyCommand &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; ICommand3 {
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; execute() {
        System.out.println(&lt;/span&gt;&quot;什么都不做&quot;&lt;span&gt;);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; undo() {
        System.out.println(&lt;/span&gt;&quot;什么都不做&quot;&lt;span&gt;);
    }
}
&lt;/span&gt;&lt;span&gt;////////////////////////////////&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; LightOnCommand &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; ICommand3 {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Light light;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; LightOnCommand(Light light) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.light =&lt;span&gt; light;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; execute() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.light.on();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.light.zoomin();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.light.blink();
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; undo() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.light.noBlink();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.light.zoomout();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.light.off();
    }
}
&lt;/span&gt;&lt;span&gt;//////////////////////////////////&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; LightOffCommand &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; ICommand3 {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Light light;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; LightOffCommand(Light light) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.light =&lt;span&gt; light;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; execute() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.light.off();
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; undo() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.light.on();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;控制器也要变化，初始化命令的同时，也要初始化 undo 命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MainController {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; ICommand3[] onCommands;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; ICommand3[] offCommands;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; ICommand3 undoCommand; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 记录上一个命令&lt;/span&gt;

    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; MainController() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.onCommands = &lt;span&gt;new&lt;/span&gt; ICommand3[3&lt;span&gt;];
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.offCommands = &lt;span&gt;new&lt;/span&gt; ICommand3[2&lt;span&gt;];
        ICommand3 emptyCommand &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EmptyCommand();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 3; i++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.onCommands[i] =&lt;span&gt; emptyCommand;
        }
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 2; i++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.offCommands[i] =&lt;span&gt; emptyCommand;
        }
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.undoCommand =&lt;span&gt; emptyCommand; // 初始化 undo 命令
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setCommand(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; idx, ICommand3 onCommand, ICommand3 offCommand) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.onCommands[idx] =&lt;span&gt; onCommand;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.offCommands[idx] =&lt;span&gt; offCommand;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; executeOnCommand(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; idx) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.onCommands[idx].execute();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.undoCommand = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.onCommands[idx];
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; executeOffCommand(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; idx) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.offCommands[idx].execute();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.undoCommand = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.offCommands[idx];
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; undoCommand() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.undoCommand.undo();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;客户端&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
        MainController mainController = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MainController();
        Light roomLight &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Light();
        LightOffCommand offCommand &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LightOffCommand(roomLight);
        LightOnCommand onCommand &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LightOnCommand(roomLight);
        mainController.setCommand(&lt;/span&gt;0&lt;span&gt;, onCommand, offCommand);
        mainController.executeOnCommand(&lt;/span&gt;0&lt;span&gt;);
        System.out.println();
        mainController.executeOffCommand(&lt;/span&gt;0&lt;span&gt;);
        System.out.println();
        mainController.undoCommand();
        System.out.println();
        mainController.executeOffCommand(&lt;/span&gt;0&lt;span&gt;);
        System.out.println();
        mainController.executeOnCommand(&lt;/span&gt;0&lt;span&gt;);
        System.out.println();
        mainController.undoCommand();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;电灯打开
灯光变强
灯光闪烁

电灯关闭

电灯打开

电灯关闭

电灯打开
灯光变强
灯光闪烁

灯光停止闪烁
灯光变弱
电灯关闭&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;个人觉得，唯一的缺点就是会使得程序复杂性提高，但是我认为微不足道，基础扎实的 RD 应该无压力阅读和使用才对，因为在多线程程序里，该模式大量出现，比如 Netty 等框架就大量使用了该思想。 &lt;/p&gt;

&lt;p&gt;策略是不同的算法做同一件事情。不同的策略之间可以相互替换。比如实现一个支付功能，有微信支付，支付宝支付，各自渠道的支付。。。&lt;/p&gt;
&lt;p&gt;命令是不同的命令做不同的事情。对外隐藏了具体的执行细节。比如菜单中的复制，移动和压缩&lt;/p&gt;

&lt;p&gt;最最常见的就是 lang 包里的 Runnable 接口，这就是一个命令接口，将对线程启动的请求和具体的执行分离了。实现该接口，也是启动线程推荐的写法&lt;/p&gt;
</description>
<pubDate>Wed, 06 Feb 2019 13:49:00 +0000</pubDate>
<dc:creator>dashuai的博客</dc:creator>
<og:description>前言 个人感觉，该模式主要还是在多线程程序的设计中比较常用，尤其是一些异步任务执行的过程。但是本文还是打算先在单线程程序里总结它的用法，至于多线程环境中命令模式的用法，还是想在多线程的设计模式里重点总</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kubixuesheng/p/10353809.html</dc:identifier>
</item>
<item>
<title>进程同步经典示例 多线程上篇（五） - noteless</title>
<link>http://www.cnblogs.com/noteless/p/10350296.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/noteless/p/10350296.html</guid>
<description>&lt;p&gt;&lt;span&gt;同步回顾&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;进程同步控制有多种方式：&lt;/span&gt;&lt;span&gt;算法、硬件、信号量、管程&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;这些方式可以认为就是&lt;/span&gt;&lt;span&gt;同步的工具（方法、函数）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如信号量机制中的wait(S) 和 signal(S) ，就相当于是两个方法调用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;调用wait(S)就会申请这个资源，否则就会等待（进入等待队列）；调用signal(S)就会释放资源（或一并唤醒等待队列中的某个）；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在梳理同步问题的解决思路时，只需要合理安排方法调用即可，底层的实现细节不需要关注。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接下来以这种套路，看一下借助与不同的同步方式“算法、硬件、信号量、管程”这一“API”，如何解决经典的进程同步问题&lt;/span&gt;&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190206190519574-1560421897.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;生产者消费者&lt;/span&gt;&lt;/h3&gt;
&lt;div readability=&quot;20&quot;&gt;
&lt;hr noshade=&quot;noshade&quot;/&gt;&lt;p&gt;&lt;span&gt;生产者-消费者(producer-consumer)问题是一个著名的进程同步问题。它描述的是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有一&lt;span&gt;群生产者进程在生产产品，并将这些产品提供给消费者进程去消费。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;为使生产者进程与消&lt;/span&gt;&lt;span&gt;费者进程能并发执行，在两者之间设置了一个具有 n 个缓冲区的缓冲池，生产者进程将它&lt;/span&gt;&lt;span&gt;所生产的产品放入一个缓冲区中；消费者进程可从一个缓冲区中取走产品去消费。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;尽管所&lt;/span&gt;&lt;span&gt;有的生产者进程和消费者进程都是以异步方式运行的，但它们之间必须保持同步&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;也就是即不允&lt;/span&gt;&lt;span&gt;许消费者进程到一个空缓冲区去取产品，也不允许生产者进程向一个已装满产品且尚未被&lt;/span&gt;&lt;span&gt;取走的缓冲区中投放产品。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr noshade=&quot;noshade&quot;/&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;记录型信号量&lt;/span&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;对于缓冲池本身，可以借助一个互斥信号量mutex实现各个进程对缓冲池的互斥使用；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;生产者关注于缓冲池空位子的个数，消费者关注的是缓冲池中被放置好产品的满的个数&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190203140634138-449927561.png&quot;&gt;&lt;img title=&quot;image_5c568495_5abf&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190203140639601-1041444768.png&quot; alt=&quot;image_5c568495_5abf&quot; width=&quot;548&quot; height=&quot;257&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;所以，我们总共设置&lt;span&gt;三个信号量semaphore&lt;/span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;mutex&lt;/span&gt;值为&lt;span&gt;1&lt;/span&gt;，用于进程间互斥访问缓冲池&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;full&lt;/span&gt;表示缓冲区这一排坑中被放置产品的个数，初始时为&lt;span&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;empty&lt;/span&gt;表示缓冲区中空位子的个数，初始时为&lt;span&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;对于缓冲池以一个数组的形式进行描述：&lt;/span&gt;&lt;span&gt;buffer[n]&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;另外还需要定义两个用于对数组进行访问的下标 &lt;span&gt;in&lt;/span&gt; 和 &lt;span&gt;out&lt;/span&gt; ，初始时都是0，也就是生产者会往0号位置放置元素，消费者会从0号开始取&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;每次的操作之后，下标后移，in和out采用自增的方式，所以应该是循环设置，比如in为10时，应该从头再来，所以求余（简言之in out序号一直自增，通过求余循环）&lt;/span&gt;&lt;/p&gt;

&lt;div readability=&quot;8.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;变量定义&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; in=0, out=0&lt;span&gt;;
item buffer[n];
semaphore mutex&lt;/span&gt;=l，empty=n, full=0&lt;span&gt;;
 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;生产者&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; proceducer(){
&lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt;{
producer an item nextp;
......
wait(empty);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;等待空位子&lt;/span&gt;
wait(mutex);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;等待缓冲池可用&lt;/span&gt;
buffer[in] =nextp;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置元素&lt;/span&gt;
in =(in+1)%n;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;下标后移&lt;/span&gt;
signal(mutex);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;释放缓冲池&lt;/span&gt;
signal(full);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;“满”也就是已生产产品个数释放1个(+1)&lt;/span&gt;
}&lt;span&gt;while&lt;/span&gt;&lt;span&gt;(TRUE);
 
 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;消费者&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; consumer() {
&lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt;{
wait(full);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;等待已生产资源个数&lt;/span&gt;
wait(mutex);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;等待缓冲池可用&lt;/span&gt;
nextc= buffer[out];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获得一个元素&lt;/span&gt;
out =(out+1) % n;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;下标后移&lt;/span&gt;
signal(mutex);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;释放缓冲池&lt;/span&gt;
signal(empty);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;空位子多出来一个&lt;/span&gt;
consumer the item in nextc;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;消费掉获得的产品&lt;/span&gt;
} &lt;span&gt;while&lt;/span&gt;&lt;span&gt;(TRUE);
}
 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;主程序&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main() {
proceducer();
consumer();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;以上就是一个记录型信号量解决生产者消费者的问题的思路&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;对于信号量中用于实现互斥的wait和signal必须是成对出现的，尽管他们可能位于不同的程序中，这都无所谓，他们使用信号量作为纽带进行联系&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190203140645143-1905290356.png&quot;&gt;&lt;img title=&quot;image_5c568495_6434&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190203140649540-1615770663.png&quot; alt=&quot;image_5c568495_6434&quot; width=&quot;519&quot; height=&quot;172&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;h4&gt;&lt;span&gt;AND型信号量&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;对于生产者和消费者，都涉及两种资源，一个是缓冲池，一个是缓冲池空或满&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以可以将上面两种资源申请的步骤转换为AND型，比如&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;wait(empty);//等待空位子&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;wait(mutex);//等待缓冲池可用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;转换为AND的形式的Swait(empty，mutex)&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;11&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; in=0, out=0&lt;span&gt;;
item buffer[n];
semaphore mutex&lt;/span&gt;=l, empty=n, full=&lt;span&gt;O;
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; proceducer() {
&lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt;{
producer an item nextp;
......
Swait(empty, mutex);
buffer[in] &lt;/span&gt;=&lt;span&gt; nextp;
in &lt;/span&gt;=(in+1) %&lt;span&gt; n;
Ssignal(mutex, full)
} &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt;(TRUE);
}
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; consumer() {
&lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt;{
Swait(full, mutex);
nextc&lt;/span&gt;=&lt;span&gt; buffer[out];
out &lt;/span&gt;=(out+1) %&lt;span&gt; n;
Ssignal(mutex, empty);
consumer the item in nextc;
......
} &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt;(TRUE);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这个示例中，AND型信号量方案只是记录型信号量机制的一个简单升级&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;管程方案&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;管程由一组共享数据结构以及过程，还有条件变量组成。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;共享的数据结构就是缓冲池，大小为n&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;生产者向缓冲池中放入产品，定义过程put(item)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;消费者从缓冲池中取出产品，定义过程get(item)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于生产者，非满 not full 就可以继续生产数据；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于消费者，非空 not empty 就可以继续消费数据；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以设置两个条件：notfull，notempty&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果数据个数 count&amp;gt;=N，那么 notfull 非满条件不成立&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果数据个数 count&amp;lt;=0，那么notempty 非空条件不成立&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;也就是说：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;count&amp;gt;=N，notfull 不满足，生产者就会在 notfull 条件上等待&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;count&amp;lt;=0N，notempty 不满足，消费者就会在 notempty 条件上等待&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;8.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义一个管程&lt;/span&gt;&lt;span&gt;
Monitor procducerconsumer {
item buffer[N];&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;缓冲区大小&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; in, out;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;访问下标&lt;/span&gt;&lt;span&gt;
condition notfull, notempty;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;条件变量&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; count;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;已生产产品的个数
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;生产方法&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; put(item x) {
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(count&amp;gt;=&lt;span&gt;N){
notfull.wait; &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果生产个数已经大于缓冲区大小，将生产进程添加到notfull条件的等待队列中&lt;/span&gt;&lt;span&gt;
}
buffer[in] &lt;/span&gt;= x; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置元素&lt;/span&gt;&lt;span&gt;
in &lt;/span&gt;= (in+1) % N; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;下标移动&lt;/span&gt;&lt;span&gt;
count&lt;/span&gt;++;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;已生产产品个数+1&lt;/span&gt;&lt;span&gt;
notempty.signal &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;释放等待notempty条件的进程&lt;/span&gt;&lt;span&gt;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取方法&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; get(item x) {
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(count&amp;lt;=0&lt;span&gt;){
notempty.wait; &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果已生产产品数量为0（以下），消费者进程添加到notempty的等待队列中&lt;/span&gt;&lt;span&gt;
}
x &lt;/span&gt;= buffer[out];&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 读取元素&lt;/span&gt;&lt;span&gt;
out &lt;/span&gt;= (out+1) % N; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 下标移动&lt;/span&gt;&lt;span&gt;
count&lt;/span&gt;--; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;已生产产品个数-1&lt;/span&gt;&lt;span&gt;
notfull.signal; &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 释放等待notfull条件的进程&lt;/span&gt;&lt;span&gt;
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化数据方法&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; init(){
in&lt;/span&gt;=0;out=0;count=0&lt;span&gt;;
}
} PC;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;生产者和消费者逻辑&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; producer(){
item x;
&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt;(TRUE){
produce an item in nextp;
PC.put(x);
}
}
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; consumer( {
item x;
&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt;(TRUE) {
PC.get(x);
consume the item in nextc;
......
}
}
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(){
proceducer();
consumer();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;管程的解决思路就是将同步的问题封装在管程内部，管程会帮你解决所有的问题&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;哲学家进餐&lt;/span&gt;&lt;/h3&gt;

&lt;div readability=&quot;19&quot;&gt;
&lt;p&gt;&lt;span&gt;由Dijkstra提出并解决的哲学家进餐问题(The Dinning Philosophers Problem)是典型的同&lt;span&gt;步问题。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;该问题是描述有五个哲学家共用一张圆桌，分别坐在周围的五张椅子上，在圆桌&lt;/span&gt;&lt;span&gt;上有五个碗和五只筷子，他们的生活方式是交替地进行思考和进餐。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;平时，一个哲学家进&lt;/span&gt;&lt;span&gt;行思考，饥饿时便试图取用其左右最靠近他的筷子，只有在他拿到两只筷子时才能进餐。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;进餐完毕，放下筷子继续思考。 &lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190203140651861-523892948.png&quot;&gt;&lt;img title=&quot;image_5c568495_2aeb&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190203140652696-760097453.png&quot; alt=&quot;image_5c568495_2aeb&quot; width=&quot;416&quot; height=&quot;355&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;灰色大圆桌，黄色凳子，每个人左右各有一根筷子，小圆点表示碗。（尽管画的像乌龟，但这真的是桌子 ￣□￣｜｜）&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;h4&gt;&lt;span&gt;记录型信号量机制&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;放在桌子上的筷子是临界资源，同一根筷子不可能被两个人同时使用，所以每一根筷子都是一个共享资源&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;需要使用五个信号量表示，五个信号量每个表示一根筷子&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span&gt;当哲学家饥饿时，总是先去拿他左边的筷子，即执行wait(chopstick[i])； &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;成功后，再去拿他右边的筷子，即执行wait(chopstick[(i+1)mod 5])；又成功后便可进餐。（i+1)mod 5 是为了处理第五个人右边的是第一个的问题 ）&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;进餐完毕，又先放下他左边的筷子，然后再放右边的筷子。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;div readability=&quot;9.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义五个信号量
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;为简单起见，假定数组起始下标为1
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;信号量全部初始化为1&lt;/span&gt;&lt;span&gt;
semaphore chopstick[&lt;/span&gt;5]={1,1,1,1,1&lt;span&gt;};
&lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;按照我们上面图中所示，第 i号哲学家，左手边为i号筷子，右手边是 (i+1)%5&lt;/span&gt;
wait(chopstick[i]);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;等待左手边的，&lt;/span&gt;&lt;span&gt;
wait(chopstick[(i&lt;/span&gt;+1)%5]);]);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;等待右手边的
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 进餐......&lt;/span&gt;&lt;span&gt;
signal(chopstick[i]);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;释放左手边的&lt;/span&gt;&lt;span&gt;
signal(chopstick[(i&lt;/span&gt;+1)%5])&lt;span&gt;//&lt;/span&gt;&lt;span&gt;释放右手边的
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 思考......&lt;/span&gt;&lt;span&gt;
} &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(TRUE);
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;通过这种算法可以保证相邻的两个哲学家之间不会出现问题，但是一旦五个人同时拿起左边的筷子，都等待右边的筷子，将会出现死锁&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有几种解决思路&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;19&quot;&gt;
&lt;p&gt;&lt;span&gt;(1)至多只允许有四位哲学家同时去拿左边的筷子&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以保证肯定会空余一根筷子，并且没拿起筷子的这个人的左手边的这一根，肯定是已经拿起左手边筷子的某一个人的右手边，所以肯定不会死锁&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(2)  仅当哲学家的左、右两只筷子均可用时，才允许他拿起筷子进餐。 也就是AND机制，将左右操作转化为“原子”&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;17&quot;&gt;
&lt;p&gt;&lt;span&gt;(3)  规定奇数号哲学家先拿他左边的筷子，然后再去拿右边的筷子，而偶数号哲学家则相反。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如上图所示，1抢1号筷子，2号和3号哲学家竞争3号筷子，4号和5号哲学家竞争5号筷子，所有人都是先竞争奇数，然后再去竞争偶数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这一条是为了所有的人都会先竞争奇数号筷子，那么也就是最多三个人抢到了奇数号筷子，有两个人第一步奇数号筷子都没抢到的这一轮就相当于出局了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;三个人，还有两个偶数号筷子，必然会有一个人抢得到&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h4&gt;&lt;span&gt;AND型信号量&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;哲学家进餐需要左手和右手的筷子，所以可以将左右手筷子的获取操作原子化，借助于AND型信号量&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;10.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义五个信号量
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;为简单起见，假定数组起始下标为1
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;信号量全部初始化为1&lt;/span&gt;&lt;span&gt;
semaphore chopstick[&lt;/span&gt;5]={1,1,1,1,1&lt;span&gt;};

&lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;按照我们上面图中所示，第 i号哲学家，左手边为i号筷子，右手边是 (i+1)%5&lt;/span&gt;&lt;span&gt;
Swait(chopstick[i],chopstick[(i&lt;/span&gt;+1)%5&lt;span&gt;]))
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 进餐......&lt;/span&gt;&lt;span&gt;
Ssignal(chopstick[i],chopstick[(i&lt;/span&gt;+1)%5&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 思考......&lt;/span&gt;&lt;span&gt;
} &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt;(TRUE);
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;h3&gt;&lt;span&gt;读者写者问题&lt;/span&gt;&lt;/h3&gt;
&lt;div readability=&quot;18&quot;&gt;
&lt;hr noshade=&quot;noshade&quot;/&gt;&lt;p&gt;&lt;span&gt;一个数据文件或记录，可被多个进程共享，我们把只要求读该文件的进程称为“Reader进程” ，其他进程则称为“Writer 进程” 。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;允许多个进程同时读一个共享对象，因为读操作不会使数据文件混乱。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但不允许一个Writer 进程和其他Reader 进程或 Writer 进程同时访问共享对象，因为这种访问将会引起混乱。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所谓“读者—写者问题(Reader-Writer  Problem)”是指保证一个 Writer 进程必须与其他进程互斥地访问共享对象的同步问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;读者—写者问题常被用来测试新同步原语。 &lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span&gt;很显然，只有多个读者时不冲突&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190203140652923-394197183.png&quot;&gt;&lt;img title=&quot;image_5c568495_6e&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190203140653279-1137755174.png&quot; alt=&quot;image_5c568495_6e&quot; width=&quot;532&quot; height=&quot;122&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;

&lt;h4&gt;&lt;span&gt;记录型信号量机制&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;读和写之间是互斥的，所以需要一个信号量用于读写互斥Wmutex&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;另外如果有读的进程存在，另外的进程如果想要读的话，不需要同步也就是Wait(Wmutex)操作；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果当前没有进程在读，那么需要Wait(Wmutex)操作，所以设置一个变量记录写者个数Readcount，可以用来判断是否需要同步&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;另外Readcount 会被多个读者进程访问，所以也是临界资源，所以设置一个rmutex 用于互斥访问Readcount&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;两个信号量，一个用于读者互斥 readcount ，一个用于读写互斥&lt;/span&gt;&lt;span&gt;
semaphore rmutex&lt;/span&gt;=l,wmutex=1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; readcount=0;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始时读者个数为0
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;读者&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; reader() {
&lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt;{
wait(rmutex);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;读者先获取 readcount&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt;(readcount==0){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果一个读者没有，第一个读者需要与写者互斥访问&lt;/span&gt;&lt;span&gt;
wait(wmutex);
}
readcount&lt;/span&gt;++;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;读者个数+1&lt;/span&gt;&lt;span&gt;
signal(rmutex);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;读者个数+1后，可以释放readcount的锁，其他读者可以进来
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开始慢慢读书......&lt;/span&gt;&lt;span&gt;
wait(rmutex);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;读者结束时，需要获取readcount的锁&lt;/span&gt;&lt;span&gt;
readcount&lt;/span&gt;--;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;退出一个读者&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; (readcount==0) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果此时一个读者都没有了，还需要释放与读写互斥的锁&lt;/span&gt;&lt;span&gt;
signal(wmutex);
}
signal(rmutex);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;释放readcount的锁&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt;(TRUE);
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; writer(){
&lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt;{
wait(wmutex);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;写者必须获得wmutex
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行写任务....&lt;/span&gt;&lt;span&gt;
signal(wmutex);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;写任务结束后就可以释放锁&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt;(TRUE);

}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;主程序&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main() {
reader();
writer();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;写者相对比较简单，获得锁wmutex之后，进行写操作，否则等待wmutex&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;读者也是需要先获得锁，读操作后释放锁，但是因为多个读者之间互不影响，所以使用readcount记录读者个数，只有第一个读者才需要竞争wmutex，只有最后一个读者才需要释放wmutex&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;readcount作为读者之间的竞争资源，所以对readcount进行操作的时候也需要进行加锁&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;信号量集机制&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;将读者写者的问题复杂化一点，&lt;span&gt;它增加了一个限制，即最多只允许 N个读&lt;/span&gt;&lt;span&gt;者同时读。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在上面的解决方法中，可以不使用rmutex控制对readcount的互斥，可以构造一个读者个数的信号量readcountmutex，初始值设置为N&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;每次新增一个读者时，wait(readcountmutex)，一个读者离开时signal(readcountmutex)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;也可以使用信号量集机制&lt;/span&gt;&lt;/p&gt;

&lt;div readability=&quot;13&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; N;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;最大的读者个数，也就是相当于图书馆的空位子，初始时空位子为N&lt;/span&gt;
&lt;span&gt;
semaphore L&lt;/span&gt;=N, mx=1;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义两个信号量资源L和mx，分别用于控制读者个数限制和读写（写写)&lt;/span&gt;

&lt;span&gt;void&lt;/span&gt;&lt;span&gt; reader() {

&lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt;{

Swait(L, &lt;/span&gt;1, 1);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取空位子L，每次获取1个，&amp;gt;=1时可分配&lt;/span&gt;
&lt;span&gt;
Swait(mx, &lt;/span&gt;1, 0);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取与写的互斥量mx，每次获取0个，&amp;gt;=1时可分配，如果mx为1，也就是没有写者，读者都可以进来，否则一个都进不来

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;进行一些读操作&lt;/span&gt;
&lt;span&gt;
Ssignal(L, &lt;/span&gt;1);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;释放一个单位的资源L&lt;/span&gt;
&lt;span&gt;
}&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt;(TRUE);

}
 

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; writer() {

&lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt;{

Swait(mx,&lt;/span&gt;1,1; L,N,0);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获得资源mx，每次获取1个，&amp;gt;=1时分配，获得资源L，每次获得0个，&amp;gt;=N时即可分配

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;进行一些写操作&lt;/span&gt;
&lt;span&gt;
Ssignal(mx, &lt;/span&gt;1);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;释放资源mx&lt;/span&gt;
&lt;span&gt;
}&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt;(TRUE);

}


&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(){

reader();

writer();

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;Swait(L, 1, 1);用于获取读者空位子没什么好说的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Swait(mx, 1, 0);作为开关，只要mx满足条件&amp;gt;=1，那么就可以无限制的进入（此例中有L的限制），一旦条件不满足，则全都不能进入，满足多读者，有写不能读的情况&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于写者中的Swait(mx,1,1; L,N,0);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;他会获取mx，&amp;gt;=1时，获取一个资源，并且当L&amp;gt;=N时，分配0个L资源，也就是说一个读者都没有的时候才行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Swait(mx, 1, 0); 与Swait( L,N,0);都是需求0个，相当于开关判断&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;以上为借助“进程同步的API”，信号量，管程等方式完成进程同步的经典示例，例子来源于《计算机操作系统》&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;说白了，就是用 wait(S)   Swait(S)   signal(S)   Ssignal(S)等这些“方法”描述进程同步算法&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;可能会觉得这些内容乱七八糟的，根本没办法使用，的确这些内容全都没办法直接转变为代码写到你的项目中&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是，这些都是解决问题的思路&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不管是信号量还是管程还是什么，不会需要你从头开始实现一个信号量，然后.......也不需要你从头开始实现一个管程，然后......&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不管是操作系统层面，还是编程语言层面，还是具体的API，万变不离其宗&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;尽管这些wait和signal的确不存在，但是，但是，但是编程语言中很可能已经提供了语意相同的方法供你调用了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;也就是说，你只需要理解同步的思路即可，尽管没有我们此处说的wait（S）,但是肯定有对应物。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 06 Feb 2019 11:03:00 +0000</pubDate>
<dc:creator>noteless</dc:creator>
<og:description>以上同步示例，是借助于前文提到的进程同步机制与工具的一个简单的应用，前文中的信号量机制管程机制等就是同步工具，本文的实例就是“”“同步工具”这些方法的一个调用而已，希望借助于几个简单的示例能够对线程同</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/noteless/p/10350296.html</dc:identifier>
</item>
<item>
<title>Netty学习问题总结 - 陈芳志</title>
<link>http://www.cnblogs.com/chenfangzhi/p/10353920.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenfangzhi/p/10353920.html</guid>
<description>&lt;p&gt;本篇记录了Netty学习过程中想到的问题和自己的一些思考，对于应用层的协议也有了更好的理解，所以在此做一个记录。&lt;/p&gt;
&lt;h3 id=&quot;一http协议分包&quot;&gt;一、HTTP协议分包&lt;/h3&gt;
&lt;p&gt;TCP是作为面来流的协议，所以需要应用层协议自己去分包。常见的分包格式如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;定长： 比如100字节每个报文，不足的前面补0，这时候每次取消息就取到100字节算整包)&lt;/li&gt;
&lt;li&gt;分隔符： 换行符其实是一种特别的分隔符，每次读取到分隔符就知道一个包读取完毕)&lt;/li&gt;
&lt;li&gt;指明长度： 比如前两个字节为长度字段，先读取两个字节，知道了需要多少字节，读取到对应的字节就是一个整包了&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;然而HTTP协议格式并不是上面的简单的一种，它结合了2和3两种来进行分包，因为请求和响应报文格式一样，所以这里针对请求报文进行说明。我们知道HTTP分为请求行，请求头，请求体。&lt;br/&gt;下面是报文说明摘自&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;HTTP RFC文档&lt;/a&gt;中4.1 Message Types：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HTTP报文格式&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    generic-message = start-line
                      *(message-header CRLF)
                      CRLF
                      [ message-body ]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.jiangmiantex.com/http%E6%8A%A5%E6%96%87.png&quot; alt=&quot;HTTP报文格式&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;报文读取过程&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;读取请求行：每个HTTP请求的第一行作为请求行，所以知道读取到CRLF就说明结束了&lt;/li&gt;
&lt;li&gt;读取请求头：请求头有多行，行数不是固定的，他的结尾是根据连续的两个CRLF来判断的，在message-body之前会有一个CRLF&lt;/li&gt;
&lt;li&gt;读取请求体：对于POST等带有请求体的方法来说，请求体的长度是不固定的，这时候请求头中会有个Content-Length字段说明了请求体的长度，所以只要读取完Content-Length个字节，整个HTTP请求报文也就得到了&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;关于报文分割一点备注&lt;/strong&gt;：早期的HTTP 1.0时代，因为它每次请求都会经历tcp的三次握手连接过程，所以它是通过连接的关闭来判断报文已经读取完毕，但是这里还有一个问题，如果这个连接关闭时因为服务端的错误引起的那客户端就无法区分了。到了HTTP 1.1，因为很多请求会重用一个连接，所以需要用到Content-Length这个字段来做分包。另外还有一种不需要Content-Length的方法就是请求头中Transfer-Encoding为chunked，这是一种分块传输，在压缩传输，动态内容生成等响应在一开始长度未知的场景下很有用。他的报文分割也很简单，详情参见：&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%88%86%E5%9D%97%E4%BC%A0%E8%BE%93%E7%BC%96%E7%A0%81&quot;&gt;分块传输编码&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;二websocket协议分包&quot;&gt;二、WebSocket协议分包&lt;/h2&gt;
&lt;p&gt;理解了HTTP协议的分包，WebSocket的协议也容易理解，道理都是想通的。一开始在谷歌的时候一直搜索不到相关的报文，最后搜索WebSocket数据帧才搜到了结果(搜索是门技巧啊)。我最关注的是opcode字段，因为在用WebSocket的时候就用到了这个字段来判断是什么帧类型。第二是Payload len字段，这是一个变长字段，为了节省字节数，含义如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如果数据长度小于等于125的话，那么该7位用来表示实际数据长度。&lt;/li&gt;
&lt;li&gt;如果数据长度为126到65535(2的16次方)之间，该7位值固定为126，也就是 1111110，往后扩展2个字节(16为，第三个区块表示)，用于存储数据的实际长度。&lt;/li&gt;
&lt;li&gt;如果数据长度大于65535， 该7位的值固定为127，也就是 1111111 ，往后扩展8个字节(64位)，用于存储数据实际长度。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;摘录自：&lt;a href=&quot;https://www.cnblogs.com/tugenhua0707/p/8542890.html%EF%BC%8C%E5%85%B7%E4%BD%93%E5%85%B3%E4%BA%8EWebSocket%E5%8F%AF%E4%BB%A5%E6%9F%A5%E9%98%85%E8%B5%84%E6%96%99%EF%BC%8C%E6%9C%89%E9%9D%9E%E5%B8%B8%E5%A4%9A%E7%9A%84%E8%AE%B2%E8%A7%A3&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/tugenhua0707/p/8542890.html，具体关于WebSocket可以查阅资料，有非常多的讲解&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc6455#section-5.2&quot;&gt;WebSocket RFC&lt;/a&gt;中websocket报文格式&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-------+-+-------------+-------------------------------+
     |F|R|R|R| opcode|M| Payload len |    Extended payload length    |
     |I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |
     |N|V|V|V|       |S|             |   (if payload len==126/127)   |
     | |1|2|3|       |K|             |                               |
     +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +
     |     Extended payload length continued, if payload len == 127  |
     + - - - - - - - - - - - - - - - +-------------------------------+
     |                               |Masking-key, if MASK set to 1  |
     +-------------------------------+-------------------------------+
     | Masking-key (continued)       |          Payload Data         |
     +-------------------------------- - - - - - - - - - - - - - - - +
     :                     Payload Data continued ...                :
     + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
     |                     Payload Data continued ...                |
     +---------------------------------------------------------------+&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;三http和websocket协议共用一个端口的问题&quot;&gt;三、HTTP和WebSocket协议共用一个端口的问题&lt;/h2&gt;
&lt;p&gt;之前对这个现象十分不理解，很多Web服务器例如Tomcat都支持HTTP和WebSocket共用一个端口，他是怎么做到的？&lt;/p&gt;
&lt;p&gt;其实理解了报文的解析就很容易理解了，HTTP和WebSocket协议的下层都是TCP连接，他们是应用层连接，所以在处理TCP的字节流时，可以先获取几个字节，如果前几个字节解析出来是GET，POST等HTTP协议的用到的，那么就根据HTTP报文的分包规则获取一个HTTP报文然后流转到后端处理。如果是WebSocket协议就根据WebSocket报文来解析然后做响应的处理。&lt;/p&gt;
&lt;p&gt;补充：很多的协议栈都是以魔数打头，这样就更容易实现同端口多协议的支持，如Dubbo协议栈前两个字节是魔数，只需要判断报文的前两个字节就知道是不是Dubbo协议了，Dubbo协议栈头报文如下图(摘抄自http://ifeve.com/dubbo-protocol/)：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.jiangmiantex.com/Dubbo%E5%8D%8F%E8%AE%AE%E6%A0%88.png&quot; alt=&quot;Dubbo协议栈&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;四time-wait状态占用了什么资源&quot;&gt;四、TIME WAIT状态占用了什么资源&lt;/h2&gt;
&lt;p&gt;我们知道TCP四次挥手时主动发起方会经历一个TIME WAIT状态，也正是因为这个原因我们尽量让客户端主动关闭连接。对于这个状态有人说是占用了文件描述符，有人说是端口，那么究竟是占用了什么资源？&lt;/p&gt;
&lt;p&gt;根据我自己的实验，Windows系统下，TIME WAIT状态占用了端口，该端口不能作为客户端端口使用，但仍然可以作为服务端端口使用。实验端口：服务端8080，客户端6060 。情况如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;客户端主动关闭，客户端重启时报BindException，服务端用6060端口仍可正常启动&lt;/li&gt;
&lt;li&gt;服务端主动关闭，服务端重启正常，客户端重启也正常，但是如果停掉服务端8080，客户端用6060报BindException&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;实验代码如下，可根据需要自己修改试验：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;服务端主动关闭&lt;/strong&gt;：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ServerSocketCloseTest {
    public static void main(String[] args) throws IOException, InterruptedException {
        Runnable runnable = () -&amp;gt; {
            try {
                ServerSocket serverSocket = null;
                serverSocket = new ServerSocket(8080, 10);
                while (true) {
                    Socket accept = serverSocket.accept();
                    accept.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        };
        new Thread(runnable).start();
        Socket socket = new Socket(InetAddress.getLocalHost(), 8080, InetAddress.getLocalHost(), 6060);
        Thread.sleep(1000);
        socket.close();
        System.in.read();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;客户端主动关闭场景&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ClientSocketCloseTest {

    public static void main(String[] args) throws IOException, InterruptedException {
        Runnable runnable = () -&amp;gt; {
            try {
                ServerSocket serverSocket = new ServerSocket(8080, 10);
                while (true) {
                    Socket accept = serverSocket.accept();
                    Thread.sleep(1000);
                    accept.close();
                }
            } catch (IOException | InterruptedException e) {
                e.printStackTrace();
            }
        };
        new Thread(runnable).start();

        Socket socket = new Socket(InetAddress.getLocalHost(), 8080, InetAddress.getLocalHost(), 6060);
        socket.close();
        Thread.sleep(1000);
        System.in.read();
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结论：处于TIME WAIT状态下的端口不能作为客户端端口使用。对于服务端端口没有影响，服务端是仍然是可以正常绑定，接收到客户端连接后本地端口和监听端口是同一个所以不存在端口占用。另外通过查阅资料，TIME WAIT是释放了文件描述符，但是TCP连接的五元组并未释放，还占用一定的内存。参考地址如下：&lt;a href=&quot;https://stackoverflow.com/questions/1803566/what-is-the-cost-of-many-time-wait-on-the-server-side/1806033#1806033&quot; class=&quot;uri&quot;&gt;https://stackoverflow.com/questions/1803566/what-is-the-cost-of-many-time-wait-on-the-server-side/1806033#1806033&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;五关于&quot;&gt;五、关于&lt;/h2&gt;
&lt;p&gt;待补充&lt;/p&gt;
</description>
<pubDate>Wed, 06 Feb 2019 10:42:00 +0000</pubDate>
<dc:creator>陈芳志</dc:creator>
<og:description>[TOC] 本篇记录了Netty学习过程中想到的问题和自己的一些思考，对于应用层的协议也有了更好的理解，所以在此做一个记录。 一、HTTP协议分包 TCP是作为面来流的协议，所以需要应用层协议自己去分</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenfangzhi/p/10353920.html</dc:identifier>
</item>
<item>
<title>最小生成树算法 - 风沙迷了眼</title>
<link>http://www.cnblogs.com/fsmly/p/10215179.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fsmly/p/10215179.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;最小生成树的形成&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;　　(1)一个贪心策略设计如下&lt;br/&gt;       每个时刻生长最小生成树的一条边，并在整个策略的实施过程中，遵守下述循环不变式的边集合A：&lt;br/&gt;          &lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201901/1368768-20190103133912079-926071865.png&quot; alt=&quot;&quot; width=&quot;327&quot; height=&quot;29&quot;/&gt;&lt;br/&gt;　　每一步，选择一条边(u,v)加入集合A，使得A不违反循环不变式。&lt;br/&gt;　　这样的边使得我们可以“安全地”将之加入到集合A而不会破坏A的循环不变式，因此称之为集合A的“安全边”。&lt;br/&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201901/1368768-20190103133948335-1995435439.png&quot; alt=&quot;&quot; width=&quot;252&quot; height=&quot;102&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　(2)使用的循环不变式方式如下：&lt;br/&gt;　　初始化：集合A直接满足循环不变式。&lt;br/&gt;　　保持：算法的循环通过只加入安全边来维持循环不变式。&lt;br/&gt;　　终止：所有加入到集合A中的边都属于某棵最小生成树，因此，算法第5行所返回的集合A必然是一棵最小生成树。&lt;br/&gt;　　说明：循环不变式告诉了我们存在一棵生成树，满足&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201901/1368768-20190103134144131-1151829200.png&quot; alt=&quot;&quot; width=&quot;31&quot; height=&quot;15&quot;/&gt;。在进入while循环时，A是T的真子集，因此必然存在一条边&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201901/1368768-20190103134203635-1915183471.png&quot; alt=&quot;&quot; width=&quot;50&quot; height=&quot;17&quot;/&gt;，使得&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201901/1368768-20190103134229187-1193655311.png&quot; alt=&quot;&quot; width=&quot;61&quot; height=&quot;19&quot;/&gt;，并且(u,v)对于集合A是安全的。&lt;br/&gt;　　(3)定义一些概念&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201901/1368768-20190103134420057-1462785353.png&quot; alt=&quot;&quot; width=&quot;359&quot; height=&quot;120&quot;/&gt;&lt;br/&gt;　　切割：无向图G=(V,E)的一个切割(S,V-S)是集合V的一个划分。&lt;/p&gt;
&lt;p&gt;　　横跨切割：如果一条边(u,v)∈E的一个端点在集合S中，另一个端点在集合V-S中，则称该条边横跨切割(S,V-S)。&lt;/p&gt;
&lt;p&gt;　　尊重集合：如果集合A中不存在横跨该切割的边，则称该切割尊重集合A。&lt;/p&gt;
&lt;p&gt;　　轻量级边：在横跨一个切割的所有边中，权重最小的边称为轻量级边&lt;/p&gt;
&lt;p&gt;　　(4)距离说明上述概念&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201901/1368768-20190103134930800-250892019.png&quot; alt=&quot;&quot; width=&quot;598&quot; height=&quot;277&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　图(a)中所示的黑色结点位于集合S中，白色结点位于V-S中。横跨该切割的边是那些连接白色结点和黑色结点的边。如&amp;lt;a,h&amp;gt;&amp;lt;b,c&amp;gt;&amp;lt;c,d&amp;gt;等等，其中&amp;lt;d,c&amp;gt;是轻量级边。若定义加了阴影的边属于集合A，那么可以看出集合A中没有横跨切割的边，所以切割&amp;lt;S,V-S&amp;gt;尊重集合A。&lt;/p&gt;
&lt;p&gt;　　图(b)中是同样一个图，只是换了视角。&lt;/p&gt;
&lt;p&gt;　　(5)辨认安全边的规则&lt;/p&gt;
&lt;p&gt;　　设G=(V,E)是一个在边E上定义了实数值权重函数ω的连通无向图。设集合A为E的一个子集，且A包含在图G的某棵最小生成树中，设(S,V-S)是图G中尊重集合A的任意一个切割，&lt;/p&gt;
&lt;p&gt;又设(u,v)是横跨切割(S,V-S)的一条轻量级边。那么边(u,v)对于集合A是安全的。&lt;/p&gt;
&lt;p&gt;　　证明：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201901/1368768-20190103142152388-52881631.png&quot; alt=&quot;&quot; width=&quot;257&quot; height=&quot;289&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　我们现在构建一个最小生成树T ′，通过将A∪{(u,v)}包括在树T '中，从而证明(u,v)对集合A来说是安全的。T中包含有G的所有结点，所以(u,v)与T中从结点u到结点v的简单路径p形成一个环。如上图所示。由于结点u，v分别处于切割S，V-S中，T中至少含有一条简单路径p并且横跨该切割。假设(x,y)是这样一条边。由于切割(S,V-S)尊重集合A，所以(x,y)不在集合A中。又因为（x，y）位于T中从u到v的唯一一条简单路径上，将这条边删除会导致T被分为两个连通分量，这时候，将（u，v）加入就能将这两个连通分量连接起来成为一颗心得生成树&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201901/1368768-20190103142930698-507209905.png&quot; alt=&quot;&quot; width=&quot;189&quot; height=&quot;19&quot;/&gt;。&lt;/p&gt;
&lt;p&gt;　　这时候我们来证明T ′是一颗最小生成树。&lt;/p&gt;
&lt;p&gt;　　由于（u，v）是横跨切割的一条轻量级边，并且边（x，y）也横跨该切割，所以我们有ω(u,v)≤ ω(x,y)，所以可以简单得出这样一个关系&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201901/1368768-20190103143200451-1945645408.png&quot; alt=&quot;&quot; width=&quot;410&quot; height=&quot;63&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　又因为T是一颗最小生成树，ω(T) ≤ ω(T ')，因此T ′也是一颗最小生成树。&lt;/p&gt;
&lt;p&gt;　　因为 A∈T，且 （x，y）∉A，所以A∈T ' 。因此&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201901/1368768-20190103143546401-371147985.png&quot; alt=&quot;&quot; width=&quot;144&quot; height=&quot;28&quot;/&gt;。由于T ' 是最小生成树，(u,v)对于集合A而言是安全的。&lt;/p&gt;
&lt;p&gt;　　在算法GENERIC-MST推进的过程中，集合A始终保持无环状态( 每条边都是安全的 )。算法执行的任意时刻，图G A =(V,A)是一个森林。&lt;/p&gt;
&lt;p&gt;　　while循环执行|V|-1次，每次找出构造最小生成树所需的一条边。每遍循环将树的数量减少1。当整个森林只含有一棵树时，算法终止。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Kruskal算法&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;　　Kruskal和Prim算法是求解最小生成树的两个经典算法。它们都是GENERIC-MST算法的具体细化：&lt;/p&gt;
&lt;p&gt;　　(1)Kruskal算法找安全边的方法：在所有连接森林中两棵不同树的边中，找权重最小的边(u,v)。设C 1 和C 2 为边(u,v)所连接的两棵树。边(u,v)是C 1 的一条安全边。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201901/1368768-20190103144819806-389369819.png&quot; alt=&quot;&quot; width=&quot;416&quot; height=&quot;169&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　(2)简单讲述一下Kruskal算法的工作过程。算法的1~3行将集合A初始化为一个空集，并创建|V|棵树，每棵树仅包含一个结点，作为初始情况。5~8行中的for循环按照权重从低到高的次序对每一条边逐一进行检查。&lt;span&gt;&lt;span&gt;对于每条边(u,v)而言，循环将检查该结点u和结点v是否属于同一棵树。如果是，这条边不能加入，避免形成环路。&lt;/span&gt;&lt;span&gt;如果不是，则两个端点分别属于不同的树，算法第7行将吧这些边加入到集合A中，第8行将两棵树进行合并。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　(3)下面给出一个具体的例子看看算法的流程&lt;/p&gt;
&lt;p&gt;　　①首先找到最小权重的边为&amp;lt;h,g&amp;gt; = 1&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201901/1368768-20190103144915742-220307267.png&quot; alt=&quot;&quot; width=&quot;337&quot; height=&quot;133&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　②继续寻找下一条权重次小的边，以此类推&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201901/1368768-20190103145018807-406781822.png&quot; alt=&quot;&quot; width=&quot;312&quot; height=&quot;116&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201901/1368768-20190103145143228-1590169951.png&quot; alt=&quot;&quot; width=&quot;273&quot; height=&quot;111&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201901/1368768-20190103145201951-1395110415.png&quot; alt=&quot;&quot; width=&quot;282&quot; height=&quot;108&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201901/1368768-20190103145258641-21317444.png&quot; alt=&quot;&quot; width=&quot;289&quot; height=&quot;116&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201901/1368768-20190103145221932-1549367411.png&quot; alt=&quot;&quot; width=&quot;277&quot; height=&quot;111&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　③注意到，(f)图中此时权重为6的边的两个端点i和g都属于同一棵树(&amp;lt;i,c,f,g,h&amp;gt;)中，所以不能加这条边加入，否则会形成环路&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201901/1368768-20190103145345603-921927779.png&quot; alt=&quot;&quot; width=&quot;275&quot; height=&quot;106&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201901/1368768-20190103145539249-2013648672.png&quot; alt=&quot;&quot; width=&quot;262&quot; height=&quot;110&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　④同③一样，（h）图中的权重为7的边不同加入集合中，避免形成环路(&amp;lt;i,c,f,g,h&amp;gt;)&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201901/1368768-20190103145556067-1239868670.png&quot; alt=&quot;&quot; width=&quot;261&quot; height=&quot;103&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201901/1368768-20190103145723404-258509018.png&quot; alt=&quot;&quot; width=&quot;252&quot; height=&quot;107&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　⑤同④一样，（j）图中的权重为8的边不同加入集合中，避免形成环路(&amp;lt;a,b,d,c,f,g,h&amp;gt;)&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201901/1368768-20190103145752127-2117858419.png&quot; alt=&quot;&quot; width=&quot;298&quot; height=&quot;121&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201901/1368768-20190103145914049-500546443.png&quot; alt=&quot;&quot; width=&quot;289&quot; height=&quot;111&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　⑥同理，&amp;lt;e,f&amp;gt;边如果加入集合中，会形成环路&amp;lt;c,d,e,f&amp;gt;；&amp;lt;b,h&amp;gt;不能加入集合中，会形成&amp;lt;a,b,h&amp;gt;环路；&amp;lt;d,f&amp;gt;不能加入集合中，会形成&amp;lt;c,f,d&amp;gt;环路&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201901/1368768-20190103145941338-964950079.png&quot; alt=&quot;&quot; width=&quot;305&quot; height=&quot;117&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201901/1368768-20190103150049803-805039336.png&quot; alt=&quot;&quot; width=&quot;292&quot; height=&quot;119&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201901/1368768-20190103150104062-1733737950.png&quot; alt=&quot;&quot; width=&quot;300&quot; height=&quot;118&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Prim算法&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　(1)Prim算法的每一步是在连接集合A和A之外的结点的所有边中，选择一条轻量级边加入到A中。所加入的边对于A也是安全的。Prim算法的基本性质：集合A中的边总是构成一棵树。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201901/1368768-20190103153832171-878557558.png&quot; alt=&quot;&quot; width=&quot;291&quot; height=&quot;237&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 　　(2)简单描述一下上述算法的流程。1~5行将每个节点的key值设置为∞（除根节点r以外，根节点key值置为0，作为第一个被处理的点），然后将每个结点的父节点置为NIL，并对最小优先队列Q进行初始化，使其包含图中的所有节点。&lt;/p&gt;
&lt;p&gt;　　算法维持的循环不变式由3个部分组成：&lt;/p&gt;
&lt;p&gt;　　①A={(v,v.π):v∈V-{r}-Q}&lt;/p&gt;
&lt;p&gt;　　②已经加入到最小生成树中的结点集合为V-Q&lt;/p&gt;
&lt;p&gt;　　③对于所有结点v∈Q，如果v.π≠NIL，则v.key&amp;lt;∞并且v.key是连接结点v和最小生成树中某个节点的轻量级边(v,v.π)的权重&lt;/p&gt;
&lt;p&gt;　　第7行找出结点v∈Q，该结点是某条横跨切割&amp;lt;V-Q,Q&amp;gt;的轻量级边的一个端点，然后将结点u从队列中删除，并将其加入到集合V-Q中，也就是将边&amp;lt;u,u.π&amp;gt;加入到集合A中。8~11行的for循环将每个与u邻接但是不在树中的结点v的key和π属性进行更新，从而维持循环不变式。&lt;/p&gt;
&lt;p&gt;　　(3)简单看一个Prim算法的例子&lt;/p&gt;
&lt;p&gt;　　例子中，初始的根节点为a，加阴影的边和黑色结点属于树A。在算法的每一步，树中的结点就决定了图的一个切割，横跨该切割的一条轻量级边就被加入到树中。&lt;/p&gt;
&lt;p&gt;　　例如：在图(b)，轻量级边有两条，&amp;lt;b,c&amp;gt;,&amp;lt;a,h&amp;gt;的权重都为8，所以可以选择两条边中的一条加入到树中&lt;/p&gt;
&lt;p&gt;　　 &lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201901/1368768-20190103155648939-224056547.png&quot; alt=&quot;&quot; width=&quot;296&quot; height=&quot;123&quot;/&gt;　     　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201901/1368768-20190103155707097-1526409978.png&quot; alt=&quot;&quot; width=&quot;305&quot; height=&quot;122&quot;/&gt;　  &lt;/p&gt;
&lt;p&gt;　　 &lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201901/1368768-20190103155726918-1490970405.png&quot; alt=&quot;&quot; width=&quot;308&quot; height=&quot;114&quot;/&gt;　　   &lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201901/1368768-20190103155756829-652188952.png&quot; alt=&quot;&quot; width=&quot;321&quot; height=&quot;125&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　 &lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201901/1368768-20190103155814006-281716340.png&quot; alt=&quot;&quot; width=&quot;308&quot; height=&quot;118&quot;/&gt;　     　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201901/1368768-20190103160916320-577260934.png&quot; alt=&quot;&quot; width=&quot;319&quot; height=&quot;120&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　  &lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201901/1368768-20190103160939642-258718486.png&quot; alt=&quot;&quot; width=&quot;311&quot; height=&quot;121&quot;/&gt; 　   　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201901/1368768-20190103161001601-1726106858.png&quot; alt=&quot;&quot; width=&quot;308&quot; height=&quot;125&quot;/&gt;　  &lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201901/1368768-20190103161029202-1430189063.png&quot; alt=&quot;&quot; width=&quot;321&quot; height=&quot;136&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 06 Feb 2019 10:28:00 +0000</pubDate>
<dc:creator>风沙迷了眼</dc:creator>
<og:description>最小生成树的形成 (1)一个贪心策略设计如下 每个时刻生长最小生成树的一条边，并在整个策略的实施过程中，遵守下述循环不变式的边集合A： 每一步，选择一条边(u,v)加入集合A，使得A不违反循环不变式。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fsmly/p/10215179.html</dc:identifier>
</item>
<item>
<title>（原创）像极了爱情的详解排序二叉树，一秒get - compassion‘s</title>
<link>http://www.cnblogs.com/yx1999/p/10352828.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yx1999/p/10352828.html</guid>
<description>&lt;p&gt;&lt;span&gt;二叉树我们已经非常熟悉了，但是除了寻常的储存数据、遍历结构，我们还能用二叉树做什么呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们都知道不同的遍历方式会对相同的树中产生不同的序列结果，排序二叉树就是利用二叉树的遍历特征实现的特殊树种，也叫二叉查找树。&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;排序二叉树从根结点起的每一个结点的左子树元素均小于其自身，右子树元素值均大于其自身&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;即任何结点的值均大于其左子树所有元素，均小于其右子树所有元素&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1598426/201902/1598426-20190205143804959-1841428011.png&quot; alt=&quot;&quot; width=&quot;359&quot; height=&quot;297&quot;/&gt;&lt;span&gt;就是一个排序二叉树，直观的一批，从子树到根结点，永远符合左小右大的规则（中序遍历）&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;Ⅰ、结构定义&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;排序二叉树的定义与一般二叉树无异&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
typedef &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; BiTree{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; item;
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; BiTree *lchild,*&lt;span&gt;rchild;
}BiTree;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;Ⅱ、排序二叉树的查找&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;我们先来看一下排序二叉树的查找实现，因为插入在排序二叉树中是实现后续建立、删除结点的基础，因为结点带有顺序，故而遍历条件有所改变，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; searchnode(BiTree *t, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; key)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;t)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(t-&amp;gt;item ==&lt;span&gt; key)
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(t-&amp;gt;item &amp;gt;&lt;span&gt; key)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; searchnode(t-&amp;gt;&lt;span&gt;lchild,key);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(t-&amp;gt;item &amp;lt;&lt;span&gt; key)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; searchnode(t-&amp;gt;&lt;span&gt;rchild,key);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;清爽递归，不解释&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;Ⅲ、二叉排序树的插入&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; insertbitree(BiTree **t, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; value)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!searchnode(*&lt;span&gt;t,value))
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(*t ==&lt;span&gt; NULL)
        {
            &lt;/span&gt;*t = (BiTree *)&lt;span&gt;malloc&lt;/span&gt;(&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(BiTree));
            (&lt;/span&gt;*t)-&amp;gt;item =&lt;span&gt; value;
            (&lt;/span&gt;*t)-&amp;gt;lchild =&lt;span&gt; NULL;
            (&lt;/span&gt;*t)-&amp;gt;rchild =&lt;span&gt; NULL;
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;((*t)-&amp;gt;item &amp;gt;&lt;span&gt; value)
                insertbitree(&lt;/span&gt;&amp;amp;((*t)-&amp;gt;&lt;span&gt;lchild), value);
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                insertbitree(&lt;/span&gt;&amp;amp;((*t)-&amp;gt;&lt;span&gt;rchild), value);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这个插入上来先判断一哈我们现有的树里面有没有这个元素，如果有就不会进入循环，至于插入操作的框架也基本符合中序遍历的操作，只是加上了判断大小&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;Ⅳ、二叉排序树删除结点（HARD）&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;轻松愉快的建立、查找排序二叉树的操作完成之后，我们来看看比较困难的删除排序二叉树结点的操作。为什么说它困难呢，相比插入或者查找，删除面对的是一个已经成型的树，我们不仅要考虑怎样去掉这个结点，还要想到按照中序以及数字大小将原有结点按序放到正确位置。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;好的，我们先来考虑一下我们可能删除哪几种结点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一类：待删除结点只有左子树，没有右子树，可以想见，这种情况下只需要把后续的左子树接到待删除结点的上一个结点上，再释放待删除结点的空间就OK&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第二类：带删除结点只有右子树，没有左子树，跟第一类一个道理，这样的操作只需要三行就解决，但是棘手的问题总在短暂的轻松过后&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第三类：这一类情况就是大魔王辽，左右孩子一个不缺，手心手背都是肉，哪个也不能少，怎么解决这个问题呢？让我们来看一个例子。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1598426/201902/1598426-20190206153735905-1491752970.png&quot; alt=&quot;&quot;/&gt;&lt;span&gt;看这个丑不拉叽的排序二叉树，非常体现中序遍历特点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在我们要删除 34 这个结点，就是我们刚才说的那种第三类情况，左右均有结点，这个时候，我们有这两种方法阔以达成目的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1598426/201902/1598426-20190206154000732-124477.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一种：姑且叫他 牺牲前驱法 ，我们要去掉 34 ，就要把他的前驱拿来顶替这个位置，保持二叉排序树的序，然后当然要检测一下，如果牺牲的这个前驱点（在我们这里是 33 ）有子树，还需要把子树和上一级连上（如32），这是第一种方法&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;用直接前驱 33 替换 34 &lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;删除原有的 33 结点&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;把结点 32 ，移到原 33 位置&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;第二种：相信你也猜到了，牺牲后继法，反正兄弟两个要挑一个顶上去，让我们看一哈在这个例子中，怎么个牺牲后继&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1598426/201902/1598426-20190206154708352-1959386085.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; 35 已经被我们放上来辽 &lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;用直接后继 35 替换 34&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;删除结点 35 &lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;因为这里的 35 茕茕孑立，没儿没女，所以这个例子的这里不需要连接子树，但是千万注意不要认为所有的替换后继法都不用管子树&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;好的，方法讲明白了辽，我们代码实现一哈&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; Delete(BiTree **&lt;span&gt;t)
{
    BiTree &lt;/span&gt;*s,*&lt;span&gt;q;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;((*t) -&amp;gt; lchild ==&lt;span&gt; NULL)//左子树空的情况
    {
        q &lt;/span&gt;= *&lt;span&gt;t;
        &lt;/span&gt;*t = (*t)-&amp;gt;&lt;span&gt;lchild;
        &lt;/span&gt;&lt;span&gt;free&lt;/span&gt;&lt;span&gt;(q);
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;( (*t) -&amp;gt; rchild ==&lt;span&gt; NULL)//右子树为空的情况
    {
        q &lt;/span&gt;= *&lt;span&gt;t;
        &lt;/span&gt;*t = (*t)-&amp;gt;&lt;span&gt;rchild;
        &lt;/span&gt;&lt;span&gt;free&lt;/span&gt;&lt;span&gt;(q);
    }
    &lt;/span&gt;&lt;span&gt;else //左右子数均为空&lt;/span&gt;&lt;span&gt;
    {
        q &lt;/span&gt;= *&lt;span&gt;t;
        s &lt;/span&gt;= (*t)-&amp;gt;&lt;span&gt;lchild;
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(s-&amp;gt;&lt;span&gt;rchild)//循环找到直接前驱
        {
            q &lt;/span&gt;=&lt;span&gt; s;
            s &lt;/span&gt;= s-&amp;gt;&lt;span&gt;rchild;
        }
        (&lt;/span&gt;*t) -&amp;gt; item = s -&amp;gt;&lt;span&gt; item; //结点数据替换
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(q != *&lt;span&gt;t) //接原有左右子树
            q&lt;/span&gt;-&amp;gt;rchild = s-&amp;gt;&lt;span&gt;lchild;
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            q&lt;/span&gt;-&amp;gt;lchild = s-&amp;gt;&lt;span&gt;lchild;
        &lt;/span&gt;&lt;span&gt;free&lt;/span&gt;&lt;span&gt;(s);
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
}
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; DeleteBST(BiTree **T, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; key)
{

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!*&lt;span&gt;T)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (key ==  (*T)-&amp;gt;&lt;span&gt;item)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Delete(T);
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (key &amp;lt; (*T)-&amp;gt;&lt;span&gt;item)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; DeleteBST(&amp;amp;(*T)-&amp;gt;&lt;span&gt;lchild, key);
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; DeleteBST(&amp;amp;(*T)-&amp;gt;&lt;span&gt;rchild, key);
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;解读见注释&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;测试用主函数部分：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i;
    BiTree &lt;/span&gt;*t =&lt;span&gt; NULL;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; value[] = {&lt;span&gt;12&lt;/span&gt;,&lt;span&gt;24&lt;/span&gt;,&lt;span&gt;88&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;64&lt;/span&gt;,&lt;span&gt;99&lt;/span&gt;,&lt;span&gt;71&lt;/span&gt;,&lt;span&gt;64&lt;/span&gt;,&lt;span&gt;10&lt;/span&gt;,&lt;span&gt;8&lt;/span&gt;&lt;span&gt;};
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;10&lt;/span&gt;; i++&lt;span&gt;)
        insertbitree(&lt;/span&gt;&amp;amp;&lt;span&gt;t,value[i]);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;建立序列为：\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    lar(t);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;删除结点88，结果为：\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    DeleteBST(&lt;/span&gt;&amp;amp;t,&lt;span&gt;88&lt;/span&gt;&lt;span&gt;);
    lar(t);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1598426/201902/1598426-20190206170505167-1869048482.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


</description>
<pubDate>Wed, 06 Feb 2019 09:08:00 +0000</pubDate>
<dc:creator>compassion‘s</dc:creator>
<og:description>数据结构 查找二叉树 排序二叉树</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yx1999/p/10352828.html</dc:identifier>
</item>
</channel>
</rss>