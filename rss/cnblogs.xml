<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>【NET CORE微服务一条龙应用】第二章 配置中心使用 - 天翔者</title>
<link>http://www.cnblogs.com/tianxiangzhe/p/10342428.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tianxiangzhe/p/10342428.html</guid>
<description>&lt;p&gt;系列目录：&lt;a href=&quot;https://www.cnblogs.com/tianxiangzhe/p/10212337.html&quot; target=&quot;_blank&quot;&gt;【NET CORE微服务一条龙应用】开始篇与目录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在分布式或者微服务系统里，通过配置文件来管理配置内容，是一件比较令人痛苦的事情，再谨慎也有湿鞋的时候，这就是在项目架构发展的过程中，配置中心存在的意义。&lt;/p&gt;
&lt;p&gt;其实配置中心的组件已经有非常出名的案例，比如携程的阿波罗配置中心（&lt;a href=&quot;https://github.com/ctripcorp/apollo&quot; target=&quot;_blank&quot;&gt;https://github.com/ctripcorp/apollo&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;为什么又造轮子，因为不想发布项目的时候到处切管理平台。&lt;/p&gt;

&lt;p&gt;作为一个通用的配置组件，需要支持如下功能：&lt;/p&gt;
&lt;p&gt;1、客户端定时刷新获信最新配置信息并进行热更新&lt;/p&gt;
&lt;p&gt;2、配置有更新服务端主动推送重载或更新命令至客户端进行配置获取&lt;/p&gt;
&lt;p&gt;所以涉及相对应组件如下：&lt;/p&gt;
&lt;p&gt;1、支持广播的消息通知组件，目前使用redis(&lt;span class=&quot;pl-en&quot;&gt;StackExchange.&lt;span class=&quot;pl-en&quot;&gt;Redis&lt;/span&gt;&lt;/span&gt;)、Zookeeper(&lt;span class=&quot;pl-en&quot;&gt;Rabbit.&lt;span class=&quot;pl-en&quot;&gt;Zookeeper&lt;/span&gt;&lt;/span&gt;)实现客户端全局监听服务，服务端可以推送不同组建不同的命令&lt;/p&gt;
&lt;p&gt;2、支持定时获取最新配置，目前使用HostedService实现全局统一启动，客户端实现全局启动接口，接口使用Timer进行定时获取配置&lt;/p&gt;
&lt;p&gt;3、支持net core原生IConfiguration接口获取配置中心数据&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/627749/201902/627749-20190203142237176-1915223994.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;管理服务端主要实现：&lt;/p&gt;
&lt;p&gt;1、三表增删改查&lt;/p&gt;
&lt;p&gt;2、配置内容表，每次新增或者修改，当前配置信息版本号为，所以配置最大版本号然后加一&lt;/p&gt;
&lt;p&gt;3、应用表列表增加主动通知功能&lt;/p&gt;

&lt;p&gt;主要提供配置信息的查询接口&lt;/p&gt;
&lt;p&gt;1、接口入参如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; QueryConfigInput
    {
        [NotEmpty(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;config_001&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AppId不能为空&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; AppId { &lt;span&gt;set&lt;/span&gt;; &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; Version { &lt;span&gt;set&lt;/span&gt;; &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
        [NotEmpty(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;config_002&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;签名不能为空&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Sign { &lt;span&gt;set&lt;/span&gt;; &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
        [NotEmpty(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;config_005&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;NamespaceName不能为空&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; NamespaceName { &lt;span&gt;set&lt;/span&gt;; &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Env { &lt;span&gt;set&lt;/span&gt;; &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、查询逻辑&lt;/p&gt;
&lt;p&gt;   2.1 入参基本验证&lt;/p&gt;
&lt;p&gt;   2.2 AppId 密钥进行签名验证&lt;/p&gt;
&lt;p&gt;   2.3 请求配置环境定位&lt;/p&gt;
&lt;p&gt;   2.4 查询当前请求应用和共有配置应用&lt;/p&gt;
&lt;p&gt;   2.5 查询大于当前查询版本号的配置信息并返回&lt;/p&gt;

&lt;h3&gt;客户端主要实现原理和功能&lt;/h3&gt;
&lt;p&gt;1、配置信息请求，当前Http请求，需根据配置信息组合请求url，然后请求获取配置，每次请求带上当前配置最大版本号(在以后请求时只获取有更新的配置）&lt;/p&gt;
&lt;p&gt;2、配置信息本地存储（容灾），第一次获取成功后，把配置信息进行版本文件存储，以后的请求中当有配置更新时再进行文件存储。&lt;/p&gt;
&lt;p&gt;3、当配置请求失败时进行本地文件配置信息的还原应用。&lt;/p&gt;
&lt;p&gt;4、配置定时获取&lt;/p&gt;
&lt;p&gt;5、客户端接收更新或者重载命令&lt;/p&gt;
&lt;p&gt;6、原生IConfiguration配置查询支持&lt;/p&gt;
&lt;h3&gt;部分功能介绍&lt;/h3&gt;
&lt;h3&gt;客户端参数&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ConfigServer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AppId&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;PinzhiGO&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AppSercet&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xxxxxxxxxxxxx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ServerUrl&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://10.10.188.136:18081/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, // 配置查询服务端地址
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;NamespaceName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Pinzhi.Identity.WebApi&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Env&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dev&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RefreshInteval&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;300&lt;/span&gt;&lt;span&gt;
  },&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;原生IConfiguration配置查询&lt;/h3&gt;
&lt;p&gt;查看AddJsonFile源码，可以发现实现自定义配置源，需要集成和实现&lt;span class=&quot;pl-en&quot;&gt;ConfigurationProvider和&lt;span class=&quot;pl-en&quot;&gt;&lt;span class=&quot;pl-en&quot;&gt;IConfigurationSource两个方法&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;pl-en&quot;&gt;&lt;span class=&quot;pl-en&quot;&gt;&lt;span class=&quot;pl-en&quot;&gt;代码如下&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BucketConfigurationProvider : ConfigurationProvider, IDataChangeListener, IConfigurationSource
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; ConfigurationHelper _configurationHelper;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; BucketConfigurationProvider(BucketConfigOptions options)
        {
            _configurationHelper &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConfigurationHelper(options);
            Data &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ConcurrentDictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;();
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Load()
        {
            DataChangeListenerDictionary.Add(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
            Data &lt;/span&gt;= _configurationHelper.Get().ConfigureAwait(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;).GetAwaiter().GetResult();
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; SetData(ConcurrentDictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; changeData)
        {
            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; dic &lt;span&gt;in&lt;/span&gt;&lt;span&gt; changeData)
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Data.ContainsKey(dic.Key))
                    Data[dic.Key] &lt;/span&gt;=&lt;span&gt; dic.Value;
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                    Data.Add(dic);
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Data = new Dictionary&amp;lt;string, string&amp;gt;(_configRepository.Data, StringComparer.OrdinalIgnoreCase);&lt;/span&gt;
&lt;span&gt;        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; OnDataChange(ConcurrentDictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; changeData)
        {
            SetData(changeData);
            OnReload();
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IConfigurationProvider Build(IConfigurationBuilder builder) =&amp;gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当有配置更新时，我们需要更新到ConfigurationProvider的Data中，所以我们需要实现自定义接口IDataChangeListener的OnDataChange方法，当客户端请求发现有配置更新时，会调用接口的OnDataChange把最新的配置信息传递进来。&lt;/p&gt;
&lt;p&gt;启用原生IConfiguration方法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
 .ConfigureAppConfiguration((hostingContext, _config) =&amp;gt;&lt;span&gt;
                   {
                       _config
                       .SetBasePath(Directory.GetCurrentDirectory())
                       .AddJsonFile(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;appsettings.json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
                       .AddJsonFile($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;appsettings.{hostingContext.HostingEnvironment.EnvironmentName}.json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
                       .AddEnvironmentVariables(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加环境变量&lt;/span&gt;
                       &lt;span&gt;var&lt;/span&gt; option = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BucketConfigOptions();
                       _config.Build().GetSection(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ConfigServer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).Bind(option);
                       _config.AddBucketConfig(option);
                   })&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;定时配置获取&lt;/h3&gt;
&lt;p&gt;常规做法是写一个hostedservice的方法，然后写一个timer去定时获取，由于其他的组件可能都需要有定时的情况，我们统一处理了一下定时的任务，每个组件实现IExecutionService接口，然后组件会在启动的时候循环调用IExecutionService的StartAsync的方法，组件包Bucket.Config.HostedService，原理比较简单，使用代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加全局定时任务&lt;/span&gt;
            services.AddBucketHostedService(builder =&amp;gt;&lt;span&gt; {
                builder.AddAuthorize().AddConfig().AddErrorCode();
            });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AspNetCoreHostedService : IBucketAgentStartup
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; IEnumerable&amp;lt;IExecutionService&amp;gt;&lt;span&gt; _services;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; AspNetCoreHostedService(IEnumerable&amp;lt;IExecutionService&amp;gt;&lt;span&gt; services)
        {
            _services &lt;/span&gt;=&lt;span&gt; services;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task StartAsync(CancellationToken cancellationToken = &lt;span&gt;default&lt;/span&gt;&lt;span&gt;(CancellationToken))
        {
            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; service &lt;span&gt;in&lt;/span&gt;&lt;span&gt; _services)
                &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; service.StartAsync(cancellationToken);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task StopAsync(CancellationToken cancellationToken = &lt;span&gt;default&lt;/span&gt;&lt;span&gt;(CancellationToken))
        {
            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; service &lt;span&gt;in&lt;/span&gt;&lt;span&gt; _services)
                &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; service.StopAsync(cancellationToken);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;组件命令监听&lt;/h3&gt;
&lt;p&gt;和上面原则一样，也进行了统一的封装，目前监听主要实现了redis和zookeeper，下面举例redis&lt;/p&gt;
&lt;p&gt;组件监听需实现接口&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IBucketListener
    {
        &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; ListenerName { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
        Task ExecuteAsync(&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt; commandText);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;命令序列化实体&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; NetworkCommand
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; NotifyComponent { &lt;span&gt;set&lt;/span&gt;; &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; CommandText { &lt;span&gt;set&lt;/span&gt;; &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; NetworkCommandType
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 更新
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;        Refresh,
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 重载
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;        Reload,
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在hostedservice启动时实现&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; Task StartAsync(CancellationToken cancellationToken = &lt;span&gt;default&lt;/span&gt;&lt;span&gt;(CancellationToken))
        {
            _subscriber &lt;/span&gt;=&lt;span&gt; _redisClient.GetSubscriber(_redisListenerOptions.ConnectionString);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; _subscriber.SubscribeAsync(RedisListenerKey, (channel, message) =&amp;gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; command = JsonConvert.DeserializeObject&amp;lt;Bucket.Values.NetworkCommand&amp;gt;&lt;span&gt;(message);
                _extractCommand.ExtractCommandMessage(command);
            });
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在接口IExtractCommand里会根据各个监听组件的&lt;span class=&quot;pl-smi&quot;&gt;ListenerName进行对应的调用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;pl-smi&quot;&gt;使用方法如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加应用监听&lt;/span&gt;
            services.AddListener(builder =&amp;gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;builder.UseRedis();&lt;/span&gt;
&lt;span&gt;                builder.UseZookeeper();
                builder.AddAuthorize().AddConfig().AddErrorCode();
            });&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所以对应组件实现的命令监听只要关心自身逻辑即可吗，代码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BucketConfigListener : IBucketListener
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; ListenerName =&amp;gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Bucket.Config&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; IDataRepository _dataRepository;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; BucketConfigListener(IDataRepository dataRepository)
        {
            _dataRepository &lt;/span&gt;=&lt;span&gt; dataRepository;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task ExecuteAsync(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; commandText)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;string&lt;/span&gt;.IsNullOrWhiteSpace(commandText) &amp;amp;&amp;amp; commandText ==&lt;span&gt; NetworkCommandType.Refresh.ToString())
                &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; _dataRepository.Get();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;string&lt;/span&gt;.IsNullOrWhiteSpace(commandText) &amp;amp;&amp;amp; commandText ==&lt;span&gt; NetworkCommandType.Reload.ToString())
                &lt;/span&gt;&lt;span&gt;await&lt;/span&gt; _dataRepository.Get(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;配置中心使用配置如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
 .ConfigureAppConfiguration((hostingContext, _config) =&amp;gt;&lt;span&gt;
                   {
                       _config
                       .SetBasePath(Directory.GetCurrentDirectory())
                       .AddJsonFile(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;appsettings.json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
                       .AddJsonFile($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;appsettings.{hostingContext.HostingEnvironment.EnvironmentName}.json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
                       .AddEnvironmentVariables(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加环境变量&lt;/span&gt;
                       &lt;span&gt;var&lt;/span&gt; option = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BucketConfigOptions();
                       _config.Build().GetSection(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ConfigServer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).Bind(option);
                       _config.AddBucketConfig(option);
                   })

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ConfigureServices 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加配置服务&lt;/span&gt;
&lt;span&gt;            services.AddConfigServer(Configuration);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加应用监听&lt;/span&gt;
            services.AddListener(builder =&amp;gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;builder.UseRedis();&lt;/span&gt;
&lt;span&gt;                builder.UseZookeeper();
                builder.AddAuthorize().AddConfig().AddErrorCode();
            });
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加全局定时任务&lt;/span&gt;
            services.AddBucketHostedService(builder =&amp;gt;&lt;span&gt; {
                builder.AddAuthorize().AddConfig().AddErrorCode();
            });

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; IConfiguration _configuration;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; IConfig _config;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; AuthController(IConfiguration configuration, IConfig config)
        {
            _configuration&lt;/span&gt;=&lt;span&gt; configuration;
            _config&lt;/span&gt;=&lt;span&gt; config;
        }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取值&lt;/span&gt;
_configuration.GetValue&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;qqqq&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
_config.StringGet(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;qqqq&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Appsettings.json相关配置信息转移至配置中心&lt;/h3&gt;
&lt;p&gt;由于配置中心客户端实现了原生的IConfiguration，所以appsetting的相关配置我们完全可以移至配置中心中，由于appsetting使用的是json，所以在配置中心服务端配置信息的Key需要转换，举例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BucketListener&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Redis&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ConnectionString&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;127.0.0.1:6379,allowadmin=true&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ListenerKey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Bucket.Sample&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    },
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Zookeeper&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ConnectionString&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;localhost:2181&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ListenerKey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Bucket.Sample&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    }
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在配置中心key如下：&lt;/p&gt;
&lt;p&gt;BucketListener:Redis:ConnectionString&lt;/p&gt;
&lt;p&gt;BucketListener:Redis:ListenerKey&lt;/p&gt;
&lt;p&gt;......&lt;/p&gt;
&lt;p&gt;数组使用如下：&lt;/p&gt;
&lt;p&gt;DbConfig:0:Name&lt;/p&gt;
&lt;p&gt;DbConfig:0:DbType&lt;/p&gt;
&lt;p&gt;DbConfig:1:Name&lt;/p&gt;
&lt;p&gt;DbConfig:1:DbType&lt;/p&gt;

&lt;p&gt;个人写作水平有限，涉及的东西也很多，篇幅有限所以只做了大体介绍，忘谅解&lt;/p&gt;
&lt;p&gt;本章涉及源码&lt;br/&gt;&lt;a href=&quot;https://github.com/q315523275/FamilyBucket/tree/master/src/Config&quot; target=&quot;_blank&quot;&gt;https://github.com/q315523275/FamilyBucket/tree/master/src/Config&lt;/a&gt; 客户端组件&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/q315523275/FamilyBucket/tree/master/%E5%9F%BA%E7%A1%80%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE/Pinzhi.ConfigServer&quot; target=&quot;_blank&quot;&gt;https://github.com/q315523275/FamilyBucket/tree/master/%E5%9F%BA%E7%A1%80%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE/Pinzhi.ConfigServer&lt;/a&gt; 配置查询服务端&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/q315523275/FamilyBucket/tree/master/%E5%9F%BA%E7%A1%80%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE/Pinzhi.Platform&quot; target=&quot;_blank&quot;&gt;https://github.com/q315523275/FamilyBucket/tree/master/%E5%9F%BA%E7%A1%80%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE/Pinzhi.Platform&lt;/a&gt; 综合管理服务接口&lt;/p&gt;
</description>
<pubDate>Sun, 03 Feb 2019 07:42:00 +0000</pubDate>
<dc:creator>天翔者</dc:creator>
<og:description>背景 系列目录：【NET CORE微服务一条龙应用】开始篇与目录 在分布式或者微服务系统里，通过配置文件来管理配置内容，是一件比较令人痛苦的事情，再谨慎也有湿鞋的时候，这就是在项目架构发展的过程中，配</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tianxiangzhe/p/10342428.html</dc:identifier>
</item>
<item>
<title>设计模式之工厂模式 - 艾心❤</title>
<link>http://www.cnblogs.com/edison0621/p/10350469.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/edison0621/p/10350469.html</guid>
<description>&lt;p&gt;定义一个创建对象的接口，但让这个接口的实现类来决定实例化哪个类。工厂方法让类的实例化推迟到子类中进行。也就是说，工厂方法模式会定义一个单独的方法去创建或者管理对象。&lt;/p&gt;
&lt;div class=&quot;account_right_info&quot; readability=&quot;44.5&quot;&gt;
&lt;p&gt;&lt;em&gt;考虑到创建对象的功能粒度，比较好的方式是未每一个具体目标对象设置一个单独的工厂实现类以及对象创建方法。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/533598/201902/533598-20190203151855105-1152530886.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;只去看定义，可能学术化太强，不足以形成一种比较形象的思维。让我们来做一个这样的思考：&lt;/p&gt;
&lt;p&gt;首先，接口更多的是强调行为，我们是赋予这个接口创建对象的职责。这个时候，大家暂时不用去考虑具体实现的事情，把关注点放在创建对象这一抽象概念上，具体开发上就是关注当前的接口。&lt;/p&gt;
&lt;p&gt;同时，我们采用面向对象的设计原则，尽量做到接口设计的职责单一。如果在具体的设计上涉及多个场景，可以考虑抽象工厂，这个会在以后的篇幅里回顾。&lt;/p&gt;
&lt;p&gt;综上所述，工厂方法模式，有着很多优势：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;最大的优势莫过于，它体现着面向对象的开闭原则：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　　　我们为什么要对每个对象都设计一个工厂接口，就是因为我们不希望因为未来不缺性的需求而影响现有功能，所以我们需要开放出一个口子，既能保持现有设计，又能不断的扩展新功能，也是就是动态扩展。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;其次，采用较细的粒度设计，也稳定了当前的设计，减少了未来的影响，这是单一职责的好处。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当然，工厂模式也有着很明显的缺陷：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先类的个数成倍数级增加&lt;/li&gt;
&lt;li&gt;同时引入的抽象层或者说是抽象概念，也在一定程度上增加了系统理解的难度，根据实现方式的需要也有可能会增加系统额外的开发，因为有些功能的实现方式还会考虑反射等&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;&lt;li&gt;当一个类不需要依赖其他类而只需要依赖其接口的时候，可以考虑工厂模式&lt;/li&gt;
&lt;li&gt;为了使系统更好的适应未来不缺性的需要，可以考虑功能扩展，这一点可以看看.NET Core关于Configuration功能的源码&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最后我们看看demo吧，这是一个非常简单的demo，正常来说，工厂模式涵盖的内容很多，思维不要太过局限于demo，更多还应该考虑每个工厂可能还有自己特殊的地方，毕竟已经设计了单独的工厂类了。&lt;/p&gt;
&lt;p&gt;以下demo的场景是想找到一个厨师去做饭，厨师角色暂时按照男女厨师来区分。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IFactory
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    ICook GetCooker();
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ManFactory : IFactory
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ICook GetCooker()
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IManCook();
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WomanFactory : IFactory
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ICook GetCooker()
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IWomanCook();
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; ICook
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; DoMeal();
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; IManCook : ICook
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; DoMeal()
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;男厨师做饭&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; IWomanCook : ICook
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; DoMeal()
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;女厨师做饭&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;找男厨师做饭&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         IFactory manFactory = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ManFactory();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         ICook manCook =&lt;span&gt; manFactory.GetCooker();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        manCook.DoMeal();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;找女厨师做饭&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         IFactory womanFactory = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ManFactory();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         ICook womanCook =&lt;span&gt; womanFactory.GetCooker();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        womanCook.DoMeal();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
</description>
<pubDate>Sun, 03 Feb 2019 07:35:00 +0000</pubDate>
<dc:creator>艾心❤</dc:creator>
<og:description>定义： 定义一个创建对象的接口，但让这个接口的实现类来决定实例化哪个类。工厂方法让类的实例化推迟到子类中进行。也就是说，工厂方法模式会定义一个单独的方法去创建或者管理对象。 考虑到创建对象的功能粒度，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/edison0621/p/10350469.html</dc:identifier>
</item>
<item>
<title>我的世界 ParaCraft 结合开源地图 OpenStreetMap 生成3D校园的方法简介 - 快手软件-TimeGIS-com</title>
<link>http://www.cnblogs.com/kuaishou/p/paracraft.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kuaishou/p/paracraft.html</guid>
<description>&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;我的世界&lt;/span&gt;&lt;/strong&gt;&lt;span class=&quot;SpellE&quot;&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;ParaCraft&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;结合开源地图&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;OpenStreetMap&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;生成&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;3D&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;校园的方法简介&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span&gt;版本&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;1.0&lt;/span&gt; &lt;span&gt;日期&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;2019.2.3&lt;/span&gt; &lt;span&gt;作者&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Ray (82735589@qq.com) &lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;a href=&quot;http://www.TimeGIS.com&quot;&gt;&lt;span&gt;www.TimeGIS.com&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;0.&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt; &lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;strong&gt;&lt;span&gt;目标&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;http://www.paracraft.cn&quot;&gt;&lt;span&gt;Paracraft&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;是&lt;/span&gt;&lt;span class=&quot;SpellE&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;LiXiZhi&lt;/span&gt;&lt;/span&gt;&lt;span&gt;开发的一种类似我的世界&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Minecraft&lt;/span&gt; &lt;span&gt;的&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;3D&lt;/span&gt;&lt;span&gt;编辑软件&lt;/span&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;https://github.com/LiXizhi&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;作者开发了他的源码&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;，可以在&lt;/span&gt;&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;https://github.com/LiXizhi&lt;/span&gt;&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;找到更多信息&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;本文介绍使用&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;NPL&lt;/span&gt;&lt;span&gt;语言（一种类似&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;LUA&lt;/span&gt;&lt;span&gt;的语言）开发&lt;/span&gt;&lt;span class=&quot;SpellE&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;Paracraft&lt;/span&gt;&lt;/span&gt;&lt;span&gt;的一个&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Mod&lt;/span&gt;&lt;span&gt;插件&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;·&lt;span&gt;        &lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;从网页地图选择一个经纬度，将周围的免费&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;GIS&lt;/span&gt;&lt;span&gt;地理信息导入到&lt;/span&gt;&lt;span class=&quot;SpellE&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;Paracraft&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;: Raster + Vector --&amp;gt; blocks&lt;/span&gt;&lt;span&gt;。&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;1&lt;/span&gt;&lt;span&gt;米&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;=1Block&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;·&lt;span&gt;        &lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;参考&lt;/span&gt;&lt;span class=&quot;apple-converted-space&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;http://www.geoboxers.com/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;http://www.geoboxers.com/&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;apple-converted-space&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;高度非线性，非正南正北的建筑&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;使得&lt;/span&gt;&lt;span class=&quot;SpellE&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;Paracraft&lt;/span&gt;&lt;/span&gt;&lt;span&gt;的世界具备&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;GIS&lt;/span&gt;&lt;span&gt;信息。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;操作形式，&lt;/span&gt;&lt;span&gt;为一个新的&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Item&lt;/span&gt;&lt;span&gt;。放到世界中，则激活。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span&gt;一种可能的效果如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;        &lt;img src=&quot;http://www.timegis.com/Paracraft3D/image002.jpg&quot; alt=&quot;&quot; width=&quot;671&quot; height=&quot;186&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;http://geoboxers.com/Stavanger/StavangerOverview/index.html#stavanger_isometric_day/0/5/1057/1044/64&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;  &lt;img src=&quot;http://www.timegis.com/Paracraft3D/image003.jpg&quot; alt=&quot;&quot; width=&quot;320&quot; height=&quot;213&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;img src=&quot;http://www.timegis.com/Paracraft3D/image005.jpg&quot; alt=&quot;&quot; width=&quot;348&quot; height=&quot;212&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;1.&lt;/span&gt;&lt;/strong&gt; &lt;strong&gt;&lt;span&gt;关于&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;OpenStreetMap&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;地图&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span&gt;经过&lt;span class=&quot;GramE&quot;&gt;对谷歌地图&lt;/span&gt;，百度地图等&lt;/span&gt;&lt;span class=&quot;SpellE&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;WebMap&lt;/span&gt;&lt;/span&gt;&lt;span&gt;的研究，发现我们可以使用&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;www.OpenStreetMap.Org&lt;/span&gt;&lt;span&gt;的开源地图&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span&gt;百度百科介绍&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;OpenStreetMap&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;OpenStreetMap&lt;/span&gt;&lt;span&gt;（简称&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;OSM&lt;/span&gt;&lt;span&gt;）是一个网上地图协作计划，目标是创造一个内容自由且能让所有人编辑的世界地图。具体描述如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;http://baike.baidu.com/link?url=L4kNWqKm1i6DodEJUFm0NZezk-7uq65tQFPhqznM1o-wTqZn5-YgFqZU1DuqFUfZWYXndSXDQaHvhKNd8YpdYnkeiDjcx7HdCpB5ZdDOJTAreCJAy_rKwZniHbWxp7dDzNXMuqzk64h7UpR5DKBsF-dkHaLL32xbjswC8W7xcbO&quot;&gt;&lt;span&gt;http://baike.baidu.com/link?url=L4kNWqKm1i6DodEJUFm0NZezk-7uq65tQFPhqznM1o-wTqZn5-YgFqZU1DuqFUfZWYXndSXDQaHvhKNd8YpdYnkeiDjcx7HdCpB5ZdDOJTAreCJAy_rKwZniHbWxp7dDzNXMuqzk64h7UpR5DKBsF-dkHaLL32xbjswC8W7xcbO&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;span&gt;我们感兴趣的原因是它提供了全球的栅格地图数据和矢量地图数据两种格式，并且是免费的。&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;可以读读这里：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;http://blog.csdn.net/scy411082514/article/details/7471499&quot;&gt;&lt;span&gt;&lt;span&gt;OpenStreetMap&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;初探（一）——了解OpenStreetMap&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;http://blog.csdn.net/scy411082514/article/details/7471499&quot;&gt;&lt;span&gt;http://blog.csdn.net/scy411082514/article/details/7471499&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;        &lt;img src=&quot;http://www.timegis.com/Paracraft3D/image006.png&quot; alt=&quot;&quot; width=&quot;671&quot; height=&quot;522&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;2. GIS&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;背景知识&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;     &lt;/span&gt;&lt;/span&gt;&lt;span&gt;由于我们的需求和地图相关，所以读者可以去网上了解一些&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;GIS, &lt;span class=&quot;SpellE&quot;&gt;WebGIS&lt;/span&gt;&lt;/span&gt;&lt;span&gt;等信息。看看这篇博客：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;     &lt;/span&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/beniao/archive/2010/04/18/1714544.html&quot;&gt;&lt;span&gt;&lt;span&gt;GIS&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;理论（墨卡托投影、地理坐标系、地面分辨率、地图比例尺、&lt;/span&gt;&lt;/span&gt;&lt;span&gt;Bing Maps Tile System&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/beniao/archive/2010/04/18/1714544.html&quot;&gt;&lt;span&gt;http://www.cnblogs.com/beniao/archive/2010/04/18/1714544.html&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span&gt;因为我们这里其实是用的&lt;/span&gt;&lt;span class=&quot;SpellE&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;WebGIS&lt;/span&gt;&lt;/span&gt;&lt;span&gt;技术，所以我们需要阅读以下一系列博客：&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/naaoveGIS/category/600559.html&quot;&gt;&lt;span&gt;http://www.cnblogs.com/naaoveGIS/category/600559.html&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span&gt;尤其是其中的这三篇博客：&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/naaoveGIS/p/3898607.html&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;（二）探究本质，&lt;/span&gt;&lt;/span&gt;&lt;span&gt;WebGIS&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;前端地图显示之地图比例尺换算原理&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/naaoveGIS/p/3899821.html&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;（三）&lt;/span&gt;&lt;/span&gt;&lt;span&gt;WebGIS&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;前端地图显示之根据地理范围换算出瓦片行列号的原理&lt;/span&gt;&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;核心&lt;/span&gt;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/naaoveGIS/p/3903270.html&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;（四）&lt;/span&gt;&lt;/span&gt;&lt;span&gt;WebGIS&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;中通过行列号来换算出多种瓦片的&lt;/span&gt;&lt;/span&gt;&lt;span&gt;URL&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;之离线地图&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span&gt;读到这里，对于&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;GIS&lt;/span&gt;&lt;span&gt;新手来说，应该是比较累了，但是还要继续，下面这篇很重要：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;国内主要地图瓦片坐标系定义及计算原理&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;http://www.jianshu.com/p/0b292688b6af&quot;&gt;&lt;span&gt;http://www.jianshu.com/p/0b292688b6af&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;3.&lt;/span&gt;&lt;/strong&gt; &lt;strong&gt;&lt;span&gt;关于栅格地图在&lt;/span&gt;&lt;/strong&gt;&lt;span class=&quot;SpellE&quot;&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;Paracraft&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;上的显示&lt;/span&gt;&lt;/strong&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span&gt;通过前面的学习，我们知道栅格地图（或者瓦片地图）&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;URL&lt;/span&gt;&lt;span&gt;的规则是这样的：&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;格式：&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;http://[url]http/tile.openstreetmap.org&quot;&gt;&lt;span&gt;[Url]http://tile.openstreetmap.org&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;/{ZOOMLEVEL}/{ROW}/{COL}.png[/Url]&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Tiles are rectangular slabs of ceramic affixed in a grid arrangement to your bathroom wall! But here we're much more likely to be talking about map tiles: square bitmap graphics displayed in a grid arrangement to show a map. We may also be talking about tiled map data (described below)&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;&lt;span&gt;网上有的翻译为瓦片，个人理解为地图切片。简单的说，就是把一张大大的地图，分割成许多小正方形（如下）。这样在加载地图的时候，只需要把区域内相关的小正方形加载出来就可以了。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;        &lt;img src=&quot;http://www.timegis.com/Paracraft3D/image007.png&quot; alt=&quot;42.png&quot; width=&quot;256&quot; height=&quot;256&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;http://tile.openstreetmap.org/7/63/42.png&quot;&gt;&lt;span&gt;http://tile.openstreetmap.org/7/63/42.png&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;如上图，&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Map tiles&lt;/span&gt; &lt;span&gt;通常是&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;256 x 256&lt;/span&gt; &lt;span&gt;像素的，虽然这不是一定的，但由于&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Google Map&lt;/span&gt;&lt;span&gt;的影响，这其实已成为实际的标准。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;现在我们假设用户输入一个经纬度地址&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;(longitude, Latitude)&lt;/span&gt; &lt;span&gt;，我们&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;要获取一个&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Tile:&lt;/span&gt; &lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;http://tile.openstreetmap.org/7/63/42.png&quot;&gt;&lt;span&gt;http://tile.openstreetmap.org/7/63/42.png&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;相应的&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;LUA&lt;/span&gt;&lt;span&gt;语句：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;local &lt;span class=&quot;SpellE&quot;&gt;img&lt;/span&gt; = &quot;http://tile.openstreetmap.org/7/66/42.png&quot;;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;SpellE&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;NPL.SyncFile&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;(&lt;span class=&quot;SpellE&quot;&gt;img&lt;/span&gt;, &quot;42.png&quot;, &quot;&lt;span class=&quot;SpellE&quot;&gt;&lt;span class=&quot;GramE&quot;&gt;DownloadCallback&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;GramE&quot;&gt;(&lt;/span&gt;)&quot;, &quot;open1&quot;);&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;据说可以用&lt;/span&gt;&lt;span class=&quot;SpellE&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;System.os.GetUrl&lt;/span&gt;&lt;/span&gt;&lt;span&gt;（）函数异步获取&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;PNG&lt;/span&gt;&lt;span&gt;栅格图像。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;然后我们可以通过调用&lt;/span&gt;&lt;span class=&quot;SpellE&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;paracraft&lt;/span&gt;&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span class=&quot;SpellE&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;blockimage&lt;/span&gt;&lt;/span&gt;&lt;span&gt;命令把地图显示出来：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;NPL.load(&quot;(gl)script/apps/Aries/Creator/Game/Commands/CommandManager.lua&quot;);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;local &lt;span class=&quot;SpellE&quot;&gt;CommandManager&lt;/span&gt; = &lt;span class=&quot;SpellE&quot;&gt;&lt;span class=&quot;GramE&quot;&gt;commonlib.gettable&lt;/span&gt;&lt;/span&gt;(&quot;&lt;span class=&quot;SpellE&quot;&gt;MyCompany.Aries.Game.CommandManager&lt;/span&gt;&quot;);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;SpellE&quot;&gt;&lt;span class=&quot;GramE&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;CommandManager:RunCommand&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;(&quot;/home&quot;);&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;SpellE&quot;&gt;&lt;span class=&quot;GramE&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;CommandManager:RunCommand&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;(&quot;/&lt;span class=&quot;SpellE&quot;&gt;blockimage&lt;/span&gt; -&lt;span class=&quot;SpellE&quot;&gt;xz&lt;/span&gt; open.png&quot;);&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;效果可能如下：这里是垂直的，其实我们用参数&lt;/span&gt; &lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;–&lt;span class=&quot;SpellE&quot;&gt;xz&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;地图就变到了脚底水平。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;        &lt;img src=&quot;http://www.timegis.com/Paracraft3D/image009.jpg&quot; alt=&quot;&quot; width=&quot;430&quot; height=&quot;265&quot; border=&quot;0&quot;/&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;注意：前面&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;URL&lt;/span&gt;&lt;span&gt;下载下来的图是&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;8bit&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;PNG, &lt;span class=&quot;SpellE&quot;&gt;ParaEngine&lt;/span&gt;&lt;/span&gt;&lt;span&gt;目前只支持真彩色&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;PNG,&lt;/span&gt;&lt;span&gt;所以需要改一下，&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;或者用小画家&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Pbrush.exe&lt;/span&gt;&lt;span&gt;工具重新存盘临时过渡一下。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;4.&lt;/span&gt;&lt;/strong&gt; &lt;strong&gt;&lt;span&gt;瓦片地图的坐标计算&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;      &lt;/span&gt;&lt;/span&gt; &lt;span&gt;瓦片地图包含经纬度坐标信息，所以我们需要将地图的位置换算一下&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span&gt;阅读前面的博客：&lt;/span&gt;&lt;strong&gt;&lt;span&gt;国内主要地图瓦片坐标系定义及计算原理&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;或者这里更详细：&lt;/span&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;http://wiki.openstreetmap.org/wiki/Slippy_map_tilenames&quot;&gt;&lt;span&gt;http://wiki.openstreetmap.org/wiki/Slippy_map_tilenames&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;假设我们要贴一个&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;256*256&lt;/span&gt;&lt;span&gt;的单个&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;PNG&lt;/span&gt;&lt;span&gt;地图切片到&lt;/span&gt;&lt;span class=&quot;SpellE&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;Paracraft&lt;/span&gt;&lt;/span&gt;&lt;span&gt;上，&lt;/span&gt;&lt;span&gt;因为我们有了用户输入的经纬度，&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;可以通过下面的公式求得瓦片坐标&lt;/span&gt;&lt;span class=&quot;SpellE&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;tileX&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;, &lt;span class=&quot;SpellE&quot;&gt;tileY&lt;/span&gt;,&lt;/span&gt; &lt;span&gt;这里&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;URL&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span class=&quot;SpellE&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;ZoomLevel&lt;/span&gt;&lt;/span&gt;&lt;span&gt;我们可以&lt;span class=&quot;GramE&quot;&gt;取那个&lt;/span&gt;最大值&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;19&lt;/span&gt;&lt;span&gt;，然后拼出整个&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;URL&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;(&lt;/span&gt;&lt;span&gt;格式：&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;http://[url]http/tile.openstreetmap.org&quot;&gt;&lt;span&gt;[Url]http://tile.openstreetmap.org&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;/{ZOOMLEVEL}/{ROW}/{COL}.png[/Url])&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;然后我们利用下面的公式求得这个&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;PNG&lt;/span&gt;&lt;span&gt;的左下角和右上角的经纬度坐标，&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;256*256&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;PNG&lt;/span&gt;&lt;span&gt;对应&lt;/span&gt;&lt;span class=&quot;SpellE&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;Paracraft&lt;/span&gt;&lt;/span&gt;&lt;span&gt;估计是&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;256×256&lt;/span&gt;&lt;span&gt;个格子&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;并且可以得知用户的当前站立坐标对应到&lt;/span&gt;&lt;span class=&quot;SpellE&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;Paracraft&lt;/span&gt;&lt;/span&gt;&lt;span&gt;格子坐标。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;img src=&quot;http://www.timegis.com/Paracraft3D/image011.jpg&quot; alt=&quot;&quot; width=&quot;671&quot; height=&quot;590&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;5.&lt;/span&gt;&lt;/strong&gt; &lt;strong&gt;&lt;span&gt;关于&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;3D&lt;/span&gt;&lt;/strong&gt; &lt;strong&gt;&lt;span&gt;校园建筑的展现。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;经过研究发现，&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;OpenStreetMap.org&lt;/span&gt;&lt;span&gt;也提供了地图的矢量格式文件，叫做&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;OSM&lt;/span&gt;&lt;span&gt;文件。它是一种&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;XML&lt;/span&gt;&lt;span&gt;文件。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;关于&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;OSM&lt;/span&gt;&lt;span&gt;文件格式介绍我们可以读以下的博客：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/LBSer/p/4451471.html&quot;&gt;&lt;span&gt;http://www.cnblogs.com/LBSer/p/4451471.html&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;http://wiki.openstreetmap.org/wiki/Elements&quot;&gt;&lt;span&gt;http://wiki.openstreetmap.org/wiki/Elements&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;并且在&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;OSM&lt;/span&gt;&lt;span&gt;文件内部，它&lt;/span&gt;&lt;strong&gt;&lt;span&gt;部分&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;提供了一些著名建筑的三维结构图。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;http://wiki.openstreetmap.org/wiki/3D&quot;&gt;&lt;span&gt;http://wiki.openstreetmap.org/wiki/3D&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;之所以做部分，因为地图的构建是很耗时间的，据说&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;OpenStreetMap&lt;/span&gt;&lt;span&gt;生成了德国全境的三维地图，&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;但是中国境内的地图就比较少了，将来有机会我们可以参与构建地图，：）&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;关于&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;OpenStreetMap&lt;/span&gt;&lt;span&gt;中&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;3D&lt;/span&gt;&lt;span&gt;的例子我们可以访问这里：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;http://wiki.openstreetmap.org/wiki/3D_development&quot;&gt;&lt;span&gt;http://wiki.openstreetmap.org/wiki/3D_development&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;利用其他软件，我从&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;OpenStreetMap&lt;/span&gt;&lt;span&gt;网站下载了浙江大学的校园地图，并利用一个插件把它的三维效果图也显示了出来，从图中我们可以惊喜地看到，校园建筑的轮廓已经有了，不过建筑的不同高度信息缺乏。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;  &lt;img src=&quot;http://www.timegis.com/Paracraft3D/image013.jpg&quot; alt=&quot;&quot; width=&quot;665&quot; height=&quot;423&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;关于&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;OSM&lt;/span&gt;&lt;span&gt;的手工获取方法可以访问&lt;/span&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;http://www.openstreetmap.org&quot;&gt;&lt;span&gt;www.openstreetmap.org&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;网站，然后&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Export&lt;/span&gt;&lt;span&gt;出一个&lt;/span&gt;&lt;span class=&quot;SpellE&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;osm&lt;/span&gt;&lt;/span&gt;&lt;span&gt;文件到本地。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里我们下载上海陆家嘴的例子来说明。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;img src=&quot;http://www.timegis.com/Paracraft3D/image015.jpg&quot; alt=&quot;&quot; width=&quot;671&quot; height=&quot;390&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;SpellE&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;lujiazui.osm&lt;/span&gt;&lt;/span&gt;&lt;span&gt;的文件内容示例如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&amp;lt;&lt;span class=&quot;SpellE&quot;&gt;osm&lt;/span&gt; version=&quot;0.6&quot; generator=&quot;&lt;span class=&quot;SpellE&quot;&gt;CGImap&lt;/span&gt; 0.5.8 (5035 thorn-02.openstreetmap.org)&quot; copyright=&quot;OpenStreetMap and contributors&quot; attribution=&quot;http://www.openstreetmap.org/copyright&quot; license=&quot;http://opendatacommons.org/licenses/&lt;span class=&quot;SpellE&quot;&gt;odbl&lt;/span&gt;/1-0/&quot;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&amp;lt;bounds &lt;span class=&quot;SpellE&quot;&gt;minlat&lt;/span&gt;=&quot;31.2312000&quot; &lt;span class=&quot;SpellE&quot;&gt;minlon&lt;/span&gt;=&quot;121.4892000&quot; &lt;span class=&quot;SpellE&quot;&gt;maxlat&lt;/span&gt;=&quot;31.2484000&quot; &lt;span class=&quot;SpellE&quot;&gt;maxlon&lt;/span&gt;=&quot;121.5136000&quot;/&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt; &lt;/span&gt;&amp;lt;node id=&quot;59608490&quot; visible=&quot;true&quot; version=&quot;3&quot; changeset=&quot;10130036&quot; timestamp=&quot;2011-12-16T10:45:50Z&quot; user=&quot;DAJIBA&quot; &lt;span class=&quot;SpellE&quot;&gt;uid&lt;/span&gt;=&quot;360397&quot; &lt;span class=&quot;SpellE&quot;&gt;lat&lt;/span&gt;=&quot;31.2321150&quot; &lt;span class=&quot;SpellE&quot;&gt;lon&lt;/span&gt;=&quot;121.4917826&quot;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt; &lt;/span&gt; &amp;lt;tag k=&quot;source&quot; v=&quot;PGS&quot;/&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt; &lt;/span&gt;&amp;lt;/node&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;。。。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&amp;lt;way id=&quot;40779113&quot; visible=&quot;true&quot; version=&quot;13&quot; changeset=&quot;43126825&quot; timestamp=&quot;2016-10-24T15:28:02Z&quot; user=&quot;lukys1&quot; &lt;span class=&quot;SpellE&quot;&gt;uid&lt;/span&gt;=&quot;514683&quot;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt; &lt;/span&gt; &amp;lt;&lt;span class=&quot;SpellE&quot;&gt;nd&lt;/span&gt; ref=&quot;495634718&quot;/&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;。。。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt; &lt;/span&gt;&amp;lt;&lt;span class=&quot;SpellE&quot;&gt;nd&lt;/span&gt; ref=&quot;495634718&quot;/&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;&amp;lt;tag k=&quot;building&quot; v=&quot;yes&quot;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt; &lt;/span&gt; &amp;lt;tag k=&quot;&lt;span class=&quot;SpellE&quot;&gt;&lt;span class=&quot;GramE&quot;&gt;building:levels&lt;/span&gt;&lt;/span&gt;&quot; v=&quot;6&quot;/&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt; &lt;/span&gt; &amp;lt;tag k=&quot;name&quot; v=&quot;&lt;/span&gt;&lt;span&gt;正大广场&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&quot;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt; &lt;/span&gt; &amp;lt;tag k=&quot;&lt;span class=&quot;SpellE&quot;&gt;&lt;span class=&quot;GramE&quot;&gt;name:en&lt;/span&gt;&lt;/span&gt;&quot; v=&quot;Super Brand Mall&quot;/&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt; &lt;/span&gt; &amp;lt;tag k=&quot;shop&quot; v=&quot;mall&quot;/&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt; &lt;/span&gt;&amp;lt;/way&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;我们注意到&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;OSM&lt;/span&gt;&lt;span&gt;其实就是一种&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;XML&lt;/span&gt;&lt;span&gt;文件格式，可以利用&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;LUA&lt;/span&gt;&lt;span&gt;语言来分析提取其中的建筑坐标信息。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;查询文件中的&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Way&lt;/span&gt;&lt;span&gt;节点，我们可以提取&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;building&lt;/span&gt;&lt;span&gt;的轮廓组成一个个&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;polygon&lt;/span&gt;&lt;span&gt;，它们带了经纬度坐标信息，我们可以通过公式换算后，对应到&lt;/span&gt;&lt;span class=&quot;SpellE&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;Paracraft&lt;/span&gt;&lt;/span&gt;&lt;span&gt;坐标，把它“画”出来。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;lt;![if !supportLists]&amp;gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;n&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &amp;lt;![endif]&amp;gt;&lt;span class=&quot;SpellE&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;CommandManager:RunCommand&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;(&quot;/take 126&quot;);&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;lt;![if !supportLists]&amp;gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;n&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &amp;lt;![endif]&amp;gt;&lt;span class=&quot;SpellE&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;CommandManager:RunCommand&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;(&quot;/box 1 1 1&quot;);&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;幸运的话，著名的建筑都有&lt;/span&gt;&lt;span class=&quot;SpellE&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;building:levels&lt;/span&gt;&lt;/span&gt;&lt;span&gt;高度信息，可以使用它表示建筑的高度，但是一般校园好像没有。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;那么如何通过编程的方式下载&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;OSM&lt;/span&gt;&lt;span&gt;文件呢？&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;OpenStreetMap&lt;/span&gt;&lt;span&gt;网站提供了相应的&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;API&lt;/span&gt;&lt;span&gt;，这里提供了说明：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;http://wiki.openstreetmap.org/wiki/API_v0.6&quot;&gt;&lt;span&gt;http://wiki.openstreetmap.org/wiki/API_v0.6&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;http://wiki.openstreetmap.org/wiki/Osmapi&quot;&gt;&lt;span&gt;http://wiki.openstreetmap.org/wiki/Osmapi&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;     &lt;/span&gt; GET /&lt;span class=&quot;SpellE&quot;&gt;api&lt;/span&gt;/0.6/&lt;span class=&quot;SpellE&quot;&gt;map?bbox&lt;/span&gt;=&lt;span class=&quot;SpellE&quot;&gt;&lt;em&gt;left&lt;/em&gt;,&lt;em&gt;bottom&lt;/em&gt;,&lt;em&gt;right&lt;/em&gt;,&lt;em&gt;top&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;例如&lt;/span&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;http://api.openstreetmap.org/api/0.6/map?bbox=120,30.1,120.25,30.2&quot;&gt;&lt;span&gt;http://api.openstreetmap.org/api/0.6/map?bbox=120,30.1,120.25,30.2&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;这里有个&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;C#&lt;/span&gt; &lt;span&gt;包装&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;API&lt;/span&gt;&lt;span&gt;的例子可以参考：&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;https://github.com/yrtimiD/osm-api-dotnet&quot;&gt;&lt;span&gt;https://github.com/yrtimiD/osm-api-dotnet&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;http://wiki.openstreetmap.org/wiki/3D&quot;&gt;&lt;span&gt;http://wiki.openstreetmap.org/wiki/3D&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;另外&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;OSM&lt;/span&gt;&lt;span&gt;有个工具叫&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;JOSM&lt;/span&gt;&lt;span&gt;可以打开&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;OSM&lt;/span&gt;&lt;span&gt;文件。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;http://josm.openstreetmap.de/wiki/Introduction&quot;&gt;&lt;span&gt;http://josm.openstreetmap.de/wiki/Introduction&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;并且有个插件可以显示&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;3D&lt;/span&gt; &lt;span&gt;建筑&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;http://wiki.openstreetmap.org/wiki/JOSM/Plugins/Kendzi3D&quot;&gt;&lt;span&gt;http://wiki.openstreetmap.org/wiki/JOSM/Plugins/Kendzi3D&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;        &lt;img src=&quot;http://www.timegis.com/Paracraft3D/image017.jpg&quot; alt=&quot;&quot; width=&quot;672&quot; height=&quot;366&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;我改写了一个&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;C#&lt;/span&gt;&lt;span&gt;程序&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;https://github.com/BjornDeRijcke/OpenStreetMap-3D&quot;&gt;&lt;span&gt;https://github.com/BjornDeRijcke/OpenStreetMap-3D&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;可以分析&lt;/span&gt;&lt;span class=&quot;SpellE&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;osm&lt;/span&gt;&lt;/span&gt;&lt;span&gt;文件并显示建筑，效果如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;center&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;img src=&quot;http://www.timegis.com/Paracraft3D/image018.png&quot; alt=&quot;&quot; width=&quot;497&quot; height=&quot;331&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/p&gt;














&lt;p&gt;&lt;span&gt;其实最终我们需要的如下结果：（此图拼凑而成）&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;  &lt;img src=&quot;http://www.timegis.com/Paracraft3D/image020.jpg&quot; alt=&quot;&quot; width=&quot;315&quot; height=&quot;263&quot; border=&quot;0&quot;/&gt;&lt;img src=&quot;http://www.timegis.com/Paracraft3D/image022.jpg&quot; alt=&quot;&quot; width=&quot;348&quot; height=&quot;261&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;span&gt;注：有个&lt;span lang=&quot;EN-US&quot;&gt;OpenStreetMap&lt;/span&gt;结合&lt;span lang=&quot;EN-US&quot;&gt;Unity3D&lt;/span&gt;例子，它也用&lt;span lang=&quot;EN-US&quot;&gt;C#&lt;/span&gt;分析了&lt;span lang=&quot;EN-US&quot;&gt;OSM&lt;/span&gt;文件，可以参考。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;https://github.com/ActionStreetMap/demo&quot;&gt;&lt;span&gt;https://github.com/ActionStreetMap/demo&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;img src=&quot;http://www.timegis.com/Paracraft3D/image024.jpg&quot; alt=&quot;&quot; width=&quot;290&quot; height=&quot;161&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;6.&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;后记&lt;/span&gt;&lt;/strong&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;span&gt;将来，如果觉得建筑不够细致，我们可能需要详细解析&lt;span lang=&quot;EN-US&quot;&gt;OSM&lt;/span&gt;文件。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;关于&lt;span lang=&quot;EN-US&quot;&gt;OSM&lt;/span&gt;的详细解析我们需要阅读下面的标准，并得到类似&lt;span lang=&quot;EN-US&quot;&gt;osm2wolrd&lt;/span&gt;的效果&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;https://wiki.openstreetmap.org/wiki/Simple_3D_buildings&quot;&gt;&lt;span&gt;https://wiki.openstreetmap.org/wiki/Simple_3D_buildings&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其他参考：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;http://osm2world.org/screens/&quot;&gt;&lt;span&gt;http://osm2world.org/screens/&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;        &lt;img src=&quot;http://www.timegis.com/Paracraft3D/image026.jpg&quot; alt=&quot;&quot; width=&quot;670&quot; height=&quot;273&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;      &lt;/span&gt;&lt;/span&gt; &lt;span&gt;关于地图的存储，我们可以直接从&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;OpenStreetMap&lt;/span&gt;&lt;span&gt;读取，也可事先下载到某个服务器，&lt;span class=&quot;GramE&quot;&gt;前面博客&lt;/span&gt;中有介绍。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;      &lt;/span&gt;&lt;/span&gt; &lt;span&gt;关于显示栅格地图，前面只提到了一个瓦片地图&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;PNG&lt;/span&gt;&lt;span&gt;的显示，可能我们需要一次读取多个（比如&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;4&lt;/span&gt;&lt;span&gt;个）相邻的瓦片地图，并同时显示到一个场景中。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;      &lt;/span&gt;&lt;/span&gt; &lt;span&gt;关于需求中提到一个格子表示一米，可能我们需要根据&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;ZOOMLEVEL&lt;/span&gt;&lt;span&gt;最大值时获取的瓦片地图（&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;256×256&lt;/span&gt;&lt;span&gt;大小）来计算，估计比一米要大，需要进一步研究，但是这个比例应该是可以显示校园了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;7.&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;后记二&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/strong&gt; &lt;span lang=&quot;EN-US&quot;&gt;Minecraft&lt;/span&gt;&lt;span&gt;是一款来自瑞典&lt;span class=&quot;GramE&quot;&gt;的沙盒建造&lt;/span&gt;独立游戏，玩家可以在一个由程序随机产生的三维世界内以带材质贴图的立方体为基础建造建筑物。游戏最初由瑞典人马库斯·阿列克谢·泊松（&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Markus 'Notch' Persson&lt;/span&gt;&lt;span&gt;）单独开发，随后自&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;2009&lt;/span&gt;&lt;span&gt;年起成立&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Mojang&lt;/span&gt;&lt;span&gt;公司开发此游戏。游戏中的其他活动包括探索世界，采集资源，合成物品及对战。&lt;/span&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;https://github.com/ddevault/TrueCraft&quot;&gt;&lt;span&gt;TrueCraft&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;是&lt;span lang=&quot;EN-US&quot;&gt;Minecraft 1.7.3&lt;/span&gt; 的一个完全开源的实现，使用&lt;span lang=&quot;EN-US&quot;&gt;C#&lt;/span&gt; 语言开发，因此也可以用它&lt;span class=&quot;GramE&quot;&gt;来结合&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;OpenStreetMap&lt;/span&gt; 生成&lt;span lang=&quot;EN-US&quot;&gt;3D&lt;/span&gt;城市。&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;   &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;        &lt;img src=&quot;http://www.timegis.com/Paracraft3D/image028.jpg&quot; alt=&quot;http://static.oschina.net/uploads/img/201505/02080613_E3TD.png&quot; width=&quot;728&quot; height=&quot;385&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;   &lt;/span&gt;&lt;/span&gt; &lt;span&gt;更多内容&lt;/span&gt;&lt;span&gt;，&lt;span class=&quot;GramE&quot;&gt;请访问&lt;/span&gt;时空地图网站：&lt;/span&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;http://www.TimeGIS.com&quot;&gt;&lt;span&gt;www.TimeGIS.com&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 03 Feb 2019 07:30:00 +0000</pubDate>
<dc:creator>快手软件-TimeGIS-com</dc:creator>
<og:description>本文结合开源软件 ParaCraft 和 OpenStreetMap ，介绍了一种生成3D校园的方法，对于那些想下载离线地图，或者分析OpenStreetMap矢量地图的读者来说，有一定的参考价值。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kuaishou/p/paracraft.html</dc:identifier>
</item>
<item>
<title>《Calculator: The Game》游戏解决方案 - Champagne_Jin</title>
<link>http://www.cnblogs.com/yishenmingliang/p/10350401.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yishenmingliang/p/10350401.html</guid>
<description>&lt;p&gt;本文将介绍手机游戏《Calculator: The Game》的完整解决方案。&lt;/p&gt;
&lt;p&gt;开源解决方案代码地址为：https://github.com/FunkyKoki/Calculator_Game&lt;/p&gt;
&lt;p&gt;《Calculator: The Game》这款游戏是Simple Machine开发的一款益智类解谜游戏，在一局游戏中，你务必在有限步骤[MOVES]内，使用该局提供的“操作”——如加减乘除、翻转、镜像等，将原始数字转化为目标数字[GOAL]。&lt;/p&gt;
&lt;p&gt;游戏总关卡数[LEVEL]为200，目前我已全部通关。另外，游戏内的植入广告颇多，我的建议是&lt;strong&gt;关闭该游戏的联网权限&lt;/strong&gt;，包括无线局域网与蜂窝网络，之后就可以尽享游戏乐趣了。&lt;/p&gt;
&lt;p&gt;如需了解游戏的详细介绍，请移步：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;【Android】https://play.google.com/store/apps/details?id=com.sm.calculateme&amp;amp;hl=en_US&lt;/li&gt;
&lt;li&gt;【iOS】https://itunes.apple.com/us/app/calculator-the-game/id1243055750&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;游戏界面如下图所示（整体看来还是比较呆萌的），类似于计算器LCD显示屏上显示的数字即当前计算得到的数字（在游戏开始时即为初始化的数字），MOVES显示可用的步骤数，GOAL显示目标数字，CLR用于清空之前的所有操作（即还原该局游戏），‘+4’、‘*4’、‘/4’就是我们在这一局游戏中可用的“操作”了，HINTS和设置就不用我再多说了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/838555/201902/838555-20190202202401533-84746636.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在进行这款游戏的破解工作前，首先要保证自己对整个游戏有一个基本了解才可以，而我在试玩前十几关时注意到了一个重要现象，这对之后破解这款游戏起到了非常关键的作用，即：&lt;strong&gt;一局游戏中，界面上给出的“操作”都是需要用到的操作，不存在冗余无关项&lt;/strong&gt;。我将这一点称为&lt;strong&gt;1号公理&lt;/strong&gt;，仅这一点就大大降低了编程破解的难度。&lt;/p&gt;
&lt;p&gt;另外值得注意的一点是：&lt;strong&gt;步骤数永远大于等于操作数（这由1号公理可以显然推出），且在步骤数大于操作数的情况下，最多仅大出5&lt;/strong&gt;。我将这一点称为&lt;strong&gt;2号公理&lt;/strong&gt;。我们定义一局游戏给出的步骤数为MOVES，给出的&quot;操作&quot;的数量为OPS，则OPS&amp;lt;=MOVES&amp;lt;=OPS+5。&lt;/p&gt;
&lt;p&gt;根据以上两个公理，我们就有了暴力破解的“理论指导”，说白了，我们将&lt;strong&gt;有理有据地穷举&lt;/strong&gt;所有可行的操作序列，并依序&lt;strong&gt;测试操作序列&lt;/strong&gt;的正确与否。&lt;/p&gt;
&lt;hr/&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;第一个问题，如何列举所有可行的操作序列？&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;这个问题往简单了说，就是一个&lt;strong&gt;排列问题&lt;/strong&gt;，即将可用的操作以不同的排列顺序全部列举出来。但是，它又不仅仅是一个排列问题。需要注意到，步骤数MOVES与操作数OPS之间有两种关系，一种是&lt;strong&gt;MOVES==OPS&lt;/strong&gt;，另一种是在&lt;strong&gt;满足2号定理的前提下，MOVES!=OPS&lt;/strong&gt;，这就将排列问题划分为了两种情况。&lt;/p&gt;
&lt;h3&gt;1. MOVES==OPS&lt;/h3&gt;
&lt;p&gt;如果步骤数等于操作数，则问题变得很简单。根据1号公理，我们知道所有的操作都必然被使用，因此为了穷举所有可行的操作序列，我们所要解决的就是一个很简单的&lt;strong&gt;全排列问题&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;设步骤数MOVES=4，OPS分别为A、B、C、D，此时MOVES==OPS，问题转化为全排列问题。我们使用下面的代码来解决这个全排列问题：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 递归全排列&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; Permutation(l, beg, endl, result):
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; beg == endl - 1&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         res =&lt;span&gt; l[:]
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        result.append(res)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(beg, endl):
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; l[i] &lt;span&gt;in&lt;/span&gt;&lt;span&gt; l[beg:i]:
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;continue&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         l[i], l[beg] =&lt;span&gt; l[beg], l[i]
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         Permutation(l, beg+1&lt;span&gt;, endl, result)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         l[beg], l[i] = l[i], l[beg]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 这个全排列的Python代码主要借鉴自https://blog.csdn.net/zhoufen12345/article/details/53560099，不过我做了一些改变，原代码主要用于打印所有可能的排列，但这不是我的目的，我的主要目的在于得到所有的排列，而不是显式地打印出来，也就是说，要将这些排列结果保存下来。这里需要注意，第4、5行不可简写为 &lt;span class=&quot;cnblogs_code&quot;&gt;result.append(l)&lt;/span&gt; ，这是&lt;strong&gt;由于在递归过程中， &lt;span class=&quot;cnblogs_code&quot;&gt;l&lt;/span&gt;位于堆栈之中，不能直接拿来使用，因此需要使用一个中间变量进行过渡&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如此，我们就可以获得全部可用排列，再送至后面的检验部门测试哪个排列结果是可用的。&lt;/p&gt;
&lt;h3&gt;2. MOVES!=OPS&lt;/h3&gt;
&lt;p&gt;在这种情况下，表明有至少一个“操作”被重复使用了，这可如何解决是好呢？&lt;/p&gt;
&lt;p&gt;我的解决方案是，基于每一个操作都必然被使用的前提，对于后(MOVES-OPS)步，我们使用for循环&lt;strong&gt;强行将每一种可能重复使用的操作的情况添加进一个待排列的序列中，再对这个增加了重复操作的序列进行全排列&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;举个例子，如MOVES=4，OPS为A、B、C，无论如何必然会使用ABC这三个操作，接着对这个序列添加所有可能的重复操作，则得到ABCA、ABCB、ABCC这三个序列，最后，我们将这三个序列分别进行全排列并将结果添加至result中。&lt;/p&gt;
&lt;p&gt;说白了，想尽办法穷举所有可能的排列情况。&lt;/p&gt;
&lt;p&gt;这里我的代码是这样写的，还值得优化，但是太懒了，所以就来了个“硬编码”：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; moves &amp;gt;&lt;span&gt; ops_num:   # moves为步骤数，ops_num为操作数
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; moves - ops_num == 1&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(ops_num):
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             ops =&lt;span&gt; copy.copy(init_ops)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;            ops.append(init_ops[i])
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;            Permutation(ops, beg, endl, all_ops)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; moves - ops_num == 2&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(ops_num):
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; j &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(ops_num):
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 ops =&lt;span&gt; copy.copy(init_ops)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;                ops.append(init_ops[i])
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;                ops.append(init_ops[j])
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;                Permutation(ops, beg, endl, all_ops)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; moves - ops_num == 3&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(ops_num):
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; j &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(ops_num):
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; k &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(ops_num):
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                     ops =&lt;span&gt; copy.copy(init_ops)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;                    ops.append(init_ops[i])
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;                    ops.append(init_ops[j])
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;                    ops.append(init_ops[k])
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;                    Permutation(ops, beg, endl, all_ops)
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; moves - ops_num == 4&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(ops_num):
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; j &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(ops_num):
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; k &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(ops_num):
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                     &lt;span&gt;for&lt;/span&gt; q &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(ops_num):
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                         ops =&lt;span&gt; copy.copy(init_ops)
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;                        ops.append(init_ops[i])
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;                        ops.append(init_ops[j])
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;                        ops.append(init_ops[k])
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;                        ops.append(init_ops[q])
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;                        Permutation(ops, beg, endl, all_ops)
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; moves - ops_num == 5&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(ops_num):
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; j &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(ops_num):
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; k &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(ops_num):
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                     &lt;span&gt;for&lt;/span&gt; q &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(ops_num):
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;                         &lt;span&gt;for&lt;/span&gt; p &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(ops_num):
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;                             ops =&lt;span&gt; copy.copy(init_ops)
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;                            ops.append(init_ops[i])
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;                            ops.append(init_ops[j])
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;                            ops.append(init_ops[k])
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;                            ops.append(init_ops[q])
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;                            ops.append(init_ops[p])
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;                            Permutation(ops, beg, endl, all_ops)
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; moves - ops_num == 6&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(ops_num):
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; j &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(ops_num):
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; k &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(ops_num):
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;                     &lt;span&gt;for&lt;/span&gt; q &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(ops_num):
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;                         &lt;span&gt;for&lt;/span&gt; p &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(ops_num):
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;                             &lt;span&gt;for&lt;/span&gt; w &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(ops_num):
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;                                 ops =&lt;span&gt; copy.copy(init_ops)
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;                                ops.append(init_ops[i])
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;                                ops.append(init_ops[j])
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; &lt;span&gt;                                ops.append(init_ops[k])
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; &lt;span&gt;                                ops.append(init_ops[q])
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; &lt;span&gt;                                ops.append(init_ops[p])
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; &lt;span&gt;                                ops.append(init_ops[w])
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; &lt;span&gt;                                Permutation(ops, beg, endl, all_ops)
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; &lt;span&gt;elif&lt;/span&gt; moves ==&lt;span&gt; ops_num:
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt;     Permutation(init_ops, beg, endl, all_ops)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上的代码只列举到了 &lt;span class=&quot;cnblogs_code&quot;&gt;moves - ops_num == 6&lt;/span&gt; 的情况，这是基于2号公理写的。2号公理指出，步骤数如果大于操作数，最多只大5，为了防止万一，我增加了上限，扩展成了6。&lt;/p&gt;
&lt;p&gt;通过以上操作，我们可以说&lt;strong&gt;基本上&lt;/strong&gt;完成了可用操作序列的完全列举。为什么说是基本上呢？因为在游戏后期，大概是LEVEL为155处，游戏增加了一个有趣的操作，称为“Store”，它将迫使我们继续深层次地列举所有可用操作序列。&lt;/p&gt;
&lt;hr/&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;第二个问题，如何测试所有操作序列？&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;看起来比较简单，不过是依序测试每个操作罢了，那么我们就先来看看整个游戏有哪些操作吧。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;+&lt;/li&gt;
&lt;li&gt;-&lt;/li&gt;
&lt;li&gt;*&lt;/li&gt;
&lt;li&gt;/&lt;/li&gt;
&lt;li&gt;末尾插入数字（如当前数字为1234，插入7，则数字变为12347），插入数字的操作方块为浅紫色背景&lt;/li&gt;
&lt;li&gt;数字代换C23=&amp;gt;14（如当前数字为1234，将23代换为14，则数字变为1144）&lt;/li&gt;
&lt;li&gt;删除末尾数字&amp;lt;&amp;lt;（如当前数字为1234，删除一个数字，则数字变为123）&lt;/li&gt;
&lt;li&gt;翻转数字Reverse（如当前数字为1234，翻转一个数字，则数字变为4321）&lt;/li&gt;
&lt;li&gt;Shift&amp;lt;&amp;lt;（如当前数字为1234，向左Shift一个数字，则数字变为2341）&lt;/li&gt;
&lt;li&gt;Shift&amp;gt;&amp;gt;（如当前数字为1234，向右Shift一个数字，则数字变为4123）&lt;/li&gt;
&lt;li&gt;立方x&lt;sup&gt;3&lt;/sup&gt;（如当前数字为4，立方一个数字，则数字变为64）&lt;/li&gt;
&lt;li&gt;SUM（如当前数字为1234，SUM一个数字即求各位数字之和，则数字变为10）&lt;/li&gt;
&lt;li&gt;Mirror（如当前数字为123，Mirror一个数字即镜像拼接一个数字，则数字变为123321）&lt;/li&gt;
&lt;li&gt;+/-（如当前数字为1234，经此操作，则数字变为-1234）&lt;/li&gt;
&lt;li&gt;Inv10（如当前数字为1250，Inv10一个数字，则数字变为9850）&lt;/li&gt;
&lt;li&gt;[+]x（将当前所有可用的操作的数值全部加x，如当前所有可用操作为/2、+3、插入2，经过[+]1操作，则变为/3、+4、插入3）&lt;/li&gt;
&lt;li&gt;[-]x，同上，只是变为减x&lt;/li&gt;
&lt;li&gt;Store，长按该键保存当前计算得到的数值，在这之后其功能变为插入键的功能，即在末尾插入其保存的数字，注意，&lt;strong&gt;长按保存这一步骤并不消耗步骤数&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;标记求和，这个操作是每进行一个操作后，若满足条件自动完成的，具体来说将在下面详细介绍&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里有些操作比较简单，我主要讲一下[+]x、[-]x、Store以及标记求和这几个操作的处理细节，而前两个又可以归为一类。&lt;/p&gt;
&lt;p&gt;在详细介绍这几个操作的实现之前，我觉得还有几点需要特意提一下，也是整个编程过程中的细节：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;所有的操作都是整数操作，因此切忌在整个计算过程中误使数字变为浮点数；&lt;/li&gt;
&lt;li&gt;一些操作在对正负数进行处理时需要注意细节，如左右Shift的时候，需要将数字和符号先分开（当然，这是我的实现方式，欢迎指出其他方法）；&lt;/li&gt;
&lt;li&gt;python有深浅拷贝的区别，需要特别注意。&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;1. [+]x&lt;/h3&gt;
&lt;p&gt;细细分析该操作，我将其定义为“摄动”操作符，即该操作影响了其他操作的操作数，为此，我引入了摄动因子 &lt;span class=&quot;cnblogs_code&quot;&gt;influence&lt;/span&gt; ，每当进行该操作时，即改变了摄动因子，而摄动因子又全面影响了其他所有摄动操作符将会影响到的操作。&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; influence =&lt;span&gt; 0
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; j &lt;span&gt;in&lt;/span&gt;&lt;span&gt; all_ops[i]:
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; j[0] == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; j[1] == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;                 influence += int(j[3&lt;span&gt;:])
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;elif&lt;/span&gt; j[1] == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 influence -= int(j[3&lt;span&gt;:])
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;elif&lt;/span&gt; j[0] == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;I&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; calc_num &amp;gt;=&lt;span&gt; 0:
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; int(j[1:]) + influence ==&lt;span&gt; 0:
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                     calc_num = calc_num * 10
&lt;span&gt;12&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                     calc_num = calc_num * pow(10, int(math.log10(int(j[1:]) + influence)) + 1) + int(j[1:])+&lt;span&gt;influence
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; int(j[1:]) ==&lt;span&gt; 0:
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                     calc_num = calc_num * 10
&lt;span&gt;17&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                     calc_num = calc_num * pow(10, int(math.log10(int(j[1:]) + influence)) + 1) - int(j[1:])-&lt;span&gt;influence
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;elif&lt;/span&gt; j[0] == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             calc_num += (int(j[1:]) +&lt;span&gt; influence)
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;elif&lt;/span&gt; j[0] == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             calc_num -= (int(j[1:]) +&lt;span&gt; influence)
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;elif&lt;/span&gt; j[0] == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             calc_num *= (int(j[1:]) +&lt;span&gt; influence)
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;elif&lt;/span&gt; j[0] == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; math.modf(calc_num/(int(j[1:])+influence))[0] !=&lt;span&gt; 0:
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;             calc_num = calc_num // (int(j[1:])+influence)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此处我仅列举了摄动操作会影响到的操作，如插入、加减乘除，事实上，正如之前介绍的，Store本身也是一个插入操作，只是这里还没有详细介绍，因此暂时不提。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;2. Store&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Store运算符在这之前稍微介绍了一下，这个操作符最骚的一点是，长按能够保存当前计算得到的数字，而长按本身并不消耗步骤数，这一点大大提升了解谜的难度，在保存了数字后，短按该键将执行类似于插入数字的操作，短按插入数字时消耗步骤数。&lt;/p&gt;
&lt;p&gt;在编程时需要解决的难题也就是这个长按与短按的问题，短按可以看作普通按键，长按就有些不可理喻了，不过经过一阵摸索，我也得到了一些经验，即&lt;strong&gt;长按保存数字的操作，在一局游戏中至多使用两次&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如此一来，我们就又有了穷举所有排列可能性的理论依据。&lt;/p&gt;
&lt;p&gt;不外乎两种情况，&lt;strong&gt;插入一个长按Store操作&lt;/strong&gt;和&lt;strong&gt;插入两个长按Store操作&lt;/strong&gt;，且值得注意的是，&lt;strong&gt;长按Store操作在整个操作序列末尾是没有意义的&lt;/strong&gt;，因此经过一通分析后，事情瞬间easy。&lt;/p&gt;
&lt;p&gt;另外还有一点很关键，要能够分析到，根据1号公理，所有按键均需要使用到，因此在所有含有Store操作的游戏对局中，为了确保Store操作被使用，其必然经过了至少1次长按Store操作。于是，以下代码就诞生了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; store_index =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(len(all_ops)):
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; it &lt;span&gt;in&lt;/span&gt;&lt;span&gt; all_ops[i]:
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; it == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Store&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;            store_index.append(i)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;break&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(len(store_index)):   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 插入一个Store_S&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     temp =&lt;span&gt; copy.deepcopy(all_ops[store_index[i]])
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; index &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(len(temp)):
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         temp_a =&lt;span&gt; copy.deepcopy(temp)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         temp_a.insert(index, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Store_S&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        all_ops.insert(len(all_ops), temp_a)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(len(store_index)):   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 插入两个Store_S&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;     temp =&lt;span&gt; copy.deepcopy(all_ops[store_index[i]])
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; index &lt;span&gt;in&lt;/span&gt; range(len(temp)-1&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         temp_a =&lt;span&gt; copy.deepcopy(temp)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         temp_a.insert(index, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Store_S&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; ttt &lt;span&gt;in&lt;/span&gt; range(3-&lt;span&gt;index):
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             temp_b =&lt;span&gt; copy.deepcopy(temp_a)
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             temp_b.insert(index + ttt + 2, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Store_S&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;            all_ops.insert(len(all_ops), temp_b)
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(len(store_index)):
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     all_ops.pop(0)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这段代码的作用就是在全排列得到所有操作后，分别插入1个Store_S（即长按Store操作）与2个Store_S得到可用的全部操作序列，由于必然需要使用Store_S，因此，result队列最前面不含有Store_S的操作序列均可删去。&lt;/p&gt;
&lt;p&gt;最后，在进行某一操作序列的测试时，我们定义变量 &lt;span class=&quot;cnblogs_code&quot;&gt;Store_num&lt;/span&gt; 用以保存Store_S操作保存的数字，并得到以下操作代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;elif&lt;/span&gt; j == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Store_S&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;             Store_num =&lt;span&gt; calc_num
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;elif&lt;/span&gt; j == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Store&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; calc_num &amp;gt;=&lt;span&gt; 0:
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; Store_num + influence ==&lt;span&gt; 0:
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                     calc_num = calc_num * 10
&lt;span&gt; 7&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                     calc_num = calc_num * pow(10, int(math.log10(Store_num + influence)) + 1) + Store_num+&lt;span&gt;influence
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; int(j[1:]) ==&lt;span&gt; 0:
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                     calc_num = calc_num * 10
&lt;span&gt;12&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                     calc_num = calc_num * pow(10, int(math.log10(Store_num + influence)) + 1) - Store_num-influence
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如此一来，我们就完成了这个骚气的Store操作，效果杠杠的。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;3. Patrol&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;这个Patrol操作，我将其中文名称为标记求和，大致长成下面这个样子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/838555/201902/838555-20190203144713906-1558671078.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所谓的标记求和，就是指对两个小三角所指的那两位数字进行求和，低于最左边三角所在位数的其余位数保持不变，高于最左边三角所在位数的数字自动向右移动一位。语言解释起来没什么感觉，我们来看一个实际的例子：&lt;/p&gt;
&lt;p&gt;假设当前数字为123，设小三角所指位数从最右向最左由1依次增大，假设左三角指向第4位，右三角指向第1位，则在插入数字1后，数字变为1231，此时，两个三角所指的位数都有了数字，因此求和第1位和第4位的数字，得2，其余数字位数不变，最后转化为232。&lt;/p&gt;
&lt;p&gt;再假设当前数字为1234，左三角指向第5位，右三角指向第1位，插入数字56，数字变成123456，第5位数字为2，第1位数字为6，求和得到8，由于1所在的位数为第6位，高于左三角所在位数，因此数字变为13458，此时第1和第5位仍有数字，所以继续自动进行标记求和操作，最终变为3459。&lt;/p&gt;
&lt;p&gt;根据以上陈述，我们可以在经过一个操作序列的其中一个操作后，对得到的数字进行自动处理：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; patrol_flag == 1&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     ss = calc_num//&lt;span&gt;abs(calc_num)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     calc_num =&lt;span&gt; list(str(abs(calc_num)))
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt; len(calc_num) &amp;gt;=&lt;span&gt; patrol_l:
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         patrol_sum = (int(calc_num[len(calc_num)-patrol_l])+int(calc_num[len(calc_num)-patrol_r]))*pow(10, patrol_r-1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         patrol_else_sum =&lt;span&gt; 0
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; zzz &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(len(calc_num)):
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; zzz != patrol_l-1 &lt;span&gt;and&lt;/span&gt; zzz != patrol_r-1 &lt;span&gt;and&lt;/span&gt; zzz &amp;lt;&lt;span&gt; patrol_l:
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 patrol_else_sum += int(calc_num[len(calc_num) - zzz - 1]) * pow(10&lt;span&gt;, zzz)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; zzz &amp;gt;=&lt;span&gt; patrol_l:
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 patrol_else_sum += int(calc_num[len(calc_num) - zzz - 1]) * pow(10, zzz - 1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         calc_num = patrol_sum +&lt;span&gt; patrol_else_sum
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         calc_num =&lt;span&gt; list(str(calc_num))
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     calc_num = ss * int(&lt;span&gt;''&lt;/span&gt;.join(calc_num))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里我们使用的是while，为的就是保证数字送进去之后会一直自动变换，直至标记的位数不再同时含有数字。&lt;/p&gt;
&lt;hr/&gt;
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;本来以为写个几行代码就能通关的，没想到这个游戏一直给我惊喜，各式各类的操作符花样迭出，因此最终完成的这版代码也是相当粗糙，目前还有以下几点值得优化：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对MOVES!=OPS的情况下，获取所有可能的操作序列的代码仍待优化，目前的代码太暴力了（不过很懒，可能就不改了hhh）&lt;/li&gt;
&lt;li&gt;不同操作符对应的操作代码可以进行包装，形成函数，整个代码看起来应该会更清爽&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;不得不说，Python是一个相当妙的语言，它的编程逻辑与C还是有很大不同的，在写代码的过程中，才发现我对Python掌握得并不是很好，有很多语言特性还没有把握到，这也正表明了不断用类似的小项目去磨练自己的必要性。&lt;/p&gt;
&lt;p&gt;我的代码也没怎么加注释，那这篇博文就当是注释啦hh&lt;/p&gt;
</description>
<pubDate>Sun, 03 Feb 2019 07:06:00 +0000</pubDate>
<dc:creator>Champagne_Jin</dc:creator>
<og:description>本文将介绍手机游戏《Calculator: The Game》的完整解决方案。 开源解决方案代码地址为：https://github.com/FunkyKoki/Calculator_Game 《Ca</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yishenmingliang/p/10350401.html</dc:identifier>
</item>
<item>
<title>JAVA性能优化工具小记 - 让我发会呆</title>
<link>http://www.cnblogs.com/yxy-ngu/p/10350103.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yxy-ngu/p/10350103.html</guid>
<description>&lt;p&gt;好记性不如烂笔头，戊戌年的最后一个工作日，把自己平时在开发过程中使用的一些java性能优化工具做一个简单的小结，&lt;/p&gt;
&lt;p&gt;主要包括 jvisualvm、jfr、gdb和查看内存对象信息的几个linux命令。&lt;/p&gt;
&lt;p&gt;注：当前系统属性 Mac OS X 10.13.6，jdk版本 1.8.0_151&lt;/p&gt;
&lt;h2&gt;1：jvisualvm(当前java自带的工具)&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/998887/201902/998887-20190203100856958-99839866.png&quot; alt=&quot;&quot; width=&quot;758&quot; height=&quot;438&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到jvisualvm不仅支持本地应用程序的追踪还支持远程。&lt;/p&gt;
&lt;p&gt;然后打开对应的本地项目：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/998887/201902/998887-20190203102107141-1296429522.png&quot; alt=&quot;&quot; width=&quot;754&quot; height=&quot;554&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 这里面确实有很多项目的信息，CPU、堆栈信息等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/998887/201902/998887-20190203102459909-672292282.png&quot; alt=&quot;&quot; width=&quot;821&quot; height=&quot;611&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我目前使用它就是用它的抽样器，查看当前项目里的对象数及对象占用的内存大小。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/998887/201902/998887-20190203104751874-1772255196.png&quot; alt=&quot;&quot; width=&quot;827&quot; height=&quot;616&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样对项目中某个对象个数过多或者对象过大，就可以方便的查看到，然后去优化它。&lt;/p&gt;
&lt;h2&gt;2:JFR&lt;/h2&gt;
&lt;p&gt;jfr的优点：&lt;/p&gt;
&lt;p&gt;VisualVM功能强大，支持图形化界面操作，可以很快定位代码问题。但是它对应用性能的影响也非常大，所以不适合在生产环境下使用。&lt;/p&gt;
&lt;p&gt;还有这些软件（比如GDB(下面介绍)）要attach到jvm进程上，生产环境一般网络隔离，很难做到。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用jfr不需要在现有应用上额外添加&lt;/strong&gt;任何参数、重启进程等，直接在命令行执行即可，实时生效，100%无入侵，且稳定可靠，不影响线上应用运行。&lt;/p&gt;
&lt;p&gt; jfr的使用：&lt;/p&gt;
&lt;h3&gt;2.1：本地使用：&lt;/h3&gt;
&lt;p&gt;1：需要在项目jvm加上配置 vm options：-XX:+UnlockCommercialFeatures -XX:+FlightRecorder&lt;/p&gt;
&lt;p&gt;2：打开jmc&lt;/p&gt;
&lt;p&gt;3：打开对应的进程ID，就可以追踪本项目的堆栈、CPU等信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/998887/201902/998887-20190203111830883-852833406.png&quot; alt=&quot;&quot; width=&quot;868&quot; height=&quot;501&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2.2：在服务器上使用：&lt;/h3&gt;
&lt;p&gt;1：由于JFR需要JDK的商业证书，这一步需要解锁jdk的商业特性：&lt;/p&gt;
&lt;p&gt;　　jcmd &amp;lt;PID&amp;gt; VM.unlock_commercial_features&lt;/p&gt;
&lt;p&gt;2：启动jrf，开始输出jfr文件&lt;/p&gt;
&lt;p&gt;　　jcmd &amp;lt;PID&amp;gt; JFR.start name=test duration=60s filename=/tmp/output.jfr&lt;/p&gt;
&lt;p&gt;3：拿到jfr文件后，在本地打开jmc图形化工具后，选择文件直接打开，然后就可以看到服务器上duration时间间隔的项目信息。&lt;/p&gt;
&lt;p&gt;当然无论是本地运行还是在服务器上运行，Java飞行记录器都支持创建一个模板。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/998887/201902/998887-20190203123118246-1833353742.png&quot; alt=&quot;&quot; width=&quot;778&quot; height=&quot;157&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在高级模式中，你可以自定义自己想要的信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/998887/201902/998887-20190203123641181-2022015474.png&quot; alt=&quot;&quot; width=&quot;778&quot; height=&quot;772&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 创建好模板后，无论是在本地还是复制到远程服务器上，&lt;/p&gt;
&lt;p&gt;jcmd &amp;lt;PID&amp;gt; JFR.start name=test duration=60s settings=template.jfc filename=/tmp/output.jfr&lt;/p&gt;
&lt;p&gt;settings=template.jfc就可以指定使用templayte.jfc这个模板的配置去收集项目信息。&lt;/p&gt;

&lt;p&gt;首先机器上需要安装gdb，gdb的安装就不赘述了，&lt;/p&gt;
&lt;p&gt;sudo apt-get install gdb&lt;/p&gt;
&lt;p&gt;sudo yum install gdb&lt;/p&gt;
&lt;p&gt;brew install gdb&lt;/p&gt;
&lt;h3&gt;1：使用gdb生成java heap文件&lt;/h3&gt;
&lt;h4&gt;1.1：生成进程core文件&lt;/h4&gt;
&lt;p&gt;sudo gdb -p &amp;lt;PID&amp;gt;&lt;/p&gt;
&lt;p&gt;. . .bunch of info. . .&lt;/p&gt;
&lt;p&gt;(gdb)gocre /tmp/jvm.core&lt;/p&gt;
&lt;p&gt;　　Saved corefile /tmp/jvm.core&lt;/p&gt;
&lt;p&gt;(gdb) detach&lt;/p&gt;
&lt;p&gt;(gdb) quit&lt;/p&gt;
&lt;h4&gt;1.2：根据core文件生成java heap文件&lt;/h4&gt;
&lt;p&gt;sudo jmap -dump:format=b,file=/tmp/jvm.hprof /usr/bin/java (自己机器java路径) /tmp/jvm.core&lt;/p&gt;
&lt;h3&gt;2：运行MAT找出内存泄漏根源（MAT下载：&lt;a href=&quot;https://www.eclipse.org/mat/downloads.php&quot; target=&quot;_blank&quot;&gt;https://www.eclipse.org/mat/downloads.php&lt;/a&gt;）&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/998887/201902/998887-20190203130246802-1401301044.png&quot; alt=&quot;&quot; width=&quot;840&quot; height=&quot;172&quot;/&gt; &lt;/p&gt;
&lt;div class=&quot;page&quot; title=&quot;Page 91&quot; readability=&quot;32&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/998887/201902/998887-20190203130340847-1463728364.png&quot; alt=&quot;&quot; width=&quot;846&quot; height=&quot;587&quot;/&gt;&lt;p&gt; 点击finish，然后就可以看到当前java进程的堆栈信息。&lt;/p&gt;
&lt;h2&gt; 4：常用的查看java进程堆栈信息命令&lt;/h2&gt;
&lt;/div&gt;
&lt;div class=&quot;page&quot; title=&quot;Page 91&quot; readability=&quot;51.010895883777&quot;&gt;
&lt;p class=&quot;title-article&quot;&gt;&lt;a href=&quot;https://blog.csdn.net/eos2009/article/details/78522901&quot; target=&quot;_blank&quot;&gt;JVM学习----查看堆栈信息&lt;/a&gt;这篇文章较全面的写了jstat、jmap的详细用法，下面我列举自己常用的一些命令：&lt;/p&gt;
&lt;p class=&quot;title-article&quot;&gt;每3秒钟输出一次当前进程已使用空间占总空间的百分比&lt;/p&gt;
&lt;p class=&quot;title-article&quot;&gt;命令：jstat -gcutil &amp;lt;PID&amp;gt;  3000   &lt;/p&gt;
&lt;p class=&quot;title-article&quot;&gt;打印进程堆存活的各个对象个数和所占大小&lt;/p&gt;
&lt;p class=&quot;title-article&quot;&gt;命令：jmap -histo:live &amp;lt;PID&amp;gt; | more&lt;/p&gt;
&lt;p&gt;使用jcmd不加任何参数即可获取jvm进程列表&lt;/p&gt;
&lt;p&gt;命令：jcmd&lt;/p&gt;
&lt;p&gt;使用jcmd help能够获取某个jvm进程其他可用的诊断命令&lt;/p&gt;
&lt;p&gt;命令：jcmd &amp;lt;PID&amp;gt; help&lt;/p&gt;
&lt;p&gt;它所列举的commands都是可以使用的。&lt;/p&gt;
&lt;h2&gt;5：参考文章相关链接：&lt;/h2&gt;
&lt;p class=&quot;site-title&quot;&gt;Java Performance Tuning Guide：http://java-performance.info/&lt;/p&gt;
&lt;p class=&quot;title-article&quot;&gt;JVM学习----查看堆栈信息：https://blog.csdn.net/eos2009/article/details/78522901&lt;/p&gt;
&lt;p id=&quot;headline&quot; class=&quot;headline entry-title section-bottom-xl&quot;&gt;JVM’s heap：https://www.atlassian.com/blog/archives/so-you-want-your-jvms-heap&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Sun, 03 Feb 2019 05:52:00 +0000</pubDate>
<dc:creator>让我发会呆</dc:creator>
<og:description>好记性不如烂笔头，戊戌年的最后一个工作日，把自己平时在开发过程中使用的一些java性能优化工具做一个简单的小结， 主要包括 jvisualvm、jfr、gdb和查看内存对象信息的几个linux命令。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yxy-ngu/p/10350103.html</dc:identifier>
</item>
<item>
<title>【Go】strings.Replace 与 bytes.Replace 调优 - 戚银</title>
<link>http://www.cnblogs.com/thinkeridea/p/10350228.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/thinkeridea/p/10350228.html</guid>
<description>&lt;p&gt;原文链接：&lt;a href=&quot;https://blog.thinkeridea.com/201902/go/replcae_you_hua.html&quot; class=&quot;uri&quot;&gt;https://blog.thinkeridea.com/201902/go/replcae_you_hua.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;标准库中函数大多数情况下更通用，性能并非最好的，还是不能过于迷信标准库，最近又有了新发现，&lt;code&gt;strings.Replace&lt;/code&gt; 这个函数自身的效率已经很好了，但是在特定情况下效率并不是最好的，分享一下我如何优化的吧。&lt;/p&gt;
&lt;p&gt;我的服务中有部分代码使用 &lt;code&gt;strings.Replace&lt;/code&gt; 把一个固定的字符串删除或者替换成另一个字符串，它们有几个特点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;旧的字符串大于或等于新字符串 &lt;code&gt;(len(old) &amp;gt;= len(new)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;源字符串的生命周期很短，替换后就不再使用替换前的字符串&lt;/li&gt;
&lt;li&gt;它们都比较大，往往超过 2k~4k&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;本博文中使用函数均在 &lt;a href=&quot;https://github.com/thinkeridea/go-extend&quot;&gt;&lt;strong&gt;go-extend&lt;/strong&gt;&lt;/a&gt; 中，优化后的函数在 &lt;a href=&quot;https://github.com/thinkeridea/go-extend/blob/master/exbytes/bytes.go&quot;&gt;exbytes.Replace&lt;/a&gt; 中。&lt;/p&gt;
&lt;h2 id=&quot;发现问题&quot;&gt;发现问题&lt;/h2&gt;
&lt;p&gt;近期使用 &lt;code&gt;pprof&lt;/code&gt; 分析内存分配情况，发现 &lt;code&gt;strings.Replace&lt;/code&gt; 排在第二，占 &lt;code&gt;7.54%&lt;/code&gt;, 分析结果如下：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;go tool pprof allocs
File: xxx
Type: alloc_space
Time: Feb 1, 2019 at 9:53pm (CST)
Entering interactive mode (type &quot;help&quot; for commands, &quot;o&quot; for options)
(pprof) top
Showing nodes accounting for 617.29GB, 48.86% of 1263.51GB total
Dropped 778 nodes (cum &amp;lt;= 6.32GB)
Showing top 10 nodes out of 157
      flat  flat%   sum%        cum   cum%
  138.28GB 10.94% 10.94%   138.28GB 10.94%  logrus.(*Entry).WithFields
   95.27GB  7.54% 18.48%    95.27GB  7.54%  strings.Replace
   67.05GB  5.31% 23.79%   185.09GB 14.65%  v3.(*v3Adapter).parseEncrypt
   57.01GB  4.51% 28.30%    57.01GB  4.51%  bufio.NewWriterSize
   56.63GB  4.48% 32.78%    56.63GB  4.48%  bufio.NewReaderSize
   56.11GB  4.44% 37.23%    56.11GB  4.44%  net/url.unescape
   39.75GB  3.15% 40.37%    39.75GB  3.15%  regexp.(*bitState).reset
   36.11GB  2.86% 43.23%    38.05GB  3.01%  des3_and_base64.(*des3AndBase64).des3Decrypt
   36.01GB  2.85% 46.08%    36.01GB  2.85%  des3_and_base64.(*des3AndBase64).base64Decode
   35.08GB  2.78% 48.86%    35.08GB  2.78%  math/big.nat.make&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;标准库中最常用的函数，居然……，不可忍必须优化，先使用 &lt;code&gt;list strings.Replace&lt;/code&gt; 看一下源码什么地方分配的内存。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;(pprof) list strings.Replace
Total: 1.23TB
ROUTINE ======================== strings.Replace in /usr/local/go/src/strings/strings.go
   95.27GB    95.27GB (flat, cum)  7.54% of Total
         .          .    858:   } else if n &amp;lt; 0 || m &amp;lt; n {
         .          .    859:       n = m
         .          .    860:   }
         .          .    861:
         .          .    862:   // Apply replacements to buffer.
   47.46GB    47.46GB    863:   t := make([]byte, len(s)+n*(len(new)-len(old)))
         .          .    864:   w := 0
         .          .    865:   start := 0
         .          .    866:   for i := 0; i &amp;lt; n; i++ {
         .          .    867:       j := start
         .          .    868:       if len(old) == 0 {
         .          .    869:           if i &amp;gt; 0 {
         .          .    870:               _, wid := utf8.DecodeRuneInString(s[start:])
         .          .    871:               j += wid
         .          .    872:           }
         .          .    873:       } else {
         .          .    874:           j += Index(s[start:], old)
         .          .    875:       }
         .          .    876:       w += copy(t[w:], s[start:j])
         .          .    877:       w += copy(t[w:], new)
         .          .    878:       start = j + len(old)
         .          .    879:   }
         .          .    880:   w += copy(t[w:], s[start:])
   47.81GB    47.81GB    881:   return string(t[0:w])
         .          .    882:}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从源码发现首先创建了一个 &lt;code&gt;buffer&lt;/code&gt; 来起到缓冲的效果，一次分配足够的内存，这个在之前 &lt;a href=&quot;https://blog.thinkeridea.com/201901/go/slice_de_yi_xie_shi_yong_ji_qiao.html&quot;&gt;【Go】slice的一些使用技巧&lt;/a&gt; 里面有讲到，另外一个是 &lt;code&gt;string(t[0:w])&lt;/code&gt; 类型转换带来的内存拷贝，&lt;code&gt;buffer&lt;/code&gt; 能够理解，但是类型转换这个不能忍，就像凭空多出来的一个数拷贝。&lt;/p&gt;
&lt;p&gt;既然类型转换这里有点浪费空间，有没有办法可以零成本转换呢，那就使用 &lt;a href=&quot;https://github.com/thinkeridea/go-extend/blob/master/exbytes/convert.go&quot;&gt;go-extend&lt;/a&gt; 这个包里面的 &lt;code&gt;exbytes.ToString&lt;/code&gt; 方法把 &lt;code&gt;[]byte&lt;/code&gt; 转换成 &lt;code&gt;string&lt;/code&gt;，这个函数可以零分配转换 &lt;code&gt;[]byte&lt;/code&gt; 到 &lt;code&gt;string&lt;/code&gt;。 &lt;code&gt;t&lt;/code&gt; 是一个临时变量，可以安全的被引用不用担心，一个小技巧节省一倍的内存分配，但是这样真的就够了吗？&lt;/p&gt;
&lt;p&gt;我记得 &lt;code&gt;bytes&lt;/code&gt; 标准库里面也有一个 &lt;code&gt;bytes.Replace&lt;/code&gt; 方法，如果直接使用这种方法呢就不用重写一个 &lt;code&gt;strings.Replace&lt;/code&gt;了，使用 &lt;a href=&quot;https://github.com/thinkeridea/go-extend/&quot;&gt;go-extend&lt;/a&gt; 里面的两个魔术方法可以一行代码搞定上面的优化效果 &lt;code&gt;s = exbytes.ToString(bytes.Replace(exstrings.UnsafeToBytes(s), []byte{' '}, []byte{''}, -1))&lt;/code&gt;， 虽然是一行代码搞定的，但是有点长，&lt;code&gt;exstrings.UnsafeToBytes&lt;/code&gt; 方法可以极小的代价把 &lt;code&gt;string&lt;/code&gt; 转成 &lt;code&gt;bytes&lt;/code&gt;， 但是 &lt;code&gt;s&lt;/code&gt; 不能是标量或常量字符串，必须是运行时产生的字符串否者可能导致程序奔溃。&lt;/p&gt;
&lt;p&gt;这样确实减少了一倍的内存分配，即使只有 &lt;code&gt;47.46GB&lt;/code&gt; 的分配也足以排到前十了，不满意这个结果，分析代码看看能不能更进一步减少内存分配吧。&lt;/p&gt;
&lt;h2 id=&quot;分析代码&quot;&gt;分析代码&lt;/h2&gt;
&lt;p&gt;使用火焰图看看究竟什么函数在调用 &lt;code&gt;strings.Replace&lt;/code&gt; 呢：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1572234/201902/1572234-20190203131457908-1962895209.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里主要是两个方法在使用，当然我记得还有几个地方有使用，看来不在火焰图中应该影响比较低 ，看一下代码吧（简化的代码不一定完全合理）：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;// 第一部分
func (v2 *v2Adapter) parse(s string) (*AdRequest, error) {
    s = strings.Replace(s, &quot; &quot;, &quot;&quot;, -1)
    requestJSON, err := v2.paramCrypto.Decrypt([]byte(s))
    if err != nil {
        return nil, err
    }

    request := v2.getDefaultAdRequest()
    if err := request.UnmarshalJSON(requestJSON); err != nil {
        return nil, err
    }
    return request, nil
}

// 第二部分
func (v3 *v3Adapter) parseEncrypt(s []byte) ([]byte, error) {
    ss := strings.Replace(string(s), &quot; &quot;, &quot;&quot;, -1)
    requestJSON, err := v3.paramCrypto.Decrypt([]byte(ss))
    if err != nil {
        return nil, error
    }

    return requestJSON, nil
}

// 通过搜索找到的第三部分
type LogItems []string

func LogItemsToBytes(items []string, sep, newline string) []byte {
    for i := range items {
        items[i] = strings.Replace(items[i], sep, &quot; &quot;, -1)
    }
    str := strings.Replace(strings.Join(items, sep), newline, &quot; &quot;, -1)

    return []byte(str + newline)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过分析我们发现前两个主要是为了删除一个字符串，第三个是为了把一个字符串替换为另一个字符串，并且源数据的生命周期很短暂，在执行替换之后就不再使用了，能不能原地替换字符串呢，原地替换的就会变成零分配了，尝试一下吧。&lt;/p&gt;
&lt;h2 id=&quot;优化&quot;&gt;优化&lt;/h2&gt;
&lt;p&gt;先写一个函数简单实现原地替换，输入的 &lt;code&gt;len(old) &amp;lt; len(new)&lt;/code&gt; 就直接调用 &lt;code&gt;bytes.Replace&lt;/code&gt; 来实现就好了 。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func Replace(s, old, new []byte, n int) []byte {
    if n == 0 {
        return s
    }

    if len(old) &amp;lt; len(new) {
        return bytes.Replace(s, old, new, n)
    }

    if n &amp;lt; 0 {
        n = len(s)
    }

    var wid, i, j int
    for i, j = 0, 0; i &amp;lt; len(s) &amp;amp;&amp;amp; j &amp;lt; n; j++ {
        wid = bytes.Index(s[i:], old)
        if wid &amp;lt; 0 {
            break
        }

        i += wid
        i += copy(s[i:], new)
        s = append(s[:i], s[i+len(old)-len(new):]...)
    }

    return s
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;写个性能测试看一下效果：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ go test -bench=&quot;.&quot; -run=nil -benchmem
goos: darwin
goarch: amd64
pkg: github.com/thinkeridea/go-extend/exbytes/benchmark
BenchmarkReplace-8                    500000          3139 ns/op         416 B/op          1 allocs/op
BenchmarkBytesReplace-8              1000000          2032 ns/op         736 B/op          2 allocs/op&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用这个新的函数和 &lt;code&gt;bytes.Replace&lt;/code&gt; 对比，内存分配是少了，但是性能却下降了那么多，崩溃.... 啥情况呢，对比 &lt;code&gt;bytes.Replace&lt;/code&gt; 的源码发现我这个代码里面 &lt;code&gt;s = append(s[:i], s[i+len(old)-len(new):]...)&lt;/code&gt; 每次都会移动剩余的数据导致性能差异很大，可以使用 &lt;code&gt;go test -bench=&quot;.&quot; -run=nil -benchmem -cpuprofile cpu.out -memprofile mem.out&lt;/code&gt; 的方式来生成 &lt;code&gt;pprof&lt;/code&gt; 数据，然后分析具体有问题的地方。&lt;/p&gt;
&lt;p&gt;找到问题就好了，移动 &lt;code&gt;wid&lt;/code&gt; 之前的数据，这样每次移动就很少了，和 &lt;code&gt;bytes.Replace&lt;/code&gt; 的原理类似。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func Replace(s, old, new []byte, n int) []byte {
    if n == 0 {
        return s
    }

    if len(old) &amp;lt; len(new) {
        return bytes.Replace(s, old, new, n)
    }

    if n &amp;lt; 0 {
        n = len(s)
    }

    var wid, i, j, w int
    for i, j = 0, 0; i &amp;lt; len(s) &amp;amp;&amp;amp; j &amp;lt; n; j++ {
        wid = bytes.Index(s[i:], old)
        if wid &amp;lt; 0 {
            break
        }

        w += copy(s[w:], s[i:i+wid])
        w += copy(s[w:], new)
        i += wid + len(old)
    }

    w += copy(s[w:], s[i:])
    return s[0:w]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在运行一下性能测试吧：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ go test -bench=&quot;.&quot; -run=nil -benchmem
goos: darwin
goarch: amd64
pkg: github.com/thinkeridea/go-extend/exbytes/benchmark
BenchmarkReplace-8                   1000000          2149 ns/op         416 B/op          1 allocs/op
BenchmarkBytesReplace-8              1000000          2231 ns/op         736 B/op          2 allocs/op&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行性能差不多，而且更好了，内存分配也减少，不是说是零分配吗，为啥有一次分配呢？&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;var replaces string
var replaceb []byte

func init() {
    replaces = strings.Repeat(&quot;A BC&quot;, 100)
    replaceb = bytes.Repeat([]byte(&quot;A BC&quot;), 100)
}

func BenchmarkReplace(b *testing.B) {
    for i := 0; i &amp;lt; b.N; i++ {
        exbytes.Replace([]byte(replaces), []byte(&quot; &quot;), []byte(&quot;&quot;), -1)
    }
}

func BenchmarkBytesReplace(b *testing.B) {
    for i := 0; i &amp;lt; b.N; i++ {
        bytes.Replace([]byte(replaces), []byte(&quot; &quot;), []byte(&quot;&quot;), -1)
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到使用了 &lt;code&gt;[]byte(replaces)&lt;/code&gt; 做了一次类型转换，因为优化的这个函数是原地替换，执行过一次之后后面就发现不用替换了，所以为了公平公正两个方法每次都转换一个类型产生一个新的内存地址，所以实际优化后是没有内存分配了。&lt;/p&gt;
&lt;p&gt;之前说写一个优化 &lt;code&gt;strings.Replace&lt;/code&gt; 函数，减少一次内存分配，这里也写一个这样函数，然后增加两个性能测试函数，对比一下效率 &lt;a href=&quot;https://github.com/thinkeridea/go-extend/blob/master/exbytes/benchmark/bytes_test.go&quot;&gt;性能测试代码&lt;/a&gt;：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ go test -bench=&quot;.&quot; -run=nil -benchmem
goos: darwin
goarch: amd64
pkg: github.com/thinkeridea/go-extend/exbytes/benchmark
BenchmarkReplace-8                   1000000          2149 ns/op         416 B/op          1 allocs/op
BenchmarkBytesReplace-8              1000000          2231 ns/op         736 B/op          2 allocs/op
BenchmarkStringsReplace-8            1000000          2260 ns/op        1056 B/op          3 allocs/op
BenchmarkUnsafeStringsReplace-8      1000000          2522 ns/op         736 B/op          2 allocs/op
PASS
ok      github.com/thinkeridea/go-extend/exbytes/benchmark  10.260s&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行效率上都相当，优化之后的 &lt;code&gt;UnsafeStringsReplace&lt;/code&gt; 函数减少了一次内存分配只有一次，和 &lt;code&gt;bytes.Replace&lt;/code&gt; 相当。&lt;/p&gt;
&lt;h2 id=&quot;修改代码&quot;&gt;修改代码&lt;/h2&gt;
&lt;p&gt;有了优化版的 &lt;code&gt;Replace&lt;/code&gt; 函数就替换到项目中吧：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;// 第一部分
func (v2 *v2Adapter) parse(s string) (*AdRequest, error) {
    b := exbytes.Replace(exstrings.UnsafeToBytes(s), []byte(&quot; &quot;), []byte(&quot;&quot;), -1)
    requestJSON, err := v2.paramCrypto.Decrypt(b)
    if err != nil {
        return nil, err
    }
    request := v2.getDefaultAdRequest()
    if err := request.UnmarshalJSON(requestJSON); err != nil {
        return nil, err
    }

    return request, nil
}

// 第二部分
func (v3 *v3Adapter) parseEncrypt(s []byte) ([]byte, error) {
    s = exbytes.Replace(s, []byte(&quot; &quot;), []byte(&quot;&quot;), -1)
    requestJSON, err := v3.paramCrypto.Decrypt(s)
    if err != nil {
        return nil, err
    }

    return requestJSON, nil
}

// 第三部分
type LogItems []string

func LogItemsToBytes(items []string, sep, newline string) []byte {
    for i := range items {
        items[i] = exbytes.ToString(exbytes.Replace(exstrings.UnsafeToBytes(items[i]), []byte(sep), []byte(&quot; &quot;), -1))
    }
    b := exbytes.Replace(exstrings.UnsafeToBytes(strings.Join(items, sep)), []byte(newline), []byte(&quot; &quot;), -1)
    return append(b, newline...)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;上线后性能分析&quot;&gt;上线后性能分析&lt;/h2&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ go tool pprof allocs2
File: xx
Type: alloc_space
Time: Feb 2, 2019 at 5:33pm (CST)
Entering interactive mode (type &quot;help&quot; for commands, &quot;o&quot; for options)
(pprof) top exbytes.Replace
Focus expression matched no samples
Active filters:
   focus=exbytes.Replace
Showing nodes accounting for 0, 0% of 864.21GB total
      flat  flat%   sum%        cum   cum%
(pprof)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;居然在 &lt;code&gt;allocs&lt;/code&gt; 上居然找不到了，确实是零分配。&lt;/p&gt;
&lt;p&gt;优化前 &lt;code&gt;profile&lt;/code&gt; ：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ go tool pprof profile
File: xx
Type: cpu
Time: Feb 1, 2019 at 9:54pm (CST)
Duration: 30.08s, Total samples = 12.23s (40.65%)
Entering interactive mode (type &quot;help&quot; for commands, &quot;o&quot; for options)
(pprof) top strings.Replace
Active filters:
   focus=strings.Replace
Showing nodes accounting for 0.08s, 0.65% of 12.23s total
Showing top 10 nodes out of 27
      flat  flat%   sum%        cum   cum%
     0.03s  0.25%  0.25%      0.08s  0.65%  strings.Replace
     0.02s  0.16%  0.41%      0.02s  0.16%  countbody
     0.01s 0.082%  0.49%      0.01s 0.082%  indexbytebody
     0.01s 0.082%  0.57%      0.01s 0.082%  memeqbody
     0.01s 0.082%  0.65%      0.01s 0.082%  runtime.scanobject&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;优化后 &lt;code&gt;profile&lt;/code&gt; ：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ go tool pprof profile2
File: xx
Type: cpu
Time: Feb 2, 2019 at 5:33pm (CST)
Duration: 30.16s, Total samples = 14.68s (48.68%)
Entering interactive mode (type &quot;help&quot; for commands, &quot;o&quot; for options)
(pprof) top exbytes.Replace
Active filters:
   focus=exbytes.Replace
Showing nodes accounting for 0.06s, 0.41% of 14.68s total
Showing top 10 nodes out of 18
      flat  flat%   sum%        cum   cum%
     0.03s   0.2%   0.2%      0.03s   0.2%  indexbytebody
     0.02s  0.14%  0.34%      0.05s  0.34%  bytes.Index
     0.01s 0.068%  0.41%      0.06s  0.41%  github.com/thinkeridea/go-extend/exbytes.Replace&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过 &lt;code&gt;profile&lt;/code&gt; 来分配发现性能也有一定的提升，本次 &lt;code&gt;strings.Replace&lt;/code&gt; 和 &lt;code&gt;bytes.Replace&lt;/code&gt; 优化圆满结束。&lt;/p&gt;
&lt;p&gt;本博文中使用函数均在 &lt;a href=&quot;https://github.com/thinkeridea/go-extend&quot;&gt;go-extend&lt;/a&gt; 中，优化后的函数在 &lt;a href=&quot;https://github.com/thinkeridea/go-extend/blob/master/exbytes/bytes.go&quot;&gt;exbytes.Replace&lt;/a&gt; 中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;转载：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文作者： 戚银（&lt;a href=&quot;https://blog.thinkeridea.com/&quot;&gt;thinkeridea&lt;/a&gt;）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文链接： &lt;a href=&quot;https://blog.thinkeridea.com/201902/go/replcae_you_hua.html&quot; class=&quot;uri&quot;&gt;https://blog.thinkeridea.com/201902/go/replcae_you_hua.html&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;版权声明： 本博客所有文章除特别声明外，均采用 &lt;a href=&quot;http://creativecommons.org/licenses/by/4.0/deed.zh&quot;&gt;CC BY 4.0 CN协议&lt;/a&gt; 许可协议。转载请注明出处！&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 03 Feb 2019 05:16:00 +0000</pubDate>
<dc:creator>戚银</dc:creator>
<og:description>原文链接：https://blog.thinkeridea.com/201902/go/replcae_you_hua.html 标准库中函数大多数情况下更通用，性能并非最好的，还是不能过于迷信标准库</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/thinkeridea/p/10350228.html</dc:identifier>
</item>
<item>
<title>[开源] .NET数据库ORM类库 Insql - rainrcn</title>
<link>http://www.cnblogs.com/rainrcn/p/10350163.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rainrcn/p/10350163.html</guid>
<description>&lt;p&gt;新年之初，给大家介绍个我自己开发的ORM类库Insql。TA是一个轻量级的.NET ORM类库 . 对象映射基于Dapper , Sql配置灵感来自于Mybatis。简单优雅性能是TA的追求。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/rainrcn/insql&quot;&gt;github&lt;/a&gt; | &lt;a href=&quot;https://gitee.com/rainrcn/insql&quot;&gt;gitee&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;以下可跳过 : )&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;自己为什么会开发Insql?&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;最初的自己一样是从写最基本的Sql代码来访问数据库&lt;br/&gt;进而我们发现查询出的数据与保存的数据通常都是实体对象，而还需要跨不同类型数据库的需要。&lt;/li&gt;
&lt;li&gt;这时ORM就成为了我们的工具。在使用ORM和Linq的出现让我迫切希望找到一款好用的支持Linq的ORM框架。这个过程中使用了微软的EntityFramework，还有各种同僚自己开发的ORM，有很多不错的作品。自己也用了很多。当然在这里面我的评判标准就是性能优先，无需中间缓存层。操作能以最直接的方式直达数据库。在Linq的支持上当然也需要丰富些。&lt;/li&gt;
&lt;li&gt;我以为这就是我的归宿，可是Linq只能解决不同类型数据库的共性问题，有些ORM很难做到充分利用各个数据库的特性，例如独特的类型和独特的方法。当然不要告诉我自己遇到那种问题时再写原生SQL.我尽可能希望我使用工具时简单统一，不要有负担存在。&lt;/li&gt;
&lt;li&gt;直到我开发Java项目时，遇到了Mybatis。可以说真的很好用。它以XML配置SQL的方式，自己可以自由灵活的写语句，当然数据库的独有方法特性都能使用。但是在dotnet core上我没有找到类似好用的组件。于是就有了Insql。&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;如何设计Insql?&lt;/strong&gt;&lt;br/&gt;整体功能架构就以下两块&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;&lt;strong&gt;语句解析&lt;/strong&gt;&lt;br/&gt;首先先加载xxx.insql.xml配置，加载方式支持扩展，目前实现以程序集嵌入式文件方式加载。&lt;br/&gt;解析各种配置节点元素，最终生成可直接执行的sql语句和sql参数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;对象映射&lt;/strong&gt;&lt;br/&gt;在保存和查询时都需要实体对象的参与，这里对象映射就提供类这个功能。目前也有很多对象映射类库，我们这里直接使用Dapper。轮子就不重复造了。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;安装&quot;&gt;安装&lt;/h2&gt;
&lt;h2 id=&quot;如何使用&quot;&gt;如何使用&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Add Insql&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public void ConfigureServices(IServiceCollection services)
{
    services.AddInsql();

    services.AddInsqlDbContext&amp;lt;UserDbContext&amp;gt;(options =&amp;gt;
    {
        options.UseSqlite(this.Configuration.GetConnectionString(&quot;sqlite&quot;));
    });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Create DbContext&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class UserDbContext : Insql.DbContext  
{
    public UserDbContext(Insql.DbContextOptions&amp;lt;UserDbContext&amp;gt; options) 
        : base(options)
    {
    }

    public IEnumerable&amp;lt;UserInfo&amp;gt; GetUserList(string userName)
    {
        //sqlId = &quot;GetUserList&quot;
        //sqlParam is PlainObject or IDictionary&amp;lt;string,object&amp;gt;
        return this.Query&amp;lt;UserInfo&amp;gt;(nameof(GetUserList), new { userName, userGender = Gender.W });
    }

    public void InsertUser(UserInfo info)
    {
        var userId = this.ExecuteScalar&amp;lt;int&amp;gt;(nameof(InsertUser),info);

        info.UserId = userId;
    }

    public void UpdateUserSelective(UserInfo info)
    {
        this.Execute(nameof(UpdateUserSelective), info);
    }
}

//user model
public class UserInfo
{
    public int UserId { get; set; }

    public string UserName { get; set; }

    public Gender? UserGender { get; set; }
}

public enum Gender
{
    M,
    W
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Create DbContext.insql.xml&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;创建 &lt;code&gt;UserDbContext.insql.xml&lt;/code&gt; 文件并且修改这个文件的属性为&lt;code&gt;嵌入式文件&lt;/code&gt;类型 . &lt;code&gt;insql type&lt;/code&gt; 与 &lt;code&gt;UserDbContext&lt;/code&gt; 类型对应.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;insql type=&quot;Example.Domain.Contexts.UserDbContext,Example.Domain&quot; &amp;gt;

  &amp;lt;sql id=&quot;selectUserColumns&quot;&amp;gt;
    select user_id as UserId,user_name as UserName,user_gender as UserGender from user_info
  &amp;lt;/sql&amp;gt;

  &amp;lt;select id=&quot;GetUserList&quot;&amp;gt;
    &amp;lt;include refid=&quot;selectUserColumns&quot; /&amp;gt;
    &amp;lt;where&amp;gt;
      &amp;lt;if test=&quot;userName != null&quot;&amp;gt;
        &amp;lt;bind name=&quot;likeUserName&quot; value=&quot;'%' + userName + '%'&quot; /&amp;gt;
        user_name like @likeUserName
      &amp;lt;/if&amp;gt;
      &amp;lt;if test=&quot;userGender != null and userGender != 'M' &quot;&amp;gt;
        and user_gender = @userGender
      &amp;lt;/if&amp;gt;
    &amp;lt;/where&amp;gt;
    order by  user_id
  &amp;lt;/select&amp;gt;

  &amp;lt;insert id=&quot;InsertUser&quot;&amp;gt;
    insert into user_info (user_name,user_gender) values (@UserName,@UserGender);
    select last_insert_rowid() from user_info;
  &amp;lt;/insert&amp;gt;
  &amp;lt;update id=&quot;UpdateUser&quot;&amp;gt;
    update user_info set user_name=@UserName,user_gender=@UserGender where user_id = @userId
  &amp;lt;/update&amp;gt;

  &amp;lt;update id=&quot;UpdateUserSelective&quot;&amp;gt;
    update user_info
    &amp;lt;set&amp;gt;
      &amp;lt;if test=&quot;UserName != null&quot;&amp;gt;
        user_name=@UserName,
      &amp;lt;/if&amp;gt;
      &amp;lt;if test=&quot;UserGender != null&quot;&amp;gt;
        user_gender=@UserGender
      &amp;lt;/if&amp;gt;
    &amp;lt;/set&amp;gt;
    where user_id = @UserId
  &amp;lt;/update&amp;gt;

&amp;lt;/insql&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Use DbContext&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class ValuesController : ControllerBase
{
    private readonly UserDbContext userDbContext;

    public ValuesController(UserDbContext userDbContext)
    {
        this.userDbContext = userDbContext;
    }

    [HttpGet]
    public ActionResult&amp;lt;IEnumerable&amp;lt;string&amp;gt;&amp;gt; Get()
    {
        //可以这样简单的使用事务
        this.userDbContext.DoWithTransaction(() =&amp;gt;
        {
            this.userDbContext.InsertUser(new Domain.UserInfo
            {
                UserName = &quot;loveW&quot;,
                UserGender = Domain.Gender.M
            });

            this.userDbContext.UpdateUserSelective(new Domain.UserInfo
            {
                UserId = 1,
                UserName = &quot;loveWWW&quot;,
            });
        });

        var list = this.userDbContext.GetUserList(&quot;love&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;其他用法&quot;&gt;其他用法&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Create Common DbContext&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class SqliteDbContext&amp;lt;T&amp;gt; : DbContext where T : class
{
    public SqliteDbContext(DbContextOptions&amp;lt;SqliteDbContext&amp;lt;T&amp;gt;&amp;gt; options) : base(options)
    {
    }

    protected override void OnConfiguring(DbContextOptions options)
    {
        var configuration = options.ServiceProvider.GetRequiredService&amp;lt;IConfiguration&amp;gt;();

        //T type mapping to insql.xml type
        options.UseSqlResolver&amp;lt;T&amp;gt;();

        options.UseSqlite(configuration.GetConnectionString(&quot;sqlite&quot;));
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Create Domain Service&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public interface IUserService
{
    IEnumerable&amp;lt;UserInfo&amp;gt; GetUserList(string userName,Gender? userGender);
}

public class UserService : IUserService
{
    private readonly DbContext dbContext;

    //T is UserService
    public UserService(SqliteDbContext&amp;lt;UserService&amp;gt; dbContext)
    {
        this.dbContext = dbContext;
    }

    public IEnumerable&amp;lt;UserInfo&amp;gt; GetUserList(string userName, Gender? userGender)
    {
        return this.dbContext.Query&amp;lt;UserInfo&amp;gt;(nameof(GetUserList), new { userName, userGender });
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Create Service.insql.xml&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;创建 &lt;code&gt;UserService.insql.xml&lt;/code&gt; 文件并且修改这个文件的属性为&lt;code&gt;嵌入式文件&lt;/code&gt;类型 . &lt;code&gt;insql type&lt;/code&gt; 与 &lt;code&gt;UserService&lt;/code&gt; 类型对应.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;insql type=&quot;Example.Domain.Services.UserService,Example.Domain&quot; &amp;gt;

  &amp;lt;sql id=&quot;selectUserColumns&quot;&amp;gt;
    select user_id as UserId,user_name as UserName,user_gender as UserGender from user_info
  &amp;lt;/sql&amp;gt;

  &amp;lt;select id=&quot;GetUserList&quot;&amp;gt;
    &amp;lt;include refid=&quot;selectUserColumns&quot; /&amp;gt;
    &amp;lt;where&amp;gt;
      &amp;lt;if test=&quot;userName != null&quot;&amp;gt;
        &amp;lt;bind name=&quot;likeUserName&quot; value=&quot;'%' + userName + '%'&quot; /&amp;gt;
        user_name like @likeUserName
      &amp;lt;/if&amp;gt;
      &amp;lt;if test=&quot;userGender != null &quot;&amp;gt;
        and user_gender = @userGender
      &amp;lt;/if&amp;gt;
    &amp;lt;/where&amp;gt;
    order by  user_id
  &amp;lt;/select&amp;gt;

&amp;lt;/insql&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Add Insql&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public void ConfigureServices(IServiceCollection services)
{
    services.AddInsql();

    services.AddScoped(typeof(DbContextOptions&amp;lt;&amp;gt;));
    services.AddScoped(typeof(SqliteDbContext&amp;lt;&amp;gt;));

    services.AddScoped&amp;lt;IUserService, UserService&amp;gt;();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Use Domain Service&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class ValuesController : ControllerBase
{
    private readonly IUserService userService;

    public ValuesController(IUserService userService)
    {
        this.userService = userService;
    }

    [HttpGet]
    public ActionResult&amp;lt;IEnumerable&amp;lt;string&amp;gt;&amp;gt; Get()
    {
        var list = this.userService.GetUserList(&quot;11&quot;, Domain.Gender.M);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;@谢谢大家支持！&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 03 Feb 2019 05:13:00 +0000</pubDate>
<dc:creator>rainrcn</dc:creator>
<og:description>介绍 新年之初，给大家介绍个我自己开发的ORM类库Insql。TA是一个轻量级的.NET ORM类库 . 对象映射基于Dapper , Sql配置灵感来自于Mybatis。简单优雅性能是TA的追求。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/rainrcn/p/10350163.html</dc:identifier>
</item>
<item>
<title>Lambda in Java VS in C# - 李新杰</title>
<link>http://www.cnblogs.com/lixinjie/p/lambda-in-java-vs-in-csharp.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lixinjie/p/lambda-in-java-vs-in-csharp.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;核心+变化&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;“凡是钱能解决的问题，就不是大问题。有很多问题是钱无法解决的，比如生老病死，比如不再相爱。”，看过《蜗居》的朋友一眼就能认出来。虽然这部电视剧讲的是chugui，但是毫无违和感，我当时都看出来真感情了。&lt;/p&gt;&lt;p&gt;海藻和宋思明虽然是因借钱开始的，但是后面的发展却远远超出了它。这里面钱是问题的核心，后面发生的事情都是围绕着核心的变化。&lt;/p&gt;&lt;p&gt;社会是一张庞大而复杂的网，有节点和连线组成。节点就是人，连线就是人际关系。这里面人是核心，人际关系是围绕着核心的变化。&lt;/p&gt;&lt;p&gt;那到底是核心影响变化呢，还是变化影响核心呢，还是二者皆而有之呢？不管怎样，请记住都是：核心+变化。&lt;/p&gt;&lt;p&gt;如果把核心看作是数据，那变化就是行为。如果把核心看作是字段，那变化就是方法。&lt;/p&gt;&lt;p&gt;哎呀，终于回到了编程上，差点没绕回来。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;那些年，我的专业课老师&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;“好了，我们这本书已经讲完了”。老师，明明后面还有一半呢，怎么就讲完了呢？“后面那是指针，给你们讲了你们也不懂”。&lt;/p&gt;&lt;p&gt;都看看，这可是我计算机生涯的第一门语言，C语言呀，碰上这样的老师，“不仅侮辱了我们的人格，还侮辱了我们的智商”。所以我今天取得的“成就”都是我自己努力得来的。&lt;/p&gt;&lt;p&gt;哈哈，开个玩笑，不管怎样，还是要感谢老师带我“上道”的。其它老师的“名言”，后续再分享。&lt;/p&gt;&lt;p&gt;有句话怎么讲，“明知山有虎、偏向虎山行”，就是不信这个邪了，我倒要看看指针有多难。&lt;/p&gt;&lt;p&gt;事实证明，很多事情因人而异。好多人都说指针很难，但是我从一开始学习指针，直到现在，从来没觉得它难。&lt;/p&gt;&lt;p&gt;指针只不过是在变量的基础上又往前走了一步。变量对应的是数据本身，指针对应的是数据的地址。所以从指针获取数据需要执行一步解引用，即星号（*）操作符。&lt;/p&gt;&lt;p&gt;不过变量类型很多，所以指针的类型也很多，还有指向指针的指针，因此指针在写法上比较繁琐，不容易记住，但并不难理解。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;C语言中的函数指针&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;人们对带“美”字的东西都比较感兴趣。如美景、美食、美酒、美元、美女等。当然也有讨厌的，如美国。&lt;/p&gt;&lt;p&gt;来个美食吧。鱼类绝对算一个，特别是深海鱼。无污染，低脂肪，高蛋白，维生素，不饱和脂肪酸，而且肉质嫩滑，味道鲜美。关键还符合我国的传统文化，年年有鱼啊。&lt;/p&gt;&lt;p&gt;岛国喜欢做成生鱼片或寿司。我国的花样就多了，红烧鱼，清蒸鱼，水煮鱼，麻辣鱼，剁椒鱼，酸菜鱼，蕃茄鱼，烤鱼等等。&lt;/p&gt;&lt;p&gt;那么问题来了，如何用C语言实现这么多的做鱼呢？&lt;/p&gt;&lt;p&gt;首先从生活入手，厨房 + 厨师 + 生鱼 = 熟鱼。假设每个厨师只会做一种鱼。用伪代码表示：&lt;br/&gt;&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;&lt;span&gt;CookedFish &lt;span&gt;kitchen&lt;/span&gt;&lt;span&gt;(UncookedFish, CookWay)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (CookWay == &lt;span&gt;&quot;生鱼片&quot;&lt;/span&gt;) {&lt;br/&gt;&lt;span&gt;//厨师A做生鱼片&lt;/span&gt;&lt;br/&gt;} &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (CookWay == &lt;span&gt;&quot;红烧鱼&quot;&lt;/span&gt;) {&lt;br/&gt;&lt;span&gt;//厨师B做红烧鱼&lt;/span&gt;&lt;br/&gt;} &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (CookWay == &lt;span&gt;&quot;酸菜鱼&quot;&lt;/span&gt;) {&lt;br/&gt;&lt;span&gt;//厨师C做酸菜鱼&lt;/span&gt;&lt;br/&gt;}...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;span&gt;这个方法看起来很臃肿，因为它把所有的做鱼方法都放进来了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;就像所有的厨师都在厨房里候着，然后进来一条生鱼，并告知要做成什么样的，对应的厨师起身去做鱼，剩余的厨师仍继续候着。&lt;/p&gt;&lt;p&gt;现实中是厨师都在自己的岗位上，而非厨房里，需要做鱼的时候，厨师和生鱼进厨房即可。&lt;/p&gt;&lt;p&gt;就像这样，厨房（厨师，生鱼）= 熟鱼，用伪代码表示：&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;&lt;span&gt;CookedFish &lt;span&gt;kitchen&lt;/span&gt;&lt;span&gt;(Cooker*, UncookedFish)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span&gt;//厨师做鱼&lt;/span&gt;&lt;br/&gt;Cooker(UncookedFish);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;span&gt;这里已经不需要CookWay了，因为一个厨师只会做一种鱼，从厨师就可以知道鱼的做法了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;这里面的核心是鱼，围绕核心的变化是厨师。如果鱼是字段，那厨师就是方法了。&lt;/p&gt;&lt;p&gt;第一种方法之所以繁琐，是因为我们只把字段传进来了，方法全部在“厨房”里。其实即使厨房里有再多的方法，一次也只能用一个。&lt;/p&gt;&lt;p&gt;为了简洁和更加符合实际，我们除了把字段传进来之外，也把方法传进来了。即，既把鱼传进来，也把厨师传经来。这样厨房里只有一个厨师在工作，就清爽多了。&lt;/p&gt;&lt;p&gt;我们可以看到，除了数据（鱼）可以当作参数传递外，行为（厨师）也可以当作参数传递。&lt;/p&gt;&lt;p&gt;C语言不是OO的，没有对象的概念，也没有方法的概念，只有函数，一段可执行的代码就是函数。&lt;/p&gt;&lt;p&gt;为了传递函数，需要用到函数指针，Cooker*就是函数指针，它指向的就是一个代码片段。&lt;/p&gt;&lt;p&gt;函数指针代表的是函数签名，即某一类函数。&lt;/p&gt;&lt;p&gt;如void (*fp)();这里的fp就是函数指针，它表示所有没有入参也没有返回值的这类函数。&lt;/p&gt;&lt;p&gt;如下：&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;&lt;span&gt;//函数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;foo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{...};&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;bar&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{...};&lt;br/&gt;&lt;span&gt;//把函数赋给函数指针&lt;/span&gt;&lt;br/&gt;fp = &amp;amp;foo;&lt;br/&gt;fp = &amp;amp;bar;&lt;br/&gt;&lt;span&gt;//通过指针调用函数&lt;/span&gt;&lt;br/&gt;(*fp)();&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;span&gt;再看一个例子：&lt;/span&gt;&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;&lt;span&gt;//函数指针&lt;/span&gt;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; (*fp2)(&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;//加&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;(&lt;span&gt;&lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;int&lt;/span&gt; b&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;&lt;span&gt;return&lt;/span&gt; a + b;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;//减&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;sub&lt;/span&gt;(&lt;span&gt;&lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;int&lt;/span&gt; b&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;&lt;span&gt;return&lt;/span&gt; a + b;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;//乘&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;mul&lt;/span&gt;(&lt;span&gt;&lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;int&lt;/span&gt; b&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;&lt;span&gt;return&lt;/span&gt; a + b;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;//除&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;div&lt;/span&gt;(&lt;span&gt;&lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;int&lt;/span&gt; b&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;&lt;span&gt;return&lt;/span&gt; a + b;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;//函数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;op2&lt;/span&gt;(&lt;span&gt;&lt;span&gt;int&lt;/span&gt; (*fp2&lt;/span&gt;)(&lt;span&gt;&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;&lt;/span&gt;), &lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;int&lt;/span&gt; b) &lt;/span&gt;{&lt;br/&gt;&lt;span&gt;return&lt;/span&gt; fp2(a, b);&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;//调用，把函数当作参数传入&lt;/span&gt;&lt;br/&gt;op2(&lt;span&gt;add&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;) == &lt;span&gt;3&lt;/span&gt;;&lt;br/&gt;op2(sub, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;) == &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;op2(mul, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;) == &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;op2(div, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;) == &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;span&gt;看不懂函数指针没关系，后面还有C#和Java代码。&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;C#中的Lambda表达式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;初次接触lambda表达式就是在C#中，已是很多年前的事了。C#确实从C和C++中继承了很多特性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;在C#中应该也支持指针，但是不推荐使用。为了完成C语言中函数指针这种功能，C#提供了类型安全的“函数指针”，就是委托。&lt;/p&gt;&lt;p&gt;委托的关键字是delegate，它的用法如下：&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;delegate&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;FB&lt;/span&gt;(&lt;span&gt;&lt;span&gt;int&lt;/span&gt; a&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;span&gt;委托表示的是方法签名，即一类方法。此处定义的委托类型是FB，它表示所有入参为一个整型且没有返回值的方法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;所以可以把方法赋值给委托，自然可以调用委托，如下：&lt;/p&gt;

&lt;pre readability=&quot;5.5&quot;&gt;
&lt;code readability=&quot;5&quot;&gt;&lt;span&gt;//一个整型入参，无返回值&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;Foo&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; a)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;Console.WriteLine(&lt;span&gt;&quot;Foo: &quot;&lt;/span&gt; + a);&lt;br/&gt;}&lt;p&gt;&lt;span&gt;//一个整型入参，无返回值&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;Bar&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; a)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;Console.WriteLine(&lt;span&gt;&quot;Bar: &quot;&lt;/span&gt; + a);&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span&gt;//委托的赋值与调用&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;TestDelegate&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;&lt;span&gt;//把方法赋给委托&lt;/span&gt;&lt;br/&gt;FB fb = &lt;span&gt;this&lt;/span&gt;.Foo;&lt;br/&gt;&lt;span&gt;//调用委托&lt;/span&gt;&lt;br/&gt;fb(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;//把方法赋给委托&lt;/span&gt;&lt;br/&gt;fb = &lt;span&gt;this&lt;/span&gt;.Bar;&lt;br/&gt;&lt;span&gt;//调用委托&lt;/span&gt;&lt;br/&gt;fb(&lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;span&gt;委托还可以用作方法的参数，此时就可以把一个方法当作参数传给其它方法。&lt;/span&gt;&lt;/p&gt;

&lt;pre readability=&quot;7&quot;&gt;
&lt;code readability=&quot;8&quot;&gt;&lt;span&gt;//第一个参数FB就是委托&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;TestDelegate&lt;/span&gt;&lt;span&gt;(FB fb, &lt;span&gt;int&lt;/span&gt; a)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;fb(a);&lt;br/&gt;}&lt;p&gt;&lt;span&gt;//下面是对这个方法的调用&lt;/span&gt;&lt;br/&gt;Program p = &lt;span&gt;new&lt;/span&gt; Program();&lt;/p&gt;&lt;p&gt;&lt;span&gt;//p.Foo是一个方法，可以作为参数传入&lt;/span&gt;&lt;br/&gt;p.TestDelegate(p.Foo, &lt;span&gt;1&lt;/span&gt;);&lt;/p&gt;&lt;p&gt;&lt;span&gt;//p.Bar是一个方法，可以作为参数传入&lt;/span&gt;&lt;br/&gt;p.TestDelegate(p.Bar, &lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;span&gt;lambda表达式本质上就是一段可执行的代码，但是不同语言对它的实现是不同的，在C#中就实现为委托。&lt;/span&gt;&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;public &lt;span&gt;void&lt;/span&gt; TestLambda()&lt;br/&gt;{&lt;br/&gt;&lt;span&gt;//这就是lambda表达式的写法，它被赋值给了委托&lt;/span&gt;&lt;br/&gt;FB fb = &lt;span&gt;(&lt;span&gt;int a&lt;/span&gt;) =&amp;gt;&lt;/span&gt; Console.WriteLine(&lt;span&gt;&quot;lambda 1: &quot;&lt;/span&gt; + a);&lt;br/&gt;fb(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;//lambda表达式&lt;/span&gt;&lt;br/&gt;fb = &lt;span&gt;(&lt;span&gt;a&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;br/&gt;{&lt;br/&gt;　　Console.WriteLine(&lt;span&gt;&quot;lambda 2: &quot;&lt;/span&gt; + a); &lt;br/&gt;};&lt;br/&gt;fb(&lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;span&gt;由于编译器会进行类型推断，所以可以省略参数类型。如果只有一个入参的话，可以省略那个小括号。如果只有一个语句的话，可以不用要大括号。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;lambda表达式作为参数传递：&lt;/p&gt;

&lt;pre readability=&quot;6.5&quot;&gt;
&lt;code readability=&quot;7&quot;&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;TestLambda&lt;/span&gt;&lt;span&gt;(FB fb, &lt;span&gt;int&lt;/span&gt; a)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;fb(a);&lt;br/&gt;}&lt;p&gt;&lt;span&gt;//lambda表达式直接作为参数&lt;/span&gt;&lt;br/&gt;p.TestLambda((&lt;span&gt;int&lt;/span&gt; a) =&amp;gt; Console.WriteLine(&lt;span&gt;&quot;lambda 1: &quot;&lt;/span&gt; + a), &lt;span&gt;1&lt;/span&gt;);&lt;/p&gt;&lt;p&gt;&lt;span&gt;//lambda表达式直接作为参数&lt;/span&gt;&lt;br/&gt;p.TestLambda((a) =&amp;gt; { Console.WriteLine(&lt;span&gt;&quot;lambda 2: &quot;&lt;/span&gt; + a); }, &lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;span&gt;C#中的匿名方法，如下：&lt;/span&gt;&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;TestAnonymousMethod&lt;/span&gt;()&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;&lt;span&gt;//匿名方法可以赋值给委托，用关键字delegate替代方法名&lt;/span&gt;&lt;br/&gt;FB fb = &lt;span&gt;delegate&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; a)&lt;br/&gt;{&lt;br/&gt;　　Console.WriteLine(&lt;span&gt;&quot;anonymous method: &quot;&lt;/span&gt; + a);&lt;br/&gt;};&lt;p&gt;fb(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;fb(&lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;span&gt;匿名方法作为参数传递：&lt;/span&gt;&lt;/p&gt;

&lt;pre readability=&quot;7&quot;&gt;
&lt;code readability=&quot;8&quot;&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;TestAnonymousMethod&lt;/span&gt;(&lt;span&gt;FB fb, &lt;span&gt;int&lt;/span&gt; a&lt;/span&gt;)&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;fb(a);&lt;br/&gt;}&lt;p&gt;&lt;span&gt;//匿名方法直接作为方法参数&lt;/span&gt;&lt;br/&gt;p.TestAnonymousMethod(&lt;span&gt;delegate&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; a) { Console.WriteLine(&lt;span&gt;&quot;anonymous method: &quot;&lt;/span&gt; + a); }, &lt;span&gt;1&lt;/span&gt;);&lt;/p&gt;&lt;p&gt;&lt;span&gt;//匿名方法直接作为方法参数&lt;/span&gt;&lt;br/&gt;p.TestAnonymousMethod(&lt;span&gt;delegate&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; a) { Console.WriteLine(&lt;span&gt;&quot;anonymous method: &quot;&lt;/span&gt; + a); }, &lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;span&gt;总之，C#中的普通方法，lambda表达式，匿名方法，最后都可以赋值给委托进行传递和调用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;看不懂C#没关系，后面还有Java代码。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;Java中的Lambda表达式&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;自从Java换了爸爸后，简直像坐上了火箭。各种其它语言的特性都陆续加进来了。从Java 8开始也可以使用lambda表达式了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;不过说来惭愧，我用的不多，因为它在我的编程生涯中已经不再“稀奇”了，因为之前已经在C#中体验过了。&lt;/p&gt;&lt;p&gt;Java也是从C和C++发展过来的，继承了一些特性，但抛弃的更多。类似函数指针的功能，就被优化没了。&lt;/p&gt;&lt;p&gt;因此在Java语言中，对于行为（可执行代码片段）的传递，无法做到方法级别，只能再往上走一步，做到接口级别或类级别。&lt;/p&gt;&lt;p&gt;也就是说，你想传递一个方法时，必须要传递一个类或对象作为方法的载体才行。这种使用方式其实一直都存在着的。&lt;/p&gt;&lt;p&gt;Java 8中引入一个新的概念叫做函数式接口。它规定这样的接口只能包含一个抽象方法，但可以包含其它带默认实现的任意方法。&lt;/p&gt;&lt;p&gt;函数式接口也可以像普通接口那样使用。只不过会有一些特定功能，毕竟是为了配合Java 8支持函数式编程而特意起的这个名字。&lt;/p&gt;&lt;p&gt;有一个函数式接口叫做Consumer&amp;lt;T&amp;gt;，它只有一个抽象方法是void accept(T t);这个方法接收一个入参但没有返回值。&lt;/p&gt;&lt;p&gt;所以这个函数式接口就代表了这样一类方法，即有一个入参但没有返回值的所有方法。所以函数式接口大致上也可以看作是一类方法的“方法签名”。&lt;/p&gt;&lt;p&gt;定义一个函数式接口变量，表示只有一个入参但没有返回值的这类方法。&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;&lt;span&gt;//函数式接口变量&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; Consumer&amp;lt;Integer&amp;gt; fb;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;span&gt;可以把方法赋值给函数式接口，然后进行调用，如下：&lt;/span&gt;&lt;/p&gt;

&lt;pre readability=&quot;6.5&quot;&gt;
&lt;code readability=&quot;7&quot;&gt;&lt;span&gt;//只有一个入参且没有返回值的方法&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;foo&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; a)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;System.out.println(&lt;span&gt;&quot;foo: &quot;&lt;/span&gt; + a);&lt;br/&gt;}&lt;p&gt;&lt;span&gt;//只有一个入参且没有返回值的方法&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;bar&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; a)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;System.out.println(&lt;span&gt;&quot;bar: &quot;&lt;/span&gt; + a);&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span&gt;//函数式接口的赋值与调用&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;testFunctionalInterface&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span&gt;//把方法赋值给函数式接口变量&lt;/span&gt;&lt;br/&gt;fb = &lt;span&gt;this&lt;/span&gt;::foo;&lt;br/&gt;&lt;span&gt;//调用函数式接口，就是调用赋给它的方法&lt;/span&gt;&lt;br/&gt;fb.accept(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;//把方法赋给函数式接口变量&lt;/span&gt;&lt;br/&gt;fb = &lt;span&gt;this&lt;/span&gt;::bar;&lt;br/&gt;&lt;span&gt;//调用&lt;/span&gt;&lt;br/&gt;fb.accept(&lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;span&gt;注意引用方法时使用了::操作符，这个应该是C++中的写法吧。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;函数式接口作为方法参数：&lt;/p&gt;

&lt;pre readability=&quot;7&quot;&gt;
&lt;code readability=&quot;8&quot;&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;testFunctionalInterface&lt;/span&gt;&lt;span&gt;(Consumer&amp;lt;Integer&amp;gt; fb, &lt;span&gt;int&lt;/span&gt; a)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;fb.accept(a);&lt;br/&gt;}&lt;p&gt;Program p = &lt;span&gt;new&lt;/span&gt; Program();&lt;/p&gt;&lt;p&gt;&lt;span&gt;//把方法作为参数传给其它方法&lt;/span&gt;&lt;br/&gt;p.testFunctionalInterface(p::foo, &lt;span&gt;1&lt;/span&gt;);&lt;/p&gt;&lt;p&gt;&lt;span&gt;//把方法作为参数传给其它方法&lt;/span&gt;&lt;br/&gt;p.testFunctionalInterface(p::bar, &lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;span&gt;毫无悬念，lambda表达式可以赋给函数式接口变量。&lt;/span&gt;&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;testLambda&lt;/span&gt;() &lt;/span&gt;{&lt;br/&gt;&lt;span&gt;//lambda表达式的写法&lt;/span&gt;&lt;br/&gt;fb = (Integer a) -&amp;gt; System.&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;lambda 1: &quot;&lt;/span&gt; + a);&lt;br/&gt;fb.accept(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;//lambda表达式&lt;/span&gt;&lt;br/&gt;fb = (a) -&amp;gt; {&lt;br/&gt;System.&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;lambda 2: &quot;&lt;/span&gt; + a); &lt;br/&gt;};&lt;br/&gt;fb.accept(&lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;span&gt;很显然，没有太多的惊喜。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;lambda表达式作为参数传递：&lt;/p&gt;

&lt;pre readability=&quot;5&quot;&gt;
&lt;code readability=&quot;4&quot;&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;testLambda&lt;/span&gt;(&lt;span&gt;Consumer&amp;lt;Integer&amp;gt; fb, &lt;span&gt;int&lt;/span&gt; a&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;fb.accept(a);&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;//lambda表达式直接作为参数传递&lt;/span&gt;&lt;br/&gt;p.testLambda((Integer a) -&amp;gt; System.&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;lambda 1: &quot;&lt;/span&gt; + a), &lt;span&gt;1&lt;/span&gt;);&lt;p&gt;&lt;span&gt;//lambda表达式直接作为参数传递&lt;/span&gt;&lt;br/&gt;p.testLambda((a) -&amp;gt; { System.&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;lambda 2: &quot;&lt;/span&gt; + a); }, &lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;span&gt;Java中的匿名类：&lt;/span&gt;&lt;/p&gt;

&lt;pre readability=&quot;4&quot;&gt;
&lt;code readability=&quot;2&quot;&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;testAnonymousClass&lt;/span&gt;() &lt;/span&gt;{&lt;br/&gt;&lt;span&gt;//匿名类，函数式接口作为普通接口使用&lt;/span&gt;&lt;br/&gt;fb = &lt;span&gt;new&lt;/span&gt; Consumer&amp;lt;Integer&amp;gt;() {&lt;br/&gt;@&lt;span&gt;Override&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;accept&lt;/span&gt;(&lt;span&gt;Integer a&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;System.&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;anonymous class: &quot;&lt;/span&gt; + a);&lt;br/&gt;}&lt;br/&gt;};&lt;p&gt;fb.accept(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;fb.accept(&lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;span&gt;匿名类作为参数传递：&lt;/span&gt;&lt;/p&gt;

&lt;pre readability=&quot;7&quot;&gt;
&lt;code readability=&quot;8&quot;&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;testAnonymousClass&lt;/span&gt;(&lt;span&gt;Consumer&amp;lt;Integer&amp;gt; fb, &lt;span&gt;int&lt;/span&gt; a&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;fb.accept(a);&lt;br/&gt;}&lt;p&gt;&lt;span&gt;//匿名类直接做参数&lt;/span&gt;&lt;br/&gt;p.testAnonymousClass(&lt;span&gt;new&lt;/span&gt; Consumer&amp;lt;Integer&amp;gt;() {&lt;br/&gt;@&lt;span&gt;Override&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;accept&lt;/span&gt;(&lt;span&gt;Integer a&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;System.&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;anonymous class: &quot;&lt;/span&gt; + a);&lt;br/&gt;}&lt;br/&gt;}, &lt;span&gt;1&lt;/span&gt;);&lt;/p&gt;&lt;p&gt;&lt;span&gt;//匿名类直接做参数&lt;/span&gt;&lt;br/&gt;p.testAnonymousClass(&lt;span&gt;new&lt;/span&gt; Consumer&amp;lt;Integer&amp;gt;() {&lt;br/&gt;@&lt;span&gt;Override&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;accept&lt;/span&gt;(&lt;span&gt;Integer a&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;System.&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;anonymous class: &quot;&lt;/span&gt; + a);&lt;br/&gt;}&lt;br/&gt;}, &lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;span&gt;总之，在Java中无论是普通方法，还是lambda表达式，或是匿名类，其实它们最后都变成了一个类，且都实现了这个函数式接口。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;只不过匿名类是我们自己定义的。lambda表达式最后对应的类是编译器造出来的，所以它是“人造”的，但不是匿名的。&lt;/p&gt;&lt;p&gt;看不懂Java没关系，只要明白了原理就算是知道了精髓。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;in C# VS in Java&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了“模拟”函数指针的功能，在C#中使用委托，在Java中使用函数式接口。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;函数式接口其实就是一个接口，它看起来具有表示“方法签名”的功能，但是很丑陋。&lt;/p&gt;&lt;p&gt;委托看起来更像“方法签名”，也很优雅，但不要被迷惑，其实它也是一个类，没有什么高级东西。&lt;/p&gt;&lt;p&gt;对于引用方法的写法不同，C#中使用this.Foo，this.Bar，Java中使用this::foo，this::bar。&lt;/p&gt;&lt;p&gt;lambda表达式的写法略微不同，C#中是() =&amp;gt; {}，Java中是() -&amp;gt; {}。&lt;/p&gt;&lt;p&gt;关于匿名，C#中虽然叫匿名方法，其实最后还是一个类，而且是委托类型的。直接用delegate关键字定义匿名方法。&lt;/p&gt;&lt;p&gt;Java中就叫匿名类，名副其实，最后就是一个类。只不过需要先定义一个接口，然后直接使用接口实现匿名类。&lt;/p&gt;&lt;p&gt;我们发现C#和Java对lambda表达式的支持其实差不多。不同的是C#更优雅一些，Java更丑陋一些。&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;思想提升&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;span&gt;一定要明白不仅普通数据可以当作参数传递，代码片段（就是逻辑）也可以当作参数传递。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;这个思想就是核心，至于写法和用法就是围绕着核心的变化而已。&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;PS&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：最近几年很少看到语言之争啊，莫非大家都觉得PHP是世界上最好的语言啦😁。Oracle选择收费和有闭源的趋势，微软却选择免费、开源和跨平台，上帝才知道这是怎么回事。&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201901/76066-20190124185836543-640590107.gif&quot; alt=&quot;&quot; width=&quot;178&quot; height=&quot;175&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.9831460674157303&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/ibyjamcabcjd1oSMRoBgcYQQExuFVWCWhiaBlA2QKLfOCAzIgiaHKWzw2hOS51llbp2L5zTc5ib0PxrONgG0DTLiaFA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;178&quot; data-order=&quot;0&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;编程新说&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr data-width=&quot;80%&quot;/&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;用独特的视角说技术&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201901/76066-20190124185847216-1263582225.jpg&quot; alt=&quot;&quot; width=&quot;258&quot; height=&quot;258&quot; data-copyright=&quot;0&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibyjamcabcjdWFl5NbLvP8Y42lnq8FO7erV4YRMvM24UexwHEvyqz25XiaAE5IhThMb7VNkh2useQFlqWPPtMWVA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;1&quot; data-w=&quot;258&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 03 Feb 2019 04:05:00 +0000</pubDate>
<dc:creator>李新杰</dc:creator>
<og:description>核心+变化 “凡是钱能解决的问题，就不是大问题。有很多问题是钱无法解决的，比如生老病死，比如不再相爱。”，看过《蜗居》的朋友一眼就能认出来。虽然这部电视剧讲的是chugui，但是毫无违和感，我当时都看</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lixinjie/p/lambda-in-java-vs-in-csharp.html</dc:identifier>
</item>
<item>
<title>React Native的缓存和下载 - _蒋鹏飞</title>
<link>http://www.cnblogs.com/dennisj/p/10349742.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dennisj/p/10349742.html</guid>
<description>&lt;p&gt;一般我们有3种数据需要缓存和下载：纯文本（比如API返回，状态标记等），图片缓存和其他静态文件。&lt;/p&gt;
&lt;h2 id=&quot;纯文本&quot;&gt;纯文本&lt;/h2&gt;
&lt;p&gt;纯文本还是比较简单的，RN官方模块&lt;code&gt;AsyncStorage&lt;/code&gt;就够了。它就跟HTML5里面的&lt;code&gt;LocalStorage&lt;/code&gt;一样，你可以直接调&lt;code&gt;setItem&lt;/code&gt;和&lt;code&gt;getItem&lt;/code&gt;去操作数据，这两个方法都会返回一个promise。下面是官方的例子：&lt;br/&gt;&lt;strong&gt;缓存数据&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;_storeData = async () =&amp;gt; {
  try {
    await AsyncStorage.setItem('@MySuperStore:key', 'I like to save it.');
  } catch (error) {
    // Error saving data
  }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;获取数据&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;_retrieveData = async () =&amp;gt; {
  try {
    const value = await AsyncStorage.getItem('TASKS');
    if (value !== null) {
      // We have data!!
      console.log(value);
    }
  } catch (error) {
    // Error retrieving data
  }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在iOS上，&lt;code&gt;AsyncStorage&lt;/code&gt;是native代码实现的，如果是小数据，就存在一个序列化字典里面，如果数据量太大，就单独存一个文件。在Android上，&lt;code&gt;AsyncStorage&lt;/code&gt;使用的是&lt;a href=&quot;https://rocksdb.org/&quot;&gt;RocksDB&lt;/a&gt; 或者 SQLite，取决于当前设备支持哪个。需要注意的是，Android上有大小限制，最大只能存6MB。这个是RN官方故意的，&lt;a href=&quot;https://github.com/facebook/react-native/blob/0.33-stable/ReactAndroid/src/main/java/com/facebook/react/modules/storage/ReactDatabaseSupplier.java#L108&quot;&gt;可以看这里的源码&lt;/a&gt;。如果需要的话，可以覆盖这个限制：&lt;/p&gt;
&lt;ul readability=&quot;9.5&quot;&gt;&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;找到&lt;code&gt;/android/app/src/main/java/MainApplication.java&lt;/code&gt; 并且导入 &lt;code&gt;ReactDatabaseSupplier&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import com.facebook.react.modules.storage.ReactDatabaseSupplier;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;导入后这个文件看起来像这样：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import com.facebook.react.shell.MainReactPackage;
import com.facebook.soloader.SoLoader;
import com.facebook.react.modules.storage.ReactDatabaseSupplier;&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;13&quot;&gt;
&lt;p&gt;找到 &lt;code&gt;onCreate&lt;/code&gt; 并设置新的 &lt;code&gt;maximumSize&lt;/code&gt;，我这里设置为50MB&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;long size = 50L * 1024L * 1024L; // 50 MB 
ReactDatabaseSupplier.getInstance(getApplicationContext()).setMaximumSize(size);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;改好后的&lt;code&gt;onCreate&lt;/code&gt;看起来是这样：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Override
public void onCreate() {
  super.onCreate();
  SoLoader.init(this, /* native exopackage */ false);

  long size = 50L * 1024L * 1024L; // 50 MB 
  ReactDatabaseSupplier.getInstance(getApplicationContext()).setMaximumSize(size);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;虽然可以覆盖这个大小，但是不推荐这么做，这会让DB变得很大很丑，如果存储失败，虽然会抛错，但是数据并不会回滚，数据会更丑。如果你需要存储大的数据，你可以把它存为文件，我们后面会讲到&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;图片&quot;&gt;图片&lt;/h2&gt;
&lt;p&gt;如果一个图片我们已经加载过一次了，下次再用的时候我就不想再加载一次了，最好是直接能从缓存读出来。官方组件&lt;a href=&quot;https://facebook.github.io/react-native/docs/images.html#cache-control-ios-only&quot;&gt;&lt;code&gt;Image&lt;/code&gt; 有一个属性 &lt;code&gt;cache&lt;/code&gt;&lt;/a&gt;可以支持一些缓存，&lt;strong&gt;但是他只支持iOS&lt;/strong&gt;。我这里找了两个比较流行的库&lt;a href=&quot;https://github.com/kfiroo/react-native-cached-image&quot;&gt;react-native-cached-image&lt;/a&gt; 和 &lt;a href=&quot;https://github.com/DylanVann/react-native-fast-image&quot;&gt;react-native-fast-image&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;react-native-cached-image&quot;&gt;react-native-cached-image&lt;/h3&gt;
&lt;p&gt;你可以跟着官方指引来安装，我就不多说了。但是要注意一点，这个库依赖 &lt;a href=&quot;https://github.com/wkh237/react-native-fetch-blob&quot;&gt;react-native-fetch-blob&lt;/a&gt;。这是一个native模块，在执行&lt;code&gt;yarn add&lt;/code&gt; 或者 &lt;code&gt;npm install&lt;/code&gt;后，你需要把它链接到你的项目，最简单的是执行&lt;code&gt;react-native link react-native-fetch-blob&lt;/code&gt;自动链接。如果你的项目结构跟自动链接的不一样，你需要手动链接，&lt;a href=&quot;https://github.com/wkh237/react-native-fetch-blob/wiki/Manually-Link-Package&quot;&gt;可以参考这里&lt;/a&gt;。&lt;br/&gt;这个库有三个比较有用的组件，&lt;code&gt;CachedImage&lt;/code&gt;, &lt;code&gt;ImageCacheProvider&lt;/code&gt; 和 &lt;code&gt;ImageCacheManager&lt;/code&gt;，这是一个官方例子：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;import React from 'react';
import {
    CachedImage,
    ImageCacheProvider
} from 'react-native-cached-image';

const images = [
    'https://example.com/images/1.jpg',
    'https://example.com/images/2.jpg',
    'https://example.com/images/3.jpg',
    // ...
];

export default class Example extends React.Component {
    render() {
        return (
            &amp;lt;ImageCacheProvider
                urlsToPreload={images}
                onPreloadComplete={() =&amp;gt; console.log('hey there')}&amp;gt;

                &amp;lt;CachedImage source={{uri: images[0]}}/&amp;gt;

                &amp;lt;CachedImage source={{uri: images[1]}}/&amp;gt;

                &amp;lt;CachedImage source={{uri: images[2]}}/&amp;gt;

            &amp;lt;/ImageCacheProvider&amp;gt;
        );
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ImageCacheManager&lt;/code&gt;是用来控制缓存的，你可以用它下载和删除图片，甚至你可以获取到下载图片的物理地址。它并没有缓存优先，强制刷新，强制使用缓存这种预设规则可以用，具体怎么用需要你自己定义。&lt;/p&gt;
&lt;h3 id=&quot;react-native-fast-image&quot;&gt;react-native-fast-image&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;react-native-fast-image&lt;/code&gt;用起来更简单一点，在GitHub上的星星也多一点。这是一个native库，在iOS上是包装的 &lt;a href=&quot;https://github.com/rs/SDWebImage&quot;&gt;SDWebImage&lt;/a&gt;，Android上是包装的&lt;a href=&quot;https://github.com/bumptech/glide&quot;&gt;Glide (Android)&lt;/a&gt;，这两个都是原生上万星星的库。因为是native库，所以安装后也需要链接，具体方法跟上面一样。这是一个使用例子：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;import FastImage from 'react-native-fast-image'

const YourImage = () =&amp;gt;
  &amp;lt;FastImage
    style={styles.image}
    source={{
      uri: 'https://unsplash.it/400/400?image=1',
      headers:{ Authorization: 'someAuthToken' },
      priority: FastImage.priority.normal,
      cache: FastImage.cacheControl.web
    }}
    resizeMode={FastImage.resizeMode.contain}
  /&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它预设了三种模式来控制缓存，其中一个是&lt;code&gt;FastImage.cacheControl.web&lt;/code&gt;，这个策略就是网页是一样的了，他会采用HTTP的缓存控制头来控制，前端开发者应该很熟悉。这个库官方有很多例子可以看，&lt;a href=&quot;https://github.com/DylanVann/react-native-fast-image&quot;&gt;看这里&lt;/a&gt;。做图片缓存的话，推荐用这个。&lt;/p&gt;
&lt;h2 id=&quot;其他静态文件&quot;&gt;其他静态文件&lt;/h2&gt;
&lt;p&gt;有时候我们需要下载或者缓存一些静态文件到设备上，比如pdf, mp3, mp4等。&lt;a href=&quot;https://github.com/joltup/rn-fetch-blob&quot;&gt;&lt;code&gt;rn-fetch-blob&lt;/code&gt;&lt;/a&gt;是一个可以将你的HTTP返回作为文件存在设备上的native库。他其实就是&lt;code&gt;react-native-fetch-blob&lt;/code&gt;，但是&lt;code&gt;react-native-fetch-blob&lt;/code&gt;没有继续维护了，所以就fork过来改了个名字继续维护。&lt;br/&gt;你只要在请求的配置里面设置&lt;code&gt;fileCache : true&lt;/code&gt;，他就会将返回值作为文件存起来，同时返回给你物理路径，默认存的文件是没有后缀名的，你可以加参数设定后缀，比如：&lt;code&gt;appendExt : 'zip'&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;RNFetchBlob
  .config({
    // add this option that makes response data to be stored as a file,
    // this is much more performant.
    fileCache : true,
    appendExt : 'zip'
  })
  .fetch('GET', 'http://www.example.com/file/example.zip', {
    Authorization : 'Bearer access-token...',
    //some headers ..
  })
  .then((res) =&amp;gt; {
    // the temp file path
    console.log('The file saved to ', res.path())
  })&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;拿到这个路径可以直接用&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;imageView = &amp;lt;Image source={{ uri : Platform.OS === 'android' ? 'file://' + res.path() : '' + res.path() }}/&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个库还可以支持文件上传&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;RNFetchBlob.fetch('POST', 'https://content.dropboxapi.com/2/files/upload', {
    // dropbox upload headers
    Authorization : &quot;Bearer access-token...&quot;,
    'Dropbox-API-Arg': JSON.stringify({
      path : '/img-from-react-native.png',
      mode : 'add',
      autorename : true,
      mute : false
    }),
    'Content-Type' : 'application/octet-stream',
    // Change BASE64 encoded data to a file path with prefix `RNFetchBlob-file://`.
    // Or simply wrap the file path with RNFetchBlob.wrap().
  }, RNFetchBlob.wrap(PATH_TO_THE_FILE))
  .then((res) =&amp;gt; {
    console.log(res.text())
  })
  .catch((err) =&amp;gt; {
    // error handling ..
  })&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在下载和上传过程中，还可以拿到他的进度：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;RNFetchBlob.fetch('POST', 'http://www.example.com/upload', {
    //... some headers,
    'Content-Type' : 'octet-stream'
  }, base64DataString)
  // listen to upload progress event
  .uploadProgress((written, total) =&amp;gt; {
      console.log('uploaded', written / total)
  })
  .then((resp) =&amp;gt; {
    // ...
  })
  .catch((err) =&amp;gt; {
    // ...
  })

RNFetchBlob
  .config({
    // add this option that makes response data to be stored as a file,
    // this is much more performant.
    fileCache : true,
    appendExt : 'zip'
  })
  .fetch('GET', 'http://www.example.com/file/example.zip', {
    Authorization : 'Bearer access-token...',
    //some headers ..
  })
  // listen to download progress event
  .progress((received, total) =&amp;gt; {
      console.log('progress', received / total)
  })
  .then((res) =&amp;gt; {
    // the temp file path
    console.log('The file saved to ', res.path())
  })&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;要注意点的是，&lt;code&gt;rn-fetch-blob&lt;/code&gt;并不会记录你的下载历史，就是说你关掉APP再打开，你就不知道你下载的文件哪儿去了。我们可以用&lt;code&gt;AsyncStorage&lt;/code&gt;配合着记录下载的历史。&lt;br/&gt;下载完成后记录地址到&lt;code&gt;AsyncStorage&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;RNFetchBlob
  .config({
    fileCache: true,
    appendExt: 'pdf',
  })
  .fetch('GET', 'http://pdf.dfcfw.com/pdf/H3_AP201901271289150621_1.pdf')
  .then((response) =&amp;gt; {
    const path = response.path();

    this.setState({
      cachedFile: path,
    });

    AsyncStorage.setItem('fileCache', path);
  })
  .catch((error) =&amp;gt; {
    this.setState({
      error,
    });
  });&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;检查是不是已经下过这个文件了：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;componentDidMount() {
  AsyncStorage.getItem('fileCache').then((data) =&amp;gt; {
    this.setState({
      cachedFile: data,
    });
  });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用完了也可以删除这个文件，同时删除记录&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;clearCache() {
  const { cachedFile } = this.state;
  RNFetchBlob.fs.unlink(cachedFile).then(() =&amp;gt; {
    this.setState({
      cachedFile: null,
    });
    AsyncStorage. removeItem('fileCache');
  });
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sun, 03 Feb 2019 03:29:00 +0000</pubDate>
<dc:creator>_蒋鹏飞</dc:creator>
<og:description>一般我们有3种数据需要缓存和下载：纯文本（比如API返回，状态标记等），图片缓存和其他静态文件。 纯文本 纯文本还是比较简单的，RN官方模块 就够了。它就跟HTML5里面的 一样，你可以直接调 和`</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dennisj/p/10349742.html</dc:identifier>
</item>
<item>
<title>mybatis 学习总结笔记Day2 - 夏天里的Jasmine</title>
<link>http://www.cnblogs.com/qianjinyan/p/10349876.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qianjinyan/p/10349876.html</guid>
<description>&lt;p&gt;&lt;span&gt;在门外听到或看到一门技术，找资料入门，一看，嗯，不错，进门之后，发现，尼玛————，是片海，你是关门而出，还是学习精卫填海。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;填海吧，也许只是个小水坑，稍加用点力，就填的7788了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;上一篇随笔中说了mybatis入门，介绍了基本方式的增删改查CRUD&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;MyBatis快速入门：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/qianjinyan/p/10346569.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://www.cnblogs.com/qianjinyan/p/10346569.html&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;CRUD&lt;/strong&gt;是指在做计算处理时的增加(Create)、读取查询(Retrieve)、更新(Update)和删除(Delete)几个单词的首字母简写。CRUD主要被用在描述软件系统中数据库或者持久层的基本操作功能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;mybatis除了用基本方式的CRUD，还可以用mapper动态代理方式的CRUD，这种方式也通常称作Mybatis接口开发。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;今天要总结的内容：&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;1. 用Mapper接口动态代理方式的CRUD&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2. 别名的使用&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3. 将数据库连接等信息放到配置文件中再动态引入&lt;/span&gt;&lt;br/&gt;&lt;span&gt;4. 类型转化器【比如DB中存int，程序对象中是false和true】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1.Mybatis接口开发的原则是：约定优于配置,必须遵循以下约定：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1) 方法名和mapper.xml文件标签中的ID必须一致&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2) 方法的输入参数和mapper.xml文件标签中的parameterType类型一致&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3) 方法的输出参数和mapper.xml文件标签中的resultType类型一致&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3） mapper.xml文件标签中的namespace的值就是接口的全类名&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1064427/201902/1064427-20190203110047740-2105885044.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;根据配置的原则，接口的内容很容易编写了，如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
package com.test.mybatis.mapper;

import com.test.mybatis.entity.User;

import java.util.List;

public interface UserMapper {

    User selectById(int id);

    List&amp;lt;User&amp;gt; selectAll();

    int  addUser(User user);

    int updateUser(User user);

    int deleteUserById(int id);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　再看一下UserMapper.xml文件，是不是namespace的值和接口的全路径名称一致，是不是mapper中的id和接口的方法名一致，返回类型是不是也不一致。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;新增/更新/删除接口，在mapper文件中是没有返回类型的，接口中返回int类型，也可以返回无类型void。 我这边返回int，目的是看新增/更新/删除操作，影响的数据条数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1064427/201902/1064427-20190203112113192-760228647.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;测试一下接口的调用，这个时候就不用statement了，需要用java中的反射，session.getMapper(xxMapper.class),返回的还是这个接口，然后调用接口里的方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1064427/201902/1064427-20190203110901972-1745919634.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; 2. 别名的使用&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;比如我觉得userMapper.xml文件中的namespace=&quot;com.test.mybatis.entity.User&quot;太长，要写的太多，想用别名User替代com.test.mybatis.entity.User&lt;/span&gt;&lt;br/&gt;&lt;span&gt;config.xml文件中，在&amp;lt;configuration&amp;gt;元素下导入&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;typeAliases&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;typeAlias type=&quot;com.test.mybatis.mapper.UserMapper&quot; alias=&quot;UserMapper&quot; /&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;typeAlias type=&quot;com.test.mybatis.entity.User&quot; alias=&quot;User&quot; /&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/typeAliases&amp;gt;&lt;/span&gt;&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;&lt;span&gt; 3. 将数据库连接等信息放到配置文件中再动态引入&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;配置信息单独放入某文件中，然后在config.xml文件中，在&amp;lt;configuration&amp;gt;元素下导入&lt;/span&gt;&lt;br/&gt;&lt;span&gt;导入语句 &amp;lt;properties resource=&quot;db.properties&quot; /&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;db.properties文件&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
&lt;span&gt;driver= com.mysql.cj.jdbc.Driver
url= jdbc:mysql://localhost:3306/test?useUnicode=true&amp;amp;characterEncoding=utf-8
username= root
password=root&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;config.xml中如何取对应的value值，用${key}来取值，之后的config.xml文件如下&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&amp;gt;
&amp;lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&amp;gt;
&amp;lt;configuration&amp;gt;
    &amp;lt;properties resource=&quot;db.properties&quot; /&amp;gt;

    &amp;lt;typeAliases&amp;gt;
        &amp;lt;typeAlias type=&quot;com.test.mybatis.mapper.UserMapper&quot; alias=&quot;UserMapper&quot; /&amp;gt;
        &amp;lt;typeAlias type=&quot;com.test.mybatis.entity.User&quot; alias=&quot;User&quot; /&amp;gt;
    &amp;lt;/typeAliases&amp;gt;

    &amp;lt;environments default=&quot;development&quot;&amp;gt;
        &amp;lt;environment id=&quot;development&quot;&amp;gt;
            &amp;lt;transactionManager type=&quot;JDBC&quot;/&amp;gt;
                &amp;lt;dataSource type=&quot;POOLED&quot;&amp;gt;
                    &amp;lt;property name=&quot;driver&quot; value=&quot;${driver}&quot;/&amp;gt;
                    &amp;lt;property name=&quot;url&quot; value=&quot;${url}&quot;/&amp;gt;
                    &amp;lt;property name=&quot;username&quot; value=&quot;${username}&quot;/&amp;gt;
                    &amp;lt;property name=&quot;password&quot; value=&quot;${password}&quot;/&amp;gt;
                &amp;lt;/dataSource&amp;gt;
        &amp;lt;/environment&amp;gt;
    &amp;lt;/environments&amp;gt;


    &amp;lt;mappers&amp;gt;
        &amp;lt;mapper resource=&quot;UserMapper.xml&quot;/&amp;gt;
    &amp;lt;/mappers&amp;gt;


&amp;lt;/configuration&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt; 4. 类型转化器【比如DB中存int，程序对象中是false和true】&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 03 Feb 2019 03:12:00 +0000</pubDate>
<dc:creator>夏天里的Jasmine</dc:creator>
<og:description>在门外听到或看到一门技术，找资料入门，一看，嗯，不错，进门之后，发现，尼玛————，是片海，你是关门而出，还是学习精卫填海。 填海吧，也许只是个小水坑，稍加用点力，就填的7788了。 上一篇随笔中说了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qianjinyan/p/10349876.html</dc:identifier>
</item>
</channel>
</rss>