<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>使用pytorch快速搭建神经网络实现二分类任务（包含示例） - 沁泽</title>
<link>http://www.cnblogs.com/wangqinze/p/13424368.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangqinze/p/13424368.html</guid>
<description>&lt;hr/&gt;&lt;h2 id=&quot;introduce&quot;&gt;Introduce&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/wangqinze/p/13418291.html&quot;&gt;上一篇学习笔记&lt;/a&gt;介绍了不使用pytorch包装好的神经网络框架实现logistic回归模型，并且根据autograd实现了神经网络参数更新。&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;&lt;strong&gt;本文介绍利用pytorch快速搭建神经网络。即利用torch.nn以及torch.optim库来快捷搭建一个简单的神经网络来实现二分类功能。&lt;/strong&gt;&lt;/mark&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;利用pytorch已经包装好的库(torch.nn)来快速搭建神经网络结构。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;利用已经包装好的包含各种优化算法的库(torch.optim)来优化神经网络中的参数，如权值参数w和阈值参数b。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;mark&gt;以下均为初学者笔记。&lt;/mark&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;build-a-neural-network-structure&quot;&gt;Build a neural network structure&lt;/h2&gt;
&lt;p&gt;假设我们要搭建一个带有两个隐层的神经网络来实现节点的二分类，输入层包括2个节点（输入节点特征），两个隐层均包含5个节点（特征映射），输出层包括2个节点（分别输出属于对应节点标签的概率）。如下图所示：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/887378/202008/887378-20200802165522303-1760549429.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图从左右到右为输入层、隐藏层、隐藏层、输出层，各层之间采用全连接结构。神经网络两隐藏层的激活函数均采用sigmoid函数，输出层最后采用softmax函数归一化概率。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;网络搭建过程中使用的torch.nn相关模块介绍如下：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;torch.nn.Sequential&lt;/strong&gt;：是一个时序容器，我们可以通过调用其构造器，将神经网络模块按照输入层到输出层的顺序传入，以此构造完整的神经网络结构，具体用法参考如下神经网络搭建代码。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;torch.nn.Linear&lt;/strong&gt;：设置网络中的全连接层，用来实现网络中节点输入的线性求和，即实现如下线性变换函数：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;\[y = xA^T + b \]&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
'''
搭建神经网络，
输入层包括2个节点，两个隐层均包含5个节点，输出层包括1个节点。'''

net = nn.Sequential(
    nn.Linear(2,5),  # 输入层与第一隐层结点数设置，全连接结构
    torch.nn.Sigmoid(),  # 第一隐层激活函数采用sigmoid
    nn.Linear(5,5),  # 第一隐层与第二隐层结点数设置，全连接结构
    torch.nn.Sigmoid(),  # 第一隐层激活函数采用sigmoid
    nn.Linear(5,2),  # 第二隐层与输出层层结点数设置，全连接结构
    nn.Softmax(dim=1) # 由于有两个概率输出，因此对其使用Softmax进行概率归一化，dim=1代表行归一化
)

 print(net)

'''
Sequential(
  (0): Linear(in_features=2, out_features=5, bias=True)
  (1): Sigmoid()
  (2): Linear(in_features=5, out_features=5, bias=True)
  (3): Sigmoid()
  (4): Linear(in_features=5, out_features=2, bias=True)
  (5): Softmax(dim=1)
)'''

&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h2 id=&quot;configure-loss-function-and-optimizer&quot;&gt;Configure Loss Function and Optimizer&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;note:&lt;/strong&gt; torch.optim库中封装了许多常用的优化方法，这边使用了最常用的随机梯度下降来优化网络参数。例子中使用了交叉熵损失作为代价函数，其实torch.nn中也封装了许多代价函数，具体可以查看官方文档。&lt;strong&gt;对于pytorch中各种损失函数的学习以及优化方法的学习将在后期进行补充。&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;配置损失函数和优化器的代码如下所示：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 配置损失函数和优化器
optimizer = torch.optim.SGD(net.parameters(),lr=0.01) # 优化器使用随机梯度下降，传入网络参数和学习率
loss_func = torch.nn.CrossEntropyLoss() # 损失函数使用交叉熵损失函数
&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h2 id=&quot;model-training&quot;&gt;Model Training&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;神经网络训练过程大致如下&lt;/strong&gt;：首先输入数据，接着神经网络进行前向传播，计算输出层的输出，进而计算预先定义好的损失（如本例中的交叉熵损失），接着进行误差反向传播，利用事先设置的优化方法（如本例中的随机梯度下降SGD）来更新网络中的参数，如权值参数w和阈值参数b。接着反复进行上述迭代，达到最大迭代次数（num_epoch)或者损失值满足某条件之后训练停止，从而我们可以得到一个由大量数据训练完成的神经网络模型。&lt;strong&gt;模型训练的代码如下所示：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 模型训练
num_epoch = 10000 # 最大迭代更新次数
for epoch in range(num_epoch):
    y_p = net(x_t)  # 喂数据并前向传播

    loss = loss_func(y_p,y_t.long()) # 计算损失
    '''
    PyTorch默认会对梯度进行累加，因此为了不使得之前计算的梯度影响到当前计算，需要手动清除梯度。
    pyTorch这样子设置也有许多好处，但是由于个人能力，还没完全弄懂。
    '''
    optimizer.zero_grad()  # 清除梯度
    loss.backward()  # 计算梯度，误差回传
    optimizer.step()  # 根据计算的梯度，更新网络中的参数

    if epoch % 1000 == 0:
        print('epoch: {}, loss: {}'.format(epoch, loss.data.item()))
        
'''
每1000次输出损失如下：
epoch: 0, loss: 0.7303197979927063
epoch: 1000, loss: 0.669952392578125
epoch: 2000, loss: 0.6142827868461609
epoch: 3000, loss: 0.5110923051834106
epoch: 4000, loss: 0.4233965575695038
epoch: 5000, loss: 0.37978556752204895
epoch: 6000, loss: 0.3588798940181732
epoch: 7000, loss: 0.3476340174674988
                ......
'''

print(&quot;所有样本的预测标签: \n&quot;,torch.max(y_p,dim = 1)[1])

'''
note：可以发现前100个标签预测为0，后100个样本标签预测为1。因此所训练模型可以正确预测训练集标签。
所有样本的预测标签: 
 tensor([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1])
'''

&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h2 id=&quot;网络的保存和提取&quot;&gt;网络的保存和提取&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;'''两种保存方式
第一种: 保存网络的所有参数（包括网络结构）
    torch.save(net,'net.pkl')
对应加载方式: net1 = torch.load('net.pkl')
第二种: 仅保存网络中需要训练的参数 ，即net.state_dict()，如权值参数w和阈值参数b。（不包括网络结构）
    torch.save(net.state_dict(),'net_parameter.pkl')
对应加载方式: 
    加载时需要提供两个信息: 
    第一: 网络结构信息，需要先重新搭建和保存的网络同样的网络结构。
    第二: 保存的网络中的参数的信息，权值和阈值参数。
    具体加载方式如下:
    net = nn.Sequential(
    nn.Linear(2,5),  
    torch.nn.Sigmoid(),  
    nn.Linear(5,5),  
    torch.nn.Sigmoid(),  
    nn.Linear(5,2),  
    nn.Softmax(dim=1) 
    )
    net2.load_state_dict(torch.load('net_parameter.pkl')
    '''

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/zergtant/pytorch-handbook/blob/master/chapter1/3_neural_networks_tutorial.ipynb&quot;&gt;本文参考-1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/115251842&quot;&gt;本文参考-2&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;附完整代码&quot;&gt;附完整代码&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;import torch
import torch.nn as nn

'''
使用正态分布随机生成两类数据
第一类有100个点，使用均值为2，标准差为1的正态分布随机生成，标签为0。
第二类有100个点，使用均值为-2，标准差为1的正态分布随机生成，标签为1。
torch.normal(tensor1,tensor2)
输入两个张量，tensor1为正态分布的均值，tensor2为正态分布的标准差。
torch.normal以此抽取tensor1和tensor2中对应位置的元素值构造对应的正态分布以随机生成数据，返回数据张量。
'''

x1_t = torch.normal(2*torch.ones(100,2),1)
y1_t = torch.zeros(100)

x2_t = torch.normal(-2*torch.ones(100,2),1)
y2_t = torch.ones(100)

x_t = torch.cat((x1_t,x2_t),0)
y_t = torch.cat((y1_t,y2_t),0)

'''
搭建神经网络，
输入层包括2个节点，两个隐层均包含5个节点，输出层包括1个节点。
'''

net = nn.Sequential(
    nn.Linear(2,5),  # 输入层与第一隐层结点数设置，全连接结构
    torch.nn.Sigmoid(),  # 第一隐层激活函数采用sigmoid
    nn.Linear(5,5),  # 第一隐层与第二隐层结点数设置，全连接结构
    torch.nn.Sigmoid(),  # 第一隐层激活函数采用sigmoid
    nn.Linear(5,2),  # 第二隐层与输出层层结点数设置，全连接结构
    nn.Softmax(dim=1) # 由于有两个概率输出，因此对其使用Softmax进行概率归一化
)

print(net)
'''
Sequential(
  (0): Linear(in_features=2, out_features=5, bias=True)
  (1): Sigmoid()
  (2): Linear(in_features=5, out_features=5, bias=True)
  (3): Sigmoid()
  (4): Linear(in_features=5, out_features=2, bias=True)
  (5): Softmax(dim=1)
)'''

# 配置损失函数和优化器
optimizer = torch.optim.SGD(net.parameters(),lr=0.01) # 优化器使用随机梯度下降，传入网络参数和学习率
loss_func = torch.nn.CrossEntropyLoss() # 损失函数使用交叉熵损失函数

# 模型训练
num_epoch = 10000 # 最大迭代更新次数
for epoch in range(num_epoch):
    y_p = net(x_t)  # 喂数据并前向传播

    loss = loss_func(y_p,y_t.long()) # 计算损失
    '''
    PyTorch默认会对梯度进行累加，因此为了不使得之前计算的梯度影响到当前计算，需要手动清除梯度。
    pyTorch这样子设置也有许多好处，但是由于个人能力，还没完全弄懂。
    '''
    optimizer.zero_grad()  # 清除梯度
    loss.backward()  # 计算梯度，误差回传
    optimizer.step()  # 根据计算的梯度，更新网络中的参数

    if epoch % 1000 == 0:
        print('epoch: {}, loss: {}'.format(epoch, loss.data.item()))


'''
torch.max(y_p,dim = 1)[0]是每行最大的值
torch.max(y_p,dim = 1)[0]是每行最大的值的下标，可认为标签
'''
print(&quot;所有样本的预测标签: \n&quot;,torch.max(y_p,dim = 1)[1])


&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 03 Aug 2020 00:43:00 +0000</pubDate>
<dc:creator>沁泽</dc:creator>
<og:description>使用pytorch快速搭建神经网络实现二分类任务（包含示例） Introduce 上一篇学习笔记介绍了不使用pytorch包装好的神经网络框架实现logistic回归模型，并且根据autograd实现</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wangqinze/p/13424368.html</dc:identifier>
</item>
<item>
<title>vue cli4构建基于typescript的vue组件并发布到npm - 邹琼俊</title>
<link>http://www.cnblogs.com/jiekzou/p/13424352.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jiekzou/p/13424352.html</guid>
<description>&lt;h2&gt;基于vue cli创建一个vue项目&lt;/h2&gt;
&lt;p&gt;　　首先安装最新的vue cli脚手架，&lt;/p&gt;
&lt;p&gt;　　npm install --global @vue/cli&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.2.13 (node_modules\@vue\cli\node_modules\fsevents)&lt;span&gt;:
npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform &lt;span&gt;for fsevents@1.2.13: wanted {&quot;os&quot;:&quot;darwin&quot;,&quot;arch&quot;:&quot;any&quot;} (current: {&quot;os&quot;:&quot;win32&quot;,&quot;arch&quot;:&quot;x64&quot;})

+ @vue/cli@4.4.6&lt;span&gt;
added 1230 packages from 670 contributors in 118.122s&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　查看安装的vue -V&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
@vue/cli 4.4.6
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　创建项目：vue create my-project-name（“my-project-name”，这个可以根据需要命名，尽量用英文）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
Vue CLI v4.&lt;span&gt;4.6
? Please pick a preset: Manually &lt;span&gt;select&lt;span&gt; features
? Check the features needed &lt;span&gt;for your project: Babel, TS, Router, Vuex, CSS Pre-&lt;span&gt;processors, Linter
? Use class-style component syntax?&lt;span&gt; Yes
? Use Babel alongside TypeScript (required &lt;span&gt;for modern mode, auto-detected polyfills, transpiling JSX)?&lt;span&gt; Yes
? Use history mode &lt;span&gt;for router? (Requires proper server setup &lt;span&gt;for index fallback &lt;span&gt;in&lt;span&gt; production) Yes
? Pick a CSS pre-processor (PostCSS, Autoprefixer and CSS Modules are supported by default): Sass/SCSS (with node-&lt;span&gt;sass)
? Pick a linter /&lt;span&gt; formatter config: Prettier
?&lt;span&gt; Pick additional lint features: Lint on save
? Where &lt;span&gt;do you prefer placing config &lt;span&gt;for Babel, ESLint, etc.?&lt;span&gt; In dedicated config files
? Save this as a preset &lt;span&gt;for future projects?&lt;span&gt; Yes
? Save preset as: ts_tmpl&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　创建完成之后，会出现如下提示&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;⚓  Running completion hooks...

�  Generating README.md...

�  Successfully created project my-project-&lt;span&gt;name.
�  Get started with the following commands:

 $ cd my-project-&lt;span&gt;name
 $ npm run serve&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　根据提示执行命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
E:\vue_codes&amp;gt;cd my-project-&lt;span&gt;name

E:\vue_codes\my-project-name&amp;gt;&lt;span&gt;npm run serve

&amp;gt; my-project-name@&lt;span&gt;0.1.&lt;span&gt;0 serve E:\vue_codes\my-project-&lt;span&gt;name
&amp;gt; vue-cli-&lt;span&gt;service serve

 INFO  Starting development server...
Starting type checking service...
Using &lt;span&gt;1&lt;span&gt; worker with 2048MB memory limit
&lt;span&gt;98%&lt;span&gt; after emitting CopyPlugin

 DONE  Compiled successfully &lt;span&gt;in 5304ms                                                                      上午11:&lt;span&gt;13:&lt;span&gt;54&lt;span&gt;

No type errors found
Version: typescript &lt;span&gt;3.9.&lt;span&gt;7&lt;span&gt;
Time: 3160ms

  App running at:
  - Local:   http:&lt;span&gt;//&lt;span&gt;localhost:8080/
  - Network: http:&lt;span&gt;//&lt;span&gt;192.168.1.95:8080/
&lt;span&gt;
  Note that the development build is not optimized.
  To create a production build, run npm run build.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在浏览器输入地址：&lt;a href=&quot;http://localhost:8080/&quot;&gt;http://localhost:8080/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/413851/202007/413851-20200729130056715-85707561.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　出现如上图所示界面，表示项目创建成功了。&lt;/p&gt;
&lt;p&gt; 　　生成的代码目录结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/413851/202007/413851-20200729130127083-1569212893.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;span&gt;&lt;span&gt;两个声明文件：&lt;em&gt;&lt;span&gt;&lt;span&gt;shims-vue.d.ts&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;span&gt;&lt;span&gt;和&lt;em&gt;&lt;span&gt;&lt;span&gt;shims.tsx.d.ts&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;&lt;span&gt;　　shims-vue.d.ts&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;span&gt;&lt;span&gt;由于 TypeScript 默认并不支持 *.vue 后缀的文件，所以在 vue 项目中引入的时候需要创建一个shims-vue.d.ts 文件，放在项目项目对应使用目录下，例如 src/shims-vue.d.ts，用来支持*.vue 后缀的文件&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;&lt;span&gt;　　shims-tsx.d.ts&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;span&gt;&lt;span&gt;：&lt;span&gt;&lt;span&gt;允许.tsx 结尾的文件，在 Vue 项目中编写 jsx 代码&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;　　tsconfig.json：&lt;/code&gt;typescript配置文件,主要用于指定待编译的文件和定义编译选项&lt;/p&gt;
&lt;p&gt;　　normalize.css：Normalize.css 是一个可以定制的CSS文件，它让不同的浏览器在渲染网页元素的时候形式更统一。Normalize.css是一种CSS reset的替代方案。&lt;/p&gt;
&lt;p&gt;　　.browserslistrc：这个配置能够分享目标浏览器和nodejs版本在不同的前端工具。这些工具能根据目标浏览器自动来进行配置，Browserslist这个东西单独是没用的，（补充: 在vue官方脚手架中，browserslist字段会被 @babel/preset-env 和 Autoprefixer 用来确定需要转译的 JavaScript 特性和需要添加的 CSS 浏览器前缀。）&lt;/p&gt;
&lt;p&gt; 　　browserslist的配置文件：&lt;br/&gt;　　&amp;gt; 1% 兼容全球使用率大于1%的游览器&lt;br/&gt;　　last 2 versions 兼容每个游览器的最近两个版本&lt;br/&gt;　　not ie &amp;lt;= 8 不兼容ie8及以下&lt;br/&gt;　　具体可见 browserslist。&lt;/p&gt;
&lt;div readability=&quot;11&quot;&gt;
&lt;p&gt;　　babel.config.js：Babel 是一个工具链，主要用于将 ECMAScript 2015+ 版本的代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其他环境中。&lt;/p&gt;
　　postcss.config.js：用于配置将px转化成rem，和自动添加CSS浏览器前缀等。&lt;/div&gt;
&lt;p&gt;　　esnext 是一个 JavaScript 库，可以将 ES6 草案规范语法转成今天的 JavaScript 语法。&lt;/p&gt;
&lt;h2&gt;改造项目结构&lt;/h2&gt;
&lt;p&gt;　　这种组件项目和我们日常的项目还是有很大区别的，由于前面我采用的是vue cli创建的完整模板项目，这里许多东西用不到，我们就将其删掉，最终项目目录结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/413851/202007/413851-20200731133920837-829924049.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　examples：是组件使用示例&lt;/p&gt;
&lt;p&gt;　　src/components：是组件源码&lt;/p&gt;
&lt;p&gt;　　package.json代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;83.5&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &quot;name&quot;: &quot;jie-echarts&quot;&lt;span&gt;,
  &quot;version&quot;: &quot;0.1.0&quot;&lt;span&gt;,
  &lt;span&gt;&quot;private&quot;: false,
  &quot;description&quot;: &quot;echarts组件&quot;&lt;span&gt;,
  &lt;span&gt;&quot;main&quot;: &quot;dist/JieEcharts.common.js&quot;,
  &quot;author&quot;: &quot;zouqj&amp;lt;zouyujie@126.com&amp;gt;&quot;&lt;span&gt;,
  &quot;license&quot;: &quot;MIT&quot;&lt;span&gt;,
  &quot;scripts&quot;&lt;span&gt;: {
    &quot;serve&quot;: &quot;vue-cli-service serve&quot;&lt;span&gt;,
    &quot;build&quot;: &quot;vue-cli-service build&quot;&lt;span&gt;,
    &quot;lint&quot;: &quot;vue-cli-service lint&quot;&lt;span&gt;,
    &lt;span&gt;&quot;lib&quot;: &quot;vue-cli-service build --target lib --name JieEcharts ./src/index.ts&quot;&lt;span&gt;
  },&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div readability=&quot;18&quot;&gt;
&lt;p&gt;&lt;span&gt;  &lt;span&gt;&quot;repository&quot;: {&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &quot;type&quot;: &quot;git&quot;,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &quot;url&quot;: &quot;git+https://github.com/zouyujie/vue-components/tree/master/jie-echarts&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  },&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  &quot;bugs&quot;: {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &quot;url&quot;: &quot;https://github.com/zouyujie/vue-components/issues&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  },&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  &quot;homepage&quot;: &quot;https://github.com/zouyujie/vue-components/tree/master/jie-echarts&quot;,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  &quot;keywords&quot;: [&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &quot;vue&quot;,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &quot;vuejs&quot;,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &quot;typescript&quot;,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &quot;vuecli4.x&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  ],&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;  &quot;dependencies&quot;&lt;span&gt;: {
    &quot;core-js&quot;: &quot;^3.6.5&quot;&lt;span&gt;,
    &quot;echarts&quot;: &quot;^4.8.0&quot;&lt;span&gt;,
    &quot;ts-loader&quot;: &quot;^8.0.1&quot;&lt;span&gt;,
    &quot;vue&quot;: &quot;^2.6.11&quot;&lt;span&gt;,
    &quot;vue-class-component&quot;: &quot;^7.2.3&quot;&lt;span&gt;,
    &quot;vue-property-decorator&quot;: &quot;^8.4.2&quot;&lt;span&gt;,
    &quot;vue-router&quot;: &quot;^3.2.0&quot;&lt;span&gt;,
    &quot;vuex&quot;: &quot;^3.4.0&quot;&lt;span&gt;
  },
  &quot;devDependencies&quot;&lt;span&gt;: {
    &quot;@types/echarts&quot;: &quot;^4.6.4&quot;&lt;span&gt;,
    &quot;@typescript-eslint/eslint-plugin&quot;: &quot;^2.33.0&quot;&lt;span&gt;,
    &quot;@typescript-eslint/parser&quot;: &quot;^2.33.0&quot;&lt;span&gt;,
    &quot;@vue/cli-plugin-babel&quot;: &quot;~4.4.0&quot;&lt;span&gt;,
    &quot;@vue/cli-plugin-eslint&quot;: &quot;~4.4.0&quot;&lt;span&gt;,
    &quot;@vue/cli-plugin-router&quot;: &quot;~4.4.0&quot;&lt;span&gt;,
    &quot;@vue/cli-plugin-typescript&quot;: &quot;~4.4.0&quot;&lt;span&gt;,
    &quot;@vue/cli-plugin-vuex&quot;: &quot;~4.4.0&quot;&lt;span&gt;,
    &quot;@vue/cli-service&quot;: &quot;~4.4.0&quot;&lt;span&gt;,
    &quot;@vue/eslint-config-prettier&quot;: &quot;^6.0.0&quot;&lt;span&gt;,
    &quot;@vue/eslint-config-typescript&quot;: &quot;^5.0.2&quot;&lt;span&gt;,
    &quot;eslint&quot;: &quot;^6.7.2&quot;&lt;span&gt;,
    &quot;eslint-plugin-prettier&quot;: &quot;^3.1.3&quot;&lt;span&gt;,
    &quot;eslint-plugin-vue&quot;: &quot;^6.2.2&quot;&lt;span&gt;,
    &quot;node-sass&quot;: &quot;^4.12.0&quot;&lt;span&gt;,
    &quot;prettier&quot;: &quot;^1.19.1&quot;&lt;span&gt;,
    &quot;sass-loader&quot;: &quot;^8.0.2&quot;&lt;span&gt;,
    &quot;typescript&quot;: &quot;~3.9.3&quot;&lt;span&gt;,
    &quot;vue-template-compiler&quot;: &quot;^2.6.11&quot;&lt;span&gt;
  }
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　重点注意标红部分的配置。&lt;/p&gt;
&lt;p&gt;　　tsconfig.json&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &quot;compilerOptions&quot;&lt;span&gt;: {
    &quot;target&quot;: &quot;esnext&quot;&lt;span&gt;,
    &quot;module&quot;: &quot;esnext&quot;&lt;span&gt;,
    &quot;strict&quot;: &lt;span&gt;true&lt;span&gt;,
    &quot;jsx&quot;: &quot;preserve&quot;&lt;span&gt;,
    &quot;importHelpers&quot;: &lt;span&gt;true&lt;span&gt;,
    &quot;moduleResolution&quot;: &quot;node&quot;&lt;span&gt;,
    &quot;experimentalDecorators&quot;: &lt;span&gt;true&lt;span&gt;,
    &quot;esModuleInterop&quot;: &lt;span&gt;true&lt;span&gt;,
    &quot;allowSyntheticDefaultImports&quot;: &lt;span&gt;true&lt;span&gt;,
    &quot;sourceMap&quot;: &lt;span&gt;true&lt;span&gt;,
    &quot;baseUrl&quot;: &quot;.&quot;&lt;span&gt;,
    &lt;span&gt;&quot;typeRoots&quot;: [&quot;/@types&quot;, &quot;./node_modules/@types&quot;],
    &quot;types&quot;: [&quot;webpack-env&quot;&lt;span&gt;],
    &quot;paths&quot;&lt;span&gt;: {
      &quot;@/*&quot;: [&quot;src/*&quot;&lt;span&gt;]
    },
    &quot;lib&quot;: [&quot;esnext&quot;, &quot;dom&quot;, &quot;dom.iterable&quot;, &quot;scripthost&quot;&lt;span&gt;]
  },
  &quot;include&quot;&lt;span&gt;: [
    &quot;src/**/*.ts&quot;&lt;span&gt;,
    &quot;src/**/*.tsx&quot;&lt;span&gt;,
    &quot;src/**/*.vue&quot;&lt;span&gt;,
    &quot;tests/**/*.ts&quot;&lt;span&gt;,
    &quot;tests/**/*.tsx&quot;&lt;span&gt;
  ],
  &quot;exclude&quot;: [&quot;node_modules&quot;&lt;span&gt;]
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　vue.config.js代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
'use strict'&lt;span&gt;;
&lt;span&gt;//&lt;span&gt; Template version: 1.3.1&lt;span&gt;
//&lt;span&gt; see http://vuejs-templates.github.io/webpack for documentation.
&lt;span&gt;
const UglifyJsPlugin = require('uglifyjs-webpack-plugin'&lt;span&gt;&lt;span&gt;);
const webpack = require('webpack'&lt;span&gt;);
const path = require('path'&lt;span&gt;);
const resolve = (dir) =&amp;gt;&lt;span&gt; path.resolve(__dirname, dir);
module.exports =&lt;span&gt; {
  &lt;span&gt;//&lt;span&gt; 修改 src 目录 为 examples 目录
&lt;span&gt;  pages: {
    index: {
     &lt;span&gt; entry: &lt;span&gt;'examples/main.ts'&lt;span&gt;&lt;span&gt;,
      template: 'public/index.html'&lt;span&gt;,
      filename: 'index.html'&lt;span&gt;,
    },
  },
  &lt;span&gt;//&lt;span&gt; vue 通过 file-loader 用版本哈希值和正确的公共基础路径来决定最终的图片路径，再用 url-loader 将小于 4kb 的
  &lt;span&gt;//&lt;span&gt; 图片内联，以减少 HTTP 请求的数量。所以我们可以通过 chainWebpack 调整图片的大小限制。例如，我们将
  &lt;span&gt;//&lt;span&gt; 图片大小限制设置为 13kb，低于13kb的图片全部被内联，高于13kb的图片会放在单独的img文件夹中。
  chainWebpack: (config) =&amp;gt;&lt;span&gt; {
    const imagesRule = config.module.rule('images'&lt;span&gt;);
    imagesRule
      .use('url-loader'&lt;span&gt;)
      .loader('url-loader'&lt;span&gt;)
      .tap((options) =&amp;gt; Object.assign(options, { limit: 13312&lt;span&gt; }));
  },
  &lt;span&gt;//&lt;span&gt; 设置css: { extract: false },可以强制内联，就不会将css单独打包成一个文件，导致页面没有style
  css: { extract: &lt;span&gt;false&lt;span&gt; },
  productionSourceMap: &lt;span&gt;false&lt;span&gt;,
};&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　 说明：UglifyJS Webpack Plugin插件用来缩小（压缩优化）js文件，修改应用入口文件，examples/main.ts，方便执行npm run serve的时候，可以直接查看组件的示例。&lt;/p&gt;
&lt;p&gt;　.npmignore可以将一些不需要发布到npm的文件忽略掉，.npmignore配置如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
.*&lt;span&gt;
package-&lt;span&gt;lock.json
/.git/
/.vscode/&lt;span&gt;
tslint.json
tsconfig.json
*&lt;span&gt;.log

.DS_Store
/dist&lt;span&gt;
/examples&lt;span&gt;
/node_modules&lt;span&gt;
/public&lt;span&gt;
/src&lt;span&gt;
/tests
&lt;span&gt;.browserslistrc
jest.config.js
vue.config.js

# local env files
.env.local
.env.*&lt;span&gt;.local

# Log files
npm-debug.log*&lt;span&gt;
yarn-debug.log*&lt;span&gt;
yarn-error.log*&lt;span&gt;

# Editor directories and files
.idea
.vscode
.gitignore
.npmignore
.npmrc
*&lt;span&gt;.suo
*.ntvs*
*&lt;span&gt;.njsproj
*&lt;span&gt;.sln
*.sw?&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　components下面&lt;/p&gt;
&lt;p&gt;　　index.ts代码，以插件的形式进行封装，方便全局引用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
import jieEcharts from './jie-echarts.vue'&lt;span&gt;;

(jieEcharts as any).install = (Vue: any) =&amp;gt;&lt;span&gt; {
  Vue.component(jieEcharts.name, jieEcharts);
};

export &lt;span&gt;default jieEcharts;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　jie-echarts.vue，是组件源码，代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&amp;lt;template&amp;gt;
  &amp;lt;!-- 每一个图表都有自己唯一的id,需要动态传入。 --&amp;gt;
  &amp;lt;div :ref=&quot;id&quot; :id=&quot;id&quot; :class=&quot;myclass&quot; :style=&quot;style&quot; /&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script lang=&quot;ts&quot;&amp;gt;&lt;span&gt;
import { Component, Vue, Prop, Watch } from &quot;vue-property-decorator&quot;&lt;span&gt;;
import Echarts from &quot;echarts&quot;&lt;span&gt;;
@Component({
  name: &quot;jie-echarts&quot;&lt;span&gt;
})
export &lt;span&gt;default&lt;span&gt; class extends Vue {
  @Prop({ &lt;span&gt;default: &quot;myCharts&quot; }) private id!&lt;span&gt;: string;
  @Prop({ &lt;span&gt;default: &quot;100%&quot; }) private width!&lt;span&gt;: string;
  @Prop({ &lt;span&gt;default: &quot;200px&quot; }) private height!&lt;span&gt;: string;
  @Prop({ &lt;span&gt;default: &quot;echarts-line&quot; }) private myclass!&lt;span&gt;: string;
  @Prop() private options!&lt;span&gt;: object;
  @Prop({ &lt;span&gt;default: &lt;span&gt;false }) private loading!: &lt;span&gt;boolean&lt;span&gt;;

  private MyEcharts: any = &lt;span&gt;null; &lt;span&gt;//&lt;span&gt; echarts实例
&lt;span&gt;
  created() {
    console.log(&quot;this.options :&amp;gt;&amp;gt; &quot;, &lt;span&gt;this&lt;span&gt;.options);
  }
  mounted() {
    &lt;span&gt;this&lt;span&gt;.InitCharts();
  }

  get style() {
    &lt;span&gt;return&lt;span&gt; {
      height: &lt;span&gt;this&lt;span&gt;.height,
      width: &lt;span&gt;this&lt;span&gt;.width
    };
  }
  @Watch(&quot;options&quot;, { deep: &lt;span&gt;true&lt;span&gt; })
  onChangeOption(newVal: string, oldVal: string) {
    &lt;span&gt;if (&lt;span&gt;this&lt;span&gt;.MyEcharts) {
      &lt;span&gt;if&lt;span&gt; (newVal) {
        &lt;span&gt;//&lt;span&gt; console.log(JSON.stringify(newVal))
        &lt;span&gt;this.MyEcharts.setOption(newVal, &lt;span&gt;true&lt;span&gt;);
      } &lt;span&gt;else&lt;span&gt; {
        &lt;span&gt;this.MyEcharts.setOption(oldVal, &lt;span&gt;true&lt;span&gt;);
      }
      setTimeout(() =&amp;gt;&lt;span&gt; {
        &lt;span&gt;this&lt;span&gt;.MyEcharts.resize();
      });
    } &lt;span&gt;else&lt;span&gt; {
      &lt;span&gt;this&lt;span&gt;.InitCharts();
    }
  }
  @Watch(&quot;height&quot;&lt;span&gt;)
  onChangeHeight(val: string) {
    &lt;span&gt;if&lt;span&gt; (val) {
      &lt;span&gt;this.height =&lt;span&gt; val;
    }
    &lt;span&gt;if (&lt;span&gt;this&lt;span&gt;.MyEcharts) {
      &lt;span&gt;this.MyEcharts.setOption(&lt;span&gt;this.options, &lt;span&gt;true&lt;span&gt;);
    } &lt;span&gt;else&lt;span&gt; {
      &lt;span&gt;this&lt;span&gt;.InitCharts();
    }
  }
  @Watch(&quot;loading&quot;&lt;span&gt;)
  onChangeLoading(val: &lt;span&gt;boolean&lt;span&gt;) {
    &lt;span&gt;if (val == &lt;span&gt;true&lt;span&gt;) {
      &lt;span&gt;this&lt;span&gt;.showLoading();
    }
    &lt;span&gt;if (val == &lt;span&gt;false&lt;span&gt;) {
      &lt;span&gt;this&lt;span&gt;.hideLoading();
    }
  }
  &lt;span&gt;//&lt;span&gt;-----------------------method----------------------
  &lt;span&gt;//&lt;span&gt; 组件初始化
&lt;span&gt;  private InitCharts() {
    const dom: any = &lt;span&gt;this.$refs[&lt;span&gt;this.id] as HTMLDivElement; &lt;span&gt;//&lt;span&gt; document.getElementById(this.id);
    &lt;span&gt;this.MyEcharts =&lt;span&gt; Echarts.init(dom);
    &lt;span&gt;if (&lt;span&gt;this.loading == &lt;span&gt;true&lt;span&gt;) {
      &lt;span&gt;this&lt;span&gt;.showLoading();
    }
    &lt;span&gt;/*&lt;span&gt;*
     * 此方法适用于所有项目的图表，但是每个配置都需要在父组件传进来，相当于每个图表的配置都需要写一遍，不是特别的省代码，主要是灵活度高
     * echarts的配置项，你可以直接在外边配置好，直接扔进来一个this.option
     &lt;span&gt;*/
    &lt;span&gt;this.MyEcharts.clear(); &lt;span&gt;//&lt;span&gt; 适用于大数据量的切换时图表绘制错误,先清空在重绘
    &lt;span&gt;this.MyEcharts.setOption(&lt;span&gt;this.options, &lt;span&gt;true); &lt;span&gt;//&lt;span&gt; 设置为true可以是图表切换数据时重新渲染
  &lt;span&gt;  setTimeout(() =&amp;gt;&lt;/span&gt;&lt;span&gt; {
      &lt;span&gt;this&lt;span&gt;.MyEcharts.resize();
    });
    &lt;span&gt;//&lt;span&gt; 当窗口变化时随浏览器大小而改变
   &lt;span&gt; window.addEventListener(&quot;resize&quot;, () =&amp;gt;&lt;/span&gt;&lt;span&gt; {
      &lt;span&gt;this&lt;span&gt;.MyEcharts.resize();
    });
    &lt;span&gt;this.MyEcharts.on(&quot;click&quot;, (params: any) =&amp;gt;&lt;span&gt; {
      &lt;span&gt;this&lt;span&gt;.mapClick(params);
    });
  }
  &lt;span&gt;//&lt;span&gt;组件单击事件
&lt;span&gt;  private mapClick(params: any) {
    &lt;span&gt;//&lt;span&gt; console.log(params, 999999);
   &lt;span&gt; const data =&lt;/span&gt;&lt;span&gt; {
      color: params.color,
      data: params.data,
      dataIndex: params.dataIndex,
      seriesIndex: params.seriesIndex,
      chartType: params.componentSubType
    };
    &lt;span&gt;this.$parent.$emit(&quot;chartParams&quot;&lt;span&gt;, JSON.stringify(data));
    &lt;span&gt;if (params.seriesType == &quot;map&quot;&lt;span&gt;) {
      &lt;span&gt;this.$emit(&quot;mapValue&quot;&lt;span&gt;, params.name);
    } &lt;span&gt;&lt;span&gt;
      &lt;span&gt;this.$emit(&quot;eclick&quot;&lt;span&gt;, params);
  }
  private showLoading() {
    &lt;span&gt;if (&lt;span&gt;this&lt;span&gt;.MyEcharts) {
      &lt;span&gt;this&lt;span&gt;.MyEcharts.showLoading({
        text: &quot;loading&quot;
        &lt;span&gt;//&lt;span&gt; color: '#4cbbff',
        &lt;span&gt;//&lt;span&gt; textColor: '#4cbbff',
&lt;span&gt;      });
    }
  }
  private hideLoading() {
    &lt;span&gt;if (&lt;span&gt;this&lt;span&gt;.MyEcharts) {
      &lt;span&gt;this&lt;span&gt;.MyEcharts.hideLoading();
    }
  }
}
&amp;lt;/script&amp;gt;
&amp;lt;style lang=&quot;scss&quot; scoped&amp;gt;&lt;span&gt;
.echarts-&lt;span&gt;line {
  height: 100%&lt;span&gt;;
}
&amp;lt;/style&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　@types目录下：&lt;/p&gt;
&lt;p&gt;　　component.d.ts代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
import Vue from 'vue'&lt;span&gt;;

export class VanComponent {
  static name: string;
  static install(vue: &lt;span&gt;typeof Vue): &lt;span&gt;void&lt;span&gt;;
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：@types是npm的一个分支，当我们把npm包发上去，npm包就会托管到服务器，供大家下载，但是ts为了代码的可复用性，要申明一些静态类型文件，那些文件就是*.d.ts&lt;/p&gt;
&lt;p&gt;　　shims-vue.d.ts代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
declare module &quot;*.vue&quot;&lt;span&gt; {
  import Vue from &quot;vue&quot;&lt;span&gt;;
  export &lt;span&gt;default&lt;span&gt; Vue;
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　App.vue代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
&amp;lt;template&amp;gt;
  &amp;lt;div id=&quot;app&quot;&amp;gt;
    &amp;lt;jie-echarts :options=&quot;echartsOptions&quot;&amp;gt;&amp;lt;/jie-echarts&amp;gt;
    &amp;lt;!-- &amp;lt;router-view /&amp;gt; --&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script lang=&quot;ts&quot;&amp;gt;&lt;span&gt;
import { Component, Vue, Watch, Prop } from &quot;vue-property-decorator&quot;&lt;span&gt;;
import jieEcharts from &quot;../src/index&quot;&lt;span&gt;;
@Component({
  components: {
    jieEcharts
  }
})
export &lt;span&gt;default&lt;span&gt; class TestJieEchartsPreview extends Vue {
  protected echartsOptions =&lt;span&gt; {
    xAxis: {
      type: &quot;category&quot;&lt;span&gt;,
      data: [&quot;Mon&quot;, &quot;Tue&quot;, &quot;Wed&quot;, &quot;Thu&quot;, &quot;Fri&quot;, &quot;Sat&quot;, &quot;Sun&quot;&lt;span&gt;]
    },
    yAxis: {
      type: &quot;value&quot;&lt;span&gt;
    },
    series: [
      {
        data: [820, 932, 901, 934, 1290, 1330, 1320&lt;span&gt;],
        type: &quot;line&quot;&lt;span&gt;
      }
    ]
  };
}
&amp;lt;/script&amp;gt;
&amp;lt;style lang=&quot;scss&quot;&amp;gt;&lt;span&gt;
#app {
  font-family: Avenir, Helvetica, Arial, sans-&lt;span&gt;serif;
  -webkit-font-&lt;span&gt;smoothing: antialiased;
  -moz-osx-font-&lt;span&gt;smoothing: grayscale;
  text-&lt;span&gt;align: center;
  color: #2c3e50;
}

#nav {
  padding: 30px;

  a {
    font-&lt;span&gt;weight: bold;
    color: #2c3e50;

    &amp;amp;.router-link-exact-&lt;span&gt;active {
      color: #42b983;
    }
  }
}
&amp;lt;/style&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　执行npm run serve，运行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/413851/202007/413851-20200731134613168-700978222.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;发布到NPM&lt;/h2&gt;

&lt;p&gt;　　2.登录邮箱，点击激活连接&lt;/p&gt;
&lt;div readability=&quot;16.5&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/413851/202007/413851-20200731132303812-1520119638.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;　　3.执行npm login，进行登录&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
PS E:\vue_codes\my-project-name&amp;gt;&lt;span&gt; npm login
Username: zouyujie
Password:
Email: (&lt;span&gt;this IS public) zouyujie@126.com&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　如果你是使用的淘宝镜像，注意啊要先切换到npm官网镜像，切换方式：npm config set registry https://registry.npmjs.org/&lt;/p&gt;
&lt;p&gt;　　4.执行命令 npm publish，进行发布，如果出现如下图所示错误：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/413851/202007/413851-20200731132444824-1015226247.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　说明邮箱没有绑定成功，点击https://www.npmjs.com/email-edit，进行绑定，然后重新执行npm publish，运行结果如下：&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;20.69497716895&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
PS E:\vue_codes\my-project-name&amp;gt;&lt;span&gt; npm publish
npm notice 
npm notice package: jie-echarts@0.1.0&lt;span&gt;
npm notice === Tarball Contents ===&lt;span&gt;
npm notice 632B    dist/index.&lt;span&gt;html
npm notice 4.3kB   dist/favicon.&lt;span&gt;ico
npm notice 66B     babel.config.&lt;span&gt;js
npm notice 965.0kB dist/js/chunk-vendors.80f39f1d.&lt;span&gt;js
npm notice 6.3kB   dist/js/index.f9222971.&lt;span&gt;js
npm notice 1.4kB   package.&lt;span&gt;json
npm notice 327B    README.&lt;span&gt;md&lt;span&gt;
npm notice === Tarball Details ===&lt;span&gt;
npm notice name:          jie-echarts
npm notice version:       0.1.0&lt;span&gt;
npm notice package size:  341.3&lt;span&gt; kB
npm notice unpacked size: 978.0&lt;span&gt; kB
npm notice shasum:        2b65bfa887ba4677dc95a36a4b0403ebfecc9fde
npm notice integrity:     sha512-RwSE3lC8N3wZT[...]b1b9cvJ8UtL/w==&lt;span&gt;
npm notice total &lt;span&gt;files:   7&lt;span&gt;
npm notice
+ jie-echarts@0.1.0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　至此，npm发布成功。&lt;/p&gt;
&lt;p&gt;　　然后我们去npm上，查看我们发布的npm包，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/413851/202007/413851-20200731132619434-169405683.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　 如果能看到如下图所示界面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/413851/202007/413851-20200731132657788-1887990657.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　说明已发布成功。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　注意：&lt;/strong&gt;每次重新发布都要记得修改一下版本号，否则会发布失败。&lt;/p&gt;
&lt;p&gt;　　npm上地址：&lt;a href=&quot;https://www.npmjs.com/package/jie-echarts&quot; target=&quot;_blank&quot;&gt;https://www.npmjs.com/package/jie-echarts&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;安装jie-echarts&lt;/h2&gt;
&lt;p&gt;     npm i jie-echarts&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Mon, 03 Aug 2020 00:37:00 +0000</pubDate>
<dc:creator>邹琼俊</dc:creator>
<og:description>基于vue cli创建一个vue项目 首先安装最新的vue cli脚手架， npm install --global @vue/cli npm WARN optional SKIPPING OPTIO</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jiekzou/p/13424352.html</dc:identifier>
</item>
<item>
<title>Web优化躬行记（3）——图像和网络 - 咖啡机（K.F.J）</title>
<link>http://www.cnblogs.com/strick/p/13218126.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/strick/p/13218126.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）响应式图像&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　浏览器根据屏幕大小、设备像素比、横竖屏自动加载合适的图像。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;响应式的功能&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;可以通过srcset和sizes两个新属性实现。&lt;/p&gt;
&lt;p&gt;　　前者可指定选择的图像以及其大小，后者会定义一组媒体条件并声明填充的宽度。&lt;/p&gt;
&lt;p&gt;　　在下面的示例中（&lt;span&gt;&lt;a href=&quot;https://mdn.github.io/learning-area/html/multimedia-and-embedding/responsive-images/responsive.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;在线查看效果&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;），浏览器会先查看设备宽度，然后检查sizes列表中哪个媒体条件第一个为真，再查看该媒体查询的填充宽度，最后从加载的srcset列表中引用宽度最接近的图像。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;srcset&lt;/span&gt;&lt;span&gt;=&quot;elva-fairy-320w.jpg 320w,
             elva-fairy-480w.jpg 480w,
             elva-fairy-800w.jpg 800w&quot;&lt;/span&gt;&lt;span&gt;
     sizes&lt;/span&gt;&lt;span&gt;=&quot;(max-width: 320px) 280px,
            (max-width: 480px) 440px,
            800px&quot;&lt;/span&gt;&lt;span&gt;
     src&lt;/span&gt;&lt;span&gt;=&quot;elva-fairy-800w.jpg&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）懒加载&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/strick/p/5372694.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;懒加载&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;就是当滚动到页面某个位置后，再显示当前位置的图像，这样做可以减少页面请求。&lt;/p&gt;
&lt;p&gt;　　预加载就是通过Image对象，给这个对象添加src属性，以JavaScript的方式请求图像，并可以缓存此对象，以后再用。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3）渐进加载&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　渐进加载是指先加载低质量甚至模糊的图片，然后随着页面继续加载，使用&lt;span&gt;&lt;a href=&quot;https://github.com/zouhir/lqip&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;LQIP&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;（低质量图片占位符）技术替换为高质量的完整版本。&lt;/p&gt;
&lt;p&gt;　　这种技术确实提高了首次进行有意义绘制的时间。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4）压缩&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　除了可通过剥离元数据（例如时间、地点等）的方式压缩图像之外，还可以将图像画到Canvas中，然后选择质量输出，从而实现压缩。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;5）雪碧图&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　CSS Sprite是一种图像处理技术，将零散的小图标整合在一起，形成成一张大图，这张图可称为雪碧图或精灵图。&lt;/p&gt;
&lt;p&gt;　　当用这张大图做背景图像时，可以利用background-position属性进行背景定位，找到想要的小图标。&lt;/p&gt;
&lt;p&gt;　　这么处理图像，不但可以解决命名困扰，还能减少HTTP请求数，降低图像字节，提升网页性能。&lt;/p&gt;
&lt;p&gt;　　参照下面的最佳实践，可将雪碧图优化得尽可能小：&lt;/p&gt;
&lt;p&gt;　　1. 按照颜色合并。&lt;/p&gt;
&lt;p&gt;　　2. 避免不必要的空白。&lt;/p&gt;
&lt;p&gt;　　3. 将元素水平排列。&lt;/p&gt;
&lt;p&gt;　　4. 将颜色限制在256种以内。&lt;/p&gt;
&lt;p&gt;　　5. 先优化单独的图像，再优化雪碧图。&lt;/p&gt;
&lt;p&gt;　　6. 通过控制大小和对齐减少反锯齿像素的数量。&lt;/p&gt;
&lt;p&gt;　　7. 避免使用对角线渐变，这种渐变无法被平铺。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;6）WebP&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;a href=&quot;https://developers.google.com/speed/webp&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;WebP&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;由Google引入，是一种支持有损压缩和无损压缩的图片文件格式，派生自图像编码格式VP8。&lt;/p&gt;
&lt;p&gt;　　根据Google的测试，无损压缩后的WebP比PNG文件少了45％的文件大小，即使这些PNG文件经过其他压缩工具压缩之后，WebP还是可以减少28％的文件大小。&lt;/p&gt;
&lt;p&gt;　　WebP不支持像JPEG那样的渐进式渲染，这导致用户使用好的JPEG可能会更快地看到实际图像，尽管WebP图像的网络加载速度可能会更快。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;7）icon font&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;a href=&quot;https://www.iconfont.cn/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;图标字体&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;（icon font）就是将图标做成字体，使用时与普通字体无异。&lt;/p&gt;
&lt;p&gt;　　换成字体后，颜色、阴影、翻转、大小和对齐等功能都能用CSS属性控制，比图像灵活很多，并且缩放还不会失真，同时兼容IE6，并且生成的文件特别小。&lt;/p&gt;
&lt;p&gt;　　使用&lt;span&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/CSS/@font-face/font-display&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;font-display&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;这个CSS属性来控制字体的加载行为并使内容立即（font-display: optional）或几乎立即（font-display: swap）可读。&lt;/p&gt;
&lt;p&gt;　　字体加载&lt;span&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/Document/fonts&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;API&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;用JavaScript来控制如何加载字体，提供了很大的自由度来决定如何将字体应用于文档。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
document.fonts.load(&quot;1em Open Sans Light&quot;);        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;加载字体&lt;/span&gt;
document.fonts.load(&quot;1em Open Sans Bold&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在所有指定的字体都加载后运行&lt;/span&gt;
document.fonts.ready.then(&lt;span&gt;function&lt;/span&gt;(fontFaceSet) { });
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）GZip压缩&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　通过添加HTTP首部来向Web服务器声明支持压缩。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Accept-Encoding: gzip, deflate
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　Web服务器会返回一个经过压缩的响应。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
Content-Encoding: gzip
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　GZip对于要压缩的文件，首先使用LZ77算法，然后对得到的结果再使用Huffman编码的方法进行压缩。&lt;/p&gt;
&lt;p&gt;　　LZ77算法过程如下：&lt;/p&gt;
&lt;p&gt;　　1. 如果文件中有两块内容相同的话，那么只要知道前一块的位置和大小，就可以确定后一块的内容。&lt;/p&gt;
&lt;p&gt;　　2. 可以用这样一对信息（两者之间的距离，相同内容的长度），来替换后一块内容。&lt;/p&gt;
&lt;p&gt;　　3. 由于这一对信息的大小，小于被替换内容的大小，所以文件得到了压缩。&lt;/p&gt;
&lt;p&gt;　　Huffman编码过程如下：&lt;/p&gt;
&lt;p&gt;　　1. 把文件中一定位长的值看作是符号，例如把8位长的256种值，也就是字节的256种值看作是符号。&lt;/p&gt;
&lt;p&gt;　　2. 根据这些符号在文件中出现的频率，对这些符号重新编码。&lt;/p&gt;
&lt;p&gt;　　3. 对于出现次数非常多的，用较少的位来表示，对于出现次数非常少的，用较多的位来表示。&lt;/p&gt;
&lt;p&gt;　　4. 这样一来，文件的一些部分位数变少了，一些部分位数变多了。&lt;/p&gt;
&lt;p&gt;　　5. 由于变小的部分比变大的部分多，所以整个文件的大小还是会减小，文件得到了压缩。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）Brotli压缩&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　2015年，Google推出了Brotli，这是一种全新的开源无损数据格式，并被现在所有现代浏览器支持。&lt;/p&gt;
&lt;p&gt;　　尽管Brotli在某些方面的性能与GZip相当，但它显示出了良好的前景，并在不断地发展中。&lt;/p&gt;
&lt;p&gt;　　如果浏览器支持Brotli，那么在请求首部中会将br令牌包含在可接受的编码列表中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
Accept-Encoding: gzip, deflate, br
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　GZip的压缩级别可指定0~9的整数来配置，而Brotli的范围是0~11。&lt;/p&gt;
&lt;p&gt;　　注意，使用Brotli压缩所有资源非常耗费计算资源和时间，在最高压缩级别下，会让服务器等待动态资源，服务器开始发送响应所花费的时间会抵消文件大小减少带来的任何潜在收益。&lt;/p&gt;
&lt;p&gt;　　如果可以避开动态压缩静态资源的成本，那么Brotli就是值得的。&lt;/p&gt;
&lt;p&gt;　　Brotli可用于任何纯文本的内容（HTML、CSS、SVG、JavaScript等），并且其性能相比GZip提高了17-25%。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3）DNS预读取&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　DNS预读取技术能够加快打开速度，方法是在head元素里写上几个link元素。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;link &lt;/span&gt;&lt;span&gt;rel&lt;/span&gt;&lt;span&gt;=&quot;dns-prefetch&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;http://www.pwstrick.com&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;link &lt;/span&gt;&lt;span&gt;rel&lt;/span&gt;&lt;span&gt;=&quot;dns-prefetch&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;http://www.home602.com&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　对以上几个网站提前解析DNS，由于是并行的，也就不会阻塞页面渲染。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4）缓存&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　缓存的处理过程可以简单的分为几步，首先在缓存中搜索指定资源的副本，如果命中就执行第二步；第二步就是对资源副本进行新鲜度检测（也就是文档是否过期），如果不新鲜就执行第三步；第三步是与服务器进行再验证，验证通过（即没有过期）就更新资源副本的新鲜度，再返回这个资源副本（此时的响应状态码为“304 Not Modified”），不通过就从服务器返回资源，再将最新资源的副本放入缓存中。&lt;/p&gt;
&lt;p&gt;　　HTTP缓存分为强缓存和协商缓存，前者的首部包括Cache-Control和Expires；后者会分为日期比对法（If-Modified-Since和Last-Modified）和实体标记法（If-None-Match和ETag）。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;5）CDN&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　CDN是在用户和服务器之间增加Cache层，将用户的访问请求引导到Cache节点而不是服务器源站点，要实现这一目的，主要是通过接管DNS实现。&lt;/p&gt;
&lt;p&gt;　　CDN可以在全球分发各类资源，并根据地理位置、接入网类型（电信还是网通）将用户的访问请求定位到离用户路由最短、位置最近、负载最轻的Cache节点（缓存服务器）上，实现就近定位，以此提升性能。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;6）并发请求&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　浏览器的并发请求数目限制是针对同一域名的。&lt;/p&gt;
&lt;p&gt;　　同一时间针对同一域名下的请求有一定数量限制（例如Chrome限制6条、IE11限制13条等），超过限制数目的请求会被阻塞。&lt;/p&gt;
&lt;p&gt;　　所以将不同静态资源（例如图片、JavaScript、CSS等）放在不同的域名下，就能增加并发请求的数量。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;7）HTTP/2.0&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　HTTP/2.0引入了全新的二进制分帧层，解决了队首阻塞问题，并且在一个域只需建立一次TCP连接，就能实现多路通信，不必进行资源排队，这样就不需要雪碧图或合并文件了。&lt;/p&gt;
&lt;p&gt;　　不仅如此，HTTP/2.0还有控制请求优先级、服务器主动推送和首部压缩等优点，&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;8）API性能优化&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　在设计和开发API时，需要一个合理的协议来实现服务器与第三方请求之间的通信。&lt;/p&gt;
&lt;p&gt;　　Restful API（REST）是一种广泛验证有效的选择：它定义了一组约束，开发人员可以遵循这些约束以使内容以高性能，可靠和可伸缩的方式进行访问。符合REST约束定义的Web服务称为RESTful Web服务。&lt;/p&gt;
&lt;p&gt;　　与普通的HTTP请求一样，当从API检索数据时，服务器响应中的任何延迟都将传播到最终用户，从而影响渲染。如果许多资源都需要来自某个API的数据，则该API可能会成为性能瓶颈。GraphQL为这些问题提供了高性能的解决方案。&lt;/p&gt;
&lt;p&gt;　　与REST不同，GraphQL可以在单个请求中检索所有数据，并且只响应所需的内容，而不会像REST通常那样过度或不足地获取数据。&lt;/p&gt;
&lt;p&gt;　　此外，因为GraphQL使用模式（Schema，定义数据结构的元数据），所以它可以提前将数据组织成所需的结构。因此在使用GraphQL后，就可以删除用于处理状态和数据结果的JavaScript代码，从而产生在客户端上运行更快更干净的应用程序代码。&lt;/p&gt;

</description>
<pubDate>Mon, 03 Aug 2020 00:35:00 +0000</pubDate>
<dc:creator>咖啡机（K.F.J）</dc:creator>
<og:description>一、图像 1）响应式图像 浏览器根据屏幕大小、设备像素比、横竖屏自动加载合适的图像。 响应式的功能可以通过srcset和sizes两个新属性实现。 前者可指定选择的图像以及其大小，后者会定义一组媒体条</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/strick/p/13218126.html</dc:identifier>
</item>
<item>
<title>MySql大表分页(附独门秘技) - trytocatch</title>
<link>http://www.cnblogs.com/trytocatch/p/mysql-page-query.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/trytocatch/p/mysql-page-query.html</guid>
<description>&lt;p&gt;本文通过三种方案，循序渐进地讲解了MySql中，InnoDB下的大表分页查询，通过原创技巧，达到了即简洁又高效&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;202.91305874093&quot;&gt;

&lt;h2&gt;问题背景&lt;/h2&gt;
&lt;p&gt;MySql(InnoDB)中的订单表需要按时间顺序分页查询，且主键不是时间维度递增，订单表在百万以上规模，此时如何高效地实现该需求？&lt;/p&gt;
&lt;p&gt;注：本文并非主要讲解如何建立索引，以下的分析均建立在有合适的索引的前提下&lt;/p&gt;
&lt;h2&gt;初步方案1&lt;/h2&gt;
&lt;p&gt;众所周知，MySql中，有一个limit offset, pageSize的用法，可以实现分页查询&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; &lt;span&gt;order&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; &lt;span&gt;user_id&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; xxx &lt;span&gt;and&lt;/span&gt; 【其它业务条件】 &lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; created_time, id limit offset, pageSize
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为created_time可能重复，所以order by时应加上id，保证顺序的确定性&lt;/p&gt;
&lt;h3&gt;点评&lt;/h3&gt;
&lt;p&gt;该方案在表规模较小的时候，不会暴露出问题，当order表增长到十万级，并且查询后面几页的时候，执行速度明显变慢，可能降到100ms的量级，如果数据量增长到百万级，则耗时达到秒级，如果增长到千万级，那耗时就变得完全不可接受了（曾排查过这样的线上慢SQL）&lt;/p&gt;

&lt;hr/&gt;&lt;h2&gt; 深入分析&lt;/h2&gt;
&lt;p&gt;方案1为啥在大表中表现这么差呢？我们可以来揣测一下MySql是怎么执行这个查询的&lt;/p&gt;
&lt;p&gt;假设我们在user_id，created_time，以及【其它业务条件】建立了联合索引，当我要查找第100000条到100049条的记录时，因为MySql的索引是b+ tree结构，不像数组可以随机定位到第N条记录，它需要花不小的成本去找到N的位置，N越大，成本越大&lt;/p&gt;
&lt;p&gt;抛开b+ tree的细节不讲，我们还可以借助统计表记录总数的SQL来理解&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;count&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;) &lt;span&gt;from&lt;/span&gt; &lt;span&gt;order&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果能非常高效地定位第N条记录，那么上述统计也能非常高效的执行，但实际上，在大表中统计记录总条数，也是非常慢的(本文是在InnoDB的场景下)&lt;/p&gt;
&lt;p&gt;方案1低效的根本原因在于：定位到offset的成本过高，未能充分利用索引的有序性&lt;/p&gt;

&lt;hr/&gt;&lt;h2&gt;方案2&lt;/h2&gt;
&lt;p&gt;索引(b+ tree)的特点在于，数据是有序的，虽然找到第N条记录的效率比较低，但找到某一条数据在索引中的位置，其效率是很高的（索引本来就是解决这个问题的）&lt;/p&gt;
&lt;p&gt;我们换一种思路，每次取50条记录，第一次取的时候，指定从上次结束的位置继续往后取50条，这样，我们便可以利用上索引的有序性了&lt;/p&gt;
&lt;p&gt;我们先看一个以id为序，进行分页查询的例子&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; &lt;span&gt;order&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; id &lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;pre max id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; id limit &lt;span&gt;50&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一次查询不用带条件，后续查询则传入前一次查询的最大id，简单分析可知，MySql在执行时，先定位到pre max id的位置(id是有序的，定位非常快)，然后从这往后取50条记录即可，整个过程非常高效&lt;/p&gt;

&lt;p&gt;我们回到最开始的问题，“按时间顺序分页查询，且主键不是时间维度递增”，此时我们不能用id作为分页的条件，因为按它去分页，便不是按时间顺序了，但也不能直接把id换成时间，因为时间可能会重复，我们来分析一下&lt;/p&gt;
&lt;table border=&quot;0&quot; align=&quot;left&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;id&lt;/td&gt;
&lt;td&gt;username&lt;/td&gt;
&lt;td&gt;created_time&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;xxx&lt;/td&gt;
&lt;td&gt;zhangsan&lt;/td&gt;
&lt;td&gt;2019-01-01&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;ddd&lt;/td&gt;
&lt;td&gt;zhangsan&lt;/td&gt;
&lt;td&gt;2019-02-03&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;yyy&lt;/td&gt;
&lt;td&gt;zhangsan&lt;/td&gt;
&lt;td&gt;2019-02-03&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;abc&lt;/td&gt;
&lt;td&gt;zhangsan&lt;/td&gt;
&lt;td&gt;2019-02-05&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;aaa&lt;/td&gt;
&lt;td&gt;zhangsan&lt;/td&gt;
&lt;td&gt;2020-08-01&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;







&lt;p&gt;假如前一次分页的最后一条记录为id=ddd的这条（created_time为2019-02-03），下一次查询使用created_time&amp;gt;2019-02-03作为条件时，则会把id=yyy的这条记录漏掉，如果换成created_time&amp;gt;=2019-02-03也不行，id=ddd的这条记录就又被查出来了&lt;/p&gt;
&lt;p&gt;对于这个数据遗漏或重复的问题，我看到一种解决方案是这样的：&lt;/p&gt;
&lt;p&gt;分三种情况进行查询&lt;/p&gt;
&lt;ol&gt;&lt;li readability=&quot;-1&quot;&gt;首次查询，created_time&amp;gt;='xxxx-xx-xx'，如果不要求以某时间开始，则无条件
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; &lt;span&gt;order&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; &lt;span&gt;user_id&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; xxx &lt;span&gt;and&lt;/span&gt; 【其它业务条件】 &lt;span&gt;and&lt;/span&gt; created_time &lt;span&gt;&amp;gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;xxxx-xx-xx&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; created_time, id limit pageSize
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;如果上次查询的记录条数等于pageSize，则用created_time和id的组合条件来查询，为了防止created_time在边界位置发生重复时漏掉数据
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; &lt;span&gt;order&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; &lt;span&gt;user_id&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; xxx &lt;span&gt;and&lt;/span&gt; 【其它业务条件】 &lt;span&gt;and&lt;/span&gt; created_time &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;created_time of latest recored&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; id &lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;id of latest recored&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; created_time, id limit pageSize
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;如果上次查询的记录数小于pageSize，并且上次查询是第二种查询，则仅用created_time来查询，
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; &lt;span&gt;order&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; &lt;span&gt;user_id&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; xxx &lt;span&gt;and&lt;/span&gt; 【其它业务条件】 &lt;span&gt;and&lt;/span&gt; created_time &amp;gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;created_time of latest recored&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; created_time, id limit pageSize
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;点评&lt;/h3&gt;
&lt;p&gt;上述方法确实可以解决漏掉数据或重复的问题，并且也有着不错的性能，但缺点也比较明显，查询过于复杂，得分情况执行不同的SQL，并且分页不稳定，中间查询出来的记录数可能小于pageSize，实际上后面还有数据&lt;/p&gt;

&lt;hr/&gt;&lt;h2&gt;进一步深入分析&lt;/h2&gt;
&lt;p&gt;我尝试在网上找过资料，只找到了以id为分页顺序，然后用id&amp;gt;'pre max id'这种方式来查，而我们要以可重复的created_time为分页顺序，如何写出简洁高效的SQL呢？&lt;/p&gt;

&lt;p&gt;如果要成为一个优秀的程序员，我觉得分析&amp;amp;解决新问题的能力，是必不可少的，即使在网上能找到解决方案，优秀的分析能力也有助于借鉴并结合自己的场景，优化出更好的个性化方案。&lt;/p&gt;

&lt;p&gt;我们在(user_id,created_time)建立了索引，并且我们知道InnoDB的辅助索引是包含了主键的，且主键一定不会重复，这意味着在索引上，每条记录的顺序是完全确定的，不存在重复的情况&lt;/p&gt;
&lt;p&gt;我们要分页的顺序跟此索引的顺序是吻合的，只需要沿着索引，一批一批地取数据就可以了，这是一个对索引很直接的利用，为什么现在我没办法做到？&lt;/p&gt;
&lt;p&gt;如果我是MySql的设计人员，针对这种很常见很直接的需求，我怎么去提供支持？还是说不支持？&lt;/p&gt;
&lt;p&gt;我举一个例子，像java中的基于排序的TreeSet，我猜它一定有floor和ceiling这样的方法(返回Set中，大于或小于指定元素的第一个元素)，这是基于排序的数据结构该有的东西，如果它没有，那早被人喷了然后加上去了&lt;/p&gt;
&lt;p&gt;回到索引的话题，这种直接的需求，它应该支持，否则说不过去，现在的问题变成了：用什么语法来，来实现在组合索引上，基于组合(user_id,created_time,id的组合)顺序的遍历？&lt;/p&gt;
&lt;p&gt;此时脑海里便回想起以前用过的(a,b) in ((1,2),(3,4),(7,4))这样的组合写法，然后猜测它也支持大于小于这类比较，跑去MySql中验证一下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; (&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;7&lt;/span&gt;)&lt;span&gt;&amp;gt;&lt;/span&gt;(&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;7&lt;/span&gt;),    (&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;)&lt;span&gt;&amp;gt;&lt;/span&gt;(&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;7&lt;/span&gt;),    (&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;8&lt;/span&gt;)&lt;span&gt;&amp;gt;&lt;/span&gt;(&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;7&lt;/span&gt;),    (&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;7&lt;/span&gt;)&lt;span&gt;&amp;gt;&lt;/span&gt;(&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;7&lt;/span&gt;),    (&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;)&lt;span&gt;&amp;gt;&lt;/span&gt;(&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;7&lt;/span&gt;&lt;span&gt;);
返回：
&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;    &lt;span&gt;0&lt;/span&gt;    &lt;span&gt;1&lt;/span&gt;    &lt;span&gt;1&lt;/span&gt;    &lt;span&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如此一来，这问题就变得和id&amp;gt;'pre max id'这种一样简单了。&lt;/p&gt;
&lt;p&gt;注：这种写法后来在官方文档中找到了对应的资料，官方称这类运算为“行比较”（row comparisons）&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_greater-than&quot;&gt;https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_greater-than&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt; 方案3&lt;/h2&gt;
&lt;p&gt;由于有(a,b)&amp;gt;(1,2)这种语法，所以可以写出简洁又高效的SQL&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; &lt;span&gt;order&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; &lt;span&gt;user_id&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; xxx &lt;span&gt;and&lt;/span&gt; 【其它业务条件】 &lt;span&gt;and&lt;/span&gt; (created_time, id) &lt;span&gt;&amp;gt;&lt;/span&gt; (created_time &lt;span&gt;and&lt;/span&gt; id &lt;span&gt;of&lt;/span&gt; latest recode) &lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; created_time, id limit pageSize
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此方式跟以id为序的分页查询是一样的，首次查询去掉组合条件即可，代码简洁，同时又可以利用上组合索引，十分高效，耗时稳定，不会因为遍历到末尾而性能降低&lt;/p&gt;

&lt;hr/&gt;&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;方案1在小表的情况下，简单方便，只用传页码和页大小即可，还可以随机跳到指定页，具有一定优势&lt;/p&gt;
&lt;p&gt;方案2和方案3在大表的情况下，有着优异的性能，以及稳定性，缺点是不能随机地跳转页面，需要传入上一页的排序字段。这个弊端在一定程度上可以规避，比如现在很多分页都是一页一页地往下翻，比如微博、朋友圈动态等，或者是分批处理全表数据，不需要随机跳转&lt;/p&gt;
&lt;p&gt;细心的同学可能发现，where条件里还有【其它业务条件】，这样还能正常走索引吗？是否会发生全表扫描？这个问题其实是可以规避的，有空再写一篇执行计划并不完全可靠的案例。&lt;/p&gt;
&lt;h4&gt;题外话&lt;/h4&gt;
&lt;p&gt;方案3的写法是我自己琢磨出来的，在网上也没找到类似的资料，算独门秘技吧，除此之外，我觉得同样很有价值的是【进一步深入分析】中的思考过程，如果养成这种思考习惯，有利于创新，去解决别人没遇到过的问题，在未知的领域，知道该从哪个方向去寻找答案；或者找到新的方法更好地去解决旧问题。&lt;/p&gt;
&lt;p&gt;如果本文有帮助到你，或者觉得有价值，麻烦点个赞，这样我会更有动力去更多地分享自己的经验&lt;/p&gt;

&lt;/div&gt;</description>
<pubDate>Mon, 03 Aug 2020 00:26:00 +0000</pubDate>
<dc:creator>trytocatch</dc:creator>
<og:description>本文通过三种方案，循序渐进地讲解了MySql中，InnoDB下的大表分页查询，通过原创技巧，达到了即简洁又高效</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/trytocatch/p/mysql-page-query.html</dc:identifier>
</item>
<item>
<title>[NewLife.Net]单机400万长连接压力测试 - 大石头</title>
<link>http://www.cnblogs.com/nnhy/p/net_100w.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nnhy/p/net_100w.html</guid>
<description>&lt;p&gt;对网络库NewLife.Net进行单机百万级长连接测试，并持续收发数据，检测网络库稳定性。 结论，8月1日晚达到200万，8月2日下午达到404万。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;188.39883076456&quot;&gt;

&lt;p&gt;对网络库NewLife.Net进行单机百万级长连接测试，并持续收发数据，检测网络库稳定性。&lt;/p&gt;
&lt;p&gt;【2020年8月1日晚上22点】&lt;/p&gt;
&lt;p&gt;先上源码：&lt;a href=&quot;https://github.com/NewLifeX/NewLife.Net&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;https://github.com/NewLifeX/NewLife.Net&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;结论，8月1日晚达到200万，8月2日下午达到404万。&lt;/p&gt;

&lt;p&gt;上一次百万级压测是2017年4月1日，失败了，只达到84.5万。后来做了一次吞吐量压测。&lt;/p&gt;

&lt;p&gt;自上一次百万级压测（2017.4.1）以来，网络库进行了诸多细节优化（没有调整架构），特别优化了内存拷贝和多线程操作。&lt;/p&gt;
&lt;p&gt;上次购买了20多台高配大数据服务器（16C64G和8C16G），每台发起5万Tcp长连接，纯人肉方式，相当累。这次从泥水佬那里学到本地配置多IP地址建立更多连接的方式，大大节省了服务器资源和人力成本。每台服务器设置20个IP，每个IP发起5万Tcp长连接。&lt;/p&gt;
&lt;p&gt;测试程序也从.Net 4.5升级到了.Net Core 3.1，性能提升可观。&lt;/p&gt;


&lt;p&gt;阿里云上海区共购买6台12C24G的计算型C5服务器，按照抢占型实例购买，晚上特别便宜。平时3.7每小时的价格，现在0.355就可以拿到。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/1596304340633-493834b5-b54d-4879-8683-7fc035e769ab.png&quot; alt=&quot;image.png&quot; width=&quot;746&quot; height=&quot;501&quot; class=&quot;zoom-in-cursor&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这次压测对网络要求极高，所以选择的服务器必须有高带宽以及高PPS，务必是同一个机房，便于内网测试。&lt;/p&gt;
&lt;p&gt;第一次购买的002因为设置IP失误导致弄残了服务器，不得不释放重新购买。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/1596303189541-aa31776b-0736-40ab-a42c-d6c45f4c5eeb.png&quot; alt=&quot;image.png&quot; width=&quot;746&quot; height=&quot;201&quot; class=&quot;zoom-in-cursor&quot;/&gt;&lt;/p&gt;
&lt;p&gt;001~004配置多IP花了很长时间，后来才想到用命令批量设置。&lt;/p&gt;
&lt;p&gt;默认每个ECS只有一个私网IP，可以再增加9个，一共10个。&lt;/p&gt;
&lt;p&gt;经&lt;a class=&quot;referer&quot; href=&quot;https://my.oschina.net/u/944642&quot; target=&quot;_blank&quot;&gt;@景洋&lt;/a&gt; 提醒，ECS可以通过 绑定弹性网卡，得到20个IP地址，后面的005/002/006都有20个IP。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/1596336995491-870ccbbc-5235-41c4-b377-a5b0ec6c8c79.png&quot; alt=&quot;image.png&quot; width=&quot;729&quot; height=&quot;147&quot; class=&quot;zoom-in-cursor&quot;/&gt;&lt;/p&gt;


&lt;h2 id=&quot;h2_5&quot;&gt;优化Tcp参数&lt;/h2&gt;
&lt;p&gt;Windows默认只能使用5000个端口，需要优化Tcp参数设置。&lt;/p&gt;
&lt;p&gt;把码神工具拷贝到服务器，直接双击运行，工具-&amp;gt;网络调试工具，内容区点击右键，查看Tcp参数，可以看到MaxUserPort是5000，右键还有个“设置最大Tcp”把各个参数值设置为最优。无需重启，直接生效。&lt;/p&gt;
&lt;p&gt;码神工具也可以在这里下载，&lt;a href=&quot;http://x.newlifex.com/XCoder_Install.exe&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;http://x.newlifex.com/XCoder_Install.exe&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;码神工具源码：&lt;a href=&quot;https://github.com/NewLifeX/XCoder&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;https://github.com/NewLifeX/XCoder&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/1596301553063-9591496f-468a-417c-bf00-9d46b3b6be84.png&quot; alt=&quot;image.png&quot; width=&quot;587&quot; height=&quot;358&quot; class=&quot;zoom-in-cursor&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;h2_6&quot;&gt;安装.NET Core运行时&lt;/h2&gt;
&lt;p&gt;.NET Core 3.1.6 也需要拷贝上去安装，或者直接从 http://get.dot.net 下载。服务器网络非常快。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/1596337706477-2f07df1c-d2a7-4f7e-9b6d-4e8321b699bd.png&quot; alt=&quot;image.png&quot; width=&quot;494&quot; height=&quot;355&quot; class=&quot;zoom-in-cursor&quot;/&gt;&lt;/p&gt;


&lt;p&gt;为了增加每台测试端的连接数，我们需要用netsh命令增加IP地址。这些IP地址来自于ECS设置的辅助私网IP。请一定要申请辅助私网IP以后再去设置网卡，未申请的IP地址可能出问题，第一次购买的002就是这样残废了。&lt;/p&gt;

&lt;h2 id=&quot;h2_8&quot;&gt;设置主网卡辅助私网IP&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/1596337272632-a412b4eb-94f5-4398-90cf-d38fb26beb00.png&quot; alt=&quot;image.png&quot; width=&quot;580&quot; height=&quot;578&quot; class=&quot;zoom-in-cursor&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/1596337473558-cdac84ff-ee40-46ac-863a-6ddc7f3ef2bf.png&quot; alt=&quot;image.png&quot; width=&quot;314&quot; height=&quot;360&quot; class=&quot;zoom-in-cursor&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;h2_9&quot;&gt;设置弹性网卡辅助私网IP&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/1596337343221-98ce7508-927b-4dea-b884-5bcd976af79f.png&quot; alt=&quot;image.png&quot; width=&quot;252&quot; height=&quot;309&quot; class=&quot;zoom-in-cursor&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/1596337389483-26304514-89cb-4e84-bff5-ad71e75d51ad.png&quot; alt=&quot;image.png&quot; width=&quot;746&quot; height=&quot;188&quot; class=&quot;zoom-in-cursor&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/1596337411003-176811ab-336a-4bed-8965-e1626f983a90.png&quot; alt=&quot;image.png&quot; width=&quot;329&quot; height=&quot;407&quot; class=&quot;zoom-in-cursor&quot;/&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/1596337432410-23383d93-7c88-48b0-ad1b-8778ed3c8b2a.png&quot; alt=&quot;image.png&quot; width=&quot;309&quot; height=&quot;356&quot; class=&quot;zoom-in-cursor&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;h2_10&quot;&gt;NetBench002&lt;/h2&gt;
&lt;div&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;pre&gt;
netsh interface ip add address &quot;以太网&quot; 172.19.18.73 255.255.0.0 172.19.19.253
netsh interface ip add address &quot;以太网&quot; 172.19.18.75 255.255.0.0 172.19.19.253
netsh interface ip add address &quot;以太网&quot; 172.19.18.76 255.255.0.0 172.19.19.253
netsh interface ip add address &quot;以太网&quot; 172.19.18.77 255.255.0.0 172.19.19.253
netsh interface ip add address &quot;以太网&quot; 172.19.18.78 255.255.0.0 172.19.19.253
netsh interface ip add address &quot;以太网&quot; 172.19.18.79 255.255.0.0 172.19.19.253
netsh interface ip add address &quot;以太网&quot; 172.19.18.80 255.255.0.0 172.19.19.253
netsh interface ip add address &quot;以太网&quot; 172.19.18.81 255.255.0.0 172.19.19.253
netsh interface ip add address &quot;以太网&quot; 172.19.18.82 255.255.0.0 172.19.19.253
netsh interface ip add address &quot;以太网&quot; 172.19.18.83 255.255.0.0 172.19.19.253

netsh interface ip add address &quot;以太网 2&quot; 172.19.18.74 255.255.0.0 172.19.19.253
netsh interface ip add address &quot;以太网 2&quot; 172.19.18.84 255.255.0.0 172.19.19.253
netsh interface ip add address &quot;以太网 2&quot; 172.19.18.85 255.255.0.0 172.19.19.253
netsh interface ip add address &quot;以太网 2&quot; 172.19.18.86 255.255.0.0 172.19.19.253
netsh interface ip add address &quot;以太网 2&quot; 172.19.18.87 255.255.0.0 172.19.19.253
netsh interface ip add address &quot;以太网 2&quot; 172.19.18.88 255.255.0.0 172.19.19.253
netsh interface ip add address &quot;以太网 2&quot; 172.19.18.89 255.255.0.0 172.19.19.253
netsh interface ip add address &quot;以太网 2&quot; 172.19.18.90 255.255.0.0 172.19.19.253
netsh interface ip add address &quot;以太网 2&quot; 172.19.18.91 255.255.0.0 172.19.19.253
netsh interface ip add address &quot;以太网 2&quot; 172.19.18.92 255.255.0.0 172.19.19.253

netsh interface ip add dns name=&quot;以太网&quot; addr=100.100.2.136
netsh interface ip add dns name=&quot;以太网&quot; addr=100.100.2.138

netsh interface ip add dns name=&quot;以太网 2&quot; addr=100.100.2.136
netsh interface ip add dns name=&quot;以太网 2&quot; addr=100.100.2.138
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;h2 id=&quot;h2_11&quot;&gt;NetBench005&lt;/h2&gt;
&lt;div&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;pre&gt;
netsh interface ip add address &quot;以太网&quot; 172.19.18.53 255.255.0.0 172.19.19.253
netsh interface ip add address &quot;以太网&quot; 172.19.18.55 255.255.0.0 172.19.19.253
netsh interface ip add address &quot;以太网&quot; 172.19.18.56 255.255.0.0 172.19.19.253
netsh interface ip add address &quot;以太网&quot; 172.19.18.57 255.255.0.0 172.19.19.253
netsh interface ip add address &quot;以太网&quot; 172.19.18.58 255.255.0.0 172.19.19.253
netsh interface ip add address &quot;以太网&quot; 172.19.18.59 255.255.0.0 172.19.19.253
netsh interface ip add address &quot;以太网&quot; 172.19.18.60 255.255.0.0 172.19.19.253
netsh interface ip add address &quot;以太网&quot; 172.19.18.61 255.255.0.0 172.19.19.253
netsh interface ip add address &quot;以太网&quot; 172.19.18.62 255.255.0.0 172.19.19.253
netsh interface ip add address &quot;以太网&quot; 172.19.18.63 255.255.0.0 172.19.19.253

netsh interface ip add address &quot;以太网 2&quot; 172.19.18.54 255.255.0.0 172.19.19.253
netsh interface ip add address &quot;以太网 2&quot; 172.19.18.64 255.255.0.0 172.19.19.253
netsh interface ip add address &quot;以太网 2&quot; 172.19.18.65 255.255.0.0 172.19.19.253
netsh interface ip add address &quot;以太网 2&quot; 172.19.18.66 255.255.0.0 172.19.19.253
netsh interface ip add address &quot;以太网 2&quot; 172.19.18.67 255.255.0.0 172.19.19.253
netsh interface ip add address &quot;以太网 2&quot; 172.19.18.68 255.255.0.0 172.19.19.253
netsh interface ip add address &quot;以太网 2&quot; 172.19.18.69 255.255.0.0 172.19.19.253
netsh interface ip add address &quot;以太网 2&quot; 172.19.18.70 255.255.0.0 172.19.19.253
netsh interface ip add address &quot;以太网 2&quot; 172.19.18.71 255.255.0.0 172.19.19.253
netsh interface ip add address &quot;以太网 2&quot; 172.19.18.72 255.255.0.0 172.19.19.253

netsh interface ip add dns name=&quot;以太网&quot; addr=100.100.2.136
netsh interface ip add dns name=&quot;以太网&quot; addr=100.100.2.138

netsh interface ip add dns name=&quot;以太网 2&quot; addr=100.100.2.136
netsh interface ip add dns name=&quot;以太网 2&quot; addr=100.100.2.138
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;p&gt;我们采用网络库例程来充当测试程序。&lt;/p&gt;
&lt;p&gt;服务端，&lt;a href=&quot;https://github.com/NewLifeX/NewLife.Net/tree/master/EchoTest&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;https://github.com/NewLifeX/NewLife.Net/tree/master/EchoTest&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;客户端，&lt;a href=&quot;https://github.com/NewLifeX/NewLife.Net/tree/master/Benchmark&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;https://github.com/NewLifeX/NewLife.Net/tree/master/Benchmark&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;源代码在这里有详细讲解&lt;/p&gt;


&lt;p&gt;二者都需要Release编译，以减少调试日志输出。&lt;/p&gt;
&lt;p&gt;为了减少内存占用，我们需要修改配置文件`Config\Socket.config`，把缓冲区大小从64k改为1k&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;Socket&amp;gt;
  &amp;lt;!--网络调试--&amp;gt;
  &amp;lt;Debug&amp;gt;false&amp;lt;/Debug&amp;gt;
  &amp;lt;!--会话超时时间。默认20*60秒--&amp;gt;
  &amp;lt;SessionTimeout&amp;gt;7200&amp;lt;/SessionTimeout&amp;gt;
  &amp;lt;!--缓冲区大小。默认64k--&amp;gt;
  &amp;lt;BufferSize&amp;gt;1024&amp;lt;/BufferSize&amp;gt;
&amp;lt;/Socket&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;服务端客户端都要修改这个配置，否则内存占用过大。&lt;/p&gt;

&lt;p&gt;我们选定001作为主服务器，内网IP是172.19.18.4，拷贝EchoTest到服务器目录，双击跑起来，运行模式选择1，服务端，开始监听1234端口。&lt;/p&gt;
&lt;p&gt;002~006作为测试端，配置环境后，拷贝Bench到服务器目录，打开cmd，输入一下命令跑起来（以005为例）：&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;pre&gt;
netbench.exe -c 1000000 -n 1000 -i 30000 -b 172.19.18.53-72 tcp://172.19.18.4:1234
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;各参数解读如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;-c 1000000，表示100万并发，也就是100万个tcp连接。003/004只有10个私有IP，这里最高只能10*5w=50w&lt;/li&gt;
&lt;li&gt;-n 1000，每个连接收发1000次数据；&lt;/li&gt;
&lt;li&gt;-i 30000，两次收发数据之间间隔30秒；&lt;/li&gt;
&lt;li&gt;-b 172.19.18.53-72，发起连接时，绑定本地IP地址172.19.18.73到172.19.18.72，这些IP会均摊前面的100万&lt;/li&gt;
&lt;li&gt;tcp://172.19.18.4:1234，指定目标服务端的协议地址和端口&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;003和004各自贡献了50万连接，它们只有10个IP。&lt;/p&gt;
&lt;p&gt;服务端在0点45分达到100万在线，非常稳定，服务端和客户端没有出现任何错误。CPU和内存占用也很好。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/1596300316490-21a5ce0d-3b07-493b-a6a6-fd86361d1a58.png&quot; alt=&quot;image.png&quot; width=&quot;746&quot; height=&quot;359&quot; class=&quot;zoom-in-cursor&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/1596300774637-0d7ce82e-2002-4f3b-a088-ce65b7bd678e.png&quot; alt=&quot;image.png&quot; width=&quot;539&quot; height=&quot;239&quot; class=&quot;zoom-in-cursor&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/1596300792238-e37cb925-1b7f-4159-a441-1de378026f02.png&quot; alt=&quot;image.png&quot; width=&quot;541&quot; height=&quot;242&quot; class=&quot;zoom-in-cursor&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/1596300887194-60f2ef66-69ea-4254-9227-27bd134a43b2.png&quot; alt=&quot;image.png&quot; width=&quot;681&quot; height=&quot;234&quot; class=&quot;zoom-in-cursor&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/1596300903758-ee728ee6-9944-4584-a70f-7b5702208023.png&quot; alt=&quot;image.png&quot; width=&quot;541&quot; height=&quot;257&quot; class=&quot;zoom-in-cursor&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后这张网络图可以看到，前面测试百万连接是，增长很快，实际上导致了部分连接失败（&amp;lt;0.01%），后来加上参数控制了连接速度，才有稳步爬坡。&lt;/p&gt;


&lt;p&gt;在003/004达到100万长连接并维持30分钟后，先后开启005和002，预期朝着300万方向走。&lt;/p&gt;
&lt;p&gt;在1点19分左右，突破200万长连接。此时，CPU和内存的压力都很大，部分测试机的连接开始断开。&lt;/p&gt;
&lt;p&gt;经检查，主服务器内存不足，导致处理能力变弱，少量客户端认为连接超时，执行自动重连，让服务器压力加大，形成雪崩。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/1596302391069-2276f33e-20fc-45ed-9490-ec1e55872bb7.png&quot; alt=&quot;image.png&quot; width=&quot;746&quot; height=&quot;358&quot; class=&quot;zoom-in-cursor&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/1596302646214-516fb7a6-21a4-44c7-b62e-b8591611b86d.png&quot; alt=&quot;image.png&quot; width=&quot;538&quot; height=&quot;239&quot; class=&quot;zoom-in-cursor&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/1596302657038-96a7b1a5-7ec2-42c0-b883-9c3d5e9dac29.png&quot; alt=&quot;image.png&quot; width=&quot;539&quot; height=&quot;239&quot; class=&quot;zoom-in-cursor&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/1596302720737-ea59d632-355d-4270-845c-285820720c49.png&quot; alt=&quot;image.png&quot; width=&quot;684&quot; height=&quot;226&quot; class=&quot;zoom-in-cursor&quot;/&gt;&lt;/p&gt;


&lt;p&gt;超量完成了预期目标，100万=&amp;gt;200万。如果这次选择48G或96G内存作为主服务器，也许真有可能上300万长连接。&lt;/p&gt;
&lt;p&gt;2017年做的2266万tps吞吐量测试&lt;/p&gt;



&lt;p&gt;购买12C96G高配实例，杭州区便宜，编号NetBench007&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/1596338436275-9a0c4583-dcc9-44a4-bc72-776c8d64a3f7.png&quot; alt=&quot;image.png&quot; width=&quot;438&quot; height=&quot;80&quot; class=&quot;zoom-in-cursor&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;h2_17&quot;&gt;IP设置&lt;/h2&gt;
&lt;div&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;pre&gt;
netsh interface ip add address &quot;以太网&quot; 172.16.188.92 255.255.240.0 172.16.191.253
netsh interface ip add address &quot;以太网&quot; 172.16.188.94 255.255.240.0 172.16.191.253
netsh interface ip add address &quot;以太网&quot; 172.16.188.95 255.255.240.0 172.16.191.253
netsh interface ip add address &quot;以太网&quot; 172.16.188.96 255.255.240.0 172.16.191.253
netsh interface ip add address &quot;以太网&quot; 172.16.188.97 255.255.240.0 172.16.191.253
netsh interface ip add address &quot;以太网&quot; 172.16.188.98 255.255.240.0 172.16.191.253
netsh interface ip add address &quot;以太网&quot; 172.16.188.99 255.255.240.0 172.16.191.253
netsh interface ip add address &quot;以太网&quot; 172.16.188.100 255.255.240.0 172.16.191.253
netsh interface ip add address &quot;以太网&quot; 172.16.188.101 255.255.240.0 172.16.191.253
netsh interface ip add address &quot;以太网&quot; 172.16.188.102 255.255.240.0 172.16.191.253

netsh interface ip add address &quot;以太网 2&quot; 172.16.188.93 255.255.240.0 172.16.191.253
netsh interface ip add address &quot;以太网 2&quot; 172.16.188.103 255.255.240.0 172.16.191.253
netsh interface ip add address &quot;以太网 2&quot; 172.16.188.104 255.255.240.0 172.16.191.253
netsh interface ip add address &quot;以太网 2&quot; 172.16.188.105 255.255.240.0 172.16.191.253
netsh interface ip add address &quot;以太网 2&quot; 172.16.188.106 255.255.240.0 172.16.191.253
netsh interface ip add address &quot;以太网 2&quot; 172.16.188.107 255.255.240.0 172.16.191.253
netsh interface ip add address &quot;以太网 2&quot; 172.16.188.108 255.255.240.0 172.16.191.253
netsh interface ip add address &quot;以太网 2&quot; 172.16.188.109 255.255.240.0 172.16.191.253
netsh interface ip add address &quot;以太网 2&quot; 172.16.188.110 255.255.240.0 172.16.191.253
netsh interface ip add address &quot;以太网 2&quot; 172.16.188.111 255.255.240.0 172.16.191.253

netsh interface ip add dns name=&quot;以太网&quot; addr=100.100.2.136
netsh interface ip add dns name=&quot;以太网&quot; addr=100.100.2.138

netsh interface ip add dns name=&quot;以太网 2&quot; addr=100.100.2.136
netsh interface ip add dns name=&quot;以太网 2&quot; addr=100.100.2.138
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;h2 id=&quot;h2_18&quot;&gt;准备就绪&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/1596338689686-477de7d1-4ffd-4cb8-a362-c4e1255d0d36.png&quot; alt=&quot;image.png&quot; width=&quot;746&quot; height=&quot;522&quot; class=&quot;zoom-in-cursor&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;h2_19&quot;&gt;先来一个亿热身&lt;/h2&gt;
&lt;p&gt;开启100个并发连接，每个密集请求100万次，轻轻松松得到 130万tps 的吞吐&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/1596338846902-605bc42b-44be-4ce7-ae59-17e35b59d00d.png&quot; alt=&quot;image.png&quot; width=&quot;746&quot; height=&quot;375&quot; class=&quot;zoom-in-cursor&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用IPv6会更强一点&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/1596339347927-84f24079-f682-44c2-8148-396dbeae9026.png&quot; alt=&quot;image.png&quot; width=&quot;746&quot; height=&quot;228&quot; class=&quot;zoom-in-cursor&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;h2_20&quot;&gt;正式开始&lt;/h2&gt;
&lt;p&gt;本机压测命令&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;pre&gt;
netbench.exe -c 1000000 -n 10000 -i 60000 -b * tcp://127.0.0.1:1234
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;其中`-b *`表示绑定本机所有IP地址。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/1596339490834-9d1c78d8-b70a-44cd-b91f-3d1d354288cf.png&quot; alt=&quot;image.png&quot; width=&quot;746&quot; height=&quot;492&quot; class=&quot;zoom-in-cursor&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;h2_21&quot;&gt;3分钟轻松上100万&lt;/h2&gt;
&lt;p&gt;由于没有控制连接速度，期间有小量连接失败。控制台那里有日志时间，同时可以看到客户端服务端连接数一致。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/1596339700860-41e76162-73b4-4311-8d2e-7f4775bd77e4.png&quot; alt=&quot;image.png&quot; width=&quot;746&quot; height=&quot;513&quot; class=&quot;zoom-in-cursor&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们等它稳定一段时间，再去准备更多服务器&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/1596348903772-adecb193-5afa-4d9b-bc58-47478e99f3c9.png&quot; alt=&quot;image.png&quot; width=&quot;746&quot; height=&quot;483&quot; class=&quot;zoom-in-cursor&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从11:40开始，截止现在14:16，持续两个半小时。建立999742个连接，现存也是999742，最大值999743说明中途有一个连接断开，但是重连成功了。&lt;/p&gt;

&lt;h2 id=&quot;h2_22&quot;&gt;增加测试机资源&lt;/h2&gt;
&lt;p&gt;再买5台同样配置服务器，编号NetBench008~NetBench012&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/1596340772164-9f059c91-0569-4c2f-82e3-7f5d9e581284.png&quot; alt=&quot;image.png&quot; width=&quot;746&quot; height=&quot;246&quot; class=&quot;zoom-in-cursor&quot;/&gt;&lt;/p&gt;
&lt;p&gt;开始配置NetBench008，每次打命令太要命了，我们给码神工具增加一个批量设置IP的功能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/1596349061066-ed3b4673-d9d6-43bd-9d09-a67de5c55553.png&quot; alt=&quot;image.png&quot; width=&quot;425&quot; height=&quot;330&quot; class=&quot;zoom-in-cursor&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从阿里云ECS控制台把辅助私网IP复制过来，点击“设置IP”，即可把这些IP地址设置到网卡上。&lt;/p&gt;
&lt;p&gt;杭州区服务器的网络限制很严格（可能别的区也这样），在哪张网卡上申请的IP地址，只能设置到这张网卡上。即使每台服务器有两张网卡，也不能把各自的辅助私网IP设置错了，否则无法使用。&lt;/p&gt;


&lt;p&gt;服务端进程占用内存15G&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/1596354088047-a65853c1-313e-4969-a16b-9a583dd85daa.png&quot; alt=&quot;image.png&quot; width=&quot;746&quot; height=&quot;345&quot; class=&quot;zoom-in-cursor&quot;/&gt;&lt;/p&gt;


&lt;p&gt;服务器0核4核爆满&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/1596354936210-428c0a01-1144-4415-b86a-553a5c3aa08c.png&quot; alt=&quot;image.png&quot; width=&quot;746&quot; height=&quot;346&quot; class=&quot;zoom-in-cursor&quot;/&gt;&lt;/p&gt;
&lt;p&gt;15:56操作系统直接挂了，自动重启，连接数峰值404万。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/1596355530916-777e4f3f-4168-4a7a-a8f2-8a5cebdd65ff.png&quot; alt=&quot;image.png&quot; width=&quot;739&quot; height=&quot;473&quot; class=&quot;zoom-in-cursor&quot;/&gt;&lt;/p&gt;


&lt;p&gt;5台测试机，每台向服务端建立100个连接，每个连接发送100万个消息，每个端平均速度170万tps&lt;/p&gt;
&lt;p&gt;服务端总速度 170万*5=1050万tps&lt;/p&gt;
&lt;p&gt;CPU很满，网卡PPS太高&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/1596358045350-6d81d18c-8f4f-4181-af98-dd72f6b56297.png&quot; alt=&quot;image.png&quot; width=&quot;746&quot; height=&quot;365&quot; class=&quot;zoom-in-cursor&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/1596358154063-99f43417-690d-4e08-865d-fe55c71ffae5.png&quot; alt=&quot;image.png&quot; width=&quot;539&quot; height=&quot;239&quot; class=&quot;zoom-in-cursor&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/1596358188317-97a52d2c-3c3d-49aa-91e3-afd44c3c0b41.png&quot; alt=&quot;image.png&quot; width=&quot;657&quot; height=&quot;243&quot; class=&quot;zoom-in-cursor&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/1596358205837-7cddc2a1-a9fc-402d-94b8-1ef6bd438116.png&quot; alt=&quot;image.png&quot; width=&quot;536&quot; height=&quot;258&quot; class=&quot;zoom-in-cursor&quot;/&gt;&lt;/p&gt;

&lt;/div&gt;</description>
<pubDate>Mon, 03 Aug 2020 00:22:00 +0000</pubDate>
<dc:creator>大石头</dc:creator>
<og:description>对网络库NewLife.Net进行单机百万级长连接测试，并持续收发数据，检测网络库稳定性。 结论，8月1日晚达到200万，8月2日下午达到404万。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/nnhy/p/net_100w.html</dc:identifier>
</item>
<item>
<title>Java ServletContext详解 - 一只胡说八道的猴子</title>
<link>http://www.cnblogs.com/pjhaymy/p/13424324.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pjhaymy/p/13424324.html</guid>
<description>&lt;h2 id=&quot;java-servletcontext详解&quot;&gt;Java ServletContext详解&lt;/h2&gt;
&lt;h2 id=&quot;什么是servletcontext？&quot;&gt;什么是ServletContext？&lt;/h2&gt;
&lt;p&gt;根据字面意思即Servlet上下文&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200802224300861.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BqaDg4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;服务器会为每一个工程创建一个对象，这个对象就是ServletContext对象，这个对象是&lt;br/&gt;&lt;strong&gt;全局唯一&lt;/strong&gt;的，工程内部的所有servlet都共享这个对象，所有应用程序共享对象&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020080222574119.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BqaDg4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面用一段简单的代码来证明一下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
@WebServlet(&quot;/ServletContext2&quot;)
public class ServletContext2 extends HttpServlet{
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        ServletContext servletContext = this.getServletContext();
        System.out.println(&quot;ServletContext2的地址：&quot;);
        System.out.println(servletContext);
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        this.doGet(req, resp);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;import javax.servlet.RequestDispatcher;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
@WebServlet(&quot;/ServletContext&quot;)
public class ServletContext extends HttpServlet{
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        this.doPost(req, resp);
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        javax.servlet.ServletContext servletContext = this.getServletContext();
        System.out.println(&quot;ServletContext2的地址：&quot;);
        System.out.println(servletContext);
        RequestDispatcher servletContext2 = req.getRequestDispatcher(&quot;ServletContext2&quot;);
        servletContext2.forward(req,resp);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到二者的地址一模一样&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200802225247995.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BqaDg4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;servletcontext对象的生命周期&quot;&gt;ServletContext对象的生命周期&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;诞生&lt;/strong&gt;：web部署到服务器上，启动服务器，此时上下文环境对象创建，只要tomcat服务器不关闭，上下文环境对象就一直&lt;br/&gt;存在&lt;br/&gt;&lt;strong&gt;销毁&lt;/strong&gt;：关闭服务器或者是从web服务器上卸载该程序的时候，该对象销毁&lt;/p&gt;
&lt;h2 id=&quot;怎么创建servletcontext对象？&quot;&gt;怎么创建ServletContext对象？&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;方法一&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;javax.servlet.ServletContext servletContext = this.getServletContext();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;方法二&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt; javax.servlet.ServletContext servletContext1 = req.getServletContext();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;方法三&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;   javax.servlet.ServletContext servletContext3 = this.getServletConfig().getServletContext();
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;servletcontext对象的作用与相关方法&quot;&gt;ServletContext对象的作用与相关方法&lt;/h2&gt;
&lt;h2 id=&quot;1是一个域对象&quot;&gt;&lt;em&gt;1.是一个域对象&lt;/em&gt;*&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;什么是域&lt;/strong&gt;：域其实就是一个map结构，及存入一个键值对，来存储获取数据&lt;br/&gt;&lt;strong&gt;作用范围&lt;/strong&gt;：本工程内部&lt;br/&gt;域对象可以被本工程内所有的servlet对象共享，因为一个工程只有一个servletcontext对象&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法介绍&lt;/strong&gt;：&lt;br/&gt;&lt;strong&gt;存储数据&lt;/strong&gt;： void setAttribute(String var1, Object var2);&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;移除数据&lt;/strong&gt;： void removeAttribute(String var1);&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;获取数据&lt;/strong&gt;： Object getAttribute(String var1);&lt;br/&gt;1.由于取出的是一个Object类型，需要强转&lt;br/&gt;2.如果指定的属性名不存在，则返回null&lt;/p&gt;
&lt;h2 id=&quot;2可以获取文件的真实路径&quot;&gt;&lt;strong&gt;2.可以获取文件的真实路径&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;真实路径：即部署在服务器是的路径&lt;br/&gt;String getRealPath（） 获取文件的真实路径&lt;/p&gt;
&lt;p&gt;不同目录下访问资源的方式不同&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//src下的资源访问
        String realPath = servletContext.getRealPath(&quot;/WEB-INF/classes/a.text&quot;);
        System.out.println(realPath);
//WEB-INF下的资源访问
        String realPath1 = servletContext.getRealPath(&quot;/WEB-INF/b.text&quot;);
        System.out.println(realPath1);
 //web目录下的资源访问
        String realPath2 = servletContext.getRealPath(&quot;/c.text&quot;);
        System.out.println(realPath2);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;import javax.servlet.RequestDispatcher;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
@WebServlet(&quot;/ServletContext&quot;)
public class ServletContext extends HttpServlet{
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        this.doPost(req, resp);
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        javax.servlet.ServletContext servletContext = this.getServletContext();
        //src下的资源访问
        String realPath = servletContext.getRealPath(&quot;/WEB-INF/classes/a.text&quot;);
        System.out.println(realPath);
        //WEB-INF下的资源访问
        String realPath1 = servletContext.getRealPath(&quot;/WEB-INF/b.text&quot;);
        System.out.println(realPath1);
        //web目录下的资源访问
        String realPath2 = servletContext.getRealPath(&quot;/c.text&quot;);
        System.out.println(realPath2);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200803081938753.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;3获得mime类型&quot;&gt;&lt;strong&gt;3.获得MIME类型&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;s什么是MIME类型，是在互联网通信过程中定义等等一种文件数据类型&lt;br/&gt;格式：大类型/小类型 image/jpeg&lt;br/&gt;获取： String getMimeType（String file)&lt;/p&gt;
&lt;p&gt;代码如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;import javax.servlet.RequestDispatcher;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
@WebServlet(&quot;/ServletContext&quot;)
public class ServletContext extends HttpServlet{
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        this.doPost(req, resp);
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        javax.servlet.ServletContext servletContext = this.getServletContext();
        String filename=&quot;a.jpg&quot;;
        String mimeType = servletContext.getMimeType(filename);
        System.out.println(mimeType);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200803075809874.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BqaDg4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;以上就是servletcontext对象的一些基础知识，如有错误还请各位批评指正，喜欢我的文章可以点赞呀，也可以关注我，我会经常跟新文章&quot;&gt;以上就是ServletContext对象的一些基础知识，如有错误还请各位批评指正，喜欢我的文章可以点赞呀，也可以关注我，我会经常跟新文章&lt;/h2&gt;
</description>
<pubDate>Mon, 03 Aug 2020 00:21:00 +0000</pubDate>
<dc:creator>一只胡说八道的猴子</dc:creator>
<og:description>Java ServletContext详解 什么是ServletContext？ 根据字面意思即Servlet上下文 服务器会为每一个工程创建一个对象，这个对象就是ServletContext对象，这</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/pjhaymy/p/13424324.html</dc:identifier>
</item>
<item>
<title>老哥，您看我这篇Java集合，还有机会评优吗？ - 程序员cxuan</title>
<link>http://www.cnblogs.com/cxuanBlog/p/13424318.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cxuanBlog/p/13424318.html</guid>
<description>&lt;p&gt;集合在我们日常开发使用的次数数不胜数，&lt;code&gt;ArrayList&lt;/code&gt;/&lt;code&gt;LinkedList&lt;/code&gt;/&lt;code&gt;HashMap&lt;/code&gt;/&lt;code&gt;HashSet&lt;/code&gt;······信手拈来，抬手就拿来用，在 IDE 上龙飞凤舞，但是作为一名合格的优雅的程序猿，仅仅了解怎么使用&lt;code&gt;API&lt;/code&gt;是远远不够的，如果在调用&lt;code&gt;API&lt;/code&gt;时，知道它内部发生了什么事情，就像开了&lt;code&gt;透视&lt;/code&gt;外挂一样，洞穿一切，这种感觉才真的爽，而且这样就&lt;strong&gt;不是集合提供什么功能给我们使用，而是我们选择使用它的什么功能了&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/1694029/1596208672973-ae64a99f-3831-4b18-b4f4-c69237eba98a.png?x-oss-process=image%2Fresize%2Cw_2400&quot; alt=&quot;img&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;集合框架总览&quot;&gt;集合框架总览&lt;/h2&gt;
&lt;p&gt;下图堪称集合框架的&lt;strong&gt;上帝视角&lt;/strong&gt;，讲到集合框架不得不看的就是这幅图，当然，你会觉得眼花缭乱，不知如何看起，这篇文章带你一步一步地秒杀上面的每一个接口、抽象类和具体类。我们将会从最顶层的接口开始讲起，一步一步往下深入，帮助你把对集合的认知构建起一个知识网络。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/jpeg/1694029/1596110252275-7ae0c7a7-b8a9-4e36-bc2f-d651c6e0ae23.jpeg&quot; alt=&quot;collection.jpeg&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;工欲善其事必先利其器，让我们先来过一遍整个集合框架的组成部分：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;集合框架提供了两个遍历接口：&lt;code&gt;Iterator&lt;/code&gt;和&lt;code&gt;ListIterator&lt;/code&gt;，其中后者是前者的&lt;code&gt;优化版&lt;/code&gt;，支持在任意一个位置进行&lt;strong&gt;前后双向遍历&lt;/strong&gt;。注意图中的&lt;code&gt;Collection&lt;/code&gt;应当继承的是&lt;code&gt;Iterable&lt;/code&gt;而不是&lt;code&gt;Iterator&lt;/code&gt;，后面会解释&lt;code&gt;Iterable&lt;/code&gt;和&lt;code&gt;Iterator&lt;/code&gt;的区别&lt;/li&gt;
&lt;li&gt;整个集合框架分为两个门派（类型）：&lt;code&gt;Collection&lt;/code&gt;和&lt;code&gt;Map&lt;/code&gt;，前者是一个容器，存储一系列的&lt;strong&gt;对象&lt;/strong&gt;；后者是键值对&lt;code&gt;&amp;lt;key, value&amp;gt;&lt;/code&gt;，存储一系列的&lt;strong&gt;键值对&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;在集合框架体系下，衍生出四种具体的集合类型：&lt;code&gt;Map&lt;/code&gt;、&lt;code&gt;Set&lt;/code&gt;、&lt;code&gt;List&lt;/code&gt;、&lt;code&gt;Queue&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Map&lt;/code&gt;存储&lt;code&gt;&amp;lt;key,value&amp;gt;&lt;/code&gt;键值对，查找元素时通过&lt;code&gt;key&lt;/code&gt;查找&lt;code&gt;value&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Set&lt;/code&gt;内部存储一系列&lt;strong&gt;不可重复&lt;/strong&gt;的对象，且是一个&lt;strong&gt;无序&lt;/strong&gt;集合，对象排列顺序不一&lt;/li&gt;
&lt;li&gt;&lt;code&gt;List&lt;/code&gt;内部存储一系列&lt;strong&gt;可重复&lt;/strong&gt;的对象，是一个&lt;strong&gt;有序&lt;/strong&gt;集合，对象按插入顺序排列&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Queue&lt;/code&gt;是一个&lt;strong&gt;队列&lt;/strong&gt;容器，其特性与&lt;code&gt;List&lt;/code&gt;相同，但只能从&lt;code&gt;队头&lt;/code&gt;和&lt;code&gt;队尾&lt;/code&gt;操作元素&lt;/li&gt;
&lt;li&gt;JDK 为集合的各种操作提供了两个工具类&lt;code&gt;Collections&lt;/code&gt;和&lt;code&gt;Arrays&lt;/code&gt;，之后会讲解工具类的常用方法&lt;/li&gt;
&lt;li&gt;四种抽象集合类型内部也会衍生出许多具有不同特性的集合类，&lt;strong&gt;不同场景下择优使用，没有最佳的集合&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;上面了解了整个集合框架体系的组成部分，接下来的章节会严格按照上面罗列的顺序进行讲解，每一步都会有&lt;code&gt;承上启下&lt;/code&gt;的作用&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;学习&lt;code&gt;Set&lt;/code&gt;前，最好最好要先学习&lt;code&gt;Map&lt;/code&gt;，因为&lt;code&gt;Set&lt;/code&gt;的操作本质上是对&lt;code&gt;Map&lt;/code&gt;的操作，往下看准没错&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;iterator--iterable-listiterator&quot;&gt;Iterator Iterable ListIterator&lt;/h3&gt;
&lt;p&gt;在第一次看这两个接口，真以为是一模一样的，没发现里面有啥不同，&lt;strong&gt;存在即合理&lt;/strong&gt;，它们两个还是有本质上的区别的。&lt;/p&gt;
&lt;p&gt;首先来看&lt;code&gt;Iterator&lt;/code&gt;接口：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface Iterator&amp;lt;E&amp;gt; {
    boolean hasNext();
    E next();
    void remove();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;提供的API接口含义如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;hasNext()&lt;/code&gt;：判断集合中是否存在下一个对象&lt;/li&gt;
&lt;li&gt;&lt;code&gt;next()&lt;/code&gt;：返回集合中的下一个对象，并将访问指针移动一位&lt;/li&gt;
&lt;li&gt;&lt;code&gt;remove()&lt;/code&gt;：删除集合中调用&lt;code&gt;next()&lt;/code&gt;方法返回的对象&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在早期，遍历集合的方式只有一种，通过&lt;code&gt;Iterator&lt;/code&gt;迭代器操作&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
list.add(1);
list.add(2);
list.add(3);
Iterator iter = list.iterator();
while (iter.hasNext()) {
    Integer next = iter.next();
    System.out.println(next);
    if (next == 2) { iter.remove(); }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再来看&lt;code&gt;Iterable&lt;/code&gt;接口：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface Iterable&amp;lt;T&amp;gt; {
    Iterator&amp;lt;T&amp;gt; iterator();
    // JDK 1.8
    default void forEach(Consumer&amp;lt;? super T&amp;gt; action) {
        Objects.requireNonNull(action);
        for (T t : this) {
            action.accept(t);
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到&lt;code&gt;Iterable&lt;/code&gt;接口里面提供了&lt;code&gt;Iterator&lt;/code&gt;接口，所以实现了&lt;code&gt;Iterable&lt;/code&gt;接口的集合依旧可以使用&lt;code&gt;迭代器&lt;/code&gt;遍历和操作集合中的对象；&lt;/p&gt;
&lt;p&gt;而在 &lt;code&gt;JDK 1.8&lt;/code&gt;中，&lt;code&gt;Iterable&lt;/code&gt;提供了一个新的方法&lt;code&gt;forEach()&lt;/code&gt;，它允许使用增强 for 循环遍历对象。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
for (Integer num : list) {
    System.out.println(num);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们通过命令：&lt;code&gt;javap -c&lt;/code&gt;反编译上面的这段代码后，发现它只是 Java 中的一个&lt;code&gt;语法糖&lt;/code&gt;，本质上还是调用&lt;code&gt;Iterator&lt;/code&gt;去遍历。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/1694029/1596110168937-9464cc3c-9198-4ef0-ada3-97c86cfaf175.png&quot; alt=&quot;image-20200729000858377.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;翻译成代码，就和一开始的&lt;code&gt;Iterator&lt;/code&gt;迭代器遍历方式基本相同了。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Iterator iter = list.iterator();
while (iter.hasNext()) {
    Integer num = iter.next();
    System.out.println(num);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7.9936102236422&quot;&gt;
&lt;p&gt;还有更深层次的探讨：为什么要设计两个接口&lt;code&gt;Iterable&lt;/code&gt;和&lt;code&gt;Iterator&lt;/code&gt;，而不是保留其中一个就可以了。&lt;/p&gt;
&lt;p&gt;简单讲解：&lt;code&gt;Iterator&lt;/code&gt;的保留可以让子类去&lt;strong&gt;实现自己的迭代器&lt;/strong&gt;，而&lt;code&gt;Iterable&lt;/code&gt;接口更加关注于&lt;code&gt;for-each&lt;/code&gt;的增强语法。具体可参考：&lt;a href=&quot;https://www.cnblogs.com/litexy/p/9744241.html&quot;&gt;Java中的Iterable与Iterator详解&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;关于&lt;code&gt;Iterator&lt;/code&gt;和&lt;code&gt;Iterable&lt;/code&gt;的讲解告一段落，下面来总结一下它们的重点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;Iterator&lt;/code&gt;是提供集合操作内部对象的一个迭代器，它可以&lt;strong&gt;遍历、移除&lt;/strong&gt;对象，且只能够&lt;strong&gt;单向移动&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Iterable&lt;/code&gt;是对&lt;code&gt;Iterator&lt;/code&gt;的封装，在&lt;code&gt;JDK 1.8&lt;/code&gt;时，实现了&lt;code&gt;Iterable&lt;/code&gt;接口的集合可以使用&lt;strong&gt;增强 for 循环&lt;/strong&gt;遍历集合对象，我们通过&lt;strong&gt;反编译&lt;/strong&gt;后发现底层还是使用&lt;code&gt;Iterator&lt;/code&gt;迭代器进行遍历&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;等等，这一章还没完，还有一个&lt;code&gt;ListIterator&lt;/code&gt;。它继承 Iterator 接口，在遍历&lt;code&gt;List&lt;/code&gt;集合时可以从&lt;strong&gt;任意索引下标&lt;/strong&gt;开始遍历，而且支持&lt;strong&gt;双向遍历&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;ListIterator 存在于 List 集合之中，通过调用方法可以返回&lt;strong&gt;起始下标&lt;/strong&gt;为 &lt;code&gt;index&lt;/code&gt;的迭代器&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
// 返回下标为0的迭代器
ListIterator&amp;lt;Integer&amp;gt; listIter1 = list.listIterator(); 
// 返回下标为5的迭代器
ListIterator&amp;lt;Integer&amp;gt; listIter2 = list.listIterator(5); 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ListIterator 中有几个重要方法，大多数方法与 Iterator 中定义的含义相同，但是比 Iterator 强大的地方是可以在&lt;strong&gt;任意一个下标位置&lt;/strong&gt;返回该迭代器，且可以实现&lt;strong&gt;双向遍历&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface ListIterator&amp;lt;E&amp;gt; extends Iterator&amp;lt;E&amp;gt; {
    boolean hasNext();
    E next();
    boolean hasPrevious();
    E previous();
    int nextIndex();
    int previousIndex();
    void remove();
    // 替换当前下标的元素,即访问过的最后一个元素
    void set(E e);
    void add(E e);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;map-和-collection-接口&quot;&gt;Map 和 Collection 接口&lt;/h3&gt;
&lt;p&gt;Map 接口和 Collection 接口是集合框架体系的两大门派，Collection 是存储元素本身，而 Map 是存储&lt;code&gt;&amp;lt;key, value&amp;gt;&lt;/code&gt;键值对，在 Collection 门派下有一小部分弟子去&lt;code&gt;偷师&lt;/code&gt;，利用 Map 门派下的弟子来修炼自己。&lt;/p&gt;
&lt;p&gt;是不是听的一头雾水哈哈哈，举个例子你就懂了：&lt;code&gt;HashSet&lt;/code&gt;底层利用了&lt;code&gt;HashMap&lt;/code&gt;，&lt;code&gt;TreeSet&lt;/code&gt;底层用了&lt;code&gt;TreeMap&lt;/code&gt;，&lt;code&gt;LinkedHashSet&lt;/code&gt;底层用了&lt;code&gt;LinkedHashMap&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;下面我会详细讲到各个具体集合类哦，所以在这里，我们先从整体上了解这两个&lt;code&gt;门派&lt;/code&gt;的特点和区别。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/1694029/1595998378619-e54eb2d1-128a-448e-98c6-4941d81546b5.png&quot; alt=&quot;img&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Map&lt;/code&gt;接口定义了存储的数据结构是&lt;code&gt;&amp;lt;key, value&amp;gt;&lt;/code&gt;形式，根据 key 映射到 value，一个 key 对应一个 value ，所以&lt;code&gt;key&lt;/code&gt;不可重复，而&lt;code&gt;value&lt;/code&gt;可重复。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;Map&lt;/code&gt;接口下会将存储的方式细分为不同的种类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;SortedMap&lt;/code&gt;接口：该类映射可以对&lt;code&gt;&amp;lt;key, value&amp;gt;&lt;/code&gt;按照自己的规则进行&lt;strong&gt;排序&lt;/strong&gt;，具体实现有 TreeMap&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AbsractMap&lt;/code&gt;：它为子类提供好一些&lt;strong&gt;通用的API实现&lt;/strong&gt;，所有的具体Map如&lt;code&gt;HashMap&lt;/code&gt;都会继承它&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;而&lt;code&gt;Collection&lt;/code&gt;接口提供了所有集合的&lt;strong&gt;通用方法&lt;/strong&gt;（注意这里不包括&lt;code&gt;Map&lt;/code&gt;）：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;添加方法：&lt;code&gt;add(E e)&lt;/code&gt; / &lt;code&gt;addAll(Collection&amp;lt;? extends E&amp;gt; var1)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;删除方法：&lt;code&gt;remove(Object var1)&lt;/code&gt; / &lt;code&gt;removeAll(Collection&amp;lt;?&amp;gt; var1)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;查找方法：&lt;code&gt;contains(Object var1)&lt;/code&gt; / &lt;code&gt;containsAll(Collection&amp;lt;?&amp;gt; var1);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;查询集合自身信息：&lt;code&gt;size()&lt;/code&gt; / &lt;code&gt;isEmpty()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;···&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在&lt;code&gt;Collection&lt;/code&gt;接口下，同样会将集合细分为不同的种类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Set&lt;/code&gt;接口：一个&lt;strong&gt;不允许存储重复元素&lt;/strong&gt;的&lt;strong&gt;无序&lt;/strong&gt;集合，具体实现有&lt;code&gt;HashSet&lt;/code&gt; / &lt;code&gt;TreeSet&lt;/code&gt;···&lt;/li&gt;
&lt;li&gt;&lt;code&gt;List&lt;/code&gt;接口：一个&lt;strong&gt;可存储重复元素&lt;/strong&gt;的&lt;strong&gt;有序&lt;/strong&gt;集合，具体实现有&lt;code&gt;ArrayList&lt;/code&gt; / &lt;code&gt;LinkedList&lt;/code&gt;···&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Queue&lt;/code&gt;接口：一个&lt;strong&gt;可存储重复元素&lt;/strong&gt;的&lt;strong&gt;队列&lt;/strong&gt;，具体实现有&lt;code&gt;PriorityQueue&lt;/code&gt; / &lt;code&gt;ArrayDeque&lt;/code&gt;···&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;map-集合体系详解&quot;&gt;Map 集合体系详解&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Map&lt;/code&gt;接口是由&lt;code&gt;&amp;lt;key, value&amp;gt;&lt;/code&gt;组成的集合，由&lt;code&gt;key&lt;/code&gt;映射到&lt;strong&gt;唯一&lt;/strong&gt;的&lt;code&gt;value&lt;/code&gt;，所以&lt;code&gt;Map&lt;/code&gt;不能包含重复的&lt;code&gt;key&lt;/code&gt;，每个键&lt;strong&gt;至多&lt;/strong&gt;映射一个值。下图是整个 Map 集合体系的主要组成部分，我将会按照日常使用频率从高到低一一讲解。&lt;/p&gt;
&lt;p&gt;不得不提的是 Map 的设计理念：&lt;strong&gt;定位元素&lt;/strong&gt;的时间复杂度优化到 &lt;code&gt;O(1)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Map 体系下主要分为 AbstractMap 和 SortedMap两类集合&lt;/p&gt;
&lt;p&gt;&lt;code&gt;AbstractMap&lt;/code&gt;是对 Map 接口的扩展，它定义了普通的 Map 集合具有的&lt;strong&gt;通用行为&lt;/strong&gt;，可以避免子类重复编写大量相同的代码，子类继承 AbstractMap 后可以重写它的方法，&lt;strong&gt;实现额外的逻辑&lt;/strong&gt;，对外提供更多的功能。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SortedMap&lt;/code&gt; 定义了该类 Map 具有 &lt;code&gt;排序&lt;/code&gt;行为，同时它在内部定义好有关排序的抽象方法，当子类实现它时，必须重写所有方法，对外提供排序功能。&lt;/p&gt;
&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/1694029/1596032812883-d74e0796-09ad-41cd-8c7c-46e01775ec75.png&quot; alt=&quot;image.png&quot;/&gt;&lt;h3 id=&quot;hashmap&quot;&gt;HashMap&lt;/h3&gt;
&lt;p&gt;HashMap 是一个&lt;strong&gt;最通用的&lt;/strong&gt;利用哈希表存储元素的集合，将元素放入 HashMap 时，将&lt;code&gt;key&lt;/code&gt;的哈希值转换为数组的&lt;code&gt;索引&lt;/code&gt;下标&lt;strong&gt;确定存放位置&lt;/strong&gt;，查找时，根据&lt;code&gt;key&lt;/code&gt;的哈希地址转换成数组的&lt;code&gt;索引&lt;/code&gt;下标&lt;strong&gt;确定查找位置&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;HashMap 底层是用数组 + 链表 + 红黑树这三种数据结构实现，它是&lt;strong&gt;非线程安全&lt;/strong&gt;的集合。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/1694029/1595419821508-67e5c9e1-ab2a-4f96-9df7-7a37658e564a.png&quot; alt=&quot;img&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;发送哈希冲突时，HashMap 的解决方法是将相同映射地址的元素连成一条&lt;code&gt;链表&lt;/code&gt;，如果链表的长度大于&lt;code&gt;8&lt;/code&gt;时，且数组的长度大于&lt;code&gt;64&lt;/code&gt;则会转换成&lt;code&gt;红黑树&lt;/code&gt;数据结构。&lt;/p&gt;
&lt;p&gt;关于 HashMap 的简要总结：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;它是集合中最常用的&lt;code&gt;Map&lt;/code&gt;集合类型，底层由&lt;code&gt;数组 + 链表 + 红黑树&lt;/code&gt;组成&lt;/li&gt;
&lt;li&gt;HashMap不是线程安全的&lt;/li&gt;
&lt;li&gt;插入元素时，通过计算元素的&lt;code&gt;哈希值&lt;/code&gt;，通过&lt;strong&gt;哈希映射函数&lt;/strong&gt;转换为&lt;code&gt;数组下标&lt;/code&gt;；查找元素时，同样通过哈希映射函数得到数组下标&lt;code&gt;定位元素的位置&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;linkedhashmap&quot;&gt;LinkedHashMap&lt;/h3&gt;
&lt;p&gt;LinkedHashMap 可以看作是 &lt;code&gt;HashMap&lt;/code&gt; 和 &lt;code&gt;LinkedList&lt;/code&gt; 的结合：它在 HashMap 的基础上添加了一条双向链表，&lt;code&gt;默认&lt;/code&gt;存储各个元素的插入顺序，但由于这条双向链表，使得 LinkedHashMap 可以实现 &lt;code&gt;LRU&lt;/code&gt;缓存淘汰策略，因为我们可以设置这条双向链表按照&lt;code&gt;元素的访问次序&lt;/code&gt;进行排序&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/1694029/1596103017691-7eb35af1-3fde-46b8-aa56-31df67c1b3de.png&quot; alt=&quot;img&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;LinkedHashMap 是 HashMap 的子类，所以它具备 HashMap 的所有特点，其次，它在 HashMap 的基础上维护了一条&lt;code&gt;双向链表&lt;/code&gt;，该链表存储了&lt;strong&gt;所有元素&lt;/strong&gt;，&lt;code&gt;默认&lt;/code&gt;元素的顺序与插入顺序&lt;strong&gt;一致&lt;/strong&gt;。若&lt;code&gt;accessOrder&lt;/code&gt;属性为&lt;code&gt;true&lt;/code&gt;，则遍历顺序按元素的访问次序进行排序。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 头节点
transient LinkedHashMap.Entry&amp;lt;K, V&amp;gt; head;
// 尾结点
transient LinkedHashMap.Entry&amp;lt;K, V&amp;gt; tail;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;利用 LinkedHashMap 可以实现 &lt;code&gt;LRU&lt;/code&gt; 缓存淘汰策略，因为它提供了一个方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;protected boolean removeEldestEntry(java.util.Map.Entry&amp;lt;K, V&amp;gt; eldest) {
    return false;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该方法可以移除&lt;code&gt;最靠近链表头部&lt;/code&gt;的一个节点，而在&lt;code&gt;get()&lt;/code&gt;方法中可以看到下面这段代码，其作用是挪动结点的位置：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;if (this.accessOrder) {
    this.afterNodeAccess(e);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;只要调用了&lt;code&gt;get()&lt;/code&gt;且&lt;code&gt;accessOrder = true&lt;/code&gt;，则会将该节点更新到链表&lt;code&gt;尾部&lt;/code&gt;，具体的逻辑在&lt;code&gt;afterNodeAccess()&lt;/code&gt;中，感兴趣的可翻看源码，篇幅原因这里不再展开。&lt;/p&gt;
&lt;p&gt;现在如果要实现一个&lt;code&gt;LRU&lt;/code&gt;缓存策略，则需要做两件事情：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;指定&lt;code&gt;accessOrder = true&lt;/code&gt;可以设定链表按照访问顺序排列，通过提供的构造器可以设定&lt;code&gt;accessOrder&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder) {
    super(initialCapacity, loadFactor);
    this.accessOrder = accessOrder;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;重写&lt;code&gt;removeEldestEntry()&lt;/code&gt;方法，内部定义逻辑，通常是判断&lt;code&gt;容量&lt;/code&gt;是否达到上限，若是则执行淘汰。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里就要贴出一道大厂面试必考题目：&lt;a href=&quot;https://leetcode-cn.com/problems/lru-cache/&quot;&gt;146. LRU缓存机制&lt;/a&gt;，只要跟着我的步骤，就能顺利完成这道大厂题了。&lt;/p&gt;
&lt;p&gt;关于 LinkedHashMap 主要介绍两点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;它底层维护了一条&lt;code&gt;双向链表&lt;/code&gt;，因为继承了 HashMap，所以它也不是线程安全的&lt;/li&gt;
&lt;li&gt;LinkedHashMap 可实现&lt;code&gt;LRU&lt;/code&gt;缓存淘汰策略，其原理是通过设置&lt;code&gt;accessOrder&lt;/code&gt;为&lt;code&gt;true&lt;/code&gt;并重写&lt;code&gt;removeEldestEntry&lt;/code&gt;方法定义淘汰元素时需满足的条件&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;treemap&quot;&gt;TreeMap&lt;/h3&gt;
&lt;p&gt;TreeMap 是 &lt;code&gt;SortedMap&lt;/code&gt; 的子类，所以它具有&lt;strong&gt;排序&lt;/strong&gt;功能。它是基于&lt;code&gt;红黑树&lt;/code&gt;数据结构实现的，每一个键值对&lt;code&gt;&amp;lt;key, value&amp;gt;&lt;/code&gt;都是一个结点，默认情况下按照&lt;code&gt;key&lt;/code&gt;自然排序，另一种是可以通过传入定制的&lt;code&gt;Comparator&lt;/code&gt;进行自定义规则排序。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 按照 key 自然排序，Integer 的自然排序是升序
TreeMap&amp;lt;Integer, Object&amp;gt; naturalSort = new TreeMap&amp;lt;&amp;gt;();
// 定制排序，按照 key 降序排序
TreeMap&amp;lt;Integer, Object&amp;gt; customSort = new TreeMap&amp;lt;&amp;gt;((o1, o2) -&amp;gt; Integer.compare(o2, o1));
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;TreeMap 底层使用了数组+红黑树实现，所以里面的存储结构可以理解成下面这幅图哦。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/1694029/1596103385086-d684f26e-dabd-44b7-bab8-151af172496a.png&quot; alt=&quot;image-20200730180101883.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图中红黑树的每一个节点都是一个&lt;code&gt;Entry&lt;/code&gt;，在这里为了图片的简洁性，就不标明 key 和 value 了，注意这些元素都是已经按照&lt;code&gt;key&lt;/code&gt;排好序了，整个数据结构都是保持着&lt;code&gt;有序&lt;/code&gt; 的状态！&lt;/p&gt;
&lt;p&gt;关于&lt;code&gt;自然&lt;/code&gt;排序与&lt;code&gt;定制&lt;/code&gt;排序：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;自然排序：要求&lt;code&gt;key&lt;/code&gt;必须实现&lt;code&gt;Comparable&lt;/code&gt;接口。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;由于&lt;code&gt;Integer&lt;/code&gt;类实现了 Comparable 接口，按照自然排序规则是按照&lt;code&gt;key&lt;/code&gt;从小到大排序。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;TreeMap&amp;lt;Integer, String&amp;gt; treeMap = new TreeMap&amp;lt;&amp;gt;();
treeMap.put(2, &quot;TWO&quot;);
treeMap.put(1, &quot;ONE&quot;);
System.out.print(treeMap);
// {1=ONE, 2=TWO}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;定制排序：在初始化 TreeMap 时传入新的&lt;code&gt;Comparator&lt;/code&gt;，&lt;strong&gt;不&lt;/strong&gt;要求&lt;code&gt;key&lt;/code&gt;实现 Comparable 接口&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;TreeMap&amp;lt;Integer, String&amp;gt; treeMap = new TreeMap&amp;lt;&amp;gt;((o1, o2) -&amp;gt; Integer.compare(o2, o1));
treeMap.put(1, &quot;ONE&quot;);
treeMap.put(2, &quot;TWO&quot;);
treeMap.put(4, &quot;FOUR&quot;);
treeMap.put(3, &quot;THREE&quot;);
System.out.println(treeMap);
// {4=FOUR, 3=THREE, 2=TWO, 1=ONE}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过传入新的&lt;code&gt;Comparator&lt;/code&gt;比较器，可以覆盖默认的排序规则，上面的代码按照&lt;code&gt;key&lt;/code&gt;降序排序，在实际应用中还可以按照其它规则自定义排序。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;compare()&lt;/code&gt;方法的返回值有三种，分别是：&lt;code&gt;0&lt;/code&gt;，&lt;code&gt;-1&lt;/code&gt;，&lt;code&gt;+1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;（1）如果返回&lt;code&gt;0&lt;/code&gt;，代表两个元素相等，不需要调换顺序&lt;/p&gt;
&lt;p&gt;（2）如果返回&lt;code&gt;+1&lt;/code&gt;，代表前面的元素需要与后面的元素调换位置&lt;/p&gt;
&lt;p&gt;（3）如果返回&lt;code&gt;-1&lt;/code&gt;，代表前面的元素不需要与后面的元素调换位置&lt;/p&gt;
&lt;p&gt;而何时返回&lt;code&gt;+1&lt;/code&gt;和&lt;code&gt;-1&lt;/code&gt;，则由我们自己去定义，JDK默认是按照&lt;strong&gt;自然排序&lt;/strong&gt;，而我们可以根据&lt;code&gt;key&lt;/code&gt;的不同去定义降序还是升序排序。&lt;/p&gt;
&lt;p&gt;关于 TreeMap 主要介绍了两点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;它底层是由&lt;code&gt;红黑树&lt;/code&gt;这种数据结构实现的，所以操作的时间复杂度恒为&lt;code&gt;O(logN)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;TreeMap 可以对&lt;code&gt;key&lt;/code&gt;进行自然排序或者自定义排序，自定义排序时需要传入&lt;code&gt;Comparator&lt;/code&gt;，而自然排序要求&lt;code&gt;key&lt;/code&gt;实现了&lt;code&gt;Comparable&lt;/code&gt;接口&lt;/li&gt;
&lt;li&gt;TreeMap 不是线程安全的。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;weakhashmap&quot;&gt;WeakHashMap&lt;/h3&gt;
&lt;p&gt;WeakHashMap 日常开发中比较少见，它是基于普通的&lt;code&gt;Map&lt;/code&gt;实现的，而里面&lt;code&gt;Entry&lt;/code&gt;中的键在每一次的&lt;code&gt;垃圾回收&lt;/code&gt;都会被清除掉，所以非常适合用于&lt;strong&gt;短暂访问、仅访问一次&lt;/strong&gt;的元素，缓存在&lt;code&gt;WeakHashMap&lt;/code&gt;中，并尽早地把它回收掉。&lt;/p&gt;
&lt;p&gt;当&lt;code&gt;Entry&lt;/code&gt;被&lt;code&gt;GC&lt;/code&gt;时，WeakHashMap 是如何感知到某个元素被回收的呢？&lt;/p&gt;
&lt;p&gt;在 WeakHashMap 内部维护了一个引用队列&lt;code&gt;queue&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private final ReferenceQueue&amp;lt;Object&amp;gt; queue = new ReferenceQueue&amp;lt;&amp;gt;();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个 queue 里包含了所有被&lt;code&gt;GC&lt;/code&gt;掉的键，当JVM开启&lt;code&gt;GC&lt;/code&gt;后，如果回收掉 WeakHashMap 中的 key，会将 key 放入queue 中，在&lt;code&gt;expungeStaleEntries()&lt;/code&gt;中遍历 queue，把 queue 中的所有&lt;code&gt;key&lt;/code&gt;拿出来，并在 WeakHashMap 中删除掉，以达到&lt;strong&gt;同步&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private void expungeStaleEntries() {
    for (Object x; (x = queue.poll()) != null; ) {
        synchronized (queue) {
            // 去 WeakHashMap 中删除该键值对
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再者，需要注意 WeakHashMap 底层存储的元素的数据结构是&lt;code&gt;数组 + 链表&lt;/code&gt;，&lt;strong&gt;没有红黑树&lt;/strong&gt;哦，可以换一个角度想，如果还有红黑树，那干脆直接继承 HashMap ，然后再扩展就完事了嘛，然而它并没有这样做：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class WeakHashMap&amp;lt;K, V&amp;gt; extends AbstractMap&amp;lt;K, V&amp;gt; implements Map&amp;lt;K, V&amp;gt; {
    
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以，WeakHashMap 的数据结构图我也为你准备好啦。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/1694029/1596106079292-a74fb47e-bb54-47e2-81ac-1254428e73b7.png&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图中被虚线标识的元素将会在下一次访问 WeakHashMap 时被删除掉，WeakHashMap 内部会做好一系列的调整工作，所以记住队列的作用就是标志那些已经被&lt;code&gt;GC&lt;/code&gt;回收掉的元素。&lt;/p&gt;
&lt;p&gt;关于 WeakHashMap 需要注意两点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;它的键是一种&lt;strong&gt;弱键&lt;/strong&gt;，放入 WeakHashMap 时，随时会被回收掉，所以不能确保某次访问元素一定存在&lt;/li&gt;
&lt;li&gt;它依赖普通的&lt;code&gt;Map&lt;/code&gt;进行实现，是一个非线程安全的集合&lt;/li&gt;
&lt;li&gt;WeakHashMap 通常作为&lt;strong&gt;缓存&lt;/strong&gt;使用，适合存储那些&lt;strong&gt;只需访问一次&lt;/strong&gt;、或&lt;strong&gt;只需保存短暂时间&lt;/strong&gt;的键值对&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;hashtable&quot;&gt;Hashtable&lt;/h3&gt;
&lt;p&gt;Hashtable 底层的存储结构是&lt;code&gt;数组 + 链表&lt;/code&gt;，而它是一个&lt;strong&gt;线程安全&lt;/strong&gt;的集合，但是因为这个线程安全，它就被淘汰掉了。&lt;/p&gt;
&lt;p&gt;下面是Hashtable存储元素时的数据结构图，它只会存在数组+链表，当链表过长时，查询的效率过低，而且会长时间&lt;strong&gt;锁住&lt;/strong&gt; Hashtable。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/1694029/1596106328540-e1acec81-7896-45be-85c4-c93e142ef610.png&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;这幅图是否有点眼熟哈哈哈哈，本质上就是 WeakHashMap 的底层存储结构了。你千万别问为什么 WeakHashMap 不继承 Hashtable 哦，Hashtable 的&lt;code&gt;性能&lt;/code&gt;在并发环境下非常差，在非并发环境下可以用&lt;code&gt;HashMap&lt;/code&gt;更优。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;HashTable 本质上是 HashMap 的前辈，它被淘汰的原因也主要因为两个字：&lt;strong&gt;性能&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;HashTable 是一个 &lt;strong&gt;线程安全&lt;/strong&gt; 的 Map，它所有的方法都被加上了 &lt;strong&gt;synchronized&lt;/strong&gt; 关键字，也是因为这个关键字，它注定成为了时代的弃儿。&lt;/p&gt;
&lt;p&gt;HashTable 底层采用 &lt;strong&gt;数组+链表&lt;/strong&gt; 存储键值对，由于被弃用，后人也没有对它进行任何改进&lt;/p&gt;
&lt;p&gt;HashTable 默认长度为 &lt;code&gt;11&lt;/code&gt;，负载因子为 &lt;code&gt;0.75F&lt;/code&gt;，即元素个数达到数组长度的 75% 时，会进行一次扩容，每次扩容为原来数组长度的 &lt;code&gt;2&lt;/code&gt; 倍&lt;/p&gt;
&lt;p&gt;HashTable 所有的操作都是线程安全的。&lt;/p&gt;
&lt;h2 id=&quot;collection-集合体系详解&quot;&gt;Collection 集合体系详解&lt;/h2&gt;
&lt;p&gt;Collection 集合体系的顶层接口就是&lt;code&gt;Collection&lt;/code&gt;，它规定了该集合下的一系列行为约定。&lt;/p&gt;
&lt;p&gt;该集合下可以分为三大类集合：List，Set和Queue&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Set&lt;/code&gt;接口定义了该类集合&lt;strong&gt;不允许存储重复&lt;/strong&gt;的元素，且任何操作时均需要通过&lt;strong&gt;哈希函数映射&lt;/strong&gt;到集合内部定位元素，集合内部的元素&lt;strong&gt;默认&lt;/strong&gt;是&lt;strong&gt;无序&lt;/strong&gt;的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;List&lt;/code&gt;接口定义了该类集合&lt;strong&gt;允许存储重复&lt;/strong&gt;的元素，且集合内部的元素按照元素插入的顺序&lt;strong&gt;有序排列&lt;/strong&gt;，可以通过&lt;strong&gt;索引&lt;/strong&gt;访问元素。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Queue&lt;/code&gt;接口定义了该类集合是以&lt;code&gt;队列&lt;/code&gt;作为存储结构，所以集合内部的元素&lt;strong&gt;有序排列&lt;/strong&gt;，仅可以操作&lt;strong&gt;头结点&lt;/strong&gt;元素，无法访问队列中间的元素。&lt;/p&gt;
&lt;p&gt;上面三个接口是&lt;strong&gt;最普通，最抽象&lt;/strong&gt;的实现，而在各个集合接口内部，还会有更加具体的表现，衍生出各种不同的&lt;strong&gt;额外功能&lt;/strong&gt;，使开发者能够对比各个集合的优势，&lt;strong&gt;择优使用&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/1694029/1595682008755-6f1e6c3c-920e-427b-9c00-a4164026f181.png&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;set-接口&quot;&gt;Set 接口&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Set&lt;/code&gt;接口继承了&lt;code&gt;Collection&lt;/code&gt;接口，是一个不包括重复元素的集合，更确切地说，Set 中任意两个元素不会出现 &lt;code&gt;o1.equals(o2)&lt;/code&gt;，而且 Set &lt;strong&gt;至多&lt;/strong&gt;只能存储一个 &lt;code&gt;NULL&lt;/code&gt; 值元素，Set 集合的组成部分可以用下面这张图概括：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/1694029/1596107343106-b98a8b29-06ba-4f6f-ab14-7a139e506dd5.png&quot; alt=&quot;1595682050240-6c6946f2-9dd4-4e5b-a006-39144184e2f1.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在 Set 集合体系中，我们需要着重关注两点：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;存入&lt;strong&gt;可变元素&lt;/strong&gt;时，必须非常小心，因为任意时候元素状态的改变都有可能使得 Set 内部出现两个&lt;strong&gt;相等&lt;/strong&gt;的元素，即 &lt;code&gt;o1.equals(o2) = true&lt;/code&gt;，所以一般不要更改存入 Set 中的元素，否则将会破坏了 &lt;code&gt;equals()&lt;/code&gt; 的作用！&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Set 的最大作用就是判重，在项目中最大的作用也是&lt;strong&gt;判重&lt;/strong&gt;！&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;接下来我们去看它的实现类和子类： &lt;code&gt;AbstractSet&lt;/code&gt; 和 &lt;code&gt;SortedSet&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;abstractset-抽象类&quot;&gt;AbstractSet 抽象类&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;AbstractSet&lt;/code&gt; 是一个实现 Set 的一个抽象类，定义在这里可以将所有具体 Set 集合的&lt;strong&gt;相同行为&lt;/strong&gt;在这里实现，&lt;strong&gt;避免子类包含大量的重复代码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所有的 Set 也应该要有相同的 &lt;code&gt;hashCode()&lt;/code&gt; 和 &lt;code&gt;equals()&lt;/code&gt; 方法，所以使用抽象类把该方法重写后，子类无需关心这两个方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Java&quot;&gt;public abstract class AbstractSet&amp;lt;E&amp;gt; implements Set&amp;lt;E&amp;gt; {
    // 判断两个 set 是否相等
    public boolean equals(Object o) {
        if (o == this) { // 集合本身
            return true;
        } else if (!(o instanceof Set)) { // 集合不是 set
            return false;
        } else {
            // 比较两个集合的元素是否全部相同
        }
    }
    // 计算所有元素的 hashcode 总和
    public int hashCode() { 
        int h = 0;
        Iterator i = this.iterator();
        while(i.hasNext()) {
            E obj = i.next();
            if (obj != null) {
                h += obj.hashCode();
            }
        }
        return h;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;sortedset-接口&quot;&gt;SortedSet 接口&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;SortedSet&lt;/code&gt; 是一个接口，它在 Set 的基础上扩展了&lt;strong&gt;排序&lt;/strong&gt;的行为，所以所有实现它的子类都会拥有排序功能。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Java&quot;&gt;public interface SortedSet&amp;lt;E&amp;gt; extends Set&amp;lt;E&amp;gt; {
    // 元素的比较器,决定元素的排列顺序
    Comparator&amp;lt;? super E&amp;gt; comparator(); 
    // 获取 [var1, var2] 之间的 set
    SortedSet&amp;lt;E&amp;gt; subSet(E var1, E var2); 
    // 获取以 var1 开头的 Set
    SortedSet&amp;lt;E&amp;gt; headSet(E var1); 
    // 获取以 var1 结尾的 Set
    SortedSet&amp;lt;E&amp;gt; tailSet(E var1); 
    // 获取首个元素
    E first(); 
    // 获取最后一个元素
    E last();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;hashset&quot;&gt;HashSet&lt;/h3&gt;
&lt;p&gt;HashSet 底层借助 &lt;code&gt;HashMap&lt;/code&gt; 实现，我们可以观察它的多个构造方法，本质上都是 new 一个 HashMap&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;这也是这篇文章为什么先讲解 Map 再讲解 Set 的原因！先学习 Map，有助于理解 Set&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Java&quot;&gt;public class HashSet&amp;lt;E&amp;gt; extends AbstractSet&amp;lt;E&amp;gt; implements Set&amp;lt;E&amp;gt;, Cloneable, Serializable {
    public HashSet() {
        this.map = new HashMap();
    }
    public HashSet(int initialCapacity, float loadFactor) {
        this.map = new HashMap(initialCapacity, loadFactor);
    }
    public HashSet(int initialCapacity) {
        this.map = new HashMap(initialCapacity);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以观察 &lt;code&gt;add()&lt;/code&gt; 方法和&lt;code&gt;remove()&lt;/code&gt;方法是如何将 HashSet 的操作嫁接到 HashMap 的。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Java&quot;&gt;private static final Object PRESENT = new Object();

public boolean add(E e) {
    return this.map.put(e, PRESENT) == null;
}
public boolean remove(Object o) {
        return this.map.remove(o) == PRESENT;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们看到 &lt;code&gt;PRESENT&lt;/code&gt; 就是一个&lt;strong&gt;静态常量&lt;/strong&gt;：使用 PRESENT 作为 HashMap 的 value 值，使用HashSet的开发者只需&lt;strong&gt;关注&lt;/strong&gt;于需要插入的 &lt;code&gt;key&lt;/code&gt;，&lt;strong&gt;屏蔽&lt;/strong&gt;了 HashMap 的 &lt;code&gt;value&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/1694029/1596109695209-9cd36cf2-1b1f-44db-94ee-71d60348d257.png&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图可以观察到每个&lt;code&gt;Entry&lt;/code&gt;的&lt;code&gt;value&lt;/code&gt;都是 PRESENT 空对象，我们就不用再理会它了。&lt;/p&gt;
&lt;p&gt;HashSet 在 HashMap 基础上实现，所以很多地方可以联系到 HashMap：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;底层数据结构：HashSet 也是采用&lt;code&gt;数组 + 链表 + 红黑树&lt;/code&gt;实现&lt;/li&gt;
&lt;li&gt;线程安全性：由于采用 HashMap 实现，而 HashMap 本身线程不安全，在HashSet 中没有添加额外的同步策略，所以 HashSet 也&lt;strong&gt;线程不安全&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;存入 HashSet 的对象的状态&lt;strong&gt;最好不要发生变化&lt;/strong&gt;，因为有可能改变状态后，在集合内部出现两个元素&lt;code&gt;o1.equals(o2)&lt;/code&gt;，破坏了 &lt;code&gt;equals()&lt;/code&gt;的语义。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;linkedhashset&quot;&gt;LinkedHashSet&lt;/h3&gt;
&lt;p&gt;LinkedHashSet 的代码少的可怜，不信我给你我粘出来&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/1694029/1596108598046-702b165f-6aa0-463e-b87b-de9305acb693.png&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;少归少，还是不能闹，&lt;code&gt;LinkedHashSet&lt;/code&gt;继承了&lt;code&gt;HashSet&lt;/code&gt;，我们跟随到父类 HashSet 的构造方法看看&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;HashSet(int initialCapacity, float loadFactor, boolean dummy) {
    this.map = new LinkedHashMap(initialCapacity, loadFactor);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;发现父类中 map 的实现采用&lt;code&gt;LinkedHashMap&lt;/code&gt;，这里注意不是&lt;code&gt;HashMap&lt;/code&gt;，而 LinkedHashMap 底层又采用 HashMap + 双向链表 实现的，所以本质上 LinkedHashSet 还是使用 HashMap 实现的。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;LinkedHashSet -&amp;gt; LinkedHashMap -&amp;gt; HashMap + 双向链表&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/1694029/1596110006108-d064aa74-d71c-401a-94b9-83caef7cdbc7.png&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而 LinkedHashMap 是采用 &lt;code&gt;HashMap&lt;/code&gt;和&lt;code&gt;双向链表&lt;/code&gt;实现的，这条双向链表中保存了元素的插入顺序。所以 LinkedHashSet 可以按照元素的插入顺序遍历元素，如果你熟悉&lt;code&gt;LinkedHashMap&lt;/code&gt;，那 LinkedHashSet 也就更不在话下了。&lt;/p&gt;
&lt;p&gt;关于 LinkedHashSet 需要注意几个地方：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;它继承了 &lt;code&gt;HashSet&lt;/code&gt;，而 HashSet 默认是采用 HashMap 存储数据的，但是 LinkedHashSet 调用父类构造方法初始化 map 时是 LinkedHashMap 而不是 HashMap，这个要额外注意一下&lt;/li&gt;
&lt;li&gt;由于 LinkedHashMap 不是线程安全的，且在 LinkedHashSet 中没有添加额外的同步策略，所以 LinkedHashSet 集合&lt;strong&gt;也不是线程安全&lt;/strong&gt;的&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;treeset&quot;&gt;TreeSet&lt;/h3&gt;
&lt;p&gt;TreeSet 是基于 TreeMap 的实现，所以存储的元素是&lt;strong&gt;有序&lt;/strong&gt;的，底层的数据结构是&lt;code&gt;数组 + 红黑树&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/1694029/1596126807774-1a122d9e-4210-4708-8328-c23f65bc55dd.png&quot; alt=&quot;img&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而元素的排列顺序有&lt;code&gt;2&lt;/code&gt;种，和 TreeMap 相同：自然排序和定制排序，常用的构造方法已经在下面展示出来了，TreeSet 默认按照自然排序，如果需要定制排序，需要传入&lt;code&gt;Comparator&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Java&quot;&gt;public TreeSet() { 
    this(new TreeMap&amp;lt;E,Object&amp;gt;());
}
public TreeSet(Comparator&amp;lt;? super E&amp;gt; comparator) {
    this(new TreeMap&amp;lt;&amp;gt;(comparator));
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;TreeSet 应用场景有很多，像在游戏里的玩家战斗力排行榜&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Java&quot;&gt;public class Player implements Comparable&amp;lt;Integer&amp;gt; {
    public String name;
    public int score;
    @Override
    public int compareTo(Student o) {
        return Integer.compareTo(this.score, o.score);
    }
}
public static void main(String[] args) {
    Player s1 = new Player(&quot;张三&quot;, 100);
    Player s2 = new Player(&quot;李四&quot;, 90);
    Player s3 = new Player(&quot;王五&quot;, 80);
    TreeSet&amp;lt;Player&amp;gt; set = new TreeSet();
    set.add(s2); set.add(s1); set.add(s3);
    System.out.println(set);
}
// [Student{name='王五', score=80}, Student{name='李四', score=90}, Student{name='张三', score=100}]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对 TreeSet 介绍了它的主要实现方式和应用场景，有几个值得注意的点。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;TreeSet 的所有操作都会转换为对 TreeMap 的操作，TreeMap 采用&lt;strong&gt;红黑树&lt;/strong&gt;实现，任意操作的平均时间复杂度为 &lt;code&gt;O(logN)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;TreeSet 是一个&lt;strong&gt;线程不安全&lt;/strong&gt;的集合&lt;/li&gt;
&lt;li&gt;TreeSet 常应用于对&lt;strong&gt;不重复&lt;/strong&gt;的元素&lt;strong&gt;定制排序&lt;/strong&gt;，例如玩家战力排行榜&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;注意:TreeSet判断元素是否重复的方法是判断compareTo()方法是否返回0，而不是调用 hashcode() 和 equals() 方法，如果返回 0 则认为集合内已经存在相同的元素，不会再加入到集合当中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;list-接口&quot;&gt;List 接口&lt;/h2&gt;
&lt;p&gt;List 接口和 Set 接口齐头并进，是我们日常开发中接触的很多的一种集合类型了。整个 List 集合的组成部分如下图&lt;/p&gt;
&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/1694029/1596123811338-4c47cdc8-bac9-4670-91ee-6d8a82159bc6.png&quot; alt=&quot;img&quot;/&gt;&lt;p&gt;&lt;code&gt;List&lt;/code&gt; 接口直接继承 Collection 接口，它定义为可以存储&lt;strong&gt;重复&lt;/strong&gt;元素的集合，并且元素按照插入顺序&lt;strong&gt;有序排列&lt;/strong&gt;，且可以通过&lt;strong&gt;索引&lt;/strong&gt;访问指定位置的元素。常见的实现有：ArrayList、LinkedList、Vector和Stack&lt;/p&gt;
&lt;h3 id=&quot;abstractlist--和-abstractsequentiallist&quot;&gt;AbstractList 和 AbstractSequentialList&lt;/h3&gt;
&lt;p&gt;AbstractList 抽象类实现了 List 接口，其内部实现了所有的 List 都需具备的功能，子类可以专注于实现自己具体的操作逻辑。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 查找元素 o 第一次出现的索引位置
public int indexOf(Object o)
// 查找元素 o 最后一次出现的索引位置
public int lastIndexOf(Object o)
//···
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;AbstractSequentialList 抽象类继承了 AbstractList，在原基础上限制了访问元素的顺序&lt;strong&gt;只能够按照顺序访问&lt;/strong&gt;，而&lt;strong&gt;不支持随机访问&lt;/strong&gt;，如果需要满足随机访问的特性，则继承 AbstractList。子类 LinkedList 使用链表实现，所以仅能支持&lt;strong&gt;顺序访问&lt;/strong&gt;，顾继承了 &lt;code&gt;AbstractSequentialList&lt;/code&gt;而不是 AbstractList。&lt;/p&gt;
&lt;h3 id=&quot;vector&quot;&gt;Vector&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/1694029/1595375364068-c2c49168-a2f4-4a06-97c0-eb3446d60a68.png&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Vector&lt;/code&gt; 在现在已经是一种过时的集合了，包括继承它的 &lt;code&gt;Stack&lt;/code&gt; 集合也如此，它们被淘汰的原因都是因为&lt;strong&gt;性能&lt;/strong&gt;低下。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;JDK 1.0 时代，ArrayList 还没诞生，大家都是使用 Vector 集合，但由于 Vector 的&lt;strong&gt;每个操作&lt;/strong&gt;都被 &lt;strong&gt;synchronized&lt;/strong&gt; 关键字修饰，即使在线程安全的情况下，仍然&lt;strong&gt;进行无意义的加锁与释放锁&lt;/strong&gt;，造成额外的性能开销，做了无用功。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public synchronized boolean add(E e);
public synchronized E get(int index);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 JDK 1.2 时，Collection 家族出现了，它提供了大量&lt;strong&gt;高性能、适用於不同场合&lt;/strong&gt;的集合，而 Vector 也是其中一员，但由于 Vector 在每个方法上都加了锁，由于需要兼容许多老的项目，很难在此基础上优化&lt;code&gt;Vector&lt;/code&gt;了，所以渐渐地也就被历史淘汰了。&lt;/p&gt;
&lt;p&gt;现在，在&lt;strong&gt;线程安全&lt;/strong&gt;的情况下，不需要选用 Vector 集合，取而代之的是 &lt;strong&gt;ArrayList&lt;/strong&gt; 集合；在并发环境下，出现了 &lt;code&gt;CopyOnWriteArrayList&lt;/code&gt;，Vector 完全被弃用了。&lt;/p&gt;
&lt;h3 id=&quot;stack&quot;&gt;Stack&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/1694029/1596126551356-dc1af780-2fe9-4d04-8351-e70637ecdab5.png&quot; alt=&quot;img&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Stack&lt;/code&gt;是一种&lt;code&gt;后入先出（LIFO）&lt;/code&gt;型的集合容器，如图中所示，&lt;code&gt;大雄&lt;/code&gt;是最后一个进入容器的，top指针指向大雄，那么弹出元素时，大雄也是第一个被弹出去的。&lt;/p&gt;
&lt;p&gt;Stack 继承了 Vector 类，提供了栈顶的压入元素操作（push）和弹出元素操作（pop），以及查看栈顶元素的方法（peek）等等，但由于继承了 Vector，正所谓跟错老大没福报，Stack 也渐渐被淘汰了。&lt;/p&gt;
&lt;p&gt;取而代之的是后起之秀 &lt;code&gt;Deque&lt;/code&gt;接口，其实现有 &lt;code&gt;ArrayDeque&lt;/code&gt;，该数据结构更加完善、可靠性更好，依靠队列也可以实现&lt;code&gt;LIFO&lt;/code&gt;的栈操作，所以优先选择 ArrayDeque 实现栈。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Deque&amp;lt;Integer&amp;gt; stack = new ArrayDeque&amp;lt;Integer&amp;gt;();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ArrayDeque 的数据结构是：&lt;code&gt;数组&lt;/code&gt;，并提供&lt;strong&gt;头尾指针下标&lt;/strong&gt;对数组元素进行操作。本文也会讲到哦，客官请继续往下看，莫着急！😄&lt;/p&gt;
&lt;h3 id=&quot;arraylist&quot;&gt;ArrayList&lt;/h3&gt;
&lt;p&gt;ArrayList 以&lt;strong&gt;数组&lt;/strong&gt;作为存储结构，它是&lt;strong&gt;线程不安全&lt;/strong&gt;的集合；具有&lt;strong&gt;查询快、在数组中间或头部增删慢&lt;/strong&gt;的特点，所以它除了线程不安全这一点，其余可以替代&lt;code&gt;Vector&lt;/code&gt;，而且线程安全的 ArrayList 可以使用 &lt;code&gt;CopyOnWriteArrayList&lt;/code&gt;代替 Vector。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/1694029/1595375364068-c2c49168-a2f4-4a06-97c0-eb3446d60a68.png&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;关于 ArrayList 有几个重要的点需要注意的：&lt;/p&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;具备&lt;strong&gt;随机访问&lt;/strong&gt;特点，&lt;strong&gt;访问元素的效率&lt;/strong&gt;较高，ArrayList 在&lt;strong&gt;频繁插入、删除&lt;/strong&gt;集合元素的场景下效率较&lt;code&gt;低&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;底层数据结构：ArrayList 底层使用数组作为存储结构，具备&lt;strong&gt;查找快、增删慢&lt;/strong&gt;的特点&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;线程安全性：ArrayList 是&lt;strong&gt;线程不安全&lt;/strong&gt;的集合&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;ArrayList &lt;strong&gt;首次扩容&lt;/strong&gt;后的长度为 &lt;code&gt;10&lt;/code&gt;，调用 &lt;code&gt;add()&lt;/code&gt; 时需要计算容器的最小容量。可以看到如果数组&lt;code&gt;elementData&lt;/code&gt;为空数组，会将最小容量设置为&lt;code&gt;10&lt;/code&gt;，之后会将数组长度完成首次扩容到 10。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-Java&quot;&gt;// new ArrayList 时的默认空数组
private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};
// 默认容量
private static final int DEFAULT_CAPACITY = 10;
// 计算该容器应该满足的最小容量
private static int calculateCapacity(Object[] elementData, int minCapacity) {
    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
        return Math.max(DEFAULT_CAPACITY, minCapacity);
    }
    return minCapacity;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;集合从&lt;strong&gt;第二次扩容&lt;/strong&gt;开始，数组长度将扩容为原来的 &lt;code&gt;1.5&lt;/code&gt; 倍，即：&lt;code&gt;newLength = oldLength * 1.5&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/1694029/1595724934991-c2f12445-bc9e-4e1c-b965-04f2ef9d3d79.png&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;linkedlist&quot;&gt;LinkedList&lt;/h3&gt;
&lt;p&gt;LinkedList 底层采用&lt;code&gt;双向链表&lt;/code&gt;数据结构存储元素，由于链表的内存地址&lt;code&gt;非连续&lt;/code&gt;，所以它不具备随机访问的特点，但由于它利用指针连接各个元素，所以插入、删除元素只需要&lt;code&gt;操作指针&lt;/code&gt;，不需要&lt;code&gt;移动元素&lt;/code&gt;，故具有&lt;strong&gt;增删快、查询慢&lt;/strong&gt;的特点。它也是一个非线程安全的集合。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/1694029/1595393003456-d37281f4-8332-46b4-9d81-e1f0c24dc060.png&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于以双向链表作为数据结构，它是&lt;strong&gt;线程不安全&lt;/strong&gt;的集合；存储的每个节点称为一个&lt;code&gt;Node&lt;/code&gt;，下图可以看到 Node 中保存了&lt;code&gt;next&lt;/code&gt;和&lt;code&gt;prev&lt;/code&gt;指针，&lt;code&gt;item&lt;/code&gt;是该节点的值。在插入和删除时，时间复杂度都保持为 &lt;code&gt;O(1)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/1694029/1595725358023-1f64f780-9dd0-47ff-a84c-d4101d16c1e1.png&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;关于 LinkedList，除了它是以链表实现的集合外，还有一些特殊的特性需要注意的。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;优势：LinkedList 底层没有&lt;code&gt;扩容机制&lt;/code&gt;，使用&lt;code&gt;双向链表&lt;/code&gt;存储元素，所以插入和删除元素效率较高，适用于频繁操作元素的场景&lt;/li&gt;
&lt;li&gt;劣势：LinkedList 不具备&lt;code&gt;随机访问&lt;/code&gt;的特点，查找某个元素只能从 &lt;code&gt;head&lt;/code&gt; 或 &lt;code&gt;tail&lt;/code&gt; 指针一个一个比较，所以&lt;strong&gt;查找中间的元素时效率很低&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;查找优化：LinkedList 查找某个下标 &lt;code&gt;index&lt;/code&gt; 的元素时&lt;strong&gt;做了优化&lt;/strong&gt;，若 &lt;code&gt;index &amp;gt; (size / 2)&lt;/code&gt;，则从 &lt;code&gt;head&lt;/code&gt; 往后查找，否则从 &lt;code&gt;tail&lt;/code&gt; 开始往前查找，代码如下所示：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-Java&quot;&gt;LinkedList.Node&amp;lt;E&amp;gt; node(int index) {
    LinkedList.Node x;
    int i;
    if (index &amp;lt; this.size &amp;gt;&amp;gt; 1) { // 查找的下标处于链表前半部分则从头找
        x = this.first;
        for(i = 0; i &amp;lt; index; ++i) { x = x.next; }
        return x;
    } else { // 查找的下标处于数组的后半部分则从尾开始找
        x = this.last;
        for(i = this.size - 1; i &amp;gt; index; --i) { x = x.prev; }
        return x;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;双端队列：使用双端链表实现，并且实现了 &lt;code&gt;Deque&lt;/code&gt; 接口，使得 LinkedList 可以用作&lt;strong&gt;双端队列&lt;/strong&gt;。下图可以看到 Node 是集合中的元素，提供了前驱指针和后继指针，还提供了一系列操作&lt;code&gt;头结点&lt;/code&gt;和&lt;code&gt;尾结点&lt;/code&gt;的方法，具有双端队列的特性。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/1694029/1595693779116-a8156f03-36fa-4557-892e-ea5103b06136.png&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;LinkedList 集合最让人树枝的是它的链表结构，但是我们同时也要注意它是一个双端队列型的集合。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Deque&amp;lt;Object&amp;gt; deque = new LinkedList&amp;lt;&amp;gt;();  
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;queue接口&quot;&gt;Queue接口&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Queue&lt;/code&gt;队列，在 JDK 中有两种不同类型的集合实现：&lt;strong&gt;单向队列&lt;/strong&gt;（AbstractQueue） 和 &lt;strong&gt;双端队列&lt;/strong&gt;（Deque）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/1694029/1595684241064-e863aeca-6a95-4423-92c4-762f56be1dbe.png&quot; alt=&quot;img&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Queue 中提供了两套增加、删除元素的 API，当插入或删除元素失败时，会有&lt;strong&gt;两种不同的失败处理策略&lt;/strong&gt;。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;方法及失败策略&lt;/th&gt;
&lt;th&gt;插入方法&lt;/th&gt;
&lt;th&gt;删除方法&lt;/th&gt;
&lt;th&gt;查找方法&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;抛出异常&lt;/td&gt;
&lt;td&gt;add()&lt;/td&gt;
&lt;td&gt;remove()&lt;/td&gt;
&lt;td&gt;get()&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;返回失败默认值&lt;/td&gt;
&lt;td&gt;offer()&lt;/td&gt;
&lt;td&gt;poll()&lt;/td&gt;
&lt;td&gt;peek()&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;选取哪种方法的决定因素：插入和删除元素失败时，希望&lt;code&gt;抛出异常&lt;/code&gt;还是返回&lt;code&gt;布尔值&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;add()&lt;/code&gt; 和 &lt;code&gt;offer()&lt;/code&gt; 对比：&lt;/p&gt;
&lt;p&gt;在队列长度大小确定的场景下，队列放满元素后，添加下一个元素时，add() 会抛出 &lt;code&gt;IllegalStateException&lt;/code&gt;异常，而 &lt;code&gt;offer()&lt;/code&gt; 会返回 &lt;code&gt;false&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;但是它们两个方法在插入&lt;strong&gt;某些不合法的元素&lt;/strong&gt;时都会抛出三个相同的异常。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/1694029/1595691512036-ed9fd3ea-5432-4105-a3fb-a5374d571971.png&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;remove()&lt;/code&gt; 和 &lt;code&gt;poll()&lt;/code&gt; 对比：&lt;/p&gt;
&lt;p&gt;在&lt;strong&gt;队列为空&lt;/strong&gt;的场景下， &lt;code&gt;remove()&lt;/code&gt; 会抛出 &lt;code&gt;NoSuchElementException&lt;/code&gt;异常，而 &lt;code&gt;poll()&lt;/code&gt; 则返回 &lt;code&gt;null&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;get()&lt;/code&gt;和&lt;code&gt;peek()&lt;/code&gt;对比：&lt;/p&gt;
&lt;p&gt;在队列为空的情况下，&lt;code&gt;get()&lt;/code&gt;会抛出&lt;code&gt;NoSuchElementException&lt;/code&gt;异常，而&lt;code&gt;peek()&lt;/code&gt;则返回&lt;code&gt;null&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;deque-接口&quot;&gt;Deque 接口&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Deque&lt;/code&gt; 接口的实现非常好理解：从&lt;strong&gt;单向&lt;/strong&gt;队列演变为&lt;strong&gt;双向&lt;/strong&gt;队列，内部额外提供&lt;strong&gt;双向队列的操作方法&lt;/strong&gt;即可：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/1694029/1596166722772-975ff644-6abf-441b-b678-4a6de5b0eef1.png&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Deque 接口额外提供了&lt;strong&gt;针对队列的头结点和尾结点&lt;/strong&gt;操作的方法，而&lt;strong&gt;插入、删除方法同样也提供了两套不同的失败策略&lt;/strong&gt;。除了&lt;code&gt;add()&lt;/code&gt;和&lt;code&gt;offer()&lt;/code&gt;，&lt;code&gt;remove()&lt;/code&gt;和&lt;code&gt;poll()&lt;/code&gt;以外，还有&lt;code&gt;get()&lt;/code&gt;和&lt;code&gt;peek()&lt;/code&gt;出现了不同的策略&lt;/p&gt;
&lt;h3 id=&quot;abstractqueue-抽象类&quot;&gt;AbstractQueue 抽象类&lt;/h3&gt;
&lt;p&gt;AbstractQueue 类中提供了各个 API 的基本实现，主要针对各个不同的处理策略给出基本的方法实现，定义在这里的作用是让&lt;code&gt;子类&lt;/code&gt;根据其&lt;code&gt;方法规范&lt;/code&gt;（操作失败时抛出异常还是返回默认值）实现具体的业务逻辑。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/1694029/1596167156067-36121579-8127-4019-ba47-e4de73f05cda.png&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;linkedlist-2&quot;&gt;LinkedList&lt;/h3&gt;
&lt;p&gt;LinkedList 在上面已经详细解释了，它实现了 &lt;code&gt;Deque&lt;/code&gt; 接口，提供了针对头结点和尾结点的操作，并且每个结点都有&lt;strong&gt;前驱&lt;/strong&gt;和&lt;strong&gt;后继&lt;/strong&gt;指针，具备了双向队列的所有特性。&lt;/p&gt;
&lt;h3 id=&quot;arraydeque&quot;&gt;ArrayDeque&lt;/h3&gt;
&lt;p&gt;使用&lt;strong&gt;数组&lt;/strong&gt;实现的双端队列，它是&lt;strong&gt;无界&lt;/strong&gt;的双端队列，最小的容量是&lt;code&gt;8&lt;/code&gt;（JDK 1.8）。在 JDK 11 看到它默认容量已经是 &lt;code&gt;16&lt;/code&gt;了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/1694029/1595695213834-cb4f1c3a-e07a-42aa-981f-31a896febe26.png&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ArrayDeque&lt;/code&gt; 在日常使用得不多，值得注意的是它与 &lt;code&gt;LinkedList&lt;/code&gt; 的对比：&lt;code&gt;LinkedList&lt;/code&gt; 采用&lt;strong&gt;链表&lt;/strong&gt;实现双端队列，而 &lt;code&gt;ArrayDeque&lt;/code&gt; 使用&lt;strong&gt;数组&lt;/strong&gt;实现双端队列。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在文档中作者写到：&lt;strong&gt;ArrayDeque 作为栈时比 Stack 性能好，作为队列时比 LinkedList 性能好&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由于双端队列&lt;strong&gt;只能在头部和尾部&lt;/strong&gt;操作元素，所以删除元素和插入元素的时间复杂度大部分都稳定在 &lt;code&gt;O(1)&lt;/code&gt; ，除非在扩容时会涉及到元素的批量复制操作。但是在大多数情况下，使用它时应该指定一个大概的数组长度，避免频繁的扩容。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;个人观点：链表的插入、删除操作涉及到&lt;strong&gt;指针的操作，我个人认为作者是觉得数组下标的移动要比指针的操作要廉价，而且数组&lt;/strong&gt;采用&lt;strong&gt;连续&lt;/strong&gt;的内存地址空间，而&lt;strong&gt;链表&lt;/strong&gt;元素的内存地址是&lt;strong&gt;不连续&lt;/strong&gt;的，所以数组操作元素的效率在&lt;strong&gt;寻址上&lt;/strong&gt;会比链表要快。请批判看待观点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;priorityqueue&quot;&gt;PriorityQueue&lt;/h3&gt;
&lt;p&gt;PriorityQueue 基于&lt;strong&gt;优先级堆实现&lt;/strong&gt;的优先级队列，而堆是采用&lt;strong&gt;数组&lt;/strong&gt;实现：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/1694029/1595727271522-d144468c-041e-4721-a786-9f952f06fafe.png&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;文档中的描述告诉我们：该数组中的元素通过传入 &lt;code&gt;Comparator&lt;/code&gt; 进行定制排序，如果不传入&lt;code&gt;Comparator&lt;/code&gt;时，则按照元素本身&lt;code&gt;自然排序&lt;/code&gt;，但要求元素实现了&lt;code&gt;Comparable&lt;/code&gt;接口，所以 PriorityQueue &lt;strong&gt;不允许存储 NULL 元素&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;PriorityQueue 应用场景：元素本身具有优先级，需要按照&lt;strong&gt;优先级处理元素&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;例如游戏中的VIP玩家与普通玩家，VIP 等级越高的玩家越先安排进入服务器玩耍，减少玩家流失。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-Java&quot;&gt;public static void main(String[] args) {
    Student vip1 = new Student(&quot;张三&quot;, 1);
    Student vip3 = new Student(&quot;洪七&quot;, 2);
    Student vip4 = new Student(&quot;老八&quot;, 4);
    Student vip2 = new Student(&quot;李四&quot;, 1);
    Student normal1 = new Student(&quot;王五&quot;, 0);
    Student normal2 = new Student(&quot;赵六&quot;, 0);
    // 根据玩家的 VIP 等级进行降序排序
    PriorityQueue&amp;lt;Student&amp;gt; queue = new PriorityQueue&amp;lt;&amp;gt;((o1, o2) -&amp;gt;  o2.getScore().compareTo(o1.getScore()));
    queue.add(vip1);queue.add(vip4);queue.add(vip3);
    queue.add(normal1);queue.add(normal2);queue.add(vip2);
    while (!queue.isEmpty()) {
        Student s1 = queue.poll();
        System.out.println(s1.getName() + &quot;进入游戏; &quot; + &quot;VIP等级: &quot; + s1.getScore());
    }
}
 public static class Student implements Comparable&amp;lt;Student&amp;gt; {
     private String name;
     private Integer score;
     public Student(String name, Integer score) {
         this.name = name;
         this.score = score;
     }
     @Override
     public int compareTo(Student o) {
         return this.score.compareTo(o.getScore());
     }
 }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行上面的代码可以得到下面这种有趣的结果，可以看到&lt;code&gt;氪金&lt;/code&gt;使人带来快乐。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/1694029/1595727945968-768b45bb-96dc-4850-8759-f07776107a23.png&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;VIP 等级越高（优先级越高）就越优先安排进入游戏（优先处理），类似这种有优先级的场景还有非常多，各位可以发挥自己的想象力。&lt;/p&gt;
&lt;p&gt;PriorityQueue 总结：&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;PriorityQueue 是基于&lt;strong&gt;优先级堆&lt;/strong&gt;实现的优先级队列，而堆是用&lt;strong&gt;数组&lt;/strong&gt;维护的&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;PriorityQueue 适用于&lt;strong&gt;元素按优先级处理&lt;/strong&gt;的业务场景，例如用户在请求人工客服需要排队时，根据用户的&lt;strong&gt;VIP等级&lt;/strong&gt;进行 &lt;code&gt;插队&lt;/code&gt; 处理，等级越高，越先安排客服。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;章节结束各集合总结：（以 JDK1.8 为例）&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;数据类型&lt;/th&gt;
&lt;th&gt;插入、删除时间复杂度&lt;/th&gt;
&lt;th&gt;查询时间复杂度&lt;/th&gt;
&lt;th&gt;底层数据结构&lt;/th&gt;
&lt;th&gt;是否线程安全&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;Vector&lt;/td&gt;
&lt;td&gt;O(N)&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;td&gt;数组&lt;/td&gt;
&lt;td&gt;是（已淘汰）&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;ArrayList&lt;/td&gt;
&lt;td&gt;O(N)&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;td&gt;数组&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;LinkedList&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;td&gt;O(N)&lt;/td&gt;
&lt;td&gt;双向链表&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;HashSet&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;td&gt;数组+链表+红黑树&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;TreeSet&lt;/td&gt;
&lt;td&gt;O(logN)&lt;/td&gt;
&lt;td&gt;O(logN)&lt;/td&gt;
&lt;td&gt;红黑树&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;LinkedHashSet&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;td&gt;O(1)~O(N)&lt;/td&gt;
&lt;td&gt;数组 + 链表 + 红黑树&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;ArrayDeque&lt;/td&gt;
&lt;td&gt;O(N)&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;td&gt;数组&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;PriorityQueue&lt;/td&gt;
&lt;td&gt;O(logN)&lt;/td&gt;
&lt;td&gt;O(logN)&lt;/td&gt;
&lt;td&gt;堆（数组实现）&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;HashMap&lt;/td&gt;
&lt;td&gt;O(1) ~ O(N)&lt;/td&gt;
&lt;td&gt;O(1) ~ O(N)&lt;/td&gt;
&lt;td&gt;数组+链表+红黑树&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;TreeMap&lt;/td&gt;
&lt;td&gt;O(logN)&lt;/td&gt;
&lt;td&gt;O(logN)&lt;/td&gt;
&lt;td&gt;数组+红黑树&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;HashTable&lt;/td&gt;
&lt;td&gt;O(1) / O(N)&lt;/td&gt;
&lt;td&gt;O(1) / O(N)&lt;/td&gt;
&lt;td&gt;数组+链表&lt;/td&gt;
&lt;td&gt;是（已淘汰）&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;文末总结&quot;&gt;文末总结&lt;/h2&gt;
&lt;p&gt;这一篇文章对各个集合都有些&lt;code&gt;点到即止&lt;/code&gt;的味道，此文的目的是对整个集合框架有一个较为整体的了解，分析了最常用的集合的相关特性，以及某些特殊集合的应用场景例如&lt;code&gt;TreeSet&lt;/code&gt;、&lt;code&gt;TreeMap&lt;/code&gt;这种可定制排序的集合。&lt;/p&gt;
&lt;ul readability=&quot;5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;Collection&lt;/code&gt; 接口提供了整个集合框架&lt;strong&gt;最通用&lt;/strong&gt;的增删改查以及集合自身操作的抽象方法，让子类去实现&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;Set&lt;/code&gt; 接口决定了它的子类都是&lt;strong&gt;无序、无重复元素&lt;/strong&gt;的集合，其主要实现有HashSet、TreeSet、LinkedHashSet。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;HashSet&lt;/code&gt; 底层采用 &lt;code&gt;HashMap&lt;/code&gt; 实现，而 &lt;code&gt;TreeSet&lt;/code&gt; 底层使用 &lt;code&gt;TreeMap&lt;/code&gt; 实现，大部分 Set 集合的操作都会转换为 Map 的操作，TreeSet 可以将元素按照规则进行&lt;strong&gt;排序&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;List&lt;/code&gt; 接口决定了它的子类都是&lt;strong&gt;有序、可存储重复元素&lt;/strong&gt;的集合，常见的实现有 ArrayList，LinkedList，Vector&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;ArrayList&lt;/code&gt; 使用&lt;strong&gt;数组&lt;/strong&gt;实现，而 LinkedList 使用&lt;strong&gt;链表&lt;/strong&gt;实现，所以它们两个的使用场景几乎是相反的，&lt;strong&gt;频繁查询&lt;/strong&gt;的场景使用 ArrayList，而&lt;strong&gt;频繁插入删除&lt;/strong&gt;的场景最好使用 LinkedList&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LinkedList&lt;/code&gt; 和 &lt;code&gt;ArrayDeque&lt;/code&gt; 都可用于&lt;strong&gt;双端队列&lt;/strong&gt;，而 &lt;em&gt;Josh Bloch and Doug Lea&lt;/em&gt; 认为 &lt;code&gt;ArrayDeque&lt;/code&gt; 具有比 &lt;code&gt;LinkedList&lt;/code&gt; 更好的性能，&lt;code&gt;ArrayDeque&lt;/code&gt;使用&lt;strong&gt;数组&lt;/strong&gt;实现双端队列，&lt;code&gt;LinkedList&lt;/code&gt;使用&lt;strong&gt;链表&lt;/strong&gt;实现双端队列。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;Queue&lt;/code&gt; 接口定义了队列的基本操作，子类集合都会拥有队列的特性：&lt;strong&gt;先进先出&lt;/strong&gt;，主要实现有：LinkedList，ArrayDeque&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;PriorityQueue&lt;/code&gt; 底层使用&lt;strong&gt;二叉堆&lt;/strong&gt;维护的优先级队列，而二叉堆是由&lt;strong&gt;数组&lt;/strong&gt;实现的，它可以按照元素的优先级进行排序，&lt;strong&gt;优先级越高的元素，排在队列前面，优先被弹出处理&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;code&gt;Map&lt;/code&gt;接口定义了该种集合类型是以&lt;code&gt;&amp;lt;key,value&amp;gt;&lt;/code&gt;键值对形式保存，其主要实现有：HashMap，TreeMap，LinkedHashMap，Hashtable&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;LinkedHashMap 底层多加了一条双向链表，设置&lt;code&gt;accessOrder&lt;/code&gt;为&lt;code&gt;true&lt;/code&gt;并重写方法则可以实现&lt;code&gt;LRU&lt;/code&gt;缓存&lt;/li&gt;
&lt;li&gt;TreeMap 底层采用数组+红黑树实现，集合内的元素默认按照自然排序，也可以传入&lt;code&gt;Comparator&lt;/code&gt;定制排序&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;看到这里非常不容易，感谢你愿意阅读我的文章，希望能对你有所帮助，你可以参考着文末总结的顺序，每当我提到一个集合时，回想它的重要知识点是什么，主要就是&lt;code&gt;底层数据结构&lt;/code&gt;，&lt;code&gt;线程安全性&lt;/code&gt;，&lt;code&gt;该集合的一两个特有性质&lt;/code&gt;，只要能够回答出来个大概，我相信之后运用这些数据结构，你能够熟能生巧。&lt;/p&gt;
&lt;p&gt;本文对整个集合体系的所有常用的集合类都分析了，这里并没有对集合内部的实现深入剖析，我想先从最宏观的角度让大家了解每个集合的的作用，应用场景，以及简单的对比，之后会抽时间对常见的集合进行源码剖析，尽情期待，感谢阅读！&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;最后有些话想说：这篇文章花了我半个月去写，也是意义重大，多谢 &lt;code&gt;cxuan&lt;/code&gt;哥一直指导我写文章，一步一步地去打磨出一篇好的文章真的非常不容易，写下的每一个字都能够让别人看得懂是一件非常难的事情，总结出最精华的知识分享给你们也是非常难的一件事情，希望能够一直进步下去！不忘初心，热爱分享，喜爱写作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202008/1515111-20200803081850221-1069203927.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202008/1515111-20200803081839915-731805156.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 03 Aug 2020 00:19:00 +0000</pubDate>
<dc:creator>程序员cxuan</dc:creator>
<og:description>集合在我们日常开发使用的次数数不胜数，ArrayList/LinkedList/HashMap/HashSet&amp;amp;#183;&amp;amp;#183;&amp;amp;#183;&amp;amp;#183;&amp;amp;</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cxuanBlog/p/13424318.html</dc:identifier>
</item>
<item>
<title>《国际化Web项目测试：记第一次兼职测试的经历（一）》 - 测试生财</title>
<link>http://www.cnblogs.com/qa-freeroad/p/13424309.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qa-freeroad/p/13424309.html</guid>
<description>&lt;p&gt;　　疫情期间我一直在家远程办公，无意间接到了个做测试兼职的机会。在&lt;strong&gt;不耽搁本职工作的情况下&lt;/strong&gt;，我从今年五月份开启了&lt;strong&gt;主职和副职的并行的状态&lt;/strong&gt;。这种项目经历对于我来说算是一次全新的体验，当然也真是累的够呛。到目前为止，我已经做了熬过了三个月。当然咯，这种项目是不是长期，能做多久，完全取决于金主爸爸的甲方。在这里，我将分享一下期间我的一些经历，包括&lt;strong&gt;从0到1入组一个团队的整体经历和经验&lt;/strong&gt;，也包括在此过程中&lt;strong&gt;国际化相关的测试经验&lt;/strong&gt;，仅供大家&lt;strong&gt;参考&lt;/strong&gt;和&lt;strong&gt;了解&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　首先说说项目吧，这个项目是一个为全球提供访问服务的站点，主要旨在为第三世界的同胞们提供一个&lt;strong&gt;IT领域&lt;/strong&gt;的在线学习平台（类似于国内的51cto，慕课网之类的这种在线视频学习平台），网站主要使用语言集中在中英法三种语言（想必了解过历史的朋友应该都知道为啥外语用的是英语和法语）。网站运营的模式就是联合国内外相关的企业院校，在平台上发布一些在线课程，然后全球各地的学员们可以通过申报注册个人信息，登录网站进行相关学习。算是和联合国教科文组织开展的一个IT互联网领域知识扶贫的一个项目。嗯，说了这么多，大概就这么一个网站吧！&lt;/p&gt;
&lt;p&gt;　　接着上面说的，刚接到这个活儿的我还是比较懵的，毕竟第一次做这种兼职，没啥经验。回想当初接手这个活儿的初感，大概是这样的：首先这个团队是一个&lt;strong&gt;远程team&lt;/strong&gt;，每个角色都处于全国的不同地区，有兼职也有全职，&lt;strong&gt;办公模式完全是远程协作&lt;/strong&gt;的（这点我觉得很赞，再也不用花一两小时走路上下班了！）。其次，这个Web网址当时给到我的时候，我被震惊到，&lt;strong&gt;网站内容全部都是英语&lt;/strong&gt;，我的天，虽然我高中时期英语全年级考过第一，大学四六级也随便过，看到全英文的网址，并且作为测试项目，我还是有点懵（因为确实没有测试过这种英文网址的经历）。最后，对于国际化这种项目测试，我还有点没有头绪，不知道从何开始，而且这种&lt;strong&gt;远程模式对于上手来说，难度也会偏大&lt;/strong&gt;（没人给你当场解答问题)。带着三点些许的头大，我被推着开始兼职之旅了。&lt;/p&gt;
&lt;p&gt;　　这个项目的团队是属于&lt;strong&gt;远程team&lt;/strong&gt;，且之前换过好几拨人，所以&lt;strong&gt;没什么资料沉淀&lt;/strong&gt;，项目team由一个产品（兼TL）、三个后端开发、两个前端和两个测试（兼职）组成，满打满算7个人左右。整体阵容其实也算豪华，基本都是高级和资深级别的工程师在扛把子。整体项目最开始的协作方式基本是扁平式的沟通，即TL单独和和每个人去协商工作进度，然后当天八点开一个站会同步进度。我刚入项目的第一天认领的任务就是做一些网站的&lt;strong&gt;随机测试&lt;/strong&gt;（其实就是随便点点），看起来很简单，但这个倒有点难到我了，因为随机测试意味着工作的&lt;strong&gt;质&lt;/strong&gt;和&lt;strong&gt;量&lt;/strong&gt;都是不明确的。这里解释一下：&lt;strong&gt;质&lt;/strong&gt;指的是我们测试的&lt;strong&gt;维度&lt;/strong&gt;和&lt;strong&gt;覆盖范围&lt;/strong&gt;是&lt;strong&gt;不明确的&lt;/strong&gt;，比如说我们到底应该着重哪些功能进行测试，哪些功能属于系统易出错的地方；&lt;strong&gt;量&lt;/strong&gt;指的是我们在整个测试活动中到底做了多少测试，还剩多少没做完，无法很好的量化，我们无法在每天站会呈现出&lt;strong&gt;具体的进度&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　那在这里可能有测试同学会说了，这样不是挺好吗，每天点点点就能薅到点收入。当然了，我也梦想着躺赚，但是毕竟只有可持续的发展才是真正值得坚持的发展。如果长期习惯了这样的工作挣钱方式，总有一天黑天鹅会主动飞到你的身边。。。&lt;/p&gt;
&lt;p&gt;　　今天先写这么多吧，关于我是怎么处理这个随机测试的窘境，未完待续。。。&lt;/p&gt;
</description>
<pubDate>Mon, 03 Aug 2020 00:09:00 +0000</pubDate>
<dc:creator>测试生财</dc:creator>
<og:description>疫情期间我一直在家远程办公，无意间接到了个做测试兼职的机会。在不耽搁本职工作的情况下，我从今年五月份开启了主职和副职的并行的状态。这种项目经历对于我来说算是一次全新的体验，当然也真是累的够呛。到目前为</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qa-freeroad/p/13424309.html</dc:identifier>
</item>
<item>
<title>Spring Validation最佳实践及其实现原理，参数校验没那么简单！ - 六点半起床</title>
<link>http://www.cnblogs.com/chentianming/p/13424303.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chentianming/p/13424303.html</guid>
<description>&lt;p&gt;之前也写过一篇关于&lt;code&gt;Spring Validation&lt;/code&gt;使用的文章，不过自我感觉还是浮于表面，本次打算彻底搞懂&lt;code&gt;Spring Validation&lt;/code&gt;。本文会详细介绍&lt;code&gt;Spring Validation&lt;/code&gt;各种场景下的最佳实践及其实现原理，死磕到底！&lt;br/&gt;项目源码：&lt;a href=&quot;https://github.com/chentianming11/spring-validation&quot;&gt;spring-validation&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;简单使用&quot;&gt;简单使用&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Java API&lt;/code&gt;规范(&lt;code&gt;JSR303&lt;/code&gt;)定义了&lt;code&gt;Bean&lt;/code&gt;校验的标准&lt;code&gt;validation-api&lt;/code&gt;，但没有提供实现。&lt;code&gt;hibernate validation&lt;/code&gt;是对这个规范的实现，并增加了校验注解如&lt;code&gt;@Email&lt;/code&gt;、&lt;code&gt;@Length&lt;/code&gt;等。&lt;code&gt;Spring Validation&lt;/code&gt;是对&lt;code&gt;hibernate validation&lt;/code&gt;的二次封装，用于支持&lt;code&gt;spring mvc&lt;/code&gt;参数自动校验。接下来，我们以&lt;code&gt;spring-boot&lt;/code&gt;项目为例，介绍&lt;code&gt;Spring Validation&lt;/code&gt;的使用。&lt;/p&gt;
&lt;h3 id=&quot;引入依赖&quot;&gt;引入依赖&lt;/h3&gt;
&lt;p&gt;如果&lt;code&gt;spring-boot&lt;/code&gt;版本小于&lt;code&gt;2.3.x&lt;/code&gt;，&lt;code&gt;spring-boot-starter-web&lt;/code&gt;会自动传入&lt;code&gt;hibernate-validator&lt;/code&gt;依赖。如果&lt;code&gt;spring-boot&lt;/code&gt;版本大于&lt;code&gt;2.3.x&lt;/code&gt;，则需要手动引入依赖：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.hibernate&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;hibernate-validator&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;6.0.1.Final&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于&lt;code&gt;web&lt;/code&gt;服务来说，为防止非法参数对业务造成影响，在&lt;code&gt;Controller&lt;/code&gt;层一定要做参数校验的！大部分情况下，请求参数分为如下两种形式：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;POST&lt;/code&gt;、&lt;code&gt;PUT&lt;/code&gt;请求，使用&lt;code&gt;requestBody&lt;/code&gt;传递参数；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GET&lt;/code&gt;请求，使用&lt;code&gt;requestParam/PathVariable&lt;/code&gt;传递参数。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;下面我们简单介绍下&lt;code&gt;requestBody&lt;/code&gt;和&lt;code&gt;requestParam/PathVariable&lt;/code&gt;的参数校验实战！&lt;/p&gt;
&lt;h3 id=&quot;requestbody参数校验&quot;&gt;&lt;code&gt;requestBody&lt;/code&gt;参数校验&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;POST&lt;/code&gt;、&lt;code&gt;PUT&lt;/code&gt;请求一般会使用&lt;code&gt;requestBody&lt;/code&gt;传递参数，这种情况下，后端使用&lt;strong&gt;DTO对象&lt;/strong&gt;进行接收。&lt;strong&gt;只要给DTO对象加上&lt;code&gt;@Validated&lt;/code&gt;注解就能实现自动参数校验&lt;/strong&gt;。比如，有一个保存&lt;code&gt;User&lt;/code&gt;的接口，要求&lt;code&gt;userName&lt;/code&gt;长度是&lt;code&gt;2-10&lt;/code&gt;，&lt;code&gt;account&lt;/code&gt;和&lt;code&gt;password&lt;/code&gt;字段长度是&lt;code&gt;6-20&lt;/code&gt;。如果校验失败，会抛出&lt;code&gt;MethodArgumentNotValidException&lt;/code&gt;异常，&lt;code&gt;Spring&lt;/code&gt;默认会将其转为&lt;code&gt;400（Bad Request）&lt;/code&gt;请求。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;DTO表示数据传输对象（Data Transfer Object），用于服务器和客户端之间交互传输使用的&lt;/strong&gt;。在spring-web项目中可以表示用于接收请求参数的&lt;code&gt;Bean&lt;/code&gt;对象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;在&lt;code&gt;DTO&lt;/code&gt;字段上声明约束注解&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Data
public class UserDTO {

    private Long userId;

    @NotNull
    @Length(min = 2, max = 10)
    private String userName;

    @NotNull
    @Length(min = 6, max = 20)
    private String account;

    @NotNull
    @Length(min = 6, max = 20)
    private String password;
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;在方法参数上声明校验注解&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@PostMapping(&quot;/save&quot;)
public Result saveUser(@RequestBody @Validated UserDTO userDTO) {
    // 校验通过，才会执行业务逻辑处理
    return Result.ok();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这种情况下，&lt;strong&gt;使用&lt;code&gt;@Valid&lt;/code&gt;和&lt;code&gt;@Validated&lt;/code&gt;都可以&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;requestparampathvariable参数校验&quot;&gt;&lt;code&gt;requestParam/PathVariable&lt;/code&gt;参数校验&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;GET&lt;/code&gt;请求一般会使用&lt;code&gt;requestParam/PathVariable&lt;/code&gt;传参。如果参数比较多(比如超过6个)，还是推荐使用&lt;code&gt;DTO&lt;/code&gt;对象接收。否则，推荐将一个个参数平铺到方法入参中。在这种情况下，&lt;strong&gt;必须在&lt;code&gt;Controller&lt;/code&gt;类上标注&lt;code&gt;@Validated&lt;/code&gt;注解，并在入参上声明约束注解(如&lt;code&gt;@Min&lt;/code&gt;等)&lt;/strong&gt;。如果校验失败，会抛出&lt;code&gt;ConstraintViolationException&lt;/code&gt;异常。代码示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@RequestMapping(&quot;/api/user&quot;)
@RestController
@Validated
public class UserController {
    // 路径变量
    @GetMapping(&quot;{userId}&quot;)
    public Result detail(@PathVariable(&quot;userId&quot;) @Min(10000000000000000L) Long userId) {
        // 校验通过，才会执行业务逻辑处理
        UserDTO userDTO = new UserDTO();
        userDTO.setUserId(userId);
        userDTO.setAccount(&quot;11111111111111111&quot;);
        userDTO.setUserName(&quot;xixi&quot;);
        userDTO.setAccount(&quot;11111111111111111&quot;);
        return Result.ok(userDTO);
    }

    // 查询参数
    @GetMapping(&quot;getByAccount&quot;)
    public Result getByAccount(@Length(min = 6, max = 20) @NotNull String  account) {
        // 校验通过，才会执行业务逻辑处理
        UserDTO userDTO = new UserDTO();
        userDTO.setUserId(10000000000000003L);
        userDTO.setAccount(account);
        userDTO.setUserName(&quot;xixi&quot;);
        userDTO.setAccount(&quot;11111111111111111&quot;);
        return Result.ok(userDTO);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;统一异常处理&quot;&gt;统一异常处理&lt;/h3&gt;
&lt;p&gt;前面说过，如果校验失败，会抛出&lt;code&gt;MethodArgumentNotValidException&lt;/code&gt;或者&lt;code&gt;ConstraintViolationException&lt;/code&gt;异常。在实际项目开发中，通常会用&lt;strong&gt;统一异常处理&lt;/strong&gt;来返回一个更友好的提示。比如我们系统要求无论发送什么异常，&lt;code&gt;http&lt;/code&gt;的状态码必须返回&lt;code&gt;200&lt;/code&gt;，由业务码去区分系统的异常情况。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@RestControllerAdvice
public class CommonExceptionHandler {

    @ExceptionHandler({MethodArgumentNotValidException.class})
    @ResponseStatus(HttpStatus.OK)
    @ResponseBody
    public Result handleMethodArgumentNotValidException(MethodArgumentNotValidException ex) {
        BindingResult bindingResult = ex.getBindingResult();
        StringBuilder sb = new StringBuilder(&quot;校验失败:&quot;);
        for (FieldError fieldError : bindingResult.getFieldErrors()) {
            sb.append(fieldError.getField()).append(&quot;：&quot;).append(fieldError.getDefaultMessage()).append(&quot;, &quot;);
        }
        String msg = sb.toString();
       return Result.fail(BusinessCode.参数校验失败, msg);
    }

    @ExceptionHandler({ConstraintViolationException.class})
    @ResponseStatus(HttpStatus.OK)
    @ResponseBody
    public Result handleConstraintViolationException(ConstraintViolationException ex) {
        return Result.fail(BusinessCode.参数校验失败, ex.getMessage());
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;进阶使用&quot;&gt;进阶使用&lt;/h2&gt;
&lt;h3 id=&quot;分组校验&quot;&gt;分组校验&lt;/h3&gt;
&lt;p&gt;在实际项目中，可能多个方法需要使用同一个&lt;code&gt;DTO&lt;/code&gt;类来接收参数，而不同方法的校验规则很可能是不一样的。这个时候，简单地在&lt;code&gt;DTO&lt;/code&gt;类的字段上加约束注解无法解决这个问题。因此，&lt;code&gt;spring-validation&lt;/code&gt;支持了&lt;strong&gt;分组校验&lt;/strong&gt;的功能，专门用来解决这类问题。还是上面的例子，比如保存&lt;code&gt;User&lt;/code&gt;的时候，&lt;code&gt;UserId&lt;/code&gt;是可空的，但是更新&lt;code&gt;User&lt;/code&gt;的时候，&lt;code&gt;UserId&lt;/code&gt;的值必须&lt;code&gt;&amp;gt;=10000000000000000L&lt;/code&gt;；其它字段的校验规则在两种情况下一样。这个时候使用&lt;strong&gt;分组校验&lt;/strong&gt;的代码示例如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;约束注解上声明适用的分组信息&lt;code&gt;groups&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Data
public class UserDTO {

    @Min(value = 10000000000000000L, groups = Update.class)
    private Long userId;

    @NotNull(groups = {Save.class, Update.class})
    @Length(min = 2, max = 10, groups = {Save.class, Update.class})
    private String userName;

    @NotNull(groups = {Save.class, Update.class})
    @Length(min = 6, max = 20, groups = {Save.class, Update.class})
    private String account;

    @NotNull(groups = {Save.class, Update.class})
    @Length(min = 6, max = 20, groups = {Save.class, Update.class})
    private String password;

    /**
     * 保存的时候校验分组
     */
    public interface Save {
    }

    /**
     * 更新的时候校验分组
     */
    public interface Update {
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;@Validated&lt;/code&gt;注解上指定校验分组&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@PostMapping(&quot;/save&quot;)
public Result saveUser(@RequestBody @Validated(UserDTO.Save.class) UserDTO userDTO) {
    // 校验通过，才会执行业务逻辑处理
    return Result.ok();
}

@PostMapping(&quot;/update&quot;)
public Result updateUser(@RequestBody @Validated(UserDTO.Update.class) UserDTO userDTO) {
    // 校验通过，才会执行业务逻辑处理
    return Result.ok();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;嵌套校验&quot;&gt;嵌套校验&lt;/h3&gt;
&lt;p&gt;前面的示例中，&lt;code&gt;DTO&lt;/code&gt;类里面的字段都是&lt;code&gt;基本数据类型&lt;/code&gt;和&lt;code&gt;String&lt;/code&gt;类型。但是实际场景中，有可能某个字段也是一个对象，这种情况先，可以使用&lt;code&gt;嵌套校验&lt;/code&gt;。比如，上面保存&lt;code&gt;User&lt;/code&gt;信息的时候同时还带有&lt;code&gt;Job&lt;/code&gt;信息。需要注意的是，&lt;strong&gt;此时&lt;code&gt;DTO&lt;/code&gt;类的对应字段必须标记&lt;code&gt;@Valid&lt;/code&gt;注解&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Data
public class UserDTO {

    @Min(value = 10000000000000000L, groups = Update.class)
    private Long userId;

    @NotNull(groups = {Save.class, Update.class})
    @Length(min = 2, max = 10, groups = {Save.class, Update.class})
    private String userName;

    @NotNull(groups = {Save.class, Update.class})
    @Length(min = 6, max = 20, groups = {Save.class, Update.class})
    private String account;

    @NotNull(groups = {Save.class, Update.class})
    @Length(min = 6, max = 20, groups = {Save.class, Update.class})
    private String password;

    @NotNull(groups = {Save.class, Update.class})
    @Valid
    private Job job;

    @Data
    public static class Job {

        @Min(value = 1, groups = Update.class)
        private Long jobId;

        @NotNull(groups = {Save.class, Update.class})
        @Length(min = 2, max = 10, groups = {Save.class, Update.class})
        private String jobName;

        @NotNull(groups = {Save.class, Update.class})
        @Length(min = 2, max = 10, groups = {Save.class, Update.class})
        private String position;
    }

    /**
     * 保存的时候校验分组
     */
    public interface Save {
    }

    /**
     * 更新的时候校验分组
     */
    public interface Update {
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;嵌套校验可以结合分组校验一起使用。还有就是&lt;code&gt;嵌套集合校验&lt;/code&gt;会对集合里面的每一项都进行校验，例如&lt;code&gt;List&amp;lt;Job&amp;gt;&lt;/code&gt;字段会对这个&lt;code&gt;list&lt;/code&gt;里面的每一个&lt;code&gt;Job&lt;/code&gt;对象都进行校验。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;集合校验&quot;&gt;集合校验&lt;/h3&gt;
&lt;p&gt;如果请求体直接传递了&lt;code&gt;json&lt;/code&gt;数组给后台，并希望对数组中的每一项都进行参数校验。此时，如果我们直接使用&lt;code&gt;java.util.Collection&lt;/code&gt;下的&lt;code&gt;list&lt;/code&gt;或者&lt;code&gt;set&lt;/code&gt;来接收数据，参数校验并不会生效！我们可以使用自定义&lt;code&gt;list&lt;/code&gt;集合来接收参数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;包装&lt;code&gt;List&lt;/code&gt;类型，并声明&lt;code&gt;@Valid&lt;/code&gt;注解&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class ValidationList&amp;lt;E&amp;gt; implements List&amp;lt;E&amp;gt; {

    @Delegate // @Delegate是lombok注解
    @Valid // 一定要加@Valid注解
    public List&amp;lt;E&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();

    // 一定要记得重写toString方法
    @Override
    public String toString() {
        return list.toString();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;code&gt;@Delegate&lt;/code&gt;注解受&lt;code&gt;lombok&lt;/code&gt;版本限制，&lt;code&gt;1.18.6&lt;/code&gt;以上版本可支持。如果校验不通过，会抛出&lt;code&gt;NotReadablePropertyException&lt;/code&gt;，同样可以使用统一异常进行处理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;比如，我们需要一次性保存多个&lt;code&gt;User&lt;/code&gt;对象，&lt;code&gt;Controller&lt;/code&gt;层的方法可以这么写：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@PostMapping(&quot;/saveList&quot;)
public Result saveList(@RequestBody @Validated(UserDTO.Save.class) ValidationList&amp;lt;UserDTO&amp;gt; userList) {
    // 校验通过，才会执行业务逻辑处理
    return Result.ok();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;自定义校验&quot;&gt;自定义校验&lt;/h3&gt;
&lt;p&gt;业务需求总是比框架提供的这些简单校验要复杂的多，我们可以自定义校验来满足我们的需求。自定义&lt;code&gt;spring validation&lt;/code&gt;非常简单，假设我们自定义&lt;code&gt;加密id&lt;/code&gt;（由数字或者&lt;code&gt;a-f&lt;/code&gt;的字母组成，&lt;code&gt;32-256&lt;/code&gt;长度）校验，主要分为两步：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;自定义约束注解&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Target({METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER})
@Retention(RUNTIME)
@Documented
@Constraint(validatedBy = {EncryptIdValidator.class})
public @interface EncryptId {

    // 默认错误消息
    String message() default &quot;加密id格式错误&quot;;

    // 分组
    Class&amp;lt;?&amp;gt;[] groups() default {};

    // 负载
    Class&amp;lt;? extends Payload&amp;gt;[] payload() default {};
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;实现&lt;code&gt;ConstraintValidator&lt;/code&gt;接口编写约束校验器&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class EncryptIdValidator implements ConstraintValidator&amp;lt;EncryptId, String&amp;gt; {

    private static final Pattern PATTERN = Pattern.compile(&quot;^[a-f\\d]{32,256}$&quot;);

    @Override
    public boolean isValid(String value, ConstraintValidatorContext context) {
        // 不为null才进行校验
        if (value != null) {
            Matcher matcher = PATTERN.matcher(value);
            return matcher.find();
        }
        return true;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样我们就可以使用&lt;code&gt;@EncryptId&lt;/code&gt;进行参数校验了！&lt;/p&gt;
&lt;h3 id=&quot;编程式校验&quot;&gt;编程式校验&lt;/h3&gt;
&lt;p&gt;上面的示例都是基于&lt;code&gt;注解&lt;/code&gt;来实现自动校验的，在某些情况下，我们可能希望以&lt;code&gt;编程方式&lt;/code&gt;调用验证。这个时候可以注入&lt;code&gt;javax.validation.Validator&lt;/code&gt;对象，然后再调用其&lt;code&gt;api&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Autowired
private javax.validation.Validator globalValidator;

// 编程式校验
@PostMapping(&quot;/saveWithCodingValidate&quot;)
public Result saveWithCodingValidate(@RequestBody UserDTO userDTO) {
    Set&amp;lt;ConstraintViolation&amp;lt;UserDTO&amp;gt;&amp;gt; validate = globalValidator.validate(userDTO, UserDTO.Save.class);
    // 如果校验通过，validate为空；否则，validate包含未校验通过项
    if (validate.isEmpty()) {
        // 校验通过，才会执行业务逻辑处理

    } else {
        for (ConstraintViolation&amp;lt;UserDTO&amp;gt; userDTOConstraintViolation : validate) {
            // 校验失败，做其它逻辑
            System.out.println(userDTOConstraintViolation);
        }
    }
    return Result.ok();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;快速失败fail-fast&quot;&gt;快速失败(Fail Fast)&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Spring Validation&lt;/code&gt;默认会校验完所有字段，然后才抛出异常。可以通过一些简单的配置，开启&lt;code&gt;Fali Fast&lt;/code&gt;模式，一旦校验失败就立即返回。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Bean
public Validator validator() {
    ValidatorFactory validatorFactory = Validation.byProvider(HibernateValidator.class)
            .configure()
            // 快速失败模式
            .failFast(true)
            .buildValidatorFactory();
    return validatorFactory.getValidator();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;valid和validated区别&quot;&gt;&lt;code&gt;@Valid&lt;/code&gt;和&lt;code&gt;@Validated&lt;/code&gt;区别&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;区别&lt;/th&gt;
&lt;th&gt;@Valid&lt;/th&gt;
&lt;th&gt;@Validated&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr&gt;&lt;td&gt;提供者&lt;/td&gt;
&lt;td&gt;JSR-303规范&lt;/td&gt;
&lt;td&gt;Spring&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;是否支持分组&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;标注位置&lt;/td&gt;
&lt;td&gt;METHOD, FIELD, CONSTRUCTOR, PARAMETER, TYPE_USE&lt;/td&gt;
&lt;td&gt;TYPE, METHOD, PARAMETER&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;嵌套校验&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;实现原理&quot;&gt;实现原理&lt;/h2&gt;
&lt;h3 id=&quot;requestbody参数校验实现原理&quot;&gt;&lt;code&gt;requestBody&lt;/code&gt;参数校验实现原理&lt;/h3&gt;
&lt;p&gt;在&lt;code&gt;spring-mvc&lt;/code&gt;中，&lt;code&gt;RequestResponseBodyMethodProcessor&lt;/code&gt;是用于解析&lt;code&gt;@RequestBody&lt;/code&gt;标注的参数以及处理&lt;code&gt;@ResponseBody&lt;/code&gt;标注方法的返回值的。显然，执行参数校验的逻辑肯定就在解析参数的方法&lt;code&gt;resolveArgument()&lt;/code&gt;中：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class RequestResponseBodyMethodProcessor extends AbstractMessageConverterMethodProcessor {
    @Override
    public Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,
                                  NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception {

        parameter = parameter.nestedIfOptional();
        //将请求数据封装到DTO对象中
        Object arg = readWithMessageConverters(webRequest, parameter, parameter.getNestedGenericParameterType());
        String name = Conventions.getVariableNameForParameter(parameter);

        if (binderFactory != null) {
            WebDataBinder binder = binderFactory.createBinder(webRequest, arg, name);
            if (arg != null) {
                // 执行数据校验
                validateIfApplicable(binder, parameter);
                if (binder.getBindingResult().hasErrors() &amp;amp;&amp;amp; isBindExceptionRequired(binder, parameter)) {
                    throw new MethodArgumentNotValidException(parameter, binder.getBindingResult());
                }
            }
            if (mavContainer != null) {
                mavContainer.addAttribute(BindingResult.MODEL_KEY_PREFIX + name, binder.getBindingResult());
            }
        }
        return adaptArgumentIfNecessary(arg, parameter);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，&lt;code&gt;resolveArgument()&lt;/code&gt;调用了&lt;code&gt;validateIfApplicable()&lt;/code&gt;进行参数校验。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;protected void validateIfApplicable(WebDataBinder binder, MethodParameter parameter) {
    // 获取参数注解，比如@RequestBody、@Valid、@Validated
    Annotation[] annotations = parameter.getParameterAnnotations();
    for (Annotation ann : annotations) {
        // 先尝试获取@Validated注解
        Validated validatedAnn = AnnotationUtils.getAnnotation(ann, Validated.class);
        //如果直接标注了@Validated，那么直接开启校验。
        //如果没有，那么判断参数前是否有Valid起头的注解。
        if (validatedAnn != null || ann.annotationType().getSimpleName().startsWith(&quot;Valid&quot;)) {
            Object hints = (validatedAnn != null ? validatedAnn.value() : AnnotationUtils.getValue(ann));
            Object[] validationHints = (hints instanceof Object[] ? (Object[]) hints : new Object[] {hints});
            //执行校验
            binder.validate(validationHints);
            break;
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看到这里，大家应该能明白为什么这种场景下&lt;code&gt;@Validated&lt;/code&gt;、&lt;code&gt;@Valid&lt;/code&gt;两个注解可以混用。我们接下来继续看&lt;code&gt;WebDataBinder.validate()&lt;/code&gt;实现。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Override
public void validate(Object target, Errors errors, Object... validationHints) {
    if (this.targetValidator != null) {
        processConstraintViolations(
            //此处调用Hibernate Validator执行真正的校验
            this.targetValidator.validate(target, asValidationGroups(validationHints)), errors);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最终发现底层最终还是调用了&lt;code&gt;Hibernate Validator&lt;/code&gt;进行真正的校验处理。&lt;/p&gt;
&lt;h3 id=&quot;方法级别的参数校验实现原理&quot;&gt;方法级别的参数校验实现原理&lt;/h3&gt;
&lt;p&gt;上面提到的将参数一个个平铺到方法参数中，然后在每个参数前面声明&lt;code&gt;约束注解&lt;/code&gt;的校验方式，就是方法级别的参数校验。实际上，这种方式可用于任何&lt;code&gt;Spring Bean&lt;/code&gt;的方法上，比如&lt;code&gt;Controller&lt;/code&gt;/&lt;code&gt;Service&lt;/code&gt;等。&lt;strong&gt;其底层实现原理就是&lt;code&gt;AOP&lt;/code&gt;，具体来说是通过&lt;code&gt;MethodValidationPostProcessor&lt;/code&gt;动态注册&lt;code&gt;AOP&lt;/code&gt;切面，然后使用&lt;code&gt;MethodValidationInterceptor&lt;/code&gt;对切点方法织入增强&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class MethodValidationPostProcessor extends AbstractBeanFactoryAwareAdvisingPostProcessorimplements InitializingBean {
    @Override
    public void afterPropertiesSet() {
        //为所有`@Validated`标注的Bean创建切面
        Pointcut pointcut = new AnnotationMatchingPointcut(this.validatedAnnotationType, true);
        //创建Advisor进行增强
        this.advisor = new DefaultPointcutAdvisor(pointcut, createMethodValidationAdvice(this.validator));
    }

    //创建Advice，本质就是一个方法拦截器
    protected Advice createMethodValidationAdvice(@Nullable Validator validator) {
        return (validator != null ? new MethodValidationInterceptor(validator) : new MethodValidationInterceptor());
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着看一下&lt;code&gt;MethodValidationInterceptor&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class MethodValidationInterceptor implements MethodInterceptor {
    @Override
    public Object invoke(MethodInvocation invocation) throws Throwable {
        //无需增强的方法，直接跳过
        if (isFactoryBeanMetadataMethod(invocation.getMethod())) {
            return invocation.proceed();
        }
        //获取分组信息
        Class&amp;lt;?&amp;gt;[] groups = determineValidationGroups(invocation);
        ExecutableValidator execVal = this.validator.forExecutables();
        Method methodToValidate = invocation.getMethod();
        Set&amp;lt;ConstraintViolation&amp;lt;Object&amp;gt;&amp;gt; result;
        try {
            //方法入参校验，最终还是委托给Hibernate Validator来校验
            result = execVal.validateParameters(
                invocation.getThis(), methodToValidate, invocation.getArguments(), groups);
        }
        catch (IllegalArgumentException ex) {
            ...
        }
        //有异常直接抛出
        if (!result.isEmpty()) {
            throw new ConstraintViolationException(result);
        }
        //真正的方法调用
        Object returnValue = invocation.proceed();
        //对返回值做校验，最终还是委托给Hibernate Validator来校验
        result = execVal.validateReturnValue(invocation.getThis(), methodToValidate, returnValue, groups);
        //有异常直接抛出
        if (!result.isEmpty()) {
            throw new ConstraintViolationException(result);
        }
        return returnValue;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;实际上，不管是&lt;code&gt;requestBody参数校验&lt;/code&gt;还是&lt;code&gt;方法级别的校验&lt;/code&gt;，最终都是调用&lt;code&gt;Hibernate Validator&lt;/code&gt;执行校验，&lt;code&gt;Spring Validation&lt;/code&gt;只是做了一层封装&lt;/strong&gt;。&lt;/p&gt;
</description>
<pubDate>Mon, 03 Aug 2020 00:07:00 +0000</pubDate>
<dc:creator>六点半起床</dc:creator>
<og:description>之前也写过一篇关于Spring Validation使用的文章，不过自我感觉还是浮于表面，本次打算彻底搞懂Spring Validation。本文会详细介绍Spring Validation各种场景下</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chentianming/p/13424303.html</dc:identifier>
</item>
<item>
<title>一文学会MySQL的explain工具 - 行无际</title>
<link>http://www.cnblogs.com/itwild/p/13424113.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/itwild/p/13424113.html</guid>
<description>&lt;h2 id=&quot;开篇说明&quot;&gt;开篇说明&lt;/h2&gt;
&lt;p&gt;(1) 本文将细致介绍MySQL的explain工具，是下一篇《一文读懂MySQL的索引机制及查询优化》的准备篇。&lt;/p&gt;
&lt;p&gt;(2) 本文主要基于MySQL&lt;code&gt;5.7&lt;/code&gt;版本(&lt;code&gt;https://dev.mysql.com/doc/refman/5.7/en/&lt;/code&gt;)，MySQL&lt;code&gt;8.x&lt;/code&gt;版本可另行翻阅对应版本文档(&lt;code&gt;https://dev.mysql.com/doc/refman/8.0/en/&lt;/code&gt;)。&lt;/p&gt;
&lt;p&gt;(3) 演示过程中的建库、建表、建索引等语句仅为了测试explain工具的使用，并未考虑实际应用场景的合理性。&lt;/p&gt;
&lt;h2 id=&quot;explain工具介绍&quot;&gt;explain工具介绍&lt;/h2&gt;
&lt;p&gt;相关文档：&lt;br/&gt;&lt;code&gt;https://dev.mysql.com/doc/refman/5.7/en/explain.html&lt;/code&gt;&lt;br/&gt;&lt;code&gt;https://dev.mysql.com/doc/refman/5.7/en/using-explain.html&lt;/code&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;EXPLAIN is used to obtain a query execution plan (that is, an explanation of how MySQL would execute a query).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单翻译一下，就是explain用于获取查询执行计划（即MySQL是如何执行一个查询的）。&lt;/p&gt;
&lt;p&gt;工作中，我们会遇到慢查询，这个时候我们就可以在&lt;code&gt;select&lt;/code&gt;语句之前增加&lt;code&gt;explain&lt;/code&gt;关键字，模拟MySQL优化器执行SQL语句，从而分析该SQL语句有没有用上索引、是否全表扫描、能否进一步优化等。&lt;/p&gt;
&lt;p&gt;还是来个快速入门的案例比较直观，依次在mysql的命令行执行下面几条语句(建库、建表sql脚本见下面的&lt;code&gt;数据准备&lt;/code&gt;部分)：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sh&quot;&gt;mysql&amp;gt; use `explain_test`;
mysql&amp;gt; select * from tb_hero where hero_name = '李寻欢' and book_id = 1;
mysql&amp;gt; explain select * from tb_hero where hero_name = '李寻欢' and book_id = 1;
mysql&amp;gt; show warnings \G
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;得到下面的输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sh&quot;&gt;mysql&amp;gt; use `explain_test`;
Database changed
mysql&amp;gt; select * from tb_hero where hero_name = '李寻欢' and book_id = 1;
+---------+-----------+--------------+---------+
| hero_id | hero_name | skill        | book_id |
+---------+-----------+--------------+---------+
|       1 | 李寻欢    | 小李飞刀     |       1 |
+---------+-----------+--------------+---------+
1 row in set (0.00 sec)

mysql&amp;gt; explain select * from tb_hero where hero_name = '李寻欢' and book_id = 1;
+----+-------------+---------+------------+------+-----------------------+-----------------------+---------+-------------+------+----------+-------+
| id | select_type | table   | partitions | type | possible_keys         | key                   | key_len | ref         | rows | filtered | Extra |
+----+-------------+---------+------------+------+-----------------------+-----------------------+---------+-------------+------+----------+-------+
|  1 | SIMPLE      | tb_hero | NULL       | ref  | idx_book_id_hero_name | idx_book_id_hero_name | 136     | const,const |    1 |   100.00 | NULL  |
+----+-------------+---------+------------+------+-----------------------+-----------------------+---------+-------------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)

mysql&amp;gt; show warnings \G
*************************** 1. row ***************************
  Level: Note
   Code: 1003
Message: /* select#1 */ select `explain_test`.`tb_hero`.`hero_id` AS `hero_id`,`explain_test`.`tb_hero`.`hero_name` AS `hero_name`,`explain_test`.`tb_hero`.`skill` AS `skill`,`explain_test`.`tb_hero`.`book_id` AS `book_id` from `explain_test`.`tb_hero` where ((`explain_test`.`tb_hero`.`book_id` = 1) and (`explain_test`.`tb_hero`.`hero_name` = '李寻欢'))
1 row in set (0.00 sec)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;先别急&lt;code&gt;explain&lt;/code&gt;语句输出结果每一列表示什么意思(后面会具体描述)，用&lt;code&gt;show warnings&lt;/code&gt;命令可以得到优化后的查询语句大致长什么样子。&lt;/p&gt;
&lt;p&gt;补充：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;有关&lt;code&gt;show warnings&lt;/code&gt;更详细的使用见&lt;code&gt;https://dev.mysql.com/doc/refman/5.7/en/show-warnings.html&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;有关获取&lt;code&gt;explain&lt;/code&gt;额外的输出信息见&lt;code&gt;https://dev.mysql.com/doc/refman/5.7/en/explain-extended.html&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;原SQL语句：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sh&quot;&gt;select * from tb_hero where hero_name = '李寻欢' and book_id = 1;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;优化后的SQL语句：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sh&quot;&gt;select `explain_test`.`tb_hero`.`hero_id`   AS `hero_id`,
       `explain_test`.`tb_hero`.`hero_name` AS `hero_name`,
       `explain_test`.`tb_hero`.`skill`     AS `skill`,
       `explain_test`.`tb_hero`.`book_id`   AS `book_id`
from `explain_test`.`tb_hero`
where ((`explain_test`.`tb_hero`.`book_id` = 1) and (`explain_test`.`tb_hero`.`hero_name` = '李寻欢'))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看出，MySQL优化器把&lt;code&gt;*&lt;/code&gt;优化成具体的列名，另外把我&lt;code&gt;where&lt;/code&gt;中的两个过滤条件&lt;code&gt;hero_name&lt;/code&gt;、&lt;code&gt;book_id&lt;/code&gt;先后顺序调换了一下，这种顺序调换是概率性事件还是另有文章？&lt;br/&gt;(哈哈哈，(●´ω｀●)留个悬念，本篇仅介绍explain工具，读了下篇《一文读懂MySQL的索引机制及查询优化》后自然豁然开朗)&lt;/p&gt;
&lt;h2 id=&quot;数据准备&quot;&gt;数据准备&lt;/h2&gt;
&lt;p&gt;为了方便演示explain工具的使用以及输出结果的含义，准备了一些测试数据，初始化sql脚本如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sh&quot;&gt;-- ----------------------------
--  create database
-- ----------------------------
DROP database IF EXISTS `explain_test`;
create database `explain_test` DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- switch database
use `explain_test`;

-- ----------------------------
--  table structure for `tb_book`
-- ----------------------------
DROP TABLE IF EXISTS `tb_book`;
CREATE TABLE `tb_book` (
  `book_id` int(11) NOT NULL,
  `book_name` varchar(64) DEFAULT NULL,
  `author` varchar(32) DEFAULT NULL,
  PRIMARY KEY (`book_id`),
  UNIQUE KEY `uk_book_name` (`book_name`) USING BTREE,
  INDEX `idx_author` (`author`) USING BTREE
);

BEGIN;
INSERT INTO `tb_book`(`book_id`, `book_name`, `author`) VALUES (1, '多情剑客无情剑', '古龙');
INSERT INTO `tb_book`(`book_id`, `book_name`, `author`) VALUES (2, '笑傲江湖', '金庸');
INSERT INTO `tb_book`(`book_id`, `book_name`, `author`) VALUES (3, '倚天屠龙记', '金庸');
INSERT INTO `tb_book`(`book_id`, `book_name`, `author`) VALUES (4, '射雕英雄传', '金庸');
INSERT INTO `tb_book`(`book_id`, `book_name`, `author`) VALUES (5, '绝代双骄', '古龙');
COMMIT;

-- ----------------------------
--  table structure for `tb_hero`
-- ----------------------------
DROP TABLE IF EXISTS `tb_hero`;
CREATE TABLE `tb_hero` (
  `hero_id` int(11) NOT NULL,
  `hero_name` varchar(32) DEFAULT NULL,
  `skill` varchar(64) DEFAULT NULL,
  `book_id` int(11) DEFAULT NULL,
  PRIMARY KEY (`hero_id`),
  INDEX `idx_book_id_hero_name`(`book_id`, `hero_name`) USING BTREE
);

BEGIN;
INSERT INTO `tb_hero`(`hero_id`, `hero_name`, `skill`, `book_id`) VALUES (1, '李寻欢', '小李飞刀', 1);
INSERT INTO `tb_hero`(`hero_id`, `hero_name`, `skill`, `book_id`) VALUES (2, '令狐冲', '独孤九剑', 2);
INSERT INTO `tb_hero`(`hero_id`, `hero_name`, `skill`, `book_id`) VALUES (3, '张无忌', '九阳神功', 3);
INSERT INTO `tb_hero`(`hero_id`, `hero_name`, `skill`, `book_id`) VALUES (4, '郭靖', '降龙十八掌', 4);
INSERT INTO `tb_hero`(`hero_id`, `hero_name`, `skill`, `book_id`) VALUES (5, '花无缺', '移花接玉', 5);
INSERT INTO `tb_hero`(`hero_id`, `hero_name`, `skill`, `book_id`) VALUES (6, '任我行', '吸星大法', 2);
COMMIT;

-- ----------------------------
--  Table structure for `tb_book_hero`
-- ----------------------------
DROP TABLE IF EXISTS `tb_book_hero`;
CREATE TABLE `tb_book_hero` (
  `book_id` int(11) NOT NULL,
  `hero_id` int(11) NOT NULL,
  `user_comment` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`book_id`, `hero_id`) USING BTREE
) ENGINE = InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

BEGIN;
INSERT INTO `tb_book_hero`(`book_id`, `hero_id`, `user_comment`) VALUES (1, 1, '小李飞刀，例无虚发，夺魂索命，弹指之间');
INSERT INTO `tb_book_hero`(`book_id`, `hero_id`, `user_comment`) VALUES (2, 2, '令狐少侠留步!');
INSERT INTO `tb_book_hero`(`book_id`, `hero_id`, `user_comment`) VALUES (3, 3, '尝遍世间善恶，归来仍是少年');
INSERT INTO `tb_book_hero`(`book_id`, `hero_id`, `user_comment`) VALUES (4, 4, '我只要我的靖哥哥!');
INSERT INTO `tb_book_hero`(`book_id`, `hero_id`, `user_comment`) VALUES (5, 5, '风采儒雅亦坦荡，武艺精深兼明智。');
INSERT INTO `tb_book_hero`(`book_id`, `hero_id`, `user_comment`) VALUES (2, 6, '有人就有恩怨，有恩怨就有江湖，人心即是江湖，你如何退出！');
COMMIT;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;explain的输出结果&quot;&gt;explain的输出结果&lt;/h2&gt;
&lt;p&gt;相关文档：&lt;br/&gt;&lt;code&gt;https://dev.mysql.com/doc/refman/5.7/en/explain-output.html&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;看一下官方文档显示的关于explain输出结果列(&lt;code&gt;explain output columns&lt;/code&gt;)的含义：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Column&lt;/th&gt;
&lt;th&gt;JSON Name&lt;/th&gt;
&lt;th&gt;Meaning&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;7&quot;&gt;&lt;tr&gt;&lt;td&gt;id&lt;/td&gt;
&lt;td&gt;select_id&lt;/td&gt;
&lt;td&gt;The SELECT identifier&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;select_type&lt;/td&gt;
&lt;td&gt;None&lt;/td&gt;
&lt;td&gt;The SELECT type&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;table&lt;/td&gt;
&lt;td&gt;table_name&lt;/td&gt;
&lt;td&gt;The table for the output row&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;partitions&lt;/td&gt;
&lt;td&gt;partitions&lt;/td&gt;
&lt;td&gt;The matching partitions&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;type&lt;/td&gt;
&lt;td&gt;access_type&lt;/td&gt;
&lt;td&gt;The join type&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;possible_keys&lt;/td&gt;
&lt;td&gt;possible_keys&lt;/td&gt;
&lt;td&gt;The possible indexes to choose&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;key&lt;/td&gt;
&lt;td&gt;key&lt;/td&gt;
&lt;td&gt;The index actually chosen&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;key_len&lt;/td&gt;
&lt;td&gt;key_length&lt;/td&gt;
&lt;td&gt;The length of the chosen key&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;ref&lt;/td&gt;
&lt;td&gt;ref&lt;/td&gt;
&lt;td&gt;The columns compared to the index&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;rows&lt;/td&gt;
&lt;td&gt;rows&lt;/td&gt;
&lt;td&gt;Estimate of rows to be examined&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;filtered&lt;/td&gt;
&lt;td&gt;filtered&lt;/td&gt;
&lt;td&gt;Percentage of rows filtered by table condition&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Extra&lt;/td&gt;
&lt;td&gt;None&lt;/td&gt;
&lt;td&gt;Additional information&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;其中&lt;code&gt;JSON Name&lt;/code&gt;指的是当设定&lt;code&gt;FORMAT=JSON&lt;/code&gt;时，列名在json中显示的name，见下面的演示就明白了&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sh&quot;&gt;mysql&amp;gt; explain select * from tb_book \G
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: tb_book
   partitions: NULL
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 5
     filtered: 100.00
        Extra: NULL
1 row in set, 1 warning (0.00 sec)

mysql&amp;gt; explain FORMAT=JSON select * from tb_book \G
*************************** 1. row ***************************
EXPLAIN: {
  &quot;query_block&quot;: {
    &quot;select_id&quot;: 1,
    &quot;cost_info&quot;: {
      &quot;query_cost&quot;: &quot;2.00&quot;
    },
    &quot;table&quot;: {
      &quot;table_name&quot;: &quot;tb_book&quot;,
      &quot;access_type&quot;: &quot;ALL&quot;,
      &quot;rows_examined_per_scan&quot;: 5,
      &quot;rows_produced_per_join&quot;: 5,
      &quot;filtered&quot;: &quot;100.00&quot;,
      &quot;cost_info&quot;: {
        &quot;read_cost&quot;: &quot;1.00&quot;,
        &quot;eval_cost&quot;: &quot;1.00&quot;,
        &quot;prefix_cost&quot;: &quot;2.00&quot;,
        &quot;data_read_per_join&quot;: &quot;1K&quot;
      },
      &quot;used_columns&quot;: [
        &quot;book_id&quot;,
        &quot;book_name&quot;,
        &quot;author&quot;
      ]
    }
  }
}
1 row in set, 1 warning (0.00 sec)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面重点看一下比较重要的几个字段。&lt;/p&gt;
&lt;h3 id=&quot;id列&quot;&gt;id列&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;id&lt;/code&gt;是&lt;code&gt;select&lt;/code&gt;的唯一标识，有几个&lt;code&gt;select&lt;/code&gt;就有几个id，并且id的顺序是按&lt;code&gt;select&lt;/code&gt;出现的顺序增长的，id值越大执行优先级越高，id相同则从上往下执行，id为NULL最后执行。&lt;/p&gt;
&lt;p&gt;为了验证上面的结论，临时关闭mysql&lt;code&gt;5.7&lt;/code&gt;对子查询(&lt;code&gt;sub queries&lt;/code&gt;)产生的衍生表(&lt;code&gt;derived tables&lt;/code&gt;)的合并优化&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sh&quot;&gt;set session optimizer_switch='derived_merge=off';
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;详情见：&lt;br/&gt;&lt;code&gt;https://dev.mysql.com/doc/refman/5.7/en/switchable-optimizations.html&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;https://dev.mysql.com/doc/refman/5.7/en/derived-table-optimization.html&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sh&quot;&gt;mysql&amp;gt; set session optimizer_switch='derived_merge=off';
Query OK, 0 rows affected (0.00 sec)

mysql&amp;gt; select (select count(1) from tb_book) as book_count, (select count(1) from tb_hero) as hero_count from (select * from tb_book_hero) as book_hero;
+------------+------------+
| book_count | hero_count |
+------------+------------+
|          5 |          6 |
|          5 |          6 |
|          5 |          6 |
|          5 |          6 |
|          5 |          6 |
|          5 |          6 |
+------------+------------+
6 rows in set (0.00 sec)

mysql&amp;gt; explain select (select count(1) from tb_book) as book_count, (select count(1) from tb_hero) as hero_count from (select * from tb_book_hero) as book_hero;
+----+-------------+--------------+------------+-------+---------------+-----------------------+---------+------+------+----------+-------------+
| id | select_type | table        | partitions | type  | possible_keys | key                   | key_len | ref  | rows | filtered | Extra       |
+----+-------------+--------------+------------+-------+---------------+-----------------------+---------+------+------+----------+-------------+
|  1 | PRIMARY     | &amp;lt;derived4&amp;gt;   | NULL       | ALL   | NULL          | NULL                  | NULL    | NULL |    6 |   100.00 | NULL        |
|  4 | DERIVED     | tb_book_hero | NULL       | ALL   | NULL          | NULL                  | NULL    | NULL |    6 |   100.00 | NULL        |
|  3 | SUBQUERY    | tb_hero      | NULL       | index | NULL          | idx_book_id_hero_name | 136     | NULL |    6 |   100.00 | Using index |
|  2 | SUBQUERY    | tb_book      | NULL       | index | NULL          | uk_book_name          | 259     | NULL |    5 |   100.00 | Using index |
+----+-------------+--------------+------------+-------+---------------+-----------------------+---------+------+------+----------+-------------+
4 rows in set, 1 warning (0.00 sec)

mysql&amp;gt; set session optimizer_switch='derived_merge=on';
Query OK, 0 rows affected (0.00 sec)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可见，查询语句中有4个select，先执行的是&lt;code&gt;select * from tb_book_hero&lt;/code&gt;，然后执行&lt;code&gt;select count(1) from tb_hero&lt;/code&gt;，再执行&lt;code&gt;select count(1) from tb_book&lt;/code&gt;，最后执行&lt;code&gt;select book_count, hero_count from book_hero&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;select_type列&quot;&gt;select_type列&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;select_type&lt;/code&gt;表示的是查询类型，常见的包括&lt;code&gt;SIMPLE&lt;/code&gt;、&lt;code&gt;PRIMARY&lt;/code&gt;、&lt;code&gt;SUBQUERY&lt;/code&gt;、&lt;code&gt;DERIVED&lt;/code&gt;、&lt;code&gt;UNION&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;(1) SIMPLE：简单查询(不包含子查询和UNION查询)&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sh&quot;&gt;mysql&amp;gt; explain select * from tb_book where book_id = 1;
+----+-------------+---------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
| id | select_type | table   | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |
+----+-------------+---------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | tb_book | NULL       | const | PRIMARY       | PRIMARY | 4       | const |    1 |   100.00 | NULL  |
+----+-------------+---------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(2) PRIMARY：复杂查询中最外层的查询&lt;br/&gt;(3) SUBQUERY：包含在select中的子查询(不在from子句中)&lt;br/&gt;(4) DERIVED：包含在from子句中的子查询，MySQL会将结果存放在一个临时表中，也称为派生表(&lt;code&gt;derived tables&lt;/code&gt;)&lt;/p&gt;
&lt;p&gt;这3种select_type见下面的例子&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sh&quot;&gt;mysql&amp;gt; set session optimizer_switch='derived_merge=off';
Query OK, 0 rows affected (0.00 sec)

mysql&amp;gt; explain select (select count(1) from tb_book) as book_count from (select * from tb_book_hero) as book_hero;
+----+-------------+--------------+------------+-------+---------------+--------------+---------+------+------+----------+-------------+
| id | select_type | table        | partitions | type  | possible_keys | key          | key_len | ref  | rows | filtered | Extra       |
+----+-------------+--------------+------------+-------+---------------+--------------+---------+------+------+----------+-------------+
|  1 | PRIMARY     | &amp;lt;derived3&amp;gt;   | NULL       | ALL   | NULL          | NULL         | NULL    | NULL |    6 |   100.00 | NULL        |
|  3 | DERIVED     | tb_book_hero | NULL       | ALL   | NULL          | NULL         | NULL    | NULL |    6 |   100.00 | NULL        |
|  2 | SUBQUERY    | tb_book      | NULL       | index | NULL          | uk_book_name | 259     | NULL |    5 |   100.00 | Using index |
+----+-------------+--------------+------------+-------+---------------+--------------+---------+------+------+----------+-------------+
3 rows in set, 1 warning (0.00 sec)

mysql&amp;gt; set session optimizer_switch='derived_merge=on';
Query OK, 0 rows affected (0.00 sec)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(5) UNION：在UNION中的第二个和随后的select&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sh&quot;&gt;mysql&amp;gt; select * from tb_book where book_id = 1 union all select * from tb_book where book_name = '笑傲江湖';
+---------+-----------------------+--------+
| book_id | book_name             | author |
+---------+-----------------------+--------+
|       1 | 多情剑客无情剑        | 古龙   |
|       2 | 笑傲江湖              | 金庸   |
+---------+-----------------------+--------+
2 rows in set (0.00 sec)

mysql&amp;gt; explain select * from tb_book where book_id = 1 union all select * from tb_book where book_name = '笑傲江湖';
+----+-------------+---------+------------+-------+---------------+--------------+---------+-------+------+----------+-------+
| id | select_type | table   | partitions | type  | possible_keys | key          | key_len | ref   | rows | filtered | Extra |
+----+-------------+---------+------------+-------+---------------+--------------+---------+-------+------+----------+-------+
|  1 | PRIMARY     | tb_book | NULL       | const | PRIMARY       | PRIMARY      | 4       | const |    1 |   100.00 | NULL  |
|  2 | UNION       | tb_book | NULL       | const | uk_book_name  | uk_book_name | 259     | const |    1 |   100.00 | NULL  |
+----+-------------+---------+------------+-------+---------------+--------------+---------+-------+------+----------+-------+
2 rows in set, 1 warning (0.00 sec)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;table列&quot;&gt;table列&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;table&lt;/code&gt;表示查询涉及的表或衍生表。&lt;/p&gt;
&lt;p&gt;常见table列是&lt;code&gt;&amp;lt;derivenN&amp;gt;&lt;/code&gt;格式，表示当前查询依赖&lt;code&gt;id=N&lt;/code&gt;的查询，需先执行&lt;code&gt;id=N&lt;/code&gt;的查询。上面含&lt;code&gt;select_type&lt;/code&gt;为&lt;code&gt;DERIVED&lt;/code&gt;的查询就是这种情况，这里不再重复举例。&lt;/p&gt;
&lt;h3 id=&quot;type列&quot;&gt;type列&lt;/h3&gt;
&lt;p&gt;相关文档：&lt;br/&gt;&lt;code&gt;https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain-join-types&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;type列是判断查询是否高效的重要依据，我们可以通过type字段的值，判断此次查询是&lt;code&gt;全表扫描&lt;/code&gt;还是&lt;code&gt;索引扫描&lt;/code&gt;等，进而进一步优化查询。&lt;/p&gt;
&lt;p&gt;一般来说表示查询性能最优到最差依次为：&lt;code&gt;NULL &amp;gt; system &amp;gt; const &amp;gt; eq_ref &amp;gt; ref &amp;gt; range &amp;gt; index &amp;gt; ALL&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;前面的几种类型都是利用到了索引来查询数据, 因此可以过滤部分或大部分数据, 查询效率自然就比较高了。&lt;br/&gt;而后面的&lt;code&gt;index&lt;/code&gt;类型的查询虽然不是全表扫描, 但是它扫描了所有的索引, 因此比&lt;code&gt;ALL&lt;/code&gt;类型稍快。&lt;br/&gt;所以，应当尽可能地保证查询达到&lt;code&gt;range&lt;/code&gt;级别，最好达到&lt;code&gt;ref&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;(0) NULL: 不用访问表或者索引，直接就能得到结果，如：在索引列中选取最大值，执行时不需要再访问表&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sh&quot;&gt;mysql&amp;gt; explain select max(book_id) from tb_book;
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                        |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------------------+
|  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL |     NULL | Select tables optimized away |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------------------+
1 row in set, 1 warning (0.00 sec)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(1) system：The table has only one row. This is a special case of the &lt;code&gt;const&lt;/code&gt; join type.&lt;/p&gt;
&lt;p&gt;当查询的表只有一行的情况下，&lt;code&gt;system&lt;/code&gt;是&lt;code&gt;const&lt;/code&gt;类型的特例，&lt;/p&gt;
&lt;p&gt;(2) const：It is used when you compare all parts of a &lt;code&gt;PRIMARY KEY&lt;/code&gt; or &lt;code&gt;UNIQUE index&lt;/code&gt; to &lt;code&gt;constant values&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;针对&lt;code&gt;主键&lt;/code&gt;或&lt;code&gt;唯一索引&lt;/code&gt;的等值查询扫描, 最多只返回一行数据。&lt;code&gt;const&lt;/code&gt;查询速度非常快, 因为它仅仅读取一次即可。&lt;/p&gt;
&lt;p&gt;关于type列为&lt;code&gt;system&lt;/code&gt;、&lt;code&gt;const&lt;/code&gt;的情况，见下面的示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sh&quot;&gt;mysql&amp;gt; set session optimizer_switch='derived_merge=off';
Query OK, 0 rows affected (0.00 sec)

mysql&amp;gt; explain select * from (select * from tb_book where book_id = 5) as book;
+----+-------------+------------+------------+--------+---------------+---------+---------+-------+------+----------+-------+
| id | select_type | table      | partitions | type   | possible_keys | key     | key_len | ref   | rows | filtered | Extra |
+----+-------------+------------+------------+--------+---------------+---------+---------+-------+------+----------+-------+
|  1 | PRIMARY     | &amp;lt;derived2&amp;gt; | NULL       | system | NULL          | NULL    | NULL    | NULL  |    1 |   100.00 | NULL  |
|  2 | DERIVED     | tb_book    | NULL       | const  | PRIMARY       | PRIMARY | 4       | const |    1 |   100.00 | NULL  |
+----+-------------+------------+------------+--------+---------------+---------+---------+-------+------+----------+-------+
2 rows in set, 1 warning (0.00 sec)

mysql&amp;gt; set session optimizer_switch='derived_merge=on';
Query OK, 0 rows affected (0.00 sec)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(3) eq_ref：It is used when all parts of an index are used by the join and the index is a &lt;code&gt;PRIMARY KEY&lt;/code&gt; or &lt;code&gt;UNIQUE NOT NULL index&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;此类型通常出现在多表的join查询，表示对于前表的每一个结果，都只能匹配到后表的一行结果，并且查询的比较操作通常是&lt;code&gt;=&lt;/code&gt;，查询效率较高。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sh&quot;&gt;mysql&amp;gt; select tb_hero.*, tb_book_hero.user_comment from tb_book_hero, tb_hero where tb_book_hero.book_id = 2 and tb_book_hero.hero_id = tb_hero.hero_id;
+---------+-----------+--------------+---------+--------------------------------------------------------------------------------------+
| hero_id | hero_name | skill        | book_id | user_comment                                                                         |
+---------+-----------+--------------+---------+--------------------------------------------------------------------------------------+
|       2 | 令狐冲    | 独孤九剑     |       2 | 令狐少侠留步!                                                                        |
|       6 | 任我行    | 吸星大法     |       2 | 有人就有恩怨，有恩怨就有江湖，人心即是江湖，你如何退出！                             |
+---------+-----------+--------------+---------+--------------------------------------------------------------------------------------+
2 rows in set (0.00 sec)

mysql&amp;gt; explain select tb_hero.*, tb_book_hero.user_comment from tb_book_hero, tb_hero where tb_book_hero.book_id = 2 and tb_book_hero.hero_id = tb_hero.hero_id;
+----+-------------+--------------+------------+--------+---------------+---------+---------+-----------------------------------+------+----------+-------+
| id | select_type | table        | partitions | type   | possible_keys | key     | key_len | ref                               | rows | filtered | Extra |
+----+-------------+--------------+------------+--------+---------------+---------+---------+-----------------------------------+------+----------+-------+
|  1 | SIMPLE      | tb_book_hero | NULL       | ref    | PRIMARY       | PRIMARY | 4       | const                             |    2 |   100.00 | NULL  |
|  1 | SIMPLE      | tb_hero      | NULL       | eq_ref | PRIMARY       | PRIMARY | 4       | explain_test.tb_book_hero.hero_id |    1 |   100.00 | NULL  |
+----+-------------+--------------+------------+--------+---------------+---------+---------+-----------------------------------+------+----------+-------+
2 rows in set, 1 warning (0.00 sec)

mysql&amp;gt; select tb_hero.*, tb_book_hero.user_comment from tb_book_hero join tb_hero on tb_book_hero.book_id = 2 and tb_book_hero.hero_id = tb_hero.hero_id;
+---------+-----------+--------------+---------+--------------------------------------------------------------------------------------+
| hero_id | hero_name | skill        | book_id | user_comment                                                                         |
+---------+-----------+--------------+---------+--------------------------------------------------------------------------------------+
|       2 | 令狐冲    | 独孤九剑     |       2 | 令狐少侠留步!                                                                        |
|       6 | 任我行    | 吸星大法     |       2 | 有人就有恩怨，有恩怨就有江湖，人心即是江湖，你如何退出！                             |
+---------+-----------+--------------+---------+--------------------------------------------------------------------------------------+
2 rows in set (0.00 sec)

mysql&amp;gt; explain select tb_hero.*, tb_book_hero.user_comment from tb_book_hero join tb_hero on tb_book_hero.book_id = 2 and tb_book_hero.hero_id = tb_hero.hero_id;
+----+-------------+--------------+------------+--------+---------------+---------+---------+-----------------------------------+------+----------+-------+
| id | select_type | table        | partitions | type   | possible_keys | key     | key_len | ref                               | rows | filtered | Extra |
+----+-------------+--------------+------------+--------+---------------+---------+---------+-----------------------------------+------+----------+-------+
|  1 | SIMPLE      | tb_book_hero | NULL       | ref    | PRIMARY       | PRIMARY | 4       | const                             |    2 |   100.00 | NULL  |
|  1 | SIMPLE      | tb_hero      | NULL       | eq_ref | PRIMARY       | PRIMARY | 4       | explain_test.tb_book_hero.hero_id |    1 |   100.00 | NULL  |
+----+-------------+--------------+------------+--------+---------------+---------+---------+-----------------------------------+------+----------+-------+
2 rows in set, 1 warning (0.00 sec)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(4) ref: It is used if the join uses only a leftmost prefix of the key or if the key is not a PRIMARY KEY or UNIQUE index (in other words, if the join cannot select a single row based on the key value).&lt;/p&gt;
&lt;p&gt;相比&lt;code&gt;eq_ref&lt;/code&gt;，不使用唯一索引，而是使用普通索引或者唯一性索引的最左前缀，可能会找到多个符合条件的行。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;简单的&lt;code&gt;select&lt;/code&gt;查询，&lt;code&gt;author&lt;/code&gt;列上建有普通索引（非唯一索引）&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-sh&quot;&gt;mysql&amp;gt; explain select * from tb_book where author = '古龙';
+----+-------------+---------+------------+------+---------------+------------+---------+-------+------+----------+-------+
| id | select_type | table   | partitions | type | possible_keys | key        | key_len | ref   | rows | filtered | Extra |
+----+-------------+---------+------------+------+---------------+------------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | tb_book | NULL       | ref  | idx_author    | idx_author | 131     | const |    2 |   100.00 | NULL  |
+----+-------------+---------+------------+------+---------------+------------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;关联表查询，&lt;code&gt;tb_book_hero&lt;/code&gt;表使用了联合主键&lt;code&gt;PRIMARY KEY (book_id, hero_id)&lt;/code&gt;，这里使用到了左边前缀&lt;code&gt;book_id&lt;/code&gt;进行过滤。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-sh&quot;&gt;mysql&amp;gt; explain select * from tb_book_hero where book_id = 3;
+----+-------------+--------------+------------+------+---------------+---------+---------+-------+------+----------+-------+
| id | select_type | table        | partitions | type | possible_keys | key     | key_len | ref   | rows | filtered | Extra |
+----+-------------+--------------+------------+------+---------------+---------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | tb_book_hero | NULL       | ref  | PRIMARY       | PRIMARY | 4       | const |    1 |   100.00 | NULL  |
+----+-------------+--------------+------------+------+---------------+---------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(5) range: It can be used when a key column is compared to a constant using any of the =, &amp;lt;&amp;gt;, &amp;gt;, &amp;gt;=, &amp;lt;, &amp;lt;=, IS NULL, &amp;lt;=&amp;gt;, BETWEEN, LIKE, or IN() operators&lt;br/&gt;扫描部分索引(范围扫描)，对索引的扫描开始于某一点，返回匹配值域的行，常见于between、&amp;lt;、&amp;gt;、in等查询&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sh&quot;&gt;mysql&amp;gt; explain select * from tb_book where book_id &amp;gt; 3;
+----+-------------+---------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
| id | select_type | table   | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |
+----+-------------+---------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | tb_book | NULL       | range | PRIMARY       | PRIMARY | 4       | NULL |    2 |   100.00 | Using where |
+----+-------------+---------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(6) index：the index tree is scanned, MySQL can use this type when the query uses only columns that are part of a single index.&lt;br/&gt;表示全索引扫描(full index scan), 和ALL类型类似, 只不过ALL类型是全表扫描, 而index类型则仅仅扫描所有的索引, 而不扫描数据.&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sh&quot;&gt;mysql&amp;gt; explain select book_name from tb_book;
+----+-------------+---------+------------+-------+---------------+--------------+---------+------+------+----------+-------------+
| id | select_type | table   | partitions | type  | possible_keys | key          | key_len | ref  | rows | filtered | Extra       |
+----+-------------+---------+------------+-------+---------------+--------------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | tb_book | NULL       | index | NULL          | uk_book_name | 259     | NULL |    5 |   100.00 | Using index |
+----+-------------+---------+------------+-------+---------------+--------------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的例子中, 我们查询的&lt;code&gt;book_name&lt;/code&gt;字段上恰好有索引, 因此我们直接从索引中获取数据就可以满足查询的需求了, 而不需要查询表中的数据。因此这样的情况下, type的值是index, 并且Extra的值大多是&lt;code&gt;Using index&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;(7) ALL: A full table scan is done&lt;br/&gt;表示全表扫描, 这个类型的查询是性能最差的查询之一。通常来说, 我们的查询不应该出现ALL类型的查询, 因为这样的查询在数据量大的情况下, 严重降低数据库的性能。如果一个查询是ALL类型查询, 那么大多可以对相应的字段添加索引来避免。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sh&quot;&gt;mysql&amp;gt; explain select * from tb_hero where hero_name = '令狐冲';
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | tb_hero | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    6 |    16.67 | Using where |
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;possible_keys列&quot;&gt;possible_keys列&lt;/h3&gt;
&lt;p&gt;表示MySQL在查询时, 能够使用到的索引。注意, 即使有些索引在possible_keys中出现, 但是并不表示此索引会真正地被MySQL使用到。MySQL在查询时具体使用了哪些索引, 由key字段决定。&lt;/p&gt;
&lt;h3 id=&quot;key列&quot;&gt;key列&lt;/h3&gt;
&lt;p&gt;这一列显示mysql实际采用哪个索引来优化对该表的访问。如果没有使用索引，则该列是NULL。&lt;/p&gt;
&lt;h3 id=&quot;key_len列&quot;&gt;key_len列&lt;/h3&gt;
&lt;p&gt;表示查询优化器使用了索引的字节数，这个字段可以评估联合索引是否完全被使用, 或只有最左部分字段被使用到。&lt;br/&gt;举例来说，&lt;code&gt;tb_hero&lt;/code&gt;表的联合索引&lt;code&gt;idx_book_id_hero_name&lt;/code&gt;由&lt;code&gt;book_id&lt;/code&gt;和&lt;code&gt;hero_name&lt;/code&gt;两个列组成，int类型占4字节，另外如果字段允许为NULL，需要1字节记录是否为NULL，通过结果中的key_len=5(&lt;code&gt;tb_hero&lt;/code&gt;.&lt;code&gt;book_id&lt;/code&gt;允许为NULL)可推断出查询使用了第一个列&lt;code&gt;book_id&lt;/code&gt;列来执行索引查找；再拿&lt;code&gt;tb_book_hero&lt;/code&gt;表联合主键&lt;code&gt;PRIMARY KEY (book_id, hero_id)&lt;/code&gt;举例，通过key_len=4(&lt;code&gt;tb_book_hero&lt;/code&gt;.&lt;code&gt;book_id&lt;/code&gt;不允许为NULL)可推断出查询使用了第一个列&lt;code&gt;book_id&lt;/code&gt;列来执行索引查找&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sh&quot;&gt;mysql&amp;gt; explain select * from tb_hero where book_id = 2;
+----+-------------+---------+------------+------+-----------------------+-----------------------+---------+-------+------+----------+-------+
| id | select_type | table   | partitions | type | possible_keys         | key                   | key_len | ref   | rows | filtered | Extra |
+----+-------------+---------+------------+------+-----------------------+-----------------------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | tb_hero | NULL       | ref  | idx_book_id_hero_name | idx_book_id_hero_name | 5       | const |    2 |   100.00 | NULL  |
+----+-------------+---------+------------+------+-----------------------+-----------------------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)

mysql&amp;gt; explain select * from tb_book_hero where book_id = 2;
+----+-------------+--------------+------------+------+---------------+---------+---------+-------+------+----------+-------+
| id | select_type | table        | partitions | type | possible_keys | key     | key_len | ref   | rows | filtered | Extra |
+----+-------------+--------------+------------+------+---------------+---------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | tb_book_hero | NULL       | ref  | PRIMARY       | PRIMARY | 4       | const |    2 |   100.00 | NULL  |
+----+-------------+--------------+------------+------+---------------+---------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.01 sec)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;key_len&lt;/code&gt;的计算规则如下:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;字符串:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;char(n): n字节长度&lt;/li&gt;
&lt;li&gt;varchar(n): 如果是&lt;code&gt;utf8&lt;/code&gt;编码, 则是&lt;code&gt;3n + 2&lt;/code&gt;字节; 如果是&lt;code&gt;utf8mb4&lt;/code&gt;编码, 则是&lt;code&gt;4n + 2&lt;/code&gt;字节.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数值类型:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;TINYINT: 1字节&lt;/li&gt;
&lt;li&gt;SMALLINT: 2字节&lt;/li&gt;
&lt;li&gt;MEDIUMINT: 3字节&lt;/li&gt;
&lt;li&gt;INT: 4字节&lt;/li&gt;
&lt;li&gt;BIGINT: 8字节&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时间类型&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;DATE: 3字节&lt;/li&gt;
&lt;li&gt;TIMESTAMP: 4字节&lt;/li&gt;
&lt;li&gt;DATETIME: 8字节&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;字段属性:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;NULL属性占用一个字节&lt;/li&gt;
&lt;li&gt;如果一个字段是NOT NULL的, 则没有此属性&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;再看下面的计算:&lt;br/&gt;&lt;code&gt;4 [book_id是int类型] + 1 [book_id允许为NULL] + (4 * 32 + 2) [hero_name是varchar32,且用的是utf8mb4编码] + 1 [hero_name允许为NULL] = 136&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sh&quot;&gt;mysql&amp;gt; explain select * from tb_hero where book_id = 2 and hero_name = '令狐冲';
+----+-------------+---------+------------+------+-----------------------+-----------------------+---------+-------------+------+----------+-------+
| id | select_type | table   | partitions | type | possible_keys         | key                   | key_len | ref         | rows | filtered | Extra |
+----+-------------+---------+------------+------+-----------------------+-----------------------+---------+-------------+------+----------+-------+
|  1 | SIMPLE      | tb_hero | NULL       | ref  | idx_book_id_hero_name | idx_book_id_hero_name | 136     | const,const |    1 |   100.00 | NULL  |
+----+-------------+---------+------------+------+-----------------------+-----------------------+---------+-------------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;ref列&quot;&gt;ref列&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;The ref column shows which columns or constants are compared to the index named in the key column to select rows from the table.&lt;br/&gt;显示的是哪个字段或常数与key一起被使用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;rows列&quot;&gt;rows列&lt;/h3&gt;
&lt;p&gt;MySQL查询优化器根据统计信息, 估算SQL要查找到结果集需要扫描读取的数据行数，注意这个不是结果集里的行数。这个值非常直观显示SQL的效率好坏, 原则上rows越少越好。&lt;/p&gt;

&lt;p&gt;这一列展示的是额外信息。常见的重要值如下:&lt;/p&gt;
&lt;p&gt;(1) Using index&lt;/p&gt;
&lt;p&gt;表示查询在索引树中就可查找所需数据, 不用扫描表数据文件, 往往说明性能不错&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sh&quot;&gt;mysql&amp;gt; explain select hero_id from tb_book_hero where book_id = 2;
+----+-------------+--------------+------------+------+---------------+---------+---------+-------+------+----------+-------------+
| id | select_type | table        | partitions | type | possible_keys | key     | key_len | ref   | rows | filtered | Extra       |
+----+-------------+--------------+------------+------+---------------+---------+---------+-------+------+----------+-------------+
|  1 | SIMPLE      | tb_book_hero | NULL       | ref  | PRIMARY       | PRIMARY | 4       | const |    2 |   100.00 | Using index |
+----+-------------+--------------+------------+------+---------------+---------+---------+-------+------+----------+-------------+
1 row in set, 1 warning (0.01 sec)

mysql&amp;gt; explain select book_id  from tb_book where author = '金庸';
+----+-------------+---------+------------+------+---------------+------------+---------+-------+------+----------+-------------+
| id | select_type | table   | partitions | type | possible_keys | key        | key_len | ref   | rows | filtered | Extra       |
+----+-------------+---------+------------+------+---------------+------------+---------+-------+------+----------+-------------+
|  1 | SIMPLE      | tb_book | NULL       | ref  | idx_author    | idx_author | 131     | const |    3 |   100.00 | Using index |
+----+-------------+---------+------------+------+---------------+------------+---------+-------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(2) Using where&lt;br/&gt;查询的列没有全部被索引覆盖&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sh&quot;&gt;mysql&amp;gt; explain select book_id, book_name from tb_book where author = '金庸';
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | tb_book | NULL       | ALL  | idx_author    | NULL | NULL    | NULL |    5 |    60.00 | Using where |
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(3) Using temporary&lt;/p&gt;
&lt;p&gt;查询有使用临时表，一般出现于排序、分组、多表join、distinct查询等等。&lt;/p&gt;
&lt;p&gt;举例子如下：&lt;code&gt;tb_book&lt;/code&gt;表对&lt;code&gt;book_name&lt;/code&gt;字段建立了唯一性索引，这时候distinct查询Extra列为&lt;code&gt;Using index&lt;/code&gt;; &lt;code&gt;tb_hero&lt;/code&gt;表的&lt;code&gt;skill&lt;/code&gt;字段上没有任何索引，这时候distinct查询Extra列为&lt;code&gt;Using temporary&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sh&quot;&gt;mysql&amp;gt; select distinct book_name from tb_book;
+-----------------------+
| book_name             |
+-----------------------+
| 倚天屠龙记            |
| 多情剑客无情剑        |
| 射雕英雄传            |
| 笑傲江湖              |
| 绝代双骄              |
+-----------------------+
5 rows in set (0.00 sec)

mysql&amp;gt; explain select distinct book_name from tb_book;
+----+-------------+---------+------------+-------+---------------+--------------+---------+------+------+----------+-------------+
| id | select_type | table   | partitions | type  | possible_keys | key          | key_len | ref  | rows | filtered | Extra       |
+----+-------------+---------+------------+-------+---------------+--------------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | tb_book | NULL       | index | uk_book_name  | uk_book_name | 259     | NULL |    5 |   100.00 | Using index |
+----+-------------+---------+------------+-------+---------------+--------------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)

mysql&amp;gt; select distinct skill from tb_hero;
+-----------------+
| skill           |
+-----------------+
| 小李飞刀        |
| 独孤九剑        |
| 九阳神功        |
| 降龙十八掌      |
| 移花接玉        |
| 吸星大法        |
+-----------------+
6 rows in set (0.00 sec)

mysql&amp;gt; explain select distinct skill from tb_hero;
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-----------------+
| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra           |
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-----------------+
|  1 | SIMPLE      | tb_hero | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    6 |   100.00 | Using temporary |
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-----------------+
1 row in set, 1 warning (0.00 sec)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(4) Using filesort&lt;/p&gt;
&lt;p&gt;表示MySQL不能通过索引顺序达到排序效果，需额外的排序操作，数据较小时在内存排序，否则需要在磁盘完成排序。这种情况下一般也是要考虑使用索引来优化的。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sh&quot;&gt;mysql&amp;gt; explain select book_id, hero_name from tb_hero order by hero_name;
+----+-------------+---------+------------+-------+---------------+-----------------------+---------+------+------+----------+-----------------------------+
| id | select_type | table   | partitions | type  | possible_keys | key                   | key_len | ref  | rows | filtered | Extra                       |
+----+-------------+---------+------------+-------+---------------+-----------------------+---------+------+------+----------+-----------------------------+
|  1 | SIMPLE      | tb_hero | NULL       | index | NULL          | idx_book_id_hero_name | 136     | NULL |    6 |   100.00 | Using index; Using filesort |
+----+-------------+---------+------------+-------+---------------+-----------------------+---------+------+------+----------+-----------------------------+
1 row in set, 1 warning (0.00 sec)

mysql&amp;gt; explain select book_id, hero_name from tb_hero order by book_id, hero_name;
+----+-------------+---------+------------+-------+---------------+-----------------------+---------+------+------+----------+-------------+
| id | select_type | table   | partitions | type  | possible_keys | key                   | key_len | ref  | rows | filtered | Extra       |
+----+-------------+---------+------------+-------+---------------+-----------------------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | tb_hero | NULL       | index | NULL          | idx_book_id_hero_name | 136     | NULL |    6 |   100.00 | Using index |
+----+-------------+---------+------------+-------+---------------+-----------------------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;tb_hero&lt;/code&gt;表上有联合索引&lt;code&gt;INDEX idx_book_id_hero_name(book_id, hero_name) USING BTREE&lt;/code&gt;&lt;br/&gt;但是&lt;code&gt;order by hero_name&lt;/code&gt;, 不能使用索引进行优化(下一篇博客会介绍联合索引的结构), 进而会产生&lt;code&gt;Using filesort&lt;/code&gt;&lt;br/&gt;如果将排序依据改为&lt;code&gt;order by book_id, hero_name&lt;/code&gt;, 就不会出现&lt;code&gt;Using filesort&lt;/code&gt;了。&lt;/p&gt;
&lt;p&gt;(5) Select tables optimized away&lt;br/&gt;比如下面的例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sh&quot;&gt;mysql&amp;gt; explain select min(book_id), max(book_id) from tb_book;
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                        |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------------------+
|  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL |     NULL | Select tables optimized away |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------------------+
1 row in set, 1 warning (0.00 sec)
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 03 Aug 2020 00:05:00 +0000</pubDate>
<dc:creator>行无际</dc:creator>
<og:description>开篇说明 (1) 本文将细致介绍MySQL的explain工具，是下一篇《一文读懂MySQL的索引机制及查询优化》的准备篇。 (2) 本文主要基于MySQL5.7版本(https://dev.mysq</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/itwild/p/13424113.html</dc:identifier>
</item>
</channel>
</rss>