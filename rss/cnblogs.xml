<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>AntD使用timePiacker封装时间范围选择器（React hook版） - 庞永胜</title>
<link>http://www.cnblogs.com/pangys/p/11154124.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pangys/p/11154124.html</guid>
<description>import React, { forwardRef } &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;hljs-string&quot;&gt;'react'&lt;/span&gt;;&lt;br/&gt;import { Row, Col, TimePicker } &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;'antd'&lt;/span&gt;;&lt;br/&gt;import moment &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;'moment'&lt;/span&gt;;&lt;br/&gt;import { TimePickerProps } &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;'antd/es/time-picker'&lt;/span&gt;;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;IProps&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;TimePickerProps&lt;/span&gt; {&lt;br/&gt;prefixCls?: &lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;value&lt;/span&gt;?: any;&lt;br/&gt;onChange?: any;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; TimePickerRange: React.FC&amp;lt;IProps&amp;gt; = (props, &lt;span class=&quot;hljs-keyword&quot;&gt;ref&lt;/span&gt;) =&amp;gt; {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; {&lt;br/&gt;prefixCls,&lt;br/&gt;className,&lt;br/&gt;style,&lt;br/&gt;onChange,&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;value&lt;/span&gt;,&lt;br/&gt;disabled,&lt;br/&gt;...rest&lt;br/&gt;} = props;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; [startTime, setStartTime] = React.useState(&lt;span class=&quot;hljs-keyword&quot;&gt;value&lt;/span&gt;.start || moment());&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; [endTime, setEndTime] = React.useState(&lt;span class=&quot;hljs-keyword&quot;&gt;value&lt;/span&gt;.end || moment());&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; Hours = Array.&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt;(Array(&lt;span class=&quot;hljs-number&quot;&gt;24&lt;/span&gt;), (v, k) =&amp;gt; k);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; Minutes = Array.&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt;(Array(&lt;span class=&quot;hljs-number&quot;&gt;60&lt;/span&gt;), (v, k) =&amp;gt; k);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; Seconds = Array.&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt;(Array(&lt;span class=&quot;hljs-number&quot;&gt;60&lt;/span&gt;), (v, k) =&amp;gt; k);&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; triggerChange = changedValue =&amp;gt; {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (onChange) {&lt;br/&gt;onChange(&lt;br/&gt;Object.assign({}, { start: startTime, end: endTime }, changedValue)&lt;br/&gt;);&lt;br/&gt;}&lt;br/&gt;};&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; disEndHouse = () =&amp;gt; {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (startTime) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; h = startTime.hour();&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; Hours.slice(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, h);&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; [];&lt;br/&gt;};&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; disEndMinute = h =&amp;gt; {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (startTime) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (h &amp;gt; startTime.hour()) &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; [];&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; m = startTime.minute();&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; Minutes.slice(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, m);&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; [];&lt;br/&gt;};&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; disEndSeconds = (h, m) =&amp;gt; {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (startTime) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (h &amp;gt; startTime.hour()) &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; [];&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (m &amp;gt; startTime.minute()) &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; [];&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; s = startTime.second();&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; Seconds.slice(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, s);&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; [];&lt;br/&gt;};&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; disStartHouse = () =&amp;gt; {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (endTime) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; h = endTime.hour();&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; Hours.slice(h, Hours.length - &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; [];&lt;br/&gt;};&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; disStartMinute = h =&amp;gt; {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (endTime) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (h &amp;lt; endTime.hour()) &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; [];&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; m = endTime.minute();&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; Minutes.slice(m, Minutes.length - &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; [];&lt;br/&gt;};&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; disStartSeconds = (h, m) =&amp;gt; {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (endTime) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (h &amp;lt; endTime.hour()) &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; [];&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (m &amp;lt; endTime.minute()) &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; [];&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; s = endTime.second();&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; Seconds.slice(s, Seconds.length - &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; [];&lt;br/&gt;};&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; (&lt;br/&gt;&amp;lt;Row &lt;span class=&quot;hljs-keyword&quot;&gt;ref&lt;/span&gt;={&lt;span class=&quot;hljs-keyword&quot;&gt;ref&lt;/span&gt;}&amp;gt;&lt;br/&gt;&amp;lt;Col span={&lt;span class=&quot;hljs-number&quot;&gt;12&lt;/span&gt;}&amp;gt;&lt;br/&gt;&amp;lt;TimePicker&lt;br/&gt;allowClear={&lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;}&lt;br/&gt;disabled={disabled}&lt;br/&gt;onChange={&lt;span class=&quot;hljs-keyword&quot;&gt;value&lt;/span&gt; =&amp;gt; {&lt;br/&gt;setStartTime(&lt;span class=&quot;hljs-keyword&quot;&gt;value&lt;/span&gt;);&lt;br/&gt;triggerChange({ start: &lt;span class=&quot;hljs-keyword&quot;&gt;value&lt;/span&gt; });&lt;br/&gt;}}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;value&lt;/span&gt;={&lt;span class=&quot;hljs-keyword&quot;&gt;value&lt;/span&gt;.start || moment(&lt;span class=&quot;hljs-string&quot;&gt;'00:00:00'&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;'HH:mm:ss'&lt;/span&gt;)}&lt;br/&gt;disabledHours={disStartHouse}&lt;br/&gt;disabledMinutes={disStartMinute}&lt;br/&gt;disabledSeconds={disStartSeconds}&lt;br/&gt;/&amp;gt;&lt;br/&gt;&amp;lt;/Col&amp;gt;&lt;br/&gt;&amp;lt;Col span={&lt;span class=&quot;hljs-number&quot;&gt;12&lt;/span&gt;}&amp;gt;&lt;br/&gt;&amp;lt;TimePicker&lt;br/&gt;allowClear={&lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;}&lt;br/&gt;disabled={disabled}&lt;br/&gt;onChange={&lt;span class=&quot;hljs-keyword&quot;&gt;value&lt;/span&gt; =&amp;gt; {&lt;br/&gt;setEndTime(&lt;span class=&quot;hljs-keyword&quot;&gt;value&lt;/span&gt;);&lt;br/&gt;triggerChange({ end: &lt;span class=&quot;hljs-keyword&quot;&gt;value&lt;/span&gt; });&lt;br/&gt;}}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;value&lt;/span&gt;={&lt;span class=&quot;hljs-keyword&quot;&gt;value&lt;/span&gt;.end || moment(&lt;span class=&quot;hljs-string&quot;&gt;'23:59:59'&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;'HH:mm:ss'&lt;/span&gt;)}&lt;br/&gt;disabledHours={disEndHouse}&lt;br/&gt;disabledMinutes={disEndMinute}&lt;br/&gt;disabledSeconds={disEndSeconds}&lt;br/&gt;/&amp;gt;&lt;br/&gt;&amp;lt;/Col&amp;gt;&lt;br/&gt;&amp;lt;/Row&amp;gt;&lt;br/&gt;);&lt;br/&gt;};&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;export &lt;span class=&quot;hljs-keyword&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;forwardRef&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;TimePickerRange&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;&lt;/p&gt;</description>
<pubDate>Tue, 09 Jul 2019 00:28:00 +0000</pubDate>
<dc:creator>庞永胜</dc:creator>
<og:description>antD中提供了是日期范围选择器及datepaicker封装日期范围选择器的示例，但是没有时间选择范围的组件，这里使用两个timePicker组合一个事件范围选择器，通过disabled属性限定时间可</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/pangys/p/11154124.html</dc:identifier>
</item>
<item>
<title>SQL Server温故系列(4)：SQL 查询之集合运算 &amp; 聚合函数 - 韩宗泽</title>
<link>http://www.cnblogs.com/hanzongze/p/tsql-aggregate.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hanzongze/p/tsql-aggregate.html</guid>
<description>&lt;h2 id=&quot;1&quot;&gt;1、集合运算&lt;/h2&gt;
&lt;p&gt;在数学中，不仅可以对指定的数字个体做四则运算，还可以对指定的集合整体做交并补运算。类似的，在数据库中也是不仅可以对具体的数据行进行增删改查，还可以对查询结果集进行集合运算。SQL Server 中的集合运算有并集运算、差集运算和交集运算三种，本节将逐一讲述。&lt;/p&gt;
&lt;h4 id=&quot;11&quot;&gt;1.1、并集运算 UNION&lt;/h4&gt;
&lt;p&gt;并集运算符 UNION 的作用是将两个或多个查询的结果集合并为单个结果集。在 UNION 运算中，需要确保各个子结果集的字段数相同、字段的顺序相同、字段的数据类型兼容。合并结果集的列名始终会取第一个子结果集中的列名，因此，如果要对合并结果集排序，则需要用第一个子结果集的字段名。&lt;/p&gt;
&lt;p&gt;参数 ALL 表示将全部行并入结果集中，换句话说合并结果集可能会包含重复行；相反，如果未指定该参数，则会删除重复行。需要注意的是，在做重复判断时，UNION 会把两个 NULL 值被视为相等的。因为 UNION ALL 不需要删除重复行，所以性能比 UNION 要好。因此，除非必须要删除重复行，否则建议一律使用 UNION ALL。&lt;/p&gt;
&lt;p&gt;1.1.1、&lt;strong&gt;简单 UNION ALL&lt;/strong&gt;。查询 1 班的男生和 2 班的女生。示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SELECT * FROM T_Students t1 WHERE t1.ClassId = 1 AND t1.Gender = 1
UNION ALL
SELECT * FROM T_Students t2 WHERE t2.ClassId = 2 AND t2.Gender = 0;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;1.1.2、&lt;strong&gt;简单 UNION ALL&lt;/strong&gt;。查询 1 班的男生和该班的男生人数。示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SELECT 1 cnt,t1.Code,t1.Name FROM T_Students t1 WHERE t1.ClassId = 1 AND t1.Gender = 1
UNION ALL
SELECT COUNT(1),NULL,NULL FROM T_Students t2 WHERE t2.ClassId = 1 AND t2.Gender = 1;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查询结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cnt         Code                           Name
----------- ------------------------------ ------------------------------
1           S330102001                     郑强
1           S330102002                     肖俊生
1           S330300007                     钱波
1           S330104009                     金桥
4           NULL                           NULL&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;1.1.3、&lt;strong&gt;UNION 与 ORDER BY&lt;/strong&gt;。查询 1 班的男生和 2 班的女生，并且将最终结果集按年龄从大到小排序。示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SELECT * FROM T_Students t1 WHERE t1.ClassId = 1 AND t1.Gender = 1
UNION ALL
SELECT * FROM T_Students t2 WHERE t2.ClassId = 2 AND t2.Gender = 0
ORDER BY t1.Birthday;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;1.1.4、&lt;strong&gt;UNION 与 SELECT INTO&lt;/strong&gt;。创建一个活动学生表，并将 1 班的男生和 2 班的女生加入其中。示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SELECT t1.Code,t1.Name,t1.Gender,t1.Birthday 
INTO T_ActivityStudents 
FROM T_Students t1 
WHERE t1.ClassId = 1 AND t1.Gender=1 
UNION ALL
SELECT t2.Code,t2.Name,t2.Gender,t2.Birthday 
FROM T_Students t2 
WHERE t2.ClassId = 2 AND t2.Gender=0;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;1.1.5、&lt;strong&gt;通过括号来改变 UNION 的运算顺序&lt;/strong&gt;。示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;WITH t AS(
    SELECT TOP(3) * FROM T_Students t WHERE t.ClassId = 1 ORDER BY t.Birthday
)
SELECT * FROM t
UNION ALL(
    SELECT * FROM t
    UNION
    SELECT * FROM t
);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;简单说明一下：首先，上例会返回 6 条数据。其次，很明显 CTE 中包含了年龄最大的 3 个学生。然后，括号会提升运算符的优先级，而且 UNION 会删除重复行，所以括号中会返回 3 条数据。最后，UNION ALL 不会删除重复行，所以最终返回的 6 条数据是第一个查询返回的 3 条数据加上括号中两个查询共同产生的 3 条数据。&lt;/p&gt;
&lt;h4 id=&quot;12&quot;&gt;1.2、差集运算 EXCEPT&lt;/h4&gt;
&lt;p&gt;差集运算符 EXCEPT 的作用是比较两个查询的结果集，然后返回左侧结果集包含但右侧结果集不包含的行，且不包含重复行。与 UNION 运算相同，EXCEPT 运算也要求各个子结果集的字段数相同、顺序相同、类型兼容。且 EXCEPT 也会把两个 NULL 值被视为相等的。示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SELECT * FROM T_GoodStudents t1 WHERE t1.Gender = 0
EXCEPT
SELECT * FROM T_GoodStudents t2 WHERE t2.Birthday &amp;lt; '2000-01-01';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：上例是用女生这个结果集减去非 00 后学生结果集，但得到的结果集并不一定是 00 后女生，因为女生的出生日期可能是 NULL，所以最终的结果集是 00 后女生加上出生日期为 NULL 的女生。&lt;/p&gt;
&lt;p&gt;类似于 UNION：EXCEPT 也可以与 ORDER BY 连用来给差集（最终的结果集）排序，而且差集的列名也跟第一个子结果集的列名相同。EXCEPT 还可以与 SELECT INTO 连用将差集拷贝到一个新表中。当有多个 EXCEPT 时也可以通过括号来改变运算顺序。具体用法可参考 UNION 的示例。&lt;/p&gt;
&lt;h4 id=&quot;13&quot;&gt;1.3、交集运算 INTERSECT&lt;/h4&gt;
&lt;p&gt;交集运算符 INTERSECT 的作用是比较两个查询的结果集，然后返回左侧结果集和右侧结果集都包含的行，且不包含重复行。与 UNION 运算相同，INTERSECT 运算也要求各个子结果集的字段数相同、顺序相同、类型兼容。且 INTERSECT 也会把两个 NULL 值被视为相等的。示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SELECT * FROM T_GoodStudents t1 WHERE t1.Gender = 0
INTERSECT
SELECT * FROM T_GoodStudents t2 WHERE t2.Birthday &amp;lt; '2000-01-01';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：上例是取女生这个结果集和非 00 后学生结果集的交集，但得到的结果集并不一定是非 00 后女生，因为女生的出生日期可能是 NULL，所以最终的结果集是非 00 后女生加上出生日期为 NULL 的女生。&lt;/p&gt;
&lt;p&gt;类似于 UNION：INTERSECT 也可以与 ORDER BY 连用来给交集（最终的结果集）排序，而且交集的列名也跟第一个子结果集的列名相同。INTERSECT 还可以与 SELECT INTO 连用将交集拷贝到一个新表中。当有多个 INTERSECT 时也可以通过括号来改变运算顺序。具体用法可参考 UNION 的示例。&lt;/p&gt;
&lt;h4 id=&quot;14&quot;&gt;1.4、集合运算小结&lt;/h4&gt;
&lt;p&gt;上文逐一讲述了各个集合运算符的语法和用途。其实这些集合运算符不仅可以单独使用，还可以结合起来使用，示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SELECT t1.Id,t1.Name,t1.Gender,t1.Birthday FROM T_Students t1 WHERE t1.ClassId = 1
UNION ALL
SELECT t2.Id,t2.Name,t2.Gender,t2.Birthday FROM T_Students t2 WHERE t2.ClassId = 3
EXCEPT
SELECT * FROM T_GoodStudents t3 WHERE t3.Birthday &amp;lt; '2000-01-01'
INTERSECT
SELECT * FROM T_GoodStudents t4 WHERE t4.Gender = 1;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：上例的运算顺序并不是先 UNION ALL，然后 EXCEPT，再 INTERSECT。因为 INTERSECT 比 EXCEPT 和 UNION 的优先级要高，而 EXCEPT 与 UNION 的优先级相同，所以上例的实际运算顺序是先 INTERSECT，然后 UNION ALL，最后再用 UNION ALL 的结果集减 INTERSECT 的结果集，即最后进行 EXCEPT 运算。&lt;/p&gt;
&lt;h2 id=&quot;2&quot;&gt;2、聚合函数&lt;/h2&gt;
&lt;p&gt;聚合函数的作用是对一组值执行计算，并返回单个结果值。聚合函数只能在 SELECT 子句或 HAVING 子句中作为表达式来用。求行数函数 COUNT、求和函数 SUM、求最大值函数 MAX、求最小值函数 MIN、求平均值函数 AVG，这 5 个函数是最常用的聚合函数，主流的关系型数据库也都支持它们。&lt;/p&gt;
&lt;p&gt;其实常见的关系型数据库都支持很多聚合函数，但其中大部分都是非标准的，各个数据库之间的差别也比较大，而且这些函数也都不常用。个人建议实际工作中不要用这些函数，以免跟某个具体的数据库绑死。&lt;/p&gt;
&lt;h4 id=&quot;21&quot;&gt;2.1、求行数函数 COUNT&lt;/h4&gt;
&lt;p&gt;求行数函数 COUNT 会返回查询结果集的行数。COUNT 函数中可以是一个具体的列，也可以是代表所有列的星号，还可以是一个具体的常量或变量。示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SELECT COUNT(t.Id) result FROM T_Students t; -- result：32 rows
SELECT COUNT(*) result FROM T_Students t;    -- result：32 rows
SELECT COUNT(1) result FROM T_Students t;    -- result：32 rows&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;COUNT 是所有聚合函数中唯一不会忽略 NULL 值的函数，但如果被计算列本身含有 NULL 值是会被忽略的。示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SELECT COUNT(Remark) result FROM T_Students t; -- result：28 rows&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 COUNT 函数中添加 DISTINCT 参数，表示会先去除重复行，然后统计剩下的非 NULL 且唯一的值的个数。示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SELECT COUNT(DISTINCT Remark) result FROM T_Students t; -- result：26 rows&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：COUNT 函数的返回值一定是大于或等于 0 的整数，证明如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SELECT COUNT(*) result;             -- result：1 rows
SELECT COUNT(*) result WHERE 1 = 2; -- result：0 rows&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另外，从 SQL Server 2008 开始，官方在增加了一个&lt;code&gt;COUNT_BIG&lt;/code&gt;函数，它的用法和用途与 COUNT 完全相同，唯一不同的就是返回值的类型。COUNT 函数总是返回一个 INT 类型的整数，而&lt;code&gt;COUNT_BIG&lt;/code&gt;函数总是返回一个 BIGINT 类型的整数。示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SELECT COUNT_BIG(1) result FROM T_Students t;               -- result：32 rows
SELECT COUNT_BIG(Remark) result FROM T_Students t;          -- result：28 rows
SELECT COUNT_BIG(DISTINCT Remark) result FROM T_Students t; -- result：26 rows&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;22&quot;&gt;2.2、求和函数 SUM&lt;/h4&gt;
&lt;p&gt;求和函数 SUM 会返回表达式中所有值的和。SUM 函数会忽略所有 NULL 值，且只能应用于数字类型的字段。例如要查询学生 1 第 1 次考试的总分，示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SELECT SUM(t.Scores) FROM T_ExamResults t WHERE t.StudentId = 1 AND t.Counts = 1;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 SUM 函数中添加 DISTINCT 参数，表示会先去除重复行，然后统计剩下的非 NULL 且唯一的数值之和。示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SELECT SUM(t.Scores) result FROM T_ExamResults t WHERE t.StudentId = 6;          -- result：2202.5
SELECT SUM(DISTINCT t.Scores) result FROM T_ExamResults t WHERE t.StudentId = 6; -- result：1857.5&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：SUM 函数的返回值有可能会是 NULL 值，证明如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SELECT SUM(1) result;             -- result：1
SELECT SUM(1) result WHERE 1 = 2; -- result：NULL&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;23&quot;&gt;2.3、求最大值函数 MAX&lt;/h4&gt;
&lt;p&gt;求最大值函数 MAX 会返回表达式中的最大值。MAX 函数会忽略所有 NULL 值。例如要查询学生 1 课程 1 的历次考试最高分，示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SELECT MAX(t.Scores) FROM T_ExamResults t WHERE t.StudentId = 1 AND t.Counts = 1;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;MAX 函数还可以作用于日期类型或字符类型，此时 MAX 将按照日期数值或字符排序顺序来确定最大值。示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SELECT MAX(t.Birthday) FROM T_Students t; -- 数值最大的出生日期，年龄最小
SELECT MAX(t.Name) FROM T_Students t;     -- 字符排序最靠后的姓名&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：MAX 函数的返回值有可能会是 NULL 值，证明如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SELECT MAX(1) result;             -- result：1
SELECT MAX(1) result WHERE 1 = 2; -- result：NULL&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;24&quot;&gt;2.4、求最小值函数 MIN&lt;/h4&gt;
&lt;p&gt;求最小值函数 MIN 会返回表达式中的最小值。MIN 函数会忽略所有 NULL 值。例如要查询学生 1 课程 1 的历次考试最低分，示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SELECT MIN(t.Scores) FROM T_ExamResults t WHERE t.StudentId = 1 AND t.Counts = 1;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;MIN 函数还可以作用于日期类型或字符类型，此时 MAX 将按照日期数值或字符排序顺序来确定最小值。示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SELECT MIN(t.Birthday) FROM T_Students t; -- 数值最小的出生日期，年龄最大
SELECT MIN(t.Name) FROM T_Students t;     -- 字符排序最靠前的姓名&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：MIN 函数的返回值有可能会是 NULL 值，证明如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SELECT MIN(1) result;             -- result：1
SELECT MIN(1) result WHERE 1 = 2; -- result：NULL&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;25&quot;&gt;2.5、求平均值函数 AVG&lt;/h4&gt;
&lt;p&gt;求平均值函数 AVG 会返回表达式中所有值的平均值。AVG 函数会忽略所有 NULL 值，且只能应用于数字类型的字段。例如要查询学生 1 第 1 次考试的平均分，示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SELECT AVG(t.Scores) FROM T_ExamResults t WHERE t.StudentId = 1 AND t.Counts = 1;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 AVG 函数中添加 DISTINCT 参数，表示会先去除重复行，然后统计剩下的非 NULL 且唯一的数值之和。示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SELECT AVG(t.Scores) result FROM T_ExamResults t WHERE t.StudentId = 6;          -- result：73.416666
SELECT AVG(DISTINCT t.Scores) result FROM T_ExamResults t WHERE t.StudentId = 6; -- result：74.300000&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：AVG 函数的返回值有可能会是 NULL 值，证明如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SELECT AVG(1) result;             -- result：1
SELECT AVG(1) result WHERE 1 = 2; -- result：NULL&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;26&quot;&gt;2.6、聚合函数小结&lt;/h4&gt;
&lt;p&gt;上文逐一讲述了常见五大聚合函数的基本语法和用途。其实这些聚合函数不仅可以单独使用，还可以结合起来使用。&lt;/p&gt;
&lt;p&gt;示例一、查询第 1 次课程 2 考试成绩的统计结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SELECT COUNT(1) 参与人数,
    SUM(t.Scores) 总分,MAX(t.Scores) 最高分,MIN(t.Scores) 最低分,AVG(t.Scores) 平均分
FROM T_ExamResults t 
WHERE t.Counts = 1 AND t.CourseId = 2;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;示例二、查询 1 班的学生总数及年龄统计结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;WITH t AS(
    SELECT t.Code,t.Name,DATEDIFF(YEAR,t.Birthday,GETDATE()) Age 
    FROM T_Students t 
    WHERE t.ClassId = 1
)
SELECT COUNT(1) 学生个数,MAX(t.Age) 最大年龄,MIN(t.Age) 最小年龄,AVG(t.Age) 平均年龄 
FROM t;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：本文所有关于聚合函数的示例，查询选择列表中包含的都是聚合函数表达式，没有一个字段，因为不允许，不过倒是可以包含与表字段无关的常量或变量。其实聚合函数通常与 GROUP BY 子句一起使用，而且也只有包含在 GROUP BY 子句中的字段才能出现在查询选择列表中，具体原因将在下一篇博文中具体讲述。&lt;/p&gt;
&lt;h2 id=&quot;3&quot;&gt;3、本文小结&lt;/h2&gt;
&lt;p&gt;本文主要讲述了 SQL Server 中的集合运算和聚合函数，以及它们的基本语法和用途。在集合运算中，UNION 和 UNION ALL 是比较常用的。而常见的 5 个聚合函数都比较常用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文参考链接：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6.5961002785515&quot;&gt;
&lt;p&gt;&lt;strong&gt;本文链接&lt;/strong&gt;：&lt;a href=&quot;http://www.cnblogs.com/hanzongze/p/tsql-aggregate.html&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/hanzongze/p/tsql-aggregate.html&lt;/a&gt;&lt;br/&gt;&lt;strong&gt;版权声明&lt;/strong&gt;：本文为博客园博主 &lt;a href=&quot;http://www.cnblogs.com/hanzongze/&quot;&gt;&lt;strong&gt;韩宗泽&lt;/strong&gt;&lt;/a&gt; 原创，作者保留署名权！欢迎通过转载、演绎或其它传播方式来使用本文，但必须在明显位置给出作者署名和本文链接！个人博客，能力有限，若有不当之处，敬请批评指正，谢谢！&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 09 Jul 2019 00:25:00 +0000</pubDate>
<dc:creator>韩宗泽</dc:creator>
<og:description>《SQL Server温故系列》之集合运算、聚合函数。SQL Server 中的集合运算有并集运算、差集运算和交集运算三种。聚合函数的作用是对一组值执行计算，且只能在 SELECT 子句或 HAVIN</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hanzongze/p/tsql-aggregate.html</dc:identifier>
</item>
<item>
<title>kubernetes实战之consul篇及consul在windows下搭建consul简单测试环境 - 周国通</title>
<link>http://www.cnblogs.com/tylerzhou/p/11155142.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tylerzhou/p/11155142.html</guid>
<description>&lt;p&gt;consul是一款服务发现中间件,1.12版本后增加servicemesh功能.consul是分布式的,可扩展的,高可用的根据官方文档介绍,目前已知最大的consul集群有5000个节点,consul被广泛用用于服务发现,服务健康检测以及分布式配置存储,并且不断地改进对servicemesh和kubernetes的支持,很多优秀项目包括ocelot,spring cloud都提供了与consul的便利集成,本系列也会将consul做为一个重点的有状态服务较为细致讲解,让大家对kubernetes在服务管理上的便捷性,自发性有更深的理解(在kubernetes里,有状态服务部署是一件很困难的事,要考虑服务间必须互相排斥,对服务资源的合理限制以及服务发生漂移时数据的处理,部分服务挂掉后如何在没有人工介入的情况下自动加入集群等问题),虽然我们在第一天接触容器的时候都会看到容器与虚拟机的对比,以及容器的优势,但是很多初学者仍然是把容器当作虚拟机来使用,按照在虚拟机中部署应用的思路在容器里部署应用,当然仅仅为了方便测试这样做是无可厚非的,但是生产环境是非常严肃的,一定要对可能产生的问题有充分的预估以便提前安排应对方案,并且充分利用新技术的特点对自己应用的部署灵活性,维护便捷性以及应用本身的伸缩性等方面进行持续优化.&lt;/p&gt;
&lt;p&gt;consul是一款服务发现中间件,1.12版本后增加servicemesh功能.consul是分布式的,可扩展的,高可用的.其主要功能如下&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;service discovery：consul通过DNS或者HTTP接口使服务注册和服务发现变的很容易，一些外部服务，例如saas提供的也可以一样注册。&lt;/li&gt;
&lt;li&gt;health checking：健康检测使consul可以快速的告警在集群中的操作。和服务发现的集成，可以防止服务转发到故障的服务上面。&lt;/li&gt;
&lt;li&gt;key/value storage：一个用来存储动态配置的系统。提供简单的HTTP接口，可以在任何地方操作。&lt;/li&gt;
&lt;li&gt;multi-datacenter：无需复杂的配置，即可支持任意数量的区域&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;基本概念&quot;&gt;基本概念&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;CLIENT&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;CLIENT表示consul的client模式，就是客户端模式。是consul节点的一种模式，这种模式下，所有注册到当前节点的服务会被转发到SERVER，本身是不持久化这些信息。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SERVER&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;SERVER表示consul的server模式，表明这个consul是个server，这种模式下，功能和CLIENT都一样，唯一不同的是，它会把所有的信息持久化的本地，这样遇到故障，信息是可以被保留的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SERVER-LEADER&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;中间那个SERVER下面有LEADER的字眼，表明这个SERVER是它们的老大，它和其它SERVER不一样的一点是，它需要负责同步注册的信息给其它的SERVER，同时也要负责各个节点的健康监测。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;其它信息&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其它信息包括它们之间的通信方式，还有一些协议信息，算法。它们是用于保证节点之间的数据同步，实时性要求等等一系列集群问题的解决。这些有兴趣的自己看看官方文档。&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;由于本系列的性质是关于devops的,因此不对consul做详细介绍,需要了解consul的同学可以参考官方文档或者相关博客.这里的关注点主要在于测试环境和生产环境的部署上.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;平台支持情况&quot;&gt;平台支持情况&lt;/h2&gt;
&lt;p&gt;consul支持linux,macos和windows平台,开发环境可以使用基于windows的consul,仅有一个可执行程序,使用非常方便,生产环境建议使用linux或者docker/kubernetes部署&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;后面我们将会对consul windows测试环境部署,docker 单节点部署,docker集群部署,kubernetes集群部署一一做介绍.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;consul在windows下测试环境简单部署&quot;&gt;consul在windows下测试环境简单部署&lt;/h2&gt;
&lt;p&gt;本篇只介绍在windows下部署单节点测试环境,关于集群的部署可以参照后面docker的部署方式.&lt;/p&gt;
&lt;p&gt;本篇非常简单,但是考虑到内容的独立性,因此单独做为一节.&lt;/p&gt;
&lt;h3 id=&quot;consul-windows版下载&quot;&gt;consul windows版下载&lt;/h3&gt;
&lt;p&gt;可以在百度里搜索&lt;code&gt;consul&lt;/code&gt;,进入到官网首页就可以看到醒目的&lt;a href=&quot;https://www.consul.io/downloads.html&quot;&gt;download&lt;/a&gt;,选择windows 版的下载即可.&lt;/p&gt;
&lt;p&gt;下载完成后可以看到是一个单文件,名叫作&lt;code&gt;consul.exe&lt;/code&gt;,这里建议把它单独放到一个文件夹里面,因为后面可能需要添加配置文件,放在一个文件夹下面方便管理.&lt;/p&gt;
&lt;h3 id=&quot;consul-windows版-部署&quot;&gt;consul windows版 部署&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意这里不像普通的exe双击安装,而是需要通过命令行启动&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在&lt;code&gt;consul.exe所在的文件夹&lt;/code&gt;打开命令窗口,输入&lt;code&gt;consul --help&lt;/code&gt;就会出现以下关于consul的命令帮助&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;λ consul --help
Usage: consul [--version] [--help] &amp;lt;command&amp;gt; [&amp;lt;args&amp;gt;]

Available commands are:
    acl            Interact with Consul's ACLs
    agent          Runs a Consul agent
    catalog        Interact with the catalog
    connect        Interact with Consul Connect
    debug          Records a debugging archive for operators
    event          Fire a new event
    exec           Executes a command on Consul nodes
    force-leave    Forces a member of the cluster to enter the &quot;left&quot; state
    info           Provides debugging information for operators.
    intention      Interact with Connect service intentions
    join           Tell Consul agent to join cluster
    keygen         Generates a new encryption key
    keyring        Manages gossip layer encryption keys
    kv             Interact with the key-value store
    leave          Gracefully leaves the Consul cluster and shuts down
    lock           Execute a command holding a lock
    maint          Controls node or service maintenance mode
    members        Lists the members of a Consul cluster
    monitor        Stream logs from a Consul agent
    operator       Provides cluster-level tools for Consul operators
    reload         Triggers the agent to reload configuration files
    rtt            Estimates network round trip time between nodes
    services       Interact with services
    snapshot       Saves, restores and inspects snapshots of Consul server state
    validate       Validate config files/directories
    version        Prints the Consul version
    watch          Watch for changes in Consu&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在命令窗口输入&lt;code&gt;consul agent -dev&lt;/code&gt;就可以以dev模式启动consul了,以下是输出内容的头部&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;==&amp;gt; Starting Consul agent...
==&amp;gt; Consul agent running!
           Version: 'v1.4.0'
           Node ID: '2be40d2e-a5eb-5dda-271f-70a39141d791'
         Node name: 'DESKTOP-OE0CB8G'
        Datacenter: 'dc1' (Segment: '&amp;lt;all&amp;gt;')
            Server: true (Bootstrap: false)
       Client Addr: [127.0.0.1] (HTTP: 8500, HTTPS: -1, gRPC: 8502, DNS: 8600)
      Cluster Addr: 127.0.0.1 (LAN: 8301, WAN: 8302)
           Encrypt: Gossip: false, TLS-Outgoing: false, TLS-Incoming: false

==&amp;gt; Log data will now stream in as it occurs:&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过以上输入内容可以看到,consul已经运行,版本是1.4.HTTP端口是8500,我们在浏览器输入&lt;code&gt;localhost:8500&lt;/code&gt;就可以看到consul的web管理界面了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201907/811801-20190709081303794-1622005228.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此,windows配置已经完成了.&lt;/p&gt;
&lt;h3 id=&quot;更改默认端口&quot;&gt;更改默认端口&lt;/h3&gt;
&lt;p&gt;可以看到,默认情况下,http端口是8500,测试环境下我们可能没有需求更改端口,可是正式环境部署的时候可能需要更改端口号,更改端口号也非常简单,在启动agent的时候加上&lt;code&gt;-http-port&lt;/code&gt;选项即可.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;consul agent -dev -http-port=8400&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;==&amp;gt; Starting Consul agent...
==&amp;gt; Consul agent running!
           Version: 'v1.4.0'
           Node ID: '7a083b04-cd4a-04af-743b-4fdc8d82c62e'
         Node name: 'DESKTOP-OE0CB8G'
        Datacenter: 'dc1' (Segment: '&amp;lt;all&amp;gt;')
            Server: true (Bootstrap: false)
       Client Addr: [127.0.0.1] (HTTP: 8400, HTTPS: -1, gRPC: 8502, DNS: 8600)
      Cluster Addr: 127.0.0.1 (LAN: 8301, WAN: 8302)
           Encrypt: Gossip: false, TLS-Outgoing: false, TLS-Incoming: false&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从输出信息中可以看到,http端口已经更改成8400了.&lt;/p&gt;
</description>
<pubDate>Tue, 09 Jul 2019 00:15:00 +0000</pubDate>
<dc:creator>周国通</dc:creator>
<og:description>consul是一款服务发现中间件,1.12版本后增加servicemesh功能.consul是分布式的,可扩展的,高可用的根据官方文档介绍,目前已知最大的consul集群有5000个节点,consul</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tylerzhou/p/11155142.html</dc:identifier>
</item>
<item>
<title>golang开发:类库篇(二) Redis连接池的使用 - 飞翔码农</title>
<link>http://www.cnblogs.com/feixiangmanon/p/11155120.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/feixiangmanon/p/11155120.html</guid>
<description>&lt;h3 id=&quot;为什么要使用连接池&quot;&gt;为什么要使用连接池&lt;/h3&gt;
&lt;p&gt;一个数据库服务器只拥有有限的连接资源，一旦所有的连接资源都在使用，那么其它需要连接的资源就只能等待释放连接资源。所以，在连接资源有限的情况下，提高单位时间的连接的使用效率，缩短连接时间，就能显著缩短请求时间。&lt;/p&gt;
&lt;p&gt;所以就有了连接池的概念，在初始化时，创建一定数量的连接，先把所有连接存起来，然后，谁需要使用，从这里取走，干完活立马放回来。 如果请求数超出连接池容量，那么就排队等待或者直接丢弃掉。这样就可以省掉每次都创建和关闭连接的资源消耗和时间。&lt;/p&gt;
&lt;p&gt;如果不使用连接池，那么，每次传输数据，我们都需要耗费大量的系统资源进行创建连接，收发数据，关闭连接。很明显，重复创建连接 关闭连接这样的消耗是可以节省。&lt;/p&gt;
&lt;h3 id=&quot;怎么使用redis连接池&quot;&gt;怎么使用Redis连接池&lt;/h3&gt;
&lt;p&gt;先看下简单的使用案例。&lt;br/&gt;首先当然是下载类库包&lt;br/&gt;go get github.com/gomodule/redigo/redis&lt;br/&gt;贴下简单的使用代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package main

import (
    red &quot;github.com/gomodule/redigo/redis&quot;
    &quot;time&quot;
    &quot;fmt&quot;
)

type Redis struct {
    pool     *red.Pool
}

var redis *Redis

func initRedis() {
    redis = new(Redis)
    redis.pool = &amp;amp;red.Pool{
        MaxIdle:     256,
        MaxActive:   0,
        IdleTimeout: time.Duration(120),
        Dial: func() (red.Conn, error) {
            return red.Dial(
                &quot;tcp&quot;,
                &quot;127.0.0.1:6379&quot;,
                red.DialReadTimeout(time.Duration(1000)*time.Millisecond),
                red.DialWriteTimeout(time.Duration(1000)*time.Millisecond),
                red.DialConnectTimeout(time.Duration(1000)*time.Millisecond),
                red.DialDatabase(0),
                //red.DialPassword(&quot;&quot;),
            )
        },
    }
}

func Exec(cmd string, key interface{}, args ...interface{}) (interface{}, error) {
    con := redis.pool.Get()
    if err := con.Err(); err != nil {
        return nil, err
    }
    defer con.Close()
    parmas := make([]interface{}, 0)
    parmas = append(parmas, key)

    if len(args) &amp;gt; 0 {
        for _, v := range args {
            parmas = append(parmas, v)
        }
    }
    return con.Do(cmd, parmas...)
}

func main() {
    initRedis()

    Exec(&quot;set&quot;,&quot;hello&quot;,&quot;world&quot;)
    fmt.Print(2)
    result,err := Exec(&quot;get&quot;,&quot;hello&quot;)
    if err != nil {
        fmt.Print(err.Error())
    }
    str,_:=red.String(result,err)
    fmt.Print(str)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用类库操作连接池就比较简单，只要从连接池获取一个连接，进行数据操作，然后关闭连接。连接池对连接的创建 回收等的管理，都是连接池内部实现。&lt;br/&gt;执行看下结果是不是预想的&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;go build -o test_web.bin
./test_web.bin
2world&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果跟预想的一毛一样&lt;/p&gt;
&lt;h3 id=&quot;基本配置说明&quot;&gt;基本配置说明&lt;/h3&gt;
&lt;p&gt;MaxIdle：最大的空闲连接数，表示即使没有redis连接时依然可以保持N个空闲的连接，而不被清除，随时处于待命状态。&lt;br/&gt;MaxActive：最大的连接数，表示同时最多有N个连接。0表示不限制。&lt;br/&gt;IdleTimeout：最大的空闲连接等待时间，超过此时间后，空闲连接将被关闭。如果设置成0，空闲连接将不会被关闭。应该设置一个比redis服务端超时时间更短的时间。&lt;br/&gt;DialConnectTimeout：连接Redis超时时间。&lt;br/&gt;DialReadTimeout：从Redis读取数据超时时间。&lt;br/&gt;DialWriteTimeout：向Redis写入数据超时时间。&lt;/p&gt;
&lt;p&gt;连接流程大概是这样的&lt;br/&gt;1.尝试从空闲列表MaxIdle中，获得一个可用连接;如果成功直接返回，失败则尝试步骤2&lt;br/&gt;2.如果当前的MaxIdle &amp;lt; 连接数 &amp;lt; MaxActive，则尝试创建一个新连接，失败则尝试步骤3&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如果连接数 &amp;gt; MaxActive就等待,直到满足步骤2的条件，重复步骤2&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;遇到过的问题&quot;&gt;遇到过的问题&lt;/h3&gt;
&lt;p&gt;目前为止，连接池的问题只遇到过一次问题，而且是在测试环境的，当时的配置是&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;DialConnectTimeout：time.Duration(200)*time.Millisecond
DialReadTimeout：time.Duration(200)*time.Millisecond
DialWriteTimeout：time.Duration(200)*time.Millisecond&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置的都是200毫秒。有一次使用hgetall的时候，就一直报错，大概类似下面的提示&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;read tcp 127.0.0.1:6379: i/o timeout&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;字面意思就是 read tcp 超时，可能某些写入大点数据的时候也会报，write tcp timeout。&lt;br/&gt;后来将读写超时时间都改为1000毫秒，就再也没有出现过类似的报错。&lt;/p&gt;
&lt;p&gt;当然了，想了解更多的Redis使用，可以看下官方的文档，里面有各种情况的各种说明。&lt;br/&gt;&lt;a href=&quot;https://github.com/gomodule/redigo/&quot; class=&quot;uri&quot;&gt;https://github.com/gomodule/redigo/&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 08 Jul 2019 23:54:00 +0000</pubDate>
<dc:creator>飞翔码农</dc:creator>
<og:description>为什么要使用连接池 一个数据库服务器只拥有有限的连接资源，一旦所有的连接资源都在使用，那么其它需要连接的资源就只能等待释放连接资源。所以，在连接资源有限的情况下，提高单位时间的连接的使用效率，缩短连接</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/feixiangmanon/p/11155120.html</dc:identifier>
</item>
<item>
<title>Qt之股票组件-自选股--列表可以拖拽、右键常用菜单 - 朝十晚八</title>
<link>http://www.cnblogs.com/swarmbees/p/11154841.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/swarmbees/p/11154841.html</guid>
<description>&lt;p&gt;&lt;strong&gt;原文链接：&lt;/strong&gt;&lt;a href=&quot;https://www.cnblogs.com/swarmbees/p/11154841.html&quot;&gt;Qt之股票组件-自选股--列表可以拖拽、右键常用菜单&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;一开头嘴一嘴&quot;&gt;一、开头嘴一嘴&lt;/h2&gt;
&lt;p&gt;上一篇文章&lt;a href=&quot;https://www.cnblogs.com/swarmbees/p/11154821.html&quot;&gt;Qt之股票组件-股票检索--支持搜索结果预览、鼠标、键盘操作&lt;/a&gt;讲述了股票检索功能，这篇文章我们来看看自选股列表的实现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果有需要的朋友可以加我好友，有偿提供源码、或者也可以进一步提供功能定制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;封装的控件，或者demo都是没有样式的，所以看着会比较丑一些，不过加样式也是分分钟。。。这里咱可以先看功能，需要即可定制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本篇文章的自选股和大多数炒股软件一样，每一条自选都是支持拖拽的，拖拽时鼠标会跟随一个拖拽映像，并且鼠标移动时，会有拖拽提示，告知我们鼠标释放时拖拽项将会被插入到哪个位置。除过拖拽之外，自选股列表还支持右键菜单，都是一样常用的操作。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;右键菜单包括置顶、置低、删除、下移一项、上移一项等&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;本篇文章中不包括的功能也可以提供定制，需求合理即可。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面来具体说一说这个功能的实现思路，会公开大多数核心代码，有需要的同学可以根据思路自行完善整个代码。&lt;/p&gt;
&lt;h2 id=&quot;二效果展示&quot;&gt;二、效果展示&lt;/h2&gt;
&lt;p&gt;如下效果图所示，是自选股使用上的一个展示效果，具有如下功能&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;搜索编辑框，支持股票代码和股票名称搜索&lt;/li&gt;
&lt;li&gt;搜索预览框支持鼠标hover，并且可以使用键盘上下键进行当前项切换，单机时支持切换自选股&lt;/li&gt;
&lt;li&gt;自选股列表，支持拖拽，拖拽时会有拖拽项映像，并示意将要拖拽到哪个位置&lt;/li&gt;
&lt;li&gt;支持右键菜单，可以对某一项进行移动，删除等操作&lt;/li&gt;
&lt;/ol&gt;&lt;center&gt;
&lt;div&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/swarmbees/1498827/o_option_stock.gif&quot;/&gt;&lt;/div&gt;
&lt;/center&gt;
&lt;p&gt;如果觉着demo比较丑的话，可以看&lt;a href=&quot;https://www.cnblogs.com/swarmbees/p/6707798.html&quot;&gt;财联社-产品展示&lt;/a&gt;这篇文章中的效果图&lt;/p&gt;
&lt;h2 id=&quot;三自选股列表&quot;&gt;三、自选股列表&lt;/h2&gt;
&lt;p&gt;接下来就是我们这篇文章的重头戏了，也是比较复杂的一个内容。&lt;/p&gt;
&lt;p&gt;自选股列表我选择的是使用QListWidget来实现，然后每一个item上在放一个Widget即可，Widget就是我们定制窗体内容，&lt;/p&gt;
&lt;p&gt;这里我们主要讲解几个比较重要的核心内容&lt;/p&gt;
&lt;h3 id=&quot;列表初始化&quot;&gt;1、列表初始化&lt;/h3&gt;
&lt;p&gt;初始化StockList，实际上自选股列表应该从服务器拉取，我们这里作为demo测试，因此就自己模拟了5条数据进行插入。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//已选个股列表
d_ptr-&amp;gt;m_pStockList = new StockList;
connect(d_ptr-&amp;gt;m_pStockList, &amp;amp;StockList::RowClicked, this, [this](const QString &amp;amp; symbol){
    emit RowClicked(symbol);
});

//测试数据 正常情况下 应该是列表自己拉取
OptionalMarketItem item;
for (int i = 1; i &amp;lt;= 5; ++i)
{
    item.wstrSymbol = QString(&quot;0h000%1&quot;).arg(i).toStdWString();
    item.wstrName = QString(&quot;%1%1%1&quot;).arg(i).toStdWString();
    item.wstrIndustryName = QString(&quot;pingyin%1&quot;).arg(i).toStdWString();

    d_ptr-&amp;gt;m_pStockList-&amp;gt;AddItem(item);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;添加item&quot;&gt;2、添加Item&lt;/h3&gt;
&lt;p&gt;往StockList中添加item项时，我们首先需要构造一个标准的QListWidgetItem结构，然后把我们自己定制的ListItem放到这个标准item结构上。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;QListWidgetItem * StockList::AddItem(const OptionalMarketItem &amp;amp; data)
{
    ListItem * itemWidget = new ListItem;
    
    itemWidget-&amp;gt;SetData(data);
    QListWidgetItem * item = new QListWidgetItem;
    addItem(item);
    item-&amp;gt;setSizeHint(QSize(0, 50));

    setItemWidget(item, itemWidget);

    return item;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ListItem就是一个普通的QWidget，上边排列了一些QLabel，用于显示我们的股票数据。&lt;/p&gt;
&lt;p&gt;ListItem界面构造就不过多解释了，唯一需要说明的就是，我们股票数据发送变化时，界面上会有红绿色框的动画提示，这里需要调用两行代码来实现重新获取控件qss代码，并刷洗界面。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;this-&amp;gt;style()-&amp;gt;unpolish(this);
this-&amp;gt;style()-&amp;gt;polish(this);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;右键菜单&quot;&gt;3、右键菜单&lt;/h3&gt;
&lt;p&gt;本篇文章和上一篇文章的右键菜单实现方式一样，都是参考我很早以前写的&lt;a href=&quot;https://www.cnblogs.com/swarmbees/p/6044361.html&quot;&gt;Qt之自定义QLineEdit右键菜单&lt;/a&gt;这篇文章，实现默认的contextMenuEvent函数即可。&lt;/p&gt;
&lt;p&gt;右键菜单已经说的很多了，这里就一笔带过了，需要的同学可以自己快速的瞅一眼，应该比较容易理解。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void StockList::contextMenuEvent(QContextMenuEvent * event)
{
    if (d_ptr-&amp;gt;m_AllowMenu == false)
    {
        return;
    }

    if (d_ptr-&amp;gt;m_ContextMenu == nullptr)
    {
        d_ptr-&amp;gt;m_ContextMenu = new QMenu(this);
        d_ptr-&amp;gt;m_ContextMenu-&amp;gt;setObjectName(QStringLiteral(&quot;StockListMenu&quot;));
        d_ptr-&amp;gt;m_ContextMenu-&amp;gt;setFixedWidth(100);

        QAction * delAct = new QAction(QStringLiteral(&quot;删除自选股&quot;), d_ptr-&amp;gt;m_ContextMenu);
        QAction * topAct = new QAction(QStringLiteral(&quot;置顶&quot;), d_ptr-&amp;gt;m_ContextMenu);
        QAction * bottomAct = new QAction(QStringLiteral(&quot;置底&quot;), d_ptr-&amp;gt;m_ContextMenu);
        QAction * upAct = new QAction(QStringLiteral(&quot;上移一位&quot;), d_ptr-&amp;gt;m_ContextMenu);
        QAction * downAct = new QAction(QStringLiteral(&quot;下移一位&quot;), d_ptr-&amp;gt;m_ContextMenu);

        connect(delAct, &amp;amp;QAction::triggered, this, &amp;amp;StockList::DeleteSotck);
        connect(topAct, &amp;amp;QAction::triggered, this, &amp;amp;StockList::TopSotck);
        connect(bottomAct, &amp;amp;QAction::triggered, this, &amp;amp;StockList::BottomSotck);
        connect(upAct, &amp;amp;QAction::triggered, this, &amp;amp;StockList::UpSotck);
        connect(downAct, &amp;amp;QAction::triggered, this, &amp;amp;StockList::DownSotck);

        d_ptr-&amp;gt;m_ContextMenu-&amp;gt;addAction(delAct);
        d_ptr-&amp;gt;m_ContextMenu-&amp;gt;addAction(topAct);
        d_ptr-&amp;gt;m_ContextMenu-&amp;gt;addAction(bottomAct);
        d_ptr-&amp;gt;m_ContextMenu-&amp;gt;addAction(upAct);
        d_ptr-&amp;gt;m_ContextMenu-&amp;gt;addAction(downAct);
    }
    d_ptr-&amp;gt;m_ContextMenu-&amp;gt;exec(mapToGlobal(event-&amp;gt;pos()));

    QListWidget::contextMenuEvent(event);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上5个菜单，虽然看起来功能相差很多，但是其实处理逻辑基本都是一样的，先是一个内容结构排序，然后进行刷新数据到界面上。&lt;/p&gt;
&lt;p&gt;为了节省篇幅，我这里就只介绍置顶一只股票的操作&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;置顶的逻辑看起来是这样的&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;移除当前项&lt;/li&gt;
&lt;li&gt;并且把当前项item插入到新位置&lt;/li&gt;
&lt;li&gt;构造一个新的Widget，设置给item&lt;/li&gt;
&lt;li&gt;把新位置的item设置为当前选中项&lt;/li&gt;
&lt;li&gt;上传最新列表到数据中心，或者服务器&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;void StockList::TopSotck()
{
    QListWidgetItem * item = currentItem();
    if (item == nullptr)
    {
        return;
    }

    if (row(item) == 0)
    {
        return;
    }

    ListItem * itemWidget = ItemWidget(item);
    QListWidgetItem * newItem = takeItem(row(item));
    insertItem(0, newItem);
    ListItem * topWidget = new ListItem;
    topWidget-&amp;gt;SetData(itemWidget-&amp;gt;GetData());
    setItemWidget(newItem, topWidget);

    if (itemWidget)
    {
        itemWidget-&amp;gt;close();
        itemWidget = nullptr;
    }
    setCurrentItem(newItem);

    StorageData();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;拖拽item&quot;&gt;4、拖拽Item&lt;/h3&gt;
&lt;p&gt;拖拽Item应该算是一个比较难一点儿功能，好在Qt已经为我们实现了一套QDrag事件的回调方法，也比较好使，如下图所示，重写如下4个方法，基本的拖拽事件就能完成了。&lt;/p&gt;
&lt;center&gt;
&lt;div&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/swarmbees/1498827/o_drag_handler.png&quot;/&gt;&lt;/div&gt;
&lt;/center&gt;
&lt;p&gt;但是这里我么有选择默认的这个回调函数来实现这个功能，其中最大的原因就是，他们的可定制性太局限了。&lt;/p&gt;
&lt;p&gt;我这里采取的是自己模拟鼠标拖拽功能，同过重写如下几个函数来达到我的目的&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;virtual void mousePressEvent(QMouseEvent * event) override;
virtual void mouseMoveEvent(QMouseEvent * event) override;
virtual void mouseReleaseEvent(QMouseEvent * event) override;
virtual void enterEvent(QEvent * event) override;
virtual void leaveEvent(QEvent * event) override;&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;鼠标按下时，主要是记录了一些内容状态，方便在鼠标移动时去做判断，并决定是否启用鼠标拖拽功能&lt;/li&gt;
&lt;li&gt;鼠标移动就比较复杂了，进行了各种对比，还需要移动被拖拽项的映像位置，移动那一根水平线的位置&lt;/li&gt;
&lt;li&gt;鼠标释放时，调整整个列表的内容&lt;/li&gt;
&lt;li&gt;鼠标进入窗体时，显示水平标识线&lt;/li&gt;
&lt;li&gt;鼠标离开窗体时，隐藏水平标识线&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;上边只是粗略的描述了这几个函数的功能， 因为函数实现体都比较长，因此这里我也是选择几个关键点来做以说明。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;a、move函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;产生拖拽时，移动鼠标，我们需要处理很多事件，比如&lt;/p&gt;
&lt;p&gt;1、初始化水平表示线和拖拽项映像&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if (d_ptr-&amp;gt;m_ShotLine == nullptr)
{
    InitShotLine();
}
if (d_ptr-&amp;gt;m_ShotPicture == nullptr)
{
    InitShotLabel();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、拖拽时修改鼠标状态&lt;/p&gt;
&lt;p&gt;根据拖拽启动后，鼠标是否还在当前拖拽项上，设置鼠标的状态。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if (ListItem * newWidget = ItemWidget(d_ptr-&amp;gt;dragItem))
{
    d_ptr-&amp;gt;m_ShotPicture-&amp;gt;move(QCursor::pos() - d_ptr-&amp;gt;dragItemPos);
    d_ptr-&amp;gt;m_DragRect = visualItemRect(d_ptr-&amp;gt;dragItem);
    if (d_ptr-&amp;gt;m_DragRect.contains(event-&amp;gt;pos()) || event-&amp;gt;pos().isNull())
    {
        if ((event-&amp;gt;pos() - d_ptr-&amp;gt;startPos).manhattanLength() &amp;gt; 5)
        {
            setCursor(Qt::ForbiddenCursor);
        }
    }
    else
    {
        setCursor(Qt::ArrowCursor);
    }
    if (d_ptr-&amp;gt;m_ShotPicture-&amp;gt;isHidden())
    {
        d_ptr-&amp;gt;m_ShotPicture-&amp;gt;show();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;b、release函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;鼠标释放时，把拖拽项移动到新的位置&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if (ListItem * oldWidget = ItemWidget(d_ptr-&amp;gt;dragItem))
{
    QListWidgetItem * newItem = new QListWidgetItem;
    ListItem * itemWidget = new ListItem;
    itemWidget-&amp;gt;SetData(oldWidget-&amp;gt;GetData());

    insertItem(insertPos, newItem);
    newItem-&amp;gt;setSizeHint(QSize(0, 50));
    setItemWidget(newItem, itemWidget);

    setCurrentItem(newItem);

    oldWidget-&amp;gt;deleteLater();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;刷新数据&quot;&gt;5、刷新数据&lt;/h3&gt;
&lt;p&gt;全量刷新数据。在原来的列表上刷新数据&lt;/p&gt;
&lt;p&gt;当原始列表行数不够时，构造新的行&lt;/p&gt;
&lt;p&gt;当原始列表函数多时，移除末尾多的行&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void StockList::Update_p(OptionalMarketItemVector data)
{
    d_ptr-&amp;gt;m_bOnceLoad = true;
    disconnect(this, &amp;amp;QListWidget::currentItemChanged, this, &amp;amp;StockList::CurrentItemChanged);

    int i = 0;
    for (auto iter = data.begin(); iter != data.end(); ++iter, ++i)
    {
        bool success = false;
        if (QListWidgetItem * item = this-&amp;gt;item(i))
        {
            if (ListItem * itemWidget = ItemWidget(item))
            {
                itemWidget-&amp;gt;SetData(*iter);
                success = true;
            }
        }
        if (!success)
        {
            AddItem(*iter);
        }
    }


    if (i &amp;lt; this-&amp;gt;count())
    {
        QListWidgetItem * item = nullptr;
        while (item = this-&amp;gt;item(i))
        {
            if (ListItem * itemWidget = ItemWidget(item))
            {
                itemWidget-&amp;gt;close();
                itemWidget = nullptr;
            }

            item = takeItem(i);
            delete item;
        }
    }

    if (d_ptr-&amp;gt;m_LeftPress == false)
    {
        RecoveryCurrentItem();
    }

    connect(this, &amp;amp;QListWidget::currentItemChanged, this, &amp;amp;StockList::CurrentItemChanged);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;以上讲解都是针对自选股列表的实现，内容差不多就这些了，如果有疑问欢迎提出&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;四相关文章&quot;&gt;四、相关文章&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/swarmbees/p/6707798.html&quot;&gt;财联社-产品展示&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/swarmbees/p/6044361.html&quot;&gt;Qt之自定义QLineEdit右键菜单&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/swarmbees/p/11154821.html&quot;&gt;Qt之股票组件-股票检索--支持搜索结果预览、鼠标、键盘操作&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/swarmbees/p/11027429.html&quot;&gt;高仿富途牛牛-组件化(一)-支持页签拖拽、增删、小工具&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/swarmbees/p/11042704.html&quot;&gt;高仿富途牛牛-组件化(二)-磁力吸附&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/swarmbees/p/11048378.html&quot;&gt;高仿富途牛牛-组件化(三)-界面美化&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/swarmbees/p/11055495.html&quot;&gt;高仿富途牛牛-组件化(四)-优秀的时钟&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/swarmbees/p/11062824.html&quot;&gt;高仿富途牛牛-组件化(五)-如何去管理炒鸡多的小窗口&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/swarmbees/p/11094667.html&quot;&gt;高仿富途牛牛-组件化(六)-炒鸡牛逼的布局记忆功能(序列化和反序列化)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果您觉得文章不错，不妨给个&lt;span&gt;打赏&lt;/span&gt;，写作不易，感谢各位的支持。您的支持是我最大的动力，谢谢！！！&lt;/p&gt;
&lt;center&gt;
&lt;div&gt;
&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/swarmbees/1497876/o_weixin_reward.png&quot; border=&quot;0&quot;/&gt;&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/swarmbees/1497876/o_zhifubao_reward.png&quot; border=&quot;0&quot;/&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/center&gt;

&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;很重要--转载声明&lt;/strong&gt;&lt;/p&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;本站文章无特别说明，皆为原创，版权所有，转载时请用链接的方式，给出原文出处。同时写上原作者：&lt;a href=&quot;https://www.cnblogs.com/swarmbees/&quot;&gt;朝十晚八&lt;/a&gt; or &lt;a href=&quot;https://www.jianshu.com/u/7673f8cfb4e6&quot;&gt;Twowords&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如要转载，请原文转载，如在转载时修改本文，请事先告知，谢绝在转载时通过修改本文达到有利于转载者的目的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;</description>
<pubDate>Mon, 08 Jul 2019 23:06:00 +0000</pubDate>
<dc:creator>朝十晚八</dc:creator>
<og:description>[TOC] 原文链接： 'Qt之股票组件 自选股 列表可以拖拽、右键常用菜单' 一、开头嘴一嘴 上一篇文章 'Qt之股票组件 股票检索 支持搜索结果预览、鼠标、键盘操作' 讲述了股票检索功能，这篇文章</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/swarmbees/p/11154841.html</dc:identifier>
</item>
<item>
<title>分析了16年的福利彩票记录，原来可以用Python这么买彩票 - 上海小胖</title>
<link>http://www.cnblogs.com/moonhmily/p/11155066.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/moonhmily/p/11155066.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/649191/201907/649191-20190709062749260-1588010310.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;目录&lt;br/&gt;0 引言&lt;br/&gt;1 环境&lt;br/&gt;2 需求分析&lt;br/&gt;3 代码实现&lt;br/&gt;4 后记&lt;/p&gt;

&lt;p&gt;上周被一则新闻震惊到了，《2454万元大奖无人认领！福彩史上第二大弃奖在广东中山产生 》，在2019年5月2日开奖的双色球中，广东中山一位彩民博中2454万元，兑奖时间截至2019年7月1日。&lt;/p&gt;
&lt;p&gt;令人遗憾的是，中奖者最终未现身领奖，2454万元大奖成为弃奖。经中山市福彩中心查证，这是中国福彩史上金额第二大的弃奖。根据《彩票管理条例实施细则》的有关规定，这次的2454万元弃奖奖金将被纳入彩票公益金。&lt;/p&gt;
&lt;p&gt;一直在为福彩做贡献的我，啥时候能摊上这样的好事啊。于是我用Python生成了一组双色球的号码……&lt;/p&gt;

&lt;p&gt;操作系统：Windows&lt;/p&gt;
&lt;p&gt;Python版本：3.7.3&lt;/p&gt;

&lt;p&gt;随机生成一组双色球的号码，我们可以借助random函数，如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import random

def ball():
    ball_list=[]
    while 1:
        a=random.randint(1,33)
        if a not in ball_list:
            ball_list.append(a)
        if len(ball_list)==6:
            break

    ball_list.sort()
    ball_list.append(random.randint(1,16))
    print(ball_list)


ball()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但要知道，这么搞的话，丝毫不会有什么中奖的，因为太随机了……&lt;/p&gt;
&lt;p&gt;经历过高考的人，肯定都知道三年模拟五年高考。要知道彩票中奖概率很低的，所以我们在这里先分析下历年的数据，借助往年的数据来“精准”地推算下一期中奖号码。&lt;/p&gt;
&lt;p&gt;我们通过这个网站来查询彩票的历史开奖信息。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://kaijiang.zhcw.com/zhcw/html/ssq/list_1.html&quot; class=&quot;uri&quot;&gt;http://kaijiang.zhcw.com/zhcw/html/ssq/list_1.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/649191/201907/649191-20190709062809711-750829611.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们点击下一页，看看网址链接是否有规律&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://kaijiang.zhcw.com/zhcw/html/ssq/list_1.html&quot; class=&quot;uri&quot;&gt;http://kaijiang.zhcw.com/zhcw/html/ssq/list_1.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://kaijiang.zhcw.com/zhcw/html/ssq/list_2.html&quot; class=&quot;uri&quot;&gt;http://kaijiang.zhcw.com/zhcw/html/ssq/list_2.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://kaijiang.zhcw.com/zhcw/html/ssq/list_3.html&quot; class=&quot;uri&quot;&gt;http://kaijiang.zhcw.com/zhcw/html/ssq/list_3.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://kaijiang.zhcw.com/zhcw/html/ssq/list_4.html&quot; class=&quot;uri&quot;&gt;http://kaijiang.zhcw.com/zhcw/html/ssq/list_4.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://kaijiang.zhcw.com/zhcw/html/ssq/list_5.html&quot; class=&quot;uri&quot;&gt;http://kaijiang.zhcw.com/zhcw/html/ssq/list_5.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;不难发现，可以将目标网址拆分如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;url_part = 'http://kaijiang.zhcw.com/zhcw/html/ssq/list'
url = url_part + '_' + str(i) + '.html'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而 i 对应的正好是页码信息，我们借助&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/649191/201907/649191-20190709062846566-2047635844.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;记录下这里的元素信息。&lt;/p&gt;
&lt;p&gt;接下来，我们需要抓取每一页中的具体开奖信息。我们继续通过开发者工具分析出每期开奖信息。&lt;/p&gt;
&lt;p&gt;我们依次记录下每期的开奖日期对应的元素信息：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/649191/201907/649191-20190709062857222-1623585966.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;开奖的批次对应的元素信息：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/649191/201907/649191-20190709062904828-1329905185.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;中奖号码对应的元素信息：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/649191/201907/649191-20190709062914265-1960588080.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有了这些元素信息之后，接下来就是代码的具体实现。&lt;/p&gt;

&lt;p&gt;在这里，我们获取网页的请求使用 requests 模块；解析网址借助 beautifulsoup4 模块。因为都是第三方模块，如环境中没有可以使用 pip 进行安装。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;pip install requests
pip install beautifulsoup4
pip install lxml&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;模块安装好之后，进行导入&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import requests
from bs4 import BeautifulSoup&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们需要先在首页中，拿到页数信息&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 发起请求
basic_url = 'http://kaijiang.zhcw.com/zhcw/html/ssq/list_1.html'
headers = {
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36'
}
response = requests.get(basic_url, headers=headers, timeout=10)
response.encoding = 'utf-8'
htm = response.text

# 解析内容
soup = BeautifulSoup(htm, 'html.parser')

# 获取页数信息
page = int(soup.find('p', attrs={&quot;class&quot;: &quot;pg&quot;}).find_all('strong')[0].text)


接下来，我们就可以根据规律组装好我们的URL：

url_part = 'http://kaijiang.zhcw.com/zhcw/html/ssq/list'

for i in range(1, page+1):
    url = url_part + '_' + str(i) + '.html'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;拿组装后的url发起请求，并获取每页中各期的开奖信息：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;res = requests.get(url, headers=headers, timeout=10)
res.encoding = 'utf-8'
context = res.text
soups = BeautifulSoup(context, 'html.parser')

if soups.table is None:
    continue
elif soups.table:
    table_rows = soups.table.find_all('tr')
    for row_num in range(2, len(table_rows)-1):
        row_tds = table_rows[row_num].find_all('td')
        ems = row_tds[2].find_all('em')
        result = row_tds[0].string +', '+ row_tds[1].string +', '+ems[0].string+' '+ems[1].string+' '+ems[2].string+' '+ems[3].string+' '+ems[4].string+' '+ems[5].string+', '+ems[6].string
        print(result)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样，我们就完成了对每一页中各期开奖数据的获取。获取的数据可以保存在本地。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def save_to_file(content):
    with open('ssq.txt', 'a', encoding='utf-8') as f:
        f.write(content + '\n')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们在获取每期的开奖数据的同时，记录下红蓝球出现的号码信息。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 定义两个变量, 用于记录历史开奖信息中的红球、蓝球号码信息
red_num = [] 
blue_num = []

red_num.append(ems[0].string) # 红色球1
red_num.append(ems[1].string) # 红色球2
red_num.append(ems[2].string) # 红色球3
red_num.append(ems[3].string) # 红色球4
red_num.append(ems[4].string) # 红色球5
red_num.append(ems[5].string) # 红色球6
blue_num.append(ems[6].string) # 蓝色球&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;统计出各个号码出现次数信息：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;red_count = Counter(red_num)
blue_count = Counter(blue_num)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来我们可以根据红蓝号码出现的频率进行排序，并推测出几组双色球号码信息：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 按照出现频率顺序
red_sorted = sorted(red_count.items(), key=lambda x: x[1], reverse=False)
blue_sorted = sorted(blue_count.items(), key=lambda x: x[1], reverse=False)

red = red_sorted[0:6]
blue = blue_sorted[0:3]

red = list(map(lambda x:x[0], red))
blue = list(map(lambda x:x[0], blue))

red.sort()
blue.sort()

print('号码高频-1注：'+str(red)+' | '+blue[0])
print('号码高频-2注：'+str(red)+' | '+blue[1])
print('号码高频-3注：'+str(red)+' | '+blue[2])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然了，也可以输出反序输出，中奖号码出现频率较低的几组，只需要设置 reverse=True 即可。&lt;/p&gt;

&lt;p&gt;这里根据蓝色球各号码出现的次数，作了张直方图，可以很直观到蓝色球各号码出现的频率。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/649191/201907/649191-20190709062930429-982599944.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有人会问了，这样预测出的中奖号码，中奖概率究竟有多大呢？&lt;/p&gt;
&lt;p&gt;这个，我可说不清楚，只有买了才会知道……小心错过一个亿哟！&lt;/p&gt;
&lt;p&gt;好了，以上就是本篇全部内容。&lt;/p&gt;
&lt;p&gt;关注公众号「&lt;strong&gt;Python专栏&lt;/strong&gt;」，更多有趣好玩的Python等着你～&lt;/p&gt;
&lt;p&gt;本文全套代码已上传至Github：&lt;a href=&quot;https://github.com/MiracleYoung/You-are-Pythonista/tree/master/PythonExercise/Tool/SSQ_Predict/&quot; class=&quot;uri&quot;&gt;https://github.com/MiracleYoung/You-are-Pythonista/tree/master/PythonExercise/Tool/SSQ_Predict/&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 08 Jul 2019 22:57:00 +0000</pubDate>
<dc:creator>上海小胖</dc:creator>
<og:description>有人会问了，这样预测出的中奖号码，中奖概率究竟有多大呢？ 这个，我可说不清楚，只有买了才会知道……小心错过一个亿哟！</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/moonhmily/p/11155066.html</dc:identifier>
</item>
<item>
<title>03-Spring profile实用精简版介绍 - Fion_Yang</title>
<link>http://www.cnblogs.com/fionyang/p/springinaction03-1.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fionyang/p/springinaction03-1.html</guid>
<description>&lt;p&gt;　　为什么说是实用精简版，没办法，工作太忙压力大啊，菜是原罪啊，所以接下来写的一些博客可能都是更偏实用性，精简点，方便自己回顾，快速上手使用即可，毕竟感觉不详细还有书不是吗。&lt;/p&gt;
&lt;p&gt;　　profile是用来干什么的？简单来说，就是现实需求中，不同环境下我们所要的某个bean可能会有所不同。&lt;/p&gt;
&lt;p&gt;　　1. 配置profile bean&lt;/p&gt;
&lt;p&gt;　　　　可以使用@Profile注解指定某个bean属于哪个profile。比如下雨天时我需要的工具是雨伞，所以可以如下配置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Configuration
@Profile(&lt;/span&gt;&quot;rainyday&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RainyDayConfig {
      @Bean
      &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Tool tool() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Umbrella();   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;假设Umbrella继承了Tool&lt;/span&gt;
&lt;span&gt;      }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里@Profile注解用在了类级别上，表明只有rainyday profile激活时，这个配置类中的bean才会被创建，相反，当rainyday profile没有被激活时，带有@Bean注解的方法会被忽略。同理，现在晴天时，我可能需要阳伞，可如下配置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Configuration
@Profile(&lt;/span&gt;&quot;sunnyday&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SunnyDayConfig {
      @Bean
      &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Tool tool() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Sunshade();   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;假设Sunshade继承了Tool&lt;/span&gt;
&lt;span&gt;      }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　与下雨天（rainyday）一样，上面这段配置类中使用@Bean注解的方法也只有在sunnyday profile激活时，才可以生效。&lt;/p&gt;
&lt;p&gt;　　不过这个还是有点麻烦，需要两个配置类，这是Spring 3.1中的唯一写法，但是Spring 3.2之后，就可以这样写了，如下：&lt;/p&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div readability=&quot;12.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Configuration
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ToolConfig {
      @Bean
      @Profile(&lt;/span&gt;&quot;rainyday&quot;&lt;span&gt;)
      &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Tool umbrellaTool() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Umbrella();   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;假设Umbrella继承了Tool&lt;/span&gt;
&lt;span&gt;      }
      
      @Bean
      @Profile(&lt;/span&gt;&quot;sunnyday&quot;&lt;span&gt;)
      &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Tool sunshadeTool() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Sunshade();   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;假设Sunshade继承了Tool&lt;/span&gt;
&lt;span&gt;      }

      @Bean
      &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Shoes shoes() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Shoes(); 
      }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这样是不是就方便多了，我只需要一个配置类，需要注意的是，umbrellaTool方法只会在下雨天（rainyday）profile激活时生效并创建bean，sunshadeTool方法只会在晴天（sunnyday）profile激活时生效并创建bean，而shoes方法没有指定profile，它会始终生效并创建bean。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;　　上面这些都是使用JavaConfig类方式在声明profile，其实也可在XML中配置profile bean，只需在&amp;lt;beans&amp;gt;标签中添加profile属性即可，这里不详细介绍了，可参考书。&lt;/p&gt;
&lt;p&gt;2. 激活profile&lt;/p&gt;
&lt;p&gt;　　profile是配置好了，但是怎么激活profile呢？别急，下面讲的就是这些啦😁😁。。。。&lt;/p&gt;
&lt;p&gt;　　Spring怎么知道哪个profile处于激活状态？其实要做到这点，Spring需要依赖于两个属性，一个是spring.profiles.active，另一个是spring.profiles.default。当设置了spring.profiles.active属性时，那么它的值就会用来确定哪个profile是激活的，如果没有设置，那么spring.profiles.default的值就用来确定哪个profile是激活的。那问题又来了，两个我都没设置怎么办？这种情况下，也就是没有profile处于激活状态，那么只有没被定义在profile中的bean会被创建，想想哪个shoes😁😁。。。。。目前，有多种方式可设置这两个属性，如下&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;作为DispatcherServlet的初始化参数&lt;/li&gt;
&lt;li&gt;作为web应用的上下文参数&lt;/li&gt;
&lt;li&gt;作为JNDI条目&lt;/li&gt;
&lt;li&gt;作为环境变量&lt;/li&gt;
&lt;li&gt;作为JVM的系统属性&lt;/li&gt;
&lt;li&gt;在集成测试类上使用@ActiveProfiles注解设置&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　　　这些个方法任选其一即可，比如在Web应用中，设置spring.profiles.default的web.xml如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;web-app &lt;/span&gt;&lt;span&gt;......&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
      ......
      &lt;/span&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 为上下文设置默认的profile &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;context-param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring.profiles.default&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param-value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;rainyday&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param-value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;context-param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
      ......
      
      ......
      &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;servlet&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
            ......
            &lt;/span&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 为Servlet设置默认的profile &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;init-param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring.profiles.default&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param-value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;rainyday&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param-value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;init-param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
            ......
      &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;servlet&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
      ......
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;web-app&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　或许，你有点疑问，为什么配置中使用的都是profiles而非profile，难道可以让多个profile处于激活状态？没错，就是这样，我们可以设置多个，在&amp;lt;param-value&amp;gt;中可以设置多个profile，使用逗号分隔就行，如&amp;lt;param-value&amp;gt;rainyday,sunnyday&amp;lt;/param-value&amp;gt;。。。。。&lt;/p&gt;
&lt;p&gt;　　好了这部分就到这了，写的不好，尽量参考书，但是想要快速上手使用应该可以了😁😁。。。。。。&lt;/p&gt;
</description>
<pubDate>Mon, 08 Jul 2019 16:49:00 +0000</pubDate>
<dc:creator>Fion_Yang</dc:creator>
<og:description>为什么说是实用精简版，没办法，工作太忙压力大啊，菜是原罪啊，所以接下来写的一些博客可能都是更偏实用性，精简点，方便自己回顾，快速上手使用即可，毕竟感觉不详细还有书不是吗。 profile是用来干什么的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/fionyang/p/springinaction03-1.html</dc:identifier>
</item>
<item>
<title>SQL Server温故系列(3)：SQL 子查询 &amp; 公用表表达式 CTE - 韩宗泽</title>
<link>http://www.cnblogs.com/hanzongze/p/tsql-subquery.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hanzongze/p/tsql-subquery.html</guid>
<description>&lt;h2 id=&quot;1&quot;&gt;1、子查询 Subqueries&lt;/h2&gt;
&lt;p&gt;子查询是一个嵌套在 SELECT、INSERT、UPDATE 或 DELETE 语句或其他子查询中的查询。通俗来讲，子查询就是嵌套在大“查询”中的小查询。子查询也称为内部查询或内部选择，而包含子查询的语句也称为外部查询或外部选择。&lt;/p&gt;
&lt;p&gt;从概念上说，子查询结果会代入外部查询（尽管这不一定是 SQL Server 实际处理带有子查询的 T-SQL 语句的方式）。所以子查询会在其父查询之前执行，以便可以将内部查询的结果传递给外部查询。&lt;/p&gt;
&lt;p&gt;比较常见的子查询有：单行子查询、多行子查询、相关子查询、嵌套子查询等。然而并没有一种泾渭分明的子查询分类方法，换句话说，有可能某个子查询既是多行子查询，也是相关子查询，同时还是嵌套子查询。&lt;/p&gt;
&lt;h4 id=&quot;11&quot;&gt;1.1、单行子查询&lt;/h4&gt;
&lt;p&gt;顾名思义，单行子查询就是只查询一行数据的内部查询。如果单行子查询仅返回单一值，就可以称之为&lt;strong&gt;标量子查询&lt;/strong&gt;。标量子查询也是最常见的单行子查询。示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;-- 查询年龄最小的学生
SELECT * FROM T_Students WHERE Birthday = (SELECT MAX(Birthday) FROM T_Students);

-- 第 1 次课程 1 考试的成绩高于学生 12 的成绩
SELECT StudentId,Scores FROM T_ExamResults 
WHERE Counts = 1 AND CourseId = 1 AND Scores &amp;gt; (
    SELECT Scores FROM T_ExamResults WHERE Counts = 1 AND CourseId = 1 AND StudentId = 12);

-- 历次课程 1 考试的平均分高于学生 12 的成绩
SELECT StudentId,AVG(Scores) AvgScore,COUNT(1) ExamCount FROM T_ExamResults 
WHERE CourseId = 1 
GROUP BY StudentId 
HAVING AVG(Scores) &amp;gt; (SELECT AVG(Scores) FROM T_ExamResults WHERE CourseId = 1 AND StudentId = 12);&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;12&quot;&gt;1.2、多行子查询&lt;/h4&gt;
&lt;p&gt;相较于单行子查询，多行子查询就是会返回多行的内部查询。示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;-- 查询有女生的班级里的学生
SELECT * FROM T_Students WHERE ClassId IN(SELECT ClassId FROM T_Students WHERE Gender = 0);

-- 查询有女生的班级之外的所有班级的学生
SELECT * FROM T_Students WHERE ClassId NOT IN(SELECT ClassId FROM T_Students WHERE Gender = 0);

-- 查询有 2003 年及以后出生的学生的班级
SELECT * FROM T_Classes WHERE Id IN(SELECT ClassId FROM T_Students WHERE Birthday &amp;gt;= '2003-01-01');&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;13&quot;&gt;1.3、相关子查询&lt;/h4&gt;
&lt;p&gt;相关子查询是指查询条件引用了外部查询中字段的内部查询。相反的，如果外部查询的字段没有出现在内部查询的条件中即为非相关子查询。相关子查询的内部查询得依靠外部查询获得值，这意味着内部查询是重复执行的，为外部查询选择的每一行都要执行一次，因此相关子查询也被称之为重复子查询。示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;-- 查询在三(1)班和三(2)班的学生
SELECT * FROM T_Students t1 WHERE EXISTS(
    SELECT Id FROM T_Classes t2 WHERE t2.Id = t1.ClassId AND t2.Name IN('三(1)班','三(2)班'));

-- 查询不在三(1)班和三(2)班的学生
SELECT * FROM T_Students t1 WHERE NOT EXISTS(
    SELECT Id FROM T_Classes t2 WHERE t2.Id = t1.ClassId AND t2.Name IN('三(1)班','三(2)班'));

-- 查询第 1 次考试的课程及参加了的学生
SELECT (SELECT t2.Name FROM T_Courses t2 WHERE t2.Id=t1.CourseId) CourseName,
       (SELECT t3.Name FROM T_Students t3 WHERE t3.Id=t1.StudentId) StudentName 
FROM T_ExamResults t1 WHERE t1.Counts = 1;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;14&quot;&gt;1.4、嵌套子查询&lt;/h4&gt;
&lt;p&gt;嵌套子查询是指查询内部嵌套一个或多个子查询的内部查询。一个 T-SQL 语句中可以嵌套任意数量的子查询，尽管通常来说没有这种必要。示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;-- 查询参加了第 1 次课程 1 考试的学生
SELECT * FROM T_Students t3 WHERE t3.Id IN(
    SELECT t2.StudentId FROM T_ExamResults t2 WHERE t2.Counts = 1 AND t2.CourseId = (
        SELECT t1.Id FROM T_Courses t1 WHERE t1.Name = '英语'));

-- 查询西湖区所在的城市的所有学生
SELECT t3.* FROM T_Students t3 WHERE SUBSTRING(t3.Code,2,6) IN(
    SELECT t2.Code FROM T_Districts t2 WHERE t2.ParentId = (
        SELECT t1.ParentId FROM T_Districts t1 WHERE t1.Name = '西湖区'));&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;15&quot;&gt;1.5、子查询小结及性能问题&lt;/h4&gt;
&lt;p&gt;上文主要讲述了查询语句中的子查询，其实在增删改语句中也一样能够使用子查询。任何能使用表达式的地方都可以使用子查询，只要它返回的是单个值即可。很多包含子查询的语句都可以改写成连接查询。示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;-- 更新语句（子查询写法）
UPDATE T_Students SET Remark='考过满分' 
WHERE Id IN(SELECT t.StudentId FROM T_ExamResults t WHERE t.Scores = 100);

-- 更新语句（连接写法）
UPDATE T_Students SET Remark='考过满分' 
FROM T_Students t1 JOIN T_ExamResults t2 ON t1.Id = t2.StudentId AND t2.Scores = 100;

-- 删除语句（子查询写法）
DELETE T_ExamResults WHERE Counts = 10 AND StudentId = (
    SELECT t.Id FROM T_Students t WHERE t.Code = 'S330104010');

-- 删除语句（连接写法）
DELETE T_ExamResults FROM T_ExamResults t1 
JOIN T_Students t2 ON t1.StudentId = t2.Id AND t1.Counts = 10 AND t2.Code = 'S330104010';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 T-SQL 中，包含子查询的语句和语义上等效的不包含子查询的语句在性能上通常是没有差别的。但在一些需要为外部查询的每个结果都执行内部查询的情况下，使用连接写法会产生更好的性能（如果数据很少，这种差别也很难体现出来），如某些非必须的相关子查询。示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;-- 查询所有学生第 1 次课程 2 考试的成绩（子查询写法）
SELECT (SELECT t2.Name FROM T_Students t2 WHERE t2.Id = t1.StudentId) StudentName,Scores 
FROM T_ExamResults t1 
WHERE t1.Counts = 1 AND t1.CourseId = 2;

-- 查询所有学生第 1 次课程 2 考试的成绩（连接写法）
SELECT t2.Name StudentName,Scores 
FROM T_ExamResults t1 
JOIN T_Students t2 ON t1.StudentId=t2.Id 
WHERE t1.Counts = 1 AND t1.CourseId = 2;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;2&quot;&gt;2、公用表表达式 CTE&lt;/h2&gt;
&lt;p&gt;在 T-SQL 中，WITH 语句用于指定临时命名的结果集，这些结果集被称为公用表表达式(Common Table Expression，简称 CTE)。基本语法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;WITH cte-name (column-names) AS (cte-query) [,...]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数释义如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;cte-name&lt;/strong&gt; 代表公用表表达式的有效标识符。类似于子查询的别名，在一个语句中不能出现重复的 cte-name，但可以与 CTE 引用的基表名称相同。引用 CTE 中的任何字段都得用 cte-name 来限定，而不能使用字段原本所属的基表来限定。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;column-names&lt;/strong&gt; 代表公用表表达式的字段名列表，只要 column-name 的个数与 cte-query 中定义字段数相同即可。如果为 cte-query 中的所有字段都提供了不同的名称，那么 column-names 就是可选的了（一般大家都这么干，毕竟有谁会喜欢没必要的繁琐呢？）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;cte-query&lt;/strong&gt; 代表一个公用表表达式的查询语句，可以是任意合法的 SELECT 语句。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;21&quot;&gt;2.1、普通公用表表达式&lt;/h4&gt;
&lt;p&gt;CTE 可在单条 INSERT、DELETE、UPDATE 或 SELECT 语句的执行范围内定义。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CTE &amp;amp; INSERT&lt;/strong&gt; 如要把 2000 年之前出生的女生信息插入到好学生表中，用 CTE 定义女生数据，示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;WITH temp AS(
    SELECT t.Id,t.Name,t.Gender,t.Birthday FROM T_Students t WHERE t.Gender = 0
)
INSERT INTO T_GoodStudents(Id,Name,Gender,Birthday) 
SELECT * FROM temp WHERE Birthday &amp;lt; '2000-01-01';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;CTE &amp;amp; DELETE&lt;/strong&gt; 如要把姓名和性别都是空的学生信息删除，用 CTE 定义姓名为空的数据，示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;WITH t AS(
    SELECT t.* FROM T_GoodStudents t WHERE t.Name IS NULL
)
DELETE FROM t WHERE t.Gender IS NULL;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;CTE &amp;amp; UPDATE&lt;/strong&gt; 如要把历次语文成绩的平均分更新到学生备注中，用 CTE 定义学生平均分数据，示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;WITH temp AS(
    SELECT t.StudentId,t.CourseId,AVG(t.Scores) AvgScore 
    FROM T_ExamResults t 
    GROUP BY t.StudentId,t.CourseId
)
UPDATE T_Students SET Remark = t1.AvgScore 
FROM temp t1 
JOIN T_Courses t2 ON t1.CourseId = t2.Id 
WHERE T_Students.Id = t1.StudentId AND t2.Name = '语文';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;CTE &amp;amp; SELECT&lt;/strong&gt;（多次引用同一个 CTE）如要查询前 3 次考试的总成绩及平均成绩，用 CTE 定义各次的成绩数据，示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;WITH temp AS(
    SELECT t.StudentId,t.Counts,SUM(t.Scores) SumScore 
    FROM T_ExamResults t 
    WHERE t.Counts IN(1,2,3) 
    GROUP BY t.StudentId,t.Counts
)
SELECT t1.Code,t1.Name,
    t2.SumScore FirstSumScore,t3.SumScore SecondSumScore,t4.SumScore ThirdSumScore,
    (t2.SumScore + t3.SumScore + t4.SumScore)/3 AvgSumScore 
FROM T_Students t1 
JOIN temp t2 ON t1.Id = t2.StudentId AND t2.Counts = 1 
JOIN temp t3 ON t1.Id = t3.StudentId AND t3.Counts = 2 
JOIN temp t4 ON t1.Id = t4.StudentId AND t4.Counts = 3;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;CTE &amp;amp; SELECT&lt;/strong&gt;（一个 WITH 定义多个 CTE）如要查询男生们前 3 次课程 1 的考试成绩，用 CTE 定义各次的成绩数据，示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;WITH t1 AS(
    SELECT t.StudentId,t.Scores FROM T_ExamResults t WHERE t.CourseId = 1 AND t.Counts = 1
),
t2 AS(
    SELECT t.StudentId,t.Scores FROM T_ExamResults t WHERE t.CourseId = 1 AND t.Counts = 2
),
t3 AS(
    SELECT t.StudentId,t.Scores FROM T_ExamResults t WHERE t.CourseId = 1 AND t.Counts = 3
)
SELECT t4.Code,t4.Name,t1.Scores FirstScore,t2.Scores SecondScore,t3.Scores ThirdScore 
FROM T_Students t4 
JOIN t1 ON t4.Id = t1.StudentId 
JOIN t2 ON t4.Id = t2.StudentId 
JOIN t3 ON t4.Id = t3.StudentId 
WHERE t4.Gender = 1;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;22&quot;&gt;2.2、递归公用表表达式&lt;/h4&gt;
&lt;p&gt;CTE 可以包含对自身的引用，这种表达式被称为递归公用表表达式。一个递归 CTE 中至少要包含两个查询定义，一个定位点成员和一个递归成员，递归成员的 FROM 子句只能引用一次 CTE。另外，定位点成员和递归成员二者的字段数必须相同，字段的数据类型也需要保持一致。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;从上到下递归&lt;/strong&gt;，如要查询浙江省及以下各级别的行政区，示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;WITH temp AS(
    SELECT t1.Id,t1.Name FROM T_Districts t1 WHERE t1.Code = '330000' 
    UNION ALL 
    SELECT t2.Id,t2.Name FROM T_Districts t2,temp t1 WHERE t2.ParentId = t1.Id 
)
SELECT temp.Name FROM temp;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;从下到上递归&lt;/strong&gt;，如要查询西湖区及其所有上级行政区，示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;WITH temp AS(
    SELECT t1.ParentId,t1.Name FROM T_Districts t1 WHERE t1.Code = '330106' 
    UNION ALL 
    SELECT t2.ParentId,t2.Name FROM T_Districts t2,temp t1 WHERE t2.Id = t1.ParentId 
)
SELECT temp.Name FROM temp;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以定义多个定位点成员和递归成员，但必须将所有定位点成员查询定义置于第一个递归成员定义之前。在起点成员之间可以用任意集合运算符，而在最后一个定位点成员和第一个递归成员之间，以及多个递归成员之间，必须用 UNION ALL 来连接。示例如下（查询卢小妹的所有祖先）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;WITH temp(Id) AS(
    SELECT t1.Father FROM T_Persons t1 WHERE t1.Name = '卢小妹' 
    UNION 
    SELECT t2.Mother FROM T_Persons t2 WHERE t2.Name = '卢小妹' 
    UNION ALL 
    SELECT t3.Father FROM T_Persons t3,temp WHERE t3.Id = temp.Id 
    UNION ALL 
    SELECT t4.Mother FROM T_Persons t4,temp WHERE t4.Id = temp.Id 
)
SELECT t1.Id,t1.Name,t1.Father,t1.Mother 
FROM T_Persons t1,temp 
WHERE t1.Id=temp.Id;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;递归运算一定要有出口&lt;/strong&gt;，否则就是死循环了！SQL Server 提供了一个 MAXRECURSION 提示来限制递归级数，以防止出现无限循环。但我个人觉得应该尽可能的通过 WHERE 条件或业务逻辑来定义更合理的出口。例如要显示的限定只返回某一递归级别的数据，示例如下（查询浙江省下所有县一级的行政区）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;WITH temp AS(
    SELECT t1.Id,t1.Name,t1.Code,t1.Level 
    FROM T_Districts t1 
    WHERE t1.Code = '330000' 
    UNION ALL 
    SELECT t2.Id,t2.Name,t2.Code,t2.Level 
    FROM T_Districts t2,temp 
    WHERE t2.ParentId = temp.Id
)
SELECT temp.Code,temp.Name,temp.Level FROM temp WHERE temp.Level = 3;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;尽管看上去很简单，但在实际开发中很可能并没有类似 Level 这种标识级别的字段可用。如果是这样，那我们还可以通过递归成员的递归次数来实现同样的过滤效果。示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;WITH temp AS(
    SELECT t1.Id,t1.Name,t1.Code,t1.Level,0 Step 
    FROM T_Districts t1 
    WHERE t1.Code = '330000' 
    UNION ALL 
    SELECT t2.Id,t2.Name,t2.Code,t2.Level,temp.Step + 1 
    FROM T_Districts t2,temp 
    WHERE t2.ParentId = temp.Id
)
SELECT temp.Code,temp.Name,temp.Level FROM temp WHERE temp.Step = 2;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;3&quot;&gt;3、本文小结&lt;/h2&gt;
&lt;p&gt;本文主要介绍了 T-SQL 中最常见的几种子查询以及公用表表达式 CTE。本文还专门说明了递归 CTE，它可以实现类似于 PL/SQL 中的 CONNECT BY 层次查询。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文参考链接：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6.6145251396648&quot;&gt;
&lt;p&gt;&lt;strong&gt;本文链接&lt;/strong&gt;：&lt;a href=&quot;http://www.cnblogs.com/hanzongze/p/tsql-subquery.html&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/hanzongze/p/tsql-subquery.html&lt;/a&gt;&lt;br/&gt;&lt;strong&gt;版权声明&lt;/strong&gt;：本文为博客园博主 &lt;a href=&quot;http://www.cnblogs.com/hanzongze/&quot;&gt;&lt;strong&gt;韩宗泽&lt;/strong&gt;&lt;/a&gt; 原创，作者保留署名权！欢迎通过转载、演绎或其它传播方式来使用本文，但必须在明显位置给出作者署名和本文链接！个人博客，能力有限，若有不当之处，敬请批评指正，谢谢！&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 08 Jul 2019 16:02:00 +0000</pubDate>
<dc:creator>韩宗泽</dc:creator>
<og:description>《SQL Server温故系列》之SQL 子查询，公用表表达式 CTE。子查询是一个嵌套在 SELECT、INSERT、UPDATE 或 DELETE 语句或其他子查询中的查询。通俗来讲，子查询就是嵌</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hanzongze/p/tsql-subquery.html</dc:identifier>
</item>
<item>
<title>【原创】Docker 搭建Maven私服nexus 3.17初始密码登录不上问题/admin登陆不上问题 - 码帝</title>
<link>http://www.cnblogs.com/wbl001/p/11154828.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wbl001/p/11154828.html</guid>
<description>&lt;p&gt;【原创-转载请说明出处】&lt;/p&gt;
&lt;p&gt;博主最近在虚拟机中搭建Maven私服，遇到了一个关键问题就是nexus 3.17版本后初始密码不是admin/admin123。&lt;/p&gt;
&lt;p&gt;对于nexus不熟悉的我弄了很长时间！！！心里一万头艹ma飞过！！！各种查资料度娘搜索出来的都是老版本修改密码步骤！！！，&lt;/p&gt;
&lt;p&gt;后来博主FanQian访问Chrome找答案，好在目前已解决，话不多说，记录一下。&lt;/p&gt;

&lt;p&gt;前提条件：&lt;/p&gt;
&lt;p&gt;1：虚拟机安装CentOS 7 (步骤请参照博主其他随笔)&lt;/p&gt;
&lt;p&gt;2：配置局域网ip xshell 访问（请参照博主其他随笔）&lt;/p&gt;
&lt;p&gt;3：CentOS 7 安装Docker （请自行百度，很多说明）&lt;/p&gt;

&lt;p&gt;步骤一：安装完成Docker后 下载Nexus 镜像&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下载一个&lt;/span&gt;nexus3&lt;span&gt;的镜像&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
docker pull sonatype/nexus3
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;步骤二：将容器内部/var/nexus-data挂载到主机/root/nexus-data目录&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
docker run -d -p 8081:8081 --name nexus -v /root/nexus-data:/var/nexus-data --restart=always sonatype/nexus3
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;步骤三：查看是否下载成功&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1697935/201907/1697935-20190708231914559-1470873224.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;步骤四：查询容器信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
docker inspect nexus
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1697935/201907/1697935-20190708232123489-889922229.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 如果出现以下信息说明启动成功&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1697935/201907/1697935-20190708232324800-1684453817.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;步骤五：这时候访问地址端口之前设置的是8081&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1697935/201907/1697935-20190708232455211-2722599.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;步骤六：右上角登录admin账户 发现之前说的默认密码admin/admin123登录不上了！！！！！！！！！&lt;/p&gt;
&lt;p&gt;各种查询资料才知道3.17版本密码改成随即的了，而且登录时候提示密码在/nexus-data/admin.password里&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1697935/201907/1697935-20190708232745481-1831655643.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;步骤七：然后搜索服务器上admin.password文件在哪&lt;/p&gt;
&lt;p&gt;因为是docker安装的所以要从docker进入容器里边&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
#查询容器id
docker ps

#进入容器里面
docker exec -it 容器id bash
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;步骤八：找到admin.password文件，默认位置在&lt;/p&gt;
&lt;p&gt;/opt/sonatype/sonatype-work/sonatype-work/admin.password&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1697935/201907/1697935-20190708233447559-1363949102.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;步骤九：查看密码&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
vi admin.password
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1697935/201907/1697935-20190708233415295-859023067.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;注意：登录密码就是这么一大长传的字符串！！！，这不是加密的，当初以为这是加密的，还各种找资料要解密&lt;/p&gt;

&lt;p&gt;步骤十：复制密码直接登录nexus，登录成功！！！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1697935/201907/1697935-20190708233706721-1725380649.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;步骤十一：首次登录成功会提示你设置 密码&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1697935/201907/1697935-20190708234858962-1901724573.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;记录下docker常用命令&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
1.查看是否下载成功
docker ps
2.docker inspect 容器id 查询容器信息
docker inspect dd1f28238dff
3.docker stop 容器id 停止容器id
4.docker rm 容器id 删除容器id
5.docker exct it 容器id/容器名 bash   (进去容器内部)
6.Exit退出
7.docker stop nexus  #停止nexus
8.docker start nexus #启动nexus 启动时间大约1分钟
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;&lt;span&gt;好了，成功了！如果本文对你有帮助请推荐一下，谢谢。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 08 Jul 2019 15:41:00 +0000</pubDate>
<dc:creator>码帝</dc:creator>
<og:description>【原创-转载请说明出处】 博主最近在虚拟机中搭建Maven私服，遇到了一个关键问题就是nexus 3.17版本后初始密码不是admin/admin123。 对于nexus不熟悉的我弄了很长时间！！！心</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wbl001/p/11154828.html</dc:identifier>
</item>
<item>
<title>Qt之股票组件-股票检索--支持搜索结果预览、鼠标、键盘操作 - 朝十晚八</title>
<link>http://www.cnblogs.com/swarmbees/p/11154821.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/swarmbees/p/11154821.html</guid>
<description>&lt;p&gt;&lt;strong&gt;原文链接：&lt;/strong&gt;&lt;a href=&quot;https://www.cnblogs.com/swarmbees/p/11154821.html&quot;&gt;Qt之股票组件-股票检索--支持搜索结果预览、鼠标、键盘操作&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;一感慨一下&quot;&gt;一、感慨一下&lt;/h2&gt;
&lt;p&gt;之前做过一款炒股软件，个人觉着是我职业生涯里做过的效果最好的一款产品，而且速度也不慢，效果可以参考&lt;a href=&quot;https://www.cnblogs.com/swarmbees/p/6707798.html&quot;&gt;财联社-产品展示&lt;/a&gt;这篇文章，当然这篇文章只能显示有限的内容，其中整个代码的结构、一些好的方法和设计模式是没有机会展示的。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;最近听到一个不好的消息，我们的产品夭折了。刚听到这个消息时心理还挺不是滋味的，毕竟这个产品我是从头参与到尾，后来因为种种原因离开了，产品功能也就此终结，但回想起那段开发的日子，真的是收获满满。更确切的说，这个产品应该是换了一种语言重新开始做。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;不爽归不爽，可整个产品的代码还是不错的，因此&lt;/strong&gt; 后续有时间我会慢慢的把一些好的代码抽离出来，编译成一个个可以单独运行的demo，方便有需要的朋友使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果有需要的朋友可以加我好友，有偿提供源码、或者也可以进一步提供功能定制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;封装的控件，或者demo都是没有样式的，所以看着会比较丑一些，不过加样式也是分分钟。。。这里咱可以先看功能，需要即可定制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本篇文章我们首先介绍的就是股票，该控件支持常用的股票检索功能，支持模糊匹配，键盘上下键切换当前检索项等&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;右键菜单包括复制、粘贴、剪贴、全选等&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;本篇文章中不包括的功能也可以提供定制，需求合理即可。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面来具体说一说这个功能的实现思路，会公开大多数核心代码，有需要的同学可以根据思路自行完善整个代码。&lt;/p&gt;
&lt;h2 id=&quot;二效果展示&quot;&gt;二、效果展示&lt;/h2&gt;
&lt;p&gt;如下效果图所示，是自选股使用上的一个展示效果，具有如下功能&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;搜索编辑框，支持股票代码和股票名称搜索&lt;/li&gt;
&lt;li&gt;搜索预览框支持鼠标hover，并且可以使用键盘上下键进行当前项切换，单机时支持切换自选股&lt;/li&gt;
&lt;li&gt;自选股列表，支持拖拽，拖拽时会有拖拽项映像，并示意将要拖拽到哪个位置&lt;/li&gt;
&lt;li&gt;支持右键菜单，可以对某一项进行移动，删除等操作&lt;/li&gt;
&lt;/ol&gt;&lt;center&gt;
&lt;div&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/swarmbees/1498827/o_option_stock.gif&quot;/&gt;&lt;/div&gt;
&lt;/center&gt;
&lt;p&gt;如果觉着demo比较丑的话，可以看&lt;a href=&quot;https://www.cnblogs.com/swarmbees/p/6707798.html&quot;&gt;财联社-产品展示&lt;/a&gt;这篇文章中的效果图&lt;/p&gt;
&lt;h2 id=&quot;三搜索编辑框&quot;&gt;三、搜索编辑框&lt;/h2&gt;
&lt;p&gt;首先出场的是搜索编辑框，如gif图中展示所示，搜索框支持预览数据，当我们输入了字符串后，就会出现过滤后的预览数据。这里由于我们的股票数据是我自己模拟的，因此只显示了5条数据。&lt;/p&gt;
&lt;p&gt;实现搜索编辑框，有2个小的模块需要讲解，一个是编辑框本身，它用于输入文本的能力，并且支持复制、粘贴等交互操作；另一个就是预览框了，他会动态的展示当前搜索的内容。&lt;/p&gt;
&lt;h3 id=&quot;编辑框&quot;&gt;1、编辑框&lt;/h3&gt;
&lt;p&gt;Qt已经帮我们实现了一种编辑框，但是他自带了很多菜单项，如果产品这个时候说，菜单项我需要自己定制，多余的项不要。那么我们是不是得重写这个控件呢？&lt;strong&gt;答案是肯定的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面我们就来讲解这个控件的重写步骤&lt;/p&gt;
&lt;p&gt;重写一个Qt控件还是很简单的，使用Qt超过半年的同学都会重写大量各种各样的控件，而我们的编辑框重写就会像下面这样，是一个简单的头文件展示&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;///***********************************///
/// 描述：自定义编辑框，重写鼠标右键事件
///***********************************///
class SearchEdit : public QLineEdit
{
public:
    SearchEdit(QWidget * parent = nullptr);
    ~SearchEdit(){}

protected:
    virtual void contextMenuEvent(QContextMenuEvent * event) override;

private:
    void InitMenu();

private:
    QMenu * m_PopMenu = nullptr;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我们主要是针对右键菜单进行了重写，Qt窗体实现右键菜单的方式多种多样，具体可以参考我很早以前写的&lt;a href=&quot;https://www.cnblogs.com/swarmbees/p/6044361.html&quot;&gt;Qt之自定义QLineEdit右键菜单&lt;/a&gt;这篇文章，今天我们也使用其中的一种方式来实现右键菜单，那就是实现默认的contextMenuEvent函数，这个函数之所以会响应，也是有一定条件的，&lt;a href=&quot;https://www.cnblogs.com/swarmbees/p/6044361.html&quot;&gt;Qt之自定义QLineEdit右键菜单&lt;/a&gt;这篇文章中讲解的也很清楚，那就是contextMenuPolicy的值必须为默认的Qt::DefaultContextMenu属性。&lt;/p&gt;
&lt;p&gt;至于菜单重写实现函数，这里就不展示了，就是比较常规的使用QMenu增加QAction的操作&lt;/p&gt;
&lt;h3 id=&quot;预览框&quot;&gt;2、预览框&lt;/h3&gt;
&lt;p&gt;大家仔细想一想，预览框是什么时候出现的？他显示的数据有什么样的特征？接下来我们来一一做以分析&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;首先是出现时机&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;预览框主要是展示我们模糊搜索后的股票数据，那么结论就很明显了。预览的出现时机就是搜索内容发现变化的时候，并且当编辑框失去焦点时，我们应该主动关闭预览框&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;编辑框内容发现变化时，显示预览框&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;connect(d_ptr-&amp;gt;m_pSearchLineEdit, &amp;amp;QLineEdit::textChanged, this, &amp;amp;SelfStocksWidget::TextChanged);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;处理预览框数据，主要是使用了FilterModel来进行过滤所有股票后选项，注意我们过滤的条件就是搜索框中输入的内容&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void SelfStocksWidget::TextChanged(const QString &amp;amp; text)
{
    if (d_ptr-&amp;gt;m_pFilterModel)
    {
        d_ptr-&amp;gt;m_pFilterModel-&amp;gt;SetFilterContext(text);
    }
    if (d_ptr-&amp;gt;m_pStockPreviewWidget)
    {
        if (text.isEmpty())
        {
            d_ptr-&amp;gt;m_pStockPreviewWidget-&amp;gt;hide();
            d_ptr-&amp;gt;m_pPreviewError-&amp;gt;hide();
            d_ptr-&amp;gt;m_pCloseButton-&amp;gt;setIcon(QIcon());
        }
        else
        {
            d_ptr-&amp;gt;m_pCloseButton-&amp;gt;setIcon(QIcon(&quot;:/optional/Resources/optional/sotck_search_close_normal.png&quot;));
            d_ptr-&amp;gt;m_pStockPreviewWidget-&amp;gt;move(d_ptr-&amp;gt;m_pTitleWidget-&amp;gt;mapToGlobal(QPoint(0, d_ptr-&amp;gt;m_pTitleWidget-&amp;gt;height())));
            int rowHeight = d_ptr-&amp;gt;m_pStockPreview-&amp;gt;rowHeight(0);
            int rowCount = d_ptr-&amp;gt;m_pFilterModel-&amp;gt;rowCount();

            ...
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;当编辑框失去焦点时，关闭预览框&lt;/strong&gt;&lt;br/&gt;这里我们取了一个巧，接收了该App的原生Win32消息，当我们发现一些影响窗口焦点的事件被触发时，我们去判断是否需要关闭预览框。&lt;/p&gt;
&lt;p&gt;具体可以参考我很早之前写的&lt;a href=&quot;https://www.cnblogs.com/swarmbees/p/5632765.html&quot;&gt;qt捕获全局windows消息&lt;/a&gt;这篇文章&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;bool SelfStocksWidget::nativeEventFilter(const QByteArray &amp;amp; eventType, void * message, long * result)
{
    if (eventType == &quot;windows_generic_MSG&quot; || eventType == &quot;windows_dispatcher_MSG&quot;)
    {
        MSG * pMsg = reinterpret_cast&amp;lt;MSG *&amp;gt;(message);

        if (pMsg-&amp;gt;message == WM_MOVE)
        {
            NativeParentWindowMove();
        }
        else if (pMsg-&amp;gt;message == WM_ACTIVATEAPP)
        {
            if (bool(pMsg-&amp;gt;wParam) == false)
            {
                if (!d_ptr-&amp;gt;m_pStockPreviewWidget-&amp;gt;rect().contains(d_ptr-&amp;gt;m_pStockPreview-&amp;gt;mapFromGlobal(QPoint(pMsg-&amp;gt;pt.x, pMsg-&amp;gt;pt.y))))
                {
                    d_ptr-&amp;gt;m_pStockPreviewWidget-&amp;gt;hide();
                }
                if (!d_ptr-&amp;gt;m_pPreviewError-&amp;gt;rect().contains(d_ptr-&amp;gt;m_pPreviewError-&amp;gt;mapFromGlobal(QPoint(pMsg-&amp;gt;pt.x, pMsg-&amp;gt;pt.y))))
                {
                    d_ptr-&amp;gt;m_pPreviewError-&amp;gt;hide();
                }
            }
        }
        else if (pMsg-&amp;gt;message == WM_NCMBUTTONDOWN
            || pMsg-&amp;gt;message == WM_LBUTTONDOWN
            || pMsg-&amp;gt;message == WM_RBUTTONDOWN
            || pMsg-&amp;gt;message == WM_NCLBUTTONDOWN
            || pMsg-&amp;gt;message == WM_NCRBUTTONDOWN
            || pMsg-&amp;gt;message == WM_MBUTTONDOWN)
        {
            同上...
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面就是一个比较负责预览数据环节了，几千只股票，要准、要快，我们应该怎么技术选型呢？&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;预览框到底怎么显示数据的？他显示的都是哪些数据？&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Qt提供了QListView、QTableView和QTreeView这3种视图模式，然后搭配Mode数据源，可以完成高效的大量数据展示，得知这个内容后是不是还有些小兴奋呢！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;乍一看，QListView和QTableView都可以作为我们的预览框窗口，毕竟每一个Item项都是可以去重新定制的，看起来QListView还是更简单一些，而且速度也会更快一些，但是仔细想想，好像不是这么回事，我们既然要支持股票代码和名称都进行搜索，那么自然不是一列数据就可以进行过滤的，方便起见我们还是使用QTableView作为我们的视图窗口&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;既然视图窗口选定了，接下来就是一堆的事件定制了&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;a、重写QTableView&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;重写QTableView时，我们得考虑一个很重要的事情，那就是鼠标hover事件了，鼠标移动时我们需要把当前行设置为鼠标hover状态，为了实现这个效果，我可谓是费劲脑汁，想出了一个办法，写了一个IView接口类，让QTableView去继承，当鼠标hover时，去调用这个接口类告知QTableView当前hover项。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class IView
{
public:
    virtual void SetMouseHover(int, bool forceChanged = false) = 0;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上边的代码是不是看着很简单呢，就一个接口，就是当鼠标hover时告知表格当前hover项，那么什么实际通知合适呢？我这里是重写了QStyledItemDelegate绘图代理类，在paint函数中通知表格的，其他同学有好的办法也可以留言。&lt;/p&gt;
&lt;p&gt;预览框的头文件大致是下面这样的，这里我只把公有的接口放出来了，其他的一些私有接口和成员变量没有公开(放出来估计大家也不看)&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;///***********************************///
/// 描述：搜索预览框
///***********************************///
class StockTableView : public QTableView, public IView
{
    Q_OBJECT

signals :
    void RowClicked(const QString &amp;amp; code);
    void RowDbClicked(const QString &amp;amp; code);

public:
    StockTableView(QStandardItemModel * model, QWidget * parent = 0);

public:
    void SetMouseHover(int, bool forceChanged = false);
    void SetMouseChecked(int);
    void SetDbClickedEnable(bool enable);

    void SetHoverColor(const QColor &amp;amp; color);
    void SetCheckedColor(const QColor &amp;amp; color);

    void CheckedMoveUp();
    void CheckedMoveDown();
    void EnterPressed();

protected:
    ...
private:
    ...
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码中的接口都比较好理解，看名字应该都知道是干嘛的，这里就不做过多解释。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;b、表格初始化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;表格的数据内容在m_pListModel中存放，但是表格直接接收数据的是m_pFilterModel对象。&lt;/p&gt;
&lt;p&gt;m_pFilterModel对象可以理解为是一个映像数据源，他没有真正的去存储数据，他的数据都是来自m_pListModel类。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//初始化搜索个股列表
d_ptr-&amp;gt;m_pStockPreview = new StockTableView(d_ptr-&amp;gt;m_pListModel);
d_ptr-&amp;gt;m_pFilterModel = new StockSortFilterProxyModel;

d_ptr-&amp;gt;m_pPreviewError-&amp;gt;setAlignment(Qt::AlignLeft | Qt::AlignVCenter);
d_ptr-&amp;gt;m_pPreviewError-&amp;gt;setText(QStringLiteral(&quot;未搜索到相关股票&quot;));

d_ptr-&amp;gt;m_pStockPreview-&amp;gt;horizontalHeader()-&amp;gt;setVisible(false);
d_ptr-&amp;gt;m_pStockPreview-&amp;gt;verticalHeader()-&amp;gt;setVisible(false);
d_ptr-&amp;gt;m_pStockPreview-&amp;gt;setShowGrid(false);
d_ptr-&amp;gt;m_pStockPreview-&amp;gt;horizontalHeader()-&amp;gt;setStretchLastSection(true);
d_ptr-&amp;gt;m_pStockPreview-&amp;gt;setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);

d_ptr-&amp;gt;m_pStockPreview-&amp;gt;setMouseTracking(true);

previewLayout-&amp;gt;addWidget(d_ptr-&amp;gt;m_pStockPreview);
d_ptr-&amp;gt;m_pStockPreviewWidget-&amp;gt;setLayout(previewLayout);

StockItemDelegate * itemDelegate = new StockItemDelegate(d_ptr-&amp;gt;m_pStockPreview);
d_ptr-&amp;gt;m_pStockPreview-&amp;gt;setItemDelegate(itemDelegate);
itemDelegate-&amp;gt;setView(d_ptr-&amp;gt;m_pStockPreview);

d_ptr-&amp;gt;m_pPreviewError-&amp;gt;setWindowFlags(Qt::WindowStaysOnTopHint | Qt::Tool | Qt::FramelessWindowHint);
d_ptr-&amp;gt;m_pStockPreviewWidget-&amp;gt;setWindowFlags(Qt::WindowStaysOnTopHint | Qt::Tool | Qt::FramelessWindowHint);

d_ptr-&amp;gt;m_pFilterModel-&amp;gt;setSourceModel(d_ptr-&amp;gt;m_pListModel);
d_ptr-&amp;gt;m_pStockPreview-&amp;gt;setModel(d_ptr-&amp;gt;m_pFilterModel);
d_ptr-&amp;gt;m_pStockPreview-&amp;gt;setColumnHidden(2, true);
d_ptr-&amp;gt;m_pStockPreview-&amp;gt;setSortingEnabled(true);

d_ptr-&amp;gt;m_pPreviewError-&amp;gt;setFixedSize(DropWidgetMaxWidth, 26);
d_ptr-&amp;gt;m_pStockPreviewWidget-&amp;gt;setFixedWidth(DropWidgetMaxWidth);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;c、表格填充数据&lt;/strong&gt;&lt;br/&gt;正常来说数据应该是网络上拉取的，但是这里作为测试，我直接添加了5行模拟数据&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void SelfStocksWidget::InitiAStock()
{
    std::vector&amp;lt;BaseStockInfoItem&amp;gt; sotckLists;
    
    BaseStockInfoItem item;
    for (int i = 1; i &amp;lt;= 5; ++i)
    {
        item.wstrSymbol = QString(&quot;0h000%1&quot;).arg(i).toStdWString();
        item.wstrName = QString(&quot;%1%1%1&quot;).arg(i).toStdWString();
        item.wstrSymbol = QString(&quot;pingyin%1&quot;).arg(i).toStdWString();
        sotckLists.push_back(item);
    }

    for each (BaseStockInfoItem stock in sotckLists)
    {
        QList&amp;lt;QStandardItem *&amp;gt; rows;
        QStandardItem * symbol = new QStandardItem(QString::fromStdWString(stock.wstrSymbol).toUpper());
        symbol-&amp;gt;setData(QColor(28, 30, 34), Qt::BackgroundRole);
        symbol-&amp;gt;setData(QColor(204, 204, 204), Qt::ForegroundRole);
        symbol-&amp;gt;setSelectable(false);
        rows &amp;lt;&amp;lt; symbol;

        QStandardItem * name = new QStandardItem(QString::fromStdWString(stock.wstrName));
        name-&amp;gt;setData(QColor(28, 30, 34), Qt::BackgroundRole);
        name-&amp;gt;setData(QColor(204, 204, 204), Qt::ForegroundRole);
        name-&amp;gt;setSelectable(false);
        rows &amp;lt;&amp;lt; name;

        QStandardItem * pinyin = new QStandardItem(QString::fromStdWString(stock.wstrShortPinYin));
        pinyin-&amp;gt;setData(QColor(28, 30, 34), Qt::BackgroundRole);
        pinyin-&amp;gt;setData(QColor(204, 204, 204), Qt::ForegroundRole);
        pinyin-&amp;gt;setSelectable(false);
        rows &amp;lt;&amp;lt; pinyin;

        //QStandardItem * type = new QStandardItem(QString::number(stock.m_stockType));
        //type-&amp;gt;setData(QColor(28, 30, 34), Qt::BackgroundRole);
        //type-&amp;gt;setData(QColor(204, 204, 204), Qt::ForegroundRole);
        //type-&amp;gt;setSelectable(false);
        //rows &amp;lt;&amp;lt; type;

        d_ptr-&amp;gt;m_pListModel-&amp;gt;appendRow(rows);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最终的数据被填充到了m_pListModel数据源中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;d、键盘操作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;文章开始的地方也说过了，我们的搜索预览框是支持键盘上下键来切换当前股票的，这个又是怎么完成的呢！&lt;/p&gt;
&lt;p&gt;预览框显示时，编辑框一直处于鼠标输入状态，并且具有键盘有限处理权限。&lt;/p&gt;
&lt;p&gt;因此里我们是取了个巧，把编辑框的事件挂载在了他的父窗体上，当键盘按下时，父窗口拿到键盘按下事件，首先转发给了预览框，让预览框去换一个最新的当前股票，并选中。&lt;/p&gt;
&lt;p&gt;代码如下所示，是不是也很简单。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;bool SelfStocksWidget::eventFilter(QObject * watched, QEvent * event)
{
    if (d_ptr-&amp;gt;m_pSearchLineEdit == watched)
    {
        if (event-&amp;gt;type() == QEvent::KeyPress)
        {
            if (QKeyEvent * keyEvent = static_cast&amp;lt;QKeyEvent *&amp;gt;(event))
            {
                switch (keyEvent-&amp;gt;key())
                {
                case Qt::Key_Up:
                    d_ptr-&amp;gt;m_pStockPreview-&amp;gt;CheckedMoveUp();
                    break;
                case Qt::Key_Down:
                    d_ptr-&amp;gt;m_pStockPreview-&amp;gt;CheckedMoveDown();
                    break;
                case Qt::Key_Enter:
                case Qt::Key_Return:
                    d_ptr-&amp;gt;m_pStockPreview-&amp;gt;EnterPressed();
                    break;
                default:
                    break;
                }
            }
        }
    }
    return __super::eventFilter(watched, event);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;e、过滤&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;前边也讲述过了，我们表格数据都是来自m_pFilterModel对象的，数据源中的数据m_pListModel基本没有发生变化过，及时我们现实的内容变化了，那也仅仅是m_pFilterModel对象过滤到的内容发生了变化。&lt;/p&gt;
&lt;p&gt;过滤接口Qt已经帮我们写好了，我们只需要实现其中的过滤方式即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;bool StockSortFilterProxyModel::filterAcceptsRow(int source_row
                                              , const QModelIndex &amp;amp; source_parent) const
{
    QRegExp regExp = filterRegExp();

    if (regExp.isEmpty())
    {
        return true;
    }

    bool result = false;
    for (int i = 0; i &amp;lt; sortColumn; ++i)
    {
        QModelIndex index = sourceModel()-&amp;gt;index(source_row, i, source_parent);
        QString context = sourceModel()-&amp;gt;data(index).toString();

        QString regExpStr = regExp.pattern();
        result = regExp.exactMatch(context);

        if (result)
        {
            break;
        }
    }

    return result;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上就是搜索股票编辑框的大致内容了，至于一些细微的设置，大家自行去完善即可。&lt;/p&gt;
&lt;p&gt;比如说预览框的窗口属性应该是这样的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;setWindowFlags(Qt::WindowStaysOnTopHint | Qt::Tool | Qt::FramelessWindowHint);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;未输入任务内容时，编辑框的holderText应该是这样的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;setPlaceholderText(QStringLiteral(&quot;搜索股票代码/名称&quot;));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;由于篇幅原因，本篇文章就只先说搜索编辑框吧，本来想把自选股列表页一起加上，不过觉着内容太多，也不利于大家吸收，下一篇文章补上吧。。。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;写的手都酸了，其他内容自行脑补吧。。。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;四相关文章&quot;&gt;四、相关文章&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/swarmbees/p/6707798.html&quot;&gt;财联社-产品展示&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/swarmbees/p/6044361.html&quot;&gt;Qt之自定义QLineEdit右键菜单&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/swarmbees/p/5632765.html&quot;&gt;qt捕获全局windows消息&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/swarmbees/p/11027429.html&quot;&gt;高仿富途牛牛-组件化(一)-支持页签拖拽、增删、小工具&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/swarmbees/p/11042704.html&quot;&gt;高仿富途牛牛-组件化(二)-磁力吸附&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/swarmbees/p/11048378.html&quot;&gt;高仿富途牛牛-组件化(三)-界面美化&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/swarmbees/p/11055495.html&quot;&gt;高仿富途牛牛-组件化(四)-优秀的时钟&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/swarmbees/p/11062824.html&quot;&gt;高仿富途牛牛-组件化(五)-如何去管理炒鸡多的小窗口&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/swarmbees/p/11094667.html&quot;&gt;高仿富途牛牛-组件化(六)-炒鸡牛逼的布局记忆功能(序列化和反序列化)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;如果您觉得文章不错，不妨给个&lt;span&gt;打赏&lt;/span&gt;，写作不易，感谢各位的支持。您的支持是我最大的动力，谢谢！！！&lt;br/&gt;&lt;/p&gt;
&lt;br/&gt;&lt;center&gt;&lt;br/&gt;&lt;div&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/swarmbees/1497876/o_weixin_reward.png&quot; border=&quot;0&quot;/&gt;&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/swarmbees/1497876/o_zhifubao_reward.png&quot; border=&quot;0&quot;/&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;&lt;br/&gt;&lt;/div&gt;
&lt;br/&gt;&lt;/center&gt;
&lt;br/&gt;&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;很重要--转载声明&lt;/strong&gt;&lt;/p&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;本站文章无特别说明，皆为原创，版权所有，转载时请用链接的方式，给出原文出处。同时写上原作者：&lt;a href=&quot;https://www.cnblogs.com/swarmbees/&quot;&gt;朝十晚八&lt;/a&gt; or &lt;a href=&quot;https://www.jianshu.com/u/7673f8cfb4e6&quot;&gt;Twowords&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如要转载，请原文转载，如在转载时修改本文，请事先告知，谢绝在转载时通过修改本文达到有利于转载者的目的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;</description>
<pubDate>Mon, 08 Jul 2019 15:40:00 +0000</pubDate>
<dc:creator>朝十晚八</dc:creator>
<og:description>[TOC] 原文链接： 'Qt之股票组件 股票检索 支持搜索结果预览、鼠标、键盘操作' 一、感慨一下 之前做过一款炒股软件，个人觉着是我职业生涯里做过的效果最好的一款产品，而且速度也不慢，效果可以参考</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/swarmbees/p/11154821.html</dc:identifier>
</item>
</channel>
</rss>