<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>RocketMQ中Broker的启动源码分析（一） - 松饼人</title>
<link>http://www.cnblogs.com/a526583280/p/11297099.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/a526583280/p/11297099.html</guid>
<description>&lt;p&gt;在RocketMQ中，使用BrokerStartup作为启动类，相较于NameServer的启动，Broker作为RocketMQ的核心可复杂得多&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/a526583280/p/11291564.html&quot; target=&quot;_blank&quot;&gt;【RocketMQ中NameServer的启动源码分析】&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;主函数作为其启动的入口：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    start(createBrokerController(args));
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;首先通过createBrokerController方法生成Broker的控制器BrokerController&lt;/p&gt;
&lt;p&gt;createBrokerController方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;73&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; BrokerController createBrokerController(String[] args) {
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;    System.setProperty(RemotingCommand.REMOTING_VERSION_KEY, Integer.toString(MQVersion.CURRENT_VERSION));
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt; 
&lt;span&gt;  4&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;null&lt;/span&gt; ==&lt;span&gt; System.getProperty(NettySystemConfig.COM_ROCKETMQ_REMOTING_SOCKET_SNDBUF_SIZE)) {
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt;         NettySystemConfig.socketSndbufSize = 131072&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; 
&lt;span&gt;  8&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;null&lt;/span&gt; ==&lt;span&gt; System.getProperty(NettySystemConfig.COM_ROCKETMQ_REMOTING_SOCKET_RCVBUF_SIZE)) {
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt;         NettySystemConfig.socketRcvbufSize = 131072&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt; 
&lt;span&gt; 12&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;PackageConflictDetect.detectFastjson();&lt;/span&gt;
&lt;span&gt; 14&lt;/span&gt;         Options options = ServerUtil.buildCommandlineOptions(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Options());
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt;         commandLine = ServerUtil.parseCmdLine(&quot;mqbroker&quot;&lt;span&gt;, args, buildCommandlineOptions(options),
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt;             &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PosixParser());
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;null&lt;/span&gt; ==&lt;span&gt; commandLine) {
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt;             System.exit(-1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; 
&lt;span&gt; 21&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt; BrokerConfig brokerConfig = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BrokerConfig();
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt; NettyServerConfig nettyServerConfig = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NettyServerConfig();
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt; NettyClientConfig nettyClientConfig = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NettyClientConfig();
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt; 
&lt;span&gt; 25&lt;/span&gt; &lt;span&gt;        nettyClientConfig.setUseTLS(Boolean.parseBoolean(System.getProperty(TLS_ENABLE,
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt;             String.valueOf(TlsSystemConfig.tlsMode ==&lt;span&gt; TlsMode.ENFORCING))));
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt;         nettyServerConfig.setListenPort(10911&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt; MessageStoreConfig messageStoreConfig = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MessageStoreConfig();
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt; 
&lt;span&gt; 30&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (BrokerRole.SLAVE ==&lt;span&gt; messageStoreConfig.getBrokerRole()) {
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; ratio = messageStoreConfig.getAccessMessageInMemoryMaxRatio() - 10&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt; &lt;span&gt;            messageStoreConfig.setAccessMessageInMemoryMaxRatio(ratio);
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt; 
&lt;span&gt; 35&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (commandLine.hasOption('c'&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt;             String file = commandLine.getOptionValue('c'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (file != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;                 configFile =&lt;span&gt; file;
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt;                 InputStream in = &lt;span&gt;new&lt;/span&gt; BufferedInputStream(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileInputStream(file));
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt;                 properties = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Properties();
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt; &lt;span&gt;                properties.load(in);
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt; 
&lt;span&gt; 43&lt;/span&gt; &lt;span&gt;                properties2SystemEnv(properties);
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt; &lt;span&gt;                MixAll.properties2Object(properties, brokerConfig);
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt; &lt;span&gt;                MixAll.properties2Object(properties, nettyServerConfig);
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt; &lt;span&gt;                MixAll.properties2Object(properties, nettyClientConfig);
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt; &lt;span&gt;                MixAll.properties2Object(properties, messageStoreConfig);
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt; 
&lt;span&gt; 49&lt;/span&gt; &lt;span&gt;                BrokerPathConfigHelper.setBrokerConfigPath(file);
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt; &lt;span&gt;                in.close();
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt; 
&lt;span&gt; 54&lt;/span&gt; &lt;span&gt;        MixAll.properties2Object(ServerUtil.commandLine2Properties(commandLine), brokerConfig);
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt; 
&lt;span&gt; 56&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;null&lt;/span&gt; ==&lt;span&gt; brokerConfig.getRocketmqHome()) {
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt;             System.out.printf(&quot;Please set the %s variable in your environment to match the location of the RocketMQ installation&quot;&lt;span&gt;, MixAll.ROCKETMQ_HOME_ENV);
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt;             System.exit(-2&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt; 
&lt;span&gt; 61&lt;/span&gt;         String namesrvAddr =&lt;span&gt; brokerConfig.getNamesrvAddr();
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;null&lt;/span&gt; !=&lt;span&gt; namesrvAddr) {
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt;                 String[] addrArray = namesrvAddr.split(&quot;;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (String addr : addrArray) {
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt; &lt;span&gt;                    RemotingUtil.string2SocketAddress(addr);
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;             } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt; &lt;span&gt;                System.out.printf(
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt;                     &quot;The Name Server Address[%s] illegal, please set it as follows, \&quot;127.0.0.1:9876;192.168.0.1:9876\&quot;%n&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt; &lt;span&gt;                    namesrvAddr);
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt;                 System.exit(-3&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt; 
&lt;span&gt; 76&lt;/span&gt;         &lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (messageStoreConfig.getBrokerRole()) {
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt;             &lt;span&gt;case&lt;/span&gt;&lt;span&gt; ASYNC_MASTER:
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt;             &lt;span&gt;case&lt;/span&gt;&lt;span&gt; SYNC_MASTER:
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt; &lt;span&gt;                brokerConfig.setBrokerId(MixAll.MASTER_ID);
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt;             &lt;span&gt;case&lt;/span&gt;&lt;span&gt; SLAVE:
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (brokerConfig.getBrokerId() &amp;lt;= 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt;                     System.out.printf(&quot;Slave's brokerId must be &amp;gt; 0&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt;                     System.exit(-3&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt; 
&lt;span&gt; 87&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt;             &lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt; 
&lt;span&gt; 92&lt;/span&gt;         messageStoreConfig.setHaListenPort(nettyServerConfig.getListenPort() + 1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt;         LoggerContext lc =&lt;span&gt; (LoggerContext) LoggerFactory.getILoggerFactory();
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt;         JoranConfigurator configurator = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JoranConfigurator();
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt; &lt;span&gt;        configurator.setContext(lc);
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt; &lt;span&gt;        lc.reset();
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt;         configurator.doConfigure(brokerConfig.getRocketmqHome() + &quot;/conf/logback_broker.xml&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt; 
&lt;span&gt; 99&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (commandLine.hasOption('p'&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;             InternalLogger console =&lt;span&gt; InternalLoggerFactory.getLogger(LoggerName.BROKER_CONSOLE_NAME);
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt; &lt;span&gt;            MixAll.printObjectProperties(console, brokerConfig);
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt; &lt;span&gt;            MixAll.printObjectProperties(console, nettyServerConfig);
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt; &lt;span&gt;            MixAll.printObjectProperties(console, nettyClientConfig);
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt; &lt;span&gt;            MixAll.printObjectProperties(console, messageStoreConfig);
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt;             System.exit(0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (commandLine.hasOption('m'&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt;             InternalLogger console =&lt;span&gt; InternalLoggerFactory.getLogger(LoggerName.BROKER_CONSOLE_NAME);
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt;             MixAll.printObjectProperties(console, brokerConfig, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt;             MixAll.printObjectProperties(console, nettyServerConfig, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt;             MixAll.printObjectProperties(console, nettyClientConfig, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;             MixAll.printObjectProperties(console, messageStoreConfig, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt;             System.exit(0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt; 
&lt;span&gt;115&lt;/span&gt;         log =&lt;span&gt; InternalLoggerFactory.getLogger(LoggerName.BROKER_LOGGER_NAME);
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt; &lt;span&gt;        MixAll.printObjectProperties(log, brokerConfig);
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt; &lt;span&gt;        MixAll.printObjectProperties(log, nettyServerConfig);
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt; &lt;span&gt;        MixAll.printObjectProperties(log, nettyClientConfig);
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt; &lt;span&gt;        MixAll.printObjectProperties(log, messageStoreConfig);
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt; 
&lt;span&gt;121&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt; BrokerController controller = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BrokerController(
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt; &lt;span&gt;            brokerConfig,
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt; &lt;span&gt;            nettyServerConfig,
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt; &lt;span&gt;            nettyClientConfig,
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt; &lt;span&gt;            messageStoreConfig);
&lt;/span&gt;&lt;span&gt;126&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; remember all configs to prevent discard&lt;/span&gt;
&lt;span&gt;127&lt;/span&gt; &lt;span&gt;        controller.getConfiguration().registerConfig(properties);
&lt;/span&gt;&lt;span&gt;128&lt;/span&gt; 
&lt;span&gt;129&lt;/span&gt;         &lt;span&gt;boolean&lt;/span&gt; initResult =&lt;span&gt; controller.initialize();
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;initResult) {
&lt;/span&gt;&lt;span&gt;131&lt;/span&gt; &lt;span&gt;            controller.shutdown();
&lt;/span&gt;&lt;span&gt;132&lt;/span&gt;             System.exit(-3&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;134&lt;/span&gt; 
&lt;span&gt;135&lt;/span&gt;         Runtime.getRuntime().addShutdownHook(&lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
&lt;/span&gt;&lt;span&gt;136&lt;/span&gt;             &lt;span&gt;private&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; hasShutdown = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;137&lt;/span&gt;             &lt;span&gt;private&lt;/span&gt; AtomicInteger shutdownTimes = &lt;span&gt;new&lt;/span&gt; AtomicInteger(0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;138&lt;/span&gt; 
&lt;span&gt;139&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt;140&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt;141&lt;/span&gt;                 &lt;span&gt;synchronized&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;142&lt;/span&gt;                     log.info(&quot;Shutdown hook was invoked, {}&quot;, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.shutdownTimes.incrementAndGet());
&lt;/span&gt;&lt;span&gt;143&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.hasShutdown) {
&lt;/span&gt;&lt;span&gt;144&lt;/span&gt;                         &lt;span&gt;this&lt;/span&gt;.hasShutdown = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;145&lt;/span&gt;                         &lt;span&gt;long&lt;/span&gt; beginTime =&lt;span&gt; System.currentTimeMillis();
&lt;/span&gt;&lt;span&gt;146&lt;/span&gt; &lt;span&gt;                        controller.shutdown();
&lt;/span&gt;&lt;span&gt;147&lt;/span&gt;                         &lt;span&gt;long&lt;/span&gt; consumingTimeTotal = System.currentTimeMillis() -&lt;span&gt; beginTime;
&lt;/span&gt;&lt;span&gt;148&lt;/span&gt;                         log.info(&quot;Shutdown hook over, consuming total time(ms): {}&quot;&lt;span&gt;, consumingTimeTotal);
&lt;/span&gt;&lt;span&gt;149&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;150&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;151&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;152&lt;/span&gt;         }, &quot;ShutdownHook&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;153&lt;/span&gt; 
&lt;span&gt;154&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; controller;
&lt;/span&gt;&lt;span&gt;155&lt;/span&gt;     } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable e) {
&lt;/span&gt;&lt;span&gt;156&lt;/span&gt; &lt;span&gt;        e.printStackTrace();
&lt;/span&gt;&lt;span&gt;157&lt;/span&gt;         System.exit(-1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;158&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;159&lt;/span&gt; 
&lt;span&gt;160&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;161&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里和NameServer中的createNamesrvController方法作用类似，对Broker所需做了一系列的配置&lt;/p&gt;
&lt;p&gt;先设置了Netty通信时的缓冲区大小，这里默认是128K&lt;/p&gt;
&lt;p&gt;接着会创建了几个实体类&lt;br/&gt;BrokerConfig，用来封装其绝大多数基本配置信息&lt;br/&gt;NettyServerConfig，封装了其作为对外暴露的消息队列服务器的信息&lt;br/&gt;NettyClientConfig，则封装了其作为NameServer客户端的信息&lt;br/&gt;这里面封装的信息和NameServer一个道理，都是映射了配置文件相应的配置&lt;/p&gt;
&lt;p&gt;然后对NettyClientConfig的TLS进行设置&lt;br/&gt;让NettyServerConfig默认监听10911端口&lt;/p&gt;
&lt;p&gt;紧接着创建了一个MessageStoreConfig，这个就是用来封装Store的信息，&lt;/p&gt;
&lt;p&gt;MessageStoreConfig会默认配置BrokerRole为ASYNC_MASTER&lt;br/&gt;Broker有三种身份，用BrokerRole枚举来表示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; BrokerRole {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    ASYNC_MASTER,
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    SYNC_MASTER,
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;    SLAVE;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也就是异步Master，同步Master，以及Slave&lt;/p&gt;
&lt;p&gt;这里会对其身份进行检查，若是Slave，则需要调整其允许的消息最大内存占比，默认值是40，也就是说Master允许消息最大内存占用40%，而Slave则只允许30%&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;接着会对”-c“指令进行相应配置的加载&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;往后看到对namesrvAddr进行了检查，只是简单地检查NameServer集群地址信息是否合法&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;往下看到有个switch块，其根据Broker的身份，进行设置&lt;br/&gt;只要是Master，将其BrokerId设为0，而Slave的BrokerId需要大于0&lt;br/&gt;（一个Master可以对应多个Slave，但是一个Slave只能对应一个Master，Master与Slave的对应关系通过指定相同的BrokerName，不同的BrokerId来定义，BrokerId为0表示Master，大于0表示Slave，Master也可以部署多个）&lt;/p&gt;
&lt;p&gt;继续往下，这里会对Store设置HA的监听端口，是NettyServer侦听端口加1&lt;/p&gt;
&lt;p&gt;往下是对“-p”，”-m“指令进行相应配置的加载，以及日志的相关配置&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;之后就会创建了一个BrokerController：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; BrokerController(
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt;&lt;span&gt; BrokerConfig brokerConfig,
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt;&lt;span&gt; NettyServerConfig nettyServerConfig,
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt;&lt;span&gt; NettyClientConfig nettyClientConfig,
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt;&lt;span&gt; MessageStoreConfig messageStoreConfig
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    ) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.brokerConfig =&lt;span&gt; brokerConfig;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.nettyServerConfig =&lt;span&gt; nettyServerConfig;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.nettyClientConfig =&lt;span&gt; nettyClientConfig;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.messageStoreConfig =&lt;span&gt; messageStoreConfig;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.consumerOffsetManager = &lt;span&gt;new&lt;/span&gt; ConsumerOffsetManager(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.topicConfigManager = &lt;span&gt;new&lt;/span&gt; TopicConfigManager(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.pullMessageProcessor = &lt;span&gt;new&lt;/span&gt; PullMessageProcessor(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.pullRequestHoldService = &lt;span&gt;new&lt;/span&gt; PullRequestHoldService(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.messageArrivingListener = &lt;span&gt;new&lt;/span&gt; NotifyMessageArrivingListener(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.pullRequestHoldService);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.consumerIdsChangeListener = &lt;span&gt;new&lt;/span&gt; DefaultConsumerIdsChangeListener(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.consumerManager = &lt;span&gt;new&lt;/span&gt; ConsumerManager(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.consumerIdsChangeListener);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.consumerFilterManager = &lt;span&gt;new&lt;/span&gt; ConsumerFilterManager(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.producerManager = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ProducerManager();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.clientHousekeepingService = &lt;span&gt;new&lt;/span&gt; ClientHousekeepingService(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.broker2Client = &lt;span&gt;new&lt;/span&gt; Broker2Client(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.subscriptionGroupManager = &lt;span&gt;new&lt;/span&gt; SubscriptionGroupManager(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.brokerOuterAPI = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BrokerOuterAPI(nettyClientConfig);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.filterServerManager = &lt;span&gt;new&lt;/span&gt; FilterServerManager(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.slaveSynchronize = &lt;span&gt;new&lt;/span&gt; SlaveSynchronize(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.sendThreadPoolQueue = &lt;span&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;Runnable&amp;gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.brokerConfig.getSendThreadPoolQueueCapacity());
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.pullThreadPoolQueue = &lt;span&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;Runnable&amp;gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.brokerConfig.getPullThreadPoolQueueCapacity());
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.queryThreadPoolQueue = &lt;span&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;Runnable&amp;gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.brokerConfig.getQueryThreadPoolQueueCapacity());
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.clientManagerThreadPoolQueue = &lt;span&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;Runnable&amp;gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.brokerConfig.getClientManagerThreadPoolQueueCapacity());
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.consumerManagerThreadPoolQueue = &lt;span&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;Runnable&amp;gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.brokerConfig.getConsumerManagerThreadPoolQueueCapacity());
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.heartbeatThreadPoolQueue = &lt;span&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;Runnable&amp;gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.brokerConfig.getHeartbeatThreadPoolQueueCapacity());
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.endTransactionThreadPoolQueue = &lt;span&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;Runnable&amp;gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.brokerConfig.getEndTransactionPoolQueueCapacity());
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.brokerStatsManager = &lt;span&gt;new&lt;/span&gt; BrokerStatsManager(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.brokerConfig.getBrokerClusterName());
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.setStoreHost(&lt;span&gt;new&lt;/span&gt; InetSocketAddress(&lt;span&gt;this&lt;/span&gt;.getBrokerConfig().getBrokerIP1(), &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getNettyServerConfig().getListenPort()));
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; 
&lt;span&gt;39&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.brokerFastFailure = &lt;span&gt;new&lt;/span&gt; BrokerFastFailure(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.configuration = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Configuration(
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;        log,
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;        BrokerPathConfigHelper.getBrokerConfigPath(),
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.brokerConfig, &lt;span&gt;this&lt;/span&gt;.nettyServerConfig, &lt;span&gt;this&lt;/span&gt;.nettyClientConfig, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.messageStoreConfig
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;    );
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到，这里实例化了许多成员，我就不一一分析，挑几个重要的介绍&lt;/p&gt;

&lt;p&gt;ConsumerOffsetManager：用来管理消费者的消费消息的进度，主要通过一张map来缓存&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; ConcurrentMap&amp;lt;String&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; topic@group &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;, ConcurrentMap&amp;lt;Integer, Long&amp;gt;&amp;gt; offsetTable =
&lt;span&gt;2&lt;/span&gt;         &lt;span&gt;new&lt;/span&gt; ConcurrentHashMap&amp;lt;String, ConcurrentMap&amp;lt;Integer, Long&amp;gt;&amp;gt;(512);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由topic@group的形式构成键，而值中的map的Integer代表具体的哪条消息队列，Long表示该消息队列的偏移量offset&lt;/p&gt;

&lt;p&gt;TopicConfigManager：管理Topic和消息队列的信息，主要通过一张map来缓存&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ConcurrentMap&amp;lt;String, TopicConfig&amp;gt; topicConfigTable =
&lt;span&gt;2&lt;/span&gt;         &lt;span&gt;new&lt;/span&gt; ConcurrentHashMap&amp;lt;String, TopicConfig&amp;gt;(1024&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; DataVersion dataVersion = &lt;span&gt;new&lt;/span&gt; DataVersion();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;键就是Topic，值TopicConfig用来记录对应的消息队列的个数&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;PullMessageProcessor、PullRequestHoldService、NotifyMessageArrivingListener这三个来管理Pull消息请求，关于Pull消息在后续博客再细说&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;ConsumerManager：管理Consumer，主要通过一张map来缓存&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ConcurrentMap&amp;lt;String&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Group &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;, ConsumerGroupInfo&amp;gt; consumerTable =
&lt;span&gt;2&lt;/span&gt;         &lt;span&gt;new&lt;/span&gt; ConcurrentHashMap&amp;lt;String, ConsumerGroupInfo&amp;gt;(1024);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;键值就是Consumer的GroupName，&lt;br/&gt;而ConsumerGroupInfo由如下构成：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ConcurrentMap&amp;lt;String&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Topic &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;, SubscriptionData&amp;gt; subscriptionTable =
&lt;span&gt;2&lt;/span&gt;         &lt;span&gt;new&lt;/span&gt; ConcurrentHashMap&amp;lt;String, SubscriptionData&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ConcurrentMap&amp;lt;Channel, ClientChannelInfo&amp;gt; channelInfoTable =
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ConcurrentHashMap&amp;lt;Channel, ClientChannelInfo&amp;gt;(16&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt;&lt;span&gt; ConsumeType consumeType;
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; MessageModel messageModel;        
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到封装了一个subscriptionTable ，这个map记录Topic和订阅内容&lt;br/&gt;以及一个channelInfoTable，记录Consumer的物理连接&lt;br/&gt;ConsumeType是一个枚举，表明两种消费方式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; ConsumeType {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     CONSUME_ACTIVELY(&quot;PULL&quot;&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     CONSUME_PASSIVELY(&quot;PUSH&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;MessageModel 也是一个枚举，表明两种消费模式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; MessageModel {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;     * broadcast
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     BROADCASTING(&quot;BROADCASTING&quot;&lt;span&gt;),
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;     * clustering
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     CLUSTERING(&quot;CLUSTERING&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Broadcasting：同一个ConsumerGroup里的每个Consumer都能消费到所订阅Topic的全部消息，也就是一个消息会被多次分发，被多个Consumer消费&lt;br/&gt;Clustering：同一个ConsumerGroup里的每个Consumer只消费所订阅消息的一部分内容，同一个ConsumerGroup里所有的Consumer消费的内容合起来才是所订阅Topic内容的整体，从而达到负载均衡的目的&lt;/p&gt;
&lt;p&gt;结合着来看，也就是说使用相同GroupName的一组Consumer，其ConsumeType和MessageModel必定相同，其订阅的Topic会根据ConsumeType和MessageModel来完成相应的方式的消息处理&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;回到BrokerController的构造&lt;/p&gt;
&lt;p&gt;ProducerManager：管理Producer，主要通过一张map来缓存&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; HashMap&amp;lt;String &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; group name &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;, HashMap&amp;lt;Channel, ClientChannelInfo&amp;gt;&amp;gt; groupChannelTable =
&lt;span&gt;2&lt;/span&gt;         &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;String, HashMap&amp;lt;Channel, ClientChannelInfo&amp;gt;&amp;gt;();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;相比ConsumerManager，对Producer的管理简单的多，只需要记录group name 和物理连接的映射&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;再回到createBrokerController方法，在完成BrokerController的创建后，会调用BrokerController的initialize方法：&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;BrokerController的initialize方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;121&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; initialize() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; CloneNotSupportedException {
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt;     &lt;span&gt;boolean&lt;/span&gt; result = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.topicConfigManager.load();
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt; 
&lt;span&gt;  4&lt;/span&gt;     result = result &amp;amp;&amp;amp; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.consumerOffsetManager.load();
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt;     result = result &amp;amp;&amp;amp; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.subscriptionGroupManager.load();
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt;     result = result &amp;amp;&amp;amp; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.consumerFilterManager.load();
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; 
&lt;span&gt;  8&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (result) {
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.messageStore =
&lt;span&gt; 11&lt;/span&gt;                 &lt;span&gt;new&lt;/span&gt; DefaultMessageStore(&lt;span&gt;this&lt;/span&gt;.messageStoreConfig, &lt;span&gt;this&lt;/span&gt;.brokerStatsManager, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.messageArrivingListener,
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt;                     &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.brokerConfig);
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (messageStoreConfig.isEnableDLegerCommitLog()) {
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt;                 DLedgerRoleChangeHandler roleChangeHandler = &lt;span&gt;new&lt;/span&gt; DLedgerRoleChangeHandler(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, (DefaultMessageStore) messageStore);
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt; &lt;span&gt;                ((DLedgerCommitLog)((DefaultMessageStore) messageStore).getCommitLog()).getdLedgerServer().getdLedgerLeaderElector().addRoleChangeHandler(roleChangeHandler);
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.brokerStats = &lt;span&gt;new&lt;/span&gt; BrokerStats((DefaultMessageStore) &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.messageStore);
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;load plugin&lt;/span&gt;
&lt;span&gt; 19&lt;/span&gt;             MessageStorePluginContext context = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MessageStorePluginContext(messageStoreConfig, brokerStatsManager, messageArrivingListener, brokerConfig);
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.messageStore = MessageStoreFactory.build(context, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.messageStore);
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.messageStore.getDispatcherList().addFirst(&lt;span&gt;new&lt;/span&gt; CommitLogDispatcherCalcBitMap(&lt;span&gt;this&lt;/span&gt;.brokerConfig, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.consumerFilterManager));
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt;             result = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt;             log.error(&quot;Failed to initialize&quot;&lt;span&gt;, e);
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt; 
&lt;span&gt; 28&lt;/span&gt;     result = result &amp;amp;&amp;amp; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.messageStore.load();
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt; 
&lt;span&gt; 30&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (result) {
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.remotingServer = &lt;span&gt;new&lt;/span&gt; NettyRemotingServer(&lt;span&gt;this&lt;/span&gt;.nettyServerConfig, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.clientHousekeepingService);
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt;         NettyServerConfig fastConfig = (NettyServerConfig) &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.nettyServerConfig.clone();
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt;         fastConfig.setListenPort(nettyServerConfig.getListenPort() - 2&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.fastRemotingServer = &lt;span&gt;new&lt;/span&gt; NettyRemotingServer(fastConfig, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.clientHousekeepingService);
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.sendMessageExecutor = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BrokerFixedThreadPoolExecutor(
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.brokerConfig.getSendMessageThreadPoolNums(),
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.brokerConfig.getSendMessageThreadPoolNums(),
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;             1000 * 60&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt; &lt;span&gt;            TimeUnit.MILLISECONDS,
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.sendThreadPoolQueue,
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt;             &lt;span&gt;new&lt;/span&gt; ThreadFactoryImpl(&quot;SendMessageThread_&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt; 
&lt;span&gt; 43&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.pullMessageExecutor = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BrokerFixedThreadPoolExecutor(
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.brokerConfig.getPullMessageThreadPoolNums(),
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.brokerConfig.getPullMessageThreadPoolNums(),
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt;             1000 * 60&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt; &lt;span&gt;            TimeUnit.MILLISECONDS,
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.pullThreadPoolQueue,
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt;             &lt;span&gt;new&lt;/span&gt; ThreadFactoryImpl(&quot;PullMessageThread_&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt; 
&lt;span&gt; 51&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.queryMessageExecutor = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BrokerFixedThreadPoolExecutor(
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.brokerConfig.getQueryMessageThreadPoolNums(),
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.brokerConfig.getQueryMessageThreadPoolNums(),
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt;             1000 * 60&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt; &lt;span&gt;            TimeUnit.MILLISECONDS,
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.queryThreadPoolQueue,
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt;             &lt;span&gt;new&lt;/span&gt; ThreadFactoryImpl(&quot;QueryMessageThread_&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt; 
&lt;span&gt; 59&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.adminBrokerExecutor =
&lt;span&gt; 60&lt;/span&gt;             Executors.newFixedThreadPool(&lt;span&gt;this&lt;/span&gt;.brokerConfig.getAdminBrokerThreadPoolNums(), &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadFactoryImpl(
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt;                 &quot;AdminBrokerThread_&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt; 
&lt;span&gt; 63&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.clientManageExecutor = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadPoolExecutor(
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.brokerConfig.getClientManageThreadPoolNums(),
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.brokerConfig.getClientManageThreadPoolNums(),
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt;             1000 * 60&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt; &lt;span&gt;            TimeUnit.MILLISECONDS,
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.clientManagerThreadPoolQueue,
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt;             &lt;span&gt;new&lt;/span&gt; ThreadFactoryImpl(&quot;ClientManageThread_&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt; 
&lt;span&gt; 71&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.heartbeatExecutor = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BrokerFixedThreadPoolExecutor(
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.brokerConfig.getHeartbeatThreadPoolNums(),
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.brokerConfig.getHeartbeatThreadPoolNums(),
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt;             1000 * 60&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt; &lt;span&gt;            TimeUnit.MILLISECONDS,
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.heartbeatThreadPoolQueue,
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt;             &lt;span&gt;new&lt;/span&gt; ThreadFactoryImpl(&quot;HeartbeatThread_&quot;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt; 
&lt;span&gt; 79&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.endTransactionExecutor = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BrokerFixedThreadPoolExecutor(
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.brokerConfig.getEndTransactionThreadPoolNums(),
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.brokerConfig.getEndTransactionThreadPoolNums(),
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt;             1000 * 60&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt; &lt;span&gt;            TimeUnit.MILLISECONDS,
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.endTransactionThreadPoolQueue,
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt;             &lt;span&gt;new&lt;/span&gt; ThreadFactoryImpl(&quot;EndTransactionThread_&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt; 
&lt;span&gt; 87&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.consumerManageExecutor =
&lt;span&gt; 88&lt;/span&gt;             Executors.newFixedThreadPool(&lt;span&gt;this&lt;/span&gt;.brokerConfig.getConsumerManageThreadPoolNums(), &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadFactoryImpl(
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt;                 &quot;ConsumerManageThread_&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt; 
&lt;span&gt; 91&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.registerProcessor();
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt; 
&lt;span&gt; 93&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; initialDelay = UtilAll.computNextMorningTimeMillis() -&lt;span&gt; System.currentTimeMillis();
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; period = 1000 * 60 * 60 * 24&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.scheduledExecutorService.scheduleAtFixedRate(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt;                 &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;                     BrokerController.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getBrokerStats().record();
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;                 } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable e) {
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt;                     log.error(&quot;schedule record error.&quot;&lt;span&gt;, e);
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt; &lt;span&gt;        }, initialDelay, period, TimeUnit.MILLISECONDS);
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt; 
&lt;span&gt;106&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.scheduledExecutorService.scheduleAtFixedRate(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt;                 &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt;                     BrokerController.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.consumerOffsetManager.persist();
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;                 } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable e) {
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt;                     log.error(&quot;schedule persist consumerOffset error.&quot;&lt;span&gt;, e);
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt;         }, 1000 * 10, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.brokerConfig.getFlushConsumerOffsetInterval(), TimeUnit.MILLISECONDS);
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt; 
&lt;span&gt;117&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.scheduledExecutorService.scheduleAtFixedRate(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt;                 &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt;                     BrokerController.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.consumerFilterManager.persist();
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt;                 } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable e) {
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;                     log.error(&quot;schedule persist consumer filter error.&quot;&lt;span&gt;, e);
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;126&lt;/span&gt;         }, 1000 * 10, 1000 * 10&lt;span&gt;, TimeUnit.MILLISECONDS);
&lt;/span&gt;&lt;span&gt;127&lt;/span&gt; 
&lt;span&gt;128&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.scheduledExecutorService.scheduleAtFixedRate(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
&lt;/span&gt;&lt;span&gt;129&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt;131&lt;/span&gt;                 &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;132&lt;/span&gt;                     BrokerController.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.protectBroker();
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt;                 } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable e) {
&lt;/span&gt;&lt;span&gt;134&lt;/span&gt;                     log.error(&quot;protectBroker error.&quot;&lt;span&gt;, e);
&lt;/span&gt;&lt;span&gt;135&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;136&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;137&lt;/span&gt;         }, 3, 3&lt;span&gt;, TimeUnit.MINUTES);
&lt;/span&gt;&lt;span&gt;138&lt;/span&gt; 
&lt;span&gt;139&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.scheduledExecutorService.scheduleAtFixedRate(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
&lt;/span&gt;&lt;span&gt;140&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt;141&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt;142&lt;/span&gt;                 &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;143&lt;/span&gt;                     BrokerController.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.printWaterMark();
&lt;/span&gt;&lt;span&gt;144&lt;/span&gt;                 } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable e) {
&lt;/span&gt;&lt;span&gt;145&lt;/span&gt;                     log.error(&quot;printWaterMark error.&quot;&lt;span&gt;, e);
&lt;/span&gt;&lt;span&gt;146&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;147&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;148&lt;/span&gt;         }, 10, 1&lt;span&gt;, TimeUnit.SECONDS);
&lt;/span&gt;&lt;span&gt;149&lt;/span&gt; 
&lt;span&gt;150&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.scheduledExecutorService.scheduleAtFixedRate(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
&lt;/span&gt;&lt;span&gt;151&lt;/span&gt; 
&lt;span&gt;152&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt;153&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt;154&lt;/span&gt;                 &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;155&lt;/span&gt;                     log.info(&quot;dispatch behind commit log {} bytes&quot;, BrokerController.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getMessageStore().dispatchBehindBytes());
&lt;/span&gt;&lt;span&gt;156&lt;/span&gt;                 } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable e) {
&lt;/span&gt;&lt;span&gt;157&lt;/span&gt;                     log.error(&quot;schedule dispatchBehindBytes error.&quot;&lt;span&gt;, e);
&lt;/span&gt;&lt;span&gt;158&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;159&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;160&lt;/span&gt;         }, 1000 * 10, 1000 * 60&lt;span&gt;, TimeUnit.MILLISECONDS);
&lt;/span&gt;&lt;span&gt;161&lt;/span&gt; 
&lt;span&gt;162&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.brokerConfig.getNamesrvAddr() != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;163&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.brokerOuterAPI.updateNameServerAddressList(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.brokerConfig.getNamesrvAddr());
&lt;/span&gt;&lt;span&gt;164&lt;/span&gt;             log.info(&quot;Set user specified name server address: {}&quot;, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.brokerConfig.getNamesrvAddr());
&lt;/span&gt;&lt;span&gt;165&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.brokerConfig.isFetchNamesrvAddrByAddressServer()) {
&lt;/span&gt;&lt;span&gt;166&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.scheduledExecutorService.scheduleAtFixedRate(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
&lt;/span&gt;&lt;span&gt;167&lt;/span&gt; 
&lt;span&gt;168&lt;/span&gt; &lt;span&gt;                @Override
&lt;/span&gt;&lt;span&gt;169&lt;/span&gt;                 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt;170&lt;/span&gt;                     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;171&lt;/span&gt;                         BrokerController.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.brokerOuterAPI.fetchNameServerAddr();
&lt;/span&gt;&lt;span&gt;172&lt;/span&gt;                     } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable e) {
&lt;/span&gt;&lt;span&gt;173&lt;/span&gt;                         log.error(&quot;ScheduledTask fetchNameServerAddr exception&quot;&lt;span&gt;, e);
&lt;/span&gt;&lt;span&gt;174&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;175&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;176&lt;/span&gt;             }, 1000 * 10, 1000 * 60 * 2&lt;span&gt;, TimeUnit.MILLISECONDS);
&lt;/span&gt;&lt;span&gt;177&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;178&lt;/span&gt; 
&lt;span&gt;179&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;messageStoreConfig.isEnableDLegerCommitLog()) {
&lt;/span&gt;&lt;span&gt;180&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (BrokerRole.SLAVE == &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.messageStoreConfig.getBrokerRole()) {
&lt;/span&gt;&lt;span&gt;181&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.messageStoreConfig.getHaMasterAddress() != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; &lt;span&gt;this&lt;/span&gt;.messageStoreConfig.getHaMasterAddress().length() &amp;gt;= 6&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;182&lt;/span&gt;                     &lt;span&gt;this&lt;/span&gt;.messageStore.updateHaMasterAddress(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.messageStoreConfig.getHaMasterAddress());
&lt;/span&gt;&lt;span&gt;183&lt;/span&gt;                     &lt;span&gt;this&lt;/span&gt;.updateMasterHAServerAddrPeriodically = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;184&lt;/span&gt;                 } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;185&lt;/span&gt;                     &lt;span&gt;this&lt;/span&gt;.updateMasterHAServerAddrPeriodically = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;186&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;187&lt;/span&gt;             } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;188&lt;/span&gt;                 &lt;span&gt;this&lt;/span&gt;.scheduledExecutorService.scheduleAtFixedRate(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
&lt;/span&gt;&lt;span&gt;189&lt;/span&gt; &lt;span&gt;                    @Override
&lt;/span&gt;&lt;span&gt;190&lt;/span&gt;                     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt;191&lt;/span&gt;                         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;192&lt;/span&gt;                             BrokerController.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.printMasterAndSlaveDiff();
&lt;/span&gt;&lt;span&gt;193&lt;/span&gt;                         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable e) {
&lt;/span&gt;&lt;span&gt;194&lt;/span&gt;                             log.error(&quot;schedule printMasterAndSlaveDiff error.&quot;&lt;span&gt;, e);
&lt;/span&gt;&lt;span&gt;195&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;196&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;197&lt;/span&gt;                 }, 1000 * 10, 1000 * 60&lt;span&gt;, TimeUnit.MILLISECONDS);
&lt;/span&gt;&lt;span&gt;198&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;199&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;200&lt;/span&gt; 
&lt;span&gt;201&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (TlsSystemConfig.tlsMode !=&lt;span&gt; TlsMode.DISABLED) {
&lt;/span&gt;&lt;span&gt;202&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Register a listener to reload SslContext&lt;/span&gt;
&lt;span&gt;203&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;204&lt;/span&gt;                 fileWatchService = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileWatchService(
&lt;/span&gt;&lt;span&gt;205&lt;/span&gt;                     &lt;span&gt;new&lt;/span&gt;&lt;span&gt; String[] {
&lt;/span&gt;&lt;span&gt;206&lt;/span&gt; &lt;span&gt;                        TlsSystemConfig.tlsServerCertPath,
&lt;/span&gt;&lt;span&gt;207&lt;/span&gt; &lt;span&gt;                        TlsSystemConfig.tlsServerKeyPath,
&lt;/span&gt;&lt;span&gt;208&lt;/span&gt; &lt;span&gt;                        TlsSystemConfig.tlsServerTrustCertPath
&lt;/span&gt;&lt;span&gt;209&lt;/span&gt; &lt;span&gt;                    },
&lt;/span&gt;&lt;span&gt;210&lt;/span&gt;                     &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileWatchService.Listener() {
&lt;/span&gt;&lt;span&gt;211&lt;/span&gt;                         &lt;span&gt;boolean&lt;/span&gt; certChanged, keyChanged = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;212&lt;/span&gt; 
&lt;span&gt;213&lt;/span&gt; &lt;span&gt;                        @Override
&lt;/span&gt;&lt;span&gt;214&lt;/span&gt;                         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onChanged(String path) {
&lt;/span&gt;&lt;span&gt;215&lt;/span&gt;                             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (path.equals(TlsSystemConfig.tlsServerTrustCertPath)) {
&lt;/span&gt;&lt;span&gt;216&lt;/span&gt;                                 log.info(&quot;The trust certificate changed, reload the ssl context&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;217&lt;/span&gt; &lt;span&gt;                                reloadServerSslContext();
&lt;/span&gt;&lt;span&gt;218&lt;/span&gt; &lt;span&gt;                            }
&lt;/span&gt;&lt;span&gt;219&lt;/span&gt;                             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (path.equals(TlsSystemConfig.tlsServerCertPath)) {
&lt;/span&gt;&lt;span&gt;220&lt;/span&gt;                                 certChanged = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;221&lt;/span&gt; &lt;span&gt;                            }
&lt;/span&gt;&lt;span&gt;222&lt;/span&gt;                             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (path.equals(TlsSystemConfig.tlsServerKeyPath)) {
&lt;/span&gt;&lt;span&gt;223&lt;/span&gt;                                 keyChanged = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;224&lt;/span&gt; &lt;span&gt;                            }
&lt;/span&gt;&lt;span&gt;225&lt;/span&gt;                             &lt;span&gt;if&lt;/span&gt; (certChanged &amp;amp;&amp;amp;&lt;span&gt; keyChanged) {
&lt;/span&gt;&lt;span&gt;226&lt;/span&gt;                                 log.info(&quot;The certificate and private key changed, reload the ssl context&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;227&lt;/span&gt;                                 certChanged = keyChanged = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;228&lt;/span&gt; &lt;span&gt;                                reloadServerSslContext();
&lt;/span&gt;&lt;span&gt;229&lt;/span&gt; &lt;span&gt;                            }
&lt;/span&gt;&lt;span&gt;230&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;231&lt;/span&gt; 
&lt;span&gt;232&lt;/span&gt;                         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; reloadServerSslContext() {
&lt;/span&gt;&lt;span&gt;233&lt;/span&gt; &lt;span&gt;                            ((NettyRemotingServer) remotingServer).loadSslContext();
&lt;/span&gt;&lt;span&gt;234&lt;/span&gt; &lt;span&gt;                            ((NettyRemotingServer) fastRemotingServer).loadSslContext();
&lt;/span&gt;&lt;span&gt;235&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;236&lt;/span&gt; &lt;span&gt;                    });
&lt;/span&gt;&lt;span&gt;237&lt;/span&gt;             } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt;238&lt;/span&gt;                 log.warn(&quot;FileWatchService created error, can't load the certificate dynamically&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;239&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;240&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;241&lt;/span&gt; &lt;span&gt;        initialTransaction();
&lt;/span&gt;&lt;span&gt;242&lt;/span&gt; &lt;span&gt;        initialAcl();
&lt;/span&gt;&lt;span&gt;243&lt;/span&gt; &lt;span&gt;        initialRpcHooks();
&lt;/span&gt;&lt;span&gt;244&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;245&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
&lt;/span&gt;&lt;span&gt;246&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;首先完成对.../store/config/topics.json、.../store/config/consumerOffset.json、&lt;br/&gt;.../store/config/subscriptionGroup.json、.../store/config/consumerFilter.json这几个文件的加载&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;接着创建一个DefaultMessageStore，这是Broker的核心存储&lt;/p&gt;
&lt;p&gt;DefaultMessageStore的构造：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ConcurrentMap&amp;lt;String&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; topic &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;, ConcurrentMap&amp;lt;Integer&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; queueId &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;, ConsumeQueue&amp;gt;&amp;gt;&lt;span&gt; consumeQueueTable;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;......
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; DefaultMessageStore(&lt;span&gt;final&lt;/span&gt; MessageStoreConfig messageStoreConfig, &lt;span&gt;final&lt;/span&gt;&lt;span&gt; BrokerStatsManager brokerStatsManager,
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt; MessageArrivingListener messageArrivingListener, &lt;span&gt;final&lt;/span&gt; BrokerConfig brokerConfig) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.messageArrivingListener =&lt;span&gt; messageArrivingListener;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.brokerConfig =&lt;span&gt; brokerConfig;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.messageStoreConfig =&lt;span&gt; messageStoreConfig;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.brokerStatsManager =&lt;span&gt; brokerStatsManager;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 请求定位服务&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.allocateMappedFileService = &lt;span&gt;new&lt;/span&gt; AllocateMappedFileService(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 存储服务&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (messageStoreConfig.isEnableDLegerCommitLog()) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.commitLog = &lt;span&gt;new&lt;/span&gt; DLedgerCommitLog(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.commitLog = &lt;span&gt;new&lt;/span&gt; CommitLog(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 消费队列信息&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.consumeQueueTable = &lt;span&gt;new&lt;/span&gt; ConcurrentHashMap&amp;lt;&amp;gt;(32&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 刷新队列服务&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.flushConsumeQueueService = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FlushConsumeQueueService();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 清除CommitLog数据服务&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.cleanCommitLogService = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CleanCommitLogService();
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 清除消费队列服务&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.cleanConsumeQueueService = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CleanConsumeQueueService();
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.storeStatsService = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StoreStatsService();
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 索引服务&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.indexService = &lt;span&gt;new&lt;/span&gt; IndexService(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     
&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; HA服务，主从复制&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;messageStoreConfig.isEnableDLegerCommitLog()) {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.haService = &lt;span&gt;new&lt;/span&gt; HAService(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.haService = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.reputMessageService = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReputMessageService();
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.scheduleMessageService = &lt;span&gt;new&lt;/span&gt; ScheduleMessageService(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.transientStorePool = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TransientStorePool(messageStoreConfig);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; 
&lt;span&gt;40&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (messageStoreConfig.isTransientStorePoolEnable()) {
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.transientStorePool.init();
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; 
&lt;span&gt;44&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.allocateMappedFileService.start();
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; 
&lt;span&gt;46&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.indexService.start();
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; 
&lt;span&gt;48&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.dispatcherList = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.dispatcherList.addLast(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; CommitLogDispatcherBuildConsumeQueue());
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.dispatcherList.addLast(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; CommitLogDispatcherBuildIndex());
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; 
&lt;span&gt;52&lt;/span&gt;     File file = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; File(StorePathConfigHelper.getLockFile(messageStoreConfig.getStorePathRootDir()));
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;    MappedFile.ensureDirOK(file.getParent());
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;     lockFile = &lt;span&gt;new&lt;/span&gt; RandomAccessFile(file, &quot;rw&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到DefaultMessageStore的构造会创建很多服务，来管理store的存储&lt;/p&gt;
&lt;p&gt;其中isEnableDLegerCommitLog用来判断是否使用DLeger，默认false是关闭的&lt;br/&gt;所以在默认情况下使用CommitLog + HAService&lt;/p&gt;

&lt;p&gt;关于DLeger可参考这篇博客 &lt;a href=&quot;https://www.jianshu.com/p/99e5df8e2657&quot; target=&quot;_blank&quot;&gt;【Dledger-RocketMQ 基于Raft协议的commitlog存储库】&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;后续的主从复制还是以CommitLog + HAService为主&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;回到initialize方法，接着会调用DefaultMessageStore的load方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; load() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;boolean&lt;/span&gt; result = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;boolean&lt;/span&gt; lastExitOK = !&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.isTempFileExist();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         log.info(&quot;last shutdown {}&quot;, lastExitOK ? &quot;normally&quot; : &quot;abnormally&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;null&lt;/span&gt; !=&lt;span&gt; scheduleMessageService) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             result = result &amp;amp;&amp;amp; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.scheduleMessageService.load();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; load Commit Log&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;         result = result &amp;amp;&amp;amp; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.commitLog.load();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; load Consume Queue&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;         result = result &amp;amp;&amp;amp; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.loadConsumeQueue();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (result) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.storeCheckpoint =
&lt;span&gt;20&lt;/span&gt;                 &lt;span&gt;new&lt;/span&gt; StoreCheckpoint(StorePathConfigHelper.getStoreCheckpoint(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.messageStoreConfig.getStorePathRootDir()));
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.indexService.load(lastExitOK);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.recover(lastExitOK);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;             log.info(&quot;load over, and the max phy offset = {}&quot;, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getMaxPhyOffset());
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         log.error(&quot;load exception&quot;&lt;span&gt;, e);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         result = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;result) {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.allocateMappedFileService.shutdown();
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; 
&lt;span&gt;37&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里会加载CommitLog和ConsumeQueue对应的文件&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;接着创建熟悉的NettyRemotingServer，在前面博客中介绍过了，就不再展开&lt;br/&gt;这里会根据nettyServerConfig克隆一份服务端配置，以此创建fastRemotingServer服务端，只不过这个服务端侦听的是上面服务端端口减2的端口号&lt;/p&gt;
&lt;p&gt;看过我前面的博客就会发现这个fastRemotingServer的端口号其实就是之前提到过的VIP通道&lt;br/&gt;详见：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/a526583280/p/11273769.html&quot; target=&quot;_blank&quot;&gt;【RocketMQ中Producer的启动源码分析】&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/a526583280/p/11290538.html&quot; target=&quot;_blank&quot;&gt;【RocketMQ中Producer消息的发送源码分析】&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;接着会根据不同的需求创建很多不同的线程池&lt;/p&gt;
&lt;p&gt;然后调用registerProcessor方法：&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;registerProcessor方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;91&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; registerProcessor() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;    &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;     * SendMessageProcessor
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     SendMessageProcessor sendProcessor = &lt;span&gt;new&lt;/span&gt; SendMessageProcessor(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    sendProcessor.registerSendMessageHook(sendMessageHookList);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    sendProcessor.registerConsumeMessageHook(consumeMessageHookList);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.remotingServer.registerProcessor(RequestCode.SEND_MESSAGE, sendProcessor, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.sendMessageExecutor);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.remotingServer.registerProcessor(RequestCode.SEND_MESSAGE_V2, sendProcessor, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.sendMessageExecutor);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.remotingServer.registerProcessor(RequestCode.SEND_BATCH_MESSAGE, sendProcessor, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.sendMessageExecutor);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.remotingServer.registerProcessor(RequestCode.CONSUMER_SEND_MSG_BACK, sendProcessor, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.sendMessageExecutor);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.fastRemotingServer.registerProcessor(RequestCode.SEND_MESSAGE, sendProcessor, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.sendMessageExecutor);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.fastRemotingServer.registerProcessor(RequestCode.SEND_MESSAGE_V2, sendProcessor, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.sendMessageExecutor);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.fastRemotingServer.registerProcessor(RequestCode.SEND_BATCH_MESSAGE, sendProcessor, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.sendMessageExecutor);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.fastRemotingServer.registerProcessor(RequestCode.CONSUMER_SEND_MSG_BACK, sendProcessor, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.sendMessageExecutor);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;     * PullMessageProcessor
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.remotingServer.registerProcessor(RequestCode.PULL_MESSAGE, &lt;span&gt;this&lt;/span&gt;.pullMessageProcessor, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.pullMessageExecutor);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.pullMessageProcessor.registerConsumeMessageHook(consumeMessageHookList);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;     * QueryMessageProcessor
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;     NettyRequestProcessor queryProcessor = &lt;span&gt;new&lt;/span&gt; QueryMessageProcessor(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.remotingServer.registerProcessor(RequestCode.QUERY_MESSAGE, queryProcessor, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.queryMessageExecutor);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.remotingServer.registerProcessor(RequestCode.VIEW_MESSAGE_BY_ID, queryProcessor, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.queryMessageExecutor);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.fastRemotingServer.registerProcessor(RequestCode.QUERY_MESSAGE, queryProcessor, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.queryMessageExecutor);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.fastRemotingServer.registerProcessor(RequestCode.VIEW_MESSAGE_BY_ID, queryProcessor, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.queryMessageExecutor);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt; &lt;span&gt;     * ClientManageProcessor
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;     ClientManageProcessor clientProcessor = &lt;span&gt;new&lt;/span&gt; ClientManageProcessor(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.remotingServer.registerProcessor(RequestCode.HEART_BEAT, clientProcessor, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.heartbeatExecutor);
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.remotingServer.registerProcessor(RequestCode.UNREGISTER_CLIENT, clientProcessor, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.clientManageExecutor);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.remotingServer.registerProcessor(RequestCode.CHECK_CLIENT_CONFIG, clientProcessor, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.clientManageExecutor);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; 
&lt;span&gt;41&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.fastRemotingServer.registerProcessor(RequestCode.HEART_BEAT, clientProcessor, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.heartbeatExecutor);
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.fastRemotingServer.registerProcessor(RequestCode.UNREGISTER_CLIENT, clientProcessor, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.clientManageExecutor);
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.fastRemotingServer.registerProcessor(RequestCode.CHECK_CLIENT_CONFIG, clientProcessor, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.clientManageExecutor);
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; 
&lt;span&gt;45&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt; &lt;span&gt;     * ConsumerManageProcessor
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt;     ConsumerManageProcessor consumerManageProcessor = &lt;span&gt;new&lt;/span&gt; ConsumerManageProcessor(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.remotingServer.registerProcessor(RequestCode.GET_CONSUMER_LIST_BY_GROUP, consumerManageProcessor, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.consumerManageExecutor);
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.remotingServer.registerProcessor(RequestCode.UPDATE_CONSUMER_OFFSET, consumerManageProcessor, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.consumerManageExecutor);
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.remotingServer.registerProcessor(RequestCode.QUERY_CONSUMER_OFFSET, consumerManageProcessor, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.consumerManageExecutor);
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; 
&lt;span&gt;53&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.fastRemotingServer.registerProcessor(RequestCode.GET_CONSUMER_LIST_BY_GROUP, consumerManageProcessor, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.consumerManageExecutor);
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.fastRemotingServer.registerProcessor(RequestCode.UPDATE_CONSUMER_OFFSET, consumerManageProcessor, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.consumerManageExecutor);
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.fastRemotingServer.registerProcessor(RequestCode.QUERY_CONSUMER_OFFSET, consumerManageProcessor, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.consumerManageExecutor);
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; 
&lt;span&gt;57&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;58&lt;/span&gt; &lt;span&gt;     * EndTransactionProcessor
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;60&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.remotingServer.registerProcessor(RequestCode.END_TRANSACTION, &lt;span&gt;new&lt;/span&gt; EndTransactionProcessor(&lt;span&gt;this&lt;/span&gt;), &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.endTransactionExecutor);
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.fastRemotingServer.registerProcessor(RequestCode.END_TRANSACTION, &lt;span&gt;new&lt;/span&gt; EndTransactionProcessor(&lt;span&gt;this&lt;/span&gt;), &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.endTransactionExecutor);
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; 
&lt;span&gt;63&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;64&lt;/span&gt; &lt;span&gt;     * Default
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;66&lt;/span&gt;     AdminBrokerProcessor adminProcessor = &lt;span&gt;new&lt;/span&gt; AdminBrokerProcessor(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.remotingServer.registerDefaultProcessor(adminProcessor, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.adminBrokerExecutor);
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.fastRemotingServer.registerDefaultProcessor(adminProcessor, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.adminBrokerExecutor);
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里会创建好几种Processor，通过registerProcessor方法同时注册到remotingServer和fastRemotingServer中&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;registerProcessor方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; registerProcessor(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; requestCode, NettyRequestProcessor processor, ExecutorService executor) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         ExecutorService executorThis =&lt;span&gt; executor;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;null&lt;/span&gt; ==&lt;span&gt; executor) {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         executorThis = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.publicExecutor;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; 
&lt;span&gt;7&lt;/span&gt;     Pair&amp;lt;NettyRequestProcessor, ExecutorService&amp;gt; pair = &lt;span&gt;new&lt;/span&gt; Pair&amp;lt;NettyRequestProcessor, ExecutorService&amp;gt;&lt;span&gt;(processor, executorThis);
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.processorTable.put(requestCode, pair);
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里实际上就是向processorTable进行了记录的添加，为的是后续收到请求能做出对应的处理&lt;/p&gt;
&lt;p&gt;processorTable：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; HashMap&amp;lt;Integer&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; request code &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;, Pair&amp;lt;NettyRequestProcessor, ExecutorService&amp;gt;&amp;gt; processorTable =
&lt;span&gt;2&lt;/span&gt;         &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;Integer, Pair&amp;lt;NettyRequestProcessor, ExecutorService&amp;gt;&amp;gt;(64);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这里的SendMessageProcessor很重要，后续会详细介绍&lt;/p&gt;

&lt;p&gt;在完成registerProcessor后，会创建8个定时任务&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;①&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; BrokerController.&lt;span&gt;this&lt;/span&gt;.getBrokerStats().record();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;定时打印Broker的状态&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;②&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; BrokerController.&lt;span&gt;this&lt;/span&gt;.consumerOffsetManager.persist();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;定时向consumerOffset.json文件中写入消费者偏移量&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;③&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; BrokerController.&lt;span&gt;this&lt;/span&gt;.consumerFilterManager.persist();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;定时向consumerFilter.json文件写入消费者过滤器信息&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;④&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; BrokerController.&lt;span&gt;this&lt;/span&gt;.protectBroker();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;定时禁用消费慢的consumer，保护Broker，需要设置disableConsumeIfConsumerReadSlowly属性，默认false&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;⑤&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; BrokerController.&lt;span&gt;this&lt;/span&gt;.printWaterMark();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;定时打印Send、Pull、Query、Transaction队列信息&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;⑥&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         log.info(&quot;dispatch behind commit log {} bytes&quot;, BrokerController.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getMessageStore().dispatchBehindBytes());
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable e) {
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         log.error(&quot;schedule dispatchBehindBytes error.&quot;&lt;span&gt;, e);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;定时打印已存储在提交日志中但尚未调度到消费队列的字节数&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;⑦&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.brokerConfig.getNamesrvAddr() != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.brokerOuterAPI.updateNameServerAddressList(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.brokerConfig.getNamesrvAddr());
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     log.info(&quot;Set user specified name server address: {}&quot;, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.brokerConfig.getNamesrvAddr());
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.brokerConfig.isFetchNamesrvAddrByAddressServer()) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.scheduledExecutorService.scheduleAtFixedRate(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        @Override
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 BrokerController.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.brokerOuterAPI.fetchNameServerAddr();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable e) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 log.error(&quot;ScheduledTask fetchNameServerAddr exception&quot;&lt;span&gt;, e);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     }, 1000 * 10, 1000 * 60 * 2&lt;span&gt;, TimeUnit.MILLISECONDS);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;若是设置了NamesrvAddr，需要通过updateNameServerAddressList完成一次NameServer地址的跟新（updateNameServerAddressList在前面博客介绍过了）&lt;br/&gt;若是设置了NamesrvAddr，并且设置了fetchNamesrvAddrByAddressServer属性（默认关闭），需要定时获取更新NameServer地址（fetchNameServerAddr方法在之前博客也介绍过）&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;⑧&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;messageStoreConfig.isEnableDLegerCommitLog()) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (BrokerRole.SLAVE == &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.messageStoreConfig.getBrokerRole()) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.messageStoreConfig.getHaMasterAddress() != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; &lt;span&gt;this&lt;/span&gt;.messageStoreConfig.getHaMasterAddress().length() &amp;gt;= 6&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.messageStore.updateHaMasterAddress(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.messageStoreConfig.getHaMasterAddress());
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.updateMasterHAServerAddrPeriodically = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.updateMasterHAServerAddrPeriodically = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.scheduledExecutorService.scheduleAtFixedRate(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                     BrokerController.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.printMasterAndSlaveDiff();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                 } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable e) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                     log.error(&quot;schedule printMasterAndSlaveDiff error.&quot;&lt;span&gt;, e);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         }, 1000 * 10, 1000 * 60&lt;span&gt;, TimeUnit.MILLISECONDS);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在非DLeger模式下&lt;br/&gt;若是SLAVE，则需要检查是否设置了HA的Master地址&lt;br/&gt;若设置了Master地址要通过updateHaMasterAddress方法向更新Master地址&lt;br/&gt;updateHaMasterAddress方法实则是在HAClient中实现的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; updateMasterAddress(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; String newAddr) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     String currentAddr = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.masterAddress.get();
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (currentAddr == &lt;span&gt;null&lt;/span&gt; || !&lt;span&gt;currentAddr.equals(newAddr)) {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.masterAddress.set(newAddr);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         log.info(&quot;update master address, OLD: &quot; + currentAddr + &quot; NEW: &quot; +&lt;span&gt; newAddr);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;非常简单，只是一个比较替换的操作&lt;/p&gt;
&lt;p&gt;若没有设置需要更改updateMasterHAServerAddrPeriodically为true，在后面会有用&lt;/p&gt;
&lt;p&gt;若是MASTER，则需要定时打印slave落后的字节数&lt;/p&gt;

&lt;p&gt;设置完定时任务后，和NameServer中一样设置了对SslContext的监听&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;接着通过initialTransaction方法，加载事务需要的实例&lt;br/&gt;initialTransaction方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; initialTransaction() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.transactionalMessageService = ServiceProvider.loadClass(ServiceProvider.TRANSACTION_SERVICE_ID, TransactionalMessageService.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;null&lt;/span&gt; == &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.transactionalMessageService) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.transactionalMessageService = &lt;span&gt;new&lt;/span&gt; TransactionalMessageServiceImpl(&lt;span&gt;new&lt;/span&gt; TransactionalMessageBridge(&lt;span&gt;this&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getMessageStore()));
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         log.warn(&quot;Load default transaction message hook service: {}&quot;, TransactionalMessageServiceImpl.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.getSimpleName());
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.transactionalMessageCheckListener = ServiceProvider.loadClass(ServiceProvider.TRANSACTION_LISTENER_ID, AbstractTransactionalMessageCheckListener.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;null&lt;/span&gt; == &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.transactionalMessageCheckListener) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.transactionalMessageCheckListener = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultTransactionalMessageCheckListener();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         log.warn(&quot;Load default discard message hook service: {}&quot;, DefaultTransactionalMessageCheckListener.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.getSimpleName());
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.transactionalMessageCheckListener.setBrokerController(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.transactionalMessageCheckService = &lt;span&gt;new&lt;/span&gt; TransactionalMessageCheckService(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里动态加载了TransactionalMessageService和AbstractTransactionalMessageCheckListener的实现类，位于如下&lt;br/&gt;&quot;META-INF/service/org.apache.rocketmq.broker.transaction.TransactionalMessageService&quot;&lt;br/&gt;&quot;META-INF/service/org.apache.rocketmq.broker.transaction.AbstractTransactionalMessageCheckListener&quot;&lt;br/&gt;还创建了TransactionalMessageCheckService&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;initialAcl会创建ACL权限检查：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; initialAcl() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;    &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.brokerConfig.isAclEnable()) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         log.info(&quot;The broker dose not enable acl&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     List&amp;lt;AccessValidator&amp;gt; accessValidators = ServiceProvider.load(ServiceProvider.ACL_VALIDATOR_ID, AccessValidator.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (accessValidators == &lt;span&gt;null&lt;/span&gt; ||&lt;span&gt; accessValidators.isEmpty()) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         log.info(&quot;The broker dose not load the AccessValidator&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (AccessValidator accessValidator: accessValidators) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt; AccessValidator validator =&lt;span&gt; accessValidator;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.registerServerRPCHook(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; RPCHook() {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doBeforeRequest(String remoteAddr, RemotingCommand request) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Do not catch the exception&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;                validator.validate(validator.parse(request, remoteAddr));
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doAfterResponse(String remoteAddr, RemotingCommand request, RemotingCommand response) {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;需要设置aclEnable属性，默认关闭&lt;br/&gt;若是设置了，同样会加载&quot;META-INF/service/org.apache.rocketmq.acl.AccessValidator&quot;配置的AccessValidator实体类&lt;br/&gt;然后将其包装成RPC钩子，注册到remotingServer和fastRemotingServer中，用于请求的调用validate方法进行ACL权限检查&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;initialRpcHooks方法则会注册配置了的RPC钩子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; initialRpcHooks() {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     List&amp;lt;RPCHook&amp;gt; rpcHooks = ServiceProvider.load(ServiceProvider.RPC_HOOK_ID, RPCHook.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (rpcHooks == &lt;span&gt;null&lt;/span&gt; ||&lt;span&gt; rpcHooks.isEmpty()) {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (RPCHook rpcHook: rpcHooks) {
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.registerServerRPCHook(rpcHook);
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;加载&quot;META-INF/service/org.apache.rocketmq.remoting.RPCHook&quot;下的配置的实体类&lt;/p&gt;

&lt;p&gt;到此Broker启动前的准备工作已经完成，后面start方法会进行真正的启动，在下一篇博客继续分析&lt;/p&gt;
</description>
<pubDate>Sat, 03 Aug 2019 22:26:00 +0000</pubDate>
<dc:creator>松饼人</dc:creator>
<og:description>在RocketMQ中，使用BrokerStartup作为启动类，相较于NameServer的启动，Broker作为RocketMQ的核心可复杂得多 【RocketMQ中NameServer的启动源码分</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/a526583280/p/11297099.html</dc:identifier>
</item>
<item>
<title>关于FFT分析音频的小归纳 - pj2933</title>
<link>http://www.cnblogs.com/pj2933/p/11295687.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pj2933/p/11295687.html</guid>
<description>
&lt;p&gt;最近工作上在做关于音乐游戏的内容，其中需要分析音频找节奏点（或者说是重音点）。&lt;/p&gt;
&lt;p&gt;学习了一系列相关知识后，了解到一段音乐的波形图可以分解成不同频率的波形图，也就是由时域到频域的转换。&lt;/p&gt;
&lt;p&gt;借用其他博主的图就比较容易理解了，如下所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1340536/201908/1340536-20190803183245399-649152286.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;波从时域到频域的转换可以通过傅里叶变换实现，关于傅里叶变换的知识可以从最上面的链接学习或者自行查找（傅里叶真厉害！！！）。&lt;/p&gt;
&lt;p&gt;计算机处理的音频在时域上是离散的数据，我们可以使用离散傅里叶变换DFT（傅里叶变换在时域和频域上都呈离散的形式）获得频域上的离散数据。&lt;/p&gt;
&lt;p&gt;快速傅立叶变换FFT是DFT的快速算法，其核心思路就是&lt;span&gt;分治法的DFT&lt;/span&gt;，具体推导可以查看上面的第二个链接。&lt;/p&gt;
&lt;p&gt;FFT 代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　　　 static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BitReverse(Complex[] cpData, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n)
        {
            Complex temp;
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; lim = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; ((&lt;span&gt;1&lt;/span&gt; &amp;lt;&amp;lt; lim) &amp;lt; n) lim++&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; n; i++&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; t = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; lim; j++&lt;span&gt;)
                {

                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (((i &amp;gt;&amp;gt; j) &amp;amp; &lt;span&gt;1&lt;/span&gt;) != &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                        t &lt;/span&gt;|= (&lt;span&gt;1&lt;/span&gt; &amp;lt;&amp;lt; (lim - j - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;));
                }
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i &amp;lt;&lt;span&gt; t)
                {
                    temp &lt;/span&gt;=&lt;span&gt; cpData[i];
                    cpData[i] &lt;/span&gt;=&lt;span&gt; cpData[t];
                    cpData[t] &lt;/span&gt;=&lt;span&gt; temp;
                } &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; i &amp;lt; t 防止交换两次&lt;/span&gt;
&lt;span&gt;            }
        }

        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; FFT1(Complex[] cpData, &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; forward)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; n =&lt;span&gt; cpData.Length;
 
            BitReverse(cpData, n);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;位反转&lt;/span&gt;
&lt;span&gt;
            Complex[] omg &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Complex[n];
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; n; i++&lt;span&gt;)
            {
                omg[i] &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Complex((&lt;span&gt;float&lt;/span&gt;)Math.Cos(&lt;span&gt;2&lt;/span&gt; * Math.PI * i / n), (&lt;span&gt;float&lt;/span&gt;)Math.Sin(&lt;span&gt;2&lt;/span&gt; * Math.PI * i /&lt;span&gt; n));
            }
             Complex temp ;
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; step = &lt;span&gt;2&lt;/span&gt;; step &amp;lt;= n; step *= &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; m = step / &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; n; j +=&lt;span&gt; step)
                    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; m; i++&lt;span&gt;)
                    {&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;蝶形运算&lt;/span&gt;
                        &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(forward)
                            temp &lt;/span&gt;= omg[n / step * i] * cpData[j + i +&lt;span&gt; m];
                        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                            temp &lt;/span&gt;= omg[n / step * i].Conjugate() * cpData[j + i +&lt;span&gt; m];
                        cpData[j &lt;/span&gt;+ i + m] = cpData[j + i] -&lt;span&gt; temp;
                        cpData[j &lt;/span&gt;+ i] = cpData[j + i] +&lt;span&gt; temp;
                    }
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Complex是封装的复数类，偷懒不是自己写的，来自这位老哥&lt;a href=&quot;https://blog.csdn.net/u011583927/article/details/46974341&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/u011583927/article/details/46974341&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个FFT，new了好多对象，效率不是很高。。。&lt;/p&gt;
&lt;p&gt;再贴一个直接把复数的实部虚部轮流放在一个数组里直接算的，能快一些。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　　　 static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Reverse(&lt;span&gt;float&lt;/span&gt;[] data, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n)
        {
                                                           
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;, k = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;                                                        
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; top = n / &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;                                                   
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
            {
                                                 
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; t = data[j + &lt;span&gt;2&lt;/span&gt;&lt;span&gt;];
                data[j &lt;/span&gt;+ &lt;span&gt;2&lt;/span&gt;] = data[k +&lt;span&gt; n];
                data[k &lt;/span&gt;+ n] =&lt;span&gt; t;
                t &lt;/span&gt;= data[j + &lt;span&gt;3&lt;/span&gt;&lt;span&gt;];
                data[j &lt;/span&gt;+ &lt;span&gt;3&lt;/span&gt;] = data[k + n + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
                data[k &lt;/span&gt;+ n + &lt;span&gt;1&lt;/span&gt;] =&lt;span&gt; t;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (j &amp;gt;&lt;span&gt; k)
                {                                                                           
                    t &lt;/span&gt;=&lt;span&gt; data[j];
                    data[j] &lt;/span&gt;=&lt;span&gt; data[k];
                    data[k] &lt;/span&gt;=&lt;span&gt; t;
                    t &lt;/span&gt;= data[j + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
                    data[j &lt;/span&gt;+ &lt;span&gt;1&lt;/span&gt;] = data[k + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
                    data[k &lt;/span&gt;+ &lt;span&gt;1&lt;/span&gt;] =&lt;span&gt; t;
                                                                             
                    t &lt;/span&gt;= data[j + n + &lt;span&gt;2&lt;/span&gt;&lt;span&gt;];
                    data[j &lt;/span&gt;+ n + &lt;span&gt;2&lt;/span&gt;] = data[k + n + &lt;span&gt;2&lt;/span&gt;&lt;span&gt;];
                    data[k &lt;/span&gt;+ n + &lt;span&gt;2&lt;/span&gt;] =&lt;span&gt; t;
                    t &lt;/span&gt;= data[j + n + &lt;span&gt;3&lt;/span&gt;&lt;span&gt;];
                    data[j &lt;/span&gt;+ n + &lt;span&gt;3&lt;/span&gt;] = data[k + n + &lt;span&gt;3&lt;/span&gt;&lt;span&gt;];
                    data[k &lt;/span&gt;+ n + &lt;span&gt;3&lt;/span&gt;] =&lt;span&gt; t;
                }
                                                                                   
                k &lt;/span&gt;+= &lt;span&gt;4&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (k &amp;gt;=&lt;span&gt; n)
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                                                                                 
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; h =&lt;span&gt; top;
                &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (j &amp;gt;=&lt;span&gt; h)
                {
                    j &lt;/span&gt;-=&lt;span&gt; h;
                    h &lt;/span&gt;/= &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
                }
                j &lt;/span&gt;+=&lt;span&gt; h;
            }                                                                            
        }
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; FFT2(&lt;span&gt;float&lt;/span&gt;[] data, &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; forward)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; n =&lt;span&gt; data.Length;            
            n &lt;/span&gt;/= &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;

            Reverse(data, n);


            &lt;/span&gt;&lt;span&gt;float&lt;/span&gt; sign = forward ? &lt;span&gt;1&lt;/span&gt; : -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; mmax = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (n &amp;gt;&lt;span&gt; mmax)
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; istep = &lt;span&gt;2&lt;/span&gt; *&lt;span&gt; mmax;
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; theta = sign * (&lt;span&gt;float&lt;/span&gt;)Math.PI /&lt;span&gt; mmax;
                &lt;/span&gt;&lt;span&gt;float&lt;/span&gt; wr = &lt;span&gt;1&lt;/span&gt;, wi = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; wpr = (&lt;span&gt;float&lt;/span&gt;&lt;span&gt;)Math.Cos(theta);
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; wpi = (&lt;span&gt;float&lt;/span&gt;&lt;span&gt;)Math.Sin(theta);
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; m = &lt;span&gt;0&lt;/span&gt;; m &amp;lt; istep; m += &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; k = m; k &amp;lt; &lt;span&gt;2&lt;/span&gt; * n; k += &lt;span&gt;2&lt;/span&gt; *&lt;span&gt; istep)
                    {
                        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; j = k +&lt;span&gt; istep;
                        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; tempr = wr * data[j] - wi * data[j + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
                        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; tempi = wi * data[j] + wr * data[j + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
                        data[j] &lt;/span&gt;= data[k] -&lt;span&gt; tempr;
                        data[j &lt;/span&gt;+ &lt;span&gt;1&lt;/span&gt;] = data[k + &lt;span&gt;1&lt;/span&gt;] -&lt;span&gt; tempi;
                        data[k] &lt;/span&gt;= data[k] +&lt;span&gt; tempr;
                        data[k &lt;/span&gt;+ &lt;span&gt;1&lt;/span&gt;] = data[k + &lt;span&gt;1&lt;/span&gt;] +&lt;span&gt; tempi;
                    }
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; t =&lt;span&gt; wr;                                                              
                    wr &lt;/span&gt;= wr * wpr - wi *&lt;span&gt; wpi;
                    wi &lt;/span&gt;= wi * wpr + t *&lt;span&gt; wpi;
                }
                mmax &lt;/span&gt;=&lt;span&gt; istep;
            }

        }&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　　　 static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {

            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; n =&lt;span&gt;1024&lt;/span&gt;*&lt;span&gt;512&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;float&lt;/span&gt;[] data = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;float&lt;/span&gt;[&lt;span&gt;2&lt;/span&gt; *&lt;span&gt; n];
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; n; i++&lt;span&gt;)
            {
                data[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; * i] =&lt;span&gt; i;
                data[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; * i + &lt;span&gt;1&lt;/span&gt;] = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            }

            Complex[] cpData &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Complex[n];
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; n; i++&lt;span&gt;)
            {
                cpData[i] &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Complex(data[&lt;span&gt;2&lt;/span&gt; * i], data[&lt;span&gt;2&lt;/span&gt; * i + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;]);
            }

            &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; s =&lt;span&gt; DateTime.Now.Ticks;
            FFT1(cpData, &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;time:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + (DateTime.Now.Ticks - s) / &lt;span&gt;10000&lt;/span&gt;&lt;span&gt;);
            
            s &lt;/span&gt;=&lt;span&gt; DateTime.Now.Ticks;
            FFT2(data, &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;time:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + (DateTime.Now.Ticks - s) / &lt;span&gt;10000&lt;/span&gt;&lt;span&gt;);

            Console.Read();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt; 速度上还是差挺多的。。。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1340536/201908/1340536-20190804011914243-1913886692.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;好了获得频率数据之后的流程就不再那么烧脑了（都怪自己早早把傅里叶变换还给课本了）。。。&lt;/p&gt;
&lt;p&gt;找节奏点的逻辑大概如下（代码有点多就不贴了）：&lt;/p&gt;
&lt;p&gt;1.根据采样率依次获取数据，每次通过FFT得到一组复数数组。&lt;/p&gt;
&lt;p&gt;2.计算出复数的模长，可以表示此频率下的声音大小，可以把一定范围的声音累加起来，可以用来表示低音、中音、高音。&lt;/p&gt;
&lt;p&gt;3.对比每一帧的数据变化就可以判断出节奏点（声音变化大，可以表示是一个节奏点）。&lt;/p&gt;
&lt;p&gt;其实能得到频域的值，针对不同的功能，大家后面就可以自由发挥了。&lt;/p&gt;
</description>
<pubDate>Sat, 03 Aug 2019 17:37:00 +0000</pubDate>
<dc:creator>pj2933</dc:creator>
<og:description>本文部分知识从以下文章学习： https://zhuanlan.zhihu.com/p/19763358 傅里叶变换的知识 https://www.cnblogs.com/RabbitHu/</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/pj2933/p/11295687.html</dc:identifier>
</item>
<item>
<title>Linux再学习（一）-学习路线规划 - JavaEdge</title>
<link>http://www.cnblogs.com/JavaEdge/p/11297019.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/JavaEdge/p/11297019.html</guid>
<description>&lt;p&gt;&lt;strong&gt;Linux第一步，从Windows思维，切换到Linux的“命令行+文件”模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在Linux中，做什么都有相应命令。一般就在bin或者sbin目录下，数量繁多。如果你事先不知道该用哪个命令，很难通过枚举的方式找到。因此，在这样没有统一入口的情况下，就需要你对最基本的命令有所掌握。&lt;/p&gt;
&lt;p&gt;一旦找到某个命令行，替代输入框的是各种各样的启动参数。&lt;/p&gt;
&lt;p&gt;这些参数怎么填，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一般可以通过 -h 查看help，就能找到相应的配置项&lt;/li&gt;
&lt;li&gt;还可以通过man命令，查看文档&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;无论是什么命令行工具，最终的配置一般会落到一个文件上，只要找到了那个文件，文件中会有注释，也可以挨个儿看下去，基本就知道如何配置了。&lt;/p&gt;
&lt;p&gt;攻克了第一个困难了。这个时候，你能看到一些很美丽的风景，例如一些很有技巧的命令sed和awk、很神奇的正则表达式、灵活的管道和grep、强大的bash。你可以自动化地做一些事情了，例如处理一些数据，会比你使用Excel要又快又准，关键是不用框框点点，在后台就能完成一系列操作。在处理数据的同时，你还可以干别的事情，半夜处理数据，第二天早上发个邮件报告，这都是Excel很难做到的事情。&lt;/p&gt;

&lt;p&gt;命令行工具也是程序，只不过是别人写的程序。从用别人写的程序，到自己能够写程序，通过程序来操作Linux，这是第二个要攻克的困难。&lt;/p&gt;
&lt;p&gt;用代码操作Linux，可以直接使用Linux系统调用，也可以使用glibc的库。&lt;/p&gt;
&lt;p&gt;Linux的系统调用非常多，而且每个函数都非常复杂，传入的参数、返回值、调用的方式等等都有很多讲究。&lt;/p&gt;
&lt;p&gt;这里面需要掌握很多Linux操作系统的原理，否则无法理解为什么应该这样调用。&lt;/p&gt;
&lt;p&gt;刚开始学Linux程序设计的时候，你会发现它比命令行复杂得多。&lt;/p&gt;
&lt;p&gt;因为你的角色再次变化。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;如果说使用命令行的人是吃馒头的，那写代码操作命令行的人就是做馒头的。看着简简单单的一个馒头，可能要经过N个工序才能蒸出来。同样，你会发现，你平时用的一个简单的命令行，却需要N个系统调用组合才能完成。其中每个系统调用都要进行深入地学习、读文档、做实验。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;经过一段时间的学习，你攻克了这些东西。这时候，你已经很接近操作系统的原理了，你能看到另一番风景了。&lt;/p&gt;
&lt;p&gt;大学里学的那些理论，你再回去看，现在就会开始有感觉了。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;进程树，调用了fork&lt;/li&gt;
&lt;li&gt;进程同步机制，调用信号量&lt;/li&gt;
&lt;li&gt;网络应用层和传输层的分界线，调用socket&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;都明白了！&lt;/p&gt;

&lt;p&gt;当你已经会使用代码操作Linux时，你肯定很希望揭开这层面纱，看看&lt;strong&gt;系统调用背后到底做了什么&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;进一步了解内核的原理，有助于你更好地使用命令行和进行程序设计，能让你的面试及开发水平更上一层楼，但是不建议直接看源码，因为Linux代码量太大，很容易迷失。&lt;/p&gt;
&lt;p&gt;最好的办法是，先&lt;strong&gt;了解一下Linux内核机制，知道基本的原理和流程&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;不过，Linux内核机制也非常复杂，而且其中相互关联。&lt;/p&gt;
&lt;p&gt;比如说，进程运行要分配内存，内存映射涉及文件的关联，文件的读写需要经过块设备，从文件中加载代码才能运行起来进程。这些知识点要反复对照，才能理清。&lt;/p&gt;
&lt;p&gt;但是一旦攻克！你会发现Linux这个复杂的系统开始透明起来。&lt;/p&gt;
&lt;p&gt;无论你是运维，还是开发，你都能大概知道后发生的事情，并在出现异常的情况时，比较准确地定位到问题所在。&lt;/p&gt;
&lt;p&gt;Linux内核机制是我们重点学习部分，基于最新4.x的内核。&lt;/p&gt;
&lt;p&gt;辅助学习，推荐《深入理解LINUX内核》。&lt;/p&gt;
&lt;p&gt;这本书言简意赅地讲述了主要的内核机制。看完这本书，你会对Linux内核有总体的了解。不过这本书的内核版本有点老，不过对于了解原理来讲，没有任何问题。&lt;/p&gt;

&lt;p&gt;在看内核原理的书的时候经常遇到这种问题，有的地方实在是难以理解，或者不同的书说的不一样，这时候该怎么办呢？其实很好办，Linux是开源的呀，我们可以看代码呀，代码是精准的。哪里有问题，找到那段代码看一看，很多问题就有方法了。&lt;/p&gt;
&lt;p&gt;另外，当你在工作中需要重点研究某方面技术的时候，如果涉及内核，这个时候仅仅了解原理已经不够了，你需要看这部分的代码。&lt;/p&gt;
&lt;p&gt;但是开源软件代码纷繁复杂，一开始看肯定晕，找不着北。这里有一个诀窍，就是一开始阅读代码不要纠结一城一池的得失，不要每一行都一定要搞清楚它是干嘛的，而要聚焦于核心逻辑和使用场景。&lt;/p&gt;
&lt;p&gt;一旦爬上这个坡，对于操作系统的原理，你应该就掌握得比较清楚了。就像蒸馒头的人已经将面粉加工流程烂熟于心。这个时候，你就可以有针对性地去做课题，把所学和你现在做的东西结合起来重点突破。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;研究虚拟化的，就重点看KVM&lt;/li&gt;
&lt;li&gt;研究网络的，就重点看内核协议栈&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;推荐&lt;a href=&quot;https://book.douban.com/subject/1231584/&quot;&gt;《LINUX内核源代码情景分析》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这本书最大的优点是结合场景进行分析，看得见、摸得着，非常直观，唯一的缺点还是内核版本比较老。&lt;/p&gt;

&lt;p&gt;从只看内核代码，到上手修改内核代码，这又是一个很大的坎。&lt;/p&gt;
&lt;p&gt;因为Linux有源代码，很多地方可以参考现有的实现，定制化自己的模块。&lt;/p&gt;
&lt;p&gt;例如，你可以自己实现一个设备驱动程序，实现一个自己的系统调用，或者实现一个自己的文件系统等等。&lt;/p&gt;

&lt;p&gt;如果你是运维，仅仅熟悉上面基本的操作是不够的，生产环境会有大量的不可控因素，尤其是集群规模大的更是如此，大量的运维经验是实战来的，不能光靠读书。如果你是开发，对内核进行少量修改容易，但是一旦面临真实的场景，需要考虑各种因素，并发与并行，锁与保护，扩展性和兼容性，都需要真实项目才能练出来。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/1752328/5keepdfobs.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://wiki.jikexueyuan.com/project/linux-command/&quot;&gt;Linux 命令行&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 03 Aug 2019 17:23:00 +0000</pubDate>
<dc:creator>JavaEdge</dc:creator>
<og:description>1 抛弃旧文化，迎接Linux命令新文化 Linux第一步，从Windows思维，切换到Linux的“命令行+文件”模式 在Linux中，做什么都有相应命令。一般就在bin或者sbin目录下，数量繁多</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/JavaEdge/p/11297019.html</dc:identifier>
</item>
<item>
<title>秒杀架构模型设计 - Yrion</title>
<link>http://www.cnblogs.com/wyq178/p/11261711.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wyq178/p/11261711.html</guid>
<description>&lt;p&gt;前言：秒杀系统相信很多人见过，比如京东或者淘宝的秒杀，小米手机的秒杀，那么秒杀系统的后台是如何实现的呢？我们如何设计一个秒杀系统呢？对于秒杀系统应该考虑哪些问题？如何设计出健壮的秒杀系统？本期我们就来探讨一下这个问题：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1066538/201908/1066538-20190804001256418-1173006929.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;博客的目录&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一：秒杀系统应该考虑的问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二：秒杀系统的设计和技术方案&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三：系统架构图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;四：总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一：秒杀应该考虑哪些问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.1：超卖问题&lt;/p&gt;
&lt;p&gt;   分析秒杀的业务场景,最重要的有一点就是超卖问题，假如备货只有100个，但是最终超卖了200，一般来讲秒杀系统的价格都比较低，如果超卖将严重影响公司的财产利益，因此首当其冲的就是解决商品的超卖问题。&lt;/p&gt;
&lt;p&gt;1.2：高并发&lt;/p&gt;
&lt;p&gt;秒杀具有时间短、并发量大的特点，秒杀持续时间只有几分钟，而一般公司都为了制造轰动效应，会以极低的价格来吸引用户，因此参与抢购的用户会非常的多。短时间内会&lt;/p&gt;
&lt;p&gt;有大量请求涌进来，后端如何防止并发过高造成缓存击穿或者失效，击垮数据库都是需要考虑的问题。&lt;/p&gt;
&lt;p&gt;1.3：接口防刷&lt;/p&gt;
&lt;p&gt;现在的秒杀大多都会出来针对秒杀对应的软件，这类软件会模拟不断向后台服务器发起请求，一秒几百次都是很常见的，如何防止这类软件的重复无效请求，防止不断发起的请求也是需要我们针对性考虑的&lt;/p&gt;
&lt;p&gt;1.4：秒杀url&lt;/p&gt;
&lt;p&gt;对于普通用户来讲，看到的只是一个比较简单的秒杀页面，在未达到规定时间，秒杀按钮是灰色的，一旦到达规定时间，灰色按钮变成可点击状态。这部分是针对小白用户的，如果是稍微有点电脑功底的用户，会通过F12看浏览器的network看到秒杀的url，通过特定软件去请求也可以实现秒杀。或者提前知道秒杀url的人，一请求就直接实现秒杀了。这个问题我们需要考虑解决&lt;/p&gt;
&lt;p&gt;1.5：数据库设计&lt;/p&gt;
&lt;p&gt;秒杀有把我们服务器击垮的风险，如果让它与我们的其他业务使用在同一个数据库中，耦合在一起，就很有可能牵连和影响其他的业务。如何防止这类问题发生，就算秒杀发生了宕机、服务器卡死问题，也应该让他尽量不影响线上正常进行的业务&lt;/p&gt;
&lt;p&gt;1.6:大量请求问题&lt;/p&gt;
&lt;p&gt;按照1.2的考虑，就算使用缓存还是不足以应对短时间的高并发的流量的冲击。如何承载这样巨大的访问量，同时提供稳定低时延的服务保证，是需要面对的一大挑战。我们来算一笔账，假如使用的是redis缓存，单台redis服务器可承受的QPS大概是4W左右，如果一个秒杀吸引的用户量足够多的话，单QPS可能达到几十万，单体redis还是不足以支撑如此巨大的请求量。缓存会被击穿，直接渗透到DB,从而击垮mysql.后台会将会大量报错&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二：秒杀系统的设计和技术方案&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2.1：秒杀系统数据库设计&lt;/p&gt;
&lt;p&gt;针对1.5提出的秒杀数据库的问题，因此应该单独设计一个秒杀数据库，防止因为秒杀活动的高并发访问拖垮整个网站。这里只需要两张表，一张是秒杀订单表，一张是秒杀货品表&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1066538/201907/1066538-20190729235900632-459948622.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1066538/201908/1066538-20190804004816292-1018723015.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;其实应该还有几张表，商品表：可以关联goods_id查到具体的商品信息，商品图像、名称、平时价格、秒杀价格等，还有用户表：根据用户user_id可以查询到用户昵称、用户手机号，收货地址等其他额外信息，这个具体就不给出实例了。&lt;/p&gt;
&lt;p&gt;2.2：秒杀url的设计&lt;/p&gt;
&lt;p&gt;为了避免有程序访问经验的人通过下单页面url直接访问后台接口来秒杀货品，我们需要将秒杀的url实现动态化，即使是开发整个系统的人都无法在秒杀开始前知道秒杀的url。具体的做法就是通过md5加密一串随机字符作为秒杀的url，然后前端访问后台获取具体的url，后台校验通过之后才可以继续秒杀。&lt;/p&gt;
&lt;p&gt;2.3：秒杀页面静态化&lt;/p&gt;
&lt;p&gt;将商品的描述、参数、成交记录、图像、评价等全部写入到一个静态页面，用户请求不需要通过访问后端服务器，不需要经过数据库，直接在前台客户端生成，这样可以最大可能的减少服务器的压力。具体的方法可以使用freemarker模板技术，建立网页模板，填充数据，然后渲染网页&lt;/p&gt;
&lt;p&gt;2.4:单体redis升级为集群redis&lt;/p&gt;
&lt;p&gt;秒杀是一个读多写少的场景，使用redis做缓存再合适不过。不过考虑到缓存击穿问题，我们应该构建redis集群，采用哨兵模式，可以提升redis的性能和可用性。&lt;/p&gt;
&lt;p&gt; 2.5:使用nginx&lt;/p&gt;
&lt;p&gt;nginx是一个高性能web服务器，它的并发能力可以达到几万，而tomcat只有几百。通过nginx映射客户端请求，再分发到后台tomcat服务器集群中可以大大提升并发能力。&lt;/p&gt;
&lt;p&gt;2.6:精简sql&lt;/p&gt;
&lt;p&gt;典型的一个场景是在进行扣减库存的时候，传统的做法是先查询库存，再去update。这样的话需要两个sql，而实际上一个sql我们就可以完成的。可以用这样的做法：update miaosha_goods  set stock =stock-1 where goos_id ={#goods_id} and  version = #{version} and sock&amp;gt;0;这样的话，就可以保证库存不会超卖并且一次更新库存,还有注意一点这里使用了版本号的乐观锁，相比较悲观锁，它的性能较好。&lt;/p&gt;
&lt;p&gt;2.7：redis预减库存&lt;/p&gt;
&lt;p&gt;很多请求进来，都需要后台查询库存,这是一个频繁读的场景。可以使用redis来预减库存，在秒杀开始前可以在redis设值，比如redis.set(goodsId,100),这里预放的库存为100可以设值为常量),每次下单成功之后,Integer stock = (Integer)redis.get(goosId); 然后判断sock的值，如果小于常量值就减去1;不过注意当取消的时候,需要增加库存，增加库存的时候也得注意不能大于之间设定的总库存数(查询库存和扣减库存需要原子操作，此时可以借助lua脚本)下次下单再获取库存的时候,直接从redis里面查就可以了。&lt;/p&gt;
&lt;p&gt;2.8:接口限流&lt;/p&gt;
&lt;p&gt;秒杀最终的本质是数据库的更新，但是有很多大量无效的请求，我们最终要做的就是如何把这些无效的请求过滤掉，防止渗透到数据库。限流的话，需要入手的方面很多：&lt;/p&gt;
&lt;p&gt;2.9.1：前端限流&lt;/p&gt;
&lt;p&gt;首先第一步就是通过前端限流，用户在秒杀按钮点击以后发起请求，那么在接下来的5秒是无法点击(通过设置按钮为disable)。这一小举措开发起来成本很小，但是很有效。&lt;/p&gt;
&lt;p&gt;2.9.2：同一个用户xx秒内重复请求直接拒绝&lt;/p&gt;
&lt;p&gt;具体多少秒需要根据实际业务和秒杀的人数而定，一般限定为10秒。具体的做法就是通过redis的键过期策略，首先对每个请求都从String value = redis.get(userId);如果获取到这个&lt;/p&gt;
&lt;p&gt;value为空或者为null，表示它是有效的请求，然后放行这个请求。如果不为空表示它是重复性请求，直接丢掉这个请求。如果有效,采用redis.setexpire(userId,value,10).value可以是任意值，一般放业务属性比较好,这个是设置以userId为key，10秒的过期时间(10秒后,key对应的值自动为null)&lt;/p&gt;
&lt;p&gt;2.7.3：令牌桶算法限流&lt;/p&gt;
&lt;p&gt;接口限流的策略有很多，我们这里采用令牌桶算法。令牌桶算法的基本思路是每个请求尝试获取一个令牌，后端只处理持有令牌的请求，生产令牌的速度和效率我们都可以自己限定，guava提供了RateLimter的api供我们使用。以下做一个简单的例子,注意需要引入guava&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestRateLimiter {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1秒产生1个令牌&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; RateLimiter rateLimiter = RateLimiter.create(1&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 10; i++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;该方法会阻塞线程，直到令牌桶中能取到令牌为止才继续向下执行。&lt;/span&gt;
            &lt;span&gt;double&lt;/span&gt; waitTime=&lt;span&gt; rateLimiter.acquire();
            System.out.println(&lt;/span&gt;&quot;任务执行&quot; + i + &quot;等待时间&quot; +&lt;span&gt; waitTime);
        }
        System.out.println(&lt;/span&gt;&quot;执行结束&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;   上面代码的思路就是通过RateLimiter来限定我们的令牌桶每秒产生1个令牌(生产的效率比较低)，循环10次去执行任务。acquire会阻塞当前线程直到获取到令牌，也就是如果任务没有获取到令牌，会一直等待。那么请求就会卡在我们限定的时间内才可以继续往下走，这个方法返回的是线程具体等待的时间。执行如下;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1066538/201908/1066538-20190802152410567-941309775.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到任务执行的过程中，第1个是无需等待的，因为已经在开始的第1秒生产出了令牌。接下来的任务请求就必须等到令牌桶产生了令牌才可以继续往下执行。如果没有获取到就会阻塞(有一个停顿的过程)。不过这个方式不太好，因为用户如果在客户端请求，如果较多的话,直接后台在生产token就会卡顿(用户体验较差)，它是不会抛弃任务的，我们需要一个更优秀的策略:如果超过某个时间没有获取到，直接拒绝该任务。接下来再来个案例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestRateLimiter2 {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; RateLimiter rateLimiter = RateLimiter.create(1&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 10; i++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; timeOut = (&lt;span&gt;long&lt;/span&gt;) 0.5&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; isValid =&lt;span&gt; rateLimiter.tryAcquire(timeOut, TimeUnit.SECONDS);
            System.out.println(&lt;/span&gt;&quot;任务&quot; + i + &quot;执行是否有效:&quot; +&lt;span&gt; isValid);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;isValid) {
                &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
            }
            System.out.println(&lt;/span&gt;&quot;任务&quot; + i + &quot;在执行&quot;&lt;span&gt;);
        }
        System.out.println(&lt;/span&gt;&quot;结束&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中用到了tryAcquire方法，这个方法的主要作用是设定一个超时的时间，如果在指定的时间内&lt;strong&gt;预估(注意是预估并不会真实的等待)，&lt;/strong&gt;如果能拿到令牌就返回true，如果拿不到就返回false.然后我们让无效的直接跳过，这里设定每秒生产1个令牌，让每个任务尝试在&lt;/p&gt;
&lt;p&gt;0.5秒获取令牌，如果获取不到,就直接跳过这个任务(放在秒杀环境里就是直接抛弃这个请求)；程序实际运行如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1066538/201908/1066538-20190802154618921-1185631982.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;只有第1个获取到了令牌，顺利执行了，下面的基本都直接抛弃了，因为0.5秒内，令牌桶(1秒1个)来不及生产就肯定获取不到返回false了。&lt;/p&gt;
&lt;p&gt;2.8:异步下单&lt;/p&gt;
&lt;p&gt;为了提升下单的效率，并且防止下单服务的失败。需要将下单这一操作进行异步处理。最常采用的办法是使用队列，队列最显著的三个优点：&lt;strong&gt;异步、削峰、解耦&lt;/strong&gt;。这里可以采用rabbitmq，在后台经过了限流、库存校验之后，流入到这一步骤的就是有效请求。然后发送到队列里，队列接受消息，异步下单。下完单，入库没有问题可以用短信通知用户秒杀成功。假如失败的话,可以采用补偿机制，重试。&lt;/p&gt;
&lt;p&gt;2.9：服务降级&lt;/p&gt;
&lt;p&gt;假如在秒杀过程中出现了某个服务器宕机，或者服务不可用，应该做好后备工作。之前的博客里有介绍通过Hystrix进行服务熔断和降级，可以开发一个备用服务，假如服务器真的宕机了，直接给用户一个友好的提示返回，而不是直接卡死，服务器错误等生硬的反馈。&lt;/p&gt;
&lt;p&gt;三：总结&lt;/p&gt;
&lt;p&gt;秒杀流程图：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1066538/201908/1066538-20190804004355937-2132198728.png&quot; alt=&quot;&quot;/&gt;这就是我设计出来的秒杀流程图,当然不同的秒杀体量针对的技术选型都不一样，这个流程可以支撑起几十万的流量，如果是成千万破亿那就得重新设计了。比如数据库的分库分表、队列改成用kafka、redis增加集群数量等手段。通过本次设计主要是要表明的是我们如何应对高并发的处理，并开始尝试解决它，在工作中多思考、多动手能提升我们的能力水平，加油！如果本篇博客有任何错误，请麻烦指出来，不胜感激。&lt;/p&gt;
</description>
<pubDate>Sat, 03 Aug 2019 16:51:00 +0000</pubDate>
<dc:creator>Yrion</dc:creator>
<og:description>前言：秒杀系统相信很多人见过，比如京东或者淘宝的秒杀，小米手机的秒杀，那么秒杀系统的后台是如何实现的呢？我们如何设计一个秒杀系统呢？对于秒杀系统应该考虑哪些问题？如何设计出健壮的秒杀系统？本期我们就来</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wyq178/p/11261711.html</dc:identifier>
</item>
<item>
<title>sift、surf、orb 特征提取及最优特征点匹配 - 闽A2436</title>
<link>http://www.cnblogs.com/multhree/p/11296945.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/multhree/p/11296945.html</guid>
<description>&lt;h2 id=&quot;sift特征简介&quot;&gt;sift特征简介&lt;/h2&gt;
&lt;p&gt;SIFT(Scale-Invariant Feature Transform)特征，即尺度不变特征变换，是一种计算机视觉的特征提取算法，用来侦测与描述图像中的局部性特征。&lt;/p&gt;
&lt;p&gt;实质上，它是在不同的尺度空间上查找关键点(特征点)，并计算出关键点的方向。SIFT所查找到的关键点是一些十分突出、不会因光照、仿射变换和噪音等因素而变化的点，如角点、边缘点、暗区的亮点及亮区的暗点等。&lt;/p&gt;
&lt;h2 id=&quot;sift特征提取步骤&quot;&gt;sift特征提取步骤&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1. 尺度空间的极值检测：&lt;/strong&gt; 尺度空间指一个变化尺度&lt;code&gt;(σ)&lt;/code&gt;的二维高斯函数&lt;code&gt;G(x,y,σ)&lt;/code&gt;与原图像&lt;code&gt;I(x,y)&lt;/code&gt;卷积（即高斯模糊）后形成的空间,尺度不变特征应该既是空间域上又是尺度域上的局部极值。极值检测的大致原理是根据不同尺度下的高斯模糊化图像差异（Difference of Gaussians,DoG）寻找局部极值，这些找到的极值所对应的点被称为关键点或特征点。&lt;br/&gt;&lt;strong&gt;2. 关键点定位：&lt;/strong&gt; 在不同尺寸空间下可能找出过多的关键点，有些关键点可能相对不易辨识或易受噪声干扰。该步借由关键点附近像素的信息、关键点的尺寸、关键点的主曲率来定位各个关键点，借此消除位于边上或是易受噪声干扰的关键点。&lt;br/&gt;&lt;strong&gt;3. 方向定位：&lt;/strong&gt; 为了使描述符具有旋转不变性，需要利用图像的局部特征为给每一个关键点分配一个基准方向。通过计算关键点局部邻域的方向直方图，寻找直方图中最大值的方向作为关键点的主方向。&lt;br/&gt;&lt;strong&gt;4. 关键点描述子：&lt;/strong&gt; 找到关键点的位置、尺寸并赋予关键点方向后，将可确保其移动、缩放、旋转的不变性。此外还需要为关键点建立一个描述子向量，使其在不同光线与视角下皆能保持其不变性。SIFT描述子是关键点邻域高斯图像梯度统计结果的一种表示，见下图。通过对关键点周围图像区域分块，计算块内梯度直方图，生成具有独特性的向量，这个向量是该区域图像信息的一种抽象，具有唯一性。Lowe在原论文中建议描述子使用在关键点尺度空间内4&lt;em&gt;4的窗口中计算的8个方向的梯度信息，共4&lt;/em&gt;4*8=128维向量表征。(opencv中实现的也是128维)&lt;/p&gt;
&lt;p&gt;具体可以参考这篇博客：&lt;a href=&quot;https://www.cnblogs.com/liuchaogege/p/5155739.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/liuchaogege/p/5155739.html&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;surf特征简介&quot;&gt;surf特征简介&lt;/h2&gt;
&lt;p&gt;SURF(Speeded Up Robust Features, 加速稳健特征) 是一种稳健的图像识别和描述算法。它是SIFT的高效变种，也是提取尺度不变特征，算法步骤与SIFT算法大致相同，但采用的方法不一样，要比SIFT算法更高效（正如其名）。SURF使用海森(Hesseian)矩阵的行列式值作特征点检测并用积分图加速运算；SURF 的描述子基于 2D 离散小波变换响应并且有效地利用了积分图。&lt;/p&gt;
&lt;h2 id=&quot;surf特征提取步骤&quot;&gt;surf特征提取步骤&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1. 特征点检测：&lt;/strong&gt; SURF使用Hessian矩阵来检测特征点，该矩阵是x,y方向的二阶导数矩阵，可测量一个函数的局部曲率，其行列式值代表像素点周围的变化量，特征点需取行列式值的极值点。用方型滤波器取代SIFT中的高斯滤波器，利用积分图（计算位于滤波器方型的四个角落值）大幅提高运算速度。&lt;br/&gt;&lt;strong&gt;2.特征点定位：&lt;/strong&gt; 与SIFT类似，通过特征点邻近信息插补来定位特征点。&lt;br/&gt;&lt;strong&gt;3. 方向定位：&lt;/strong&gt; 通过计算特征点周围像素点x,y方向的哈尔小波变换，并将x,y方向的变换值在xy平面某一角度区间内相加组成一个向量，在所有的向量当中最长的(即x、y分量最大的)即为此特征点的方向。&lt;br/&gt;&lt;strong&gt;4. 特征描述子：&lt;/strong&gt; 选定了特征点的方向后，其周围相素点需要以此方向为基准来建立描述子。此时以5&lt;em&gt;5个像素点为一个子区域，取特征点周围20&lt;/em&gt;20个像素点的范围共16个子区域，计算子区域内的x、y方向(此时以平行特征点方向为x、垂直特征点方向为y)的哈尔小波转换总和Σdx、ΣdyΣdx、Σdy与其向量长度总和Σ|dx|、Σ|dy|Σ|dx|、Σ|dy|共四个量值，共可产生一个64维的描述子。&lt;/p&gt;
&lt;p&gt;具体可以参考这篇博客：&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/zyly/p/9531907.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/zyly/p/9531907.html&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;orb特征简介&quot;&gt;orb特征简介&lt;/h2&gt;
&lt;p&gt;ORB（Oriented FAST and Rotated BRIEF）该特征检测算法是在著名的FAST特征检测和BRIEF特征描述子的基础上提出来的，其运行时间远远优于SIFT和SURF，可应用于实时性特征检测。ORB特征检测具有尺度和旋转不变性，对于噪声及其透视变换也具有不变性，良好的性能是的利用ORB在进行特征描述时的应用场景十分广泛。ORB特征检测主要分为以下两个步骤:(1)方向FAST特征点检测(2)BRIEF特征描述。&lt;/p&gt;
&lt;h2 id=&quot;orb特征提取算法&quot;&gt;orb特征提取算法&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;FAST特征点检测：&lt;a href=&quot;https://www.cnblogs.com/ronny/p/4078710.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/ronny/p/4078710.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;BRIEF特征描述子：&lt;a href=&quot;https://www.cnblogs.com/ronny/p/4081362.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/ronny/p/4081362.html&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;接下来的代码采用的库如下图所示&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1410231/201908/1410231-20190803155054698-162569541.png&quot;/&gt;&lt;br/&gt;红色框的那两个库非常重要！版本请使用&lt;strong&gt;3.4.2.16&lt;/strong&gt;的，而不是最新的，否则在特征提取的时候会报错。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;错误提示：sift = cv2.xfeatures2d.SIFT_create()
cv2.error: OpenCV(3.4.3) C:\projects\opencv-python\opencv_contrib\modules\xfeatures2d\src\sift.cpp:1207: error: (-213:The function/feature is not implemented) This algorithm is patented and is excluded in this configuration; Set OPENCV_ENABLE_NONFREE CMake option and rebuild the library in function ‘cv::xfeatures2d::SIFT::create’&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果你在使用cv2.xfeatures2d.SIFT_create()这个函数的时候出现了上面的错误，就是因为你的库版本太新。把版本退回去就可以了。&lt;/p&gt;
&lt;h2 id=&quot;特征提取&quot;&gt;特征提取&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;def sift(filename):
    img = cv2.imread(filename) # 读取文件
    img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) # 转化为灰度图
    sift = cv2.xfeatures2d_SIFT.create()
    keyPoint, descriptor = sift.detectAndCompute(img, None) # 特征提取得到关键点以及对应的描述符（特征向量）
    return img,keyPoint, descriptor&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;def surf(filename):
    img = cv2.imread(filename) # 读取文件
    img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) # 转化为灰度图
    sift = cv2.xfeatures2d_SURF.create()
    keyPoint, descriptor = sift.detectAndCompute(img, None) # 特征提取得到关键点以及对应的描述符（特征向量）
    return img, keyPoint, descriptor&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;def orb(filename):
    img = cv2.imread(filename) # 读取文件
    img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) # 转化为灰度图
    sift = cv2.ORB_create()
    keyPoint, descriptor = sift.detectAndCompute(img, None) # 特征提取得到关键点以及对应的描述符（特征向量）
    return img, keyPoint, descriptor&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里解释一下为什么要进行转化为灰度图？&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;识别物体，最关键的因素是梯度（SIFT/HOG），梯度意味着边缘，这是最本质的部分，而计算梯度，自然就用到灰度图像了，可以把灰度理解为图像的强度。&lt;/li&gt;
&lt;li&gt;颜色，易受光照影响，难以提供关键信息，故将图像进行灰度化，同时也可以加快特征提取的速度。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;比较一下提取的结果看看&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def compare(filename):
    imgs = []
    keyPoint = []
    descriptor = []
    img, keyPoint_temp, descriptor_temp = sift(filename)
    keyPoint.append(keyPoint_temp)
    descriptor.append(descriptor_temp)
    imgs.append(img)
    img, keyPoint_temp, descriptor_temp = surf(filename)
    keyPoint.append(keyPoint_temp)
    descriptor.append(descriptor_temp)
    imgs.append(img)
    img, keyPoint_temp, descriptor_temp = orb(filename)
    keyPoint.append(keyPoint_temp)
    descriptor.append(descriptor_temp)
    imgs.append(img)
    return imgs, keyPoint, descriptor

def main():
    method = ['sift','surf','orb']
    imgs, kp, des = compare('./pic/doraemon1.jpg')
    for i in range(3):
        img = cv2.drawKeypoints(imgs[i], kp[i], None)
        cv2.imshow(method[i], img)
        cv2.waitKey()
        cv2.destroyAllWindows()
    print(&quot;sift len of des: %d, size of des: %d&quot; % (len(des[0]), len(des[0][0])))
    print(&quot;surf len of des: %d, size of des: %d&quot; % (len(des[1]), len(des[1][0])))
    print(&quot;orb len of des: %d, size of des: %d&quot; % (len(des[2]), len(des[2][0])))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下图是提取的结果，从左到右分别是原图、sift、surf、orb&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1410231/201908/1410231-20190803161230394-1095704981.jpg&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;sift len of des: 458, size of des: 128
surf len of des: 1785, size of des: 64
orb len of des: 500, size of des: 32&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看出：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;sift虽然提取的特征点最少，但是效果最好。&lt;/li&gt;
&lt;li&gt;sift提取的特征点维度是128维，surf是64维，orb是32维。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;特征匹配&quot;&gt;特征匹配&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;BruteForce匹配&lt;/strong&gt;和&lt;strong&gt;FLANN匹配&lt;/strong&gt;是opencv二维特征点匹配常见的两种办法，分别对应BFMatcher（BruteForceMatcher）和FlannBasedMatcher。&lt;/p&gt;
&lt;p&gt;二者的区别在于BFMatcher总是尝试所有可能的匹配，从而使得它总能够找到最佳匹配，这也是Brute Force（暴力法）的原始含义。而FlannBasedMatcher中FLANN的含义是Fast Library forApproximate Nearest Neighbors，从字面意思可知它是一种近似法，算法更快但是找到的是最近邻近似匹配，所以当我们需要找到一个相对好的匹配但是不需要最佳匹配的时候往往使用FlannBasedMatcher。当然也可以通过调整FlannBasedMatcher的参数来提高匹配的精度或者提高算法速度，但是相应地算法速度或者算法精度会受到影响。&lt;/p&gt;
&lt;p&gt;本文是进行最优特征点匹配，因此选用BruteForce Matcher。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def match(filename1, filename2, method):
    if(method == 'sift'):
        img1, kp1, des1 = sift(filename1)
        img2, kp2, des2 = sift(filename2)
        bf = cv2.BFMatcher(cv2.NORM_L2, crossCheck=True)  # sift的normType应该使用NORM_L2或者NORM_L1
        matches = bf.match(des1, des2)
        matches = sorted(matches, key=lambda x: x.distance)
        knnMatches = bf.knnMatch(des1, des2, k=1)  # drawMatchesKnn
    if (method == 'surf'):
        img1, kp1, des1 = surf(filename1)
        img2, kp2, des2 = surf(filename2)
        bf = cv2.BFMatcher(cv2.NORM_L2, crossCheck=True)  # surf的normType应该使用NORM_L2或者NORM_L1
        matches = bf.match(des1, des2)
        matches = sorted(matches, key=lambda x: x.distance)
        knnMatches = bf.knnMatch(des1, des2, k=1)  # drawMatchesKnn
    if(method == 'orb'):
        img1, kp1, des1 = orb(filename1)
        img2, kp2, des2 = orb(filename2)
        bf = cv2.BFMatcher(cv2.NORM_HAMMING, crossCheck = True) # orb的normType应该使用NORM_HAMMING
        matches = bf.match(des1, des2)
        matches = sorted(matches, key=lambda x: x.distance)
        knnMatches = bf.knnMatch(des1, des2, k = 1) # drawMatchesKnn
    # 过滤
    for m in matches:
        for n in matches:
            if(m != n and m.distance &amp;gt;= n.distance*0.75):
                matches.remove(m)
                break
    img = cv2.drawMatches(img1, kp1, img2, kp2, matches[:50], img2, flags=2)
    cv2.imshow(&quot;matches&quot;, img)
    cv2.waitKey()
    cv2.destroyAllWindows()
def main():
    method = ['sift','surf','orb']
    for i in range(3):
        match('./pic/wechat1.jpg', './pic/wechat2.png', method[i])
if __name__ == '__main__':
    main()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;介绍一下几个关键函数。&lt;br/&gt;首先是&lt;code&gt;cv2.BFMatcher(normType, corssCheck)&lt;/code&gt;函数。它有两个参数。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一个参数是用来指定要使用的距离测试类型。默认值为 cv2.Norm_L2。这很适合 SIFT 和 SURF 等(cv2.NORM_L1 也可以)。对于使用二进制描述符的 ORB,BRIEF,BRISK算法等,要使用cv2.NORM_HAMMING,这样就会返回两个测试对象之间的汉明距离。&lt;/li&gt;
&lt;li&gt;第二个参数是布尔变量 crossCheck,默认值为 False。如果设置为True,匹配条件就会更加严格,只有到 A 中的第 i 个特征点与 B 中的第 j 个特征点距离最近,并且 B 中的第 j 个特征点到 A 中的第 i 个特征点也是最近(A 中没有其他点到 j 的距离更近)时才会返回最佳匹配(i,j)。也就是这两个特征点要互相匹配才行。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;然后是&lt;code&gt;bf.match()&lt;/code&gt;。它也有两个参数。前面一个是查询用的向量，后面一个是匹配用的向量。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sorted()&lt;/code&gt;函数是用来对匹配得到的结果进行排序，按照距离排序。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;knnMatch()&lt;/code&gt; 是BFMatcher 对象的另一个方法, BFMatcher.match()方法会返回最佳匹配。而该方法为每个关键点返回 k 个最佳匹配(降序排列之后取前 k 个),其中 k 是由用户设定的。&lt;br/&gt;（注意：knnMatch()和match()得到的返回并不是一样的结果）&lt;/p&gt;
&lt;p&gt;这里还对匹配得到的结果做了过滤，排除一些不好的匹配结果。&lt;/p&gt;
&lt;pre class=&quot;drawmatch()```函数可以画出两张图的匹配点。参数如下：&quot;&gt;
&lt;code&gt;- img1 – 源图像1
- keypoints1 –源图像1的特征点.
- img2 – 源图像2.
- keypoints2 – 源图像2的特征点
- matches1to2 – 源图像1的特征点匹配源图像2的特征点
- outImg – 输出图像具体由flags决定.
- matchColor – 匹配的颜色（特征点和连线),若matchColor==Scalar::all(-1)，颜色随机.
- singlePointColor – 单个点的颜色，即未配对的特征点，若matchColor==Scalar::all(-1)，颜色随机.
- matchesMask – Mask决定哪些点将被画出，若为空，则画出所有匹配点.
- flags – Fdefined by DrawMatchesFlags.

接下来看一下上面的代码运行的结果。从上到底依次是原图、sift、surf、orb

![](https://img2018.cnblogs.com/blog/1410231/201908/1410231-20190803180143667-1990830735.jpg)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;sift size of kp: 59, after filtering: 20&lt;br/&gt;surf size of kp: 197, after filtering: 35&lt;br/&gt;orb size of kp: 390, after filtering: 47&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
从输出的结果来看，orb的效果最好。感兴趣的话还可以用其他图片看看效果，pic文件夹还提供其他两组比较的图片。

# 总结

基于特征的匹配分为特征点提取和匹配两个步骤，本篇主要针对特征点提取三种方法进行比较，分别是SIFT，SURF以及ORB三种方法，这三种方法在OpenCV里面都已实现。SURF基本就是SIFT的全面升级版，有 SURF基本就不用考虑SIFT，而ORB的强点在于计算时间，以下具体比较：&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;计算速度: ORB&amp;gt;&amp;gt;SURF&amp;gt;&amp;gt;SIFT（各差一个量级）&lt;/p&gt;
&lt;p&gt;旋转鲁棒性：SURF&amp;gt;ORB~SIFT（表示差不多）&lt;/p&gt;
&lt;p&gt;模糊鲁棒性：SURF&amp;gt;ORB~SIFT&lt;/p&gt;
&lt;p&gt;尺度变换鲁棒性: SURF&amp;gt;SIFT&amp;gt;ORB（ORB并不具备尺度变换性）&lt;br/&gt;```&lt;br/&gt;所以结论就是，如果对计算实时性要求非常高，可选用ORB算法，但基本要保证正对拍摄；如果对实行性要求稍高，可以选择SURF；基本不用SIFT。&lt;br/&gt;参考：&lt;a href=&quot;https://blog.csdn.net/zilanpotou182/article/details/66478915&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/zilanpotou182/article/details/66478915&lt;/a&gt;&lt;br/&gt;不过上面那篇博客的评论提出了不同的看法，正确性有待验证。&lt;/p&gt;

&lt;p&gt;GitHub：&lt;a href=&quot;https://github.com/Professorchen/Computer-Vision/tree/master/feature-extraction&quot; class=&quot;uri&quot;&gt;https://github.com/Professorchen/Computer-Vision/tree/master/feature-extraction&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 03 Aug 2019 16:39:00 +0000</pubDate>
<dc:creator>闽A2436</dc:creator>
<og:description>[toc] sift sift特征简介 SIFT(Scale Invariant Feature Transform)特征，即尺度不变特征变换，是一种计算机视觉的特征提取算法，用来侦测与描述图像中的局</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/multhree/p/11296945.html</dc:identifier>
</item>
<item>
<title>夜深人静写题解--牛客第六场 - nlc_x</title>
<link>http://www.cnblogs.com/plys/p/11296881.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/plys/p/11296881.html</guid>
<description>&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; #include&amp;lt;bits/stdc++.h&amp;gt;
&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; inf=1e17+&lt;span&gt;7&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;  a[&lt;span&gt;1500&lt;/span&gt;][&lt;span&gt;1500&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; sum[&lt;span&gt;1500&lt;/span&gt;][&lt;span&gt;1500&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; d[&lt;span&gt;1500&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt;    
&lt;span&gt;  8&lt;/span&gt; typedef &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; node
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; l,r;
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt;     &lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; minn;
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt; &lt;span&gt;} Node;
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; maxn = 1e3+&lt;span&gt;7&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt; Node tree[maxn][maxn&amp;lt;&amp;lt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; push_up(&lt;span&gt;int&lt;/span&gt; i,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; rt)
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt;     tree[i][rt].minn=min(tree[i][rt&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;].minn,tree[i][rt&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;|&lt;span&gt;1&lt;/span&gt;&lt;span&gt;].minn);
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; build(&lt;span&gt;int&lt;/span&gt; i,&lt;span&gt;int&lt;/span&gt; rt,&lt;span&gt;int&lt;/span&gt; l,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; r)
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt;     tree[i][rt].l=l,tree[i][rt].r=&lt;span&gt;r;
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(l==&lt;span&gt;r)
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt;         tree[i][rt].minn=&lt;span&gt;sum[i][l];
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ;
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; mid = (l+r)/&lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt;     build(i,rt&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,l,mid);
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt;     build(i,rt&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;|&lt;span&gt;1&lt;/span&gt;,mid+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,r);
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt; &lt;span&gt;    push_up(i,rt);
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; query(&lt;span&gt;int&lt;/span&gt; i,&lt;span&gt;int&lt;/span&gt; rt,&lt;span&gt;int&lt;/span&gt; l,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; r)
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(r&amp;lt;l)&lt;span&gt;return&lt;/span&gt; 1e15+&lt;span&gt;7&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;printf(&quot;%d %d\n&quot;,l,r);&lt;/span&gt;
&lt;span&gt; 36&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(tree[i][rt].l&amp;gt;r||tree[i][rt].r&amp;lt;&lt;span&gt;l)
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; inf;
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(tree[i][rt].l&amp;gt;=l&amp;amp;&amp;amp;tree[i][rt].r&amp;lt;=&lt;span&gt;r)
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; tree[i][rt].minn;
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; mid = (tree[i][rt].l+tree[i][rt].r)/&lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt;     &lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; ans =1e17+&lt;span&gt;7&lt;/span&gt;&lt;span&gt;;;
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(mid&amp;gt;=&lt;span&gt;r)
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt;         ans=query(i,rt&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,l,r);
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(mid&amp;lt;&lt;span&gt;l)
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt;         ans=query(i,rt&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;|&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,l,r);
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;
&lt;span&gt; 55&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt;         ans=min(query(i,rt&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;,l,mid),query(i,rt&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;|&lt;span&gt;1&lt;/span&gt;,mid+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,r));
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ans;
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; t;
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt;     scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;&lt;span&gt;t);
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; temp=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(t--&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n,m;
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;         scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;n,&amp;amp;&lt;span&gt;m);
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;; i&amp;lt;=n; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; j=&lt;span&gt;1&lt;/span&gt;; j&amp;lt;=m; j++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt;                 scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%lld&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;&lt;span&gt;a[i][j]);
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;; i&amp;lt;=m; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt;             scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%lld&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;&lt;span&gt;d[i]);
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;; i&amp;lt;=n; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt;             sum[i][&lt;span&gt;0&lt;/span&gt;]=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; j=&lt;span&gt;1&lt;/span&gt;; j&amp;lt;=m; j++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt;                 sum[i][j]=sum[i][j-&lt;span&gt;1&lt;/span&gt;]+&lt;span&gt;a[i][j];
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt;    
&lt;span&gt; 85&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;; i&amp;lt;=n; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;             build(i,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,m);
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt;    
&lt;span&gt; 88&lt;/span&gt;         &lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; ans=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt;         &lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; qq=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt;         d[&lt;span&gt;0&lt;/span&gt;]=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;; i&amp;lt;=m; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt;             qq+=&lt;span&gt;d[i];
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt;             &lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; jishu=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt;             &lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; se=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; fi=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; st=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; j=&lt;span&gt;1&lt;/span&gt;; j&amp;lt;=n; j++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;                 &lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; mm=query(j,&lt;span&gt;1&lt;/span&gt;,i+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,m);
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt;                 jishu+=&lt;span&gt;min(mm,sum[j][i]);
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;(mm==1e15+&lt;span&gt;7&lt;/span&gt;||mm&amp;gt;=&lt;span&gt;sum[j][i])
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt;                     fi=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;107&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt;(st==&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt;                         se=mm-&lt;span&gt;sum[j][i];
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt;                     &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;111&lt;/span&gt;                     se=max(se,mm-&lt;span&gt;sum[j][i]);
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt;                     st++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;printf(&quot;+++   %lld %lld\n&quot;,mm,se);&lt;/span&gt;
&lt;span&gt;115&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(fi==&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt;                 se=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt;             ans=max(ans,qq-(jishu-&lt;span&gt;se));
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;printf(&quot;****%lld %lld\n&quot;,ans,jishu);&lt;/span&gt;
&lt;span&gt;122&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Case #%d: %lld\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,temp++&lt;span&gt;,ans);
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt; }
&lt;/pre&gt;</description>
<pubDate>Sat, 03 Aug 2019 16:16:00 +0000</pubDate>
<dc:creator>nlc_x</dc:creator>
<og:description>A Garbage Classification 模拟题 1 #include&lt;bits/stdc++.h&gt; 2 using namespace std; 3 4 5 int main()</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/plys/p/11296881.html</dc:identifier>
</item>
<item>
<title>Golang Context 包详解 - 黄挤挤</title>
<link>http://www.cnblogs.com/guangze/p/11296822.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/guangze/p/11296822.html</guid>
<description>&lt;h2 id=&quot;引言&quot;&gt;0. 引言&lt;/h2&gt;
&lt;p&gt;在 Go 语言编写的服务器程序中，服务器通常要为每个 HTTP 请求创建一个 goroutine 以并发地处理业务。同时，这个 goroutine 也可能会创建更多的 goroutine 来访问数据库或者 RPC 服务。当这个请求超时或者被终止的时候，需要优雅地退出所有衍生的 goroutine，并释放资源。因此，我们需要一种机制来通知衍生 goroutine 请求已被取消。 比如以下例子，sleepRandom_1 的结束就无法通知到 sleepRandom_2。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

func sleepRandom_1() {
    i := 0
    for {
        time.Sleep(1 * time.Second)
        fmt.Printf(&quot;This is sleep Random 1: %d\n&quot;, i)

        i++
        if i == 5 {
            fmt.Println(&quot;cancel sleep random 1&quot;)
            break
        }
    }
}

func sleepRandom_2() {
    i := 0
    for {
        time.Sleep(1 * time.Second)
        fmt.Printf(&quot;This is sleep Random 2: %d\n&quot;, i)
        i++
    }
}

func main() {

    go sleepRandom_1() // 循环 5 次后退出
    go sleepRandom_2() // 会一直打印 This is sleep Random 2

    for {
        time.Sleep(1 * time.Second)
        fmt.Println(&quot;Continue...&quot;)
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;context&quot;&gt;1. Context&lt;/h2&gt;
&lt;p&gt;Context 包提供上下文机制在 goroutine 之间传递 deadline、取消信号（cancellation signals）或者其他请求相关的信息。使用方法是：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;首先，服务器程序为每个接受的请求创建一个 Context 实例（称为根 context，通过 &lt;code&gt;context.Background()&lt;/code&gt; 方法创建）；&lt;/li&gt;
&lt;li&gt;之后的 goroutine 接受根 context 的一个派生 Context 对象。比如通过调用根 context 的 WithCancel 方法，创建子 context；&lt;/li&gt;
&lt;li&gt;goroutine 通过 &lt;code&gt;context.Done()&lt;/code&gt; 方法监听取消信号。&lt;code&gt;func Done() &amp;lt;-chan struct{}&lt;/code&gt; 是一个通信操作，会阻塞 goroutine，直到收到取消信号接触阻塞。&lt;br/&gt;（可以借助 select 语句，如果收到取消信号，就退出 goroutine；否则，默认子句是继续执行 goroutine）；&lt;/li&gt;
&lt;li&gt;当一个 Context 被取消（比如执行了 &lt;code&gt;cancelFunc()&lt;/code&gt;），那么该 context 派生出来的 context 也会被取消。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;context-类型&quot;&gt;1.1 Context 类型&lt;/h2&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;// A Context carries a deadline, a cancelation signal, and other values across
// API boundaries.
//
// Context's methods may be called by multiple goroutines simultaneously.
type Context interface {

    Done() &amp;lt;-chan struct{}

    Deadline() (deadline time.Time, ok bool)
    
    Err() error
    
    Value(key interface{}) interface{}
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;done--chan-struct&quot;&gt;Done() &amp;lt;-chan struct{}&lt;/h3&gt;
&lt;p&gt;Done 方法返回一个 channel，阻塞当前运行的代码，直到以下条件之一发生时，channel 才会被关闭，进而解除阻塞：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;WithCancel 创建的 context，cancelFunc 被调用。该 context 以及派生子 context 的 Done channel 都会收到取消信号;&lt;/li&gt;
&lt;li&gt;WithDeadline 创建的 context，deadline 到期。&lt;/li&gt;
&lt;li&gt;WithTimeout 创建的 context，timeout 到期&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Done 要配合 select 语句使用:&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;// DoSomething 生产数据并发送给通道 out
// 但如果 DoSomething 返回一个则退出函数，
// 或者 ctx.Done 被关闭时也会退出函数.
func Stream(ctx context.Context, out chan&amp;lt;- Value) error {
    for {
        v, err := DoSomething(ctx)
        if err != nil {
            return err
        }
        select {
        case &amp;lt;-ctx.Done():
            return ctx.Err()
        case out &amp;lt;- v:
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;deadline-deadline-time.time-ok-bool&quot;&gt;Deadline() (deadline time.Time, ok bool)&lt;/h3&gt;
&lt;p&gt;WithDeadline 方法会给 context 设置 deadline，到期自动发送取消信号。调用 Deadline() 返回 deadline 的值。如果没设置，ok 返回 false。&lt;br/&gt;该方法可用于确定当前时间是否临近 deadline。&lt;/p&gt;
&lt;h3 id=&quot;err-error&quot;&gt;Err() error&lt;/h3&gt;
&lt;p&gt;如果 Done 的 channel 被关闭了, Err 函数会返回一个 error，说明错误原因:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如果 channel 是因为被取消而关闭，打印 canceled；&lt;/li&gt;
&lt;li&gt;如果 channel 是因为 deadline 到时了，打印 deadline exceeded。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;重复调用，返回相同值。&lt;/p&gt;
&lt;h3 id=&quot;valuekey-interface-interface&quot;&gt;Value(key interface{}) interface{}&lt;/h3&gt;
&lt;p&gt;返回由 WithValue 关联到 context 的值。&lt;/p&gt;
&lt;h2 id=&quot;创建根-context&quot;&gt;1.2 创建根 Context&lt;/h2&gt;
&lt;p&gt;有两种方法创建根 Context:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;context.Background()&lt;/li&gt;
&lt;li&gt;context.TODO()&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;根 context 不会被 cancel。这两个方法只能用在最外层代码中，比如 main 函数里。一般使用 Background() 方法创建根 context。&lt;br/&gt;TODO() 用于当前不确定使用何种 context，留待以后调整。&lt;/p&gt;
&lt;h2 id=&quot;派生-context&quot;&gt;1.3 派生 Context&lt;/h2&gt;
&lt;p&gt;一个 Context 被 cancel，那么它的派生 context 都会收到取消信号（表现为 context.Done() 返回的 channel 收到值）。&lt;br/&gt;有四种方法派生 context ：&lt;/p&gt;
&lt;ol readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;func WithCancel(parent Context) (ctx Context, cancel CancelFunc)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;code&gt;func WithDeadline(parent Context, d time.Time) (Context, CancelFunc)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;code&gt;func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;code&gt;func WithValue(parent Context, key, val interface{}) Context&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;withcancel&quot;&gt;WithCancel&lt;/h3&gt;
&lt;p&gt;最常用的派生 context 方法。该方法接受一个父 context。父 context 可以是一个 background context 或其他 context。&lt;br/&gt;返回的 cancelFunc，如果被调用，会导致 Done channel 关闭。因此，绝不要把 cancelFunc 传给其他方法。&lt;/p&gt;
&lt;h3 id=&quot;withdeadline&quot;&gt;WithDeadline&lt;/h3&gt;
&lt;p&gt;该方法会创建一个带有 deadline 的 context。当 deadline 到期后，该 context 以及该 context 的可能子 context 会受到 cancel 通知。另外，如果 deadline 前调用 cancelFunc 则会提前发送取消通知。&lt;/p&gt;
&lt;h3 id=&quot;withtimeout&quot;&gt;WithTimeout&lt;/h3&gt;
&lt;p&gt;与 WithDeadline 类似。创建一个带有超时机制的 context。&lt;/p&gt;
&lt;h3 id=&quot;withvalue&quot;&gt;WithValue&lt;/h3&gt;
&lt;p&gt;WithValue 方法创建一个携带信息的 context，可以是 user 信息、认证 token等。该 context 与其派生的子 context 都会携带这些信息。&lt;/p&gt;
&lt;p&gt;WithValue 方法的第二个参数是信息的唯一 key。该 key 类型不应对外暴露，为了避免与其他包可能的 key 类型冲突。所以使用 WithValue 也&lt;br/&gt;应像下面例子的方式间接调用 WithValue。&lt;/p&gt;
&lt;p&gt;WithValue 方法的第三个参数即是真正要存到 context 中的值。&lt;/p&gt;
&lt;p&gt;使用 WithValue 的例子：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package user

import &quot;context&quot;

// User 类型对象会被保存到 Context 中
type User struct {
    // ...
}

// key 不应该暴露出来。这样避免与包中其他 key 类型冲突
type key int

// userKey 是 user 的 key，不应暴露; 
// 通过 user.NewContext 和 user.FromContext 间接使用 key
var userKey key

// NewContext 返回携带 u 作为 value 的 Context
func NewContext(ctx context.Context, u *User) context.Context {
    return context.WithValue(ctx, userKey, u)
}

// FromContext 返回关联到 context 的 User类型的 value 的值
func FromContext(ctx context.Context) (*User, bool) {
    u, ok := ctx.Value(userKey).(*User)
    return u, ok
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;例子&quot;&gt;2. 例子&lt;/h2&gt;
&lt;p&gt;改进引子里的例子。 sleepRandom_1 结束后，会触发 cancelParent() 被调用。所以 sleepRandom_2 中的 ctx.Done() 会被关闭。sleepRandom_2 执行退出。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package main

import (
    &quot;context&quot;
    &quot;fmt&quot;
    &quot;time&quot;
)

func sleepRandom_1(stopChan chan struct{}) {
    i := 0
    for {
        time.Sleep(1 * time.Second)
        fmt.Printf(&quot;This is sleep Random 1: %d\n&quot;, i)

        i++
        if i == 5 {
            fmt.Println(&quot;cancel sleep random 1&quot;)
            stopChan &amp;lt;- struct{}{}
            break
        }
    }
}

func sleepRandom_2(ctx context.Context) {
    i := 0
    for {
        time.Sleep(1 * time.Second)
        fmt.Printf(&quot;This is sleep Random 2: %d\n&quot;, i)
        i++

        select {
        case &amp;lt;-ctx.Done():
            fmt.Printf(&quot;Why? %s\n&quot;, ctx.Err())
            fmt.Println(&quot;cancel sleep random 2&quot;)
            return
        default:
        }
    }
}

func main() {
    
    ctxParent, cancelParent := context.WithCancel(context.Background())
    ctxChild, _ := context.WithCancel(ctxParent)
    
    stopChan := make(chan struct{})

    go sleepRandom_1(stopChan)
    go sleepRandom_2(ctxChild)

    select {
    case &amp;lt;- stopChan:
        fmt.Println(&quot;stopChan received&quot;)
    }
    cancelParent()
    
    for {
        time.Sleep(1 * time.Second)
        fmt.Println(&quot;Continue...&quot;)
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;参考文档&quot;&gt;3. 参考文档&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.golang.org/context&quot;&gt;Go Concurrency Patterns: Context&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://p.agnihotry.com/post/understanding_the_context_package_in_golang/&quot;&gt;Understanding the context package in golang&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 03 Aug 2019 15:50:00 +0000</pubDate>
<dc:creator>黄挤挤</dc:creator>
<og:description>Golang Context 包详解 0. 引言 在 Go 语言编写的服务器程序中，服务器通常要为每个 HTTP 请求创建一个 goroutine 以并发地处理业务。同时，这个 goroutine 也</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/guangze/p/11296822.html</dc:identifier>
</item>
<item>
<title>Docker Compose的使用 - 暗香残留</title>
<link>http://www.cnblogs.com/zhizihuakai/p/11296743.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhizihuakai/p/11296743.html</guid>
<description>&lt;p&gt;一、背景&lt;/p&gt;
&lt;p&gt;　　继&lt;a href=&quot;https://www.cnblogs.com/zhizihuakai/p/11293802.html&quot; target=&quot;_blank&quot;&gt;上篇&lt;/a&gt;文章之后，学习使用Docker Compose（实际项目中需要做对应的变化）&lt;/p&gt;

&lt;p&gt;二、docker-compose 安装&lt;/p&gt;
&lt;p&gt;　　官网使用最新版进行安装&lt;br/&gt;　　https://github.com/docker/compose/releases/&lt;/p&gt;
&lt;p&gt;例如：&lt;br/&gt;1. 安装当前稳定版本&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
curl -L https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;github.com/docker/compose/releases/download/1.24.1/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2. 对二进制文件应用可执行权限&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;chmod&lt;/span&gt; +x /usr/local/bin/docker-compose
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3. 查看版本（也可以校验是否安装成功）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
docker-compose --version
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/336878/201908/336878-20190803230521784-1320004069.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;三、 docker-compose 命令简介&lt;/p&gt;
&lt;p&gt;如命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
docker-compose up -d
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;up&lt;/p&gt;
&lt;p&gt;　　启动所有在Compose问中定义的容器，并且把它们的日志信息汇集在一起。通常会添加-d参数（在up后面），让容器在后台执行&lt;/p&gt;
&lt;p&gt;start&lt;br/&gt;　　启动指定的已经存在的容器&lt;/p&gt;
&lt;p&gt;build&lt;br/&gt;　　重新建造由Dockerfile构建的镜像。&lt;/p&gt;
&lt;p&gt;ps&lt;br/&gt;　　获取由Compose管理的容器的状态信息&lt;/p&gt;
&lt;p&gt;run&lt;br/&gt;　　启动一个容器，并允许一个一次性的命令。被连接的容器会同时启动，除非用了 --no-deps参数。&lt;/p&gt;
&lt;p&gt;logs&lt;br/&gt;　　汇集由Compose管理的容器的日志，并以彩色输出。&lt;/p&gt;
&lt;p&gt;stop&lt;br/&gt;　　停止容器，但不会删除它们&lt;/p&gt;
&lt;p&gt;rm&lt;br/&gt;　　删除已停止的容器。不要忘记使用-v参数来删除任何由Docker管理的数据卷&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;说明：&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;　　一个普通的工作流程以docker-compose up -d名利启动应用程序开始。docker-compose logs和ps命令可以用来验证应用程序的状态，还能帮助调试。&lt;/em&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;em&gt;修改代码后，先执行docker-compose build 构建新的镜像，然后执行docker-compose up -d 取代运行中的容器。注意，Compose会保留原来容器中所有旧的数据卷，这意味着即使容器更新后，数据库和缓存也依旧在容器内（这很可能造成混淆，因此要特别小心）。&lt;/em&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;em&gt;　　如果你修改了Compose的YAML文件，但不需要构建新的镜像，可以通过up -d参数使Compose以新的配置替换容器。如果想要强制停止Compose并重新创建所有容器，可以使用--force-recreate选项来达到目的。&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;四、 docker-compose.yml 文件模板&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
#具体的版本号，请参考官网https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;docs.docker.com/compose/compose-file/&lt;/span&gt;
version: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;3.7&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
services:
    #声明构建容器的名称，docker&lt;/span&gt;-&lt;span&gt;compose start和stop命令可以使用
    testhttpweb:
    #使用指定目录下的Dockerfile进行构建
    build: .
    #相当于docker run命令的&lt;/span&gt;-&lt;span&gt;p参数，用于声明对外开放的端口
    ports:
        &lt;/span&gt;- &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;5000:5000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; 
    　　 - &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;8010:80&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;五、简单使用&lt;/p&gt;
&lt;p&gt;1. 在/root/Root/DefaultHttp的路径下创建yml文件（请参考上一步的模板）&lt;/p&gt;
&lt;p&gt;2. 执行命令运行容器&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
docker-compose up -d
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/336878/201908/336878-20190803231407692-1875589295.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上图可以看出，即使没有创建image也会成功（会自动进行创建）&lt;/p&gt;
&lt;p&gt;3. 查看镜像&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
docker images
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/336878/201908/336878-20190803231556187-97811422.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;defaulthttp_testhttpweb 为自动创建的镜像&lt;/p&gt;
&lt;p&gt;4. 停止和删除容器&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
docker-compose stop testhttpweb
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/336878/201908/336878-20190803232731260-872709233.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
docker-compose &lt;span&gt;rm&lt;/span&gt; testhttpweb
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/336878/201908/336878-20190803232757158-1401294959.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;六、总结&lt;/p&gt;
&lt;p&gt;　　实现了docker-compose的安装、命令介绍、简单使用&lt;/p&gt;

&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;　　《Docker开发指南》&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;https://www.jianshu.com/p/658911a8cff3&quot;&gt;https://www.jianshu.com/p/658911a8cff3&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 03 Aug 2019 15:19:00 +0000</pubDate>
<dc:creator>暗香残留</dc:creator>
<og:description>一、背景 继上篇文章之后，学习使用Docker Compose（实际项目中需要做对应的变化） 二、docker-compose 安装 官网使用最新版进行安装 https://github.com/do</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhizihuakai/p/11296743.html</dc:identifier>
</item>
<item>
<title>BeanFactory体系结构 - 张风闲</title>
<link>http://www.cnblogs.com/zhangfengxian/p/11296591.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangfengxian/p/11296591.html</guid>
<description>&lt;p&gt;BeanFactory是Spring中非常重要的一个类，搞懂了它，你就知道了bean的初始化和摧毁过程，对于深入理解IOC有很大的帮助。&lt;/p&gt;
&lt;h2 id=&quot;beanfactory体系结构&quot;&gt;BeanFactory体系结构&lt;/h2&gt;
&lt;p&gt;首先看一下使用IDEA生成的继承层次图（图中去掉了ApplicationContext的继承图）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1156642/201907/1156642-20190716220520591-405509584.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到&lt;code&gt;BeanFactory&lt;/code&gt;下的接口主要分为三个：&lt;/p&gt;
&lt;p&gt;关于&lt;code&gt;BeanFactory&lt;/code&gt;的分析见&lt;a href=&quot;https://www.cnblogs.com/zhangfengxian/p/11086695.html#beanfactory&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/zhangfengxian/p/11086695.html#beanfactory&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;beanfactory接口分析&quot;&gt;BeanFactory接口分析&lt;/h2&gt;
&lt;p&gt;下面将对&lt;code&gt;BeanFactory&lt;/code&gt;中的接口进行分析。&lt;/p&gt;
&lt;h3 id=&quot;autowirecapablebeanfactory&quot;&gt;AutowireCapableBeanFactory&lt;/h3&gt;
&lt;p&gt;该接口提供了对现有bean进行自动装配的能力，设计目的不是为了用于一般的应用代码中，对于一般的应用代码应该使用&lt;code&gt;BeanFactory&lt;/code&gt;和&lt;code&gt;ListableBeanFactory&lt;/code&gt;。其他框架的代码集成可以利用这个接口去装配和填充现有的bean的实例，但是Spring不会控制这些现有bean的生命周期。你也许注意到了&lt;code&gt;ApplicationContext&lt;/code&gt;中的&lt;code&gt;getAutowireCapableBeanFactory()&lt;/code&gt;能获取到&lt;code&gt;AutowireCapableBeanFactory&lt;/code&gt;的实例（&lt;a href=&quot;https://www.cnblogs.com/zhangfengxian/p/11086695.html#applicationcontext%E8%AE%BE%E8%AE%A1%E8%A7%A3%E6%9E%90&quot;&gt;https://www.cnblogs.com/zhangfengxian/p/11086695.html#applicationcontext%E8%AE%BE%E8%AE%A1%E8%A7%A3%E6%9E%90&lt;/a&gt;）。同样，也能实现&lt;code&gt;BeanFactoryAware&lt;/code&gt;接口来接收&lt;code&gt;BeanFactory&lt;/code&gt;（应用程序上下暴露的内部使用的BeanFactory）的实例，然后将其转换成&lt;code&gt;AutowireCapableBeanFactory&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;下面看一下这个接口中的静态成员变量和方法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 定义了bean的装配策略
int AUTOWIRE_NO = 0;            // 不进行装配
int AUTOWIRE_BY_NAME = 1;       // 根据名字进行装配
int AUTOWIRE_BY_TYPE = 2;       // 根据类型进行装配
int AUTOWIRE_CONSTRUCTOR = 3;   // 根据构造函数进行装配
@Deprecated
int AUTOWIRE_AUTODETECT = 4;    // Spring3.0已经过时的方法，通过省视bean来决定适当的装载策略

//Spring5.1后增加，原始实例的后缀，例如&quot;com.mypackage.MyClass.ORIGINAL&quot;，强制返回给定的实例（没有代理）
String ORIGINAL_INSTANCE_SUFFIX = &quot;.ORIGINAL&quot;;

// 完全创建给定类的一个新的实例，包括所有适用的BeanPostProcessor
// 填充注解的field和方法，并且会应用所有的初始化回调函数
&amp;lt;T&amp;gt; T createBean(Class&amp;lt;T&amp;gt; beanClass) throws BeansException;
// 装配bean，通过应用初始化之后的回调函数和bean属性的后置处理来填充给定的bean的实例
// 本质上是为了在创建新的实例或者反序列化实例时，填充（重新填充）实例中注解的field和方法
void autowireBean(Object existingBean) throws BeansException;
// 配置给定的原始bean：自动装配bean的属性，应用bean的属性值、工厂回调函数（例如setBeanName,values）
// 同样也会应用所有bean的后置处理器
Object configureBean(Object existingBean, String beanName) throws BeansException;

// 使用指定的装配策略来完全创建一个新的bean的实例
Object createBean(Class&amp;lt;?&amp;gt; beanClass, int autowireMode, boolean dependencyCheck) throws BeansException;
// 使用指定的装配策略来实例化一个给定类新的bean的实例
// 不会应用标准的BeanPostProcessor回调函数或者在未来执行任何bean的初始化
Object autowire(Class&amp;lt;?&amp;gt; beanClass, int autowireMode, boolean dependencyCheck) throws BeansException;
// 根据名字和类型来自动装配给定bean的实例的属性
// 不会应用标准的BeanPostProcessor回调函数或者在未来执行任何bean的初始化
void autowireBeanProperties(Object existingBean, int autowireMode, boolean dependencyCheck)
    throws BeansException;
// 应用给定名字的bean的定义的属性值到给定的bean的实例
// 该方法不会自动装配bean属性，仅仅应用明确定义的属性值
void applyBeanPropertyValues(Object existingBean, String beanName) throws BeansException;
// 初始化给定的原始的bean应用bean的属性值、工厂回调函数（例如setBeanName,values）
// 同样也会应用所有bean的后置处理器
Object initializeBean(Object existingBean, String beanName) throws BeansException;
// 应用BeanPostProcessor到给定的现存的bean的实例，调用postProcessBeforeInitialization方法
Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName)
    throws BeansException;
// 应用BeanPostProcessor到给定的现存的bean的实例，postProcessAfterInitialization
Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName)
    throws BeansException;
// 摧毁给定的bean的实例，应用DisposableBean规约和注册的DestructionAwareBeanPostProcessor
void destroyBean(Object existingBean);

// 解析唯一匹配给定对象类型的bean的实例，该方法是getBean(Class)的变种，只不过它还提供了匹配实例的bean的名字
&amp;lt;T&amp;gt; NamedBeanHolder&amp;lt;T&amp;gt; resolveNamedBean(Class&amp;lt;T&amp;gt; requiredType) throws BeansException;
// 解析给定bean的名字的实例，提供了用于暴露目标的工厂方法的依赖描述符
Object resolveBeanByName(String name, DependencyDescriptor descriptor) throws BeansException;
// 针对在工厂中定义的bean来解析指定的依赖
Object resolveDependency(DependencyDescriptor descriptor, @Nullable String requestingBeanName) throws BeansException;
// 针对在工厂中定义的bean来解析指定的依赖
Object resolveDependency(DependencyDescriptor descriptor, @Nullable String requestingBeanName,
                         @Nullable Set&amp;lt;String&amp;gt; autowiredBeanNames, @Nullable TypeConverter typeConverter) throws BeansException;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;configurablebeanfactory&quot;&gt;ConfigurableBeanFactory&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;ConfigurableBeanFactory&lt;/code&gt;提供了bean工厂的配置机制（除了BeanFactory接口中的bean的工厂的客户端方法）。该BeanFactory接口不适应一般的应用代码中，应该使用&lt;code&gt;BeanFactory&lt;/code&gt;和&lt;code&gt;ListableBeanFactory&lt;/code&gt;。该扩展接口仅仅用于内部框架的使用，并且是对bean工厂配置方法的特殊访问。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ConfigurableBeanFactory&lt;/code&gt;继承自&lt;code&gt;HierarchicalBeanFactory&lt;/code&gt;和&lt;code&gt;SingletonBeanRegistry&lt;/code&gt;，下面先看下&lt;code&gt;SingletonBeanRegistry&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SingletonBeanRegistry&lt;/code&gt;是为了共享的bean的实例而定义的注册器，以统一的方式暴露单例管理机制。下面是在此接口中定义的方法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 在bean的注册器中以给定的bean的名字将给定的现存对象注册为单例
void registerSingleton(String beanName, Object singletonObject);
// 根据给定的bean的名字来获取单例bean，可能为null
Object getSingleton(String beanName);
// 是否包含给定名字的单例bean
boolean containsSingleton(String beanName);
// 获取所有在注册器中注册的单例bean的名字
String[] getSingletonNames();
// 获取所有在注册器中注册的单例bean的数量
int getSingletonCount();
// 获取在这个注册器中使用的单例的mutex（用于外部协同）
Object getSingletonMutex();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要注意的是使用&lt;code&gt;registerSingleton&lt;/code&gt;方法注册的单例bean，不会执行任何的初始化回调函数（尤其不会调用&lt;code&gt;InitializingBean&lt;/code&gt;的&lt;code&gt;afterPropertiesSet&lt;/code&gt;方法），同样也不会接收任何的摧毁回调函数。如果需要接收初始化和摧毁回调函数，请注册bean的定义而不是现存的实例对象。&lt;/p&gt;
&lt;p&gt;接下来看下&lt;code&gt;ConfigurableBeanFactory&lt;/code&gt;中定义的方法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 作用域
String SCOPE_SINGLETON = &quot;singleton&quot;; // 单例作用域
String SCOPE_PROTOTYPE = &quot;prototype&quot;; // 原型作用域

// 设置父级bean工厂
void setParentBeanFactory(BeanFactory parentBeanFactory) throws IllegalStateException;
// 设置bean的类加载器，默认为线程上下文类加载器
void setBeanClassLoader(@Nullable ClassLoader beanClassLoader);
// 获取bean的类加载器
@Nullable
ClassLoader getBeanClassLoader();
// 设置临时的类加载器
void setTempClassLoader(@Nullable ClassLoader tempClassLoader);
// 获取临时的类加载器
@Nullable
ClassLoader getTempClassLoader();
// 设置是否缓存bean的元数据
void setCacheBeanMetadata(boolean cacheBeanMetadata);
// 是否缓存bean的元数据
boolean isCacheBeanMetadata();
// 设置bean的表达式解析器，以统一的EL兼容样式支持#{...}这样的表达式
void setBeanExpressionResolver(@Nullable BeanExpressionResolver resolver);
// 获取bean的表达式解析器
@Nullable
BeanExpressionResolver getBeanExpressionResolver();
// 设置转换服务，用于转换属性值
void setConversionService(@Nullable ConversionService conversionService);
// 获取转换服务
@Nullable
ConversionService getConversionService();
// 添加属性编辑器注册者
void addPropertyEditorRegistrar(PropertyEditorRegistrar registrar);
// 为所有给定的属性注册自定义属性编辑器
void registerCustomEditor(Class&amp;lt;?&amp;gt; requiredType, Class&amp;lt;? extends PropertyEditor&amp;gt; propertyEditorClass);
// 使用在BeanFactory中注册的自定义编辑器来初始哈给定的属性编辑器注册者
void copyRegisteredEditorsTo(PropertyEditorRegistry registry);
// 设置类型转换器
void setTypeConverter(TypeConverter typeConverter);
// 获取类型转换器
TypeConverter getTypeConverter();
// 添加嵌入值解析器，例如注册属性
void addEmbeddedValueResolver(StringValueResolver valueResolver);
// 在BeanFactory是否有注册嵌入值解析器
boolean hasEmbeddedValueResolver();
// 解析给定的嵌入的值
@Nullable
String resolveEmbeddedValue(String value);
// 添加bean的后置处理器
void addBeanPostProcessor(BeanPostProcessor beanPostProcessor);
// 获取bean的后置处理器个数
int getBeanPostProcessorCount();
// 注册作用域
void registerScope(String scopeName, Scope scope);
// 获取注册的作用域的名字
String[] getRegisteredScopeNames();
// 获取作用域
@Nullable
Scope getRegisteredScope(String scopeName);
// 提供一个与这个工厂有关的安全访问控制上下文
AccessControlContext getAccessControlContext();
// 从给定的其他的工厂拷贝所有相关的配置。不应该包含任何bean的定义元数据
void copyConfigurationFrom(ConfigurableBeanFactory otherFactory);
// 注册别名
void registerAlias(String beanName, String alias) throws BeanDefinitionStoreException;
// 解析所有别名的目标名称和在工厂中注册的别名，将给定的StringValueResolver应用于它们
void resolveAliases(StringValueResolver valueResolver);
// 获取合并的bean的定义
BeanDefinition getMergedBeanDefinition(String beanName) throws NoSuchBeanDefinitionException;
// 给定名字的bean是否为FactoryBean
boolean isFactoryBean(String name) throws NoSuchBeanDefinitionException;
// 显式的设置指定bean的目前在创建状态
void setCurrentlyInCreation(String beanName, boolean inCreation);
// 指定的bean目前是否为在建状态
boolean isCurrentlyInCreation(String beanName);
// 注册给定bean所依赖的bean
void registerDependentBean(String beanName, String dependentBeanName);
// 获取所有依赖于指定bean的bean的名字
String[] getDependentBeans(String beanName);
// 获取所有指定bean所依赖的bean的名字
String[] getDependenciesForBean(String beanName);
// 根据bean的定义来摧毁给定的bean的实例（通常是从工厂中获取到的原型实例）
void destroyBean(String beanName, Object beanInstance);
// 在当前目标作用域中摧毁指定的作用域中的bean
void destroyScopedBean(String beanName);
// 摧毁在工厂中的所有单例bean
void destroySingletons();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的大部分方法都是获取或者设置一些配置的信息，以便协同来完成BeanFactory的配置。&lt;/p&gt;
&lt;h3 id=&quot;configurablelistablebeanfactory&quot;&gt;ConfigurableListableBeanFactory&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;ConfigurableListableBeanFactory&lt;/code&gt;接口继承自&lt;code&gt;ListableBeanFactory&lt;/code&gt;, &lt;code&gt;AutowireCapableBeanFactory&lt;/code&gt;, &lt;code&gt;ConfigurableBeanFactory&lt;/code&gt;。大多数具有列出能力的bean工厂都应该实现此接口。此了这些接口的能力之外，该接口还提供了分析、修改bean的定义和单例的预先实例化的机制。这个接口不应该用于一般的客户端代码中，应该仅仅提供给内部框架使用。下面是这个接口的方法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 忽略用于自动装配的依赖的类型
void ignoreDependencyType(Class&amp;lt;?&amp;gt; type);
// 忽略用于自动装配的依赖的接口
void ignoreDependencyInterface(Class&amp;lt;?&amp;gt; ifc);
// 给特定的依赖类型注册自动装配的值
void registerResolvableDependency(Class&amp;lt;?&amp;gt; dependencyType, @Nullable Object autowiredValue);
// 指定的bean是否为自动装配的候选者
boolean isAutowireCandidate(String beanName, DependencyDescriptor descriptor)
    throws NoSuchBeanDefinitionException;
// 获取bean的定义
BeanDefinition getBeanDefinition(String beanName) throws NoSuchBeanDefinitionException;
// 获取这个工厂中的所有bean的名字的迭代器
Iterator&amp;lt;String&amp;gt; getBeanNamesIterator();
// 清除元数据缓存
void clearMetadataCache();
// 冻结所有bean的定义
void freezeConfiguration();
// 工厂中bean的定义是否冻结了
boolean isConfigurationFrozen();
// 对非懒加载的单例进行预先初始化
void preInstantiateSingletons() throws BeansException;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;abstractbeanfactory&quot;&gt;AbstractBeanFactory&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;AbstractBeanFactory&lt;/code&gt;继承自&lt;code&gt;FactoryBeanRegistrySupport&lt;/code&gt;，实现了&lt;code&gt;ConfigurableBeanFactory&lt;/code&gt;接口。&lt;code&gt;AbstractBeanFactory&lt;/code&gt;是&lt;code&gt;BeanFactory&lt;/code&gt;的抽象基础类实现，提供了完整的&lt;code&gt;ConfigurableBeanFactory&lt;/code&gt;的能力。在这里不讨论该抽象类的实现细节，只要知道这个类是干什么的就行了，会面会有更加详细的章节来讨论。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;单例缓存&lt;/li&gt;
&lt;li&gt;别名的管理&lt;/li&gt;
&lt;li&gt;FactoryBean的处理&lt;/li&gt;
&lt;li&gt;用于子bean定义的bean的合并&lt;/li&gt;
&lt;li&gt;bean的摧毁接口&lt;/li&gt;
&lt;li&gt;自定义的摧毁方法&lt;/li&gt;
&lt;li&gt;BeanFactory的继承管理&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;子类需要实现的模板方法如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 是否包含给定名字的bean的定义
protected abstract boolean containsBeanDefinition(String beanName);
// 根据bean的名字来获取bean的定义，子类通常要实现缓存
protected abstract BeanDefinition getBeanDefinition(String beanName) throws BeansException;
// 为给定的已经合并了的bean的定义创建bean的实例
protected abstract Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)
    throws BeanCreationException;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;abstractautowirecapablebeanfactory&quot;&gt;AbstractAutowireCapableBeanFactory&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;AbstractAutowireCapableBeanFactory&lt;/code&gt;继承自&lt;code&gt;AbstractBeanFactory&lt;/code&gt;，实现了&lt;code&gt;AutowireCapableBeanFactory&lt;/code&gt;接口。该抽象了实现了默认的bean的创建。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;提供了bean的创建、属性填充、装配和初始化&lt;/li&gt;
&lt;li&gt;处理运行时bean的引用，解析管理的集合、调用初始化方法等&lt;/li&gt;
&lt;li&gt;支持构造器自动装配，根据类型来对属性进行装配，根据名字来对属性进行装配&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;子类需要自行实现的模板方法如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 用于根据类型来进行自动装配
Object resolveDependency(DependencyDescriptor descriptor, @Nullable String requestingBeanName,
                         @Nullable Set&amp;lt;String&amp;gt; autowiredBeanNames, @Nullable TypeConverter typeConverter) throws BeansException;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;defaultlistablebeanfactory&quot;&gt;DefaultListableBeanFactory&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;DefaultListableBeanFactory&lt;/code&gt;继承自&lt;code&gt;AbstractAutowireCapableBeanFactory&lt;/code&gt;，实现了&lt;code&gt;ConfigurableListableBeanFactory&lt;/code&gt;, &lt;code&gt;BeanDefinitionRegistry&lt;/code&gt;, &lt;code&gt;Serializable&lt;/code&gt;接口。这个类是一个非常完全的BeanFactory，基于bean的定义元数据，通过后置处理器来提供可扩展性。&lt;/p&gt;
&lt;h3 id=&quot;xmlbeanfactory&quot;&gt;XmlBeanFactory&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;XmlBeanFactory&lt;/code&gt;继承自&lt;code&gt;DefaultListableBeanFactory&lt;/code&gt;，用来从XML文档中读取bean的定义的一个非常方便的类。最底层是委派给&lt;code&gt;XmlBeanDefinitionReader&lt;/code&gt;，实际上等价于带有&lt;code&gt;XmlBeanDefinitionReader&lt;/code&gt;的&lt;code&gt;DefaultListableBeanFactory&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;思维导图&quot;&gt;思维导图&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1156642/201908/1156642-20190803222741643-856758785.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 03 Aug 2019 14:29:00 +0000</pubDate>
<dc:creator>张风闲</dc:creator>
<og:description>BeanFactory是Spring中非常重要的一个类，搞懂了它，你就知道了bean的初始化和摧毁过程，对于深入理解IOC有很大的帮助。 BeanFactory体系结构 首先看一下使用IDEA生成的继</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhangfengxian/p/11296591.html</dc:identifier>
</item>
<item>
<title>详解 Diff 算法以及循环要加 key 值问题 - 梁音</title>
<link>http://www.cnblogs.com/liangyin/p/11296583.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liangyin/p/11296583.html</guid>
<description>&lt;p&gt;上一篇文章我简述了什么是 &lt;a href=&quot;https://juejin.im/post/5d3ff99fe51d4561fb04beea&quot;&gt;Virtual DOM&lt;/a&gt;，这一章我会详细讲 &lt;code&gt;Diff&lt;/code&gt; 算法以及为什么在 &lt;code&gt;React&lt;/code&gt; 和 &lt;code&gt;Vue&lt;/code&gt; 中循环都需要 key 值。&lt;/p&gt;

&lt;p&gt;Web 界面其实就是一个 DOM 树的结构，当其中某个部分发生变化的时候，实质上就是对应的某个 DOM 节点发生了变化。而在 React/Vue 中，都采用了 Virtual DOM 来模拟真实的树结构，他们都拥有两个 Virtual DOM，一颗是真实 DOM 结构的映射，另一颗则是改动后生成的 Virtual DOM，然后利用高效的 Diff 算法来遍历分析新旧 Virtual DOM 结构的差异，最后 Patch 不同的节点。&lt;/p&gt;
&lt;p&gt;但是给定两个 Virtual DOM，利用标准的 Diff 算法肯定是不行的，使用传统的 Diff 算法通过循环递归遍历节点进行对比，其复杂度要达到&lt;em&gt;O(n^3)&lt;/em&gt;，其中 n 是节点总数，效率十分低下，假设我们要展示 1000 个节点，那么我们就要依次执行上十亿次的比较，这肯定无法满足性能要求。&lt;/p&gt;
&lt;p&gt;这里附上一则传统的 Diff 算法：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// 存储比较结果
let result = []
// 比较两棵树
const diffTree = function (beforeTree, afterTree) {
  // 获取较大树的 长度
  let count = Math.max(beforeTree.children.length, afterTree.children.length)
  // 进行循环遍历
  for (let i = 0; i &amp;lt; count; i++) {
    const beforeChildren = beforeTree.children[i]
    const afterChildren = afterTree.children[i]
    // 如果原树没有，新树有，则添加
    if (beforeChildren === undefined) {
      result.push({
        type: 'add',
        element: afterChildren
      })
      // 如果原树有，新树没有，则删除
    } else if (afterChildren === undefined) {
      result.push({
        type: 'remove',
        element: beforeChildren
      })
      // 如果节点名称对应不上，则删除原树节点并添加新树节点
    } else if (beforeChildren.tagName !== afterChildren.tagName) {
      result.push({
        type: 'remove',
        elevation: beforeChildren
      })
      result.push({
        type: 'add',
        element: beforeChildren
      })
      // 如果节点名称一样，但内容改变，则修改原树节点的内容
    } else if (beforeChildren.innerTHML !== afterChildren.innerTHML) {
      // 如果没有其他子节点，则直接改变
      if (beforeChildren.children.length === 0) {
        result.push({
          type: 'changed',
          beforeElement: beforeChildren,
          afterElement: afterChildren,
          html: afterChildren.innerTHML
        });
      } else {
        // 否则进行递归比较
        diffTree(beforeChildren, afterChildren)
      }
    }
  }
  // 最后返回结果
  return result
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然而优化过后的 Diff 算法的复杂度只有&lt;em&gt;O(n)&lt;/em&gt;，这归结于 DIff 算法的优化，工程师们将 Diff 算法根据实际 DOM 树结构特点做了以下优化。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Tree Diff（层级的比较）&lt;/li&gt;
&lt;li&gt;Component Diff（组件的比较）&lt;/li&gt;
&lt;li&gt;Element Diff（元素/节点的比较）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;简单来说就是两个概念：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;相同组件会产生类似的 DOM 结构，不同的组件产生的 DOM 结构也不同&lt;/li&gt;
&lt;li&gt;同一层级的子节点，可以通过唯一的 id 来进行区分&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;利用一张常见的图可以完全看出 Tree Diff 的比较规则：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://md-1255362963.cos.ap-chengdu.myqcloud.com/2019-08-02-084455.png&quot; alt=&quot;5518628-d60043dbeddfce8b&quot;/&gt;&lt;/p&gt;
&lt;p&gt;左右两棵树，分别为旧树和新树，先进行树结构的层级比较，并且只会对相同颜色方框内的 DOM 节点进行比较，即同一个父节点下的所有子节点。&lt;/p&gt;
&lt;p&gt;如果有任一一个节点不匹配，则该节点和其子节点就会被完全删除，不会继续遍历。&lt;/p&gt;
&lt;p&gt;基于这个策略，算法复杂度降低为&lt;em&gt;O(n)&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;这时有同学要问了，那如果我想移动一个节点到另一个节点下，即跨层级操作，DIff 会怎样表现呢？&lt;/p&gt;
&lt;p&gt;如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://md-1255362963.cos.ap-chengdu.myqcloud.com/2019-08-03-092824.jpg&quot; alt=&quot;Xnip2019-08-02_17-21-26&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以 C 为根节点，整棵树会被新创建，而不是简单的移动，创建的流程为 &lt;code&gt;create C&lt;/code&gt;-&amp;gt;`&lt;code&gt;create F&lt;/code&gt;-&amp;gt;&lt;code&gt;create G&lt;/code&gt;-&amp;gt;&lt;code&gt;delete C&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这是一种很影响性能的操作，&lt;strong&gt;官方建议不要进行DOM节点跨层级操作，可以通过CSS隐藏、显示节点，而不是真正地移除、添加DOM节点&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：在开发组件时，保持稳定的 DOM 结构会有助于性能的提升。例如，可以通过 CSS 隐藏或显示节点，而不是真的移除或添加 DOM 节点。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;React&lt;/code&gt;/&lt;code&gt;Vue&lt;/code&gt;是基于组件构建应用的，对于组件间的比较所采用的策略也是非常简洁和高效的。&lt;/p&gt;
&lt;p&gt;对此，有以下三种策略：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;同类型组件（即：两节点是同一个组件类的两个不同实例）
&lt;ul&gt;&lt;li&gt;若组件相同，则继续按照层级比较其 Virtual DOM 的结构。&lt;/li&gt;
&lt;li&gt;若组件 A 转变为组件 B，但是组件 A 和组件 B 渲染出来的 Virtual DOM 没有任何变化(即，子节点的顺序、状态state等，都未发生变化)，如果开发者能够提前知道这一点，那么可以省下大量 Diff 的时间。React 中，允许用户通过&lt;code&gt;shouldComponentUpdate()&lt;/code&gt;来判断该组件是否需要进行&lt;code&gt;diff&lt;/code&gt;算法分析。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;不同类型组件
&lt;ul&gt;&lt;li&gt;直接判断为 &lt;code&gt;dirty component&lt;/code&gt;，继而替换整个组件的所有内容。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如果组件 A 和组件 B 的结构相似，但是 React 判断是 不同类型的组件，则不会比较其结构，而是删除组件 A 及其子节点，创建组件 B 及其子节点。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;举个栗子：就算组件 D 和组件 G 的结构一模一样，但是改变时仍然会删除并且重新创建。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://md-1255362963.cos.ap-chengdu.myqcloud.com/2019-08-03-092832.png&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Component Diff 只会比较同组节点集合的内容是否改变。即，若旧树里，A 有 B 和 C 两个节点，新树里 A 有 C 和 B 两个节点，无论 B 和 C 的位置是否改变，都会认为 component 层未改变。但是若 A 里的 state 发生了改变，则会认为 component 改变，继而进行组件的更新。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;

&lt;p&gt;当 DOM 处于同一层级时，Diff 提供三个节点操作，即 &lt;em&gt;删除（REMOVE_NODE）&lt;/em&gt;、&lt;em&gt;插入（INSERT_MARKUP）&lt;/em&gt;、&lt;em&gt;移动（MOVE_EXISTING）&lt;/em&gt;。&lt;/p&gt;
&lt;h2 id=&quot;删除remove_node&quot;&gt;删除（REMOVE_NODE）&lt;/h2&gt;
&lt;p&gt;旧组件类型，在新集合里也有，但对应的&lt;code&gt;element&lt;/code&gt;不同则不能直接复用和更新，需要执行删除操作，或者旧组件不在新集合里的，也需要执行删除操作。&lt;/p&gt;
&lt;p&gt;如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://md-1255362963.cos.ap-chengdu.myqcloud.com/2019-08-03-092840.jpg&quot; alt=&quot;Xnip2019-08-03_13-53-59&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;插入insert_markup&quot;&gt;插入（INSERT_MARKUP）&lt;/h2&gt;
&lt;p&gt;新的组件类型不在旧集合中，即全新的节点，需要对新节点进行插入操作。&lt;/p&gt;
&lt;p&gt;如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://md-1255362963.cos.ap-chengdu.myqcloud.com/2019-08-03-092844.jpg&quot; alt=&quot;Xnip2019-08-03_14-00-16&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;移动move_existing&quot;&gt;移动（MOVE_EXISTING）&lt;/h2&gt;
&lt;p&gt;旧集合中有新组件类型，且&lt;code&gt;element&lt;/code&gt;是可更新的类型，这时候就需要做移动操作，可以复用以前的DOM节点。&lt;/p&gt;
&lt;h3 id=&quot;没有-key-值的问题&quot;&gt;没有 Key 值的问题&lt;/h3&gt;
&lt;p&gt;如下图，老集合中包含节点：A、B、C、D，更新后的新集合中包含节点：B、A、D、C，此时新老集合进行 diff 差异化对比，发现 B != A，则创建并插入 B 至新集合，删除老集合 A；以此类推，创建并插入 A、D 和 C，删除 B、C 和 D。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://md-1255362963.cos.ap-chengdu.myqcloud.com/2019-08-03-092853.png&quot; alt=&quot;7541670c089b84c59b84e9438e92a8e9_hd&quot;/&gt;&lt;/p&gt;
&lt;p&gt;React 发现这类操作繁琐冗余，因为这些都是相同的节点，但由于位置发生变化，导致需要进行繁杂低效的删除、创建操作，其实只要对这些节点进行位置移动即可。&lt;/p&gt;
&lt;p&gt;针对这一现象，React 提出优化策略：允许开发者对同一层级的同组子节点，添加唯一 key 进行区分，虽然只是小小的改动，性能上却发生了翻天覆地的变化！&lt;/p&gt;
&lt;h3 id=&quot;为什么循环需要添加唯一-key值&quot;&gt;为什么循环需要添加唯一 Key值&lt;/h3&gt;
&lt;p&gt;给元素加了 Key 值之后，React/Vue 在做 Diff 的时候会进行差异化对比，即通过 key 发现新老集合中的节点都是相同的节点，因此无需进行节点删除和创建，只需要将老集合中节点的位置进行移动，更新为新集合中节点的位置，此时 React 给出的 diff 结果为：B、D 不做任何操作，A、C 进行&lt;code&gt;移动&lt;/code&gt;操作，即可。&lt;/p&gt;
&lt;p&gt;那么，如此高效的 diff 到底是如何运作的呢？&lt;/p&gt;
&lt;p&gt;简单来说有以下几步：&lt;/p&gt;
&lt;ol readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;对新集合的节点进行遍历，通过唯一 key 可以判断新老集合中是否存在相同节点。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3.5&quot;&gt;
&lt;p&gt;如果存在相同节点，则进行移动操作，但在移动前，需要将当前节点在老集合中的位置与 lastIndex 进行比较，如果不同，则进行节点移动，否则不执行该操作。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;这是一种顺序优化手段，lastIndex 一直在更新，表示访问过的节点在老集合中最右的位置（即最大的位置），如果新集合中当前访问的节点比 lastIndex 大，说明当前访问节点在老集合中就比上一个节点位置靠后，则该节点不会影响其他节点的位置，因此不用添加到差异队列中，即不执行移动操作，只有当访问的节点比 lastIndex 小时，才需要进行移动操作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这里给出一整图作为示例。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://md-1255362963.cos.ap-chengdu.myqcloud.com/2019-08-03-092900.png&quot; alt=&quot;c0aa97d996de5e7f1069e97ca3accfeb_hd&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，以新树为循环基准：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;B 在老集合的下标为 &lt;code&gt;BIndex=1&lt;/code&gt;，此时 &lt;code&gt;lastIndex=0&lt;/code&gt;，这时，&lt;code&gt;lastIndex &amp;lt; BIndex&lt;/code&gt;，不进行任何处理，并且取值 &lt;code&gt;lastIndex=Math.max(BIndex, lastIndex)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;A 在老集合的下标为 &lt;code&gt;AIndex=0&lt;/code&gt;，此时&lt;code&gt;lastIndex=1&lt;/code&gt;，这时，&lt;code&gt;lastIndex &amp;gt; AIndex&lt;/code&gt;，这时，需要把老树中的 A 移动到下标为&lt;code&gt;lastIndex&lt;/code&gt;的位置，并且取值 &lt;code&gt;lastIndex=Math.max(AIndex, lastIndex)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;D 在老集合的下标为 &lt;code&gt;DIndex=3&lt;/code&gt;，此时&lt;code&gt;lastIndex=1&lt;/code&gt;，这时，&lt;code&gt;lastIndex &amp;lt; DIndex&lt;/code&gt;，不进行任何处理，并且取值 &lt;code&gt;lastIndex=Math.max(DIndex, lastIndex)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;C 在老集合的下标为 &lt;code&gt;CIndex=2&lt;/code&gt;，此时&lt;code&gt;lastIndex=3&lt;/code&gt;，这时，&lt;code&gt;lastIndex &amp;gt; CIndex&lt;/code&gt;，需要把老树中的 C 移动到下标为&lt;code&gt;lastIndex&lt;/code&gt;的位置，并且取值 &lt;code&gt;lastIndex=Math.max(CIndex, lastIndex)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;由于 C 已经是最后一个节点，因此 Diff 至此结束。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;以上主要分析新老集合中存在相同节点但位置不同时，对节点进行位置移动的情况，如果新集合中有新加入的节点且老集合存在需要删除的节点，那么 React diff 又是如何对比运作的呢？&lt;/p&gt;
&lt;p&gt;以此图为例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://md-1255362963.cos.ap-chengdu.myqcloud.com/2019-08-03-092905.png&quot; alt=&quot;7b9beae0cf0a5bc8c2e82d00c43d1c90_hd&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同上的流程：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;B 同上流程&lt;/li&gt;
&lt;li&gt;老集合中没有 E 集合，则判断老集合中不存在相同节点 E，则创建新节点 E，更新 lastIndex ＝ 1，并将 E 的位置更新为新集合中的位置。&lt;/li&gt;
&lt;li&gt;C 同上&lt;/li&gt;
&lt;li&gt;A 同上&lt;/li&gt;
&lt;li&gt;当完成集合 Diff 时，最后还需要对老集合进行循环遍历，判断是否存在新集合中没有但老集合中仍然存在的节点，如果有，则删除，循环发现，D 就是这样的节点，因此删除 D，完成 Diff。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这种循环方式，眼尖的读者会发现一个问题，如果是集合的首尾位置互换，那开销就大了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://md-1255362963.cos.ap-chengdu.myqcloud.com/2019-08-03-092910.png&quot; alt=&quot;1b8dac5b9b3e4452dec8d5447d7717ad_hd&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，此时的 DIff 算法，会将 A，B，C 全部移动到 D 的后面，造成大量DOM 的移动，而实际上我们只需要将 D 移动到集合的头部仅一次即可。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;由此可看出，在开发过程中，尽量减少类似将最后一个节点移动到列表首部的操作，当节点数量过大或更新操作过于频繁时，在一定程度上会影响 React 的渲染性能。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;除了上述不添加 Key 值会造成整个集合删除再新增，不会进行移动 DOM 操作，导致大量无谓的开销外，但是结合上述 Component Diff 联想，如果 A、B、C、D都是同类型组件且不加 Key 值会发生什么情况呢？&lt;/p&gt;
&lt;p&gt;我们看图说话：&lt;/p&gt;
&lt;p&gt;这是 Vue 的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://md-1255362963.cos.ap-chengdu.myqcloud.com/2019-08-03-092940.gif&quot; alt=&quot;Jietu20190803-165539-HD&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是 React 的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://md-1255362963.cos.ap-chengdu.myqcloud.com/2019-08-03-094900.gif&quot; alt=&quot;Jietu20190803-165152-HD&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们发现，无论是 React 还是 Vue 删除了第二项之后，第三项列表内部的 state 仍然沿用的第二个列表的内容。&lt;/p&gt;
&lt;p&gt;这是因为，React/Vue 判断是变化前后是同类型组件，并且 props 的内容并没有改变，不会触发改变。&lt;/p&gt;
&lt;p&gt;其流程如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;既然 1 没有变，那么就&lt;strong&gt;就地复用&lt;/strong&gt;之前的 1&lt;/li&gt;
&lt;li&gt;既然 2 变成了 3，里面的子孙元素就地复用。有人不理解为什么子孙元素就地复用，那么是因为子孙元素的 data/state 属性不受 2 变成 3 的影响&lt;/li&gt;
&lt;li&gt;既然 3 没了，那么连其子孙元素全部删除&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;破解方法就是加上唯一的 key，让 Diff 知道就算是同类型的组件，也是有名字区分的。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;在做动态改变的时候，尽量不要使用 index 作为循环的 key，如果你用 index 作为 key，那么在删除第二项的时候，index 就会从 1，2，3 变为 1，2（而不是 1，3），那么仍有可能引起更新错误。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;&lt;li&gt;React/Vue 的 DIff 策略使遍历复杂度降低为 O(n)，是一个重大的优化&lt;/li&gt;
&lt;li&gt;React/Vue 在做循环时，一定要加上唯一的 key 值，这样不仅能有效提高 Diff 效率，减少 DOM 的重绘，还能避免一些稀奇古怪的错误&lt;/li&gt;
&lt;li&gt;尽量减少跨层级的组件改动，尽量使用 v-show/display:none 来保持 DOM 结构的稳定性，防止新增、删除等消耗大量性能的操作&lt;/li&gt;
&lt;li&gt;尽量减少将节点尾部移动到节点头部等操作，当节点数量过大或更新操作过于频繁时，在一定程度上会影响 React 的渲染性能。&lt;/li&gt;
&lt;li&gt;另外，React 从 16 版本开始使用了 Fiber 架构，这个架构解决了大型 React 项目的性能问题及一些之前框架的痛点，我会在下一章详细介绍 Fiber 架构的奥秘和其与之前架构的区别&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;文章最后，如大家有兴趣入小程序的坑，不妨试试用 React 方式书写小程序的框架 Taro，我以此为基础做出一套多端 UI 框架&lt;a href=&quot;https://yinliangdream.github.io/mp-colorui-doc/#/&quot;&gt;MP-ColorUI&lt;/a&gt;，大家感兴趣可以去 &lt;a href=&quot;https://github.com/yinLiangDream/mp-colorui&quot;&gt;Github&lt;/a&gt; star 一下，下面是小程序演示版本。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://md-1255362963.cos.ap-chengdu.myqcloud.com/coloruiqrcode.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 03 Aug 2019 14:27:00 +0000</pubDate>
<dc:creator>梁音</dc:creator>
<og:description>上一篇文章我简述了什么是 'Virtual DOM' ，这一章我会详细讲 算法以及为什么在 和 中循环都需要 key 值。 什么是 DOM Diff 算法 Web 界面其实就是一个 DOM 树的结构，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/liangyin/p/11296583.html</dc:identifier>
</item>
</channel>
</rss>