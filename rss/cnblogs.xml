<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>解读 kubernetes client-go 官方 examples - Part Ⅰ - 黄挤挤</title>
<link>http://www.cnblogs.com/guangze/p/10753929.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/guangze/p/10753929.html</guid>
<description>&lt;p&gt;&lt;strong&gt;转发请注明出处：https://www.cnblogs.com/guangze/p/10753929.html&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;最近，因为需要对 Kubernetes 进行二次开发，接触了 client-go 库。client-go 作为官方维护的 go 语言实现的 client 库，提供了大量的高质量代码帮助开发者编写自己的客户端程序，来访问、操作 Kubernetes 集群。 在学习过程中我发现，除了官方的几个 examples 和 README 外，介绍 client-go 的文章较少。因此，这里有必要总结一下我的学习体会，分享出来。&lt;/p&gt;
&lt;p&gt;访问 Kubernetes 集群的方式有多种（见 &lt;a href=&quot;https://kubernetes.io/docs/tasks/administer-cluster/access-cluster-api/&quot;&gt;Access Clusters Using the Kubernetes API&lt;/a&gt; ），但本质上都要通过调用 Kubernetes REST API 实现对集群的访问和操作。比如，使用最多 kubernetes 命令行工具 kubectl，就是通过调用 Kubernetes REST API 完成的。当执行 &lt;code&gt;kubectl get pods -n test&lt;/code&gt; 命令时， kubectl 向 Kubernetes API Server 完成认证、并发送 GET 请求：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;GET /api/v1/namespaces/test/pods
---
200 OK
Content-Type: application/json
{
  &quot;kind&quot;: &quot;PodList&quot;,
  &quot;apiVersion&quot;: &quot;v1&quot;,
  &quot;metadata&quot;: {&quot;resourceVersion&quot;:&quot;10245&quot;},
  &quot;items&quot;: [...]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么如何编写自己的 http 客户端程序呢？ 这就需要 Kubernetes 提供的 Golang client 库。&lt;/p&gt;
&lt;p&gt;本文通过解读 Kubernetes client-go 官方例子之一 &lt;a href=&quot;https://github.com/kubernetes/client-go/tree/master/examples/create-update-delete-deployment&quot;&gt;Create, Update &amp;amp; Delete Deployment&lt;/a&gt; ，详细介绍 client-go 原理和使用方法。该例子实现了创建、更新、查询、删除 deployment 资源。&lt;/p&gt;

&lt;h2 id=&quot;测试环境&quot;&gt;2.1 测试环境&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Ubuntu 18.04.2&lt;/li&gt;
&lt;li&gt;Minikube 1.0.0&lt;/li&gt;
&lt;li&gt;golang 1.12.4&lt;/li&gt;
&lt;li&gt;k8s.io/client-go 源码&lt;/li&gt;
&lt;li&gt;GoLand IDE&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下载 Minikube release 地址：https://github.com/kubernetes/minikube/releases&lt;/p&gt;
&lt;p&gt;下载 k8s.io/client-go 源码：https://github.com/kubernetes/client-go&lt;/p&gt;
&lt;p&gt;client-go 源码下载后，使用 go mod vendor 下载依赖库，或直接从github上下载依赖的其他库（如果没有设置外网代理的话）。&lt;/p&gt;
&lt;h2 id=&quot;运行结果&quot;&gt;2.2 运行结果&lt;/h2&gt;
&lt;p&gt;因为我自己开了 VPN 连接到远程的 Kubernetes 集群内网，并复制 .kube/config 到了本地，所以我可以直接在 GoLand 上编译运行，就能看到如下输出：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;Creating deployment...
Created deployment &quot;demo-deployment&quot;.
-&amp;gt; Press Return key to continue.

Updating deployment...
Updated deployment...
-&amp;gt; Press Return key to continue.

Listing deployments in namespace &quot;default&quot;:
 * demo-deployment (1 replicas)
 * intended-quail-fluentbit-operator (1 replicas)
 * test (1 replicas)
-&amp;gt; Press Return key to continue.

Deleting deployment...
Deleted deployment.

Process finished with exit code 0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在运行过程中，你也可以通过 kubectl 命令观察创建的 deployment 变化。可以看到，这个 example 分别完成了四个操作：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在 default namespace 下创建了一个叫 demo-deployment 的 deployment&lt;/li&gt;
&lt;li&gt;更新该 deployment 的副本数量、修改容器镜像版本到 nginx:1.13&lt;/li&gt;
&lt;li&gt;列出 default namespace 下的所有 deployment&lt;/li&gt;
&lt;li&gt;删除创建的 demo-deployment&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;完成 deployment 资源的增删改查，大体可以分为以下几个步骤。这个流程对访问其他 Kubernete 资源也是一样的：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;通过 kubeconfig 信息，构造 Config 实例。该实例记录了集群证书、 API Server 地址等信息；&lt;/li&gt;
&lt;li&gt;根据 Config 实例携带的信息，创建 http 客户端；&lt;/li&gt;
&lt;li&gt;向 apiserver 发送请求，创建 Kubernetes 资源等&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我用 go-callvis 制作了 example 中的函数调用图，以供参考：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/409355/201904/409355-20190422233531454-1526038177.png&quot; alt=&quot;例子里的函数调用图&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;获取-kubeconfig-信息并构造-restconfig-实例&quot;&gt;3.1 获取 kubeconfig 信息，并构造 rest#Config 实例&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Note: 我用 &amp;lt;package&amp;gt;#&amp;lt;func, struct&amp;gt; 表示某包下的函数、结构体&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在访问 Kubernetes 集群时，少不了身份认证。使用 kubeconfig 配置文件是其中一种主要的认证方式。kubeconfig 文件描述了集群（cluster）、用户（user）和上下文（context）信息。默认的 kubeconfig 文件位于 $HOME/.kube/config 下。可以通过 &lt;code&gt;cat $HOME/.kube/config&lt;/code&gt;， 或者 &lt;code&gt;kubectl config view&lt;/code&gt; 查看：&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;apiVersion: v1
kind: Config
clusters:
- cluster:
    certificate-authority-data: DATA+OMITTED
    server: https://192.168.0.8:6443
  name: cluster.local
contexts:
- context:
    cluster: cluster.local
    user: kubernetes-admin
  name: kubernetes-admin@cluster.local
users:
- name: kubernetes-admin
  user:
    client-certificate-data: REDACTED
    client-key-data: REDACTED
current-context: kubernetes-admin@cluster.local
preferences: {}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我的测试环境 kubeconfig 配置显示，集群 API Server 地址位于 192.168.0.8:6443，集群开启 TLS，certificate-authority-data 指定公钥。客户端用户名为 kubernetes-admin，证书为 client-certificate-data，通过私钥 client-key-data 访问集群。上下文参数将集群和用户关联了起来。关于 kubeconfig 的更多介绍可以参考 [kubernetes中kubeconfig的用法]。(https://www.cnblogs.com/charlieroro/p/8489515.html)&lt;/p&gt;
&lt;p&gt;源码中，kubeconfig 变量记录了 kubeconfig 文件路径。通过 BuildConfigFromFlags 函数返回了一个 rest#Config 结构体实例。该实例记录了 kubeconfig 文件解析、处理后的信息。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;var kubeconfig *string
if home := homedir.HomeDir(); home != &quot;&quot; {
  kubeconfig = flag.String(&quot;kubeconfig&quot;, filepath.Join(home, &quot;.kube&quot;, &quot;config&quot;), &quot;(optional) absolute path to the kubeconfig file&quot;)
} else {
  kubeconfig = flag.String(&quot;kubeconfig&quot;, &quot;&quot;, &quot;absolute path to the kubeconfig file&quot;)
}
flag.Parse()

config, err := clientcmd.BuildConfigFromFlags(&quot;&quot;, *kubeconfig)
if err != nil {
  panic(err)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;BuildConfigFromFlags 函数是如何实例化 Config 结构体的呢？&lt;/p&gt;
&lt;p&gt;首先，BuildConfigFromFlags 函数接受一个 kubeconfigPath 变量，然后在内部依次调用如下函数：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;func NewNonInteractiveDeferredLoadingClientConfig(loader ClientConfigLoader, overrides *ConfigOverrides) ClientConfig&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;func (config *DeferredLoadingClientConfig) ClientConfig() (*restclient.Config, error)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func BuildConfigFromFlags(masterUrl, kubeconfigPath string) (*restclient.Config, error) {
  if kubeconfigPath == &quot;&quot; &amp;amp;&amp;amp; masterUrl == &quot;&quot; {
    ...
  }
  return NewNonInteractiveDeferredLoadingClientConfig(
    &amp;amp;ClientConfigLoadingRules{ExplicitPath: kubeconfigPath},
    &amp;amp;ConfigOverrides{ClusterInfo: clientcmdapi.Cluster{Server: masterUrl}}).ClientConfig()
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们来看看这两个链式调用的函数都做了哪些工作：&lt;/p&gt;
&lt;h3 id=&quot;toolsclientcmdnewnoninteractivedeferredloadingclientconfig&quot;&gt;3.1.1 tools/clientcmd#NewNonInteractiveDeferredLoadingClientConfig&lt;/h3&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func NewNonInteractiveDeferredLoadingClientConfig(loader ClientConfigLoader, overrides *ConfigOverrides) ClientConfig {
  return &amp;amp;DeferredLoadingClientConfig{loader: loader, overrides: overrides, icc: &amp;amp;inClusterClientConfig{overrides: overrides}}
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;返回值：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;返回一个 &lt;code&gt;tools/clientcmd#DirectClientConfig&lt;/code&gt; 类型的实例。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;DeferredLoadingClientConfig 结构体是 ClientConfig 接口的一种实现。主要工作是确保装载的 Config 实例使用的是最新 kubeconfig 数据（对于配置了多个集群的，export KUBECONFIG=cluster1-config:cluster2-config，需要执行 merge）。虽然本例子中还感受不到 Deferred Loading 体现在何处。源码注释中有这样一段话：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;It is used in cases where the loading rules may change after you've instantiated them and you want to be sure that the most recent rules are used. This is useful in cases where you bind flags to loading rule parameters before the parse happens and you want your calling code to be ignorant of how the values are being mutated to avoid passing extraneous information down a call stack&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;参数列表：&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;loader ClientConfigLoader：&lt;/p&gt;
&lt;p&gt;我的测试环境是通过单一的路径 &lt;code&gt;$HOME/.kube/config&lt;/code&gt; 获取 kubeconfig。但 kubeconfig 可能由不只一个配置文件 merge 而成，loader 确保在最终创建 Config 实例时，使用的是最新的 kubeconfig。loader 的 ExplicitPath 字段记录指定的 kubeconfig 文件路径，Precedence 字符串数组记录要 merge 的 kubeconfig 信息。这也是为什么返回值叫 &lt;strong&gt;Deferred Loading ClientConfig&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;loader 接受一个 ClientConfigLoader 接口实现，比如：&lt;code&gt;&amp;amp;ClientConfigLoadingRules{ExplicitPath: kubeconfigPath}&lt;/code&gt;（这里是地址类型，因为是 *ClientConfigLoadingRules 实现了 ClientConfigLoader 接口，而不是 ClientConfigLoadingRules）。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;overrides *ConfigOverrides：&lt;/p&gt;
&lt;p&gt;overtrides 保存用于强制覆盖 Config 实例的信息。本例中没有用到。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;deferredloadingclientconfig.clientconfig&quot;&gt;3.1.2 (*DeferredLoadingClientConfig).ClientConfig()&lt;/h3&gt;
&lt;p&gt;上一个函数返回了 ClientConfig 接口实例。这里调用 ClientConfig 接口定义的 ClientConfig() 方法。ClientConfig() 工作是解析、处理 kubeconfig 文件里的认证信息，并返回一个完整的 rest#Config 实例。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;// 错误处理省略
func (config *DeferredLoadingClientConfig) ClientConfig() (*restclient.Config, error) {
  mergedClientConfig, err := config.createClientConfig()
  ...

  // load the configuration and return on non-empty errors and if the
  // content differs from the default config
  mergedConfig, err := mergedClientConfig.ClientConfig()
  ...

  // check for in-cluster configuration and use it
  if config.icc.Possible() {
    klog.V(4).Infof(&quot;Using in-cluster configuration&quot;)
    return config.icc.ClientConfig()
  }

  // return the result of the merged client config
  return mergedConfig, err
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个函数主要有两个重要部分：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;mergedClientConfig, err := config.createClientConfig()&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;内部执行遍历 kubeconfig files （如果有多个）， 对每个 kubeconfig 执行 LoadFromFile 返回 tools/clientcmd/api#Config 实例。api#Config 顾名思义 api 包下的 Config，是把 kubeconfig （eg. $HOME/.kube/config） 序列化为一个 API 资源对象。&lt;/p&gt;
&lt;p&gt;现在,我们看到了几种结构体或接口命名相似，不要混淆了：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;api#Config：序列化 kubeconfig 文件后生成的对象&lt;/li&gt;
&lt;li&gt;tools/clientcmd#ClientConfig：负责用 api#Config 真正创建 rest#Config。处理、解析 kubeconfig 中的认证信息，有了它才能创建 rest#Config，所以命名叫 &lt;strong&gt;Client&lt;/strong&gt;Config&lt;/li&gt;
&lt;li&gt;rest#Config：用于创建 http 客户端&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于 merge 后的 api#Config，调用 NewNonInteractiveClientConfig 创建一个 ClientConfig 接口的实现。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;mergedConfig, err := mergedClientConfig.ClientConfig()&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;真正创建 rest#Config 的地方。在这里解析、处理 kubeconfig 中的认证信息。&lt;/p&gt;
&lt;h2 id=&quot;创建-clientset&quot;&gt;3.2 创建 ClientSet&lt;/h2&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;// NewForConfig creates a new Clientset for the given config.
config, err := clientcmd.BuildConfigFromFlags(&quot;&quot;, *kubeconfig)
if err != nil {
  panic(err)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ClientSet 是一个重要的对象。它就是负责访问集群 apiserver 的客户端。那为什么叫 ClientSet 呢？ 说明 Client 不止一个。比如 deployment 的 extensions/v1beta1、apps/v1beta、最新的 apps/v1 有多种版本（API Group），每种都有一个 Client 用于创建该版本的 deployment&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;// Clientset contains the clients for groups. Each group has exactly one
// version included in a Clientset.
type Clientset struct {
  ...
  appsV1                       *appsv1.AppsV1Client
  appsV1beta1                  *appsv1beta1.AppsV1beta1Client
  appsV1beta2                  *appsv1beta2.AppsV1beta2Client
  ...
  extensionsV1beta1            *extensionsv1beta1.ExtensionsV1beta1Client
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;创建一个-default-命名空间下的-appsv1deployment-资源&quot;&gt;3.3 创建一个 default 命名空间下的 apps/v1#deployment 资源&lt;/h2&gt;
&lt;h3 id=&quot;创建-deploymentsclient&quot;&gt;3.3.1 创建 deploymentsClient&lt;/h3&gt;
&lt;p&gt;创建 apps/v1 版本的 deployment，首先获得该版本的 client。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;deploymentsClient := clientset.AppsV1().Deployments(apiv1.NamespaceDefault)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;构造一个-appsv1deployment-实例&quot;&gt;3.3.2 构造一个 apps/v1#deployment 实例&lt;/h3&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;deployment := &amp;amp;appsv1.Deployment{
  ObjectMeta: metav1.ObjectMeta{
    Name: &quot;demo-deployment&quot;,  // 指定 deployment 名字
  },
  Spec: appsv1.DeploymentSpec{
    Replicas: int32Ptr(2), // 指定副本数
    Selector: &amp;amp;metav1.LabelSelector{  // 指定标签
      MatchLabels: map[string]string{
        &quot;app&quot;: &quot;demo&quot;,
      },
    },
    Template: apiv1.PodTemplateSpec{ // 容器模板
      ObjectMeta: metav1.ObjectMeta{
        Labels: map[string]string{
          &quot;app&quot;: &quot;demo&quot;,
        },
      },
      Spec: apiv1.PodSpec{
        ...
      },
    },
  },
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;向-apiserver-发送-post-创建-deployment&quot;&gt;3.3.3 向 apiserver 发送 POST 创建 deployment&lt;/h3&gt;
&lt;p&gt;有兴趣的朋友可以进一步看源码这里是如何实现 http client 的。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;result, err := deploymentsClient.Create(deployment)

---

// Create takes the representation of a deployment and creates it.  Returns the server's representation of the deployment, and an error, if there is any.
func (c *deployments) Create(deployment *v1.Deployment) (result *v1.Deployment, err error) {
  result = &amp;amp;v1.Deployment{}
  err = c.client.Post().
    Namespace(c.ns).
    Resource(&quot;deployments&quot;).
    Body(deployment).
    Do().
    Into(result)
  return
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至此，一个 deployment 就创建完成了。删、改、查操作也是一样。&lt;/p&gt;

&lt;p&gt;要搞彻底清楚 client-go，一方面要多查看 K8s 的 API 文档，另一方建议用 GoLand 单步调试，搞清楚每一步的含义。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://kubernetes.io/docs/tasks/administer-cluster/access-cluster-api/&quot;&gt;Access Clusters Using the Kubernetes API&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://kubernetes.io/docs/reference/using-api/api-concepts/#efficient-detection-of-changes&quot;&gt;Kubernetes API Concepts&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/charlieroro/p/8489515.html&quot;&gt;kubernetes中kubeconfig的用法&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 22 Apr 2019 15:53:00 +0000</pubDate>
<dc:creator>黄挤挤</dc:creator>
<og:description>本文通过解读 Kubernetes client-go 官方例子之一 Create, Update &amp; Delete Deployment ，详细介绍 client-go 原理和使用方法。该例子实现了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/guangze/p/10753929.html</dc:identifier>
</item>
<item>
<title>ansible playbook详细知识点（个人笔记加官网资料） - 魏俊峰</title>
<link>http://www.cnblogs.com/aaaaaaa/p/10753860.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/aaaaaaa/p/10753860.html</guid>
<description>&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1652795/201904/1652795-20190422220825092-466126572.png&quot; alt=&quot;&quot; width=&quot;259&quot; height=&quot;262&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;内容比较杂多,不太会调格式，你自己&lt;/strong&gt;ctrl F 方便查找哈 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;执行playbook命令  &lt;/strong&gt;&lt;br/&gt;&lt;span&gt;ansible­playbook ­i &quot;inventory文件名&quot; playbook.yml ­f 10  (并行级别10)&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;加参数&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;-e &quot;temp_file=${uuid}&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;­­extra­vars &quot;version=1.23.45 other_variable=foo&quot; ­­extra­vars&lt;/span&gt;&lt;br/&gt;&lt;span&gt;'{&quot;pacman&quot;:&quot;mrs&quot;,&quot;ghosts&quot;:[&quot;inky&quot;,&quot;pinky&quot;,&quot;clyde&quot;,&quot;sue&quot;]}' ­­extra­vars&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&quot;@some_file.json&quot;&lt;/span&gt;&lt;br/&gt;执行一个 playbook 之前,农想看看这个 playbook 的执行会影响到哪些 hosts,可&lt;br/&gt;以这样做:&lt;br/&gt;&lt;span&gt;ansible­playbook playbook.yml ­­--list-­hosts&lt;/span&gt;&lt;br/&gt;实践例子：https://github.com/ansible/ansible­examples   &lt;/p&gt;
&lt;p&gt; playbook.yml 文件like 可 this：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
--- &lt;br/&gt;- hosts: webservers,webservers2&lt;br/&gt;vars:     &lt;br/&gt;http_port: &lt;span&gt;80&lt;/span&gt;     &lt;br/&gt;max_clients: &lt;span&gt;200&lt;/span&gt;   &lt;br/&gt;remote_user: root   &lt;br/&gt;tasks:   &lt;br/&gt;- name: ensure apache &lt;span&gt;is&lt;/span&gt; at the latest version(确定是不是最新版本)&lt;br/&gt;yum: pkg=httpd state=latest&lt;br/&gt;remote_user: yourname&lt;br/&gt;- name: write the apache config file     &lt;br/&gt;template: src=/srv/httpd.j2 dest=/etc/httpd.conf     &lt;br/&gt;notify:     &lt;br/&gt;- restart apache   &lt;br/&gt;- name: ensure apache &lt;span&gt;is&lt;/span&gt; running     &lt;br/&gt;service: name=httpd state=started   &lt;br/&gt;handlers:     &lt;br/&gt;- name: restart apache       &lt;br/&gt;service: name=httpd state=restarted
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;inventory文件例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37.5&quot;&gt;
&lt;pre readability=&quot;8&quot;&gt;
[all:vars] &lt;br/&gt;DOCKERREGISTRY=kubernetes-master &lt;br/&gt;DOCKERREGISTRYPROT=&lt;span&gt;5000&lt;/span&gt; &lt;br/&gt;IMAGESVERSION=&lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;4&lt;/span&gt;-SNAPSHOT  &lt;br/&gt;[k8s_emu_vip_node] &lt;br/&gt;k8s_emu_vip_node1 ansible_ssh_host=&lt;span&gt;10.222&lt;/span&gt;.&lt;span&gt;2.201&lt;/span&gt; ansible_connection=ssh ansible_ssh_user=root ansible_ssh_pass=gsta123 ansible_ssh_extra_args=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-o StrictHostKeyChecking=no&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;    &lt;p&gt;[k8s_emu_node] &lt;br/&gt;k8s_emu_node1 ansible_ssh_host=&lt;span&gt;1.1&lt;/span&gt;.&lt;span&gt;1.1&lt;/span&gt; ansible_connection=ssh ansible_ssh_user=root ansible_ssh_pass=gsta123 ansible_ssh_extra_args=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-o StrictHostKeyChecking=no&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;   &lt;br/&gt;k8s_emu_node2 ansible_ssh_host=&lt;span&gt;1.1&lt;/span&gt;.&lt;span&gt;1.2&lt;/span&gt; ansible_connection=ssh ansible_ssh_user=root ansible_ssh_pass=gsta123 ansible_ssh_extra_args=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-o StrictHostKeyChecking=no&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;{{}}里进行操作，lookup插件，读取network_test_conf文件，然后作为变量&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
{{ lookup(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, network_test_conf) | from_yaml }}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;注册node，添加主机，添加组&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
- name: Register ansible node list  &lt;br/&gt;add_host:       &lt;br/&gt;hostname: '{{item[&quot;name&quot;]}}'       &lt;br/&gt;groups: 'fio-server'    &lt;br/&gt;#   ansible_ssh_host: '{{item.addresses[network_name] | selectattr(&quot;OS-EXT-IPS:type&quot;,&quot;equalto&quot;, &quot;floating&quot;)| map(attribute=&quot;addr&quot;) | join(&quot;,&quot;)}}'       &lt;br/&gt;ansible_ssh_host: '{{item.addresses[network_name] | selectattr(&quot;OS-EXT-IPS:type&quot;,&quot;equalto&quot;, &quot;fixed&quot;)| map(attribute=&quot;addr&quot;) | join(&quot;,&quot;)}}'       &lt;br/&gt;ansible_ssh_port: &quot;22&quot;       &lt;br/&gt;ansible_ssh_user: '{{image_ssh_user}}'       &lt;br/&gt;ansible_ssh_pass: '{{image_ssh_pass}}'       &lt;br/&gt;ansible_ssh_extra_args: &quot;-o StrictHostKeyChecking=no&quot;       &lt;br/&gt;ansible_sftp_extra_args: &quot;-o StrictHostKeyChecking=no&quot;              &lt;br/&gt;#ansible_ssh_extra_args: &quot;-o ProxyCommand='{{proxy}}' -o StrictHostKeyChecking=no&quot;       &lt;br/&gt;#ansible_sftp_extra_args: &quot;-o ProxyCommand='{{proxy}}' -o StrictHostKeyChecking=no&quot;  with_items: &quot;{{result.json.servers}}&quot;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;copy模块&lt;/strong&gt;[拷贝文件，从本地拷贝文件至各主机]&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
- name: Copy the keyfile &lt;span&gt;for&lt;/span&gt; authentication    &lt;br/&gt;copy: src=/wjf/weijunfeng dest={{ mongodb_datadir_prefix }}/secret owner=mongod group=mongod mode=&lt;span&gt;0400&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;fetch模块&lt;/strong&gt;，从各主机拷贝文件到本地，flat: &quot;yes&quot;表示不自动创建目录，如果为false，会自动创建带各自主机名的目录&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
fetch:  &lt;br/&gt;src: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/home/fio-result&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;  &lt;br/&gt;dest: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;./fio-test-result/{{ansible_ssh_host}}/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;  &lt;br/&gt;flat: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yes&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;创建文件或者目录，&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
- name: Create data directory for mongoc configuration server    &lt;br/&gt;file: path={{ mongodb_datadir_prefix }}/configdb state=directory owner=mongod group=mongod
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;l  path: 路径，一般用于创建删除文件或目录&lt;/p&gt;
&lt;p&gt;l  state: file的相关操作，&lt;/p&gt;
&lt;p&gt;       directory表示创建目录，&lt;/p&gt;
&lt;p&gt;       link表示创建软连接，link还需要源路径和目标路径配合使用&lt;/p&gt;
&lt;p&gt;       touch表示创建文件，&lt;/p&gt;
&lt;p&gt;       absent表示删除文件&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;执行shell命令&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;- name: Initialize the replication set   &lt;br/&gt;shell: /usr/bin/mongo --port &quot;&lt;/span&gt;{&lt;span&gt;{ mongod_port &lt;/span&gt;}&lt;span&gt;}&quot; /tmp/repset_init.js&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;暂停，等待&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;- name: pause   pause: seconds=20&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;service服务模块 比如启动nginx&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt; - name: Make sure nginx start with boot     &lt;br/&gt;service: name=nginx state=started enabled=yes&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;enabled&lt;/em&gt;：这个注意了，默认是&lt;em&gt;no&lt;/em&gt;，如果配置成&lt;em&gt;false&lt;/em&gt;就是&lt;em&gt;restart&lt;/em&gt;了之后就不关心结果了，配置成&lt;em&gt;yes&lt;/em&gt;是要关心结果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解压模块&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;- unarchive: src=foo.tgz dest=/var/lib/foo  &lt;br/&gt;- unarchive: src=/tmp/foo.zip dest=/usr/local/bin copy=no  &lt;br/&gt;- unarchive: src=https://example.com/example.zip dest=/usr/local/bin copy=no&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;unarchive模块&lt;/p&gt;
&lt;p&gt;用于解压文件，模块包含如下选项：&lt;/p&gt;
&lt;p&gt;copy：在解压文件之前，是否先将文件复制到远程主机，默认为yes。若为no，则要求目标主机上压缩包必须存在。&lt;/p&gt;
&lt;p&gt;creates：指定一个文件名，当该文件存在时，则解压指令不执行&lt;/p&gt;
&lt;p&gt;dest：远程主机上的一个路径，即文件解压的路径&lt;/p&gt;
&lt;p&gt;grop：解压后的目录或文件的属组&lt;/p&gt;
&lt;p&gt;list_files：如果为yes，则会列出压缩包里的文件，默认为no，2.0版本新增的选项&lt;/p&gt;
&lt;p&gt;mode：解决后文件的权限&lt;/p&gt;
&lt;p&gt;src：如果copy为yes，则需要指定压缩文件的源路径&lt;/p&gt;
&lt;p&gt;owner：解压后文件或目录的属主&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;yum模块&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;- name: remove epel if installed   &lt;br/&gt;yum:     &lt;br/&gt;name: epel-release     &lt;br/&gt;state: absent   &lt;br/&gt;ignore_errors: true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Wait_for模块：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;等待事情发生，例如等待数据库启动、web容器启动等。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;- name: wait for dnsmasq port 53   &lt;br/&gt;wait_for:     &lt;br/&gt;port: 53 &lt;br/&gt;timeout: 10&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;port：等待某端口号必须启动&lt;/p&gt;
&lt;p&gt;path：等待某文件必须创建&lt;/p&gt;
&lt;p&gt;host：默认是127.0.0.1，为了满足等待其它远程服务器的场景&lt;/p&gt;
&lt;p&gt;timeout的单位是秒&lt;/p&gt;
&lt;p&gt;state：默认是started，也就是等待启动或创建，也可能存在等待删除或停止等场景。对象是端口的时候start状态会确保端口是打开的，stoped状态会确认端口是关闭的;对象是文件的时候，present或者started会确认文件是存在的，而absent会确认文件是不存在的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Git模块&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于git版本服务的操作模块&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;- name: ANSISTRANO | GIT | Update remote repository   &lt;br/&gt;git:     &lt;br/&gt;repo: &quot;&lt;/span&gt;{&lt;span&gt;{ ansistrano_git_repo &lt;/span&gt;}&lt;span&gt;}&quot;     &lt;br/&gt;dest: &quot;&lt;/span&gt;{&lt;span&gt;{ ansistrano_deploy_to &lt;/span&gt;}&lt;span&gt;}/repo&quot;     &lt;br/&gt;version: &quot;&lt;/span&gt;{&lt;span&gt;{ ansistrano_git_branch &lt;/span&gt;}&lt;span&gt;}&quot;     &lt;br/&gt;accept_hostkey: true     &lt;br/&gt;update: yes     &lt;br/&gt;force: yes   &lt;br/&gt;register: ansistrano_git_result_update   &lt;br/&gt;when: ansistrano_git_identity_key_path|trim == '' and ansistrano_git_identity_key_remote_path|trim == ''&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;repo：git仓库的地址&lt;/p&gt;
&lt;p&gt;dest：仓库中的相对目录&lt;/p&gt;
&lt;p&gt;version：哪个版本&lt;/p&gt;
&lt;p&gt;accept_hostkey：如果ssh_opts包含” -o StrictHostKeyChecking=no”，此参数可以省略，如果配置成true或yes，需要添加hostkey&lt;/p&gt;
&lt;p&gt;update：是否要更新新版本&lt;/p&gt;
&lt;p&gt;force：配置成yes，本地仓库将永远被仓库服务端覆盖&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;get_url模块&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;也就是download操作：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
- name: codelivery | download | Download artifact   &lt;br/&gt;get_url:     &lt;br/&gt;url: &quot;{{ codelivery_product_url }}&quot;     &lt;br/&gt;dest: &quot;{{ codelivery_releases_dir }}/{{ codelivery_product_url | basename }}&quot;     &lt;br/&gt;force_basic_auth: &quot;{{ codelivery_download_force_basic_auth | default(omit) }}&quot;     &lt;br/&gt;headers: &quot;{{ codelivery_download_headers | default(omit) }}&quot;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;url：http的地址&lt;/p&gt;
&lt;p&gt;dest：下载文件到目的机的路径&lt;/p&gt;
&lt;p&gt;force_basic_auth：在发起请求前是否发出权限校验信息&lt;/p&gt;
&lt;p&gt;headers：报文头信息&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;uri模块&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比get_url功能更强大的http请求模块，可以发起get、post、put等各种请求方式，也可以处理返回值及内容&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
- name: codelivery | healthcheck | urlcheck status==200?   &lt;br/&gt;uri:     &lt;br/&gt;url: &quot;http://{{ codelivery_urlcheck_addr }}:{{ codelivery_urlcheck_port }}{{ codelivery_urlcheck_url }}&quot;     &lt;br/&gt;method: GET     &lt;br/&gt;headers:       &lt;br/&gt;Host: &quot;{{ codelivery_urlcheck_host }}&quot;     &lt;br/&gt;timeout: 10     &lt;br/&gt;status_code: 200     &lt;br/&gt;return_content: no
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;debug模块&lt;/strong&gt; 打印出变量&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
- debug: msg=&quot;heat_failed_reason={{reason.stdout}}&quot;   &lt;br/&gt;when: result.stdout==&quot;CREATE_FAILED&quot;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;常用魔数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ansible_distribution=Ubuntu&lt;/p&gt;
&lt;p&gt;ansible_distribution_version=14.04&lt;/p&gt;
&lt;p&gt;ansible_distribution_major_version：系统的大版本号&lt;/p&gt;
&lt;p&gt;ansible_os_family：系统的操作系统(‘RedHat’,’Debian’,’FreeBSD’)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;自定义局部变量并赋值&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
- name: Define nginx_user.   &lt;br/&gt;set_fact:     &lt;br/&gt;nginx_user: &quot;{{ __nginx_user }}&quot;   &lt;br/&gt;when: nginx_user is not defined
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;支持从 sudo 执行命令:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
--- 
 -&lt;span&gt; hosts: webservers   
   remote_user: yourname   &lt;br/&gt;sudo: yes&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以登陆后,sudo 到不同的用户身份,而不是使用 root:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
---&lt;br/&gt;- hosts: webservers  &lt;br/&gt;remote_user: yourname  &lt;br/&gt;sudo: yes  &lt;br/&gt;sudo_user: postgres
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果需要在使用 sudo 时指定密码,可在运行 &lt;em&gt;ansible-playbook&lt;/em&gt; 命令时加上选项 --ask-sudo-pass (&lt;em&gt;-K&lt;/em&gt;). 如果使用 sudo 时,playbook 疑似被挂起,可能是在 sudo prompt 处被卡住,这时可执行 &lt;em&gt;Control-C&lt;/em&gt; 杀死卡住的任务,再重新运行一次.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;service moudle&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
tasks:   &lt;br/&gt;- name: make sure apache is running     &lt;br/&gt;service: name=httpd state=running
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;command&lt;/em&gt; 和 &lt;em&gt;shell&lt;/em&gt; ,它们不使用 key=value 格式的参数:[执行命令，linux命令]&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
tasks:   &lt;br/&gt;- name: disable selinux     &lt;br/&gt;command: /sbin/setenforce 0
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;command module 和 shell module 时,需要关心返回码信息,如果有一条命令,它的成功执行的返回码不是0, 意思就是执行命令不成功，你可以通过下面例子进行忽略[忽略错误，跳过报错]：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
tasks:   &lt;br/&gt;- name: run &lt;span&gt;this&lt;/span&gt; command and ignore the result     &lt;br/&gt;shell: /usr/bin/somecommand || /bin/true&lt;br/&gt;或者：&lt;br/&gt;tasks:   &lt;br/&gt;- name: run this command and ignore the result     &lt;br/&gt;shell: /usr/bin/somecommand     &lt;br/&gt;ignore_errors: True
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;假设在 ‘vars’ 那里定义了一个变量 ‘vhost’ ,可以这样使用:{{}}  [使用参数方法]&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
tasks:   &lt;br/&gt;- name: create a virtual host file &lt;span&gt;for&lt;/span&gt; {{ vhost }}     &lt;br/&gt;template: src=somefile.j2 dest=/etc/httpd/conf.d/{{ vhost }}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;‘notify’ 下列出的即是 handlers，比如当一个文件的内容被改动时,重启两个 services:[文件改变时执行]&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
- name: template configuration file   &lt;br/&gt;template: src=template.j2 dest=/etc/foo.conf   &lt;br/&gt;notify:      &lt;br/&gt;- restart memcached      &lt;br/&gt;- restart apache
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Handlers 也是一些 task 的列表,通过名字来引用,它们和一般的 task 并没有什么区别.Handlers 是由通知者进行 notify, 如果没有被 notify,handlers 不会执行.不管有多少个通知者进行了 notify,等到 play 中的所有 task 执行完成之后,handlers 也只会被执行一次，handlers 例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 handlers:     &lt;br/&gt;- name: restart memcached       &lt;br/&gt;service:  name=memcached state=restarted     &lt;br/&gt;- name: restart apache       &lt;br/&gt;service: name=apache state=restarted&lt;br/&gt;- include: handlers/handlers.yml
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;include指令&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;一个 task include file foo.yml 由一个普通的 task 列表所组成，像这样:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
--- &lt;br/&gt;# possibly saved as tasks/foo.yml  &lt;br/&gt;- name: placeholder foo   &lt;br/&gt;command: /bin/foo  &lt;br/&gt;- name: placeholder bar   &lt;br/&gt;command: /bin/bar
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Include 指令可以跟普通的 task 混合，所以呢，你可以这样使用(后面可以加参数):[include参数]&lt;/p&gt;
&lt;p&gt;tasks:   - include: tasks/foo.yml  wp_user=timmy&lt;/p&gt;
&lt;p&gt;如果Ansible 1.4 及以后的版本，include 语法可更为精简&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;tasks: 

   &lt;/span&gt;- { include: wordpress.yml, wp_user: timmy, ssh_keys: [ 'keys/one.txt', 'keys/two.txt' ] }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从 1.0 版开始，Ansible 支持另一种传递变量到 include files 的语法，这种语法支持结构化的变量:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;tasks:  

  &lt;/span&gt;-&lt;span&gt; include: wordpress.yml    

    vars:        

      wp_user: timmy        

      some_list_variable:          

           &lt;/span&gt;-&lt;span&gt; alpha          

           &lt;/span&gt;-&lt;span&gt; beta          

           &lt;/span&gt;- gamma
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;Roles&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; Roles 基于一个已知的文件结构，去自动的加载某些 vars_files，tasks 以及 handlers。基于 roles 对内容进行分组&lt;/p&gt;
&lt;p&gt;roles目录结构如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
site.yml &lt;br/&gt;webservers.yml &lt;br/&gt;fooservers.yml &lt;br/&gt;roles/    &lt;br/&gt;common/      &lt;br/&gt;files/      &lt;br/&gt;templates/      &lt;br/&gt;tasks/      &lt;br/&gt;handlers/      &lt;br/&gt;vars/      &lt;br/&gt;defaults/      &lt;br/&gt;meta/    &lt;br/&gt;webservers/      &lt;br/&gt;files/      &lt;br/&gt;templates/      &lt;br/&gt;tasks/      &lt;br/&gt;handlers/      &lt;br/&gt;vars/      &lt;br/&gt;defaults/      &lt;br/&gt;meta/
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;哥哥姐姐们可以这样使用roles&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
--- &lt;br/&gt;- hosts: webservers   &lt;br/&gt;roles:      &lt;br/&gt;- common      &lt;br/&gt;- webservers
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个 playbook 为一个角色 ‘x’ 指定了如下的行为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;l  如果 roles/x/tasks/main.yml 存在, 其中列出的 tasks 将被添加到 play 中&lt;/li&gt;
&lt;li&gt;l  如果 roles/x/handlers/main.yml 存在, 其中列出的 handlers 将被添加到 play 中&lt;/li&gt;
&lt;li&gt;l  如果 roles/x/vars/main.yml 存在, 其中列出的 variables 将被添加到 play 中&lt;/li&gt;
&lt;li&gt;l  如果 roles/x/meta/main.yml 存在, 其中列出的 “角色依赖” 将被添加到 roles 列表中 (1.3 and later)&lt;/li&gt;
&lt;li&gt;l  所有 copy tasks 可以引用 roles/x/files/ 中的文件，不需要指明文件的路径。&lt;/li&gt;
&lt;li&gt;l  所有 script tasks 可以引用 roles/x/files/ 中的脚本，不需要指明文件的路径。&lt;/li&gt;
&lt;li&gt;l  所有 template tasks 可以引用 roles/x/templates/ 中的文件，不需要指明文件的路径。&lt;/li&gt;
&lt;li&gt;l  所有 include tasks 可以引用 roles/x/tasks/ 中的文件，不需要指明文件的路径。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在 Ansible 1.4 及之后版本，你可以为”角色”的搜索设定 roles_path 配置项。使用这个配置项将所有的 common 角色 check out 到一个位置，以便在多个 playbook 项目中可方便的共享使用它们&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
roles_path = /opt/mysite/roles
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果 roles 目录下有文件不存在，这些文件将被忽略。比如 roles 目录下面缺少了 ‘vars/’ 目录，这也没关系。&lt;/p&gt;
&lt;p&gt;roles带参数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
--- &lt;br/&gt;- hosts: webservers  &lt;br/&gt;roles:     &lt;br/&gt;- common     &lt;br/&gt;- { role: foo_app_instance, dir: '/opt/a',  port: 5000 }     &lt;br/&gt;- { role: foo_app_instance, dir: '/opt/b',  port: 5001 }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;roles带条件，when&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
--- &lt;br/&gt;- hosts: webservers   &lt;br/&gt;roles:     &lt;br/&gt;- { role: some_role, when: &quot;ansible_os_family == 'RedHat'&quot; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;roles分配tags&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
--- &lt;br/&gt;- hosts: webservers   &lt;br/&gt;roles:     &lt;br/&gt;- { role: foo, tags: [&quot;bar&quot;, &quot;baz&quot;] }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果 play 仍然包含有 ‘tasks’ section，这些 tasks 将在所有 roles 应用完成之后才被执行。&lt;/p&gt;
&lt;p&gt;如果你希望定义一些 tasks，让它们在 roles 之前以及之后执行，大佬你可以这样做:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
--- &lt;br/&gt;- hosts: webservers    &lt;br/&gt;pre_tasks:     &lt;br/&gt;- shell: echo 'hello'    &lt;br/&gt;roles:     &lt;br/&gt;- { role: some_role }    &lt;br/&gt;tasks:     &lt;br/&gt;- shell: echo 'still busy'    &lt;br/&gt;post_tasks:     &lt;br/&gt;- shell: echo 'goodbye'
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;角色默认变量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;要创建默认变量，只需在 roles 目录下添加 &lt;em&gt;defaults/main.yml&lt;/em&gt; 文件。这些变量在所有可用变量中拥有最低优先级，可能被其他地方定义的变量(包括 inventory 中的变量)所覆盖。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;角色依赖&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;“角色依赖” 使你可以自动地将其他 roles 拉取到现在使用的 role 中。”角色依赖” 保存在 roles 目录下的 &lt;em&gt;meta/main.yml&lt;/em&gt; 文件中。这个文件应包含一列 roles 和 为之指定的参数，下面是在 &lt;em&gt;roles/myapp/meta/main.yml&lt;/em&gt; 文件中的示例:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
--- &lt;br/&gt;dependencies:   &lt;br/&gt;- { role: common, some_parameter: 3 }   &lt;br/&gt;- { role: apache, port: 80 }   &lt;br/&gt;- { role: postgres, dbname: blarg, other_parameter: 12 }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;“角色依赖” 也可以通过源码控制仓库或者 tar 文件指定，使用逗号分隔：路径、一个可选的版本（tag, commit, branch 等等）、一个可选友好角色名（尝试从源码仓库名或者归档文件名中派生出角色名）:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
--- dependencies:   &lt;br/&gt;- { role: 'git+http://git.example.com/repos/role-foo,v1.1,foo' }   &lt;br/&gt;- { role: '/path/to/tar/file.tgz,,friendly-name' }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;“角色依赖” 总是在 role （包含”角色依赖”的role）之前执行，并且是递归地执行。默认情况下，作为 “角色依赖” 被添加的 role 只能被添加一次，如果另一个 role 将一个相同的角色列为 “角色依赖” 的对象，它不会被重复执行。但这种默认的行为可被修改，通过添加 &lt;em&gt;allow_duplicates: yes&lt;/em&gt; 到&lt;em&gt;meta/main.yml&lt;/em&gt; 文件中。 比如，一个 role 名为 ‘car’，它可以添加名为 ‘wheel’ 的 role 到它的 “角色依赖” 中:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
--- &lt;br/&gt;dependencies: &lt;br/&gt;- { role: wheel, n: 1 } &lt;br/&gt;- { role: wheel, n: 2 } &lt;br/&gt;- { role: wheel, n: 3 } &lt;br/&gt;- { role: wheel, n: 4 }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;wheel 角色的 &lt;em&gt;meta/main.yml&lt;/em&gt; 文件包含如下内容:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
--- &lt;br/&gt;allow_duplicates: yes &lt;br/&gt;dependencies: &lt;br/&gt;- { role: tire } &lt;br/&gt;- { role: brake }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最终的执行顺序是这样的:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
tire(n=1)&lt;br/&gt;brake(n=1)&lt;br/&gt;wheel(n=1)&lt;br/&gt;tire(n=2)&lt;br/&gt;brake(n=2)&lt;br/&gt;wheel(n=2)&lt;br/&gt;...&lt;br/&gt;car
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;YAML语法要求如果值以{{ foo }}开头的话我们需要将整行用双引号包起来.这是为了确认你不是想声明一个YAML字典&lt;/p&gt;
&lt;p&gt;这样是不行的:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
- hosts: app_servers   &lt;br/&gt;vars:       &lt;br/&gt;app_path: {{ base_path }}/22
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;你应该这么做:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
- hosts: app_servers   &lt;br/&gt;vars:        &lt;br/&gt;app_path: &quot;{{ base_path }}/22&quot;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Facts通过访问远程系统获取相应的信息. 一个例子就是远程主机的IP地址或者操作系统是什么. 使用以下命令可以查看哪些信息是可用的:[查看主机信息]&lt;/p&gt;
&lt;p&gt;如果你不需要使用你主机的任何fact数据,你已经知道了你系统的一切,那么你可以关闭fact数据的获取.这有利于增强Ansilbe面对大量系统的push模块,或者你在实验性平台中使用Ansible.在任何playbook中可以这样做:[关闭facts]&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
- hosts: whatever   &lt;br/&gt;gather_facts: no
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;获取主机名 {{ ansible_nodename }}&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;ansible hostname -m setup   &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;命令输出如下：（哇这格式真的没法调，，米娜桑将就看，或者拷贝到notepad ，然后转成json）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &quot;ansible_all_ipv4_addresses&quot;: [     &quot;REDACTED IP ADDRESS&quot; ], &quot;ansible_all_ipv6_addresses&quot;: [     &quot;REDACTED IPV6 ADDRESS&quot; ], &quot;ansible_architecture&quot;: &quot;x86_64&quot;, &quot;ansible_bios_date&quot;: &quot;09/20/2012&quot;, &quot;ansible_bios_version&quot;: &quot;6.00&quot;, &quot;ansible_cmdline&quot;: {     &quot;BOOT_IMAGE&quot;: &quot;/boot/vmlinuz-3.5.0-23-generic&quot;,     &quot;quiet&quot;: true,     &quot;ro&quot;: true,     &quot;root&quot;: &quot;UUID=4195bff4-e157-4e41-8701-e93f0aec9e22&quot;,     &quot;splash&quot;: true }, &quot;ansible_date_time&quot;: {     &quot;date&quot;: &quot;2013-10-02&quot;,     &quot;day&quot;: &quot;02&quot;,     &quot;epoch&quot;: &quot;1380756810&quot;,     &quot;hour&quot;: &quot;19&quot;,     &quot;iso8601&quot;: &quot;2013-10-02T23:33:30Z&quot;,     &quot;iso8601_micro&quot;: &quot;2013-10-02T23:33:30.036070Z&quot;,     &quot;minute&quot;: &quot;33&quot;,     &quot;month&quot;: &quot;10&quot;,     &quot;second&quot;: &quot;30&quot;,     &quot;time&quot;: &quot;19:33:30&quot;,     &quot;tz&quot;: &quot;EDT&quot;,     &quot;year&quot;: &quot;2013&quot; }, &quot;ansible_default_ipv4&quot;: {     &quot;address&quot;: &quot;REDACTED&quot;,     &quot;alias&quot;: &quot;eth0&quot;,     &quot;gateway&quot;: &quot;REDACTED&quot;,     &quot;interface&quot;: &quot;eth0&quot;,     &quot;macaddress&quot;: &quot;REDACTED&quot;,     &quot;mtu&quot;: 1500,     &quot;netmask&quot;: &quot;255.255.255.0&quot;,     &quot;network&quot;: &quot;REDACTED&quot;,     &quot;type&quot;: &quot;ether&quot; }, &quot;ansible_default_ipv6&quot;: {}, &quot;ansible_devices&quot;: {     &quot;fd0&quot;: {         &quot;holders&quot;: [],         &quot;host&quot;: &quot;&quot;,         &quot;model&quot;: null,         &quot;partitions&quot;: {},         &quot;removable&quot;: &quot;1&quot;,         &quot;rotational&quot;: &quot;1&quot;,         &quot;scheduler_mode&quot;: &quot;deadline&quot;,         &quot;sectors&quot;: &quot;0&quot;,         &quot;sectorsize&quot;: &quot;512&quot;,         &quot;size&quot;: &quot;0.00 Bytes&quot;,         &quot;support_discard&quot;: &quot;0&quot;,         &quot;vendor&quot;: null     },     &quot;sda&quot;: {         &quot;holders&quot;: [],         &quot;host&quot;: &quot;SCSI storage controller: LSI Logic / Symbios Logic 53c1030 PCI-X Fusion-MPT Dual Ultra320 SCSI (rev 01)&quot;,         &quot;model&quot;: &quot;VMware Virtual S&quot;,         &quot;partitions&quot;: {             &quot;sda1&quot;: {                 &quot;sectors&quot;: &quot;39843840&quot;,                 &quot;sectorsize&quot;: 512,                 &quot;size&quot;: &quot;19.00 GB&quot;,                 &quot;start&quot;: &quot;2048&quot;             },             &quot;sda2&quot;: {                 &quot;sectors&quot;: &quot;2&quot;,                 &quot;sectorsize&quot;: 512,                 &quot;size&quot;: &quot;1.00 KB&quot;,                 &quot;start&quot;: &quot;39847934&quot;             },             &quot;sda5&quot;: {                 &quot;sectors&quot;: &quot;2093056&quot;,                 &quot;sectorsize&quot;: 512,                 &quot;size&quot;: &quot;1022.00 MB&quot;,                 &quot;start&quot;: &quot;39847936&quot;             }         },         &quot;removable&quot;: &quot;0&quot;,         &quot;rotational&quot;: &quot;1&quot;,         &quot;scheduler_mode&quot;: &quot;deadline&quot;,         &quot;sectors&quot;: &quot;41943040&quot;,         &quot;sectorsize&quot;: &quot;512&quot;,         &quot;size&quot;: &quot;20.00 GB&quot;,         &quot;support_discard&quot;: &quot;0&quot;,         &quot;vendor&quot;: &quot;VMware,&quot;     },     &quot;sr0&quot;: {         &quot;holders&quot;: [],         &quot;host&quot;: &quot;IDE interface: Intel Corporation 82371AB/EB/MB PIIX4 IDE (rev 01)&quot;,         &quot;model&quot;: &quot;VMware IDE CDR10&quot;,         &quot;partitions&quot;: {},         &quot;removable&quot;: &quot;1&quot;,         &quot;rotational&quot;: &quot;1&quot;,         &quot;scheduler_mode&quot;: &quot;deadline&quot;,         &quot;sectors&quot;: &quot;2097151&quot;,         &quot;sectorsize&quot;: &quot;512&quot;,         &quot;size&quot;: &quot;1024.00 MB&quot;,         &quot;support_discard&quot;: &quot;0&quot;,         &quot;vendor&quot;: &quot;NECVMWar&quot;     } }, &quot;ansible_distribution&quot;: &quot;Ubuntu&quot;, &quot;ansible_distribution_release&quot;: &quot;precise&quot;, &quot;ansible_distribution_version&quot;: &quot;12.04&quot;, &quot;ansible_domain&quot;: &quot;&quot;, &quot;ansible_env&quot;: {     &quot;COLORTERM&quot;: &quot;gnome-terminal&quot;,     &quot;DISPLAY&quot;: &quot;:0&quot;,     &quot;HOME&quot;: &quot;/home/mdehaan&quot;,     &quot;LANG&quot;: &quot;C&quot;,     &quot;LESSCLOSE&quot;: &quot;/usr/bin/lesspipe %s %s&quot;,     &quot;LESSOPEN&quot;: &quot;| /usr/bin/lesspipe %s&quot;,     &quot;LOGNAME&quot;: &quot;root&quot;,     &quot;LS_COLORS&quot;: &quot;rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arj=01;31:*.taz=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.lz=01;31:*.xz=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.jpg=01;35:*.jpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.axv=01;35:*.anx=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.axa=00;36:*.oga=00;36:*.spx=00;36:*.xspf=00;36:&quot;,     &quot;MAIL&quot;: &quot;/var/mail/root&quot;,     &quot;OLDPWD&quot;: &quot;/root/ansible/docsite&quot;,     &quot;PATH&quot;: &quot;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;,     &quot;PWD&quot;: &quot;/root/ansible&quot;,     &quot;SHELL&quot;: &quot;/bin/bash&quot;,     &quot;SHLVL&quot;: &quot;1&quot;,     &quot;SUDO_COMMAND&quot;: &quot;/bin/bash&quot;,     &quot;SUDO_GID&quot;: &quot;1000&quot;,     &quot;SUDO_UID&quot;: &quot;1000&quot;,     &quot;SUDO_USER&quot;: &quot;mdehaan&quot;,     &quot;TERM&quot;: &quot;xterm&quot;,     &quot;USER&quot;: &quot;root&quot;,     &quot;USERNAME&quot;: &quot;root&quot;,     &quot;XAUTHORITY&quot;: &quot;/home/mdehaan/.Xauthority&quot;,     &quot;_&quot;: &quot;/usr/local/bin/ansible&quot; }, &quot;ansible_eth0&quot;: {     &quot;active&quot;: true,     &quot;device&quot;: &quot;eth0&quot;,     &quot;ipv4&quot;: {         &quot;address&quot;: &quot;REDACTED&quot;,         &quot;netmask&quot;: &quot;255.255.255.0&quot;,         &quot;network&quot;: &quot;REDACTED&quot;     },     &quot;ipv6&quot;: [         {             &quot;address&quot;: &quot;REDACTED&quot;,             &quot;prefix&quot;: &quot;64&quot;,             &quot;scope&quot;: &quot;link&quot;         }     ],     &quot;macaddress&quot;: &quot;REDACTED&quot;,     &quot;module&quot;: &quot;e1000&quot;,     &quot;mtu&quot;: 1500,     &quot;type&quot;: &quot;ether&quot; }, &quot;ansible_form_factor&quot;: &quot;Other&quot;, &quot;ansible_fqdn&quot;: &quot;ubuntu2.example.com&quot;, &quot;ansible_hostname&quot;: &quot;ubuntu2&quot;, &quot;ansible_interfaces&quot;: [     &quot;lo&quot;,     &quot;eth0&quot; ], &quot;ansible_kernel&quot;: &quot;3.5.0-23-generic&quot;, &quot;ansible_lo&quot;: {     &quot;active&quot;: true,     &quot;device&quot;: &quot;lo&quot;,     &quot;ipv4&quot;: {         &quot;address&quot;: &quot;127.0.0.1&quot;,         &quot;netmask&quot;: &quot;255.0.0.0&quot;,         &quot;network&quot;: &quot;127.0.0.0&quot;     },     &quot;ipv6&quot;: [         {             &quot;address&quot;: &quot;::1&quot;,             &quot;prefix&quot;: &quot;128&quot;,             &quot;scope&quot;: &quot;host&quot;         }     ],     &quot;mtu&quot;: 16436,     &quot;type&quot;: &quot;loopback&quot; }, &quot;ansible_lsb&quot;: {     &quot;codename&quot;: &quot;precise&quot;,     &quot;description&quot;: &quot;Ubuntu 12.04.2 LTS&quot;,     &quot;id&quot;: &quot;Ubuntu&quot;,     &quot;major_release&quot;: &quot;12&quot;,     &quot;release&quot;: &quot;12.04&quot; }, &quot;ansible_machine&quot;: &quot;x86_64&quot;, &quot;ansible_memfree_mb&quot;: 74, &quot;ansible_memtotal_mb&quot;: 991, &quot;ansible_mounts&quot;: [     {         &quot;device&quot;: &quot;/dev/sda1&quot;,         &quot;fstype&quot;: &quot;ext4&quot;,         &quot;mount&quot;: &quot;/&quot;,         &quot;options&quot;: &quot;rw,errors=remount-ro&quot;,         &quot;size_available&quot;: 15032406016,         &quot;size_total&quot;: 20079898624     } ], &quot;ansible_nodename&quot;: &quot;ubuntu2.example.com&quot;, &quot;ansible_os_family&quot;: &quot;Debian&quot;, &quot;ansible_pkg_mgr&quot;: &quot;apt&quot;, &quot;ansible_processor&quot;: [     &quot;Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz&quot; ], &quot;ansible_processor_cores&quot;: 1, &quot;ansible_processor_count&quot;: 1, &quot;ansible_processor_threads_per_core&quot;: 1, &quot;ansible_processor_vcpus&quot;: 1, &quot;ansible_product_name&quot;: &quot;VMware Virtual Platform&quot;, &quot;ansible_product_serial&quot;: &quot;REDACTED&quot;, &quot;ansible_product_uuid&quot;: &quot;REDACTED&quot;, &quot;ansible_product_version&quot;: &quot;None&quot;, &quot;ansible_python_version&quot;: &quot;2.7.3&quot;, &quot;ansible_selinux&quot;: false, &quot;ansible_ssh_host_key_dsa_public&quot;: &quot;REDACTED KEY VALUE&quot; &quot;ansible_ssh_host_key_ecdsa_public&quot;: &quot;REDACTED KEY VALUE&quot; &quot;ansible_ssh_host_key_rsa_public&quot;: &quot;REDACTED KEY VALUE&quot; &quot;ansible_swapfree_mb&quot;: 665, &quot;ansible_swaptotal_mb&quot;: 1021, &quot;ansible_system&quot;: &quot;Linux&quot;, &quot;ansible_system_vendor&quot;: &quot;VMware, Inc.&quot;, &quot;ansible_user_id&quot;: &quot;root&quot;, &quot;ansible_userspace_architecture&quot;: &quot;x86_64&quot;, &quot;ansible_userspace_bits&quot;: &quot;64&quot;, &quot;ansible_virtualization_role&quot;: &quot;guest&quot;, &quot;ansible_virtualization_type&quot;: &quot;VMware&quot;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本地Facts&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果远程受管理的机器有一个 “/etc/ansible/facts.d” 目录,那么在该目录中任何以 ”.fact”结尾的文件都可以在Ansible中提供局部facts.这些文件可以是JSON,INI或者任何可以返回JSON的可执行文件.&lt;/p&gt;
&lt;p&gt;例如建设有一个 /etc/ansible/facts.d/perferences.fact文件:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
[general]&lt;br/&gt;asdf=1&lt;br/&gt;bar=2
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这将产生一个名为 “general” 的哈希表fact,里面成员有 ‘asdf’ 和 ‘bar’. 可以这样验证:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
ansible &amp;lt;hostname&amp;gt; -m setup -a &quot;filter=ansible_local&quot;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后你会看到有以下fact被添加:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&quot;ansible_local&quot;: {         &lt;br/&gt;&quot;preferences&quot;: {             &lt;br/&gt;&quot;general&quot;: {                 &lt;br/&gt;&quot;asdf&quot; : &quot;1&quot;,                &lt;br/&gt;&quot;bar&quot;  : &quot;2&quot;             }         }  }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而且也可以在template或palybook中访问该数据:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
{{ ansible_local.preferences.general.asdf }}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;本地命名空间放置其它用户提供的fact或者playbook中定义的变量覆盖系统facts值.&lt;/p&gt;
&lt;p&gt;如果你有个一个playook,它复制了一个自定义的fact,然后运行它,请显式调用来重新运行setup模块,这样可以让我们在该playbook中使用这些fact.否则,在下一个play中才能获取这些自定义的fact信息.这里有一个示例:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
- hosts: webservers   &lt;br/&gt;tasks:     &lt;br/&gt;- name: create directory &lt;span&gt;for&lt;/span&gt; ansible custom facts       &lt;br/&gt;file: state=directory recurse=yes path=/etc/ansible/facts.d     &lt;br/&gt;- name: install custom impi fact       &lt;br/&gt;copy: src=ipmi.fact dest=/etc/ansible/facts.d     &lt;br/&gt;- name: re-read facts after adding custom fact       &lt;br/&gt;setup: filter=ansible_local
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然而在该模式中你也可以编写一个fact模块,这只不过是多了一个选项.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Fact&lt;/strong&gt;&lt;strong&gt;缓存&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从一个服务器引用另一个服务器的变量是可行的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
{{ hostvars['asdf.example.com']['ansible_os_family'] }}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;注册变量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; register&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre readability=&quot;5&quot;&gt;
- hosts: web_servers   &lt;br/&gt;tasks:      &lt;br/&gt;- shell: /usr/bin/foo        &lt;br/&gt;register: foo_result        &lt;br/&gt;ignore_errors: True       &lt;p&gt;- shell: /usr/bin/bar        &lt;br/&gt;when: foo_result.rc == 5
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;魔法变量,以及如何访问其它主机的信息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Ansible会自动提供给你一些变量,即使你并没有定义过它们.这些变量中重要的有 ‘hostvars’,’group_names’,和 ‘groups’.由于这些变量名是预留的,所以用户不应当覆盖它们. ‘environmen’ 也是预留的. hostvars可以让你访问其它主机的变量,包括哪些主机中获取到的facts.如果你还没有在当前playbook或者一组playbook的任何play中访问那个主机,那么你可以获取变量,但无法看到facts值. 如果数据库服务器想使用另一个节点的某个 ‘fact’ 值,或者赋值给该节点的一个inventory变量.可以在一个模板中甚至命令行中轻松实现:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
{{ hostvars['test.example.com']['ansible_distribution'] }}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另外, &lt;em&gt;group_names&lt;/em&gt; 是当前主机所在所有群组的列表(数组).所以可以使用Jinja2语法在模板中根据该主机所在群组关系(或角色)来产生变化:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
{% &lt;span&gt;if&lt;/span&gt; 'webserver' &lt;span&gt;in&lt;/span&gt; group_names %}   &lt;br/&gt;　　 # some part of a configuration file that only applies to webservers &lt;br/&gt;{% endif %}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;groups&lt;/em&gt; 是inventory中所有群组(主机)的列表.可用于枚举群组中的所有主机.例如:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
{% &lt;span&gt;for&lt;/span&gt; host &lt;span&gt;in&lt;/span&gt; groups['app_servers'] %}    &lt;br/&gt;　　# something that applies to all app servers. &lt;br/&gt;{% endfor %}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一个经常使用的范式是找出该群组中的所有IP地址:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
{% &lt;span&gt;for&lt;/span&gt; host &lt;span&gt;in&lt;/span&gt; groups['app_servers'] %}   &lt;br/&gt;　　 {{ hostvars[host]['ansible_eth0']['ipv4']['address'] }}&lt;br/&gt;{% endfor %}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;外部的变量文件:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre readability=&quot;5&quot;&gt;
--- &lt;br/&gt;- hosts: all   &lt;br/&gt;remote_user: root   &lt;br/&gt;vars:    &lt;br/&gt;favcolor: blue  &lt;br/&gt;vars_files:     &lt;br/&gt;- /vars/external_vars.yml    &lt;p&gt;tasks:   &lt;br/&gt;- name: &lt;span&gt;this&lt;/span&gt; is just a placeholder    &lt;br/&gt;command: /bin/echo foo
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这可以保证你共享playbook源码时隔离敏感数据的风险.&lt;/p&gt;
&lt;p&gt;每个变量文件的内容是一个简单的YAML文件,如下所示:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
--- &lt;br/&gt;# &lt;span&gt;in&lt;/span&gt; the above example, &lt;span&gt;this&lt;/span&gt; would be vars/external_vars.yml&lt;br/&gt;somevar: somevalue &lt;br/&gt;password: magic
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;变量的优先级，变量优先级&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre readability=&quot;13&quot;&gt;
* extra vars (-e &lt;span&gt;in&lt;/span&gt; the command line) always win &lt;br/&gt;* then comes connection variables defined &lt;span&gt;in&lt;/span&gt; inventory (ansible_ssh_user, etc) &lt;br/&gt;* then comes &quot;most everything else&quot; (command line switches, vars &lt;span&gt;in&lt;/span&gt; play, included vars, role vars, etc) &lt;br/&gt;* then comes the rest of the variables defined &lt;span&gt;in&lt;/span&gt; inventory &lt;br/&gt;* then comes facts discovered about a system * then &quot;role defaults&quot;, which are the most &quot;defaulty&quot; and lose &lt;span&gt;in&lt;/span&gt; priority to everything.  &lt;p&gt;* extra vars (在命令行中使用 -e)优先级最高 &lt;br/&gt;* 然后是在inventory中定义的连接变量(比如ansible_ssh_user) &lt;br/&gt;* 接着是大多数的其它变量(命令行转换,play中的变量,included的变量,role中的变量等) &lt;br/&gt;* 然后是在inventory定义的其它变量 &lt;br/&gt;* 然后是由系统发现的facts &lt;br/&gt;* 然后是 &quot;role默认变量&quot;, 这个是最默认的值,很容易丧失优先权
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;when&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
- include: tasks/sometasks.yml   &lt;br/&gt;when: &quot;'reticulating splines' in output&quot;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或者应用于role:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
- hosts: webservers   &lt;br/&gt;roles:      &lt;br/&gt;- { role: debian_stock_config, when: ansible_os_family == 'Debian' }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://www.ansible.com.cn/docs/playbooks_conditionals.html#id11&quot;&gt;基于变量选择文件和模版&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.ansible.com.cn/docs/playbooks_loops.html#id18&quot;&gt;&lt;strong&gt;循环&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
- name: add several users   &lt;br/&gt;user: name={{ item }} state=present groups=wheel   &lt;br/&gt;with_items:      &lt;br/&gt;- testuser1      &lt;br/&gt;- testuser2
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
with_items: &quot;{{somelist}}&quot;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
- name: add several users   &lt;br/&gt;user: name={{ item.name }} state=present groups={{ item.groups }}   &lt;br/&gt;with_items:     &lt;br/&gt;- { name: 'testuser1', groups: 'wheel' }     &lt;br/&gt;- { name: 'testuser2', groups: 'root' }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;http://www.ansible.com.cn/docs/playbooks_loops.html#id19&quot;&gt;&lt;strong&gt;嵌套循环&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
- name: give users access to multiple databases   &lt;br/&gt;mysql_user: name={{ item[0] }} priv={{ item[1] }}.*:ALL append_privs=yes password=foo   &lt;br/&gt;with_nested:     &lt;br/&gt;- [ 'alice', 'bob' ]     &lt;br/&gt;- [ 'clientdb', 'employeedb', 'providerdb' ]
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;对哈希表使用循环&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;New in version 1.5.&lt;/p&gt;
&lt;p&gt;假如你有以下变量:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
--- users:   &lt;br/&gt;alice:     &lt;br/&gt;name: Alice Appleworth     &lt;br/&gt;telephone: 123-456-7890   &lt;br/&gt;bob:    &lt;br/&gt;name: Bob Bananarama     &lt;br/&gt;telephone: 987-654-3210
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;你想打印出每个用户的名称和电话号码.你可以使用 with_dict 来循环哈希表中的元素:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
tasks:  &lt;br/&gt;- name: Print phone records     &lt;br/&gt;debug: msg=&quot;User {{ item.key }} is {{ item.value.name }} ({{ item.value.telephone }})&quot;     &lt;br/&gt;with_dict: &quot;{{users}}&quot;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;对文件列表使用循环&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;with_fileglob 可以以非递归的方式来模式匹配单个目录中的文件.如下面所示:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
--- &lt;br/&gt;- hosts: all   &lt;br/&gt;tasks:      &lt;br/&gt;# first ensure our target directory exists     &lt;br/&gt;- file: dest=/etc/fooapp state=directory      &lt;br/&gt;# copy each file over that matches the given pattern     &lt;br/&gt;- copy: src={{ item }} dest=/etc/fooapp/ owner=root mode=600       &lt;br/&gt;with_fileglob:         &lt;br/&gt;- /playbooks/files/fooapp/*
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;对子元素使用循环&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设你想对一组用户做一些动作,比如创建这些用户,并且允许它们使用一组SSH key来登录.&lt;/p&gt;
&lt;p&gt;如何实现那? 先假设你有按以下方式定义的数据,可以通过”vars_files”或”group_vars/all”文件加载:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
--- users:   &lt;br/&gt;- name: alice     &lt;br/&gt;authorized:       &lt;br/&gt;- /tmp/alice/onekey.pub      &lt;br/&gt;- /tmp/alice/twokey.pub     &lt;br/&gt;mysql:         &lt;br/&gt;password: mysql-password         &lt;br/&gt;hosts:           &lt;br/&gt;- &quot;%&quot;           &lt;br/&gt;- &quot;127.0.0.1&quot;&lt;br/&gt;- &quot;::1&quot;       &lt;br/&gt;- &quot;localhost&quot;         &lt;br/&gt;privs:           &lt;br/&gt;- &quot;*.*:SELECT&quot;     &lt;br/&gt;- &quot;DB1.*:ALL&quot; &lt;br/&gt;- name: bob     &lt;br/&gt;authorized:       &lt;br/&gt;- /tmp/bob/id_rsa.pub     &lt;br/&gt;mysql:         &lt;br/&gt;password: other-mysql-password         &lt;br/&gt;hosts:    &lt;br/&gt;- &quot;db1&quot;    &lt;br/&gt;privs:       &lt;br/&gt;- &quot;*.*:SELECT&quot;     &lt;br/&gt;- &quot;DB2.*:ALL&quot;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么可以这样实现:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre readability=&quot;7&quot;&gt;
- user: name={{ item.name }} state=present generate_ssh_key=yes   &lt;br/&gt;with_items: &quot;{{users}}&quot;  &lt;p&gt;- authorized_key: &quot;user={{ item.0.name }} key='{{ lookup('file', item.1) }}'&quot;   &lt;br/&gt;with_subelements:      &lt;br/&gt;- users      &lt;br/&gt;- authorized
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;根据mysql hosts以及预先给定的privs subkey列表,我们也可以在嵌套的subkey中迭代列表:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
- name: Setup MySQL users   &lt;br/&gt;mysql_user: name={{ item.0.user }} password={{ item.0.mysql.password }} host={{ item.1 }} priv={{ item.0.mysql.privs | join('/') }}   &lt;br/&gt;with_subelements:     &lt;br/&gt;- users     &lt;br/&gt;-&lt;span&gt; mysql.hosts

Subelements walks a list of hashes (aka dictionaries) and then traverses a list &lt;/span&gt;&lt;span&gt;with&lt;/span&gt; a given key inside of those records.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;你也可以为字元素列表添加第三个元素,该元素可以放置标志位字典.现在你可以加入’skip_missing’标志位.如果设置为True,那么查找插件会跳过不包含指定子键的列表条目.如果没有该标志位,或者标志位值为False,插件会产生错误并指出缺少该子键.&lt;/p&gt;
&lt;p&gt;这就是authorized_key模式中key的获取方式.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;对整数序列使用循环&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;with_sequence 可以以升序数字顺序生成一组序列.你可以指定起始值、终止值,以及一个可选的步长值.&lt;/p&gt;
&lt;p&gt;指定参数时也可以使用key=value这种键值对的方式.如果采用这种方式,’format’是一个可打印的字符串.&lt;/p&gt;
&lt;p&gt;数字值可以被指定为10进制,16进制(0x3f8)或者八进制(0600).负数则不受支持.请看以下示例:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
--- &lt;br/&gt;- hosts: all    &lt;br/&gt;tasks:      # create groups     &lt;br/&gt;- group: name=evens state=present    &lt;br/&gt;- group: name=odds state=present     &lt;br/&gt;# create some test users     &lt;br/&gt;- user: name={{ item }} state=present groups=evens      &lt;br/&gt;with_sequence: start=0 end=32 format=testuser%02x      &lt;br/&gt;# create a series of directories &lt;span&gt;with&lt;/span&gt; even numbers &lt;span&gt;for&lt;/span&gt; some reason     &lt;br/&gt;-file: dest=/var/stuff/{{ item }} state=directory       &lt;br/&gt;with_sequence: start=4 end=16 stride=2      &lt;br/&gt;# a simpler way to use the sequence plugin     &lt;br/&gt;# create 4 groups     &lt;br/&gt;- group: name=group{{ item }} state=present       &lt;br/&gt;with_sequence: count=4
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;随机选择&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;‘random_choice’功能可以用来随机获取一些值.它并不是负载均衡器(已经有相关的模块了).它有时可以用作一个简化版的负载均衡器,比如作为条件判断:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
- debug: msg={{ item }}   &lt;br/&gt;with_random_choice:      &lt;br/&gt;- &quot;go through the door&quot;      &lt;br/&gt;- &quot;drink from the goblet&quot;      &lt;br/&gt;- &quot;press the red button&quot;      &lt;br/&gt;- &quot;do nothing&quot; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;http://www.ansible.com.cn/docs/playbooks_loops.html#id26&quot;&gt;&lt;strong&gt;Do-Until&lt;/strong&gt;&lt;strong&gt;循环&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;有时你想重试一个任务直到达到某个条件.比如下面这个例子:[重复执行]&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
- action: shell /usr/bin/foo   &lt;br/&gt;register: result   &lt;br/&gt;until: result.stdout.find(&quot;all systems go&quot;) != -1   &lt;br/&gt;retries: 5   &lt;br/&gt;delay: 10
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的例子递归运行shell模块,直到模块结果中的stdout输出中包含”all systems go”字符串,或者该任务按照10秒的延迟重试超过5次.”retries”和”delay”的默认值分别是3和5.&lt;/p&gt;
&lt;p&gt;该任务返回最后一个任务返回的结果.单次重试的结果可以使用-vv选项来查看. 被注册的变量会有一个新的属性’attempts’,值为该任务重试的次数.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;查找第一个匹配的文件&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这其实不是一个循环,但和循环很相似.如果你想引用一个文件,而该文件是从一组文件中根据给定条件匹配出来的.这组文件中部分文件名由变量拼接而成.针对该场景你可以这样做:[动态文件名]&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
- name: INTERFACES | Create Ansible header &lt;span&gt;for&lt;/span&gt; /etc/network/interfaces   &lt;br/&gt;template: src={{ item }} dest=/etc/foo.conf   &lt;br/&gt;with_first_found:    &lt;br/&gt;- &quot;{{ansible_virtualization_type}}_foo.conf&quot;    &lt;br/&gt;- &quot;default_foo.conf&quot;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;该功能还有一个更完整的版本,可以配置搜索路径.请看以下示例:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
- name: some configuration template   &lt;br/&gt;template: src={{ item }} dest=/etc/file.cfg mode=0444 owner=root group=root   &lt;br/&gt;with_first_found:     &lt;br/&gt;- files:        &lt;br/&gt;- &quot;{{inventory_hostname}}/etc/file.cfg&quot;      &lt;br/&gt;paths:        &lt;br/&gt;- ../../../templates.overwrites        &lt;br/&gt;- ../../../templates    &lt;br/&gt;- files:        &lt;br/&gt;- etc/file.cfg       &lt;br/&gt;paths:         &lt;br/&gt;- templates
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;异步操作和轮询&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;默认情况下playbook中的任务执行时会一直保持连接,直到该任务在每个节点都执行完毕.有时这是不必要的,比如有些操作运行时间比SSH超时时间还要长.&lt;/p&gt;
&lt;p&gt;解决该问题最简单的方式是一起执行它们,然后轮询直到任务执行完毕，简单的意思就是，像下面的例子，执行任务后，ansible就不等它了，往下执行下一个任务，然后每隔5秒钟去看看它执行完成没，超时时间为45秒，async参数值代表了这个任务执行时间的上限值。即任务执行所用时间如果超出这个时间，则认为任务失败。此参数若未设置，则为同步执行。&lt;/p&gt;
&lt;p&gt;你也可以对执行时间非常长（有可能遭遇超时）的操作使用异步模式.&lt;/p&gt;
&lt;p&gt;为了异步启动一个任务,可以指定其最大超时时间以及轮询其状态的频率.如果你没有为 &lt;em&gt;poll&lt;/em&gt; 指定值,那么默认的轮询频率是10秒钟:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37.5&quot;&gt;
&lt;pre readability=&quot;8&quot;&gt;
--- &lt;br/&gt;- hosts: all   &lt;br/&gt;remote_user: root   &lt;br/&gt;tasks:    &lt;p&gt;- name: simulate &lt;span&gt;long&lt;/span&gt; running op (15 sec), wait &lt;span&gt;for&lt;/span&gt; up to 45 sec, poll every 5 sec     &lt;br/&gt;command: /bin/sleep 15     &lt;br/&gt;async: 45     &lt;br/&gt;poll: 5
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;async&lt;/em&gt; 并没有默认值,如果你没有指定 &lt;em&gt;async&lt;/em&gt; 关键字,那么任务会以同步的方式运行,这是Ansible的默认行为.&lt;/p&gt;

&lt;p&gt;另外,如果你不需要等待任务执行完毕,你可以指定 &lt;em&gt;poll&lt;/em&gt; 值为0而启用 “启动并忽略”&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
---  &lt;br/&gt;- hosts: all   &lt;br/&gt;remote_user: root   &lt;br/&gt;tasks:    &lt;br/&gt;- name: simulate &lt;span&gt;long&lt;/span&gt; running op, allow to run &lt;span&gt;for&lt;/span&gt; 45 sec, fire and forget     &lt;br/&gt;command: /bin/sleep 15     &lt;br/&gt;async: 45     &lt;br/&gt;poll: 0
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;改为”启动并忽略,稍后再检查”,你可以使用以下方式执行任务:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
--- &lt;br/&gt;# Requires ansible 1.8+ &lt;br/&gt;- name: 'YUM - fire and forget task'   &lt;br/&gt;yum: name=docker-io state=installed   &lt;br/&gt;async: 1000   &lt;br/&gt;poll: 0   &lt;br/&gt;register: yum_sleeper  &lt;br/&gt;- name: 'YUM - check on fire and forget task'   &lt;br/&gt;async_status: jid={{ yum_sleeper.ansible_job_id }}   &lt;br/&gt;register: job_result   &lt;br/&gt;until: job_result.finished   &lt;br/&gt;retries: 30
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果 async: 值太小,可能会导致 “稍后检查” 任务执行失败,因为 async_status:: 的临时状态文件还未被写入信息,而”稍后检查”任务就试图读取此文件.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;delegate_to  选中主机执行&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
  - name: add back to load balancer pool     &lt;br/&gt;command: /usr/bin/add_back_to_pool {{ inventory_hostname }}     &lt;br/&gt;delegate_to: 127.0.0.1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;本地执行&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
--- &lt;br/&gt;# ...   &lt;br/&gt;tasks:    &lt;br/&gt;- name: recursively copy files from management server to target     &lt;br/&gt;local_action: command rsync -a /path/to/files {{ inventory_hostname }}:/path/to/target/
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Run Once&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;New in version 1.7.&lt;/p&gt;
&lt;p&gt;有时候你有这样的需求,在一个主机上面只执行一次一个任务.这样的配置可以配置”run_once”来实现:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
--- &lt;br/&gt;# ...    &lt;br/&gt;tasks:      &lt;br/&gt;# ...     &lt;br/&gt;- command: /opt/application/upgrade_db.py      &lt;br/&gt;run_once: true      # ...
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这样可以添加在”delegat_to”选项对中来定义要执行的主机:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
- command: /opt/application/upgrade_db.py   &lt;br/&gt;run_once: true   &lt;br/&gt;delegate_to: web01.example.org
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当”run_once” 没有喝”delegate_to”一起使用,这个任务将会被清单指定的第一个主机. 在一组被play制定主机.例如 webservers[0], 如果play指定为 “hosts: webservers”.&lt;/p&gt;
&lt;p&gt;这个方法也很类似,虽然比使用条件更加简单粗暴,如下事例:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
- command: /opt/application/upgrade_db.py   &lt;br/&gt;when: inventory_hostname == webservers[0]
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;本地Playbooks&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在本地使用playbook有时候比ssh远程使用更加有用.可以通过把playbook放在crontab中,来确保一个系统的配置,可以很有用. 在OS installer 中运行一个playbook也很有用.例如Anaconda kickstart.&lt;/p&gt;
&lt;p&gt;要想在本地运行一个play,可以直接设置”host:” 与 “hosts:127.0.0.1”, 然后使用下面的命令运行:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
ansible-playbook playbook.yml --connection=local
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或者,一个本地连接也可以作为一个单独的playbook play应用在playbook中, 即便playbook中其他的plays使用默认远程 连接如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
- hosts: 127.0.0.1   &lt;br/&gt;connection: local
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;environment  使用代理上网&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
- hosts: all   &lt;br/&gt;remote_user: root    &lt;br/&gt;tasks:      &lt;br/&gt;- apt: name=cobbler state=installed       &lt;br/&gt;environment:         &lt;br/&gt;http_proxy: http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;proxy.example.com:8080&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;environment 也可以被存储在变量中,像如下方式访问:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
- hosts: all   &lt;br/&gt;remote_user: root   &lt;br/&gt;# here we make a variable named &quot;proxy_env&quot; that is a dictionary   &lt;br/&gt;vars:     &lt;br/&gt;proxy_env:       &lt;br/&gt;http_proxy: http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;proxy.example.com:8080    &lt;br/&gt;tasks:      &lt;br/&gt;- apt: name=cobbler state=installed       &lt;br/&gt;environment: proxy_env&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;指定错误条件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;[判定错误]&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
- name: &lt;span&gt;this&lt;/span&gt; command prints FAILED when it fails   &lt;br/&gt;command: /usr/bin/example-command -x -y -z   &lt;br/&gt;register: command_result   &lt;br/&gt;failed_when: &quot;'FAILED' in command_result.stderr&quot;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在 Ansible 1.4 之前的版本能通过如下方式完成:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35.5&quot;&gt;
&lt;pre readability=&quot;6&quot;&gt;
- name: &lt;span&gt;this&lt;/span&gt; command prints FAILED when it fails   &lt;br/&gt;command: /usr/bin/example-command -x -y -z   &lt;br/&gt;register: command_result   ignore_errors: True  &lt;p&gt;- name: fail the play if the previous command did not succeed   &lt;br/&gt;fail: msg=&quot;the command failed&quot;   &lt;br/&gt;when: &quot;'FAILED' in command_result.stderr
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;不输出结果，不报告状态，覆写结果&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre readability=&quot;5&quot;&gt;
tasks:   &lt;br/&gt;- shell: /usr/bin/billybass --mode=&quot;take me to the river&quot;     &lt;br/&gt;register: bass_result     &lt;br/&gt;changed_when: &quot;bass_result.rc != 2&quot;    &lt;p&gt;# this will never report 'changed' status  &lt;br/&gt;- shell: wall 'beep'     &lt;br/&gt;changed_when: False
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;标签tags&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你有一个大型的 playbook,那能够只运行其中特定部分的配置而无需运行整个 playbook 将会很有用.&lt;/p&gt;
&lt;p&gt;plays 和 tasks 都因这个理由而支持 “tags:”&lt;/p&gt;
&lt;p&gt;例:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
tasks:      &lt;br/&gt;- yum: name={{ item }} state=installed      &lt;br/&gt;with_items:         &lt;br/&gt;- httpd         &lt;br/&gt;- memcached     &lt;br/&gt;tags:       &lt;br/&gt;- packages &lt;br/&gt;- template: src=templates/src.j2 dest=/etc/foo.conf       &lt;br/&gt;tags:          &lt;br/&gt;- configuration
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果你只想运行一个非常大的 playbook 中的 “configuration” 和 “packages”,你可以这样做:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
ansible-playbook example.yml --tags &quot;configuration,packages&quot;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另一方面,如果你只想执行 playbook 中某个特定任务 &lt;em&gt;之外&lt;/em&gt; 的所有任务,你可以这样做:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
ansible-playbook example.yml --skip-tags &quot;notification&quot;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;你同样也可以对 roles 应用 tags:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
roles:   &lt;br/&gt;- { role: webserver, port: 5000, tags: [ 'web', 'foo' ] }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;你同样也可以对基本的 include 语句使用 tag:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
- include: foo.yml tags=web,foo
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;从指定任务开始运行palybook以及分步运行playbook&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以下列出了几种方式来运行playbook.这对于测试或调试新的playbook很有帮助.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Start-at-task&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你想从指定的任务开始执行playbook,可以使用``–start-at``选项:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
ansible-playbook playbook.yml --start-at=&quot;install packages&quot;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上命令就会在名为”install packages”的任务开始执行你的playbook.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分步运行playbook&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们也可以通过``–step``选项来交互式的执行playbook:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
ansible-playbook playbook.yml --step
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样ansible在每个任务前会自动停止,并询问是否应该执行该任务.&lt;/p&gt;
&lt;p&gt;比如你有个名为``configure ssh``的任务,playbook执行到这里会停止并询问:&lt;/p&gt;
&lt;p&gt;Perform task: configure ssh (y/n/c):&lt;/p&gt;
&lt;p&gt;“y”回答会执行该任务,”n”回答会跳过该任务,而”c”回答则会继续执行剩余的所有任务而不再询问你.&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;python ansible api调用&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;90&quot;&gt;
&lt;pre&gt;
#!/usr/bin/env python2
&lt;span&gt;
import sys
import json
import shutil
import pprint
from collections import namedtuple
from ansible.parsing.dataloader import DataLoader
from ansible.vars.manager import VariableManager
from ansible.inventory.manager import InventoryManager
from ansible.playbook.play import Play
from ansible.executor.task_queue_manager import TaskQueueManager
from ansible.plugins.callback import CallbackBase
import ansible.constants as C
from ansible.inventory.group import Group
from ansible.inventory.host import Host
def get_info(username,password,resource):
    class ResultCallback(CallbackBase):
        def __init__(self, &lt;/span&gt;*args, **&lt;span&gt;kwargs):
            self.info &lt;/span&gt;=&lt;span&gt; {}
        def v2_runner_on_ok(self, result, &lt;/span&gt;**&lt;span&gt;kwargs):
            host &lt;/span&gt;=&lt;span&gt; result._host
            self.info[host.name] &lt;/span&gt;=&lt;span&gt; result._result

    Options &lt;/span&gt;= namedtuple('Options', ['connection', 'module_path', 'forks', 'become', 'become_method', 'become_user', 'check', 'diff'&lt;span&gt;])
    options &lt;/span&gt;= Options(connection='local', module_path=['/to/mymodules'], forks=10, become=None, become_method=None, become_user=None, check=False, diff=&lt;span&gt;False)
    loader &lt;/span&gt;=&lt;span&gt; DataLoader()
    results_callback &lt;/span&gt;=&lt;span&gt; ResultCallback()
    #inventory &lt;/span&gt;= InventoryManager(loader=loader, sources=&lt;span&gt;[tempFileName])
    inventory &lt;/span&gt;= InventoryManager(loader=&lt;span&gt;loader)
    inventory.add_group(&lt;/span&gt;&quot;default&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; host &lt;span&gt;in&lt;/span&gt;&lt;span&gt; resource:
        inventory.add_host(host&lt;/span&gt;=host,port=22,group='default'&lt;span&gt;)
    variable_manager &lt;/span&gt;= VariableManager(loader=loader, inventory=&lt;span&gt;inventory)

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; host &lt;span&gt;in&lt;/span&gt;&lt;span&gt; resource:        
        host &lt;/span&gt;= inventory.get_host(hostname=&lt;span&gt;host)
        variable_manager.set_host_variable(host&lt;/span&gt;=host,varname='ansible_ssh_host',value=&lt;span&gt;host)
        variable_manager.set_host_variable(host&lt;/span&gt;=host,varname='ansible_ssh_user',value=&lt;span&gt;username)
        variable_manager.set_host_variable(host&lt;/span&gt;=host,varname='ansible_ssh_pass',value=&lt;span&gt;password)
        variable_manager.set_host_variable(host&lt;/span&gt;=host,varname='ansible_connection',value='local'&lt;span&gt;)
    play_source &lt;/span&gt;=&lt;span&gt;  dict(
        name &lt;/span&gt;= &quot;Ansible Play&quot;&lt;span&gt;,
        hosts &lt;/span&gt;=&lt;span&gt; resource,
        gather_facts &lt;/span&gt;= 'no'&lt;span&gt;,
        tasks &lt;/span&gt;=&lt;span&gt; [
            dict(action&lt;/span&gt;=dict(module='setup', args=''&lt;span&gt;))
         ]
        )
    play &lt;/span&gt;= Play().load(play_source, variable_manager=variable_manager, loader=&lt;span&gt;loader)
    tqm &lt;/span&gt;=&lt;span&gt; None
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
        tqm &lt;/span&gt;=&lt;span&gt; TaskQueueManager(
              inventory&lt;/span&gt;=&lt;span&gt;inventory,
              variable_manager&lt;/span&gt;=&lt;span&gt;variable_manager,
              loader&lt;/span&gt;=&lt;span&gt;loader,
              options&lt;/span&gt;=&lt;span&gt;options,
              passwords&lt;/span&gt;=&lt;span&gt;None,
              stdout_callback&lt;/span&gt;=&lt;span&gt;results_callback,
          )
        result &lt;/span&gt;=&lt;span&gt; tqm.run(play)
    &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; tqm is not None:
        tqm.cleanup()
        shutil.rmtree(C.DEFAULT_LOCAL_TMP, True)

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; results_callback.info

def handle_info(rawdata, node):
    # data dictionary
    data &lt;/span&gt;=&lt;span&gt; {}
    detail &lt;/span&gt;=&lt;span&gt; {}

    # read sysinfo
    cpu_count &lt;/span&gt;= rawdata[node]['ansible_facts']['ansible_processor_count'&lt;span&gt;]
    cpu_cores &lt;/span&gt;= rawdata[node]['ansible_facts']['ansible_processor_cores'&lt;span&gt;]
    cpu_model &lt;/span&gt;= list(set(rawdata[node]['ansible_facts']['ansible_processor'][2::3&lt;span&gt;]))
    cpu_vcpus &lt;/span&gt;= rawdata[node]['ansible_facts']['ansible_processor_vcpus'&lt;span&gt;]
    # memtotal &lt;/span&gt;= rawdata[node]['ansible_facts']['ansible_memtotal_mb'&lt;span&gt;]
    # memfree &lt;/span&gt;= rawdata[node]['ansible_facts']['ansible_memfree_mb'&lt;span&gt;]
    memory &lt;/span&gt;= rawdata[node]['ansible_facts']['ansible_memory_mb']['real'&lt;span&gt;]
    disk_info &lt;/span&gt;= rawdata[node]['ansible_facts']['ansible_devices'&lt;span&gt;]
    interfaces_info &lt;/span&gt;= rawdata[node]['ansible_facts']['ansible_interfaces'&lt;span&gt;]
    
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(len(interfaces_info)):
        tmp &lt;/span&gt;= &quot;ansible_&quot; + interfaces_info[i].replace(&quot;-&quot;, &quot;_&quot;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; rawdata[node]['ansible_facts'][tmp].has_key('type'&lt;span&gt;):
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; rawdata[node]['ansible_facts'][tmp]['type'] == &quot;bridge&quot;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;
        detail[interfaces_info[i]] &lt;/span&gt;=&lt;span&gt; {}
        detail[interfaces_info[i]][&lt;/span&gt;'active'] = rawdata[node]['ansible_facts'][tmp]['active'&lt;span&gt;]
        detail[interfaces_info[i]][&lt;/span&gt;'mtu'] = rawdata[node]['ansible_facts'][tmp]['mtu'&lt;span&gt;]
        detail[interfaces_info[i]][&lt;/span&gt;'promisc'] = rawdata[node]['ansible_facts'][tmp]['promisc'&lt;span&gt;]
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; rawdata[node]['ansible_facts'][tmp].has_key('speed'&lt;span&gt;):
            detail[interfaces_info[i]][&lt;/span&gt;'speed'] = rawdata[node]['ansible_facts'][tmp]['speed'&lt;span&gt;]
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; rawdata[node]['ansible_facts'][tmp].has_key('type'&lt;span&gt;):
            detail[interfaces_info[i]][&lt;/span&gt;'type'] = rawdata[node]['ansible_facts'][tmp]['type'&lt;span&gt;]
        

    # store sysinfo into data dictionary
    
    
    cpu &lt;/span&gt;=&lt;span&gt; {}
    cpu[&lt;/span&gt;'cpu_number'] =&lt;span&gt; cpu_count
    cpu[&lt;/span&gt;'cpu_cores'] =&lt;span&gt; cpu_cores
    cpu[&lt;/span&gt;'cpu_model'] =&lt;span&gt; cpu_model
    cpu[&lt;/span&gt;'cpu_vcpus'] =&lt;span&gt; cpu_vcpus
    data[&lt;/span&gt;'cpu'] =&lt;span&gt; cpu
    data[&lt;/span&gt;'memory'] =&lt;span&gt; memory
    
    disk &lt;/span&gt;=&lt;span&gt; {}
    disk[&lt;/span&gt;'number'] =&lt;span&gt; len(disk_info)
    disk[&lt;/span&gt;'info'] =&lt;span&gt; {}
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; key &lt;span&gt;in&lt;/span&gt;&lt;span&gt; disk_info:
        disk[&lt;/span&gt;'info'][key] =&lt;span&gt; {}
        disk[&lt;/span&gt;'info'][key]['size'] = disk_info[key]['size'&lt;span&gt;]
    data[&lt;/span&gt;'disk'] =&lt;span&gt; disk
    
    interfaces &lt;/span&gt;=&lt;span&gt; {}
    interfaces[&lt;/span&gt;'number'] =&lt;span&gt; len(interfaces_info)
    interfaces[&lt;/span&gt;'info'] =&lt;span&gt; detail
    data[&lt;/span&gt;'interfaces'] =&lt;span&gt; interfaces

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; data

def handle_infos(rawdata):
    info &lt;/span&gt;=&lt;span&gt; []
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; key &lt;span&gt;in&lt;/span&gt;&lt;span&gt; rawdata:
        temp &lt;/span&gt;=&lt;span&gt; {}
        temp[&lt;/span&gt;'IP_ADDR'] =&lt;span&gt; key
        temp[&lt;/span&gt;'OBJ_ATTRS'] =&lt;span&gt; handle_info(rawdata, key)
        info.append(temp)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; info

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; __name__ == '__main__'&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; len(sys.argv) != 4&lt;span&gt;:
        print &lt;/span&gt;&quot;need parameter:username,password,list of hosts(split with ',')!!!&quot;&lt;span&gt;
        sys.exit()
    hosts&lt;/span&gt;=sys.argv[3].split(&quot;,&quot;&lt;span&gt;)
    raw_data &lt;/span&gt;= get_info(sys.argv[1],sys.argv[2&lt;span&gt;],hosts)
    data &lt;/span&gt;=&lt;span&gt; handle_infos(raw_data)
    data &lt;/span&gt;=&lt;span&gt; json.dumps(data)
    pprint.pprint(data)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;早点睡,晚安(￣o￣) . z Z&lt;/p&gt;

</description>
<pubDate>Mon, 22 Apr 2019 15:32:00 +0000</pubDate>
<dc:creator>魏俊峰</dc:creator>
<og:description>内容比较杂多,不太会调格式，你自己ctrl F 方便查找哈 执行playbook命令 ansible­playbook ­i &quot;inventory文件</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/aaaaaaa/p/10753860.html</dc:identifier>
</item>
<item>
<title>BoltDB简单使用教程 - 勋爵</title>
<link>http://www.cnblogs.com/X-knight/p/10753833.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/X-knight/p/10753833.html</guid>
<description>&lt;h2&gt;1.BoltDB简介&lt;/h2&gt;
&lt;p&gt;Bolt是一个纯粹Key/Value模型的程序。该项目的目标是为不需要完整数据库服务器（如Postgres或MySQL）的项目提供一个简单，快速，可靠的数据库。&lt;/p&gt;
&lt;p&gt;BoltDB只需要将其链接到你的应用程序代码中即可使用BoltDB提供的API来高效的存取数据。而且BoltDB支持完全可序列化的ACID事务，让应用程序可以更简单的处理复杂操作。&lt;/p&gt;
&lt;p&gt;其源码地址为:&lt;strong&gt;&lt;span&gt;&lt;a href=&quot;https://github.com/boltdb/bolt&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://github.com/boltdb/bolt&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;2.BoltDB特性&lt;/h2&gt;
&lt;p&gt;BoltDB设计源于LMDB，具有以下特点：&lt;/p&gt;
&lt;ul class=&quot; list-paddingleft-2&quot; readability=&quot;2.5&quot;&gt;&lt;li&gt;
&lt;p&gt;使用Go语言编写&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;不需要服务器即可运行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;支持数据结构&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;直接使用API存取数据，没有查询语句；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;支持完全可序列化的ACID事务，这个特性比LevelDB强；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;数据保存在内存映射的文件里。没有wal、线程压缩和垃圾回收；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;通过COW技术，可实现无锁的读写并发，但是无法实现无锁的写写并发，这就注定了读性能超高，但写性能一般，适合与读多写少的场景。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;BoltDB是一个Key/Value（键/值）存储，这意味着没有像SQL RDBMS（MySQL，PostgreSQL等）中的表，没有行，没有列。相反，数据作为键值对存储（如在Golang Maps中）。键值对存储在Buckets中，它们旨在对相似的对进行分组（这与RDBMS中的表类似）。因此，为了获得Value(值)，需要知道该Value所在的桶和钥匙。&lt;/p&gt;
&lt;h2&gt;3.BoltDB的安装&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Linux中：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$ go get github.com/boltdb/bolt/...
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;Windows中：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.前提是已经&lt;strong&gt;安装GO语言环境.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;2.&lt;strong&gt;安装git&lt;/strong&gt; for windows :&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;%20http://git-for-windows.github.io/&quot; target=&quot;_blank&quot;&gt; http://git-for-windows.github.io/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;3.安装Git后才能&lt;strong&gt;执行命令:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
go get github.com/boltdb/bolt/...
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;来安装第三方包。这条命令它会把 类库包源代码，下载解压到你的 %GOPATH% 路径里面去，比如：C:\go\gopath\   src\github.com\...&lt;br/&gt;前面是gopath路径，后面是类库，并且它还会同时执行 go install xxx ，生成 D:\go\gopath\pkg\xxxx 这样的包路径。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;4. 在&lt;strong&gt;代码中导入第三方包:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import (
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;github.com/boltdb/bolt&lt;/span&gt;&lt;span&gt;&quot; // 从环境变量：%goPath% 中定义的路径去查找第三方类库&lt;/span&gt;&lt;span&gt;
)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;4.BoltDB简单使用&lt;/h2&gt;
&lt;h3&gt;4.1 打开或创建数据库&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.数据库创建
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在这里gland直接运行，生成的my.db在main.go上层目录;命令行build在运行的话是当前目录！！！&lt;/span&gt;
    db, err := bolt.Open(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;chaorsBlock.db&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;0600&lt;/span&gt;&lt;span&gt;, nil)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil {
        log.Fatal(err)
    }
    defer db.Close()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;p&gt;如果通过goland程序运行创建的my.db会保存在$GOPATH /src/Project目录下&lt;br/&gt;如果通过go build main.go ; ./main 执行生成的my.db，会保存在当前目录$GOPATH /src/Project/package下&lt;/p&gt;
&lt;h3&gt;4.2 数据库操作&lt;/h3&gt;
&lt;h4&gt;4.2.1 创建数据库表&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.创建表&lt;/span&gt;
    err = db.Update(func(tx *&lt;span&gt;bolt.Tx) error {
  
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断要创建的表是否存在&lt;/span&gt;
        b := tx.Bucket([]&lt;span&gt;byte&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MyBlocks&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; b ==&lt;span&gt; nil {
  
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建叫&quot;MyBucket&quot;的表&lt;/span&gt;
            _, err := tx.CreateBucket([]&lt;span&gt;byte&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MyBlocks&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil {
                                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;也可以在这里对表做插入操作&lt;/span&gt;
&lt;span&gt;                log.Fatal(err)
            }
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;一定要返回nil&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; nil
    })

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;更新数据库失败&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil {
        log.Fatal(err)
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;4.2.2 更新&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3.更新表数据&lt;/span&gt;
    err = db.Update(func(tx *&lt;span&gt;bolt.Tx) error {

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取出叫&quot;MyBucket&quot;的表&lt;/span&gt;
        b := tx.Bucket([]&lt;span&gt;byte&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MyBlocks&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;往表里面存储数据&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; b !=&lt;span&gt; nil {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;插入的键值对数据类型必须是字节数组&lt;/span&gt;
            err := b.Put([]&lt;span&gt;byte&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;l&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;), []&lt;span&gt;byte&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0x0000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
            err :&lt;/span&gt;= b.Put([]&lt;span&gt;byte&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ll&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;), []&lt;span&gt;byte&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0x0001&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
                        err :&lt;/span&gt;= b.Put([]&lt;span&gt;byte&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lll&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;), []&lt;span&gt;byte&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0x0002&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil {
                log.Fatal(err)
            }
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;一定要返回nil&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; nil
    })

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;更新数据库失败&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil {
        log.Fatal(err)
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;4.2.3 查询&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;4.查看表数据&lt;/span&gt;
    err = db.View(func(tx *&lt;span&gt;bolt.Tx) error {

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取出叫&quot;MyBucket&quot;的表&lt;/span&gt;
        b := tx.Bucket([]&lt;span&gt;byte&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MyBlocks&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;往表里面存储数据&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; b !=&lt;span&gt; nil {

            data :&lt;/span&gt;= b.Get([]&lt;span&gt;byte&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;l&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
            fmt.Printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, data)
            data :&lt;/span&gt;= b.Get([]&lt;span&gt;byte&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;l&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
            fmt.Printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, data)
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;一定要返回nil&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; nil
    })

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;查询数据库失败&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil {
        log.Fatal(err)
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Mon, 22 Apr 2019 15:27:00 +0000</pubDate>
<dc:creator>勋爵</dc:creator>
<og:description>1.BoltDB简介 Bolt是一个纯粹Key/Value模型的程序。该项目的目标是为不需要完整数据库服务器（如Postgres或MySQL）的项目提供一个简单，快速，可靠的数据库。 BoltDB只需</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/X-knight/p/10753833.html</dc:identifier>
</item>
<item>
<title>babel 7 简单指北 - 郭佬</title>
<link>http://www.cnblogs.com/guolao/p/10753795.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/guolao/p/10753795.html</guid>
<description>&lt;h2 id=&quot;babel-7&quot;&gt;babel 7&lt;/h2&gt;
&lt;p&gt;对于 babel 7，&lt;a href=&quot;https://babeljs.io/&quot;&gt;babel 的官网&lt;/a&gt;已经介绍得非常详细了，但有时感觉文档和实际使用总是差那么一点东西。&lt;/p&gt;
&lt;h3 id=&quot;主要包&quot;&gt;主要包&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;先来看一下主要的包，babel 7 对于包进行了一些简化。&lt;/p&gt;
&lt;h3 id=&quot;安装-babel-7&quot;&gt;安装 babel 7&lt;/h3&gt;
&lt;hr/&gt;&lt;pre class=&quot;powershell&quot;&gt;
&lt;code&gt;npm init -y
npm i -S @babel/cli @babel/core&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装完之后，可以看见 package.json 下有 babel 的信息。&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
  &quot;name&quot;: &quot;babel_7&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;amp;&amp;amp; exit 1&quot;
  },
  &quot;keywords&quot;: [],
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;,
  &quot;dependencies&quot;: {
    &quot;@babel/cli&quot;: &quot;^7.4.3&quot;,
    &quot;@babel/core&quot;: &quot;^7.4.3&quot;
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;新建一个 src 目录，并在目录下创建一个 index.js：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// src/index.js
const sum = (a, b) =&amp;gt; a + b&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着新建 dist 目录，存放打包文件，然后执行命令：&lt;/p&gt;
&lt;pre class=&quot;powershell&quot;&gt;
&lt;code&gt;npx babel src/index.js -d dist/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以在 dist 下看见转换后的 index.js，但内容一模一样，因为 @babel/core 只复制把代码转换为 AST，然后 babel 又把 AST 转为代码，中间并没有做任何处理。&lt;/p&gt;
&lt;h4 id=&quot;babelcli-的一些命令&quot;&gt;@babel/cli 的一些命令&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;转码结果输出到标准输出
npx babel example.js
 
转码结果写入一个文件
--out-file 或 -o 参数指定输出文件
npx babel example.js --out-file compiled.js
或者
npx babel example.js -o compiled.js
 
整个目录转码
--out-dir 或 -d 参数指定输出目录
npx babel src --out-dir lib
或者
npx babel src -d lib
 
-s 参数生成 source map 文件
npx babel src -d lib -s&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;配置&quot;&gt;配置&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;babel 7 提供了 3 种通过文件进行配置的方式。&lt;/p&gt;
&lt;ol readability=&quot;12&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;&lt;code&gt;babel.config.js&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;适用场景：以编程的方式创建配置文件，希望编译 &lt;code&gt;node_modules&lt;/code&gt; 目录下的模块&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;module.exports = function (api) {
  api.cache(true);

  const presets = [ ... ];
  const plugins = [ ... ];

  return {
    presets,
    plugins
  };
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;code&gt;.babelrc&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;适用场景：简单的静态配置&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
  &quot;presets&quot;: [...],
  &quot;plugins&quot;: [...]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也可以将上面的配置移到 package.json 中：&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
  &quot;name&quot;: &quot;my-package&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;babel&quot;: {
    &quot;presets&quot;: [ ... ],
    &quot;plugins&quot;: [ ... ],
  }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;code&gt;.babelrc.js&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;适用场景和 babel.config.js 类似&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const presets = [ ... ];
const plugins = [ ... ];
module.exports = { presets, plugins };&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还可以调用 Node.js 的任何 API，例如基于进程环境进行动态配置：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const presets = [ ... ];
const plugins = [ ... ];

if (process.env[&quot;ENV&quot;] === &quot;prod&quot;) {
  plugins.push(...);
}

module.exports = { presets, plugins };&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;babelpolyfillbabelpreset-env&quot;&gt;@babel/polyfill、@babel/preset-env&lt;/h3&gt;
&lt;hr/&gt;&lt;pre class=&quot;powershell&quot;&gt;
&lt;code&gt;npm i -S @babel/polyfill
npm i -D @babel/preset-env&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装完之后，在根目录下创建 .babelrc 文件，进行一些简单配置:&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
  &quot;presets&quot;: [
    [
      &quot;@babel/preset-env&quot;,
      {
        &quot;useBuiltIns&quot;: &quot;entry&quot;
      }
    ]
  ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再将 src/index.js 改一下：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// src/index.js
import &quot;@babel/polyfill&quot;

let list = new Set()
list.set(0, 'hhh')

const sum = (a, b) =&amp;gt; a + b&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后运行转换命令：&lt;/p&gt;
&lt;pre class=&quot;powershell&quot;&gt;
&lt;code&gt; npx babel src/index.js -d dist/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后会发现 dist/index.js 中 es6+ 的语法转换为了 es5，而且还添加了一堆&lt;code&gt;require(...)&lt;/code&gt;，这些都是 polyfill，但没用到的一些东西也依然打包进来了，对于这种情况，babel 7 提供了&lt;code&gt;useBuiltIns&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&quot;usebuiltins&quot;&gt;useBuiltIns&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;useBuiltIns: &quot;usage&quot;, &quot;entry&quot;, &quot;false&quot;。默认为 false。&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;usage: 在每个文件中使用 polyfill 时，为 polyfill 添加特定导入，babel 利用捆绑器只加载一次相同的polyfill。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;entry: 使用 entry 属性，必须在项目入口处引入一次 @babel/polyfill。然后 babel 在做代码转换的时候，会把&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;import @babel/polyfill&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;转成&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;require(&quot;core-js/modules/es6.array.copy-within&quot;);
require(&quot;core-js/modules/es6.array.every&quot;);
require(&quot;core-js/modules/es6.array.fill&quot;);
// more&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;false: 不引入 polyfill&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;将 .babelrc 下的&lt;code&gt;useBuiltIns&lt;/code&gt;改为&lt;code&gt;usage&lt;/code&gt;，再执行转换命令，就会发现 polyfill 变成了按需导入。&lt;/p&gt;
&lt;h4 id=&quot;targets&quot;&gt;targets&lt;/h4&gt;
&lt;p&gt;babel 7 还提供了&lt;code&gt;targets&lt;/code&gt;，这个配置主要用于指定需要支持的环境，一般是指浏览器版本。（ targets 还可以指定 node、android、ios、electron 等其他环境）&lt;/p&gt;
&lt;p&gt;设置了 targets，babel 在转换前，会先检查 targets 指定的环境已经支持了哪些新语法和 API，然后就不再转换或者不引入已经支持的内容。&lt;/p&gt;
&lt;p&gt;配置 targets，依然是修改 .babelrc 文件：&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
  &quot;presets&quot;: [
    [
      &quot;@babel/preset-env&quot;,
      {
        &quot;useBuiltIns&quot;: &quot;usage&quot;,
        &quot;targets&quot;: {
          &quot;browsers&quot;: [&quot;last 2 versions&quot;, &quot;ie &amp;gt;= 10&quot;]
        }
      }
    ]
  ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;babelplugin-transform-runtimebabelruntime&quot;&gt;@babel/plugin-transform-runtime、@babel/runtime&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;使用 @babel/polyfill 会对全局对象进行污染，所以可以使用 @babel/plugin-transform-runtime 和@babel/runtime 防止这种现象。&lt;/p&gt;
&lt;p&gt;@babel/plugin-transform-runtime 会在你需要的地方自动引入你使用到的新方法。&lt;/p&gt;
&lt;pre class=&quot;powershell&quot;&gt;
&lt;code&gt;npm i -D @babel/plugin-transform-runtime
npm i -S @babel/runtime&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装完毕之后依然是修改 .babelrc 文件：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;{
  &quot;presets&quot;: [
    [
      &quot;@babel/preset-env&quot;,
      {
        &quot;targets&quot;: {
          &quot;browsers&quot;: [&quot;last 2 versions&quot;, &quot;ie &amp;gt;= 10&quot;]
        }
      }
    ]
  ],
  &quot;plugins&quot;: [&quot;@babel/plugin-transform-runtime&quot;]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后修改一下 src/index.js：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// src/index.js

class Person {
  constructor (name) {
    this.name = name
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后用命令进行转换，会发现转换结果和使用 @babel/polyfill 是有一点不一样的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 如果使用 @babel/runtime 的话，一些类的实例方法如：&lt;code&gt;foobar.includes(&quot;foo&quot;)&lt;/code&gt;将无法工作。因为它必须在原生对象的原型链上进行修改。&lt;/p&gt;
&lt;h4 id=&quot;区别&quot;&gt;区别&lt;/h4&gt;
&lt;p&gt;看了上面的做法，你可能会觉得困惑，为什么要一起使用 @babel/plugin-transform-runtime、@babel/runtime 呢，为什么不能单独使用一个？&lt;/p&gt;
&lt;p&gt;其实是因为 babel 转换时，@babel/plugin-transform-runtime 这个插件会自动引入使用到的新方法，而引入的这些 polyfill 包是在 @babel/runtime 里面的，所以 @babel/runtime 需要安装在 dependency（生产环境）下，@babel/plugin-transform-runtime 则安装在 devDependency（开发环境）下。&lt;/p&gt;
&lt;h4 id=&quot;使用哪一个&quot;&gt;使用哪一个？&lt;/h4&gt;
&lt;p&gt;至于是使用 @babel/polyfill，还是 @babel/runtime，我也不太清楚，网上的说法大致都是：&lt;/p&gt;
&lt;p&gt;一般库或工具中使用 @babel/runtime，因为它可以避免全局的污染。如果是项目中可以直接使用 @babel/polyfill。&lt;/p&gt;
&lt;p&gt;其实就是看使用场景吧，毕竟各有利弊。&lt;/p&gt;
</description>
<pubDate>Mon, 22 Apr 2019 15:18:00 +0000</pubDate>
<dc:creator>郭佬</dc:creator>
<og:description>babel 7 对于 babel 7， 'babel 的官网' 已经介绍得非常详细了，但有时感觉文档和实际使用总是差那么一点东西。 主要包 先来看一下主要的包，babel 7 对于包进行了一些简化。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/guolao/p/10753795.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core 使用 Google 验证码（reCAPTCHA v3）代替传统验证码 - 乔达摩</title>
<link>http://www.cnblogs.com/xiaxiaolu/p/10753583.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaxiaolu/p/10753583.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/641760/201904/641760-20190422223542168-361650878.jpg&quot; alt=&quot;Image result for reCAPTCHA v3&quot;/&gt;&lt;/p&gt;

&lt;p&gt;友情提示：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Google reCAPTCHA(v3下同) 的使用不需要“梯子”，但申请账号的时候需要！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Google reCAPTCHA 的使用不需要“梯子”，但申请账号的时候需要！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Google reCAPTCHA 的使用不需要“梯子”，但申请账号的时候需要！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;那天上班路上刷博客园，看到&lt;a href=&quot;https://www.cnblogs.com/stulzq&quot;&gt;晓晨&lt;/a&gt;大佬的&lt;a href=&quot;https://www.cnblogs.com/stulzq/p/10714417.html&quot;&gt;ASP.NET Core 使用 Google 验证码（Google reCAPTCHA）&lt;/a&gt;手痒不已，回家立马抽空自己也写了一遍（基本上抄晓晨大佬的），趁周末写个文，挥发下余温；（然而今天晚上下班才匆忙收尾。。。）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;日常所见各类奇葩验证码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个太有名了，必须前排&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/641760/201904/641760-20190422223541458-1786569204.png&quot; alt=&quot;1555769673891&quot;/&gt;&lt;/p&gt;
&lt;p&gt;京东的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/641760/201904/641760-20190422223540346-554542901.png&quot; alt=&quot;1555769755756&quot;/&gt;&lt;/p&gt;
&lt;p&gt;中文的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/641760/201904/641760-20190422223539817-43775923.png&quot; alt=&quot;1555769838576&quot;/&gt;&lt;/p&gt;
&lt;p&gt;丧心病狂的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/641760/201904/641760-20190422223538869-1293802571.png&quot; alt=&quot;1555769913750&quot;/&gt;&lt;/p&gt;
&lt;p&gt;面对这堆无力吐槽的验证码，降低用户体验不说，也提高了开发成本；&lt;/p&gt;
&lt;p&gt;很多现在很多公司验证码是用了第三方的，&lt;a href=&quot;https://www.geetest.com/GCN/&quot;&gt;极验&lt;/a&gt;、&lt;a href=&quot;https://dun.163.com/trial/sense&quot;&gt;网易云盾&lt;/a&gt;等等。&lt;/p&gt;
&lt;p&gt;也有很多公司的验证码（人机识别）模块是自己做的，有的甚至做了几套，还有更甚的甚至用上了&lt;strong&gt;理解图卷积算法&lt;/strong&gt;，堪称丧心病狂；&lt;/p&gt;
&lt;p&gt;但现在爬虫横行，恶意爬取数据，大量肉鸡爬取几乎等于dos攻击等，这算轻的；稍有不慎，暴力破解、数据泄露等安全问题也着实严峻；&lt;/p&gt;
&lt;p&gt;so,如果现在说，有人帮你搞定这些（人机识别），让你的登录页面清清爽爽，没有验证码，你想不想爽一把。&lt;/p&gt;
&lt;p&gt;我看你也跟我一样，定抵不住这&lt;a href=&quot;https://developers.google.com/recaptcha/docs/v3&quot;&gt;Google.reCAPTCHA-v3&lt;/a&gt;这妖艳货色婀娜的身姿；&lt;/p&gt;

&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;本文讲的reCAPTCHA都是v3，下同；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;官方文档：&lt;a href=&quot;https://developers.google.com/recaptcha/docs/v3&quot; class=&quot;uri&quot;&gt;https://developers.google.com/recaptcha/docs/v3&lt;/a&gt; 英文好的自己看看；&lt;/p&gt;
&lt;p&gt;一句带过：reCAPTCHA 会以嵌入js的方式，给网站后台返回一个分数，这个分数是用于判断用户是否是机器人，分数的范围是0~1，分数约接近0，越像机器人；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;顺便提一句，reCAPTCHA 这妖艳货色是免费的哦！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;注册站点：&lt;a href=&quot;https://www.google.com/recaptcha/admin/create&quot; class=&quot;uri&quot;&gt;https://www.google.com/recaptcha/admin/create&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这里很简单啦，照着我的图瞎点就行了；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/641760/201904/641760-20190422223534420-573605114.png&quot; alt=&quot;1555603088777&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点提交之后，得到：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这两个kes是配置用的，作用页面也说清楚了；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/641760/201904/641760-20190422223533399-824183667.png&quot; alt=&quot;1555603128328&quot;/&gt;&lt;/p&gt;
&lt;p&gt;很简单，ok，接下来看看怎么在.net core站点中使用；&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1、创建项目&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/641760/201904/641760-20190422223532754-576236117.png&quot; alt=&quot;1555603893270&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、引用程序包&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;install-package Unicorn.reCAPTCHA.AspNetCore&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;4.8275862068966&quot;&gt;
&lt;p&gt;这个包是晓晨大佬改过的（我也不知道改了什么[捂脸]），就先用它&lt;/p&gt;
&lt;p&gt;不想用这个的，可以用&lt;a href=&quot;https://github.com/TimothyMeadows/reCAPTCHA.AspNetCore&quot; class=&quot;uri&quot;&gt;https://github.com/TimothyMeadows/reCAPTCHA.AspNetCore&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;3、写个简单的登录页&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;AccountViewModel&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public class AccountViewModel
    {
        [Required]
        public string Username { get; set; }

        [Required]
        public string Password { get; set; }

        public string GoogleToken { get; set; }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;后端：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; public IActionResult Login()
        {
            return View();
        }

        [HttpPost]
        public async Task&amp;lt;IActionResult&amp;gt; Login(AccountViewModel model)
        {
            if (ModelState.IsValid)
            {
                var recaptchaReault = await _recaptcha.Validate(model.GoogleToken);

                if (!recaptchaReault.success || recaptchaReault.score &amp;lt; 0.08m)
                {
                    ModelState.AddModelError(string.Empty, &quot;老实说，你是不是机器人！&quot;);
                }
                else
                {
                    ModelState.AddModelError(string.Empty, &quot;登录成功~&quot;);
                }
            }

            return View(model);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;前端：&lt;/p&gt;
&lt;p&gt;appsettings.json&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
  &quot;RecaptchaSettings&quot;: {
    &quot;SiteKey&quot;: &quot;刚刚申请的SiteKey&quot;,
    &quot;SecretKey&quot;: &quot;刚刚申请的SecretKey&quot;,
    &quot;Version&quot;: &quot;v3&quot;,
    &quot;Domain&quot;: &quot;www.recaptcha.net&quot;
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Startup&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;services.AddGoogleRecaptcha(Configuration.GetSection(&quot;RecaptchaSettings&quot;));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;4、简单测试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们先把这里改成这样&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/641760/201904/641760-20190422223532064-1207248669.png&quot; alt=&quot;1555772858463&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后调试会得到：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/641760/201904/641760-20190422223531074-778270706.gif&quot; alt=&quot;12&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我还放到了对外地址上，大家有空可以点来玩玩（但提交不要点太快哦，js异步加载token太快会报错）&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.sophiawu.cn/&quot; class=&quot;uri&quot;&gt;http://www.sophiawu.cn/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;哦，对了，还有一个坑，就是你点登录按钮后点浏览器的返回按钮，再点登录，这个时候百分百识别为机器人，线上用的时候要注意这个问题&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;以后做有人机验证需求的登录页面，多了个选择，后面多玩下，自己试着用爬虫摸一下这个页面什么的，可靠的话我就投入生产了；&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/gebiWangshushu/cnblogs-demos/tree/master/Google.reCAPTCHA.V3.Example&quot;&gt;本文示例代码&lt;/a&gt;（也没写什么新内容，大部分是看晓晨大佬那篇博客自己实现了一遍）&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/stulzq/p/10714417.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/stulzq/p/10714417.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 22 Apr 2019 14:37:00 +0000</pubDate>
<dc:creator>乔达摩</dc:creator>
<og:description>﻿ 写在前面 友情提示： Google reCAPTCHA(v3下同) 的使用不需要“梯子”，但申请账号的时候需要！ Google reCAPTCHA 的使用不需要“梯子”，但申请账号的时候需要！ G</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaxiaolu/p/10753583.html</dc:identifier>
</item>
<item>
<title>为什么会有Comparable与Comparator接口? 引入策略模式 - 炭烧生蚝</title>
<link>http://www.cnblogs.com/tanshaoshenghao/p/10753022.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tanshaoshenghao/p/10753022.html</guid>
<description>&lt;ul&gt;&lt;li&gt;大家先考虑一个场景, 有一个整形数组, 我们希望通过调用一个工具类的排序方法就能对该数组进行排序. 请看下面的代码:&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Strategy {
    public static void main(String[] args) {
        int[] arr = {5, 3, 1, 7, 2};
        new DataSorter().sort(arr);//调用工具类进行排序
        for(int i = 0; i &amp;lt; arr.length; i++){
            System.out.println(arr[i]);
        }
    }
}

class DataSorter{//用于排序的工具类
    public void sort(int[] arr){//调用sort方法进行排序, 此处使用冒泡排序
        for(int i = arr.length - 1; i &amp;gt; 0; i--){
            for(int j = 0; j &amp;lt; i; j++){
                if(arr[j] &amp;gt; arr[j + 1])
                    swap(arr, j, j  + 1);
            }
        }
    }

    private void swap(int[] arr, int i, int j){
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}&lt;/code&gt;
&lt;/pre&gt;


&lt;ul&gt;&lt;li&gt;通过上面的代码, 我们能够轻易地对整形数组进行排序, 那么如果现在有了新需求, 需要对浮点类型数据进行排序, 排序工具类应该如何做呢?&lt;/li&gt;
&lt;li&gt;或许你会想, 不如就新添加一个排序方法, 方法的参数类型为&lt;code&gt;float&lt;/code&gt;类型, 把int类型数组的排序算法复制一遍不就可以了吗?&lt;/li&gt;
&lt;li&gt;那如果我继续追问, 如果现在要对一只猫进行排序, 那应该怎么做呢? 猫的类如下&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class Cat{
    private int age;//猫的年龄
    private int weight;//猫的体重

    //get / set 方法...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;你也许会顺着原来的思路回答, 照样copy一份排序的算法, 修改方法参数, 然后在比较的地方指定比较猫的年龄或体重不就可以了吗?&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void sort(Cat[] arr){//以猫数组作为参数
    for(int i = arr.length - 1; i &amp;gt; 0; i--){
        for(int j = 0; j &amp;lt; i; j++){
            if(arr[j].getAge() &amp;gt; arr[j + 1].getAge())//根据猫的年龄作比较
                swap(arr, j, j  + 1);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;但仔细想想, 如果还要继续比较小狗, 小鸡, 小鸭等各种对象, 那么这个排序工具类的代码量岂不是变得很大? 为了能让排序算法的可重用性高一点, 我们希望排序工具中的&lt;code&gt;sort()&lt;/code&gt;方法可以对任何调用它的对象进行排序.&lt;/li&gt;
&lt;li&gt;你可能会想: 到对任何对象都能排序, 把&lt;code&gt;sort()&lt;/code&gt;方法的参数改为&lt;code&gt;Object&lt;/code&gt;类型不久可以了嘛. 这个方向是对的, 但是问题是, 当拿到两个&lt;code&gt;Object&lt;/code&gt;类型对象, 应该根据什么规则进行比较呢?&lt;/li&gt;
&lt;li&gt;这个时候我们自然而然地就希望调用工具类进行排序的对象本身就具备自己的&lt;code&gt;比较法则&lt;/code&gt;, 这样在排序的时候就能直接调用对象的排序法则进行排序了.&lt;/li&gt;
&lt;li&gt;我们把比较法则抽象为&lt;code&gt;Comparable&lt;/code&gt;接口, 凡是要进行比较的类都要实现&lt;code&gt;Comparable&lt;/code&gt;接口, 并且定义自己的比较法则, 也就是&lt;code&gt;CompareTo()&lt;/code&gt;方法.&lt;/li&gt;
&lt;li&gt;这样当我们在封装工具时, 就可以直接对实现了&lt;code&gt;Comparable&lt;/code&gt;接口的对象进行比较, 不用担心比较的细节了.&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Strategy {
public class Strategy {
    public static void main(String[] args) {
//      Integer[] arr = {5, 3, 1, 7, 2};//注意这里把int改为Integer, Integer是Object的子类
        Cat[] arr = {new Cat(3, 3), new Cat(1, 1), new Cat(5, 5)};
        DataSorter ds = new DataSorter();
        ds.sort(arr);
        for(int i = 0; i &amp;lt; arr.length; i++){
            System.out.println(arr[i]);
        }
    }
}
}

class DataSorter{//用于排序的工具类
    public void sort(Object[] arr){//参数类型为Object
        for(int i = arr.length - 1; i &amp;gt; 0; i--){
            for(int j = 0; j &amp;lt; i; j++){
                Comparable c1 = (Comparable) arr[j];//先转为Comparable类型
                Comparable c2 = (Comparable) arr[j + 1];
                if(c1.CompareTo(c2) == 1)//调用CompareTo()进行比较, 不关心具体的实现
                    swap(arr, j, j  + 1);
            }
        }
    }

    private void swap(Object[] arr, int i, int j){
        Object temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}

class Cat implements Comparable{
    private int age;
    private int weight;

    @Override
    public int CompareTo(Object o) {
        if(o instanceof Cat){//先判断传入的是否是Cat类对象, 不是则抛异常
            Cat c = (Cat) o;
            if(this.age &amp;gt; c.age) return 1;
            else if (this.age &amp;lt; c.age) return -1;
            else return 0;
        }
        throw null == o ? new NullPointerException() : new ClassCastException();
    }

    // get / set ...
    //toString() ...
}

interface Comparable{
    public int CompareTo(Object o);
}&lt;/code&gt;
&lt;/pre&gt;


&lt;ul&gt;&lt;li&gt;相信看了上面的&lt;code&gt;Comparable&lt;/code&gt;接口来由, 大家会感觉整个设计又美好了一些, 但是其中还有漏洞. 我们在&lt;code&gt;Cat&lt;/code&gt;类的&lt;code&gt;CompareTo()&lt;/code&gt;方法中, 对猫的比较策略是写死的, 现在我们按猫的年龄比较大小, 如果哪天我们想按照猫的体重比较大小, 又要去修改源码了. 有没有扩展性更好的设计?&lt;/li&gt;
&lt;li&gt;我们可以让用户自己定义一个比较器类, 对象可以根据用户指定的比较器比较大小.&lt;/li&gt;
&lt;li&gt;整个逻辑是: 如果这个对象需要进行比较, 那么它必须实现&lt;code&gt;Comparable&lt;/code&gt;接口, 但是它具体是怎么比较的, 则通过具体的&lt;code&gt;Comparator&lt;/code&gt;比较器进行比较.&lt;/li&gt;
&lt;li&gt;当然这里少不了多态, 我们首先要定义一个比较器接口&lt;code&gt;Comparator&lt;/code&gt;, 用户的比较器需要实现&lt;code&gt;Comparator&lt;/code&gt;接口, 下面上代码:&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Strategy {
    public static void main(String[] args) {
        Cat[] arr = {new Cat(3, 3), new Cat(1, 1), new Cat(5, 5)};
        DataSorter ds = new DataSorter();
        ds.sort(arr);
        for(int i = 0; i &amp;lt; arr.length; i++){
            System.out.println(arr[i]);
        }
    }
}

class DataSorter{//用于排序的工具类
    public void sort(Object[] arr){//参数类型为Object
        for(int i = arr.length - 1; i &amp;gt; 0; i--){
            for(int j = 0; j &amp;lt; i; j++){
                Comparable c1 = (Comparable) arr[j];//先转为Comparable类型
                Comparable c2 = (Comparable) arr[j + 1];
                if(c1.CompareTo(c2) == 1)//背后已经转换为使用Comparator的定义的规则进行比较
                    swap(arr, j, j  + 1);
            }
        }
    }

    private void swap(Object[] arr, int i, int j){
        Object temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}

class Cat implements Comparable{
    private int age;
    private int weight;
    private Comparator comparator = new CatAgeComparator();//默认持有年龄比较器

    @Override
    public int CompareTo(Object o) {
        return comparator.Compare(this, o);//调用比较器比较而不是直接在此写比较法则
    }

    // get / set / toString ...
}

interface Comparable{
    public int CompareTo(Object o);
}

interface Comparator{
    public int Compare(Object o1, Object o2);
}

//用户自己定义的, 按照猫的年龄比较大小的比较器
class CatAgeComparator implements Comparator{
    @Override
    public int Compare(Object o1, Object o2) {
        Cat c1 = (Cat) o1;
        Cat c2 = (Cat) o2;
        if(c1.getAge() &amp;gt; c2.getAge()) return 1;
        else if(c1.getAge() &amp;lt; c2.getAge()) return -1;
        else return 0;
    }
}

//按照猫的体重比较大小的比较器
class CatWeightComparator implements Comparator{
    @Override
    public int Compare(Object o1, Object o2) {
        Cat c1 = (Cat) o1;
        Cat c2 = (Cat) o2;
        if(c1.getWeight() &amp;gt; c2.getWeight()) return 1;
        else if(c1.getWeight() &amp;lt; c2.getWeight()) return -1;
        else return 0;
    }
}&lt;/code&gt;
&lt;/pre&gt;


&lt;ul&gt;&lt;li&gt;在上面的例子中, 我们自己定义了&lt;code&gt;Comparable&lt;/code&gt;接口和&lt;code&gt;Comparator&lt;/code&gt;接口, 其实这两个接口都是Java自带的, 通过上面的代码示例, 想必大家也应该知道了为什么会有这两个接口.&lt;/li&gt;
&lt;li&gt;其实&lt;code&gt;Comparable&lt;/code&gt;定义的就是一种比较的策略, 这里的策略你可以理解为一个功能, 然而策略有了, 我们还需要有具体的策略实现, 于是便有了&lt;code&gt;Comparator&lt;/code&gt;接口.&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;&lt;li&gt;这里再举一个例子方便大家理解.&lt;/li&gt;
&lt;li&gt;现在有一个坦克小游戏, 坦克要能够发射炮弹, 那么我们可以认为发射炮弹就是一种策略, 但是具体到发送什么炮弹, 这可以由具体的策略实现.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/liuyj24/TankOnline&quot;&gt;到GitHub上看看该坦克游戏&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;首先定义发射炮弹这种策略&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface Fire {
    public void fire();//发射炮弹的策略
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;为了实现发射炮弹这种策略, 定义策略的具体实现, 也就是定义发射炮弹动作&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface FireAction {
    public void fireAction(Tank tank);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;坦克想要发送炮弹必须实现&lt;code&gt;Fire()&lt;/code&gt;接口, 而且坦克拥有发射炮弹的动作, 至于动作的具体实现, 这里默认给出只发射一颗炮弹的动作.&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Tank implements TankHitListener, Fire {
    //省略各种属性方法...
    private FireAction fireAction = new NormalFireAction();//默认动作是只发射一颗炮弹
    
    @Override
    public void fire() {
        fireAction.fireAction(this);
    }
    
    //...&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;使用了策略模式有什么好处&quot;&gt;使用了策略模式有什么好处?&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;以上面的坦克游戏为例, 当把发射炮弹定义为一种策略后, 能发射炮弹的对象就不只坦克一个了, 如果游戏中有机关, 可以让机关也实现&lt;code&gt;fire()&lt;/code&gt;接口, 获得发射炮弹的能力.&lt;/li&gt;
&lt;li&gt;而且在定义策略后我们可以根据策略给出不同的实现方式, 比方说坦克发射炮弹的动作是每次只发射一颗炮弹, 而机关是每次向八个方向发射一颗炮弹. 非常灵活.&lt;/li&gt;
&lt;li&gt;结束&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/tanshaoshenghao/1426602/o_tankGif.gif&quot;/&gt;</description>
<pubDate>Mon, 22 Apr 2019 13:07:00 +0000</pubDate>
<dc:creator>炭烧生蚝</dc:creator>
<og:description>[TOC] 引入 大家先考虑一个场景, 有一个整形数组, 我们希望通过调用一个工具类的排序方法就能对该数组进行排序. 请看下面的代码:   Comparable接口的来龙去脉 通过上面的代码</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tanshaoshenghao/p/10753022.html</dc:identifier>
</item>
<item>
<title>【带着canvas去流浪（8）】碰撞 - 大史不说话</title>
<link>http://www.cnblogs.com/dashnowords/p/10753005.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dashnowords/p/10753005.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354575/201904/1354575-20190422210456911-1651753080.jpg&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;3.2041884816754&quot;&gt;
&lt;p&gt;示例代码托管在：&lt;a href=&quot;https://github.com/dashnowords/blogs/tree/master/Demo/canvas-echarts/8.collision&quot;&gt;http://www.github.com/dashnowords/blogs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;博客园地址：&lt;a href=&quot;https://www.cnblogs.com/dashnowords/p/10127926.html&quot;&gt;《大史住在大前端》原创博文目录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;华为云社区地址：&lt;a href=&quot;https://bbs.huaweicloud.com/blogs/8ae7e6420a4611e9bd5a7ca23e93a891&quot;&gt;【你要的前端打怪升级指南】&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;经过前面章节相对枯燥的练习，相信你已经能够上手&lt;code&gt;canvas&lt;/code&gt;的原生API了，那么从这一节开始，我们就开始接触点好玩的东西——动画。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354575/201904/1354575-20190422210513384-1822868200.gif&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;一.-canvas的能力&quot;&gt;一. canvas的能力&lt;/h2&gt;
&lt;p&gt;如果你以为&lt;code&gt;canvas&lt;/code&gt;只能绘制图表那真的就图样图森破了，且不谈&lt;code&gt;webgl&lt;/code&gt;的绘图上下文，单就2d空间的画笔就可以做很多有意思的事情，比如实现一些酷炫的动画效果，比如做一些&lt;strong&gt;物理仿真，图片滤镜，直播弹幕，甚至做游戏开发&lt;/strong&gt;等等，画面的变化大多依赖于canvas提供的像素操作能力，而动效几乎都是靠canvas在短时间内逐帧绘制而形成的，和电影的原理是一样的。&lt;/p&gt;
&lt;p&gt;我们知道&lt;code&gt;javascript&lt;/code&gt;中和时间控制有关的函数&lt;code&gt;setTimeout( )&lt;/code&gt; 以及&lt;code&gt;setInterval( )&lt;/code&gt;最终执行时的时间点并不准确，因为在事件队列中会被其他异步任务影响甚至直接阻塞，那么在不断重复的绘制中，就有可能会出现卡顿或者忽快忽慢；另一方面，假设我们使用的电脑显示屏刷新率为&lt;strong&gt;60帧/秒&lt;/strong&gt;，也就是大约16.7ms重绘一次，那么即时我们在16.7ms时间内执行了很多次计算和绘制命令，实际上最终呈现出的也只是最后一次结果，就好比对一段很密集的数据进行了隔点采样，轻则浪费性能，重则会在画面呈现时出现跳帧。为了配合显示器刷新，我们可以使用另一个方法——&lt;code&gt;requestAnimationFrame（fn）&lt;/code&gt;，这是javascript中专门用来绘制逐帧动画的，它会配合显示器的刷新频率进行必要的图像更新，节省不必要的性能浪费。&lt;/p&gt;
&lt;h2 id=&quot;二.-动画框架&quot;&gt;二. 动画框架&lt;/h2&gt;
&lt;p&gt;在&lt;code&gt;canvas&lt;/code&gt;上实现基本的动画，可以遵循一个基本的编程框架:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;function step(){
    /**
    *在每一帧中要执行的逻辑
    *......
    */
    requestAnimationFrame(step);
}

step();//启动执行&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你没看错，这就是&lt;code&gt;canvas&lt;/code&gt;动画最核心的一段代码，&lt;code&gt;step（）&lt;/code&gt;函数会在每个绘图周期内重复执行。那么每一帧中需要做哪些工作呢？&lt;/p&gt;
&lt;p&gt;我们将canvas想象成一个舞台&lt;code&gt;stage&lt;/code&gt;，每一个需要绘制在画布上的元素被称为&lt;strong&gt;精灵&lt;/strong&gt;，无论它们拥有怎样的属性，它们都具备&lt;code&gt;update( )&lt;/code&gt;和&lt;code&gt;paint( )&lt;/code&gt;两个基本方法，前者用于在每一帧中计算更新精灵的参数属性，后者用于将这个精灵对象绘制在画布上。那么&lt;code&gt;step&lt;/code&gt;函数在每一帧中所执行的逻辑就变得明朗了，对画布进行必要的擦除，接着更新每一个精灵的状态（可能是位置，颜色等等），然后将其绘制在画布上。&lt;/p&gt;
&lt;p&gt;比如现在要在画布上表现一段太阳东升西落得动画，对应的伪代码就是下面这个样子的：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;let stage = [];
stage.push(background, tree, cloud, sun);

function step(){
    cleanStage();//对画布进行必要擦除
    background.update();//更新土地的属性
    tree.update();//更新树的属性
    cloud.update();//更新云的属性
    sun.update();//更新太阳的属性（属性中必然包含着太阳的位置数据）
    background.paint();//绘制土地
    tree.paint();//绘制树
    cloud.paint();//绘制云
    sun.paint();//绘制太阳
    requestAnimationFrame(step);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果你理解了上面的过程，那么接下来我们对上述代码进行一些抽象和改写：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;//建立舞台及添加元素的代码
let stage = [];
stage.push(background, tree, cloud, sun....);

//逐帧动画代码
function step(){
    cleanStage();
    stage.map(sprite=&amp;gt;{
        sprite,update();
        sprite.paint(ctx);
    });
    requestAnimationFrame(step);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;每一个精灵对象都需要实现自己的&lt;code&gt;update( )&lt;/code&gt;和 &lt;code&gt;paint( )&lt;/code&gt;方法来描述自己的参数如何变化，以及如何在每一帧中被绘制，被添加进stage数组的都是精灵的实例，一般会将canvas绘图上下文传入&lt;code&gt;paint(context)&lt;/code&gt;方法，这样就可以将精灵绘制在指定的画布上。上面的范式只是一个简陋的核心模型，但是已经足够说明canvas动画的本质。&lt;/p&gt;
&lt;h2 id=&quot;三.-在canvas中模拟碰撞&quot;&gt;三. 在canvas中模拟碰撞&lt;/h2&gt;
&lt;p&gt;现在我们就通过一个碰撞仿真的例子来学习canvas动画以及基本的物理仿真分析，示例虽然精简，但包含了canvas动效最核心的精灵动画和碰撞检测主题。为了方便二维向量操作并隐藏各种数学计算的细节，我们直接使用一个已经定义好的&lt;code&gt;Vector2&lt;/code&gt;类，其中封装了很多向量的基本操作，都是初高中数学的知识，如果你已经记不太清楚，可以找一些有关的资料复习一下。&lt;/p&gt;
&lt;h3 id=&quot;定义小球的属性&quot;&gt;3.1定义小球的属性&lt;/h3&gt;
&lt;p&gt;将每一个小球视为一个精灵，我们需要为它增加一些基本属性以便在每一帧中能够将其绘制出来。通过位置，半径和颜色信息，就能够绘制出小球；通过速度信息，就可以计算小球的位置变化，以便在绘制下一帧时使用。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;class Ball{
    constructor(x,y,id){
        this.pos = new Vector2(x,y);//初始化小球的位置
        this.id = id;
        this.color = '';//绘制的颜色
        this.r = 20;//小球半径，为方便演示，此处使用给定值
        this.velocity = null;//小球的速度
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;生成新的小球&quot;&gt;3.2 生成新的小球&lt;/h3&gt;
&lt;p&gt;为了增加演示效果，我们使用一个定时函数来随机生成小球，每次生成时为其赋予一个颜色，并给定一个随机的初始速度。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;//为全局balls数组增加一个新的小球,初始位置为(50,30),
function addBall() {
   let ball = new Ball(50,30,balls.length);
       ball.color = colorPalette[parseInt(steps / 100,10) % 10];
       ball.velocity = new Vector2(5*Math.random(), 5 * Math.random());
       balls.push(ball);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了方便起见，我们使用一个全局自增的数值变量，在&lt;code&gt;step&lt;/code&gt;中根据条件来执行&lt;code&gt;addBall()&lt;/code&gt;方法:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;if (steps % 100 === 0 &amp;amp;&amp;amp; steps &amp;lt; 1500) {
  addBall();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;step&lt;/code&gt;每循环100次（大约1.5秒）就会多生成一个向随机方向发射的小球，且小球的数量不能超过15个。&lt;/p&gt;
&lt;h3 id=&quot;帧动画绘制函数step&quot;&gt;3.3 帧动画绘制函数step&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;step&lt;/code&gt;函数是动画的核心，我们需要在其中完成重绘背景，添加小球，更新每个小球，绘制小球这些逻辑（由于背景是静态的，示例中并没有将其抽象为精灵动画）。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;function step() {
    steps++;
    //重绘背景
    paintBg();
    //每隔一定时间增加一个小球
    if (steps % 100 === 0 &amp;amp;&amp;amp; steps &amp;lt; 1500) {
      addBall();
    }
    //更新每个小球的状态
    balls = balls.map((ball,index,originArr)=&amp;gt;{
      ball.update(index,originArr);
      ball.paint();//描线但不在画布上绘制
      return ball;
    });
    //绘制每个小球位置
    requestAnimationFrame(step);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;定义小球的update方法&quot;&gt;3.4 定义小球的update方法&lt;/h3&gt;
&lt;p&gt;精灵的绘制方法&lt;code&gt;paint&lt;/code&gt;一般都只涉及&lt;code&gt;canvas&lt;/code&gt;的基本绘图&lt;code&gt;API&lt;/code&gt;,并不复杂，例如本例中，只需要在小球的&lt;code&gt;pos&lt;/code&gt;属性记录的位置处绘制一个封闭弧线并填充它就可以了。精灵的&lt;code&gt;update( )&lt;/code&gt;方法往往才是最难编写的部分。在这个方法中，需要完成的基本逻辑包括状态更新和碰撞检测。&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;状态更新&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;状态更新一般包括自身状态更新和相对状态更新。自身状态的更新，比如你希望小球在运动过程中颜色会有变化，就属于自身状态的变化，相对状态变化一般指小球相对公共坐标系或某个参照对象而发生的宏观位置变化，比如本例中的小球位置变化。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;碰撞检测&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;碰撞检测一般包括精灵是否与其他精灵发生碰撞，并需要对碰撞后造成的影响进行仿真。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;参考代码:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;/*更新状态
由于检测碰撞需要知道其他小球的位置，故此处将小球数组的引用传入
也可以直接以面向对象的方式来定义*/
update(index,balls){

    let nextPos;//模拟下一次落点

    //1.计算下一次落点
    nextPos = this.pos.add(this.velocity.multiply(dt)); 

    //2.判断新位置是否碰触边界，如果是则边界法向的速度反向，假设碰撞过程是无能量损失
    if (nextPos.x + this.r &amp;gt; rightBorder || nextPos.x &amp;lt; this.r) {
        this.velocity.x = -1 * this.velocity.x;//速度分量反向
        nextPos = this.pos;//取消当前帧的位置更新
    } 
    if (nextPos.y + this.r &amp;gt; bottomBorder || nextPos.y &amp;lt; this.r) {
        this.velocity.y = -1 * this.velocity.y;
        nextPos = this.pos;
    }

    //3.判断是否与其他小球产生碰撞，为避免重复，每个小球只和比自己id更大的小球做检测
    balls.map(ball=&amp;gt;{
       if (ball.id &amp;gt; index &amp;amp;&amp;amp; this.checkCollision(ball)) {
           this.handleCollision(ball);
       }
       return ball;
    });

    //4.确认更新位置
    this.pos = nextPos;      
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;碰撞检测&quot;&gt;3.5 碰撞检测&lt;/h3&gt;
&lt;p&gt;规则形状的碰撞检测一般有某些特殊方法，例如平面内的小球，其实只需要判断圆心的距离和两球半径和的大小，就可以知道两球是否碰撞。而当检测物体的外观并不规则时，碰撞检测是成了一个非常复杂的问题，最常用的方法包括外接盒检测，光线投射法和分离轴定理检测，感兴趣的小伙伴可以自行查资料进行学习。本例中的检测方法实际上是外接盒检测法的一种基本情况。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;//碰撞检测
checkCollision(ball){
   return this.pos.subtract(ball.pos).length() &amp;lt; this.r + ball.r;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;碰撞仿真&quot;&gt;3.6 碰撞仿真&lt;/h3&gt;
&lt;p&gt;碰撞仿真就是利用物理知识来计算碰撞对于物体造成的影响并修改其对应参数。本例中的碰撞可以抽象为&lt;strong&gt;两个质量相等的运动小球的非对心碰撞&lt;/strong&gt;，且不计能量损失，一般情况下需要使用能量守恒定理和动量守恒定理联立方程进行求解。本例的仿真中，我们先将&lt;strong&gt;小球的非对心碰撞&lt;/strong&gt;简化为&lt;strong&gt;对心碰撞&lt;/strong&gt;，方法是将小球的速度向量分解为沿球心连线方向&lt;code&gt;Vr&lt;/code&gt;以及沿圆心连线法向&lt;code&gt;Vn&lt;/code&gt;两个分量，然后使用两个小球的&lt;code&gt;Vr&lt;/code&gt;来进行对心碰撞的模拟（质量相等的刚体对心碰撞后会互换速度），接着再将碰撞后的速度与小球自己的法向速度&lt;code&gt;Vn&lt;/code&gt;进行向量合成即可。&lt;/p&gt;
&lt;p&gt;本例的代码中使用了简化的方案，只计算了沿球心连线方向的分量并进行了碰撞模拟，没有对碰撞后的速度进行合成，但对碰撞模拟的效果影响不大。参考代码如下：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;//处理碰撞
handleCollision(ball){
    let ballToThis = this.pos.subtract(ball.pos).normalize();
    let thisToBall = ballToThis.negate();
    this.velocity = ballToThis.multiply(Math.abs(ball.velocity.length()*(ball.velocity.dot(ballToThis) / ball.velocity.length())));
    ball.velocity = thisToBall.multiply(Math.abs(this.velocity.length()*(this.velocity.dot(ballToThis) / this.velocity.length())));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;碰撞后两个小球的速度都发生了变化，在下一帧更新位置时就会表现出来，效果已经在本节开头展示出了。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;完整的示例代码可以参见附件的demo，或访问开头处我的&lt;code&gt;github&lt;/code&gt;仓库地址。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;四.-下一步&quot;&gt;四. 下一步&lt;/h2&gt;
&lt;p&gt;有了这样一个撞球的基本模型和示例，你能做出一个乒乓球小游戏或是撞球小游戏吗？&lt;/p&gt;
</description>
<pubDate>Mon, 22 Apr 2019 13:06:00 +0000</pubDate>
<dc:creator>大史不说话</dc:creator>
<og:description>示例代码托管在： 'http://www.github.com/dashnowords/blogs' 博客园地址： '《大史住在大前端》原创博文目录' 华为云社区地址： '【你要的前端打怪升级指南】'</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dashnowords/p/10753005.html</dc:identifier>
</item>
<item>
<title>vue项目首屏加载优化实战 - 面包大虾</title>
<link>http://www.cnblogs.com/mianbaodaxia/p/10751453.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mianbaodaxia/p/10751453.html</guid>
<description>&lt;p&gt;单页面应用的一个问题就是首页加载东西过多，加载时间过长。特别在移动端，单页面应用的首屏加载优化更是绕不开的话题。下面我会写出我在项目中做的一些优化，希望大家能够相互讨论，共同进步。&lt;/p&gt;
&lt;p&gt;我的项目&lt;strong&gt;vue-cli3构建的，vue+vue-router+vuex，UI框架选用 element-ui，ajax方案选用 axios，服务器使用Nginx&lt;/strong&gt;。用到的这些技术都是现在用的比较广泛的，看到这篇文章，我估计你和我用的技术应该差不多。&lt;/p&gt;
&lt;h2&gt;第一步：webpack-bundle-analyzer 分析&lt;/h2&gt;
&lt;p&gt;首页我们来看看没有经过任何优化的打包分析，vue-cli3的项目直接&lt;strong&gt;vue-cli-service build --report&lt;/strong&gt;就会生成一个report.html，打开这个html就能看到，不是vue-cli3的项目需要自行安装这个插件，参考链接，&lt;a href=&quot;https://segmentfault.com/a/1190000017716736&quot; target=&quot;_blank&quot;&gt;点击&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1071709/201904/1071709-20190422182609543-2138501830.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图所示在vendor比较大的文件有element，moment，echart，还有jquery，然后还有一些没见过的vue-qriously这些组件，接下来我们来一步一步让vendor变小&lt;/p&gt;
&lt;h2&gt;第二步：初步优化&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1. 仔细考虑组件是否需要全局引入&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在我们的main.js，我发现有很多组件被全局引入，其中有些组件只有1，2个页面用到，这些组件不需要全部引入&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
import ImageComponent from 'COMMON/imageComponent'&lt;span&gt;
import InfiniteLoading from &lt;/span&gt;'COMMON/infiniteLoading'&lt;span&gt;
import SearchDialog from &lt;/span&gt;'COMMON/SearchDialog'&lt;span&gt;
import BasicTable from &lt;/span&gt;'COMMON/BasicTable'&lt;span&gt;
import VueQriously from &lt;/span&gt;'vue-qriously'&lt;span&gt;

Vue.use(ImageComponent)
Vue.use(InfiniteLoading) // 可以去除
Vue.use(SearchDialog) // 可以去除
Vue.use(BasicTable)  // 可以去除
Vue.use(VueQriously)  // 可以去除&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面一段代码是我们main.js中的代码，其中ImageComponent是用来处理图片的，用到的页面很多，其他的组件都只要较少的页面用到，我们在main.js中删除，移到具体的页面中去。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2. 手动引入 ECharts 各模块&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;默认引入 ECharts 是引入全部的```import * as ECharts from 'echarts' ```我们只需要部分组件，只需引入自己需要的部分。参考地址，&lt;a href=&quot;https://github.com/ecomfe/vue-echarts/blob/master/README.zh_CN.md&quot; target=&quot;_blank&quot;&gt;点击&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
import VueECharts from 'vue-echarts/components/ECharts.vue'&lt;span&gt;
import &lt;/span&gt;'echarts/lib/chart/line'&lt;span&gt;
import &lt;/span&gt;'echarts/lib/chart/bar'&lt;span&gt;
import &lt;/span&gt;'echarts/lib/chart/pie'&lt;span&gt;
import &lt;/span&gt;'echarts/lib/component/title'&lt;span&gt;
import &lt;/span&gt;'echarts/lib/component/tooltip'&lt;span&gt;
import &lt;/span&gt;'echarts/lib/component/legend'&lt;span&gt;
import &lt;/span&gt;'echarts/lib/component/markPoint'
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.使用更轻量级的工具库&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;moment是处理时间的标杆，但是它过于庞大且默认不支持tree-shaking，而且我们的项目中只用到了moment(), format(), add(), subtract()等几个非常简单的方法，有点大材小用，所以我们用 &lt;a href=&quot;https://github.com/date-fns/date-fns&quot; target=&quot;_blank&quot;&gt;date-fns&lt;/a&gt; 来替换它，需要什么方法直接引入就行。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1071709/201904/1071709-20190422194833620-693794572.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;经过上面的三步初步优化，我们可以看到vendor.js变小了很多，去除了moment，我们项目之前echart就是按需加载的。&lt;/p&gt;
&lt;h2&gt;第三步：CDN优化&lt;/h2&gt;
&lt;p&gt; 进过上面的优化，发现 Vue 全家桶以及 ElementUI 仍然占了很大一部分 vendors 体积，这部分代码是不变的，但会随着每次 vendors 打包改变 hash 重新加载。我们可以使用 CDN 剔除这部分不经常变化的公共库。我们将&lt;span&gt;&lt;strong&gt;vue，vue-router，vuex，axios，jquery，underscore&lt;/strong&gt;&lt;/span&gt;，使用CDN资源引入。国内的CDN服务推荐使用 &lt;a href=&quot;https://www.bootcdn.cn/&quot; target=&quot;_blank&quot;&gt;BootCDN&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.首先我们在index.html中，添加CDN代码&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;...
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;link &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;https://cdn.bootcss.com/element-ui/2.7.2/theme-chalk/index.css&quot;&lt;/span&gt;&lt;span&gt; rel&lt;/span&gt;&lt;span&gt;=&quot;stylesheet&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;https://cdn.bootcss.com/vue/2.6.10/vue.min.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;https://cdn.bootcss.com/vuex/3.1.0/vuex.min.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;https://cdn.bootcss.com/vue-router/3.0.4/vue-router.min.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;https://cdn.bootcss.com/axios/0.18.0/axios.min.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;https://cdn.bootcss.com/element-ui/2.7.2/index.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;https://cdn.bootcss.com/jquery/3.4.0/jquery.min.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;https://cdn.bootcss.com/underscore.js/1.9.1/underscore-min.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.在vue.config.js中加入webpack配置代码，关于webpack配置中的externals，请&lt;a href=&quot;https://webpack.js.org/configuration/externals/&quot; target=&quot;_blank&quot;&gt;参考地址&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;configureWebpack: {
  externals: {
    &lt;/span&gt;'vue': 'Vue'&lt;span&gt;,
    &lt;/span&gt;'vue-router': 'VueRouter'&lt;span&gt;,
    &lt;/span&gt;'vuex': 'Vuex'&lt;span&gt;,
    &lt;/span&gt;'element-ui': 'ELEMENT'&lt;span&gt;,
    &lt;/span&gt;'axios': 'axios'&lt;span&gt;,
    &lt;/span&gt;'underscore'&lt;span&gt; : {
      commonjs: &lt;/span&gt;'underscore'&lt;span&gt;,
      amd: &lt;/span&gt;'underscore'&lt;span&gt;,
      root: &lt;/span&gt;'_'&lt;span&gt;
    },
    &lt;/span&gt;'jquery'&lt;span&gt;: {
      commonjs: &lt;/span&gt;'jQuery'&lt;span&gt;,
      amd: &lt;/span&gt;'jQuery'&lt;span&gt;,
      root: &lt;/span&gt;'$'&lt;span&gt;
    }
  },
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;3. 去除vue.use相关代码&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;需要注意的是，通过 CDN 引入，在使用 VueRouter Vuex ElementUI 的时候要改下写法。CDN会把它们挂载到window上，因此不再使用Vue.use(xxx)&lt;/p&gt;
&lt;p&gt;也不在需import Vue from 'vue', import VueRouter from 'vue-router' 等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1071709/201904/1071709-20190422201103764-1878969642.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;剔除全家桶和Element-ui等只有，剩下的需要首次加载 vendors 就很小了。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;使用 CDN 的好处有以下几个方面&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;（1）加快打包速度。分离公共库以后，每次重新打包就不会再把这些打包进 vendors 文件中。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;（2）CDN减轻自己服务器的访问压力，并且能实现资源的并行下载。浏览器对 src 资源的加载是并行的(执行是按照顺序的)。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt; 第四步：检查Nginx 是否开启 gzip&lt;/h2&gt;
&lt;p&gt;如下图所示，开启了gzip后js的大小比未开启gzip的js小2/3左右，所以如果没开启gzip，感觉我们做的再多意义也不大，如何看自己的项目有没有开启gzip，如下图所示，开启了gzip，在浏览器的控制台Content-Encoding一栏会显示gzip，否则没有。Nginx如果开启gzip，请自行搜索，或者叫服务端来开启。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1071709/201904/1071709-20190422174911008-1641961014.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1071709/201904/1071709-20190422175218054-1158680500.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;第五步：检查路由懒加载&lt;/h2&gt;
&lt;p&gt;路由组件如果不按需加载的话，就会把所有的组件一次性打包到app.js中，导致首次加载内容过多，vue官方文档中也有提到，&lt;a href=&quot;https://cn.vuejs.org/v2/guide/components-dynamic-async.html#%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6&quot; target=&quot;_blank&quot;&gt;地址&lt;/a&gt;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  name: &lt;/span&gt;'vipBoxActivity'&lt;span&gt;,
  path:&lt;/span&gt;'vipBoxActivity'&lt;span&gt;,
  component(resolve) {
    require([&lt;/span&gt;'COMPONENTS/vipBox/vipBoxActivity/main.vue'&lt;span&gt;], resolve)
  }
},&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  path: &lt;/span&gt;'buyerSummary'&lt;span&gt;,
  name: &lt;/span&gt;'buyerSummary'&lt;span&gt;,
  component: () &lt;/span&gt;=&amp;gt; import('VIEWS/buyer/buyerSummary/index'&lt;span&gt;),
},&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的两种引入组件的方法都是正确的，都能实现路由的懒加载。&lt;/p&gt;

&lt;h2&gt;最后 &lt;/h2&gt;
&lt;p&gt;最后我们可以发现vendor.js的大小减少了很多。其中第一步到第三步我们项目中都没做，第四步和第五步我们做了。如果读者你没做，一定要注意了。最后希望这篇文字能够对大家有一点点帮组&lt;/p&gt;
</description>
<pubDate>Mon, 22 Apr 2019 12:17:00 +0000</pubDate>
<dc:creator>面包大虾</dc:creator>
<og:description>问题 单页面应用的一个问题就是首页加载东西过多，加载时间过长。特别在移动端，单页面应用的首屏加载优化更是绕不开的话题。下面我会写出我在项目中做的一些优化，希望大家能够相互讨论，共同进步。 我的项目vu</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mianbaodaxia/p/10751453.html</dc:identifier>
</item>
<item>
<title>更新缓存 - 不要乱摸</title>
<link>http://www.cnblogs.com/cjsblog/p/10752245.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cjsblog/p/10752245.html</guid>
<description>&lt;p&gt;&lt;span&gt;更新缓存的时候涉及两个问题：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;删除（del）还是 修改（set）？&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;先操作数据库，还是 先操作缓存？&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;组合起来就有四种情况：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一种情况：先删除缓存，后更新数据库&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果删除缓存失败，则后面的操作都不会执行，没问题；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果删除缓存成功，更新数据库失败，则缓存与数据库不一致，但这种不一致会马上被修正，因而不影响，因为下一次请求缓存的时候发现缓存中没有，会从数据库重新加载；但是，又有一个问题出现了，在旧的缓存被删除后，新的缓存未写入之前，这段时间内如果有读操作，那么旧的值会被重新加载到缓存，这就相当于没更新缓存；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第二种情况：先更新缓存，后更新数据库&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;同样，如果更新缓存成功，更新数据库是吧，则出现缓存与数据库不一致，&lt;strong&gt;数据不一致就是问题&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第三种情况：先更新数据库，后删除缓存&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果更新数据库成功，删除缓存失败，则出现缓存与数据库不一致，&lt;strong&gt;数据不一致就是问题&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第四种情况：先更新数据库，后更新缓存&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;跟第三种情况一样&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;虽然，看上去好像都有问题，但是，&lt;strong&gt;任何脱离实际业务的设计都是耍流氓&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;既然我们把Redis当缓存，那么所有数据都要以数据库为准，像上面第二种情况（缓存中有的数据在数据库中没有）是不能容忍的，而对于第一种情况，可以采取双删的策略（删除缓存 --&amp;gt; 更新数据库 --&amp;gt; 再删除缓存），后面两种情况，可以用定时任务进行补偿，有些场景下我们是可以接受不一致的情况的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不过，话又说回来，直接删除缓存当然是最简单的，它相当于延迟加载（第一次使用的时候发现没有才会去从数据库加载），这样可能导致第一次请求会比较慢；而采用修改缓存的方式，相当于预先加载。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在实际使用的时候，可以采用这两种方式：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;先删除缓存，再更新数据库，最后再删一次&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;先更新数据库，然后向MQ发一条消息，由专门的缓存服务去更新数据&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;span&gt;上面说的是只有一个数据库实例的情况，而实际生产过程中肯定是一主多从的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;按照写主读从，缓存加载数据的时候应该从从库中读，而本来主从同步就有延迟，于是读从库很有可能读到的是旧数据&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了解决这种问题，可以考虑以下几种方案：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一种：强制缓存读主数据库&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这样一来，就不必考虑主从同步的问题了，可行（PS：跟微信公众号开发的时候获取Token一样）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第二种：选择性地读主数据库&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;之所以强制读主库，是因为再主从同步完成之前从库中的数据还是旧的，当主从同步完成后再读从库就没什么问题了，那么如果在主从同步的这段时间内如果没有请求读这个KEY就没有问题，如果这段时间内有请求读取这个KEY，那么在同步完成后要删除这个KEY&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如何判断在主从同步这段时间内有没有请求读取这个KEY呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在更新数据库的时候，往缓存中设置一个KEY，格式是：缓存KEY+业务数据ID，其生存时间是主从延时时间&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如，假设主从同步延时是3秒，而有业务缓存KEY是hash类型的，更新的这条数据的ID是213，那么在更新数据库后要立即设置  set USER_213_KV  1  3&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在读的时候，首先判断缓存中有没有这样一个KEY，如果有则从主库中重新加载数据到缓存，没有，则直接从从库中加载数据到缓存&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第三种：订阅从库的binlog&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以通过工具（比如，canal）订阅从库的binlog，这是比较准确的，从库数据有更新，则立即更新缓存&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://github.com/alibaba/canal&quot;&gt;https://github.com/alibaba/canal&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;补充1：缓存穿透&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;缓存穿透&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;缓存穿透，指的是查询一个数据库中不存在的数据。这样的话，每次都会查询数据库，相当于缓存就没有用了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;针对这种情况，可以缓存空值，并设置一个较短的生存时间，比如60秒。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;缓存雪崩&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;缓存雪崩，指的是大量缓存在一段时间内集体失效。这样的话，短时间内大量请求会直接打到数据库。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;针对这种情况，可以在缓存的生存时间后面再加上一个随机数，这样的话就不至于同一时刻集体过期。实际上，因为大量缓存失效意味着这些缓存在同一时刻被设置的，而这种情况不多见。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;缓存击穿&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;缓存击穿，指的是单个缓存在被高并发访问时失效了导致请求全部打到数据库。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;针对这种情况，在加载缓存的时候要加分布式锁。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;补充2：Redis客户端工具Medis&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://github.com/luin/medis&quot;&gt;https://github.com/luin/medis&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
git clone https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;github.com/luin/medis.git&lt;/span&gt;
&lt;span&gt;cd medis
npm &lt;/span&gt;&lt;span&gt;install&lt;/span&gt;&lt;span&gt;
npm run build
npm start&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/874963/201904/874963-20190422192347253-2059999245.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/874963/201904/874963-20190422192359546-1385109275.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 22 Apr 2019 11:27:00 +0000</pubDate>
<dc:creator>不要乱摸</dc:creator>
<og:description>更新缓存的时候涉及两个问题： 删除（del）还是 修改（set）？ 先操作数据库，还是 先操作缓存？ 组合起来就有四种情况： 第一种情况：先删除缓存，后更新数据库 如果删除缓存失败，则后面的操作都不</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cjsblog/p/10752245.html</dc:identifier>
</item>
<item>
<title>深入学习ThreadLocal原理 - 木瓜芒果</title>
<link>http://www.cnblogs.com/volcano-liu/p/10712524.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/volcano-liu/p/10712524.html</guid>
<description>&lt;p&gt;　　&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/volcano-liu/p/10681399.html&quot; target=&quot;_blank&quot;&gt;上文&lt;/a&gt;我们学习了ThreadLocal的基本用法以及基本原理，ThreadLocal中的方法并不多，基本用到的也就get、set、remove等方法，但是其核心逻辑还是在定义在ThreadLocal内部的静态内部类ThreadLocalMap中，里面有很多设计非常精妙的地方，本文中我们就从ThreadLocalMap的角度入手深入学习ThreadLocal的原理。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt; 1. 基本数据结构&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;按照官方的解释是：这是一个定制化的Hash类型的map，专门用来保存线程本地变量。其内部采用是通过一个自定义的Entry来封装数据，并且保存在一个Entry数组中。为了便于处理大量且长时间存活的对象引用(其实是ThreadLocal)，Entry采用WeakReference作为key的类型，当map中空间不够时，key为null的ertry将会被删除。ThreadLocalMap内部数据结构如下：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ThreadLocalMap {

  &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Entry &lt;span&gt;extends&lt;/span&gt; WeakReference&amp;lt;ThreadLocal&amp;lt;?&amp;gt;&amp;gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 要保存到线程本地的变量 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
      Object value;

      Entry(ThreadLocal&lt;/span&gt;&amp;lt;?&amp;gt;&lt;span&gt; k, Object v) {
          &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(k);
          value &lt;/span&gt;=&lt;span&gt; v;
      }
  }

  &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
   * 数组初始容量 -- 必须为2的倍数.
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; INITIAL_CAPACITY = 16&lt;span&gt;;

  &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
   * 存储entry的数组，长度为2的倍数
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
  &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Entry[] table;

  &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
   * entries数量
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; size = 0&lt;span&gt;;

  &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
   * resize阈值
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; threshold; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Default to 0&lt;/span&gt;

  &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
   * 计算阈值
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setThreshold(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; len) {
      threshold &lt;/span&gt;= len * 2 / 3&lt;span&gt;;
  }

  &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
   * i+1，大于等于len则从0开始继续
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; nextIndex(&lt;span&gt;int&lt;/span&gt; i, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; len) {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ((i + 1 &amp;lt; len) ? i + 1 : 0&lt;span&gt;);
  }

  &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
   * i-1，小于0则从len-1开始继续
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; prevIndex(&lt;span&gt;int&lt;/span&gt; i, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; len) {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ((i - 1 &amp;gt;= 0) ? i - 1 : len - 1&lt;span&gt;);
  }

  ......

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　在ThreadLocalMap内部通过自定义的Entry类来封装要保存的数据，以ThreadLocal类型对象为key，Object类型对象为value。这个Entry继承自WeakReference&amp;lt;ThreadLocal&amp;lt;?&amp;gt;&amp;gt;，每个Entry都可以是一个指向ThreadLocal对象的弱引用，可通过Entry的get方法来获取对ThreadLocal对象的引用，而这个引用就是key。所有的Entry统一保存在一个Entry数组table中，数组的长度必须为2的倍数，通过key的hashcode与数组长度减1进行与运算来定位Entry在数组中的存储位置，这点和hashmap类似，但是当发生hash碰撞时hashmap的处理方法是放入链表或者树中(都在同一个hash桶中)，而ThreadLocalMap则是依次往后查找可以保存的地方，没有桶的概念(这点后面会结合代码详细讲)。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　既然ThreadLocalMap内部是一个数组，通过key的hashcode来定位到数组下标，这里我们不得不说一下key的hashcode的生成方式，非常精妙，因为key类型为ThreadLocal，所以其hashcode的生成方式也在ThreadLocal中：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; threadLocalHashCode =&lt;span&gt; nextHashCode();

  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; AtomicInteger nextHashCode = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AtomicInteger();

  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; HASH_INCREMENT = 0x61c88647&lt;span&gt;;

  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; nextHashCode() {
     &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; nextHashCode.getAndAdd(HASH_INCREMENT);
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　对于每个ThreadLocal对象，都有一个独自不变的hashcode，每新增一个ThreadLocal对象，会自动生成其自己的hashcode，其实就是让nextHashCode自增0x61c88647，目的是为了让生成的hashcode均匀的分布在2的幂次方上，而数组长度也是2的幂次方，这样就保证了要插入的元素可以均匀分布在数组中。&lt;/p&gt;
&lt;p&gt;　　虽然ThreadLocal使用了很牛逼的办法来生成hashcode，但是还是不可避免会产生hash碰撞，当出现碰撞时是如何来处理呢？我们接着看：&lt;/p&gt;
&lt;h2&gt;2. 获取元素&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　我们知道ThreadLocalMap是以Entry为基本单元保存数据的，而且是以key-value对的形式，我们先来看一下是如何通过key获取到Entry的：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; Entry getEntry(ThreadLocal&amp;lt;?&amp;gt;&lt;span&gt; key) {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i = key.threadLocalHashCode &amp;amp; (table.length - 1&lt;span&gt;);
    Entry e &lt;/span&gt;=&lt;span&gt; table[i];
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; e.get() ==&lt;span&gt; key)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; e;
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; getEntryAfterMiss(key, i, e);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　这个逻辑比较简单：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;首先通过key的hashcode获取数组下标(与运算)；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果下标对应处Entry不为空，且key与传入的key是指向同一个ThreadLocal对象则认为找到，直接返回Entry；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;否则执行getEntryAfterMiss；&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;br/&gt;* 有三种情况下会执行这个方法&lt;br/&gt;* 1. e为null；&lt;br/&gt;* 2. e!=null，e的key=null；&lt;br/&gt;* 3. e!=null，e的key!=null，e的key!=要找的key，即出现hash碰撞 &lt;br/&gt;**/&lt;br/&gt;private&lt;/span&gt; Entry getEntryAfterMiss(ThreadLocal&amp;lt;?&amp;gt; key, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; i, Entry e) {
    Entry[] tab &lt;/span&gt;=&lt;span&gt; table;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; len =&lt;span&gt; tab.length;

    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (e != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        ThreadLocal&lt;/span&gt;&amp;lt;?&amp;gt; k =&lt;span&gt; e.get();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (k ==&lt;span&gt; key)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; e;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (k == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            expungeStaleEntry(i);
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            i &lt;/span&gt;=&lt;span&gt; nextIndex(i, len);   // 出现碰撞，则依次往后找
        e &lt;/span&gt;=&lt;span&gt; tab[i];
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　&lt;span&gt;　这里的逻辑也比较清晰：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;获取内部保存Entry的数组及数组长度；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;获取传入Entry对应的key，如果和传入的key相等则直接返回key；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果Entry对应的key为空，则执行expungeStaleEntry，传入的参数为当前Entry所在数组下标i；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;否则将获取e在数组中后面那个元素并赋值给e，如果e不为空，则循环从第2步执行，否则直接退出循环；&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　对于key为空的Entry在ThreadLocal里面称为staleSlot，接下来看一下expungeStaleEntry：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; expungeStaleEntry(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; staleSlot) {
    Entry[] tab &lt;/span&gt;=&lt;span&gt; table;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; len =&lt;span&gt; tab.length;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 直接将下标为staleSlot处的元素擦除，value和Entry都要擦除&lt;/span&gt;
    tab[staleSlot].value = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    tab[staleSlot] &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    size&lt;/span&gt;--&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Rehash操作直到数组对应下标处元素为空的情况&lt;/span&gt;
&lt;span&gt;    Entry e;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (i =&lt;span&gt; nextIndex(staleSlot, len);
         (e &lt;/span&gt;= tab[i]) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
         i &lt;/span&gt;=&lt;span&gt; nextIndex(i, len)) {
        ThreadLocal&lt;/span&gt;&amp;lt;?&amp;gt; k =&lt;span&gt; e.get();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (k == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            e.value &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            tab[i] &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            size&lt;/span&gt;--&lt;span&gt;;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; h = k.threadLocalHashCode &amp;amp; (len - 1&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (h !=&lt;span&gt; i) {
                tab[i] &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;while&lt;/span&gt; (tab[h] != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                    h &lt;/span&gt;=&lt;span&gt; nextIndex(h, len);
                tab[h] &lt;/span&gt;=&lt;span&gt; e;
            }
        }
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; i;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　逻辑会稍微复杂一些，我们还是一步一步看：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;获取内部保存Entry的数组及数组长度；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;key为空代表这个Entry已经不需要了，直接置空，帮助gc，并将size减1；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;从传入的staleSlot下标后面的元素开始，依次遍历过去，循环执行下面的操作，直到遇到Entry为空停止；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果Entry为staleSlot(即key为null)，则清空；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;否则检查该Entry是否在它应该在的位置(根据hashcode计算出来的下标与其实际下标是否相等)；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果不在则将当前slot置为空，继续往后寻找，直到一个Entry为空的slot，将其放进去，重复下一次循环；&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;　&lt;span&gt;　expungeStaleEntry的作用是清除传入的staleSlot处的Entry，除此之外还会管两件&quot;闲事&quot;：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;从其后面开始清除遇到的staleSlot；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;rehash计算下标与实际下标不相符的Entry，&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;直到遇到Entry为空的slot则停止。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　从上面的分析我们得出，通过key获取元素时，如果从计算出来的下标能获取到符合要求的值则直接返回，否则会从该位置开始依次往后找；遇到Entry不为空但是Entry的key为空的会擦除该Entry并继续循环；遇到Entry不为空且key不为空(hash碰撞)则直接往后找；在整个找的过程中遇到Entry为null则停止查找，直接返回null。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;3. 设置元素 &lt;/h2&gt;
&lt;p&gt;　　接下来我们看看设置元素，也就是set方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; set(ThreadLocal&amp;lt;?&amp;gt;&lt;span&gt; key, Object value) {

    Entry[] tab &lt;/span&gt;=&lt;span&gt; table;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; len =&lt;span&gt; tab.length;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i = key.threadLocalHashCode &amp;amp; (len-1&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Entry e =&lt;span&gt; tab[i];
         e &lt;/span&gt;!= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
         e &lt;/span&gt;= tab[i =&lt;span&gt; nextIndex(i, len)]) {
        ThreadLocal&lt;/span&gt;&amp;lt;?&amp;gt; k =&lt;span&gt; e.get();
　　　　　// 找到则直接替换，然后直接返回
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (k ==&lt;span&gt; key) {
            e.value &lt;/span&gt;=&lt;span&gt; value;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
　　　　 // 发现staleSlot，则执行replaceStaleEntry，然后直接返回
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (k == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            replaceStaleEntry(key, value, i);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
    }
　　 // 如果没有找到，则new一个Entry插入数组中
    tab[i] &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Entry(key, value);
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; sz = ++&lt;span&gt;size;&lt;br/&gt;　　 // 插入新的Etry之后需要试探的去擦除一些过期的slot(key=null的Entry)，如果Entry数量大于阈值，则执行扩容
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!cleanSomeSlots(i, sz) &amp;amp;&amp;amp; sz &amp;gt;=&lt;span&gt; threshold)
        rehash();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这也是一个私有方法，这里看起来代码不多，但是里面涉及到的东西很多，逻辑也要比get方法复杂，但是没关系，我们层层递进，一一分解。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;获取Entry数组、数组长度以及通过要插入的key的hashcode计算出其在数组中的下标；&lt;/li&gt;
&lt;li&gt;拿到下标之后，对应下标处如果有Entry存在，则有三种情况：
&lt;ul&gt;&lt;li&gt;key不为空，且等于要插入的key，则直接将value替换成要执行的value，返回；&lt;/li&gt;
&lt;li&gt;key为空，则执行replaceStaleEntry中的逻辑，返回；&lt;/li&gt;
&lt;li&gt;如果key不为空但是又不等于要插入的key，则取下标i处后一个元素，循环执行上面的操作；&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;如果如上的循环结束，到这里代表没有找到要插入的key，且当前i处的Entry为空，则直接new一个Entry，将待插入的key和value放入其中，再放入数组；&lt;/li&gt;
&lt;li&gt;将代表数组中Entry数量的size加1；&lt;/li&gt;
&lt;li&gt;执行cleanSomeSlots中的逻辑，如果有删除一些Slot，并且size大于阈值，则需要执行rehash中的逻辑进行扩容，否则set执行结束；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　上面的步骤看完之后，我们来看看其中当key为空时需要执行的replaceStaleEntry的逻辑：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; replaceStaleEntry(ThreadLocal&amp;lt;?&amp;gt; key, Object value, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; staleSlot) {
    Entry[] tab &lt;/span&gt;=&lt;span&gt; table;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; len =&lt;span&gt; tab.length;
    Entry e;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 现在staleSlot处对应的Entry其key=null，往前查找看是否能不能找到一个stale的Entry&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; slotToExpunge =&lt;span&gt; staleSlot;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i =&lt;span&gt; prevIndex(staleSlot, len);
         (e &lt;/span&gt;= tab[i]) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
         i &lt;/span&gt;=&lt;span&gt; prevIndex(i, len))
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e.get() == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            slotToExpunge &lt;/span&gt;=&lt;span&gt; i;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Find either the key or trailing null slot of run, whichever
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; occurs first&lt;/span&gt;

    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i =&lt;span&gt; nextIndex(staleSlot, len);
         (e &lt;/span&gt;= tab[i]) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
         i &lt;/span&gt;=&lt;span&gt; nextIndex(i, len)) {
        ThreadLocal&lt;/span&gt;&amp;lt;?&amp;gt; k =&lt;span&gt; e.get();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 找到了直接替换，替换之后再尝试删除一些stale的Entry&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (k ==&lt;span&gt; key) {
            e.value &lt;/span&gt;=&lt;span&gt; value;

            tab[i] &lt;/span&gt;=&lt;span&gt; tab[staleSlot];
            tab[staleSlot] &lt;/span&gt;=&lt;span&gt; e;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Start expunge at preceding stale entry if it exists&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (slotToExpunge ==&lt;span&gt; staleSlot)
                slotToExpunge &lt;/span&gt;=&lt;span&gt; i;
            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果i处对应的Entry是stale，并且前面往前没有找到stale的Entry，则将i标识为待擦除的slot&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (k == &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; slotToExpunge ==&lt;span&gt; staleSlot)
            slotToExpunge &lt;/span&gt;=&lt;span&gt; i;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果没有找到传入key对应的entry，则new一个新Entry放在传入staleSlot下标处，现在staleSlot处的Entry不再是stale(过期的)了&lt;/span&gt;
    tab[staleSlot].value = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    tab[staleSlot] &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Entry(key, value);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果还发现有其他stale entries存在, 将其清除&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (slotToExpunge !=&lt;span&gt; staleSlot)
        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这个replaceStaleEntry的逻辑比较难理解，只要清楚它主要干了下面两件事：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;尝试查找和传入key对应的Entry，找到则替换，没找到则在传入的staleSlot处插入一个新的Entry；&lt;/li&gt;
&lt;li&gt;在上面的过程中，尽力地去擦除一些找到的staleSlot；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　以及插入一个新的Entry之后，试探性地去删除多余的staleSlot(注意，是&lt;strong&gt;试探&lt;/strong&gt;性的哦)，逻辑在cleanSomeSlots中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;br/&gt;* @param i 扫描起始下标，从第i+1处开始扫描&lt;br/&gt;* &lt;br/&gt;* @param n 扫描次数控制量，在往后面扫描的过程中，如果没有发现staleSlot，则最多扫描log2(n)个元素，否则在staleSlot之后再扫log2(table.length-1)个&lt;br/&gt;**/&lt;br/&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; cleanSomeSlots(&lt;span&gt;int&lt;/span&gt; i, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n) {    &lt;br/&gt;　　 // 标识是否有删除过staleSlot&lt;br/&gt;&lt;/span&gt;&lt;span&gt;　　 boolean&lt;/span&gt; removed = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    Entry[] tab &lt;/span&gt;=&lt;span&gt; table;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; len =&lt;span&gt; tab.length;
    &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt; {
        i &lt;/span&gt;=&lt;span&gt; nextIndex(i, len);
        Entry e &lt;/span&gt;=&lt;span&gt; tab[i];
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; e.get() == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            n &lt;/span&gt;=&lt;span&gt; len;
            removed &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            i &lt;/span&gt;=&lt;span&gt; expungeStaleEntry(i);
        }
    } &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; ( (n &amp;gt;&amp;gt;&amp;gt;= 1) != 0&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; removed;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　从i+1处开始，往后扫描，如果遇到staleSlot，则执行expungeStaleEntry，往后扫描log2(n)次结束循环，n为传入的参数，如果发现staleSlot，则将n更新为Entry数组长度len。&lt;/p&gt;
&lt;p&gt;　　这个设计非常巧妙，试探性的扫描一些单元看是否能发现staleSlot(不新鲜的entrys，也就是key=null)。当一个新元素添加进来或者一个staleSlot被清除的时候，会调用这个方法。该方法扫描元素的数量是对数级的，如果不扫描就不能及时清除key为null的entry(会浪费内存)，如果全数组扫描则会导致一次插入的时间复杂度为O(n)，采用这种试探性的扫描方式其实是一种在功能和性能之间的平衡，尽最大努力清理垃圾，又不导致过于消耗性能。&lt;/p&gt;

&lt;p&gt;　　如果插入了新Entry，且执行了cleanSomeSlots之后size的数量还是大于阈值的话，这时就需要rehash扩容了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; rehash() {
    expungeStaleEntries();

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Use lower threshold for doubling to avoid hysteresis&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (size &amp;gt;= threshold - threshold / 4&lt;span&gt;)
        resize();
}
&lt;br/&gt;// 扫描全表，清除所有staleSlot
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; expungeStaleEntries() {
    Entry[] tab &lt;/span&gt;=&lt;span&gt; table;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; len =&lt;span&gt; tab.length;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = 0; j &amp;lt; len; j++&lt;span&gt;) {
        Entry e &lt;/span&gt;=&lt;span&gt; tab[j];
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; e.get() == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            expungeStaleEntry(j);
    }
}&lt;br/&gt;// 将表容量扩大一倍
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; resize() {
    Entry[] oldTab &lt;/span&gt;=&lt;span&gt; table;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; oldLen =&lt;span&gt; oldTab.length;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; newLen = oldLen * 2&lt;span&gt;;
    Entry[] newTab &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Entry[newLen];
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; count = 0&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = 0; j &amp;lt; oldLen; ++&lt;span&gt;j) {
        Entry e &lt;/span&gt;=&lt;span&gt; oldTab[j];
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            ThreadLocal&lt;/span&gt;&amp;lt;?&amp;gt; k =&lt;span&gt; e.get();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (k == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                e.value &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Help the GC&lt;/span&gt;
            } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; h = k.threadLocalHashCode &amp;amp; (newLen - 1&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (newTab[h] != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                    h &lt;/span&gt;=&lt;span&gt; nextIndex(h, newLen);
                newTab[h] &lt;/span&gt;=&lt;span&gt; e;
                count&lt;/span&gt;++&lt;span&gt;;
            }
        }
    }

    setThreshold(newLen);
    size &lt;/span&gt;=&lt;span&gt; count;
    table &lt;/span&gt;=&lt;span&gt; newTab;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　首先扫描全表，清除所有staleSlot，如果这还不能减小size，则将table容量扩大一倍。扩容的逻辑比较简单，根据新数组容量来计算新的数组下标，如果存在hash冲突就往后找，直到Entry为空则把元素放进去。&lt;/p&gt;
&lt;p&gt;　　到这里我们学习了ThreadLocal的基本原理、核心数据结构、最常用的get和set方法，是不是对ThreadLocal有了更深入的了解呢？如果有，那非常高兴我的文章能给你带来一丁点价值^_^&lt;/p&gt;
&lt;h2&gt;4. 内存泄漏&lt;/h2&gt;
&lt;p&gt;　　前面有讲到，ThreadLocalMap中的Entry其类型是属于弱引用(继承了WeakReference)，被弱引用指向的对象，在下一次GC时是会被回收的，除非这个对象还有强引用指向它(对Java中强、软、弱、虚引用不清楚的同学可以详细了解下)，之所以这样设计，我的理解是Entry是存在ThreadLocalMap中，而这个map又是保存在线程thread中的，用户是不能直接获取到的，也是不能直接操作的，也就会影响到垃圾回收。为了避免因为ThreadLocalMap存储了ThreadLocal对象而影响到ThreadLocal对象的垃圾回收，JDK的设计者把主动权完全交给调用方，一旦调用方不想使用，只需设置ThreadLocal对象为null，内存就可以被回收掉了，这也是弱引用的一个主要使用场景。&lt;/p&gt;
&lt;p&gt;　　另一方面，在set和getEntry的过程中会频繁的去清理stale entry，以及时释放空余位置，这样就可以及时清除value，因为value是我们要保存到ThreadLocal中的值，而这是强引用，即便是key被回收了，value依然不会被回收。&lt;/p&gt;
&lt;p&gt;　　虽然ThreadLocal中做了种种设计来防止内存泄漏，但是如果使用不当还是会导致内存泄漏，我这里借用一个网上的例子，一起来感受下：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ThreadLocalLeakDemo {
  
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {

      @Override
      &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = 0; i&amp;lt; 1000 ;i++&lt;span&gt;) {
          TestClass t &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TestClass(i);
          t.printId();&lt;br/&gt;　　　　　　// 行1，注释掉这一行时不会导致内存溢出
          t &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;　　　　　　// 行2，注释掉这一行时会导致内存溢出
          t.threadLocal.remove();
        }
      }
    }).start();;
  }
  
  &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestClass{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; id;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] arr;&lt;br/&gt;　　 // 注意，这是一个普通成员哦
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; ThreadLocal&amp;lt;TestClass&amp;gt;&lt;span&gt; threadLocal;
    TestClass(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id){
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.id =&lt;span&gt; id;
      arr &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[1000000&lt;span&gt;];
      threadLocal &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadLocal();
      threadLocal.set(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span readability=&quot;2&quot;&gt; printId() {
      System.out.println(threadLocal.get().id);
    }
  }
}&lt;p&gt;/**&lt;br/&gt;* 注释行2，放开行1时，会导致内存溢出，结果如下：&lt;br/&gt;**/&lt;br/&gt;&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;
...&lt;br/&gt;449&lt;br/&gt;450&lt;br/&gt;451&lt;br/&gt;Exception in thread &quot;Thread-0&quot; java.lang.OutOfMemoryError: Java heap space&lt;br/&gt;at testDemos.annotationDemos.ThreadLocalLeakDemo$TestClass.(ThreadLocalLeakDemo.java:28)&lt;br/&gt;at testDemos.annotationDemos.ThreadLocalLeakDemo$1.run(ThreadLocalLeakDemo.java:13)&lt;br/&gt;at java.lang.Thread.run(Unknown Source)&lt;br/&gt;...
&lt;pre&gt;
&lt;span&gt;/**&lt;br/&gt;* 注释行1，放开行2时，不会导致内存泄漏，结果如下：&lt;br/&gt;**/&lt;/span&gt;
&lt;/pre&gt;
...&lt;br/&gt;997&lt;br/&gt;998&lt;br/&gt;999&lt;/div&gt;
&lt;p&gt;　　上面其实就是改了一行代码，就导致内存溢出，增加的那一步操作就是调用了ThreadLocal的remove，那我们就来看看remove的逻辑：&lt;/p&gt;
&lt;p&gt;　　移除元素的逻辑很简单，根据传入的key定位到数组下标i，从这个下标开始往后循环，直到遇到Entry为空时停止循环。如果找到key对应的entry，则调用Entry的clear方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; remove(ThreadLocal&amp;lt;?&amp;gt;&lt;span&gt; key) {
    Entry[] tab &lt;/span&gt;=&lt;span&gt; table;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; len =&lt;span&gt; tab.length;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i = key.threadLocalHashCode &amp;amp; (len-1&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Entry e =&lt;span&gt; tab[i];
         e &lt;/span&gt;!= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
         e &lt;/span&gt;= tab[i =&lt;span&gt; nextIndex(i, len)]) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e.get() ==&lt;span&gt; key) {
            e.clear();
            expungeStaleEntry(i);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　结合上面的例子和源码，我们解释一下为什么没有调用remove方法会导致内存溢出。如上，在不调用remove时，每一次循环都会插入一个新的Entry对象到ThreadLocalMap中，这个Entry是指向一个新的ThreadLocal对象，对于这个ThreadLocal对象存在两个引用：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Entry--&amp;gt;ThreadLocal，这是弱引用；&lt;/li&gt;
&lt;li&gt;Entry--&amp;gt;value(TestClass)--&amp;gt;ThreadLocal，这是强引用；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　由于强引用一直存在，而t=null并不能让value不可达，因为value是保存在线程本地内存中的，所以没法回收这个新的ThreadLocal对象，导致一直堆积，最终报OOM&lt;/p&gt;
&lt;p&gt;　　而如果调用remove的话，则会直接将对应Entry以及其保存的value清空，这样就不会内存泄漏了。&lt;/p&gt;
&lt;p&gt;　　其实上面的例子是使用不当导致的，如果将ThreadLocal成员变量置为static，也不会出现这个问题，因为即便有1000次循环，但是都是用的同一个ThreadLocal，在线程本地始终只有一份，用private static来修饰ThreadLocal也是一个官方推荐的惯用法。&lt;/p&gt;
&lt;h2&gt;5. 总结&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;ThreadLocal内部数据结构：Entry数组&lt;/li&gt;
&lt;li&gt;Entry封装要保存的数据，以key-value的形式，key的类型为指向ThreadLocal的WeakReference，value为要保存的对象&lt;/li&gt;
&lt;li&gt;通过key的hashcode来初步定位其在数组中的位置，如果没有则往后依次查找，如果找到则返回(getEntry)或替换(set)，直到碰到为空的Entry为止，这就是解决hash碰撞所采用的方法；&lt;/li&gt;
&lt;li&gt;当出现hash冲突时，ThreadLocalMap采用的办法就是继续往后面找，这是线性操作所以会比较低效。但是ThreadLocal采用的散列算法效果很好，冲突的概率非常小，再加上在set和getEntry的过程中会频繁的去清理stale entry(expungeStaleEntry、replaceStaleEntry、cleanSomeSlots中都有涉及到)，是为了能够及时释放空余位置，进一步降低这种低效带来的影响。&lt;/li&gt;
&lt;li&gt;由于Entry是指向ThreadLocal对象的弱引用，所以当ThreadLocal对象不存在强引用的时候，是可以被回收的，回收之后Entry就指向空了(get获取的key为null)，但是这时候Entry中的value仍然不为空，可以可能导致内存泄漏，有两种方式可以清除：&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;　　在ThreadLocal的get、set方法中会频繁的去清除staleSlot&lt;/li&gt;
&lt;li&gt;　　手动调用TreadLocal的remove方法来清除&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　以上为个人总结，如有不对，烦请指正。&lt;/p&gt;
</description>
<pubDate>Mon, 22 Apr 2019 11:25:00 +0000</pubDate>
<dc:creator>木瓜芒果</dc:creator>
<og:description>ThreadLocal原理深入学习</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/volcano-liu/p/10712524.html</dc:identifier>
</item>
</channel>
</rss>