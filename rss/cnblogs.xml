<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>基于WebSocket实现网页版聊天室 - 陈本布衣</title>
<link>http://www.cnblogs.com/chenbenbuyi/p/10779999.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenbenbuyi/p/10779999.html</guid>
<description>&lt;p&gt;　　WebSocket ，HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议，其使用简单，应用场景也广泛，不同开发语言都用种类繁多的实现，仅Java体系中，Tomcat,Jetty，Spring等都提供了对WS的API支持。本篇不做理论探究，仅自娱自乐，简单实现网页版的聊天室功能，在实际开发场景中变通使用即可。废话不叽歪，直接撸出来——&lt;/p&gt;
&lt;h3&gt;1  简单页面&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;HanppyRoom&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt;&lt;span&gt; url &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ws://&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt; window.location.host &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/page_room/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; ws &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加入聊天室&lt;/span&gt;
        &lt;span&gt;function&lt;/span&gt;&lt;span&gt; joinRoom() {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ws) {
                alert(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;你已经在聊天室，不能再加入&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; username &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; document.getElementById(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).value;
            ws &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; WebSocket(url &lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt; username);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;与服务端建立连接触发&lt;/span&gt;
&lt;span&gt;            ws.onopen &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
              console.log(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;与服务器成功建立连接&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            };
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;服务端推送消息触发&lt;/span&gt;
&lt;span&gt;            ws.onmessage &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (ev) {
                talking(ev.data);
            };

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;发生错误触发&lt;/span&gt;
&lt;span&gt;            ws.onerror &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
                console.log(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;连接错误&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            };
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;正常关闭触发&lt;/span&gt;
&lt;span&gt;            ws.onclose &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
                console.log(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;连接关闭&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            };
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;退出聊天室&lt;/span&gt;
        &lt;span&gt;function&lt;/span&gt;&lt;span&gt; exitRoom() {
            closeWebSocket();
        }

        &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; sendMsg() {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;!&lt;/span&gt;&lt;span&gt;ws){
                alert(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;你已掉线，请重新加入&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;消息发送&lt;/span&gt;
&lt;span&gt;            ws.send(document.getElementById(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sendMsg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).value);
            document.getElementById(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sendMsg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).value &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;


        }

        &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; closeWebSocket() {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(ws){
                ws.close();
                ws &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            }
        }

        &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; talking(content) {
            document.getElementById(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;content&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).append(content &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;text-align: center;background-color: rgba(129,86,255,0.35);margin:0 auto;border:1px solid #000;width:600px;height:650px&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;欢迎使用&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;strong&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;陈本布衣&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;strong&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;牌极简聊天室：&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;textarea &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;content&quot;&lt;/span&gt;&lt;span&gt; cols&lt;/span&gt;&lt;span&gt;=&quot;60&quot;&lt;/span&gt;&lt;span&gt; rows&lt;/span&gt;&lt;span&gt;=&quot;30&quot;&lt;/span&gt;&lt;span&gt; readonly&lt;/span&gt;&lt;span&gt;=&quot;readonly&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;textarea&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;sendMsg&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;button&quot;&lt;/span&gt;&lt;span&gt; onclick&lt;/span&gt;&lt;span&gt;=&quot;sendMsg()&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;发送消息&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;
    用户：&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;user&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;onclick&lt;/span&gt;&lt;span&gt;=&quot;joinRoom()&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;加入群聊&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;onclick&lt;/span&gt;&lt;span&gt;=&quot;exitRoom()&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;退出群聊&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2   后端实现&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * @ServerEndpoin 注解声明该类为 WebSocket 的服务端端点
 * value 值为监听客户端访问的 URL
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@ServerEndpoint(value &lt;/span&gt;= &quot;/page_room/{username}&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WsByTomcat {

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里只是简单测试用，真正的场景请考虑线程安全的容器或其它并发解决方案&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; List&amp;lt;Session&amp;gt; sessions = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; session  与客户端的会话对象【可选】
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; username 路径参数值 【可选】
     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; IOException
     * @OnOpen 标注此方法在 ws 连接建立时调用，可用来处理一些准备性工作 可选参数
     * EndpointConfig（端点配置信息对象） Session 连接会话对象
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @OnOpen
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; OnOpen(Session session, @PathParam(&quot;username&quot;) String username) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
        sessions.add(session);
        sendTextMsg(&lt;/span&gt;&quot;好友 [&quot; + username + &quot;] 加入群聊&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; msg      接受客户端消息
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; username RESTful 路径方式获取用户名
     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; IOException
     * @OnMessage 在收到客户端消息调用 消息形式不限于文本消息，还可以是二进制消息(byte[]/ByteBuffer等)，ping/pong 消息
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @OnMessage
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; OnMsg(String msg, @PathParam(&quot;username&quot;) String username) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
        sendTextMsg(username &lt;/span&gt;+ &quot;：\r\n&quot; +&lt;span&gt; msg);
    }


    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * @OnClose 连接关闭调用
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @OnClose
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; OnClose(Session session, @PathParam(&quot;username&quot;) String username) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
        sessions.remove(session);
        sendTextMsg(&lt;/span&gt;&quot;好友 [&quot;+username + &quot;] 退出群聊&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; e 异常参数
     * @OnError 连接出现错误调用
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @OnError
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnError(Throwable e) {
        e.printStackTrace();
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; sendTextMsg(String msg) {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Session session : sessions) {
            session.getAsyncRemote().sendText(msg);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Tue, 30 Apr 2019 15:52:00 +0000</pubDate>
<dc:creator>陈本布衣</dc:creator>
<og:description>WebSocket ，HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议，其使用简单，应用场景也广泛，不同开发语言都用种类繁多的实现，仅Java体系中，Tomcat,Jetty，Sp</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenbenbuyi/p/10779999.html</dc:identifier>
</item>
<item>
<title>Pytest UI自动化测试实战实例 - linux超</title>
<link>http://www.cnblogs.com/linuxchao/p/linuxchao-pytest-Actual.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/linuxchao/p/linuxchao-pytest-Actual.html</guid>
<description>&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;------------------------------------
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;@Time : 2019/4/20 8:45
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;@Auth : linux超
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;@File : BasePage.py
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; &lt;span&gt;@IDE  : PyCharm
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;@Motto: Real warriors,dare to face the bleak warning,dare to face the incisive error!
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; &lt;span&gt;------------------------------------
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 10&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; selenium.webdriver.support &lt;span&gt;import&lt;/span&gt;&lt;span&gt; expected_conditions as EC
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; selenium.webdriver.support.wait &lt;span&gt;import&lt;/span&gt;&lt;span&gt; WebDriverWait as wd
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; selenium.webdriver.common.by &lt;span&gt;import&lt;/span&gt;&lt;span&gt; By
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; selenium.common.exceptions &lt;span&gt;import&lt;/span&gt;&lt;span&gt; NoSuchWindowException, TimeoutException, \
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt; &lt;span&gt;    NoAlertPresentException, NoSuchFrameException
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; selenium &lt;span&gt;import&lt;/span&gt;&lt;span&gt; webdriver
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt; 
&lt;span&gt; 18&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; util.clipboard &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ClipBoard
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; util.keyboard &lt;span&gt;import&lt;/span&gt;&lt;span&gt; KeyBoard
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; util.parseConFile &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ParseConFile
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; util.parseExcelFile &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ParseExcel
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt; 
&lt;span&gt; 23&lt;/span&gt; 
&lt;span&gt; 24&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BasePage(object):
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 26&lt;/span&gt; &lt;span&gt;    结合显示等待封装一些selenium 内置方法
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 28&lt;/span&gt;     cf =&lt;span&gt; ParseConFile()
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt;     excel =&lt;span&gt; ParseExcel()
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt; 
&lt;span&gt; 31&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;(self, driver, outTime=30&lt;span&gt;):
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt;         self.byDic =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: By.ID,
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: By.NAME,
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;class_name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: By.CLASS_NAME,
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;xpath&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: By.XPATH,
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;link_text&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: By.LINK_TEXT
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt;         self.driver =&lt;span&gt; driver
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt;         self.outTime =&lt;span&gt; outTime
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt; 
&lt;span&gt; 42&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; findElement(self, by, locator):
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 44&lt;/span&gt; &lt;span&gt;        find alone element
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt; &lt;span&gt;        :param by: eg: id, name, xpath, css.....
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt; &lt;span&gt;        :param locator: id, name, xpath for str
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt; &lt;span&gt;        :return: element object
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 49&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;[Info:Starting find the element &quot;{}&quot; by &quot;{}&quot;!]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(locator, by))
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt;             element = wd(self.driver, self.outTime).until(&lt;span&gt;lambda&lt;/span&gt;&lt;span&gt; x : x.find_element(by, locator))
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt;         &lt;span&gt;except&lt;/span&gt;&lt;span&gt; TimeoutException as t:
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;error: found &quot;{}&quot; timeout!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(locator), t)
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt;         &lt;span&gt;except&lt;/span&gt;&lt;span&gt; NoSuchWindowException as e:
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;error: no such &quot;{}&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(locator), e)
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt;         &lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception as e:
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt;             &lt;span&gt;raise&lt;/span&gt;&lt;span&gt; e
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; print('[Info:Had found the element &quot;{}&quot; by &quot;{}&quot;!]'.format(locator, by))&lt;/span&gt;
&lt;span&gt; 60&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; element
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt; 
&lt;span&gt; 62&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; findElements(self, by, locator):
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 64&lt;/span&gt; &lt;span&gt;        find group elements
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt; &lt;span&gt;        :param by: eg: id, name, xpath, css.....
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt; &lt;span&gt;        :param locator: eg: id, name, xpath for str
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt; &lt;span&gt;        :return: elements object
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 69&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;[Info:start find the elements &quot;{}&quot; by &quot;{}&quot;!]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(locator, by))
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt;             elements = wd(self.driver, self.outTime).until(&lt;span&gt;lambda&lt;/span&gt;&lt;span&gt; x : x.find_element(by, locator))
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt;         &lt;span&gt;except&lt;/span&gt;&lt;span&gt; TimeoutException as t:
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(t)
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt;         &lt;span&gt;except&lt;/span&gt;&lt;span&gt; NoSuchWindowException as e:
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(e)
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;         &lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception as e:
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt;             &lt;span&gt;raise&lt;/span&gt;&lt;span&gt; e
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; print('[Info:Had found the elements &quot;{}&quot; by &quot;{}&quot;!]'.format(locator, by))&lt;/span&gt;
&lt;span&gt; 80&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; elements
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt; 
&lt;span&gt; 82&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; isElementExsit(self, by, locator):
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 84&lt;/span&gt; &lt;span&gt;        assert element if exist
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt; &lt;span&gt;        :param by: eg: id, name, xpath, css.....
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt; &lt;span&gt;        :param locator: eg: id, name, xpath for str
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt; &lt;span&gt;        :return: if element return True else return false
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 89&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; by.lower() &lt;span&gt;in&lt;/span&gt;&lt;span&gt; self.byDic:
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt; &lt;span&gt;                wd(self.driver, self.outTime).\
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt; &lt;span&gt;                    until(EC.visibility_of_element_located((self.byDic[by], locator)))
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt;             &lt;span&gt;except&lt;/span&gt;&lt;span&gt; TimeoutException:
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt;                 &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Error: element &quot;{}&quot; time out!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(locator))
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; False
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt;             &lt;span&gt;except&lt;/span&gt;&lt;span&gt; NoSuchWindowException:
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt;                 &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Error: element &quot;{}&quot; not exsit!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(locator))
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; False
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; True
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;the &quot;{}&quot; error!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(by))
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt; 
&lt;span&gt;103&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; isClick(self, by, locator):
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;判断是否可点击,返回元素对象&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;105&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; by.lower() &lt;span&gt;in&lt;/span&gt;&lt;span&gt; self.byDic:
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt;                 element =&lt;span&gt; wd(self.driver, self.outTime).\
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt; &lt;span&gt;                    until(EC.element_to_be_clickable((self.byDic[by], locator)))
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt;             &lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception:
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; False
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; element
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;the &quot;{}&quot; error!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(by))
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt; 
&lt;span&gt;115&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; isAlertAndSwitchToIt(self):
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;117&lt;/span&gt; &lt;span&gt;        assert alert if exsit
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt; &lt;span&gt;        :return: alert obj
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;120&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt;             re =&lt;span&gt; wd(self.driver, self.outTime).until(EC.alert_is_present())
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt;         &lt;span&gt;except&lt;/span&gt;&lt;span&gt; NoAlertPresentException:
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; False
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt;         &lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception:
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; False
&lt;/span&gt;&lt;span&gt;126&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; re
&lt;/span&gt;&lt;span&gt;127&lt;/span&gt; 
&lt;span&gt;128&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; switchToFrame(self, by, locator):
&lt;/span&gt;&lt;span&gt;129&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;判断frame是否存在，存在就跳到frame&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;130&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;info:switching to iframe &quot;{}&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(locator))
&lt;/span&gt;&lt;span&gt;131&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; by.lower() &lt;span&gt;in&lt;/span&gt;&lt;span&gt; self.byDic:
&lt;/span&gt;&lt;span&gt;132&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt; &lt;span&gt;                wd(self.driver, self.outTime).\
&lt;/span&gt;&lt;span&gt;134&lt;/span&gt; &lt;span&gt;                    until(EC.frame_to_be_available_and_switch_to_it((self.byDic[by], locator)))
&lt;/span&gt;&lt;span&gt;135&lt;/span&gt;             &lt;span&gt;except&lt;/span&gt;&lt;span&gt; TimeoutException as t:
&lt;/span&gt;&lt;span&gt;136&lt;/span&gt;                 &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;error: found &quot;{}&quot; timeout！&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(locator), t)
&lt;/span&gt;&lt;span&gt;137&lt;/span&gt;             &lt;span&gt;except&lt;/span&gt;&lt;span&gt; NoSuchFrameException as e:
&lt;/span&gt;&lt;span&gt;138&lt;/span&gt;                 &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;error: no such &quot;{}&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(locator), e)
&lt;/span&gt;&lt;span&gt;139&lt;/span&gt;             &lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception as e:
&lt;/span&gt;&lt;span&gt;140&lt;/span&gt;                 &lt;span&gt;raise&lt;/span&gt;&lt;span&gt; e
&lt;/span&gt;&lt;span&gt;141&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;142&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;the &quot;{}&quot; error!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(by))
&lt;/span&gt;&lt;span&gt;143&lt;/span&gt; 
&lt;span&gt;144&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; switchToDefaultFrame(self):
&lt;/span&gt;&lt;span&gt;145&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;返回默认的frame&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;146&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;info:switch back to default iframe&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;147&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;148&lt;/span&gt; &lt;span&gt;            self.driver.switch_to.default_content()
&lt;/span&gt;&lt;span&gt;149&lt;/span&gt;         &lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception as e:
&lt;/span&gt;&lt;span&gt;150&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(e)
&lt;/span&gt;&lt;span&gt;151&lt;/span&gt; 
&lt;span&gt;152&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; getAlertText(self):
&lt;/span&gt;&lt;span&gt;153&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;获取alert的提示信息&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;154&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; self.isAlertAndSwitchToIt():
&lt;/span&gt;&lt;span&gt;155&lt;/span&gt;             alert =&lt;span&gt; self.isAlertAndSwitchToIt()
&lt;/span&gt;&lt;span&gt;156&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; alert.text
&lt;/span&gt;&lt;span&gt;157&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;158&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; None
&lt;/span&gt;&lt;span&gt;159&lt;/span&gt; 
&lt;span&gt;160&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; getElementText(self, by, locator, name=&lt;span&gt;None):
&lt;/span&gt;&lt;span&gt;161&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;获取某一个元素的text信息&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;162&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;163&lt;/span&gt;             element =&lt;span&gt; self.findElement(by, locator)
&lt;/span&gt;&lt;span&gt;164&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; name:
&lt;/span&gt;&lt;span&gt;165&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; element.get_attribute(name)
&lt;/span&gt;&lt;span&gt;166&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;167&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; element.text
&lt;/span&gt;&lt;span&gt;168&lt;/span&gt;         &lt;span&gt;except&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;169&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;get &quot;{}&quot; text failed return None&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(locator))
&lt;/span&gt;&lt;span&gt;170&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; None
&lt;/span&gt;&lt;span&gt;171&lt;/span&gt; 
&lt;span&gt;172&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; loadUrl(self, url):
&lt;/span&gt;&lt;span&gt;173&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;加载url&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;174&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;info: string upload url &quot;{}&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(url))
&lt;/span&gt;&lt;span&gt;175&lt;/span&gt; &lt;span&gt;        self.driver.get(url)
&lt;/span&gt;&lt;span&gt;176&lt;/span&gt; 
&lt;span&gt;177&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; getSource(self):
&lt;/span&gt;&lt;span&gt;178&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;获取页面源码&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;179&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; self.driver.page_source
&lt;/span&gt;&lt;span&gt;180&lt;/span&gt; 
&lt;span&gt;181&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; sendKeys(self, by, locator, value=&lt;span&gt;''&lt;/span&gt;&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;182&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;写数据&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;183&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;info:input &quot;{}&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(value))
&lt;/span&gt;&lt;span&gt;184&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;185&lt;/span&gt;             element =&lt;span&gt; self.findElement(by, locator)
&lt;/span&gt;&lt;span&gt;186&lt;/span&gt; &lt;span&gt;            element.send_keys(value)
&lt;/span&gt;&lt;span&gt;187&lt;/span&gt;         &lt;span&gt;except&lt;/span&gt;&lt;span&gt; AttributeError as e:
&lt;/span&gt;&lt;span&gt;188&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(e)
&lt;/span&gt;&lt;span&gt;189&lt;/span&gt; 
&lt;span&gt;190&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; clear(self, by, locator):
&lt;/span&gt;&lt;span&gt;191&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;清理数据&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;192&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;info:clearing value&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;193&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;194&lt;/span&gt;             element =&lt;span&gt; self.findElement(by, locator)
&lt;/span&gt;&lt;span&gt;195&lt;/span&gt; &lt;span&gt;            element.clear()
&lt;/span&gt;&lt;span&gt;196&lt;/span&gt;         &lt;span&gt;except&lt;/span&gt;&lt;span&gt; AttributeError as e:
&lt;/span&gt;&lt;span&gt;197&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(e)
&lt;/span&gt;&lt;span&gt;198&lt;/span&gt; 
&lt;span&gt;199&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; click(self, by, locator):
&lt;/span&gt;&lt;span&gt;200&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;点击某个元素&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;201&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;info:click &quot;{}&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(locator))
&lt;/span&gt;&lt;span&gt;202&lt;/span&gt;         element =&lt;span&gt; self.isClick(by, locator)
&lt;/span&gt;&lt;span&gt;203&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; element:
&lt;/span&gt;&lt;span&gt;204&lt;/span&gt; &lt;span&gt;            element.click()
&lt;/span&gt;&lt;span&gt;205&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;206&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;the &quot;{}&quot; unclickable!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;207&lt;/span&gt; 
&lt;span&gt;208&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; sleep(self, num=&lt;span&gt;0):
&lt;/span&gt;&lt;span&gt;209&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;强制等待&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;210&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;info:sleep &quot;{}&quot; minutes&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(num))
&lt;/span&gt;&lt;span&gt;211&lt;/span&gt; &lt;span&gt;        time.sleep(num)
&lt;/span&gt;&lt;span&gt;212&lt;/span&gt; 
&lt;span&gt;213&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; ctrlV(self, value):
&lt;/span&gt;&lt;span&gt;214&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;ctrl + V 粘贴&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;215&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;info:pasting &quot;{}&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(value))
&lt;/span&gt;&lt;span&gt;216&lt;/span&gt; &lt;span&gt;        ClipBoard.setText(value)
&lt;/span&gt;&lt;span&gt;217&lt;/span&gt;         self.sleep(3&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;218&lt;/span&gt;         KeyBoard.twoKeys(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ctrl&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;v&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;219&lt;/span&gt; 
&lt;span&gt;220&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; enterKey(self):
&lt;/span&gt;&lt;span&gt;221&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;enter 回车键&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;222&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;info:keydown enter&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;223&lt;/span&gt;         KeyBoard.oneKey(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;enter&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;224&lt;/span&gt; 
&lt;span&gt;225&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; waitElementtobelocated(self, by, locator):
&lt;/span&gt;&lt;span&gt;226&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;显示等待某个元素出现，且可见&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;227&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;info:waiting &quot;{}&quot; to be located&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(locator))
&lt;/span&gt;&lt;span&gt;228&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;229&lt;/span&gt; &lt;span&gt;            wd(self.driver, self.outTime).until(EC.visibility_of_element_located((self.byDic[by], locator)))
&lt;/span&gt;&lt;span&gt;230&lt;/span&gt;         &lt;span&gt;except&lt;/span&gt;&lt;span&gt; TimeoutException as t:
&lt;/span&gt;&lt;span&gt;231&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;error: found &quot;{}&quot; timeout！&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(locator), t)
&lt;/span&gt;&lt;span&gt;232&lt;/span&gt;         &lt;span&gt;except&lt;/span&gt;&lt;span&gt; NoSuchWindowException as e:
&lt;/span&gt;&lt;span&gt;233&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;error: no such &quot;{}&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(locator), e)
&lt;/span&gt;&lt;span&gt;234&lt;/span&gt;         &lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception as e:
&lt;/span&gt;&lt;span&gt;235&lt;/span&gt;             &lt;span&gt;raise&lt;/span&gt;&lt;span&gt; e
&lt;/span&gt;&lt;span&gt;236&lt;/span&gt; 
&lt;span&gt;237&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; assertValueInSource(self, value):
&lt;/span&gt;&lt;span&gt;238&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;断言某个关键字是否存在页面源码中&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;239&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;info:assert &quot;{}&quot; in page source&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(value))
&lt;/span&gt;&lt;span&gt;240&lt;/span&gt;         source =&lt;span&gt; self.getSource()
&lt;/span&gt;&lt;span&gt;241&lt;/span&gt;         &lt;span&gt;assert&lt;/span&gt; value &lt;span&gt;in&lt;/span&gt; source, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;关键字&quot;{}&quot;不存在源码中!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(value)
&lt;/span&gt;&lt;span&gt;242&lt;/span&gt; 
&lt;span&gt;243&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; assertStringContainsValue(self, String, value):
&lt;/span&gt;&lt;span&gt;244&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;断言某段字符串包含另一个字符串&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;245&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;info:assert &quot;{}&quot; contains &quot;{}&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(String, value))
&lt;/span&gt;&lt;span&gt;246&lt;/span&gt;         &lt;span&gt;assert&lt;/span&gt; value &lt;span&gt;in&lt;/span&gt; String, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;{}&quot;不包含&quot;{}&quot;!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(String, value)
&lt;/span&gt;&lt;span&gt;247&lt;/span&gt; 
&lt;span&gt;248&lt;/span&gt; 
&lt;span&gt;249&lt;/span&gt; &lt;span&gt;    @staticmethod
&lt;/span&gt;&lt;span&gt;250&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; getSheet(sheetName):
&lt;/span&gt;&lt;span&gt;251&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;获取某个sheet页的对象&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;252&lt;/span&gt;         sheet =&lt;span&gt; BasePage.excel.getSheetByName(sheetName)
&lt;/span&gt;&lt;span&gt;253&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; sheet
&lt;/span&gt;&lt;span&gt;254&lt;/span&gt; 
&lt;span&gt;255&lt;/span&gt; 
&lt;span&gt;256&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;257&lt;/span&gt;     driver =&lt;span&gt; webdriver.Firefox()
&lt;/span&gt;&lt;span&gt;258&lt;/span&gt;     frame = (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;xpath&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;//div[@id=&quot;loginDiv&quot;]/ifram&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;259&lt;/span&gt;     wait =&lt;span&gt; BasePage(driver)
&lt;/span&gt;&lt;span&gt;260&lt;/span&gt;     driver.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://mail.126.com/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;261&lt;/span&gt;     wait.switchToFrame(*&lt;span&gt;frame)
&lt;/span&gt;&lt;span&gt;262&lt;/span&gt;     username = wait.findElement(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;xpath&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;//input[@name=&quot;email&quot;]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;263&lt;/span&gt;     username.send_keys(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;账号&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;264&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; wait.isElementExsit(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;xpath&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;//input[@name=&quot;password&quot;]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;265&lt;/span&gt;         wait.findElement(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;xpath&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;//input[@name=&quot;password&quot;]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).send_keys(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;xiaochao11520&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;266&lt;/span&gt;     wait.click(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;xpath&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;//a[@id=&quot;dologin&quot;]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;</description>
<pubDate>Tue, 30 Apr 2019 15:42:00 +0000</pubDate>
<dc:creator>linux超</dc:creator>
<og:description>前言 明天就放假了，4天小长假，是不是很开心！也许很多人要回老家帮家里种地，干农活。其实能陪陪家里人，帮忙干点农活还是挺开心的，希望大家有个愉快的假期！废话不多说哈，今天再来说说pytest吧，经过几</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/linuxchao/p/linuxchao-pytest-Actual.html</dc:identifier>
</item>
<item>
<title>MySQL 中的日期时间类型 - 刘哇勇</title>
<link>http://www.cnblogs.com/Wayou/p/mysql_data_type_datetime.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Wayou/p/mysql_data_type_datetime.html</guid>
<description>&lt;p&gt;日期时间类型中包含以下几种数据类型：&lt;/p&gt;
&lt;p&gt;各类型都有具体的取值范围，超出或非法的其他值时，MySQL 会回退到 0。TIMESTAMP 类型是个例外，给它设置一个超出范围的值时，将保存上该类型允许的最大值。&lt;/p&gt;
&lt;p&gt;MySQL 按标准格式 &lt;code&gt;YYYY-MM-DD hh:mm:ss[.fraction]&lt;/code&gt; 输出日期时间，但设置或进行日期时间相关的比较时却支持灵活的多种格式，会自动解析。具体支持的输入格式可参见 &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/date-and-time-literals.html&quot; rel=&quot;nofollow&quot;&gt;Section 9.1.3, “Date and Time Literals”&lt;/a&gt;。其中 &lt;code&gt;fraction&lt;/code&gt; 部分为秒后面的小数部分，取值范围为 0~6 位。&lt;/p&gt;
&lt;p&gt;虽然 MySQL 支持多种格式进行日期时间的设置，但日期部分要求必须是 年-月-日 的形式才能正确解析。比如 &lt;code&gt;98-09-04&lt;/code&gt; 是按年月日顺序解析的，而不是英文里常用的月日年，或者日月年。&lt;/p&gt;
&lt;p&gt;年在只给了两位数的情况下，MySQL 尝试使用以下规则来补全：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;给定的两位数为 70~99 时解析成 1970 ~ 1999。&lt;/li&gt;
&lt;li&gt;给定为 00 ~ 69 时解析成 2000 ~ 2069。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以，为了避免不可预测的结果，使用时还是指定全一些。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在需要使用数字的语境下，MySQL 会将日期时间自动转成数字。同理，在需要日期时间的相关操作语境下，会尝试将数字解析成日期时间。&lt;/li&gt;
&lt;li&gt;通过设置 MySQL 相关参数，日期类型可保存原本非法的值，比如开启 &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/sql-mode.html#sqlmode_allow_invalid_dates&quot; rel=&quot;nofollow&quot;&gt;ALLOW_INVALID_DATES&lt;/a&gt; 设置项时，可设置日期类型保存一个 &lt;code&gt;2009-11-31&lt;/code&gt; 值，但正常情况下我们知道 11 月哪来什么 31 号。此时 MySQL 仅仅只是不检查月分与日期的关联性，但月分的取值范围 1&lt;del&gt;12 及日期的取值范围 1&lt;/del&gt;31 还是要单独各自做校验的。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;17&quot;&gt;
&lt;pre&gt;
mysql&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; INSERT INTO todo (title,created_on) VALUES (&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;blah&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;,&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;2019-09-31&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;)&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt;
ERROR 1292 (22007): Incorrect date value: &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;2019-09-31&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;for&lt;/span&gt; column &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;created_on&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt; at row 1

mysql&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; SET SESSION sql_mode = &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;ALLOW_INVALID_DATES&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt;
Query OK, 0 rows affected (0.00 sec)

mysql&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; INSERT INTO todo (title,created_on) VALUES (&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;blah&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;,&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;2019-09-31&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;)&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt;
Query OK, 1 row affected, 1 warning (0.01 sec)
mysql&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; SELECT &lt;span class=&quot;pl-k&quot;&gt;*&lt;/span&gt; FROM todo&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt;
+----+------+------------+
&lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; id &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; title &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; created_on    &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;
+----+------+------------+
&lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;  1 &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; blah &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; 2019-09-31 &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;
+----+------+------------+
1 rows &lt;span class=&quot;pl-k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;set&lt;/span&gt; (0.00 sec)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;某些场景下你可能需要保存部分日期，比如用户只输入了年没输入月日。所以 MySQL 是支持将月日设置成 0，比如 &lt;code&gt;2019-00-00&lt;/code&gt;。但这种情况下就无法从日期相关的操作中获得到准确的结果，比如使用 &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_date-sub&quot; rel=&quot;nofollow&quot;&gt;&lt;code&gt;DATE_SUB()&lt;/code&gt;&lt;/a&gt; 或 &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_date-add&quot; rel=&quot;nofollow&quot;&gt;&lt;code&gt;DATE_ADD()&lt;/code&gt;&lt;/a&gt; 函数时。禁用月日的零值可通过开启 MySQL 的 &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/sql-mode.html#sqlmode_no_zero_in_date&quot; rel=&quot;nofollow&quot;&gt;&lt;code&gt;NO_ZERO_IN_DATE&lt;/code&gt;&lt;/a&gt; 模式。&lt;/p&gt;
&lt;p&gt;除了月日可零，MySQL 还支持设置年月日都零的值 &lt;code&gt;0000-00-00&lt;/code&gt;，对于日期非必填的情况比较有用，因为此时它比单纯的 &lt;code&gt;NULL&lt;/code&gt; 更有语义。可通过开启 MySQL 的 &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/sql-mode.html#sqlmode_no_zero_date&quot; rel=&quot;nofollow&quot;&gt;NO_ZERO_DATE&lt;/a&gt; 模式来禁用这个全零的值。&lt;/p&gt;
&lt;p&gt;各日期时间零值格式如下，但实际时用时，直接简写成一个 0 效果是等效的。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Data Type&lt;/th&gt;
&lt;th&gt;“Zero” Value&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;DATE&lt;/td&gt;
&lt;td&gt;'0000-00-00'&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;TIME&lt;/td&gt;
&lt;td&gt;'00:00:00'&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;DATETIME&lt;/td&gt;
&lt;td&gt;'0000-00-00 00:00:00'&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;TIMESTAMP&lt;/td&gt;
&lt;td&gt;'0000-00-00 00:00:00'&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;YEAR&lt;/td&gt;
&lt;td&gt;0000&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2&gt;DATE，DATETIME，及 TIMESTAMP&lt;/h2&gt;
&lt;p&gt;三者具有相关性，都支持多种格式的自动解析，详见 &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/date-and-time-literals.html&quot; rel=&quot;nofollow&quot;&gt;Date and Time Literals&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;DATE&lt;/code&gt; 日期格式不带时间 &lt;code&gt;TIME&lt;/code&gt; 部分，查询时输出格式为 &lt;code&gt;YYYY-MM-DD&lt;/code&gt;，取值范围为 &lt;code&gt;1000-01-01&lt;/code&gt; 到 &lt;code&gt;9999-12-31&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;DATETIME&lt;/code&gt; 包含日期及时间，输出格式为 &lt;code&gt;YYYY-MM-DD hh:mm:ss&lt;/code&gt;，取值范围 &lt;code&gt;1000-01-01 00:00:00&lt;/code&gt; 到 &lt;code&gt;9999-12-31 23:59:59&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;TIMESTAMP&lt;/code&gt; 同 &lt;code&gt;DATETIME&lt;/code&gt;，但取值范围基于 UTC 时间，较 &lt;code&gt;DATETIME&lt;/code&gt; 要小，为 &lt;code&gt;1970-01-01 00:00:01&lt;/code&gt; UTC 到 &lt;code&gt;2038-01-19 03:14:07&lt;/code&gt; UTC。所以使用 TIMESTAMP 格式的时间，到 2038 年会溢出，这就是 &lt;a href=&quot;https://en.wikipedia.org/wiki/Year_2038_problem&quot; rel=&quot;nofollow&quot;&gt;Year 2038 problem&lt;/a&gt;。关于该问题的讨论和解决可参见这个 &lt;a href=&quot;https://stackoverflow.com/a/2012620/1553656&quot; rel=&quot;nofollow&quot;&gt;StackOverflow 的回答&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;既然如此，为何要使用这个取值范围更小的呢。&lt;code&gt;TIMESTAMP&lt;/code&gt; 存储的值是带时区的。在存储时会根据当前时区转成 UTC（universal time zone） 存储，查询时也会根据时区从 UTC 转换到具体的时间。对于支持多语及国际化全球部署的应用来说，显得尤为方便。需要注意的是，这里操作基于的时区默认为服务器的时区，可通过改变 &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_time_zone&quot; rel=&quot;nofollow&quot;&gt;&lt;code&gt;time_zone&lt;/code&gt;&lt;/a&gt; &lt;code&gt;SET GLOBAL time_zone=time_zone&lt;/code&gt; 来修改。时区的设置也可以是以连接为单位，这样来自不同时区的请求可得到不同的时间。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;TIMESTAMP&lt;/code&gt; 和 &lt;code&gt;DATETIME&lt;/code&gt; 都可包含至多 6 位的小数来表示时间中毫秒（microseconds）的部分。所以，带上毫秒时完整的格式是 &lt;code&gt;YYYY-MM-DD hh:mm:ss[.fraction]&lt;/code&gt;。前者取值范围为 &lt;code&gt;1970-01-01 00:00:01.000000&lt;/code&gt; 到 &lt;code&gt;2038-01-19 03:14:07.999999&lt;/code&gt;，后者为 &lt;code&gt;1000-01-01 00:00:00.000000&lt;/code&gt; 到 &lt;code&gt;9999-12-31 23:59:59.999999&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在写入时，对于非法的日期时间值，将自动存成零值，即 '0000-00-00' 或 '0000-00-00 00:00:00'。&lt;/p&gt;
&lt;p&gt;关于日期时间需要注意的点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;因为 MySQL 支持比较宽松的格式来设置日期时间，所以理论上你可以用你想用的值来做为数字之间的分界符，但使用时需要关注其解析的原理。比如给一个日期格式的列设置 &lt;code&gt;10:11:12&lt;/code&gt;，虽然这个值看起来像时间类型，但还是可以正确在被解析成目标列的格式，即日期。如果这这个日期列设置 &lt;code&gt;10:45:15&lt;/code&gt; 则会认为是非法值，因为 &lt;code&gt;45&lt;/code&gt; 不是一个合法的月份值，所以存储时变成零值 &lt;code&gt;0000-00-00&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;日期时间与毫秒的分界符必需是小数点。&lt;/li&gt;
&lt;li&gt;默认 MySQL 除了检查日月值是否有有效范围 1~ 31,1~12。还会将两者结合进来检查，比如 4 月没有 31。所以对于日期 &lt;code&gt;2004-04-31&lt;/code&gt; 算是非法的，会变成零值 &lt;code&gt;0000-00-00&lt;/code&gt;。如果不需要这样的约束检查，可开启 MySQL 的 &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/sql-mode.html#sqlmode_allow_invalid_dates&quot; rel=&quot;nofollow&quot;&gt;&lt;code&gt;ALLOW_INVALID_DATES&lt;/code&gt;&lt;/a&gt; 模式。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;日期时间的自动初始化及更新&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;TIMESTAMP&lt;/code&gt; 和 &lt;code&gt;DATETIME&lt;/code&gt; 还支持自动初始化（auto-initialized）和更新到当前时间（auto-updated）。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;创建表定义列时，指定 &lt;code&gt;DEFAULT CURRENT_TIMESTAMP&lt;/code&gt; 来使相应的日期时间列自动初始化。&lt;/li&gt;
&lt;li&gt;指定 &lt;code&gt;ON UPDATE CURRENT_TIMESTAMP&lt;/code&gt; 来使相应的日期时间列自动更新。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;两者可同时作用于一个日期时间列，表示插入记录时自动初始化成当前时间，后续记录更新时自动更新到当前时间。&lt;/p&gt;
&lt;p&gt;其中 &lt;code&gt;CURRENT_TIMESTAMP&lt;/code&gt; 指代当前时间，与其有相同效果的还有 &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_current-timestamp&quot; rel=&quot;nofollow&quot;&gt;&lt;code&gt;CURRENT_TIMESTAMP()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_now&quot; rel=&quot;nofollow&quot;&gt;&lt;code&gt;NOW()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_localtime&quot; rel=&quot;nofollow&quot;&gt;&lt;code&gt;LOCALTIME&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_localtime&quot; rel=&quot;nofollow&quot;&gt;&lt;code&gt;LOCALTIME()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_localtimestamp&quot; rel=&quot;nofollow&quot;&gt;&lt;code&gt;LOCALTIMESTAMP&lt;/code&gt;&lt;/a&gt; 以及 &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_localtimestamp&quot; rel=&quot;nofollow&quot;&gt;&lt;code&gt;LOCALTIMESTAMP()&lt;/code&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;DEFAULT&lt;/code&gt; 除了可指定成当前时间外，也可指定一个任意的固定值，比如 &lt;code&gt;DEFAULT 0&lt;/code&gt; 或 `DEFAULT '2000-01-01 00:00:00'。&lt;/p&gt;
&lt;p&gt;对于指定了自动初始化的列，插入时如果没指定该列的值，则会自动设置为当前的时间。&lt;/p&gt;
&lt;p&gt;对于指定为自动更新的列，一旦一条记录中有字段变更，该日期会自动更新成变更时的时间。如果不想它更新，可在插入其他值时手动设置一下该日期列为原有的值，让其保持不变。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;TIMESTAMP&lt;/code&gt; 和 &lt;code&gt;DATETIME&lt;/code&gt; 在列的定义时，如果指定了小数部分，那么在配合使用 &lt;code&gt;CURRENT_TIMESTAMP(fsp)&lt;/code&gt; 时，这个小数部分的精度需要保持一致。比如：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;--&lt;/span&gt; ✅&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;t1&lt;/span&gt; (
  ts &lt;span class=&quot;pl-k&quot;&gt;TIMESTAMP&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;6&lt;/span&gt;) DEFAULT &lt;span class=&quot;pl-c1&quot;&gt;CURRENT_TIMESTAMP&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;6&lt;/span&gt;) &lt;span class=&quot;pl-k&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;UPDATE&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;CURRENT_TIMESTAMP&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;6&lt;/span&gt;)
);

&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;--&lt;/span&gt; 🚨&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;t1&lt;/span&gt; (
  ts &lt;span class=&quot;pl-k&quot;&gt;TIMESTAMP&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;6&lt;/span&gt;) DEFAULT &lt;span class=&quot;pl-c1&quot;&gt;CURRENT_TIMESTAMP&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;UPDATE&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;CURRENT_TIMESTAMP&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;3&lt;/span&gt;)
);
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;TIME&lt;/h2&gt;
&lt;p&gt;时间 &lt;code&gt;TIME&lt;/code&gt; 格式即日期时间中时间的部分，输出格式为 &lt;code&gt;hh:mm:ss&lt;/code&gt; 或时间较大时为 &lt;code&gt;hhh:mm:ss&lt;/code&gt;，取值范围 &lt;code&gt;-838:59:59&lt;/code&gt; 到 &lt;code&gt;838:59:59&lt;/code&gt;。同样地，也是支持带至多 6 位小数表示毫秒。&lt;/p&gt;
&lt;p&gt;设置时也是支持将多种格式自动解析。对于带冒号的情况，比如 &lt;code&gt;11:12&lt;/code&gt; 解析成 &lt;code&gt;11:12:00&lt;/code&gt; 而不是 &lt;code&gt;00:11:12&lt;/code&gt;。不带冒号的情况，将最右边的两位数字解析成秒（按逝去的时间来解析），比如 &lt;code&gt;'1112'&lt;/code&gt; 和 &lt;code&gt;1112&lt;/code&gt; 不是 &lt;code&gt;11:12:00&lt;/code&gt; 而会解析成 &lt;code&gt;00:11:12&lt;/code&gt;。同理，&lt;code&gt;'12'&lt;/code&gt; 和 &lt;code&gt;12&lt;/code&gt; 会解析成 &lt;code&gt;00:00:12&lt;/code&gt;。&lt;/p&gt;
&lt;h2&gt;YEAR&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;YEAR&lt;/code&gt; 表示日期中年的部分，是一个 1 字节大小的类型，可通过 &lt;code&gt;YEAR&lt;/code&gt; 或 &lt;code&gt;YEAR(4)&lt;/code&gt; 来声明，其展示宽度（display width）为 4。查询时输出格式为 &lt;code&gt;YYYY&lt;/code&gt;，取值范围 1901 到 2155。 &lt;code&gt;0000&lt;/code&gt; 也是合法的值。&lt;/p&gt;
&lt;p&gt;支持使用以下格式进行设置：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用 1901 ~ 2155 间的四位数字值。&lt;/li&gt;
&lt;li&gt;或将上面的数字以字符串形式给定。&lt;/li&gt;
&lt;li&gt;1 ~ 99 之间的数字，此时 1 ~ 69 解析成 2001 ~ 2069，70 ~ 99 解析成 1970 ~ 1999.&lt;/li&gt;
&lt;li&gt;其他可返回合法值的方法，比如 &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_now&quot; rel=&quot;nofollow&quot;&gt;&lt;code&gt;NOW()&lt;/code&gt;&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;相关资源&lt;/h2&gt;
</description>
<pubDate>Tue, 30 Apr 2019 15:40:00 +0000</pubDate>
<dc:creator>刘哇勇</dc:creator>
<og:description>日期时间类型中包含以下几种数据类型： DATE TIME DATETIME TIMESTAMP YEAR 各类型都有具体的取值范围，超出或非法的其他值时，MySQL 会回退到 0。TIMESTAMP</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Wayou/p/mysql_data_type_datetime.html</dc:identifier>
</item>
<item>
<title>C语言的第一天 - 一枚硬币一</title>
<link>http://www.cnblogs.com/tanjie/p/10798615.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tanjie/p/10798615.html</guid>
<description>&lt;p&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　&lt;span&gt;　代码根本C语言（我不知道这句话，严不严谨）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2019年4月30日（day01）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　　　　软件Code：：blocks&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　　　　　　　　　　#include &amp;lt;stdio.h&amp;gt;　　//导入标准的io库&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　　　　#include &amp;lt;stdlib.h&amp;gt;　　//标准库&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　　　　　　　　　　int main()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　　　　{&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　　　　　　　int a = 30;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　　　　　　　printf(&quot; %-#8x | %#3o | %2.3f \n&quot;,a,a,a); 　　//%#x 输出16位进制  | %#o 输出8位进制的数 | %f浮点型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　　　　　　　return；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　　　　}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 30 Apr 2019 15:37:00 +0000</pubDate>
<dc:creator>一枚硬币一</dc:creator>
<og:description>代码根本C语言（我不知道这句话，严不严谨） 2019年4月30日（day01） 软件Code：：blocks #include &lt;stdio.h&gt; //导入标准的io库 #include</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tanjie/p/10798615.html</dc:identifier>
</item>
<item>
<title>4. CMake 系列 - 项目添加编译选项 - standardzero</title>
<link>http://www.cnblogs.com/standardzero/p/10798603.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/standardzero/p/10798603.html</guid>
<description>&lt;pre&gt;
&lt;code&gt;test3
├── add
│   ├── add.c
│   ├── add.h
│   └── CMakeLists.txt
├── build
├── CMakeLists.txt
├── config.h.in
├── example
│   ├── CMakeLists.txt
│   └── test.c
└── sub
    ├── CMakeLists.txt
    ├── sub.c
    └── sub.h&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;很多开源项目都支持编译选项控制编译，用户可以根据编译选项定制需要的功能，典型例子如linux内核，用户可根据自身裁剪内核。&lt;/p&gt;
&lt;p&gt;CMake 允许为项目增加编译选项，从而可以根据用户的环境和需求选择最合适的编译方案。&lt;/p&gt;
&lt;p&gt;编译选项控制编译的核心思想：通过CMake生成&lt;code&gt;config.h&lt;/code&gt;, &lt;code&gt;config.h&lt;/code&gt;文件定义一些宏，项目代码包含&lt;code&gt;config.h&lt;/code&gt;文件，通过这些宏控制代码模块。&lt;/p&gt;

&lt;h2 id=&quot;add-模块&quot;&gt;2.1 add 模块&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;add.h&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#ifndef _ADD_H
#define _ADD_H

int add(const int a, const int b);

#endif
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;add.c&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &quot;add.h&quot;

int add(const int a, const int b)
{
    return a+b;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;CMakeLists.txt&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 递归获取目录下所有的C文件
file(GLOB_RECURSE c_files ./*.c)


# 递归获取目录下所有的h文件
file(GLOB_RECURSE h_files ./*.h)

#生成动态库和静态库
add_library(add_lib_shared  SHARED ${c_files})
add_library(add_lib_static STATIC ${c_files})

#将动态库和静态库的名字设置为 add
set_target_properties(add_lib_shared PROPERTIES OUTPUT_NAME &quot;add&quot;)
set_target_properties(add_lib_static PROPERTIES OUTPUT_NAME &quot;add&quot;)

#设置动态库版本
set_target_properties(add_lib_shared PROPERTIES VERSION 1.0 SOVERSION 1)

#安装动态库和静态库
INSTALL(TARGETS add_lib_shared add_lib_static
    LIBRARY DESTINATION lib
    ARCHIVE DESTINATION lib)

#安装头文件
INSTALL(FILES ${h_files}  DESTINATION include)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;sub-模块&quot;&gt;2.2 sub 模块&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;sub.h&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#ifndef _SUB_H
#define _SUB_H

int sub(const int a, const int b);

#endif
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;sub.c&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &quot;sub.h&quot;

int sub(const int a, const int b)
{
    return a - b;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;CMakeLists.txt&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#递归获取目录下所有的C文件
file(GLOB_RECURSE c_files ./*.c)

# 递归获取目录下所有的h文件
file(GLOB_RECURSE h_files ./*.h)

#生成动态库和静态库
add_library(sub_lib_shared  SHARED ${c_files})
add_library(sub_lib_static STATIC ${c_files})

#将动态库和静态库的名字设置为 sub
set_target_properties(sub_lib_shared PROPERTIES OUTPUT_NAME &quot;sub&quot;)
set_target_properties(sub_lib_static PROPERTIES OUTPUT_NAME &quot;sub&quot;)

#设置动态库版本
set_target_properties(sub_lib_shared PROPERTIES VERSION 1.0 SOVERSION 1)

#设置动态库版本
set_target_properties(sub_lib_shared PROPERTIES VERSION 1.0 SOVERSION 1)

#安装动态库和静态库
INSTALL(TARGETS sub_lib_shared sub_lib_static
    LIBRARY DESTINATION lib
    ARCHIVE DESTINATION lib)

#安装头文件
INSTALL(FILES ${h_files}  DESTINATION include)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;example-模块&quot;&gt;2.3 example 模块&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;test.c&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &quot;config.h&quot;

#ifdef ENABLE_ADD
#include &quot;add.h&quot;
#endif

#ifdef ENABLE_SUB
#include &quot;sub.h&quot;
#endif

#include &amp;lt;stdio.h&amp;gt;


int main(int argc, char **argv)
{
    int a = 10;
    int b = 8;
#ifdef ENABLE_ADD
    printf(&quot;%d + %d = %d\n&quot;, a, b, add(a, b));
#endif

#ifdef ENABLE_SUB
    printf(&quot;%d - %d = %d\n&quot;, a, b, sub(a, b));
#endif


    return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;CMakeLists.txt&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 添加头文件路径
include_directories(${PROJECT_SOURCE_DIR}/add)
include_directories(${PROJECT_SOURCE_DIR}/sub)
include_directories(${PROJECT_SOURCE_DIR})

# 添加第三方库(add)头文件路径
link_directories(${PROJECT_SOURCE_DIR}/lib)

# 生成执行文件
add_executable(test_add_sub test.c)

# 链接库文件
if(ENABLE_ADD)
target_link_libraries(test_add_sub add)
endif(ENABLE_ADD)

if(ENABLE_SUB)
target_link_libraries(test_add_sub sub)
endif(ENABLE_SUB)

INSTALL(TARGETS test_add_sub 
    RUNTIME DESTINATION bin)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;顶层-cmakelists.txt&quot;&gt;2.4 顶层 CMakeLists.txt&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;CMakeLists.txt&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cmake_minimum_required(VERSION 3.10)

# 设置库文件输出目录
set(LIBRARY_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/lib)

# 设置执行文件输出目录
set(EXECUTABLE_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/bin)


# 添加编译选项
option(ENABLE_ADD &quot;enable add&quot; ON)
option(ENABLE_SUB &quot;enable sub&quot; ON)

if(ENABLE_ADD)
    add_subdirectory(add)
endif(ENABLE_ADD)

if(ENABLE_SUB)
    add_subdirectory(sub)
endif(ENABLE_SUB)

# 加入一个头文件配置，让cmake对源码进行操作
configure_file(
    &quot;${PROJECT_SOURCE_DIR}/config.h.in&quot;
    &quot;${PROJECT_SOURCE_DIR}/config.h&quot;
    )

add_subdirectory(example)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;configure_file&lt;/code&gt;命令用于加入一个配置头文件&lt;code&gt;config.h&lt;/code&gt; ，这个文件由CMake从&lt;code&gt;config.h.in&lt;/code&gt;生成，通过这样的机制，将可以通过预定义一些参数和变量来控制代码的生成。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;option&lt;/code&gt;命令添加了&lt;code&gt;ENABLE_ADD&lt;/code&gt; 选项&lt;br/&gt;和&lt;code&gt;ENABLE_SUB&lt;/code&gt;选项，并且默认值为&lt;code&gt;ON&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;cmake 可以根据&lt;code&gt;ENABLE_ADD&lt;/code&gt; 选项&lt;br/&gt;和&lt;code&gt;ENABLE_SUB&lt;/code&gt;选项的值来控制是否编译&lt;code&gt;add&lt;/code&gt;模块和&lt;code&gt;sub&lt;/code&gt;模块。&lt;/p&gt;
&lt;p&gt;要想在&lt;code&gt;config.h&lt;/code&gt;生成对应的宏，需要对&lt;code&gt;config.h.in&lt;/code&gt;进行如下配置&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;config.h.in&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#cmakedefine ENABLE_ADD
#cmakedefine ENABLE_SUB
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;默认配置&amp;amp;编译&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ cd build
$ cmake ..
$ make
$ cd ..
$ tree bin lib&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;bin
└── test_add_sub
lib
├── libadd.a
├── libadd.so -&amp;gt; libadd.so.1
├── libadd.so.1 -&amp;gt; libadd.so.1.0
├── libadd.so.1.0
├── libsub.a
├── libsub.so -&amp;gt; libsub.so.1
├── libsub.so.1 -&amp;gt; libsub.so.1.0
└── libsub.so.1.0
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从生成的lib库，可以看出，&lt;code&gt;add&lt;/code&gt;模块和&lt;code&gt;sub&lt;/code&gt;模块都生成了。&lt;/p&gt;
&lt;p&gt;查看&lt;code&gt;config.h&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#define ENABLE_ADD
#define ENABLE_SUB
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;自定义配置&amp;amp;编译&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ cd build
$ cmake -DENABLE_ADD=OFF ..
$ make
$ cd ..
$ tree bin lib&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;bin
└── test_add_sub
lib
├── libsub.a
├── libsub.so -&amp;gt; libsub.so.1
├── libsub.so.1 -&amp;gt; libsub.so.1.0
└── libsub.so.1.0
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从生成的lib库，可以看出，&lt;code&gt;add&lt;/code&gt;模块并未生成了。&lt;/p&gt;
&lt;p&gt;查看&lt;code&gt;config.h&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/* #undef ENABLE_ADD */
#define ENABLE_SUB&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;使用ccmake工具进行配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当我们的项目很大且配置选项很多的时候，可以选择ccmake工具进行配置编译选项，这个是交互式配置工具，有点类似内核的&lt;code&gt;menuconfigure&lt;/code&gt;的功能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416584/201904/1416584-20190430233332685-124994017.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;enter&lt;/code&gt;: 编辑选项&lt;/p&gt;
&lt;p&gt;&lt;code&gt;c&lt;/code&gt;: 配置&lt;/p&gt;
&lt;p&gt;&lt;code&gt;g&lt;/code&gt;：生成makefile&lt;/p&gt;
&lt;p&gt;&lt;code&gt;q&lt;/code&gt;：退出&lt;/p&gt;
&lt;p&gt;&lt;code&gt;h&lt;/code&gt;: 帮助&lt;/p&gt;
</description>
<pubDate>Tue, 30 Apr 2019 15:34:00 +0000</pubDate>
<dc:creator>standardzero</dc:creator>
<og:description>[TOC] 1. 项目目录结构 很多开源项目都支持编译选项控制编译，用户可以根据编译选项定制需要的功能，典型例子如linux内核，用户可根据自身裁剪内核。 CMake 允许为项目增加编译选项，从而可以</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/standardzero/p/10798603.html</dc:identifier>
</item>
<item>
<title>RabbitMQ指南之二：工作队列（Work Queues） - 无恨之都</title>
<link>http://www.cnblogs.com/wuhenzhidu/p/10787702.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wuhenzhidu/p/10787702.html</guid>
<description>&lt;p&gt;  　　在上一章的指南中，我们写了一个命名队列：生产者往该命名队列发送消息、消费从从该命名队列中消费消息。在本章中，我们将创建一个工作队列，用于在多个工作者之间分配耗时的任务。工作队列(即任务队列)的主要思想是避免立即执行那些需要等他们执行完成的资源密集型任务。相反，我们将任务安排在稍后完成。我们将任务封装为消息并将其发送到队列，后台运行的工作进程将取出任务并执行完成。如果你启动了多个工作者，这些任务将在多个工作者之间分享。&lt;/p&gt;
&lt;p&gt;　　这个概念也即我们说的异步，在项目中，有时候一个简单的Web请求，后台要做一系统的操作，这时候，如果后台执行完成之后再给前台返回消息将会导致浏览器页面等待从而出现假死状态。因此，通常的做法是，在这个Http请求到后台，后台获取到正确的参数等信息后立即给前台返回一个成功标志，然后后台异步地进行后续的操作。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1651332/201904/1651332-20190428220258839-1855423161.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　本章中，我们将发送字符串消息来模拟复杂的任务。这里因为没有一个真实的复杂任务，因此用Thread.sleep()方法来模拟复杂耗时的任务。我们用字符串中的含点（“.&quot;）的数量来表示任务的复杂程度，一个点表示一秒钟的耗时，例如：一个发送”Hello ...“字符串的任务将会耗时3秒钟。&lt;/p&gt;
&lt;p&gt;　　我们可以直接将上一章中的&lt;em&gt;&lt;span&gt;Send.java&lt;/span&gt;&lt;/em&gt;代码拿过来修改，允许从命令行发送消息。本程序将会把任务调试到工作队列，因此，我们将类名改为NewTask.java：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
String message = String.join(&quot; &quot;&lt;span&gt;, argv);

channel.basicPublish(&lt;/span&gt;&quot;&quot;, &quot;hello&quot;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;, message.getBytes());
System.out.println(&lt;/span&gt;&quot; [x] Sent '&quot; + message + &quot;'&quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　此时完整的NewTask.java代码为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; NewTask {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String QUEUE_NAME = &quot;hello&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] argv) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException, TimeoutException {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;         ConnectionFactory connectionFactory = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConnectionFactory();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         connectionFactory.setHost(&quot;HOST&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;(Connection connection =&lt;span&gt; connectionFactory.newConnection();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             Channel channel =&lt;span&gt; connection.createChannel()) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;             channel.queueDeclare(QUEUE_NAME,&lt;span&gt;false&lt;/span&gt;,&lt;span&gt;false&lt;/span&gt;,&lt;span&gt;false&lt;/span&gt;,&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;             String message = String.join(&quot; &quot;&lt;span&gt;, argv);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             
&lt;span&gt;17&lt;/span&gt;             channel.basicPublish(&quot;&quot;,QUEUE_NAME,&lt;span&gt;null&lt;/span&gt;,message.getBytes(&quot;UTF-8&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             System.out.println(&quot; [x] Sent '&quot; + message + &quot;'&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　之前的Recv.java也要做一些修改：模拟字符串消息中的每个点耗时1秒钟，它将处理传送过来的消息并执行任务，因此，我们修改为Work.java：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; DeliverCallback deliverCallback = (consumerTag, delivery) -&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;   String message = &lt;span&gt;new&lt;/span&gt; String(delivery.getBody(), &quot;UTF-8&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;   System.out.println(&quot; [x] Received '&quot; + message + &quot;'&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;   &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    doWork(message);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;   } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     System.out.println(&quot; [x] Done&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; autoAck = &lt;span&gt;true&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; acknowledgment is covered below&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; channel.basicConsume(TASK_QUEUE_NAME, autoAck, deliverCallback, consumerTag -&amp;gt; { });
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我们模拟执行过程中耗时的伪任务：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; doWork(String task) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;char&lt;/span&gt;&lt;span&gt; ch: task.toCharArray()) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (ch == '.') Thread.sleep(1000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　此时完整的Work.java为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Worker {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String TASK_QUEUE_NAME = &quot;hello&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;         ConnectionFactory connectionFactory = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConnectionFactory();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         connectionFactory.setHost(&quot;HOST&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;         Connection connection =&lt;span&gt; connectionFactory.newConnection();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         Channel channel =&lt;span&gt; connection.createChannel();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         channel.queueDeclare(TASK_QUEUE_NAME,&lt;span&gt;false&lt;/span&gt;,&lt;span&gt;false&lt;/span&gt;,&lt;span&gt;false&lt;/span&gt;,&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;         DeliverCallback deliverCallback = (consumerTag, delivery) -&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             String message = &lt;span&gt;new&lt;/span&gt; String(delivery.getBody(), &quot;UTF-8&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;             System.out.println(&quot; [x] Received '&quot; + message + &quot;'&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;                doWork(message);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;                e.printStackTrace();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                 System.out.println(&quot; [x] Done&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        };
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;boolean&lt;/span&gt; autoAck = &lt;span&gt;true&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; acknowledgment is covered below&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;         channel.basicConsume(TASK_QUEUE_NAME, autoAck, deliverCallback, consumerTag -&amp;gt;&lt;span&gt; { });
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; doWork(String task) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;char&lt;/span&gt;&lt;span&gt; ch: task.toCharArray()) {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (ch == '.') Thread.sleep(1000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　使用工作队列的优点之一是能够轻松地进行并行化操作。假设我们在做一个后台日志收集系统，我们可以很容易地增加更多的Worker从而提高系统性能。&lt;/p&gt;
&lt;p&gt;　　首先，我们同时启动两个Worker，同样地，我这里也放到IDEA中启动：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1651332/201904/1651332-20190428225726785-830854617.png&quot; alt=&quot;&quot; width=&quot;398&quot; height=&quot;193&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　接下来，我们先后启动5个Task，并分别通过main()参数传入五个字符串消息：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;First message.
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;Second message..
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;Third message...
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;Fourth message....
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; Fifth message.....
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1651332/201904/1651332-20190428230337044-1476631418.png&quot; alt=&quot;&quot; width=&quot;424&quot; height=&quot;119&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　执行五个发送任务之后，来看一下两个Worker都接收到了什么样的消息：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1651332/201904/1651332-20190428230659970-695832234.png&quot; alt=&quot;&quot; width=&quot;400&quot; height=&quot;184&quot;/&gt;        &lt;img src=&quot;https://img2018.cnblogs.com/blog/1651332/201904/1651332-20190428230734987-156590766.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　默认情况下，RabbitMQ将按顺序将每个消息发送给下一个使用者。平均每个消费者将得到相同数量的消息。这种消息的调度方式称之为循环调度，你可以开启更多的Worker来进行测试。&lt;/p&gt;

&lt;p&gt;　　因为消费者执行一个任务会有时间耗时，假设一个消费者在执行一个任务执行一半的时候挂掉了将会怎样？消息会不会因此丢失？在我们目前的代码里，一旦RabbitMq将一条消息转发给了一个消费者后，将会立即将消息删除（注意Worker.java里的autoAck），因此，在我们上面例子里，如kill掉一个正在处理数据的Worker，那么该数据将会丢失。不仅如此，所有那些指派给该Worker的还未处理的消息也会丢失。&lt;/p&gt;
&lt;p&gt;　　但在实际工作的，我们并不希望一个Worker挂掉之后就会丢失数据，我们希望的是：如果该Worker挂掉了，所有转发给该Worker的消息将会重新转发给其他Worker进行处理（包括处理了一半的消息）。为了确保一条消息永不丢失，RabbitMq支持消息回执。消费者在接收到一条消息，并且成功处理完成之后会给RabbitMq回发一条确认ack确认消息，RabbitMq此时才会删除该条消息。&lt;/p&gt;
&lt;p&gt;　　如果一个Worker正在处理一条消息时挂掉了（信道关闭、连接关闭、TCP连接丢失），它将没有机会发送ack回执，RabbitMq就认为该消息没有消费成功，于是便会将该消息重新放到队列中，如果此时有其他消费者还是在线状态，RabbitMq会立即将该条消息再转发给其他在线的消费者。这种机制可以保证任何消息都不会丢失。&lt;/p&gt;
&lt;p&gt;　　默认情况下，需要手动进行消息确认，在前面的例子里，我们通过autoAck=true显示地关闭了手动消息确认，因此，RabbitMq将采用自动消息确认的机制。现在，我们修改我们的程序，采用手动发送回执的方式，当我们完成对消息的处理后，再手动发送回执确认：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; channel.basicQos(1); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; accept only one unack-ed message at a time (see below)&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; DeliverCallback deliverCallback = (consumerTag, delivery) -&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;   String message = &lt;span&gt;new&lt;/span&gt; String(delivery.getBody(), &quot;UTF-8&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;   System.out.println(&quot; [x] Received '&quot; + message + &quot;'&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;   &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    doWork(message);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;   } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     System.out.println(&quot; [x] Done&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     channel.basicAck(delivery.getEnvelope().getDeliveryTag(), &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; autoAck = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; channel.basicConsume(TASK_QUEUE_NAME, autoAck, deliverCallback, consumerTag -&amp;gt; { });
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　ack发送信道必须和接收消息的信道(channel)是同一个，如果尝试通过一个不同的信道发送ack回执，将会抛出channel等级协议异常（官网说会抛出异常，但是我在实际测试中并没有抛异常，只是该条消息得不到回执，从而也无法删除）。&lt;/p&gt;
&lt;p&gt;　　一个常见的错误是忘了手动回执，虽然只是一个简单的错误，但是带来的后果却是严重的，它将导致已经消费掉的消费不会被删除，并且当消费该消息的消费者在退出之后，RabbitMq会将该条消息重新进行转发，内存将被慢慢耗尽。我们可以通过正面的命令来检查这种错误：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
sudo rabbitmqctl list_queues name messages_ready messages_unacknowledged
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1651332/201904/1651332-20190430222742656-1481357488.png&quot; alt=&quot;&quot; width=&quot;484&quot; height=&quot;78&quot;/&gt;    &lt;img src=&quot;https://img2018.cnblogs.com/blog/1651332/201904/1651332-20190430222821989-760947836.png&quot; alt=&quot;&quot; width=&quot;730&quot; height=&quot;73&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　该命令有三列内容，第一列是在监听的队列名称，第二列是Ready状态的消息数量，第三列是Unacked的消息数量。&lt;/p&gt;

&lt;p&gt;　　在3中我们讲解了如何保证当消费者挂掉之后消息不被丢失，但是，如果RabbitMq服务或者部署RabbitMq的服务器挂掉了之后，消息仍然会丢失。当RabbitMq崩溃之后，它将会忘记所有的队列和消息，除非，有什么机制让RabbitMq将队列信息和消息保存下来。&lt;/p&gt;
&lt;p&gt;　　要确保消息和队列不会丢失，我们必须要确保两件事情。&lt;/p&gt;
&lt;p&gt;　　首先，我们要确保RabbitMq永远不丢失队列，要做到这点，我们在定义的时候就需要告诉RabbitMq它是需要持久化的，通过指定durable参数实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;boolean&lt;/span&gt; durable = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
channel.queueDeclare(&lt;/span&gt;&quot;hello&quot;, durable, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　虽然这个命令本身是正确的，但是在我们目前它不能工作。因为我们前面已经定义了一个非持久化的hello队列，RabbitMq不允许重新定义一个已经存在的队列（用不同的参数），否则会抛出异常：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
Exception in thread &quot;main&quot;&lt;span&gt; java.io.IOException
    at com.rabbitmq.client.impl.AMQChannel.wrap(AMQChannel.java:&lt;/span&gt;126&lt;span&gt;)
    at com.rabbitmq.client.impl.AMQChannel.wrap(AMQChannel.java:&lt;/span&gt;122&lt;span&gt;)
    at com.rabbitmq.client.impl.AMQChannel.exnWrappingRpc(AMQChannel.java:&lt;/span&gt;144&lt;span&gt;)
    at com.rabbitmq.client.impl.ChannelN.queueDeclare(ChannelN.java:&lt;/span&gt;962&lt;span&gt;)
    at com.rabbitmq.client.impl.recovery.AutorecoveringChannel.queueDeclare(AutorecoveringChannel.java:&lt;/span&gt;333&lt;span&gt;)
    at myblog.myblog.java8.methodreference.rabbitmq.workqueue.NewTask.main(NewTask.java:&lt;/span&gt;23&lt;span&gt;)
    Suppressed: com.rabbitmq.client.AlreadyClosedException: channel is already closed due to channel error; protocol method: #method&lt;/span&gt;&amp;lt;channel.close&amp;gt;(reply-code=406, &lt;br/&gt;reply-text=PRECONDITION_FAILED - parameters &lt;span&gt;for&lt;/span&gt; queue 'hello' in vhost '/' not equivalent, &lt;span&gt;class&lt;/span&gt;-id=50, method-id=10&lt;span&gt;)
        at com.rabbitmq.client.impl.AMQChannel.processShutdownSignal(AMQChannel.java:&lt;/span&gt;396&lt;span&gt;)
        at com.rabbitmq.client.impl.ChannelN.startProcessShutdownSignal(ChannelN.java:&lt;/span&gt;292&lt;span&gt;)
        at com.rabbitmq.client.impl.ChannelN.close(ChannelN.java:&lt;/span&gt;607&lt;span&gt;)
        at com.rabbitmq.client.impl.ChannelN.close(ChannelN.java:&lt;/span&gt;541&lt;span&gt;)
        at com.rabbitmq.client.impl.ChannelN.close(ChannelN.java:&lt;/span&gt;534&lt;span&gt;)
        at com.rabbitmq.client.impl.recovery.AutorecoveringChannel.close(AutorecoveringChannel.java:&lt;/span&gt;68&lt;span&gt;)
        at myblog.myblog.java8.methodreference.rabbitmq.workqueue.NewTask.main(NewTask.java:&lt;/span&gt;29)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　要么重启RabbitMq让该临时队列消失，要么在控制台将该队列删除，或者重新创建一个新的队列：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; durable = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; channel.queueDeclare(&quot;task_queue&quot;, durable, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　生产者和消费者要做同步修改。&lt;/p&gt;
&lt;p&gt;　　上面这一步，我们保证了队列（task_quee）的持久化，此时，即便RabbitMq崩溃了也不会丢失该队列，当RabbitMq重启后将自动重新加载该队列。&lt;/p&gt;
&lt;p&gt;　　其次，我们需要确保我们的消息也被持久化，要做到这一点，在生产者发布消息的时候需要指定消息的属性为：PERSISTENT_TEXT_PLAIN。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.rabbitmq.client.MessageProperties;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt; channel.basicPublish(&quot;&quot;, &quot;task_queue&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;            MessageProperties.PERSISTENT_TEXT_PLAIN,
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;             message.getBytes());
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;strong&gt;注意，&lt;/strong&gt;即便设置了消息的持久化属性也不能保证消息会被100%地写入到磁盘中，因为RabbitMq在接收到消息和写入到磁盘不是同步的，有可能消息只是被写入到缓存中而还没来和及写入磁盘的时候，RabbitMq崩溃了，此时也会丢失消息。但无论如何，比前面简单的消息队列已经强大了很多。&lt;/p&gt;

&lt;p&gt;　　您可能已经注意到，任务调度仍然不能完全按照我们希望的方式工作。举个例子，在只有两个Worker的环境中，奇数的消息比较重，偶数的消息比较轻时，一个Worker将会一直处于忙碌状态，而另一个Worker将会一直处于空闲状态，但RabbitMq并不知道这种情况，它会依然均衡地向两个Worker传递消息。&lt;/p&gt;
&lt;p&gt;　　发生这种情况是因为，当一个消息进入队列之后，RabbitMq只是盲目地将该第n个消息转发给第n个消费者，它并不关注每个消费者发了多少个回执。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1651332/201904/1651332-20190430231007468-1417204694.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　为了解决这个问题，我们可以通过调用basicQos方法，给它传入1。这将告诉RabbitMq不要同时给一个队列转发多于1条的消息，换句话说，在一个消费者没有完成并回执前一条消息时，不要再给它转发其他消息。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; prefetchCount = 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; channel.basicQos(prefetchCount);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;strong&gt;一、NewTask.java&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.rabbitmq.client.Channel;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.rabbitmq.client.Connection;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.rabbitmq.client.ConnectionFactory;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.rabbitmq.client.MessageProperties;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; NewTask {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;   &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String TASK_QUEUE_NAME = &quot;task_queue&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;   &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] argv) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     ConnectionFactory factory = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConnectionFactory();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     factory.setHost(&quot;localhost&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt; (Connection connection =&lt;span&gt; factory.newConnection();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;          Channel channel =&lt;span&gt; connection.createChannel()) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         channel.queueDeclare(TASK_QUEUE_NAME, &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;         String message = String.join(&quot; &quot;&lt;span&gt;, argv);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;         channel.basicPublish(&quot;&quot;&lt;span&gt;, TASK_QUEUE_NAME,
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;                MessageProperties.PERSISTENT_TEXT_PLAIN,
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                 message.getBytes(&quot;UTF-8&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         System.out.println(&quot; [x] Sent '&quot; + message + &quot;'&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;　　二、Worker.java&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.rabbitmq.client.Channel;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.rabbitmq.client.Connection;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.rabbitmq.client.ConnectionFactory;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.rabbitmq.client.DeliverCallback;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Worker {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;   &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String TASK_QUEUE_NAME = &quot;task_queue&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;   &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] argv) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     ConnectionFactory factory = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConnectionFactory();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     factory.setHost(&quot;localhost&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;final&lt;/span&gt; Connection connection =&lt;span&gt; factory.newConnection();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;final&lt;/span&gt; Channel channel =&lt;span&gt; connection.createChannel();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;     channel.queueDeclare(TASK_QUEUE_NAME, &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     System.out.println(&quot; [*] Waiting for messages. To exit press CTRL+C&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;     channel.basicQos(1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;     DeliverCallback deliverCallback = (consumerTag, delivery) -&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         String message = &lt;span&gt;new&lt;/span&gt; String(delivery.getBody(), &quot;UTF-8&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;         System.out.println(&quot; [x] Received '&quot; + message + &quot;'&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;            doWork(message);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             System.out.println(&quot; [x] Done&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             channel.basicAck(delivery.getEnvelope().getDeliveryTag(), &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;    };
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     channel.basicConsume(TASK_QUEUE_NAME, &lt;span&gt;false&lt;/span&gt;, deliverCallback, consumerTag -&amp;gt;&lt;span&gt; { });
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt;   &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doWork(String task) {
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;char&lt;/span&gt;&lt;span&gt; ch : task.toCharArray()) {
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (ch == '.'&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;                 Thread.sleep(1000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;             } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException _ignored) {
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;                Thread.currentThread().interrupt();
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　至此，工作队列模式讲解完了，下一章，将讲解发布-订阅模式。&lt;/p&gt;
</description>
<pubDate>Tue, 30 Apr 2019 15:25:00 +0000</pubDate>
<dc:creator>无恨之都</dc:creator>
<og:description>在上一章的指南中，我们写了一个命名队列：生产者往该命名队列发送消息、消费从从该命名队列中消费消息。在本章中，我们将创建一个工作队列，用于在多个工作者之间分配耗时的任务。工作队列(即任务队列)的主要思想</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wuhenzhidu/p/10787702.html</dc:identifier>
</item>
<item>
<title>Tarojs+redux支付宝小程序开发攻略 - 散场丶丶</title>
<link>http://www.cnblogs.com/sanchang/p/10790052.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sanchang/p/10790052.html</guid>
<description>&lt;h3 id=&quot;技术选型&quot;&gt;技术选型&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;   对于习惯react语法的开发者来讲，RN是实现native的必备工具。 我们甚至可以屏蔽官方稳定而强大的配置层，直接上手开发。
   而后，同为表层React语法的Rax、Taro这样的开源多端开发框架的兴起，让react开发人员得以不必在多端投入更高的成本。反过来，只要有足够的移动端开发经验(主要体现在多端机型兼容这方面)，那么这些开源的多端框架就会成为你手中的神器，让你几乎零成本get到碎片化多端开发技能。
    Taro相对于Rax的优势是，在国内的开源社区更为活跃(论中文文档的重要性)，集成的端更多(包括不限于h5，native与各类小程序)，集成的功能更多, 语法限制与RN相去不远(基于集成注册RN中间层实现的Native)。
    虽然Taro集成的端数比较多，但在开发过程中，我们可针对一类单独watch，build，每一类的官方调试方案与端官方(如蚂蚁金服支付宝小程序)的调试工具无缝对接。
    集成Redux而不是mobX，则是单纯的基于技术熟练度的思考（实际上mobX在开发范式上更高层一些）。&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;支付宝小程序端开发准备&quot;&gt;支付宝小程序端开发准备&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;    我曾思考一个很有深度的问题，混合开发的难点是在哪。
    这个问题大概三秒钟就有了答案：
    1环境配置  ； 2调试兼容

    那么基于上述两个问题中的第一个，Taro在官方文档中已经给出了解决方案——基于taro的配置，我们只需要简单地修改几个配置字段即可。
    后面有详细的流程。
    
    折回开发准备： 
   1 需要node开发环境(这是句废话); 
   2 taro脚手架 运行的时候选择集成redux; 
   3 安官方文档中这里，点击下图红框中的链接，下载并安装支付宝调试工具。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1425733/201904/1425733-20190429131417547-882683762.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   4 申请项目调试权限(按蚂蚁金服支付宝小程序官方文档走简单流程。链接地址：https://docs.alipay.com/mini/developer/getting-started/ )&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;脚手架简单配置&quot;&gt;脚手架简单配置。&lt;/h3&gt;
&lt;h4 id=&quot;css模块化配置&quot;&gt;1 css模块化配置&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;taro的css模块化目前支持基于hash随机值的模块化(等同于css-modules)，配置极为简单， 如官方所示：
https://nervjs.github.io/taro/docs/css-modules.html
这里直接给出链接，对应修改两个bool参数即可。
但要注意的是：  在css的命名上：
要以 name.module.css(/less/sass)的形式——
如：  index.module.less 
在使用时，以json变量的形式引入并使用，如代码所示&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;    import styles from './index.module.less'

    class Demo extends Component {
        render () {
            return (
              &amp;lt;View className={styles.wrap}&amp;gt;
                &amp;lt;Text className={styles.demoText}&amp;gt;
                     demo
                 &amp;lt;/Text&amp;gt;
              &amp;lt;/View&amp;gt;
            )
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt; 当然，除开上述方式，我们也可以用css in js的方式实现，这点上几乎所有表层react语法的多端框架都支持：&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;    import styles from './index.module.less'

    const demoStyle = {
        width: '300px',
        height: '300px'
    }
    class Demo extends Component {
        render () {
            return (
              &amp;lt;View style={demoStyle}&amp;gt;
                &amp;lt;Text &amp;gt;
                     demo
                 &amp;lt;/Text&amp;gt;
              &amp;lt;/View&amp;gt;
            )
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;但要注意的是，上述写法中的单位px，不会被转化成对应的rem，而用css-modules的形式，会默认以iphone6的尺寸给转化成rem(省去了很多麻烦)。
实际上，我个人认为css in js的形式更能体现组件化开发的思想，但在tarojs里，建议还是用css-modules，亲测比较成熟，没有出任何问题。&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;redux配置&quot;&gt;2 redux配置&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt; 在“开局”选择redux集成时，展开的taro框架里，已经给集成了redux的使用demo。
 使用总结来讲，即，三个文件夹。
     &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1425733/201904/1425733-20190430220012806-463312320.png&quot;/&gt;&lt;br/&gt;如图，actions，constants，reduces里的文件应该与pages里每个pege名一一对应(目录统一，更加清晰)。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;要注意的是，如果store里使用的是下图中的中间件(默认生成使用就这个)，那么在写异步action时，请用promise，而不应该用generetor函数&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1425733/201904/1425733-20190430220325884-869914273.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;异步action的就可以这么写：&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;//postReq是基于fetch封装了请求头的请求函数
export  function fetchData (payload){
  const {params={},callback} = payload;
  return dispatch=&amp;gt;{
    postReq(url,{
      params,
      callback
    })
    .then(
      res=&amp;gt;{
        if(res.status){
          dispatch({
            type: FETCHDATA
            data: res.data
          })
        }
      }
    )
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;开发注意事项&quot;&gt;开发注意事项&lt;/h3&gt;
&lt;h4 id=&quot;阻止事件冒泡&quot;&gt;1 阻止事件冒泡&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;如果有特殊的情况，需要阻止实践冒泡，在官方中提供了针对此需求的api，但在支付宝小程序端似乎不太好用(亲测不起效),解决方案是：
 用一个实例属性控制，在第一次触发的点击事件里修改实例属性值，冒泡触发的事件里基于这个实例属性做逻辑,如：&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;    handleWrapClick = ()=&amp;gt;{
        if(this.isStop){
            return null
        }
        this.goHome() //跳转到Home页
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;jsx只能写在render注意以下代码在支付宝小程序端是不起效的&quot;&gt;2 jsx只能写在render，注意，以下代码在支付宝小程序端是不起效的：&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;    class Demo extends Component {
        //在下面的这个实例方法里写jsx是不起效的
        renderText = ()=&amp;gt;(
            &amp;lt;Text&amp;gt;
                demo
             &amp;lt;/Text&amp;gt;
        )
        render () {
            const text = this.renderText();
            return (
              &amp;lt;View style={demoStyle}&amp;gt;
                   {text}
              &amp;lt;/View&amp;gt;
            )
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们应该写成下面的方式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;     class Demo extends Component {
        //jsx必须写在render里
        render () {
            const text = (
                &amp;lt;Text&amp;gt;
                    demo
                 &amp;lt;/Text&amp;gt;
            );
            return (
              &amp;lt;View style={demoStyle}&amp;gt;
                   {text}
              &amp;lt;/View&amp;gt;
            )
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述问题跟taro的render解决方案有关&lt;/p&gt;
</description>
<pubDate>Tue, 30 Apr 2019 14:21:00 +0000</pubDate>
<dc:creator>散场丶丶</dc:creator>
<og:description>tarojs+redux支付宝小程序端开发实践</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sanchang/p/10790052.html</dc:identifier>
</item>
<item>
<title>Java虚拟机四：垃圾回收算法与垃圾收集器 - 码农大卫</title>
<link>http://www.cnblogs.com/fengweiweicoder/p/10787454.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fengweiweicoder/p/10787454.html</guid>
<description>&lt;p&gt;　　在Java运行时的几个数据区域中，程序计数器，虚拟机栈，本地方法栈3个区域随着线程而生，随线程而灭，因此这几个区域的内存分配和回收具有确定性，不需要过多考虑垃圾回收问题，因为方法结束或者线程结束时，内存就回收了。但是方法区和堆区不一样，一个接口或者实现类所需要的内存可能不一样，一个方法的多个分支需要的内存也可能不一样，只有程序运行时才能知道创建哪些对象，这部分内存的分配和回收是动态的。&lt;/p&gt;
&lt;p&gt;　　在进行垃圾回收时候，首先需要判断哪些对象需要回收，这就涉及到回收算法的问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、垃圾回收算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.标记-清除算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　标记-清除算法是一种最基础的垃圾收集算法，分为“标记”和“清除”两步。“标记”阶段标记所有需要进行垃圾回收的对象，标记完成后统一回收被标记的对象。这种算法的不足点在于：&lt;/p&gt;
&lt;p&gt;　　（1）效率问题，标记和清除两个过程效率都不高；&lt;/p&gt;
&lt;p&gt;　　（2）空间问题，标记清除后会产生大量不连续碎片，后续如果需要为较大对象分配空间，则又需触发垃圾回收。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.复制算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　为了解决标记-清除算法的效率问题，出现了复制算法。这种算法把内存按照容量划分为大小相同的两块，每次只是用其中一块，当这块内存用完了，就把还存活的对象复制到另外一块中，并将这块的内存清理掉，然后使用另外一块，当另外一块内存用完了，再把存活的对象复制到这块中，并清理另外一块内存，依次类推。&lt;/p&gt;
&lt;p&gt;　　复制算法主要用于新生代的回收，在HotSpot虚拟机中，新生代内存划分为一块较大的Eden空间，和两块较小的Survivor空间，每次使用Eden空间和其中一块Survivor空间。当进行垃圾回收时，会把Eden空间和Survivor空间中存活的对象一次性复制到另外一块Survivor空间上，最后清理掉Eden空间和刚才使用过的Survivor空间。HotSpot虚拟机中，默认情况下Eden空间和Survivor空间的大小比例是8:1，即Eden空间占整个新生代的80%，每次新生代中使用的空间为80%+10%=90%，闲置空间10%。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.标记-整理算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;复制算法适用于那种对象存活率较低的场景，在对象存活率较高时，使用复制收集算法意味着需要进行大量复制，会使效率降低，同时复制大量存活对象到另外一块内存，意味着需要有足够大的内存来保存这些对象，这势必会降低内存使用率。根据老年代的特点，有人提出标记-整理算法，和标记-清除算法不同的是，标记整理算法将存活的对象向一端移动，然后直接清理掉端边界之外的内存。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.分代收集算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　目前商业虚拟机中都使用分代收集算法。一般将Java堆分为新生代和老年代，新生代进行垃圾收集发现有大量对象死去，只有少量对象存活，那么就使用复制算法。老年代中对象存活率较高，使用标记-清除算法或者标记-整理算法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、垃圾收集器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 　　垃圾收集算法提供了内存回收的方法论，垃圾收集器是内存回收的方法论。每个厂商对垃圾收集器的实现不一样，这里主要讨论Jdk1.7 Update 14之后的HotSpot虚拟机。这个虚拟机中包含的垃圾收集器有如下7种：&lt;/p&gt;
&lt;p&gt;                                     &lt;img src=&quot;https://img2018.cnblogs.com/blog/1671546/201904/1671546-20190429213238533-337889854.png&quot; alt=&quot;&quot; width=&quot;447&quot; height=&quot;309&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　以上收集器之间如果有连线，则表明可以搭配使用，虚拟机所处区域，表示他是新生代收集器还是老年代收集器。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.Serial收集器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　Serial收集器是一种最基本的单线程收集器，这种收集器工作时，必须停止其他所有工作线程，优点在于简单高效，但体验很不友好，目前主要应用场合是：虚拟机运行在Client模式下的默认新生代收集。器。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.ParNew收集器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　parNew收集器是Serial收集器的多线程版本，常用参数设置：&lt;/p&gt;
&lt;p&gt;　　 &lt;span class=&quot;cnblogs_code&quot;&gt;-XX:+UseConcMarkSweepGC&lt;/span&gt; ：设置ParNew为默认的新生代收集器；&lt;/p&gt;
&lt;p&gt;　　 &lt;span class=&quot;cnblogs_code&quot;&gt;-XX:+UseParNewGC&lt;/span&gt; ：指定使用ParNew为年轻代收集器，强制指定；&lt;/p&gt;
&lt;p&gt;　　 &lt;span class=&quot;cnblogs_code&quot;&gt;-XX:ParallelGCThreads=n&lt;/span&gt; ：设置收集器的线程数为n。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.Parallel Scavenge收集器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　Parallel Scavenge收集器是一个使用复制算法的新生代收集器，这种收集器的主要目标是达到一个可控制的吞吐量（Throughput，CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)）。由于与吞吐量关系密切，故而Parallel Scavenge收集器也称为“吞吐量优先”收集器。常用参数设置：&lt;/p&gt;
&lt;p&gt;　　 &lt;span class=&quot;cnblogs_code&quot;&gt;-XX:MaxGCPauseMillis=n&lt;/span&gt; ：设置年轻代垃圾收集的最长时间；&lt;/p&gt;
&lt;p&gt;　　 &lt;span class=&quot;cnblogs_code&quot;&gt;-XX:GCTimeRatio=n&lt;/span&gt; ：设置垃圾收集总可用时长的比例，和吞吐量直接相关；&lt;/p&gt;
&lt;p&gt;　　 &lt;span class=&quot;cnblogs_code&quot;&gt;-XX:+UseAdaptiveSizePolicy&lt;/span&gt; 自适应大小开关，配置该选项之后，每次GC后会重新计算 Eden、From 和 To 区的大小，计算依据是 GC 过程中统计的 GC 时间、吞吐量、内存占用量，因此设置此参数之后就不需要再设置 &lt;span class=&quot;cnblogs_code&quot;&gt;-XX:SurvivorRatio&lt;/span&gt; 、 &lt;span class=&quot;cnblogs_code&quot;&gt;-XX:PretenureSizeThreshold&lt;/span&gt; 等参数了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.Serial Old收集器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　Serial收集器的老年版本，也是一个单线程收集器，使用的是“标记-整理”算法，这种收集器的主要意义也是给Client模式下的虚拟机使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5.Parallel Old收集器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　Parallel Old收集器是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge收集器和Parallel Old收集器的组合。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6.CMS收集器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　CMS收集器是一种以获取最短回收停顿时间为目标的收集器。它基于“标记-清除”算法实现，运作过程相对于其他几种收集器更复杂一些。分为以下四个过程：&lt;/p&gt;
&lt;p&gt;　　（1）初始标记（CMS initial mark）：标记一下CG Roots能关联到的对象；&lt;/p&gt;
&lt;p&gt;　　（2）并发标记（CMS concurrent mark）：进行CG Roots Tracing的过程；&lt;/p&gt;
&lt;p&gt;　　（3）重新标记（CMS remark）：修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录。&lt;/p&gt;
&lt;p&gt;　　（4）并发清理（CMS concurrent sweep）&lt;/p&gt;
&lt;p&gt;　　CMS 收集器的优点在于并发收集，低停顿。其缺点在于以下三点：&lt;/p&gt;
&lt;p&gt;　　（1）CMS收集器对CPU很敏感，CMS默认回收线程是（CPU数量+3）/4，当CPU在4个以上时，并发收集时垃圾收集线程不少于25%的CPU资源，并随着CPU数量增加而下降。但是当CPU不足4个时，CMS对用户程序的影响就会变得很大。&lt;/p&gt;
&lt;p&gt;　　（2）CMS收集器无法处理浮动垃圾。由于CMS收集器并发清理阶段用户线程还在运行着，伴随着程序运行就会有垃圾产生，这部分垃圾在标记过后，CMS收集器无法在当次收集中清理这些垃圾。&lt;/p&gt;
&lt;p&gt;　　（3）由于CMS收集器是一种基于“标记-清除”算法的收集器，这种算法实现的收集器在收集结束后会有大量不连续碎片产生。碎片过多时会给大对象分配带来很大麻烦，往往老年代还有很大空间剩余，但是无法找到连续空间分配当前对象，因而不得不提前触发Full GC。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;7.G1收集器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　G1收集器是一款面向服务端应用的垃圾收集器，与其他收集器相比，G1收集器具有如下优点：&lt;/p&gt;
&lt;p&gt;　　（1）并发与并行：G1能充分利用多CPU，多核硬件优势，使用多个CPU来减少停顿时间；&lt;/p&gt;
&lt;p&gt;　　（2）分代收集：G1不需要其他收集器配合就能独立管理整个堆的垃圾收集，且它能采用不同方式去处理新建对象和已经存活了一段时间，熬过多次GC的旧对象以获得更好的收集效果。&lt;/p&gt;
&lt;p&gt;　　（3）空间整合：使用G1收集器不会产生内存碎片，收集后能提供规整的可用内存。这种特性有利于程序长时间运行，分配大对象时候不会因为无法找到连续内存空间而提前触发下一次GC.&lt;/p&gt;
&lt;p&gt;　　（4）可预测的停顿：G1除了追求低停顿，还能建立可预测的停顿时间模型，能让使用着指定在长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不超过N毫秒。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;三、垃圾收集参数总结&lt;/strong&gt;&lt;/p&gt;
&lt;table border=&quot;2&quot;&gt;&lt;tbody readability=&quot;24.5&quot;&gt;&lt;tr&gt;&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td&gt;UseSerialGC&lt;/td&gt;
&lt;td readability=&quot;6&quot;&gt;
&lt;p&gt;虚拟机运行在Client模式下的默认值，打开此开关后，使用Serial+Serial Old的收集器组合进行内存回收&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;UseParNewGC&lt;/td&gt;
&lt;td&gt;打开此开关后，使用ParNew + Serial Old 的收集器组合进行内存回收&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;UseConcMarkSweepGC&lt;/td&gt;
&lt;td&gt;打开此开关后，使用ParNew + CMS + Serial Old 的收集器组合进行内存回收。Serial Old 收集器将作为CMS收集器出现Concurrent Mode Failure失败后的后备收集器使用&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;UseParallelGC&lt;/td&gt;
&lt;td&gt;虚拟机运行在Server 模式下的默认值，打开此开关后，使用Parallel Scavenge + Serial Old（PS MarkSweep）的收集器组合进行内存回收&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;UseParallelOldGC&lt;/td&gt;
&lt;td&gt;打开此开关后，使用Parallel Scavenge + Parallel Old 的收集器组合进行内存回收&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;SurvivorRatio&lt;/td&gt;
&lt;td&gt;新生代中Eden 区域与Survivor 区域的容量比值，默认为8，代表Eden ：Survivor=8∶1&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;PretenureSizeThreshold&lt;/td&gt;
&lt;td&gt;直接晋升到老年代的对象大小，设置这个参数后，大于这个参数的对象将直接在老年代分配&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;MaxTenuringThreshold&lt;/td&gt;
&lt;td&gt;晋升到老年代的对象年龄。每个对象在坚持过一次Minor GC 之后，年龄就加1，当超过这个参数值时就进入老年代&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;UseAdaptiveSizePolicy&lt;/td&gt;
&lt;td&gt;动态调整Java 堆中各个区域的大小以及进入老年代的年龄&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;HandlePromotionFailure&lt;/td&gt;
&lt;td&gt;是否允许分配担保失败，即老年代的剩余空间不足以应付新生代的整个Eden 和Survivor 区的所有对象都存活的极端情况&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;ParallelGCThreads&lt;/td&gt;
&lt;td&gt;设置并行GC 时进行内存回收的线程数&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;GCTimeRatio&lt;/td&gt;
&lt;td&gt;GC 时间占总时间的比率，默认值为99，即允许1% 的GC 时间。仅在使用Parallel Scavenge 收集器时生效&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;MaxGCPauseMillis&lt;/td&gt;
&lt;td&gt;设置GC 的最大停顿时间。仅在使用Parallel Scavenge 收集器时生效&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;CMSInitiatingOccupancyFraction&lt;/td&gt;
&lt;td&gt;设置CMS 收集器在老年代空间被使用多少后触发垃圾收集。默认值为68%，仅在使用CMS 收集器时生效&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;UseCMSCompactAtFullCollection&lt;/td&gt;
&lt;td&gt;设置CMS 收集器在完成垃圾收集后是否要进行一次内存碎片整理。仅在使用CMS 收集器时生效&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;CMSFullGCsBeforeCompaction&lt;/td&gt;
&lt;td&gt;设置CMS 收集器在进行若干次垃圾收集后再启动一次内存碎片整理，仅在使用CMS 收集器时生效&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;参考资料：《深入理解Java虚拟机 JVM高级特性与最佳实践 第2版》&lt;/p&gt;
</description>
<pubDate>Tue, 30 Apr 2019 14:09:00 +0000</pubDate>
<dc:creator>码农大卫</dc:creator>
<og:description>在Java运行时的几个数据区域中，程序计数器，虚拟机栈，本地方法栈3个区域随着线程而生，随线程而灭，因此这几个区域的内存分配和回收具有确定性，不需要过多考虑垃圾回收问题，因为方法结束或者线程结束时，内</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fengweiweicoder/p/10787454.html</dc:identifier>
</item>
<item>
<title>我很喜欢玩游戏，那么我就适合做游戏程序员吗？ - 黄小斜</title>
<link>http://www.cnblogs.com/xll1025/p/10798262.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xll1025/p/10798262.html</guid>
<description>&lt;p&gt;&lt;strong&gt;作者：黄小斜&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文章来源：微信公众号【程序员江湖】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;游戏在今天的普及度已经不是端游时代可以比肩的了。如今人手一台手机、平板就可以吃鸡、打农药，不仅是男生，也有很多女生加入了游戏圈。相信现在在看文章的你也玩游戏，虽然爱玩的程度不同，但是至少都是感兴趣的，当然你也知道，手游行业利润高，游戏程序员自然也吃香，能一边赚钱一边玩游戏，岂不是人生一大幸事呢？其实当年我也是这么想的。&lt;/p&gt;
&lt;h2&gt;为成为游戏程序员而读研&lt;/h2&gt;
&lt;p&gt;大学的时候学的专业和计算机不太沾边，对学的东西不太感兴趣，每天的生活就是上课开黑打游戏，在大学的男生宿舍里，这样的情况确实也比较普遍。恰逢做毕业设计的时候，在课题列表上看到了一个关于“unity3D游戏开发”的课题，我特别感兴趣，于是果断选择了它。当时的水平就是刚刚c语言入门，有多菜可想而知，于是跟着网上的视频撸了一个劣质的《炉石传说》出来，连一局游戏都打不完的那种。&lt;/p&gt;
&lt;p&gt;但是从那时候开始，我就感觉游戏开发确实挺有趣的。这么多年来，国内的游戏大厂也只有腾讯网易两家，网易游戏的游戏研发招聘要求就是至少要985研究生，腾讯虽然没有指定学历要求，但是要求也绝对不低。&lt;/p&gt;
&lt;p&gt;除了学历要求之外，最要命的就是技术要求了，精通C++、精通计算机图形学，最好有游戏引擎经验，对算法等计算机基础课程也要非常熟悉。&lt;/p&gt;
&lt;p&gt;简直和我毫不沾边嘛，好吧，既然我一穷二白，想要翻身的话，不是一时半会能做得到的，就算我挤破头准备一年的校园招聘，可能也离这个要求还很远，于是干脆选择读研，三年后，准备好了再来，也许胜算就比较大了吧。&lt;/p&gt;
&lt;h2&gt;兴趣和职业，有时候要有所取舍&lt;/h2&gt;
&lt;p&gt;刚开始读研的时候，我还一心想着做游戏开发，想着实在不行的话，靠着之前的那些基础，做做Android或者Java也可以吧，于是我的简历上有着各个方向的经验，项目经验既有游戏开发、Android开发，也有Java Web的项目。现在想想是非常可笑的，因为我每个方向都不精，经验也都很水，求职意向不明确，这样的简历在大公司的面试官看来简直就是笑话。&lt;/p&gt;
&lt;p&gt;那时候我还不明白这个道理，只希望自己的求职方向大而全，能够多覆盖几个岗位，每个岗位都投一次简历，广撒网多捞鱼，殊不知投简历最忌讳的就是这个事情，公司找的是能胜任某个岗位的人才，而不是啥都不精的半吊子。还好，没过多久我就明白了这个道理，于是分别做了三个方向的简历，每份简历只写和岗位相关的经历。&lt;/p&gt;
&lt;p&gt;那时候发现一个问题，身边的同学罕有做移动端和游戏开发的，大多数是做Java或者C++后台开发的，除此之外还有一些人做的方向我之前听都没听过，什么机器学习、数据挖掘，这都是我在读研的时候才知道的岗位。后来才发现，这几年这个方向很火，薪资很高，做游戏、移动端的越来越少，也和行业状况有很大的关系。&lt;/p&gt;
&lt;p&gt;当时我还是比较纠结的，是继续做小众的游戏开发或者移动端，找小众的游戏公司，还是做需求量更大的Java方向，去尝试更多的大公司呢。想来想去，游戏大厂就那么两家，反观Java方向能去的互联网公司，BAT、TMD不说，还有很多二线的企业、银行，甚至是国企，这完全是两条路啊，一条是圈子很小，选择很少的游戏程序员路线，一条是机会多，公司多的，很多人也在走的Java程序员路线，考虑到未来的岗位机会、工作机会、职业发展，最终我还是选了后者。&lt;/p&gt;
&lt;h2&gt;再谈选择技术方向的关键因素&lt;/h2&gt;
&lt;p&gt;如今我已经在Java这条路上走了很久了，回顾过去，其实也不知道当初做的这个选择是不是对的，虽然现在也是在一线大厂，但是如果当初还是做游戏开发，现在又会在哪呢，说不准，谁也不知道。&lt;/p&gt;
&lt;p&gt;所以，选择了一个技术方向，可能也意味着你今后要在这条路上走很久，走很远，可能无法回头。就像是选专业一样，大学四年不能白学，专业课不是白上的，很多人虽然不喜欢自己的专业，但是再去尝试其他专业的成本实在太高，所以半推半就也只好接受了不太喜欢的工作。&lt;/p&gt;
&lt;p&gt;选择技术方向，比高考选专业要灵活多了，没有分数要求，也不用权衡学校和专业，只要考虑自己的兴趣、能力、未来发展路线，就可以确定好自己的一个方向。这里不再大谈各个技术方向，因为上次的那篇文章已经讲了够多了，有兴趣的可以回头去看看。&lt;/p&gt;
&lt;p&gt;如今还是有很多同学来问我，怎么选方向，大数据还是Java、Python还是Java、前端还是后端、计算机还是软件。其实你们问我，不如问问自己，到底喜欢什么方向，其实这些岗位都不错，未来也大有可为，大厂的需求也很大，短期看来算法和大数据还是很火，但是前端后端仍然是常青树，测试、运维等岗位需求不算大但是却是进大厂的一种不错方式，游戏开发和移动端虽然没有以前那么火，但是小众的人才更稀缺。&lt;/p&gt;
&lt;p&gt;不管怎么说，选好一个方向，是很重要的，未来你必须在这个方向深挖，积累，成为这个方向的技术专家，这是每一个程序员都需要面对的挑战。&lt;/p&gt;

</description>
<pubDate>Tue, 30 Apr 2019 14:04:00 +0000</pubDate>
<dc:creator>黄小斜</dc:creator>
<og:description>作者：黄小斜 文章来源：微信公众号【程序员江湖】 游戏在今天的普及度已经不是端游时代可以比肩的了。如今人手一台手机、平板就可以吃鸡、打农药，不仅是男生，也有很多女生加入了游戏圈。相信现在在看文章的你也</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xll1025/p/10798262.html</dc:identifier>
</item>
<item>
<title>docker部署Asp.net core应用 - 捞月亮的猴子</title>
<link>http://www.cnblogs.com/wyy1234/p/10747196.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wyy1234/p/10747196.html</guid>
<description>&lt;h2&gt;1 容器概念&lt;/h2&gt;
&lt;p&gt;　　使用Docker前我们首先要简单了解一下容器的概念。MSDN上有一张虚拟机和容器的对比图，很好的展示了虚拟机和容器的区别，如下所示，&lt;span class=&quot;x-hidden-focus&quot; data-ttu-id=&quot;beb4c-132&quot;&gt;虚拟机包括应用程序、必需的库或二进制文件以及完整的来宾操作系统，&lt;strong&gt;每台虚拟机都有一个单独的内核，我们完全可以把虚拟机看做是一台真实的物理机&lt;/strong&gt;。 &lt;span class=&quot;x-hidden-focus&quot; data-ttu-id=&quot;beb4c-133&quot;&gt;&lt;span data-ttu-id=&quot;beb4c-134&quot;&gt;容器包括应用程序及其所有依赖项，&lt;span data-ttu-id=&quot;beb4c-135&quot;&gt;&lt;strong&gt;与其他容器共享 OS 内核&lt;/strong&gt;，容器在主机操作系统上作为独立进程运行，&lt;strong&gt;我们可以把容器看做是一个应用沙盒&lt;/strong&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;x-hidden-focus&quot; data-ttu-id=&quot;beb4c-132&quot;&gt;&lt;span class=&quot;x-hidden-focus&quot; data-ttu-id=&quot;beb4c-133&quot;&gt;&lt;span data-ttu-id=&quot;beb4c-134&quot;&gt;&lt;span data-ttu-id=&quot;beb4c-135&quot;&gt;　　我们经常会遇到“我机器上可以运行”的问题吧，然后部署到其他机器时就遇到了各种坑，这多是因为其他设备上缺少应用所需的环境或者缺少应用的依赖项造成的。使用容器技术可以很好的解决这个问题，容器是一个“应用的沙盒”，这个沙盒内部包含了应用所需的环境和所有依赖项，只要有这个沙盒存在，应用在任何环境下都能正常的运行，容器技术的典型特点就是“一次封装，到处运行”。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1007918/201904/1007918-20190430190652083-1488305705.png&quot; alt=&quot;&quot;/&gt;        &lt;img src=&quot;https://img2018.cnblogs.com/blog/1007918/201904/1007918-20190430190757209-732731161.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　Docker 是一个使用go语言开发的开源的&lt;strong&gt;应用容器引擎&lt;/strong&gt;，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。我们先了解Docker中的三个核心概念：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1  镜像(Image)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　镜像是一种轻量级、可执行的独立软件包，它包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2  容器(Container)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　容器是镜像的运行时实例 ，执行镜像时内存中运行的就是容器。如果把容器看做面向对象中的类，容器就是对象。使用类时通过new来获取一个对象，类似的使用镜像时通过  &lt;span class=&quot;cnblogs_code&quot;&gt;docker run &amp;lt;镜像名/镜像id&amp;gt;&lt;/span&gt; 创建一个容器。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3 仓库(Repository)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　仓库时用来存放镜像的地方，Docker hub是docker官方提供的仓库，类似于githhub,，通过push推送镜像到仓库，通过pull命令拉取镜像。当然我们也可以使用其他仓库，或者自己搭建一个仓库。&lt;/p&gt;
&lt;h2&gt;2 安装docker&lt;/h2&gt;
&lt;h3&gt;1 Windows安装docker&lt;/h3&gt;
&lt;p&gt;　　docker是运行在Linux系统上的，在Windows上使用docker默认要用到Hyper-V功能，所以我们在Windows系统上安装Docker必须先开启Hyper-V功能。首先打开【控制面板】，找到【启动或关闭Windows功能】，然后勾选【Hyper-V】，点击确定即可安装Hyper-V。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1007918/201904/1007918-20190421214947782-1325836123.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 　　安装好Hyper-V后，到docker官网下载Windows版本的docker，docker需要登录账户才能下载，我们可以创建一个账户，牢记这个账号，我们以后会经常用到。docke下载地址：&lt;a href=&quot;https://hub.docker.com/editions/community/docker-ce-desktop-windows&quot; target=&quot;_blank&quot;&gt;docker下载&lt;/a&gt;。下载完成后，双击安装包，一路next即可。安装完成后需要重启电脑，打开命令行，输入 &lt;span class=&quot;cnblogs_code&quot;&gt;docker run hello-world&lt;/span&gt; ，如果出现以下界面，表示docker已经安装成功了。docker run hello-world命令首先会在本地找名字为hello-world的镜像，如果本地不存在这个镜像就会从docker hub上拉取hello-world镜像，然后运行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1007918/201904/1007918-20190421230603239-1388408868.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt; 2 Centos安装docker&lt;/h3&gt;
&lt;p&gt; 　　Linux系统安装常用软件都十分方便，执行下边的命令即可安装docker&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;删除旧版本&lt;/span&gt;
&lt;span&gt;sudo yum remove docker \
                  docker&lt;/span&gt;-&lt;span&gt;client \
                  docker&lt;/span&gt;-client-&lt;span&gt;latest \
                  docker&lt;/span&gt;-&lt;span&gt;common \
                  docker&lt;/span&gt;-&lt;span&gt;latest \
                  docker&lt;/span&gt;-latest-&lt;span&gt;logrotate \
                  docker&lt;/span&gt;-&lt;span&gt;logrotate \
                  docker&lt;/span&gt;-&lt;span&gt;engine
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;安装一些需要的工具&lt;/span&gt;
yum install -y yum-utils device-mapper-persistent-&lt;span&gt;data lvm2
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;添加软件源信息&lt;/span&gt;
sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-&lt;span&gt;ce.repo
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;更新yum缓存&lt;/span&gt;
&lt;span&gt;yum makecache fast
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;安装docker&lt;/span&gt;
yum -y install docker-&lt;span&gt;ce
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;启动docker服务&lt;/span&gt;
&lt;span&gt;systemctl start docker
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;测试docker&lt;/span&gt;
docker run hello-world
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　安装完成后执行 &lt;span class=&quot;cnblogs_code&quot;&gt;docker run hello-world&lt;/span&gt;命令，如果出现下边的界面表示docker安装成功了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1007918/201904/1007918-20190422205551811-105025092.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;3 Docker基本使用&lt;/h2&gt;
&lt;h3&gt;1 使用官方docker实例&lt;/h3&gt;
&lt;p&gt;　　可以查看&lt;a href=&quot;https://docs.docker.com/get-started/&quot; target=&quot;_blank&quot;&gt;官方教程&lt;/a&gt;详细地了解docker的使用，这里我们先用两分钟分钟展示一下微软官方提供的docker栗子，执行命令 &lt;span class=&quot;cnblogs_code&quot;&gt;docker run  -p 8000:80 --name aspnetcore_sample mcr.microsoft.com/dotnet/core/samples:aspnetapp&lt;/span&gt; ，-p 8000:80表示将服务器的8000端口和容器的80端口建立映射，访问服务器8000端口时会去访问容器的80端口。--name设置镜像的名字&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1007918/201904/1007918-20190430202151902-365908913.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　打开浏览器，访问虚拟机的8000端口如下，说明我们的容器已经成功启动了！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1007918/201904/1007918-20190430202556846-318310688.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　我们使用 &lt;span class=&quot;cnblogs_code&quot;&gt;docker images&lt;/span&gt; 和 &lt;span class=&quot;cnblogs_code&quot;&gt;docker container ls&lt;/span&gt; 查看一下本机的容器和镜像，结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1007918/201904/1007918-20190430203143636-2141006732.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2 Docker常用命令&lt;/h3&gt;
&lt;p&gt;　　其实我们实际开发中能用到的docker命令并不多，这里简单汇总一下最常用的docker命令。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;# 查看docker版本和信息&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;查看docker-cli的版本&lt;/span&gt;
docker --&lt;span&gt;version
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;查看docker版本和信息&lt;/span&gt;
&lt;span&gt;docker version
docker info

&lt;/span&gt;&lt;strong&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;# docker镜像相关命令&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;拉取镜像&lt;/span&gt;
&lt;span&gt;docker pull [imgName:tag]
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;运行镜像,执行后会生成一个容器&lt;/span&gt;
docker run [imgName:tag/&lt;span&gt;imgID]
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;查看所有的镜像&lt;/span&gt;
&lt;span&gt;docker images
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;删除镜像 执行rmi命令前必须删除所有该镜像的container&lt;/span&gt;
docker rmi [&lt;span&gt;imgName:tag/imgID] &lt;/span&gt;&lt;strong&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;#docker容器相关命令&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;查看所有的容器，没有-a表示查询所有正在运行中的容器&lt;/span&gt;
docker container ls -&lt;span&gt;a 
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;查看docker正在运行和已经停止的容器&lt;/span&gt;
docker ps -&lt;span&gt;a 
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;启动容器&lt;/span&gt;
docker start [ctnName/&lt;span&gt;cID]
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;停止容器&lt;/span&gt;
docker stop [ctnName/&lt;span&gt;cID]
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;删除容器，执行rm命令前必须先停止该容器&lt;/span&gt;
docke rm [ctnName/&lt;span&gt;cID] 

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;#清理镜像和容器&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;删除所有的镜像和容器&lt;/span&gt;
docker kill $(docker ps -q) ; docker rm $(docker ps -a -q) ; docker rmi $(docker images -q -&lt;span&gt;a)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;删除所有的容器&lt;/span&gt;
docker kill $(docker ps -q) ; docker rm $(docker ps -a -&lt;span&gt;q)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;清除名称为none的镜像&lt;/span&gt;
docker ps -a | grep &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Exited&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; | awk '{print &lt;span&gt;$1&lt;/span&gt; }'|&lt;span&gt;xargs docker stop
docker ps &lt;/span&gt;-a | grep &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Exited&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; | awk '{print &lt;span&gt;$1&lt;/span&gt; }'|&lt;span&gt;xargs docker rm
docker images&lt;/span&gt;|grep none|awk '{print &lt;span&gt;$3&lt;/span&gt; }'|xargs docker rmi
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　有时候我们需要和容器交互，可以使用命令 &lt;span class=&quot;cnblogs_code&quot;&gt;docker exec -it [name/id] common&lt;/span&gt; 。如我们启动一个mysql容器mysqlx1，执行 &lt;span class=&quot;cnblogs_code&quot;&gt;docker exec -it mysqlx1 mysql -p&lt;/span&gt; 表示和容器mysqlx1交互，执行的命令是【mysql -p】进行登录，如下所示。 &lt;span class=&quot;cnblogs_code&quot;&gt;Ctrl +p+q&lt;/span&gt; 退出容器，回到服务器目录。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1007918/201904/1007918-20190422221158707-57987242.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;3 定制容器&lt;/h2&gt;
&lt;p&gt;　　大多数用户使用docker的核心目的是更方便的交付项目，就是将我们的应用程序构建成镜像，然后交付镜像即可，这里演示怎么构建一个Aspnet core项目的镜像。&lt;/p&gt;
&lt;h3&gt;1. 开发aspnet core应用&lt;/h3&gt;
&lt;p&gt;　　我们创建一个Asp net core MVC项目，项目名为DockerDemo，为了方便不勾选Https和Dcoker执行，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1007918/201904/1007918-20190430180134406-177733317.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　简单修改首页，运行一下，测试项目没有bug，运行首页如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1007918/201904/1007918-20190430180419655-966635454.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2 发布项目，添加Dockerfile&lt;/h3&gt;
&lt;p&gt;　　发布项目，然后在发布文件夹下添加Dockerfile文件，结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1007918/201904/1007918-20190430180731825-1338597215.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　Dockerfile的内容如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;拉取runtime父镜像，运行aspnet core应用必须要用runtime&lt;/span&gt;
FROM microsoft/dotnet:2.2-aspnetcore-&lt;span&gt;runtime
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置容器工作目录&lt;/span&gt;
WORKDIR /&lt;span&gt;DockerDemo
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;把当前目录的所有文件copy到工作目录中&lt;/span&gt;
COPY . /&lt;span&gt;DockerDemo
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;暴露一个端口让外部可以访问&lt;/span&gt;
EXPOSE 80
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;容器入口命令，即容器启动时执行dotnet DockerDemo.dll命令&lt;/span&gt;
ENTRYPOINT [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dotnet&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DockerDemo.dll&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　Dockerfile常见指令简单说明&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Dockerfile常用指令：

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;FROM:通常情况下，我们创建的镜像时基于另外一个镜像的，这时就要用FROM，当然我们也可以完全从头创建&lt;/span&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;WORKDIR:设置容器的工作目录&lt;/span&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;MAINTAINER:该镜像的维护人&lt;/span&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;COPY:经常需要把源码复制到容器中，只用COPY就可以实现这一点&lt;/span&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;RUN:这里可以定义一些需要运行的命令，执行的目录是WORKDIR。如npm install ,dotnet restore，dotnet run等&lt;/span&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;ENTRYPOINT:定义容器的入口，通常是一些dotnet/node等命令,如dotnet xxx.dll&lt;/span&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;CMD:设置容器运行的默认命令和参数,即容器启动时执行的命令。当容器运行时，可以通过命令行覆盖CMD定义的命令&lt;/span&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;EXPOSE:暴露端口&lt;/span&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;ENV:设置环境变量&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3 创建镜像&lt;/h3&gt;
&lt;p&gt;　　docker创建镜像很简单，执行 &lt;span class=&quot;cnblogs_code&quot;&gt;docker build -t dockerdemo:v1.&lt;span&gt;0&lt;/span&gt; .&lt;/span&gt; 命令即可创建镜像，其中dockerdemo:v1.0是镜像的名字和版本tag，名字和tag可以随便设置。然后通过 &lt;span class=&quot;cnblogs_code&quot;&gt;docker images&lt;/span&gt; 命令查看所有镜像，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1007918/201904/1007918-20190430153352586-771434037.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;4 运行容器&lt;/h3&gt;
&lt;p&gt; 　使用命令 &lt;span class=&quot;cnblogs_code&quot;&gt;docker run -d -p &lt;span&gt;8080&lt;/span&gt;:&lt;span&gt;80&lt;/span&gt; dockerdemo:v1.&lt;span&gt;0&lt;/span&gt;&lt;/span&gt; 启动容器，-d 表示后台运行，-p 8080：80表示服务器的8080端口映射到容器的80端口，我们也可以使用服务器的其他端口，容器的端口为Dockerfile中Expose的端口。执行 &lt;span class=&quot;cnblogs_code&quot;&gt;docker container ls&lt;/span&gt; 查看容器，这里我们的容器已经启动了，如下：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1007918/201904/1007918-20190430154210543-235795064.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　打开浏览器，输入【服务器IP:服务器端口】接口访问容器，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1007918/201904/1007918-20190430155323666-1649292809.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　到这一步，本地创建镜像和运行容器成功了。&lt;/p&gt;
&lt;h3&gt;5 使用docker hub存储和分发镜像&lt;/h3&gt;
&lt;p&gt;　　docker提供了远程仓库用于存储和分发镜像，其作用类似于github,区别在于github托管代码，而docker hub托管镜像。我们创建好了镜像可以推送(push)到远程仓库，然后在其他设备上拉取(pull)镜像，有了docker hub我们可以更方便的管理和分发镜像。docker hub的使用非常简单，只记住三个命令就可以了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;标记镜像，就是设置远程镜像名和标记&lt;/span&gt;
docker tag  localname:localtag dockeruser/&lt;span&gt;repname:reptag
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;推送镜像文件到docker hub&lt;/span&gt;
docker push username/&lt;span&gt;repname:reptag
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;拉取远程镜像&lt;/span&gt;
&lt;span&gt;docker pull repname:reptag

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;注：localname是本地镜像名   localtag是本地镜像tag&lt;/span&gt;&lt;span&gt;
#   &lt;/span&gt;&lt;span&gt;repname远程仓库的镜像名  reptag是远程仓库的tag&lt;/span&gt;&lt;span&gt;
#   &lt;/span&gt;&lt;span&gt;username是我们的dockerhub用户名&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里将上边创建的本地镜像推动到docker hub。 使用命令 &lt;span class=&quot;cnblogs_code&quot;&gt;docker tag dockerdemo:v1.&lt;span&gt;0&lt;/span&gt; wyyxxx/resdockerdemo:v1.&lt;span&gt;0&lt;/span&gt;&lt;/span&gt; 标记，使用命令 &lt;span class=&quot;cnblogs_code&quot;&gt;docker push wyyxxx/resdockerdemo:v1.&lt;span&gt;0&lt;/span&gt;&lt;/span&gt; 推动镜像到远程仓库，打开 &lt;a href=&quot;https://hub.docker.com&quot; target=&quot;_blank&quot;&gt;镜像仓库&lt;/a&gt;，登陆后就可以看到我们自定义的镜像了，如下所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1007918/201904/1007918-20190430161532262-80696420.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　然后使用另一台安装了docker的服务器，执行命令 &lt;span class=&quot;cnblogs_code&quot;&gt;docker run -p &lt;span&gt;8080&lt;/span&gt;:&lt;span&gt;80&lt;/span&gt; wyyxxx/resdockerdemo:v1.&lt;span&gt;0&lt;/span&gt;&lt;/span&gt; 拉取远程镜像并启动 ，打开浏览器输入地址，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1007918/201904/1007918-20190430170404416-1745371636.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　我们在通过拉取远程镜像并运行容器时，不需要事先部署环境(如安装runtime)等，因为镜像中已经设置了需要的所有环境和依赖资源，只需要使用 &lt;span class=&quot;cnblogs_code&quot;&gt;docker run&lt;/span&gt; 命令运行即可。这也是使用容器交付的方便之处。&lt;/p&gt;
&lt;h2&gt; 4 使用Docker的一点建议&lt;/h2&gt;
&lt;p&gt;① “3C原则”一个容器只运行一个应用&lt;/p&gt;
&lt;p&gt;② 使用镜像交付应用程序，而不是直接部署&lt;/p&gt;
&lt;p&gt;　　如果要在centos上部署一个aspnet core应用程序。错误的做法是：在docker中先安装一个centos系统，在centos系统中部署环境，然后部署我们的netcore应用程序,,最后把部署的应用程序生成镜像。正确的做法是通过Dockerfile定义我们需要的环境和依赖项，然后生成镜像，通过镜像去分发和执行。&lt;/p&gt;
&lt;p&gt;③ 分层构建镜像&lt;/p&gt;
&lt;p&gt;　　还是上边centos部署netcore应用的栗子，如果从零定制镜像时，我们应该把centos作为一层镜像，环境runtime作为一层镜像，最后我们的应用做为一层镜像，使用Dockerfile的FROM 指令拉取父镜像。这样做的好处是节省空间和复用镜像。如上边我们使用了2.2版本的runtime镜像，当我们创建了另一个web应用再来定制镜像时，这两个应用程序镜像可以 共用同一个runtime镜像。&lt;/p&gt;
&lt;p&gt;④ 不要把数据存储在容器中&lt;/p&gt;
&lt;p&gt;　　容器是随时可能销毁的，销毁后容器内部的数据就不存在了，所以最好不要在容器中存储需要持久化的数据。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 30 Apr 2019 12:58:00 +0000</pubDate>
<dc:creator>捞月亮的猴子</dc:creator>
<og:description>1 容器概念 使用Docker前我们首先要简单了解一下容器的概念。MSDN上有一张虚拟机和容器的对比图，很好的展示了虚拟机和容器的区别，如下所示，虚拟机包括应用程序、必需的库或二进制文件以及完整的来宾</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wyy1234/p/10747196.html</dc:identifier>
</item>
</channel>
</rss>