<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>/usr/local/lib/ruby/gems/2.4.0/gems/cocoapods-1.5.3/lib/cocoapods/command.rb:118:in `git_version': Failed to extract git version from `git --version` - longyoung</title>
<link>http://www.cnblogs.com/longyoung/p/11696339.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/longyoung/p/11696339.html</guid>
<description>&lt;h2 id=&quot;问题及分析&quot;&gt;问题及分析&lt;/h2&gt;
&lt;p&gt;今天做项目的时候，执行pod update报了如下错误信息：&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;/usr/local/lib/ruby/gems/2.4.0/gems/cocoapods-1.5.3/lib/cocoapods/command.rb:118:in &lt;code&gt;git_version': Failed to extract git version from&lt;/code&gt;git --version&lt;code&gt;(&quot;xcrun: error: active developer path (\&quot;/Users/feiwei/Desktop/Xcode.app/Contents/Developer\&quot;) does not exist\nUse&lt;/code&gt;sudo xcode-select --switch path/to/Xcode.app&lt;code&gt;to specify the Xcode that you wish to use for command line developer tools, or use&lt;/code&gt;xcode-select --install&lt;code&gt;to install the standalone command line developer tools.\nSee&lt;/code&gt;man xcode-select` for more details.\n&quot;) (RuntimeError)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;粗略一看，应该是找不到git。为什么找不到？首先，有可能没有安装git；其次，可能是关联路径不对。&lt;/p&gt;
&lt;h2 id=&quot;解决方案&quot;&gt;解决方案&lt;/h2&gt;
&lt;p&gt;1.没有安装git&lt;br/&gt;可以在终端执行：xcode-select --install。如果你的电脑系统更新了，有可能这个命令解决不了你的问题，那么，这时候需要到git官网下载安装，下载链接https://git-scm.com/download/mac。&lt;/p&gt;
&lt;p&gt;2.关联路径不对&lt;br/&gt;这个问题可以使用命令：sudo xcode-select --switch /Users/feiwei/Downloads/Xcode.app，其实这个命令就是指定Xcode的安装目录。如果你不知道安装路径，或者不想用命令，Xcode --&amp;gt;Preferences--&amp;gt;Locations并选择Command Line Tools，看看是否选择了当前Xcode版本。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/10/17/16dd997c6ca85e81?w=358&amp;amp;h=301&amp;amp;f=png&amp;amp;s=80166&quot; alt=&quot;步骤一&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/10/17/16dd9995dccc0a57?w=797&amp;amp;h=541&amp;amp;f=png&amp;amp;s=106526&quot; alt=&quot;步骤二&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;0.95505617977528&quot;&gt;
&lt;p&gt;简书：&lt;a href=&quot;https://www.jianshu.com/u/fa72e27b5006&quot; class=&quot;uri&quot;&gt;https://www.jianshu.com/u/fa72e27b5006&lt;/a&gt;&lt;br/&gt;CSDN：&lt;a href=&quot;https://blog.csdn.net/xiaocaoyu111&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/xiaocaoyu111&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/6/6/16b2cce98b78cf59?w=156&amp;amp;h=156&amp;amp;f=png&amp;amp;s=23811&quot; alt=&quot;扫描二维码关注公众号&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PS：本文原创发于微信公众号longyoung，关注并回复「51电子书」免费领取程序员必读经典电子书。&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 18 Oct 2019 00:51:00 +0000</pubDate>
<dc:creator>longyoung</dc:creator>
<og:description>问题及分析 今天做项目的时候，执行pod update报了如下错误信息： /usr/local/lib/ruby/gems/2.4.0/gems/cocoapods 1.5.3/lib/cocoapo</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/longyoung/p/11696339.html</dc:identifier>
</item>
<item>
<title>java23种设计模式（一）工厂方法模式 - 执偕</title>
<link>http://www.cnblogs.com/zhixie/p/11696327.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhixie/p/11696327.html</guid>
<description>&lt;p&gt;在说工厂方法模式之前，先了解一下简单工厂模式。工厂方法模式其实是在简单工厂上面做了一些增强。&lt;br/&gt;&lt;strong&gt;简单工厂模式：有一个专门的类来生产其他类的实例，生产的这些实例有一个共同父类。&lt;/strong&gt;这个跟我们的多态有一点像。&lt;br/&gt;&lt;strong&gt;例子：&lt;/strong&gt;&lt;br/&gt;假如我们有一个鼠标工厂，这个工厂既可以生产联想鼠标，又可以生产宏碁鼠标。&lt;br/&gt;代码如下：&lt;br/&gt;1、鼠标工厂（可以生产联想鼠标和宏碁鼠标）&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class MouseFactory {

    /**
     * 生产一个鼠标
     * @param i
     * @return
     */
     public Mouse createMouse(int i){

        Mouse mouse = null;
        switch (i){
            case 1:
                mouse = new LenovoMouse();
                break;
            case 2:
                mouse = new AcerMouse();
                break;
        }
        return mouse;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、鼠标接口（有一个getName()的方法）&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface Mouse {

    void getName();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3、联想鼠标实现类（实现鼠标接口，可以生产联想鼠标）&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class LenovoMouse implements Mouse {
    @Override
    public void getName() {
        System.out.println(&quot;这个是联想鼠标&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4、宏碁鼠标实现类（实现鼠标接口，可以生产宏碁鼠标）&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class AcerMouse implements Mouse {
    @Override
    public void getName() {
        System.out.println(&quot;这个是宏碁鼠标&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;5、客户端（需要鼠标的人，可以买联想鼠标也可以买宏碁鼠标）&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@SpringBootTest
class FactoryApplicationTests {

    @Test
    void contextLoads() {

        MouseFactory factory = new MouseFactory();
        Mouse mouse = factory.createMouse(2);
        mouse.getName();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样简单工厂就算实现了，可以传入1和2让工厂分别生成联想鼠标和宏碁鼠标。&lt;br/&gt;&lt;strong&gt;接下来我们在简单工厂的基础上看看工厂方法模式。&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;工厂方法模式：定义一个专门生产其他类实例的接口，让子类决定具体生产哪个类的实例。&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;例子：&lt;/strong&gt;&lt;br/&gt;有一个鼠标工厂开了两个子公司，一个是联想鼠标工厂用来专门生产联想鼠标，另一个是宏碁鼠标工厂用来专门生产宏碁鼠标。&lt;br/&gt;代码如下：&lt;br/&gt;1、鼠标工厂接口：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface MouseFactory {

    Mouse createMouse();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、联想鼠标工厂（用来生产联想鼠标）&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class LenovoMouseFactory implements MouseFactory {
    @Override
    public Mouse createMouse() {
        return new LenovoMouse();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3、宏碁鼠标工厂（用来生产宏碁鼠标）&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class AcerMouseFactory implements MouseFactory {
    @Override
    public Mouse createMouse() {
        return new AcerMouse();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;鼠标类跟简单工厂一样，复制如下：&lt;br/&gt;4、鼠标接口（有一个getName()的方法）&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface Mouse {

    void getName();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;5、联想鼠标实现类（实现鼠标接口，可以生产联想鼠标）&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class LenovoMouse implements Mouse {
    @Override
    public void getName() {
        System.out.println(&quot;这个是联想鼠标&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;6、宏碁鼠标实现类（实现鼠标接口，可以生产宏碁鼠标）&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class AcerMouse implements Mouse {
    @Override
    public void getName() {
        System.out.println(&quot;这个是宏碁鼠标&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;7、客户端（需要鼠标的人，可以买联想鼠标也可以买宏碁鼠标）&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@SpringBootTest
class FactoryApplicationTests {
    @Test
    void demo(){

        LenovoMouseFactory lenovoMouseFactory = new LenovoMouseFactory();
        Mouse lenovoMouse = lenovoMouseFactory.createMouse();
        lenovoMouse.getName();

        AcerMouseFactory acerMouseFactory = new AcerMouseFactory();
        Mouse acerMouse = acerMouseFactory.createMouse();
        acerMouse.getName();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以通过不同的工厂来获取不同实例，假如我们想买一个联想鼠标，则去联想工厂买。想买宏碁鼠标，则去宏碁工厂买。&lt;br/&gt;这样，我们就实现了工厂方法模式，假如我们想要一个华硕鼠标，则建一个华硕工厂去生产华硕鼠标即可。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果文章对您有帮助，请记得点赞关注哟~&lt;br/&gt;欢迎大家关注我的公众号&amp;lt;情系IT&amp;gt;，每日技术推送文章供大家学习参考。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 18 Oct 2019 00:47:00 +0000</pubDate>
<dc:creator>执偕</dc:creator>
<og:description>在说工厂方法模式之前，先了解一下简单工厂模式。工厂方法模式其实是在简单工厂上面做了一些增强。 简单工厂模式：有一个专门的类来生产其他类的实例，生产的这些实例有一个共同父类。 这个跟我们的多态有一点像。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhixie/p/11696327.html</dc:identifier>
</item>
<item>
<title>小白学 Python（1）：开篇 - 极客挖掘机</title>
<link>http://www.cnblogs.com/babycomeon/p/11696324.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/babycomeon/p/11696324.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201910/908359-20191018084525500-1466826080.jpg&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;人生苦短，我用 Python&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;引言&quot;&gt;引言&lt;/h2&gt;
&lt;p&gt;大家好，可能大家都对我比较熟悉了，不熟悉请去面壁（现在熟悉一下也来得及）~&lt;/p&gt;
&lt;p&gt;简单做一个自我介绍，我是极客挖掘机的唯一作者，一位油腻的 Java 程序员【臭鸡蛋什么的先放放，等我打个伞先&lt;/p&gt;
&lt;p&gt;啊喂~ 你的自我介绍就一句话啊？？？&lt;/p&gt;
&lt;p&gt;我乐意，要么你来咬我&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201910/908359-20191018084525843-760242185.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;虽然我精通有关 Java 的十八般武艺，但是我现在是在写 Python 的连载教程啊，好像没个 P 用&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201910/908359-20191018084526137-1669899335.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;说个你可能不知道事情，今年（2019年）Python 已经高龄 28 岁，是不是吃了一惊，万万没想到，Python 可能比在座的各位年龄都大。可是还是没我大（一脸傲娇）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201910/908359-20191018084526277-246892926.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如今，Python 已经是必须了解的编程语言了，Python 在爬虫、机器学习等领域的优势越来越明显。&lt;/p&gt;
&lt;p&gt;并且北京和山东已经确定要把Python编程基础纳入信息技术课程和高考的内容体系。尤其山东省最新出版的小学信息技术六年级教材也加入了Python内容，小学生都开始接触Python语言了！！&lt;/p&gt;
&lt;p&gt;你要是再不学，以后可能真的连小学生都打不过了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201910/908359-20191018084526412-1934147615.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那你还不赶紧关注我，跟我一起学。&lt;/p&gt;
&lt;p&gt;我不是 Python 大牛，但是我乐于分享啊，大家可以每天抽出来几分钟，看我 XBB 几句，指不定各位骨骼清奇，就打通任督二脉了，从此走上人生巅峰（苟富贵，勿相忘）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201910/908359-20191018084526575-82725938.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;环境搭建&quot;&gt;环境搭建&lt;/h2&gt;
&lt;p&gt;目前 Python 2 官方已经宣布在 2020 年停止支持，什么，你就要学 Python 2 ，出门左转不送。&lt;/p&gt;
&lt;p&gt;在 windows 上构建 Python 的环境还是十分简单的，访问 Python 的官方网站（&lt;a href=&quot;https://www.python.org/&quot; class=&quot;uri&quot;&gt;https://www.python.org/&lt;/a&gt; ），发挥我小学的英文水平，找到 DownLoad ，点一下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201910/908359-20191018084530051-230868063.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在第二页选择适合自己系统的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201910/908359-20191018084530353-604248025.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;小编是的电脑是 win10 ，所以选择了红框中的这个版本，再点一下，开始下载，如果嫌慢的话可以使用迅雷下载（你们谁跟迅雷讲一下回头记得给我广告费）&lt;/p&gt;
&lt;p&gt;下载完成后是一个 exe 文件，直接双击安装就好了，有需要的可以修改下安装路径，虽然是英文版的，但是操作也很简单，一路 next 到底就好了，安装成功后可以打开 cmd 或者 powershell 命令行输入以下命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;python --version&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行后应该出现目前安装的 Python 版本信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201910/908359-20191018084530511-505569697.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，安装的版本是 3.7.4 ，和我们刚才下载的版本吻合【废话&lt;/p&gt;
&lt;p&gt;开发工具可以选用 jetbrains 提供的 PyCharm 或者是微软提供的 VSCode 。&lt;/p&gt;
&lt;p&gt;小编以 PyCharm 为例介绍如何构建（因为简单啊，VSCode 还要装好几个插件才能用，我这么懒，才不要讲）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201910/908359-20191018084530665-501132027.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;去官网下载（&lt;a href=&quot;https://www.jetbrains.com/zh/pycharm/promo/?utm_source=baidu&amp;amp;utm_medium=cpc&amp;amp;utm_campaign=cn-bai-br-pycharm-ex-pc&amp;amp;utm_content=pycharm-pure&amp;amp;utm_term=pycharm&quot; class=&quot;uri&quot;&gt;https://www.jetbrains.com/zh/pycharm/promo/?utm_source=baidu&amp;amp;utm_medium=cpc&amp;amp;utm_campaign=cn-bai-br-pycharm-ex-pc&amp;amp;utm_content=pycharm-pure&amp;amp;utm_term=pycharm&lt;/a&gt; ）&lt;/p&gt;
&lt;p&gt;下载完成后同样一路下一步到底，至此，Python 开发环境搭建完成。&lt;/p&gt;
&lt;h2 id=&quot;hello-world&quot;&gt;Hello World&lt;/h2&gt;
&lt;p&gt;环境搭建完成一定要写一个 &lt;code&gt;Hello World&lt;/code&gt; ，这不仅仅是程序员的信仰，同时也是对一门开发语言的尊重&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201910/908359-20191018084530821-1436770275.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;怀着崇敬的心情双击 Pycharm 图标，这时会弹出来一个框，让我们选择代码存放的路径，这个看个人习惯，随便放个地方，路径一定要记住，不然下次开机会找不到的。&lt;/p&gt;
&lt;p&gt;然后点开下面的小箭头，这个是选择编译器，刚才我们已经安装过了，直接选择现有的编译器。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201910/908359-20191018084531225-2145741680.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击唯一的按钮 Create ，稍等一会，人生中第一个 Python 工程就创建好了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201910/908359-20191018084531653-1532151658.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;创建一个 Python 的可执行文件，名字就叫 HelloWorld 就 ok 。&lt;/p&gt;
&lt;p&gt;现在开始写代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;print('Hello World')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;写好后点击右键，选择 run 或者 debug 都行&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201910/908359-20191018084532027-2130152580.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到 PyCharm 的控制台正常打印 &lt;code&gt;Hello World&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201910/908359-20191018084532442-916129443.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;恭喜，第一个 Python 程序已经成功运行。&lt;/p&gt;
&lt;h2 id=&quot;示例代码&quot;&gt;示例代码&lt;/h2&gt;
&lt;p&gt;本系列的所有代码小编都会放在代码管理仓库 Github 和 Gitee 上，方便大家取用。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/meteor1993/python-learning/tree/master/hello-world&quot; title=&quot;示例代码-Github&quot;&gt;示例代码-Github&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/inwsy/python-learning/tree/master/hello-world&quot; title=&quot;示例代码-Gitee&quot;&gt;示例代码-Gitee&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 18 Oct 2019 00:46:00 +0000</pubDate>
<dc:creator>极客挖掘机</dc:creator>
<og:description>人生苦短，我用 Python 引言 大家好，可能大家都对我比较熟悉了，不熟悉请去面壁（现在熟悉一下也来得及）~ 简单做一个自我介绍，我是极客挖掘机的唯一作者，一位油腻的 Java 程序员【臭鸡蛋什么的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/babycomeon/p/11696324.html</dc:identifier>
</item>
<item>
<title>python常用算法学习（4）——数据结构 - 战争热诚</title>
<link>http://www.cnblogs.com/wj-1314/p/11574277.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wj-1314/p/11574277.html</guid>
<description>&lt;h2&gt;数据结构简介&lt;/h2&gt;
&lt;h3&gt;1，数据结构&lt;/h3&gt;
&lt;p&gt;　　数据结构是指相互之间存在着一种或多种关系的数据元素的集合和该集合中数据元素之间的关系组成。简单来说，数据结构就是设计数据以何种方式组织并存贮在计算机中。比如：列表，集合与字典等都是一种数据结构。而之前已经学习过列表，字典，集合，元组等，这里就简单说一下不再赘述。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;N.Wirth：“程序=数据结构+算法”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　数据&lt;/strong&gt;：&lt;span&gt;数据即信息的载体，是能够输入到计算机中并且能被计算机识别，存储和处理的符号总称。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　数据元素&lt;/strong&gt;：数据元素是数据的基本单位，又称之为记录（Record），一般，数据元素若由若干基本型（或称字段，域，属性）组成。&lt;/p&gt;
&lt;h3&gt;2，数据结构的分类&lt;/h3&gt;
&lt;p&gt;　　数据结构按照其逻辑结构可分为线性结构，树结构，图结构&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;线性结构：数据结构中的元素存在一对一的相互关系&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;树结构：数据结构中的元素存在一对多的相互关系&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;图结构：数据结构中的元素存在多对多的相互关系&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;3，存储结构&lt;/h3&gt;
&lt;h4&gt;1，特点&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;1，是数据的逻辑结构在计算机存储器中的映象（或表示）&lt;/li&gt;
&lt;li&gt;2，存储结构是通过计算机程序来实现，因而是依赖于具体的计算机语言的&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;2，存储结构分类&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;1，顺序存储（Sequential Storage）：将数据结构中各元素按照其逻辑顺序存放于存储器一片连续的存储空间中。&lt;/li&gt;
&lt;li&gt;2，链式存储（Linkend Storage）：将数据结构中各元素分布到存储器的不通电，用记录下一个结点位置的方式建立他们之间的联系，由此得到的存储结构为链式存储结果。&lt;/li&gt;
&lt;li&gt;3，索引存储（Indexed Storage）：在存储数据的同时，建立一个附加的索引表，即索引存储结构=数据文件+索引表。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;常用的数据结构&lt;/h2&gt;
&lt;h3&gt;1，列表&lt;/h3&gt;
&lt;p&gt;　　&lt;strong&gt;列表（其他语言称为数组，但是数组和Python的列表还是有区别的）是一种基本数据类型。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　列表，在Python中称为list，使用中括号包含，其中内部元素使用逗号分隔，内部元素可以是任何类型包含空。&lt;/strong&gt;&lt;/p&gt;
&lt;h4&gt;1.1 数组和列表不同点&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;1，数组元素类型要相同，而Python列表不需要&lt;/li&gt;
&lt;li&gt;2，数组长度固定，而Python列表可以增加&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　Python列表操作方法请参考此博客：&lt;a href=&quot;https://www.cnblogs.com/wj-1314/p/8433116.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/wj-1314/p/8433116.html&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;2，元组&lt;/h3&gt;
&lt;p&gt;　　元组，Python中类为tuple。使用小括号包含，内部元素使用逗号分隔，可为任意值。与列表不同之处为，其内部元素不可修改，而且不能做删除，更新操作。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;注意：当元组中元素只有一个时，结尾要加逗号，若不加逗号，Python解释器都将解释成元素本身的类型，而非元组类型。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　举个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&amp;gt;&amp;gt;&amp;gt; a = (1,2,3)
&amp;gt;&amp;gt;&amp;gt; b = ('1',[2,3])
&amp;gt;&amp;gt;&amp;gt; c = ('1','2',(3,4))
&amp;gt;&amp;gt;&amp;gt; d = ()
&amp;gt;&amp;gt;&amp;gt; e = (1,)
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;2.1  元组的操作&lt;/h4&gt;
&lt;p&gt;　　通过下标操作&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;通过小标来获取元素值，使用方法同列表&lt;/li&gt;
&lt;li&gt;切片的处理，使用方法同列表&lt;/li&gt;
&lt;li&gt;不可通过下标做删除和更新操作&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　　如下，做出更改和删除会报异常：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&amp;gt;&amp;gt;&amp;gt; c[0] = 1
Traceback (most recent call last):
  File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;
TypeError: 'tuple' object does not support item assignment

&amp;gt;&amp;gt;&amp;gt; del c[0]
Traceback (most recent call last):
  File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;
TypeError: 'tuple' object doesn't support item deletion
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;2.2  运算符及内建函数操作&lt;/h4&gt;
&lt;p&gt;　　元组本身是不可变，但是可以通过 + 来构成新的元组。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&amp;gt;&amp;gt;&amp;gt; a
(1, 2, 3)
&amp;gt;&amp;gt;&amp;gt; b
('1', [2, 3])
&amp;gt;&amp;gt;&amp;gt; a + b
(1, 2, 3, '1', [2, 3])
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　可以通过使用内建函数 len 获取元组长度，可以使用 * 元素来实现元素的重复&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&amp;gt;&amp;gt;&amp;gt; a = (1,2,3)
&amp;gt;&amp;gt;&amp;gt; len(a)
3
&amp;gt;&amp;gt;&amp;gt; a*3
(1, 2, 3, 1, 2, 3, 1, 2, 3)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　元组也支持 in  和 not in  成员运算符。&lt;/p&gt;
&lt;h3&gt;3，集合&lt;/h3&gt;
&lt;p&gt;　　集合用于包含一组无序的对象，与列表和元组不同，集合是无序的，也无法通过数字进行索引。此外，集合中的元素不能重复。set和dict一样，只是没有 value，相当于 dict 的 key 集合，由于 dict 的 key 是不重复的，且 key 是不可变对象，因此 set 有如下特性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;1，不重复，（互异性），也就是说集合是天生去重的&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;2，元素为不可变对象，（确定性，元素必须可 hash）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;3，集合的元素没有先后之分，（无序性） &lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　Python的集合与数学中的集合一样，也有交集，并集和合集。&lt;/p&gt;
&lt;p&gt;　　举例如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;48&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&amp;gt;&amp;gt;&amp;gt; s1 = {1,2,3,4,5}
&amp;gt;&amp;gt;&amp;gt; s2 = {1,2,3}
&amp;gt;&amp;gt;&amp;gt; s3 = {4,5}
&amp;gt;&amp;gt;&amp;gt; s1&amp;amp;s2   # 交集
{1, 2, 3}
&amp;gt;&amp;gt;&amp;gt; s1|s2   # 并集
{1, 2, 3, 4, 5}  
&amp;gt;&amp;gt;&amp;gt; s1 - s2  # 差差集
{4, 5}
&amp;gt;&amp;gt;&amp;gt; s3.issubset(s1)   # s3 是否为s1 的子集
True
&amp;gt;&amp;gt;&amp;gt; s1.issuperset(s2)  # s1 是否为 s2 的超集
True
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　更多集合相关的操作参考博客：&lt;a href=&quot;https://www.cnblogs.com/wj-1314/p/8423273.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/wj-1314/p/8423273.html&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;4，栈&lt;/h3&gt;
&lt;p&gt;　　栈（Stack）是一个数据集合，可以理解为只能在一段进行插入或删除操作的列表。&lt;/p&gt;
&lt;p&gt;　　栈的特点：后进先出 LIFO（Last-in， First-out）&lt;/p&gt;
&lt;p&gt;　　栈的概念有：栈顶，栈底&lt;/p&gt;
&lt;p&gt;　　栈的基本操作：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;进栈（压栈）：push&lt;/li&gt;
&lt;li&gt;出栈：pop&lt;/li&gt;
&lt;li&gt;取栈顶：gettop&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt; 　　对栈的理解，就像是一摞书，只能从上面放和取。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201910/1226410-20191007083220115-1882188810.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;4.1  栈的实现&lt;/h4&gt;
&lt;p&gt;　　使用一般列表结构即可实现栈：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;进栈：li.append&lt;/li&gt;
&lt;li&gt;出栈：li.pop&lt;/li&gt;
&lt;li&gt;取栈顶：li[-1]&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt; 　　那现在我们写一个类实现它：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
class Stack:

    def __init__(self):
        self.stack = []

    def push(self, element):
        self.stack.append(element)

    def pop(self):
        # 移除列表中的一个元素（默认最后一个），并返回该元素的值
        return self.stack.pop()

    def get_top(self):
        if len(self.stack) &amp;gt; 0:
            return self.stack[-1]
        else:
            return None

stack = Stack()
stack.push(1)
stack.push(2)
print(stack.pop())   # 2
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;4.2  栈的应用——括号匹配问题&lt;/h4&gt;
&lt;p&gt;　　我们可以通过栈来解决括号匹配的问题，就是解决IDE实现括号未匹配成功报错的问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201910/1226410-20191008191646538-1261557926.png&quot; alt=&quot;&quot; width=&quot;467&quot; height=&quot;170&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
class Stack:

    def __init__(self):
        self.stack = []

    def push(self,element):
        return self.stack.append(element)

    def pop(self):
        return self.stack.pop()

    def get_top(self):
        if len(self.stack) &amp;gt; 0:
            return self.stack[-1]
        else:
            return None

    def is_empty(self):
        return len(self.stack) == 0

def brace_match(s):
    match = {'}': '{', ']': '[', ')': '('}
    stack = Stack()
    for ch in s:
        if ch in {'(', '[', '{'}:
            stack.push(ch)
        else:
            if stack.is_empty():
                return False
            elif stack.get_top() == match[ch]:
                stack.pop()
            else:
                return False

    if stack.is_empty():
        return True
    else:
        return False

print(brace_match('{[{()}]}'))
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;5，队列&lt;/h3&gt;
&lt;p&gt;　　队列（Queue）是一个数据集合，仅允许在列表的一端进行插入，另一端进行删除。进行插入的一端称为队尾（rear），插入动作称为进队或者入队。进行删除的一端称为对头（front），删除动作称为出队。&lt;/p&gt;
&lt;p&gt;　　队列的性质：先进先出（First-in ,  First-out）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201910/1226410-20191008192405732-1359399806.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　队列可以并发的派多个线程，对排列的线程处理，并切每个需要处理线程只需要将请求的数据放入队列容器的内存中，线程不需要等待，当排列完毕处理完数据后，线程在准时来取数据即可，请求数据的线程只与这个队列容器存在关系，处理数据的线程down掉不会影响到请求数据的线程，队列会派给其他线程处理这份数据，它实现了解耦，提高效率。队列内会有一个顺序的容器，列表与这个容器是有区别的，列表中数据虽然是排列的，但数据被取走后还会保留，而队列中这些容器的数据被取后将不会保留。当必须在多个线程之间安全的交换信息时，队列在线程编程中特别有用。&lt;/p&gt;
&lt;h4&gt;5.1  队列的实现&lt;/h4&gt;
&lt;p&gt;　　队列能否用列表简单实现？为什么？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201910/1226410-20191008192729518-2037940073.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;环形队列的实现方式&lt;/h4&gt;
&lt;p&gt;　　环形队列：当队尾指针 front == MaxSize + 1 时，再前进一个位置就自动到0。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;队首指针前进1： front = (front + 1) % MaxSize&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;队尾指针前进1： rear = (rear + 1) % MaxSize&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;队空条件： front ==  rear&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;队满条件： (rear + 1) % MaxSize ==  front&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; &lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201910/1226410-20191016115703537-124813351.png&quot; alt=&quot;&quot; width=&quot;404&quot; height=&quot;258&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
class Queue:

    def __init__(self, size):
        self.queue = [0 for _ in range(size)]
        self.size = size
        self.rear = 0  # 队尾指针是进队的
        self.front = 0  # 对首指针是出队的

    def push(self, element):
        if not self.is_filled():
            rear = (self.rear + 1) % self.size
            self.queue[self.rear] = element
        else:
            raise IndexError(&quot;Queue is filled&quot;)

    def pop(self):
        if not self.is_empty():
            self.front = (self.front + 1) % self.size
            return self.queue[self.front]
        else:
            raise IndexError(&quot;Queue is empty&quot;)

    # 判断队空
    def is_empty(self):
        return self.rear == self.front

    # 判断队满
    def is_filled(self):
        return (self.rear + 1) % self.size == self.front

q = Queue(5)
for i in range(4):
    q.push(i)

print(q.pop())
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201910/1226410-20191017092035089-468547927.png&quot; alt=&quot;&quot; width=&quot;523&quot; height=&quot;270&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
from collections import deque

q = deque()
q.append(1)  # 队尾进队
print(q.popleft())  # 对首出队

# 用于双向队列
q.appendleft(1)  # 队首进队
print(q.pop())   #队尾出队
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;&lt;span&gt;&lt;strong&gt;双向队列的完整用法&lt;/strong&gt;&lt;/span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;114&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
# _*_coding:utf-8_*_

# 创建双向队列
from collections import deque

d = deque()

# append（往右边添加一个元素）
d.append(1)
d.append(2)
print(d)  # deque([1, 2])

# appendleft（往左边添加一个元素）
d.appendleft(11)
d.appendleft(22)
print(d)  # deque([22, 11, 1, 2])

# clear清空队列
d.clear()
print(d)  # deque([])

# 浅copy copy
d.append(1)
new_d = d.copy()
print(new_d)  # deque([1])

#  count(返回指定元素的出现次数)
d.append(1)
d.append(1)
print(d)  # deque([1, 1, 1])
print(d.count(1))  # 3

# extend(从队列右边扩展一个列表的元素)
d.append(2)
d.extend([3, 4, 5])
print(d)  # deque([1, 1, 1, 2, 3, 4, 5])

# extendleft(从队列左边扩展一个列表的元素)
d.extendleft([3, 4, 5])
print(d)  # deque([5, 4, 3, 1, 1, 1, 2, 3, 4, 5])

#  index（查找某个元素的索引位置）
d.clear()
d.extend(['a', 'b', 'c', 'd', 'e'])
print(d)
print(d.index('e'))
print(d.index('c', 0, 3))  # 指定查找区间
'''
deque(['a', 'b', 'c', 'd', 'e'])
4
2
'''

#  insert（在指定位置插入元素）
d.insert(2, 'z')
print(d)
# deque(['a', 'b', 'z', 'c', 'd', 'e'])

# pop（获取最右边一个元素，并在队列中删除）
x = d.pop()
print(x)
print(d)
'''
e
deque(['a', 'b', 'z', 'c', 'd'])
'''

# popleft（获取最左边一个元素，并在队列中删除）
print(d)
x = d.popleft()
print(x)
print(d)
'''
deque(['a', 'b', 'z', 'c', 'd'])
a
deque(['b', 'z', 'c', 'd'])
'''

# remove（删除指定元素）
print(d)
d.remove('c')
print(d)
'''
deque(['b', 'z', 'c', 'd'])
deque(['b', 'z', 'd'])
'''

# reverse（队列反转）
print(d)
d.reverse()
print(d)
'''
deque(['b', 'z', 'd'])
deque(['d', 'z', 'b'])
'''

# rotate（把右边元素放到左边）
d.extend(['a', 'b', 'c', 'd', 'e'])
print(d)
d.rotate(2)  # 指定次数，默认1次
print(d)
'''
deque(['d', 'z', 'b', 'a', 'b', 'c', 'd', 'e'])
deque(['d', 'e', 'd', 'z', 'b', 'a', 'b', 'c'])
'''
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;Python四种类型的队列&lt;/h4&gt;
&lt;p&gt;　　Queue：FIFO 即 first in first out  先进先出&lt;/p&gt;
&lt;p&gt;　　LifoQueue：LIFO 即 last in first out   后进先出&lt;/p&gt;
&lt;p&gt;　　PriorityQueue：优先队列，级别越低，越优先&lt;/p&gt;
&lt;p&gt;　　deque：双边队列&lt;/p&gt;
&lt;p&gt;导入三种队列，包&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
from queue import Queue,LifoQueue,PriorityQueue
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;Queue：先进先出队列&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
#基本FIFO队列  先进先出 FIFO即First in First Out,先进先出
#maxsize设置队列中，数据上限，小于或等于0则不限制，容器中大于这个数则阻塞，直到队列中的数据被消掉
q = Queue(maxsize=0)

#写入队列数据
q.put(0)
q.put(1)
q.put(2)

#输出当前队列所有数据
print(q.queue)
#删除队列数据，并返回该数据
q.get()
#输也所有队列数据
print(q.queue)

# 输出:
# deque([0, 1, 2])
# deque([1, 2])
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;LifoQueue：后进先出队列：&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
#LIFO即Last in First Out,后进先出。与栈的类似，使用也很简单,maxsize用法同上
lq = LifoQueue(maxsize=0)

#队列写入数据
lq.put(0)
lq.put(1)
lq.put(2)

#输出队列所有数据
print(lq.queue)
#删除队尾数据，并返回该数据
lq.get()
#输出队列所有数据
print(lq.queue)

#输出:
# [0, 1, 2]
# [0, 1]
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;优先队列&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
# 存储数据时可设置优先级的队列
# 优先级设置数越小等级越高
pq = PriorityQueue(maxsize=0)

#写入队列，设置优先级
pq.put((9,'a'))
pq.put((7,'c'))
pq.put((1,'d'))

#输出队例全部数据
print(pq.queue)

#取队例数据，可以看到，是按优先级取的。
pq.get()
pq.get()
print(pq.queue)

#输出：
[(9, 'a')]
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;双边队列&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
#双边队列
dq = deque(['a','b'])

#增加数据到队尾
dq.append('c')
#增加数据到队左
dq.appendleft('d')

#输出队列所有数据
print(dq)
#移除队尾，并返回
print(dq.pop())
#移除队左，并返回
print(dq.popleft())
#输出:
deque(['d', 'a', 'b', 'c'])
c
d
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;6，链表&lt;/h3&gt;
&lt;p&gt;　　当我们存储一大波数据时，我们很多时候是使用数组，但是当我们执行插入操作的时候就是非常麻烦，比如，有一堆数据1,2,3,5,6,7 我们要在3和5之间插入4，如果用数组，我们会怎么办？当然是将5之后的数据往后退一位，然后再插入4，这样非常麻烦，但是如果用链表，就直接在3和5之间插入4即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201910/1226410-20191016114918966-226976596.png&quot; alt=&quot;&quot; width=&quot;574&quot; height=&quot;191&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　所以链表的节点结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201910/1226410-20191005183406960-506304163.png&quot; alt=&quot;&quot; width=&quot;205&quot; height=&quot;63&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　data为自定义的数据，next为下一个节点的地址。head保存首位节点的地址。&lt;/p&gt;
&lt;p&gt; 　　首先可以看一个小链表，定义链表：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
class Node:
    def __init__(self, item):
        self.item = item
        self.next = None

a = Node(1)
b = Node(2)
c = Node(3)
# 通过next 将 a,b,c联系起来
a.next = b
b.next = c
# 打印a的下一个的下一个结果是什么
print(a.next.next.item) # 3
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　当然，我们不可能这样next来调用链表，使用循环等，下面继续学习。&lt;/p&gt;
&lt;p&gt;　　链表永远有一个头结点，head&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201910/1226410-20191016114956388-340357382.png&quot; alt=&quot;&quot; width=&quot;542&quot; height=&quot;239&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　头插法和尾插法的代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;54&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
class Node:
    def __init__(self, item):
        self.item = item
        self.next = None

# 头插法
# 这里我们使用 li 进行循环插入
def create_linklist_head(li):
    head = Node(li[0])
    for element in li[1:]:
        node = Node(element)
        node.next = head  # 将头结点 给刚插入的节点
        head = node       # 然后将插入的节点设置为头结点
    return head

# 尾插法
def create_linklist_tail(li):
    head = Node(li[0])
    tail = head
    for element in li[1:]:
        node = Node(element)
        tail.next = node
        tail = node
    return head

def print_linklist(lk):
    while lk:
        print(lk.item, end=',')
        lk = lk.next
    print('*********')

lk = create_linklist_head([1, 2, 3, 4])
# print(lk.item)  # 4
print_linklist(lk)  # 4,3,2,1,*********

lk = create_linklist_tail([1, 2, 3, 4, 5])
print_linklist(lk)  # 1,2,3,4,5,
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201910/1226410-20191005155701178-633510201.png&quot; alt=&quot;&quot; width=&quot;394&quot; height=&quot;392&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201910/1226410-20191005163334101-234559946.png&quot; alt=&quot;&quot; width=&quot;534&quot; height=&quot;215&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　插入如下，非常简单，所以时间复杂度也低。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201910/1226410-20191005163616618-1394351188.png&quot; alt=&quot;&quot; width=&quot;401&quot; height=&quot;175&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201910/1226410-20191005163729372-610811215.png&quot; alt=&quot;&quot; width=&quot;539&quot; height=&quot;214&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;6.1  关于链表的方法&lt;/h4&gt;
&lt;h4&gt;　　1，判断是否为空：isEmpty()&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
def isEmpty(self):
    return (self.length == 0)
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;　　2，增加一个节点（在链表尾添加）：append()&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
def append(self, dataOrNode):
    item = None
    if isinstance(dataOrNode, Node):
        item = dataOrNode
    else:
        item = Node(dataOrNode)
    
    if not self.head:
        self.head = item
        self.length += 1
    else:
        node = self.head
        while node._next:
            node = node._next
        node._next = item
        self.length += 1
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;　　3，删除一个节点：delete()&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
# 删除一个节点之后，记得把链表长度减一
def delete(self, index):
    if self.isEmpty():
        print(&quot;this chain table is empty&quot;)
        return

    if index &amp;lt; 0 or index &amp;gt;= self.length:
        print('Error: out of index')
        return

    # 要注意删除第一个节点的情况，如果有空的头节点就不用这样
    if index == 0:
        self.head = self.head._next
        self.length -= 1
        return

    # prev 为保存前导节点
    # node 为保存当前节点
    # 当j 与index 相等时就相当于找到要删除的节点
    j = 0
    node = self.head
    prev = self.head
    while node._next and j &amp;lt; index:
        prev = node
        node = node._next
        j += 1
    
    if j == index:
        prev._next = node._next
        self.length -= 1　
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;　　4，修改一个节点：update()&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
def update(self, index, data):
    if self.isEmpty() or index &amp;lt; 0 or index &amp;gt;= self.length:
        print 'error: out of index'
        return
    j = 0
    node = self.head
    while node._next and j &amp;lt; index:
        node = node._next
        j += 1

    if j == index:
        node.data = data
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;　　5，查找一个节点：getItem()&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
def getItem(self, index):
    if self.isEmpty() or index &amp;lt; 0 or index &amp;gt;= self.length:
        print &quot;error: out of index&quot;
        return
    j = 0
    node = self.head
    while node._next and j &amp;lt; index:
        node = node._next
        j += 1

    return node.data　
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;　　6，查找一个节点的索引：getIndex()&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
def getIndex(self, data):
    j = 0
    if self.isEmpty():
        print &quot;this chain table is empty&quot;
        return
    node = self.head
    while node:
        if node.data == data:
            return j
        node = node._next
        j += 1

    if j == self.length:
        print &quot;%s not found&quot; % str(data)
        return
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;　　7，插入一个节点：insert()&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
def insert(self, index, dataOrNode):
    if self.isEmpty():
        print &quot;this chain tabale is empty&quot;
        return

    if index &amp;lt; 0 or index &amp;gt;= self.length:
        print &quot;error: out of index&quot;
        return

    item = None
    if isinstance(dataOrNode, Node):
        item = dataOrNode
    else:
        item = Node(dataOrNode)

    if index == 0:
        item._next = self.head
        self.head = item
        self.length += 1
        return

    j = 0
    node = self.head
    prev = self.head
    while node._next and j &amp;lt; index:
        prev = node
        node = node._next
        j += 1

    if j == index:
        item._next = node
        prev._next = item
        self.length += 1
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;　　8，清空链表：clear()&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
def clear(self):
    self.head = None
    self.length = 0
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;6.2  双链表&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201910/1226410-20191016171918965-1079850547.png&quot; alt=&quot;&quot; width=&quot;503&quot; height=&quot;186&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201910/1226410-20191016171951401-1276176201.png&quot; alt=&quot;&quot; width=&quot;430&quot; height=&quot;183&quot;/&gt;&lt;/p&gt;

&lt;h4&gt; 6.3  链表复杂度分析&lt;/h4&gt;
&lt;p&gt;　　顺序表（列表/数组）与链表&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;按照元素值查找&lt;/li&gt;
&lt;li&gt;按下标查找&lt;/li&gt;
&lt;li&gt;在某元素后插入&lt;/li&gt;
&lt;li&gt;删除某元素&lt;/li&gt;
&lt;/ol&gt;&lt;h4&gt;&lt;span&gt;　  链表与顺序表&lt;br/&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;链表在插入和删除的操作上明显快于顺序表&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;链表的内存可以更加灵活地分配（可以试利用链表重新实现栈和队列）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;链表这种链式存储的数据结构对树和图的结构有很大的启发性&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;7，哈希表（Hash table）&lt;/h3&gt;
&lt;p&gt;　　众所周知，HashMap是一个用于存储 Key-Value键值对的集合，每一个键值对也叫Entry，这些键值对（Entry）分散存储在一个数组当中，这个数组就是HashMap的主干。&lt;/p&gt;
&lt;p&gt;　　使用哈希表可以进行非常快速的查找操作，查找时间为常数，同时不需要元素排列有序；Python的内建数据类型：字典就是用哈希表实现的。&lt;/p&gt;
&lt;p&gt;　　Python中的这些东西都是哈希原理：字典(dictionary)、集合(set)、计数器(counter)、默认字典Defaut dict)、有序字典(Order dict).&lt;/p&gt;
&lt;p&gt;　　哈希表示一个高效的查找的数据结构，哈希表一个通过哈希函数来计算数据存储位置的数据结构，通常支持如下操作：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;insert(key, value)：插入键值对（key, value）&lt;/li&gt;
&lt;li&gt;get(key)：如果存在键为key的键值对则返回其value，否则返回空值&lt;/li&gt;
&lt;li&gt;delete(key)：删除键为key的键值对&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;直接寻址表&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201910/1226410-20191016095939261-1029288149.png&quot; alt=&quot;&quot; width=&quot;579&quot; height=&quot;194&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;直接寻址技术缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;当域U很大时，需要消耗大量内存，很不实际&lt;/li&gt;
&lt;li&gt;如果域U很大而实际出现的key很少，则大量空间被浪费&lt;/li&gt;
&lt;li&gt;无法处理关键字不是数字的情况&lt;/li&gt;
&lt;/ol&gt;&lt;h4&gt;哈希&lt;/h4&gt;
&lt;p&gt;　　直接寻址表：key为k的元素放到k位置上&lt;/p&gt;
&lt;p&gt;　　改进直接寻址表：哈希（Hashing）&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;构建大小为m的寻址表T&lt;/li&gt;
&lt;li&gt;key为k的元素放到 h(k)位置上&lt;/li&gt;
&lt;li&gt;h(k) 是一个函数，其将域U映射到表 T[0, 1, ... , m-1]&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;哈希表&lt;/h4&gt;
&lt;p&gt;　　哈希表（Hash Table，又称为散列表），是一种线性表的存储结构。哈希表由一个&lt;strong&gt;直接寻址表&lt;/strong&gt;和一个&lt;strong&gt;哈希函数&lt;/strong&gt;组成。哈希函数h(k)将元素关键字 k 作为自变量，返回元素的存储下标。&lt;/p&gt;
&lt;p&gt;　　假设有一个长度为7的哈希表，哈希函数 h(k)=k%7.元素集合 {14, 22, 3, 5}的存储方式如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201910/1226410-20191016100643703-1264970198.png&quot; alt=&quot;&quot; width=&quot;413&quot; height=&quot;48&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201910/1226410-20191017092648675-1359856833.png&quot; alt=&quot;&quot; width=&quot;535&quot; height=&quot;278&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201910/1226410-20191017092710957-750210890.png&quot; alt=&quot;&quot; width=&quot;535&quot; height=&quot;247&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201910/1226410-20191017092728192-619079059.png&quot; alt=&quot;&quot; width=&quot;522&quot; height=&quot;257&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;47&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
class LinkList:
    class Node:
        def __init__(self, item=None):
            self.item = item
            self.next = None

    class LinkListIterator:
        def __init__(self, node):
            self.node = node
        def __next__(self):
            if self.node:
                cur_node = self.node
                self.node = cur_node.next
                return cur_node.item
            else:
                raise StopIteration
        def __iter__(self):
            return self

    def __init__(self, iterable=None):
        self.head = None
        self.tail = None
        if iterable:
            self.extend(iterable)

    def append(self, obj):
        s = LinkList.Node(obj)
        if not self.head:
            self.head = s
            self.tail = s
        else:
            self.tail.next = s
            self.tail = s

    def extend(self, iterable):
        for obj in iterable:
            self.append(obj)

    def find(self, obj):
        for n in self:
            if n == obj:
                return True
        else:
            return False

    def __iter__(self):
        return self.LinkListIterator(self.head)

    def __repr__(self):
        return &quot;&amp;lt;&amp;lt;&quot; + &quot;,&quot;.join(map(str, self)) + &quot;&amp;gt;&amp;gt;&quot;


# 类似于集合的结构
class HashTable:
    def __init__(self, size=101):
        self.size = size
        self.T = [LinkList() for i in range(self.size)]

    def h(self, k):
        return k % self.size

    def insert(self, k):
        i = self.h(k)
        if self.find(k):
            print('Duplicated Insert')
        else:
            self.T[i].append(k)

    def find(self, k):
        i = self.h(k)
        return self.T[i].find(k)
    
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;7.1  哈希表的应用&lt;/h4&gt;
&lt;h4&gt;　　1，集合与字典&lt;/h4&gt;
&lt;p&gt;　　字典与集合都是通过哈希表来实现的。比如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
dic_res = {'name':'james', 'age':32, 'gender': 'Man'}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　使用哈希表存储字典，通过哈希表将字典的键映射为下标，假设 h('name')=3，h('age')=4，则哈希表存储为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
[None, 32, None, 'james', 'Man']
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　如果发生哈希冲突，则通过拉链法或开发寻址法解决。&lt;/p&gt;
&lt;h4&gt;　　2，md5算法&lt;/h4&gt;
&lt;p&gt;　　MD5（Message-Digest Algorithm 5）曾经是密码学中常用的哈希函数，可以把任意长度的数据映射为128位的哈希值，其曾经包含如下特征：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1，同样的消息，其MD5值必定相同；&lt;/li&gt;
&lt;li&gt;2，可以快速计算出任意给定消息的MD5值；&lt;/li&gt;
&lt;li&gt;3，除非暴力的枚举所有可能的消息，否则不可能从哈希值反推出消息本身；&lt;/li&gt;
&lt;li&gt;4，两天消息之间即使只有微小的差别，其对应的MD5值也应该是完全不同，完全不相关的；&lt;/li&gt;
&lt;li&gt;5，不能再有意义的时间内人工的构造两个不同的消息，使其具有相同的MD5值&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;　　3，md5&lt;/h4&gt;
&lt;p&gt;　　应用举例：文件的哈希值&lt;/p&gt;
&lt;p&gt;　　算出文件的哈希值，若两个文件的哈希值相同，则可认为这两个文件时相同的，因此：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1，用户可以利用它来验证下载的文件是否完整&lt;/li&gt;
&lt;li&gt;2，云存储服务商可以利用它来判断用户要上次的文件是否已经存在于服务器上，从而实现秒传的功能，同时避免存储过多相同的文件副本。&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;　　 4，SHA2算法&lt;/h4&gt;
&lt;p&gt; 　　历史上MD5和SHA-1曾经是使用最为广泛的 cryptographic hash function，但是随着密码学的发展，这两个哈希函数的安全性相继受到了各种挑战。&lt;/p&gt;
&lt;p&gt;　　因此现在安全性较重要的场合推荐使用 SHA-A等新的更安全的哈希函数。&lt;/p&gt;
&lt;p&gt;　　SHA-2包含了一系列的哈希函数：SHA-224， SHA-256， SHA-384，SHA-512，SHA-512/224，SHA-512/256，其对应的哈希值长度分别为 224， 256， 384 or 512位。&lt;/p&gt;
&lt;p&gt;　　SHA-2 具有和 MD5 类似的性质。&lt;/p&gt;
&lt;h4&gt;　　5，SHA2算法应用举例&lt;/h4&gt;
&lt;p&gt;　　例如在比特币系统中，所有参与者需要共同解决如下问题：对于一个给定的字符串U，给定的目标哈希值H，需要计算一个字符串V，使得 U+ V的哈希值与H的差小于一个给定值D。此时，只能通过暴力枚举V来进行猜测。首先计算出结果的人可获得一定奖金。而某人首先计算成功的概率与其拥有的计算量成正比，所以其获得的奖金的期望值与其拥有的计算量成正比。&lt;/p&gt;

&lt;h3&gt;栈和队列的应用——迷宫问题&lt;/h3&gt;
&lt;p&gt;　　给出一个二维列表，表示迷宫（0表示通道，1表示围墙）。给出算法，求一条走出迷宫的路径。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201910/1226410-20191016101330640-1239520887.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　将其转化为数组如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201910/1226410-20191016101355239-1087570749.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　那有两种思路，一种是使用栈（深度优先搜索）来存储当前路径，也可以称为回溯法。但是深度优先有一个缺点，就是虽然能找到路径，但是不能保证是最短路径，其优点就是简单，容易理解。&lt;/p&gt;
&lt;p&gt;另一种方法就是队列，&lt;/p&gt;
&lt;h4&gt;1，栈——深度优先搜索&lt;/h4&gt;
&lt;p&gt;　　回溯法&lt;/p&gt;
&lt;p&gt;　　思路：从一个节点开始，任意找下一个能走的点，当炸不到能走的点时，退回上一个点寻找是否有其他方向的点。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;使用栈存储当前路径&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201910/1226410-20191016103810704-2145223636.png&quot; alt=&quot;&quot; width=&quot;386&quot; height=&quot;356&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;160&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
# _*_coding:utf-8_*_

maze = [
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    [1, 0, 0, 1, 0, 0, 0, 1, 0, 1],
    [1, 0, 0, 1, 0, 0, 0, 1, 0, 1],
    [1, 0, 0, 0, 0, 1, 1, 0, 0, 1],
    [1, 0, 1, 1, 1, 0, 0, 0, 0, 1],
    [1, 0, 0, 0, 1, 0, 0, 0, 0, 1],
    [1, 0, 1, 0, 0, 0, 1, 0, 0, 1],
    [1, 0, 1, 1, 1, 0, 1, 1, 0, 1],
    [1, 1, 0, 0, 0, 0, 0, 0, 0, 1],
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
]

# 这里我们封装一个列表,用来表示走迷宫的四个方向
dirs = [
    lambda x, y: (x + 1, y),  # 表示向上走
    lambda x, y: (x - 1, y),  # 表示向下走
    lambda x, y: (x, y - 1),  # 表示向左走
    lambda x, y: (x, y + 1),  # 表示向右走
]


def maze_path(x1, y1, x2, y2):
    stack = []
    stack.append((x1, y1))
    while (len(stack) &amp;gt; 0):
        curNode = stack[-1]  # 当前节点是 stack最后一个位置
        if curNode[0] == x2 and curNode[1] == y2:
            return True  # 如果有路则返回TRUE，没有路则返回FALSE
        # x,y当前坐标，四个方向上下左右分别是：x-1,y  x+1,y  x, y-1  x,y+1
        for dir in dirs:
            nextNode = dir(curNode[0], curNode[1])
            # 如果下一个节点能走
            if maze[nextNode[0]][nextNode[1]] == 0:
                stack.append(nextNode)
                maze[nextNode[0]][nextNode[1]] = 2  # 2表示已经走过了
                break
        else:  # 如果一个都找不到，就需要回退了
            maze[nextNode[0]][nextNode[1]] = 2
            stack.pop()  # 栈顶出栈，也就是回退

    else:
        print(&quot;没有路&quot;)
        return False


maze_path(1, 1, 8, 8)
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt; 2，队列——广度优先搜索&lt;/h4&gt;
&lt;p&gt;　　思路：从下一个节点开始，寻找所有接下来能继续走的点，继续不断寻找，直到找到出口。&lt;/p&gt;
&lt;p&gt;　　使用队列存储当前正在考虑的节点&lt;/p&gt;
&lt;p&gt;　　思路图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201910/1226410-20191016104219700-1669185875.png&quot; alt=&quot;&quot; width=&quot;381&quot; height=&quot;332&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 或者这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201910/1226410-20191016104240736-602848437.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 可以通过如下方式理解：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201910/1226410-20191016104325838-260568357.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201910/1226410-20191016104335801-1371843259.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;159&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
# _*_coding:utf-8_*_
from collections import deque

maze = [
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    [1, 0, 0, 1, 0, 0, 0, 1, 0, 1],
    [1, 0, 0, 1, 0, 0, 0, 1, 0, 1],
    [1, 0, 0, 0, 0, 1, 1, 0, 0, 1],
    [1, 0, 1, 1, 1, 0, 0, 0, 0, 1],
    [1, 0, 0, 0, 1, 0, 0, 0, 0, 1],
    [1, 0, 1, 0, 0, 0, 1, 0, 0, 1],
    [1, 0, 1, 1, 1, 0, 1, 1, 0, 1],
    [1, 1, 0, 0, 0, 0, 0, 0, 0, 1],
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
]

dirs = [
    lambda x, y: (x + 1, y),  # 表示向上走
    lambda x, y: (x - 1, y),  # 表示向下走
    lambda x, y: (x, y - 1),  # 表示向左走
    lambda x, y: (x, y + 1),  # 表示向右走
]

def print_r(path):
    real_path = []  # 用来存储真实的路径
    i = len(path) - 1  # 用i指向path的最后一个下标
    while i &amp;gt;= 0:
        real_path.append(path[i][0:2])
        i = path[i][2]
    real_path.reverse()

# 起点坐标（x1, y1)  终点坐标（x2, y2）
def maze_path_queue(x1, y1, x2, y2):
    queue = deque()
    path = []
    # -1  为当前path的路径的下标
    queue.append((x1, y1, -1))
    while len(queue) &amp;gt; 0:  # 当队列不空时循环
        # append是从右边加入的，popleft()从左边出去
        cur_Node = queue.popleft()
        path.append(cur_Node)
        if cur_Node[0] == x2 and cur_Node[1] == y2:
            # 如果当前节点等于终点节点，则说明到达终点
            print_r(path)
            return True

        # 队列是找四个方向，每个能走就继续
        for dir in dirs:
            # 下一个方向的节点坐标
            next_node = dir(cur_Node[0], cur_Node[1])
            if maze[next_node[0]][next_node[1]] == 0:
                queue.append((next_node[0], next_node[1], len(path) - 1))
                maze[next_node[0]][next_node[1]] = 2  # 标记为已走过
    return False  # 如果队列结束了，空了，还没找到路径，则为FALSE


maze_path_queue(1, 1, 8, 8)
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Fri, 18 Oct 2019 00:41:00 +0000</pubDate>
<dc:creator>战争热诚</dc:creator>
<og:description>数据结构简介 1，数据结构 数据结构是指相互之间存在着一种或多种关系的数据元素的集合和该集合中数据元素之间的关系组成。简单来说，数据结构就是设计数据以何种方式组织并存贮在计算机中。比如：列表，集合与字</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wj-1314/p/11574277.html</dc:identifier>
</item>
<item>
<title>机器学习中梯度下降法原理及用其解决线性回归问题的C语言实现 - davidtym</title>
<link>http://www.cnblogs.com/talkaudiodev/p/11673028.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/talkaudiodev/p/11673028.html</guid>
<description>&lt;p&gt;本文讲梯度下降（Gradient Descent）前先看看利用梯度下降法进行监督学习（例如分类、回归等）的一般步骤：&lt;/p&gt;
&lt;p&gt;1， 定义损失函数（Loss Function）&lt;/p&gt;
&lt;p&gt;2， 信息流forward propagation，直到输出端&lt;/p&gt;
&lt;p&gt;3， 误差信号back propagation。采用“链式法则”，求损失函数关于参数Θ的梯度&lt;/p&gt;
&lt;p&gt;4， 利用最优化方法（比如梯度下降法），进行参数更新&lt;/p&gt;
&lt;p&gt;5， 重复步骤2、3、4，直到收敛为止&lt;/p&gt;
&lt;p&gt;所谓损失函数，就是一个描述实际输出值和期望输出值之间落差的函数。有多种损失函数的定义方法，常见的有均方误差（error of mean square）、最大似然误差（maximum likelihood estimate）、最大后验概率（maximum posterior probability）、交叉熵损失函数（cross entropy loss）。本文就以均方误差作为损失函数讲讲梯度下降的算法原理以及用其解决线性回归问题。在监督学习下，对于一个样本，它的特征记为x（如果是多个特征，x表示特征向量），期望输出记为t（t为target的缩写），实际输出记为o（o为output的缩写）。两者之间的误差e可用下式表达（为了节省时间，各种算式就用手写的了）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1181527/201910/1181527-20191015122704144-1364127437.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;前面的系数1/2主要是为了在求导时消掉差值的平方项2。如果在训练集中有n个样本，可用E来表示所有样本的误差总和，并用其大小来度量模型的误差程度，如下式所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1181527/201910/1181527-20191015122741914-1210893832.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 对于第d个实例的输出可记为下式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1181527/201910/1181527-20191015122754677-2058765939.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于特定的训练数据集而言， 只有Θ是变量，所以E就可以表示成Θ的函数，如下式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1181527/201910/1181527-20191015122811727-1752283823.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以，对于神经网络学习的任务，就是求到一系列合适的Θ值，以拟合给定的训练数据，使实际输出尽可能接近期望输出，使得E取得最小值。&lt;/p&gt;

&lt;p&gt;再来看梯度下降。上式中损失函数E对权值向量Θ的梯度如下式所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1181527/201910/1181527-20191015122847689-238913197.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;它确定了E最快上升的方向。在梯度前面加上负号“-”，就表示E最快下降的方向。所以梯度下降的训练法则如下式所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1181527/201910/1181527-20191015173946132-1669304281.jpg&quot; alt=&quot;&quot;/&gt;， 其中 &lt;img src=&quot;https://img2018.cnblogs.com/blog/1181527/201910/1181527-20191015174012667-939226740.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里的负号“-”表示和梯度相反的方向。η表示学习率。下面给出各个权值梯度计算的数学推导：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1181527/201910/1181527-20191015175535162-1718615353.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以最终的梯度下降的训练法则如下式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1181527/201910/1181527-20191015175700755-935959701.jpg&quot; alt=&quot;&quot;/&gt;    &lt;/p&gt;
&lt;p&gt; 这个式子就是用于程序中计算参数Θ的。&lt;/p&gt;
&lt;p&gt;下面看怎么用梯度下降法解决线性回归问题。线性回归就是能够用一个直线较为精确地描述数据之间的关系。这样当出现新的数据的时候，就能够预测出一个简单的值。线性回归函数可写成&lt;img src=&quot;https://img2018.cnblogs.com/blog/1181527/201910/1181527-20191015183247549-323838407.jpg&quot; alt=&quot;&quot;/&gt; 。线性回归问题常用最小二乘法解决，这里用梯度下降法解决主要是通过实例加深对梯度下降法的理解。先假设Y = 2X + 3=2*X + 3*1，取X的四个值分别为1，4，5，8，相应的Y为5，11，13，19。这样就可以描述为有四个样本分别为（1,1），（4,1），（5,1），（8,1），对应的期望值是5，11，13，19.5（这个值做了微调，从19变成了19.5，是为了让四个样本不在一根直线上）。通过梯度下降法求Θ值(最终Θ逼近2和3)。C语言实现的代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#include &amp;lt;stdio.h&amp;gt;&lt;br/&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;p&gt;int&lt;/p&gt;&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;argv[])
{
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; matrix[&lt;span&gt;4&lt;/span&gt;][&lt;span&gt;2&lt;/span&gt;]={{&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;},{&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;},{&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;},{&lt;span&gt;8&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;&lt;span&gt;}};   &lt;span&gt;//样本&lt;/span&gt;
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; result[&lt;span&gt;4&lt;/span&gt;]={&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;11&lt;/span&gt;,&lt;span&gt;13&lt;/span&gt;,&lt;span&gt;19.5&lt;/span&gt;&lt;span&gt;};                 &lt;span&gt;//期望值&lt;/span&gt;
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; err_sum[&lt;span&gt;4&lt;/span&gt;] = {&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;};                   &lt;span&gt;//各个样本的误差&lt;/span&gt;
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; theta[&lt;span&gt;2&lt;/span&gt;] = {&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;&lt;span&gt;};                         &lt;span&gt;//Θ,初始值随机&lt;/span&gt;
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; err_square_total = &lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;;                   &lt;span&gt;//方差和&lt;/span&gt;
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; learning_rate = &lt;span&gt;0.01&lt;/span&gt;&lt;span&gt;;                     &lt;span&gt;//学习率&lt;/span&gt;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; ite_num;                                     &lt;span&gt;//迭代次数&lt;/span&gt;

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(ite_num = &lt;span&gt;0&lt;/span&gt;; ite_num &amp;lt;= &lt;span&gt;10000&lt;/span&gt;; ite_num++&lt;span&gt;) 
    {                               
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i,j,k;
        err_square_total &lt;/span&gt;= &lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;; 

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;4&lt;/span&gt;; i++&lt;span&gt;)          
        {
            &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; h = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;         
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; &lt;span&gt;2&lt;/span&gt;; j++&lt;span&gt;)   
                h &lt;/span&gt;+= theta[j]*&lt;span&gt;matrix[i][j];    

            err_sum[i] &lt;/span&gt;= result[i] -&lt;span&gt; h;  
            err_square_total &lt;/span&gt;+= 0.5*err_sum[i]*&lt;span&gt;err_sum[i];
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(err_square_total &amp;lt; &lt;span&gt;0.05&lt;/span&gt;&lt;span&gt;)  //0.05表示精度
             &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; &lt;span&gt;2&lt;/span&gt;; j++&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; sum = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(k = &lt;span&gt;0&lt;/span&gt;; k &amp;lt; &lt;span&gt;4&lt;/span&gt;; k++)   //所有样本都参与计算&lt;span&gt;
                sum &lt;/span&gt;+= err_sum[k]*matrix[k][j]; &lt;span&gt;
            theta[j] &lt;/span&gt;= theta[j] + learning_rate*&lt;span&gt;sum; //根据上面的公式计算新的Θ
        }
    }

    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; @@@ Finish, ite_number:%d, err_square_total:%lf, theta[0]:%lf, theta[1]:%lf\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, ite_num, err_square_total, theta[&lt;span&gt;0&lt;/span&gt;], theta[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]);

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;程序运行后的结果为：@@@ Finish, ite_number:308, err_square_total:0.049916, theta[0]:2.037090, theta[1]:3.002130。发现迭代了308次，最终的线性方程为Y=2.037090X + 3.002130，是逼近2和3的。当再有一个新的X时就可以预测出Y了。学习率是一个经验值，一般是0.01--0.001，当我把它改为0.04再运行时就不再收敛了。&lt;/p&gt;

&lt;p&gt;上面的梯度下降叫批量梯度下降法（Batch Gradient Descent, BGD）, 它是指在每一次迭代时使用所有样本来进行梯度的更新&lt;strong&gt;。&lt;/strong&gt;当样本数目很大时，每迭代一步都需要对所有样本计算，训练过程会很慢。于是人们想出了随机梯度下降法（Stochastic Gradient Descent, SGD），每次只随机取一个样本计算梯度，训练速度变快了，但是迭代次数变多了（表示不是一直向最快方向下降，但总体上还是向最低点逼近）。还是上面的例子，只不过每次只从四个样本中随机取一个计算梯度。C语言实现的代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;#include &amp;lt;stdio.h&amp;gt;&lt;br/&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;p&gt;int&lt;/p&gt;&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;argv[])
{
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; matrix[&lt;span&gt;4&lt;/span&gt;][&lt;span&gt;2&lt;/span&gt;]={{&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;},{&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;},{&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;},{&lt;span&gt;8&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;&lt;span&gt;}};  //样本
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; result[&lt;span&gt;4&lt;/span&gt;]={&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;11&lt;/span&gt;,&lt;span&gt;13&lt;/span&gt;,&lt;span&gt;19.5&lt;/span&gt;&lt;span&gt;};                //期望值
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; err_sum[&lt;span&gt;4&lt;/span&gt;] = {&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;};                  //各个样本的误差
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; theta[&lt;span&gt;2&lt;/span&gt;] = {&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;&lt;span&gt;};                        //Θ,初始值随机
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; err_square_total = &lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;;                  //方差和
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; learning_rate = &lt;span&gt;0.01&lt;/span&gt;&lt;span&gt;;                    //学习率
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; ite_num;                                    //迭代次数

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(ite_num = &lt;span&gt;0&lt;/span&gt;; ite_num &amp;lt;= &lt;span&gt;10000&lt;/span&gt;; ite_num++&lt;span&gt;) 
    {                               
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i,j,seed;
        err_square_total &lt;/span&gt;= &lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;; 
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;4&lt;/span&gt;; i++&lt;span&gt;)          
        {
            &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; h = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; &lt;span&gt;2&lt;/span&gt;; j++&lt;span&gt;)   
                h &lt;/span&gt;+= theta[j]*&lt;span&gt;matrix[i][j];    &lt;br/&gt;err_sum[i] &lt;/span&gt;= result[i] -&lt;span&gt; h;   
            err_square_total &lt;/span&gt;+= 0.5*err_sum[i]*&lt;span&gt;err_sum[i];
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(err_square_total &amp;lt; &lt;span&gt;0.05&lt;/span&gt;&lt;span&gt;) 
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

        seed &lt;/span&gt;= rand()%&lt;span&gt;4&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; &lt;span&gt;2&lt;/span&gt;; j++&lt;span&gt;)       
            theta[j] &lt;/span&gt;= theta[j] + learning_rate*err_sum[seed]*&lt;span&gt;matrix[seed][j];   //随机选一个样本参与计算
    }

    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; @@@ Finish, ite_number:%d, err_square_total:%lf, theta[0]:%lf, theta[1]:%lf\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, ite_num, err_square_total, theta[&lt;span&gt;0&lt;/span&gt;], theta[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]);

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;程序运行后的结果为：@@@ Finish, ite_number:1228, err_square_total:0.049573, theta[0]:2.037240, theta[1]:3.000183。发现迭代了1228次（迭代次数变多了），最终的线性方程为Y=2.037240X + 3.000183，也是逼近2和3的。&lt;/p&gt;

&lt;p&gt;后来人们又想出了在BGD和SGD之间的一个折中方法，即mini-batch SGD方法，即每次随机的取一组样本来计算梯度。mini-batch SGD是实际使用中用的最多的。还是上面的例子，只不过每次只从四个样本中随机取两个作为一组个计算梯度。C语言实现的代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#include &amp;lt;stdio.h&amp;gt;&lt;br/&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;p&gt;int&lt;/p&gt;&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;argv[])
{
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; matrix[&lt;span&gt;4&lt;/span&gt;][&lt;span&gt;2&lt;/span&gt;]={{&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;},{&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;},{&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;},{&lt;span&gt;8&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;&lt;span&gt;}};
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; result[&lt;span&gt;4&lt;/span&gt;]={&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;11&lt;/span&gt;,&lt;span&gt;13&lt;/span&gt;,&lt;span&gt;19.5&lt;/span&gt;&lt;span&gt;};
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; err_sum[&lt;span&gt;4&lt;/span&gt;] = {&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;};
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; theta[&lt;span&gt;2&lt;/span&gt;] = {&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;&lt;span&gt;}; 
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; err_square_total = &lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;; 
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; learning_rate = &lt;span&gt;0.01&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; ite_num;

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(ite_num = &lt;span&gt;0&lt;/span&gt;; ite_num &amp;lt;= &lt;span&gt;10000&lt;/span&gt;; ite_num++&lt;span&gt;) 
    {                               
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i,j,k,seed;
        err_square_total &lt;/span&gt;= &lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;; &lt;br/&gt;&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i = &lt;span&gt;0&lt;/span&gt;;i&amp;lt;&lt;span&gt;4&lt;/span&gt;;i++&lt;span&gt;)          
        {
            &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; h = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;   &lt;br/&gt;&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; &lt;span&gt;2&lt;/span&gt;; j++&lt;span&gt;)   
                h &lt;/span&gt;+= theta[j]*&lt;span&gt;matrix[i][j];    

            err_sum[i] &lt;/span&gt;= result[i] -&lt;span&gt; h;   
            err_square_total &lt;/span&gt;+= 0.5*err_sum[i]*&lt;span&gt;err_sum[i];
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(err_square_total &amp;lt; &lt;span&gt;0.05&lt;/span&gt;&lt;span&gt;) 
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;


        seed &lt;/span&gt;= rand()%&lt;span&gt;4&lt;/span&gt;&lt;span&gt;;
        k &lt;/span&gt;= (seed +&lt;span&gt;1&lt;/span&gt;)%&lt;span&gt;4&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; &lt;span&gt;2&lt;/span&gt;; j++&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; sum = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            sum &lt;/span&gt;+= err_sum[seed]*&lt;span&gt;matrix[seed][j];   //随机取两个作为一组计算梯度
            sum &lt;/span&gt;+= err_sum[k]*&lt;span&gt;matrix[k][j];&lt;br/&gt;theta[j] &lt;/span&gt;= theta[j] + learning_rate*&lt;span&gt;sum;
        }
    }

    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; @@@ Finish, ite_number:%d, err_square_total:%lf, theta[0]:%lf, theta[1]:%lf\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, ite_num, err_square_total, theta[&lt;span&gt;0&lt;/span&gt;], theta[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]);

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;程序运行后的结果为： @@@ Finish, ite_number:615, err_square_total:0.047383, theta[0]:2.039000, theta[1]:2.987382。发现迭代了615次，最终的线性方程为Y=2.039000X + 2.987382，也是逼近2和3的。迭代次数介于BGD和SGD中间。在用mini-batch SGD时batch size的选择很关键。&lt;/p&gt;
</description>
<pubDate>Fri, 18 Oct 2019 00:08:00 +0000</pubDate>
<dc:creator>davidtym</dc:creator>
<og:description>本文讲梯度下降（Gradient Descent）前先看看利用梯度下降法进行监督学习（例如分类、回归等）的一般步骤： 1， 定义损失函数（Loss Function） 2， 信息流forward pr</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/talkaudiodev/p/11673028.html</dc:identifier>
</item>
<item>
<title>[ASP.NET Core 3框架揭秘] 依赖注入：依赖注入模式 - Artech</title>
<link>http://www.cnblogs.com/artech/p/inside-asp-net-core-03-03.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/artech/p/inside-asp-net-core-03-03.html</guid>
<description>&lt;p&gt;IoC主要体现了这样一种设计思想：通过将一组通用流程的控制权从应用转移到框架之中以实现对流程的复用，并按照“好莱坞法则”实现应用程序的代码与框架之间的交互。我们可以采用若干设计模式以不同的方式实现IoC，比如我们在前面介绍的模板方法、工厂方法和抽象工厂，接下来我们介绍一种更有价值的IoC模式：依赖注入（DI：Dependency Injection）。&lt;/p&gt;

&lt;p&gt;和前面介绍的工厂方法和抽象工厂模式一样，依赖注入是一种“对象提供型”的设计模式，在这里我们将提供的对象统称为“服务”、“服务对象”或者“服务实例”。在一个采用依赖注入的应用中，我们定义某个类型的时候，只需要直接将它依赖的服务采用相应的方式注入进来就可以了。&lt;/p&gt;
&lt;p&gt;在应用启动的时候，我们会对所需的服务进行全局注册。一般来说，服务大都是针对实现的接口或者继承的抽象类进行注册的，服务注册信息的帮助我们在后续消费过程中提供对应的服务实例。按照“好莱坞法则”，应用只需要定义并注册好所需的服务，服务实例的提供则完全交给框架来完成，框架则会利用一个独立的“容器（Container）”来提供所需的每一个服务实例。&lt;/p&gt;
&lt;p&gt;我们将这个被框架用来提供服务的容器称为“依赖注入容器”，也有很多人将其称为“IoC容器”，根据前面针对IoC的介绍，我不认为后者是一个合理的称谓。依赖注入容器之所以能够按照我们希望的方式来提供所需的服务是因为该容器是根据服务注册信息来创建的，服务注册了包含提供所需服务实例的所有信息。&lt;/p&gt;
&lt;p&gt;举个简单的例子，我们创建一个名为Cat的依赖注入容器类型，那么我们可以调用如下这个扩展方法GetService&amp;lt;T&amp;gt;从某个Cat对象中获取指定类型的服务对象。我之所以将其命名为Cat，源于我们大家都非常熟悉的一个卡通形象“机器猫（哆啦A梦）”。机器猫的那个四次元口袋就是一个理想的依赖注入容器，大熊只需要告诉哆啦A梦相应的需求，它就能从这个口袋中得到相应的法宝。依赖注入容器亦是如此，服务消费者只需要告诉容器所需服务的类型（一般是一个服务接口或者抽象服务类），就能得到与之匹配的服务实例。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CatExtensions
{  
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; T GetService&amp;lt;T&amp;gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; Cat cat);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于我们演示的MVC框架来说，我们在前面分别采用不同的设计模式对框架的核心类型MvcEngine进行了“改造”，现在我们采用依赖注入的方式，并利用上述的这个Cat容器按照如下的方式对其进行重新实现，我们会发现MvcEngine变得异常简洁而清晰。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MvcEngine
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Cat Cat { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; MvcEngine(Cat cat) =&amp;gt; Cat =&lt;span&gt; cat;
        
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task StartAsync(Uri address)
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; listener = Cat.GetService&amp;lt;IWebListener&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; activator = Cat.GetService&amp;lt;IControllerActivator&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; executor = Cat.GetService&amp;lt;IControllerExecutor&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; renderer = Cat.GetService&amp;lt;IViewRenderer&amp;gt;&lt;span&gt;();

        &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; listener.ListenAsync(address);
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; httpContext = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; listener.ReceiveAsync();
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; controller = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; activator.CreateControllerAsync(httpContext);
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; view = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; executor.ExecuteAsync(controller, httpContext);
                &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; renderer.RenderAsync(view, httpContext);
            }
            &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; activator.ReleaseAsync(controller);
            }
        }
    }        
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;依赖注入体现了一种最为直接的服务消费方式，消费者只需要告诉提供者（依赖注入容器）所需服务的类型，后者就能根据预先注册的规则提供一个匹配的服务实例。由于服务注册最终决定了依赖注入容器根据指定的服务类型会提供一个怎样的服务实例，所以我们可以通过修改服务注册的方式来实现对框架的定制。如果应用程序需要采用前面定义的SingletonControllerActivator以单例的模式来激活目标Controller，那么它可以在启动MvcEngine之前按照如下的形式将SingletonControllerActivator注册到依赖注入容器上就可以了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; App
{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; cat = &lt;span&gt;new&lt;/span&gt; Cat() .Register&amp;lt;ControllerActivator, SingletonControllerActivator&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; engine     = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MvcEngine(cat);
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; address     = &lt;span&gt;new&lt;/span&gt; Uri(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost/mvcapp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        engine.StartAsync(address);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;一项任务往往需要多个对象相互协作才能完成，或者说某个对象在完成某项任务的时候需要直接或者间接地依赖其他的对象来完成某些必要的步骤，所以运行时对象之间的依赖关系是由目标任务来决定的，是“恒定不变的”，自然也无所谓“解耦”的说法。但是运行时对象通过对应的类来定义，类与类之间耦合则可以通过对依赖进行抽象的方式来降低或者解除。&lt;/p&gt;
&lt;p&gt;从服务消费的角度来讲，我们借助于一个接口对消费的服务进行抽象，那么服务消费程序针对具体服务类型的依赖可以转移到对服务接口的依赖上面，但是在运行时提供给消费者的总是一个针对某个具体服务类型的对象。不仅如此，要完成定义在服务接口的操作，这个对象可能需要其他相关对象的参与，换句话说，提供的这个依赖服务对象可能具有对其他服务对象的依赖。作为服务对象提供者的依赖注入容器，它会根据这一依赖链提供所有的依赖服务实例。&lt;/p&gt;
&lt;p&gt;如下图所示，应用框架调用GetService&amp;lt;IFoo&amp;gt;方法向依赖注入容器索取一个实现了IFoo接口的服务对象，后者会根据预先注册的类型映射关系创建一个类型为Foo的对象。由于Foo对象需要Bar和Gux对象的参与才能完成目标操作，所以Foo具有了针对Bar和Gux的直接依赖。至于服务对象Bar，它又依赖Baz，那么Baz成为了Foo的间接依赖。对于依赖注入容器最终提供的Foo对象，它所直接或者间接依赖的对象Bar、Baz和Qux都会预先被初始化并自动注入到该对象之中。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/201910/19327-20191018071258473-231745681.png&quot;&gt;&lt;img width=&quot;398&quot; height=&quot;226&quot; title=&quot;3-5&quot; alt=&quot;3-5&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/201910/19327-20191018071258789-2059018756.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;从面向对象编程的角度来讲，类型中的字段或者属性是依赖的一种主要体现形式。如果类型A中具有一个B类型的字段或者属性，那么A就对B产生了依赖，所以我们可以将依赖注入简单地理解为一种针对依赖字段或者属性的自动化初始化方式。我们可以通过三种主要的方式达到这个目的，这就是接下来着重介绍的三种依赖注入方式。&lt;/p&gt;
&lt;h2&gt;构造器注入&lt;/h2&gt;
&lt;p&gt;构造器注入就是在构造函数中借助参数将依赖的对象注入到由它创建的对象之中。如下面的代码片段所示，Foo针对Bar的依赖体现在只读属性Bar上，针对该属性的初始化实现在构造函数中，具体的属性值由构造函数传入的参数提供。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IBar Bar{&lt;span&gt;get&lt;/span&gt;&lt;span&gt;;}
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Foo(IBar bar) =&amp;gt;Bar =&lt;span&gt; bar;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;除此之外，构造器注入还体现在对构造函数的选择上。如下面的代码片段所示，Foo类定义了两个构造函数，依赖注入容器在创建Foo对象之前首先需要选择一个适合的构造函数。至于目标构造函数如何选择，不同的依赖注入容器可能有不同的策略，比如可以选择参数最多或者最少的构造函数，或者可以按照如下所示的方式在目标构造函数上标注一个InjectionAttribute特性。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IBar Bar{&lt;span&gt;get&lt;/span&gt;&lt;span&gt;;}
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IBaz Baz {&lt;span&gt;get&lt;/span&gt;&lt;span&gt;;}

    [Injection]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Foo(IBar bar) =&amp;gt;Bar =&lt;span&gt; bar;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Foo(IBar bar, IBaz):&lt;span&gt;this&lt;/span&gt;(bar)=&amp;gt;Baz =&lt;span&gt; baz;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;属性注入&lt;/h2&gt;
&lt;p&gt;如果依赖直接体现为类的某个属性，并且该属性不是只读的，我们可以让依赖注入容器在对象创建之后自动对其进行赋值进而达到依赖注入的目的。一般来说，我们在定义这种类型的时候，需要显式将这样的属性标识为需要自动注入的依赖属性以区别于其他普通的属性。如下面的代码片段所示，Foo类中定义了两个可读写的公共属性Bar和Baz，我们通过标注InjectionAttribute特性的方式将属性Baz设置为自动注入的依赖属性。对于由依赖注入容器提供的Foo对象，它的Baz属性将会自动被初始化。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IBar Bar{&lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;;}

    [Injection]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IBaz Baz {&lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;;}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;方法注入&lt;/h2&gt;
&lt;p&gt;体现依赖关系的字段或者属性可以通过方法的形式初始化。如下面的代码片段所示，Foo针对Bar的依赖体现在只读属性上，针对该属性的初始化实现在Initialize方法中，具体的属性值由该方法的传入的参数提供。我们同样通过标注特性（InjectionAttribute）的方式将该方法标识为注入方法。依赖注入容器在调用构造函数创建一个Foo对象之后，它会自动调用这个Initialize方法对只读属性Bar进行赋值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IBar Bar{&lt;span&gt;get&lt;/span&gt;&lt;span&gt;;}

    [Injection]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Initialize(IBar bar)=&amp;gt; Bar =&lt;span&gt; bar;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;除了上述这种通过依赖注入容器在初始化服务过程中自动调用的实现之外，我们还可以利用它实现另一种更加自由的方法注入，这种注入方式在ASP.NET Core应用中具有广泛的应用。ASP.NET Core在启动的时候会调用注册的Startup对象来完成中间件的注册，我们定义这个Startup类型的时候不需要让它实现某个接口，所以用于注册中间件的Configure方法没有一个固定的声明，我们可以按照如下的方式将任意依赖的服务实例直接注入到这个方法中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Startup
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app, IFoo foo, IBar bar, IBaz baz);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;类似的注入方式同样应用到中间件类型的定义上。与用来注册中间件的Startup类型一样，ASP.NET Core框架下的中间件类型同样不需要实现某个预定义的接口，用于处理请求的InvokeAsync或者Invoke方法同样可以按照如下的方式注入任意的依赖服务。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FoobarMiddleware
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; RequestDelegate _next; 
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; FoobarMiddleware(RequestDelegate next)=&amp;gt; _next =&lt;span&gt; next;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Task InvokeAsync(HttpContext httpContext, IFoo foo, IBar bar, IBaz baz);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面这种方式的方法注入促成了一种“面向约定”的编程方式。由于不再需要实现某个预定义的接口或者继承某一个预定义的基类，需要实现或者重写方法的声明也就少了对应的限制，这样就可以采用最直接的方式将依赖的服务注入到方法中。对于前面介绍的这几种注入方式，&lt;strong&gt;构造器注入是最为理想的形式&lt;/strong&gt;，我个人不建议使用属性注入和方法注入（前面介绍的这种基于约定的方法注入除外）。&lt;/p&gt;

&lt;p&gt;假设我们需要定义一个服务类型Foo，它依赖于另外两个服务Bar和Baz，后者对应的服务接口分别为IBar和IBaz。如果当前应用中具有一个依赖注入容器（假设类似于我们在前面定义的Cat），那么我们可以采用如下两种方式来定义这个服务类型Foo。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo : IFoo
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IBar Bar { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IBaz Baz { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Foo(IBar bar, IBaz baz)
    {
        Bar &lt;/span&gt;=&lt;span&gt; bar;
        Baz &lt;/span&gt;=&lt;span&gt; baz;
    }  
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task InvokeAsync()
    {
        &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; Bar.InvokeAsync();
        &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; Baz.InvokeAsync();
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo : IFoo
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Cat Cat { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Foo(Cat cat) =&amp;gt; Cat =&lt;span&gt; cat; 
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task InvokeAsync()
    {
        &lt;/span&gt;&lt;span&gt;await&lt;/span&gt; Cat.GetService&amp;lt;IBar&amp;gt;&lt;span&gt;().InvokeAsync();
        &lt;/span&gt;&lt;span&gt;await&lt;/span&gt; Cat.GetService&amp;lt;IBaz&amp;gt;&lt;span&gt;().InvokeAsync();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从表面上看，上面提供的这两种服务类型的定义方式貌似都不错，至少它们都解决针对依赖服务的耦合问题，并将针对服务实现的依赖转变成针对接口的依赖。那么哪一种更好呢？我想有人会选择第二种定义方式，因为这种定义方式不仅仅代码量更少，针对服务的提供也更加直接。我们直接在构造函数中“注入”了代表“依赖注入容器”的Cat对象，在任何使用到依赖服务的地方，我们只需要利用它来提供对应的服务实例就可以了。&lt;/p&gt;
&lt;p&gt;但事实上第二种定义方式采用的设计模式根本就&lt;strong&gt;不是“依赖注入”&lt;/strong&gt;，而是一种被称为“&lt;strong&gt;Service Locator&lt;/strong&gt;”的设计模式。Service Locator模式同样具有一个通过服务注册创建的全局的容器来提供所需的服务实例，该容器被称为“Service Locator”。“依赖注入容器”和“Service Locator”实际上是同一事物在不同设计模式中的不同称谓罢了，那么依赖注入和Service Locator之间的差异体现在什么地方呢？&lt;/p&gt;
&lt;p&gt;我觉得可以从“依赖注入容器”或者“Service Locator”被谁使用的角度来区分这两种设计模式的差别。在一个采用依赖注入的应用中，我们只需要采用标准的注入形式将服务类型定义好，并在应用启动之前完成相应的服务注册就可以了，框架自身的引擎在运行过程中会利用依赖注入容器来提供当前所需的服务实例。换句话说，&lt;strong&gt;依赖注入容器的使用者应该是框架而不是应用程序&lt;/strong&gt;。Service Locator模式显然不是这样，很明显是应用程序在利用它来提供所需的服务实例，所以它的&lt;strong&gt;使用者是应用程序&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我们也可以从另外一个角度区分两者之间的差别。由于依赖服务是以“注入”的方式来提供的，所以采用依赖注入模式的应用可以看成是将服务&lt;strong&gt;“推&lt;/strong&gt;”给依赖注入容器，Service Locator模式下的应用则是利用Service Locator去“&lt;strong&gt;拉&lt;/strong&gt;”取所需的服务，这一推一拉也准确地体现了两者之间的差异。那么既然两者之间有差别，究竟孰优孰劣呢？&lt;/p&gt;
&lt;p&gt;早在2010年，Mark Seemann就在他的&lt;a href=&quot;http://blog.ploeh.dk/2010/02/03/ServiceLocatorisanAnti-Pattern&quot;&gt;博客&lt;/a&gt;中将Service Locator视为一种“反模式（Anti-Pattern）”，虽然也有人对此提出不同的意见，但我个人是非常不推荐使用这种设计模式的。我反对使用Service Locator与前面提到的反对使用属性注入和方法注入具有类似的缘由。&lt;/p&gt;
&lt;p&gt;本着“松耦合、高内聚”的设计原则，我们既然将一组相关的操作定义在一个能够复用的服务中，就应该尽量要求服务自身不但具有独立和自治的特性，也要求服务之间的应该具有明确的界限，服务之间的依赖关系应该是明确的而不是模糊的。不论是采用属性注入或者方法注入，还是使用Service Locator来提供当前依赖的服务，这无疑为当前的服务&lt;strong&gt;增添了一个新的依赖&lt;/strong&gt;，即针对依赖注入容器或者Service Locator的依赖。&lt;/p&gt;
&lt;p&gt;当前服务针对另一个服务的依赖与针对依赖注入容器或者Service Locator的依赖具有本质的不同，前者是一种基于类型的依赖，不论是基于服务的接口还是实现类型，这是一种基于“&lt;strong&gt;契约”&lt;/strong&gt;的依赖。这种依赖不仅是&lt;strong&gt;明确&lt;/strong&gt;的，也是&lt;strong&gt;有保障&lt;/strong&gt;的。但是依赖注入容器或者Service Locator本质上是一个&lt;strong&gt;黑盒&lt;/strong&gt;，它能够提供所需服务的前提是相应的服务注册已经预先添加了容器之中，但是这种依赖不仅是&lt;strong&gt;模糊的也是不可靠&lt;/strong&gt;的。&lt;/p&gt;
&lt;p&gt;ASP.NET Core框架使用的依赖注入框架只支持构造器注入，而不支持属性和方法注入（类似于Startup和中间件基于约定的方法注入除外），但是我们很有可能不知不觉地会按照Service Locator模式来编写我们的代码。从某种意义上讲，当我们在程序中使用IServiceProvider（表示依赖注入容器）来提取某个服务实例的时候，就意味着我们已经在使用Service Locator模式了，所以当我们遇到这种情况下的时候应该多想一想是否一定需要这么做。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-01.html&quot;&gt;[ASP.NET Core 3框架揭秘] 依赖注入：控制反转&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-02.html&quot;&gt;[ASP.NET Core 3框架揭秘] 依赖注入：IoC模式&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-03.html&quot;&gt;[ASP.NET Core 3框架揭秘] 依赖注入：依赖注入模式&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-04.html&quot;&gt;[ASP.NET Core 3框架揭秘] 依赖注入：一个迷你版DI框架&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 17 Oct 2019 23:13:00 +0000</pubDate>
<dc:creator>Artech</dc:creator>
<og:description>IoC主要体现了这样一种设计思想：通过将一组通用流程的控制权从应用转移到框架之中以实现对流程的复用，并按照“好莱坞法则”实现应用程序的代码与框架之间的交互。我们可以采用若干设计模式以不同的方式实现Io</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/artech/p/inside-asp-net-core-03-03.html</dc:identifier>
</item>
<item>
<title>Java线程状态和关闭线程的正确姿势 - 张小云的博客</title>
<link>http://www.cnblogs.com/zhangweicheng/p/11695849.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangweicheng/p/11695849.html</guid>
<description>&lt;p&gt;　　Java中的线程有六种状态，使用线程Thread内的枚举类来实现，如下，我对每个状态都进行了一定的解释。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; State {
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 表示一个线程还没启用（即未调用start方法）&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        NEW,

        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * JVM中执行的线程都是处于这个状态的，但是处于这个状态不一定在JVM中执行，
         * 也就是说，只有这个状态有资格被JVM调度从而获得时间片执行。
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        RUNNABLE,

        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 线程在等待获取锁资源从而进入阻塞状态，
         * 在这个状态中，其一直监视锁的动态，随时准备抢占锁
         * 若获得锁资源，重新进入RUNNABLE状态
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        BLOCKED,

        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 当调用Object.wait、Thread.join或者LockSupport类的park方法的时候，线程进入此状态，
         * 该状态若无其他线程主动唤醒，则无期限的等待。
         * 唤醒的方法包括：Object.notify（唤醒随机一个）、Object.notifyAll（唤醒全部线程），
         * 被唤醒的线程重新进入RUNNABLE状态
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        WAITING,

        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 同WAITING状态，不过不同的是调用的方法加上了时间的限制，
         * 例如：Object.wait(10)、Thread.sleep(10)、Thread.join(10)、LockSupport.parkNanos(10)、LockSupport.parkUntil(10)这些方法
         * 唤醒的方法有两种：
         *     1、时间过期。
         *     2、其他线程调用了notify或者notifyAll
         *  唤醒之后同样进入RUNNABLE状态
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        TIMED_WAITING,

        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 线程的终点（正常死亡或者被终止）&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        TERMINATED;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　除了NEW和TERMINATED之外，其他的状态都是可以相互转换的，其转换过程如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1742516/201910/1742516-20191017214056797-776893786.png&quot; alt=&quot;&quot; width=&quot;691&quot; height=&quot;402&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　这里特别讲一下&lt;strong&gt;RUNNABLE&lt;/strong&gt;状态，在这个状态中线程并不一定在执行程序，只有被JVM调度的线程才能获得执行的时间片，并且只有这个状态的线程才能够获得时间片，换句话说，&lt;strong&gt;被JVM调度并且获得时间片是只属于处于RUNNABLE状态线程的权利&lt;/strong&gt;。为了便于理解，可以将RUNNABLE分成&lt;strong&gt;Runnable&lt;/strong&gt;和&lt;strong&gt;Running&lt;/strong&gt;两个状态（当然，你也可以换成其他的，这里我只是自己好理解），那么上面的线程转换图就转变成了下面这样（参考《Java并发编程的艺术》中的线程状态图）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1742516/201910/1742516-20191017215236678-108311631.png&quot; alt=&quot;&quot; width=&quot;830&quot; height=&quot;499&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　关于线程状态转换的例子，可以通过下面的代码加深理解&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        Test test &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Test();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1.NEW状态&lt;/span&gt;
        Thread thread = &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3.进行test对象锁的争夺，若抢到锁则继续执行，否则进入BLOCKED状态监控该锁，重新获得后进入RUNNABLE &lt;/span&gt;
            &lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; (test) {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 4.进入TIMED_WAITING状态，100ms后重新进入RUNNABLE状态争夺时间片 &lt;/span&gt;
                    Thread.sleep(100&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 5.重新获得时间片之后，进入WAITING状态 &lt;/span&gt;
&lt;span&gt;                    test.wait();
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 6.正常run()方法执行完毕后线程结束，进入TERMINATED &lt;/span&gt;
&lt;span&gt;        });
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2.调用start()方法，线程进入RUNNABLE状态&lt;/span&gt;
&lt;span readability=&quot;2&quot;&gt;        thread.start();
    }&lt;br/&gt;}&lt;p&gt;注：代码执行的顺序为注释的序号&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　在上面的例子中我们看到线程的&lt;strong&gt;run&lt;/strong&gt;方法正常执行完毕之后线程就正常死亡进入TERMINATED状态了，那么如果我们有中途停止线程的需求，我们应该如何正确的结束一个线程呢？&lt;/p&gt;
&lt;ol&gt;&lt;li readability=&quot;2&quot;&gt;&lt;strong&gt;使用interrupt()方法：&lt;/strong&gt;在线程内部，其定义了一个变量来标识当前线程是否处于被打断状态，调用interrupt()方法则使这个状态变为&lt;strong&gt;true&lt;/strong&gt;。我们采用这个方法加异常处理的方式来结束一个线程。
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre readability=&quot;7.5&quot;&gt;
&lt;span&gt;　　public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        Thread thread &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                Thread.sleep(&lt;/span&gt;1&lt;span&gt;);
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                e.printStackTrace();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里的return是必须的，原因后面说明&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }
            System.err.println(&lt;/span&gt;&quot;thread interrupt test...&quot;&lt;span&gt;);
        });
        thread.start();
        thread.interrupt();
        System.out.println(&lt;/span&gt;&quot;main thread end...&quot;&lt;span readability=&quot;9&quot;&gt;);
    }&lt;p&gt;// 结果图：异常后面的语句不会打印&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1742516/201910/1742516-20191017223023809-1011751041.png&quot; alt=&quot;&quot; width=&quot;350&quot; height=&quot;139&quot;/&gt;&lt;/p&gt;&lt;p&gt;　　这里关于&lt;strong&gt;线程中的打断标识变量（之后以interrupt称）&lt;/strong&gt;需要说明的是，在特定的情况下其状态会被重置。&lt;br/&gt;　　    1、线程内部在catch了异常了之后interrupt的状态会被重置为false。&lt;br/&gt;2、线程调用了Thread.interrupted()方法之后，interrupt的状态会被重置为false。如果需要判断线程是否中断的话可以使用对象方法isInterrupted()，此方法不会重置。&lt;br/&gt;所以在刚才的代码中需要加入return来结束线程，否则的话线程还是会继续往下执行，如下图&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1742516/201910/1742516-20191017223726955-1013973844.png&quot; alt=&quot;&quot; width=&quot;444&quot; height=&quot;192&quot;/&gt;&lt;/p&gt;&lt;p&gt;使用isInterrupted()实现：&lt;br/&gt;&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
public static void main(String[] args) throws InterruptedException {&lt;br/&gt;Thread thread = new Thread(() -&amp;gt; {&lt;br/&gt;while (!Thread.currentThread().isInterrupted()) {&lt;br/&gt;int k = 0;&lt;br/&gt;while (k++ &amp;lt; 10) {&lt;br/&gt;System.out.println(&quot;do something...&quot; + k);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;System.err.println(&quot;thread end...&quot;);&lt;br/&gt;});&lt;br/&gt;thread.start();&lt;br/&gt;Thread.sleep(1);&lt;br/&gt;// 主线程流程执行完了，需要停止线程&lt;br/&gt;thread.interrupt();&lt;br/&gt;}
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li readability=&quot;-0.5&quot;&gt;&lt;strong&gt;使用标识位来实现：&lt;/strong&gt;定义一个变量标识线程是否终止，若终止了则退出run方法。跟上面isInterrupted()的实现一样，不过换成了&lt;strong&gt;volatile&lt;/strong&gt;变量而已。
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; interrupted = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
        Thread thread &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (!&lt;span&gt;interrupted) {
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; k = 0&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (k++ &amp;lt; 10&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (interrupted) {
                        System.err.println(&lt;/span&gt;&quot;thread invoke end....&quot;&lt;span&gt;);
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                    }
                    System.out.println(&lt;/span&gt;&quot;do something...&quot; +&lt;span&gt; k);
                }
            }
        System.err.println(&lt;/span&gt;&quot;thread end...&quot;&lt;span&gt;);
        });
        thread.start();
        Thread.sleep(&lt;/span&gt;1&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 主线程流程执行完了，需要停止线程&lt;/span&gt;
        interrupted = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }
}&lt;br/&gt;// 结果图&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1742516/201910/1742516-20191017225940108-2082600755.png&quot; alt=&quot;&quot; width=&quot;312&quot; height=&quot;294&quot;/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;　stop()方法——不正确的线程中断方法&lt;/h2&gt;
&lt;p&gt;　　  在线程提供的方法中还有一个方法可以强制关闭线程——stop()。这个方法可以说是相当的霸道，给人一种“我不管，我就是要你现在立刻死亡（指线程）”的感觉，并且其还会释放线程所有的锁资源，这样可能会导致出现数据不一致从而出现线程不安全的情况，如下面例子。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; flag = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; state = 0&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
            Test test &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Test();
            Thread thread &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; (test) {
                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                        test.state &lt;/span&gt;= 1&lt;span&gt;;
                        Thread.sleep(&lt;/span&gt;100&lt;span&gt;);
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (flag) {
                            test.state &lt;/span&gt;= 2&lt;span&gt;;
                        }
                        System.err.println(&lt;/span&gt;&quot;thread execute finished...&quot;&lt;span&gt;);
                    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            });
            thread.start();
            Thread.sleep(&lt;/span&gt;1&lt;span&gt;);
            thread.stop();
            flag &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            System.out.println(&lt;/span&gt;&quot;state状态：&quot; +&lt;span&gt; test.state);
        }
}&lt;br/&gt;// 在这段代码中，进入线程时默认将state赋为1，接着过一段时间后如果触发了特定条件则把state赋为2，但是在特定条件触发之前，线程就被终止掉了，这个特定条件虽然符合但却没办法执行，从而导致数据的不一致。&lt;br/&gt;// 结果图&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1742516/201910/1742516-20191017232325223-1615574314.png&quot; alt=&quot;&quot; width=&quot;372&quot; height=&quot;105&quot;/&gt;　　&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;em id=&quot;__mceDel&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/em&gt;&lt;span&gt;　　所以，我们应该采用上面两种正确的方式&lt;strong&gt;而不是stop()来中止线程&lt;/strong&gt;。此外，stop()方法若在线程start()之前执行，那么在线程启动的时候就会立即死亡。&lt;/span&gt;
&lt;/pre&gt;


&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;若有不对之处，望各位不吝指教（反正免费，对吧）。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 17 Oct 2019 15:37:00 +0000</pubDate>
<dc:creator>张小云的博客</dc:creator>
<og:description>1、线程状态及切换 Java中的线程有六种状态，使用线程Thread内的枚举类来实现，如下，我对每个状态都进行了一定的解释。 除了NEW和TERMINATED之外，其他的状态都是可以相互转换的，其转换</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhangweicheng/p/11695849.html</dc:identifier>
</item>
<item>
<title>分库分表(7)--- SpringBoot+ShardingSphere实现分库分表 + 读写分离 - 雨点的名字</title>
<link>http://www.cnblogs.com/qdhxhz/p/11688371.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qdhxhz/p/11688371.html</guid>
<description>&lt;center&gt;

&lt;/center&gt;
&lt;p&gt;有关分库分表前面写了六篇博客:&lt;/p&gt;
&lt;p&gt;1、&lt;a href=&quot;https://www.cnblogs.com/qdhxhz/p/11608222.html&quot;&gt;分库分表(1) --- 理论&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2、&lt;a href=&quot;https://www.cnblogs.com/qdhxhz/p/11629883.html&quot;&gt;分库分表(2) --- ShardingSphere(理论)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3、&lt;a href=&quot;https://www.cnblogs.com/qdhxhz/p/11656205.html&quot;&gt;分库分表(3) ---SpringBoot + ShardingSphere实现读写分离&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4、&lt;a href=&quot;https://www.cnblogs.com/qdhxhz/p/11651163.html&quot;&gt;分库分表(4) ---SpringBoot + ShardingSphere 实现分表&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;5、&lt;a href=&quot;https://www.cnblogs.com/qdhxhz/p/11673493.html&quot;&gt;分库分表(5) ---SpringBoot + ShardingSphere 实现分库分表&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;6、&lt;a href=&quot;https://www.cnblogs.com/qdhxhz/p/11688651.html&quot;&gt;分库分表(6)--- SpringBoot+ShardingSphere实现分表+ 读写分离&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这篇博客通过ShardingSphere&lt;code&gt;实现分库分表 + 读写分离&lt;/code&gt;，并在文章最下方附上项目&lt;code&gt;Github地址&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;一项目概述&quot;&gt;&lt;span&gt;一、项目概述&lt;/span&gt;&lt;/h2&gt;
&lt;h4 id=&quot;技术架构&quot;&gt;1、技术架构&lt;/h4&gt;
&lt;p&gt;项目总体技术选型&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SpringBoot2.0.6 + shardingsphere4.0.0-RC1 + Maven3.5.4  + MySQL + lombok(插件)&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;项目说明&quot;&gt;2、项目说明&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;场景&lt;/code&gt; 在实际开发中，如果数据库压力大我们可以通过 &lt;strong&gt;分库分表&lt;/strong&gt; 的基础上进行 &lt;strong&gt;读写分离&lt;/strong&gt;，来减缓数据库压力。&lt;/p&gt;
&lt;h4 id=&quot;数据库设计&quot;&gt;3、数据库设计&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;分库&lt;/code&gt; ms单库分库分为 ms0库 和 ms1库。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;分表&lt;/code&gt; tab_user单表分为tab_user0表 和 tab_user1表。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;读写分离&lt;/code&gt; 数据写入ms0库 和 ms1库，数据读取 sl0库 和 sl1库。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ms0 ---主库&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201910/1090617-20191016204615168-856573739.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ms1 ---主库&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201910/1090617-20191016204625922-1762015926.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sl0 ---从库&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201910/1090617-20191016204638625-407970469.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sl1 ---从库&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201910/1090617-20191016204648399-387199295.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;说明&lt;/code&gt; 初始数据的时候，这边只有 &lt;strong&gt;sl0从库&lt;/strong&gt; 我插入了一条数据。那是因为我们这个项目中Mysql服务器并没有实现主从部署,这四个库都在同一服务器上，所以&lt;/p&gt;
&lt;p&gt;做不到主数据库数据自动同步到从数据库。所以这里在从数据库建一条数据。等下验证的时候，我们只需验证数据是否存入&lt;code&gt;ms0&lt;/code&gt;和&lt;code&gt;ms1&lt;/code&gt;，数据读取是否在&lt;code&gt;sl0&lt;/code&gt;和&lt;code&gt;sl1&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;具体的创建表SQL也会放到GitHub项目里&lt;/p&gt;

&lt;h2 id=&quot;二核心代码&quot;&gt;&lt;span&gt;二、核心代码&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;说明&lt;/code&gt; 完整的代码会放到GitHub上，这里只放一些核心代码。&lt;/p&gt;
&lt;h4 id=&quot;application.properties&quot;&gt;1、application.properties&lt;/h4&gt;
&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;server.port=8082

#指定mybatis信息
mybatis.config-location=classpath:mybatis-config.xml
#打印sql
spring.shardingsphere.props.sql.show=true
#数据源 
spring.shardingsphere.datasource.names=master0,slave0,master1,slave1

spring.shardingsphere.datasource.master0.type=com.alibaba.druid.pool.DruidDataSource
spring.shardingsphere.datasource.master0.driver-class-name=com.mysql.jdbc.Driver
spring.shardingsphere.datasource.master0.url=jdbc:mysql://localhost:3306/ms0?characterEncoding=utf-8
spring.shardingsphere.datasource.master0.username=root
spring.shardingsphere.datasource.master0.password=root

spring.shardingsphere.datasource.slave0.type=com.alibaba.druid.pool.DruidDataSource
spring.shardingsphere.datasource.slave0.driver-class-name=com.mysql.jdbc.Driver
spring.shardingsphere.datasource.slave0.url=jdbc:mysql://localhost:3306/sl0?characterEncoding=utf-8
spring.shardingsphere.datasource.slave0.username=root
spring.shardingsphere.datasource.slave0.password=root

spring.shardingsphere.datasource.master1.type=com.alibaba.druid.pool.DruidDataSource
spring.shardingsphere.datasource.master1.driver-class-name=com.mysql.jdbc.Driver
spring.shardingsphere.datasource.master1.url=jdbc:mysql://localhost:3306/ms1?characterEncoding=utf-8
spring.shardingsphere.datasource.master1.username=root
spring.shardingsphere.datasource.master1.password=root

spring.shardingsphere.datasource.slave1.type=com.alibaba.druid.pool.DruidDataSource
spring.shardingsphere.datasource.slave1.driver-class-name=com.mysql.jdbc.Driver
spring.shardingsphere.datasource.slave1.url=jdbc:mysql://localhost:3306/slave1?characterEncoding=utf-8
spring.shardingsphere.datasource.slave1.username=root
spring.shardingsphere.datasource.slave1.password=root

#根据年龄分库
spring.shardingsphere.sharding.default-database-strategy.inline.sharding-column=age
spring.shardingsphere.sharding.default-database-strategy.inline.algorithm-expression=master$-&amp;gt;{age % 2}
#根据id分表
spring.shardingsphere.sharding.tables.tab_user.actual-data-nodes=master$-&amp;gt;{0..1}.tab_user$-&amp;gt;{0..1}
spring.shardingsphere.sharding.tables.tab_user.table-strategy.inline.sharding-column=id
spring.shardingsphere.sharding.tables.tab_user.table-strategy.inline.algorithm-expression=tab_user$-&amp;gt;{id % 2}

#指定master0为主库，slave0为它的从库
spring.shardingsphere.sharding.master-slave-rules.master0.master-data-source-name=master0
spring.shardingsphere.sharding.master-slave-rules.master0.slave-data-source-names=slave0
#指定master1为主库，slave1为它的从库
spring.shardingsphere.sharding.master-slave-rules.master1.master-data-source-name=master1
spring.shardingsphere.sharding.master-slave-rules.master1.slave-data-source-names=slave1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Sharding-JDBC可以通过&lt;code&gt;Java&lt;/code&gt;，&lt;code&gt;YAML&lt;/code&gt;，&lt;code&gt;Spring命名空间&lt;/code&gt;和&lt;code&gt;Spring Boot Starter&lt;/code&gt;四种方式配置，开发者可根据场景选择适合的配置方式。具体可以看官网。&lt;/p&gt;
&lt;h4 id=&quot;usercontroller&quot;&gt;2、UserController&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RestController
public class UserController {

    @Autowired
    private UserService userService;

    /**
     * 模拟插入数据
     */
    List&amp;lt;User&amp;gt; userList = Lists.newArrayList();
    /**
     * 初始化插入数据
     */
    @PostConstruct
    private void getData() {
        userList.add(new User(1L,&quot;小小&quot;, &quot;女&quot;, 3));
        userList.add(new User(2L,&quot;爸爸&quot;, &quot;男&quot;, 30));
        userList.add(new User(3L,&quot;妈妈&quot;, &quot;女&quot;, 28));
        userList.add(new User(4L,&quot;爷爷&quot;, &quot;男&quot;, 64));
        userList.add(new User(5L,&quot;奶奶&quot;, &quot;女&quot;, 62));
    }
    /**
     * @Description: 批量保存用户
     */
    @PostMapping(&quot;save-user&quot;)
    public Object saveUser() {
        return userService.insertForeach(userList);
    }
    /**
     * @Description: 获取用户列表
     */
    @GetMapping(&quot;list-user&quot;)
    public Object listUser() {
        return userService.list();
    }&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;三测试验证&quot;&gt;&lt;span&gt;三、测试验证&lt;/span&gt;&lt;/h2&gt;
&lt;h4 id=&quot;批量插入数据&quot;&gt;1、批量插入数据&lt;/h4&gt;
&lt;p&gt;请求接口&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;localhost:8082/save-user&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以从商品接口代码中可以看出，它会批量插入5条数据。我们先看控制台输出SQL语句&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201910/1090617-20191016204701100-420602843.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以从SQL语句可以看出 &lt;strong&gt;master0&lt;/strong&gt; 和 &lt;strong&gt;master1&lt;/strong&gt; 库中都插入了数据。&lt;/p&gt;
&lt;p&gt;我们再来看数据库&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ms0.tab_user0&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201910/1090617-20191016204709927-109585642.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ms0.tab_user1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201910/1090617-20191016204720312-155045671.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ms1.tab_user0&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201910/1090617-20191016204731838-247434033.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ms1.tab_user1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201910/1090617-20191016204740482-27142599.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;完成分库分表插入数据。&lt;/p&gt;
&lt;h4 id=&quot;获取数据&quot;&gt;2、获取数据&lt;/h4&gt;
&lt;p&gt;这里获取列表接口的SQL。&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;  select *  from tab_user &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;请求接口结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201910/1090617-20191016204752338-1011637895.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;结论&lt;/code&gt; 从接口返回的结果可以很明显的看出，数据存储在主库,而数据库的读取在从库。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;注意&lt;/code&gt; ShardingSphere并不支持&lt;code&gt;CASE WHEN&lt;/code&gt;、&lt;code&gt;HAVING&lt;/code&gt;、&lt;code&gt;UNION (ALL)&lt;/code&gt;，&lt;code&gt;有限支持子查询&lt;/code&gt;。这个官网有详细说明。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Github地址&lt;/code&gt;：&lt;a href=&quot;https://github.com/yudiandemingzi/spring-boot-sharding-sphere&quot; class=&quot;uri&quot;&gt;https://github.com/yudiandemingzi/spring-boot-sharding-sphere&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;参考&quot;&gt;&lt;span&gt;参考&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;1、&lt;a href=&quot;https://shardingsphere.apache.org/document/current/cn/overview/&quot;&gt;ShardingSphere中文文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2、&lt;a href=&quot;https://shardingsphere.apache.org/&quot;&gt;ShardingSphere官网&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3、&lt;a href=&quot;https://github.com/apache/incubator-shardingsphere&quot;&gt;Shardingsphere Github库&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt; 我相信，无论今后的道路多么坎坷，只要抓住今天，迟早会在奋斗中尝到人生的甘甜。抓住人生中的一分一秒，胜过虚度中的一月一年！(20）&lt;/code&gt;
&lt;/pre&gt;

</description>
<pubDate>Thu, 17 Oct 2019 15:26:00 +0000</pubDate>
<dc:creator>雨点的名字</dc:creator>
<og:description>分库分表(7) ShardingSphere实现分库分表+读写分离 有关分库分表前面写了六篇博客: 1、 '分库分表(1) 理论' 2、 '分库分表(2) ShardingSphere(理论)' 3、</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qdhxhz/p/11688371.html</dc:identifier>
</item>
<item>
<title>编程杂谈——std::vector与List的性能比较 - Ken.W</title>
<link>http://www.cnblogs.com/kenwoo/p/11695634.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kenwoo/p/11695634.html</guid>
<description>&lt;p&gt;昨天在比较完C++中std::vector的两个方法的性能差异并留下记录后——&lt;a href=&quot;https://www.cnblogs.com/kenwoo/p/11689284.html&quot;&gt;编程杂谈——使用emplace_back取代push_back&lt;/a&gt;，今日尝试在C#中测试对应功能的性能。&lt;/p&gt;
&lt;p&gt;C#中对应std::vector的数据结构为List。更多的对应关系可以参照下面：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;std::vector - List&lt;br/&gt;std::list - LinkedList&lt;br/&gt;std::map - Dictionary&amp;lt;K, V&amp;gt;&lt;br/&gt;std::set - HashSet&lt;br/&gt;std::multimap - Dictionary&amp;lt;K, List&amp;gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;C#的测试代码如下：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;using System;
using System.Collections.Generic;
using System.Diagnostics;

namespace ConsoleApp
{
    class Item
    {
        public string Name { get; set; }
    }
    class Program
    {
        static void Main(string[] args)
        {
            var sw = new Stopwatch();
            sw.Start();
            var count = 100000;
            var l = new List&amp;lt;Item&amp;gt;();
            
            for (int i = 0; i &amp;lt; count; i++)
            {
                l.Add(new Item { Name = &quot;Test&quot; });
            }

            Console.WriteLine(sw.ElapsedMilliseconds / 1000.0);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;程序执行结果约为0.077(该值每次会发生少许变化)&lt;/p&gt;
&lt;p&gt;而C++的测试代码的结果约是0.207。这就有违于我们一般的认知了，毕竟通常都觉得C++的性能要优于C#。&lt;/p&gt;
&lt;pre class=&quot;cplusplus&quot;&gt;
&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;chrono&amp;gt;

class Item
{
public:
    Item(std::string name):name(name){}
private:
    std::string name;
};

int main()
{
    std::vector&amp;lt;Item&amp;gt; v;
    int count = 100000;
    v.reserve(count);
    clock_t begin_time = clock();
    for (auto i = 0; i &amp;lt; count; i++)
    {
        v.emplace_back(&quot;Test&quot;);
    }

    std::cout &amp;lt;&amp;lt; float(clock() - begin_time) / CLOCKS_PER_SEC &amp;lt;&amp;lt; std::endl;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;原来这里犯了个错误，如果要进行基准测试的话，必须要在Release模式下进行。&lt;/p&gt;
&lt;p&gt;当改成Release模式后，C++的代码执行时间变成了0.003，而C#也下降到了0.061左右。&lt;/p&gt;
&lt;p&gt;不过在上述C#代码中，缺少一点优化，&lt;code&gt;var l = new List&amp;lt;Item&amp;gt;();&lt;/code&gt;没有预设容量值，如果改成&lt;code&gt;var l = new List&amp;lt;Item&amp;gt;(count);&lt;/code&gt;，执行时间进一步下降至0.050左右。&lt;/p&gt;
&lt;p&gt;然而C#代码还可以继续优化，将Item类改成结构体后，结果变成了0.006。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;struct Item
{
    public string Name { get; set; }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果把C++代码中也同样改成结构体，则几乎没有获得什么优化。&lt;/p&gt;
&lt;pre class=&quot;cplusplus&quot;&gt;
&lt;code&gt;struct Item
{
public:
    Item(std::string name):name(name){}
private:
    std::string name;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后将测试数据量从10W加至1000W后，C++代码的执行时间约是0.286，而C#的约为0.627。同样是2倍左右的差距。&lt;/p&gt;
&lt;p&gt;值得注意的是，上述的C#代码是在.NET Core 3.0基础上测试，如果改成.NET Framwork 4.8，执行时间会降为0.536左右。由此可见，.NET Core应该还留有不少可以优化的地方，希望其在性能方面上能够进一步改善。&lt;/p&gt;
</description>
<pubDate>Thu, 17 Oct 2019 15:22:00 +0000</pubDate>
<dc:creator>Ken.W</dc:creator>
<og:description>昨天在比较完C++中std::vector的两个方法的性能差异并留下记录后—— '编程杂谈——使用emplace_back取代push_back' ，今日尝试在C 中测试对应功能的性能。 C 中对应s</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kenwoo/p/11695634.html</dc:identifier>
</item>
<item>
<title>Go routine 编排框架：oklog/run 包 - 黄挤挤</title>
<link>http://www.cnblogs.com/guangze/p/11695602.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/guangze/p/11695602.html</guid>
<description>&lt;h2 id=&quot;问题引入&quot;&gt;问题引入&lt;/h2&gt;
&lt;p&gt;oklog/run 包提供了一套非常简单、易用的 Go routine 编排框架。在介绍 oklog/run 前，我们先考虑以下问题：&lt;/p&gt;
&lt;p&gt;假设我们有四个 Go routine 组件，如图所示，分别是运行一个状态机 sm.Run 、启动一个 HTTP 服务器、执行定时任务 cronJobs(sm) 读取状态机状态、和运行信号监听器。每个 Go routine 组件互相独立运行。&lt;/p&gt;
&lt;p&gt;问题在于，我们如何将各个组件作为一个整体运行，并有序地结束？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/409355/201910/409355-20191017223539083-299877784.png&quot; alt=&quot;Ways To Do Things - Peter Bourgon&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于每一个 Go routine 组件，我们都有相应的办法来执行结束操作。状态机通过 Context 对象，HTTP 服务器通过调用 Listener 的 Close 方法，定时任务和监听器通过 channel。当一个组件结束的时候，需要通知其他组件有序执行结束操作。这个问题的解决方法可以用 Actor 模型来描述。每个 Go routine 都是一个 actor，互相独立，互相之间只能通过 message 通信。oklog/run 包实现了 Actor 模型，能非常简洁的实现 Go routine 编排功能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/409355/201910/409355-20191017223604342-1986183200.png&quot; alt=&quot;Ways To Do Things - Peter Bourgon&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;oklogrun-包介绍&quot;&gt;oklog/run 包介绍&lt;/h2&gt;
&lt;p&gt;oklog/run 包非常简单，只有一个类型，两个方法，共 60 行代码。其中 Group 是一组 actor，通过调用 Add 方法将 actor 添加到 Group 中。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;type Group
func (g *Group) Add(execute func() error, interrupt func(error))
func (g *Group) Run() error&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;type Group struct {
    actors []actor
}

func (g *Group) Add(execute func() error, interrupt func(error)) {
    g.actors = append(g.actors, actor{execute, interrupt})
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;每个 actor 有两个方法：execute 和 interrupt。execute 完成 Go routine 的计算任务，interrupt 结束 Go routine 并退出。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;type actor struct {
    execute   func() error
    interrupt func(error)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用 Run 方法后会启动所有 Go routine（或者称为 actor），并等待第一个结束的 Go routine（无论正常退出或因为异常终止）。一旦捕获到第一个结束信号，会依次结束其他 Go routine 直到所有 Go routine 完全退出。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func (g *Group) Run() error {
    if len(g.actors) == 0 {
        return nil
    }

    // Run each actor.
    errors := make(chan error, len(g.actors))
    for _, a := range g.actors {
        go func(a actor) {
            errors &amp;lt;- a.execute()
        }(a)
    }

    // Wait for the first actor to stop.
    err := &amp;lt;-errors

    // Signal all actors to stop.
    for _, a := range g.actors {
        a.interrupt(err)
    }

    // Wait for all actors to stop.
    for i := 1; i &amp;lt; cap(errors); i++ {
        &amp;lt;-errors
    }

    // Return the original error.
    return err
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;使用例子&quot;&gt;使用例子&lt;/h2&gt;
&lt;p&gt;下面例子定义了三个 actor，前两个 actor 一直等待。第三个 actor 在 3s 后结束退出。引起前两个 actor 退出。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package main

import (
    &quot;fmt&quot;
    &quot;github.com/oklog/run&quot;
    &quot;time&quot;
)

func main() {
    g := run.Group{}
    {
        cancel := make(chan struct{})
        g.Add(
            func() error {

                select {
                case &amp;lt;- cancel:
                    fmt.Println(&quot;Go routine 1 is closed&quot;)
                    break
                }

                return nil
            },
            func(error) {
                close(cancel)
            },
        )
    }
    {
        cancel := make(chan struct{})
        g.Add(
            func() error {

                select {
                case &amp;lt;- cancel:
                    fmt.Println(&quot;Go routine 2 is closed&quot;)
                    break
                }

                return nil
            },
            func(error) {
                close(cancel)
            },
        )
    }
    {
        g.Add(
            func() error {
                for i := 0; i &amp;lt;= 3; i++ {
                    time.Sleep(1 * time.Second)
                    fmt.Println(&quot;Go routine 3 is sleeping...&quot;)
                }
                fmt.Println(&quot;Go routine 3 is closed&quot;)
                return nil
            },
            func(error) {
                return
            },
        )
    }
    g.Run()
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打印结果：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;Go routine 3 is sleeping...
Go routine 3 is sleeping...
Go routine 3 is sleeping...
Go routine 3 is closed
Go routine 2 is closed
Go routine 1 is closed&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=LHe1Cb_Ud_M&amp;amp;t=15m45s&quot;&gt;Ways To Do Things - Peter Bourgon&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 17 Oct 2019 14:37:00 +0000</pubDate>
<dc:creator>黄挤挤</dc:creator>
<og:description>[toc] Go routine 编排框架：oklog/run 包 问题引入 oklog/run 包提供了一套非常简单、易用的 Go routine 编排框架。在介绍 oklog/run 前，我们先考</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/guangze/p/11695602.html</dc:identifier>
</item>
</channel>
</rss>