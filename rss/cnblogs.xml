<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Vue躬行记（3）——样式和表单 - 咖啡机（K.F.J）</title>
<link>http://www.cnblogs.com/strick/p/11331410.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/strick/p/11331410.html</guid>
<description>&lt;p&gt;　　Vue对DOM元素的class和style两个特性做了专门的增强，即对CSS类和内联样式做了一层封装，通过v-bind指令来处理它们，而接收的表达式既可以是简单的字符串、对象或数组，也可以是复杂的计算属性。不仅如此，Vue还为表单设计了一些语法糖，让表单处理变得尤为简单。&lt;/p&gt;

&lt;p&gt;　　v-bind指令与class参数配合，就能处理CSS类，并且能接收多种类型的值。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）对象&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　v-bind:class可以接收一个对象，对象的属性名就是CSS类名，只有当其值是真值时，才能添加到DOM元素上，否则会被忽略。下面的&amp;lt;p&amp;gt;元素会接收数据对象中的classList，它包含两个属性warning和cur，其中cur属性保存了一个假值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p &lt;/span&gt;&lt;span&gt;v-bind:class&lt;/span&gt;&lt;span&gt;=&quot;classList&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;strick&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;var&lt;/span&gt;&lt;span&gt; vm &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({　
    data: {　　
      classList: {
        warning: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
        cur: &lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;
      }　
    }
  });
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　渲染出的&amp;lt;p&amp;gt;元素如下所示，不包含cur类。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;warning&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;strick&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　此外，v-bind:class可简写成:class，并且能与普通的class特性共存，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p &lt;/span&gt;&lt;span&gt;:class&lt;/span&gt;&lt;span&gt;=&quot;classList&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;size&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;strick&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）数组&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　当v-bind:class接收一个数组时，其元素既可以是CSS类名，也可以是对象，格式与之前相同，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p &lt;/span&gt;&lt;span&gt;:class&lt;/span&gt;&lt;span&gt;=&quot;[classList, cur]&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;strick&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;var&lt;/span&gt;&lt;span&gt; vm &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({　
    data: {　　
      classList: {
        warning: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
      },
      cur: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cur&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;　
    }
  });
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　v-bind指令与style参数配合，就能避免通过字符串拼接的方式来处理内联样式，并且也能接收多种类型的值。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）对象&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　v-bind:style可以接收一个对象，对象的属性名有两种命名方式：驼峰式和连字符分隔式，第二种就是层叠样式表中的CSS属性的命名方式。下面的&amp;lt;p&amp;gt;元素会接收数据对象中的cssObj，其属性采用了两种命名方式。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p &lt;/span&gt;&lt;span&gt;:style&lt;/span&gt;&lt;span&gt;=&quot;cssObj&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;strick&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;var&lt;/span&gt;&lt;span&gt; vm &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({　
    data: {　　
      cssObj: {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fontSize&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;30px&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;line-height&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
      }　
    }
  });
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　渲染出的&amp;lt;p&amp;gt;元素如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;font-size: 30px; line-height: 2;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;strick&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　Vue允许为属性赋一个包含多个值的数组（即多重值），可让浏览器选择支持的属性，例如定义不同阶段的伸缩盒样式，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p &lt;/span&gt;&lt;span&gt;:style&lt;/span&gt;&lt;span&gt;=&quot;{display: ['-webkit-box', '-ms-flexbox', 'flex']}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;strick&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）数组&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　当v-bind:style接收一个数组时，其元素就是样式对象，并且如果出现同名的CSS属性，那么后面的会覆盖前面的。例如下面的cssObj1和cssObj2两个对象都包含line-height属性，而最终渲染出的值为1.5。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p &lt;/span&gt;&lt;span&gt;:style&lt;/span&gt;&lt;span&gt;=&quot;[cssObj1, cssObj2]&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;strick&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;var&lt;/span&gt;&lt;span&gt; vm &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({　
    data: {　　
      cssObj1: {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fontSize&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;30px&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;line-height&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
      },
      cssObj2: {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;line-height&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: &lt;/span&gt;&lt;span&gt;1.5&lt;/span&gt;&lt;span&gt;
      }　
    }
  });
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3）浏览器前缀&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　Vue会自动侦测浏览器样式的兼容性，并根据需要为CSS属性（例如border-radius、transform等）添加相应的浏览器前缀。&lt;/p&gt;
&lt;p&gt; 　　下面的代码摘自Vue.js，其中camelize()函数可将连字符分隔式的字符串转换成驼峰式的字符串；vendorNames变量记录了三种浏览器前缀；normalize()函数会判断传入的属性是否存在于&amp;lt;div&amp;gt;元素的style属性中，如果不存在，就为其添加浏览器前缀，而之所以单独处理filter属性是因为Chrome的一个bug，虽然Chrome只支持-webkit-filter属性，但是style属性中保存的却是无前缀的filter。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; camelizeRE = /-(\w)/&lt;span&gt;g;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; camelize = cached(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(str) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; str.replace(camelizeRE, &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(_, c) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; c ? c.toUpperCase() : &quot;&quot;&lt;span&gt;;
  });
});

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; vendorNames = [&quot;Webkit&quot;, &quot;Moz&quot;, &quot;ms&quot;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; emptyStyle;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; normalize = cached(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(prop) {
  emptyStyle &lt;/span&gt;= emptyStyle || document.createElement(&quot;div&quot;&lt;span&gt;).style;
  prop &lt;/span&gt;=&lt;span&gt; camelize(prop);
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (prop !== &quot;filter&quot; &amp;amp;&amp;amp; prop &lt;span&gt;in&lt;/span&gt;&lt;span&gt; emptyStyle) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; prop;
  }
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; capName = prop.charAt(0).toUpperCase() + prop.slice(1&lt;span&gt;);
  &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; vendorNames.length; i++&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; name = vendorNames[i] +&lt;span&gt; capName;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (name &lt;span&gt;in&lt;/span&gt;&lt;span&gt; emptyStyle) {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
    }
  }
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　Vue提供了v-model指令，可在表单控件上实现双向数据绑定，即修改控件的值，也会自动更新Vue实例中所对应的数据对象的属性，反之亦然。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）v-model&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　下面用一个示例来演示v-model指令的用法，文本框的初始值是“strick”，当修改&amp;lt;input&amp;gt;元素中的值时，&amp;lt;p&amp;gt;元素的文本也会随之更新。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; v-model&lt;/span&gt;&lt;span&gt;=&quot;name&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{name}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;var&lt;/span&gt;&lt;span&gt; vm &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({　
    data: {　　
      name: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;strick&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;　
    }
  });
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　而如果在控制台执行下面这条赋值语句，那么就会更新&amp;lt;input&amp;gt;元素中的值，其实这就是Vue的双向数据绑定所起的作用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
vm.name = &quot;freedom&quot;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在使用v-model指令时需要注意，表单控件的初始值得声明在数据对象的属性中，而不是value、checked或selected这些特性中。还是以之前的文本框为例，添加了一个value特性，如下所示，渲染出的控件值将是“strick”，而不是“init”。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; v-model&lt;/span&gt;&lt;span&gt;=&quot;name&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;init&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　v-model本质上是个语法糖，它在内部会监听表单控件相关特性的变化，并触发相应的事件，其对应关系如表4所示。&lt;/p&gt;
&lt;p&gt;表4  v-model指令内部的对应关系&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr&gt;&lt;td&gt;表单控件&lt;/td&gt;
&lt;td&gt;监听特性&lt;/td&gt;
&lt;td&gt;触发事件&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;文本框（单行和多行）&lt;/td&gt;
&lt;td&gt;value&lt;/td&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;单选框和复选框&lt;/td&gt;
&lt;td&gt;checked&lt;/td&gt;
&lt;td&gt;change&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;选择框&lt;/td&gt;
&lt;td&gt;&amp;lt;option&amp;gt;子元素中的value&lt;/td&gt;
&lt;td&gt;change&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）表单控件&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　将v-model指令作用于表单控件时，其初始值常用的类型会有所不同，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; vm = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
  data: {
    name: &lt;/span&gt;&quot;&quot;,          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;文本框（单行和多行）&lt;/span&gt;
    checked: &lt;span&gt;true&lt;/span&gt;,     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;一个复选框&lt;/span&gt;
    names: [],         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;多个复选框&lt;/span&gt;
    color: &quot;&quot;,         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;单选框&lt;/span&gt;
    selected: &quot;&quot;,      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;选择框（单选）&lt;/span&gt;
    selecteds: []      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;选择框（多选）&lt;/span&gt;
&lt;span&gt;  }
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　当只使用一个复选框时，v-model指令可绑定一个布尔值；而当使用多个复选框时，v-model指令适合绑定数组，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;checkbox&quot;&lt;/span&gt;&lt;span&gt; v-model&lt;/span&gt;&lt;span&gt;=&quot;checked&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;checkbox&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;strick&quot;&lt;/span&gt;&lt;span&gt; v-model&lt;/span&gt;&lt;span&gt;=&quot;names&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;checkbox&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;freedom&quot;&lt;/span&gt;&lt;span&gt; v-model&lt;/span&gt;&lt;span&gt;=&quot;names&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　单选框与复选框不同，由于它只能选中一个值，因此不适合绑定数组，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;radio&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;red&quot;&lt;/span&gt;&lt;span&gt; v-model&lt;/span&gt;&lt;span&gt;=&quot;color&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;radio&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;black&quot;&lt;/span&gt;&lt;span&gt; v-model&lt;/span&gt;&lt;span&gt;=&quot;color&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　选择框的multiple特性能控制其是否多选，而这也会决定是否需要绑定数组，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;v-model&lt;/span&gt;&lt;span&gt;=&quot;selected&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;strick&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;freedom&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;v-model&lt;/span&gt;&lt;span&gt;=&quot;selecteds&quot;&lt;/span&gt;&lt;span&gt; multiple&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;strick&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;freedom&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3）值绑定&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　单选框、复选框和选择框的值原先只能是字符串或布尔值，而通过v-bind指令就能让它们绑定任意类型的值，如下所示，为两个单选框的value特性绑定了一个对象。当选中其中一个按钮时，color属性的值就会更新成绑定的对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;radio&quot;&lt;/span&gt;&lt;span&gt; v-model&lt;/span&gt;&lt;span&gt;=&quot;color&quot;&lt;/span&gt;&lt;span&gt; :value&lt;/span&gt;&lt;span&gt;=&quot;{digit: 1}&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;radio&quot;&lt;/span&gt;&lt;span&gt; v-model&lt;/span&gt;&lt;span&gt;=&quot;color&quot;&lt;/span&gt;&lt;span&gt; :value&lt;/span&gt;&lt;span&gt;=&quot;{digit: 2}&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　复选框包含两个特殊的特性：true-value和false-value（如下代码所示），当将其选中时，toggle属性会更新为yes属性的值，否则更新为no属性的值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;checkbox&quot;&lt;/span&gt;&lt;span&gt; v-model&lt;/span&gt;&lt;span&gt;=&quot;toggle&quot;&lt;/span&gt;&lt;span&gt; :true-value&lt;/span&gt;&lt;span&gt;=&quot;yes&quot;&lt;/span&gt;&lt;span&gt; :false-value&lt;/span&gt;&lt;span&gt;=&quot;no&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;var&lt;/span&gt;&lt;span&gt; vm &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({　
    data: {　　
      toggle: &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
      yes: &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
      no: &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
    }
  });
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4）修饰符&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　Vue为v-model指令提供了3个修饰符，如下所列，每个修饰符后面都给出了相应的示例。&lt;/p&gt;
&lt;p&gt;　　（1）.lazy修饰符能将同步输入值的事件从input替换成change，以下面的文本框为例，只有当修改其值并失去焦点时，才会更新数据对象的name属性。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; v-model.lazy&lt;/span&gt;&lt;span&gt;=&quot;name&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　（2）.number修饰符能让输入值自动转换成数字，常与number类型的文本框配合使用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;number&quot;&lt;/span&gt;&lt;span&gt; v-model.number&lt;/span&gt;&lt;span&gt;=&quot;age&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　（3）.trim修饰符能过滤输入值的首尾空格。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; v-model.trim&lt;/span&gt;&lt;span&gt;=&quot;school&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;    
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Mon, 21 Oct 2019 00:33:00 +0000</pubDate>
<dc:creator>咖啡机（K.F.J）</dc:creator>
<og:description>Vue对DOM元素的class和style两个特性做了专门的增强，即对CSS类和内联样式做了一层封装，通过v-bind指令来处理它们，而接收的表达式既可以是简单的字符串、对象或数组，也可以是复杂的计算</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/strick/p/11331410.html</dc:identifier>
</item>
<item>
<title>[ASP.NET Core 3框架揭秘] 依赖注入：一个Mini版的依赖注入框架 - Artech</title>
<link>http://www.cnblogs.com/artech/p/inside-asp-net-core-03-04.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/artech/p/inside-asp-net-core-03-04.html</guid>
<description>&lt;p&gt;在前面的章节中，我们从纯理论的角度对依赖注入进行了深入论述，我们接下来会对.NET Core依赖注入框架进行单独介绍。为了让读者朋友能够更好地理解.NET Core依赖注入框架的设计与实现，我们按照类似的原理创建了一个简易版本的依赖注入框架，也就是我们在前面多次提及的Cat。&lt;/p&gt;
&lt;p&gt;源代码下载&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://files.cnblogs.com/files/artech/cat01.7z&quot;&gt;普通服务的注册与消费&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://files.cnblogs.com/files/artech/cat02.7z&quot;&gt;泛型服务的注册与消费&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://files.cnblogs.com/files/artech/cat03.7z&quot;&gt;多服务实例的提供&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://files.cnblogs.com/files/artech/cat04.7z&quot;&gt;服务实例的生命周期&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;虽然我们对这个名为Cat的依赖注入框架进行了最大限度的简化，但是与.NET Core框架内部使用的真实依赖注入框架相比，Cat不仅采用了一致的设计，而且几乎具备了后者所有的功能特性。为了让大家对Cat具有一个感官的认识，我们先来演示一下如何利用它来提供我们所需的服务实例。&lt;/p&gt;
&lt;p&gt;作为依赖注入容器的Cat对象不仅仅作为服务实例的提供者，它同时还需要维护着服务实例的生命周期。Cat提供了三种生命周期模式，如果要了解它们之间的差异，就必须对多个Cat之间的层次关系有充分的认识。一个代表依赖注入容器的Cat对象用来创建其他的Cat对象，后者视前者为“父容器”，所以多个Cat对象通过其“父子关系”维系一个树形层次化结构。不过这仅仅是一个逻辑结构而已，实际上每个Cat对象只会按照下图所示的方式引用整棵树的根。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/201910/19327-20191021083258858-62040007.png&quot;&gt;&lt;img width=&quot;380&quot; height=&quot;192&quot; title=&quot;3-6_thumb2&quot; alt=&quot;3-6_thumb2&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/201910/19327-20191021083259141-626976470.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在了解了多个Cat对象之间的关系之后，对于三种预定义的生命周期模式就很好理解了。如下所示的Lifetime枚举代表着三种生命周期模式，其中Transient代表容器针对每次服务请求都会创建一个新的服务实例，而Self则是将提供服务实例保存在当前容器中，它代表针对某个容器范围内的单例模式，Root则是将每个容器提供的服务实例统一存放到根容器中，所以该模式能够在多个“同根”容器范围内确保提供的服务是单例的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; Lifetime
{
    Root,
    Self,
    Transient
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代表依赖注入容器的Cat对象之所以能够为我们提供所需服务实例，其根本前提是相应的服务注册在此之前已经添加到容器之中。服务总是针对服务类型（接口、抽象类或者具体类型）进行注册，Cat通过定义的扩展方法提供了如下三种注册方式。除了直接提供服务实例的形式外（默认采用Root模式），我们在注册服务的时候必须指定一个具体的生命周期模式。&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;指定具体的实现类型。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;提供一个服务实例。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;指定一个创建服务实例的工厂。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们定义了如下的接口和对应的实现类型来演示针对Cat的服务注册。其中Foo、Bar、Baz和Gux分别实现了对应的接口IFoo、IBar、IBaz和IGux，其中Gux类型上标注了一个MapToAttribute特性注册了与对应接口IGux之间的映射。为了反映Cat对服务实例生命周期的控制，我们让它们派生于同一个基类Base。Base实现了IDisposable接口，我们在其构造函数和实现的Dispose方法中输出相应的文本以确定对应的实例何时被创建和释放。我们还定义了一个泛型的接口IFoobar&amp;lt;T1, T2&amp;gt;和对应的实现类Foobar&amp;lt;T1, T2&amp;gt;来演示Cat针对泛型服务实例的提供。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IFoo {}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IBar {}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IBaz {} 
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IGux {}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; IFoobar&amp;lt;T1, T2&amp;gt;&lt;span&gt; {}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Base : IDisposable
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Base() =&amp;gt; Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Instance of {GetType().Name} is created.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Dispose()  =&amp;gt; Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Instance of {GetType().Name} is disposed.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo : Base, IFoo{ }
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Bar : Base, IBar{ }
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Baz : Base, IBaz{ } 
[MapTo(&lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(IGux), Lifetime.Root)]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Gux : Base, IGux { }
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Foobar&amp;lt;T1, T2&amp;gt;: IFoobar&amp;lt;T1,T2&amp;gt;&lt;span&gt;
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IFoo Foo { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IBar Bar { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Foobar(IFoo foo, IBar bar)
    {
        Foo &lt;/span&gt;=&lt;span&gt; foo;
        Bar &lt;/span&gt;=&lt;span&gt; bar;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在如下所示的代码片段中我们创建了一个Cat对象并采用上面提到的方式针对接口IFoo、IBar和IBaz注册了对应的服务，它们采用的生命周期模式分别为Transient、Self和Root。然后我们还调用了另一个将当前入口程序集作为参数的Register方法，该方法会解析指定程序集中标注了MapToAttribute特性的类型并作相应的服务注册，对于我们演示的程序来，该方法会完成针对IGux/Gux类型的服务注册。接下来我们利用Cat对象创建了它的两个子容器，并调用子容器的GetService&amp;lt;T&amp;gt;方法提供相应的服务实例。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; root = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Cat()
            .Register&lt;/span&gt;&amp;lt;IFoo, Foo&amp;gt;&lt;span&gt;(Lifetime.Transient)
            .Register&lt;/span&gt;&amp;lt;IBar&amp;gt;(_=&amp;gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Bar(), Lifetime.Self) 
            .Register&lt;/span&gt;&amp;lt;IBaz, Baz&amp;gt;&lt;span&gt;(Lifetime.Root) 
            .Register(Assembly.GetEntryAssembly());
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; cat1 =&lt;span&gt; root.CreateChild();
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; cat2 =&lt;span&gt; root.CreateChild();

        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; GetServices&amp;lt;TService&amp;gt;&lt;span&gt;(Cat cat)
        {
            cat.GetService&lt;/span&gt;&amp;lt;TService&amp;gt;&lt;span&gt;();
            cat.GetService&lt;/span&gt;&amp;lt;TService&amp;gt;&lt;span&gt;();
        }

        GetServices&lt;/span&gt;&amp;lt;IFoo&amp;gt;&lt;span&gt;(cat1);
        GetServices&lt;/span&gt;&amp;lt;IBar&amp;gt;&lt;span&gt;(cat1);
        GetServices&lt;/span&gt;&amp;lt;IBaz&amp;gt;&lt;span&gt;(cat1); 
        GetServices&lt;/span&gt;&amp;lt;IGux&amp;gt;&lt;span&gt;(cat1);
        Console.WriteLine();
        GetServices&lt;/span&gt;&amp;lt;IFoo&amp;gt;&lt;span&gt;(cat2);
        GetServices&lt;/span&gt;&amp;lt;IBar&amp;gt;&lt;span&gt;(cat2);
        GetServices&lt;/span&gt;&amp;lt;IBaz&amp;gt;&lt;span&gt;(cat2); 
        GetServices&lt;/span&gt;&amp;lt;IGux&amp;gt;&lt;span&gt;(cat2);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的程序运行之后会在控制台上输出如图3-7所示的结果，输出的内容不仅表明Cat能够根据添加的服务注册提供对应类型的服务实例，还体现了它对生命周期的控制。由于服务IFoo被注册为Transient服务，所以Cat针对该接口的服务提供四次请求都会创建一个全新的Foo对象。IBar服务的生命周期模式为Self，如果我们利用同一个Cat对象来提供对应的服务实例，该Cat对象只会创建一个Bar对象，所以整个过程中会创建两个Bar对象。IBaz和IGux服务采用Root生命周期，所以具有同根的两个Cat对象提供的总是同一个Baz/Gux对象，后者只会被创建一次。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/201910/19327-20191021083259438-700391232.png&quot;&gt;&lt;img width=&quot;366&quot; height=&quot;250&quot; title=&quot;3-7_thumb2&quot; alt=&quot;3-7_thumb2&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/201910/19327-20191021083259714-1864946840.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;除了提供类似于IFoo、IBar和IBaz这样非泛型的服务实例之外，如果具有针对泛型定义（Generic Definition）的服务注册，Cat同样也能提供泛型服务实例。如下面的代码片段所示，在为创建的Cat对象添加了针对IFoo和IBar接口的服务注册之后，我们调用Register方法注册了针对泛型定义IFoobar&amp;lt;,&amp;gt;的服务注册，具体的实现类型为Foobar&amp;lt;,&amp;gt;。当我们利用Cat对象提供一个类型为IFoobar&amp;lt;IFoo, IBar&amp;gt;的服务实例的时候，它会创建并返回一个Foobar&amp;lt;Foo, Bar&amp;gt;对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; cat = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Cat()
            .Register&lt;/span&gt;&amp;lt;IFoo, Foo&amp;gt;&lt;span&gt;(Lifetime.Transient)
            .Register&lt;/span&gt;&amp;lt;IBar, Bar&amp;gt;&lt;span&gt;(Lifetime.Transient)
            .Register(&lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;(IFoobar&amp;lt;,&amp;gt;), &lt;span&gt;typeof&lt;/span&gt;(Foobar&amp;lt;,&amp;gt;&lt;span&gt;), Lifetime.Transient);

        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; foobar = (Foobar&amp;lt;IFoo, IBar&amp;gt;)cat.GetService&amp;lt;IFoobar&amp;lt;IFoo, IBar&amp;gt;&amp;gt;&lt;span&gt;();
        Debug.Assert(foobar.Foo &lt;/span&gt;&lt;span&gt;is&lt;/span&gt;&lt;span&gt; Foo);
        Debug.Assert(foobar.Bar &lt;/span&gt;&lt;span&gt;is&lt;/span&gt;&lt;span&gt; Bar);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当我们在进行服务注册的时候，可以为同一个类型添加多个服务注册。虽然添加的所有服务注册均是有效的，不过由于扩展方法GetService&amp;lt;TService&amp;gt;总是返回一个唯一的服务实例，我们对该方法采用了“后来居上”的策略，即总是采用最近添加的服务注册来创建服务实例。如果我们调用另一个扩展方法GetServices&amp;lt;TService&amp;gt;，它将利用返回根据所有服务注册提供的服务实例。&lt;/p&gt;
&lt;p&gt;如下面的代码片段所示，我们为创建的Cat对象添加了三个针对Base类型的服务注册，对应的实现类型分别为Foo、Bar和Baz。我们最后将Base作为泛型参数调用了GetServices&amp;lt;Base&amp;gt;方法，该方法会返回包含三个Base对象的集合，集合元素的类型分别为Foo、Bar和Baz。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; services = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Cat()
            .Register&lt;/span&gt;&amp;lt;Base, Foo&amp;gt;&lt;span&gt;(Lifetime.Transient)
            .Register&lt;/span&gt;&amp;lt;Base, Bar&amp;gt;&lt;span&gt;(Lifetime.Transient)
            .Register&lt;/span&gt;&amp;lt;Base, Baz&amp;gt;&lt;span&gt;(Lifetime.Transient)
            .GetServices&lt;/span&gt;&amp;lt;Base&amp;gt;&lt;span&gt;();
        Debug.Assert(services.OfType&lt;/span&gt;&amp;lt;Foo&amp;gt;&lt;span&gt;().Any());
        Debug.Assert(services.OfType&lt;/span&gt;&amp;lt;Bar&amp;gt;&lt;span&gt;().Any());
        Debug.Assert(services.OfType&lt;/span&gt;&amp;lt;Baz&amp;gt;&lt;span&gt;().Any());
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果提供的服务实例实现了IDisposable接口，我们应该在适当的时候调用其Dispose方法释放该服务实例。由于服务实例的生命周期完全由作为依赖注入容器的Cat对象来管理，那么通过调用Dispose方法来释放服务实例自然也应该由它来负责。Cat针对提供服务实例的释放策略取决于采用的生命周期模式，具体的策略如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Transient和Self：所有实现了IDisposable接口的服务实例会被当前Cat对象保存起来，当Cat对象自身的Dispose方法被调用的时候，这些服务实例的Dispose方法会随之被调用。&lt;/li&gt;
&lt;li&gt;Root：由于服务实例保存在作为根容器的Cat对象上，所以当这个Cat对象的Dispose方法被调用的时候，这些服务实例的Dispose方法会随之被调用。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上述的释放策略可以通过如下的演示实例来印证。我们在如下的代码片段中创建了一个Cat对象，并添加了相应的服务注册。我们接下来调用了CreateChild方法创建代表子容器的Cat对象，并用它提供了四个注册服务对应的实例。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
    {
        &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; root = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Cat()
            .Register&lt;/span&gt;&amp;lt;IFoo, Foo&amp;gt;&lt;span&gt;(Lifetime.Transient)
            .Register&lt;/span&gt;&amp;lt;IBar&amp;gt;(_ =&amp;gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Bar(), Lifetime.Self)
            .Register&lt;/span&gt;&amp;lt;IBaz, Baz&amp;gt;&lt;span&gt;(Lifetime.Root)
            .Register(Assembly.GetEntryAssembly()))
        {
            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; cat =&lt;span&gt; root.CreateChild())
            {
                cat.GetService&lt;/span&gt;&amp;lt;IFoo&amp;gt;&lt;span&gt;();
                cat.GetService&lt;/span&gt;&amp;lt;IBar&amp;gt;&lt;span&gt;();
                cat.GetService&lt;/span&gt;&amp;lt;IBaz&amp;gt;&lt;span&gt;();
                cat.GetService&lt;/span&gt;&amp;lt;IGux&amp;gt;&lt;span&gt;();
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Child cat is disposed.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Root cat is disposed.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于两个Cat对象的创建都是在using块中进行的，所以它们的Dispose方法都会在using块结束的地方被调用。为了确定方法被调用的时机，我们特意在控制台上打印了相应的文字。该程序运行之后会在控制台上输出如下图所示的结果，我们可以看到当作为子容器的Cat对象的Dispose方法被调用的时候，由它提供的两个生命周期模式分别为Transient和Self的两个服务实例（Foo和Bar）被正常释放了。至于生命周期模式为Root的服务实例Baz和Gux，它的Dispose方法会延迟到作为根容器的Cat对象的Dispose方法被调用的时候。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/201910/19327-20191021083300147-899781160.png&quot;&gt;&lt;img width=&quot;400&quot; height=&quot;287&quot; title=&quot;3-8_thumb2&quot; alt=&quot;3-8_thumb2&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/201910/19327-20191021083300432-2004787700.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在完成针对Cat的编程体验之后，我们来聊聊这个依赖注入容器的设计原理和具体实现。由于作为依赖注入容器的Cat对象总是利用预先添加的服务注册来提供对应的服务实例，所以服务注册至关重要。如下所示的就是表示服务注册的ServiceRegistry的定义，它具有三个核心属性（ServiceType、Lifetime和Factory），分别代表服务类型、生命周期模式和用来创建服务实例的工厂。最终用来创建服务实例的工厂体现为一个类型为Func&amp;lt;Cat,Type[], object&amp;gt;的委托对象，它的两个输入分别代表当前使用的Cat对象以及提供服务类型的泛型参数，如果提供的服务类型并不是一个泛型类型，这个参数被会指定为一个空的数组。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ServiceRegistry
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Type ServiceType { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Lifetime Lifetime { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Func&amp;lt;Cat,Type[], &lt;span&gt;object&lt;/span&gt;&amp;gt; actory { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;internal&lt;/span&gt; ServiceRegistry Next { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ServiceRegistry(Type serviceType, Lifetime lifetime,   Func&amp;lt;Cat,Type[], &lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt; factory)
    {
        ServiceType     &lt;/span&gt;=&lt;span&gt; serviceType;
        Lifetime     &lt;/span&gt;=&lt;span&gt; lifetime;
        Factory     &lt;/span&gt;=&lt;span&gt; factory;
    }

    &lt;/span&gt;&lt;span&gt;internal&lt;/span&gt; IEnumerable&amp;lt;ServiceRegistry&amp;gt;&lt;span&gt; AsEnumerable()
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; list = &lt;span&gt;new&lt;/span&gt; List&amp;lt;ServiceRegistry&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; self = &lt;span&gt;this&lt;/span&gt;; self!=&lt;span&gt;null&lt;/span&gt;; self=&lt;span&gt; self.Next)
        {
            list.Add(self);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; list;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们将针对同一个服务类型（ServiceType属性相同）的多个ServiceRegistry组成一个链表，作为相邻节点的两个ServiceRegistry对象通过Next属性关联起来。我们为ServiceRegistry定义了一个AsEnumerable方法使它返回由当前以及后续节点组成的ServiceRegistry集合。如果当前ServiceRegistry为链表头，那么这个方法会返回链表上的所有ServiceRegistry对象。下图体现了服务注册核心三要素和链表结构。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/201910/19327-20191021083300693-15804931.png&quot;&gt;&lt;img width=&quot;388&quot; height=&quot;134&quot; title=&quot;3-9_thumb2&quot; alt=&quot;3-9_thumb2&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/201910/19327-20191021083300897-261735935.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在了解了表示服务注册的ServiceRegistry之后，我们来着重介绍表示依赖注入容器的Cat类型。如下面的代码片段所示，Cat同时实现了IServiceProvider和IDisposable接口，定义在前者中的GetService方法用于提供服务实例。作为根容器的Cat对象通过公共构造函数创建，另一个内部构造函数则用来创建作为子容器的Cat对象，指定的Cat对象将作为父容器。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Cat : IServiceProvider, IDisposable
{
    &lt;/span&gt;&lt;span&gt;internal&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; Cat                             _root;
    &lt;/span&gt;&lt;span&gt;internal&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; ConcurrentDictionary&amp;lt;Type, ServiceRegistry&amp;gt;&lt;span&gt;     _registries;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; ConcurrentDictionary&amp;lt;Key, &lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt;             _services;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; ConcurrentBag&amp;lt;IDisposable&amp;gt;&lt;span&gt;                 _disposables;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; _disposed;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Cat()
    {
        _registries &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ConcurrentDictionary&amp;lt;Type, ServiceRegistry&amp;gt;&lt;span&gt;();
        _root &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
        _services &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ConcurrentDictionary&amp;lt;Key, &lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt;();
        _disposables &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ConcurrentBag&amp;lt;IDisposable&amp;gt;&lt;span&gt;();
    }

    &lt;/span&gt;&lt;span&gt;internal&lt;/span&gt;&lt;span&gt; Cat(Cat parent)
    {
        _root &lt;/span&gt;=&lt;span&gt; parent._root;
        _registries &lt;/span&gt;=&lt;span&gt; _root._registries;
        _services &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ConcurrentDictionary&amp;lt;Key, &lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt;();
        _disposables &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ConcurrentBag&amp;lt;IDisposable&amp;gt;&lt;span&gt;();
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; EnsureNotDisposed()
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (_disposed)
        {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ObjectDisposedException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Cat&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }
    ...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;作为根容器的Cat对象通过_root字段表示。_registries字段返回的ConcurrentDictionary&amp;lt;Type, ServiceRegistry&amp;gt;对象用来存储所有添加的服务注册，该字典对象的Key和Value分别表示服务类型和ServiceRegistry链表，下图体现这一映射关系。由于需要负责完成对提供服务实例的释放工作，所以我们需要将实现了IDisposable接口的服务实例保存在通过_disposables字段表示的集合中。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/201910/19327-20191021083301169-730832873.png&quot;&gt;&lt;img width=&quot;480&quot; height=&quot;128&quot; title=&quot;3-10_thumb2&quot; alt=&quot;3-10_thumb2&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/201910/19327-20191021083301429-1434341357.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;由当前Cat对象提供的非Transient服务实例保存在由_services字段表示的一个ConcurrentDictionary&amp;lt;Key, object&amp;gt;对象上，该字典对象的键类型为如下所示的Key，它相当于是创建服务实例所使用的ServiceRegistry对象和泛型参数类型数组的组合。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;internal&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Key : IEquatable&amp;lt;Key&amp;gt;&lt;span&gt;
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ServiceRegistry     Registry { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Type[]         GenericArguments { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Key(ServiceRegistry registry, Type[] genericArguments)
    {
        Registry  &lt;/span&gt;=&lt;span&gt; registry;
        GenericArguments &lt;/span&gt;=&lt;span&gt; genericArguments;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; Equals(Key other)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (Registry !=&lt;span&gt; other.Registry)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (GenericArguments.Length !=&lt;span&gt; other.GenericArguments.Length)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; index = &lt;span&gt;0&lt;/span&gt;; index &amp;lt; GenericArguments.Length; index++&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (GenericArguments[index] !=&lt;span&gt; other.GenericArguments[index])
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; GetHashCode()
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; hashCode =&lt;span&gt; Registry.GetHashCode();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; index = &lt;span&gt;0&lt;/span&gt;; index &amp;lt; GenericArguments.Length; index++&lt;span&gt;)
        {
            hashCode &lt;/span&gt;^=&lt;span&gt; GenericArguments[index].GetHashCode();
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; hashCode;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; Equals(&lt;span&gt;object&lt;/span&gt; obj) =&amp;gt; obj &lt;span&gt;is&lt;/span&gt; Key key ? Equals(key) : &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;虽然我们为Cat定义了若干扩展方法来提供多种不同的服务注册，但是这些方法最终都会调用如下这个Register方法，该方法会将提供的ServiceRegistry添加到_registries字段表示的字典对象中。值得注意的是，不论我们是调用哪个Cat对象的Register方法，指定的ServiceRegistry都会被添加到作为根容器的Cat对象上。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Cat : IServiceProvider, IDisposable
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Cat Register(ServiceRegistry registry)
    {
        EnsureNotDisposed();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (_registries.TryGetValue(registry.ServiceType, &lt;span&gt;out&lt;/span&gt; &lt;span&gt;var&lt;/span&gt;&lt;span&gt; existing))
        {
            _registries[registry.ServiceType] &lt;/span&gt;=&lt;span&gt; registry;
            registry.Next &lt;/span&gt;=&lt;span&gt; existing;
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        {
            _registries[registry.ServiceType] &lt;/span&gt;=&lt;span&gt; registry;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
    }
    ...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;用来提供服务实例的核心操作实现在如下这个GetServiceCore方法中。如下面的代码片段所示，我们在调用该方法的时候需要指定对应的ServiceRegistry对象的服务类型的泛型参数。当该方法被执行的时候，对于Transient的生命周期模式，它会直接利用ServiceRegistry提供的工厂来创建服务实例。如果服务实例的类型实现了IDisposable接口，该对象会被添加到_disposables字段表示的待释放服务实例列表中。对于Root和Self生命周期模式，该方法会先根据提供的ServiceRegistry判断是否对应的服务实例已经存在，存在的服务实例会直接返回。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Cat : IServiceProvider, IDisposable
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt; GetServiceCore(ServiceRegistry registry, Type[] genericArguments)
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; key = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Key(registry, genericArguments);
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; serviceType =&lt;span&gt; registry.ServiceType;

        &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (registry.Lifetime)
        {
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; Lifetime.Root: &lt;span&gt;return&lt;/span&gt;&lt;span&gt; GetOrCreate(_root._services, _root._disposables);
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; Lifetime.Self: &lt;span&gt;return&lt;/span&gt;&lt;span&gt; GetOrCreate(_services, _disposables);
            &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
                {
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; service = registry.Factory(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, genericArguments);
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (service &lt;span&gt;is&lt;/span&gt; IDisposable disposable &amp;amp;&amp;amp; disposable != &lt;span&gt;this&lt;/span&gt;&lt;span&gt;)
                    {
                        _disposables.Add(disposable);
                    }
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; service;
                }
        }

        &lt;/span&gt;&lt;span&gt;object&lt;/span&gt; GetOrCreate(ConcurrentDictionary&amp;lt;Key, &lt;span&gt;object&lt;/span&gt;&amp;gt; services,  ConcurrentBag&amp;lt;IDisposable&amp;gt;&lt;span&gt; disposables)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (services.TryGetValue(key, &lt;span&gt;out&lt;/span&gt; &lt;span&gt;var&lt;/span&gt;&lt;span&gt; service))
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; service;
            }
            service &lt;/span&gt;= registry.Factory(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, genericArguments);
            services[key] &lt;/span&gt;=&lt;span&gt; service;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (service &lt;span&gt;is&lt;/span&gt;&lt;span&gt; IDisposable disposable)
            {
                disposables.Add(disposable);
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; service;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;GetServiceCore方法只有在指定ServiceRegistry对应的服务实例不存在的情况下才会利用提供的工厂来创建服务实例，创建的服务实例会根据生命周期模式保存到作为根容器的Cat对象或者当前Cat对象上。如果提供的服务实例实现了IDisposable接口，在采用Root生命周期模式下会被保存到作为根容器的Cat对象的待释放列表中。如果生命周期模式为Self，它会被添加到当前Cat对象的待释放列表中。&lt;/p&gt;
&lt;p&gt;在实现的GetService方法中，Cat会根据指定的服务类型找到对应的ServiceRegistry对象，并最终调用GetServiceCore方法来提供对应的服务实例。GetService方法还会解决一些特殊服务的提供问题，比如若服务类型为Cat或者IServiceProvider，该方法返回的就是它自己。如果服务类型为IEnumerable&amp;lt;T&amp;gt;，GetService方法会根据泛型参数类型T找到所有的ServiceRegistry并利用它们来创建对应的服务实例，最终返回的是由这些服务实例组成的集合。除了这些，针对泛型服务实例的提供也是在这个方法中解决的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Cat : IServiceProvider, IDisposable
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt; GetService(Type serviceType)
    {
        EnsureNotDisposed();

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (serviceType == &lt;span&gt;typeof&lt;/span&gt;(Cat) || serviceType == &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(IServiceProvider))
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
        }

        ServiceRegistry registry;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (serviceType.IsGenericType &amp;amp;&amp;amp; serviceType.GetGenericTypeDefinition() ==  &lt;span&gt;typeof&lt;/span&gt;(IEnumerable&amp;lt;&amp;gt;&lt;span&gt;))
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; elementType = serviceType.GetGenericArguments()[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!_registries.TryGetValue(elementType, &lt;span&gt;out&lt;/span&gt;&lt;span&gt; registry))
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Array.CreateInstance(elementType, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
            }

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; registries =&lt;span&gt; registry.AsEnumerable();
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; services = registries.Select(it =&amp;gt;&lt;span&gt; GetServiceCore(it, Type.EmptyTypes)).ToArray();
            Array array &lt;/span&gt;=&lt;span&gt; Array.CreateInstance(elementType, services.Length);
            services.CopyTo(array, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; array;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Generic&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (serviceType.IsGenericType &amp;amp;&amp;amp; !&lt;span&gt;_registries.ContainsKey(serviceType))
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; definition =&lt;span&gt; serviceType.GetGenericTypeDefinition();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; _registries.TryGetValue(definition, &lt;span&gt;out&lt;/span&gt;&lt;span&gt; registry)
                &lt;/span&gt;?&lt;span&gt; GetServiceCore(registry, serviceType.GetGenericArguments())
                : &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Normal&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; _registries.TryGetValue(serviceType, &lt;span&gt;out&lt;/span&gt;&lt;span&gt; registry)
                &lt;/span&gt;? GetServiceCore(registry, &lt;span&gt;new&lt;/span&gt; Type[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;])
                : &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
    ...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在实现的Dispose方法中，由于所有待释放的服务实例已经保存到_disposables字段表示的集合中，所以我们只需要依次调用它们的Dispose方法即可。在释放了所有服务实例并清空待释放列表后，Dispose还会清空_services字段表示的服务实例列表。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Cat : IServiceProvider, IDisposable
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Dispose()
    {
        _disposed &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; disposable &lt;span&gt;in&lt;/span&gt;&lt;span&gt; _disposables)
        {
            disposable.Dispose();
        }
        _disposables.Clear();
        _services.Clear();
    }
    ...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;为了方便注册服务，我们定义了如下六个Register扩展方法。由于服务注册的添加总是需要调用Cat自身的Register方法来完成，所以这些方法最终都需要创建一个代表服务注册的ServiceRegistry对象。对于一个ServiceRegistry对象来说，它最为核心的元素莫过于表示服务实例创建工厂的Func&amp;lt;Cat,Type[], object&amp;gt;对象，所以上述这六个扩展方法需要解决的就是创建这么一个委托对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;77&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CatExtensions
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Cat Register(&lt;span&gt;this&lt;/span&gt; Cat cat, Type &lt;span&gt;from&lt;/span&gt;&lt;span&gt;, Type to, Lifetime lifetime)
    {
        Func&lt;/span&gt;&amp;lt;Cat, Type[], &lt;span&gt;object&lt;/span&gt;&amp;gt; factory =  (_, arguments) =&amp;gt;&lt;span&gt; Create(_, to, arguments);
        cat.Register(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; ServiceRegistry(&lt;span&gt;from&lt;/span&gt;&lt;span&gt;, lifetime, factory));
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cat;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Cat Register&amp;lt;TFrom, TTo&amp;gt;(&lt;span&gt;this&lt;/span&gt; Cat cat, Lifetime lifetime) &lt;span&gt;where&lt;/span&gt;&lt;span&gt; TTo:TFrom
        &lt;/span&gt;=&amp;gt; cat. Register(&lt;span&gt;typeof&lt;/span&gt;(TFrom), &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(TTo), lifetime);

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Cat Register(&lt;span&gt;this&lt;/span&gt; Cat cat, Type serviceType, &lt;span&gt;object&lt;/span&gt;&lt;span&gt; instance)
    {
        Func&lt;/span&gt;&amp;lt;Cat, Type[], &lt;span&gt;object&lt;/span&gt;&amp;gt; factory = (_, arguments) =&amp;gt;&lt;span&gt; instance;
        cat.Register(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServiceRegistry(serviceType, Lifetime.Root, factory));
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cat;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Cat Register&amp;lt;TService&amp;gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; Cat cat, TService instance)
    {
        Func&lt;/span&gt;&amp;lt;Cat, Type[], &lt;span&gt;object&lt;/span&gt;&amp;gt; factory = (_, arguments) =&amp;gt;&lt;span&gt; instance;
        cat.Register(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; ServiceRegistry(&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(TService),  Lifetime.Root,  factory));
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cat;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Cat Register(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; Cat cat, Type serviceType, 
    Func&lt;/span&gt;&amp;lt;Cat, &lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt; factory, Lifetime lifetime)
    {
        cat.Register(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; ServiceRegistry(serviceType, lifetime,  (_, arguments) =&amp;gt;&lt;span&gt; factory(_)));
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cat;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Cat Register&amp;lt;TService&amp;gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; Cat cat, 
    Func&lt;/span&gt;&amp;lt;Cat,TService&amp;gt;&lt;span&gt; factory, Lifetime lifetime)
    {
        cat.Register(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; ServiceRegistry(&lt;span&gt;typeof&lt;/span&gt;(TService), lifetime,  (_,arguments)=&amp;gt;&lt;span&gt;factory(_)));
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cat;
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt; Create(Cat cat, Type type, Type[] genericArguments)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (genericArguments.Length &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
        {
            type &lt;/span&gt;=&lt;span&gt; type.MakeGenericType(genericArguments);
        }
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; constructors =&lt;span&gt; type.GetConstructors();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (constructors.Length == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; InvalidOperationException($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Cannot create the instance of &lt;/span&gt;
                {type} which does not have a &lt;span&gt;public&lt;/span&gt; constructor.&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;
&lt;span&gt;        }
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; constructor = constructors.FirstOrDefault(it =&amp;gt;   it.GetCustomAttributes(&lt;span&gt;false&lt;/span&gt;).OfType&amp;lt;InjectionAttribute&amp;gt;&lt;span&gt;().Any());
        constructor &lt;/span&gt;??=&lt;span&gt; constructors.First();
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; parameters =&lt;span&gt; constructor.GetParameters();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (parameters.Length == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Activator.CreateInstance(type);
        }
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; arguments = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt;[parameters.Length];
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; index = &lt;span&gt;0&lt;/span&gt;; index &amp;lt; arguments.Length; index++&lt;span&gt;)
        {
            arguments[index] &lt;/span&gt;=&lt;span&gt; cat.GetService(parameters[index].ParameterType);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; constructor.Invoke(arguments);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于前两个重载指定的是服务实现类型，所以我们需要调用对应的构造函数来创建服务实例，这一逻辑实现在私有的Create方法中。第三个扩展方法指定的直接就是服务实例，所以我们很容易将提供的参数转换成一个Func&amp;lt;Cat,Type[], object&amp;gt;。&lt;/p&gt;
&lt;p&gt;我们刻意简化了构造函数的筛选逻辑。为了解决构造函数的选择问题，我们引入如下这个InjectionAttribute特性。我们将所有公共实例构造函数作为候选的构造函数，并会优先选择标注了该特性的构造函数。当构造函数被选择出来后，我们需要通过分析其参数类型并利用Cat对象来提供具体的参数值，这实际上是一个递归的过程。最终我们将针对构造函数的调用转换成Func&amp;lt;Cat,Type[], object&amp;gt;对象，进而创建出表示服务注册的ServiceRegistry对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[AttributeUsage( AttributeTargets.Constructor)]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; InjectionAttribute: Attribute {}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;前面给出的代码片段还提供了HasRegistry和HasRegistry&amp;lt;T&amp;gt;方法来确定指定类型的服务注册是否存在。除此之外，用于提供服务实例的泛型方法GetService&amp;lt;T&amp;gt;和用于提供所有指定类型服务实例的GetServices&amp;lt;TService&amp;gt;方法采用了如下的定义方式。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CatExtensions
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IEnumerable&amp;lt;TService&amp;gt; GetServices&amp;lt;T&amp;gt;(&lt;span&gt;this&lt;/span&gt; Cat cat)  =&amp;gt; cat.GetService&amp;lt;IEnumerable&amp;lt;TService &amp;gt;&amp;gt;&lt;span&gt;();
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; TService GetService&amp;lt;TService &amp;gt;(&lt;span&gt;this&lt;/span&gt; Cat cat)  =&amp;gt; (TService)cat.GetService(&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(T));
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上述六个扩展方法帮助我们完成针对单一服务的注册，有时间我们的项目中可能会出现非常多的服务需要注册，如何能够完成针对它们的批量注册会是不错的选择。我们的依赖注入框架提供了针对程序集范围的批量服务注册。为了标识带注册的服务，我们需要在服务实现类型上标注如下这个MapToAttribute类型，并指定服务类型（一般为它实现的接口或者继承的基类）和生命周期。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
[AttributeUsage( AttributeTargets.Class, AllowMultiple = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;sealed&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MapToAttribute: Attribute
{       
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Type     ServiceType { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Lifetime     Lifetime { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; MapToAttribute(Type serviceType, Lifetime lifetime)
    {
        ServiceType &lt;/span&gt;=&lt;span&gt; serviceType;
        Lifetime &lt;/span&gt;=&lt;span&gt; lifetime;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;针对程序集范围的批量服务注册实现在Cat的如下这个Register扩展方法中。如下面的代码片段所示，该方法会从指定程序集中获取所有标注了MapToAttribute特性的类型，并提取出服务类型、实现类型和生命周期模型，然后利用它们批量完成所需的服务注册。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CatExtensions
{   
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Cat Register(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; Cat cat, Assembly assembly)
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; typedAttributes = &lt;span&gt;from&lt;/span&gt; type &lt;span&gt;in&lt;/span&gt;&lt;span&gt; assembly.GetExportedTypes()
            let attribute &lt;/span&gt;= type.GetCustomAttribute&amp;lt;MapToAttribute&amp;gt;&lt;span&gt;()
            &lt;/span&gt;&lt;span&gt;where&lt;/span&gt; attribute != &lt;span&gt;null&lt;/span&gt;
            &lt;span&gt;select&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; { ServiceType = type, Attribute =&lt;span&gt; attribute };
        &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; typedAttribute &lt;span&gt;in&lt;/span&gt;&lt;span&gt; typedAttributes)
        {
            cat.Register(typedAttribute.Attribute.ServiceType, 
                typedAttribute.ServiceType, typedAttribute.Attribute.Lifetime);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cat;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;除了上述这七个用来注册服务的Register扩展方法，我们还为Cat类型定义了如下两个扩展方法，其中CreateService&amp;lt;T&amp;gt;方法以泛型参数的形式指定获取服务实例对应注册的类型，CreateServices&amp;lt;T&amp;gt;方法会提供指定服务类型的所有实例，而CreateChild方法则帮助我们创建一个代表子容器的Cat对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CatExtensions
{   
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; T GetService&amp;lt;T&amp;gt;(&lt;span&gt;this&lt;/span&gt; Cat cat) =&amp;gt; (T)cat.GetService(&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(T));
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IEnumerable&amp;lt;T&amp;gt; GetServices&amp;lt;T&amp;gt;(&lt;span&gt;this&lt;/span&gt; Cat cat) =&amp;gt; cat.GetService&amp;lt;IEnumerable&amp;lt;T&amp;gt;&amp;gt;&lt;span&gt;();
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Cat CreateChild(&lt;span&gt;this&lt;/span&gt; Cat cat) =&amp;gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Cat(cat);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-01.html&quot;&gt;[ASP.NET Core 3框架揭秘] 依赖注入：控制反转&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-02.html&quot;&gt;[ASP.NET Core 3框架揭秘] 依赖注入：IoC模式&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-03.html&quot;&gt;[ASP.NET Core 3框架揭秘] 依赖注入：依赖注入模式&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-04.html&quot;&gt;[ASP.NET Core 3框架揭秘] 依赖注入：一个迷你版DI框架&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 21 Oct 2019 00:30:00 +0000</pubDate>
<dc:creator>Artech</dc:creator>
<og:description>在前面的章节中，我们从纯理论的角度对依赖注入进行了深入论述，我们接下来会对.NET Core依赖注入框架进行单独介绍。为了让读者朋友能够更好地理解.NET Core依赖注入框架的设计与实现，我们按照类</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/artech/p/inside-asp-net-core-03-04.html</dc:identifier>
</item>
<item>
<title>基于 Web 端 3D 地铁站可视化系统 - xhload3d</title>
<link>http://www.cnblogs.com/xhload3d/p/11711422.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xhload3d/p/11711422.html</guid>
<description>&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;工业互联网，物联网，可视化等名词在我们现在信息化的大背景下已经是耳熟能详，日常生活的交通，出行，吃穿等可能都可以用信息化的方式来为我们表达，在传统的可视化监控领域，一般都是基于 Web SCADA 的前端技术来实现 2D 可视化监控，本系统采用 Hightopo 的 HT for Web 产品来构造轻量化的 3D 可视化场景，该 3D 场景从正面展示了一个地铁站的现实场景，包括地铁的实时运行情况，地铁上下行情况，视频监控，烟雾报警，电梯运行情况等等，帮助我们直观的了解当前的地铁站。&lt;/p&gt;
&lt;p&gt;系统中为了帮助用户更直观友好的浏览当前地铁站，提供了三种交互模式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一人称模式 -- 操作就类似行人或车在行进的效果，可以通过键盘鼠标控制前进后退。&lt;/li&gt;
&lt;li&gt;自动巡检模式 -- 该模式下用户不需要任何操作，场景自动前进后退来巡查当前地铁站的场景。&lt;/li&gt;
&lt;li&gt;鼠标操作模式 -- 左键旋转场景，右键平移场景。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;本篇文章通过对地铁站可视化场景的搭建，动画代码的实现，交互模式的原理解析，以及主要功能点的实现进行阐述，帮助我们了解如何使用 &lt;strong&gt;&lt;a href=&quot;https://hightopo.com/&quot; target=&quot;_blank&quot;&gt;HT&lt;/a&gt;&lt;/strong&gt; 实现一个简单的地铁站可视化。&lt;/p&gt;
&lt;p&gt;预览地址：&lt;a href=&quot;http://www.hightopo.com/demo/ht-subway/&quot; target=&quot;_blank&quot;&gt;基于 HTML5 WebGL 的地铁站 3D 可视化系统&lt;/a&gt; &lt;a href=&quot;http://www.hightopo.com/demo/ht-subway/&quot; target=&quot;_blank&quot;&gt;http://www.hightopo.com/demo/ht-subway/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;界面简介及效果预览&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;地铁运行效果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/591709/201902/591709-20190217222130192-613344785.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;地铁从站外开到站内的效果为透明度逐渐增加，速度逐渐降低。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;漫游效果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/591709/201902/591709-20190217222206241-1220111661.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上述为自动巡检的漫游效果，场景自动进行前进旋转。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;监控设备交互效果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/591709/201902/591709-20190217222239338-650547517.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当我们点击场景中的监控设备时可以查看当前设备的运行情况，运行数据等信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;场景搭建&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;该系统中的大部分模型都是通过 3dMax 建模生成的，该建模工具可以导出 obj 与 mtl 文件，在 HT 中可以通过解析 obj 与 mtl 文件来生成 3d 场景中的所有复杂模型，当然如果是某些简单的模型可以直接使用 HT 来绘制，这样会比 obj 模型更轻量化，所以大部分简单的模型都是采用 &lt;strong&gt;HT for Web&lt;/strong&gt; 产品轻量化 &lt;strong&gt;HTML5/WebGL&lt;/strong&gt; 建模的方案，具体的解析代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
 1 // 分别为 obj 文件地址，mtl 文件地址
 2 ht.Default.loadObj('obj/metro.obj', 'obj/metro.mtl', {
 3     center: true,
 4     // 模型是否居中，默认为 false，设置为 true 则会移动模型位置使其内容居中
 5     r3: [0, -Math.PI / 2, 0],
 6     // 旋转变化参数，格式为 [rx, ry, rz]
 7     s3: [0.15, 0.15, 0.15],
 8     // 大小变化参数，格式为 [sx, sy, sz]
 9     finishFunc: function(modelMap, array, rawS3) {
10         if (modelMap) {
11             ht.Default.setShape3dModel('metro', array); // 注册一个名字为 metro 的模型
12         }
13     }
14 });
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;上面通过加载 obj 模型之后注册了一个名字为 &lt;strong&gt;metro&lt;/strong&gt; 的模型，之后如果要使用该模型可以通过以下代码来实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
1 var node = new ht.Node();
2 node.s({
3     'shape3d': 'metro'
4 });
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面代码新建了一个 &lt;strong&gt;node&lt;/strong&gt; 对象，通过设置 style 对象的 &lt;strong&gt;shape3d&lt;/strong&gt; 属性可以把模型名称为 &lt;strong&gt;metro&lt;/strong&gt; 用到该 node 对象上去，之后便是我们场景中看到的地铁列车模型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;动画代码分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;地铁动画代码的实现分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;场景中地铁的运行是通过 HT 提供的调度插件来实现，&lt;strong&gt;调度&lt;/strong&gt;的具体用法可以参考 HT for Web 的&lt;a href=&quot;http://www.hightopo.com/guide/guide/core/schedule/ht-schedule-guide.html&quot; target=&quot;_blank&quot;&gt;调度手册&lt;/a&gt;，该调度主要用于在指定的时间间隔进行函数回调处理，回调函数的第一个参数为 data 图元，也就是 3D 场景中的模型节点，我们可以判断当前 data 是否为我们刚才创建的 metro 那个节点来进行后续的操作，场景中模拟了一个左开的地铁和一个右开的地铁，两辆地铁会交替出现。在 3D 场景中肯定会有坐标系，HT 中是用 x, y, z 来分别表示三个轴，所以地铁的运动肯定是改变地铁在坐标系中的位置来实现地铁的运行，地铁坐标如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/591709/201902/591709-20190217222835256-173997617.jpg&quot; alt=&quot;&quot; width=&quot;640&quot; height=&quot;390&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过上图可以知道地铁在 3D 场景中的坐标系，如果要实现地铁的移动则只需要将地铁往图中所示红色箭头的方向进行移动，即 &lt;strong&gt;x&lt;/strong&gt; 轴的方向，通过 &lt;strong&gt;setX&lt;/strong&gt; 这个方法不断的修改地铁的位置达到地铁行进的目的，代码中通过 getSpeedByX 以及 getOpacityByX 两个方法来不断获取此时的列车速度以及列车透明度，以下为关键代码实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
 1 let metroTask = {
 2     interval: 50,
 3     // 每五十秒执行一次
 4     action: (data) = &amp;gt;{ // 即上文所提回调函数
 5         // 判断当时传进来的节点是否为地铁列车节点
 6         if (data === currentMetro) {
 7             // 获取地铁此时的 X 轴位置以及行进的方向
 8             let currentX = data.getX(),
 9             direction = data.a('direction');
10             // 根据当前的 X 轴位置获取当前的列车速度
11             let speed = this.getSpeedByX(currentX);
12             // 根据当前的 X 轴位置获取当前的列车透明度
13             let opacity = this.getOpacityByX(currentX);
14             // 判断此时 X 轴位置是否超过某个值 即地铁是在某个范围内移动
15             if (Math.abs(currentX) &amp;lt;= 5000) {
16                 // 设置当前的透明度
17                 opacity !== 1 ? currentMetro.s({
18                     'shape3d.transparent': true,
19                     'shape3d.opacity': opacity
20                 }) : currentMetro.s({
21                     'shape3d.transparent': false
22                 });
23                 // 设置当前的 X 轴位置
24                 data.setX(currentX + direction * speed);
25                 // 判断此时地铁的速度为 0，所以此时应该执行开门的动画
26                 if (speed === 0) this.doorAnimation(currentMetro, direction);
27             }
28             // 右方向地铁开到头，进行复位
29             if (currentX &amp;gt; 5000 &amp;amp;&amp;amp; direction === 1) {
30                 currentMetro = leftMetro;
31                 currentMetro.setX(5000);
32             }
33             // 左方向地铁开到头，进行复位
34             if (currentX &amp;lt; -5000 &amp;amp;&amp;amp; direction === -1) {
35                 currentMetro = rightMetro;
36                 currentMetro.setX( - 5000);
37             }
38         }
39     }
40 };
41 dm3d.addScheduleTask(metroTask);
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;通过以上代码可以知道地铁在运行的过程中，主要通过修改地铁的 &lt;strong&gt;x&lt;/strong&gt; 轴位置来产生前进的动画，并且需要让地铁在某个区间内进行运动，需要判断边界，而且为了模拟出真实的效果需要根据地铁当前的位置不断获取当前的列车速度以及列车透明度，以下为流程图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/591709/201902/591709-20190217223350025-341511583.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图所示的为地铁进站时候的流程，当地铁停靠完毕关门后需要进行出站，此时我们只需要把地铁位置重新设置一下不为 0 即可，以下为部分代码实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
1 currentMetro.setX(direction * 10); // 设置出站列车的位置
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当执行上面那句代码之后上方的 &lt;strong&gt;metroTask&lt;/strong&gt; 调度任务执行到 getSpeedByX 这个方法之后获取到的 speed 速度不为 0，因此此时会继续执行地铁行进的动画，此时的速度就是由慢至快，透明度由深至浅。以下为开门动画执行流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/591709/201902/591709-20190217223609315-838709115.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;自动巡检代码的实现分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;系统中自动巡检的实现主要是通过修改 3D 场景中的 &lt;strong&gt;eye&lt;/strong&gt; 以及 &lt;strong&gt;center&lt;/strong&gt; 的值，&lt;strong&gt;HT&lt;/strong&gt; 中提供了 &lt;strong&gt;rotate&lt;/strong&gt;，&lt;strong&gt;walk&lt;/strong&gt; 两个方法来控制视角的旋转以及视角的行进，&lt;strong&gt;rotate&lt;/strong&gt; 方法在非第一人称模式时，旋转是以 &lt;strong&gt;center&lt;/strong&gt; 为中心进行旋转，也就是围绕中心物体旋转，当为第一人称时旋转以 &lt;strong&gt;eye&lt;/strong&gt; 为中心进行旋转，也就是旋转眼睛朝向方向。&lt;strong&gt;walk&lt;/strong&gt; 函数同时改变 &lt;strong&gt;eye&lt;/strong&gt; 和 &lt;strong&gt;center&lt;/strong&gt; 的位置，也就是 &lt;strong&gt;eye&lt;/strong&gt; 和 &lt;strong&gt;center&lt;/strong&gt; 在两点建立的矢量方向上同时移动相同的偏移量。该系统中我没有采用 &lt;strong&gt;rotate&lt;/strong&gt; 函数而是自己实现了视角的旋转，因为原本的 rotate 函数旋转某个角度会马上旋转过去而不会有一个旋转的过程，所以我重新实现了旋转的方法，该系统中视角旋转是通过不断修改 &lt;strong&gt;center&lt;/strong&gt; 的数值来实现，具体实现过程原理如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/591709/201902/591709-20190217223813536-1894778998.jpg&quot; alt=&quot;&quot; width=&quot;794&quot; height=&quot;266&quot;/&gt;&lt;/p&gt;
&lt;p&gt;部分实现代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
 1 rotateStep() {
 2     // 即上图辅助点 C
 3     let fromCenter = this.fromCenter;
 4     // 即上图 B 点
 5     let toCenter = this.toCenter;
 6     // 每帧转一度
 7     let rotateValue = this.rotateFrame || Math.PI / 180;
 8     // 辅助点 C 与 B 点之间建立一个方向向量
 9     let centerVector = new ht.Math.Vector2(toCenter.x - fromCenter.x, toCenter.y - fromCenter.y);
10     let centerVectorLength = centerVector.length();
11     // 此时旋转百分比
12     let rotatePercent = rotateValue * this.stepNum / this.curRotateVal;
13     if (rotatePercent &amp;gt;= 1) {
14         rotatePercent = 1;
15         this.stepNum = -2;
16     }
17     let newLength = rotatePercent * centerVectorLength;
18     centerVector.setLength(newLength);
19     let newCenterVector = centerVector.add(fromCenter);
20     // 获取旋转过程中 center 的点信息
21     let newCenterPosition = [newCenterVector.x, this.personHeight, newCenterVector.y];
22     // 设置当前 center 的大小
23     this.g3d.setCenter(newCenterPosition);
24 }
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;通过上述代码就实现了场景中的视角旋转，并且可以通过修改 &lt;strong&gt;rotateValue&lt;/strong&gt; 的值控制旋转的速度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;电梯动画代码的实现分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;场景中电梯是一个 obj 模型，3D 模型是由最基础的三角形面拼接合成，例如 1 个矩形可以由 2 个三角形构成，1 个立方体由 6 个面即 12 个三角形构成，以此类推更复杂的模型可以由许多的小三角形组合合成。因此 3D 模型定义即为对构造模型的所有三角形的描述，而每个三角形由三个顶点 vertex 构成，每个顶点 vertex 由 x, y, z 三维空间坐标决定，HT 中使用 &lt;strong&gt;vs&lt;/strong&gt; 数组记录构成三角面的所有顶点坐标，所以如果想要让电梯运行起来，只需要把所有的顶点坐标往电梯运行的方向进行平移，以下为部分关键伪代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
 1 // vs 指的是构成电梯模型所有的三角面顶点坐标数组
 2 // 由于场景中电梯的运行方向为往对角线右上方运动，所以只需要修改 x 轴以及 y 轴坐标值
 3 // xStep yStep 为每次电梯运动的距离
 4 setInterval(() = &amp;gt;{
 5     // i+3 是因为 vs 数组的顺序为 x, y, z 轴 所以每次 i 偏移三个单位大小
 6     for (let i = 0, l = vs.length; i &amp;lt; l; i = i + 3) {
 7         // 该顶点坐标下一个 x 轴坐标的值
 8         let nextX = vs[i] - xStep;
 9         // 该顶点坐标下一个 y 轴坐标的值
10         let nextY = vs[i + 1] + yStep;
11         vs[i] = nextX &amp;lt; -0.5 ? 0.5 - (Math.abs(nextX) - 0.5) : nextX;
12         vs[i + 1] = nextY &amp;gt; 0.5 ? -0.5 + (Math.abs(nextY) - 0.5) : nextY;
13     }
14 },
15 200);
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;电梯运动动画如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/591709/201902/591709-20190217224148875-2007009013.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;监控功能展示及介绍&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;视频监控&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当点击场景中的摄像头之后右侧顶部会显示出当前摄像头的监控画面，以下为实现效果图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/591709/201902/591709-20190217224224092-1535497454.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;烟雾报警监控&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;烟雾报警会根据后台实时传递过来的状态值来变换当前烟雾报警模型的颜色，红色为报警状态，以下为实现效果图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/591709/201902/591709-20190217224253149-224991118.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;电视列车到站时间监控&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;日常地铁站中会有专门的电视来展示下一班地铁到站的时间表，该系统中也模拟该效果，不过该系统暂时做了电视的模型，时间暂无对接，以下为效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/591709/201902/591709-20190217224314244-590196035.jpg&quot; alt=&quot;&quot; width=&quot;836&quot; height=&quot;509/&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;场景监控交互&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;3D 场景中交互是比较简单的，主要是点击摄像头展示 2D 监控面板，在 2D 界面中主要是切换三种交互模式，三种交互模式为互斥的关系，以下是 3D 交互注册事件代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
 1 g3d.mi((e) = &amp;gt;{
 2     let {
 3         g2d,
 4         dm2d
 5     } = this;
 6     // 为点击类型
 7     if (e.kind === 'clickData') {
 8         // data 为当前点击的图元
 9         let data = e.data;
10         // 当前图元的 shape3d 类型
11         let shape3d = data.s('shape3d');
12         // 判断当前 shape3d 类型是否为摄像头
13         if (shape3d &amp;amp;&amp;amp; shape3d.indexOf('摄像头') &amp;gt; 0) {
14             let cameraPanel = dm2d.getDataByTag('cameraPanel');
15             // toggle 切换摄像头 2d 面板
16             g2d.isVisible(cameraPanel) ? cameraPanel.s('2d.visible', false) : cameraPanel.s('2d.visible', true);
17         }
18     }
19     // 为点击 3d 场景背景类型
20     if (e.kind === 'clickBackground') {
21         let cameraPanel = dm2d.getDataByTag('cameraPanel');
22         // 隐藏摄像头 2d 面板
23         g2d.isVisible(cameraPanel) &amp;amp;&amp;amp; cameraPanel.s('2d.visible', false);
24     }
25 });
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;工业互联网将人，数据和机器连接起来，地铁站 3D 可视化系统则是一个很好的展现，HT 的轻量化，数据的可视化，机器的可视化，资产的管理化帮助我们更好的监控。而物联网将通过各种信息传感设备，实时采集任何需要监控、连接、互动的物体或过程等各种需要的信息，通过与 HT 的结合更好的展现出可视化的优势，当然地铁站还可以与 &lt;strong&gt;VR&lt;/strong&gt; 进行结合，在各地科技展会中我们可以见到各种 &lt;strong&gt;VR&lt;/strong&gt; 场景操作，&lt;strong&gt;HT&lt;/strong&gt; 中也可以结合 &lt;strong&gt;VR&lt;/strong&gt; 设备进行操作，可以戴上设备在地铁站中漫游，让人有身临其境的感觉，由于场景本身的轻量化，所以 &lt;strong&gt;VR&lt;/strong&gt; 场景下的流畅性也是十分的高，让用户不会有头晕的感觉。当然系统本身也可以在移动端运行，以下为移动端运行截图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/591709/201902/591709-20190217224707332-642327379.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;程序运行截图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/591709/201902/591709-20190217224728536-2122459047.jpg&quot; alt=&quot;&quot; width=&quot;836&quot; height=&quot;509&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/591709/201902/591709-20190217224820627-367557523.jpg&quot; alt=&quot;&quot; width=&quot;836&quot; height=&quot;509&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 21 Oct 2019 00:30:00 +0000</pubDate>
<dc:creator>xhload3d</dc:creator>
<og:description>前言 工业互联网，物联网，可视化等名词在我们现在信息化的大背景下已经是耳熟能详，日常生活的交通，出行，吃穿等可能都可以用信息化的方式来为我们表达，在传统的可视化监控领域，一般都是基于 Web SCAD</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xhload3d/p/11711422.html</dc:identifier>
</item>
<item>
<title>C#刷遍Leetcode面试题系列连载（4）：No.633 - 平方数之和 - dotNET匠人</title>
<link>http://www.cnblogs.com/enjoy233/p/csharp_leetcode_series_4.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/enjoy233/p/csharp_leetcode_series_4.html</guid>
<description>&lt;p&gt;上篇文章中一道数学问题 - &lt;strong&gt;自除数&lt;/strong&gt;，今天我们接着分析 LeetCode 中的另一道数学题吧~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/436938/201910/436938-20191021080627267-1662633830.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;今天要给大家分析的面试题是 LeetCode 上第 &lt;strong&gt;633&lt;/strong&gt; 号问题，&lt;/p&gt;
&lt;p&gt;Leetcode 633 - 平方数之和&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/sum-of-square-numbers/&quot; class=&quot;uri&quot;&gt;https://leetcode.com/problems/sum-of-square-numbers/&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;题目描述&quot;&gt;题目描述&lt;/h3&gt;
&lt;p&gt;给定一个非负整数 &lt;span&gt;c&lt;/span&gt; ，你要判断是否存在两个整数 &lt;span&gt;a&lt;/span&gt;和 &lt;span&gt;b&lt;/span&gt;，使得 &lt;span class=&quot;math inline&quot;&gt;\(a^2 + b^2 = c\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例1:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;输入: 5
输出: True
解释: 1 * 1 + 2 * 2 = 5&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例2:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;输入: 3
输出: False&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;5
2
100&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Expected answer:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;true
true
true&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;相关话题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;相似题目&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;解题思路:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;做一次循环，用目标和减去循环变量的平方，如果剩下的部分依然是完全平方的情形存在，就返回true；否则返回false。&lt;/p&gt;
&lt;p&gt;假定 $i \leq a \leq b $，根据数据的对称性，循环变量 &lt;span&gt;&lt;em&gt;i&lt;/em&gt;&lt;/span&gt; 只需取到 $i^2 \cdot 2 \leq c $ 即可覆盖所有情形.&lt;/p&gt;
&lt;p&gt;已AC代码:&lt;/p&gt;
&lt;p&gt;最初版本:&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class Solution
{
    public bool JudgeSquareSum(int c)
    {           
        for (int i = 0; c - 2 * i * i &amp;gt;= 0; i++)
        {
            double diff = c - i*i;
            if ((int)(Math.Ceiling(Math.Sqrt(diff))) == (int)(Math.Floor(Math.Sqrt(diff))))  // 若向上取整=向下取整，则该数开方后是整数
                return true;
        }

        return false;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Rank:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;执行用时: &lt;code&gt;56 ms&lt;/code&gt;, 在所有 csharp 提交中击败了&lt;code&gt;68.18%&lt;/code&gt;的用户.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优化1:&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class Solution
{
    public bool JudgeSquareSum(int c)
    {           
        for (int i = 0; c - 2 * i * i &amp;gt;= 0; i++)
        {
            int diff = c - i*i;
            if (IsPerfectSquare(diff))
                return true;
        }

        return false;
    }
    private bool IsPerfectSquare(int num)
    {
        double sq1 = Math.Sqrt(num);
        int sq2 = (int)Math.Sqrt(num);
        if (Math.Abs(sq1 - (double)sq2) &amp;lt; 10e-10)
            return true;
        return false;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Rank:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;执行用时: &lt;code&gt;52 ms&lt;/code&gt;, 在所有 csharp 提交中击败了&lt;code&gt;90.91%&lt;/code&gt;的用户.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优化2&lt;/strong&gt;(根据文末参考资料[1]中&lt;em&gt;MPUCoder&lt;/em&gt; 的回答改写):&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class Solution
{
    public bool JudgeSquareSum(int c)
    {           
        for (int i = 0; i &amp;lt;= c &amp;amp;&amp;amp; c - i * i &amp;gt;= 0; i++)
        {
            int diff = c - i*i;
            if (IsPerfectSquare(diff))
                return true;
        }

        return false;
    }
    public bool IsPerfectSquare(int num)
    {
        if ((0x0213 &amp;amp; (1 &amp;lt;&amp;lt; (num &amp;amp; 15))) != 0)  //TRUE only if n mod 16 is 0, 1, 4, or 9
        {
            int t = (int)Math.Floor(Math.Sqrt((double)num) + 0.5);
            return t * t == num;
        }
        return false;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Rank:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;执行用时: &lt;code&gt;44 ms&lt;/code&gt;, 在所有 csharp 提交中击败了&lt;code&gt;100.00%&lt;/code&gt;的用户.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/436938/201910/436938-20191021080551659-2049622163.png&quot; alt=&quot;LeetCode-dotNET匠人&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优化3&lt;/strong&gt;(根据文末参考资料[1]中 &lt;em&gt;Simon&lt;/em&gt; 的回答改写):&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class Solution
{
    public bool JudgeSquareSum(int c)
    {           
        for (int i = 0; c - i * i &amp;gt;= 0; i++)
        {
            long diff = c - i*i;
            if (IsSquareFast(diff))
                return true;
        }

        return false;
    }

    bool IsSquareFast(long n)
    {
        if ((0x2030213 &amp;amp; (1 &amp;lt;&amp;lt; (int)(n &amp;amp; 31))) &amp;gt; 0)
        {
            long t = (long)Math.Round(Math.Sqrt((double)n));
            bool result = t * t == n;
            return result;
        }
        return false;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Rank:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;执行用时: &lt;code&gt;48 ms&lt;/code&gt;, 在所有 csharp 提交中击败了&lt;code&gt;100.00%&lt;/code&gt;的用户.&lt;/p&gt;
&lt;p&gt;另外，stackoverflow上还推荐了一种写法：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class Solution
{
    public bool JudgeSquareSum(int c)
    {           
        for (int i = 0; c - 2 * i * i &amp;gt;= 0; i++)
        {
            double diff = c - i*i;
            if (Math.Abs(Math.Sqrt(diff) % 1) &amp;lt; 0.000001)
                return true;
        }

        return false;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;事实上，速度并不快~&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Rank:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;执行用时: &lt;code&gt;68 ms&lt;/code&gt;, 在所有 csharp 提交中击败了&lt;code&gt;27.27%&lt;/code&gt;的用户.&lt;/p&gt;
&lt;p&gt;相应代码已经上传到github:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/yanglr/Leetcode-CSharp/tree/master/leetcode633&quot; class=&quot;uri&quot;&gt;https://github.com/yanglr/Leetcode-CSharp/tree/master/leetcode633&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考资料:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;[1] Fast way to test whether a number is a square&lt;br/&gt;&lt;a href=&quot;https://www.johndcook.com/blog/2008/11/17/fast-way-to-test-whether-a-number-is-a-square/&quot; class=&quot;uri&quot;&gt;https://www.johndcook.com/blog/2008/11/17/fast-way-to-test-whether-a-number-is-a-square/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[2] Shortest way to check perfect Square? - C#&lt;br/&gt;&lt;a href=&quot;https://stackoverflow.com/questions/4885925/shortest-way-to-check-perfect-square/4886006#4886006&quot; class=&quot;uri&quot;&gt;https://stackoverflow.com/questions/4885925/shortest-way-to-check-perfect-square/4886006#4886006&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 21 Oct 2019 00:08:00 +0000</pubDate>
<dc:creator>dotNET匠人</dc:creator>
<og:description>dotNET匠人 C#刷遍Leetcode面试题系列连载（4） No.633 - 平方数之和</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/enjoy233/p/csharp_leetcode_series_4.html</dc:identifier>
</item>
<item>
<title>TensorFlow2.0（7）：激活函数 - 奥辰</title>
<link>http://www.cnblogs.com/chenhuabin/p/11711379.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenhuabin/p/11711379.html</guid>
<description>[unable to retrieve full-text content]激活函数是深度学习，亦或者说人工神经网络中一个十分重要的组成部分，它可以对神经元的接收信息进行非线性变换，将变换后的信息输出到下一层神经元。</description>
<pubDate>Mon, 21 Oct 2019 00:03:00 +0000</pubDate>
<dc:creator>奥辰</dc:creator>
<og:description>激活函数是深度学习，亦或者说人工神经网络中一个十分重要的组成部分，它可以对神经元的接收信息进行非线性变换，将变换后的信息输出到下一层神经元。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chenhuabin/p/11711379.html</dc:identifier>
</item>
<item>
<title>java架构之路-（Redis专题）Redis的高性能和持久化 - oO从零开始Oo</title>
<link>http://www.cnblogs.com/cxiaocai/p/11707699.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cxiaocai/p/11707699.html</guid>
<description>&lt;p&gt;　　上次我们简单的说了一下我们的redis的安装和使用，这次我们来说说redis为什么那么快和持久化数据&lt;/p&gt;
&lt;p&gt;　　在我们现有的redis中(5.0.*之前的版本)，Redis都是单线程的，那么单线程的Redis为什么还会有那么高的效率呢？因为它所有的数据都在内存中，所有的运算都是内存级别的运算，而且单线程避免了多线程的切换中性能损耗的问题，正因为Redis是单线程，所以我们要小心使用Redis指令，对于那些耗时的指令(比如keys)，我们一定要谨慎使用。&lt;/p&gt;
&lt;p&gt;　　在并发环境中，我们Redis的单线程并不是线程1请求了，而我们的线程2就无法继续请求了，而他的内部是采用了IO多路复用，redis利用epoli来实现IO多路复用，将连接信息和事件放在队列中，依次放到事件分派器，事件分派器将事件分发给我们的事件处理器来执行指令操作。&lt;/p&gt;
&lt;p&gt;　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1506597/201910/1506597-20191020133824114-531927482.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　redis默认支持最大连接数是10000，我们通过设置我们的redis.conf来指定我们的最大连接数，# maxclients 10000 =&amp;gt; maxclients 100，大致在539行，或者我们输入/maxclients 可以快速查找到我们需要改的配置，进入我们的客户端，输入$ CONFIG GET maxclients，即可查看我们的客户端最大连接数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;127.0.0.1&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&lt;span&gt;&amp;gt; CONFIG GET maxclients
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;maxclients&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;高级命令&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　我们输入keys *，既可以返回我们的全部键的数据，一般不推荐使用，如果数据量过大，会相当消耗性能的。&lt;/p&gt;
&lt;p&gt;　　scan，scan提供了三个参数，第一个是cursor整数值，第二个是key的正则模式。第三个是第一次遍历的key的数量，并不是符合条件的结果的数量，第一次遍历时，cursor值为0，然后我们将返回结果中第一个整数作为下一次遍历的cursor。一直遍历到cursor值为0时结束。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;127.0.0.1&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt; scan &lt;span&gt;0&lt;/span&gt; match key* count &lt;span&gt;5&lt;/span&gt;
&lt;span&gt;1&lt;/span&gt;) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;) &lt;span&gt;1&lt;/span&gt;) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key6&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
   &lt;span&gt;2&lt;/span&gt;) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key4&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
   &lt;span&gt;3&lt;/span&gt;) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;127.0.0.1&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt; scan &lt;span&gt;6&lt;/span&gt; match key* count &lt;span&gt;5&lt;/span&gt;
&lt;span&gt;1&lt;/span&gt;) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;) &lt;span&gt;1&lt;/span&gt;) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
   &lt;span&gt;2&lt;/span&gt;) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
   &lt;span&gt;3&lt;/span&gt;) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Info：查看redis服务运行信息，分为 9 大块，每个块都有非常多的参数，这 9 个块分别是: &lt;/p&gt;
&lt;p&gt;Server 服务器运行的环境参数 &lt;/p&gt;
&lt;p&gt;Clients 客户端相关信息 &lt;/p&gt;
&lt;p&gt;Memory 服务器运行内存统计数据 &lt;/p&gt;
&lt;p&gt;Persistence 持久化信息 &lt;/p&gt;
&lt;p&gt;Stats 通用统计数据 &lt;/p&gt;
&lt;p&gt;Replication 主从复制相关信息 &lt;/p&gt;
&lt;p&gt;CPU CPU 使用情况 &lt;/p&gt;
&lt;p&gt;Cluster 集群信息 &lt;/p&gt;
&lt;p&gt;KeySpace 键值对统计数量信息&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;日志&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;redis.conf文件配置logfile来配置我们的log日志信息。大概在137行。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
logfile &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;logForRedis.log&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt; &lt;span&gt;&lt;strong&gt;Redis持久化&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　持久化主要分为三种，RDB，AOF和混合模式(4.0.*以后的模式)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RDB快照模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　在默认情况下，Redis将内存数据库快照保存为*.rdb的二进制文件。我用的是5.0.5版本，默认是开启我们的RDB快照模式的，大致在253行，我们看到dbfilename dump.rdb，就是我们要以dump.rdb的文件来存储，存储位置在263行的dir ./ 也就是我们的当前路径（这里可以设置绝对路径）。&lt;strong&gt;　　&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　我们在大概218行可以看到三个save，也就是我们RDB的保存策略&lt;/p&gt;
&lt;p&gt;save 900 1 //表示在900秒内，发生了一次&lt;span&gt;变动&lt;/span&gt;，我们就生成一次快照，变动只是数据的变动，get并不算变动&lt;/p&gt;
&lt;p&gt;save 300 10 //表示在300秒内，发生了十次变动，我们就生成一次快照&lt;/p&gt;
&lt;p&gt;save 60 10000 //表示在60秒内，发生了一万次变动，我们就生成一次快照&lt;/p&gt;
&lt;p&gt;三者条件满足其一就保存一次，他们之间是一个或者的关系，如果三个条件都未满足，这时宕机可能造成数据的丢失。&lt;/p&gt;
&lt;p&gt;　　我们还可以通过进入redis-cli客户端以后，我们手动输入save或者bgsave来生成我们的dump.rdb文件。我们的redis服务端配置是采用bgsave的方式来保存的。我们来看一下save和bgsave的比较。&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;命令&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;save&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;bgsave&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;IO类型&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;同步&lt;/td&gt;
&lt;td&gt;异步&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;strong&gt;是否阻塞redis其它命令&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;否（在生成子进程执行调用fork函数时会有超级短暂的阻塞）&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;时间复杂度&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;O(n)&lt;/td&gt;
&lt;td&gt;O(n)&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;优点&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;不会消耗额外内存&lt;/td&gt;
&lt;td&gt;不阻塞客户端命令&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;缺点&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;阻塞客户端命令&lt;/td&gt;
&lt;td&gt;需要fork子进程，消耗内存&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;AOF命令模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　我们为什么成为AOF叫做命令模式呢？我们的AOF其实是保存了我们每一个操作的动作，也就是我们每一个Redis指令，我们只需要设置appendonly yes即可，大概在699行。下面的appendfilename是我们需要保存aof的文件名，rdb中提到的dir对应的也是aof文件的保存路径。这样的持久化，其实也不是每次都要向磁盘写入数据的，他有三个选项供我们来修改。&lt;/p&gt;
&lt;p&gt;　　appendfsync always：每次有新命令追加到 AOF 文件时就执行一次 fsync ，非常慢，也非常安全。&lt;/p&gt;
&lt;p&gt;　　appendfsync everysec：每秒 fsync 一次，足够快（和使用 RDB 持久化差不多），并且在故障时只会丢失 1 秒钟的数据。&lt;/p&gt;
&lt;p&gt;　　appendfsync no：从不 fsync ，将数据交给操作系统来处理。更快，也更不安全的选择。&lt;/p&gt;
&lt;p&gt;　　大概在728-730行设置这三种策略，默认的每秒一次，也是推荐使用的，三种策略只能选择其中一种生效。一组set testkey testvalue命令大概这样的&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;7&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;*3&lt;/td&gt;
&lt;td&gt;表示占了几个位置，*3表示占了三个位置，也就是*** *** *** 样式的命令&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;$3&lt;/td&gt;
&lt;td&gt; 表示下面命令占位的长度&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;set&lt;/td&gt;
&lt;td&gt; 就是我们实际的命令&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;$7&lt;/td&gt;
&lt;td&gt; 表示下一个命令占位的长度&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;testkey&lt;/td&gt;
&lt;td&gt; 就是我们实际的命令&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;$9&lt;/td&gt;
&lt;td&gt; 表示下一个命令占位的长度&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;testvalue&lt;/td&gt;
&lt;td&gt; 就是我们实际的命令&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;　　我们假象一下输入了一百次&lt;strong&gt;incr article:xiaocai&lt;/strong&gt;命令，我们现在要使用AOF来恢复我们的文件，那么指令&lt;strong&gt;incr article:xiaocai&lt;/strong&gt;就要存储100次，恢复100次，貌似效率不高啊。这里就提到了我们的AOF文件重写。也就是把一些指令重新组合生成新的指令，但保证数据的准确性。我们来看一下，我们先经历三次set命令，key值是一样的，我很容易知道，这里set了三次，但前两次并没有什么卵用，最后一次将我们的值已经覆盖掉了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt; set xiaocai &lt;span&gt;123&lt;/span&gt;&lt;span&gt;
OK
&lt;/span&gt;&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt; set xiaocai &lt;span&gt;456&lt;/span&gt;&lt;span&gt;
OK
&lt;/span&gt;&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt; set xiaocai &lt;span&gt;666&lt;/span&gt;&lt;span&gt;
OK
&lt;/span&gt;&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt; BGREWRITEAOF
Background append only file rewriting started
&lt;/span&gt;&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这时应该生产三条AOF指令，我们来执行我们的AOF重写命令$ &lt;strong&gt;BGREWRITEAOF&lt;/strong&gt;，重写之后，前面的set就不见了，相同键的set，只保留最后一次的set。可能造成乱码（我们5.0.5默认开启了混合模式，后面会说），但是确实压缩了，恢复也是可以成功的。我们来看一下我该掉默认配置后的AOF重写文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1506597/201910/1506597-20191020232712428-1782434761.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以看到我们前两条指令被优化去掉了，这也就是我们的AOF重写。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;auto-aof-rewrite-min-size&lt;/strong&gt; 64mb //表示当我们的aof文件达到64M时，我们就重写一次，建议使用默认配置就可以，太多了，重写耗时长，太小了，经常重写，消耗性能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;auto-aof-rewrite-percentage&lt;/strong&gt; 100 这个表示。//当我们的配置增加了100%我们就重写一次&lt;br/&gt;　　说到这，两种持久化的方式就都说完了，我们来看一下谁才是王者，谁才是最优质的。&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;命令&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;RDB&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;AOF&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;启动优先级&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;低&lt;/td&gt;
&lt;td&gt;高&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;体积&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;小&lt;/td&gt;
&lt;td&gt;大&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;恢复速度&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;快&lt;/td&gt;
&lt;td&gt;慢&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;数据安全性&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;容易丢失数据&lt;/td&gt;
&lt;td&gt;根据策略决定&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意：当我们同时开启RDB和AOF时，当我们重启redis时，Redis会优先去加载AOF文件来恢复我们的数据，相对来说AOF的数据更完整&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;混合模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　重启redis时，我们很少使用RDB来恢复内存数据，因为会丢失大量的数据。通常我们使用AOF指令来恢复，但AOF的性能相比RDB要慢很多，看到这我们还是觉得并没有一种完美的解决方案，来持久化我们的数据，这时Redis4.0就引出了我们混合持久化。我们可以通过设置 # aof-use-rdb-preamble yes来开启我们的混合持久化，这时我们生成的持久化文件内部还是AOF的，但我们重写的时候，会将这些AOF的指令重写为二进制文件。这样我们就综合了RDB和AOF的优势，在恢复数据的时候大部分是执行二进制文件的，小部分来执行我们的AOF指令操作，使我们的恢复数据的效率更高，在备份的时候是以AOF来备份的，也保证了数据的安全性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　这次我们主要说了我们的Redis的内存高性能，Redis在内存来计算的，再就是我们的高级设置keys *（少用或者别用）和我们的scan命令，再就是Redis的持久化，两种RDB和AOF，RDB持久化可能数据丢失，但是二进制文件恢复的快，AOF持久化几乎不会丢数据，但是是指令的模式，恢复数据效率低。由于都有缺点我们引入了混合模式，保存用AOF来存，恢复用RDB+AOF来恢复。再就是一个重点是save和bgsave的区别。记住bgsave是后台执行的，需要fork子进程，消耗内存，但是不阻塞Redis的其它线程。&lt;/p&gt;
&lt;p&gt;　　今天就说这么多，下次博文我们说说我们的主从模式，哨兵模式和我们的Redis集群。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1506597/201910/1506597-20191014210426502-816598535.gif&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1506597/201910/1506597-20191015223023070-2112352436.jpg&quot; alt=&quot;&quot; width=&quot;298&quot; height=&quot;298&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt; 最进弄了一个公众号，小菜技术，欢迎大家的加入&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1506597/201910/1506597-20191006211816137-1624049234.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 20 Oct 2019 23:59:00 +0000</pubDate>
<dc:creator>oO从零开始Oo</dc:creator>
<og:description>上次我们简单的说了一下我们的redis的安装和使用，这次我们来说说redis为什么那么快和持久化数据 在我们现有的redis中(5.0.*之前的版本)，Redis都是单线程的，那么单线程的Redis为</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cxiaocai/p/11707699.html</dc:identifier>
</item>
<item>
<title>Podman 使用指南 - 米开朗基杨</title>
<link>http://www.cnblogs.com/ryanyangcs/p/11711334.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ryanyangcs/p/11711334.html</guid>
<description>&lt;blockquote readability=&quot;2.2058823529412&quot;&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://www.yangcs.net/posts/podman-sidecar/&quot;&gt;Podman 使用指南&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;Podman&lt;/code&gt; 原来是 &lt;a href=&quot;https://github.com/kubernetes-incubator/cri-o&quot;&gt;CRI-O&lt;/a&gt; 项目的一部分，后来被分离成一个单独的项目叫 &lt;a href=&quot;https://github.com/containers/libpod&quot;&gt;libpod&lt;/a&gt;。Podman 的使用体验和 &lt;code&gt;Docker&lt;/code&gt; 类似，不同的是 Podman 没有 daemon。以前使用 Docker CLI 的时候，Docker CLI 会通过 gRPC API 去跟 Docker Engine 说「我要启动一个容器」，然后 Docker Engine 才会通过 OCI Container runtime（默认是 &lt;code&gt;runc&lt;/code&gt;）来启动一个容器。这就意味着容器的进程不可能是 Docker CLI 的子进程，而是 Docker Engine 的子进程。&lt;/p&gt;
&lt;p&gt;Podman 比较简单粗暴，它不使用 Daemon，而是直接通过 OCI runtime（默认也是 &lt;code&gt;runc&lt;/code&gt;）来启动容器，所以容器的进程是 podman 的子进程。这比较像 Linux 的 &lt;code&gt;fork/exec&lt;/code&gt; 模型，而 Docker 采用的是 &lt;code&gt;C/S&lt;/code&gt;（客户端/服务器）模型。与 C/S 模型相比，&lt;code&gt;fork/exec&lt;/code&gt; 模型有很多优势，比如：&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;系统管理员可以知道某个容器进程到底是谁启动的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如果利用 &lt;code&gt;cgroup&lt;/code&gt; 对 podman 做一些限制，那么所有创建的容器都会被限制。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;SD_NOTIFY&lt;/strong&gt; : 如果将 podman 命令放入 &lt;code&gt;systemd&lt;/code&gt; 单元文件中，容器进程可以通过 podman 返回通知，表明服务已准备好接收任务。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;socket 激活&lt;/strong&gt; : 可以将连接的 &lt;code&gt;socket&lt;/code&gt; 从 systemd 传递到 podman，并传递到容器进程以便使用它们。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;废话不多说，下面我们直接进入实战环节，本文将手把手教你如何用 podman 来部署静态博客，并通过 Sidecar 模式将博客所在的容器加入到 &lt;code&gt;Envoy&lt;/code&gt; mesh 之中。&lt;/p&gt;
&lt;h2 id=&quot;方案架构&quot;&gt;1. 方案架构&lt;/h2&gt;
&lt;p&gt;我的部署方案涉及到两层 Envoy：&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;首先会有一个前端代理单独跑一个容器。前端代理的工作是给访问者提供一个入口，将来自外部的访问请求转发到具体的后端服务。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;其次，博客静态页面由 nginx 提供，同时以 Sidecar 模式运行一个 &lt;code&gt;Envoy&lt;/code&gt; 容器，它与 nginx 共享 &lt;code&gt;network nemspace&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;所有的 Envoy 形成一个 mesh，然后在他们之间共享路由信息。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我之前写过一篇用 &lt;code&gt;Docker&lt;/code&gt; 部署 hugo 静态博客并配置 &lt;code&gt;HTTPS&lt;/code&gt; 证书的文章，本文采用的是相同的方案，只是将 docker 换成了 podman，具体参考&lt;a href=&quot;https://www.yangcs.net/posts/setting-up-ssl-in-envoy-practice/&quot;&gt;为 Envoy 开启 TLS 验证实战&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;部署-hugo-和-sidecar-proxy&quot;&gt;2. 部署 hugo 和 sidecar proxy&lt;/h2&gt;
&lt;p&gt;我的博客是通过 hugo 生成的静态页面，可以将其放到 &lt;code&gt;nginx&lt;/code&gt; 中，其他静态网站工具类似（比如 hexo 等），都可以这么做。现在我要做的是&lt;strong&gt;让 nginx 容器和 envoy 容器共享同一个 network namespace，同时还要让前端代理能够通过域名来进行服务发现&lt;/strong&gt;。以前用 docker 很简单，直接用 docker-compose 就搞定了，podman 就比较麻烦了，它又不能用 &lt;code&gt;docker-compose&lt;/code&gt;，服务发现看来是搞不定了。&lt;/p&gt;
&lt;p&gt;好不容易在 Github 上发现了一个项目叫 &lt;a href=&quot;https://github.com/containers/podman-compose&quot;&gt;podman-compose&lt;/a&gt;，以为有救了，试用了一下发现还是不行，podman-compose 创建容器时会将字段 &lt;code&gt;network_mode: &quot;service:hugo&quot;&lt;/code&gt; 转化为 podman CLI 的参数 &lt;code&gt;--network service:hugo&lt;/code&gt;（真脑残），导致容器创建失败，报错信息为 &lt;code&gt;CNI network &quot;service:hugo&quot; not found&lt;/code&gt;。将该字段值改为 &lt;code&gt;network_mode: &quot;container:hugo_hugo_1&quot;&lt;/code&gt; 可以启动成功，然而又引来了另一个问题：podman-compose 的做法是为每一个 &lt;code&gt;service&lt;/code&gt; 创建一个 &lt;code&gt;pod&lt;/code&gt;（pod 的名字为 docker-compose.yml 所在目录名称），然后往这个 pod 中添加容器。我总不能将前端代理和后端服务塞进同一个 pod 中吧？只能分别为前端代理和 hugo 创建两个目录，然后分别创建 docker-compose.yml。这个问题解决了，下个问题又来了，podman-compose 不支持通过 service name 进行服务发现，扒了一圈发现支持 &lt;code&gt;links&lt;/code&gt;（其实就是加个参数 &lt;code&gt;--add-host&lt;/code&gt;），然而 links 只在同一个 pod 下才生效，我都拆分成两个 pod 了，links 鞭长莫及啊，还是没什么卵用。我能怎么办，现在唯一的办法就是手撸命令行了。&lt;/p&gt;
&lt;p&gt;上面我提到了一个新名词叫 &lt;code&gt;pod&lt;/code&gt;，这里花 30 秒的时间给大家简单介绍一下，如果你是 &lt;code&gt;Kubernetes&lt;/code&gt; 的重度使用者，对这个词应该不陌生，但这里确实说的是 podman 的 pod，意思还是一样的，先创建一个 &lt;code&gt;pause&lt;/code&gt; 容器，然后再创建业务容器，业务容器共享 &lt;code&gt;pause&lt;/code&gt; 容器的各种 linux namespace，因此同一个 pod 中的容器之间可以通过 localhost 轻松地相互通信。不仅如此，podman 还可以将 pod 导出为 Kubernetes 的声明式资源定义，举个栗子：&lt;/p&gt;
&lt;p&gt;先创建一个 pod：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ podman pod create --name hugo&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看 pod：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ podman pod ls

POD ID         NAME   STATUS    CREATED         # OF CONTAINERS   INFRA ID
88226423c4d2   hugo   Running   2 minutes ago   2                 7e030ef2e7ca&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这个 pod 中启动一个 hugo 容器：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ podman run -d --pod hugo nginx:alpine&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看容器：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ podman ps

CONTAINER ID  IMAGE                           COMMAND               CREATED        STATUS            PORTS  NAMES
3c91cab1e99d  docker.io/library/nginx:alpine  nginx -g daemon o...  3 minutes ago  Up 3 minutes ago         reverent_kirch&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看所有容器，包括 pause 容器：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ podman ps -a

CONTAINER ID  IMAGE                           COMMAND               CREATED        STATUS            PORTS  NAMES
3c91cab1e99d  docker.io/library/nginx:alpine  nginx -g daemon o...  4 minutes ago  Up 4 minutes ago         reverent_kirch
7e030ef2e7ca  k8s.gcr.io/pause:3.1                                  6 minutes ago  Up 6 minutes ago         88226423c4d2-infra&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看所有容器，包括 pause 容器，并显示容器所属的 pod id：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ podman ps -ap

CONTAINER ID  IMAGE                           COMMAND               CREATED        STATUS            PORTS  NAMES               POD
3c91cab1e99d  docker.io/library/nginx:alpine  nginx -g daemon o...  4 minutes ago  Up 4 minutes ago         reverent_kirch      88226423c4d2
7e030ef2e7ca  k8s.gcr.io/pause:3.1                                  6 minutes ago  Up 6 minutes ago         88226423c4d2-infra  88226423c4d2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看 pod 中进程的资源使用情况：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ podman pod top hugo

USER    PID   PPID   %CPU    ELAPSED           TTY   TIME   COMMAND
root    1     0      0.000   8m5.045493912s    ?     0s     nginx: master process nginx -g daemon off;
nginx   6     1      0.000   8m5.045600833s    ?     0s     nginx: worker process
nginx   7     1      0.000   8m5.045638877s    ?     0s     nginx: worker process
0       1     0      0.000   9m41.051039367s   ?     0s     /pause&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将 pod 导出为声明式部署清单：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ podman generate kube hugo &amp;gt; hugo.yaml&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看部署清单内容：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ cat hugo.yaml

# Generation of Kubernetes YAML is still under development!
#
# Save the output of this file and use kubectl create -f to import
# it into Kubernetes.
#
# Created with podman-1.0.2-dev
apiVersion: v1
kind: Pod
metadata:
  creationTimestamp: 2019-10-17T04:17:40Z
  labels:
    app: hugo
  name: hugo
spec:
  containers:
  - command:
    - nginx
    - -g
    - daemon off;
    env:
    - name: PATH
      value: /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
    - name: TERM
      value: xterm
    - name: HOSTNAME
    - name: container
      value: podman
    - name: NGINX_VERSION
      value: 1.17.4
    - name: NJS_VERSION
      value: 0.3.5
    - name: PKG_RELEASE
      value: &quot;1&quot;
    image: docker.io/library/nginx:alpine
    name: reverentkirch
    resources: {}
    securityContext:
      allowPrivilegeEscalation: true
      capabilities: {}
      privileged: false
      readOnlyRootFilesystem: false
    workingDir: /
status: {}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;怎么样，是不是有种熟悉的味道？这是一个兼容 kubernetes 的 pod 定义，你可以直接通过 &lt;code&gt;kubectl apply -f hugo.yaml&lt;/code&gt; 将其部署在 Kubernetes 集群中，也可以直接通过 podman 部署，步骤大致是这样的：&lt;/p&gt;
&lt;p&gt;先删除之前创建的 pod：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ podman pod rm -f hugo&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后通过部署清单创建 pod：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ podman play kube hugo.yaml&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;回到之前的问题，如果通过声明式定义来创建 pod，还是无法解决服务发现的问题，除非换个支持静态 IP 的 &lt;code&gt;CNI&lt;/code&gt; 插件，而支持静态 IP 的这些 CNI 插件又需要 etcd 作为数据库，我就这么点资源，可不想再加个 etcd，还是手撸命令行吧。&lt;/p&gt;
&lt;p&gt;首先我要创建一个 hugo 容器，并指定容器的 IP：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ podman run -d --name hugo \
  --ip=10.88.0.10 \
  -v /opt/hugo/public:/usr/share/nginx/html \
  -v /etc/localtime:/etc/localtime \
  nginx:alpine&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再创建一个 envoy 容器，与 hugo 容器共享 network namespace：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ podman run -d --name hugo-envoy \
  -v /opt/hugo/service-envoy.yaml:/etc/envoy/envoy.yaml \
  -v /etc/localtime:/etc/localtime \
  --net=container:hugo envoyproxy/envoy-alpine:latest&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;service-envoy.yaml 的内容如下：&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;static_resources:
  listeners:
  - address:
      socket_address:
        address: 0.0.0.0
        port_value: 8080
    filter_chains:
    - filters:
      - name: envoy.http_connection_manager
        config:
          codec_type: auto
          stat_prefix: ingress_http
          access_log:
          - name: envoy.file_access_log
            config:
              path: &quot;/dev/stdout&quot;
          route_config:
            name: local_route
            virtual_hosts:
            - name: service
              domains:
              - &quot;*&quot;
              routes:
              - match:
                  prefix: &quot;/&quot;
                route:
                  cluster: local_service
          http_filters:
          - name: envoy.router
            config: {}
  clusters:
  - name: local_service
    connect_timeout: 0.25s
    type: strict_dns
    lb_policy: round_robin
    hosts:
    - socket_address:
        address: 127.0.0.1
        port_value: 80
admin:
  access_log_path: &quot;/dev/null&quot;
  address:
    socket_address:
      address: 0.0.0.0
      port_value: 8081&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体的含义请参考&lt;a href=&quot;https://www.yangcs.net/posts/setting-up-ssl-in-envoy-practice/&quot;&gt;为 Envoy 开启 TLS 验证实战&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;本文开头提到 podman 创建的容器是 podman 的子进程，这个表述可能比较模糊，实际上 podman 由两部分组成，一个是 podman CLI，还有一个是 container runtime，container runtime 由 &lt;code&gt;conmon&lt;/code&gt; 来负责，主要包括监控、日志、TTY 分配以及类似 &lt;code&gt;out-of-memory&lt;/code&gt; 情况的杂事。也就是说，conmon 是所有容器的父进程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1737323/201910/1737323-20191021065634410-531106674.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;conmon 需要去做所有 &lt;code&gt;systemd&lt;/code&gt; 不做或者不想做的事情。即使 CRI-O 不直接使用 systemd 来管理容器，它也将容器分配到 sytemd 兼容的 &lt;code&gt;cgroup&lt;/code&gt; 中，这样常规的 systemd 工具比如 &lt;code&gt;systemctl&lt;/code&gt; 就可以看见容器资源使用情况了。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ podman ps

CONTAINER ID  IMAGE                                     COMMAND               CREATED             STATUS                 PORTS  NAMES
42762bf7d37a  docker.io/envoyproxy/envoy-alpine:latest  /docker-entrypoin...  About a minute ago  Up About a minute ago         hugo-envoy
f0204fdc9524  docker.io/library/nginx:alpine            nginx -g daemon o...  2 minutes ago       Up 2 minutes ago              hugo&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1737323/201910/1737323-20191021065638257-1904545600.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对 cgroup 不熟的同学，可以参考下面这个系列：&lt;/p&gt;
&lt;p&gt;零基础的同学建议按照上面的目录从上到下打怪升级，祝你好运！&lt;/p&gt;
&lt;h2 id=&quot;部署前端代理&quot;&gt;3. 部署前端代理&lt;/h2&gt;
&lt;p&gt;这个很简单，直接创建容器就好了：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ podman run -d --name front-envoy \
--add-host=hugo:10.88.0.10 \
-v /opt/hugo/front-envoy.yaml:/etc/envoy/envoy.yaml \
-v /etc/localtime:/etc/localtime \
-v /root/.acme.sh/yangcs.net:/root/.acme.sh/yangcs.net \
--net host envoyproxy/envoy&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于没办法自动服务发现，需要通过参数 &lt;code&gt;--add-host&lt;/code&gt; 手动添加 hosts 到容器中。envoy 的配置文件中是通过域名来添加 cluster 的，front-envoy.yaml 内容如下：&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;static_resources:
  listeners:
  - address:
      socket_address:
        address: 0.0.0.0
        port_value: 80
    filter_chains:
    - filters:
      - name: envoy.http_connection_manager
        config:
          codec_type: auto
          stat_prefix: ingress_http
          access_log:
          - name: envoy.file_access_log
            config:
              path: &quot;/dev/stdout&quot;
          route_config:
            virtual_hosts:
            - name: backend
              domains:
              - &quot;*&quot;
              routes:
              - match:
                  prefix: &quot;/&quot;
                redirect:
                  https_redirect: true
                  response_code: &quot;FOUND&quot;
          http_filters:
          - name: envoy.router
            config: {}
  - address:
      socket_address:
        address: 0.0.0.0
        port_value: 443
    filter_chains:
    - filter_chain_match:
        server_names: [&quot;yangcs.net&quot;, &quot;www.yangcs.net&quot;]
      tls_context:
        common_tls_context:
          alpn_protocols: h2
          tls_params:
            tls_maximum_protocol_version: TLSv1_3
          tls_certificates:
            - certificate_chain:
                filename: &quot;/root/.acme.sh/yangcs.net/fullchain.cer&quot;
              private_key:
                filename: &quot;/root/.acme.sh/yangcs.net/yangcs.net.key&quot;
      filters:
      - name: envoy.http_connection_manager
        config:
          codec_type: auto
          stat_prefix: ingress_http
          route_config:
            name: local_route
            virtual_hosts:
            - name: backend
              domains:
              - &quot;yangcs.net&quot;
              - &quot;www.yangcs.net&quot;
              routes:
              - match:
                  prefix: &quot;/admin&quot;
                route:
                  prefix_rewrite: &quot;/&quot;
                  cluster: envoy-ui
              - match:
                  prefix: &quot;/&quot;
                route:
                  cluster: hugo
                  response_headers_to_add:
                    - header:
                        key: &quot;Strict-Transport-Security&quot;
                        value: &quot;max-age=63072000; includeSubDomains; preload&quot;
          http_filters:
          - name: envoy.router
            config: {}
  clusters:
  - name: hugo
    connect_timeout: 0.25s
    type: strict_dns
    lb_policy: round_robin
    http2_protocol_options: {}
    hosts:
    - socket_address:
        address: hugo
        port_value: 8080
admin:
  access_log_path: &quot;/dev/null&quot;
  address:
    socket_address:
      address: 0.0.0.0
      port_value: 8001&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体的含义请参考&lt;a href=&quot;https://www.yangcs.net/posts/setting-up-ssl-in-envoy-practice/&quot;&gt;为 Envoy 开启 TLS 验证实战&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;现在就可以通过公网域名访问博客网站了，如果后续还有其他应用，都可以参考第二节的步骤，然后重新创建前端代理，添加 &lt;code&gt;--add-host&lt;/code&gt;参数。以我的网站 &lt;a href=&quot;https://www.yangcs.net&quot; class=&quot;uri&quot;&gt;https://www.yangcs.net&lt;/a&gt; 为例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1737323/201910/1737323-20191021065642382-459265375.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1737323/201910/1737323-20191021065650190-2125711670.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1737323/201910/1737323-20191021065704661-1874456694.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我好像透露了一些什么不得了的东西，就此打住，你也不要说，你也不要问。&lt;/p&gt;
&lt;h2 id=&quot;开机自启&quot;&gt;4. 开机自启&lt;/h2&gt;
&lt;p&gt;由于 podman 不再使用 daemon 管理服务，&lt;code&gt;--restart&lt;/code&gt; 参数被废弃了，要想实现开机自动启动容器，只能通过 systemd 来管理了。先创建 systemd 服务配置文件：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ vim /etc/systemd/system/hugo_container.service

[Unit]
Description=Podman Hugo Service
After=network.target
After=network-online.target

[Service]
Type=simple
ExecStart=/usr/bin/podman start -a hugo
ExecStop=/usr/bin/podman stop -t 10 hugo
Restart=always

[Install]
WantedBy=multi-user.target&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ vim /etc/systemd/system/hugo-envoy_container.service

[Unit]
Description=Podman Hugo Sidecar Service
After=network.target
After=network-online.target
After=hugo_container.service

[Service]
Type=simple
ExecStart=/usr/bin/podman start -a hugo-envoy
ExecStop=/usr/bin/podman stop -t 10 hugo-envoy
Restart=always

[Install]
WantedBy=multi-user.target&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ vim /etc/systemd/system/front-envoy_container.service

[Unit]
Description=Podman Front Envoy Service
After=network.target
After=network-online.target
After=hugo_container.service hugo-envoy_container.service

[Service]
Type=simple
ExecStart=/usr/bin/podman start -a front-envoy
ExecStop=/usr/bin/podman stop -t 10 front-envoy
Restart=always

[Install]
WantedBy=multi-user.target&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后将之前停止之前创建的容器，&lt;strong&gt;注意：是停止，不是删除！&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ podman stop $(podman ps -aq)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后通过 systemd 服务启动这些容器。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ systemctl start hugo_container
$ systemctl start hugo-envoy_container
$ systemctl start front-envoy_container&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;设置开机自启。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ systemctl enable hugo_container
$ systemctl enable hugo-envoy_container
$ systemctl enable front-envoy_container&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;之后每次系统重启后 systemd 都会自动启动这个服务所对应的容器。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;4. 总结&lt;/h2&gt;
&lt;p&gt;以上就是将博客从 Docker 迁移到 Podman 的所有变更操作，总体看下来还是比较曲折，因为 Podman 是为 Kubernetes 而设计的，而我要求太高了，就一个资源紧张的 vps，即不想上 &lt;code&gt;Kubernetes&lt;/code&gt;，也不想上 &lt;code&gt;etcd&lt;/code&gt;，既想搞 sidecar，又想搞自动服务发现，我能怎么办，我也很绝望啊，这个事怨不得 podman，为了防止在大家心里留下 &lt;strong&gt;“podman 不好用”&lt;/strong&gt; 的印象，特此声明一下。啥都不想要，只能自己想办法了~~&lt;/p&gt;
&lt;h2 id=&quot;微信公众号&quot;&gt;微信公众号&lt;/h2&gt;
&lt;p&gt;扫一扫下面的二维码关注微信公众号，在公众号中回复◉加群◉即可加入我们的云原生交流群，和孙宏亮、张馆长、阳明等大佬一起探讨云原生技术&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1737323/201910/1737323-20191021065727863-1944143362.gif&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 20 Oct 2019 22:58:00 +0000</pubDate>
<dc:creator>米开朗基杨</dc:creator>
<og:description>本文介绍了 podman 相对于 docker 的优势，并成功将hugo静态博客从 docker 迁移到 podman。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ryanyangcs/p/11711334.html</dc:identifier>
</item>
<item>
<title>Cocos Creator 通用框架设计 —— 资源管理 - 深圳-宝爷</title>
<link>http://www.cnblogs.com/ybgame/p/11711086.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ybgame/p/11711086.html</guid>
<description>&lt;p&gt;如果你想使用Cocos Creator制作一些规模稍大的游戏，那么资源管理是必须解决的问题，随着游戏的进行，你可能会发现游戏的内存占用只升不降，哪怕你当前只用到了极少的资源，并且有使用cc.loader.release来释放之前加载的资源，但之前使用过的大部分资源都会留在内存中！为什么会这样呢？&lt;/p&gt;
&lt;h2 id=&quot;cocos-creator-资源管理存在的问题&quot;&gt;cocos creator 资源管理存在的问题&lt;/h2&gt;
&lt;p&gt;资源管理主要解决3个问题，资源加载，资源查找（使用），资源释放。这里要讨论的主要是资源释放的问题，这个问题看上去非常简单，在Cocos2d-x中确实也很简单，但在js中变得复杂了起来，因为难以跟踪一个资源是否可以被释放。&lt;/p&gt;
&lt;p&gt;在Cocos2d-x中我们使用引用计数，在引用计数为0的时候释放资源，维护好引用计数即可，而且在Cocos2d-x中我们对资源的管理是比较分散的，引擎层面只提供如TextureCache、AudioManager之类的单例来管理某种特定的资源，大多数的资源都需要我们自己去管理，而在cocos creator中，我们的资源统一由cc.loader来管理，大量使用prefab，prefab与各种资源复杂的引用关系增加了资源管理的难度。&lt;/p&gt;
&lt;h3 id=&quot;资源依赖&quot;&gt;资源依赖&lt;/h3&gt;
&lt;p&gt;资源A可能依赖资源B、C、D，而资源D又依赖资源E，这是非常常见的一种资源依赖情况，如果我们使用&lt;code&gt;cc.loader.loadRes(&quot;A&quot;)&lt;/code&gt;加载资源A，B～E都会被加载进来，但如果我们调用&lt;code&gt;cc.loader.release(&quot;A&quot;)&lt;/code&gt;则只有资源A被释放。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/10/20/KMIYQK.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每一个加载的资源都会放到cc.loader的_cache中，但cc.loader.release只是将传入的资源进行释放，而没有考虑资源依赖的情况。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果对cc.loader背后的资源加载流程感兴趣可以参考： https://www.cnblogs.com/ybgame/p/10576884.html&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果我们希望将依赖的资源也一起释放，cocos creator提供了一个笨拙的方法，&lt;code&gt;cc.loader.getDependsRecursively;&lt;/code&gt;，递归获取指定资源依赖的所有资源，放入一个数组并返回，然后在cc.loader.release中传入该数组，cc.loader会遍历它们，将其逐个释放。&lt;/p&gt;
&lt;p&gt;这种方式虽然可以将资源释放，但却有可能释放了不应该释放的资源，如果有一个资源F依赖D，这时候就会导致F资源无法正常工作。由于cocos creator引擎没有维护好资源的依赖，导致我们在释放D的时候并不知道还有F依赖我们。即使没有F依赖，我们也不确定是否可以释放D，比如我们调用cc.loader加载D，而后又加载了A，此时D已经加载完成，A可以直接使用。但如果释放A的时候，将D也释放了，这就不符合我们的预期，我们期望的是在我们没有显式地释放D时，D不应该随着其它资源的释放而自动释放。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;可以简单地进行测试，可以打开Chrome的开发者模式，在Console面板中进行输入，如果是旧版本的cocos creator可以在cc.textureCache中dump所有的纹理，而新版本移除了textureCache，但我们可以输入cc.loader._cache来查看所有的资源。如果资源太多，只关心数量，可以输入Object.keys(cc.loader._cache).length来查看资源总数，我们可以在资源加载前dump一次，加载后dump一次，释放后再dump一次，来对比cc.loader中的缓存状态。当然，也可以写一些便捷的方法，如只dump图片，或者dump与上次dump的差异项。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/10/20/KMz75V.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;资源使用&quot;&gt;资源使用&lt;/h3&gt;
&lt;p&gt;除了资源依赖的问题，我们还需要解决资源使用的问题，前者是cc.loader内部的资源组织问题，后者是应用层逻辑的资源使用问题，比如我们需要在一个界面关闭的时候释放某资源，同样会面临一个该不该释放的问题，比如另外一个未关闭的界面是否使用了该资源？如果有其他地方用到了该资源，那么就不应该释放它！&lt;/p&gt;
&lt;h2 id=&quot;resloader&quot;&gt;ResLoader&lt;/h2&gt;
&lt;p&gt;在这里我设计了一个ResLoader，来解决cc.loader没有解决好的问题，关键是为每一个资源创建一个CacheInfo来记录资源的依赖和使用等信息，以此来判断资源是否可以释放，使用ResLoader.getInstance().loadRes()来替代cc.loader.loadRes()，ResLoader.getInstance().releaseRes()来替代cc.loader.releaseRes()。&lt;/p&gt;
&lt;p&gt;对于依赖，在资源加载的时候ResLoader会自动建立起映射，释放资源的时候会自动取消映射，并检测取消映射后的资源是否可以释放，是才走释放的逻辑。&lt;/p&gt;
&lt;p&gt;对于使用，提供了一个use参数，通过该参数来区别是哪里使用了该资源，以及是否有其他地方使用了该资源，当一个资源即没有倍其他资源依赖，也没有被其它逻辑使用，那么这个资源就可以被释放。&lt;/p&gt;
&lt;pre class=&quot;ts&quot;&gt;
&lt;code&gt;/**
 * 资源加载类
 * 1. 加载完成后自动记录引用关系，根据DependKeys记录反向依赖
 * 2. 支持资源使用，如某打开的UI使用了A资源，其他地方释放资源B，资源B引用了资源A，如果没有其他引用资源A的资源，会触发资源A的释放，
 * 3. 能够安全释放依赖资源（一个资源同时被多个资源引用，只有当其他资源都释放时，该资源才会被释放）
 * 
 * 2018-7-17 by 宝爷
 */

// 资源加载的处理回调
export type ProcessCallback = (completedCount: number, totalCount: number, item: any) =&amp;gt; void;
// 资源加载的完成回调
export type CompletedCallback = (error: Error, resource: any) =&amp;gt; void;

// 引用和使用的结构体
interface CacheInfo {
    refs: Set&amp;lt;string&amp;gt;,
    uses: Set&amp;lt;string&amp;gt;
}

// LoadRes方法的参数结构
interface LoadResArgs {
    url: string,
    type?: typeof cc.Asset,
    onCompleted?: CompletedCallback,
    onProgess?: ProcessCallback,
    use?: string,
}

// ReleaseRes方法的参数结构
interface ReleaseResArgs {
    url: string,
    type?: typeof cc.Asset,
    use?: string,
}

// 兼容性处理
let isChildClassOf = cc.js[&quot;isChildClassOf&quot;]
if (!isChildClassOf) {
    isChildClassOf = cc[&quot;isChildClassOf&quot;];
}

export default class ResLoader {

    private _resMap: Map&amp;lt;string, CacheInfo&amp;gt; = new Map&amp;lt;string, CacheInfo&amp;gt;();
    private static _resLoader: ResLoader = null;
    public static getInstance(): ResLoader {
        if (!this._resLoader) {
            this._resLoader = new ResLoader();
        }
        return this._resLoader;
    }

    public static destroy(): void {
        if (this._resLoader) {
            this._resLoader = null;
        }
    }

    private constructor() {

    }

    /**
     * 从cc.loader中获取一个资源的item
     * @param url 查询的url
     * @param type 查询的资源类型
     */
    private _getResItem(url: string, type: typeof cc.Asset): any {
        let ccloader: any = cc.loader;
        let item = ccloader._cache[url];
        if (!item) {
            let uuid = ccloader._getResUuid(url, type, false);
            if (uuid) {
                let ref = ccloader._getReferenceKey(uuid);
                item = ccloader._cache[ref];
            }
        }
        return item;
    }

    /**
     * loadRes方法的参数预处理
     */
    private _makeLoadResArgs(): LoadResArgs {
        if (arguments.length &amp;lt; 1 || typeof arguments[0] != &quot;string&quot;) {
            console.error(`_makeLoadResArgs error ${arguments}`);
            return null;
        }
        let ret: LoadResArgs = { url: arguments[0] };
        for (let i = 1; i &amp;lt; arguments.length; ++i) {
            if (i == 1 &amp;amp;&amp;amp; isChildClassOf(arguments[i], cc.RawAsset)) {
                // 判断是不是第一个参数type
                ret.type = arguments[i];
            } else if (i == arguments.length - 1 &amp;amp;&amp;amp; typeof arguments[i] == &quot;string&quot;) {
                // 判断是不是最后一个参数use
                ret.use = arguments[i];
            } else if (typeof arguments[i] == &quot;function&quot;) {
                // 其他情况为函数
                if (arguments.length &amp;gt; i + 1 &amp;amp;&amp;amp; typeof arguments[i + 1] == &quot;function&quot;) {
                    ret.onProgess = arguments[i];
                } else {
                    ret.onCompleted = arguments[i];
                }
            }
        }
        return ret;
    }

    /**
     * releaseRes方法的参数预处理
     */
    private _makeReleaseResArgs(): ReleaseResArgs {
        if (arguments.length &amp;lt; 1 || typeof arguments[0] != &quot;string&quot;) {
            console.error(`_makeReleaseResArgs error ${arguments}`);
            return null;
        }
        let ret: ReleaseResArgs = { url: arguments[0] };
        for (let i = 1; i &amp;lt; arguments.length; ++i) {
            if (typeof arguments[i] == &quot;string&quot;) {
                ret.use = arguments[i];
            } else {
                ret.type = arguments[i];
            }
        }
        return ret;
    }

    /**
     * 生成一个资源使用Key
     * @param where 在哪里使用，如Scene、UI、Pool
     * @param who 使用者，如Login、UIHelp...
     * @param why 使用原因，自定义...
     */
    public static makeUseKey(where: string, who: string = &quot;none&quot;, why: string = &quot;&quot;): string {
        return `use_${where}_by_${who}_for_${why}`;
    }

    /**
     * 获取资源缓存信息
     * @param key 要获取的资源url
     */
    public getCacheInfo(key: string): CacheInfo {
        if (!this._resMap.has(key)) {
            this._resMap.set(key, {
                refs: new Set&amp;lt;string&amp;gt;(),
                uses: new Set&amp;lt;string&amp;gt;()
            });
        }
        return this._resMap.get(key);
    }

    /**
     * 开始加载资源
     * @param url           资源url
     * @param type          资源类型，默认为null
     * @param onProgess     加载进度回调
     * @param onCompleted   加载完成回调
     * @param use           资源使用key，根据makeUseKey方法生成
     */
    public loadRes(url: string, use?: string);
    public loadRes(url: string, onCompleted: CompletedCallback, use?: string);
    public loadRes(url: string, onProgess: ProcessCallback, onCompleted: CompletedCallback, use?: string);
    public loadRes(url: string, type: typeof cc.Asset, use?: string);
    public loadRes(url: string, type: typeof cc.Asset, onCompleted: CompletedCallback, use?: string);
    public loadRes(url: string, type: typeof cc.Asset, onProgess: ProcessCallback, onCompleted: CompletedCallback, use?: string);
    public loadRes() {
        let resArgs: LoadResArgs = this._makeLoadResArgs.apply(this, arguments);
        console.time(&quot;loadRes|&quot;+resArgs.url);
        let finishCallback = (error: Error, resource: any) =&amp;gt; {
            // 反向关联引用（为所有引用到的资源打上本资源引用到的标记）
            let addDependKey = (item, refKey) =&amp;gt; {
                if (item &amp;amp;&amp;amp; item.dependKeys &amp;amp;&amp;amp; Array.isArray(item.dependKeys)) {
                    for (let depKey of item.dependKeys) {
                        // 记录该资源被我引用
                        this.getCacheInfo(depKey).refs.add(refKey);
                        // cc.log(`${depKey} ref by ${refKey}`);
                        let ccloader: any = cc.loader;
                        let depItem = ccloader._cache[depKey]
                        addDependKey(depItem, refKey)
                    }
                }
            }

            let item = this._getResItem(resArgs.url, resArgs.type);
            if (item &amp;amp;&amp;amp; item.url) {
                addDependKey(item, item.url);
            } else {
                cc.warn(`addDependKey item error1! for ${resArgs.url}`);
            }

            // 给自己加一个自身的引用
            if (item) {
                let info = this.getCacheInfo(item.url);
                info.refs.add(item.url);
                // 更新资源使用
                if (resArgs.use) {
                    info.uses.add(resArgs.use);
                }
            }

            // 执行完成回调
            if (resArgs.onCompleted) {
                resArgs.onCompleted(error, resource);
            }
            console.timeEnd(&quot;loadRes|&quot;+resArgs.url);
        };

        // 预判是否资源已加载
        let res = cc.loader.getRes(resArgs.url, resArgs.type);
        if (res) {
            finishCallback(null, res);
        } else {
            cc.loader.loadRes(resArgs.url, resArgs.type, resArgs.onProgess, finishCallback);
        }
    }

    /**
     * 释放资源
     * @param url   要释放的url
     * @param type  资源类型
     * @param use   要解除的资源使用key，根据makeUseKey方法生成
     */
    public releaseRes(url: string, use?: string);
    public releaseRes(url: string, type: typeof cc.Asset, use?: string)
    public releaseRes() {
        /**暂时不释放资源 */
        // return;

        let resArgs: ReleaseResArgs = this._makeReleaseResArgs.apply(this, arguments);
        let item = this._getResItem(resArgs.url, resArgs.type);
        if (!item) {
            console.warn(`releaseRes item is null ${resArgs.url} ${resArgs.type}`);
            return;
        }
        cc.log(&quot;resloader release item&quot;);
        // cc.log(arguments);
        let cacheInfo = this.getCacheInfo(item.url);
        if (resArgs.use) {
            cacheInfo.uses.delete(resArgs.use)
        }
        this._release(item, item.url);
    }

    // 释放一个资源
    private _release(item, itemUrl) {
        if (!item) {
            return;
        }
        let cacheInfo = this.getCacheInfo(item.url);
        // 解除自身对自己的引用
        cacheInfo.refs.delete(itemUrl);

        if (cacheInfo.uses.size == 0 &amp;amp;&amp;amp; cacheInfo.refs.size == 0) {
            // 解除引用
            let delDependKey = (item, refKey) =&amp;gt; {
                if (item &amp;amp;&amp;amp; item.dependKeys &amp;amp;&amp;amp; Array.isArray(item.dependKeys)) {
                    for (let depKey of item.dependKeys) {
                        let ccloader: any = cc.loader;
                        let depItem = ccloader._cache[depKey]
                        this._release(depItem, refKey);
                    }
                }
            }
            delDependKey(item, itemUrl);
            //如果没有uuid,就直接释放url
            if (item.uuid) {
                cc.loader.release(item.uuid);
                cc.log(&quot;resloader release item by uuid :&quot; + item.url);
            } else {
                cc.loader.release(item.url);
                cc.log(&quot;resloader release item by url:&quot; + item.url);
            }
        }
    }

    /**
     * 判断一个资源能否被释放
     * @param url 资源url
     * @param type  资源类型
     * @param use   要解除的资源使用key，根据makeUseKey方法生成
     */
    public checkReleaseUse(url: string, use?: string): boolean;
    public checkReleaseUse(url: string, type: typeof cc.Asset, use?: string): boolean
    public checkReleaseUse() {
        let resArgs: ReleaseResArgs = this._makeReleaseResArgs.apply(this, arguments);
        let item = this._getResItem(resArgs.url, resArgs.type);
        if (!item) {
            console.log(`cant release,item is null ${resArgs.url} ${resArgs.type}`);
            return true;
        }

        let cacheInfo = this.getCacheInfo(item.url);
        let checkUse = false;
        let checkRef = false;

        if (resArgs.use &amp;amp;&amp;amp; cacheInfo.uses.size &amp;gt; 0) {
            if (cacheInfo.uses.size == 1 &amp;amp;&amp;amp; cacheInfo.uses.has(resArgs.use)) {
                checkUse = true;
            } else {
                checkUse = false;
            }
        } else {
            checkUse = true;
        }

        if ((cacheInfo.refs.size == 1 &amp;amp;&amp;amp; cacheInfo.refs.has(item.url)) || cacheInfo.refs.size == 0) {
            checkRef = true;
        } else {
            checkRef = false;
        }

        return checkUse &amp;amp;&amp;amp; checkRef;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;使用resloader&quot;&gt;使用ResLoader&lt;/h2&gt;
&lt;p&gt;ResLoader的使用非常简单，下面是一个简单的例子，我们可以点击dump按钮来查看当前的资源总数，点击cc.load、cc.release之后分别dump一次，可以发现，开始有36个资源，加载之后有40个资源，而执行释放之后，还有39个资源，只释放了一个资源。&lt;/p&gt;
&lt;p&gt;如果使用ResLoader进行测试，发现释放之后只有34个资源，这是因为前面加载场景的资源也被该测试资源依赖，所以这些资源也被释放掉了，只要我们都使用ResLoader来加载和卸载资源，就不会出现资源泄露的问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/10/20/KQpLnJ.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre class=&quot;ts&quot;&gt;
&lt;code&gt;@ccclass
export default class NetExample extends cc.Component {
    @property(cc.Node)
    attachNode: cc.Node = null;
    @property(cc.Label)
    dumpLabel: cc.Label = null;

    onLoadRes() {
        cc.loader.loadRes(&quot;Prefab/HelloWorld&quot;, cc.Prefab, (error: Error, prefab: cc.Prefab) =&amp;gt; {
            if (!error) {
                cc.instantiate(prefab).parent = this.attachNode;
            }
        });
    }

    onUnloadRes() {
        this.attachNode.removeAllChildren(true);
        cc.loader.releaseRes(&quot;Prefab/HelloWorld&quot;);
    }

    onMyLoadRes() {
        ResLoader.getInstance().loadRes(&quot;Prefab/HelloWorld&quot;, cc.Prefab, (error: Error, prefab: cc.Prefab) =&amp;gt; {
            if (!error) {
                cc.instantiate(prefab).parent = this.attachNode;
            }
        });
    }

    onMyUnloadRes() {
        this.attachNode.removeAllChildren(true);
        ResLoader.getInstance().releaseRes(&quot;Prefab/HelloWorld&quot;);
    }

    onDump() {
        let Loader:any = cc.loader;
        this.dumpLabel.string = `当前资源总数:${Object.keys(Loader._cache).length}`;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到上面的例子是先移除节点，再进行释放，这是正确的使用方式，如果我没有移除直接释放呢？？因为释放了纹理，所以cocos creator在接下来的渲染中会不断报错。&lt;/p&gt;
&lt;p&gt;ResLoader只是一个基础，直接使用ResLoader我们不需要关心资源的依赖问题，但资源的使用问题我们还需要关心，在实际的使用中，我们可能希望资源的生命周期是以下几种情况：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;跟随某对象的生命周期，对象销毁时资源释放&lt;/li&gt;
&lt;li&gt;跟随某界面的生命周期，界面关闭时资源释放&lt;/li&gt;
&lt;li&gt;跟随某场景的生命周期，场景切换时资源释放&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们可以实现一个组件挂在到对象身上，当我们在该对象或该对象的其它组件中编写逻辑，加载资源时，使用这个资源管理组件进行加载，由该组件来维护资源的释放。界面和场景也类似。下一篇文章再聊一聊这个话题。&lt;/p&gt;
&lt;p&gt;项目代码位于：https://github.com/wyb10a10/cocos_creator_framework ，打开Scene目录的ResExample场景即可查看。&lt;/p&gt;
</description>
<pubDate>Sun, 20 Oct 2019 15:59:00 +0000</pubDate>
<dc:creator>深圳-宝爷</dc:creator>
<og:description>如果你想使用Cocos Creator制作一些规模稍大的游戏，那么资源管理是必须解决的问题，随着游戏的进行，你可能会发现游戏的内存占用只升不降，哪怕你当前只用到了极少的资源，并且有使用cc.loade</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ybgame/p/11711086.html</dc:identifier>
</item>
<item>
<title>树莓派(4B)Linux + .Net Core嵌入式-HelloWorld(二) - 荣少（Leif）</title>
<link>http://www.cnblogs.com/vcode/p/11708910.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/vcode/p/11708910.html</guid>
<description>&lt;h2&gt;一、新建.Net Core项目&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/656844/201910/656844-20191020195806987-1637605008.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;新建.Net Core3.0的控制台应用，代码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
namespace Demo
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine(&quot;Hello World!&quot;);
            Console.WriteLine(Environment.OSVersion);
            Console.WriteLine(Environment.Version);
            Console.ReadKey();
        }
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;二、生成项目&lt;/h2&gt;
&lt;p&gt;项目已经写好后，右击项目发布&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/656844/201910/656844-20191020204947188-873360228.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 会弹出一下窗体，选择文件夹，生成后的路径一般默认即可（具体看个人喜好），然后点击创建配置文件&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/656844/201910/656844-20191020205115008-830693519.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;创建后，点击编辑&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/656844/201910/656844-20191020220020862-1867238097.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;修改目标运行时，修改为linux-arm&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/656844/201910/656844-20191020220058853-355610093.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击保存后，点击发布，发布完成根据，目标位置寻找生成后的文件。&lt;/p&gt;
&lt;h2&gt;三、树莓派运行&lt;/h2&gt;
&lt;p&gt;根据上一章节说到的【&lt;a href=&quot;https://www.cnblogs.com/vcode/p/11705939.html&quot; target=&quot;_blank&quot;&gt;树莓派(4B)Linux + .Net Core嵌入式-初始化环境(一)&lt;/a&gt;】，使用Xftp软件上传项目编译好的文件到树莓派机器中&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/656844/201910/656844-20191020223205403-1636646367.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在树莓派中建立Demo文件夹，把上图中Demo、Demo.dll、Demo.rentimeconfig.json上传到Demo文件夹中即可。&lt;/p&gt;
&lt;p&gt;然后打开Xshell软件，cd进入到程度目录&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/656844/201910/656844-20191020224823655-26657335.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以分别输入以下命令执行即可运行（2种方法）：&lt;/p&gt;
&lt;p&gt;方法一：直接键入命令执行dll&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
dotnet Demo.dll　
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/656844/201910/656844-20191020225005587-1299742468.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;方法二：执行Dome&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
./Dome  或者是 Demo/Demo（需要退到上级目录，所谓的相对路径）
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/656844/201910/656844-20191020232831113-853465450.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;直接执行分别2条命令，都无法正常执行成功，提示是权限拒绝访问；&lt;/p&gt;
&lt;p&gt;那么解决方案是给Demo增加执行权限&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
chmod +x Demo
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/656844/201910/656844-20191020232219457-814471257.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;加上执行权限后，可以看上图就颜色就已经区分开了，&lt;/p&gt;
&lt;p&gt;绿色：可执行文件 白色：文件 蓝色：文件夹；其他颜色自行脑补。&lt;/p&gt;
&lt;p&gt;然后再分别操作下，执行语句看看效果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/656844/201910/656844-20191020232719358-762085266.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 终于 可以正常执行了.....&lt;/p&gt;

</description>
<pubDate>Sun, 20 Oct 2019 15:30:00 +0000</pubDate>
<dc:creator>荣少（Leif）</dc:creator>
<og:description>一、新建.Net Core项目 新建.Net Core3.0的控制台应用，代码如下 二、生成项目 项目已经写好后，右击项目发布 会弹出一下窗体，选择文件夹，生成后的路径一般默认即可（具体看个人喜好），</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/vcode/p/11708910.html</dc:identifier>
</item>
<item>
<title>基于KVM的SRIOV直通配置及性能测试 - 小慢哥</title>
<link>http://www.cnblogs.com/fzxiaomange/p/sriov-kvm-passthrough.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fzxiaomange/p/sriov-kvm-passthrough.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://fzxiaomange.com/img/sriov/sriov-cover.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SRIOV介绍、VF直通配置，以及包转发率性能测试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;小慢哥的原创文章，欢迎转载&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;▪ 1. SRIOV介绍&lt;br/&gt;▪ 2. 环境说明&lt;br/&gt;▪ 3. 开启SRIOV&lt;br/&gt;▪ 4. 生成VF&lt;br/&gt;▪ 5. VF直通&lt;br/&gt;▪ 6. 开启irqbalance&lt;br/&gt;▪ 7. VM迁移&lt;br/&gt;▪ 8. 带宽限速&lt;br/&gt;▪ 9. 安全&lt;br/&gt;▪ 10. 其他使用限制&lt;br/&gt;▪ 11. 性能测试&lt;br/&gt;▪ 12. windows虚拟机使用VF&lt;br/&gt;▪ 13. 运维命令&lt;br/&gt;▪ 14. 宿主屏蔽VF驱动&lt;br/&gt;▪ 附. 包转发率测试方法&lt;br/&gt;▪ 附. 参考文档&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;img src=&quot;https://fzxiaomange.com/img/sriov/sriov-network.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;▷ &lt;strong&gt;传统方式的瓶颈&lt;/strong&gt;：qemu的网卡，传统方式是使用tap网卡，桥接到宿主的bridge上，但性能很差，尤其是包转发率很低，难以满足对性能要求比较高的场景。性能差的主要原因是路径太长，经过的内核设备太多，根本原因在于linux/unix内核本身就不是为高性能而设计的，linux/unix更适合做控制平面，而不是转发平面。&lt;br/&gt;▷ &lt;strong&gt;解决思路&lt;/strong&gt;：减少中间路径，最简单有效的方法就是bypass内核。SRIOV的作用就是bypass宿主内核。&lt;br/&gt;▷ &lt;strong&gt;PF和VF&lt;/strong&gt;：每个物理网卡（比如p1p1）就是一个PF，在开启SRIOV后，每个PF可以生成固定数量的VF，每个VF都可以在宿主上作为一张网卡直接使用，或者直通到QEMU虚拟机里作为虚拟机里的网卡使用，这就实现了bypass宿主内核。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;先给出性能测试的结论，SRIOV VF直通相比传统tap+bridge方案，性能提升：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;▷ 发包转发率提高: 677%&lt;br/&gt;▷ 收包转发率提高: 171%&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;机型：Dell PowerEdge R620&lt;br/&gt;网卡：Intel X520（82599ES）&lt;br/&gt;宿主OS：CentOS 7&lt;br/&gt;VM OS：CentOS 7&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;1️⃣ &lt;strong&gt;在BIOS里开启SRIOV，如图所示&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://fzxiaomange.com/img/sriov/bios-enable-sriov.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注：即使BIOS里开启全局SRIOV，网卡也依然可以当作普通网卡使用&lt;/p&gt;
&lt;p&gt;2️⃣ &lt;strong&gt;需要在BIOS里开启VT-d&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;3️⃣ &lt;strong&gt;grub配置iommu&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;iommu=pt intel_iommu=on&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;
&lt;pre&gt;
&lt;code&gt;# 启动网卡
ip link set p1p1 up

# 查看pf的pci编号
lshw -c network -businfo

# 查看网卡支持的vf数量
cat /sys/bus/pci/devices/0000:41:00.0/sriov_totalvfs

# 生成vf，建议加入开机启动
echo 63 &amp;gt; /sys/bus/pci/devices/0000:41:00.0/sriov_numvfs&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：若没有屏蔽宿主的VF驱动，则在生成vf后还必须等待一会时间才能在宿主上看到所有命名完成的网卡（否则会看到一堆ethX网卡），vf数量越多需要等待时间越长，63个vf，差不多需要10秒&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;如果qemu是通过libvirt管理的，有3种配置方法：&lt;/p&gt;
&lt;p&gt;▷ &lt;strong&gt;方法1（interface）：在devices段落里加入&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;interface type='hostdev' managed='yes'&amp;gt;
  &amp;lt;mac address='52:54:00:ad:ef:8d'/&amp;gt;
  &amp;lt;source&amp;gt;
    &amp;lt;address type='pci' domain='0x0000' bus='0x41' slot='0x10' function='0x0'/&amp;gt;
  &amp;lt;/source&amp;gt;
  &amp;lt;vlan&amp;gt;
    &amp;lt;tag id='4010'/&amp;gt;
  &amp;lt;/vlan&amp;gt;
&amp;lt;/interface&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面中address的地址，可以根据“lshw -c network -businfo”来配置，比如&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;pci@0000:41:10.0 p1p1_0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;▷ &lt;strong&gt;方法2（hostdev）：在devices段落里加入&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;hostdev mode='subsystem' type='pci' managed='yes'&amp;gt;
  &amp;lt;source&amp;gt;
    &amp;lt;address domain='0x0000' bus='0x41' slot='0x10' function='0x0'/&amp;gt;
  &amp;lt;/source&amp;gt;
&amp;lt;/hostdev&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面中address的地址，也是根据“lshw -c network -businfo”来配置&lt;/p&gt;
&lt;p&gt;▷ &lt;strong&gt;方法3（net-pool）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为每个PF网卡定义一个net-pool，即分别编辑一个xml文件。这里仅展示一个PF，编辑sriov-int.xml&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;network&amp;gt;
  &amp;lt;name&amp;gt;sriov-int&amp;lt;/name&amp;gt;
  &amp;lt;forward mode='hostdev' managed='yes'&amp;gt;
    &amp;lt;pf dev='p1p1'/&amp;gt;
  &amp;lt;/forward&amp;gt;
&amp;lt;/network&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;加入到libvirt net-pool、激活、并设置开机启动&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;virsh net-define sriov-int.xml
virsh net-start sriov-int
virsh net-autostart sriov-int&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;虽然配置了net-autostart，但并不管用，因为物理机启动时候，经常会在启动生成vf（假设在rc.local里生成vf）之前就启动libvirt，而这个net-pool（sriov-int）本应该在vf生成后才能启动，因此建议在rc.local里增加如下内容来确保启动&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ip link set p1p2 up
echo 63 &amp;gt; /sys/bus/pci/devices/0000:41:00.0/sriov_numvfs
virsh net-start sriov-int&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后，在vm的xml里增加&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;interface type='network'&amp;gt;
  &amp;lt;mac address='52:54:00:ad:ef:8d'/&amp;gt;
  &amp;lt;source network='sriov-int'/&amp;gt;
  &amp;lt;vlan&amp;gt;
    &amp;lt;tag id='4010'/&amp;gt;
  &amp;lt;/vlan&amp;gt;
&amp;lt;/interface&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3种方法如何选择&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;▷ 方法1：功能多，可以配置mac和vlan&lt;br/&gt;▷ 方法2：mac和vlan需要自己在宿主上敲ip命令设置&lt;br/&gt;▷ 方法3：有2个问题&lt;br/&gt;▪ 存在一个bug，当本宿主所有vm使用某个PF的VF总数超过VF上限后，不会报错，也能启动，但是可能会有异常，并且vm如果被destroy关机，那么对应的VF就会出问题，比如使用ip link set p1p1 vf 0 mac 00:00:00:00:00:00来做重置时候，会提示“RTNETLINK answers: Cannot allocate memory”，而且难以修复，即使修复，也不知道有没有看不见的异常存在。&lt;br/&gt;▪ 没有办法知道某个vm使用的是哪个vf，因此如果要对vf设置限速或者开关spoofchk时候，只能先在宿主上通过“ip link show dev p1p1 | grep MAC地址”方式来获得vf号，然后才能设置限速等操作&lt;/p&gt;
&lt;p&gt;综上所述：使用方法3最便捷，但是存在bug，因此需要做好逻辑来防止vm使用vf总数超过上限的情况。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;x520是2队列，x710是4队列，需要在vm里启动中断平衡服务（irqbalance），否则只会有一个cpu来处理数据包。&lt;/p&gt;
&lt;p&gt;另外，这与宿主上vf的query_rss无关。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;直通网卡属于PCI设备，而libvirt和qemu却不支持带有非USB的PCI设备的vm做迁移，包括冷迁移和热迁移。因此热迁移无法实现。&lt;/p&gt;
&lt;p&gt;冷迁移，有2种方案:&lt;/p&gt;
&lt;p&gt;▷ detach掉vf网卡，然后使用libvirt做迁移，迁移过去后，再在新宿主上attach vf网卡&lt;br/&gt;▷ undefine vm，然后在新宿主上重新渲染并define vm&lt;/p&gt;
&lt;p&gt;注意：不能在vm关机时候用libvirt的迁移功能，有时候会导致虚拟机消失掉，包括原宿主和新宿主&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;strong&gt;只能限制出站带宽，无法限制入站带宽&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ip link set p1p1 vf 0 max_tx_rate 100&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;表示出站带宽限速100Mbps，不同网卡有差别:&lt;/p&gt;
&lt;p&gt;▷ x520网卡最小限速11Mbps，最大限速10000Mbps，设为0表示不限速。&lt;strong&gt;若小于11或大于10000则会报错&lt;/strong&gt;&lt;br/&gt;▷ x710网卡最小限速50Mbps，最大限速10000Mbps，设为0表示不限速。&lt;strong&gt;若小于50则自动设为50，若大于10000则会报错&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;注意：vm关机后vf的带宽限速不会复位&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;仅支持源mac过滤和网卡mac防篡改，不支持其他安全防护（防arp欺骗就无法实现）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;源mac过滤&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ip link set p1p1 vf 0 spoofchk on&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;表示vm里发出的包，如果源mac不是指定mac，那么数据包不允许通过。注意：vm关机后vf的spoofchk不会复位&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;网卡mac防篡改&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;▷ 在宿主上修改mac，vm里的mac不会跟着改；在vm里修改mac，在宿主上可以看到变化&lt;br/&gt;▷ 如果在vm关机状态下改了mac地址，那么当vm开机后会改为vm的mac，当vm又关机后，又回改为原先改的mac&lt;br/&gt;▷ 只有在宿主上看到的当前vf的mac为全0，才能在vm里修改mac地址，即使vf的spoofchk为off。但有一种例外，若使用上面方法2来配置xml，虽然宿主上看到的vf的mac不为0，但vm里可以修改&lt;br/&gt;▷ 当在宿主上设置了mac后，虚拟机里的mac就无法篡改了&lt;br/&gt;▪ 方法1（interface）来配置xml，估计vm启动时候就自动帮忙在宿主上设置了mac，所以就直接实现了防篡改功能&lt;br/&gt;▪ 方法2（hostdev）来配置xml，需要在宿主上手动再设置一次mac地址才能实现防篡改&lt;/p&gt;
&lt;p&gt;在宿主上手动修改mac方法（vm关机和开机情况下都可以改）:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ip link set p1p1 vf 0 mac aa:bb:cc:dd:ee:ff&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;建议:&lt;/p&gt;
&lt;p&gt;▷ 在vm启动前对vf做一次重置&lt;br/&gt;▷ 在vm undefine后对vf做一次重置&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;▷ 直通到vm里的vf网卡里无法桥接到vm里的linux bridge，这也导致ebtables无法使用，iptables可以使用&lt;br/&gt;▷ 直通到vm里的vf网卡可以加入ovs桥接&lt;br/&gt;▷ 一个vm最多只能支持32个vf，超过数量会报错&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;strong&gt;测试方法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;▷ 多台vm同时发包，一台vm收包，分别观察发包性能和收包性能&lt;br/&gt;▷ 发包vm在同一台宿主上，收包vm在另一台宿主上&lt;br/&gt;▷ 测试工具：modprobe pktgen&lt;br/&gt;▷ 测试包大小: udp包，size为64 bytes&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;配置：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;▷ vm配置均为4核8G&lt;br/&gt;▷ 物理网卡均为x520（vf队列默认为2）&lt;br/&gt;▷ 宿主和vm均开启irqbalance、均关闭numad&lt;br/&gt;▷ 不配置cpu绑定、不配置numa绑定&lt;br/&gt;▷ 开启大页&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://fzxiaomange.com/img/sriov/sriov-vf-compare-benchmark-table.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;测试结论：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用SR-IOV+VF直通方式可以明显提升包转发率，1对1的测试结果看到&lt;strong&gt;kernel态发包可以达到3.5Mpps，收包可以达到1.9Mpps&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;▷ 发包比vxlan提高: 1196%，比vlan提高: 677%。此结果参考1对1（1个发包vm，1个收包vm）&lt;br/&gt;▷ 收包比vxlan提高: 363%，比vlan提高: 171%。此结果参考3对1（3个发包vm，1个收包vm）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;▷ kernel态单核数据包(64B)处理能力为2Mpps&lt;br/&gt;▷ 2Mpps是因为kernel态瓶颈是2Mpps，如果通过dpdk走用户态，则可以大于2M，原因：收包端要将数据包中断平衡到不同的cpu上，方法：可以通过多队列方式，把每个队列分配到单独cpu上（irqbalance会自动均衡），然后source ip不一样，就会对应到不同队列，也就是不同的中断上。即1个VF，2个队列，VM有至少2核，那么当符合负载均衡条件（mac、ip不同），则理论上最大可以达到4Mpps&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;更多测试结果：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以下测试使用的packet大小为64B&lt;/p&gt;
&lt;p&gt;▷ kernel态，3层转发性能:发包器使用不同的source ip&lt;/p&gt;
&lt;p&gt;▪ BCM57800:2Mpps&lt;br/&gt;▪ Intel X520:10Mpps&lt;br/&gt;▪ Intel X710:12Mpps&lt;/p&gt;
&lt;p&gt;▷ kernel态，2层转发性能:发包器使用不同的source mac&lt;/p&gt;
&lt;p&gt;▪ BCM57800:2Mpps&lt;br/&gt;▪ Intel X520:7.3Mpps&lt;br/&gt;▪ Intel X710:7.8Mpps&lt;/p&gt;
&lt;p&gt;▷ kernel态下vxlan封装能力&lt;/p&gt;
&lt;p&gt;▪ vxlan内层使用不同的source ip发包&lt;br/&gt;▪ 收包在:1.1-1.2Mpps&lt;/p&gt;
&lt;p&gt;▷ dpdk用户态，2层转发性能:发包器使用不同的source ip&lt;/p&gt;
&lt;p&gt;▪ BCM57800:不支持&lt;br/&gt;▪ Intel X520:14.8Mpps&lt;br/&gt;▪ Intel X710:14.8Mpps&lt;/p&gt;
&lt;p&gt;▷ SR-IOV模式&lt;/p&gt;
&lt;p&gt;▪ X520总量11.2Mpps，每vm为11.2Mpps/vm总数(即VF数)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;▷ kernel态下的中断平衡的依据因素:2层依据source mac,3层依据source ip&lt;br/&gt;▷ kernel态下使用传统中断模式的单核转发能力极限2Mpps&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;▷ kernel态下，利用多队列RSS中断平衡提升吞吐率，会导致cpu非常高&lt;br/&gt;▷ 用户态下即使source mac或source ip固定，吞吐率基本接近限速14.8Mpps&lt;br/&gt;▷ vxlan不能利用多核来提升吞吐，主要原因为外层source ip不够多&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;到网卡官网下载对应驱动并安装，经测试，win2012默认就有82599（x520）驱动，但版本旧&lt;/p&gt;
&lt;hr/&gt;
&lt;pre&gt;
&lt;code&gt;# 查看网卡支持的vf数量
cat /sys/bus/pci/devices/0000:41:00.0/sriov_totalvfs

# 宿主屏蔽VF驱动后查看vf和pf的对应
https://github.com/intel/SDN-NFV-Hands-on-Samples/blob/master/SR-IOV_Network_Virtual_Functions_in_KVM/listvfs_by_pf.sh
载下来后执行./listvfs_by_pf.sh即可

# 宿主屏蔽VF后查看哪些VF正在被使用
yum install dpdk-tools
dpdk-devbind --status

# 查看网卡对应哪个socket
lstopo-no-graphics

# lspci查看网卡信息
lspci -Dvmm|grep -B 1 -A 4 Ethernet

# 宿主上查看具体VF流量（仅支持x520，x710查不到）
ethtool -S p1p1 | grep VF&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;
&lt;pre&gt;
&lt;code&gt;echo &quot;blacklist ixgbevf&quot; &amp;gt;&amp;gt; /etc/modprobe.d/blacklist.conf&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;表示当物理机启动时候，默认不加载ixgbevf驱动，但是如果手动modprobe ixgbevf，则也会加载驱动。&lt;/p&gt;
&lt;p&gt;如果当前已经加载了ixgbevf，想卸载，则需要如下步骤&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;echo 0 &amp;gt; /sys/bus/pci/devices/0000:41:00.0/sriov_numvfs
rmmod ixgbevf
echo 63 &amp;gt; /sys/bus/pci/devices/0000:41:00.0/sriov_numvfs&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;strong&gt;modprobe pktgen&lt;/strong&gt;：发包通过pktgen来发，收包通过sar -n DEV来看，发的是udp包&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#!/bin/bash

NIC=&quot;eth1&quot;
DST_IP=&quot;192.168.1.2&quot;
DST_MAC=&quot;52:54:00:43:99:65&quot;

modprobe pktgen

pg() {
    echo inject &amp;gt; $PGDEV
    cat $PGDEV
}

pgset() {
    local result
    echo $1 &amp;gt; $PGDEV

    result=`cat $PGDEV | fgrep &quot;Result: OK:&quot;`
    if [ &quot;$result&quot; = &quot;&quot; ]; then
         cat $PGDEV | fgrep Result:
    fi
}
# Config Start Here -----------------------------------------------------------

# thread config
# Each CPU has own thread. Two CPU exammple. We add ens7, eth2 respectivly.

PGDEV=/proc/net/pktgen/kpktgend_0
echo &quot;Removing all devices&quot;
pgset &quot;rem_device_all&quot;
echo &quot;Adding ${NIC}&quot;
pgset &quot;add_device ${NIC}&quot;

# device config
# delay 0 means maximum speed.

CLONE_SKB=&quot;clone_skb 1000000&quot;
# NIC adds 4 bytes CRC
PKT_SIZE=&quot;pkt_size 64&quot;

# COUNT 0 means forever
COUNT=&quot;count 0&quot;
DELAY=&quot;delay 0&quot;

PGDEV=/proc/net/pktgen/${NIC}
echo &quot;Configuring $PGDEV&quot;
pgset &quot;$COUNT&quot;
pgset &quot;$CLONE_SKB&quot;
pgset &quot;$PKT_SIZE&quot;
pgset &quot;$DELAY&quot;
pgset &quot;dst ${DST_IP}&quot;
pgset &quot;dst_mac ${DST_MAC}&quot;

# Time to run
PGDEV=/proc/net/pktgen/pgctrl

echo &quot;Running... ctrl^C to stop&quot;
pgset &quot;start&quot;
echo &quot;Done&quot;

# Result can be vieved in /proc/net/pktgen/eth[3,4]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;▷ 将脚本开头的eth1改为发包对应的网卡&lt;br/&gt;▷ 将脚本开头的192.168.1.2改为目标ip&lt;br/&gt;▷ 将脚本开头的52:54:00:43:99:65改为目标mac&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;pktgen-dpdk&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 固定ip固定mac
set 0 dst ip 192.168.10.240
set 0 src ip 192.168.10.245/24
set 0 dst mac c8:1f:66:d7:58:ba
set 0 src mac a0:36:9f:ec:4a:28


# 可变source ip可变source mac
stop 0
range 0 src ip 192.168.0.1 192.168.0.1 192.168.200.200 0.0.0.1
range 0 dst ip 10.1.1.241 10.1.1.241 10.1.1.241 0.0.0.0
range 0 dst mac c8:1f:66:d7:58:ba c8:1f:66:d7:58:ba c8:1f:66:d7:58:ba 00:00:00:00:00:00
range 0 src mac a0:36:9f:ec:4a:28 a0:36:9f:ec:4a:28 a0:36:9f:ec:ff:ff 00:00:00:00:01:01
range 0 src port 100 100 65530 1
range 0 dst port 100 100 65530 1
range 0 size 64 64 64 0
enable 0 range
enable 0 latency
start 0


# 按50%的速率发包
set 0 rate 50&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;
&lt;pre&gt;
&lt;code&gt;# openstack关于sriov的限制
https://docs.openstack.org/mitaka/networking-guide/config-sriov.html

# 迁移
https://wenku.baidu.com/view/d949db67998fcc22bcd10dfd.html
https://www.chenyudong.com/archives/live-migrate-with-pci-pass-through-fail-with-libvirt-and-qemu.html

# sriov配置
https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/virtualization_host_configuration_and_guest_installation_guide/sect-virtualization_host_configuration_and_guest_installation_guide-sr_iov-how_sr_iov_libvirt_works

# 线速
http://netoptimizer.blogspot.tw/2014/05/the-calculations-10gbits-wirespeed.html&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sun, 20 Oct 2019 15:20:00 +0000</pubDate>
<dc:creator>小慢哥</dc:creator>
<og:description>SRIOV介绍、VF直通配置，以及包转发率性能测试</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/fzxiaomange/p/sriov-kvm-passthrough.html</dc:identifier>
</item>
</channel>
</rss>