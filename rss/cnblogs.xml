<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>可能是最全面的G1学习笔记 - javaadu</title>
<link>http://www.cnblogs.com/javaadu/p/10713956.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/javaadu/p/10713956.html</guid>
<description>&lt;h3 id=&quot;引子&quot;&gt;引子&lt;/h3&gt;
&lt;p&gt;最近遇到很多朋友过来咨询G1调优的问题，我自己去年有专门学过一次G1，但是当时只是看了个皮毛，因此自己也有不少问题。总体来讲，对于G1我有几个疑惑，希望能够在这篇文章中得到解决。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;G1出现的初衷是什么？&lt;/li&gt;
&lt;li&gt;G1适合在什么场景下使用？&lt;/li&gt;
&lt;li&gt;G1的trade-off是什么？&lt;/li&gt;
&lt;li&gt;G1的详细过程？&lt;/li&gt;
&lt;li&gt;如何理解G1的gc日志?&lt;/li&gt;
&lt;li&gt;G1的调优思路？&lt;/li&gt;
&lt;li&gt;G1和CMS的对比和选择？&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;一基础知识&quot;&gt;一、基础知识&lt;/h3&gt;
&lt;h4 id=&quot;初衷&quot;&gt;1. 初衷&lt;/h4&gt;
&lt;p&gt;在G1提出之前，经典的垃圾收集器主要有三种类型：串行收集器、并行收集器和并发标记清除收集器，这三种收集器分别可以是满足Java应用三种不同的需求：内存占用及并发开销最小化、应用吞吐量最大化和应用GC暂停时间最小化，但是，上述三种垃圾收集器都有几个共同的问题：（1）所有针对老年代的操作必须扫描整个老年代空间；（2）新生代和老年代是独立的连续的内存块，必须先决定年轻代和老年代在虚拟地址空间的位置。&lt;/p&gt;
&lt;h4 id=&quot;设计目标&quot;&gt;2. 设计目标&lt;/h4&gt;
&lt;p&gt;G1是一种服务端应用使用的垃圾收集器，目标是用在&lt;strong&gt;多核、大内存&lt;/strong&gt;的机器上，它在大多数情况下可以实现指定的GC暂停时间，同时还能保持较高的吞吐量。&lt;/p&gt;
&lt;h4 id=&quot;使用场景&quot;&gt;3. 使用场景&lt;/h4&gt;
&lt;p&gt;G1适用于以下几种应用：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;可以像CMS收集器一样，允许垃圾收集线程和应用线程并行执行，即需要额外的CPU资源；&lt;/li&gt;
&lt;li&gt;压缩空闲空间不会延长GC的暂停时间；&lt;/li&gt;
&lt;li&gt;需要更易预测的GC暂停时间；&lt;/li&gt;
&lt;li&gt;不需要实现很高的吞吐量&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;二g1的重要概念&quot;&gt;二、G1的重要概念&lt;/h3&gt;
&lt;h4 id=&quot;分区region&quot;&gt;1. 分区（Region）&lt;/h4&gt;
&lt;p&gt;G1采取了不同的策略来解决并行、串行和CMS收集器的碎片、暂停时间不可控制等问题——G1将整个堆分成相同大小的&lt;strong&gt;分区（Region）&lt;/strong&gt;，如下图所示。&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/44770-09d482d0794827e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;G1的堆模型&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每个分区都可能是年轻代也可能是老年代，但是在同一时刻只能属于某个代。&lt;br/&gt;年轻代、幸存区、老年代这些概念还存在，成为逻辑上的概念，这样方便复用之前分代框架的逻辑。在物理上不需要连续，则带来了额外的好处——有的分区内垃圾对象特别多，有的分区内垃圾对象很少，G1会优先回收垃圾对象特别多的分区，这样可以花费较少的时间来回收这些分区的垃圾，这也就是G1名字的由来，即首先收集垃圾最多的分区。&lt;/p&gt;
&lt;p&gt;新生代其实并不是适用于这种算法的，依然是在新生代满了的时候，对整个新生代进行回收——整个新生代中的对象，要么被回收、要么晋升，至于新生代也采取分区机制的原因，则是因为这样跟老年代的策略统一，方便调整代的大小。&lt;/p&gt;
&lt;p&gt;G1还是一种带压缩的收集器，在回收老年代的分区时，是将存活的对象从一个分区拷贝到另一个可用分区，这个拷贝的过程就实现了局部的压缩。每个分区的大小从1M到32M不等，但是都是2的冥次方。&lt;/p&gt;
&lt;h4 id=&quot;收集集合cset&quot;&gt;2. 收集集合（CSet）&lt;/h4&gt;
&lt;p&gt;一组可被回收的分区的集合。在CSet中存活的数据会在GC过程中被移动到另一个可用分区，CSet中的分区可以来自Eden空间、survivor空间、或者老年代。CSet会占用不到整个堆空间的1%大小。&lt;/p&gt;
&lt;h4 id=&quot;已记忆集合rset&quot;&gt;3. 已记忆集合（RSet）&lt;/h4&gt;
&lt;p&gt;RSet记录了其他Region中的对象引用本Region中对象的关系，属于points-into结构（谁引用了我的对象）。RSet的价值在于使得垃圾收集器不需要扫描整个堆找到谁引用了当前分区中的对象，只需要扫描RSet即可。&lt;/p&gt;
&lt;p&gt;如下图所示，Region1和Region3中的对象都引用了Region2中的对象，因此在Region2的RSet中记录了这两个引用。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/44770-86d5381d1eaa4398.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;RSet的示意图&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;摘一段R大的解释：G1 GC则是在points-out的card table之上再加了一层结构来构成points-into RSet：每个region会记录下到底哪些别的region有指向自己的指针，而这些指针分别在哪些card的范围内。 这个RSet其实是一个hash table，key是别的region的起始地址，value是一个集合，里面的元素是card table的index。 举例来说，如果region A的RSet里有一项的key是region B，value里有index为1234的card，它的意思就是region B的一个card里有引用指向region A。所以对region A来说，该RSet记录的是points-into的关系；而card table仍然记录了points-out的关系。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;snapshot-at-the-beginningsatb&quot;&gt;4. Snapshot-At-The-Beginning(SATB)&lt;/h4&gt;
&lt;p&gt;SATB是维持并发GC的正确性的一个手段，G1GC的并发理论基础就是SATB，SATB是由Taiichi Yuasa为增量式标记清除垃圾收集器设计的一个标记算法。Yuasa的SATAB的标记优化主要针对标记-清除垃圾收集器的并发标记阶段。按照R大的说法：CMS的incremental update设计使得它在remark阶段必须重新扫描所有线程栈和整个young gen作为root；G1的SATB设计在remark阶段则只需要扫描剩下的satb_mark_queue。&lt;/p&gt;
&lt;p&gt;SATB算法创建了一个对象图，它是堆的一个逻辑“快照”。标记数据结构包括了两个位图：previous位图和next位图。previous位图保存了最近一次完成的标记信息，并发标记周期会创建并更新next位图，随着时间的推移，previous位图会越来越过时，最终在并发标记周期结束的时候，next位图会将previous位图覆盖掉。&lt;br/&gt;下面我们以几个图例来描述SATB算法的过程：&lt;/p&gt;
&lt;ol readability=&quot;5.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;在并发周期开始之前，NTAMS字段被设置到每个分区当前的顶部，并发周期启动后分配的对象会被放在TAMS之前（图里下边的部分），同时被明确定义为隐式存活对象，而TAMS之后（图里上边的部分）的对象则需要被明确地标记。&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/44770-3bf82355da6e3693.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;初始标记过程中的一个堆分区&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;并发标记过程中的堆分区&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/44770-baf374962ebc8fd6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;并发标记过程中的对分区&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;位于堆分区的Bottom和PTAMS之间的对象都会被标记并记录在previous位图中；&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/44770-727cd8d8ca8970c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;位于Bottom和PTAMS之间的对象都会被标记在previous位图中&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;位于堆分区的Top和PATMS之间的对象均为隐式存活对象，同时也记录在previous位图中；&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/44770-36d3cd5cb655130a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;隐式存活标记，是一种增量标记&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在重新标记阶段的最后，所有NTAMS之前的对象都会被标记&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/44770-f2a131620f5a610e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;重新标记&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;在并发标记阶段分配的对象会被分配到NTAMS之后的空间，它们会作为隐式存活对象被记录在next位图中。一次并发标记周期完成后，这个next位图会覆盖previous位图，然后将next位图清空。&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/44770-db67d11a613ce4da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;开始并发标记后的对象会被识别为隐式存活对象，放在next位图中&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;SATB是一个快照标记算法，在并发标记进行的过程中，垃圾收集器（Collecotr）和应用程序（Mutator）都在活动，如果一个对象还没被mark到，这时候Mutator就修改了它的引用，那么这时候拿到的快照就是不完整的了，如何解决这个问题呢?G1 GC使用了SATB write barrier来解决这个问题——在并发标记过程中，将该对象的旧的引用记录在一个SATB日志对列或缓冲区中。去翻G1的代码，却发现实际代码如下——只该对象入队列，并没有将整个修改过程放在写屏障之间完成。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;  // hotspot/src/share/vm/gc_implementation/g1/g1SATBCardTableModRefBS.hpp
  // This notes that we don't need to access any BarrierSet data
  // structures, so this can be called from a static context.
  template &amp;lt;class T&amp;gt; static void write_ref_field_pre_static(T* field, oop newVal) {
    T heap_oop = oopDesc::load_heap_oop(field);
    if (!oopDesc::is_null(heap_oop)) {
      enqueue(oopDesc::decode_heap_oop(heap_oop));
    }
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;enqueue的真正代码在&lt;code&gt;hotspot/src/share/vm/gc_implementation/g1/g1SATBCardTableModRefBS.cpp&lt;/code&gt;中，这里使用&lt;code&gt;JavaThread::satb_mark_queue_set().is_active()&lt;/code&gt;判断是否处于并发标记周期。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void G1SATBCardTableModRefBS::enqueue(oop pre_val) {
  // Nulls should have been already filtered.
  assert(pre_val-&amp;gt;is_oop(true), &quot;Error&quot;);

  if (!JavaThread::satb_mark_queue_set().is_active()) return;
  Thread* thr = Thread::current();
  if (thr-&amp;gt;is_Java_thread()) {
    JavaThread* jt = (JavaThread*)thr;
    //将旧值入队
    jt-&amp;gt;satb_mark_queue().enqueue(pre_val);
  } else {
    MutexLockerEx x(Shared_SATB_Q_lock, Mutex::_no_safepoint_check_flag);
    JavaThread::satb_mark_queue_set().shared_satb_queue()-&amp;gt;enqueue(pre_val);
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;stab_mark_queue.enqueue方法首先尝试将以前的值记录在一个缓冲区中，如果这个缓冲区已经满了，就会将当期这个SATB缓冲区“退休”并放入全局列表中，然后再给线程分配一个新的SATB缓冲区。并发标记线程会定期检查和处理那些“被填满”的缓冲区。&lt;/p&gt;
&lt;h3 id=&quot;三g1的过程&quot;&gt;三、G1的过程&lt;/h3&gt;
&lt;h4 id=&quot;四个操作&quot;&gt;1. 四个操作&lt;/h4&gt;
&lt;p&gt;G1收集器的收集活动主要有四种操作：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;新生代垃圾收集&lt;/li&gt;
&lt;li&gt;后台收集、并发周期&lt;/li&gt;
&lt;li&gt;混合式垃圾收集&lt;/li&gt;
&lt;li&gt;必要时候的Full GC&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;第一、新生代垃圾收集的图例如下：&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/44770-76a5c1ff8af26a1e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Eden区耗尽的时候就会触发新生代收集，新生代垃圾收集会对整个新生代进行回收&lt;/li&gt;
&lt;li&gt;新生代垃圾收集期间，整个应用STW&lt;/li&gt;
&lt;li&gt;新生代垃圾收集是由多线程并发执行的&lt;/li&gt;
&lt;li&gt;新生代收集结束后依然存活的对象，会被拷贝到一个新的Survivor分区，或者是老年代。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;G1设计了一个标记阈值，它描述的是总体Java堆大小的百分比，默认值是45，这个值可以通过命令&lt;code&gt;-XX:InitiatingHeapOccupancyPercent(IHOP)&lt;/code&gt;来调整，一旦达到这个阈值就回触发一次并发收集周期。注意：这里的百分比是针对整个堆大小的百分比，而CMS中的&lt;code&gt;CMSInitiatingOccupancyFraction&lt;/code&gt;命令选型是针对老年代的百分比。并发收集周期的图例如下：&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/44770-3c606fba02f4cfb5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在上图中有几个情况需要注意：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;新生代的空间占用情况发生了变化——在并发收集周期中，至少有一次（很可能是多次）新生代垃圾收集；&lt;/li&gt;
&lt;li&gt;注意到一些分区被标记为X，这些分区属于老年代，它们就是标记周期找出的包含最多垃圾的分区（注意：它们内部仍然保留着数据）；&lt;/li&gt;
&lt;li&gt;老年代的空间占用在标记周期结束后变得更多，这是因为在标记周期期间，新生代的垃圾收集会晋升对象到老年代，而且标记周期中并不会是否老年代的任何对象。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;第二、G1的并发标记周期包括多个阶段：&lt;br/&gt;并发标记周期采用的算法是我们前文提到的SATB标记算法，产出是找出一些垃圾对象最多的老年代分区。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;初始标记（initial-mark），在这个阶段，应用会经历STW，通常初始标记阶段会跟一次新生代收集一起进行，换句话说——既然这两个阶段都需要暂停应用，G1 GC就重用了新生代收集来完成初始标记的工作。在新生代垃圾收集中进行初始标记的工作，会让停顿时间稍微长一点，并且会增加CPU的开销。初始标记做的工作是设置两个TAMS变量（NTAMS和PTAMS）的值，所有在TAMS之上的对象在这个并发周期内会被识别为隐式存活对象；&lt;/li&gt;
&lt;li&gt;根分区扫描（root-region-scan），这个过程不需要暂停应用，在初始标记或新生代收集中被拷贝到survivor分区的对象，都需要被看做是根，这个阶段G1开始扫描survivor分区，所有被survivor分区所引用的对象都会被扫描到并将被标记。survivor分区就是根分区，正因为这个，该阶段不能发生新生代收集，如果扫描根分区时，新生代的空间恰好用尽，新生代垃圾收集必须等待根分区扫描结束才能完成。如果在日志中发现根分区扫描和新生代收集的日志交替出现，就说明当前应用需要调优。&lt;/li&gt;
&lt;li&gt;并发标记阶段（concurrent-mark），并发标记阶段是多线程的，我们可以通过&lt;code&gt;-XX:ConcGCThreads&lt;/code&gt;来设置并发线程数，默认情况下，G1垃圾收集器会将这个线程总数设置为并行垃圾线程数（&lt;code&gt;-XX:ParallelGCThreads&lt;/code&gt;）的四分之一；并发标记会利用trace算法找到所有活着的对象，并记录在一个bitmap中，因为在TAMS之上的对象都被视为隐式存活，因此我们只需要遍历那些在TAMS之下的；记录在标记的时候发生的引用改变，SATB的思路是在开始的时候设置一个快照，然后假定这个快照不改变，根据这个快照去进行trace，这时候如果某个对象的引用发生变化，就需要通过pre-write barrier logs将该对象的旧的值记录在一个SATB缓冲区中，如果这个缓冲区满了，就把它加到一个全局的列表中——G1会有并发标记的线程定期去处理这个全局列表。&lt;/li&gt;
&lt;li&gt;重新标记阶段（remarking），重新标记阶段是最后一个标记阶段，需要暂停整个应用，G1垃圾收集器会处理掉剩下的SATB日志缓冲区和所有更新的引用，同时G1垃圾收集器还会找出所有未被标记的存活对象。这个阶段还会负责引用处理等工作。&lt;/li&gt;
&lt;li&gt;清理阶段（cleanup），清理阶段真正回收的内存很小，截止到这个阶段,G1垃圾收集器主要是标记处哪些老年代分区可以回收，将老年代按照它们的存活度（liveness）从小到大排列。这个过程还会做几个事情：识别出所有空闲的分区、RSet梳理、将不用的类从metaspace中卸载、回收巨型对象等等。识别出每个分区里存活的对象有个好处是在遇到一个完全空闲的分区时，它的RSet可以立即被清理，同时这个分区可以立刻被回收并释放到空闲队列中，而不需要再放入CSet等待混合收集阶段回收；梳理RSet有助于发现无用的引用。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;第三、混合收集只会回收一部分老年代分区，下图是第一次混合收集前后的堆情况对比。&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/44770-dea8413e90459945.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;混合收集会执行多次，一直运行到（几乎）所有标记点老年代分区都被回收，在这之后就会恢复到常规的新生代垃圾收集周期。当整个堆的使用率超过指定的百分比时，G1 GC会启动新一轮的并发标记周期。在混合收集周期中，对于要回收的分区，会将该分区中存活的数据拷贝到另一个分区，这也是为什么G1收集器最终出现碎片化的频率比CMS收集器小得多的原因——以这种方式回收对象，实际上伴随着针对当前分区的压缩。&lt;/p&gt;
&lt;h4 id=&quot;两个模式&quot;&gt;2. 两个模式&lt;/h4&gt;
&lt;p&gt;G1收集器的模式主要有两种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Young GC（新生代垃圾收集）&lt;/li&gt;
&lt;li&gt;Mixed GC（混合垃圾收集）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在R大的帖子中，给出了一个假象的G1垃圾收集运行过程，如下图所示，在结合上一小节的细节，就可以将G1 GC的正常过程理解清楚了。&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/44770-d30169030aef1d08.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;巨型对象的管理&quot;&gt;3. 巨型对象的管理&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;巨型对象&lt;/strong&gt;：在G1中，如果一个对象的大小超过分区大小的一半，该对象就被定义为&lt;strong&gt;巨型对象（Humongous Object）&lt;/strong&gt;。巨型对象时直接分配到老年代分区，如果一个对象的大小超过一个分区的大小，那么会直接在老年代分配两个连续的分区来存放该巨型对象。巨型分区一定是连续的，分配之后也不会被移动——没啥益处。&lt;/p&gt;
&lt;p&gt;由于巨型对象的存在，G1的堆中的分区就分成了三种类型：新生代分区、老年代分区和巨型分区，如下图所示：&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/44770-cd13ea552919353f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果一个巨型对象跨越两个分区，开始的那个分区被称为“开始巨型”，后面的分区被称为“连续巨型”，这样最后一个分区的一部分空间是被浪费掉的，如果有很多巨型对象都刚好比分区大小多一点，就会造成很多空间的浪费，从而导致堆的碎片化。如果你发现有很多由于巨型对象分配引起的连续的并发周期，并且堆已经碎片化（明明空间够，但是触发了FULL GC），可以考虑调整&lt;code&gt;-XX:G1HeapRegionSize&lt;/code&gt;参数，减少或消除巨型对象的分配。&lt;/p&gt;
&lt;p&gt;关于巨型对象的回收：在JDK8u40之前，巨型对象的回收只能在并发收集周期的清除阶段或FULL GC过程中过程中被回收，在JDK8u40（包括这个版本）之后，一旦没有任何其他对象引用巨型对象，那么巨型对象也可以在年轻代收集中被回收。&lt;/p&gt;
&lt;h4 id=&quot;g1执行过程中的异常情况&quot;&gt;4. G1执行过程中的异常情况&lt;/h4&gt;
&lt;h5 id=&quot;并发标记周期开始后的full-gc&quot;&gt;并发标记周期开始后的FULL GC&lt;/h5&gt;
&lt;p&gt;G1启动了标记周期，但是在并发标记完成之前，就发生了Full GC，日志常常如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;51.408: [GC concurrent-mark-start]
65.473: [Full GC 4095M-&amp;gt;1395M(4096M), 6.1963770 secs]
 [Times: user=7.87 sys=0.00, real=6.20 secs]
71.669: [GC concurrent-mark-abort]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;GC concurrent-mark-start开始之后就发生了FULL GC，这说明针对老年代分区的回收速度比较慢，或者说对象过快得从新生代晋升到老年代，或者说是有很多大对象直接在老年代分配。针对上述原因，我们可能需要做的调整有：调大整个堆的大小、更快得触发并发回收周期、让更多的回收线程参与到垃圾收集的动作中。&lt;/p&gt;
&lt;h5 id=&quot;混合收集模式中的full-gc&quot;&gt;混合收集模式中的FULL GC&lt;/h5&gt;
&lt;p&gt;在GC日志中观察到，在一次混合收集之后跟着一条FULL GC，这意味着混合收集的速度太慢，在老年代释放出足够多的分区之前，应用程序就来请求比当前剩余可分配空间大的内存。针对这种情况我们可以做的调整：增加每次混合收集收集掉的老年代分区个数；增加并发标记的线程数；提高混合收集发生的频率。&lt;/p&gt;
&lt;h5 id=&quot;疏散失败转移失败&quot;&gt;疏散失败（转移失败）&lt;/h5&gt;
&lt;p&gt;在新生代垃圾收集快结束时，找不到可用的分区接收存活下来的对象，常见如下的日志：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;60.238: [GC pause (young) (to-space overflow), 0.41546900 secs]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这意味着整个堆的碎片化已经非常严重了，我们可以从以下几个方面调整：（1）增加整个堆的大小——通过增加&lt;code&gt;-XX:G1ReservePercent&lt;/code&gt;选项的值（并相应增加总的堆大小），为“目标空间”增加预留内存量;（2）通过减少 &lt;code&gt;-XX:InitiatingHeapOccupancyPercent&lt;/code&gt;提前启动标记周期；（3）&lt;br/&gt;你也可以通过增加&lt;code&gt;-XX:ConcGCThreads&lt;/code&gt;选项的值来增加并发标记线程的数目；&lt;/p&gt;
&lt;h5 id=&quot;巨型对象分配失败&quot;&gt;巨型对象分配失败&lt;/h5&gt;
&lt;p&gt;如果在GC日志中看到莫名其妙的FULL GC日志，又对应不到上述讲过的几种情况，那么就可以怀疑是巨型对象分配导致的，这里我们可以考虑使用&lt;code&gt;jmap&lt;/code&gt;命令进行堆dump，然后通过MAT对堆转储文件进行分析。关于堆转储文件的分析技巧，后续会有专门的文章介绍。&lt;/p&gt;
&lt;h3 id=&quot;四g1的调优&quot;&gt;四、G1的调优&lt;/h3&gt;
&lt;p&gt;G1的调优目标主要是在避免FULL GC和疏散失败的前提下，尽量实现较短的停顿时间和较高的吞吐量。关于G1 GC的调优，需要记住以下几点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;不要自己显式设置新生代的大小（用&lt;code&gt;Xmn&lt;/code&gt;或&lt;code&gt;-XX:NewRatio&lt;/code&gt;参数），如果显式设置新生代的大小，会导致目标时间这个参数失效。&lt;/li&gt;
&lt;li&gt;由于G1收集器自身已经有一套预测和调整机制了，因此我们首先的选择是相信它，即调整&lt;code&gt;-XX:MaxGCPauseMillis=N&lt;/code&gt;参数，这也符合G1的目的——让GC调优尽量简单，这里有个取舍：如果减小这个参数的值，就意味着会调小新生代的大小，也会导致新生代GC发生得更频繁，同时，还会导致混合收集周期中回收的老年代分区减少，从而增加FULL GC的风险。这个时间设置得越短，应用的吞吐量也会受到影响。&lt;/li&gt;
&lt;li&gt;针对混合垃圾收集的调优。如果调整这期望的最大暂停时间这个参数还是无法解决问题，即在日志中仍然可以看到FULL GC的现象，那么就需要自己手动做一些调整，可以做的调整包括：&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;调整G1垃圾收集的后台线程数，通过设置&lt;code&gt;-XX:ConcGCThreads=n&lt;/code&gt;这个参数，可以增加后台标记线程的数量，帮G1赢得这场你追我赶的游戏；&lt;/li&gt;
&lt;li&gt;调整G1垃圾收集器并发周期的频率，如果让G1更早得启动垃圾收集，也可以帮助G1赢得这场比赛，那么可以通过设置&lt;code&gt;-XX:InitiatingHeapOccupancyPercent&lt;/code&gt;这个参数来实现这个目标，如果将这个参数调小，G1就会更早得触发并发垃圾收集周期。这个值需要谨慎设置：如果这个参数设置得太高，会导致FULL GC出现得频繁；如果这个值设置得过小，又会导致G1频繁得进行并发收集，白白浪费CPU资源。通过GC日志可以通过一个点来判断GC是否正常——在一轮并发周期结束后，需要确保堆剩下的空间小于InitiatingHeapOccupancyPercent的值。&lt;/li&gt;
&lt;li&gt;调整G1垃圾收集器的混合收集的工作量，即在一次混合垃圾收集中尽量多处理一些分区，可以从另外一方面提高混合垃圾收集的频率。在一次混合收集中可以回收多少分区，取决于三个因素：（1）有多少个分区被认定为垃圾分区，&lt;code&gt;-XX:G1MixedGCLiveThresholdPercent=n&lt;/code&gt;这个参数表示如果一个分区中的存活对象比例超过n，就不会被挑选为垃圾分区，因此可以通过这个参数控制每次混合收集的分区个数，这个参数的值越大，某个分区越容易被当做是垃圾分区；（2）G1在一个并发周期中，最多经历几次混合收集周期，这个可以通过&lt;code&gt;-XX:G1MixedGCCountTarget=n&lt;/code&gt;设置，默认是8，如果减小这个值，可以增加每次混合收集收集的分区数，但是可能会导致停顿时间过长；（3）期望的GC停顿的最大值，由&lt;code&gt;MaxGCPauseMillis&lt;/code&gt;参数确定，默认值是200ms，在混合收集周期内的停顿时间是向上规整的，如果实际运行时间比这个参数小，那么G1就能收集更多的分区。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;五g1的最佳实践&quot;&gt;五、G1的最佳实践&lt;/h3&gt;
&lt;h4 id=&quot;关键参数项&quot;&gt;1. 关键参数项&lt;/h4&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li&gt;&lt;code&gt;-XX:+UseG1GC&lt;/code&gt;，告诉JVM使用G1垃圾收集器&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-XX:MaxGCPauseMillis=200&lt;/code&gt;，设置GC暂停时间的目标最大值，这是个柔性的目标，JVM会尽力达到这个目标&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;code&gt;-XX:INitiatingHeapOccupancyPercent=45&lt;/code&gt;，如果整个堆的使用率超过这个值，G1会触发一次并发周期。记住这里针对的是整个堆空间的比例，而不是某个分代的比例。&lt;/p&gt;
&lt;h4 id=&quot;最佳实践&quot;&gt;2. 最佳实践&lt;/h4&gt;
&lt;h5 id=&quot;不要设置年轻代的大小&quot;&gt;不要设置年轻代的大小&lt;/h5&gt;
通过&lt;code&gt;-Xmn&lt;/code&gt;显式设置年轻代的大小，会干扰G1收集器的默认行为：&lt;/li&gt;
&lt;li&gt;G1不再以设定的暂停时间为目标，换句话说，如果设置了年轻代的大小，就无法实现自适应的调整来达到指定的暂停时间这个目标&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;G1不能按需扩大或缩小年轻代的大小&lt;/p&gt;
&lt;h5 id=&quot;响应时间度量&quot;&gt;响应时间度量&lt;/h5&gt;
&lt;p&gt;不要根据平均响应时间（ART）来设置&lt;code&gt;-XX:MaxGCPauseMillis=n&lt;/code&gt;这个参数，应该设置希望90%的GC都可以达到的暂停时间。这意味着90%的用户请求不会超过这个响应时间，记住，这个值是一个目标，但是G1并不保证100%的GC暂停时间都可以达到这个目标&lt;/p&gt;
&lt;h4 id=&quot;g1-gc的参数选项&quot;&gt;3. G1 GC的参数选项&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;24&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;-XX:+UseG1GC&lt;/td&gt;
&lt;td&gt;使用G1收集器&lt;/td&gt;
&lt;td&gt;JDK1.8中还需要显式指定&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;-XX:MaxGCPauseMillis=n&lt;/td&gt;
&lt;td&gt;设置一个期望的最大GC暂停时间，这是一个柔性的目标，JVM会尽力去达到这个目标&lt;/td&gt;
&lt;td&gt;200&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;-XX:InitiatingHeapOccupancyPercent=n&lt;/td&gt;
&lt;td&gt;当整个堆的空间使用百分比超过这个值时，就会触发一次并发收集周期，记住是整个堆&lt;/td&gt;
&lt;td&gt;45&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;-XX:NewRatio=n&lt;/td&gt;
&lt;td&gt;新生代和老年代的比例&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;-XX:SurvivorRatio=n&lt;/td&gt;
&lt;td&gt;Eden空间和Survivor空间的比例&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;-XX:MaxTenuringThreshold=n&lt;/td&gt;
&lt;td&gt;对象在新生代中经历的最多的新生代收集，或者说最大的岁数&lt;/td&gt;
&lt;td&gt;G1中是15&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;-XX:ParallelGCThreads=n&lt;/td&gt;
&lt;td&gt;设置垃圾收集器的并行阶段的垃圾收集线程数&lt;/td&gt;
&lt;td&gt;不同的平台有不同的值&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;-XX:ConcGCThreads=n&lt;/td&gt;
&lt;td&gt;设置垃圾收集器并发执行GC的线程数&lt;/td&gt;
&lt;td&gt;n一般是ParallelGCThreads的四分之一&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;-XX:G1ReservePercent=n&lt;/td&gt;
&lt;td&gt;设置作为空闲空间的预留内存百分比，以降低目标空间溢出（疏散失败）的风险。默认值是 10%。增加或减少这个值，请确保对总的 Java 堆调整相同的量&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;-XX:G1HeapRegionSize=n&lt;/td&gt;
&lt;td&gt;分区的大小&lt;/td&gt;
&lt;td&gt;堆内存大小的1/2000，单位是MB，值是2的幂，范围是1MB到32MB之间&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;-XX:G1HeapWastePercent=n&lt;/td&gt;
&lt;td&gt;设置您愿意浪费的堆百分比。如果可回收百分比小于堆废物百分比，JavaHotSpotVM不会启动混合垃圾回收周期（注意，这个参数可以用于调整混合收集的频率）。&lt;/td&gt;
&lt;td&gt;JDK1.8是5&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;6&quot;&gt;&lt;td&gt;-XX:G1MixedGCCountTarget=8&lt;/td&gt;
&lt;td&gt;设置并发周期后需要执行多少次混合收集，如果混合收集中STW的时间过长，可以考虑增大这个参数。（注意：这个可以用来调整每次混合收集中回收掉老年代分区的多少，即调节混合收集的停顿时间）&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;7&quot;&gt;&lt;td&gt;-XX:G1MixedGCLiveThresholdPercent=n&lt;/td&gt;
&lt;td&gt;一个分区是否会被放入mix GC的CSet的阈值。对于一个分区来说，它的存活对象率如果超过这个比例，则改分区不会被列入mixed gc的CSet中&lt;/td&gt;
&lt;td&gt;JDK1.6和1.7是65，JDK1.8是85&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;常见问题&quot;&gt;常见问题&lt;/h3&gt;
&lt;ol readability=&quot;4.4795650095602&quot;&gt;&lt;li&gt;Young GC、Mixed GC和Full GC的区别？&lt;br/&gt;答：Young GC的CSet中只包括年轻代的分区，Mixed GC的CSet中除了包括年轻代分区，还包括老年代分区；Full GC会暂停整个引用，同时对新生代和老年代进行收集和压缩。&lt;/li&gt;
&lt;li&gt;ParallelGCThreads和ConcGCThreads的区别？&lt;br/&gt;答：ParallelGCThreads指得是在STW阶段，并行执行垃圾收集动作的线程数，ParallelGCThreads的值一般等于逻辑CPU核数，如果CPU核数大于8，则设置为&lt;code&gt;5/8 * cpus&lt;/code&gt;，在SPARC等大型机上这个系数是5/16。；ConcGCThreads指的是在并发标记阶段，并发执行标记的线程数，一般设置为ParallelGCThreads的四分之一。&lt;/li&gt;
&lt;li readability=&quot;1.9747340425532&quot;&gt;
&lt;p&gt;write barrier在GC中的作用？如何理解G1 GC中write barrier的作用？&lt;br/&gt;写屏障是一种内存管理机制，用在这样的场景——当代码尝试修改一个对象的引用时，在前面放上写屏障就意味着将这个对象放在了写屏障后面。write barrier在GC中的作用有点复杂，我们这里以trace GC算法为例讲下：trace GC有些算法是并发的，例如CMS和G1，即用户线程和垃圾收集线程可以同时运行，即mutator一边跑，collector一边收集。这里有一个限制是：黑色的对象不应该指向任何白色的对象。如果mutator视图让一个黑色的对象指向一个白色的对象，这个限制就会被打破，然后GC就会失败。针对这个问题有两种解决思路：（1）通过添加read barriers阻止mutator看到白色的对象；（2）通过write barrier阻止mutator修改一个黑色的对象，让它指向一个白色的对象。write barrier的解决方法就是讲黑色的对象放到写write barrier后面。如果真得发生了white-on-black这种写需求，一般也有多种修正方法：增量得将白色的对象变灰，将黑色的对象重新置灰等等。我理解，增量的变灰就是CMS和G1里并发标记的过程，将黑色的对象重新变灰就是利用卡表或SATB的缓冲区将黑色的对象重新置灰的过程，当然会在重新标记中将所有灰色的对象处理掉。关于G1中write barrier的作用，可以参考&lt;a href=&quot;https://hllvm-group.iteye.com/group/topic/44381?page=3&quot;&gt;R大的这个帖子&lt;/a&gt;里提到的：&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/44770-3abfa971618507fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;G1里在并发标记的时候，如果有对象的引用修改，要将旧的值写到一个缓冲区中，这个动作前后会有一个write barrier，这段可否细说下？&lt;br/&gt;答：这块涉及到SATB标记算法的原理，SATB是指start at the beginning，即在并发收集周期的第一个阶段（初始标记）是STW的，会给所有的分区做个快照，后面的扫描都是按照这个快照进行；在并发标记周期的第二个阶段，并发标记，这是收集线程和应用线程同时进行的，这时候应用线程就可能修改了某些引用的值，导致上面那个快照不是完整的，因此G1就想了个办法，我把在这个期间对对象引用的修改都记录动作都记录下来，有点像mysql的操作日志。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;6.5&quot;&gt;
&lt;p&gt;GC算法中的三色标记算法怎么理解？&lt;br/&gt;trace GC将对象分为三类：白色（垃圾收集器未探测到的对象）、灰色（活着的对象，但是依然没有被垃圾收集器扫描过）、黑色（活着的对象，并且已经被垃圾收集器扫描过）。垃圾收集器的工作过程，就是通过灰色对象的指针扫描它指向的白色对象，如果找到一个白色对象，就将它设置为灰色，如果某个灰色对象的可达对象已经全部找完，就将它设置为黑色对象。当在当前集合中找不到灰色的对象时，就说明该集合的回收动作完成，然后所有白色的对象的都会被回收。PS：这个问题来自参考资料17，我将原文也贴在下面：&lt;/p&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;For a tracing collector (marking or copying), one conceptually colours the data white (not yet seen by the collector), black (alive and scanned by the collector) and grey (alive but not yet scanned by the collector). The collector proceeds by scanning grey objects for pointers to white objects. The white objects found are turned grey, and the grey objects scanned are turned black. When there are no more grey objects, the collection is complete and all the white objects can be recycled.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;参考资料&quot;&gt;参考资料&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://blogs.oracle.com/poonam/understanding-g1-gc-logs&quot;&gt;Understanding G1 GC Logs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.oracle.com/technetwork/articles/java/g1gc-1984535.html&quot;&gt;Garbage First Garbage Collector Tuning&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.oracle.com/technetwork/cn/articles/java/g1gc-1984535-zhs.html&quot;&gt;垃圾优先型回收器调优&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc.html#garbage_first_garbage_collection&quot;&gt;Oracle的GC调优文档——G1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.oracle.com/technetwork/java/javase/tech/g1-intro-jsp-135488.html&quot;&gt;The Garbage-First Garbage Collector&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://item.jd.com/11896988.html&quot;&gt;《Java性能权威指南》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://item.jd.com/12154276.html&quot;&gt;《Java性能调优指南》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/index.html#summary&quot;&gt;G1入门，O记官网的PPT&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://tech.meituan.com/g1.html&quot;&gt;Java Hotspot G1 GC的一些关键技术&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://app.yinxiang.com/shard/s44/nl/9245418/fe5882c3-2fdf-440b-9a70-f6cf165979f4/&quot;&gt;G1 GC的论文&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://hllvm-group.iteye.com/group/topic/44381&quot;&gt;R大关于G1 GC的帖子&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.infoq.com/articles/tuning-tips-G1-GC&quot;&gt;Tips for Tuning the Garbage First Garbage Collector&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://item.jd.com/12154276.html&quot;&gt;Java性能调优指南&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://item.jd.com/11896988.html&quot;&gt;Java性能权威指南&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/35380827/g1-what-are-the-differences-between-mixed-gc-and-full-gc&quot;&gt;G1: What are the differences between mixed gc and full gc?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.redhat.com/en/blog/part-1-introduction-g1-garbage-collector&quot;&gt;Part 1: Introduction to the G1 Garbage Collector&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.redhat.com/en/blog/collecting-and-reading-g1-garbage-collector-logs-part-2?source=author&amp;amp;term=22991&quot;&gt;Collecting and reading G1 garbage collector logs - part 2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.iecc.com/gclist/GC-algorithms.html&quot;&gt;GC FAQ -- algorithms&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;&lt;p&gt;本号专注于后端技术、JVM问题排查和优化、Java面试题、个人成长和自我管理等主题，为读者提供一线开发者的工作和成长经验，期待你能在这里有所收获。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/44770-7daebe9e48739106.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;javaadu&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 15 Apr 2019 23:19:00 +0000</pubDate>
<dc:creator>javaadu</dc:creator>
<og:description>引子 最近遇到很多朋友过来咨询G1调优的问题，我自己去年有专门学过一次G1，但是当时只是看了个皮毛，因此自己也有不少问题。总体来讲，对于G1我有几个疑惑，希望能够在这篇文章中得到解决。 1. G1出现</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/javaadu/p/10713956.html</dc:identifier>
</item>
<item>
<title>成为一个小的管理者 - 冰魄秋雨</title>
<link>http://www.cnblogs.com/skyice/p/10714347.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/skyice/p/10714347.html</guid>
<description>&lt;h3 id=&quot;成为一个小的管理者&quot;&gt;成为一个小的管理者&lt;/h3&gt;
&lt;p&gt;对于入职场没几年的人来说，管理一个团队的机会比较少，大多是会有一个老大来管理自己，但是管理的能力确实我们需要好好的学习。对于程序员来说，逐渐的一部分的精力会花费到管理上来，不管自己愿不愿，毕竟到了一定阶段，我们都将会是一个独挡一面的人，但一个项目不太可能只有自己一个人，如果管理，如何协调周围的人，让项目快速起来。下面是自己一些经历和观察到其他管理者的一点经历。&lt;/p&gt;
&lt;h4 id=&quot;一分解任务安排任务&quot;&gt;&lt;a id=&quot;1&quot;&gt;一、分解任务，安排任务&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;项目会有许多功能，这些功能点之间的联系，如果进行关联上，至少自己心里有一个底。对一个团队来说，需要每个人有不同的分工，不可能所有人一起上，需要一起协调配合，那么最开始，如何分解任务就比较重要。举一个后台管理系统的项目。该项目一个OA系统，系统的功能是人员列表,考勤管理，工作事项等等。这些是一个功能点，然后接着根据需求文档和原型设计。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;人员列表&lt;/td&gt;
&lt;td&gt;人员查询列表&lt;/td&gt;
&lt;td&gt;0.5天&lt;/td&gt;
&lt;td&gt;小明&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;人员列表&lt;/td&gt;
&lt;td&gt;人员录入页面&lt;/td&gt;
&lt;td&gt;0.3天&lt;/td&gt;
&lt;td&gt;小明&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;考勤管理&lt;/td&gt;
&lt;td&gt;考勤显示页面&lt;/td&gt;
&lt;td&gt;0.5天&lt;/td&gt;
&lt;td&gt;小芳&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;考勤管理&lt;/td&gt;
&lt;td&gt;考勤编辑&lt;/td&gt;
&lt;td&gt;0.3天&lt;/td&gt;
&lt;td&gt;小芳&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;上面仅仅做一个分解的过程，这种方式需要和小组成员一同交流，一起讨论这个功能和功能完成的时间。这种形式将一个项目分解成很多小的任务，并且有任务的时间，这样这个项目就有一个大概完成的时间点。具体如何安排，具体如何操作都可以一起讨论。&lt;/p&gt;
&lt;p&gt;一个项目通过分解后，就可以将具体的任务安排给其他人，这种方式也能具体到个人，每个人就可以朝同一个目标去前进。&lt;/p&gt;
&lt;h4 id=&quot;二协调工作和人员之间关系&quot;&gt;&lt;a id=&quot;2&quot;&gt;二、协调工作和人员之间关系&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;协调工作和人员之间的关系，上诉分解任务之后，安排人员时，根据每个人的实际情况，安排具体的工作。开一个会讨论讨论，最后将其结果发布出来。但是变化赶不上计划，比如员工生病了，请了两天假，本来可以完成的项目，可能就因此延期，这个时候，就安排一下，进度比较快的员工，协调一下接受一下生病员工的工作。&lt;/p&gt;
&lt;p&gt;这次某个员工多做了工作，那么在接下来的工作的时候，就可以少安排工作内容，或者安排一个学习新知识的任务等等，尽量做到相对公平。这个是需要自己对项目有一定的掌控能力，而不是让项目失去了自己掌控。&lt;/p&gt;
&lt;p&gt;协调人员的之间的关系，毕竟作为一个工作年限长一些的人，可以多组织一些活动，让大家活动活动，吃个饭什么的，这样能够促进员工之间的信任。尽量让新人融入到新的环境中来，融入到这个小的环境中来。&lt;/p&gt;
&lt;p&gt;可以安排大家一起攻坚一个新的技术，这样可以一起去探讨交流技术等等，或者是组织安排技术交流分享会，大家每周分享最近自己学习到新的知识。&lt;/p&gt;
&lt;p&gt;协调自己与其他员工的关系，小的管理者暂还不属于自己管理，毕竟自己也还从事月技术工作，但是会安排其他人员的任务，有一点点权力。有时候这种管理者和员工之间的关系就很特别，或者是不太会去交流。需要多做一些努力去了解他是一个什么样的人，比如是一个爱专研技术，那么就可以聊聊技术，或者是将自己了解的新的技术分享给他。&lt;/p&gt;
&lt;h4 id=&quot;三代码检查&quot;&gt;&lt;a id=&quot;3&quot;&gt;三、代码检查&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;一般大的公司在提交代码的时候，会进行代码审查，但是我所在的公司还没有进行这样操作。不进行这种操作，并不代表代码审查，检查是不重要的，恰恰相反，如果作为一个对该项目的主导者，那么需要理解现在的项目是怎样的，需要大概的了解代码中的相关内容，有哪些合理的地方，哪些不合理的地方，并且将项目把控在一个合适的范围内，不让它失控。&lt;/p&gt;
&lt;p&gt;代码检查不是究细节，一般按照了一定开发规范开发后，那么在不出大的偏差，就可以不需要修正。代码审查不仅需要去审查是否有错误，还需要去看这些代码是否符合规范，是否能够有优化的地方。&lt;/p&gt;
&lt;h4 id=&quot;四解决问题&quot;&gt;&lt;a id=&quot;4&quot;&gt;四、解决问题&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;因为是管事的，下面的人可以任性一点，可以脱卸责任，可以说这个不会。但是作为一个小小的管理者，不能说这做不出来，还不能说原因。而是大部分事情，是需要找方法去解决问题。&lt;/p&gt;
&lt;p&gt;作为项目的负责人，项目中所有的事情，都应该去解决。自己不能解决的，需要协调资源的，就需要申请，需要找资源。因为自己是项目的负责人。&lt;/p&gt;
&lt;p&gt;当明白这一点之后，就需要思考和明白如何去解决问题。解决问题可以靠自己的经验，但是很多时候是需要靠团队的。&lt;/p&gt;
&lt;p&gt;当一个复杂的问题出现时，需要一个团队共同去攻坚。这个时候作为管事者，需要充当协调者，并且最后拍板。&lt;/p&gt;
&lt;p&gt;如何解决问题，我观察和自己一些体会：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;摆正心态，大部分的问题总会有解决的方法，不能遇到问题，就将问题推卸掉。毕竟作为一个管事者，可能大部分的问题都会汇总到自己手上，自己不能找方法去解决，那么这个问题就会堆积。&lt;/li&gt;
&lt;li&gt;发动自己和同事的能动性，遇到问题，一起面对，共同解决。可以一起开会讨论，将问题具体化，遇到的问题归类，是属于资源不够导致，还是这个BUG团队能力不够导致等等。然后根据不同类型去找解决问题的方法。&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Mon, 15 Apr 2019 16:25:00 +0000</pubDate>
<dc:creator>冰魄秋雨</dc:creator>
<og:description>成为一个小的管理者 '一、分解任务' '二、协调工作和人员之间关系' '三、代码检查' '四、解决问题' 对于入职场没几年的人来说，管理一个团队的机会比较少，大多是会有一个老大来管理自己，但是管理的能</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/skyice/p/10714347.html</dc:identifier>
</item>
<item>
<title>The case for learned index structures - Sun Yongyue</title>
<link>http://www.cnblogs.com/sunyongyue/p/learned_idx_structs.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sunyongyue/p/learned_idx_structs.html</guid>
<description>&lt;p&gt;17年的旧文，最近因为SageDB论文而重读。&lt;/p&gt;

&lt;p&gt;文章主要思路是通过学习key的顺序、结构等来预测record在位置、存在与否等。效果方面，据称部分场景下，相对b-tree可以优化70%的内存占用。&lt;/p&gt;
&lt;p&gt;最大价值其实在于使用ML或DL来优化（索引）系统这个新的方向。&lt;/p&gt;

&lt;p&gt;Range Index&lt;/p&gt;

&lt;p&gt;审视下btree查找完成的功能：输入一个key，每次选出一个可能的范围(分支节点)，直到最后命中(叶子节点)。这其实跟ML中模型类似。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/sunyongyue/334850/o_Bitmap.png&quot; alt=&quot;&quot; width=&quot;400&quot; height=&quot;203&quot;/&gt;&lt;/p&gt;
&lt;p&gt;换句话说，若能估算出数据的累积分布（记作F），那么查询key所在位置，也可以看成是 pos = F(key) * N 这样一个过程。&lt;/p&gt;
&lt;p&gt;基于此，文章首先尝试了朴素的方案：使用tf训练并运行一个2层全连接的神经网络，每层32个单元，使用ReLU作为激发函数。&lt;/p&gt;
&lt;p&gt; 然而这个方案运行效果很差，单次查找耗时比btree高了2个数量级。原因是多方面的：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;TF并不针对小数据集优化&lt;/li&gt;
&lt;li&gt;单一的神经网络在最后的精细部分(last mile)，需要花费大量的计算与存储资源&lt;/li&gt;
&lt;li&gt;btree的设计考量了内存优化等，而朴素方案显然还较为粗糙(全连接层)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The RM-Index&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/117546/201904/117546-20190416000835502-1481840979.png&quot; alt=&quot;&quot; width=&quot;454&quot; height=&quot;286&quot;/&gt;&lt;/p&gt;
&lt;p&gt;针对上文朴素方案的问题，文章进行了一系列的优化。 &lt;/p&gt;
&lt;p&gt;首先不再使用TF进行推断查找，而是开发发了一个叫LIF的框架，从TF模型中提取权重参数，直接生成专为小数据集优化的高效C++代码。&lt;/p&gt;
&lt;p&gt;其次，使用RMI递归（而非单一）模型，在逐步缩小key的范围。由于每次问题被分解到小范围内进行，资源消耗得到改善的同时，模型的精度可以更好提升。RMI每层的输出是下一层的输入，有利于使用TPU/GPU进行优化。RMI中可以在不同的stage混合使用btree在内的不同类型模型来达到最佳效果，所以理论上不会比单纯的btree差。这个思路很ML，一个模型接一个模型:) &lt;/p&gt;
&lt;p&gt;并且，由于模型实际上已经预测出key的位置（position），而不仅仅是范围（range），本文使用了两种新的查找算法（MBS、BQS）利用该信息来更高效地进行查找。&lt;/p&gt;
&lt;p&gt;一连串的优化之后，模型的训练和运行有了明显的优化。其中，训练过程使用sgd只需要一次或少量的访问就可以。2亿条记录能在秒级完成。&lt;/p&gt;
&lt;p&gt;对于整型数据集，相同内存占用时下，RMI经常能较btree有数倍性能提升。或者说性能相同时，内存占用会有数量级的优化。见下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/117546/201904/117546-20190416000957407-638075584.png&quot; alt=&quot;&quot; width=&quot;552&quot; height=&quot;196&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在尽量公平相似的场景下，跟其他相关方案（FAST等）比也有明显优化：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/117546/201904/117546-20190416001029849-1105769321.png&quot; alt=&quot;&quot; width=&quot;551&quot; height=&quot;196&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在字符串场景下，优化场景不明显，原因可能在于字符串比较太耗时，model执行时间过长等。后者用TPU/GPU可能会有优化空间。&lt;/p&gt;

&lt;p&gt;Point Index&lt;/p&gt;

&lt;p&gt;point idx（hash索引）的优化基础在于，典型的数据冲突可能会有33%（如生日）。然而实际减少冲突和运行效果取决于两个主要方面：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;数据本身的分布情况。比如均匀分布场景下，learned idx不会比普通的随机hash函数好多少；&lt;/li&gt;
&lt;li&gt;其他payload等&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;从文章的数据集来说，还是有效果的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/117546/201904/117546-20190416001105042-1000082435.png&quot; alt=&quot;&quot; width=&quot;541&quot; height=&quot;170&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Existence Index&lt;/p&gt;

&lt;p&gt;存在性的索引，本文优化方面主要在于内存占用：10亿记录典型bloom filter需要1.76GB，如果要FPR为0.01%，则需要2.23GB。&lt;/p&gt;
&lt;p&gt;前边在索引需要学习数据分布，而存在性索引，需要让合法的key相关，非法的key相关，而合法key与非法key间不相关。这其实就很像分类问题了。&lt;/p&gt;
&lt;p&gt;另一方面，由于ML的特别，FPR下降时，FNR通常会上升。这跟bloom filter要求的FPR尽量小，FNR为0有冲突。解决方案是，在模型判断为false时，另行使用一个overflow bloom filter进行判断。由于bloom filter的大小于数据集相关，因为后接的bloom filter大小于FNR（即false部分相关），这要远小于传统方案中的大小。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/117546/201904/117546-20190416001133561-1804809781.png&quot; alt=&quot;&quot; width=&quot;381&quot; height=&quot;215&quot;/&gt;&lt;/p&gt;
&lt;p&gt;需要注意的是，该文章只研究了查询存在一定规律的场景，并在此这上建立模型。这在实际使用时要视业务场景而定。&lt;/p&gt;
&lt;p&gt;在符合条件的情况下，1.7M条URL， 1. FPR 0.5%，FNR 55%时，2.04MB-&amp;gt;1.31MB，减少36% 2. FPR 0.1%，FNR 76%时，3.06MB-&amp;gt;2.59MB，减少15%。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/117546/201904/117546-20190416001208043-840646366.png&quot; alt=&quot;&quot; width=&quot;379&quot; height=&quot;291&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Conclusion and Future Work&lt;/p&gt;

&lt;p&gt;文章研究的是单一维度索引，如果能支持多维索引，对现实系统将会有更多帮助。&lt;/p&gt;
&lt;p&gt;文章提到其价值时指出目前的索引是state-of-the-arts状态。有意思的是，ML和DL又何尝不是呢？:)&lt;/p&gt;

</description>
<pubDate>Mon, 15 Apr 2019 16:02:00 +0000</pubDate>
<dc:creator>Sun Yongyue</dc:creator>
<og:description>17年的旧文，最近因为SageDB论文而重读。 文章主要思路是通过学习key的顺序、结构等来预测record在位置、存在与否等。效果方面，据称部分场景下，相对b-tree可以优化70%的内存占用。 最</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sunyongyue/p/learned_idx_structs.html</dc:identifier>
</item>
<item>
<title>ELK(elasticsearch+kibana+logstash)搜索引擎(二)： elasticsearch基础教程 - waen</title>
<link>http://www.cnblogs.com/buggeerWang/p/10714181.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/buggeerWang/p/10714181.html</guid>
<description>&lt;p&gt;　　首先elasticsearch目前的结构为 /index/type/id  id对应的就是存储的文档ID，elasticsearch一般将数据以JSON格式存储。我们可以将elasticsearch和关系型数据库进行比较，index相当于关系型数据库中的database，type相当于table，而id就相当于表中的主键，elasticsearch中一个文档存储的一个json则能视为是关系型数据库中一张表的一行数据，而ID就是他的主键，在理解了es的存储结构后我们就可以对elasticsearch的一些基本使用进行了解了。&lt;/p&gt;
&lt;hr/&gt;

&lt;p&gt;　　elasticsearch在导入数据到索引时会按照固定的模板去导入数据，模板中可以设置字段的数据类型，以及设置数据的分词策略，&lt;span&gt;注意es会在数据导入时就对数据做分词，然后在搜索数据的时候，会按照存入时的分词策略查询数据&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{&lt;/span&gt;&quot;settings&quot;&lt;span&gt;:{
         &lt;/span&gt;&quot;analysis&quot;&lt;span&gt; : {
            &lt;/span&gt;&quot;analyzer&quot;&lt;span&gt; : {
                &lt;/span&gt;&quot;ik&quot;&lt;span&gt; : {
                    &lt;/span&gt;&quot;tokenizer&quot; : &quot;ik_max_word&quot;&lt;span&gt;
                }
            }
        },
        &lt;/span&gt;&quot;index&quot;&lt;span&gt; : {
            &lt;/span&gt;&quot;analysis.analyzer.default.type&quot;: &quot;ik_max_word&quot;&lt;span&gt;
        }
    },
  &lt;/span&gt;&quot;mappings&quot;&lt;span&gt;: {
    &lt;/span&gt;&quot;doc&quot;&lt;span&gt;: {
      &lt;/span&gt;&quot;dynamic&quot;: &quot;false&quot;&lt;span&gt;,
      &lt;/span&gt;&quot;properties&quot;&lt;span&gt;: {
        &lt;/span&gt;&quot;brand&quot;&lt;span&gt;: {
          &lt;/span&gt;&quot;type&quot;: &quot;string&quot;&lt;span&gt;,
          &lt;/span&gt;&quot;analyzer&quot;: &quot;ik_max_word&quot;&lt;span&gt;
        },
        &lt;/span&gt;&quot;product_name&quot;&lt;span&gt;: {
          &lt;/span&gt;&quot;type&quot;: &quot;string&quot;&lt;span&gt;,
          &lt;/span&gt;&quot;analyzer&quot;: &quot;ik_max_word&quot;&lt;span&gt;
        }
      }
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;关于分词，elasticsearch中默认的标准分词器基本只能将一句话只能分成一个个的字，所以我们要用到ik分词器，切记版本问题。&lt;/p&gt;
&lt;p&gt;下载地址》》：&lt;a href=&quot;https://github.com/medcl/elasticsearch-analysis-ik&quot; target=&quot;_blank&quot;&gt;https://github.com/medcl/elasticsearch-analysis-ik&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下载完成直接解压到es的pulgin目录下就行，ik分词器默认有两种分词方式：&lt;/p&gt;
&lt;p&gt;　　(1) ik_max_word，该模式的分词策略为最大化词汇搜索，既会递归整个词条，将词条中所有的语句列出，允许重复。&lt;/p&gt;
&lt;p&gt;　　(2) ik_smart，该策略不允许词汇重复，词条中如果有没有匹配到词典的字直接忽略&lt;/p&gt;
&lt;p&gt;关于ik分词器这里就不再详细叙述了，有一些关于词典的知识请大家自行百度，这里只对elasticsearch重点讲述！&lt;/p&gt;
&lt;hr/&gt;
&lt;h3&gt;①query组件&lt;/h3&gt;
&lt;p&gt;好了，到了正式介绍es的时候，搜索引擎不用多说搜索肯定是最重要的一点，下面给出一个最简单的例子&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594654/201904/1594654-20190415225434094-732675817.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　首先看到 红色箭头1 ，整个语句意思从前至后 分别为 GET 方式对es请求， /catalogue 为请求的索引地址，可以具体到/type甚至id，/_search代表发起查询请求，而后面的则是请求的json体，毫无疑问json体是搜索的关键也是今天的主要讲解内容。&lt;/p&gt;
&lt;p&gt;       再看到红色剪头2，es中所有的查询都要包含在query组件中，query后面则跟着一个JSON，JSON的内容也就是红色剪头3，match_all代表无条件的查询即搜索所有，同样的还有match代表有条件的查询，查询条件放在match后面的json中，记住整个查询体都按照json格式来写。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594654/201904/1594654-20190415230118052-236538067.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上队商品名进行查询，查出所有名字包含洗衣粉的商品，搜索结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594654/201904/1594654-20190415230453594-2080574300.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到返回hits的其实是个json数组，每个json中包含着该数据的index、type、id以及匹配的分数_score以及数据_source&lt;/p&gt;
&lt;p&gt;好了，这样就介绍完了最基本的单条件搜索&lt;/p&gt;
&lt;h3&gt;②bool组件&lt;/h3&gt;
&lt;p&gt;上面是单条件查询，那么多条件怎么查询呢，可以看到如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594654/201904/1594654-20190415231110293-1210019448.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到直接在query里面是不能进行多条件查找的，这里需要用到bool组件&lt;/p&gt;
&lt;p&gt;使用bool组件进行复杂的查询：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594654/201904/1594654-20190415231357478-934982852.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到使用bool组件后多条件搜索就没有报错，那么bool的结构是怎么样呢？&lt;/p&gt;
&lt;p&gt;bool表达式包含三个jsonArray：&lt;/p&gt;
&lt;p&gt;　　（1）must 包含了所有必须匹配的条件，如果有一项不匹配则排除，类似于逻辑且&lt;/p&gt;
&lt;p&gt;　　  (2)  should包含的条件必须满足至少一个，类似于逻辑或&lt;/p&gt;
&lt;p&gt;　　（3）must_not 包含了所有排除的条件，类似于逻辑非&lt;/p&gt;
&lt;p&gt;整个结构如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    &lt;/span&gt;&quot;query&quot;&lt;span&gt;:{
        &lt;/span&gt;&quot;bool&quot;&lt;span&gt;:{
            &lt;/span&gt;&quot;must&quot;&lt;span&gt;:[],
            &lt;/span&gt;&quot;should&quot;&lt;span&gt;:[],
            &lt;/span&gt;&quot;must_not&quot;&lt;span&gt;:[]
        }
    }&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;并且bool直接多重嵌套使用，所以想做出复杂的搜索功能，可以在bool上多下功夫&lt;/p&gt;
&lt;p&gt;还有如上图中的range范围控制，和size查询的大小就不细说，看图应该就明白了&lt;/p&gt;
&lt;h3&gt;③分页查询&lt;/h3&gt;
&lt;p&gt;这里再讲一下es中怎么做到分页查询&lt;/p&gt;
&lt;p&gt;es中和size并列还有from属性，size是一次查询的数量，from则是从第几个开始查，搭配使用即可达到分页查询的目的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594654/201904/1594654-20190415232558595-1747113964.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;④排序&lt;/h3&gt;
&lt;p&gt;es中可以使用sort对数据进行排序，sort为一个jsonArray，可以按照多个字段对数据进行排序，说明一下，如果不使用sort排序，es则默认按照_score匹配分数进行降序排序，&lt;span&gt;当使用sort并且sort中没有_score时，_score会变成null从而达到排除按照_score排序&lt;span&gt;，按照多个条件进行排序时，按照jsonArray中json的排序顺序进行先排和后排，关于升序降序学过数据库的童鞋应该很清楚！什么？没学过数据库？那你现在还不去学数据库？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594654/201904/1594654-20190415233026593-1820814579.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;至此elasticsearch基础教程结束，后面将为大家带来elasticsearch的进阶教程和ELK架构实现电商搜索引擎&lt;/p&gt;
</description>
<pubDate>Mon, 15 Apr 2019 15:40:00 +0000</pubDate>
<dc:creator>waen</dc:creator>
<og:description>1.elasticsearch的结构 首先elasticsearch目前的结构为 /index/type/id id对应的就是存储的文档ID，elasticsearch一般将数据以JSON格式存储。我</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/buggeerWang/p/10714181.html</dc:identifier>
</item>
<item>
<title>React + TypeScript：元素引用的传递 - 刘哇勇</title>
<link>http://www.cnblogs.com/Wayou/p/react_typescript_forwardref.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Wayou/p/react_typescript_forwardref.html</guid>
<description>&lt;p&gt;React 中需要操作元素时，可通过 &lt;code&gt;findDOMNode()&lt;/code&gt; 或通过 &lt;code&gt;createRef()&lt;/code&gt; 创建对元素的引用来实现。前者官方不推荐，所以这里讨论后者及其与 TypeScript 结合时如何工作。&lt;/p&gt;
&lt;h2&gt;React 中的元素引用&lt;/h2&gt;
&lt;p&gt;正常的组件中，可通过创建对元素的引用来获取到某元素然后进行相应操作。比如元素加载后将焦点定位到输入框。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;App&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;pl-e&quot;&gt;Component&lt;/span&gt; {
  &lt;span class=&quot;pl-en&quot;&gt;constructor&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;props&lt;/span&gt;){
    &lt;span class=&quot;pl-c1&quot;&gt;super&lt;/span&gt;(props);
    &lt;span class=&quot;pl-c1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;inputRef&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;React&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;createRef&lt;/span&gt;();
  }

  &lt;span class=&quot;pl-en&quot;&gt;componentDidMount&lt;/span&gt;(){
    &lt;span class=&quot;pl-c1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;inputRef&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;current&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;focus&lt;/span&gt;()
  }

  &lt;span class=&quot;pl-en&quot;&gt;render&lt;/span&gt;() {
    &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; (
      &lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt;div className&lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;App&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt;input type&lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;text&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; ref&lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt;{&lt;span class=&quot;pl-c1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;inputRef&lt;/span&gt;}&lt;span class=&quot;pl-k&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;/&lt;/span&gt;div&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt;
    );
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;创建对元素的引用是通过 &lt;code&gt;React.createRef()&lt;/code&gt; 方法完成的。使用的时候，通过其返回对象身上的 &lt;code&gt;current&lt;/code&gt; 属性可访问到绑定引用的元素。&lt;/p&gt;
&lt;p&gt;React 内部对引用的 &lt;code&gt;current&lt;/code&gt; 赋值更新发生在 &lt;code&gt;componentDidMount&lt;/code&gt; 或 &lt;code&gt;componentDidUpdate&lt;/code&gt; 生命周期之前，即存在使用的时候引用未初始化完成的情况，所以 &lt;code&gt;current&lt;/code&gt; 不一定有值。好的做法是使用前先判空。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;inputRef&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;current&lt;/span&gt;){
    &lt;span class=&quot;pl-c1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;inputRef&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;current&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;focus&lt;/span&gt;()
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在上面的示例中，之所以不用判空是因为我们在 &lt;code&gt;componentDidMount&lt;/code&gt; 生命周期中使用，此时元素已经加载到页面，所以可以放心使用。&lt;/p&gt;
&lt;h2&gt;组件中引用的传递&lt;/h2&gt;
&lt;p&gt;对于原生 DOM 元素可以像上面那样创建引用，但对于自己写的组件，则需要使用 &lt;code&gt;forwardRef()&lt;/code&gt; 来实现。&lt;/p&gt;
&lt;p&gt;假如你写了个按钮组件，想要实现像上面那样，让使用者可通过传递一个 &lt;code&gt;ref&lt;/code&gt; 属性来获取到组件中原生的这个 &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; 元素以进行相应的操作。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;button.jsx&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;FancyInput&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;props&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt;input type&lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;text&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; className&lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;fancy-input&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;添加 ref 支持后的按钮组件：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;button.jsx&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;FancyInput&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;React&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;forwardRef&lt;/span&gt;((&lt;span class=&quot;pl-smi&quot;&gt;props&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;ref&lt;/span&gt;) &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
  &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt;input type&lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;text&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; ref&lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt;{ref} className&lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;fancy-input&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt;;
});
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;forwardRef&lt;/code&gt; 接收一个函数，函数的入参中第一个是组件的 props，第二个便是外部传递进来的 ref 引用。通过将这个引用在组件中绑定到相应的原生 DOM 元素上，实现了外部直接引用到组件内部元素的目的，所以叫 &lt;code&gt;forwardRef&lt;/code&gt;（传递引用）。&lt;/p&gt;
&lt;p&gt;使用上面创建的 &lt;code&gt;FancyInput&lt;/code&gt;，在组件加载后使其获得焦点：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-diff&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
class App extends Component {
  constructor(props) {
    super(props);
    this.inputRef = React.createRef();
  }

  componentDidMount() {
    if (this.inputRef.current) {
      this.inputRef.current.focus();
    }
  }

  render() {
    return (
      &amp;lt;div className=&quot;App&quot;&amp;gt;
&lt;span class=&quot;pl-md&quot;&gt;&lt;span class=&quot;pl-md&quot;&gt;-&lt;/span&gt;        &amp;lt;input type=&quot;text&quot; ref={this.inputRef}/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;pl-mi1&quot;&gt;&lt;span class=&quot;pl-mi1&quot;&gt;+&lt;/span&gt;        &amp;lt;FancyInput ref={this.inputRef} /&amp;gt;&lt;/span&gt;
      &amp;lt;/div&amp;gt;
    );
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;TypeScript 中传递引用&lt;/h2&gt;
&lt;p&gt;先看正常情况下，对原生 DOM 元素的引用。还是上面的示例：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-ts&quot; readability=&quot;11&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;App&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;pl-e&quot;&gt;Component&lt;/span&gt;&amp;lt;{}, {}&amp;gt; {
  &lt;span class=&quot;pl-k&quot;&gt;private&lt;/span&gt; inputRef &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;React&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;createRef&lt;/span&gt;();

  componentDidMount() {
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;/**&lt;/span&gt; 🚨 Object is possibly 'null' &lt;span class=&quot;pl-c&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;
    &lt;span class=&quot;pl-c1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;inputRef&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;current&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;focus&lt;/span&gt;();
  }

  render() {
    &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; (
      &lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;className&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;App&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt;
        {&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;/*&lt;/span&gt; 🚨 Type '{}' is missing the following properties from type 'HTMLInputElement':... &lt;span class=&quot;pl-c&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;}
        &lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;input&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;text&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;ref&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt;{this.&lt;span class=&quot;pl-smi&quot;&gt;inputRef&lt;/span&gt;} &lt;span class=&quot;pl-k&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;div&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt;
    );
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;像上面那样创建并使用存在两个问题。&lt;/p&gt;
&lt;p&gt;一个是提示我们的引用无法赋值到 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 的 &lt;code&gt;ref&lt;/code&gt; 属性上，类型不兼容。引用需要与它真实所指代的元素类型相符，这正是 TypeScript 类型检查为我们添加的约束。这个约束的好处是，我们在使用引用的时候，就知道这个引用真实的元素类型，TypeScript 会自动提示可用的方法和属性，同时防止调用该元素身上没有的属性和方法。这里修正的方法很简单，如果 hover 或 &lt;kbd&gt;F12&lt;/kbd&gt; 查看 &lt;code&gt;React.createRef()&lt;/code&gt; 的方法签名，会发现它是个泛型方法，支持传递类型参数。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-ts&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; createRef&amp;lt;&lt;span class=&quot;pl-en&quot;&gt;T&lt;/span&gt;&amp;gt;()&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;RefObject&lt;/span&gt;&amp;lt;&lt;span class=&quot;pl-en&quot;&gt;T&lt;/span&gt;&amp;gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所以上面创建引用时，显式指定它的类型。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-diff&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-md&quot;&gt;&lt;span class=&quot;pl-md&quot;&gt;-&lt;/span&gt; private inputRef = React.createRef();&lt;/span&gt;
&lt;span class=&quot;pl-mi1&quot;&gt;&lt;span class=&quot;pl-mi1&quot;&gt;+&lt;/span&gt; private inputRef = React.createRef&amp;lt;HTMLInputElement&amp;gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第二个问题是即使在 &lt;code&gt;componentDidMount&lt;/code&gt; 生命周期中使用，TypeScript 仍然提示 &lt;code&gt;current&lt;/code&gt; 的值有可能为空。上面讨论过，其实此时我们知道它不可能为空的。但因为 TypeScript 无法理解 &lt;code&gt;componentDidMount&lt;/code&gt;，所以它不知道此时引用其实是可以安全使用的。解决办法当然是加上判空的逻辑。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-diff&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
  componentDidMount() {
&lt;span class=&quot;pl-mi1&quot;&gt;&lt;span class=&quot;pl-mi1&quot;&gt;+&lt;/span&gt;    if(this.inputRef.current){&lt;/span&gt;
      this.inputRef.current.focus();
&lt;span class=&quot;pl-mi1&quot;&gt;&lt;span class=&quot;pl-mi1&quot;&gt;+&lt;/span&gt;    }&lt;/span&gt;
  }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;还可通过变量后添加 &lt;code&gt;!&lt;/code&gt; 操作符告诉 TypeScript 该变量此时非空。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-diff&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
  componentDidMount() {
&lt;span class=&quot;pl-md&quot;&gt;&lt;span class=&quot;pl-md&quot;&gt;-&lt;/span&gt;      this.inputRef.current.focus();&lt;/span&gt;
&lt;span class=&quot;pl-mi1&quot;&gt;&lt;span class=&quot;pl-mi1&quot;&gt;+&lt;/span&gt;      this.inputRef.current!.focus();&lt;/span&gt;
  }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修复后完整的代码如下：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-ts&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;App&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;pl-e&quot;&gt;Component&lt;/span&gt;&amp;lt;{}, {}&amp;gt; {
  &lt;span class=&quot;pl-k&quot;&gt;private&lt;/span&gt; inputRef &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;React&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;createRef&lt;/span&gt;&amp;lt;&lt;span class=&quot;pl-en&quot;&gt;HTMLInputElement&lt;/span&gt;&amp;gt;();

  componentDidMount() {
    &lt;span class=&quot;pl-c1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;inputRef&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;!&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;focus&lt;/span&gt;();
  }

  render() {
    &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; (
      &lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;className&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;App&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;input&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;text&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;ref&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt;{this.&lt;span class=&quot;pl-smi&quot;&gt;inputRef&lt;/span&gt;} &lt;span class=&quot;pl-k&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;div&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt;
    );
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;React + TypeScript 组件引用的传递&lt;/h2&gt;
&lt;p&gt;继续到组件的情况，当需要引用的元素在另一个组件内部时，还是通过 &lt;code&gt;React.forwardRef()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这是该方法的签名：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-ts&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; forwardRef&amp;lt;&lt;span class=&quot;pl-en&quot;&gt;T&lt;/span&gt;, &lt;span class=&quot;pl-en&quot;&gt;P&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; {}&amp;gt;(&lt;span class=&quot;pl-v&quot;&gt;Component&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;RefForwardingComponent&lt;/span&gt;&amp;lt;&lt;span class=&quot;pl-en&quot;&gt;T&lt;/span&gt;, &lt;span class=&quot;pl-en&quot;&gt;P&lt;/span&gt;&amp;gt;)&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;ForwardRefExoticComponent&lt;/span&gt;&amp;lt;&lt;span class=&quot;pl-en&quot;&gt;PropsWithoutRef&lt;/span&gt;&amp;lt;&lt;span class=&quot;pl-en&quot;&gt;P&lt;/span&gt;&amp;gt; &lt;span class=&quot;pl-k&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;RefAttributes&lt;/span&gt;&amp;lt;&lt;span class=&quot;pl-en&quot;&gt;T&lt;/span&gt;&amp;gt;&amp;gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到，方法接收两个类型参数，&lt;code&gt;T&lt;/code&gt; 为需要引用的元素类型，我们示例中是 &lt;code&gt;HTMLInputElement&lt;/code&gt;，&lt;code&gt;P&lt;/code&gt; 为组件的 props 类型。&lt;/p&gt;
&lt;p&gt;所以添加引用传递后，&lt;code&gt;FancyInput&lt;/code&gt; 组件在 TypeScript 中的版本应该长这样：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-ts&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt;&lt;/span&gt; FancyInput &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;React&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;forwardRef&lt;/span&gt;&amp;lt;&lt;span class=&quot;pl-en&quot;&gt;HTMLInputElement&lt;/span&gt;, {}&amp;gt;((&lt;span class=&quot;pl-v&quot;&gt;props&lt;/span&gt;, &lt;span class=&quot;pl-v&quot;&gt;ref&lt;/span&gt;) &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
  &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &amp;lt;&lt;span class=&quot;pl-en&quot;&gt;input&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;type&lt;/span&gt;=&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;text&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;ref&lt;/span&gt;={&lt;span class=&quot;pl-en&quot;&gt;ref&lt;/span&gt;} &lt;span class=&quot;pl-en&quot;&gt;className&lt;/span&gt;=&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;fancy-input&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; /&amp;gt;;
});
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用组件：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-ts&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;App&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;pl-e&quot;&gt;Component&lt;/span&gt;&amp;lt;{}, {}&amp;gt; {
  &lt;span class=&quot;pl-k&quot;&gt;private&lt;/span&gt; inputRef &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;React&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;createRef&lt;/span&gt;&amp;lt;&lt;span class=&quot;pl-en&quot;&gt;HTMLInputElement&lt;/span&gt;&amp;gt;();

  componentDidMount() {
    &lt;span class=&quot;pl-c1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;inputRef&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;!&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;focus&lt;/span&gt;();
  }

  render() {
    &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; (
      &lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;className&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;App&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;FancyInput&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;ref&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt;{this.&lt;span class=&quot;pl-smi&quot;&gt;inputRef&lt;/span&gt;} &lt;span class=&quot;pl-k&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;div&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt;
    );
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;相关资源&lt;/h2&gt;
</description>
<pubDate>Mon, 15 Apr 2019 15:32:00 +0000</pubDate>
<dc:creator>刘哇勇</dc:creator>
<og:description>React 中需要操作元素时，可通过 findDOMNode() 或通过 createRef() 创建对元素的引用来实现。前者官方不推荐，所以这里讨论后者及其与 TypeScript 结合时如何工作。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Wayou/p/react_typescript_forwardref.html</dc:identifier>
</item>
<item>
<title>Java8新特性之一：Lambda表达式 - 无恨之都</title>
<link>http://www.cnblogs.com/wuhenzhidu/p/lambda.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wuhenzhidu/p/lambda.html</guid>
<description>&lt;p&gt;　　Java8是自java5之后最重大的一次更新，它给JAVA语言带来了很多新的特性（包括编译器、类库、工具类、JVM等），其中最重要的升级是它给我们带来了Lambda表达式和Stream API。&lt;/p&gt;
&lt;h2&gt;1、什么是Lambda表达式？&lt;/h2&gt;
&lt;p&gt;　　Lambda是一个匿名函数，可以理解为是一段可以传递的代码，可以将代码像传递参数、传递数据一样进行传输。使用Lambda表达式，可以写出更加紧凑、更加简洁、更加灵活的代码。&lt;/p&gt;
&lt;h2&gt;2、使用Lambda的限制条件&lt;/h2&gt;
&lt;p&gt;　　Lambda并不是任何地方都可以使用，Lambda表达式需要“函数式接口”的支持。&lt;/p&gt;
&lt;h2&gt;3、什么是函数式接口？&lt;/h2&gt;
&lt;p&gt;　　接口中只有一个抽象方法的接口，称为函数式接口，可以用@FunctionalInterface修饰一下，这里需要注意的是：未使用 @FunctionalInterfaces注解的接口未必就不是函数式接口，一个接口是不是函数式接口的条件只有一条，即接口中只有一个抽象方法的接口（Object类中的方法不算）。而使用@FunctionalInterface注解修饰了的接口就一定是函数式接口，添加@FunctionalInterface注解可以帮助我们检查是否是函数式接口。&lt;/p&gt;
&lt;p&gt;JDK中常见的函数式接口有：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;@FunctionalInterface
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Runnable {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run();
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;@FunctionalInterface
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; Callable&amp;lt;V&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     V call() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以下接口中虽然有两个方法，但因hashCode()是Object类中的方法，因此该接口也是函数式接口：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;@FunctionalInterface
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; FuncInterface {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     
&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doSomething();
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; 
&lt;span&gt;6&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; hashCode();  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Object类中的方法&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;4、Lambda表达式示例&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;　　需求一：开启一个线程，在线程中打印出&quot;Hello World&quot;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　未使用Lambda表达式时的写法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LambdaTest {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; print() {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;         Thread thread = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;                System.out.println(&quot;Hello World&quot;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        thread.start();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　使用Lambda时的写法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LambdaTest {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     
&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; print() {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         Thread thread = &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt;&lt;span&gt; System.out.println(&quot;Hello World&quot;));
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;　　需求二：模拟一个计算器，使其可以进行简单的加、减、乘操作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　（1）、计算器操作函数式接口&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;@FunctionalInterface
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; Calculator&amp;lt;T&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    T operation(T t1,T t2);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　（2）具体操作&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CalculatorTest {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Integer operator(Integer v1,Integer v2,Calculator&amp;lt;Integer&amp;gt;&lt;span&gt; calculator) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; calculator.operation(v1,v2);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer add(Integer v1,Integer v2) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; operator(v1,v2,(x,y) -&amp;gt; x +&lt;span&gt; y);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer subtr(Integer v1,Integer v2) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; operator(v1,v2,(x,y) -&amp;gt; x -&lt;span&gt; y);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer multi(Integer v1,Integer v2) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; operator(v1,v2,(x,y) -&amp;gt; x *&lt;span&gt; y);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;         CalculatorTest calculatorTest = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CalculatorTest();
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 加法&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;         Integer add = calculatorTest.add(1,2&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 减法&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;         Integer sub = calculatorTest.subtr(100,82&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 乘法&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;         Integer multi = calculatorTest.multi(5,3&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt; &lt;span&gt;        System.out.println(add);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;        System.out.println(sub);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;        System.out.println(multi);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　运行结果：&lt;/p&gt;

&lt;p&gt;　　从需求一中，我们可以看出，使用Lambda比使用匿名内部类代码更加简洁，同时，也可以理解为什么Lambda必须需要函数式接口的支持。我们假设Runnable中有两个方法，那么，“() -&amp;gt; System.out.println(Thread.currentThread().getName())”应该去找哪个方法去实现？&lt;/p&gt;
&lt;p&gt;　　从需求二的例子中，我们可以更加理解“一段可以传递的代码”这句话的含义。对数据的操作方法定义在Calculator接口中，而加、减、乘的具体实现代码在各自的方法中，并将这些实现作为参数传递给CalculatorTest类的operator()方法，最终返回操作结果。&lt;/p&gt;
&lt;h2&gt;5、Lambda表达式的语法&lt;/h2&gt;
&lt;h3&gt;5.1 Lambda表达式的语法结构&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
(参数列表，对应的是接口中对应的抽象方法的参数列表) -&amp;gt; {对抽象方法的实现}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　Lambda表达式语法分在3个部分：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;左边的参数列表，对应的是函数式接口中抽象方法的参数列表；&lt;/li&gt;
&lt;li&gt;中间的符号:-&amp;gt;,为固定写法; &lt;/li&gt;
&lt;li&gt;右边大括号内对函数接口抽象方法的实现。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　　Lambda表达式的在具体场景下可以有简略写法。&lt;/p&gt;
&lt;h3&gt;5.2 语法格式一：无参数，无返回值&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; Runnable runnable = () -&amp;gt; {System.out.println(&quot;Hello World&quot;&lt;span&gt;);} 
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; Runnable runnable = () -&amp;gt; System.out.println(&quot;Hello World&quot;);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 简写形式&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　此时，如果右边的代码简单，只有一行代码时，{}可以省略。&lt;/p&gt;
&lt;h3&gt;5.2 语法格式二：有一个参数，无返回值&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CalculatorTest {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; print(Consumer&amp;lt;String&amp;gt;&lt;span&gt; msg) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        System.out.println(msg);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doPrint(String msg) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         print((str) -&amp;gt;&lt;span&gt; System.out.println(msg));
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         print(str -&amp;gt; System.out.println(msg));  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 简写&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　此时，左边的()可以省略。&lt;/p&gt;
&lt;h3&gt;5.3 语法格式三：Lambda体内只有一条语句，且有返回值，return可省略&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer subtr(Integer v1,Integer v2) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; operator(v1,v2,(x,y) -&amp;gt; x -&lt;span&gt; y);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;5.4 语法格式四：有两个以上参数，且Lambda体中有多条语句&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer add(Integer v1,Integer v2) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; operator(v1,v2,(x,y) -&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;             System.out.println(&quot;进行加法运算&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; x +&lt;span&gt; y;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;5.5 语法格式五：Lambda表达式的数据类型可以省略不写&lt;/h3&gt;
&lt;p&gt;　　JVM编译器通过上下文可以推断出数据类型，但要注意的是，当多个参数时，要么都写，要么都不写，不能有的写，有的不写：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer subtr(Integer v1,Integer v2) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; operator(v1,v2,(Integer x,y) -&amp;gt; x - y);   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 错误&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; 
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer subtr(Integer v1,Integer v2) {
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; operator(v1,v2,(x,y) -&amp;gt; x - y);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 正确&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;6、Java8四大内置核心函数式接口&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 Consumer&amp;lt;T&amp;gt;&lt;span&gt; : 消费型接口（无返回值，有去无回）
         &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; accept(T t);
 Supplier&lt;/span&gt;&amp;lt;T&amp;gt;&lt;span&gt; : 供给型接口
         T get();
         
 Function&lt;/span&gt;&amp;lt;T,R&amp;gt;&lt;span&gt; : 函数型接口
        R apply(T t);
        
 Predicate&lt;/span&gt;&amp;lt;T&amp;gt;&lt;span&gt; : 断言型接口
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; test(T t);
        
四大核心接口的&lt;/span&gt;--&amp;gt;扩展子接口
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; lombok.Getter;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; lombok.Setter;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.function.Consumer;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.function.Function;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.function.Predicate;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.function.Supplier;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;@Getter
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;@Setter
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; User {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String username;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &quot;User{&quot; +
&lt;span&gt;18&lt;/span&gt;                 &quot;username='&quot; + username + '\'' +
&lt;span&gt;19&lt;/span&gt;                 &quot;, age=&quot; + age +
&lt;span&gt;20&lt;/span&gt;                 '}'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; InnerInterface {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;     * 打印user信息
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; print(User user,Consumer&amp;lt;User&amp;gt;&lt;span&gt; userConsumer) {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;        userConsumer.accept(user);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt; &lt;span&gt;     * 返回一个user
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; User getUser(Supplier&amp;lt;User&amp;gt;&lt;span&gt; userSupplier) {
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; userSupplier.get();
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; 
&lt;span&gt;40&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt; &lt;span&gt;     * 转换一个user
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; User transformUser(User user,Function&amp;lt;User,User&amp;gt;&lt;span&gt; function) {
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; function.apply(user);
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; 
&lt;span&gt;47&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt; &lt;span&gt;     * 检验User是否合法
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;50&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; checkUser(User user, Predicate&amp;lt;User&amp;gt;&lt;span&gt; predicate) {
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; predicate.test(user);
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; 
&lt;span&gt;54&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; 
&lt;span&gt;56&lt;/span&gt;         User userObj = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User();
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;         userObj.setUsername(&quot;西门吹雪&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;         userObj.setAge(22&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; 
&lt;span&gt;60&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 测试Consumer&lt;/span&gt;
&lt;span&gt;61&lt;/span&gt;         InnerInterface mainInst = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InnerInterface();
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;         mainInst.print(userObj,user -&amp;gt;&lt;span&gt; System.out.println(user));
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; 
&lt;span&gt;64&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 测试Supplier&lt;/span&gt;
&lt;span&gt;65&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt; User user1 = mainInst.getUser(() -&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;             User user = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User();
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt;             user.setUsername(&quot;叶孤城&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;             user.setAge(22&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; user;
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt; &lt;span&gt;        System.out.println(user1);
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt;         
&lt;span&gt;73&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将西门吹雪的年龄改为25&lt;/span&gt;
&lt;span&gt;74&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt; User user2 = mainInst.transformUser(userObj, (user -&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt;             user.setAge(25&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; user;
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt; &lt;span&gt;        }));
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt; &lt;span&gt;        System.out.println(user2);
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt; 
&lt;span&gt;80&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断User是否是西门吹雪&lt;/span&gt;
&lt;span&gt;81&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; checkUser = mainInst.checkUser(userObj, (user -&amp;gt; user.getUsername().equals(&quot;西门吹雪&quot;&lt;span&gt;)));
&lt;/span&gt;&lt;span&gt;82&lt;/span&gt; &lt;span&gt;        System.out.println(checkUser);
&lt;/span&gt;&lt;span&gt;83&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;84&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　运行结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
User{username='西门吹雪', age=22&lt;span&gt;}
User{username&lt;/span&gt;='叶孤城', age=22&lt;span&gt;}
User{username&lt;/span&gt;='西门吹雪', age=25&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　以上四大核心内置接口是我们日常开发中经常要用到的，同时，它们还有一些变种，如：&lt;/p&gt;
&lt;p&gt;　　BiConsumer，Consumer的增强版，接受两个参数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;@FunctionalInterface
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; BiConsumer&amp;lt;T, U&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; 
&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; accept(T t, U u);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　BiFunction类似，Function的增强版，接受两个参数，返回一个参数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@FunctionalInterface
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; BiFunction&amp;lt;T, U, R&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    R apply(T t, U u);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;default&lt;/span&gt; &amp;lt;V&amp;gt; BiFunction&amp;lt;T, U, V&amp;gt; andThen(Function&amp;lt;? &lt;span&gt;super&lt;/span&gt; R, ? &lt;span&gt;extends&lt;/span&gt; V&amp;gt;&lt;span&gt; after) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        Objects.requireNonNull(after);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; (T t, U u) -&amp;gt;&lt;span&gt; after.apply(apply(t, u));
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　其他的类似，这些函数式接口都在java.util.function包下，读者可去这个包下去查询。&lt;/p&gt;

</description>
<pubDate>Mon, 15 Apr 2019 15:32:00 +0000</pubDate>
<dc:creator>无恨之都</dc:creator>
<og:description>Java8是自java5之后最重大的一次更新，它给JAVA语言带来了很多新的特性（包括编译器、类库、工具类、JVM等），其中最重要的升级是它给我们带来了Lambda表达式和Stream API。 1、</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wuhenzhidu/p/lambda.html</dc:identifier>
</item>
<item>
<title>详解Java中的final关键字 - Heriam</title>
<link>http://www.cnblogs.com/cciejh/p/final-in-java.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cciejh/p/final-in-java.html</guid>
<description>&lt;p&gt;本文原文地址：&lt;a href=&quot;https://jiang-hao.com/articles/2019/coding-java-final-keyword.html&quot; class=&quot;uri&quot;&gt;https://jiang-hao.com/articles/2019/coding-java-final-keyword.html&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;final-简介2&quot;&gt;final 简介&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;final&lt;/em&gt;关键字可用于多个场景，且在不同场景具有不同的作用。首先，&lt;em&gt;final&lt;/em&gt;是一个&lt;a href=&quot;https://www.geeksforgeeks.org/access-and-non-access-modifiers-in-java/&quot;&gt;非访问修饰符&lt;/a&gt;，&lt;strong&gt;仅&lt;/strong&gt;适用&lt;strong&gt;于变量，方法或类&lt;/strong&gt;。下面是使用final的不同场景：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Heriam/images/master/in-article/final-keyword.png&quot; alt=&quot;java中的final关键字&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面这张图可以概括成：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当&lt;em&gt;final&lt;/em&gt;修饰&lt;strong&gt;变量&lt;/strong&gt;时，被修饰的变量必须被初始化(赋值)，且后续不能修改其值，实质上是常量；&lt;/li&gt;
&lt;li&gt;当&lt;em&gt;final&lt;/em&gt;修饰&lt;strong&gt;方法&lt;/strong&gt;时，被修饰的方法无法被所在类的子类重写（覆写）；&lt;/li&gt;
&lt;li&gt;当&lt;em&gt;final&lt;/em&gt;修饰&lt;strong&gt;类&lt;/strong&gt;时，被修饰的类不能被继承，并且&lt;em&gt;final&lt;/em&gt;类中的所有成员方法都会被隐式地指定为&lt;em&gt;final&lt;/em&gt;方法，但成员变量则不会变。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;final-修饰变量&quot;&gt;final 修饰变量&lt;/h3&gt;
&lt;p&gt;当使用&lt;em&gt;final&lt;/em&gt;关键字声明类成员变量或局部变量后，其值不能被再次修改；也经常和&lt;em&gt;static&lt;/em&gt;关键字一起，作为&lt;strong&gt;类常量&lt;/strong&gt;使用。很多时候会容易把&lt;em&gt;static&lt;/em&gt;和&lt;em&gt;final&lt;/em&gt;关键字混淆，&lt;u&gt;&lt;em&gt;static&lt;/em&gt;作用于成员变量用来表示只保存一份副本，而&lt;em&gt;final&lt;/em&gt;的作用是用来保证变量不可变&lt;/u&gt;。如果&lt;em&gt;final&lt;/em&gt;变量是引用，这意味着该变量不能重新绑定到引用另一个对象，但是可以更改该引用变量指向的对象的内部状态，即可以从&lt;a href=&quot;https://www.geeksforgeeks.org/final-arrays-in-java/&quot;&gt;&lt;em&gt;final&lt;/em&gt;数组&lt;/a&gt;或&lt;em&gt;final&lt;/em&gt;集合中添加或删除元素。最好用全部大写来表示&lt;em&gt;final&lt;/em&gt;变量，使用下划线来分隔单词。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;例子&lt;/strong&gt;：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//一个final成员常量
final int THRESHOLD = 5;
//一个空的final成员常量
final int THRESHOLD;
//一个静态final类常量
static final double PI = 3.141592653589793;
//一个空的静态final类常量
static final double PI;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;初始化final变量&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;我们必须初始化一个&lt;em&gt;final&lt;/em&gt;变量，否则编译器将抛出编译时错误。&lt;em&gt;final&lt;/em&gt;变量只能通过&lt;a href=&quot;https://www.geeksforgeeks.org/g-fact-26-the-initializer-block-in-java/&quot;&gt;初始化器&lt;/a&gt;或赋值语句初始化一次。初始化&lt;em&gt;final&lt;/em&gt;变量有三种方法：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;可以在声明它时初始化&lt;em&gt;final&lt;/em&gt;变量。这种方法是最常见的。如果在声明时&lt;strong&gt;未&lt;/strong&gt;初始化，则该变量称为&lt;strong&gt;空&lt;em&gt;final&lt;/em&gt;变量&lt;/strong&gt;。下面是初始化空&lt;em&gt;final&lt;/em&gt;变量的两种方法。&lt;/li&gt;
&lt;li&gt;可以在&lt;a href=&quot;https://www.geeksforgeeks.org/instance-initialization-block-iib-java/&quot;&gt;instance-initializer块&lt;/a&gt; 或内部构造函数中&lt;a href=&quot;https://www.geeksforgeeks.org/instance-initialization-block-iib-java/&quot;&gt;初始化&lt;/a&gt;空的&lt;em&gt;final&lt;/em&gt;变量。如果您的类中有多个构造函数，则必须在所有构造函数中初始化它，否则将抛出编译时错误。&lt;/li&gt;
&lt;li&gt;可以在&lt;a href=&quot;https://www.geeksforgeeks.org/g-fact-79/&quot;&gt;静态块&lt;/a&gt;内初始化空的&lt;em&gt;final&lt;/em&gt;静态变量。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这里注意有一个很普遍的误区。&lt;u&gt;很多人会认为static修饰的final常量必须在声明时就进行初始化，否则会报错。但其实则不然，我们可以先使用&lt;em&gt;static final&lt;/em&gt;关键字声明一个类常量，然后再在&lt;a href=&quot;https://www.geeksforgeeks.org/g-fact-79/&quot;&gt;静态块&lt;/a&gt;内初始化空的&lt;em&gt;final&lt;/em&gt;静态变量。&lt;/u&gt;让我们通过一个例子看上面初始化&lt;em&gt;final&lt;/em&gt;变量的不同方法。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// Java program to demonstrate different 
// ways of initializing a final variable 
  
class Gfg  
{ 
    // a final variable direct initialize 
    // 直接赋值
    final int THRESHOLD = 5; 
      
    // a blank final variable 
    // 空final变量
    final int CAPACITY; 
      
    // another blank final variable 
    final int  MINIMUM; 
      
    // a final static variable PI direct initialize 
    // 直接赋值的静态final变量
    static final double PI = 3.141592653589793; 
      
    // a  blank final static variable 
    // 空的静态final变量，此处并不会报错，因为在下方的静态代码块内对其进行了初始化
    static final double EULERCONSTANT; 
      
    // instance initializer block for initializing CAPACITY 
    // 用来赋值空final变量的实例初始化块
    { 
        CAPACITY = 25; 
    } 
      
    // static initializer block for initializing EULERCONSTANT
    // 用来赋值空final变量的静态初始化块
    static{ 
        EULERCONSTANT = 2.3; 
    } 
      
    // constructor for initializing MINIMUM 
    // Note that if there are more than one 
    // constructor, you must initialize MINIMUM 
    // in them also 
    // 构造函数内初始化空final变量；注意如果有多个
    // 构造函数时，必须在每个中都初始化该final变量
    public GFG()  
    { 
        MINIMUM = -1; 
    } 
          
} &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;何时使用&lt;em&gt;final&lt;/em&gt;变量：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;普通变量和&lt;em&gt;final&lt;/em&gt;变量之间的唯一区别是我们可以将值重新赋值给普通变量；但是对于&lt;em&gt;final&lt;/em&gt;变量，一旦赋值，我们就不能改变&lt;em&gt;final&lt;/em&gt;变量的值。因此，&lt;em&gt;final&lt;/em&gt;变量必须仅用于我们希望在整个程序执行期间保持不变的值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;final&lt;/em&gt;引用变量：&lt;/strong&gt;&lt;br/&gt;当&lt;em&gt;final&lt;/em&gt;变量是对象的引用时，则此变量称为&lt;em&gt;final&lt;/em&gt;引用变量。例如，&lt;em&gt;final&lt;/em&gt;的&lt;em&gt;StringBuffer&lt;/em&gt;变量：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;final StringBuffer sb;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;final&lt;/em&gt;变量无法重新赋值。但是对于&lt;em&gt;final&lt;/em&gt;的引用变量，可以更改该引用变量指向的对象的内部状态。请注意，这不是重新赋值。&lt;em&gt;final的&lt;/em&gt;这个属性称为&lt;em&gt;非传递性&lt;/em&gt;。要了解对象内部状态的含义，请参阅下面的示例：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// Java program to demonstrate  
// reference final variable 
  
class Gfg 
{ 
    public static void main(String[] args)  
    { 
        // a final reference variable sb 
        final StringBuilder sb = new StringBuilder(&quot;Geeks&quot;); 
          
        System.out.println(sb); 
          
        // changing internal state of object 
        // reference by final reference variable sb 
        // 更改final变量sb引用的对象的内部状态
        sb.append(&quot;ForGeeks&quot;); 
          
        System.out.println(sb); 
    }     
} &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Geeks
GeeksForGeeks&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;非传递&lt;/em&gt;属性也适用于数组，因为在Java中&lt;a href=&quot;https://www.geeksforgeeks.org/arrays-in-java/&quot;&gt;数组也是对象&lt;/a&gt;。带有&lt;em&gt;final&lt;/em&gt;关键字的数组也称为&lt;a href=&quot;https://www.geeksforgeeks.org/final-arrays-in-java/&quot;&gt;&lt;em&gt;final&lt;/em&gt;数组&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意 ：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如上所述，&lt;em&gt;final&lt;/em&gt;变量不能重新赋值，这样做会抛出编译时错误。&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;   // Java program to demonstrate re-assigning 
   // final variable will throw compile-time error 
   
   class Gfg 
   { 
     static final int CAPACITY = 4; 
   
     public static void main(String args[]) 
     { 
       // re-assigning final variable 
       // will throw compile-time error 
       CAPACITY = 5; 
     } 
   } &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   Compiler Error: cannot assign a value to final variable CAPACITY&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;当在方法/构造函数/块中创建&lt;em&gt;final&lt;/em&gt;变量时，它被称为局部&lt;em&gt;final&lt;/em&gt;变量，并且必须在创建它的位置初始化一次。参见下面的局部&lt;em&gt;final&lt;/em&gt;变量程序：&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;   // Java program to demonstrate 
   // local final variable 
   
   // The following program compiles and runs fine 
   
   class Gfg 
   { 
    public static void main(String args[]) 
    { 
        // local final variable 
        final int i; 
        i = 20; 
        System.out.println(i); 
    } 
   } &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   20&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;注意C ++ &lt;em&gt;const&lt;/em&gt;变量和Java &lt;em&gt;final&lt;/em&gt;变量之间的区别。声明时，必须为C ++中的const变量赋值。对于Java中的&lt;em&gt;final&lt;/em&gt;变量，正如我们在上面的示例中所看到的那样，可以稍后赋值，但只能赋值一次。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;final&lt;/em&gt;在&lt;a href=&quot;https://www.geeksforgeeks.org/for-each-loop-in-java/&quot;&gt;foreach循环&lt;/a&gt;中：在foreach语句中使用&lt;em&gt;final&lt;/em&gt;声明存储循环元素的变量是合法的。&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;  // Java program to demonstrate final 
  // with for-each statement 

  class Gfg 
  { 
    public static void main(String[] args) 
    { 
      int arr[] = {1, 2, 3}; 

      // final with for-each statement 
      // legal statement 
      for (final int i : arr) 
        System.out.print(i + &quot; &quot;); 
    }    
  } &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1 2 3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;由于i变量在循环的每次迭代时超出范围，因此实际上每次迭代都重新声明，允许使用相同的标记（即i）来表示多个变量。&lt;/p&gt;
&lt;h3 id=&quot;final-修饰类&quot;&gt;final 修饰类&lt;/h3&gt;
&lt;p&gt;当使用&lt;em&gt;final&lt;/em&gt;关键字声明一个类时，它被称为&lt;em&gt;final&lt;/em&gt;类。被声明为&lt;em&gt;final&lt;/em&gt;的类不能被扩展（继承）。&lt;em&gt;final&lt;/em&gt;类有两种用途：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;一个是彻底防止被&lt;a href=&quot;https://www.geeksforgeeks.org/inheritance-in-java/&quot;&gt;继承&lt;/a&gt;，因为&lt;em&gt;final&lt;/em&gt;类不能被扩展。例如，所有&lt;a href=&quot;https://www.geeksforgeeks.org/wrapper-classes-java/&quot;&gt;包装类&lt;/a&gt;如&lt;a href=&quot;https://www.geeksforgeeks.org/java-lang-integer-class-java/&quot;&gt;Integer&lt;/a&gt;，&lt;a href=&quot;https://www.geeksforgeeks.org/java-lang-float-class-in-java/&quot;&gt;Float&lt;/a&gt;等都是&lt;em&gt;final&lt;/em&gt;类。我们无法扩展它们。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;final&lt;/em&gt;类的另一个用途是&lt;a href=&quot;https://www.geeksforgeeks.org/create-immutable-class-java/&quot;&gt;创建一个&lt;/a&gt;类似于&lt;a href=&quot;https://www.geeksforgeeks.org/string-class-in-java/&quot;&gt;String&lt;/a&gt;类的不可变类。只有将一个类定义成为&lt;em&gt;final&lt;/em&gt;类，才能使其不可变。&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;  final class A
  {
       // methods and fields
  }
  // 下面的这个类B想要扩展类A是非法的
  class B extends A 
  { 
      // COMPILE-ERROR! Can't subclass A
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Java支持把class定义成&lt;em&gt;final&lt;/em&gt;，似乎违背了面向对象编程的基本原则，但在另一方面，封闭的类也保证了该类的所有方法都是固定不变的，不会有子类的覆盖方法需要去动态加载。这给编译器做优化时提供了更多的可能，最好的例子是String，它就是&lt;em&gt;final&lt;/em&gt;类，Java编译器就可以把字符串常量（那些包含在双引号中的内容）直接变成String对象，同时对运算符&quot;+&quot;的操作直接优化成新的常量，因为final修饰保证了不会有子类对拼接操作返回不同的值。&lt;br/&gt;对于所有不同的类定义一顶层类(全局或包可见)、嵌套类(内部类或静态嵌套类)都可以用final来修饰。但是一般来说final多用来修饰在被定义成全局(public)的类上，因为对于非全局类，访问修饰符已经将他们限制了它们的也可见性，想要继承这些类已经很困难，就不用再加一层final限制。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;final&lt;/em&gt;与匿名内部类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;匿名类(Anonymous Class)虽然说同样不能被继承，但它们并没有被编译器限制成final。另外要提到的是，网上有许多地方都说因为使用内部类，会有两个地方必须需要使用 &lt;em&gt;final&lt;/em&gt; 修饰符：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在内部类的方法使用到方法中定义的局部变量，则该局部变量需要添加 &lt;em&gt;final&lt;/em&gt; 修饰符&lt;/li&gt;
&lt;li&gt;在内部类的方法形参使用到外部传过来的变量，则形参需要添加 &lt;em&gt;final&lt;/em&gt; 修饰符&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;原因大多是说当我们创建匿名内部类的那个方法调用运行完毕之后，因为局部变量的生命周期和方法的生命周期是一样的，当方法弹栈，&lt;strong&gt;这个局部变量就会消亡了，但内部类对象可能还存在。&lt;/strong&gt; 此时就会出现一种情况，就是我们调用这个内部类对象去访问一个不存在的局部变量，就可能会出现空指针异常。而此时需要使用 &lt;em&gt;final&lt;/em&gt; 在类加载的时候进入常量池，即使方法弹栈，常量池的常量还在，也可以继续使用，JVM 会持续维护这个引用在回调方法中的生命周期。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;但是 JDK 1.8 取消了对匿名内部类引用的局部变量 &lt;em&gt;final&lt;/em&gt; 修饰的检查&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;对此，&lt;a href=&quot;https://www.jianshu.com/u/7e0d004ed427&quot;&gt;theonlin&lt;/a&gt;专门通过实验做出了总结：其实局部内部类并不是直接调用方法传进来的参数，而是内部类将传进来的参数通过自己的构造器备份到了自己的内部，自己内部的方法调用的实际是自己的属性而不是外部类方法的参数。外部类中的方法中的变量或参数只是方法的局部变量，这些变量或参数的作用域只在这个方法内部有效，所以方法中被 &lt;em&gt;final&lt;/em&gt;的变量的仅仅作用是表明这个变量将作为内部类构造器参数，&lt;strong&gt;其实&lt;em&gt;final&lt;/em&gt;不加也可以，加了可能还会占用内存空间，影响 GC&lt;/strong&gt;。最后结论就是，需要使用 final 去持续维护这个引用在回调方法中的生命周期这种说法应该是错误的，也没必要。&lt;/p&gt;
&lt;h3 id=&quot;final-修饰方法&quot;&gt;final 修饰方法&lt;/h3&gt;
&lt;p&gt;下面这段话摘自《Java编程思想》第四版第143页：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;使用&lt;em&gt;final&lt;/em&gt;方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当使用&lt;em&gt;final&lt;/em&gt;关键字声明方法时，它被称为&lt;em&gt;final&lt;/em&gt;方法。&lt;em&gt;final&lt;/em&gt;方法无法被&lt;a href=&quot;https://www.geeksforgeeks.org/overriding-in-java/&quot;&gt;覆盖&lt;/a&gt;（重写）。比如&lt;a href=&quot;https://www.geeksforgeeks.org/object-class-in-java/&quot;&gt;Object类&lt;/a&gt;，它的一些方法就被声明成为了&lt;em&gt;final&lt;/em&gt;。如果你认为一个方法的功能已经足够完整了，子类中不需要改变的话，你可以声明此方法为&lt;em&gt;final&lt;/em&gt;。以下代码片段说明了用&lt;em&gt;final&lt;/em&gt;关键字修饰方法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class A 
{
    // 父类的ml方法被使用了final关键字修饰
    final void m1() 
    {
        System.out.println(&quot;This is a final method.&quot;);
    }
}

class B extends A 
{
    // 此处会报错，子类B尝试重写父类A的被final修饰的ml方法
    @override
    void m1()
    { 
        // COMPILE-ERROR! Can't override.
        System.out.println(&quot;Illegal!&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而关于高效，是因为在java早期实现中，如果将一个方法指明为final，就是同意编译器将针对该方法的调用都转化为内嵌调用（内联）。大概就是，如果是内嵌调用，虚拟机不再执行正常的方法调用（参数压栈，跳转到方法处执行，再调回，处理栈参数，处理返回值），而是直接将方法展开，以方法体中的实际代码替代原来的方法调用。这样减少了方法调用的开销。所以有一些程序员认为：&lt;strong&gt;除非有足够的理由使用多态性，否则应该将所有的方法都用 final 修饰。这样的认识未免有些偏激&lt;/strong&gt;，因为在最近的java设计中，虚拟机（特别是hotspot技术）可以自己去根据具体情况自动优化选择是否进行内联，只不过使用了&lt;em&gt;final&lt;/em&gt;关键字的话可以显示地影响编译器对被修饰的代码进行内联优化。所以请切记，对于Java虚拟机来说编译器在编译期间会自动进行内联优化，这是由编译器决定的，对于开发人员来说，一定要设计好时空复杂度的平衡，不要滥用final。&lt;/p&gt;
&lt;p&gt;注1：类的&lt;em&gt;private&lt;/em&gt;方法会隐式地被指定为&lt;em&gt;final&lt;/em&gt;方法，也就同样无法被重写。可以对private方法添加final修饰符，但并没有添加任何额外意义。&lt;/p&gt;
&lt;p&gt;注2：在java中，你永远不会看到同时使用&lt;a href=&quot;https://www.geeksforgeeks.org/final-keyword-java/&quot;&gt;&lt;em&gt;final&lt;/em&gt;&lt;/a&gt;和&lt;em&gt;abstract&lt;/em&gt;关键字声明的类或方法。对于类，&lt;em&gt;final&lt;/em&gt;用于防止&lt;a href=&quot;https://www.geeksforgeeks.org/inheritance-in-java/&quot;&gt;继承&lt;/a&gt;，而抽象类反而需要依赖于它们的子类来完成实现。在修饰方法时，&lt;em&gt;final&lt;/em&gt;用于防止被&lt;a href=&quot;https://www.geeksforgeeks.org/overriding-in-java/&quot;&gt;覆盖&lt;/a&gt;，而抽象方法反而需要在子类中被重写。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有关&lt;em&gt;final&lt;/em&gt;方法和&lt;em&gt;final&lt;/em&gt;类的更多示例和行为&lt;/strong&gt;，请参阅&lt;a href=&quot;https://www.geeksforgeeks.org/using-final-with-inheritance-in-java/&quot;&gt;使用final继承&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;final-优化编码的艺术&quot;&gt;final 优化编码的艺术&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;final&lt;/em&gt;关键字在效率上的作用主要可以总结为以下三点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;缓存：&lt;em&gt;final&lt;/em&gt;配合&lt;em&gt;static&lt;/em&gt;关键字提高了代码性能，JVM和Java应用都会缓存&lt;em&gt;final&lt;/em&gt;变量。&lt;/li&gt;
&lt;li&gt;同步：&lt;em&gt;final&lt;/em&gt;变量或对象是只读的，可以安全的在多线程环境下进行共享，而不需要额外的同步开销。&lt;/li&gt;
&lt;li&gt;内联：使用&lt;em&gt;final&lt;/em&gt;关键字，JVM会&lt;strong&gt;显式地&lt;/strong&gt;主动对方法、变量及类进行内联优化。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;更多关于&lt;em&gt;final&lt;/em&gt;关键字对代码的优化总结以及注意点可以参考IBM的&lt;a href=&quot;https://www.ibm.com/developerworks/library/j-jtp1029/index.html&quot;&gt;《Is that your final answer?》&lt;/a&gt;这篇文章。&lt;/p&gt;
</description>
<pubDate>Mon, 15 Apr 2019 15:23:00 +0000</pubDate>
<dc:creator>Heriam</dc:creator>
<og:description>本文原文地址： 'https://jiang hao.com/articles/2019/coding java final keyword.html' [^1] final 简介[^2] final</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cciejh/p/final-in-java.html</dc:identifier>
</item>
<item>
<title>【译】.NET Core 3.0 Preview 3中关于ASP.NET Core的更新内容 - 艾心❤</title>
<link>http://www.cnblogs.com/edison0621/p/10714069.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/edison0621/p/10714069.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://devblogs.microsoft.com/dotnet/announcing-net-core-3-preview-3/&quot;&gt;.NET Core 3.0 Preview 3已经推出&lt;/a&gt;，它包含了一系列关于ASP.NET Core的新的更新。&lt;/p&gt;
&lt;p&gt;下面是该预览版的更新列表：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Razor组件改进:
&lt;ul&gt;&lt;li&gt;单项目模板 &lt;/li&gt;
&lt;li&gt;新的Razer扩展&lt;/li&gt;
&lt;li&gt;Endpoint路由集成&lt;/li&gt;
&lt;li&gt;预呈现&lt;/li&gt;
&lt;li&gt;Razor类库中的Razor组件&lt;/li&gt;
&lt;li&gt;改进事件处理 &lt;/li&gt;
&lt;li&gt;Forms &amp;amp; validation&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;运行时编译&lt;/li&gt;
&lt;li&gt;Worker服务模板&lt;/li&gt;
&lt;li&gt;gRPC模板&lt;/li&gt;
&lt;li&gt;Angular模板已更新为Angular 7&lt;/li&gt;
&lt;li&gt;SPA认证 &lt;/li&gt;
&lt;li&gt;SignalR与Endpoint路由集成&lt;/li&gt;
&lt;li&gt;SignalR Java客户端支持长轮询&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其他详细信息和已知问题，请参阅&lt;a href=&quot;https://aka.ms/netcore3releasenotes&quot;&gt;发行说明&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;要在.NET Core 3.0 Preview 3中开始使用ASP.NET Core，&lt;a href=&quot;https://aka.ms/netcore3download&quot;&gt;请安装.NET Core 3.0 Preview 3 SDK&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果您使用的是Visual Studio，则还需要&lt;a href=&quot;https://visualstudio.com/preview&quot;&gt;安装Visual Studio 2019的最新预览版&lt;/a&gt;【译者注：目前VS2019正式版已经发布，直接安装正式版即可】。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;注意：要在Visual Studio 2019中使用.NET Core 3.0预览版，需要启用选项以使用.NET Core SDK预览版，方法是通过【&lt;em&gt;工具&amp;gt;选项&amp;gt;项目和解决方案&amp;gt; .NET Core&amp;gt;使用.NET Core SDK预览版&lt;/em&gt;】&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;将现有的ASP.NET Core应用程序升级到.NET Core 3.0 Preview 3，请按照&lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/migration/22-to-30&quot;&gt;ASP.NET Core文档中&lt;/a&gt;的&lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/migration/22-to-30&quot;&gt;迁移步骤进行操作&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;另请参阅ASP.NET Core 3.0 中的&lt;a href=&quot;https://github.com/aspnet/announcements/issues?utf8=%E2%9C%93&amp;amp;q=is%3Aissue+label%3A3.0.0+label%3A%22Breaking+change%22&quot;&gt;重大更改&lt;/a&gt;的完整列表。&lt;/p&gt;

&lt;p&gt;在前面的预览中，我们介绍了Razor组件，这是一种用ASP.NET核心构建交互式客户端Web UI的新方法。本节将会介绍我们在该预览更新中对Razor组件所做的各种改进。&lt;/p&gt;
&lt;h2&gt;单项目模板&lt;/h2&gt;
&lt;p&gt;Razor组件项目模板现在是单个项目，而不是同一解决方案中的两个项目。所编写的Razor组件位于托管它们的ASP.NET Core应用程序中。同一个ASP.NET Core项目可以包含Razor组件、页面和视图。Razor组件模板与其他ASP.NET Core Web应用程序模板一样，默认情况下也启用了HTTPS。&lt;/p&gt;
&lt;h2&gt;新的Razer扩展&lt;/h2&gt;
&lt;p&gt;Razor组件使用Razor语法编写，但编译方式与Razor页面和视图不同。为了明确哪些Razor文件应该编译为Razor组件，我们引入了一个新的文件扩展名：.razor。在Razor组件模板中，所有组件文件现在都使用.razor扩展名。Razor页面和视图仍然使用.cshtml扩展名。&lt;/p&gt;
&lt;p&gt;只要使用_RazorComponentInclude MSBuild属性将这些文件标识为Razor组件文件，Razor组件仍然可以使用.cshtml文件扩展名来创建。例如，该版本中的Razor组件模板指定Components文件夹下的所有.cshtml文件为Razor组件。&lt;/p&gt;
&lt;div class=&quot;csharpcode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   1:  &lt;/span&gt;&amp;lt;_RazorComponentInclude&amp;gt;Components\**\*.cshtml&amp;lt;/_RazorComponentInclude&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;请注意，这个版本中的.razor文件有很多限制。有关已知问题和可用解决方案的列表，请参考发布说明。&lt;/p&gt;
&lt;h2&gt;Endpoint路由集成&lt;/h2&gt;
&lt;p&gt;Razor组件现在已经集成到了ASP.NET Core中新的Endpoint路由系统。要在应用程序中启用Razor组件支持，需要在路由配置中使用MapComponentHub&amp;lt;TComponent&amp;gt;。&lt;/p&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   1:  &lt;/span&gt;app.UseRouting(routes =&amp;gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   2:  &lt;/span&gt;{
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   3:  &lt;/span&gt;    routes.MapRazorPages();
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   4:  &lt;/span&gt;    routes.MapComponentHub&amp;lt;App&amp;gt;(&lt;span class=&quot;str&quot;&gt;&quot;app&quot;&lt;/span&gt;);
&lt;/pre&gt;
&lt;p&gt;这会将应用程序配置以接受交互式Razor组件的传入连接，并指定根组件App应该在匹配选择器App的DOM元素中呈现。&lt;/p&gt;
&lt;h2&gt;预呈现&lt;/h2&gt;
&lt;p&gt;默认情况下，Razor组件项目模板执行服务端预渲染。也就是说当用户浏览您的应用程序时，服务器将对您的Razor组件执行初始化渲染，并将结果作为纯静态HTML传递给浏览器。然后，浏览器将通过SignalR重新连接到服务器，并将Razor组件切换为完全交互的模式。这两个阶段的交付是有益的，因为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;它提高了站点的感知能力，因为用户界面可以更快地出现，而无需等待进行任何WebSocket连接，甚至运行任何客户端脚本。这对连接速度较慢的用户有着更大的影响，如2G/3G手机。&lt;/li&gt;
&lt;li&gt;它可以让搜索引擎很容易的搜索到你的应用程序。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于使用更快连接的用户（如内网用户），此功能的影响较小，因为无论如何用户界面都应该立即出现。&lt;/p&gt;
&lt;p&gt;设置预渲染，Razor组件项目模板不会有静态HTML文件。取而代之的是单个Razor页面/Pages/Index.cshtml，使用Html.RenderComponentAsync&amp;lt;TComponent&amp;gt;() HTML帮助器预呈现应用程序内容。该页面还引用components.server.js脚本，在预呈现和下载内容后设置SignalR 连接。由于这是一个Razor页面，像环境标签助手这样的功能就可以工作了。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Index.cshtml&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;csharpcode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   1:  &lt;/span&gt;@page &quot;{*clientPath}&quot;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   2:  &lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;&amp;lt;!&lt;/span&gt;&lt;span class=&quot;html&quot;&gt;DOCTYPE&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;html&lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   3:  &lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;html&quot;&gt;html&lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   4:  &lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;html&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   5:  &lt;/span&gt;    ...
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   6:  &lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;html&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   7:  &lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;html&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   8:  &lt;/span&gt;    &lt;span class=&quot;kwrd&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;html&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;&amp;gt;&lt;/span&gt;@(await Html.RenderComponentAsync&lt;span class=&quot;kwrd&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;html&quot;&gt;App&lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;&amp;gt;&lt;/span&gt;())&lt;span class=&quot;kwrd&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;html&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   9:  &lt;/span&gt; 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  10:  &lt;/span&gt;    &lt;span class=&quot;kwrd&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;html&quot;&gt;script&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;=&quot;_framework/components.server.js&quot;&lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;html&quot;&gt;script&lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  11:  &lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;html&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  12:  &lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;html&quot;&gt;html&lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;除了应用程序加载速度更快之外，还可以在浏览器开发工具中查看下载的HTML源代码，从而可以看到预渲染正在进行。Razor组件在HTML中是完全呈现的。&lt;/p&gt;
&lt;h2&gt;Razor类库中的Razor组件&lt;/h2&gt;
&lt;p&gt;现在可以将Razor组件添加到Razor类库中，并使用Razor组件从ASP.NET核心项目引用它们。&lt;/p&gt;
&lt;p&gt;在Razer类库中创建可重用的Razer组件：&lt;/p&gt;
&lt;p&gt;1、创建Razer组件应用程序&lt;/p&gt;
&lt;div class=&quot;csharpcode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   1:  &lt;/span&gt;dotnet &lt;span class=&quot;kwrd&quot;&gt;new&lt;/span&gt; razorcomponents -o RazorComponentsApp1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、创建Razer类库&lt;/p&gt;
&lt;div class=&quot;csharpcode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   1:  &lt;/span&gt;dotnet &lt;span class=&quot;kwrd&quot;&gt;new&lt;/span&gt; razorclasslib -o RazorClassLib1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3、添加&lt;em&gt;Component1.razor&lt;/em&gt;文件到Razer类库&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Component1.razor&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;csharpcode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   1:  &lt;/span&gt;&amp;lt;h1&amp;gt;Component1&amp;lt;/h1&amp;gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   2:  &lt;/span&gt; 
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   3:  &lt;/span&gt;&amp;lt;p&amp;gt;@message&amp;lt;/p&amp;gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   4:  &lt;/span&gt; 
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   5:  &lt;/span&gt;@functions {
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   6:  &lt;/span&gt;    &lt;span class=&quot;kwrd&quot;&gt;string&lt;/span&gt; message = &lt;span class=&quot;str&quot;&gt;&quot;Hello from a Razor Class Library&quot;&lt;/span&gt;!;
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   7:  &lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;1、使用Razor组件从ASP.NET Core应用程序引用Razor类库&lt;/p&gt;
&lt;div class=&quot;csharpcode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   1:  &lt;/span&gt;dotnet add RazorComponentsApp1 reference RazorClassLib1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在Razor组件应用程序中，使用@addTagHelper指令从Razor类库导入所有组件，然后在应用程序中使用component1&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Index.razor&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;csharpcode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   1:  &lt;/span&gt;@page &lt;span class=&quot;str&quot;&gt;&quot;/&quot;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   2:  &lt;/span&gt;@addTagHelper *, RazorClassLib1
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   3:  &lt;/span&gt; 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   4:  &lt;/span&gt;&amp;lt;h1&amp;gt;Hello, world!&amp;lt;/h1&amp;gt;
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   5:  &lt;/span&gt; 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   6:  &lt;/span&gt;Welcome to your &lt;span class=&quot;kwrd&quot;&gt;new&lt;/span&gt; app.
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   7:  &lt;/span&gt; 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   8:  &lt;/span&gt;&amp;lt;Component1 /&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意：在此版本中，Razer类库与Blazor应用程序并不兼容。另外，Razor类库还不支持静态资源。如果要在库中创建可与Blazor和Razor组件应用程序共享的组件，仍然需要使用Blazor类库。这写问题会在未来的更新中解决。&lt;/p&gt;
&lt;h2&gt;改进事件处理&lt;/h2&gt;
&lt;p&gt;新的eventcallback和eventcallback&amp;lt;&amp;gt;类型使得定义组件回调更加简单。例如，考虑以下两个组件：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;MyButton.razor&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;csharpcode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   1:  &lt;/span&gt;&amp;lt;button onclick=&lt;span class=&quot;str&quot;&gt;&quot;@OnClick&quot;&lt;/span&gt;&amp;gt;Click here and see what happens!&amp;lt;/button&amp;gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   2:  &lt;/span&gt; 
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   3:  &lt;/span&gt;@functions {
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   4:  &lt;/span&gt;    [Parameter] EventCallback&amp;lt;UIMouseEventArgs&amp;gt; OnClick { get; set; }
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   5:  &lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;UsesMyButton.razor&lt;/p&gt;
&lt;div class=&quot;csharpcode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   1:  &lt;/span&gt;&amp;lt;div&amp;gt;@text&amp;lt;/div&amp;gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   2:  &lt;/span&gt; 
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   3:  &lt;/span&gt;&amp;lt;MyButton OnClick=&lt;span class=&quot;str&quot;&gt;&quot;ShowMessage&quot;&lt;/span&gt; /&amp;gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   4:  &lt;/span&gt; 
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   5:  &lt;/span&gt;@function {
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   6:  &lt;/span&gt;    &lt;span class=&quot;kwrd&quot;&gt;string&lt;/span&gt; text;
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   7:  &lt;/span&gt; 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   8:  &lt;/span&gt;    &lt;span class=&quot;kwrd&quot;&gt;void&lt;/span&gt; ShowMessage(UIMouseEventArgs e)
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   9:  &lt;/span&gt;    {
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  10:  &lt;/span&gt;        text = &lt;span class=&quot;str&quot;&gt;&quot;Hello, world!&quot;&lt;/span&gt;;
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  11:  &lt;/span&gt;    }
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  12:  &lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;onclick回调的类型是EventCallback&amp;lt;UIMouseEventArgs&amp;gt;（取代Action&amp;lt;UIMouseEventArgs&amp;gt;），MyButton直接传递给onclick事件处理程序。编译器处理将委托转换为EventCallback的过程，并将执行其他一些操作，以确保呈现过程具有足够的信息来呈现正确的目标组件。因此，不需要在ShowMessage事件处理程序中显式调用StateHasChanged。编译器处理将委托转换为EventCallback的过程，并将执行其他一些操作，以确保渲染过程具有足够的信息来渲染正确的目标组件。因此，不需要在ShowMessage事件处理程序中显式调用StateHasChanged。&lt;/p&gt;
&lt;p&gt;通过使用EventCallback&amp;lt;&amp;gt;类型的OnClick处理程序可以是异步的，而不需要对MyButton进行任何其他代码的修改。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;UsesMyButton.razor&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;csharpcode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   1:  &lt;/span&gt;&amp;lt;div&amp;gt;@text&amp;lt;/div&amp;gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   2:  &lt;/span&gt; 
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   3:  &lt;/span&gt;&amp;lt;MyButton OnClick=&lt;span class=&quot;str&quot;&gt;&quot;ShowMessageAsync&quot;&lt;/span&gt; /&amp;gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   4:  &lt;/span&gt; 
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   5:  &lt;/span&gt;@function {
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   6:  &lt;/span&gt;    &lt;span class=&quot;kwrd&quot;&gt;string&lt;/span&gt; text;
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   7:  &lt;/span&gt; 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   8:  &lt;/span&gt;    async Task ShowMessageAsync(UIMouseEventArgs e)
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   9:  &lt;/span&gt;    {
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  10:  &lt;/span&gt;        await Task.Yield(); 
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  11:  &lt;/span&gt;        text = &lt;span class=&quot;str&quot;&gt;&quot;Hello, world!&quot;&lt;/span&gt;;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  12:  &lt;/span&gt;    }
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  13:  &lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们建议在为事件处理和绑定定义组件参数时使用EventCallback and EventCallback&amp;lt;T&amp;gt;。尽可能使用EventCallback&amp;lt;&amp;gt;，因为它是强类型的并且可以向组件的用户提供更好的反馈。当没有传递给回调函数的值时，也使用EventCallback。&lt;/p&gt;
&lt;h2&gt;Forms&amp;amp;validation&lt;/h2&gt;
&lt;p&gt;此预览版本添加了用于处理表单和验证的内置组件和基础结构。&lt;/p&gt;
&lt;p&gt;使用. net进行客户端web开发的一个好处是能够在客户端和服务器之间共享相同的实现逻辑。验证逻辑是一个很好的逻辑。Razor组件中的新的Forms&amp;amp;validation支持包括使用数据注解处理验证的支持，或者可以插入你喜欢的验证系统。&lt;/p&gt;
&lt;p&gt;例如，以下Person类型使用数据注解定义验证逻辑：&lt;/p&gt;
&lt;div class=&quot;csharpcode&quot; readability=&quot;25&quot;&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   1:  &lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;class&lt;/span&gt; Person
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   2:  &lt;/span&gt;{
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   3:  &lt;/span&gt;    [Required(ErrorMessage = &lt;span class=&quot;str&quot;&gt;&quot;Enter a name&quot;&lt;/span&gt;)]
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   4:  &lt;/span&gt;    [StringLength(10, ErrorMessage = &lt;span class=&quot;str&quot;&gt;&quot;That name is too long&quot;&lt;/span&gt;)]
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   5:  &lt;/span&gt;    &lt;span class=&quot;kwrd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;string&lt;/span&gt; Name { get; set; }
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   6:  &lt;/span&gt; 
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   7:  &lt;/span&gt;    [Range(0, 200, ErrorMessage = &lt;span class=&quot;str&quot;&gt;&quot;Nobody is that old&quot;&lt;/span&gt;)]
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   8:  &lt;/span&gt;    &lt;span class=&quot;kwrd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;int&lt;/span&gt; AgeInYears { get; set; }
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   9:  &lt;/span&gt; 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  10:  &lt;/span&gt;    [Required]
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  11:  &lt;/span&gt;    [Range(&lt;span class=&quot;kwrd&quot;&gt;typeof&lt;/span&gt;(&lt;span class=&quot;kwrd&quot;&gt;bool&lt;/span&gt;), &lt;span class=&quot;str&quot;&gt;&quot;true&quot;&lt;/span&gt;, &lt;span class=&quot;str&quot;&gt;&quot;true&quot;&lt;/span&gt;, ErrorMessage = &lt;span class=&quot;str&quot;&gt;&quot;Must accept terms&quot;&lt;/span&gt;)]
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  12:  &lt;/span&gt;    &lt;span class=&quot;kwrd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;bool&lt;/span&gt; AcceptsTerms { get; set; }
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  13:  &lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以下是如何基于&lt;code&gt;Person&lt;/code&gt;模型锁创建的验证表单：&lt;/p&gt;
&lt;div class=&quot;csharpcode&quot; readability=&quot;25&quot;&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   1:  &lt;/span&gt;&amp;lt;EditForm Model=&lt;span class=&quot;str&quot;&gt;&quot;@person&quot;&lt;/span&gt; OnValidSubmit=&lt;span class=&quot;str&quot;&gt;&quot;@HandleValidSubmit&quot;&lt;/span&gt;&amp;gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   2:  &lt;/span&gt;    &amp;lt;DataAnnotationsValidator /&amp;gt;
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   3:  &lt;/span&gt;    &amp;lt;ValidationSummary /&amp;gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   4:  &lt;/span&gt; 
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   5:  &lt;/span&gt;    &amp;lt;p &lt;span class=&quot;kwrd&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;str&quot;&gt;&quot;name&quot;&lt;/span&gt;&amp;gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   6:  &lt;/span&gt;        Name: &amp;lt;InputText bind-Value=&lt;span class=&quot;str&quot;&gt;&quot;@person.Name&quot;&lt;/span&gt; /&amp;gt;
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   7:  &lt;/span&gt;    &amp;lt;/p&amp;gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   8:  &lt;/span&gt;    &amp;lt;p &lt;span class=&quot;kwrd&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;str&quot;&gt;&quot;age&quot;&lt;/span&gt;&amp;gt;
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   9:  &lt;/span&gt;        Age (years): &amp;lt;InputNumber bind-Value=&lt;span class=&quot;str&quot;&gt;&quot;@person.AgeInYears&quot;&lt;/span&gt; /&amp;gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  10:  &lt;/span&gt;    &amp;lt;/p&amp;gt;
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  11:  &lt;/span&gt;    &amp;lt;p &lt;span class=&quot;kwrd&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;str&quot;&gt;&quot;accepts-terms&quot;&lt;/span&gt;&amp;gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  12:  &lt;/span&gt;        Accepts terms: &amp;lt;InputCheckbox bind-Value=&lt;span class=&quot;str&quot;&gt;&quot;@person.AcceptsTerms&quot;&lt;/span&gt; /&amp;gt;
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  13:  &lt;/span&gt;    &amp;lt;/p&amp;gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  14:  &lt;/span&gt; 
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  15:  &lt;/span&gt;    &amp;lt;button type=&lt;span class=&quot;str&quot;&gt;&quot;submit&quot;&lt;/span&gt;&amp;gt;Submit&amp;lt;/button&amp;gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  16:  &lt;/span&gt;&amp;lt;/EditForm&amp;gt;
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  17:  &lt;/span&gt; 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  18:  &lt;/span&gt;@functions {
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  19:  &lt;/span&gt;    Person person = &lt;span class=&quot;kwrd&quot;&gt;new&lt;/span&gt; Person();
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  20:  &lt;/span&gt; 
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  21:  &lt;/span&gt;    &lt;span class=&quot;kwrd&quot;&gt;void&lt;/span&gt; HandleValidSubmit()
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  22:  &lt;/span&gt;    {
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  23:  &lt;/span&gt;        Console.WriteLine(&lt;span class=&quot;str&quot;&gt;&quot;OnValidSubmit&quot;&lt;/span&gt;);
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  24:  &lt;/span&gt;    }
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  25:  &lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果将此表单添加到应用程序中，并运行它，你将获得一个基本表单，该表单在字段更改和表单提交时自动进行字段输入值的验证。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://devblogs.microsoft.com/aspnet/wp-content/uploads/sites/16/2019/03/razor-components-validating-form.png&quot; alt=&quot;Validating form&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里发生了很多事情，让我们把它一个一个地分解：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;这个表单是使用新的EditForm组件定义的。EditForm将EditContext设置为一个级联相关的值，该值用于跟踪关于编辑过程的元数据(例如，已修改的内容、当前验证消息等)。EditForm还为有效和无效提交(OnValidSubmit、OnInvalidSubmit)提供了合适的事件。如果想自己触发验证，也可以直接使用OnSubmit。&lt;/li&gt;
&lt;li&gt;DataAnnotationsValidator组件使用数据注解，以验证支持附加到级联的EditContext。 使用数据注释启用验证支持需要显式调用，但我们正在考虑将其作为默认行为，但随后你可以覆盖它。&lt;/li&gt;
&lt;li&gt;每个表单字段都是使用一组内置的输入组件（InputText, InputNumber, InputCheckbox, InputSelect等）定义的。这些组件提供默认行为，用于在编辑时验证并更改它们的CSS类以反映字段状态。其中一些具有有用的分析逻辑（例如，InputDate和InputNumber将不可解析的值注册为验证错误，这样可以优雅地处理它们）。相关字段还支持目标字段的可空性（例如，int？）。&lt;/li&gt;
&lt;li&gt;ValidationMessage组件显示特定字段的验证消息。&lt;/li&gt;
&lt;li&gt;ValidationSummary组件汇总所有验证消息（类似于验证摘要标记助手）。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;内置的输入组件存在一些限制，我们希望在将来的更新中改进这些限制。例如，目前不能在生成输入标记上指定任意属性。将来，我们计划启用组件的所有额外属性。现在，您需要构建自己的组件子类来处理这些情况。&lt;/p&gt;
&lt;h2&gt;运行时验证&lt;/h2&gt;
&lt;p&gt;对运行时编译的支持已从.NET Core 3.0中的ASP.NET核心共享框架中删除，但现在可以通过向应用程序添加包的方式来启用它。&lt;/p&gt;
&lt;p&gt;启用运行时编译：&lt;/p&gt;
&lt;p&gt;添加Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation&lt;/p&gt;
&lt;div class=&quot;csharpcode&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   1:  &lt;/span&gt;&amp;lt;PackageReference Include=&lt;span class=&quot;str&quot;&gt;&quot;Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation&quot;&lt;/span&gt; Version=&lt;span class=&quot;str&quot;&gt;&quot;3.0.0-preview3-19153-02&quot;&lt;/span&gt; /&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在Startup.ConfigureServices添加对AddRazorRuntimeCompilation的调用&lt;/p&gt;
&lt;div class=&quot;csharpcode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   1:  &lt;/span&gt;services.AddMvc().AddRazorRuntimeCompilation();
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Worker服务模板&lt;/h2&gt;
&lt;p&gt;在preview3中，我们引入了一个名为“Worker Service”的新模板。此模板被设计为运行长时间运行的后台进程的起点，就像您可能作为Windows服务或Linux守护进程运行一样。例如，从消息队列生成/消费消息，或者监视要处理的文件。它旨在支持ASP.NET Core的生产力功能，如日志记录，DI，配置等，而不承载任何Web依赖项。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://devblogs.microsoft.com/aspnet/wp-content/uploads/sites/16/2019/03/worker-service.png&quot; alt=&quot;å·¥äººæœåŠ¡&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在接下来的几天里，我们将发布一些博客文章，提供更多关于使用Worker模板入门的练习。我们将有一些专门官微Windows/SystemD服务发布、在ACI/AKS上运行以及作为WebJob运行的文章。&lt;/p&gt;
&lt;h2&gt;提醒&lt;/h2&gt;
&lt;p&gt;虽然其目的是使工作模板默认情况下不依赖于web技术，但在preview3中它仍然使用web SDK，并在您选择“ASP.NET Core WebApplication”之后显示出来。&lt;/p&gt;
&lt;h2&gt;Angular模板更新到了Angular 7&lt;/h2&gt;
&lt;p&gt;Angular模板更新到了Angular 7。在 .NET Core 3.0 发布稳定版本之前，我们预计会更新到Angular 8。&lt;/p&gt;
&lt;h2&gt;SPA身份认证&lt;/h2&gt;
&lt;p&gt;这个版本，在Angular和React模板中引入了对身份验证的支持。在本节中，我们将展示如何创建一个新的Angular或React模板，该模板允许我们对用户进行身份验证并访问受保护的API资源。&lt;/p&gt;
&lt;p&gt;我们对用户身份验证和授权的支持是由IdentityServer在后台提供的，我们构建了一些扩展来简化我们特定场景的配置体验。&lt;/p&gt;
&lt;p&gt;注意：在本文中，我们展示了对Angular的身份验证支持，但在React模板中提供了相同的功能。&lt;/p&gt;
&lt;h2&gt;创建新的Angular应用程序&lt;/h2&gt;
&lt;p&gt;要创建一一个新的支持身份验证的Angular应用程序，我们需要调用以下命令:&lt;/p&gt;
&lt;div class=&quot;csharpcode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   1:  &lt;/span&gt;dotnet &lt;span class=&quot;kwrd&quot;&gt;new&lt;/span&gt; angular -au Individual
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个命令创建一个新的ASP.NET Core应用程序和托管的客户端Angular应用程序。ASP.NET Core应用程序包括已配置的Identity Server实例，可是让Angular应用程序很方面的对用户进行身份验证，并针对ASP.NET Core应用程序中的受保护资源发送HTTP请求。&lt;/p&gt;
&lt;p&gt;Angular模块所构建的身份验证和授权支持，可以导入到您的应用程序中，并提供一套组件和服务来增强主应用程序模块的功能。&lt;/p&gt;
&lt;h2&gt;运行该应用程序&lt;/h2&gt;
&lt;p&gt;要运行应用程序，只需执行以下命令，然后用浏览器打开控制台上显示的URL：&lt;/p&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   1:  &lt;/span&gt;dotnet run
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   1:  &lt;/span&gt;Hosting environment: Development
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   2:  &lt;/span&gt;Content root path: C:\angularapp
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   3:  &lt;/span&gt;Now listening on: https:&lt;span class=&quot;rem&quot;&gt;//localhost:5001&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   4:  &lt;/span&gt;Now listening on: http:&lt;span class=&quot;rem&quot;&gt;//localhost:5000&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   5:  &lt;/span&gt;Application started. Press Ctrl+C to shut down.
&lt;/pre&gt;
&lt;p class=&quot;csharpcode&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;csharpcode&quot;&gt;&lt;span&gt;&lt;strong&gt;运行结果如下：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://devblogs.microsoft.com/aspnet/wp-content/uploads/sites/16/2019/03/spa-auth-index.png&quot; alt=&quot;SPAæŒ‡æ•°&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当我们打开应用程序时，我们会看到常用的Home、Counter和Fetch数据菜单选项以及两个新选项:Register和Login。如果单击Register，我们将被发送到默认的认证界面(在运行迁移和更新数据库之后)，在那里我们可以注册为新用户。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://devblogs.microsoft.com/aspnet/wp-content/uploads/sites/16/2019/03/spa-auth-register.png&quot; alt=&quot;SPA register&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注册为新用户后，我们将被重定向回应用程序，在那里我们可以看到我们成功地通过了身份验证。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://devblogs.microsoft.com/aspnet/wp-content/uploads/sites/16/2019/03/spa-logged-in.png&quot; alt=&quot;SPA logged in&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;调用经过身份验证的API&lt;/h2&gt;
&lt;p&gt;如果我们点击获取数据，我们可以看到天气预报数据列表&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://devblogs.microsoft.com/aspnet/wp-content/uploads/sites/16/2019/03/spa-fetch-data.png&quot; alt=&quot;SPA fetch data&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;保护现有的API&lt;/h2&gt;
&lt;p&gt;要保护服务器上的API，只需要在要保护的控制器或操作上使用[Authorize]属性。&lt;/p&gt;
&lt;div class=&quot;csharpcode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   1:  &lt;/span&gt;[Authorize]
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   2:  &lt;/span&gt;[Route(&lt;span class=&quot;str&quot;&gt;&quot;api/[controller]&quot;&lt;/span&gt;)]
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   3:  &lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;class&lt;/span&gt; SampleDataController : Controller
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   4:  &lt;/span&gt;{
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   5:  &lt;/span&gt;...
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   6:  &lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;客户端路径认证&lt;/h2&gt;
&lt;p&gt;为了在Angular应用程序访问页面时，要求对用户进行身份验证，我们将[AuthorizeGuard]应用到正在配置的路由上。&lt;/p&gt;
&lt;div class=&quot;csharpcode&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   1:  &lt;/span&gt;import { ApiAuthorizationModule } from &lt;span class=&quot;str&quot;&gt;'src/api-authorization/api-authorization.module'&lt;/span&gt;;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   2:  &lt;/span&gt;import { AuthorizeGuard } from &lt;span class=&quot;str&quot;&gt;'src/api-authorization/authorize.guard'&lt;/span&gt;;
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   3:  &lt;/span&gt;import { AuthorizeInterceptor } from &lt;span class=&quot;str&quot;&gt;'src/api-authorization/authorize.interceptor'&lt;/span&gt;;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   4:  &lt;/span&gt; 
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   5:  &lt;/span&gt;@NgModule({
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   6:  &lt;/span&gt;  declarations: [
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   7:  &lt;/span&gt;    AppComponent,
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   8:  &lt;/span&gt;    NavMenuComponent,
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   9:  &lt;/span&gt;    HomeComponent,
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  10:  &lt;/span&gt;    CounterComponent,
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  11:  &lt;/span&gt;    FetchDataComponent
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  12:  &lt;/span&gt;  ],
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  13:  &lt;/span&gt;  imports: [
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  14:  &lt;/span&gt;    BrowserModule.withServerTransition({ appId: &lt;span class=&quot;str&quot;&gt;'ng-cli-universal'&lt;/span&gt; }),
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  15:  &lt;/span&gt;    HttpClientModule,
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  16:  &lt;/span&gt;    FormsModule,
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  17:  &lt;/span&gt;    ApiAuthorizationModule,
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  18:  &lt;/span&gt;    RouterModule.forRoot([
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  19:  &lt;/span&gt;      { path: &lt;span class=&quot;str&quot;&gt;''&lt;/span&gt;, component: HomeComponent, pathMatch: &lt;span class=&quot;str&quot;&gt;'full'&lt;/span&gt; },
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  20:  &lt;/span&gt;      { path: &lt;span class=&quot;str&quot;&gt;'counter'&lt;/span&gt;, component: CounterComponent },
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  21:  &lt;/span&gt;      { path: &lt;span class=&quot;str&quot;&gt;'fetch-data'&lt;/span&gt;, component: FetchDataComponent, canActivate: [AuthorizeGuard] },
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  22:  &lt;/span&gt;    ])
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  23:  &lt;/span&gt;  ],
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  24:  &lt;/span&gt;  providers: [
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  25:  &lt;/span&gt;    { provide: HTTP_INTERCEPTORS, useClass: AuthorizeInterceptor, multi: &lt;span class=&quot;kwrd&quot;&gt;true&lt;/span&gt; }
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  26:  &lt;/span&gt;  ],
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  27:  &lt;/span&gt;  bootstrap: [AppComponent]
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  28:  &lt;/span&gt;})
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  29:  &lt;/span&gt;export &lt;span class=&quot;kwrd&quot;&gt;class&lt;/span&gt; AppModule { }
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;带有SignalR Hubs的Endpoint路由&lt;/h2&gt;
&lt;p&gt;在preview3中，我们将SignalR hubs连接到最近发布的新端点路由特性中。SignalR hub连线之前已经明确完成:&lt;/p&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   1:  &lt;/span&gt;app.UseSignalR(routes =&amp;gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   2:  &lt;/span&gt;{
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   3:  &lt;/span&gt;    routes.MapHub&amp;lt;ChatHub&amp;gt;(&lt;span class=&quot;str&quot;&gt;&quot;hubs/chat&quot;&lt;/span&gt;);
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   4:  &lt;/span&gt;});
&lt;/pre&gt;
&lt;p&gt;这意味着开发人员需要在启动期间将控制器、Razor页面和hubs连接到不同的位置，从而产生一系列几乎相同的路由片段:&lt;/p&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   1:  &lt;/span&gt;app.UseSignalR(routes =&amp;gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   2:  &lt;/span&gt;{
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   3:  &lt;/span&gt;    routes.MapHub&amp;lt;ChatHub&amp;gt;(&lt;span class=&quot;str&quot;&gt;&quot;hubs/chat&quot;&lt;/span&gt;);
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   4:  &lt;/span&gt;});
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   5:  &lt;/span&gt; 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   6:  &lt;/span&gt;app.UseRouting(routes =&amp;gt;
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   7:  &lt;/span&gt;{
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   8:  &lt;/span&gt;    routes.MapRazorPages();
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   9:  &lt;/span&gt;});
&lt;/pre&gt;
&lt;p&gt;现在，SignalR hub也可以通过endpoint路由进行路由分发，因此您可以在ASP.NET Core中一站式地路由几乎所有内容。&lt;/p&gt;
&lt;div class=&quot;csharpcode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   1:  &lt;/span&gt;app.UseRouting(routes =&amp;gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   2:  &lt;/span&gt;{
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   3:  &lt;/span&gt;    routes.MapRazorPages();
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   4:  &lt;/span&gt;    routes.MapHub&amp;lt;ChatHub&amp;gt;(&lt;span class=&quot;str&quot;&gt;&quot;hubs/chat&quot;&lt;/span&gt;);
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   5:  &lt;/span&gt;});
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Java SignalR客户端的长轮询&lt;/h2&gt;
&lt;p&gt;我们向Java客户端添加了长轮询支持，这使它能够在不支持WebSockets的环境中建立连接。这也使您能够在客户端应用程序中专门选择长轮询传输。&lt;/p&gt;
&lt;h2&gt;gRPC 模板&lt;/h2&gt;
&lt;p&gt;这个预览版引入了一个用ASP.NET Core构建的gRPC服务的新模板。NET Core使用一个新的gRPC框架，我们正在与谷歌合作构建。&lt;/p&gt;
&lt;p&gt;gRPC是一个流行的RPC(远程过程调用)框架，它为API开发提供了一种固定的契约优先方法。它使用HTTP/2进行传输，协议缓冲区作为接口描述语言，并提供诸如身份验证、双向流和流控制、取消和超时等功能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://devblogs.microsoft.com/aspnet/wp-content/uploads/sites/16/2019/03/grpc-service.png&quot; alt=&quot;gRPC template&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这些模板创建了两个项目:一个是托管于ASP. NET Core中的gRPC服务，以及一个用于测试它的控制台应用程序。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://devblogs.microsoft.com/aspnet/wp-content/uploads/sites/16/2019/03/grpc-templatepng.png&quot; alt=&quot;gRPC solution&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是第一个为ASP.NET Core公开发布的gRPC预览，并没有实现gRPC的所有功能，但是我们正在努力使ASP.NET Core提供所提供得最佳的gRPC体验成为可能。请尝试一下，并在GitHub上的&lt;a href=&quot;https://github.com/grpc/grpc-dotnet/issues&quot;&gt;grpc/grpc-dotnet&lt;/a&gt;上给我们反馈。&lt;/p&gt;
&lt;p&gt;未来将会有更详细地讨论ASP.NET Core使用gRPC的博客文章，请继续关注。&lt;/p&gt;
&lt;h2&gt;反馈&lt;/h2&gt;
&lt;p&gt;我们希望您喜欢这个预览版的ASP.NET Core中的新功能！请通过在Github上提交问题让我们知道你的想法。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;原文地址：&lt;a href=&quot;https://devblogs.microsoft.com/aspnet/asp-net-core-updates-in-net-core-3-0-preview-3/&quot;&gt;https://devblogs.microsoft.com/aspnet/asp-net-core-updates-in-net-core-3-0-preview-3/&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 15 Apr 2019 15:23:00 +0000</pubDate>
<dc:creator>艾心❤</dc:creator>
<og:description>.NET Core 3.0 Preview 3已经推出，它包含了一系列关于ASP.NET Core的新的更新。 下面是该预览版的更新列表： Razor组件改进: 单项目模板 新的Razer扩展 End</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/edison0621/p/10714069.html</dc:identifier>
</item>
<item>
<title>[Python]可变类型，默认参数与学弟的困惑 - Magic激流</title>
<link>http://www.cnblogs.com/magicxyx/p/10714072.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/magicxyx/p/10714072.html</guid>
<description>&lt;p&gt;    十天前一个夜阑人静、月明星稀的夜晚，我和我的朋友们正在学校东门的小餐馆里吃着方圆3里内最美味的牛蛙，唱着最好听的歌儿，畅聊人生的意义。突然，我的手机一震，气氛瞬间就安静下来，看着牛蛙碗里三双贪婪的筷子，我犹豫了：不——我的肉…但是本着不让人久等的原则，我不舍地放下了筷子。点亮屏幕，我的眉头不禁紧锁，事情好像并不简单…&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1219242/201904/1219242-20190415231907398-1894288055.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    什么，还上升到了去医院的程度？现在的年轻人怎么了，怎么那么不注意安全，嗨，真是一届不如一届了，不过也好，没受伤就好…正当我沉浸在我自己的瞎想时，一张图片紧接着医院那条发了过来…嗯？好熟悉的图！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1219242/201904/1219242-20190415231907759-479849751.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;    嗯…，这不是PyCharm嘛…原来是Python…啊不，我的牛蛙…当我还在想这会是个啥问题时，学弟发出了追问三连：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1219242/201904/1219242-20190415231908038-162091257.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    我是谁？我从哪里来？我的牛蛙怎么没了？&lt;/p&gt;
&lt;p&gt;    右手无意思地点开了那张承载着学弟追问三连的图，我倒要看看，什么问题耽误了我吃肉的最佳时机。&lt;/p&gt;
&lt;p&gt;    忽略学弟那莫名其妙的文件命名，以及那三位数的行数，学弟的问题由六行代码引出：&lt;/p&gt;
&lt;ol readability=&quot;3.5&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;def&lt;/strong&gt;&lt;span&gt; li_si(a,ls=[]):  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    ls.append(a)  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;return&lt;/strong&gt;&lt;span&gt; ls  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;print&lt;/strong&gt;&lt;span&gt;(li_si(7))  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;print&lt;/strong&gt;&lt;span&gt;(li_si(15))  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;print&lt;/strong&gt;&lt;span&gt;(li_si(45,[1,5,7]))  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;print&lt;/strong&gt;&lt;span&gt;(li_si(78))  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;一个函数，两个参数，其中一个是默认的空列表，函数里，列表对第一个参数执行append操作，返回列表。&lt;/p&gt;
&lt;p&gt;四个print()，每个print()的参数是一个函数调用，第一二四个函数调用只有一个参数，第二个参数使用的默认值。&lt;/p&gt;
&lt;p&gt;这会有啥问题？结果是显而易见的嘛。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1219242/201904/1219242-20190415231908229-1635706225.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看来学弟进度有点慢啊。这么基础的知识，怎么会扯上这么多，什么&quot;局部变量&quot;，什么&quot;全局变量&quot;，还有&quot;参数&quot;之类，引得我嘴角上扬，感觉空气中充满了快活的空气。&lt;/p&gt;
&lt;p&gt;我夹起了一块牛蛙肉，真香。&lt;/p&gt;
&lt;p&gt;瞄了一眼程序的输出结果，瞳孔瞬间放大。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1219242/201904/1219242-20190415231908514-288225711.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;          不好，有诈！我仿佛听到一声惊雷，右手一抖，我的牛蛙掉到了大白菜汤里，啊，牛蛙，你还是想回家啊。&lt;/p&gt;
&lt;p&gt;          哈哈，顾不得牛蛙了，看来学弟提了一个好问题，C语言里那一套规则似乎不起作用了。&lt;/p&gt;
&lt;p&gt;          放下筷子，虔诚的拿起了可以打开未知世界大门的手机，思绪进入计算机世界，这几行代码在执行时，到底发生了什么。&lt;/p&gt;

&lt;p&gt;    当编译器遇到一个函数调用时，它产生代码传递参数并调用函数。C语言里所有的参数均以&quot;传值调用&quot;方式传递，而对于数组参数，传递的则是常量指针(数组)的拷贝。每次函数调用时，被调用的函数都有自己独有的栈空间，里面存储了函数的参数、局部变量等信息，函数返回后，栈空间被释放。&lt;/p&gt;
&lt;p&gt;    而Python的解释器是用C写的，Python里的list底层就是C语言的可变数组，就是一个指针。&lt;/p&gt;
&lt;p&gt;    基于这种认知，我设想的运行结果应该是，第一二四个函数使用的默认参数list，每次调用时，默认参数都回有一个值，这个值是不确定的(后面会提到，在Python里，可变类型竟然还真是确定的)，所以每次调用时默认参数都(应该)指向空的数组，结果应该就是返回只有a一个元素的列表。&lt;/p&gt;
&lt;p&gt;    但是现在运行结果显示，这三次函数调用时似乎指向了同一个列表，这就奇怪了。&lt;/p&gt;

&lt;p&gt;    本身应该是局部变量的参数，运行时却有了全局变量的效果(我终于还是提到了学弟问的那几个词…)，看着代码，我有了这样几个猜测…&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1219242/201904/1219242-20190415231908789-62724600.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;猜想1：&lt;/strong&gt; 学弟这几行代码所在行数为106-112，有没有可能在之前的代码中，ls已经被定义过了，所以在后面的代码中，全局的ls覆盖了局部的ls，造成了这种参数全局的效果。&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;猜想2：&lt;/strong&gt; 现在我也好奇当时我为嘛会想到这个…这解释器怎么可能会跨行优化这种…可能是被牛蛙冲昏了头脑。&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;猜想3：&lt;/strong&gt; 这个我做过实验，对同一个函数多次调用，每次函数局部变量的地址都相同。所以我怀疑，默认参数所在内存区域的值，一直没被修改，所以每次都一样。不过这样就有了一个悖论，第三次函数调用没有使用默认的参数，内存区域的值理应被修改，但是第四次调用时又回到了前两种情况。&lt;/p&gt;

&lt;p&gt;    回到学校后，终于有机会能实际跑跑这奇怪的代码了，毕竟脑子不能编译、解释代码，还是要上机。&lt;/p&gt;
&lt;p&gt;    首先，直接跑这7行代码，看看结果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1219242/201904/1219242-20190415231909105-525244822.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    嗯，和学弟的结果一样，可以排除含有全局变量的情况1了。&lt;/p&gt;
&lt;p&gt;    看看每次函数调用时默认参数的值与地址。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1219242/201904/1219242-20190415231909400-566365870.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    这结果部分地验证了猜想3，每次使用默认参数时都指向了同一个地址。&lt;/p&gt;
&lt;p&gt;换一下，默认参数改为一个数字，这不会还指同一块吧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1219242/201904/1219242-20190415231909848-1945319331.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    嗯…还指向同一块，难不成这个默认参数的值放常量池了，怎么老是指一个地儿…啊，对象，突然想起一句话，&quot;Python里万物皆为对象&quot;，这么想来，每一个数字都有自己单独的地址了。嗯，实验一下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1219242/201904/1219242-20190415231910159-168305863.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    果然，都是对象。面向对象的特性爬出了书本，以这样一种方式在我的面前刷了一波存在感。&lt;/p&gt;
&lt;p&gt;    因此，默认的参数ls，指向的也是同一个列表对象。而想要该变量指向新的列表的话，就得重新赋值。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1219242/201904/1219242-20190415231910432-1798449804.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    重新赋值后，就得到了预期的结果。&lt;/p&gt;

&lt;p&gt;    Python的内建标准类型有一种分类标准是分为可变类型与不可变类型：&lt;/p&gt;
&lt;p&gt;    变量保存的实际都是对象的引用，所以在给一个不可变类型(比如int)的变量a赋新值的时候，实际上是在内存中新建了一个对象，并讲a指向这个对象，然后将原对象的引用计数-1。&lt;/p&gt;
&lt;p&gt;    所以当函数参数是默认列表时，它始终指向同一个对象，除非重新赋值，否则它并不会重新创建一个新列表。也就是说，多次调用函数执行append操作，实际上是对同一个对象进行操作。&lt;/p&gt;


&lt;p&gt;参考：&lt;a href=&quot;https://www.cnblogs.com/Simon-xm/p/4299655.html?tdsourcetag=s_pctim_aiomsg&quot;&gt;Python——可变类型与不可变类型（即为什么函数默认参数要用元组而非列表）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;    &lt;a href=&quot;http://baijiahao.baidu.com/s?id=1602330535408996217&amp;amp;wfr=spider&amp;amp;for=pc&amp;amp;tdsourcetag=s_pctim_aiomsg&amp;amp;qq-pf-to=pcqq.c2c&quot;&gt;python之函数默认参数及注意点&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 15 Apr 2019 15:19:00 +0000</pubDate>
<dc:creator>Magic激流</dc:creator>
<og:description>一、学弟的困惑 十天前一个夜阑人静、月明星稀的夜晚，我和我的朋友们正在学校东门的小餐馆里吃着方圆3里内最美味的牛蛙，唱着最好听的歌儿，畅聊人生的意义。突然，我的手机一震，气氛瞬间就安静下来，看着牛蛙碗</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/magicxyx/p/10714072.html</dc:identifier>
</item>
<item>
<title>解决方案：如何防止数据重复插入？ - www.bysocket.com</title>
<link>http://www.cnblogs.com/Alandre/p/10714048.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Alandre/p/10714048.html</guid>
<description>&lt;p&gt;摘要: 原创出处 https://www.bysocket.com 「公众号：泥瓦匠BYSocket 」欢迎关注和转载，保留摘要，谢谢！&lt;/p&gt;
&lt;p&gt;目录&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;为啥要解决数据重复插入？&lt;/li&gt;
&lt;li&gt;解决方案实战&lt;/li&gt;
&lt;li&gt;可落地小总结&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;问题起源，微信小程序抽风 wx.request() 重复请求服务器提交数据。后端服务也很简单，伪代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java hljs&quot;&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;SignLogService {
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;saveSignLog&lt;span class=&quot;hljs-params&quot;&gt;(SignLogDO log) {
        &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;发现数据库会存在重复数据行，提交时间一模一样。但业务需求是不能有多余的 log 出现，这明显是个问题。&lt;/p&gt;
&lt;p&gt;问题是，重复请求导致的数据重复插入。这问题造成的后果很明显：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;数据冗余，可能不单单多一条&lt;/li&gt;
&lt;li&gt;有些业务需求不能有多余数据，造成服务问题&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;问题如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.bysocket.com/wp-content/uploads/2019/04/1-1.png&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;解决方式：如何将 同请求 A，不执行插入，而是读取前一个请求插入的数据并返回。解决后流程应该如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.bysocket.com/wp-content/uploads/2019/04/2-1.png&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;1.单库单表解决方案&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;唯一索引 + 唯一字段&lt;/li&gt;
&lt;li&gt;幂等&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上面说的那种业务场景：sign_log 表会有 user_id、sign_id、sign_time 等。那么每次签到，每个人每天只有一条签到记录。&lt;/p&gt;
&lt;p&gt;数据库层采取唯一索引的形式，保证数据记录唯一性。即 UNIQUE 约束，UNIQUE 约束唯一标识数据库表中的每条记录。另外，user_id,sign_id,sign_time 三个组合适唯一字段。创表的伪代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;CREATE TABLE &lt;span class=&quot;hljs-title&quot;&gt;sign_log
&lt;span class=&quot;hljs-params&quot;&gt;(
id &lt;span class=&quot;hljs-keyword&quot;&gt;int NOT NULL,
user_id &lt;span class=&quot;hljs-keyword&quot;&gt;int NOT NULL,
sign_id &lt;span class=&quot;hljs-keyword&quot;&gt;int,
sign_time &lt;span class=&quot;hljs-keyword&quot;&gt;int,
CONSTRAINT unique_sign_log UNIQUE (user_id,sign_id,sign_time)
)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重点是 &lt;code&gt;CONSTRAINT unique_sign_log UNIQUE (user_id,sign_id,sign_time)&lt;/code&gt;。有个小问题，数据量大的时候，每条记录都会有对应的唯一索引，比较耗资源。那么这样就行了吗？&lt;/p&gt;
&lt;p&gt;答案是不行，服务不够健壮。第一个请求插入成功，第二个请求直接报错，Java 服务会抛出 &lt;code&gt;DuplicateKeyException&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;简单的幂等写法操作即可，伪代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java hljs&quot;&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;SignLogService {
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public SingLogDO &lt;span class=&quot;hljs-title&quot;&gt;saveSignLog&lt;span class=&quot;hljs-params&quot;&gt;(SignLogDO log) {
        &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;的确，流量不是很大，也不算很高并发。重复写问题，这样处理即可。那大流量、高并发场景咋搞&lt;/p&gt;
&lt;h2&gt;2.分库分表解决方案&lt;/h2&gt;
&lt;p&gt;流量大了后，单库单表会演变成分库分表。那么基于单表的唯一索引形式，在碰到分表就无法保证呢，插入的地方可能是两个分表 A1 和 A2。&lt;/p&gt;
&lt;p&gt;解决思路：将数据的唯一性条件放到其他存储，并进行锁控制&lt;/p&gt;
&lt;p&gt;还是上面的例子，每天，每次签到，每个人只有一条签到记录。那么使用分布式锁 Redis 的解决方案。大致伪代码如下：&lt;/p&gt;
&lt;h3&gt;a.加锁&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java hljs&quot;/&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;lockKey 最简单的是 user_id + sign_id + sign_time&lt;/li&gt;
&lt;li&gt;expireTime 设置为一天&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;b.解锁&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java hljs&quot;/&gt;
&lt;/pre&gt;
&lt;h3&gt;c.幂等代码加强&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java hljs&quot;&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;SignLogService {
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public SingLogDO &lt;span class=&quot;hljs-title&quot;&gt;saveSignLog&lt;span class=&quot;hljs-params&quot;&gt;(SignLogDO log) {

        &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个方案还是不是很成熟，大家参考下即可。&lt;/p&gt;

&lt;p&gt;解决方案实战中，了解具体术。归纳如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;幂等：保证多次同意请求后结果一致&lt;/li&gt;
&lt;li&gt;并发控制：单表唯一索引、分布式多表分布式锁&lt;/li&gt;
&lt;li&gt;降级兜底方案：分布式锁锁失效 – 考虑乐观锁兜底&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;重复插入方案： http://www.bysocket.com/archives/2266&lt;/li&gt;
&lt;li&gt;《阿里巴巴 Java 开发手册》&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;以下专题教程也许您会有兴趣&lt;/h2&gt;
&lt;div readability=&quot;7&quot;&gt;&lt;img src=&quot;http://www.bysocket.com/wp-content/uploads/2017/01/qrcode_for_gh_cd421e7eb7d6_430.jpg&quot; alt=&quot;&quot; width=&quot;224&quot; height=&quot;224&quot;/&gt; &lt;br/&gt;（关注微信公众号，领取 Java 精选干货学习资料）&lt;/div&gt;
</description>
<pubDate>Mon, 15 Apr 2019 15:13:00 +0000</pubDate>
<dc:creator>www.bysocket.com</dc:creator>
<og:description>摘要: 原创出处 https://www.bysocket.com 「公众号：泥瓦匠BYSocket 」欢迎关注和转载，保留摘要，谢谢！ 目录 一、为啥要解决数据重复插入？ 问题起源，微信小程序抽风</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Alandre/p/10714048.html</dc:identifier>
</item>
</channel>
</rss>