<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>aspnetcore 实现简单的伪静态化 - WeihanLi</title>
<link>http://www.cnblogs.com/weihanli/p/11173915.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/weihanli/p/11173915.html</guid>
<description>&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;/h2&gt;
&lt;p&gt;在我的活动室预约项目中，有一个公告模块，类似于新闻发布，个人感觉像新闻这种网页基本就是发布的时候编辑一次之后就再也不会改了，最适合静态化了， 静态化之后用户请求的就是静态文件基本不再需要服务器端查询数据库甚至服务器端渲染，可以一定程度上提升服务器的处理能力以及优化用户体验，而且这种静态化的url对 SEO 比较友好。&lt;/p&gt;
&lt;p&gt;由于我的这个项目正在开发中，迁移起来不太方便，所以使用的是伪静态化，看上去是访问的 *.html，实际上并不是 html，而是需要服务器处理的。&lt;/p&gt;
&lt;h2 id=&quot;getstarted&quot;&gt;GetStarted&lt;/h2&gt;
&lt;p&gt;配置路由信息，注意顺序，伪静态的路由要在默认路由之前&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;app.UseMvc(routes =&amp;gt;
{
    routes.MapRoute(&quot;Notice&quot;, &quot;/Notice/{path}.html&quot;, new
    {
        controller = &quot;Home&quot;,
        action = &quot;NoticeDetails&quot;
    });

    routes.MapRoute(name: &quot;areaRoute&quot;,
        template: &quot;{area:exists}/{controller=Home}/{action=Index}&quot;);

    routes.MapRoute(
        name: &quot;default&quot;,
        template: &quot;{controller=Home}/{action=Index}&quot;);
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;控制器代码：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// 公告详情
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;path&quot;&amp;gt;访问路径&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
public async Task&amp;lt;ActionResult&amp;gt; NoticeDetails(string path)
{
    if (string.IsNullOrWhiteSpace(path))
    {
        return RedirectToAction(&quot;Notice&quot;);
    }
    try
    {
        var noticeBll = HttpContext.RequestServices.GetService&amp;lt;IBLLNotice&amp;gt;();
        var notice = await noticeBll.FetchAsync(n =&amp;gt; n.NoticeCustomPath == path.Trim());
        if (notice != null)
        {
            notice.NoticeVisitCount += 1;
            await noticeBll.UpdateAsync(notice, x =&amp;gt; x.NoticeVisitCount);

            return View(notice);
        }
        else
        {
            return RedirectToAction(&quot;Notice&quot;);
        }
    }
    catch (Exception ex)
    {
        Logger.Error(ex);
        throw;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实际效果：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://reservation.weihanli.xyz/Notice/test-notice.html&quot; class=&quot;uri&quot;&gt;https://reservation.weihanli.xyz/Notice/test-notice.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/489462/201907/489462-20190712083056242-864532905.png&quot; alt=&quot;notice details&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;qa&quot;&gt;Q&amp;amp;A&lt;/h2&gt;
&lt;p&gt;Q:为什么我们要做（伪）静态化？&lt;/p&gt;
&lt;p&gt;A:站点下的 *.html 文件有利于网站的 SEO 优化，有利于百度和google爬虫爬你的网站，SEO做的好有利于提高搜索排名【SEO的水也很深、感兴趣的可以自己找资料研究】。&lt;/p&gt;
&lt;p&gt;Q:什么是伪静态化？什么是完全静态化？他们的区别是什么？&lt;/p&gt;
&lt;p&gt;A:伪静态化是针对完全静态化来说的，（完全）静态化是会实际保存内容到一个 *.html 文件中，而伪静态化则是通过服务器端技术通过匹配 url 符合一定的模式就重新交给指定的程序处理并返回内容。&lt;/p&gt;
&lt;p&gt;简单来说，（完全）静态化会有一个实际存在的静态文件，伪静态化则不存在，需要较多服务器端的处理。&lt;/p&gt;
&lt;p&gt;Q:伪静态化和完全静态化哪个好？&lt;/p&gt;
&lt;p&gt;A:这个问题更好的问法应该是这样的：“什么时候适合用伪静态化？什么时候适合用完全静态化？”，一个事物既然存在就必然有它存在的道理，存在即合理，如果没有存在的意义必将死去。&lt;/p&gt;
&lt;p&gt;完全静态化一般会根据一个模板生成一个实际存在的 *.html 文件，完全静态化不需要太多的服务器端处理，客户端请求这个文件时因为是一个静态文件服务器会直接将文件内容返回给客户端，不需要额外的服务器处理。&lt;br/&gt;完全静态化会减少服务器的压力。&lt;/p&gt;
&lt;p&gt;伪静态化服务器上并没有静态 *.html文件，只是在服务器断使用了Rewrite，将动态URL进行重写，使动态URL表现为静态URL，以满足网页URL静态需求但网页依然为动态调用的，，是需要很多服务器端处理的，比如url的模式匹配，从数据库中查询数据。&lt;/p&gt;
&lt;p&gt;总结：虽然完全静态化URL的网页有打开速度快的优点，但是网站内容巨大的话，势必会使网站的体积变大很多，会有很多的静态化文件，网站迁移的话很麻烦，另一方面如果网站内容很多的时候修改模板的话，再次静态化的时候会是一个比较大的工作量。实际使用的话还是需要根据自己实际需要来选取。&lt;/p&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
</description>
<pubDate>Fri, 12 Jul 2019 00:32:00 +0000</pubDate>
<dc:creator>WeihanLi</dc:creator>
<og:description>aspnet core 实现简单的伪静态化</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/weihanli/p/11173915.html</dc:identifier>
</item>
<item>
<title>半年的总结和思考，继续前行 - 渡码</title>
<link>http://www.cnblogs.com/duma/p/11173476.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/duma/p/11173476.html</guid>
<description>&lt;h2&gt;小结&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;从 19 年开始决定写博客，到现在半年的时间已经在博客园写了 24 篇原创文章。虽然数量不多，基本上每周一篇的节奏，但还是有点小坚持带来的喜悦。虽然没什么人气，但积累积累也算是对自己所做的事情一个总结、思考，同时也提高一下自己的写作能力。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这半年除了每周写一篇博客，下班时间还会在知乎上做一些问答，在帮助别人的同时锻炼自己的表达、写作能力。开通了公众号但一直不知道写什么，还在慢慢探索的阶段，希望能够输出一些独一无二且有价值的内容。上半年也做了比较重要的决定，想自己写本书，以电子书的形式。基于一个开源框架的模块，把涉及到的基础知识串起来，希望会是一个精简同时又成体系、内容丰富的电子书。当然，想法总是美好的，具体执行的时候还是会比较困难，好在已经迈出了第一步，即便最后的结果没想象中那么好，也算是做了一次新的尝试。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此外，上半年也开始了新框架 —— Flink 的研究。因为我自己平时的工作中没有用到 Flink 框架，所以这块研究的时间就更少了。出过几篇最简单的教程，但是时间上跟写书严重冲突，所以最近没有更新相关的内容。但后续空出时间后还会继续更新，继续深入研究。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上下班的时间会看一些经济学、英语等其他非计算相关的内容。至于为什么看这些内容，这其实是一个边际收益的问题，因为已经在计算机专业上积累比较多的知识了， 但是在经济学上的知识几乎为零，所以同样的花10分钟的时间，在经济学上学到的东西肯定大于计算机。也就是说这时候学经济学的边际收益是大于学计算机的。所以，建议各位朋友有时间可以学学专业以外的知识，尤其是像我这样的程序员，比较宅、又不太善于社交，如果再不主动学习圈子以外的其他东西，可能视野越来越窄。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上面提到了上半年做的一些事情，如果同时做的话会是比较累的。毕竟人的精力有限的，所以应该做做减法。最开始这几件事我是同步进行的，但是发现来回切换思维栈确实挺痛苦的。所以就果断暂时放弃了 Flink 的研究，保质保量地重点完成写书的任务，等这件事接近尾声了再进行启动其他事情。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;建议各位程序员朋友，平时可以多记录自己觉得有价值的东西，写写博客。这样做的好处，一来当时解决的比较复杂的问题，如果不及时记录可能以后会忘掉，尤其面试的时候可能都记不起具体的细节了。二来，可以提升自己写作、表达的能力，也可以简历自己的技术影响力。既然谈到写作，下面就简单分享下关于环境和写作内容的一些思考。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;h2&gt;环境的重要性&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;我们想要做好自己的事情当然需要有一个良好的环境。以我写书为例，从5月中旬开始动手写，到现在大概快 2 个月了。平时下班时候会写一些，工作日大部分时间都是 10 点钟到家并且上了一天班，即便写效率也比较低。所以，主要还是靠周末。虽然周末时间充足，但消耗时间的东西也挺多，看看新闻、看看视频、玩玩游戏、跟朋友聊聊天，一天下来也写不了太多的东西。导致整体进度比较慢，自己也比较焦虑。上周末，一次偶然的机会，去了趟附近的一个书店。发现那里面的环境不错，里面提供一块比较安静的区域，有书桌、WiFi、插座，可以在里面办公、看书。可能是新环境的原因，一天下来并没有觉得做了多少事。但比自己在家做的事情要多并且时间利用上比较集中，不会特别分散，自己也能静下心思考一些东西。之前有去过咖啡厅，但是咖啡厅里比较嘈杂，并且有些咖啡厅插座比较少，网速也比较堪忧。当然也有人喜欢去公司，硬件设施相对来说更好一些，我第一份工作周末就经常一个人呆在公司写代码。但现在觉得总是呆在公司也不好。长期以来会错过很多新鲜的事儿，导致对新事物的敏感度降低。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其实环境对我们的影响挺大的。我大学时候转过专业，最开始那个专业其实并不是特别热门，所以班里的同学学习都很拼命。在那种环境下你自己不敢懈怠，你会觉得稍微放松一点就会被别人落下很远。但大二我转到计算机学院后，那个环境完全变了，周围同学大部分都玩游戏、同学经常逃课。虽然我自己学习没有懈怠（毕竟要补大一的课程），但是心态上完全变了，自己会觉得稍微多学一点就会比大部分人强。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以，对于周末想搞点事儿，但是在家静不下心的人可以尝试找个书店待一两次。我自己比较向往这种状态，在一个安静的、没人打扰的地方，没有产品、运营和测试，泡上一杯茶，给自己的需求排个期，敲着自己的代码，即便 BUG 数量呈指数级增长，心里依然乐开花。当然，也不是每个人都要那么拼命，那么努力。但我觉得哪怕一周抽半天的时间，找个安静的地方做做自己感兴趣的事，一点一点积累，时间长了可能会产生质变。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;h2&gt;关于技术输出&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;对于刚开始写作的人来说，都会有类似的问题，就是总是想写但是好像一直不知道该写什么。我刚开始写作这个问题也一直困扰我，包括现在也是。我自己的解决方法是从心态上调整，前期就是写给我自己看，因为刚开始写作没有多少人关注，所以写出的东西首先自己觉得值得记录，如果自己都觉得可有可无，那就不如不写。当然如果写的文章对别人有一点帮助，也会促进我们不断更新更好的内容。记得在阿里内部一次会议上一位大佬讲了一句话 “我们先要把自己做好，再考虑怎么去帮人家”，我觉得写作也是一样。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当不知道写什么内容的时候，可以考虑降低更新的频率，比如一周写一次。从一个时间段里寻找有意义的事，慢慢去发散，发散到一些关键的点，提炼出有价值、值得记录的东西，再慢慢地收拢、聚焦。在这方面我自己做的也不够好，也在不断地尝试中。希望能走出一条与众不同的道路。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最后，坚持输出很重要，尤其是对于刚写作的朋友。刚开始写作有了一些阅读量内心是兴奋的，然而写的东西多了但是阅读量并没有变得更多，同时又得不到读者反馈的时候，这时候就会产生懈怠的情绪，甚至放弃。出现这种情况建议采用我上面说的方式，调整下心态，坚持住。对于写作的平台方面，我自己对比过几个，感觉博客园对创作者是比较友好的，用户量比较大，没有那么多的广告干扰用户，搜索引擎收录也比较好，优质的内容可以提到首页获得足够的曝光量。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2&gt;工作&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;简单总结下这半年来工作上的一些思考。这半年，我转变最大的就是对待工作的态度，以前我总觉得呆在一个公司首先得满足我能在里面学到技术。如果纯做业务学不到技术可能就会有消极的情绪，现在这种心态已经完全转变了。我觉得公司雇我就是用钱买我的时间，至于工作好不好，愿不愿意干那是我自己选的。如果工作中能学到新技术自然是自己赚到了，如果学不到那也怨不得别人。以这样的心态来工作会更加积极、主动，不会有过多无谓的消极心态。虽然自己业务时间写书、写博客，但工作还是根本。工作做好了，才有更多的心思做自己的事。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;接下来&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;上半年做的一些主要的事情大概就总结完了。至于下半年以及未来要做的事情，我也不打算写了。因为我觉得人往往会高估短期内的目标，并且计划不如变化快，唯一确定的就是认清当前的自己，沿着自己既定的路线，一步一步扎实地走下去。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这次的文章改了好多遍才发出来，希望能够对正在阅读的你有启发。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;欢迎关注公众号&lt;strong/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1129006/201906/1129006-20190610224613682-287034495.png&quot; alt=&quot;&quot; width=&quot;162&quot; height=&quot;161&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 12 Jul 2019 00:22:00 +0000</pubDate>
<dc:creator>渡码</dc:creator>
<og:description>小结 从 19 年开始决定写博客，到现在半年的时间已经在博客园写了 24 篇原创文章。虽然数量不多，基本上每周一篇的节奏，但还是有点小坚持带来的喜悦。虽然没什么人气，但积累积累也算是对自己所做的事情一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/duma/p/11173476.html</dc:identifier>
</item>
<item>
<title>Git使用小技巧之多个远程仓库 - 代码无止境</title>
<link>http://www.cnblogs.com/endless-code/p/11173886.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/endless-code/p/11173886.html</guid>
<description>&lt;blockquote readability=&quot;3.943661971831&quot;&gt;
&lt;p&gt;想要获取更多文章可以访问我的博客 - &lt;a href=&quot;https://itweknow.cn&quot;&gt;代码无止境&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是一个普通的工作日，小代正在勤勤恳恳的写代码。这时陈BOSS走到小代身边，跟小代说：“我们的代码需要同时推送到Github和码云两个仓库，你研究一下怎么搞吧。” 乐于研究和学习的小代自然是毫不犹豫的答应了下来。&lt;/p&gt;
&lt;h3 id=&quot;准备工作&quot;&gt;准备工作&lt;/h3&gt;
&lt;p&gt;好，我们先来看下完成这篇文章的学习需要准备哪些东西。自然是一个本地的git仓库。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;mkdir git-test
cd git-test
git init
touch README.md&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行了这几行命令之后，我们还需要在Github和码云上分别新建两个远程仓库。到这里我们就有了一个和小代差不多的本地环境。下面我们就一起来看下小代是通过怎样的操作来实现陈BOSS的需求的。&lt;/p&gt;
&lt;h3 id=&quot;小代的操作&quot;&gt;小代的操作&lt;/h3&gt;
&lt;p&gt;首先小代思考的是如何在一个项目中添加两个远程仓库。经过一番搜索，小代知道了下面的命令可以给仓库添加远程仓库。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;git remote add [shortname] [url]&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;PS：我们解释一下这行命令的两个参数，第一个参数其实就是我们后面推送到这个远程仓库的时候都使用这个名称来代替仓库地址，第二个参数就是远程仓库的地址了，这句命令应该很好理解。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然后小代就在本地仓库根目录执行了下面两行命令，为本地仓库添加了两个远程仓库。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;git remote add gitee https://gitee.com/gancy/git-test.git
git remote add github https://github.com/ganchaoyang/git-test.git&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们修改README文件后，可以分别往两个仓库推送代码。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;git add *
git commit -m &quot;first commit&quot;
git push -u github master
git push -u gitee master&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过两句&lt;code&gt;git push&lt;/code&gt;命令我们确实可以向两个远程仓库推送代码，但是作为一个喜欢偷懒的程序员的小代同学绝不满足于此，于是他就想有没有一种方式可以一句命令就同时push到两个远程仓库。于是乎就有了下面的操作。小代修改了.git/config文件中的内容。原文件内容如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[core]
    repositoryformatversion = 0
    filemode = false
    bare = false
    logallrefupdates = true
    symlinks = false
    ignorecase = true
[remote &quot;gitee&quot;]
    url = https://gitee.com/gancy/git-test.git
    fetch = +refs/heads/*:refs/remotes/gitee/*
[remote &quot;github&quot;]
    url = https://github.com/ganchaoyang/git-test.git
    fetch = +refs/heads/*:refs/remotes/github/*
[branch &quot;master&quot;]
    remote = gitee
    merge = refs/heads/master&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改后的内容为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[core]
    repositoryformatversion = 0
    filemode = false
    bare = false
    logallrefupdates = true
    symlinks = false
    ignorecase = true
[remote &quot;origin&quot;]
    url = https://gitee.com/gancy/git-test.git
    url = https://github.com/ganchaoyang/git-test.git
    fetch = +refs/heads/*:refs/remotes/origin/*
[branch &quot;master&quot;]
    remote = origin
    merge = refs/heads/master&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;只是将两个&lt;code&gt;remote&lt;/code&gt;合并成了一个而已，然后再执行&lt;code&gt;git push&lt;/code&gt;命令就会发现，会一次性向两个仓库&lt;code&gt;push&lt;/code&gt;代码了。然后，小代同学就下班回家吃饭了。&lt;/p&gt;
&lt;h3 id=&quot;结束语&quot;&gt;结束语&lt;/h3&gt;
&lt;p&gt;这篇文章，主要是讲了如何同时向多个远程仓库推送代码。虽然平时使用场景不多，但是偶尔遇到了这样的需求还是很实用的。如果你喜欢我的文章，可以扫描下方二维码关注&lt;strong&gt;代码无止境&lt;/strong&gt;公众号。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/18399325-05b9f0239ccb1fbc.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;扫码关注“代码无止境”&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 12 Jul 2019 00:06:00 +0000</pubDate>
<dc:creator>代码无止境</dc:creator>
<og:description>想要获取更多文章可以访问我的博客 '代码无止境' 。 这是一个普通的工作日，小代正在勤勤恳恳的写代码。这时陈BOSS走到小代身边，跟小代说：“我们的代码需要同时推送到Github和码云两个仓库，你研究</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/endless-code/p/11173886.html</dc:identifier>
</item>
<item>
<title>C#8.0: 在 LINQ 中支持异步的 IAsyncEnumerable - yan_xiaodi</title>
<link>http://www.cnblogs.com/yanxiaodi/p/Support-IAsyncEnumerable-with-LINQ.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yanxiaodi/p/Support-IAsyncEnumerable-with-LINQ.html</guid>
<description>&lt;p&gt;C# 8.0中，提供了一种新的&lt;code&gt;IAsyncEnumerable&amp;lt;T&amp;gt;&lt;/code&gt;接口，在对集合进行迭代时，支持异步操作。比如在读取文本中的多行字符串时，如果读取每行字符串的时候使用同步方法，那么会导致线程堵塞。&lt;code&gt;IAsyncEnumerable&amp;lt;T&amp;gt;&lt;/code&gt;可以解决这种情况，在迭代的时候支持使用异步方法。也就是说，之前我们使用&lt;code&gt;foreach&lt;/code&gt;来对&lt;code&gt;IEnumerable&lt;/code&gt;进行迭代，现在可以使用&lt;code&gt;await foreach&lt;/code&gt;来对&lt;code&gt;IAsyncEnumerable&amp;lt;T&amp;gt;&lt;/code&gt;进行迭代，每个项都是可等待的。这种新的接口称为&lt;code&gt;async-streams&lt;/code&gt;，将会随&lt;code&gt;.NET Core 3&lt;/code&gt;发布。我们来看一下如何在&lt;code&gt;LINQ&lt;/code&gt;中实现异步的迭代。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;使用常规的&lt;span&gt;&lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;首先我们创建一个新的&lt;span&gt;&lt;code&gt;Console&lt;/code&gt;&lt;span&gt;项目，基于&lt;span&gt;&lt;code&gt;.NET Core 3&lt;/code&gt;&lt;span&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; AsyncLinqDemo
{
   &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
  {
       &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
      {
           Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Input the file path:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
           &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; file =&lt;span&gt; Console.ReadLine();
           &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; lines =&lt;span&gt; ReadAllLines(file);
           &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; line &lt;span&gt;in&lt;/span&gt;&lt;span&gt; lines)
          {
               Console.WriteLine(line);
          }
      }

       &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; IEnumerable&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; ReadAllLines(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; file)
      {
           &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; fs =&lt;span&gt; File.OpenRead(file))
          {
               &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; sr = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StreamReader(fs))
              {
                   &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
                  {
                       &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; line =&lt;span&gt; sr.ReadLine();
                       &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(line == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                      {
                           &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                      }
                       &lt;/span&gt;&lt;span&gt;yield&lt;/span&gt; &lt;span&gt;return&lt;/span&gt;&lt;span&gt; line;
                  }
              }
          }
      }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;这是一个很简单的Console程序，实现了一个简单的返回类型为&lt;span&gt;&lt;code&gt;IEnumerable&amp;lt;string&amp;gt;&lt;/code&gt;&lt;span&gt;的&lt;span&gt;&lt;code&gt;ReadAllLines(string file)&lt;/code&gt;&lt;span&gt;方法，从文本文件中逐行读取文本，并逐行输出。如果文本内容较少的话，没什么问题。但如果我们使用过&lt;span&gt;&lt;code&gt;aync/await&lt;/code&gt;&lt;span&gt;，就会了解，在IO操作如读取或写入文件的时候，最好使用异步方法以避免线程阻塞。让我们来改进一下。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;使用异步的&lt;span&gt;&lt;code&gt;IAsyncEnumerable&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;可以优化的是下面这句：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;string&lt;/span&gt; line = sr.ReadLine();
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;对于IO操作，最好使用异步方式。这里可使用相应的异步方法：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;string&lt;/span&gt; line = &lt;span&gt;await&lt;/span&gt; sr.ReadLineAsync();
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;我们说“异步是传染的”，如果这里使用异步，那么相应的该方法的返回值也要使用异步，所以需要将返回值改为&lt;span&gt;&lt;code&gt;static async Task&amp;lt;IEnumerable&amp;lt;string&amp;gt;&amp;gt;&lt;/code&gt;&lt;span&gt;，但这样会得到一个错误：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
ErrorCS1624The body of &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Program.ReadAllLines(string)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; cannot be an iterator block because &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Task&amp;lt;IEnumerable&amp;lt;string&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; is not an iterator interface typeAsyncLinqDemoC:\Source\Workspaces\Console\AsyncLinqDemo\AsyncLinqDemo\Program.cs23Active
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;因为&lt;span&gt;&lt;code&gt;Task&amp;lt;IEnumerable&amp;lt;string&amp;gt;&amp;gt;&lt;/code&gt;&lt;span&gt;并不是一个可以迭代的接口类型，所以我们无法在方法内部使用&lt;span&gt;&lt;code&gt;yield&lt;/code&gt;&lt;span&gt;关键字。解决问题的办法是使用新的&lt;span&gt;&lt;code&gt;IAsyncEnumerable&lt;/code&gt;&lt;span&gt;接口：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
static async IAsyncEnumerable&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; ReadAllLines(&lt;span&gt;string&lt;/span&gt; &lt;span&gt;file&lt;/span&gt;&lt;span&gt;)
{
   using (var fs &lt;/span&gt;= File.OpenRead(&lt;span&gt;file&lt;/span&gt;&lt;span&gt;))
  {
       using (var sr &lt;/span&gt;=&lt;span&gt; new StreamReader(fs))
      {
           &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
          {
               &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; line =&lt;span&gt; await sr.ReadLineAsync();
               &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(line == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
              {
                   break;
              }
               yield return line;
          }

      }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;按&lt;span&gt;&lt;code&gt;F12&lt;/code&gt;&lt;span&gt;查看该接口的定义：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace System.Collections.Generic
{
   public interface IAsyncEnumerable&lt;/span&gt;&amp;lt;out T&amp;gt;&lt;span&gt;
  {
       IAsyncEnumerator&lt;/span&gt;&amp;lt;T&amp;gt; GetAsyncEnumerator(CancellationTokencancellationToken =&lt;span&gt; default);
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;这是一个异步的迭代器，并提供了&lt;span&gt;&lt;code&gt;CancellationToken&lt;/code&gt;&lt;span&gt;。再按&lt;span&gt;&lt;code&gt;F12&lt;/code&gt;&lt;span&gt;查看&lt;span&gt;&lt;code&gt;IAsyncEnumerator&amp;lt;T&amp;gt;&lt;/code&gt;&lt;span&gt;的定义，可发现里面是这样的：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace System.Collections.Generic
{
   public interface IAsyncEnumerator&lt;/span&gt;&amp;lt;out T&amp;gt;&lt;span&gt; : IAsyncDisposable
  {
       T Current { get; }
       ValueTask&lt;/span&gt;&amp;lt;&lt;span&gt;bool&lt;/span&gt;&amp;gt;&lt;span&gt; MoveNextAsync();
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;这里&lt;span&gt;&lt;code&gt;MoveNextAsync()&lt;/code&gt;&lt;span&gt;方法实际是返回了一个结果类型为&lt;span&gt;&lt;code&gt;bool&lt;/code&gt;&lt;span&gt;的&lt;span&gt;&lt;code&gt;Task&lt;/code&gt;&lt;span&gt;，每次迭代都是可等待的，从而实现了迭代器的异步。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;使用&lt;span&gt;&lt;code&gt;await foreach&lt;/code&gt;&lt;span&gt;消费&lt;span&gt;&lt;code&gt;IAsyncEnumerable&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;当我们做了以上改动之后，&lt;span&gt;&lt;code&gt;ReadAllLines()&lt;/code&gt;&lt;span&gt;方法返回的是一个支持异步的&lt;span&gt;&lt;code&gt;IAsyncEnumerable&lt;/code&gt;&lt;span&gt;，那么在使用的时候，也不能简单的使用&lt;span&gt;&lt;code&gt;foreach&lt;/code&gt;&lt;span&gt;了。修改&lt;span&gt;&lt;code&gt;Main&lt;/code&gt;&lt;span&gt;方法如下：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
static async Task Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
{
   Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Input the file path:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
   var &lt;/span&gt;&lt;span&gt;file&lt;/span&gt; =&lt;span&gt; Console.ReadLine();
   var lines &lt;/span&gt;= ReadAllLines(&lt;span&gt;file&lt;/span&gt;&lt;span&gt;);
   await foreach (var line &lt;/span&gt;&lt;span&gt;in&lt;/span&gt;&lt;span&gt; lines)
  {
       Console.WriteLine(line);
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;首先在&lt;span&gt;&lt;code&gt;foreach&lt;/code&gt;&lt;span&gt;之前添加&lt;span&gt;&lt;code&gt;await&lt;/code&gt;&lt;span&gt;关键字，还要需要将&lt;span&gt;&lt;code&gt;Main&lt;/code&gt;&lt;span&gt;方法由&lt;span&gt;&lt;code&gt;void&lt;/code&gt;&lt;span&gt;改为&lt;span&gt;&lt;code&gt;async Task&lt;/code&gt;&lt;span&gt;。这样整个程序都是异步执行了，不会再导致堵塞了。这个例子只是一个简单的demo，是否使用异步并不会感觉到明显的区别。如果在迭代内部需要比较重的操作，如从网络获取大量数据或读取大量磁盘文件，异步的优势还是会比较明显的。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;使用&lt;span&gt;&lt;code&gt;LINQ&lt;/code&gt;&lt;span&gt;消费&lt;span&gt;&lt;code&gt;IAsyncEnumerable&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;使用&lt;span&gt;&lt;code&gt;LINQ&lt;/code&gt;&lt;span&gt;来操作集合是常用的功能。如果使用&lt;span&gt;&lt;code&gt;IEnumberable&lt;/code&gt;&lt;span&gt;，在&lt;span&gt;&lt;code&gt;Main&lt;/code&gt;&lt;span&gt;方法中可以做如下改动：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
var lines = ReadAllLines(&lt;span&gt;file&lt;/span&gt;&lt;span&gt;);
var res &lt;/span&gt;= from line &lt;span&gt;in&lt;/span&gt; lines where line.StartsWith(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ERROR: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) selectline.Substring(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ERROR: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.Length);
foreach (var line &lt;/span&gt;&lt;span&gt;in&lt;/span&gt;&lt;span&gt; res)
{
   Console.WriteLine(line);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;或：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
var res = lines.Where(x =&amp;gt; x.StartsWith(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ERROR: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)).Select(x =&amp;gt; x.Substring(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ERROR: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;.Length));
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;如果使用了新的&lt;span&gt;&lt;code&gt;IAsyncEnumerable&lt;/code&gt;&lt;span&gt;，你会发现无法使用&lt;span&gt;&lt;code&gt;Where&lt;/code&gt;&lt;span&gt;等操作符了：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
ErrorCS1936Could not &lt;span&gt;find&lt;/span&gt; an implementation of the query pattern &lt;span&gt;for&lt;/span&gt; source type &lt;span&gt;'&lt;/span&gt;&lt;span&gt;IAsyncEnumerable&amp;lt;string&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;. &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Where&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; not found.AsyncLinqDemoC:\Source\Workspaces\Console\AsyncLinqDemo\AsyncLinqDemo\Program.cs16Active
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;目前&lt;span&gt;&lt;code&gt;LINQ&lt;/code&gt;&lt;span&gt;还没有提供对&lt;span&gt;&lt;code&gt;IAsyncEnumerable&lt;/code&gt;&lt;span&gt;的原生支持，不过微软提供了一个Nuget包来实现此功能。在项目中打开Nuget Package Manger搜索安装&lt;span&gt;&lt;code&gt;System.Linq.Async&lt;/code&gt;&lt;span&gt;，注意该包目前还是预览版，所以要勾选&lt;span&gt;&lt;code&gt;include prerelease&lt;/code&gt;&lt;span&gt;才能看到。安装该Nuget包后，Linq查询语句中的错误就消失了。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在&lt;span&gt;&lt;code&gt;System.Linq.Async&lt;/code&gt;&lt;span&gt;这个包中，对每个同步的&lt;span&gt;&lt;code&gt;LINQ&lt;/code&gt;&lt;span&gt;方法都做了相应的扩展。所以基本上代码无需什么改动即可正常编译。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于&lt;span&gt;&lt;code&gt;LINQ&lt;/code&gt;&lt;span&gt;中的条件语句，也可以使用&lt;span&gt;&lt;code&gt;WhereAwait()&lt;/code&gt;&lt;span&gt;方法来支持&lt;span&gt;&lt;code&gt;await&lt;/code&gt;&lt;span&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
public static IAsyncEnumerable&amp;lt;TSource&amp;gt; WhereAwait&amp;lt;TSource&amp;gt;(thisIAsyncEnumerable&amp;lt;TSource&amp;gt; source, Func&amp;lt;TSource, &lt;span&gt;int&lt;/span&gt;, ValueTask&amp;lt;&lt;span&gt;bool&lt;/span&gt;&amp;gt;&amp;gt;predicate);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;如需要在条件语句中进行IO或网络请求等异步操作，可以这样用：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
var res = lines.WhereAwait(async x =&amp;gt; await DoSomeHeavyOperationsAsync(x));
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;code&gt;DoSomeHeavyOperationsAsync&lt;/code&gt;&lt;span&gt;方法的签名如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
private static ValueTask&amp;lt;&lt;span&gt;bool&lt;/span&gt;&amp;gt; DoSomeHeavyOperationsAsync(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; x)
{
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Do some works...&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;span&gt;小结&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;通过以上的示例，我们简要了解了如何使用&lt;span&gt;&lt;code&gt;IAsyncEnumerable&lt;/code&gt;&lt;span&gt;接口以及如何在&lt;span&gt;&lt;code&gt;LINQ&lt;/code&gt;&lt;span&gt;中实现异步查询。在使用该接口时，我们需要创建一个自定义方法返回&lt;span&gt;&lt;code&gt;IAsyncEnumerable&amp;lt;T&amp;gt;&lt;/code&gt;&lt;span&gt;来代替&lt;span&gt;&lt;code&gt;IEnumberable&amp;lt;T&amp;gt;&lt;/code&gt;&lt;span&gt;，这个方法可称为&lt;span&gt;&lt;code&gt;async-iterator&lt;/code&gt;&lt;span&gt;方法，需要注意以下几点：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; data-mark=&quot;*&quot; readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;该方法应该被声明为&lt;span&gt;&lt;code&gt;async&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;返回&lt;span&gt;&lt;code&gt;IAsyncEnumerable&amp;lt;T&amp;gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;同时使用&lt;span&gt;&lt;code&gt;await&lt;/code&gt;&lt;span&gt;及&lt;span&gt;&lt;code&gt;yield&lt;/code&gt;&lt;span&gt;。如&lt;span&gt;&lt;code&gt;await foreach&lt;/code&gt;&lt;span&gt;，&lt;span&gt;&lt;code&gt;yield return&lt;/code&gt;&lt;span&gt;或&lt;span&gt;&lt;code&gt;yield break&lt;/code&gt;&lt;span&gt;等。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;例如：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
async IAsyncEnumerable&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt; GetValuesFromServer()
{
   &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
  {
       IEnumerable&lt;/span&gt;&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; batch =&lt;span&gt; await GetNextBatch();
       &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (batch == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) yield break;

       foreach (&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; batch)
      {
           yield return item;
      }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;此外还有一些限制：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;期待.NET Core 3的正式发布！&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ahAATVIdckRjwCicQictHicK9Ebav2YbXIiblyZ45Q7n50Jv20xzXsj94fueJ8SQcL1ZQibEZLKs1p55kzQiaBFyMDBQ/640?wx_fmt=jpeg&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; width=&quot;287&quot; height=&quot;196&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.6822074215033301&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;1051&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ahAATVIdckRjwCicQictHicK9Ebav2YbXIiblyZ45Q7n50Jv20xzXsj94fueJ8SQcL1ZQibEZLKs1p55kzQiaBFyMDBQ/640?wx_fmt=jpeg&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;p&gt;了解新西兰IT行业真实码农生活&lt;/p&gt;
&lt;p&gt;请长按上方二维码关注“程序员在新西兰”&lt;/p&gt;
</description>
<pubDate>Thu, 11 Jul 2019 22:44:00 +0000</pubDate>
<dc:creator>yan_xiaodi</dc:creator>
<og:description>C# 8.0中，提供了一种新的IAsyncEnumerable&lt;T&gt;接口，在对集合进行迭代时，支持异步操作。比如在读取文本中的多行字符串时，如果读取每行字符串的时候使用同步方法，那么会导致</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yanxiaodi/p/Support-IAsyncEnumerable-with-LINQ.html</dc:identifier>
</item>
<item>
<title>自动化冒烟测试 Unittest , Pytest 哪家强？ - 深圳-逸遥</title>
<link>http://www.cnblogs.com/snailrunning/p/11173728.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/snailrunning/p/11173728.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;前言：之前有一段时间一直用 Python Uittest做自动化测试，觉得Uittest组织冒烟用例比较繁琐，后来康哥提示我使用pytest.mark来组织冒烟用例&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文讲述以下几个内容：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;1、Unittest 如何组织冒烟用例&lt;br/&gt;2、Pytest 组织冒烟测试&lt;br/&gt;3、Pytest 执行unittest冒烟用例&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;环境准备：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Python 3.64&lt;br/&gt;Pytest 5.01&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;项目目录：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;smoke_testing_demo
        test_case
            __init__.py
            test_case_with_unittest.py
            test_case_with_pytest.py
        run_unittest_smoke_testing.py&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;一unittest如何组织冒烟用例&quot;&gt;一、Unittest如何组织冒烟用例&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;当 import unittest 时 ，会自动导入TestLoader类&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;TestLoader这个类下，封装了 5 种组织用例的方法&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;本文主要讲解 loadTestsFromNames&lt;/li&gt;
&lt;li&gt;更多Uittest组织用例方法可参考《Unittest组织用例的姿势》这篇博文，链接在文末&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;loadtestsfromnames-方法简介&quot;&gt;loadTestsFromNames 方法简介&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;$ loader.py 该文件在python3.7已不存在，建议使用python3.64 查看使用方法

class TestLoader(object):
    &quot;&quot;&quot;
    该类负责根据各种标准加载测试并将它们包装在TestSuite中
    &quot;&quot;&quot;
    
    def loadTestsFromNames(self, names, module=None):
    &quot;&quot;&quot;
    返回给定的一组用例名的测试用例的套件
    &quot;&quot;&quot;    &lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;loadtestsfromnames-组织冒烟用例&quot;&gt;loadTestsFromNames 组织冒烟用例&lt;/h4&gt;
&lt;p&gt;测试用例&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ test_case_with_unittest.py

#!/usr/bin/env python3
# encoding:utf-8

import unittest

class TestUittestCase(unittest.TestCase):

    def test_case_with_unittest_1(self):
        '''冒烟测试用例'''
        print('I am Smoke Testing ')

    def test_case_with_unittest_2(self):
        pass


if __name__ == '__main__':
    unittest.main(verbosity=2)&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;pre&gt;
&lt;code&gt;$ test_case_with_unittest2.py

#!/usr/bin/env python3
# encoding:utf-8

import unittest

class TestUittestCase2(unittest.TestCase):

    def test_case_with_unittest_3(self):
        '''冒烟测试用例'''
        print('I am Smoke Testing ')

    def test_case_with_unittest_4(self):
        pass


if __name__ == '__main__':
    unittest.main(verbosity=2)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;冒烟测试用例集&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ run_unittest_smoke_testing.py

#!/usr/bin/env python3
# encoding:utf-8

import unittest

cases = [
    'test_case.test_case_with_unittest2.TestUittestCase2.test_case_with_unittest_3',
    'test_case.test_case_with_unittest.TestUittestCase.test_case_with_unittest_1'
]
test_suit = unittest.TestLoader().loadTestsFromNames(cases)
runner = unittest.TextTestRunner(verbosity=2)
runner.run(test_suit)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;test_case_with_unittest_3 (test_case.test_case_with_unittest2.TestUittestCase2)
冒烟测试 ... ok
test_case_with_unittest_1 (test_case.test_case_with_unittest.TestUittestCase)
冒烟测试 ... ok
----------------------------------------------------------------------
Ran 2 tests in 0.000s&lt;/code&gt;
&lt;/pre&gt;

&lt;h4 id=&quot;小结&quot;&gt;小结：&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;通过loadTestsFromNames 可以从不同的模块组织特定的用例集&lt;/li&gt;
&lt;li&gt;使用loadTestsFromNames这个方法,需要传入一个数组&lt;/li&gt;
&lt;li&gt;数组里面里面的元素必须是字符串&lt;/li&gt;
&lt;li&gt;数组元素传入格式：'moudleName.testCaseClassName.testCaseName'&lt;/li&gt;
&lt;li&gt;执行用例是根据数组元素的的顺序执行&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;ps: 更多通过loadTestsFromNames 使用技巧，
可以查看《Unittest组织用例的姿势》这篇博文，链接在文末&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;二pytest-组织冒烟测试&quot;&gt;二、Pytest 组织冒烟测试&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;pytest 提供了测试用例标记机制&lt;/li&gt;
&lt;li&gt;一个测试用例允许被多个@pytest.mark进行标记&lt;/li&gt;
&lt;li&gt;同一个@pytest.mark可以标记多个测试用例&lt;/li&gt;
&lt;li&gt;pytest.mark常用于冒烟测试用例组织&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;ps:更多的pytest.mark用法可以参考乙醇老师《安利一下pytest的mark用法》&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;pytest.mark-组织冒烟用例&quot;&gt;pytest.mark 组织冒烟用例&lt;/h4&gt;
&lt;p&gt;测试用例&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ run_unittest_smoke_testing.py

#!/usr/bin/env python3
# encoding:utf-8

import pytest

@pytest.mark.test_env
def test_case_1():
    pass

@pytest.mark.test_env
@pytest.mark.smoke
def test_case_2():
    ''' 冒烟用例'''
    pass&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;cd 进入 /test_case目录,&lt;br/&gt;使用命令行运行 test_case_with_pytest.py&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;pytest test_case_with_pytest.py -v -m smoke&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;collected 2 items
test_case_with_pytest.py::test_case_2 PASSED

============================== 1 tests deselected ==============================
==================== 1 passed, 1 deselected in 0.01 seconds ====================&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行被标记test_env的用例&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;pytest test_case_with_pytest.py -v -m test_env&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;collected 2 items
test_case_with_pytest.py::test_case_1 PASSED
test_case_with_pytest.py::test_case_2 PASSED
=========================== 2 passed in 0.01 seconds ===========================&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;三pytest-执行-unittest冒烟用例&quot;&gt;三、Pytest 执行 Unittest冒烟用例&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Pytest测试框架是兼容Python自带的Unittest&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;修改test_case_with_unittest2.py&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ test_case_with_unittest2.py

#!/usr/bin/env python3
# encoding:utf-8

import unittest
import pytest

class TestUittestCase2(unittest.TestCase):

    @pytest.mark.smoke                 
    def test_case_with_unittest_3(self):
        '''冒烟测试用例'''
        print('I am Smoke Testing ')

    def test_case_with_unittest_4(self):
        pass


if __name__ == '__main__':
    unittest.main(verbosity=2)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;命令行运行 test_case_with_unittest2.py&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;pytest test_case_with_unittest2.py -v -m smoke&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;collected 2 items / 1 deselected / 1 selected
test_case_with_unittest2.py::TestUittestCase2::test_case_with_unittest_3 PASSED [100%]

============== 1 passed, 1 deselected, 1 warnings in 0.01 seconds ==============&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;总结：&lt;br/&gt;1、Uittest组织冒烟用例，需通过loadTestsFromNames在不同的测试模块里指定测试用例，组装成test suit(测试套件)后，给TextTestRunner运行&lt;/p&gt;
&lt;p&gt;2、Pytest组织冒烟用例，只需给测试用例加上@pytest.mark.key ，使用命令行pytest -m key test_case.py 即可&lt;/p&gt;

&lt;h3 id=&quot;自动化冒烟测试-unittest-pytest-哪家强&quot;&gt;自动化冒烟测试 Unittest , Pytest 哪家强？&lt;/h3&gt;
&lt;p&gt;笔者个人见解：&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;使用Uittest组织冒烟测试，关注点有至少有两个&lt;br/&gt;1、当编写新功能的冒烟测试，需要去维护冒烟测试用例集&lt;br/&gt;2、合并代码时，如果有两个人同时修改了这个冒烟用例集，还要解决冲突，防止遗漏冒烟用例&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;使用Pytest组织冒烟测试，关注点在于用例的本身&lt;br/&gt;当编写新功能的冒烟测试，我只需在给用例加一个编写用例人员约定好的@pytest.mark，例如@pytest.mark.smoke&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;推荐阅读&quot;&gt;推荐阅读:&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/S5QiTz8gDWxhuJYmjo2oAw&quot;&gt;《安利一下pytest的mark用法》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/snailrunning/p/10125596.html#4287840&quot;&gt;《Python Unittest - 根据不同测试环境跳过用例详解》&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;源码地址&quot;&gt;源码地址:&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;https://github.com/SEtester/smoke_testing_demo&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;最后，欢迎同学们留言, 你认为自动化冒烟测试 Unittest , Pytest 哪家强？&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;文章如有不是，欢迎同学们斧正&lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 11 Jul 2019 17:26:00 +0000</pubDate>
<dc:creator>深圳-逸遥</dc:creator>
<og:description>前言：之前有一段时间一直用 Python Uittest做自动化测试，觉得Uittest组织冒烟用例比较繁琐，后来康哥提示我使用pytest.mark来组织冒烟用例 本文讲述以下几个内容： 1、Uni</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/snailrunning/p/11173728.html</dc:identifier>
</item>
<item>
<title>使用Xcode + Python进行IOS运动轨迹模拟 - Joeric</title>
<link>http://www.cnblogs.com/Joeric07/p/11173651.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Joeric07/p/11173651.html</guid>
<description>&lt;p&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在某些app中，需要根据用户的实时位置来完成某些事件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如跑步打卡软件（步道乐跑）、考勤打卡软件（叮叮）、某些基于实时位置的游戏（Pokemon Go、一起来捉妖）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一般解决办法是通过使用安卓模拟器，通过改变模拟器的位置属性来实现模拟位置&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是某些软件会通过比对常用设备的uuid，设备序列号等&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一旦出现不匹配或者无法识别就可能会被列为怀疑对象，且安卓模拟器较难实现连续的拟人化的路径&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因此，为了减少被判定作弊的可能，只能通过在常用设备上连续的改变实时位置来模拟跑步行为&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;硬件环境：&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　　　MacBook Pro (15-inch, 2017)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　iPhone 8 Plus&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;软件环境：&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　　　macOS Mojave 10.14.5&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　iOS 12.4&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　Xcode 10.2.1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　Python 3.7.0&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　sublime text 3.1.1&lt;/span&gt;&lt;/p&gt;


&lt;h2&gt;1.使用Xcode创建一个IOS项目&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;打开Xcode -&amp;gt; Preferences 添加Apple ID&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1459302/201907/1459302-20190711221349916-1640618970.png&quot; alt=&quot;&quot; width=&quot;404&quot; height=&quot;402&quot;/&gt; 　　　　　　　　 &lt;img src=&quot;https://img2018.cnblogs.com/blog/1459302/201907/1459302-20190711221417752-1218695661.png&quot; alt=&quot;&quot; width=&quot;558&quot; height=&quot;399&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在Xcode上创建新项目&lt;/p&gt;
&lt;p&gt;打开Xcode -&amp;gt; create a new Xcode project&lt;/p&gt;
&lt;p&gt;选择ios菜单 -&amp;gt; Single View App&lt;/p&gt;
&lt;p&gt;填写项目名 推荐非中文&lt;/p&gt;
&lt;p&gt;在事先准备好的文件夹内存放 文件夹推荐非中文&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1459302/201907/1459302-20190711225348956-658941545.png&quot; alt=&quot;&quot; width=&quot;414&quot; height=&quot;412&quot;/&gt;　　　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1459302/201907/1459302-20190711225416911-1362119621.png&quot; alt=&quot;&quot; width=&quot;604&quot; height=&quot;412&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1459302/201907/1459302-20190711225449517-378315047.png&quot; alt=&quot;&quot; width=&quot;433&quot; height=&quot;324&quot;/&gt;　　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1459302/201907/1459302-20190711225537339-1546595961.png&quot; alt=&quot;&quot; width=&quot;357&quot; height=&quot;312&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此时将iPhone连接mac 左上角显示连接设备&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;出现如下结果即为成功：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1459302/201907/1459302-20190711225705208-1200948984.png&quot; alt=&quot;&quot; width=&quot;839&quot; height=&quot;589&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;h2&gt;2.使用Xcode创建一个含有gpx的文件&lt;/h2&gt;
&lt;p&gt;GPX（GPS eXchange Format，GPS交换格式）是一个XML格式，为应用软件设计的通用GPS数据格式，专门用来存储地理信息&lt;/p&gt;
&lt;p&gt;一个GPX文件内包含一些经纬度点组成的轨迹，包含了时间、名字等信息&lt;/p&gt;

&lt;p&gt;&lt;span&gt;回到Xcode 打开Xcode -&amp;gt; File -&amp;gt; New -&amp;gt; File...&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在IOS菜单下选择GPX File&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;选择一个位置并命名GPX文件 例：fake_loc.gpx&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1459302/201907/1459302-20190711222304818-480287510.png&quot; alt=&quot;&quot; width=&quot;444&quot; height=&quot;484&quot;/&gt;　　　　　　　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1459302/201907/1459302-20190711222352452-119938516.png&quot; alt=&quot;&quot; width=&quot;485&quot; height=&quot;483&quot;/&gt; &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1459302/201907/1459302-20190711222321640-24804772.png&quot; alt=&quot;&quot; width=&quot;824&quot; height=&quot;160&quot;/&gt;&lt;/p&gt;

&lt;p&gt;自动生成如下gpx文件即为成功&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1459302/201907/1459302-20190711222622755-904964503.png&quot; alt=&quot;&quot; width=&quot;710&quot; height=&quot;705&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;分析该gpx文件，格式类似标签语言风格&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在&amp;lt;wpt&amp;gt;标签内包含经纬度（lat、lon）、该点名称以及时间&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一段注释内容大意为： &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;　　“提供一个或多个包含纬度/经度对的点&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;　　如果提供一个点，Xcode将模拟那个特定的点&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;　　如果提供多个点，Xcode将依次模拟每一个点”&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第二段注释内容大意为： &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;　　“可以选择为每一个坐标点添加一个时间标签&lt;/em&gt;&lt;em&gt;可，Xcode可以根据时间标签的顺序依次移动到每一个坐标点，并根据时间点来插入速度X&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;　　如果不提供一个时间标签，那么Xcode将使用一个固定的速度&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;　　航路点必须按时间升序排序&lt;/em&gt;&lt;em&gt;”&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;因此，可以通过输入一系列点来模拟位置，让Xcode来依次定为每一个点来模拟人的跑动行为&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;3.使用Python来自动生成一系列轨迹点&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;mac下python与sublime text3的环境配置在第一篇随笔中有记录&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;分析gpx文件结构可以得到目标gpx文件结构应该为：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;gpx &lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;=&quot;1.1&quot;&lt;/span&gt;&lt;span&gt; creator&lt;/span&gt;&lt;span&gt;=&quot;Xcode&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;wpt &lt;/span&gt;&lt;span&gt;lat&lt;/span&gt;&lt;span&gt;=&quot;坐标点经度1&quot;&lt;/span&gt;&lt;span&gt; lon&lt;/span&gt;&lt;span&gt;=&quot;坐标点纬度1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;wpt&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;wpt &lt;/span&gt;&lt;span&gt;lat&lt;/span&gt;&lt;span&gt;=&quot;坐标点经度2&quot;&lt;/span&gt;&lt;span&gt; lon&lt;/span&gt;&lt;span&gt;=&quot;坐标点纬度2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;wpt&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;wpt &lt;/span&gt;&lt;span&gt;lat&lt;/span&gt;&lt;span&gt;=&quot;坐标点经度3&quot;&lt;/span&gt;&lt;span&gt; lon&lt;/span&gt;&lt;span&gt;=&quot;坐标点纬度3&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;wpt&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;

    #......
    #以此类推
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;gpx&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;在地图经纬度查询网站可以得到指定地点的经纬度信息：http://www.gpsspg.com/maps.htm&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们选择西安市某211高校作为实验地点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1459302/201907/1459302-20190711231226382-1979013397.png&quot; alt=&quot;&quot; width=&quot;792&quot; height=&quot;618&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;该网站提供多个公司的定位标准下的经纬度信息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由于每一家公司的定位标准不同，经纬度就会存在偏差，这时候就要看用来模拟的APP使用哪家的地图了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们以某跑步打卡APP 步道乐跑 作为实验对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在该高校实现水平移动与竖直移动&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;经过验证该APP使用的是 谷歌地球标准&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;通过该网站首先得到一段直线的首尾经纬度点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1459302/201907/1459302-20190711231640060-1906684923.png&quot; alt=&quot;&quot; width=&quot;233&quot; height=&quot;309&quot;/&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;　&lt;/span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1459302/201907/1459302-20190711231649533-1137080266.png&quot; alt=&quot;&quot; width=&quot;326&quot; height=&quot;308&quot;/&gt;　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1459302/201907/1459302-20190711233300390-1867922652.png&quot; alt=&quot;&quot; width=&quot;391&quot; height=&quot;305&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;开始点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;lat：34.3752989239&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;lon：108.9080291565&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;中间点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;lat：34.3740193255&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;lon：108.9085977848&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;结束点：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;lat：34.3733728774&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;lon：108.9064091023&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;在该网站可以通过经纬度获得距离信息：http://www.hhlink.com/经纬度/&lt;/p&gt;
&lt;p&gt;计算得到距离约为78米&lt;/p&gt;
&lt;p&gt;后续可根据需求，通过测距来得到相应距离 从而计算得到水平与竖直移动速度&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1459302/201907/1459302-20190711232244129-781242410.png&quot; alt=&quot;&quot; width=&quot;709&quot; height=&quot;128&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以得出结论：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在该高校相对从北到南 经度减少，纬度增加&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在该高校相对从东到西 经度减小，纬度减小&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在符合跑步打卡APP步道乐跑的配速要求：3～9 min/km&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 例如从北到南生成100个点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;经度依次减少 纬度依次增加，并使得这100个点散布在路径上&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;每个点之间减少或者增加的距离可以通过乘以指定范围内的随机数，使得点之间呈现左右略为摇摆的路径&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在点数量较多的情况下近似为人的跑动轨迹&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;根据该高校的位置情况编写相应的python程序：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; random

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;初始点信息&lt;/span&gt;
a1 = 34.3752989239&lt;span&gt;;
b1 &lt;/span&gt;= 108.9080291565&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;中间点信息&lt;/span&gt;
a2 = 34.3740193255&lt;span&gt;;
b2 &lt;/span&gt;= 108.9085977848&lt;span&gt;;


&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range( 1,1000&lt;span&gt; ):
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;( a1 &amp;gt;= a2 ):        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 循环条件 经度未到达中间点时执行&lt;/span&gt;
        xa = round( random.uniform(0.2, 7) )    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 随机数，用于模拟人跑动&lt;/span&gt;
        xb = round( random.uniform(12, 15&lt;span&gt;) )
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 竖直移动&lt;/span&gt;
        a1 = round( a1 - 0.0000072 * xa , 10&lt;span&gt; )
        b1 &lt;/span&gt;= round( b1 + 0.0000008 * xb , 10&lt;span&gt; )
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输出信息&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;wpt lat=&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + str( a1 ) + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + &lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt; + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;lon=&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + str( b1 ) + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; )
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;/wpt&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; )


&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range( 1,1000&lt;span&gt; ):
    xa &lt;/span&gt;= round( random.uniform(2, 8&lt;span&gt;) )
    xb &lt;/span&gt;= round( random.uniform(1, 3&lt;span&gt;) )
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 水平移动&lt;/span&gt;
    a2 = round( a2 - 0.000003 * xa, 10&lt;span&gt; )
    b2 &lt;/span&gt;= round( b2 - 0.000025 * xb, 10&lt;span&gt; )
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;wpt lat=&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + str( a2 ) + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + &lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt; + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;lon=&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + str( b2 ) + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; )
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;/wpt&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; )
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;得到输出（节选）：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1459302/201907/1459302-20190711235821361-307362155.png&quot; alt=&quot;&quot; width=&quot;424&quot; height=&quot;705&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;将该输出复制并粘贴在gpx文件里&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;并 command + s 保存&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以在xcode项目目录内找到并打开该文件：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1459302/201907/1459302-20190712000126277-1327201930.png&quot; alt=&quot;&quot; width=&quot;870&quot; height=&quot;788&quot;/&gt;&lt;/p&gt;


&lt;h2&gt;4.开始位置模拟&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;确保手机连接上电脑，并解锁保持屏幕常亮&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;点击Xcode右上角开始图标：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1459302/201907/1459302-20190712000436296-985010763.png&quot; alt=&quot;&quot; width=&quot;957&quot; height=&quot;115&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;第一次会提示iPhone未信任开发者&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在设置 -&amp;gt; 通用 -&amp;gt; 设备管理 点击该开发者并选择信任&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;再次在Xcode上点击右上角图标&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一分钟左右手机上会多出一个灰色的app图标&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;点击后按home键退出，进入步道乐跑&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在Xcode下方多出一栏功能，点击位置图标并选择你的fake_loc&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1459302/201907/1459302-20190712001126914-174512656.png&quot; alt=&quot;&quot; width=&quot;663&quot; height=&quot;137&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;此时APP就已经按照gpx文件内的路径开始移动了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1459302/201907/1459302-20190712002345245-1407435382.png&quot; alt=&quot;&quot; width=&quot;430&quot; height=&quot;765&quot;/&gt;&lt;/p&gt;


&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1459302/201907/1459302-20190712004329770-1032286576.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h2&gt;5.总结&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;在模拟时没有考虑速度的因素，按照默认的Xcode对gpx的点的更新速度来实现的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在控制整体的移动速度时完全是按照点的密集程度，即点的位置变化程度来实现的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;后期可以根据时间标签&amp;lt;time&amp;gt;来改进获得更精确的速度&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;根据步道乐跑后台数据，检测作弊主要依靠平均配速、每公里的步数、设备uuid、设备序列号来检测的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;文章的方法可以解决平均配速、uudi、序列号等问题（因为就是使用真机来实现的）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是对于步数只能依靠在模拟时通过摇晃手机来实现&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 11 Jul 2019 16:25:00 +0000</pubDate>
<dc:creator>Joeric</dc:creator>
<og:description>使用Xcode对ios设备进行轨迹模拟，并加入随机摇摆来模拟跑动状态从而通过某些app对地理位置的限定与移动速度的限制</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Joeric07/p/11173651.html</dc:identifier>
</item>
<item>
<title>python数据库-MySQL与python的交互(52) - Se7eN_HOU</title>
<link>http://www.cnblogs.com/Se7eN-HOU/p/11173618.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Se7eN-HOU/p/11173618.html</guid>
<description>
&lt;h3&gt;一、python3中安装PyMySQL模块&lt;/h3&gt;
&lt;p&gt;命令安装：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
sudo apt-get install python-mysql
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
pip install pymysql
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、使用在pyCharm中安装PyMySQL模块&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/751754/201907/751754-20190711205515602-1934494374.png&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;二、PyMysql对象说明&lt;/h3&gt;
&lt;h4 id=&quot;connection对象&quot;&gt;1、Connection对象&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;用于建立与数据库的连接&lt;/li&gt;
&lt;li&gt;创建对象：调用connect()方法&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
conn=connect(参数列表)
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;参数host：连接的mysql主机，如果本机是'localhost'&lt;/li&gt;
&lt;li&gt;参数port：连接的mysql主机的端口，默认是3306&lt;/li&gt;
&lt;li&gt;参数database：数据库的名称&lt;/li&gt;
&lt;li&gt;参数user：连接的用户名&lt;/li&gt;
&lt;li&gt;参数password：连接的密码&lt;/li&gt;
&lt;li&gt;参数charset：通信采用的编码方式，默认是'gb2312'，要求与数据库创建时指定的编码一致，否则中文会乱码&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;对象的方法&quot;&gt;　　对象的方法&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;close()关闭连接&lt;/li&gt;
&lt;li&gt;commit()事务，所以需要提交才会生效&lt;/li&gt;
&lt;li&gt;rollback()事务，放弃之前的操作&lt;/li&gt;
&lt;li&gt;cursor()返回Cursor对象，用于执行sql语句并获得结果&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;cursor对象&quot;&gt;2、Cursor对象&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;执行sql语句&lt;/li&gt;
&lt;li&gt;创建对象：调用Connection对象的cursor()方法&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
cursor1=conn.cursor()
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;对象的方法&quot;&gt;    对象的方法&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;close()关闭&lt;/li&gt;
&lt;li&gt;execute(operation [, parameters ])执行语句，返回受影响的行数&lt;/li&gt;
&lt;li&gt;fetchone()执行查询语句时，获取查询结果集的第一个行数据，返回一个元组&lt;/li&gt;
&lt;li&gt;next()执行查询语句时，获取当前行的下一行&lt;/li&gt;
&lt;li&gt;fetchall()执行查询时，获取结果集的所有行，一行构成一个元组，再将这些元组装入一个元组返回&lt;/li&gt;
&lt;li&gt;scroll(value[,mode])将行指针移动到某个位置
&lt;ul&gt;&lt;li&gt;mode表示移动的方式&lt;/li&gt;
&lt;li&gt;mode的默认值为relative，表示基于当前行移动到value，value为正则向下移动，value为负则向上移动&lt;/li&gt;
&lt;li&gt;mode的值为absolute，表示基于第一条数据的位置，第一条数据的位置为0&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;对象的属性&quot;&gt;　　对象的属性&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;rowcount只读属性，表示最近一次execute()执行后受影响的行数&lt;/li&gt;
&lt;li&gt;connection获得当前连接对象&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;三、对Mysql基本操作的封装&lt;/h3&gt;
&lt;p&gt;1、我们创建MySQLManager.py模块，对Mysql的基本操作封装&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; coding=utf-8;&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 导入模块pymysql模块&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; pymysql

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 封装MySQL数据库管理类&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MySQL_Manager(object):
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 初始化方法&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;(self,host,port,database,user,password,charset=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 配置连接MySQL数据库的基本信息&lt;/span&gt;
        self.host =&lt;span&gt; host
        self.port &lt;/span&gt;=&lt;span&gt; port
        self.database &lt;/span&gt;=&lt;span&gt; database
        self.user &lt;/span&gt;=&lt;span&gt; user
        self.password &lt;/span&gt;=&lt;span&gt; password
        self.charset &lt;/span&gt;=&lt;span&gt; charset
        
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 使用python3链接MySQL数据库&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; connect(self):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 链接&lt;/span&gt;
        self.connect = pymysql.connect(host = self.host, port = self.port, database = self.database, user = self.user, password = self.password,charset =&lt;span&gt; self.charset)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 得到一个可以执行SQL语句的光标对象&lt;/span&gt;
        self.cursor =&lt;span&gt; self.connect.cursor()
    
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 操作完毕后关闭&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; close(self):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 关闭执行语句&lt;/span&gt;
&lt;span&gt;        self.cursor.close()
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 关闭连接&lt;/span&gt;
&lt;span&gt;        self.connect.close()
        
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建表操作&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; create_table(self,sql,params=&lt;span&gt;()):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 先连接&lt;/span&gt;
&lt;span&gt;        self.connect()
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 执行创建语句&lt;/span&gt;
&lt;span&gt;        self.cursor.execute(sql,params)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 关闭连接&lt;/span&gt;
&lt;span&gt;        self.close()
        
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查询一条数据&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; select_one(self,sql,params=&lt;span&gt;()):
        result &lt;/span&gt;=&lt;span&gt; None
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
            self.connect()
            self.cursor.execute(sql,params)
            result &lt;/span&gt;=&lt;span&gt; self.cursor.fetchone()
            self.close()
        &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception as e:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(e)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result
    
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查询全部数据    &lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; select_all(self,sql,params=&lt;span&gt;()):
        list&lt;/span&gt;=&lt;span&gt;()
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
            self.connect()
            self.cursor.execute(sql,params)
            list &lt;/span&gt;=&lt;span&gt; self.cursor.fetchall()
            self.close()
        &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception as e:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(e)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; list
    
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 插入&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; insert(self, sql, params=&lt;span&gt;()):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; self.&lt;span&gt;__edit&lt;/span&gt;&lt;span&gt;(sql, params)
    
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 修改&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; update(self, sql, params=&lt;span&gt;()):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; self.&lt;span&gt;__edit&lt;/span&gt;&lt;span&gt;(sql, params)
    
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 删除&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; delete(self, sql, params=&lt;span&gt;()):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; self.&lt;span&gt;__edit&lt;/span&gt;&lt;span&gt;(sql, params)
    
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 插入、修改、删除其实一样的，只是sql代码不同，但是为了代码的阅读性更高，还是分开写&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__edit&lt;/span&gt;&lt;span&gt;(self, sql, params):
        count &lt;/span&gt;=&lt;span&gt; 0
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
            self.connect()
            count &lt;/span&gt;=&lt;span&gt; self.cursor.execute(sql, params)
            self.connect.commit()
            self.close()
        &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception as e:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(e)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; count
        &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.创建testMySQL.py模块对我们创建的MySQLManager.py模块测试&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; coding = utf-8&lt;/span&gt;

&lt;span&gt;from&lt;/span&gt; MySQLManager &lt;span&gt;import&lt;/span&gt; *&lt;span&gt;

mysql_manager &lt;/span&gt;= MySQL_Manager(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;192.168.100.114&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,3306,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hero&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123456&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建表&lt;/span&gt;
create_sql = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;create table hero(id int auto_increment primary key,name varchar(20) not null unique,skill varchar(20) not null) engine=innodb default charset=utf8;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
mysql_manager.create_table(create_sql)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 添加数据&lt;/span&gt;
insert_sql = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;insert into hero(id,name,skill) values(1,'李白','青莲剑歌');&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
mysql_manager.insert(insert_sql)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查询语句&lt;/span&gt;
select_sql = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;select * from hero;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
list &lt;/span&gt;=&lt;span&gt; mysql_manager.select_all(select_sql)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(list)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 修改&lt;/span&gt;
update_sql = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;update hero set name='韩信' where id=1;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
mysql_manager.update(update_sql)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 删除语句&lt;/span&gt;
delete_sql = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;delete from hero where id=1;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
mysql_manager.delete(delete_sql)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;为什么MySQLManager里面的方法都有params参数，这里却没用？因为这只是测试，我把所有的参数都直接写在了sql语句中，但是为了程序的可扩展性，建议大家还是使用参数params&lt;/li&gt;
&lt;li&gt;testMysql.py文件每运行一次里面对数据库的操作就会执行一次，例如创建表的操作只需要执行一次，当我们创建表成功之后，就可以把创建表的方法注释掉，不用再创建了，同样的，添加，删除也是一样。&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Thu, 11 Jul 2019 16:09:00 +0000</pubDate>
<dc:creator>Se7eN_HOU</dc:creator>
<og:description>一、python3中安装PyMySQL模块 命令安装： 或者 2、使用在pyCharm中安装PyMySQL模块 二、PyMysql对象说明 1、Connection对象 用于建立与数据库的连接 创建对</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Se7eN-HOU/p/11173618.html</dc:identifier>
</item>
<item>
<title>基于C#的机器学习--我应该接受这份工作吗-使用决策树 - 王振耀</title>
<link>http://www.cnblogs.com/wangzhenyao1994/p/11173585.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangzhenyao1994/p/11173585.html</guid>
<description>&lt;h2&gt; 决策树&lt;/h2&gt;
&lt;p&gt;       要使决策树完整而有效，它必须包含所有的可能性。事件序列也必须提供，并且是互斥的，这意味着如果一个事件发生，另一个就不能发生。&lt;/p&gt;
&lt;p&gt;       决策树是监督机器学习的一种形式，因为我们必须解释输入和输出应该是什么。有决策节点和叶子。叶子是决策，不管是否是最终决策，节点是决策分裂发生的地方。&lt;/p&gt;
&lt;p&gt;       虽然有很多算法可供我们使用，但我们将使用迭代二分法(ID3)算法。&lt;/p&gt;
&lt;p&gt;在每个递归步骤中，根据一个标准(信息增益、增益比等)选择对我们正在处理的输入集进行最佳分类的属性。&lt;/p&gt;
&lt;p&gt;这里必须指出的是，无论我们使用什么算法，都不能保证生成尽可能小的树。因为这直接影响到算法的性能。&lt;/p&gt;
&lt;p&gt;请记住，对于决策树，学习仅仅基于启发式，而不是真正的优化标准。让我们用一个例子来进一步解释这一点。&lt;/p&gt;
&lt;p&gt;下面的示例来自http://jmlr.csail.mit.edu/papers/volume8/esmeir07a/esmeir07a.pdf，它演示了XOR学习概念，我们所有的开发人员都(或应该)熟悉这个概念。稍后的例子中也会出现这种情况，但现在a3和a4与我们要解决的问题完全无关。它们对我们的答案没有影响。也就是说，ID3算法将选择其中一个构建树，事实上，它将使用a4作为根节点!记住，这是算法的启发式学习，而不是优化结果:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/912798/201907/912798-20190711234708556-75849415.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;希望这张图能让大家更容易理解刚刚所说的内容。我们的目标并不是深入研究决策树机制和理论。而是如何使用它，尽管存在很多问题，但决策树仍然是许多算法的基础，尤其是那些需要对结果进行人工描述的算法。这也是我们前面试试人脸检测算法的基础。&lt;/p&gt;
&lt;h3&gt;     决策节点&lt;/h3&gt;
&lt;p&gt;决策树的一个节点。每个节点可能有关联的子节点，也可能没有关联的子节点&lt;/p&gt;
&lt;h3&gt;     决策的变量&lt;/h3&gt;
&lt;p&gt;       此对象定义树和节点可以处理的每个决策变量的性质。值可以是范围，连续的，也可以是离散的。&lt;/p&gt;
&lt;h3&gt;     决策分支节点的集合&lt;/h3&gt;
&lt;p&gt;       此集合包含将一个或多个决策节点组，以及关于决策变量的附加信息，以便进行比较。&lt;/p&gt;
&lt;p&gt;       下面是一个用于确定金融风险的决策树示例。我们只需要在节点之间导航，就可以很容易地跟随它，决定要走哪条路，直到得到最终的答案。在这种情况下，当有人正在申请贷款，而我们需要对他们的信用价值做出决定。这时决策树就是解决这个问题的一个很好的方法:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/912798/201907/912798-20190711234728685-2069366998.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;我应该接受这份工作吗？&lt;/h2&gt;
&lt;p&gt;       你刚刚得到一份新工作，你需要决定是否接受它。有一些重要的事情需要考虑，所以我们将它们作为输入变量或特性，用于决策树。&lt;/p&gt;
&lt;p&gt;对你来说最重要的是:薪水、福利、公司文化，当然还有，我能在家工作吗?&lt;/p&gt;
&lt;p&gt;我们将创建一个内存数据库并以这种方式添加特性，而不是从磁盘存储中加载数据。我们将创建DataTable并创建列，如下图所示:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/912798/201907/912798-20190711234743188-1601951939.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这之后，我们将加载几行数据，每一行都有一组不同的特性，最后一列应该是Yes或No，作为我们的最终决定:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/912798/201907/912798-20190711234757434-52353987.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一旦所有的数据都创建好并放入表中，我们就需要将之前的特性转换成计算机能够理解的表示形式。&lt;/p&gt;
&lt;p&gt;由于数字更简单，我们将通过一个称为编码的过程将我们的特性(类别)转换为一本代码本。该代码本有效地将每个值转换为整数。&lt;/p&gt;
&lt;p&gt;注意，我们将传递我们的数据类别作为输入:&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/912798/201907/912798-20190711234817544-365512694.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来，我们需要为决策树创建要使用的决策变量。&lt;/p&gt;
&lt;p&gt;这棵树会帮助我们决定是否接受新的工作邀请。对于这个决策，将有几类输入，我们将在决策变量数组中指定它们，以及两个可能的决策，是或者否。&lt;/p&gt;
&lt;p&gt;DecisionVariable数组将保存每个类别的名称以及该类别可能的属性的总数。例如，薪水类别有三个可能的值，高、平均或低。我们指定类别名和数字3。然后，除了最后一个类别(即我们的决定)之外，我们对所有其他类别都重复这个步骤:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/912798/201907/912798-20190711234837834-708896384.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在我们已经创建了决策树，我们必须教它如何解决我们要解决的问题。为了做到这一点，我们必须为这棵树创建一个学习算法。由于我们只有这个示例的分类值，所以ID3算法是最简单的选择。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/912798/201907/912798-20190711234850215-959931670.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一旦学习算法被运行，它就会被训练并可供使用。我们简单地为算法提供一个样本数据集，这样它就可以给我们一个答案。在这种情况下，薪水不错，公司文化不错，福利也不错，我可以在家工作。如果正确地训练决策树，答案将会是是:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/912798/201907/912798-20190711234900759-571463863.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;Numl&lt;/h2&gt;
&lt;p&gt;numl是一个非常著名的开源机器学习工具包。与大多数机器学习框架一样，它的许多示例也使用Iris数据集，包括我们将用于决策树的那个。&lt;/p&gt;
&lt;p&gt;下面是我们的numl输出的一个例子:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/912798/201907/912798-20190711234912900-1386067057.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;让我们看一下这个例子背后的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello World!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; description = Descriptor.Create&amp;lt;Iris&amp;gt;&lt;span&gt;();
            Console.WriteLine(description);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; generator = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DecisionTreeGenerator();
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; data =&lt;span&gt; Iris.Load();
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; model =&lt;span&gt; generator.Generate(description, data);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;生成的模型:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(model);
            Console.ReadKey();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个方法并不复杂，对吧?这就是在应用程序中使用numl的好处;它非常容易使用和集成。&lt;/p&gt;
&lt;p&gt;上述代码创建描述符和DecisionTreeGenerator，加载Iris数据集，然后生成模型。这里只是正在加载的数据的一个示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Iris[] Load()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Iris[]
            {
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Iris { SepalLength = &lt;span&gt;5.1m&lt;/span&gt;, SepalWidth = &lt;span&gt;3.5m&lt;/span&gt;, PetalLength = &lt;span&gt;1.4m&lt;/span&gt;, PetalWidth = &lt;span&gt;0.2m&lt;/span&gt;, Class = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Iris-setosa&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; },
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Iris { SepalLength = &lt;span&gt;4.9m&lt;/span&gt;, SepalWidth = 3m, PetalLength = &lt;span&gt;1.4m&lt;/span&gt;, PetalWidth = &lt;span&gt;0.2m&lt;/span&gt;, Class = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Iris-setosa&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; },
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Iris { SepalLength = &lt;span&gt;4.7m&lt;/span&gt;, SepalWidth = &lt;span&gt;3.2m&lt;/span&gt;, PetalLength = &lt;span&gt;1.3m&lt;/span&gt;, PetalWidth = &lt;span&gt;0.2m&lt;/span&gt;, Class = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Iris-setosa&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; },
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Iris { SepalLength = &lt;span&gt;4.6m&lt;/span&gt;, SepalWidth = &lt;span&gt;3.1m&lt;/span&gt;, PetalLength = &lt;span&gt;1.5m&lt;/span&gt;, PetalWidth = &lt;span&gt;0.2m&lt;/span&gt;, Class = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Iris-setosa&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; },
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Iris { SepalLength = 5m, SepalWidth = &lt;span&gt;3.6m&lt;/span&gt;, PetalLength = &lt;span&gt;1.4m&lt;/span&gt;, PetalWidth = &lt;span&gt;0.2m&lt;/span&gt;, Class = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Iris-setosa&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; },
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Iris { SepalLength = &lt;span&gt;5.4m&lt;/span&gt;, SepalWidth = &lt;span&gt;3.9m&lt;/span&gt;, PetalLength = &lt;span&gt;1.7m&lt;/span&gt;, PetalWidth = &lt;span&gt;0.4m&lt;/span&gt;, Class = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Iris-setosa&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; }
            };
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Accord.NET 决策树&lt;/h2&gt;
&lt;p&gt;Accord.NET framework也有自己的决策树例子。它采用了一种不同的、更图形化的方法来处理决策树，但是您可以通过调用来决定您喜欢哪个决策树，并且最习惯使用哪个决策树。&lt;/p&gt;
&lt;p&gt;       一旦数据被加载，您就可以创建决策树并为学习做好准备。您将看到与这里类似的数据图，使用了X和Y两个类别：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/912798/201907/912798-20190711235043545-1469240700.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下一个选项卡将让您看到树节点、叶子和决策。右边还有一个自顶向下的树的图形视图。最有用的信息在左边的树形视图中，你可以看到节点，它们的值，以及做出的决策:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/912798/201907/912798-20190711235058624-941519640.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后，最后一个选项卡将允许您执行模型测试：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/912798/201907/912798-20190711235110685-1384087563.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;代码&lt;/h2&gt;
&lt;p&gt;下面是学习代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 指定输入变量&lt;/span&gt;
            DecisionVariable[] variables =&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; DecisionVariable(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, DecisionVariableKind.Continuous),
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; DecisionVariable(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;y&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, DecisionVariableKind.Continuous),
            };
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建C4.5学习算法&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; c45 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; C45Learning(variables);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用C4.5学习决策树&lt;/span&gt;
            tree =&lt;span&gt; c45.Learn(inputs, outputs);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在视图中显示学习树&lt;/span&gt;
            decisionTreeView1.TreeSource =&lt;span&gt; tree;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取每个变量(X和Y)的范围&lt;/span&gt;
            DoubleRange[] ranges = table.GetRange(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 生成一个笛卡尔坐标系&lt;/span&gt;
            &lt;span&gt;double&lt;/span&gt;[][] map = Matrix.Mesh(ranges[&lt;span&gt;0&lt;/span&gt;], &lt;span&gt;200&lt;/span&gt;, ranges[&lt;span&gt;1&lt;/span&gt;], &lt;span&gt;200&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对笛卡尔坐标系中的每个点进行分类&lt;/span&gt;
            &lt;span&gt;double&lt;/span&gt;[,] surface =&lt;span&gt; map.ToMatrix().InsertColumn(tree.Decide(map));
CreateScatterplot(zedGraphControl2, surface);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;测试
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从整个源数据表创建一个矩阵&lt;/span&gt;
            &lt;span&gt;double&lt;/span&gt;[][] table = (dgvLearningSource.DataSource &lt;span&gt;as&lt;/span&gt; DataTable).ToJagged(&lt;span&gt;out&lt;/span&gt;&lt;span&gt; columnNames);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;只获取输入向量值(前两列)&lt;/span&gt;
            &lt;span&gt;double&lt;/span&gt;[][] inputs = table.GetColumns(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取预期的输出标签(最后一列)&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt;[] expected = table.GetColumn(&lt;span&gt;2&lt;/span&gt;&lt;span&gt;).ToInt32();


            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 计算实际的树输出&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt;[] actual =&lt;span&gt; tree.Decide(inputs);


            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用混淆矩阵来计算一些统计数据。&lt;/span&gt;
            ConfusionMatrix confusionMatrix = &lt;span&gt;new&lt;/span&gt; ConfusionMatrix(actual, expected, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
            dgvPerformance.DataSource &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt;[] { confusionMatrix };

            CreateResultScatterplot(zedGraphControl1, inputs, expected.ToDouble(), actual.ToDouble());&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后他的值被输入一个混淆矩阵。对于不熟悉这一点的同学，让我简单解释一下.&lt;/p&gt;
&lt;h2&gt;混淆矩阵&lt;/h2&gt;
&lt;p&gt;混淆矩阵是用来描述分类模型性能的表。它在已知真值的测试数据集上运行。这就是我们如何得出如下结论的。&lt;/p&gt;

&lt;h2&gt;真-阳性&lt;/h2&gt;
&lt;p&gt;在这个例子中，我们预测是，这是事实。&lt;/p&gt;
&lt;h2&gt;真-阴性&lt;/h2&gt;
&lt;p&gt;在这种情况下，我们预测否，这是事实。&lt;/p&gt;
&lt;h2&gt;假-阳性&lt;/h2&gt;
&lt;p&gt;在这种情况下，我们预测是，但事实并非如此。有时您可能会看到这被称为type 1错误。&lt;/p&gt;
&lt;h2&gt;假-阴性&lt;/h2&gt;
&lt;p&gt;在这种情况下，我们预测“否”，但事实是“是”。有时您可能会看到这被type 2类错误。&lt;/p&gt;
&lt;p&gt;现在，说了这么多，我们需要谈谈另外两个重要的术语，精确度和回忆。&lt;/p&gt;
&lt;p&gt;让我们这样来描述它们。在过去的一个星期里，每天都下雨。这是7天中的7天。很简单。一周后，你被问到上周多久下一次雨?&lt;/p&gt;
&lt;h2&gt;回忆&lt;/h2&gt;
&lt;p&gt;它是你正确回忆下雨的天数与正确事件总数的比值。如果你说下了7天雨，那就是100%。如果你说下了四天雨，那么57%的人记得。在这种情况下，它的意思是你的回忆不是那么精确，所以我们有精确度来识别。&lt;/p&gt;
&lt;h2&gt;精确度&lt;/h2&gt;
&lt;p&gt;它是你正确回忆将要下雨的次数与那一周总天数的比值。&lt;/p&gt;
&lt;p&gt;对我们来说，如果我们的机器学习算法擅长回忆，并不一定意味着它擅长精确。有道理吗?这就涉及到其他的事情，比如F1的分数，我们会留到以后再讲。&lt;/p&gt;
&lt;h2&gt;可视化错误类型&lt;/h2&gt;
&lt;p&gt;以下是一些可能会有帮助的可视化:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/912798/201907/912798-20190711235218911-1750112939.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;识别真阳性和假阴性：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/912798/201907/912798-20190711235239589-1651916238.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用混淆矩阵计算统计量后，创建散点图，识别出所有内容:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/912798/201907/912798-20190711235252490-353213788.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;在这一章中，我们花了很多时间来研究决策树;它们是什么，我们如何使用它们，以及它们如何使我们在应用程序中受益。在下一章中，我们将进入深度信念网络(DBNs)的世界，它们是什么，以及我们如何使用它们。&lt;/p&gt;
&lt;p&gt;我们甚至会谈论一下计算机的梦，当它做梦的时候!&lt;/p&gt;
</description>
<pubDate>Thu, 11 Jul 2019 15:54:00 +0000</pubDate>
<dc:creator>王振耀</dc:creator>
<og:description>决策树 要使决策树完整而有效，它必须包含所有的可能性。事件序列也必须提供，并且是互斥的，这意味着如果一个事件发生，另一个就不能发生。 决策树是监督机器学习的一种形式，因为我们必须解释输入和输出应该是什</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wangzhenyao1994/p/11173585.html</dc:identifier>
</item>
<item>
<title>15分钟带你了解虚拟内存 - 一心一怿</title>
<link>http://www.cnblogs.com/ZXYloveFR/p/11150523.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ZXYloveFR/p/11150523.html</guid>
<description>&lt;p&gt;这篇文章主要是想尽量直观的介绍虚拟内存的知识，而虚拟内存的知识不管作为在校学生的基础知识，面试的问题以及计算机程序本身性能的优化都有着重要的意义。而起意写这篇文章主要还是因为在python，人工智能的大浪潮下，我发现好多人对这方面真的无限趋近于不知道。我不是说懂这些基础知识比懂人工智能水平就是高，但是作为一个软件工程师，我觉得相对于调库调参，我们更应该有更牢靠的基础知识。不然很容易陷入，高深的数学不会，基础的知识也不知道的尴尬境地。毕竟从事算法核心的，没有多少人，而作为工程师，我始终觉得我们的使命是如何把这些天赋异禀，脑袋发达的人的想法，构思，算法变成真正可用的东西。而在我从业不算长的年限中遇过的人来看，这绝对不是一种很简单的能力。&lt;/p&gt;
&lt;p&gt;阅读本文，需要有基本的c语言和python语言知识，如果提到虚拟内存，脑海中就有虚拟内存分布图的大概样子，那就完美适配这篇文章了。我希望通过这篇文章可以帮助你可以通过推理的方法回答出虚拟内存的各种问题，可以知道这个东西是如何真正和程序结合起来的。&lt;/p&gt;
&lt;p&gt;文章大体分为三个部分，&lt;/p&gt;
&lt;p&gt;第一部分，介绍虚拟内存的基本知识&lt;/p&gt;
&lt;p&gt;第二部分，会直观的展示虚拟内存和我们的程序代码到底是怎么联系起来的&lt;/p&gt;
&lt;p&gt;第三部分，我会演示如何改掉虚拟内存的内容，和修改这些内容到底意味着什么，吹的大一点，如何hack一个程序&lt;/p&gt;
&lt;p&gt;本文所有的代码都很简单，只有c语言代码和python代码，并且我都跑过，如果你使用以下的环境，应该代码都能跑起来看到结果:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一台Linux发行版的机器，我用的，一个树莓pi&lt;/li&gt;
&lt;li&gt;Python 3+&lt;/li&gt;
&lt;li&gt;gcc 5.4.0+&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果你是一个程序员，至少你肯定听过内存这个词，虽然你可能真的不知道内存是什么，但是确实在现代程序语言的包装下，你依然可以写出各种程序。如果你真的不知道，那么我觉得还是应该去学习下内存的知识的以及计算机程序是如何被执行起来的。而什么叫虚拟，我至今记得我大学操作系统老师上虚拟内存这一节的时候引用的解释，我拙劣的翻译成中文大概就是:&lt;/p&gt;
&lt;p&gt;真实就是这个东西存在并且感受到，虚拟就是这个东西存在但是你感觉不到。&lt;/p&gt;
&lt;p&gt;虚拟内存就是这么一类东西，它确实存在，而你却不能在程序中感受到他。为什么要有虚拟内存，原因有很多，比如操作系统分配内存的时候，很难保证一个程序用的内存地址一定是连续的。比如内存是一个全局的东西而且只有一个，而程序有无数个，直接操作内存出问题的概率大，管理也不方便等等。于是虚拟内存的概念就给计算机程序的编写者，编译器等等都提供了一段独立，连续的“内存”空间。而实际上，这段内存不是真是存在的，其地址空间可以比真实的地址空间还要大，通过各种换出换入技术，让程序以为自己运行在一段连续的地址空间上。虚拟内存的概念的伟大之处在于给计算机科学的各种概念设计提供了一种思路，隔离，虚拟，直到现在，docker,各种虚拟化技术不能不说和虚拟内存的概念没有关系。&lt;/p&gt;
&lt;p&gt;而提到虚拟内存那么无论在什么样关于操作系统的教科书里一定有这么一张图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/159614/201907/159614-20190708123815699-434506553.jpg&quot; alt=&quot;&quot; width=&quot;316&quot; height=&quot;277&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我当时在学习的时候老师会跟我们说这个虚拟内存由哪些部分组成,为了文章看起来比较整体，让我再简单的说明下，对于一个运行的程序，到底有哪些部分组成:&lt;/p&gt;
&lt;p&gt;首先虚拟内存的寻址地址是由机器和操作系统决定，比如你是一个32bit的操作系统，那么寻址空间就是4GB，换句话说你的程序可以跑在一个0到0xffff ffff的“盒子”里，而如果你是64位的操作系统，那么这个寻址空间就会更大，意味着，你有更大的“盒子”，可以有更多的可能。&lt;/p&gt;
&lt;p&gt;而图中的低地址就是0x0，假设是32位操作系统，那么高地址就是0xffff ffff。那么，就让我们按照人类的认知习惯，从低往高看看每一层都“住”着些什么。&lt;/p&gt;
&lt;p&gt;最下面是text段，这里放着程序的执行的代码等等，如果你用objdump这样的程序打开一个程序，最前面你能看到应该是你的代码转化而成的汇编语言。&lt;/p&gt;
&lt;p&gt;往上就是已初始化数据段和未初始化数据段，这里存放着全局变量，而这些都会被exec去执行，他们不仅有不同的名称，还有不同的权限，在后面的展示中，你可以直观的看到这些。&lt;/p&gt;
&lt;p&gt;而再往上是堆段，也就是面试中经常会被问的，malloc，new出来的内存是存放在哪里的，没错，就是这里。而他的上面是另一个面试问题的来源，局部变量，参数都存在哪里。&lt;/p&gt;
&lt;p&gt;住在顶楼的是命令行参数，环境变量等等。&lt;/p&gt;
&lt;p&gt;而这些都是理论书本上写的，类似于告诉你两点之间有且只有一条直线一样。到底两点之间是不是真的只能画一条直线，最好的办法应该是自己画一画，以真实去验证理论。所以，到底一个程序在内存中真的是这样吗，或者说我们的程序代码到底和这样一个概念有什么关系，下面的章节就让你看看“虚拟”是如何可以被真实的展示的。&lt;/p&gt;

&lt;p&gt;在这一节的最开始，我不得不特别简单的介绍linux下的proc文件夹，其实正确的应该叫他文件系统。而这也是为什么要使用Linux作为代码运行环境的原因，Windows上要看到一个程序的虚拟内存不是不可以，但是要去使用一些第三方工具，唯有Linux，在不需要任何工具的情况就能直观的给你展示所有的内容。而Proc文件系统就是这样一个入口。&lt;/p&gt;
&lt;p&gt;如果你在Linux的命令行中输入ls /proc/，你会发现好多内容，其中有很多以数字为名字的文件夹。这些数字对应的就是一个一个的进程，而这些数字就是进程的pid，此时你可以更进一步，随便选一个数字大一点的文件夹，看看里面到底有什么。在我的电脑上，我选了7199这个数字，使用ls /proc/7199。你会看到更多的文件和文件夹，而且这些文件的名字都很有意思，比如cpuset，比如mem，比如cmdline等等。没错，这些文件里存储的就是该进程相关的信息，比如命令行，比如环境变量等等。而LINUX中一切都是文件的思想也在这里得到了体现。proc是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，用户可以通过这些文件查看有关系统硬件及当前正在运行进程的信息。而和我们这个主题相关的文件就是/proc/pid/maps和/proc/pid/mem。一个显示了改进程虚拟内存的分布，一个就是真正的虚拟内存的文件表现了。作为好奇的人类，你可以随便找一个pid文件夹看看maps文件里的内容，而mem由于特殊设置是无法被直接读取查看的。或者，你可以跟着这篇文章后面的代码，查看自己的程序的maps文件。&lt;/p&gt;
&lt;p&gt;我编写了一个很简单小程序叫做showVM，这个程序会是下一章的主角。在我运行showVM文件后，使用下面的命令找到这个程序的id：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;ps&lt;/span&gt; aux | &lt;span&gt;grep&lt;/span&gt; showVM
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在我的机器上，这一次运行分配的ID是20772，接下来就是让人充满啊！哈！感的时刻了。既然找到了id，根据最前面介绍的proc文件系统知识，首先使用 cat /proc/20855/maps查看下这个进程的虚拟内存分布图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/159614/201907/159614-20190710151855091-33353173.png&quot; alt=&quot;&quot; width=&quot;632&quot; height=&quot;380&quot;/&gt;&lt;/p&gt;
&lt;p&gt;maps文件是一个非常值得细细研究的文件，这就是一个虚拟内存最好的示意图。和上面的有一些些不同，貌似这个虚拟内存地址似乎不是从0x0开始到0xffff ffff结束，和我上面说的32位操作系统寻址空间有点差别。而这个由于和本文所想介绍的主题不是那么的联系紧密，而太多的细节容易让人偏离主题，所以这个有兴趣的话可以就是那句俗话，自己去搜索搜索。&lt;/p&gt;
&lt;p&gt;废话不再多扯了，就从一眼最熟悉的两个词开始，stack和heap。maps文件的第一列是地址，所以从这个文件中可以最直接的验证的就是heap是存在于低地址段，而stack位于高地址段。还有一个就是这两个段的权限都是可读可写，这样保证了这两段是可以被程序读写的。&lt;/p&gt;
&lt;p&gt;这个时候再回到上面的示意图中，可以看到图中所绘，stack的更高地址存储的是命令行参数，而heap更低地址是代码段和数据段。而这里，我想从更低的地址开始说起，因为即使你从来没接触过aps文件，你会发现最后一列是文件的名称，最低地址放着的是我们自己的程序代码文件。这不足为奇，一个程序总要把自己的可执行部分放在虚拟内存中，这样CPU才能找到并且执行，这里比较有意思的是这里貌似有三个重复的，但是仔细看，你会发现这三个部分的权限是不同的，而示意图中heap之下也正好有三个部分，看起来正好是对应了示意图的三个部分。但是这个想法是不准确的，可以看到这三个部分：&lt;/p&gt;
&lt;p&gt;第一个部分是可读可执行权限，这里存放的是代码。&lt;/p&gt;
&lt;p&gt;第二个部分只有读权限，这个部分涉及另外一类称之为RELRO的技术，简答来说这个技术在gcc，linux中采用可以减少非法篡改着修改可写区域的机会，不是简单的一节两节可以说清楚的。考虑到这个和了解熟悉虚拟内存分布的关系不大，如果没有兴趣，完全可以暂时忽略这个部分。&lt;/p&gt;
&lt;p&gt;第三个部分是可读可写的部分，这里存放的呢就是各种数据，和上面的示意图可能有点不一样，这里包括已经初始化的和未被初始化的数据。&lt;/p&gt;
&lt;p&gt;说完heap更低的地址，下面再看看另一个部分，stack更高的地址。这里有很多缩写名词，而这些名词又涉及到更多的细节，主要是内核态和用户态的相关知识，这个部分就很深入而且不是很少的篇幅就能叙述清除的，在这里只需要知道，在Linux虚拟地址空间映射中，最高的1GB是kernel space的映射，具体有什么作用呢？可以完成比如用户态，内核态数据交换，在这里映射一些内核态的函数，加快调用内核态函数时的速度等等。这1GB的地址的内容，用户态的程序是不可以读不可以写的。&lt;/p&gt;
&lt;p&gt;对应着示意图，似乎maps文件多了一个部分，就是中间的一串.so文件。当然，只要你稍微有点Linux的知识，你会知道这些都是Linux的库文件，也就是可执行程序。那么虚拟内存里面为什么要放这么多库文件呢？很明显的一点，就是这些库文件肯定是我们的程序需要调用的文件，这一部分叫做内存映射文件，最大的好处就是可以提高程序的运行速度。&lt;/p&gt;
&lt;p&gt;说了这么多，对应着示意图，Linux虚拟内存地址更准确的示意图应该是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/159614/201907/159614-20190710143818943-95098899.png&quot; alt=&quot;&quot; width=&quot;239&quot; height=&quot;479&quot;/&gt;&lt;/p&gt;


&lt;p&gt;作为程序员，我们的世界里最直接面对的就是代码了。如果书上描写的一切不能用代码证明，感觉总是缺少点什么，而这一节主要就是用真实的代码证明maps文件里面的各个区域。而和内存交互，最直接想到的应该就是使用c语言，而证明maps文件的各个部分最简单的方法就是打印出各个部分的地址然后和maps文件一一对应。 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;************************************************************************
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    &amp;gt; File Name: showVM.c
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    &amp;gt; Author: 
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    &amp;gt; Mail: 
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    &amp;gt; Created Time: Wed 03 Jul 2019 01:24:28 PM CST
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt; ***********************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; #include &amp;lt;stdio.h&amp;gt;
&lt;span&gt; 9&lt;/span&gt; #include &amp;lt;&lt;span&gt;string&lt;/span&gt;.h&amp;gt;
&lt;span&gt;10&lt;/span&gt; #include &amp;lt;stdlib.h&amp;gt;
&lt;span&gt;11&lt;/span&gt; #include &amp;lt;unistd.h&amp;gt;
&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; add(&lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; b){
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; a+&lt;span&gt;b;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; del(&lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; b){
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; a-&lt;span&gt;b;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; (*fPointer)(&lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; b);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;global&lt;/span&gt; = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; global_uninitialized;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc,&lt;span&gt;char&lt;/span&gt; *&lt;span&gt;argv[])
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;char&lt;/span&gt; *chOnHeap = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;chOnHeap = (char*)malloc(8);&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; *nOnHeap = (&lt;span&gt;int&lt;/span&gt;*)&lt;span&gt;malloc&lt;/span&gt;(&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;)*&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     *nOnHeap = &lt;span&gt;200&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt;     fPointer =&lt;span&gt; add;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         sleep(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-------------------------------------------------------------------------------\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;global address = %p\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,(&lt;span&gt;void&lt;/span&gt;*)&amp;amp;&lt;span&gt;global&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;global uninitialized address = %p\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,(&lt;span&gt;void&lt;/span&gt;*)&amp;amp;&lt;span&gt;global_uninitialized);
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;var value = %d, address = %p\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;var&lt;/span&gt;,(&lt;span&gt;void&lt;/span&gt;*)&amp;amp;&lt;span&gt;var&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;chOnHeap value = %s, pointer address = %p, pointed address = %p\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,chOnHeap,(&lt;span&gt;void&lt;/span&gt;*)&amp;amp;&lt;span&gt;chOnHeap,chOnHeap);
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;nOnHeap value = %d, pointer address = %p, pointed address = %p\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,*nOnHeap,(&lt;span&gt;void&lt;/span&gt;*)&amp;amp;&lt;span&gt;nOnHeap,nOnHeap);
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; 
&lt;span&gt;45&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;main address = %p\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,(&lt;span&gt;void&lt;/span&gt;*)&amp;amp;&lt;span&gt;main);
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; argc; i++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;             printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;argument address = %p\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,(&lt;span&gt;void&lt;/span&gt;*)&amp;amp;&lt;span&gt;argv[i]);
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;add address = %p\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, (&lt;span&gt;void&lt;/span&gt; *)&amp;amp;&lt;span&gt;add);
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;del address = %p\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, (&lt;span&gt;void&lt;/span&gt; *)&amp;amp;&lt;span&gt;del);
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;function pointer address = %p, pointed address = %p ,value = %d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,(&lt;span&gt;void&lt;/span&gt; *)&amp;amp;fPointer,fPointer,(*fPointer)(&lt;span&gt;10&lt;/span&gt;,&lt;span&gt;20&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; 
&lt;span&gt;53&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--------------------------------------------------------------------------------\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;     
&lt;span&gt;56&lt;/span&gt;     &lt;span&gt;free&lt;/span&gt;&lt;span&gt;(nOnHeap);
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;free(chOnHeap);&lt;/span&gt;
&lt;span&gt;58&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后使用以下命令编译这个文件：&lt;/p&gt;
&lt;p&gt;gcc -Wall -Wextra -Werror showVM.c -o showVM&lt;/p&gt;
&lt;p&gt;下面就是运行showVM，得到输出如下，准确的说应该是一次输出如下：&lt;/p&gt;

&lt;p&gt;对应着上一节的maps文件，我们就可以开始我们的代码验证之旅了。&lt;/p&gt;
&lt;p&gt;首先，对于global变量，不管是已初始化的或者是未初始化的，都是位于0x21000-0x22000这个段中的，对应上面的maps文件，可以看到无论是初始化的数据或者未初始化数据都是放在上面所说的heap之下的第三部分，可写可读区域的。&lt;/p&gt;
&lt;p&gt;接下来就是最常见的局部变量的位置，在无数的关于c语言的书中，都会类似这样的描写： c语言中，一个变量是在栈上分配（存储）的。这里可以看到这个变量var的地址是0x7e8441d8，位于0x7e824000-0x7e845000之间，并且可以看到是更接近于7e845000，似乎可以印证栈都是从高地址向低地址增长的。不过，只有一个变量的话，有可能正好这个变量就坐落于这个区域。没有关系，我们可以用声明更多的变量看看栈到底是怎样生长的。&lt;/p&gt;
&lt;p&gt;在接下里的两行，打印的是两个指针的地址，而指针本身是一个变量，所以可以看到他们的地址都是在栈上。如果结合上面一个变量的地址来看，正好每一个都是前一个的地址减去4，而这和32位机器上指针的大小一致。可以看到，在虚拟内存中，栈是由高地址往低地址生长的。&lt;/p&gt;
&lt;p&gt;还是这两行，根据c语言书里面关于变量分配的另外一句话，“指针数据都是存储（分配）在堆上的”，似乎从这个输出中看有点出入。对于这两个指针，指向整数的那个指针，所指向的整数确实是分配在堆上的，因为地址0x1fce018确实坐落于0x1fce000-0x1fef000之间，而且从这个位置来看，堆似乎是从低地址往高地址分配的。而指向字符串的那个指针所指的地址明显不是在栈上，而是在0x10000-0x11000这个区域之间。这不是堆的区域，而是可执行文件存放的区域，从下一行main函数的地址更加可以证明这一点。为什么会这样呢？因为c语言把这种字面量(string literal）都放在所谓的“文字常量区”，这里的数据会在程序结束后由程序自己释放，所以即使对于这个指针不进行free也不会造成内存泄露。所以，对于这道常见的面试题，“指针指向的值都分配在哪里？”，如果你的回答可以提及文字常量区，那么一定是更有加分的。&lt;/p&gt;
&lt;p&gt;那么，如果再多想一步，如何让指向字符串的指针所指的值也分配在堆上呢？办法有很多，比如malloc之后用strncpy，有兴趣可以试试，你会发现，这个时候指向的地址就是在堆上了。不过，千万别忘了这样的之后指针需要被free，不然就会有内存泄漏。另外，其实还有一个很有意思的行为，这个行为凸显出了编译器的机智。如果在这个文件中再定义一个指针，指向的值还是“test”，那么这两个指针指向的地址会是一样的，有兴趣只要稍微在上面的代码中加一点内容就可以验证。这种聪明的行为最直接的好处就是可以节省空间，很多这种细小的行为，至少我觉得真的是很有意思的。&lt;/p&gt;
&lt;p&gt;讲完了指针以及main函数的地址，在示意图中说还有一部分位置是留给命令行参数的。于是，我也做了小小的验证，可以看到，虽然我这个程序执行只有一个命令行参数，也就是程序名，但是不妨碍看看这个参数到底是在哪个区域中。可以看到其地址是在前面分配的栈空间的更高地址，344明显大于1d4，所以说，和示意图中说的一样，命令行参数是位于栈空间之上的。&lt;/p&gt;
&lt;p&gt;剩下来我想展示的是函数的地址，所谓调用函数，其实就是执行某一个地址的代码。所以，可以看到，函数地址是位于可执行区域的，和main的地址在一个区域，maps文件里也表明了这个区域具有的是可读可执行权限。&lt;/p&gt;
&lt;p&gt;另外一个，既然函数是地址，那么按照c语言的规范，就可以使用一个指针指向这个地址，而体现在代码之中，就是函数指针。最后一行，打印了指向add函数的函数指针的地址，因为这个指针是全局定义的，所以指针本身的地址是位于全局的数据去，和globa数据一样。而指向的地址，就是add函数的地址，当然，执行的也就是add函数。&lt;/p&gt;
&lt;p&gt;好了，现在我们使用程序本身打印出程序中不同变量的地址，并且我们知道了，maps 文件可以显示整个虚拟内存地址的分布。而正如上面提到的，还有一个和虚拟内存相关的文件，mem，这个文件就是一个程序虚拟内存的映射。而作为一个文件，就有可能有读写的权限，而下一节，就是让你看看如何hack掉一个正在运行的程序的行为（虚拟内存数据）。&lt;/p&gt;

&lt;p&gt;这一节，我想做的是，改掉一个正在运行的程序的函数指针指向的地址，这样会让一个函数的结果改变，或者说执行自己想要的函数。在一些用心良苦，技术高超的侵入者里，就这一个行为就完全有可能控制你整个电脑。当然，在我这里，我程序本身就知道函数的地址，所以，只要你理解上面所说的，看起来有点太过于玩具。而真正的黑客，会用精心构造好的代码修改掉虚拟内存中任何一个可以有写权限的地方，从而达到为所欲为的目的。&lt;/p&gt;
&lt;p&gt;就像前面所说的，既然我知道一个指针的地址，而且又知道修改后函数应该指向的地址，那么就很简单了，读出这个文件，在这里就是mem文件了，将文件写指针指向这个位置，修改之，大功告成。而完成这个操作，可以选择任一语言，只要有文件操作的接口，而我，选择的是python。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/usr/bin/env python3&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; coding=utf-8&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; sys
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; pid = int(sys.argv[1&lt;span&gt;])
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; address = int(sys.argv[2],16&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; byte_arr =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; num &lt;span&gt;in&lt;/span&gt; range(3&lt;span&gt;,len(sys.argv)):
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     byte_arr.append(int(sys.argv[num],16&lt;span&gt;))
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; mem_filename = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/proc/{}/mem&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(pid)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[*] mem: {}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(mem_filename))
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     mem_file = open(mem_filename, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;rb+&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;except&lt;/span&gt;&lt;span&gt; IOError as e:
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[ERROR] Can not open file {}:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(mem_filename))
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;        I/O error({}): {}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(e.errno, e.strerror))
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     exit(1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;mem_file.seek(address)
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;mem_file.write(bytearray(byte_arr))
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt; mem_file.close()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在执行这个程序时，可能需要使用sudo来提升权限执行。这个python程序很简单，也没啥错误提示，处理的，因为我只是想展示下基本的原理。这个脚本接受的参数依次为pid，你想改变的地址的16进制字符串，比如我想改变的那个函数指针在文件内的偏移就是他的地址 21040，想替换的终极数据，一个byte数组。这里有一点讲究，就是你需要知道一些大端，小端机器的知识，这个并不难，搜索引擎2分钟就可以告诉你答案。我想把这个函数指针指向的地址改成减法函数的地址，看起来应该改成0x10504，也就是传入01，05，04。但是如果你传入这个数据，会发现运行着的showVM程序立刻就崩溃了。而如果你认真学习了关于大端小端的知识，你会发现这里应该传入的其实是04 05 01 00。这个原因，就留给热爱探索的人吧。&lt;/p&gt;
&lt;p&gt;好了，要想看到神奇的事情发生，只需要做两步，第一步，运行showVM，第二步，根据你的输出向这个python文件传入对应的参数，因为我又重新运行了下showVM，所以，下面执行的截图和上面会略有不同：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/159614/201907/159614-20190711224949491-2029614157.png&quot; alt=&quot;&quot; width=&quot;605&quot; height=&quot;42&quot;/&gt;&lt;/p&gt;
&lt;p&gt;准备好，奇迹发生的时刻：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/159614/201907/159614-20190711225008491-1997016783.png&quot; alt=&quot;&quot; width=&quot;635&quot; height=&quot;486&quot;/&gt;&lt;/p&gt;
&lt;p&gt;你可以看到，正在运行的程序，得到的结果变了，本来是10+20=30，现在变成了10-20=-10了。函数指针的地址也变了，确实指向了del。就这一套小把戏，理论上你可以改这个输出中的任意地址，但是实际上，有些你是改不了的，因为权限问题。&lt;/p&gt;
&lt;p&gt;是不是很神奇？你还可以想想到其他有意思的实验，比如修改掉一个运行程序的字符串。方法也并不复杂，从maps文件里找到heap段的范围，在这个范围里搜索需要的字符串。有可能搜不到，因为按照上面说的，字面量字符串可能不是存储在heap区域的，而他所存储的区域你是无法修改的。这里假设在heap中搜到你所需要的字符串，那么剩下的就是找到这个位置，修改其中的内容，你会发现和上面一摸一样的效果。&lt;/p&gt;
&lt;p&gt;最后我想说的是，如果观察maps文件更仔细一点，你会发现当你执行同一个程序，开头的三个段地址是不会改变的，但是heap开始的地址貌似并不是固定的，为什么要这么做？这里涉及到虚拟内存实现中的一个常见技术，这里会有一个随机gap，目的是增加安全性。因为前三段是固定的，而heap又是如此重要，因为你完全可以改变heap中的内容来改变一个指针指向的内容。所以一段随机的偏移可以让侵入者不那么容易的找到heap段里的数据。一个简单的操作带来的是一个安全性不小的提升，扰动其实是特别美妙的事情，随机性才让我们的世界变得如此丰富多彩。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/159614/201907/159614-20190711230724492-2141751872.png&quot; alt=&quot;&quot; width=&quot;758&quot; height=&quot;92&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/159614/201907/159614-20190711230733148-793860465.png&quot; alt=&quot;&quot; width=&quot;757&quot; height=&quot;98&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这篇文章也在我的公众号同步发表，我的这个公众号嘛，佛系更新，当然，本质上是想到一个话题不容易（懒的好借口），欢迎关注哦：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/159614/201907/159614-20190711232412708-267689402.jpg&quot; alt=&quot;&quot; width=&quot;234&quot; height=&quot;234&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 11 Jul 2019 15:25:00 +0000</pubDate>
<dc:creator>一心一怿</dc:creator>
<og:description>虚拟内存的种种以及如何hack掉一个正在运行的程序的内存</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ZXYloveFR/p/11150523.html</dc:identifier>
</item>
<item>
<title>Flutter学习笔记（5）--Dart运算符 - CurtisWgh</title>
<link>http://www.cnblogs.com/upwgh/p/11173472.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/upwgh/p/11173472.html</guid>
<description>&lt;p&gt;&lt;span&gt;先给出一个Dart运算符表，接下来在逐个解释和使用。如下：&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;1&quot; align=&quot;left&quot;&gt;&lt;caption&gt; &lt;/caption&gt;
&lt;tbody readability=&quot;7.5&quot;&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;&lt;span&gt;                         &lt;strong&gt;描述&lt;/strong&gt;                                       &lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;                                &lt;strong&gt;运算符                                              &lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;一元后缀&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;expr++　　expr--　　()　　[]　　.　　?.&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;一元前缀&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;-expr　　!expr　　~expr　　++expr　　--expr&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;乘法类型&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;*　　/　　%　　~/&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;加法类型&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;+　　-&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;移位运算符&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&amp;lt;&amp;lt;　　&amp;gt;&amp;gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;与位运算&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&amp;amp;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;异或位运算&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;^&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;或位运算&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;|&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;关系和类型测试&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&amp;gt;=　　&amp;lt;=　　&amp;gt;　　&amp;lt;　　as　　is　　is!&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;等式&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;== 　　!=&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;逻辑与&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;逻辑或&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;||&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;条件&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;expr1?expr2:expr3&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;级联&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;..&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;span&gt;赋值&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;=　　*=　　/=　　~/=　　%=　　+=　　-=　　&amp;lt;&amp;lt;=　　&amp;gt;&amp;gt;=　　&amp;amp;=　　^=　　|=　　??=&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;





















&lt;p&gt;&lt;span&gt;注：在上面的运算符表中，操作符的优先级由上到下逐个减小，上面行内的操作符优先级大于下面行内的操作符；&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;一.算数运算符&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; a = &lt;span&gt;10&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; b = &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
print(a &lt;/span&gt;+ b); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;
print(a - b); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;8   &lt;/span&gt;
print(a * b); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;
print(a / b); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;5.0 这个不是整除，值是duoble类型的&lt;/span&gt;
print(a ~/ b);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;5 整除，余数部分舍弃取整&lt;/span&gt;
print(a % b);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;0 去余数&lt;/span&gt;

&lt;span&gt;var&lt;/span&gt;++，&lt;span&gt;var&lt;/span&gt;--，++&lt;span&gt;var&lt;/span&gt;，--&lt;span&gt;var&lt;/span&gt;&lt;span&gt;
前缀的递增或递减和后缀的递增或递减和java中是一样的；
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; a = &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; b = a++;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;先赋值，再自增&lt;/span&gt;
print(b+&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;+a);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2，3&lt;/span&gt;

&lt;span&gt;int&lt;/span&gt; a = &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; b = a--;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;先赋值，再自减&lt;/span&gt;
print(b+&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;+a);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2，1&lt;/span&gt;

&lt;span&gt;int&lt;/span&gt; a = &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; b = ++a;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;再自增，先赋值&lt;/span&gt;
print(b+&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;+a);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3，3&lt;/span&gt;

&lt;span&gt;int&lt;/span&gt; a = &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; b = --a;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;再自减，先赋值&lt;/span&gt;
print(b+&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;+a);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1，1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;二.关系运算符&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; a = &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; b = &lt;span&gt;3&lt;/span&gt;&lt;span&gt;;
print(a &lt;/span&gt;== b);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;
print(a != b);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
print(a &amp;gt;= b);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;
print(a &amp;lt;= b);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
print(a &amp;gt; b);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;
print(a &amp;lt; b);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;三.类型测试操作符&lt;/h2&gt;
&lt;p&gt;as，is和is!操作符在运行时用于检查类型非常方便，和java中的用法相同，含义如下所示：&lt;/p&gt;
&lt;table border=&quot;1&quot; align=&quot;left&quot;&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;strong&gt;&lt;span&gt;　　　　　　操作符                   &lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;span&gt;　　　　　　　　　　　含义　　　　　　　　　　&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;as&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;类型转换&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;is&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;当对象是相应类型时返回true&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;is!&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;当对象不是相应类型时返回true&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;





&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt;(mClassType &lt;span&gt;is&lt;/span&gt;&lt;span&gt; User){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;相同类型，处理一些操作&lt;/span&gt;
    mClassType.name = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello word！&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;四.赋值操作符&lt;/h2&gt;
&lt;p&gt;赋值运算没有什么好说的，这里就只强调一下??=的用法吧；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;一般赋值操作，将value赋值给某一变量&lt;/span&gt;
a =&lt;span&gt; value;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;??=，这个赋值操作符仅在变量为null的时候才会进行赋值&lt;/span&gt;
b ??= value;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果b为null，则将value的值赋给b，否则，b保持不变
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;前面我们有说过，在Dart里面，变量如果没有初始化赋值的话，默认值就是null，这个时候，使用??=给b赋值是可以的，如果初始化的时候就给了b一个值，那么再使用??=进行赋值，b的值是不会变的；&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;五.逻辑运算符&lt;/h2&gt;
&lt;table border=&quot;1&quot; align=&quot;left&quot;&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;strong&gt;&lt;span&gt;　　　　　　操作符                   &lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;span&gt;　　　　　　　　　　　含义　　　　　　　　　　&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;！expr&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;反转表达式（将false更改为true，反之亦然）&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;||&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;逻辑或&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;span&gt;逻辑与&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;





&lt;h2&gt;六.位运算符&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
final value = &lt;span&gt;0x22&lt;/span&gt;&lt;span&gt;;
final bitmask &lt;/span&gt;= &lt;span&gt;0x0f&lt;/span&gt;&lt;span&gt;;

assert((value &lt;/span&gt;&amp;amp; bitmask)  == &lt;span&gt;0x02&lt;/span&gt;);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 与&lt;/span&gt;
assert((value &amp;amp; ~bitmask) == &lt;span&gt;0x20&lt;/span&gt;);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 与非&lt;/span&gt;
assert((value | bitmask)  == &lt;span&gt;0x2f&lt;/span&gt;);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 或&lt;/span&gt;
assert((value ^ bitmask)  == &lt;span&gt;0x2d&lt;/span&gt;);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 异或&lt;/span&gt;
assert((value &amp;lt;&amp;lt; &lt;span&gt;4&lt;/span&gt;)       == &lt;span&gt;0x220&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 左移&lt;/span&gt;
assert((value &amp;gt;&amp;gt; &lt;span&gt;4&lt;/span&gt;)       == &lt;span&gt;0x02&lt;/span&gt;);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 右移&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;七.条件表达式&lt;/h2&gt;
&lt;p&gt;在Dart里，和java一样有三元运算&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; result = isTrue ? &lt;span&gt;'&lt;/span&gt;&lt;span&gt;result1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; : &lt;span&gt;'&lt;/span&gt;&lt;span&gt;result2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这种是通过布尔类型进行判断，如果条件为真，返回result1，反之条件为false，则返回result2；

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;还有一种就是判断条件是否为空，如果数据1不为空，就返回数据1，反之，如果数据1为空，则返回数据2；&lt;/span&gt;
String playerName(String name) =&amp;gt; name ?? &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Guest&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果name的值不为空，返回name的值，如果name的值为空，返回‘Guest’；&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;八.级联操作&lt;/h2&gt;
&lt;p&gt;级联操作用两个点（..）表示（严格来说的话，级联的双点符号不是运算符，这这是Dart语法的一部分），可对同一对象执行一系列操作，类似Java语言里面的点点点处理，级联操作主要目的是为了简化代码，示例如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
querySelector(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#btnOk)//获取一个id为btnOk的按钮对象&lt;/span&gt;
    ..text = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;确定&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;给按钮设置文本为'确定'&lt;/span&gt;
    ..classes.add(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ButtonOKStyle&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;给这个按钮添加一个叫'ButtonOKStyle'的样式&lt;/span&gt;
    ..onClick.listen((e) =&amp;gt; window.alert(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;确定&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;))；&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置监听事件，事件弹出一个显示‘确定’的alert

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这样的操作相当于如下操作：&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; button = querySelector(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#btnOk);&lt;/span&gt;
button.text = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;确定&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
button.classes.add(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ButtonOKStyle&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
button.onClick.listen((e) &lt;/span&gt;=&amp;gt; window.alert(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;确定&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;));
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;下一章节：&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/upwgh/p/11173540.html&quot;&gt;Flutter学习笔记（6）--Dart流程控制语句&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 11 Jul 2019 15:19:00 +0000</pubDate>
<dc:creator>CurtisWgh</dc:creator>
<og:description>Dart运算符：一元后缀、一元前缀、乘法类型、加法类型、移位运算符、与位运算、异或位运算、或位运算、关系和类型测试、等式、逻辑与、逻辑或、条件、级联、赋值；</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/upwgh/p/11173472.html</dc:identifier>
</item>
</channel>
</rss>