<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>一个基于Consul的.NET Leader选举类库 - 波斯马</title>
<link>http://www.cnblogs.com/bossma/p/a-dotnet-leader-election-library-based-on-consul.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bossma/p/a-dotnet-leader-election-library-based-on-consul.html</guid>
<description>&lt;p&gt;前段时间有传言说Consul将不能在我国继续使用，后被查明是因法律问题Vault企业版产品不能在国内销售。Valut和Consul都是HashiCorp公司的产品，并且都推出了开源版本，继续使用开源版本都是没有问题的，虚惊一场。Consul是一款优秀的服务发现和配置管理产品，基于其提供的Session机制，可以很方便的实现Leader选举功能。这篇文章将介绍我编写的一个基于Consul的.NET Leader选举类库。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;111.49150104603&quot;&gt;
&lt;p&gt;前段时间有传言说Consul将不能在我国继续使用，后被查明是因法律问题Vault企业版产品不能在国内销售。Valut和Consul都是HashiCorp公司的产品，并且都推出了开源版本，继续使用开源版本都是没有问题的，虚惊一场。Consul是一款优秀的服务发现和配置管理产品，基于其提供的Session机制，可以很方便的实现Leader选举功能。这篇文章将介绍我编写的一个基于Consul的.NET Leader选举类库。&lt;/p&gt;
&lt;h2&gt;基于Consul的Leader选举原理&lt;/h2&gt;
&lt;p&gt;1、参加选举的程序可以在Consul中创建一个Session，这个Session的存活状态依赖于当前程序的Consul健康检查状态， 一旦健康检查处于Critical状态，则对应的Session就会失效。&lt;/p&gt;
&lt;p&gt;2、使用这个Session去锁定某个Consul Key/Value，只有一个Session能成功锁住KV，拥有这个Session的程序即为Leader。&lt;/p&gt;
&lt;p&gt;3、Leader选举成功后，所有节点还要继续阻塞查询上边的Consul Key/Value，如果KV绑定的Session失效了， 所有节点可以立即发现并发起一次Leader选举，并选举出1个Leader。&lt;/p&gt;
&lt;h2&gt;使用说明&lt;/h2&gt;
&lt;h3&gt;1、启动本机Consul&lt;/h3&gt;
&lt;p&gt;当前的版本依赖本机Consul，后续会支持配置远程Consul地址。&lt;/p&gt;
&lt;p&gt;如果本地环境已经配置Consul，保证其正常运行即可。&lt;/p&gt;
&lt;p&gt;如果本地环境没有配置Consul，可以下载后以开发模式快速启动，以方便体验Leader选举功能。&lt;/p&gt;
&lt;p&gt;下载地址：&lt;a href=&quot;https://www.consul.io/downloads&quot; rel=&quot;nofollow&quot;&gt;https://www.consul.io/downloads&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;启动命令：./consul agent -dev&lt;/p&gt;
&lt;h3&gt;2、安装Nuget包&lt;/h3&gt;
&lt;p&gt;NuGet包地址：&lt;a href=&quot;https://www.nuget.org/packages/FireflySoft.LeaderElection&quot; rel=&quot;nofollow&quot;&gt;https://www.nuget.org/packages/FireflySoft.LeaderElection&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;3、编写Leader选举代码&lt;/h3&gt;
&lt;p&gt;首先创建LeaderElectionManager的一个实例，传入服务名称、服务Id、leader选举选项等参数，然后调用Watch方法参与选举，并在Watch方法中传入Leader选举结果的处理方法。&lt;/p&gt;
&lt;p&gt;以控制台程序为例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;I am ElectionService1.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 参与Leader选举的多个程序应该使用相同的服务名
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 参与Leader选举的每个程序应该有唯一的服务Id&lt;/span&gt;
            LeaderElectionManager electionManager = &lt;span&gt;new&lt;/span&gt; LeaderElectionManager(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ElectionService&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ElectionService1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LeaderElectionOptions());
            electionManager.Watch(LeaderElectCompletedEventHandler);

            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Start Election...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            Console.Read();
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; LeaderElectCompletedEventHandler(LeaderElectionResult result)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在这里处理Leader选举结果。&lt;/span&gt;
            Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LeaderElectCompleted, Result: {result.IsSuccess}, Current Leader: {result.State.CurrentLeaderId}.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;4、注意事项&lt;/h3&gt;
&lt;h4&gt;选举沉默期&lt;/h4&gt;
&lt;p&gt;LeaderElectionOptions中提供了一个重新选举沉默期：ReElectionSilencePeriod，默认15s。应用场景如下：&lt;/p&gt;
&lt;p&gt;当一个程序的Leader状态失效时，它可能仍在处理某些事务，并且不能立即中止。 这时候如果其它节点马上选举成为Leader，并且开始处理数据，则可能导致数据不一致的状态。&lt;/p&gt;
&lt;h4&gt;Leader优先选举权&lt;/h4&gt;
&lt;p&gt;此类库为Leader增加了优先选举权。应用场景如下：&lt;/p&gt;
&lt;p&gt;Leader状态失效可能只是一种短暂的中断导致的，系统会很快自动恢复，而业务事务的的启动和中止需要进行复杂的处理， 所以我们仍然期望下一次Leader选举时之前的Leader有优先选举权，避免数据同步和加快系统恢复。&lt;/p&gt;
&lt;h3&gt;5、源码开放&lt;/h3&gt;
&lt;p&gt;这么好的东西当然要开源：&lt;a href=&quot;https://github.com/bosima/FireflySoft.LeaderElection&quot;&gt;https://github.com/bosima/FireflySoft.LeaderElection&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;参考文档&lt;/h2&gt;
&lt;p&gt;1、Consul Session机制参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.bossma.cn/consul/consul-leader-election-solution/&quot;&gt;https://blog.bossma.cn/consul/consul-leader-election-solution/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.consul.io/docs/internals/sessions&quot;&gt;https://www.consul.io/docs/internals/sessions&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2、基于Session的Leader选举机制参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://learn.hashicorp.com/consul/developer-configuration/elections&quot;&gt;https://learn.hashicorp.com/consul/developer-configuration/elections&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;如果你有关于Consul的任何使用问题欢迎加入千人Consul QQ交流群：234939415&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Tue, 09 Jun 2020 00:30:00 +0000</pubDate>
<dc:creator>波斯马</dc:creator>
<og:description>前段时间有传言说Consul将不能在我国继续使用，后被查明是因法律问题Vault企业版产品不能在国内销售。Valut和Consul都是HashiCorp公司的产品，并且都推出了开源版本，继续使用开源版</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bossma/p/a-dotnet-leader-election-library-based-on-consul.html</dc:identifier>
</item>
<item>
<title>计算机网络之网络层 - Java伴我余生</title>
<link>http://www.cnblogs.com/reminis/p/13053654.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/reminis/p/13053654.html</guid>
<description>&lt;h2 id=&quot;网络层概述&quot;&gt;网络层概述&lt;/h2&gt;
&lt;p&gt;  网络层的目的是实现两个端系统之间的数据透明传送，具体功能包括寻址和路由选择、连接的建立、保持和终止等。它提供的服务使传输层不需要了解网络中的数据传输和交换技术。如果您想用尽量少的词来记住网络层，那就是&quot;路径选择、路由及逻辑寻址&quot;。&lt;/p&gt;
&lt;p&gt;  网络层中涉及众多的协议，其中包括最重要的协议，也是TCP/IP的核心协议——IP协议。IP协议非常简单，仅仅提供不可靠、无连接的传送服务。IP协议的主要功能有：无连接数据报传输、数据报路由选择和差错控制。与IP协议配套使用实现其功能的还有地址解析协议ARP、逆地址解析协议RARP、因特网报文协议ICMP、因特网组管理协议IGMP。&lt;/p&gt;
&lt;h3 id=&quot;ip协议详解&quot;&gt;IP协议详解&lt;/h3&gt;
&lt;h4 id=&quot;虚拟互连网络&quot;&gt;虚拟互连网络&lt;/h4&gt;
&lt;p&gt;  实际的计算机网络是错综复杂的，物理设备通过使用IP协议，屏蔽了物理网络之间的差异，当网络中的主机使用IP协议连接时，则无需关注网络细节。IP协议使得复杂的实际网络变为一个虚拟互连的网络，还使得网络层可以屏蔽底层细节而专注网络层的数据转发，IP协议解决了在虚拟网络中数据报传输路径的问题。&lt;/p&gt;
&lt;p&gt;  IP地址长度为32位，常分成4个8位，IP地址常使用&lt;span&gt;点分十进制&lt;/span&gt;来表示(0~255.0~255.0~255.0~255)，也就是共有&lt;span class=&quot;math inline&quot;&gt;\(2^{32} = 4294961296\)&lt;/span&gt;个IP地址。下图是IP协议的格式：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202006/1975191-20200606065836323-1350481097.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;我们来看看IP协议的首部：&lt;/p&gt;
&lt;table readability=&quot;3&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;4位版本&lt;/td&gt;
&lt;td&gt;4位首部长度&lt;/td&gt;
&lt;td colspan=&quot;2&quot;&gt;8位服务类型（TOS）&lt;/td&gt;
&lt;td colspan=&quot;4&quot;&gt;16位总长度（字节）&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td colspan=&quot;4&quot;&gt;16位标识&lt;/td&gt;
&lt;td&gt;3位标志&lt;/td&gt;
&lt;td colspan=&quot;3&quot;&gt;13位片偏移&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td colspan=&quot;2&quot;&gt;8位生存时间(TTL)&lt;/td&gt;
&lt;td colspan=&quot;2&quot;&gt;8位协议&lt;/td&gt;
&lt;td colspan=&quot;4&quot;&gt;16位首部校验和&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td colspan=&quot;8&quot;&gt;32位源IP地址&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td colspan=&quot;8&quot;&gt;32位目的IP地址&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td colspan=&quot;8&quot;&gt;选项options（若有）&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td colspan=&quot;8&quot; rowspan=&quot;2&quot;&gt;IP数据&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;版本&lt;/strong&gt;：占4位，指的是IP协议的版本，通信双方的版本必须一致，当前主流版本是4，即IPv4，也有IPv6&lt;br/&gt;&lt;strong&gt;首部位长度&lt;/strong&gt;：占4位，最大数值为15，表示的是IP首部长度，单位是“32位字”（4个字节），也即是IP首部最大长度为60字节&lt;br/&gt;&lt;strong&gt;总长度&lt;/strong&gt;：占16位，最大数值为65535，表示的是IP数据报总长度（IP首部+IP数据）&lt;br/&gt;&lt;strong&gt;TTL&lt;/strong&gt;：占8位，表明IP数据报文在网络中的寿命，每经过一个设备，TTL减1，当TTL=0时，网络设备必须丢弃该报文。作用：避免数据在网络中无限传输，当这个网络报文找不到目的机器时，而进行无限传输，来浪费带宽资源&lt;br/&gt;&lt;strong&gt;协议&lt;/strong&gt;：占8位，表明IP数据所携带的具体数据是什么协议的（如：TCP、UDP等）&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;协议名&lt;/th&gt;
&lt;th&gt;ICMP&lt;/th&gt;
&lt;th&gt;IGMP&lt;/th&gt;
&lt;th&gt;&lt;span&gt;IP&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;TCP&lt;/th&gt;
&lt;th&gt;UDP&lt;/th&gt;
&lt;th&gt;OSPF&lt;/th&gt;
&lt;th&gt;…&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;字段值&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;&lt;span&gt;4&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;17&lt;/td&gt;
&lt;td&gt;89&lt;/td&gt;
&lt;td&gt;…&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;首部校验和&lt;/strong&gt;：占16位，校验IP首部是否有出错&lt;/p&gt;
&lt;h4 id=&quot;ip协议的转发流程&quot;&gt;IP协议的转发流程&lt;/h4&gt;
&lt;p&gt;  在数据链路层的学习中我们知道了MAC地址表，由于IP协议的转发是通过逐跳(hop-by-hop)来实现的，所以在网络层中，存在一个类似于MAC地址表的路由表，路由表是存储的目的IP地址和下一跳IP地址的映射，计算机或者路由器都拥有路由表。路由表如下：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;目的IP地址&lt;/th&gt;
&lt;th&gt;下一跳IP地址&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;IP1&lt;/td&gt;
&lt;td&gt;IP4&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;IP2&lt;/td&gt;
&lt;td&gt;IP5&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;IP3&lt;/td&gt;
&lt;td&gt;IP6&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;…&lt;/td&gt;
&lt;td&gt;…&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202006/1975191-20200606073117501-130891653.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;A设备向C设备在网络层中传输数据的过程如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;A发出目的地为C的IP数据报，&lt;span&gt;查询路由表发现下一跳为E&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;A将数据报发送给E&lt;/li&gt;
&lt;li&gt;E&lt;span&gt;查询路由表发现下一跳为F&lt;/span&gt;，将数据报发送给F&lt;/li&gt;
&lt;li&gt;F&lt;span&gt;查询路由表发现目的地C直接连接&lt;/span&gt;，将数据报发送给C&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;&lt;p&gt;现在结合数据链路层和网络层，再来看一下跨设备传输数据的过程：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;A发出目的地为C的IP数据报，&lt;span&gt;查询路由表发现下一跳为E&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;A将IP数据报交给&lt;span&gt;数据链路层，并告知目的MAC地址是E&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;数据链路层填充&lt;span&gt;源MAC地址A&lt;/span&gt;和&lt;span&gt;目的MAC地址E&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;数据链路层通过物理层将数据发送给E&lt;/li&gt;
&lt;li&gt;E的数据链路层接收到数据帧，&lt;span&gt;把帧数据交给网络层&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;E&lt;span&gt;查询路由表，发现下一跳为F&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;E&lt;span&gt;把数据报交给数据链路层，并告知目的MAC地址为F&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;E的数据链路层&lt;span&gt;封装数据帧并发送&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;F的数据链路层接收到数据帧，&lt;span&gt;把帧数据交给网络层&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;F&lt;span&gt;查询路由表，发现下一跳为C&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;F&lt;span&gt;把数据报交给数据链路层&lt;/span&gt;，并&lt;span&gt;告知目的MAC地址为C&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;F的数据链路层F&lt;span&gt;封装数据帧并发送&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;&lt;p&gt;  从IP协议的转发流程中我们可以看到：数据帧每一跳的MAC地址都在变化，但IP数据报每一跳的IP地址始终不变。但我们会发现一个问题，在网络层中将数据报交给数据链路层，并且需要告知目的MAC地址，但是在网络层中只知道IP地址，我们是如何知道目的MAC地址的呢？这就是ARP协议做的事情了。&lt;/p&gt;
&lt;h3 id=&quot;arp协议&quot;&gt;ARP协议&lt;/h3&gt;
&lt;p&gt;  ARP(Address Resolution Protocol)地址解析协议，将网络层中的32位IP地址，通过ARP协议解析为数据链路层中的48位MAC地址。这个映射关系是存储在ARP缓存表中的。arp -a命令：查看ARP缓存表&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;IP地址&lt;/th&gt;
&lt;th&gt;MAC地址&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;192.168.83.254&lt;/td&gt;
&lt;td&gt;00-50-56-e0-33-40&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;192.168.83.255&lt;/td&gt;
&lt;td&gt;01-00-5e-00-00-16&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;224.0.0.251&lt;/td&gt;
&lt;td&gt;01-00-5e-00-00-fc&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;239.1.2.3&lt;/td&gt;
&lt;td&gt;01-00-5e-40-98-8f&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;255.255.255.255&lt;/td&gt;
&lt;td&gt;01-00-5e-7f-ff-fa&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;  ARP缓存表是ARP协议和RARP协议运行的关键，ARP缓存表缓存了IP地址到硬件地址之间的映射关系，ARP缓存表中的记录并不是永久有效的，有一定的期限。这是因为当你的网络设备，换个网络环境，网络设备的IP地址就可能会发生改变，ARP缓存表中的原来的记录就失效了。当ARP缓存表中有映射关系，就直接查询ARP缓存表；如果没有这个映射关系，ARP协议就会广播，并记录回应得地址信息。&lt;/p&gt;
&lt;p&gt;  RARP(Reverse Address Resolution Protocol)逆地址解析协议，其作用与ARP协议相反，即把数据链路层中48位MAC地址，解析位网络层中的32位IP地址。(R)ARP协议是TCP/IP协议栈里面基础的协议，ARP和RARP的操作对程序员是透明的，理解(R)ARP协议有助于理解网络分层的细节。&lt;/p&gt;
&lt;h3 id=&quot;ip地址的子网划分&quot;&gt;IP地址的子网划分&lt;/h3&gt;
&lt;h4 id=&quot;分类的ip地址&quot;&gt;分类的IP地址&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202006/1975191-20200606081849282-1228121622.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt; &lt;/th&gt;
&lt;th&gt;最小网络号&lt;/th&gt;
&lt;th&gt;最大网络号&lt;/th&gt;
&lt;th&gt;子网数量&lt;/th&gt;
&lt;th&gt;最小主机号&lt;/th&gt;
&lt;th&gt;最大主机号&lt;/th&gt;
&lt;th&gt;主机数量&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;A&lt;/td&gt;
&lt;td&gt;0(00000000)&lt;/td&gt;
&lt;td&gt;127(01111111)&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;span class=&quot;math inline&quot;&gt;\(2^7\)&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;0.0.0&lt;/td&gt;
&lt;td&gt;255.255.255&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;span class=&quot;math inline&quot;&gt;\(2^{24}\)&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;B&lt;/td&gt;
&lt;td&gt;128.0&lt;/td&gt;
&lt;td&gt;191.255&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;span class=&quot;math inline&quot;&gt;\(2^{14}\)&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;0.0&lt;/td&gt;
&lt;td&gt;255.255&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;span class=&quot;math inline&quot;&gt;\(2^{16}\)&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;C&lt;/td&gt;
&lt;td&gt;192.0.0&lt;/td&gt;
&lt;td&gt;223.255.255&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;span class=&quot;math inline&quot;&gt;\(2^{21}\)&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;255&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;span class=&quot;math inline&quot;&gt;\(2^{8}\)&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;特殊的主机号&lt;/strong&gt;：主机号全0表示当前网络段，不可分配为特定主机；主机号为全1表示广播地址，向当前网络段所有主机发消息&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;A类地址网络段全0(00000000)表示特殊网络&lt;/li&gt;
&lt;li&gt;A类地址网络段后7位全1(01111111:127)表示回环地址&lt;/li&gt;
&lt;li&gt;B类地址网络段(10000000.00000000:128.0)是不可使用的&lt;/li&gt;
&lt;li&gt;C类地址网络段(192.0.0)是不可使用的&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;p&gt;实际可使用各类IP地址如下：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt; &lt;/th&gt;
&lt;th&gt;最小网络号&lt;/th&gt;
&lt;th&gt;最大网络号&lt;/th&gt;
&lt;th&gt;子网数量&lt;/th&gt;
&lt;th&gt;最小主机号&lt;/th&gt;
&lt;th&gt;最大主机号&lt;/th&gt;
&lt;th&gt;主机数量&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;A&lt;/td&gt;
&lt;td&gt;&lt;span&gt;1&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;127(01111111)&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(2^7\)&lt;/span&gt;&lt;span&gt;-2&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;0.0.1&lt;/td&gt;
&lt;td&gt;255.255.254&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(2^{24}\)&lt;/span&gt;&lt;span&gt;-2&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;B&lt;/td&gt;
&lt;td&gt;&lt;span&gt;128.1&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;191.255&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(2^{14}\)&lt;/span&gt;&lt;span&gt;-1&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;0.1&lt;/td&gt;
&lt;td&gt;255.254&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(2^{16}\)&lt;/span&gt;&lt;span&gt;-2&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;C&lt;/td&gt;
&lt;td&gt;&lt;span&gt;192.0.1&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;223.255.255&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(2^{21}\)&lt;/span&gt;&lt;span&gt;-1&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;254&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(2^{8}\)&lt;/span&gt;&lt;span&gt;-2&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;  127.0.0.1，通常被称为本地回环地址(Loopback Address)，不属于任何一个有类别地址类。它代表设备的本地虚拟接口，所以默认被看作是永远不会宕掉的接口。在Windows操作系统中也有相似的定义，所以通常在安装网卡前就可以ping通这个本地回环地址。一般都会用来检查本地网络协议、基本数据接口等是否正常的。&lt;/p&gt;
&lt;h4 id=&quot;划分子网&quot;&gt;划分子网&lt;/h4&gt;
&lt;p&gt;  随着互连网应用的不断扩大，原先的IPv4的弊端也逐渐暴露出来，即网络号占位太多，而主机号位太少，所以其能提供的主机地址也越来越稀缺，目前除了使用NAT在企业内部利用保留地址自行分配以外，通常都对一个高类别的IP地址进行再划分，以形成多个子网，提供给不同规模的用户群使用。这里主要是为了在网络分段情况下有效地利用IP地址，通过对主机号的高位部分取作为子网号，从通常的网络位界限中扩展或压缩子网掩码，用来创建某类地址的更多子网。但创建更多的子网时，在每个子网上的可用主机地址数目会比原先减少。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202006/1975191-20200606090201822-318716944.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;上图就把原来的C类地址划分成了两个子网。&lt;br/&gt;  但子网号这么多，有没有办法快速判断某个IP的网络号？这就是子网掩码的作用了，子网掩码是标志两个IP地址是否同属于一个子网的，也是32位二进制地址，其每一个为1代表该位是网络位，为0代表主机位。它和IP地址一样也是使用点式十进制来表示的。如果两个IP地址在子网掩码的按位与的计算下所得结果相同，即表明它们共属于同一子网中。&lt;/p&gt;
&lt;p&gt;  子网掩码由连续的1和连续的0组成，某一个子网的子网掩码具备网络号位数个连续的1&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt;在计算子网掩码时，我们要注意IP地址中的保留地址，即&quot; 0&quot;地址和广播地址，它们是指主机地址或网络地址全为&quot; 0&quot;或&quot; 1&quot;时的IP地址，它们代表着本网络地址和广播地址，一般是不能被计算在内的。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;无分类编址cidr&quot;&gt;无分类编址CIDR&lt;/h4&gt;
&lt;p&gt;  CIDR中没有A、B、C类网络号、和子网划分的概念，CIDR将网络前缀相同的IP地址称为一个“CIDR地址块”，注意网络前缀是任意位数的。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;网络前缀&lt;/th&gt;
&lt;th&gt;主机号&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;/table&gt;&lt;p&gt;斜线记法：193.10.10.129/25 使用二进制表示：&lt;span&gt;11000001.00001010.00001010.1&lt;/span&gt;0000001&lt;br/&gt;无分类地址CIDR相比原来的子网划分更加 灵活：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;CIDR前缀长度&lt;/th&gt;
&lt;th&gt;掩码点分十进制&lt;/th&gt;
&lt;th&gt;地址数&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;/13&lt;/td&gt;
&lt;td&gt;255.248.0.0&lt;/td&gt;
&lt;td&gt;512K&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;/14&lt;/td&gt;
&lt;td&gt;255.252.0.0&lt;/td&gt;
&lt;td&gt;256K&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;/15&lt;/td&gt;
&lt;td&gt;255.254.0.0&lt;/td&gt;
&lt;td&gt;128K&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;/16&lt;/td&gt;
&lt;td&gt;255.255.0.0&lt;/td&gt;
&lt;td&gt;64K&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;/17&lt;/td&gt;
&lt;td&gt;255.255.128.0&lt;/td&gt;
&lt;td&gt;32K&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;/18&lt;/td&gt;
&lt;td&gt;255.255.192.0&lt;/td&gt;
&lt;td&gt;16K&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;/19&lt;/td&gt;
&lt;td&gt;255.255.224.0&lt;/td&gt;
&lt;td&gt;8K&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;网络地址转换nat技术&quot;&gt;网络地址转换NAT技术&lt;/h4&gt;
&lt;p&gt;  IPv4最多只有40+亿个IP地址，早期IP地址的不合理规划导致IP号浪费。在介绍NAT技术之前，首先要知道内网地址和外网地址。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;内网地址：内部机构使用，避免与外网地址重复。三类内网地址如下：
&lt;ul&gt;&lt;li&gt;10.0.0.0~10.255.255.255（支持千万数量级设备）&lt;/li&gt;
&lt;li&gt;172.16.0.0~172.31.255.255（支持百万数量级设备）&lt;/li&gt;
&lt;li&gt;192.168.0.0~192.168.255.255（支持万数量级设备）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;外网地址：全球范围使用，全球公网唯一&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;  网络地址转换技术是发生在本地路由器的，主要功能就是把内网的IP地址转成外网的IP地址来进行外部的通信，并且在接收到数据之后，再把外网IP地址映射成内网IP地址，转发到具体的某个设备上面去。&lt;/p&gt;
&lt;p&gt;  内网多个设备使用同一个外网IP请求外网的服务，外部怎么知道具体是哪个设备在请求的？网络地址转换NAT的英文全称是Network Address Translation，NAT技术用于多个主机通过一个公有IP访问互联网的私有网络中，外部主要是通过端口号来区分到底是内网的哪一个设备进行请求的，这其中有一个NA(P)T表表：示例如下：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202006/1975191-20200606093041521-874851919.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;方向&lt;/th&gt;
&lt;th&gt;旧的地址和端口号&lt;/th&gt;
&lt;th&gt;新的地址与端口号&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;出&lt;/td&gt;
&lt;td&gt;192.168.2.11:6666&lt;/td&gt;
&lt;td&gt;173.21.59.10:16666&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;出&lt;/td&gt;
&lt;td&gt;192.168.2.10:7777&lt;/td&gt;
&lt;td&gt;173.21.59.10:17777&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;入&lt;/td&gt;
&lt;td&gt;173.21.59.10:16666&lt;/td&gt;
&lt;td&gt;192.168.2.11:6666&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;入&lt;/td&gt;
&lt;td&gt;173.21.59.10:17777&lt;/td&gt;
&lt;td&gt;192.168.2.10:7777&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;NAT减缓了IP地址的消耗，但是增加了网络通信的复杂度&lt;/p&gt;
&lt;h3 id=&quot;icmp协议&quot;&gt;ICMP协议&lt;/h3&gt;
&lt;p&gt;  ICMP协议全称是网际控制报文协议（Internet Control Message Protocol）,ICMP协议可以报告错误信息或者异常情况&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202006/1975191-20200606102001059-1750108806.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;ICMP协议首部:&lt;/p&gt;
&lt;table&gt;&lt;tr&gt;&lt;td&gt;8位类型&lt;/td&gt;
&lt;td&gt;8位代码&lt;/td&gt;
&lt;td&gt;16位校验和&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td colspan=&quot;3&quot;&gt;ICMP报文数据&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;&lt;p&gt;ICMP报文分为：差错报告报文和询问报文:&lt;/p&gt;
&lt;table readability=&quot;2&quot;&gt;&lt;tr&gt;&lt;td&gt;ICMP报文种类&lt;/td&gt;
&lt;td&gt;类型的值&lt;/td&gt;
&lt;td&gt;报文类型&lt;/td&gt;
&lt;td&gt;具体代码&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td rowspan=&quot;7&quot;&gt;差错报告报文&lt;/td&gt;
&lt;td rowspan=&quot;2&quot;&gt;3（终点不可达）&lt;/td&gt;
&lt;td&gt;网络不可达&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;主机不可达&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td rowspan=&quot;2&quot;&gt;5（重定向）&lt;/td&gt;
&lt;td&gt;对网络重定向&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;对主机重定向&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;传输超时&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td rowspan=&quot;2&quot;&gt;12&lt;/td&gt;
&lt;td&gt;坏的IP头&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;缺少其他必要参数&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td rowspan=&quot;2&quot;&gt;询问报文&lt;/td&gt;
&lt;td&gt;0或8&lt;/td&gt;
&lt;td&gt;回送(Echo)请求或应答&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;13或14&lt;/td&gt;
&lt;td&gt;时间戳(Timestamp)请求或应答&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;&lt;h4 id=&quot;icmp协议的应用&quot;&gt;ICMP协议的应用&lt;/h4&gt;
&lt;p&gt;ping应用：我们可以通过ping命令进行简单的网络故障排查：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;ping本地回环地址，一般情况下，都会得到返回的，如果得不到返回，则说明你的计算机的协议栈出现了问题，这个时候就可能需要重装系统，或者是重新安装这个协议栈&lt;/li&gt;
&lt;li&gt;ping网关地址，即路由器地址，如果能得到返回的话，则说明本机到路由器的通路是通的，如果没有返回的话，则说明你的wifi，或者你的网线连接是有问题的&lt;/li&gt;
&lt;li&gt;ping远端地址，如果不通的话，则说明你的家到ISP之间的网络是故障的，此时就需要联系网络服务商（移动、电信、联通）进行排查。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Traceroute应用：Traceroute可以探测IP数据报在网络中走过的路径&lt;/p&gt;
&lt;h3 id=&quot;路由概述&quot;&gt;路由概述&lt;/h3&gt;
&lt;p&gt;  思考：路由表中的下一跳地址是怎么来的？下一跳地址是唯一的吗？下一跳地址是最佳的吗？路由器怎么多，他们是怎么协同工作的？为了解决这些问题，路由表需要一个好的算法去解决这些事情。路由算法实际上是图论的算法，由于网络环境复杂，使得路由算法要比图论的算法更复杂。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202006/1975191-20200607095453310-1517135006.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;  由于互联网的规模是非常大的，互联网环境是非常复杂的，所以我们需要对互联网进行划分。自治系统(Autonomous System)是指处于一个管理机构下的网络设备群，AS内部网络自行管理，AS对外提供一个或者多个出（入）口。自治系统内部路由的协议称为：内部网关协议(RIP、OSPF)， 自治系统外部路由的协议称为：外部网关协议(BGP)。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202006/1975191-20200607095810096-1695686983.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;路由算法&quot;&gt;路由算法&lt;/h4&gt;
&lt;p&gt;  路由算法的本质是距离矢量（DV）算法， 距离矢量（DV）算法介绍如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;每一个节点使用两个向量&lt;span&gt;&lt;span class=&quot;math inline&quot;&gt;\(D_i\)&lt;/span&gt;&lt;/span&gt;和&lt;span&gt;&lt;span class=&quot;math inline&quot;&gt;\(S_i\)&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span class=&quot;math inline&quot;&gt;\(D_i\)&lt;/span&gt;&lt;/span&gt;描述的是当前节点到别的节点的&lt;span&gt;距离&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span class=&quot;math inline&quot;&gt;\(S_i\)&lt;/span&gt;&lt;/span&gt;描述的是当前节点到别的节点的&lt;span&gt;下一节点&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;每一个节点与相邻的节点交换向量&lt;span&gt;&lt;span class=&quot;math inline&quot;&gt;\(D_i\)&lt;/span&gt;&lt;/span&gt;和&lt;span&gt;&lt;span class=&quot;math inline&quot;&gt;\(S_i\)&lt;/span&gt;&lt;/span&gt;的信息&lt;/li&gt;
&lt;li&gt;&lt;span&gt;每一个节点根据交换的信息更新自己的节点信息&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202006/1975191-20200607103841300-328663666.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;现在假设有A的距离矢量信息，收到的距离矢量信息如下图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202006/1975191-20200607105924701-502964357.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;A通过B到各个节点得距离矢量信息如下：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202006/1975191-20200607111321912-1136651588.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;A通过C到各个节点得距离矢量：并更新下一条的节点&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202006/1975191-20200607112341345-1588131792.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;A通过D到各个节点得距离矢量：并更新下一条的节点&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202006/1975191-20200607113133473-2050788803.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;A通过F到各个节点得距离矢量：并更新下一条的节点&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202006/1975191-20200607113342701-737059304.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;rip协议&quot;&gt;RIP协议&lt;/h4&gt;
&lt;p&gt;  RIP(Routing Information Protocol)协议，RIP协议是使用DV算法的一种路由协议。RIP协议把网络的跳数(hop)作为DV算法的距离，每隔30s交换一次路由信息，认为跳数&amp;gt;15的路由则为不可达路由。&lt;/p&gt;
&lt;p&gt;RIP协议的过程&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;路由器初始化路由信息(两个向量&lt;span class=&quot;math inline&quot;&gt;\(D_i\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(S_i\)&lt;/span&gt;)&lt;/li&gt;
&lt;li&gt;对相邻路由器X发过来的信息，对信息的内容进行修改（下一跳地址设置为X，所有距离加1）
&lt;ol&gt;&lt;li&gt;检索本地路由，将信息中新的路由插入到路由表里面&lt;/li&gt;
&lt;li&gt;检索本地路由，对于下一跳为X的，更新为修改后的信息&lt;/li&gt;
&lt;li&gt;检索本地路由，对比相同目的的距离，如果新信息的距离更小，则更新本地路由表&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;如果3分钟没有收到相邻的路由信息，则把相邻路由设置为不可达(16跳)&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;RIP协议的优缺点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;优点：实现简单，开销很小。&lt;/li&gt;
&lt;li&gt;缺点：故障信息传递慢。也就是随便相信“隔壁老王”，“自己不思考” “视野不够”。因为RIP协议每一个路由器它只看到相邻路由器的信息，而看不到更远的路由器信息，这也限制了网络的规模。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;内部网关路由协议之ospf协议&quot;&gt;内部网关路由协议之OSPF协议&lt;/h3&gt;
&lt;h4 id=&quot;链路状态（ls）协议&quot;&gt;链路状态（LS）协议&lt;/h4&gt;
&lt;p&gt;  链路状态（LS）协议：向所有的路由器发送消息，也就是一传十、十传百，只和相邻的路由器交换信息。消息描述该路由器与相邻路由器的&lt;span&gt;链路状态&lt;/span&gt;，每隔30s交换路由信息，只有链路状态发生变化时，才发送更新信息。&lt;/p&gt;
&lt;h4 id=&quot;dijkstra（迪杰斯特拉）算法&quot;&gt;Dijkstra（迪杰斯特拉）算法&lt;/h4&gt;
&lt;p&gt;  Dijkstra算法是著名的图算法，Dijkstra算法解决有权图从一个节点到其他节点的最短路径问题，“以起始点为中心，向外层层扩展”。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202006/1975191-20200608080223076-1466716109.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;Dijkstra（迪杰斯特拉）算法定义：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;初始化两个集合(S, U)（S为只有初始顶点点A的集合，U为其他顶点集合）&lt;/li&gt;
&lt;li&gt;如果U不为空， 对U集合顶点进行距离的排序，并取出距离A最近的一个顶点D&lt;br/&gt;i. 将顶点D的纳入S集合&lt;br/&gt;ii. 更新通过顶点D到达U集合所有点的距离（如果距离更小则更新，否则不更新）&lt;br/&gt;iii. 重复2步骤&lt;/li&gt;
&lt;li&gt;直到U集合为空，算法完成&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202006/1975191-20200608082807693-2094863869.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;ospf协议的过程&quot;&gt;OSPF协议的过程&lt;/h4&gt;
&lt;p&gt;  OSPF(Open Shortest Path First：开放最短路径优先)，OSPF协议的核心是&lt;span&gt;Dijkstra算法&lt;/span&gt;。OSPF协议的过程：路由器接入网络，路由器向邻居发出问候信息，与邻居交流链路状态数据库，广播和更新未知路由。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;RIP协议&lt;/th&gt;
&lt;th&gt;OSPF协议&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr&gt;&lt;td&gt;从邻居看网络&lt;/td&gt;
&lt;td&gt;整个网络的拓扑&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;在路由器之间累加距离&lt;/td&gt;
&lt;td&gt;Dijkstra算法计算最短路径&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;频繁、周期更新，收敛很慢&lt;/td&gt;
&lt;td&gt;状态变化更新，收敛很快&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;路由间拷贝路由信息&lt;/td&gt;
&lt;td&gt;路由间传递链路状态，自行计算路径&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;外部网关路由协议之bgp协议&quot;&gt;外部网关路由协议之BGP协议&lt;/h3&gt;
&lt;p&gt;  BGP(Border Gateway Protocol: 边际网关协议)，BGP协议是运行在AS之间的一种协议。由于互联网的规模很大，AS内部使用不同的路由协议。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202006/1975191-20200608091528109-1360839756.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;  AS之间需要考虑除网络特性以外的一些因素（政治、安全…），BGP(Border Gateway Protocol，边界网关协议)，BGP协议能够找到一条到达目的比较好的路由，AS之间通过BGP发言人来进行路由信息的交换。BGP发言人(speaker)：BGP并不关心内部网络拓扑，AS之间通过BGP发言人交流信息，BGP Speaker可以人为配置策略。&lt;/p&gt;
&lt;p&gt;总结：网络层负责对子网间的数据包进行路由选择。此外，网络层还可以实现拥塞控制、网际互连等功能；网络层的基本数据单位为IP数据报；包含的主要协议：IP协议（Internet Protocol，因特网互联协议）、ICMP协议（Internet Control Message Protocol，因特网控制报文协议）、ARP协议（Address Resolution Protocol，地址解析协议）以及RARP协议（Reverse Address Resolution Protocol，逆地址解析协议）。网络层重要的设备是路由器。常见的路由选择协议有：RIP协议、OSPF协议。RIP协议 ：底层是贝尔曼福特算法，它选择路由的度量标准（metric)是跳数，最大跳数是15跳，如果大于15跳，它就会丢弃数据包；OSPF协议 ：Open Shortest Path First开放式最短路径优先，底层是迪杰斯特拉算法，是链路状态路由选择协议，它选择路由的度量标准是带宽，延迟。&lt;/p&gt;
</description>
<pubDate>Tue, 09 Jun 2020 00:01:00 +0000</pubDate>
<dc:creator>Java伴我余生</dc:creator>
<og:description>网络层概述 网络层的目的是实现两个端系统之间的数据透明传送，具体功能包括寻址和路由选择、连接的建立、保持和终止等。它提供的服务使传输层不需要了解网络中的数据传输和交换技术。如果您想用尽量少的词来记住网</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/reminis/p/13053654.html</dc:identifier>
</item>
<item>
<title>Java基础？看完以后再也不惧怕面试了 - 大魔王先生</title>
<link>http://www.cnblogs.com/wtzbk/p/13068349.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wtzbk/p/13068349.html</guid>
<description>&lt;h3 id=&quot;h&quot;&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;这篇文章主要是Java基础部分，主要分为3个部分:Java集合、Java多线、JVM；这些东西帮助我面试成功率提升了很多。后面还有中间件Spring、Redis、RocketMQ等等吧，祝愿大家找到好的工作加油！&lt;/p&gt;
&lt;h3 id=&quot;hjava&quot;&gt;&lt;span&gt;Java集合&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;这部分整理不算细致，也基本够大家应付基本的面试的，当然面试是次要的，主要的还是要提升自己，主要还是要在平常下功夫。该部分主要分为3个部分:Map、List、Set。&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/1005447/202006/1005447-20200608072829842-164093419.png&quot; alt=&quot;Map&quot; title=&quot;Map&quot;/&gt;Map&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1005447/202006/1005447-20200608073032093-1860553662.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;h3 id=&quot;hjava-1&quot;&gt;&lt;span&gt;Java多线程&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;这部分之前已经发过，后面有补充很多东西和修复了一些写的有问题部分，这里还是整体简单介绍一下，总体分为13个部分，包括基础(Thread相关)、同步原语(synchronized、volatile、final)、内存模型(JMM)、LOCK(常见的锁)、原子锁(乐观锁)、并发容器、多线程中常用的一些概念、并发工具类(CountDownLatch等)、Fork-join、阻塞队列、FutureTask和面试题，基本覆盖了Java并发体系的知识，大家在看完前12部分以后，还可以根据我后面的面试题部分进行回忆，参看自己那部分还没掌握，然后进行学习补充；有些部分为了大家在图片上能看到主要的部分进行收起的操作，细节后期会将下载地址给大家公布一下；&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/1005447/202006/1005447-20200608074659552-1125742120.png&quot; alt=&quot;基础&quot; title=&quot;基础&quot;/&gt;基础&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1005447/202006/1005447-20200608075034585-1725280614.png&quot; alt=&quot;同步原语&quot; title=&quot;同步原语&quot;/&gt;同步原语&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1005447/202006/1005447-20200608075141887-1440263954.png&quot; alt=&quot;内存模型&quot; title=&quot;内存模型&quot;/&gt;内存模型&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1005447/202006/1005447-20200608075306322-1602493771.png&quot; alt=&quot;Lock&quot; title=&quot;Lock&quot;/&gt;Lock&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1005447/202006/1005447-20200608075352436-733953283.png&quot; alt=&quot;原子类&quot; title=&quot;原子类&quot;/&gt;原子类&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1005447/202006/1005447-20200608075454039-1902127210.png&quot; alt=&quot;并发容器&quot; title=&quot;并发容器&quot;/&gt;并发容器&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1005447/202006/1005447-20200608075601105-783137864.png&quot; alt=&quot;线程池&quot; title=&quot;线程池&quot;/&gt;线程池&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1005447/202006/1005447-20200608075704952-1355318749.png&quot; alt=&quot;概念&quot; title=&quot;概念&quot;/&gt;概念&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1005447/202006/1005447-20200608075748048-1936288743.png&quot; alt=&quot;并发工具类&quot; title=&quot;并发工具类&quot;/&gt;并发工具类&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1005447/202006/1005447-20200608075820944-895666492.png&quot; alt=&quot;Fork-join&quot; title=&quot;Fork-join&quot;/&gt;Fork-join&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1005447/202006/1005447-20200608075901567-97620801.png&quot; alt=&quot;阻塞队列&quot; title=&quot;阻塞队列&quot;/&gt;阻塞队列&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1005447/202006/1005447-20200608075943290-1728082959.png&quot; alt=&quot;FutureTask&quot; title=&quot;FutureTask&quot;/&gt;FutureTask&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1005447/202006/1005447-20200608081123778-1246908667.png&quot; alt=&quot;面试题&quot; title=&quot;面试题&quot;/&gt;面试题
&lt;h3 id=&quot;hjvm&quot;&gt;&lt;span&gt;JVM部分&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;主要分为5部分:类加载机制、内存结构、执行引擎、垃圾回收、常用命令，其中类加载机制、内存结构、垃圾回收部分比较细致，对于JVM部分还是对解决线上问题以后才能有更深入了解知识点只是刚刚开始，这里面的水很深，做好CodeReview也可以减少很多这方面问题；&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/1005447/202006/1005447-20200608082009890-246976834.png&quot; alt=&quot;类加载机制&quot; title=&quot;类加载机制&quot;/&gt;类加载机制&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1005447/202006/1005447-20200608082130359-381518664.png&quot; alt=&quot;内存结构&quot; title=&quot;内存结构&quot;/&gt;内存结构&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1005447/202006/1005447-20200608082130359-381518664.png&quot; alt=&quot;垃圾回收&quot; title=&quot;垃圾回收&quot;/&gt;垃圾回收
&lt;h3 id=&quot;h-1&quot;&gt;&lt;span&gt;结束&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;大家觉得有用，欢迎关注下公众号，回复Java基础或者基础，就可以看到排版好以后的PDF，欢迎下载！&lt;/p&gt;
&lt;img src=&quot;https://img2018.cnblogs.com/blog/1005447/201912/1005447-20191208220755887-1955863761.png&quot; alt=&quot;&quot; width=&quot;404&quot; height=&quot;395&quot; title=&quot;&quot;/&gt;</description>
<pubDate>Mon, 08 Jun 2020 23:51:00 +0000</pubDate>
<dc:creator>大魔王先生</dc:creator>
<og:description>前言 这篇文章主要是Java基础部分，主要分为3个部分:Java集合、Java多线、JVM；这些东西帮助我面试成功率提升了很多。后面还有中间件Spring、Redis、RocketMQ等等吧，祝愿大家</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wtzbk/p/13068349.html</dc:identifier>
</item>
<item>
<title>经典卷积神经网络算法(4)：GoogLeNet - 奥辰</title>
<link>http://www.cnblogs.com/chenhuabin/p/13070185.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenhuabin/p/13070185.html</guid>
<description>&lt;!--[if IE]&gt;
    &lt;div class=&quot;unsupported-browser&quot;&gt;
        &amp;#35813;&amp;#39029;&amp;#38754;&amp;#19981;&amp;#25903;&amp;#25345; Internet Explorer &amp;#27983;&amp;#35272;&amp;#22120;&amp;#65292;&amp;#24314;&amp;#35758;&amp;#20351;&amp;#29992;
        &lt;a href=&quot;https://www.google.cn/intl/zh-CN/chrome/&quot;&gt;Google Chrome&lt;/a&gt;,
        &lt;a href=&quot;https://www.mozilla.org/zh-CN/firefox/&quot;&gt;Firefox&lt;/a&gt; &amp;#25110;
        &lt;a href=&quot;https://www.microsoftedgeinsider.com/zh-CN/&quot;&gt;Microsoft Edge&lt;/a&gt;
    &lt;/div&gt;
&lt;![endif]--&gt;
    &lt;div class=&quot;center-container &quot;&gt;
        &lt;div class=&quot;center-body card  h-sm-100&quot;&gt;
            &lt;div class=&quot;card-body&quot;&gt;
                


&lt;div class=&quot;login-top text-center&quot;&gt;
    &lt;span class=&quot;login-title&quot;&gt;博客园用户登录&lt;/span&gt;
    &lt;a href=&quot;https://www.cnblogs.com/&quot;&gt;
        &lt;svg class=&quot;login-sign&quot;&gt;&lt;use xlink:href=&quot;#icon-login-sign&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;
    &lt;p&gt;代码改变世界&lt;/p&gt;
&lt;/div&gt;
&lt;form id=&quot;loginForm&quot; method=&quot;post&quot; onsubmit=&quot;return false&quot;&gt;
    
        &lt;div class=&quot;form-group&quot;&gt;
            &lt;input tabindex=&quot;1&quot; class=&quot;form-control&quot; placeholder=&quot;登录用户名 / 邮箱&quot; autofocus=&quot;&quot; type=&quot;text&quot; data-val=&quot;true&quot; data-val-required=&quot;请输入登录用户名&quot; id=&quot;LoginName&quot; name=&quot;LoginName&quot; value=&quot;&quot;/&gt;&lt;span class=&quot;invalid-feedback field-validation-valid&quot; data-valmsg-for=&quot;LoginName&quot; data-valmsg-replace=&quot;true&quot;/&gt;
            &lt;a class=&quot;txt-forget-sign&quot; href=&quot;https://account.cnblogs.com/forgotloginname&quot;&gt;忘记登录用户名&lt;/a&gt;
        &lt;/div&gt;
        &lt;div class=&quot;form-group&quot;&gt;
            &lt;input tabindex=&quot;2&quot; class=&quot;form-control&quot; placeholder=&quot;密码&quot; type=&quot;password&quot; data-val=&quot;true&quot; data-val-required=&quot;请输入密码&quot; id=&quot;Password&quot; name=&quot;Password&quot;/&gt;&lt;span class=&quot;invalid-feedback field-validation-valid&quot; data-valmsg-for=&quot;Password&quot; data-valmsg-replace=&quot;true&quot;/&gt;
            &lt;a class=&quot;txt-forget-sign&quot; href=&quot;https://account.cnblogs.com/resetpassword&quot;&gt;忘记密码&lt;/a&gt;
        &lt;/div&gt;
        &lt;p&gt;
            &lt;input tabindex=&quot;3&quot; type=&quot;checkbox&quot; id=&quot;IsRemember&quot; name=&quot;IsRemember&quot; value=&quot;true&quot; class=&quot;custom-control-input&quot;/&gt;&lt;label class=&quot;custom-control-label&quot; for=&quot;IsRemember&quot;&gt;记住我&lt;/label&gt;
        &lt;/p&gt;

        &lt;button tabindex=&quot;4&quot; id=&quot;submitBtn&quot; type=&quot;submit&quot; class=&quot;btn-login btn btn-primary btn-sm ladda-button px-4&quot; data-style=&quot;slide-down&quot;&gt;
            &lt;span class=&quot;ladda-label&quot;&gt;登录&lt;/span&gt;
        &lt;/button&gt;
        &lt;div class=&quot;login-footer&quot;&gt;
            &lt;div class=&quot;ajax-error-box&quot;&gt;
                
            &lt;/div&gt;
            &lt;span&gt;没有账户，&lt;a href=&quot;https://account.cnblogs.com/signup&quot;&gt;立即注册&lt;/a&gt;&lt;/span&gt;
        &lt;/div&gt;
    
&lt;input name=&quot;__RequestVerificationToken&quot; type=&quot;hidden&quot; value=&quot;CfDJ8B9DwO68dQFBg9xIizKsC6R1bvU4pAkgMoh9GZopVIL1Lcr3dlUHmcPvxxaD20o7CP68e_r1SF1shciKTamq1g9GORRBvbAyUK4lSzMiBwAnDet87VqgivcE9L8XEzdA4C5KyRjyK7gLNyWrWQ8fjLs&quot;/&gt;&lt;/form&gt;

&lt;input type=&quot;hidden&quot; id=&quot;PublicKey&quot; name=&quot;PublicKey&quot; value=&quot;MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCp0wHYbg/NOPO3nzMD3dndwS0MccuMeXCHgVlGOoYyFwLdS24Im2e7YyhB0wrUsyYf0/nhzCzBK8ZC9eCWqd0aHbdgOQT6CuFQBMjbyGYvlVYU2ZP7kG9Ft6YV6oc9ambuO7nPZh+bvXH0zDKfi02prknrScAKC0XhadTHT3Al0QIDAQAB&quot;/&gt;&lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    </description>
<pubDate>Mon, 08 Jun 2020 23:45:00 +0000</pubDate>
<dc:creator>奥辰</dc:creator>
<dc:language>zh</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://account.cnblogs.com:443/signin?ReturnUrl=https%3A%2F%2Fwww.cnblogs.com%2Fchenhuabin%2Fp%2F13070185.html</dc:identifier>
</item>
<item>
<title>Elasticsearch 别管原理，先run起来 - 龙跃十二</title>
<link>http://www.cnblogs.com/zhonglongbo/p/13070181.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhonglongbo/p/13070181.html</guid>
<description>&lt;blockquote data-tool=&quot;mdnice编辑器&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;少点代码，多点头发&lt;/p&gt;
&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文已经收录至我的GitHub,欢迎大家踊跃star 和 issues。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://github.com/midou-tech/articles&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看文章有两点需要注意：&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li readability=&quot;-1.5&quot;&gt;
&lt;section readability=&quot;3&quot;&gt;&lt;p&gt;本公号讲解的Elasticsearch是基于7.7.0版本，你们在阅读一些相关书籍和博客注意版本，不同版本很多概念会有出入。&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;
&lt;section readability=&quot;2&quot;&gt;&lt;p&gt;文章写作过程中会经常将Elasticsearch简写为Es，阅读过程中需要注意。&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般学习一个新的技术或者产品，第一步就是用起来。什么设计理论，框架源码，都别和我谈，先&lt;strong&gt;run&lt;/strong&gt;起来。这也是在公司看别人项目的绝招。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用起来，有一个很明显的点，是你能感受到他，不然天天看理论知识，看源码会让你觉得你好像懂了，但又心里没底，最终会导致你走火入魔。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天龙叔的主题就是 &lt;strong&gt;学Es，先run起来&lt;/strong&gt;，用起来之后在去探索内部更多问题和原理。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1gex0aitcu7j30zc0iignh.jpg&quot; alt=&quot;Elasticsearch&quot;/&gt;Elasticsearch
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;Elasticsearch安装&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Elasticsearch 的底层是开源库 &lt;a href=&quot;https://lucene.apache.org/&quot;&gt;Lucene&lt;/a&gt;。但是，你没法直接用 Lucene，必须自己写代码去调用它的接口。Elasticsearch 是 Lucene 的封装，提供了 REST API 的操作接口，开箱即用。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Elasticsearch 需要 Java 8 环境。如果你的机器还没安装 Java，可以在网上找个教程安装，注意要保证环境变量&lt;code&gt;JAVA_HOME&lt;/code&gt;正确设置。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;安装完 Java，就可以跟着 &lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/current/zip-targz.html&quot;&gt;官方文档：https://www.elastic.co/guide/en/elasticsearch/reference/current/zip-targz.html&lt;/a&gt; 安装 Elasticsearch。我这里就直接下载压缩包比较简单。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;

$ wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.7.0-darwin-x86_64.tar.gz
$ wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.7.0-darwin-x86_64.tar.gz.sha512
$ shasum -a 512 -c elasticsearch-7.7.0-darwin-x86_64.tar.gz.sha512 

$ tar -xzf elasticsearch-7.7.0-darwin-x86_64.tar.gz
$ &lt;span class=&quot;hljs-built_in&quot;&gt;cd&lt;/span&gt; elasticsearch-7.7.0/
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着，进入解压后的目录，运行下面的命令，启动 Elasticsearch。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;$ ./bin/elasticsearch
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果一切正常，那可能是run起来了，Es默认打开9200端口。测试下是否启动成功，用 curl 工具测试（这个工具后面会写一篇文章介绍，还有上面用的wget），也可以在浏览器访问。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;$ curl localhost:9200 
{
  &lt;span class=&quot;hljs-string&quot;&gt;&quot;name&quot;&lt;/span&gt; : &lt;span class=&quot;hljs-string&quot;&gt;&quot;MacBook-Pro.local&quot;&lt;/span&gt;,
  &lt;span class=&quot;hljs-string&quot;&gt;&quot;cluster_name&quot;&lt;/span&gt; : &lt;span class=&quot;hljs-string&quot;&gt;&quot;elasticsearch&quot;&lt;/span&gt;,
  &lt;span class=&quot;hljs-string&quot;&gt;&quot;cluster_uuid&quot;&lt;/span&gt; : &lt;span class=&quot;hljs-string&quot;&gt;&quot;Z1NxCjE4T6CgTjZmpAVe_A&quot;&lt;/span&gt;,
  &lt;span class=&quot;hljs-string&quot;&gt;&quot;version&quot;&lt;/span&gt; : {
    &lt;span class=&quot;hljs-string&quot;&gt;&quot;number&quot;&lt;/span&gt; : &lt;span class=&quot;hljs-string&quot;&gt;&quot;7.7.0&quot;&lt;/span&gt;,
    &lt;span class=&quot;hljs-string&quot;&gt;&quot;build_flavor&quot;&lt;/span&gt; : &lt;span class=&quot;hljs-string&quot;&gt;&quot;default&quot;&lt;/span&gt;,
    &lt;span class=&quot;hljs-string&quot;&gt;&quot;build_type&quot;&lt;/span&gt; : &lt;span class=&quot;hljs-string&quot;&gt;&quot;tar&quot;&lt;/span&gt;,
    &lt;span class=&quot;hljs-string&quot;&gt;&quot;build_hash&quot;&lt;/span&gt; : &lt;span class=&quot;hljs-string&quot;&gt;&quot;81a1e9eda8e6183f5237786246f6dced26a10eaf&quot;&lt;/span&gt;,
    &lt;span class=&quot;hljs-string&quot;&gt;&quot;build_date&quot;&lt;/span&gt; : &lt;span class=&quot;hljs-string&quot;&gt;&quot;2020-05-12T02:01:37.602180Z&quot;&lt;/span&gt;,
    &lt;span class=&quot;hljs-string&quot;&gt;&quot;build_snapshot&quot;&lt;/span&gt; : &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;,
    &lt;span class=&quot;hljs-string&quot;&gt;&quot;lucene_version&quot;&lt;/span&gt; : &lt;span class=&quot;hljs-string&quot;&gt;&quot;8.5.1&quot;&lt;/span&gt;,
    &lt;span class=&quot;hljs-string&quot;&gt;&quot;minimum_wire_compatibility_version&quot;&lt;/span&gt; : &lt;span class=&quot;hljs-string&quot;&gt;&quot;6.8.0&quot;&lt;/span&gt;,
    &lt;span class=&quot;hljs-string&quot;&gt;&quot;minimum_index_compatibility_version&quot;&lt;/span&gt; : &lt;span class=&quot;hljs-string&quot;&gt;&quot;6.0.0-beta1&quot;&lt;/span&gt;
  },
  &lt;span class=&quot;hljs-string&quot;&gt;&quot;tagline&quot;&lt;/span&gt; : &lt;span class=&quot;hljs-string&quot;&gt;&quot;You Know, for Search&quot;&lt;/span&gt;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;请求9200端口，Elastic 返回一个 JSON 对象，包含当前节点、集群、版本等信息。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;收到这样一个JSON对象，说明启动成功。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;安装整体没什么压力，java环境装好，基本就是开箱即用。程序员最喜欢使用这样的中间件，开箱即用，从不管箱子里面是啥。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;基本概念&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本来run起来就准备说搞点数据进去，在和Es进行交互起来，但是正在准备写数据进索引的时候，发现不对劲。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可能有人根本不知道什么是索引？什么Document。于是 就来了，先普及下基本概念。&lt;/p&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;节点（Node） 与集群（ Cluster）&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Elastic 本质上是一个分布式数据库，允许多台服务器协同工作，每台服务器可以运行多个 Elastic 实例。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;单个 Elastic 实例称为一个节点（node）。一组节点构成一个集群（cluster）。&lt;/p&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;索引（Index）&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Elastic 会索引所有字段，经过处理后写入一个反向索引（Inverted Index），也经常称之为倒排索引。查找数据的时候，直接查找该索引。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Elastic 数据管理的顶层单位就叫做 Index（索引）。它是单个数据库的同义词。每个 Index （即数据库）的名字必须是小写。&lt;/p&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;文档（Document）&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Index 里面单条的记录称为 Document（文档）。许多条 Document 构成了一个 Index。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;写点数据进Es&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基本概念已经有了，知道查找是通过倒排索引进行的，所以数据肯定是存放在索引里面的。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们现在要写数据进Es，其实就是把数据写到Es的索引（index）中，前面已经把Es启动起来了，并没有创建索引。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天写数据就不写代码了，利用ES的一些封装很好的接口，直接命令行操作，后期在用代码写数据进Es。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先创建一个index ，使用curl 工具在命令行操作，这是一个put请求。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-variable&quot;&gt;$curl&lt;/span&gt; -X PUT &lt;span class=&quot;hljs-string&quot;&gt;'localhost:9200/user'&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查看索引是否以及创建成功&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;$ curl -X GET &lt;span class=&quot;hljs-string&quot;&gt;'http://localhost:9200/_cat/indices?v'&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个get请求可以查看当前节点的所有索引&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1gf3jqekoayj319i030jrt.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;妥妥的已经创建成功&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;顺便说下，删除一个索引的命令，DELETE参数表示删除&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-variable&quot;&gt;$curl&lt;/span&gt; -X DELETE &lt;span class=&quot;hljs-string&quot;&gt;'localhost:9200/user'&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到这里索引已经创建好了，可以写点数据进去了。使用接口 /index/_doc/id ，/索引名/_doc/doc_id&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;$ curl -X PUT -H &lt;span class=&quot;hljs-string&quot;&gt;'Content-Type: application/json'&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;'localhost:9200/user/_doc/1'&lt;/span&gt; -d &lt;span class=&quot;hljs-string&quot;&gt;'
{
  &quot;name&quot;: &quot;龙跃十二&quot;,
  &quot;title&quot;: &quot;工程师&quot;,
  &quot;desc&quot;: &quot;一个分享互联网技术和心路历程的star&quot;
}'&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查看当前索引下的所有数据&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;$ curl &lt;span class=&quot;hljs-string&quot;&gt;'localhost:9200/user/_search?pretty=true
&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到这里基本我们已经可以写数据到指定索引了，生产场景不会这么写数据的，都是用代码写海量数据进ES的，这就几条数据也没什么搜索性能可谈的。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我之前工作中日志数据都是TB级别的写到Es中，当遇到这种数据量的搜索时才会感受到搜索引擎的魅力，才会意识到Es的重要性。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里主要是练手和跑通流程，所以造了一些数据到Es中&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;和ES进行交互&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实写数据进Es已经是一种交互了，在讲一些其他的交互接口&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前讲的交互方式主要是通过原生的请求的方式，还没有上升到界面操作，后期在学习的过程中会展现出来。&lt;/p&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;查询交互&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 GET 方法，直接请求&lt;code&gt;/Index/_search&lt;/code&gt;，就会返回所有记录。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;$ curl &lt;span class=&quot;hljs-string&quot;&gt;'localhost:9200/user/_search?pretty=true'&lt;/span&gt;
{
  &lt;span class=&quot;hljs-string&quot;&gt;&quot;took&quot;&lt;/span&gt; : 1,
  &lt;span class=&quot;hljs-string&quot;&gt;&quot;timed_out&quot;&lt;/span&gt; : &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;,
  &lt;span class=&quot;hljs-string&quot;&gt;&quot;_shards&quot;&lt;/span&gt; : {
    &lt;span class=&quot;hljs-string&quot;&gt;&quot;total&quot;&lt;/span&gt; : 1,
    &lt;span class=&quot;hljs-string&quot;&gt;&quot;successful&quot;&lt;/span&gt; : 1,
    &lt;span class=&quot;hljs-string&quot;&gt;&quot;skipped&quot;&lt;/span&gt; : 0,
    &lt;span class=&quot;hljs-string&quot;&gt;&quot;failed&quot;&lt;/span&gt; : 0
  },
  &lt;span class=&quot;hljs-string&quot;&gt;&quot;hits&quot;&lt;/span&gt; : {
    &lt;span class=&quot;hljs-string&quot;&gt;&quot;total&quot;&lt;/span&gt; : {
      &lt;span class=&quot;hljs-string&quot;&gt;&quot;value&quot;&lt;/span&gt; : 3,
      &lt;span class=&quot;hljs-string&quot;&gt;&quot;relation&quot;&lt;/span&gt; : &lt;span class=&quot;hljs-string&quot;&gt;&quot;eq&quot;&lt;/span&gt;
    },
    &lt;span class=&quot;hljs-string&quot;&gt;&quot;max_score&quot;&lt;/span&gt; : 1.0,
    &lt;span class=&quot;hljs-string&quot;&gt;&quot;hits&quot;&lt;/span&gt; : [
      {
        &lt;span class=&quot;hljs-string&quot;&gt;&quot;_index&quot;&lt;/span&gt; : &lt;span class=&quot;hljs-string&quot;&gt;&quot;user&quot;&lt;/span&gt;,
        &lt;span class=&quot;hljs-string&quot;&gt;&quot;_type&quot;&lt;/span&gt; : &lt;span class=&quot;hljs-string&quot;&gt;&quot;_doc&quot;&lt;/span&gt;,
        &lt;span class=&quot;hljs-string&quot;&gt;&quot;_id&quot;&lt;/span&gt; : &lt;span class=&quot;hljs-string&quot;&gt;&quot;1&quot;&lt;/span&gt;,
        &lt;span class=&quot;hljs-string&quot;&gt;&quot;_score&quot;&lt;/span&gt; : 1.0,
        &lt;span class=&quot;hljs-string&quot;&gt;&quot;_source&quot;&lt;/span&gt; : {
          &lt;span class=&quot;hljs-string&quot;&gt;&quot;name&quot;&lt;/span&gt; : &lt;span class=&quot;hljs-string&quot;&gt;&quot;龙跃十二&quot;&lt;/span&gt;,
          &lt;span class=&quot;hljs-string&quot;&gt;&quot;title&quot;&lt;/span&gt; : &lt;span class=&quot;hljs-string&quot;&gt;&quot;工程师&quot;&lt;/span&gt;,
          &lt;span class=&quot;hljs-string&quot;&gt;&quot;desc&quot;&lt;/span&gt; : &lt;span class=&quot;hljs-string&quot;&gt;&quot;一个分享互联网技术和心路历程的star&quot;&lt;/span&gt;
        }
      },
      {
        &lt;span class=&quot;hljs-string&quot;&gt;&quot;_index&quot;&lt;/span&gt; : &lt;span class=&quot;hljs-string&quot;&gt;&quot;user&quot;&lt;/span&gt;,
        &lt;span class=&quot;hljs-string&quot;&gt;&quot;_type&quot;&lt;/span&gt; : &lt;span class=&quot;hljs-string&quot;&gt;&quot;_doc&quot;&lt;/span&gt;,
        &lt;span class=&quot;hljs-string&quot;&gt;&quot;_id&quot;&lt;/span&gt; : &lt;span class=&quot;hljs-string&quot;&gt;&quot;3&quot;&lt;/span&gt;,
        &lt;span class=&quot;hljs-string&quot;&gt;&quot;_score&quot;&lt;/span&gt; : 1.0,
        &lt;span class=&quot;hljs-string&quot;&gt;&quot;_source&quot;&lt;/span&gt; : {
          &lt;span class=&quot;hljs-string&quot;&gt;&quot;name&quot;&lt;/span&gt; : &lt;span class=&quot;hljs-string&quot;&gt;&quot;三y&quot;&lt;/span&gt;,
          &lt;span class=&quot;hljs-string&quot;&gt;&quot;title&quot;&lt;/span&gt; : &lt;span class=&quot;hljs-string&quot;&gt;&quot;工程师&quot;&lt;/span&gt;,
          &lt;span class=&quot;hljs-string&quot;&gt;&quot;desc&quot;&lt;/span&gt; : &lt;span class=&quot;hljs-string&quot;&gt;&quot;只有光头才能变得更强&quot;&lt;/span&gt;
        }
      },
      {
        &lt;span class=&quot;hljs-string&quot;&gt;&quot;_index&quot;&lt;/span&gt; : &lt;span class=&quot;hljs-string&quot;&gt;&quot;user&quot;&lt;/span&gt;,
        &lt;span class=&quot;hljs-string&quot;&gt;&quot;_type&quot;&lt;/span&gt; : &lt;span class=&quot;hljs-string&quot;&gt;&quot;_doc&quot;&lt;/span&gt;,
        &lt;span class=&quot;hljs-string&quot;&gt;&quot;_id&quot;&lt;/span&gt; : &lt;span class=&quot;hljs-string&quot;&gt;&quot;2&quot;&lt;/span&gt;,
        &lt;span class=&quot;hljs-string&quot;&gt;&quot;_score&quot;&lt;/span&gt; : 1.0,
        &lt;span class=&quot;hljs-string&quot;&gt;&quot;_source&quot;&lt;/span&gt; : {
          &lt;span class=&quot;hljs-string&quot;&gt;&quot;name&quot;&lt;/span&gt; : &lt;span class=&quot;hljs-string&quot;&gt;&quot;敖丙&quot;&lt;/span&gt;,
          &lt;span class=&quot;hljs-string&quot;&gt;&quot;title&quot;&lt;/span&gt; : &lt;span class=&quot;hljs-string&quot;&gt;&quot;工程师&quot;&lt;/span&gt;,
          &lt;span class=&quot;hljs-string&quot;&gt;&quot;desc&quot;&lt;/span&gt; : &lt;span class=&quot;hljs-string&quot;&gt;&quot;一个互联网苟且偷生的工具人&quot;&lt;/span&gt;
        }
      }
    ]
  }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面代码中，返回结果的 &lt;code&gt;took&lt;/code&gt;字段表示该操作的耗时（单位为毫秒），&lt;code&gt;timed_out&lt;/code&gt;字段表示是否超时，&lt;code&gt;hits&lt;/code&gt;字段表示命中的记录，里面子字段的含义如下。&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;total：返回记录数，本例是2条。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;max_scor：最高的匹配程度，本例是1.0。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;hits：返回的记录组成的数组。&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;返回的记录中，每条记录都有一个&lt;code&gt;_score&lt;/code&gt;字段，表示匹配的程序，默认是按照这个字段降序排列。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Es的查询语法还有很多，后面在结合实战项目的时候会讲解其他语法，你也可以看下官网语法介绍 &lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.7/query-dsl.html&quot;&gt;官网查询语法&lt;/a&gt;。&lt;/p&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;数据操作交互&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;新增一条doc记录的语法示例如下，可以不用指定doc_id的，Es会默认有一个doc_id。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;$ curl -X PUT -H &lt;span class=&quot;hljs-string&quot;&gt;'Content-Type: application/json'&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;'localhost:9200/user/_doc/2'&lt;/span&gt; -d &lt;span class=&quot;hljs-string&quot;&gt;'
{
  &quot;name&quot;: &quot;敖丙&quot;,
  &quot;title&quot;: &quot;工程师&quot;,
  &quot;desc&quot;: &quot;一个互联网苟且偷生的工具人&quot;
}'&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;删除一条doc记录的语法是 &lt;code&gt;/Index/_doc/doc_id&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;$ curl -X DELETE  &lt;span class=&quot;hljs-string&quot;&gt;'localhost:9200/user/_doc/1'&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;更新一条记录的语法示例&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;$ curl -X PUT -H &lt;span class=&quot;hljs-string&quot;&gt;'Content-Type: application/json'&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;'localhost:9200/user/_doc/2'&lt;/span&gt; -d &lt;span class=&quot;hljs-string&quot;&gt;'
{
  &quot;name&quot;: &quot;三太子敖丙&quot;,
  &quot;title&quot;: &quot;工程师&quot;,
  &quot;desc&quot;: &quot;一个互联网苟且偷生的工具人&quot;
}'&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;总结一下&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本篇文章，我们把Es从官网下载下来，可以run起来，可以写数据进去，可以查询，学习了一些简单的交互语法。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然Es的魅力不在于此，Es的魅力之一在于可以对&lt;strong&gt;海量数据&lt;/strong&gt;进行&lt;strong&gt;高效&lt;/strong&gt;的检索。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下篇文章出一个关于Es的写作大纲，方便大家在看的过程中有一个整理的轮廓。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Es整个知识点我也是边学边写，有什么不对的地方，还希望大佬们尽管指出来。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/00831rSTly1gdjy2023y3j30p00dw0tn.jpg&quot; alt=&quot;龙跃十二&quot;/&gt;龙跃十二</description>
<pubDate>Mon, 08 Jun 2020 23:42:00 +0000</pubDate>
<dc:creator>龙跃十二</dc:creator>
<og:description>工作中经常遇到看别人的项目，很多人很迷茫，其实第一步都是先run起来，run起来之后再去看架构看细节</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhonglongbo/p/13070181.html</dc:identifier>
</item>
<item>
<title>掌握SpringBoot-2.3的容器探针：基础篇 - zq2599</title>
<link>http://www.cnblogs.com/bolingcavalry/p/13070180.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bolingcavalry/p/13070180.html</guid>
<description>&lt;h3 id=&quot;欢迎访问我的github&quot;&gt;欢迎访问我的GitHub&lt;/h3&gt;
&lt;h3 id=&quot;关于《springboot-23容器化技术》系列&quot;&gt;关于《SpringBoot-2.3容器化技术》系列&lt;/h3&gt;
&lt;p&gt;《SpringBoot-2.3容器化技术》系列，旨在和大家一起学习实践2.3版本带来的最新容器化技术，让咱们的Java应用更加适应容器化环境，在云计算时代依旧紧跟主流，保持竞争力；&lt;br/&gt;全系列文章分为主题和辅助两部分，主题部分如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/106597358&quot;&gt;《体验SpringBoot(2.3)应用制作Docker镜像(官方方案)》&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/106598189&quot;&gt;《详解SpringBoot(2.3)应用制作Docker镜像(官方方案)》&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/106605264&quot;&gt;《掌握SpringBoot-2.3的容器探针：基础篇》&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/106606442&quot;&gt;《掌握SpringBoot-2.3的容器探针：深入篇》&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/106607225&quot;&gt;《掌握SpringBoot-2.3的容器探针：实战篇》&lt;/a&gt;；&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;辅助部分是一些参考资料和备忘总结，如下：&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/106600620&quot;&gt;《SpringBoot-2.3镜像方案为什么要做多个layer》&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/106590784&quot;&gt;《设置非root账号不用sudo直接执行docker命令》&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/106594392&quot;&gt;《开发阶段，将SpringBoot应用快速部署到K8S》&lt;/a&gt;；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;springboot容器探针系列文章简介&quot;&gt;SpringBoot容器探针系列文章简介&lt;/h3&gt;
&lt;p&gt;为了让应用更适应容器化环境，SpringBoot2.3版本推出了新的探针技术，《掌握SpringBoot-2.3的容器探针》系列旨在与您一起学习和实践这些新技术，分为三个阶段：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;基础篇：即本文，对容器探针的相关知识点进行梳理和学习；&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/106606442&quot;&gt;深入篇&lt;/a&gt;：继续深入学习探针相关的知识点；&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/106607225&quot;&gt;实战篇&lt;/a&gt;：将springboot应用部署在kubernetes环境，并使用最新的探针技术；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;探针特性的官方信息&quot;&gt;探针特性的官方信息&lt;/h3&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如下图红框所示，2.3版本的容器探针特性早在预览版(v2.3.0.M4)就已经发布：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202006/485422-20200609074109932-2124305232.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如今v2.3.0.RELEASE已发布，可以放心的学习和使用该特性了，首先把基础知识点列出来，确保准备工作OK；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;知识点整理&quot;&gt;知识点整理&lt;/h3&gt;
&lt;p&gt;下面是掌握探针技术所需的基础知识，也是本文的主要内容：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;kubernetes的存活探针&lt;span&gt;livenessProbe&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;kubernetes的就绪探针&lt;span&gt;readinessProbe&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;SpringBoot的&lt;span&gt;actuator&lt;/span&gt;；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;接下来逐个学习，有了这些知识积累，我们才能更好的阅读官方资料，开发适合自己业务场景的探针；&lt;/p&gt;
&lt;h3 id=&quot;kubernetes的存活探针livenessprobe&quot;&gt;kubernetes的存活探针livenessProbe&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;kubernetes的探针涉及的内容是很多的，这里只提和SpringBoot相关的部分；&lt;/li&gt;
&lt;li&gt;kubelet 使用存活探针&lt;span&gt;livenessProbe&lt;/span&gt;来知道什么时候要重启容器；&lt;/li&gt;
&lt;li&gt;下图是kubernetes官网的存活探针示例，几个关键参数已经做了详细说明：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202006/485422-20200609074110943-1140049907.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;可见如果我们的SpringBoot应用发布到kubernetes环境，只要应用还健康，livenessProbe对应的地址就要能响应200-400的返回码；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;kubernetes的就绪探针readinessprobe&quot;&gt;kubernetes的就绪探针readinessProbe&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;有时候，应用程序会暂时性的不能提供通信服务。例如，应用程序在启动时可能需要加载很大的数据或配置文件，或是启动后要依赖等待外部服务。在这种情况下，既不想杀死应用程序，也不想给它发送请求。Kubernetes 提供了就绪探测器来发现并缓解这些情况。容器所在 Pod 上报还未就绪的信息，并且不接受通过 Kubernetes Service 的流量。&lt;/li&gt;
&lt;li&gt;就绪探测器的配置和存活探测器的配置相似，唯一区别就是要使用 &lt;span&gt;readinessProbe&lt;/span&gt;字段，而不是 livenessProbe 字段；&lt;/li&gt;
&lt;li&gt;简单的说，就绪探针正常的容器，k8s就认为是可以对外提供服务的，相应的请求也会被调度到该容器上来；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;springboot的actuator&quot;&gt;SpringBoot的actuator&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;简单来说，actuator是用来帮助用户监控和操作SprinBoot应用的，这些监控和操作都可以通过http请求实现，如下图，&lt;a href=&quot;http://localhost:8080/actuator/health&quot;&gt;http://localhost:8080/actuator/health&lt;/a&gt; 地址返回的是应用的健康状态：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202006/485422-20200609074111355-196395698.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;下面是常用的actuator地址，访问不同的地址可以得到不同的信息：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202006/485422-20200609074112027-1004360521.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;在SpringBoot-2.3版本中，actuator新增了两个地址：&lt;span&gt;/actuator/health/liveness&lt;/span&gt;和&lt;span&gt;/actuator/health/readiness&lt;/span&gt;，前者用作kubernetes的&lt;span&gt;存活探针&lt;/span&gt;，后者用作kubernetes的&lt;span&gt;就绪探针&lt;/span&gt;；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;画外音：springboot的探针技术就这点东西？&quot;&gt;画外音：SpringBoot的探针技术就这点东西？&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;文章看到这里，您可能觉得索然无味：所谓的容器探针特性如此简单，新增两个actuator地址留给kubernetes的存活和就绪探针用，只要这两个地址响应正常，kubernetes就判定该容器正常；&lt;/li&gt;
&lt;li&gt;大多数时候，上述结论并无不妥，SpringBoot官方给出的推荐配置如下图，我们只要照搬即可：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202006/485422-20200609074112370-269278185.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;冷静下来仔细思考，有三个问题似乎没有解决：&lt;/li&gt;
&lt;/ol&gt;&lt;ul readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;首先，SpringBoot为kubernetes提供了两个actuator项，但是那些并未部署在kubernetes的SringBoot应用呢？用不上这两项也要对外暴露这两个服务地址吗？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;其次，就绪探针是什么时候开始返回200返回码的？应用启动阶段，业务服务可能需要一段时间才能正常工作，就绪探针要是提前返回了200，那k8s就认为容器可以正常工作了，这时候把外部请求调度过来是无法正常响应的，所以搞清楚就绪探针的状态变化逻辑很重要；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;最后，也是最重要的一点：有的场景下，例如外部依赖服务异常、本地全局异常等情况下，业务不想对外提供服务，等到问题解决后业务又可以对外提供服务了，如果此时我们能自己写代码控制就绪探针的返回码，那就做到了控制kubernetes是否将外部请求调度到此容器上，这可是个很实用的功能！&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;还需要继续深入&quot;&gt;还需要继续深入&lt;/h3&gt;
&lt;p&gt;面对上述三个问题您是否会感慨：看似简单的容器探针技术，想要用好还需掌握更多知识，&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/106606442&quot;&gt;接下来的文章&lt;/a&gt;中咱们一起努力吧，从知识覆盖到实战操练，终究会掌握这门实用技术；&lt;/p&gt;
&lt;h3 id=&quot;欢迎关注我的公众号：程序员欣宸&quot;&gt;欢迎关注我的公众号：程序员欣宸&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202006/485422-20200609074112563-1600584390.jpg&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 08 Jun 2020 23:41:00 +0000</pubDate>
<dc:creator>zq2599</dc:creator>
<og:description>欢迎访问我的GitHub 地址：https://github.com/zq2599/blog_demos 内容：原创文章分类汇总，及配套源码，涉及Java、Docker、K8S、DevOPS等 关于《</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bolingcavalry/p/13070180.html</dc:identifier>
</item>
<item>
<title>【Flutter实战】移动技术发展史 - 老孟Flutter</title>
<link>http://www.cnblogs.com/mengqd/p/13070171.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mengqd/p/13070171.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202006/467322-20200609072034887-1380367146.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;老孟导读：大家好，这是【Flutter实战】系列文章的第一篇，这并不是一篇&lt;strong&gt;Flutter&lt;/strong&gt;技术文章，而是介绍智能手机操作系统、跨平台技术的演进以及我对各种跨平台技术看法的文章。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;智能手机操作系统&quot;&gt;智能手机操作系统&lt;/h3&gt;
&lt;h4 id=&quot;塞班（symbian）系统&quot;&gt;塞班（Symbian）系统&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;后浪&lt;/strong&gt;们可能都没有听说过塞班系统，而很多&lt;strong&gt;前浪&lt;/strong&gt;们也会诧异，塞班是智能手机操作系统吗？让我们先来看下智能手机的定义：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;智能手机，是指像个人电脑一样，具有独立的操作系统，独立的运行空间，可以由用户自行安装软件、游戏、导航等第三方服务商提供的程序，并可以通过移动通讯网络来实现无线网络接入的手机类型的总称。目前智能手机的发展趋势是充分加入了人工智能、5G等多项专利技术，使智能手机成为了用途最为广泛的专利产品。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以按照如上的定义，塞班系统属于智能手机操作系统，那为什么很多人都认为塞班系统不属于智能手机操作系统呢？主要是因为塞班和现在的Android、iOS智能系统比起来差远了。&lt;/p&gt;
&lt;p&gt;虽然现在塞班系统已经&lt;strong&gt;Game Over&lt;/strong&gt;了，但当年塞班系统是当之无愧的王者，根本就没有一个与之匹配的对手。&lt;/p&gt;
&lt;p&gt;2008年12月2日，塞班公司被诺基亚收购。&lt;/p&gt;
&lt;p&gt;2011年12月21日，诺基亚官方宣布放弃塞班品牌。由于缺乏新技术支持，塞班的市场份额日益萎缩。&lt;/p&gt;
&lt;p&gt;截止至2012年2月，塞班系统的全球市场占有量仅为3%。&lt;/p&gt;
&lt;p&gt;2012年5月27日，诺基亚彻底放弃开发塞班系统，但是服务将一直持续到2016年。&lt;/p&gt;
&lt;p&gt;2013年1月24日晚间，诺基亚宣布，今后将不再发布塞班系统的手机，意味着塞班这个智能手机操作系统，在长达14年的历史之后，终于迎来了谢幕。&lt;/p&gt;
&lt;p&gt;至此，&lt;strong&gt;塞班时代&lt;/strong&gt;终结，一个时代的终结，必将伴随着新时代的到来。&lt;/p&gt;
&lt;h4 id=&quot;windows-phone&quot;&gt;Windows Phone&lt;/h4&gt;
&lt;p&gt;Windows Phone(简称为WP)是微软于2010年10月21日正式发布的一款手机操作系统，初始版本命名为Windows Phone7.0。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;2011年9月27日，微软发布升级版Windows Phone 7.5，这是首个支持简体中文的系统版本。&lt;/li&gt;
&lt;li&gt;2012年6月21日，微软正式发布Windows Phone 8，全新的Windows Phone 8舍弃了老旧Windows CE内核，采用了与Windows系统相同的Windows NT内核，支持很多新的特性。由于内核的改变，所有Windows Phone 7.5系统的手机都将无法升级至Windows Phone 8。&lt;/li&gt;
&lt;li&gt;2015年1月22日，微软将Windows Phone 10更名为Windows 10 for Phone。&lt;/li&gt;
&lt;li&gt;2015年5月14日，微软官网正式将智能手机上的版本命名为“Windows 10 Mobile” 。&lt;/li&gt;
&lt;li&gt;2019年12月10日，微软停止对Windows 10 Mobile的支持。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;2019年12月10日这一天，微软宣布停止对Windows 10 Mobile的支持，也就宣告Windows 10 Mobile告别了历史的舞台。&lt;/p&gt;
&lt;p&gt;Windows Phone当年的市场份额一度超过50%，到退出历史的舞台，在我看来微软犯了一个很大的错误：&lt;/p&gt;
&lt;p&gt;那就是Windows Phone 8的发布，由于使用了新的内核导致以前的手机无法升级而且软件不向下兼容，导致用户和开发者极度不爽，用户刚买了手机，结果你告诉用户系统不能升级？&lt;/p&gt;
&lt;p&gt;新系统导致以前开发的App无法运行，开发者重新开发一遍？而且还要维护两套？&lt;/p&gt;
&lt;p&gt;系统最核心的资产是生态，当你抛弃了开发者也就意味着生态的残缺，没有大量优质的应用用户怎么可能买你的手机？&lt;/p&gt;
&lt;h4 id=&quot;android&quot;&gt;Android&lt;/h4&gt;
&lt;p&gt;Android系统大家都非常熟悉了，毕竟是当前市场份额最大的移动操作系统，看一下Android的发展历程：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;2003年10月，Andy Rubin等人创建Android公司，并组建Android团队。&lt;/li&gt;
&lt;li&gt;2005年8月17日，Google低调收购了成立仅22个月的高科技企业Android及其团队。安迪鲁宾成为Google公司工程部副总裁，继续负责Android项目。&lt;/li&gt;
&lt;li&gt;2008年，在GoogleI/O大会上，谷歌提出了AndroidHAL架构图，在同年8月18号，Android获得了美国联邦通信委员会（FCC）的批准，在2008年9月，谷歌正式发布了Android 1.0系统，这也是Android系统最早的版本。&lt;/li&gt;
&lt;li&gt;2009年4月，谷歌正式推出了Android 1.5这款手机，从Android 1.5版本开始，谷歌开始将Android的版本以甜品的名字命名，Android 1.5命名为Cupcake。&lt;/li&gt;
&lt;li&gt;2010年10月，谷歌宣布Android系统达到了第一个里程碑，即电子市场上获得官方数字认证的Android应用数量已经达到了10万个，Android系统的应用增长非常迅速。&lt;/li&gt;
&lt;li&gt;2011年8月2日，Android手机已占据全球智能机市场48%的份额，并在亚太地区市场占据统治地位，终结了塞班系统的霸主地位，跃居全球第一。&lt;/li&gt;
&lt;li&gt;今年（2020年）即将发布Android 11。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;ios&quot;&gt;iOS&lt;/h4&gt;
&lt;p&gt;iOS是由苹果公司开发的移动操作系统 。苹果公司最早于2007年1月9日的Macworld大会上公布这个系统，其发展历程如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;2007年10月17日，苹果公司发布了第一个本地化iPhone应用程序开发包（SDK），并且计划在2月发送到每个开发者以及开发商手中。&lt;/li&gt;
&lt;li&gt;2010年6月，苹果公司将“iPhone OS”改名为“iOS”，同时还获得了思科iOS的名称授权。&lt;/li&gt;
&lt;li&gt;2010年第四季度，苹果公司的iOS占据了全球智能手机操作系统26%的市场份额。&lt;/li&gt;
&lt;li&gt;2013年6月10日，苹果公司在WWDC 2013上发布了iOS 7，几乎重绘了所有的系统App，去掉了所有的仿实物化，整体设计风格转为扁平化设计。将于2013年秋正式开放下载更新。&lt;/li&gt;
&lt;li&gt;2016年9月14日，苹果发布iOS 10正式版，这是苹果推出移动操作系统以来最大的一次更新，尤其增加了很多特别适应中国国情的功能，比如骚扰电话识别、苹果地图进一步本地化等。&lt;/li&gt;
&lt;li&gt;2018年9月13日，2018苹果秋季新品发布会上，苹果CEO库克介绍了苹果生态的一些数据。他表示，搭载苹果iOS系统设备已达20亿部。&lt;/li&gt;
&lt;li&gt;2020年5月21日，苹果发布iOS 13.5正式版，iOS 13.5加快了配备面容ID的设备在用户佩戴口罩时显示密码栏的速度，并加入了“暴露通知”API以支持来自公共卫生管理机构的COVID-19接触追踪App。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;跨平台开发演进&quot;&gt;跨平台开发演进&lt;/h3&gt;
&lt;p&gt;2008年7月IPhone推出第一代手机IPhone 3G，同年9月谷歌正式发布了Android 1.0系统，标志着我们正式步入移动端发展期，按照技术开发的历程移动端（目前特指Android和iOS）的发展大致可以分为4个阶段：原生阶段-&amp;gt;Hybird阶段-&amp;gt;RN阶段-&amp;gt;Flutter 阶段。&lt;/p&gt;
&lt;h4 id=&quot;原生阶段&quot;&gt;原生阶段&lt;/h4&gt;
&lt;p&gt;使用原生语言（Android使用Java或Kotlin，iOS使用Objective-C 或 Swift ）开发应用，称之为&lt;strong&gt;原生阶段&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在此阶段发现一样的功能需要在Android和iOS两端开发，开发和维护成本较高，同时无动态化更新能力，紧急问题的修复和添加新功能都需要到相应平台发版，尤其是iOS审核的周期非常长，在国内Android虽然有动态化方案，但如果上架Google Play很有可能审核不通过或者下架，iOS也有动态化，但苹果官方基本审核不通过，所以原生的动态化更新受政策影响很大。&lt;/p&gt;
&lt;p&gt;从开发者的角度出发，是否有一种方案可以开发一套代码在多个平台运行且可以动态化更新，无需在走平台的审核。基于这个需求H5兴起，也就是我们所说的Hybird阶段。&lt;/p&gt;
&lt;h4 id=&quot;hybird阶段&quot;&gt;Hybird阶段&lt;/h4&gt;
&lt;p&gt;Hybird实现的基本原理是通过原生的WebView容器加载H5网页进行渲染，通过JavaScript Bridge调用一部分系统能力，同步更新服务器上的H5网页也实现了动态更新，俗称混合应用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202006/467322-20200609072035299-1109147373.png&quot; alt=&quot;image-20200608113600654&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当时大量的公司使用此方案进行开发，最出名的就是Facebook，早期的Facebook在H5上投入了大量的精力，一次开发、快速迭代这是使用H5技术巨大的优势。&lt;/p&gt;
&lt;p&gt;然而一切看似美好，但很快发现，H5方案存在致命的缺陷-&lt;strong&gt;用户体验极差&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;Facebook创始人兼CEO&lt;strong&gt;马克·扎克伯格&lt;/strong&gt;在接受采访的时候承认：&lt;strong&gt;专注在HTML 5上面是他有史以来犯过的最大的错误。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;然而&lt;strong&gt;福兮祸所伏&lt;/strong&gt;，虽然在Facebook上大量使用H5而导致用户体验极差，但Facebook基于强大的H5技术积累开发出了伟大的&lt;strong&gt;React&lt;/strong&gt;框架，此框架是&lt;strong&gt;React Native&lt;/strong&gt;框架的基础。&lt;/p&gt;
&lt;h4 id=&quot;react-native阶段&quot;&gt;React Native阶段&lt;/h4&gt;
&lt;p&gt;React Native简称RN，是FaceBook在2015年开源，基于 JavaScript，具备动态配置能力跨平台开发框架。React Native框架原理如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202006/467322-20200609072035521-73048025.png&quot; alt=&quot;image-20200608115921953&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;React Native 使用&lt;strong&gt;React&lt;/strong&gt;开发，然后生成虚拟DOM树，虚拟 DOM 是一个 JavaScript 的树形结构，通过虚拟DOM树映射到不同平台的本地控件，最终显示的UI是原生控件，因此在性能体验上和原生非常相近。和React Native 类似的框架还有阿里巴巴的Weex框架，Weex是在React Native基础上重新设计了一套开发模式，原理上和React Native 一样。&lt;/p&gt;
&lt;p&gt;React Native 解决了继承了H5的优点，同时解决了性能体验上的问题，2015年React Native一经发布，就在技术圈引起了巨大的反响，在当时看来React Native 是一个非常完美的跨平台解决方案，很快大量开发者涌入。&lt;/p&gt;
&lt;p&gt;当年使用React Native 的开发者最担心的不是React Native 性能如何？体验如何？而是担心&lt;strong&gt;苹果会不会封掉React Native&lt;/strong&gt;，可想而之React Native 的火爆程度，当年著名的&lt;strong&gt;JSPatch&lt;/strong&gt;事件起初，起初大家都在说苹果开始对React Native下手了，虽然后来证实和React Native无关，但多多少少都对React Native 开发者造成了一定的影响。&lt;/p&gt;
&lt;p&gt;随着时间的流逝，发现React Native 和原生桥接的成本非常高，在复杂场景下会出现严重的性能问题，比如早期的ListView滑动卡顿问题。&lt;/p&gt;
&lt;p&gt;React Native要桥接到原生控件，但Android和IOS控件的差异导致React Native无法统一API，有的属性IOS支持，Android不支持，有的Android支持，IOS不支持，这就导致经常需要开发Android和IOS两套插件，随着项目的复杂度提升，也导致维护成本大幅提升。&lt;/p&gt;
&lt;p&gt;还有一个很大的问题就是React Native 依赖于 Facebook 的维护，而每次iOS和Android系统版本更新，很大程度上会受到影响。&lt;/p&gt;
&lt;h4 id=&quot;小程序&quot;&gt;小程序&lt;/h4&gt;
&lt;p&gt;从技术上来说，小程序（指微信小程序，下同）并不是新的跨平台方案，它使用浏览器内核来渲染界面，小部分由原生组件渲染，原理图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202006/467322-20200609072035719-195653277.png&quot; alt=&quot;image-20200608140924092&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;小程序的运行环境分成渲染层和逻辑层，通信会经由微信客户端（Native）做中转。&lt;/p&gt;
&lt;p&gt;微信小程序目前来看是非常成功的，在我看来微信小程序成功主要原因并不是因为技术，而是生态，当然微信小程序体验也是非常好的。&lt;/p&gt;
&lt;p&gt;对商家来说，微信小程序拥有月活10亿的微信用户，获客成本低，这是一个流量极佳的平台，因此很多商家开发了体验极好的小程序，甚至一些商家把主要平台迁移到了微信小程序。&lt;/p&gt;
&lt;p&gt;对于用户来说，&lt;strong&gt;无需下载，用完就走&lt;/strong&gt;，极大的提升了用户体验，微信提供基础服务平台，商家获客成本低，用户体验提升，三方形成完美的平衡，因此微信小程序的生态越来越完善。&lt;/p&gt;
&lt;p&gt;除了小程序外，类似的方案还有百度的轻应用和快应用，但都不温不火。&lt;/p&gt;
&lt;h4 id=&quot;flutter-阶段&quot;&gt;Flutter 阶段&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;千呼万唤始出来&lt;/strong&gt;，主角-Flutter终于登场了，Flutter是谷歌的移动UI框架，可以快速在iOS和Android上构建高质量的原生用户界面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202006/467322-20200609072035914-947677863.png&quot; alt=&quot;image-20200608143242580&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Flutter吸收了前面的经验，它既没有使用WebView，也没有使用原生控件进行绘制，而是自己实现了一套高性能渲染引擎来绘制UI，这个引擎就是大名鼎鼎的Skia，Skia是一个2D绘图引擎库，Chrome和Android都是采用Skia作为引擎。Flutter完美的解决了跨平台代码复用和性能问题，大家都在感叹：似乎UI迎来了终极解决方案。&lt;/p&gt;
&lt;h3 id=&quot;flutter局限性&quot;&gt;Flutter局限性&lt;/h3&gt;
&lt;p&gt;Flutter并不是无所不能的，当你选取Flutter作为技术方案时，首先要了解Flutter无法实现哪些功能。&lt;/p&gt;
&lt;h4 id=&quot;ui平台一致性&quot;&gt;UI平台一致性&lt;/h4&gt;
&lt;p&gt;由于Flutter使用自己的引擎进行UI渲染，而不是用原生控件渲染，导致控件显示效果和原生不是完全一样，虽然肉眼看起来基本一样，但还是有一些细微的差别，尤其当Android和iOS系统升级导致原生控件效果发生变化时，Flutter开发的App并不会进行相应的变化，如果您的App需要原生控件保持完全一致，Flutter可能并不适合您。&lt;/p&gt;
&lt;h4 id=&quot;动态化更新&quot;&gt;动态化更新&lt;/h4&gt;
&lt;p&gt;动态化功能在国内来说是一项非常重要的功能，Google官方已经明确现阶段不会实现动态化功能。&lt;/p&gt;
&lt;p&gt;此功能并不是技术上无法实现，更多的还是政策和法律上的约束。&lt;/p&gt;
&lt;p&gt;因此如果您的App需要动态化功能，那么Flutter可能并不适合您。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;既然Flutter已经如此优秀了，那是不是以后使用Flutter就可以了呢？答案是否定的，未来很长一段时间应该是原生、Hybird、React Native、Flutter共存时代。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;原生开发是无法完全避开的，一些硬件（比如蓝牙、传感器等）功能、音视频和ARVR等相关功能必须使用原生开发，有人说我开发蓝牙功能没用写原生代码啊，直接引入即可，你没有写，那是因为有人为你封装好了第三方插件。&lt;/li&gt;
&lt;li&gt;Hybird虽然有一些缺陷，但依然有其使用的场景，比如京东、天猫App中的营销活动都是是H5实现的。&lt;/li&gt;
&lt;li&gt;React Native可以使用原生控件渲染，因此，如果您需要使用原生控件而又想跨平台，React Native是不错的选择。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;交流&quot;&gt;交流&lt;/h2&gt;
&lt;p&gt;老孟Flutter博客地址（330个控件用法）：&lt;a href=&quot;http://laomengit.com&quot;&gt;http://laomengit.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎加入Flutter交流群（微信：laomengit）、关注公众号【老孟Flutter】：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th/&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202006/467322-20200609072036465-553098351.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202006/467322-20200609072036873-59425139.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</description>
<pubDate>Mon, 08 Jun 2020 23:21:00 +0000</pubDate>
<dc:creator>老孟Flutter</dc:creator>
<og:description>老孟导读：大家好，这是【Flutter实战】系列文章的第一篇，这并不是一篇Flutter技术文章，而是介绍智能手机操作系统、跨平台技术的演进以及我对各种跨平台技术看法的文章。 智能手机操作系统 塞班（</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mengqd/p/13070171.html</dc:identifier>
</item>
<item>
<title>小师妹学JavaIO之:文件File和路径Path - flydean</title>
<link>http://www.cnblogs.com/flydean/p/java-io-file-path.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/flydean/p/java-io-file-path.html</guid>
<description>&lt;p&gt;文件和路径有什么关系？文件和路径又隐藏了什么秘密？在文件系统的管理下，创建路径的方式又有哪些？今天F师兄带小师妹再给大家来一场精彩的表演。&lt;/p&gt;

&lt;p&gt;小师妹：F师兄我有一个问题，java中的文件File是一个类可以理解，因为文件里面包含了很多其他的信息，但是路径Path为什么也要单独一个类出来？只用一个String表示不是更简单？&lt;/p&gt;
&lt;p&gt;更多精彩内容且看：&lt;/p&gt;
&lt;blockquote readability=&quot;2.9166666666667&quot;&gt;
&lt;p&gt;更多内容请访问&lt;a href=&quot;https://www.cnblogs.com/flydean/p/www.flydean.com&quot;&gt;www.flydean.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;万物皆有因，没有无缘无故的爱，也没有无缘无故的恨。一切真的是妙不可言啊。&lt;/p&gt;
&lt;p&gt;我们来看下File和path的定义：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class File
   implements Serializable, Comparable&amp;lt;File&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface Path
    extends Comparable&amp;lt;Path&amp;gt;, Iterable&amp;lt;Path&amp;gt;, Watchable
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先，File是一个类，它表示的是所有的文件系统都拥有的属性和功能，不管你是windows还是linux，他们中的File对象都应该是一样的。&lt;/p&gt;
&lt;p&gt;File中包含了Path，小师妹你且看，Path是一个interface,为什么是一个interface呢？因为Path根据不同的情况可以分为JrtPath，UnixPath和ZipPath。三个Path所对应的FileSystem我们在上一篇文章中已经讨论过了。所以Path的实现是不同的，但是包含Path的File是相同的。&lt;/p&gt;
&lt;p&gt;小师妹：F师兄，这个怎么这么拗口，给我来一个直白通俗的解释吧。&lt;/p&gt;
&lt;p&gt;既然这样，且听我解释：爱国版的，或许我们属于不同的民族，但是我们都是中国人。通俗版的，大家都是文化人儿，为啥就你这么拽。文化版的，同九年，汝何秀？&lt;/p&gt;
&lt;p&gt;再看两者的实现接口，File实现了Serializable表示可以被序列化，实现了Comparable，表示可以被排序。&lt;/p&gt;
&lt;p&gt;Path继承Comparable，表示可以被排序。继承Iterable表示可以被遍历，可以被遍历是因为Path可以表示目录。继承Watchable，表示可以被注册到WatchService中，进行监控。&lt;/p&gt;

&lt;p&gt;小师妹：F师兄，File中有好几个关于Path的get方法，能讲一下他们的不同之处吗？&lt;/p&gt;
&lt;p&gt;直接上代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void getFilePath() throws IOException {
        File file= new File(&quot;../../www.flydean.com.txt&quot;);
        log.info(&quot;name is : {}&quot;,file.getName());

        log.info(&quot;path is : {}&quot;,file.getPath());
        log.info(&quot;absolutePath is : {}&quot;,file.getAbsolutePath());
        log.info(&quot;canonicalPath is : {}&quot;,file.getCanonicalPath());
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;File中有三个跟Path有关的方法，分别是getPath，getAbsolutePath和getCanonicalPath。&lt;/p&gt;
&lt;p&gt;getPath返回的结果就是new File的时候传入的路径，输入什么返回什么。&lt;/p&gt;
&lt;p&gt;getAbsolutePath返回的是绝对路径，就是在getPath前面加上了当前的路径。&lt;/p&gt;
&lt;p&gt;getCanonicalPath返回的是精简后的AbsolutePath，就是去掉了.或者..之类的指代符号。&lt;/p&gt;
&lt;p&gt;看下输出结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt; INFO com.flydean.FilePathUsage - name is : www.flydean.com.txt
 INFO com.flydean.FilePathUsage - path is : ../../www.flydean.com.txt
 INFO com.flydean.FilePathUsage - absolutePath is : /Users/flydean/learn-java-io-nio/file-path/../../www.flydean.com.txt
 INFO com.flydean.FilePathUsage - canonicalPath is : /Users/flydean/www.flydean.com.txt
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;小师妹：F师兄，我记得路径有相对路径，绝对路径等，是不是也有相应的创建Path的方法呢？&lt;/p&gt;
&lt;p&gt;当然有的，先看下绝对路径的创建：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void getAbsolutePath(){
        Path absolutePath = Paths.get(&quot;/data/flydean/learn-java-io-nio/file-path&quot;, &quot;src/resource&quot;,&quot;www.flydean.com.txt&quot;);
        log.info(&quot;absolutePath {}&quot;,absolutePath );
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以使用Paths.get方法传入绝对路径的地址来构建绝对路径。&lt;/p&gt;
&lt;p&gt;同样使用Paths.get方法，传入非绝对路径可以构建相对路径。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void getRelativePath(){
        Path RelativePath = Paths.get(&quot;src&quot;, &quot;resource&quot;,&quot;www.flydean.com.txt&quot;);
        log.info(&quot;absolutePath {}&quot;,RelativePath.toAbsolutePath() );
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们还可以从URI中构建Path：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void getPathfromURI(){
        URI uri = URI.create(&quot;file:///data/flydean/learn-java-io-nio/file-path/src/resource/www.flydean.com.txt&quot;);
        log.info(&quot;schema {}&quot;,uri.getScheme());
        log.info(&quot;default provider absolutePath {}&quot;,FileSystems.getDefault().provider().getPath(uri).toAbsolutePath().toString());
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也可以从FileSystem构建Path：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void getPathWithFileSystem(){
            Path path1 = FileSystems.getDefault().getPath(System.getProperty(&quot;user.home&quot;), &quot;flydean&quot;, &quot;flydean.txt&quot;);
           log.info(path1.toAbsolutePath().toString());

            Path path2 = FileSystems.getDefault().getPath(&quot;/Users&quot;, &quot;flydean&quot;, &quot;flydean.txt&quot;);
            log.info(path2.toAbsolutePath().toString());

        }
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;好多好多Path的创建方法，总有一款适合你。快来挑选吧。&lt;/p&gt;
&lt;p&gt;本文的例子&lt;a href=&quot;https://github.com/ddean2009/learn-java-io-nio&quot;&gt;https://github.com/ddean2009/learn-java-io-nio&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8.7106598984772&quot;&gt;
&lt;p&gt;本文作者：flydean程序那些事&lt;/p&gt;
&lt;p&gt;本文链接：&lt;a href=&quot;http://www.flydean.com/java-io-file-path/&quot;&gt;http://www.flydean.com/java-io-file-path/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文来源：flydean的博客&lt;/p&gt;
&lt;p&gt;欢迎关注我的公众号:程序那些事，更多精彩等着您！&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 08 Jun 2020 22:38:00 +0000</pubDate>
<dc:creator>flydean</dc:creator>
<og:description>简介 文件和路径有什么关系？文件和路径又隐藏了什么秘密？在文件系统的管理下，创建路径的方式又有哪些？今天F师兄带小师妹再给大家来一场精彩的表演。 文件和路径 小师妹：F师兄我有一个问题，java中的文</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/flydean/p/java-io-file-path.html</dc:identifier>
</item>
<item>
<title>STM32学习笔记——printf - jerry_fuyi</title>
<link>http://www.cnblogs.com/jerry-fuyi/p/13063308.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jerry-fuyi/p/13063308.html</guid>
<description>&lt;h3 id=&quot;printf复习&quot;&gt;printf复习&lt;/h3&gt;
&lt;p&gt;当我们写&lt;code&gt;printf(&quot;%d\n&quot;, 1);&lt;/code&gt;的时候，&lt;code&gt;printf&lt;/code&gt;函数并不能通过C语言语法得知第二个参数是&lt;code&gt;int&lt;/code&gt;类型。&lt;code&gt;printf&lt;/code&gt;是一个变参函数（variadic function）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int printf(const char *restrict format, ...);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数的类型都是通过格式串&lt;code&gt;format&lt;/code&gt;推导出的。如果参数类型与格式串中指定的不匹配，或提供的参数数量少于需要的，将导致未定义行为。&lt;/p&gt;
&lt;p&gt;由于参数类型是动态的，&lt;code&gt;printf&lt;/code&gt;和&lt;code&gt;scanf&lt;/code&gt;比静态类型的&lt;code&gt;std::cout&lt;/code&gt;和&lt;code&gt;std::cin&lt;/code&gt;慢，前提是后者的众多overhead被手动消除。&lt;/p&gt;
&lt;p&gt;C为可变参数提供了&lt;code&gt;va_start&lt;/code&gt;、&lt;code&gt;va_arg&lt;/code&gt;、&lt;code&gt;va_copy&lt;/code&gt;、&lt;code&gt;va_end&lt;/code&gt;、&lt;code&gt;va_list&lt;/code&gt;等工具，定义在头文件&lt;code&gt;&amp;lt;stdarg.h&amp;gt;&lt;/code&gt;中。&lt;code&gt;va_arg&lt;/code&gt;用于取出参数，&lt;code&gt;va_copy&lt;/code&gt;用于拷贝参数供多次使用。引用&lt;a href=&quot;https://en.cppreference.com/w/c/variadic/va_copy#Example&quot; target=&quot;_blank&quot;&gt;cppreference&lt;/a&gt;上的例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdarg.h&amp;gt;
#include &amp;lt;math.h&amp;gt;
 
double sample_stddev(int count, ...) 
{
    /* Compute the mean with args1. */
    double sum = 0;
    va_list args1;
    va_start(args1, count);
    va_list args2;
    va_copy(args2, args1);   /* copy va_list object */
    for (int i = 0; i &amp;lt; count; ++i) {
        double num = va_arg(args1, double);
        sum += num;
    }
    va_end(args1);
    double mean = sum / count;
 
    /* Compute standard deviation with args2 and mean. */
    double sum_sq_diff = 0;
    for (int i = 0; i &amp;lt; count; ++i) {
        double num = va_arg(args2, double);
        sum_sq_diff += (num-mean) * (num-mean);
    }
    va_end(args2);
    return sqrt(sum_sq_diff / count);
}
 
int main(void) 
{
    printf(&quot;%f\n&quot;, sample_stddev(4, 25.0, 27.3, 26.9, 25.7));
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;stdio.h&amp;gt;&lt;/code&gt;还定义了&lt;code&gt;vprintf&lt;/code&gt;系列函数，与不带&lt;code&gt;v&lt;/code&gt;的相比，可变参数&lt;code&gt;...&lt;/code&gt;都换成了&lt;code&gt;va_list&lt;/code&gt;的实例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int vprintf(const char *format, va_list vlist);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以借此实现自己的&lt;code&gt;printf&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;可变参数在传递的过程中会被执行默认参数提升（default argument promotion），对于整数类型执行整数提升（提升为&lt;code&gt;int&lt;/code&gt;或&lt;code&gt;unsigned int&lt;/code&gt;），对于&lt;code&gt;float&lt;/code&gt;类型提升成&lt;code&gt;double&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;格式串&lt;code&gt;format&lt;/code&gt;中的普通字符直接拷贝到输出流，由&lt;code&gt;%&lt;/code&gt;引导的称为转换格式（conversion specification），在&lt;code&gt;%&lt;/code&gt;和转换说明符（conversion specifier）之间可以有若干修饰符，实现对齐、精度等功能，转换说明符有&lt;code&gt;c&lt;/code&gt;、&lt;code&gt;s&lt;/code&gt;、&lt;code&gt;d&lt;/code&gt;、&lt;code&gt;f&lt;/code&gt;等，详见&lt;a href=&quot;https://en.cppreference.com/w/c/io/fprintf#Parameters&quot; target=&quot;_blank&quot;&gt;cppreference&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;uart实现&quot;&gt;UART实现&lt;/h3&gt;
&lt;p&gt;单片机开发板并没有可以用于输出的控制台，&lt;code&gt;printf&lt;/code&gt;调用最后都会归结为&lt;code&gt;_write&lt;/code&gt;函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int _write(int file, char* ptr, int len);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;_write&lt;/code&gt;函数需要把&lt;code&gt;ptr&lt;/code&gt;指向的&lt;code&gt;len&lt;/code&gt;字节的数据以想要的形式发送，在此就沿用&lt;a href=&quot;https://www.cnblogs.com/jerry-fuyi/p/12907026.html&quot; target=&quot;_blank&quot;&gt;上一篇&lt;/a&gt;中的UART异步IO，于是&lt;code&gt;printf&lt;/code&gt;就可以打印在串口上了。&lt;/p&gt;
&lt;p&gt;为了方便日后使用，我把USART相关的代码抽离出来放在一个新的源文件里，IDE生成的代码去掉&lt;code&gt;MX_USART1_UART_Init&lt;/code&gt;和&lt;code&gt;USART1_IRQHandler&lt;/code&gt;两个函数，再加上这一对文件就可以使用了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;usart1.h&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

void MX_USART1_UART_Init();
void usart1_transmit(char c);
char usart1_receive();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;usart1.c&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &quot;usart1.h&quot;

#include &amp;lt;stdbool.h&amp;gt;
#include &amp;lt;stdint.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &quot;cmsis_gcc.h&quot;
#include &quot;stm32f4xx_hal.h&quot;

typedef char queue_element_t;

typedef struct
{
  uint16_t mask;
  uint16_t head;
  uint16_t tail;
  queue_element_t data[0];
} queue_t;

static inline queue_t* queue_create(uint16_t _size)
{
  if (_size &amp;amp; (_size - 1))
    _size = 256;
  queue_t* q = malloc(sizeof(queue_t) + _size * sizeof(queue_element_t));
  if (q)
  {
    q-&amp;gt;mask = _size - 1;
    q-&amp;gt;head = q-&amp;gt;tail = 0;
  }
  return q;
}

static inline bool queue_empty(const queue_t* _queue)
{
  return _queue-&amp;gt;head == _queue-&amp;gt;tail;
}

static inline uint16_t queue_size(const queue_t* _queue)
{
  return (_queue-&amp;gt;tail - _queue-&amp;gt;head) &amp;amp; _queue-&amp;gt;mask;
}

static inline uint16_t queue_capacity(const queue_t* _queue)
{
  return _queue-&amp;gt;mask;
}

static inline queue_element_t queue_peek(const queue_t* _queue)
{
  return _queue-&amp;gt;data[_queue-&amp;gt;head];
}

static inline void queue_push(queue_t* _queue, const queue_element_t _ele)
{
  _queue-&amp;gt;data[_queue-&amp;gt;tail] = _ele;
  _queue-&amp;gt;tail = (_queue-&amp;gt;tail + 1) &amp;amp; _queue-&amp;gt;mask;
}

static inline void queue_pop(queue_t* _queue)
{
  _queue-&amp;gt;head = (_queue-&amp;gt;head + 1) &amp;amp; _queue-&amp;gt;mask;
}

extern UART_HandleTypeDef huart1;
extern void Error_Handler();
queue_t* tx_buffer;
queue_t* rx_buffer;

void USART1_IRQHandler()
{
  uint32_t isrflags   = USART1-&amp;gt;SR;
  uint32_t cr1its     = USART1-&amp;gt;CR1;
  uint32_t errorflags = 0x00U;
  errorflags = (isrflags &amp;amp; (uint32_t)(USART_SR_PE | USART_SR_FE | USART_SR_ORE | USART_SR_NE));
  if (errorflags == RESET)
  {
    if (((isrflags &amp;amp; USART_SR_RXNE) != RESET) &amp;amp;&amp;amp; ((cr1its &amp;amp; USART_CR1_RXNEIE) != RESET))
    {
      queue_push(rx_buffer, USART1-&amp;gt;DR);
      return;
    }
    if (((isrflags &amp;amp; USART_SR_TXE) != RESET) &amp;amp;&amp;amp; ((cr1its &amp;amp; USART_CR1_TXEIE) != RESET))
    {
      USART1-&amp;gt;DR = queue_peek(tx_buffer);
      queue_pop(tx_buffer);
      if (queue_empty(tx_buffer))
        USART1-&amp;gt;CR1 &amp;amp;= ~USART_CR1_TXEIE &amp;amp; UART_IT_MASK;
      return;
    }
  }
  HAL_UART_IRQHandler(&amp;amp;huart1);
}

void MX_USART1_UART_Init()
{
  tx_buffer = queue_create(1024);
  rx_buffer = queue_create(1024);
  huart1.Instance = USART1;
  huart1.Init.BaudRate = 115200;
  huart1.Init.WordLength = UART_WORDLENGTH_8B;
  huart1.Init.StopBits = UART_STOPBITS_1;
  huart1.Init.Parity = UART_PARITY_NONE;
  huart1.Init.Mode = UART_MODE_TX_RX;
  huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart1.Init.OverSampling = UART_OVERSAMPLING_16;
  if (HAL_UART_Init(&amp;amp;huart1) != HAL_OK)
  {
    Error_Handler();
  }
  USART1-&amp;gt;CR1 |= USART_CR1_RXNEIE &amp;amp; UART_IT_MASK;
}

void usart1_transmit(char c)
{
  uint16_t capacity = queue_capacity(tx_buffer);
  bool ok = false;
  while (1)
  {
    __disable_irq();
    ok = capacity - queue_size(tx_buffer) &amp;gt;= 1;
    if (ok)
      break;
    __enable_irq();
    __NOP();
  }
  queue_push(tx_buffer, c);
  USART1-&amp;gt;CR1 |= USART_CR1_TXEIE &amp;amp; UART_IT_MASK;
  __enable_irq();
}

char usart1_receive()
{
  bool ok = false;
  while (1)
  {
    __disable_irq();
    ok = !queue_empty(rx_buffer);
    if (ok)
      break;
    __enable_irq();
    __NOP();
  }
  char c = queue_peek(rx_buffer);
  queue_pop(rx_buffer);
  __enable_irq();
  return c;
}

int _write(int file, char* ptr, int len)
{
  for (int i = 0; i != len; ++i)
    usart1_transmit(*ptr++);
  return len;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;main.c&lt;/code&gt;（部分）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &quot;main.h&quot;
#include &quot;usart1.h&quot;

UART_HandleTypeDef huart1;
uint8_t count = 0;

void SystemClock_Config(void);
static void MX_GPIO_Init(void);

int main(void)
{
  HAL_Init();
  SystemClock_Config();
  MX_GPIO_Init();
  MX_USART1_UART_Init();
  while (1)
  {
    printf(&quot;Hello world: %d\n&quot;, count);
    HAL_GPIO_TogglePin(LED_GPIO_Port, LED_Pin);
    ++count;
    HAL_Delay(500);
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;itm实现&quot;&gt;ITM实现&lt;/h3&gt;
&lt;p&gt;明明已经用调试器连接了开发板和电脑，还要加个USB转串口工具就显得很累赘；IDE和串口监视器两个窗口的频繁切换也让Alt和Tab键损坏的几率增加了几成。有没有办法让开发板通过调试器和IDE就能输出呢？&lt;/p&gt;
&lt;p&gt;可以用ARM的ITM（Instrumentation Trace Macroblock），通过&lt;code&gt;TRACESWO&lt;/code&gt;发送。&lt;code&gt;SWO&lt;/code&gt;与JTAG的&lt;code&gt;JTDIO&lt;/code&gt;是同一个引脚，用标准ST-LINK的20-pin排线可以连接，但是10-pin的简版ST-LINK没有引出&lt;code&gt;SWO&lt;/code&gt;，因此要使用ITM调试不能用简版的4线接法。&lt;/p&gt;
&lt;p&gt;ITM无需初始化，直接调用&lt;code&gt;ITM_SendChar&lt;/code&gt;函数即可发送，该函数定义在&lt;code&gt;\Drivers\CMSIS\Include\core_cmx.h&lt;/code&gt;中。ITM版的&lt;code&gt;_write&lt;/code&gt;函数，不过是把&lt;code&gt;usart1_transmit&lt;/code&gt;换成&lt;code&gt;ITM_SendChar&lt;/code&gt;而已。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &quot;main.h&quot;
#include &amp;lt;stdio.h&amp;gt;

void SystemClock_Config(void);
static void MX_GPIO_Init(void);

int _write(int file, char* ptr, int len)
{
  for (int i = 0; i != len; ++i)
    ITM_SendChar(*ptr++);
  return len;
}

uint8_t count = 0;

int main(void)
{
  HAL_Init();
  SystemClock_Config();
  MX_GPIO_Init();
  while (1)
  {
    printf(&quot;Hello world: %d\n&quot;, count);
    HAL_GPIO_TogglePin(LED_GPIO_Port, LED_Pin);
    ++count;
    HAL_Delay(500);
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了在IDE中看到&lt;code&gt;printf&lt;/code&gt;输出的内容，需要做几步配置。首先进入Debug模式，在调试选项的Debugger页启用SWV：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1734552/202006/1734552-20200609013454296-2101988933.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;找到SWV ITM Data Console窗口：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1734552/202006/1734552-20200609013502783-1175628587.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;窗口右上角Configure trace，勾选Port 0：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1734552/202006/1734552-20200609013508863-1702652579.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击Start Trace。这样就可以看见&lt;code&gt;printf&lt;/code&gt;的输出了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1734552/202006/1734552-20200609013516178-1656542743.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;杂记&quot;&gt;杂记&lt;/h3&gt;
&lt;p&gt;好久没更博客了。这两周一直在做摇摇棒，硬件软件交替着改，总算是做出一个比较稳定的显示效果了。计划本月再更两篇。&lt;/p&gt;
&lt;p&gt;有一次下载器与摇摇棒的连接有松动，数据传输错误，导致熔丝位被修改，时钟源选择了不存在的，程序无法启动，也无法下载新的程序。还好我带着这块STM32开发板，在一个引脚上产生一个较高频率的方波，连接到单片机的晶振引脚，改回熔丝位，算是把单片机救活了。本来STM32开发板带着是要写这篇&lt;code&gt;printf&lt;/code&gt;的，博客没写，倒是有救场的用途。&lt;/p&gt;
&lt;p&gt;与&lt;code&gt;printf&lt;/code&gt;相对的&lt;code&gt;scanf&lt;/code&gt;，我也尝试过实现，但是有两个问题，一是我没有找到在STM32CubeIDE中如何通过ITM向单片机发送，二是&lt;code&gt;_read&lt;/code&gt;函数的&lt;code&gt;len&lt;/code&gt;参数总是&lt;code&gt;1024&lt;/code&gt;，这是想让我一次性读&lt;code&gt;1024&lt;/code&gt;个字节再返回吗？&lt;/p&gt;
</description>
<pubDate>Mon, 08 Jun 2020 17:36:00 +0000</pubDate>
<dc:creator>jerry_fuyi</dc:creator>
<og:description>printf复习 当我们写printf(&amp;amp;quot;%d\n&amp;amp;quot;, 1);的时候，printf函数并不能通过C语言语法得知第二个参数是int类型。printf是一个变参函数（v</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jerry-fuyi/p/13063308.html</dc:identifier>
</item>
<item>
<title>关于Graph Convolutional Network的初步理解 - 那不太可能</title>
<link>http://www.cnblogs.com/missouter/p/13064867.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/missouter/p/13064867.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　为给之后关于图卷积网络的科研做知识积累，这里写一篇关于GCN基本理解的博客。GCN的本质是一个图网络中，特征信息的交互+与传播。这里的图指的不是图片，而是数据结构中的图，图卷积网络的应用非常广泛 ，经常被举到的典型例子就是一个空间中热量的传递和交互，这里不多作赘述。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、图卷积网络与普通卷积网络的应用范围&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　图卷积网络为什么叫图卷积网络呢？图卷积网络，其实就是就是GCN，但GCN为什么是图神经网络呢？小编也很疑惑。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　好了！开玩笑的话先打住，进入正题。首先复习一下卷积神经网络的工作原理，以检测图片的过程为例，卷积神经网络提取图片特征的过程，其实就是对每个像素周边像素加权求和的过程，初始每个像素对应的卷积核的权重随机，在通过反向传递、逐层梯度下降的优化之后才会得到合理的权重，根据这个权重得到的feature map便是特征提取的结果。对于图像等像素排列规整的结构来说，使用普通的卷积神经网络提取特征没有任何问题，但对于某些形如交通网、电网等“不整齐”的结构，普通的CNN就没有用武之地了，引用知乎大佬学术性的话讲，就是“CNN在Non Euclidean Structure的数据上无法保持平移不变性”，&lt;span&gt;翻译成人话&lt;/span&gt;就是对于图结构的数据，其每个点邻接的数量各不相同，会给CNN提取特征带来很大的困难；要提取图结构的空间特征进行后续的机器学习，就需要使用图卷积网络。简而言之，GCN是CNN的升级版，CNN做不到的，GCN可以做，GCN做的到的，CNN做不到。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、图卷积网络提取空间特征的方式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　提取拓扑图空间特征有两种方法：空间领域与谱领域。这里我只对谱领域的提取方法作总结概述&lt;span&gt;（空间领域的没学）&lt;/span&gt;，通过定义图上的傅里叶变换，图的卷积方式得到表示方式，与深度学习结合得到最终的图卷积网络。在进行傅里叶和卷积的推导前先复习一下线代？一张图的拉普拉斯矩阵一般为其度矩阵D减去其邻接矩阵A，其他常见定义也有D&lt;sup&gt;-1&lt;/sup&gt;LD与D&lt;sup&gt;-1&lt;/sup&gt;L。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.图的特征分解&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　对图的拉普拉斯矩阵进行谱分解，说的通俗易懂一点就是对角化。使用拉普拉斯矩阵进行运算的优势在这里体现：拉普拉斯矩阵满足谱分解所需线性无关的条件。图的拉普拉斯矩阵分解形式为UPU-1，其中U=[u1，u2，…，un]，为列向量是单位特征向量的矩阵；P为含有n个特征值的对角矩阵。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.含特征向量与特征值矩阵的傅里叶变换定义&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在浏览一些大佬的博客与知乎时我常常感到诧异：进行完矩阵分解后怎么突然讲到傅里叶变化了？理清思路后发现相关矩阵傅里叶变换的定义是最后卷积公式推导的基础，由于两函数的卷积是其函数傅立叶变换乘积的逆变换，即：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1829854/202006/1829854-20200609005439905-584482588.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　为了能将针对图的傅里叶变换类比代入上述公式，我们需要推广傅里叶变换，把特征函数 &lt;strong&gt;e&lt;sup&gt;iωt&lt;/sup&gt; &lt;/strong&gt;变为拉普拉斯矩阵的特征向量。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　由傅里叶变换的一般形式：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1829854/202006/1829854-20200609005629096-10628621.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;类比特征方程定义：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;LV=λV&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　L、V、λ分别代表拉普拉斯矩阵、特征向量/函数、特征值。将特征向量与前面定义的u矩阵对应，得到最终图的傅里叶变换定义为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1829854/202006/1829854-20200609005744826-1543366565.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　其中&lt;strong&gt;f(i)&lt;/strong&gt;对应图的各个顶点，&lt;strong&gt;u&lt;sub&gt;x&lt;/sub&gt;&lt;sup&gt;*&lt;/sup&gt;(i)&lt;/strong&gt;表示第x个特征向量的第 i 个分量。那么特征值&lt;strong&gt;λ&lt;sub&gt;x&lt;/sub&gt;&lt;/strong&gt;下F的图傅里叶变换就是与&lt;strong&gt;λ&lt;sub&gt;x&lt;/sub&gt;&lt;/strong&gt;对应的特征向量&lt;strong&gt;u&lt;sub&gt;x&lt;/sub&gt;&lt;/strong&gt;进行内积运算。矩阵形式为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1829854/202006/1829854-20200608230228567-115375746.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　即&lt;strong&gt;f^=U&lt;sup&gt;T&lt;/sup&gt; f&lt;/strong&gt;。同时由傅里叶逆变换基本公式：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1829854/202006/1829854-20200609005853057-1928593254.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　得到傅里叶逆变换的矩阵形式：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/1829854/202006/1829854-20200608231138963-732185696.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　即&lt;strong&gt;f=Uf^&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.图卷积推导　　&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在定义完图上的傅里叶变换之后，总算要开始&lt;span&gt;让梦想照进现实&lt;/span&gt;将卷积运算推广到图上了。由卷积定理：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1829854/202006/1829854-20200609005919930-1700462892.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　    将对应图上各点的f与卷积核h的傅里叶定义代入其中，卷积核在图上的傅里叶变换被定义为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1829854/202006/1829854-20200608233617126-1454497555.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　按卷积定理将两者傅里叶变换形式相乘得到：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1829854/202006/1829854-20200609000729972-1495073555.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　最后乘U求得傅立叶变换乘积的逆变换，最终得到卷积：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1829854/202006/1829854-20200609001152022-331132969.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　以上，GCN粗略的推导过程就整理完毕了。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　参考网站：&lt;/span&gt;&lt;span&gt;　&lt;a href=&quot;https://www.zhihu.com/question/54504471?sort=created&quot;&gt;https://www.zhihu.com/question/54504471?sort=created&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　&lt;a href=&quot;https://www.cnblogs.com/h2zZhou/p/8405717.html&quot;&gt;https://www.cnblogs.com/h2zZhou/p/8405717.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 08 Jun 2020 16:25:00 +0000</pubDate>
<dc:creator>那不太可能</dc:creator>
<og:description>为给之后关于图卷积网络的科研做知识积累，这里写一篇关于GCN基本理解的博客。GCN的本质是一个图网络中，特征信息的交互+与传播。这里的图指的不是图片，而是数据结构中的图，图卷积网络的应用非常广泛 ，经</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/missouter/p/13064867.html</dc:identifier>
</item>
</channel>
</rss>