<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>如何优雅地删除 Linux 中的垃圾文件 - 良许Linux</title>
<link>http://www.cnblogs.com/yychuyu/p/12418334.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yychuyu/p/12418334.html</guid>
<description>&lt;p&gt;不知道大家是否也跟我一样，是一只要把的自己电脑文件安排的条理有序，把没用的文件会及时删掉的程序猿呢？如果是的话，那么我们可以愉快地探讨下文章的内容。如果不是的话，你也可以留下来凑凑热闹嘛(&amp;gt;-&amp;lt;)。&lt;/p&gt;
&lt;p&gt;下面要介绍的是今天的主角—— &lt;code&gt;tmpwatch&lt;/code&gt; ，它能帮助我们递归删除在给定时间内没有访问的文件和空目录。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;当然，我们也可以使用 &lt;code&gt;find&lt;/code&gt; 命令查找并删除超过 x 天未访问的文件，不过 &lt;code&gt;tmpwatch&lt;/code&gt; 可以一步到位，何乐而不为？&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;tmpwatch&lt;/code&gt; 默认根据文件或目录的访问时间（access time）来决定删除哪些文件或目录。除此之外，你还可以根据 inode 改变时间（inode change time）、修改时间（modification time）来进行操作。&lt;/p&gt;
&lt;p&gt;通常，&lt;code&gt;tmpwatch&lt;/code&gt; 用于删除 &lt;code&gt;/tmp&lt;/code&gt; 目录下的文件，以及其它地方其他无用的文件，如旧的日志文件。&lt;/p&gt;
&lt;h4 id=&quot;重要警告&quot;&gt;重要警告！！&lt;/h4&gt;
&lt;p&gt;不要在 &lt;code&gt;/&lt;/code&gt;（根目录）中运行 tmpwatch！&lt;br/&gt;不要在 &lt;code&gt;/&lt;/code&gt;（根目录）中运行 tmpwatch！！&lt;br/&gt;不要在 &lt;code&gt;/&lt;/code&gt;（根目录）中运行 tmpwatch！！！（三遍警告！ ^ - ^ ）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/&lt;/code&gt; 目录包含 Linux 系统运行所必需的重要文件，而&lt;code&gt;tmpwatch&lt;/code&gt; 并没有内置保护机制防止在&lt;code&gt;/&lt;/code&gt; 目录上运行，一旦那些重要的文件被删除了，后果不堪设想！所以，小伙伴们在使用这个命令的时候一定要慎重！&lt;/p&gt;
&lt;h4 id=&quot;安装-tmpwatch&quot;&gt;安装 tmpwatch&lt;/h4&gt;
&lt;p&gt;大多数 Linux 发行版的默认存储库中都提供 &lt;code&gt;tmpwatch&lt;/code&gt; 的安装：&lt;/p&gt;
&lt;p&gt;在 Fedora 上：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ sudo dnf install tmpwatch&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 CentOS 上：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ sudo yum install tmpwatch&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 openSUSE 上：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ sudo zypper install tmpwatch&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 Debian 及其衍生版本（如 Ubuntu ）上，&lt;code&gt;tmpwatch&lt;/code&gt; 又叫 &lt;code&gt;tmpreaper&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ sudo apt install tmpreaper&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;使用-tmpwatchtmpreaper-删除指定时间内未访问的文件&quot;&gt;使用 tmpwatch/tmpreaper 删除指定时间内未访问的文件&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;tmpwatch&lt;/code&gt; 和 &lt;code&gt;tmpreaper&lt;/code&gt; 的用法几乎相同，可以认为二者是一样的命令。为了便于描述，本文以 &lt;code&gt;tmpwatch&lt;/code&gt; 为例进行讲解，使用基于 Debian 系统的朋友可以将下面的 &lt;code&gt;tmpwatch&lt;/code&gt; 改为 &lt;code&gt;tmpreaper&lt;/code&gt;。&lt;/p&gt;
&lt;h5 id=&quot;删除超过-x-天未访问的文件&quot;&gt;1. 删除超过 X 天未访问的文件&lt;/h5&gt;
&lt;p&gt;例：删除 &lt;code&gt;/var/log/&lt;/code&gt; 文件夹中超过 10 天未访问的所有文件和空目录&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;tmpwatch 10d /var/log/&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;删除超过-x-天未修改的文件&quot;&gt;2. 删除超过 X 天未修改的文件&lt;/h5&gt;
&lt;p&gt;前文提到， &lt;code&gt;tmpwatch&lt;/code&gt; 默认根据访问时间来删除文件的，现在我们使用 &lt;code&gt;-m&lt;/code&gt; 选项来根据文件的修改时间（modification time）来删除文件。&lt;/p&gt;
&lt;p&gt;例：删除 &lt;code&gt;/var/log/&lt;/code&gt; 文件夹中超过 10 天未修改的文件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;tmpwatch -m 10d /var/log/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面两个命令中的 &lt;code&gt;d&lt;/code&gt; 是时间参数，具体如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;d - 天数&lt;/li&gt;
&lt;li&gt;h - 小时&lt;/li&gt;
&lt;li&gt;m - 分钟&lt;/li&gt;
&lt;li&gt;s - 秒数&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;em&gt;默认时间参数是&lt;strong&gt;小时&lt;/strong&gt;&lt;/em&gt; 。假如想删除过去 10 个小时未修改的文件，可以写成下面这种形式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;tmpwatch -m 10 /var/log/&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;删除符号链接&quot;&gt;3. 删除符号链接&lt;/h5&gt;
&lt;p&gt;可以使用 &lt;code&gt;-s&lt;/code&gt; 选项删除符号链接：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;tmpwatch -s 10 /var/log/&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;删除所有文件包括常规文件符号链接和目录&quot;&gt;4. 删除所有文件（包括常规文件，符号链接和目录）&lt;/h5&gt;
&lt;p&gt;tmpwatch 不仅仅可以删普通文件，还可以删除一些特殊文件，比如符号链接、目录、管道文件等等。这个情况下，需要使用 &lt;code&gt;-a&lt;/code&gt; 选项：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;tmpwatch -a 10 /var/log/&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;删除时排除目录&quot;&gt;5. 删除时排除目录&lt;/h5&gt;
&lt;p&gt;如果不想删除某个目录，可以使用 &lt;code&gt;--nodirs&lt;/code&gt; 选项，在删除时排除对该目录的删除：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;tmpwatch -am 10 --nodirs /var/log/&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;测试删除不实际删除任何内容&quot;&gt;6. 测试删除（不实际删除任何内容）&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;这里要再次强调，在对重要目录进行文件删除时，不要急着使用 &lt;code&gt;tmpwatch&lt;/code&gt; 命令！不妨先看看命令运行之后删除的文件有哪些，不然删错了脑壳又疼了。。（养成一种好习惯！）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以使用 &lt;code&gt;-t&lt;/code&gt; 进入测试模式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;tmpwatch -t 30 /var/log/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;CentOS 7 下输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;removing file /var/log/wtmp
removing directory /var/log/ppp if empty
removing directory /var/log/tuned if empty
removing directory /var/log/anaconda if empty
removing file /var/log/dmesg.old
removing file /var/log/boot.log
removing file /var/log/dnf.librepo.log&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;基于 Debian 的系统下输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ tmpreaper -t 30 /var/log/
(PID 1803) Pretending to clean up directory `/var/log/'.
(PID 1804) Pretending to clean up directory `apache2'.
Pretending to remove file `apache2/error.log'.
Pretending to remove file `apache2/access.log'.
Pretending to remove file `apache2/other_vhosts_access.log'.
(PID 1804) Back from recursing down `apache2'.
(PID 1804) Pretending to clean up directory `dbconfig-common'.
Pretending to remove file `dbconfig-common/dbc.log'.
(PID 1804) Back from recursing down `dbconfig-common'.
(PID 1804) Pretending to clean up directory `dist-upgrade'.
(PID 1804) Back from recursing down `dist-upgrade'.
(PID 1804) Pretending to clean up directory `lxd'.
(PID 1804) Back from recursing down `lxd'.
Pretending to remove file `/var/log//cloud-init.log'.
(PID 1804) Pretending to clean up directory `landscape'.
Pretending to remove file `landscape/sysinfo.log'.
(PID 1804) Back from recursing down `landscape'.
[...]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面这个过程，其实并没有真正删除文件，只是进行模拟删除，告知你哪些文件会被删除。&lt;/p&gt;
&lt;p&gt;在确保要删除的文件都是正确的时候，方可去掉 &lt;code&gt;-t&lt;/code&gt; 选项再执行 &lt;code&gt;tmpwatch&lt;/code&gt; 进行真正删除。&lt;/p&gt;
&lt;h5 id=&quot;强制删除&quot;&gt;7. 强制删除&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;tmpwatch&lt;/code&gt; 默认不会删除当前用户没有写访问权的文件。&lt;/strong&gt;但是如果你必须要删除那些文件，可以使用 &lt;code&gt;-f&lt;/code&gt; 选项进行强制删除：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;tmpwatch -f 10h /var/log/&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;删除时跳过某些文件&quot;&gt;8. 删除时跳过某些文件&lt;/h5&gt;
&lt;p&gt;若想在删除时保留指定的文件，也就是说列入白名单，可以使用 &lt;code&gt;--protect&lt;/code&gt; 选项。假设我们要保留所有 &lt;code&gt;txt&lt;/code&gt; 类型的文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;tmpreaper --protect '*.txt' -t 10h /var/log/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;(PID 2623) Pretending to clean up directory `/var/log/'.
(PID 2624) Pretending to clean up directory `apache2'.
Pretending to remove file `apache2/error.log'.
Pretending to remove file `apache2/access.log'.
Pretending to remove file `apache2/other_vhosts_access.log'.
(PID 2624) Back from recursing down `apache2'.
(PID 2624) Pretending to clean up directory `dbconfig-common'.
Pretending to remove file `dbconfig-common/dbc.log'.
(PID 2624) Back from recursing down `dbconfig-common'.
(PID 2624) Pretending to clean up directory `dist-upgrade'.
(PID 2624) Back from recursing down `dist-upgrade'.
Pretending to remove empty directory `dist-upgrade'.
Entry matching `--protect' pattern skipped. `ostechnix.txt'
(PID 2624) Pretending to clean up directory `lxd'.&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;设置-cron-job-定期自动删除文件&quot;&gt;设置 cron job 定期自动删除文件&lt;/h4&gt;
&lt;p&gt;（偷偷地告诉你，&lt;code&gt;tmpwatch/tmpreaper&lt;/code&gt; 与 &lt;code&gt;cron job&lt;/code&gt; 一起食用更佳哦。）&lt;/p&gt;
&lt;p&gt;进入 &lt;code&gt;cron job&lt;/code&gt; 任务编辑窗口：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# crontab -e&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;添加一个周期任务：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;0 1 * * * /usr/sbin/tmpwatch 30d /var/log/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码设置了 &lt;code&gt;tmpwatch&lt;/code&gt; 每天凌晨 1 点运行，并删除 30 天之前的文件。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;不了解 corn job 的小伙伴可以上网搜下它的初学者指南哈。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;安装 &lt;code&gt;tmpreaper&lt;/code&gt; 时，它会自动创建一个日常 &lt;code&gt;cron job&lt;/code&gt;（/etc/cron.daily/Tmpreaper）。它从 /etc/timereaper.conf 文件中读取配置并执行。默认设置的是删除 7 天以前的文件，你可以通过修改 TMPREAPER.conf 文件中 &lt;code&gt;“TMPREAPER_TIME=7d”&lt;/code&gt; 来更改这项设置。&lt;/p&gt;
&lt;h4 id=&quot;写在最后&quot;&gt;写在最后&lt;/h4&gt;
&lt;p&gt;最后在提醒一下，在删除文件的时候一定要仔细检查好路径，以免数据丢失。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;tmpwatch&lt;/code&gt; 和 &lt;code&gt;tmpreaper&lt;/code&gt; 手册页：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ man tmpwatch&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;$ man tmpreaper&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;-----------------&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;良许&lt;/strong&gt;，&lt;strong&gt;世界500强&lt;/strong&gt;外企 Linux 开发工程师，Linux 布道者，欢迎关注我的公众号「&lt;strong&gt;良许Linux&lt;/strong&gt;」，满满都是干货！&lt;br/&gt;&lt;strong&gt;→「技术干货推送」&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;→「独家资料共享」&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;→「高手如云社群」&lt;/strong&gt;&lt;br/&gt;如果您对我的专题内容感兴趣，也可以关注我的博客：&lt;a href=&quot;https://www.lxlinux.net&quot;&gt;lxlinux.net&lt;/a&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1218435/202003/1218435-20200305085426348-327521569.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 05 Mar 2020 00:54:00 +0000</pubDate>
<dc:creator>良许Linux</dc:creator>
<og:description>不知道大家是否也跟我一样，是一只要把的自己电脑文件安排的条理有序，把没用的文件会及时删掉的程序猿呢？如果是的话，那么我们可以愉快地探讨下文章的内容。如果不是的话，你也可以留下来凑凑热闹嘛( &amp;lt;)</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yychuyu/p/12418334.html</dc:identifier>
</item>
<item>
<title>前端公共图表数据大盘方案 - 子慕大诗人</title>
<link>http://www.cnblogs.com/1wen/p/12258884.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/1wen/p/12258884.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;前端常常会在的业务中后台开发数据统计图表，对于类似Echarts这种配置性极强的库，需要花费很多时间查看文档， 一个项目中统计图表大多情况下只占少部分，平时写的不多容易忘记配置，重复开发的效率低。产品经理对于图表的设计个性化明显（今天看到一种样式的图表觉得也挺好，然后就想照搬到自己业务之中），同类型的图表可能样式不一，代码又得重新写。总归给人的感受就是开发效率低，产品设计效率低。&lt;/p&gt;
&lt;p&gt;在文章的开始我们先来看看一个前端平常在开发各种数据图表时，可能经历的过程，以Echarts为例：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;打开echarts官网&lt;/li&gt;
&lt;li&gt;查看实例界面，参考需要实现的类似的图例，找到合适的实例拷贝需要的实例代码&lt;/li&gt;
&lt;li&gt;打开业务项目复制代码，发现需要安装依赖，也许通过html中script引入，也许通过模块方式引入（这种情况下可能还需要配置一下webpack解决一些依赖优化的问题）&lt;/li&gt;
&lt;li&gt;发现细节上和ui或者产品原型不符，开始查找文档配置，比如：轴线颜色，刻度颜色，内间距，提示器，文案模版等等&lt;/li&gt;
&lt;li&gt;做第二个图表的时候，发现和第一个类似都是折线图，但是这次是一个图中有多个折线，ui在细节上又发生了一些变化，然后重复上面步骤4。&lt;/li&gt;
&lt;li&gt;一段时间以后，另一个业务项目，再次需要做数据图表。这个时候，想到以前做过，然后找到老项目对比图表，拷贝类似的代码，进行修改，发现细节不一致的地方又开始步骤4&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;因为每次做的图表不一样重复步骤4、5几次以后，耗费的时间已经很多了，加上配置代码本身就比较多，2、3个图表就能让代码上一百行。经历过几次这样的折腾以后，可能稍微熟悉了一下API，但是仍然会觉得每次开发的效率好低。于是就有了今天所做的分享，下面进入正文。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/623144/202002/623144-20200207175955743-836578226.png&quot; alt=&quot;&quot; width=&quot;612&quot; height=&quot;308&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/623144/202002/623144-20200207180329221-579102938.png&quot; alt=&quot;&quot; width=&quot;612&quot; height=&quot;435&quot;/&gt;&lt;/p&gt;

&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;&lt;strong&gt;方案&lt;/strong&gt;&lt;/h2&gt;
&lt;p class=&quot;ql-long-8696677&quot;&gt;&lt;span class=&quot;ql-author-8696677&quot;&gt;针对公司各个业务中后台项目开发数据统计图表的应用场景，为了解决以上两个效率问题，我想到了通过下面两个方向来做处理：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li class=&quot;ql-long-8696677&quot;&gt;&lt;span class=&quot;ql-author-8696677&quot;&gt;抽象代码减少应用代码量，傻瓜式配置避免每一个开发者花费时间重复阅读文档 —— 提升开发效率。&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;ql-long-8696677&quot;&gt;&lt;span class=&quot;ql-author-8696677&quot;&gt;统一图表使用风格，减少一定程度个性化，提供图表界面和对应组件代码 —— 提升产品设计效率。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;简单来说，就是封装公共图表组件供团队使用，约定统一图表样式，提供可视化界面文档&lt;/p&gt;
&lt;p class=&quot;ql-long-8696677&quot;&gt;&lt;span class=&quot;ql-author-8696677&quot;&gt;优点：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li class=&quot;ql-long-8696677&quot;&gt;&lt;span class=&quot;ql-author-8696677&quot;&gt;只关心更核心的配置、组件抹去配置细节、提升开发效率&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;ql-long-8696677&quot;&gt;&lt;span class=&quot;ql-author-8696677&quot;&gt;&lt;span class=&quot;ql-author-8696677&quot;&gt;提升产品设计效率、省去设计选择的时间&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;ql-long-8696677&quot;&gt;&lt;span class=&quot;ql-author-8696677&quot;&gt;缺点：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li class=&quot;ql-long-8696677&quot;&gt;&lt;span class=&quot;ql-author-8696677&quot;&gt;缺少一定灵活性（抽离常用部分，牺牲灵活性，多用共性）&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;ql-long-8696677&quot;&gt;&lt;span class=&quot;ql-author-8696677&quot;&gt;公共图表组件开发需要投入成本 &lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;ql-long-8696677&quot;&gt; &lt;/p&gt;
&lt;h2 class=&quot;ql-long-8696677&quot;&gt;实施&lt;/h2&gt;
&lt;h4&gt;JS组件库&lt;/h4&gt;
&lt;p class=&quot;ql-long-8696677&quot;&gt;目的和方向已经明确，我们可能会第一时间想到，那肯定就是基于三方图表库做一次组件封装，通过npm安装依赖，最后再写好文档就行了。现在称它为JS组件库方案，那我们来考虑考虑此方案组件库的一个实现和使用流程，以Echarts为例&lt;/p&gt;
&lt;ol&gt;&lt;li class=&quot;ql-long-8696677&quot;&gt;新建一个代码库，安装echarts依赖&lt;/li&gt;
&lt;li class=&quot;ql-long-8696677&quot;&gt;新建组件（比如一个折线图组件）&lt;/li&gt;
&lt;li class=&quot;ql-long-8696677&quot;&gt;封装组件参数，回调方法等&lt;/li&gt;
&lt;li class=&quot;ql-long-8696677&quot;&gt;如果要兼容vue，angular，react，组件代码需要写三套兼容，或者通过代码优化和构建处理，一套代码生成多种框架组件&lt;/li&gt;
&lt;li class=&quot;ql-long-8696677&quot;&gt;定版本，发布组件库&lt;/li&gt;
&lt;li class=&quot;ql-long-8696677&quot;&gt;写一个网页文档并在网页上展示实例&lt;/li&gt;
&lt;li class=&quot;ql-long-8696677&quot;&gt;业务系统安装组件库使用&lt;/li&gt;
&lt;li class=&quot;ql-long-8696677&quot;&gt;如果代码需要升级或者修改bug，需要重新修改组件库，并发新版本，业务系统重装依赖&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;下图为此方案的示意图：&lt;/p&gt;
&lt;p class=&quot;ql-long-8696677&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/623144/202002/623144-20200207175146281-2077184264.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-8696677&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;ql-long-8696677&quot;&gt;&lt;span class=&quot;ql-author-8696677&quot;&gt;但是以上的方案带来了一些麻烦和问题：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li class=&quot;ql-long-8696677&quot;&gt;&lt;span class=&quot;ql-author-8696677&quot;&gt;可能需要兼容多套框架，组件库开发成本增加&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;ql-long-8696677&quot;&gt;&lt;span class=&quot;ql-author-8696677&quot;&gt;修改bug和库升级都需要发版本，每一个业务系统都有可能需要在一个版本之后更新依赖，维护成本增加&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;ql-long-8696677&quot;&gt; &lt;/p&gt;
&lt;h4 class=&quot;ql-long-8696677&quot;&gt;Iframe方案&lt;/h4&gt;
&lt;p class=&quot;ql-long-8696677&quot;&gt;&lt;span class=&quot;ql-author-8696677&quot;&gt;而我最初的下手点是通过iframe + postMessage来实施了这套方案，下面介绍一下此方案。此方案最终把一个个组件输出为一个静态的页面，通过iframe的方式，嵌入到我们的业务系统之中，通过postMessage来传递数据、配置和事件绑定。先介绍一下大致开发和使用流程，而后对其优劣做分析。&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li class=&quot;ql-long-8696677&quot;&gt;新建代码库，安装echarts依赖&lt;/li&gt;
&lt;li class=&quot;ql-long-8696677&quot;&gt;新建页面组件（比如一个折线图组件）&lt;/li&gt;
&lt;li class=&quot;ql-long-8696677&quot;&gt;封装组件参数，回调方法等&lt;/li&gt;
&lt;li class=&quot;ql-long-8696677&quot;&gt;打包输出为一个个静态资源页面，发布到静态资源服务器&lt;/li&gt;
&lt;li class=&quot;ql-long-8696677&quot;&gt;写一个网页文档并在网页上展示实例&lt;/li&gt;
&lt;li class=&quot;ql-long-8696677&quot;&gt;业务系统不需要安装任何依赖，通过Iframe配置url引入组件，通过postMessage发送配置和数据&lt;/li&gt;
&lt;li class=&quot;ql-long-8696677&quot;&gt;如果代码需要升级或者修改bug，重新修改组件库，打包更新静态资源，业务系统不需要重装依赖直接访问就更新。如果存在变化比较大的类似组件，可以考虑输出新版本，比如老版本是xxx.com/v1/bar.html,新版可以定义为xxx.com/v2/bar.html，互不影响&lt;/li&gt;
&lt;/ol&gt;&lt;p class=&quot;ql-long-8696677&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;ql-long-8696677&quot;&gt;下图为此方案的示意图：&lt;/p&gt;
&lt;p class=&quot;ql-long-8696677&quot;&gt;&lt;span class=&quot;ql-author-8696677&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/623144/202002/623144-20200207175141033-1215565663.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;




&lt;p&gt; 下面我们来对比一下两个方案：&lt;/p&gt;
&lt;h4&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/623144/202003/623144-20200304231620793-73679003.png&quot; alt=&quot;&quot;/&gt;&lt;/h4&gt;


&lt;h2 class=&quot;ql-long-8696677&quot;&gt;优化&lt;/h2&gt;
&lt;h4&gt;稳定性：&lt;/h4&gt;
&lt;p&gt;Iframe有个比较需要特别谨慎的地方就在于其稳定性上的问题，由于所有业务系统的图表都指向到公共图表项目，都需要对其进行访问，如果出现了问题，那影响是很大的。由于业务系统是分散的，我们在发布新的公共图表项目版本的时候，需要进行一轮测试，测试新版本，首先需要满足的是不影响已有业务系统。于是，针对这两个问题，我们一方面需要严格保障公共图表项目的代码质量，在代码合并权限控制和人为review上需要格外重视；一方面可以同样通过Iframe的方式，在公共图表的文档网站页面加入一个页面菜单、嵌入所有中后台业务系统的相关页面。由于我们中后台统一接入了公司内部开发的sso权限登录系统，因此可以根据当前的登录用户和他的权限，看到他所能够看到的业务系统的图表统计相关的页面。那我们给一个测试用户配置所有业务的权限，就能通过公共图表系统本身查看到所有业务相关界面，以此来做测试验收。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;也因为如此，公共图表项目本身不仅提供了页面组件给业务中后台系统使用，也同时集合了所有业务系统的数据统计界面，变成了一个真正的数据大盘。到此我们的方案就是一个完整的公共图表数据大盘。&lt;/strong&gt;&lt;/p&gt;
&lt;h4&gt;资源大小&lt;/h4&gt;
&lt;p&gt;在静态资源大小方面，每一个html组件，只引入了一个三方图表库和组件本身的一小段js代码，并没有引入任何框架，尽可能的减少文件大小。&lt;/p&gt;
&lt;h4&gt;迭代原则：&lt;/h4&gt;
&lt;p&gt;首先做封装是有成本的，并不是一开始我们就写好所有的组件库，而更多应该是在开发需要某一种图表时，再考虑进行封装，封装的同时不仅要考虑当前版本使用，也要尽量考虑通用性和后期其他项目使用的情况&lt;/p&gt;
&lt;h4&gt;纯个性化配置&lt;/h4&gt;
&lt;p&gt;当然很多情况下 需要个性化配置我们的图表，既然当前已经有了公共系统，如果遇到个性化的图表，难道又要让业务系统去安装Echarts依赖，然后以旧的模式写配置吗？所以，在公共图表项目内部也提供一个纯个性化配置的图表，也就是没有任何多余封装的组件，配置信息完全需要业务方写好，组件直接调用生成，不做任何处理。这样我们依旧不需要管理依赖，仍然也只是关心配置。&lt;/p&gt;
&lt;h4&gt;界面优化和约定&lt;/h4&gt;
&lt;p&gt;如何统一用什么样式的图表，这需要产品、设计和研发一起商量做好约定，这块是需要投入成本的&lt;/p&gt;
&lt;h4&gt;多图表库支持&lt;/h4&gt;
&lt;p&gt;上周在公司内部分享的时候，被问到可以支持多库吗。确实不排除后期需要多库的情况，或者某些图表库不支持我们想用的功能，因此在代码架构配置中做了处理，已经支持多三方图表库存在的情况，具体内容可以看github仓库。&lt;/p&gt;

&lt;h2&gt;Iframe方案可能会被吐槽的一些问题&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;阻塞父页面加载：由于单页面框架内使用Iframe大部分都是在框架本身生命周期中创建节点，所以并不会阻塞业务本身&lt;/li&gt;
&lt;li&gt;安全问题：因为我们的图表项目是自己写的，并且是纯静态资源，没有接口的输入，也没有任何业务，因此没有任何攻击的价值&lt;/li&gt;
&lt;li&gt;性能低下：因为在PC端这样的场景之下，Iframe本身会带来的性能问题是微不足道的，并且一个界面之中的图表大部分情况下是不会超过10个的，即便有10多个，也都并不会导致卡顿。配合上缓存策略，图表的加载实际也很快&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;代码展示&lt;/h2&gt;
&lt;p&gt;业务代码在使用组件时，只需要大致下面这些代码，不需要安装任何依赖&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/623144/202003/623144-20200304232121577-469532396.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/623144/202003/623144-20200304232153404-1342550872.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h2&gt;仓库演示&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://dashiren.cn/public-chart/dist/index.html&quot;&gt;https://dashiren.cn/public-chart/dist/index.html&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;br class=&quot;Apple-interchange-newline&quot;/&gt;
仓库地址&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/zimv/public_chart&quot;&gt;https://github.com/zimv/public_chart&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;结语&lt;/h2&gt;
&lt;p&gt;基于我们需要解决的问题，选择哪一种方案，其实都可以，只是刚好我偏向于Iframe。从发现问题到解决问题，从提出想法到实施落地，以上便是全部内容，希望能给大家带来一些启发，今天的分享就到这里。&lt;/p&gt;
</description>
<pubDate>Thu, 05 Mar 2020 00:48:00 +0000</pubDate>
<dc:creator>子慕大诗人</dc:creator>
<og:description>前言 前端常常会在的业务中后台开发数据统计图表，对于类似Echarts这种配置性极强的库，需要花费很多时间查看文档， 一个项目中统计图表大多情况下只占少部分，平时写的不多容易忘记配置，重复开发的效率低</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/1wen/p/12258884.html</dc:identifier>
</item>
<item>
<title>Spring事务Transactional和动态代理（二）-cglib动态代理 - 骑着龙的羊</title>
<link>http://www.cnblogs.com/qizhelongdeyang/p/12412049.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qizhelongdeyang/p/12412049.html</guid>
<description>&lt;p&gt;系列文章索引：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;http://www.itrensheng.com/archives/spring_transaction_jdk_proxy&quot;&gt;Spring事务Transactional和动态代理（一）-JDK代理实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/qizhelongdeyang/p/Spring事务Transactional和动态代理（一）-JDK代理实现&quot;&gt;Spring事务Transactional和动态代理（二）-cglib动态代理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.itrensheng.com/archives/spring_transactional_uneffect&quot;&gt;Spring事务Transactional和动态代理（三）-事务失效的场景&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;什么是cglib&quot;&gt;什么是cglib&lt;/h3&gt;
&lt;p&gt;Cglib是一个强大的、高性能的代码生成包，它广泛被许多AOP框架使用，为他们提供方法的拦截。它为没有实现接口的类提供代理，为JDK的动态代理提供了很好的补充。JDK必须强制基于interface接口类型：&lt;a href=&quot;http://www.itrensheng.com/archives/spring_transaction_jdk_proxy&quot;&gt;Spring事务Transactional和动态代理（上）-JDK代理实现&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;cglib的应用&quot;&gt;cglib的应用&lt;/h3&gt;
&lt;p&gt;cglib应用很广泛，根据cglib在Github上的描述（&lt;a href=&quot;https://github.com/cglib/cglib/wiki&quot;&gt;cglib&lt;/a&gt;），存在以下应用：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;http://commons.apache.org/proper/commons-bcel/&quot;&gt;Byte Code Engineering Library&lt;/a&gt;&lt;br/&gt;也就是JavaClass字节码文件，这个库可以很方便的分析，创建和操作字节码文件&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://xorm.sourceforge.net/&quot;&gt;XORM&lt;/a&gt;&lt;br/&gt;是一个可扩展的ORM框架，使用cglib来生成持久化对象，为RDBMS提供了映射到接口的持久Entity，让开发人员专注于业务对象模型&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://hibernate.sourceforge.net/&quot;&gt;Hibernate&lt;/a&gt;&lt;br/&gt;Hibernate是一个又一个强大的、超高性能的Java对象/关系持久性框架。可以开发持久对象，包括关联、继承、多态性、组合和Java集合框架&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://staff.develop.com/halloway/code/gd.html&quot;&gt;The Java Class File Editor&lt;/a&gt;&lt;br/&gt;Java类文件编辑器，允许用户在磁盘上或在运行时加载类时读取/修改Class文件，也它可以动态地创建新类&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://nanning.codehaus.org/&quot;&gt;Nanning Aspects&lt;/a&gt;&lt;br/&gt;是一个基于java的简介AOP框架&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://spring.io/&quot;&gt;Spring&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;iBatis/Mybatis&lt;/li&gt;
&lt;li&gt;ASM&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://proxool.sourceforge.net/&quot;&gt;Proxool&lt;/a&gt;&lt;br/&gt;基于java的连接池&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://code.google.com/p/google-guice/&quot;&gt;Guice&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://modelmapper.org/&quot;&gt;ModelMapper&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;cglib的使用&quot;&gt;cglib的使用&lt;/h3&gt;
&lt;p&gt;使用cglib需要先引入jar包，在maven中添加依赖：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;cglib&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;cglib&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;3.3.0&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;新建一个目标类，其中一个为final方法，一个为非final方法，用于对比cglib对于两种方法的织入结果：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Student {

    public void study(){
        System.out.println(&quot;study&quot;);
    }

    public final void eat(){
        System.out.println(&quot;eat&quot;);
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Interceptor 代理类如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class CglibInterceptor implements MethodInterceptor {
    //织入前的处理
    private void beforeInvoke(Method method){
        System.out.println(&quot;before &quot; + method.getName());
    }

    //织入后的处理
    private void afterInvoke(Method method){
        System.out.println(&quot;after &quot;  + method.getName());
    }

    @Override
    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
        beforeInvoke(method);
        //调用cglib的invokeSuper而不是invoke方法
        Object object = methodProxy.invokeSuper(o,objects);
        afterInvoke(method);
        return object;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试类的调用顺序为&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;创建增强建Enhancer实例&lt;/li&gt;
&lt;li&gt;通过setSuperclass方法来设置目标类&lt;/li&gt;
&lt;li&gt;通过setCallback设置Interceptor拦截&lt;/li&gt;
&lt;li&gt;调用Enhancer的create方法生成代理类&lt;br/&gt;代码如下：&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class CglibTesst {

    public static void main(String[] args) {
        //把生产的代理类保存到磁盘指定文件夹
        System.getProperties().put(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, &quot;.&quot;);
        Enhancer enhancer = new Enhancer();
        enhancer.setSuperclass(Student.class);
        enhancer.setCallback(new CglibInterceptor());

        Student studentProxy = (Student) enhancer.create();
        studentProxy.study();
        studentProxy.eat();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中的输出如下，可以看到只有非final方法study织入了before和after逻辑，而final方法eat是没有的：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;before study
study
after study

eat&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;cglib生成的代理class文件分析&quot;&gt;cglib生成的代理class文件分析&lt;/h4&gt;
&lt;p&gt;通过在测试类中加入了&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;System.getProperties().put(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, &quot;.&quot;);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;代码之后，本地就多出来了一些.class文件如下：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/314515/202003/314515-20200304204249287-1394358571.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先看一下Student&lt;span class=&quot;math display&quot;&gt;\[EnhancerByCGLIB\]&lt;/span&gt;92f3e3f6，继承了Student并且实现了Factory接口（接口方法主要是newInstance，setCallback和getCallbacks），该类中的代码太多，以下代码是节选：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Student$$EnhancerByCGLIB$$92f3e3f6 extends Student implements Factory {
    
    //静态初始化类
    static void CGLIB$STATICHOOK1() {
        CGLIB$THREAD_CALLBACKS = new ThreadLocal();
        CGLIB$emptyArgs = new Object[0];
        Class var0 = Class.forName(&quot;com.randy.dynamicproxy.cglib.Student$$EnhancerByCGLIB$$92f3e3f6&quot;);
        Class var1;
        Method[] var10000 = ReflectUtils.findMethods(new String[]{&quot;equals&quot;, &quot;(Ljava/lang/Object;)Z&quot;, &quot;toString&quot;, &quot;()Ljava/lang/String;&quot;, &quot;hashCode&quot;, &quot;()I&quot;, &quot;clone&quot;, &quot;()Ljava/lang/Object;&quot;}, (var1 = Class.forName(&quot;java.lang.Object&quot;)).getDeclaredMethods());
        CGLIB$equals$1$Method = var10000[0];
        CGLIB$equals$1$Proxy = MethodProxy.create(var1, var0, &quot;(Ljava/lang/Object;)Z&quot;, &quot;equals&quot;, &quot;CGLIB$equals$1&quot;);
        CGLIB$toString$2$Method = var10000[1];
        CGLIB$toString$2$Proxy = MethodProxy.create(var1, var0, &quot;()Ljava/lang/String;&quot;, &quot;toString&quot;, &quot;CGLIB$toString$2&quot;);
        CGLIB$hashCode$3$Method = var10000[2];
        CGLIB$hashCode$3$Proxy = MethodProxy.create(var1, var0, &quot;()I&quot;, &quot;hashCode&quot;, &quot;CGLIB$hashCode$3&quot;);
        CGLIB$clone$4$Method = var10000[3];
        CGLIB$clone$4$Proxy = MethodProxy.create(var1, var0, &quot;()Ljava/lang/Object;&quot;, &quot;clone&quot;, &quot;CGLIB$clone$4&quot;);
        CGLIB$study$0$Method = ReflectUtils.findMethods(new String[]{&quot;study&quot;, &quot;()V&quot;}, (var1 = Class.forName(&quot;com.randy.dynamicproxy.cglib.Student&quot;)).getDeclaredMethods())[0];
        CGLIB$study$0$Proxy = MethodProxy.create(var1, var0, &quot;()V&quot;, &quot;study&quot;, &quot;CGLIB$study$0&quot;);
    }

    static {
        CGLIB$STATICHOOK1();
    }

    final void CGLIB$study$0() {
        super.study();
    }

    public final void study() {
        MethodInterceptor var10000 = this.CGLIB$CALLBACK_0;
        //检查当前Callback拦截对象
        if (var10000 == null) {
            CGLIB$BIND_CALLBACKS(this);
            var10000 = this.CGLIB$CALLBACK_0;
        }
        //根据是否存在判定是通过拦截类来调用还是直接调用父类Student的study方法
        if (var10000 != null) {
            var10000.intercept(this, CGLIB$study$0$Method, CGLIB$emptyArgs, CGLIB$study$0$Proxy);
        } else {
            super.study();
        }
    }

    final boolean CGLIB$equals$1(Object var1) {
        return super.equals(var1);
    }

    public final boolean equals(Object var1) {
       ...
    }

    final String CGLIB$toString$2() {
        return super.toString();
    }

    public final String toString() {
       ...
    }

    final int CGLIB$hashCode$3() {
        return super.hashCode();
    }

    public final int hashCode() {
        ...
    }

    final Object CGLIB$clone$4() throws CloneNotSupportedException {
        return super.clone();
    }

    protected final Object clone() throws CloneNotSupportedException {
       ...
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到该生成类中除了实现Factory接口的方法以外，都复写了Student类以及超类Object中的非final方法（对于Student中的final方法eat和Object中的final方法wati,notify,notifyAll等方法都没有复写），&lt;strong&gt;这也就是为什么cglib无法对final方法进行代理，因为java不允许复写final方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;另外两个类 Student&lt;span class=&quot;math display&quot;&gt;\[EnhancerByCGLIB\]&lt;/span&gt;92f3e3f6&lt;span class=&quot;math display&quot;&gt;\[FastClassByCGLIB\]&lt;/span&gt;1d02f934 和 Student&lt;span class=&quot;math display&quot;&gt;\[FastClassByCGLIB\]&lt;/span&gt;ec571eb6 都继承了cglib的抽象类FastClass，&lt;br/&gt;主要是实现了FastClass的一下几个方法&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    public abstract int getIndex(String var1, Class[] var2);
    public abstract int getIndex(Class[] var1);
    public abstract Object invoke(int var1, Object var2, Object[] var3) throws InvocationTargetException;
    public abstract Object newInstance(int var1, Object[] var2) throws InvocationTargetException;
    public abstract int getIndex(Signature var1);
    public abstract int getMaxIndex();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中的&lt;/p&gt;
&lt;h3 id=&quot;cglib的原理&quot;&gt;cglib的原理&lt;/h3&gt;
&lt;p&gt;cglib动态生成一个要代理类的子类，子类重写要代理的类的所有不是final的方法（&lt;strong&gt;cglib无法对final方法进行代理&lt;/strong&gt;）。在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。&lt;/p&gt;
&lt;p&gt;CGLIB底层使用字节码处理框架ASM，来转换字节码并生成新的类。关于java字节码请查看：&lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html&quot;&gt;The Java class File Format&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;enhancer类源码分析&quot;&gt;Enhancer类源码分析&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Enhancer extends AbstractClassGenerator {
    //设置目标类作为父类，也就是对应生成的Student$$EnhancerByCGLIB$$92f3e3f6类继承了Student
    public void setSuperclass(Class superclass) {
        if (superclass != null &amp;amp;&amp;amp; superclass.isInterface()) {
            this.setInterfaces(new Class[]{superclass});
        } else if (superclass != null &amp;amp;&amp;amp; superclass.equals(Object.class)) {
            this.superclass = null;
        } else {
            this.superclass = superclass;
        }

    }
    //通过Enhancer来创建代理类
    public Object create() {
        this.classOnly = false;
        this.argumentTypes = null;
        return this.createHelper();
    }
    
    private Object createHelper() {
        this.preValidate();
        //根据当前设置的父类等信心构造一个唯一的key
        Object key = KEY_FACTORY.newInstance(this.superclass != null ? this.superclass.getName() : null, ReflectUtils.getNames(this.interfaces), this.filter == ALL_ZERO ? null : new WeakCacheKey(this.filter), this.callbackTypes, this.useFactory, this.interceptDuringConstruction, this.serialVersionUID);
        this.currentKey = key;
        Object result = super.create(key);
        return result;
    }
}

    protected Object create(Object key) {
        try {
            ClassLoader loader = this.getClassLoader();
            Map&amp;lt;ClassLoader, AbstractClassGenerator.ClassLoaderData&amp;gt; cache = CACHE;
            //首先从缓存中查找key，如果就生成一个
            AbstractClassGenerator.ClassLoaderData data = (AbstractClassGenerator.ClassLoaderData)cache.get(loader);
            if (data == null) {
                Class var5 = AbstractClassGenerator.class;
                synchronized(AbstractClassGenerator.class) {
                    cache = CACHE;
                    data = (AbstractClassGenerator.ClassLoaderData)cache.get(loader);
                    if (data == null) {
                        Map&amp;lt;ClassLoader, AbstractClassGenerator.ClassLoaderData&amp;gt; newCache = new WeakHashMap(cache);
                        //核心是调用了AbstractClassGenerator的generate来生成字节码文件，并通过ReflectUtils.defineClass返回
                        data = new AbstractClassGenerator.ClassLoaderData(loader);
                        //加入缓存  
                        newCache.put(loader, data);
                        CACHE = newCache;
                    }
                }
            }

            this.key = key;
            Object obj = data.get(this, this.getUseCache());
            //如果是类就通过firstInstance初始化，而firstInstance在AbstractClassGenerator类中是一个抽象方法，具体实现如下
            //firstInstance和nextInstance都是通过cglib的ReflectUtils.newInstance来创建实例的
            return obj instanceof Class ? this.firstInstance((Class)obj) : this.nextInstance(obj);
        } catch (RuntimeException var9) {
            throw var9;
        } catch (Error var10) {
            throw var10;
        } catch (Exception var11) {
            throw new CodeGenerationException(var11);
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;methodproxy&quot;&gt;MethodProxy&lt;/h4&gt;
&lt;p&gt;当所生成的代理类被调用的时候，MethodProxy会在所设置的CallBack中调用intercept方法。而在上面的CglibInterceptor类的intercept方法中就是使用的MethodProxy.invokeSuper方法，源码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public Object invokeSuper(Object obj, Object[] args) throws Throwable {
        try {
            //单例初始化
            init();
            FastClassInfo fci = fastClassInfo;
            return fci.f2.invoke(fci.i2, obj, args);
        } catch (InvocationTargetException e) {
            throw e.getTargetException();
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;init方法&quot;&gt;init方法：&lt;/h4&gt;
&lt;p&gt;init()方法是一个经典的双重检查单例设计模式，初始判断对象是否已经初始化了，如果没有就加锁并再次判空。初始化的内容主要是FastClassInfo对象及其属性&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private final Object initLock = new Object();

private void init()
    {
        if (fastClassInfo == null)
        {
            synchronized (initLock)
            {
                if (fastClassInfo == null)
                {
                    CreateInfo ci = createInfo;
                    FastClassInfo fci = new FastClassInfo();
                    fci.f1 = helper(ci, ci.c1);
                    fci.f2 = helper(ci, ci.c2);
                    //通过getIndex来查找到指定方法的索引
                    fci.i1 = fci.f1.getIndex(sig1);
                    fci.i2 = fci.f2.getIndex(sig2);
                    fastClassInfo = fci;
                    createInfo = null;
                }
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;fastclass机制&quot;&gt;FastClass机制&lt;/h4&gt;
&lt;p&gt;FastClass机制就是对一个类的方法建立索引，通过索引来直接调用相应的方法，在上述的其中的invokeSuper中init初始化的主要就是FastClassInfo（内部类，持有两个FastClass类型的变量）。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; private static class FastClassInfo
    {
        //目标类的FastClass
        FastClass f1;
        //代理类的FastClass
        FastClass f2;
        //目标类方法的索引
        int i1;
        //代理类方法的索引
        int i2;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上一篇&lt;a href=&quot;http://www.itrensheng.com/archives/spring_transaction_jdk_proxy&quot;&gt;JDK代理实现&lt;/a&gt; 中提到JDK拦截对象是通过InvocationHandler反射的机制来调用被拦截方法的，反射的效率比较低。&lt;br/&gt;而cglib是对一个类的方法建立索引，通过索引来直接调用相应的方法。&lt;br/&gt;如生成的Student&lt;span class=&quot;math display&quot;&gt;\[FastClassByCGLIB\]&lt;/span&gt;ec571eb6就是继承了FastClass,通过getIndex(Signature)通过方法签名来定位一个索引，&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    public int getIndex(Signature var1) {
        String var10000 = var1.toString();
        switch(var10000.hashCode()) {
        case -1310345955:
            if (var10000.equals(&quot;eat()V&quot;)) {
                return 1;
            }
            break;
        case 1826985398:
            if (var10000.equals(&quot;equals(Ljava/lang/Object;)Z&quot;)) {
                return 2;
            }
            break;
        case 1876544780:
            if (var10000.equals(&quot;study()V&quot;)) {
                return 0;
            }
            break;
        case 1913648695:
            if (var10000.equals(&quot;toString()Ljava/lang/String;&quot;)) {
                return 3;
            }
            break;
        case 1984935277:
            if (var10000.equals(&quot;hashCode()I&quot;)) {
                return 4;
            }
        }

        return -1;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在根据获取的的Index位置来调用invoke方法，invoke方法在FastClass类中是一个抽象方法，子类（也就是生成的Student&lt;span class=&quot;math display&quot;&gt;\[FastClassByCGLIB\]&lt;/span&gt;ec571eb6继承FastClass）具体实现如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; public Object invoke(int var1, Object var2, Object[] var3) throws InvocationTargetException {
        Student var10000 = (Student)var2;
        int var10001 = var1;

        try {
            switch(var10001) {
            case 0:
                var10000.study();
                return null;
            case 1:
                var10000.eat();
                return null;
            case 2:
                return new Boolean(var10000.equals(var3[0]));
            case 3:
                return var10000.toString();
            case 4:
                return new Integer(var10000.hashCode());
            }
        } catch (Throwable var4) {
            throw new InvocationTargetException(var4);
        }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;https://github.com/cglib/cglib/wiki&lt;/li&gt;
&lt;li&gt;https://tech.meituan.com/2019/09/05/java-bytecode-enhancement.html&lt;/li&gt;
&lt;li&gt;https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html&lt;/li&gt;
&lt;li&gt;https://www.baeldung.com/cglib&lt;/li&gt;
&lt;li&gt;https://www.ibm.com/developerworks/cn/java/j-lo-springaopcglib/index.html&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Thu, 05 Mar 2020 00:48:00 +0000</pubDate>
<dc:creator>骑着龙的羊</dc:creator>
<og:description>系列文章索引： 1. &amp;quot;Spring事务Transactional和动态代理（一） JDK代理实现&amp;quot; 2. &amp;quot;Spring事务Transactional和动态代理（二）</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qizhelongdeyang/p/12412049.html</dc:identifier>
</item>
<item>
<title>Newman+Jenkins实现接口自动化测试 - 雪山飞猪</title>
<link>http://www.cnblogs.com/chenqionghe/p/12417263.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenqionghe/p/12417263.html</guid>
<description>&lt;!--[if IE]&gt;
    &lt;div class=&quot;unsupported-browser&quot;&gt;
        &amp;#35813;&amp;#39029;&amp;#38754;&amp;#19981;&amp;#25903;&amp;#25345; Internet Explorer &amp;#27983;&amp;#35272;&amp;#22120;&amp;#65292;&amp;#24314;&amp;#35758;&amp;#20351;&amp;#29992;
        &lt;a href=&quot;https://www.google.cn/intl/zh-CN/chrome/&quot;&gt;Google Chrome&lt;/a&gt;,
        &lt;a href=&quot;https://www.mozilla.org/zh-CN/firefox/&quot;&gt;Firefox&lt;/a&gt; &amp;#25110;
        &lt;a href=&quot;https://www.microsoftedgeinsider.com/zh-CN/&quot;&gt;Microsoft Edge&lt;/a&gt;
    &lt;/div&gt;
&lt;![endif]--&gt;
&lt;div class=&quot;center-container &quot;&gt;
    &lt;div class=&quot;center-body card  h-sm-100&quot;&gt;
        &lt;div class=&quot;card-body&quot;&gt;
            


&lt;div class=&quot;login-top text-center&quot;&gt;
    &lt;span class=&quot;login-title&quot;&gt;博客园用户登录&lt;/span&gt;
    &lt;a href=&quot;https://www.cnblogs.com/&quot;&gt;
        &lt;svg class=&quot;login-sign&quot;&gt;&lt;use xlink:href=&quot;#icon-login-sign&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;
    &lt;p&gt;代码改变世界&lt;/p&gt;
&lt;/div&gt;
&lt;form id=&quot;loginForm&quot; method=&quot;post&quot; onsubmit=&quot;return false&quot;&gt;
    
        &lt;div class=&quot;form-group&quot;&gt;
            &lt;input tabindex=&quot;1&quot; class=&quot;form-control&quot; placeholder=&quot;登录用户名 / 邮箱&quot; autofocus=&quot;&quot; type=&quot;text&quot; data-val=&quot;true&quot; data-val-required=&quot;请输入登录用户名&quot; id=&quot;LoginName&quot; name=&quot;LoginName&quot; value=&quot;&quot;/&gt;&lt;span class=&quot;invalid-feedback field-validation-valid&quot; data-valmsg-for=&quot;LoginName&quot; data-valmsg-replace=&quot;true&quot;/&gt;
            &lt;a href=&quot;https://passport.cnblogs.com/GetUsername.aspx&quot; class=&quot;txt-forget-sign&quot;&gt;忘记登录用户名&lt;/a&gt;
        &lt;/div&gt;
        &lt;div class=&quot;form-group&quot;&gt;
            &lt;input tabindex=&quot;2&quot; class=&quot;form-control&quot; placeholder=&quot;密码&quot; type=&quot;password&quot; data-val=&quot;true&quot; data-val-required=&quot;请输入密码&quot; id=&quot;Password&quot; name=&quot;Password&quot;/&gt;&lt;span class=&quot;invalid-feedback field-validation-valid&quot; data-valmsg-for=&quot;Password&quot; data-valmsg-replace=&quot;true&quot;/&gt;
            &lt;a class=&quot;txt-forget-sign&quot; href=&quot;https://account.cnblogs.com/resetpassword&quot;&gt;忘记密码&lt;/a&gt;
        &lt;/div&gt;
        &lt;p&gt;
            &lt;input tabindex=&quot;3&quot; type=&quot;checkbox&quot; id=&quot;IsRemember&quot; name=&quot;IsRemember&quot; value=&quot;true&quot; class=&quot;custom-control-input&quot;/&gt;&lt;label class=&quot;custom-control-label&quot; for=&quot;IsRemember&quot;&gt;记住我&lt;/label&gt;
        &lt;/p&gt;

        &lt;button tabindex=&quot;4&quot; id=&quot;submitBtn&quot; type=&quot;submit&quot; class=&quot;btn-login btn btn-primary btn-sm ladda-button px-4&quot; data-style=&quot;slide-down&quot;&gt;
            &lt;span class=&quot;ladda-label&quot;&gt;登录&lt;/span&gt;
        &lt;/button&gt;
        &lt;div class=&quot;login-footer&quot;&gt;
            &lt;div class=&quot;ajax-error-box&quot;&gt;
                
            &lt;/div&gt;
            &lt;span&gt;没有账户，&lt;a href=&quot;https://account.cnblogs.com/signup&quot;&gt;立即注册&lt;/a&gt;&lt;/span&gt;
        &lt;/div&gt;
    
&lt;input name=&quot;__RequestVerificationToken&quot; type=&quot;hidden&quot; value=&quot;CfDJ8Nf-Z6tqUPlNrwu2nvfTJEi3aY6y1SVGqiDD8wV4x8djYr9G4wCAfNU1FLRvcbFgRgB-qQSSr8w-6bCiM31Zyrw_urbE0XnObcSluDzgj2q7KLtB8LECviq2osEqkDOuUOiUNocZPgRv6skBSXuvQDg&quot;/&gt;&lt;/form&gt;

&lt;input type=&quot;hidden&quot; id=&quot;PublicKey&quot; name=&quot;PublicKey&quot; value=&quot;MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCp0wHYbg/NOPO3nzMD3dndwS0MccuMeXCHgVlGOoYyFwLdS24Im2e7YyhB0wrUsyYf0/nhzCzBK8ZC9eCWqd0aHbdgOQT6CuFQBMjbyGYvlVYU2ZP7kG9Ft6YV6oc9ambuO7nPZh+bvXH0zDKfi02prknrScAKC0XhadTHT3Al0QIDAQAB&quot;/&gt;&lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Thu, 05 Mar 2020 00:46:00 +0000</pubDate>
<dc:creator>雪山飞猪</dc:creator>
<dc:language>zh</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://account.cnblogs.com/signin?ReturnUrl=https://www.cnblogs.com/chenqionghe/p/12417263.html</dc:identifier>
</item>
<item>
<title>数据结构——动手实战双向链表 - TechFlow2019</title>
<link>http://www.cnblogs.com/techflow/p/12418305.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/techflow/p/12418305.html</guid>
<description>&lt;p&gt;本文始发于个人公众号：&lt;strong&gt;TechFlow&lt;/strong&gt;，原创不易，求个关注&lt;/p&gt;

&lt;p&gt;在之前介绍SkipList的文章当中，有一些同学反馈说由于对链表缺少认知以及了解，所以直接啃算法有些过于困难。加上之前的文章当中介绍过了栈，所以这次继续线性表这个话题，我们来一起讨论一下&lt;strong&gt;链表&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;链表是很多数据结构的基础，它的最大特点是支持快速的删除和插入，因此在很多数据频繁变动的场景下使用广泛。而且链表的&lt;strong&gt;可拓展性较强&lt;/strong&gt;，所以它的应用非常广泛，相关的拓展和改进版本也很多。今天我们和大家介绍的是双端链表，也称为双向链表，它是寻常单向链表的改进版本，也是会经常使用的链表。&lt;/p&gt;

&lt;h2 id=&quot;单向链表&quot;&gt;单向链表&lt;/h2&gt;

&lt;p&gt;链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)。以上是维基百科当中的定义，我们可以明白两点，首先链表由多个节点组成的，每个节点存储了下一个节点的位置。其次，链表的各个节点不是顺序存储的。&lt;/p&gt;
&lt;p&gt;我们看一下下图可以加深一下了解：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/3/5/170a820850ef2af7?w=670&amp;amp;h=268&amp;amp;f=png&amp;amp;s=47000&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图当中展示是单向链表，单向的意思是说每个节点只有一个指向后继节点的指针，也就是说链表只有一个遍历方向，因此称为是单向链表。&lt;/p&gt;

&lt;h2 id=&quot;链表的增删&quot;&gt;链表的增删&lt;/h2&gt;

&lt;p&gt;初学者在学习链表时可能会头疼它的使用，相比于数组的直接访问，链表需要通过移动指针来遍历节点修改节点的内容来完成增删，因此不如数组直观。我一直想要找到一个很好的例子来比喻链表运行的机制，直到有一次看谍战片，我发现间谍联络的系统就是以链表形式工作的。所以我决定以间谍系统来举例，介绍一下链表的工作原理。&lt;/p&gt;
&lt;p&gt;假设你是民国时期&lt;strong&gt;军统的头目&lt;/strong&gt;，你负责一个谍报链路。为了安全，你和你的手下们是&lt;strong&gt;单向联系&lt;/strong&gt;的。也就是说只能你联系你的一个手下，由这个手下再去联络其他人，最终把暗号交到目标的手上。假设你的代号是A，你的手下是B，B的手下是C，C来执行任务。这个机制一直运转很好，直到有一天，B因为神秘原因转移了地点，导致A和B联络的时间变长，为了解决这个问题，你决定新增一个人手D专门负责A和B之间的联络，加快联络速度。你应该怎么办呢？&lt;/p&gt;
&lt;p&gt;由于身份限制，以及安全原因，你是不知道B的具体信息的。你只能将消息给到A，让A去联络新人D，并且告诉他B的联络方法。还有一点需要注意，A必须等到D成功找到了B之后再切断和B的联系。否则一旦D出现什么意外，这整条链路就断了。&lt;/p&gt;
&lt;p&gt;我们把整个图画出来如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/3/5/170a82083f8f2263?w=452&amp;amp;h=411&amp;amp;f=png&amp;amp;s=13533&quot;/&gt;&lt;/p&gt;
&lt;p&gt;先让D和B取得联系，之后断开A和B的联系。但是有一个问题，由于A的后继只有一个，A如果指向D，那么B的位置就会丢失。所以我们需要先用一个临时变量cur存储下来B的位置，然后再让D指向这个cur。不过在Python当中，我们可以不用这么麻烦，利用Python的多变量赋值的方法，我们可以一行代码搞定。&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def add(pos, new_node):
    new_node.next, pos.next = pos.next, new_node&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;假如过了一段时间，B又回到了原处，我们不需要D了，要删除这个节点该怎么办？很简单，直接让D将B的最新的联络方式给A就可以了。也就是说让A跨过D指向B即可。&lt;/p&gt;
&lt;p&gt;来看图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/3/5/170a8208485f4e9c?w=452&amp;amp;h=271&amp;amp;f=png&amp;amp;s=10788&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def delete(pos):
    pos.next = pos.next.next&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;双向链表&quot;&gt;双向链表&lt;/h2&gt;

&lt;p&gt;理解了单向链表，双向链表也就很简单了。双向的意思也很明显，每个节点除了记录后继节点的位置之外，还会&lt;strong&gt;记录源头&lt;/strong&gt;节点的位置。有了双向指针之后不仅是获取来源节点方便而已，并且也可以很方便地对整个链表进行倒叙遍历和头部插入。&lt;/p&gt;
&lt;p&gt;还记得我们之前Python专题当中介绍过的&lt;strong&gt;deque&lt;/strong&gt;这个库吗？通过deque我们可以实现一个双向增删元素的队列，结合双向链表的定义，很容易发现deque其实就是保留了一部分api的双向链表。换句话说deque是基于双向链表实现的，就和栈是基于list实现的一样。&lt;/p&gt;
&lt;p&gt;和单向链表相比，由于我们多了一个指针，理解和实现起来会更加容易，因为之前需要通过顺序关系以及临时变量完成的内容现在可以通过前向指针很轻易地实现了。&lt;/p&gt;
&lt;p&gt;下面附上双向链表增删的代码：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def add(pos, new_node):
    pos.next, new_node.next = new_node, pos.next
    new_node.pre, new_node.next.pre = pos, new_node
    
    
def delete(pos):
    pos.next = pos.next.next
    # 这个时候pos.next已经更新
    pos.next.pre = pos&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;双向链表本身并不复杂，也没有太多变化的花样，和之前介绍的SkipList相比要简单许多。我相信即使是初学者，只要自己动手实现一遍，也足够掌握。在我初学数据结构的时候，我非常抗拒使用链表，除了觉得寻址很麻烦，需要遍历整个链表耗时很大之外。另一个根本的原因是在C++当中链表的编写很麻烦，而且很容易有&lt;strong&gt;内存泄漏以及野指针&lt;/strong&gt;问题。所以我当时尽可能地使用数组作为替代，并且甚至一度认为随着内存价格的降低，总有一天我们可以抛弃链表这个结构。&lt;/p&gt;
&lt;p&gt;直到后来我学习了操作系统之后，我找到了一个必须使用链表的理由。因为在操作系统当中，&lt;strong&gt;内存并不是连续的&lt;/strong&gt;，大部分内存都是分散的。当我们创建一个数组的时候，我们其实是在想操作系统申请一块连续的内存。我们申请的数组越大，这块内存也就越大。显然越大的内存越难申请到，因为内存大多被切分成了许多碎片，在资源不够的情况下，操作系统需要做大量的工作才能将碎片搜集起来。&lt;/p&gt;
&lt;p&gt;而链表因为通过指针寻址，所以可以避免这个问题，链表当中的元素分散在内存各处，分摊了内存消耗的压力。这也是在操作系统领域当中，链表大量使用的原因。&lt;/p&gt;
&lt;p&gt;最后，由于篇幅限制，我们没有放上全部的代码，想要获取完整双向链表代码的同学，可以关注我的公众号，回复“&lt;strong&gt;双向链表&lt;/strong&gt;”获取。&lt;/p&gt;
&lt;p&gt;今天的文章就到这里，如果觉得有所收获，请顺手点个&lt;strong&gt;关注或者转发&lt;/strong&gt;吧，你们的举手之劳对我来说很重要。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/3/5/170a82148acda9d9?w=258&amp;amp;h=258&amp;amp;f=png&amp;amp;s=23988&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 05 Mar 2020 00:40:00 +0000</pubDate>
<dc:creator>TechFlow2019</dc:creator>
<og:description>本文始发于个人公众号： TechFlow ，原创不易，求个关注 在之前介绍SkipList的文章当中，有一些同学反馈说由于对链表缺少认知以及了解，所以直接啃算法有些过于困难。加上之前的文章当中介绍过了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/techflow/p/12418305.html</dc:identifier>
</item>
<item>
<title>从0开发3D引擎（十二）：使用领域驱动设计，从最小3D程序中提炼引擎（第三部分） - Wonder-YYC</title>
<link>http://www.cnblogs.com/chaogex/p/12418289.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chaogex/p/12418289.html</guid>
<description>&lt;p&gt;大家好，本文根据领域驱动设计的成果，实现了init API。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/chaogex/p/12411575.html&quot;&gt;从0开发3D引擎（十一）：使用领域驱动设计，从最小3D程序中提炼引擎（第二部分）&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/chaogex/p/12418292.html#%E6%9C%AC%E6%96%87%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%E5%9C%B0%E5%9D%80&quot;&gt;从0开发3D引擎（十三）：使用领域驱动设计，从最小3D程序中提炼引擎（第四部分）&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;实现directorjsapi.init&quot;&gt;实现“DirectorJsAPI.init”&lt;/h2&gt;
&lt;h3 id=&quot;实现保存webgl上下文限界上下文&quot;&gt;实现“保存WebGL上下文”限界上下文&lt;/h3&gt;
&lt;p&gt;1、在src/api_layer/api/中加入DirectorJsAPI.re，实现API&lt;br/&gt;DirectorJsAPI.re代码为：&lt;/p&gt;
&lt;pre class=&quot;re&quot;&gt;
&lt;code&gt;let init = DirectorApService.init;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、在src/infrastructure_layer/external/external_object/中加入Error.re，负责处理“js异常”这个外部对象&lt;br/&gt;Error.re代码为：&lt;/p&gt;
&lt;pre class=&quot;re&quot;&gt;
&lt;code&gt;//根据错误信息(string类型)，创建并抛出“js异常”对象
let error = msg =&amp;gt; Js.Exn.raiseError(msg);

//根据“js异常”对象，抛出它
let throwError: Js.Exn.t =&amp;gt; unit = [%raw err =&amp;gt; {|
throw err;
|}];&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3、在src/application_layer/service/中加入DirectorApService.re，实现应用服务&lt;br/&gt;DirectorApService.re代码为：&lt;/p&gt;
&lt;pre class=&quot;re&quot;&gt;
&lt;code&gt;let init = contextConfigJsObj =&amp;gt; {
  CanvasCanvasEntity.getCanvas()
  |&amp;gt; OptionContainerDoService.get
  //OptionContainerDoService.get函数返回的是Result容器的包装值，需要调用ResultContainerVO.bind函数来处理容器内部的值
  |&amp;gt; ResultContainerVO.bind(canvas =&amp;gt; {
       SetWebGLContextSetWebGLContextDoService.setGl(
         contextConfigJsObj,
         canvas,
       )
     })
     //应用服务DirectorApService负责用抛出异常的方式处理Result错误
     |&amp;gt; ResultContainerVO.handleFail(Error.throwError);
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关于bind函数的使用，可以参考&lt;a href=&quot;https://www.cnblogs.com/chaogex/p/12172930.html#bind&quot;&gt;从0开发3D引擎（五）：函数式编程及其在引擎中的应用-&amp;gt;bind&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4、修改CanvasCanvasEntity.re，实现getCanvas函数&lt;br/&gt;CanvasCanvasEntity.re相关代码为：&lt;/p&gt;
&lt;pre class=&quot;re&quot;&gt;
&lt;code&gt;let getCanvas = () =&amp;gt; {
  Repo.getCanvas();
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;5、把最小3D程序的WebGL1.re放到src/infrastructure_layer/external/library/中，保留所有的代码&lt;br/&gt;WebGL1.re代码为：&lt;/p&gt;
&lt;pre class=&quot;re&quot;&gt;
&lt;code&gt;open Js.Typed_array;

type webgl1Context;

type program;

type shader;

type buffer;

type attributeLocation = int;

type uniformLocation;

type bufferTarget =
  | ArrayBuffer
  | ElementArrayBuffer;

type usage =
  | Static;

type contextConfigJsObj = {
  .
  &quot;alpha&quot;: bool,
  &quot;depth&quot;: bool,
  &quot;stencil&quot;: bool,
  &quot;antialias&quot;: bool,
  &quot;premultipliedAlpha&quot;: bool,
  &quot;preserveDrawingBuffer&quot;: bool,
};

[@bs.send]
external getWebGL1Context:
  ('canvas, [@bs.as &quot;webgl&quot;] _, contextConfigJsObj) =&amp;gt; webgl1Context =
  &quot;getContext&quot;;

[@bs.send.pipe: webgl1Context] external createProgram: program = &quot;&quot;;

[@bs.send.pipe: webgl1Context] external useProgram: program =&amp;gt; unit = &quot;&quot;;

[@bs.send.pipe: webgl1Context] external linkProgram: program =&amp;gt; unit = &quot;&quot;;

[@bs.send.pipe: webgl1Context]
external shaderSource: (shader, string) =&amp;gt; unit = &quot;&quot;;

[@bs.send.pipe: webgl1Context] external compileShader: shader =&amp;gt; unit = &quot;&quot;;

[@bs.send.pipe: webgl1Context] external createShader: int =&amp;gt; shader = &quot;&quot;;

[@bs.get] external getVertexShader: webgl1Context =&amp;gt; int = &quot;VERTEX_SHADER&quot;;

[@bs.get] external getFragmentShader: webgl1Context =&amp;gt; int = &quot;FRAGMENT_SHADER&quot;;

[@bs.get] external getHighFloat: webgl1Context =&amp;gt; int = &quot;HIGH_FLOAT&quot;;

[@bs.get] external getMediumFloat: webgl1Context =&amp;gt; int = &quot;MEDIUM_FLOAT&quot;;

[@bs.send.pipe: webgl1Context]
external getShaderParameter: (shader, int) =&amp;gt; bool = &quot;&quot;;

[@bs.get] external getCompileStatus: webgl1Context =&amp;gt; int = &quot;COMPILE_STATUS&quot;;

[@bs.get] external getLinkStatus: webgl1Context =&amp;gt; int = &quot;LINK_STATUS&quot;;

[@bs.send.pipe: webgl1Context]
external getProgramParameter: (program, int) =&amp;gt; bool = &quot;&quot;;

[@bs.send.pipe: webgl1Context]
external getShaderInfoLog: shader =&amp;gt; string = &quot;&quot;;

[@bs.send.pipe: webgl1Context]
external getProgramInfoLog: program =&amp;gt; string = &quot;&quot;;

[@bs.send.pipe: webgl1Context]
external attachShader: (program, shader) =&amp;gt; unit = &quot;&quot;;

[@bs.send.pipe: webgl1Context]
external bindAttribLocation: (program, int, string) =&amp;gt; unit = &quot;&quot;;

[@bs.send.pipe: webgl1Context] external deleteShader: shader =&amp;gt; unit = &quot;&quot;;

[@bs.send.pipe: webgl1Context] external createBuffer: buffer = &quot;&quot;;

[@bs.get]
external getArrayBuffer: webgl1Context =&amp;gt; bufferTarget = &quot;ARRAY_BUFFER&quot;;

[@bs.get]
external getElementArrayBuffer: webgl1Context =&amp;gt; bufferTarget =
  &quot;ELEMENT_ARRAY_BUFFER&quot;;

[@bs.send.pipe: webgl1Context]
external bindBuffer: (bufferTarget, buffer) =&amp;gt; unit = &quot;&quot;;

[@bs.send.pipe: webgl1Context]
external bufferFloat32Data: (bufferTarget, Float32Array.t, usage) =&amp;gt; unit =
  &quot;bufferData&quot;;

[@bs.send.pipe: webgl1Context]
external bufferUint16Data: (bufferTarget, Uint16Array.t, usage) =&amp;gt; unit =
  &quot;bufferData&quot;;

[@bs.get] external getStaticDraw: webgl1Context =&amp;gt; usage = &quot;STATIC_DRAW&quot;;

[@bs.send.pipe: webgl1Context]
external getAttribLocation: (program, string) =&amp;gt; attributeLocation = &quot;&quot;;

[@bs.send.pipe: webgl1Context]
external getUniformLocation: (program, string) =&amp;gt; Js.Null.t(uniformLocation) =
  &quot;&quot;;

[@bs.send.pipe: webgl1Context]
external vertexAttribPointer:
  (attributeLocation, int, int, bool, int, int) =&amp;gt; unit =
  &quot;&quot;;

[@bs.send.pipe: webgl1Context]
external enableVertexAttribArray: attributeLocation =&amp;gt; unit = &quot;&quot;;

&quot;&quot;;

[@bs.send.pipe: webgl1Context]
external uniformMatrix4fv: (uniformLocation, bool, Float32Array.t) =&amp;gt; unit =
  &quot;&quot;;

[@bs.send.pipe: webgl1Context]
external uniform1i: (uniformLocation, int) =&amp;gt; unit = &quot;&quot;;

[@bs.send.pipe: webgl1Context]
external uniform3f: (uniformLocation, float, float, float) =&amp;gt; unit = &quot;&quot;;

[@bs.send.pipe: webgl1Context]
external drawElements: (int, int, int, int) =&amp;gt; unit = &quot;&quot;;

[@bs.get] external getFloat: webgl1Context =&amp;gt; int = &quot;FLOAT&quot;;

[@bs.send.pipe: webgl1Context]
external clearColor: (float, float, float, float) =&amp;gt; unit = &quot;&quot;;

[@bs.send.pipe: webgl1Context] external clear: int =&amp;gt; unit = &quot;&quot;;

[@bs.get]
external getColorBufferBit: webgl1Context =&amp;gt; int = &quot;COLOR_BUFFER_BIT&quot;;

[@bs.get]
external getDepthBufferBit: webgl1Context =&amp;gt; int = &quot;DEPTH_BUFFER_BIT&quot;;

[@bs.get] external getDepthTest: webgl1Context =&amp;gt; int = &quot;DEPTH_TEST&quot;;

[@bs.send.pipe: webgl1Context] external enable: int =&amp;gt; unit = &quot;&quot;;

[@bs.get] external getTriangles: webgl1Context =&amp;gt; int = &quot;TRIANGLES&quot;;

[@bs.get] external getUnsignedShort: webgl1Context =&amp;gt; int = &quot;UNSIGNED_SHORT&quot;;

[@bs.get] external getCullFace: webgl1Context =&amp;gt; int = &quot;CULL_FACE&quot;;

[@bs.send.pipe: webgl1Context] external cullFace: int =&amp;gt; unit = &quot;&quot;;

[@bs.get] external getBack: webgl1Context =&amp;gt; int = &quot;BACK&quot;;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;6、在src/domain_layer/domain/init/set_webgl_context/service/中加入SetWebGLContextSetWebGLContextDoService.re，创建领域服务SetWebGLContext&lt;br/&gt;SetWebGLContextSetWebGLContextDoService.re代码为：&lt;/p&gt;
&lt;pre class=&quot;re&quot;&gt;
&lt;code&gt;let setGl = (contextConfigJsObj, canvas): ResultContainerVO.t(unit, Js.Exn.t) =&amp;gt; {
  ContextContextEntity.setGl(contextConfigJsObj, canvas)
  |&amp;gt; ResultContainerVO.succeed;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;7、修改ContextContextEntity.re，实现setGl函数&lt;br/&gt;ContextContextEntity.re相关代码为：&lt;/p&gt;
&lt;pre class=&quot;re&quot;&gt;
&lt;code&gt;let setGl = (contextConfigJsObj, canvas) =&amp;gt; {
  ContextRepo.setGl(WebGL1.getWebGL1Context(canvas, contextConfigJsObj));
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;8、修改ContextPOType.re，定义Context PO的gl字段的数据类型&lt;br/&gt;ContextPOType.re相关代码为：&lt;/p&gt;
&lt;pre class=&quot;re&quot;&gt;
&lt;code&gt;type context = {
  gl: option(WebGL1.webgl1Context),
  ...
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;9、修改ContextRepo.re，实现仓库对Context PO的gl字段的操作&lt;br/&gt;ContextRepo.re代码为：&lt;/p&gt;
&lt;pre class=&quot;re&quot;&gt;
&lt;code&gt;let getGl = gl =&amp;gt; {
  //将Option转换为Result
  Repo.getContext().gl |&amp;gt; OptionContainerDoService.get;
};

let setGl = gl =&amp;gt; {
  Repo.setContext({...Repo.getContext(), gl: Some(gl)});
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;10、修改CreateRepo.re，实现创建Context PO的gl字段&lt;br/&gt;CreateRepo.re相关代码为：&lt;/p&gt;
&lt;pre class=&quot;re&quot;&gt;
&lt;code&gt;let create = () =&amp;gt; {
  ...
  context: {
    gl: None,
    ...
  },
};&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;实现初始化所有shader限界上下文&quot;&gt;实现“初始化所有Shader”限界上下文&lt;/h3&gt;
&lt;p&gt;1、重写DirectorApService.re&lt;br/&gt;DirectorApService.re代码为：&lt;/p&gt;
&lt;pre class=&quot;re&quot;&gt;
&lt;code&gt;let init = contextConfigJsObj =&amp;gt; {
  CanvasCanvasEntity.getCanvas()
  |&amp;gt; ResultContainerVO.bind(canvas =&amp;gt; {
       SetWebGLContextSetWebGLContextDoService.setGl(
         contextConfigJsObj,
         canvas,
       )
       |&amp;gt; ResultContainerVO.bind(() =&amp;gt; {InitShaderInitShaderDoService.init()})
     })
  |&amp;gt; ResultContainerVO.handleFail(Error.throwError);
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、加入值对象InitShader&lt;/p&gt;
&lt;p&gt;在&lt;a href=&quot;https://www.cnblogs.com/chaogex/p/12408831.html&quot;&gt;从0开发3D引擎（十）：使用领域驱动设计，从最小3D程序中提炼引擎（第一部分）&lt;/a&gt;的“设计值对象InitShader”中，我们已经定义了值对象InitShader的类型，所以我们直接将设计转换为实现：&lt;br/&gt;在src/domain_layer/domain/init/init_shader/value_object/中加入InitShaderInitShaderVO.re，创建值对象InitShader&lt;br/&gt;InitShaderInitShaderVO.re代码为：&lt;/p&gt;
&lt;pre class=&quot;re&quot;&gt;
&lt;code&gt;type singleInitShader = {
  shaderId: string,
  vs: string,
  fs: string,
};

type t = list(singleInitShader);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3、在src/domain_layer/domain/shader/shader/value_object/中加入ProgramShaderVO.re，创建值对象Program，它的DO对应一个WebGL的program对象&lt;br/&gt;ProgramShaderVO.re代码为：&lt;/p&gt;
&lt;pre class=&quot;re&quot;&gt;
&lt;code&gt;type t =
  | Program(WebGL1.program);

let create = program =&amp;gt; Program(program);

let value = program =&amp;gt;
  switch (program) {
  | Program(value) =&amp;gt; value
  };&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4、修改聚合根ShaderManager的DO&lt;/p&gt;
&lt;p&gt;根据识别的引擎逻辑：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在初始化所有Shader时，创建每个Program&lt;/li&gt;
&lt;li&gt;在渲染每个三角形时，根据Shader名称获得关联的Program&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们需要根据Shader id获得关联的Program，所以在ShaderManager DO中应该加入一个immutable hash map，它的key为Shader id，value为值对象Program的DO。&lt;/p&gt;
&lt;p&gt;应该在领域视图的“容器”限界上下文中，加入值对象ImmutableHashMap、值对象MutableHashMap，其中ImmutableHashMap用于实现不可变的hash map，MutableHashMap用于实现可变的hash map。&lt;/p&gt;
&lt;p&gt;现在来具体实现它们：&lt;br/&gt;1)在src/domain_layer/domain/structure/container/value_object/中创建文件夹hash_map/&lt;br/&gt;2)在hash_map/文件夹中加入ImmutableHashMapContainerVO.re、MutableHashMapContainerVO.re、HashMapContainer.re、HashMapContainerType.re&lt;br/&gt;ImmutableHashMapContainerVO.re负责实现Immutable Hash Map；&lt;br/&gt;MutableHashMapContainerVO.re负责实现Mutable Hash Map；&lt;br/&gt;HashMapContainer.re从两者中提出的公共代码；&lt;br/&gt;HashMapContainerType.re定义HashMap的类型。&lt;/p&gt;
&lt;p&gt;因为HashMapContainer需要使用reduce来遍历数组，这个操作属于通用操作，应该作为领域服务，所以在领域视图的“容器”限界上下文中，加入领域服务Array。在src/domain_layer/domain/structure/container/service/中加入ArrayContainerDoService.re，创建领域服务Array。&lt;/p&gt;
&lt;p&gt;相关代码如下：&lt;br/&gt;ArrayContainterDoService.re&lt;/p&gt;
&lt;pre class=&quot;re&quot;&gt;
&lt;code&gt;let reduceOneParam = (func, param, arr) =&amp;gt; {
  //此处为了优化，使用for循环和mutable变量来代替Array.reduce
  let mutableParam = ref(param);
  for (i in 0 to Js.Array.length(arr) - 1) {
    mutableParam := func(. mutableParam^, Array.unsafe_get(arr, i));
  };
  mutableParam^;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;HashMapContainerType.re&lt;/p&gt;
&lt;pre class=&quot;re&quot;&gt;
&lt;code&gt;type t('key, 'value) = Js.Dict.t('value);
type t2('value) = t(string, 'value);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;HashMapContainer.re&lt;/p&gt;
&lt;pre class=&quot;re&quot;&gt;
&lt;code&gt;let createEmpty = (): HashMapContainerType.t2('a) =&amp;gt; Js.Dict.empty();

let get = (key: string, map: HashMapContainerType.t2('a)) =&amp;gt;
  Js.Dict.get(map, key);

let entries = (map: HashMapContainerType.t2('a)): array((Js.Dict.key, 'a)) =&amp;gt;
  map |&amp;gt; Js.Dict.entries;

let _mutableSet = (key: string, value, map) =&amp;gt; {
  Js.Dict.set(map, key, value);
  map;
};

let _createEmpty = (): Js.Dict.t('a) =&amp;gt; Js.Dict.empty();

let copy = (map: HashMapContainerType.t2('a)): HashMapContainerType.t2('a) =&amp;gt;
  map
  |&amp;gt; entries
  |&amp;gt; ArrayContainerDoService.reduceOneParam(
       (. newMap, (key, value)) =&amp;gt; newMap |&amp;gt; _mutableSet(key, value),
       _createEmpty(),
     );&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ImmutableHashMapContainerVO.re&lt;/p&gt;
&lt;pre class=&quot;re&quot;&gt;
&lt;code&gt;type t('key, 'value) = HashMapContainerType.t('key, 'value);

let createEmpty = HashMapContainer.createEmpty;

let set =
    (key: string, value: 'a, map: HashMapContainerType.t2('a))
    : HashMapContainerType.t2('a) =&amp;gt; {
  let newMap = map |&amp;gt; HashMapContainer.copy;

  Js.Dict.set(newMap, key, value);

  newMap;
};

let get = HashMapContainer.get;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;MutableHashMap.re&lt;/p&gt;
&lt;pre class=&quot;re&quot;&gt;
&lt;code&gt;type t('key, 'value) = HashMapContainerType.t('key, 'value);

let createEmpty = HashMapContainer.createEmpty;

let set = (key: string, value: 'a, map: HashMapContainerType.t2('a)) =&amp;gt; {
  Js.Dict.set(map, key, value);

  map;
};

let get = HashMapContainer.get;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在我们可以通过修改ShaderManagerShaderEntity.re来修改ShaderManager的DO，加入programMap字段&lt;br/&gt;ShaderManagerShaderEntity.re相关代码为：&lt;/p&gt;
&lt;pre class=&quot;re&quot;&gt;
&lt;code&gt;type t = {
  ...
  programMap:
    ImmutableHashMapContainerVO.t2(ShaderShaderEntity.t, ProgramShaderVO.t),
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;5、创建领域服务BuildInitShaderData，实现构造值对象InitShader&lt;br/&gt;1)在src/domain_layer/domain/init/init_shader/service/中加入BuildInitShaderDataInitShaderDoService.re，创建领域服务BuildInitShaderData&lt;br/&gt;BuildInitShaderDataInitShaderDoService.re代码为：&lt;/p&gt;
&lt;pre class=&quot;re&quot;&gt;
&lt;code&gt;let build = () =&amp;gt; {
  ShaderManagerShaderEntity.getAllGLSL()
  |&amp;gt; List.map(((shaderName, glsl)) =&amp;gt; {
       (
         {
           shaderId: ShaderShaderEntity.getId(shaderName),
           vs: GLSLShaderVO.getVS(glsl),
           fs: GLSLShaderVO.getFS(glsl),
         }: InitShaderInitShaderVO.singleInitShader
       )
     });
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2)修改GLSLShaderVO.re，实现getVS、getFS函数&lt;br/&gt;GLSLShaderVO.re相关代码为：&lt;/p&gt;
&lt;pre class=&quot;re&quot;&gt;
&lt;code&gt;let getVS = glsl =&amp;gt;
  switch (glsl) {
  | GLSL(vs, fs) =&amp;gt; vs
  };

let getFS = glsl =&amp;gt;
  switch (glsl) {
  | GLSL(vs, fs) =&amp;gt; fs
  };&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3)修改ShaderManagerShaderEntity.re，加入getAllGLSL函数&lt;br/&gt;ShaderManagerShaderEntity.re相关代码为：&lt;/p&gt;
&lt;pre class=&quot;re&quot;&gt;
&lt;code&gt;let getAllGLSL = () =&amp;gt; {
  ShaderManagerRepo.getAllGLSL();
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4)修改ShaderManagerRepo.re，加入getAllGLSL函数&lt;br/&gt;ShaderManagerShaderEntity.re相关代码为：&lt;/p&gt;
&lt;pre class=&quot;re&quot;&gt;
&lt;code&gt;let getAllGLSL = () =&amp;gt; {
  Repo.getShaderManager().glsls
  |&amp;gt; List.map(((shaderId, (vs, fs))) =&amp;gt; {
       (ShaderShaderEntity.create(shaderId), GLSLShaderVO.create((vs, fs)))
     });
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;6、在src/domain_layer/domain/init/init_shader/service/中加入InitShaderInitShaderDoService.re，创建领域服务InitShader&lt;br/&gt;InitShaderInitShaderDoService.re代码为：&lt;/p&gt;
&lt;pre class=&quot;re&quot;&gt;
&lt;code&gt;let init = (): ResultContainerVO.t(unit, Js.Exn.t) =&amp;gt; {
  ContextContextEntity.getGl()
  |&amp;gt; ResultContainerVO.bind(gl =&amp;gt; {
       //从着色器DO数据中构建值对象InitShader
       BuildInitShaderDataInitShaderDoService.build()
       |&amp;gt; ResultContainerVO.tryCatch(initShaderData =&amp;gt; {
            initShaderData
            |&amp;gt; List.iter(
                 (
                   {shaderId, vs, fs}: InitShaderInitShaderVO.singleInitShader,
                 ) =&amp;gt; {
                 let program = ContextContextEntity.createProgram(gl);

                 /* 注意：领域服务不应该直接依赖Repo

                    应该通过实体ContextContextEntity而不是ShaderManagerRepo来将program设置到ShaderManager PO的programMap中！
                    */
                 ContextContextEntity.setProgram(shaderId, program);

                 ContextContextEntity.initShader(vs, fs, program, gl)
                 |&amp;gt; ignore;

                 //用于运行测试
                 Js.log((shaderId, vs, fs));
               })
          })
     });
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;7、修改ContextContextEntity.re，实现相关函数&lt;br/&gt;ContextContextEntity.re相关代码为：&lt;/p&gt;
&lt;pre class=&quot;re&quot;&gt;
&lt;code&gt;let getGl = () =&amp;gt; {
  ContextRepo.getGl();
};

...

let createProgram = gl =&amp;gt; gl |&amp;gt; WebGL1.createProgram;

let setProgram = (shaderId, program) =&amp;gt; {
  ShaderManagerRepo.setProgram(shaderId, program);
};

let _compileShader = (gl, glslSource, shader) =&amp;gt; {
  WebGL1.shaderSource(shader, glslSource, gl);
  WebGL1.compileShader(shader, gl);

  WebGL1.getShaderParameter(shader, WebGL1.getCompileStatus(gl), gl)
  === false
    ? {
      let message = WebGL1.getShaderInfoLog(shader, gl);

      //这里为了实现“从0开发3D引擎（十）：使用领域驱动设计，从最小3D程序中提炼引擎（第一部分）”提出的“处理错误优化”，用“抛出异常”而不是Result来处理错误
      Error.error(
        {j|shader info log: $message
        glsl source: $glslSource
        |j},
      );
    }
    : shader;
};

let _linkProgram = (program, gl) =&amp;gt; {
  WebGL1.linkProgram(program, gl);

  WebGL1.getProgramParameter(program, WebGL1.getLinkStatus(gl), gl) === false
    ? {
      let message = WebGL1.getProgramInfoLog(program, gl);

      //这里为了实现“从0开发3D引擎（十）：使用领域驱动设计，从最小3D程序中提炼引擎（第一部分）”提出的“处理错误优化”，用“抛出异常”而不是Result来处理错误
      Error.error({j|link program error: $message|j});
    }
    : program;
};

let initShader = (vsSource: string, fsSource: string, program, gl) =&amp;gt; {
  let vs =
    _compileShader(
      gl,
      vsSource,
      WebGL1.createShader(WebGL1.getVertexShader(gl), gl),
    );
  let fs =
    _compileShader(
      gl,
      fsSource,
      WebGL1.createShader(WebGL1.getFragmentShader(gl), gl),
    );

  WebGL1.attachShader(program, vs, gl);
  WebGL1.attachShader(program, fs, gl);

  WebGL1.bindAttribLocation(program, 0, &quot;a_position&quot;, gl);

  _linkProgram(program, gl);

  WebGL1.deleteShader(vs, gl);
  WebGL1.deleteShader(fs, gl);

  program;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;8、修改ShaderManagerPOType.re，ShaderManager PO加入programMap字段&lt;/p&gt;
&lt;p&gt;虽然programMap也是hash map，但不能直接使用领域层的值对象ImmutableHashMapContainerVO来定义它的类型！因为PO属于基础设施层，它不能依赖领域层！&lt;br/&gt;因此，我们应该在基础设施层的“数据”中创建一个ImmutableHashMap.re模块，尽管它的类型和函数都与ImmutableHashMapContainerVO一样。&lt;/p&gt;
&lt;p&gt;在src/infrastructure_layer/data/中创建文件夹structure/，在该文件夹中加入ImmutableHashMap.re。&lt;br/&gt;为了方便，目前暂时直接用ImmutableHashMapContainerVO来实现ImmutableHashMap。&lt;br/&gt;ImmutableHashMap.re代码为：&lt;/p&gt;
&lt;pre class=&quot;re&quot;&gt;
&lt;code&gt;type t2('key, 'a) = ImmutableHashMapContainerVO.t2('key, 'a);

let createEmpty = ImmutableHashMapContainerVO.createEmpty;

let set = ImmutableHashMapContainerVO.set;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改ShaderManagerPOType.re，ShaderManager PO加入programMap字段：&lt;/p&gt;
&lt;pre class=&quot;re&quot;&gt;
&lt;code&gt;type shaderManager = {
  ...
  programMap: ImmutableHashMap.t2(shaderId, WebGL1.program),
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;9、修改ShaderManagerRepo.re，实现setProgram函数&lt;br/&gt;ShaderManagerRepo.re相关代码为：&lt;/p&gt;
&lt;pre class=&quot;re&quot;&gt;
&lt;code&gt;let _getProgramMap = ({programMap}) =&amp;gt; programMap;

let setProgram = (shaderId, program) =&amp;gt; {
  Repo.setShaderManager({
    ...Repo.getShaderManager(),
    programMap:
      _getProgramMap(Repo.getShaderManager())
      //这里也使用基础设施层的“数据”的ImmutableHashMap，因为操作的是ShaderManager PO的programMap
      |&amp;gt; ImmutableHashMap.set(shaderId, program),
  });
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;10、修改CreateRepo.re，实现创建ShaderManager PO的programMap字段&lt;br/&gt;CreateRepo.re相关代码为：&lt;/p&gt;
&lt;pre class=&quot;re&quot;&gt;
&lt;code&gt;let create = () =&amp;gt; {
  ...
  shaderManager: {
    ...
    programMap: ImmutableHashMap.createEmpty(),
  },
};&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;实现用户代码并运行测试&quot;&gt;实现用户代码并运行测试&lt;/h3&gt;
&lt;p&gt;1、在项目根目录上执行webpack命令，更新wd.js文件&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;yarn webpack&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、实现index.html相关代码&lt;/p&gt;
&lt;p&gt;index.html代码为：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;  &amp;lt;script&amp;gt;
    ...
    //准备webgl上下文的配置项
    var contextConfig = {
      &quot;alpha&quot;: true,
      &quot;depth&quot;: true,
      &quot;stencil&quot;: false,
      &quot;antialias&quot;: true,
      &quot;premultipliedAlpha&quot;: true,
      &quot;preserveDrawingBuffer&quot;: false,
    };

    wd.Director.init(contextConfig);
  &amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3、运行测试&lt;/p&gt;
&lt;p&gt;运行index.html页面&lt;/p&gt;
&lt;p&gt;打开控制台，可以看到打印了两次数组，每次数组内容为[Shader名称, vs, fs]，其中第一次的Shader名称为“shader2”，第二次为“shader1”&lt;/p&gt;
</description>
<pubDate>Thu, 05 Mar 2020 00:33:00 +0000</pubDate>
<dc:creator>Wonder-YYC</dc:creator>
<og:description>[TOC] 大家好，本文根据领域驱动设计的成果，实现了init API。 上一篇博文 &amp;quot;从0开发3D引擎（十一）：使用领域驱动设计，从最小3D程序中提炼引擎（第二部分）&amp;quot; 下一篇博</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chaogex/p/12418289.html</dc:identifier>
</item>
<item>
<title>《痞子衡嵌入式半月刊》 第 3 期 - 痞子衡</title>
<link>http://www.cnblogs.com/henjay724/p/12418233.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/henjay724/p/12418233.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/cnblogs/pzh_mcu_bi_weekly.PNG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里分享嵌入式领域有用有趣的项目/工具以及一些热点新闻，农历年分二十四节气，希望在每个交节之日准时发布一期。&lt;/p&gt;
&lt;p&gt;本期刊是开源项目（GitHub: &lt;a href=&quot;https://github.com/JayHeng/pzh-mcu-bi-weekly&quot;&gt;JayHeng/pzh-mcu-bi-weekly&lt;/a&gt;），欢迎提交 issue，投稿或推荐你知道的嵌入式那些事儿。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;上期回顾&lt;/strong&gt; ：&lt;a href=&quot;https://www.cnblogs.com/henjay724/p/12326587.html&quot;&gt;《痞子衡嵌入式半月刊： 第 2 期》&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;唠两句&quot;&gt;唠两句&lt;/h2&gt;
&lt;p&gt;今天是雨水与惊蛰交节之时，惊蛰节气在农耕上有着相当重要的意义，自古以来我国人民很重视惊蛰这个节气，把它视为春耕开始的节令。&lt;/p&gt;
&lt;p&gt;新冠肺炎疫情在逐日好转，相信大部分人都已经开始陆续复工了，但痞子衡东家还是决定 3 月 23 号之后再考虑全面复工的事。因此这些天痞子衡在家主要是以看技术文档写技术文档以及线上客户支持为主，最近原创文章产出比较惊人，一周能达到 3 篇，写文章这种事，写作过程中比较痛苦，但写完还是成就感满满的。&lt;/p&gt;
&lt;p&gt;最近痞子衡不断接到技术群的朋友约稿，趁着在家办公的时机，痞子衡会加快写作，尽早完成大家的约稿。&lt;/p&gt;
&lt;p&gt;本期共收录 3条资讯、4个项目、2个工具、1个RT产品，希望对你有帮助！&lt;/p&gt;
&lt;h2 id=&quot;资讯类&quot;&gt;资讯类&lt;/h2&gt;
&lt;h3 id=&quot;面向音频语音应用的恩智浦-i.mxrt600-已上市&quot;&gt;&lt;span&gt;1、面向音频/语音应用的恩智浦 i.MXRT600 已上市&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;恩智浦半导体于 Embedded World 2020 上宣布其旗下主打音频/语音应用的全新跨界处理器 i.MXRT600 已开始正式供货，10K 量起价 $4.50，恩智浦官网上也逐渐放出了 i.MXRT600 相关开发资料。&lt;/p&gt;
&lt;p&gt;i.MXRT600 特性如下：&lt;/p&gt;
&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt;- 主频高达 300MHz 的Arm® Cortex®-M33内核
- 可选的Cadence® Tensilica® HiFi 4 音频、语音数字信号处理器（DSP）。运行主频高达 600MHz，并支持四组 32x32 MAC。
- 多达4.5MB 片上 SRAM，支持关键指令和数据的“零等待”访问。
- 28nm FD-SIO （耗尽型绝缘硅）工艺，提供更低的工作电流和漏电流。
- 内置恩智浦卓越的嵌入式安全技术 - EdgeLock™ 400A。
- 可使用 Glow 神经网络编译器，优化机器学习性能。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;恩智浦除了提供常规软硬件开发工具支持外，还包括适用于 i.MXRT600 的 Cadence Xplorer IDE、DSP函数库和音频编解码器的支持。恩智浦还与 Alango Technologies、DSP Concepts 和 Sensory 合作，提供高性能语音预处理和识别软件以及专业的音频库和工具。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/biweekly/i.MXRT600_BlockDiagram.PNG&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;全球首颗通用-risc-v-mcu-兆易创新-gd32vf103-获-ew2020-唯一最佳硬件产品大奖&quot;&gt;&lt;span&gt;2、全球首颗通用 RISC-V MCU 兆易创新 GD32VF103 获 EW2020 唯一最佳硬件产品大奖&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;GD32VF103 是兆易创新（Gigadevice）于 2019 年 8 月 22 日发布的全球首款通用 RISC-V MCU，这款芯片日前获得了 Embedded World 2020 年度唯一的最佳硬件产品大奖。&lt;/p&gt;
&lt;p&gt;GD32VF103 特性如下所示，其 Bumblebee 内核是由芯来科技（Nuclei System Technology）联合兆易创新针对其面向 IoT 或其他超低功耗场景的通用 MCU 产品定制的一款商用 RISC-V 处理器内核。&lt;/p&gt;
&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt;- 提供108 MHz的运算主频，以及16~128 KB的片上闪存和6~32 KB的SRAM。
- 支持32比特宽的标准AHB-Lite系统总线接口，支持32比特宽的指令局部存储器。
- 支持32位的RISC-V指令集架构，支持RV32IMAC指令子集的组合。
- 主流支持标准JTAG接口 和RISC-V调试标准。
- 使用基于RISC-V的Bumblebee内核，该内核内置了单周期硬件乘法器、硬件除器。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;兆易创新官方提供了两款 GD32VF103 开发板，一款是入门级 GD32VF103C-START，另一款是专业级 GD32VF103V-EVAL，下图便是专业级开发板：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/biweekly/GD32VF103V-EVAL.PNG&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;micrium-ucos-及其大部分组件推出免费商业授权apache-license-2.0&quot;&gt;&lt;span&gt;3、Micrium uC/OS 及其大部分组件推出免费商业授权(Apache License 2.0)&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;Micrium 宣布于 2020 年 2 月底将 µC/OS-II, µC/OS-III, µC/FS, µC/TCP-IP, µC/USB-Device, µC/USB-Host, µC/CAN, µC/Modbus 转入 Apache License 2.0，客户可以免费商业使用。相关源码可在 SiliconLabs 官方 github 上获取：&lt;/p&gt;
&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt;https://github.com/SiliconLabs/uC-OS2
https://github.com/SiliconLabs/uC-OS3
https://github.com/SiliconLabs/uC-FS
https://github.com/SiliconLabs/uC-TCP-IP
https://github.com/SiliconLabs/uC-USBD
https://github.com/SiliconLabs/uC-USBH&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;源于 1992 年的 uC/OS 应该是中国大部分嵌入式工程师的 RTOS 启蒙老师，除了其简单易用以及开源特性之外，邵贝贝老师翻译的 《嵌入式实时操作系统uC/OS-II》 对其推广也起了很大作用。&lt;/p&gt;
&lt;p&gt;但是开源并不等于免费，早期的 uC/OS 仅可用于个人学习，如用作商业目的，Micrium 其实是要按产品出货量收费的。不过自从 2016 年 SiliconLabs 完成对 Micrium 的收购之后，uC/OS 逐渐放开商业授权，现在基本除了uC/GUI 之外，其它都可以免费商业使用了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/biweekly/uCOS_Components.PNG&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;项目类&quot;&gt;项目类&lt;/h2&gt;
&lt;h3 id=&quot;ametal---具有跨-mcu-平台通用接口的裸机软件驱动包&quot;&gt;&lt;span&gt;1、AMetal - 具有跨 MCU 平台通用接口的裸机软件驱动包&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;AMetal 是周立功（ZLG）公司维护的芯片级裸机软件包，定义了跨平台的通用接口（使得基于 AMetal 的应用程序可以和具体硬件完全分离，实现跨平台复用），并提供了一系列驱动及常用的软件服务。AMetal 是周立功 AWorksOS 架构底层里的重要一环。&lt;/p&gt;
&lt;blockquote readability=&quot;1.5625&quot;&gt;
&lt;p&gt;项目主页：&lt;a href=&quot;https://github.com/zlgopen/ametal&quot; class=&quot;uri&quot;&gt;https://github.com/zlgopen/ametal&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/biweekly/AWorks_Components.PNG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;AMetal 主要特点如下，其目前已经支持周立功、华大半导体、灵动微电子、恩智浦半导体等公司的 MCU 产品，并且其还支持了非常多的嵌入式里常用的驱动组件（见下表，未完全列出）&lt;/p&gt;
&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt;- 将外设操作标准化，避免上层软件、驱动的再次开发；
- 能独立运行的软件包，全部开源，提供工程模板与DEMO程序，可在此基础上开发应用程序；
- 不依赖操作系统服务；
- 尽可能将外设的所有特性开放出来；
- 尽可能浅地对外设进行封装，把效率放在第一位；
- 用户不用看芯片手册也能使用。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/biweekly/AMetal_Device_list.PNG&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;tjpgdec---为小型嵌入式系统高度优化的-jpeg-解码库&quot;&gt;&lt;span&gt;2、TJpgDec - 为小型嵌入式系统高度优化的 JPEG 解码库&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;TJpgDec 全称 Tiny JPEG Decompressor，是日本的大牛工程师 ChaN 开发的开源 JPEG 图像解码库（C代码），你可能对 ChaN 这个名字陌生，但我相信你对 ChaN 的另一个作品 FatFs 一定不陌生。&lt;/p&gt;
&lt;blockquote readability=&quot;1.3157894736842&quot;&gt;
&lt;p&gt;项目主页：&lt;a href=&quot;http://elm-chan.org/fsw/tjpgd/00index.html&quot; class=&quot;uri&quot;&gt;http://elm-chan.org/fsw/tjpgd/00index.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;嵌入式项目里（尤其是视频相关）有时候经常需要跟 JPEG 格式打交道，关于 JPEG 解码最知名的莫过于 IJG 组织开发的 libjpeg 解码库，但是 libjpeg 主要针对 Linux 等大型 OS 平台开发的，而在嵌入式 MCU 平台下，TJpgDec 会更合适一点。&lt;/p&gt;
&lt;p&gt;TJpgDec 特性如下，其极低的存储空间占用使其可以完美运行于小型 MCU，比如AVR, 8051, PIC, Z80, Cortex-M0 等。&lt;/p&gt;
&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt;- Platform independent. Written in ANSI-C.
- Easy to use master mode operation.
- Fully re-entrant architecture.
- Very small memory footprint:
  - 3K bytes of RAM for work area independent of image dimensions.
  - 3.5-8.5K bytes of ROM for text and constants.
- Output format:
  - Scaling ratio: 1/1, 1/2, 1/4 or 1/8 selectable on decompression.
  - Pixel format: RGB888 or RGB565 pre-configurable.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/biweekly/TJpgDec.PNG&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;microboy---基于微芯-attiny24-的简易电子游戏机&quot;&gt;&lt;span&gt;3、Micro:Boy - 基于微芯 ATtiny24 的简易电子游戏机&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;这是来自 Hackaday 上的一个作品，基于 ATtiny24 和 MicroPython 的电子游戏机。&lt;/p&gt;
&lt;blockquote readability=&quot;1.3157894736842&quot;&gt;
&lt;p&gt;项目主页：&lt;a href=&quot;https://hackaday.io/project/27757-microboy&quot; class=&quot;uri&quot;&gt;https://hackaday.io/project/27757-microboy&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/biweekly/ATtiny24_micro-boy_system.jpg&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;0.87209302325581&quot;&gt;
&lt;p&gt;游戏代码：&lt;a href=&quot;https://hackaday.io/project/27757-microboy/log/78338-progress-on-a-game&quot; class=&quot;uri&quot;&gt;https://hackaday.io/project/27757-microboy/log/78338-progress-on-a-game&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/biweekly/ATtiny24_micro-boy_game.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;作者一开始想在 Micro:bit 平台上实现，但两个按键和 5x5 LED 最多只能做个贪吃蛇游戏。后来作者想到在 PewPew FeatherWing 平台上做，六个按键及 8x8 LED 能展示的余地大一些。不过最终作者还是选择了一个 ATtiny24 开发板以及 1.3&quot; OLED SH1106 I²C 模块。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/biweekly/Micro-Bit_PewPew-FeatherWing.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;metro-m7---一款带-airlift-wifi-模块的-i.mxrt1011-开发板&quot;&gt;&lt;span&gt;4、Metro M7 - 一款带 AirLift WiFi 模块的 i.MXRT1011 开发板&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;Adafruit 网站上发现的一款带 AirLift WiFi 模块兼容 Arduino 的开发板，主控是恩智浦新推的 500MHz 主频的 i.MXRT1011，WiFi 模块是乐鑫的 ESP32，此板仍在研发中。&lt;/p&gt;
&lt;blockquote readability=&quot;0.75&quot;&gt;
&lt;p&gt;项目帖子：&lt;a href=&quot;https://blog.adafruit.com/2020/02/29/metro-m7-rt1011-w-airlift-wifi-espressifsystem-nxp-arduino-adafruit/&quot; class=&quot;uri&quot;&gt;https://blog.adafruit.com/2020/02/29/metro-m7-rt1011-w-airlift-wifi-espressifsystem-nxp-arduino-adafruit/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/biweekly/Metro_M7_imxrt1011.PNG&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;工具类&quot;&gt;工具类&lt;/h2&gt;
&lt;h3 id=&quot;rt-thread-studio---rt-thread-项目开发一站式工具ide&quot;&gt;&lt;span&gt;1、RT-Thread Studio - RT-Thread 项目开发一站式工具(IDE)&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;RT-Thread Studio 是 RT-Thread 团队于 2019 年 12 月 25 日全新推出的一站式开发工具，全面取代其上一代集成度不高的开发工具 ENV。&lt;/p&gt;
&lt;blockquote readability=&quot;1.3157894736842&quot;&gt;
&lt;p&gt;软件主页：&lt;a href=&quot;https://www.rt-thread.org/page/studio.html&quot; class=&quot;uri&quot;&gt;https://www.rt-thread.org/page/studio.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;RT-Thread 是为数不多的国产 RTOS 之光，这些年的发展有目共睹，生态体系建设越来越完善，用户群也越来越庞大。RT-Thread Studio 就是其构建软件生态的重要一环。&lt;/p&gt;
&lt;p&gt;RT-Thread Studio 主要包括工程创建和管理，代码编辑，SDK管理，RT-Thread配置，构建配置，调试配置，程序下载和调试等功能，结合图形化配置系统以及软件包和组件资源，减少重复工作，提高开发效率。&lt;/p&gt;
&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt;- 社区版本永久免费
- 支持主流C/C++语言开发
- 强大的代码编辑和重构功能
- SDK管理器支持在线下载更新 RT-Thread 最新源码包
- 简单易用的工程创建向导，快速验证原型
- 全新图形化配置系统，同时支持架构图和树形图配置
- 软件包市场提供丰富的可用软件包资源
- 丰富的调试功能，快速查看和跟踪定位代码问题&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/biweekly/RT-Thread_Studio.PNG&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;emwin-appwizard---面向下一代嵌入式应用的-emwin-界面构建工具&quot;&gt;&lt;span&gt;2、emWin AppWizard - 面向下一代嵌入式应用的 emWin 界面构建工具&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;AppWizard 是 SEGGER 公司为其嵌入式 GUI 库 emWin 全新设计的面向下一代嵌入式应用的界面构建工具，伴随着 emWin v6.10 （2020年3月）一起发布，用于取代之前的界面构建工具 GUIBuilder。&lt;/p&gt;
&lt;blockquote readability=&quot;0.75757575757576&quot;&gt;
&lt;p&gt;产品主页：&lt;a href=&quot;https://www.segger.com/products/user-interface/emwin/tools/tools-overview/#appwizard&quot; class=&quot;uri&quot;&gt;https://www.segger.com/products/user-interface/emwin/tools/tools-overview/#appwizard&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;emWin 是非常流行的嵌入式 GUI 库，界面构建一直是 GUI 开发中的痛点，SEGGER 于 emWin v5.10 时（2011年8月）开始推出的 GUIBuilder 工具一定程度上帮助用户减轻了 GUI 开发的工作量，但 GUIBuilder 诞生至今近 9 年里因其较弱的功能一直备受吐槽。如 GUIBuilder 只适合单窗口编辑，并且不支持汉字字体，窗体风格设计等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/biweekly/emWin_GUIBuilder_rel.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;http://henjay724.com/image/biweekly/emWin_GUIBuilder_ui.PNG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一切爱恨，皆是过往，如今 AppWizard 来了，这是一个真正的所见即所得的界面构建工具，其典型功能如下：&lt;/p&gt;
&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt;- Complete and ready-to-run emWin applications
- Support of emWin's core features such as widgets, animations and language management
- Resource management for fonts and bitmaps - Multilingual text management
- Application's behavior can be defined with interactions
- Integrated play mode makes testing simple
- Exportable to simulation or target project through included BSPs
- Little to no experience with emWin or even C required &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/biweekly/emWin_AppWizard_rel.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;http://henjay724.com/image/biweekly/emWin_AppWizard_gui.PNG&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;i.mxrt出品&quot;&gt;i.MXRT出品&lt;/h2&gt;
&lt;h3 id=&quot;谷歌---stadia-云游戏手柄&quot;&gt;&lt;span&gt;1、谷歌 - Stadia 云游戏手柄&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;Stadia 云游戏平台，可以使玩家们打破硬件性能和游玩地点的限制，仅仅通过网络就可以在 PC、平板电脑、手机等各种设备上体验到原汁原味的 3A 游戏大作。Stadia 手柄是这个云游戏平台的配套设备，其除了常规的按钮和操作杆之外，还有一个专用按钮用于截取屏幕和录制视频剪辑。&lt;/p&gt;
&lt;blockquote readability=&quot;3.7222222222222&quot;&gt;
&lt;p&gt;RT芯片：i.MXRT1062&lt;br/&gt;产品主页： &lt;a href=&quot;https://www.stadia.dev/&quot; class=&quot;uri&quot;&gt;https://www.stadia.dev/&lt;/a&gt;&lt;br/&gt;官网定价： 69 美元起&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/biweekly/Stadia_440x246.gif&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;欢迎订阅&quot;&gt;欢迎订阅&lt;/h3&gt;
&lt;p&gt;文章会同时发布到我的 &lt;a href=&quot;https://www.cnblogs.com/henjay724/&quot;&gt;博客园主页&lt;/a&gt;、&lt;a href=&quot;https://blog.csdn.net/Henjay724&quot;&gt;CSDN主页&lt;/a&gt;、&lt;a href=&quot;http://weixin.sogou.com/weixin?type=1&amp;amp;query=%E7%97%9E%E5%AD%90%E8%A1%A1%E5%B5%8C%E5%85%A5%E5%BC%8F&quot;&gt;微信公众号&lt;/a&gt; 平台上。&lt;/p&gt;
&lt;p&gt;微信搜索&quot;&lt;strong&gt;痞子衡嵌入式&lt;/strong&gt;&quot;或者扫描下面二维码，就可以在手机上第一时间看了哦。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/github/pzhMcu_qrcode_258x258.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 05 Mar 2020 00:19:00 +0000</pubDate>
<dc:creator>痞子衡</dc:creator>
<og:description>痞子衡嵌入式半月刊： 第 3 期 这里分享嵌入式领域有用有趣的项目/工具以及一些热点新闻，农历年分二十四节气，希望在每个交节之日准时发布一期。 本期刊是开源项目（GitHub: &amp;quot;JayHe</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/henjay724/p/12418233.html</dc:identifier>
</item>
<item>
<title>[ASP.NET Core 3框架揭秘]服务承载系统[4]:总体设计[下篇] - Artech</title>
<link>http://www.cnblogs.com/artech/p/inside-asp-net-core-09-04.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/artech/p/inside-asp-net-core-09-04.html</guid>
<description>&lt;p&gt;在了解了作为服务宿主的IHost接口之后，我们接着来认识一下作为宿主构建者的&lt;span&gt;IHostBuilder&lt;/span&gt;接口。如下面的代码片段所示，IHostBuilder接口的核心方法Build用来提供由它构建的IHost对象。除此之外，它还具有一个字典类型的只读属性Properties，我们可以将它视为一个共享的数据容器。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IHostBuilder
{    
    IDictionary&lt;/span&gt;&amp;lt;&lt;span&gt;object&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt; Properties { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    IHost Build();
    …
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;作为一个典型的设计模式，Builder模式在最终提供给由它构建的对象之前，一般会允许作相应的前期设置，IHostBuilder针对IHost的构建也不例外。IHostBuilder接口提供了一系列的方法，我们可以利用它们为最终构建的IHost对象作相应的设置，具体的设置主要涵盖两个方面：针对配置系统的设置和针对依赖注入框架的设置。&lt;/p&gt;

&lt;p&gt;IHostBuilder接口针对配置系统的设置体现在&lt;span&gt;ConfigureHostConfiguration&lt;/span&gt;和&lt;span&gt;ConfigureAppConfiguration&lt;/span&gt;方法上。通过前面的实例演示，我们知道ConfigureHostConfiguration方法涉及的配置主要是在&lt;span&gt;服务承载过程&lt;/span&gt;中使用的，是针对服务宿主的配置；ConfigureAppConfiguration方法设置的则是供承载的&lt;span&gt;IHostedService&lt;/span&gt;服务使用的，是针对应用的配置。不过前者最终会合并到后者之中，我们最终得到的配置实际上是两者合并的结果。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IHostBuilder
{
    IHostBuilder ConfigureHostConfiguration( Action&lt;/span&gt;&amp;lt;IConfigurationBuilder&amp;gt;&lt;span&gt; configureDelegate); 
    IHostBuilder ConfigureAppConfiguration( Action&lt;/span&gt;&amp;lt;HostBuilderContext, IConfigurationBuilder&amp;gt;&lt;span&gt; configureDelegate);
    …
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从上面的代码片段可以看出ConfigureHostConfiguration方法提供一个Action&amp;lt;IConfigurationBuilder&amp;gt;类型的委托作为参数，我们可以利用它注册不同的配置源或者作相应的设置（比如设置配置文件所在目录的路径）。另一个方法ConfigureAppConfiguration的参数类型则是Action&amp;lt;HostBuilderContext, IConfigurationBuilder&amp;gt;，作为第一个参数的HostBuilderContext对象携带了与服务承载相关的上下文信息，我们可以利用该上下文对配置系统作针对性设置。&lt;/p&gt;
&lt;p&gt;HostBuilderContext携带的上下文主要包含两个部分：其一，&lt;span&gt;通过调用ConfigureHostConfiguration方法设置的针对宿主的配置&lt;/span&gt;；其二，&lt;span&gt;当前的承载环境&lt;/span&gt;。这两部分上下文信息分别对应着如下所示的Configuration和HostingEnvironment属性。除此之外，HostBuilderContext同样具有一个作为共享数据字典的Properties属性。如果针对配置系统的设置与当前承载上下文无关，我们可以调用如下这个同名的扩展方法，该方法提供的参数依旧是一个Action&amp;lt;IConfigurationBuilder&amp;gt;类型的委托。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HostBuilderContext
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IConfiguration Configuration { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IHostEnvironment HostingEnvironment { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IDictionary&amp;lt;&lt;span&gt;object&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt; Properties { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; HostBuilderContext(IDictionary&amp;lt;&lt;span&gt;object&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt; properties);
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HostingHostBuilderExtensions
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IHostBuilder ConfigureAppConfiguration(&lt;span&gt;this&lt;/span&gt; IHostBuilder hostBuilder, Action&amp;lt;IConfigurationBuilder&amp;gt;&lt;span&gt; configureDelegate)
    &lt;/span&gt;=&amp;gt; hostBuilder.ConfigureAppConfiguration((context, builder) =&amp;gt;&lt;span&gt;configureDelegate(builder));
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;任何一个应用总是针对某个具体的环境进行部署的，我们将承载服务的部署环境称为承载环境。承载环境通过IHostEnvironment接口表示，HostBuilderContext的HostingEnvironment属性返回的就是一个IHostEnvironment对象。如下面的代码片段所示，除了表示环境名称的EnvironmentName属性之外，IHostEnvironment接口还定义了一个表示当前应用名称的ApplicationName属性。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IHostEnvironment
{
    &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; EnvironmentName { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; ApplicationName { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; ContentRootPath { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    IFileProvider ContentRootFileProvider { &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当我们编译某个.NET Core项目的时候，提供的代码文件（.cs）文件会转换成元数据和IL指令保存到生成的程序集中，其他一些文件还可以作为程序集的内嵌资源。除了这些面向程序集的文件之外，一些文件还会以静态文件的形式供应用程序使用，比如Web应用三种典型的静态文件（JavaScript、CSS和图片），我们将这些静态文件称为内容文件“Content File”。IHostEnvironment接口的ContentRootPath表示的就是存放这些内容文件的根目录所在的路径，另一个ContentRootFileProvider属性对应的则是指向该路径的IFileProvider对象，我们可以利用它获取目录的层次结构，也可以直接利用它来读取文件的内容。&lt;/p&gt;
&lt;p&gt;开发、预发和产品是三种最为典型的承载环境，如果采用“Development”、“Staging”和“Production”来对它们进行命名，我们针对这三种承载环境的判断就可以利用如下三个扩展方法（IsDevelopment、IsStaging和IsProduction）来完成。如果我们需要判断指定的IHostEnvironment对象是否属于某个具体的环境，可以直接调用扩展方法IsEnvironment。从给出的代码片段我们不难看出针对环境名称的比较是不区分大小写的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HostEnvironmentEnvExtensions
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; IsDevelopment(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; IHostEnvironment hostEnvironment)
        &lt;/span&gt;=&amp;gt;&lt;span&gt; hostEnvironment.IsEnvironment(Environments.Development);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; IsStaging(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; IHostEnvironment hostEnvironment)
        &lt;/span&gt;=&amp;gt;&lt;span&gt; hostEnvironment.IsEnvironment(Environments.Staging);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; IsProduction(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; IHostEnvironment hostEnvironment)
        &lt;/span&gt;=&amp;gt;&lt;span&gt; hostEnvironment.IsEnvironment(Environments.Production);

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; IsEnvironment(&lt;span&gt;this&lt;/span&gt; IHostEnvironment hostEnvironment, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; environmentName)
        &lt;/span&gt;=&amp;gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;.Equals(hostEnvironment.EnvironmentName, environmentName, StringComparison.OrdinalIgnoreCase);
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Environments
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Development = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Development&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Production = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Production&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Staging = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Staging&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;IHostEnvironment对象承载的3个属性都是通过配置的形式提供的，对应的配置项名称为“environment”和“contentRoot”和“applicationName”，它们对应着HostDefaults类型中三个静态只读字段。我们可以调用如下这两个针对IHostBuilder接口的UseEnvironment和UseContentRoot扩展方法来设置环境名称和内容文件根目录路径。从给出的代码片段可以看出，该方法依旧是调用的ConfigureHostConfiguration方法。如果没有对应用名称做显示设置，入口程序集名称会作为当前应用名称。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HostDefaults
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; EnvironmentKey = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;environment&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; ContentRootKey = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;contentRoot&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; ApplicationKey = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;applicationName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HostingHostBuilderExtensions
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IHostBuilder UseEnvironment(&lt;span&gt;this&lt;/span&gt; IHostBuilder hostBuilder, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; environment)
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; hostBuilder.ConfigureHostConfiguration(configBuilder =&amp;gt;&lt;span&gt;
        {
            configBuilder.AddInMemoryCollection(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt;[]
            {
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; KeyValuePair&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;(HostDefaults.EnvironmentKey,environment)
            });
        });

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IHostBuilder UseContentRoot(&lt;span&gt;this&lt;/span&gt; IHostBuilder hostBuilder, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; contentRoot)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; hostBuilder.ConfigureHostConfiguration(configBuilder =&amp;gt;&lt;span&gt;
            {
                configBuilder.AddInMemoryCollection(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt;[]
                {
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; KeyValuePair&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;(HostDefaults.ContentRootKey,
                    contentRoot))
                });
        });
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;由于包括承载服务在内的所有依赖服务都是由依赖注入框架提供的，所以IHostBuilder接口提供了更多的方法来对完成服务注册。绝大部分用来注册服务的方法最终都调用了如下所示的&lt;span&gt;ConfigureServices&lt;/span&gt;方法，由于该方法提供的参数是一个&lt;span&gt;Action&amp;lt;HostBuilderContext, IServiceCollection&amp;gt;&lt;/span&gt;类型的委托，意味服务可以针对当前的承载上下文进行针对性注册。如果注册的服务与当前承载上下文无关，我们可以调用如下所示的这个同名的扩展方法，该方法提供的参数是一个类型为 &lt;span&gt;Action&amp;lt;IServiceCollection&amp;gt;&lt;/span&gt;的委托对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IHostBuilder
{
    IHostBuilder ConfigureServices(Action&lt;/span&gt;&amp;lt;HostBuilderContext, IServiceCollection&amp;gt;&lt;span&gt; configureDelegate);
    …
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HostingHostBuilderExtensions
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IHostBuilder ConfigureServices(&lt;span&gt;this&lt;/span&gt; IHostBuilder hostBuilder, Action&amp;lt;IServiceCollection&amp;gt;&lt;span&gt; configureDelegate)
        &lt;/span&gt;=&amp;gt; hostBuilder.ConfigureServices((context, collection) =&amp;gt;&lt;span&gt; configureDelegate(collection));
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在《&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-09-02.html&quot;&gt;承载长时间运行的服务[下篇]&lt;/a&gt;》针对日志的演示中，我们调用了IHostBuilder接口的扩展方法&lt;span&gt;ConfigureLogging&lt;/span&gt;注册了针对日志框架的核心服务，如下的代码片段展示了这两个扩展方法重载的定义。可以看出这两个方法的背后依旧是调用上面这个ConfigureServices方法，具体的服务是通过调用IServiceCollection接口的AddLogging扩展方法注册的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HostingHostBuilderExtensions
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IHostBuilder ConfigureLogging(&lt;span&gt;this&lt;/span&gt; IHostBuilder hostBuilder, Action&amp;lt;HostBuilderContext, ILoggingBuilder&amp;gt;&lt;span&gt; configureLogging)
        &lt;/span&gt;=&amp;gt; hostBuilder.ConfigureServices((context, collection) =&amp;gt; collection.AddLogging(builder =&amp;gt;&lt;span&gt; configureLogging(context, builder)));

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IHostBuilder ConfigureLogging(&lt;span&gt;this&lt;/span&gt; IHostBuilder hostBuilder, Action&amp;lt;ILoggingBuilder&amp;gt;&lt;span&gt; configureLogging)
            &lt;/span&gt;=&amp;gt; hostBuilder.ConfigureServices((context, collection) =&amp;gt; collection.AddLogging(builder =&amp;gt;&lt;span&gt; configureLogging(builder)));
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;IHostBuilder接口提供了如下两个&lt;span&gt;UseServiceProviderFactory&amp;lt;TContainerBuilder&amp;gt;&lt;/span&gt;方法重载，我们可以利用它注册的IServiceProviderFactory&amp;lt;TContainerBuilder&amp;gt;对象实现&lt;span&gt;对第三方依赖注入框架的整合&lt;/span&gt;。除此之外，该接口还提供了另一个ConfigureContainer&amp;lt;TContainerBuilder&amp;gt;为注册IServiceProviderFactory&amp;lt;TContainerBuilder&amp;gt;对象创建的容器作进一步设置。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IHostBuilder
{
    IHostBuilder UseServiceProviderFactory&lt;/span&gt;&amp;lt;TContainerBuilder&amp;gt;(IServiceProviderFactory&amp;lt;TContainerBuilder&amp;gt;&lt;span&gt; factory);
    IHostBuilder UseServiceProviderFactory&lt;/span&gt;&amp;lt;TContainerBuilder&amp;gt;(Func&amp;lt;HostBuilderContext, IServiceProviderFactory&amp;lt;TContainerBuilder&amp;gt;&amp;gt;&lt;span&gt; factory);
    IHostBuilder ConfigureContainer&lt;/span&gt;&amp;lt;TContainerBuilder&amp;gt;(Action&amp;lt;HostBuilderContext, TContainerBuilder&amp;gt;&lt;span&gt; configureDelegate);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我个人觉得.NET Core依赖注入框架已经能够满足绝大部分应用开发的需求了，所以真正与第三方依赖注入框架的整合其实并没有太多的必要。我们知道原生的依赖注入框架使用DefaultServiceProviderFactory来提供作为依赖注入容器的IServiceProvider，针对它的注册由如下这两个&lt;span&gt;UseDefaultServiceProvider&lt;/span&gt;扩展方法来完成。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HostingHostBuilderExtensions
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IHostBuilder UseDefaultServiceProvider(&lt;span&gt;this&lt;/span&gt; IHostBuilder hostBuilder, Action&amp;lt;ServiceProviderOptions&amp;gt;&lt;span&gt; configure)
    &lt;/span&gt;=&amp;gt; hostBuilder.UseDefaultServiceProvider((context, options) =&amp;gt;&lt;span&gt; configure(options));

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IHostBuilder UseDefaultServiceProvider(&lt;span&gt;this&lt;/span&gt; IHostBuilder hostBuilder, Action&amp;lt;HostBuilderContext, ServiceProviderOptions&amp;gt;&lt;span&gt; configure)
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; hostBuilder.UseServiceProviderFactory(context =&amp;gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; options = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServiceProviderOptions();
            configure(context, options);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultServiceProviderFactory(options);
        });
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;定义在IHostBuilder接口的ConfigureContainer&amp;lt;TContainerBuilder&amp;gt;方法提供的参数是一个类型为Action&amp;lt;HostBuilderContext, TContainerBuilder&amp;gt;的委托对象，如果我们针对TContainerBuilder的设置与当前承载上下文无关，我们也可以调用如下的这个简化的ConfigureContainer&amp;lt;TContainerBuilder&amp;gt;扩展方法，它只需要提供一个Action&amp;lt;TContainerBuilder&amp;gt;对象作为参数就可以了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HostingHostBuilderExtensions
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IHostBuilder ConfigureContainer&amp;lt;TContainerBuilder&amp;gt;(&lt;span&gt;this&lt;/span&gt; IHostBuilder hostBuilder, Action&amp;lt;TContainerBuilder&amp;gt;&lt;span&gt; configureDelegate)
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; hostBuilder.ConfigureContainer&amp;lt;TContainerBuilder&amp;gt;((context, builder) =&amp;gt;&lt;span&gt; configureDelegate(builder));
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;IHostBuilder接口还具有如下这个StartAsync扩展方法，它同时完成了针对IHost对象的创建和启动工作，它的另一个Start方法是StartAsync方法的同步版本。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HostingAbstractionsHostBuilderExtensions
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;IHost&amp;gt; StartAsync(&lt;span&gt;this&lt;/span&gt; IHostBuilder hostBuilder, CancellationToken cancellationToken = &lt;span&gt;default&lt;/span&gt;&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; host =&lt;span&gt; hostBuilder.Build();
        &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; host.StartAsync(cancellationToken);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; host;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IHost Start(&lt;span&gt;this&lt;/span&gt; IHostBuilder hostBuilder) =&amp;gt;&lt;span&gt; hostBuilder.StartAsync().GetAwaiter().GetResult();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-09-01.html&quot;&gt;服务承载系统[1]: 承载长时间运行的服务[上篇]&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-09-02.html&quot;&gt;服务承载系统[2]: 承载长时间运行的服务[下篇]&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-09-03.html&quot;&gt;服务承载系统[3]: 总体设计[上篇]&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-09-04.html&quot;&gt;服务承载系统[4]: 总体设计[下篇]&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-09-05.html&quot;&gt;服务承载系统[5]: 承载服务启动流程[上篇]&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-09-06.html&quot;&gt;服务承载系统[6]: 承载服务启动流程[下篇]&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 05 Mar 2020 00:01:00 +0000</pubDate>
<dc:creator>Artech</dc:creator>
<og:description>在了解了作为服务宿主的IHost接口之后，我们接着来认识一下作为宿主构建者的IHostBuilder接口。如下面的代码片段所示，IHostBuilder接口的核心方法Build用来提供由它构建的IHo</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/artech/p/inside-asp-net-core-09-04.html</dc:identifier>
</item>
<item>
<title>.NET Core 基于Websocket的在线聊天室 - Agile.Zhou</title>
<link>http://www.cnblogs.com/kklldog/p/core-for-websocket.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kklldog/p/core-for-websocket.html</guid>
<description>&lt;h2 id=&quot;什么是websocket&quot;&gt;什么是Websocket&lt;/h2&gt;
&lt;p&gt;我们在传统的客户端程序要实现实时双工通讯第一想到的技术就是socket通讯，但是在web体系是用不了socket通讯技术的，因为http被设计成无状态，每次跟服务器通讯完成后就会断开连接。&lt;br/&gt;在没有websocket之前web系统如果要做双工通讯往往使用http long polling技术。http long polling 每次往服务器发送请求后，服务端不会立刻返回信息来结束请求，而是一直挂着直到有数据需要返回，或者等待超时了才会返回。客户端在结束上一次请求后立刻再发送一次请求，如此反复。http long polling虽然能实现web系统的双工通讯，但是有个很大的问题，就是基于http协议客户端每次发送请求都需要携带巨大的头部。在并发交互少量数据的时候非常不划算，对服务器资源的消耗也是巨大的。&lt;br/&gt;websocket很好的改善了以上问题。它基于tcp重新设计了一套协议，同时又兼容http，默认跟http一样使用80/443端口。websocket链接建立本质上就是一次http请求，直接使用http协议的upgrade头来标识这是一次websocket请求，服务端回复101状态码表示“握手”成功。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//客户端请求
GET / HTTP/1.1
Upgrade: websocket
Connection: Upgrade
Host: example.com
Origin: http://example.com
Sec-WebSocket-Key: sN9cRrP/n9NdMgdcy2VJFQ==
Sec-WebSocket-Version: 13

//服务端响应
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: fFBooB7FAkLlXgRSz0BT3v4hq5s=
Sec-WebSocket-Location: ws://example.com/&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;使用asp.net-core来处理websocket&quot;&gt;使用asp.net core来处理websocket&lt;/h2&gt;
&lt;p&gt;上面我们简单的了解了websocket，那么如何来使用asp.net core处理websocket呢？因为websocket的握手就是一次http请求，那么我们就可以使用一个middleware来拦截websocket的请求，把建立的链接统一进行管理，其实微软已经帮我们简单的封装过了。&lt;/p&gt;
&lt;h3 id=&quot;新建一个asp.net-core网站&quot;&gt;新建一个asp.net core网站&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/kklldog/1401672/o_200304033211TIM%E6%88%AA%E5%9B%BE20200304105929.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;新建websockethandlermiddleware中间件&quot;&gt;新建WebsocketHandlerMiddleware中间件&lt;/h3&gt;
&lt;p&gt;这个中间件就是我们管理websocket链接的入口，我们调用context.WebSockets.AcceptWebSocketAsync()方法把请求转换为websocket链接。&lt;/p&gt;
&lt;h4 id=&quot;在invoke方法内接收websocket链接&quot;&gt;在Invoke方法内接收websocket链接&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;      public async Task Invoke(HttpContext context)
        {
            if (context.Request.Path == &quot;/ws&quot;)
            {
                if (context.WebSockets.IsWebSocketRequest)
                {
                    WebSocket webSocket = await context.WebSockets.AcceptWebSocketAsync();
                    string clientId = Guid.NewGuid().ToString(); ;
                    var wsClient = new WebsocketClient
                    {
                        Id = clientId,
                        WebSocket = webSocket
                    };
                    try
                    {
                        await Handle(wsClient);
                    }
                    catch (Exception ex)
                    {
                        _logger.LogError(ex, &quot;Echo websocket client {0} err .&quot;, clientId);
                        await context.Response.WriteAsync(&quot;closed&quot;);
                    }
                }
                else
                {
                    context.Response.StatusCode = 404;
                }
            }
            else
            {
                await _next(context);
            }
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;在hanle方法等待客户端的消息&quot;&gt;在Hanle方法等待客户端的消息&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;        private async Task Handle(WebsocketClient webSocket)
        {
            WebsocketClientCollection.Add(webSocket);
            _logger.LogInformation($&quot;Websocket client added.&quot;);
           
            WebSocketReceiveResult result = null;
            do
            {
                var buffer = new byte[1024 * 1];
                result = await webSocket.WebSocket.ReceiveAsync(new ArraySegment&amp;lt;byte&amp;gt;(buffer), CancellationToken.None);
                if (result.MessageType == WebSocketMessageType.Text &amp;amp;&amp;amp; !result.CloseStatus.HasValue)
                {
                    var msgString = Encoding.UTF8.GetString(buffer);
                    _logger.LogInformation($&quot;Websocket client ReceiveAsync message {msgString}.&quot;);
                    var message = JsonConvert.DeserializeObject&amp;lt;Message&amp;gt;(msgString);
                    message.SendClientId = webSocket.Id;
                    MessageRoute(message);
                }
            }
            while (!result.CloseStatus.HasValue);
            WebsocketClientCollection.Remove(webSocket);
            _logger.LogInformation($&quot;Websocket client closed.&quot;);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;在messageroute方法内对客户端的消息进行转发&quot;&gt;在MessageRoute方法内对客户端的消息进行转发&lt;/h4&gt;
&lt;p&gt;对客户端的消息定义几个标准的action，对不同的action进行特定的处理，比如加入房间、离开房间、在房间内广播消息等。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private void MessageRoute(Message message)
        {
            var client = WebsocketClientCollection.Get(message.SendClientId);
            switch (message.action)
            {
                case &quot;join&quot;:
                    client.RoomNo = message.msg;
                    client.SendMessageAsync($&quot;{message.nick} join room {client.RoomNo} success .&quot;);
                    _logger.LogInformation($&quot;Websocket client {message.SendClientId} join room {client.RoomNo}.&quot;);
                    break;
                case &quot;send_to_room&quot;:
                    if (string.IsNullOrEmpty(client.RoomNo))
                    {
                        break;
                    }
                    var clients = WebsocketClientCollection.GetRoomClients(client.RoomNo);
                    clients.ForEach(c =&amp;gt;
                    {
                        c.SendMessageAsync(message.nick + &quot; : &quot; + message.msg);
                    });
                    _logger.LogInformation($&quot;Websocket client {message.SendClientId} send message {message.msg} to room {client.RoomNo}&quot;);

                    break;
                case &quot;leave&quot;:
                    var roomNo = client.RoomNo;
                    client.RoomNo = &quot;&quot;;
                    client.SendMessageAsync($&quot;{message.nick} leave room {roomNo} success .&quot;);
                    _logger.LogInformation($&quot;Websocket client {message.SendClientId} leave room {roomNo}&quot;);
                    break;
                default:
                    break;
            }
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;新建websocketclientcollection管理类&quot;&gt;新建WebsocketClientCollection管理类&lt;/h3&gt;
&lt;p&gt;这个类是个容器，用来存放所有的websocket链接，便于统一管理。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public class WebsocketClientCollection
    {
        private static List&amp;lt;WebsocketClient&amp;gt; _clients = new List&amp;lt;WebsocketClient&amp;gt;();

        public static void Add(WebsocketClient client)
        {
            _clients.Add(client);
        }

        public static void Remove(WebsocketClient client)
        {
            _clients.Remove(client);
        }

        public static WebsocketClient Get(string clientId)
        {
            var client = _clients.FirstOrDefault(c=&amp;gt;c.Id == clientId);

            return client;
        }

        public static List&amp;lt;WebsocketClient&amp;gt; GetRoomClients(string roomNo)
        {
            var client = _clients.Where(c =&amp;gt; c.RoomNo == roomNo);
            return client.ToList();
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;在startup中使用中间件&quot;&gt;在Startup中使用中间件&lt;/h3&gt;
&lt;p&gt;有了上面的中间件，我们需要use一下。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  app.UseWebSockets(new WebSocketOptions
            {
                KeepAliveInterval = TimeSpan.FromSeconds(60),
                ReceiveBufferSize = 1* 1024
            });
  app.UseMiddleware&amp;lt;WebsocketHandlerMiddleware&amp;gt;();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到此我们的服务端基本完成了，下面进行客户端html跟JavaScript的编写。&lt;/p&gt;
&lt;h3 id=&quot;编写客户端界面&quot;&gt;编写客户端界面&lt;/h3&gt;
&lt;p&gt;修改index.cshtml来实现一个简单的聊天室ui。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;div style=&quot;margin-bottom:5px;&quot;&amp;gt;
    room no: &amp;lt;input type=&quot;text&quot;  id=&quot;txtRoomNo&quot; value=&quot;8888&quot;/&amp;gt; &amp;lt;button id=&quot;btnJoin&quot;&amp;gt;join room&amp;lt;/button&amp;gt; &amp;lt;button id=&quot;btnLeave&quot;&amp;gt;leave room&amp;lt;/button&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;div style=&quot;margin-bottom:5px;&quot;&amp;gt;
    nick name: &amp;lt;input type=&quot;text&quot; id=&quot;txtNickName&quot; value=&quot;batman&quot; /&amp;gt; 
&amp;lt;/div&amp;gt;
&amp;lt;div style=&quot;height:300px;width:600px&quot;&amp;gt;
    &amp;lt;textarea style=&quot;height:100%;width:100%&quot; id=&quot;msgList&quot;&amp;gt;&amp;lt;/textarea&amp;gt;
    &amp;lt;div style=&quot;text-align: right&quot;&amp;gt;
        &amp;lt;input type=&quot;text&quot; id=&quot;txtMsg&quot; value=&quot;&quot; /&amp;gt;  &amp;lt;button id=&quot;btnSend&quot;&amp;gt;send&amp;lt;/button&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;使用javascript来处理websocket链接及消息&quot;&gt;使用JavaScript来处理websocket链接及消息&lt;/h3&gt;
&lt;p&gt;现代浏览器已经都支持websocket协议，JavaScript运行时内置了WebSocket类，我们仅仅需要new一个Websocket对象出来就可以对websocket进行操作。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
var server = 'ws://localhost:5000'; //如果开启了https则这里是wss

var WEB_SOCKET = new WebSocket(server + '/ws');

WEB_SOCKET.onopen = function (evt) {
    console.log('Connection open ...');
    $('#msgList').val('websocket connection opened .');
};

WEB_SOCKET.onmessage = function (evt) {
    console.log('Received Message: ' + evt.data);
    if (evt.data) {
        var content = $('#msgList').val();
        content = content + '\r\n' + evt.data;

        $('#msgList').val(content);
    }
};

WEB_SOCKET.onclose = function (evt) {
    console.log('Connection closed.');
};

$('#btnJoin').on('click', function () {
    var roomNo = $('#txtRoomNo').val();
    var nick = $('#txtNickName').val();
    if (roomNo) {
        var msg = {
            action: 'join',
            msg: roomNo,
            nick: nick
        };
        WEB_SOCKET.send(JSON.stringify(msg));
    }
});

$('#btnSend').on('click', function () {
    var message = $('#txtMsg').val();
    var nick = $('#txtNickName').val();
    if (message) {
        WEB_SOCKET.send(JSON.stringify({
            action: 'send_to_room',
            msg: message,
            nick: nick
        }));
    }
});

$('#btnLeave').on('click', function () {
    var nick = $('#txtNickName').val();
    var msg = {
        action: 'leave',
        msg: '',
        nick: nick
    };
    WEB_SOCKET.send(JSON.stringify(msg));
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;运行&quot;&gt;运行&lt;/h3&gt;
&lt;p&gt;至此我们的聊天室已经搭建完成了，运行一下看看效果。我们启动两个页面，进行聊天。&lt;br/&gt;可以看到我们的消息被实时的转发出去了，good job ！&lt;br/&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/kklldog/1401672/o_200304033220TIM%E6%88%AA%E5%9B%BE20200304112745.jpg&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/kklldog/1401672/o_200304033227TIM%E6%88%AA%E5%9B%BE20200304112756.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;源码&quot;&gt;源码&lt;/h2&gt;
&lt;p&gt;源码已上传github&lt;br/&gt;&lt;a href=&quot;https://github.com/kklldog/CoreWebsocketChatRoom&quot;&gt;CoreWebsocketChatRoom&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 04 Mar 2020 16:53:00 +0000</pubDate>
<dc:creator>Agile.Zhou</dc:creator>
<og:description>什么是Websocket 我们在传统的客户端程序要实现实时双工通讯第一想到的技术就是socket通讯，但是在web体系是用不了socket通讯技术的，因为http被设计成无状态，每次跟服务器通讯完成后</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kklldog/p/core-for-websocket.html</dc:identifier>
</item>
<item>
<title>Roma - Facebook工具链大一统 - 小雨小雨丶</title>
<link>http://www.cnblogs.com/xiaoyuxy/p/12417155.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaoyuxy/p/12417155.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://github.com/facebookexperimental/rome/raw/master/assets/logo_with_text.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;什么是roma&quot;&gt;什么是roma&lt;/h3&gt;
&lt;p&gt;roma，中文名&lt;code&gt;罗马&lt;/code&gt;，是Facebook的rn团队的产出，是一个试验性质的javascript工具链，集编译，linter，格式化，打包，测试等等于一体。目标是成为一个处理javascript源代码的全面性工具。&lt;/p&gt;
&lt;p&gt;roma不是一个收集已有工具的整合体，所有的内部组件都是有业务逐渐提炼出来的，并且没有使用三方库。&lt;/p&gt;
&lt;p&gt;roma虽然是试验性工具，但是目前正在积极地发展。目前对所有感兴趣的未来贡献者们敞开大门。因为roma还没有做好在生产环境使用的准备，所以使用roma的唯一方式是从源代码构建。&lt;/p&gt;
&lt;p&gt;roma是有志向的工具链，它或许将替代很多已存在的javascript工具。当然，我们将来也会提供可以在其他工具中使用的组件。比如将roma作为插件集成在其他打包器中。&lt;/p&gt;
&lt;p&gt;roma遵循&lt;a href=&quot;https://github.com/facebookexperimental/rome/blob/master/LICENSE&quot;&gt;MIT协议&lt;/a&gt;，并且基于&lt;a href=&quot;https://github.com/facebookexperimental/rome/blob/master/.github/CODE_OF_CONDUCT.md&quot;&gt;Contributor Covenant Code of Conduct&lt;/a&gt;管理。&lt;/p&gt;
&lt;h3 id=&quot;roma的诞生&quot;&gt;roma的诞生&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://twitter.com/sebmck&quot;&gt;Sebastian McKenzie&lt;/a&gt;启动的roma项目，他同时也是babel和yarn的作者。&lt;/p&gt;
&lt;p&gt;roma是Facebook的rn团队合力完成的项目。&lt;/p&gt;
&lt;p&gt;roma的名字灵感来自于&lt;code&gt;条条大路通罗马&lt;/code&gt;、&lt;code&gt;罗马非一日可就&lt;/code&gt;和&lt;code&gt;在罗马的时候就要融入到罗马的生活中&lt;/code&gt;。这些指代我们对roma的期望，希望整个项目中有广阔的适应范围和我们对约定(一致性)的渴望。然而。roma这个雄心勃勃的项目起初来自于办公室的一句玩笑话。 : )&lt;/p&gt;
&lt;p&gt;roma有一个斯巴达头盔样式的logo，虽然可能与roma没有强相关性，但是它比&lt;a href=&quot;https://en.wikipedia.org/wiki/Galea_(helmet)&quot;&gt;Galea&lt;/a&gt;要帅得多。&lt;/p&gt;
&lt;h3 id=&quot;代码库&quot;&gt;代码库&lt;/h3&gt;
&lt;p&gt;roma几乎完全使用typescript编写，几乎没有松散类型。&lt;/p&gt;
&lt;p&gt;roma采用monorepo规范结构。&lt;/p&gt;
&lt;p&gt;roma完全自托管，每次更新会使用之前的版本编译新的代码。&lt;/p&gt;
&lt;p&gt;roma支持JSX和Flow、Typescript特有的注释代码。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/facebookexperimental/rome/blob/master/.github/CONTRIBUTING.md&quot;&gt;查看更多细节&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;当前集中点&quot;&gt;当前集中点&lt;/h3&gt;
&lt;p&gt;当前我们主要致力于linting部分，参考&lt;a href=&quot;https://github.com/facebookexperimental/rome/issues/20&quot;&gt;issue&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;快速上手&quot;&gt;快速上手&lt;/h3&gt;
&lt;p&gt;如果想要在项目中集成roma，你所要做的只有一个配置文件：roma.json&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ mkdir hello-world
$ cd hello-world
$ echo '{}' &amp;gt;rome.json&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该文件用来配置roma，并且也是划分是否受roma托管的重要标志。&lt;/p&gt;
&lt;p&gt;更新细节请查看&lt;a href=&quot;https://romejs.dev/docs/introduction/getting-started/&quot;&gt;官网&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;roma的哲学&quot;&gt;roma的哲学&lt;/h3&gt;
&lt;p&gt;下面的列表列出了roma信守的精神。这些内容是不全面的，其中一些是浅显易懂但是为了完成性依然将其列出。&lt;/p&gt;
&lt;h4 id=&quot;工程管理&quot;&gt;工程管理&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;设定明确的目标：提前制定工程的意图和期望，我们的工程不应该给我们惊喜！&lt;/li&gt;
&lt;li&gt;公开性：有关roma的讨论和决定都将在一些公共场景，如github、roma dicord和推特。唯一例外的是对于代码的审核我们将严格保密。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;技术&quot;&gt;技术&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;无外部依赖：我们可以通过更机密的集成我们的内部工具和互通抽象概念，使我们更告诉的推动项目的进度和更加一致性的体验。利用定制型我们有更多的机会去获得更好的体验。&lt;/li&gt;
&lt;li&gt;对错误提供修复提示：通过对常见使用方法的推断和过滤，我们要减少无关的、没有帮助的提示信息。&lt;/li&gt;
&lt;li&gt;更精确到错误信息：我们没有通用的错误信息，因为这不能帮助使用者明白为什么会出错，也不能帮助开发者更好的通过错误信息定位问题所在。&lt;/li&gt;
&lt;li&gt;简化API：对于可选配置和命令行参数，我们觉得不是必须的。他们并不能很好的组合使用。我们为什么不能简化这部分？&lt;/li&gt;
&lt;li&gt;避免专用术语：这些专用术语除了装X几乎没有其他作用，我们致力于让新手和专家都能一目了然，例如，在编译出错的时候，使用'character'代替'token'！&lt;/li&gt;
&lt;li&gt;对于命令和命令行参数避免缩写：没有必要时用令人迷惑且不得不查阅文档的缩写！&lt;/li&gt;
&lt;li&gt;容错率高的术语：使用那些更容易明白的术语&lt;/li&gt;
&lt;li&gt;兼容大部分终端：不要假设仅仅在terminal中使用，要兼容更多的通用环境。&lt;/li&gt;
&lt;li&gt;使用强类型：不要使用松散类型，尽可能的验证输入。&lt;/li&gt;
&lt;li&gt;终端上的输出更明确：设计终端输出的时候，不要仅仅依靠色彩来提高可读性，应合理运用格式、符号、间距来提高可读性。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;社区&quot;&gt;社区&lt;/h3&gt;
&lt;p&gt;贡献和开发介绍在&lt;a href=&quot;https://github.com/facebookexperimental/rome/blob/master/.github/CONTRIBUTING.md&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可以来这里&lt;a href=&quot;https://discord.gg/9WxHa5d&quot;&gt;这里&lt;/a&gt;一起讨论，但是要遵守我们的&lt;a href=&quot;https://github.com/facebookexperimental/rome/blob/master/.github/CODE_OF_CONDUCT.md&quot;&gt;准则&lt;/a&gt;哦！&lt;/p&gt;
</description>
<pubDate>Wed, 04 Mar 2020 16:08:00 +0000</pubDate>
<dc:creator>小雨小雨丶</dc:creator>
<og:description>什么是roma roma，中文名 ，是Facebook的rn团队的产出，是一个试验性质的javascript工具链，集编译，linter，格式化，打包，测试等等于一体。目标是成为一个处理javascr</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiaoyuxy/p/12417155.html</dc:identifier>
</item>
</channel>
</rss>