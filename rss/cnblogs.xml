<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>el-collapse header修改 - joyzher</title>
<link>http://www.cnblogs.com/naxwnm/p/14153165.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/naxwnm/p/14153165.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2126197/202012/2126197-20201218084449383-213873211.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2126197/202012/2126197-20201218084457442-1226893059.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h6 id=&quot;原版el-collapse的icon在右边，而我们ui设计是在最左边，而且右边还要加上此el-collapse-item的长度。&quot;&gt;原版el-collapse的icon在右边，而我们UI设计是在最左边，而且右边还要加上此el-collapse-item的长度。&lt;/h6&gt;
&lt;h3 id=&quot;实现思路&quot;&gt;实现思路&lt;/h3&gt;
&lt;h6 id=&quot;用flex-dirction：-row-reverse反转。然后用justify-content将内容放到左边，但这样也会让显示el-collapse-item长度放左边，这时加上一个margin-left：auto就可以解决。&quot;&gt;用flex-dirction： row-reverse反转。然后用justify-content将内容放到左边，但这样也会让显示el-collapse-item长度放左边，这时加上一个margin-left：auto就可以解决。&lt;/h6&gt;
&lt;pre&gt;
&lt;code class=&quot;language-css&quot;&gt;    .collapse-title {
      display: flex;
      &amp;amp;-length {
        margin-left: auto;
        margin-right: 14px;
      }
    }
    /deep/ .el-collapse-item__content {
      padding: 0;
    }
    /deep/ .el-collapse-item__arrow {
      margin: 4px 4px 4px 12px;
    }
    /deep/ .el-collapse-item__header {
      color: $blue;
      height: 40px;
      display: flex;
      flex-direction: row-reverse;
      justify-content: flex-end;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;&amp;lt;el-collapse&amp;gt;
  &amp;lt;template v-for=&quot;(item, key) in arr&quot;&amp;gt;
    &amp;lt;el-collapse-item
      :key=&quot;key&quot;
      :disabled=&quot;item.length == 0&quot;
    &amp;gt;
      &amp;lt;template slot=&quot;title&quot; class=&quot;collapse-title&quot;&amp;gt;
        &amp;lt;div class=&quot;collapse-title-length&quot;&amp;gt;
          {{ item.length }}
        &amp;lt;/div&amp;gt;
        &amp;lt;div&amp;gt;
          ...
        &amp;lt;/div&amp;gt;
      &amp;lt;/template&amp;gt;
    &amp;lt;/el-collapse-item&amp;gt;
  &amp;lt;/template&amp;gt;
&amp;lt;/el-collapse&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;

</description>
<pubDate>Fri, 18 Dec 2020 00:49:00 +0000</pubDate>
<dc:creator>joyzher</dc:creator>
<og:description>先看一下修改后的效果 修改前el-collapse效果 对比一下 原版el-collapse的icon在右边，而我们UI设计是在最左边，而且右边还要加上此el-collapse-item的长度。 实现</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/naxwnm/p/14153165.html</dc:identifier>
</item>
<item>
<title>深入LUA脚本语言，让你彻底明白调试原理 - sewain</title>
<link>http://www.cnblogs.com/sewain/p/14153146.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sewain/p/14153146.html</guid>
<description>&lt;br/&gt;&lt;center&gt;&lt;span&gt;这是道哥的第008篇原创&lt;/span&gt;&lt;/center&gt;&lt;p&gt;&lt;img src=&quot;http://ql815naye.hn-bkt.clouddn.com/wechat-qrcode.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;一、前言&quot;&gt;一、前言&lt;/h2&gt;
&lt;p&gt;上篇文章我们聊了&lt;a href=&quot;https://mp.weixin.qq.com/s/oY2pF5ilk8UCq09022Tt6w&quot; target=&quot;_blank&quot;&gt;gdb的底层调试机制&lt;/a&gt;，明白了gdb是利用操作系统提供的系统信号来调试目标程序的。很多朋友私下留言了，看到能帮助到大家，我心里还是很开心的，其实这也是我继续输出文章的最大动力！后面我会继续把自己在项目开发中的&lt;span&gt;实战经验&lt;/span&gt;进行总结。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ql815naye.hn-bkt.clouddn.com/comment.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于gdb的代码相对复杂，没有办法从代码层面仔细的分析调试细节，所以这次我们选择一个&lt;span&gt;小巧、开源的Lua脚本语言&lt;/span&gt;，深入到最底层的代码中去探究一下代码调试真正是怎么一回事。&lt;/p&gt;
&lt;p&gt;不过请放心，虽然深入到代码最底层，但是&lt;span&gt;理解难度并不大，只要C语言掌握的没问题&lt;/span&gt;，其他就都不是问题。&lt;br/&gt;另外，这篇文章重点不是介绍代码，而是介绍实现一个调试器应该如何思考，解决问题的思路是什么。&lt;/p&gt;
&lt;p&gt;通过阅读这篇文章，能有什么收获？&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如果你使用过Lua语言，那么你能够从源代码级别了解到调试库的代码逻辑。&lt;/li&gt;
&lt;li&gt;如果你对Lua不了解，可以从设计思想、实现架构上学习到一门编程语言是如何进行调试程序的。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;二、lua-语言简介&quot;&gt;二、Lua 语言简介&lt;/h2&gt;
&lt;h4 id=&quot;1-lua是什么鬼？&quot;&gt;1. Lua是什么鬼？&lt;/h4&gt;
&lt;p&gt;喜欢玩游戏的小伙伴可能会知道，Lua语言在&lt;span&gt;游戏开发&lt;/span&gt;中使用的比较多。它是一个&lt;span&gt;轻量、小巧&lt;/span&gt;的脚本语言，用标准&lt;span&gt;C语言&lt;/span&gt;编写，源码开放。正因为这几个原因，所以我才选择它作为剖析对象。&lt;/p&gt;
&lt;p&gt;如果对于Lua语言还是没有感觉，Python语言总应该知道吧？广告满天飞，你就把Lua想象为类似Python一样的脚本语言，只不过体积比Python要轻量的得多。&lt;/p&gt;
&lt;p&gt;这里有1张图可以了解下，2020年12月份的编程语言&lt;span&gt;市场占有率&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ql815naye.hn-bkt.clouddn.com/lua-2.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在上图中看不到Lua的身影，因为市场占有率太低了，大概是位于30几名。但是再看看下面这张图，从&lt;span&gt;工资&lt;/span&gt;的角度再体会一下Lua的高贵：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ql815naye.hn-bkt.clouddn.com/lua-1.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;远远的把&lt;span&gt;C/C++、JAVA&lt;/span&gt;甩在了身后，是不是有点冲动想学一下Lua语言了？先别激动，学习任何东西，先要想明白可以用在什么地方。如果仅仅是从找工作的角度来，Lua可以不用考虑了，毕竟市场需求量比较小。&lt;/p&gt;
&lt;h4 id=&quot;2-为什么选择lua语言作为研究对象？&quot;&gt;2. 为什么选择Lua语言作为研究对象？&lt;/h4&gt;
&lt;p&gt;虽然Lua语言在招聘网站中处于小众需求，但是这并不妨碍我们利用Lua来深入的学习、研究一门编程语言，Lua语言虽小，但是五脏俱全。就像我们如果想学习Linux内核的设计思想，你是愿意从最开始的版本(&lt;span&gt;几千行代码&lt;/span&gt;)开始呢？还是愿意从当前最新的内核代码(&lt;span&gt;2780万行代码，66492个文件&lt;/span&gt;)开始呢？&lt;/p&gt;
&lt;p&gt;看一下当前最新版的Lua代码体积:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ql815naye.hn-bkt.clouddn.com/lua-3.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同样的思路，如果我们想深入研究一门编程语言，选择哪一种语言，对于我们的积极性和学习效率是非常重要的。每个人的职业生涯都很长，花一些时间沉下心来研究透一门语言，对于一个开发者来说，还是蛮有成就的，对于职业的发展是非常有好处的，你会有一览众山小的感觉！&lt;/p&gt;
&lt;p&gt;再看一下Lua代码量与Python代码量的对比：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ql815naye.hn-bkt.clouddn.com/lua-18.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从功能上来说，Lua与Python之间是没有可比性的，但是我们的目的不是学习一个编程工具，而是研究一门编程语言本身，因此选择Lua脚本语言进行学习、研究，没有错！&lt;/p&gt;
&lt;p&gt;言归正传。&lt;/p&gt;
&lt;h2 id=&quot;三、lua源代码535&quot;&gt;三、Lua源代码5.3.5&lt;/h2&gt;
&lt;h4 id=&quot;1-lua程序是如何执行的？&quot;&gt;1. Lua程序是如何执行的？&lt;/h4&gt;
&lt;p&gt;Lua 是一门扩展式程序设计语言，被设计成支持通用过程式编程，并有相关数据描述设施。同时对面向对象编程、函数式编程和数据驱动式编程也提供了良好的支持。它作为一个强大、轻量的嵌入式脚本语言，可供任何需要的程序使用。&lt;/p&gt;
&lt;p&gt;作为一门扩展式语言，Lua没有&quot;main&quot;程序的概念：它只能嵌入一个宿主程序中工作，该宿主程序被称为&lt;span&gt;被嵌入程序或者简称宿主&lt;/span&gt;。宿主程序可以调用函数执行一小段Lua代码，可以读写Lua变量，可以注册C函数让Lua代码调用。依靠C函数，Lua可以共享相同的语法框架来定制编程语言，从而适用不同的领域。&lt;/p&gt;
&lt;p&gt;也就是说，我们写了一个test.lua程序，是没有办法直接运行它的。而实需要一个“宿主”程序，来加载test.lua文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ql815naye.hn-bkt.clouddn.com/lua-10.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;宿主程序可以是一个最简单的C程序，Lua官方提供了一个宿主程序。&lt;/p&gt;&lt;p&gt;我们也可以自己写一个，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 引入Lua头文件
#include &amp;lt;lua.h&amp;gt;
#include &amp;lt;lualib.h&amp;gt;
#include &amp;lt;lauxlib.h&amp;gt;

int main(int argc, char *argv[])
{
    // 创建一个Lua虚拟机
    lua_State *L = luaL_newstate();
    
    // 打开LUA中的标准库
    luaL_openlibs(L);
    
    // 加载 test.lua 程序
    if (luaL_loadfile(L, &quot;test.lua&quot;) || lua_pcall(L, 0, 0, 0))
    {
        printf(&quot;Error: %s \n&quot;, lua_tostring(g_lua_handle.L, -1));
        lua_close(g_lua_handle.L);
    }
    // 其他代码
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;2-lua语法&quot;&gt;2. Lua语法&lt;/h4&gt;
&lt;p&gt;在语法层面，Lua涵盖的内容还是比较全面的，它是一门动态类型语言，基本概念包括：八种基本数据类型，表是唯一的数据结构，环境与全局变量，元表及元方法，协程，闭包，错误处理，垃圾收集。具体的信息可以看一下&lt;a href=&quot;https://www.runoob.com/manual/lua53doc/manual.html&quot; target=&quot;_blank&quot;&gt;Lua5.3参考手册&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;这篇文章主要从&lt;span&gt;调试器&lt;/span&gt;这个角度进行分析，因此我不会在这里详细的贴出很多代码细节，而只是把与调试有关的代码贴出来进行解释。&lt;/p&gt;
&lt;p&gt;我之前在学习Lua源码时(5.3.5版本)，在代码文件中记录了很多注释，可以很好的帮助理解，主要是因为我的忘性比较好。&lt;/p&gt;
&lt;p&gt;其实我更建议大家自己去下载源码学习，经过自己的理解、加工，印象会更深刻。在之前的工作中，由于项目需要，我对源码进行了一些优化，这部分代码就不放出来了，添加注释的源码是完完全全的Lua5.3.5版本，大概是这个样子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ql815naye.hn-bkt.clouddn.com/lua-5.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ql815naye.hn-bkt.clouddn.com/lua-4.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果有小伙伴需要&lt;span&gt;加了注释的源码&lt;/span&gt;，请在公众号(&lt;span&gt;IOT物联网小镇&lt;/span&gt;)里留言给我。&lt;/p&gt;
&lt;h2 id=&quot;四、lua调试库相关&quot;&gt;四、Lua调试库相关&lt;/h2&gt;
&lt;p&gt;我们可以停下来稍微想一下，对一个程序进行调试，需要考虑的问题有3点：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;如何让程序暂停执行？&lt;/li&gt;
&lt;li&gt;如何获取程序的内部信息？&lt;/li&gt;
&lt;li&gt;如果修改程序的内部信息？&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;带着这些问题，我们来逐个击破。&lt;/p&gt;
&lt;h4 id=&quot;1-钩子函数hook：让程序暂停执行&quot;&gt;1. 钩子函数(Hook)：让程序暂停执行&lt;/h4&gt;
&lt;p&gt;Lua虚拟机(也可称之为解释器)内部提供了一个接口：用户可以在应用程序中设置一个&lt;span&gt;钩子函数(Hook)&lt;/span&gt;，虚拟机在执行指令码的时候会检查用户是否设置了钩子函数，如果设置了，就调用这个钩子函数。本质上就是设置一个回调函数，因为都是用C语言来实现的，虚拟机中只要把这个钩子函数的地址记住，然后在&lt;span&gt;某些场合&lt;/span&gt;回调这个函数就可以了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ql815naye.hn-bkt.clouddn.com/lua-12.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么，虚拟机在哪些场合回调用户设置的钩子函数呢？&lt;/p&gt;&lt;p&gt;我们在设置Hook函数的时候，可以通过&lt;span&gt;mask参数&lt;/span&gt;来设置回调策略，也就是告诉虚拟机：在什么时候来回调钩子函数。mask参数可以是下列选项的组合操作：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;LUA_MASKCALL：调用一个函数时，就调用一次钩子函数。&lt;/li&gt;
&lt;li&gt;LUA_MASKRET：从一个函数中返回时，就调用一次钩子函数。&lt;/li&gt;
&lt;li&gt;LUA_MASKLINE：执行一行指令时，就回调一次钩子函数。&lt;/li&gt;
&lt;li&gt;LUA_MASKCOUNT：执行指定数量的指令时，就回调一次钩子函数。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;设置钩子函数的基础&lt;span&gt;API原型&lt;/span&gt;如下：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;void lua_sethook (lua_State *L, lua_Hook f, int mask, int count);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;第二个参数f需要指向我们自己定义的钩子函数，这个&lt;span&gt;钩子函数原型&lt;/span&gt;为：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;typedef void (*lua_Hook) (lua_State *L, lua_Debug *ar);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们也可以通过下面即将介绍的&lt;span&gt;调试库&lt;/span&gt;中的函数来设置钩子函数，效果是一样的，因为调试库函数的内部也是调用基础函数。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;debug.sethook ([thread,] hook, mask [, count])&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;再来看一下虚拟机中的相关代码。&lt;br/&gt;当执行完上一条指令，获取下一条指令之后，调用函数&lt;em&gt;luaG_traceexec(lua_State *L)&lt;/em&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void luaG_traceexec (lua_State *L) {
  // 获取mask掩码
  lu_byte mask = L-&amp;gt;hookmask; 
  int counthook = (--L-&amp;gt;hookcount == 0 &amp;amp;&amp;amp; (mask &amp;amp; LUA_MASKCOUNT));
  if (counthook)
    resethookcount(L);
  else if (!(mask &amp;amp; LUA_MASKLINE))
    return; 

  if (counthook)
    luaD_hook(L, LUA_HOOKCOUNT, -1);  // 按指令次数调用钩子函数
  if (mask &amp;amp; LUA_MASKLINE) {
    Proto *p = ci_func(ci)-&amp;gt;p;
    int npc = pcRel(ci-&amp;gt;u.l.savedpc, p);
    int newline = getfuncline(p, npc);
    if (npc == 0 || 
        ci-&amp;gt;u.l.savedpc &amp;lt;= L-&amp;gt;oldpc ||
        newline != getfuncline(p, pcRel(L-&amp;gt;oldpc, p))) 
      luaD_hook(L, LUA_HOOKLINE, newline); // 按行调用钩子函数
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，当mask掩码中包含了LUA_MASKLINE时，就调用函数luaD_hook()，如下代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void luaD_hook (lua_State *L, int event, int line) {
  lua_Hook hook = L-&amp;gt;hook;
  if (hook &amp;amp;&amp;amp; L-&amp;gt;allowhook) { 
    // 为钩子函数准备参数，其中包括了各种调试信息
    lua_Debug ar;
    ar.event = event;
    ar.currentline = line;
    ar.i_ci = ci;
    // 调用钩子函数
    (*hook)(L, &amp;amp;ar);
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;只要进入了用户设置的钩子函数，那么我们就可以在这个函数中&lt;span&gt;为所欲为&lt;/span&gt;了。&lt;/p&gt;&lt;p&gt;比如：获取程序内部信息，读取、修改变量的值，查看函数调用栈信息等等，这就是下面要讲解的内容。&lt;/p&gt;
&lt;h4 id=&quot;2-lua调试库是什么？&quot;&gt;2. Lua调试库是什么？&lt;/h4&gt;
&lt;p&gt;首先说一下Lua中的标准库。&lt;br/&gt;所谓的标准库就是Lua为开发者提供的一些有用的函数，可以提高开发效率，当然我们可以选择不使用标准库，或者只使用部分标准库，这是可以裁剪的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ql815naye.hn-bkt.clouddn.com/lua-11.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里我们只介绍一下基础库、操作系统库和调试库这3个家伙。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;基础库&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;基础库提供了Lua核心函数，如果你不将这个库包含在你的程序中，就需要小心检查程序是否需要自己提供其中一些特性的实现，这个库一般都是需要使用的。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;操作系统库&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这个库提供与操作系统进行交互的功能，例如提供了函数：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;os.date&lt;br/&gt;os.time&lt;br/&gt;os.execute&lt;br/&gt;os.exit&lt;br/&gt;os.getenv&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;调试库&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;先看一下库中提供的几个重要的函数：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;debug.gethook&lt;br/&gt;debug.sethook&lt;br/&gt;debug.getinfo&lt;br/&gt;debug.getlocal&lt;br/&gt;debug.setlocal&lt;br/&gt;debug.setupvalue&lt;br/&gt;debug.traceback&lt;br/&gt;debug.getregistry&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面已经说到，Lua给用户提供了设置钩子的API函数&lt;span&gt;lua_sethook&lt;/span&gt;，用户可以直接调用这个函数，此时传入的钩子函数的定义格式需要满足要求。&lt;/p&gt;
&lt;p&gt;为了简化用户编程，Lua还提供了调试库来帮助用户降低编程难度。调试库其实也就是把基础API函数进行封装了一下，我们以设置钩子函数&lt;span&gt;debug.sethook&lt;/span&gt;为例：&lt;br/&gt;文件&lt;span&gt;ldblib.c&lt;/span&gt;中，定义了调试库支持的所有函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;static int db_sethook (lua_State *L) {
  lua_sethook(L1, func, mask, count);
}

static const luaL_Reg dblib[] = {
  // 其他接口函数都删掉了，只保留这一个来讲解
  {&quot;sethook&quot;, db_sethook},
  {NULL, NULL}
};

// 这个函数用来把调试库中的函数注册到全局变量表中
LUAMOD_API int luaopen_debug (lua_State *L) {
  luaL_newlib(L, dblib);
  return 1;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，&lt;span&gt;调试库的debgu.sethook()函数最终也是调用基础API函数:lua_sethook()&lt;/span&gt;。&lt;/p&gt;&lt;p&gt;在后面的调试器开发讲解中，我就是用debug库来实现一个远程调试器。&lt;/p&gt;
&lt;h4 id=&quot;3-获取程序内部信息&quot;&gt;3. 获取程序内部信息&lt;/h4&gt;
&lt;p&gt;在钩子函数中，可以通过如下API函数还获取程序内部的信息了：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;int lua_getinfo (lua_State *L, const char *what, lua_Debug *ar);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在这个API函数中：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;第二个参数用来告诉虚拟机我们想获取程序的哪些信息&lt;br/&gt;第三个参数用来存储获取到的信息&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;结构体&lt;span&gt;lua_Debug&lt;/span&gt;比较重要，成员变量如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;typedef struct lua_Debug {
  int event;
  const char *name;           /* (n) */
  const char *namewhat;       /* (n) */
  const char *what;           /* (S) */
  const char *source;         /* (S) */
  int currentline;            /* (l) */
  int linedefined;            /* (S) */
  int lastlinedefined;        /* (S) */
  unsigned char nups;         /* (u) 上值的数量 */
  unsigned char nparams;      /* (u) 参数的数量 */
  char isvararg;              /* (u) */
  char istailcall;            /* (t) */
  char short_src[LUA_IDSIZE]; /* (S) */
  /* 私有部分 */
  其它域
} lua_Debug;
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;source：创建这个函数的代码块的名字。 如果 source 以 '@' 打头， 指这个函数定义在一个文件中，而 '@' 之后的部分就是文件名。&lt;/li&gt;
&lt;li&gt;linedefined: 函数定义开始处的行号。&lt;/li&gt;
&lt;li&gt;lastlinedefined: 函数定义结束处的行号。&lt;/li&gt;
&lt;li&gt;currentline: 给定函数正在执行的那一行。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;其他字段可以在参考手册中查询。&lt;br/&gt;例如：如果想知道函数 f 是在哪一行定义的， 你可以使用下列代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;lua_Debug ar;
lua_getglobal(L, &quot;f&quot;);  /* 取得全局变量 'f' */
lua_getinfo(L, &quot;&amp;gt;S&quot;, &amp;amp;ar);
printf(&quot;%d\n&quot;, ar.linedefined);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;同样的，也可以调用调试库debug.getinfo()来达到同样的目的。&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;4-修改程序内部信息&quot;&gt;4. 修改程序内部信息&lt;/h4&gt;
&lt;p&gt;经过上面的讲解，已经看到我们获取程序信息都是通过Lua提供的API函数，或者是利用调试库提供的接口函数来完成的。那么修改程序内部信息也同样如此。&lt;br/&gt;Lua提供了下面这2个API函数来修改函数中的变量：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;修改当前活动记录总的&lt;span&gt;局部变量&lt;/span&gt;的值：&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;const char *lua_setlocal (lua_State *L, const lua_Debug *ar, int n);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;设置闭包&lt;span&gt;上值&lt;/span&gt;的值(上值upvalue就是闭包使用了外层的那些变量)&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;const char *lua_setupvalue (lua_State *L, int funcindex, int n);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;同样的，也可以利用调试库中的&lt;span&gt;debug.setlocal和debug.setupvalue&lt;/span&gt;来完成同样的功能。&lt;/p&gt;
&lt;h4 id=&quot;5-小结&quot;&gt;5. 小结&lt;/h4&gt;
&lt;span&gt;到这里，我们就把Lua语言中与调试有关的机制和代码都理解清楚了，剩下的问题就是如何利用它提供的这些接口，来编写一个类似gdb一样的调试器。&lt;br/&gt;就好比：Lua已经把材料(米、面、菜、肉、佐料)摆在我们的面前了，剩下的就需要我们把这些材料做成一桌美味佳肴。&lt;/span&gt;
&lt;h2 id=&quot;五、lua调试器开发&quot;&gt;五、Lua调试器开发&lt;/h2&gt;
&lt;h4 id=&quot;1-与gdb调试模型做类比&quot;&gt;1. 与gdb调试模型做类比&lt;/h4&gt;
&lt;p&gt;上一篇文章说过，gdb调试模型有两种：&lt;span&gt;本地调试和远程调试&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本地调试&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ql815naye.hn-bkt.clouddn.com/1-1.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;远程调试&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ql815naye.hn-bkt.clouddn.com/1-2.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么，我们也可以按照这个思路来实现两种调试模型，只要把其中的&lt;span&gt;gdb替换成ldb，gdbserver替换成ldbserver&lt;/span&gt;即可。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本地调试&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ql815naye.hn-bkt.clouddn.com/lua-13.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;远程调试&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ql815naye.hn-bkt.clouddn.com/lua-14.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这两种调试模型本质是一样的，只是调试程序和被调试程序是否运行在同一台电脑上而已。&lt;/p&gt;&lt;p&gt;如果是远程调试，ldbserver调用接口函数对被调试程序进行控制，然后把结果通过TCP网络传递给ldb，&lt;span&gt;ldbserver就相当于一个传话筒&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;至于选择实现哪一种调试模型？这个要根据实际场景的需求来决定。&lt;br/&gt;我在这里实现的是&lt;span&gt;远程调试&lt;/span&gt;，因为被调试程序是需要运行在ARM板子(下位机)中的，但是调试器是需要运行在PC电脑上(上位机)的，通过远程调试，只需要把ldbserver和被调试程序放到下位机中运行，ldb嵌入到上位机的集成开发环境(IDE)中运行就可以了。&lt;/p&gt;
&lt;p&gt;另外，远程调试模型同样也可以全部运行在同一台PC电脑中，这个时候ldb与ldbserver之间就是在本机中进行TCP网络连接。&lt;/p&gt;
&lt;p&gt;这里有2个内容需要补充一下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;TCP链接可以直接利用第三方库luasocket。&lt;/li&gt;
&lt;li&gt;ldb与ldbserver之间的通讯协议可以参照gdb与gdbserver之间的协议，也可以自定义。我借鉴了HTTP协议，简化了很多。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;h4 id=&quot;2-ldbserver如何实现&quot;&gt;2. ldbserver如何实现&lt;/h4&gt;
&lt;p&gt;思考一个问题：被调试程序在执行时调用钩子函数，在钩子函数中我们可以做各种&lt;span&gt;调试操作&lt;/span&gt;，但是在执行到钩子函数的最后，是需要返回到被调试程序中的下一行指令码继续执行的，我们不能打断被调试程序的执行序列。&lt;/p&gt;
&lt;p&gt;但是，&lt;span&gt;调试操作&lt;/span&gt;又需要通过TCP连接与上位机进行通信协议的交互，比如：设置断点、查看变量的值、查看函数信息等等。所以，被调试程序的执行与调试器ldbserver的执行是&lt;span&gt;2个并发的执行序列&lt;/span&gt;，可以理解为2个线程在并发执行。我们需要在这2个执行序列之间进行协调，比如：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;ldbserver在等待用户输入指令时(running)，被调试程序应该处于暂停状态(pending)。&lt;/li&gt;
&lt;li&gt;ldbserver接收到用户指令后(eg: run)，自己应该暂停执行(pending)，让被调试程序继续执行(running)。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://ql815naye.hn-bkt.clouddn.com/lua-15.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图中，两条红色箭头表示两个执行序列。这两个执行序列并不是同时在执行的，而是交替执行，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ql815naye.hn-bkt.clouddn.com/lua-16.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么怎么样才能让这2个执行序列交替执行呢？&lt;/p&gt;&lt;p&gt;如果是在C语言中，我们可以通过信号量、互斥锁等各种方法实现，但这是在Lua语言中，应该利用什么机制来实现这个功能？&lt;/p&gt;
&lt;p&gt;柳暗花明又一村！&lt;/p&gt;&lt;p&gt;Lua中提供了&lt;span&gt;协程机制&lt;/span&gt;！&lt;br/&gt;下面这段话是从参考手册中摘抄过来：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;Lua 支持协程，也叫协同式多线程。一个协程在 Lua 中代表了一段独立的执行线程。然而，与多线程系统中的线程的区别在于， 协程仅在显式调用一个让出（yield）函数时才挂起当前的执行。&lt;/li&gt;
&lt;li&gt;调用函数coroutine.create可创建一个协程。&lt;/li&gt;
&lt;li&gt;调用coroutine.resume函数执行一个协程。&lt;/li&gt;
&lt;li&gt;通过调用coroutine.yield使协程暂停执行，让出执行权。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;我们可以让&lt;span&gt;ldbserver&lt;/span&gt;运行在一个&lt;span&gt;协程&lt;/span&gt;中，被调试程序运行在&lt;span&gt;主程序&lt;/span&gt;中。&lt;br/&gt;当虚拟机执行一条被调试程序的指令码之后，调用钩子函数，在钩子函数中通过&lt;span&gt;coroutine.resume&lt;/span&gt;让协程运行，主程序停止。前面说到，ldbserver运行在运行在一个&lt;span&gt;协程&lt;/span&gt;中，此时就可以在ldbserver中利用阻塞函数(例如：TCP 中的receive)，接收用户的调试指令。&lt;/p&gt;
&lt;p&gt;假设用户发送来全速执行指令(run)，ldbserver就调用&lt;span&gt;coroutine.yield&lt;/span&gt;让自己挂起，此时被调试程序所在的主程序就可以继续执行了。&lt;/p&gt;
&lt;p&gt;进行到这里，基本上大功告成！剩下的就是一些代码细节问题了。&lt;/p&gt;
&lt;h4 id=&quot;3-ldb如何实现&quot;&gt;3. ldb如何实现&lt;/h4&gt;
&lt;p&gt;这部分就比较简单了，从功能上来说包括3部分内容：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;与ldbserver之间建立TCP连接。&lt;/li&gt;
&lt;li&gt;读取调试人员输入的指令，发送给ldbserver。&lt;/li&gt;
&lt;li&gt;接收ldbserver发来的信息，显示给调试人员。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;可以在调试终端中手动输入、显示调试信息，也可以把ldb嵌入到一个可视化的编辑工具中，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;local function print_commands()
    print(&quot;setb &amp;lt;file&amp;gt; &amp;lt;line&amp;gt;    -- sets a breakpoin&quot;)
    print(&quot;step                  -- run one line, stepping into function&quot;)
    print(&quot;next                  -- run one line, stepping over function&quot;)
    print(&quot;goto &amp;lt;line&amp;gt;           -- goto line in a function&quot;)
    // 其他指令
end
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;六、调试指令举例&quot;&gt;六、调试指令举例&lt;/h2&gt;
&lt;h4 id=&quot;1-break指令的实现&quot;&gt;1. break指令的实现&lt;/h4&gt;
&lt;h6 id=&quot;（1）设置钩子函数&quot;&gt;（1）设置钩子函数&lt;/h6&gt;
&lt;p&gt;ldbserver通过调试库的debug.sethook函数，设置了一个钩子函数，调用参数是：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;debug.sethook(my_hook, &quot;lcr&quot;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;第二个参数&quot;lcr&quot;的含义是：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;'c': 每当 Lua 调用一个函数时，调用钩子。&lt;br/&gt;'r': 每当 Lua 从一个函数内返回时，调用钩子。&lt;br/&gt;'l': 每当 Lua 进入新的一行时，调用钩子。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也即是说：虚拟机进入一个函数、从一个函数返回、每执行一行代码，都调用一次钩子函数。注意：这里的一行指定是被调试程序中的一行Lua代码，而不是二进制文件中的一行指令码，一行Lua代码可能被会编译生成多行指令码。&lt;/p&gt;
&lt;p&gt;这里还有一点需要注意：&lt;span&gt;钩子函数虽然是定义在用户代码中，但是它是被虚拟机调用的，也就是说钩子函数是处于主程序的执行序列中。&lt;/span&gt;&lt;/p&gt;
&lt;h6 id=&quot;（2）设置断点&quot;&gt;（2）设置断点&lt;/h6&gt;
&lt;p&gt;ldb向ldbserver发送设置断点的指令：setb test.lua 10，即：在test.lua文件的第10行设置一个断点，ldbserver接收到指令后，在内存中记录这个信息(文件名-行号)。&lt;/p&gt;
&lt;h6 id=&quot;（3）捕获断点&quot;&gt;（3）捕获断点&lt;/h6&gt;
&lt;p&gt;虚拟机在调用钩子函数时，传入两个参数(注意：钩子函数是被虚拟机调用的，所以它是处于主程序的执行序列中)，&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;local function my_hook(event, line)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在钩子函数中，查找这个line是否被用户设置为断点，如果是那么就通过coroutine.resume让主程序暂停，让协程中的ldbserver执行。此时，ldbserver就可以在TCP网络上继续等待ldb发来的下一个调试指令。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ql815naye.hn-bkt.clouddn.com/lua-17.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;2-next指令的实现&quot;&gt;2. next指令的实现&lt;/h4&gt;
&lt;p&gt;next指令与step指令类似，区别在于当下一条指令是一个函数调用时:&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;step指令: 进入到函数内部。&lt;br/&gt;next指令: 不进入函数内部，而是直接把这个函数执行完。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;next指令的实现主要依赖于钩子函数的第一个参数event，上面在设置钩子函数的时候，告诉虚拟机在3种条件下调用钩子函数，重新贴一下：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;'c': 每当 Lua 调用一个函数时，调用钩子&lt;br/&gt;'r': 每当 Lua 从一个函数内返回时，调用钩子&lt;br/&gt;'l': 每当 Lua 进入新的一行时，调用钩子&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在进入钩子函数之后，event参数会告诉我们：为什么会调用钩子函数。代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function my_hook(event, line)
    if event == &quot;call&quot; then
        // 进入了一个函数
        func_level = func_level + 1
    elseif event == &quot;return&quot; then
        // 从一个函数返回
        func_level = func_level - 1
    else
        // 执行完一行代码
    end
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以就可以利用event参数来记录进入、退出函数层数，然后在钩子函数中判断：&lt;span&gt;是否需要暂停主程序，把执行的机会让给协程&lt;/span&gt;。&lt;/p&gt;
&lt;h4 id=&quot;3-goto指令的实现&quot;&gt;3. goto指令的实现&lt;/h4&gt;
&lt;p&gt;在调试过程中，如果我们想跳过当前执行函数中的某几行，可以发送goto指令,被调试程序就从当前停止的位置直接跳转到goto指令中设置的那行代码。&lt;/p&gt;
&lt;p&gt;目前goto指令有一个限制:&lt;/p&gt;&lt;p&gt;因为Lua虚拟机中的所有代码都是以函数为单位的，通过函数调用栈把所有的代码串接在一起，因此只能goto到当前函数内的指定行。&lt;/p&gt;
&lt;p&gt;这部分功能Lua源码中并没有提供，需要扩展调试库的功能。核心步骤就是：&lt;span&gt;强制把虚拟机中的PC指针设置为指定的那行Lua代码所对应的第一个指令码&lt;/span&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;ar-&amp;gt;i_ci-&amp;gt;u.l.savedpc = cl-&amp;gt;p-&amp;gt;code + 需要跨过的指令码&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;ar变量就是调试库为我们准备的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;const lua_Debug *ar&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;(&lt;span&gt;如果你能跟着思路看到这里，我心里时非常非常的感激，能容忍我这么唠叨这么久。到这里我想表达的内容也差不多结束了，后面两个模块如果有兴趣的话可以稍微了解一下，不是重点。&lt;/span&gt;)&lt;/p&gt;
&lt;h2 id=&quot;七、其他重要的模块&quot;&gt;七、其他重要的模块&lt;/h2&gt;
&lt;p&gt;这部分先空着，如果有小伙伴想要详细了解的话，请在公众号(IOT物联网小镇)中留言给我，单独整理成文档。&lt;br/&gt;比较重要的内容包括：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;标准库的加载过程&lt;/li&gt;
&lt;li&gt;函数调用栈&lt;/li&gt;
&lt;li&gt;同时调试多个程序&lt;/li&gt;
&lt;li&gt;如何处理中断信号&lt;/li&gt;
&lt;li&gt;如何处理中断信号嵌套问题&lt;/li&gt;
&lt;li&gt;如何添加自己的库&lt;/li&gt;
&lt;li&gt;如何同时调试多个程序&lt;/li&gt;
&lt;li&gt;其他指令的实现机制：查看、修改变量，查看函数调用栈，多个被调试程序的切换等等。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;h2 id=&quot;八、调试操作步骤&quot;&gt;八、调试操作步骤&lt;/h2&gt;
&lt;p&gt;关于实际操作步骤，用文档表达起来比较费劲，全部是黑乎乎的终端窗口。计划录一个60分钟左右的视频，把上面提到的内容都操作演示一遍，这样效果会更好一下。有兴趣的话可以在B站搜一下我的ID(&lt;span&gt;道哥分享&lt;/span&gt;)。&lt;br/&gt;内容主要包括：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;在Linux平台下：编译和调试步骤。&lt;/li&gt;
&lt;li&gt;Windows平台下：编译和调试步骤。&lt;/li&gt;
&lt;li&gt;简单的图形调试界面，就是把ldb嵌入到IDE中。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;hr/&gt;&lt;center&gt;&lt;span&gt;【原创声明】&lt;/span&gt;&lt;/center&gt;
&lt;br/&gt;&amp;gt; 作者：道哥(公众号: &lt;span&gt;IOT物联网小镇&lt;/span&gt;)&lt;br/&gt;&amp;gt; 知乎：道哥&lt;br/&gt;&amp;gt; B站：道哥分享&lt;br/&gt;&amp;gt; 掘金：道哥分享&lt;br/&gt;&amp;gt; CSDN：道哥分享&lt;p&gt;如果觉得文章不错，请&lt;span&gt;转发、分享&lt;/span&gt;给您的朋友。&lt;/p&gt;&lt;p&gt;我会把&lt;span&gt;十多年嵌入式开发中的项目实战经验&lt;/span&gt;进行总结、分享，相信不会让你失望的！&lt;/p&gt;
&lt;center&gt;长按下图二维码关注，每篇文章都有干货。
&lt;p&gt;&lt;img src=&quot;http://ql815naye.hn-bkt.clouddn.com/IotTown_258.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/center&gt;
&lt;br/&gt;&lt;span&gt;转载：欢迎转载，但未经作者同意，必须保留此段声明，必须在文章中给出原文连接。&lt;/span&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;推荐阅读&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;[1] &lt;a href=&quot;https://mp.weixin.qq.com/s/oY2pF5ilk8UCq09022Tt6w&quot; target=&quot;_blank&quot;&gt;原来gdb的底层调试原理这么简单&lt;/a&gt;&lt;br/&gt;[2] &lt;a href=&quot;https://mp.weixin.qq.com/s/ZAdiynT-OAE1HscPrj4Sew&quot; target=&quot;_blank&quot;&gt;生产者和消费者模式中的双缓冲技术&lt;/a&gt;&lt;br/&gt;[3] &lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzA3MzAwODYyNQ==&amp;amp;mid=2247483796&amp;amp;idx=1&amp;amp;sn=334fa37b92aa4a7f6048392e83a52322&amp;amp;chksm=9f14d50aa8635c1c8cfe9fd11bb9b6e0703a284b32f74a0147f700db572cfb6432e1b6ec5afe&amp;amp;token=1587429588&amp;amp;lang=zh_CN#rd&quot; target=&quot;_blank&quot;&gt;C_C++_静态库_动态库的制作和使用&lt;/a&gt;&lt;br/&gt;[4] &lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzA3MzAwODYyNQ==&amp;amp;mid=2247483783&amp;amp;idx=1&amp;amp;sn=db1349224644095bb623f1cfc480355b&amp;amp;chksm=9f14d519a8635c0f98ff0e24dfb6dcbf474d527b89a4a8ec79b59fa60944ca72b0d933cb7a93&amp;amp;token=1587429588&amp;amp;lang=zh_CN#rd&quot; target=&quot;_blank&quot;&gt;利用C可变参数和宏定义来实现自己的日志系统&lt;/a&gt;&lt;br/&gt;[5] &lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzA3MzAwODYyNQ==&amp;amp;mid=2247483768&amp;amp;idx=1&amp;amp;sn=32698756ac610042d67c0ff43f322d8e&amp;amp;chksm=9f14d5e6a8635cf08581350460bd55c0623d81544000cae754731ca6c6882b29945f74e89474&amp;amp;token=1587429588&amp;amp;lang=zh_CN#rd&quot; target=&quot;_blank&quot;&gt;C与C++混合编程&lt;/a&gt;&lt;br/&gt;[6] &lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzA3MzAwODYyNQ==&amp;amp;mid=2247483746&amp;amp;idx=1&amp;amp;sn=666a7a9777a9a5fd4eea76ec6d961b31&amp;amp;chksm=9f14d5fca8635ceaf63bf1ad0ef76f52dcff9162079a8a8c82a9ad048ebfa3908cd30a9c8ba2&amp;amp;token=1587429588&amp;amp;lang=zh_CN#rd&quot; target=&quot;_blank&quot;&gt;拿来即用：用C+JS结构来处理JSON数据&lt;/a&gt;&lt;br/&gt;[7] &lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzA3MzAwODYyNQ==&amp;amp;mid=2247483731&amp;amp;idx=1&amp;amp;sn=32f406dee7eafcc43783c61139b0b085&amp;amp;chksm=9f14d5cda8635cdb3135254448a16f253c53f00de52daf62dfb90907a4b4bb3c1233abfc0361&amp;amp;token=1587429588&amp;amp;lang=zh_CN#rd&quot; target=&quot;_blank&quot;&gt;拿来即用：分享一个检查内存泄漏的小工具&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 18 Dec 2020 00:42:00 +0000</pubDate>
<dc:creator>sewain</dc:creator>
<og:description>这是道哥的第008篇原创 一、前言 上篇文章我们聊了gdb的底层调试机制，明白了gdb是利用操作系统提供的系统信号来调试目标程序的。很多朋友私下留言了，看到能帮助到大家，我心里还是很开心的，其实这也是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sewain/p/14153146.html</dc:identifier>
</item>
<item>
<title>提升网站性能的五种方式，希望你也知道 - 葡萄城技术团队</title>
<link>http://www.cnblogs.com/powertoolsteam/p/14153132.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/powertoolsteam/p/14153132.html</guid>
<description>&lt;div readability=&quot;6.5714285714286&quot;&gt;
&lt;blockquote readability=&quot;6.5714285714286&quot;&gt;
&lt;p align=&quot;left&quot;&gt;转载请注明出处：&lt;a href=&quot;https://www.grapecity.com.cn/&quot;&gt;葡萄城官网&lt;/a&gt;，葡萄城为开发者提供专业的开发工具、解决方案和服务，赋能开发者。&lt;br/&gt;原文出处：https://blog.bitsrc.io/5-common-mistakes-developers-do-that-affect-page-load-time-5a49b0e46f6b&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;如果您的网站在用户访问时的加载时间需要很久，那么，这篇文章兴许能为您的优化工作带来一些启发。不过即便没能帮您解决你的问题，您也能了解到影响了网站加载时间的几种常见错误是什么。&lt;/p&gt;
&lt;h2&gt;为什么页面加载时间这个指标很重要？&lt;/h2&gt;
&lt;p&gt;页面的加载时间直接影响到了用户对网站性能的直观感受。有调研数据表示，&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;一旦页面加载时长超过3秒，那么将会有一半的访问用户在等待中而流失。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;搜索引擎排名&lt;/strong&gt; — 页面加载时间是搜索引擎在搜索结果中对你的网站进行排名的重要依据之一。因此，网页的加载时间会影响用户在Web上查找该网页的难易程度。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;转化率&lt;/strong&gt; — 页面加载越快，用户的参与度就越高。网站速度慢，显而易见地会导致转化率下降。如果您的网页加载时间太长，执行Call-To-Action(CTA) 将消耗大量的 时间，这段期间用户的耐心和积极性会被消磨，最终关掉您的网站，而不购买您的产品或使用您提供的服务。&lt;/li&gt;
&lt;li&gt;用户体验 — 网站加载时间越长，用户就越满意。因此，客户的留存率和再次访问比例会更高。&lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;left&quot;&gt;让我们看看几个基于&lt;a href=&quot;https://blog.hubspot.com/marketing/page-load-time-conversion-rates&quot;&gt;HubSpot&lt;/a&gt;所做研究的示例：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果Yahoo将页面加载时间减少0.4秒，流量可能会增加9%。&lt;/li&gt;
&lt;li&gt;页面慢1秒可能会使亚马逊每年损失16亿美元的销售额。&lt;/li&gt;
&lt;li&gt;Bing搜索的2秒延迟将导致每位访客的收入损失4.3%，点击量减少3.75%，查询量下降1.8%。&lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;left&quot;&gt;根据上面的数据，您可以看出页面加载时间对您的网站有多么重要。&lt;/p&gt;
&lt;h2&gt;影响页面加载时间的因素以及优化技巧&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;影响页面加载时间的因素很多，在这些错误中，我列出了我在建立网站时遇到的比较有代表性的五大错误。&lt;/p&gt;
&lt;h3&gt;1.    大量的HTTP请求&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;每当浏览器需要从Web服务器获取文件、页面或图像时，都会发出一次HTTP请求，之后您可以通过Chrome“开发人员工具”中的“Network”选项卡去监测应用程序是发出了哪些网络请求，哪些请求比较耗时等信息。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;一般浏览器通常将同时发出的HTTP请求数限制在4-8个之间。因此，当并发请求数量较多时，会产生较长的等待延迟。Yahoo所做的研究表明，您的应用程序加载时间的80%依赖于HTTP请求。减少HTTP请求的数量会增加页面加载时间。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;您可以通过下面的方式来减少Web应用的HTTP请求总量：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;合并CSS/JS文件&lt;/strong&gt; — 您可以尝试将CSS文件和JS文件分别合并为同一个文件，这样减少了请求，也无需从服务器检索多个文件。由于所有CSS文件都是渲染分块的，因此减少CSS文件将大大缩短页面加载时间。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内容按需加载&lt;/strong&gt; — 不一次加载应用程序的所有图像，而是只在需要时加载它们。这种方法被称为延迟加载或按需加载。当用户到达站点时，您可以在用户滚动到该特定位置时才加载图像，而不是在点击时就一股脑全部加载。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;启用浏览器缓存&lt;/strong&gt; — 允许缓存静态图片或网站的内容，这些内容不会经常变化。当用户第二次访问网站时，缓存可以加载这些内容，而无需向服务器发送新的HTTP请求。这使得内容的加载速度更快。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;服务器支持HTTP/2&lt;/strong&gt; — 使用HTTP/2，从浏览器到服务器只需要建立一个连接就可以加载一个网站，并且允许同时多个请求。这比为每个资源创建新连接要高效得多。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;2. 没有使用CDN&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;如果您的网站没有启用CDN，则当用户的物理位置远离服务器时，加载时间会增加。这些延迟会随着距离的增加而变得更明显，并且会影响到对服务器的所有HTTP请求。使用CDN可以缩短页面加载时间。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;CDN&lt;/strong&gt;&lt;strong&gt;是什么？&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;CDN的全称是Content Delivery Network，即内容分发网络。CDN是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户可以就近获取所需内容。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;使用CDN将使用户能够从距离其位置最近的服务器获取网页所需的资源。CDN中的服务器分布在不同的地理位置。所以使用这种CDN是改善应用程序加载时间的有效方法之一。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;例如，如果您的Web服务器位于加利福尼亚州，如果您部署了CDN，您的访客访问网络拓补图可能是下面的样子。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/139239/202012/139239-20201218083020999-302792824.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;大多数CDN服务都拥有自己的网络骨干，与互联网相比，它们可以提供更高的服务质量，更少的数据包率及更快的加载速度等有点。缺点，就是贵。&lt;/p&gt;
&lt;h3&gt;3.文件大小和页面大小&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;从Web服务器上加载大尺寸文件或加载页面尺寸较大时将耗费大量时间，所以可能会在为了获取几个这样大的文件而使页面加载时间变长。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/139239/202012/139239-20201218083040233-493129048.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;



&lt;p align=&quot;left&quot;&gt;通过启用压缩是减小HTTP请求文件大小、缩短页面加载时间的常用方式。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;常见的压缩方式有两种：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;第一种方式是Gzip，Gzip可以定位文件中的类似代码，并暂时替换它们，使文件变小。目前，大多数Web服务器都支持Gzip压缩。对HTML或CSS文件启用压缩通常可以节省约50%或70%的文件大小，从而减少页面加载时间和使用的带宽。您可以通过减小应用程序中使用的图像的大小来进一步减少页面加载时间。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;另一种压缩方案称为Brotli，据官方介绍压缩比较gzip要高20%~30%，并且执行效率更高效，具体的因为我这没有测试，所以无法佐证，您可以根据您的实际情况来考虑。&lt;/p&gt;
&lt;h3&gt;4.同时加载所有资源&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;同时加载所有HTML、CSS和JS文件将增加页面加载时间，因为在加载所有这些资源之前，页面渲染的流程将被阻止。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;延迟JavaScript加载是一种在加载其他元素之后加载大型JS文件的机制。此方法可确保加载页面内容时不会因加载大型JS文件而受到影响。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;如果您有一个HTML站点，则需要在&amp;lt;/body&amp;gt;标记之前调用外部JS文件(defer.js)。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
   function downloadJSAtOnload() {
      var element = document.createElement(&quot;script&quot;);
      element.src = &quot;defer.js&quot;;
      document.body.appendChild(element);
  }
  if (window.addEventListener)
    window.addEventListener(&quot;load&quot;, downloadJSAtOnload, false);
  else if (window.attachEvent)
    window.attachEvent(&quot;onload&quot;, downloadJSAtOnload);
  else &lt;br/&gt;window.onload = downloadJSAtOnload;
&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;上面的代码是讲，“等待整个文档加载，然后再加载外部defer.js文件。”&lt;/p&gt;
&lt;h3&gt;5.大量的重定向&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;一般情况下，我们使用重定向来处理移动或删除的页面，以避免用户访问时出现错误。但是，更多的重定向意味着更多的HTTP请求。这会极大地增加页面加载时间。谷歌建议网站所有者取消重定向，以缩短加载时间，特别是在移动优先的网站上。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;您可以使用类似网站爬取工具来获得网站中的所有重定向请求。通过分析这一点，您可以掌握并清除其中不必要的重定向。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;一般，重定向分为两种类型：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;服务器端重定向&lt;/strong&gt; — 快速且可缓存。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;客户端重定向&lt;/strong&gt; — 速度慢且不可缓存。&lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;left&quot;&gt;避免使用你的页面使用客户端重定向，同时将服务器端重定向保持在最低限度内，从而优化网页加载时间。&lt;/p&gt;
&lt;h2&gt;结论&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;一个执行、加载速度快的站点相信对站长和用户而言都是有益的，我希望这篇文章能让您对页面加载时间的重要性有足够的信心。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;如果您正在考虑提升您的网站性能，我有一些工具可以分享给您，比如Google Pagespeed Insights，Pingdom，YSlow等。这些工具可以提供完整的报告让您深入了解你的网站的短板。希望您的网站也可以获得更好的用户体验。&lt;/p&gt;

</description>
<pubDate>Fri, 18 Dec 2020 00:34:00 +0000</pubDate>
<dc:creator>葡萄城技术团队</dc:creator>
<og:description>转载请注明出处：葡萄城官网，葡萄城为开发者提供专业的开发工具、解决方案和服务，赋能开发者。 原文出处：https://blog.bitsrc.io/5-common-mistakes-develope</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/powertoolsteam/p/14153132.html</dc:identifier>
</item>
<item>
<title>DRF对Django请求响应做了技术升级 - dongfanger</title>
<link>http://www.cnblogs.com/df888/p/14150449.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/df888/p/14150449.html</guid>
<description>&lt;p&gt;Django视图是用来处理请求和响应的，Django默认是按Form和Template来设计的，如果要处理以JSON格式为主的RESTful API，那么就需要对Django请求和响应的处理代码进行优化改造，本文就来介绍DRF在这一部分的技术升级。&lt;/p&gt;

&lt;p&gt;DRF把Django的&lt;code&gt;HttpRequest&lt;/code&gt;扩展成了&lt;code&gt;Request&lt;/code&gt;：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202012/1629545-20201217163957545-399412111.png&quot;/&gt;&lt;/center&gt;
&lt;p&gt;其中最核心的属性是&lt;code&gt;request.data&lt;/code&gt;，它和&lt;code&gt;request.POST&lt;/code&gt;的区别如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;request.POST  # 只处理表单（Form）数据，只支持POST方法
request.data  # 处理任何数据，支持POST、PUT、PATCH方法
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;DRF的&lt;code&gt;Response&lt;/code&gt;继承自Django的&lt;code&gt;django.template.response.SimpleTemplateResponse&lt;/code&gt;：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202012/1629545-20201217163957818-1237127118.png&quot;/&gt;&lt;/center&gt;
&lt;p&gt;&lt;code&gt;Response&lt;/code&gt;可以根据客户端的请求render合适的content type：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;return Response(data)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我摘取了&lt;code&gt;rendered_content()&lt;/code&gt;函数的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;@property
def rendered_content(self):
    renderer = getattr(self, 'accepted_renderer', None)
    accepted_media_type = getattr(self, 'accepted_media_type', None)
    context = getattr(self, 'renderer_context', None)

    assert renderer, &quot;.accepted_renderer not set on Response&quot;
    assert accepted_media_type, &quot;.accepted_media_type not set on Response&quot;
    assert context is not None, &quot;.renderer_context not set on Response&quot;
    context['response'] = self

    media_type = renderer.media_type
    charset = renderer.charset
    content_type = self.content_type

    if content_type is None and charset is not None:
        content_type = &quot;{}; charset={}&quot;.format(media_type, charset)
    elif content_type is None:
        content_type = media_type
    self['Content-Type'] = content_type

    ret = renderer.render(self.data, accepted_media_type, context)
    if isinstance(ret, str):
        assert charset, (
            'renderer returned unicode, and did not specify '
            'a charset value.'
        )
        return ret.encode(charset)

    if not ret:
        del self['Content-Type']

    return ret
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;如果在代码中直接写数字形式的状态码如&lt;code&gt;400&lt;/code&gt;，是不容易阅读的，于是DRF提供了标识符如&lt;code&gt;HTTP_400_BAD_REQUEST&lt;/code&gt;来替代。我列一些常见的状态码标识符：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;HTTP_200_OK = 200
HTTP_201_CREATED = 201
HTTP_204_NO_CONTENT = 204
HTTP_400_BAD_REQUEST = 400
HTTP_401_UNAUTHORIZED = 401
HTTP_403_FORBIDDEN = 403
HTTP_404_NOT_FOUND = 404
HTTP_405_METHOD_NOT_ALLOWED = 405
HTTP_500_INTERNAL_SERVER_ERROR = 500
HTTP_502_BAD_GATEWAY = 502
HTTP_503_SERVICE_UNAVAILABLE = 503
HTTP_504_GATEWAY_TIMEOUT = 504
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;全部的状态码标识符可以在&lt;code&gt;rest_framework.status&lt;/code&gt;模块中看到。&lt;/p&gt;

&lt;p&gt;DRF对API视图做了2个封装：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;@api_view&lt;/code&gt;用于函数视图。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;APIView&lt;/code&gt;用于类视图。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;它们提供了一些新功能，比如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;检查请求是&lt;code&gt;Request&lt;/code&gt;对象&lt;/li&gt;
&lt;li&gt;添加上下文到&lt;code&gt;Response&lt;/code&gt;对象&lt;/li&gt;
&lt;li&gt;返回请求错误如&lt;code&gt;405 Method Not Allowed&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;当&lt;code&gt;request.data&lt;/code&gt;格式有误时，抛出&lt;code&gt;ParseError&lt;/code&gt;异常&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接着就用上面这几个新实现对我们之前写的&lt;code&gt;snippets/views.py&lt;/code&gt;进行改造：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from rest_framework import status
from rest_framework.decorators import api_view
from rest_framework.response import Response
from snippets.models import Snippet
from snippets.serializers import SnippetSerializer


@api_view(['GET', 'POST'])
def snippet_list(request):
    &quot;&quot;&quot;
    List all code snippets, or create a new snippet.
    &quot;&quot;&quot;
    if request.method == 'GET':
        snippets = Snippet.objects.all()
        serializer = SnippetSerializer(snippets, many=True)
        return Response(serializer.data)

    elif request.method == 'POST':
        serializer = SnippetSerializer(data=request.data)
        if serializer.is_valid():
            serializer.save()
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

    
@api_view(['GET', 'PUT', 'DELETE'])
def snippet_detail(request, pk):
    &quot;&quot;&quot;
    Retrieve, update or delete a code snippet.
    &quot;&quot;&quot;
    try:
        snippet = Snippet.objects.get(pk=pk)
    except Snippet.DoesNotExist:
        return Response(status=status.HTTP_404_NOT_FOUND)

    if request.method == 'GET':
        serializer = SnippetSerializer(snippet)
        return Response(serializer.data)

    elif request.method == 'PUT':
        serializer = SnippetSerializer(snippet, data=request.data)
        if serializer.is_valid():
            serializer.save()
            return Response(serializer.data)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

    elif request.method == 'DELETE':
        snippet.delete()
        return Response(status=status.HTTP_204_NO_CONTENT)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;改动点有这些，添加了&lt;code&gt;@api_view&lt;/code&gt;，如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;@api_view(['GET', 'POST'])
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用了状态码标识符，如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;status.HTTP_404_NOT_FOUND
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用&lt;code&gt;request.data&lt;/code&gt;替代了 &lt;code&gt;data = JSONParser().parse(request)&lt;/code&gt;，如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt; serializer = SnippetSerializer(data=request.data)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用&lt;code&gt;Response()&lt;/code&gt;替代了&lt;code&gt;JsonResponse()&lt;/code&gt;，如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;return Response(serializer.data, status=status.HTTP_201_CREATED)
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;request.data&lt;/code&gt;和&lt;code&gt;Response()&lt;/code&gt;能根据请求的JSON自动处理content type。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;既然DRF能自动处理content type，那么也可以给URL指定具体的后缀格式，比如&lt;code&gt;http://example.com/api/items/4.json&lt;/code&gt;。具体添加步骤是，先给view增加1个可选参数&lt;code&gt;format&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;def snippet_list(request, format=None):
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;def snippet_detail(request, pk, format=None):
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再更新&lt;code&gt;snippets/urls.py&lt;/code&gt;，添加&lt;code&gt;format_suffix_patterns&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from django.urls import path
from rest_framework.urlpatterns import format_suffix_patterns
from snippets import views

urlpatterns = [
    path('snippets/', views.snippet_list),
    path('snippets/&amp;lt;int:pk&amp;gt;', views.snippet_detail),
]

urlpatterns = format_suffix_patterns(urlpatterns)
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这并不是必须的，实际上也无需这么做。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;http http://127.0.0.1:8000/snippets/

HTTP/1.1 200 OK
...
[
  {
    &quot;id&quot;: 1,
    &quot;title&quot;: &quot;&quot;,
    &quot;code&quot;: &quot;foo = \&quot;bar\&quot;\n&quot;,
    &quot;linenos&quot;: false,
    &quot;language&quot;: &quot;python&quot;,
    &quot;style&quot;: &quot;friendly&quot;
  },
  {
    &quot;id&quot;: 2,
    &quot;title&quot;: &quot;&quot;,
    &quot;code&quot;: &quot;print(\&quot;hello, world\&quot;)\n&quot;,
    &quot;linenos&quot;: false,
    &quot;language&quot;: &quot;python&quot;,
    &quot;style&quot;: &quot;friendly&quot;
  }
]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;跟之前的结果一样。再分别用form和json试试：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# POST using form data
http --form POST http://127.0.0.1:8000/snippets/ code=&quot;print(123)&quot;

{
  &quot;id&quot;: 3,
  &quot;title&quot;: &quot;&quot;,
  &quot;code&quot;: &quot;print(123)&quot;,
  &quot;linenos&quot;: false,
  &quot;language&quot;: &quot;python&quot;,
  &quot;style&quot;: &quot;friendly&quot;
}

# POST using JSON
http --json POST http://127.0.0.1:8000/snippets/ code=&quot;print(456)&quot;

{
    &quot;id&quot;: 4,
    &quot;title&quot;: &quot;&quot;,
    &quot;code&quot;: &quot;print(456)&quot;,
    &quot;linenos&quot;: false,
    &quot;language&quot;: &quot;python&quot;,
    &quot;style&quot;: &quot;friendly&quot;
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;DRF提供了可视化的API HTML文档，把API URL在浏览器中打开即可看到：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202012/1629545-20201217163958034-1145636582.png&quot;/&gt;&lt;/center&gt;

&lt;p&gt;最近测试开发和业务测试的话题频频出现在TesterHome论坛上，讨论激烈，我觉得从公司的角度来说，只会关注员工的产出有没有给公司带来价值，无论技术多厉害，不能创造价值终究是会优先被裁的。从个人的角度来说，只会业务测试的出路肯定是会越来越窄的，努力提高技术，辅助业务测试，同时提升效率，才是更好的发展方向。千万要谨慎选择只做纯测试工具，要依托于业务，让技术落地，在业务中发挥技术的价值，产生从业务到技术，从技术到业务的良好循环。当然，会技术是个大前提，对技术的学习不能停，比如Django REST framework。&lt;/p&gt;
&lt;blockquote readability=&quot;0.90909090909091&quot;&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.django-rest-framework.org/tutorial/2-requests-and-responses/&quot; target=&quot;_blank&quot;&gt;https://www.django-rest-framework.org/tutorial/2-requests-and-responses/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 17 Dec 2020 23:32:00 +0000</pubDate>
<dc:creator>dongfanger</dc:creator>
<og:description>Django视图是用来处理请求和响应的，Django默认是按Form和Template来设计的，如果要处理以JSON格式为主的RESTful API，那么就需要对Django请求和响应的处理代码进行优</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/df888/p/14150449.html</dc:identifier>
</item>
<item>
<title>阅站无数！不过我只推荐下面这些 - 程序员cxuan</title>
<link>http://www.cnblogs.com/cxuanBlog/p/14153069.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cxuanBlog/p/14153069.html</guid>
<description>&lt;blockquote readability=&quot;4&quot;&gt;
&lt;p&gt;我把自己以往的文章汇总成为了 Github ，欢迎各位大佬 star&lt;br/&gt;&lt;a href=&quot;https://github.com/crisxuan/bestJavaer&quot; target=&quot;_blank&quot;&gt;https://github.com/crisxuan/bestJavaer&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;程序员的工作和日常生活非常的枯燥，这里给大家推荐一些程序员经常使用的网站，也是我经常上的一些网站，我将会从多个角度、多个层面为你整理归纳这些网站和论坛&lt;/p&gt;
&lt;h2 id=&quot;项目类&quot;&gt;项目类&lt;/h2&gt;
&lt;p&gt;项目是一个面试官非常看重的点，也是拓展视野、挖掘轮子一个的地方，下面就为你推荐几个程序员都应该 mark 的项目类网站。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;Github&lt;/code&gt; 代码托管 &lt;a href=&quot;https://github.com/&quot; target=&quot;_blank&quot;&gt;https://github.com&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;作为开源代码库以及版本控制系统，Github 拥有140多万开发者用户。随着越来越多的应用程序转移到了云上，Github 已经成为了管理软件开发以及发现已有代码的首选方法。代码托管必备。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/12/16/r1RNE6.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Github 也有非常多好的项目可以推荐，比如我自己的 github (逃了)&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/crisxuan/bestJavaer&quot; target=&quot;_blank&quot;&gt;https://github.com/crisxuan/bestJavaer&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;还有其他非常多优秀的 Github ，比如 &lt;strong&gt;CS-notes、JavaGuide、mall 商城项目&lt;/strong&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;&lt;code&gt;码云代码托管平台&lt;/code&gt; &lt;a href=&quot;https://gitee.com/&quot; target=&quot;_blank&quot;&gt;Gitee | Software Development and Collaboration Platform&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;码云托管平台是中国的，之所以国内自己开发了一个码云平台，是因为 github 涉及到 fq，你懂的，而且码云是开源中国的托管平台，会定期评选一些优秀的项目，你不可错过！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/12/16/r1Ra4O.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;&lt;code&gt;Gitlab&lt;/code&gt; &lt;a href=&quot;https://about.gitlab.com/&quot; target=&quot;_blank&quot;&gt;https://about.gitlab.com/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;对于有些人，提到GitHub就会自然的想到Gitlab,Gitlab支持无限的公有项目和私有项目。其首页截图如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/12/16/r1RYHx.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;&lt;code&gt;coding.net&lt;/code&gt; &lt;a href=&quot;https://coding.net&quot; target=&quot;_blank&quot;&gt;https://coding.net&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;谈到 coding.net,首先必须提的是速度快，功能与开源中国相似，同样一个账号最多可以创建 1000 个项目，也支持任务的创建等&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/12/16/r1RUUK.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;博客类&quot;&gt;博客类&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;博客园&lt;/code&gt; &lt;a href=&quot;http://www.cnblogs.com/&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/12/16/r1RwCD.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;博客园吸引了很多IT技术精英，把这里当作自己的网上家园，每天在这里分享着精彩的原创内容，也许他们看重的不是华丽的外表、诱人的虚名，而是纯净、专注、对技术人员的理解。&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;&lt;code&gt;CSDN&lt;/code&gt; &lt;a href=&quot;https://www.csdn.net/&quot; target=&quot;_blank&quot;&gt;https://www.csdn.net/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/12/16/r1RyDI.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;中国专业IT社区CSDN (Chinese Software Developer Network) 创立于1999年，致力于为中国软件开发者提供知识传播、在线学习、职业发展等服务。中国最大、最具专业的博客平台，同时也是质量最高的博客平台&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;&lt;code&gt;掘金&lt;/code&gt; &lt;a href=&quot;https://juejin.im/&quot; target=&quot;_blank&quot;&gt;https://juejin.im/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/12/16/r1R08e.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;掘金现在被字节跳动收购了，内容审核变得越来越严格，也涌现了很多大佬，他们写的文章非常帮，强烈推荐大家每天逛一逛，博客内容都是经过层层筛选的，非常值得一看&lt;/p&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;&lt;code&gt;思否&lt;/code&gt; &lt;a href=&quot;https://segmentfault.com/&quot; target=&quot;_blank&quot;&gt;https://segmentfault.com/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/12/16/r1RBgH.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;思否上面有很多大佬，不得不说思否的界面做的非常清新，舒服，这就让人很喜欢这个博客平台，目前看来还是比较小众，但是上面的开发者的互动很多，是一个很温馨的地方。&lt;/p&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;&lt;code&gt;infoq&lt;/code&gt; &lt;a href=&quot;https://www.infoq.cn/?utm_source=infoq&amp;amp;utm_medium=toutubiaoti&quot; target=&quot;_blank&quot;&gt;https://www.infoq.cn/?utm_source=infoq&amp;amp;utm_medium=toutubiaoti&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/12/16/r1RsKA.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;infoq 是最近兴起的一个技术社区，界面非常小清新，让人感觉很舒服，目前入驻的开发者倒不是很多，但是 infoq 依托极客邦的大流量和资源，做起来应该很快的，我入驻了 infoq ，感觉里面还是有很多大佬的，推荐大家经常浏览一波&lt;/p&gt;
&lt;ol start=&quot;6&quot;&gt;&lt;li&gt;&lt;code&gt;GitChat&lt;/code&gt; &lt;a href=&quot;https://gitbook.cn/&quot; target=&quot;_blank&quot;&gt;https://gitbook.cn&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;GitChat 是一个付费学习网站，当然也支持免费模式，因为付费所以相对文章质量比较高，但是免费的文章同样也很不错，而且我就在 GitChat 上面写了很多免费文章，不应该是很多，应该是全部免费，我的 gitchat 主页如下 &lt;a href=&quot;https://gitbook.cn/gitchat/author/5ca2dd8afd80e72ce02ebd1c&quot; target=&quot;_blank&quot;&gt;程序员cxuan 的 GitChat&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&quot;7&quot;&gt;&lt;li&gt;&lt;code&gt;V2EX&lt;/code&gt; &lt;a href=&quot;https://www.v2ex.com/&quot; target=&quot;_blank&quot;&gt;https://www.v2ex.com&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/12/16/r1R6bt.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;无论你是在大学进行人生最重要阶段的学习，或者是在中国的某座城市工作，或者是在外太空的某个天体如 Sputnik 1 上享受人生，在注册进入 V2EX 之后，你都可以为自己设置一个所在地，从而找到更多和你在同一区域的朋友。&lt;/p&gt;
&lt;ol start=&quot;8&quot;&gt;&lt;li&gt;&lt;code&gt;OSCHINA&lt;/code&gt; &lt;a href=&quot;https://www.oschina.net/&quot; target=&quot;_blank&quot;&gt;https://www.oschina.net&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/12/16/r1R2Uf.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个网站和 CSDN 一样是国内最大程序员社区，各种教程、资源、工具、书籍都是可以找到的。在社区里，你可以尽情的写博客，发动态，激烈的讨论问题，只有在这种环境下才能激起你学习的热情。&lt;/p&gt;
&lt;ol start=&quot;9&quot;&gt;&lt;li&gt;&lt;code&gt;简书&lt;/code&gt; &lt;a href=&quot;https://www.jianshu.com/&quot; target=&quot;_blank&quot;&gt;https://www.jianshu.com/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/12/16/r1RgVP.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;简书是一个不仅仅为程序员提供的创作分享社区，上面充满了各种各样精彩的博文，也有很多优秀的博主，但是相比较与 CSDN 个人认为在技术创作方面就略低一筹了。&lt;/p&gt;
&lt;ol start=&quot;10&quot;&gt;&lt;li&gt;&lt;code&gt;dev&lt;/code&gt; &lt;a href=&quot;https://dev.to/&quot; target=&quot;_blank&quot;&gt;https://dev.to/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/12/16/r1R5vj.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;dev 社区和国内的掘金社区很相似，技术分类也比较多，各种技术应有尽有，文章质量都很不错。&lt;/p&gt;
&lt;ol start=&quot;11&quot;&gt;&lt;li&gt;&lt;code&gt;dreamincode&lt;/code&gt; &lt;a href=&quot;https://www.dreamincode.net/&quot; target=&quot;_blank&quot;&gt;https://www.dreamincode.net&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/12/16/r1R42Q.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;dreamincode 是一个相对小众的技术博客，风格简约，但是内容却不简单。&lt;/p&gt;
&lt;ol start=&quot;12&quot;&gt;&lt;li&gt;&lt;code&gt;bytes&lt;/code&gt; &lt;a href=&quot;https://bytes.com/&quot; target=&quot;_blank&quot;&gt;https://bytes.com&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/12/16/r1RR58.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;bytes 和 dreamcode 类似，简约但不简单。&lt;/p&gt;
&lt;ol start=&quot;13&quot;&gt;&lt;li&gt;&lt;code&gt;hongkiat&lt;/code&gt; &lt;a href=&quot;https://www.hongkiat.com/blog/design-dev/&quot; target=&quot;_blank&quot;&gt;https://www.hongkiat.com/blog/design-dev&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/12/16/r1Rh8g.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;hongkiat是与技术、设计领域相关的站点之一，大家可以在这里分享技术文章。&lt;/p&gt;
&lt;ol start=&quot;14&quot;&gt;&lt;li&gt;&lt;code&gt;IBM Developer&lt;/code&gt; &lt;a href=&quot;https://developer.ibm.com/&quot; target=&quot;_blank&quot;&gt;https://developer.ibm.com&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/12/16/r1RfPS.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里面都是一线工程师，技术性很强，每一篇文章都值得细细观看，认真学习。&lt;/p&gt;
&lt;h2 id=&quot;问答类&quot;&gt;问答类&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;知乎&lt;/code&gt; &lt;a href=&quot;https://www.zhihu.com/&quot; target=&quot;_blank&quot;&gt;https://www.zhihu.com/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;有问题,上知乎。知乎,可信赖的问答社区,以让每个人高效获得可信赖的解答为使命。&lt;/p&gt;
&lt;p&gt;本是一个分享各种人生杂谈，和一些鲜为人知以及各种大牛的免费和付费的知识型网站。由于流量逐步扩大，吸引了大批优秀的程序员在上面分享自己的技术创作，也是一个程序员常去的网站之一，不仅仅是为了学习技术。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/12/16/r1RTrn.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;&lt;code&gt;思否问答&lt;/code&gt; &lt;a href=&quot;https://segmentfault.com/&quot; target=&quot;_blank&quot;&gt;https://segmentfault.com&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;SegmentFault 思否是中国领先的新一代开发者社区和专业的技术媒体。我们为中文开发者提供纯粹、高质的技术交流平台以及最前沿的技术行业动态,帮助更多的开发者获得认知&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/12/16/r1RbV0.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;&lt;code&gt;StackOverFlow&lt;/code&gt; &lt;a href=&quot;https://stackoverflow.com/&quot; target=&quot;_blank&quot;&gt;https://stackoverflow.com&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这是一个由外国人创办的专为程序员提供的国际性问题解答交流社区，正如网站签名：&lt;strong&gt;Stack Overflow - Where Developers Learn, Share, &amp;amp; Build Careers&lt;/strong&gt;。这个网站非常的纯粹，一般人还真不太习惯用这个，没有一手好英语还看不太懂全英文的技术交流与问答。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/12/16/r1R7bq.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;&lt;code&gt;Reddit&lt;/code&gt; &lt;a href=&quot;https://www.reddit.com/&quot; target=&quot;_blank&quot;&gt;https://www.reddit.com&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;reddit是一个非常个性的社区，你可以在这里讨论编程问题，还可以学习学英语，reddit 还很幽默，有古怪的莫名笑点，评论接楼很有意思。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/12/16/r1RqaV.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;&lt;code&gt;daniweb&lt;/code&gt; &lt;a href=&quot;https://www.daniweb.com/&quot; target=&quot;_blank&quot;&gt;https://www.daniweb.com&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;daniweb也是一个质量比较高的问答平台，有一种像社交平台的感觉。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/12/16/r1RL5T.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;教程类&quot;&gt;教程类&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;菜鸟教程&lt;/code&gt; &lt;a href=&quot;https://www.runoob.com/&quot; target=&quot;_blank&quot;&gt;https://www.runoob.com&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;菜鸟教程提供了编程的基础技术教程, 介绍了 HTML、CSS、Javascript、Python、Java、Ruby、C、PHP、MySQL 等各种编程语言的基础知识，是个小白入门，学习语言的好地方。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/12/16/r1RXPU.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;&lt;code&gt;w3schoool&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在W3School,你可以找到你所需要的所有的网站建设教程。 从基础的 HTML 到 CSS,乃至进阶的 XML、SQL、JS、PHP 和 ASP.NET。 从左侧的菜单选择你需要的教程! 和菜鸟教程十分相似的网站。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/12/16/r1RjGF.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;&lt;code&gt;易百教程&lt;/code&gt; &lt;a href=&quot;https://www.yiibai.com/&quot; target=&quot;_blank&quot;&gt;https://www.yiibai.com&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;易百网是一个内容全面的教程网站，专注于 VBScript, MATLAB, EJB, IPv6, IPv4, 电子商务, PostgreSQL, SQLite, SDLC, Assembly, 操作系统, JSON, iOS, 设计模式, VB.Net, 计算机基础知识。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/12/16/r1Rv24.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;&lt;code&gt;Bilibili1&lt;/code&gt; &lt;a href=&quot;https://www.bilibili.com/&quot; target=&quot;_blank&quot;&gt;https://www.bilibili.com&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;期初这个网站是由游戏玩家视频火起来的，尤其LOL骨灰级玩家遍布其中。bilibili 是国内知名的视频弹幕网站，通过动漫打出了名声，最近两年发展势头迅猛，里面有不少有创意的 Up 主，不乏一些有趣的程序员。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/12/16/r1RxxJ.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;&lt;code&gt;中国大学MOOC网&lt;/code&gt; &lt;a href=&quot;https://www.cnblogs.com/cxuanBlog/p/icourse163.org&quot; target=&quot;_blank&quot;&gt;icourse163.org&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;中国大学 MOOC(慕课) 是国内优质的中文 MOOC 学习平台，由爱课程网携手网易云课堂打造。平台拥有包括 985 高校在内提供的千余门课程。在这里，每一个有意愿提升自己的人都可以免费获得更优质的高等教育。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/12/16/r1WSM9.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;6&quot;&gt;&lt;li&gt;&lt;code&gt;慕课网-程序员的梦工厂&lt;/code&gt; &lt;a href=&quot;https://www.imooc.com/&quot; target=&quot;_blank&quot;&gt;https://www.imooc.com&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;慕课网(IMOOC)是IT技能学习平台。&lt;em&gt;慕课网&lt;/em&gt;(IMOOC)提供了丰富的移动端开发、php开发、web前端、android开发以及 html5 等视频教程资源公开课。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/12/16/r1WPVx.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;7&quot;&gt;&lt;li&gt;&lt;code&gt;网易云课堂&lt;/code&gt; &lt;a href=&quot;https://study.163.com/&quot; target=&quot;_blank&quot;&gt;https://study.163.com&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;网易云课堂，是网易公司打造的在线实用技能学习平台，主要为学习者提供海量、优质的课程，用户可以根据自身的学习程度，自主安排学习进度。涵盖实用软件、IT与互联网、外语学习、生活家居、兴趣爱好、职场技能、金融管理、考试认证、中小学、亲子教育等十余大门类。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/12/16/r1W9q1.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;8&quot;&gt;&lt;li&gt;&lt;code&gt;实验楼&lt;/code&gt; &lt;a href=&quot;https://www.lanqiao.cn/courses/&quot; target=&quot;_blank&quot;&gt;https://www.lanqiao.cn/courses&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;实验楼这个网站我直接吹爆，无需配置繁琐的本地环境，随时在线使用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/12/17/r3uTZ8.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;9&quot;&gt;&lt;li&gt;&lt;code&gt;tutorialspoint&lt;/code&gt; &lt;a href=&quot;https://www.tutorialspoint.com/index.htm&quot; target=&quot;_blank&quot;&gt;https://www.tutorialspoint.com/index.htm&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这是一个在线学习的网站，并且免费，里面有各种技术、各个知识点的讲解和demo，灰常全面，这比查找API方便多了，遇到不明白的知识点直接根据索引找就是了，还有各种电子书。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/12/17/r3uvMq.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;10&quot;&gt;&lt;li&gt;&lt;code&gt;codecademy&lt;/code&gt;&lt;a href=&quot;https://www.codecademy.com/learn/&quot; target=&quot;_blank&quot;&gt;https://www.codecademy.com&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;学习新语言，敲代码玩就在这里了。这个网站将简化编程学习的过程。比如说网站左边会讲解知识点，右边直接练习。如果出现错误，就会有错误提示，直接给你反馈。所以，使用它不用想太多，直接拼命硬干敲代码入门。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/12/17/r3uIqf.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;11&quot;&gt;&lt;li&gt;&lt;code&gt;Livecoding.tv&lt;/code&gt; &lt;a href=&quot;https://www.livecoding.tv/accounts/login/&quot; target=&quot;_blank&quot;&gt;https://www.livecoding.tv/accounts/login/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Livecoding.tv 由一群欧美程序爱好者共同发起成立，旨在为全球程序员提供一个实时高效的互动平台。特色是使用了录屏直播技术，用户可以在线观看高手实时编程并且可以向对方提问互动，网站现在已经汇集了一大批程序精英。现在 Livecoding.TV 来到中国，希望更多的中国程序员加入进来一起切磋技术。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/12/17/r3uqiQ.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;12&quot;&gt;&lt;li&gt;&lt;code&gt;Dzone&lt;/code&gt; &lt;a href=&quot;https://dzone.com/&quot; target=&quot;_blank&quot;&gt;https://dzone.com&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Dzone 是一个技术涵盖比较全面的网站，像云平台、数据库、物联网、开发运维、Java 语言等都有。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/12/17/r3u7dS.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;13&quot;&gt;&lt;li&gt;&lt;code&gt;simpleprogrammer&lt;/code&gt; &lt;a href=&quot;https://simpleprogrammer.com/&quot; target=&quot;_blank&quot;&gt;https://simpleprogrammer.com/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;simpleprogrammer与其他技术类的社区不太一样，在这里并没有很多技术类的文章，更多的是指导建议性的文章，讲述了一些人生道理，职场规则，编程生涯的一些文章。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/12/17/r3uHIg.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;14&quot;&gt;&lt;li&gt;&lt;code&gt;SitePoint&lt;/code&gt; &lt;a href=&quot;https://www.sitepoint.com/web/&quot; target=&quot;_blank&quot;&gt;https://www.sitepoint.com/web&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;通过 SitePoint 教程，课程和书籍学习 Web 设计和开发-HTML5，CSS3，JavaScript，PHP，移动应用，这是一个偏向前端方向的网站，在这里包含了各种高质量的前端方面的文章，电子书。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/12/17/r3uXzn.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;15&quot;&gt;&lt;li&gt;&lt;code&gt;YouTobe&lt;/code&gt; &lt;a href=&quot;https://www.youtube.com/&quot; target=&quot;_blank&quot;&gt;https://www.youtube.com/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;YouTobe 这个网站可算是经典，和国内的哔哩哔哩一样，各类视频汇聚于此，当然各国编程大神也在这啦。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/12/17/r3uORs.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;算法类&quot;&gt;算法类&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;LeetCode&lt;/code&gt; &lt;a href=&quot;https://leetcode-cn.com/&quot; target=&quot;_blank&quot;&gt;https://leetcode-cn.com&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;几乎每个算法大牛都知道的神奇网站，这个网站上面有：算法、数据库、Shell、多线程等多种类型供你学习。多数人在上面练习编程算法，尤其是给想进入一线互联网公司的技术人员，提供了一个免费又方便的题库。面试前都会在上面进行长期和充分的刷题，是你的不二选择。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/12/17/r3uzLV.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;&lt;code&gt;LintCode&lt;/code&gt; &lt;a href=&quot;https://www.lintcode.com/&quot; target=&quot;_blank&quot;&gt;https://www.lintcode.com&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;LintCode 领扣上有数量超过 1000 道的算法题目和人工智能题目，通过刷题熟练掌握数据结构和算法。完成各大名企的阶梯训练，为你斩获心仪的 offer 打下坚实的基础&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/12/17/r3Kii4.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;&lt;code&gt;洛谷&lt;/code&gt; &lt;a href=&quot;https://www.luogu.com.cn/&quot; target=&quot;_blank&quot;&gt;https://www.luogu.com.cn&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;洛谷创办于 2013 年,致力于为参加 noip、noi、acm 的选手提供清爽、快捷的编程体验。它拥有在线测题系统、强大的社区、在线学习功能，也是一个很好练习刷题的网站啦&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/12/17/r3KpZT.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;&lt;code&gt;Codeforces&lt;/code&gt; &lt;a href=&quot;http://codeforces.com/&quot; target=&quot;_blank&quot;&gt;http://codeforces.com/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Codeforces 是一家为计算机编程爱好者提供的在线评测系统该网站由萨拉托夫国立大学的一个团体创立并负责运营。在编程挑战赛中，选手有 2 个小时的时间去解决 5 道题，通过得分排名，选手可以看到实时的排名，也可以选择查看好友的排名，还可以看到某题有多少人通过等信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/12/17/r3K9dU.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;&lt;code&gt;Topcoder&lt;/code&gt; &lt;a href=&quot;https://www.topcoder.com/&quot; target=&quot;_blank&quot;&gt;https://www.topcoder.com&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Topcoder 据说是世界上规模最大的编程网站，这里面的题型，比赛形式跟 ACM/ICPC 极不相同。该网站把中国纳入其赛区，大家可以上去那里跟来自全世界的程序员(事实上大多数也是大学生)进行更直接的交流，可能也是ACM/ICPC 练兵的好地方吧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/12/17/r3KCoF.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;接单类&quot;&gt;接单类&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;程序员客栈&lt;/code&gt; &lt;a href=&quot;https://www.proginn.com/&quot; target=&quot;_blank&quot;&gt;https://www.proginn.com&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;程序员客栈是领先的程序员自由远程工作平台，未来互联网企业用人方式。提供优秀程序员为您进行网站建设制作、测试运维服务、人工智能 AI、大数据区块链、软件开发等优质服务。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/12/17/r3KAzR.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;&lt;code&gt;码市&lt;/code&gt; &lt;a href=&quot;https://codemart.com/developers&quot; target=&quot;_blank&quot;&gt;https://codemart.com/developers&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;码市是互联网软件外包服务平台，意在连接需求方与广大开发者。让项目的需求方快速的找到合适的开发者，完成项目开发工作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/12/17/r3KkW9.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;&lt;code&gt;猿急送&lt;/code&gt; &lt;a href=&quot;https://www.yuanjisong.com/job&quot; target=&quot;_blank&quot;&gt;https://www.yuanjisong.com/job&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;猿急送为您提供兼职程序员，兼职工程师信息，猿急送是一个高级技术共享平台，是优质的程序员兼职网站，这里汇聚 BAT 等知名互联网公司的技术开发、产品、设计大牛。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/12/17/r3KFJJ.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;&lt;code&gt;开源众包&lt;/code&gt; &lt;a href=&quot;https://zb.oschina.net/&quot; target=&quot;_blank&quot;&gt;https://zb.oschina.net&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;开源众包–专业的软件众包平台，350万+ 优质开发者为您提供网站、APP、微信/小程序、企业应用等软件开发服务，有效降低企业 IT 软件开发成本、解决技术资源不足等问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/12/17/r3KudO.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;&lt;code&gt;实现网&lt;/code&gt; &lt;a href=&quot;https://shixian.com/&quot; target=&quot;_blank&quot;&gt;https://shixian.com&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这个比较高级，是一些知名公司技术人员兼职的平台。我们可以在线约好去其他公司兼职坐班。实现网为企业提供BAT 等名企背景的、靠谱的开发设计兼职人才和自由职业者,满足企业项目外包、驻场开发、远程兼职、技术咨询等短期人力需求。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/12/17/r3KVQ1.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;6&quot;&gt;&lt;li&gt;&lt;code&gt;猪八戒&lt;/code&gt; &lt;a href=&quot;https://shenyang.zbj.com/&quot; target=&quot;_blank&quot;&gt;https://shenyang.zbj.com&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;猪八戒网企业外包服务，中国领先的灵活用工平台，其中服务品类涵盖LOGO设计、UI设计、营销推广、网站建设、装修设计、工业设计、文案策划、知识产权的服务。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/12/17/r3KeL6.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;7&quot;&gt;&lt;li&gt;&lt;code&gt;码易众包平台&lt;/code&gt; &lt;a href=&quot;https://www.mayigeek.com/&quot; target=&quot;_blank&quot;&gt;https://www.mayigeek.com&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;码易是智网易联旗下 IT 软件服务平台，集软件商城、企业应用、电商软件、crm 软件、商务服务平台于一体的一站式软件外包开发服务平台。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/12/17/r3KZsx.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;求职类&quot;&gt;求职类&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;牛客网&lt;/code&gt; &lt;a href=&quot;https://www.nowcoder.com/&quot; target=&quot;_blank&quot;&gt;https://www.nowcoder.com&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;求职之前，先上牛客，就业找工作一站解决。这个网站不像 csdn 和 OSChina 以技术博客论坛为主了。但是在你需要的时候，却是相当有价值，里面有面试技巧、各种知名的不知名的互联网公司的对应往年校招社招面试题库，刷到你手软，一般应届生用这个比较多。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/12/17/r3KlJH.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;&lt;code&gt;拉勾网&lt;/code&gt; &lt;a href=&quot;https://www.lagou.com/&quot; target=&quot;_blank&quot;&gt;https://www.lagou.com&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;拉勾招聘是专业的&lt;em&gt;互联网求职招聘网站&lt;/em&gt;。致力于提供真实可靠的互联网岗位&lt;em&gt;求职招聘&lt;/em&gt;找工作信息，拥有海量的互联网人才储备，互联网行业找工作就上拉勾招聘,值得信赖的求职。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/12/17/r3KneK.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;&lt;code&gt;Boss直聘&lt;/code&gt; &lt;a href=&quot;https://www.zhipin.com/&quot; target=&quot;_blank&quot;&gt;https://www.zhipin.com&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;BOSS直聘是权威领先的招聘网，开启人才网招聘求职新时代，让求职者与 Boss 直接开聊、加快面试、即时反馈，是一个致力于为招聘者和求职者搭建高效沟通、信息对等的平台&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/12/17/r3K1Wd.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;&lt;code&gt;猎聘&lt;/code&gt; &lt;a href=&quot;https://www.liepin.com/&quot; target=&quot;_blank&quot;&gt;https://www.liepin.com&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;猎聘，2018年香港上市。作为中国知名中高端人才求职招聘平台，汇聚56万+知名企业、16万+认证猎头，为5700万用户提供高薪工作岗位。总之，猎聘还是非常不错的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/12/17/r3KQFe.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外，我自己肝了六本 PDF，微信搜索「程序员cxuan」关注公众号后，在后台回复 cxuan ，领取全部 PDF，这些 PDF 如下&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://s3.ax1x.com/2020/11/30/DgOK6f.png&quot; target=&quot;_blank&quot;&gt;六本 PDF 链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202011/1515111-20201130090550310-1032998206.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 17 Dec 2020 23:23:00 +0000</pubDate>
<dc:creator>程序员cxuan</dc:creator>
<og:description>我把自己以往的文章汇总成为了 Github ，欢迎各位大佬 star https://github.com/crisxuan/bestJavaer 程序员的工作和日常生活非常的枯燥，这里给大家推荐一些</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cxuanBlog/p/14153069.html</dc:identifier>
</item>
<item>
<title>我用go-zero开发了第一个线上项目 - Kevin Wan</title>
<link>http://www.cnblogs.com/kevinwan/p/14153059.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kevinwan/p/14153059.html</guid>
<description>&lt;p&gt;作者：结冰&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;​ 说在最前面，我是一个外表谦让，内心狂热，外表斯文，内心贪玩的一个普通人。我的职业是程序员，是一个golang语言爱好者，一半是因为golang好用，一半是因为其他语言学不好。我是从phper转为gopher的，写php的时候我认识了互联网软件，写go的时候感觉自己终于在编程。&lt;/p&gt;
&lt;h2 id=&quot;初见golang&quot;&gt;初见golang&lt;/h2&gt;
&lt;p&gt;​ 我大学专业是软件。第一门编程语言是C++，知道了指针，知道了加减乘除，知道了编程去控制软硬件。后来选修了java，被ssh框架戏耍了一个暑假。再后来进入了一个社团技术部，再被html/css/js打击了自己信心。高中年级总能排名前几的我，真的开始怀疑人生了。再再后来进入了一家游戏平台公司，开始了php的编写之旅。“噢！”，终于，我知道了什么是互联网，折磨我的编程语言c++/java/html/css，原来还可以这样子“变现”。&lt;/p&gt;
&lt;p&gt;​ 刚入门了互联网的我，心里是真的喜悦。不过，重复的东西做多了，总是少不了厌倦。每天都是写php，都是那些增删改查，都是修改数据表，增加字段，增加临时表。真的，开始腻了。“听说最新公司在用新的编程语言golang”，我，想去试试。但，我不敢，心里有对自己和对golang的怀疑，因此我不是第一个去拜师的。当golang在公司流行了两个月，我的leader让我去用一下golang。终于，我师出有名了。浅尝了一周的golang之后，我！！发现！！&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;golang是有指针的，这不是大学熟悉的C++那样的指针吗&lt;/li&gt;
&lt;li&gt;golang是编译语言，原来客户端的“打包、打包”，原来是这么一回事&lt;/li&gt;
&lt;li&gt;golang是可以做定时器的，换用php该怎么搞啊？很麻烦的吧。&lt;/li&gt;
&lt;li&gt;golang不用写分号，不用写括号，看起来很简单啊，性能又很好啊！&lt;/li&gt;
&lt;li&gt;golang原生支持web服务，原来不用nginx也可以起一个web服务啊&lt;/li&gt;
&lt;li&gt;.......还有很多很多&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;喜欢golang&quot;&gt;喜欢golang&lt;/h2&gt;
&lt;p&gt;​ 尝试了golang之后，我发现我喜欢上了golang了。&lt;/p&gt;
&lt;h3 id=&quot;golang严谨&quot;&gt;golang严谨&lt;/h3&gt;
&lt;p&gt;​ golang中不提倡多余的变量。gopher都知道，golang变量不使用，直接会报编译错误！这让我刮目相看！在我看来，是把严谨提升了一个阶段，只要你是gopher，就会强迫你变得严谨。golang变量这个属性，秉承了golang的设计理念，严谨这个理念贯穿了golang的各处。&lt;/p&gt;
&lt;p&gt;​ 曾经有一个CTO跟我说，定义的每一个变量、每一个字段，都应该有它的作用。多余的代码，多余的变量，多余的字段，除了误导别人，弄脏代码，别无他用。我，表示绝对赞同！&lt;/p&gt;
&lt;h3 id=&quot;golang性能好&quot;&gt;golang性能好&lt;/h3&gt;
&lt;p&gt;​ 单单靠golang的简单、严谨，当然上不了程序员的舞台。可恨的是，golang性能还很好！比C++要差点，但是就web应用的并发、资源占用来说，比java、python、php、nodejs都是要优秀的。具体数据大家上网一搜比比皆是。一个语法简单、性能又好、入门只需一周的语言，反正我是入坑了。&lt;/p&gt;
&lt;p&gt;​ 有段时间，我太热爱golang了导致认为golang可以做任何事情。不过慢慢，我理性了。做web应用，首选golang。做数据分析、爬虫、图片处理还是python吧。但要是有人说用java去写web后台，cms类型还好，要是面向市场用户的，spring boot那套，spring cloud那套，我觉得，远远远远远远远比不上用golang相关的框架，java还是去做那些单体应用吧。&lt;/p&gt;
&lt;h3 id=&quot;golang轻量&quot;&gt;golang轻量&lt;/h3&gt;
&lt;p&gt;​ golang还有另外一个属性，就是“轻”，有多轻？对比一下java的jvm那套容器，你就知道有多轻了。几行代码就能实现一个原生web服务了，docker这个跨时代的产物就是golang写的。etcd这个分布式基石也是golang写的，云原生这个跨时代的名词，很多组件都是golang贡献的。“微服务”这个面试必问的名词，golang可以对它做最好的诠释。&lt;/p&gt;
&lt;h2 id=&quot;go-zero一见如故&quot;&gt;go-zero一见如故&lt;/h2&gt;
&lt;p&gt;​ 后来我进入了一家直播公司，刚好遇到了公司的波动，让我有了停下来自省的时间。其间，喜欢逛逛github，稍有目的去逛一下golang的开源项目。比如gin，iris，go-micro，go-zero，sentinel-golang，gin-vue-admin等等等啦。一开始，go-zero并不是特别吸引我，可能是博客/github布局不够亮眼吧。但是，当我哪天沉下来看go-zero的文档，开始敲起第一个goctl的命令，我好像，好像！已经停不下来。&lt;/p&gt;
&lt;p&gt;​ go-zero，用起来，真的很舒服！&lt;/p&gt;
&lt;p&gt;​ 我刚在游戏平台公司实习转正的时候，也是可以带一两个实习生的。当时我就有个想法，“如何让员工都敲出规范、高效的代码”。当时想了下用go-template，但是因为学艺未精，推进不下去。时隔几年，当我接触到go-zero的goctl后，发现，居然有大佬实现了当年我的想法！虽然我技术不大行，但是梦想还是要有的，go-zero对我来说太亲切了。搞！肝！！&lt;/p&gt;
&lt;p&gt;​ 一周时间，过完了go-zero的github文档以及语雀文档，中途也自己练手了几个demo。可真是越敲越舒服。迫不及待地用想找个实际项目投入生产！果真不久有个机会来了，公司想做一个简单的app做投放调研，允许重新搭建一个新的后台web项目，我！go-zero！义不容辞，开干。又花了两周时间，写完了一个后台web服务，里面有下面板块&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;用户板块&lt;/li&gt;
&lt;li&gt;咨询板块&lt;/li&gt;
&lt;li&gt;报告板块&lt;/li&gt;
&lt;li&gt;支付板块&lt;/li&gt;
&lt;li&gt;广告板块&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;截个图看看我的项目结构，由于还是公司项目，暂时不会开源啦，不过凡是go-zeroer都能看懂&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/14470/202012/14470-20201218070040733-416307473.jpg&quot; alt=&quot;go-zero目录&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;简单说明一下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;api目录，就是http1.1的web服务，跟前端对接&lt;/li&gt;
&lt;li&gt;rpc目录，rpc服务，基本和api一一对应&lt;/li&gt;
&lt;li&gt;enum目录，枚举目录，里面存放的是各种各样的枚举值，我把它提到一等公民了&lt;/li&gt;
&lt;li&gt;model目录，数据库model，目前都是用goctl根据mysql生成的model&lt;/li&gt;
&lt;li&gt;utils目录，这里主要存放我的一些小工具包，例如int/string/time的一些操作，参考了下go-zero的命名方法，子目录一般会以x结尾，例如intx，timex，stringx等等&lt;/li&gt;
&lt;li&gt;worker目录，主要是做一些消费者模型的消费者，例如kafka的消费者，google订阅通知的消费者等等&lt;/li&gt;
&lt;li&gt;ws目录，存放websocket相关的服务，例如私聊&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;感谢下go-zero，让我对项目的组织结构有了一个简单的标准。worker、ws等服务，以前的项目结构都杂乱无章，目前都是参考go-zero生成api的目录结构了：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;main.go入口&lt;/li&gt;
&lt;li&gt;etc存放配置，&lt;/li&gt;
&lt;li&gt;internal内部目录
&lt;ol&gt;&lt;li&gt;config：配置&lt;/li&gt;
&lt;li&gt;handler：处理器&lt;/li&gt;
&lt;li&gt;logic：逻辑处理&lt;/li&gt;
&lt;li&gt;types：中间类型&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;go-zero理念&quot;&gt;go-zero理念&lt;/h2&gt;
&lt;p&gt;​ “工具大于约定和文档”，这，就是go-zero的理念。我，表示极度赞同！&lt;/p&gt;
&lt;p&gt;​ go-zero的最大特点，就是goctl。goctl是什么？就是能根据协议文档，生成代码的一个神器。例如&lt;/p&gt;
&lt;ol readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;定了a.proto文件，goctl rpc proto a.proto -dir . 即可生成rpc服务&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;定了b.sql文件，goctl model mysql ddl -c -src b.sql -dir . 即可生成模板model文件&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;定了c.api文件（go-zero出品），goctl api go -api ad-api.api -dir . 即可生成api文件&lt;/p&gt;
&lt;p&gt;再配合上golang的jb IDE，代码提醒，代码格式化，一个go-zero的生态，就出来了。一个字：舒服！！&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;go-zero小工具&quot;&gt;go-zero小工具&lt;/h2&gt;
&lt;p&gt;​ 除了goctl神器，另外一个让我拜服的点是，go-zero的一些小工具。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;流数据处理利器：fx。听说java8的lambda很炫酷，go-zero也有了！fx.Filter().Sort().Head() ，让数组的复杂处理变得简单&lt;/li&gt;
&lt;li&gt;mapReduce降低服务相应时间：mr.Finish(), mr.Map().Reduce(), 跟并发处理waitGroup说拜拜！&lt;/li&gt;
&lt;li&gt;etcd服务发现的集成：p2c的算法发现服务，免却了开发们点对点或nginx的转发服务，安装一个etcd就完事了&lt;/li&gt;
&lt;li&gt;jwt集成api：轻松拥有一个jwt的后台服务&lt;/li&gt;
&lt;li&gt;集成Prometheus：轻松拥有一个带监控的golang后台服务&lt;/li&gt;
&lt;li&gt;等等等&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;二次感谢go-zero，还有很多小工具，等待我去看源码，时间轮/调度器等等啦。go-zero有点像我学习的导师一样。&lt;/p&gt;
&lt;h2 id=&quot;go-zero拓展&quot;&gt;go-zero拓展&lt;/h2&gt;
&lt;p&gt;​ go-zero为小白如我的gopher们，提供了一个功能完备、性能可观、开发迅速的web框架。然而，它不像其他框架那样约束着我，我还是能里面做很多发挥的。虽然不是大牛级别的发挥，但是，个性化操作还是支持的：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;model层，完全可以接入gorm代替掉内置的sqlx，虽然就没了大佬辛苦做的缓存击穿等防护的功能。当然也可以两者并存。&lt;/li&gt;
&lt;li&gt;rpc层，不必约定要api层去调用。例如我上面截图的worker/ws层去调用完全没问题。&lt;/li&gt;
&lt;li&gt;api层自己生成的middleware，可以抽离出到公共目录，那就可以多个api目录使用同一个middlerware了。&lt;/li&gt;
&lt;li&gt;等等等啦&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;go-zero 很轻量、很便捷、很博学。里面蕴藏的着很多知识以及理念。目前我只是用了皮毛，go-zero的k8s部署，目前我没开始接入。继续努力努力学习啦！&lt;/p&gt;
&lt;h2 id=&quot;再次感谢&quot;&gt;再次感谢&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.yuque.com/tal-tech/go-zero/yaoehb&quot; target=&quot;_blank&quot;&gt;https://www.yuque.com/tal-tech/go-zero/yaoehb&lt;/a&gt; go-zero语雀文档&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/tal-tech/go-zero&quot; target=&quot;_blank&quot;&gt;https://github.com/tal-tech/go-zero&lt;/a&gt; go-zero源码&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;1.5&quot;&gt;
&lt;p&gt;项目地址：&lt;br/&gt;&lt;a href=&quot;https://github.com/tal-tech/go-zero&quot; target=&quot;_blank&quot;&gt;https://github.com/tal-tech/go-zero&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 17 Dec 2020 23:01:00 +0000</pubDate>
<dc:creator>Kevin Wan</dc:creator>
<og:description>作者：结冰 前言 ​	说在最前面，我是一个外表谦让，内心狂热，外表斯文，内心贪玩的一个普通人。我的职业是程序员，是一个golang语言爱好者，一半是因为golang好用，一半是因为其他语言学不好。我是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kevinwan/p/14153059.html</dc:identifier>
</item>
<item>
<title>容器编排系统之ReplicaSet和Deployment控制器 - Linux-1874</title>
<link>http://www.cnblogs.com/qiuhom-1874/p/14149042.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qiuhom-1874/p/14149042.html</guid>
<description>&lt;p&gt;　　前文我们了解了k8s上的Pod资源的生命周期、健康状态和就绪状态探测以及资源限制相关话题，回顾请参考&lt;a href=&quot;https://www.cnblogs.com/qiuhom-1874/p/14143610.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/qiuhom-1874/p/14143610.html&lt;/a&gt;；今天我们来了解下Pod控制器相关话题；&lt;/p&gt;
&lt;p&gt;　　在k8s上控制器就是k8s的“大脑”，在聊k8s开篇时，我们说过控制器主要负责创建，管理k8s上的资源，如果对应资源不吻合用户定义的资源状态，它就会尝试重启或重建的方式让其状态和用户定义的状态吻合；在k8s上控制器的类型有很多，比如pod控制，service控制器，endpoint控制器等等；不同类型的控制器有着不同的功能和作用；比如pod控制器就是针对pod资源进行管理的控制器；单说pod控制器，它也有很多类型，根据pod里容器跑的应用程序来分类，可以分为有状态应用和无状态应用控制，从应用程序是否运行为守护进程我们可以将控制器分为，守护进程和非守护进程控制器；其中无状态控制器中最常用的有ReplicaSet控制器和Deployment控制；有状态应用控制器常用的有StatefulSet；守护进程控制器最常用的有daemonSet控制器；非守护进程控制器有job控制器，对Job类型的控制器，如果要周期性执行的有Cronjob控制器；&lt;/p&gt;
&lt;p&gt;　　1、ReplicaSet控制器&lt;/p&gt;
&lt;p&gt;　　ReplicaSet控制器的主要作用是确保Pod对象副本数量在任何时刻都能精准满足用户期望的数量；这种控制器启动以后，它首先会查找集群中匹配其标签选择器的Pod资源对象，当活动pod数量与用户期望的pod数量不吻合时，如果多了就删除，少了就创建；它创建新pod是靠我们在配置清单中定义的pod模板来创建新pod；&lt;/p&gt;
&lt;p&gt;　　示例：定义创建ReplicaSet控制器&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# cat ReplicaSet-controller-demo.yaml
apiVersion: apps/v1
kind: ReplicaSet
metadata: 
  name: replicaset-demo
  namespace: default
spec:
  replicas: 3
  selector: 
    matchLabels:
      app: nginx-pod
  template:
    metadata:
      labels:
        app: nginx-pod
    spec:
      containers:
      - name: nginx
        image: nginx:1.14-alpine
        ports:
        - name: http
          containerPort: 80
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：定义ReplicaSet控制器，apiVersion字段的值为apps/v1，kind为ReplicaSet，这两个字段都是固定的；后面的metadata中主要定义名称和名称空间；spec中主要定义replicas、selector、template；其中replicas这个字段的值为一个整数，表示对应pod的副本数量；selector用于定义标签选择器；其值为一个对象，其中matchLabels字段表示精确匹配标签，这个字段的值为一个字典；除了精确匹配标签选择器这种方式，还有matchExpressions表示使用匹配表达式，其值为一个对象；简单说定义标签选择器，第一种是matchLabels，这种方式就是指定一个或多个标签，每个标签就是一个kvj键值对；后者matchExpressions是指定一个表达式，其值为一个对象，这个对象中主要定义key字段，这个字段定义key的名称；operator定义操作符，values定义值；key和operator字段的值类型都是字符串，其中operator的值有In, NotIn, Exists和DoesNotExist；values是一个字符串列表；其次就是定义pod模板，使用template字段定义，该字段的值为一个对象其中metadata字段用于定义模板的元素据信息，这个元数据信息必须定义标签属性；通常这个标签属性和选择器中的标签相同；spec字段用于定义pod模板的状态，最重要的是定义pod里容器的名字，镜像等等；&lt;/p&gt;
&lt;p&gt;　　应用资源配置清单&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl apply -f ReplicaSet-controller-demo.yaml
replicaset.apps/replicaset-demo created
[root@master01 ~]# kubectl get rs
NAME              DESIRED   CURRENT   READY   AGE
replicaset-demo   3         3         3       9s
[root@master01 ~]# kubectl get rs -o wide
NAME              DESIRED   CURRENT   READY   AGE   CONTAINERS   IMAGES              SELECTOR
replicaset-demo   3         3         3       17s   nginx        nginx:1.14-alpine   app=nginx-pod
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：rs就是ReplicaSet的简写；从上面的信息可以看到对应控制器已经创建；并且当前pod副本数量为3，用户期望的数量也为3，有3个准备就绪；&lt;/p&gt;
&lt;p&gt;　　查看pod&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl get pod -L app
NAME                    READY   STATUS    RESTARTS   AGE     APP
replicaset-demo-rsl7q   1/1     Running   0          2m57s   nginx-pod
replicaset-demo-twknl   1/1     Running   0          2m57s   nginx-pod
replicaset-demo-vzdbb   1/1     Running   0          2m57s   nginx-pod
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到当前default名称空间中创建了3个pod,其标签为nginx-pod；&lt;/p&gt;
&lt;p&gt;　　测试：更改其中一个pod的标签为ngx,看看对应控制器是否会新建一个标签为nginx-pod的pod呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl get pod -L app                         
NAME                    READY   STATUS    RESTARTS   AGE     APP
replicaset-demo-rsl7q   1/1     Running   0          5m48s   nginx-pod
replicaset-demo-twknl   1/1     Running   0          5m48s   nginx-pod
replicaset-demo-vzdbb   1/1     Running   0          5m48s   nginx-pod
[root@master01 ~]# kubectl label pod/replicaset-demo-vzdbb app=ngx --overwrite
pod/replicaset-demo-vzdbb labeled
[root@master01 ~]# kubectl get pod -L app
NAME                    READY   STATUS    RESTARTS   AGE    APP
replicaset-demo-qv8tp   1/1     Running   0          4s     nginx-pod
replicaset-demo-rsl7q   1/1     Running   0          6m2s   nginx-pod
replicaset-demo-twknl   1/1     Running   0          6m2s   nginx-pod
replicaset-demo-vzdbb   1/1     Running   0          6m2s   ngx
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到当我们把其中一个pod的标签更改为app=ngx后，对应控制器又会根据pod模板创建一个新pod；&lt;/p&gt;
&lt;p&gt;　　测试：更改pod标签为app=nginx-pod，看看对应控制器是否会删除一个pod呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl get pod -L app
NAME                    READY   STATUS    RESTARTS   AGE     APP
replicaset-demo-qv8tp   1/1     Running   0          2m35s   nginx-pod
replicaset-demo-rsl7q   1/1     Running   0          8m33s   nginx-pod
replicaset-demo-twknl   1/1     Running   0          8m33s   nginx-pod
replicaset-demo-vzdbb   1/1     Running   0          8m33s   ngx
[root@master01 ~]# kubectl label pod/replicaset-demo-vzdbb app=nginx-pod --overwrite
pod/replicaset-demo-vzdbb labeled
[root@master01 ~]# kubectl get pod -L app
NAME                    READY   STATUS        RESTARTS   AGE     APP
replicaset-demo-qv8tp   0/1     Terminating   0          2m50s   nginx-pod
replicaset-demo-rsl7q   1/1     Running       0          8m48s   nginx-pod
replicaset-demo-twknl   1/1     Running       0          8m48s   nginx-pod
replicaset-demo-vzdbb   1/1     Running       0          8m48s   nginx-pod
[root@master01 ~]# kubectl get pod -L app
NAME                    READY   STATUS    RESTARTS   AGE     APP
replicaset-demo-rsl7q   1/1     Running   0          8m57s   nginx-pod
replicaset-demo-twknl   1/1     Running   0          8m57s   nginx-pod
replicaset-demo-vzdbb   1/1     Running   0          8m57s   nginx-pod
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到当集群中有多余用户期望数量的pod标签时，对应控制器会把多余的相同标签的pod删除；从上面的测试可以看到ReplicaSet控制器是依靠标签选择器来判断集群中pod的数量是否和用户定义的数量吻合，如果不吻合就尝试删除或新建，让对应pod数量精确满足用户期望pod数量；&lt;/p&gt;
&lt;p&gt; 　　查看rs控制器的详细信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl describe rs replicaset-demo
Name:         replicaset-demo
Namespace:    default
Selector:     app=nginx-pod
Labels:       &amp;lt;none&amp;gt;
Annotations:  &amp;lt;none&amp;gt;
Replicas:     3 current / 3 desired
Pods Status:  3 Running / 0 Waiting / 0 Succeeded / 0 Failed
Pod Template:
  Labels:  app=nginx-pod
  Containers:
   nginx:
    Image:        nginx:1.14-alpine
    Port:         80/TCP
    Host Port:    0/TCP
    Environment:  &amp;lt;none&amp;gt;
    Mounts:       &amp;lt;none&amp;gt;
  Volumes:        &amp;lt;none&amp;gt;
Events:
  Type    Reason            Age   From                   Message
  ----    ------            ----  ----                   -------
  Normal  SuccessfulCreate  20m   replicaset-controller  Created pod: replicaset-demo-twknl
  Normal  SuccessfulCreate  20m   replicaset-controller  Created pod: replicaset-demo-vzdbb
  Normal  SuccessfulCreate  20m   replicaset-controller  Created pod: replicaset-demo-rsl7q
  Normal  SuccessfulCreate  15m   replicaset-controller  Created pod: replicaset-demo-qv8tp
  Normal  SuccessfulDelete  12m   replicaset-controller  Deleted pod: replicaset-demo-qv8tp
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　扩展/缩减rs控制pod副本数量&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl scale rs replicaset-demo --replicas=6
replicaset.apps/replicaset-demo scaled
[root@master01 ~]# kubectl get rs
NAME              DESIRED   CURRENT   READY   AGE
replicaset-demo   6         6         6       32m
[root@master01 ~]# kubectl scale rs replicaset-demo --replicas=4
replicaset.apps/replicaset-demo scaled
[root@master01 ~]# kubectl get rs
NAME              DESIRED   CURRENT   READY   AGE
replicaset-demo   4         4         4       32m
[root@master01 ~]# kubectl get pod
NAME                    READY   STATUS        RESTARTS   AGE
replicaset-demo-5t9tt   0/1     Terminating   0          33s
replicaset-demo-j75hk   1/1     Running       0          33s
replicaset-demo-rsl7q   1/1     Running       0          33m
replicaset-demo-twknl   1/1     Running       0          33m
replicaset-demo-vvqfw   0/1     Terminating   0          33s
replicaset-demo-vzdbb   1/1     Running       0          33m
[root@master01 ~]# kubectl get pod
NAME                    READY   STATUS    RESTARTS   AGE
replicaset-demo-j75hk   1/1     Running   0          41s
replicaset-demo-rsl7q   1/1     Running   0          33m
replicaset-demo-twknl   1/1     Running   0          33m
replicaset-demo-vzdbb   1/1     Running   0          33m
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：scale也可以对控制器做扩展和缩减pod副本数量，除了以上使用命令的方式来变更对应pod副本数量；也可以直接在配置清单中修改replicas字段，然后使用apply命令执行配置清单进行修改；&lt;/p&gt;
&lt;p&gt;　　修改配置清单中的replicas字段的值来扩展pod副本数量&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# cat ReplicaSet-controller-demo.yaml
apiVersion: apps/v1
kind: ReplicaSet
metadata: 
  name: replicaset-demo
  namespace: default
spec:
  replicas: 7
  selector: 
    matchLabels:
      app: nginx-pod
  template:
    metadata:
      labels:
        app: nginx-pod
    spec:
      containers:
      - name: nginx
        image: nginx:1.14-alpine
        ports:
        - name: http
          containerPort: 80
[root@master01 ~]# kubectl apply -f ReplicaSet-controller-demo.yaml
replicaset.apps/replicaset-demo configured
[root@master01 ~]# kubectl get rs
NAME              DESIRED   CURRENT   READY   AGE
replicaset-demo   7         7         7       35m
[root@master01 ~]# kubectl get pod
NAME                    READY   STATUS    RESTARTS   AGE
replicaset-demo-j75hk   1/1     Running   0          3m33s
replicaset-demo-k2n9g   1/1     Running   0          9s
replicaset-demo-n7fmk   1/1     Running   0          9s
replicaset-demo-q4dc6   1/1     Running   0          9s
replicaset-demo-rsl7q   1/1     Running   0          36m
replicaset-demo-twknl   1/1     Running   0          36m
replicaset-demo-vzdbb   1/1     Running   0          36m
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　更新pod版本&lt;/p&gt;
&lt;p&gt;　　方式1修改资源配置清单中pod模板的版本，然后在使用apply命令来执行配置清单&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# cat ReplicaSet-controller-demo.yaml
apiVersion: apps/v1
kind: ReplicaSet
metadata: 
  name: replicaset-demo
  namespace: default
spec:
  replicas: 7
  selector: 
    matchLabels:
      app: nginx-pod
  template:
    metadata:
      labels:
        app: nginx-pod
    spec:
      containers:
      - name: nginx
        image: nginx:1.16-alpine
        ports:
        - name: http
          containerPort: 80
[root@master01 ~]# kubectl apply -f ReplicaSet-controller-demo.yaml
replicaset.apps/replicaset-demo configured
[root@master01 ~]# kubectl get rs -o wide
NAME              DESIRED   CURRENT   READY   AGE   CONTAINERS   IMAGES              SELECTOR
replicaset-demo   7         7         7       55m   nginx        nginx:1.16-alpine   app=nginx-pod
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：从上面命令可以看到，它显示的镜像版本是1.16的版本；&lt;/p&gt;
&lt;p&gt;　　验证：查看对应pod，看看对应pod中容器镜像版本是否变成了1.16呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl get pod
NAME                    READY   STATUS    RESTARTS   AGE
replicaset-demo-j75hk   1/1     Running   0          25m
replicaset-demo-k2n9g   1/1     Running   0          21m
replicaset-demo-n7fmk   1/1     Running   0          21m
replicaset-demo-q4dc6   1/1     Running   0          21m
replicaset-demo-rsl7q   1/1     Running   0          57m
replicaset-demo-twknl   1/1     Running   0          57m
replicaset-demo-vzdbb   1/1     Running   0          57m
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：从pod创建的时间来看，pod没有更新；&lt;/p&gt;
&lt;p&gt;　　测试：删除一个pod看看对应pod里容器镜像是否会更新呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl get pod
NAME                    READY   STATUS    RESTARTS   AGE
replicaset-demo-j75hk   1/1     Running   0          25m
replicaset-demo-k2n9g   1/1     Running   0          21m
replicaset-demo-n7fmk   1/1     Running   0          21m
replicaset-demo-q4dc6   1/1     Running   0          21m
replicaset-demo-rsl7q   1/1     Running   0          57m
replicaset-demo-twknl   1/1     Running   0          57m
replicaset-demo-vzdbb   1/1     Running   0          57m
[root@master01 ~]# kubectl delete pod/replicaset-demo-vzdbb 
pod &quot;replicaset-demo-vzdbb&quot; deleted
[root@master01 ~]# kubectl get pod
NAME                    READY   STATUS              RESTARTS   AGE
replicaset-demo-9wqj9   0/1     ContainerCreating   0          10s
replicaset-demo-j75hk   1/1     Running             0          26m
replicaset-demo-k2n9g   1/1     Running             0          23m
replicaset-demo-n7fmk   1/1     Running             0          23m
replicaset-demo-q4dc6   1/1     Running             0          23m
replicaset-demo-rsl7q   1/1     Running             0          58m
replicaset-demo-twknl   1/1     Running             0          58m
[root@master01 ~]# kubectl describe pod/replicaset-demo-9wqj9 |grep Image
    Image:          nginx:1.16-alpine
    Image ID:       docker-pullable://nginx@sha256:5057451e461dda671da5e951019ddbff9d96a751fc7d548053523ca1f848c1ad
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到我们删除了一个pod，对应控制器又新建了一个pod，对应新建的pod镜像版本就成为了新版本的pod；从上面测试情况可以看到，对于rs控制器当pod模板中的镜像版本发生更改，如果k8s集群上对应pod数量和用户定义的数量吻合，此时rs控制器不会更新pod；只有新建后的pod才会拥有新版本；也就说如果我们要rs来对pod版本更新，就得删除原有老的pod后才会更新；&lt;/p&gt;
&lt;p&gt;　　方式2使用命令更新pod版本&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl set image rs replicaset-demo  nginx=nginx:1.18-alpine
replicaset.apps/replicaset-demo image updated
[root@master01 ~]# kubectl get rs -o wide
NAME              DESIRED   CURRENT   READY   AGE   CONTAINERS   IMAGES              SELECTOR
replicaset-demo   7         7         7       72m   nginx        nginx:1.18-alpine   app=nginx-pod
[root@master01 ~]# kubectl get pod
NAME                    READY   STATUS    RESTARTS   AGE
replicaset-demo-9wqj9   1/1     Running   0          13m
replicaset-demo-j75hk   1/1     Running   0          40m
replicaset-demo-k2n9g   1/1     Running   0          36m
replicaset-demo-n7fmk   1/1     Running   0          36m
replicaset-demo-q4dc6   1/1     Running   0          36m
replicaset-demo-rsl7q   1/1     Running   0          72m
replicaset-demo-twknl   1/1     Running   0          72m
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：对于rs控制器，不管用命令还是修改资源配置清单中pod模板中镜像版本，如果有和用户期望数量的pod，它是不会自动更新pod版本的；只有手动删除老版本pod，对应新版本pod才会被创建；&lt;/p&gt;
&lt;p&gt;　　2、deployment控制器&lt;/p&gt;
&lt;p&gt;　　对于deployment控制来说，它的定义方式和rs控制都差不多，但deploy控制器的功能要比rs强大，它可以实现滚动更新，用户手动定义更新策略；其实deploy控制器是在rs控制器的基础上来管理pod；也就说我们在创建deploy控制器时，它自动会创建一个rs控制器；其中使用deployment控制器创建的pod名称是由deploy控制器名称加上“-”pod模板hash名称加上“-”随机字符串；而对应rs控制器的名称恰好就是deploy控制器名称加“-”pod模板hash；即pod名称就为rs控制器名称加“-”随机字符串；&lt;/p&gt;
&lt;p&gt;　　示例：创建deployment控制器&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# cat deploy-demo.yaml
apiVersion: apps/v1
kind: Deployment
metadata: 
  name: deploy-demo
  namespace: default
spec:
  replicas: 3
  selector: 
    matchLabels:
      app: ngx-dep-pod
  template:
    metadata:
      labels:
        app: ngx-dep-pod
    spec:
      containers:
      - name: nginx
        image: nginx:1.14-alpine
        ports:
        - name: http
          containerPort: 80
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　应用配置清单&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl apply -f deploy-demo.yaml
deployment.apps/deploy-demo created
[root@master01 ~]# kubectl get deploy -o wide
NAME          READY   UP-TO-DATE   AVAILABLE   AGE   CONTAINERS   IMAGES              SELECTOR
deploy-demo   3/3     3            3           10s   nginx        nginx:1.14-alpine   app=ngx-dep-pod
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　验证：查看是否有rs控制器创建？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl get rs
NAME                     DESIRED   CURRENT   READY   AGE
deploy-demo-6d795f958b   3         3         3       57s
replicaset-demo          7         7         7       84m
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到有一个deploy-demo-6d795f958b的rs控制器被创建；&lt;/p&gt;
&lt;p&gt;　　验证：查看pod，看看对应pod名称是否有rs控制器名称加“-”一串随机字符串？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl  get pod
NAME                           READY   STATUS    RESTARTS   AGE
deploy-demo-6d795f958b-bppjr   1/1     Running   0          2m16s
deploy-demo-6d795f958b-mxwkn   1/1     Running   0          2m16s
deploy-demo-6d795f958b-sh76g   1/1     Running   0          2m16s
replicaset-demo-9wqj9          1/1     Running   0          26m
replicaset-demo-j75hk          1/1     Running   0          52m
replicaset-demo-k2n9g          1/1     Running   0          49m
replicaset-demo-n7fmk          1/1     Running   0          49m
replicaset-demo-q4dc6          1/1     Running   0          49m
replicaset-demo-rsl7q          1/1     Running   0          85m
replicaset-demo-twknl          1/1     Running   0          85m
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到有3个pod的名称是deploy-demo-6d795f958b-加随机字符串；&lt;/p&gt;
&lt;p&gt;　　更新pod版本&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# cat deploy-demo.yaml
apiVersion: apps/v1
kind: Deployment
metadata: 
  name: deploy-demo
  namespace: default
spec:
  replicas: 3
  selector: 
    matchLabels:
      app: ngx-dep-pod
  template:
    metadata:
      labels:
        app: ngx-dep-pod
    spec:
      containers:
      - name: nginx
        image: nginx:1.16-alpine
        ports:
        - name: http
          containerPort: 80
[root@master01 ~]# kubectl apply -f deploy-demo.yaml
deployment.apps/deploy-demo configured
[root@master01 ~]# kubectl get deploy -o wide
NAME          READY   UP-TO-DATE   AVAILABLE   AGE     CONTAINERS   IMAGES              SELECTOR
deploy-demo   3/3     3            3           5m45s   nginx        nginx:1.16-alpine   app=ngx-dep-pod
[root@master01 ~]# kubectl get pod
NAME                          READY   STATUS    RESTARTS   AGE
deploy-demo-95cc58f4d-45l5c   1/1     Running   0          43s
deploy-demo-95cc58f4d-6bmb6   1/1     Running   0          45s
deploy-demo-95cc58f4d-7d5r5   1/1     Running   0          29s
replicaset-demo-9wqj9         1/1     Running   0          30m
replicaset-demo-j75hk         1/1     Running   0          56m
replicaset-demo-k2n9g         1/1     Running   0          53m
replicaset-demo-n7fmk         1/1     Running   0          53m
replicaset-demo-q4dc6         1/1     Running   0          53m
replicaset-demo-rsl7q         1/1     Running   0          89m
replicaset-demo-twknl         1/1     Running   0          89m
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到deploy控制器只要更改了pod模板中镜像版本，对应pod会自动更新；&lt;/p&gt;
&lt;p&gt;　　使用命令更新pod版本&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl set image deploy deploy-demo nginx=nginx:1.18-alpine
deployment.apps/deploy-demo image updated
[root@master01 ~]# kubectl get deploy
NAME          READY   UP-TO-DATE   AVAILABLE   AGE
deploy-demo   3/3     1            3           9m5s
[root@master01 ~]# kubectl get deploy -o wide
NAME          READY   UP-TO-DATE   AVAILABLE   AGE     CONTAINERS   IMAGES              SELECTOR
deploy-demo   3/3     1            3           9m11s   nginx        nginx:1.18-alpine   app=ngx-dep-pod
[root@master01 ~]# kubectl get deploy -o wide
NAME          READY   UP-TO-DATE   AVAILABLE   AGE     CONTAINERS   IMAGES              SELECTOR
deploy-demo   3/3     3            3           9m38s   nginx        nginx:1.18-alpine   app=ngx-dep-pod
[root@master01 ~]# kubectl get pod
NAME                          READY   STATUS    RESTARTS   AGE
deploy-demo-567b54cd6-6h97c   1/1     Running   0          28s
deploy-demo-567b54cd6-j74t4   1/1     Running   0          27s
deploy-demo-567b54cd6-wcccx   1/1     Running   0          49s
replicaset-demo-9wqj9         1/1     Running   0          34m
replicaset-demo-j75hk         1/1     Running   0          60m
replicaset-demo-k2n9g         1/1     Running   0          56m
replicaset-demo-n7fmk         1/1     Running   0          56m
replicaset-demo-q4dc6         1/1     Running   0          56m
replicaset-demo-rsl7q         1/1     Running   0          92m
replicaset-demo-twknl         1/1     Running   0          92m
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到deploy控制器，只要修改了pod模板中镜像的版本，对应pod就会随之滚动更新到我们指定的版本；&lt;/p&gt;
&lt;p&gt;　　查看rs历史版本&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl get rs -o wide
NAME                     DESIRED   CURRENT   READY   AGE     CONTAINERS   IMAGES              SELECTOR
deploy-demo-567b54cd6    3         3         3       3m50s   nginx        nginx:1.18-alpine   app=ngx-dep-pod,pod-template-hash=567b54cd6
deploy-demo-6d795f958b   0         0         0       12m     nginx        nginx:1.14-alpine   app=ngx-dep-pod,pod-template-hash=6d795f958b
deploy-demo-95cc58f4d    0         0         0       7m27s   nginx        nginx:1.16-alpine   app=ngx-dep-pod,pod-template-hash=95cc58f4d
replicaset-demo          7         7         7       95m     nginx        nginx:1.18-alpine   app=nginx-pod
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：deploy控制器的更新pod版本操作，它会记录rs的所有历史版本；因为只要pod模板的hash值发生变化，对应的rs就会重新被创建一遍，不同于rs控制器，历史版本的rs上没有pod运行，只有当前版本的rs上才会运行pod；&lt;/p&gt;
&lt;p&gt;　　查看更新历史记录&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl rollout history deploy/deploy-demo
deployment.apps/deploy-demo 
REVISION  CHANGE-CAUSE
1         &amp;lt;none&amp;gt;
2         &amp;lt;none&amp;gt;
3         &amp;lt;none&amp;gt;

[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：这里可以看到有3个版本，没有记录对应的原因；这是因为我们在更新pod版本是没有记录；要想记录器更新原因，可以在对应名后面加--record选项即可；&lt;/p&gt;
&lt;p&gt;　　示例：记录更新操作命令到更新历史记录&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl set image deploy deploy-demo nginx=nginx:1.14-alpine --record 
deployment.apps/deploy-demo image updated
[root@master01 ~]# kubectl rollout history deploy/deploy-demo
deployment.apps/deploy-demo 
REVISION  CHANGE-CAUSE
2         &amp;lt;none&amp;gt;
3         &amp;lt;none&amp;gt;
4         kubectl set image deploy deploy-demo nginx=nginx:1.14-alpine --record=true

[root@master01 ~]# kubectl apply -f deploy-demo-nginx-1.16.yaml --record
deployment.apps/deploy-demo configured
[root@master01 ~]# kubectl rollout history deploy/deploy-demo
deployment.apps/deploy-demo 
REVISION  CHANGE-CAUSE
3         &amp;lt;none&amp;gt;
4         kubectl set image deploy deploy-demo nginx=nginx:1.14-alpine --record=true
5         kubectl apply --filename=deploy-demo-nginx-1.16.yaml --record=true

[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到更新操作时加上--record选项后，再次查看更新历史记录，就能显示对应的更新命令；&lt;/p&gt;
&lt;p&gt;　　回滚到上一个版本&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl get deploy -o wide
NAME          READY   UP-TO-DATE   AVAILABLE   AGE   CONTAINERS   IMAGES              SELECTOR
deploy-demo   3/3     3            3           33m   nginx        nginx:1.16-alpine   app=ngx-dep-pod
[root@master01 ~]# kubectl get rs -o wide    
NAME                     DESIRED   CURRENT   READY   AGE    CONTAINERS   IMAGES              SELECTOR
deploy-demo-567b54cd6    0         0         0       24m    nginx        nginx:1.18-alpine   app=ngx-dep-pod,pod-template-hash=567b54cd6
deploy-demo-6d795f958b   0         0         0       33m    nginx        nginx:1.14-alpine   app=ngx-dep-pod,pod-template-hash=6d795f958b
deploy-demo-95cc58f4d    3         3         3       28m    nginx        nginx:1.16-alpine   app=ngx-dep-pod,pod-template-hash=95cc58f4d
replicaset-demo          7         7         7       116m   nginx        nginx:1.18-alpine   app=nginx-pod
[root@master01 ~]# kubectl rollout history deploy/deploy-demo
deployment.apps/deploy-demo 
REVISION  CHANGE-CAUSE
3         &amp;lt;none&amp;gt;
4         kubectl set image deploy deploy-demo nginx=nginx:1.14-alpine --record=true
5         kubectl apply --filename=deploy-demo-nginx-1.16.yaml --record=true

[root@master01 ~]# kubectl rollout undo deploy/deploy-demo
deployment.apps/deploy-demo rolled back
[root@master01 ~]# kubectl rollout history deploy/deploy-demo
deployment.apps/deploy-demo 
REVISION  CHANGE-CAUSE
3         &amp;lt;none&amp;gt;
5         kubectl apply --filename=deploy-demo-nginx-1.16.yaml --record=true
6         kubectl set image deploy deploy-demo nginx=nginx:1.14-alpine --record=true

[root@master01 ~]# kubectl get deploy -o wide
NAME          READY   UP-TO-DATE   AVAILABLE   AGE   CONTAINERS   IMAGES              SELECTOR
deploy-demo   3/3     3            3           34m   nginx        nginx:1.14-alpine   app=ngx-dep-pod
[root@master01 ~]# kubectl get rs -o wide
NAME                     DESIRED   CURRENT   READY   AGE    CONTAINERS   IMAGES              SELECTOR
deploy-demo-567b54cd6    0         0         0       26m    nginx        nginx:1.18-alpine   app=ngx-dep-pod,pod-template-hash=567b54cd6
deploy-demo-6d795f958b   3         3         3       35m    nginx        nginx:1.14-alpine   app=ngx-dep-pod,pod-template-hash=6d795f958b
deploy-demo-95cc58f4d    0         0         0       29m    nginx        nginx:1.16-alpine   app=ngx-dep-pod,pod-template-hash=95cc58f4d
replicaset-demo          7         7         7       118m   nginx        nginx:1.18-alpine   app=nginx-pod
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到执行了kubectl rollout undo deploy/deploy-demo命令后，对应版本从1.16就回滚到1.14的版本了；对应更新历史记录也把1.14版本更新为当前最新记录；&lt;/p&gt;
&lt;p&gt;　　回滚到指定历史记录版本&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl rollout history deploy/deploy-demo
deployment.apps/deploy-demo 
REVISION  CHANGE-CAUSE
3         &amp;lt;none&amp;gt;
5         kubectl apply --filename=deploy-demo-nginx-1.16.yaml --record=true
6         kubectl set image deploy deploy-demo nginx=nginx:1.14-alpine --record=true

[root@master01 ~]# kubectl rollout undo deploy/deploy-demo --to-revision=3
deployment.apps/deploy-demo rolled back
[root@master01 ~]# kubectl rollout history deploy/deploy-demo             
deployment.apps/deploy-demo 
REVISION  CHANGE-CAUSE
5         kubectl apply --filename=deploy-demo-nginx-1.16.yaml --record=true
6         kubectl set image deploy deploy-demo nginx=nginx:1.14-alpine --record=true
7         &amp;lt;none&amp;gt;

[root@master01 ~]# kubectl get deploy -o wide
NAME          READY   UP-TO-DATE   AVAILABLE   AGE   CONTAINERS   IMAGES              SELECTOR
deploy-demo   3/3     3            3           42m   nginx        nginx:1.18-alpine   app=ngx-dep-pod
[root@master01 ~]# kubectl get rs -o wide
NAME                     DESIRED   CURRENT   READY   AGE    CONTAINERS   IMAGES              SELECTOR
deploy-demo-567b54cd6    3         3         3       33m    nginx        nginx:1.18-alpine   app=ngx-dep-pod,pod-template-hash=567b54cd6
deploy-demo-6d795f958b   0         0         0       42m    nginx        nginx:1.14-alpine   app=ngx-dep-pod,pod-template-hash=6d795f958b
deploy-demo-95cc58f4d    0         0         0       36m    nginx        nginx:1.16-alpine   app=ngx-dep-pod,pod-template-hash=95cc58f4d
replicaset-demo          7         7         7       125m   nginx        nginx:1.18-alpine   app=nginx-pod
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：指定要回滚到某个历史记录的版本，可以使用--to-revision选项来指定历史记录的编号；&lt;/p&gt;
&lt;p&gt;　　查看deploy控制器的详细信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl describe deploy deploy-demo
Name:                   deploy-demo
Namespace:              default
CreationTimestamp:      Thu, 17 Dec 2020 23:40:11 +0800
Labels:                 &amp;lt;none&amp;gt;
Annotations:            deployment.kubernetes.io/revision: 7
Selector:               app=ngx-dep-pod
Replicas:               3 desired | 3 updated | 3 total | 3 available | 0 unavailable
StrategyType:           RollingUpdate
MinReadySeconds:        0
RollingUpdateStrategy:  25% max unavailable, 25% max surge
Pod Template:
  Labels:  app=ngx-dep-pod
  Containers:
   nginx:
    Image:        nginx:1.18-alpine
    Port:         80/TCP
    Host Port:    0/TCP
    Environment:  &amp;lt;none&amp;gt;
    Mounts:       &amp;lt;none&amp;gt;
  Volumes:        &amp;lt;none&amp;gt;
Conditions:
  Type           Status  Reason
  ----           ------  ------
  Available      True    MinimumReplicasAvailable
  Progressing    True    NewReplicaSetAvailable
OldReplicaSets:  &amp;lt;none&amp;gt;
NewReplicaSet:   deploy-demo-567b54cd6 (3/3 replicas created)
Events:
  Type    Reason             Age                 From                   Message
  ----    ------             ----                ----                   -------
  Normal  ScalingReplicaSet  58m                 deployment-controller  Scaled down replica set deploy-demo-6d795f958b to 1
  Normal  ScalingReplicaSet  58m                 deployment-controller  Scaled up replica set deploy-demo-95cc58f4d to 3
  Normal  ScalingReplicaSet  58m                 deployment-controller  Scaled down replica set deploy-demo-6d795f958b to 0
  Normal  ScalingReplicaSet  55m                 deployment-controller  Scaled up replica set deploy-demo-567b54cd6 to 1
  Normal  ScalingReplicaSet  54m                 deployment-controller  Scaled down replica set deploy-demo-95cc58f4d to 2
  Normal  ScalingReplicaSet  38m                 deployment-controller  Scaled up replica set deploy-demo-6d795f958b to 1
  Normal  ScalingReplicaSet  38m                 deployment-controller  Scaled down replica set deploy-demo-567b54cd6 to 2
  Normal  ScalingReplicaSet  38m                 deployment-controller  Scaled up replica set deploy-demo-6d795f958b to 2
  Normal  ScalingReplicaSet  37m                 deployment-controller  Scaled down replica set deploy-demo-567b54cd6 to 1
  Normal  ScalingReplicaSet  37m                 deployment-controller  Scaled down replica set deploy-demo-567b54cd6 to 0
  Normal  ScalingReplicaSet  33m (x2 over 58m)   deployment-controller  Scaled up replica set deploy-demo-95cc58f4d to 1
  Normal  ScalingReplicaSet  33m (x2 over 58m)   deployment-controller  Scaled up replica set deploy-demo-95cc58f4d to 2
  Normal  ScalingReplicaSet  33m (x2 over 58m)   deployment-controller  Scaled down replica set deploy-demo-6d795f958b to 2
  Normal  ScalingReplicaSet  29m (x3 over 64m)   deployment-controller  Scaled up replica set deploy-demo-6d795f958b to 3
  Normal  ScalingReplicaSet  22m (x14 over 54m)  deployment-controller  (combined from similar events): Scaled down replica set deploy-demo-6d795f958b to 2
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：查看deploy控制器的详细信息，可以看到对应pod模板，回滚的过程，以及默认更新策略等等信息；&lt;/p&gt;
&lt;p&gt;　　自定义滚动更新策略&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# cat deploy-demo-nginx-1.14.yaml
apiVersion: apps/v1
kind: Deployment
metadata: 
  name: deploy-demo
  namespace: default
spec:
  replicas: 3
  selector: 
    matchLabels:
      app: ngx-dep-pod
  template:
    metadata:
      labels:
        app: ngx-dep-pod
    spec:
      containers:
      - name: nginx
        image: nginx:1.14-alpine
        ports:
        - name: http
          containerPort: 80
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 2
      maxUnavailable: 1
  minReadySeconds: 5
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：定义滚动更新策略需要使用strategy这个字段，这个字段的值是一个对象，其中type是指定更新策略，其策略有两种，第一种是Recreate，这种策略更新方式是新建一个新版pod，然后再删除一个旧版pod以这种方式滚动更新；第二种是RollingUpdate，这种策略是用于我们手动指定的策略；其中maxSurge表示最大允许超出用户期望的pod数量（即更新时允许新建超出用户期望的pod数量），maxUnavailable表示最大允许少于用于期望的pod数量（即更新时可以一次删除几个旧版pod）；最后minReadySeconds字段不是定义更新策略的，它是spec中的一个字段，用于限定pod最小就绪时长；以上更新策略表示，使用RollingUpdate类型策略，并指定最大新建pod超出用户期望pod数量为2个，最大允许少于用户期望pod数量为1个；pod最小就绪时间为5秒；&lt;/p&gt;
&lt;p&gt;　　应用配置清单&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl apply -f deploy-demo-nginx-1.14.yaml
deployment.apps/deploy-demo configured
[root@master01 ~]# kubectl describe deploy/deploy-demo
Name:                   deploy-demo
Namespace:              default
CreationTimestamp:      Thu, 17 Dec 2020 23:40:11 +0800
Labels:                 &amp;lt;none&amp;gt;
Annotations:            deployment.kubernetes.io/revision: 8
Selector:               app=ngx-dep-pod
Replicas:               3 desired | 3 updated | 3 total | 3 available | 0 unavailable
StrategyType:           RollingUpdate
MinReadySeconds:        5
RollingUpdateStrategy:  1 max unavailable, 2 max surge
Pod Template:
  Labels:  app=ngx-dep-pod
  Containers:
   nginx:
    Image:        nginx:1.14-alpine
    Port:         80/TCP
    Host Port:    0/TCP
    Environment:  &amp;lt;none&amp;gt;
    Mounts:       &amp;lt;none&amp;gt;
  Volumes:        &amp;lt;none&amp;gt;
Conditions:
  Type           Status  Reason
  ----           ------  ------
  Available      True    MinimumReplicasAvailable
  Progressing    True    NewReplicaSetAvailable
OldReplicaSets:  &amp;lt;none&amp;gt;
NewReplicaSet:   deploy-demo-6d795f958b (3/3 replicas created)
Events:
  Type    Reason             Age                 From                   Message
  ----    ------             ----                ----                   -------
  Normal  ScalingReplicaSet  47m                 deployment-controller  Scaled up replica set deploy-demo-6d795f958b to 1
  Normal  ScalingReplicaSet  47m                 deployment-controller  Scaled down replica set deploy-demo-567b54cd6 to 1
  Normal  ScalingReplicaSet  42m (x2 over 68m)   deployment-controller  Scaled up replica set deploy-demo-95cc58f4d to 1
  Normal  ScalingReplicaSet  42m (x2 over 68m)   deployment-controller  Scaled up replica set deploy-demo-95cc58f4d to 2
  Normal  ScalingReplicaSet  42m (x2 over 68m)   deployment-controller  Scaled down replica set deploy-demo-6d795f958b to 2
  Normal  ScalingReplicaSet  31m (x14 over 64m)  deployment-controller  (combined from similar events): Scaled down replica set deploy-demo-6d795f958b to 2
  Normal  ScalingReplicaSet  41s (x4 over 73m)   deployment-controller  Scaled up replica set deploy-demo-6d795f958b to 3
  Normal  ScalingReplicaSet  41s (x2 over 47m)   deployment-controller  Scaled down replica set deploy-demo-567b54cd6 to 2
  Normal  ScalingReplicaSet  41s (x2 over 47m)   deployment-controller  Scaled up replica set deploy-demo-6d795f958b to 2
  Normal  ScalingReplicaSet  34s (x2 over 47m)   deployment-controller  Scaled down replica set deploy-demo-567b54cd6 to 0
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到对应deploy控制器的更新策略已经更改为我们定义的策略；为了能够看出更新的效果，我们这里先手动把pod数量调整为10个；&lt;/p&gt;
&lt;p&gt;　　扩展pod副本数量&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl scale deploy/deploy-demo --replicas=10
deployment.apps/deploy-demo scaled
[root@master01 ~]# kubectl get pods
NAME                           READY   STATUS    RESTARTS   AGE
deploy-demo-6d795f958b-5bdfw   1/1     Running   0          3m33s
deploy-demo-6d795f958b-5zr7r   1/1     Running   0          8s
deploy-demo-6d795f958b-9mc7k   1/1     Running   0          8s
deploy-demo-6d795f958b-czwdp   1/1     Running   0          3m33s
deploy-demo-6d795f958b-jfrnc   1/1     Running   0          8s
deploy-demo-6d795f958b-jw9n8   1/1     Running   0          3m33s
deploy-demo-6d795f958b-mbrlw   1/1     Running   0          8s
deploy-demo-6d795f958b-ph99t   1/1     Running   0          8s
deploy-demo-6d795f958b-wzscg   1/1     Running   0          8s
deploy-demo-6d795f958b-z5mnf   1/1     Running   0          8s
replicaset-demo-9wqj9          1/1     Running   0          100m
replicaset-demo-j75hk          1/1     Running   0          126m
replicaset-demo-k2n9g          1/1     Running   0          123m
replicaset-demo-n7fmk          1/1     Running   0          123m
replicaset-demo-q4dc6          1/1     Running   0          123m
replicaset-demo-rsl7q          1/1     Running   0          159m
replicaset-demo-twknl          1/1     Running   0          159m
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　查看更新过程&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl get pod -w
NAME                           READY   STATUS    RESTARTS   AGE
deploy-demo-6d795f958b-5bdfw   1/1     Running   0          5m18s
deploy-demo-6d795f958b-5zr7r   1/1     Running   0          113s
deploy-demo-6d795f958b-9mc7k   1/1     Running   0          113s
deploy-demo-6d795f958b-czwdp   1/1     Running   0          5m18s
deploy-demo-6d795f958b-jfrnc   1/1     Running   0          113s
deploy-demo-6d795f958b-jw9n8   1/1     Running   0          5m18s
deploy-demo-6d795f958b-mbrlw   1/1     Running   0          113s
deploy-demo-6d795f958b-ph99t   1/1     Running   0          113s
deploy-demo-6d795f958b-wzscg   1/1     Running   0          113s
deploy-demo-6d795f958b-z5mnf   1/1     Running   0          113s
replicaset-demo-9wqj9          1/1     Running   0          102m
replicaset-demo-j75hk          1/1     Running   0          128m
replicaset-demo-k2n9g          1/1     Running   0          125m
replicaset-demo-n7fmk          1/1     Running   0          125m
replicaset-demo-q4dc6          1/1     Running   0          125m
replicaset-demo-rsl7q          1/1     Running   0          161m
replicaset-demo-twknl          1/1     Running   0          161m
deploy-demo-578d6b6f94-qhc9j   0/1     Pending   0          0s
deploy-demo-578d6b6f94-qhc9j   0/1     Pending   0          0s
deploy-demo-578d6b6f94-95srs   0/1     Pending   0          0s
deploy-demo-6d795f958b-mbrlw   1/1     Terminating   0          4m16s
deploy-demo-578d6b6f94-95srs   0/1     Pending       0          0s
deploy-demo-578d6b6f94-qhc9j   0/1     ContainerCreating   0          0s
deploy-demo-578d6b6f94-95srs   0/1     ContainerCreating   0          0s
deploy-demo-578d6b6f94-bht84   0/1     Pending             0          0s
deploy-demo-578d6b6f94-bht84   0/1     Pending             0          0s
deploy-demo-578d6b6f94-bht84   0/1     ContainerCreating   0          0s
deploy-demo-6d795f958b-mbrlw   0/1     Terminating         0          4m17s
deploy-demo-6d795f958b-mbrlw   0/1     Terminating         0          4m24s
deploy-demo-6d795f958b-mbrlw   0/1     Terminating         0          4m24s
deploy-demo-578d6b6f94-qhc9j   1/1     Running             0          15s
deploy-demo-578d6b6f94-95srs   1/1     Running             0          16s
deploy-demo-578d6b6f94-bht84   1/1     Running             0          18s
deploy-demo-6d795f958b-ph99t   1/1     Terminating         0          4m38s
deploy-demo-6d795f958b-jfrnc   1/1     Terminating         0          4m38s
deploy-demo-578d6b6f94-lg6vk   0/1     Pending             0          0s
deploy-demo-578d6b6f94-g9c8x   0/1     Pending             0          0s
deploy-demo-578d6b6f94-lg6vk   0/1     Pending             0          0s
deploy-demo-578d6b6f94-g9c8x   0/1     Pending             0          0s
deploy-demo-578d6b6f94-lg6vk   0/1     ContainerCreating   0          0s
deploy-demo-578d6b6f94-g9c8x   0/1     ContainerCreating   0          0s
deploy-demo-6d795f958b-ph99t   0/1     Terminating         0          4m38s
deploy-demo-6d795f958b-jfrnc   0/1     Terminating         0          4m38s
deploy-demo-6d795f958b-5zr7r   1/1     Terminating         0          4m43s
deploy-demo-578d6b6f94-4rpx9   0/1     Pending             0          0s
deploy-demo-578d6b6f94-4rpx9   0/1     Pending             0          0s
deploy-demo-578d6b6f94-4rpx9   0/1     ContainerCreating   0          0s
deploy-demo-6d795f958b-5zr7r   0/1     Terminating         0          4m43s
deploy-demo-6d795f958b-ph99t   0/1     Terminating         0          4m44s
deploy-demo-6d795f958b-ph99t   0/1     Terminating         0          4m44s
deploy-demo-6d795f958b-jfrnc   0/1     Terminating         0          4m44s
deploy-demo-6d795f958b-jfrnc   0/1     Terminating         0          4m44s
deploy-demo-578d6b6f94-g9c8x   1/1     Running             0          12s
deploy-demo-6d795f958b-5zr7r   0/1     Terminating         0          4m51s
deploy-demo-6d795f958b-5zr7r   0/1     Terminating         0          4m51s
deploy-demo-578d6b6f94-lg6vk   1/1     Running             0          15s
deploy-demo-6d795f958b-9mc7k   1/1     Terminating         0          4m56s
deploy-demo-578d6b6f94-4lbwg   0/1     Pending             0          0s
deploy-demo-578d6b6f94-4lbwg   0/1     Pending             0          0s
deploy-demo-578d6b6f94-4lbwg   0/1     ContainerCreating   0          0s
deploy-demo-578d6b6f94-4rpx9   1/1     Running             0          13s
deploy-demo-6d795f958b-9mc7k   0/1     Terminating         0          4m57s
deploy-demo-578d6b6f94-4lbwg   1/1     Running             0          2s
deploy-demo-6d795f958b-wzscg   1/1     Terminating         0          4m58s
deploy-demo-578d6b6f94-fhkk9   0/1     Pending             0          0s
deploy-demo-578d6b6f94-fhkk9   0/1     Pending             0          0s
deploy-demo-578d6b6f94-fhkk9   0/1     ContainerCreating   0          0s
deploy-demo-6d795f958b-wzscg   0/1     Terminating         0          4m59s
deploy-demo-578d6b6f94-fhkk9   1/1     Running             0          2s
deploy-demo-6d795f958b-z5mnf   1/1     Terminating         0          5m2s
deploy-demo-578d6b6f94-sfpz4   0/1     Pending             0          1s
deploy-demo-578d6b6f94-sfpz4   0/1     Pending             0          1s
deploy-demo-6d795f958b-czwdp   1/1     Terminating         0          8m28s
deploy-demo-578d6b6f94-sfpz4   0/1     ContainerCreating   0          1s
deploy-demo-578d6b6f94-5bs6z   0/1     Pending             0          0s
deploy-demo-578d6b6f94-5bs6z   0/1     Pending             0          0s
deploy-demo-578d6b6f94-5bs6z   0/1     ContainerCreating   0          0s
deploy-demo-6d795f958b-czwdp   0/1     Terminating         0          8m28s
deploy-demo-6d795f958b-z5mnf   0/1     Terminating         0          5m4s
deploy-demo-578d6b6f94-sfpz4   1/1     Running             0          2s
deploy-demo-6d795f958b-5bdfw   1/1     Terminating         0          8m29s
deploy-demo-6d795f958b-9mc7k   0/1     Terminating         0          5m4s
deploy-demo-6d795f958b-9mc7k   0/1     Terminating         0          5m4s
deploy-demo-578d6b6f94-5bs6z   1/1     Running             0          1s
deploy-demo-6d795f958b-5bdfw   0/1     Terminating         0          8m30s
deploy-demo-6d795f958b-czwdp   0/1     Terminating         0          8m36s
deploy-demo-6d795f958b-czwdp   0/1     Terminating         0          8m36s
deploy-demo-6d795f958b-5bdfw   0/1     Terminating         0          8m36s
deploy-demo-6d795f958b-5bdfw   0/1     Terminating         0          8m36s
deploy-demo-6d795f958b-wzscg   0/1     Terminating         0          5m11s
deploy-demo-6d795f958b-wzscg   0/1     Terminating         0          5m11s
deploy-demo-6d795f958b-jw9n8   1/1     Terminating         0          8m38s
deploy-demo-6d795f958b-jw9n8   0/1     Terminating         0          8m38s
deploy-demo-6d795f958b-z5mnf   0/1     Terminating         0          5m14s
deploy-demo-6d795f958b-z5mnf   0/1     Terminating         0          5m14s
deploy-demo-6d795f958b-jw9n8   0/1     Terminating         0          8m46s
deploy-demo-6d795f958b-jw9n8   0/1     Terminating         0          8m46s
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：使用-w选项可以一直跟踪查看pod变化过程；从上面的监控信息可以看到，在更新时，首先是将三个pod标记为pending状态，然后先删除一个pod，然后再创建两个pod；然后又创建一个，再删除3个，一次进行；不管怎么删除和新建，对应新旧pod的数量最少要有9个，最大不超过12个；&lt;/p&gt;
&lt;p&gt;　　使用暂停更新实现金丝雀发布&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl set image deploy/deploy-demo nginx=nginx:1.14-alpine &amp;amp;&amp;amp; kubectl rollout pause deploy/deploy-demo 
deployment.apps/deploy-demo image updated
deployment.apps/deploy-demo paused
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：以上命令会根据我们定义的更新策略，先删除一个pod，然后再创建3个新版pod，然后更新操作就暂停了；此时对应pod只更新了1个，然后新建了2个新pod，总共就有12个pod；&lt;/p&gt;
&lt;p&gt;　　查看pod情况&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl get pod
NAME                           READY   STATUS    RESTARTS   AGE
deploy-demo-6d795f958b-df77k   1/1     Running   0          87s
deploy-demo-6d795f958b-tll8b   1/1     Running   0          87s
deploy-demo-6d795f958b-zbhwp   1/1     Running   0          87s
deploy-demo-fb957b9b-44l6g     1/1     Running   0          3m21s
deploy-demo-fb957b9b-7q6wh     1/1     Running   0          3m38s
deploy-demo-fb957b9b-d45rg     1/1     Running   0          3m27s
deploy-demo-fb957b9b-j7p2j     1/1     Running   0          3m38s
deploy-demo-fb957b9b-mkpz6     1/1     Running   0          3m38s
deploy-demo-fb957b9b-qctnv     1/1     Running   0          3m21s
deploy-demo-fb957b9b-rvrtf     1/1     Running   0          3m27s
deploy-demo-fb957b9b-wf254     1/1     Running   0          3m12s
deploy-demo-fb957b9b-xclhz     1/1     Running   0          3m22s
replicaset-demo-9wqj9          1/1     Running   0          135m
replicaset-demo-j75hk          1/1     Running   0          161m
replicaset-demo-k2n9g          1/1     Running   0          158m
replicaset-demo-n7fmk          1/1     Running   0          158m
replicaset-demo-q4dc6          1/1     Running   0          158m
replicaset-demo-rsl7q          1/1     Running   0          3h14m
replicaset-demo-twknl          1/1     Running   0          3h14m
[root@master01 ~]# kubectl get pod|grep &quot;^deploy.*&quot; |wc -l
12
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：之所以多两个是因为我们在更新策略中定义允许最大超出用户期望2个pod；&lt;/p&gt;
&lt;p&gt;　　恢复更新&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl rollout resume deploy/deploy-demo &amp;amp;&amp;amp; kubectl rollout status deploy/deploy-demo
deployment.apps/deploy-demo resumed
Waiting for deployment &quot;deploy-demo&quot; rollout to finish: 3 out of 10 new replicas have been updated...
Waiting for deployment &quot;deploy-demo&quot; rollout to finish: 6 out of 10 new replicas have been updated...
Waiting for deployment &quot;deploy-demo&quot; rollout to finish: 6 out of 10 new replicas have been updated...
Waiting for deployment &quot;deploy-demo&quot; rollout to finish: 6 out of 10 new replicas have been updated...
Waiting for deployment &quot;deploy-demo&quot; rollout to finish: 6 out of 10 new replicas have been updated...
Waiting for deployment &quot;deploy-demo&quot; rollout to finish: 6 out of 10 new replicas have been updated...
Waiting for deployment &quot;deploy-demo&quot; rollout to finish: 6 out of 10 new replicas have been updated...
Waiting for deployment &quot;deploy-demo&quot; rollout to finish: 9 out of 10 new replicas have been updated...
Waiting for deployment &quot;deploy-demo&quot; rollout to finish: 9 out of 10 new replicas have been updated...
Waiting for deployment &quot;deploy-demo&quot; rollout to finish: 9 out of 10 new replicas have been updated...
Waiting for deployment &quot;deploy-demo&quot; rollout to finish: 9 out of 10 new replicas have been updated...
Waiting for deployment &quot;deploy-demo&quot; rollout to finish: 9 out of 10 new replicas have been updated...
Waiting for deployment &quot;deploy-demo&quot; rollout to finish: 9 out of 10 new replicas have been updated...
Waiting for deployment &quot;deploy-demo&quot; rollout to finish: 9 of 10 updated replicas are available...
Waiting for deployment &quot;deploy-demo&quot; rollout to finish: 9 of 10 updated replicas are available...
deployment &quot;deploy-demo&quot; successfully rolled out
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：resume表示恢复刚才暂停的更新操作；status是用来查看对应更新过程；&lt;/p&gt;
</description>
<pubDate>Thu, 17 Dec 2020 18:21:00 +0000</pubDate>
<dc:creator>Linux-1874</dc:creator>
<og:description>前文我们了解了k8s上的Pod资源的生命周期、健康状态和就绪状态探测以及资源限制相关话题，回顾请参考https://www.cnblogs.com/qiuhom-1874/p/14143610.htm</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qiuhom-1874/p/14149042.html</dc:identifier>
</item>
<item>
<title>详解Java中的IO输入输出流！ - 天乔巴夏丶</title>
<link>http://www.cnblogs.com/summerday152/p/14152925.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/summerday152/p/14152925.html</guid>
<description>&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;什么是流？流表示任何有能力&lt;strong&gt;产生数据的数据源对象或者是有能力接收数据的接收端对象&lt;/strong&gt;，它屏蔽了实际的I/O设备中处理数据的细节。&lt;/p&gt;
&lt;p&gt;IO流是实现输入输出的基础，它可以很方便地实现数据的输入输出操作，即读写操作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;本片要点&quot;&gt;本片要点&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;介绍流的定义和基本分类。&lt;/li&gt;
&lt;li&gt;介绍文件字符流、字节流、转换流、合并流、打印流等使用。&lt;/li&gt;
&lt;li&gt;介绍序列化的意义。&lt;/li&gt;
&lt;li&gt;介绍两种自定义序列化方式。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;基本分类&quot;&gt;基本分类&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;根据方向&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;输入流&lt;/strong&gt;：数据从外部流向程序，例如&lt;strong&gt;从文件中读取数据&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;输出流&lt;/strong&gt;：数据从程序流向外部，例如&lt;strong&gt;向文件中写数据&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;根据形式&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;字符流&lt;/strong&gt;：字符类文件，【如 txt、 java、 html】，操作16位的字符。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;字节流&lt;/strong&gt;：【图片、视频、音频】 ，操作8位的字节。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;根据功能&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;节点流&lt;/strong&gt;：直接从/向数据源【如磁盘、网络】进行数据读写&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;处理流&lt;/strong&gt;：封装其他的流，来提供增强流的功能。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th&gt;输入流&lt;/th&gt;
&lt;th&gt;输出流&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;字符流&lt;/td&gt;
&lt;td&gt;Reader&lt;/td&gt;
&lt;td&gt;Writer&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;字节流&lt;/td&gt;
&lt;td&gt;InputStream&lt;/td&gt;
&lt;td&gt;OutputStream&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;ul&gt;&lt;li&gt;上面四大基本流都是&lt;strong&gt;抽象类&lt;/strong&gt;，都不能直接创建实例对象。&lt;/li&gt;
&lt;li&gt;数据的来源/目的地：磁盘、网络、内存、外部设备。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;发展史&quot;&gt;发展史&lt;/h2&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;java1.0版本中，I/O库中与输入有关的所有类都将继承&lt;code&gt;InputStream&lt;/code&gt;，与输出有关的所有类继承&lt;code&gt;OutputStream&lt;/code&gt;，用以操作二进制数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;java1.1版本对I/O库进行了修改：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在原先的库中新增了新类，如&lt;code&gt;ObjectInputStream&lt;/code&gt;和&lt;code&gt;ObjectOutputStream&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;增加了Reader和Writer，提供了兼容Unicode与面向字符的I/O功能。&lt;/li&gt;
&lt;li&gt;在Reader和Writer类层次结构中，提供了使字符与字节相互转化的类，&lt;code&gt;OutputStreamWriter&lt;/code&gt;和&lt;code&gt;InputStreamReader&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;两个不同的继承层次结构拥有相似的行为，它们都提供了读（read)和写（write)的方法，针对不同的情况，提供的方法也是类似的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;java1.4版本的java.nio.*包中引入新的I/O类库，这部分以后再做学习。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;文件字符流&quot;&gt;文件字符流&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;文件字符输出流&lt;/strong&gt; &lt;code&gt;FileWriter&lt;/code&gt;：&lt;strong&gt;自带缓冲区&lt;/strong&gt;，数据先写到到缓冲区上，然后从缓冲区写入文件。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;文件字符输入流&lt;/strong&gt; &lt;code&gt;FileReader&lt;/code&gt;：没有缓冲区，可以单个字符的读取，也可以自定义数组缓冲区。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;输出的基本结构&quot;&gt;输出的基本结构&lt;/h3&gt;
&lt;p&gt;在实际应用中，异常处理的方式都需要按照下面的结构进行，本篇为了节约篇幅，之后都将采用向上抛出的方式处理异常。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    //将流对象放在try之外声明，并附为null，保证编译，可以调用close
    FileWriter writer = null;
    try {
        //将流对象放在里面初始化
        writer = new FileWriter(&quot;D:\\b.txt&quot;);
        writer.write(&quot;abc&quot;);
        
        //防止关流失败，没有自动冲刷，导致数据丢失
        writer.flush();
        
    } catch (IOException e) {
        e.printStackTrace();
    } finally {
        //判断writer对象是否成功初始化
        if(writer!=null) {
            //关流，无论成功与否
            try {
                writer.close();
            } catch (IOException e) {
                e.printStackTrace();
            }finally {
                //无论关流成功与否，都是有意义的：标为垃圾对象，强制回收
                writer = null;
            }
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;并不会直接将数据写入文件中，而是先写入缓冲区，待缓冲区满了之后才将缓冲区的数据写入文件。&lt;/li&gt;
&lt;li&gt;假设数据写入缓冲区时且缓冲区还没满，数据还没能够写入文件时，程序就已经结束，会导致数据惨死缓冲区，这时需要手动冲刷缓冲区，将缓冲区内的数据冲刷进文件中。&lt;code&gt;writer.flush();&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;数据写入完毕，释放文件以允许别的流来操作该文件。&lt;strong&gt;关闭流&lt;/strong&gt;可以调用&lt;code&gt;close()&lt;/code&gt;方法，值得注意的是，在close执行之前，流会自动进行一次flush的操作以避免数据还残存在缓冲区中，但这并不意味着flush操作是多余的。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;流中的异常处理&quot;&gt;流中的异常处理&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;无论流操作成功与否，关流操作都需要进行，所以需要&lt;strong&gt;将关流操作放到finally代码块中&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;为了让流对象在finally中依然能够使用，所以&lt;strong&gt;需要将流对象放在try之外声明并且赋值为null&lt;/strong&gt;，然后在try之内进行实际的初始化过程。&lt;/li&gt;
&lt;li&gt;在关流之前要判断流对象是否初始化成功，实际就是&lt;strong&gt;判断流对象是否为null&lt;/strong&gt;。&lt;code&gt;writer!=null&lt;/code&gt;时才执行关流操作。&lt;/li&gt;
&lt;li&gt;关流可能会失败，此时流依然会占用文件，所以需要将&lt;strong&gt;流对象置为null&lt;/strong&gt;，标记为垃圾对象进行强制回收以释放文件。&lt;/li&gt;
&lt;li&gt;如果流有缓冲区，为了防止关流失败导致没有进行自动冲刷，所以需要手动冲刷一次，以防止有数据死在缓冲区而产生数据的丢失。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;异常处理新方式&quot;&gt;异常处理新方式&lt;/h3&gt;
&lt;p&gt;JDK1.7提出了对流进行异常处理的新方式，任何&lt;code&gt;AutoClosable&lt;/code&gt;类型的对象都可以用于&lt;code&gt;try-with-resourses&lt;/code&gt;语法，实现自动关闭。&lt;/p&gt;
&lt;p&gt;要求处理的对象的声明过程必须在try后跟的&lt;code&gt;()&lt;/code&gt;中，在try代码块之外。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;try(FileWriter writer = new FileWriter(&quot;D:\\c.txt&quot;)){
    writer.write(&quot;abc&quot;);
}catch (IOException e){
    e.printStackTrace();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;读取的基本结构&quot;&gt;读取的基本结构&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    public static void main(String[] args) throws IOException {
        FileReader reader = new FileReader(&quot;D:\\b.txt&quot;);
        //定义数组作为缓冲区
        char[] cs = new char[5];
        //定义一个变量记录每次读取的字符
        int hasRead;
        //读取到末尾为-1
        while ((hasRead = reader.read(cs)) != -1) {
            System.out.println(new String(cs, 0, hasRead));
        }
        reader.close();
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;read方法可以传入字符数组，每次读取一个字符数组的长度。&lt;/li&gt;
&lt;li&gt;定义变量m记录读取的字符，以达到末尾为终止条件。&lt;code&gt;m!=-1&lt;/code&gt;时，终止循环。&lt;/li&gt;
&lt;li&gt;读取结束，执行关流操作。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;运用输入与输出完成复制效果&quot;&gt;运用输入与输出完成复制效果&lt;/h3&gt;
&lt;p&gt;运用文件字符输入与输出的小小案例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static void copyFile(FileReader reader, FileWriter writer) throws IOException {
    //利用字符数组作为缓冲区
    char[] cs = new char[5];
    //定义变量记录读取到的字符个数
    int hasRead;
    while((hasRead = reader.read(cs)) != -1){
        //将读取到的内容写入新的文件中
        writer.write(cs, 0, hasRead));

    }
    reader.close();
    writer.close();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;文件字节流&quot;&gt;文件字节流&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;文件字节输出流&lt;/strong&gt; &lt;code&gt;FileOutputStream&lt;/code&gt; 在输出的时候没有缓冲区，所以不需要进行flush操作。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    public static void main(String[] args) throws Exception {
        FileOutputStream out = new FileOutputStream(&quot;D:\\b.txt&quot;);
        //写入数据
        //字节输出流没有缓冲区
        out.write(&quot;天乔巴夏&quot;.getBytes());
        //关流是为了释放文件
        out.close();
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;文件字节输入流&lt;/strong&gt; &lt;code&gt;FileInputStream&lt;/code&gt;，可以定义字节数组作为缓冲区。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    public static void main(String[] args) throws Exception{
        FileInputStream in = new FileInputStream(&quot;E:\\1myblog\\Node.png&quot;);
       //1.读取字节
       int i;
       while((i = in.read()) ! =-1)
           System.out.println(i);
       //2.定义字节数组作为缓冲区
       byte[] bs = new byte[10];
       //定义变量记录每次实际读取的字节个数
       int len;
       while((len = in.read(bs)) != -1){
           System.out.println(new String(bs, 0, len));
       }
       in.close();

    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;缓冲流&quot;&gt;缓冲流&lt;/h2&gt;
&lt;h3 id=&quot;字符缓冲流&quot;&gt;字符缓冲流&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;BufferedReader&lt;/strong&gt;：在构建的时候需要传入一个Reader对象，&lt;strong&gt;真正读取数据依靠的是传入的这个Reader对象&lt;/strong&gt;，&lt;code&gt;BufferedRead&lt;/code&gt;从&lt;code&gt;Reader&lt;/code&gt;对象中获取数据&lt;strong&gt;提供缓冲区&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    public static void main(String[] args) throws IOException {
        //真正读取文件的流是FileReader，它本身并没有缓冲区
        FileReader reader = new FileReader(&quot;D:\\b.txt&quot;);
        BufferedReader br = new BufferedReader(reader);
        //读取一行
        //String str = br.readLine();
        //System.out.println(str);

        //定义一个变量来记录读取的每一行的数据（回车）
        String str;
        //读取到末尾返回null
        while((str = br.readLine())!=null){
            System.out.println(str);
        }
        //关外层流即可
        br.close();
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;BufferedWriter&lt;/strong&gt;：提供了一个更大的缓冲区，提供了一个&lt;code&gt;newLine&lt;/code&gt;的方法用于换行，以&lt;strong&gt;屏蔽不同操作系统的差异性&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    public static void main(String[] args) throws Exception {
        //真正向文件中写数据的流是FileWriter,本身具有缓冲区
        //BufferedWriter 提供了更大的缓冲区
        BufferedWriter writer = new BufferedWriter(new FileWriter(&quot;E:\\b.txt&quot;));
        writer.write(&quot;天乔&quot;);
        //换行： Windows中换行是 \r\n   linux中只有\n
        //提供newLine() 统一换行
        writer.newLine();
        writer.write(&quot;巴夏&quot;);
        writer.close();
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;装饰设计模式&quot;&gt;装饰设计模式&lt;/h3&gt;
&lt;p&gt;缓冲流基于&lt;strong&gt;装饰设计模式&lt;/strong&gt;，即&lt;u&gt;利用同类对象构建本类对象，在本类中进行功能的改变或者增强。&lt;/u&gt;&lt;/p&gt;
&lt;p&gt;例如，&lt;strong&gt;BufferedReader本身就是Reader对象&lt;/strong&gt;，它接收了一个Reader对象构建自身，&lt;strong&gt;自身提供缓冲区&lt;/strong&gt;和&lt;strong&gt;其他新增方法&lt;/strong&gt;，通过减少磁盘读写次数来提高输入和输出的速度。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771072/202012/1771072-20201218003909688-1362911548.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;除此之外，字节流同样也存在缓冲流，分别是&lt;code&gt;BufferedInputStream&lt;/code&gt;和&lt;code&gt;BufferedOutputStream&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;转换流（适配器）&quot;&gt;转换流（适配器）&lt;/h2&gt;
&lt;p&gt;利用转换流可以&lt;strong&gt;实现字符流和字节流之间的转换&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;OutputStreamWriter&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    public static void main(String[] args) throws Exception {
        //在构建转换流时需要传入一个OutputStream  字节流
        OutputStreamWriter ow = 
                new OutputStreamWriter(
                        new FileOutputStream(&quot;D:\\b.txt&quot;),&quot;utf-8&quot;);
        //给定字符--&amp;gt; OutputStreamWriter转化为字节--&amp;gt;以字节流形式传入文件FileOutputStream
        //如果没有指定编码，默认使用当前工程的编码
        ow.write(&quot;天乔巴夏&quot;);
        ow.close();
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最终与文件接触的是字节流，意味着&lt;strong&gt;将传入的字符转换为字节&lt;/strong&gt;。&lt;/p&gt;
&lt;hr/&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;InputStreamReader&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    public static void main(String[] args) throws IOException {
        //以字节形式FileInputStream读取,经过转换InputStreamReader --&amp;gt;字符
        //如果没有指定编码。使用的是默认的工程的编码
        InputStreamReader ir = 
                new InputStreamReader(
                        new FileInputStream(&quot;D:\\b.txt&quot;));
        char[] cs = new char[5];
        int len;
        while((len=ir.read(cs))!=-1){
            System.out.println(new String(cs,0,len));
        }
        ir.close();
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最初与文件接触的是字节流，意味着&lt;strong&gt;将读取的字节转化为字符&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;适配器设计模式&quot;&gt;适配器设计模式&lt;/h3&gt;
&lt;p&gt;缓冲流基于&lt;strong&gt;适配器设计模式&lt;/strong&gt;，将某个类的接口转换另一个用户所希望的类的接口，让原本由于接口不兼容而不能在一起工作的类可以在一起进行工作。&lt;/p&gt;
&lt;p&gt;以&lt;code&gt;OutputStreamWriter为&lt;/code&gt;例，构建该转换流时需要传入一个字节流，而写入的数据最开始是由字符形式给定的，也就是说该转换流实现了从字符向字节的转换，让两个不同的类在一起共同办事。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771072/202012/1771072-20201218003917113-1976169718.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;标准流系统流&quot;&gt;标准流/系统流&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;程序的所有输入都可以来自于&lt;strong&gt;标准输入&lt;/strong&gt;，所有输出都可以发送到&lt;strong&gt;标准输出&lt;/strong&gt;，所有错误信息都可以发送到&lt;strong&gt;标准错误&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;标准流分类&quot;&gt;标准流分类&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;对象&lt;/th&gt;
&lt;th&gt;解释&lt;/th&gt;
&lt;th&gt;封装类型&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;System.in&lt;/td&gt;
&lt;td&gt;标准输入流&lt;/td&gt;
&lt;td&gt;InputStream&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;System.out&lt;/td&gt;
&lt;td&gt;标准输出流&lt;/td&gt;
&lt;td&gt;PrintStream&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;System.err&lt;/td&gt;
&lt;td&gt;标准错误流&lt;/td&gt;
&lt;td&gt;PrintStream&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;可以直接使用&lt;code&gt;System.out&lt;/code&gt;和&lt;code&gt;System.err&lt;/code&gt;，但是在读取&lt;code&gt;System.in&lt;/code&gt;之前必须对其进行封装，例如我们之前经常会使用的读取输入：&lt;code&gt;Scanner sc = new Scanner(System.in);&lt;/code&gt;实际上就封装了&lt;code&gt;System.in&lt;/code&gt;对象。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;标准流都是&lt;strong&gt;字节流&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;标准流对应的不是类而是对象。&lt;/li&gt;
&lt;li&gt;标准流在使用的时候不用关闭。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    /**
     * 从控制台获取一行数据
     * @throws IOException  readLine 可能会抛出异常
     */
    public static void getLine() throws IOException {
        //获取一行字符数据 -- BufferedReader
        //从控制台获取数据 -- System.in
        //System是字节流，BufferedReader在构建的时候需要传入字符流
        //将字节流转换为字符流
        BufferedReader br =
                new BufferedReader(
                        new InputStreamReader(System.in));
        //接收标准输入并转换为大写
        String str = br.readLine().toUpperCase();
        //发送到标准输出
        System.out.println(str);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过转换流，将System.in读取的标准输入字节流转化为字符流，发送到标准输出，打印显示。&lt;/p&gt;
&lt;h2 id=&quot;打印流&quot;&gt;打印流&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;打印流只有输出流没有输入流&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;PrintStream&lt;/strong&gt;: 打印字节流&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    public static void main(String[] args) throws IOException {
        //创建PrintStream对象
        PrintStream p = new PrintStream(&quot;D:\\b.txt&quot;);
        p.write(&quot;abc&quot;.getBytes());
        p.write(&quot;def&quot;.getBytes());
        p.println(&quot;abc&quot;);
        p.println(&quot;def&quot;);
        //如果打印对象，默认调用对象身上的toString方法
        p.println(new Object());
        p.close();
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;PrintWrite&lt;/strong&gt;r：打印字符流&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    //将System.out转换为PrintStream
    public static void main(String[] args) {
        //第二个参数autoFlash设置为true，否则看不到结果
        PrintWriter p = new PrintWriter(System.out,true);
        p.println(&quot;hello,world!&quot;);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;合并流&quot;&gt;合并流&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;SequenceInputStream&lt;/code&gt;用于将多个字节流合并为一个字节流的流。&lt;/li&gt;
&lt;li&gt;有两种构建方式：
&lt;ul&gt;&lt;li&gt;将多个合并的字节流放入一个&lt;code&gt;Enumeration&lt;/code&gt;中来进行。&lt;/li&gt;
&lt;li&gt;传入两个&lt;code&gt;InputStream&lt;/code&gt;对象。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;合并流只有输入流没有输出流。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以第一种构建方式为例，我们之前说过，&lt;code&gt;Enumeration&lt;/code&gt;可以通过Vector容器的&lt;code&gt;elements&lt;/code&gt;方法创建。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    public static void main(String[] args) throws IOException {
        FileInputStream in1 = new FileInputStream(&quot;D:\\1.txt&quot;);
        FileInputStream in2 = new FileInputStream(&quot;D:\\a.txt&quot;);
        FileInputStream in3 = new FileInputStream(&quot;D:\\b.txt&quot;);
        FileInputStream in4 = new FileInputStream(&quot;D:\\m.txt&quot;);

        FileOutputStream out = new FileOutputStream(&quot;D:\\union.txt&quot;);
        //准备一个Vector存储输入流
        Vector&amp;lt;InputStream&amp;gt; v = new Vector&amp;lt;&amp;gt;();
        v.add(in1);
        v.add(in2);
        v.add(in3);
        v.add(in4);

        //利用Vector产生Enumeration对象
        Enumeration&amp;lt;InputStream&amp;gt; e = v.elements();
        //利用迭代器构建合并流
        SequenceInputStream s = new SequenceInputStream(e);

        //读取
        byte[] bs = new byte[10];
        int len;
        while((len = s.read(bs))!=-1){
            out.write(bs,0,len);
        }
        out.close();
        s.close();
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;序列化反序列化流&quot;&gt;序列化/反序列化流&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;序列化&lt;/strong&gt;：将对象转化为字节数组的过程。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;反序列化&lt;/strong&gt;：将字节数组还原回对象的过程。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;序列化的意义&quot;&gt;序列化的意义&lt;/h3&gt;
&lt;p&gt;对象序列化的目标是将对象保存在磁盘中，或允许在网络中直接传输对象。对象序列化机制允许把内存中的Java对象转换成平台无关的二进制流，从而允许把这种二进制流持久地保存在磁盘上，通过网络将这种二进制流传输到另一个网络节点。其他程序一旦获得了这种流，都可以将这种二进制流恢复为原来的Java对象。&lt;/p&gt;
&lt;p&gt;让某个对象支持序列化的方法很简单，让它实现&lt;code&gt;Serializable&lt;/code&gt;接口即可：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface Serializable {
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个接口没有任何的方法声明，只是一个标记接口，表明实现该接口的类是可序列化的。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;我们通常在Web开发的时候，JavaBean可能会作为参数或返回在远程方法调用中，如果对象不可序列化会出错，因此，JavaBean需要实现Serializable接口。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;序列化对象&quot;&gt;序列化对象&lt;/h3&gt;
&lt;p&gt;创建一个Person类。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//必须实现Serializable接口
class Person implements Serializable {
    //序列化ID serialVersionUID
    private static final long serialVersionUID = 6402392549803169300L;
    private String name;
    private int age;

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建序列化流，将对象转化为字节，并写入&quot;D:\1.data&quot;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class ObjectOutputStreamDemo {
    public static void main(String[] args) throws IOException {
        Person p = new Person();
        p.setAge(18);
        p.setName(&quot;Niu&quot;);
        //创建序列化流
        //真正将数据写出的流是FileOutputStream
        //ObjectOutputStream将对象转化为字节
        ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;D:\\1.data&quot;));
        out.writeObject(p);
        out.close();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建反序列化流，将从&quot;D:\1.data&quot;中读取的字节转化为对象。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    public static void main(String[] args) throws IOException, ClassNotFoundException {
        //创建反序列化流
        //真正读取文件的是FileInputStream
        //ObjectInputStream将读取的字节转化为对象
        ObjectInputStream in = new ObjectInputStream(new FileInputStream(&quot;D:\\1.data&quot;));
        //读取数据必须进行数据类型的强制转换
        Person p = (Person)in.readObject();
        in.close();
        System.out.println(p.getName());//Niu
        System.out.println(p.getAge());//18

    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要注意的是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果一个对象要想被序列化，那么对应的类必须实现接口&lt;code&gt;serializable&lt;/code&gt;，该接口没有任何方法，仅仅作为标记使用。&lt;/li&gt;
&lt;li&gt;被&lt;code&gt;static&lt;/code&gt;或&lt;code&gt;transient&lt;/code&gt;修饰的属性不会进行序列化。如果属性的类型没有实现&lt;code&gt;serializable&lt;/code&gt;接口但是也没有用这两者修饰，会抛出&lt;code&gt;NotSerializableException&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;在对象序列化的时候，版本号会随着对象一起序列化出去，在反序列化的时候，对象中的版本号和类中的版本号进行比较，如果版本号一致，则允许反序列化。如果不一致，则抛出&lt;code&gt;InvalidClassException&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;集合允许被整体序列化 ，集合及其中元素会一起序列化出去。&lt;/li&gt;
&lt;li&gt;如果对象的成员变量是引用类型，这个引用类型也需要是可序列化的。&lt;/li&gt;
&lt;li&gt;当一个可序列化类存在父类时，这些父类要么有无参构造器，要么是需要可序列化的，否则将抛出&lt;code&gt;InvalidClassException&lt;/code&gt;的异常。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;关于版本号&quot;&gt;关于版本号&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;一个类如果允许被序列化，那么这个类中会产生一个版本号 &lt;code&gt;serialVersonUID&lt;/code&gt;。
&lt;ul&gt;&lt;li&gt;如果没有手动指定版本号，那么在编译的时候自动根据当前类中的属性和方法计算一个版本号，也就意味着一旦类中的属性发生改变，就会重新计算新的，导致前后不一致。&lt;/li&gt;
&lt;li&gt;但是，手动指定版本号的好处就是，不需要再计算版本号。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;版本号的意义在于防止类产生改动导致已经序列化出去的对象无法反序列化回来。版本号必须用&lt;code&gt;static final&lt;/code&gt;修饰，本身必须是&lt;code&gt;long&lt;/code&gt;类型。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;自定义序列化的两种方法&quot;&gt;自定义序列化的两种方法&lt;/h3&gt;
&lt;h4 id=&quot;serializable自定义&quot;&gt;Serializable自定义&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 实现writeObject和readObject两个方法
@Data
@AllArgsConstructor
@NoArgsConstructor
public class Person implements Serializable {

    private String name;
    private int age;

    // 将name的值反转后写入二进制流
    private void writeObject(ObjectOutputStream out) throws IOException {
        out.writeObject(new StringBuffer(name).reverse());
        out.writeInt(age);
    }

    // 将读取的字符串反转后赋给name
    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
        this.name = ((StringBuffer) in.readObject()).reverse().toString();
        this.age = in.readInt();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还有一种更加彻底的自定义机制，直接将序列化对象替换成其他的对象，需要定义&lt;code&gt;writeReplace&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Data
@AllArgsConstructor
@NoArgsConstructor
public class Person implements Serializable {

    private String name;
    private int age;

    private Object writeReplace(){
        ArrayList&amp;lt;Object&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        list.add(name);
        list.add(age);
        return list;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;externalizable自定义&quot;&gt;Externalizable自定义&lt;/h4&gt;
&lt;p&gt;Externalizable实现了Seriablizable接口，并规定了两个方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface Externalizable extends java.io.Serializable {

    void writeExternal(ObjectOutput out) throws IOException;

    void readExternal(ObjectInput in) throws IOException, ClassNotFoundException;
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实现该接口，并给出两个方法的实现，也可以实现自定义序列化。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Data
@NoArgsConstructor
@AllArgsConstructor
public class User implements Externalizable {

    String name;
    int age;

    @Override
    public void writeExternal(ObjectOutput out) throws IOException {
        out.writeObject(new StringBuffer(name).reverse());
        out.writeInt(age);
    }

    @Override
    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
        this.name = ((StringBuffer) in.readObject()).reverse().toString();
        this.age = in.readInt();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;参考阅读&quot;&gt;参考阅读&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;写在最后：如果本文有叙述错误之处，还望评论区批评指正，共同进步。&lt;/p&gt;
&lt;p&gt;参考资料：《Java 编程思想》、《Java语言程序设计》、《大话设计模式》、《疯狂Java讲义》&lt;/p&gt;
</description>
<pubDate>Thu, 17 Dec 2020 16:40:00 +0000</pubDate>
<dc:creator>天乔巴夏丶</dc:creator>
<og:description>什么是流？流表示任何有能力产生数据的数据源对象或者是有能力接收数据的接收端对象，它屏蔽了实际的I/O设备中处理数据的细节。 IO流是实现输入输出的基础，它可以很方便地实现数据的输入输出操作，即读写操作</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/summerday152/p/14152925.html</dc:identifier>
</item>
<item>
<title>自顶向下redis4.0（5）持久化 - dewxin</title>
<link>http://www.cnblogs.com/dewxin/p/TopDownRedis5.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dewxin/p/TopDownRedis5.html</guid>
<description>&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;虽然&lt;code&gt;redis&lt;/code&gt;是内存数据库，但它也提供了持久化的功能。其中&lt;code&gt;rdb&lt;/code&gt;持久化可以定时备份用于回滚，而&lt;code&gt;aof&lt;/code&gt;持久化则更接近数据库最新的状态，服务器重启后可以恢复至最新的状态。两者数据备份的粒度不同，&lt;code&gt;rdb&lt;/code&gt;将整个数据库备份，&lt;code&gt;aof&lt;/code&gt;持久化粒度更为小，但生成的文件更大。如果有多个线程同时向磁盘写入，那么会增大磁盘的压力，最终导致线程阻塞，因此&lt;code&gt;redis&lt;/code&gt;在同一时间只允许一个持久化向磁盘写入数据。&lt;code&gt;redis&lt;/code&gt;默认配置关闭&lt;code&gt;aof&lt;/code&gt;持久化，开启&lt;code&gt;rdb&lt;/code&gt;后台持久化。由于&lt;code&gt;aof&lt;/code&gt;持久化数据较新，所以如果开启了&lt;code&gt;aof&lt;/code&gt;持久化，&lt;code&gt;redis&lt;/code&gt;启动时会选择加载&lt;code&gt;aof&lt;/code&gt;文件中的数据。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# 默认关闭aof
appendonly no
#   after 900 sec (15 min) if at least 1 key changed
#   after 300 sec (5 min) if at least 10 keys changed
#   after 60 sec if at least 10000 keys changed
save 900 1
save 300 10
save 60 10000
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;正文&quot;&gt;正文&lt;/h2&gt;
&lt;h3 id=&quot;rdb持久化&quot;&gt;rdb持久化&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;redis&lt;/code&gt;允许&lt;code&gt;save&lt;/code&gt;命令和&lt;code&gt;bgsave&lt;/code&gt;命令，还支持配置定期保存&lt;code&gt;rdb&lt;/code&gt;数据。&lt;/p&gt;
&lt;h4 id=&quot;save命令&quot;&gt;save命令&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;save&lt;/code&gt;命令使用&lt;code&gt;saveCommand&lt;/code&gt;函数直接调用&lt;code&gt;rdbSave&lt;/code&gt;函数在主线程保存数据，线上模式不建议使用。在进一步介绍之前，我们先看一眼相关的成员。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;struct redisServer {
    /* RDB persistence */
    pid_t rdb_child_pid;            /* PID of RDB saving child */
    char *rdb_filename;             /* Name of RDB file */
    long long dirty;                /* Changes to DB from the last rdb save */
    time_t lastsave;                /* Unix time of last successful save */
    int lastbgsave_status;          /* C_OK or C_ERR */
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果已经有&lt;code&gt;rdb&lt;/code&gt;子进程在运行,则会直接返回。如果没有运行的子进程，则将数据存储到&lt;code&gt;server.rdb_filename&lt;/code&gt;文件中，默认为&lt;code&gt;dump.rdb&lt;/code&gt;。&lt;code&gt;rdbSave&lt;/code&gt;函数会打开一个临时文件，向其写入数据后，刷新数据到磁盘，然后重命名这个临时文件为&lt;code&gt;dump.rdb&lt;/code&gt;。然后重置&lt;code&gt;server.dirty&lt;/code&gt;为&lt;code&gt;0&lt;/code&gt;，设置&lt;code&gt;lastsave&lt;/code&gt;时间。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;void saveCommand(client *c) {
    if (server.rdb_child_pid != -1) {
        addReplyError(c,&quot;Background save already in progress&quot;);
        return;
    }

    if (rdbSave(server.rdb_filename,null) == C_OK) {
        addReply(c,shared.ok);
    } 
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体写入数据的操作位于&lt;code&gt;rdbSaveRio&lt;/code&gt;，它会先写入&lt;code&gt;rdb&lt;/code&gt;的版本，再写入一些辅助信息，然后将每个&lt;code&gt;db&lt;/code&gt;中的数据写入，最后写入校验码。&lt;/p&gt;
&lt;h4 id=&quot;bgsave命令&quot;&gt;bgsave命令&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;bgsave&lt;/code&gt;命令会调用&lt;code&gt;fork&lt;/code&gt;函数开启子进程，在子进程中调用&lt;code&gt;rdbSave&lt;/code&gt;函数。&lt;/p&gt;
&lt;p&gt;和&lt;code&gt;save&lt;/code&gt;命令相同，如果有正在运行的子进程在存储数据，则会返回错误提示。但如果使用&lt;code&gt;bgsave schedule&lt;/code&gt;命令并且当前的子进程为&lt;code&gt;aof&lt;/code&gt;，则可以延迟调用&lt;code&gt;bgsave&lt;/code&gt;命令。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;struct redisServer {
    ...
    /* RDB persistence */
    pid_t rdb_child_pid;            /* PID of RDB saving child */
    int child_info_pipe[2];         /* Pipe used to write the child_info_data. */
    struct {
        int process_type;           /* AOF or RDB child? */
        size_t cow_size;            /* Copy on write size. */
        unsigned long long magic;   /* Magic value to make sure data is valid. */
    } child_info_data;
    ...
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;后台启动&lt;code&gt;rdb&lt;/code&gt;就是调用&lt;code&gt;fork&lt;/code&gt;函数创建一个子进程，在子进程中调用&lt;code&gt;rdbSave&lt;/code&gt;函数。在调用&lt;code&gt;fork&lt;/code&gt;函数之前，&lt;code&gt;redis&lt;/code&gt;会先创建一个管道用于子进程向父进程的单向通信，&lt;code&gt;fork&lt;/code&gt;后的子进程会和父进程共享文件描述符，所以可以通过管道文件描述符单向通信。在子进程存储&lt;code&gt;db&lt;/code&gt;数据的时候，会修改内存空间，造成&lt;code&gt;copy-on-write&lt;/code&gt;，占用额外的内存空间，数据存储完成后，子进程会向父进程发送额外创建的内存大小。&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;code&gt;fork(2)
*  The child inherits copies of the parent's set of open file
 descriptors.  Each file descriptor in the child refers to the same
 open file description (see open(2)) as the corresponding file
 descriptor in the parent.  This means that the two file
 descriptors share open file status flags, file offset, and signal-
 driven I/O attributes (see the description of F_SETOWN and
 F_SETSIG in fcntl(2)).
&lt;/code&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;int rdbSaveBackground(char *filename, rdbSaveInfo *rsi) {
    pid_t childpid;
    long long start;

    if (server.aof_child_pid != -1 || server.rdb_child_pid != -1) return C_ERR;

    openChildInfoPipe(); // 创建管道

    start = ustime();
    if ((childpid = fork()) == 0) {
        //子进程
        int retval;

        closeListeningSockets(0); //因为会继承文件描述符，所以此处关闭套接字连接
        redisSetProcTitle(&quot;redis-rdb-bgsave&quot;);
        retval = rdbSave(filename,rsi);
        if (retval == C_OK) {
            size_t private_dirty = zmalloc_get_private_dirty(-1);
            
            server.child_info_data.cow_size = private_dirty;
            sendChildInfo(CHILD_INFO_TYPE_RDB);
        }
        exitFromChild((retval == C_OK) ? 0 : 1);
    } else {
        //父进程
        serverLog(LL_NOTICE,&quot;Background saving started by pid %d&quot;,childpid);
        server.rdb_save_time_start = time(NULL);
        server.rdb_child_pid = childpid;
        server.rdb_child_type = RDB_CHILD_TYPE_DISK;
        updateDictResizePolicy();
        return C_OK;
    }
    return C_OK; /* unreached */
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;父进程此时记录子进程id &lt;code&gt;rdb_child_pid&lt;/code&gt;和类型。然后在之前注册的时间事件&lt;code&gt;serverCron&lt;/code&gt;中检查子进程是否结束。&lt;code&gt;wait3&lt;/code&gt;等待子进程的状态发送改变，可能是运行结束了，也可能是被信号量暂停或者恢复了。如果子进程已经结束则接受子进程通过管道发送的信息，也就是&lt;code&gt;Copy-On-Write&lt;/code&gt;的大小。然后关闭管道。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;int serverCron(struct aeEventLoop *eventLoop, long long id, void *clientData) {
    ...
    //如果有子进程在全量存储数据
    if (server.rdb_child_pid != -1|| server.aof_child_pid != -1 ||
        ldbPendingChildren())
    {
        int statloc;
        pid_t pid;

        if ((pid = wait3(&amp;amp;statloc,WNOHANG,NULL)) != 0) {
            int exitcode = WEXITSTATUS(statloc);
            int bysignal = 0;

            if (WIFSIGNALED(statloc)) bysignal = WTERMSIG(statloc);
                        
            if (pid == server.rdb_child_pid) {
                backgroundSaveDoneHandler(exitcode,bysignal);
                if (!bysignal &amp;amp;&amp;amp; exitcode == 0) receiveChildInfo();
            } 
            updateDictResizePolicy();
            closeChildInfoPipe();
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于我们此处是&lt;code&gt;RDB&lt;/code&gt;存储（与之相对的是&lt;code&gt;AOF&lt;/code&gt;重写，但如果开启&lt;code&gt;RDB&lt;/code&gt;格式存储，两者几乎等价），&lt;code&gt;backgroundSaveDoneHandler&lt;/code&gt;会调用&lt;code&gt;backgroundSaveDoneHandlerDisk&lt;/code&gt;函数。这里会将&lt;code&gt;rdb_child_pid&lt;/code&gt;等数据重置，如果保存成功，则更新&lt;code&gt;server.dirty&lt;/code&gt;以及&lt;code&gt;lastsave&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;void backgroundSaveDoneHandlerDisk(int exitcode, int bysignal) {
    if (!bysignal &amp;amp;&amp;amp; exitcode == 0) {
        serverLog(LL_NOTICE,
            &quot;Background saving terminated with success&quot;);
        server.dirty = server.dirty - server.dirty_before_bgsave;
        server.lastsave = time(NULL);
        server.lastbgsave_status = C_OK;
    } else if (!bysignal &amp;amp;&amp;amp; exitcode != 0) {
        serverLog(LL_WARNING, &quot;Background saving error&quot;);
        server.lastbgsave_status = C_ERR;
    } else {
        mstime_t latency;

        serverLog(LL_WARNING,
            &quot;Background saving terminated by signal %d&quot;, bysignal);
        latencyStartMonitor(latency);
        rdbRemoveTempFile(server.rdb_child_pid);
        latencyEndMonitor(latency);
        latencyAddSampleIfNeeded(&quot;rdb-unlink-temp-file&quot;,latency);
        /* SIGUSR1 is whitelisted, so we have a way to kill a child without
         * tirggering an error conditon. */
        if (bysignal != SIGUSR1)
            server.lastbgsave_status = C_ERR;
    }
    server.rdb_child_pid = -1;
    server.rdb_child_type = RDB_CHILD_TYPE_NONE;
    server.rdb_save_time_last = time(NULL)-server.rdb_save_time_start;
    server.rdb_save_time_start = -1;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;rdb定期保存数据&quot;&gt;rdb定期保存数据&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;redis&lt;/code&gt;默认添加3个定期保存参数，如果使用&lt;code&gt;redis.conf&lt;/code&gt;，则会清空默认配置使用&lt;code&gt;redis.conf&lt;/code&gt;配置。如果&lt;code&gt;redis.conf&lt;/code&gt;中没有配置，则不会使用&lt;code&gt;rdb&lt;/code&gt;定期保存。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;appendServerSaveParams(60*60,1);  /* save after 1 hour and 1 change */
appendServerSaveParams(300,100);  /* save after 5 minutes and 100 changes */
appendServerSaveParams(60,10000); /* save after 1 minute and 10000 changes */
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同样是在&lt;code&gt;serverCron&lt;/code&gt;函数中，如果当前没有&lt;code&gt;aof&lt;/code&gt;或者&lt;code&gt;rdb&lt;/code&gt;子进程存储数据，则会检测条件是否满足。如果（距离上一次写入的时间和数据变更的数量满足条件）&lt;strong&gt;并且&lt;/strong&gt;（上一次写入成功或者距离上一次写入已经超过5秒钟，默认的&lt;code&gt;CONFIG_BGSAVE_RETRY_DELAY&lt;/code&gt;值） ,则启动&lt;code&gt;rdb&lt;/code&gt;序列化。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;    if (server.rdb_child_pid != -1 || server.aof_child_pid != -1 ||
        ldbPendingChildren())
    {
        ...
    } else {
        /* If there is not a background saving/rewrite in progress check if
         * we have to save/rewrite now. */
         for (j = 0; j &amp;lt; server.saveparamslen; j++) {
            struct saveparam *sp = server.saveparams+j;

            /* Save if we reached the given amount of changes,
             * the given amount of seconds, and if the latest bgsave was
             * successful or if, in case of an error, at least
             * CONFIG_BGSAVE_RETRY_DELAY seconds already elapsed. */
            if (server.dirty &amp;gt;= sp-&amp;gt;changes &amp;amp;&amp;amp;
                server.unixtime-server.lastsave &amp;gt; sp-&amp;gt;seconds &amp;amp;&amp;amp;
                (server.unixtime-server.lastbgsave_try &amp;gt;
                 CONFIG_BGSAVE_RETRY_DELAY || // 值为5
                 server.lastbgsave_status == C_OK))
            {
                serverLog(LL_NOTICE,&quot;%d changes in %d seconds. Saving...&quot;,
                    sp-&amp;gt;changes, (int)sp-&amp;gt;seconds);
                rdbSaveInfo rsi, *rsiptr;
                rsiptr = rdbPopulateSaveInfo(&amp;amp;rsi);
                rdbSaveBackground(server.rdb_filename,rsiptr);
                break;
            }
         }

         /* Trigger an AOF rewrite if needed. */
                        ...
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;进程结束保存数据&quot;&gt;进程结束保存数据&lt;/h4&gt;
&lt;p&gt;在&lt;code&gt;redis&lt;/code&gt;正常关闭的情况下（接受客户端&lt;code&gt;shutdown&lt;/code&gt;命令或者是收到&lt;code&gt;terminal&lt;/code&gt;信号），会调用&lt;code&gt;prepareForShutdown&lt;/code&gt;函数。该函数会关闭正在存储的子进程。如果有配置定期存储&lt;code&gt;rdb&lt;/code&gt;或者是关闭时有传入&lt;code&gt;save&lt;/code&gt;参数，则会在主线程中调用&lt;code&gt;rdbSave&lt;/code&gt;存储数据等，接着关闭进程。&lt;/p&gt;
&lt;p&gt;可以看到在使用&lt;code&gt;rdb&lt;/code&gt;保存数据之前，如果开启了&lt;code&gt;AOF&lt;/code&gt;，那么&lt;code&gt;redis&lt;/code&gt;会调用&lt;code&gt;flushAppendOnlyFile&lt;/code&gt;强制将数据写入磁盘，并调用&lt;code&gt;aof_fsync&lt;/code&gt;保证数据刷新。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;int prepareForShutdown(int flags) {
    int save = flags &amp;amp; SHUTDOWN_SAVE;
    int nosave = flags &amp;amp; SHUTDOWN_NOSAVE;

    serverLog(LL_WARNING,&quot;User requested shutdown...&quot;);

    /* Kill all the Lua debugger forked sessions. */
    ldbKillForkedSessions();

    /* Kill the saving child if there is a background saving in progress.
       We want to avoid race conditions, for instance our saving child may
       overwrite the synchronous saving did by SHUTDOWN. */
    if (server.rdb_child_pid != -1) {
        serverLog(LL_WARNING,&quot;There is a child saving an .rdb. Killing it!&quot;);
        kill(server.rdb_child_pid,SIGUSR1);
        rdbRemoveTempFile(server.rdb_child_pid);
    }

    if (server.aof_state != AOF_OFF) {
        /* Kill the AOF saving child as the AOF we already have may be longer
         * but contains the full dataset anyway. */
        if (server.aof_child_pid != -1) {
            /* If we have AOF enabled but haven't written the AOF yet, don't
             * shutdown or else the dataset will be lost. */
            if (server.aof_state == AOF_WAIT_REWRITE) {
                serverLog(LL_WARNING, &quot;Writing initial AOF, can't exit.&quot;);
                return C_ERR;
            }
            serverLog(LL_WARNING,
                &quot;There is a child rewriting the AOF. Killing it!&quot;);
            kill(server.aof_child_pid,SIGUSR1);
        }
        /* Append only file: flush buffers and fsync() the AOF at exit */
        serverLog(LL_NOTICE,&quot;Calling fsync() on the AOF file.&quot;);
        flushAppendOnlyFile(1);
        aof_fsync(server.aof_fd);
    }

    /* Create a new RDB file before exiting. */
    if ((server.saveparamslen &amp;gt; 0 &amp;amp;&amp;amp; !nosave) || save) {
        serverLog(LL_NOTICE,&quot;Saving the final RDB snapshot before exiting.&quot;);
        /* Snapshotting. Perform a SYNC SAVE and exit */
        rdbSaveInfo rsi, *rsiptr;
        rsiptr = rdbPopulateSaveInfo(&amp;amp;rsi);
        if (rdbSave(server.rdb_filename,rsiptr) != C_OK) {
            /* Ooops.. error saving! The best we can do is to continue
             * operating. Note that if there was a background saving process,
             * in the next cron() Redis will be notified that the background
             * saving aborted, handling special stuff like slaves pending for
             * synchronization... */
            serverLog(LL_WARNING,&quot;Error trying to save the DB, can't exit.&quot;);
            return C_ERR;
        }
    }

    /* Remove the pid file if possible and needed. */
    if (server.daemonize || server.pidfile) {
        serverLog(LL_NOTICE,&quot;Removing the pid file.&quot;);
        unlink(server.pidfile);
    }

    /* Best effort flush of slave output buffers, so that we hopefully
     * send them pending writes. */
    flushSlavesOutputBuffers();

    /* Close the listening sockets. Apparently this allows faster restarts. */
    closeListeningSockets(1);
    serverLog(LL_WARNING,&quot;%s is now ready to exit, bye bye...&quot;,
        server.sentinel_mode ? &quot;Sentinel&quot; : &quot;Redis&quot;);
    return C_OK;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;aof持久化&quot;&gt;aof持久化&lt;/h3&gt;
&lt;h4 id=&quot;数据缓冲区&quot;&gt;数据缓冲区&lt;/h4&gt;
&lt;p&gt;上文已经提到，&lt;code&gt;redis&lt;/code&gt;在解析客户端请求到&lt;code&gt;client-argc&lt;/code&gt;和&lt;code&gt;client-argv&lt;/code&gt;后会调用&lt;code&gt;processCommand&lt;/code&gt;检查请求命令的条件是否满足，如果满足，则会调用&lt;code&gt;call(client, CMD_CALL_FULL)&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;/* Command call flags, see call() function */
#define CMD_CALL_NONE 0
#define CMD_CALL_SLOWLOG (1&amp;lt;&amp;lt;0)
#define CMD_CALL_STATS (1&amp;lt;&amp;lt;1)
#define CMD_CALL_PROPAGATE_AOF (1&amp;lt;&amp;lt;2)
#define CMD_CALL_PROPAGATE_REPL (1&amp;lt;&amp;lt;3)
#define CMD_CALL_PROPAGATE (CMD_CALL_PROPAGATE_AOF|CMD_CALL_PROPAGATE_REPL)
#define CMD_CALL_FULL (CMD_CALL_SLOWLOG | CMD_CALL_STATS | CMD_CALL_PROPAGATE)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这里，我们观察一下&lt;code&gt;CMD_CALL_FULL&lt;/code&gt;，此时我们只需要知道，该值包含&lt;code&gt;CMD_CALL_PROPAGATE&lt;/code&gt;。在调用完命令后，&lt;code&gt;redis&lt;/code&gt;会根据情况将命令追加到&lt;code&gt;server-&amp;gt;aof_buf&lt;/code&gt;中，如果&lt;strong&gt;数据有发生改动&lt;/strong&gt;，命令没有禁止propagate，并且&lt;strong&gt;&lt;code&gt;redis&lt;/code&gt;开启了&lt;code&gt;aof&lt;/code&gt;&lt;/strong&gt;，则会将命令追加到缓冲区。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;call(client *c, int flags) {
        c-&amp;gt;cmd-&amp;gt;proc(c); //已经执行命令

        /* Propagate the command into the AOF and replication link */
    if (flags &amp;amp; CMD_CALL_PROPAGATE &amp;amp;&amp;amp; // flag 就是 CMD_CALL_FULL
        (c-&amp;gt;flags &amp;amp; CLIENT_PREVENT_PROP) != CLIENT_PREVENT_PROP)
    {
        int propagate_flags = PROPAGATE_NONE;

        //如果指令有造成数据变化
        if (dirty) propagate_flags |= (PROPAGATE_AOF|PROPAGATE_REPL);

        //有些命令强制propagete, 比如publishMessage
        if (c-&amp;gt;flags &amp;amp; CLIENT_FORCE_REPL) propagate_flags |= PROPAGATE_REPL;
        if (c-&amp;gt;flags &amp;amp; CLIENT_FORCE_AOF) propagate_flags |= PROPAGATE_AOF;

        //有些命令禁止在此处propagate，比如spop,会在其他函数操作
        if (c-&amp;gt;flags &amp;amp; CLIENT_PREVENT_REPL_PROP ||
            !(flags &amp;amp; CMD_CALL_PROPAGATE_REPL))
            propagate_flags &amp;amp;= ~PROPAGATE_REPL;
        if (c-&amp;gt;flags &amp;amp; CLIENT_PREVENT_AOF_PROP ||
            !(flags &amp;amp; CMD_CALL_PROPAGATE_AOF))
            propagate_flags &amp;amp;= ~PROPAGATE_AOF;

        /* Call propagate() only if at least one of AOF / replication
         * propagation is needed. Note that modules commands handle replication
         * in an explicit way, so we never replicate them automatically. */
        if (propagate_flags != PROPAGATE_NONE &amp;amp;&amp;amp; !(c-&amp;gt;cmd-&amp;gt;flags &amp;amp; CMD_MODULE))
            propagate(c-&amp;gt;cmd,c-&amp;gt;db-&amp;gt;id,c-&amp;gt;argv,c-&amp;gt;argc,propagate_flags);
    }
  
}

void propagate(struct redisCommand *cmd, int dbid, robj **argv, int argc,
               int flags)
{
    if (server.aof_state != AOF_OFF &amp;amp;&amp;amp; flags &amp;amp; PROPAGATE_AOF)
        feedAppendOnlyFile(cmd,dbid,argv,argc);
    if (flags &amp;amp; PROPAGATE_REPL)
        replicationFeedSlaves(server.slaves,dbid,argv,argc);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在追加命令之前，&lt;code&gt;redis&lt;/code&gt;还会做一些处理，如果命令对应的&lt;code&gt;db&lt;/code&gt;和上次追加命令的&lt;code&gt;db&lt;/code&gt;不同，则插入&lt;code&gt;select&lt;/code&gt;命令 。如果是&lt;code&gt;expire&lt;/code&gt;系列的命令，则全部切换成&lt;code&gt;pexpireat&lt;/code&gt;命令。如果是&lt;code&gt;setex&lt;/code&gt;命令，则拆分成&lt;code&gt;set&lt;/code&gt;和&lt;code&gt;pexpireat&lt;/code&gt;。如果此时没有子进程在重写，则写入到缓冲区，如果有子进程在重写，则尝试将数据发送给子进程。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;void feedAppendOnlyFile(struct redisCommand *cmd, int dictid, robj **argv, int argc) {
    sds buf = sdsempty();
    robj *tmpargv[3];

    /* The DB this command was targeting is not the same as the last command
     * we appended. To issue a SELECT command is needed. */
    if (dictid != server.aof_selected_db) {
        char seldb[64];

        snprintf(seldb,sizeof(seldb),&quot;%d&quot;,dictid);
        buf = sdscatprintf(buf,&quot;*2\r\n$6\r\nSELECT\r\n$%lu\r\n%s\r\n&quot;,
            (unsigned long)strlen(seldb),seldb);
        server.aof_selected_db = dictid;
    }

    if (cmd-&amp;gt;proc == expireCommand || cmd-&amp;gt;proc == pexpireCommand ||
        cmd-&amp;gt;proc == expireatCommand) {
        /* Translate EXPIRE/PEXPIRE/EXPIREAT into PEXPIREAT */
        buf = catAppendOnlyExpireAtCommand(buf,cmd,argv[1],argv[2]);
    } else if (cmd-&amp;gt;proc == setexCommand || cmd-&amp;gt;proc == psetexCommand) {
        /* Translate SETEX/PSETEX to SET and PEXPIREAT */
        tmpargv[0] = createStringObject(&quot;SET&quot;,3);
        tmpargv[1] = argv[1];
        tmpargv[2] = argv[3];
        buf = catAppendOnlyGenericCommand(buf,3,tmpargv);
        decrRefCount(tmpargv[0]);
        buf = catAppendOnlyExpireAtCommand(buf,cmd,argv[1],argv[2]);
    } else if (cmd-&amp;gt;proc == setCommand &amp;amp;&amp;amp; argc &amp;gt; 3) {
        int i;
        robj *exarg = NULL, *pxarg = NULL;
        /* Translate SET [EX seconds][PX milliseconds] to SET and PEXPIREAT */
        buf = catAppendOnlyGenericCommand(buf,3,argv);
        for (i = 3; i &amp;lt; argc; i ++) {
            if (!strcasecmp(argv[i]-&amp;gt;ptr, &quot;ex&quot;)) exarg = argv[i+1];
            if (!strcasecmp(argv[i]-&amp;gt;ptr, &quot;px&quot;)) pxarg = argv[i+1];
        }
        serverAssert(!(exarg &amp;amp;&amp;amp; pxarg));
        if (exarg)
            buf = catAppendOnlyExpireAtCommand(buf,server.expireCommand,argv[1],
                                               exarg);
        if (pxarg)
            buf = catAppendOnlyExpireAtCommand(buf,server.pexpireCommand,argv[1],
                                               pxarg);
    } else {

        buf = catAppendOnlyGenericCommand(buf,argc,argv);
    }

    /* Append to the AOF buffer. This will be flushed on disk just before
     * of re-entering the event loop, so before the client will get a
     * positive reply about the operation performed. */
    if (server.aof_state == AOF_ON)
        server.aof_buf = sdscatlen(server.aof_buf,buf,sdslen(buf));

    /* If a background append only file rewriting is in progress we want to
     * accumulate the differences between the child DB and the current one
     * in a buffer, so that when the child process will do its work we
     * can append the differences to the new append only file. */
    if (server.aof_child_pid != -1)
        aofRewriteBufferAppend((unsigned char*)buf,sdslen(buf));

    sdsfree(buf);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;刷新数据到磁盘&quot;&gt;刷新数据到磁盘&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;appendonly no #关闭aof


# 开启aof后生效
# appendfsync always  #aof 磁盘刷新策略
appendfsync everysec
# appendfsync no
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;redis&lt;/code&gt;默认关闭&lt;code&gt;aof&lt;/code&gt;，如果关闭&lt;code&gt;aof&lt;/code&gt;则&lt;code&gt;server-&amp;gt;aof_buf&lt;/code&gt;不会包含任何数据，只有开启了&lt;code&gt;aof&lt;/code&gt;，也就是&lt;code&gt;appendonly yes&lt;/code&gt;，才会往&lt;code&gt;aof&lt;/code&gt;中写入数据。&lt;/p&gt;
&lt;p&gt;在配置&lt;code&gt;appendonly yes&lt;/code&gt;之后，&lt;code&gt;appendfsync&lt;/code&gt;配置才会生效，&lt;code&gt;redis&lt;/code&gt;默认配置为&lt;code&gt;everysec&lt;/code&gt;，也就是每秒尝试后台线程&lt;strong&gt;刷新&lt;/strong&gt;数据到磁盘，但&lt;strong&gt;写入数据还是主线程写入的&lt;/strong&gt;，只要有数据且没有子线程在写入数据，就会写入数据。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;redis&lt;/code&gt;刷新磁盘的操作也放在&lt;code&gt;beforeSleep&lt;/code&gt;中处理。如果读者看过该系列之前的文章，应该记得&lt;code&gt;redis&lt;/code&gt;返回客户端数据并不是直接发送给客户端，而是先将数据保存在&lt;code&gt;client-&amp;gt;buf&lt;/code&gt;中，然后在下一轮的&lt;code&gt;aeMainLoop&lt;/code&gt;前的&lt;code&gt;beforeSleep&lt;/code&gt;函数中调用&lt;code&gt;handleClientsWithPendingWrites&lt;/code&gt;， 将数据返回给客户端。这样做的目的是为了兼容&lt;code&gt;appendfysync always&lt;/code&gt;的效果。所以在&lt;code&gt;beforeSleep&lt;/code&gt;函数中，刷新函数&lt;code&gt;flushAppendOnlyFile&lt;/code&gt;位于&lt;code&gt;handleClientsWithPendingWrites&lt;/code&gt;之前。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;void beforeSleep(struct aeEventLoop *eventLoop) {
    ...
    /* Write the AOF buffer on disk */
    flushAppendOnlyFile(0);

    /* Handle writes with pending output buffers. */
    handleClientsWithPendingWrites();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;刷新数据也有3种策略，下文会按照&lt;code&gt;no&lt;/code&gt;，&lt;code&gt;always&lt;/code&gt;，&lt;code&gt;everysec&lt;/code&gt;的顺序结合源码讲解。&lt;/p&gt;
&lt;h5 id=&quot;appendfsync-no&quot;&gt;appendfsync no&lt;/h5&gt;
&lt;p&gt;在不保证刷新的策略下，&lt;code&gt;redis&lt;/code&gt;也会调用&lt;code&gt;flushAppendOnly&lt;/code&gt;函数就等于直接调用&lt;code&gt;aofWrite(server.aof_fd,server.aof_buf,sdslen(server.aof_buf));&lt;/code&gt;将数据写入系统缓冲区，但文件是否刷新到磁盘，以及什么时候刷新由系统决定。由于调用&lt;code&gt;aofWrite&lt;/code&gt;可能会遇到磁盘空间不够的问题，&lt;code&gt;redis&lt;/code&gt;会对比传入的数据长度和写入的数据长度，如果没有全部写入，为了保证下一次加载&lt;code&gt;aof&lt;/code&gt;文件能够顺利，&lt;strong&gt;&lt;code&gt;reids&lt;/code&gt;会裁剪掉部分写入的数据，等待下次重新写入。&lt;/strong&gt;如果裁剪失败，则缩减&lt;code&gt;aof_buf&lt;/code&gt;的长度，删除&lt;code&gt;aof_buf&lt;/code&gt;中已经写入的部分，下次从最新的地方开始写入。并且如果写入系统缓冲区发送问题，则会在处理完问题后返回，而不会调用&lt;code&gt;aof_sync&lt;/code&gt;等刷新磁盘的函数。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;void flushAppendOnlyFile(int force) {
    ssize_t nwritten;
    int sync_in_progress = 0;
    mstime_t latency;

    if (sdslen(server.aof_buf) == 0) return;

    nwritten = aofWrite(server.aof_fd,server.aof_buf,sdslen(server.aof_buf));

    if (nwritten != (ssize_t)sdslen(server.aof_buf)) {
        static time_t last_write_error_log = 0;

        //有写入数据
        if (nwritten != -1) {
            //将刚才写入的数据裁剪掉
            
            //todo what will happen if system ftruncate the file some part is still in the memory not yet flushed to the disk
            if (ftruncate(server.aof_fd, server.aof_current_size) != -1) {
                //裁剪成功
                nwritten = -1;
            } 
            server.aof_last_write_errno = ENOSPC;
        }

        server.aof_last_write_status = C_ERR;
        //如果裁剪失败
        if (nwritten &amp;gt; 0) {
            server.aof_current_size += nwritten;
            sdsrange(server.aof_buf,nwritten,-1);
        }
        return; /* We'll try again on the next call... */
        
    }
    
    server.aof_current_size += nwritten;

    if ((sdslen(server.aof_buf)+sdsavail(server.aof_buf)) &amp;lt; 4000) {
        sdsclear(server.aof_buf);
    } else {
        sdsfree(server.aof_buf);
        server.aof_buf = sdsempty();
    }
    //下面是刷新磁盘的操作
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;appendfysnc-always&quot;&gt;appendfysnc always&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;always&lt;/code&gt;模式保证客户端接受返回数据后，&lt;code&gt;redis&lt;/code&gt;一定已经将数据变化刷新回磁盘。采用该模式相当于&lt;code&gt;redis&lt;/code&gt;在主线程中调用完&lt;code&gt;aofWrite&lt;/code&gt;函数后，紧接着调用了&lt;code&gt;aof_sync&lt;/code&gt;函数，也就是&lt;code&gt;fsync&lt;/code&gt;系列的函数。该模式迫使&lt;code&gt;redis&lt;/code&gt;在主线程访问磁盘，会导致性能极具下降。并且&lt;code&gt;always&lt;/code&gt;的容错性较差，&lt;strong&gt;如果&lt;code&gt;aofWrite&lt;/code&gt;没有将&lt;code&gt;aof_buf&lt;/code&gt;中的全部数据写入，&lt;code&gt;redis&lt;/code&gt;会立刻退出。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190516233655801.png&quot; alt=&quot;磁盘 内存 访问时间&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;appendfysnc-everysec&quot;&gt;appendfysnc everysec&lt;/h5&gt;
&lt;p&gt;每秒刷新一次数据到磁盘是&lt;code&gt;redis&lt;/code&gt;的默认配置，它会尝试每秒刷新文件到磁盘。由于&lt;code&gt;flushAppendOnlyFile&lt;/code&gt;在&lt;code&gt;serverCron&lt;/code&gt;中被调用，而&lt;code&gt;serverCron&lt;/code&gt;的频率为10次/秒，所以&lt;code&gt;redis&lt;/code&gt;默认写入数据的频率和刷新数据的频率为10:1。如果开启了&lt;code&gt;aof_no_fsync_on_rewrite&lt;/code&gt;，则不会在有子进程全量存储的时候（包括&lt;code&gt;rdb&lt;/code&gt;存储和&lt;code&gt;aof&lt;/code&gt;重写）同步增量&lt;code&gt;aof&lt;/code&gt;数据。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;void flushAppendOnlyFile(int force) {
    ssize_t nwritten;
    int sync_in_progress = 0;
    mstime_t latency;

    if (sdslen(server.aof_buf) == 0) return;

    // 查看是否有子线程在同步数据
    if (server.aof_fsync == AOF_FSYNC_EVERYSEC)
        sync_in_progress = bioPendingJobsOfType(BIO_AOF_FSYNC) != 0;

    if (server.aof_fsync == AOF_FSYNC_EVERYSEC &amp;amp;&amp;amp; !force) {
        if (sync_in_progress) {
            
            //如果有另外的线程在写入数据，则等待一个postponed的循环和2秒
            if (server.aof_flush_postponed_start == 0) {
                server.aof_flush_postponed_start = server.unixtime;
                return;
            } else if (server.unixtime - server.aof_flush_postponed_start &amp;lt; 2) {
                return;
            }
            //如果还没有处理完，则继续写入，实际上会阻塞
        }
    }

    nwritten = aofWrite(server.aof_fd,server.aof_buf,sdslen(server.aof_buf));

    server.aof_flush_postponed_start = 0;

    if (nwritten != (ssize_t)sdslen(server.aof_buf)) {
        //上文已经介绍，如果写入的数据不全，则返回
        ...
        return; /* We'll try again on the next call... */
    } 

    //此时数据已写入系统缓冲区，刷新`aof_buf`的缓冲区
    sdsfree(server.aof_buf);
    server.aof_buf = sdsempty();

    /* Don't fsync if no-appendfsync-on-rewrite is set to yes and there are
     * children doing I/O in the background. */
    if (server.aof_no_fsync_on_rewrite &amp;amp;&amp;amp;
        (server.aof_child_pid != -1 || server.rdb_child_pid != -1))
            return;

    if ((server.aof_fsync == AOF_FSYNC_EVERYSEC &amp;amp;&amp;amp;
                server.unixtime &amp;gt; server.aof_last_fsync)) {
        if (!sync_in_progress) aof_background_fsync(server.aof_fd);
        server.aof_last_fsync = server.unixtime;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;redis&lt;/code&gt;在将数据写入磁盘时，会在主线程调用&lt;code&gt;write&lt;/code&gt;函数，然后在另外的线程中调用&lt;code&gt;fsync&lt;/code&gt;函数。这样能够让另外一个线程阻塞在&lt;code&gt;IO&lt;/code&gt;上而不影响主线程的操作，但需要注意的是如果另一个线程&lt;code&gt;fsync&lt;/code&gt;函数如果没有返回，主线程就调用&lt;code&gt;write&lt;/code&gt;函数，那么主线程也会阻塞在&lt;code&gt;write&lt;/code&gt;函数上。&lt;sup&gt;[4]&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;《Redis开发与运维》&lt;sup&gt;[3]&lt;/sup&gt;中提到&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;通过对AOF阻塞流程可以发现两个问题：&lt;/p&gt;
&lt;p&gt;1） everysec配置最多可能丢失2秒数据， 不是1秒&lt;/p&gt;
&lt;p&gt;2） 如果系统fsync缓慢， 将会导致Redis主线程阻塞影响效率。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;实际上在&lt;code&gt;redis&lt;/code&gt;4.0版本中，&lt;code&gt;everysec&lt;/code&gt;配置最多可能丢失2秒加上一个&lt;code&gt;aeMainLoop&lt;/code&gt;循环的时间。虽然《Redis开发与运维》指出了两个问题，但实际上它们是同一个问题，那就是&lt;strong&gt;磁盘写入速度无法承受过量的数据&lt;/strong&gt;。在使用&lt;code&gt;everysec&lt;/code&gt;配置时，如果发生这个问题，&lt;code&gt;redis&lt;/code&gt;首先考虑主线程的运行，如果距离上一次延迟写入的时间戳&lt;code&gt;aof_flush_postponed_start&lt;/code&gt;小于2秒，那么先跳过这一次的写入，避免阻塞以保证主线程能够处理请求。如果2秒后数据还没有从缓冲区刷新到磁盘，那么将会调用&lt;code&gt;aofWrite&lt;/code&gt;导致主线程阻塞。&lt;/p&gt;
&lt;h3 id=&quot;aof重写&quot;&gt;aof重写&lt;/h3&gt;
&lt;h4 id=&quot;aof重写的配置&quot;&gt;aof重写的配置&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;aof&lt;/code&gt;重写可以输入指令触发&lt;code&gt;bgrewriteaof&lt;/code&gt;，也可以配置条件触发重写。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;auto-aof-rewrite-min-size 64mb
auto-aof-rewrite-percentage 100
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;仅仅这两个配置还不能了解清楚&lt;code&gt;redis&lt;/code&gt;何时重写，我们还需要有&lt;code&gt;aof_current_size&lt;/code&gt;和&lt;code&gt;aof_base_size&lt;/code&gt;，&lt;code&gt;aof_current_size&lt;/code&gt;就是&lt;code&gt;aof&lt;/code&gt;文件当前的大小，&lt;code&gt;redis&lt;/code&gt;启动加载&lt;code&gt;aof&lt;/code&gt;文件或者每次&lt;code&gt;aof&lt;/code&gt;追加数据都会更新这个值，这个值并不会存储到磁盘中，&lt;code&gt;aof_base_size&lt;/code&gt;也是同理，如果启动时有加载&lt;code&gt;aof&lt;/code&gt;文件，那么&lt;code&gt;aof_base_size&lt;/code&gt;的值就是&lt;code&gt;aof&lt;/code&gt;文件的大小。&lt;/p&gt;
&lt;p&gt;当&lt;code&gt;aof_current_size&lt;/code&gt;&amp;gt;&lt;code&gt;auto-aof-rewrite-min-size&lt;/code&gt;并且有配置&lt;code&gt;auto-aof-rewrite-percentage&lt;/code&gt;时，如果(&lt;code&gt;aof_current_size&lt;/code&gt;-&lt;code&gt;aof_base_size&lt;/code&gt;)/&lt;code&gt;100&lt;/code&gt; &amp;gt;= &lt;code&gt;percentage&lt;/code&gt;，则会自动重写。比如按照上文的配置，&lt;code&gt;redis&lt;/code&gt;启动时加载的&lt;code&gt;aof&lt;/code&gt;文件大小为&lt;code&gt;100mb&lt;/code&gt;，那么&lt;code&gt;aof_base_size&lt;/code&gt;就是&lt;code&gt;100mb&lt;/code&gt;，当&lt;code&gt;redis&lt;/code&gt;文件增长到&lt;code&gt;200mb&lt;/code&gt;的时候就会自动重写。&lt;/p&gt;
&lt;p&gt;但是会存在这样一种情况，&lt;code&gt;redis&lt;/code&gt;文件增长到&lt;code&gt;199mb&lt;/code&gt;的时候，刚好重启了，那么下次启动的时候，&lt;code&gt;aof_base_size&lt;/code&gt;就和&lt;code&gt;aof_current_size&lt;/code&gt;大小相等，想要触发自动重写，就要等到&lt;code&gt;redis&lt;/code&gt;文件大小增长到&lt;code&gt;400mb&lt;/code&gt;左右。&lt;strong&gt;如果数据增长地比较缓慢，或者是百分比配置较大&lt;/strong&gt;。在触发重写之前，&lt;code&gt;redis&lt;/code&gt;就关闭或者重启了。那么&lt;code&gt;aof_base_size&lt;/code&gt;下次启动的时候会被刷新成&lt;code&gt;aof_current_size&lt;/code&gt;的大小，&lt;strong&gt;导致可能永远无法触发自动重写。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;aof重写的优先级&quot;&gt;aof重写的优先级&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;aof&lt;/code&gt;重写的优先级低于&lt;code&gt;rdb&lt;/code&gt;，如果两者的触发条件同时满足，&lt;code&gt;redis&lt;/code&gt;会优先处理&lt;code&gt;rdb&lt;/code&gt;存储。观察源代码，可以发现&lt;code&gt;rdb&lt;/code&gt;存储先于&lt;code&gt;aof&lt;/code&gt;，如果&lt;code&gt;rdb&lt;/code&gt;此处触发，即使&lt;code&gt;aof&lt;/code&gt;触发重写的条件满足，因为&lt;code&gt;server.rdb_child_pid&lt;/code&gt;将不为&lt;code&gt;-1&lt;/code&gt;，导致无法进入&lt;code&gt;aof&lt;/code&gt;重写。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;serverCron(aeEventLoop*, longlong, void*) {
        if (server.rdb_child_pid != -1 || server.aof_child_pid != -1 ||
        ldbPendingChildren()) {
            //... 检查子进程是否结束并处理。
        } else {
            /* If there is not a background saving/rewrite in progress check if
             * we have to save/rewrite now. */
             for (j = 0; j &amp;lt; server.saveparamslen; j++) {
                ...
                //..处理rdb自动存储
             }

             /* Trigger an AOF rewrite if needed. */
             if (server.aof_state == AOF_ON &amp;amp;&amp;amp;
                 server.rdb_child_pid == -1 &amp;amp;&amp;amp;
                 server.aof_child_pid == -1 &amp;amp;&amp;amp;
                 server.aof_rewrite_perc &amp;amp;&amp;amp;
                 server.aof_current_size &amp;gt; server.aof_rewrite_min_size)
             {
                long long base = server.aof_rewrite_base_size ?
                                server.aof_rewrite_base_size : 1;
                long long growth = (server.aof_current_size*100/base) - 100;
                if (growth &amp;gt;= server.aof_rewrite_perc) {
                    serverLog(LL_NOTICE,&quot;Starting automatic rewriting of AOF on %lld%% growth&quot;,growth);
                    rewriteAppendOnlyFileBackground();
                }
             }
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;aof-重写的来龙去脉&quot;&gt;aof 重写的来龙去脉&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;rewriteAppendOnlyFileBackground&lt;/code&gt;会创建许多管道用于父子间通信。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;childInfoPipe&lt;/code&gt;用于子进程向父进程提示有多少个&lt;code&gt;Copy-On-Write&lt;/code&gt;内存。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;aof_pipe_write_data_to_child&lt;/code&gt;用于父进程向&lt;code&gt;aof&lt;/code&gt;重写子进程发送最近的数据变更。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;aof_pipe_write_ack_to_parent&lt;/code&gt;和&lt;code&gt;aof_pipe_write_ack_to_child&lt;/code&gt;用于等待彼此的确认消息。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;并且注册了&lt;code&gt;aof_pipe_read_ack_from_child&lt;/code&gt;的文件事件，&lt;strong&gt;当子进程向父进程发送中止请求的时候，就会调用&lt;code&gt;aof_pipe_read_ack_from_child&lt;/code&gt;函数。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;int aofCreatePipes(void) {
    int fds[6] = {-1, -1, -1, -1, -1, -1};
    int j;

    if (pipe(fds) == -1) goto error; /* parent -&amp;gt; children data. */
    if (pipe(fds+2) == -1) goto error; /* children -&amp;gt; parent ack. */
    if (pipe(fds+4) == -1) goto error; /* parent -&amp;gt; children ack. */
    /* Parent -&amp;gt; children data is non blocking. */
    if (anetNonBlock(NULL,fds[0]) != ANET_OK) goto error;
    if (anetNonBlock(NULL,fds[1]) != ANET_OK) goto error;
    
    //注意：
    //这里注册了一个文件事件
    if (aeCreateFileEvent(server.el, fds[2], AE_READABLE, aofChildPipeReadable, NULL) == AE_ERR) goto error;

    server.aof_pipe_write_data_to_child = fds[1];
    server.aof_pipe_read_data_from_parent = fds[0];
    server.aof_pipe_write_ack_to_parent = fds[3];
    server.aof_pipe_read_ack_from_child = fds[2];
    server.aof_pipe_write_ack_to_child = fds[5];
    server.aof_pipe_read_ack_from_parent = fds[4];
    server.aof_stop_sending_diff = 0;
    return C_OK;

error:
    serverLog(LL_WARNING,&quot;Error opening /setting AOF rewrite IPC pipes: %s&quot;,
        strerror(errno));
    for (j = 0; j &amp;lt; 6; j++) if(fds[j] != -1) close(fds[j]);
    return C_ERR;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;父进程&lt;/strong&gt; 创建完子进程后，父进程会更新&lt;code&gt;aof_child_pid&lt;/code&gt;记录子进程&lt;code&gt;id&lt;/code&gt;，虽然只更新了一个字段，但意味着已经开启了一个很有可能影响&lt;code&gt;redis&lt;/code&gt;性能的任务。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;子进程 &lt;strong&gt;先向临时文件写入当前数据库的内容，如果开启了&lt;code&gt;aof_use_rdb_preamble&lt;/code&gt;（默认关闭，但建议开启），那么就会写入&lt;code&gt;rdb&lt;/code&gt;数据，也就是&lt;code&gt;db&lt;/code&gt;数据全量存储，否则按&lt;code&gt;aof&lt;/code&gt;追加模式，全量存储&lt;code&gt;db&lt;/code&gt;中的内容，&lt;/strong&gt;接着刷新数据到磁盘，阻塞。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;//in function rewriteAppendOnlyFile(char* filename)
if (server.aof_use_rdb_preamble) {
    int error;
    if (rdbSaveRio(&amp;amp;aof,&amp;amp;error,RDB_SAVE_AOF_PREAMBLE,NULL) == C_ERR) {
        errno = error;
        goto werr;
    }
} else {
    if (rewriteAppendOnlyFileRio(&amp;amp;aof) == C_ERR) goto werr;
}

/* Do an initial slow fsync here while the parent is still sending
     * data, in order to make the next final fsync faster. */
if (fflush(fp) == EOF) goto werr;
if (fsync(fileno(fp)) == -1) goto werr;
&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;父进程&lt;/strong&gt; 在&lt;code&gt;aof&lt;/code&gt;子进程等待数据刷新的时候，继续处理请求，并且将数据追加到&lt;code&gt;server.aof_rewrite_buf_blocks&lt;/code&gt;，如果没有注册&lt;code&gt;aof_pipe_write_data_to_child&lt;/code&gt;（是个管道，也就是文件描述符）文件事件的话，会将该管道和&lt;code&gt;aofChildWriteDiffData&lt;/code&gt;绑定，如果管道可写，则会将&lt;code&gt;server.aof_rewrite_buf_blocks&lt;/code&gt;中的数据写入管道发送给子进程。&lt;strong&gt;这样保证了父进程不会因为向管道写入数据而阻塞&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;/* Append data to the AOF rewrite buffer, allocating new blocks if needed. */
void aofRewriteBufferAppend(unsigned char *s, unsigned long len) {
    listNode *ln = listLast(server.aof_rewrite_buf_blocks);
    aofrwblock *block = ln ? ln-&amp;gt;value : NULL;

    while(len) {
       ...
       // 一直将数据写入aof_rewrite_buf_block
    }

        //注册文件事件
    if (aeGetFileEvents(server.el,server.aof_pipe_write_data_to_child) == 0) {
        aeCreateFileEvent(server.el, server.aof_pipe_write_data_to_child,
            AE_WRITABLE, aofChildWriteDiffData, NULL);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;子进程&lt;/strong&gt; 刷新完之前的数据后，会在1秒内一直读取来自父进程的数据，将其写入到&lt;code&gt;aof_child_diff&lt;/code&gt;中。然后向父进程发送&lt;strong&gt;停发数据&lt;/strong&gt;请求。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;//in function rewriteAppendOnlyFile(char* filename)
mstime_t start = mstime();
while(mstime()-start &amp;lt; 1000 &amp;amp;&amp;amp; nodata &amp;lt; 20) {
    if (aeWait(server.aof_pipe_read_data_from_parent, AE_READABLE, 1) &amp;lt;= 0)
    {
        nodata++;
        continue;
    }
    nodata = 0; /* Start counting from zero, we stop on N *contiguous*
                       timeouts. */
    aofReadDiffFromParent();
}
if (write(server.aof_pipe_write_ack_to_parent,&quot;!&quot;,1) != 1) goto werr;

&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;父进程&lt;/strong&gt; 在&lt;code&gt;aeMainLoop&lt;/code&gt;中检测到&lt;code&gt;aof_pipe_read_ack_from_child&lt;/code&gt;管道可读事件（在创建管道的时候注册，请看前文），调用&lt;code&gt;aofChildPipeReadable&lt;/code&gt;函数，将&lt;code&gt;aof_stop_sending_diff&lt;/code&gt;设置为1，父进程不会再将&lt;code&gt;aof_rewrite_buf_blocks&lt;/code&gt;缓冲区的内容写给子进程。并向子进程发送消息表示已经收到停发请求。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;子进程&lt;/strong&gt; 接受到父进程的同意后，&lt;strong&gt;最后读取一次数据&lt;/strong&gt;，因为在父进程接受到停发请求前可能又发送了数据。至此，停发请求前的额外&lt;code&gt;aof&lt;/code&gt;增量数据都已写入&lt;code&gt;aof_child_diff&lt;/code&gt;。接着子进程将其写入文件并刷新，退出子进程。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;if (syncRead(server.aof_pipe_read_ack_from_parent,&amp;amp;byte,1,5000) != 1 ||
    byte != '!') goto werr;
aofReadDiffFromParent();
if (rioWrite(&amp;amp;aof,server.aof_child_diff,sdslen(server.aof_child_diff)) == 0)
    goto werr;

/* Make sure data will not remain on the OS's output buffers */
if (fflush(fp) == EOF) goto werr;
if (fsync(fileno(fp)) == -1) goto werr;
if (fclose(fp) == EOF) goto werr;
&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;父进程&lt;/strong&gt; 在&lt;code&gt;serverCron&lt;/code&gt;函数中调用&lt;code&gt;wait3&lt;/code&gt;检测到&lt;code&gt;aof&lt;/code&gt;重写子进程的退出，会调用&lt;code&gt;backgroundRewriteDoneHandler&lt;/code&gt;处理。&lt;br/&gt;它首先会打开之前保存的临时文件，将中止请求后的追加数据&lt;code&gt;aof_rewrite_buf_blocks&lt;/code&gt;写入文件（&lt;strong&gt;注意：虽然子进程之前请求中止发送数据了，但因为&lt;code&gt;rdb_child_pid&lt;/code&gt;直到现在还是保存的子进程的id，会一直接受追加数据到&lt;code&gt;aof_rewrite_buf_blocks&lt;/code&gt;&lt;/strong&gt;）。此时已经将所有的数据都写入&lt;code&gt;aof&lt;/code&gt;临时文件。接下来就是将临时文件替换为&lt;code&gt;aof&lt;/code&gt;保存的文件名。&lt;/p&gt;
&lt;h3 id=&quot;rdb对比aof&quot;&gt;rdb对比aof&lt;/h3&gt;
&lt;p&gt;官网有一篇文章&lt;a href=&quot;https://redis.io/topics/persistence&quot; target=&quot;_blank&quot;&gt;《persistence》&lt;/a&gt;已经做了比对，在此不再赘述。&lt;/p&gt;
&lt;h2 id=&quot;参考文献&quot;&gt;参考文献&lt;/h2&gt;
&lt;p&gt;[1]&lt;a href=&quot;https://github.com/dewxin/redis&quot; target=&quot;_blank&quot;&gt;《Redis 源码》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[2]&lt;a href=&quot;https://book.douban.com/subject/26971561/&quot; target=&quot;_blank&quot;&gt;《Redis开发与运维》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[3]&lt;a href=&quot;https://book.douban.com/subject/25900156/&quot; target=&quot;_blank&quot;&gt;《Redis设计与实现》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[4]&lt;a href=&quot;http://oldblog.antirez.com/post/fsync-different-thread-useless.html&quot; target=&quot;_blank&quot;&gt;《fsync() on a different thread: apparently a useless trick》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[5]&lt;a href=&quot;https://stackoverflow.com/questions/17594183/what-does-private-dirty-memory-mean-in-smaps&quot; target=&quot;_blank&quot;&gt;《private dirty memory》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[6]&lt;a href=&quot;https://linux.die.net/man/2/pipe&quot; target=&quot;_blank&quot;&gt;《pipe(2) - Linux man page》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[7]&lt;a href=&quot;https://linux.die.net/man/2/wait3&quot; target=&quot;_blank&quot;&gt;《wait3(2) - Linux man page》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[8]&lt;a href=&quot;https://linux.die.net/man/3/ftruncate&quot; target=&quot;_blank&quot;&gt;《ftruncate(3) - Linux man page》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[9]&lt;a href=&quot;https://redis.io/topics/persistence&quot; target=&quot;_blank&quot;&gt;《Redis persistence》&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 17 Dec 2020 14:19:00 +0000</pubDate>
<dc:creator>dewxin</dc:creator>
<og:description>redis4.0的持久化 简介 虽然redis是内存数据库，但它也提供了持久化的功能。其中rdb持久化可以定时备份用于回滚，而aof持久化则更接近数据库最新的状态，服务器重启后可以恢复至最新的状态。两</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/dewxin/p/TopDownRedis5.html</dc:identifier>
</item>
<item>
<title>synchronized实现原理及ReentrantLock源码 - 曹自标</title>
<link>http://www.cnblogs.com/caozibiao/p/14150661.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/caozibiao/p/14150661.html</guid>
<description>&lt;h4 id=&quot;synchronized&quot;&gt;synchronized&lt;/h4&gt;
&lt;h6 id=&quot;synchronized的作用范围&quot;&gt;synchronized的作用范围&lt;/h6&gt;
&lt;pre&gt;
&lt;code&gt;public class SynchronizedTest {
    // 实例方法，方法访问标志ACC_SYNCHRONIZED,锁对象是对象实例
    public synchronized void test1(){}
    // 静态方法，方法访问标志ACC_SYNCHRONIZED,锁对象是MetaSpace中的Class
    // 相当于类的全局锁，会锁住所有调用该方法的线程
    public synchronized static void test2(){}

    public void test3() {
        //同步代码块，在代码块前增加monitorenter指令，代码块后增加monitorexit指令
        SynchronizedTest synchronizedTest = new SynchronizedTest();
        synchronized (synchronizedTest) {}
        // 类锁，效果等同于锁静态方法。代码块前后增加monitorenter、monitorexit指令
        synchronized (SynchronizedTest.class) {}
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可jclasslib查看Acc_SYNCHRONIZED标志和monitorenter、monitorexit指令&lt;/p&gt;
&lt;p&gt;test1 方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Access flags： 0x0021[public synchronized]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;test2 方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Access flags： 0x0029[public static synchronized]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;test3方法Code操作码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; 0 new #2 &amp;lt;com/java/study/jvm/SynchronizedTest&amp;gt;
 3 dup
 4 invokespecial #3 &amp;lt;com/java/study/jvm/SynchronizedTest.&amp;lt;init&amp;gt;&amp;gt;
 7 astore_1
 8 aload_1
 9 dup
10 astore_2
11 monitorenter
12 aload_2
13 monitorexit
14 goto 22 (+8)
17 astore_3
18 aload_2
19 monitorexit
20 aload_3
21 athrow
22 ldc #2 &amp;lt;com/java/study/jvm/SynchronizedTest&amp;gt;
24 dup
25 astore_2
26 monitorenter
27 aload_2
28 monitorexit
29 goto 39 (+10)
32 astore 4
34 aload_2
35 monitorexit
36 aload 4
38 athrow
39 return
&lt;/code&gt;
&lt;/pre&gt;
&lt;h6 id=&quot;synchronized实现&quot;&gt;synchronized实现&lt;/h6&gt;
&lt;p&gt;核心组件&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Wait Set：哪些调用 wait方法被阻塞的线程被放置在这里&lt;/li&gt;
&lt;li&gt;Contention List： 竞争队列，所有请求锁的线程首先被放在这个竞争队列中&lt;/li&gt;
&lt;li&gt;Entry List： Contention List 中那些有资格成为候选资源的线程被移动到 Entry List 中&lt;/li&gt;
&lt;li&gt;OnDeck：任意时刻， 最多只有一个线程正在竞争锁资源，该线程被成为 OnDeck&lt;/li&gt;
&lt;li&gt;Owner：当前已经获取到所资源的线程被称为 Owner&lt;/li&gt;
&lt;li&gt;!Owner：当前释放锁的线程&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;图示过程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2211828/202012/2211828-20201217135731347-1804767041.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;解释：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;JVM 每次从队列的尾部取出一个数据用于锁竞争候选者（OnDeck），但是并发情况下，ContentionList 会被大量的并发线程进行 CAS 访问，为了降低对尾部元素的竞争， JVM 会将一部分线程移动到 EntryList 中作为候选竞争线程。&lt;/li&gt;
&lt;li&gt;Owner 线程会在 unlock 时，将 ContentionList 中的部分线程迁移到 EntryList 中，并指定EntryList 中的某个线程为 OnDeck 线程（一般是最先进去的那个线程）。&lt;/li&gt;
&lt;li&gt;Owner 线程并不直接把锁传递给 OnDeck 线程，而是把锁竞争的权利交给 OnDeck，OnDeck 需要重新竞争锁。这样虽然牺牲了一些公平性，但是能极大的提升系统的吞吐量，在JVM 中，也把这种选择行为称之为“竞争切换”。&lt;/li&gt;
&lt;li&gt;OnDeck 线程获取到锁资源后会变为 Owner 线程，而没有得到锁资源的仍然停留在 EntryList中。如果 Owner 线程被 wait 方法阻塞，则转移到 WaitSet 队列中，直到某个时刻通过 notify或者 notifyAll 唤醒，会重新进去 EntryList 中。&lt;/li&gt;
&lt;li&gt;处于 ContentionList、 EntryList、 WaitSet 中的线程都处于阻塞状态，该阻塞是由操作系统来完成的（Linux 内核下采用 pthread_mutex_lock 内核函数实现的）。&lt;/li&gt;
&lt;li&gt;Synchronized 是非公平锁。 Synchronized 在线程进入 ContentionList 时， 等待的线程会先尝试自旋获取锁，如果获取不到就进入 ContentionList，这明显对于已经进入队列的线程是不公平的，还有一个不公平的事情就是自旋获取锁的线程还可能直接抢占 OnDeck 线程的锁资源。&lt;br/&gt;参考： &lt;a href=&quot;https://blog.csdn.net/zqz_zqz/article/details/70233767&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/zqz_zqz/article/details/70233767&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;每个对象都有个 monitor 对象， 加锁就是在竞争 monitor 对象，代码块加锁是在前后分别加上 monitorenter 和 monitorexit 指令来实现的，方法加锁是通过一个标记位来判断的&lt;/li&gt;
&lt;li&gt;synchronized 是一个重量级操作，需要调用操作系统相关接口，性能是低效的，有可能给线程加锁消耗的时间比有用操作消耗的时间更多。&lt;/li&gt;
&lt;li&gt;Java1.6， synchronized 进行了很多的优化， 有适应自旋、锁消除、锁粗化、轻量级锁及偏向锁等，效率有了本质上的提高。在之后推出的 Java1.7 与 1.8 中，均对该关键字的实现机理做了优化。引入了偏向锁和轻量级锁。都是在对象头中有标记位，不需要经过操作系统加锁。&lt;/li&gt;
&lt;li&gt;锁可以从偏向锁升级到轻量级锁，再升级到重量级锁。这种升级过程叫做锁膨胀；&lt;/li&gt;
&lt;li&gt;JDK 1.6 中默认是开启偏向锁和轻量级锁，可以通过-XX:-UseBiasedLocking 来禁用偏向锁&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;reentrantlock&quot;&gt;ReentrantLock&lt;/h4&gt;
&lt;p&gt;ReentrantLock初始化时，会new一个同步类（默认非公平NonfairSync，当传入公平参数fair=true时，则new公平类FairSync）；而FairSync 和NonfairSync都继承ReentrantLock中内部类Sync，Sync则继承同步器AbstractQueuedSynchronizer。UML图如下（&lt;a href=&quot;https://www.cnblogs.com/zhimingyang/p/5702752.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/zhimingyang/p/5702752.html&lt;/a&gt; 截取）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2211828/202012/2211828-20201217135803447-1477260052.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;lock流程图非公平锁示例&quot;&gt;Lock流程图(非公平锁示例)&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2211828/202012/2211828-20201217220522854-1106183660.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h6 id=&quot;源码&quot;&gt;源码&lt;/h6&gt;
&lt;ol&gt;&lt;li&gt;ReentrantLock$NonfairSync#lock(),当state为0，即compareAndSetState(0, 1)为true时，获得锁；否则进行下一步&lt;/li&gt;
&lt;li&gt;ReentrantLock$NonfairSync#acquire() ——&amp;gt; AbstractQueuedSynchronizer#acquire() --&amp;gt; ReentrantLock$NonfairSync#tryAcquire() --&amp;gt;&lt;br/&gt;ReentrantLock$Sync#nonfairTryAcquire(), 第2次尝试获取锁&lt;/li&gt;
&lt;li&gt;在上面acquire方法中，还会调用addWaiter方法，将一个排他锁加入队列&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;public class ReentrantLock implements Lock, java.io.Serializable {
    
    abstract static class Sync extends AbstractQueuedSynchronizer {
        final boolean nonfairTryAcquire(int acquires) {
            final Thread current = Thread.currentThread();
            int c = getState();
            if (c == 0) {
                //第2次尝试获取锁
                if (compareAndSetState(0, acquires)) {
                    setExclusiveOwnerThread(current);
                    return true;
                }
            }
            else if (current == getExclusiveOwnerThread()) {
                int nextc = c + acquires;
                if (nextc &amp;lt; 0) // overflow
                    throw new Error(&quot;Maximum lock count exceeded&quot;);
                setState(nextc);
                return true;
            }
            return false;
        }
    }
        
    static final class NonfairSync extends Sync {
    
        final void lock() {
            // 可不进入队列，直接抢锁
            if (compareAndSetState(0, 1))
                setExclusiveOwnerThread(Thread.currentThread());
            else
                acquire(1);
        }
    
        protected final boolean tryAcquire(int acquires) {
            return nonfairTryAcquire(acquires);
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;public abstract class AbstractQueuedSynchronizer
    extends AbstractOwnableSynchronizer
    implements java.io.Serializable {
    
    public final void acquire(int arg) {
        // 步骤3，加入等待队列，默认排他锁
        if (!tryAcquire(arg) &amp;amp;&amp;amp;
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
            selfInterrupt();
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而继续addWaiter、enq和acquireQueued则是实现以下图示过程：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2211828/202012/2211828-20201217215348776-495982590.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    private Node addWaiter(Node mode) {
        Node node = new Node(Thread.currentThread(), mode);
        // Try the fast path of enq; backup to full enq on failure
        Node pred = tail;
        if (pred != null) {
            node.prev = pred;
            if (compareAndSetTail(pred, node)) {
                pred.next = node;
                return node;
            }
        }
        //前置节点为null的临界条件，第一个线程进入等待队列
        enq(node);
        return node;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;前置节点为null的临界条件，第一个线程进入等待队列，进行初始化&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    private Node enq(final Node node) {
        for (;;) {
            Node t = tail;
            if (t == null) { // Must initialize
                //队列初始化
                if (compareAndSetHead(new Node()))
                    tail = head;
            } else {
                //双向链表添加元素
                node.prev = t;
                if (compareAndSetTail(t, node)) {
                    t.next = node;
                    return t;
                }
            }
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;    final boolean acquireQueued(final Node node, int arg) {
        boolean failed = true;
        try {
            boolean interrupted = false;
            for (;;) {
                final Node p = node.predecessor();
                if (p == head &amp;amp;&amp;amp; tryAcquire(arg)) {
                    setHead(node);
                    p.next = null; // help GC
                    failed = false;
                    return interrupted;
                }
                if (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;
                    parkAndCheckInterrupt())
                    interrupted = true;
            }
        } finally {
            if (failed)
                cancelAcquire(node);
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;node属性值介绍：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2211828/202012/2211828-20201217215628600-1474600701.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;对应源码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public abstract class AbstractQueuedSynchronizer
    extends AbstractOwnableSynchronizer
    implements java.io.Serializable {
    static final class Node {
        
        static final Node EXCLUSIVE = null;
        static final int CANCELLED =  1;
        static final int SIGNAL    = -1;
        static final int CONDITION = -2;
        static final int PROPAGATE = -3;

        volatile int waitStatus;
        volatile Node prev;
        volatile Node next;
        volatile Thread thread;
        Node nextWaiter;

        final boolean isShared() {
            return nextWaiter == SHARED;
        }

        final Node predecessor() throws NullPointerException {
            Node p = prev;
            if (p == null)
                throw new NullPointerException();
            else
                return p;
        }

        Node() {    // Used to establish initial head or SHARED marker
        }

        Node(Thread thread, Node mode) {     // Used by addWaiter
            this.nextWaiter = mode;
            this.thread = thread;
        }

        Node(Thread thread, int waitStatus) { // Used by Condition
            this.waitStatus = waitStatus;
            this.thread = thread;
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h6 id=&quot;重入锁的实现&quot;&gt;重入锁的实现&lt;/h6&gt;
&lt;p&gt;重入锁的可重复进入在以下代码中实现(非公平锁示例，公平锁代码一样)：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;c &amp;gt; 0, 即有锁，并且获取锁的线程就是当前线程，则将state加1，并更新&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;final boolean nonfairTryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    int c = getState();
    if (c == 0) {
        ...
    }
    // c &amp;gt; 0
    else if (current == getExclusiveOwnerThread()) {
        int nextc = c + acquires;
        if (nextc &amp;lt; 0) // overflow
            throw new Error(&quot;Maximum lock count exceeded&quot;);
        setState(nextc);
        return true;
    }
    return false;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h6 id=&quot;公平锁和非公平锁&quot;&gt;公平锁和非公平锁&lt;/h6&gt;
&lt;p&gt;第一处不公平地方(lock方法)：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;非公平锁lock时，如果发现没有锁了，即state为0，可以不管队列，直接compareAndSetState，如果获取true了(抢到锁)，直接获得锁，不用进同步器中的队列。&lt;/li&gt;
&lt;li&gt;而公平锁没有此逻辑。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;static final class NonfairSync extends Sync {

    final void lock() {
        // 可不进入队列，直接抢锁
        if (compareAndSetState(0, 1))
            setExclusiveOwnerThread(Thread.currentThread());
        else
            acquire(1);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;static final class FairSync extends Sync {
    final void lock() {
        acquire(1);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第二处不公平的地方(tryAcquire)：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;非公平锁tryAcquire方法会调用Sync#nonfairTryAcquire()，当state为0，发现锁被释放时，可直接抢锁&lt;/li&gt;
&lt;li&gt;公平锁则必须满足!hasQueuedPredecessors()条件，也即必须同步器中队列没有线程在等待，才去获取锁&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;static final class NonfairSync extends Sync {
    protected final boolean tryAcquire(int acquires) {
        return nonfairTryAcquire(acquires);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;abstract static class Sync extends AbstractQueuedSynchronizer {
    final boolean nonfairTryAcquire(int acquires) {
        final Thread current = Thread.currentThread();
        int c = getState();
        if (c == 0) {
            //发现锁被释放时，可直接抢锁
            if (compareAndSetState(0, acquires)) {
                setExclusiveOwnerThread(current);
                return true;
            }
        }
        ...
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;公平锁&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;static final class FairSync extends Sync {
    protected final boolean tryAcquire(int acquires) {
        final Thread current = Thread.currentThread();
        int c = getState();
        if (c == 0) {
            // 必须同步器中队列没有线程在等待，才去获取锁
            if (!hasQueuedPredecessors() &amp;amp;&amp;amp;
                compareAndSetState(0, acquires)) {
                setExclusiveOwnerThread(current);
                return true;
            }
        }
        ...
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第三处不公平地方，加入队列时，前置节点是头节点：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    final boolean acquireQueued(final Node node, int arg) {
        boolean failed = true;
        try {
            boolean interrupted = false;
            for (;;) {
                final Node p = node.predecessor();
                if (p == head &amp;amp;&amp;amp; tryAcquire(arg)) {
                ...
                }
            }
    }
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 17 Dec 2020 14:08:00 +0000</pubDate>
<dc:creator>曹自标</dc:creator>
<og:description>synchronized synchronized的作用范围 public class SynchronizedTest { // 实例方法，方法访问标志ACC_SYNCHRONIZED,锁对象是对象</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/caozibiao/p/14150661.html</dc:identifier>
</item>
</channel>
</rss>