<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>JVM的方法执行引擎-entry point栈帧  - HotSpot-Researcher</title>
<link>http://www.cnblogs.com/mazhimazhi/p/13516634.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mazhimazhi/p/13516634.html</guid>
<description>&lt;p&gt;接着上一篇去讲，回到JavaCalls::call_helper()中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
address entry_point = method-&amp;gt;from_interpreted_entry();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;entry_point是从当前要执行的Java方法中获取的，定义如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
源代码位置：/openjdk/hotspot/src/share/vm/oops/method.hpp
volatile address from_interpreted_entry() const{ 
      return (address)OrderAccess::load_ptr_acquire(&amp;amp;_from_interpreted_entry); 
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么_from_interpreted_entry是何时赋值的？之前在介绍方法连接时简单介绍过，在method.hpp中有这样一个set方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
void set_interpreter_entry(address entry) { 
    _i2i_entry = entry;  
    _from_interpreted_entry = entry; 
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在连接方法时通过如下的方法调用上面的方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
// Called when the method_holder is getting linked. Setup entrypoints so the method
// is ready to be called from interpreter, compiler, and vtables.
void Method::link_method(methodHandle h_method, TRAPS) {
  // ...
  address entry = Interpreter::entry_for_method(h_method);
  assert(entry != NULL, &quot;interpreter entry must be non-null&quot;);
  // Sets both _i2i_entry and _from_interpreted_entry
  set_interpreter_entry(entry);
  // ...
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;根据注释都可以得知，当方法连接时，会去设置方法的entry_point，entry_point是通过调用Interpreter::entry_for_method()方法得到，这个方法的实现如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
static address entry_for_method(methodHandle m)  { 
     return entry_for_kind(method_kind(m)); 
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;首先通过method_kind()拿到方法类型，然后调用entry_for_kind()方法根据方法类型获取方法入口entry point。调用的entry_for_kind()方法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
static address entry_for_kind(MethodKind k){ 
      return _entry_table[k]; 
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里直接返回了_entry_table数组中对应方法类型的entry_point地址。给数组中元素赋值专门有个方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
void AbstractInterpreter::set_entry_for_kind(AbstractInterpreter::MethodKind kind, address entry) {
  _entry_table[kind] = entry;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么何时会调用set_entry_for_kind ()呢，答案就在TemplateInterpreterGenerator::generate_all()中，generate_all()会调用generate_method_entry()去生成每种方法的entry_point，所有Java方法的执行，都会通过对应类型的entry_point例程来辅助。下面来详细介绍一下generate_all()方法的实现逻辑。　&lt;/p&gt;
&lt;p&gt;HotSpot在启动时，会为所有字节码创建在特定目标平台上运行的机器码，并存放在CodeCache中，在解释执行字节码的过程中，就会从CodeCache中取出这些本地机器码并执行。&lt;/p&gt;
&lt;p&gt;在启动虚拟机阶段会调用init_globals()方法初始化全局模块，在这个方法中通过调用interpreter_init()方法初始化模板解释器，调用栈如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
TemplateInterpreter::initialize()    templateInterpreter.cpp
interpreter_init()                   interpreter.cpp
init_globals()                       init.cpp
Threads::create_vm()                 thread.cpp
JNI_CreateJavaVM()                   jni.cpp
InitializeJVM()                      java.c
JavaMain()                           java.c
start_thread()                       pthread_create.c   
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;interpreter_init()方法主要是通过调用TemplateInterpreter::initialize()方法来完成逻辑，initialize()方法的实现如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
源代码位置：/src/share/vm/interpreter/templateInterpreter.cpp

void TemplateInterpreter::initialize() {
  if (_code != NULL) 
       return;

  // 抽象解释器AbstractInterpreter的初始化，AbstractInterpreter是基于汇编模型的解释器的共同基类，
  // 定义了解释器和解释器生成器的抽象接口
  AbstractInterpreter::initialize();

  // 模板表TemplateTable的初始化，模板表TemplateTable保存了各个字节码的模板
  TemplateTable::initialize();

  // generate interpreter
  {
     ResourceMark rm;
     int code_size = InterpreterCodeSize;
     // CodeCache的Stub队列StubQueue的初始化
     _code = new StubQueue(new InterpreterCodeletInterface, code_size, NULL,&quot;Interpreter&quot;);
     //  实例化模板解释器生成器对象TemplateInterpreterGenerator
     InterpreterGenerator g(_code);
  }

  // initialize dispatch table
  _active_table = _normal_table;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;模板解释器的初始化包括如下几个方面：&lt;/p&gt;
&lt;p&gt;（1）抽象解释器AbstractInterpreter的初始化，AbstractInterpreter是基于汇编模型的解释器的共同基类，定义了解释器和解释器生成器的抽象接口。&lt;/p&gt;
&lt;p&gt;（2）模板表TemplateTable的初始化，模板表TemplateTable保存了各个字节码的模板（目标代码生成函数和参数）；&lt;/p&gt;
&lt;p&gt;（3）CodeCache的Stub队列StubQueue的初始化；&lt;/p&gt;
&lt;p&gt;（4）解释器生成器InterpreterGenerator的初始化。&lt;/p&gt;
&lt;p&gt;在执行InterpreterGenerator g(_code)代码时，调用InterpreterGenerator的构造函数，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
InterpreterGenerator::InterpreterGenerator(StubQueue* code) : TemplateInterpreterGenerator(code) {
   generate_all(); // down here so it can be &quot;virtual&quot;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调用的generate_all()方法将生成一系列HotSpot运行过程中所执行的一些公共代码的入口和所有字节码的InterpreterCodelet。这些入口包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;error exits：出错退出处理入口&lt;/li&gt;
&lt;li&gt;字节码追踪入口(配置了-XX:+TraceBytecodes)&lt;/li&gt;
&lt;li&gt;函数返回入口&lt;/li&gt;
&lt;li&gt;JVMTI的EarlyReturn入口&lt;/li&gt;
&lt;li&gt;逆优化调用返回入口&lt;/li&gt;
&lt;li&gt;native调用返回值处理handlers入口&lt;/li&gt;
&lt;li&gt;continuation入口&lt;/li&gt;
&lt;li&gt;safepoint入口&lt;/li&gt;
&lt;li&gt;异常处理入口&lt;/li&gt;
&lt;li&gt;抛出异常入口&lt;/li&gt;
&lt;li&gt;方法入口（native方法和非native方法）&lt;/li&gt;
&lt;li&gt;字节码入口&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;部分重要的入口实现逻辑会在后面详细介绍，这里只看为非native方法入口（也就是普通的、没有native关键字修饰的Java方法）生成入口的逻辑。generate_all()方法中有如下调用语句：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
#define method_entry(kind)                                                                    \
  {                                                                                           \
    CodeletMark cm(_masm, &quot;method entry point (kind = &quot; #kind &quot;)&quot;);                           \
    Interpreter::_entry_table[Interpreter::kind] = generate_method_entry(Interpreter::kind);  \
  }　　

method_entry(zerolocals)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中method_entry是宏，扩展后如上的调用语句变为如下的形式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
Interpreter::_entry_table[Interpreter::zerolocals] = generate_method_entry(Interpreter::zerolocals);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;_entry_table变量定义在AbstractInterpreter类中，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
// method entry points
static address    _entry_table[number_of_method_entries];     // entry points for a given method
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;number_of_method_entries表示方法类型的总数，使用方法类型做为数组下标就可以获取对应的方法入口。调用generate_method_entry()方法为各个类型的方法生成对应的方法入口，实现如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
address AbstractInterpreterGenerator::generate_method_entry(AbstractInterpreter::MethodKind kind) {
  // determine code generation flags
  bool                   synchronized = false;
  address                entry_point = NULL;
  InterpreterGenerator*  ig_this = (InterpreterGenerator*)this;

  switch (kind) { // 根据方法类型kind生成不同的入口
  case Interpreter::zerolocals             : // zerolocals表示普通方法类型
          break;
  case Interpreter::zerolocals_synchronized: // zerolocals表示普通的、同步方法类型
          synchronized = true;
          break;
  // ...
  }

  if (entry_point) {
     return entry_point;
  }

  return ig_this-&amp;gt;generate_normal_entry(synchronized);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;zerolocals表示正常的Java方法调用（包括Java程序的主函数），对于zerolocals来说，会调用ig_this-&amp;gt;generate_normal_entry()方法生成入口。generate_normal_entry()方法会为执行的方法生成堆栈，而堆栈由局部变量表（用来存储传入的参数和被调用函数的局部变量）、帧数据和操作数栈这三大部分组成，所以方法会创建这3部分来辅助Java方法的执行。&lt;/p&gt;
&lt;p&gt;之前在介绍CallStub栈帧时讲到过，如果要执行entry_point，那么栈帧的状态就如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1236123/202008/1236123-20200817151341774-735894985.png&quot; alt=&quot;&quot; width=&quot;519&quot; height=&quot;650&quot; loading=&quot;lazy&quot;/&gt; &lt;/p&gt;
&lt;p&gt;/src/cpu/x86/vm/templateInterpreter_x86_64.cpp文件中generate_normal_entry()方法在通过CallStub调用时，各个寄存器的状态如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
rbx -&amp;gt; Method*
r13 -&amp;gt; sender sp
rsi -&amp;gt; entry point　　
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;generate_normal_entry()方法的实现如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;53&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
// Generic interpreted method entry to (asm) interpreter
address InterpreterGenerator::generate_normal_entry(bool synchronized) {
  // determine code generation flags
  bool inc_counter  = UseCompiler || CountCompiledCalls;
 
  // 执行如下方法前的寄存器中保存的值如下：
  // ebx: Method*
  // r13: sender sp  
  address entry_point = __ pc();   // entry_point函数的代码入口地址
 
  // 当前rbx中存储的是指向Method的指针，通过Method*找到ConstMethod*
  const Address constMethod(rbx, Method::const_offset()); 
  // 通过Method*找到AccessFlags
  const Address access_flags(rbx, Method::access_flags_offset()); 
  // 通过ConstMethod*得到parameter的大小
  const Address size_of_parameters(rdx,ConstMethod::size_of_parameters_offset());
  // 通过ConstMethod*得到local变量的大小
  const Address size_of_locals(rdx, ConstMethod::size_of_locals_offset());
 
  // 上面已经说明了获取各种方法元数据的计算方式，但并没有执行计算，下面会生成对应的汇编来执行计算
  // get parameter size (always needed)
  __ movptr(rdx, constMethod);                     // 计算ConstMethod*，保存在rdx里面
  __ load_unsigned_short(rcx, size_of_parameters); // 计算parameter大小，保存在rcx里面
  //rbx：保存基址；rcx：保存循环变量；rdx：保存目标地址；rax：保存返回地址（下面用到）
 
  // 此时的各个寄存器中的值如下：
  // rbx: Method*
  // rcx: size of parameters
  // r13: sender_sp (could differ from sp+wordSize if we were called via c2i ) 即调用者的栈顶地址
  // 计算local变量的大小，保存到rdx
__ load_unsigned_short(rdx, size_of_locals);
  // 由于局部变量表用来存储传入的参数和被调用函数的局部变量，所以rdx减去rcx后就是被调用函数的局部变量可使用的大小 
  __ subl(rdx, rcx); 
 
 
  // see if we've got enough room on the stack for locals plus overhead.
  generate_stack_overflow_check();
 
  //返回地址是在call_stub中保存的，如果不弹出堆栈到rax，那么局部变量区就如下面的样子：
  // [parameter 1]
  // [parameter 2]
  // ......
  // [parameter n]
  // [return address]
  // [local 1]
  // [local 2]
  // ...
  // [local n]
  // 显然中间有个return address使的局部变量表不是连续的，这会导致其中的局部变量计算方式不一致，所以暂时将返回地址存储到rax中
  // get return address
  __ pop(rax);
 
  // compute beginning of parameters (r14)
  // 计算第1个参数的地址：当前栈顶地址 + 变量大小 * 8 - 一个字大小。
  // 这儿注意，因为地址保存在低地址上，而堆栈是向低地址扩展的，所以只需加n-1个变量大小就可以得到第1个参数的地址。
  __ lea(r14, Address(rsp, rcx, Address::times_8, -wordSize));
 
  // 把函数的局部变量全置为0,也就是做初始化，防止之前遗留下的值影响
  // rdx：被调用函数的局部变量可使用的大小
  // allocate space for locals
  // explicitly initialize locals
  {
    Label exit, loop;
    __ testl(rdx, rdx);
    __ jcc(Assembler::lessEqual, exit); // do nothing if rdx &amp;lt;= 0
    __ bind(loop);
    __ push((int) NULL_WORD); // initialize local variables
    __ decrementl(rdx); // until everything initialized
    __ jcc(Assembler::greater, loop);
    __ bind(exit);
  }
 
  // 生成固定桢
  // initialize fixed part of activation frame
  generate_fixed_frame(false);
 
  // 省略统计及栈溢出等逻辑，后面会详细介绍
 
  // check for synchronized methods
  // Must happen AFTER invocation_counter check and stack overflow check,
  // so method is not locked if overflows.
  if (synchronized) {
    // Allocate monitor and lock method
    lock_method();
  } else {
    // no synchronization necessary
  }

  // 跳转到目标Java方法的第一条字节码指令，并执行其对应的机器指令
   __ dispatch_next(vtos);
 
  // 省略统计相关逻辑，后面会详细介绍
 
  return entry_point;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;要对偏移的计算进行研究，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
// 当前rbx中存储的是指向Method的指针，通过Method*找到ConstMethod*
const Address constMethod(rbx, Method::const_offset()); 
// 通过Method*找到AccessFlags
const Address access_flags(rbx, Method::access_flags_offset()); 
// 通过ConstMethod*得到parameter的大小
const Address size_of_parameters(rdx,ConstMethod::size_of_parameters_offset());
// 通过ConstMethod*得到local变量的大小
const Address size_of_locals(rdx, ConstMethod::size_of_locals_offset());
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果要打印这个方法生成的汇编代码，可以在方法的return语句之前添加如下2句打印代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
address end =  __ pc();
Disassembler::decode(entry_point, end);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样，在执行Disassembler::decode()方法时，会将此方法生成的机器码转换为汇编打印到控制台上。&lt;/p&gt;
&lt;p&gt;调用generate_fixed_frame()方法之前生成的汇编代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;45&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
Loaded disassembler from /home/mazhi/workspace/openjdk/build/linux-x86_64-normal-server-slowdebug/jdk/lib/amd64/server/hsdis-amd64.so
[Disassembling for mach='i386:x86-64']
  0x00007fffe101e2e0: mov    0x10(%rbx),%rdx // 通过%rbx中保存的Method*找到ConstMethod并保存到%rdx
  0x00007fffe101e2e4: movzwl 0x2a(%rdx),%ecx // 通过ConstMethod*找到入参数量保存在%ecx
  0x00007fffe101e2e8: movzwl 0x28(%rdx),%edx // 通过ConstMethod*找到本地变量表大小保存在%edx
  0x00007fffe101e2ec: sub    %ecx,%edx       // 计算方法局部变量可使用的本地变量空间的大小并保存在%edx

  // ... 省略调用generate_stack_overflow_check()方法生成的汇编

  0x00007fffe101e43d: pop    %rax                   // 弹出返回地址
  0x00007fffe101e43e: lea    -0x8(%rsp,%rcx,8),%r14 // 计算第一个参数的地址
  // 为局部变量slot(不包括方法入参）分配堆栈空间并初始化为0
  //  循环进行本地变量表空间的开辟
  // -- loop --
  0x00007fffe101e443: test   %edx,%edx  
  0x00007fffe101e445: jle    0x00007fffe101e454 // 由于%edx的大小等于0,所以不需要额外分配，直接跳转到exit
  0x00007fffe101e44b: pushq  $0x0
  0x00007fffe101e450: dec    %edx
  0x00007fffe101e452: jg     0x00007fffe101e44b　// 如果%edx的大小不等于0,跳转到loop　
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在栈的状态如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1236123/202008/1236123-20200817161829798-1059959091.png&quot; alt=&quot;&quot; width=&quot;445&quot; height=&quot;681&quot; loading=&quot;lazy&quot;/&gt; &lt;/p&gt;
&lt;p&gt; 现在r14指向局部变量开始的位置，而argument和local variable都存储在了局部变量表，rbp指向了局部变量表结束位置。现在各个寄存器的状态如下：　&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
rax: return address  // %rax寄存器中存储的是返回地址return address
rbx: Method*
r14: pointer to locals
r13: sender sp
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在InterpreterGenerator::generate_normal_entry()函数中，接下来会以这样的状态调用generate_fixed_frame()函数来创建Java方法运行时所需要的栈帧。generate_fixed_frame()函数会在下一篇详细介绍。&lt;/p&gt;
&lt;p&gt;调用后栈帧变为如下的状态：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1236123/202008/1236123-20200817165956867-1169609550.png&quot; alt=&quot;&quot; width=&quot;703&quot; height=&quot;584&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图右边的栈状态随着具体方法的不同会显示不同的状态，不过大概的状态就是上图所示的样子。&lt;/p&gt;
&lt;p&gt;调用完generate_fixed_frame()方法后一些寄存器中保存的值如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
rbx：Method*
ecx：invocation counter
r13：bcp(byte code pointer)
rdx：ConstantPool* 常量池的地址
r14：本地变量表第1个参数的地址
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行完generate_fixed_frame()方法后会继续执行InterpreterGenerator::generate_normal_entry()函数，如果是为同步方法生成机器码，那么还需要调用lock_method()方法，这个方法会改变当前栈的状态，添加同步所需要的一些信息，在后面介绍锁的实现时会详细介绍。&lt;/p&gt;
&lt;p&gt;InterpreterGenerator::generate_normal_entry()函数最终会返回生成机器码的入口执行地址，然后通过变量_entry_table数组来保存，这样就可以使用方法类型做为数组下标获取对应的方法入口了。　 &lt;/p&gt;
&lt;p&gt;相关文章的链接如下：&lt;/p&gt;
&lt;p&gt;1、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13215548.html&quot; target=&quot;_blank&quot;&gt;在Ubuntu 16.04上编译OpenJDK8的源代码&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;2、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13217159.html&quot; target=&quot;_blank&quot;&gt;调试HotSpot源代码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13222664.html&quot; target=&quot;_blank&quot;&gt;HotSpot项目结构&lt;/a&gt;　&lt;/p&gt;
&lt;p&gt;4、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13228157.html&quot; target=&quot;_blank&quot;&gt;HotSpot的启动过程&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;5、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13233607.html&quot; target=&quot;_blank&quot;&gt;HotSpot二分模型（1）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;6、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13237631.html&quot; target=&quot;_blank&quot;&gt;HotSpot的类模型（2）&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;7、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13252983.html&quot; target=&quot;_blank&quot;&gt;HotSpot的类模型（3） &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;8、&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2 vertical-middle&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13272865.html&quot;&gt;HotSpot的类模型（4）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;9、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13289686.html&quot; target=&quot;_blank&quot;&gt;HotSpot的对象模型（5） &lt;/a&gt; &lt;/p&gt;
&lt;p&gt;10、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13291427.html&quot; target=&quot;_blank&quot;&gt;HotSpot的对象模型（6）&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;11、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13297034.html&quot; target=&quot;_blank&quot;&gt;操作句柄Handle（7）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;12、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13303505.html&quot; target=&quot;_blank&quot;&gt;句柄Handle的释放（8）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;13、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13320889.html&quot; target=&quot;_blank&quot;&gt;类加载器&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;14、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13338549.html&quot; target=&quot;_blank&quot;&gt;类的双亲委派机制&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;15、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13343296.html&quot; target=&quot;_blank&quot;&gt;核心类的预装载&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;16、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13353233.html&quot; target=&quot;_blank&quot;&gt;Java主类的装载 &lt;/a&gt; &lt;/p&gt;
&lt;p&gt;17、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13354961.html&quot; target=&quot;_blank&quot;&gt;触发类的装载 &lt;/a&gt; &lt;/p&gt;
&lt;p&gt;18、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13356636.html&quot; target=&quot;_blank&quot;&gt;类文件介绍&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;19、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13358460.html&quot; target=&quot;_blank&quot;&gt;文件流&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;20、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13407609.html&quot; target=&quot;_blank&quot;&gt;解析Class文件&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;21、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13407690.html&quot; target=&quot;_blank&quot;&gt;常量池解析（1）&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;22、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13408261.html&quot; target=&quot;_blank&quot;&gt;常量池解析（2）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;23、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13409707.html&quot; target=&quot;_blank&quot;&gt;字段解析（1）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;24、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13409953.html&quot; target=&quot;_blank&quot;&gt;字段解析之伪共享（2）&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;25、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13413170.html&quot; target=&quot;_blank&quot;&gt;字段解析（3） &lt;/a&gt; &lt;/p&gt;
&lt;p&gt;26、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13413207.html&quot; target=&quot;_blank&quot;&gt;字段解析之OopMapBlock（4）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;27、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13436627.html&quot; target=&quot;_blank&quot;&gt;方法解析之Method与ConstMethod介绍 &lt;/a&gt; &lt;/p&gt;
&lt;p&gt;28、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13436632.html&quot; target=&quot;_blank&quot;&gt;方法解析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;29、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13456515.html&quot; target=&quot;_blank&quot;&gt;klassVtable与klassItable类的介绍&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;30、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13461949.html&quot; target=&quot;_blank&quot;&gt;计算vtable的大小&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;31、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13462910.html&quot; target=&quot;_blank&quot;&gt;计算itable的大小 &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;32、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13467751.html&quot; target=&quot;_blank&quot;&gt;解析Class文件之创建InstanceKlass对象&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;33、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13469745.html&quot; target=&quot;_blank&quot;&gt;字段解析之字段注入&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;34、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13470515.html&quot; target=&quot;_blank&quot;&gt;类的连接 &lt;/a&gt; &lt;/p&gt;
&lt;p&gt;35、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13473410.html&quot; target=&quot;_blank&quot;&gt;类的连接之验证&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;36、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13474567.html&quot; target=&quot;_blank&quot;&gt;类的连接之重写（1）&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;37、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13474577.html&quot; target=&quot;_blank&quot;&gt;类的连接之重写（2）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;38、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13488845.html&quot; target=&quot;_blank&quot;&gt;方法的连接 &lt;/a&gt; &lt;/p&gt;
&lt;p&gt;39、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13494714.html&quot; target=&quot;_blank&quot;&gt;初始化vtable&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;40、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13495636.html&quot; target=&quot;_blank&quot;&gt;初始化itable &lt;/a&gt; &lt;/p&gt;
&lt;p&gt;41、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13495639.html&quot; target=&quot;_blank&quot;&gt;类的初始化 &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;42、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13500050.html&quot; target=&quot;_blank&quot;&gt;对象的创建 &lt;/a&gt; &lt;/p&gt;
&lt;p&gt;43、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13502748.html&quot; target=&quot;_blank&quot;&gt;Java引用类型&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;44、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13503800.html&quot; target=&quot;_blank&quot;&gt;Java引用类型之软引用（1）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;45、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13503996.html&quot; target=&quot;_blank&quot;&gt;Java引用类型之软引用（2）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;46、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13504081.html&quot; target=&quot;_blank&quot;&gt;Java引用类型之弱引用与幻像引用&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;47、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13504083.html&quot; target=&quot;_blank&quot;&gt;Java引用类型之最终引用&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;48、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13511722.html&quot; target=&quot;_blank&quot;&gt;HotSpot的垃圾回收算法&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;49、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13511728.html&quot; target=&quot;_blank&quot;&gt;HotSpot的垃圾回收器 &lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;作者持续维护的个人博客  &lt;a href=&quot;http://classloading.com/&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;classloading.com&lt;/strong&gt;&lt;/a&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关注公众号，有HotSpot源码剖析系列文章！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1236123/202006/1236123-20200630200021532-955264784.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;  　&lt;/p&gt;

</description>
<pubDate>Tue, 18 Aug 2020 00:24:00 +0000</pubDate>
<dc:creator>HotSpot-Researcher</dc:creator>
<og:description>接着上一篇去讲，回到JavaCalls::call_helper()中： address entry_point = method-&amp;gt;from_interpreted_entry(); entr</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mazhimazhi/p/13516634.html</dc:identifier>
</item>
<item>
<title>[NOIP2019] 划分 - linzhuohang</title>
<link>http://www.cnblogs.com/linzhuohang/p/13521302.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/linzhuohang/p/13521302.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1684993/202008/1684993-20200818082217368-1824092496.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;首先YY一个最简单的dp&lt;/p&gt;
&lt;p&gt;$dp[i][j]=min(dp[j][k]+(sum[i]-sum[j])^2 (sum[i]-sum[j]&amp;gt;=sum[j]-sum[k])$&lt;/p&gt;
&lt;p&gt;$dp[i][j]$表示i为终点，j为上一段起点的最小代价。&lt;/p&gt;
&lt;p&gt;上述过程其实就是在i的左端寻找满足条件的点，然后一一计算代价并取最小值（注意这些点可能不是连续的）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1684993/202008/1684993-20200818075136405-291601408.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 但其实，我们只要取最右边的满足条件的点来更新就行了，证明见下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1684993/202008/1684993-20200817222419710-1437627190.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 我们可以记一个$pre[i]$表示i点上一个区间的终点&lt;/p&gt;
&lt;p&gt;这样我们就有了一个$O(n^2)$ dp&lt;/p&gt;
&lt;p&gt;对于每个点i，我们从i往前扫，找到第一个满足 $(sum[i]-sum[j]&amp;gt;=sum[j]-sum[pre[j])$ 的点j ，则&lt;/p&gt;
&lt;p&gt;$dp[i]=dp[j]+(sum[i]-sum[j])^2$&lt;/p&gt;
&lt;p&gt;注意到如果一个点j满足i,那么它肯定满足i+1,&lt;/p&gt;
&lt;p&gt;如果不满足i,也可能满足i+1&lt;/p&gt;
&lt;p&gt;另外，对于 $sum[i]-sum[j]&amp;gt;=sum[j]-sum[pre[j]$&lt;/p&gt;
&lt;p&gt;可以变形成 $sum[i]&amp;gt;=2*sum[j]-sum[pre[j]$&lt;/p&gt;
&lt;p&gt;那么可以设一个$d(j)=2*sum[j]-sum[pre[j]$&lt;/p&gt;
&lt;p&gt;我们可以用一个单调队列来维护满足条件的点&lt;/p&gt;
&lt;p&gt;因为我们只需要最右边满足条件的点，所以每次i递增的时候，如果队头下一位也满足条件，就把队头踢掉（因为下一位肯定比队头更右）&lt;/p&gt;
&lt;p&gt;然后用队头更新这一位的dp值&lt;/p&gt;
&lt;p&gt;然后把这一位从队尾插入，并把前面d值大于它的点全部删除&lt;/p&gt;
&lt;p&gt;这样就可以做到$O(n)$了&lt;/p&gt;

&lt;p&gt;这个是88分的，100分的要写高精，但正确性是有的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
#define int long long
using namespace std;
#define N 4*(int)1e7+10
int sum[N],pre[N],q[N],dp[N],l=1,r=0;
#define val(a) (2*sum[a]-sum[pre[a]])
signed main()
{
        int n,type;
        cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;type;
        for(int i=1;i&amp;lt;=n;i++)
        {
                int a;
                scanf(&quot;%lld&quot;,&amp;amp;a);
                sum[i]=sum[i-1]+a;
        }
        q[++r]=0;
        for(int i=1;i&amp;lt;=n;i++)
        {
                while(l&amp;lt;r&amp;amp;&amp;amp;val(q[l+1])&amp;lt;=sum[i]) l++;
                pre[i]=q[l];
                dp[i]=dp[pre[i]]+(sum[i]-sum[pre[i]])*(sum[i]-sum[pre[i]]);
                while(l&amp;lt;=r&amp;amp;&amp;amp;val(i)&amp;lt;=val(q[r])) r--;
                q[++r]=i;
        }
        cout&amp;lt;&amp;lt;dp[n];
}
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Tue, 18 Aug 2020 00:21:00 +0000</pubDate>
<dc:creator>linzhuohang</dc:creator>
<og:description>题目 题解 首先YY一个最简单的dp $dp[i][j]=min(dp[j][k]+(sum[i]-sum[j])^2 (sum[i]-sum[j]&amp;gt;=sum[j]-sum[k])$ $dp[i</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/linzhuohang/p/13521302.html</dc:identifier>
</item>
<item>
<title>troubleshoot之:GC调优到底是什么 - flydean</title>
<link>http://www.cnblogs.com/flydean/p/jvm-diagnostic-gc.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/flydean/p/jvm-diagnostic-gc.html</guid>
<description>&lt;p&gt;我们经常会听到甚至需要自己动手去做GC调优。那么GC调优的目的到底是什么呢？让程序跑得更快？让GC消耗更少的资源？还是让程序更加稳定？&lt;/p&gt;
&lt;p&gt;带着这些疑问来读一下这篇文章，将会得到一个系统的甚至是不一样的结果。&lt;/p&gt;

&lt;p&gt;其实GC或者说JVM的参数非常非常的多，有控制内存使用的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200706092911625.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_0,text_aHR0cDovL3d3dy5mbHlkZWFuLmNvbQ==,size_30,color_8F8F8F,t_70&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有控制JIT的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200706092938357.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_0,text_aHR0cDovL3d3dy5mbHlkZWFuLmNvbQ==,size_30,color_8F8F8F,t_70&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有控制分代比例的,也有控制GC并发的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200706093012995.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_0,text_aHR0cDovL3d3dy5mbHlkZWFuLmNvbQ==,size_30,color_8F8F8F,t_70&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然，大部分的参数其实并不需要我们自行去调整，JVM会很好的动态帮我们设置这些变量的值。&lt;/p&gt;
&lt;p&gt;如果我们不去设置这些值，那么对GC性能比较有影响的参数和他们的默认值有哪些呢？&lt;/p&gt;
&lt;h2 id=&quot;gc的选择&quot;&gt;GC的选择&lt;/h2&gt;
&lt;p&gt;我们知道JVM中的GC有很多种，不同的GC选择对java程序的性能影响还是比较大的。&lt;/p&gt;
&lt;p&gt;在JDK9之后，G1已经是默认的垃圾回收器了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020070609331112.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_0,text_aHR0cDovL3d3dy5mbHlkZWFuLmNvbQ==,size_30,color_8F8F8F,t_70&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们看一下G1的调优参数。&lt;/p&gt;
&lt;p&gt;G1是基于分代技术的，其实JVM还在开发一些不再基于分代技术的GC算法，比如ZGC，我们可以根据需要来选择适合我们的GC算法。&lt;/p&gt;
&lt;h2 id=&quot;gc的最大线程个数&quot;&gt;GC的最大线程个数&lt;/h2&gt;
&lt;p&gt;GC是由专门的GC线程来执行的，并不是说GC线程越多越好，这个默认线程的最大值是由heap size和可用的CPU资源动态决定的。&lt;/p&gt;
&lt;p&gt;当然你可以使用下面两个选项来修改GC的线程：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt; -XX:ParallelGCThreads=threads 设置STW的垃圾收集线程数

 -XX:ConcGCThreads = n 设置并行标记线程的数量
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一般情况下ConcGCThreads可以设置为ParallelGCThreads的1/4。&lt;/p&gt;
&lt;h2 id=&quot;初始化heap-size&quot;&gt;初始化heap size&lt;/h2&gt;
&lt;p&gt;默认情况下加初始化的heap size是物理内存的1/64。&lt;/p&gt;
&lt;p&gt;你可以使用&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt; -XX:InitialHeapSize=size
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;来重新设置。&lt;/p&gt;
&lt;h2 id=&quot;最大的heap-size&quot;&gt;最大的heap size&lt;/h2&gt;
&lt;p&gt;默认情况下最大的heap size是物理内存的1/4。&lt;/p&gt;
&lt;p&gt;你可以使用：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt; -XX:MaxHeapSize
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;来重新设置。&lt;/p&gt;
&lt;h2 id=&quot;分层编译技术&quot;&gt;分层编译技术&lt;/h2&gt;
&lt;p&gt;默认情况下分层编译技术是开启的。你可以使用：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt; -XX:-TieredCompilation
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;来关闭分层编译。如果启用了分层编译，那么可能需要关注JIT中的C1和C2编译器带来的影响。&lt;/p&gt;

&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;鱼，我所欲也，熊掌亦我所欲也；二者不可得兼，舍鱼而取熊掌者也。--孟子&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;java程序在运行过程中，会发生很多次GC，那么我们其实是有两种统计口径：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;平均每次GC执行导致程序暂停的时间（Maximum Pause-Time Goal）。&lt;/li&gt;
&lt;li&gt;总的花费在GC上的时间和应用执行时间的比例（Throughput Goal）。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;最大暂停时间&quot;&gt;最大暂停时间&lt;/h2&gt;
&lt;p&gt;单次GC的暂停时间是一个统计平均值，因为单次GC的时间其实是不可控的，但是取了平均值，GC就可以动态去调整heap的大小，或者其他的一些GC参数，从而保证每次GC的时间不会超过这个平均值。&lt;/p&gt;
&lt;p&gt;我们可以通过设置：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;-XX:MaxGCPauseMillis=&amp;lt;nnn&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;来控制这个值。&lt;/p&gt;
&lt;p&gt;不管怎么设置这个参数，总体需要被GC的对象肯定是固定的，如果单次GC暂停时间比较短，可能会需要减少heap size的大小，那么回收的对象也比较少。这样就会导致GC的频率增加。从而导致GC的总时间增加，影响程序的Throughput。&lt;/p&gt;
&lt;h2 id=&quot;吞吐率&quot;&gt;吞吐率&lt;/h2&gt;
&lt;p&gt;吞吐率是由花费在GC上的时间和应用程序上的时间比率来决定的。&lt;/p&gt;
&lt;p&gt;我们可以通过设置：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;-XX:GCTimeRatio=nnn
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;来控制。&lt;/p&gt;
&lt;p&gt;如果没有达到throughput的目标，那么GC可能会去增加heap size，从而减少GC的执行频率。但是这样会增加单次的Maximum Pause-Time。&lt;/p&gt;
&lt;p&gt;如果throughput和maximum pause-time的参数同时都设置的话，JVM会去尝试去动态减少heap size的大小，直到其中的一个目标不能满足为止。&lt;/p&gt;
&lt;p&gt;相对而言，G1更加偏重于最大暂停时间，而ZGC更加偏重于吞吐率。&lt;/p&gt;
&lt;blockquote readability=&quot;8.7106598984772&quot;&gt;
&lt;p&gt;本文作者：flydean程序那些事&lt;/p&gt;
&lt;p&gt;本文链接：&lt;a href=&quot;http://www.flydean.com/jvm-diagnostic-gc/&quot;&gt;http://www.flydean.com/jvm-diagnostic-gc/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文来源：flydean的博客&lt;/p&gt;
&lt;p&gt;欢迎关注我的公众号:程序那些事，更多精彩等着您！&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 17 Aug 2020 23:51:00 +0000</pubDate>
<dc:creator>flydean</dc:creator>
<og:description>简介 我们经常会听到甚至需要自己动手去做GC调优。那么GC调优的目的到底是什么呢？让程序跑得更快？让GC消耗更少的资源？还是让程序更加稳定？ 带着这些疑问来读一下这篇文章，将会得到一个系统的甚至是不一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/flydean/p/jvm-diagnostic-gc.html</dc:identifier>
</item>
<item>
<title>自然语言处理之jieba分词 - 奥辰</title>
<link>http://www.cnblogs.com/chenhuabin/p/13521253.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenhuabin/p/13521253.html</guid>
<description>&lt;pre&gt;
精确模式分词结果: 据,报道,，,因,雷暴雨,天气,，,该,地区,川,亿,线,变压器,跌落,式,熔断器,引流,线,烧,断,，,造成,电压,不,稳


全模式分词结果: 据,报道,，,因,雷暴,雷暴雨,暴雨,雨天,天气,，,该地,地区,川,亿,线,变压,变压器,跌落,式,熔断,熔断器,引流,流线,烧,断,，,造成,成电,电压,不稳


搜索引擎模式分词结果: 据,报道,，,因,雷暴,暴雨,雷暴雨,天气,，,该,地区,川,亿线,变压,变压器,跌落,式,熔断,熔断器,引流,线,烧断,，,造成,电压,不,稳
&lt;/pre&gt;</description>
<pubDate>Mon, 17 Aug 2020 23:15:00 +0000</pubDate>
<dc:creator>奥辰</dc:creator>
<og:description>对于英文文本，句子中的词汇可以通过空格很容易得进行划分，但是在我们中文中则不然，没有明显的划分标志，所以需要通过专门的方法（算法）进行分词。在Python中，有多种库实现了各种方法支持中文分词，例如：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chenhuabin/p/13521253.html</dc:identifier>
</item>
<item>
<title>手牵手，使用uni-app从零开发一款视频小程序 (系列上 准备工作篇) - 醉花春</title>
<link>http://www.cnblogs.com/zhaohongcheng/p/13521185.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhaohongcheng/p/13521185.html</guid>
<description>&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;%22https://www.cnblogs.com/zhaohongcheng/p/13521185.html%22&quot;&gt;手牵手，使用uni-app从零开发一款视频小程序 (系列上 准备工作篇)&lt;/a&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;%22https://juejin.im/post/6861994621417979918%22&quot;&gt;手牵手，使用uni-app从零开发一款视频小程序 (系列下 开发实战篇)&lt;/a&gt;&lt;/p&gt;

&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好久不见，很久没更新博客了，前段时间在深圳出差，胡吃海喝颓废了很久，不想每天下班刷抖音、打游戏虚度光阴，准备把之前做的一个小程序案例详细的介绍一下，从安装编译器开始重新开发复盘一遍，希望对初入小程序的你有所帮助。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;扫码体验，先睹为快&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以扫描下微信小程序的二维码，体验一下开发完毕的效果：&lt;/p&gt;
&lt;img src=&quot;https://zhcat.oss-cn-beijing.aliyuncs.com/image_20200817214258.png&quot; alt=&quot;&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;源码地址:&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;%22https://github.com/Tzlibai/uni-app-video%22&quot;&gt;GitHub : https://github.com/Tzlibai/uni-app-video&lt;/a&gt; -- Star 100+&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;%22https://ext.dcloud.net.cn/plugin?id=1839%22&quot;&gt;uni-app插件市场地址: https://ext.dcloud.net.cn/plugin?id=1839&lt;/a&gt; -- 插件下载量1000+&lt;/p&gt;

&lt;blockquote data-tool=&quot;mdnice编辑器&quot; readability=&quot;5.8493150684932&quot;&gt;
&lt;p&gt;目前开发小程序的常见开发方案：微信原生wxml开发，wepy，mpvue，taro、uni-app等，详细优劣对比可以参考&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;京东凹凸实验室&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;的这篇文章：&lt;a href=&quot;%22https://juejin.im/post/6844903800138891278#heading-5%22&quot;&gt;小程序多端框架的全面测评&lt;/a&gt;；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;其实上面的方案开发小程序大同小异，可以根据喜好选择，下文所使用的方案为uni-app&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好的话不多少，进入正题，这里整理一个简单的Xmind总结了一些，其实小程序的开发并没有想象中的那么复杂，接下来我将慢慢的从零开始解读这个一个小程序项目，带大家走入正题： &lt;img src=&quot;https://zhcat.oss-cn-beijing.aliyuncs.com/image_20200817214323.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来的内容我假设你已了解关于HTML、CSS和JavaScript 的初中级知识。并且有一定的Vue基础，如果你刚开始学习前端开发，将本文作为你的第一步可能不是最好的主意！&lt;/p&gt;
&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;1.1 注册微信小程序账号&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果已注册小程序账号，可以略过此步~&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设没有小程序账号：&lt;/p&gt;
&lt;ol data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;我们可以通过&lt;a href=&quot;%22https://mp.weixin.qq.com%22&quot;&gt;微信公众号平台&lt;/a&gt;右上角 → &lt;a href=&quot;%22https://mp.weixin.qq.com/cgi-bin/registermidpage?action=index&amp;amp;lang=zh_CN%22&quot;&gt;立即注册&lt;/a&gt; → 注册的帐号类型 → 选择小程序类型注册&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;进入&lt;a href=&quot;%22https://mp.weixin.qq.com/wxopen/waregister?action=step1&amp;amp;token=&amp;amp;lang=zh_CN%22&quot;&gt;注册页面&lt;/a&gt; → 输入邮箱 → 密码 → 验证码 → 激活邮箱 → 填写主体信息（根据自身选择类型：个人、企业、政府、媒体等） → 登记相关信息即可注册；&lt;/section&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;注册注意事项：&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;:邮箱作为登录帐号，需要填写未在微信公众平台注册，并且没有被个人微信号绑定的邮箱，每个邮箱只能申请一个小程序;&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;1.2 登录微信小程序后台&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1.&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;完善相关信息&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;补充小程序名称信息，上传小程序头像，填写小程序介绍并根据后续开发的内容选择服务范围；&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2.&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;绑定开发者&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;登录微信公众平台小程序，进入用户身份-开发者，新增绑定开发者、体验者。（体验者的含义是在小程序没有通过审核正式发布之前，体验者可以使用该小程序）；&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3.&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;获取AppID&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;登录微信公众平台小程序，进入“设置-账号信息（设置的最下面）”，获取AppID信息。（微信AppID是后面开发小程序必须使用的，在开发小程序之前需要填写开发者的AppID）。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;1.3 下载微信开发者工具&lt;/span&gt;&lt;/h2&gt;
&lt;ol data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;section readability=&quot;5.4889589905363&quot;&gt;&lt;p&gt;前往&lt;a href=&quot;%22https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html%22&quot;&gt;开发者工具下载页面&lt;/a&gt;，根据自己的操作系统下载对应的安装包进行安装,建议现在稳定版本的安装包，其实微信开发者工具不止可以开发小程序，也可以用来制作微信小游戏，有兴趣的朋友可以找找相关资料，开发一款属于自己的小游戏~&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;
&lt;li readability=&quot;-0.4841628959276&quot;&gt;
&lt;section readability=&quot;4.841628959276&quot;&gt;&lt;p&gt;微信开发者工具安装完毕后，双击打开软件，进行登录即可，由于我们是使用&lt;a href=&quot;%22https://uniapp.dcloud.net.cn/%22&quot;&gt;uni-app&lt;/a&gt;进行开发小程序,所以这里先打开登录即可，后面我们使用相关工具自动编译小程序；&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;1.4 总结&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上是关于小程序注册、微信开发者工具下载的内容，文章比较简练，如果需要对小程序有更深一步的了解，可以查看&lt;a href=&quot;%22https://developers.weixin.qq.com/miniprogram/dev/framework/%22&quot;&gt;微信小程序官方开放文档&lt;/a&gt;,官方文档中对于小程序的框架配置、组件介绍、API以及扩展能力等有非常系统的讲解，非常适合初学者对小程序的学习；&lt;/p&gt;

&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;前言&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可能大家对&lt;a href=&quot;%22https://www.dcloud.io/hbuilderx.html%22&quot;&gt;HBuilderX&lt;/a&gt;、&lt;a href=&quot;%22https://uniapp.dcloud.io/README%22&quot;&gt;uni-app&lt;/a&gt;的了解的不是很多；这两者都是DCloud旗下的产品。&lt;/p&gt;
&lt;blockquote data-tool=&quot;mdnice编辑器&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;DCloud公司拥有500万开发者用户，几十万应用案例、10亿手机端月活用户，数千款uni-app插件、70+微信/qq群，开发者可以放心选择。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;HBuilderX&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;HBuilderX&lt;/code&gt;是一款专为Vue的打造编辑器，C++架构，启动速度、大文档打开速度、编码提示，都还是挺不错的，我们今天开发小程序用到的就是这款编辑器，我最开始接触它的绿柔主题感觉特别清爽、特别舒服; 其实我们在Vue.js的官网我们也可以看到他的身影。&lt;/p&gt;
&lt;img src=&quot;https://zhcat.oss-cn-beijing.aliyuncs.com/image_20200817214515.png&quot; alt=&quot;&quot;/&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;uni-app&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;uni-app&lt;/code&gt;是一个使用 Vue.js 开发所有前端应用的框架，开发者编写一套代码，可发布到iOS、Android、H5、以及各种小程序（微信/支付宝/百度/头条/QQ/钉钉/淘宝）、快应用等多个平台。个人接触体验下来，上手快，效果高；&lt;/p&gt;
&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;开始我们接下来的小程序就是用HBuilderX编辑器，加之uni-app框架来开发的&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;2.1 HBuilderX的下载与使用&lt;/span&gt;&lt;/h2&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;HBuilderX的下载&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以访问&lt;a href=&quot;%22https://www.dcloud.io/hbuilderx.html%22&quot;&gt;HBuilderX官方下载地址: https://www.dcloud.io/hbuilderx.html&lt;/a&gt;进行下载，建议大家选择APP开发版进行下载，后面可以把一套代码编译成多个平台使用，效果非常Nice&lt;/p&gt;
&lt;img src=&quot;https://zhcat.oss-cn-beijing.aliyuncs.com/image_20200817214538.png&quot; alt=&quot;&quot;/&gt;&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;7&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;8&quot;&gt;下载完成后是一个Zip文件，解压后选中目录中的HBuilderX.exe&lt;p&gt;→ 点击HBuilderX.exe鼠标右键出现菜单&lt;/p&gt;&lt;p&gt;→ 点击菜单项：发送到&lt;/p&gt;&lt;p&gt;→ 点击桌面快捷方式，即可把图标放到桌面&lt;/p&gt;&lt;p&gt;→ 双击即可正常使用；&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;HBuilderX的简单使用&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HBuilderx的使用方法其实与VScode、WebStorm、Atom等编辑器大同小异，如果你接触过上述编辑器，那么对你来说一定非常轻松！&lt;/p&gt;

&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们之前已经下载了App开发版，可以开箱即用，启动HBuilderX软件&lt;/p&gt;
&lt;ol data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li readability=&quot;-2&quot;&gt;
&lt;section readability=&quot;2&quot;&gt;&lt;p&gt;接下来让我们创建一个uni-app项目，点击工具栏里的文件 -&amp;gt; 新建 -&amp;gt; 项目： &lt;img src=&quot;https://zhcat.oss-cn-beijing.aliyuncs.com/image_20200817215054.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;section readability=&quot;4&quot;&gt;&lt;p&gt;选择uni-app类型，输入工程名，选择模板，点击创建，即可成功创建。 uni-app自带的模板有 Hello uni-app ，是官方的组件和API示例。还有一个重要模板是 uni-ui项目模板，日常开发推荐使用该模板，已内置一些官方的常用组件。 &lt;img src=&quot;https://zhcat.oss-cn-beijing.aliyuncs.com/image_20200817215119.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;section readability=&quot;4&quot;&gt;&lt;p&gt;创建成功后，我们就可以在微信开发工具中运行啦。进入我们刚才创建的项目，&lt;code&gt;点击工具栏的运行 -&amp;gt; 运行到小程序模拟器 -&amp;gt; 微信开发者工具&lt;/code&gt;，即可在微信开发者工具里面体验uni-app。 &lt;img src=&quot;https://zhcat.oss-cn-beijing.aliyuncs.com/image_20200817215139.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;
&lt;li readability=&quot;-1.5&quot;&gt;
&lt;section readability=&quot;3&quot;&gt;&lt;p&gt;接下来会开始编译，并打开微信开发者工具，当你看到以下页面时，说明你&lt;code&gt;新建项目&lt;/code&gt;这一步骤就已经完成啦！ &lt;img src=&quot;https://zhcat.oss-cn-beijing.aliyuncs.com/image_20200817215423.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;
&lt;li readability=&quot;-1.5&quot;&gt;
&lt;section readability=&quot;3&quot;&gt;&lt;p&gt;在创建的uni-app目录中找到&lt;code&gt;manifest.json&lt;/code&gt;文件，基础设置 -&amp;gt; 填写uni-appid，注册登录后即可获取该ID，后续文件会使用到。 &lt;img src=&quot;https://zhcat.oss-cn-beijing.aliyuncs.com/image_20200817215505.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;注意事项&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li readability=&quot;-1.5&quot;&gt;
&lt;section readability=&quot;3&quot;&gt;&lt;p&gt;由于我们是利用HBuilderX启动微信开发者工具，所以我们在开发过程中，需要保持微信开发者工具的打开。&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;
&lt;li readability=&quot;-0.5&quot;&gt;
&lt;section readability=&quot;5&quot;&gt;&lt;p&gt;我们是第一次使用，需要先配置小程序开发者工具的的相关路径，才能运行成功。&lt;code&gt;点击工具栏的工具 -&amp;gt; 设置 -&amp;gt; 运行配置 -&amp;gt; 小程序运行配置&lt;/code&gt;, 如下图，需在输入框输入微信开发者工具的安装路径。 &lt;img src=&quot;https://zhcat.oss-cn-beijing.aliyuncs.com/image_20200817215735.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;section readability=&quot;4&quot;&gt;&lt;p&gt;首次开发时需要在小程序中设置 &lt;code&gt;微信开发者工具 -&amp;gt; 设置 -&amp;gt; 安全设置，将服务端口开启&lt;/code&gt;,可以使用相关的命令行调用工具。 &lt;img src=&quot;https://zhcat.oss-cn-beijing.aliyuncs.com/image_20200817215915.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;
&lt;section readability=&quot;2&quot;&gt;&lt;p&gt;uni-app默认把项目编译到根目录的unpackage目录。&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;
&lt;li readability=&quot;-1.5&quot;&gt;
&lt;section readability=&quot;3&quot;&gt;&lt;p&gt;编译成功后，我们需要把微信小程序的appID在微信开发者工具中填写，如下图： &lt;img src=&quot;https://zhcat.oss-cn-beijing.aliyuncs.com/image_20200817220014.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;3.1 目录分析及UI组件引入&lt;/span&gt;&lt;/h2&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;├─ colorui           &lt;br/&gt;├─ components        &lt;br/&gt;├─ pages/            &lt;br/&gt;│ ├─ home/&lt;br/&gt;│ │ ├─ index.vue     &lt;br/&gt;│ │ ......&lt;br/&gt;├─ static            &lt;br/&gt;├─ unpackage/        &lt;br/&gt;├─ App.vue           &lt;br/&gt;├─ main.js           &lt;br/&gt;├─ manifest.json     &lt;br/&gt;├─ package.json      &lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本项目引入了两个组件：&lt;code&gt;mi-loading、ColorUI&lt;/code&gt;&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;3.1.1 UI组件-mi-loading&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相信大家在小程序的体验中有看到Loading的动画，这边引入了一个Loading的组件，&lt;a href=&quot;%22https://ext.dcloud.net.cn/plugin?id=1483%22&quot;&gt;mi-loading&lt;/a&gt;&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;通过上方链接下载Zip包文件，下载源码解压，复制项目根目录的 &lt;code&gt;/mi-loading&lt;/code&gt; 文件夹到你的项目&lt;code&gt;components目录&lt;/code&gt;中即可&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;打开&lt;code&gt;mi-loading.vue&lt;/code&gt;这个文件，里面的loading动画是可以自行使用Gif图配置，大家可以查看该源码的第四行，img配置的的图片地址就是自定义的Loding，&lt;a href=&quot;%22https://github.com/Tzlibai/uni-app-video/blob/master/uni/components/mi-loading/mi-loading.vue%22&quot;&gt;mi-loading源码地址&lt;/a&gt;，我把自定义的图片放置到了：&lt;code&gt;/static/img/loading.gif&lt;/code&gt;,图片地址：&lt;a href=&quot;%22https://github.com/Tzlibai/uni-app-video/blob/master/uni/static/img/loading.gif%22&quot;&gt;点此查看&lt;/a&gt;&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;# 使用方法&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.$refs.Loading.show() &lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.$refs.Loading.hide() &lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;3.2.2 UI组件-ColorUI&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本项目引入了插件市场的&lt;a href=&quot;%22https://ext.dcloud.net.cn/plugin?id=239%22&quot;&gt;ColorUI-UniApp组件库&lt;/a&gt;，引入方法如下：&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;通过上方链接下载Zip包文件，下载源码解压，复制项目根目录的 /colorui 文件夹到你的项目根目录&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;App.vue 文件引入关键Css &lt;code&gt;main.css&lt;/code&gt;、&lt;code&gt;icon.css&lt;/code&gt;，让改UI组件成为每个页面公共css&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;style&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;css&quot;&gt;&lt;br/&gt;@&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;colorui/main.css&quot;&lt;/span&gt;;&lt;br/&gt;@&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;colorui/icon.css&quot;&lt;/span&gt;;&lt;br/&gt;....&lt;br/&gt;&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;style&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以使用该UI库中封装好的导航栏，测试效果。&lt;/p&gt;
&lt;ol data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;在&lt;code&gt;App.vue文件&lt;/code&gt;中加入如下配置，用于获得系统信息,该文件源码地址：&lt;a href=&quot;%22https://github.com/Tzlibai/uni-app-video/blob/master/uni/App.vue%22&quot;&gt;App.vue&lt;/a&gt;&lt;/section&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;br/&gt;onLaunch: &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt;() &lt;/span&gt;{&lt;br/&gt;uni.getSystemInfo({&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;success&lt;/span&gt;: &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;e&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;Vue.prototype.StatusBar = e.statusBarHeight;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (e.platform == &lt;span class=&quot;hljs-string&quot;&gt;'android'&lt;/span&gt;) {&lt;br/&gt;Vue.prototype.CustomBar = e.statusBarHeight + &lt;span class=&quot;hljs-number&quot;&gt;50&lt;/span&gt;;&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; {&lt;br/&gt;Vue.prototype.CustomBar = e.statusBarHeight + &lt;span class=&quot;hljs-number&quot;&gt;45&lt;/span&gt;;&lt;br/&gt;};&lt;br/&gt;Vue.prototype.StatusBar = e.statusBarHeight;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; custom = wx.getMenuButtonBoundingClientRect();&lt;br/&gt;Vue.prototype.Custom = custom;&lt;br/&gt;Vue.prototype.CustomBar = custom.bottom + custom.top - e.statusBarHeight;&lt;br/&gt;Vue.prototype.StatusBar = e.statusBarHeight;&lt;br/&gt;Vue.prototype.CustomBar = e.statusBarHeight + e.titleBarHeight;&lt;br/&gt;}&lt;br/&gt;})}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;&lt;code&gt;pages.json文件&lt;/code&gt; 配置取消系统导航栏,该文件源码地址：&lt;a href=&quot;%22https://github.com/Tzlibai/uni-app-video/blob/master/uni/pages.json%22&quot;&gt;pages.json&lt;/a&gt;&lt;/section&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;# 复制下面命令需要把注释删除，否则会报错&lt;br/&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;globalStyle&quot;&lt;/span&gt;: {&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;navigationStyle&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;custom&quot;&lt;/span&gt;, &lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;navigationBarTextStyle&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;white&quot;&lt;/span&gt;, &lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;navigationBarTitleText&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;uni-app&quot;&lt;/span&gt;, &lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;navigationBarBackgroundColor&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;#007AFF&quot;&lt;/span&gt;, &lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;backgroundColor&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;#FFFFFF&quot;&lt;/span&gt; &lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行成功后如下图所示： &lt;img src=&quot;https://zhcat.oss-cn-beijing.aliyuncs.com/image_20200817221015.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好的，这样我们已经成功的引入了该UI库，此时可以在微信开发者工具中看到效果，无需手动刷新，当我们在HBuilderX中添加代码保存，代码会自动编译，微信开发者工具会自动刷新；&lt;/p&gt;

&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上就是我们这款小程序的开发准备工作，下篇文章我们将会走入进行实际项目的从零开发，从新建一个项目到小程序代码的审核上传。&lt;/p&gt;
&lt;blockquote data-tool=&quot;mdnice编辑器&quot; readability=&quot;4.695652173913&quot;&gt;
&lt;p&gt;我曾踏足山巅，也曾跌入低谷，这两者都让我受益良多。个人网站：&lt;a href=&quot;%22https://zhaohongcheng.com%22&quot;&gt;https://zhaohongcheng.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 17 Aug 2020 17:33:00 +0000</pubDate>
<dc:creator>醉花春</dc:creator>
<og:description>系列文章 手牵手，使用uni-app从零开发一款视频小程序 (系列上 准备工作篇) 手牵手，使用uni-app从零开发一款视频小程序 (系列下 开发实战篇) 前言 好久不见，很久没更新博客了，前段时间</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhaohongcheng/p/13521185.html</dc:identifier>
</item>
<item>
<title>要点3：输入函数对比与自定义输入方式 - CN_Simo</title>
<link>http://www.cnblogs.com/lxmwb/p/13521096.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lxmwb/p/13521096.html</guid>
<description>&lt;p&gt;相关函数原型(从控制台获取输入，不考虑宽字符)：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;int scanf( const char *format, ... );
int getchar(void);
char *gets( char *str );
char *gets_s( char *str, rsize_t n );
char *fgets( char *str, int count, FILE *stream );
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;scanf
&lt;ul&gt;&lt;li&gt;如果解析错误，内容继续留在缓冲区供下次使用；&lt;/li&gt;
&lt;li&gt;解析失败返回0，成功返回解析的参数个数，不会超过占位符个数，读到文件尾返回EOF（-1）；&lt;/li&gt;
&lt;li&gt;读取字符串，一次只能读取一个词，不能用scanf读取一行；&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;getchar
&lt;ul&gt;&lt;li&gt;可以读取到换行符；&lt;/li&gt;
&lt;li&gt;常用于暂停程序，或丢弃缓冲区剩余字符；&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;gets
&lt;ul&gt;&lt;li&gt;读取一行，遇到换行符，直接丢弃换行符；&lt;/li&gt;
&lt;li&gt;会自动在字符串末尾添加&lt;code&gt;\0&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;返回字符串指针，读取失败返回null；&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;gets_s
&lt;ul&gt;&lt;li&gt;可以设置读取的字符串长度；&lt;/li&gt;
&lt;li&gt;读到换行符，将换行符丢弃；&lt;/li&gt;
&lt;li&gt;如果读取到最大字符数，还没有读取到换行符或文件结尾，读取并丢弃随后的输入直至遇到换行符或EOF；&lt;/li&gt;
&lt;li&gt;返回字符串指针，读取失败返回null；&lt;/li&gt;
&lt;li&gt;c11的可选函数&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;fgets
&lt;ul&gt;&lt;li&gt;可以设置读取的字符串长度；&lt;/li&gt;
&lt;li&gt;读到换行符不丢弃存到数组里；&lt;/li&gt;
&lt;li&gt;不会自动清除行缓冲区剩余数据；&lt;/li&gt;
&lt;li&gt;返回字符串指针，读取失败返回null；&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;该函数可以从标准输入读取内容，返回值为读取的参数个数，例如:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;

int main()
{
    int seed;
    printf(&quot;%d\n&quot;, scanf(&quot;%d %d&quot;, &amp;amp;seed, &amp;amp;seed));
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行程序，输入 两个整数，打印为 2，测试输入3个值仍然打印2，是因为这个&quot;%d %d&quot;指定了只解析两个int，多余的将留在缓冲区中，如果后面再写一个scanf，将从缓冲区中继续解析。&lt;/p&gt;
&lt;p&gt;现在多加一个&lt;code&gt;scanf&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;

int main()
{
    int seed;
    printf(&quot;%d\n&quot;, scanf(&quot;%d %d&quot;, &amp;amp;seed, &amp;amp;seed));
    printf(&quot;%d\n&quot;, scanf(&quot;%d %d&quot;, &amp;amp;seed, &amp;amp;seed));
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;case1：读取到文件尾部返回eof&quot;&gt;case1：读取到文件尾部返回EOF&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;1
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1
-1
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;scanf从缓冲区中解析，返回解析成功的参数个数，因为只有一个1，所以第一个给scanf解析，第一行打印1，第二行解析的时候因读取到了文件结束表示&lt;code&gt;EOF&lt;/code&gt;返回-1。&lt;/p&gt;
&lt;h2 id=&quot;case2：解析失败返回0&quot;&gt;case2：解析失败返回0&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;f
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;0
0
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这说明，解析失败的内容还留在缓冲区给下次scanf用，所以两个scanf都返回的0。&lt;/p&gt;
&lt;p&gt;因为无法解析的值会继续留在缓冲区供下次使用，所以如果是循环&lt;code&gt;scanf&lt;/code&gt;，程序就会跑飞，让你没有输入的机会，可以使用综上一节提供的示例测试一下，运行后直接输入&lt;code&gt;f&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;case3：返回值最大为占位符个数&quot;&gt;case3：返回值最大为占位符个数&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;1 2 3 4 5 6 7
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;2
2
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这表明，返回值最大是占位符的个数，剩下的内容还留在缓冲区。&lt;/p&gt;
&lt;h2 id=&quot;综上&quot;&gt;综上&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;scanf&lt;/code&gt;判断输入结束，只能在文件输入模式下利用&lt;code&gt;EOF&lt;/code&gt;判断，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;// qwer.c
#include &amp;lt;stdio.h&amp;gt;

int main()
{
    int a;
    while(scanf(&quot;%d&quot;, &amp;amp;a) != EOF)
    {
        printf(&quot;%d\n&quot;, a);
    }
    return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输入文件&lt;code&gt;test.txt&lt;/code&gt;内容：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1
2
3
4
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;编译: &lt;code&gt;gcc qwer.c -o main -std=c11&lt;/code&gt;。&lt;br/&gt;运行：&lt;code&gt;./main &amp;lt; test.txt&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;这个函数可以从输入缓冲区仅读取一个字符，返回int，后面结合&lt;code&gt;fgets&lt;/code&gt;使用。&lt;/p&gt;

&lt;p&gt;在读取字符串时，&lt;code&gt;scanf()&lt;/code&gt;和转换说明&lt;code&gt;%s&lt;/code&gt;只能读取一个单词，可是程序中经常要读取一整行输入。&lt;code&gt;gets&lt;/code&gt;函数简单易用，它读取整行输入，直到遇到换行符，然后丢弃换行符，存储其余字符，并在这些字符的末尾添加一个空字符使其成为一个c字符串。它经常和&lt;code&gt;puts&lt;/code&gt;函数配对使用，该函数用于显示字符串，并在末尾添加换行符。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#define STLEN 81
int main()
{
    char words[STLEN];
    puts(&quot;Enter a string, please.&quot;);
    gets(words);   // 典型用法
    printf(&quot;Your string twice:\n&quot;);
    printf(&quot;%s\n&quot;, words);
    puts(words);
    puts(&quot;Done.&quot;);
    return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;printf(&quot;%s\n&quot;, words);&lt;/code&gt;和&lt;code&gt;puts(words);&lt;/code&gt;效果相同，但是编译的时候会产生警告，因为&lt;code&gt;gets&lt;/code&gt;读取整行输入，并不知道&lt;code&gt;words&lt;/code&gt;能存多少，如果输入字符串过长，会导致缓冲区溢出。&lt;/p&gt;
&lt;p&gt;例如将&lt;code&gt;STLEN&lt;/code&gt;设置成&lt;code&gt;5&lt;/code&gt;，程序依然可以运行，尝试输入过长的数据就可能会发成溢出，最直观的就是可以看到发生段溢出后程序异常退出。&lt;/p&gt;

&lt;p&gt;该函数是c11才有的，且为拓展函数，使用方式除了可以设置读取的字符数之外和&lt;code&gt;gets&lt;/code&gt;函数用法一样。&lt;/p&gt;

&lt;p&gt;这个函数除了可以从标准输入读取字符串之外，还可以从文件中读取，而且可以指定读取字符个数，比&lt;code&gt;gets_s&lt;/code&gt;更加灵活易用，利用&lt;code&gt;fgets&lt;/code&gt;，但是&lt;code&gt;fgets&lt;/code&gt;不会自动丢弃超过字符个数之外的行缓冲区数据，所以要配合&lt;code&gt;getchar&lt;/code&gt;将剩余的缓冲数据丢弃，否则可能造成程序运行以异常。&lt;/p&gt;

&lt;p&gt;为满足以下几点编写自定义输入：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;从标准输入读取数据；&lt;/li&gt;
&lt;li&gt;能够指定读取字符个数；&lt;/li&gt;
&lt;li&gt;丢弃换行符；&lt;/li&gt;
&lt;li&gt;丢弃行缓冲区剩余数据；&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;char *s_gets(char *str, int n)
{
    char *ret_var;
    int i = 0;
    ret_var = fgets(str, n, stdin);
    if(ret_var)
    {
        while(str[i] != '\n' &amp;amp;&amp;amp; str[i] != '\0')
        {
            i++;
        }
        if(str[i] == '\n')
            str[i] = '\0';
        else
            while(getchar() != '\n')
                continue;
    }
    return ret_var;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用方式&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#define STLEN 8

int main()
{
    char words[STLEN];
    while(s_gets(words, STLEN) &amp;amp;&amp;amp; words[0] != '\n') // 没有输入数据会自动退出程序
    {
        puts(words);
    }
    return 0;
}
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 17 Aug 2020 16:16:00 +0000</pubDate>
<dc:creator>CN_Simo</dc:creator>
<og:description>读取输入的方式 相关函数原型(从控制台获取输入，不考虑宽字符)： int scanf( const char *format, ... ); int getchar(void); char *gets</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lxmwb/p/13521096.html</dc:identifier>
</item>
<item>
<title>[Hei-Ocelot-Gateway ].Net Core Api网关Ocelot的开箱即用版本 - 乔达摩</title>
<link>http://www.cnblogs.com/xiaxiaolu/p/13514942.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaxiaolu/p/13514942.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/641760/202008/641760-20200816225054695-1519401431.png&quot; alt=&quot;Containerizing ASP.net core API Gateways&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;很多neter都有在用&lt;a href=&quot;https://github.com/ThreeMammals/Ocelot&quot;&gt;Ocelot&lt;/a&gt;做Api网关，但是Ocelot又不像kong或者其他网关一样，开箱即用。它需要你单独开一个web项目来部署，这样很多同学都在做重复的事了。&lt;/p&gt;
&lt;p&gt;这里[Hei.Ocelot.ApiGateway] 就把这件事给做了，以后有同学要用的话可以单独拉下代码来部署，或者docker/k8s直接部署就好了（这是我的计划，后续怎么做可能要看我自己的需求，我们公司内部部分项目也用）；&lt;/p&gt;
&lt;p&gt;--大家也可以当成一个ocelot的demo哈，毕竟没什么代码量。&lt;/p&gt;
&lt;p&gt;基于此，本文目标读者是对Ocelot有初步了解的同学。&lt;/p&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/gebiWangshushu/Hei.Ocelot.ApiGateway&quot;&gt;https://github.com/gebiWangshushu/Hei.Ocelot.ApiGateway&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/641760/202008/641760-20200816225054244-1305331069.png&quot; alt=&quot;1597215263573&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;项目结构很简单：&lt;/p&gt;
&lt;p&gt;Hei.Ocelot.ApiGateway 是主角，是我配置好的Ocelot网关；&lt;/p&gt;
&lt;p&gt;Hei.Api 是网关测试用的Api;&lt;/p&gt;
&lt;p&gt;Hei.IdentityServer 是测试用的IdentityServer，给部分自己没准备好IdentityServer的同学体验的；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;裸机(Host)直接部署&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;直接clone项目下来，按需分别跑起来就行；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;docker、docker-compose部署&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、clone项目下来，配置好 /Hei.Ocelot.ApiGateway/config 下的appsettings.yml；&lt;/p&gt;
&lt;p&gt;2、把这个整个config目录拷贝到 /home/heidemo/config （因为我demo里面挂载在这个目录）；&lt;/p&gt;
&lt;p&gt;3、去项目根目录执行&lt;code&gt;docker-compose up&lt;/code&gt; (docker-compose.yml就在根目录，你可以注释掉你不想启用的service)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;k8s部署&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、&lt;a href=&quot;https://github.com/gebiWangshushu/Hei.Ocelot.ApiGateway/blob/master/deploy.yml&quot;&gt;deploy.yml&lt;/a&gt;下载到本地，修改文件后面的ConfigMap节点，这部分是配置，含义跟其他部署方式一样；&lt;/p&gt;
&lt;p&gt;2、执行&lt;code&gt;kubectl apply -f deploy.yml&lt;/code&gt;；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我自己部署的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Hei.Ocelot.ApiGateway 网关地址：&lt;a href=&quot;http://172.16.3.117:5000&quot;&gt;http://172.16.3.117:5000&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Hei.Api地址：&lt;a href=&quot;http://172.16.3.117:5003&quot;&gt;http://172.16.3.117:5003&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Hei.IdentityServer地址：&lt;a href=&quot;http://172.16.3.117:5100&quot;&gt;http://172.16.3.117:5100&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;通过网关访问下我的HeiApi:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://172.16.3.117:5000/user%E3%80%81http://172.16.3.117:5000/WeatherForecast&quot;&gt;http://172.16.3.117:5000/user、http://172.16.3.117:5000/WeatherForecast&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/641760/202008/641760-20200816225053939-1404194047.png&quot; alt=&quot;1597218730749&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;OK，美&lt;/p&gt;
&lt;p&gt;我们讲下各个功能怎么开启，随便简单聊聊怎么用。&lt;/p&gt;

&lt;p&gt;Ocelot 有一堆的配置https://ocelot.readthedocs.io/en/latest/features/configuration.html，Ocelot 支持在运行时动态改配置，Ocelot 提供了对应的Rest Api 修改即时生效。不然每次改一点点配置都要找运维挺麻烦的；&lt;/p&gt;
&lt;p&gt;对应的Rest Api是用&lt;a href=&quot;https://github.com/IdentityServer/IdentityServer4&quot;&gt;IdentityServer&lt;/a&gt;保护的，可以直接配置用已搭建好的IdentityServer或者用Ocelot内置的IdentityServer，用来做这个Api的授权。我们实现的是前者；&lt;/p&gt;
&lt;h2 id=&quot;开启配置&quot;&gt;开启配置&lt;/h2&gt;
&lt;p&gt;appsetting.yml加上以下配置即可启用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Administration:
 Path: /administration #这里是admin api的目录
 IdentityServer:
  Authority: http://172.16.3.117:5100 #IdentityServer地址
  ApiName: ocelot #这些是我配置好在IdentityServer里的
  RequireHttpsMetadata: false
  ApiSecret: secret #这些是我配置好在IdentityServer里的
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;使用&quot;&gt;使用&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1、先去IdentityServer申请token&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;POST http://172.16.3.117:5100/connect/token HTTP/1.1
Content-Type: application/x-www-form-urlencoded
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/641760/202008/641760-20200816225053489-1124661804.png&quot; alt=&quot;1597203533753&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、去Hei-Ocelot-Gateway 查询配置&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;GET http://172.16.3.117:5100/administration/configuration HTTP/1.1
Authorization: Bearer token
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;红框中的就是步骤1申请的token。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/641760/202008/641760-20200816225053043-1595622473.png&quot; alt=&quot;1597203753334&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、更新Hei-Ocelot-Gateway 更新配置&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;POST http://172.16.3.117:5100/administration/configuration HTTP/1.1
Authorization: Bearer token
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/641760/202008/641760-20200816225052599-1440569610.png&quot; alt=&quot;1597204124724&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;我发现这个admin Api配置好的配置，重启后又会复原为初始化状态，不知道是不是Bug。生产谨慎使用或有管理工具每次更新备份好再用。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;你的网关后面有很多服务，某些服务安全性较高的话可接入IdentityServer做服务授权。&lt;/p&gt;
&lt;h2 id=&quot;开启配置-2&quot;&gt;开启配置&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;appsetting.yml&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;IdentityProvider:
 - Authority: http://172.16.3.117:5100
   ApiName: ocelot
   ApiSecret: secret
   RequireHttpsMetadata: false
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2、ocelot路由配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;然后使用前面搭建好的Admin Api，或者你用的是配置文件，加上以下Routes:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
        &quot;DownstreamPathTemplate&quot;: &quot;/{url}&quot;,
        &quot;DownstreamScheme&quot;: &quot;http&quot;,
        &quot;DownstreamHostAndPorts&quot;: [{
                &quot;Host&quot;: &quot;172.16.3.117&quot;,
                &quot;Port&quot;: 5003
        }],
        &quot;UpstreamPathTemplate&quot;: &quot;/protect/{url}&quot;,
        &quot;UpstreamHttpMethod&quot;: [&quot;Get&quot;, &quot;Post&quot;, &quot;Put&quot;],
        &quot;AuthenticationOptions&quot;: {
                &quot;AuthenticationProviderKey&quot;: &quot;ocelot&quot;,
                &quot;AllowedScopes&quot;: []
        },
        &quot;RouteClaimsRequirement&quot;: {}
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3、测试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们再次访问，&lt;a href=&quot;http://172.16.3.117:5000/user&quot;&gt;http://172.16.3.117:5000/user&lt;/a&gt; 的受保护路由 &lt;a href=&quot;http://172.16.3.117:5000/protect/user&quot;&gt;http://172.16.3.117:5000/protect/user&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/641760/202008/641760-20200816225052228-230862945.png&quot; alt=&quot;1597219742675&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;申请token&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/641760/202008/641760-20200816225051865-1233539559.png&quot; alt=&quot;1597220844358&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再次访问&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/641760/202008/641760-20200816225051448-1219298007.png&quot; alt=&quot;1597220881342&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Ocelot 支持Consul和Eureka做服务发现，基本能满足我们日常需求；&lt;/p&gt;
&lt;h2 id=&quot;consul&quot;&gt;Consul&lt;/h2&gt;
&lt;h3 id=&quot;开启配置-3&quot;&gt;开启配置&lt;/h3&gt;
&lt;p&gt;1、appsetting.yml&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;GlobalConfiguration:
 ServiceDiscoveryProvider:
  Host: 172.16.3.119 #这是我配置在其他机器的consul agent,生产用的一般会在本机配个agent
  Port: 8500
  Type: Consul
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、ocelot路由配置&lt;/p&gt;
&lt;p&gt;首先要求你们的服务要注册到Consul，这里我自己注册了一个叫&lt;code&gt;MessageApi&lt;/code&gt;的服务；&lt;/p&gt;
&lt;p&gt;加上以下Routes:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
    &quot;DownstreamPathTemplate&quot;: &quot;/api/{url}&quot;,
    &quot;DownstreamScheme&quot;: &quot;http&quot;,
    &quot;UpstreamPathTemplate&quot;: &quot;/consul/{url}&quot;,
    &quot;UpstreamHttpMethod&quot;: [ &quot;Get&quot;, &quot;Post&quot;, &quot;Put&quot; ],
    &quot;ServiceName&quot;: &quot;MessageApi&quot;,
    &quot;LoadBalancerOptions&quot;: {
    &quot;Type&quot;: &quot;LeastConnection&quot;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样你访问网关 &lt;a href=&quot;http://172.16.3.117:5000/consul/&quot;&gt;http://172.16.3.117:5000/consul/&lt;/a&gt; 就能访问到对应服务了；&lt;/p&gt;
&lt;h2 id=&quot;eureka&quot;&gt;Eureka&lt;/h2&gt;
&lt;h3 id=&quot;开启配置-4&quot;&gt;开启配置&lt;/h3&gt;
&lt;p&gt;1、appsetting.yml&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Eureka:
 Client:
  ServiceUrl: http://localhost:8761/eureka/ #你的eureka
  ShouldRegisterWithEureka: false
  ShouldFetchRegistry: true
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、ocelot配置&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;GlobalConfiguration:
  ServiceDiscoveryProvider:
   Type: Eureka
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3、测试&lt;/p&gt;
&lt;p&gt;略，eureka环境给我删了，今天懒得搭了，如果需求强烈，我加上。&lt;/p&gt;

&lt;p&gt;ocelot是支持k8s的，如果你启用k8s，那它在k8s集群里的角色比较接近于“ocelot-ingress”吧；然后我用的是&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;PackageReference Include=&quot;Ocelot.Provider.Kubernetes&quot; Version=&quot;16.0.1&quot; /&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;16.0.0 有点问题，直接用&lt;code&gt;AddKubernetes()&lt;/code&gt;访问总会报错，我换了种方式实现；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;开启配置-5&quot;&gt;开启配置&lt;/h2&gt;
&lt;p&gt;开启前你肯定要搭建好k8s集群了；&lt;/p&gt;
&lt;p&gt;1、ocelot配置&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;GlobalConfiguration:
  ServiceDiscoveryProvider:
   Type: Kube
   NameSpace: dotnetcore #这是我自己部署的HeiApi的命名空间，你的如果你的api有多个命名空间可以在路由里配置
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、ocelot新增路由&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; {
    &quot;DownstreamPathTemplate&quot;: &quot;/{url}&quot;,
    &quot;DownstreamScheme&quot;: &quot;http&quot;,
    &quot;UpstreamPathTemplate&quot;: &quot;/kube/{url}&quot;,
    &quot;ServiceName&quot;: &quot;hei-ocelot-api&quot;,  
    #&quot;Namespace&quot;: &quot;dev&quot;,  #比如这里你的这个路由对应的serverName不是dotnetcore，你可以这样配置
    &quot;UpstreamHttpMethod&quot;: [ &quot;Get&quot; ]
  }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3、测试&lt;/p&gt;
&lt;p&gt;我们来访问我们刚刚新增的路由对应地址： &lt;a href=&quot;http://172.16.1.30:31500/kube/user&quot;&gt;http://172.16.1.30:31500/kube/user&lt;/a&gt; (之所以换了地址是因为我刚刚172。16.3.117那台机没搭k8s环境)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/641760/202008/641760-20200816225050949-1930546237.png&quot; alt=&quot;1597229456658&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;大家也看到服务发现和k8s(在ocelot这里也是一种新式的服务发现)都在配置GlobalConfiguration:ServiceDiscoveryProvider: 下面，那Consul和eureka和k8s是互斥的，都有配置的话优先级consul&amp;gt;eureka&amp;gt;k8s&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我大概看着自己的需求实现了部分需要单独引用拓展包才能启用的功能，但是还有部分功能未有实现，比如Caching、Tracing这些（大家可以修改测好后直接提pr，我不是懒得写而是测试麻烦，懒哈哈）&lt;/p&gt;
&lt;p&gt;同样，不需要引用包，单独配置就可以启用的功能，都一一保留着,比如&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;限流&lt;/li&gt;
&lt;li&gt;服务熔断降级&lt;/li&gt;
&lt;li&gt;求求合并&lt;/li&gt;
&lt;li&gt;请求头转换等等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://ocelot.readthedocs.io/en/latest/&quot;&gt;https://ocelot.readthedocs.io/en/latest/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/gebiWangshushu/Hei.Ocelot.ApiGateway&quot;&gt;https://github.com/gebiWangshushu/Hei.Ocelot.ApiGateway&lt;/a&gt; （喜欢的话给我点个星~~）&lt;/p&gt;
</description>
<pubDate>Mon, 17 Aug 2020 15:41:00 +0000</pubDate>
<dc:creator>乔达摩</dc:creator>
<og:description>﻿ 写在前面 很多neter都有在用Ocelot做Api网关，但是Ocelot又不像kong或者其他网关一样，开箱即用。它需要你单独开一个web项目来部署，这样很多同学都在做重复的事了。 这里[Hei</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiaxiaolu/p/13514942.html</dc:identifier>
</item>
<item>
<title>ElasticSearch实战系列七: Logstash实战使用-图文讲解 - 虚无境</title>
<link>http://www.cnblogs.com/xuwujing/p/13520666.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuwujing/p/13520666.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;在上一篇中我们介绍了&lt;a href=&quot;https://www.cnblogs.com/xuwujing/p/13412108.html&quot;&gt;Logstash快速入门&lt;/a&gt;，本文主要介绍的是ELK日志系统中的Logstash的实战使用。实战使用我打算从以下的几个场景来进行讲解。&lt;/p&gt;
&lt;h3 id=&quot;时区问题解决方案&quot;&gt;时区问题解决方案&lt;/h3&gt;
&lt;p&gt;在我们使用logstash将采集的数据传输到ES中的时候，会发现采集的时间&lt;code&gt;@timestamp&lt;/code&gt;的时间和我们本地的不一致，这个主要是因为时区的问题导致的，我们在计算时间的时候需要将这个时间增加8小时，但是这样会很不方便。为了永久解决这个问题，我们可以在logstash中的filter中对该字段进行转换，增加8小时。&lt;/p&gt;
&lt;p&gt;添加的配置如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
 ruby {
   code =&amp;gt; &quot;event.set('timestamp', event.get('@timestamp').time.localtime + 8*60*60)&quot;
 }
 ruby {
   code =&amp;gt; &quot;event.set('@timestamp',event.get('timestamp'))&quot;
 }
 mutate {
   remove_field =&amp;gt; [&quot;timestamp&quot;]
 }
 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;原本示例图:&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200813173634140.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhendzeHBjbQ==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;添加配置之后的示例图:&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200813174158330.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhendzeHBjbQ==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;可以看到添加配置之后&lt;code&gt;@timestamp&lt;/code&gt;时间已经和本地时间基本一致了。&lt;/p&gt;
&lt;h3 id=&quot;日志内容切分&quot;&gt;日志内容切分&lt;/h3&gt;
&lt;p&gt;我们在进行采集日志到ES中的时候，有时需要对日志内容进行切割。比如得到日志内容的时间以及日志级别等等。这时我们就可以通过grok来对日志内容进行切分，比如将制定好的日志内容切割为日志时间、线程名称、日志级别、类名以及详细内容等等。我们只需要在logstash的filter中使用grok语法即可完成日志内容切割。&lt;br/&gt;这里我们使用JAVA的Logback来制定日志输出格式，然后通过日志的格式编写grok语法，最后将grok配置添加到logstash的filter中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Logback输出配置:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;|%d{yyyy-MM-dd HH:mm:ss.SSS}|[%thread]|%-5level|%logger{50}|-%msg%n&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;日志样例数据:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;|2020-07-24 17:08:33.159|[Thread-5]|INFO|com.pancm.Application|-测试示例三: All things in their being are good for something. 天生我才必有用3&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;grok模式:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;|%{DATA:log_time}|%{DATA:thread}|%{DATA:log_level}|%{DATA:class_name}|-%{GREEDYDATA:content}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用grok分析&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200813174422136.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhendzeHBjbQ==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;可以看到以及分析匹配成功了。&lt;/p&gt;
&lt;p&gt;然后我们在filter中添加如下配置:&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;grok {&lt;br/&gt;match =&amp;gt; { &quot;message&quot; =&amp;gt;&quot;|%{DATA:log_time}|%{DATA:thread}|%{DATA:log_level}|%{DATA:class_name}|-%{GREEDYDATA:content}&quot;&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最终输出的日志到ES的示例图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200813174942382.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhendzeHBjbQ==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;自定义模板&quot;&gt;自定义模板&lt;/h3&gt;
&lt;p&gt;我们在使用Logstash采集日志的时候，如果没有指定索引库或模板，则会使用ElasticSearch默认自带的名字为”logstash”的模板，默认应用于Logstash写入数据到ElasticSearch使用。但是我们希望使用自定义的索引模板，将采集的日志按照我们自身的想法来写入，此时我们就需要用到自定义模板了。&lt;br/&gt;主要有两种方式，一种是在logstash的output插件中使用template指定本机器上的一个模板json路径， 例如 &lt;code&gt;template =&amp;gt; &quot;/home/logstash.json&quot;&lt;/code&gt;，json里面的内容为我们自定的索引mapping，虽然这种方式简单，但是分散在Logstash机器上，维护起来比较麻烦。还有一种是在elasticsearc服务端自定义配置模板，事先将模板设置好，然后在logstash的output输出中指定该模板即可，这种方式比较灵活方便，可动态更改，全局生效。&lt;br/&gt;这里我们还是通过一个示例来进行说明，我们首先创建一个template_mylog的模板，配置这几个字段:&lt;br/&gt;log_time、thread、log_level、class_name、content。&lt;/p&gt;
&lt;p&gt;语句如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
PUT _template/template_mylog
{       
        &quot;index_patterns&quot; : [
            &quot;mylog-*&quot;
        ],
        &quot;order&quot; : 10,
          &quot;settings&quot;: {  
              &quot;index.number_of_shards&quot;: 3,  
              &quot;number_of_replicas&quot;: 1
          },  
      &quot;mappings&quot; : {  
          &quot;properties&quot; : {  
               &quot;log_level&quot; : { &quot;type&quot; : &quot;keyword&quot; },
            &quot;thread&quot; : { &quot;type&quot; : &quot;keyword&quot; },
             &quot;class_name&quot; : { &quot;type&quot; : &quot;keyword&quot; },
              &quot;content&quot; : { &quot;type&quot; : &quot;keyword&quot; },
             &quot;log_time&quot; : {   &quot;type&quot; : &quot;date&quot;,&quot;format&quot; : &quot;yyyy-MM-dd HH:mm:ss.SSS&quot;}
          }  
         
      }  
  }

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;示例图:&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200813164346316.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhendzeHBjbQ==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;注:上述的配置比其他mapping而言多了两个新配置，一个是index_patterns，该配置表明自动创建的索引开头以&lt;code&gt;mylog-&lt;/code&gt;的索引库都会采用该模板；而order表示顺序级别，在有相同的索引模板中，该值越大，优先级越高。&lt;/p&gt;
&lt;p&gt;创建成功之后，我们只需在output中的添加如下配置即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; 
 elasticsearch {
            hosts =&amp;gt; [&quot;127.0.0.1:9200&quot;]
            index =&amp;gt; &quot;mylog-%{+YYYY.MM.dd}&quot;  
    }
    
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们启动logstash进行日志的采集。&lt;br/&gt;效果图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200813174942382.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhendzeHBjbQ==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;写入多个索引库&quot;&gt;写入多个索引库&lt;/h3&gt;
&lt;p&gt;我们在使用logstash采集日志的时候，有时有多种不同的日志并且需要采集到不同的索引库中，这时我们就可以通过标记来进行写入。比如采集/home/logs目录下的日志我定义一个标记为java，采集/home/logs2目录下的日志我定义一个标记为java2，那么在写入ElasticSearch的时候只需要根据该标记区分写入即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;logstash input配置示例:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
  file {
        path =&amp;gt; [&quot;/home/logs/mylog-2020-08-13.0.txt&quot;]
        type =&amp;gt; &quot;java&quot;
        start_position =&amp;gt; &quot;beginning&quot;
        sincedb_path =&amp;gt; &quot;/dev/null&quot;
    }
    file {
        path =&amp;gt; [&quot;/home/logs2/*.txt&quot;]
        type =&amp;gt; &quot;java2&quot;
        start_position =&amp;gt; &quot;beginning&quot;
        sincedb_path =&amp;gt; &quot;/dev/null&quot;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;logstash output配置示例:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
    if [type] == &quot;java&quot;{
      elasticsearch {
         hosts =&amp;gt; [&quot;127.0.0.1:9200&quot;]
         index =&amp;gt; &quot;mylog-%{+YYYY.MM.dd}&quot;
      }
    }

    if [type] == &quot;java2&quot;{
      elasticsearch {
         hosts =&amp;gt; [&quot;127.0.0.1:9200&quot;]
         index =&amp;gt; &quot;mylog-%{+YYYY.MM}&quot;
      }
    }
    
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;示例图在&lt;strong&gt;多行内容合并&lt;/strong&gt;场景中。&lt;/p&gt;
&lt;h3 id=&quot;多行内容合并&quot;&gt;多行内容合并&lt;/h3&gt;
&lt;p&gt;我们在采集日志的时候，经常会遇到异常日志，并且异常日志并非为一行内容，如果我们按照原有的方式采集，在ElasticSearch中显示的是一行一行的内容，这样的话我们排查问题会很头疼。幸好Logstash中支持多行日志合并，使用multiline.pattern、multiline.negate和multiline.what来实现配置实现。&lt;br/&gt;下面的配置中，我们通过制定匹配规则将以空格开头的所有行合并到上一行,并把以Caused by开头的也追加到上一行。&lt;br/&gt;在Logstash的input配置中添加如下配置:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
 codec =&amp;gt; multiline {
          pattern =&amp;gt; &quot;\s*\[&quot;
          negate =&amp;gt; &quot;true&quot;
          what =&amp;gt; &quot;previous&quot;
        }
        
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;异常日志:&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200813175244616.png#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;原异常日志在ElasticSearch中示例图:&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200813175733878.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhendzeHBjbQ==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;多行合并之后的效果图:&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200813180752587.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhendzeHBjbQ==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;完整配置&quot;&gt;完整配置&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;logstash-test.conf 配置&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;input{
    file {
        path =&amp;gt; [&quot;/home/logs/mylog-2020-08-13.0.txt&quot;]
        type =&amp;gt; &quot;java&quot;
        start_position =&amp;gt; &quot;beginning&quot;
        sincedb_path =&amp;gt; &quot;/dev/null&quot;
    }
    file {
        path =&amp;gt; [&quot;/home/logs2/*.txt&quot;]
        type =&amp;gt; &quot;java2&quot;
        codec =&amp;gt; multiline {
          pattern =&amp;gt; &quot;\s*\[&quot;
          negate =&amp;gt; &quot;true&quot;
          what =&amp;gt; &quot;previous&quot;
        }
        start_position =&amp;gt; &quot;beginning&quot;
        sincedb_path =&amp;gt; &quot;/dev/null&quot;
    }
}

filter {

   grok {
         match =&amp;gt; { &quot;message&quot; =&amp;gt;&quot;\|%{DATA:log_time}\|%{DATA:thread}\|%{DATA:log_level}\|%{DATA:class_name}\|-%{GREEDYDATA:content}&quot; }       
    }

  ruby {
   code =&amp;gt; &quot;event.set('timestamp', event.get('@timestamp').time.localtime + 8*60*60)&quot;
 }
 ruby {
   code =&amp;gt; &quot;event.set('@timestamp',event.get('timestamp'))&quot;
 }
 mutate {
   remove_field =&amp;gt; [&quot;timestamp&quot;]
 }
}




output {
  stdout {
    codec =&amp;gt; rubydebug
  }
    if [type] == &quot;java&quot;{
      elasticsearch {
         hosts =&amp;gt; [&quot;127.0.0.1:9200&quot;]
         index =&amp;gt; &quot;mylog-%{+YYYY.MM.dd}&quot;
      }
    }

    if [type] == &quot;java2&quot;{
      elasticsearch {
         hosts =&amp;gt; [&quot;127.0.0.1:9200&quot;]
         index =&amp;gt; &quot;mylog-%{+YYYY.MM}&quot;
      }
    }
  
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;异常问题解决方案&quot;&gt;异常问题解决方案&lt;/h3&gt;
&lt;p&gt;1.logstash: Could not execute action: PipelineAction::Create, action_result: false&lt;/p&gt;
&lt;p&gt;解决办法: 斜杆采用“/”&lt;/p&gt;
&lt;p&gt;2, logstash: object mapping for [host] tried to parse field [host] as object, but found a concrete value&lt;/p&gt;
&lt;p&gt;解决办法: 在filter里面添加如下配置:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; mutate {
      rename =&amp;gt; { &quot;host&quot; =&amp;gt; &quot;host.name&quot; }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;其它&quot;&gt;其它&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/xuwujing/tag/elasticsearch/&quot;&gt;ElasticSearch实战系列&lt;/a&gt;:&lt;/p&gt;
&lt;h3 id=&quot;音乐推荐&quot;&gt;音乐推荐&lt;/h3&gt;

&lt;p&gt;原创不易，如果感觉不错，希望给个推荐！您的支持是我写作的最大动力！&lt;br/&gt;版权声明:&lt;br/&gt;作者：虚无境&lt;br/&gt;博客园出处：&lt;a href=&quot;http://www.cnblogs.com/xuwujing&quot;&gt;http://www.cnblogs.com/xuwujing&lt;/a&gt;&lt;br/&gt;CSDN出处：&lt;a href=&quot;http://blog.csdn.net/qazwsxpcm&quot;&gt;http://blog.csdn.net/qazwsxpcm&lt;/a&gt;　　　　&lt;br/&gt;个人博客出处：&lt;a href=&quot;http://www.panchengming.com&quot;&gt;http://www.panchengming.com&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 17 Aug 2020 14:51:00 +0000</pubDate>
<dc:creator>虚无境</dc:creator>
<og:description>前言 在上一篇中我们介绍了Logstash快速入门，本文主要介绍的是ELK日志系统中的Logstash的实战使用。实战使用我打算从以下的几个场景来进行讲解。 时区问题解决方案 在我们使用logstas</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xuwujing/p/13520666.html</dc:identifier>
</item>
<item>
<title>信号完整性之“过冲“（振铃）深度分析 - 失心少年悟红尘</title>
<link>http://www.cnblogs.com/Spring-Ltc/p/13512099.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Spring-Ltc/p/13512099.html</guid>
<description>&lt;p&gt;信号在传输的过程中，往往不是标准的矩形波信号，尤其在高速信号中，保证信号的完整性是十分重要的，影响信号完整性最主要的因素之一，就是阻抗不匹配，通常表现在传输线上，而阻抗不匹配直接导致信号的反射，反射信号与原始信号叠加，就会产生过冲、回沟、台阶等信号完整性问题。本文将主要对因传输线阻抗不匹配导致信号产生过冲（上冲overshoot、下冲undershoot）进行深度分析，并提出部分可行的解决方案。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;181&quot;&gt;
&lt;p&gt; 信号在传输的过程中，往往不是标准的矩形波信号，尤其在高速信号中，保证信号的完整性是十分重要的，影响信号完整性最主要的因素之一，就是阻抗不匹配，通常表现在传输线上，而阻抗不匹配直接导致信号的反射，反射信号与原始信号叠加，就会产生过冲、回沟、台阶等信号完整性问题。本文将主要对因传输线阻抗不匹配导致信号产生过冲（上冲overshoot、下冲undershoot）进行深度分析，并提出部分可行的解决方案。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一、过冲的定义&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　过冲是振铃的一部分，信号电平发生跳变后，第一个峰值电压或谷值电压超过设定的标准电压，主要表现为一个尖端脉冲。&lt;/p&gt;
&lt;p&gt;　　一般描述过冲的影响，主要考虑：过冲的最大幅值、过冲的持续时间、过冲的发生频率这三个要素。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;二、过冲和振铃的危害&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　1、当过冲幅值较大或持续时间较长时，可能回导致电路元器件的失效；&lt;/p&gt;
&lt;p&gt;　　2、振铃产生的电压波动，可能回多次跨越逻辑电平的电压阈值，造成接收端的误判&lt;/p&gt;

&lt;p&gt;&lt;span&gt;三、过冲产生原因&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　本质原因是：传输线阻抗不匹配造成信号的反射，多个反射信号和原信号叠加导致过冲和振铃。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、反射及反射系数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　如下图所示，设区域1阻抗为Z&lt;sub&gt;1&lt;/sub&gt;，区域2阻抗为Z&lt;sub&gt;2&lt;/sub&gt;，信号经过两个阻抗不同的区域，在交界处A处，电压和电流不能产生突变（若电压不连续，将产生无穷大的电场；若电流不连续，将产生无穷大的磁场）。                 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1812998/202008/1812998-20200816173944434-884259946.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;







&lt;p&gt;　　若Z&lt;sub&gt;1&lt;/sub&gt; ≠ Z&lt;sub&gt;2&lt;/sub&gt;，则关系式 V&lt;sub&gt;1&lt;/sub&gt; =I&lt;sub&gt;1&lt;/sub&gt; ×Z&lt;sub&gt;1&lt;/sub&gt; ;  V2 =I2 ×Z&lt;sub&gt;2&lt;/sub&gt;   无法同时满足电压和电流连续的条件V&lt;sub&gt;1&lt;/sub&gt; = V&lt;sub&gt;2&lt;/sub&gt;,I&lt;sub&gt;1&lt;/sub&gt; = I&lt;sub&gt;2&lt;/sub&gt; ，故只能从电磁波反射的角度进行分析，如下所示。&lt;/p&gt;
&lt;p&gt;　　信号由区域1往区域2传输的过程中，入射(incident)信号、反射信号(reflect)、传输信号(transfer)分别如下图表示：&lt;/p&gt;
&lt;p&gt;   &lt;img src=&quot;https://img2020.cnblogs.com/blog/1812998/202008/1812998-20200816205010623-292657996.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;     &lt;img src=&quot;https://img2020.cnblogs.com/blog/1812998/202008/1812998-20200816205212848-878147276.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;       &lt;/p&gt;
&lt;p&gt; 　　分界面两侧的电压相等，有 V&lt;sub&gt;inc&lt;/sub&gt; + V&lt;sub&gt;ref&lt;/sub&gt; = V&lt;sub&gt;tra&lt;/sub&gt;  ；&lt;/p&gt;
&lt;p&gt;　 　分界面两侧的电流相等，有I&lt;sub&gt;inc&lt;/sub&gt; - I&lt;sub&gt;ref&lt;/sub&gt; = I&lt;sub&gt;tra&lt;/sub&gt;     ；&lt;/p&gt;
&lt;p&gt;　 　再有 I&lt;sub&gt;inc &lt;/sub&gt; × Z&lt;sub&gt;1&lt;/sub&gt; = V&lt;sub&gt;inc    ；&lt;/sub&gt;I&lt;sub&gt;&lt;sub&gt;ref &lt;/sub&gt; ×&lt;/sub&gt; Z&lt;sub&gt;&lt;sub&gt;1&lt;/sub&gt; =&lt;/sub&gt; V&lt;sub&gt;ref&lt;sub&gt;    ；&lt;/sub&gt;&lt;/sub&gt;I&lt;sub&gt;tra ×&lt;/sub&gt; Z&lt;sub&gt;&lt;sub&gt;1&lt;/sub&gt; =&lt;/sub&gt; V&lt;sub&gt;tra    ；&lt;/sub&gt;&lt;/p&gt;
&lt;p&gt; 　　由以上5个等式可以推导得出：&lt;/p&gt;

&lt;p&gt;  &lt;img src=&quot;https://img2020.cnblogs.com/blog/1812998/202008/1812998-20200816213216952-1924443405.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;            &lt;img src=&quot;https://img2020.cnblogs.com/blog/1812998/202008/1812998-20200816213450821-1801672620.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt;2、建立传输模型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1812998/202008/1812998-20200816111518651-2071462083.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;






&lt;p&gt;　　一般理想情况下，末端接收端的输入阻抗无穷大，源端输出端的输出阻抗趋近于0。设源端串接的匹配电阻阻抗为Rs，传输线(即PCB走线)阻抗为Rz。&lt;/p&gt;
&lt;p&gt; 　　信号在线上由A往B传送时，在B点信号的反射系数为1，即全反射；&lt;/p&gt;
&lt;p&gt;　　由B往A传送时，在A点信号的反射系数为 (Rs-Rz)/(Rs+Rz)。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;3、展开时间轴，计算实时反射波形&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;下面举个栗子&lt;/p&gt;
&lt;p&gt;　　设传输线阻抗Rz=30Ω，源端串接的匹配电阻Rs=10Ω，则传输线左端A点反射系数为 (10 - 30)/(10 + 30) = -0.5,右端B点反射系数为 (+∞ - 30)/(+∞ + 30) = 1。&lt;/p&gt;
&lt;p&gt;　　设初始状态都为低电平0.0V，T0时刻源端跳变为3.3V，发送逻辑高电平信号，末端B点的电压变化如下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1812998/202008/1812998-20200816122131832-1520332142.png&quot; alt=&quot;&quot; width=&quot;872&quot; height=&quot;472&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
















&lt;p&gt;　　T1时刻，由于电阻分压，传输线左端A点电压为3.3*30/(10+40)=2.475V，抽象理解为T1时刻有一个+2.475V的信号在传输线上向B点传播；&lt;/p&gt;
&lt;p&gt;　　T2时刻，该信号在B点产生全反射(反射系数为1)，T2时刻B点电压为原始信号、入射信号、反射信号的叠加，即0+2.475+2.475 = 4.95V；&lt;/p&gt;
&lt;p&gt;　　T3时刻，末端的一次反射信号到达A点，由于阻抗不匹配，反射电压为2.475 * (-0.5）=-1.2375V，此时A点电压也为原始信号、入射信号、反射信号的叠加；&lt;/p&gt;
&lt;p&gt;　　T4时刻，源端的一次反射信号到达B点，同理计算末端B点电压为4.95-1.2375-1.2375 = 2.475V；&lt;/p&gt;
&lt;p&gt;　　T5时刻，末端的二次反射信号到达A点........&lt;/p&gt;
&lt;p&gt;　　T6时刻，源端的二次反射信号达到B点，如上图所示计算B点电压为 3.7125V&lt;/p&gt;
&lt;p&gt;　　.......................................................................&lt;/p&gt;
&lt;p&gt;　　在理想情况（无损传输）下，信号会在传输线A、B两端无休止的反射振荡，反射电压的幅值越来越趋近于0，在实际中信号在传输过程中有衰减，最终趋于稳态。&lt;/p&gt;
&lt;p&gt;　　下面我计算了约50多个数据，反应末端B点的电压变化，如下图所示：（左图为理论数据计算作图，右图为示波器测得实际波形） &lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1812998/202008/1812998-20200816154904540-1595384514.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;            &lt;em id=&quot;__mceDel&quot;&gt;&lt;img src=&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAcAAAAD2CAYAAABBcVd3AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAlMSURBVHhe7d2BcetEFAXQfJqgA3qgmlAFRVAFroYe6IAqQjaKGMXItiR7pefcc2Z2CBtLG+faeqz8/ufHy8vL2/sAgCg/ff6zq9fX18+vqEAetcijDlnU0juPXQogAFSjAAIQyWeAAESyAwQgkgIIQCRdoIHkUYs86pBFLbpAAaADBRCASLpAAYhkBwhAJAUQgEi6QAPJoxZ51CGLWnSBAkAHCiAAkXSBAhDJDhCASAogAJF0gQaSRy3yqEMWtegCBYAOFEAAIukCBSCSHSAAkRRAACLpAg0kj1rkUYcsatEFCgAdKIAARNIFCkAkO0AAIimAAETSBRpIHrXIow5Z1KILFAA6UAABiKQLFIBIdoAARPrYAU4/aDydTp9fff0A0vzA/MD8wPzA/MD84Fnmm3YLtOt4X3B23jhmyKPWkEedIYtao3ceboECEEkBBCCSLlAAItkBAhBJAQQg0i4F8PWs7ZRjyaMWedQhi1p652EHCEAkBRCASLpAAYhkBwhAJAUQntQv/7x9DGAbXaCB5FHLljymhU8RfBzvjVp0gQKz/v75x39DEYT1FEB4MnPFThGE9XSBwpNpha4VvDnXvgd8ZQcIQCQFEL4Rt0JhOV2ggeRRy5o83OLsy3ujFl2gANCBAgjfjNugsIwuUHgSa25/ulUKt9kBArNaET0f8J3YAcKTaAVoza5u7eNH00J3fvz4PbtLvgNdoIHkUUulPKYFbq7IjfPTIrlFO/7aOIr3Ri3X8ph73SwZU+0V3v3V1p7E6XT6/DeOJo9alubR3rxrd15rjhkvDmsev+XnGV07du3PMjVd45JL572WxZLzzlnz+9zq0hr3nHPO+TqPPP/ccxjzuLTO0t/t1PRc7ejH/oZmuODWIo9aKhXA3udv1qyx9JjxcaOtj59mcf6YZs3PPpo7zyVbzt9cW2PrOec86ncyZ+7cv/7+28tff/z58fUjn8eonXF5OsAh2sVh68V3yXHjxWfrGs2lY6cXtq0Xsek5Ltl67ubS+e85J/W1dG+/soBDtQv0PcXj1rH3nL8ZC8j0HNOiopBQUXtVKoBQXM8CeG/xm5oWvUbhozJdoIHkUcuReZwXrHu1gjcdz8Z7o5beefiD8BBqLH52aaRSAOGbawWuFbvpbk/xA58BwlNoBesRxWpaBBU/0imAUNyjih/wlVugAETSBRpIHrXIow5Z1KILFAA6UAABiKQJBorTBAN92AECEEkBBCCSLtBA8qjlWh5uf+7Le6MWXaAA0IECCEAkXaBQmFug0I8dIACRFEAAIukCDSSPWuRRhyxq0QUKAB0ogABE0gUKRekAhb7sAAGI9LEDnH7QeDqdPr/6+gGk+YH5gfmB+YH5gfnBs8w37RZo1/G+4Oy8ccyQR61xKY9f/nmbnTf6De+NWqN3Hm6BAhBJAQQgki5QKEoXKPRlBwhAJAUQgEi7FMDXs7ZTjiWPWubycPvzGN4btfTOww4QgEgKIACRdIFCQW6BQn92gABEUgABiKQLNJA8apFHHbKoRRcoAHSgAAIQSRcoFKQLFPqzAwQgkgIIxdj9wT50gQaSRy3yqEMWtegCBYAOFEAAIukChWJ8Bgj7sAMEIJICCEAkXaCB5FGLPOqQRS26QAGgAwUQgEi6QKEYXaCwDztAKETxg/0ogABE0gUaSB61yKMOWdSiCxQAOlAAAYikCxQK0QQD+7EDBCCSAghAJF2ggeRRizzqkEUtukABoAMFEIBIukChCB2gsC87QAAiKYAARNIFGkgetcijDlnUogsUADpQAAGIpAsUitAFCvuyAwQgkgIIQCRdoIHkUYs86pBFLbpAAaADBRAK0AAD+9MFCgUogLC/jwI4vc96Op0+v/p6/9X8wPzA/OBR83/98ed/BXDPdc0PzA/S5u0AoQA7QNifLtBA8qhFHnXIopbeeWiCASCSAghAJJ8BQgE+A4T92QECEEkBBCCSLtBA8qhFHnXIohZdoBDA53+wPwUQgEi6QOFgOkDhGHaAAERSAAGIpAs0kDxq+fX33z6/4mjeG7XoAgWADhRAACLpAoWD6QKFY9gBAhBJAYQD2f3BcXSBBpJHLfKoQxa16AIFgA4UQAAi6QKFA/kMEI5jBwhAJAUQgEi6QAPJoxZ51CGLWnSBAkAHCiAAkXSBwoF0gcJx7AABiKQAAhBJF2ggedQijzpkUYsuUADoQAEEIJIuUDiQLlA4jh0gAJEUQAAi6QINJI8axtuf8qhDFrXoAgWADhRAACLpAoWD6ACFY9kBAhBJAQQgki7QQPKoRR51yKIWXaAA0IECCAfQAAPH0wUKB1AA4Xh2gABEUgABiKQLNJA8apFHHbKoRRcoAHSgAAIQSRco7EwHKNTwUQCn91lPp9PnV1/vv5ofmB+YH2yZn/v/AO6x7sj8wPwged4OEHZmBwg16AINJI9a5FGHLGrpnYcmGAAiKYCwI7c/oQ6fAcKOFECoww4QgEgKIACRdIEGkkct8qhDFrXoAoUC2md35wN4bgog3NCKXWtcmY5xfo3xPEANukB5eueF6JFF5lrRGtddup4CCLUogEWsvZhWdl6Qph71/KZrnJ/zUb/LJQVrzVpLzgfs58f7m/LtEW/K8UKwxJb11py/uec5rV2rubTe0nONx996/NrnteW5NPeus/T3sXadUTvPtWOn6/RaYzSudevn2fpzAH20d+Tb9GIxWnpxmbp0TOvkmf5t3JeOv2XNBWTrGqO1F6tr6z3ywrfleZ2vf57HuUesscR0nSXHr318Mx6z9udrx6055tbjr33/Vh7sRxa17JFHu0L8b7y/YS+OucdfG+9PYnbeOGZUy+PSa2xubstYe46ta80dt2Rd7486Qxa1Ru88LnaBtv9avTTgkeZeX+9F4+Of5/NbzJ13TvteG/esNXf+e84H9NPemZevCPDNXCuAjyhUCiA8DwUQgEj+IDwAkfxdoIHkUYs86pBFLb3zsAMEIJICCEAkTTAARLIDBCCSAghAJF2ggeRRizzqkEUtukABoAMFEIBIukABiGQHCEAkBRCASLpAA8mjFnnUIYtadIECQAcKIACRdIECEMkOEIBICiAAkXSBBpJHLfKoQxa16AIFgA4UQAAi6QIFIJIdIACRFEAAIukCDSSPWuRRhyxq0QUKAB0ogABE0gUKQCQ7QAACvbz8C2aDT7YZ9bkIAAAAAElFTkSuQmCC&quot; width=&quot;531&quot; height=&quot;292&quot;/&gt;&lt;/em&gt;       &lt;/p&gt;
&lt;p&gt; 　　由以上理论推导和数据可知，当源端信号发生跳变后，由于阻抗不匹配，末端会产生多个超过或低于期望电平的脉冲，这就是振铃现象，第一个脉冲就是过冲。&lt;/p&gt;
&lt;p&gt; 　　在下写了一小段C语言代码用于生成数据，copy到excel绘制散点图，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('e748374f-7403-4acf-bebc-4c579e98ec24')&quot; readability=&quot;33.5&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_e748374f-7403-4acf-bebc-4c579e98ec24&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_e748374f-7403-4acf-bebc-4c579e98ec24&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_e748374f-7403-4acf-bebc-4c579e98ec24&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; #include &amp;lt;stdio.h&amp;gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; DataNum 100    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;100个数据模拟波形&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; StartNum 30    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;30个起始数据，方便对比&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;系统初始条件，参数可改&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;float&lt;/span&gt; SourceRes=&lt;span&gt;10.0&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;源端电阻&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;float&lt;/span&gt; LineRes=&lt;span&gt;30.0&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;传输线电阻&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;float&lt;/span&gt; StartVoltage=&lt;span&gt;0.0&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始电平&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;float&lt;/span&gt; TailVoltage=&lt;span&gt;3.3&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;跳变后电平&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;float&lt;/span&gt; ReflectTail = &lt;span&gt;1.0&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;末端反射系数，    假设接收端输入阻抗无穷大，为全反射&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;float&lt;/span&gt; ReflectSource;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;源端反射系数&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;float&lt;/span&gt;&lt;span&gt; StartTransferVoltage;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;float&lt;/span&gt;&lt;span&gt; VoltageReflectSource;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;float&lt;/span&gt; OutputData[DataNum]={&lt;span&gt;0&lt;/span&gt;&lt;span&gt;};
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; i,j;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     ReflectSource = (SourceRes-LineRes)/(SourceRes+LineRes);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算源端反射系数&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;     VoltageReflectSource = (TailVoltage-StartVoltage)*LineRes/(SourceRes+LineRes);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算传输线起始端电压&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;StartNum;i++)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加初始数据&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;         OutputData[i]=&lt;span&gt;StartVoltage;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(;i&amp;lt;DataNum;i++)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开始计算保存数据&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         OutputData[i] = OutputData[i-&lt;span&gt;1&lt;/span&gt;] + (VoltageReflectSource + VoltageReflectSource*&lt;span&gt;ReflectTail);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         VoltageReflectSource *= (ReflectSource*&lt;span&gt;ReflectTail);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(j=&lt;span&gt;0&lt;/span&gt;;j&amp;lt;DataNum;j++)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出数据用于Excel绘图&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%f\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,OutputData[j]);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     system(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pause&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;4、改变阻抗匹配条件对比分析波形&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　通过改变源端匹配电阻 Rs 的阻值，得到如下一部分模拟数据&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1812998/202008/1812998-20200816155751089-1948027088.png&quot; alt=&quot;&quot; width=&quot;384&quot; height=&quot;226&quot; loading=&quot;lazy&quot;/&gt;  &lt;img src=&quot;https://img2020.cnblogs.com/blog/1812998/202008/1812998-20200816155808632-548976670.png&quot; alt=&quot;&quot; width=&quot;386&quot; height=&quot;227&quot; loading=&quot;lazy&quot;/&gt;  &lt;img src=&quot;https://img2020.cnblogs.com/blog/1812998/202008/1812998-20200816155833489-1802704982.png&quot; alt=&quot;&quot; width=&quot;385&quot; height=&quot;226&quot; loading=&quot;lazy&quot;/&gt;  &lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1812998/202008/1812998-20200816155900542-1172038152.png&quot; alt=&quot;&quot; width=&quot;385&quot; height=&quot;222&quot; loading=&quot;lazy&quot;/&gt;  &lt;img src=&quot;https://img2020.cnblogs.com/blog/1812998/202008/1812998-20200816155915049-402620174.png&quot; alt=&quot;&quot; width=&quot;390&quot; height=&quot;224&quot; loading=&quot;lazy&quot;/&gt;  &lt;img src=&quot;https://img2020.cnblogs.com/blog/1812998/202008/1812998-20200816155927969-1319470698.png&quot; alt=&quot;&quot; width=&quot;389&quot; height=&quot;223&quot; loading=&quot;lazy&quot;/&gt;  &lt;/p&gt;

&lt;p&gt;　　可以发现，当源端电阻小于传输线电阻时，信号变化比较快（上升时间较短），但是会伴随着过冲的产生，影响信号的完整性；&lt;/p&gt;
&lt;p&gt;　　当源端电阻大于传输线电阻时，信号上升相对比较平缓，能有效解决过冲问题，但是增大了上升时间，限制了信号的传输速度；&lt;/p&gt;
&lt;p&gt;　　只有当源端电阻和传输线电阻相等时（即阻抗匹配状态），信号质量最接近理想状态。&lt;/p&gt;
&lt;p&gt; 　　　　注：当源端电平发生由1到0的负跳变时，分析方法同上，这里不再重复阐述，用于生成模拟数据的代码仍然可用&lt;/p&gt;


&lt;p&gt;&lt;span&gt;四、解决方案&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　1、减小驱动端的输出电流&lt;/p&gt;
&lt;p&gt;　　2、端接电阻进行阻抗匹配，本质上是消除信号路径端点的阻抗突变&lt;/p&gt;
&lt;p&gt;　　　　大多数情况下在源端串联一个匹配电阻，使传输线阻抗与源端阻抗匹配，在PCB走线时，该电阻尽可能靠近源端器件的输出管脚；&lt;/p&gt;
&lt;p&gt;　　　　也有部分情况在末端并联一个匹配电阻到电源或地，以消除信号在末端的一次反射，但这种方式增大了电路的功耗，一般不建议采用；&lt;/p&gt;
&lt;p&gt;　　3、增加TVS二极管限制峰值&lt;/p&gt;

&lt;p&gt;&lt;em&gt; &lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Mon, 17 Aug 2020 14:18:00 +0000</pubDate>
<dc:creator>失心少年悟红尘</dc:creator>
<og:description>信号在传输的过程中，往往不是标准的矩形波信号，尤其在高速信号中，保证信号的完整性是十分重要的，影响信号完整性最主要的因素之一，就是阻抗不匹配，通常表现在传输线上，而阻抗不匹配直接导致信号的反射，反射信</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Spring-Ltc/p/13512099.html</dc:identifier>
</item>
<item>
<title>CopyOnWriteArrayList源码阅读笔记 - 三分恶</title>
<link>http://www.cnblogs.com/three-fighter/p/13520475.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/three-fighter/p/13520475.html</guid>
<description>&lt;p&gt;ArrayList是开发中使用比较多的集合，它不是线程安全的，CopyOnWriteArrayList就是线程安全版本的ArrayList。CopyOnWriteArrayList同样是通过数组实现，这个类的名字叫“CopyOnWrite ”，它是在写入的时候拷贝数组，对副本进行操作。&lt;/p&gt;&lt;br/&gt;&lt;h2 id=&quot;原理&quot;&gt;原理&lt;/h2&gt;
&lt;p&gt;CopyOnWriteArrayList采用了一种&lt;strong&gt;读写分离&lt;/strong&gt;的并发策略。CopyOnWriteArrayList容器允许并发读，读操作是无锁的，性能较高。至于写操作，比如向容器中添加一个元素，则&lt;strong&gt;首先将当前容器复制一份，然后在新副本上执行写操作，结束之后再将原容器的引用指向新容器。&lt;/strong&gt;示意图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200817213116843.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;继承体系&quot;&gt;继承体系&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200817180438367.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;通过类图，可以看到CopyOnWriteArrayList的继承体系·：&lt;/p&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;实现了List, RandomAccess, Cloneable, java.io.Serializable等接口。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;实现了List，提供了基础的添加、删除、遍历等操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;实现了RandomAccess，提供了随机访问的能力。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;实现了Cloneable，可以被克隆。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;实现了Serializable，可以被序列化。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;br/&gt;&lt;h2 id=&quot;属性&quot;&gt;属性&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    //可重入锁，保证线程安全
    final transient ReentrantLock lock = new ReentrantLock();
    
    //存放数据元素的数组，只能通过get/set方法访问
    private transient volatile Object[] array;

    final Object[] getArray() {
        return array;
    }
    
    final void setArray(Object[] a) {
        array = a;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;lock：用于修改时加锁，使用transient修饰表示不自动序列化。&lt;/li&gt;
&lt;li&gt;array:被使用volatile修饰表示一个线程对这个字段的修改另外一个线程立即可见。&lt;/li&gt;
&lt;/ul&gt;&lt;br/&gt;&lt;h2 id=&quot;构造方法&quot;&gt;构造方法&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;无参构造方法：创建一个空数组&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public CopyOnWriteArrayList() {
        setArray(new Object[0]);
 }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;有参构造方法，参数为集合&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    public CopyOnWriteArrayList(Collection&amp;lt;? extends E&amp;gt; c) {
        Object[] elements;
         // 如果c也是CopyOnWriteArrayList类型
        // 那么直接把它的数组拿过来使用
        if (c.getClass() == CopyOnWriteArrayList.class)
            elements = ((CopyOnWriteArrayList&amp;lt;?&amp;gt;)c).getArray();
        else {
           //否则，先转换为数组
            elements = c.toArray();
            // c.toArray might (incorrectly) not return Object[] (see 6260652)
           //  检查c.toArray()返回的是不是Object[]类型，如果不是，重新拷贝成Object[].class类型
            if (elements.getClass() != Object[].class)
                elements = Arrays.copyOf(elements, elements.length, Object[].class);
        }
        setArray(elements);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;有参构造方法，参数为数组&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    //把toCopyIn的元素拷贝给当前list的数组。
    public CopyOnWriteArrayList(E[] toCopyIn) {
        setArray(Arrays.copyOf(toCopyIn, toCopyIn.length, Object[].class));
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;br/&gt;&lt;h2 id=&quot;adde-e&quot;&gt;add(E e)&lt;/h2&gt;
&lt;p&gt;添加一个元素到末尾&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    public boolean add(E e) {
        //获取锁
        final ReentrantLock lock = this.lock;
        //加锁
        lock.lock();
        try {
           //旧数组
            Object[] elements = getArray();
            //获取旧数组长度
            int len = elements.length;
            //拷贝旧数组的值到新数组
            Object[] newElements = Arrays.copyOf(elements, len + 1);
            //将插入的元素放到最后
            newElements[len] = e;
            //存放元素数组置为新数组 
            setArray(newElements);
            return true;
        } finally {
            //释放锁
            lock.unlock();
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;br/&gt;&lt;h2 id=&quot;addint-index-e-element&quot;&gt;add(int index, E element)&lt;/h2&gt;
&lt;p&gt;在指定位置插入数组&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt; public void add(int index, E element) {
        //获取锁
        final ReentrantLock lock = this.lock;
        //加锁
        lock.lock();
        try {
           //旧数组
            Object[] elements = getArray();
            int len = elements.length;
            //判断下标是否越界
            if (index &amp;gt; len || index &amp;lt; 0)
                throw new IndexOutOfBoundsException(&quot;Index: &quot;+index+
                                                    &quot;, Size: &quot;+len);
            //新数组                                        
            Object[] newElements;
            int numMoved = len - index;
            if (numMoved == 0)
            // 如果插入的位置是最后一位
            // 那么拷贝一个n+1的数组, 其前n个元素与旧数组一致
                newElements = Arrays.copyOf(elements, len + 1);
            else {
                // 如果插入的位置不是最后一位
               // 那么新建一个n+1的数组
                newElements = new Object[len + 1];
                //拷贝旧数组[0,……index-1]下标的元素
                System.arraycopy(elements, 0, newElements, 0, index);
                //拷贝旧数组的其余元素到新数组[index+1，……length+1]，刚好空出了index下标位置
                System.arraycopy(elements, index, newElements, index + 1,
                                 numMoved);
            }
            //将插入的元素放到index下标位置
            newElements[index] = element;
            //给array赋值
            setArray(newElements);
        } finally {
           //释放锁
            lock.unlock();
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;写入操作:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在上面添加元素的操作中，都进行了加锁的操作&lt;/li&gt;
&lt;li&gt;拷贝一个新数组，长度等于原数组长度加1，并把原数组元素拷贝到新数组中&lt;/li&gt;
&lt;li&gt;把新数组赋值给当前对象的array属性，覆盖原数组&lt;/li&gt;
&lt;/ul&gt;&lt;br/&gt;&lt;h2 id=&quot;removeint-index&quot;&gt;remove(int index)&lt;/h2&gt;
&lt;p&gt;根据下标位置移除数据元素：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    public E remove(int index) {
        //获取锁
        final ReentrantLock lock = this.lock;
        //加锁 
        lock.lock();
        try {
           //旧数组
            Object[] elements = getArray();
            int len = elements.length;
            E oldValue = get(elements, index);
            int numMoved = len - index - 1;
            if (numMoved == 0)
            // 如果移除的是最后一位
            // 那么直接拷贝一份n-1的新数组, 最后一位就自动删除了
                setArray(Arrays.copyOf(elements, len - 1));
            else {
              // 如果移除的不是最后一位
             // 那么新建一个n-1的新数组
                Object[] newElements = new Object[len - 1];
                // 将前index个元素拷贝到新数组中
                System.arraycopy(elements, 0, newElements, 0, index);
                // 将index后面(不包含)的元素往前挪一位
               // 这样正好把index位置覆盖掉了, 相当于删除了
                System.arraycopy(elements, index + 1, newElements, index,
                                 numMoved);
                setArray(newElements);
            }
            return oldValue;
        } finally {
            //释放锁
            lock.unlock();
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;删除操作：&lt;/strong&gt;删除操作同理，将除要删除元素之外的其他元素拷贝到新副本中，然后切换引用，将原容器引用指向新副本。同属写操作，需要加锁。&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;getint-index&quot;&gt;get(int index)&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    public E get(int index) {
        return get(getArray(), index);
    }
   
    final Object[] getArray() {
        return array;
    }
    
    private E get(Object[] a, int index) {
        return (E) a[index];
    }

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;获取操作&lt;/strong&gt;:获取操作属于读操作，直接通过数组下标获取数据元素，没有加锁，所以保证了性能。&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;size&quot;&gt;size()&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    public int size() {
       //返回数组长度
        return getArray().length;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;和ArrayList不同，查看&lt;a href=&quot;https://blog.csdn.net/sinat_40770656/article/details/108033187&quot;&gt;ArrayList源码阅读笔记&lt;/a&gt;，可以发现ArrayList中是有size属性的，这是因为ArrayList数组的长度实际是要大于集合的大小的。CopyOnWriteArrayList每次修改都是拷贝一份正好可以存储目标个数元素的数组，所以不需要size属性，直接返回数组长度即可。&lt;/p&gt;
&lt;br/&gt;&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;CopyOnWriteArrayList使用ReentrantLock重入锁加锁，保证线程安全；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;CopyOnWriteArrayList的写操作都要先拷贝一份新数组，在新数组中做修改，修改完了再用新数组替换老数组，所以空间复杂度是O(n)，性能相对低下；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;CopyOnWriteArrayList的读操作支持随机访问，时间复杂度为O(1)；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;CopyOnWriteArrayList采用读写分离的思想，读操作不加锁，写操作加锁，且写操作占用较大内存空间，所以适用于读多写少的场合；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;CopyOnWriteArrayList只保证最终一致性，不保证实时一致性；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;纸上得来终觉浅，绝知此事要躬行。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;big&gt;&lt;strong&gt;参考：&lt;/strong&gt;&lt;/big&gt;&lt;/p&gt;
&lt;p&gt;【1】：&lt;a href=&quot;http://cmsblogs.com/?p=4729&quot;&gt;【死磕 Java 集合】— CopyOnWriteArrayList源码分析&lt;/a&gt;&lt;br/&gt;【2】：&lt;a href=&quot;https://www.cnblogs.com/chengxiao/p/6881974.html&quot;&gt;CopyOnWriteArrayList实现原理及源码分析&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 17 Aug 2020 14:17:00 +0000</pubDate>
<dc:creator>三分恶</dc:creator>
<og:description>简介 ArrayList是开发中使用比较多的集合，它不是线程安全的，CopyOnWriteArrayList就是线程安全版本的ArrayList。CopyOnWriteArrayList同样是通过数组</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/three-fighter/p/13520475.html</dc:identifier>
</item>
</channel>
</rss>