<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>数论分块之整除分块 - henry_y</title>
<link>http://www.cnblogs.com/henry-1202/p/10121854.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/henry-1202/p/10121854.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;最近在学莫比乌斯反演，然而只看懂了莫比乌斯函数，然后反演看着一脸懵逼，最后只看懂了数论分块里面的一个分支内容（也是莫比乌斯反演的前置姿势），整除分块&lt;br/&gt;于是写一篇博文记录一下整除分块&lt;/p&gt;
&lt;h2 id=&quot;整除分块&quot;&gt;整除分块&lt;/h2&gt;
&lt;p&gt;整除分块是用于快速处理形似&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \sum_{i=1}^{n}{\lfloor \frac{n}{i} \rfloor} \]&lt;/span&gt;&lt;br/&gt;的式子的方法&lt;br/&gt;很显然，这个可以&lt;span class=&quot;math inline&quot;&gt;\(O(n)\)&lt;/span&gt;得到答案。但是，在某些题目中，毒瘤出题人将数据加强到了&lt;span class=&quot;math inline&quot;&gt;\(10^{10}\)&lt;/span&gt;以上，这个时候我们就无法通过&lt;span class=&quot;math inline&quot;&gt;\(O(n)\)&lt;/span&gt;的解法来得到答案了。我们需要一个&lt;span class=&quot;math inline&quot;&gt;\(O(\sqrt{n})\)&lt;/span&gt;的更为优秀的解法&lt;br/&gt;首先观察这个式子，找几个特殊值代入&lt;br/&gt;&lt;code&gt;n=5时，sum=5+2+1+1+1&lt;/code&gt;&lt;br/&gt;可以发现的是：（这里给的例子并不明显，其实应该找一个大的n来代入才直观，读者可以自行尝试）&lt;br/&gt;对于单一的&lt;span class=&quot;math inline&quot;&gt;\(\lfloor \frac{n}{i} \rfloor\)&lt;/span&gt;，某些地方的值是相同的，并且&lt;strong&gt;呈块状分布&lt;/strong&gt;&lt;br/&gt;通过进一步的探求规律与推理&lt;del&gt;以及打表与瞎猜&lt;/del&gt;，我们可以惊喜的发现一个规律，这些&lt;strong&gt;块状分布的值是有规律的&lt;/strong&gt;&lt;br/&gt;对于一个块，&lt;strong&gt;假设它的起始位置的下标为l，那么可以得到的是，它的结束位置的下标为&lt;span class=&quot;math inline&quot;&gt;\(\lfloor \frac{n}{\lfloor \frac{n}{l}\rfloor} \rfloor\)&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;如果实在看的有点懵逼，可以继续采用代入特殊值的方法，验证一下上方的规律，用程序表现出来即为&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;//l为块的左端点，r为块的右端点
r=n/(n/l)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在实际应用中，需要注意的就是&lt;strong&gt;除法除0&lt;/strong&gt;的问题（一般都需要特判一下n/l）&lt;br/&gt;程序实现也十分简单&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;int ans = 0;
for(int l = 1, r = 0; l &amp;lt;= n; l++) {
    r = n / (n / l);
    // do something
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;实际应用&quot;&gt;实际应用&lt;/h2&gt;
&lt;h3 id=&quot;例题bzoj1257-cqoi2007余数之和&quot;&gt;例题：&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/problem.php?id=1257&quot;&gt;BZOJ1257: [CQOI2007]余数之和&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;这题其实就是求&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \sum_{i=1}^{n}{k\space mod\space i} \]&lt;/span&gt;&lt;br/&gt;这题和整除分块又有什么关系呢？&lt;br/&gt;mod没有什么特殊的性质，所以我们将它展开来，就变成了&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \sum_{i=1}^{n}{k\space-\lfloor \frac{k}{i} \rfloor*i} \]&lt;/span&gt;&lt;br/&gt;于是我们就看到了一个熟悉的形式，也就是整除分块的一般形式&lt;/p&gt;
&lt;p&gt;再次改一下这个式子&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ n*k-\sum_{i=1}^{n}{\lfloor \frac{k}{i}\rfloor*i} \]&lt;/span&gt;&lt;br/&gt;那么&lt;span class=&quot;math inline&quot;&gt;\(\sum_{i=1}^{n}{\lfloor \frac{k}{i}\rfloor*i}\)&lt;/span&gt;和普通的整除分块有什么差别呢？&lt;/p&gt;
&lt;p&gt;&lt;del&gt;其实就是多了一个i&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;确实，就是多了一个i而已，只需要简单的化简一下，这个i就对我们的处理没有什么影响了&lt;/p&gt;
&lt;p&gt;因为我们知道，对于一个整除分块&lt;span class=&quot;math inline&quot;&gt;\(\sum_{i=l}^{r}{\lfloor\frac{k}{i}\rfloor}\)&lt;/span&gt;，其中的每个值都是相同的，于是我们可以设&lt;span class=&quot;math inline&quot;&gt;\(T=\lfloor\frac{k}{i}\rfloor\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;式子就化为了&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \sum_{i=l}^{r}T*i \\ =T*\sum_{i=l}^{r}i \]&lt;/span&gt;&lt;br/&gt;也就是说，其实这个式子前半段是一个整除分块，后半段是一个首项为l，公差为1的等差数列&lt;/p&gt;
&lt;p&gt;至此，我们就圆满的解决了这个问题，可以在&lt;span class=&quot;math inline&quot;&gt;\(O(\sqrt{n})\)&lt;/span&gt;的时间内解决本题&lt;/p&gt;
&lt;p&gt;这是整除分块中最基础的应用，就是单纯的利用整除分块来加速递推的实现，而实际上，整除分块更多的与其他函数结合在一起来使用，优化问题的求解&lt;/p&gt;
&lt;h3 id=&quot;整除分块与积性函数&quot;&gt;整除分块与积性函数&lt;/h3&gt;
&lt;p&gt;说到积性函数，就不得不讲到两个广为人知的函数&lt;span class=&quot;math inline&quot;&gt;\(\phi,\mu\)&lt;/span&gt;，这是我们最熟悉的积性函数&lt;del&gt;（其实我也只知道这两个）&lt;/del&gt;&lt;br/&gt;积性函数有一个很好用的性质（设&lt;span class=&quot;math inline&quot;&gt;\(f(i)\)&lt;/span&gt;为一个积性函数）：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ f(i*j)=f(i)*f(j) \]&lt;/span&gt;&lt;br/&gt;这里的&lt;span class=&quot;math inline&quot;&gt;\(f(i)\)&lt;/span&gt;其实是一个完全积性函数。（&lt;span class=&quot;math inline&quot;&gt;\(\phi\)&lt;/span&gt;就不是一个完全积性函数：&lt;span class=&quot;math inline&quot;&gt;\(\phi(i*j)=\phi(i)*\phi(j)\)&lt;/span&gt;当且仅当i，j互质才成立）&lt;br/&gt;好了，讲完积性函数的这个性质后我们步入正题，整除分块与积性函数的联系&lt;br/&gt;很多时候，我们推出来整除分块的式子不是很裸的，常与其他函数结合（通常是积性函数，通常为&lt;span class=&quot;math inline&quot;&gt;\(\mu\)&lt;/span&gt;或&lt;span class=&quot;math inline&quot;&gt;\(\phi\)&lt;/span&gt;）&lt;br/&gt;这个时候如何统计答案呢？&lt;br/&gt;比如：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \sum_{i=1}^{n}{\mu(i)*\lfloor \frac{n}{i}\rfloor} \]&lt;/span&gt;&lt;br/&gt;积性函数的性质！&lt;br/&gt;因为积性函数这个很好用的性质，所以我们可以直接对前半段的莫比乌斯函数维护一个前缀和，再利用整除分块处理式子的后半段，处理答案的时候，把两段相乘即可&lt;br/&gt;当然，整除分块能结合的函数肯定不止这么几个&lt;del&gt;（但是由于博主太菜所以并不知道其他的函数与整除分块结合的方法）&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(To\ Be\ Continue...\)&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 14 Dec 2018 15:40:00 +0000</pubDate>
<dc:creator>henry_y</dc:creator>
<og:description>前言 最近在学莫比乌斯反演，然而只看懂了莫比乌斯函数，然后反演看着一脸懵逼，最后只看懂了数论分块里面的一个分支内容（也是莫比乌斯反演的前置姿势），整除分块 于是写一篇博文记录一下整除分块 整除分块 整</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/henry-1202/p/10121854.html</dc:identifier>
</item>
<item>
<title>Kafka 详解（二）------集群搭建 - YSOcean</title>
<link>http://www.cnblogs.com/ysocean/p/9860880.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ysocean/p/9860880.html</guid>
<description>&lt;p&gt;　　这里通过 VMware ，我们安装了三台虚拟机，用来搭建 kafka集群，虚拟机网络地址如下：&lt;/p&gt;
&lt;p&gt;　　　hostname                      ipaddress        　　       subnet mask                          geteway　　　　&lt;/p&gt;
&lt;p&gt;　　1、 master　　　　　192.168.146.200　　　　255.255.255.0　　　　　　192.168.146.2&lt;/p&gt;
&lt;p&gt;　　2、 slave1　　　　　 192.168.146.201　　　　255.255.255.0　　　　　　192.168.146.2&lt;/p&gt;
&lt;p&gt;　　3、 slave2　　　　　 192.168.146.202　　　　255.255.255.0　　　　　　192.168.146.2&lt;/p&gt;
&lt;h3&gt;1、下载 kafka 压缩包&lt;/h3&gt;
&lt;p&gt;　　官网下载地址：&lt;a href=&quot;http://kafka.apache.org/downloads&quot; target=&quot;_blank&quot;&gt;http://kafka.apache.org/downloads&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;2、搭建zookeeper集群&lt;/h3&gt;
&lt;p&gt;　　由于 kafka 集群的运行需要 zookeeper，所以我们要首先进行 zookeeper 集群的搭建。&lt;/p&gt;
&lt;p&gt;　　关于搭建的教程，我在上一篇博客已经介绍了：&lt;a href=&quot;https://www.cnblogs.com/ysocean/p/9860529.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/ysocean/p/9860529.html&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;3、解压 kafka&lt;/h3&gt;
&lt;p&gt;　　将下载的 kafka 压缩文件上传到集群中的每台机器相应目录，执行如下命令进行解压。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
tar -zxf kafka_2.12-2.0.0.tgz
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;4、修改配置文件 server.properties&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; broker.id=0
&lt;span&gt;2&lt;/span&gt; listeners=PLAINTEXT:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;192.168.146.200:9092&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; zookeeper.connect=192.168.146.200:2181,192.168.146.201:2181,192.168.146.202:2181
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　第一个 broker.id 后面的值和搭建 zookeeper 集群中 myid 一样，是一个集群中唯一的数，要求是正数。需要保证kafka集群中设置的都不一样。&lt;/p&gt;
&lt;p&gt;　　第二个设置监听器，后面的 IP 地址对应当前的 ip 地址。&lt;/p&gt;
&lt;p&gt;　　第三个是配置 zookeeper 集群的 IP 地址。&lt;/p&gt;
&lt;p&gt;　　该配置文件的其余设置可以默认，具体会在后面博客进行介绍。&lt;/p&gt;
&lt;h3&gt;5、启动 kafka&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
/usr/local/software/kafka_2.12-2.0.0/bin/kafka-server-start.sh /usr/local/software/kafka_2.12-2.0.0/config/server.properties &amp;amp;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　该命令虽然是后台启动服务，但是日志仍然会打印到控制台。&lt;/p&gt;
&lt;p&gt;　　想要完全后台启动，执行如下命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
/usr/local/software/kafka_2.12-2.0.0/bin/kafka-server-start.sh /usr/local/software/kafka_2.12-2.0.0/config/server.properties 1&amp;gt;/dev/&lt;span&gt;null&lt;/span&gt; 2&amp;gt;&amp;amp;1 &amp;amp;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　其中1&amp;gt;/dev/null  2&amp;gt;&amp;amp;1 是将命令产生的输入和错误都输入到空设备，也就是不输出的意思。/dev/null代表空设备。&lt;/p&gt;
&lt;p&gt;　　执行完毕后，输入 jps ，出现 kafka 的进程，则证明启动成功。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1120165/201810/1120165-20181027224055873-1353580769.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;6、创建 topic&lt;/h3&gt;
&lt;p&gt;　　集群启动成功后，我们通过创建一个名字为 test，partitions为3，replication为3的topic。&lt;/p&gt;
&lt;p&gt;　　进入到bin 目录下，执行如下命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
./kafka-topics.sh --create --zookeeper 192.168.146.200:2181,192.168.146.201:2181,192.168.146.202:2181 --partitions 3 --replication-factor 3 --topic test
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;7、向 topic 发送消息&lt;/h3&gt;
&lt;p&gt;　　进入到 bin 目录下，执行如下命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
./kafka-console-producer.sh --broker-list 192.168.146.200:9092,192.168.146.201:9092,192.168.146.202:9092 --topic test
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1120165/201810/1120165-20181028201123120-2136390421.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　输入 hello kafka ，然后 enter 键，即向名为 test 的topic 发送了一条消息：hello kafka&lt;/p&gt;
&lt;h3&gt;8、kafka 可视化工具&lt;/h3&gt;
&lt;p&gt;　　为了更好的看到上一步创建的 topic，以及发送的消息。这里介绍一个 kafka 可视化工具——Kafka Tools，官网下载地址：&lt;a href=&quot;http://www.kafkatool.com/download.html&quot; target=&quot;_blank&quot;&gt;http://www.kafkatool.com/download.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　安装过程很简单，都是点击下一步即可。然后打开该工具，进行如下配置：&lt;/p&gt;
&lt;p&gt;　　点击 File ---&amp;gt; Add cluster&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1120165/201810/1120165-20181027230434691-85423639.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　然后点击有下家的 Add 按钮即可。&lt;/p&gt;
&lt;p&gt;　　点开刚刚创建的连接，出现如下界面：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1120165/201810/1120165-20181028201035588-550685212.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　test 便是我们上一步创建的 topic 名称，里面有一条消息 hello kafka。&lt;/p&gt;

</description>
<pubDate>Fri, 14 Dec 2018 15:33:00 +0000</pubDate>
<dc:creator>YSOcean</dc:creator>
<og:description>Kafka 详解（二）------集群搭建</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ysocean/p/9860880.html</dc:identifier>
</item>
<item>
<title>Android探究之Gson@SerializedName - juneyu</title>
<link>http://www.cnblogs.com/juneyu/p/10122171.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/juneyu/p/10122171.html</guid>
<description>&lt;h3 id=&quot;serializedname注解的意义&quot;&gt;@SerializedName注解的意义&lt;/h3&gt;
&lt;p&gt;当我们使用Gson解析Json数据时都会创建一个对应实体类，有时候Json数据里面的字段是Java关键词或者Json数据里面的字段太简单，我们想在实体类中自定义字段名，这时就可以用@SerializedName注解。&lt;/p&gt;
&lt;p&gt;@SerializedName注解，不管是对象转Json还是Json转对象，字段名称会被替换成注解的名字。&lt;/p&gt;
&lt;p&gt;@SerializedName这个注解解决了我们Model和Json不对应的问题，好处：&lt;/p&gt;
&lt;ol readability=&quot;3&quot;&gt;&lt;li&gt;首先将服务器字段和客户端字段名称区分，不用保持一一对应关系，客户端定义的字段不用根据服务端接口字段改变而改变，只需要更改@SerializedName中的取值即可；&lt;br/&gt;&lt;/li&gt;
&lt;li readability=&quot;9&quot;&gt;
&lt;p&gt;我们输出一个Json格式的数据也可以使用@SerializedName不用为了输出格式而影响java中驼峰命名规范；&lt;/p&gt;
&lt;h3 id=&quot;实例&quot;&gt;实例&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt; public class Test {

 public static void main(String[] args) {
     Gson gson = new Gson();
     User user = new User(&quot;juneyu&quot;, &quot;18&quot;);
     String json = gson.toJson(user);
     System.out.println(&quot;obj-&amp;gt;json:&quot; + json);
     User user2 = gson.fromJson(json, User.class);
     System.out.println(&quot;json-&amp;gt;obj:&quot; + user2);
 }

 public static class User{
     @SerializedName(&quot;Name&quot;)
     private String name;
     @SerializedName(&quot;Age&quot;)
     private String age;

     public User(String name, String age) {
         this.name = name;
         this.age = age;
     }

     @Override
     public String toString() {
         return &quot;User{&quot; +
                 &quot;name='&quot; + name + '\'' +
                 &quot;, age='&quot; + age + '\'' +
                 '}';
     }
 }&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;输出为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;obj-&amp;gt;json:{&quot;Name&quot;:&quot;juneyu&quot;,&quot;Age&quot;:&quot;18&quot;}
json-&amp;gt;obj:User{name='juneyu', age='18'}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;实现原理&quot;&gt;实现原理&lt;/h3&gt;
&lt;p&gt;查看Gson源码，在ReflectiveTypeAdapterFactory类中有如下代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  private Map&amp;lt;String, BoundField&amp;gt; getBoundFields(Gson context, TypeToken&amp;lt;?&amp;gt; type, Class&amp;lt;?&amp;gt; raw) {
    Map&amp;lt;String, BoundField&amp;gt; result = new LinkedHashMap&amp;lt;String, BoundField&amp;gt;();
    if (raw.isInterface()) {
      return result;
    }

    Type declaredType = type.getType();
    while (raw != Object.class) {
      Field[] fields = raw.getDeclaredFields();
      for (Field field : fields) {
        boolean serialize = excludeField(field, true);
        boolean deserialize = excludeField(field, false);
        if (!serialize &amp;amp;&amp;amp; !deserialize) {
          continue;
        }
        field.setAccessible(true);
        Type fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType());
        List&amp;lt;String&amp;gt; fieldNames = getFieldNames(field);
        BoundField previous = null;
        for (int i = 0; i &amp;lt; fieldNames.size(); ++i) {
          String name = fieldNames.get(i);
          if (i != 0) serialize = false; // only serialize the default name
          BoundField boundField = createBoundField(context, field, name,
              TypeToken.get(fieldType), serialize, deserialize);
          BoundField replaced = result.put(name, boundField);
          if (previous == null) previous = replaced;
        }
        if (previous != null) {
          throw new IllegalArgumentException(declaredType
              + &quot; declares multiple JSON fields named &quot; + previous.name);
        }
      }
      type = TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));
      raw = type.getRawType();
    }
    return result;
  }

  /** first element holds the default name */
  private List&amp;lt;String&amp;gt; getFieldNames(Field f) {
    SerializedName annotation = f.getAnnotation(SerializedName.class);
    if (annotation == null) {
      String name = fieldNamingPolicy.translateName(f);
      return Collections.singletonList(name);
    }

    String serializedName = annotation.value();
    String[] alternates = annotation.alternate();
    if (alternates.length == 0) {
      return Collections.singletonList(serializedName);
    }

    List&amp;lt;String&amp;gt; fieldNames = new ArrayList&amp;lt;String&amp;gt;(alternates.length + 1);
    fieldNames.add(serializedName);
    for (String alternate : alternates) {
      fieldNames.add(alternate);
    }
    return fieldNames;
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在getFieldNames方法中，在获取Field时去匹配了SerializedName注解类标示的字段，存在的话取的是注解设定的值。&lt;/p&gt;
&lt;h3 id=&quot;其它&quot;&gt;其它&lt;/h3&gt;
&lt;p&gt;情况一：多个字段取一个&lt;/p&gt;
&lt;p&gt;项目中只用了一个字段来更改解析字段名，还有一种情况，我们在开发的时候会用到，这里举一个不太合适的例子，例如：后台同学给配数据，后期要废弃其中一个字段，但又不能影响老版本的使用，于是增加了一个字段，取值相同。&lt;/p&gt;
&lt;p&gt;解决：&lt;/p&gt;
&lt;p&gt;当然我们在新版本直接将字段改成新字段取值就好了。&lt;br/&gt;这是一种解决办法，但是不能保证以后没有其它字段废弃或者添加，这里在介绍一个属性alternate简明知意，用来替换;&lt;br/&gt;可以这么写:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  @SerializedName(value = &quot;Name&quot;, alternate = {&quot;NameNew&quot;})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当出现Name或者NameNew字段时，就会主动匹配，当然如果都存在就匹配最后一个，这样在老版本上虽然服务器返回的是增加NameNew的数据，但是客户端使用的是@SerializedName(&quot;Name&quot;) 来解析的，所以也不会出问题，在新版本上使用NameNew字段，等完全替代老版本以后，就可以在服务器中去掉原来的Name字段，当然我这种情况是比较理想的，一般也不会说随意更改字段含义，但也不排除这种可能，如果有那我们自然应对就好。&lt;/p&gt;
&lt;p&gt;注意：&lt;br/&gt;1、千万注意要解析成对象的类，和对象转成Json的类，不要去混淆，否则会解析不成功，在Android中可以修改proguard-project.txt文件来过滤不混淆的类；&lt;/p&gt;
&lt;p&gt;2、需要注入到JS当中的类不能混淆；&lt;/p&gt;
&lt;p&gt;3、另外在使用Gson和FastJson中，发现 FastJson 在某些情况下内部会出现空指针，而且数据解析有可能不正确，项目中遇到一次在某条数据下出问题，然后替换了Gson就好了，具体区别还查证；&lt;/p&gt;
&lt;p&gt;4、自己使用的时候尽量封装以下，避免以后换库导致修改地方过多；&lt;/p&gt;
</description>
<pubDate>Fri, 14 Dec 2018 15:13:00 +0000</pubDate>
<dc:creator>juneyu</dc:creator>
<og:description>@SerializedName注解的意义 当我们使用Gson解析Json数据时都会创建一个对应实体类，有时候Json数据里面的字段是Java关键词或者Json数据里面的字段太简单，我们想在实体类中自定</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/juneyu/p/10122171.html</dc:identifier>
</item>
<item>
<title>Vue引入第三方JavaScript库和如何创建自己的Vue插件 - 双眸</title>
<link>http://www.cnblogs.com/both-eyes/p/10122164.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/both-eyes/p/10122164.html</guid>
<description>&lt;h3 id=&quot;一-第三方javascript库&quot;&gt;一 第三方JavaScript库&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;br/&gt;.vue文件 中不解析 script标签引入js文件，只能用 import 引入&lt;br/&gt;有两种用法:&lt;br/&gt;1.import a from '../a'&lt;br/&gt;2.import '../a'&lt;br/&gt;区别在于第一个你要用到export导出之后 才能用import导入。&lt;br/&gt;第二个是直接引入 和script标签是一样的. 但是它作用在自己的js文件中。&lt;/p&gt;
&lt;p&gt;在使用vue做项目的时候，我们一般不将css样式写到各自的组件里，这样不仅会让代码冗余，而且不美观整洁。如果你定义了一些外部css文件，如何引入到vue组件中去呢？我们这里使用ES6的引入方式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;template&amp;gt;&amp;lt;/template&amp;gt;
&amp;lt;style scoped&amp;gt;
 @import &quot;../assets/common/common.css&quot;;
&amp;lt;/style&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么JS文件如何引入呢？&lt;strong&gt;如果需要全局使用&lt;/strong&gt;，则可以在main.js中引用并实例化对象：&lt;/p&gt;
&lt;p&gt;部分js代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const DEBUG = true;
let BASE_URL = DEBUG ? 'url' : '';
const API = {
    //网关设备管理
    'edgeManager':{
        'deviceList':BASE_URL + '/devicemanager/device/list.do',//网关设备列表
        'deviceDelete':BASE_URL + '/devicemanager/device/delete.do'//网关设备删除
    }
}
export default API;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在main.js中：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import API from './assets/api/api.config.js'
Vue.prototype.$API = API;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样，我们在vue组件中使用&lt;code&gt;this.$API&lt;/code&gt;就可以找到这个js文件中的对象了。&lt;br/&gt;如：&lt;code&gt;this.$API.edgeManager.deviceList&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果需要按需引入，不在main.js中引入，直接在有需要的vue组件中引入：&lt;/p&gt;
&lt;p&gt;部分代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;template&amp;gt;&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;
import API from '../../assets/api/api.config.js'
&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样引入的话，我们在当前组件可以直接使用API去找到这个js文件中的对象。&lt;br/&gt;如：API.edgeManager.deviceList&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;需要注意的是，第二种方式按需引入的js文件在其他组件中是找不到这个对象的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;在vue.js应用中可能需要引入lodashmomentaxiosasync等非常好用的javascript库&quot;&gt;在Vue.js应用中，可能需要引入Lodash，Moment，Axios，Async等非常好用的JavaScript库。&lt;/h3&gt;
&lt;p&gt;当项目变得复杂庞大，通常会将代码进行模块化拆分。可能还需要跑在不同的环境下，比如浏览器，服务端。&lt;br/&gt;如何在各个模块和组件文件中引入需要的库呢？ 找到一种简单靠谱的方式，可以省去很多的麻烦。&lt;/p&gt;
&lt;h4 id=&quot;错误示范----------------&quot;&gt;----------------错误示范----------------&lt;/h4&gt;
&lt;h4 id=&quot;全局变量法&quot;&gt;全局变量法&lt;/h4&gt;
&lt;p&gt;最不靠谱的方式就是将导入的库挂在全部变量window对象下：&lt;br/&gt;entry.js&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;window._ = require('lodash');&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;MyComponent.vue&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;export default {
  created() {
    console.log(_.isEmpty() ? 'Lodash everywhere!' : 'Uh oh..');
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种方式的缺点有很多，我们只说其中一个关键的点：不支持服务端渲染。当应用跑在服务端时，window对象不存在，当然试图去访问window下的属性会抛出错误。&lt;/p&gt;
&lt;h4 id=&quot;处处引入法&quot;&gt;处处引入法&lt;/h4&gt;
&lt;p&gt;另外一个不太优雅的方式就是在需要的每个文件中都引入对应的库：&lt;br/&gt;MyComponent.vue&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import _ from 'lodash';

export default {
  created() {
    console.log(_.isEmpty() ? 'Lodash is available here!' : 'Uh oh..');
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;虽然这方法是可行的，但是太不简洁。你必须在每个文件中都记得引入， 而且如果不需要了，又得重新删除。另外，如果打包策略不够明智的话，可能会打包出多份重复的代码。&lt;/p&gt;
&lt;h3 id=&quot;正确引入方式-----------&quot;&gt;-----------正确引入方式-----------&lt;/h3&gt;
&lt;p&gt;最简单靠谱的方式是用库变成Vue的原型对象的属性。下面，我来演示如何将Moment库引入：&lt;br/&gt;entry.js&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import moment from 'moment';
Object.defineProperty(Vue.prototype, '$moment', { value: moment });&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于所有的组件都会继承Vue原型对象上的方法，因此这些方法在任何组件文件中都能通过&lt;code&gt;this.$moment&lt;/code&gt;访问到：&lt;br/&gt;MyNewComponent.vue&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;export default {
  created() {
    console.log('The time is ' . this.$moment().format(&quot;HH:mm&quot;));
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们来仔细看一下其中的原理。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Object.defineProperty&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通常我们会如下设置对象属性：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Vue.prototype.$moment = moment;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你也可以这么做，但是&lt;code&gt;Object.defineProperty&lt;/code&gt;允许我们用属性描述器来定义我们的属性。我们可以定义该属性是否可写，可枚举，可配置。&lt;br/&gt;一般情况下，我们不需要用那么复杂的方式来赋值属性。但这里用它有个好处：用属性描述器定义的属性是默认只读的。&lt;br/&gt;这能防止那些脑子不清醒的开发者犯下一些低级错误：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;this.$http = 'Assign some random thing to the instance method';
this.$http.get('/'); // TypeError: this.$http.get is not a function&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Object.defineProperty&lt;/code&gt;能保护引入的库不被重新赋值，如果你尝试重写，程序会抛出&lt;code&gt;“TypeError: Cannot assign to read only property”&lt;/code&gt;的错误。&lt;/p&gt;
&lt;h4 id=&quot;section&quot;&gt;$&lt;/h4&gt;
&lt;p&gt;可能你注意到，我们用&lt;code&gt;“$”&lt;/code&gt;开头的属性来存放引入的库。当然，你应该记得还有其他的一些属性也是这样的，比如&lt;code&gt;$refs， $on， $mount。&lt;/code&gt;&lt;br/&gt;这种做法不是强制的，这个前缀就是为了提醒某些昏昏沉沉的开发者，这些属性是公有的，你可以在任何地方使用。反之，某些属性只能在Vue内部使用。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;作为一门以原型为基本的语言，JavaScript中并没有真正的类，所以也就没有所谓的公有，私有变量，或者静态方法。上面这种约定，我觉得是种不错的选择。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;this&quot;&gt;this&lt;/h4&gt;
&lt;p&gt;现在你能用&lt;code&gt;this.$libraryName&lt;/code&gt;的方式来访问你需要的库了。但，你得保证this的指向。如果你在回调函数中使用this，通常这个this不再指向Vue实例。&lt;br/&gt;箭头函数是解决这个问题的好方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;this.$http.get('/').then(res =&amp;gt; {
  if (res.status !== 200) {
    this.$http.get('/') // etc
    // Only works in a fat arrow callback.
  }
});&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;二-如何创建自己的vue插件&quot;&gt;二 如何创建自己的Vue插件&lt;/h3&gt;
&lt;p&gt;如果你在项目的很多地方都用了某个库，或者你希望全局可用，你可以构建自己的Vue插件。&lt;/p&gt;
&lt;p&gt;插件能化繁为简，能让你像下面这样很简单地引入自己想要的库：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import MyLibraryPlugin from 'my-library-plugin';
Vue.use(MyLibraryPlugin);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;就像&lt;code&gt;Vue Route，Vuex&lt;/code&gt;等插件一样，我们的库仅仅需要两行，就能在任何地方使用了。&lt;/p&gt;
&lt;h4 id=&quot;如何写插件&quot;&gt;如何写插件&lt;/h4&gt;
&lt;p&gt;首先，创建一个文件。本例中，我将引入一个Axios库的插件。我们就把这个文件命名为axios.js吧。&lt;br/&gt;最关键的地方在于，我们需要暴露一个将Vue构造器作为第一个参数的install方法。&lt;br/&gt;axios.js&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;export default {
  install: function(Vue) {
    // Do stuff
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们可以用之前的方式将库添加到Vue的原型对象上：&lt;br/&gt;axios.js&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import axios from 'axios';

export default {
  install: function(Vue) {
    Object.defineProperty(Vue.prototype, '$http', { value: axios });
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着我们只需要Vue实例的use方法就能将这个库引入整个项目了。我们像下面代码一样简单引入：&lt;br/&gt;entry.js&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import AxiosPlugin from './axios.js';
Vue.use(AxiosPlugin);

new Vue({
  created() {
    console.log(this.$http ? 'Axios works!' : 'Uh oh..');
  }
})&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;插件参数设置&quot;&gt;插件参数设置&lt;/h4&gt;
&lt;p&gt;插件的install方法还可以接受其他的可选参数。有些开发者可能不喜欢Axios实例对象的方法名&lt;code&gt;$http&lt;/code&gt;，因为&lt;code&gt;Vue resource&lt;/code&gt;插件的方法名也是这个。然后，让我们利用第二个参数来修改它。&lt;br/&gt;axios.js&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import axios from 'axios';

export default {
  install: function(Vue, name = '$http') {
    Object.defineProperty(Vue.prototype, name, { value: axios });
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;entry.js&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import AxiosPlugin from './axios.js';
Vue.use(AxiosPlugin, '$axios');

new Vue({
  created() {
    console.log(this.$axios ? 'Axios works!' : 'Uh oh..');
  }
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然上面，我们可以直接在Object.defineProperty的中将name属性写死成$axios。也可以在install方法中引入多个需要的库。&lt;/p&gt;
</description>
<pubDate>Fri, 14 Dec 2018 15:04:00 +0000</pubDate>
<dc:creator>双眸</dc:creator>
<og:description>一 第三方JavaScript库 前言 .vue文件 中不解析 script标签引入js文件，只能用 import 引入 有两种用法: 1.import a from '../a' 2.import</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/both-eyes/p/10122164.html</dc:identifier>
</item>
<item>
<title>伸展树的基本操作与应用 - SongHL</title>
<link>http://www.cnblogs.com/songorz/p/10122047.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/songorz/p/10122047.html</guid>
<description>
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1417592/201812/1417592-20181214223416472-1551747647.png&quot; alt=&quot;&quot; width=&quot;921&quot; height=&quot;736&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1417592/201812/1417592-20181214223505939-1902305289.png&quot; alt=&quot;&quot; width=&quot;916&quot; height=&quot;702&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1417592/201812/1417592-20181214223558776-1618044741.png&quot; alt=&quot;&quot; width=&quot;909&quot; height=&quot;623&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1417592/201812/1417592-20181214223629658-1791733433.png&quot; alt=&quot;&quot; width=&quot;860&quot; height=&quot;736&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1417592/201812/1417592-20181214223703897-1721426324.png&quot; alt=&quot;&quot; width=&quot;898&quot; height=&quot;666&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1417592/201812/1417592-20181214223749033-2093997933.png&quot; alt=&quot;&quot; width=&quot;869&quot; height=&quot;716&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1417592/201812/1417592-20181214223917429-743338115.png&quot; alt=&quot;&quot; width=&quot;882&quot; height=&quot;748&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1417592/201812/1417592-20181214224004150-1955202638.png&quot; alt=&quot;&quot; width=&quot;784&quot; height=&quot;582&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1417592/201812/1417592-20181214224032954-1315395805.png&quot; alt=&quot;&quot; width=&quot;818&quot; height=&quot;730&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1417592/201812/1417592-20181214224107617-1029141099.png&quot; alt=&quot;&quot; width=&quot;852&quot; height=&quot;744&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1417592/201812/1417592-20181214224135086-106786949.png&quot; alt=&quot;&quot; width=&quot;817&quot; height=&quot;694&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1417592/201812/1417592-20181214224201887-1534662190.png&quot; alt=&quot;&quot; width=&quot;861&quot; height=&quot;677&quot;/&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;【总结】&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;由上面的分析介绍，我们可以发现伸展树有以下几个优点： &lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;(1)时间复杂度低，伸展树的各种基本操作的平摊复杂度都是 O(log n)的。在&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;树状数据结构中，无疑是非常优秀的。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;(2)空间要求不高。与红黑树需要记录每个节点的颜色、AVL 树需要记录平&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;衡因子不同，伸展树不需要记录任何信息以保持树的平衡。 &lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;(3)算法简单，编程容易。伸展树的基本操作都是以 Splay 操作为基础的，而&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;Splay 操作中只需根据当前节点的位置进行旋转操作即可。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;上题参考代码：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('99fd9b05-ccc7-4883-811a-4f0540aed149')&quot; readability=&quot;51.5&quot;&gt;&lt;img id=&quot;code_img_closed_99fd9b05-ccc7-4883-811a-4f0540aed149&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_99fd9b05-ccc7-4883-811a-4f0540aed149&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('99fd9b05-ccc7-4883-811a-4f0540aed149',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_99fd9b05-ccc7-4883-811a-4f0540aed149&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;98&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*************************************************************
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    Problem: 1588
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    User: SongHL
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    Language: C++
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    Result: Accepted
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    Time:1284 ms
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    Memory:2068 kb
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;***************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;  
&lt;span&gt;10&lt;/span&gt; #include&amp;lt;bits/stdc++.h&amp;gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; INF=&lt;span&gt;0x3f3f3f3f&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; ans,n,t1,t2,rt,size;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; tr[&lt;span&gt;50001&lt;/span&gt;][&lt;span&gt;2&lt;/span&gt;],fa[&lt;span&gt;50001&lt;/span&gt;],num[&lt;span&gt;50001&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; rotate(&lt;span&gt;int&lt;/span&gt; x,&lt;span&gt;int&lt;/span&gt; &amp;amp;&lt;span&gt;k)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; y=fa[x],z=&lt;span&gt;fa[y],l,r;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(tr[y][&lt;span&gt;0&lt;/span&gt;]==x)l=&lt;span&gt;0&lt;/span&gt;;&lt;span&gt;else&lt;/span&gt; l=&lt;span&gt;1&lt;/span&gt;;r=l^&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(y==k)k=&lt;span&gt;x;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;{&lt;span&gt;if&lt;/span&gt;(tr[z][&lt;span&gt;0&lt;/span&gt;]==y)tr[z][&lt;span&gt;0&lt;/span&gt;]=x;&lt;span&gt;else&lt;/span&gt; tr[z][&lt;span&gt;1&lt;/span&gt;]=&lt;span&gt;x;}
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     fa[x]=z;fa[y]=x;fa[tr[x][r]]=&lt;span&gt;y;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     tr[y][l]=tr[x][r];tr[x][r]=&lt;span&gt;y;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt; }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; splay(&lt;span&gt;int&lt;/span&gt; x,&lt;span&gt;int&lt;/span&gt; &amp;amp;&lt;span&gt;k)
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; y,z;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(x!=&lt;span&gt;k)
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         y=fa[x],z=&lt;span&gt;fa[y];
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(y!=&lt;span&gt;k)
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;((tr[y][&lt;span&gt;0&lt;/span&gt;]==x)^(tr[z][&lt;span&gt;0&lt;/span&gt;]==&lt;span&gt;y))rotate(x,k);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;&lt;span&gt; rotate(y,k);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;        rotate(x,k);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ins(&lt;span&gt;int&lt;/span&gt; &amp;amp;k,&lt;span&gt;int&lt;/span&gt; x,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; last)
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;      &lt;span&gt;if&lt;/span&gt;(k==&lt;span&gt;0&lt;/span&gt;){size++;k=size;num[k]=x;fa[k]=last;splay(k,rt);&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;}
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;      &lt;span&gt;if&lt;/span&gt;(x&amp;lt;num[k])ins(tr[k][&lt;span&gt;0&lt;/span&gt;&lt;span&gt;],x,k);
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;      &lt;span&gt;else&lt;/span&gt; ins(tr[k][&lt;span&gt;1&lt;/span&gt;&lt;span&gt;],x,k);
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt; }
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ask_before(&lt;span&gt;int&lt;/span&gt; k,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; x)
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;      &lt;span&gt;if&lt;/span&gt;(k==&lt;span&gt;0&lt;/span&gt;)&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;      &lt;span&gt;if&lt;/span&gt;(num[k]&amp;lt;=x){t1=num[k];ask_before(tr[k][&lt;span&gt;1&lt;/span&gt;&lt;span&gt;],x);}
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;      &lt;span&gt;else&lt;/span&gt; ask_before(tr[k][&lt;span&gt;0&lt;/span&gt;&lt;span&gt;],x);
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt; }
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ask_after(&lt;span&gt;int&lt;/span&gt; k,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; x)
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;    &lt;span&gt;if&lt;/span&gt;(k==&lt;span&gt;0&lt;/span&gt;)&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;    &lt;span&gt;if&lt;/span&gt;(num[k]&amp;gt;=x){t2=num[k];ask_after(tr[k][&lt;span&gt;0&lt;/span&gt;&lt;span&gt;],x);}
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;    &lt;span&gt;else&lt;/span&gt; ask_after(tr[k][&lt;span&gt;1&lt;/span&gt;&lt;span&gt;],x);
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;     scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;&lt;span&gt;n);
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=n;i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; x;&lt;span&gt;if&lt;/span&gt;(scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;x)==EOF) x=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;         t1=-INF;t2=&lt;span&gt;INF;
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; &lt;span&gt;        ask_before(rt,x);
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; &lt;span&gt;        ask_after(rt,x);
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(i!=&lt;span&gt;1&lt;/span&gt;)ans+=min(x-t1,t2-&lt;span&gt;x);
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt; ans+=&lt;span&gt;x;
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt;         ins(rt,x,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,ans);
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;h2&gt; [NOI2005]维修数列（Splay的其他操作）&lt;/h2&gt;
&lt;p&gt;https://www.lydsy.com/JudgeOnline/problem.php?id=1500&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1417592/201812/1417592-20181214224323376-1159839245.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;算法过程：&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;初始化&lt;/h3&gt;
&lt;p&gt;首先，对于原序列，我们不应该一个一个读入，然后插入，那么效率就是O(nlogn),而splay的常数本身就很大，所以考虑一个优化，就是把原序列一次性读入后，直接类似线段树的build，搞一个整体建树，即不断的将当前点维护的区间进行二分，到达单元素区间后，就把对应的序列值插入进去，这样，我们一开始建的树就是一个非常平衡的树，可以使后续操作的常数更小，并且建树整个复杂度只是O(2n)的。&lt;/p&gt;
&lt;h3&gt;Insert操作&lt;/h3&gt;
&lt;p&gt;其次，我们来考虑一下如何维护一个insert操作。我们可以这么做，首先如上将需要insert的区间变成节点数目为tot的平衡树,然后把k+1（注意我们将需要操作的区间右移了一个单位，所以题目所给k就是我们需要操作的k+1）移到根节点的位置，把原树中的k+2移到根节点的右儿子的位置。然后把需要insert的区间，先build成一个平衡树，把需要insert的树的根直接挂到原树中k+1的左儿子上就行了。&lt;/p&gt;
&lt;h3&gt;Delete操作&lt;/h3&gt;
&lt;p&gt;再然后，我们来考虑一下delete操作，我们同样的，把需要delete的区间变成[k+1,k+tot]（注意，是删去k后面的tot个数，那么可以发现我们需要操作的原区间是[k,k+tot-1]!），然后把k号节点移到根节点的位置，把k+tot+2移到根节点的右儿子位置，然后直接把k+tot+2的左儿子的指针清为0，就把这段区间删掉了。可以发现，比insert还简单一点。&lt;/p&gt;
&lt;h3&gt;Reverse操作&lt;/h3&gt;
&lt;p&gt;接下来，这道题的重头戏就要开始了。splay的区间操作基本原理还类似于线段树的区间操作，即延迟修改，又称打懒标记。&lt;/p&gt;
&lt;p&gt;对于翻转（reverse）操作，我们依旧是将操作区间变成[k+1,k+tot]，然后把k和k+tot+1分别移到对应根的右儿子的位置，然后对这个右儿子的左儿子打上翻转标记即可。&lt;/p&gt;
&lt;h3&gt;Make-Same操作&lt;/h3&gt;
&lt;p&gt;对于Make-Same操作，我们同样需要先将需要操作的区间变成[k+1,k+tot]，然后把k和k+tot+1分别移到根和右儿子的位置，然后对这个右儿子的左儿子打上修改标记即可。&lt;/p&gt;
&lt;h3&gt;Get-Sum操作&lt;/h3&gt;
&lt;p&gt;对于Get-Sum操作，我们还是将操作区间变成[k+1,k+tot],然后把k和k+tot+1分别移到根和右儿子的位置，然后直接输出这个右儿子的左儿子上的sum记录的和。&lt;/p&gt;
&lt;h3&gt;Max-Sum操作&lt;/h3&gt;
&lt;p&gt;对于这个求最大子序列的操作，即Max-Sum操作，我们不能局限于最开始学最大子序列的线性dp方法，而是要注意刚开始，基本很多书都会介绍一个分治的O(nlogn)的方法，但是由于存在O(n)的方法，导致这个方法并不受重视，但是这个方法确实很巧妙，当数列存在修改操作时，线性的算法就不再适用了。&lt;/p&gt;
&lt;p&gt;这种带修改的最大子序列的问题，最开始是由线段树来维护，具体来说就是，对于线段树上的每个节点所代表的区间，维护3个量：lx表示从区间左端点l开始的连续的前缀最大子序列。rx表示从区间右端点r开始的连续的后缀最大子序列。mx表示这个区间中的最大子序列。&lt;/p&gt;
&lt;p&gt;那么在合并[l,mid]和[mid+1,r]时，就类似一个dp的过程了！其中&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;lx[l,r]=max(lx[l,mid],sum[l,mid]+lx[mid+1,r])&lt;span class=&quot;katex-html&quot;&gt;&lt;span class=&quot;strut&quot;&gt;&lt;span class=&quot;strut bottom&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;mord mathit&quot;&gt;l&lt;span class=&quot;mord mathit&quot;&gt;x&lt;span class=&quot;mopen&quot;&gt;[&lt;span class=&quot;mord mathit&quot;&gt;l&lt;span class=&quot;mpunct&quot;&gt;,&lt;span class=&quot;mord mathit&quot;&gt;r&lt;span class=&quot;mclose&quot;&gt;]&lt;span class=&quot;mrel&quot;&gt;=&lt;span class=&quot;mord mathit&quot;&gt;m&lt;span class=&quot;mord mathit&quot;&gt;a&lt;span class=&quot;mord mathit&quot;&gt;x&lt;span class=&quot;mopen&quot;&gt;(&lt;span class=&quot;mord mathit&quot;&gt;l&lt;span class=&quot;mord mathit&quot;&gt;x&lt;span class=&quot;mopen&quot;&gt;[&lt;span class=&quot;mord mathit&quot;&gt;l&lt;span class=&quot;mpunct&quot;&gt;,&lt;span class=&quot;mord mathit&quot;&gt;m&lt;span class=&quot;mord mathit&quot;&gt;i&lt;span class=&quot;mord mathit&quot;&gt;d&lt;span class=&quot;mclose&quot;&gt;]&lt;span class=&quot;mpunct&quot;&gt;,&lt;span class=&quot;mord mathit&quot;&gt;s&lt;span class=&quot;mord mathit&quot;&gt;u&lt;span class=&quot;mord mathit&quot;&gt;m&lt;span class=&quot;mopen&quot;&gt;[&lt;span class=&quot;mord mathit&quot;&gt;l&lt;span class=&quot;mpunct&quot;&gt;,&lt;span class=&quot;mord mathit&quot;&gt;m&lt;span class=&quot;mord mathit&quot;&gt;i&lt;span class=&quot;mord mathit&quot;&gt;d&lt;span class=&quot;mclose&quot;&gt;]&lt;span class=&quot;mbin&quot;&gt;+&lt;span class=&quot;mord mathit&quot;&gt;l&lt;span class=&quot;mord mathit&quot;&gt;x&lt;span class=&quot;mopen&quot;&gt;[&lt;span class=&quot;mord mathit&quot;&gt;m&lt;span class=&quot;mord mathit&quot;&gt;i&lt;span class=&quot;mord mathit&quot;&gt;d&lt;span class=&quot;mbin&quot;&gt;+&lt;span class=&quot;mord&quot;&gt;1&lt;span class=&quot;mpunct&quot;&gt;,&lt;span class=&quot;mord mathit&quot;&gt;r&lt;span class=&quot;mclose&quot;&gt;]&lt;span class=&quot;mclose&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;rx[l,r]=max(rx[mid+1,r],sum[mid+1,r]+rx[l,mid])&lt;span class=&quot;katex-html&quot;&gt;&lt;span class=&quot;strut&quot;&gt;&lt;span class=&quot;strut bottom&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;mord mathit&quot;&gt;r&lt;span class=&quot;mord mathit&quot;&gt;x&lt;span class=&quot;mopen&quot;&gt;[&lt;span class=&quot;mord mathit&quot;&gt;l&lt;span class=&quot;mpunct&quot;&gt;,&lt;span class=&quot;mord mathit&quot;&gt;r&lt;span class=&quot;mclose&quot;&gt;]&lt;span class=&quot;mrel&quot;&gt;=&lt;span class=&quot;mord mathit&quot;&gt;m&lt;span class=&quot;mord mathit&quot;&gt;a&lt;span class=&quot;mord mathit&quot;&gt;x&lt;span class=&quot;mopen&quot;&gt;(&lt;span class=&quot;mord mathit&quot;&gt;r&lt;span class=&quot;mord mathit&quot;&gt;x&lt;span class=&quot;mopen&quot;&gt;[&lt;span class=&quot;mord mathit&quot;&gt;m&lt;span class=&quot;mord mathit&quot;&gt;i&lt;span class=&quot;mord mathit&quot;&gt;d&lt;span class=&quot;mbin&quot;&gt;+&lt;span class=&quot;mord&quot;&gt;1&lt;span class=&quot;mpunct&quot;&gt;,&lt;span class=&quot;mord mathit&quot;&gt;r&lt;span class=&quot;mclose&quot;&gt;]&lt;span class=&quot;mpunct&quot;&gt;,&lt;span class=&quot;mord mathit&quot;&gt;s&lt;span class=&quot;mord mathit&quot;&gt;u&lt;span class=&quot;mord mathit&quot;&gt;m&lt;span class=&quot;mopen&quot;&gt;[&lt;span class=&quot;mord mathit&quot;&gt;m&lt;span class=&quot;mord mathit&quot;&gt;i&lt;span class=&quot;mord mathit&quot;&gt;d&lt;span class=&quot;mbin&quot;&gt;+&lt;span class=&quot;mord&quot;&gt;1&lt;span class=&quot;mpunct&quot;&gt;,&lt;span class=&quot;mord mathit&quot;&gt;r&lt;span class=&quot;mclose&quot;&gt;]&lt;span class=&quot;mbin&quot;&gt;+&lt;span class=&quot;mord mathit&quot;&gt;r&lt;span class=&quot;mord mathit&quot;&gt;x&lt;span class=&quot;mopen&quot;&gt;[&lt;span class=&quot;mord mathit&quot;&gt;l&lt;span class=&quot;mpunct&quot;&gt;,&lt;span class=&quot;mord mathit&quot;&gt;m&lt;span class=&quot;mord mathit&quot;&gt;i&lt;span class=&quot;mord mathit&quot;&gt;d&lt;span class=&quot;mclose&quot;&gt;]&lt;span class=&quot;mclose&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;mx[l,r]=max(mx[l,mid],mx[mid+1,r],lx[mid+1,r]+rx[l,mid+1])&lt;span class=&quot;katex-html&quot;&gt;&lt;span class=&quot;strut&quot;&gt;&lt;span class=&quot;strut bottom&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;mord mathit&quot;&gt;m&lt;span class=&quot;mord mathit&quot;&gt;x&lt;span class=&quot;mopen&quot;&gt;[&lt;span class=&quot;mord mathit&quot;&gt;l&lt;span class=&quot;mpunct&quot;&gt;,&lt;span class=&quot;mord mathit&quot;&gt;r&lt;span class=&quot;mclose&quot;&gt;]&lt;span class=&quot;mrel&quot;&gt;=&lt;span class=&quot;mord mathit&quot;&gt;m&lt;span class=&quot;mord mathit&quot;&gt;a&lt;span class=&quot;mord mathit&quot;&gt;x&lt;span class=&quot;mopen&quot;&gt;(&lt;span class=&quot;mord mathit&quot;&gt;m&lt;span class=&quot;mord mathit&quot;&gt;x&lt;span class=&quot;mopen&quot;&gt;[&lt;span class=&quot;mord mathit&quot;&gt;l&lt;span class=&quot;mpunct&quot;&gt;,&lt;span class=&quot;mord mathit&quot;&gt;m&lt;span class=&quot;mord mathit&quot;&gt;i&lt;span class=&quot;mord mathit&quot;&gt;d&lt;span class=&quot;mclose&quot;&gt;]&lt;span class=&quot;mpunct&quot;&gt;,&lt;span class=&quot;mord mathit&quot;&gt;m&lt;span class=&quot;mord mathit&quot;&gt;x&lt;span class=&quot;mopen&quot;&gt;[&lt;span class=&quot;mord mathit&quot;&gt;m&lt;span class=&quot;mord mathit&quot;&gt;i&lt;span class=&quot;mord mathit&quot;&gt;d&lt;span class=&quot;mbin&quot;&gt;+&lt;span class=&quot;mord&quot;&gt;1&lt;span class=&quot;mpunct&quot;&gt;,&lt;span class=&quot;mord mathit&quot;&gt;r&lt;span class=&quot;mclose&quot;&gt;]&lt;span class=&quot;mpunct&quot;&gt;,&lt;span class=&quot;mord mathit&quot;&gt;l&lt;span class=&quot;mord mathit&quot;&gt;x&lt;span class=&quot;mopen&quot;&gt;[&lt;span class=&quot;mord mathit&quot;&gt;m&lt;span class=&quot;mord mathit&quot;&gt;i&lt;span class=&quot;mord mathit&quot;&gt;d&lt;span class=&quot;mbin&quot;&gt;+&lt;span class=&quot;mord&quot;&gt;1&lt;span class=&quot;mpunct&quot;&gt;,&lt;span class=&quot;mord mathit&quot;&gt;r&lt;span class=&quot;mclose&quot;&gt;]&lt;span class=&quot;mbin&quot;&gt;+&lt;span class=&quot;mord mathit&quot;&gt;r&lt;span class=&quot;mord mathit&quot;&gt;x&lt;span class=&quot;mopen&quot;&gt;[&lt;span class=&quot;mord mathit&quot;&gt;l&lt;span class=&quot;mpunct&quot;&gt;,&lt;span class=&quot;mord mathit&quot;&gt;m&lt;span class=&quot;mord mathit&quot;&gt;i&lt;span class=&quot;mord mathit&quot;&gt;d&lt;span class=&quot;mbin&quot;&gt;+&lt;span class=&quot;mord&quot;&gt;1&lt;span class=&quot;mclose&quot;&gt;]&lt;span class=&quot;mclose&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这个还是很好理解的。就是选不选mid的两个决策。但是其实在实现的时候，我们并不用[l,r]的二维方式来记录这三个标记，而是用对应的节点编号来表示区间，这个可以看程序，其实是个很简单的东西。&lt;/p&gt;
&lt;p&gt;那么最大子序列这个询问操作就可以很简单的解决了，还是类比前面的方法，就是把k和k+tot+1移到对应的根和右儿子的位置，然后直接输出右儿子的左儿子上的mx标记即可&lt;/p&gt;
&lt;h3&gt;懒标记的处理&lt;/h3&gt;
&lt;p&gt;最后，相信认真看了的童鞋会有疑问，这个标记怎么下传呢？首先，我们在每次将k和k+tot+1移到对应的位置时，需要一个类似查找k大值的find操作，即找出在平衡树中，实际编号为k在树中中序遍历的编号，这个才是我们真正需要处理的区间端点编号，那么就好了，我们只需在查找的过程中下传标记就好了！（其实线段树中也是这么做的），因为我们所有的操作都需要先find一下，所以我们可以保证才每次操作的结果计算出来时，对应的节点的标记都已经传好了。而我们在修改时，直接修改对应节点的记录标记和懒标记，因为我们的懒标记记录的都是已经对当前节点产生贡献，但是还没有当前节点的子树区间产生贡献！然后就是每处有修改的地方都要pushup一下就好了。&lt;/p&gt;
&lt;h3&gt;一些细节&lt;/h3&gt;
&lt;p&gt;另外，由于本题数据空间卡的非常紧，我们就需要用时间换空间，直接开4000000*logm的数据是不现实的，但是由于题目保证了同一时间在序列中的数字的个数最多是500000，所以我们考虑一个回收机制，把用过但是已经删掉的节点编号记录到一个队列或栈中，在新建节点时直接把队列中的冗余编号搞过来就好了。&lt;/p&gt;
&lt;p&gt;参考代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('359e3e14-1338-46eb-baf0-f6c4f2f3cbf3')&quot; readability=&quot;86.5&quot;&gt;&lt;img id=&quot;code_img_closed_359e3e14-1338-46eb-baf0-f6c4f2f3cbf3&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_359e3e14-1338-46eb-baf0-f6c4f2f3cbf3&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('359e3e14-1338-46eb-baf0-f6c4f2f3cbf3',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_359e3e14-1338-46eb-baf0-f6c4f2f3cbf3&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;168&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; #include&amp;lt;bits/stdc++.h&amp;gt;
&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; RI register int
&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; For(i,a,b) for (RI i=a;i&amp;lt;=b;++i)
&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; inf=&lt;span&gt;0x3f3f3f3f&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; N=1e6+&lt;span&gt;17&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n,m,rt,cnt;
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; a[N],id[N],fa[N],c[N][&lt;span&gt;2&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; sum[N],sz[N],v[N],mx[N],lx[N],rx[N];
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; tag[N],rev[N];
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;tag表示是否有统一修改的标记，rev表示是否有统一翻转的标记
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;sum表示这个点的子树中的权值和，v表示这个点的权值&lt;/span&gt;
&lt;span&gt; 13&lt;/span&gt; queue&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt; q;
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt; inline &lt;span&gt;int&lt;/span&gt;&lt;span&gt; read()
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt;     RI x=&lt;span&gt;0&lt;/span&gt;,f=&lt;span&gt;1&lt;/span&gt;;&lt;span&gt;char&lt;/span&gt; ch=&lt;span&gt;getchar();
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(ch&amp;lt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;||ch&amp;gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;){&lt;span&gt;if&lt;/span&gt;(ch==&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) f=-&lt;span&gt;1&lt;/span&gt;; ch=&lt;span&gt;getchar();}
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;lt;=ch&amp;amp;&amp;amp;ch&amp;lt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;){x=(x&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;)+(x&amp;lt;&amp;lt;&lt;span&gt;3&lt;/span&gt;)+ch-&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;;ch=&lt;span&gt;getchar();}
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; x*&lt;span&gt;f;
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt; inline &lt;span&gt;void&lt;/span&gt;&lt;span&gt; pushup(RI x)
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt;     RI l=c[x][&lt;span&gt;0&lt;/span&gt;],r=c[x][&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt;     sum[x]=sum[l]+sum[r]+&lt;span&gt;v[x];
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt;     sz[x]=sz[l]+sz[r]+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt;     mx[x]=max(mx[l],max(mx[r],rx[l]+v[x]+&lt;span&gt;lx[r]));
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt;     lx[x]=max(lx[l],sum[l]+v[x]+&lt;span&gt;lx[r]);
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt;     rx[x]=max(rx[r],sum[r]+v[x]+&lt;span&gt;rx[l]);
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;上传记录标记&lt;/span&gt;
&lt;span&gt; 31&lt;/span&gt; inline &lt;span&gt;void&lt;/span&gt;&lt;span&gt; pushdown(RI x)
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt;     RI l=c[x][&lt;span&gt;0&lt;/span&gt;],r=c[x][&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(tag[x])
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt;         rev[x]=tag[x]=&lt;span&gt;0&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;我们有了一个统一修改的标记，再翻转就没有什么意义了&lt;/span&gt;
&lt;span&gt; 37&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(l) tag[l]=&lt;span&gt;1&lt;/span&gt;,v[l]=v[x],sum[l]=v[x]*&lt;span&gt;sz[l];
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(r) tag[r]=&lt;span&gt;1&lt;/span&gt;,v[r]=v[x],sum[r]=v[x]*&lt;span&gt;sz[r];
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(v[x]&amp;gt;=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;) 
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(l) lx[l]=rx[l]=mx[l]=&lt;span&gt;sum[l];
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(r) lx[r]=rx[r]=mx[r]=&lt;span&gt;sum[r];
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;
&lt;span&gt; 45&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(l) lx[l]=rx[l]=&lt;span&gt;0&lt;/span&gt;,mx[l]=&lt;span&gt;v[x];
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(r) lx[r]=rx[r]=&lt;span&gt;0&lt;/span&gt;,mx[r]=&lt;span&gt;v[x];
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(rev[x])
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt;         rev[x]=&lt;span&gt;0&lt;/span&gt;;rev[l]^=&lt;span&gt;1&lt;/span&gt;;rev[r]^=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt; &lt;span&gt;        swap(lx[l],rx[l]);swap(lx[r],rx[r]);
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;注意，在翻转操作中，前后缀的最长上升子序列都反过来了，很容易错&lt;/span&gt;
&lt;span&gt; 55&lt;/span&gt;         swap(c[l][&lt;span&gt;0&lt;/span&gt;],c[l][&lt;span&gt;1&lt;/span&gt;]);swap(c[r][&lt;span&gt;0&lt;/span&gt;],c[r][&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt; inline &lt;span&gt;void&lt;/span&gt; rotate(RI x,RI &amp;amp;&lt;span&gt;k)
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt;     RI y=fa[x],z=fa[y],l=(c[y][&lt;span&gt;1&lt;/span&gt;]==x),r=l^&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (y==k)k=x;&lt;span&gt;else&lt;/span&gt; c[z][c[z][&lt;span&gt;1&lt;/span&gt;]==y]=&lt;span&gt;x;
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt;     fa[c[x][r]]=y;fa[y]=x;fa[x]=&lt;span&gt;z;
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt;     c[y][l]=c[x][r];c[x][r]=&lt;span&gt;y;
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt; &lt;span&gt;    pushup(y);pushup(x);
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;旋转操作,一定要上传标记且顺序不能变 &lt;/span&gt;
&lt;span&gt; 66&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt; inline &lt;span&gt;void&lt;/span&gt; splay(RI x,RI &amp;amp;&lt;span&gt;k)
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(x!=&lt;span&gt;k)
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; y=fa[x],z=&lt;span&gt;fa[y];
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(y!=&lt;span&gt;k)
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;((c[z][&lt;span&gt;0&lt;/span&gt;]==y)^(c[y][&lt;span&gt;0&lt;/span&gt;]==&lt;span&gt;x)) rotate(x,k);
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;&lt;span&gt; rotate(y,k);
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt; &lt;span&gt;        rotate(x,k);
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这是整个程序的核心之一，毕竟是伸展操作嘛&lt;/span&gt;
&lt;span&gt; 81&lt;/span&gt; inline &lt;span&gt;int&lt;/span&gt;&lt;span&gt; find(RI x,RI rk)
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt; {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回当前序列第rk个数的标号 &lt;/span&gt;
&lt;span&gt; 83&lt;/span&gt; &lt;span&gt;    pushdown(x);
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt;     RI l=c[x][&lt;span&gt;0&lt;/span&gt;],r=c[x][&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(sz[l]+&lt;span&gt;1&lt;/span&gt;==rk) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; x;
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(sz[l]&amp;gt;=rk) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; find(l,rk);
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt; &lt;span&gt;return&lt;/span&gt; find(r,rk-sz[l]-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt; inline &lt;span&gt;void&lt;/span&gt;&lt;span&gt; recycle(RI x)
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt; {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这就是用时间换空间的回收冗余编号机制，很好理解&lt;/span&gt;
&lt;span&gt; 91&lt;/span&gt;     RI &amp;amp;l=c[x][&lt;span&gt;0&lt;/span&gt;],&amp;amp;r=c[x][&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(l) recycle(l);
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(r) recycle(r);
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt; &lt;span&gt;    q.push(x);
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt;     fa[x]=l=r=tag[x]=rev[x]=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt; inline &lt;span&gt;int&lt;/span&gt; split(RI k,RI tot)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;找到[k+1,k+tot]&lt;/span&gt;
&lt;span&gt; 98&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;     RI x=find(rt,k),y=find(rt,k+tot+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;     splay(x,rt);splay(y,c[x][&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; c[y][&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个split操作是整个程序的核心之三
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;我们通过这个split操作，找到[k+1,k+tot]，并把k,和k+tot+1移到根和右儿子的位置
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;然后我们返回了这个右儿子的左儿子，这就是我们需要操作的区间&lt;/span&gt;
&lt;span&gt;106&lt;/span&gt; inline &lt;span&gt;void&lt;/span&gt;&lt;span&gt; query(RI k,RI tot)
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt;     RI x=&lt;span&gt;split(k,tot);
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,sum[x]);
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt; inline &lt;span&gt;void&lt;/span&gt; modify(RI k,RI tot,RI val)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;MAKE-SAME&lt;/span&gt;
&lt;span&gt;112&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt;     RI x=split(k,tot),y=&lt;span&gt;fa[x];
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt;     v[x]=val;tag[x]=&lt;span&gt;1&lt;/span&gt;;sum[x]=sz[x]*&lt;span&gt;val;
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(val&amp;gt;=&lt;span&gt;0&lt;/span&gt;) lx[x]=rx[x]=mx[x]=&lt;span&gt;sum[x];
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt; lx[x]=rx[x]=&lt;span&gt;0&lt;/span&gt;,mx[x]=&lt;span&gt;val;
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt; &lt;span&gt;    pushup(y);pushup(fa[y]);
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;每一步的修改操作，由于父子关系发生改变
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;及记录标记发生改变，我们需要及时上传记录标记&lt;/span&gt;
&lt;span&gt;120&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt; inline &lt;span&gt;void&lt;/span&gt; rever(RI k,RI tot)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;翻转 &lt;/span&gt;
&lt;span&gt;122&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;     RI x=split(k,tot),y=&lt;span&gt;fa[x];
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;tag[x])
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;126&lt;/span&gt;         rev[x]^=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;127&lt;/span&gt;         swap(c[x][&lt;span&gt;0&lt;/span&gt;],c[x][&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt;128&lt;/span&gt; &lt;span&gt;        swap(lx[x],rx[x]);
&lt;/span&gt;&lt;span&gt;129&lt;/span&gt; &lt;span&gt;        pushup(y);pushup(fa[y]);
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;131&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;同上&lt;/span&gt;
&lt;span&gt;132&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt; inline &lt;span&gt;void&lt;/span&gt; erase(RI k,RI tot)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;DELETE&lt;/span&gt;
&lt;span&gt;134&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;135&lt;/span&gt;     RI x=split(k,tot),y=&lt;span&gt;fa[x];
&lt;/span&gt;&lt;span&gt;136&lt;/span&gt;     recycle(x);c[y][&lt;span&gt;0&lt;/span&gt;]=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;137&lt;/span&gt; &lt;span&gt;    pushup(y);pushup(fa[y]);
&lt;/span&gt;&lt;span&gt;138&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;同上&lt;/span&gt;
&lt;span&gt;139&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;140&lt;/span&gt; inline &lt;span&gt;void&lt;/span&gt;&lt;span&gt; build(RI l,RI r,RI f)
&lt;/span&gt;&lt;span&gt;141&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;142&lt;/span&gt;     RI mid=(l+r)&amp;gt;&amp;gt;&lt;span&gt;1&lt;/span&gt;,now=id[mid],pre=&lt;span&gt;id[f];
&lt;/span&gt;&lt;span&gt;143&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(l==&lt;span&gt;r)
&lt;/span&gt;&lt;span&gt;144&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;145&lt;/span&gt;         mx[now]=sum[now]=&lt;span&gt;a[l];
&lt;/span&gt;&lt;span&gt;146&lt;/span&gt;         tag[now]=rev[now]=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;147&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里这个tag和rev的清0是必要，因为这个编号可能是之前冗余了&lt;/span&gt;
&lt;span&gt;148&lt;/span&gt;         lx[now]=rx[now]=max(a[l],&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;149&lt;/span&gt;         sz[now]=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;150&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;151&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(l&amp;lt;mid) build(l,mid-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,mid);
&lt;/span&gt;&lt;span&gt;152&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(mid&amp;lt;r) build(mid+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,r,mid);
&lt;/span&gt;&lt;span&gt;153&lt;/span&gt;     v[now]=a[mid]; fa[now]=&lt;span&gt;pre;
&lt;/span&gt;&lt;span&gt;154&lt;/span&gt;     pushup(now); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;上传记录标记&lt;/span&gt;
&lt;span&gt;155&lt;/span&gt;     c[pre][mid&amp;gt;=f]=&lt;span&gt;now;
&lt;/span&gt;&lt;span&gt;156&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;当mid&amp;gt;=f时，now是插入到又区间取了，所以c[pre][1]=now，当mid&amp;lt;f时同理&lt;/span&gt;
&lt;span&gt;157&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;158&lt;/span&gt; inline &lt;span&gt;void&lt;/span&gt;&lt;span&gt; insert(RI k,RI tot)
&lt;/span&gt;&lt;span&gt;159&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;160&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=tot;++i) a[i]=&lt;span&gt;read();
&lt;/span&gt;&lt;span&gt;161&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=tot;++&lt;span&gt;i)
&lt;/span&gt;&lt;span&gt;162&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;163&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(!q.empty()) id[i]=&lt;span&gt;q.front(),q.pop();
&lt;/span&gt;&lt;span&gt;164&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt; id[i]=++cnt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;利用队列中记录的冗余节点编号&lt;/span&gt;
&lt;span&gt;165&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;166&lt;/span&gt;     build(&lt;span&gt;1&lt;/span&gt;,tot,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;167&lt;/span&gt;     RI z=id[(&lt;span&gt;1&lt;/span&gt;+tot)&amp;gt;&amp;gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;168&lt;/span&gt;     RI x=find(rt,k+&lt;span&gt;1&lt;/span&gt;),y=find(rt,k+&lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;169&lt;/span&gt;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;首先，依据中序遍历，找到我们需要操作的区间的实际编号&lt;/span&gt;
&lt;span&gt;170&lt;/span&gt;     splay(x,rt);splay(y,c[x][&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt;171&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;把k+1(注意我们已经右移了一个单位）和(k+1)+1移到根和右儿子&lt;/span&gt;
&lt;span&gt;172&lt;/span&gt;     fa[z]=y;c[y][&lt;span&gt;0&lt;/span&gt;]=&lt;span&gt;z;
&lt;/span&gt;&lt;span&gt;173&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;直接把需要插入的这个平衡树挂到右儿子的左儿子上去就好了&lt;/span&gt;
&lt;span&gt;174&lt;/span&gt; &lt;span&gt;    pushup(y);pushup(x);
&lt;/span&gt;&lt;span&gt;175&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;上传记录标记&lt;/span&gt;
&lt;span&gt;176&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;177&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;可以这么记，只要用了split就要重新上传标记
&lt;/span&gt;&lt;span&gt;178&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;只有find中需要下传标记&lt;/span&gt;
&lt;span&gt;179&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
&lt;/span&gt;&lt;span&gt;180&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;181&lt;/span&gt;     n=read(),m=&lt;span&gt;read();
&lt;/span&gt;&lt;span&gt;182&lt;/span&gt;     mx[&lt;span&gt;0&lt;/span&gt;]=a[&lt;span&gt;1&lt;/span&gt;]=a[n+&lt;span&gt;2&lt;/span&gt;]=-&lt;span&gt;inf;
&lt;/span&gt;&lt;span&gt;183&lt;/span&gt;     For(i,&lt;span&gt;1&lt;/span&gt;,n) a[i+&lt;span&gt;1&lt;/span&gt;]=&lt;span&gt;read();
&lt;/span&gt;&lt;span&gt;184&lt;/span&gt;     For(i,&lt;span&gt;1&lt;/span&gt;,n+&lt;span&gt;2&lt;/span&gt;) id[i]=i;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;虚拟了两个节点1和n+2，然后把需要操作区间整体右移一个单位&lt;/span&gt;
&lt;span&gt;185&lt;/span&gt;     build(&lt;span&gt;1&lt;/span&gt;,n+&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;建树&lt;/span&gt;
&lt;span&gt;186&lt;/span&gt;     rt=(n+&lt;span&gt;3&lt;/span&gt;)&amp;gt;&amp;gt;&lt;span&gt;1&lt;/span&gt;;cnt=n+&lt;span&gt;2&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取最中间的为根&lt;/span&gt;
&lt;span&gt;187&lt;/span&gt;     RI k,tot,val;&lt;span&gt;char&lt;/span&gt; ch[&lt;span&gt;10&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;188&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(m--&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;189&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;190&lt;/span&gt;         scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,ch);
&lt;/span&gt;&lt;span&gt;191&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(ch[&lt;span&gt;0&lt;/span&gt;]!=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;M&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; || ch[&lt;span&gt;2&lt;/span&gt;]!=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;X&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) k=read(),tot=&lt;span&gt;read();
&lt;/span&gt;&lt;span&gt;192&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(ch[&lt;span&gt;0&lt;/span&gt;]==&lt;span&gt;'&lt;/span&gt;&lt;span&gt;I&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) insert(k,tot);
&lt;/span&gt;&lt;span&gt;193&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(ch[&lt;span&gt;0&lt;/span&gt;]==&lt;span&gt;'&lt;/span&gt;&lt;span&gt;D&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) erase(k,tot);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;DELETE&lt;/span&gt;
&lt;span&gt;194&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(ch[&lt;span&gt;0&lt;/span&gt;]==&lt;span&gt;'&lt;/span&gt;&lt;span&gt;M&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;195&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;196&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(ch[&lt;span&gt;2&lt;/span&gt;]==&lt;span&gt;'&lt;/span&gt;&lt;span&gt;X&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,mx[rt]);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;MAX-SUM&lt;/span&gt;
&lt;span&gt;197&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; val=read(),modify(k,tot,val);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;MAKE-SAME&lt;/span&gt;
&lt;span&gt;198&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;199&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(ch[&lt;span&gt;0&lt;/span&gt;]==&lt;span&gt;'&lt;/span&gt;&lt;span&gt;R&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) rever(k,tot);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;翻转 &lt;/span&gt;
&lt;span&gt;200&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(ch[&lt;span&gt;0&lt;/span&gt;]==&lt;span&gt;'&lt;/span&gt;&lt;span&gt;G&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) query(k,tot);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;GET-SUM&lt;/span&gt;
&lt;span&gt;201&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;202&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;203&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;204&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

</description>
<pubDate>Fri, 14 Dec 2018 14:28:00 +0000</pubDate>
<dc:creator>SongHL</dc:creator>
<og:description>【总结】 由上面的分析介绍，我们可以发现伸展树有以下几个优点： (1)时间复杂度低，伸展树的各种基本操作的平摊复杂度都是 O(log n)的。在树状数据结构中，无疑是非常优秀的。 (2)空间要求不高。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/songorz/p/10122047.html</dc:identifier>
</item>
<item>
<title>.net core i上 K8S(六).netcore程序的service网络代理模式 - 老六代码</title>
<link>http://www.cnblogs.com/chenyishi/p/10121980.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenyishi/p/10121980.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/chenyishi/p/10116757.html&quot; target=&quot;_blank&quot;&gt;上一章&lt;/a&gt;我们讲了pod的hostip模式，但在生产环境中，我们都是通过service来访问k8s集群的，service有两种模式来暴漏端口，今天我们来分享一下&lt;/p&gt;
&lt;h2&gt;1.clusterIP模式&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;我们在创建service的时候，默认创建的时clusterIP模式，clusterIP模式的特点是只能在node节点上访问，创建方法如下：&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;1.1首先创建Deployment&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
apiVersion: apps/&lt;span&gt;v1beta2
kind: Deployment
metadata:
  name: cys&lt;/span&gt;-&lt;span&gt;netcore
spec:
  replicas: &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
  selector:
    matchLabels:
      app: cys&lt;/span&gt;-&lt;span&gt;netcore
  template:
    metadata:
      labels:
        app: cys&lt;/span&gt;-&lt;span&gt;netcore
    spec:
      containers:
      &lt;/span&gt;- name: cys-&lt;span&gt;netcore
        image: chenyishi&lt;/span&gt;/&lt;span&gt;webdocker_s_provider
        ports:
        &lt;/span&gt;- containerPort: &lt;span&gt;1000&lt;/span&gt;
        &lt;span&gt;env&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;-&lt;span&gt; name: serverport
          value: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1033233/201812/1033233-20181214215649176-530170195.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;1.2创建service，并指定clusterip（不指定也可以，会自动随机分配）&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;注意：clusterIP设置须按照集群搭建时指定的范围设置，我们查看一下我们制定的范围&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1033233/201812/1033233-20181214220622411-171736104.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以看到范围是10.10.10.1~10.10.10.255，编写yaml文件如下&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;apiVersion: v1
kind: Service
metadata:
  name: netcore&lt;/span&gt;-&lt;span&gt;service
  labels:
    app: netcore
spec:
  ports:
  &lt;/span&gt;-&lt;span&gt; name: http
    protocol: TCP
    port: &lt;/span&gt;&lt;span&gt;1001&lt;/span&gt;&lt;span&gt;
    targetPort: &lt;/span&gt;&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;
  clusterIP: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;10.10.10.10&lt;/span&gt;&lt;span&gt;&quot;    #指定ip&lt;/span&gt;&lt;span&gt;
  selector:
    app: cys&lt;/span&gt;-netcore
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1033233/201812/1033233-20181214220313575-1306274905.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可查看信息，如下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1033233/201812/1033233-20181214220420054-1941917153.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;1.3验证地址&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;我们可以去node节点验证一下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1033233/201812/1033233-20181214220451660-1124492516.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;至此clusterip介绍完毕&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;2.NodePort模式&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;我们可以看到clusterIP模式只能在node节点访问，这无法满足我们的生产环境，因此我们在生产环境中都是采用NodePort模式，映射到宿主机的port，我们的Deployment的yaml文件还是采用上面的，需要改一下service的yaml文件&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;apiVersion: v1
kind: Service
metadata:
  name: netcore&lt;/span&gt;-&lt;span&gt;service
  labels:
    app: netcore
spec:
  ports:
  &lt;/span&gt;-&lt;span&gt; name: http
    protocol: TCP
    port: &lt;/span&gt;&lt;span&gt;1001&lt;/span&gt;&lt;span&gt;
    targetPort: &lt;/span&gt;&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;
    nodePort: &lt;/span&gt;&lt;span&gt;31111　　　　#指定宿主机暴漏的端口&lt;/span&gt;&lt;span&gt;
  selector:
    app: cys&lt;/span&gt;-&lt;span&gt;netcore
  type: NodePort　　　　　　#指定类型&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;注意：nodePort的端口号也是从集群搭建时指定的范围中设置的，不可超出范围，如下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1033233/201812/1033233-20181214221221697-2084108276.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2.1创建service&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1033233/201812/1033233-20181214221303049-958279160.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;查看信息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1033233/201812/1033233-20181214221325748-1784812364.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2.2验证&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;访问地址http://192.168.8.202:31111/api/values&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1033233/201812/1033233-20181214221416893-858526350.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;成功访问！！！&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 14 Dec 2018 14:18:00 +0000</pubDate>
<dc:creator>老六代码</dc:creator>
<og:description>上一章我们讲了pod的hostip模式，但在生产环境中，我们都是通过service来访问k8s集群的，service有两种模式来暴漏端口，今天我们来分享一下 1.clusterIP模式 我们在创建se</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenyishi/p/10121980.html</dc:identifier>
</item>
<item>
<title>【API知识】类型转换工具ConvertUtils引发的思考 - 猫毛·波拿巴</title>
<link>http://www.cnblogs.com/longfurcat/p/10121971.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/longfurcat/p/10121971.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;　　在读取Excel文件数据，有时候不可避免地需要把获取到的字符串转型为基本类型的对象。以前都是自己写转换，难度也不大。后来听说，有可以直接用的轮子——Apache 的commons-beanutils这个包，有提供ConvertUtils。以下我的相关记录。&lt;/p&gt;
&lt;h2&gt;我要的异常呢？&lt;/h2&gt;
&lt;p&gt;　　听说有可以用的轮子，第一反应，肯定是拿来先跑几个测试案例。这东西使用起来也很简单，参数就是源字符串和目的类型。我就先测了一下，一个乱码String转Boolean，看看会不会抛出异常。结果出乎意外的是，它居然没有抛出异常，还返回了false。认真看了一下，才发现它直接把异常打印出来了，还返回了默认值。&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ConvertTest {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        Object result;
        result &lt;/span&gt;= ConvertUtils.convert(&quot;@7##jF*&amp;amp;%#$&quot;, Boolean.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        System.out.println(result);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1313132/201812/1313132-20181214211548573-1294222206.png&quot; alt=&quot;&quot; width=&quot;1081&quot; height=&quot;84&quot;/&gt;&lt;/p&gt;
&lt;p&gt;真是够呛，你不抛出异常，我留你何用。我就是要你抛出异常，然后我再在上层决定怎么和用户交互，你倒好，直接打印出来了，还给我个默认值，那怎么知道原来的值到底是错误的还是bool false。&lt;/p&gt;
&lt;p&gt;于是我想，这种工具都有一个尿性——可配置。我就想肯定有什么方法，比如xxxwithException()，或者throwException()这样的设定。结果翻了一下，还真没有。哇，上头。&lt;/p&gt;
&lt;h2&gt;内核——ConvertUtilsBean&lt;/h2&gt;
&lt;p&gt;　　刚好有时间，于是就看它到底怎么实现的。看了才知道，原来它是把工作委托给ConvertUtilsBean来做的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Object convert(&lt;span&gt;final&lt;/span&gt; String value, &lt;span&gt;final&lt;/span&gt; Class&amp;lt;?&amp;gt;&lt;span&gt; clazz) {
　　　　 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里获取一个ConvertUtilsBean的实例来执行convert方法&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ConvertUtilsBean.getInstance().convert(value, clazz);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　于是顺藤摸瓜，我就随便翻了翻ConvertUtilsBean。我的眼睛就盯着，看看有没有exception这个关键字，果然让我找到了！！！&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; register(&lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; throwException, &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; defaultNull, &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; defaultArraySize) {
        registerPrimitives(throwException);
        registerStandard(throwException, defaultNull);
        registerOther(throwException);
        registerArrays(throwException, defaultArraySize);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里可以配置是否要抛出异常。于是我就用这个bean，测了一下，果然可以。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ConvertBeanTest {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        ConvertUtilsBean convertUtilsBean &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConvertUtilsBean();
        convertUtilsBean.register(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, 0&lt;span&gt;);
        Object obj;
        obj &lt;/span&gt;= convertUtilsBean.convert(&quot;@7##jF*&amp;amp;%#$&quot;, Boolean.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        System.out.println(obj);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1313132/201812/1313132-20181214214719599-1918658393.png&quot; alt=&quot;&quot; width=&quot;1061&quot; height=&quot;117&quot;/&gt;&lt;/p&gt;
&lt;p&gt;很好，终于抛出异常了。那么，我用这个ConvertUtilsBean就可以了。&lt;/p&gt;
&lt;h2&gt;ConvertUtilsBean为何能够想转什么就转什么?&lt;/h2&gt;
&lt;p&gt;　　实际上，它也不是想转什么就转什么。初始条件下，它内部只注册了基本类型的转换器。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ConvertUtilsBean() {
        converters.setFast(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个方法是关键，它清除当前所有转换器，并重新初始化&lt;/span&gt;
&lt;span&gt;        deregister();
        converters.setFast(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; deregister() {

        converters.clear();
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;false参数表示，是否抛出异常。即默认不抛出异常。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里注册了基本类型的转换器&lt;/span&gt;
        registerPrimitives(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
        registerStandard(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
        registerOther(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        registerArrays(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;, 0&lt;span&gt;);
        register(BigDecimal.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BigDecimalConverter());
        register(BigInteger.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BigIntegerConverter());
    }
    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;注册是什么概念？&lt;/h3&gt;
&lt;p&gt;　　“注册”这个词，看上去挺玄乎的，其实一般就是写到一个注册表里面，然后需要的时候从表中检索。在这个实现中，注册表，不过就是一张HashMap。而注册操作，就是把Converter对象放到这个哈希表中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    /**&lt;/span&gt;&lt;span&gt;
     * The set of {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; Converter}s that can be used to convert Strings
     * into objects of a specified Class, keyed by the destination Class.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; WeakFastHashMap&amp;lt;Class&amp;lt;?&amp;gt;, Converter&amp;gt; converters =
            &lt;span&gt;new&lt;/span&gt; WeakFastHashMap&amp;lt;Class&amp;lt;?&amp;gt;, Converter&amp;gt;();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们可以看到，这个表的Key是类型。也就是说，我们在使用convert方法的时候，已经指定了key，自然就找到了对应的Converter。那我们还能想到什么呢，那就是“覆盖”。因为HashMap中，Key是唯一的，所以同种类型的Converter只能存在一个，即新注册的Converter会覆盖同类型的Converter。&lt;/p&gt;
&lt;p&gt;对了，忘记提了，这个包有一个Converter接口，如果要自定义的话，也可以自己实现相关的类，注册到这个Bean上，然后统一使用这个Bean。&lt;/p&gt;
&lt;h2&gt;service provider framework&lt;/h2&gt;
&lt;p&gt;　　之所以想到这个，是因为前几天刚刚开始看《Effective Java》这本书中，而里面说的service provider framwork的结构，和这个非常类似。&lt;/p&gt;
&lt;p&gt;三个要素：&lt;/p&gt;
&lt;p&gt;　　service接口   =&amp;gt;  Converter接口&lt;/p&gt;
&lt;p&gt;　　register API   =&amp;gt;  register方法&lt;/p&gt;
&lt;p&gt;　　access  API   =&amp;gt;  ConverterUtils工具类&lt;/p&gt;
&lt;p&gt;体现的思想就是：客户端和实现类解耦，参照上面的，客户端只要知道ConvertUtils或者ConvertUtilsBean这个类就好了，不需要去记该用哪个Converter。&lt;/p&gt;
</description>
<pubDate>Fri, 14 Dec 2018 14:16:00 +0000</pubDate>
<dc:creator>猫毛&amp;#183;波拿巴</dc:creator>
<og:description>前言 在读取Excel文件数据，有时候不可避免地需要把获取到的字符串转型为基本类型的对象。以前都是自己写转换，难度也不大。后来听说，有可以直接用的轮子——Apache 的commons-beanuti</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/longfurcat/p/10121971.html</dc:identifier>
</item>
<item>
<title>GoogLeNetv2 论文研读笔记 - 范中豪</title>
<link>http://www.cnblogs.com/zhhfan/p/10121965.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhhfan/p/10121965.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;http://arxiv.org/abs/1502.03167&quot;&gt;原文链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;摘要&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当前神经网络层之前的神经网络层的参数变化，引起神经网络每一层输入数据的分布产生了变化，这使得训练一个深度神经网络变得复杂。这样就要求使用更小的学习率，参数初始化也需要更为谨慎的设置。并且由于非线性饱和（注：如sigmoid激活函数的非线性饱和问题），训练一个深度神经网络会非常困难。我们称这个现象为：internal covariate shift。同时利用归一化层输入解决这个问题。我们将归一化层输入作为神经网络的结构，并且对每一个小批量训练数据执行这一操作。Batch Normalization（BN） 能使用更高的学习率，并且不需要过多地注重参数初始化问题。BN 的过程与正则化相似，在某些情况下可以去除Dropout&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;引言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;随即梯度下降法(SGD)通过最小化 &lt;span class=&quot;math inline&quot;&gt;\(\theta\)&lt;/span&gt; 来最小化损失函数&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503464/201812/1503464-20181214220942487-240543289.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中X&lt;sub&gt;1…N&lt;/sub&gt;为训练数据集。在使用SGD时，每次迭代我们使用一个大小为m 的小批量数据X&lt;sub&gt;1…m&lt;/sub&gt; 。通过计算&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503464/201812/1503464-20181214220948524-2145345956.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;来逼近损失函数关于权值的梯度。在迭代过程中使用小批量数据相比使用一个样本有几个好处。首先，由小批量数据计算而来的损失函数梯度是由整个训练数据集的损失函数梯度的估计。并且随着小批量数据大小的增加，其性能会越好。其次，由于现代计算平台的并行性，小批量训练会比单个样例训练更高效&lt;/p&gt;
&lt;p&gt;尽管随机梯度下降法简单有效，但却需要谨慎的调整模型的参数，特别是在优化过程中加入学习率和参数初始化方式的选择。每一层的输入都会受之前所有层的参数影响，并且随着网络越深，即使参数的变化很小也为对每一层的输入产生很大的影响。这使得训练一个网络变得十分复杂。神经网络层输入分布的改变，使得神经网络层必须不停的适应新的数据分布。当一个学习系统的输入数据分布产生变化，称这种现象为：Experience Covariate Shift。解决这种现象的典型方法是领域适应。输入数据分布相同这一特性，使得子网络更容易训练。因此保持输入的分布不变是有利的。保持一个子网络的输入数据分布不变，对该子网络以外的隐藏层也有积极的作用&lt;/p&gt;
&lt;p&gt;称在训练深度神经网络的过程中，网络内部节点的分布发生变换这一现象为 Internal Covariate Shift。而消除这个现象能够加速网络的训练。因此提出了Batch Normalization ，通过减少依赖参数缩放和初始化，进而缓解Internal Covariate Shift，并动态的加速深度神经网络的训练速度。BN 允许使用更高的学习率，而不会有发散的风险。进一步的，BN能够正则化模型，并且不需要Dropout。最后，BN能够使用s型激活函数，同时不会陷入饱和端&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;降低内协变量漂移(Internal Covariate Shift)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将 Internal Covariate Shift 定义为：在神经网络的训练过程中，由于参数改变，而引起的神经网络激活值分布的改变。通过缓解 Internal Covariate Shift 来提高训练。在训练的过程中保持神经网络层输入的分布不变，来提高训练速度。已知，如果对网络的输入进行白化(输入线性变换为具有零均值和单位方差，并去相关)，网络训练将会收敛的更快。通过白化每一层的输入，采取措施实现输入的固定分布，消除内部协变量转移的不良影响&lt;/p&gt;
&lt;p&gt;考虑在每个训练步骤或在某些间隔来白化激活值，通过直接修改网络或根据网络激活值来更改优化方法的参数。然而，如果这些修改分散在优化步骤中，那么梯度下降步骤可能会试图以要求标准化进行更新的方式来更新参数，这会降低梯度下降步骤的影响&lt;/p&gt;
&lt;p&gt;我们希望确保对于任何参数值，网络总是产生具有所需分布的激活值。这样做将允许关于模型参数损失的梯度来解释标准化，以及它对模型参数&lt;span class=&quot;math inline&quot;&gt;\(\Theta\)&lt;/span&gt;的依赖。希望通过对相对于整个训练数据统计信息的单个训练样本的激活值进行归一化来保留网络中的信息&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通过Mini-Batch统计进行标准化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于每一层输入的整个白化是代价昂贵的并且不是到处可微分的，因此做了两个必要的简化。首先是单独标准化每个标量特征，从而代替在层输入输出对特征进行共同白化，使其具有零均值和单位方差。对于多为输入的层，将标准化每一维。简单标准化层的每一个输入可能会改变层可以表示什么。例如，标准化sigmoid的输入会将它们约束到非线性的线性状态。为了解决这个问题，要确保插入到网络中的变换可以表示恒等变换。为了实现这个，对于每一个激活值x&lt;sup&gt;(k)&lt;/sup&gt;，引入成对的参数&lt;span class=&quot;math inline&quot;&gt;\(\gamma^{(k)}, \beta^{(k)}\)&lt;/span&gt;，它们会归一化和移动标准值&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ y^{k} = \gamma^{k} \hat a^{k} + \beta(k) \]&lt;/span&gt;&lt;br/&gt;这些参数与原始的模型参数一起学习，并恢复网络的表示能力&lt;/p&gt;
&lt;p&gt;每个训练步骤的批处理设置是基于整个训练集的，将使用整个训练集来标准化激活值。然而，当使用随机优化时，这是不切实际的。因此，做了第二个简化：由于在随机梯度训练中使用小批量，每个小批量产生每次激活平均值和方差的估计。这样，用于标准化的统计信息可以完全参与梯度反向传播。通过计算每一维的方差而不是联合协方差，可以实现小批量的使用；在联合情况下，将需要正则化，因为小批量大小可能小于白化的激活值的数量，从而导致单个协方差矩阵&lt;br/&gt;批标准化步骤&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503464/201812/1503464-20181214221028230-1498879544.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;BN变换可以添加到网络上来操纵任何激活。在公式&lt;span class=&quot;math inline&quot;&gt;\(y=BN_{\gamma,\beta}(x)\)&lt;/span&gt;中，参数&lt;span class=&quot;math inline&quot;&gt;\(\gamma\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(\beta\)&lt;/span&gt;需要进行学习，但应该注意到在每一个训练样本中BN变换不单独处理激活。相反，&lt;span class=&quot;math inline&quot;&gt;\(BN_{\gamma,\beta}(x)\)&lt;/span&gt;取决于训练样本和小批量数据中的其它样本。所有的这些子网络输入都有固定的均值和方差，尽管这些标准化的&lt;span class=&quot;math inline&quot;&gt;\(\hat {x} ^{(k)}\)&lt;/span&gt;的联合分布可能在训练过程中改变，但预计标准化输入的引入会加速子网络的训练，从而加速整个网络的训练&lt;/p&gt;
&lt;p&gt;BN变换是将标准化激活引入到网络中的可微变换。这确保了在模型训练时，层可以继续学习输入分布，表现出更少的内部协变量转移，从而加快训练。此外，应用于这些标准化的激活上的学习到的仿射变换允许BN变换表示恒等变换并保留网络的能力&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;批量标准化网络的训练与推理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了批标准化一个网络，根据上面的算法，指定一个激活的子集，然后在每一个激活中插入BN变换。任何以前接收x作为输入的层现在接收BN(x)作为输入。采用批标准化的模型可以使用批梯度下降，或者用小批量数据大小为m&amp;gt;1的随机梯度下降，或使用它的任何变种例如Adagrad进行训练。依赖小批量数据的激活值的标准化可以有效地训练，但在推断过程中是不必要的也是不需要的；希望输出只确定性地取决于输入。为此，一旦网络训练完成，将使用总体统计来进行标准化，而不是小批量数据统计&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \hat x = \frac {x - E[x]}{\sqrt {Var[x] + \epsilon}} \]&lt;/span&gt;&lt;br/&gt;此时，如果忽略&lt;span class=&quot;math inline&quot;&gt;\(\epsilon\)&lt;/span&gt;，这些标准化的激活具有相同的均值0和方差1，使用无偏方差估计&lt;span class=&quot;math inline&quot;&gt;\(Var[x] = \frac{m}{m-1} E_{\beta} [\sigma^2_{\beta}]\)&lt;/span&gt;，其中期望是在大小为m的小批量训练数据上得到的，&lt;span class=&quot;math inline&quot;&gt;\(\sigma^2_{\beta}\)&lt;/span&gt;是其样本方差。使用这些值移动平均，在训练过程中可以跟踪模型的准确性。由于均值和方差在推断时是固定的，因此标准化是应用到每一个激活上的简单线性变换。它可以进一步由缩放&lt;span class=&quot;math inline&quot;&gt;\(\gamma\)&lt;/span&gt;和转移&lt;span class=&quot;math inline&quot;&gt;\(\beta\)&lt;/span&gt;组成，以产生代替BN(x)的单线性变换&lt;br/&gt;训练批标准化网络的过程&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503464/201812/1503464-20181214221040846-1772550677.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;批标准化卷积网络&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;批标准化可以应用于网络的任何激活集合。这里专注于仿射变换和元素级非线性组成的变换&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ z = g(Wu + b) \]&lt;/span&gt;&lt;br/&gt;其中W和b是模型学习的参数，g(⋅)是非线性例如sigmoid或ReLU。这个公式涵盖了全连接层和卷积层。在非线性之前通过标准化x=Wu+b加入BN变换。也可以标准化层输入u，但由于u可能是另一个非线性的输出，它的分布形状可能在训练过程中改变，并且限制其第一矩或第二矩不能去除协变量转移。相比之下，Wu+b更可能具有对称，非稀疏分布，即“更高斯”，对其标准化可能产生具有稳定分布的激活&lt;/p&gt;
&lt;p&gt;由于对Wu+b进行标准化，偏置b可以忽略，因为它的效应将会被后面的中心化取消（偏置的作用会归入到算法1的β）。因此，z=g(Wu+b)被&lt;span class=&quot;math inline&quot;&gt;\(z=g(BN(Wu))\)&lt;/span&gt;替代，其中BN变换独立地应用到x=Wu的每一维，每一维具有单独的成对学习参数&lt;span class=&quot;math inline&quot;&gt;\(\gamma^{(k)},\beta^{(k)}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;另外，对于卷积层，希望标准化遵循卷积特性——为的是同一特征映射的不同元素，在不同的位置，以相同的方式进行标准化。为了实现这个，在所有位置联合标准化了小批量数据中的所有激活。在第一个算法中，让&lt;span class=&quot;math inline&quot;&gt;\(B\)&lt;/span&gt;是跨越小批量数据的所有元素和空间位置的特征图中所有值的集合——因此对于大小为m的小批量数据和大小为p×q的特征映射，使用有效的大小为m' = &lt;span class=&quot;math inline&quot;&gt;\(|B|\)&lt;/span&gt; = m ⋅ pq 的小批量数据。每个特征映射学习一对参数&lt;span class=&quot;math inline&quot;&gt;\(\gamma^{(k)}\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(\beta^{(k)}\)&lt;/span&gt;，而不是每个激活。第二个算法进行类似的修改，以便推断期间BN变换对在给定的特征映射上的每一个激活应用同样的线性变换&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;批标准化可以提高学习率&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过标准化整个网络的激活值，在数据通过深度网络传播时，它可以防止层参数的微小变化被放大。批标准化也使训练对参数的缩放更有弹性。通常，大的学习率可能会增加层参数的缩放，这会在反向传播中放大梯度并导致模型爆炸。然而，通过批标准化，通过层的反向传播不受其参数缩放的影响。对于标量&lt;span class=&quot;math inline&quot;&gt;\(\alpha\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ BN(Wu)=BN((aW)u) \]&lt;/span&gt;&lt;br/&gt;因此，&lt;span class=&quot;math inline&quot;&gt;\(\frac {∂BN((aW)u)}{∂u}= \frac {∂BN(Wu)}{∂u}\)&lt;/span&gt;。因此，标量不影响层的雅可比行列式，从而不影响梯度传播。此外，&lt;span class=&quot;math inline&quot;&gt;\(\frac {∂BN((aW)u)}{∂(aW)}=\frac {1}{a}⋅\frac {∂BN(Wu)}{∂W}\)&lt;/span&gt;，因此更大的权重会导致更小的梯度，并且批标准化会稳定参数的增长。研究者进一步推测，批标准化可能会导致雅可比行列式的奇异值接近于1，这被认为对训练是有利的&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实验&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;实验表明，批标准化有助于网络训练的更快，取得更高的准确率，原因是随着训练的进行，批标准化网络中的分布更加稳定，这有助于训练&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;加速BN网络&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;提高学习率。在批标准化模型中，能够从高学习率中实现训练加速，没有不良的副作用&lt;br/&gt;删除丢弃。发现从BN-Inception中删除丢弃可以使网络实现更高的验证准确率&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;推测批标准化提供了类似丢弃的正则化收益，因为对于训练样本观察到的激活受到了同一小批量数据中样本随机选择的影响&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;更彻底地搅乱训练样本。这导致验证准确率提高了约1％&lt;br/&gt;减少L2全中正则化。虽然在Inception中模型参数的L2损失会控制过拟合，但在修改的BN-Inception中，损失的权重减少了5倍。研究者发现这提高了在提供的验证数据上的准确性&lt;/p&gt;
&lt;p&gt;通过仅使用批标准化（BN-Baseline），可以在不到Inception一半的训练步骤数量内将准确度与其相匹配，这显著提高了网络的训练速度&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;结论&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;提出的方法(批标准化)大大加快了深度网络的训练。该方法从标准化激活以及将这种标准化结合到网络体系结构本身中汲取了它的力量。批处理规范化每次激活只添加两个额外的参数，并且这样做保留了网络的表示能力。本文提出了一种用批量标准化网络构建、训练和执行推理的算法。所得到的网络可以用饱和非线性进行训练，更容忍增加的训练速率，并且通常不需要dropout来进行正规化&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;为什么需要它&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在BN出现之前，我们的归一化操作一般都在数据输入层，对输入的数据进行求均值以及求方差做归一化，但是BN的出现打破了这一个规定，我们可以在网络中任意一层进行归一化处理。因为我们现在所用的优化方法大多都是min-batch SGD，所以我们的归一化操作就成为Batch Normalization&lt;/p&gt;
&lt;p&gt;神经网络层之前的神经网络层的参数变化，将会引起神经网络每一层输入数据的分布产生了变化，这使得训练一个深度神经网络会非常困难。作者称这个现象为：&lt;strong&gt;internal covariate shift&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;BatchNorm就是在深度神经网络训练过程中使得每一层神经网络的输入保持相同的分布的方法，是用来解决“Internal Covariate Shift”问题的&lt;/p&gt;
&lt;p&gt;Mini-Batch SGD相对于One Example SGD的两个优势：梯度更新方向更准确；并行计算速度快&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;它的思想&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;BN的基本思想是：因为深层神经网络在做非线性变换前的激活输入值（就是那个x=WU+B，U是输入）随着网络深度加深或者在训练过程中，其分布逐渐发生偏移或者变动，之所以训练收敛慢，一般是整体分布逐渐往非线性函数的取值区间的上下限两端靠近，这导致反向传播时低层神经网络的梯度消失，这是训练深层神经网络收敛越来越慢的本质原因，而BN就是通过一定的规范化手段，把每层神经网络任意神经元这个输入值的分布强行拉回到均值为0方差为1的标准正态分布，这样使得激活输入值落在非线性函数对输入比较敏感的区域，这样输入的小变化就会导致损失函数较大的变化，即通过这种方法让梯度变大，避免梯度消失问题产生，而且梯度变大意味着学习收敛速度快，能大大加快训练速度&lt;/p&gt;
&lt;p&gt;BN其实就是把每个隐层神经元的激活输入分布从偏离均值为0方差为1的正态分布通过平移均值压缩或者扩大曲线尖锐程度，调整为均值为0方差为1的正态分布&lt;/p&gt;
&lt;p&gt;当输入均值为0，方差为1时，当使用sigmoid激活函数时，绝大多数的输入都落到了[-2,2]的区间，而这一段是sigmoid函数接近于线性变换的区域，意味着x的小变化会导致非线性函数值较大的变化，也即是梯度变化较大，对应导数函数图中明显大于0的区域，就是梯度非饱和区。即经过BN后，目前大部分Activation的值落入非线性函数的线性区内，其对应的导数远离导数饱和区，这样来加速训练收敛过程&lt;/p&gt;
&lt;p&gt;然后为了不让网络的表达能力下降，保证非线性的获得，它又对变换后的满足均值为0方差为1的x又进行了scale加上shift操作(y=scale*x+shift)，这样就等价于将非线性函数的值从正中心周围的线性区往非线性区移动了一点&lt;/p&gt;
&lt;p&gt;推理的过程中，我们得不到实例集合的均值和方差，因此，这里用从所有训练实例中获得的统计量来代替Mini-Batch里面m个训练实例获得的均值和方差统计量&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;BN的优点&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;提升了训练速度，收敛过程大大加快&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;增加分类效果，一种解释是这是类似于Dropout的，一种是自带了防止过拟合的正则化表达方式，所以不用Dropout也能达到相当的效果&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;调参过程也简单多了，对于初始化要求没那么高，而且可以使用大的学习率等&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;参考链接&lt;/strong&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/guoyaohua/p/8724433.html&quot;&gt;深入理解Batch Normalization批标准化&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/skyfsm/p/8453498.html&quot;&gt;批归一化（Batch Normalization）&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://v.youku.com/v_show/id_XMTg1MTYwNDg2OA==&quot;&gt;视频链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/zhhfan/p/10121938.html&quot;&gt;GoogLeNetv1 论文研读笔记&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/zhhfan/p/10122019.html&quot;&gt;GoogLeNetv3 论文研读笔记&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 14 Dec 2018 14:13:00 +0000</pubDate>
<dc:creator>范中豪</dc:creator>
<og:description>GoogLeNetv2论文研读</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhhfan/p/10121965.html</dc:identifier>
</item>
<item>
<title>云计算全栈-系统管理04-目录和文件管理（二） - 房佳亮</title>
<link>http://www.cnblogs.com/crushlinux/p/10121912.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/crushlinux/p/10121912.html</guid>
<description>&lt;p&gt;作者信息： 房佳亮 (crushlinux@163.com)&lt;/p&gt;

&lt;p&gt;学习环境：&lt;/p&gt;
&lt;div&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;操作系统&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;IP地址&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;主机名&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;软件包&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;备注&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;CentOS7.5&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;192.168.200.111&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;localhost&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;实验初始配置：所有主机关闭防火墙与selinux&lt;/p&gt;
&lt;p&gt;[root@localhost ~]# iptables -F&lt;/p&gt;
&lt;p&gt;[root@localhost ~]# systemctl stop firewalld&lt;/p&gt;
&lt;p&gt;[root@localhost ~]# systemctl disable firewalld&lt;/p&gt;

&lt;p&gt;[root@localhost ~]# setenforce 0&lt;/p&gt;
&lt;p&gt;[root@localhost ~]# sed -i '/SELINUX/ s/enforcing/disabled/g' /etc/sysconfig/selinux&lt;/p&gt;

&lt;p&gt;Linux目录结构&lt;/p&gt;
&lt;p&gt;树形目录结构：&lt;/p&gt;
&lt;p&gt;根目录：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;所有分区、目录、文件等的位置起点&lt;/li&gt;
&lt;li&gt;整个树形目录结构中，使用独立的一个“/”表示&lt;/li&gt;
&lt;li&gt;不管计算机拥有多少个分区，多少个硬盘，操作系统使用时只能有一个跟&lt;/li&gt;
&lt;/ul&gt;&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/064099c639360783cedb0187365065b9/xmlnote/85FF413803AB429E8A66FD455270BF55/9529&quot; alt=&quot;&quot; data-media-type=&quot;image&quot; data-original=&quot;https://note.youdao.com/yws/public/resource/064099c639360783cedb0187365065b9/xmlnote/85FF413803AB429E8A66FD455270BF55/9529&quot;/&gt;&lt;/div&gt;

&lt;ul&gt;&lt;li&gt;/root：系统管理员root的宿主目录&lt;/li&gt;
&lt;li&gt;/home：普通用户的宿主目录&lt;/li&gt;
&lt;li&gt;/boot：系统内核、启动文件&lt;/li&gt;
&lt;li&gt;/dev：设备文件&lt;/li&gt;
&lt;li&gt;/etc：配置文件&lt;/li&gt;
&lt;li&gt;/lib /lib64：库文件&lt;/li&gt;
&lt;li&gt;/tmp：临时文件&lt;/li&gt;
&lt;li&gt;/media /mnt 默认挂载点&lt;/li&gt;
&lt;li&gt;/bin：所有用户可执行的命令&lt;/li&gt;
&lt;li&gt;/sbin：管理员可执行的管理命令&lt;/li&gt;
&lt;li&gt;/usr /opt：应用程序&lt;/li&gt;
&lt;li&gt;/var/log：日志文件等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;cat、nl、tac、rev&lt;/p&gt;
&lt;p&gt;用法：cat [选项]... [文件]...&lt;/p&gt;
&lt;p&gt;将[文件]或标准输入组合输出到标准输出。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;-n 显示内容的同时显示行号&lt;/li&gt;
&lt;li&gt;-A 显示所有的字符 （通常windows系统拷贝过来的文件无法直接cat到，需要加此选项）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;[root@localhost ~]# cat -n /etc/hosts&lt;/p&gt;
&lt;p&gt;1 127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4&lt;/p&gt;
&lt;p&gt;2 ::1 localhost localhost.localdomain localhost6 localhost6.localdomain6&lt;/p&gt;
&lt;p&gt;[root@localhost ~]# nl /etc/resolv.conf&lt;/p&gt;
&lt;p&gt;1 # Generated by NetworkManager&lt;/p&gt;
&lt;p&gt;2 nameserver 202.106.0.20&lt;/p&gt;
&lt;p&gt;3 search localdomain&lt;/p&gt;
&lt;p&gt;[root@localhost ~]# tac /etc/hosts&lt;/p&gt;
&lt;p&gt;::1 localhost localhost.localdomain localhost6 localhost6.localdomain6&lt;/p&gt;
&lt;p&gt;127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4&lt;/p&gt;

&lt;p&gt;more 全屏方式分页显示文件内容&lt;/p&gt;
&lt;p&gt;用法：more [选项] 文件...&lt;/p&gt;
&lt;p&gt;快捷键：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;按Enter向下滚动一行&lt;/li&gt;
&lt;li&gt;按空格键向下滚动一页&lt;/li&gt;
&lt;li&gt;按q键退出&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;less 与more基本相同，但扩展功能更多&lt;/p&gt;
&lt;p&gt;格式：less [选项] 文件名 （一般不用选项）&lt;/p&gt;
&lt;p&gt;快捷键：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;按PgUp、PgDn键上下翻页&lt;/li&gt;
&lt;li&gt;按“/”键查找内容，“n”下一个，“N”上一个&lt;/li&gt;
&lt;li&gt;其他功能与more基本类似&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;head查看文件开头的一部分内容，默认显示10行，可加选项调节&lt;/p&gt;
&lt;p&gt;用法：head [选项]... [文件]...&lt;/p&gt;
&lt;p&gt;[root@localhost ~]# head -5 /etc/passwd&lt;/p&gt;
&lt;p&gt;root:x:0:0:root:/root:/bin/bash&lt;/p&gt;
&lt;p&gt;bin:x:1:1:bin:/bin:/sbin/nologin&lt;/p&gt;
&lt;p&gt;daemon:x:2:2:daemon:/sbin:/sbin/nologin&lt;/p&gt;
&lt;p&gt;adm:x:3:4:adm:/var/adm:/sbin/nologin&lt;/p&gt;
&lt;p&gt;lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin&lt;/p&gt;

&lt;p&gt;tail查看文件结尾的一部分内容，默认显示10行，可加选项调节&lt;/p&gt;
&lt;p&gt;用法：tail [选项]... [文件]...&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;–f 动态更新尾部的信息=tailf&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;[root@localhost ~]# tail -3 /etc/passwd&lt;/p&gt;
&lt;p&gt;tcpdump:x:72:72::/:/sbin/nologin&lt;/p&gt;
&lt;p&gt;mysql:x:1000:1000::/home/mysql:/sbin/nologin&lt;/p&gt;
&lt;p&gt;dhcpd:x:177:177:DHCP server:/:/sbin/nologin&lt;/p&gt;

&lt;p&gt;wc作用：统计文件中的单词数量（Word Count）等&lt;/p&gt;
&lt;p&gt;用法：wc [选项]... [文件]...&lt;/p&gt;
&lt;p&gt;常用选项：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;-l：统计行数&lt;/li&gt;
&lt;li&gt;-w：统计单词个数&lt;/li&gt;
&lt;li&gt;-c：统计字节数&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;[root@localhost ~]# wc -l /etc/passwd&lt;/p&gt;
&lt;p&gt;45 /etc/passwd&lt;/p&gt;
&lt;p&gt;[root@localhost ~]# wc -w /etc/passwd&lt;/p&gt;
&lt;p&gt;90 /etc/passwd&lt;/p&gt;
&lt;p&gt;[root@localhost ~]# wc -c /etc/passwd&lt;/p&gt;
&lt;p&gt;2341 /etc/passwd&lt;/p&gt;
&lt;p&gt;[root@localhost ~]# wc /etc/passwd&lt;/p&gt;
&lt;p&gt;45 90 2341 /etc/passwd&lt;/p&gt;

&lt;p&gt;grep&lt;/p&gt;
&lt;p&gt;作用：在文件中查找并显示包含指定字符串的行&lt;/p&gt;
&lt;p&gt;用法: grep [选项]... PATTERN [FILE]...&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;-i：查找时忽略大小写&lt;/li&gt;
&lt;li&gt;-v：反转查找，输出与条件不相符的行&lt;/li&gt;
&lt;li&gt;-E: 查找时支持正则表达式&lt;/li&gt;
&lt;li&gt;-w: 查找时将条件视为完整单词&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;“^…”表示以…开头&lt;/p&gt;
&lt;p&gt;“…$”表示以…结尾&lt;/p&gt;
&lt;p&gt;“^$”表示空行&lt;/p&gt;

&lt;p&gt;egrep=grep -E&lt;/p&gt;
&lt;p&gt;作用：增强型过滤&lt;/p&gt;
&lt;p&gt;格式：egrep [选项] “查找条件1|查找条件2|查找条件3…” 目标文件&lt;/p&gt;

&lt;p&gt;gzip&lt;/p&gt;
&lt;p&gt;作用：压缩，选项为1-9的数字控制压缩级别，数字越大压缩级别越高。压缩后 文件格式为“.gz”&lt;/p&gt;
&lt;p&gt;格式：gzip [-9] 文件名&lt;/p&gt;

&lt;p&gt;gunzip、gzip –d&lt;/p&gt;
&lt;p&gt;作用：解压缩格式为.gz的压缩文件&lt;/p&gt;
&lt;p&gt;格式：gunzip 文件名&lt;/p&gt;
&lt;p&gt;gzip -d 文件名&lt;/p&gt;

&lt;p&gt;bzip2&lt;/p&gt;
&lt;p&gt;作用：压缩，选项为1-9的数字控制压缩级别，数字越大压缩级别越高。压缩后 文件格式为“.bz2”&lt;/p&gt;
&lt;p&gt;格式：bzip2 [-9] 文件名&lt;/p&gt;

&lt;p&gt;bunzip2、bzip2 –d&lt;/p&gt;
&lt;p&gt;作用：解压缩格式为.bz2的压缩文件&lt;/p&gt;
&lt;p&gt;格式：bunzip2 文件名&lt;/p&gt;
&lt;p&gt;bzip2 -d 文件名&lt;/p&gt;

&lt;p&gt;tar&lt;/p&gt;
&lt;p&gt;作用：制作归档文件、释放归档文件&lt;/p&gt;
&lt;p&gt;格式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;归档：tar [选项c…] 归档文件名 源文件或目录&lt;/li&gt;
&lt;li&gt;释放：tar [选项x…] 归档文件名 [-C 目标目录]&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;常用选项：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;-c 创建.tar格式的包文件&lt;/li&gt;
&lt;li&gt;-x 解开.tar格式的包文件&lt;/li&gt;
&lt;li&gt;-v 输出详细信息&lt;/li&gt;
&lt;li&gt;-f 表示使用归档文件（后面需紧跟归档文件名）&lt;/li&gt;
&lt;li&gt;-p 打包时保留原始文件及目录的权限（不建议使用）&lt;/li&gt;
&lt;li&gt;-t 列表查看包内的文件&lt;/li&gt;
&lt;li&gt;-C 解包时指定释放的目标目录&lt;/li&gt;
&lt;li&gt;-z 调用gzip程序进行压缩或解压&lt;/li&gt;
&lt;li&gt;-j 调用bzip2程序进行压缩或解压&lt;/li&gt;
&lt;li&gt;-P打包时保留文件及目录的绝对路径（不建议使用）&lt;/li&gt;
&lt;li&gt;--remove 选项打包压缩时可删除源文件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;p&gt;1、tar命令的选项前可以省略“-”，在解压时无需选择“-z”或“-j”，命令可以自行识别&lt;/p&gt;
&lt;p&gt;2、tar命令通过-zcf 选项创建打包压缩文件时（.tar.gz = .tgz）&lt;/p&gt;

&lt;p&gt;额外扩展：&lt;/p&gt;
&lt;p&gt;1、tar命令实现增量备份&lt;/p&gt;
&lt;p&gt;完整备份:&lt;/p&gt;

&lt;p&gt;建立测试路径与档案&lt;/p&gt;
&lt;p&gt;[root@localhost ~]# mkdir test&lt;/p&gt;
&lt;p&gt;[root@localhost ~]# touch test/{a,b,c}&lt;/p&gt;
&lt;p&gt;在test目录下生成三个文件&lt;/p&gt;

&lt;p&gt;执行完整备份&lt;/p&gt;
&lt;p&gt;[root@localhost ~]# tar -g snapshot -zcf full.tar.gz test/&lt;/p&gt;

&lt;p&gt;查看 tarball 内容&lt;/p&gt;
&lt;p&gt;[root@localhost ~]# tar tf full.tar.gz&lt;/p&gt;
&lt;p&gt;test/&lt;/p&gt;
&lt;p&gt;test/a&lt;/p&gt;
&lt;p&gt;test/b&lt;/p&gt;
&lt;p&gt;test/c&lt;/p&gt;

&lt;p&gt;差异+增量备份 ：&lt;/p&gt;
&lt;p&gt;新增一个档案, 并修改一个档案内容&lt;/p&gt;
&lt;p&gt;[root@localhost ~]# touch test/e&lt;/p&gt;
&lt;p&gt;[root@localhost ~]# echo 123 &amp;gt; test/a&lt;/p&gt;

&lt;p&gt;执行第二次的增量备份 (注意 tarball 档名)&lt;/p&gt;
&lt;p&gt;[root@localhost ~]# tar -g snapshot -zcf full_2.tar.gz test&lt;/p&gt;

&lt;p&gt;查看 tarball 内容&lt;/p&gt;
&lt;p&gt;[root@localhost ~]# tar tf full_2.tar.gz&lt;/p&gt;
&lt;p&gt;test/&lt;/p&gt;
&lt;p&gt;test/a&lt;/p&gt;
&lt;p&gt;test/e&lt;/p&gt;

&lt;p&gt;还原备份资料:清空测试资料&lt;/p&gt;
&lt;p&gt;[root@localhost ~]# rm -rf test/&lt;/p&gt;

&lt;p&gt;开始进行资料还原&lt;/p&gt;
&lt;p&gt;[root@localhost ~]# tar xf full.tar.gz&lt;/p&gt;
&lt;p&gt;[root@localhost ~]# tar xf full_2.tar.gz&lt;/p&gt;

&lt;p&gt;查看测试资料&lt;/p&gt;
&lt;p&gt;[root@localhost ~]# ls test/&lt;/p&gt;
&lt;p&gt;a b c e&lt;/p&gt;


&lt;p&gt;2、打包某个目录下的所有文件时忽略某个文件&lt;/p&gt;
&lt;p&gt;[root@localhost ~]# mkdir /tardir&lt;/p&gt;
&lt;p&gt;[root@localhost ~]# touch /tardir/{11,22,33,44,55}&lt;/p&gt;
&lt;p&gt;[root@localhost ~]# ls -l /tardir/&lt;/p&gt;
&lt;p&gt;总用量 0&lt;/p&gt;
&lt;p&gt;-rw-r--r-- 1 root root 0 12月 14 16:59 11&lt;/p&gt;
&lt;p&gt;-rw-r--r-- 1 root root 0 12月 14 16:59 22&lt;/p&gt;
&lt;p&gt;-rw-r--r-- 1 root root 0 12月 14 16:59 33&lt;/p&gt;
&lt;p&gt;-rw-r--r-- 1 root root 0 12月 14 16:59 44&lt;/p&gt;
&lt;p&gt;-rw-r--r-- 1 root root 0 12月 14 16:59 55&lt;/p&gt;
&lt;p&gt;[root@localhost ~]# tar zcf num.tar.gz --exclude=/tardir/11 --exclude=/tardir/22 /tardir&lt;/p&gt;
&lt;p&gt;tar: 从成员名中删除开头的“/”&lt;/p&gt;
&lt;p&gt;[root@localhost ~]# tar tf num.tar.gz&lt;/p&gt;
&lt;p&gt;tardir/&lt;/p&gt;
&lt;p&gt;tardir/33&lt;/p&gt;
&lt;p&gt;tardir/44&lt;/p&gt;
&lt;p&gt;tardir/55&lt;/p&gt;

&lt;p&gt;或者&lt;/p&gt;
&lt;p&gt;[root@localhost ~]# tar zcf num.tar.gz --exclude-from /tardir/excludefile /tardir&lt;/p&gt;
&lt;p&gt;tar: 从成员名中删除开头的“/”&lt;/p&gt;
&lt;p&gt;[root@localhost ~]# tar tf num.tar.gz&lt;/p&gt;
&lt;p&gt;tardir/&lt;/p&gt;
&lt;p&gt;tardir/33&lt;/p&gt;
&lt;p&gt;tardir/44&lt;/p&gt;
&lt;p&gt;tardir/55&lt;/p&gt;
&lt;p&gt;tardir/excludefile&lt;/p&gt;

&lt;p&gt;3、tar命令打包压缩时忽略目录&lt;/p&gt;
&lt;p&gt;[root@localhost ~]# tar zcf file.tar.gz -C /etc/ passwd&lt;/p&gt;
&lt;p&gt;[root@localhost ~]# tar tf file.tar.gz&lt;/p&gt;
&lt;p&gt;passwd&lt;/p&gt;


&lt;p&gt;文本编辑器的作用&lt;/p&gt;
&lt;p&gt;创建或修改文本文件&lt;/p&gt;
&lt;p&gt;维护 Linux 系统中的各种配置文件&lt;/p&gt;

&lt;p&gt;Linux中最常用的文本编辑器&lt;/p&gt;
&lt;p&gt;vi：类UNIX操作系统的默认文本编辑器&lt;/p&gt;
&lt;p&gt;vim：vim是vi文本编辑器（一般简称为vi编辑器）的增强版本&lt;/p&gt;

&lt;p&gt;三种工作模式&lt;/p&gt;
&lt;p&gt;命令模式、输入模式、末行模式&lt;/p&gt;

&lt;p&gt;不同模式之间的切换&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/064099c639360783cedb0187365065b9/xmlnote/BCC61C8546394D73BE43D5A5654DCD8F/9534&quot; alt=&quot;&quot; data-media-type=&quot;image&quot; data-original=&quot;https://note.youdao.com/yws/public/resource/064099c639360783cedb0187365065b9/xmlnote/BCC61C8546394D73BE43D5A5654DCD8F/9534&quot;/&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;a 在光标后插入内容&lt;/li&gt;
&lt;li&gt;A 在光标所在行末尾插入内容&lt;/li&gt;
&lt;li&gt;i 从当前光标前插入内容&lt;/li&gt;
&lt;li&gt;I 在光标所在行行首插入内容&lt;/li&gt;
&lt;li&gt;o 在当前光标下插入空行&lt;/li&gt;
&lt;li&gt;O 在当前光标上插入空行&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;光标移动&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/064099c639360783cedb0187365065b9/xmlnote/262C4EE6FCF349B89838F72871F9DCE7/9555&quot; alt=&quot;&quot; data-media-type=&quot;image&quot; data-original=&quot;https://note.youdao.com/yws/public/resource/064099c639360783cedb0187365065b9/xmlnote/262C4EE6FCF349B89838F72871F9DCE7/9555&quot;/&gt;&lt;/div&gt;
&lt;p&gt;复制、粘贴、删除&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/064099c639360783cedb0187365065b9/xmlnote/61FADD574E35465D85AF9027E26FFAE9/9530&quot; alt=&quot;&quot; data-media-type=&quot;image&quot; data-original=&quot;https://note.youdao.com/yws/public/resource/064099c639360783cedb0187365065b9/xmlnote/61FADD574E35465D85AF9027E26FFAE9/9530&quot;/&gt;&lt;/div&gt;
&lt;p&gt;文件内容查找&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/064099c639360783cedb0187365065b9/xmlnote/7F2FD54CD63347409B14DC3D63CEA574/9536&quot; alt=&quot;&quot; data-media-type=&quot;image&quot; data-original=&quot;https://note.youdao.com/yws/public/resource/064099c639360783cedb0187365065b9/xmlnote/7F2FD54CD63347409B14DC3D63CEA574/9536&quot;/&gt;&lt;/div&gt;
&lt;p&gt;撤销编辑及保存退出&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/064099c639360783cedb0187365065b9/xmlnote/98A7B57A582A44D0A31C79E03275D39F/9539&quot; alt=&quot;&quot; data-media-type=&quot;image&quot; data-original=&quot;https://note.youdao.com/yws/public/resource/064099c639360783cedb0187365065b9/xmlnote/98A7B57A582A44D0A31C79E03275D39F/9539&quot;/&gt;&lt;/div&gt;
&lt;p&gt;保存文件及退出vi编辑器&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/064099c639360783cedb0187365065b9/xmlnote/F43D495AE8714787878ADD60804C5E0D/9537&quot; alt=&quot;&quot; data-media-type=&quot;image&quot; data-original=&quot;https://note.youdao.com/yws/public/resource/064099c639360783cedb0187365065b9/xmlnote/F43D495AE8714787878ADD60804C5E0D/9537&quot;/&gt;&lt;/div&gt;
&lt;p&gt;打开新文件或读入其他文件内容&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/064099c639360783cedb0187365065b9/xmlnote/27B22FE805D24937B11973F61276D01E/9538&quot; alt=&quot;&quot; data-media-type=&quot;image&quot; data-original=&quot;https://note.youdao.com/yws/public/resource/064099c639360783cedb0187365065b9/xmlnote/27B22FE805D24937B11973F61276D01E/9538&quot;/&gt;&lt;/div&gt;
&lt;p&gt;文件内容替换&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/064099c639360783cedb0187365065b9/xmlnote/27D1FFBCB0244362BC3B700FCBFF35DB/9532&quot; alt=&quot;&quot; data-media-type=&quot;image&quot; data-original=&quot;https://note.youdao.com/yws/public/resource/064099c639360783cedb0187365065b9/xmlnote/27D1FFBCB0244362BC3B700FCBFF35DB/9532&quot;/&gt;&lt;/div&gt;

&lt;p&gt;常规操作的补充：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;:x 保存退出 但如果未修改，时间戳不改变&lt;/li&gt;
&lt;li&gt;:w file 将当前文件另存为file （vim）&lt;/li&gt;
&lt;li&gt;:X 加密（vim）&lt;/li&gt;
&lt;li&gt;:7 跳转到第7行&lt;/li&gt;
&lt;li&gt;:1,$ co $ 从第一行到第最后一行复制，到最后一行后&lt;/li&gt;
&lt;li&gt;J 合并当前行和下一行&lt;/li&gt;
&lt;li&gt;ctrl+r 对使用u命令撤销操作进行恢复&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;vim可视化模式操作：&lt;/p&gt;


&lt;p&gt;vim学习工具：vimtutor&lt;/p&gt;

&lt;p&gt;vim键盘图&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/064099c639360783cedb0187365065b9/xmlnote/01BA688510EF4BFC8BA8E8CFD1708BAD/9533&quot; alt=&quot;&quot; data-media-type=&quot;image&quot; data-original=&quot;https://note.youdao.com/yws/public/resource/064099c639360783cedb0187365065b9/xmlnote/01BA688510EF4BFC8BA8E8CFD1708BAD/9533&quot;/&gt;&lt;/div&gt;
</description>
<pubDate>Fri, 14 Dec 2018 14:00:00 +0000</pubDate>
<dc:creator>房佳亮</dc:creator>
<og:description>作者信息： 房佳亮 (crushlinux@163.com) 学习环境： 操作系统 IP地址 主机名 软件包 备注 CentOS7.5 192.168.200.111 localhost 操作系统 I</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/crushlinux/p/10121912.html</dc:identifier>
</item>
<item>
<title>设计模式——适配器模式（type-c转3.5mm耳机口） - cdream</title>
<link>http://www.cnblogs.com/cdream-zs/p/10121875.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cdream-zs/p/10121875.html</guid>
<description>&lt;blockquote readability=&quot;6.6347826086957&quot;&gt;
&lt;p&gt;本文首发于&lt;a href=&quot;https://icdream.github.io/2018/12/14/designpattern03/&quot;&gt;cdream&lt;/a&gt;的个人博客，点击获得更好的阅读体验！&lt;/p&gt;
&lt;p&gt;欢迎转载，转载请注明出处。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文简述适配器模式，考虑到java中没有多继承就只写了对象适配器模式，然后例子是怎么用转接口把3.5mm耳机插在小米8上面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/006tNbRwly1fy6kyjux7nj316i0am75r.jpg&quot; alt=&quot;image-20181214211029904&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;一概念&quot;&gt;一、概念&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;适配器模式&lt;/strong&gt;（英语：adapter pattern）有时候也称包装样式或者包装(wrapper)。将一个类的接口转接成用户所期待的。一个适配器使得因接口不兼容而不能在一起工作的类能在一起工作，做法是将类自己的接口包裹在一个已存在的类中。&lt;/p&gt;
&lt;p&gt;适配器模式允许一个已存在的类的接口被用作另一个接口。通常可以在不需要修改源代码的情况下使用已存在的类。&lt;/p&gt;
&lt;p&gt;其实在生活中，适配器随处看见，例如下图，一个type-c转耳机口的适配器。接下来让我看看适配器模式的结构，并用java代码来实现一个type-c接口的手机与3.5mm的耳机通过适配器连接。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws4.sinaimg.cn/large/006tNbRwly1fy6h3dhi2rj30jw0kqq3e.jpg&quot; alt=&quot;image-20181214184815532&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;适配器模式主要解决两个问题&lt;/strong&gt;：&lt;br/&gt;1.转换当前接口为客户端需要的接口&lt;br/&gt;2.通过适配器使用没有我们需要的接口的类&lt;/p&gt;
&lt;p&gt;描述看似相同，实际上出发点不同~嘿嘿，意会意会&lt;/p&gt;
&lt;h2 id=&quot;二结构&quot;&gt;二、结构&lt;/h2&gt;
&lt;p&gt;适配器模式有两种，一种是&lt;strong&gt;类适配器&lt;/strong&gt;，不过需要支持多继承的语言才能实现，本文主要讲解单继承也可以实现的&lt;strong&gt;对象适配器&lt;/strong&gt;。下图是对象适配器模式的类图，Client需要一个实现Target接口的类来完成工作，而当前我们提供的只有Adaptee类，这时该怎么办呢？恩，我们就造一个适配器（adapter）来完成这个需求。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws2.sinaimg.cn/large/006tNbRwly1fy5xwwob9bj30qo0egwfa.jpg&quot; alt=&quot;image-20181214075257986&quot;/&gt;&lt;/p&gt;
&lt;p&gt;涉及到的主要角色：&lt;/p&gt;
&lt;p&gt;​ &lt;strong&gt;Target&lt;/strong&gt;:目标接口，也就是我们期待得到的接口。&lt;/p&gt;
&lt;p&gt;​ &lt;strong&gt;Adaptee&lt;/strong&gt;：当前拥有的接口，需要适配，已满足客户端的要求。&lt;/p&gt;
&lt;p&gt;​ &lt;strong&gt;Adapter&lt;/strong&gt;：适配器类，适配器模式的核心，就是将Adaptee转换成需要的接口的具体类。&lt;/p&gt;
&lt;h2 id=&quot;三type-c转3.5mm耳机孔适配器&quot;&gt;三、Type-C转3.5mm耳机孔适配器&lt;/h2&gt;
&lt;p&gt;这个是小米8手机类，只提供插TypeC耳机的接口&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Mi8{
    private TypeCEraPhones eraPhones;
    //打电话功能
    public void call() {
        System.out.println(&quot;打电话&quot;);
    }
    //播放音乐，有耳机就用耳机，没耳机就外放
    public void playMusic() {
        if (eraPhones != null){
            eraPhones.play();
        }else{
            System.out.println(&quot;外放&quot;);
        }

    }
    // 插个TypeC接口的耳机
    public void setEraPhones(TypeCEraPhones eraPhones) {
        this.eraPhones = eraPhones;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个是TypeC接口的耳机接口，听说用这个接口的耳机都好好贵呢~~&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface TypeCEraPhones {
    void play();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个是我们以前剩下的能听个响的3.5mm接口的耳机&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Mi35MMEraPhones {
    public void play(){
        System.out.println(&quot;使用3.5mm孔的小米耳机播放声音&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;怎么办呢，是花大钱买个新的耳机（想想，如果真是个复杂的对象，重新实现功能是不是很头大），还是对当前这个3.5mm的耳机爆改,可是我还有个需要使用3.5mm的mp3 ,🤔,这可怎么是好……于是机智的我去淘宝发现了一个type-c转3.5mm的接口，才5块钱！！🤣&lt;/p&gt;
&lt;p&gt;适配器类&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Adapter implements TypeCEraPhones {
    private Mi35MMEraPhones eraPhones;

    public Adapter(Mi35MMEraPhones eraPhones) {
        this.eraPhones = eraPhones;
    }

    @Override
    public void play() {
        eraPhones.play();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;适配器实现了TypeC耳机的接口，并能把原来的耳机传进来，于是我们就能愉快的用原来的耳机在小米8上听音乐了，hooooooo~而且还能我的mp3使用，美滋滋~&lt;/p&gt;
&lt;h2 id=&quot;四缺省适配器模式&quot;&gt;四、缺省适配器模式&lt;/h2&gt;
&lt;p&gt;在很多情况下，必须让一个具体类实现某一个接口，但是这个类又用不到接口所规定的所有的方法。通常的处理方法是，把方法都实现了，有用的写上需要的方法，没用的提供空实现，烦死了😤&lt;/p&gt;
&lt;p&gt;这些空的方法是一种浪费，有时也是一种混乱。只有看过这些空方法的代码，程序员才能知道哪些是空的，哪些不是空的，于是我们可以提供一个适配器类，来为接口所有方法提供空实现，然后这个具体类继承适配器接口，需要哪些方法，进行重写就可以。&lt;/p&gt;
&lt;p&gt;在jdk中有AbstractList这样一个抽象类，实现了List接口，如果我们需要定制自己的集合类，就可以继承这个抽象类，需要哪些方法就可以对这些方法进行重写，而不用对List接口下所有方法都提供空实现。&lt;/p&gt;
&lt;p&gt;缺省适配器模式是一种特殊的适配器模式，目的是在不得不继承某个方法时可以减少重写不需要的方法。&lt;/p&gt;
&lt;h2 id=&quot;五优缺点&quot;&gt;五、优缺点&lt;/h2&gt;
&lt;h3 id=&quot;优点&quot;&gt;优点&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;更好的复用性&lt;/strong&gt;：系统需要使用现有的类，而此类的接口不符合系统的需要。那么通过适配器模式就可以让这些功能得到更好的复用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;更好的扩展性&lt;/strong&gt;：在实现适配器功能的时候，可以调用自己开发的功能，从而自然地扩展系统的功能。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;缺点&quot;&gt;缺点&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;过多的使用适配器模式，会让系统难以把控，毕竟表面上是A接口，其实内部被适配成了B接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;六总结&quot;&gt;六、总结&lt;/h2&gt;
&lt;p&gt;本文对适配器模式进行了简要介绍，主要把握是适配器实现需要的接口，并与adaptee进行组合，就可以实现对象适配器。在学习适配器模式过程中可以与装饰者模式和外观模式，适配器和装饰者使用方法类似，但是目的完全不同，前者是将一个接口转为另一个接，后者是为了对类进行增强；外观模式目的是对外提供一个简单的接口。&lt;/p&gt;
&lt;hr/&gt;&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;http://product.dangdang.com/20021171.html&quot;&gt;Head First 设计模式,Eric Freeman &amp;amp;Elisabeth Freeman with Kathy Sierra &amp;amp; Bert Bates&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Adapter_pattern&quot;&gt;Adapter pattern，wiki&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/java-my-life/archive/2012/04/13/2442795.html&quot;&gt;《JAVA与模式》之适配器模式&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Fri, 14 Dec 2018 13:50:00 +0000</pubDate>
<dc:creator>cdream</dc:creator>
<og:description>本文首发于</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cdream-zs/p/10121875.html</dc:identifier>
</item>
</channel>
</rss>