<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>跟我学SpringCloud | 第六篇：Spring Cloud Config Github配置中心 - 极客挖掘机</title>
<link>http://www.cnblogs.com/babycomeon/p/11134717.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/babycomeon/p/11134717.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Springboot: 2.1.6.RELEASE&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;SpringCloud: Greenwich.SR1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;如无特殊说明，本系列教程全采用以上版本&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;随着分布式项目越来越大，勤劳的程序猿们会开始面临一个挑战，配置文件会越来越繁杂，虽然spring提供了一个鸡肋版的解决方案，spring.profiles.active，在大型的分布式项目体系中，聊胜于无吧，手动维护配置文件的痛苦，生产，UAT，测试，开发环境的隔离，额外的配置文件，如：logback.xml日志的配置文件，bootstrap.properties配置文件，当系统中有几十个服务，相应的会有上百个配置文件，简直就是史诗级的灾难大片，每次发布上线，都要手动去检查配置文件，相应的服务都需要重启，那么，有没有一种方案，可以自动更新配置，并且对版本做出相应的控制，恰好，springcloud为我们提供了这样一种工具，虽然很多方面都还不完善，配置能力比较弱，但是也给我们提供了一种思路。&lt;/p&gt;
&lt;p&gt;市面上有很多配置中心，BAT每家都出过，360的QConf、淘宝的diamond、百度的disconf都是解决这类问题。国外也有很多开源的配置中心Apache Commons Configuration、owner、cfg4j等等。这些开源的软件以及解决方案都很优秀，也存在这样或者那样的缺陷。今天我们要了解的Spring Cloud Config，可以无缝的和spring体系相结合，够方便够简单颜值高。&lt;/p&gt;
&lt;h2 id=&quot;spring-cloud-config&quot;&gt;1. Spring Cloud Config&lt;/h2&gt;
&lt;p&gt;在介绍Spring Cloud Config之前，我们可以先凭空想一下一个配置中心需要提供的核心功能有哪些：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;提供客户端和服务端的支持&lt;/li&gt;
&lt;li&gt;提供各个环境的配置&lt;/li&gt;
&lt;li&gt;配置文件修改后可以快速生效&lt;/li&gt;
&lt;li&gt;可以提供不同版本的管理&lt;/li&gt;
&lt;li&gt;可以支持不同的语言（java、.Net、Delphi、node等）&lt;/li&gt;
&lt;li&gt;支持一定数量的并发&lt;/li&gt;
&lt;li&gt;高可用（防止意外宕机导致配置不可用）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Spring Cloud Config项目是一个解决分布式系统的配置管理方案。它包含了Client和Server两个部分，server提供配置文件的存储、以接口的形式将配置文件的内容提供出去，client通过接口获取数据、并依据此数据初始化自己的应用。Spring cloud使用git或svn存放配置文件，默认情况下使用git，我们先以git为例做一套示例。&lt;/p&gt;
&lt;p&gt;首先在github上面创建了一个文件夹springcloud-config用来存放配置文件，为了模拟生产环境，我们创建以下三个配置文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 开发环境
springcloud-config-dev.properties
// 测试环境
springcloud-config-test.properties
// 生产环境
springcloud-config-pro.properties&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;每个配置文件中都写一个属性springcloud.hello,属性值分别是 hello dev/test/pro。下面我们开始配置server端&lt;/p&gt;
&lt;h2 id=&quot;server端&quot;&gt;2. Server端&lt;/h2&gt;
&lt;h3 id=&quot;pom.xml&quot;&gt;1. pom.xml&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;
    &amp;lt;parent&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;2.1.6.RELEASE&amp;lt;/version&amp;gt;
        &amp;lt;relativePath/&amp;gt; &amp;lt;!-- lookup parent from repository --&amp;gt;
    &amp;lt;/parent&amp;gt;
    &amp;lt;groupId&amp;gt;com.springcloud&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;config-server&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;name&amp;gt;config-server&amp;lt;/name&amp;gt;
    &amp;lt;description&amp;gt;Demo project for Spring Boot&amp;lt;/description&amp;gt;

    &amp;lt;properties&amp;gt;
        &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt;
        &amp;lt;spring-cloud.version&amp;gt;Greenwich.SR1&amp;lt;/spring-cloud.version&amp;gt;
    &amp;lt;/properties&amp;gt;

    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-cloud-config-server&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;

    &amp;lt;dependencyManagement&amp;gt;
        &amp;lt;dependencies&amp;gt;
            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-cloud-dependencies&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;${spring-cloud.version}&amp;lt;/version&amp;gt;
                &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt;
                &amp;lt;scope&amp;gt;import&amp;lt;/scope&amp;gt;
            &amp;lt;/dependency&amp;gt;
        &amp;lt;/dependencies&amp;gt;
    &amp;lt;/dependencyManagement&amp;gt;

    &amp;lt;build&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt;

&amp;lt;/project&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;配置文件&quot;&gt;2. 配置文件&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;server:
  port: 8080
spring:
  application:
    name: spring-cloud-config-server
  cloud:
    config:
      server:
        git:
          uri: https://github.com/meteor1993/SpringCloudLearning # git仓库的地址
          search-paths: chapter6/springcloud-config  # git仓库地址下的相对地址，可以配置多个，用,分割。
          username: #Git仓库用户名
          password: #Git仓库密码&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Spring Cloud Config也提供本地存储配置的方式。我们只需要设置属性spring.profiles.active=native，Config Server会默认从应用的src/main/resource目录下检索配置文件。也可以通过spring.cloud.config.server.native.searchLocations=file:E:/properties/属性来指定配置文件的位置。虽然Spring Cloud Config提供了这样的功能，但是为了支持更好的管理内容和版本控制的功能，还是推荐使用git的方式。&lt;/p&gt;
&lt;h3 id=&quot;启动类-configserverapplication&quot;&gt;3. 启动类 ConfigServerApplication&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;package com.springcloud.configserver;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.config.server.EnableConfigServer;

@SpringBootApplication
@EnableConfigServer
public class ConfigServerApplication {

    public static void main(String[] args) {
        SpringApplication.run(ConfigServerApplication.class, args);
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;增加@EnableConfigServer注解，激活对配置中心的支持&lt;/p&gt;
&lt;h3 id=&quot;测试&quot;&gt;4. 测试&lt;/h3&gt;
&lt;p&gt;首先测试我们的server端能否从github上获取到我们需要的信息，直接访问：http://localhost:8080/springcloud-config/pro， &lt;strong&gt;注意：&lt;/strong&gt; springcloud-config是文件夹的前缀命名，可以看到如下结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
    &quot;name&quot;:&quot;springcloud-config&quot;,
    &quot;profiles&quot;:[
        &quot;pro&quot;
    ],
    &quot;label&quot;:null,
    &quot;version&quot;:&quot;4e3d1a93e869fb336254c480ed1e5b36d58124aa&quot;,
    &quot;state&quot;:null,
    &quot;propertySources&quot;:[
        {
            &quot;name&quot;:&quot;https://github.com/meteor1993/SpringCloudLearning/chapter6/springcloud-config/springcloud-config-pro.properties&quot;,
            &quot;source&quot;:{
                &quot;springcloud.hello&quot;:&quot;hello pro&quot;
            }
        }
    ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述的返回的信息包含了配置文件的位置、版本、配置文件的名称以及配置文件中的具体内容，说明server端已经成功获取了git仓库的配置信息。&lt;/p&gt;
&lt;p&gt;如果直接查看配置文件中的配置信息可访问：http://localhost:8080/springcloud-config-dev.properties， 返回：springcloud.hello: hello dev&lt;/p&gt;
&lt;p&gt;修改配置文件springcloud-config-dev.properties中配置信息为：springcloud.hello=hello dev update，再次在浏览器访问http://localhost:8080/springcloud-config-dev.properties，返回：springcloud.hello: hello dev update。说明server端会自动读取自动提交功能。&lt;/p&gt;
&lt;p&gt;仓库中的配置文件会被转换成web接口，访问可以参照以下的规则：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;/{application}/{profile}[/{label}]&lt;/li&gt;
&lt;li&gt;/{application}-{profile}.yml&lt;/li&gt;
&lt;li&gt;/{label}/{application}-{profile}.yml&lt;/li&gt;
&lt;li&gt;/{application}-{profile}.properties&lt;/li&gt;
&lt;li&gt;/{label}/{application}-{profile}.properties&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以springcloud-config-dev.properties为例，它的application是springcloud-config，profile是dev，label是分支的意思，如果只有一个主分支，可以不写，默认会访问master分支，client会根据填写的参数来选择读取对应的配置。&lt;/p&gt;
&lt;h2 id=&quot;client端&quot;&gt;3. client端&lt;/h2&gt;
&lt;p&gt;主要展示如何在业务项目中去获取server端的配置信息。&lt;/p&gt;
&lt;h3 id=&quot;pom.xml-1&quot;&gt;1. pom.xml&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;
    &amp;lt;parent&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;2.1.6.RELEASE&amp;lt;/version&amp;gt;
        &amp;lt;relativePath/&amp;gt; &amp;lt;!-- lookup parent from repository --&amp;gt;
    &amp;lt;/parent&amp;gt;
    &amp;lt;groupId&amp;gt;com.springcloud&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;config-client&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;name&amp;gt;config-client&amp;lt;/name&amp;gt;
    &amp;lt;description&amp;gt;Demo project for Spring Boot&amp;lt;/description&amp;gt;

    &amp;lt;properties&amp;gt;
        &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt;
        &amp;lt;spring-cloud.version&amp;gt;Greenwich.SR1&amp;lt;/spring-cloud.version&amp;gt;
    &amp;lt;/properties&amp;gt;

    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-cloud-starter-config&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;

    &amp;lt;dependencyManagement&amp;gt;
        &amp;lt;dependencies&amp;gt;
            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-cloud-dependencies&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;${spring-cloud.version}&amp;lt;/version&amp;gt;
                &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt;
                &amp;lt;scope&amp;gt;import&amp;lt;/scope&amp;gt;
            &amp;lt;/dependency&amp;gt;
        &amp;lt;/dependencies&amp;gt;
    &amp;lt;/dependencyManagement&amp;gt;

    &amp;lt;build&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt;

&amp;lt;/project&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;配置文件-1&quot;&gt;2. 配置文件&lt;/h3&gt;
&lt;p&gt;这里配置文件分两个，application.yml和bootstrap.properties&lt;/p&gt;
&lt;p&gt;application.yml如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;server:
  port: 8081
spring:
  application:
    name: spring-cloud-config-client&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;bootstrap.properties如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;spring.cloud.config.name=springcloud-config
spring.cloud.config.profile=dev
spring.cloud.config.uri=http://localhost:8080/
spring.cloud.config.label=master&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;spring.application.name：对应{application}部分&lt;/li&gt;
&lt;li&gt;spring.cloud.config.profile：对应{profile}部分&lt;/li&gt;
&lt;li&gt;spring.cloud.config.label：对应git的分支。如果配置中心使用的是本地存储，则该参数无用&lt;/li&gt;
&lt;li&gt;spring.cloud.config.uri：配置中心的具体地址&lt;/li&gt;
&lt;li&gt;spring.cloud.config.discovery.service-id：指定配置中心的service-id，便于扩展为高可用配置集群。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;注意：上面这些与spring-cloud相关的属性必须配置在bootstrap.properties中，config部分内容才能被正确加载。因为config的相关配置会先于application.properties，而bootstrap.properties的加载也是先于application.yml。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;启动类&quot;&gt;3. 启动类&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;package com.springcloud.configclient;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class ConfigClientApplication {

    public static void main(String[] args) {
        SpringApplication.run(ConfigClientApplication.class, args);
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动类只需要@SpringBootApplication注解就可以，常规操作。&lt;/p&gt;
&lt;h3 id=&quot;访问类&quot;&gt;4. 访问类&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;package com.springcloud.configclient.controller;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * @Author: shiyao.wei
 * @Date: 2019/7/4 16:19
 * @Version: 1.0
 * @Desc:
 */
@RestController
public class HelloController {

    @Value(&quot;${springcloud.hello}&quot;)
    private String hello;

    @RequestMapping(&quot;/hello&quot;)
    public String from() {
        return this.hello;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用@Value注解来获取server端参数的值&lt;/p&gt;
&lt;h3 id=&quot;测试-1&quot;&gt;5. 测试&lt;/h3&gt;
&lt;p&gt;启动client端，访问链接：http://localhost:8081/hello， 返回：hello dev update，说明已经正确的从server端获取到了参数。到此一个完整的服务端提供配置服务，客户端获取配置参数的例子就完成了。&lt;/p&gt;
&lt;p&gt;可以再进行一个小实验，我们再次修改springcloud-config-dev.properties中的内容为：hello dev update1，提交至github后，再次访问http://localhost:8081/hello，可以发现，返回的内容还是hello dev update，这是为什么呢？因为springboot项目只有在启动的时候才会获取配置文件的值，修改github信息后，client端并没有在次去获取，所以导致这个问题。如何去解决这个问题呢？留到下一篇我们在介绍。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/meteor1993/SpringCloudLearning/tree/master/chapter6&quot; title=&quot;示例代码-Github&quot;&gt;示例代码-Github&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;参考：http://www.ityouknow.com/springcloud/2017/05/22/springcloud-config-git.html&lt;/p&gt;
</description>
<pubDate>Sat, 06 Jul 2019 00:42:00 +0000</pubDate>
<dc:creator>极客挖掘机</dc:creator>
<og:description>SpringCloud系列教程 | 第六篇：Spring Cloud Config Github配置中心 Springboot: 2.1.6.RELEASE SpringCloud: Greenwic</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/babycomeon/p/11134717.html</dc:identifier>
</item>
<item>
<title>命令行解析函数 - 凌逆战</title>
<link>http://www.cnblogs.com/LXP-Never/p/11093896.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/LXP-Never/p/11093896.html</guid>
<description>&lt;p&gt;&lt;span&gt;在终端运行python 1.py hahah&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; sys 

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(sys.argv)    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; ['1.py', 'hahah']&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;　　Python的命令行解析模块，这是一个python的内置库，通过在程序中我们定义好的参数，argparse将会从sys.argv中解析出这些参数，并自动生成帮助和使用信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;argparse的简单使用&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;创建ArgumentParser()对象&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;调用add_argument()方法添加参数&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;使用parse_args()解析添加的参数&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; argparse

parser &lt;/span&gt;=&lt;span&gt; argparse.ArgumentParser()
parser.add_argument(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;integer&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, type=int, help=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;display an integer&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
args &lt;/span&gt;=&lt;span&gt; parser.parse_args()

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(args.integer)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;将上面的代码保存为文件 &lt;code&gt;argparse_usage.py&lt;/code&gt;，在终端运行，结果如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;$&lt;/span&gt; python argparse_usage.py
　　usage: argparse_usage.py [&lt;/span&gt;-&lt;span&gt;h] integer
　　argparse_usage.py: error: too few arguments

&lt;span&gt;$&lt;/span&gt; python argparse_usage.py abcd
　　usage: argparse_usage.py [&lt;/span&gt;-&lt;span&gt;h] integer
　　argparse_usage.py: error: argument integer: invalid int value: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;abcd&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&lt;span&gt;

$&lt;/span&gt; python argparse_usage.py &lt;/span&gt;-&lt;span&gt;h
　　usage: argparse_usage.py [&lt;/span&gt;-&lt;span&gt;h] integer

　　positional arguments:
  　　integer     display an integer

　　optional arguments:
  　　&lt;/span&gt;-h, --help  show this help message &lt;span&gt;and&lt;/span&gt;&lt;span&gt; exit

&lt;span&gt;$&lt;/span&gt; python argparse_usage.py &lt;/span&gt;10
　　10
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;定位参数&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; argparse

parser &lt;/span&gt;=&lt;span&gt; argparse.ArgumentParser()
parser.add_argument(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;square&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, help=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;display a square of a given number&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, type=&lt;span&gt;int)
args &lt;/span&gt;=&lt;span&gt; parser.parse_args()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(args.square**2)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;将上面的代码保存为文件 &lt;code&gt;argparse_usage.py&lt;/code&gt;，在终端运行，结果如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$&lt;/span&gt; python argparse_usage.py 9
　　81
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;可选参数&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;可选参数就是命令行参数是可选的&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; argparse

parser &lt;/span&gt;=&lt;span&gt; argparse.ArgumentParser()

parser.add_argument(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--square&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, help=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;display a square of a given number&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, type=&lt;span&gt;int)
parser.add_argument(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--cubic&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, help=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;display a cubic of a given number&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, type=&lt;span&gt;int)

args &lt;/span&gt;=&lt;span&gt; parser.parse_args()

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; args.square:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; args.square**2

&lt;span&gt;if&lt;/span&gt;&lt;span&gt; args.cubic:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; args.cubic**3
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;将上面的代码保存为文件 &lt;code&gt;argparse_usage.py&lt;/code&gt;，在终端运行，结果如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$&lt;/span&gt; python argparse_usage.py --&lt;span&gt;h
　　usage: argparse_usage.py [&lt;/span&gt;-h] [--square SQUARE] [--&lt;span&gt;cubic CUBIC]

　　optional arguments:
  　　&lt;/span&gt;-h, --help       show this help message &lt;span&gt;and&lt;/span&gt;&lt;span&gt; exit
  　　&lt;/span&gt;--&lt;span&gt;square SQUARE  display a square of a given number
  　　&lt;/span&gt;--&lt;span&gt;cubic CUBIC    display a cubic of a given number

&lt;span&gt;$&lt;/span&gt; python argparse_usage.py &lt;/span&gt;--square 8
　　　　64&lt;span&gt;&lt;span&gt;

$&lt;/span&gt; python argparse_usage.py &lt;/span&gt;--cubic 8
　　　　512&lt;span&gt;&lt;span&gt;

$&lt;/span&gt; python argparse_usage.py &lt;/span&gt;8&lt;span&gt;
　　　　usage: argparse_usage.py [&lt;/span&gt;-h] [--square SQUARE] [--&lt;span&gt;cubic CUBIC]
　　　　argparse_usage.py: error: unrecognized arguments: &lt;/span&gt;8&lt;span&gt;&lt;span&gt;

$&lt;/span&gt; python argparse_usage.py  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 没有输出&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;混合使用&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;定位参数和选项参数可以混合使用，看下面一个例子，给一个整数序列，输出它们的和或最大值（默认）：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; argparse

parser &lt;/span&gt;= argparse.ArgumentParser(description=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Process some integers.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
parser.add_argument(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;integers&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, metavar=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;N&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, type=int, nargs=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                   help&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;an integer for the accumulator&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
parser.add_argument(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;--sum&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, dest=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;accumulate&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, action=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;store_const&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                   const&lt;/span&gt;=sum, default=&lt;span&gt;max,
                   help&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sum the integers (default: find the max)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

args &lt;/span&gt;=&lt;span&gt; parser.parse_args()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(args.accumulate(args.integers))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;将上面的代码保存为文件 &lt;code&gt;argparse_usage.py&lt;/code&gt;，在终端运行，结果如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;$&lt;/span&gt; python argparse_usage.py
　　usage: argparse_usage.py [&lt;/span&gt;-h] [--&lt;span&gt;sum] N [N ...]
　　argparse_usage.py: error: too few arguments
&lt;span&gt;$&lt;/span&gt; python argparse_usage.py &lt;/span&gt;1 2 3 4
　　4&lt;span&gt;&lt;span&gt;
$&lt;/span&gt; python argparse_usage.py &lt;/span&gt;1 2 3 4 --&lt;span&gt;sum
　　&lt;/span&gt;10
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;add_argument()方法&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
ArgumentParser.add_argument(name &lt;span&gt;or&lt;/span&gt; flags...[, action][, nargs][, const][, default][, type][, choices][, required][, help][, metavar][, dest])
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;每个参数解释如下:&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;name or flags - 选项字符串的名字或者列表，例如 foo 或者 -f, --foo。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;action - 命令行遇到参数时的动作，默认值是 store。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;store_const，表示赋值为const；store_ture/store_false。详情见下面。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;store_const，表示赋值为const；store_ture/store_false。详情见下面。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;append，将遇到的值存储成列表，也就是如果参数重复则会保存多个值;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;append_const，将参数规范中定义的一个值保存到一个列表；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;count，存储遇到的次数；此外，也可以继承 argparse.Action 自定义参数解析；&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;const - action 和 nargs 所需要的常量值。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;nargs - 应该读取的命令行参数个数，可以是具体的数字，或者是?号，当不指定值时对于 Positional argument 使用 default，对于 Optional argument 使用 const；或者是 * 号，表示 0 或多个参数；或者是 + 号表示 1 或多个参数。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;default - 不指定参数时的默认值。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;type - 命令行参数应该被转换成的类型。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;choices - 参数可允许的值的一个容器。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;required - 可选参数是否可以省略 (仅针对可选参数)。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;help - 参数的帮助信息，当指定为&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;code&gt;argparse.SUPPRESS&lt;/code&gt;&lt;/span&gt;&lt;span&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; 时表示不显示该参数的帮助信息.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;metavar - 在 usage 说明中的参数名称，对于必选参数默认就是参数名称，对于可选参数默认是全大写的参数名称.&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;dest - 解析后的参数名称，默认情况下，对于可选参数选取最长的名称，中划线转换为下划线.&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; argparse

parser &lt;/span&gt;=&lt;span&gt; argparse.ArgumentParser()
parser.add_argument(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;--inter&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, action=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;store_true&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
args &lt;/span&gt;=&lt;span&gt; parser.parse_args()

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(args.interpolate)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;在命令行运行&lt;span&gt;python temp.py&lt;/span&gt;     　　 　　args.interpolate是False&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在命令行运行&lt;span&gt;python temp.py --inter&lt;/span&gt;　　　　　args.interpolate是True&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://blog.csdn.net/leiting_imecas/article/details/72367937&quot; target=&quot;_blank&quot;&gt;tensorflow 学习(三）使用flags定义命令行参数&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;1、tf.app.flags()　　# 他支持应用从命令行接受参数在tf.app.flags中有下列定义参数的类型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;DEFING_string(flag_name, default_value, docstring)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;DEFING_integer(flag_name, default_value, docstring)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;DEFING_boolean(flag_name, default_value, docstring)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;DEFING_float(flag_name, default_value, docstring)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、tf.app.flags,在flag有一个FLAGS标志，他在程序中可以调用我们前面定义的flag_name,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、通过tf.app.run()启动maini(argv)函数&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
tf.app.flags.DEFINE_integer(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;max_step&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, 0, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;训练模型的步数&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
tf.app.flads.DEFINE_string(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;model_dir&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;模型保存的路径+模型名&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
FLAGS &lt;/span&gt;= tf.app.flags.FLAGS　　&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 定义命令行参数&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(FLAGS.max_step)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(FLAGS.model_dir)
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; main(argv):
　　&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(argv)
tf.app.run()　　&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 启动main函数&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sat, 06 Jul 2019 00:34:00 +0000</pubDate>
<dc:creator>凌逆战</dc:creator>
<og:description>sys.argv 在终端运行python 1.py hahah argparse Python的命令行解析模块，这是一个python的内置库，通过在程序中我们定义好的参数，argparse将会从sys</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/LXP-Never/p/11093896.html</dc:identifier>
</item>
<item>
<title>一文学会Java死锁和CPU 100% 问题的排查技巧 - 阿飞云</title>
<link>http://www.cnblogs.com/aflyun/p/11141369.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/aflyun/p/11141369.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;做一个积极的人&lt;/p&gt;
&lt;p&gt;编码、改bug、提升自己&lt;/p&gt;
&lt;p&gt;我有一个乐园，面向编程，春暖花开&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;工欲善其事，必先利其器&lt;/span&gt;&lt;/p&gt;


&lt;h3 id=&quot;00&quot;&gt;00 本文简介&lt;/h3&gt;
&lt;p&gt;作为一名搞技术的程序猿或者是攻城狮，想必你应该是对下面这两个问题有所了解，说不定你在实际的工作或者面试就有遇到过：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一个问题：Java死锁如何排查和解决？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二个问题：服务器CPU占用率高达到100%排查和解决？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第三个问题：有哪些工具能够快速查看线程使用情况？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本文对这三个问题进行总结整理，通过实例演示讲解，精彩干货，不容错过啊！&lt;/p&gt;
&lt;p&gt;前戏就这么多，高潮会很多，做好了，让我们直奔主题，发动小船，Let's go！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190704132046575.gif&quot; alt=&quot;小船&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;01java&quot;&gt;01 Java死锁排查和解决&lt;/h3&gt;
&lt;p&gt;要排查和解决死锁，首先思考三个问题：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 什么是死锁？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 为什么会出现死锁？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 怎么排查代码中出现了死锁？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. 如何避免写出死锁的代码？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;作为技术人员（工程师），在出现问题的时候，能够尽快的去解决这个问题。但是在学习技术知识的时候，还是脚踏实地，多问一些为什么，一个好的问题，能够让自己思考，这方面的能力也一定要锻炼锻炼哦，这样才能更好的理解和掌握知识，并探究/触碰到更深入的地方。&lt;/p&gt;
&lt;h4 id=&quot;1&quot;&gt;1、啥是死锁？&lt;/h4&gt;
&lt;p&gt;死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。[百度百科：死锁]&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180617222821998?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA2NDg1NTU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;死锁图示&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注：进程和线程都可以发生死锁，只要满足死锁的条件！&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;2&quot;&gt;2、为啥子会出现死锁？&lt;/h4&gt;
&lt;p&gt;从上面的概念中我们知道&lt;/p&gt;
&lt;p&gt;（1）必须是两个或者两个以上进程（线程）&lt;/p&gt;
&lt;p&gt;（2）必须有竞争资源&lt;/p&gt;
&lt;h4 id=&quot;3&quot;&gt;3、怎么排查代码中出现了死锁？【重点来了】&lt;/h4&gt;
&lt;p&gt;首先整一个死锁的代码，看例子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190705220318217.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hZmx5dW4uYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70&quot; alt=&quot;死锁小demo&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面这段代码执行后，就会出现死锁，那么排查的方法有如下：&lt;/p&gt;
&lt;h4 id=&quot;jpsjstack&quot;&gt;第一个姿势：使用 jps + jstack&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;一&lt;/strong&gt;：在windons命令窗口，使用&lt;code&gt;jps -l&lt;/code&gt;【不会使用jps请自行查询资料】&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180617224314653?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA2NDg1NTU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;jps -l 命令&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二&lt;/strong&gt;：使用 &lt;code&gt;jstack -l 12316&lt;/code&gt; 【不会使用jstack请自行查询资料】&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180617224419971?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA2NDg1NTU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;jstack&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;jconsole&quot;&gt;第二个姿势：使用jconsole&lt;/h4&gt;
&lt;p&gt;在window打开 JConsole，JConsole是一个图形化的监控工具！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一&lt;/strong&gt;：在windons命令窗口 ，输出 &lt;code&gt;JConsole&lt;/code&gt;，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180617224721820?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA2NDg1NTU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二&lt;/strong&gt;：选择到线程的tab上，如下截图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180617225004261?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA2NDg1NTU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;javavisualvm&quot;&gt;第三个姿势：使用Java Visual VM&lt;/h4&gt;
&lt;p&gt;在window打开 jvisualvm，jvisualvm是一个图形化的监控工具！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一&lt;/strong&gt;：在windons命令窗口 ，输出 &lt;code&gt;jvisualvm&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180617225253701?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA2NDg1NTU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;Java Visual VM&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二&lt;/strong&gt;：依然是切换到线程这个TAB上，很明显的就有提示！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180617225315495?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA2NDg1NTU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;死锁检测&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;4&quot;&gt;4、如何避免死锁？&lt;/h4&gt;
&lt;p&gt;上面说了死锁出现的原因以及通过三种方式来检测和排查死锁，下面更重要的东西来了，就是如何避免死锁，如果能够让写出的代码避免死锁出现也就没有上面这些排查的过程了。最好的是从源头控制问题，而不是后期遇到问题在去填坑。&lt;/p&gt;
&lt;p&gt;我看了阿里巴巴中最新的开发规约，里面有对避免死锁的说明，具体如下：&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;【强制】&lt;/span&gt;对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会 造成死锁。 说明：线程一需要对表 A、B、C 依次全部加锁后才可以进行更新操作，那么线程二的加锁顺序也必须是 A、B、C，否则可能出现死锁。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;02javacpu100&quot;&gt;02、Java CPU 100% 排查技巧&lt;/h3&gt;
&lt;h4 id=&quot;&quot;&gt;第一个姿势，步骤有点多，难度四星&lt;/h4&gt;
&lt;p&gt;平时多积累一点，这样在遇到问题的时候就少句求人的话。如果在实际的开发中遇到CPU 100%问题，要怎么排查呢？如果你没有遇到过这个问题，请先自己思考10s，如果你遇到过，这个时候也正好可以在回顾一遍。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一&lt;/strong&gt;、 使用&lt;code&gt;top&lt;/code&gt;命令查看cpu占用资源较高的PID&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180617225946794?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA2NDg1NTU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;top命令&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当前占用cup100% 的PID为3455。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二&lt;/strong&gt;、通过&lt;code&gt;jps&lt;/code&gt;找到当前用户下的java程序PID&lt;/p&gt;
&lt;p&gt;执行&lt;code&gt;jps -l&lt;/code&gt;能够打印出所有的应用的PID，找到有一个PID和这个cpu使用100%一样的ID！！！就知道是哪一个服务了。知道了对应的服务，在接着后续的分析步骤。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三&lt;/strong&gt;、 使用 &lt;code&gt;pidstat -p &amp;lt; PID &amp;gt; 1 3 -u -t&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;shell language-shell hljs&quot;&gt;-p：指定进程号
-u：默认的参数，显示各个进程的cpu使用统计
-t：显示选择任务的线程的统计信息外的额外信息
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180621164230418?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA2NDg1NTU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180617230647320?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA2NDg1NTU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;四&lt;/strong&gt;、找到cpu占用较高的线程TID ，通过上图发现是 &lt;code&gt;3467&lt;/code&gt;的TID占用cup较大&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;五&lt;/strong&gt;、 因为jstack命令输出文件记录的线程ID是16进制。因此我们先将TID转换为十六进制的表示方式，转换方式可以参考下图。&lt;/p&gt;
&lt;p&gt;将&lt;code&gt;3467&lt;/code&gt;转为十六进制 &lt;code&gt;d8d&lt;/code&gt;，注意是小写！! 记录下来，后面会使用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180617231206817?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA2NDg1NTU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;巧转进制&quot;/&gt;&lt;strong&gt;六&lt;/strong&gt;、通过&lt;code&gt;jstack [-l] PID&lt;/code&gt;输出当前进程的线程信息&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;shell language-shell hljs&quot;&gt;jstack PID  /temp/test.log
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;七&lt;/strong&gt;、查找 TID对应的线程(输出的线程id为十六进制)，找到对应的代码，使用命令查找哦，不要肉眼比对，具体命令请思考，给你表现机会。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180617230519477?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA2NDg1NTU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;查找&quot;/&gt;&lt;/p&gt;
&lt;p&gt;找到之后具体分析这个线程在干什么，为什么会占用这么多的 CUP资源。&lt;/p&gt;
&lt;p&gt;PS：线程的几种状态如下说明：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;log language-log&quot;&gt;NEW,未启动的。不会出现在Dump中。
RUNNABLE,在虚拟机内执行的。
BLOCKED,受阻塞并等待监视器锁。
WATING,无限期等待另一个线程执行特定操作。
TIMED_WATING,有时限的等待另一个线程的特定操作。
TERMINATED,已退出的。
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;-1&quot;&gt;第二个姿势，待开发[奸笑脸]&lt;/h4&gt;
&lt;p&gt;此处省略……，好多字。&lt;/p&gt;
&lt;h3 id=&quot;03&quot;&gt;03 推荐两个高效排查问题工具&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;一&lt;/strong&gt; ：&lt;code&gt;show-busy-java-threads&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190705230614816.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hZmx5dW4uYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;官网地址：&lt;a href=&quot;https://github.com/oldratlee/useful-scripts/blob/master/docs/java.md#-show-busy-java-threads&quot;&gt;show-busy-java-threads&lt;/a&gt;： https://github.com/oldratlee/useful-scripts/blob/master/docs/java.md#-show-busy-java-threads&lt;/p&gt;
&lt;p&gt;简单安装和使用过程：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;下载 &lt;a href=&quot;https://download.csdn.net/download/u010648555/10568140&quot;&gt;show-busy-java-threads&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;上传服务器，然后进行解压&lt;/li&gt;
&lt;li&gt;然后执行对应的命令&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180727154001709?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA2NDg1NTU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二&lt;/strong&gt;：阿里开源的问题定位神器 &lt;code&gt;arthas&lt;/code&gt; 来定位问题。&lt;/p&gt;
&lt;p&gt;官网地址：&lt;a href=&quot;https://alibaba.github.io/arthas/index.html&quot;&gt;arthas&lt;/a&gt; ：https://alibaba.github.io/arthas/index.html&lt;/p&gt;
&lt;p&gt;这个里面有很多命令，如&lt;code&gt;thread&lt;/code&gt; 支持一键展示当前最忙的前N个线程并打印堆栈，最简单的 &lt;code&gt;thread -n 10&lt;/code&gt; 即可将最忙碌的十个线程快照打印出来，真正高效。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2019070523070958.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hZmx5dW4uYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;定位神器 &lt;code&gt;arthas&lt;/code&gt; 安装过程就做介绍了，如果你还没有用过这个工具，我建议一定去用一下，说不定你会爱上它！&lt;/p&gt;
&lt;h3 id=&quot;04&quot;&gt;04 总结&lt;/h3&gt;
&lt;p&gt;本文内容比较多，基本上是手把手的教程了，希望能够对你有所帮助，也建议没有遇到类似问题的伙伴，看完之后一定要亲自去实践一下操作过程，如果没有环境可以自行想办法搞一个测试例子。还是老话：&lt;strong&gt;不要眼高手低，看了和做了本质上两个概念，最终收获的也一定不同。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;05&quot;&gt;05 彩蛋-另一个姿势&lt;/h3&gt;
&lt;p&gt;也可以通过使用&lt;code&gt;jstack&lt;/code&gt;找到系统的代码性能问题&lt;/p&gt;
&lt;p&gt;1、在进行压力测试的时候，使用jps找到应用的PID&lt;/p&gt;
&lt;p&gt;2、然后使用&lt;code&gt;jstack&lt;/code&gt;输出出压力测试时候应用的dump信息&lt;/p&gt;
&lt;p&gt;3、分析输出的日志文件中那个方法&lt;code&gt;block&lt;/code&gt;线程占用最多，这里可能是性能有问题，找到对应的代码分析&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;谢谢你的阅读，如果您觉得这篇博文对你有帮助，请点赞或者喜欢，让更多的人看到！祝你每天开心愉快！&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;strong&gt;不管做什么，只要坚持下去就会看到不一样！在路上，不卑不亢!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://aflyun.blog.csdn.net/&quot;&gt; &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;愿你我在人生的路上能都变成最好的自己，能够成为一个独挡一面的人&lt;/strong&gt;&lt;img src=&quot;http://dufyun.gitee.io/images_bed/images/life/qrcode_javaCoder.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;© 每天都在变得更好的阿飞云&lt;/p&gt;
</description>
<pubDate>Fri, 05 Jul 2019 16:18:00 +0000</pubDate>
<dc:creator>阿飞云</dc:creator>
<og:description>手把手的排查教程，更有实际的案例操作，真正带你掌握排查技巧，值得学习！</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/aflyun/p/11141369.html</dc:identifier>
</item>
<item>
<title>自己挖的坑跪着也要填完---mapper配置文件和java源文件在同一包下 - 白露非霜</title>
<link>http://www.cnblogs.com/nijunyang/p/11141344.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nijunyang/p/11141344.html</guid>
<description>&lt;p&gt;本来准备研究下mybatis源码执行流程的，就随意搭建了个项目，所有配置如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1216484/201907/1216484-20190705233130136-1974534566.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1216484/201907/1216484-20190705233229929-1640568042.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;一切看似都是那么的正常，然而执行的时候：Exception in thread &quot;main&quot; org.apache.ibatis.binding.BindingException: Invalid bound statement (not found): com.nijunyang.mybatis.mapper.UserMapper.insertUser&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1216484/201907/1216484-20190705233330107-1806154062.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 1.发现org.apache.ibatis.session.Configuration#mappedStatements始终是空的，等于说mapper文件的类容根本没有被加载解析&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1216484/201907/1216484-20190705233503034-608792676.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2.org.apache.ibatis.builder.annotation.MapperAnnotationBuilder#loadXmlResource加载xml根本没有加载到&lt;/p&gt;
&lt;p&gt;3.文件路径看似都是对的，但是却加载不到文件流org.apache.ibatis.io.Resources#getResourceAsStream(java.lang.ClassLoader, java.lang.String)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1216484/201907/1216484-20190705234134285-1091402799.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1216484/201907/1216484-20190705234423569-1278509456.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;各种找问题，以为是名字不对等等，重新写各项配置，结果还是不行。最后恍然大悟，这配置文件是用classloader加载的，遂检查jar包（class目录）发现mapper.xml文件根本没有编译进去，再看pom文件，资源文件的打包配置空空如也。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1216484/201907/1216484-20190706000123379-777515457.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;所以看似正常的xml文件路径，实则并不正常，因为在jar/class里面并没有将配置文件打进去&lt;/p&gt;
&lt;p&gt; &lt;span&gt;&lt;strong&gt;&lt;span&gt;因此在源文件包里面写配置，pom文件一定要注意加上打包资源的配置&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;因此在源文件包里面写配置，pom文件一定要注意加上打包资源的配置&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;因此在源文件包里面写配置，pom文件一定要注意加上打包资源的配置&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;默认的编译只会将java源文件编译出来的class文件打包走，而不会打包其他文件，撸上&amp;lt;&lt;span&gt;resources&amp;gt;节点万事大吉&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1216484/201907/1216484-20190705235837435-103213701.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 05 Jul 2019 16:06:00 +0000</pubDate>
<dc:creator>白露非霜</dc:creator>
<og:description>本来准备研究下mybatis源码执行流程的，就随意搭建了个项目，所有配置如下： 一切看似都是那么的正常，然而执行的时候：Exception in thread &quot;main&quot; org</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/nijunyang/p/11141344.html</dc:identifier>
</item>
<item>
<title>基于百度云的OCR识别（Python） - 东小东</title>
<link>http://www.cnblogs.com/dongxiaodong/p/11140680.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dongxiaodong/p/11140680.html</guid>
<description>&lt;p&gt;2019年7月3日早上，在百度AI开发者大会上，一个来自山西的青年，将一瓶矿泉水浇在了同样来自山西的李彦宏身上。&lt;/p&gt;
&lt;p&gt;可以回顾一下 https://b23.tv/av57665929/p1 ，着实让人一惊，这么大的会议上既然让人这么容易接近大佬。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485202/201907/1485202-20190705192829889-1116947320.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（图片来源网络）&lt;/p&gt;
&lt;h2&gt;OCR识别准备工作&lt;/h2&gt;
&lt;p&gt;百度云真的是测试接口的天堂，免费接口很多，当然有量的限制，但个人使用是完全够用的，什么人脸识别、MQTT服务器、语音识别等等，应有尽有吧&lt;/p&gt;
&lt;p&gt;看看OCR识别免费的量&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485202/201907/1485202-20190705194326287-980567175.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一步：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;创建一个文字识别的应用，也就是向百度云申请一个文字识别的用户接口&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1485202/201907/1485202-20190705194654336-658084962.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二步：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;打开技术文档，基本涵盖了当今流行的编程语言&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://cloud.baidu.com/doc/OCR/s/ejwvxzls6/&quot;&gt;https://cloud.baidu.com/doc/OCR/s/ejwvxzls6/&lt;/a&gt;&lt;/p&gt;
&lt;p id=&quot;安装ocr-python-sdk&quot;&gt;&lt;strong&gt;第三步：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;安装OCR Python SDK，OCR Python SDK目录结构&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;language-text line-numbers&quot;&gt;
&lt;code class=&quot;language-text&quot;&gt;├── README.md
├── aip                   //SDK目录
│   ├── __init__.py       //导出类
│   ├── base.py           //aip基类
│   ├── http.py           //http请求
│   └── ocr.py //OCR
└── setup.py              //setuptools安装&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;支持Python版本：2.7.+ ,3.+&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;安装命令：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在win10环境下通过cmd安装后需要关掉当前cmd窗口，重新打开cmd窗口进行命令执行python程序方可正确实现&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
pip install baidu-aip
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;strong&gt;测试代码&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485202/201907/1485202-20190705210445649-2093672772.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485202/201907/1485202-20190705210502493-27142961.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通用文字识别&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; aip &lt;span&gt;import&lt;/span&gt;&lt;span&gt; AipOcr

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;更换为自己的注册信息&lt;/span&gt;
APP_ID = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;---&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
API_KEY &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;---&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
SECRET_KEY &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;---&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

client &lt;/span&gt;= AipOcr(APP_ID, API_KEY, SECRET_KEY)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建连接&lt;/span&gt;
fp=open(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tu2.png&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;rb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).read()&lt;span&gt;#&lt;/span&gt;&lt;span&gt;打开并读取文件内容&lt;/span&gt;
res=client.basicGeneral(fp)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;普通&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;print(res)&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;将所有的文字都合并到一起&lt;/span&gt;
strx=&lt;span&gt;&quot;&quot;&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; tex &lt;span&gt;in&lt;/span&gt; res[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;words_result&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]:&lt;span&gt;#&lt;/span&gt;&lt;span&gt;遍历结果&lt;/span&gt;
    strx+=tex[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;words&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]#每一行
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(strx)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;输出内容&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;通用文字识别（高精度版）&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; aip &lt;span&gt;import&lt;/span&gt;&lt;span&gt; AipOcr

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;更换为自己的注册信息&lt;/span&gt;
APP_ID = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;---&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
API_KEY &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;---&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
SECRET_KEY &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;---&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

client &lt;/span&gt;= AipOcr(APP_ID, API_KEY, SECRET_KEY)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建连接&lt;/span&gt;
fp=open(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tu2.png&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;rb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).read()&lt;span&gt;#&lt;/span&gt;&lt;span&gt;打开并读取文件内容&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;res=client.basicGeneral(fp)#普通&lt;/span&gt;
res=client.basicAccurate(fp)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;高精度&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;print(res)&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;将所有的文字都合并到一起&lt;/span&gt;
strx=&lt;span&gt;&quot;&quot;&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; tex &lt;span&gt;in&lt;/span&gt; res[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;words_result&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]:&lt;span&gt;#&lt;/span&gt;&lt;span&gt;遍历结果&lt;/span&gt;
    strx+=tex[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;words&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]#每一行
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(strx)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;输出内容&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt; URL图片地址方式&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; aip &lt;span&gt;import&lt;/span&gt;&lt;span&gt; AipOcr

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;更换为自己的注册信息&lt;/span&gt;
APP_ID = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;----&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
API_KEY &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;----&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
SECRET_KEY &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;-----&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

client &lt;/span&gt;= AipOcr(APP_ID, API_KEY, SECRET_KEY)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建连接&lt;/span&gt;
url = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://img2018.cnblogs.com/blog/1485202/201907/1485202-20190705210445649-2093672772.png&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
res&lt;/span&gt;=client.basicGeneralUrl(url)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;普通&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;print(res)&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;将所有的文字都合并到一起&lt;/span&gt;
strx=&lt;span&gt;&quot;&quot;&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; tex &lt;span&gt;in&lt;/span&gt; res[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;words_result&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]:&lt;span&gt;#&lt;/span&gt;&lt;span&gt;遍历结果&lt;/span&gt;
    strx+=tex[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;words&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(strx)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;输出内容&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;注意&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;图片格式（image）：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;图像数据，base64编码，要求base64编码后大小不超过4M，最短边至少15px，最长边最大4096px,支持jpg/png/bmp格式&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;URL格式（url）：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;图片完整URL，URL长度不超过1024字节，URL对应的图片base64编码后大小不超过4M，最短边至少15px，最长边最大4096px,支持jpg/png/bmp格式，当image字段存在时url字段失效&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;语言设置（language_type）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;识别语言类型，默认为CHN_ENG&lt;/p&gt;
&lt;p&gt;可设置：- CHN_ENG：中英文混合；- ENG：英文；- POR：葡萄牙语；- FRE：法语；- GER：德语；- ITA：意大利语；- SPA：西班牙语；- RUS：俄语；- JAP：日语；- KOR：韩语；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;图像倒置设置（detect_direction）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;是否检测图像朝向，默认不检测，即：false。朝向是指输入图像是正常方向、逆时针旋转90/180/270度。可选值包括:- true：检测朝向；- false：不检测朝向&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;是否检测语言（detect_language）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;是否检测语言，默认不检测。当前支持（中文、英语、日语、韩语），值为flase或者true&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;是否返回识别结果中每一行的置信度（probability）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;值为flase或者true&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数添加举例&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt; 如果有可选参数 &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
options &lt;/span&gt;=&lt;span&gt; {}
options[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;detect_direction&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
options[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;detect_language&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt; 带参数调用网络图片文字识别, 图片参数为远程url图片 &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
client.webImageUrl(url, options)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt; 更多参考：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://cloud.baidu.com/doc/OCR/s/Rjwvxzm3n&quot;&gt;https://cloud.baidu.com/doc/OCR/s/Rjwvxzm3n&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 05 Jul 2019 15:27:00 +0000</pubDate>
<dc:creator>东小东</dc:creator>
<og:description>2019年7月3日早上，在百度AI开发者大会上，一个来自山西的青年，将一瓶矿泉水浇在了同样来自山西的李彦宏身上。 可以回顾一下 https://b23.tv/av57665929/p1 ，着实让人一惊</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/dongxiaodong/p/11140680.html</dc:identifier>
</item>
<item>
<title>（持续更新）Qt3D 学习资源 - 行者孙</title>
<link>http://www.cnblogs.com/sunchaothu/p/11141212.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sunchaothu/p/11141212.html</guid>
<description>&lt;p&gt;最近用Qt3D做了一个三维显示的项目，过程比较艰辛，主要是Qt3D这个库虽然推出了有几年，但是资料并不多，官方的例程比较少且大多是QML的，虽然他本身是完全支持C++的，而API 接口的文档写得又比较简略，用的人少产生的资料就更少了，在google和stackoverflow 搜索相关问题也往往找不到答案，在做项目的过程中我收集了很多资料，在这里列出来分享给大家，同时欢迎大家找到好的相关资料在评论里留言，我会更新到博客中。&lt;/p&gt;
&lt;h2 id=&quot;什么是qt3d&quot;&gt;1.1 什么是Qt3D&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://doc.qt.io/qt-5/qt3d-index.html#qt-3d-platform-support&quot;&gt;Qt3D&lt;/a&gt; 是Qt官方支持的3D实时渲染引擎，和Qt一样几乎支持所有平台，对OpenGL pipeline进行了封装，支持C++ 和脚本语言QML，甚至支持 python (pyQt和pySide)， 目的是为了让开发者快速地开发出三维渲染的程序。与OSG、VTK和OGRE等类似，但是是Qt原生的，对于Qt开发来说兼容性会更好，可以自然地使用Qt的信号-槽机制。&lt;/p&gt;
&lt;p&gt;Qt3D 具有以下&lt;a href=&quot;https://doc.qt.io/qt-5/qt3d-overview.html#&quot;&gt;基本特性&lt;/a&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;C++ 应用或者Qt Quick应用程序的 2D/3D 渲染&lt;/li&gt;
&lt;li&gt;Meshes 和 Geometry （Qt 中三维实体的组织形式，可以加载obj\mesh等对象 或者定义 opengl 中 vertex 集合）&lt;/li&gt;
&lt;li&gt;Materials 材质&lt;/li&gt;
&lt;li&gt;Shaders&lt;/li&gt;
&lt;li&gt;Shadow Mapping 阴影贴图&lt;/li&gt;
&lt;li&gt;Ambient occlusion 环境光遮蔽&lt;/li&gt;
&lt;li&gt;高动态范围&lt;/li&gt;
&lt;li&gt;Deferred rendering 延迟渲染&lt;/li&gt;
&lt;li&gt;Multitexturing 多重纹理&lt;/li&gt;
&lt;li&gt;Instanced rendering&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;Uniform Buffer Objects&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;还有 物理引擎、碰撞检测和游戏AI等。&lt;/p&gt;
&lt;p&gt;Qt3D 主要由&lt;a href=&quot;https://www.kdab.com/expertise/3dgraphicsandcompute/qt3d/&quot;&gt;KDAB&lt;/a&gt; 设计、开发和维护，和Qt Company 由密切合作， Qt3D 模块集成在Qt5.5以后的版本中, 版本越高功能越完善且一些BUG会被修复。&lt;/p&gt;
&lt;p&gt;Qt3D 有两种License: GNU LGPL v3协议和GNU GPL v2协议。&lt;/p&gt;
&lt;h2 id=&quot;qt3d-的利与弊&quot;&gt;1.2 Qt3D 的利与弊&lt;/h2&gt;
&lt;p&gt;Qt3D 的利和弊我只能根据我的直观体验来写，未必客观，但是真实。&lt;/p&gt;
&lt;h3 id=&quot;利原生支持&quot;&gt;利：原生支持&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;如果你本来就在用Qt作为GUI库，那么使用Qt3D将会获得完全兼容的3D库，并且不需要安装额外的依赖，在移植的时候也很方便, 可以使用Qt的信号-槽和事件机制&lt;/li&gt;
&lt;li&gt;性能上号称支持做游戏引擎 near real-time simulation&lt;/li&gt;
&lt;li&gt;工具库相对很丰富了，相比纯撸 OpenGL 来说还是节省了很大的开发工作&lt;/li&gt;
&lt;li&gt;和Qt一致的跨平台能力&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;弊处资料过少&quot;&gt;弊处：资料过少&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;相比与OSG、Unity3D库这些成熟的库来说不够流行（但是原理是相通的）&lt;/li&gt;
&lt;li&gt;资料过少，官方文档和例程不够充实（或许这也是广大开发者加入开源社区的好机会）&lt;/li&gt;
&lt;li&gt;如果不使用Qt作为GUI框架，那么单独使用Qt3D似乎又优点沉重&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;最终建议是：如果你使用Qt开发，那么使用Qt3D 将会很方便，否则，则没必要。&lt;/p&gt;

&lt;p&gt;如果要使用Qt3D，那么以下知识是必须的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Qt GUI框架，不管是C++或者QML&lt;/li&gt;
&lt;li&gt;OpenGL渲染管线的基本知识，或许不需要成为这方面专家，但是需要知道基本的pipeline。同时如果想开发高性能的3D程序，那么OpenGL的底子还是要打牢。&lt;/li&gt;
&lt;li&gt;ECS 架构：Entity+Component System, Qt3D 中的任何一个实体由 Mesh + 材质构成；Mesh、材质都属于 component。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;Entity - mesh + material( + transform) &lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;(可选) QML/QtQucik&lt;br/&gt;因为Qt3D 的大部分例子都是QML的(当然也有C++); 掌握QML有利于读懂QML的示例代码；从而进行C++实现&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;opengl-学习资料&quot;&gt;2.1 OpenGL 学习资料&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;掌握以下概念,差不多足够Qt3D 入门使用&lt;/strong&gt; ：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;OpenGL pipeline&lt;/li&gt;
&lt;li&gt;vertex, attribute,shader, transform ,camera,texture&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;qt3d-资料&quot;&gt;2.2 Qt3D 资料&lt;/h2&gt;
&lt;h3 id=&quot;视频资料&quot;&gt;2.2.1 视频资料&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://youtu.be/FLBf5VWn8s4&quot;&gt;introduction to Qt3D&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;与3D 实体交互的QT3D 教程，涉及的关键类（QObjectPicker）&lt;br/&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=dpj2dZQA63c&amp;amp;feature=youtu.be&quot;&gt;Interact with 3D contents&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;ppt和博客&quot;&gt;2.2.2 PPT和博客&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://ervin.ipsquad.net/slides/talks/ak2017-qt3d-advances/ak2017-qt3d-advances.pdf&quot; class=&quot;uri&quot;&gt;https://ervin.ipsquad.net/slides/talks/ak2017-qt3d-advances/ak2017-qt3d-advances.pdf&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.kdab.com/wp-content/uploads/stories/Qt_3D_basics_whitepaper_Part2.pdf&quot; class=&quot;uri&quot;&gt;https://www.kdab.com/wp-content/uploads/stories/Qt_3D_basics_whitepaper_Part2.pdf&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.kdab.com/wp-content/uploads/stories/qt3dinteraction.pdf&quot; class=&quot;uri&quot;&gt;https://www.kdab.com/wp-content/uploads/stories/qt3dinteraction.pdf&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://blog.qt.io/blog/2016/06/16/introducing-qt-3d/&quot; class=&quot;uri&quot;&gt;https://blog.qt.io/blog/2016/06/16/introducing-qt-3d/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;教程&quot;&gt;2.2.3 教程&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;使用Qt3D 游戏开发的一个实例,主要基于QML，需要一定的QML 基础和OpenGL 基础，这个例子也提供了一些参考链接。&lt;br/&gt;&lt;a href=&quot;http://ftp.jaist.ac.jp/pub/qtproject/learning/developerguides/gamedevelopmentqt3d/GameDevelopmentQt3D.pdf&quot; class=&quot;uri&quot;&gt;http://ftp.jaist.ac.jp/pub/qtproject/learning/developerguides/gamedevelopmentqt3d/GameDevelopmentQt3D.pdf&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;问答&quot;&gt;2.2.4 问答&lt;/h3&gt;
&lt;ol readability=&quot;-0.84317032040472&quot;&gt;&lt;li&gt;知乎 &lt;a href=&quot;https://www.zhihu.com/question/48708879/answer/112235199&quot; class=&quot;uri&quot;&gt;https://www.zhihu.com/question/48708879/answer/112235199&lt;/a&gt;&lt;/li&gt;
&lt;li readability=&quot;-0.92570281124498&quot;&gt;
&lt;p&gt;Qt3D 是 ECS(Entity-Component-System)架构;什么是ECS架构&lt;br/&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/30538626&quot; class=&quot;uri&quot;&gt;https://zhuanlan.zhihu.com/p/30538626&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;补充：ECS的利弊&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ECS Pros:
&lt;ul&gt;&lt;li&gt;Avoids deep, wide, complex inheritance hierarchies&lt;/li&gt;
&lt;li&gt;Flexible – can change object behaviour at runtime (add/remove components)&lt;/li&gt;
&lt;li&gt;Extensible – add more component types later&lt;/li&gt;
&lt;li&gt;Qt 3D ECS is high performance by Aspects (Systems) offloading work to backend&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ECS Cons:
&lt;ul&gt;&lt;li&gt;Often new to OOP programmers – takes a while to adjust thinking&lt;/li&gt;
&lt;li&gt;More objects – Entity plus Components&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Qt3D 中使用着色器 Shader&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/52836013/how-to-make-color-of-a-section-be-different-on-a-3d-object&quot; class=&quot;uri&quot;&gt;https://stackoverflow.com/questions/52836013/how-to-make-color-of-a-section-be-different-on-a-3d-object&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;项目源码&quot;&gt;2.2.5 项目源码&lt;/h3&gt;
&lt;ol readability=&quot;-0.46926229508197&quot;&gt;&lt;li readability=&quot;-0.95698924731183&quot;&gt;
&lt;p&gt;qt3d 源码，Github上有源码（下面这个镜像在网页端支持代码跳转！）&lt;br/&gt;&lt;a href=&quot;https://code.woboq.org/qt5/qt3d/src/render/picking/qpickevent.h.html#Qt3DRender::QPickEvent::RightButton&quot;&gt;qt3d&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://code.qt.io/cgit/qt-labs/qt3d-editor.git/&quot;&gt;Qt3D Editor&lt;/a&gt; 一个可以用来实验 mesh + camera + transform + render 效果的。主要由QML写得，核心类是由Cpp写得。下面是效果。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://qt-blog-uploads.s3.amazonaws.com/wp-content/uploads/2016/06/scene-editor.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 05 Jul 2019 15:13:00 +0000</pubDate>
<dc:creator>行者孙</dc:creator>
<og:description>[toc] 一、前言 最近用Qt3D做了一个三维显示的项目，过程比较艰辛，主要是Qt3D这个库虽然推出了有几年，但是资料并不多，官方的例程比较少且大多是QML的，虽然他本身是完全支持C++的，而API</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sunchaothu/p/11141212.html</dc:identifier>
</item>
<item>
<title>python算法与数据结构-二叉树的代码实现(46) - Se7eN_HOU</title>
<link>http://www.cnblogs.com/Se7eN-HOU/p/11140752.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Se7eN-HOU/p/11140752.html</guid>
<description>&lt;h3&gt;一、二叉树回忆&lt;/h3&gt;
&lt;p&gt;　　上一篇我们对数据结构中常用的树做了介绍，本篇博客主要以二叉树为例，讲解一下树的数据结构和代码实现。回顾二叉树：二叉树是每个节点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）&lt;/p&gt;
&lt;h3&gt;二、二叉树比链表好在哪里？&lt;/h3&gt;
&lt;p&gt;看看如下的数据：使用链表形式存放&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/751754/201907/751754-20190705143359417-132176316.png&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们要向查找数据6，需要从头开始查找，找到最后一个，查找比较麻烦。再来看看使用二叉树的形式存储&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/751754/201907/751754-20190705143923679-1315564812.png&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;显然，我们很清楚自己要查找的目标大致会在那里出现；&lt;/p&gt;
&lt;p&gt;例如查找的目标是6，那么我知道6小于9所以根本不会去看右边的数据；&lt;/p&gt;
&lt;p&gt;我们继续看6大于5所以找到啦目标；&lt;/p&gt;
&lt;p&gt;换句话说我们只对比了两次找到啦目标；&lt;/p&gt;
&lt;p&gt;而对于链表，我们发现6排在了链表的尾部；到此为止我们知道这样的二叉树的确是高效的；&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;三、二叉树的节点定义（C语言版）&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
typedef &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; N
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; data;
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; N *&lt;span&gt;left_node;
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; N *&lt;span&gt;right_node;
    
}Node;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;四、定义一个二叉树（C语言版）&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
typedef &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; tree
{
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; node *&lt;span&gt;root;
}Tree;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们的树定义得更加简单，注意我们是先定义节点，再定义树；&lt;/p&gt;
&lt;p&gt;因为树的定义需要用到节点结构体；&lt;/p&gt;
&lt;p&gt;接下来我们需要初始化我们的树&lt;/p&gt;
&lt;h3&gt;五、初始化树（C语言版）&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Tree *&lt;span&gt; init_tree()
{
    Tree &lt;/span&gt;*tree = (Tree *)&lt;span&gt;malloc&lt;/span&gt;(&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(Tree));
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (tree)
    {
        tree&lt;/span&gt;-&amp;gt;root =&lt;span&gt; NULL;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; tree;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;六、创建节点（C语言版）&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Node *make_node(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; data)
{
    Node &lt;/span&gt;*node = (Node *)&lt;span&gt;malloc&lt;/span&gt;(&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(Node));
    node&lt;/span&gt;-&amp;gt;left_node =&lt;span&gt; NULL;
    node&lt;/span&gt;-&amp;gt;right_node =&lt;span&gt; NULL;
    node&lt;/span&gt;-&amp;gt;data =&lt;span&gt; data;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; node;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;七、插入节点（C语言版）&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 插入节点&lt;/span&gt;
Node* insert_node(Tree *tree,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; data)
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断根节点是否存在&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (tree-&amp;gt;root ==&lt;span&gt; NULL)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 不存在就创建&lt;/span&gt;
        tree-&amp;gt;root =&lt;span&gt; make_node(data);
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    {
        Node &lt;/span&gt;*current = tree-&amp;gt;&lt;span&gt;root;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 一直循环知道找到准确的插入数据的位置&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 我们的二叉树不允许重复数字插入,相等直接退出&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (current-&amp;gt;data ==&lt;span&gt; data)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; tree-&amp;gt;&lt;span&gt;root;
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果要插入的数据比根节点大，就放在右边的子树中&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(current-&amp;gt;data&amp;lt;&lt;span&gt;data)
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (current-&amp;gt;right_node ==&lt;span&gt; NULL)
                {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建右节点&lt;/span&gt;
                    current-&amp;gt;right_node =&lt;span&gt; make_node(data);
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                }
                current &lt;/span&gt;= current-&amp;gt;&lt;span&gt;right_node;
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果要插入的数据比根节点小，就放在左边的子树中&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (current-&amp;gt;left_node ==&lt;span&gt; NULL)
                {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建左节点&lt;/span&gt;
                    current-&amp;gt;left_node =&lt;span&gt; make_node(data);
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                }
                current &lt;/span&gt;= current-&amp;gt;&lt;span&gt;left_node;
            }
        }
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; tree-&amp;gt;&lt;span&gt;root;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;八、树的遍历（C语言版）&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; print_inorder(Node *&lt;span&gt;root)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (root)
    {
        print_inorder(root&lt;/span&gt;-&amp;gt;&lt;span&gt;left_node);
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;data:%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,root-&amp;gt;&lt;span&gt;data);
        print_inorder(root&lt;/span&gt;-&amp;gt;&lt;span&gt;right_node);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;九、树的删除（C语言版）&lt;/h3&gt;
&lt;p&gt;树的删除比较麻烦，整体分为二种情况：&lt;/p&gt;
&lt;p&gt;　　一、要删除的节点左右都有子节点&lt;/p&gt;
&lt;p&gt;　　二、要删除的节点只有一个或者0个节点（即有左节点或者右节点或者一个都没有）&lt;/p&gt;
&lt;p&gt; 其中第一种情况又分几种小情况。例如：我们要删除节点6&lt;/p&gt;
&lt;p&gt;　　1.1 我们现在要删除的是节点6，这时候6节点下面的右节点只有一个7，并且7下面没有节点，有一个也一样的，只需要将其右边的节点7替代他的位置即可。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/751754/201907/751754-20190705165848948-650861540.png&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　1.2 我们现在要删除的是节点6，现在7下面5和8两个节点，如果还是按照上面的思路删除的话，删除之后7下面就有1，5，8三个节点，明显不对&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/751754/201907/751754-20190705170547708-1203997848.png&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　正确的做法应该是找到要删除的节点6的右节点7，这时候在找到7的做节点5，去继承删除节点6的位置&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/751754/201907/751754-20190705171205768-1451587712.png&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt; &lt;/p&gt;
&lt;p&gt;　　1.3、以要删除节点6的右节点7为树的左边分支的最小子节点是左节点的情况（很绕口）&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/751754/201907/751754-20190705173910529-1996840894.png&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　1.4、以要删除节点6的右节点7为树的左边分支的最小子节点是右节点的情况（很绕口）&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/751754/201907/751754-20190705175722871-796728100.png&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;树删除代码的实现&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; remove_node(Tree *tree,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; data)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tree-&amp;gt;root !=&lt;span&gt; NULL)
    {
        Node &lt;/span&gt;*p =&lt;span&gt; NULL;
        Node &lt;/span&gt;*&lt;span&gt;s ;
        Node &lt;/span&gt;*current = tree-&amp;gt;&lt;span&gt;root;
        
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根节点都没有直接返回&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (current ==&lt;span&gt; NULL)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 要删除的节点就是跟节点&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(current-&amp;gt;data ==&lt;span&gt; data)
            {
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 要删除的节点在根节点的右边&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(current-&amp;gt;data&amp;lt;&lt;span&gt;data)
            {
                p &lt;/span&gt;=&lt;span&gt; current;
                current &lt;/span&gt;= current-&amp;gt;&lt;span&gt;right_node;
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 要删除的节点在根节点的左边&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                p&lt;/span&gt;=&lt;span&gt;current;
                current &lt;/span&gt;= current-&amp;gt;&lt;span&gt;left_node;
            }
        }
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*********************上面的代码片段是找到要删除的节点*************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        
        &lt;span&gt;if&lt;/span&gt; (current-&amp;gt;left_node != NULL &amp;amp;&amp;amp; current-&amp;gt;right_node !=&lt;span&gt; NULL)
        {
            p &lt;/span&gt;=&lt;span&gt; current;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 找到要删除节点的右节点&lt;/span&gt;
            s = current-&amp;gt;&lt;span&gt;right_node;
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (s-&amp;gt;left_node !=&lt;span&gt; NULL)
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; p = s当current要深入到下一个分叉时，给自己留一个后路；所以保存了自己的前一个备份；&lt;/span&gt;
                p =&lt;span&gt; s;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 沿着左边一直找到最小的节点&lt;/span&gt;
                s = s-&amp;gt;&lt;span&gt;left_node;
            }
            current&lt;/span&gt;-&amp;gt;data = s-&amp;gt;&lt;span&gt;data;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 最小值在分支的右边&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; ( p-&amp;gt;right_node ==&lt;span&gt; s)
            {
                p&lt;/span&gt;-&amp;gt;right_node = s-&amp;gt;&lt;span&gt;right_node;
            }
            &lt;/span&gt;&lt;span&gt;free&lt;/span&gt;&lt;span&gt;(s);
        }
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;**************上面的代码片段是根据要删除节点左右都有子节点的情况*************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 左子节点为空，只有右子节点&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (current-&amp;gt;left_node ==&lt;span&gt; NULL)
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 而且要删除的节点是跟节点&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (p==&lt;span&gt;NULL)
                {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 直接将跟节点的右节点设置为跟节点&lt;/span&gt;
                    tree-&amp;gt;root = current-&amp;gt;&lt;span&gt;right_node;
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (p-&amp;gt;right_node ==&lt;span&gt; current)
                    {
                        p&lt;/span&gt;-&amp;gt;right_node = current-&amp;gt;&lt;span&gt;right_node;
                    }
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                    {
                        p&lt;/span&gt;-&amp;gt;left_node = current-&amp;gt;&lt;span&gt;right_node;
                    }
                }
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 右子节点为空，只有左子节点&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 而且要删除的节点是跟节点&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (p ==&lt;span&gt; NULL)
                {
                    tree&lt;/span&gt;-&amp;gt;root = current-&amp;gt;&lt;span&gt;left_node;
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (p-&amp;gt;right_node ==&lt;span&gt; current)
                    {
                        p&lt;/span&gt;-&amp;gt;right_node = current-&amp;gt;&lt;span&gt;left_node;
                    }
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                    {
                        p&lt;/span&gt;-&amp;gt;left_node = current-&amp;gt;&lt;span&gt;left_node;
                    }
                }
            }
        }
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;**************上面的代码片段是根据要删除节点左右只有一个或者没有子节点的情况*********&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;十、树的查找（C语言版）&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; find_node(Node *root,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; data)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (root ==&lt;span&gt; NULL)
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(root-&amp;gt;data ==&lt;span&gt; data)
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (root-&amp;gt;data &amp;lt;&lt;span&gt;data)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; find_node(root-&amp;gt;&lt;span&gt;right_node, data);
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; find_node(root-&amp;gt;&lt;span&gt;left_node, data);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;十一、树的前序遍历（C语言版）&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; preOrder(Node *&lt;span&gt;root)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (root !=&lt;span&gt; NULL)
    {
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,root-&amp;gt;&lt;span&gt;data);
        preOrder(root&lt;/span&gt;-&amp;gt;&lt;span&gt;left_node);
        preOrder(root&lt;/span&gt;-&amp;gt;&lt;span&gt;right_node);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;十二、树的中序遍历（C语言版）&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; inOrder(Node *&lt;span&gt;root)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (root !=&lt;span&gt; NULL)
    {
        inOrder(root&lt;/span&gt;-&amp;gt;&lt;span&gt;left_node);
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,root-&amp;gt;&lt;span&gt;data);
        inOrder(root&lt;/span&gt;-&amp;gt;&lt;span&gt;right_node);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;十三、树的后序遍历(C语言版)&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; postOreder(Node *&lt;span&gt;root)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (root !=&lt;span&gt; NULL)
    {
        postOreder(root&lt;/span&gt;-&amp;gt;&lt;span&gt;left_node);
        postOreder(root&lt;/span&gt;-&amp;gt;&lt;span&gt;right_node);
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,root-&amp;gt;&lt;span&gt;data);
    }
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;十四、树的广度遍历（C语言版）&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; level_order(Tree *&lt;span&gt;tree)
{
    Node &lt;/span&gt;*node = tree-&amp;gt;&lt;span&gt;root;
    Node &lt;/span&gt;*queue[&lt;span&gt;10&lt;/span&gt;&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; current = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; after_current = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node ==&lt;span&gt; NULL)
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }
    
    queue[current&lt;/span&gt;++] =&lt;span&gt; node;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (current!=&lt;span&gt;after_current)
    {
        node &lt;/span&gt;= queue[after_current++&lt;span&gt;];
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,node-&amp;gt;&lt;span&gt;data);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node-&amp;gt;left_node !=&lt;span&gt; NULL)
        {
            queue[current&lt;/span&gt;++] = node-&amp;gt;&lt;span&gt;left_node;
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node-&amp;gt;right_node !=&lt;span&gt; NULL)
        {
            queue[current&lt;/span&gt;++] = node-&amp;gt;&lt;span&gt;right_node;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;十五、树的python代码实现&lt;/h3&gt;
&lt;p&gt;由于C语言版写的很详细了，python就简单的实现排序，思路完全一样。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; coding:utf-8&lt;/span&gt;

&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Node(object):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, item):
        self.elem &lt;/span&gt;=&lt;span&gt; item
        self.lchild &lt;/span&gt;=&lt;span&gt; None
        self.rchild &lt;/span&gt;=&lt;span&gt; None

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Tree(object):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;二叉树&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        self.root &lt;/span&gt;=&lt;span&gt; None

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; add(self, item):
        node &lt;/span&gt;=&lt;span&gt; Node(item)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; self.root &lt;span&gt;is&lt;/span&gt;&lt;span&gt; None:
            self.root &lt;/span&gt;=&lt;span&gt; node
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;
        queue &lt;/span&gt;=&lt;span&gt; [self.root]
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; queue:
            cur_node &lt;/span&gt;=&lt;span&gt; queue.pop(0)
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; cur_node.lchild &lt;span&gt;is&lt;/span&gt;&lt;span&gt; None:
                cur_node.lchild &lt;/span&gt;=&lt;span&gt; node
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                queue.append(cur_node.lchild)
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; cur_node.rchild &lt;span&gt;is&lt;/span&gt;&lt;span&gt; None:
                cur_node.rchild &lt;/span&gt;=&lt;span&gt; node
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                queue.append(cur_node.rchild)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; breadth_travel(self):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;广度遍历&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; self.root &lt;span&gt;is&lt;/span&gt;&lt;span&gt; None:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;
        queue &lt;/span&gt;=&lt;span&gt; [self.root]
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; queue:
            cur_node &lt;/span&gt;=&lt;span&gt; queue.pop(0)
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(cur_node.elem, end=&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; cur_node.lchild &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; None:
                queue.append(cur_node.lchild)
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; cur_node.rchild &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; None:
                queue.append(cur_node.rchild)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; preorder(self, node):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;先序遍历&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; node &lt;span&gt;is&lt;/span&gt;&lt;span&gt; None:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(node.elem, end=&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        self.preorder(node.lchild)
        self.preorder(node.rchild)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; inorder(self, node):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;中序遍历&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; node &lt;span&gt;is&lt;/span&gt;&lt;span&gt; None:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;
        self.inorder(node.lchild)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(node.elem, end=&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        self.inorder(node.rchild)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; postorder(self, node):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;后序遍历&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; node &lt;span&gt;is&lt;/span&gt;&lt;span&gt; None:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;
        self.postorder(node.lchild)
        self.postorder(node.rchild)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(node.elem, end=&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
    tree &lt;/span&gt;=&lt;span&gt; Tree()
    tree.add(&lt;/span&gt;5&lt;span&gt;)
    tree.add(&lt;/span&gt;2&lt;span&gt;)
    tree.add(&lt;/span&gt;3&lt;span&gt;)
    tree.add(&lt;/span&gt;7&lt;span&gt;)
    tree.add(&lt;/span&gt;4&lt;span&gt;)
    tree.add(&lt;/span&gt;8&lt;span&gt;)
    tree.add(&lt;/span&gt;6&lt;span&gt;)
    
    
    tree.preorder(tree.root)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    tree.inorder(tree.root)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    tree.postorder(tree.root)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    tree.breadth_travel()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
5 2 7 4 3 8 6  
7 2 4 5 8 3 6  
7 4 2 8 6 3 5  
5 2 3 7 4 8 6 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;写到此处以吐血，你看到次数也吐血了吧。&lt;/p&gt;

</description>
<pubDate>Fri, 05 Jul 2019 13:00:00 +0000</pubDate>
<dc:creator>Se7eN_HOU</dc:creator>
<og:description>一、二叉树回忆 上一篇我们对数据结构中常用的树做了介绍，本篇博客主要以二叉树为例，讲解一下树的数据结构和代码实现。回顾二叉树：二叉树是每个节点最多有两个子树的树结构。通常子树被称作“左子树”（left</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Se7eN-HOU/p/11140752.html</dc:identifier>
</item>
<item>
<title>（数据科学学习手札63）利用pandas读写HDF5文件 - 费弗里</title>
<link>http://www.cnblogs.com/feffery/p/11135082.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/feffery/p/11135082.html</guid>
<description>&lt;p&gt;&lt;span&gt;一、简介&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　HDF5（Hierarchical Data Formal）是用于存储大规模数值数据的较为理想的存储格式，文件后缀名为h5，存储读取速度非常快，且可在文件内部按照明确的层次存储数据，同一个HDF5可以看做一个高度整合的文件夹，其内部可存放不同类型的数据。在Python中操纵HDF5文件的方式主要有两种，一是利用pandas中内建的一系列HDF5文件操作相关的方法来将pandas中的数据结构保存在HDF5文件中，二是利用h5py模块来完成从Python原生数据结构向HDF5格式的保存，本文就将针对pandas中读写HDF5文件的方法进行介绍。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;二、利用pandas操纵HDF5文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.1 写出&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　pandas中的HDFStore()用于生成管理HDF5文件IO操作的对象，其主要参数如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　path：字符型输入，用于指定h5文件的名称（不在当前工作目录时需要带上完整路径信息）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　mode：用于指定IO操作的模式，与Python内建的open()中的参数一致，默认为'a'，即当指定文件已存在时不影响原有数据写入，指定文件不存在时则新建文件；'r'，只读模式；'w'，创建新文件（会覆盖同名旧文件）；'r+'，与'a'作用相似，但要求文件必须已经存在；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　complevel：int型，用于控制h5文件的压缩水平，取值范围在0-9之间，越大则文件的压缩程度越大，占用的空间越小，但相对应的在读取文件时需要付出更多解压缩的时间成本，默认为0，代表不压缩&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　下面我们创建一个HDF5 IO对象store：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; pandas as pd

store &lt;/span&gt;= pd.HDFStore(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;demo.h5&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;查看store类型&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(store)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1344061/201907/1344061-20190705160551989-1745377353.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　可以看到store对象属于pandas的io类，通过上面的语句我们已经成功的初始化名为demo.h5的的文件，本地也相应的出现了如下的文件：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1344061/201907/1344061-20190705160936172-1136779737.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　接下来我们创建pandas中不同的两种对象，并将它们共同保存到store中，首先创建series对象：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建一个series对象&lt;/span&gt;
s = pd.Series(np.random.randn(5), index=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;e&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
s&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1344061/201907/1344061-20190705161827115-1510631964.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　接着我们创建一个dataframe对象：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建一个dataframe对象&lt;/span&gt;
df = pd.DataFrame(np.random.randn(8, 3&lt;span&gt;),
                 columns&lt;/span&gt;=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
df&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1344061/201907/1344061-20190705161921857-1049924984.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　第一种方式利用键值对将不同的数据存入store对象中，这里为了代码简洁使用了元组赋值法：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
store[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;],store[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;df&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = s,df
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　第二种方式利用store对象的put()方法，其主要参数如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　key：指定h5文件中待写入数据的key&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　value：指定与key对应的待写入的数据&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　format：字符型输入，用于指定写出的模式，'fixed'对应的模式速度快，但是不支持追加也不支持检索；'table'对应的模式以表格的模式写出，速度稍慢，但是支持直接通过store对象进行追加和表格查询操作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　使用put()方法将数据存入store对象中：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
store.put(key=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,value=s);store.put(key=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;df&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,value=df)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;　　既然是键值对的格式，那么可以查看store的items属性（注意这里store对象只有items和keys属性，没有values属性）：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
store.items
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1344061/201907/1344061-20190705163440369-1875789582.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　调用store对象中的数据直接用对应的键名来索引即可：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
store[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;df&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1344061/201907/1344061-20190705163720364-1053922646.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　删除store对象中指定数据的方法有两种，一是使用remove()方法，传入要删除数据对应的键：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
store.remove(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(store.keys())
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　二是使用Python中的关键词del来删除指定数据：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;del&lt;/span&gt; store[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(store.keys())
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　打印出的结果都如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1344061/201907/1344061-20190705164449829-560024565.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这时若想将当前的store对象持久化到本地，只需要利用close()方法关闭store对象即可：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;store.close()
&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;查看store连接状况，False则代表已关闭&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
store.is_open&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1344061/201907/1344061-20190705164835971-1678386504.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这时本地的h5文件也相应的存储进store对象关闭前包含的文件：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1344061/201907/1344061-20190705165204993-1023469633.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　除了通过定义一个确切的store对象的方式，还可以从pandas中的数据结构直接导出到本地h5文件中：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建新的数据框&lt;/span&gt;
df_ = pd.DataFrame(np.random.randn(5,5&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;导出到已存在的h5文件中，这里需要指定key&lt;/span&gt;
df_.to_hdf(path_or_buf=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;demo.h5&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,key=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;df_&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建于本地demo.h5进行IO连接的store对象&lt;/span&gt;
store = pd.HDFStore(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;demo.h5&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;查看指定h5对象中的所有键&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(store.keys())
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1344061/201907/1344061-20190705171632572-703208754.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.2 读入&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在pandas中读入HDF5文件的方式主要有两种，一是通过上一节中类似的方式创建与本地h5文件连接的IO对象，接着使用键索引或者store对象的get()方法传入要提取数据的key来读入指定数据：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
store = pd.HDFStore(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;demo.h5&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;方式1&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
df1 &lt;/span&gt;= store[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;df&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;方式2&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
df2 &lt;/span&gt;= store.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;df&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
df1 &lt;/span&gt;== df2
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1344061/201907/1344061-20190705180451549-616275753.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　可以看出这两种方式都能顺利读取键对应的数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　第二种读入h5格式文件中数据的方法是pandas中的read_hdf()，其主要参数如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　path_or_buf：传入指定h5文件的名称&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　key：要提取数据的键&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　需要注意的是利用read_hdf()读取h5文件时对应文件不可以同时存在其他未关闭的IO对象，否则会报错，如下例：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(store.is_open)
df &lt;/span&gt;= pd.read_hdf(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;demo.h5&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,key=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;df&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1344061/201907/1344061-20190705200011652-1184933155.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　把IO对象关闭后再次提取：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;store.close()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(store.is_open)
df &lt;/span&gt;= pd.read_hdf(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;demo.h5&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,key=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;df&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
df&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1344061/201907/1344061-20190705200430913-1379101662.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;2.3 速度比较&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这一小节我们来测试一下对于存储同样数据的csv格式文件、h5格式的文件，在读取速度上的差异情况：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这里我们首先创建一个非常大的数据框，由一亿行x5列浮点类型的标准正态分布随机数组成，接着分别用pandas中写出HDF5和csv格式文件的方式持久化存储：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; pandas as pd
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time

store &lt;/span&gt;= pd.HDFStore(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;store.h5&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;生成一个1亿行，5列的标准正态分布随机数表&lt;/span&gt;
df = pd.DataFrame(np.random.rand(100000000,5&lt;span&gt;))
start1 &lt;/span&gt;=&lt;span&gt; time.clock()
store[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;df&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; df
store.close()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(f&lt;span&gt;'&lt;/span&gt;&lt;span&gt;HDF5存储用时{time.clock()-start1}秒&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
start2 &lt;/span&gt;=&lt;span&gt; time.clock()
df.to_csv(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;df.csv&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,index=&lt;span&gt;False)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(f&lt;span&gt;'&lt;/span&gt;&lt;span&gt;csv存储用时{time.clock()-start2}秒&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1344061/201907/1344061-20190705205118452-807190320.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在写出同样大小的数据框上，HDF5比常规的csv快了将近50倍，而且两者存储后的文件大小也存在很大差异：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1344061/201907/1344061-20190705205319159-1025379245.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　csv比HDF5多占用将近一倍的空间，这还是在我们没有开启HDF5压缩的情况下，接下来我们关闭所有IO连接，运行下面的代码来比较对上述两个文件中数据还原到数据框上两者用时差异：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; pandas as pd
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time

start1 &lt;/span&gt;=&lt;span&gt; time.clock()
store &lt;/span&gt;= pd.HDFStore(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;store.h5&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,mode=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
df1 &lt;/span&gt;= store.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;df&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(f&lt;span&gt;'&lt;/span&gt;&lt;span&gt;HDF5读取用时{time.clock()-start1}秒&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
start2 &lt;/span&gt;=&lt;span&gt; time.clock()
df2 &lt;/span&gt;= pd.read_csv(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;df.csv&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(f&lt;span&gt;'&lt;/span&gt;&lt;span&gt;csv读取用时{time.clock()-start2}秒&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1344061/201907/1344061-20190705205535656-477377155.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　HDF5用时仅为csv的1/13，因此在涉及到数据存储特别是规模较大的数据时，HDF5是你不错的选择。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　以上就是本文的全部内容，如有笔误望指出！&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 05 Jul 2019 12:59:00 +0000</pubDate>
<dc:creator>费弗里</dc:creator>
<og:description>一、简介 HDF5（Hierarchical Data Formal）是用于存储大规模数值数据的较为理想的存储格式，文件后缀名为h5，存储读取速度非常快，且可在文件内部按照明确的层次存储数据，同一个H</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/feffery/p/11135082.html</dc:identifier>
</item>
<item>
<title>每天学点node系列-stream - 一半水一半冰</title>
<link>http://www.cnblogs.com/jingh/p/11140651.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jingh/p/11140651.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;在编写代码时，我们应该有一些方法将程序像连接水管一样连接起来 -- 当我们需要获取一些数据时，可以去通过&quot;拧&quot;其他的部分来达到目的。这也应该是IO应有的方式。 -- Doug McIlroy. October 11, 1964&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;为什么应该使用stream&quot;&gt;为什么应该使用stream?&lt;/h2&gt;
&lt;p&gt;在node中，I/O都是异步的，所以在和硬盘以及网络的交互过程中会涉及到传递回调函数的过程。你之前可能会写出这样的代码：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var http = require('http');
var fs = require('fs');

var server = http.createServer(function (req, res) {
    fs.readFile(__dirname + '/data.txt', function (err, data) {
        res.end(data);
    });});
server.listen(8000);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的这段代码并没有什么问题，但是在每次请求时，我们都会把整个data.txt文件读入到内存中，然后再把结果返回给客户端。想想看，如果data.txt文件非常大，在响应大量用户的并发请求时，程序可能会消耗大量的内存，这样很可能会造成用户连接缓慢的问题。其次，上面的代码可能会造成很不好的用户体验，因为用户在接收到任何的内容之前首先需要等待程序将文件内容完全读入到内存中。所幸的是，&lt;code&gt;(req,res)&lt;/code&gt; 参数都是流对象，这意味着我们可以使用一种更好的方法来实现上面的需求：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var http = require('http');
var fs = require('fs');

var server = http.createServer(function (req, res) {
    var stream = fs.createReadStream(__dirname + '/data.txt');
    stream.pipe(res);
});
server.listen(8000);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这里，.pipe()方法会自动帮助我们监听data和end事件。上面的这段代码不仅简洁，而且data.txt文件中每一小段数据都将源源不断的发送到客户端。&lt;br/&gt;除此之外，使用.pipe()方法还有别的好处，比如说它可以自动控制后端压力，以便在客户端连接缓慢的时候node可以将尽可能少的缓存放到内存中。&lt;/p&gt;
&lt;h2 id=&quot;认识nodejs中的stream&quot;&gt;认识NodeJS中的stream&lt;/h2&gt;
&lt;p&gt;流（stream）是 Node.js 中处理流式数据的抽象接口。·&lt;code&gt;stream&lt;/code&gt; 模块用于构建实现了流接口的对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们用到的很多核心模块都是&lt;code&gt;stream&lt;/code&gt;的实例。&lt;/strong&gt; 例如：http.clientRequest， process.stdout。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;流可以是可读的、可写的、或者可读可写的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所有的流都是 EventEmitter 的实例。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虽然我们平时开发过程中平常不会直接用到&lt;code&gt;stream&lt;/code&gt;模块，但是也需要了解其运行机制。&lt;/p&gt;
&lt;p&gt;对于想要实现自定义stream实例的开发者来说，就得好好研究stream的扩展API了，比如gulp的内部实现就大量用到了自定义的stream类型。&lt;/p&gt;
&lt;h2 id=&quot;stream的类型&quot;&gt;stream的类型&lt;/h2&gt;
&lt;p&gt;Node.js 中有四种基本的流类型：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Writable - 可写入数据的流（例如 fs.createWriteStream()）。&lt;/li&gt;
&lt;li&gt;Readable - 可读取数据的流（例如 fs.createReadStream()）。&lt;/li&gt;
&lt;li&gt;Duplex - 可读又可写的流（例如 net.Socket）。&lt;/li&gt;
&lt;li&gt;Transform - 在读写过程中可以修改或转换数据的 Duplex 流（例如 zlib.createDeflate()）。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;使用Stream可实现数据的流式处理，如：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var fs = require('fs') 
// `fs.createReadStream`创建一个`Readable`对象以读取`bigFile`的内容，并输出到标准输出 
// 如果使用`fs.readFile`则可能由于文件过大而失败 
fs.createReadStream(bigFile).pipe(process.stdout)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;readable&quot;&gt;Readable&lt;/h2&gt;
&lt;p&gt;Readable流可以产出数据，你可以将这些数据传送到一个writable，transform或者duplex流中，只需要调用pipe()方法:&lt;/p&gt;
&lt;h3 id=&quot;创建个readable流&quot;&gt;创建个readable流&lt;/h3&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var Readable = require('stream').Readable;

var rs = new Readable;
rs.push('beep ');
rs.push('boop\n');
rs.push(null);

rs.pipe(process.stdout);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面运行代码&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;$ node read.js
beep boop&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上面的代码中rs.push(null)的作用是告诉rs输出数据应该结束了。&lt;br/&gt;需要注意的一点是我们在将数据输出到process.stdout之前已经将内容推送进readable流rs中，但是所有的数据依然是可写的。这是因为在你使用.push()将数据推进一个readable流中时，一直要到另一个东西来消耗数据之前，数据都会存在一个缓存中。然而，在更多的情况下，我们想要的是当需要数据时数据才会产生，以此来避免大量的缓存数据。&lt;/p&gt;
&lt;h3 id=&quot;流式消耗迭代器中的数据&quot;&gt;流式消耗迭代器中的数据&lt;/h3&gt;
&lt;p&gt;我们可以通过定义一个._read函数来实现按需推送数据:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;const Readable = require('stream').Readable
class ToReadable extends Readable {
    constructor(iterator) {
        super()
        this.iterator = iterator
    }
    // 子类需要实现该方法
    // 这是生产数据的逻辑
    _read() {
        const res = this.iterator.next()
        if (res.done) {
            // 数据源已枯竭，调用`push(null)`通知流
            return this.push(null)
        }
        setTimeout(() =&amp;gt; {
        // 通过`push`方法将数据添加到流中
            this.push(res.value + '\n')
        }, 0)
    }
}
module.exports = ToReadable&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用时，new ToReadable(iterator)会返回一个可读流，下游可以流式的消耗迭代器中的数据。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;const iterator = function (limit) {
    return {
        next: function () {
            if (limit--) {
                return { done: false, value: limit + Math.random() }
            }
            return { done: true }
        }
    }
}(1e10)
const readable = new ToReadable(iterator)
// 监听`data`事件，一次获取一个数据
readable.on('data', data =&amp;gt; process.stdout.write(data))
// 所有数据均已读完
readable.on('end', () =&amp;gt; process.stdout.write('DONE'))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行上述代码，将会有100亿个随机数源源不断地写进标准输出流。&lt;/p&gt;
&lt;p&gt;创建可读流时，需要继承Readable，并实现_read方法。 * _read方法是从底层系统读取具体数据的逻辑，即生产数据的逻辑。 * 在_read方法中，通过调用push(data)将数据放入可读流中供下游消耗。 * 在_read方法中，可以同步调用push(data)，也可以异步调用。 * 当全部数据都生产出来后，必须调用push(null)来结束可读流。 * 流一旦结束，便不能再调用push(data)添加数据。&lt;/p&gt;
&lt;p&gt;可以通过监听data事件的方式消耗可读流。 * 在首次监听其data事件后，readable便会持续不断地调用_read()，通过触发data事件将数据输出。 * 第一次data事件会在下一个tick中触发，所以，可以安全地将数据输出前的逻辑放在事件监听后（同一个tick中）。 * 当数据全部被消耗时，会触发end事件。&lt;/p&gt;
&lt;p&gt;上面的例子中，process.stdout代表标准输出流，实际是一个可写流。&lt;/p&gt;
&lt;h2 id=&quot;writable&quot;&gt;Writable&lt;/h2&gt;
&lt;p&gt;一个writable流指的是只能流进不能流出的流:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;src.pipe(writableStream)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;创建一个writable流&quot;&gt;创建一个writable流&lt;/h3&gt;
&lt;p&gt;只需要定义一个._write(chunk,enc,next)函数，你就可以将一个readable流的数据释放到其中：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;const Writable = require('stream').Writable

const writable = Writable()
// 实现`_write`方法
// 这是将数据写入底层的逻辑
writable._write = function (data, enc, next) {
  // 将流中的数据写入底层
  process.stdout.write(data.toString().toUpperCase())
  // 写入完成时，调用`next()`方法通知流传入下一个数据
  process.nextTick(next)
}

// 所有数据均已写入底层
writable.on('finish', () =&amp;gt; process.stdout.write('DONE'))

// 将一个数据写入流中
writable.write('a' + '\n')
writable.write('b' + '\n')
writable.write('c' + '\n')

// 再无数据写入流时，需要调用`end`方法
writable.end()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;$ node 1.js
A
B
C
DONE&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;上游通过调用writable.write(data)将数据写入可写流中。write()方法会调用_write()将data写入底层。&lt;/li&gt;
&lt;li&gt;_write中，当数据成功写入底层后，必须调用next(err)告诉流开始处理下一个数据。&lt;/li&gt;
&lt;li&gt;在从一个readable流向一个writable流传数据的过程中，数据会自动被转换为&lt;code&gt;Buffer&lt;/code&gt;对象，除非你在创建writable流的时候制定了&lt;code&gt;decodeStrings&lt;/code&gt;参数为&lt;code&gt;false&lt;/code&gt;:&lt;code&gt;Writable({decodeStrings: false})&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;如果你需要传递对象，需要指定&lt;code&gt;objectMode&lt;/code&gt;参数为&lt;code&gt;true&lt;/code&gt;，&lt;code&gt;Writable({ objectMode: true })&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;在end方法调用后，当所有底层的写操作均完成时，会触发finish事件。&lt;/li&gt;
&lt;li&gt;上游必须调用writable.end(data)来结束可写流，data是可选的。此后，不能再调用write新增数据。&lt;/li&gt;
&lt;li&gt;next的调用既可以是同步的，也可以是异步的.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;_write的参数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一个参数，&lt;code&gt;chunk&lt;/code&gt;表写进来的数据。&lt;/li&gt;
&lt;li&gt;第二个参数 &lt;code&gt;enc&lt;/code&gt; 代表编码的字符串，但是只有在&lt;code&gt;opts.decodeString&lt;/code&gt;为&lt;code&gt;false&lt;/code&gt;的时候你才可以写一个字符串。&lt;/li&gt;
&lt;li&gt;第三个参数，&lt;code&gt;next(err)&lt;/code&gt;是一个回调函数，使用这个回调函数你可以告诉数据消耗者可以写更多的数据。你可以有选择性的传递一个错误对象&lt;code&gt;error&lt;/code&gt;，这时会在流实体上触发一个&lt;code&gt;emit&lt;/code&gt;事件。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;向一个writable流中写东西&quot;&gt;向一个writable流中写东西&lt;/h3&gt;
&lt;p&gt;如果你需要向一个writable流中写东西，只需要调用.write(data)即可。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;    process.stdout.write('beep boop\n');&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了告诉一个writable流你已经写完毕了，只需要调用.end()方法。你也可以使用.end(data)在结束前再写一些数据。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var fs = require('fs');
var ws = fs.createWriteStream('message.txt');

ws.write('beep ');

setTimeout(function () {
    ws.end('boop\n');
},1000);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果如下所示:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;$ node writing.js 
$ cat message.txt
beep boop&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果你在创建writable流时指定了highWaterMark参数，那么当没有更多数据写入时，调用.write()方法将会返回false。如果你想要等待缓存情况，可以监听drain事件。&lt;/p&gt;
&lt;h2 id=&quot;duplex&quot;&gt;Duplex&lt;/h2&gt;
&lt;p&gt;Duplex流是一个可读也可写的流，就好像一个电话，可以接收也可以发送语音。一个rpc交换是一个duplex流的最好的例子。如果你看到过下面这样的代码：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;a.pipe(b).pipe(a)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么你需要处理的就是一个duplex流对象。&lt;/p&gt;
&lt;h3 id=&quot;实现一个duplex&quot;&gt;实现一个Duplex&lt;/h3&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var Duplex = require('stream').Duplex
var duplex = Duplex()
// 可读端底层读取逻辑
duplex._read = function () {
    this._readNum = this._readNum || 0
    if (this._readNum &amp;gt; 1) {
        this.push(null)
    } else {
        this.push('' + (this._readNum++))
    }
}
// 可写端底层写逻辑
duplex._write = function (buf, enc, next) {
    // a, b
    process.stdout.write('_write ' + buf.toString() + '\n')
    next()
}
// 0, 1
duplex.on('data', data =&amp;gt; console.log('ondata', data.toString()))
duplex.write('a')
duplex.write('b')
duplex.end()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码中实现了_read方法，所以可以监听data事件来消耗Duplex产生的数据。 同时，又实现了_write方法，可作为下游去消耗数据。&lt;br/&gt;因为它既可读又可写，所以称它有两端：可写端和可读端。 可写端的接口与Writable一致，作为下游来使用；可读端的接口与Readable一致，作为上游来使用。&lt;/p&gt;
&lt;h2 id=&quot;transform&quot;&gt;Transform&lt;/h2&gt;
&lt;p&gt;Transform stream是Duplex stream的特例，也就是说，Transform stream也同时可读可写。跟Duplex stream的区别点在于，Transform stream的输出与输入是存在相关性的。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;const Transform = require('stream').Transform
class Rotate extends Transform {
    constructor(n) {
        super()
        // 将字母旋转`n`个位置
        this.offset = (n || 13) % 26
    }
    // 将可写端写入的数据变换后添加到可读端
    _transform (buf, enc, next) {
        var res = buf.toString().split('').map(c =&amp;gt; {
            var code = c.charCodeAt(0)
            if (c &amp;gt;= 'a' &amp;amp;&amp;amp; c &amp;lt;= 'z') {
                code += this.offset
                if (code &amp;gt; 'z'.charCodeAt(0)) {
                    code -= 26
                }
            } else if (c &amp;gt;= 'A' &amp;amp;&amp;amp; c &amp;lt;= 'Z') {
                code += this.offset
                if (code &amp;gt; 'Z'.charCodeAt(0)) {
                    code -= 26
                }
            }
            return String.fromCharCode(code)
        }).join('')
        // 调用push方法将变换后的数据添加到可读端
        this.push(res)
        // 调用next方法准备处理下一个
        next()
    }
}
var transform = new Rotate(3)
transform.on('data', data =&amp;gt; process.stdout.write(data))
transform.write('hello, ')
transform.write('world!')
transform.end()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果如下：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;$ node 1.js
khoor, zruog!&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Tranform继承自Duplex，并已经实现了_read和_write方法，同时要求用户实现一个_transform方法。&lt;/p&gt;
&lt;h3 id=&quot;相关链接&quot;&gt;相关链接&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://nodejs.org/api/stream.html&quot; class=&quot;uri&quot;&gt;https://nodejs.org/api/stream.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 05 Jul 2019 12:59:00 +0000</pubDate>
<dc:creator>一半水一半冰</dc:creator>
<og:description>在编写代码时，我们应该有一些方法将程序像连接水管一样连接起来 当我们需要获取一些数据时，可以去通过'拧'其他的部分来达到目的。这也应该是IO应有的方式。 Doug McIlroy. October 1</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jingh/p/11140651.html</dc:identifier>
</item>
<item>
<title>为什么建议大家使用 Linux 开发 - 夏日浅笑、</title>
<link>http://www.cnblogs.com/summertime-wu/p/11140052.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/summertime-wu/p/11140052.html</guid>
<description>&lt;h2 id=&quot;linux-能用吗&quot;&gt;Linux 能用吗？&lt;/h2&gt;
&lt;p&gt;我身边还有些朋友对 linux 的印象似乎还停留在黑乎乎的命令行界面上。当我告诉他或者建议他使用 linux 时，会一脸惊讶的问我，那个怎么用（来开发或者日常使用）？&lt;/p&gt;
&lt;h3 id=&quot;linux-有图形界面&quot;&gt;Linux 有图形界面&lt;/h3&gt;
&lt;p&gt;桌面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1138447/201907/1138447-20190705182726987-1367589147.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;启动器&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1138447/201907/1138447-20190705182808641-113978073.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;文件管理器&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1138447/201907/1138447-20190705182827996-950232210.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;设置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1138447/201907/1138447-20190705182940335-775164604.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是我使用了近两年的“国产”操作系统 &lt;a href=&quot;https://www.cnblogs.com/summertime-wu/p/www.deepin.org&quot;&gt;deepin&lt;/a&gt; ，界面美不美观我不知道，能用是肯定的。&lt;/p&gt;
&lt;blockquote readability=&quot;2.6601307189542&quot;&gt;
&lt;p&gt;关于其他 linux 可以参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.linuxprobe.com/eight-linux-distribution.html&quot;&gt;八款精美的 Linux 发行版！&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnbeta.com/articles/soft/695605.htm&quot;&gt;2018年10大最漂亮的 Linux 发行版&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.linuxidc.com/Linux/2017-01/139414.htm&quot;&gt;展望2017年的七款好用Linux发行版&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;支持日常开发&quot;&gt;支持日常开发&lt;/h3&gt;
&lt;p&gt;首先 Vim/Emacs 表示它们可以搞定，但是我觉得我和它们不熟。..&lt;/p&gt;
&lt;p&gt;Java : Eclipse , IDEA , NetBeans , Android Studio ...&lt;/p&gt;
&lt;p&gt;Python : PyCharm , WingIDE ...&lt;/p&gt;
&lt;p&gt;C++ : KDevelop , Code Blocks ...&lt;/p&gt;
&lt;p&gt;Php : PhpStorm ...&lt;/p&gt;
&lt;p&gt;前端 ：Sublime , VS Code , WebStorm ...&lt;/p&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;排名不分先后&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;社交沟通没问题&quot;&gt;社交沟通没问题&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1138447/201907/1138447-20190705183005453-832888611.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;居然还有 ICQ ...&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;囿于时间原因，这里使用了 deepin 商店截图 ，其他 linux 发行版不一定有这么丰富，不过安装qq、微信应该没问题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;linux-能替代-windows-吗&quot;&gt;Linux 能替代 Windows 吗？&lt;/h2&gt;
&lt;p&gt;先列下本人日常使用的软件：&lt;/p&gt;
&lt;p&gt;开发：IDEA&lt;/p&gt;
&lt;p&gt;数据库：DBeaver , Navicat , PL/SQL&lt;/p&gt;
&lt;p&gt;沟通：TIM , 微信&lt;/p&gt;
&lt;p&gt;浏览器：谷歌，火狐，360&lt;/p&gt;
&lt;p&gt;Office: WPS ，Microsoft office网页版&lt;/p&gt;
&lt;p&gt;音乐：网易云音乐&lt;/p&gt;
&lt;p&gt;输入法：搜狗输入法&lt;/p&gt;
&lt;p&gt;播放器：deepin自带的播放器，VLC&lt;/p&gt;
&lt;p&gt;编辑器：Sublime Text&lt;/p&gt;
&lt;p&gt;远程控制：TeamViewer，向日葵，VNC，Remmina&lt;/p&gt;
&lt;p&gt;下载：迅雷极速版，Aria2&lt;/p&gt;
&lt;p&gt;网盘：坚果云，百度网盘&lt;/p&gt;
&lt;p&gt;MarkDown编辑器：Typora，Zettlr&lt;/p&gt;
&lt;p&gt;终端：deepin自带的（非常好用）&lt;/p&gt;
&lt;p&gt;思维导图：XMind ZEN&lt;/p&gt;
&lt;p&gt;ftp：FileZilla&lt;/p&gt;
&lt;p&gt;PDF：福熙阅读器&lt;/p&gt;
&lt;p&gt;虚拟机：VirtualBox，vmware&lt;/p&gt;
&lt;p&gt;游戏：Steam，Minecraft（我的世界）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Android APP：xDroid&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这些只是我个人日常使用，还有很多优秀的软件没有列出来。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;至于能不能替代 Windows ，这个问题因人而异。对我而言，在两年的使用经历中，暂时没有遇到过 linux 下不能解决，必须回到 Windows 的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;而且，实在不行不是还有虚拟机吗。&lt;/p&gt;
&lt;blockquote readability=&quot;0.86928104575163&quot;&gt;
&lt;p&gt;其他参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/71833109&quot;&gt;100 个最佳 Ubuntu 应用（上）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://dstore-appstore.deepin.cn/china/index&quot;&gt;Deepin 应用商店&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.sohu.com/a/238318823_100008608&quot;&gt;常用的超赞 Linux 软件大汇总，入行运维必藏！&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.appinn.com/tag/linux/&quot;&gt;小众软件-Linux&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;linux-下运行-android-应用&quot;&gt;Linux 下运行 Android 应用&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://www.linzhuotech.com/&quot;&gt;xDroid&lt;/a&gt;&lt;/strong&gt; 使 Android 应用能运行在 linux 上，极大的扩展了 linux 生态。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1138447/201907/1138447-20190705185316802-1841274788.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1138447/201907/1138447-20190705185638986-1383144424.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;是的，你没有看错，不是基于虚拟机或模拟器的，速度可观，占用资源小。&lt;/p&gt;
&lt;p&gt;这似乎是目前 Windows 都无法做到的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;运行截图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1138447/201907/1138447-20190705191819584-1413551466.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;应用市场部分截图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1138447/201907/1138447-20190705191442721-65081846.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1138447/201907/1138447-20190705191512267-92192405.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;linux-有什么优势吗&quot;&gt;Linux 有什么优势吗？&lt;/h2&gt;
&lt;p&gt;从一个系统迁移到另一个的系统成本是巨大的，Linux 有什么魅力值得我这么做吗？&lt;/p&gt;
&lt;h3 id=&quot;linux-是优雅的&quot;&gt;Linux 是优雅的&lt;/h3&gt;
&lt;p&gt;当我在 Windows 下安装一个软件时，首先需要打开浏览器，搜索你想要的软件，小心翼翼的避开广告，当你找到一个看起来是对的网站时，还是得小心翼翼的找到 &lt;code&gt;下载地址&lt;/code&gt; 之类而不是巨大的下载按钮，最后再小小翼翼的安装，一定不能漏掉某些勾勾，一旦一不小心漏掉了，就会发现电脑似乎有点卡顿，不一会儿，它的朋友就会出现在你的桌面上。&lt;/p&gt;
&lt;p&gt;而在 linux 下，&lt;code&gt;apt install&lt;/code&gt; 或者 &lt;code&gt;yum install&lt;/code&gt; 之类的命令，就能搞定整个安装。&lt;/p&gt;
&lt;p&gt;Linux 不需要选择软件是放 c 盘还是 d 盘，已经定义好了哪些文件该放在哪些地方，&lt;/p&gt;
&lt;p&gt;也不需要杀毒软件，&lt;/p&gt;
&lt;p&gt;也不需要清理垃圾，&lt;/p&gt;
&lt;p&gt;也不需要释放内存，&lt;/p&gt;
&lt;p&gt;也不需要激活系统，它是开源免费的，&lt;/p&gt;
&lt;p&gt;也不需要磁盘优化，&lt;/p&gt;
&lt;p&gt;也没有烦人的弹窗，&lt;/p&gt;
&lt;p&gt;也没有强制更新。&lt;/p&gt;
&lt;h3 id=&quot;linux-是高效的&quot;&gt;Linux 是高效的&lt;/h3&gt;
&lt;p&gt;这是 linux 最吸引我的地方了&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;命令行&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;命令行不是一种落后的操控计算机的方式。相反，它一直很高效且富有表达性。&lt;/p&gt;
&lt;p&gt;当你想要复制、剪切或删除一个文件时，我相信打开文件管理器在不同窗口之间跳转是没有一条命令来得快。&lt;/p&gt;
&lt;p&gt;当你想要查看系统运行状态，我相信移动鼠标，右键，选择任务管理器是没有一条命令来得快。&lt;/p&gt;
&lt;p&gt;当你想要编写一个简单的脚本或文件时，我相信打开编辑器，新建文件，编写，选择文件位置保存是没有一条命令来得快。&lt;/p&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;p&gt;鼠标是很好的工具，但是它有它的局限，毕竟它只有三个按钮。而命令行中使用参数的表达力是无穷的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;减少使用鼠标&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过命令行，浏览器的 Vimium 插件（类似于 Vim 的方式操作浏览器界面），Albert（通过指定按键唤出一个输入框，可以打开 app ， 文件 ，url ，直接搜索 ，计算器 ...），系统快捷键再加上IDEA（它的设计思想是键盘优先）我能够很少的使用鼠标。&lt;/p&gt;
&lt;p&gt;当然不是鼠标烫手，当你的双手在键盘上飞快的敲打时，直接使用键盘是比右手挪到鼠标上再挪回来要快的，而且这种不中断的体验非常舒畅。&lt;/p&gt;
&lt;p&gt;至于这为什么是 linux 的优点，在我过去多年的 Windows 使用经验中，我没有找到自定义系统快捷键的入口，更不用说自定义宏了。Windows 当然也有命令行，不过我认为它的命令丰富程度和各个命令之间的配合是不如 linux 的（有人称之为附属品）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;减少重复劳动&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我有一个文件夹，专门存放着我写的各式各样的脚本。大部分时候，你的问题市面上的软件都可以解决，但是当有一些细碎、独特、重复的小任务时。脚本能够帮你很好的解决这些。&lt;/p&gt;
&lt;p&gt;比如，我有一个监控生产环境的脚本（其实应该是项目本身自带的），有一个OA守护脚本（其实就是监控我有没有写日报，没有的话发个短信提醒我），甚至还有一个定时发送微信的脚本...&lt;/p&gt;
&lt;p&gt;这些脚本能一定程度的解决信息世界的重复劳动，让我更专注于具有创造性的工作上。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;启动速度&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在我的电脑上，无论是从系统启动速度，还是软件（IDEA，Chrome）启动速度都略胜 Windows 一筹。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;使用经验所得，未有准确测试数据。不过IDEA是测过的，快了一秒多&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;内存占用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1138447/201907/1138447-20190705191913137-1992505815.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;来源：deepin 官网&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;linux-是自由的&quot;&gt;Linux 是自由的&lt;/h3&gt;
&lt;p&gt;上面的只说明了脚本带来的好处，并没有说明是在 linux 下带来。&lt;/p&gt;
&lt;p&gt;因为只有 linux 才有这样的开放和可定制，你可以很容易的通过命令来修改系统配置和改变系统状态，甚至于修改内核代码，编译并使用它。&lt;/p&gt;
&lt;p&gt;假如不喜欢当前的桌面环境，可以轻易的通过命令来切换。&lt;/p&gt;
&lt;p&gt;假如喜欢 mac os ，可以通过网上的教程将 Ubuntu 改成一模一样（甚至包含开机 logo）。&lt;/p&gt;
&lt;p&gt;假如不喜欢系统自带的文件管理器，可以选择其他优秀的软件，比如 Nautilus。&lt;/p&gt;
&lt;p&gt;假如不喜欢当前终端，有太多选择了，我甚至用过一个模仿一部电影内出现的，极具极客风格的终端。&lt;/p&gt;
&lt;p&gt;而相反，比如拿字体来说，在 linux 下我可以通过命令来安装和切换系统字体，而在 Windows 下没有这样的设置或者入口。暂时不太明白为什么这种选择的权利都没有。&lt;/p&gt;
&lt;p&gt;而这些仅仅只是一些微不足道的例子。&lt;/p&gt;
&lt;blockquote readability=&quot;1.1428571428571&quot;&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/lmseo5hy/article/details/79279424&quot;&gt;Linux与windows相比有何优势，看完就明白了&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;linux-也可以是美的&quot;&gt;Linux 也可以是美的&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/av50732978&quot;&gt;deepin 15.10 中文宣传视频&lt;/a&gt; (使用内嵌 iframe 不知道为什么放不出来)&lt;/p&gt;

&lt;blockquote readability=&quot;5.55078125&quot;&gt;
&lt;p&gt;本文作者：夏日浅笑、&lt;br/&gt;原文地址：&lt;a href=&quot;https://www.cnblogs.com/summertime-wu/p/11140052.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/summertime-wu/p/11140052.html&lt;/a&gt;&lt;br/&gt;本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;限于本人有限的知识水平，文中可能存在误解或错误（轻喷～），欢迎指出。&lt;/p&gt;
&lt;p&gt;写这点东西写了我两天，可把我累坏了（叉腰），大家走过路过不要吝啬自己的赞美哦&lt;/p&gt;
</description>
<pubDate>Fri, 05 Jul 2019 12:04:00 +0000</pubDate>
<dc:creator>夏日浅笑、</dc:creator>
<og:description>Linux 能用吗？ 我身边还有些朋友对 linux 的印象似乎还停留在黑乎乎的命令行界面上。当我告诉他或者建议他使用 linux 时，会一脸惊讶的问我，那个怎么用（来开发或者日常使用）？ Linux</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/summertime-wu/p/11140052.html</dc:identifier>
</item>
</channel>
</rss>