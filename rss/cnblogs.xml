<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>大神是怎样炼成的 ---谈如何做一个优秀的程序员！ - dongwang911</title>
<link>http://www.cnblogs.com/wangdong811/p/10330584.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangdong811/p/10330584.html</guid>
<description>&lt;p id=&quot;activity-name&quot;&gt;&lt;span&gt;&lt;span&gt; 　　年关将至，大部分的同仁们在筹划着怎么买票的同时，也在筹划着来年的打算，我估计好多人都已经蠢蠢欲动了。不是我说话难听，只是这个世界很现实，据统计，每年有近一百万的新培训的IT们进入到这个行业，然后封装成三年经验去进入到这个鱼龙混杂的大潮中。所以逼着面试官们，不得不想尽各种的策略方法来筛选到自己的中意的人, 同时也会采用更加严格残酷的标准去衡量每一位候选人。我们所面对的竞争者每年都在增长，竞争压力越来越大。这既是现实，3年前的面试时候掌握点java基础就可以了，但是现在你不懂JVM你就不能称自己有两三年经验。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;div id=&quot;js_content&quot; readability=&quot;109&quot;&gt;
&lt;p&gt;　　我相信大部分的同仁都是CRUD(增删改查)工程&lt;span&gt;师，大厂可能有，但是大部分还是传&lt;span&gt;统行业的居多, 比如电信、银行、保险、CRM等。传统行业的工程师有一个特点就是工作的时候百分之九十的时间是在关注业务，平时根本没有时间去关注技术层面的提升，平时所使用、接触到的技术层面的东西寥寥无几，大部分都是自己封装的&lt;/span&gt;一套，再加上在舒适区呆习惯了，鲜有在业余时间进行技术方面的充电的，所以当这一批人一旦产生要换工作的念头，就需要慎重&lt;/span&gt;了，因为技术的进步一日千里，当你还在温水里面煮着的时候，这个世界已经把你远远地甩在了后面，所以我建议大家，不管平时有多么多么的忙，每天或者每周都要抽出点时间学习一些新的东西，即使不学习新东西，起码对于自己所使用的技术要门清，比如你使用的是Hibernate，那么hibernate的底层原理是什么？ 一二级缓存是怎么理解的？&lt;/p&gt;
&lt;p&gt;　　最近我明白了一个道理，技术的进步，不在于你学会了多少的框架，掌握了多少技能，而在于你有没有一种作为合格程序员的思维，既要会从小到大的微观思维，也要会从大到小的宏观思维。所以好多的大佬都建议平时多研究研究Spring的源码，因为Spring是管理框架的框架，所以读懂了Spring的源码你就学会了一种宏观思维。一个新的业务框架的熟悉只需要一两个周，所以看的不是会多少框架，而是看你的知识体系是否足够的深入，所谓纸上得来终觉浅，绝知此事要躬行。&lt;/p&gt;
&lt;p&gt;　　程序员三年以后拼的不是你的多么的会写CRUD，而是你的内功，什么内功呢？ 就是你对深层次的东西的理解程度。每年有近百万的程序员上岸，他们能做什么CRUD么？ 答案是可以的？ 但是内功怎么样呢？ 不敢恭维，就像是一个司机经过了四次考试，拿到了驾照，你能说他是一个合格的司机吗?  就像是刚学会走路的小孩跌跌撞撞的在走，你能说他会走吗？ 简历可以封装，青涩可以用衣服来伪装，但是内功是装不出来的，内功是需要十几万代码的锤炼、为解决BUG来抓耳挠腮的煎熬、上线的时候的从彻夜无眠，战战兢兢到上线成功，欢呼雀跃的洗礼。所谓高手过招，比的不是招式，而是内功。&lt;/p&gt;
&lt;p&gt;　　做程序员容易，但是做个好程序员难，真是难上加难。难得是难有日复一日、坚持学习的精神，难有不被游戏诱惑住的定力等等，总之取经的路上九九八十一难，哪一难都少不了。所以佼佼者寥寥无几，混饭吃的人乌央乌央的，从每天早上地铁的拥挤程度就能看出来，当然我也是一个。&lt;/p&gt;
&lt;p&gt;　　好了，回归正题，虽然说平时的积累少，面试的时候胜算会少点，但是临时抱佛脚的行动还是要有的。从这篇文章开始我会陆续的给大家推送一些面试相关的文章，工作之余我给大家准备了一个知识清单，方便大家复习，巩固知识，为了来年的更好的工作，让自己能有一个质的飞越。&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;Java基础相关&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;Java 基础相关的知识&lt;/p&gt;
&lt;p&gt;单例模式、冒泡排序&lt;/p&gt;
&lt;p&gt;Java 集合的底层的实现&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;设计模式相关&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;掌握常用的设计模式&lt;/p&gt;
&lt;p&gt;掌握几种常用的设计模式的应用场景，优缺点&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;多线程相关&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;线程的几种创建方式以及区别&lt;/p&gt;
&lt;p&gt;线程相关的方法的使用，场景的处理，比如如何判断线程执行完毕。&lt;/p&gt;
&lt;p&gt;高并发相关的原子类、volitile关键字 等&lt;/p&gt;
&lt;p&gt;Java Concurrent包下面的类熟悉一下&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;数据库相关&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;数据库优化相关&lt;/p&gt;
&lt;p&gt;数据库的索引的结构，以及不同结构的优缺点。&lt;/p&gt;
&lt;p&gt;数据库语法中的基础，比如各种join的区别&lt;/p&gt;
&lt;p&gt;不同数据库的区别（mysql 和oracle的区别当然问这个问题的人大多不长脑子）&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;数据结构算法&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;熟悉几种常见的数据结构 数组  集合 链表等&lt;/p&gt;
&lt;p&gt;熟悉几种数据结构的用处&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;虚拟机相关&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;Jvm 内存结构 各部分的作用以及相关的优化。&lt;/p&gt;
&lt;p&gt;熟悉参数调优相关的原理&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;常用框架相关&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;深入理解 Spring的工作原理。了解相关接口。&lt;/p&gt;
&lt;p&gt;深入理解 IOC 和AOP 的底层实现。&lt;/p&gt;
&lt;p&gt;熟悉Hibernate相关的底层实现原理基本的配置 一级缓存默认开启 主要是二级缓存。&lt;/p&gt;
&lt;p&gt;熟悉Mybatis的相关的原理。&lt;/p&gt;
&lt;p&gt;熟悉是springboot 常用的starter 以及工作原理。&lt;/p&gt;
&lt;p&gt;SpringMVC 的原理，请求流程。&lt;/p&gt;
&lt;p&gt;熟悉常用的rpc框架。&lt;/p&gt;
&lt;p&gt;熟悉会话管理以及相关的知识点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以后的文章我会竭尽全力为大家准备相关的内容，助大家一臂之力！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;更多精彩内容请点击下方二维码： &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ib0x5UUZDULCibSZhluWolx7Ofe4260r2Ks7lDbIQPoIGQq1UvWIbaOaEHW669AgS4axXv5v7C8hMicPoM8VjLTWw/640?wx_fmt=jpeg&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ib0x5UUZDULCibSZhluWolx7Ofe4260r2Ks7lDbIQPoIGQq1UvWIbaOaEHW669AgS4axXv5v7C8hMicPoM8VjLTWw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Mon, 28 Jan 2019 08:00:00 +0000</pubDate>
<dc:creator>dongwang911</dc:creator>
<og:description>年关将至，大部分的同仁们在筹划着怎么买票的同时，也在筹划着来年的打算，我估计好多人都已经蠢蠢欲动了。不是我说话难听，只是这个世界很现实，据统计，每年有近一百万的新培训的IT们进入到这个行业，然后封装成</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wangdong811/p/10330584.html</dc:identifier>
</item>
<item>
<title>多线程学习笔记-深入理解ThreadPoolExecutor - 醉眼识朦胧</title>
<link>http://www.cnblogs.com/fingerboy/p/10330259.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fingerboy/p/10330259.html</guid>
<description>&lt;p&gt;　　java多线程中,线程池的最上层接口是Executor,ExecutorService实现了Executor,是真正的管理线程池的接口,ThreadPoolExecutor间接继承了ExecutorService,提供了多种具体的线程池实现,在日常开发中一般直接使用Executors工具类提供的几种常用ThreadPoolExecutor,下面详细介绍下ThreadPoolExecutor.&lt;/p&gt;
&lt;h2&gt;ThreadPoolExecutor基本参数&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
ThreadPoolExecutor executor = &lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor(5, 10, 1000L, &lt;br/&gt;TimeUnit.SECONDS, &lt;br/&gt;&lt;span&gt;                                                     new&lt;/span&gt; LinkedBlockingDeque&amp;lt;Runnable&amp;gt;(20), &lt;br/&gt;&lt;span&gt;                                                     new&lt;/span&gt; ThreadPoolExecutor.CallerRunsPolicy());
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;29&quot;&gt;
&lt;p&gt;　&lt;span&gt;　&lt;span&gt;&lt;strong&gt;corePoolSize&lt;/strong&gt;:核心线程数的大小,也有说线程池最小线程数&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;maximumPoolSize&lt;/strong&gt;:线程池最大线程数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;keepAliveTime&lt;/strong&gt;:当没有任务执行时,线程能存活的最大时间,这里说的线程是指大于corePoolSize,小于maximumPoolSize的线程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;timeunit&lt;/strong&gt;:keepAliveTime的时间单位&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;workQueue&lt;/strong&gt;:用来存放task的堵塞队列,队列的选择和size的大小对线程池的运行有直接影响,默认有几种实现,后面详说.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;rejectHandler&lt;/strong&gt;:拒绝策略,当队列已满并且线程数达到maximumPoolSize时,再有新任务进来时会执行拒绝策略,默认集中实现,后面详说.&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;ThreadPool模型初始化&lt;/h2&gt;
&lt;p&gt;　　ThreadPool线程池初始化时,不会创建corePoolSIze的线程,也就是说在没有task进来的时候,线程池是空的,当有task进来的时候,开始创建线程,并且线程执行完task后不会销毁,而是驻留内存,直至达到corePoolSize,那什么时候线程数会再度增加达到maxPoolSize呢,这就取决于存放task的queue的size了,如果task的数量一直不超过指定的size那么就不会创建新的线程出来,反之,则会创建新的线程去执行task,那么新建出来的线程执行完task也会一直驻留内存吗?答案是不会,这时候就要看设置的keepAliveTime,如果在超过了这个时间后还是没有task去使用这个线程,则线程销毁,直至线程数等于corePoolSize.那么如果queue也满了,线程数也达到maxPoolsize,这时候怎么办呢,这时rejectHandler就会发挥作用,会根据我们指定的拒绝策略去处理这种场景.&lt;/p&gt;
&lt;h2&gt;Executors的几个默认实现&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; ExecutorService newSingleThreadExecutor() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FinalizableDelegatedExecutorService
            (&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor(1, 1&lt;span&gt;,&lt;/span&gt;0L&lt;span&gt;, TimeUnit.MILLISECONDS,&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;Runnable&amp;gt;&lt;span&gt;()));
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　1.newSingleThreadExecutor:创建一个单线程的线程池.如果这个线程在执行霍城中因为异常结束,则会创建一个新的线程来代替它,这个线程池保证所有任务的执行顺序是按照任务提交顺序进行.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ExecutorService newFixedThreadPool(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; nThreads) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS,&lt;span&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;Runnable&amp;gt;&lt;span&gt;());
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2.newFixedThreadPool:创建一个固定大小的线程池.看源码可知,该实现创建了一个corePoolSize等于maximumPoolSize的线程池.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; ExecutorService newCachedThreadPool() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor(0&lt;span&gt;, Integer.MAX_VALUE,&lt;/span&gt;60L&lt;span&gt;, TimeUnit.SECONDS,&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; SynchronousQueue&amp;lt;Runnable&amp;gt;&lt;span&gt;());
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　3.newCachedThreadPool:创建一个可缓存的线程池.看源码可知corePoolSize=0,即当线程空闲时会被回收,当线程忙碌时又可以&quot;源源不断&quot;的创建新线程来执行task.&lt;/p&gt;
&lt;p&gt;　　默认线程池实现中还有ScheduledThreadPoolExecutor,可以实现定时的一些功能,可用来代替Timer或者TimeTask.这里不再展开说.&lt;/p&gt;
&lt;h2&gt;线程池的堵塞队列&lt;/h2&gt;
&lt;p&gt;　　如何选择线程池的堵塞队列,取决我们的业务场景,即我们希望以一种什么样的排队策略来处理任务.排队通常有3种策略,对应下面几种queue.&lt;/p&gt;
&lt;blockquote readability=&quot;28&quot;&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;直接提交(SynchronousQueue)&lt;/strong&gt;:不排队,这个队列不会存储task,会将调用方的task直接提交给线程,指定了SynchronousQueue的线程池通常会把maximumPoolSize配置的比较大,否则可能会导致没有足够的线程来执行task,而导致task无法放入queue而被丢弃或拒绝.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;有界队列(ArrayBlockingQueue)&lt;/strong&gt;:通过指定ArrayBlockingQueue的size可以设置队列的最大存储个数,当超出这个个数时就会新建线程去执行task直至线程数达到maximumPoolSize,有界队列size的设置和maximumPoolSize的设置息息相关.会影响CPU的使用率以及系统吞吐量.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;无界队列(不设定size的LinkedBlockingQueue)&lt;/strong&gt;:当线程数达到corePoolSize的仍有task进来时,会源源不断进队列,由于无解,maximumPoolSize参数会失效,线程数最大只能达到corPoolSize.&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;线程池拒绝策略&lt;/h2&gt;
&lt;blockquote readability=&quot;34&quot;&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;CallerRunsPolicy&lt;/strong&gt;:使用调用方的线程来执行task,通常情况下调用方线程就是指我们所说的主线程,这样的好处是不会丢弃task,但是缺点也很明显,使用这种策略会堵塞主线程,进而拖慢主线程的整个调用时长.而基于此,该策略同时也减缓了新的task提交进来的速度(因为主线程本来只需要用来提交task就好了,现在直接去执行task,后面的task进来的速度就慢了).&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;AbortPolicy&lt;/strong&gt;:这个策略简单粗暴,直接抛出异常,不跟你多BB,需要注意的是,这个是jdk的默认策略.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;DiscardPolicy&lt;/strong&gt;:这个和AbortPolicy差不多,区别是不会抛出异常,直接丢弃.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;DiscardOldestPolicy&lt;/strong&gt;:这也是一种丢弃策略,不过和上面的DiscardPolicy刚好相反,她丢弃的不是新进来的task而是在堵塞队列中存在时间最久的那个task,即丢弃最早进入队列并且还没有被执行的task.&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

</description>
<pubDate>Mon, 28 Jan 2019 08:00:00 +0000</pubDate>
<dc:creator>醉眼识朦胧</dc:creator>
<og:description>java多线程中,线程池的最上层接口是Executor,ExecutorService实现了Executor,是真正的管理线程池的接口,ThreadPoolExecutor间接继承了ExecutorS</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fingerboy/p/10330259.html</dc:identifier>
</item>
<item>
<title>iOS与硬件通讯（socket，data拼接，发送指令，解析指令） - 王_聪</title>
<link>http://www.cnblogs.com/wangcongiOS/p/wangcong.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangcongiOS/p/wangcong.html</guid>
<description>&lt;p&gt;最近项目中用到了iPad驱动硬件来工作，也就是智能硬件的实现。下面简单说下原理，详细说下socket，wifi通信，数据处理接收，发送，以及数据解析代码。&lt;/p&gt;
&lt;p&gt;首先，来说下通信。因为硬件部件比较多，我们采取的是，iPad与主控板进行交换数据，主控板来与各硬件部件进行通信。看图：&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1372&quot; data-height=&quot;632&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3467163-98c974823db70876.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/3467163-98c974823db70876.png&quot; data-original-width=&quot;1372&quot; data-original-height=&quot;632&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;57672&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;image.png&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;其中，主控与零部件间及时通讯，零部件实时把状态上报给主控。当然，iPad与主控板也是及时通讯，主控需要每秒都上报给iPad各个硬件的当前状态，以供iPad可以实时监控各零部件并且显示不同的状态，比如“ipad上实时显示电冰箱的温度”。后面这黑体加粗才是我们iOS端要做的任务。涉及到&lt;br/&gt;1.与主控建立连接，&lt;br/&gt;2.并保持长链接，实时接收解析主控发来的零部件状态，&lt;br/&gt;3.以及iPad给主控发指令来驱动硬件动作，比如“iPad发送指令让电灯关闭”。&lt;/p&gt;
&lt;p&gt;与主控建立连接，我们用到的是GCDAsyncSocket这个类，github地址&lt;a href=&quot;https://github.com/robbiehanson/CocoaAsyncSocket&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;https://github.com/robbiehanson/CocoaAsyncSocket&lt;/a&gt;，&lt;/p&gt;
&lt;pre class=&quot;hljs objectivec&quot;&gt;
&lt;code class=&quot;objectivec&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;连接成功之后会回调GCDAsyncSocketDelegate的连接成功的方法如下。&lt;/p&gt;
&lt;pre class=&quot;hljs objectivec&quot;&gt;
&lt;code class=&quot;objectivec&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;相对的，断开连接会调用如下回调&lt;/p&gt;
&lt;pre class=&quot;hljs objectivec&quot;&gt;
&lt;code class=&quot;objectivec&quot;&gt;- (&lt;span class=&quot;hljs-keyword&quot;&gt;void)socketDidDisconnect:(GCDAsyncSocket *)sock withError:(&lt;span class=&quot;hljs-built_in&quot;&gt;NSError *)err
{
    &lt;span class=&quot;hljs-built_in&quot;&gt;NSLog(&lt;span class=&quot;hljs-string&quot;&gt;@&quot;tcp连接断开，%@&quot;,err);
    &lt;span class=&quot;hljs-keyword&quot;&gt;self.connected = &lt;span class=&quot;hljs-literal&quot;&gt;NO;
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;连接成功了，下面读取data&lt;/p&gt;
&lt;pre class=&quot;hljs objectivec&quot;&gt;
&lt;code class=&quot;objectivec&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;接收到数据了，下面我们来发送指令控制硬件。&lt;br/&gt;先来看下我们与主控约定的协议格式。&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1218&quot; data-height=&quot;580&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3467163-68220220596693b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/3467163-68220220596693b8.png&quot; data-original-width=&quot;1218&quot; data-original-height=&quot;580&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;265496&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;image.png&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;972&quot; data-height=&quot;328&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3467163-3c83210640a94727.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/972/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/3467163-3c83210640a94727.png&quot; data-original-width=&quot;972&quot; data-original-height=&quot;328&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;110576&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;image.png&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;接下来看代码怎么来发送这个协议数据到主控。&lt;/p&gt;
&lt;pre class=&quot;hljs objectivec&quot;&gt;
&lt;code class=&quot;objectivec&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;那么我们就要构造出这个data，就可以实现发送数据到主控了。&lt;br/&gt;下面介绍两种生成data的方法。&lt;/p&gt;
&lt;pre class=&quot;hljs objectivec&quot;&gt;
&lt;code class=&quot;objectivec&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;10进制转16进制&lt;/p&gt;
&lt;pre class=&quot;hljs objectivec&quot;&gt;
&lt;code class=&quot;objectivec&quot;&gt;+(&lt;span class=&quot;hljs-built_in&quot;&gt;NSString *)ToHex:(&lt;span class=&quot;hljs-keyword&quot;&gt;long &lt;span class=&quot;hljs-keyword&quot;&gt;long &lt;span class=&quot;hljs-keyword&quot;&gt;int)tmpid

{
    
    &lt;span class=&quot;hljs-built_in&quot;&gt;NSString *nLetterValue;
    
    &lt;span class=&quot;hljs-built_in&quot;&gt;NSString *str =&lt;span class=&quot;hljs-string&quot;&gt;@&quot;&quot;;
    
    &lt;span class=&quot;hljs-keyword&quot;&gt;long &lt;span class=&quot;hljs-keyword&quot;&gt;long &lt;span class=&quot;hljs-keyword&quot;&gt;int ttmpig;
    
    &lt;span class=&quot;hljs-keyword&quot;&gt;for (&lt;span class=&quot;hljs-keyword&quot;&gt;int i =&lt;span class=&quot;hljs-number&quot;&gt;0; i&amp;lt;&lt;span class=&quot;hljs-number&quot;&gt;9; i++) {
        
        ttmpig=tmpid%&lt;span class=&quot;hljs-number&quot;&gt;16;
        
        tmpid=tmpid/&lt;span class=&quot;hljs-number&quot;&gt;16;
        
        &lt;span class=&quot;hljs-keyword&quot;&gt;switch (ttmpig)
        
        {
                
            &lt;span class=&quot;hljs-keyword&quot;&gt;case &lt;span class=&quot;hljs-number&quot;&gt;10:
                
                nLetterValue =&lt;span class=&quot;hljs-string&quot;&gt;@&quot;A&quot;;&lt;span class=&quot;hljs-keyword&quot;&gt;break;
                
            &lt;span class=&quot;hljs-keyword&quot;&gt;case &lt;span class=&quot;hljs-number&quot;&gt;11:
                
                nLetterValue =&lt;span class=&quot;hljs-string&quot;&gt;@&quot;B&quot;;&lt;span class=&quot;hljs-keyword&quot;&gt;break;
                
            &lt;span class=&quot;hljs-keyword&quot;&gt;case &lt;span class=&quot;hljs-number&quot;&gt;12:
                
                nLetterValue =&lt;span class=&quot;hljs-string&quot;&gt;@&quot;C&quot;;&lt;span class=&quot;hljs-keyword&quot;&gt;break;
                
            &lt;span class=&quot;hljs-keyword&quot;&gt;case &lt;span class=&quot;hljs-number&quot;&gt;13:
                
                nLetterValue =&lt;span class=&quot;hljs-string&quot;&gt;@&quot;D&quot;;&lt;span class=&quot;hljs-keyword&quot;&gt;break;
                
            &lt;span class=&quot;hljs-keyword&quot;&gt;case &lt;span class=&quot;hljs-number&quot;&gt;14:
                
                nLetterValue =&lt;span class=&quot;hljs-string&quot;&gt;@&quot;E&quot;;&lt;span class=&quot;hljs-keyword&quot;&gt;break;
                
            &lt;span class=&quot;hljs-keyword&quot;&gt;case &lt;span class=&quot;hljs-number&quot;&gt;15:
                
                nLetterValue =&lt;span class=&quot;hljs-string&quot;&gt;@&quot;F&quot;;&lt;span class=&quot;hljs-keyword&quot;&gt;break;
                
            &lt;span class=&quot;hljs-keyword&quot;&gt;default:nLetterValue=[[&lt;span class=&quot;hljs-built_in&quot;&gt;NSString alloc]initWithFormat:&lt;span class=&quot;hljs-string&quot;&gt;@&quot;%lli&quot;,ttmpig];
        }
        str = [nLetterValue stringByAppendingString:str];
        
        &lt;span class=&quot;hljs-keyword&quot;&gt;if (tmpid == &lt;span class=&quot;hljs-number&quot;&gt;0) {
            
            &lt;span class=&quot;hljs-keyword&quot;&gt;break;
            
        }
    }
    &lt;span class=&quot;hljs-keyword&quot;&gt;return str;
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;16进制转为NSData&lt;/p&gt;
&lt;pre class=&quot;hljs objectivec&quot;&gt;
&lt;code class=&quot;objectivec&quot;&gt;+ (&lt;span class=&quot;hljs-built_in&quot;&gt;NSData *)convertHexStrToData:(&lt;span class=&quot;hljs-built_in&quot;&gt;NSString *)str
{
    &lt;span class=&quot;hljs-keyword&quot;&gt;if (!str || [str length] == &lt;span class=&quot;hljs-number&quot;&gt;0) {
        &lt;span class=&quot;hljs-keyword&quot;&gt;return &lt;span class=&quot;hljs-literal&quot;&gt;nil;
    }
    
    &lt;span class=&quot;hljs-built_in&quot;&gt;NSMutableData *hexData = [[&lt;span class=&quot;hljs-built_in&quot;&gt;NSMutableData alloc] initWithCapacity:&lt;span class=&quot;hljs-number&quot;&gt;20];
    &lt;span class=&quot;hljs-built_in&quot;&gt;NSRange range;
    &lt;span class=&quot;hljs-keyword&quot;&gt;if ([str length] % &lt;span class=&quot;hljs-number&quot;&gt;2 == &lt;span class=&quot;hljs-number&quot;&gt;0) {
        range = &lt;span class=&quot;hljs-built_in&quot;&gt;NSMakeRange(&lt;span class=&quot;hljs-number&quot;&gt;0, &lt;span class=&quot;hljs-number&quot;&gt;2);
    } &lt;span class=&quot;hljs-keyword&quot;&gt;else {
        range = &lt;span class=&quot;hljs-built_in&quot;&gt;NSMakeRange(&lt;span class=&quot;hljs-number&quot;&gt;0, &lt;span class=&quot;hljs-number&quot;&gt;1);
    }
    &lt;span class=&quot;hljs-keyword&quot;&gt;for (&lt;span class=&quot;hljs-built_in&quot;&gt;NSInteger i = range.location; i &amp;lt; [str length]; i += &lt;span class=&quot;hljs-number&quot;&gt;2) {
        &lt;span class=&quot;hljs-keyword&quot;&gt;unsigned &lt;span class=&quot;hljs-keyword&quot;&gt;int anInt;
        &lt;span class=&quot;hljs-built_in&quot;&gt;NSString *hexCharStr = [str substringWithRange:range];
        &lt;span class=&quot;hljs-built_in&quot;&gt;NSScanner *scanner = [[&lt;span class=&quot;hljs-built_in&quot;&gt;NSScanner alloc] initWithString:hexCharStr];
        
        [scanner scanHexInt:&amp;amp;anInt];
        &lt;span class=&quot;hljs-built_in&quot;&gt;NSData *entity = [[&lt;span class=&quot;hljs-built_in&quot;&gt;NSData alloc] initWithBytes:&amp;amp;anInt length:&lt;span class=&quot;hljs-number&quot;&gt;1];
        [hexData appendData:entity];
        
        range.location += range.length;
        range.length = &lt;span class=&quot;hljs-number&quot;&gt;2;
    }
    &lt;span class=&quot;hljs-keyword&quot;&gt;return hexData;
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结束。谢谢看官！&lt;/p&gt;
</description>
<pubDate>Mon, 28 Jan 2019 07:34:00 +0000</pubDate>
<dc:creator>王_聪</dc:creator>
<og:description>下面简单说下原理，详细说下socket，wifi通信，数据处理接收，发送，以及数据解析代码。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wangcongiOS/p/wangcong.html</dc:identifier>
</item>
<item>
<title>适用于移动设备弹性布局的js脚本(rem单位) - Bowen Huang</title>
<link>http://www.cnblogs.com/huangbx/p/css-responsive-rem-js.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huangbx/p/css-responsive-rem-js.html</guid>
<description>&lt;h2&gt;背景介绍&lt;/h2&gt;
&lt;p&gt;目前，随着移动设备的普及和4G网络的普及，web在移动端的占比已经远远超过PC端，各种H5页面推广页面，H5小游戏热度火爆。以前简单的使用px单位（没有弹性）的时代已经无法满足各位设计师和用户了。如何100%还原UI设计师的设计图，一直困扰着前端工程师。&lt;/p&gt;
&lt;h2&gt;css单位&lt;/h2&gt;
&lt;p&gt;学习首先我们简单了解下css目前都支持哪些单位:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;px: 设置固定的布局或者元素大小，缺点是没有弹性&lt;/li&gt;
&lt;li&gt;em: 参考父元素的font-size，em会继承父级元素的字体大小，em的值并不是固定的&lt;/li&gt;
&lt;li&gt;rem: 相对根元素html的font-size&lt;/li&gt;
&lt;li&gt;%: 相对父元素，对于position: absolute;的元素是相对于已定位的父元素，对于position: fixed;的元素是相对于ViewPort（可视窗口）&lt;/li&gt;
&lt;li&gt;vw: view width的简写, 是指可视窗口的宽度，浏览器宽度1200px, 1 vw = 1200px/100 = 12 px&lt;/li&gt;
&lt;li&gt;vh: view height的简写，是指可视窗口的高度，浏览器高度900px, 1 vh = 900px/100 = 9 px&lt;/li&gt;
&lt;li&gt;vm: 相对于视口的宽度或高度中较小的那个, 其中最小的那个被均分为100单位的vm，浏览器高度900px，宽度1200px，取最小的浏览器高度，1 vm = 900px/100 = 9 px&lt;/li&gt;
&lt;li&gt;in: 寸&lt;/li&gt;
&lt;li&gt;cm: 厘米&lt;/li&gt;
&lt;li&gt;mm: 毫米&lt;/li&gt;
&lt;li&gt;pt: point, 大约1/72寸&lt;/li&gt;
&lt;li&gt;pc: pica, 大约6pt, 1/6寸&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;具有弹性布局能力的单位：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;em，%: 相对于父元素&lt;/li&gt;
&lt;li&gt;rem: 相对于html&lt;/li&gt;
&lt;li&gt;vw, vh, vm: 相对于可视窗口&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;从上可以看出，要做页面整体弹窗缩放的话，使用rem, vm, vw, vh更适合，因为任何内容都可以找到同一个基准。&lt;/p&gt;
&lt;h2&gt;HTML viewport基础&lt;/h2&gt;
&lt;h3&gt;概念&lt;/h3&gt;
&lt;p&gt;viewport 是用户网页的可视区域。&lt;/p&gt;
&lt;p&gt;手机浏览器是把页面放在一个虚拟的&quot;窗口&quot;（viewport）中，通常这个虚拟的&quot;窗口&quot;（viewport）比屏幕宽，这样就不用把每个网页挤到很小的窗口中（这样会破坏没有针对手机浏览器优化的网页的布局），用户可以通过平移和缩放来看网页的不同部分。&lt;/p&gt;
&lt;h3&gt;用法&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;viewport&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;width=device-width, initial-scale=1.0&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;属性说明&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;width：控制 viewport 的大小，可以指定的一个值，如 600，或者特殊的值，如 device-width 为设备的宽度（单位为缩放为 100% 时的 CSS 的像素）。&lt;/li&gt;
&lt;li&gt;height：和 width 相对应，指定高度。&lt;/li&gt;
&lt;li&gt;initial-scale：初始缩放比例，也即是当页面第一次 load 的时候缩放比例，默认值1。&lt;/li&gt;
&lt;li&gt;maximum-scale：允许用户缩放到的最大比例。&lt;/li&gt;
&lt;li&gt;minimum-scale：允许用户缩放到的最小比例。&lt;/li&gt;
&lt;li&gt;user-scalable：用户是否可以手动缩放。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;弹性布局方案&lt;/h2&gt;
&lt;p&gt;通过以上可以看出，使用弹性布局的css单位配合设置html viewport元信息，就可以实现整体页面的弹性布局（包含字体大小）。&lt;/p&gt;
&lt;h3&gt;先弄明白几个概念：&lt;/h3&gt;
&lt;p&gt;设备分辨率：一个物理像素是显示器(手机屏幕)上最小的物理显示单元，在操作系统的调度下，每一个设备像素都有自己的颜色值和亮度值；&lt;br/&gt;设备屏幕宽度：设备显示器的实际宽度；&lt;br/&gt;DPR：设备上物理像素和设备独立像素(device-independent pixels (dips))的比例，DPR = 设备分辨率/设备屏幕宽度；&lt;br/&gt;300ppi：每英寸300个像素点&lt;/p&gt;
&lt;h3&gt;思路&lt;/h3&gt;
&lt;p&gt;根据以上的概念，那么，我们知道&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
window.devicePixelRatio = document.body.clientWidth / window.screen.width;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;如果屏幕分辨率宽是1080px，屏幕宽度为360px，那么DPR=1080/360=3。&lt;/p&gt;
&lt;p&gt;如果现在UI设计图也是1080px，那么前端工程师不想丢失任何细节的使用代码如何还原呢？&lt;/p&gt;
&lt;p&gt;可以设置屏幕宽度为1080px, 设置viewport属性initial-scale = 1/3;&lt;/p&gt;
&lt;p&gt;这样360px的屏幕就可以容纳1080px宽的内容了。&lt;/p&gt;
&lt;p&gt;但是每个手机的分辨率都不一样，那么如何来设置这个这个initial-scale呢？我们可以通过以下方式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; scale = 1 /&lt;span&gt; window.devicePixelRatio;
document.querySelector(&lt;/span&gt;'meta[name=&quot;viewport&quot;]').setAttribute('content', 'user-scalable=no,initial-scale=' + scale + ', maximum-scale=' + scale + ', minimum-scale=' + scale);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;将user-scalable设置为no, 不允许缩放，有缩放需要的，可以不设置&lt;/p&gt;
&lt;p&gt;之后如何设置某一个区块的宽，高，或者字体大小呢？&lt;/p&gt;
&lt;p&gt;我们还需要设置html标签，字体的大小，我习惯于使用设计图的宽/20来获取元素的rem数值。比如&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;UI设计图文字大小30px, 那么我习惯使用 font-size: 1.5rem;&lt;/li&gt;
&lt;li&gt;UI设计图图片宽100px, 我习惯使用 width: 5rem;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;那么我会设置html的font-size为 deviceWidht / (UI设计图宽/20);&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
var base = 720 / 20; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 720为UI设计稿的宽&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; fontSize = deviceWidth /&lt;span&gt; base;
document.documentElement.style.fontSize &lt;/span&gt;= fontSize + 'px';
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;结合以上，完整代码为：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
&lt;span&gt;var&lt;/span&gt; scale = 1 /&lt;span&gt; window.devicePixelRatio;
document.querySelector(&lt;/span&gt;'meta[name=&quot;viewport&quot;]').setAttribute('content', 'user-scalable=no,initial-scale=' + scale + ', maximum-scale=' + scale + ', minimum-scale=' +&lt;span&gt; scale);
window.onresize &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (base) {
　　&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; deviceWidth = (document.body.clientWidth &amp;lt; document.documentElement.clientWidth) ?&lt;span&gt; document.body.clientWidth : document.documentElement.clientWidth;
　　&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; screenWidth =&lt;span&gt; window.screen.width;
　　&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (deviceWidth / screenWidth !=&lt;span&gt; window.devicePixelRatio) {
　　　　document.querySelector(&lt;/span&gt;'meta[name=&quot;viewport&quot;]').setAttribute('content', 'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no'&lt;span&gt;);
　　　　deviceWidth &lt;/span&gt;= (document.body.clientWidth &amp;lt; document.documentElement.clientWidth) ?&lt;span&gt; document.body.clientWidth : document.documentElement.clientWidth;
　　}
　　&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; fontSize = deviceWidth /&lt;span&gt; base;
　　document.documentElement.style.fontSize &lt;/span&gt;= fontSize + 'px'&lt;span&gt;;
};
window.onresize(&lt;/span&gt;720&lt;span&gt;);
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上代码我放在&amp;lt;head&amp;gt;里面，在html标签渲染前就开始设置。&lt;/p&gt;
&lt;p&gt;一开始就根据DPR设置initial-scale，之后在onresize里面设置html字体大小。&lt;/p&gt;
&lt;p&gt;大家会注意到onresize里面有这样一段代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; deviceWidth = (document.body.clientWidth &amp;lt; document.documentElement.clientWidth) ?&lt;span&gt; document.body.clientWidth : document.documentElement.clientWidth;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; screenWidth =&lt;span&gt; window.screen.width;
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (deviceWidth / screenWidth !=&lt;span&gt; window.devicePixelRatio) {
　　document.querySelector(&lt;/span&gt;'meta[name=&quot;viewport&quot;]').setAttribute('content', 'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no'&lt;span&gt;);
　　deviceWidth &lt;/span&gt;= (document.body.clientWidth &amp;lt; document.documentElement.clientWidth) ?&lt;span&gt; document.body.clientWidth : document.documentElement.clientWidth;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这一段代码是为了兼容一部分旧款机器，这些机器无法正常的获取到DPR值，那么我们就只能设置屏幕页面内容宽度为设备宽度。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;有疑问，欢迎联系博主讨论。&lt;/p&gt;
</description>
<pubDate>Mon, 28 Jan 2019 07:25:00 +0000</pubDate>
<dc:creator>Bowen Huang</dc:creator>
<og:description>现在各种品牌的手机，有很多种不同的分辨率，为了做到优美的自适应，苦了各位前端开发人员，想了各种解决办法。随着css3的普及，现在各浏览器的兼容性也越来越好，我们已经不局限于使用px单位了，rem单位就</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/huangbx/p/css-responsive-rem-js.html</dc:identifier>
</item>
<item>
<title>【.NET Core项目实战-统一认证平台】第十四章 授权篇-自定义授权方式 - 金焰的世界</title>
<link>http://www.cnblogs.com/jackcao/p/10330397.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jackcao/p/10330397.html</guid>
<description>&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;上篇文章我介绍了如何强制令牌过期的实现，相信大家对&lt;code&gt;IdentityServer4&lt;/code&gt;的验证流程有了更深的了解，本篇我将介绍如何使用自定义的授权方式集成老的业务系统验证，然后根据不同的客户端使用不同的认证方式来集成到统一认证平台。&lt;/p&gt;
&lt;p&gt;.netcore项目实战交流群（637326624），有兴趣的朋友可以在群里交流讨论。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;一自定授权源码剖析&quot;&gt;一、自定授权源码剖析&lt;/h4&gt;
&lt;p&gt;当我们需要使用开源项目的某些功能时，最好了解实现的原理，才能正确和熟练使用功能，避免出现各种未知bug问题和出现问题无法解决的被动场面。&lt;/p&gt;
&lt;p&gt;在使用此功能前，我们需要了解完整的实现流程，下面我将从源码开始讲解&lt;code&gt;IdentityServer4&lt;/code&gt;是如何实现自定义的授权方式。&lt;/p&gt;
&lt;p&gt;从我之前的文章中我们知道授权方式是通过&lt;code&gt;Grant_Type&lt;/code&gt;的值来判断的，所以我们自定义的授权方式，也是通过此值来区分，所以需要了解自定义的值处理流程。&lt;code&gt;TokenRequestValidator&lt;/code&gt;是请求验证的方法，除了常规验证外，还增加了自定义的验证方式。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public async Task&amp;lt;TokenRequestValidationResult&amp;gt; ValidateRequestAsync(NameValueCollection parameters, ClientSecretValidationResult clientValidationResult)
{
    _logger.LogDebug(&quot;Start token request validation&quot;);

    _validatedRequest = new ValidatedTokenRequest
    {
        Raw = parameters ?? throw new ArgumentNullException(nameof(parameters)),
        Options = _options
    };

    if (clientValidationResult == null) throw new ArgumentNullException(nameof(clientValidationResult));

    _validatedRequest.SetClient(clientValidationResult.Client, clientValidationResult.Secret, clientValidationResult.Confirmation);

    /////////////////////////////////////////////
    // check client protocol type
    /////////////////////////////////////////////
    if (_validatedRequest.Client.ProtocolType != IdentityServerConstants.ProtocolTypes.OpenIdConnect)
    {
        LogError(&quot;Client {clientId} has invalid protocol type for token endpoint: expected {expectedProtocolType} but found {protocolType}&quot;,
                 _validatedRequest.Client.ClientId,
                 IdentityServerConstants.ProtocolTypes.OpenIdConnect,
                 _validatedRequest.Client.ProtocolType);
        return Invalid(OidcConstants.TokenErrors.InvalidClient);
    }

    /////////////////////////////////////////////
    // check grant type
    /////////////////////////////////////////////
    var grantType = parameters.Get(OidcConstants.TokenRequest.GrantType);
    if (grantType.IsMissing())
    {
        LogError(&quot;Grant type is missing&quot;);
        return Invalid(OidcConstants.TokenErrors.UnsupportedGrantType);
    }

    if (grantType.Length &amp;gt; _options.InputLengthRestrictions.GrantType)
    {
        LogError(&quot;Grant type is too long&quot;);
        return Invalid(OidcConstants.TokenErrors.UnsupportedGrantType);
    }

    _validatedRequest.GrantType = grantType;

    switch (grantType)
    {
        case OidcConstants.GrantTypes.AuthorizationCode:
            return await RunValidationAsync(ValidateAuthorizationCodeRequestAsync, parameters);
        case OidcConstants.GrantTypes.ClientCredentials:
            return await RunValidationAsync(ValidateClientCredentialsRequestAsync, parameters);
        case OidcConstants.GrantTypes.Password:
            return await RunValidationAsync(ValidateResourceOwnerCredentialRequestAsync, parameters);
        case OidcConstants.GrantTypes.RefreshToken:
            return await RunValidationAsync(ValidateRefreshTokenRequestAsync, parameters);
        default://统一的自定义的验证方式
            return await RunValidationAsync(ValidateExtensionGrantRequestAsync, parameters);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面代码可以看出，除了内置的授权方式，其他的都是用&lt;code&gt;ValidateExtensionGrantRequestAsync&lt;/code&gt;来进行验证，详细的验证规则继续分析实现过程。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;private async Task&amp;lt;TokenRequestValidationResult&amp;gt; ValidateExtensionGrantRequestAsync(NameValueCollection parameters)
{
    _logger.LogDebug(&quot;Start validation of custom grant token request&quot;);

    /////////////////////////////////////////////
    // 校验客户端是否开启了此授权方式
    /////////////////////////////////////////////
    if (!_validatedRequest.Client.AllowedGrantTypes.Contains(_validatedRequest.GrantType))
    {
        LogError(&quot;{clientId} does not have the custom grant type in the allowed list, therefore requested grant is not allowed&quot;, _validatedRequest.Client.ClientId);
        return Invalid(OidcConstants.TokenErrors.UnsupportedGrantType);
    }

    /////////////////////////////////////////////
    // 判断是否注入了此自定义的授权实现
    /////////////////////////////////////////////
    if (!_extensionGrantValidator.GetAvailableGrantTypes().Contains(_validatedRequest.GrantType, StringComparer.Ordinal))
    {
        LogError(&quot;No validator is registered for the grant type: {grantType}&quot;, _validatedRequest.GrantType);
        return Invalid(OidcConstants.TokenErrors.UnsupportedGrantType);
    }

    /////////////////////////////////////////////
    // 校验是否支持scope
    /////////////////////////////////////////////
    if (!await ValidateRequestedScopesAsync(parameters))
    {
        return Invalid(OidcConstants.TokenErrors.InvalidScope);
    }

    /////////////////////////////////////////////
    // 调用自定义的验证实现方法
    /////////////////////////////////////////////
    var result = await _extensionGrantValidator.ValidateAsync(_validatedRequest);

    if (result == null)
    {
        LogError(&quot;Invalid extension grant&quot;);
        return Invalid(OidcConstants.TokenErrors.InvalidGrant);
    }

    if (result.IsError)
    {
        if (result.Error.IsPresent())
        {
            LogError(&quot;Invalid extension grant: {error}&quot;, result.Error);
            return Invalid(result.Error, result.ErrorDescription, result.CustomResponse);
        }
        else
        {
            LogError(&quot;Invalid extension grant&quot;);
            return Invalid(OidcConstants.TokenErrors.InvalidGrant, customResponse: result.CustomResponse);
        }
    }

    if (result.Subject != null)
    {
        /////////////////////////////////////////////
        // 判断当前的用户是否可用
        /////////////////////////////////////////////
        var isActiveCtx = new IsActiveContext(
            result.Subject,
            _validatedRequest.Client,
            IdentityServerConstants.ProfileIsActiveCallers.ExtensionGrantValidation);

        await _profile.IsActiveAsync(isActiveCtx);

        if (isActiveCtx.IsActive == false)
        {
            // todo: raise event?

            LogError(&quot;User has been disabled: {subjectId}&quot;, result.Subject.GetSubjectId());
            return Invalid(OidcConstants.TokenErrors.InvalidGrant);
        }

        _validatedRequest.Subject = result.Subject;
    }

    _logger.LogDebug(&quot;Validation of extension grant token request success&quot;);
    return Valid(result.CustomResponse);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从代码中可以看出，实现流程如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1、客户端是否配置了自定义的授权方式。&lt;/li&gt;
&lt;li&gt;2、是否注入了自定义的授权实现。&lt;/li&gt;
&lt;li&gt;3、授权的scope客户端是否有权限。&lt;/li&gt;
&lt;li&gt;4、使用自定义的授权验证方式校验请求数据是否合法。&lt;/li&gt;
&lt;li&gt;5、判断是否有有效数据信息，可自行实现接口。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;从源码中，可以发现流程已经非常清晰了，核心类&lt;code&gt;ExtensionGrantValidator&lt;/code&gt;实现了自定义授权的校验过程，进一步分析下此类的代码实现。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;using IdentityServer4.Models;
using Microsoft.Extensions.Logging;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;

namespace IdentityServer4.Validation
{
    /// &amp;lt;summary&amp;gt;
    /// Validates an extension grant request using the registered validators
    /// &amp;lt;/summary&amp;gt;
    public class ExtensionGrantValidator
    {
        private readonly ILogger _logger;
        private readonly IEnumerable&amp;lt;IExtensionGrantValidator&amp;gt; _validators;

        /// &amp;lt;summary&amp;gt;
        /// Initializes a new instance of the &amp;lt;see cref=&quot;ExtensionGrantValidator&quot;/&amp;gt; class.
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;validators&quot;&amp;gt;The validators.&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;logger&quot;&amp;gt;The logger.&amp;lt;/param&amp;gt;
        public ExtensionGrantValidator(IEnumerable&amp;lt;IExtensionGrantValidator&amp;gt; validators, ILogger&amp;lt;ExtensionGrantValidator&amp;gt; logger)
        {
            if (validators == null)
            {
                _validators = Enumerable.Empty&amp;lt;IExtensionGrantValidator&amp;gt;();
            }
            else
            {
                _validators = validators;
            }

            _logger = logger;
        }

        /// &amp;lt;summary&amp;gt;
        /// Gets the available grant types.
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public IEnumerable&amp;lt;string&amp;gt; GetAvailableGrantTypes()
        {
            return _validators.Select(v =&amp;gt; v.GrantType);
        }

        /// &amp;lt;summary&amp;gt;
        /// Validates the request.
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;request&quot;&amp;gt;The request.&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public async Task&amp;lt;GrantValidationResult&amp;gt; ValidateAsync(ValidatedTokenRequest request)
        {
            var validator = _validators.FirstOrDefault(v =&amp;gt; v.GrantType.Equals(request.GrantType, StringComparison.Ordinal));

            if (validator == null)
            {
                _logger.LogError(&quot;No validator found for grant type&quot;);
                return new GrantValidationResult(TokenRequestErrors.UnsupportedGrantType);
            }

            try
            {
                _logger.LogTrace(&quot;Calling into custom grant validator: {type}&quot;, validator.GetType().FullName);

                var context = new ExtensionGrantValidationContext
                {
                    Request = request
                };
            
                await validator.ValidateAsync(context);
                return context.Result;
            }
            catch (Exception e)
            {
                _logger.LogError(1, e, &quot;Grant validation error: {message}&quot;, e.Message);
                return new GrantValidationResult(TokenRequestErrors.InvalidGrant);
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面代码可以发现，自定义授权方式，只需要实现&lt;code&gt;IExtensionGrantValidator&lt;/code&gt;接口即可，然后支持多个自定义授权方式的共同使用。&lt;/p&gt;
&lt;p&gt;到此整个验证过程解析完毕了，然后再查看下生成Token流程，实现方法为&lt;code&gt;TokenResponseGenerator&lt;/code&gt;，这个方法并不陌生，前几篇介绍不同的授权方式都介绍了，所以直接看实现代码。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public virtual async Task&amp;lt;TokenResponse&amp;gt; ProcessAsync(TokenRequestValidationResult request)
{
    switch (request.ValidatedRequest.GrantType)
    {
        case OidcConstants.GrantTypes.ClientCredentials:
            return await ProcessClientCredentialsRequestAsync(request);
        case OidcConstants.GrantTypes.Password:
            return await ProcessPasswordRequestAsync(request);
        case OidcConstants.GrantTypes.AuthorizationCode:
            return await ProcessAuthorizationCodeRequestAsync(request);
        case OidcConstants.GrantTypes.RefreshToken:
            return await ProcessRefreshTokenRequestAsync(request);
        default://自定义授权生成Token的方式
            return await ProcessExtensionGrantRequestAsync(request);
    }
}

protected virtual Task&amp;lt;TokenResponse&amp;gt; ProcessExtensionGrantRequestAsync(TokenRequestValidationResult request)
{
    Logger.LogTrace(&quot;Creating response for extension grant request&quot;);
    return ProcessTokenRequestAsync(request);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实现的代码方式和客户端模式及密码模式一样，这里就不多介绍了。&lt;/p&gt;
&lt;p&gt;最后我们查看下是如何注入&lt;code&gt;IExtensionGrantValidator&lt;/code&gt;，是否对外提供接入方式，发现&lt;code&gt;IdentityServer4&lt;/code&gt;提供了&lt;code&gt;AddExtensionGrantValidator&lt;/code&gt;扩展方法，我们自己实现自定义授权后添加即可，详细实现代码如下。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public static IIdentityServerBuilder AddExtensionGrantValidator&amp;lt;T&amp;gt;(this IIdentityServerBuilder builder)
            where T : class, IExtensionGrantValidator
        {
            builder.Services.AddTransient&amp;lt;IExtensionGrantValidator, T&amp;gt;();
            return builder;
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;二自定义授权实现&quot;&gt;二、自定义授权实现&lt;/h4&gt;
&lt;p&gt;现在开始开发第一个自定义授权方式，&lt;code&gt;GrantType&lt;/code&gt;定义为&lt;code&gt;CzarCustomUser&lt;/code&gt;，然后实现&lt;code&gt;IExtensionGrantValidator&lt;/code&gt;接口，为了演示方便，我新建一个测试用户表，用来模拟老系统的登录方式。&lt;/p&gt;
&lt;pre class=&quot;mssql&quot;&gt;
&lt;code&gt;Create Table CzarCustomUser
(
    iid int identity,
    username varchar(50),
    usertruename varchar(50),
    userpwd varchar(100)
)
--插入测试用户密码信息，测试数据密码不加密
insert into CzarCustomUser values('jinyancao','金焰的世界','777777')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后把实现验证的方法,由于代码太简单，我就直接贴代码如下。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;namespace Czar.AuthPlatform.Web.Application.IRepository
{
    public interface ICzarCustomUserRepository
    {
        /// &amp;lt;summary&amp;gt;
        /// 根据账号密码获取用户实体
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;uaccount&quot;&amp;gt;账号&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;upassword&quot;&amp;gt;密码&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        CzarCustomUser FindUserByuAccount(string uaccount, string upassword);
    }
}

namespace Czar.AuthPlatform.Web.Application.Repository
{
    public class CzarCustomUserRepository : ICzarCustomUserRepository
    {
        private readonly string DbConn = &quot;&quot;;
        public CzarCustomUserRepository(IOptions&amp;lt;CzarConfig&amp;gt; czarConfig)
        {
            DbConn = czarConfig.Value.DbConnectionStrings;
        }

        /// &amp;lt;summary&amp;gt;
        /// 根据账号密码获取用户实体
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;uaccount&quot;&amp;gt;账号&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;upassword&quot;&amp;gt;密码&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public CzarCustomUser FindUserByuAccount(string uaccount, string upassword)
        {
            using (var connection = new SqlConnection(DbConn))
            {
                string sql = @&quot;SELECT * from CzarCustomUser where username=@uaccount and userpwd=upassword &quot;;
                var result = connection.QueryFirstOrDefault&amp;lt;CzarCustomUser&amp;gt;(sql, new { uaccount, upassword });
                return result;
            }
        }
    }
}

namespace Czar.AuthPlatform.Web.Application.IServices
{
    public interface ICzarCustomUserServices
    {
        /// &amp;lt;summary&amp;gt;
        /// 根据账号密码获取用户实体
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;uaccount&quot;&amp;gt;账号&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;upassword&quot;&amp;gt;密码&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        CzarCustomUser FindUserByuAccount(string uaccount, string upassword);
    }
}

namespace Czar.AuthPlatform.Web.Application.Services
{
    public class CzarCustomUserServices: ICzarCustomUserServices
    {
        private readonly ICzarCustomUserRepository czarCustomUserRepository;
        public CzarCustomUserServices(ICzarCustomUserRepository czarCustomUserRepository)
        {
            this.czarCustomUserRepository = czarCustomUserRepository;
        }

        /// &amp;lt;summary&amp;gt;
        /// 根据账号密码获取用户实体
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;uaccount&quot;&amp;gt;账号&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;upassword&quot;&amp;gt;密码&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public CzarCustomUser FindUserByuAccount(string uaccount, string upassword)
        {
            return czarCustomUserRepository.FindUserByuAccount(uaccount, upassword);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在可以定义自定义的授权类型了，我起名为&lt;code&gt;CzarCustomUserGrantValidator&lt;/code&gt;，实现代码如下。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;using Czar.AuthPlatform.Web.Application.IServices;
using IdentityServer4.Models;
using IdentityServer4.Validation;
using System.Threading.Tasks;

namespace Czar.AuthPlatform.Web.Application.Ids4
{
    /// &amp;lt;summary&amp;gt;
    /// 金焰的世界
    /// 2019-01-28
    /// 自定义用户授权
    /// &amp;lt;/summary&amp;gt;
    public class CzarCustomUserGrantValidator : IExtensionGrantValidator
    {
        public string GrantType =&amp;gt; &quot;CzarCustomUser&quot;;

        private readonly ICzarCustomUserServices czarCustomUserServices;

        public CzarCustomUserGrantValidator(ICzarCustomUserServices czarCustomUserServices)
        {
            this.czarCustomUserServices = czarCustomUserServices;
        }

        public Task ValidateAsync(ExtensionGrantValidationContext context)
        {
            var userName = context.Request.Raw.Get(&quot;czar_name&quot;);
            var userPassword = context.Request.Raw.Get(&quot;czar_password&quot;);

            if (string.IsNullOrEmpty(userName) || string.IsNullOrEmpty(userPassword))
            {
                context.Result = new GrantValidationResult(TokenRequestErrors.InvalidGrant);
            }
            //校验登录
            var result = czarCustomUserServices.FindUserByuAccount(userName, userPassword);
            if (result==null)
            {
                context.Result = new GrantValidationResult(TokenRequestErrors.InvalidGrant);
            }
            //添加指定的claims
            context.Result = new GrantValidationResult(
                         subject: result.iid.ToString(),
                         authenticationMethod: GrantType,
                         claims: result.Claims);
            return Task.CompletedTask;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这就实现了自定义授权的功能，是不是很简单呢？然后添加此扩展方法。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;services.AddIdentityServer(option =&amp;gt;
            {
                option.PublicOrigin = Configuration[&quot;CzarConfig:PublicOrigin&quot;];
            })
                .AddDeveloperSigningCredential()
                .AddDapperStore(option =&amp;gt;
                {
                    option.DbConnectionStrings = Configuration[&quot;CzarConfig:DbConnectionStrings&quot;];
                })
                .AddResourceOwnerValidator&amp;lt;CzarResourceOwnerPasswordValidator&amp;gt;()
                .AddProfileService&amp;lt;CzarProfileService&amp;gt;()
                .AddSecretValidator&amp;lt;JwtSecretValidator&amp;gt;()
                //添加自定义授权
                .AddExtensionGrantValidator&amp;lt;CzarCustomUserGrantValidator&amp;gt;()；&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在是不是就可以使用自定义授权的方式了呢？打开&lt;code&gt;PostMan&lt;/code&gt;测试，按照源码解析和设计参数，测试信息如下，发现报错，原来是还未配置好客户端访问权限，开启权限测试如下。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529926/201901/1529926-20190128152319676-315104525.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;三客户端权限配置&quot;&gt;三、客户端权限配置&lt;/h4&gt;
&lt;p&gt;在使用&lt;code&gt;IdentityServer4&lt;/code&gt;时我们一定要理解整个验证流程。根据这次配置，我再梳理下流程如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1、校验客户端client_id和Client_Secret。&lt;/li&gt;
&lt;li&gt;2、校验客户端是否有当前的授权方式。&lt;/li&gt;
&lt;li&gt;3、校验是否有请求scope权限。&lt;/li&gt;
&lt;li&gt;4、如果非客户端验证，校验账号密码或自定义规则是否正确。&lt;/li&gt;
&lt;li&gt;5、非客户端验证，校验授权信息是否有效。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;通过此流程会发现我们缺少授权方式配置，所以请求时提示上面的提示，既然知道原因了，那就很简单的来实现，添加客户端自定义授权模式。此信息是在&lt;code&gt;ClientGrantTypes&lt;/code&gt;表中，字段为客户端ID和授权方式。我测试的客户端ID为21，授权方式为&lt;code&gt;CzarCustomUser&lt;/code&gt;，那直接使用SQL语句插入关系，然后再测试。&lt;/p&gt;
&lt;pre class=&quot;mssql&quot;&gt;
&lt;code&gt;INSERT INTO ClientGrantTypes VALUES(21,'CzarCustomUser');&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529926/201901/1529926-20190128152340610-1941860445.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;发现可以获取到预期结果，然后查看access_token是什么内容，显示如下。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529926/201901/1529926-20190128152358606-1334221466.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;显示的信息和我们定义的信息相同，而且可以通过&lt;code&gt;amr&lt;/code&gt;来区分授权类型，不同的业务系统使用不同的认证方式，然后统一集成到认证平台即可。&lt;/p&gt;
&lt;h4 id=&quot;四总结与思考&quot;&gt;四、总结与思考&lt;/h4&gt;
&lt;p&gt;本篇我介绍了自定义授权方式，从源码解析到最后的实现详细讲解了实现原理，并使用测试的用户来实现自定义的认证流程，本篇涉及的知识点不多，但是非常重要，因为我们在使用统一身份认证时经常会遇到多种认证方式的结合，和多套不同应用用户的使用，在掌握了授权原理后，就能在不同的授权方式中切换的游刃有余。&lt;/p&gt;
&lt;p&gt;思考下，有了这些知识后，关于短信验证码登录和扫码登录是不是有心理有底了呢？如果自己实现这类登录应该都知道从哪里下手了吧。&lt;/p&gt;
&lt;p&gt;下篇我将介绍常用登录的短信验证码授权方式，尽情期待吧。&lt;/p&gt;
</description>
<pubDate>Mon, 28 Jan 2019 07:24:00 +0000</pubDate>
<dc:creator>金焰的世界</dc:creator>
<og:description>' 【.NET Core项目实战 统一认证平台】开篇及目录索引 ' 上篇文章我介绍了如何强制令牌过期的实现，相信大家对 的验证流程有了更深的了解，本篇我将介绍如何使用自定义的授权方式集成老的业务系统验</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jackcao/p/10330397.html</dc:identifier>
</item>
<item>
<title>15分钟在笔记本上搭建 Kubernetes + Istio开发环境 - 阿里云云栖社区</title>
<link>http://www.cnblogs.com/yunqishequ/p/10330383.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yunqishequ/p/10330383.html</guid>
<description>&lt;p&gt;&lt;img title=&quot;image&quot; src=&quot;https://yqfile.alicdn.com/14ea648b9153d3f9c889f7204bdceedeec284dc7.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;11月13~15日，KubeCon 上海大会召开，云原生是这个秋天最火热的技术。很多同学来问如何上手 Kubernetes和Istio 服务网格开发。本文将帮助你利用Docker CE桌面版，15分钟在笔记本上从零搭建 Kubernetes + Istio开发环境，开启云原生之旅。&lt;/p&gt;
&lt;p&gt;说明：本文测试通过环境 Docker CE 18.09 (Kubernetes 1.10.3) 以及 Istio 1.0.4&lt;/p&gt;
&lt;p&gt;先决条件，你需要一个 Docker for Mac或者Docker for Windows的安装包，如果没有请下载下载 Docker CE最新版本。由于Kubernetes大量的容器镜像在 gcr.io， 无法在国内保证稳定的访问。我们提供了一些工具脚本，帮助从阿里云镜像服务下载所需镜像&lt;/p&gt;
&lt;p&gt;首先，&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs php&quot;&gt;git &lt;span class=&quot;hljs-keyword&quot;&gt;clone https:&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;1&quot;&gt;Docker for Mac 开启 Kubernetes&lt;/h3&gt;
&lt;p&gt;为 Docker daemon 配置 Docker Hub 的中国官方镜像加速 &lt;code&gt;https://registry.docker-cn.com&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;mirror&quot; src=&quot;https://yqfile.alicdn.com/979d0e121d6f9929a6d117f277003ac83664718c.png&quot; alt=&quot;mirror&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可选操作: 为 Kubernetes 配置 CPU 和 内存资源，建议分配 4GB 或更多内存。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;resource&quot; src=&quot;https://yqfile.alicdn.com/61ae11ebd5b54db875390a1f2a5f36c6a4a32154.png&quot; alt=&quot;resource&quot;/&gt;&lt;/p&gt;
&lt;p&gt;预先从阿里云Docker镜像服务下载 Kubernetes 所需要的镜像, 可以通过修改 &lt;code&gt;images.properties&lt;/code&gt; 文件加载你自己需要的镜像&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs&quot;&gt;./load_images.sh&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;开启 Kubernetes，并等待 Kubernetes 开始运行&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;k8s&quot; src=&quot;https://yqfile.alicdn.com/c54a96b9309adb38687f9e0678bbc207a3634cb2.png&quot; alt=&quot;k8s&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;2&quot;&gt;Docker for Windows 开启 Kubernetes&lt;/h3&gt;
&lt;p&gt;为 Docker daemon 配置 Docker Hub 的中国官方镜像加速 &lt;code&gt;https://registry.docker-cn.com&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;mirror_win&quot; src=&quot;https://yqfile.alicdn.com/bc03181b01d378ae32145614ada40872810290e6.png&quot; alt=&quot;mirror_win&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可选操作: 为 Kubernetes 配置 CPU 和 内存资源，建议分配 4GB 或更多内存。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;resource_win&quot; src=&quot;https://yqfile.alicdn.com/17f7c7923fa86fbf1600e717973975970ce49af0.png&quot; alt=&quot;resource_win&quot;/&gt;&lt;/p&gt;
&lt;p&gt;预先从阿里云Docker镜像服务下载 Kubernetes 所需要的镜像, 可以通过修改 &lt;code&gt;images.properties&lt;/code&gt; 文件加载你自己需要的镜像&lt;/p&gt;
&lt;p&gt;使用 Bash shell&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs&quot;&gt;./load_images.sh&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用 PowerShell&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs css&quot;&gt; .\&lt;span class=&quot;hljs-selector-tag&quot;&gt;load_images&lt;span class=&quot;hljs-selector-class&quot;&gt;.ps1&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;说明: 如果因为安全策略无法执行 PowerShell 脚本，请在 “以管理员身份运行” 的 PowerShell 中执行 &lt;code&gt;Set-ExecutionPolicy RemoteSigned&lt;/code&gt; 命令。&lt;/p&gt;
&lt;p&gt;开启 Kubernetes，并等待 Kubernetes 开始运行&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;k8s_win&quot; src=&quot;https://yqfile.alicdn.com/047e1311a6625257ca909ef6cf2525518d9a1aec.png&quot; alt=&quot;k8s_win&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;3&quot;&gt;配置 Kubernetes&lt;/h3&gt;
&lt;p&gt;可选操作: 切换Kubernetes运行上下文至 docker-for-desktop&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs sql&quot;&gt;kubectl config &lt;span class=&quot;hljs-keyword&quot;&gt;use-&lt;span class=&quot;hljs-keyword&quot;&gt;context docker-&lt;span class=&quot;hljs-keyword&quot;&gt;for-desktop&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;验证 Kubernetes 集群状态&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs nginx&quot;&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;kubectl cluster-&lt;span class=&quot;hljs-literal&quot;&gt;info
kubectl get nodes&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;部署 Kubernetes dashboard&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs ruby&quot;&gt;kubectl create -f &lt;span class=&quot;hljs-symbol&quot;&gt;https:/&lt;span class=&quot;hljs-regexp&quot;&gt;/raw.githubusercontent.com/kubernetes&lt;span class=&quot;hljs-regexp&quot;&gt;/dashboard/master&lt;span class=&quot;hljs-regexp&quot;&gt;/src/deploy&lt;span class=&quot;hljs-regexp&quot;&gt;/recommended/kubernetes-dashboard.yaml&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot;&gt;kubectl create &lt;span class=&quot;hljs-_&quot;&gt;-f kubernetes-dashboard.yaml&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;开启 API Server 访问代理&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs nginx&quot;&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;kubectl proxy&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过如下 URL 访问 Kubernetes dashboard&lt;/p&gt;
&lt;p&gt;http://localhost:8001/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy/#!/overview?namespace=default&lt;/p&gt;
&lt;p&gt;说明：如果测试 Istio，不需要安装 Ingress，如果需要 Ingress 可以参考 https://github.com/AliyunContainerService/k8s-for-docker-desktop 中 Ingress相关章节&lt;/p&gt;
&lt;h3 id=&quot;4&quot;&gt;安装 Helm&lt;/h3&gt;
&lt;p&gt;可以根据文档安装 helm https://github.com/helm/helm/blob/master/docs/install.md&lt;/p&gt;
&lt;h4 id=&quot;5&quot;&gt;在 Mac OS 上安装&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs nginx&quot;/&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;6&quot;&gt;在Windows上安装&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs nginx&quot;/&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;7&quot;&gt;配置 Istio&lt;/h3&gt;
&lt;p&gt;可以根据文档安装 Istio https://istio.io/docs/setup/kubernetes/&lt;/p&gt;
&lt;h4 id=&quot;8&quot;&gt;下载 Istio 1.0.4 并安装 CLI&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot;&gt;curl -L https://git.io/getLatestIstio | sh -
&lt;span class=&quot;hljs-built_in&quot;&gt;cd istio-1.0.4/
&lt;span class=&quot;hljs-built_in&quot;&gt;export PATH=&lt;span class=&quot;hljs-variable&quot;&gt;$PWD/bin:&lt;span class=&quot;hljs-variable&quot;&gt;$PATH&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在Windows上，您可以手工下载Istio安装包，或者把&lt;code&gt;getLatestIstio.ps1&lt;/code&gt;拷贝到你希望下载 Istio 的目录，并执行 - 说明：根据社区提供的安装脚本修改而来&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs css&quot;&gt;.\&lt;span class=&quot;hljs-selector-tag&quot;&gt;getLatestIstio&lt;span class=&quot;hljs-selector-class&quot;&gt;.ps1&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;9&quot;&gt;通过 Helm chart 安装 Istio&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs sql&quot;&gt;helm &lt;span class=&quot;hljs-keyword&quot;&gt;install &lt;span class=&quot;hljs-keyword&quot;&gt;install/kubernetes/helm/istio &lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;10&quot;&gt;查看 istio 发布状态&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs nginx&quot;&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;helm status istio&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;11&quot;&gt;为 &lt;code&gt;default&lt;/code&gt; 名空间开启自动 sidecar 注入&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cpp&quot;&gt;kubectl label &lt;span class=&quot;hljs-keyword&quot;&gt;namespace &lt;span class=&quot;hljs-keyword&quot;&gt;default istio-injection=enabled
kubectl get &lt;span class=&quot;hljs-keyword&quot;&gt;namespace -L istio-injection&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;12&quot;&gt;安装 Book Info 示例&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot;&gt;kubectl apply &lt;span class=&quot;hljs-_&quot;&gt;-f samples/bookinfo/platform/kube/bookinfo.yaml
kubectl apply &lt;span class=&quot;hljs-_&quot;&gt;-f samples/bookinfo/networking/bookinfo-gateway.yaml&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;确认示例应用在运行中&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;export GATEWAY_URL=localhost:80
curl -o /dev/null &lt;span class=&quot;hljs-_&quot;&gt;-s -w &lt;span class=&quot;hljs-string&quot;&gt;&quot;%{http_code}\n&quot; http://&lt;span class=&quot;hljs-variable&quot;&gt;${GATEWAY_URL}/productpage&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以通过浏览器访问&lt;/p&gt;
&lt;p&gt;http://localhost/productpage&lt;/p&gt;
&lt;p&gt;说明：如果当前80端口已经被占用或保留，我们可以编辑 &lt;code&gt;install/kubernetes/helm/istio/values.yaml&lt;/code&gt; 文件中&lt;br/&gt;Gateway 端口进行调整，比如将 80 端口替换为 8888 端口&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot;&gt;      &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后执行如下命令并生效&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs sql&quot;&gt;kubectl &lt;span class=&quot;hljs-keyword&quot;&gt;delete service istio-ingressgateway -n istio-&lt;span class=&quot;hljs-keyword&quot;&gt;system
helm &lt;span class=&quot;hljs-keyword&quot;&gt;upgrade istio &lt;span class=&quot;hljs-keyword&quot;&gt;install/kubernetes/helm/istio&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;13&quot;&gt;学习 Istio&lt;/h4&gt;
&lt;p&gt;大家参照 Istio 开始学习吧， https://istio.io/zh/docs/examples/bookinfo/&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;image&quot; src=&quot;https://yqfile.alicdn.com/40e125d97f498bf5cb5e7e5f4c08f5f648d34510.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;14&quot;&gt;删除实例应用&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs&quot;&gt;samples/bookinfo/platform/kube/cleanup.sh&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;15&quot;&gt;卸载 Istio&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs sql&quot;&gt;helm del &lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;16&quot;&gt;总结&lt;/h2&gt;
&lt;p data-spm-anchor-id=&quot;a2c4e.11153940.blogcont672675.i0.419916a3wcoS0e&quot;&gt;阿里云Kubernetes服务 (ACK) 已经对 Istio提供了支持，并将Istio和阿里云进行了深度整合，比如可以通过阿里云日志服务支持基于Jaeger的全链路监控，基于云监控提升Istio可观测性和报警能力等。后续也将进一步简化Kubernetes和Istio的开发者体验，让大家方便地把 Kubernetes + Istio 应用无缝迁移上云。&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;a href=&quot;https://yq.aliyun.com/articles/672675?utm_content=g_1000040177&quot; target=&quot;_blank&quot;&gt;原文链接&lt;/a&gt;&lt;br/&gt;本文为云栖社区原创内容，未经允许不得转载。&lt;/p&gt;
</description>
<pubDate>Mon, 28 Jan 2019 07:21:00 +0000</pubDate>
<dc:creator>阿里云云栖社区</dc:creator>
<og:description>11月13~15日，KubeCon 上海大会召开，云原生是这个秋天最火热的技术。很多同学来问如何上手 Kubernetes和Istio 服务网格开发。本文将帮助你利用Docker CE桌面版，15分钟</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yunqishequ/p/10330383.html</dc:identifier>
</item>
<item>
<title>RabbitMQ消息可靠性分析和应用 - 烟花易冷人憔悴</title>
<link>http://www.cnblogs.com/FireworksEasyCool/p/10330225.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/FireworksEasyCool/p/10330225.html</guid>
<description>&lt;h3&gt;&lt;span&gt;RabbitMQ流程简介（带Exchange）&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;       RabbitMQ使用一些机制来保证可靠性，如持久化、消费确认及发布确认等。&lt;/p&gt;
&lt;p&gt;       先看以下这个图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1508611/201901/1508611-20190128143713643-676884213.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;






&lt;p&gt;       P为生产者，X为中转站（Exchange），红色部分为消息队列，C1、C2为消费者。&lt;/p&gt;
&lt;p&gt;       整个流程分成三部分：第一，生产者生产消息，发送到中转站；第二，中转站按定义的规则转发消息到消息队列；第三，消费者从消息队列获取消息进行消费（处理）。&lt;/p&gt;
&lt;hr/&gt;
&lt;h3&gt;&lt;span&gt;RabbitMQ消息可靠性分析和应用&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;       应用代码均使用C#客户端代码实现。&lt;/p&gt;

&lt;h4&gt;&lt;span&gt;一、发布确认&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;       生产者生产消息，发送到中转站的过程中，可能会因为网络丢包、网络故障等问题造成消息丢失。为了确保生产者发送的消息不会丢失，RabbitMQ提供了发布确认（Publisher Confirms）机制，从而提高消息的可靠性（注意：发布确认机制不能和事务机制一起使用）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;       单条消息发布确认：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
                channel.ConfirmSelect();//发布确认机制
                string message = &quot;msg&quot;;
                var body = Encoding.UTF8.GetBytes(message);
                channel.BasicPublish(
                        exchange: &quot;MarkTopicChange&quot;,
                        routingKey: &quot;MarkRouteKey.one&quot;,
                        basicProperties: null,
                        body: body
                        );
                bool isPublished = channel.WaitForConfirms();//通道（channel）里消息发送成功返回true
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       使用channel.ConfirmSelect，一旦信道进入确认模式，所有在该信道上面发布的消息都会被指派一个唯一的ID（从1开始）。消息被投递到所有匹配的队列之后，RabbitMQ就会发送（Basic.Ack）给生产者（包含消息的唯一ID），生产者从而知道消息发送成功。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;       多条消息发布确认：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
                channel.ConfirmSelect();//发布确认机制
                foreach (var itemMsg in lstMsg)
                {
                    byte[] sendBytes = Encoding.UTF8.GetBytes(itemMsg);
                    //发布消息
                    channel.BasicPublish(
                        exchange: &quot;MarkTopicChange&quot;,
                        routingKey: &quot;MarkRouteKey.one&quot;,
                        basicProperties: null,
                        body: sendBytes
                        );
                }
                bool isAllPublished = channel.WaitForConfirms();//通道（channel）里所有消息均发送才返回true　
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       注意：多消息发布确认机制情况下，倘若要发送100条消息，发送90条后，突然网络故障，后面的消息发送失败了，那么isAllPublished返回的是false，而前面90条消息已经发送到消息队列了。我们还不知道哪些消息是发送失败的，所以很多条消息发布确认，建议分几次发送或多通道发送。&lt;/p&gt;
&lt;p&gt;       此外，需要确保在中转站（Exchange）的消息可以顺利到达消息队列。&lt;/p&gt;
&lt;p&gt;       （1）首先需要定义匹配的Exchange和Queue，根据Exchange的类型和routingKey确定转发的关系。&lt;/p&gt;
&lt;p&gt;       （2）设置&lt;span&gt;BasicPublish&lt;/span&gt;方法中&lt;span&gt;mandatory&lt;/span&gt;参数为true，然后监听Exchange中没有匹配的队列的消息，然后进行相操作。&lt;/p&gt;
&lt;p&gt;       （3）确保消息队列有足够内存存储消息。&lt;/p&gt;
&lt;p&gt;       RabbitMQ默认配置&lt;span&gt;vm_memory_high_watermark&lt;/span&gt;为0.4。意思是控制消息占40%内存左右。&lt;span&gt;vm_memory_high_watermark_paging_ratio&lt;/span&gt;为0.5，当消息占用内存超过50%，RabbitMQ会把消息转移到磁盘上以释放内存。当磁盘剩余空间小于阀值&lt;span&gt;disk_free_limit&lt;/span&gt;（默认为50M），所有生产者阻塞，避免充满磁盘，导致所有的写操作失败。&lt;/p&gt;
&lt;p&gt;       RabbitMQ配置文件一般在%APPDATA%\RabbitMQ\rabbitmq.config.&lt;/p&gt;
&lt;p&gt;       %APPDATA% 一般为 C:\Users\%USERNAME%\AppData\Roaming（Windows环境）&lt;/p&gt;
&lt;hr/&gt;
&lt;h4&gt;&lt;span&gt;二、持久化&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;       消息存放到消息队列后，在不配置消息持久化的情况下，若服务器重启、关闭或宕机等，消息都会丢失。配置持久化可以有效提高消息的可靠性。持久化需要同时配置消息持久化和队列持久化。单配置消息持久化，队列消失了，消息没有地方存放；单配置队列持久化，队列还在，消息没了。&lt;/p&gt;
&lt;p&gt;       队列持久化在定义队列时候配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
                //定义队列
                channel.QueueDeclare(
                    queue: &quot;Mark_Queue&quot;, //队列名称
                    durable: true, //队列磁盘持久化                   
                    exclusive: false,//是否排他的，false。如果一个队列声明为排他队列，该队列首次声明它的连接可见，并在连接断开时自动删除
                    autoDelete: false,//是否自动删除，一般设成false
                    arguments: null
                    );
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　消息持久化在发布消息时候配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
                //消息持久化，把DeliveryMode设成2
                IBasicProperties properties = channel.CreateBasicProperties();
                properties.DeliveryMode = 2;
                    //发布消息
                    channel.BasicPublish(
                        exchange: &quot;MarkTopicChange&quot;,
                        routingKey: &quot;MarkRouteKey.one&quot;,
                        basicProperties: properties,
                        body: sendBytes
                        );
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       如何配置了事务机制或发布确认（publisher confirm）机制，服务端的返回Basic.Ack是在消息落盘之后执行的，进一步的提高了消息的可靠性。&lt;/p&gt;
&lt;p&gt;       为了防止磁盘损坏带来的消息丢失，可以配置镜像队列，这里不作介绍。&lt;/p&gt;
&lt;hr/&gt;
&lt;h4&gt;&lt;span&gt;三、消费确认&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;       为了确保消息被消费者消费，RabbitMQ提供消费确认模式（consumer Acknowledgements）。自动确认模式，当消费者&lt;span&gt;&lt;strong&gt;成功接收到&lt;/strong&gt;&lt;/span&gt;消息后，自动通知RabbitMQ，把消息队列中相应消息删除。这很大程度上满足不了我们，假如消费者接收到消息后，服务器宕机，消息还没处理完成，这样就会造成消息丢失。手动确认模式，当消费者&lt;span&gt;&lt;strong&gt;成功处理完&lt;/strong&gt;&lt;/span&gt;消息后，手动发消息通知RabbitMQ，把消息队列中相应消息删除。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;45&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
                    consumer.Received += (model, ea) =&amp;gt;
                    {
                        var body = ea.Body;
                        var message = Encoding.UTF8.GetString(body);
                        var routingKey = ea.RoutingKey;
                        Console.WriteLine(&quot; [x] Received '{0}':'{1}'&quot;,
                                          routingKey,
                                          message);

                    //确认该消息已被消费,发删除消息给RabbitMQ，把消息队列中的消息删除 
                    channel.BasicAck(ea.DeliveryTag, false);
                    //消费消息失败，拒绝此消息，重回队列，让它可以继续发送到其他消费者 
                    //channel.BasicReject(ea.DeliveryTag, true);
                    //消费消息失败，拒绝多条消息，重回队列，让它们可以继续发送到其他消费者 
                    //channel.BasicNack(ea.DeliveryTag, true, true);
                    };
                    //手动确认消息，把autoAck设成false
                    channel.BasicConsume(queue: &quot;Mark_Queue&quot;,
                                         autoAck: false,
                                         consumer: consumer);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       这里值得注意的是，消息处理完成后，一定要把处理完成的消息发送到RabbitMQ（&lt;span&gt;channel.BasicAck(ea.DeliveryTag, false)&lt;/span&gt;），不然RabbitMQ会一直等待，从而造成内存泄露。若处理消息过程中发生异常，可以使用&lt;span&gt;channel.BasicReject(ea.DeliveryTag, true)&lt;/span&gt;来拒绝此消息，让它重回队列。若RabbitMQ收不到消费者任何确认消息的信号（包括确认信号，拒绝信号灯），直到此消费者断开连接，消息才能重回队列，继续发送到其他消费者。&lt;/p&gt;
&lt;p&gt;       提醒一下，假如消费者消费消息的方法不支持并发（取决于需求），可以限制消费者每次只接收一条消息。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
channel.BasicQos(0, 1, false);
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Mon, 28 Jan 2019 06:56:00 +0000</pubDate>
<dc:creator>烟花易冷人憔悴</dc:creator>
<og:description>RabbitMQ流程简介（带Exchange） RabbitMQ使用一些机制来保证可靠性，如持久化、消费确认及发布确认等。 先看以下这个图： P为生产者，X为中转站（Exchange），红色部分为消息</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/FireworksEasyCool/p/10330225.html</dc:identifier>
</item>
<item>
<title>最佳实践 | OceanBase事务引擎的技术创新 - 蚂蚁金服技术</title>
<link>http://www.cnblogs.com/antfin/p/10330182.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/antfin/p/10330182.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;颜然，蚂蚁金服 OceanBase 团队资深技术专家，OceanBase 初创成员之一，目前负责事务引擎以及性能优化相关的研发工作。&lt;br/&gt;以下为演讲实录：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先，我们先来聊一个大家都很感兴趣的话题：跟已有的经典数据库比如：Oracle、SQL Server等，OceanBase跟他们最大的区别在哪里？&lt;strong&gt;OceanBase是一个云原生的数据库&lt;/strong&gt;。而我们所做的软件全部是基于硬件的基础之上。那么，我们首先就需要了解现在的硬件到底处在什么水平？&lt;br/&gt;&lt;img src=&quot;https://s1.51cto.com/images/blog/201901/28/861f6e8b7b9bd9939013ec46c5c4e767.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，IBM的解决方案是最为大家所熟识的，从五十多年前的System 360到去年新出的IBM z14，时至今日依然还有很多机构在沿用这套解决方案。&lt;br/&gt;&lt;img src=&quot;https://s1.51cto.com/images/blog/201901/28/103c2cdb4c9449d428ad603cb8c1f5a5.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们每天都在说云计算，那么到底什么是云计算？云计算不是从石头缝里蹦出来的解决方案，它最早起源于DEC的小型机。DEC是和IBM大型机同时代的产物，以较低的价格解决存储和计算的需求。它与IBM大型机的区别在于：DEC价格低，获得方式更灵活。&lt;/p&gt;
&lt;p&gt;DEC之后被基于芯片的解决方案打破了，诸如SUN工作站的解决方案提供了更好的性能和更低价格，平台也更通用。再之后PC Server接过接力棒，此时的CPU、内存、存储可以来自于不同的厂商，但大家组合起来以后仍然可以提供一套标准化的计算和存储的平台。&lt;/p&gt;
&lt;p&gt;相比较IBM大型机，基于PC Server的数据中心以一种更产业链化的方式提供了计算和存储的解决方案，具有更好的性价比，也更易于扩展。但是IBM大型机是软硬一体化设计，这也是大型机满足需求可以采用很多硬件层面的解决思路。例如，金融业务对于高可靠性的需求，大型机是在硬件层面做了多种可靠性保障，从存储到内存甚至CPU都是有冗余策略来支持。但是PC Server的单台机器的故障率相对来说是高的，所以需要使用完全不同的思路来解决业务高可靠和高可用的需求。&lt;/p&gt;
&lt;p&gt;此处引用OceanBase团队创始人阳振坤的一句话——“&lt;strong&gt;计算机天然不适合数据库，但数据库天然选择了计算机&lt;/strong&gt;”。为什么计算机天然不适合数据库？因为在处理数据的时候，一个非常关键的问题就是数据的可靠安全和一致。而计算机的硬件天然具有各种概率的损坏，不管是掉电，软件出Bug，操作系统有问题，还是整个机房都挂掉，计算机是天然会出错的。但我们要解决的问题又是不能出错，所以在计算机上去解决数据库的可靠安全一致性的问题，其实是一个非常大的挑战。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;要在一个更低可靠性的机器上实现更可靠的数据库的事务服务能力，这就是我们当前所面临的严峻挑战&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;oceanbase事务&quot;&gt;OceanBase事务&lt;/h2&gt;
&lt;p&gt;当然，有挑战的地方就有机遇。OceanBase在面对这样的挑战之下我们做了什么？在这样的一个基于PC Server的云化环境下，&lt;strong&gt;OceanBase实现了弹性扩展的能力，同时实现了不依赖高端硬件解决数据库事务的高可靠和高可用的能力。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;OceanBase所依赖的硬件条件是一套通用的云化环境。但在这个硬件基础上，我们依然可以做到数据库的事务，同样能够实现高性能，甚至能够支撑金融级的可靠性。&lt;/p&gt;
&lt;p&gt;何谓金融级可靠性？每个人都会有切身的感受。比如说你发了一条帖子，但是这条帖子丢了，你可能会不爽，但是不至于非常难受。再换一个场景，今天你给朋友转账100元，你朋友却只收到98元，此时你的内心一定是恐惧的。所以在这种金融级场景下，必须做到的就是为用户提供充足的保障，这就叫做金融级可靠性。但金融级可靠性的难度在于对细节的处理能力。细节是魔鬼，我们在做数据库软件的时候，需要对细节的把控能力极强。&lt;br/&gt;&lt;img src=&quot;https://s1.51cto.com/images/blog/201901/28/a4cdba419892b6accc65710c06cfa0b1.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里要重点提到的几点，其实就延续着数据库事务的几个重要的特性。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;OceanBase架构下事务 ACID 的实现方式：&lt;/li&gt;
&lt;li&gt;Durability：事务日志使用 Paxos做多副本同步&lt;/li&gt;
&lt;li&gt;Atomicity：使用两阶段提交保证跨机事务原子性&lt;/li&gt;
&lt;li&gt;Isolation：使用多版本机制进行并发控制&lt;/li&gt;
&lt;li&gt;Consistency：保证唯一性约束&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;oceanbase存储引擎&quot;&gt;OceanBase存储引擎&lt;/h2&gt;
&lt;p&gt;OceanBase的架构基于LSM Tree。为什么会基于LSM Tree？它有哪些特点？&lt;/p&gt;
&lt;p&gt;在经典的数据库里，所有的数据是分片保存在持久化存储里的，比如磁盘或者SSD。在读取数据的时候，一定要先把它放在内存里。当需要做修改的时候，也要把一块数据放在内存里。如果内存满了之后，就会把这个页面刷回去。&lt;br/&gt;&lt;img src=&quot;https://s1.51cto.com/images/blog/201901/28/a6ff64cd993a28e4f302808e05a9423f.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;/p&gt;
&lt;p&gt;OceanBase所基于的LSMTree，可以把更多的修改更集中地放在一个内存结构里。我们的做法是在后台定期地做这件事情，前台把数据尽可能存更久的时间，然后再让后台去做合并。OceanBase有一个机制叫每日合并，也就是说如果前台能存一天的时间，我们到了每天夜里才做后台合并这件事情。&lt;/p&gt;
&lt;p&gt;OceanBase会在系统内部做调度，第一台机器在后台刷脏页的时候，让业务的流量都跑在其他机器上，就可以不影响前台的业务。当第一台完成后，再把业务的流量切回来，然后让第二台机器做后台刷脏页的操作。我们通过这种“轮转合并”的方法解决在集群环境下利用不同机器不同服务的时间差去做刷脏页这件事情。&lt;/p&gt;
&lt;p&gt;OceanBase事务引擎设计也利用了LSM Tree的结构，让事务的所有执行状态都保存在内存中，只有事务提交之后才会把事务修改的数据持久化。所以在实现事务原子性时，不需要做undo。这样OceanBase可以以一个更简洁的方式来做数据库的事务。这个就是OceanBase存储引擎的整体逻辑。&lt;/p&gt;
&lt;h2 id=&quot;oceanbase内存事务引擎&quot;&gt;OceanBase内存事务引擎&lt;/h2&gt;
&lt;p&gt;OceanBase的事务执行操作都在内存里发生。内存跟硬盘一个最大的差别，就是内存是可以以字节为单位进行随机寻址的，而这带来的一个非常大的好处就是使得数据结构更丰富了。&lt;br/&gt;&lt;img src=&quot;https://s1.51cto.com/images/blog/201901/28/79e36884d46718a04a29c66d36660304.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;/p&gt;
&lt;p&gt;举个例子，如上图表格中的数据，现在要对第一行数据进行更新：条件是给Han加50万薪水。现在需要给这张表格中这一列对应的Han写一个新的值。在内存里的表示方法就是这样一个链表。如果Han涨了薪水以后突然希望换部门接受全新的挑战，我们就需要再做一次更新操作。只需要在这个列表里串上一次新的更新把他的部门进行更改。他从研发部门转到投资部门了，那我们就把这一列对应的修改记录在这里。&lt;/p&gt;
&lt;p&gt;这个是数据库内部基于多版本的一种并发控制，记录了每一次更新发生的时间，保证了修改操作跟读取操作不会互相影响。因为即使一行数据被改了，我们还是可以直接拿到历史数据。基于链表的数据结构对程序员来说是非常友好的。&lt;/p&gt;
&lt;p&gt;相比较经典的基于硬盘的数据库，无论数据读取还是写入都是定长数据块为单位的操作，表达信息的方式也是基于块的。OceanBase的方式带来的一个最大的好处就是大大提升了表达的简洁性，也就是它本身的操作效率要高特别多。这也解释了了为什么OceanBase能在目前的硬件环境下提供更强的事务处理能力，这是其中一个很重要的原因。&lt;/p&gt;
&lt;p&gt;我们再回顾一下OceanBase的架构，OceanBase把数据分片了之后，可以在多个集群里的多台机器上把数据扩展出去做存储，它提供了线性扩展能力。&lt;br/&gt;&lt;img src=&quot;https://s1.51cto.com/images/blog/201901/28/fc65588d7a65f945ece6970df5fc3407.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;/p&gt;
&lt;p&gt;像上图所示同样一份数据会有多个副本，比如P0在三台机器上，这三台机器可能在同一个机房，也可能来自不同机房。但是它们会服务于同一份数据，其中只有一个是当前的主，它负责做数据库的操作，并且把数据库事务的修改同步到其他的机器上。我们这里提到OceanBase的数据组织与分布的目的就是要解决后面数据库的可靠性问题。&lt;/p&gt;
&lt;h2 id=&quot;可靠性-vs-可用性&quot;&gt;可靠性 vs 可用性&lt;/h2&gt;
&lt;p&gt;高可靠和高可用是被所有数据库产品广泛提及的概念。那么，可靠性和可用性到底意味着什么？&lt;/p&gt;
&lt;p&gt;传统的数据库，ACID的理论里并没有availability这个概念，只保证了durable。但是数据不丢，却不一定能保证服务的连续性。但是failover的能力在实际的系统中却是非常重要的。所以所有的商业数据库都有对应的解决可用性的方案。其中经典的就是基于主备同步的方案，当主坏掉的时候，备可以继续提供服务，这就是在解决可用性的问题。&lt;br/&gt;&lt;img src=&quot;https://s1.51cto.com/images/blog/201901/28/78adc4d1004b8b7f83d38b1fc5183629.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;/p&gt;
&lt;p&gt;OceanBase采用Paxos协议来解决可靠性和可用性的问题。任何一个数据库的事务要做持久化，事务的日志都需要持久到多个副本上。在三个副本之中，我们认为只要持久化到两个副本的硬盘上，就定义为这个事务是成功的。也就是说有任何一台机器坏了的时候，至少还有一个副本在。&lt;/p&gt;
&lt;p&gt;那么，反过来思考是不是同步到越多的机器上越好？如果三个副本都同步到，是不是就更加可靠了？这就是可用性所带来的问题，如果其中有一台机器网络出现故障，或者系统负载太高无法响应，你是否认为这个事务成功？&lt;/p&gt;
&lt;p&gt;如果要求三个都成功的话，就不能认为它成功，因为有一台机器没响应。Paxos协议只要求两个机器同步到，就是即便有一个没有应答，我们依然认为这个事务是成功的，因为多数派成功了。&lt;/p&gt;
&lt;p&gt;保证三个里面有一个坏掉是不受影响的，同时也不影响系统的持续服务。这是在可靠性和可用性中间的一个很好的平衡。如果你需要更高的保障，就可以选择五个副本的方案，这样可以保证有两台机器出故障的时候，同样既不影响可靠性，也不影响可用性，这是一个很重要的平衡点。&lt;/p&gt;
&lt;p&gt;所以我们在ACID里再加入一个A，也就是我们既要让事务有可靠性，也要让事务的处理能力有可用性。&lt;/p&gt;
&lt;h2 id=&quot;分布式事务二阶段提交协议&quot;&gt;分布式事务二阶段提交协议&lt;/h2&gt;
&lt;p&gt;数据库在单机上写日志一定是只写自己机器上的日志文件，如果写成功了就成功，不成功就失败。但是在多台机器上的时候就涉及到：A机器成功了，B机器失败了。这件事情该怎么办？&lt;br/&gt;&lt;img src=&quot;https://s1.51cto.com/images/blog/201901/28/1c25d559ac42a61662cadfbb202addc0.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;两阶段提交协议的存在就是为了解决这个问题，也就是说提交再也不能是一次性就成功的，它要涉及到多个机器之间达成一致，每台机器都成功了最终才能定义为成功。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;事实上，两阶段提交协议在实际应用中非常少。为什么呢？主要因为它很复杂，虽然理论很漂亮，但是存在的细节问题特别多。但是在OceanBase的业务场景下又一定要用两阶段提交协议来解决。&lt;/p&gt;
&lt;p&gt;OceanBase的基础是每一个参与者都是高可用的，因为OceanBase使用了Paxos协议保证了Partition高可用，所以任何一台机器的故障不会导致服务停止，这是一个很重要的前提。另外，因为Paxos同步引入了跨网络、跨机房的同步延迟，原始的两阶段提交协议多次写日志会带来较多的开销，OceanBase做了一件事情就是让协调者不写日志，只保留内存状态。它带来的一个非常重要的好处就是commit延迟低。同时因为所有参与者都是高可用的，我们不会出现两阶段状态一般会出现的问题，比如协调者宕机卡住的问题。&lt;/p&gt;
&lt;h2 id=&quot;oceanbase事务隔离&quot;&gt;OceanBase事务隔离&lt;/h2&gt;
&lt;p&gt;事务隔离涉及到事务的并发控制怎么做，OceanBase使用的是多版本并发控制。读取请求会拿到当前系统的publish version作为读取的快照版本。事务提交的时候会生成一个版本号，版本号是连续递增的，作为本事务所有修改数据的版本。&lt;br/&gt;&lt;img src=&quot;https://s1.51cto.com/images/blog/201901/28/e2b0f4f98c70e9cb4a9e5aef2f0c72ad.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;/p&gt;
&lt;p&gt;单机场景下，一条日志就能决定这个事务最终是否能够提交。那么这条日志的位置就决定了这个事务的版本号，它的版本号一定是递增连续的。但是在分布式事务参与进来之后，举个例子，就会出现230可能是一条prepare日志，prepare日志不代表这个事务能够提交，但是232可能是另外一个事务的commit日志，这也就意味着这个事务要commit的话，232版本就需要可读，但是230又处在行锁未解事务进行中的状态。这个时候就需要另外一种控制方法，对于两阶段提交的prepare和commit之间的事务，这些事务所有操作的行要锁住，不允许读取。&lt;/p&gt;
&lt;p&gt;这个影响很小是因为在prepare和commit之间不涉及到用户的任何干预，是一个毫秒级的操作，也就是说，这个行在提交的过程中会在一个很短的瞬间被锁住。这个瞬间里读取操作会等待事务提交掉，再去判断该不该读这一行的数据。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;基于以上的技术创新，OceanBase真正实现了在云环境下事务的高可靠、高可用，同时还具有很好的性能。希望OceanBase可以帮助更多的业务解决数据存储和查询的需求，不再受困于传统商业数据库的价格高、扩展性差的问题。&lt;/p&gt;
</description>
<pubDate>Mon, 28 Jan 2019 06:44:00 +0000</pubDate>
<dc:creator>蚂蚁金服技术</dc:creator>
<og:description>颜然，蚂蚁金服 OceanBase 团队资深技术专家，OceanBase 初创成员之一，目前负责事务引擎以及性能优化相关的研发工作。 以下为演讲实录： 首先，我们先来聊一个大家都很感兴趣的话题：跟已有</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/antfin/p/10330182.html</dc:identifier>
</item>
<item>
<title>求求你规范下你的代码风格 - 帅地</title>
<link>http://www.cnblogs.com/kubidemanong/p/10330142.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kubidemanong/p/10330142.html</guid>
<description>&lt;p&gt;代码风格并不影响程序的运行，也不会给你的程序带来潜在的危险。但一段好的代码风格，能让人阅读起来特别舒服，特别的阅读别人代码的时候，有些人的代码可以说是完全不注意空格、缩进、大小写的，看起来特别不舒服。&lt;/p&gt;
&lt;p&gt;给人好的印象，从一段代码风格开始。今天我总结了几个最常用到的代码规范、可以说你每时每刻都会接触到的了，也比较简单，如果你平时没有按这些规范写的话，建议慢慢改过来。&lt;/p&gt;
&lt;h3 id=&quot;类名&quot;&gt;1. 类名&lt;/h3&gt;
&lt;p&gt;类名采用&lt;strong&gt;大驼峰&lt;/strong&gt;的命名形式，所谓大驼峰就是首字母大写，例如UpperCameCase。&lt;/p&gt;
&lt;p&gt;抽象类命名使用 Abstract 或 Base 开头；异常类使用 Exception 结尾；测试类命名以测试的类名开始，以 Test 结尾。&lt;/p&gt;
&lt;p&gt;枚举类名带上 Enum 作为后缀，&lt;strong&gt;枚举成员&lt;/strong&gt;名称需要大写，&lt;strong&gt;单词间&lt;/strong&gt;用下画线隔开。&lt;/p&gt;
&lt;h3 id=&quot;包名&quot;&gt;2. 包名&lt;/h3&gt;
&lt;p&gt;包名统一使用小写，&lt;strong&gt;点分隔符&lt;/strong&gt;之间有且仅有一个自然语义的英语单词。一般单词使用单数形式，但是类名如果有复数含义的话，则可以使用复数形式。&lt;/p&gt;
&lt;h3 id=&quot;变量&quot;&gt;3. 变量&lt;/h3&gt;
&lt;p&gt;变量可分为&lt;strong&gt;不可变量(常量)&lt;/strong&gt;和&lt;strong&gt;可变变量&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(1). 常量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 Java 中，常量一般指 final 关键字修饰的变量。&lt;/p&gt;
&lt;p&gt;1、&lt;strong&gt;全局常量&lt;/strong&gt;和&lt;strong&gt;类内常量&lt;/strong&gt;的命名采用字母全部大写，单词之间加&lt;strong&gt;下画线&lt;/strong&gt;的方式。&lt;/p&gt;
&lt;p&gt;所谓全局常量指的是&lt;strong&gt;类的公开静态属性&lt;/strong&gt;，使用 public static final 修饰；类内常量指的是&lt;strong&gt;私有静态属性&lt;/strong&gt;，使用 private static final 修饰。&lt;/p&gt;
&lt;p&gt;2、&lt;strong&gt;局部常量&lt;/strong&gt;则采用&lt;strong&gt;小驼峰&lt;/strong&gt;的形式。所谓局部常量指的是方法内的常量。&lt;/p&gt;
&lt;p&gt;例子展示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Constant {
    //全局常量
    public static final String MY_NAME = &quot;shuaidi&quot;;
    //类内常量
    private static final String MY_SEX = &quot;男&quot;;
    
    public void tt(){
        //局部常量
        final String myName = &quot;shuaidi&quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;(2). 可变变量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可变变量一般常用&lt;strong&gt;小驼峰&lt;/strong&gt;的命名形式，如 myName ,小驼峰和大驼峰的区别就是，小驼峰首字母小写，而大驼峰首字母大写。不过需要注意的是，针对&lt;strong&gt;布尔类型&lt;/strong&gt;的变量，在命名的时候，不要用 &lt;strong&gt;is&lt;/strong&gt; 做前缀,否则部分框架在解析的时候会引起序列化错误。&lt;/p&gt;
&lt;p&gt;例如标识是否删除的成员变量 Boolean isDeleted, 它的 getter 方法也是 isDeleted()，框架在反向解析的时候，会误认为对应的属性名称为 deleted，从而引起错误。&lt;/p&gt;
&lt;h3 id=&quot;空格&quot;&gt;4. 空格&lt;/h3&gt;
&lt;p&gt;我发现很多人在写代码的时候，在运算符、赋值、参数等之间很少使用&lt;strong&gt;空格&lt;/strong&gt;来隔开各种元素之间的距离，例如&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//错误例子示范，注：里面的代码之间没啥联系，都是随意给出的。
int a=1
int b=a==1?1:2;
if(a==1&amp;amp;&amp;amp;b==2){
    print(a,b);//调用打印函数
}else{
    
}
public static void print(int a,int b){
    System.out.printf(a+b);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;像上面的这个例子中，就是几乎没用到空格的，代码看起来很紧，反正我看起来是很不舒服，特别的当代码很多的时候。&lt;/p&gt;
&lt;p&gt;下面是我给的关于加空格的几点建议：&lt;/p&gt;
&lt;p&gt;1、二目、三目运算符的左右两边都应该加一个空格。&lt;/p&gt;
&lt;p&gt;2、注释的双斜线与注释内容之间有且仅有一个空格。&lt;/p&gt;
&lt;p&gt;3、方法参数在定义和传入参数时，多个参数逗号后边都应该加空格。&lt;/p&gt;
&lt;p&gt;4、如果大括号为空，则简洁地写成{}即可，大括号中间无须换行和加空格。&lt;/p&gt;
&lt;p&gt;5、左右小括号与括号内部的相邻字符之间不要出现空格。&lt;/p&gt;
&lt;p&gt;6、左大括号前需要加空格。&lt;/p&gt;
&lt;p&gt;所以，修改后如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int a = 1;
int b = a == 1 ? 1 : 2;
if(a == 1 &amp;amp;&amp;amp; b == 2) {
    print(a, b);
} else {}

public static void print(int a, int b) {
    System.out.printf(a + b);// 调用打印函数
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样看起来舒服多了，特别是在括号内参数多的的时候。&lt;/p&gt;
&lt;h3 id=&quot;控制语句&quot;&gt;5. 控制语句&lt;/h3&gt;
&lt;p&gt;控制语句可以说是最容易出现 bug 的地方，所以代码风格的约束极为重要，而不是天马行空地乱跳。因此，控制语句必须遵循如下约定：&lt;/p&gt;
&lt;p&gt;1、在 if, for, while, do-while 等语句中必须使用大括号，即使只有一行代码，也应该加上大括号。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int sum = 0;
for(int i = 0; i &amp;lt; 10; i++) {
    sum += i;// 尽管只有一行/
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、在条件表达式中不允许出现赋值操作，也不允许在判断表达式中出现复杂的所及组合。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//复杂的多级组合
if((file.open(fileName, &quot;w&quot;) != null) &amp;amp;&amp;amp; (...) &amp;amp;&amp;amp; (...)) {
    dosomething();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;争取的做法应该是将复杂的多级运算赋值给一个具有业务含义的布尔变量。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;boolean existed = (file.open(fileName, &quot;w&quot;) != null) &amp;amp;&amp;amp; (...) &amp;amp;&amp;amp; (...);

if(existed) {
    dosomething();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3、多层嵌套不能超过三层。&lt;/p&gt;
&lt;h3 id=&quot;关于缩进与空格&quot;&gt;6. 关于缩进与空格&lt;/h3&gt;
&lt;p&gt;一个缩进的距离等于四个空格的距离，但究竟是要使用 Tab 缩进来调距离还是用四个空格代替一个缩进来调距离，这个貌似存在争议，有些大佬建议用 Tab 键，有些大佬建议用空格。我在《码出高效Java开发手册》里，本书的作者是推荐&lt;strong&gt;四个空格缩进&lt;/strong&gt;，禁止使用Tab键。&lt;/p&gt;
&lt;p&gt;当然，你在使用IDE的时候，当你换行时，很多编辑器是会帮你自动缩进的，大多数IDE都是默认四个空格来缩进。&lt;/p&gt;
&lt;p&gt;不过很多 IDE 工具提供了 Tab 键与空格之间的快速转换设置。例如对于 IDEA 这个工具，要设置 Tab 键为四个空格时，可以在设置那里勾选 Use tab character(setting-&amp;gt;editor-&amp;gt;Code Style-&amp;gt;选择你想编辑的语言)；而在 Eclipse 中，就得勾选 Insert spaces for tabs。&lt;/p&gt;
&lt;p&gt;上面讲的这几点，可以说是无时无刻都在和他们打交道的了，其他比较少接触的我就不列出来了。你平时有木按照这种风格来写呢？&lt;/p&gt;
&lt;p&gt;文章首发于我的公众号「&lt;strong&gt;苦逼的码农&lt;/strong&gt;」，原文链接：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUxNzg0MDc1Mg==&amp;amp;mid=2247485028&amp;amp;idx=1&amp;amp;sn=09ea534be019e454171fd1e790f4b79e&amp;amp;chksm=f9934c7bcee4c56dc83268d1537b99c2de78167f2f3f73d98859a5d85aac6e374bbb1f9a97d9&amp;amp;token=1714351639&amp;amp;lang=zh_CN#rd&quot;&gt;求求你规范下你的代码风格&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 28 Jan 2019 06:36:00 +0000</pubDate>
<dc:creator>帅地</dc:creator>
<og:description>代码风格并不影响程序的运行，也不会给你的程序带来潜在的危险。但一段好的代码风格，能让人阅读起来特别舒服，特别的阅读别人代码的时候，有些人的代码可以说是完全不注意空格、缩进、大小写的，看起来特别不舒服。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kubidemanong/p/10330142.html</dc:identifier>
</item>
<item>
<title>kubernetes系列08—service资源详解 - alonghub</title>
<link>http://www.cnblogs.com/along21/p/10330076.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/along21/p/10330076.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;strong&gt;本文收录在&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/along21/p/8116905.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;容器技术学习系列文章总目录&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;1、认识service&lt;/h2&gt;
&lt;h3&gt;&lt;strong&gt;1.1 &lt;span&gt;为什么要使用&lt;/span&gt;&lt;span&gt;service&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　Kubernetes Pod &lt;span&gt;是有生命周期的，它们可以被创建，也可以被销毁，然而一旦被销毁生命就永远结束。 通过&lt;/span&gt;&lt;span&gt; ReplicationController &lt;/span&gt;&lt;span&gt;能够动态地创建和销毁&lt;/span&gt;&lt;span&gt; Pod&lt;/span&gt;&lt;span&gt;（例如，需要进行扩缩容，或者执行&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;滚动升级）。 每个&lt;/span&gt;&lt;span&gt; Pod &lt;/span&gt;&lt;span&gt;都会获取它自己的&lt;/span&gt; &lt;span&gt;IP&lt;/span&gt; &lt;span&gt;地址，即使这些&lt;/span&gt; &lt;span&gt;IP&lt;/span&gt; &lt;span&gt;地址不总是稳定可依赖的。 这会导致一个问题：在&lt;/span&gt; &lt;span&gt;Kubernetes&lt;/span&gt; &lt;span&gt;集群中，如果一组&lt;/span&gt;&lt;span&gt; Pod&lt;/span&gt;&lt;span&gt;（称为&lt;/span&gt; &lt;span&gt;backend&lt;/span&gt;&lt;span&gt;）为其它&lt;/span&gt;&lt;span&gt; Pod &lt;/span&gt;&lt;span&gt;（称为&lt;/span&gt; &lt;span&gt;frontend&lt;/span&gt;&lt;span&gt;）提供服务，那么那些&lt;/span&gt;&lt;strong&gt; frontend &lt;span&gt;该如何发现，并连接到这组&lt;/span&gt;&lt;span&gt; Pod &lt;/span&gt;&lt;span&gt;中的哪些&lt;/span&gt; &lt;span&gt;backend&lt;/span&gt;&lt;/strong&gt; &lt;span&gt;呢？答案是：&lt;/span&gt;Service&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;1.2 service&lt;span&gt;介绍&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　Kubernetes Service &lt;span&gt;定义了这样一种&lt;/span&gt;&lt;strong&gt;&lt;span&gt;抽象&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：一个&lt;/span&gt; Pod &lt;span&gt;的逻辑分组，一种可以访问它们的策略&lt;/span&gt; &lt;span&gt;——&lt;/span&gt; &lt;span&gt;通常称为微服务。 这一组&lt;/span&gt;&lt;span&gt; Pod &lt;/span&gt;&lt;span&gt;能够被&lt;/span&gt;&lt;span&gt; Service &lt;/span&gt;&lt;span&gt;访问到，通常是通过&lt;/span&gt;&lt;span&gt; Label Selector&lt;/span&gt;&lt;span&gt;（下面我们会讲到我们为什么需要一个没有&lt;/span&gt;&lt;span&gt;label selector&lt;/span&gt;&lt;span&gt;的服务）实现的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　举个例子，考虑一个图片处理&lt;/span&gt; backend&lt;span&gt;，它运行了&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;个副本。这些副本是可互换的&lt;/span&gt; &lt;span&gt;—— frontend&lt;/span&gt; &lt;span&gt;不需要关心它们调用了哪个&lt;/span&gt; &lt;span&gt;backend&lt;/span&gt; &lt;span&gt;副本。 然而组成这一组&lt;/span&gt; &lt;span&gt;backend&lt;/span&gt; &lt;span&gt;程序的&lt;/span&gt;&lt;span&gt; Pod &lt;/span&gt;&lt;span&gt;实际上可能会发生变化，&lt;/span&gt;&lt;span&gt;frontend&lt;/span&gt; &lt;span&gt;客户端不应该也没必要知道，而且也不需要跟踪这一组&lt;/span&gt; &lt;span&gt;backend&lt;/span&gt; &lt;span&gt;的状态。&lt;/span&gt;&lt;span&gt; Service &lt;/span&gt;&lt;span&gt;定义的抽象能够解耦这种关联。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　对&lt;/span&gt; Kubernetes &lt;span&gt;集群中的应用，&lt;/span&gt;&lt;span&gt;Kubernetes&lt;/span&gt; &lt;span&gt;提供了简单的&lt;/span&gt;&lt;span&gt; Endpoints API&lt;/span&gt;&lt;span&gt;，只要&lt;/span&gt;&lt;span&gt; Service &lt;/span&gt;&lt;span&gt;中的一组&lt;/span&gt;&lt;span&gt; Pod &lt;/span&gt;&lt;span&gt;发生变更，应用程序就会被更新。 对非&lt;/span&gt; &lt;span&gt;Kubernetes&lt;/span&gt; &lt;span&gt;集群中的应用，&lt;/span&gt;&lt;span&gt;Kubernetes&lt;/span&gt; &lt;span&gt;提供了基于&lt;/span&gt; &lt;span&gt;VIP&lt;/span&gt; &lt;span&gt;的网桥的方式访问&lt;/span&gt;&lt;span&gt; Service&lt;/span&gt;&lt;span&gt;，再由&lt;/span&gt;&lt;span&gt; Service &lt;/span&gt;&lt;span&gt;重定向到&lt;/span&gt; &lt;span&gt;backend Pod&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;1.3 &lt;span&gt;三种代理模式&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt; userspace &lt;span&gt;代理模式（&lt;/span&gt;&lt;span&gt;K8S 1.1&lt;/span&gt;&lt;span&gt;之前版本）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; iptables &lt;span&gt;代理模式（&lt;/span&gt;&lt;span&gt;K8S 1.10&lt;/span&gt;&lt;span&gt;之前版本）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; ipvs &lt;span&gt;代理模式（&lt;/span&gt;&lt;span&gt;K8S 1.11&lt;/span&gt; &lt;span&gt;之后版本，激活&lt;/span&gt;&lt;span&gt;ipvs&lt;/span&gt;&lt;span&gt;需要修改配置）&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;&lt;strong&gt;1.3.1 userspace &lt;span&gt;代理模式&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;　　这种模式，&lt;/span&gt;kube-proxy &lt;span&gt;会监视&lt;/span&gt; &lt;span&gt;Kubernetes master&lt;/span&gt; &lt;span&gt;对&lt;/span&gt;&lt;span&gt; Service &lt;/span&gt;&lt;span&gt;对象和&lt;/span&gt;&lt;span&gt; Endpoints &lt;/span&gt;&lt;span&gt;对象的添加和移除。 对每个&lt;/span&gt;&lt;span&gt; Service&lt;/span&gt;&lt;span&gt;，它会在本地&lt;/span&gt; &lt;span&gt;Node&lt;/span&gt; &lt;span&gt;上打开一个端口（随机选择）。 任何连接到&lt;/span&gt;&lt;span&gt;“&lt;/span&gt;&lt;span&gt;代理端口&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;span&gt;的请求，都会被代理到&lt;/span&gt;&lt;span&gt; Service &lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;backend Pods &lt;/span&gt;&lt;span&gt;中的某个上面（如&lt;/span&gt;&lt;span&gt; Endpoints &lt;/span&gt;&lt;span&gt;所报告的一样）。 使用哪个&lt;/span&gt; &lt;span&gt;backend Pod&lt;/span&gt;&lt;span&gt;，是基于&lt;/span&gt;&lt;span&gt; Service &lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt; SessionAffinity &lt;/span&gt;&lt;span&gt;来确定的。 最后，它安装&lt;/span&gt; &lt;span&gt;iptables&lt;/span&gt; &lt;span&gt;规则，捕获到达该&lt;/span&gt;&lt;span&gt; Service &lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt; clusterIP&lt;/span&gt;&lt;span&gt;（是虚拟&lt;/span&gt; &lt;span&gt;IP&lt;/span&gt;&lt;span&gt;）和&lt;/span&gt;&lt;span&gt; Port &lt;/span&gt;&lt;span&gt;的请求，并重定向到代理端口，代理端口再代理请求到&lt;/span&gt; &lt;span&gt;backend Pod&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　网络返回的结果是，任何到达&lt;/span&gt; Service &lt;span&gt;的&lt;/span&gt; &lt;span&gt;IP:Port&lt;/span&gt; &lt;span&gt;的请求，都会被代理到一个合适的&lt;/span&gt; &lt;span&gt;backend&lt;/span&gt;&lt;span&gt;，不需要客户端知道关于&lt;/span&gt; &lt;span&gt;Kubernetes&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;Service&lt;/span&gt;&lt;span&gt;、或&lt;/span&gt;&lt;span&gt; Pod &lt;/span&gt;&lt;span&gt;的任何信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　默认的策略是，通过&lt;/span&gt; round-robin &lt;span&gt;算法来选择&lt;/span&gt; &lt;span&gt;backend Pod&lt;/span&gt;&lt;span&gt;。 实现基于客户端&lt;/span&gt; &lt;span&gt;IP&lt;/span&gt; &lt;span&gt;的会话亲和性，可以通过设置&lt;/span&gt;&lt;span&gt; service.spec.sessionAffinity &lt;/span&gt;&lt;span&gt;的值为&lt;/span&gt;&lt;span&gt; &quot;ClientIP&quot; &lt;/span&gt;&lt;span&gt;（默认值为&lt;/span&gt;&lt;span&gt; &quot;None&quot;&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1216496/201901/1216496-20190128141910636-598457561.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h4&gt; &lt;strong&gt;1.3.2 iptables &lt;span&gt;代理模式&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;　　这种模式，&lt;/span&gt;kube-proxy &lt;span&gt;会监视&lt;/span&gt; &lt;span&gt;Kubernetes master&lt;/span&gt; &lt;span&gt;对&lt;/span&gt;&lt;span&gt; Service &lt;/span&gt;&lt;span&gt;对象和&lt;/span&gt;&lt;span&gt; Endpoints &lt;/span&gt;&lt;span&gt;对象的添加和移除。 对每个&lt;/span&gt;&lt;span&gt; Service&lt;/span&gt;&lt;span&gt;，它会安装&lt;/span&gt; &lt;span&gt;iptables&lt;/span&gt; &lt;span&gt;规则，从而捕获到达该&lt;/span&gt;&lt;span&gt; Service &lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt; clusterIP&lt;/span&gt;&lt;span&gt;（虚拟&lt;/span&gt; &lt;span&gt;IP&lt;/span&gt;&lt;span&gt;）和端口的请求，进而将请求重定向到&lt;/span&gt;&lt;span&gt; Service &lt;/span&gt;&lt;span&gt;的一组&lt;/span&gt; &lt;span&gt;backend&lt;/span&gt; &lt;span&gt;中的某个上面。 对于每个&lt;/span&gt;&lt;span&gt; Endpoints &lt;/span&gt;&lt;span&gt;对象，它也会安装&lt;/span&gt; &lt;span&gt;iptables&lt;/span&gt; &lt;span&gt;规则，这个规则会选择一个&lt;/span&gt; &lt;span&gt;backend Pod&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　默认的策略是，随机选择一个&lt;/span&gt; backend&lt;span&gt;。 &lt;strong&gt;实现基于客户端&lt;/strong&gt;&lt;/span&gt; &lt;strong&gt;&lt;span&gt;IP&lt;/span&gt; &lt;span&gt;的会话亲和性，可以将&lt;/span&gt;&lt;span&gt; service.spec.sessionAffinity &lt;/span&gt;&lt;span&gt;的值设置为&lt;/span&gt;&lt;span&gt; &quot;ClientIP&quot; &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;（默认值为&lt;/span&gt;&lt;span&gt; &quot;None&quot;&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　和&lt;/span&gt; userspace &lt;span&gt;代理类似，网络返回的结果是，任何到达&lt;/span&gt;&lt;span&gt; Service &lt;/span&gt;&lt;span&gt;的&lt;/span&gt; &lt;span&gt;IP:Port&lt;/span&gt; &lt;span&gt;的请求，都会被代理到一个合适的&lt;/span&gt; &lt;span&gt;backend&lt;/span&gt;&lt;span&gt;，不需要客户端知道关于&lt;/span&gt; &lt;span&gt;Kubernetes&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;Service&lt;/span&gt;&lt;span&gt;、或&lt;/span&gt;&lt;span&gt; Pod &lt;/span&gt;&lt;span&gt;的任何信息。 这应该比&lt;/span&gt; &lt;span&gt;userspace&lt;/span&gt; &lt;span&gt;代理更快、更可靠。然而，不像&lt;/span&gt; &lt;span&gt;userspace&lt;/span&gt; &lt;span&gt;代理，如果初始选择的&lt;/span&gt;&lt;span&gt; Pod &lt;/span&gt;&lt;span&gt;没有响应，&lt;/span&gt;&lt;span&gt;iptables&lt;/span&gt; &lt;span&gt;代理能够自动地重试另一个&lt;/span&gt;&lt;span&gt; Pod&lt;/span&gt;&lt;span&gt;，所以它需要依赖&lt;/span&gt;&lt;span&gt; readiness probes&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1216496/201901/1216496-20190128141957624-2007587884.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h4&gt;&lt;strong&gt;1.3.3 ipvs&lt;span&gt;代理模式&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;　　ipvs (IP Virtual Server) &lt;span&gt;实现了传输层负载均衡，也就是我们常说的&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;层&lt;/span&gt;&lt;span&gt;LAN&lt;/span&gt;&lt;span&gt;交换，作为&lt;/span&gt; &lt;span&gt;Linux&lt;/span&gt; &lt;span&gt;内核的一部分。&lt;/span&gt;&lt;span&gt;ipvs&lt;/span&gt;&lt;span&gt;运行在主机上，在真实服务器集群前充当负载均衡器。&lt;/span&gt;&lt;span&gt;ipvs&lt;/span&gt;&lt;span&gt;可以将基于&lt;/span&gt;&lt;span&gt;TCP&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;UDP&lt;/span&gt;&lt;span&gt;的服务请求转发到真实服务器上，并使真实服务器的服务在单个&lt;/span&gt; &lt;span&gt;IP&lt;/span&gt; &lt;span&gt;地址上显示为虚拟服务。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在&lt;/span&gt;kubernetes v1.8 &lt;span&gt;中引入了&lt;/span&gt; &lt;span&gt;ipvs&lt;/span&gt; &lt;span&gt;模式，在&lt;/span&gt; &lt;span&gt;v1.9&lt;/span&gt; &lt;span&gt;中处于&lt;/span&gt; &lt;span&gt;beta&lt;/span&gt; &lt;span&gt;阶段，在&lt;/span&gt; &lt;span&gt;v1.11&lt;/span&gt; &lt;span&gt;中已经正式可用了。&lt;/span&gt; &lt;span&gt;iptables&lt;/span&gt; &lt;span&gt;模式在&lt;/span&gt; &lt;span&gt;v1.1&lt;/span&gt; &lt;span&gt;中就添加支持了，从&lt;/span&gt; &lt;span&gt;v1.2&lt;/span&gt; &lt;span&gt;版本开始&lt;/span&gt; &lt;span&gt;iptables&lt;/span&gt; &lt;span&gt;就是&lt;/span&gt; &lt;span&gt;kube-proxy&lt;/span&gt; &lt;span&gt;默认的操作模式，&lt;/span&gt;&lt;span&gt;ipvs&lt;/span&gt; &lt;span&gt;和&lt;/span&gt; &lt;span&gt;iptables&lt;/span&gt; &lt;span&gt;都是基于&lt;/span&gt;&lt;span&gt;netfilter&lt;/span&gt;&lt;span&gt;的，&lt;/span&gt; &lt;span&gt;ipvs&lt;/span&gt; &lt;span&gt;模式和&lt;/span&gt; &lt;span&gt;iptables&lt;/span&gt; &lt;span&gt;模式之间的差异：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt; ipvs &lt;span&gt;为大型集群提供了更好的可扩展性和性能&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; ipvs &lt;span&gt;支持比&lt;/span&gt; &lt;span&gt;iptables&lt;/span&gt; &lt;span&gt;更复杂的复制均衡算法（最小负载、最少连接、加权等等）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; ipvs &lt;span&gt;支持服务器健康检查和连接重试等功能&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　同时&lt;/span&gt;ipvs &lt;span&gt;也依赖&lt;/span&gt; &lt;span&gt;iptables&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;ipvs&lt;/span&gt; &lt;span&gt;会使用&lt;/span&gt; &lt;span&gt;iptables&lt;/span&gt; &lt;span&gt;进行包过滤、&lt;/span&gt;&lt;span&gt;SNAT&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;masquared(&lt;/span&gt;&lt;span&gt;伪装&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;。具体来说，&lt;/span&gt;&lt;span&gt;ipvs&lt;/span&gt; &lt;span&gt;将使用&lt;/span&gt;&lt;span&gt;ipset&lt;/span&gt;&lt;span&gt;来存储需要&lt;/span&gt;&lt;span&gt;DROP&lt;/span&gt;&lt;span&gt;或&lt;/span&gt;&lt;span&gt;masquared&lt;/span&gt;&lt;span&gt;的流量的源或目标地址，以确保&lt;/span&gt; &lt;span&gt;iptables&lt;/span&gt; &lt;span&gt;规则的数量是恒定的，这样我们就不需要关心我们有多少服务了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1216496/201901/1216496-20190128142029635-978305445.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;ipvs&lt;span&gt;虽然在&lt;/span&gt;&lt;span&gt;v1.1&lt;/span&gt;&lt;span&gt;版本中已经支持，但是想要使用，还需激活&lt;/span&gt;&lt;span&gt;ipvs&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;① &lt;span&gt;修改配置文件&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master ~]# vim /etc/sysconfig/kubelet
KUBE_PROXY=MODE=ipvs
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;② &lt;span&gt;编写脚本，让&lt;/span&gt;&lt;span&gt;kubelet&lt;/span&gt;&lt;span&gt;所在的主机，启动时装入以下几个模块：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;ip_vs&lt;span&gt;，&lt;/span&gt;&lt;span&gt;ip_vs_rr&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;ip_vs_wrr&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;ip_vs_sh&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;nf_conntrack_ipv4&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;1.4 service&lt;span&gt;定义资源清单几个字段&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt; apiVersion&lt;span&gt;：&lt;/span&gt; &lt;span&gt;v1  &lt;/span&gt;&lt;span&gt;版本&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; kind&lt;span&gt;：&lt;/span&gt; &lt;span&gt;Service  &lt;/span&gt;&lt;span&gt;类型&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; metadata  &lt;span&gt;元数据&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; spec  &lt;span&gt;期望状态&lt;/span&gt;
&lt;ul&gt;&lt;li&gt; ports&lt;span&gt;：服务公开的端口列表；把哪个端口和后端建立联系&lt;/span&gt;
&lt;ul&gt;&lt;li&gt; port&lt;span&gt;：此服务将公开的端口&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; targetPort&lt;span&gt;：要在服务所针对的&lt;/span&gt;&lt;span&gt;pod&lt;/span&gt;&lt;span&gt;上访问的端口的编号或名称&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; nodePort&lt;span&gt;：&lt;/span&gt;&lt;span&gt;K8S&lt;/span&gt; &lt;span&gt;集群节点上的端口&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt; selector&lt;span&gt;：标签选择器；关联到哪些&lt;/span&gt;&lt;span&gt;pod&lt;/span&gt;&lt;span&gt;资源上&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; clusterIP&lt;span&gt;：服务的&lt;/span&gt;&lt;span&gt;IP&lt;/span&gt;&lt;span&gt;地址，通常由主服务器随机分配&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; &lt;strong&gt;type&lt;/strong&gt;&lt;span&gt;：确定服务的公开方式。&lt;/span&gt; &lt;span&gt;默认为&lt;/span&gt;ClusterIP
&lt;ul&gt;&lt;li&gt; ClusterIP&lt;span&gt;（默认）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; NodePort&lt;/li&gt;
&lt;li&gt; LoadBalancer&lt;/li&gt;
&lt;li&gt; ExternelName&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt; sessionAffinity&lt;span&gt;：&lt;/span&gt;&lt;span&gt;service&lt;/span&gt;&lt;span&gt;负载均衡，默认值是&lt;/span&gt;&lt;span&gt;None&lt;/span&gt;&lt;span&gt;，根据&lt;/span&gt;&lt;span&gt;iptables&lt;/span&gt;&lt;span&gt;规则随机调度；可使用&lt;/span&gt;&lt;span&gt;sessionAffinity&lt;/span&gt;&lt;span&gt;保持会话连线；&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt; status  &lt;span&gt;当前状态&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;strong&gt;1.5 service&lt;span&gt;的&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;中类型&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt; ClusterIP&lt;span&gt;（默认）：仅用于集群内通信，集群内部可达，可以被各&lt;/span&gt;&lt;span&gt;pod&lt;/span&gt;&lt;span&gt;访问，节点本身可访问；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; NodePort&lt;span&gt;：构建在&lt;/span&gt;&lt;span&gt;ClusterIP&lt;/span&gt;&lt;span&gt;上，并在路由到&lt;/span&gt;&lt;span&gt;clusterIP&lt;/span&gt;&lt;span&gt;的每个节点上分配一个端口；&lt;/span&gt;
&lt;ul&gt;&lt;li&gt; client ---&amp;gt; NodeIP:NodePort ---&amp;gt; ClusterIP:ServicePort ---&amp;gt; PodIP:containePort&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt; LoadBalancer&lt;span&gt;：构建在&lt;/span&gt;&lt;span&gt;NodePort&lt;/span&gt;&lt;span&gt;上，并创建一个外部负载均衡器（如果在当前云中受支持），它将路由到&lt;/span&gt;&lt;span&gt;clusterIP&lt;/span&gt;&lt;span&gt;；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; ExternelName&lt;span&gt;：通过&lt;/span&gt;&lt;span&gt;CNAME&lt;/span&gt;&lt;span&gt;将&lt;/span&gt;&lt;span&gt;service&lt;/span&gt;&lt;span&gt;与&lt;/span&gt;&lt;span&gt;externalName&lt;/span&gt;&lt;span&gt;的值&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;比如：&lt;/span&gt;&lt;span&gt;foo.bar.example.com)&lt;/span&gt;&lt;span&gt;映射起来&lt;/span&gt;&lt;span&gt;.&lt;/span&gt; &lt;span&gt;要求&lt;/span&gt;&lt;span&gt;kube-dns&lt;/span&gt;&lt;span&gt;的版本为&lt;/span&gt;&lt;span&gt;1.7&lt;/span&gt;&lt;span&gt;或以上&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;2、创建clusterIP类型的service&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）编写&lt;/span&gt;&lt;span&gt;yaml&lt;/span&gt;&lt;span&gt;文件并创建名为&lt;/span&gt;&lt;span&gt;redis&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;service&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;先创建一个&lt;/span&gt;deployment&lt;span&gt;，启动一个&lt;/span&gt;&lt;span&gt;redis pod&lt;/span&gt;&lt;span&gt;；在使用&lt;/span&gt;&lt;span&gt;service&lt;/span&gt;&lt;span&gt;绑定这个&lt;/span&gt;&lt;span&gt;pod&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master manifests]# vim redis-svc.yaml 
apiVersion: apps/v1
kind: Deployment
metadata:
  name: redis
  namespace: default
spec:
  replicas: 1
  selector:
    matchLabels:
      app: redis
      role: logstor
  template:
    metadata:
      labels:
        app: redis
        role: logstor
    spec:
      containers:
      - name: redis
        image: redis:4.0-alpine
        ports:
        - name: redis
          containerPort: 6379
---
apiVersion: v1
kind: Service
metadata:
  name: redis
  namespace: default
spec:
  selector:
    app: redis
    role: logstor
  clusterIP: 10.99.99.99
  type: ClusterIP
  ports:
  - port: 6380
    targetPort: 6379
[root@master manifests]# kubectl apply -f redis-svc.yaml
deployment.apps/redis created
service/redis created
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;（&lt;/span&gt;2&lt;span&gt;）查询验证&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master ~]# kubectl get svc
NAME         TYPE        CLUSTER-IP    EXTERNAL-IP   PORT(S)    AGE
kubernetes   ClusterIP   10.96.0.1     &amp;lt;none&amp;gt;        443/TCP    142d
redis        ClusterIP   10.99.99.99   &amp;lt;none&amp;gt;        6380/TCP   12s
---查询service详细信息，pod绑定成功
[root@master ~]# kubectl describe svc redis
Name:              redis
Namespace:         default
Labels:            &amp;lt;none&amp;gt;
Annotations:       kubectl.kubernetes.io/last-applied-configuration={&quot;apiVersion&quot;:&quot;v1&quot;,&quot;kind&quot;:&quot;Service&quot;,&quot;metadata&quot;:{&quot;annotations&quot;:{},&quot;name&quot;:&quot;redis&quot;,&quot;namespace&quot;:&quot;default&quot;},&quot;spec&quot;:{&quot;clusterIP&quot;:&quot;10.99.99.99&quot;,&quot;ports&quot;:[{&quot;por...
Selector:          app=redis,role=logstor
Type:              ClusterIP
IP:                10.99.99.99
Port:              &amp;lt;unset&amp;gt;  6380/TCP
TargetPort:        6379/TCP
Endpoints:         10.244.2.94:6379
Session Affinity:  None
Events:            &amp;lt;none&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;3、创建NodePort类型的service&lt;/h2&gt;
&lt;h3&gt;&lt;strong&gt;3.1 &lt;span&gt;创建&lt;/span&gt;&lt;span&gt;service&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）编写&lt;/span&gt;&lt;span&gt;yaml&lt;/span&gt;&lt;span&gt;文件并创建名为&lt;/span&gt;&lt;span&gt;myapp&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;service&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;先创建一个&lt;/span&gt;deployment&lt;span&gt;，启动&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;个&lt;/span&gt;&lt;span&gt;myapp pod&lt;/span&gt;&lt;span&gt;；在使用&lt;/span&gt;&lt;span&gt;service&lt;/span&gt;&lt;span&gt;绑定这&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;个&lt;/span&gt;&lt;span&gt;pod&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master manifests]# vim myapp-svc.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp-deploy
  namespace: default
spec:
  replicas: 3
  selector:
    matchLabels:
      app: myapp
      release: canary
  template:
    metadata:
      labels:
        app: myapp
        release: canary
    spec:
      containers:
      - name: myapp
        image: ikubernetes/myapp:v1
        ports:
        - name: http
          containerPort: 80
---
apiVersion: v1
kind: Service
metadata:
  name: myapp
  namespace: default
spec:
  selector:
    app: myapp
    release: canary
  clusterIP: 10.97.97.97
  type: NodePort
  ports:
  - port: 80
    targetPort: 80
    nodePort: 31180
[root@master manifests]# kubectl apply -f myapp-svc.yaml
deployment.apps/myapp-deploy unchanged
service/myapp created
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;（&lt;/span&gt;2&lt;span&gt;）查询验证&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;44&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master ~]# kubectl get svc
NAME         TYPE        CLUSTER-IP    EXTERNAL-IP   PORT(S)        AGE
kubernetes   ClusterIP   10.96.0.1     &amp;lt;none&amp;gt;        443/TCP        145d
myapp        NodePort    10.97.97.97   &amp;lt;none&amp;gt;        80:31180/TCP   39s
redis        ClusterIP   10.99.99.99   &amp;lt;none&amp;gt;        6380/TCP       2d
[root@master ~]# kubectl describe svc myapp
Name:                     myapp
Namespace:                default
Labels:                   &amp;lt;none&amp;gt;
Annotations:              kubectl.kubernetes.io/last-applied-configuration={&quot;apiVersion&quot;:&quot;v1&quot;,&quot;kind&quot;:&quot;Service&quot;,&quot;metadata&quot;:{&quot;annotations&quot;:{},&quot;name&quot;:&quot;myapp&quot;,&quot;namespace&quot;:&quot;default&quot;},&quot;spec&quot;:{&quot;clusterIP&quot;:&quot;10.97.97.97&quot;,&quot;ports&quot;:[{&quot;nod...
Selector:                 app=myapp,release=canary
Type:                     NodePort
IP:                       10.97.97.97
Port:                     &amp;lt;unset&amp;gt;  80/TCP
TargetPort:               80/TCP
NodePort:                 &amp;lt;unset&amp;gt;  31180/TCP
Endpoints:                10.244.1.96:80,10.244.2.101:80,10.244.2.102:80
Session Affinity:         None
External Traffic Policy:  Cluster
Events:                   &amp;lt;none&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;（&lt;/span&gt;3&lt;span&gt;）在集群外访问服务&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1216496/201901/1216496-20190128142222612-1365398205.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;3.2 &lt;span&gt;使用&lt;/span&gt;&lt;span&gt;sessionAffinity&lt;/span&gt;&lt;span&gt;保持会话连接&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）&lt;/span&gt;&lt;span&gt;sessionAffinity&lt;/span&gt;&lt;span&gt;默认是&lt;/span&gt;&lt;span&gt;None&lt;/span&gt;&lt;span&gt;，没有修改前，访问业务是随机调度&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master ~]# while true; do curl 192.168.10.103:31180/hostname.html; sleep 1; done
myapp-deploy-69b47bc96d-mmb5v
myapp-deploy-69b47bc96d-wtbx7
myapp-deploy-69b47bc96d-wtbx7
myapp-deploy-69b47bc96d-cj48v
... ...
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;（&lt;/span&gt;2&lt;span&gt;）打补丁修改&lt;/span&gt;&lt;span&gt;sessionAffinity&lt;/span&gt;&lt;span&gt;为&lt;/span&gt;&lt;span&gt;clientip&lt;/span&gt;&lt;span&gt;；实现会话连接&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;也可以使用&lt;/span&gt;exec&lt;span&gt;修改；或者直接修改&lt;/span&gt;&lt;span&gt;yaml&lt;/span&gt;&lt;span&gt;文件也可以；&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master ~]# kubectl patch svc myapp -p '{&quot;spec&quot;:{&quot;sessionAffinity&quot;:&quot;ClientIP&quot;}}'
service/myapp patched
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;（&lt;/span&gt;3&lt;span&gt;）查询验证&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;44&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master ~]# kubectl describe svc myapp
Name:                     myapp
Namespace:                default
Labels:                   &amp;lt;none&amp;gt;
Annotations:              kubectl.kubernetes.io/last-applied-configuration={&quot;apiVersion&quot;:&quot;v1&quot;,&quot;kind&quot;:&quot;Service&quot;,&quot;metadata&quot;:{&quot;annotations&quot;:{},&quot;name&quot;:&quot;myapp&quot;,&quot;namespace&quot;:&quot;default&quot;},&quot;spec&quot;:{&quot;clusterIP&quot;:&quot;10.97.97.97&quot;,&quot;ports&quot;:[{&quot;nod...
Selector:                 app=myapp,release=canary
Type:                     NodePort
IP:                       10.97.97.97
Port:                     &amp;lt;unset&amp;gt;  80/TCP
TargetPort:               80/TCP
NodePort:                 &amp;lt;unset&amp;gt;  31180/TCP
Endpoints:                10.244.1.96:80,10.244.2.101:80,10.244.2.102:80
Session Affinity:         ClientIP
External Traffic Policy:  Cluster
Events:                   &amp;lt;none&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;（&lt;/span&gt;4&lt;span&gt;）访问业务查询验证；发现同一客户端的请求始终发往同一&lt;/span&gt;&lt;span&gt;pod&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master ~]# while true; do curl 192.168.10.103:31180/hostname.html; sleep 1; done
myapp-deploy-69b47bc96d-cj48v
myapp-deploy-69b47bc96d-cj48v
myapp-deploy-69b47bc96d-cj48v
myapp-deploy-69b47bc96d-cj48v
... ...
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;（&lt;/span&gt;5&lt;span&gt;）重新打补丁修改为&lt;/span&gt;&lt;span&gt;None&lt;/span&gt;&lt;span&gt;，立即恢复为随机调度&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master ~]# kubectl patch svc myapp -p '{&quot;spec&quot;:{&quot;sessionAffinity&quot;:&quot;None&quot;}}'
service/myapp patched
[root@master ~]# while true; do curl 192.168.10.103:31180/hostname.html; sleep 1; done
myapp-deploy-69b47bc96d-cj48v
myapp-deploy-69b47bc96d-mmb5v
myapp-deploy-69b47bc96d-cj48v
myapp-deploy-69b47bc96d-mmb5v
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;4、创建无头service&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）编写&lt;/span&gt;&lt;span&gt;yaml&lt;/span&gt;&lt;span&gt;文件并创建名为&lt;/span&gt;&lt;span&gt;myapp-svc&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;service&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;绑定上面创建&lt;/span&gt;myapp&lt;span&gt;的&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;个&lt;/span&gt;&lt;span&gt;pod&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master manifests]# vim myapp-svc-headless.yaml
apiVersion: v1
kind: Service
metadata:
  name: myapp-svc
  namespace: default
spec:
  selector:
    app: myapp
    release: canary
  clusterIP: None
  ports:
  - port: 80
    targetPort: 80
[root@master manifests]# kubectl apply -f myapp-svc-headless.yaml
service/myapp-svc created
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;（&lt;/span&gt;2&lt;span&gt;）查询验证&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master ~]# kubectl get svc
NAME         TYPE        CLUSTER-IP    EXTERNAL-IP   PORT(S)        AGE
kubernetes   ClusterIP   10.96.0.1     &amp;lt;none&amp;gt;        443/TCP        145d
myapp        NodePort    10.97.97.97   &amp;lt;none&amp;gt;        80:31180/TCP   2h
myapp-svc    ClusterIP   None          &amp;lt;none&amp;gt;        80/TCP         6s
redis        ClusterIP   10.99.99.99   &amp;lt;none&amp;gt;        6380/TCP       2d
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;（&lt;/span&gt;3&lt;span&gt;）和有头正常&lt;/span&gt;&lt;span&gt;myapp&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;service&lt;/span&gt;&lt;span&gt;对比&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;无头&lt;/span&gt;service&lt;span&gt;的解析：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master manifests]# dig -t A myapp-svc.default.svc.cluster.local. @10.96.0.10
... ...
;; ANSWER SECTION:
myapp-svc.default.svc.cluster.local. 5 IN A     10.244.1.96
myapp-svc.default.svc.cluster.local. 5 IN A     10.244.2.101
myapp-svc.default.svc.cluster.local. 5 IN A     10.244.2.102
... ...
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;有头正常&lt;/span&gt;myapp&lt;span&gt;的&lt;/span&gt;&lt;span&gt;service&lt;/span&gt;&lt;span&gt;的解析：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master manifests]# dig -t A myapp.default.svc.cluster.local. @10.96.0.10
... ...
;; ANSWER SECTION:
myapp.default.svc.cluster.local. 5 IN   A       10.97.97.97
... ...
&lt;/pre&gt;&lt;/div&gt;


</description>
<pubDate>Mon, 28 Jan 2019 06:25:00 +0000</pubDate>
<dc:creator>alonghub</dc:creator>
<og:description>本文收录在容器技术学习系列文章总目录 1、认识service 1.1 为什么要使用service Kubernetes Pod 是有生命周期的，它们可以被创建，也可以被销毁，然而一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/along21/p/10330076.html</dc:identifier>
</item>
</channel>
</rss>