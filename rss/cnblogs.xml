<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>HBase之CF持久化系列(续1) - letsfly</title>
<link>http://www.cnblogs.com/letsfly/p/10114377.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/letsfly/p/10114377.html</guid>
<description>&lt;p&gt;　　这一节本来打算讲解HRegion的初始化过程中一些比较复杂的流程。不过，考虑前面的博文做的铺垫并不够，因此，在这一节，我还是特意来介绍HBase的CF持久化。关于这个话题的整体流程性分析在博文《HBase数据持久化之HRegion.flushcache即CF持久化》中已经介绍过，大家最好先看一下我的上篇博文，然后再看这个系列(这个系列我预计会通过三篇博文来详细讲解)。可以说，《HBase数据持久化之HRegion.flushcache即CF持久化》是CF持久化的概述，而本节是CF持久化过程中关键流程的一个详细描述。由于该系列比较复杂，因此，该系列中涉及到WAL的知识点或者其他的无关的知识点我都略过，单就介绍CF持久化的相关信息。&lt;/p&gt;
&lt;p&gt;　　由于在上篇博文中，我已经将HRegion.internalPrepareFlushCache流程讲解的比较详细，因此，该系列的三篇文章都从HRegion.internalFlushCacheAndCommit讲起。&lt;/p&gt;
&lt;p&gt;　　由于在博文《HBase数据持久化之HRegion.flushcache即CF持久化》中已经介绍过方法HRegion.internalFlushCacheAndCommit中的一些流程，但是某些方法讲的比较粗略。因此，我在这一节从DefaultStoreFlusher.flushSnapshot方法讲起，下一节从StoreFlusher.finalizeWriter开始讲起，第三节我将分析HStore.validateStoreFile。至于CF持久化流程中涉及到其他知识点的，我会在CF持久化系列(杂记)中一一介绍。&lt;/p&gt;
&lt;p&gt;　　在这一节，我不再粘贴大量的图，尽量使用文字来进行描述，必要的时候，我会贴图来说明。虽然这样说，但是，由于该系列比较复杂，因此，在本篇博客，我可能还是会贴不少的图。&lt;/p&gt;
&lt;p&gt;　　首先，让我们来到流程性的方法DefaultStoreFlusher.flushSnapshot。这里有几个关键的步骤。&lt;/p&gt;
&lt;p&gt;　　1.调用内部的createScanner方法，构造了StoreScanner，这里是本节的一个重点。&lt;/p&gt;
&lt;p&gt;　　2.调用HStore.createWriterInTmp方法构建了一个StoreFileWriter，该方法的流程在本节中比较复杂，但其功能可以比较简单的概括——确定CF的目录文件，并且在其目录文件上创建对应的输入流(这里我们只讨论文件系统为HDFS的情况)&lt;/p&gt;
&lt;p&gt;　　3.调用内部的performFlush，将每一行信息写入到上面创建的StoreFileWriter.HFileWriterImpl.HFileBlock.Writer.userDataStream(大家这里看的可能比较懵逼，没有关系，耐心往后面看，这里是本节的重点，在这里有一个印象就好)。&lt;/p&gt;
&lt;p&gt;　　4.调用内部的finalizeWriter方法，该方法将上一步中保存的行信息写入到HFileWriterImpl.outputStream，包括布隆过滤器的值，blockIndex、File info、FixedFileTrailer中的信息。&lt;/p&gt;
&lt;p&gt;　　5.将上面获取到的store.scanInfo关闭&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;　　6.将CF的目录保存到待返回的结果值中。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181213143625189-1558711479.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　在createScanner方法内部，主要调用了StoreScanner构造方法，如下图所示。这里相对比较复杂。&lt;/p&gt;
&lt;p&gt;　　1.调用了内部的另外一个构造方法，完成部分成员变量的初始化。&lt;/p&gt;
&lt;p&gt;　　2.调用selectScannersFrom，会根据TLL等条件筛选出一部分scanners&lt;/p&gt;
&lt;p&gt;　　3.调用seekScanners，这里将根据matcher.getStartKey()中的row与family筛选出该scanner。由于其内部使用了NavigableMap类型，以传入的matcher.getStartKey()为NavigableMap.tailMap的入参，就可以获得大于等于该值的所有cell。该方法的主要作用就是遍历入参scanners，并且初始化每个scanner中的关键性成员变量iter与current。这里的具体流程我在接下来还会着重讲解。&lt;/p&gt;
&lt;p&gt;　　4.调用addCurrentScanners将入参scanners中的值都添加到其成员变量currentScanners中。&lt;/p&gt;
&lt;div readability=&quot;8&quot;&gt;　　5.调用resetKVHeap初始化了成员变量heap。这里的具体流程我也会着重讲解。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181213144013706-344797078.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　首先，让我们分析方法seekScanners。在该方法内部值得注意的方法是调用了scanner.seek(scanner类型为SegmentScanner)，这里的seek方法就是用于初始化scanner的成员变量iter与current。&lt;/p&gt;
&lt;p&gt;　　让我们来到SegmentScanner.seek，如下图所示，这里有两个比较重要的方法——getIterator、updateCurrent。&lt;/p&gt;
&lt;p&gt;　　1.这里的getIterator方法比较琐碎，细讲吧，有种鸡肋的感觉，不细讲吧，却是一个知识点。不过，为了后面方便理解，我还是不偷懒了，为大家细细讲解一番。&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;　　2.调用updateCurrent，获得上面iter.next值，并赋给成员变量current。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181213144049275-530561643.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;7&quot;&gt;　　这里首先介绍方法getIterator，如下图所示。这里调用了Segment.tailSet。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181213144104512-752753393.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;8&quot;&gt;　　接下来让我们来到Segment.tailSet。如下图所示。这里调用getCellSet方法获得成员变量cellSet中的值，其cellSet类型为AtomicReference。然后调用CellSet.tailSet。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181213144132989-477544522.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　然后，我们来到CellSet.tailSet，如下图所示。这里我需要说明一点CellSet实现了接口java.util.NavigableSet，而且这里的delegatee类型为NavigableMap。也就是说，这里将delegatee中大于等于(入参inclusive为true)fromElement的值封装为NavigableSet返回，并且作为新构建的CellSet的入参。&lt;/p&gt;
&lt;div readability=&quot;8&quot;&gt;　　到这里getIterator方法的流程就介绍完了。至此，我们也明白了，返回的iterator就是新构建的CellSet.iterator。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181213144154995-158060985.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;9&quot;&gt;　　接下来，让我们来到updateCurrent。如下图所示。看到这里，我相信大家就明白许多了。没错，这里迭代iterator，将其中符合条件的值赋给了成员变量current。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181213144220590-1088370167.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;8&quot;&gt;　　然后，调用方法resetKVHeap，将刚刚初始化好的scanners封装到KeyValueHeap中，并赋给成员变量heap。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181213144242023-1768336242.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;10&quot;&gt;　　这里，让我们简单看一下KeyValueHeap的构造函数，有利于我们在后面的理解。如下图所示，这里初始化了其成员变量heap，并且将入参中的scanners一一添加到成员变量heap中。然后调用方法pollRealKV，将其返回值用于初始化成员变量current。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181213145946718-27146314.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　在HStore.createWriterInTmp方法中主要构建了StoreFileWriter。首先，让我们来到StoreFileWriter.Builder.build方法。&lt;/p&gt;
&lt;p&gt;　　1.这里首先查看CF所在的目录是否存在，如果不存在，则创建。&lt;/p&gt;
&lt;p&gt;　　2.在CF所在目录下指定随机文件，该文件名通过UUID随机生成(注：这里并没有创建文件)。&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;　　3.调用StoreFileWriter的构造方法。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181213150009884-1217934754.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　然后，来到StoreFileWriter的构造方法：&lt;/p&gt;
&lt;p&gt;　　1.其内部首先通过HFile.WriterFactory创建了HFileWriterImpl。&lt;/p&gt;
&lt;p&gt;　　2.调用BloomFilterFactory.createGeneralBloomAtWrite创建CompoundBloomFilterWriter，并且赋给成员变量generalBloomFilterWriter&lt;/p&gt;
&lt;p&gt;　　3.这里我们分析传入的bloomType为ROW的，可以看到，其使用刚刚创建的generalBloomFilterWriter构建了RowBloomContext&lt;/p&gt;
&lt;div readability=&quot;8&quot;&gt;　　4.同样，调用BloomFilterFactory.createGeneralBloomAtWrite创建CompoundBloomFilterWriter，赋给成员变量deleteFamilyBloomFilterWriter。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181213150046997-1378269607.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　上面流程中，最主要的是创建了HFileWriterImpl。接下来让我们来到HFile.WriterFactory.create。&lt;/p&gt;
&lt;p&gt;　　1.调用HFileWriterImpl.createOutputStream创建并获得文件的输出流，注意，这里的文件就是在StoreFileWriter.Builder.build中构建的文件。&lt;/p&gt;
&lt;div readability=&quot;8&quot;&gt;　　在这里我们只关心文件系统为HDFS的情况。这里内部会调用FSUtils.create。如下图所示，这里通过反射方式调用了DistributedFileSystem.create方法。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181213150117289-720269891.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;8&quot;&gt;　　2.调用HFileWriterImpl构造方法。注意，这里将刚刚获得的输出流传入了HFileWriterImpl的构造方法中(这里是重点，我在后面将详细讲解)。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181213150139089-1912854691.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　让我们来到HFileWriterImpl的构造方法中，如下图所示。&lt;/p&gt;
&lt;p&gt;　　1.这里将传入的输出流赋给了成员变量outputStream&lt;/p&gt;
&lt;p&gt;　　2.然后将NoOpDataBlockEncoder.INSTANCE赋给成员变量blockEncoder&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;　　3.调用了内部方法finishInit，完成了另一部分成员变量的初始化&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181213150216357-1859273231.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;9&quot;&gt;　　来到finishInit，如下图所示，这里连续完成了成员变量blockWriter、dataBlockIndexWriter、metaBlockIndexWriter的初始化。这里，我要着重讲一下HFileBlock.Writer构造函数。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181213150235921-815291388.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;10&quot;&gt;　　接下来让我们来到HFileBlock.Writer的构造函数。如下图所示，这里将传入的dataBlockEncoder赋给了成员变量dataBlockEncoder。另外，分别初始化了dataBlockEncodingCtx、defaultBlockEncodingCtx。由于这里的dataBlockEncoder实际类型为NoOpDataBlockEncoder，因此，这两个成员变量最后调用的方法其实是一样的，都调用了HFileBlockDefaultEncodingContext构造方法。然后初始化了成员变量baosInMemory，而这个成员变量可以说是本节的核心。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181213150252532-1190554744.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　至此，我们就完成了StoreFileWriter的初始化过程。也就是本节的主线——HStore.createWriterInTmp方法调用完成。&lt;/p&gt;
&lt;p&gt;　　然后，来到StoreFlusher.performFlush。&lt;/p&gt;
&lt;p&gt;　　1.调用scanner.next，获取下一条行数据，并且在其方法内部调用了heap.next，更新了heap.KeyValueScanner.current的值。这里的scanner类型为StoreScanner，也正是文章一开始构造的那个StoreScanner。该方法的详细流程我还会在后面谈到。&lt;/p&gt;
&lt;p&gt;　　2.接下来调用sink.append方法，将入参c中的cell信息写入到sink中。大家还记得这里的sink吗，他的实际类型是我在上面谈到的StoreFileWriter。该方法比较复杂，也是本节中的重点之一，我将在后面讲解。&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;　　3.将kvs中的值清空，以便下一次迭代。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181213150545504-1291845927.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　让我们首先来到scanner.next，也就是StoreScanner.next的详细流程。该方法比较长，为了避免讲解混乱，我这里就只介绍方法调用中比较重要的两个方法——heap.peek、heap.next。这里的heap类型为KeyValueHeap。因此，我们来到KeyValueHeap.peek与KeyValueHeap.next方法，如下图所示。大家可能忘记了这里的current的实际类型，我简单提醒一下，他的实际类型是文章开始谈到的SegmentScanner。&lt;/p&gt;
&lt;p&gt;　　1.调用SegmentScanner.peek，获取其成员变量current的值。&lt;/p&gt;
&lt;div readability=&quot;8&quot;&gt;　　2.调用SegmentScanner.next，其内部调用了方法updateCurrent(我在上面已经提到过)，他的作用是更新内部成员变量current的值。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181213150627381-637814522.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　接着，让我们来到sink.append，也就是StoreFileWriter.append。该方法是本节中最为复杂的，希望大家特别留意。让我们来到其方法内部，如下图所示。&lt;/p&gt;
&lt;p&gt;　　1.首先调用appendGeneralBloomfilter，其内部调用了bloomContext.writeBloom(上面分析过，这里的bloomContext类型为RowBloomContext)，这里的内容我接下来会详细讲解。&lt;/p&gt;
&lt;div readability=&quot;8&quot;&gt;　　2.调用writer.append。这里的调用将cell值写入到HFileBlock.Writer.userDataStream(也就是上面提到的)。至于详细的流程，我会详细讲解。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181213150746697-1641428970.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　首先，让我们关注appendGeneralBloomfilter。其内部的调用比较简单，调用了bloomContext.writeBloom，这里的bloomContext类型为RowBloomContext，其内部的bloomFilterWriter类型为CompoundBloomFilterWriter。在方法bloomContext.writeBloom中调用了bloomFilterWriter.append。因此，让我们来到CompoundBloomFilterWriter.append，如下图所示。&lt;/p&gt;
&lt;p&gt;　　1.这里首先调用enqueueReadyChunk，以确保成员变量chunk仍然有空间写入，如果没有，则将其封装到ReadyChunk中，然后加入到成员队列readyChunks中，并将chunk置空，以期后面的调用将其重新分配。&lt;/p&gt;
&lt;p&gt;　　2.如果成员变量chunk为空，则将当前cell值copy并赋给成员变量firstKeyInChunk&lt;/p&gt;
&lt;p&gt;　　3.调用allocateNewChunk，这里比较重要，后面我还是简单讲一下。&lt;/p&gt;
&lt;div readability=&quot;9&quot;&gt;　　4.将入参cell加入到chunk中，需要注意的是这里的cell类型为BloomFilterChunk。关于这里的布隆过滤器的使用，我将在后面专门拿出一章来讲解。这里就不详细介绍了。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181213150839490-2022884233.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;9&quot;&gt;　　让我们来到allocateNewChunk，如下图所示。看到这里，相信大家就很清楚了。这里首先构建了BloomFilterChunk(在BloomFilterUtil.createBySize方法内)，然后调用chunk.allocBloom，为chunk内部的bloom(ByteBuffer类型)分配指定的字节。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181213153541608-1936299299.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　到此，大家对于其中的bloomContext.writeBloom方法应该有了一个比较明确的了解。&lt;/p&gt;
&lt;p&gt;　　接下来，我来为大家详细介绍writer.append，也就是HFileWriterImpl.append。如下图所示。&lt;/p&gt;
&lt;p&gt;　　1.由于这是首次写入，因此这里会调用newBlock，这里主要是后面blockWriter.write的调用做准备，具体的细节还是比较重要的，我将放在后面来讲解。&lt;/p&gt;
&lt;p&gt;　　2.调用blockWriter.write方法，将cell信息写入HFileBlock.userDataStream(这里比较重要)。&lt;/p&gt;
&lt;p&gt;　　3.判断是否将入参cell赋给成员变量firstCellInBlock&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;　　4.将入参cell赋给成员变量lastCell&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181213153609087-1492159340.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　让我们首先关注方法newBlock。在其内部主要调用了blockWriter.startWriting(BlockType.DATA)，这里的入参为BlockType.DATA，需要格外注意。让我们来到HFileBlock.startWriting。&lt;/p&gt;
&lt;p&gt;　　1.这里的baosInMemory在Writer构造时已经实现了初始化。这里调用其reset，为下一次完整的写入做准备。&lt;/p&gt;
&lt;p&gt;　　2.调用baosInMemory.write，这里已经开始写入。而HConstants.HFILEBLOCK_DUMMY_HEADER是一个空的header。在后面调用finishBlock中，会将这里的内容填充(这里的具体内容我会在后面finishBlock中分析，大家有一个概念就好)。&lt;/p&gt;
&lt;p&gt;　　3.将baosInMemory封装到userDataStream，后面都会通过userDataStream将内容简介写入baosInMemory。看到这里，大家可能就会明白我在上面提到的StoreFileWriter.HFileWriterImpl.HFileBlock.Writer.userDataStream。不清楚也没有关系，后面我还会详细讲解，这里是本节的重点。&lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt;　　4.由于入参格式为BlockType.DATA，因此这里会调用dataBlockEncoder.startBlockEncoding。这里完成了dataBlockEncodingCtx.encoderState的初始化，为后面将cell写入userDataStream做前期准备。由于我们这里的dataBlockEncoder类型为NoOpDataBlockEncoder，因此，接下来，我们来到NoOpDataBlockEncoder.startBlockEncoding。这里需要注意的是，第一个入参为成员变量dataBlockEncodingCtx，二个入参为封装了baosInMemory的userDataStream。后面还会用到这两个变量，希望大家紧记。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181213153633930-143160785.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　如下图所示，我们来到NoOpDataBlockEncoder.startBlockEncoding。&lt;/p&gt;
&lt;p&gt;　　1.这里将入参中的out封装到新构造的encoder&lt;/p&gt;
&lt;div readability=&quot;8&quot;&gt;　　2.将封装了刚刚构造的encoder封装并赋给入参blkEncodingCtx.encoderState，也就是说，这里的blkEncodingCtx.encoderState将入参中的out也封装进去了。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181213153656864-1095526416.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　到这里，方法newBlock的调用就完成了，这里主要为后面数据的写入做了前期的准备。&lt;/p&gt;
&lt;p&gt;　　接下来我们来分析blockWriter.write。&lt;/p&gt;
&lt;p&gt;　　1.这里的userDataStream的就是上面刚刚构造的，其封装了baosInMemory&lt;/p&gt;
&lt;div readability=&quot;8&quot;&gt;　　2.调用了dataBlockEncoder.encode，这里的第二个入参就是上面介绍的成员变量dataBlockEncodingCtx。当然，这里的dataBlockEncoder类型为NoOpDataBlockEncoder。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181213153720065-2070900400.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;8&quot;&gt;　　因此，接下来，让我们来到NoOpDataBlockEncoder.encode。如下图所示，这里获得入参的encodingCtx.encoderState。然后获取其encoder，并且调用encoder.write。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181213153750356-204028051.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　让我们来到NoneEncoder.write，如下图所示。这里我将其中的构造方法也顺带粘了过来。这里调用KeyValueUtil.oswrite。这里的out就是上面的userDataStream。&lt;/p&gt;
&lt;div readability=&quot;8&quot;&gt;　　在KeyValueUtil.oswrite完成了将cell中内容写入到out的功能。其流程还是一个知识点，我这里还是讲解一番。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181213153812132-408228836.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　我这里只介绍入参cell类型为NoTagByteBufferChunkKeyValue。在KeyValueUtil.oswrite方法中，由于NoTagByteBufferChunkKeyValue实现了ExtendedCell接口。&lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt;　　因此，在KeyValueUtil.oswrite方法中，仅仅调用了((ExtendedCell)cell).write(out, withTags)方法。如下图所示，这里调用了ByteBufferUtils.copyBufferToStream(该方法会多次调用)。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181213153841252-829343180.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;9&quot;&gt;　　接下来让我们来到ByteBufferUtils.copyBufferToStream。这里的入参out类型为ByteBufferWriterDataOutputStream，其实现了ByteBufferWriter接口。因此，这里调用了ByteBufferWriterDataOutputStream.write方法。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181213153910871-910108255.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;10&quot;&gt;　　让我们来到ByteBufferWriterDataOutputStream.write。如下图所示，这里又调用了上面的方法ByteBufferUtils.copyBufferToStream，不过这里的out类型与上面的out的类型不同了，这里的out类型为ByteArrayOutputStream。也就是上面提到的userDataStream封装的baosInMemory。也就是说，这里然后调用了ByteArrayOutputStream.write。让我们进一步分析。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181213153936303-536504593.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　来到ByteArrayOutputStream.write。&lt;/p&gt;
&lt;p&gt;　　1.这里检查成员变量buf是否足以容纳extra长度的字节，如果不满足，则从新分配、拷贝，如果已经满足，则不再进行任何操作。这里的详细逻辑我就不详述了。&lt;/p&gt;
&lt;div readability=&quot;8&quot;&gt;　　2.调用ByteBufferUtils.copyFromBufferToArray将入参b中的内容拷贝到成员变量buf中。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181213154115300-1011025761.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　到此，我们就分析完了blockWriter.write的详细流程。&lt;/p&gt;
&lt;p&gt;　　也就是说，这里就将cell中的内容写到了HFileBlock.userDataStream，也就是HFileBlock.baosInMemory中。从整体流程上来讲，我们就完成了StoreFlusher.performFlush。&lt;/p&gt;
&lt;p&gt;　　本节就分析到这里。下一节我将从StoreFlusher.finalizeWriter开始分析。&lt;/p&gt;
</description>
<pubDate>Thu, 13 Dec 2018 07:50:00 +0000</pubDate>
<dc:creator>letsfly</dc:creator>
<og:description>这一节本来打算讲解HRegion的初始化过程中一些比较复杂的流程。不过，考虑前面的博文做的铺垫并不够，因此，在这一节，我还是特意来介绍HBase的CF持久化。关于这个话题的整体流程性分析在博文《HBa</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/letsfly/p/10114377.html</dc:identifier>
</item>
<item>
<title>使用elementUI的时候，使用Upload 上传的时候，使用 list-type 属性来设置文件列表的样式，before-upload方法失效 - saucxs</title>
<link>http://www.cnblogs.com/chengxs/p/10114419.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chengxs/p/10114419.html</guid>
<description>&lt;p&gt;最近在做项目的时候，使用elementUI的时候，使用Upload 上传的时候，before-upload方法失效。&lt;/p&gt;
&lt;p&gt;情况下：使用 &lt;code&gt;list-type&lt;/code&gt; 属性来设置文件列表的样式。&lt;/p&gt;
&lt;p&gt;最终的优化之后：（演示的是修改）&lt;/p&gt;
&lt;p&gt;需求：&lt;/p&gt;
&lt;p&gt;1、已经提交的附件不可删除，新上传的附件可以删除&lt;/p&gt;
&lt;p&gt;2、图片附件不能上传其他格式的文件，一次可以多张上传图片，最多上传3张，最大不超过2M&lt;/p&gt;
&lt;p&gt;3、文件附件不能上传除了图片格式以外的格式，一次可以上传多个文件，最多上传3个文件，最大不超过2M&lt;/p&gt;
&lt;p&gt;4、手动上传文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.mwcxs.top/static/upload/pics/2018/12/129ifX2poU2QJrHwvnznH3_yWP.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、使用on-change方法来模拟before-upload方法来判断文件类型或大小&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;查找了资料发现还是不行，只能求助大佬们？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
  &amp;lt;el-form-item prop=&quot;image&quot; label=&quot;图片附件上传&quot;&amp;gt;
          &amp;lt;el-&lt;span&gt;upload
            ref&lt;/span&gt;=&quot;uploadImage&quot;&lt;span&gt;
            :action&lt;/span&gt;=&quot;uploadAction&quot;&lt;span&gt;
            :before&lt;/span&gt;-upload=&quot;beforeUploadPicture&quot;&lt;span&gt;
            :before&lt;/span&gt;-remove=&quot;beforeRemovePicture&quot;&lt;span&gt;
            :on&lt;/span&gt;-change=&quot;imageChange&quot;&lt;span&gt;
            list&lt;/span&gt;-type=&quot;picture-card&quot;&lt;span&gt;
            name&lt;/span&gt;=&quot;files&quot;&lt;span&gt;
            :file&lt;/span&gt;-list=&quot;eventDetail.images&quot;&lt;span&gt;
            :limit&lt;/span&gt;=&quot;3&quot;&lt;span&gt;
            multiple
            :auto&lt;/span&gt;-upload=&quot;false&quot;&lt;span&gt;
            :on&lt;/span&gt;-preview=&quot;handlePictureCardPreview&quot;&lt;span&gt;
            :on&lt;/span&gt;-remove=&quot;handleRemovePicture&quot;&lt;span&gt;
            :on&lt;/span&gt;-exceed=&quot;handleExceedPicture&quot;&amp;gt;
            &amp;lt;i class=&quot;el-icon-plus&quot;&amp;gt;&amp;lt;/i&amp;gt;
          &amp;lt;/el-upload&amp;gt;
          &amp;lt;el-dialog append-to-body title=&quot;图片详情&quot; :visible.sync=&quot;dialogVisible&quot;&amp;gt;
            &amp;lt;img width=&quot;100%&quot; :src=&quot;dialogImageUrl&quot; alt=&quot;&quot;&amp;gt;
          &amp;lt;/el-dialog&amp;gt;
        &amp;lt;/el-form-item&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;最后只能使用on-change来模拟before-upload方法的判断上传的照片或者文件的格式。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个是before-upload方法，来判断上传文件    beforeUploadPicture(file){&lt;/span&gt;
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; console.log(file, fileList, '=============================')&lt;/span&gt;
      const isImage = file.raw.type == 'image/png' || file.raw.type == 'image/jpg' ||  file.raw.type == 'image/jpeg' || file.raw.type == 'image/bmp' || file.raw.type == 'image/gif' || file.raw.type == 'image/webp'&lt;span&gt;;
      const isLt2M &lt;/span&gt;= file.size &amp;lt;  1024 * 1024 * 2&lt;span&gt;;
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;isImage) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$message.error('上传只能是png,jpg,jpeg,bmp,gif,webp格式!'&lt;span&gt;);
      }
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;isLt2M) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$message.error('上传图片大小不能超过 2MB!'&lt;span&gt;);
      }
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; isImage &amp;amp;&amp;amp;&lt;span&gt; isLt2M;
    },&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;******然后这个方法失效，on-change方法正常。我只能使用on-change方法来******&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;on-change的方法 imageChange(file, fileList) {&lt;/span&gt;
      const isImage = file.raw.type == 'image/png' || file.raw.type == 'image/jpg' ||  file.raw.type == 'image/jpeg' || file.raw.type == 'image/bmp' || file.raw.type == 'image/gif' || file.raw.type == 'image/webp'&lt;span&gt;;
      const isLt2M &lt;/span&gt;= file.size &amp;lt;  1024 * 1024 * 2&lt;span&gt;;
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;isImage) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$message.error('上传只能是png,jpg,jpeg,bmp,gif,webp格式!'&lt;span&gt;);
      }
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;isLt2M) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$message.error('上传图片大小不能超过 2MB!'&lt;span&gt;);
      }
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(isImage &amp;amp;&amp;amp;&lt;span&gt; isLt2M){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.imageList =&lt;span&gt; fileList;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.images[''] =&lt;span&gt; fileList;
      }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
        fileList.splice(&lt;/span&gt;-1,1&lt;span&gt;);
      }
    },&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上是图片附件的：&lt;strong&gt;使用on-change方法模拟before-upload方法，使用splice删除文件，splice方法是可以改变原始数组的，这样就模拟了上传前判断文件格式。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;文件附件的方法跟这个类似，改一下方法名就行&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二、已经保存的文件不可删除，怎么判断&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;思路：&lt;/strong&gt;我本来是打算从列表中根据单子状态来判断，然后发现我新上传的文件，也删除不了，所以最后使用文件的url路径来判断是不是已经保存的，因为这是手动保存，文件路径如果不是服务器地址而是本地地址，就可以判断为这是新上传的文件，就可以删除。&lt;/p&gt;
&lt;p&gt;使用before-remove方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    beforeRemovePicture(file, fileList){
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(file.url.indexOf('blob') === -1&lt;span&gt;){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$message.warning('已提交的服务单的附件不能删除'&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
      }
    },&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;三、手动上传文件和附带其他参数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;思路&lt;/strong&gt;：可以自己构建FormData数据，使用append方法构造一个&lt;strong&gt;文件对象&lt;/strong&gt;，并且将其他参数加入到&lt;strong&gt;文件对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;手动上传方法（构造&lt;/strong&gt;FormData文件对象&lt;strong&gt;）&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
let wfForm = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FormData();
      wfForm.append(&lt;/span&gt;'orderId', &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.eventDetail.orderId)
      wfForm.append(&lt;/span&gt;'eventCategory', &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.eventDetail.eventCategory)
      wfForm.append(&lt;/span&gt;'priority', &lt;span&gt;this&lt;/span&gt;.eventDetail.priority==&lt;span&gt;null&lt;/span&gt;?'':&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.eventDetail.priority)
      wfForm.append(&lt;/span&gt;'title', &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.eventDetail.title)
      wfForm.append(&lt;/span&gt;'dsc', &lt;span&gt;this&lt;/span&gt;.eventDetail.dsc==&lt;span&gt;null&lt;/span&gt;?'':&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.eventDetail.dsc)
      wfForm.append(&lt;/span&gt;'occurDate', &lt;span&gt;this&lt;/span&gt;.eventDetail.occurDate==&lt;span&gt;null&lt;/span&gt;?'':&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.eventDetail.occurDate)
      let attIds &lt;/span&gt;= ''
      &lt;span&gt;for&lt;/span&gt; (let i = 0, length = &lt;span&gt;this&lt;/span&gt;.eventDetail.files.length; i &amp;lt; length; i++&lt;span&gt;) {
        attIds &lt;/span&gt;+= &lt;span&gt;this&lt;/span&gt;.eventDetail.files[i].attId + ','&lt;span&gt;;
      }
      &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (let i = 0, length = &lt;span&gt;this&lt;/span&gt;.eventDetail.images.length; i &amp;lt; length; i++&lt;span&gt;) {
        attIds &lt;/span&gt;+= &lt;span&gt;this&lt;/span&gt;.eventDetail.images[i].attId + ','&lt;span&gt;;
      }
      attIds &lt;/span&gt;= attIds.substring(0, attIds.length - 1&lt;span&gt;);
      wfForm.append(&lt;/span&gt;'attIds'&lt;span&gt;, attIds);
      Object.entries(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.images).forEach(file =&amp;gt;&lt;span&gt; {
        file[&lt;/span&gt;1].forEach(item =&amp;gt;&lt;span&gt; {
          wfForm.append(&lt;/span&gt;'file'&lt;span&gt;, item.raw)
          wfForm.append(item.name, file[&lt;/span&gt;0&lt;span&gt;])
        })
      })
      Object.entries(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.files).forEach(file =&amp;gt;&lt;span&gt; {
        file[&lt;/span&gt;1].forEach(item =&amp;gt;&lt;span&gt; {
          wfForm.append(&lt;/span&gt;'file'&lt;span&gt;, item.raw)
          wfForm.append(item.name, file[&lt;/span&gt;0&lt;span&gt;])
        })
      })&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;说明一下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、this.images指的是新上传的图片的数组，this.files值的是新上传的文件的数组。&lt;/p&gt;
&lt;p&gt;2、Object.entries方法主要是用来遍历对象属性。&lt;/p&gt;
&lt;p&gt;3、wfForm.append('file', item.raw)用来构建文件对象&lt;/p&gt;

</description>
<pubDate>Thu, 13 Dec 2018 07:48:00 +0000</pubDate>
<dc:creator>saucxs</dc:creator>
<og:description>最近在做项目的时候，使用elementUI的时候，使用Upload 上传的时候，before-upload方法失效。 情况下：使用 list-type 属性来设置文件列表</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chengxs/p/10114419.html</dc:identifier>
</item>
<item>
<title>开发函数计算的正确姿势 —— 使用 Fun Local 本地运行与调试 - 阿里云云栖社区</title>
<link>http://www.cnblogs.com/yunqishequ/p/10114384.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yunqishequ/p/10114384.html</guid>
<description>&lt;h2 id=&quot;1&quot; data-spm-anchor-id=&quot;a2c4e.11153940.blogcont672623.i0.418c6f65Cy6ocj&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;首先介绍下在本文出现的几个比较重要的概念：&lt;/p&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;函数计算（Function Compute）: 函数计算是一个事件驱动的服务，通过函数计算，用户无需管理服务器等运行情况，只需编写代码并上传。函数计算准备计算资源，并以弹性伸缩的方式运行用户代码，而用户只需根据实际代码运行所消耗的资源进行付费。函数计算更多信息 参考。&lt;/p&gt;
&lt;p&gt;Fun: Fun 是一个用于支持 Serverless 应用部署的工具，能帮助您便捷地管理函数计算、API 网关、日志服务等资源。它通过一个资源配置文件（template.yml），协助您进行开发、构建、部署操作。Fun 的更多文档 参考。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2.0 版本的 Fun，在部署这一块做了很多努力，并提供了比较完善的功能，能够做到将云资源方便、平滑地部署到云端。但该版本，在本地开发上的体验，还有较多的工作要做。于是，我们决定推出 Fun Local 弥补这一处短板。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Fun Local: Fun Local 作为 Fun 的一个子命令存在，只要 Fun 的版本大于等于 2.6.0，即可以直接通过 &lt;code&gt;fun local&lt;/code&gt; 命令使用。Fun Local 工具可以将函数计算中的函数在本地完全模拟运行，并提供单步调试的功能，旨在弥补函数计算相对于传统应用开发体验上的短板，并为用户提供一种解决函数计算问题排查的新途径。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;《开发函数计算的正确姿势》系列除本篇是为用户介绍 fun local 的使用方法外，其他几篇都会向用户展示 Fun Local 对于函数计算开发所带来的效率上的巨大提升。&lt;/p&gt;
&lt;h2 id=&quot;2&quot;&gt;Fun Local 命令格式&lt;/h2&gt;
&lt;p&gt;使用 &lt;code&gt;fun local invoke -h&lt;/code&gt; 可以查看 fun local invoke 的帮助信息：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;shell hljs bash&quot;&gt;$ fun &lt;span class=&quot;hljs-built_in&quot;&gt;local invoke -h
  Usage: invoke [options] &amp;lt;[service/]&lt;span class=&quot;hljs-keyword&quot;&gt;function&amp;gt;

  Run your serverless application locally &lt;span class=&quot;hljs-keyword&quot;&gt;for quick development &amp;amp; testing.

  Options:

    &lt;span class=&quot;hljs-_&quot;&gt;-d, --debug-port &amp;lt;port&amp;gt;  used &lt;span class=&quot;hljs-keyword&quot;&gt;for &lt;span class=&quot;hljs-built_in&quot;&gt;local debugging
    -c, --config &amp;lt;ide&amp;gt;       &lt;span class=&quot;hljs-built_in&quot;&gt;print out ide debug configuration. Options are VSCode
    &lt;span class=&quot;hljs-_&quot;&gt;-e, --event &amp;lt;path&amp;gt;       event file containing event data passed to the &lt;span class=&quot;hljs-keyword&quot;&gt;function
    -h, --help               output usage information&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;3&quot;&gt;本地运行函数&lt;/h2&gt;
&lt;p&gt;运行函数的命令格式为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;shell hljs bash&quot;&gt;fun &lt;span class=&quot;hljs-built_in&quot;&gt;local invoke [options] &amp;lt;[service/]&lt;span class=&quot;hljs-keyword&quot;&gt;function&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中 options、service 都是可以省略的。&lt;br/&gt;从调用方式上，可以理解为，fun local invoke 支持通过 &lt;code&gt;函数名&lt;/code&gt; 调用，或者 &lt;code&gt;服务名/函数名&lt;/code&gt; 的方式调用，即&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;shell hljs bash&quot;&gt;fun &lt;span class=&quot;hljs-built_in&quot;&gt;local invoke &lt;span class=&quot;hljs-keyword&quot;&gt;function
fun &lt;span class=&quot;hljs-built_in&quot;&gt;local invoke service/&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;比如，如果要运行名为 php72 的函数，可以直接通过以下命令完成:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;shell hljs bash&quot;&gt;fun &lt;span class=&quot;hljs-built_in&quot;&gt;local invoke php72&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用结果为：&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://tan-blog.oss-cn-hangzhou.aliyuncs.com/img/20181116165134.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再比如，要运行名为 nodejs8 的函数，可以使用：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;shell hljs bash&quot;&gt;fun &lt;span class=&quot;hljs-built_in&quot;&gt;local invoke nodejs8&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;会得到如下结果:&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://tan-blog.oss-cn-hangzhou.aliyuncs.com/img/20181116165835.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果 template.yml 中包含多个服务，而多个服务中包含相同名称的函数时，通过函数名的方式调用 fun 只会运行第一个名称匹配的函数。&lt;/p&gt;
&lt;p&gt;如果想要精准匹配，可以使用 &lt;code&gt;服务名/函数名&lt;/code&gt; 的方式。&lt;/p&gt;
&lt;p&gt;比如想要调用 localdemo 下的 php72，可以使用：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;shell hljs bash&quot;&gt;fun &lt;span class=&quot;hljs-built_in&quot;&gt;local invoke localdemo/php72&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在本例中，会得到和 &lt;code&gt;fun local invoke php72&lt;/code&gt; 一致的结果。&lt;/p&gt;
&lt;p&gt;以下是一个运行 nodejs8 函数的演示：&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://tan-blog.oss-cn-hangzhou.aliyuncs.com/img/invoke.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;4&quot;&gt;本地运行 java 类型的函数&lt;/h3&gt;
&lt;p&gt;java 不同于解释型的语言，在作为函数运行前，需要先编译。在我们的例子中，可以进入到 demo 中的 java8 目录，然后执行：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;shell hljs java&quot;&gt;mvn &lt;span class=&quot;hljs-keyword&quot;&gt;package&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到 log:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;shell hljs ruby&quot;&gt;[INFO] skip non existing resourceDirectory /Users/tan/code/fun/examples/local/java8/src/test/resources
[INFO]
[INFO] --- maven-compiler-&lt;span class=&quot;hljs-symbol&quot;&gt;plugin:&lt;span class=&quot;hljs-number&quot;&gt;3.1&lt;span class=&quot;hljs-symbol&quot;&gt;:testCompile (default-testCompile) @ demo ---
[INFO] No sources to compile
[INFO]
[INFO] --- maven-surefire-&lt;span class=&quot;hljs-symbol&quot;&gt;plugin:&lt;span class=&quot;hljs-number&quot;&gt;2.12.&lt;span class=&quot;hljs-number&quot;&gt;4&lt;span class=&quot;hljs-symbol&quot;&gt;:test (default-test) @ demo ---
[INFO] No tests to run.
[INFO]
[INFO] --- maven-dependency-&lt;span class=&quot;hljs-symbol&quot;&gt;plugin:&lt;span class=&quot;hljs-number&quot;&gt;2.8&lt;span class=&quot;hljs-symbol&quot;&gt;:copy-dependencies (copy-dependencies) @ demo ---
[INFO] fc-java-core-&lt;span class=&quot;hljs-number&quot;&gt;1.0.&lt;span class=&quot;hljs-number&quot;&gt;0.jar already exists &lt;span class=&quot;hljs-keyword&quot;&gt;in destination.
[INFO]
[INFO] --- maven-jar-&lt;span class=&quot;hljs-symbol&quot;&gt;plugin:&lt;span class=&quot;hljs-number&quot;&gt;2.4&lt;span class=&quot;hljs-symbol&quot;&gt;:jar (default-jar) @ demo ---
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total &lt;span class=&quot;hljs-symbol&quot;&gt;time: &lt;span class=&quot;hljs-number&quot;&gt;1.223 s
[INFO] Finished &lt;span class=&quot;hljs-symbol&quot;&gt;at: &lt;span class=&quot;hljs-number&quot;&gt;2018-&lt;span class=&quot;hljs-number&quot;&gt;11-&lt;span class=&quot;hljs-number&quot;&gt;22&lt;span class=&quot;hljs-symbol&quot;&gt;T10:&lt;span class=&quot;hljs-number&quot;&gt;45&lt;span class=&quot;hljs-symbol&quot;&gt;:&lt;span class=&quot;hljs-number&quot;&gt;14+08&lt;span class=&quot;hljs-symbol&quot;&gt;:&lt;span class=&quot;hljs-number&quot;&gt;00
[INFO] Final &lt;span class=&quot;hljs-symbol&quot;&gt;Memory: &lt;span class=&quot;hljs-number&quot;&gt;15M/&lt;span class=&quot;hljs-number&quot;&gt;309M
[INFO] ------------------------------------------------------------------------&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该命令会在 java8/target 目录下生成 demo-1.0-SNAPSHOT.jar 文件。&lt;/p&gt;
&lt;p&gt;由于我们在 template.yml 中配置的 CodeUri 为 java8/target/demo-1.0-SNAPSHOT.jar，因此不需要任何改动，可以直接通过以下命令运行:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;shell hljs bash&quot;&gt;fun &lt;span class=&quot;hljs-built_in&quot;&gt;local invoke java8&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果如下:&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://tan-blog.oss-cn-hangzhou.aliyuncs.com/img/20181122105124.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以下是一个运行 java8 函数的演示：&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://tan-blog.oss-cn-hangzhou.aliyuncs.com/img/fun_local_java_run.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;5&quot;&gt;本地调试&lt;/h2&gt;
&lt;p&gt;fun local invoke 支持 &lt;code&gt;-d, --debug-port &amp;lt;port&amp;gt;&lt;/code&gt; 选项，可以对函数进行本地单步调试。本文档只介绍如何配置调试，并不涉及调试技巧，更多文章，请参考。&lt;/p&gt;
&lt;p&gt;备注：Fun Local 涉及到的 debugging 技术全部都基于各个语言通用的调试协议实现的，因此无论什么语言的开发者，即使不喜欢用 VSCode，只要使用对应语言的 remote debugging 方法都可以进行调试。&lt;/p&gt;
&lt;h3 id=&quot;6&quot;&gt;本地调试 nodejs、python 类型的函数&lt;/h3&gt;
&lt;p&gt;对于 nodejs6、nodejs8、python2.7、python3、java8 类型的函数，调试方法基本一致。下面拿 nodejs8 举例。&lt;/p&gt;
&lt;p&gt;我们上面演示了可以通过 &lt;code&gt;fun local invoke nodejs8&lt;/code&gt; 来运行名称为 nodejs8 的函数，如果想对该函数进行调试，只需要使用 -d 参数，并配置相应的端口号即可。&lt;/p&gt;
&lt;p&gt;比如我们以调试方式运行函数，并将调试端口设定在 3000，可以通过下面的命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;shell hljs bash&quot;&gt;fun &lt;span class=&quot;hljs-built_in&quot;&gt;local invoke &lt;span class=&quot;hljs-_&quot;&gt;-d 3000 nodejs8&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另外，推荐添加 --config 参数，在调试的同时，可以输出用来调试的 IDE 的配置信息：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;shell hljs bash&quot;&gt;fun &lt;span class=&quot;hljs-built_in&quot;&gt;local invoke &lt;span class=&quot;hljs-_&quot;&gt;-d 3000 --config VSCode nodejs8&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;命令执行结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;shell hljs ruby&quot;&gt;skip pulling images ...
you can paste these config to .vscode/launch.json, &lt;span class=&quot;hljs-keyword&quot;&gt;and &lt;span class=&quot;hljs-keyword&quot;&gt;then attach to your running function
/&lt;span class=&quot;hljs-regexp&quot;&gt;//&lt;span class=&quot;hljs-regexp&quot;&gt;//&lt;span class=&quot;hljs-regexp&quot;&gt;//&lt;span class=&quot;hljs-regexp&quot;&gt;//&lt;span class=&quot;hljs-regexp&quot;&gt;//&lt;span class=&quot;hljs-regexp&quot;&gt;//&lt;span class=&quot;hljs-regexp&quot;&gt;//&lt;span class=&quot;hljs-regexp&quot;&gt;// config &lt;span class=&quot;hljs-keyword&quot;&gt;begin /&lt;span class=&quot;hljs-regexp&quot;&gt;//&lt;span class=&quot;hljs-regexp&quot;&gt;//&lt;span class=&quot;hljs-regexp&quot;&gt;//&lt;span class=&quot;hljs-regexp&quot;&gt;//&lt;span class=&quot;hljs-regexp&quot;&gt;//&lt;span class=&quot;hljs-regexp&quot;&gt;//&lt;span class=&quot;hljs-regexp&quot;&gt;//&lt;span class=&quot;hljs-regexp&quot;&gt;//
{
    &lt;span class=&quot;hljs-string&quot;&gt;&quot;version&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;0.2.0&quot;,
    &lt;span class=&quot;hljs-string&quot;&gt;&quot;configurations&quot;: [
        {
            &lt;span class=&quot;hljs-string&quot;&gt;&quot;name&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;fc/localdemo/nodejs8&quot;,
            &lt;span class=&quot;hljs-string&quot;&gt;&quot;type&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;node&quot;,
            &lt;span class=&quot;hljs-string&quot;&gt;&quot;request&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;attach&quot;,
            &lt;span class=&quot;hljs-string&quot;&gt;&quot;address&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;localhost&quot;,
            &lt;span class=&quot;hljs-string&quot;&gt;&quot;port&quot;: &lt;span class=&quot;hljs-number&quot;&gt;3000,
            &lt;span class=&quot;hljs-string&quot;&gt;&quot;localRoot&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;/Users/tan/code/fun/examples/local/nodejs8&quot;,
            &lt;span class=&quot;hljs-string&quot;&gt;&quot;remoteRoot&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;/code&quot;,
            &lt;span class=&quot;hljs-string&quot;&gt;&quot;protocol&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;inspect&quot;,
            &lt;span class=&quot;hljs-string&quot;&gt;&quot;stopOnEntry&quot;: &lt;span class=&quot;hljs-literal&quot;&gt;false
        }
    ]
}
/&lt;span class=&quot;hljs-regexp&quot;&gt;//&lt;span class=&quot;hljs-regexp&quot;&gt;//&lt;span class=&quot;hljs-regexp&quot;&gt;//&lt;span class=&quot;hljs-regexp&quot;&gt;//&lt;span class=&quot;hljs-regexp&quot;&gt;//&lt;span class=&quot;hljs-regexp&quot;&gt;//&lt;span class=&quot;hljs-regexp&quot;&gt;//&lt;span class=&quot;hljs-regexp&quot;&gt;// config &lt;span class=&quot;hljs-keyword&quot;&gt;end /&lt;span class=&quot;hljs-regexp&quot;&gt;//&lt;span class=&quot;hljs-regexp&quot;&gt;//&lt;span class=&quot;hljs-regexp&quot;&gt;//&lt;span class=&quot;hljs-regexp&quot;&gt;//&lt;span class=&quot;hljs-regexp&quot;&gt;//&lt;span class=&quot;hljs-regexp&quot;&gt;//&lt;span class=&quot;hljs-regexp&quot;&gt;//&lt;span class=&quot;hljs-regexp&quot;&gt;//
Debugger listening on &lt;span class=&quot;hljs-symbol&quot;&gt;ws:/&lt;span class=&quot;hljs-regexp&quot;&gt;/0.0.0.0:3000/b65c288b-bd6a-&lt;span class=&quot;hljs-number&quot;&gt;4791-&lt;span class=&quot;hljs-number&quot;&gt;849b-b03e0d16b0ce
For help see &lt;span class=&quot;hljs-symbol&quot;&gt;https:/&lt;span class=&quot;hljs-regexp&quot;&gt;/nodejs.org/en&lt;span class=&quot;hljs-regexp&quot;&gt;/docs/inspector&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;程序会阻塞在这里，并不会继续往下执行。只有 IDE 的连接上来后，程序才会继续执行。接下来，我们针对 VSCode 配置、VSCode 调试两个方面分别进行讲解。&lt;/p&gt;
&lt;p&gt;其中 VSCode 配置只有在第一次对函数进行调试时才需要，如果已经配置过，则不需要再次配置。&lt;/p&gt;
&lt;h4 id=&quot;7&quot;&gt;VSCode 配置&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;创建 vscode launch.json 文件&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://tan-blog.oss-cn-hangzhou.aliyuncs.com/img/20181116202330.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;li&gt;复制日志中的 config begin 与 config end 之间的配置到 launch.json 中。&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://tan-blog.oss-cn-hangzhou.aliyuncs.com/img/20181118174828.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;li&gt;完成上面配置后，在 Debug 视图可以看到配置的函数列表。&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://tan-blog.oss-cn-hangzhou.aliyuncs.com/img/20181118204006.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;至此，VSCode 配置完成。VSCode 更多配置知识可以参考官方文档。&lt;/p&gt;
&lt;h4 id=&quot;8&quot;&gt;VSCode 调试&lt;/h4&gt;
&lt;p&gt;VSCode 配置成功后，只需要在 VSCode 编辑器侧边栏单击设置断点，然后点击“开始调试”按钮，即可开始调试。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://tan-blog.oss-cn-hangzhou.aliyuncs.com/img/20181116202909.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以下是一个 nodejs8 函数本地单步调试的流程例子：&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://tan-blog.oss-cn-hangzhou.aliyuncs.com/img/fun_local_debug.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;9&quot;&gt;本地调试 java 类型的函数&lt;/h3&gt;
&lt;p&gt;调试 java 函数的过程和 nodejs、python 是类似的。但由于 java 程序员通常喜欢用 IDEA、Eclipse 这样的 IDE，所以我们单独拿出来说一下。&lt;/p&gt;
&lt;h4 id=&quot;10&quot;&gt;使用 VSCode 调试 java&lt;/h4&gt;
&lt;p&gt;使用 VSCode 调试 java 时，需要安装两个插件：&lt;code&gt;Language Support for Java(TM) by Red Hat&lt;/code&gt;、&lt;code&gt;Debugger for Java&lt;/code&gt;。利用 VSCode 的插件市场安装插件很简单，可以 参考。&lt;/p&gt;
&lt;p&gt;以下是一个使用 VSCode 调试 java 类型函数的例子：&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://tan-blog.oss-cn-hangzhou.aliyuncs.com/img/fun_local_java_debug_vscode.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;11&quot;&gt;使用 IDEA 调试 java&lt;/h4&gt;
&lt;h5 id=&quot;12&quot;&gt;IDEA 配置&lt;/h5&gt;
&lt;p&gt;IDEA 配置 remote debugging 还是比较简单的，首先在菜单栏依次点击 &lt;code&gt;Run -&amp;gt; Edit Configurations...&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://tan-blog.oss-cn-hangzhou.aliyuncs.com/img/20181122114543.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后新建一个 Remote Debugging：&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://tan-blog.oss-cn-hangzhou.aliyuncs.com/img/20181122114813.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后我们随意输出一个名字，并配置端口号为 3000.&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://tan-blog.oss-cn-hangzhou.aliyuncs.com/img/20181122114947.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以下是一个配置 IDEA remote debugging 的完整流程演示:&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://tan-blog.oss-cn-hangzhou.aliyuncs.com/img/fun_local_java_debug_idea_config.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;13&quot;&gt;使用 IDEA 开始调试&lt;/h4&gt;
&lt;p&gt;首先将 java 函数以 debug 的方式运行起来：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot;&gt;fun &lt;span class=&quot;hljs-built_in&quot;&gt;local invoke &lt;span class=&quot;hljs-_&quot;&gt;-d 3000 java8&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://tan-blog.oss-cn-hangzhou.aliyuncs.com/img/20181122115333.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到函数卡在这里了，接着我们使用 IDEA 连接并开始调试。可以通过菜单栏上的 &lt;code&gt;Run -&amp;gt; Debug...&lt;/code&gt; 或者工具栏直接点击 Debug 按钮，即可开始调试。&lt;/p&gt;
&lt;p&gt;以下是一个用 IDEA 进行 remote debugging 的完整流程演示：&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://tan-blog.oss-cn-hangzhou.aliyuncs.com/img/fun_local_java_debug_idea.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;14&quot;&gt;本地调试 php 类型的函数&lt;/h3&gt;
&lt;p&gt;php 的调试与其他类型的函数调试在流程上有一些不同。&lt;/p&gt;
&lt;p&gt;首先，php 的运行通过 &lt;code&gt;fun local invoke php72&lt;/code&gt; 命令完成，这与其他类型的函数一致。调试时，也像其他类型的函数一样，通过 -d 参数以调试模式启动函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;shell hljs bash&quot;&gt;fun &lt;span class=&quot;hljs-built_in&quot;&gt;local invoke &lt;span class=&quot;hljs-_&quot;&gt;-d 3000 --config VSCode php72&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但不同的是，以 debug 方式运行 php 函数后，php 函数并没有阻塞等待 vscode 调试器的连接，而是直接运行结束。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;shell hljs ruby&quot;&gt;skip pulling images ...
you can paste these config to .vscode/launch.json, &lt;span class=&quot;hljs-keyword&quot;&gt;and &lt;span class=&quot;hljs-keyword&quot;&gt;then attach to your running function
/&lt;span class=&quot;hljs-regexp&quot;&gt;//&lt;span class=&quot;hljs-regexp&quot;&gt;//&lt;span class=&quot;hljs-regexp&quot;&gt;//&lt;span class=&quot;hljs-regexp&quot;&gt;//&lt;span class=&quot;hljs-regexp&quot;&gt;//&lt;span class=&quot;hljs-regexp&quot;&gt;//&lt;span class=&quot;hljs-regexp&quot;&gt;//&lt;span class=&quot;hljs-regexp&quot;&gt;// config &lt;span class=&quot;hljs-keyword&quot;&gt;begin /&lt;span class=&quot;hljs-regexp&quot;&gt;//&lt;span class=&quot;hljs-regexp&quot;&gt;//&lt;span class=&quot;hljs-regexp&quot;&gt;//&lt;span class=&quot;hljs-regexp&quot;&gt;//&lt;span class=&quot;hljs-regexp&quot;&gt;//&lt;span class=&quot;hljs-regexp&quot;&gt;//&lt;span class=&quot;hljs-regexp&quot;&gt;//&lt;span class=&quot;hljs-regexp&quot;&gt;//
{
    &lt;span class=&quot;hljs-string&quot;&gt;&quot;version&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;0.2.0&quot;,
    &lt;span class=&quot;hljs-string&quot;&gt;&quot;configurations&quot;: [
        {
            &lt;span class=&quot;hljs-string&quot;&gt;&quot;name&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;fc/localdemo/php72&quot;,
            &lt;span class=&quot;hljs-string&quot;&gt;&quot;type&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;php&quot;,
            &lt;span class=&quot;hljs-string&quot;&gt;&quot;request&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;launch&quot;,
            &lt;span class=&quot;hljs-string&quot;&gt;&quot;port&quot;: &lt;span class=&quot;hljs-number&quot;&gt;3000,
            &lt;span class=&quot;hljs-string&quot;&gt;&quot;stopOnEntry&quot;: &lt;span class=&quot;hljs-literal&quot;&gt;false,
            &lt;span class=&quot;hljs-string&quot;&gt;&quot;pathMappings&quot;: {
                &lt;span class=&quot;hljs-string&quot;&gt;&quot;/code&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;/Users/tan/code/fun/examples/local/php7.2&quot;
            },
            &lt;span class=&quot;hljs-string&quot;&gt;&quot;ignore&quot;: [
                &lt;span class=&quot;hljs-string&quot;&gt;&quot;/var/fc/runtime/**&quot;
            ]
        }
    ]
}
/&lt;span class=&quot;hljs-regexp&quot;&gt;//&lt;span class=&quot;hljs-regexp&quot;&gt;//&lt;span class=&quot;hljs-regexp&quot;&gt;//&lt;span class=&quot;hljs-regexp&quot;&gt;//&lt;span class=&quot;hljs-regexp&quot;&gt;//&lt;span class=&quot;hljs-regexp&quot;&gt;//&lt;span class=&quot;hljs-regexp&quot;&gt;//&lt;span class=&quot;hljs-regexp&quot;&gt;// config &lt;span class=&quot;hljs-keyword&quot;&gt;end /&lt;span class=&quot;hljs-regexp&quot;&gt;//&lt;span class=&quot;hljs-regexp&quot;&gt;//&lt;span class=&quot;hljs-regexp&quot;&gt;//&lt;span class=&quot;hljs-regexp&quot;&gt;//&lt;span class=&quot;hljs-regexp&quot;&gt;//&lt;span class=&quot;hljs-regexp&quot;&gt;//&lt;span class=&quot;hljs-regexp&quot;&gt;//&lt;span class=&quot;hljs-regexp&quot;&gt;//
FunctionCompute php7.&lt;span class=&quot;hljs-number&quot;&gt;2 runtime inited.
FC Invoke Start &lt;span class=&quot;hljs-symbol&quot;&gt;RequestId: &lt;span class=&quot;hljs-number&quot;&gt;6e8f7ed7-&lt;span class=&quot;hljs-number&quot;&gt;653d-&lt;span class=&quot;hljs-number&quot;&gt;4a6a-&lt;span class=&quot;hljs-number&quot;&gt;94cc-&lt;span class=&quot;hljs-number&quot;&gt;1ef0d028e4b4
FC Invoke End &lt;span class=&quot;hljs-symbol&quot;&gt;RequestId: &lt;span class=&quot;hljs-number&quot;&gt;6e8f7ed7-&lt;span class=&quot;hljs-number&quot;&gt;653d-&lt;span class=&quot;hljs-number&quot;&gt;4a6a-&lt;span class=&quot;hljs-number&quot;&gt;94cc-&lt;span class=&quot;hljs-number&quot;&gt;1ef0d028e4b4
hello world


&lt;span class=&quot;hljs-symbol&quot;&gt;RequestId: &lt;span class=&quot;hljs-number&quot;&gt;6e8f7ed7-&lt;span class=&quot;hljs-number&quot;&gt;653d-&lt;span class=&quot;hljs-number&quot;&gt;4a6a-&lt;span class=&quot;hljs-number&quot;&gt;94cc-&lt;span class=&quot;hljs-number&quot;&gt;1ef0d028e4b4          Billed &lt;span class=&quot;hljs-symbol&quot;&gt;Duration: &lt;span class=&quot;hljs-number&quot;&gt;48 ms          Memory &lt;span class=&quot;hljs-symbol&quot;&gt;Size: &lt;span class=&quot;hljs-number&quot;&gt;1998 MB        Max Memory &lt;span class=&quot;hljs-symbol&quot;&gt;Used: &lt;span class=&quot;hljs-number&quot;&gt;58 MB&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是因为，对于 php 程序，需要首先启动 vscode 的调试器。&lt;/p&gt;
&lt;p&gt;php 类型的函数启动 VSCode 调试器的流程与其他类型的函数一致：复制上面日志中的 vscode 配置到 launch.json，单击“开始调试”即可。&lt;/p&gt;
&lt;p&gt;然后在终端重新以调试模式启动 php 函数即可开始调试：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;shell hljs bash&quot;&gt;fun &lt;span class=&quot;hljs-built_in&quot;&gt;local invoke &lt;span class=&quot;hljs-_&quot;&gt;-d 3000 php72&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://tan-blog.oss-cn-hangzhou.aliyuncs.com/img/20181116211640.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;15&quot;&gt;Event 事件源&lt;/h2&gt;
&lt;p&gt;函数计算提供了丰富的触发器，包括但不局限于对象存储触发器、日志服务触发器、CDN 事件触发器等。在本地无论是运行还是调试函数时，为了能够完全模拟线上环境，通常需要构造触发事件。&lt;/p&gt;
&lt;p&gt;触发事件可以是一段可读的 json 配置，也可以是一段非可读的二进制数据。这里我们拿 json 举例，假设触发事件内容为:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;json hljs&quot;&gt;{
    &lt;span class=&quot;hljs-attr&quot;&gt;&quot;testKey&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;testValue&quot;
}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;想要将这段事件内容传给函数，可以通过以下三种途径：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;管道: &lt;code&gt;echo '{&quot;testKey&quot;: &quot;testValue&quot;}' | fun local invoke nodejs8&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;文件: 将的 json 内容写入到文件，文件名随意，比如 event.json。然后通过 -e 指定文件名：&lt;code&gt;fun local invoke -e event.json nodejs8 &lt;/code&gt;&lt;/li&gt;
&lt;li&gt;重定向: &lt;code&gt;fun local invoke nodejs8 &amp;lt; event.json&lt;/code&gt; 或者 &lt;code&gt;fun local invoke nodejs8 &amp;lt;&amp;lt;&amp;lt; '{&quot;testKey&quot;: &quot;testValue&quot;}'&lt;/code&gt; 等等。更多信息可以参考这篇文章。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;16&quot;&gt;环境变量&lt;/h2&gt;
&lt;p&gt;在 template.yml 中配置的 EnvironmentVariables 会与线上行为一致，当函数运行时，可以通过代码获取到。更多信息参考。&lt;/p&gt;
&lt;p&gt;在本地运行函数时，除了 EnvironmentVariables 配置的环境变量，fun 还会额外提供一个 &lt;code&gt;local=true&lt;/code&gt; 的环境变量，用来标识这是一个本地运行的函数。&lt;/p&gt;
&lt;p&gt;通过这个环境变量，用户可以区分是本地运行还是线上运行，以便于进行一些特定的逻辑处理。&lt;/p&gt;
&lt;h2 id=&quot;17&quot;&gt;Initializer&lt;/h2&gt;
&lt;p&gt;在 template.yml 中配置的 Initializer 属性会与线上行为一致，当函数运行时，会首先运行 Initializer 指定的方法。Initializer 更多信息 参考。&lt;/p&gt;
&lt;h2 id=&quot;18&quot;&gt;Credentials&lt;/h2&gt;
&lt;p&gt;用户可以通过 Credentials 中存储的 ak 信息访问阿里云的其他服务。Fun local 在本地运行函数时，会按照与 fun deploy 相同的 策略 寻找 ak 信息。&lt;/p&gt;
&lt;p&gt;关于函数计算 Credentials 的描述，可以参考。&lt;/p&gt;
&lt;p&gt;以下是一个根据本地、线上环境的不同，利用函数提供的 Credentials 配置 oss client 的例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;python hljs&quot;&gt;local = bool(os.getenv(&lt;span class=&quot;hljs-string&quot;&gt;'local', &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;))
&lt;span class=&quot;hljs-keyword&quot;&gt;if (local):
    &lt;span class=&quot;hljs-keyword&quot;&gt;print &lt;span class=&quot;hljs-string&quot;&gt;'thank you for running function in local!!!!!!'
    auth = oss2.Auth(creds.access_key_id,
                     creds.access_key_secret)
&lt;span class=&quot;hljs-keyword&quot;&gt;else:
    auth = oss2.StsAuth(creds.access_key_id,
                        creds.access_key_secret,
                        creds.security_token)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;19&quot;&gt;附录&lt;/h2&gt;

&lt;h3 id=&quot;20&quot;&gt;代码&lt;/h3&gt;
&lt;p&gt;本文讲解涉及到的 demo 代码，托管在 github 上。项目目录结构如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;shell hljs css&quot;&gt;.
├── &lt;span class=&quot;hljs-selector-tag&quot;&gt;java8
│   ├── &lt;span class=&quot;hljs-selector-tag&quot;&gt;pom&lt;span class=&quot;hljs-selector-class&quot;&gt;.xml
│   ├── &lt;span class=&quot;hljs-selector-tag&quot;&gt;src
│   │   └── &lt;span class=&quot;hljs-selector-tag&quot;&gt;main
│   │       └── &lt;span class=&quot;hljs-selector-tag&quot;&gt;java
│   │           └── &lt;span class=&quot;hljs-selector-tag&quot;&gt;example
│   │               └── &lt;span class=&quot;hljs-selector-tag&quot;&gt;App&lt;span class=&quot;hljs-selector-class&quot;&gt;.java
│   └── &lt;span class=&quot;hljs-selector-tag&quot;&gt;target
│       └── &lt;span class=&quot;hljs-selector-tag&quot;&gt;demo-1&lt;span class=&quot;hljs-selector-class&quot;&gt;.0-SNAPSHOT&lt;span class=&quot;hljs-selector-class&quot;&gt;.jar
├── &lt;span class=&quot;hljs-selector-tag&quot;&gt;nodejs6
│   └── &lt;span class=&quot;hljs-selector-tag&quot;&gt;index&lt;span class=&quot;hljs-selector-class&quot;&gt;.js
├── &lt;span class=&quot;hljs-selector-tag&quot;&gt;nodejs8
│   └── &lt;span class=&quot;hljs-selector-tag&quot;&gt;index&lt;span class=&quot;hljs-selector-class&quot;&gt;.js
├── &lt;span class=&quot;hljs-selector-tag&quot;&gt;php7&lt;span class=&quot;hljs-selector-class&quot;&gt;.2
│   └── &lt;span class=&quot;hljs-selector-tag&quot;&gt;index&lt;span class=&quot;hljs-selector-class&quot;&gt;.php
├── &lt;span class=&quot;hljs-selector-tag&quot;&gt;python2&lt;span class=&quot;hljs-selector-class&quot;&gt;.7
│   └── &lt;span class=&quot;hljs-selector-tag&quot;&gt;index&lt;span class=&quot;hljs-selector-class&quot;&gt;.py
├── &lt;span class=&quot;hljs-selector-tag&quot;&gt;python3
│   └── &lt;span class=&quot;hljs-selector-tag&quot;&gt;index&lt;span class=&quot;hljs-selector-class&quot;&gt;.py
└── &lt;span class=&quot;hljs-selector-tag&quot;&gt;template&lt;span class=&quot;hljs-selector-class&quot;&gt;.yml&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-spm-anchor-id=&quot;a2c4e.11153940.blogcont672623.i1.418c6f65Cy6ocj&quot;&gt;template.yml 定义了函数计算模型，其中定义了一个名为 localdemo 的服务，并在该服务下，定义了 6 个函数，名称分别是 nodejs6、nodejs8、php72、python27、python3、java8。它们对应的代码目录由 template 中的 CodeUri 定义，分别位于 nodejs6、nodejs8、php7.2、python2.7、python3、java8 目录。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;a href=&quot;https://yq.aliyun.com/articles/672623?utm_content=g_1000030768&quot; target=&quot;_blank&quot;&gt;原文链接&lt;/a&gt;&lt;br/&gt;本文为云栖社区原创内容，未经允许不得转载。&lt;/p&gt;
</description>
<pubDate>Thu, 13 Dec 2018 07:42:00 +0000</pubDate>
<dc:creator>阿里云云栖社区</dc:creator>
<og:description>前言 首先介绍下在本文出现的几个比较重要的概念： 函数计算（Function Compute）: 函数计算是一个事件驱动的服务，通过函数计算，用户无需管理服务器等运行情况，只需编写代码并上传。函数计算</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yunqishequ/p/10114384.html</dc:identifier>
</item>
<item>
<title>webpack配置proxyTable时pathRewrite无效 - 姜小七的填坑之旅</title>
<link>http://www.cnblogs.com/Janejxt/p/webpack_proxyTable_pathReWrite.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Janejxt/p/webpack_proxyTable_pathReWrite.html</guid>
<description>&lt;p&gt;本人webpack版本3.6，webpack-dev-server版本2.9.1，本人按照网上写的版本折腾两天都没通，无意间自己试通了，猜测网上大部分都是照本宣科，没有自己实践&lt;/p&gt;


&lt;p&gt;在项目开发中，接口联调的时候一般都是同域名下，且不存在跨域的情况下进行接口联调，但是当我们在本地启动服务器后，比如本地开发服务下是 &lt;code&gt;http://localhost:8080&lt;/code&gt; 这样的访问链接，但是我们的接口地址是 &lt;code&gt;http://www.xxx.com/save/post&lt;/code&gt; 这样的，我们这样直接使用就会存在跨域的请求，导致接口请求不成功。&lt;/p&gt;
&lt;p&gt;配置：&lt;/p&gt;
&lt;p&gt;我们打开下面路径的文件&lt;/p&gt;
&lt;p&gt;&lt;code&gt;config/index.js&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在其中的&lt;code&gt;dev&lt;/code&gt;对象里面找到：&lt;code&gt;proxyTable: {}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这里就是配置代理的地方，我们进行如下设置：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
module.exports =&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;  dev: {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 代理配置表，在这里可以配置特定的请求代理到对应的API接口&lt;/span&gt;
&lt;span&gt;    proxyTable: {
      &lt;/span&gt;'/api'&lt;span&gt;: {
        target: &lt;/span&gt;'http://www.xxx.com', &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 你接口的域名&lt;/span&gt;
        secure: &lt;span&gt;false&lt;/span&gt;,      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果是https接口，需要配置这个参数为true&lt;/span&gt;
        changeOrigin: &lt;span&gt;true&lt;/span&gt;,     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果接口跨域，需要进行这个参数配置为true&lt;/span&gt;
&lt;span&gt;   
      }
    },
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接口地址原本是 &lt;code&gt;/save/post&lt;/code&gt;，但是为了匹配代理地址，在前面加一个 &lt;code&gt;/api&lt;/code&gt;, 因此接口地址需要写成这样的即可生效 &lt;code&gt;/api/save/post&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;即：&lt;/strong&gt;前端本地启动接口为：http://localhost:8080/api/save/post，转发的代理接口为：http://www.xxx.com/api/save/post，其中的/api为匹配项。&lt;/p&gt;
&lt;p&gt;/api 是本地路径和后端接口路径的匹配前缀，若后端接口给了/api这个前缀，可用上面的写法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;若后端前缀不统一，则可继续添加，写法如下：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
module.exports =&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;  dev: {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 代理配置表，在这里可以配置特定的请求代理到对应的API接口&lt;/span&gt;
&lt;span&gt;    proxyTable: {
      &lt;/span&gt;'/api'&lt;span&gt;: {
        target: &lt;/span&gt;'http://www.xxx.com', &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 你接口的域名&lt;/span&gt;
        secure: &lt;span&gt;false&lt;/span&gt;,      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果是https接口，需要配置这个参数为true&lt;/span&gt;
        changeOrigin: &lt;span&gt;true&lt;/span&gt;,     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果接口跨域，需要进行这个参数配置为true&lt;/span&gt;
&lt;span&gt;   
      },
     &lt;/span&gt;'/api'&lt;span&gt;: {
        target: &lt;/span&gt;'http://www.xxx.com', &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 你接口的域名&lt;/span&gt;
        secure: &lt;span&gt;false&lt;/span&gt;,      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果是https接口，需要配置这个参数为true&lt;/span&gt;
        changeOrigin: &lt;span&gt;true&lt;/span&gt;,     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果接口跨域，需要进行这个参数配置为true&lt;/span&gt;
&lt;span&gt;   
      }
    },
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;那么还有一种情况，是后端的接口没有我们想要的匹配项（前缀）'/api',是直接的http://www.xxx.com/save/post&lt;/strong&gt;，这样的接口，我们就要用到pathRewrite来重写地址，将本地路径上的带匹配前缀的路径：http://localhost:8080/api/save/post上的前缀'/api'转成 ‘ / ’。以下第一种是网络上大部分推荐的，但是我亲测是无效的，估计他们多数用的上面的方法，没有实际使用下面的方法，LZ用以下第一种方法折腾了2天无果，后去看了webpack-dev-server的issue，无意义试通了接口，即下面第二种方法，当然也不排除第一种方法是我的版本问题而没有效果，所以如果大家试了第一种方法有效就当我的方法没说，如果无效，不妨试试我的第二种方法：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一种方法（网上写的方法）&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
module.exports =&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;  dev: {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 代理配置表，在这里可以配置特定的请求代理到对应的API接口&lt;/span&gt;
&lt;span&gt;    proxyTable: {
      &lt;/span&gt;'/api'&lt;span&gt;: {
        target: &lt;/span&gt;'http://www.xxx.com', &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 你接口的域名&lt;/span&gt;
        secure: &lt;span&gt;false&lt;/span&gt;,      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果是https接口，需要配置这个参数为true&lt;/span&gt;
        changeOrigin: &lt;span&gt;true&lt;/span&gt;,     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果接口跨域，需要进行这个参数配置为true&lt;/span&gt;
&lt;span&gt;        pathRewrite: {
          &lt;/span&gt;'^/api': '/'&lt;span&gt;
        }
      }
    },
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;第二种方法（亲测有效的方法）&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
module.exports =&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;  dev: {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 代理配置表，在这里可以配置特定的请求代理到对应的API接口&lt;/span&gt;
&lt;span&gt;    proxyTable: {
     &lt;/span&gt;'/api/*'&lt;span&gt;:{
        target: &lt;/span&gt;&quot;http://XXX.XXX.com&quot;&lt;span&gt;,
        changeOrigin: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
        pathRewrite: {&lt;/span&gt;'/api':'/'&lt;span&gt;}
      }
    },
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;即将上面的匹配项从 ‘/api’ 改成了 '/api/*'&lt;/strong&gt;,至于为什么，我表示也没有搞明白，不过确实调通了代理，希望对大家有帮助&lt;/p&gt;

</description>
<pubDate>Thu, 13 Dec 2018 07:37:00 +0000</pubDate>
<dc:creator>姜小七的填坑之旅</dc:creator>
<og:description>webpack的转发代理中pathReWrite无效处理</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Janejxt/p/webpack_proxyTable_pathReWrite.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core WebAPI中使用JWT Bearer认证和授权 - 车骑</title>
<link>http://www.cnblogs.com/royzshare/p/10114198.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/royzshare/p/10114198.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;

&lt;p&gt;ASP.NET Core 在 Microsoft.AspNetCore.Authentication 下实现了一系列认证, 包含 &lt;code&gt;Cookie&lt;/code&gt;, &lt;code&gt;JwtBearer&lt;/code&gt;, &lt;code&gt;OAuth&lt;/code&gt;, &lt;code&gt;OpenIdConnect&lt;/code&gt; 等,&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Cookie 认证是一种比较常用本地认证方式, 它由浏览器自动保存并在发送请求时自动附加到请求头中, 更适用于 MVC 等纯网页系统的本地认证.&lt;/li&gt;
&lt;li&gt;OAuth &amp;amp; OpenID Connect 通常用于运程认证, 创建一个统一的认证中心, 来统一配置和处理对于其他资源和服务的用户认证及授权.&lt;/li&gt;
&lt;li&gt;JwtBearer 认证中, 客户端通常将 JWT(一种Token) 通过 HTTP 的 Authorization header 发送给服务端, 服务端进行验证. 可以方便的用于 WebAPI 框架下的本地认证.&lt;br/&gt;当然, 也可以完全自己实现一个WebAPI下基于Token的本地认证, 比如自定义Token的格式, 自己写颁发和验证Token的代码等. 这样的话通用性并不好, 而且也需要花费更多精力来封装代码以及处理细节.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;JWT (JSON Web Token) 是一种基于JSON的、用于在网络上声明某种主张的令牌（token）。&lt;br/&gt;作为一个开放的标准（RFC 7519），定义了一种简洁的、自包含的方法，从而使通信双方实现以JSON对象的形式安全的传递信息。&lt;/p&gt;
&lt;p&gt;JWT通常由三部分组成: 头信息（header）, 消息体（payload）和签名（signature）。&lt;br/&gt;头信息指定了该JWT使用的签名算法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;header = {&quot;alg&quot;: &quot;HS256&quot;, &quot;typ&quot;: &quot;JWT&quot;}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;消息体包含了JWT的意图：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;payload = {&quot;sub&quot;: &quot;1234567890&quot;, &quot;name&quot;: &quot;John Doe&quot;, &quot;iat&quot;: 1516239022}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;未签名的令牌由base64url编码的头信息和消息体拼接而成（使用&quot;.&quot;分隔），签名则通过私有的key计算而成：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;key = &quot;secretkey&quot; 
unsignedToken = encodeBase64(header) + '.' + encodeBase64(payload)  
signature = HMAC-SHA256(key, unsignedToken) &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后在尾部拼接上base64url编码的签名（同样使用&quot;.&quot;分隔）就是JWT了：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;token = encodeBase64(header) + '.' + encodeBase64(payload) + '.' + encodeBase64(signature) &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;JWT常常被用作保护服务端的资源，客户端通常将JWT通过HTTP的Authorization header发送给服务端，服务端使用自己保存的key计算、验证签名以判断该JWT是否可信。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Authorization: Bearer &amp;lt;token&amp;gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;相比于传统的 cookie-session 认证机制，优点有：&lt;/p&gt;
&lt;ol readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;更适用分布式和水平扩展&lt;/strong&gt;&lt;br/&gt;在cookie-session方案中，cookie内仅包含一个session标识符，而诸如用户信息、授权列表等都保存在服务端的session中。如果把session中的认证信息都保存在JWT中，在服务端就没有session存在的必要了。当服务端水平扩展的时候，就不用处理session复制（session replication）/ session黏连（sticky session）或是引入外部session存储了。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;适用于多客户端（特别是移动端）的前后端解决方案&lt;/strong&gt;&lt;br/&gt;移动端使用的往往不是网页技术，使用Cookie验证并不是一个好主意，因为你得和Cookie容器打交道，而使用Bearer验证则简单的多。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;无状态化&lt;/strong&gt;&lt;br/&gt;JWT 是无状态化的，更适用于 RESTful 风格的接口验证。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;它的缺点也很明显：&lt;/p&gt;
&lt;ol readability=&quot;2&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;&lt;strong&gt;更多的空间占用&lt;/strong&gt;&lt;br/&gt;JWT 由于Payload里面包含了附件信息，占用空间往往比SESSION ID大，在HTTP传输中会造成性能影响。所以在设计时候需要注意不要在JWT中存储太多的claim,以避免发生巨大的,过度膨胀的请求。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;无法作废已颁布的令牌&lt;/strong&gt;&lt;br/&gt;所有的认证信息都在JWT中，由于在服务端没有状态，即使你知道了某个JWT被盗取了，你也没有办法将其作废。在JWT过期之前（你绝对应该设置过期时间），你无能为力。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ol readability=&quot;65.405127462341&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;定义配置类 JwtIssuerOptions.cs&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class JwtIssuerOptions
{
    /// &amp;lt;summary&amp;gt;
    /// 4.1.1.  &quot;iss&quot; (Issuer) Claim - The &quot;iss&quot; (issuer) claim identifies the principal that issued the JWT.
    /// &amp;lt;/summary&amp;gt;
    public string Issuer { get; set; }

    /// &amp;lt;summary&amp;gt;
    /// 4.1.2.  &quot;sub&quot; (Subject) Claim - The &quot;sub&quot; (subject) claim identifies the principal that is the subject of the JWT.
    /// &amp;lt;/summary&amp;gt;
    public string Subject { get; set; }

    /// &amp;lt;summary&amp;gt;
    /// 4.1.3.  &quot;aud&quot; (Audience) Claim - The &quot;aud&quot; (audience) claim identifies the recipients that the JWT is intended for.
    /// &amp;lt;/summary&amp;gt;
    public string Audience { get; set; }

    /// &amp;lt;summary&amp;gt;
    /// 4.1.4.  &quot;exp&quot; (Expiration Time) Claim - The &quot;exp&quot; (expiration time) claim identifies the expiration time on or after which the JWT MUST NOT be accepted for processing.
    /// &amp;lt;/summary&amp;gt;
    public DateTime Expiration =&amp;gt; IssuedAt.Add(ValidFor);

    /// &amp;lt;summary&amp;gt;
    /// 4.1.5.  &quot;nbf&quot; (Not Before) Claim - The &quot;nbf&quot; (not before) claim identifies the time before which the JWT MUST NOT be accepted for processing.
    /// &amp;lt;/summary&amp;gt;
    public DateTime NotBefore =&amp;gt; DateTime.UtcNow;

    /// &amp;lt;summary&amp;gt;
    /// 4.1.6.  &quot;iat&quot; (Issued At) Claim - The &quot;iat&quot; (issued at) claim identifies the time at which the JWT was issued.
    /// &amp;lt;/summary&amp;gt;
    public DateTime IssuedAt =&amp;gt; DateTime.UtcNow;

    /// &amp;lt;summary&amp;gt;
    /// Set the timespan the token will be valid for (default is 120 min)
    /// &amp;lt;/summary&amp;gt;
    public TimeSpan ValidFor { get; set; } = TimeSpan.FromMinutes(120);


    /// &amp;lt;summary&amp;gt;
    /// &quot;jti&quot; (JWT ID) Claim (default ID is a GUID)
    /// &amp;lt;/summary&amp;gt;
    public Func&amp;lt;Task&amp;lt;string&amp;gt;&amp;gt; JtiGenerator =&amp;gt;
      () =&amp;gt; Task.FromResult(Guid.NewGuid().ToString());

    /// &amp;lt;summary&amp;gt;
    /// The signing key to use when generating tokens.
    /// &amp;lt;/summary&amp;gt;
    public SigningCredentials SigningCredentials { get; set; }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;36&quot;&gt;
&lt;p&gt;定义的帮助类 JwtFactory.cs, 主要是用于生成Token&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public interface IJwtFactory
{
    Task&amp;lt;string&amp;gt; GenerateEncodedToken(string userName, ClaimsIdentity identity);
    ClaimsIdentity GenerateClaimsIdentity(User user);
}

public class JwtFactory : IJwtFactory
{
    private readonly JwtIssuerOptions _jwtOptions;

    public JwtFactory(IOptions&amp;lt;JwtIssuerOptions&amp;gt; jwtOptions)
    {
        _jwtOptions = jwtOptions.Value;
        ThrowIfInvalidOptions(_jwtOptions);
    }

    public async Task&amp;lt;string&amp;gt; GenerateEncodedToken(string userName, ClaimsIdentity identity)
    {
        var claims = new List&amp;lt;Claim&amp;gt;
        {
            new Claim(JwtRegisteredClaimNames.Sub, userName),
            new Claim(JwtRegisteredClaimNames.Jti, await _jwtOptions.JtiGenerator()),
            new Claim(JwtRegisteredClaimNames.Iat, ToUnixEpochDate(_jwtOptions.IssuedAt).ToString(), ClaimValueTypes.Integer64),
            identity.FindFirst(ClaimTypes.Name),
            identity.FindFirst(&quot;id&quot;)
        };
        claims.AddRange(identity.FindAll(ClaimTypes.Role));

        // Create the JWT security token and encode it.
        var jwt = new JwtSecurityToken(
            issuer: _jwtOptions.Issuer,
            audience: _jwtOptions.Audience,
            claims: claims,
            notBefore: _jwtOptions.NotBefore,
            expires: _jwtOptions.Expiration,
            signingCredentials: _jwtOptions.SigningCredentials);

        var encodedJwt = new JwtSecurityTokenHandler().WriteToken(jwt);

        var response = new
        {
            auth_token = encodedJwt,
            expires_in = (int)_jwtOptions.ValidFor.TotalSeconds,
            token_type = &quot;Bearer&quot;
        };

        return JsonConvert.SerializeObject(response, new JsonSerializerSettings { Formatting = Formatting.Indented });
    }

    public ClaimsIdentity GenerateClaimsIdentity(User user)
    {
        var claimsIdentity  = new ClaimsIdentity(new GenericIdentity(user.UserName, &quot;Token&quot;));
        claimsIdentity.AddClaim(new Claim(&quot;id&quot;, user.Id.ToString()));
        claimsIdentity.AddClaim(new Claim(ClaimTypes.Name, user.UserName));
        foreach (var role in user.Roles)
        {
            claimsIdentity.AddClaim(new Claim(ClaimTypes.Role, role));
        }
        return claimsIdentity;
    }

    /// &amp;lt;returns&amp;gt;Date converted to seconds since Unix epoch (Jan 1, 1970, midnight UTC).&amp;lt;/returns&amp;gt;
    private static long ToUnixEpochDate(DateTime date)
      =&amp;gt; (long)Math.Round((date.ToUniversalTime() -
                           new DateTimeOffset(1970, 1, 1, 0, 0, 0, TimeSpan.Zero))
                          .TotalSeconds);

    private static void ThrowIfInvalidOptions(JwtIssuerOptions options)
    {
        if (options == null) throw new ArgumentNullException(nameof(options));

        if (options.ValidFor &amp;lt;= TimeSpan.Zero)
        {
            throw new ArgumentException(&quot;Must be a non-zero TimeSpan.&quot;, nameof(JwtIssuerOptions.ValidFor));
        }

        if (options.SigningCredentials == null)
        {
            throw new ArgumentNullException(nameof(JwtIssuerOptions.SigningCredentials));
        }

        if (options.JtiGenerator == null)
        {
            throw new ArgumentNullException(nameof(JwtIssuerOptions.JtiGenerator));
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;31&quot;&gt;
&lt;p&gt;在 Startup.cs 里面添加相关代码:&lt;/p&gt;
&lt;p&gt;读取配置:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var jwtAppSettingOptions = Configuration.GetSection(nameof(JwtIssuerOptions));
services.Configure&amp;lt;JwtIssuerOptions&amp;gt;(options =&amp;gt;
{
    options.Issuer = jwtAppSettingOptions[nameof(JwtIssuerOptions.Issuer)];
    options.Audience = jwtAppSettingOptions[nameof(JwtIssuerOptions.Audience)];
    options.SigningCredentials = new SigningCredentials(_signingKey, SecurityAlgorithms.HmacSha256);
}); &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;JwtBearer验证:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Startup
{
    private const string SecretKey = &quot;iNivDmHLpUA223sqsfhqGbMRdRj1PVkH&quot;; // todo: get this from somewhere secure
    private readonly SymmetricSecurityKey _signingKey = new SymmetricSecurityKey(System.Text.Encoding.UTF8.GetBytes(SecretKey));

    public void ConfigureServices(IServiceCollection services)
    {
        services.AddSingleton&amp;lt;IJwtFactory, JwtFactory&amp;gt;();

        services.AddAuthentication(options =&amp;gt;
        {
            options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
            options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;

        }).AddJwtBearer(configureOptions =&amp;gt;
        {
            configureOptions.ClaimsIssuer = jwtAppSettingOptions[nameof(JwtIssuerOptions.Issuer)];
            configureOptions.TokenValidationParameters = new TokenValidationParameters
            {
                ValidateIssuer = true,
                ValidIssuer = jwtAppSettingOptions[nameof(JwtIssuerOptions.Issuer)],
                ValidateAudience = true,
                ValidAudience = jwtAppSettingOptions[nameof(JwtIssuerOptions.Audience)],
                ValidateIssuerSigningKey = true,
                IssuerSigningKey = _signingKey,
                RequireExpirationTime = false,
                ValidateLifetime = true,
                ClockSkew = TimeSpan.Zero
            };
            configureOptions.SaveToken = true;
        });
    }

    public void Configure(IApplicationBuilder app, IHostingEnvironment env)
    {
        app.UseAuthentication();
        app.UseMvc();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Swagger相关:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;services.AddSwaggerGen(options =&amp;gt;
{
    var security = new Dictionary&amp;lt;string, IEnumerable&amp;lt;string&amp;gt;&amp;gt; { { &quot;Bearer&quot;, new string[] { } }, };
    options.AddSecurityRequirement(security);
    options.AddSecurityDefinition(&quot;Bearer&quot;, new Swashbuckle.AspNetCore.Swagger.ApiKeyScheme
    {
        Description = &quot;Format: Bearer {auth_token}&quot;,
        Name = &quot;Authorization&quot;,
        In = &quot;header&quot;
    });
});&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;10&quot;&gt;
&lt;p&gt;创建一个控制器 AuthController.cs，用来提供签发 Token 的 API&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[Route(&quot;api/[controller]&quot;)]
[ApiController]
public class AuthController : ControllerBase
{
    private readonly IJwtFactory _jwtFactory;
    private readonly JwtIssuerOptions _jwtOptions;

    public AuthController(IJwtFactory jwtFactory, IOptions&amp;lt;JwtIssuerOptions&amp;gt; jwtOptions)
    {
        _jwtFactory = jwtFactory;
        _jwtOptions = jwtOptions.Value;
    }

    /// &amp;lt;summary&amp;gt;
    /// Log in
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;request&quot;&amp;gt;&amp;lt;/param&amp;gt;
    /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
    [HttpPost(&quot;[action]&quot;)]
    public async Task&amp;lt;IActionResult&amp;gt; Login([FromBody]LoginRequest request)
    {
        var users = TestUsers.Users.Where(r =&amp;gt; r.UserName.Equals(request.UserName));
        if (users.Count() &amp;lt;= 0)
        {
            ModelState.AddModelError(&quot;login_failure&quot;, &quot;Invalid username.&quot;);
            return BadRequest(ModelState);
        }
        var user = users.First();
        if (!request.Password.Equals(user.Password))
        {
            ModelState.AddModelError(&quot;login_failure&quot;, &quot;Invalid password.&quot;);
            return BadRequest(ModelState);
        }

        var claimsIdentity = _jwtFactory.GenerateClaimsIdentity(user.UserName, user.Id.ToString());
        var token = await _jwtFactory.GenerateEncodedToken(user.UserName, claimsIdentity);
        return new OkObjectResult(token);
    }

    /// &amp;lt;summary&amp;gt;
    /// Get User Info
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
    [HttpGet(&quot;[action]&quot;)]
    [Authorize]
    public IActionResult GetUserInfo()
    {
        var claimsIdentity = User.Identity as ClaimsIdentity;
        return Ok(claimsIdentity.Claims.ToList().Select(r=&amp;gt; new { r.Type, r.Value}));
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;为需要保护的API添加 &lt;code&gt;[Authorize]&lt;/code&gt; 特性&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[Route(&quot;api/[controller]&quot;)]
[ApiController]
[Authorize]
public class ValuesController : ControllerBase
{
    // GET api/values
    [HttpGet]
    public ActionResult&amp;lt;IEnumerable&amp;lt;string&amp;gt;&amp;gt; Get()
    {
        return new string[] { &quot;value1&quot;, &quot;value2&quot; };
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;33.760900140647&quot;&gt;
&lt;p&gt;使用 Swagger UI 或者 PostMan 等工具测试&lt;/p&gt;
&lt;p&gt;获取Token:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;curl -X POST &quot;http://localhost:5000/api/Auth/Login&quot; -H &quot;accept: application/json&quot; -H &quot;Content-Type: application/json-patch+json&quot; -d &quot;{ \&quot;userName\&quot;: \&quot;Paul\&quot;, \&quot;password\&quot;: \&quot;Paul123\&quot;}&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回值:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&quot;{\r\n  \&quot;auth_token\&quot;: \&quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJQYXVsIiwianRpIjoiM2I1YzEyMzMtZTI1YS00ZWU5LWJkNjYtY2Y0NjU2YWMzM2QzIiwiaWF0IjoxNTQ0NTg5ODY5LCJodHRwOi8vc2NoZW1hcy54bWxzb2FwLm9yZy93cy8yMDA1LzA1L2lkZW50aXR5L2NsYWltcy9uYW1lIjoiUGF1bCIsImlkIjoiZDM3ZjI3Y2UtODc4MC00NDI1LTkxMzUtYjY4OGE3NmM0YzBmIiwiaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS93cy8yMDA4LzA2L2lkZW50aXR5L2NsYWltcy9yb2xlIjpbImFkbWluaXN0cmF0b3IiLCJhcGlfYWNjZXNzIl0sIm5iZiI6MTU0NDU4OTg2OCwiZXhwIjoxNTQ0NTk3MDY4LCJpc3MiOiJTZWN1cml0eURlbW8uQXV0aGVudGljYXRpb24uSldUIiwiYXVkIjoiaHR0cDovL2xvY2FsaG9zdDo1MDAwLyJ9.UAWLYQ5lA6xWofWIjGsPGWtAMHEtqZSfrfVaBui2mKI\&quot;,\r\n  \&quot;expires_in\&quot;: 7200,\r\n  \&quot;token_type\&quot;: \&quot;Bearer\&quot;\r\n}&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 &lt;a href=&quot;https://jwt.io/&quot; class=&quot;uri&quot;&gt;https://jwt.io/&lt;/a&gt; 上解析 Token 如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
  &quot;sub&quot;: &quot;Paul&quot;,
  &quot;jti&quot;: &quot;3b5c1233-e25a-4ee9-bd66-cf4656ac33d3&quot;,
  &quot;iat&quot;: 1544589869,
  &quot;http://schemas.xmlsoap.org/ws/2005/05/identity/claims/name&quot;: &quot;Paul&quot;,
  &quot;id&quot;: &quot;d37f27ce-8780-4425-9135-b688a76c4c0f&quot;,
  &quot;http://schemas.microsoft.com/ws/2008/06/identity/claims/role&quot;: [&quot;administrator&quot;,&quot;api_access&quot;],
  &quot;nbf&quot;: 1544589868,
  &quot;exp&quot;: 1544597068,
  &quot;iss&quot;: &quot;SecurityDemo.Authentication.JWT&quot;,
  &quot;aud&quot;: &quot;http://localhost:5000/&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用 Token 访问受保护的 API&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;curl -X GET &quot;http://localhost:5000/api/Values&quot; -H &quot;accept: text/plain&quot; -H &quot;Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJQYXVsIiwianRpIjoiM2I1YzEyMzMtZTI1YS00ZWU5LWJkNjYtY2Y0NjU2YWMzM2QzIiwiaWF0IjoxNTQ0NTg5ODY5LCJodHRwOi8vc2NoZW1hcy54bWxzb2FwLm9yZy93cy8yMDA1LzA1L2lkZW50aXR5L2NsYWltcy9uYW1lIjoiUGF1bCIsImlkIjoiZDM3ZjI3Y2UtODc4MC00NDI1LTkxMzUtYjY4OGE3NmM0YzBmIiwiaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS93cy8yMDA4LzA2L2lkZW50aXR5L2NsYWltcy9yb2xlIjpbImFkbWluaXN0cmF0b3IiLCJhcGlfYWNjZXNzIl0sIm5iZiI6MTU0NDU4OTg2OCwiZXhwIjoxNTQ0NTk3MDY4LCJpc3MiOiJTZWN1cml0eURlbW8uQXV0aGVudGljYXRpb24uSldUIiwiYXVkIjoiaHR0cDovL2xvY2FsaG9zdDo1MDAwLyJ9.UAWLYQ5lA6xWofWIjGsPGWtAMHEtqZSfrfVaBui2mKI&quot;&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因为JWT在服务端是没有状态的, 无论用户注销, 修改密码还是Token被盗取, 你都无法将其作废. 所以给JWT设置有效期并且尽量短是很有必要的. 但我们不可能让用户每次Token过期后都重新输入一次用户名和密码为了生成新的Token. 最好是有种方式在用户无感知的情况下完成Token刷新. 所以这里引入了Refresh Token.&lt;/p&gt;
&lt;ol readability=&quot;37.5&quot;&gt;&lt;li readability=&quot;13&quot;&gt;
&lt;p&gt;修改 JwtFactory 中的 GenerateEncodedToken 方法, 新加一个参数 refreshToken, 并在包含在 response 里和 auth_token 一起返回.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public async Task&amp;lt;string&amp;gt; GenerateEncodedToken(string userName, string refreshToken, ClaimsIdentity identity)
{
    var response = new
    {
        auth_token = encodedJwt,
        refresh_token = refreshToken,
        expires_in = (int)_jwtOptions.ValidFor.TotalSeconds,
        token_type = &quot;Bearer&quot;
    };

    return JsonConvert.SerializeObject(response, new JsonSerializerSettings { Formatting = Formatting.Indented });
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;13&quot;&gt;
&lt;p&gt;修改 AuthController 中的 Login Action, 在每次客户端请求 JWT Token 的时候, 同时生成一个 GUID 的 refreshToken. 这个 refreshToken 需要保存在数据库或者缓存里. 这里方便演示放入了 MemoryCache 里面. 缓存的过期时间要比JWT Token的过期时间稍微长一点.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;string refreshToken = Guid.NewGuid().ToString();
var claimsIdentity = _jwtFactory.GenerateClaimsIdentity(user);

_cache.Set(refreshToken, user.UserName, TimeSpan.FromMinutes(11));

var token = await _jwtFactory.GenerateEncodedToken(user.UserName, refreshToken, claimsIdentity);
return new OkObjectResult(token);&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;19&quot;&gt;
&lt;p&gt;添加一个RefreshToken的接口, 接收参数 refresh_token, 然后检查 refresh_token 的有效性, 如果有效生成一个新的 auth_token 和 refresh_token 并返回. 同时需要删除掉原来 refresh_token 的缓存.&lt;br/&gt;这里只是简单的利用缓存的过期时间和auth_token的过期时间相近从而默认 refresh_token 是有效的, 精确期间需要把对应的 auth_token过期时间一起放入缓存, 在刷新Token的时候验证这个时间.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// RefreshToken
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;request&quot;&amp;gt;&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
[HttpPost(&quot;[action]&quot;)]
public async Task&amp;lt;IActionResult&amp;gt; RefreshToken([FromBody]RefreshTokenRequest request)
{
    string userName;
    if (!_cache.TryGetValue(request.RefreshToken, out userName))
    {
        ModelState.AddModelError(&quot;refreshtoken_failure&quot;, &quot;Invalid refreshtoken.&quot;);
        return BadRequest(ModelState);
    }
    if (!request.UserName.Equals(userName))
    {
        ModelState.AddModelError(&quot;refreshtoken_failure&quot;, &quot;Invalid userName.&quot;);
        return BadRequest(ModelState);
    }

    var user = _userService.GetUserByName(request.UserName);
    string newRefreshToken = Guid.NewGuid().ToString();
    var claimsIdentity = _jwtFactory.GenerateClaimsIdentity(user);

    _cache.Remove(request.RefreshToken);
    _cache.Set(newRefreshToken, user.UserName, TimeSpan.FromMinutes(11));

    var token = await _jwtFactory.GenerateEncodedToken(user.UserName, newRefreshToken, claimsIdentity);
    return new OkObjectResult(token);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;24&quot;&gt;
&lt;p&gt;测试&lt;/p&gt;
&lt;p&gt;获取Token:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;curl -X POST &quot;http://localhost:5000/api/Auth/Login&quot; -H &quot;accept: application/json&quot; -H &quot;Content-Type: application/json-patch+json&quot; -d &quot;{ \&quot;userName\&quot;: \&quot;Paul\&quot;, \&quot;password\&quot;: \&quot;Paul123\&quot;}&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回值:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&quot;{\r\n  \&quot;auth_token\&quot;: \&quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJQYXVsIiwianRpIjoiNzA5Y2VkNjEtNWQ2ZS00N2RlLTg4NjctNzVjZGM0N2U0MWZiIiwiaWF0IjoxNTQ0NjgxOTA0LCJodHRwOi8vc2NoZW1hcy54bWxzb2FwLm9yZy93cy8yMDA1LzA1L2lkZW50aXR5L2NsYWltcy9uYW1lIjoiUGF1bCIsImlkIjoiZmE3NjMxYzEtMzk0NS00MzUwLThjM2YtOWYxZDRhODU0MDFhIiwiaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS93cy8yMDA4LzA2L2lkZW50aXR5L2NsYWltcy9yb2xlIjpbImFkbWluaXN0cmF0b3IiLCJhcGlfYWNjZXNzIl0sIm5iZiI6MTU0NDY4MTkwMywiZXhwIjoxNTQ0NjgyNTAzLCJpc3MiOiJTZWN1cml0eURlbW8uQXV0aGVudGljYXRpb24uSldUIiwiYXVkIjoiaHR0cDovL2xvY2FsaG9zdDo1MDAwLyJ9.tEJ-EuaI-BalW4lJEL8aeJzdryKfE440EC4cAVOW1PY\&quot;,\r\n  \&quot;refresh_token\&quot;: \&quot;3093f839-fd3c-47a3-97a9-c0324e4e6b7e\&quot;,\r\n  \&quot;expires_in\&quot;: 600,\r\n  \&quot;token_type\&quot;: \&quot;Bearer\&quot;\r\n}&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;请求RefreshToken:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;curl -X POST &quot;http://localhost:5000/api/Auth/RefreshToken&quot; -H &quot;accept: application/json&quot; -H &quot;Content-Type: application/json-patch+json&quot; -d &quot;{ \&quot;userName\&quot;: \&quot;Paul\&quot;, \&quot;refreshToken\&quot;: \&quot;3093f839-fd3c-47a3-97a9-c0324e4e6b7e\&quot;}&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回新的 auth_token 和 refresh_token&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&quot;{\r\n  \&quot;auth_token\&quot;: \&quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJQYXVsIiwianRpIjoiMjI2M2Y4NGEtZjlmMC00ZTM1LWI1YTUtMDdhYmI0M2UzMWQ5IiwiaWF0IjoxNTQ0NjgxOTIxLCJodHRwOi8vc2NoZW1hcy54bWxzb2FwLm9yZy93cy8yMDA1LzA1L2lkZW50aXR5L2NsYWltcy9uYW1lIjoiUGF1bCIsImlkIjoiZmE3NjMxYzEtMzk0NS00MzUwLThjM2YtOWYxZDRhODU0MDFhIiwiaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS93cy8yMDA4LzA2L2lkZW50aXR5L2NsYWltcy9yb2xlIjpbImFkbWluaXN0cmF0b3IiLCJhcGlfYWNjZXNzIl0sIm5iZiI6MTU0NDY4MTkyMSwiZXhwIjoxNTQ0NjgyNTIxLCJpc3MiOiJTZWN1cml0eURlbW8uQXV0aGVudGljYXRpb24uSldUIiwiYXVkIjoiaHR0cDovL2xvY2FsaG9zdDo1MDAwLyJ9.A1hXNVmkqD80GqfF69LwvarpNf5QedPvKFDcB5xA4Z0\&quot;,\r\n  \&quot;refresh_token\&quot;: \&quot;b33de8ff-5213-4d37-be0b-7b561553e0f7\&quot;,\r\n  \&quot;expires_in\&quot;: 600,\r\n  \&quot;token_type\&quot;: \&quot;Bearer\&quot;\r\n}&quot;&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在认证阶段我们通过用户令牌获取到了用户的Claims，而授权便是对这些Claims进行验证, 比如是否拥有某种角色，年龄是否大于18岁(如果Claims里有年龄信息)等。&lt;/p&gt;
&lt;h2 id=&quot;简单授权&quot;&gt;简单授权&lt;/h2&gt;
&lt;p&gt;ASP.NET Core中使用&lt;code&gt;Authorize&lt;/code&gt;特性授权, 使用&lt;code&gt;AllowAnonymous&lt;/code&gt;特性跳过授权.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//所有用户都可以Login, 但只有授权的用户才可以Logout.
public class AccountController : Controller
{
    [AllowAnonymous]
    public ActionResult Login()
    {
    }
    
    [Authorize]
    public ActionResult Logout()
    {
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;基于固定角色的授权&quot;&gt;基于固定角色的授权&lt;/h2&gt;
&lt;p&gt;适用于系统中的角色是固定的，每种角色可以访问的Controller和Action也是固定的情景.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//可以指定多个角色, 以逗号分隔
[Authorize(Roles = &quot;Administrator&quot;)]
public class AdministrationController : Controller
{
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;基于策略的授权&quot;&gt;基于策略的授权&lt;/h2&gt;
&lt;p&gt;在ASP.NET Core中，重新设计了一种更加灵活的授权方式：基于策略的授权, 它是授权的核心.&lt;br/&gt;在使用基于策略的授权时，首先要定义授权策略，而授权策略本质上就是对Claims的一系列断言。&lt;br/&gt;基于角色的授权和基于Scheme的授权，只是一种语法上的便捷，最终都会生成授权策略。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void ConfigureServices(IServiceCollection services)
{
    services.AddMvc();

    services.AddAuthorization(options =&amp;gt;
    {
        //options.AddPolicy(&quot;Administrator&quot;, policy =&amp;gt; policy.RequireRole(&quot;administrator&quot;));
        options.AddPolicy(&quot;Administrator&quot;, policy =&amp;gt; policy.RequireClaim(ClaimTypes.Role, &quot;administrator&quot;));
        
        //options.AddPolicy(&quot;Founders&quot;, policy =&amp;gt; policy.RequireClaim(&quot;EmployeeNumber&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;));
    });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;[Authorize(Policy = &quot;Administrator&quot;)]
public ActionResult&amp;lt;IEnumerable&amp;lt;string&amp;gt;&amp;gt; GetValueByAdminPolicy()
{
    return new string[] { &quot;GetValueByAdminPolicy&quot; };
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;自定义策略授权&quot;&gt;自定义策略授权&lt;/h2&gt;
&lt;p&gt;基于策略的授权中有一个很重要的概念是&lt;code&gt;Requirements&lt;/code&gt;，每一个Requirement都代表一个授权条件。&lt;br/&gt;Requirement需要继承接口IAuthorizationRequirement。&lt;br/&gt;在 ASP.NET Core 中已经内置了一些常用的实现：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;AssertionRequirement ：使用最原始的断言形式来声明授权策略。&lt;/li&gt;
&lt;li&gt;DenyAnonymousAuthorizationRequirement ：用于表示禁止匿名用户访问的授权策略，并在AuthorizationOptions中将其设置为默认策略。&lt;/li&gt;
&lt;li&gt;ClaimsAuthorizationRequirement ：用于表示判断Cliams中是否包含预期的Claims的授权策略。&lt;/li&gt;
&lt;li&gt;RolesAuthorizationRequirement ：用于表示使用ClaimsPrincipal.IsInRole来判断是否包含预期的Role的授权策略。&lt;/li&gt;
&lt;li&gt;NameAuthorizationRequirement：用于表示使用ClaimsPrincipal.Identities.Name来判断是否包含预期的Name的授权策略。&lt;/li&gt;
&lt;li&gt;OperationAuthorizationRequirement：用于表示基于操作的授权策略。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;除了OperationAuthorizationRequirement外，都有对应的快捷添加方法，比如&lt;code&gt;RequireClaim&lt;/code&gt;，&lt;code&gt;RequireRole&lt;/code&gt;，&lt;code&gt;RequireUserName&lt;/code&gt;等。&lt;/p&gt;
&lt;p&gt;当内置的Requirement不能满足需求时，可以定义自己的Requirement. 下面基于图中所示的用户-角色-功能权限设计来实现一个自定义的验证策略。&lt;br/&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/dd507532883191c2150732af8720f5e0/xmlnote/B06751F32D99498AB3397A0D6FF3B24D/14873&quot; alt=&quot;用户权限表定义&quot;/&gt;&lt;/p&gt;
&lt;ol readability=&quot;33.5&quot;&gt;&lt;li readability=&quot;29&quot;&gt;
&lt;p&gt;添加一个静态类 TestUsers 用于模拟用户数据&lt;br/&gt;这里只是模拟, 实际使用当中肯定是从数据库取数据, 同时也应该有类似于User, Role, Function, UserRole, RoleFunction等几张表保存这些数据.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static class TestUsers
{
    public static List&amp;lt;User&amp;gt; Users = new List&amp;lt;User&amp;gt;
    {
        new User{ Id = Guid.NewGuid(), UserName = &quot;Paul&quot;, Password = &quot;Paul123&quot;, Roles = new List&amp;lt;string&amp;gt;{ &quot;administrator&quot;, &quot;api_access&quot; }, Urls = new List&amp;lt;string&amp;gt;{ &quot;/api/values/getadminvalue&quot;, &quot;/api/values/getguestvalue&quot; }},
        new User{ Id = Guid.NewGuid(), UserName = &quot;Young&quot;, Password = &quot;Young123&quot;, Roles = new List&amp;lt;string&amp;gt;{ &quot;api_access&quot; }, Urls = new List&amp;lt;string&amp;gt;{ &quot;/api/values/getguestvalue&quot; }},
        new User{ Id = Guid.NewGuid(), UserName = &quot;Roy&quot;, Password = &quot;Roy123&quot;, Roles = new List&amp;lt;string&amp;gt;{ &quot;administrator&quot; }, Urls = new List&amp;lt;string&amp;gt;{ &quot;/api/values/getadminvalue&quot; }},
    };
}

public class User
{
    public Guid Id { get; set; }
    public string UserName { get; set; }
    public string Password { get; set; }
    public List&amp;lt;string&amp;gt; Roles { get; set; }
    public List&amp;lt;string&amp;gt; Urls { get; set; }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;创建类 UserService 用于获取用户已授权的功能列表.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public interface IUserService
{
    List&amp;lt;string&amp;gt; GetFunctionsByUserId(Guid id);
}

public class UserService : IUserService
{
    public List&amp;lt;string&amp;gt; GetFunctionsByUserId(Guid id)
    {
        var user = TestUsers.Users.SingleOrDefault(r =&amp;gt; r.Id.Equals(id));
        return user?.Urls;
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;创建 PermissionRequirement&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class PermissionRequirement : IAuthorizationRequirement
{
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;创建 PermissionHandler&lt;br/&gt;获取当前的URL, 并去当前用户已授权的URL List里查看. 如果匹配就验证成功.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class PermissionHandler : AuthorizationHandler&amp;lt;PermissionRequirement&amp;gt;
{
    private readonly IUserService _userService;

    public PermissionHandler(IUserService userService)
    {
        _userService = userService;
    }

    protected override Task HandleRequirementAsync(AuthorizationHandlerContext context, PermissionRequirement requirement)
    {
        var httpContext = (context.Resource as Microsoft.AspNetCore.Mvc.Filters.AuthorizationFilterContext).HttpContext;

        var isAuthenticated = httpContext.User.Identity.IsAuthenticated;
        if (isAuthenticated)
        {
            Guid userId;
            if (!Guid.TryParse(httpContext.User.Claims.SingleOrDefault(s =&amp;gt; s.Type == &quot;id&quot;).Value, out userId))
            {
                return Task.CompletedTask;
            }
            var functions = _userService.GetFunctionsByUserId(userId);
            var requestUrl = httpContext.Request.Path.Value.ToLower();
            if (functions != null &amp;amp;&amp;amp; functions.Count &amp;gt; 0 &amp;amp;&amp;amp; functions.Contains(requestUrl))
            {
                context.Succeed(requirement);
            }
        }
        return Task.CompletedTask;
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;在Startup.cs 的 ConfigureServices 里面注册 PermissionHandler 并添加 Policy.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;services.AddAuthorization(options =&amp;gt;
{
    options.AddPolicy(&quot;Permission&quot;, policy =&amp;gt; policy.Requirements.Add(new PermissionRequirement()));
});
services.AddSingleton&amp;lt;IAuthorizationHandler, PermissionHandler&amp;gt;();&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;9&quot;&gt;
&lt;p&gt;添加测试代码并测试&lt;br/&gt;注意这里Controller, Action需要和用户功能表里的URL一致&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[Route(&quot;api/[controller]&quot;)]
[ApiController]
public class ValuesController : ControllerBase
{
    [HttpGet(&quot;[action]&quot;)]
    [Authorize(Policy = &quot;Permission&quot;)]
    public ActionResult&amp;lt;IEnumerable&amp;lt;string&amp;gt;&amp;gt; GetAdminValue()
    {
        return new string[] { &quot;use Policy = Permission&quot; };
    }

    [HttpGet(&quot;[action]&quot;)]
    [Authorize(Policy = &quot;Permission&quot;)]
    public ActionResult&amp;lt;IEnumerable&amp;lt;string&amp;gt;&amp;gt; GetGuestValue()
    {
        return new string[] { &quot;use Policy = Permission&quot; };
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用我们的模拟数据, 用户 Paul 两个Action GetAdminValue 和 GetGuestValue 都可以访问; Young 只有权限访问 GetGuestValue; 而 Roy 只可以访问 GetAdminValue.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;基于资源的授权&quot;&gt;基于资源的授权&lt;/h2&gt;
&lt;p&gt;有些时候, 授权需要依赖于要访问的资源, 比如:只允许作者自己编辑和删除所写的博客.&lt;br/&gt;这种场景是无法通过Authorize特性来指定授权的, 因为授权过滤器会在MVC的模型绑定之前执行，无法确定所访问的资源。此时，我们需要使用基于资源的授权。&lt;br/&gt;在基于资源的授权中, 我们要判断的是用户是否具有针对该资源的某项操作, 而系统预置的&lt;code&gt;OperationAuthorizationRequirement&lt;/code&gt;就是用于这种场景中的.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class OperationAuthorizationRequirement : IAuthorizationRequirement
{
    public string Name { get; set; }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ol readability=&quot;33&quot;&gt;&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;定义一些常用操作, 方便业务调用.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static class ResourceOperations
{
    public static OperationAuthorizationRequirement Create = new OperationAuthorizationRequirement { Name = &quot;Create&quot; };
    public static OperationAuthorizationRequirement Read = new OperationAuthorizationRequirement { Name = &quot;Read&quot; };
    public static OperationAuthorizationRequirement Update = new OperationAuthorizationRequirement { Name = &quot;Update&quot; };
    public static OperationAuthorizationRequirement Delete = new OperationAuthorizationRequirement { Name = &quot;Delete&quot; };
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;我们是根据资源的创建者来判断用户是否具有操作权限，因此，定义一个资源实体的接口, 包含一个字段 Creator&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public interface IResourceWithCreator
{
    string Creator { get; set; }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;20&quot;&gt;
&lt;p&gt;定义测试数据用于模拟&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static class TestBlogs
{
    public static List&amp;lt;Blog&amp;gt; Blogs = new List&amp;lt;Blog&amp;gt;
    {
        new Blog{ Id = Guid.Parse(&quot;CA4A3FC9-42CA-47F4-B651-36A863023E75&quot;), Name = &quot;Paul_Blog_1&quot;, BlogUrl = &quot;blogs/paul/1&quot;, Creator = &quot;Paul&quot; },
        new Blog{ Id = Guid.Parse(&quot;9C03EDA8-FBCD-4C33-B5C8-E4DFC40258D7&quot;), Name = &quot;Paul_Blog_2&quot;, BlogUrl = &quot;blogs/paul/2&quot;, Creator = &quot;Paul&quot; },
        new Blog{ Id = Guid.Parse(&quot;E05E3625-1885-49A5-87D0-54F7EAF90C88&quot;), Name = &quot;Young_Blog_1&quot;, BlogUrl = &quot;blogs/young/1&quot;, Creator = &quot;Young&quot; },
        new Blog{ Id = Guid.Parse(&quot;E97D5DF4-AE50-4258-84F8-0B3052EB2CB8&quot;), Name = &quot;Roy_Blog_1&quot;, BlogUrl = &quot;blogs/roy/1&quot;, Creator = &quot;Roy&quot; },
    };
}

public class Blog : IResourceWithCreator
{
    public Guid Id { get; set; }
    public string Name { get; set; }
    public string BlogUrl { get; set; }

    public string Creator { get; set; }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;9&quot;&gt;
&lt;p&gt;定义 ResourceAuthorizationHandler&lt;br/&gt;允许任何人创建或查看资源, 有只有资源的创建者才可以修改和删除资源.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class ResourceAuthorizationHandler : AuthorizationHandler&amp;lt;OperationAuthorizationRequirement, IResourceWithCreator&amp;gt;
{
    protected override Task HandleRequirementAsync(AuthorizationHandlerContext context, OperationAuthorizationRequirement requirement, IResourceWithCreator resource)
    {
        if (requirement == ResourceOperations.Create || requirement == ResourceOperations.Read)
        {
            context.Succeed(requirement);
        }
        else
        {
            if (context.User.Identity.Name == resource.Creator)
            {
                context.Succeed(requirement);
            }
        }
        return Task.CompletedTask;
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;在ConfigureServices里注册Handler.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;services.AddSingleton&amp;lt;IAuthorizationHandler, ResourceAuthorizationHandler&amp;gt;();&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;15&quot;&gt;
&lt;p&gt;添加控制器并引入IAuthorizationService进行验证&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[Authorize]
public class BlogsController : ControllerBase
{
    private readonly IAuthorizationService _authorizationService;
    private readonly IBlogService _blogService;

    public BlogsController(IAuthorizationService authorizationService, IBlogService blogService)
    {
        _authorizationService = authorizationService;
        _blogService = blogService;
    }

    [HttpGet(&quot;{id}&quot;, Name = &quot;Get&quot;)]
    public async Task&amp;lt;ActionResult&amp;lt;Blog&amp;gt;&amp;gt; Get(Guid id)
    {
        var blog = _blogService.GetBlogById(id);
        if ((await _authorizationService.AuthorizeAsync(User, blog, ResourceOperations.Read)).Succeeded)
        {
            return Ok(blog);
        }
        else
        {
            return Forbid();
        }
    }

    [HttpPut(&quot;{id}&quot;)]
    public async Task&amp;lt;ActionResult&amp;gt; Put(Guid id, [FromBody] Blog newBlog)
    {
        var blog = _blogService.GetBlogById(id);
        if ((await _authorizationService.AuthorizeAsync(User, blog, ResourceOperations.Update)).Succeeded)
        {
            bool result = _blogService.Update(newBlog);
            return Ok(result);
        }
        else
        {
            return Forbid();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在实际使用当中, 可以通过EF Core拦截或AOP来实现授权验证与业务代码的分离。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/zdz72113/NETCore_BasicKnowledge.Examples/tree/master/SecurityDemo/SecurityDemo.Authentication.JWT&quot;&gt;github&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 13 Dec 2018 07:15:00 +0000</pubDate>
<dc:creator>车骑</dc:creator>
<og:description>[TOC] 为什么是 JWT Bearer ASP.NET Core 在 Microsoft.AspNetCore.Authentication 下实现了一系列认证, 包含 , , , 等, Cook</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/royzshare/p/10114198.html</dc:identifier>
</item>
<item>
<title>前端入门23-CSS预处理器（Less&amp;Sass） - 请叫我大苏</title>
<link>http://www.cnblogs.com/dasusu/p/10114097.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dasusu/p/10114097.html</guid>
<description>&lt;p&gt;本篇内容梳理自以下几个来源：&lt;/p&gt;
&lt;p&gt;感谢大佬们的分享。&lt;/p&gt;

&lt;h3 id=&quot;css预处理&quot;&gt;CSS预处理&lt;/h3&gt;
&lt;p&gt;什么是 CSS 预处理？为什么要有 CSS 预处理？&lt;/p&gt;
&lt;p&gt;这里就讲讲这两个问题，写过 CSS 应该就会比较清楚，虽然我才刚入门，但在写一些练手时就已经有点感觉了：写 CSS 后，很难维护，维护基本要靠注释来，而且由于 HTML 文档中标签的嵌套层次复杂，导致写 CSS 的选择器时也很费劲，尤其是在后期为某部分标签新增样式时，总会不知道到底应该在 CSS 文件中哪里写这个选择器，这个选择器是否会与前面冲突。&lt;/p&gt;
&lt;p&gt;最有感觉的一点是，CSS 代码基本没法复用，一个页面一份 CSS，每次都需要重写，只是很多时候，可以直接去旧的里面复制粘贴。&lt;/p&gt;
&lt;p&gt;有这么些问题是因为 CSS 本身并不是一门编程语言，它只是一个标记语言，静态语言，不具备编程语言的特性，所以写容易，但维护会比较难。&lt;/p&gt;
&lt;p&gt;这个时候，CSS 预处理器就出现了，其实应该是说 Sass 和 Less 这类语言出现了。&lt;/p&gt;
&lt;p&gt;Sass 和 Less 这类语言，其实可以理解成 CSS 的超集，也就是它们是基于 CSS 原本的语法格式基础上，增加了编程语言的特性，如变量的使用、逻辑语句的支持、函数等。让 CSS 代码更容易维护和复用。&lt;/p&gt;
&lt;p&gt;但浏览器最终肯定是只认识 CSS 文件的，它并无法处理 CSS 中的那些变量、逻辑语句，所以需要有一个编译的过程，将 Sass 或 Less 写的代码转换成标准的 CSS 代码，这个过程就称为 CSS 预处理。&lt;/p&gt;
&lt;p&gt;所以，CSS 预处理器其实只是一个过程的称呼，主要工作就是将源代码编译并输出标准的 CSS 文件，而这个源代码可以用 Sass 写，也可以用 Less，当然还有其他很多种语言。&lt;/p&gt;
&lt;p&gt;那么，到底哪一种语言好，我还没能力来讨论，反正存在即有理，每种语言总它的优缺点、总有它的适用场景。&lt;/p&gt;
&lt;p&gt;下面，主要就来介绍下其中的两种语言：Less 和 Sass。&lt;/p&gt;
&lt;p&gt;我觉得，掌握 CSS 预处理的关键，其实也就两点，一是掌握语言的语法、二是清楚怎么编译成标准的 CSS 文件；语法基本都不会很难，编译一般需要配置一些环境，因为我使用的开发工具是 WebStrom，所以会介绍下 WebStrom 上的配置。&lt;/p&gt;
&lt;h3 id=&quot;less&quot;&gt;Less&lt;/h3&gt;
&lt;h4 id=&quot;使用&quot;&gt;使用&lt;/h4&gt;
&lt;p&gt;Less 写的 CSS 文件后缀名为 &lt;code&gt;.less&lt;/code&gt;，但浏览器并不认识 less 文件，所以最后需要转换成 css 文件，有两种方式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;借助 less.js&lt;/strong&gt;，程序运行期间，浏览器会自动借助 less.js 来解析 less 文件内的代码，转成 css 标准语法&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这种方式，不需要配置任何其他环境，只需要下载 less.js，并在项目中使用即可，但有几点需要注意：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;head&amp;gt;
    &amp;lt;!--link标签需要设置 rel=stylesheet/less, less.js的加载需要放在所有 link 标签后面--&amp;gt;
    &amp;lt;link rel=&quot;stylesheet/less&quot; type=&quot;text/css&quot; href=&quot;css/src/main.less&quot;/&amp;gt;
    &amp;lt;link rel=&quot;stylesheet/less&quot; type=&quot;text/css&quot; href=&quot;css/src/test.less&quot;/&amp;gt;
    &amp;lt;script src=&quot;js/lib/less.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;HTML 文档通过 link 标签引入 less 文件时，需要将 link 标签的 rel 属性设置为 stylesheet/less，否则无效；&lt;/p&gt;
&lt;p&gt;而且，用 &amp;lt;script&amp;gt; 标签加载 less.js 的代码需要放在最后，即所有用 link 标签引入 less 文件的后面，因为 less.js 文件加载成功后就会去将 less 转成 css 标准样式，在 &amp;lt;script&amp;gt; 标签后面才用 link 标签引入的那些 less 文件就无法被转换了。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/less/less.js/releases&quot;&gt;less.js 下载地址：https://github.com/less/less.js/releases&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;借助 node.js 环境&lt;/strong&gt;，安装完 less 后，执行 lessc 命令&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;第一种方式，虽然便捷，但会让页面的渲染多了一个转换步骤，延长页面渲染时长，所以，还可以用第二种方式，直接在本地将 less 转成 css 文件后，项目直接使用转换后输出的 css 文件。&lt;/p&gt;
&lt;p&gt;假设你已经在电脑上安装了 node.js 了，如果还没有，先去网上自行搜索下教程，很多，也很快。&lt;/p&gt;
&lt;p&gt;首次使用需要先安装 less，打开终端，执行下述命令：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;npm install -g less&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;安装完后，就可以使用 lessc 命令，如：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;lessc main.less main.css&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这是最简单的用法，将 main.less 文件编译输出 main.css；还有其他高级的用法，比如顺便压缩 css 文件，输出 .min.css 文件等等。&lt;/p&gt;
&lt;h4 id=&quot;webstorm配置&quot;&gt;WebStorm配置&lt;/h4&gt;
&lt;p&gt;我是比较习惯使用第二种方式，也就是在本地就将 less 文件转成 css 文件，项目里是直接使用转换后输出的 css 文件了，而且我用的开发工具是 WebStrom，所以可以借助它，省去了每次自己输命令的操作：&lt;/p&gt;
&lt;p&gt;第一步：在项目根目录下执行 &lt;code&gt;npm init -y&lt;/code&gt; 初始化项目，初始化完项目后，根目录会生成 package.json 文件；&lt;/p&gt;
&lt;p&gt;第二步：打开 package.json，在里面的 scripts 字段，根据你的项目结构，输入脚本命令；&lt;/p&gt;
&lt;p&gt;第三步：点击 scripts 旁边的三角形按钮，就可以自动执行脚本命令，完成转换工作；&lt;/p&gt;
&lt;p&gt;第四步：（可选）如果嫌每次都需要自己手动点击按钮麻烦，可以将这项工作添加进 File Watcher 功能中，每次文件改动就会自动执行脚本命令，完成转换，具体参考&lt;a href=&quot;https://www.cnblogs.com/dasusu/p/10105433.html&quot;&gt;上一篇&lt;/a&gt;，或者自行搜索，很简单。&lt;/p&gt;
&lt;p&gt;这是例子的项目结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-62c124ed1dbc6c65.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;src 目录中存放 less 文件，dist 目录中存放转换后输出的 css 文件，所以，我的 package.json 里的脚本命令如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-9ebc6e6b0af1287e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;具体的脚本命令可根据实际需求，实际项目结构，自行决定。&lt;/p&gt;
&lt;h4 id=&quot;语法&quot;&gt;语法&lt;/h4&gt;
&lt;p&gt;好了，清楚了 less 文件的两种使用方式后，就可以来学习语法了，这样在学习语法过程中，就可以随时进行转换，查看 less 书写的代码，最终转换的 css 代码是什么样的，这样比较着学习比较容易掌握。&lt;/p&gt;
&lt;p&gt;通过 &lt;code&gt;@变量名:&lt;/code&gt; 来定义变量，通过 &lt;code&gt;@变量名&lt;/code&gt; 使用变量，其实本质上是常量了，如：&lt;/p&gt;
&lt;pre class=&quot;less&quot;&gt;
&lt;code&gt;@width: 10px;  /*定义变量*/
@height: @width + 10px; /*使用变量，和逻辑语句*/

#header {
  width: @width;  /*使用变量*/
  height: @height;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;转换成 CSS 文件：&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;/*定义变量*/
/*使用变量，和逻辑语句*/
#header {
  width: 10px;
  /*使用变量*/
  height: 20px;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上个例子中，转换后的注释也还保留着，这是因为 less 和 css 都支持 &lt;code&gt;/* */&lt;/code&gt; 的注释方式，所以这种会保留，但如果是 &lt;code&gt;//&lt;/code&gt;，这种只有在 less 中支持，css 不支持，那么这种注释就不会保留，验证下：&lt;/p&gt;
&lt;pre class=&quot;less&quot;&gt;
&lt;code&gt;/*这是注释1*/
//这是注释2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;转换成 css 文件：&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;/*这是注释1*/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以，在 less 中使用注释时，需要注意下，哪些是想保留，哪些是不想保留的。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Mixins（混合）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;也有的文章里翻译成混入，还有的文章直接保留单词，不做翻译，可能是觉得中文翻译不能够很好的表达意思吧。&lt;/p&gt;
&lt;p&gt;先说有这么种场景：有时候写在某个选择器中的属性样式，在其他选择器中也需要，所以通常是直接将那部分复制粘贴过来使用。&lt;/p&gt;
&lt;p&gt;而 less 的 Mixins 允许你在某个选择器内，直接使用其他选择器内的属性样式，所以中文翻译才有混合，或混入之说，其实也就是将其他的属性样式混合到当前选择器中。&lt;/p&gt;
&lt;p&gt;看个例子就明白了：&lt;/p&gt;
&lt;pre class=&quot;less&quot;&gt;
&lt;code&gt;.class1 {   //类选择器 class1 的属性样式
  width: 10px;
  height: 20px;
}

.class2(@color: #fff) {  //定义了一个模板样式，类似于函数的作用
  background-color: @color;
}

#id1() {  //定义了一个模板样式，类似于函数作用
  border: 1px solid #ff22ff;
}

.mian { 
  .class1; //直接使用其他选择器定义的属性样式
  .class2(#f2f); //使用模板样式，传入参数
  #id1; //使用模板样式，不传参时，括号可省略
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;转换后的 CSS 文件：&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;.class1 {
  width: 10px;
  height: 20px;
}
.mian {
  width: 10px;
  height: 20px;
  background-color: #f2f;
  border: 1px solid #ff22ff;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以注意对比源代码和转换后的代码，原本就定义好的基本选择器，如 &lt;code&gt;.class1&lt;/code&gt;，可直接在其他选择器内通过 &lt;code&gt;.calss1&lt;/code&gt; 将它内部的属性样式都复制过来。&lt;/p&gt;
&lt;p&gt;也可以在基本选择器后面加上 &lt;code&gt;()&lt;/code&gt; 括号，这样一来，这个就会被当做模板处理，作用类似于函数，可接收参数，使用时就类似于调用函数那么使用，如果不传参，调用时也可以将括号省略。既然是作为函数使用，那么它们存在的意义就只是被调用，所以转换后的 CSS 中并不会存在这个函数。&lt;/p&gt;
&lt;p&gt;另外，有的文章中，对 Mixins 的解释是说，在 class 中使用 class，但上面的例子中也测试了，class 中也是可以使用其他 id 选择器的属性样式的，所以应该不仅限于 class 类选择器，但不能用于组合选择器中。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;命名空间&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我对于命名空间的理解：属于 less 自己的命名空间，也就是这些代码并不会在转换后的 CSS 文件中出现，因为它只属于 less。&lt;/p&gt;
&lt;p&gt;所以，其实也就是上述例子中，类似函数存在的那些模板选择器，当在书写选择器时，在其后面增加 &lt;code&gt;()&lt;/code&gt; 括号，则表示这个选择器只属于 less 的命名空间，转成 CSS 后并不会出现。k&lt;/p&gt;
&lt;p&gt;在写 CSS 时，组合选择器经常写得很复杂，因为 HTML 里的标签嵌套层次本身就很复杂，而且组合选择器写完也不是能够很明显的表示出它的目的，所以 less 允许依据 HTML 中的嵌套层次来书写，不用去记那么多组合选择器的规则，如：&lt;/p&gt;
&lt;pre class=&quot;less&quot;&gt;
&lt;code&gt;body {
  font-size: 16px;
  .content {
    .banner {
      ul {
        img {
          width: 700px;
          height: 300px;
          &amp;amp;:hover {
            width: 800px;
            height: 300px;
          }
        }
      }
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;转换成 CSS 文件：&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;body {
  font-size: 16px;
}
body .content .banner ul img {
  width: 700px;
  height: 300px;
}
body .content .banner ul img:hover {
  width: 800px;
  height: 300px;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也就是，子孙后代的组合选择器规则可以不用去记，直接根据 HTML 文档中标签的嵌套层次来书写即可，这样便于后期维护，如果要对某个标签新增某些样式，也知道该去哪里找。&lt;/p&gt;
&lt;p&gt;有一点需要注意的是，类似 &lt;code&gt;a:hover&lt;/code&gt; 这种伪类选择器，需要加一个 &lt;code&gt;&amp;amp;&lt;/code&gt; 符号。&lt;/p&gt;
&lt;p&gt;less 允许在代码中进行一些简单的加、减、乘、除基本运算，结合变量的使用，可进行一些字体、颜色等的动态运算效果。&lt;/p&gt;
&lt;pre class=&quot;less&quot;&gt;
&lt;code&gt;@border: 1px;
@color: #fff;
#header {
  color: @color * 0.5;
  border-width: @border @border*2 @border*3 @border*4;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;转换成 CSS 后：&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;#header {
  color: #808080;
  border-width: 1px 2px 3px 4px;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通常，变量和运算都是用于对颜色、大小等进行计算。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;内置函数&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;less 内置了一些基础函数，可用于转换颜色、处理字符串、算术运算等，这里列举一些函数：&lt;/p&gt;
&lt;pre class=&quot;less&quot;&gt;
&lt;code&gt;color(&quot;#aaa&quot;);  //输出 #aaa， 将字符串的颜色值转换为颜色值
image-size(&quot;file.png&quot;);  //输出 =&amp;gt; 10px 10px，获取图片文件的宽高信息
//image-with(&quot;file.png&quot;); image-height(&quot;file.png&quot;); 获取图片文件宽高
convert(9s, &quot;ms&quot;);  //输出 =&amp;gt; 9000ms，单位换算，例如对 m,cm,mmin,pt,pc的换算
@size: if((true), 1px, 0px);  //if函数，第一个参数为条件，满足则返回第二个参数，不满足返回第三个参数
if(not (true), 1px, 0px);     //非语句， not
if((true) and (true), 1px, 0px); //逻辑与语句， and 
if((false) or (true), 1px, 0px); //逻辑或语句， or 

//处理数组
@list: &quot;banana&quot;, &quot;tomato&quot;, &quot;potato&quot;, &quot;peach&quot;;
length(@list);  // 输出 =&amp;gt; 4
extract(@list, 3);  //输出 =&amp;gt; potato,注意第一个不是从 0 开始计算

//类型判断
isnumber(#ff0);  // false
isstring(&quot;234&quot;); // true
iscolor(#ff0);   // true
isXXX

...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;内置函数很多，用途也很多，覆盖了基本算术运算、逻辑语句、颜色计算、字符串处理等等，需要用时再查手册吧。&lt;/p&gt;
&lt;p&gt;作用域很好理解，就是类似 JavaScript 中的变量作用域，因为在 less 中都是通过 &lt;code&gt;@变量名:&lt;/code&gt; 来定义变量的，后定义的会覆盖掉前定义的，但当在不同嵌套层次中定义同一变量时，就存在局部变量和外部变量之分，内部变量并不会覆盖掉外部变量。&lt;/p&gt;
&lt;p&gt;而且，less 的变量定义也有类似 JavaScript 中的提前特性，如：&lt;/p&gt;
&lt;pre class=&quot;less&quot;&gt;
&lt;code&gt;@var: red;

#aaa {
  color: @var;  // yellow，因为后面定义的 @var:yellow 将 @var:red 覆盖掉了
}

#page {
  #header {
    color: @var; // white，内部变量不影响外部变量
  }
  @var: white;
}

@var: yellow;

#ppp {
  color: @var;  //yellow
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看看转换成 CSS 后：&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;#aaa {
  color: yellow;
}
#page #header {
  color: white;
}
#ppp {
  color: yellow;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;import（导入）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果某份 less 文件是可以复用的，那么可以使用 &lt;code&gt;@import&lt;/code&gt; 命令将其全部引入使用。&lt;/p&gt;
&lt;pre class=&quot;less&quot;&gt;
&lt;code&gt;@import &quot;main&quot;;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-dc39a7a68fbca83f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后在 test.css 里会汇合 main.less 里的代码。&lt;/p&gt;
&lt;p&gt;以上，只是介绍 less 的基础语法，还有更多详细、复杂的语法用途，需要时再翻阅文档吧。&lt;/p&gt;
&lt;h3 id=&quot;sassscss&quot;&gt;Sass（Scss）&lt;/h3&gt;
&lt;p&gt;Sass 相比于 Less 功能会更强大，但也更复杂。&lt;/p&gt;
&lt;p&gt;Sass 和 Scss 本质是一家，Sass 早期版本的文件后缀名是 &lt;code&gt;.sass&lt;/code&gt;，从 Sass 3 之后，因为修改了一些特性语法，Sass 更加强大且易使用，从这个版本之后的文件后缀名改成了 &lt;code&gt;.scss&lt;/code&gt;，所以 Scss 其实 Sass 的新版本的称呼，但两者本质上没太大区别。&lt;/p&gt;
&lt;p&gt;Scss 是基于 Sass 的语法基础上，修改了一部分的语法。比如早期的 Sass 是通过换行和缩进如：&lt;/p&gt;
&lt;pre class=&quot;sass&quot;&gt;
&lt;code&gt;#sidebar
  width: 30%
  background-color: #faa&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种语法格式跟 CSS 不一致，让使用者会很不习惯，Scss 之后就换成用分号和括号了：&lt;/p&gt;
&lt;pre class=&quot;scss&quot;&gt;
&lt;code&gt;#sidebar {
  width: 30%;
  background-color: #faa;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;使用-1&quot;&gt;使用&lt;/h4&gt;
&lt;p&gt;Sass 不像 Less 一样可以直接借助 less.js 来进行转换，它是基于 Ruby 运行环境，所以电脑上需要先安装 Ruby，然后才能有办法将 Sass 文件转成 CSS。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://rubyinstaller.org/downloads/&quot;&gt;Ruby 下载地址：https://rubyinstaller.org/downloads/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;因为是 exe 文件，下载完直接按提示安装就可以了，安装后打开终端，执行 gem 命名安装 Sass：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;gem install sass&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;安装完 Sass 后，就可以通过 scss 命令来进行转换工作了，如：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;scss main.scss main.css&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;上述命令中，scss 换成 sass 也可以，但注意，scss 或 sass 命令是基于 Ruby 环境下运行的命令，因为电脑上已经安装过 Ruby 了，也通过 Ruby 安装了 Sass，所以才可以在终端里直接执行 scss 命令。&lt;/p&gt;
&lt;p&gt;而类似于 Less 中说到的，WebStrom 可以借助 package.json 里的 scripts 来手动运行脚本命令，这有个前提，就这些脚本命令是运行在 node.js 环境上的，所以如果你直接将上述 scss 命令配置到 package.json 的 script 里，你会发现，是运行不了的。&lt;/p&gt;
&lt;p&gt;要解决这个问题，让 WebStrom 能够运行 sass 命令来处理转换工作有两种方式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;直接去 WebStrom 配置 File Watcher，program 选择 Ruby 目录中的 sass.bat 或 scss.bat&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这种方式下，每次配置的文件变动时，会自动生成对应的 css 文件，转换工作会自动实时进行。但如果不习惯这种方式，想要每次编写完 scss 代码后，手动来触发转换工作，那么可以选择第二种方式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通过 npm 命令安装 sass&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在终端里执行 &lt;code&gt;npm install -g sass&lt;/code&gt;，这样就可以类似配置 less 那样的步骤来使用 sass 命令了，在 package.json 里配置相关命令，然后手动点击脚本的运行即可。&lt;/p&gt;
&lt;p&gt;但 npm 安装的 sass 跟在 Ruby 下安装的 sass 是否有和区别，我不清楚，用段时间，如果有啥问题再来说说。&lt;/p&gt;
&lt;p&gt;而且，对于选择使用 Sass，刚接触可能会有些困惑，是应该使用哪个后缀名的文件，命令是该用 sass 还是 scss 来进行转换，我也有这个困惑，但感觉好像并没有什么区别，先试着用段时间，以后熟悉了再来讲讲。&lt;/p&gt;
&lt;p&gt;最后，Sass 虽然有 &lt;code&gt;.sass&lt;/code&gt; 和 &lt;code&gt;.scss&lt;/code&gt; 两种后缀名的文件，但建议使用 &lt;code&gt;.scss&lt;/code&gt;，因为前者的语法跟 CSS 很不一样，使用起来会有些不习惯，当然如果你有 Ruby 基础的话，可能会比较喜欢这种。我个人会选择后者。&lt;/p&gt;
&lt;h4 id=&quot;语法-1&quot;&gt;语法&lt;/h4&gt;
&lt;p&gt;语法方面，大部分类似于 Less，但就细节方面可能有些不一样，还有，支持更多更强大的功能吧。&lt;/p&gt;
&lt;p&gt;上面介绍的 Less 的基础语法、基础功能，Sass 也基本全部支持，也差不了多少，所以下面就不一个个来介绍了，详细的到开头声明部分给的中文网链接中去查阅即可。&lt;/p&gt;
&lt;p&gt;下面就主要列一些不同的地方：&lt;/p&gt;
&lt;p&gt;Sass 中的变量用 &lt;code&gt;$变量名:&lt;/code&gt; 定义，用 &lt;code&gt;$变量名&lt;/code&gt; 使用，其余跟 Less 差不了多少。&lt;/p&gt;
&lt;p&gt;Less 中的变量分局部作用域和全局作用域，但在 Sass 中，不同版本，作用域范围并不一样，摘抄一段原文中描述：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Sass 中变量的作用域在过去几年已经发生了一些改变。直到最近，规则集和其他范围内声明变量的作用域才默认为本地。如果已经存在同名的全局变量，则局部变量覆盖全局变量。从 Sass 3.4 版本开始，Sass 已经可以正确处理作用域的概念，并通过创建一个新的局部变量来代替。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;条件语句&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Less 中并不支持条件语句，当然，可以通过内置函数 if 以及 and，or，not 这些来模拟条件语句。&lt;/p&gt;
&lt;p&gt;在 Sass 中是支持条件语句的，但也不是像其他编程语言直接 if 这样通过保留字来编写，需要加个 &lt;code&gt;@&lt;/code&gt; 符合，如：&lt;/p&gt;
&lt;pre class=&quot;scss&quot;&gt;
&lt;code&gt;@if $support-legacy {
  // …
} @else {
  // …
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;教程中给了几条准则要求：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;除非必要，不然不需要括号；&lt;/li&gt;
&lt;li&gt;务必在 &lt;code&gt;@if&lt;/code&gt; 之前添加空行；&lt;/li&gt;
&lt;li&gt;务必在左开大括号(&lt;code&gt;{&lt;/code&gt;)后换行；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@else&lt;/code&gt; 语句和它前面的右闭大括号(&lt;code&gt;}&lt;/code&gt;)写在同一行；&lt;/li&gt;
&lt;li&gt;务必在右闭大括号(&lt;code&gt;}&lt;/code&gt;)后添加空行，除非下一行还是右闭大括号(&lt;code&gt;}&lt;/code&gt;)，那么就在最后一个右闭大括号(&lt;code&gt;}&lt;/code&gt;)后添加空行。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;另外，教程中也说了：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;除非你的代码中有偏复杂的逻辑，否则没必要在日常开发的样式表中使用条件语句。实际上，条件语句主要适用于库和框架。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其他区别，等用段时间，熟悉了再来讲讲。&lt;/p&gt;
&lt;h4 id=&quot;框架-compass&quot;&gt;框架-&lt;a href=&quot;http://compass-style.org/&quot;&gt;Compass&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Sass 有一点比 Less 有优势的就是，目前有很多稳定且热门的基于 Sass 编写的框架库，比如：&lt;a href=&quot;http://compass-style.org/&quot;&gt;Compass&lt;/a&gt;、&lt;a href=&quot;http://bourbon.io/&quot;&gt;Bourbon&lt;/a&gt; 和 &lt;a href=&quot;http://susy.oddbird.net/&quot;&gt;Susy&lt;/a&gt; 等。&lt;/p&gt;
&lt;p&gt;这些框架库就类似于 jQurey 和 JavaScript 关系，对 Sass 进行了一层封装，让编写 Sass 代码的人，可以极为简便的开发，我还没用过，就不过多介绍了。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;大家好，我是 dasu，欢迎关注我的公众号（dasuAndroidTv），公众号中有我的联系方式，欢迎有事没事来唠嗑一下，如果你觉得本篇内容有帮助到你，可以转载但记得要关注，要标明原文哦，谢谢支持~&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-d7190704b160d280.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;dasuAndroidTv2.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 13 Dec 2018 07:01:00 +0000</pubDate>
<dc:creator>请叫我大苏</dc:creator>
<og:description>声明 本篇内容梳理自以下几个来源：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dasusu/p/10114097.html</dc:identifier>
</item>
<item>
<title>Winform TreeView实现多级目录Checkbox状态判断 - blueshard</title>
<link>http://www.cnblogs.com/hicolin/p/10113953.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hicolin/p/10113953.html</guid>
<description>&lt;ul&gt;&lt;li&gt;大概是这么个样子：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/601875/201812/601875-20181213142145281-42532377.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;大概是这么个思路：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　当变更（点击）节点的选中状态的时候，同步更新所有子节点(包括子节点的子节点）状态，并且判断所有兄弟节点的状态若都是选中状态，更新父级节点状态为选中，否则，更新父节点（包括父节点的父节点）为未选中状态。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;划重点：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　要点1： treeView.CheckBoxes = true;&lt;/p&gt;
&lt;p&gt;　　要点2：不能使用AfterCheck事件，会导致无限递归&lt;/p&gt;
&lt;p&gt;　　要点3：递归更新状态&lt;/p&gt;
&lt;p&gt;　　要点4：递归检查状态&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;代码片段：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_600f0bd6-4c44-47c7-8f26-f2405065ff9f&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_600f0bd6-4c44-47c7-8f26-f2405065ff9f&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_600f0bd6-4c44-47c7-8f26-f2405065ff9f&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 更新子节点状态
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;node&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;bl&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;void&lt;/span&gt; Changechild(TreeNode node, &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; bl)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (node.Level &amp;lt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 &lt;span&gt;foreach&lt;/span&gt; (TreeNode item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; node.Nodes)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                     item.Checked =&lt;span&gt; bl;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (item.Level &amp;lt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;                        Changechild(item, bl);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;Changechild&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_ce428af8-70a0-4c63-a87c-8fae04ebe1df&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_ce428af8-70a0-4c63-a87c-8fae04ebe1df&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_ce428af8-70a0-4c63-a87c-8fae04ebe1df&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 变更父节点状态
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;node&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;bl&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;void&lt;/span&gt; ChangeParent(TreeNode node, &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; bl)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断兄弟节点是否全部选中&lt;/span&gt;
            &lt;span&gt;bool&lt;/span&gt; parentstate = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (bl)
            {
                &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (TreeNode item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; node.Parent.Nodes)
                {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;item.Checked)
                    {
                        parentstate &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                    }
                }
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                parentstate &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }
            node.Parent.Checked &lt;/span&gt;=&lt;span&gt; parentstate;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node.Parent.Level &amp;gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
            {
                ChangeParent(node.Parent, parentstate);
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;ChangeParent&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_b0a640a0-c67d-454c-bce8-12d21a7c0d71&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_b0a640a0-c67d-454c-bce8-12d21a7c0d71&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_b0a640a0-c67d-454c-bce8-12d21a7c0d71&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 1级节点，判断子节点（2级）是否全部选中,只要有一个子节点未选中，则当前节点不选中
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;node&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;bl&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;void&lt;/span&gt;&lt;span&gt; CheckChild(TreeNode node)
        {
            &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; parentchecked = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (TreeNode item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; node.Nodes)
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!item.Checked)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;只要有一个节点未选中，就不选中&lt;/span&gt;
&lt;span&gt;                {
                    parentchecked &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                }
            }
            node.Checked &lt;/span&gt;=&lt;span&gt; parentchecked;

        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;CheckChild&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_3df88c9a-b82c-4f34-a7a0-db7713b3f79d&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_3df88c9a-b82c-4f34-a7a0-db7713b3f79d&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_3df88c9a-b82c-4f34-a7a0-db7713b3f79d&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; treeView1_MouseClick(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, MouseEventArgs e)
        {
            TreeNode node &lt;/span&gt;= treeView1.GetNodeAt(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Point(e.X, e.Y));
            TreeViewHitTestInfo info &lt;/span&gt;=&lt;span&gt; treeView1.HitTest(e.Location);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (info != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; info.Location ==&lt;span&gt; TreeViewHitTestLocations.StateImage)
            {
                Changechild(node, node.Checked);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node.Level != &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                {
                    ChangeParent(node, node.Checked);
                }
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;treeView1_MouseClick&lt;/span&gt;&lt;/div&gt;
&lt;p&gt; 简单实现，有问题欢迎大家指正。&lt;/p&gt;

&lt;p&gt;winform支持 win10 缩放适配 参考我另外一篇：&lt;/p&gt;

</description>
<pubDate>Thu, 13 Dec 2018 06:43:00 +0000</pubDate>
<dc:creator>blueshard</dc:creator>
<og:description>大概是这么个样子： 大概是这么个思路： 当变更（点击）节点的选中状态的时候，同步更新所有子节点(包括子节点的子节点）状态，并且判断所有兄弟节点的状态若都是选中状态，更新父级节点状态为选中，否则，更新父</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hicolin/p/10113953.html</dc:identifier>
</item>
<item>
<title>transient和synchronized的使用 - 张占岭</title>
<link>http://www.cnblogs.com/lori/p/10113871.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lori/p/10113871.html</guid>
<description>&lt;p&gt;transient和synchronized这两个关键字没什么联系，这两天用到了它们，所以总结一下，两个关键字做个伴！&lt;/p&gt;
&lt;h3 id=&quot;transient&quot;&gt;transient&lt;/h3&gt;
&lt;p&gt;持久化时不被存储，当你的对象实现了Serializable接口，这个对象就可以被存储到磁盘上了，而有一些信息比较敏感时，不想被持久化，就可以声明为transient，这时它只在内存中存在，保存到磁盘时将被忽略！&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class ExcelBean implements Serializable {
  private static final long serialVersionUID = 1L;
  private String headTextName;
  private String propertyName;
  private Integer cols = 0;
  private transient XSSFCellStyle cellStyle;
 }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面代码中，cellStyle这个复杂对象不会被文件流写到磁盘里。&lt;/p&gt;
&lt;h3 id=&quot;synchronized&quot;&gt;synchronized&lt;/h3&gt;
&lt;p&gt;同步关键字，当你的对象被实现化后，里面的方法可能被多个线程调用，这在web环境下很常见，如果希望为方法加个锁，让方法一个一个线程排队执行，最简单的方法就是加synchronized关键字，它可以保持这个方法同一时刻只有一个线程执行它。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  /**
   * 方法强制为同步方法.
   */
  synchronized void queue() {
    try {
      System.out.println(&quot;print synchronized result:&quot; + LocalDateTime.now().toString());
      Thread.sleep(5000);
    } catch (Exception ex) {

    }
  }

  @Test
  public void synchronizedTest() throws Exception {
    for (int i = 0; i &amp;lt; 5; i++) {
      new Thread(() -&amp;gt; queue()).start();
    }
    Thread.sleep(500000);

  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行的结果如下，它总会被阻塞4秒钟，没有任务两个线程打印的时间相同。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;print synchronized result:2018-12-13T14:31:13.010
print synchronized result:2018-12-13T14:31:18.015
print synchronized result:2018-12-13T14:31:23.018
print synchronized result:2018-12-13T14:31:28.023
print synchronized result:2018-12-13T14:31:33.028&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 13 Dec 2018 06:34:00 +0000</pubDate>
<dc:creator>张占岭</dc:creator>
<og:description>transient和synchronized这两个关键字没什么联系，这两天用到了它们，所以总结一下，两个关键字做个伴！ transient 持久化时不被存储，当你的对象实现了Serializable接</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lori/p/10113871.html</dc:identifier>
</item>
<item>
<title>基于 Docker 的 DevOps 搭建 - LuckyBB</title>
<link>http://www.cnblogs.com/heyixiaoran/p/9603011.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/heyixiaoran/p/9603011.html</guid>
<description>&lt;p&gt;一直对 DevOps 感兴趣，最近心血来潮，搭乘 Docker 搞一搞，Let‘s Go ！！！&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;1.拉取 GitLab &lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
docker pull gitlab/gitlab-ce
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;2.Run GitLab &lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
docker run --detach --hostname gitlab.example.com --publish 443:443&lt;span&gt; 
--publish &lt;/span&gt;80:80 --publish 22:22&lt;span&gt; --name gitlab --restart always 
--volume /srv/gitlab/config:/etc/gitlab 
--volume /srv/gitlab/logs:/var/log/gitlab 
--volume /srv/gitlab/data:/var/opt/gitlab gitlab/gitlab-ce:latest&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span&gt;现在你就可以访问你的 http://localhost 看到你的 GitLab 了&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;3.生成 Token&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/280776/201812/280776-20181213110450042-1604096085.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这是留着下边用的&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;3.注册 GitLab Runner&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/280776/201809/280776-20180918172823966-1187147844.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中第2个的 token 是在 gitlab 里 Setting——CI/CD——Runner 里给的（如下图），成功后可以在 gitlab 里看到一个 runner&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/280776/201809/280776-20180918174513849-232525517.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;4.拉取 SonarQube&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
docker pull sonarqube
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;5.Run SonarQube&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
docker run -d --name sonarqube -p 9000:9000 -p 9092:9092 sonarqube
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 现在你就可以访问你的 http://localhost:9000 , 登录——用户名：admin 密码：admin&lt;/p&gt;
&lt;p&gt;1.Token——gitlab 的 Setting——Access Tokens——Personal Access Tokens&lt;/p&gt;
&lt;p&gt;2.选择项目语言，填写 unique project key&lt;/p&gt;
&lt;p&gt;3.根据右边弹出提示完成步骤&lt;/p&gt;
&lt;p&gt;下载：https://docs.sonarqube.org/display/SCAN/Analyzing+with+SonarQube+Scanner+for+MSBuild&lt;/p&gt;
&lt;p&gt;命令：&lt;/p&gt;
&lt;p&gt;SonarQube.Scanner.MSBuild.exe begin /k:&quot;testproject2&quot; /d:sonar.host.url=&quot;http://localhost:9000&quot; /d:sonar.login=&quot;ae471877adee54f312188a0b5d92be11289c1436&quot;&lt;/p&gt;
&lt;p&gt;MsBuild.exe /t:Rebuild&lt;/p&gt;
&lt;p&gt;SonarQube.Scanner.MSBuild.exe end /d:sonar.login=&quot;ae471877adee54f312188a0b5d92be11289c1436&quot;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/280776/201809/280776-20180908154834702-757500151.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 为了把 SonarQube 加到 gitlab 里，需要在 SonarQube 里添加 GitLab ，方法 Administration——Marketplace 添加上 GitLab&lt;/p&gt;
&lt;p&gt; 然后在配置里找到 GitLab 标签，右边填写上 GitLab url 和 GitLab User Token&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/280776/201809/280776-20180920143215333-1625893421.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;6.配置  .gitlab-ci.yml&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; 由于我还不熟悉配置这个地方，先略过一下&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;7.拉取 Jenkins&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;docker pull jenkins/jenkins&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;8.Run Jenkins&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span&gt;&lt;span&gt;docker run -d --name jenkins -p 8080:8080 -p 50000:50000 jenkins/jenkins:lts&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这时会出现很多日志，但都不重要，最后出现的*******的位置的才重要，因为是 Unlock Jenkins 的密钥，你说重要不重要，简单截个图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/280776/201809/280776-20180921144710396-1976254149.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果你忘了复制这个也没关系，再用命令找回来就可以&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
docker logs jenkins（镜像名称）
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;访问 http://localhost:8800/，输入密钥，安装插件，填写 admin 密码。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt; 9.配置 Jenkins&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;1. 安装 GitLab 插件：系统管理——插件管理——安装 GitLab 插件，重启 Jenkins&lt;/p&gt;
&lt;p&gt;2. 配置 GitLab：系统管理——系统设置——填写 GitLab 配置&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/280776/201812/280776-20181213111131119-413092372.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Add 里边选 GitLab API token，然后填上之前的 GitLab 的 Token&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/280776/201812/280776-20181213111419919-1936997023.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;之后就是创建任务了，具体还是要根据你的项目需要来决定，这里先略过一下&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;9.拉取 &lt;/strong&gt;&lt;strong&gt;Portainer&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
docker pull portainer/portainer
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;10.Run Portainer&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
docker run -d --name portainer -p 9090:9000 -v /var/run/docker.sock:/var/run/docker.sock portainer/portainer
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注册一个用户 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/280776/201812/280776-20181213142021406-689906166.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击 local  后进入到 dashboard 页面，也可以管理公有云上的，此处以单机版为例&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/280776/201812/280776-20181213142031231-2000988237.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;如图所示，这里可以很轻松的创建和管理  Container ，比上边的命令好用很多，比如 Containers 菜单里的 Create Container 可以创建一个新的 Container。更多功能等待你的挖掘，此处略过，只是想告诉大家先学习基础再用工具，基础还是很重要的。&lt;/p&gt;

&lt;p&gt;上边略过了2处配置的地方，所以没有跑一个完整的流程，但是我想配置的地方还是对的，配置之后再补齐吧&lt;/p&gt;
</description>
<pubDate>Thu, 13 Dec 2018 06:30:00 +0000</pubDate>
<dc:creator>LuckyBB</dc:creator>
<og:description>一直对 DevOps 感兴趣，最近心血来潮，搭乘 Docker 搞一搞，Let‘s Go ！！！ 1.拉取 GitLab 2.Run GitLab 现在你就可以访问你的 http://loc</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/heyixiaoran/p/9603011.html</dc:identifier>
</item>
<item>
<title>const浅析 - 倔强的铃铛</title>
<link>http://www.cnblogs.com/0xfffffff0/p/10113644.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/0xfffffff0/p/10113644.html</guid>
<description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;c++中使用到&lt;code&gt;const&lt;/code&gt;的地方有很多, 而且&lt;code&gt;const&lt;/code&gt; 本身也针对不同的类型可能有不同的含义, 比如对指针就有顶层和底层. 本节就是探讨关于C++中&lt;code&gt;const&lt;/code&gt;的在不同的地方不同表现或含义.&lt;/p&gt;
&lt;h3 id=&quot;const&quot;&gt;const&lt;/h3&gt;
&lt;h4 id=&quot;关于const&quot;&gt;关于const :&lt;/h4&gt;
&lt;ul readability=&quot;11.89932885906&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;&lt;code&gt;const&lt;/code&gt;修饰的对象一旦创建一般就不能改变, 所以对于&lt;code&gt;const&lt;/code&gt;对象必须进行初始化.&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;int i = 0;
const int j;    // error. 必须进行初始化
const int j = 0;&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;初始化时并不关心初始化对象的是&lt;code&gt;const&lt;/code&gt;还是非&lt;code&gt;const&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;int i = 0;
const int j = i;    // i 是非const也可以&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;const&lt;/code&gt;不能改变&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;const int i = 0;
i = 1;  // error const的对象一般不能进行修改&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;引用对象的类型必须与其所引用对象的类型一致&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;int i = 0;
int &amp;amp;j = i;
double &amp;amp;size = j; // error. size与j的类型不一致&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;因为以上引用的规则, 所以&lt;code&gt;const&lt;/code&gt;类型的引用只能被&lt;code&gt;const&lt;/code&gt;的对象引用&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;int i = 0;
const int &amp;amp;size = i;
int &amp;amp;j = size; // error. size的类型为const int, j的类型为 int. 两者并不匹配&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;9&quot;&gt;&lt;li readability=&quot;21&quot;&gt;
&lt;p&gt;引用类型对应的例外&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;int size = 0;
const double &amp;amp;i = size; // size与i的类型虽然不一致, 但是因为const的原因使得等式成立&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;原因 : &lt;strong&gt;虽然i与size两者的类型并不一致, 但是初始化i时, 编译器会为size生成一个临时量(&lt;code&gt;double j = size;&lt;/code&gt;), 然后i最终绑定在这个临时量上(&lt;code&gt;const double &amp;amp;i = j )&lt;/code&gt;&lt;/strong&gt;. i 之所以能绑定在一个临时量上, 还是因为&lt;code&gt;const&lt;/code&gt;的对象不能被修改, 则i 无法被修改, 保障了临时量不会被改变.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注意 i实际绑定在临时量上, 并没有绑定在size上&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;int size = 0;
const double &amp;amp;i = size;
size = 1;   // i 实际值并没有改变, 它绑定的是临时量不是size&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;6.7314578005115&quot;&gt;
&lt;p&gt;修改&lt;code&gt;const&lt;/code&gt;对象的值&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;int i = 0;
const int size = i;
const int &amp;amp;j = i;
const_cast&amp;lt;int&amp;amp;&amp;gt;(size) = 1; // 将size的值修改为1
i = 2;  // 因为j绑定i, i被修改则j也被修改&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为&lt;code&gt;const&lt;/code&gt;只是对修饰的对象限制其不能修改, 不能保证对象一定是常量, 所以&lt;strong&gt;能保证是常量的对象最好都定义成&lt;code&gt;constexpr&lt;/code&gt;&lt;/strong&gt; . 对constexpr不清楚的可以看一下&lt;a href=&quot;https://blog.csdn.net/Function_Dou/article/details/84523482&quot;&gt;constexpr浅析&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;顶层与底层const概念&quot;&gt;顶层与底层const概念&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;顶层&lt;code&gt;const&lt;/code&gt; : 指针本身是一个常量(即地址不允许改变)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;其实我们一直都有在用顶层const, 比如&lt;code&gt;int i = 0;&lt;/code&gt;, 这就是一个顶层const, 因为 i 的地址不会改变, 只有值会被改变.&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;int size = 0, i = 0;    // 其实是顶层const
int *const p = &amp;amp;size; // const直接修饰指针本身, 顶层const
p = &amp;amp;i;     // error. p是顶层const
*p = 1;     // 顶层const可以直接修改值&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;底层&lt;code&gt;const&lt;/code&gt; : 指针所指的对象是一个常量(指针本身是可以修改的, 只是指向的值不能进行修改)&lt;/span&gt;.&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;int size = 0, i = 0;
const int * p = &amp;amp;size; // const直接修饰指针指向的对象, 底层const
ptr = &amp;amp;i;   // ptr可以重新指向其他地址, 因为是底层const
*ptr = 1;   // error. 底层const不能直接修改指向的值&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然我们可以将一个对象修饰为既是顶层又是底层&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;int size = 0;
const int * const p = &amp;amp;size;    // 既是顶层又是底层
const int i = 0;    // 既是顶层又是底层&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有一点一定要注意 : &lt;span&gt;顶层const被拷贝时会忽略掉顶层const&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;const int i = 0;
int size = i;   // 这里的顶层const被忽略掉了
auto j = i;     // 此时 auto 推断出 j的类型为 int , i 的顶层const被忽略了&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;const与重载函数&quot;&gt;const与重载函数&lt;/h4&gt;
&lt;p&gt;在重载函数时, &lt;code&gt;const&lt;/code&gt;类型的参数可能会在处理顶层const与底层const的时候出现问题. 具体什么问题分析之后再来总结.&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void Ccount(int ccount) {}          // ccount为顶层const
void Ccount(const int ccount) {}    // error. ccount也是为顶层const, 赋值时会忽略掉顶层const, 就与上面的函数一样了

void Ccount_pointer(int *ccount) {} // ccount为顶层const
void Ccount_pointer(int *const ccount) {}   // error. ccount也是为顶层const, 赋值时会忽略掉顶层const, 就与上面的函数一样了&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面可以看出来, &lt;span&gt;因为顶层const会被忽略, 所以顶层const与另外顶层const不能被区分出来&lt;/span&gt;.&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// error. 在函数调用的时候有二义性, 并不能区分调用哪一个函数, 在编译期间报错. 
void const_reference(int i) {}  // i 是顶层const. 参数类型为 int
void const_reference(int &amp;amp;i) {} // i 是顶层const. 参数类型为 int

// 下面都没有问题
void const_reference(int &amp;amp;i) {} // i 是顶层const. 参数类型为 int
void const_reference(const int &amp;amp;i) {}   // i 是底层const. 参数类型为const int

void const_pointer(int *i) {}       // 顶层const
void const_pointer(const int *i) {} // 底层const&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为引用对象的类型必须相同, 所以&lt;code&gt;int &amp;amp;i&lt;/code&gt;与&lt;code&gt;const int &amp;amp;i&lt;/code&gt;有区别, 前者类型为&lt;code&gt;int&lt;/code&gt; , 后者类型为&lt;code&gt;const int&lt;/code&gt;, 所以后者是&lt;strong&gt;底层const&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;上面可以看出来, &lt;span&gt;因为底层const不会被忽略, 底层与底层有区分, 所以可以底层const可以用来重载&lt;/span&gt;.&lt;/p&gt;
&lt;h4 id=&quot;const与类的常量成员函数&quot;&gt;const与类的常量成员函数&lt;/h4&gt;
&lt;p&gt;如果&lt;code&gt;const&lt;/code&gt;放在函数名的前面其意义只是告诉编译器返回类型是&lt;code&gt;const&lt;/code&gt;类型的常量而已, 但是如果把&lt;code&gt;const&lt;/code&gt;放在函数名后那就又是另一种情况了, 我们这里主要分析的就种情况.&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;const int const_func(int i) {return i;} // 这里函数返回的是const类型的, 即常量
int const_func(int i) const {return i;} // error. const不能直接放在普通函数名的后面, 只能放在成员函数(类函数)名的后面,原因之后分析.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;定义一个简单的类&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;class A {
    private: int nun;
    public: int const_func() const {return 0;}  // success
};
// 如果将函数改为
int const_func() const { ++num; return 0;}  // error&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;int const_func() const&lt;/code&gt;函数中&lt;code&gt;const&lt;/code&gt;是告诉编译器, &lt;span&gt;类中定义的非静态变量都不能进行修改&lt;/span&gt;. 原因在于类的所有成员函数都会隐式的传入&lt;code&gt;this 指针&lt;/code&gt;, 即上面的成员函数被修改为&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;int const_func(const A * const this)  { ++num; return 0;}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;this&lt;/code&gt;指针本身就是顶层const, 而放在函数名后面的const是为了修饰this指针的, 但是因为this指针不能显示的被传入, 所以const只能放在函数名后.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;知道了这里&lt;code&gt;const&lt;/code&gt;修饰的是&lt;code&gt;this 指针&lt;/code&gt;, 所以&lt;code&gt;this-&amp;gt;i&lt;/code&gt;就不能被修改了, 而静态成员不是属于实例化类本身, 也就没有this指向静态变量, 所以可以在以上类型的函数中修改静态变量.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;const&lt;/code&gt;放在成员函数名后面的函数我们称为&lt;strong&gt;常量成员函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;但是有的时候非要在以上函数中改变某个变量的值怎么办? c++中有&lt;code&gt;mutable&lt;/code&gt;关键字, 就是允许这样的特例发生. &lt;code&gt;mutable&lt;/code&gt;就是告诉编译器, &lt;code&gt;num&lt;/code&gt;可以在任何函数中进行修改.&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;class A {
    private: mutable int nun;
    public: void const_func() const {++num;}    // success
};&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;const与类&quot;&gt;const与类&lt;/h4&gt;
&lt;p&gt;我们在定义类的实例化时, 可能会将类实例化定义为&lt;code&gt;const&lt;/code&gt;, 即&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;class A {
    private: int nun;
    public: int const_func()  {return 0;}   
};
A a;
const A ca;
a.const_func(); // success
ca.const_func(); // error&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面出错的原因在于ca的类型为&lt;code&gt;const&lt;/code&gt;, 所以与之对应的函数应该是常量成员函数, 所以最好在定义类函数实现时, 重载一个常量成员函数.&lt;/p&gt;
&lt;h4 id=&quot;const与类静态成员&quot;&gt;const与类静态成员&lt;/h4&gt;
&lt;p&gt;同样上面的类为例子&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;class A {
    private: static int nun = 0; // error
    public: int const_func() const {++num; return 0;}   // success. 原因上面分析了
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在类中定义的静态变量不能在类中初始化, 必须在类外进行初始化, 不然报错. 所以上面应该在类外改为&lt;code&gt;int A::num = 0;&lt;/code&gt; .&lt;/p&gt;
&lt;p&gt;但是有一个例外 :&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;class A {
    private: const static int nun = 0; // success
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为&lt;code&gt;const&lt;/code&gt;要求必须在创建的时候就需要对其初始化, 所以上式的例子才成立.&lt;/p&gt;
&lt;h4 id=&quot;const与typedef&quot;&gt;const与typedef&lt;/h4&gt;
&lt;p&gt;当我们不愿意每次都定义指针的时候, 就想到用&lt;code&gt;typedef&lt;/code&gt;来定义指针类型. 即:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;typedef char * Str;
char *str1 = &quot;hello&quot;;
const char *str2 = &quot;hello&quot;;
const Str str3 = &quot;hello&quot;;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对其进行相同的操作&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;str1[0] = 'a';
str2[0] = 'a';  // error
str3[0] = 'a';  // success

str1++;
str2++; // success
str3++; // error&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上面的执行的操作可以看出来&lt;code&gt;typedef&lt;/code&gt;不仅仅只是一个替换, 它将&lt;code&gt;const Str str3&lt;/code&gt;转换为了&lt;code&gt;char *const str3&lt;/code&gt;而不是跟str2一样.&lt;/p&gt;
&lt;p&gt;原因是 : &lt;code&gt;char *&lt;/code&gt;重写声明之后, 真实的数据类型变成了&lt;code&gt;char&lt;/code&gt; 而不是&lt;code&gt;char *&lt;/code&gt;, 反而&lt;code&gt;*&lt;/code&gt;成了声明符的一部分了, 导致&lt;code&gt;const Str&lt;/code&gt;的数据类型为&lt;code&gt;const char&lt;/code&gt;, 而&lt;code&gt;*&lt;/code&gt;修饰&lt;code&gt;const char&lt;/code&gt;, 也就成了常量指针.&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;本节汇总了部分关于&lt;code&gt;const&lt;/code&gt;用法的注意点, 可能看起来会很晕, 也不是一次性就容易记住, 希望在看的时候最好也进行验证是最好的. 最主要记住&lt;strong&gt;底层&lt;code&gt;const&lt;/code&gt;和顶层&lt;code&gt;const&lt;/code&gt;&lt;/strong&gt;, 怎样重载, 基本很多的问题都是衍生.&lt;/p&gt;
</description>
<pubDate>Thu, 13 Dec 2018 06:01:00 +0000</pubDate>
<dc:creator>倔强的铃铛</dc:creator>
<og:description>前言 c++中使用到 的地方有很多, 而且 本身也针对不同的类型可能有不同的含义, 比如对指针就有顶层和底层. 本节就是探讨关于C++中 的在不同的地方不同表现或含义. const 关于const :</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/0xfffffff0/p/10113644.html</dc:identifier>
</item>
</channel>
</rss>