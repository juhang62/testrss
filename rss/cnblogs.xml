<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>slf4j 搭配 log4j2 处理日志 - 海向</title>
<link>http://www.cnblogs.com/haixiang/p/10277386.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/haixiang/p/10277386.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;关于-log4j&quot;&gt;关于 log4j&lt;/h3&gt;
&lt;p&gt;Log4j + Slf4j 的使用组合最为常见，但是我们知道 Log4j 目前已经停止更新了。Apache推出了新的 Log4j2 来代替 Log4j，Log4j2 是对Log4j 的升级，与其前身 Log4j 相比有了显着的改进，并提供了许多 Logback 可用的改进，同时解决了 Logback 体系结构中的一些固有问题。因此，Log4j2 + Slf4j 应该是未来的大势所趋。&lt;/p&gt;
&lt;h3 id=&quot;关于-slf4j&quot;&gt;关于 slf4j&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;LF4J不同于其他日志类库，与其它日志类库有很大的不同。SLF4J(Simple logging Facade for Java)不是一个真正的日志实现，而是一个抽象层（ abstraction layer），它允许你在后台使用任意一个日志类库。如果是在编写供内外部都可以使用的API或者通用类库，那么你真不会希望使用你类库的客户端必须使用你选择的日志类库。&lt;/li&gt;
&lt;li&gt;如果一个项目已经使用了log4j，而你加载了一个类库，比方说 Apache Active MQ——它依赖于于另外一个日志类库 logback，那么你就需要把它也加载进去。但如果 Apache Active MQ 使用了 SLF4J，你可以继续使用你的日志类库而无需忍受加载和维护一个新的日志框架的痛苦。&lt;/li&gt;
&lt;li&gt;总的来说，SLF4J使你的代码独立于任意一个特定的日志API，这是对于 API 开发者的很好的思想。虽然抽象日志类库的思想已经不是新鲜的事物，而且 Apache commons logging 也已经在使用这种思想了，但 SLF4J 正迅速成为Java世界的日志标准。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;案例使用&quot;&gt;案例使用&lt;/h3&gt;
&lt;p&gt;引入 slf4j 和 log4j2 的核心包&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;!-- slf4j核心包--&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;slf4j-api&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.7.25&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;jcl-over-slf4j&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.7.25&amp;lt;/version&amp;gt;
    &amp;lt;scope&amp;gt;runtime&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;!--log4j2核心包--&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.apache.logging.log4j&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;log4j-core&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.8.2&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.apache.logging.log4j&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;log4j-api&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.8.2&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.apache.logging.log4j&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;log4j-slf4j-impl&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.8.2&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.apache.logging.log4j&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;log4j-web&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.8.2&amp;lt;/version&amp;gt;
    &amp;lt;scope&amp;gt;runtime&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;!--log4j2 异步依赖--&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.lmax&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;disruptor&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;3.3.6&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;log4j2.xml&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;configuration status=&quot;off&quot; monitorInterval=&quot;120&quot;&amp;gt;
    &amp;lt;properties&amp;gt;
        &amp;lt;property name=&quot;LOG_HOME&quot;&amp;gt;/mytest_log&amp;lt;/property&amp;gt;
    &amp;lt;/properties&amp;gt;
    &amp;lt;appenders&amp;gt;
        &amp;lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&amp;gt;
            &amp;lt;PatternLayout pattern=&quot;%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n&quot;/&amp;gt;
        &amp;lt;/Console&amp;gt;

        &amp;lt;!--RollingFile 为全局同步 RandomAccessFile 为异步--&amp;gt;
        &amp;lt;RollingRandomAccessFile name=&quot;rootAppeder&quot;
                                 fileName=&quot;${LOG_HOME}/rattanapi.log&quot;
                                 filePattern=&quot;${LOG_HOME}/$${date:yyyy-MM}/rattanapi-root-%d{yyyy-MM-dd}-%i.log&quot;&amp;gt;
            &amp;lt;PatternLayout pattern=&quot;%d{yyyy-MM-dd HH:mm:ss.SSS} [%t] %-5level %logger{36} - %ex%msg%n&quot;/&amp;gt;
            &amp;lt;Policies&amp;gt;
                &amp;lt;TimeBasedTriggeringPolicy interval=&quot;1&quot;/&amp;gt;
                &amp;lt;SizeBasedTriggeringPolicy size=&quot;100 MB&quot;/&amp;gt;
            &amp;lt;/Policies&amp;gt;
            &amp;lt;DefaultRolloverStrategy max=&quot;30&quot;/&amp;gt;
        &amp;lt;/RollingRandomAccessFile&amp;gt;

        &amp;lt;!--错误日志输出--&amp;gt;
        &amp;lt;RollingRandomAccessFile name=&quot;errorAppeder&quot;
                                 fileName=&quot;${LOG_HOME}/rattanapi-error.log&quot;
                                 filePattern=&quot;${LOG_HOME}/$${date:yyyy-MM}/rattanapi-error-%d{yyyy-MM-dd}-%i.log&quot;&amp;gt;
            &amp;lt;Filters&amp;gt;
                &amp;lt;ThresholdFilter level=&quot;ERROR&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&amp;gt;
            &amp;lt;/Filters&amp;gt;
            &amp;lt;PatternLayout pattern=&quot;%d{yyyy-MM-dd HH:mm:ss.SSS} [%t] %-5level %logger{36} - %ex%msg%n&quot;/&amp;gt;
            &amp;lt;Policies&amp;gt;
                &amp;lt;TimeBasedTriggeringPolicy interval=&quot;1&quot;/&amp;gt;
                &amp;lt;SizeBasedTriggeringPolicy size=&quot;100 MB&quot;/&amp;gt;
            &amp;lt;/Policies&amp;gt;
            &amp;lt;DefaultRolloverStrategy max=&quot;30&quot;/&amp;gt;
        &amp;lt;/RollingRandomAccessFile&amp;gt;

    &amp;lt;/appenders&amp;gt;

    &amp;lt;loggers&amp;gt;
        &amp;lt;asyncRoot level=&quot;info&quot;&amp;gt;
            &amp;lt;!--根据配置文件是否打开 console输出 --&amp;gt;
            &amp;lt;appender-ref ref=&quot;Console&quot;/&amp;gt;
            &amp;lt;appender-ref ref=&quot;rootAppeder&quot;/&amp;gt;
            &amp;lt;appender-ref ref=&quot;errorAppeder&quot;/&amp;gt;
        &amp;lt;/asyncRoot&amp;gt;
    &amp;lt;/loggers&amp;gt;
&amp;lt;/configuration&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;web.xml中设置log4j2的监听器和过滤器（servlet3.0及以上版本不需要该步操作）开发Servlet3.0的程序需要一定的环境支持。&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;!--对于log4j2，Servlet2.5以前的版本需要--&amp;gt;
   &amp;lt;listener&amp;gt;
      &amp;lt;listener-class&amp;gt;org.apache.logging.log4j.web.Log4jServletContextListener&amp;lt;/listener-class&amp;gt;
   &amp;lt;/listener&amp;gt;
   &amp;lt;filter&amp;gt;
      &amp;lt;filter-name&amp;gt;log4jServletFilter&amp;lt;/filter-name&amp;gt;
      &amp;lt;filter-class&amp;gt;org.apache.logging.log4j.web.Log4jServletFilter&amp;lt;/filter-class&amp;gt;
   &amp;lt;/filter&amp;gt;
&amp;lt;filter-mapping&amp;gt;
      &amp;lt;filter-name&amp;gt;log4jServletFilter&amp;lt;/filter-name&amp;gt;
      &amp;lt;url-pattern&amp;gt;/*&amp;lt;/url-pattern&amp;gt;
      &amp;lt;dispatcher&amp;gt;REQUEST&amp;lt;/dispatcher&amp;gt;
      &amp;lt;dispatcher&amp;gt;FORWARD&amp;lt;/dispatcher&amp;gt;
      &amp;lt;dispatcher&amp;gt;INCLUDE&amp;lt;/dispatcher&amp;gt;
      &amp;lt;dispatcher&amp;gt;ERROR&amp;lt;/dispatcher&amp;gt;
 &amp;lt;/filter-mapping&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：log4j2不再支持properties文件了，只支持xml，json或是yaml，不指定位置的情况下默认在src/main/resources下查找。&lt;/p&gt;
&lt;p&gt;如果需要自定义位置，需要在上面的web.xml中添加以下代码&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;context-param&amp;gt;
    &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt;
    &amp;lt;param-value&amp;gt;classpath:applicationContext.xml&amp;lt;/param-value&amp;gt;
&amp;lt;/context-param&amp;gt;
&amp;lt;context-param&amp;gt;
    &amp;lt;param-name&amp;gt;log4jConfiguration&amp;lt;/param-name&amp;gt;
    &amp;lt;param-value&amp;gt;classpath:log4j2.xml&amp;lt;/param-value&amp;gt;
&amp;lt;/context-param&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class Main {
    private static final Logger logger = LoggerFactory.getLogger(Main.class);
    public static void main(String[] args) {
    String world = &quot;world&quot;;
    logger.info(&quot;hellp world:{}&quot;,world);
    logger.error(&quot;exception e&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 16 Jan 2019 07:40:00 +0000</pubDate>
<dc:creator>海向</dc:creator>
<og:description>[TOC] 关于 log4j Log4j + Slf4j 的使用组合最为常见，但是我们知道 Log4j 目前已经停止更新了。Apache推出了新的 Log4j2 来代替 Log4j，Log4j2 是对</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/haixiang/p/10277386.html</dc:identifier>
</item>
<item>
<title>logging模块 - old-six</title>
<link>http://www.cnblogs.com/lida585/p/10277387.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lida585/p/10277387.html</guid>
<description>&lt;p&gt;我们来说一下这个logging模块,这个模块的功能是记录我们软件的各种状态,其实每个软件都是有错误日志的,开发人员可以通过错误日志中的内容对他的程序进行修改.&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;我们先来看一下&lt;strong&gt;函数式简单配置&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import logging  

logging.debug(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;debug message&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)  

logging.info(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;info message&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)  

logging.warning(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;warning message&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)  

logging.error(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;error message&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)  

logging.critical(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;critical message&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;默认情况下Python的logging模块将日志打印到了标准输出中，且只显示了大于等于WARNING级别的日志，这说明默认的日志级别设置为WARNING（日志级别等级CRITICAL &amp;gt; ERROR &amp;gt; WARNING &amp;gt; INFO &amp;gt; DEBUG），默认的日志格式为日志级别：Logger名称：用户输出消息。&lt;/p&gt;
&lt;p&gt;我们自己用函数写的这个可以正常使用但是不够灵活,我们看看这个灵活的&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;灵活配置日志级别，日志格式，输出位置:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;手动挡 小轿车
import logging
logging.basicConfig(
    level&lt;/span&gt;=&lt;span&gt;logging.WARNING,
    # level&lt;/span&gt;=&lt;span&gt;10&lt;/span&gt;&lt;span&gt;,
    format&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%(asctime)s-%(name)s-[%(lineno)d]-%(message)s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    # filename&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test,log&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    # filemode&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a+&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
)
logging.debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;我是风儿&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
logging.info(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;你是沙&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
logging.warning(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;缠缠绵绵&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
logging.error(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;走天涯&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
logging.critical(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;厉害了&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;logging.basicConfig()函数中可通过具体参数来更改logging模块默认行为，可用参数有：

 

filename：用指定的文件名创建FiledHandler，这样日志会被存储在指定的文件中。

filemode：文件打开方式，在指定了filename时使用这个参数，默认值为“a”还可指定为“w”。

format：指定handler使用的日志显示格式。

datefmt：指定日期时间格式。

level：设置rootlogger（后边会讲解具体概念）的日志级别

stream：用指定的stream创建StreamHandler。可以指定输出到sys.stderr,sys.stdout或者文件(f&lt;/span&gt;=&lt;span&gt;open(‘test.log’,’w’))，默认为sys.stderr。若同时列出了filename和stream两个参数，则stream参数会被忽略。

 

format参数中可能用到的格式化串：

&lt;/span&gt;%&lt;span&gt;(name)s Logger的名字

&lt;/span&gt;%&lt;span&gt;(levelno)s 数字形式的日志级别

&lt;/span&gt;%&lt;span&gt;(levelname)s 文本形式的日志级别

&lt;/span&gt;%&lt;span&gt;(pathname)s 调用日志输出函数的模块的完整路径名，可能没有

&lt;/span&gt;%&lt;span&gt;(filename)s 调用日志输出函数的模块的文件名

&lt;/span&gt;%&lt;span&gt;(module)s 调用日志输出函数的模块名

&lt;/span&gt;%&lt;span&gt;(funcName)s 调用日志输出函数的函数名

&lt;/span&gt;%&lt;span&gt;(lineno)d 调用日志输出函数的语句所在的代码行

&lt;/span&gt;%&lt;span&gt;(created)f 当前时间，用UNIX标准的表示时间的浮 点数表示

&lt;/span&gt;%&lt;span&gt;(relativeCreated)d 输出日志信息时的，自Logger创建以 来的毫秒数

&lt;/span&gt;%(asctime)s 字符串形式的当前时间。默认格式是 “&lt;span&gt;2003&lt;/span&gt;-&lt;span&gt;07&lt;/span&gt;-&lt;span&gt;08&lt;/span&gt; &lt;span&gt;16&lt;/span&gt;:&lt;span&gt;49&lt;/span&gt;:&lt;span&gt;45&lt;/span&gt;,&lt;span&gt;896&lt;/span&gt;&lt;span&gt;”。逗号后面的是毫秒

&lt;/span&gt;%&lt;span&gt;(thread)d 线程ID。可能没有

&lt;/span&gt;%&lt;span&gt;(threadName)s 线程名。可能没有

&lt;/span&gt;%&lt;span&gt;(process)d 进程ID。可能没有

&lt;/span&gt;%(message)s用户输出的消息
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;logger对象配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;自动挡 小轿车
import logging
logger&lt;/span&gt;=logging.getLogger(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;开发日志&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)#获取一个新的日志
formatter&lt;/span&gt;=logging.Formatter(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%(asctime)s-%(name)s-[%(lineno)d]-%(message)s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
#定义了一个模板
ch&lt;/span&gt;=&lt;span&gt;logging.StreamHandler()#流 屏幕流
#生成了一个屏幕流
fh&lt;/span&gt;=logging.FileHandler(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tt.log&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,encoding=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
#生成了一个文件流
boss&lt;/span&gt;=logging.FileHandler(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;boss.log&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,encoding=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
#生成一个老板看的日志
boss_formatterl&lt;/span&gt;=logging.Formatter(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%(asctime)s-%(message)s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
ch.setFormatter(formatter)
#把咱们定义的模板绑定给咱们创建的存储日志的流
fh.setFormatter(formatter)
boss.setFormatter(boss_formatterl)
#自己又写了一个新的模板,然后绑定
logger.setLevel(logging.DEBUG)
设置咱们的记录等级

logger.addHandler(fh)
#将文件流加入咱们的日志绑定
logger.addHandler(ch)
#将屏幕流加入咱们的日志绑定
logger.addHandler(boss)
logger.debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;我&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
logger.info(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;你&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
logger.warning(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;缠缠绵绵&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
logger.error(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;走天涯&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
logger.critical(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;爆炸了&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;logging库提供了多个组件：Logger、Handler、Filter、Formatter。Logger对象提供应用程序可直接使用的接口，Handler发送日志到适当的目的地，Filter提供了过滤日志信息的方法，Formatter指定日志显示格式。另外，可以通过：logger.setLevel(logging.Debug)设置级别,当然，也可以通过fh.setLevel(logging.Debug)单对文件流设置某个级别。&lt;/p&gt;
</description>
<pubDate>Wed, 16 Jan 2019 07:40:00 +0000</pubDate>
<dc:creator>old-six</dc:creator>
<og:description>我们来说一下这个logging模块,这个模块的功能是记录我们软件的各种状态,其实每个软件都是有错误日志的,开发人员可以通过错误日志中的内容对他的程序进行修改. 我们先来看一下函数式简单配置 默认情况下</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lida585/p/10277387.html</dc:identifier>
</item>
<item>
<title>【TCP协议】(3)---TCP粘包黏包 - 雨点的名字</title>
<link>http://www.cnblogs.com/qdhxhz/p/10277239.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qdhxhz/p/10277239.html</guid>
<description>&lt;p&gt;有关TCP协议之前写过两篇博客:&lt;/p&gt;
&lt;p&gt;      1、&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/qdhxhz/p/10267932.html&quot;&gt;【TCP协议】（1）---TCP协议详解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;      2、&lt;a id=&quot;CategoryEntryList1_EntryStoryList_ctl00_Entries_TitleUrl_2&quot; class=&quot;entrylistItemTitle&quot; href=&quot;https://www.cnblogs.com/qdhxhz/p/8470997.html&quot;&gt;【TCP协议】(2)---TCP三次握手和四次挥手&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;一、TCP粘包、拆包图解&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201901/1090617-20190116151233403-308970675.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;假设客户端分别发送了两个数据包D1和D2给服务端，由于服务端一次读取到字节数是不确定的，故可能存在以下四种情况：&lt;/p&gt;
&lt;p&gt;      1）服务端分两次读取到了两个独立的数据包，分别是D1和D2，没有粘包和拆包&lt;/p&gt;
&lt;p&gt;     2）服务端一次接受到了两个数据包，D1和D2粘合在一起，称之为TCP粘包&lt;/p&gt;
&lt;p&gt;     3）服务端分两次读取到了数据包，第一次读取到了完整的D1包和D2包的部分内容，第二次读取到了D2包的剩余内容，这称之为TCP拆包&lt;/p&gt;
&lt;p&gt;     4）服务端分两次读取到了数据包，第一次读取到了D1包的部分内容D1_1，第二次读取到了D1包的剩余部分内容D1_2和完整的D2包。&lt;/p&gt;
&lt;p&gt;特别要注意的是，如果TCP的接受滑窗非常小，而数据包D1和D2比较大，很有可能会发生第五种情况，即服务端分多次才能将D1和D2包完全接受，期间发生多次拆包。&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;二、 粘包、拆包发生原因&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;      产生原因主要有这3种：&lt;span&gt;滑动窗口&lt;/span&gt;、&lt;span&gt;MSS/MTU限制&lt;/span&gt;、&lt;span&gt;Nagle算法&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;1、滑动窗口&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;      TCP流量控制主要使用滑动窗口协议，滑动窗口是接受数据端使用的窗口大小，用来告诉发送端接收端的缓存大小，以此可以控制发送端发送数据的大小，从而达到流量&lt;/p&gt;
&lt;p&gt;控制的目的。这个窗口大小就是我们一次传输几个数据。对所有数据帧按顺序赋予编号，发送方在发送过程中始终保持着一个发送窗口，只有落在发送窗口内的帧才允许被发送；&lt;/p&gt;
&lt;p&gt;同时接收方也维持着一个接收窗口，只有落在接收窗口内的帧才允许接收。这样通过调整发送方窗口和接收方窗口的大小可以实现流量控制。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在来看一下滑动窗口是如何造成粘包、拆包的？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;粘包&lt;/span&gt;：假设发送方的每256 bytes表示一个完整的报文，接收方由于数据处理不及时，这256个字节的数据都会被缓存到SO_RCVBUF(接收缓存区）中。如果接收方的SO_RCVBUF&lt;/p&gt;
&lt;p&gt;         中缓存了多个报文，那么对于接收方而言，这就是粘包。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;拆包&lt;/span&gt;：考虑另外一种情况，假设接收方的窗口只剩了128，意味着发送方最多还可以发送128字节，而由于发送方的数据大小是256字节，因此只能发送前128字节，等到接收方ack&lt;/p&gt;
&lt;p&gt;         后，才能发送剩余字节。这就造成了拆包。&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;2、MSS和MTU分片&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;MSS&lt;/span&gt;: 是Maximum Segement Size缩写，&lt;span&gt;表示TCP报文中data部分的最大长度&lt;/span&gt;，是TCP协议在OSI五层网络模型中传输层对一次可以发送的最大数据的限制。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;MTU&lt;/span&gt;: 最大传输单元是Maxitum Transmission Unit的简写，&lt;span&gt;是OSI五层网络模型中链路层(datalink layer)对一次可以发送的最大数据的限制&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;当需要传输的数据大于MSS或者MTU时，数据会被拆分成多个包进行传输。由于MSS是根据MTU计算出来的，因此当发送的数据满足MSS时，必然满足MTU。&lt;/p&gt;
&lt;p&gt;为了更好的理解，我们先介绍一下在5层网络模型中应用通过TCP发送数据的流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201901/1090617-20190116151647205-118877619.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于应用层来说，只关心发送的数据DATA，将数据写入socket在内核中的发送缓冲区SO_SNDBUF即返回，操作系统会将SO_SNDBUF中的数据取出来进行发送。&lt;/p&gt;
&lt;p&gt;    传输层会在DATA前面加上TCP Header,构成一个完整的TCP报文。&lt;/p&gt;
&lt;p&gt;    当数据到达网络层(network layer)时，网络层会在TCP报文的基础上再添加一个IP Header，也就是将自己的网络地址加入到报文中。&lt;/p&gt;
&lt;p&gt;    到数据链路层时，还会加上Datalink Header和CRC。&lt;/p&gt;
&lt;p&gt;     当到达物理层时，会将SMAC(Source Machine，数据发送方的MAC地址)，DMAC(Destination Machine，数据接受方的MAC地址 )和Type域加入。&lt;/p&gt;
&lt;p&gt;可以发现数据在发送前，每一层都会在上一层的基础上增加一些内容，下图演示了MSS、MTU在这个过程中的作用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201901/1090617-20190116151753616-1373092465.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;     MTU是以太网传输数据方面的限制，每个以太网帧都有最小的大小64bytes最大不能超过1518bytes。刨去以太网帧的帧头 （DMAC目的MAC地址48bit=6Bytes&lt;/p&gt;
&lt;p&gt;+SMAC源MAC地址48bit=6Bytes+Type域2bytes）14Bytes和帧尾 CRC校验部分4Bytes（这个部分有时候大家也把它叫做FCS），那么剩下承载上层协议的地方也&lt;/p&gt;
&lt;p&gt;就是&lt;span&gt;Data域最大就只能有1500Bytes这个值 我们就把它称之为MTU&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;由于MTU限制了一次最多可以发送1500个字节，而TCP协议在发送DATA时，还会加上额外的TCP Header和Ip Header，因此刨去这两个部分，就是TCP协议一次可以&lt;/p&gt;
&lt;p&gt;发送的实际应用数据的最大大小，也就是MSS。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      MSS长度=MTU长度-IP Header-TCP Header&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;TCP Header的长度是20字节，IPv4中IP Header长度是20字节，IPV6中IP Header长度是40字节，因此：&lt;span&gt;在IPV4中，以太网MSS可以达到1460byte&lt;/span&gt;；&lt;span&gt;在IPV6中，以太网&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;MSS可以达到1440byte。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;需要注意的是MSS表示的一次可以发送的DATA的最大长度，而不是DATA的真实长度。发送方发送数据时，当SO_SNDBUF中的数据量大于MSS时，操作系统会将数据进&lt;/p&gt;
&lt;p&gt;行拆分，使得每一部分都小于MSS，这就是拆包，然后每一部分都加上TCP Header，构成多个完整的TCP报文进行发送，当然经过网络层和数据链路层的时候，还会分别&lt;/p&gt;
&lt;p&gt;加上相应的内容。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;需要注意&lt;/span&gt;:  默认情况下，与外部通信的网卡的MTU大小是1500个字节。而本地回环地址的MTU大小为65535，这是因为本地测试时数据不需要走网卡，所以不受到1500&lt;/p&gt;
&lt;p&gt;               的限制。&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;3、 Nagle算法&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;       TCP/IP协议中，无论发送多少数据，总是要在数据(DATA)前面加上协议头(TCP Header+IP Header)，同时，对方接收到数据，也需要发送ACK表示确认。&lt;/p&gt;
&lt;p&gt;即使从键盘输入的一个字符，占用一个字节，可能在传输上造成41字节的包，其中包括1字节的有用信息和40字节的首部数据。这种情况转变成了4000%的消耗，这样的&lt;/p&gt;
&lt;p&gt;情况对于重负载的网络来是无法接受的。&lt;/p&gt;
&lt;p&gt;为了尽可能的利用网络带宽，TCP总是希望尽可能的发送足够大的数据。（一个连接会设置MSS参数，因此，TCP/IP希望每次都能够以MSS尺寸的数据块来发送数据）。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Nagle算法就是为了尽可能发送大块数据，避免网络中充斥着许多小数据块。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Nagle算法的基本定义是任意时刻，最多只能有一个未被确认的小段。 所谓“小段”，指的是小于MSS尺寸的数据块，所谓“未被确认”，是指一个数据块发送出去后，没有&lt;/p&gt;
&lt;p&gt;收到对方发送的ACK确认该数据已收到。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Nagle算法的规则：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;      1）如果SO_SNDBUF(发送缓冲区）中的数据长度达到MSS，则允许发送；&lt;/p&gt;
&lt;p&gt;      2）如果该SO_SNDBUF中含有FIN，表示请求关闭连接，则先将SO_SNDBUF中的剩余数据发送，再关闭；&lt;/p&gt;
&lt;p&gt;      3）设置了TCP_NODELAY=true选项，则允许发送。TCP_NODELAY是取消TCP的确认延迟机制，相当于禁用了Nagle 算法。&lt;/p&gt;
&lt;p&gt;      4）未设置TCP_CORK选项时，若所有发出去的小数据包（包长度小于MSS）均被确认，则允许发送;&lt;/p&gt;
&lt;p&gt;      5）上述条件都未满足，但发生了超时（一般为200ms），则立即发送。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;有关TCP粘包黏包的解决办法,将在下一篇通过Netty代码演示。&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;参考&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;这篇博客基本上参考一篇博客的,感谢原作者整理,看了许多相关博客,感觉这一篇就够了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参考博客链接：&lt;a href=&quot;http://www.tianshouzhi.com/api/tutorials/netty/343&quot; target=&quot;_blank&quot;&gt;TCP粘包、拆包&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 16 Jan 2019 07:32:00 +0000</pubDate>
<dc:creator>雨点的名字</dc:creator>
<og:description>【TCP协议】(3) TCP粘包黏包 有关TCP协议之前写过两篇博客: 1、【TCP协议】（1） TCP协议详解 2、【TCP协议】(2) TCP三次握手和四次挥手 一、TCP粘包、拆包图解 假设客户</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qdhxhz/p/10277239.html</dc:identifier>
</item>
<item>
<title>【NLP】彻底搞懂BERT - 水奈樾</title>
<link>http://www.cnblogs.com/rucwxb/p/10277217.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rucwxb/p/10277217.html</guid>
<description>&lt;p&gt;&lt;span&gt;# 好久没更新博客了，有时候随手在本上写写，或者Evernote上记记，零零散散的笔记带来零零散散的记忆o(╥﹏╥)o。。还是整理到博客上比较有整体性，也方便查阅~&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;自google在2018年10月底公布BERT在11项nlp任务中的卓越表现后，BERT（Bidirectional Encoder Representation from Transformers)就成为NLP领域大火、整个ML界略有耳闻的模型，网上相关介绍也很多，但很多技术内容太少，或是写的不全面半懂不懂，重复内容占绝大多数&lt;span&gt;（这里弱弱吐槽百度的搜索结果多样化。。）&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一句话概括，BERT的出现，彻底改变了&lt;span&gt;预训练产生词向量&lt;/span&gt;和&lt;span&gt;下游具体NLP任务&lt;/span&gt;的关系，提出龙骨级的训练词向量概念。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;目录：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　词向量模型：word2vec, ELMo, BERT比较&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　BERT细则：Masked LM, Transformer, sentence-level&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　迁移策略：下游NLP任务调用接口&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　运行结果：破11项NLP任务最优纪录&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;一、词向量模型&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;这里主要横向比较一下word2vec，ELMo，BERT这三个模型，着眼在模型亮点与差别处。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;传统意义上来讲，词向量模型是一个工具，可以把真实世界抽象存在的文字转换成可以进行数学公式操作的向量，而对这些向量的操作，才是NLP真正要做的任务。因而某种意义上，NLP任务分成两部分，&lt;span&gt;预训练产生词向量&lt;/span&gt;，对词向量操作（&lt;span&gt;下游具体NLP任务&lt;/span&gt;）。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;从word2vec到ELMo到BERT，做的其实主要是把&lt;span&gt;下游具体NLP任务&lt;/span&gt;的活逐渐移到&lt;span&gt;预训练产生词向量&lt;/span&gt;上。下面是一个大体概括，具体解释后面会写到。。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;word2vec——&amp;gt;ELMo：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　结果：上下文无关的static向量变成上下文相关的dynamic向量，比如苹果在不同语境vector不同。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　操作：encoder操作转移到&lt;span&gt;预训练产生词向量&lt;span&gt;过程实现。&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;ELMo——&amp;gt;BERT：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　结果：训练出的word-level向量变成sentence-level的向量，&lt;span&gt;下游具体NLP任务&lt;/span&gt;调用更方便，修正了ELMo模型的潜在问题，。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　操作：使用句子级负采样获得句子表示/句对关系，Transformer模型代替LSTM提升表达和时间上的效率，masked LM解决“自己看到自己”的问题。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1. word2vec&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;# 反正一直以来用的这个，感觉方便有效率，后来才知道too young。。。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;线性模型：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　很神奇的地方，从而也说明高维空间映射的词向量可以很好体现真实世界中token之间的关系。如：king-man = queen-woman&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;负采样：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　由于训练词向量模型的目标不是为了得到一个多么精准的语言模型，而是为了获得它的副产物——词向量。所以要做到的不是在几万几十万个token中艰难计算softmax获得最优的那个词（就是预测的对于给定词的下一词），而只需能做到在几个词中找到对的那个词就行，这几个词包括一个正例（即直接给定的下一词），和随机产生的噪声词（采样抽取的几个负例），就是说训练一个sigmoid二分类器，只要模型能够从中找出正确的词就认为完成任务。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这种负采样思想也应用到之后的BERT里，只不过从word-level变成sentence-level，这样能获取句子间关联关系。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;缺点是上下文无关（static）：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　因而为了让句子有一个整体含义(context)，大家会在下游具体的NLP任务中基与词向量的序列做encoding操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面是一个比较表格，模型不细讲了，预测目标这里的next word下一个词，是所有传统语言模型都做的事——寻找下一个词填什么。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1214565/201901/1214565-20190116104404540-113526380.png&quot; alt=&quot;&quot; width=&quot;987&quot; height=&quot;74&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2. ELMo&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;# 10月份初做一个任务还被建议使用ELMo提升模型效率，但后来可能哪里没调好导致运行时间很长，所以放弃了。。。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　ELmo模型是AllenNLP在2018年8月发布的一个上下文无关模型，甚至在9月10月BERT没出来时，也小火了一把。但据说使用时很慢效率很低，再加上马上就提出的强势BERT，ELMo很快就被人们忘掉了。。。但BERT的提出，算是对ELMo的致敬，硬是凑了一个和ELMo一个动画片里的角色名。。。（下面左图，红色的是ELMo，右二是BERT）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1214565/201901/1214565-20190116111955500-1615019895.png&quot; alt=&quot;&quot;/&gt;       &lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里介绍ELMo的两方面，一个是它的encoder模型Bi-LSTM，另一个是它和下游具体NLP任务的接口（迁移策略）。&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Bi-LSTM做encoder实现上下文相关（context）：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这里就是之前说的把下游具体NLP任务放到预训练产生词向量里面，从而达到获得一个根据context不同不断变化的dynamic词向量。具体实现方法是使用双向语言模型（BiLM）Bi-LSTM来实现，如下面左图所示。从前到后和后到前分别做一遍LSTM的encoding操作，从而获得两个方向的token联系，进而获得句子的context。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　但这里有两个潜在问题，姑且称作“不完全双向”和“自己看见自己”。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　首先，“不完全双向”是指模型的前向和后向LSTM两个模型是分别训练的，从图中也可以看出，对于一个序列，前向遍历一遍获得左边的LSTM，后向遍历一遍获得右边的LSTM，最后得到的隐层向量直接拼接得到结果向量（前向的hidden state1 + 后向的hidden state2 = 总的hidden state，+是concat），并且在最后的Loss function中也是前向和后向的loss function直接相加，并非完全同时的双向计算。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　另外，“自己看见自己”是指要预测的下一个词在给定的序列中已经出现的情况。传统语言模型的数学原理决定了它的单向性。从公式&lt;img src=&quot;https://img2018.cnblogs.com/blog/1214565/201901/1214565-20190116114232017-1219667808.png&quot; alt=&quot;&quot; width=&quot;542&quot; height=&quot;25&quot;/&gt;可以看出，传统语言模型的目标是获得在给定序列从头到尾条件概率相乘后概率最大的下一词，而双向模型会导致预测的下一词已经在给定序列中出现了的问题，这就是“自己看见自己”。如下面右图所示（图片从下往上看），最下行是训练数据A B C D，经过两个bi-lstm操作，需要预测某个词位置的内容。比如第二行第二列A|CD这个结果是第一层bi-lstm在B位置输出内容，包括正向A和反向CD，直接拼接成A|CD。比如第三行第二例ABCD这个结果是前向BCD和反向AB|D拼接结果，而当前位置需要预测的是B，已经在ABCD中出现了，这就会有问题。因而对于Bi-LSTM，只要层数增加，就是会存在“自己看见自己”的问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1214565/201901/1214565-20190116112443371-1531751133.png&quot; alt=&quot;&quot; width=&quot;405&quot; height=&quot;197&quot;/&gt;         &lt;img src=&quot;https://img2018.cnblogs.com/blog/1214565/201901/1214565-20190116113304627-165330102.png&quot; alt=&quot;&quot; width=&quot;283&quot; height=&quot;198&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;span&gt;与下游具体NLP任务接口：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　ELMo模型将context的encoding操作从下游具体NLP任务转换到了预训练词向量这里，但在具体应用时要做出一些调整。当bilstm有多层时，由于每层会学到不同的特征，而这些特征在具体应用中侧重点不同，每层的关注度也不同。ELMo给原始词向量层和每个RNN隐层都设置了一个可训练参数，通过softmax层归一化后乘到相应的层上并求和起到了加权作用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　比如，原本论文中设定了两个隐层，第一隐层可以学到对词性、句法等信息，对此有明显需求的任务可以对第一隐层参数学到比较大的值；第二隐层更适合对词义消歧有需求的任务，从而分配更高权重。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面是 ELMo的比较表格。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1214565/201901/1214565-20190116104824519-1994637198.png&quot; alt=&quot;&quot; width=&quot;988&quot; height=&quot;76&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;3. BERT&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1214565/201901/1214565-20190116135302227-2093534456.png&quot; alt=&quot;&quot; width=&quot;255&quot; height=&quot;227&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;BERT模型进一步增加词向量模型泛化能力，充分描述字符级、词级、句子级甚至句间关系特征。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;真正的双向encoding：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Masked LM，类似完形填空，尽管仍旧看到所有位置信息，但需要预测的词已被特殊符号代替，可以放心双向encoding。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;Transformer做encoder实现上下文相关（context）&lt;/strong&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　使用transformer而不是bi-LSTM做encoder，可以有更深的层数、具有更好并行性。并且线性的Transformer比lstm更易免受mask标记影响，只需要通过self-attention减小mask标记权重即可，而lstm类似黑盒模型，很难确定其内部对于mask标记的处理方式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;提升至句子级别：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　学习句子/句对关系表示，句子级负采样。首先给定的一个句子，下一句子正例（正确词），随机采样一句负例（随机采样词）,句子级上来做二分类（即判断句子是当前句子的下一句还是噪声），类似word2vec的单词级负采样。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1214565/201901/1214565-20190116104308267-1578273247.png&quot; alt=&quot;&quot; width=&quot;991&quot; height=&quot;76&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、BERT细则&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里主要介绍BERT的三个亮点&lt;/span&gt;&lt;span&gt;Masked LM、transformer、sentence-level。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1. Masked Language Model&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;# 原本叫cloze test，是完形填空的意思。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;随机mask语料中15%的token，然后将masked token 位置输出的最终隐层向量送入softmax，来预测masked token。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这样输入一个句子，每次只预测句子中大概15%的词，所以BERT训练很慢。。。（但是google设备NB。。）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1214565/201901/1214565-20190116140355998-735418598.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而对于盖住词的特殊标记，在下游NLP任务中不存在。因此，为了和后续任务保持一致，作者按一定的比例在需要预测的词位置上输入原词或者输入某个随机的词。&lt;/span&gt;&lt;span&gt;如：my dog is hairy&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;有80%的概率用“[mask]”标记来替换——my dog is [MASK]&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;有10%的概率用随机采样的一个单词来替换——my dog is apple&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;有10%的概率不做替换——my dog is hairy&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2. Transformer —— attention is all you need&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Transformer模型是2018年5月提出的，可以替代传统RNN和CNN的一种新的架构，用来实现机器翻译，论文名称是attention is all you need。无论是RNN还是CNN，在处理NLP任务时都有缺陷。CNN是其先天的卷积操作不很适合序列化的文本，RNN是其没有并行化，很容易超出内存限制（比如50tokens长度的句子就会占据很大的内存）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面左图是transformer模型一个结构，分成左边Nx框框的encoder和右边Nx框框的decoder，相较于RNN+attention常见的encoder-decoder之间的attention（上边的一个橙色框），还多出encoder和decoder内部的self-attention（下边的两个橙色框）。每个attention都有multi-head特征。最后，通过position encoding加入没考虑过的位置信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面从multi-head attention，self-attention， position encoding几个角度介绍。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1214565/201901/1214565-20190116142653316-1496131245.png&quot; alt=&quot;&quot; width=&quot;369&quot; height=&quot;411&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1214565/201901/1214565-20190116142545918-1165617611.png&quot; alt=&quot;&quot; width=&quot;336&quot; height=&quot;413&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;multi-head attention:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　将一个词的vector切分成h个维度，求attention相似度时每个h维度计算。由于单词映射在高维空间作为向量形式，每一维空间都可以学到不同的特征，相邻空间所学结果更相似，相较于全体空间放到一起对应更加合理。&lt;/span&gt;&lt;span&gt;比如对于vector-size=512的词向量，取h=8，每64个空间做一个attention，学到结果更细化。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;self-attention：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　每个词位的词都可以无视方向和距离，有机会直接和句子中的每个词encoding。比如上面右图这个句子，每个单词和同句其他单词之间都有一条边作为联系，边的颜色越深表明联系越强，而一般意义模糊的词语所连的边都比较深。比如：law，application，missing，opinion。。。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;position encoding:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　因为transformer既没有RNN的recurrence也没有CNN的convolution，但序列顺序信息很重要，比如你欠我100万明天要还和我欠你100万明天要还的含义截然不同。。。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　transformer计算token的位置信息这里使用正弦波↓，类似模拟信号传播周期性变化。这样的循环函数可以一定程度上增加模型的泛化能力。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1214565/201901/1214565-20190116144117224-867816626.png&quot; alt=&quot;&quot; width=&quot;317&quot; height=&quot;58&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　但BERT直接训练一个position embedding来保留位置信息，每个位置随机初始化一个向量，加入模型训练，最后就得到一个包含位置信息的embedding（简单粗暴。。），最后这个position embedding和word embedding的结合方式上，BERT选择直接拼接。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3. sentence-level representation&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在很多任务中，仅仅靠encoding是不足以完成任务的（这个只是学到了一堆token级的特征），还需要捕捉一些句子级的模式，来完成SLI、QA、dialogue等需要句子表示、句间交互与匹配的任务。对此，BERT又引入了另一个极其重要却又极其轻量级的任务，来试图把这种模式也学习到。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;句子级负采样&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　句子级别的连续性预测任务，即预测输入BERT的两端文本是否为连续的文本。训练的时候，输入模型的第二个片段会以50%的概率从全部文本中随机选取，剩下50%的概率选取第一个片段的后续的文本。 即首先给定的一个句子（相当于word2vec中给定context），它下一个句子即为正例（相当于word2vec中的正确词），随机采样一个句子作为负例（相当于word2vec中随机采样的词），然后在该sentence-level上来做二分类（即判断句子是当前句子的下一句还是噪声）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;句子级表示&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1214565/201901/1214565-20190116145008433-1602993101.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　BERT是一个句子级别的语言模型，不像ELMo模型在与下游具体NLP任务拼接时需要每层加上权重做全局池化，BERT可以直接获得一整个句子的唯一向量表示。它在每个input前面加一个特殊的记号[CLS]，然后让Transformer对[CLS]进行深度encoding，由于Transformer是可以无视空间和距离的把全局信息encoding进每个位置的，而[CLS]的最高隐层作为句子/句对的表示直接跟softmax的输出层连接，因此其作为梯度反向传播路径上的“关卡”，可以学到整个input的上层特征。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;segment embedding&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　对于句对来说，EA和EB分别代表左句子和右句子；对于句子来说，只有EA。这个EA和EB也是随模型训练出来的。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;如下图所示，最终输入结果会变成下面3个embedding拼接的表示。&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1214565/201901/1214565-20190116144618868-297101595.png&quot; alt=&quot;&quot; width=&quot;590&quot; height=&quot;229&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;&lt;span&gt;三、迁移策略&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下游具体NLP任务主要分为4大类&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;　　序列标注：分词、实体识别、语义标注……&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;　　分类任务：文本分类、情感计算……&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;　　句子关系判断：entailment、QA、自然语言推理&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;　　生成式任务：机器翻译、文本摘要&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt; 　　BERT将传统大量在下游具体NLP任务中做的操作转移到预训练词向量中，在获得使用BERT词向量后，最终只需在词向量上加简单的MLP或线性分类器即可。比如论文中所给的几类任务：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1214565/201901/1214565-20190116150329349-309993829.png&quot; alt=&quot;&quot; width=&quot;538&quot; height=&quot;275&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1214565/201901/1214565-20190116150342986-596377975.png&quot; alt=&quot;&quot; width=&quot;265&quot; height=&quot;263&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1214565/201901/1214565-20190116150348744-979980470.png&quot; alt=&quot;&quot; width=&quot;265&quot; height=&quot;274&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于左边两幅文本分类任务和文本匹配任务（文本匹配其实也是一种文本分类任务，只不过输入是文本对）来说，只需要用得到的表示（即encoder在[CLS]词位的顶层输出）加上一层MLP就好&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;a——句子关系判断（句对匹配）&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　MultiNLI文本蕴含识别（M推理出N，蕴含/矛盾/中立），QQP（文本匹配），QNLI（自然语言问题推理），STS-B（语义文本相似度1-5），MRPC（微软研究释义语料库，判断文本对语音信息是否等价）、RTE（同MNLI，小数据），SWAG（113k多项选择问题组成的数据集，涉及丰富的基础情境）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;b——分类任务（文本匹配）：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　SST-2（斯坦福情感分类树），CoLA（语言可接受性预测）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于左三图抽取式任务，用两个线性分类器分别输出span的起点和终点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;c——序列标注（文本抽取）：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　SQuAD（斯坦福问答数据集，从phrase中选取answer）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于左四图序列标注任务，就只需要加softmax输出层&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;d——序列标注：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　NER命名实体识别&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;四、运行结果&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;# 贫穷限制了我的想象力系列。。&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;span&gt;&lt;strong&gt;1. 数据量与模型大小&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;数据：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　BooksCropus与英文维基百科数据一共有33亿个词。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;模型：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　BERT模型的标准版本有1亿的参数量，与GPT持平；BERT的大号版本有3亿多参数量，这应该是目前自然语言处理中最大的预训练模型了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;训练代价：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　google用了16个TPU集群（一共64块TPU）来训练大号版本的BERT，花了4天时间。对于是否可以复现预训练，作者在 [Reddit]上有一个大致的回复，指出OpenAI当时训练GPT用了将近1个月的时间，而如果用同等的硬件条件来训练BERT估计需要1年的时间。不过他们会将已经训练好的模型和代码开源，方便大家训练好的模型上进行后续任务。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2. 运行结果&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Table1 句子关系判断及分类任务&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Table2 抽取式任务：SQuAD&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Table3 序列标注：命名实体识别&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Table4 分类任务：SWAG&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1214565/201901/1214565-20190116151627011-1157130413.png&quot; alt=&quot;&quot;/&gt;table1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1214565/201901/1214565-20190116151636109-1085982245.png&quot; alt=&quot;&quot; width=&quot;303&quot; height=&quot;339&quot;/&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1214565/201901/1214565-20190116151703493-1838477290.png&quot; alt=&quot;&quot; width=&quot;698&quot; height=&quot;275&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;只在NLP生成式任务中留了一条活路。。。。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 16 Jan 2019 07:21:00 +0000</pubDate>
<dc:creator>水奈樾</dc:creator>
<og:description># 好久没更新博客了，有时候随手在本上写写，或者Evernote上记记，零零散散的笔记带来零零散散的记忆o(╥﹏╥)o。。还是整理到博客上比较有整体性，也方便查阅~ 自google在2018年10月底</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/rucwxb/p/10277217.html</dc:identifier>
</item>
<item>
<title>我的第一个上线小程序，案例实战篇一 - 又过二十</title>
<link>http://www.cnblogs.com/wyang/p/10277128.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wyang/p/10277128.html</guid>
<description>&lt;p&gt;感谢大家的关注，”我的第一个上线小程序“三篇博文已经更新结束（PS:&lt;a id=&quot;post_title_link_10261790&quot; href=&quot;https://www.cnblogs.com/wyang/p/10261790.html&quot;&gt;我的第一个上线小程序，三篇其三&lt;/a&gt; 喜欢的可以跳转）。&lt;/p&gt;
&lt;p&gt;我前面的文章是写我的小程序是如何实现的，本来应该更新小程序版本同时发布，更新的内容主要是底部tabar，切换基础篇和实战篇内容。先把实战篇的在博客园连续发下去，希望大家和我一起探讨成长。&lt;/p&gt;
&lt;p&gt;我这个系列主要是分享基于LayaBox开发微信小游戏系列，开篇我先用一个经典案例——HelloWorld 教程，带大家熟悉下Laya。&lt;/p&gt;
&lt;p&gt;开发工具大家可以自己度娘，直接下载2.0版本。&lt;/p&gt;
&lt;p&gt;本片为了凑字数（PS:上一篇就以为文字内容过少，被博客园下架了，请审核的手下留情！！！）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;正式开始&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;窗体程序大家应该都接触过，LayaAir IDE也实现了拖拽式编程。&lt;/p&gt;
&lt;p&gt;第一步：新建一个空的LayaAir 空项目&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/633005/201901/633005-20190116142744209-2000483696.png&quot; alt=&quot;&quot; width=&quot;590&quot; height=&quot;443&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输入项目名称，大家随意呀，选择一个路径，编程语言选择JavaScript即可，点击创建即可。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;PS:整个项目结构大家可以边学习边熟悉，不着重讲解，相信大家经过两三个小练习就可以熟悉了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;第二步：我们把窗口切换到IDE的编辑模式，在Scenes文件夹右键-》新建-》页面/场景，输入场景名HelloWorld（也可以自行修改），点击创建就行&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/633005/201901/633005-20190116142937155-2096872589.png&quot; alt=&quot;&quot; width=&quot;780&quot; height=&quot;440&quot;/&gt;&lt;/p&gt;
&lt;p&gt;经过这一步，我们的游戏场景就创建出来了。&lt;/p&gt;
&lt;p&gt;下面我们在场景中添加一个按钮，窗口依然是编辑模式，在Basics目录下找到UI目录，在UI目录里面找到Button并拖拽到场景中，修改它的通用属性var为btnShow，常用属性label为helloworld&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/633005/201901/633005-20190116143640008-644285838.png&quot; alt=&quot;&quot; width=&quot;922&quot; height=&quot;608&quot;/&gt;&lt;/p&gt;
&lt;p&gt;经过这两步我们的游戏场景就大功告成了。&lt;/p&gt;
&lt;p&gt;第三步：我们把窗口切换到IDE的代码模式，在src目录下面新建一个scripts的文件夹，在scripts文件夹右键-》新建模板文件-》新建脚本文件，点击确定生成脚本文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/633005/201901/633005-20190116144900205-1892299168.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们在HelloWorld.js文件中复制下面的javascript代码，并保存。&lt;/p&gt;
&lt;p&gt;代码的主要功能是点击helloworld按钮弹出一个对话框，对话框里面展示 Hello World!&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
export &lt;span&gt;default&lt;/span&gt;&lt;span&gt; class HelloWorld extends Laya.Scene {
    constructor() { 
        super();
        HelloWorld.instance &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
    }
    onBtnShowClick(){
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; dialog = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Laya.Dialog();
        dialog.width&lt;/span&gt;=300&lt;span&gt;;
        dialog.height&lt;/span&gt;=600&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;var bg = new Laya.Image('comp/img_bg.png');&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;dialog.addChild(bg);&lt;/span&gt;

        &lt;span&gt;var&lt;/span&gt; button = &lt;span&gt;new&lt;/span&gt; Laya.Button('comp/button.png'&lt;span&gt;);
        button.label&lt;/span&gt;='Hello World!'&lt;span&gt;;
        button.name &lt;/span&gt;=&lt;span&gt; Laya.Dialog.CLOSE;
        button.width&lt;/span&gt;=260&lt;span&gt;;
        button.height&lt;/span&gt;=500&lt;span&gt;;
        button.pos(&lt;/span&gt;35, 35&lt;span&gt;);
        dialog.addChild(button);

        dialog.dragArea &lt;/span&gt;= '0,0,300,600'&lt;span&gt;;
        dialog.show();
    }
    onEnable() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btnShow.on(Laya.Event.CLICK,&lt;span&gt;this&lt;/span&gt;,&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.onBtnShowClick);
    }

    onDisable() {
        
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;是不是以为到了这一步就结束了，别着急，还有关键的一个步骤，就是把helloworld.js和我们的场景关联起来。&lt;/p&gt;
&lt;p&gt;最后一步：拖拽helloworld.js到场景的runtime字段中&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/633005/201901/633005-20190116150044892-575278792.png&quot; alt=&quot;&quot; width=&quot;609&quot; height=&quot;407&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到了这一步，才算大功告成，我们启动F8编译，F5启动调试。&lt;/p&gt;
&lt;p&gt;效果图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/633005/201901/633005-20190116150253243-788939559.png&quot; alt=&quot;&quot; width=&quot;376&quot; height=&quot;467&quot;/&gt;&lt;/p&gt;
&lt;p&gt;是不是很简单呀，第一篇LayaAir开发教程就到这里，若是喜欢，就关注我吧，我们一起交流成长。&lt;/p&gt;
&lt;p&gt;后面的实战案例我会把手里的几个项目的模块分享出来给大家。我也会尽快更新小程序，实现教程数据同步。&lt;/p&gt;
&lt;p&gt;欢迎大家体验我的小程序，留言交流。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/633005/201901/633005-20190116150512895-1130430131.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 16 Jan 2019 07:13:00 +0000</pubDate>
<dc:creator>又过二十</dc:creator>
<og:description>感谢大家的关注，”我的第一个上线小程序“三篇博文已经更新结束（PS:我的第一个上线小程序，三篇其三 喜欢的可以跳转）。 我前面的文章是写我的小程序是如何实现的，本来应该更新小程序版本同时发布</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wyang/p/10277128.html</dc:identifier>
</item>
<item>
<title>如何做自己的服务监控？spring boot 1.x服务监控揭秘 - 一天不进步，就是退步</title>
<link>http://www.cnblogs.com/davidwang456/p/10272999.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/davidwang456/p/10272999.html</guid>
<description>&lt;p&gt;1.准备&lt;/p&gt;
&lt;p&gt;  下载可运行程序：http://www.mkyong.com/spring-boot/spring-boot-hello-world-example-jsp/&lt;/p&gt;
&lt;p&gt;  2.添加服务监控依赖&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-actuator&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;provided&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.启动spring boot项目&lt;/p&gt;
&lt;p&gt;console 截图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/486074/201901/486074-20190115153421618-514316480.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.servlet和filter&lt;/p&gt;
&lt;p&gt;  4.1 使用ServletRegistrationBean注册dispatcherServlet&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * A {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; ServletContextInitializer} to register {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; Servlet}s in a Servlet 3.0+
 * container. Similar to the {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; ServletContext#addServlet(String, Servlet)
 * registration} features provided by {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; ServletContext} but with a Spring Bean
 * friendly design.
 * &amp;lt;p&amp;gt;
 * The {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #setServlet(Servlet) servlet} must be specified before calling
 * {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #onStartup}. URL mapping can be configured used {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #setUrlMappings} or
 * omitted when mapping to '/*' (unless
 * {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #ServletRegistrationBean(Servlet, boolean, String...) alwaysMapUrl} is set to
 * {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; false}). The servlet name will be deduced if not specified.
 *
 * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; &amp;lt;T&amp;gt; the type of the {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; Servlet} to register
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Phillip Webb
 * &lt;/span&gt;&lt;span&gt;@since&lt;/span&gt;&lt;span&gt; 1.4.0
 * &lt;/span&gt;&lt;span&gt;@see&lt;/span&gt;&lt;span&gt; ServletContextInitializer
 * &lt;/span&gt;&lt;span&gt;@see&lt;/span&gt;&lt;span&gt; ServletContext#addServlet(String, Servlet)
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;总结：类似于ServletContext#addServlet(String, Servlet)&lt;/p&gt;
&lt;p&gt;查看所有注册的bean&lt;/p&gt;
&lt;p&gt;http://127.0.0.1:8080/beans&lt;/p&gt;
&lt;p&gt;并把返回的json 格式化 视图查看，在线工具(http://www.bejson.com/jsonviewernew/)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/486074/201901/486074-20190115155413679-1737017741.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注册的流程：&lt;/p&gt;
&lt;p&gt;spring-boot-autoconfigure模块spring.facotories的属性org.springframework.boot.autoconfigure.EnableAutoConfiguration=DispatcherServletAutoConfiguration&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
        @Bean(name =&lt;span&gt; DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME)
        @ConditionalOnBean(value &lt;/span&gt;= DispatcherServlet.&lt;span&gt;class&lt;/span&gt;, name =&lt;span&gt; DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; DispatcherServletRegistrationBean dispatcherServletRegistration(
                DispatcherServlet dispatcherServlet) {
            DispatcherServletRegistrationBean registration &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DispatcherServletRegistrationBean(
                    dispatcherServlet, &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.webMvcProperties.getServlet().getPath());
            registration.setName(DEFAULT_DISPATCHER_SERVLET_BEAN_NAME);
            registration.setLoadOnStartup(
                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.webMvcProperties.getServlet().getLoadOnStartup());
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.multipartConfig != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                registration.setMultipartConfig(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.multipartConfig);
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; registration;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4.2 使用FilterRegistrationBean注册各种filter&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * A {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; ServletContextInitializer} to register {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; Filter}s in a Servlet 3.0+
 * container. Similar to the {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; ServletContext#addFilter(String, Filter) registration}
 * features provided by {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; ServletContext} but with a Spring Bean friendly design.
 * &amp;lt;p&amp;gt;
 * The {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #setFilter(Filter) Filter} must be specified before calling
 * {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #onStartup(ServletContext)}. Registrations can be associated with
 * {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #setUrlPatterns URL patterns} and/or servlets (either by {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #setServletNames
 * name} or via a {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #setServletRegistrationBeans ServletRegistrationBean}s. When no
 * URL pattern or servlets are specified the filter will be associated to '/*'. The filter
 * name will be deduced if not specified.
 *
 * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; &amp;lt;T&amp;gt; the type of {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; Filter} to register
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Phillip Webb
 * &lt;/span&gt;&lt;span&gt;@since&lt;/span&gt;&lt;span&gt; 1.4.0
 * &lt;/span&gt;&lt;span&gt;@see&lt;/span&gt;&lt;span&gt; ServletContextInitializer
 * &lt;/span&gt;&lt;span&gt;@see&lt;/span&gt;&lt;span&gt; ServletContext#addFilter(String, Filter)
 * &lt;/span&gt;&lt;span&gt;@see&lt;/span&gt;&lt;span&gt; DelegatingFilterProxyRegistrationBean
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;总结：类似于ServletContext#addFilter(String, Filter)&lt;/p&gt;
&lt;p&gt; spring-boot-actuator-autoconfigure模块spring.facotories的属性org.springframework.boot.autoconfigure.EnableAutoConfiguration=WebMvcMetricsAutoConfiguration,......&lt;/p&gt;
&lt;p&gt;5.RequestMappingHandlerAdapter查找controller注解&lt;/p&gt;
&lt;p&gt;使用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
2019-01-16 09:47:07.715  INFO 8468 --- [           main] s.w.s.m.m.a.RequestMappingHandlerAdapter : Looking for @ControllerAdvice: org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext@66ac5762: startup date [Wed Jan 16 09:47:06 CST 2019]; root of context hierarchy
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;定义：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * An {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; AbstractHandlerMethodAdapter} that supports {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; HandlerMethod}s
 * with their method argument and return type signature, as defined via
 * {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; @RequestMapping}.
 *
 * &amp;lt;p&amp;gt;Support for custom argument and return value types can be added via
 * {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #setCustomArgumentResolvers} and {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #setCustomReturnValueHandlers}.
 * Or alternatively, to re-configure all argument and return value types,
 * use {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #setArgumentResolvers} and {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #setReturnValueHandlers}.
 *
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Rossen Stoyanchev
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Juergen Hoeller
 * &lt;/span&gt;&lt;span&gt;@since&lt;/span&gt;&lt;span&gt; 3.1
 * &lt;/span&gt;&lt;span&gt;@see&lt;/span&gt;&lt;span&gt; HandlerMethodArgumentResolver
 * &lt;/span&gt;&lt;span&gt;@see&lt;/span&gt;&lt;span&gt; HandlerMethodReturnValueHandler
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;内部实现源码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; initControllerAdviceCache() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (getApplicationContext() == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isInfoEnabled()) {
            logger.info(&lt;/span&gt;&quot;Looking for @ControllerAdvice: &quot; +&lt;span&gt; getApplicationContext());
        }

        List&lt;/span&gt;&amp;lt;ControllerAdviceBean&amp;gt; beans =&lt;span&gt; ControllerAdviceBean.findAnnotatedBeans(getApplicationContext());
        AnnotationAwareOrderComparator.sort(beans);

        List&lt;/span&gt;&amp;lt;Object&amp;gt; requestResponseBodyAdviceBeans = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Object&amp;gt;&lt;span&gt;();

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (ControllerAdviceBean bean : beans) {
            Set&lt;/span&gt;&amp;lt;Method&amp;gt; attrMethods =&lt;span&gt; MethodIntrospector.selectMethods(bean.getBeanType(), MODEL_ATTRIBUTE_METHODS);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;attrMethods.isEmpty()) {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.modelAttributeAdviceCache.put(bean, attrMethods);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isInfoEnabled()) {
                    logger.info(&lt;/span&gt;&quot;Detected @ModelAttribute methods in &quot; +&lt;span&gt; bean);
                }
            }
            Set&lt;/span&gt;&amp;lt;Method&amp;gt; binderMethods =&lt;span&gt; MethodIntrospector.selectMethods(bean.getBeanType(), INIT_BINDER_METHODS);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;binderMethods.isEmpty()) {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.initBinderAdviceCache.put(bean, binderMethods);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isInfoEnabled()) {
                    logger.info(&lt;/span&gt;&quot;Detected @InitBinder methods in &quot; +&lt;span&gt; bean);
                }
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (RequestBodyAdvice.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.isAssignableFrom(bean.getBeanType())) {
                requestResponseBodyAdviceBeans.add(bean);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isInfoEnabled()) {
                    logger.info(&lt;/span&gt;&quot;Detected RequestBodyAdvice bean in &quot; +&lt;span&gt; bean);
                }
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ResponseBodyAdvice.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.isAssignableFrom(bean.getBeanType())) {
                requestResponseBodyAdviceBeans.add(bean);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isInfoEnabled()) {
                    logger.info(&lt;/span&gt;&quot;Detected ResponseBodyAdvice bean in &quot; +&lt;span&gt; bean);
                }
            }
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;requestResponseBodyAdviceBeans.isEmpty()) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.requestResponseBodyAdvice.addAll(0&lt;span&gt;, requestResponseBodyAdviceBeans);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;6.使用RequestMappingHandlerMapping查找controller映射路径&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
2019-01-16 09:47:07.758  INFO 8468 --- [           main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped &quot;{[/]}&quot; onto &lt;span&gt;public&lt;/span&gt; java.lang.String com.mkyong.WelcomeController.welcome(java.util.Map&amp;lt;java.lang.String, java.lang.Object&amp;gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;定义：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Creates {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; RequestMappingInfo} instances from type and method-level
 * {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; RequestMapping @RequestMapping} annotations in
 * {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; Controller @Controller} classes.
 *
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Arjen Poutsma
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Rossen Stoyanchev
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Sam Brannen
 * &lt;/span&gt;&lt;span&gt;@since&lt;/span&gt;&lt;span&gt; 3.1
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;作用：使用注解@RequestMapping在controller类内创建一个类型或者方法级别的RequestMappingInfo实例&lt;/p&gt;
&lt;p&gt;7.EndpointHandlerMapping映射的监控项&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
2019-01-15 14:19:30.985  INFO 9440 --- [           main] o.s.b.a.e.mvc.EndpointHandlerMapping     : Mapped &quot;{[/trace || /trace.json],methods=[GET],produces=[application/json]}&quot; onto public java.lang.Object org.springframework.boot.actuate.endpoint.mvc.EndpointMvcAdapter.invoke()
2019-01-15 14:19:30.986  INFO 9440 --- [           main] o.s.b.a.e.mvc.EndpointHandlerMapping     : Mapped &quot;{[/health || /health.json],produces=[application/json]}&quot; onto public java.lang.Object org.springframework.boot.actuate.endpoint.mvc.HealthMvcEndpoint.invoke(java.security.Principal)
2019-01-15 14:19:30.987  INFO 9440 --- [           main] o.s.b.a.e.mvc.EndpointHandlerMapping     : Mapped &quot;{[/metrics/{name:.*}],methods=[GET],produces=[application/json]}&quot; onto public java.lang.Object org.springframework.boot.actuate.endpoint.mvc.MetricsMvcEndpoint.value(java.lang.String)
2019-01-15 14:19:30.987  INFO 9440 --- [           main] o.s.b.a.e.mvc.EndpointHandlerMapping     : Mapped &quot;{[/metrics || /metrics.json],methods=[GET],produces=[application/json]}&quot; onto public java.lang.Object org.springframework.boot.actuate.endpoint.mvc.EndpointMvcAdapter.invoke()
2019-01-15 14:19:30.988  INFO 9440 --- [           main] o.s.b.a.e.mvc.EndpointHandlerMapping     : Mapped &quot;{[/dump || /dump.json],methods=[GET],produces=[application/json]}&quot; onto public java.lang.Object org.springframework.boot.actuate.endpoint.mvc.EndpointMvcAdapter.invoke()
2019-01-15 14:19:30.988  INFO 9440 --- [           main] o.s.b.a.e.mvc.EndpointHandlerMapping     : Mapped &quot;{[/heapdump || /heapdump.json],methods=[GET],produces=[application/octet-stream]}&quot; onto public void org.springframework.boot.actuate.endpoint.mvc.HeapdumpMvcEndpoint.invoke(boolean,javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse) throws java.io.IOException,javax.servlet.ServletException
2019-01-15 14:19:30.989  INFO 9440 --- [           main] o.s.b.a.e.mvc.EndpointHandlerMapping     : Mapped &quot;{[/beans || /beans.json],methods=[GET],produces=[application/json]}&quot; onto public java.lang.Object org.springframework.boot.actuate.endpoint.mvc.EndpointMvcAdapter.invoke()
2019-01-15 14:19:30.990  INFO 9440 --- [           main] o.s.b.a.e.mvc.EndpointHandlerMapping     : Mapped &quot;{[/autoconfig || /autoconfig.json],methods=[GET],produces=[application/json]}&quot; onto public java.lang.Object org.springframework.boot.actuate.endpoint.mvc.EndpointMvcAdapter.invoke()
2019-01-15 14:19:30.992  INFO 9440 --- [           main] o.s.b.a.e.mvc.EndpointHandlerMapping     : Mapped &quot;{[/env/{name:.*}],methods=[GET],produces=[application/json]}&quot; onto public java.lang.Object org.springframework.boot.actuate.endpoint.mvc.EnvironmentMvcEndpoint.value(java.lang.String)
2019-01-15 14:19:30.992  INFO 9440 --- [           main] o.s.b.a.e.mvc.EndpointHandlerMapping     : Mapped &quot;{[/env || /env.json],methods=[GET],produces=[application/json]}&quot; onto public java.lang.Object org.springframework.boot.actuate.endpoint.mvc.EndpointMvcAdapter.invoke()
2019-01-15 14:19:30.995  INFO 9440 --- [           main] o.s.b.a.e.mvc.EndpointHandlerMapping     : Mapped &quot;{[/info || /info.json],methods=[GET],produces=[application/json]}&quot; onto public java.lang.Object org.springframework.boot.actuate.endpoint.mvc.EndpointMvcAdapter.invoke()
2019-01-15 14:19:30.996  INFO 9440 --- [           main] o.s.b.a.e.mvc.EndpointHandlerMapping     : Mapped &quot;{[/mappings || /mappings.json],methods=[GET],produces=[application/json]}&quot; onto public java.lang.Object org.springframework.boot.actuate.endpoint.mvc.EndpointMvcAdapter.invoke()
2019-01-15 14:19:30.996  INFO 9440 --- [           main] o.s.b.a.e.mvc.EndpointHandlerMapping     : Mapped &quot;{[/configprops || /configprops.json],methods=[GET],produces=[application/json]}&quot; onto public java.lang.Object org.springframework.boot.actuate.endpoint.mvc.EndpointMvcAdapter.invoke()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中，&lt;/p&gt;
&lt;p&gt;/trace 通过EndpointMvcAdapter.invoke()触发TraceEndpoint的invoke方法&lt;/p&gt;
&lt;p&gt;/health通过HealthMvcEndpoint.invoke()触发&lt;/p&gt;
&lt;p&gt;/metrics/{name:.*}通过MetricsMvcEndpoint.value()触发&lt;/p&gt;
&lt;p&gt;/metrics通过EndpointMvcAdapter.invoke()触发MetricsEndpoint的invoke方法&lt;/p&gt;
&lt;p&gt;/dump通过EndpointMvcAdapter.invoke()触发DumpEndpoint的invoke方法&lt;/p&gt;
&lt;p&gt;/heapdump通过HeapdumpMvcEndpoint.invoke()触发&lt;/p&gt;
&lt;p&gt;/beans通过EndpointMvcAdapter.invoke()触发BeansEndpoint的invoke方法&lt;/p&gt;
&lt;p&gt;/autoconfig通过EndpointMvcAdapter.invoke()触发AutoconfigEndpoint的invoke方法&lt;/p&gt;
&lt;p&gt;/env/{name:.*}通过EnvironmentMvcEndpoint.value()方法触发&lt;/p&gt;
&lt;p&gt;/info通过EndpointMvcAdapter.invoke()触发InfoEndpoint的invoke方法&lt;/p&gt;
&lt;p&gt;/mappings通过通过EndpointMvcAdapter.invoke()触发RequestMappingEndpoint的invoke方法&lt;/p&gt;
&lt;p&gt;小结：&lt;/p&gt;
&lt;p&gt;restful请求实现分两种，一种通过EndpointMvcAdapter.invoke()触发&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/486074/201901/486074-20190116144043691-1392014506.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而EndpointMvcAdapter.invoke()通过注解@GetMapping实现了restful服务&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Adapter class to expose {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; Endpoint}s as {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; MvcEndpoint}s.
 *
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Dave Syer
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Andy Wilkinson
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; EndpointMvcAdapter &lt;span&gt;extends&lt;/span&gt; AbstractEndpointMvcAdapter&amp;lt;Endpoint&amp;lt;?&amp;gt;&amp;gt;&lt;span&gt; {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Create a new {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; EndpointMvcAdapter}.
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; delegate the underlying {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; Endpoint} to adapt.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; EndpointMvcAdapter(Endpoint&amp;lt;?&amp;gt;&lt;span&gt; delegate) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(delegate);
    }

    @Override
    @GetMapping(produces &lt;/span&gt;=&lt;span&gt; MediaType.APPLICATION_JSON_VALUE)
    @ResponseBody
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object invoke() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.invoke();
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另一种，通过继承MvcEndpoint的invoke方法来触发 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/486074/201901/486074-20190116144616046-1257580202.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;例如HealthMvcEndpoint&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    @RequestMapping(produces =&lt;span&gt; MediaType.APPLICATION_JSON_VALUE)
    @ResponseBody
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object invoke(Principal principal) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;getDelegate().isEnabled()) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Shouldn't happen because the request mapping should not be registered&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; getDisabledResponse();
        }
        Health health &lt;/span&gt;=&lt;span&gt; getHealth(principal);
        HttpStatus status &lt;/span&gt;=&lt;span&gt; getStatus(health);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (status != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ResponseEntity&amp;lt;Health&amp;gt;&lt;span&gt;(health, status);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; health;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;7.1 EndpointHandlerMapping的定义&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; HandlerMapping} to map {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; Endpoint}s to URLs via {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; Endpoint#getId()}.
 * The semantics of {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; @RequestMapping} should be identical to a normal
 * {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; @Controller}, but the endpoints should not be annotated as {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; @Controller}
 * (otherwise they will be mapped by the normal MVC mechanisms).
 * &amp;lt;p&amp;gt;
 * One of the aims of the mapping is to support endpoints that work as HTTP endpoints but
 * can still provide useful service interfaces when there is no HTTP server (and no Spring
 * MVC on the classpath). Note that any endpoints having method signatures will break in a
 * non-servlet environment.
 *
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Phillip Webb
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Christian Dupuis
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Dave Syer
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;7.2 层次结构&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/486074/201901/486074-20190116103742929-661591134.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;7.3 查看对应的bean的生成&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
      {
        &quot;bean&quot;: &quot;endpointHandlerMapping&quot;,
        &quot;aliases&quot;: [
          
        ],
        &quot;scope&quot;: &quot;singleton&quot;,
        &quot;type&quot;: &quot;org.springframework.boot.actuate.endpoint.mvc.EndpointHandlerMapping&quot;,
        &quot;resource&quot;: &quot;class path resource [org/springframework/boot/actuate/autoconfigure/EndpointWebMvcManagementContextConfiguration.class]&quot;,
        &quot;dependencies&quot;: [
          
        ]
      }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 7.4 获取流程&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Bean
    @ConditionalOnMissingBean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; EndpointHandlerMapping endpointHandlerMapping() {
        &lt;span&gt;Set&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&amp;lt;? extends MvcEndpoint&amp;gt; endpoints =&lt;/span&gt;&lt;span&gt;&lt;span&gt; mvcEndpoints().getEndpoints(); //1&lt;/span&gt;
        CorsConfiguration corsConfiguration &lt;/span&gt;= getCorsConfiguration(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.corsProperties);
&lt;span&gt;        EndpointHandlerMapping mapping &lt;/span&gt;&lt;/span&gt;&lt;span&gt;= new EndpointHandlerMapping(endpoints,
                corsConfiguration);                                          //2
&lt;span&gt;        boolean disabled = this.managementServerProperties.getPort() != null  
                &amp;amp;&amp;amp; this.managementServerProperties.getPort() == -1&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;; &lt;/span&gt;          &lt;/span&gt;
        mapping.setDisabled(disabled);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;disabled) {
            &lt;span&gt;mapping.setPrefix(&lt;/span&gt;&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;&lt;span&gt;.managementServerProperties.getContextPath()); //3&lt;/span&gt;
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.mappingCustomizers != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (EndpointHandlerMappingCustomizer customizer : &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mappingCustomizers) {
                &lt;span&gt;customizer.customize(mapping);   //4&lt;/span&gt;
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; mapping;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;7.4.1 MvcEndpoints获取endpoint定义&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; afterPropertiesSet() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        Collection&lt;/span&gt;&amp;lt;MvcEndpoint&amp;gt; existing =&lt;span&gt; BeanFactoryUtils
                .beansOfTypeIncludingAncestors(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.applicationContext, MvcEndpoint.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
                .values();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.endpoints.addAll(existing);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.customTypes =&lt;span&gt; findEndpointClasses(existing);
        @SuppressWarnings(&lt;/span&gt;&quot;rawtypes&quot;&lt;span&gt;)
        Collection&lt;/span&gt;&amp;lt;Endpoint&amp;gt; delegates =&lt;span&gt; BeanFactoryUtils
                .beansOfTypeIncludingAncestors(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.applicationContext, Endpoint.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
                .values();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Endpoint&amp;lt;?&amp;gt;&lt;span&gt; endpoint : delegates) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (isGenericEndpoint(endpoint.getClass()) &amp;amp;&amp;amp;&lt;span&gt; endpoint.isEnabled()) {
                EndpointMvcAdapter adapter &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EndpointMvcAdapter(endpoint);
                String path &lt;/span&gt;=&lt;span&gt; determinePath(endpoint,
                        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.applicationContext.getEnvironment());
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (path != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    adapter.setPath(path);
                }
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.endpoints.add(adapter);
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;7.4.2 定义映射关系&lt;/p&gt;
&lt;p&gt;其内部实现源码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String getPath(Object handler) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (handler &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; String) {
            handler &lt;/span&gt;=&lt;span&gt; getApplicationContext().getBean((String) handler);
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (handler &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; MvcEndpoint) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ((MvcEndpoint) handler).getPath();
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;&quot;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;7.4.3 增加contextpath&lt;/p&gt;
&lt;p&gt;7.4.4 自定义EndpointHandlerMappingCustomizer&lt;/p&gt;
&lt;p&gt;8.其它通过&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Bean
    @ConditionalOnBean(EnvironmentEndpoint.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
    @ConditionalOnEnabledEndpoint(&lt;/span&gt;&quot;env&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; EnvironmentMvcEndpoint environmentMvcEndpoint(EnvironmentEndpoint delegate) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EnvironmentMvcEndpoint(delegate);
    }

    @Bean
    @ConditionalOnMissingBean
    @ConditionalOnEnabledEndpoint(&lt;/span&gt;&quot;heapdump&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; HeapdumpMvcEndpoint heapdumpMvcEndpoint() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HeapdumpMvcEndpoint();
    }

    @Bean
    @ConditionalOnBean(HealthEndpoint.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
    @ConditionalOnEnabledEndpoint(&lt;/span&gt;&quot;health&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; HealthMvcEndpoint healthMvcEndpoint(HealthEndpoint delegate,
            ManagementServerProperties managementServerProperties) {
        HealthMvcEndpoint healthMvcEndpoint &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HealthMvcEndpoint(delegate,
                isHealthSecure(), managementServerProperties.getSecurity().getRoles());
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.healthMvcEndpointProperties.getMapping() != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            healthMvcEndpoint
                    .addStatusMapping(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.healthMvcEndpointProperties.getMapping());
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; healthMvcEndpoint;
    }

    @Bean
    @ConditionalOnBean(MetricsEndpoint.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
    @ConditionalOnEnabledEndpoint(&lt;/span&gt;&quot;metrics&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; MetricsMvcEndpoint metricsMvcEndpoint(MetricsEndpoint delegate) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MetricsMvcEndpoint(delegate);
    }

    @Bean
    @ConditionalOnEnabledEndpoint(&lt;/span&gt;&quot;logfile&quot;&lt;span&gt;)
    @Conditional(LogFileCondition.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; LogFileMvcEndpoint logfileMvcEndpoint() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LogFileMvcEndpoint();
    }

    @Bean
    @ConditionalOnBean(ShutdownEndpoint.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
    @ConditionalOnEnabledEndpoint(value &lt;/span&gt;= &quot;shutdown&quot;, enabledByDefault = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ShutdownMvcEndpoint shutdownMvcEndpoint(ShutdownEndpoint delegate) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ShutdownMvcEndpoint(delegate);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 以health为例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    @RequestMapping(produces =&lt;span&gt; MediaType.APPLICATION_JSON_VALUE)
    @ResponseBody
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object invoke(Principal principal) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;getDelegate().isEnabled()) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Shouldn't happen because the request mapping should not be registered&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; getDisabledResponse();
        }
       &lt;span&gt; Health health &lt;/span&gt;&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&lt;span&gt; getHealth(principal);&lt;/span&gt;
        HttpStatus status &lt;/span&gt;=&lt;span&gt; getStatus(health);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (status != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ResponseEntity&amp;lt;Health&amp;gt;&lt;span&gt;(health, status);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; health;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调用HealthEndpoint&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Invoke all {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; HealthIndicator} delegates and collect their health information.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Health invoke() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.healthIndicator.health();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 总结：&lt;/p&gt;
&lt;p&gt;spring boot提供http请求的方式可以分两种：&lt;/p&gt;
&lt;p&gt;1.通过查找@Controller注解中的@RequestMapping来形成HandlerMapping&lt;/p&gt;
&lt;p&gt;2.直接通过@RequestMapping来形成HandlerMapping如actuator模块，这里面又分成两种：&lt;/p&gt;
&lt;p&gt;   2.1  一种集中式的通过继承@RequestMapping来实现如通过EndpointMvcAdapter.invoke()触发&lt;/p&gt;
&lt;p&gt;   2.2  另一种通过直接的@RequestMapping注解实现&lt;/p&gt;
&lt;p&gt;3.spring boot1.x监控的实现&lt;/p&gt;
&lt;p&gt;　　/trace 通过EndpointMvcAdapter.invoke()触发TraceEndpoint的invoke方法&lt;/p&gt;
&lt;p&gt;　　/health通过HealthMvcEndpoint.invoke()触发&lt;/p&gt;
&lt;p&gt;　　/metrics/{name:.*}通过MetricsMvcEndpoint.value()触发&lt;/p&gt;
&lt;p&gt;　　/metrics通过EndpointMvcAdapter.invoke()触发MetricsEndpoint的invoke方法&lt;/p&gt;
&lt;p&gt;　　/dump通过EndpointMvcAdapter.invoke()触发DumpEndpoint的invoke方法&lt;/p&gt;
&lt;p&gt;　　/heapdump通过HeapdumpMvcEndpoint.invoke()触发&lt;/p&gt;
&lt;p&gt;　　/beans通过EndpointMvcAdapter.invoke()触发BeansEndpoint的invoke方法&lt;/p&gt;
&lt;p&gt;　　/autoconfig通过EndpointMvcAdapter.invoke()触发AutoconfigEndpoint的invoke方法&lt;/p&gt;
&lt;p&gt;　　/env/{name:.*}通过EnvironmentMvcEndpoint.value()方法触发&lt;/p&gt;
&lt;p&gt;　　/info通过EndpointMvcAdapter.invoke()触发InfoEndpoint的invoke方法&lt;/p&gt;
&lt;p&gt;　　/mappings通过通过EndpointMvcAdapter.invoke()触发RequestMappingEndpoint的invoke方法。&lt;/p&gt;
&lt;p&gt; 4. 这些实现都定义在spring.factories&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
org.springframework.boot.autoconfigure.EnableAutoConfiguration=&lt;span&gt;\
org.springframework.boot.actuate.autoconfigure.AuditAutoConfiguration&lt;/span&gt;,&lt;span&gt;\
org.springframework.boot.actuate.autoconfigure.CacheStatisticsAutoConfiguration&lt;/span&gt;,&lt;span&gt;\
org.springframework.boot.actuate.autoconfigure.CrshAutoConfiguration&lt;/span&gt;,&lt;span&gt;\
org.springframework.boot.actuate.autoconfigure.EndpointAutoConfiguration&lt;/span&gt;,&lt;span&gt;\
org.springframework.boot.actuate.autoconfigure.EndpointMBeanExportAutoConfiguration&lt;/span&gt;,&lt;span&gt;\
org.springframework.boot.actuate.autoconfigure.EndpointWebMvcAutoConfiguration&lt;/span&gt;,&lt;span&gt;\
org.springframework.boot.actuate.autoconfigure.HealthIndicatorAutoConfiguration&lt;/span&gt;,&lt;span&gt;\
org.springframework.boot.actuate.autoconfigure.InfoContributorAutoConfiguration&lt;/span&gt;,&lt;span&gt;\
org.springframework.boot.actuate.autoconfigure.JolokiaAutoConfiguration&lt;/span&gt;,&lt;span&gt;\
org.springframework.boot.actuate.autoconfigure.ManagementServerPropertiesAutoConfiguration&lt;/span&gt;,&lt;span&gt;\
org.springframework.boot.actuate.autoconfigure.ManagementWebSecurityAutoConfiguration&lt;/span&gt;,&lt;span&gt;\
org.springframework.boot.actuate.autoconfigure.MetricFilterAutoConfiguration&lt;/span&gt;,&lt;span&gt;\
org.springframework.boot.actuate.autoconfigure.MetricRepositoryAutoConfiguration&lt;/span&gt;,&lt;span&gt;\
org.springframework.boot.actuate.autoconfigure.MetricsDropwizardAutoConfiguration&lt;/span&gt;,&lt;span&gt;\
org.springframework.boot.actuate.autoconfigure.MetricsChannelAutoConfiguration&lt;/span&gt;,&lt;span&gt;\
org.springframework.boot.actuate.autoconfigure.MetricExportAutoConfiguration&lt;/span&gt;,&lt;span&gt;\
org.springframework.boot.actuate.autoconfigure.PublicMetricsAutoConfiguration&lt;/span&gt;,&lt;span&gt;\
org.springframework.boot.actuate.autoconfigure.TraceRepositoryAutoConfiguration&lt;/span&gt;,&lt;span&gt;\
org.springframework.boot.actuate.autoconfigure.TraceWebFilterAutoConfiguration

org.springframework.boot.actuate.autoconfigure.ManagementContextConfiguration&lt;/span&gt;=&lt;span&gt;\
org.springframework.boot.actuate.autoconfigure.&lt;span&gt;EndpointWebMvcManagementContextConfiguration&lt;/span&gt;&lt;/span&gt;,&lt;span&gt;\
org.springframework.boot.actuate.autoconfigure.EndpointWebMvcHypermediaManagementContextConfiguration&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Wed, 16 Jan 2019 07:01:00 +0000</pubDate>
<dc:creator>一天不进步，就是退步</dc:creator>
<og:description>1.准备 下载可运行程序：http://www.mkyong.com/spring-boot/spring-boot-hello-world-example-jsp/ 2.添加服务监控依赖 3.启动s</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/davidwang456/p/10272999.html</dc:identifier>
</item>
<item>
<title>asp.net core 系列 9 环境(Development、Staging 、Production) - 花阴偷移</title>
<link>http://www.cnblogs.com/MrHSR/p/10276650.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MrHSR/p/10276650.html</guid>
<description>&lt;h3&gt;一.在asp.net core中使用多个环境&lt;/h3&gt;
&lt;p&gt;　　ASP.NET Core 配置是基于运行时环境, 使用环境变量。ASP.NET Core 在应用启动时读取环境变量ASPNETCORE_ENVIRONMENT，并将该值存储在 IHostingEnvironment.EnvironmentName 中。ASPNETCORE_ENVIRONMENT 可设置为任意值，但框架支持三个值：Development、Staging 和 Production。 如果发布项目未设置 ASPNETCORE_ENVIRONMENT，则默认为 Production (本机vs中项目Properties\launchSettings.json中environmentVariables默认设置的是Development，如果禁用environmentVariables，那默认则为Production)。&lt;/p&gt;
&lt;p&gt;　　下面是Startup. Configure中的默认实现，本机默认配置的是Development环境。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果是Development环境&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (env.IsDevelopment())
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当捕获同步和异步系统。管道中的异常实例,并生成HTML错误响应。&lt;/span&gt;
&lt;span&gt;                app.UseDeveloperExceptionPage();
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果不是Development环境,向管道中添加一个中间件，用于捕获异常、记录异常并进行重置&lt;/span&gt;
                app.UseExceptionHandler(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/Home/Error&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                app.UseHsts();
            }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h5&gt;　　1.1 Development 模式&lt;/h5&gt;
&lt;p align=&quot;left&quot;&gt;         开发环境可以启用不应该在生产中公开的功能, 例如ASP.NET Core 模板在开发环境中启用了开发人员异常页(app.UseDeveloperExceptionPage())。当出现异常时，显示错误页信息如下图所示：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201901/151560-20190116134810744-98220612.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　本地计算机开发环境可以在项目的 Properties\launchSettings.json 文件中设置。 在 launchSettings.json 中设置的环境值替代在系统环境中设置的值。新建的mvc项目默认配置如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;iisSettings&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;windowsAuthentication&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;, 
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;anonymousAuthentication&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;, 
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;iisExpress&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;applicationUrl&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:30081&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sslPort&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;44349&lt;/span&gt;&lt;span&gt;
    }
  },
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;profiles&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;IIS Express&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;commandName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;IISExpress&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;launchBrowser&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;environmentVariables&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ASPNETCORE_ENVIRONMENT&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Development&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
      }
    },
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MyNetCoreStudy_MVC&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;commandName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Project&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;launchBrowser&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;applicationUrl&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://localhost:5001;http://localhost:5000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;environmentVariables&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ASPNETCORE_ENVIRONMENT&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Development&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
      }
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　launchSettings.json 中的 applicationUrl 属性可指定服务器 URL 的列表。 在列表中的 URL 之间使用分号。&lt;span&gt;注意：launchSettings.json只用于本机在vs 中开发使用，在开发中可以选择三种之中任意一种的环境模式。当项目发布后，发布后(iis做反向代理)，发布的文件中并不会有launchSettings.json文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;如果不用vs来启动应用程序，使用 dotnet run 命令来 启动应用程序时，使用具有 &quot;commandName&quot;: &quot;Project&quot; 的第一个配置文件。 commandName 的值指定要启动的 Web 服务器。 commandName 可为以下任一项：IIS Express、IIS、Project（启动 Kestrel 的项目）。&lt;/p&gt;
&lt;p&gt;　　当使用dotnet run 启动应用时：1会读取 launchSettings.json中的environmentVariables；2是会显示打印出host 环境。&lt;/p&gt;

&lt;h5&gt;　　1.2  Production  模式&lt;/h5&gt;
&lt;p&gt;      　　 Production 环境应配置为最大限度地提高安全性、性能和应用可靠性。 不同于开发环境的一些通用设置包括：&lt;/p&gt;
&lt;p&gt;　　　　(1) 缓存&lt;/p&gt;
&lt;p&gt;　　　　(2) 客户端资源被捆绑和缩小，并可能从 CDN (网络分发)提供。&lt;/p&gt;
&lt;p&gt;　　　　(3) 已禁用诊断错误页。&lt;/p&gt;
&lt;p&gt;　　　　(4) 已启用友好错误页。&lt;/p&gt;
&lt;p&gt;　　　　(5) 已启用生产记录和监视。&lt;/p&gt;

&lt;h3&gt;二. 环境设置&lt;/h3&gt;
&lt;p&gt; 　　在项目中为测试设置特定环境通常很有用。&lt;span lang=&quot;EN-US&quot;&gt; &lt;span data-ttu-id=&quot;dab47-157&quot;&gt;如果未设置环境，默认值为&lt;span lang=&quot;EN-US&quot;&gt; &lt;code&gt;&lt;span lang=&quot;EN-US&quot;&gt;Production&lt;/span&gt;&lt;/code&gt;，这会禁用大多数调试功能。&lt;span data-ttu-id=&quot;dab47-158&quot;&gt;设置环境的方法取决于操作系统。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;例如将asp.net core razor项目发布后，部署到IIS上,访问OtherPages/page1时出现异常。此时默认是&lt;code&gt;Production&lt;/code&gt; &lt;code&gt;环境变量，会&lt;/code&gt;显示了error页面信息， 表示已启用友好错误页。如下图所示 :&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201901/151560-20190116135313671-2051063119.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h5&gt;　　2.1  修改环境变量&lt;/h5&gt;
&lt;p&gt;　　　　上面讲到，设置环境的方法取决于操作系统：有Azure 应用服务、Windows、macOS、Linux等。每种操作系统上设置环境变量的方法不同，这里不在介绍，具体参考文档。这里就先只介绍在Windows操作系统上以iis做反向代理的配置环境变量。&lt;/p&gt;
&lt;p&gt;　　　　在Windows操作系统上配置环境变量方法有很多。当发布后，文件中有一个web.config。这里就介绍下在web.config中设置 &lt;code&gt;ASPNETCORE_ENVIRONMENT&lt;/code&gt; 环境变量。使用 web.config 设置 &lt;code&gt;ASPNETCORE_ENVIRONMENT&lt;/code&gt; 环境变量后，它的值会替代系统级设置。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
      &amp;lt;aspNetCore processPath=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dotnet&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; arguments=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.\MyNetCoreStudy.dll&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; stdoutLogEnabled=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; stdoutLogFile=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.\logs\stdout&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; hostingModel=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;InProcess&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &lt;span&gt;&lt;strong&gt;    &amp;lt;environmentVariables&amp;gt;
          &amp;lt;environmentVariable name=&quot;ASPNETCORE_ENVIRONMENT&quot; value=&quot;Development&quot; /&amp;gt;
        &amp;lt;/environmentVariables&amp;gt;&lt;/strong&gt;&lt;/span&gt;
      &amp;lt;/aspNetCore&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;         此时iis上该项目就是Development开发环境了，再次访问OtherPages/page1时出现异常，此时会捕获同步和异步系统。管道中的异常实例,并生成HTML错误响应。详细异常信息如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201901/151560-20190116135715805-1828433973.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;三. 发布到IIS上步骤&lt;/h3&gt;
&lt;p&gt;　　下面简单讲下发布到IIS上的步骤实现：&lt;/p&gt;
&lt;p&gt;　　　　(1) 安装好IIS，网上很多参考资料。&lt;/p&gt;
&lt;p&gt;　　　　(2)下载dotnet-hosting-2.2.1-win.exe 用于在iis上处理对web服务器的请求。下载地址介绍：&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;a href=&quot;https://docs.microsoft.com/zh-cn/aspnet/core/host-and-deploy/iis/index?view=aspnetcore-2.2#install-the-net-core-hosting-bundle&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/zh-cn/aspnet/core/host-and-deploy/iis/index?view=aspnetcore-2.2#install-the-net-core-hosting-bundle&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　在里面找到“当前 .NET Core 托管捆绑包安装程序（直接下载）”这里进去可以下载到当前版本(aspnetcore-2.2)，安装后，在iis模块中能看到AspNetCoreModuleV2。对应发布项目中web.config的&amp;lt;handlers&amp;gt;处理。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201901/151560-20190116140113505-338017888.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
     &amp;lt;handlers&amp;gt;
        &amp;lt;add name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;aspNetCore&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; path=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; verb=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; modules=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AspNetCoreModuleV2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; resourceType=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Unspecified&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
      &amp;lt;/handlers&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　(3) 在vs中右击项目发布，选择&quot;iis Ftp&quot; 点击发布。 选择“文件系统”， 目标位置可以选择当前电脑位置如: D:\DonetCoreStudy\IIS&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201901/151560-20190116140204418-219707307.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201901/151560-20190116140215364-1501071792.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　 (4) 在iis这边，添加网站　　　　　　&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201901/151560-20190116140305650-634388212.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　(5) 在应用程序池中对项目(MyNetCoreStudy)  选择无托管代码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201901/151560-20190116140331677-1486054011.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　这样发布到iis上就成功了。&lt;/p&gt;

&lt;h3&gt;四. 基于环境的 Startup 类&lt;/h3&gt;
&lt;p&gt; 　　最后在讲下Startup 类约定。当 ASP.NET Core 应用启动时，会启动Startup类。 应用程序可以为不同的环境，单独定义 Startup 类。可以定义例如： StartupDevelopment类、StartupProduction类，Startup类。当程序运行时会选择相应的 Startup 类。 程序会优先考虑名称后缀与当前环境相匹配的类。如果是Developmen环境则程序进入StartupDevelopment类，如果是Production环境则程序进入StartupProduction类。如果找不到匹配的 Startup{EnvironmentName}，就会使用 Startup 类。&lt;/p&gt;
&lt;p&gt;　　基于环境的 Startup 类实现代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; StartupDevelopment
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app, IHostingEnvironment env)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;        }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Startup class to use in the Production environment&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; StartupProduction
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;
&lt;span&gt;        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app, IHostingEnvironment env)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;        }
    }
        
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Fallback Startup class
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Selected if the environment doesn't match a Startup{EnvironmentName} class&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Startup
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;
&lt;span&gt;    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app, IHostingEnvironment env)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 根据环境变量，动态加载Startup的程序集类
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;args&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IWebHostBuilder CreateWebHostBuilder(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; assemblyName = &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(Startup).GetTypeInfo().Assembly.FullName;

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; WebHost.CreateDefaultBuilder(args)
                .UseStartup(assemblyName);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;参考文献&lt;/p&gt;
&lt;p&gt;官方资料:&lt;a href=&quot;https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/environments?view=aspnetcore-2.2&quot; target=&quot;_blank&quot;&gt;asp.net core 环境&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 16 Jan 2019 07:00:00 +0000</pubDate>
<dc:creator>花阴偷移</dc:creator>
<og:description>一.在asp.net core中使用多个环境 ASP.NET Core 配置是基于运行时环境, 使用环境变量。ASP.NET Core 在应用启动时读取环境变量ASPNETCORE_ENVIRONME</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/MrHSR/p/10276650.html</dc:identifier>
</item>
<item>
<title>MaxCompute安全管理指南-基础篇 - 阿里云云栖社区</title>
<link>http://www.cnblogs.com/yunqishequ/p/10276935.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yunqishequ/p/10276935.html</guid>
<description>&lt;ol&gt;&lt;li&gt;方便和辅助MaxCompute的project owner或安全管理员进行project的日常安全运维，保障数据安全。&lt;/li&gt;
&lt;li&gt;MaxCompute有安全模型，DataWorks也有安全模型，当通过DataWorks使用MaxCompute，而DataWorks的安全模型不满足业务安全需求时，合理的将两个安全模型结合使用就尤其重要。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;3&quot;&gt;MaxCompute安全模型&lt;/h2&gt;
&lt;h3 id=&quot;4&quot;&gt;安全体系&lt;/h3&gt;
&lt;p&gt;MaxCompute 多租户的数据安全体系，主要包括如下内容：&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li&gt;用户认证。&lt;br/&gt;支持 云账号 和 RAM 账号 两种账号体系，对于RAM账号，仅识别账号体系不识别RAM权限体系，即可将主账号自身的任意 RAM 子账号加入 MaxCompute 的某一个项目中，但 MaxCompute 在对该 RAM 子账号做权限验证时，并不会考虑 RAM 中的权限定义。&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;用户与授权管理。&lt;br/&gt;在MaxCompute Project中对用户添加（add）、移除（remove）、授权（grant）管理。&lt;br/&gt;还可以通过角色（role）管理授权，MaxCompute project默认有admin role。&lt;br/&gt;而授权方式包含ACL和Policy方式，本文只讲ACL方式，Policy方式待后续升级篇中介绍。&lt;br/&gt;ACL即似于 SQL92 定义的 GRANT/REVOKE 语法，它通过简单的授权语句来完成对已存在的项目空间对象的授权或撤销授权。授权语法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs sql&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;grant actions &lt;span class=&quot;hljs-keyword&quot;&gt;on &lt;span class=&quot;hljs-keyword&quot;&gt;object &lt;span class=&quot;hljs-keyword&quot;&gt;to subject
&lt;span class=&quot;hljs-keyword&quot;&gt;revoke actions &lt;span class=&quot;hljs-keyword&quot;&gt;on &lt;span class=&quot;hljs-keyword&quot;&gt;object &lt;span class=&quot;hljs-keyword&quot;&gt;from subject&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;标签安全策略&lt;br/&gt;基于标签的安全(LabelSecurity)是项目空间级别的一种强制访问控制策略(Mandatory Access Control, MAC)，它的引入是为了让项目空间管理员能更加灵活地控制用户对列级别敏感数据的访问。&lt;/li&gt;
&lt;li&gt;跨项目空间的资源分享。&lt;br/&gt;Package是一种跨项目空间共享数据及资源的机制，主要用于解决跨项目空间的用户授权问题。即可以分享table、Resource、function等资源给其他项目，但是无需对其他项目的用户进行管理。&lt;/li&gt;
&lt;li&gt;项目空间的数据保护。&lt;br/&gt;主要解决“不允许用户将数据转移到项目空间之外”的需求。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;5&quot;&gt;对象操作赋权、Role 和 label 关系介绍&lt;/h3&gt;
&lt;p&gt;上个小节中介绍了MaxCompute体系包含多种策略，而各种策略赋权是权限递增关系。以需要获取一个L4等级表的权限来展开说明这个递增关系，主要进行以下步骤操作：&lt;/p&gt;
&lt;p&gt;第一步: 如果用户未有过授权记录，且非本项目用户，首先需要添加一个 USER(用户)，这个过程，用户还没有任何实际权限。&lt;/p&gt;
&lt;p&gt;第二步: 赋权 USER(用户)对象的操作权限，有以下方式赋权。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs&quot;&gt;1) 可以是单独的操作权限;
2) 通过 policy 方式赋权给用户;
3) 将 ACL 和 policy 赋权给 role 再赋权给用户。 如果资源是没有设置 Label 的，则此时用户已经拥有的该资源的权限。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第三步: 对于拥有 Label 的资源，例如:数据表、打包了数据表的 package，则还需要 赋权 Label 权限。有以下四钟 Label 赋权:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs java&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;1) 针对某个数据表的字段;
&lt;span class=&quot;hljs-number&quot;&gt;2) 针对某个数据表; 
&lt;span class=&quot;hljs-number&quot;&gt;3) 针对某个 &lt;span class=&quot;hljs-keyword&quot;&gt;package;
&lt;span class=&quot;hljs-number&quot;&gt;4) 给某个 USER(用户)一个批量的 Label 权限，不支持 ROLE。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;各权限赋权过程及关系图如下：&lt;br/&gt;&lt;img title=&quot;undefined&quot; src=&quot;https://cdn.nlark.com/lark/0/2018/png/36371/1538188447134-68dde260-32ae-4301-b03d-be80814dc69e.png&quot; alt=&quot;undefined&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;6&quot;&gt;数据流程保护机制和 Package 关系介绍&lt;/h3&gt;
&lt;p&gt;ProjectProtection(数据流出保护机制)是 MaxCompute 防止项目内的数据批量流出的安全功能。 开启数据流程保护后，如果相互之间没有建立“TrustedProject Group” ，与其它 project 的数据赋权就必须通过 Package 方式进行，Package 赋权后，对方 package 可以自主赋权 Package 内的资源给组内用户。&lt;/p&gt;
&lt;p&gt;部分资源(例如某些常用表、UDF 等)，如想放权给其 Package 管理，也可以通过 Package 的方式，将资源打包后赋权给其他 Project。&lt;/p&gt;
&lt;p&gt;ProjectProtection(数据流出保护机制)支持做例外处理，部分特殊的业务场景，可以针 对应用的 IP 地址、产品云账号做 Exception 策略，以满足特殊的数据流出需求。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;undefined&quot; src=&quot;https://cdn.nlark.com/lark/0/2018/png/36371/1538190332322-2ecfe006-8cc0-43d8-a352-ed95830d68e6.png&quot; alt=&quot;undefined&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;7&quot;&gt;DataWorks安全模型&lt;/h2&gt;
&lt;p&gt;DataWorks提供多人协同数据开发工作的平台，其安全模型需要考虑几方面：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;企业之间数据的安全隔离。&lt;/li&gt;
&lt;li&gt;数据开发即ETL过程中的安全问题，如生产任务如何保障不可随意变更；如哪个成员可以进行代码编辑调试，哪个成员可以进行发布生产任务等。&lt;/li&gt;
&lt;li&gt;由于底层MaxCompute有自己的安全模型，项目成员做ETL过程肯定会需要MaxCompute的各种资源（table、Resource、function、instance）的相关权限。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;针对第一点，DataWorks的用户认证，DataWorks对接RAM，云账号可作为主账号进行开通并创建DataWorks项目，而项目成员必须为该主账号的RAM子账号不能是其他云账号。&lt;br/&gt;另外，同个主账号创建的项目作为一个组织，项目与项目之间的任务可以进行依赖配置；不同主账号创建的项目之间数据（各种任务）隔离。&lt;/p&gt;
&lt;p&gt;针对第二点，DataWorks通过业务划分“开发项目”、“生产项目”进行任务开发调试和稳定生产的隔离；通过成员角色控制哪个成员可以进行任务开发调试，哪个成员可以运维生产任务等。&lt;/p&gt;
&lt;p&gt;针对第三点，DataWorks在MaxCompute Project创建成功的同时，在MaxCompute Project里对应DataWorks的角色创建role，并给不同role赋权。&lt;/p&gt;

&lt;p&gt;从前面介绍的MaxCompute和DataWorks两个小节可以知道，通过MaxCompute的安全模型进行权限控制，并不会影响成员在DataWorks任何界面操作。通过DataWorks的用户角色分配，是有可能影响成员的MaxCompute资源权限。下面我们详细介绍这两个产品之间权限如何交叉关联。&lt;/p&gt;
&lt;h2 id=&quot;9&quot;&gt;项目关系&lt;/h2&gt;
&lt;p&gt;通过MaxCompute或DataWorks官网产品页进入的控制台创建的项目，&lt;/p&gt;
&lt;p&gt;DataWorks 两种选择：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;简单模式的项目实际上是创建了关联绑定好的一个MaxCompute project和一个DataWorks项目空间，同时在MaxCompute 的project里创建对应的几个role，具体role权限后续小节会介绍。&lt;/li&gt;
&lt;li&gt;标准模式的项目实际上是创建了关联绑定好的一个开发（dev）MaxCompute project、一个生产（prod）MaxCompute project对应一个DataWorks项目空间。同时在MaxCompute 的project里创建对应的几个role，具体role权限后续小节会介绍。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;10&quot;&gt;账号认证&lt;/h2&gt;
&lt;p&gt;云账号在DataWorks项目中只能是主账号即项目owner，在MaxCompute既可以为owner也可以为普通user。当通过DataWorks项目成员管理添加成员时只能是添加当前项目主账号对应的RAM子账号。而MaxCompute可以通过命令行&lt;code&gt;add user xxx;&lt;/code&gt;命令添加其他云账号。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;undefined&quot; src=&quot;https://cdn.nlark.com/lark/0/2018/png/36371/1537854960779-332a958c-36a7-4efc-8b6b-49e76f14726b.png&quot; alt=&quot;undefined&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;11&quot;&gt;成员角色权限关系&lt;/h2&gt;
&lt;p&gt;如前面小节（DataWorks安全模型）说的DataWorks为了解决项目成员在ETL过程中需要的MaxCompute相关资源权限，绑定了一些MaxCompute role。具体是指DataWorks项目固定有几个成员角色，同时在对应MaxCompute project上创建了对应几个role。另外MaxCompute project本身除了project owner，也还有一个admin role。&lt;/p&gt;
&lt;p&gt;具体权限对应如下表：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;MaxCompute角色&lt;/th&gt;
&lt;th&gt;MaxCompute数据权限&lt;/th&gt;
&lt;th&gt;DataWorks成员角色&lt;/th&gt;
&lt;th&gt;平台权限特征&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;15&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;project owner&lt;/td&gt;
&lt;td&gt;MaxCompute project的owner，拥有所有project的权限。&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;admin&lt;/td&gt;
&lt;td&gt;每一个project在创建时，会自动创建一个 admin 的role，并且为该role授予了确定的权限：可以访问project的所有对象、对user或role进行管理、对user或role进行授权。&lt;br/&gt;与project Owner 相比，admin 角色不能将 admin 权限指派给用户，不能设定项目空间的安全配置，不能修改项目空间的鉴权模型，admin 角色所对应的权限不能被修改。&lt;br/&gt;project owner可以将这admin role赋权给一个user，让该user代理安全管理。&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;role_project_admin&lt;/td&gt;
&lt;td&gt;project/table/fuction/resource/instance/job/package 的所有权限&lt;/td&gt;
&lt;td&gt;项目管理员&lt;/td&gt;
&lt;td&gt;指项目空间的管理者，可对该项目空间的基本属性、数据源、当前项目空间计算引擎配置和项目成员等进行管理，并为项目成员赋予项目管理员、开发、运维、部署、访客角色。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;role_project_dev&lt;/td&gt;
&lt;td&gt;project/fuction/resource/instance/job/package/table 的所有权限&lt;/td&gt;
&lt;td&gt;开发&lt;/td&gt;
&lt;td&gt;开发角色的用户能够创建工作流、脚本文件、资源和 UDF，新建/删除表，同时可以创建发布包，但不能执行发布操作。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;role_project_pe&lt;/td&gt;
&lt;td&gt;project/fuction/resource/instance/job 的所有权限，拥有package 的 read 权限和table 的 read/describe 权限。&lt;/td&gt;
&lt;td&gt;运维&lt;/td&gt;
&lt;td&gt;运维角色的用户由项目管理员分配运维权限；拥有发布及线上运维的操作权限，没有数据开发的操作权限。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;role_project_deploy&lt;/td&gt;
&lt;td&gt;默认无权限&lt;/td&gt;
&lt;td&gt;部署&lt;/td&gt;
&lt;td&gt;部署角色与运维角色相似，但是它没有线上运维的操作权限。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;role_project_guest&lt;/td&gt;
&lt;td&gt;默认无权限&lt;/td&gt;
&lt;td&gt;访客&lt;/td&gt;
&lt;td&gt;访客角色的用户只具备查看权限，没有权限进行编辑工作流和代码等操作。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;role_project_security&lt;/td&gt;
&lt;td&gt;默认无权限&lt;/td&gt;
&lt;td&gt;安全管理员&lt;/td&gt;
&lt;td&gt;安全管理员仅在数据保护伞中用到，用于敏感规则配置，数据风险审计等&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;由上表可知，DataWorks角色对应的MaxCompute权限是固定的，一旦某个user通过DataWorks角色获取MaxCompute相关role权限后，又通过命令行方式获得MaxCompute的其他权限，会使该user在MaxCompute的权限与在DataWorks上看到的不一致。&lt;/p&gt;
&lt;h4 id=&quot;12&quot;&gt;用户和权限关系图&lt;/h4&gt;
&lt;p&gt;一个DataWorks项目空间绑定一个MaxCompute project，此时根据DataWorks的项目管理——MaxCompute设置中的“MaxCompute访问身份”这个属性设置决定DataWorks其他项目成员是否拥有MaxCompute project的权限。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;image&quot; src=&quot;https://yqfile.alicdn.com/1594372846c369da7859dfd9b4bf249b167d8742.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;标准模式，一个DataWorks项目空间绑定两个MaxCompute project，此时固定MaxCompute的project一个是开发项目一个是生产项目，DataWorks其他项目成员根据成员角色拥有MaxCompute 开发project对应的role权限，但没有MaxCompute生产project的权限，MaxCompute 任务需要走发布流程发布到生产project后以owner账号提交到MaxCompute执行。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;image&quot; src=&quot;https://yqfile.alicdn.com/0e37b9b429f4ab951068fcbf2425788f6453a31d.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;14&quot;&gt;用户管理&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;操作类型&lt;/th&gt;
&lt;th&gt;DataWorks用户管理&lt;/th&gt;
&lt;th&gt;MaxCompute用户管理&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;13.5&quot;&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;操作描述&lt;/td&gt;
&lt;td&gt;准确添加和管理用户，应删除或锁定，无属主、闲置以及离职人员的账号权限，严控管理员、运维权限。&lt;/td&gt;
&lt;td&gt;应删除或锁定，无属主、闲置以及离职人员的账号权 限。 通过DataWorks新增的用户，注意会可能授权于默认的 role。&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;操作角色&lt;/td&gt;
&lt;td&gt;项目管理员&lt;/td&gt;
&lt;td&gt;owner或admin role&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;现状查看&lt;/td&gt;
&lt;td&gt;DataWorks项目管理页模块的——项目成员管理查看现有成员及角色，并确认各个成员权限的合理性。&lt;/td&gt;
&lt;td&gt;查看项目下的用户：&lt;br/&gt;&lt;code&gt;list users;&lt;/code&gt;;&lt;br/&gt;查看指定用户拥有的权限：&lt;br/&gt;&lt;code&gt;show grants for &amp;lt;username&amp;gt;;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;10&quot;&gt;&lt;td&gt;赋权操作&lt;/td&gt;
&lt;td&gt;DataWorks项目管理页模块的——项目成员管理添加成员和分配角色。注意：&lt;br/&gt;1.只能添加该项目负责人账号下的RAM子账号为项目成员；&lt;br/&gt;2.添加一个成员，并分配角色，可能会在MaxCompute 赋予默认的 role 权限。具体可参看前面《MaxCompute &amp;amp; DataWorks用户和权限关系图》小节&lt;/td&gt;
&lt;td&gt;成员仅加入 MaxCompute project，不在DataWorks 项目成员中体现，且无任何权限。 需要结合“对象操作”、“Role 权限”、“label 权限”才能使用，所以应关注成员是否拥有“对象操作”和“label 权限”，并对相应授权进行清理。&lt;br/&gt;另外，可以添加云账号和RAM子账号。&lt;br/&gt;在项目空间中添加用户:&lt;br/&gt;&lt;code&gt;add user &amp;lt;username&amp;gt;;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;回退操作&lt;/td&gt;
&lt;td&gt;清理成员或对应角色权限，删除后，会自动清除对应 MaxCompute 内的 user 和默认 role。&lt;/td&gt;
&lt;td&gt;在项目空间中移除用户：&lt;br/&gt;&lt;code&gt;remove user &amp;lt;username&amp;gt;;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;15&quot;&gt;角色管理&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;操作类型&lt;/th&gt;
&lt;th&gt;MaxCompute role管理&lt;/th&gt;
&lt;th&gt;DataWorks角色管理&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;14&quot;&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td&gt;操作描述&lt;/td&gt;
&lt;td&gt;准确的创建role并配置role权限，及时清理离职或转岗人员的账号，清理role中不必要开放的资源和权限。&lt;br/&gt;MaxCompute project创建成功后除了默认有admin role外，DataWorks还给创建几个role具体可参考前面《成员角色权限关系》小节。&lt;/td&gt;
&lt;td&gt;准确的分配角色，成员工作性质发生改变需及时改变角色，严格控制项目管理员和运维角色的分配。&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;操作角色&lt;/td&gt;
&lt;td&gt;project owner或admin&lt;/td&gt;
&lt;td&gt;项目管理员&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;现状查看&lt;/td&gt;
&lt;td&gt;查看当前project所有role：&lt;code&gt;list roles;&lt;/code&gt;&lt;br/&gt;查看role中的权限：&lt;code&gt;describe role &amp;lt;role_name&amp;gt;;&lt;/code&gt;&lt;br/&gt;查看某用户在什么role中：&lt;code&gt;show grants for &amp;lt;username&amp;gt;；&lt;/code&gt;&lt;br/&gt;查看某个role都指派给哪些user：目前暂不支持！&lt;/td&gt;
&lt;td&gt;DataWorks项目管理-&amp;gt;成员管理页面，可以点击每个角色查看该角色下的成员。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;10&quot;&gt;&lt;td&gt;赋权操作&lt;/td&gt;
&lt;td readability=&quot;7&quot;&gt;MaxCompute除了默认的role，还可以自定义role，通过命令自定义role权限并将role授权给user。&lt;br/&gt;创建role：&lt;code&gt;Create role &amp;lt;role_name&amp;gt;;&lt;/code&gt;&lt;br/&gt;给角色授权：&lt;code&gt;grant actions on object to &amp;lt;role_name&amp;gt;;&lt;/code&gt;&lt;br/&gt;添加用户到角色:&lt;code&gt;GRANT &amp;lt;roleName&amp;gt; TO &amp;lt;full_username&amp;gt; ;&lt;/code&gt;&lt;p&gt;此外，DataWorks的项目管理-&amp;gt;MaxCompute高级配置-&amp;gt;自定义用户角色页面，可以通过界面方式创建MaxCompute自定义role、对role进行授权、将role授权给成员，但是注意通过命令行创建的role不会在这个界面显示。&lt;/p&gt;&lt;/td&gt;
&lt;td&gt;DataWorks角色是固定的不能自定义，成员添加到DataWorks项目时勾选角色分配给成员，该成员既可拥有对应角色的权限。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td&gt;回退操作&lt;/td&gt;
&lt;td&gt;删除角色中的用户：&lt;code&gt;REVOKE &amp;lt;roleName&amp;gt; FROM &amp;lt;full_username&amp;gt;;&lt;/code&gt;&lt;br/&gt;撤销对角色的授权：&lt;code&gt;revoke &amp;lt;privList&amp;gt; on &amp;lt;objType&amp;gt; &amp;lt;objName&amp;gt; from role &amp;lt;rolename&amp;gt;;&lt;/code&gt;&lt;br/&gt;删除角色：&lt;code&gt;DROP ROLE &amp;lt;roleName&amp;gt;;&lt;/code&gt;&lt;br/&gt;如果是通过DataWorks的项目管理-&amp;gt;MaxCompute高级配置-&amp;gt;自定义用户角色页面创建的role，也通过这个页面进行回退操作。&lt;/td&gt;
&lt;td&gt;DataWorks的角色不能删除，只能将某个成员的角色去掉。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;16&quot;&gt;ACL（对象操作）的授权管理&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;操作类型&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;11.5&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;操作描述&lt;/td&gt;
&lt;td&gt;回收非必须必要的对象操作授权，操作权限涉及多种操作对象和类型，应逐一确认。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;操作角色&lt;/td&gt;
&lt;td&gt;project owner或admin role&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;现状查看&lt;/td&gt;
&lt;td&gt;查看指定用户的权限：&lt;br/&gt;&lt;code&gt;show grants for &amp;lt;username&amp;gt;;&lt;/code&gt;&lt;br/&gt;查看当前用户的权限:&lt;br/&gt;&lt;code&gt;show grants;&lt;/code&gt;&lt;br/&gt;查看指定对象的授权列表:&lt;br/&gt;&lt;code&gt;show acl for &amp;lt;objectName&amp;gt; [on type &amp;lt;objectType&amp;gt;];&lt;/code&gt;&lt;br/&gt;查看某 package 赋权情况案例:&lt;br/&gt;&lt;code&gt;show acl for alipaydw.alipaydw_for_alisec_app on type package;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;12&quot;&gt;&lt;td&gt;赋权操作&lt;/td&gt;
&lt;td&gt;进行某对象的操作赋权：&lt;br/&gt;&lt;code&gt;grant actions on object to subject;&lt;/code&gt;&lt;br/&gt;操作、主体、客体类型表达式：&lt;br/&gt;actions 类型： &lt;code&gt;action_item1, action_item2, ...&lt;/code&gt;&lt;br/&gt;object 类型：&lt;code&gt;project project_name,table schema_name ,instance inst_name ,function func_name ,resource res_name&lt;/code&gt;&lt;br/&gt;subject 类型：&lt;code&gt;user full_username ,role role_name&lt;/code&gt;&lt;br/&gt;操作、主体、客体类型，详细说明请看官方文档。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;回退操作&lt;/td&gt;
&lt;td&gt;回收某对象的操作权限：&lt;br/&gt;&lt;code&gt;revoke actions on object from subject;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;17&quot;&gt;Role授权管理&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;操作类型&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;12.5&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;操作描述&lt;/td&gt;
&lt;td&gt;角色(Role)可以打包多个 ACL 权限。当需要对一组用户赋予相同的权限，或者多ACL 权限时，可以使用角色(Role)来授权。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;操作角色&lt;/td&gt;
&lt;td&gt;project owner或admin role&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;现状查看&lt;/td&gt;
&lt;td&gt;查看指定角色的赋权内容，以及拥有该权限用户：&lt;br/&gt;&lt;code&gt;describe role &amp;lt;rolename&amp;gt;;&lt;/code&gt;&lt;br/&gt;查看指定用户拥有哪些 role 及 ACL:&lt;br/&gt;&lt;code&gt;show grants for &amp;lt;username&amp;gt;;&lt;/code&gt;&lt;br/&gt;查看当前用户的 role 及 ACL:&lt;br/&gt;&lt;code&gt;show grants; &lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;11&quot;&gt;&lt;td&gt;赋权操作&lt;/td&gt;
&lt;td&gt;1. 创建角色:&lt;br/&gt;&lt;code&gt;create role &amp;lt;rolename&amp;gt;;&lt;/code&gt;&lt;br/&gt;2. 给用户指派某种角色:&lt;br/&gt;&lt;code&gt;grant &amp;lt;rolename&amp;gt; to &amp;lt;username&amp;gt;;&lt;/code&gt;&lt;br/&gt;3. 给角色打包 ACL，有两种方式：&lt;br/&gt;方法一：逐一执行 ACL 授权命令。:&lt;br/&gt;&lt;code&gt;grant actions on object to role &amp;lt;rolename&amp;gt;;&lt;/code&gt;&lt;br/&gt;操作、主体、客体类型表达式：&lt;br/&gt;actions 类型： &lt;code&gt;action_item1, action_item2, ...&lt;/code&gt;&lt;br/&gt;object 类型：&lt;code&gt;project project_name , table schema_name ,instance inst_name , function func_name , resource res_name&lt;/code&gt;&lt;br/&gt;操作、主体类型，详细说明见官方文档。&lt;br/&gt;方法二：新建 policy 文件，将 policy 映射给 role。&lt;br/&gt;&lt;code&gt;Put policy &amp;lt;policy 文件所在本地位置&amp;gt; on role &amp;lt;rolename&amp;gt;;&lt;/code&gt;&lt;br/&gt;案例：&lt;br/&gt;&lt;code&gt;PUT POLICY D:\sx_default.txt ON ROLE sx_default; &lt;/code&gt;将存放在 D 盘根目录下的 policy 文件 sx_default.txt，映射给 sx_default 角色；&lt;br/&gt;Policy 配置详见《policy 的授权》小节&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;回退操作&lt;/td&gt;
&lt;td&gt;1. 删除角色：&lt;br/&gt;&lt;code&gt;drop role &amp;lt;rolename&amp;gt;;&lt;/code&gt;&lt;br/&gt;2. 撤销角色指派:&lt;br/&gt;&lt;code&gt;revoke &amp;lt;rolename&amp;gt; from &amp;lt;username&amp;gt;;&lt;/code&gt;&lt;br/&gt;3. 更改角色打包的 ACL，两种方式：&lt;br/&gt;方法一：逐一执行 ACL 更改授权命令。&lt;br/&gt;&lt;code&gt;revoke actions on object from role &amp;lt;rolename&amp;gt;;&lt;/code&gt;&lt;br/&gt;方法二：更改 policy 文件，将新的 policy 映射给 role。&lt;br/&gt;&lt;code&gt;Put policy &amp;lt;policy 文件所在本地位置&amp;gt; on role &amp;lt;rolename&amp;gt;; &lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;18&quot;&gt;package授权管理&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;操作类型&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;12&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;操作描述&lt;/td&gt;
&lt;td&gt;开启 ProjectProtection 的项目，如果没有在同一个互信项目组（TrustedProject Group），则必须使用 package 方式赋权，package 赋权有两种方式。确保package 合理打包和赋权，无闲置 package 赋权。&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;操作角色&lt;/td&gt;
&lt;td&gt;project owner&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;现状查看&lt;/td&gt;
&lt;td&gt;1. 了解本项目 Package 创建及赋权情况：&lt;br/&gt;查看已创建和已安装的 Package 列表:&lt;br/&gt;&lt;code&gt;show packages;&lt;/code&gt;&lt;br/&gt;查看 Package 详细信息:&lt;br/&gt;&lt;code&gt;describe package &amp;lt;pkgname&amp;gt;;&lt;/code&gt;&lt;br/&gt;2. 本项目安装的 Package ，对用户的授权情况:&lt;br/&gt;&lt;code&gt;show acl for &amp;lt;project_name.package_name&amp;gt; on type package;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8&quot;&gt;&lt;td&gt;赋权操作&lt;/td&gt;
&lt;td&gt;Package创建者:&lt;br/&gt;1. 创建 Package:&lt;br/&gt;&lt;code&gt;create package &amp;lt;pkgname&amp;gt;;&lt;/code&gt;&lt;br/&gt;2. 将分享的资源添加到 Package:&lt;br/&gt;&lt;code&gt;add project_object to package package_name [with privileges privileges];&lt;/code&gt;&lt;br/&gt;project_object 表达式：&lt;br/&gt;&lt;code&gt;table table_name ,instance inst_name ,function func_name ,resource res_name&lt;/code&gt;&lt;br/&gt;3. 许可其他项目空间使用 Package:&lt;br/&gt;&lt;code&gt;allow project &amp;lt;prjname&amp;gt; to install package &amp;lt;pkgname&amp;gt; [using label&amp;lt;number&amp;gt;];&lt;/code&gt;&lt;br/&gt;Package使用者:&lt;br/&gt;1. 安装 Package:&lt;br/&gt;&lt;code&gt;install package &amp;lt;pkgname&amp;gt;;&lt;/code&gt;&lt;br/&gt;2. 将 package 赋权给用户、角色，package赋权给具体用户时，不能指定 label。(project owner 或admin 都可操作)&lt;br/&gt;&lt;code&gt;grant actions on package &amp;lt;pkgName&amp;gt; to user &amp;lt;username&amp;gt;;&lt;/code&gt;&lt;br/&gt;&lt;code&gt;grant actions on package &amp;lt;pkgName&amp;gt; to role &amp;lt;role_name&amp;gt;;&lt;/code&gt;&lt;br/&gt;actions 类型：参考官方文档，一般将Package的 read权限赋给对象既可满足对象访问package里的资源。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8&quot;&gt;&lt;td&gt;回退操作&lt;/td&gt;
&lt;td&gt;1. 撤销其他项目空间使用 Package 的许可:&lt;br/&gt;&lt;code&gt;disallow project &amp;lt;prjname&amp;gt; to install package &amp;lt;pkgname&amp;gt;;&lt;/code&gt;&lt;br/&gt;2. 删除 Package:&lt;br/&gt;&lt;code&gt;delete package &amp;lt;pkgname&amp;gt;;&lt;/code&gt;&lt;br/&gt;3. 将分享的资源移出 Package:&lt;br/&gt;&lt;code&gt;remove project_object from package package_name;&lt;/code&gt;&lt;br/&gt;project_object 表达式：&lt;br/&gt;&lt;code&gt;table table_name ,instance inst_name ,function func_name ,resource res_name&lt;/code&gt;&lt;br/&gt;4. 撤销 package 的用户、角色的权限。&lt;br/&gt;&lt;code&gt;revoke actions on package &amp;lt;pkgName&amp;gt; from user &amp;lt;username&amp;gt;;&lt;/code&gt;&lt;br/&gt;&lt;code&gt;revoke actions on package &amp;lt;pkgName&amp;gt; from role &amp;lt;role_name&amp;gt;; &lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;19&quot;&gt;Label授权管理&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;操作类型&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;10&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;操作描述&lt;/td&gt;
&lt;td&gt;Maxcompute的字段、表、package 分为 1~4 个等级，应根据用户实际需要，赋予对应的 label 权限。&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;操作角色&lt;/td&gt;
&lt;td&gt;project owner&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;现状查看&lt;/td&gt;
&lt;td&gt;1. 查看一个用户能访问哪些敏感数据集:&lt;br/&gt;&lt;code&gt;SHOW LABEL [&amp;lt;level&amp;gt;] GRANTS [FOR USER &amp;lt;username&amp;gt;];&lt;/code&gt;&lt;br/&gt;&lt;code&gt;--省略 [FOR USER &amp;lt;username&amp;gt;]时，查看当前用户所能访问的敏感数据集.&lt;/code&gt;&lt;br/&gt;&lt;code&gt;--省略&amp;lt;level&amp;gt;时，将显示所有 label 等级的授权；&lt;/code&gt;&lt;br/&gt;&lt;code&gt;--若指定&amp;lt;level&amp;gt;，则只显示指定等级的授权.&lt;/code&gt;&lt;br/&gt;2. 查看一个敏感数据表能被哪些用户访问:&lt;br/&gt;&lt;code&gt;SHOW LABEL [&amp;lt;level&amp;gt;] GRANTS ON TABLE &amp;lt;tablename&amp;gt;;--显示指定 table 上的 Label 授权&lt;/code&gt;&lt;br/&gt;3. 查看一个用户对一个数据表的所有列级别的 Label 权限:&lt;br/&gt;&lt;code&gt;SHOW LABEL [&amp;lt;level&amp;gt;] GRANTS ON TABLE &amp;lt;tablename&amp;gt; FOR USER &amp;lt;username&amp;gt;;&lt;/code&gt;&lt;br/&gt;&lt;code&gt;--显示指定用户对指定 table 上列级别的 Label 授权 &lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td&gt;赋权操作&lt;/td&gt;
&lt;td&gt;1. 给用户单个表或字段的安全许可标签。&lt;br/&gt;&lt;code&gt;GRANT LABEL &amp;lt;number&amp;gt; ON TABLE &amp;lt;tablename&amp;gt;[(column_list)] TO USER &amp;lt;username&amp;gt; [WITH EXP &amp;lt;days&amp;gt;]; --默认过期时间是 180 天&lt;/code&gt;&lt;br/&gt;举例：&lt;br/&gt;&lt;code&gt;GRANT LABEL 2 ON TABLE t1 TO USER alice WITH EXP 1; --显式授权alice 访问 t1 表中敏感度不超过 2 级的数据，授权有效期为 1 天&lt;/code&gt;&lt;br/&gt;&lt;code&gt;GRANT LABEL 3 ON TABLE t1(col1, col2) TO USER alice WITH EXP 1; --显式授权 alice 访问 t1(col1, col2)中敏感度不超过3 级的数据，授权有效期为 1 天&lt;/code&gt;&lt;br/&gt;2. 给用户授权整个项目的安全许可标签。&lt;br/&gt;&lt;code&gt;SET LABEL &amp;lt;number&amp;gt; TO USER &amp;lt;username&amp;gt;;&lt;/code&gt;&lt;br/&gt;3. 控制 package 安装者对 package 中敏感资源的许可访问级别&lt;br/&gt;&lt;code&gt;ALLOW PROJECT &amp;lt;prjName&amp;gt; TO INSTALL PACKAGE &amp;lt;pkgName&amp;gt; [USING LABEL &amp;lt;number&amp;gt;];--由 package 创建者授权，授予 package 安装者对 package 中敏感资源的许可访问级别&lt;/code&gt;&lt;br/&gt;4. 将 package 赋权给用户、角色，package 赋权给具体用户时，不能指定 label。&lt;br/&gt;&lt;code&gt;grant actions on package &amp;lt;pkgName&amp;gt; to user &amp;lt;username&amp;gt;;&lt;/code&gt;&lt;br/&gt;&lt;code&gt;grant actions on package &amp;lt;pkgName&amp;gt; to role &amp;lt;role_name&amp;gt;;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;回退操作&lt;/td&gt;
&lt;td&gt;1. 撤销用户单个表或字段的安全许可标签。&lt;br/&gt;【撤销授权】：&lt;br/&gt;&lt;code&gt;REVOKE LABEL ON TABLE &amp;lt;tablename&amp;gt;[(column_list)] FROM USER &amp;lt;username&amp;gt;;&lt;/code&gt;&lt;br/&gt;【清理过期的授权】：&lt;br/&gt;&lt;code&gt;CLEAR EXPIRED GRANTS;&lt;/code&gt;&lt;br/&gt;举例:&lt;br/&gt;&lt;code&gt;REVOKE LABEL ON TABLE t1 FROM USER alice;--撤销 alice对 t1 表的敏感数据访问&lt;/code&gt;&lt;br/&gt;2. 更改用户授权整个项目的安全许可标签，默认等级为 0。&lt;br/&gt;&lt;code&gt;SET LABEL &amp;lt;number&amp;gt; TO USER &amp;lt;username&amp;gt;;&lt;/code&gt;&lt;br/&gt;3. 更改 package 安装者对 package 中敏感资源的许可访问级别，调整为其他级别，默认为 0。&lt;br/&gt;&lt;code&gt;ALLOW PROJECT &amp;lt;prjName&amp;gt; TO INSTALL PACKAGE &amp;lt;pkgName&amp;gt; [USING LABEL &amp;lt;number&amp;gt;];&lt;/code&gt;&lt;br/&gt;4. 撤销 package 的用户、角色的权限。&lt;br/&gt;&lt;code&gt;revoke actions on package &amp;lt;pkgName&amp;gt; from user &amp;lt;username&amp;gt;;&lt;/code&gt;&lt;br/&gt;&lt;code&gt;revoke actions on package &amp;lt;pkgName&amp;gt; from role &amp;lt;role_name&amp;gt;;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h2 id=&quot;21&quot;&gt;设置 ProjectProtection（数据流出保护机制）&lt;/h2&gt;
&lt;p&gt;项目空间的数据保护主要解决“不允许用户将数据转移到项目空间之外”的需求。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;操作类型&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;6.5&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;操作描述&lt;/td&gt;
&lt;td&gt;设置 ProjectProtection 避免项目批量数据下载到本地电脑，出现批量数据泄露风险。&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;操作角色&lt;/td&gt;
&lt;td&gt;project owner&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;查看现状&lt;/td&gt;
&lt;td&gt;执行命令：&lt;br/&gt;&lt;code&gt;show SecurityConfiguration;&lt;/code&gt;&lt;br/&gt;查是否 ProjectProtection=true&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;操作设置&lt;/td&gt;
&lt;td&gt;设置 ProjectProtection 机制，默认为 false；&lt;br/&gt;两个方法设置：&lt;br/&gt;DataWorks界面上设置：&lt;br/&gt;进入DataWorks项目管理-&amp;gt;MaxCompute设置-&amp;gt;基本设置页面，把“项目空间数据保护”属性打开。&lt;br/&gt;命令行方式执行MaxCompute命令：&lt;br/&gt;&lt;code&gt;SET ProjectProtection=true [WITH EXCEPTION &amp;lt;policyFile&amp;gt;];&lt;/code&gt;&lt;br/&gt;开启后由于部分公共账号，个人用户因种种原因需要数据流出权限，根据需要附带 exception 例外策略（白名单），exception policy具体看升级篇介绍。&lt;br/&gt;以下情形建议配置 Exception 策略：&lt;br/&gt;1) 需要数据流出权限的应用系统云账号或 IP 地址。&lt;br/&gt;2) 个人账号开通白名单，应指定允许下载的表。&lt;br/&gt;添加项目互信：&lt;br/&gt;对于数据可互通的 project 可以通过项目互信的方式确保数据顺利流转。&lt;br/&gt;查看当前project 中的所有 TrustedProjects: &lt;br/&gt;&lt;code&gt;list trustedprojects;&lt;/code&gt;&lt;br/&gt;在当前 project 中添加一个 TrustedProject&lt;br/&gt;&lt;code&gt;add trustedproject &amp;lt;projectname&amp;gt;;&lt;/code&gt;&lt;br/&gt;在当前 project 中移除一个 TrustedProject:&lt;br/&gt;&lt;code&gt;remove trustedproject &amp;lt;projectname&amp;gt;; &lt;/code&gt; &lt;br/&gt;未添加TrustedProject 的项目，申请本项目数据，需要以 package 方式授权。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;回退操作&lt;/td&gt;
&lt;td&gt;关闭 ProjectProtection 机制:&lt;br/&gt;&lt;code&gt;SET ProjectProtection=false;&lt;/code&gt;&lt;br/&gt;移除 TrustedProject:&lt;br/&gt;&lt;code&gt;remove trustedproject &amp;lt;projectname&amp;gt; ; &lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;22&quot;&gt;开启 Label Security（列及安全控制）&lt;/h2&gt;
&lt;p&gt;基于标签的安全(LabelSecurity)是项目空间级别的一种强制访问控制策略(Mandatory Access Control, MAC)，它的引入是为了让项目空间管理员能更加灵活地控制用户对列级别敏感数据的访问。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;操作类型&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;操作描述&lt;/td&gt;
&lt;td&gt;打开 LabelSecurity 确保字段级别安全控制生效， 项目空间中的 LabelSecurity 安全机制默认是关闭的。&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;操作角色&lt;/td&gt;
&lt;td&gt;project owner&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;查看现状&lt;/td&gt;
&lt;td&gt;&lt;code&gt;show SecurityConfiguration;&lt;/code&gt;&lt;br/&gt;查是否 LabelSecurity=true&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;操作设置&lt;/td&gt;
&lt;td&gt;开启 LabelSecurity 机制，默认为 false。&lt;br/&gt;&lt;code&gt;Set LabelSecurity=true; &lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;回退操作&lt;/td&gt;
&lt;td&gt;关闭 LabelSecurity 机制:&lt;br/&gt;&lt;code&gt;Set LabelSecurity=false; &lt;/code&gt;&lt;br/&gt;操作前，需要确认外部 project 数据的依赖情况，是否赋于了表的 label 权限。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;23&quot;&gt;合理设置字段的 Label&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;操作类型&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;9.5&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;操作描述&lt;/td&gt;
&lt;td&gt;MaxCompute数据的敏感性可以分为 0~4 级。所有数据表，可以设置安全等级，避免数据表出现不合理授权访问情形。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;查看现状&lt;/td&gt;
&lt;td&gt;查看 MaxCompute表字段的等级，两个方式:&lt;br/&gt;方式一，执行命令：&lt;code&gt;DESCRIBE &amp;lt;tablename&amp;gt;;&lt;/code&gt;&lt;br/&gt;方式二：在DataWorks的数据管理查看表详情中的字段信息。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td&gt;操作设置&lt;/td&gt;
&lt;td&gt;给表字段设置安全级别可以通过两种方式：&lt;br/&gt;方式一【推荐此方式】：&lt;br/&gt;DataWorks的数据管理里，新建表或者编辑已有表的字段信息，均可以设置字段安全级别。（注意，只有Project的LabelSecurity=true，数据管理页面才可见字段安全级别属性。）&lt;br/&gt;方式二，执行命令：&lt;br/&gt;&lt;code&gt;SET LABEL &amp;lt;number&amp;gt; TO TABLE tablename[(column_list)]; -- number 取值范围:[0, 4]。&lt;/code&gt;&lt;br/&gt;举例:&lt;br/&gt;&lt;code&gt;SET LABEL 1 TO TABLE t1; --设置表 t1 的 label 为 1 级&lt;/code&gt;&lt;br/&gt;&lt;code&gt;SET LABEL 2 TO TABLE t1(mobile, addr); --将 t1 的 mobile,addr 两列的 label 设置为 2 级&lt;/code&gt;&lt;br/&gt;&lt;code&gt;SET LABEL 3 TO TABLE t1; --设置表 t1 的 label 为 3 级. 注意此时 mobile,addr 两列的 label 仍为 2 级 &lt;/code&gt;&lt;br/&gt;注意：通过命令行设置自动安全级别后，在DataWorks的数据管理界面，对应表字段安全等级不同步，因此，建议通过DataWorks对表的字段进行安全级别设置&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;回退操作&lt;/td&gt;
&lt;td&gt;将安全等级调整回原来等级。注意：字段安全等级的上调，会导致原有的授权失效（涉及 package 授权、生产账号和个人账号），调整前必须通知到受影响用户，以减少影响。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;24&quot;&gt;设置访问Project的IP白名单&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;操作类型&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;8.5&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;操作描述&lt;/td&gt;
&lt;td&gt;设置IP白名单，指定白名单列表中的IP（console或者SDK所在的出口IP）能够访问这个Project。&lt;br/&gt;注：&lt;br/&gt;1.当前project的所有user（包括主账号）都会受限。 &lt;br/&gt;2.DataWorks的机器默认在白名单内，因此通过DataWorks提交MaxCompute任务不会受此限制。&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;操作角色&lt;/td&gt;
&lt;td&gt;project owner&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;查看现状&lt;/td&gt;
&lt;td&gt;通过console执行命令：&lt;br/&gt;&lt;code&gt;setproject;&lt;/code&gt;&lt;br/&gt;查看对应的‘odps.security.ip.whitelist= ’若等号后面为空则未设置白名单列表&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td&gt;操作设置&lt;/td&gt;
&lt;td&gt;设置前请特别注意：在白名单list加上自己当前机器IP，以免把自己屏蔽。 &lt;br/&gt;通过console执行命令：&lt;br/&gt;&lt;code&gt;setproject odps.security.ip.whitelist=xxx.xxx.xxx.xxx,xxx.xxx.x.x/xx,xxx.xxx.xxx.xxx-xxx.xxx.xxx.xxx;&lt;/code&gt; &lt;br/&gt;白名单中IP列表的表示格式有三种。&lt;br/&gt;单纯IP：例如101.132.236.134。&lt;br/&gt;子网掩码：100.116.0.0/16。&lt;br/&gt;网段：101.132.236.134-101.132.236.144。 &lt;br/&gt;设置IP白名单后，您需要等待五分钟后才会生效。&lt;br/&gt;若需更精细化管理，也可以通过policy授权，可参考后面的案例《project Policy 案例》。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;回退操作&lt;/td&gt;
&lt;td&gt;IP白名单清空后，MaxCompute就认为Project关闭了白名单功能。&lt;br/&gt;&lt;code&gt;setproject odps.security.ip.whitelist=; &lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;25&quot;&gt;设置禁止DataWorks的select结果下载到本地&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;操作类型&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;6.5&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;描述&lt;/td&gt;
&lt;td&gt;开发者通过DataWorks进行数据分析，通常会屏显在IDE上并且可以下载结果。project设置ProjectProtection为true后，在本project中只要有表的读取权限，依然可以通过DataWorks的开发界面select后进行结果下载。&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;操作角色&lt;/td&gt;
&lt;td&gt;DataWorks管理员&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;查看现状&lt;/td&gt;
&lt;td&gt;进入DataWorks的项目管理-&amp;gt;项目设置页面，查看“在本项目中能下载select结果”属性是否打开。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;操作设置&lt;/td&gt;
&lt;td&gt;进入DataWorks的项目管理-&amp;gt;项目设置页面，关闭“在本项目中能下载select结果”开关。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;回退操作&lt;/td&gt;
&lt;td&gt;进入DataWorks的项目管理-&amp;gt;项目设置页面，打开“在本项目中能下载select结果”开关。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;使用MaxCompute过程中，会关联使用到其他的云服务，因此也需要考虑通过其他云服务提高MaxCompute的安全管理。本章节主要介绍通过DataWorks使用MaxCompute时，添加项目成员必须会用到RAM子账号，那么如何在RAM子账号服务上提高安全管理。&lt;/p&gt;
&lt;p&gt;前面《MaxCompute安全模型》章节中提到MaxCompute的用户认证“支持 云账号 和 RAM 账号 两种账号体系，对于RAM账号，仅识别账号体系不识别RAM权 限体系，即可将主账号自身的任意 RAM 子账号加入 MaxCompute 的某一个项目中，但 MaxCompute 在对该 RAM 子账号做权限验证时，并不会考虑 RAM 中的权限定义。” 因此，我们只需要从RAM子账号登录验证入手进行安全控制。&lt;/p&gt;
&lt;p&gt;子账号密码强度设置&lt;/p&gt;
&lt;p&gt;如果您允许子用户更改登录密码，那么应该要求他们创建强密码并且定期轮换。&lt;br/&gt;您可以通过 RAM 控制台设置密码策略，如最短长度、是否需要非字母字符、必须进行轮换的频率等等。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;undefined&quot; src=&quot;https://cdn.nlark.com/lark/0/2018/png/36371/1539228611368-9bcd310e-41b7-46ff-a260-fbd8d3f70d30.png&quot; alt=&quot;undefined&quot;/&gt;&lt;/p&gt;
&lt;p&gt;子账号登录掩码设置&lt;/p&gt;
&lt;p&gt;通过设置网络掩码决定哪些IP地址会受到登录控制台的影响，子用户必须只能从指定的IP地址进行登录。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;undefined&quot; src=&quot;https://cdn.nlark.com/lark/0/2018/png/36371/1539238556135-f76cbc01-d784-4d78-8683-ce9af2c077d8.png&quot; alt=&quot;undefined&quot;/&gt;&lt;/p&gt;
&lt;p&gt;及时撤销用户不再需要的权限&lt;/p&gt;
&lt;p data-spm-anchor-id=&quot;a2c4e.11153940.blogcont686800.i2.1fcf1e86B6RFTQ&quot;&gt;当一个子账号对应员工由于工作职责变更而不再使用权限时，应该及时将对应子账号的权限撤销。&lt;/p&gt;
&lt;p data-spm-anchor-id=&quot;a2c4e.11153940.blogcont686800.i2.1fcf1e86B6RFTQ&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;a href=&quot;https://yq.aliyun.com/articles/686800?utm_content=g_1000037943&quot; target=&quot;_blank&quot;&gt;原文链接&lt;/a&gt;&lt;br/&gt;本文为云栖社区原创内容，未经允许不得转载。&lt;/p&gt;
</description>
<pubDate>Wed, 16 Jan 2019 06:46:00 +0000</pubDate>
<dc:creator>阿里云云栖社区</dc:creator>
<og:description>背景及目的 安全模型 MaxCompute安全模型 安全体系 MaxCompute 多租户的数据安全体系，主要包括如下内容： 用户认证。支持 云账号 和 RAM 账号 两种账号体系，对于RAM账号，仅</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yunqishequ/p/10276935.html</dc:identifier>
</item>
<item>
<title>redux 的概述 - 月山</title>
<link>http://www.cnblogs.com/mybilibili/p/10276866.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mybilibili/p/10276866.html</guid>
<description>&lt;h2 id=&quot;redux-的概述&quot;&gt;redux 的概述&lt;/h2&gt;
&lt;p&gt;随着 javascript 单页应用的不断发展,javascript 需要管理比以往都要多的状态,管理不断变化的 state 非常困难,数据流动不断变的模糊不可预测,代码的开发与维护成为了变得越来越困难.redux 这类状态管理框架变出现了,通过限制更新发生的时间和方式,来使 state 的变化变得可以预测.&lt;/p&gt;
&lt;p&gt;redux 是一个很有用的框架,但是并不是非用不可,而是当你自己觉得可能需要 redux 的时候,就会找到他,并且使用他(&lt;em&gt;还有其他同类框架&lt;/em&gt;)&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当你有大量的,随时间变化的数据&lt;/li&gt;
&lt;li&gt;当你需要一个单一可靠的 state 数据源&lt;/li&gt;
&lt;li&gt;当你把所有 state 放到顶部,或者父子兄弟之间的数据通信让你焦头烂额的时候&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;三大原则&quot;&gt;三大原则&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;单一数据源 (整个应用的 state 存放在一个 object tree 中,这个 object tree 只存在与唯一的一个 store 中)&lt;/li&gt;
&lt;li&gt;state 是只读的,唯一能够改变 state 的只有 action&lt;/li&gt;
&lt;li&gt;只能通过纯函数进行修改&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;state-基本概念&quot;&gt;state 基本概念&lt;/h3&gt;
&lt;p&gt;state 是数据的状态集合,一般为一个对象&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let state = {
    singer: [
        {
            name: &quot;刘德华&quot;,
            desc: &quot;一位演员&quot;
        }
    ],
    actor: [
        {
            name: &quot;郭富城&quot;,
            desc: &quot;一位歌手&quot;
        }
    ]
};&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;action-基本概念&quot;&gt;action 基本概念&lt;/h3&gt;
&lt;p&gt;action 是一个普通的 javacript 对象,用来更新 state 并同时描述发生了什么.可以知道应用到底发生了什么,变化后可以知道为什么改变.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let action = {
    type: &quot;ADD_SINGER&quot;,
    payload: {
        name: &quot;黎明&quot;,
        desc: &quot;一位很好的歌手&quot;
    }
};

let action2 = {
    type: &quot;ADD_ACTOR&quot;,
    payload: {
        name: &quot;周润发&quot;,
        desc: &quot;一位很好的演员&quot;
    }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;action-生成器&quot;&gt;action 生成器&lt;/h3&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;(action 是一个对象,action 生成器是一个函数,两个不同的概念)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;用于 action 的复用,实际上是返回一个对象的函数&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function addSinger_action(payload) {
    return {
        type: &quot;ADD_SINGER&quot;,
        payload
    };
}

function addActor_action(payload) {
    return {
        type: &quot;ADD_ACTOR&quot;,
        payload
    };
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;reducer-基本概念&quot;&gt;reducer 基本概念&lt;/h3&gt;
&lt;p&gt;reducer 是一个为了把 state 和 action 连接起来而诞生的纯函数,接收 state 和 action,然后返回一个新的 state&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function add_singer(state, action) {
    if (action.type === &quot;ADD_SINGER&quot;) {
        console.warn(&quot;发起了action=ADD_SINGER&quot;);
        state = Object.assign({}, state, {
            singer: state.singer.concat([action.payload])
        });
        return state;
    }
    return state;
}

function add_actor(state, action) {
    if (action.type === &quot;ADD_ACTOR&quot;) {
        console.warn(&quot;发起了action=&amp;gt;ADD_ACTOR&quot;);
        state = Object.assign({}, state, {
            actor: state.actor.concat([action.payload])
        });
        return state;
    }
    return state;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;改变 state&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;state = add_actor(
    state,
    addActor_action({
        name: &quot;周润发&quot;,
        desc: &quot;一位很好的演员&quot;
    })
);

console.log(state);

state = add_singer(
    state,
    addSinger_action({
        name: &quot;黎明&quot;,
        desc: &quot;一位很好的歌手&quot;
    })
);

console.log(state);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/easterCat/common_react/blob/master/03_redux/01.png?raw=true&quot; alt=&quot;01&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;上面就是 state,action 以及 reducer 连接二者的方式,redux 里面提供了更多的便捷操作&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;redux-基础&quot;&gt;redux 基础&lt;/h3&gt;
&lt;ol readability=&quot;4&quot;&gt;&lt;li readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;strong&gt;redux 中的 action&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;action 主要是把数据从应用传到 store 的有效载荷,它是 store 的唯一来源,通过 reducer 定义的 state 是初始化,一般写法中多设置为 null,undefined,{},[]等.通过 store.dispatch()将 action 传到 store.为了使用方便,一般会用 action 生成器来生成 action.&lt;/p&gt;
&lt;p&gt;redux 只用把 action 生成器的结果传给 dispatch()就可以发起 dispatch&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;import { createStore } from &quot;../redux/index&quot;;
import reducer from './reducer';

const ADD_SINGER = &quot;ADD_SINGER&quot;;
const ADD_ACTOR = &quot;ADD_ACTOR&quot;;

const store = createStore(reducer);

store.dispatch(
    addSinger_action({
        name: &quot;周华健&quot;,
        desc: &quot;一位大帅哥&quot;
    })
);

store.dispatch(
    addActor_action({
        name: &quot;谢安琪&quot;,
        desc: &quot;一位小美女&quot;
    })
);

console.log(store.getState());

function addSinger_action(payload) {
    return {
        type: ADD_SINGER,
        payload
    };
}
function addActor_action(payload) {
    return {
        type: ADD_ACTOR,
        payload
    };
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/easterCat/common_react/blob/master/03_redux/02.png?raw=true&quot; alt=&quot;02&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;我们也可以创建一个函数用于返回 dispatch 触发器&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;bound_add_singer_action({
    name: &quot;周华健&quot;,
    desc: &quot;一位大帅哥&quot;
});

bound_add_actor_action({
    name: &quot;谢安琪&quot;,
    desc: &quot;位小美女&quot;
});

function bound_add_singer_action(payload) {
    return store.dispatch(addSinger_action(payload));
}

function bound_add_actor_action(payload) {
    return store.dispatch(addActor_action(payload));
}

console.log(store.getState());&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;action 主要包含 action 对象,action_creater()生成器,bound_action_creater()绑定函数&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//我是action
{type:&quot;我是type&quot;,payload:&quot;我是数据&quot;}

//我是action生成器,我是来返回action对象
function action_creater(){
    return {type:&quot;我是type&quot;,payload:&quot;我是数据&quot;}
}

//我是bound_action_creater绑定函数,我是获取action生成器的返回值去触发dispatch()
function bound_action_creater(){
    store.dispatch(action_creater());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;redux 中 reducer&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;(oldState,action)=&amp;gt; newState 这种就是一个最简单的 reducer.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;禁止事项&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;修改传入的参数&lt;/li&gt;
&lt;li&gt;执行有副作用的操作,如 api 请求,变量修改,路由跳转&lt;/li&gt;
&lt;li&gt;调用非纯函数,如 Date.now()或 Math.random()&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;const singerState = {
    singer: [
        {
            name: &quot;刘德华&quot;,
            desc: &quot;一位演员&quot;
        }
    ]
}; //state初始状态

const actorState = {
    actor: [
        {
            name: &quot;郭富城&quot;,
            desc: &quot;一位歌手&quot;
        }
    ]
}; //state初始状态

const reducer = function(state = {}, action) {
    return {
        singerState: singer_reducer(state.singerState, action),
        actorState: actor_reducer(state.actorState, action)
    };
};
// console.log(reducer);

export default reducer;

function singer_reducer(state = singerState, action) {
    if (action.type === &quot;ADD_SINGER&quot;) {
        console.warn(&quot;发起了action=ADD_SINGER&quot;);
        state = Object.assign({}, state, {
            singer: state.singer.concat([action.payload])
        }); //Object.assgin会修改第一个参数的值,所以将state放到二号位
        return state;
    }
    return state; //遇到未知的 action 时,一定要返回旧的 state
}

function actor_reducer(state = actorState, action) {
    if (action.type === &quot;ADD_ACTOR&quot;) {
        console.warn(&quot;发起了action=&amp;gt;ADD_ACTOR&quot;);
        state = Object.assign({}, state, {
            actor: state.actor.concat([action.payload])
        });
        return state;
    }
    if (action.type === &quot;MINUS_ACTOR&quot;) {
        console.warn(&quot;发起了action=&amp;gt;MINUS_ACTOR&quot;);
        state.actor = state.actor.splice(action.index, 1);
        return state;
    }
    return state;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;redux 当然提供了的便捷方法 combineReducers().combineReducers()只是生成一个函数 combination,这个函数将调用所有的 reducer,每个 reducer 根据 key 值筛选出 state 的一部分数据进行处理.这个函数再将所有的 reducer 结果合成一个大对象.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import { combineReducers } from &quot;../redux/index&quot;;

// 返回一个combination函数
const reducer = combineReducers({
    singer_reducer,
    actor_reducer
});

// console.log(reducer);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时在 store 中,数据的 key 值会变为 singer_reducer 和 actor_reducer,我们可以通过设置不同 key 来更改在 store 中存放的 key&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
    singerState:singer_reducer,
    actorState:actor_reducer
}
//或者将函数名更改&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;redux 中 store&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;store 维护应用的 state&lt;/li&gt;
&lt;li&gt;提供 getState()方法获取 state&lt;/li&gt;
&lt;li&gt;提供 dispatch()方法触发 action,更新 state (action-&amp;gt;reducer-&amp;gt;newState)&lt;/li&gt;
&lt;li&gt;subscribe()注册监听器&lt;/li&gt;
&lt;li&gt;subscribe()返回一个函数用来注销监听器&lt;br/&gt;&lt;img src=&quot;https://github.com/easterCat/common_react/blob/master/03_redux/03.png?raw=true&quot; alt=&quot;03&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;const store = createStore(reducer);

const unsubscribe = store.subscribe(listener);

bound_add_singer_action({
    name: &quot;周华健&quot;,
    desc: &quot;一位大帅哥&quot;
});

bound_add_actor_action({
    name: &quot;谢安琪&quot;,
    desc: &quot;位小美女&quot;
});

bound_minus_actor_action(1);

unsubscribe();

bound_add_singer_action({
    name: &quot;周杰伦&quot;,
    desc: &quot;歌手一枚&quot;
});

bound_add_actor_action({
    name: &quot;周星驰&quot;,
    desc: &quot;笑了&quot;
});

function listener() {
    console.log(store.getState());
}

function bound_add_singer_action(payload) {
    return store.dispatch(addSinger_action(payload));
}

function bound_add_actor_action(payload) {
    return store.dispatch(addActor_action(payload));
}

function bound_minus_actor_action(index) {
    return store.dispatch(minusActor_action(index));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/easterCat/common_react/blob/master/03_redux/04.png?raw=true&quot; alt=&quot;04&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当我们 shore.dispatch()之后返回的值就是一个用来注销该监听器的 unsubscribe 函数,redux 中源码:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  function subscribe(listener) {
    if (typeof listener !== 'function') {
      throw new Error('Expected listener to be a function.')
    }

    let isSubscribed = true

    ensureCanMutateNextListeners()
    &amp;lt;!-- 将listener推入到执行队列中去 --&amp;gt;
    nextListeners.push(listener)

    return function unsubscribe() {
      if (!isSubscribed) {
        return
      }

      isSubscribed = false

      ensureCanMutateNextListeners()
      &amp;lt;!-- 找到监听的listener,并将函数从队列中删除 --&amp;gt;
      const index = nextListeners.indexOf(listener)
      nextListeners.splice(index, 1)
    }
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;http://cn.redux.js.org/&quot;&gt;第一个 Redux 中文文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.redux.org.cn/&quot;&gt;第二个 Redux 中文文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://redux.js.org/&quot;&gt;Redux 官方文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/kenberkeley/redux-simple-tutorial&quot;&gt;Redux 简明教程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://kylewh.gitbooks.io/understand-redux/content/&quot;&gt;Understand Redux&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_three_react-redux.html&quot;&gt;Redux 入门教程（三）：React-Redux 的用法&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 16 Jan 2019 06:35:00 +0000</pubDate>
<dc:creator>月山</dc:creator>
<og:description>redux 的概述 随着 javascript 单页应用的不断发展,javascript 需要管理比以往都要多的状态,管理不断变化的 state 非常困难,数据流动不断变的模糊不可预测,代码的开发与维</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mybilibili/p/10276866.html</dc:identifier>
</item>
<item>
<title>南尘的 2018，阅读本文大约需要一整年 - 南尘</title>
<link>http://www.cnblogs.com/liushilin/p/10276826.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liushilin/p/10276826.html</guid>
<description>&lt;h2 id=&quot;南尘的-2018阅读本文大约需要一整年&quot;&gt;南尘的 2018，阅读本文大约需要一整年&lt;/h2&gt;
&lt;p&gt;嗨，陌生人，你是我的朋友吗？我是南尘，还是那个在网上习惯加个 2251 后缀的南尘。&lt;/p&gt;
&lt;p&gt;你最近过的怎么样呀？应该还好吧。有没有好好工作，好好学习，好好生活呀？&lt;/p&gt;
&lt;p&gt;距离南尘的上一篇原创，好像得有俩月了吧，好像，在 2018 年，南尘就一直在玩消失。&lt;/p&gt;
&lt;p&gt;刚刚看了下 &lt;a href=&quot;https://github.com/nanchen2251&quot;&gt;GitHub&lt;/a&gt;，过去的一年里，提交数量不到 50 次，虽然 Stars 和 Fllowers 都熙熙攘攘地长了一些，不过似乎确实好久没有产生什么新的内容啦。&lt;/p&gt;
&lt;p&gt;在简书上看了一下自己的上一篇年终总结，花了一整年观看的 2017 年总结，早已悄然离开。2018 年，差点又悄然路过。&lt;/p&gt;
&lt;p&gt;2018 年是一个让人恍惚的一年，各种裁员风波异军突起，大家有被影响到吗？&lt;/p&gt;
&lt;p&gt;看起来好像每一年都是 Android 的寒冬的样子，但如果你的技术足够，即使你成了裁员潮下的亡命之徒，你会担心找不到下家吗？&lt;/p&gt;
&lt;p&gt;好像并不会。做技术，从来都是和企业一样，优胜劣汰，你唯一能做的，只能是不断深入学习，让自己有一技之长。&lt;/p&gt;
&lt;p&gt;好像有些许偏题了呢，不是说南尘的 2018 吗？怎么扯的渐行渐远啦。&lt;/p&gt;
&lt;p&gt;2018 年，南尘被提拔为了「技术总监助理」，开始做着部分项目和部门的管理和推动工作，才真正体会到了管理者的辛酸。感觉自己一会又开始开发 Python，一会又开始运维，一会又开始测试，又一会开始打开 Axure 设计起了原型。&lt;/p&gt;
&lt;p&gt;2018 年，带着对「致学」人文无限的不舍，为了追逐技术的深度，南尘终于跳槽啦。从头条到抖音，再到火山，心疼的是南尘均没有踏出成都。成都就像一座带着我无限感情的城市一样，始终不渝地牵扯着我。还好在秋天的 8 月，我和咕咚一拍即合，让咕咚成为了我 Android 路上的第二家企业。&lt;/p&gt;
&lt;p&gt;咕咚，一个挺有诗意的名字，一直到现在，都远超我心中的期望。我是一个煽情并且容易被身边事情动容的人，而咕咚，不论是技术，还是人文，都遵从着把细节做到最好，我很开心能有这样一群上进的小伙伴，虽然我的环境总是独一无二地出事儿。&lt;/p&gt;
&lt;p&gt;这里会有好多好多的人，在技术上帮助自己，比如一面就把我带上气氛的 &lt;strong&gt;Blue&lt;/strong&gt;，比如早已声名在外的 &lt;strong&gt;Hideeee&lt;/strong&gt;，还有一些我暂时还不知道他们网络昵称的大佬们，慢慢地，我才发现，原来最好的工作就是这样，薪资已经不是第一要素。&lt;/p&gt;
&lt;p&gt;2018 年，总算在公众号开启了送书福利和红包福利，也总算有了文末广告的权利，推文却一天不如一天，南尘也一天比一天愧疚。&lt;/p&gt;
&lt;p&gt;2018 年，我开始接触使用 Kotlin，在成为纯 Kotlin Android 开发后，进行了 &lt;a href=&quot;https://mp.weixin.qq.com/s/E83nfE2w8S9gE9WcQwv8Sg&quot;&gt;Better Kotlin&lt;/a&gt; 的技术分享，还分享了一个自己认为的 &lt;a href=&quot;https://mp.weixin.qq.com/s/hOLZEozcVp-aXyPwO0gQDA&quot;&gt;较好 Kotlin 学习方式&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;2018 年，写了一堆关于 &lt;a href=&quot;https://mp.weixin.qq.com/s/Ix6V6e3AS8nNcJ84TEbNCg&quot;&gt;Android 面试的题集&lt;/a&gt;，浑浑噩噩，多多少少，流流水水。&lt;/p&gt;
&lt;p&gt;2018 年，当初写的那一套 &lt;a href=&quot;https://www.jianshu.com/p/0cd258eecf60&quot;&gt;RxJava 2.x 入门教程&lt;/a&gt; 阅读暴涨，其实并没有写的很深入，没想到却成了不少 Android 开发的 RxJava 入门教程，虽说离扔物线朱凯的 RxJava 教程还相差甚远，但至少对人有所帮助，所以甚是欣慰。&lt;/p&gt;
&lt;p&gt;2018 年，在公众号上坚持了半年之久的 &lt;a href=&quot;https://mp.weixin.qq.com/s/WRdSmGxwDp-CpQcSlmJYlg&quot;&gt;模拟面试&lt;/a&gt; 从免费到收费，从一开始的无人问津到后面各种网站找我挂友链，到最后因为报名人数太多而使自己不堪重负被迫关停，直到现在，都还没有重新开启。&lt;/p&gt;
&lt;p&gt;2018 年，没有再去 Android 巴士成都站担任讲师，因为深知 17 年的分享做的太粗浅，不想再一次浪费大家的时间。倒是去了偶像朱凯大人的 HenCoder Plus 瞎比比了一个半小时，也是把自己所有积累慷慨地分享成了 &lt;a href=&quot;https://mp.weixin.qq.com/s/rP1vTJpoLlqj9jfj13WKeQ&quot;&gt;文字&lt;/a&gt;，哪怕只能帮到一个人。&lt;/p&gt;
&lt;p&gt;2018 年，熙熙攘攘，&lt;a href=&quot;https://github.com/nanchen2251&quot;&gt;GitHub&lt;/a&gt; 上的 AiYa 系列又新增了一名成员 &lt;a href=&quot;https://github.com/nanchen2251/AiYaScanner&quot;&gt;AiYaScanner&lt;/a&gt;，以 Zxing 和 Zbar 结合，只为极速扫码而生，希望大家多多众筹代码和提 bug，我想认真维护好这个库。&lt;/p&gt;
&lt;p&gt;2018，浑浑噩噩，洋洋洒洒，不再想提及感情。&lt;/p&gt;
&lt;h3 id=&quot;展望-2019&quot;&gt;展望 2019&lt;/h3&gt;
&lt;p&gt;还是需要一如常态，展望一下 2019。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;希望能把模拟面试再重新开启一下，毕竟这是我在技术圈里以来，发现最有意义的事。&lt;/li&gt;
&lt;li&gt;还是希望自己能把架构方面挖一下吧，毕竟不想一直就做需求开发工程师。&lt;/li&gt;
&lt;li&gt;不敢奢求能发多少篇推文，但求每一篇都能带来无限制的价值。&lt;/li&gt;
&lt;li&gt;最最重要的还是，不管你在哪里，不管你对我是喜欢还是厌恶，都希望你能开心每一天~&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Wed, 16 Jan 2019 06:29:00 +0000</pubDate>
<dc:creator>南尘</dc:creator>
<og:description>南尘的 2018，阅读本文大约需要一整年 嗨，陌生人，你是我的朋友吗？我是南尘，还是那个在网上习惯加个 2251 后缀的南尘。 你最近过的怎么样呀？应该还好吧。有没有好好工作，好好学习，好好生活呀？</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liushilin/p/10276826.html</dc:identifier>
</item>
</channel>
</rss>