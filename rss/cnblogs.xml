<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>java中的守护线程 - 杨冠标</title>
<link>http://www.cnblogs.com/yanggb/p/11702843.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yanggb/p/11702843.html</guid>
<description>&lt;p&gt;在Java中有两类线程，分别是User Thread（用户线程）和Daemon Thread（守护线程） 。&lt;/p&gt;
&lt;p&gt;用户线程很好理解，我们日常开发中编写的业务逻辑代码，运行起来都是一个个用户线程。而守护线程相对来说则要特别理解一下。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;什么是守护线程&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在操作系统里面是没有所谓的守护线程的概念的，只有守护进程一说。但是Java语言机制是构建在JVM的基础之上的，这一机制意味着Java平台是把操作系统的底层给屏蔽了起来，所以它可以在它自己的虚拟的平台里面构造出对自己有利的机制。而Java语言或者说平台的设计者多多少少是收到Unix操作系统思想的影响，而守护线程机制又是对JVM这样的平台凑合，于是守护线程应运而生。&lt;/p&gt;
&lt;p&gt;所谓的守护线程，指的是程序运行时在后台提供的一种通用服务的线程。比如垃圾回收线程就是一个很称职的守护者，并且这种线程并不属于程序中不可或缺的部分。因此，当所有的非守护线程结束时，程序也就终止了，同时会杀死进程中的所有守护线程。反过来说，只要任何非守护线程还在运行，程序就不会终止。&lt;/p&gt;
&lt;p&gt;事实上，User Thread（用户线程）和Daemon Thread（守护线程）从本质上来说并没有什么区别，唯一的不同之处就在于虚拟机的离开：如果用户线程已经全部退出运行了，只剩下守护线程存在了，虚拟机也就退出了。 因为没有了被守护者，守护线程也就没有工作可做了，也就没有继续运行程序的必要了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;守护线程的使用与注意事项&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;守护线程并非只有虚拟机内部可以提供，用户也可以手动将一个用户线程设定/转换为守护线程。&lt;/p&gt;
&lt;p&gt;在Thread类中提供了一个setDaemon(true)方法来将一个普通的线程（用户线程）设置为守护线程。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setDaemon(&lt;span&gt;boolean&lt;/span&gt; on);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在使用的过程中，有几点需要注意：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.thread.setDaemon(true)必须在thread.start()之前设置，否则会抛出一个IllegalThreadStateException异常。&lt;/span&gt;这也就意味着不能把正在运行的常规线程设置为守护线程。 这点与操作系统中的守护进程有着明显的区别，守护进程是创建后，让进程摆脱原会话的控制+让进程摆脱原进程组的控制+让进程摆脱原控制终端的控制；所以说寄托于虚拟机的语言机制跟系统级语言有着本质上面的区别。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.在Daemon线程中产生的新线程也是Daemon的。&lt;/span&gt;关于这一点又是与操作系统中的守护进程有着本质的区别：守护进程fork()出来的子进程不再是守护进程，尽管它把父进程的进程相关信息复制过去了，但是子进程的进程的父进程不是init进程，所谓的守护进程本质上说就是，当父进程挂掉，init就会收养该进程，然后文件0、1和2都是/dev/null，当前目录到/。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.不是所有的应用都可以分配给Daemon线程来进行服务的，比如读写操作或者计算逻辑。&lt;/span&gt;因为这种应用可能在Daemon Thread还没来得及进行操作时，虚拟机已经退出了。这也就意味着，守护线程应该永远不去访问固有资源，如文件、数据库，因为它会在任何时候甚至在一个操作的中间发生中断。&lt;/p&gt;
&lt;p&gt;下面以一个完成文件输出的守护线程任务作为例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt; java.io.*&lt;span&gt;;  

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; TestRunnable &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run(){
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            Thread.sleep(&lt;/span&gt;1000); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 守护线程阻塞1秒后运行  &lt;/span&gt;
            File f = &lt;span&gt;new&lt;/span&gt; File(&quot;daemon.txt&quot;&lt;span&gt;);
            FileOutputStream os &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; FileOutputStream(f,&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
            os.write(&lt;/span&gt;&quot;daemon&quot;&lt;span&gt;.getBytes());
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(IOException e1) {  
            e1.printStackTrace();  
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(InterruptedException e2) {  
            e2.printStackTrace();  
        }  
    }  
}  

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestDemo2 {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
        Runnable tr &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TestRunnable();
        Thread thread &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(tr);
        thread.setDaemon(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置守护线程（必须在thread.start()之前）&lt;/span&gt;
        thread.start(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 开始执行分进程&lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面这段代码的运行结果是文件daemon.txt中没有daemon字符串。&lt;/p&gt;
&lt;p&gt;但是如果把thread.setDaemon(true);这行代码注释掉，文件daemon.txt是可以被写入daemon字符串的，因为这个时候这个线程就是普通的用户线程了。&lt;/p&gt;
&lt;p&gt;简单理解就是，JRE判断程序是否执行结束的标准是所有的前台线程（用户线程）执行完毕了，而不管后台线程（守护线程）的状态。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;守护线程的应用场景&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;前面说了那么多，那么Daemon Thread的实际应用在那里呢？举个例子，Web服务器中的Servlet，在容器启动时，后台都会初始化一个服务线程，即调度线程，负责处理http请求，然后每个请求过来，调度线程就会从线程池中取出一个工作者线程来处理该请求，从而实现并发控制的目的。也就是说，一个实际应用在Java的线程池中的调度线程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/842514/201910/842514-20191019094436692-1045439482.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;从我的理解，守护线程就是用来告诉JVM，我的这个线程是一个低级别的线程，不需要等待它运行完才退出，让&lt;span lang=&quot;EN-US&quot;&gt;JVM喜欢什么时候退出就退出，不用管这个线程。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在日常的业务相关的CRUD开发中，其实并不会关注到守护线程这个概念，也几乎不会用上。&lt;/p&gt;
&lt;p&gt;但是如果要往更高的地方走的话，这些深层次的概念还是要了解一下的，比如一些框架的底层实现。&lt;/p&gt;

&lt;p&gt;&quot;我不知道我有多喜欢你，但如果是去见你，我一定用跑的。&quot;&lt;/p&gt;
</description>
<pubDate>Sun, 20 Oct 2019 00:41:00 +0000</pubDate>
<dc:creator>杨冠标</dc:creator>
<og:description>在Java中有两类线程，分别是User Thread（用户线程）和Daemon Thread（守护线程） 。 用户线程很好理解，我们日常开发中编写的业务逻辑代码，运行起来都是一个个用户线程。而守护线程</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yanggb/p/11702843.html</dc:identifier>
</item>
<item>
<title>2. SOFAJRaft源码分析—JRaft的定时任务调度器是怎么做的？ - luozhiyun</title>
<link>http://www.cnblogs.com/luozhiyun/p/11706171.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/luozhiyun/p/11706171.html</guid>
<description>&lt;p&gt;看完这个实现之后，感觉还是要多看源码，多研究。其实JRaft的定时任务调度器是基于Netty的时间轮来做的，如果没有看过Netty的源码，很可能并不知道时间轮算法，也就很难想到要去使用这么优秀的定时调度算法了。&lt;/p&gt;
&lt;p&gt;对于介绍RepeatedTimer，我拿Node初始化的时候的electionTimer进行讲解&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;this.electionTimer = new RepeatedTimer(&quot;JRaft-ElectionTimer&quot;, this.options.getElectionTimeoutMs()) {

    @Override
    protected void onTrigger() {
        handleElectionTimeout();
    }

    @Override
    protected int adjustTimeout(final int timeoutMs) {
        //在一定范围内返回一个随机的时间戳
        //为了避免同时发起选举而导致失败
        return randomTimeout(timeoutMs);
    }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;构造器&quot;&gt;构造器&lt;/h3&gt;
&lt;p&gt;由electionTimer的构造方法可以看出RepeatedTimer需要传入两个参数，一个是name，另一个是time&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//timer是HashedWheelTimer
private final Timer        timer;
//实例是HashedWheelTimeout
private Timeout            timeout;

public RepeatedTimer(String name, int timeoutMs) {
    //name代表RepeatedTimer实例的种类，timeoutMs是超时时间
    this(name, timeoutMs, new HashedWheelTimer(new NamedThreadFactory(name, true), 1, TimeUnit.MILLISECONDS, 2048));
}

public RepeatedTimer(String name, int timeoutMs, Timer timer) {
    super();
    this.name = name;
    this.timeoutMs = timeoutMs;
    this.stopped = true;
    this.timer = Requires.requireNonNull(timer, &quot;timer&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在构造器中会根据传进来的值初始化一个name和一个timeoutMs，然后实例化一个timer，RepeatedTimer的run方法是由timer进行回调。在RepeatedTimer中会持有两个对象，一个是timer，一个是timeout&lt;/p&gt;
&lt;h3 id=&quot;启动repeatedtimer&quot;&gt;启动RepeatedTimer&lt;/h3&gt;
&lt;p&gt;对于一个RepeatedTimer实例，我们可以通过start方法来启动它：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void start() {
    //加锁，只能一个线程调用这个方法
    this.lock.lock();
    try {
        //destroyed默认是false
        if (this.destroyed) {
            return;
        }
        //stopped在构造器中初始化为ture
        if (!this.stopped) {
            return;
        }
        //启动完一次后下次就无法再次往下继续
        this.stopped = false;
        //running默认为false
        if (this.running) {
            return;
        }
        this.running = true;
        schedule();
    } finally {
        this.lock.unlock();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在调用start方法进行启动后会进行一系列的校验和赋值，从上面的赋值以及加锁的情况来看，这个是只能被调用一次的。然后会调用到schedule方法中&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private void schedule() {
    if(this.timeout != null) {
        this.timeout.cancel();
    }
    final TimerTask timerTask = timeout -&amp;gt; {
        try {
            RepeatedTimer.this.run();
        } catch (final Throwable t) {
            LOG.error(&quot;Run timer task failed, taskName={}.&quot;, RepeatedTimer.this.name, t);
        }
    };
    this.timeout = this.timer.newTimeout(timerTask, adjustTimeout(this.timeoutMs), TimeUnit.MILLISECONDS);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果timeout不为空，那么会调用HashedWheelTimeout的cancel方法。然后封装一个TimerTask实例，当执行TimerTask的run方法的时候会调用RepeatedTimer实例的run方法。然后传入到timer中，TimerTask的run方法由timer进行调用，并将返回值赋值给timeout。&lt;/p&gt;
&lt;p&gt;如果timer调用了TimerTask的run方法，那么便会回调到RepeatedTimer的run方法中：&lt;br/&gt;&lt;strong&gt;RepeatedTimer#run&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void run() {
    //加锁
    this.lock.lock();
    try {
        //表示RepeatedTimer已经被调用过
        this.invoking = true;
    } finally {
        this.lock.unlock();
    }
    try {
        //然后会调用RepeatedTimer实例实现的方法
        onTrigger();
    } catch (final Throwable t) {
        LOG.error(&quot;Run timer failed.&quot;, t);
    }
    boolean invokeDestroyed = false;
    this.lock.lock();
    try {
        this.invoking = false;
        //如果调用了stop方法，那么将不会继续调用schedule方法
        if (this.stopped) {
            this.running = false;
            invokeDestroyed = this.destroyed;
        } else {
            this.timeout = null;
            schedule();
        }
    } finally {
        this.lock.unlock();
    }
    if (invokeDestroyed) {
        onDestroy();
    }
}

protected void onDestroy() {
    // NO-OP
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个run方法会由timer进行回调，如果没有调用stop或destroy方法的话，那么调用完onTrigger方法后会继续调用schedule，然后一次次循环调用RepeatedTimer的run方法。&lt;/p&gt;
&lt;p&gt;如果调用了destroy方法，在这里会有一个onDestroy的方法，可以由实现类override复写执行一个钩子。&lt;/p&gt;
&lt;h3 id=&quot;hashedwheeltimer的基本介绍&quot;&gt;HashedWheelTimer的基本介绍&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204119/201910/1204119-20191019224829947-219091505.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;HashedWheelTimer通过一定的hash规则将不同timeout的定时任务划分到HashedWheelBucket进行管理，而HashedWheelBucket利用双向链表结构维护了某一时刻需要执行的定时任务列表&lt;/p&gt;
&lt;h4 id=&quot;wheel&quot;&gt;Wheel&lt;/h4&gt;
&lt;p&gt;时间轮，是一个HashedWheelBucket数组，数组数量越多，定时任务管理的时间精度越精确。tick每走一格都会将对应的wheel数组里面的bucket拿出来进行调度。&lt;/p&gt;
&lt;h4 id=&quot;worker&quot;&gt;Worker&lt;/h4&gt;
&lt;p&gt;Worker继承自Runnable，HashedWheelTimer必须通过Worker线程操作HashedWheelTimer中的定时任务。Worker是整个HashedWheelTimer的执行流程管理者，控制了定时任务分配、全局deadline时间计算、管理未执行的定时任务、时钟计算、未执行定时任务回收处理。&lt;/p&gt;
&lt;h4 id=&quot;hashedwheeltimeout&quot;&gt;HashedWheelTimeout&lt;/h4&gt;
&lt;p&gt;是HashedWheelTimer的执行单位，维护了其所属的HashedWheelTimer和HashedWheelBucket的引用、需要执行的任务逻辑、当前轮次以及当前任务的超时时间(不变)等，可以认为是自定义任务的一层Wrapper。&lt;/p&gt;
&lt;h4 id=&quot;hashedwheelbucket&quot;&gt;HashedWheelBucket&lt;/h4&gt;
&lt;p&gt;HashedWheelBucket维护了hash到其内的所有HashedWheelTimeout结构，是一个双向队列。&lt;/p&gt;
&lt;h3 id=&quot;hashedwheeltimer的构造器&quot;&gt;HashedWheelTimer的构造器&lt;/h3&gt;
&lt;p&gt;在初始化RepeatedTimer实例的时候会实例化一个HashedWheelTimer：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;new HashedWheelTimer(new NamedThreadFactory(name, true), 1, TimeUnit.MILLISECONDS, 2048)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后调用HashedWheelTimer的构造器：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; 
private final HashedWheelBucket[]  wheel;
private final int  mask;
private final long  tickDuration;
private final Worker  worker    = new Worker();
private final Thread   workerThread;
private final long  maxPendingTimeouts;
private static final int  INSTANCE_COUNT_LIMIT   = 256;
private static final AtomicInteger instanceCounter        = new AtomicInteger();
private static final AtomicBoolean warnedTooManyInstances = new AtomicBoolean();


public HashedWheelTimer(ThreadFactory threadFactory, long tickDuration, TimeUnit unit, int ticksPerWheel) {
        tickDuration
    this(threadFactory, tickDuration, unit, ticksPerWheel, -1);
}

public HashedWheelTimer(ThreadFactory threadFactory, long tickDuration, TimeUnit unit, int ticksPerWheel,
                        long maxPendingTimeouts) {

    if (threadFactory == null) {
        throw new NullPointerException(&quot;threadFactory&quot;);
    }
    //unit = MILLISECONDS
    if (unit == null) {
        throw new NullPointerException(&quot;unit&quot;);
    }
    if (tickDuration &amp;lt;= 0) {
        throw new IllegalArgumentException(&quot;tickDuration must be greater than 0: &quot; + tickDuration);
    }
    if (ticksPerWheel &amp;lt;= 0) {
        throw new IllegalArgumentException(&quot;ticksPerWheel must be greater than 0: &quot; + ticksPerWheel);
    }

    // Normalize ticksPerWheel to power of two and initialize the wheel.
    // 创建一个HashedWheelBucket数组
    // 创建时间轮基本的数据结构，一个数组。长度为不小于ticksPerWheel的最小2的n次方
    wheel = createWheel(ticksPerWheel);
    // 这是一个标示符，用来快速计算任务应该呆的格子。
    // 我们知道，给定一个deadline的定时任务，其应该呆的格子=deadline%wheel.length.但是%操作是个相对耗时的操作，所以使用一种变通的位运算代替：
    // 因为一圈的长度为2的n次方，mask = 2^n-1后低位将全部是1，然后deadline&amp;amp;mast == deadline%wheel.length
    // java中的HashMap在进行hash之后，进行index的hash寻址寻址的算法也是和这个一样的
    mask = wheel.length - 1;

    // Convert tickDuration to nanos.
    //tickDuration传入是1的话，这里会转换成1000000
    this.tickDuration = unit.toNanos(tickDuration);

    // Prevent overflow.
    // 校验是否存在溢出。即指针转动的时间间隔不能太长而导致tickDuration*wheel.length&amp;gt;Long.MAX_VALUE
    if (this.tickDuration &amp;gt;= Long.MAX_VALUE / wheel.length) {
        throw new IllegalArgumentException(String.format(
            &quot;tickDuration: %d (expected: 0 &amp;lt; tickDuration in nanos &amp;lt; %d&quot;, tickDuration, Long.MAX_VALUE
                                                                                        / wheel.length));
    }
    //将worker包装成thread
    workerThread = threadFactory.newThread(worker);
    //maxPendingTimeouts = -1
    this.maxPendingTimeouts = maxPendingTimeouts;

    //如果HashedWheelTimer实例太多，那么就会打印一个error日志
    if (instanceCounter.incrementAndGet() &amp;gt; INSTANCE_COUNT_LIMIT
        &amp;amp;&amp;amp; warnedTooManyInstances.compareAndSet(false, true)) {
        reportTooManyInstances();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个构造器里面主要做一些初始化的工作。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;初始化一个wheel数据，我们这里初始化的数组长度为2048.&lt;/li&gt;
&lt;li&gt;初始化mask，用来计算槽位的下标，类似于hashmap的槽位的算法，因为wheel的长度已经是一个2的n次方，所以2^n-1后低位将全部是1，用&amp;amp;可以快速的定位槽位，比%耗时更低&lt;/li&gt;
&lt;li&gt;初始化tickDuration，这里会将传入的tickDuration转化成纳秒，那么这里是1000，000&lt;/li&gt;
&lt;li&gt;校验整个时间轮走完的时间不能过长&lt;/li&gt;
&lt;li&gt;包装worker线程&lt;/li&gt;
&lt;li&gt;因为HashedWheelTimer是一个很消耗资源的一个结构，所以校验HashedWheelTimer实例不能太多，如果太多会打印error日志&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;启动timer&quot;&gt;启动timer&lt;/h3&gt;
&lt;p&gt;时间轮算法中并不需要手动的去调用start方法来启动，而是在添加节点的时候会启动时间轮。&lt;/p&gt;
&lt;p&gt;我们在RepeatedTimer的schedule方法里会调用newTimeout向时间轮中添加一个任务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HashedWheelTimer#newTimeout&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public Timeout newTimeout(TimerTask task, long delay, TimeUnit unit) {
    if (task == null) {
        throw new NullPointerException(&quot;task&quot;);
    }
    if (unit == null) {
        throw new NullPointerException(&quot;unit&quot;);
    }

    long pendingTimeoutsCount = pendingTimeouts.incrementAndGet();

    if (maxPendingTimeouts &amp;gt; 0 &amp;amp;&amp;amp; pendingTimeoutsCount &amp;gt; maxPendingTimeouts) {
        pendingTimeouts.decrementAndGet();
        throw new RejectedExecutionException(&quot;Number of pending timeouts (&quot; + pendingTimeoutsCount
                                             + &quot;) is greater than or equal to maximum allowed pending &quot;
                                             + &quot;timeouts (&quot; + maxPendingTimeouts + &quot;)&quot;);
    }
    // 如果时间轮没有启动，则启动
    start();

    // Add the timeout to the timeout queue which will be processed on the next tick.
    // During processing all the queued HashedWheelTimeouts will be added to the correct HashedWheelBucket.
    long deadline = System.nanoTime() + unit.toNanos(delay) - startTime;

    // Guard against overflow.
    //在delay为正数的情况下，deadline是不可能为负数
    //如果为负数，那么说明超过了long的最大值
    if (delay &amp;gt; 0 &amp;amp;&amp;amp; deadline &amp;lt; 0) {
        deadline = Long.MAX_VALUE;
    }
    // 这里定时任务不是直接加到对应的格子中，而是先加入到一个队列里，然后等到下一个tick的时候，
    // 会从队列里取出最多100000个任务加入到指定的格子中
    HashedWheelTimeout timeout = new HashedWheelTimeout(this, task, deadline);
    //Worker会去处理timeouts队列里面的数据
    timeouts.add(timeout);
    return timeout;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这个方法中，在校验之后会调用start方法启动时间轮，然后设置deadline，这个时间等于时间轮启动的时间点+延迟的的时间；&lt;br/&gt;然后新建一个HashedWheelTimeout实例，会直接加入到timeouts队列中去，timeouts对列会在worker的run方法里面取出来放入到wheel中进行处理。&lt;/p&gt;
&lt;p&gt;然后我们来看看start方法：&lt;br/&gt;&lt;strong&gt;HashedWheelTimer#start&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
private static final AtomicIntegerFieldUpdater&amp;lt;HashedWheelTimer&amp;gt; workerStateUpdater     = AtomicIntegerFieldUpdater.newUpdater(HashedWheelTimer.class,&quot;workerState&quot;);

private volatile int  workerState; 
//不需要你主动调用，当有任务添加进来的的时候他就会跑
public void start() {
    //workerState一开始的时候是0（WORKER_STATE_INIT），然后才会设置为1（WORKER_STATE_STARTED）
    switch (workerStateUpdater.get(this)) {
        case WORKER_STATE_INIT:
            //使用cas来获取启动调度的权力，只有竞争到的线程允许来进行实例启动
            if (workerStateUpdater.compareAndSet(this, WORKER_STATE_INIT, WORKER_STATE_STARTED)) {
                //如果成功设置了workerState，那么就调用workerThread线程
                workerThread.start();
            }
            break;
        case WORKER_STATE_STARTED:
            break;
        case WORKER_STATE_SHUTDOWN:
            throw new IllegalStateException(&quot;cannot be started once stopped&quot;);
        default:
            throw new Error(&quot;Invalid WorkerState&quot;);
    }

    // 等待worker线程初始化时间轮的启动时间
    // Wait until the startTime is initialized by the worker.
    while (startTime == 0) {
        try {
            //这里使用countDownLauch来确保调度的线程已经被启动
            startTimeInitialized.await();
        } catch (InterruptedException ignore) {
            // Ignore - it will be ready very soon.
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由这里我们可以看出，启动时间轮是不需要手动去调用的，而是在有任务的时候会自动运行，防止在没有任务的时候空转浪费资源。&lt;/p&gt;
&lt;p&gt;在start方法里面会使用AtomicIntegerFieldUpdater的方式来更新workerState这个变量，如果没有启动过那么直接在cas成功之后调用start方法启动workerThread线程。&lt;/p&gt;
&lt;p&gt;如果workerThread还没运行，那么会在while循环中等待，直到workerThread运行为止才会往下运行。&lt;/p&gt;
&lt;h3 id=&quot;开始时间轮转&quot;&gt;开始时间轮转&lt;/h3&gt;
&lt;p&gt;时间轮的运转是在Worker的run方法中进行的：&lt;br/&gt;&lt;strong&gt;Worker#run&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private final Set&amp;lt;Timeout&amp;gt; unprocessedTimeouts = new HashSet&amp;lt;&amp;gt;();
private long               tick;
public void run() {
    // Initialize the startTime.
    startTime = System.nanoTime();
    if (startTime == 0) {
        // We use 0 as an indicator for the uninitialized value here, so make sure it's not 0 when initialized.
        startTime = 1;
    }

    //HashedWheelTimer的start方法会继续往下运行
    // Notify the other threads waiting for the initialization at start().
    startTimeInitialized.countDown();

    do {
        //返回的是当前的nanoTime- startTime
        //也就是返回的是 每 tick 一次的时间间隔
        final long deadline = waitForNextTick();
        if (deadline &amp;gt; 0) {
            //算出时间轮的槽位
            int idx = (int) (tick &amp;amp; mask);
            //移除cancelledTimeouts中的bucket
            // 从bucket中移除timeout
            processCancelledTasks();
            HashedWheelBucket bucket = wheel[idx];
            // 将newTimeout()方法中加入到待处理定时任务队列中的任务加入到指定的格子中
            transferTimeoutsToBuckets();
            bucket.expireTimeouts(deadline);
            tick++;
        }
    //    校验如果workerState是started状态，那么就一直循环
    } while (workerStateUpdater.get(HashedWheelTimer.this) == WORKER_STATE_STARTED);

    // Fill the unprocessedTimeouts so we can return them from stop() method.
    for (HashedWheelBucket bucket : wheel) {
        bucket.clearTimeouts(unprocessedTimeouts);
    }
    for (;;) {
        HashedWheelTimeout timeout = timeouts.poll();
        if (timeout == null) {
            break;
        }
        //如果有没有被处理的timeout，那么加入到unprocessedTimeouts对列中
        if (!timeout.isCancelled()) {
            unprocessedTimeouts.add(timeout);
        }
    }
    //处理被取消的任务
    processCancelledTasks();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;这个方法首先会设置一个时间轮的开始时间startTime，然后调用startTimeInitialized的countDown让被阻塞的线程往下运行&lt;/li&gt;
&lt;li&gt;调用waitForNextTick等待到下次tick的到来，并返回当次的tick时间-startTime&lt;/li&gt;
&lt;li&gt;通过&amp;amp;的方式获取时间轮的槽位&lt;/li&gt;
&lt;li&gt;移除掉被取消的task&lt;/li&gt;
&lt;li&gt;将timeouts中的任务转移到对应的wheel槽位中，如果槽位中不止一个bucket，那么串成一个链表&lt;/li&gt;
&lt;li&gt;执行格子中的到期任务&lt;/li&gt;
&lt;li&gt;遍历整个wheel，将过期的bucket放入到unprocessedTimeouts队列中&lt;/li&gt;
&lt;li&gt;将timeouts中过期的bucket放入到unprocessedTimeouts队列中&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;上面所有的过期但未被处理的bucket会在调用stop方法的时候返回unprocessedTimeouts队列中的数据。所以unprocessedTimeouts中的数据只是做一个记录，并不会再次被执行。&lt;/p&gt;
&lt;p&gt;时间轮的所有处理过程都在do-while循环中被处理，我们下面一个个分析&lt;/p&gt;
&lt;h4 id=&quot;处理被取消的任务&quot;&gt;处理被取消的任务&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Worker#processCancelledTasks&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private void processCancelledTasks() {
    for (;;) {
        HashedWheelTimeout timeout = cancelledTimeouts.poll();
        if (timeout == null) {
            // all processed
            break;
        }
        try {
            timeout.remove();
        } catch (Throwable t) {
            if (LOG.isWarnEnabled()) {
                LOG.warn(&quot;An exception was thrown while process a cancellation task&quot;, t);
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个方法相当的简单，因为在调用HashedWheelTimer的stop方法的时候会将要取消的HashedWheelTimeout实例放入到cancelledTimeouts队列中，所以这里只需要循环把队列中的数据取出来，然后调用HashedWheelTimeout的remove方法将自己在bucket移除就好了&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HashedWheelTimeout#remove&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;void remove() {
    HashedWheelBucket bucket = this.bucket;
    if (bucket != null) {
          //这里面涉及到链表的引用摘除，十分清晰易懂，想了解的可以去看看
        bucket.remove(this);
    } else {
        timer.pendingTimeouts.decrementAndGet();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;转移数据到时间轮中&quot;&gt;转移数据到时间轮中&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Worker#transferTimeoutsToBuckets&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private void transferTimeoutsToBuckets() {
    // transfer only max. 100000 timeouts per tick to prevent a thread to stale the workerThread when it just
    // adds new timeouts in a loop.
    // 每次tick只处理10w个任务，以免阻塞worker线程
    for (int i = 0; i &amp;lt; 100000; i++) {
        HashedWheelTimeout timeout = timeouts.poll();
        if (timeout == null) {
            // all processed
            break;
        }
        //已经被取消了；
        if (timeout.state() == HashedWheelTimeout.ST_CANCELLED) {
            // Was cancelled in the meantime.
            continue;
        }
        //calculated = tick 次数
        long calculated = timeout.deadline / tickDuration;
        // 计算剩余的轮数, 只有 timer 走够轮数, 并且到达了 task 所在的 slot, task 才会过期
        timeout.remainingRounds = (calculated - tick) / wheel.length;
        //如果任务在timeouts队列里面放久了, 以至于已经过了执行时间, 这个时候就使用当前tick, 也就是放到当前bucket, 此方法调用完后就会被执行
        final long ticks = Math.max(calculated, tick); // Ensure we don't schedule for past.
        //// 算出任务应该插入的 wheel 的 slot, slotIndex = tick 次数 &amp;amp; mask, mask = wheel.length - 1
        int stopIndex = (int) (ticks &amp;amp; mask);

        HashedWheelBucket bucket = wheel[stopIndex];
        //将timeout加入到bucket链表中
        bucket.addTimeout(timeout);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;每次调用这个方法会处理10w个任务，以免阻塞worker线程&lt;/li&gt;
&lt;li&gt;在校验之后会用timeout的deadline除以每次tick运行的时间tickDuration得出需要tick多少次才会运行这个timeout的任务&lt;/li&gt;
&lt;li&gt;由于timeout的deadline实际上还包含了worker线程启动到timeout加入队列这段时间，所以在算remainingRounds的时候需要减去当前的tick次数&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;        |_____________________|____________
 worker启动时间          timeout任务加入时间
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;最后根据计算出来的ticks来&amp;amp;算出wheel的槽位，加入到bucket链表中&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;执行到期任务&quot;&gt;执行到期任务&lt;/h4&gt;
&lt;p&gt;在worker的run方法的do-while循环中，在根据当前的tick拿到wheel中的bucket后会调用expireTimeouts方法来处理这个bucket的到期任务&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HashedWheelBucket#expireTimeouts&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 过期并执行格子中的到期任务，tick到该格子的时候，worker线程会调用这个方法，
//根据deadline和remainingRounds判断任务是否过期
public void expireTimeouts(long deadline) {
    HashedWheelTimeout timeout = head;

    // process all timeouts
    //遍历格子中的所有定时任务
    while (timeout != null) {
        // 先保存next，因为移除后next将被设置为null
        HashedWheelTimeout next = timeout.next;
        if (timeout.remainingRounds &amp;lt;= 0) {
            //从bucket链表中移除当前timeout，并返回链表中下一个timeout
            next = remove(timeout);
            //如果timeout的时间小于当前的时间，那么就调用expire执行task
            if (timeout.deadline &amp;lt;= deadline) {
                timeout.expire();
            } else {
                //不可能发生的情况，就是说round已经为0了，deadline却&amp;gt;当前槽的deadline
                // The timeout was placed into a wrong slot. This should never happen.
                throw new IllegalStateException(String.format(&quot;timeout.deadline (%d) &amp;gt; deadline (%d)&quot;,
                        timeout.deadline, deadline));
            }
        } else if (timeout.isCancelled()) {
            next = remove(timeout);
        } else {
            //因为当前的槽位已经过了，说明已经走了一圈了，把轮数减一
            timeout.remainingRounds--;
        }
        //把指针放置到下一个timeout
        timeout = next;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;expireTimeouts方法会根据当前tick到的槽位，然后获取槽位中的bucket并找到链表中到期的timeout并执行&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;因为每一次的指针都会指向bucket中的下一个timeout，所以timeout为空时说明整个链表已经遍历完毕，所以用while循环做非空校验&lt;/li&gt;
&lt;li&gt;因为没一次循环都会把当前的轮数大于零的做减一处理，所以当轮数小于或等于零的时候就需要把当前的timeout移除bucket链表&lt;/li&gt;
&lt;li&gt;在校验deadline之后执行expire方法，这里会真正进行任务调用&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;HashedWheelTimeout#task&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void expire() {
    if (!compareAndSetState(ST_INIT, ST_EXPIRED)) {
        return;
    }

    try {
        task.run(this);
    } catch (Throwable t) {
        if (LOG.isWarnEnabled()) {
            LOG.warn(&quot;An exception was thrown by &quot; + TimerTask.class.getSimpleName() + '.', t);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里这个task就是在schedule方法中构建的timerTask实例，调用timerTask的run方法会调用到外层的RepeatedTimer的run方法，从而调用到RepeatedTimer子类实现的onTrigger方法。&lt;/p&gt;
&lt;p&gt;到这里Jraft的定时调度就讲完了，感觉还是很有意思的。&lt;/p&gt;
</description>
<pubDate>Sat, 19 Oct 2019 14:49:00 +0000</pubDate>
<dc:creator>luozhiyun</dc:creator>
<og:description>看完这个实现之后，感觉还是要多看源码，多研究。其实JRaft的定时任务调度器是基于Netty的时间轮来做的，如果没有看过Netty的源码，很可能并不知道时间轮算法，也就很难想到要去使用这么优秀的定时调</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/luozhiyun/p/11706171.html</dc:identifier>
</item>
<item>
<title>计算机图形学——裁剪 - 王陸</title>
<link>http://www.cnblogs.com/wkfvawl/p/11705842.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wkfvawl/p/11705842.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;裁剪作用：&lt;/strong&gt;&lt;br/&gt;选择显示的内容--图形在窗口内的部分被显示出来，窗口外的部分被裁剪掉&lt;br/&gt; 图形中每个图形基本元素都要经过裁剪，因此裁剪直接影响整个图形系统的效率。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;裁剪窗口：&lt;/span&gt;&lt;/strong&gt;矩形，凸多边形，任意多边形&lt;br/&gt;&lt;strong&gt;&lt;span&gt;裁剪类型：&lt;/span&gt;&lt;/strong&gt;二维裁剪、三维裁剪&lt;br/&gt;&lt;strong&gt;&lt;span&gt;裁剪对象：&lt;/span&gt;&lt;/strong&gt;直线段、多边形、文字等&lt;br/&gt;裁剪方法:&lt;br/&gt;直线的裁剪方法: &lt;strong&gt;&lt;span&gt;Sutherland-Cohen算法 , Cyrus-Beck算法,梁友栋-Barsky算法&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;多边形的裁剪方法:&lt;strong&gt;&lt;span&gt;Sutherland-Hodgman算法&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;三维的裁剪方法: &lt;strong&gt;&lt;span&gt;Sutherland-Cohen算法 ,梁友栋-Barsky算法&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt; &lt;/p&gt;
&lt;h2&gt;一、Sutherland-Cohen算法&lt;/h2&gt;
&lt;p&gt;本算法又称为编码裁剪算法&lt;/p&gt;
&lt;p&gt;Sutherland–Cohen算法分成两部分：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1358881/201910/1358881-20191019183400730-147486163.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;第一步，判定：&lt;br/&gt;1) 完全在窗口内的直线段，称为完全可见的线段，如AB。保留着&lt;br/&gt;2) 完全在窗口外的线段，称为完全不可见线段，如CD。抛弃掉&lt;/p&gt;
&lt;p&gt;第二步，处理不能断定为完全可见或完全不可见的线段，如IJ、KL&lt;br/&gt;*这时需要计算出&lt;strong&gt;&lt;span&gt;直线段和窗口边界的一个交点&lt;/span&gt;&lt;/strong&gt;，这个交点把直线分成两段，其中一条为完全不可见的线段,被抛弃。&lt;br/&gt;*对余下部分再作第一步的判断，重复上述过程，直到直线段余下的部分可用第一步的判断得出肯定的结论为止。&lt;/p&gt;
&lt;h3&gt;1、判断完全可见/不可见的线段&lt;/h3&gt;
&lt;p&gt;为使计算机能够快速判断一条直线段与窗口属何种关系，采用如下&lt;strong&gt;&lt;span&gt;编码方法&lt;/span&gt;&lt;/strong&gt;。窗口的四条边把整个平面分成&lt;strong&gt;&lt;span&gt;九个区域&lt;/span&gt;&lt;/strong&gt;，每一个区域采用&lt;strong&gt;&lt;span&gt;四位编码&lt;/span&gt;&lt;/strong&gt;表示：&lt;/p&gt;
&lt;p&gt;在x=xL左侧的区域,编码的第四位是1；&lt;br/&gt;在x=xR右侧的区域,编码的第三位是1；&lt;br/&gt;在y=yB下侧的区域,编码的第二位是1；&lt;br/&gt;在y=yT上侧的区域,编码的第一位是1。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1358881/201910/1358881-20191019183645948-456762266.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;如何判断？&lt;br/&gt;对要被裁剪的线段的两个端点进行区域编码。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;如果其所在的区域的编码均是0000（相与），则这条线段完全可见；&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;如果两个编码的逻辑与不为0000，则这条线段完全不可见&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;2、处理不能断定为完全可见或完全不可见的线段&lt;/h3&gt;
&lt;p&gt;线段KL为例，从K点(1001)的编码分析出K在x=xL的左侧，KL必和x=xL有交点，求出其交点M，KM显然是完全不可见的，因而只要对ML从第一步开始重复上述处理步骤。&lt;br/&gt;由于ML还是不能用第一步下结论，又从M的编码发现M在y=yT的上侧，因而要求ML和y=yT的交点N。&lt;/p&gt;
&lt;p&gt;丢掉MN，对NL用第一步的方法可断定NL为完全可见，至此裁剪结束。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1358881/201910/1358881-20191019184007482-122875773.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;3、程序代码&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
&lt;span&gt;float&lt;span&gt; xl, xr, yt, yb;
unsigned &lt;span&gt;char code(&lt;span&gt;float x, &lt;span&gt;float&lt;span&gt; y)
{
    unsigned &lt;span&gt;char c = 0&lt;span&gt;;
    &lt;span&gt;if (x &amp;lt;&lt;span&gt; xl)
        c = c|1;  &lt;span&gt;//&lt;span&gt;按位或
    &lt;span&gt;else &lt;span&gt;if (x &amp;gt;&lt;span&gt; xr)
        c = c|2&lt;span&gt;;
    &lt;span&gt;if (y &amp;lt;&lt;span&gt; yb)
        c = c|4&lt;span&gt;;
    &lt;span&gt;else &lt;span&gt;if (y &amp;gt;&lt;span&gt; yt)
        c = c|8&lt;span&gt;;
    &lt;span&gt;return&lt;span&gt; c;
}&lt;span&gt;//&lt;span&gt;给九个区域编码
&lt;span&gt; 
&lt;span&gt;void clip(&lt;span&gt;float x0, &lt;span&gt;float y0, &lt;span&gt;float x2, &lt;span&gt;float&lt;span&gt; y2)
{
    unsigned &lt;span&gt;char&lt;span&gt; c1, c2, c;
    &lt;span&gt;float&lt;span&gt; x, y, wx, wy;
    c1 =&lt;span&gt; code(x0, y0);
    c2 =&lt;span&gt; code(x2, y2);
    &lt;span&gt;while ((!(c1 == 0)) || (!(c2 == 0&lt;span&gt;)))
    {
        &lt;span&gt;if ((c1&amp;amp;&lt;span&gt; c2))
            &lt;span&gt;return; &lt;span&gt;//&lt;span&gt;两端点逻辑与不为0，则在区域外，裁去
        c =&lt;span&gt; c1;
        &lt;span&gt;if (c == 0&lt;span&gt;)
            c =&lt;span&gt; c2;
        wx=x2-&lt;span&gt;x0;
        wy=y2-&lt;span&gt;y0;
        &lt;span&gt;if ((c &amp;amp; 1) == 1&lt;span&gt;)
        {
            y = y0 + wy * (xl - x0) /&lt;span&gt;wx;
            x =&lt;span&gt; xl;
        }&lt;span&gt;//&lt;span&gt;端点在xl左侧，求与xl的交点

        &lt;span&gt;else &lt;span&gt;if ((c &amp;amp; 2) == 2&lt;span&gt;)
        {
            y = y0 +wy * (xr - x0) /&lt;span&gt;wx;
            x =&lt;span&gt; xr;
        } &lt;span&gt;//&lt;span&gt;端点在xr右侧，求与xr的交点

        &lt;span&gt;else &lt;span&gt;if ((c &amp;amp; 4) == 4&lt;span&gt;)
        {
            x = x0 +wx * (yb - y0) /&lt;span&gt;wy;
            y =&lt;span&gt; yb;
        } &lt;span&gt;//&lt;span&gt;端点在yb下方，求与yb的交点

        &lt;span&gt;else &lt;span&gt;if ((c &amp;amp; 8) == 8&lt;span&gt;)
        {
            x = x0 +wx * (yt - y0) /&lt;span&gt; wy;
            y =&lt;span&gt; yt;
        } &lt;span&gt;//&lt;span&gt;端点在yt上方，求与yt的交点

        &lt;span&gt;if (c ==&lt;span&gt; c1)
        {
            x0 =&lt;span&gt; x;
            y0 =&lt;span&gt; y;
            c1 =&lt;span&gt; code(x0, y0);
        }
        &lt;span&gt;else&lt;span&gt;
        {
            x2 =&lt;span&gt; x;
            y2 =&lt;span&gt; y;
            c2 =&lt;span&gt; code(x2, y2);
        } &lt;span&gt;//&lt;span&gt;用交点代替端点，再返回第一步
    }&lt;span&gt;//&lt;span&gt; While()
    glLine(&lt;span&gt;int(x0), &lt;span&gt;int(y0), &lt;span&gt;int(x2), &lt;span&gt;int&lt;span&gt;(y2));
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;4、小结&lt;/h3&gt;
&lt;p&gt;Cohen-Sutherland裁剪算法对不与边框相交的线段进行裁剪时效率较高,而对与窗口边界有交点的线段裁剪效率低。&lt;/p&gt;
&lt;p&gt;因而比较适合两种情况的裁剪：&lt;strong&gt;&lt;span&gt;一是大部分线段完全可见；二是大部分线段完全不可见。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;而且很多的时候,被裁剪线段仅与窗口边界延长线相交,求交点到最后是无效的操作,因为线段可能完全被丢弃;并且被裁剪线段与窗口边界相交时交点的取得比较复杂。&lt;/p&gt;
&lt;p&gt;比如像下图这样的裁剪，这条&lt;strong&gt;&lt;span&gt;红色线段&lt;/span&gt;&lt;/strong&gt;完全是在裁剪窗口的外部，却需要进行算法计算，最后线段完全被丢弃！&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1358881/201910/1358881-20191019184625787-983519052.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;二、中点分隔算法&lt;/h2&gt;
&lt;p&gt;中点分隔算法是对Sutherland-Cohen算法在求交点方面的改进。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;核心思想是通过二分逼近来确定直线段与 窗口的交点。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;取线段的中点&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1、若中点不在窗口内， 则把中点和离窗口边界最远点构成的线段丢掉，以线段上的另一点和该中点再构成线段求其中点&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1358881/201910/1358881-20191019185609029-738674097.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2、如中点在窗口内，则又以中点和最远点构成线段， 并求其中点，直到中点与窗口边界的 坐标值在规定的误差范围内相等&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1483999/201810/1483999-20181018225555035-92071122.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;重复上述过程，直到线段长度小于给定的小数ε为止。&lt;br/&gt;在显示时ε可取成一个象素的宽度，&lt;strong&gt;&lt;span&gt;对分辨率为2&lt;sup&gt;N&lt;/sup&gt;×2&lt;sup&gt;N&lt;/sup&gt;的显示器来说，上面讲的二分的过程最多只要作N次&lt;/span&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;h2&gt;三、Cyrus-Beck算法&lt;/h2&gt;
&lt;p&gt;Cyrus-Beck算法可以处理任意凸多边形对线段的裁剪。&lt;/p&gt;
&lt;h3&gt;1、裁剪目标&lt;/h3&gt;
&lt;p&gt;考虑如图所示一个凸多边形区域R和一条线段P1P2，要求计算线段落在区域R中的部分。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1358881/201910/1358881-20191019191819652-1604872668.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;2、线段表示&lt;/h3&gt;
&lt;p&gt;假定A是区域R边界L上一点；N是区域边界在A点的内法向量；线段P1P2用参数方程表示：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1358881/201910/1358881-20191019191800257-1681406535.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3、基本思想&lt;/h3&gt;
&lt;p&gt;对于线段P1P2的参数方程表示，如果能判断出线段进入多边形时候的参数ts和线段退出多边形时的参数te，则tste之间的线段为裁剪完毕后的结果。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1358881/201910/1358881-20191019192001106-250564527.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;4、判定线段上的点和多边形的关系&lt;/h3&gt;
&lt;p&gt;&lt;br/&gt;假定A为区域边界L上的任意一点，记L的内法向量（垂直）为N对于线段上任意一点 Pi， Pi和多边形边界L的关系有三种可能(t 为此点的参数值)：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1358881/201910/1358881-20191019192504202-43852595.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1358881/201910/1358881-20191019192440434-792563207.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1358881/201910/1358881-20191019193924516-615515864.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;&lt;span&gt;性质（1）: 如果点P(t)在多边形所有边的内侧，则称P是在多边形的内侧。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;可见线段的参数区间&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1358881/201910/1358881-20191019194206650-2034410465.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1358881/201910/1358881-20191019194805880-637455598.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1358881/201910/1358881-20191019194957986-1363262986.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1358881/201910/1358881-20191019195031853-1287314542.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;5、编程思路&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1358881/201910/1358881-20191019195416533-553483433.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;6、程序代码&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;double&lt;span&gt; ts,te;
&lt;span&gt;int Cyrus_Beck (&lt;span&gt;int k,&lt;span&gt;double A[][&lt;span&gt;2],&lt;span&gt;double N[][&lt;span&gt;2],&lt;span&gt;double x[&lt;span&gt;2],&lt;span&gt;double y[&lt;span&gt;2],&lt;span&gt;double *ts,&lt;span&gt;double *&lt;span&gt;te)
{
    &lt;span&gt;int&lt;span&gt; i,j;
    &lt;span&gt;double t,dn,nw,D[&lt;span&gt;2],W[&lt;span&gt;2&lt;span&gt;];
    *ts=&lt;span&gt;0&lt;span&gt;;
    *te=&lt;span&gt;1&lt;span&gt;;
    &lt;span&gt;for(i=&lt;span&gt;0; i&amp;lt;k; i++&lt;span&gt;)
    {
        dn=N[i][&lt;span&gt;0]*(x[&lt;span&gt;1]- x[&lt;span&gt;0])+N[i][&lt;span&gt;1]* (y[&lt;span&gt;1]-y[&lt;span&gt;0&lt;span&gt;]);
        nw=N[i][&lt;span&gt;0]* (x[&lt;span&gt;0]-A[i][&lt;span&gt;0])+N[i][&lt;span&gt;1]* (y[&lt;span&gt;0]- A[i][&lt;span&gt;1&lt;span&gt;]);

        &lt;span&gt;if(fabs(dn)&amp;lt;&lt;span&gt;1.0e-6)  &lt;span&gt;//&lt;span&gt;平行
&lt;span&gt;        {
            &lt;span&gt;if(nw&amp;lt;&lt;span&gt;0&lt;span&gt;)
                &lt;span&gt;return &lt;span&gt;0;    &lt;span&gt;//&lt;span&gt;p在L外侧
&lt;span&gt;        }
        &lt;span&gt;else&lt;span&gt;
        {
            t=-nw/&lt;span&gt;dn;
            &lt;span&gt;if(dn&amp;lt;&lt;span&gt;0&lt;span&gt;)
            {
                &lt;span&gt;if(t&amp;lt; *&lt;span&gt;te)
                    *te=t;   &lt;span&gt;//&lt;span&gt;终点
&lt;span&gt;            }
            &lt;span&gt;else &lt;span&gt;if(t&amp;gt; *&lt;span&gt;ts)
                *ts=t;  &lt;span&gt;//&lt;span&gt;起点
&lt;span&gt;        }
        &lt;span&gt;if(*ts&amp;gt;*&lt;span&gt;te)
            &lt;span&gt;return &lt;span&gt;0; &lt;span&gt;//&lt;span&gt;在区域外
&lt;span&gt;    }
    &lt;span&gt;return &lt;span&gt;1&lt;span&gt;;
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;三、梁友栋-Barsky算法&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; 当凸多边形是矩形窗口，且矩形的边平行于坐标轴时&lt;/span&gt;&lt;/strong&gt;， Cyrus-Beck算法可简化为梁友栋-Barsky算法。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1358881/201910/1358881-20191019200801629-420734848.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1358881/201910/1358881-20191019200835271-809578035.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;基本步骤&lt;/h3&gt;
&lt;p&gt;初始化线段在边界内的端点参数为ts=0、te=1。&lt;/p&gt;&lt;p&gt;计算出各个裁剪边界的r、s值。&lt;/p&gt;&lt;p&gt;当r=0且s&amp;lt;0时，舍弃该线段；否则计算线段与边界的交点参数t。&lt;br/&gt;当r&amp;lt;0时，参数t用于更新ts；&lt;br/&gt;当r&amp;gt;0时，参数t用于更新te。&lt;/p&gt;&lt;p&gt;如果更新了ts或te后，使ts&amp;gt;te，则舍弃该线段。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1358881/201910/1358881-20191019201010271-143822484.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1358881/201910/1358881-20191019201139490-1078232702.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;程序代码&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;double&lt;span&gt; ts,te;
&lt;span&gt;double&lt;span&gt; xL,xR,yB,yT;
&lt;span&gt;bool visible=&lt;span&gt;false&lt;span&gt;;
&lt;span&gt;void Liang_Barsky (&lt;span&gt;double x[&lt;span&gt;2],&lt;span&gt;double y[&lt;span&gt;2],&lt;span&gt;double *ts,&lt;span&gt;double *&lt;span&gt;te)
{
    &lt;span&gt;double&lt;span&gt; dx,dy;
    visible=&lt;span&gt;false&lt;span&gt;;
    dx=x[&lt;span&gt;1]-x[&lt;span&gt;0&lt;span&gt;];
    dy= y[&lt;span&gt;1]-y[&lt;span&gt;0&lt;span&gt;];
    *ts=&lt;span&gt;0&lt;span&gt;;
    *te=&lt;span&gt;1&lt;span&gt;;
    &lt;span&gt;if(clipt(-dx,x[&lt;span&gt;0]-&lt;span&gt;xL,ts,te))
        &lt;span&gt;if(clipt(dx,xR-x[&lt;span&gt;0&lt;span&gt;],ts,te))
            &lt;span&gt;if(clipt(-dy,y[&lt;span&gt;0]-&lt;span&gt;yB,ts,te))
                &lt;span&gt;if(clipt(dy,yT-y[&lt;span&gt;0&lt;span&gt;],ts,te))
                    visible=&lt;span&gt;true&lt;span&gt;;
}
&lt;span&gt;bool clipt (&lt;span&gt;double r,&lt;span&gt;double s,&lt;span&gt;double * ts,&lt;span&gt;double *&lt;span&gt;te)
{
    &lt;span&gt;double&lt;span&gt; t;
    &lt;span&gt;if(r&amp;lt;&lt;span&gt;0&lt;span&gt;)
    {
        t=s/&lt;span&gt;r;
        &lt;span&gt;if(t&amp;gt;*&lt;span&gt; te)
            &lt;span&gt;return &lt;span&gt;false&lt;span&gt;;
        &lt;span&gt;else  &lt;span&gt;if(t&amp;gt;*&lt;span&gt; ts)
            *ts=&lt;span&gt;t;
    }  &lt;span&gt;//&lt;span&gt;起点组
    &lt;span&gt;else &lt;span&gt;if(r&amp;gt;&lt;span&gt;0&lt;span&gt;)
    {
        t=s/&lt;span&gt;r;
        &lt;span&gt;if(t&amp;lt;*&lt;span&gt;ts)
            &lt;span&gt;return &lt;span&gt;false&lt;span&gt;;
        &lt;span&gt;else   &lt;span&gt;if(t&amp;lt;*&lt;span&gt; te)
            *te=&lt;span&gt;t;
    }  &lt;span&gt;//&lt;span&gt;终点组
    &lt;span&gt;else  &lt;span&gt;if(s&amp;lt;&lt;span&gt;0&lt;span&gt;)
        &lt;span&gt;return &lt;span&gt;false; &lt;span&gt;//&lt;span&gt;r=0且s&amp;lt;0则完全不可见
    &lt;span&gt;return &lt;span&gt;true&lt;span&gt;;
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;梁友栋-Barsky算法比Sutherland-Cohen算法更有效,因为需要计算的交点数目减少了。更新参数仅仅需要一次除法,线段与窗口的交点只计算一次就计算出 ts、te的最后的值。而对于Sutherland-Cohen算法,即使一条线段完全落在裁剪窗口之外,也要对其反复求交点,而且每次求交都需要除法和乘法运算。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/cnblog-wuran/p/9813841.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/cnblog-wuran/p/9813841.html&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;四、Sutherland-Hodgman多边形裁剪&lt;/h2&gt;
&lt;p&gt;该算法的基本思想是将多边形边界作为一个整体，每次用窗口的一条边对要裁剪的多边形和中间结果多边形进行裁剪，体现一种&lt;strong&gt;&lt;span&gt;分而治之&lt;/span&gt;&lt;/strong&gt;的思想&lt;/p&gt;
&lt;p&gt;基本原理&lt;/p&gt;
&lt;p&gt;只要对多边形用窗口的四条边依次裁剪四次便可得到裁剪后的多边形。&lt;br/&gt;每次用窗口的一条&lt;strong&gt;&lt;span&gt;边界（包括延长线）&lt;/span&gt;&lt;/strong&gt;对要裁剪的多边形进行裁剪，裁剪时顺序地测试多边形各顶点，&lt;strong&gt;&lt;span&gt;保留边界内侧的顶点，删除外侧的顶点&lt;/span&gt;&lt;/strong&gt;，同时，&lt;strong&gt;&lt;span&gt;适时地插入新的顶点(即交点和窗口顶点)，从而得到一个新的多边形顶点序列&lt;/span&gt;&lt;/strong&gt;。&lt;br/&gt;然后以此新的顶点序列作为输入，相对第二条窗边界线进行裁剪，又得到一个更新的多边形顶点序列。&lt;br/&gt;依次下去，相对于第三条、第四条边界线进行裁剪，最后输出的多边形顶点序列即为所求的裁剪好了的多边形。如下图所示。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1358881/201910/1358881-20191019211056242-1809142351.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 算法的输入是&lt;strong&gt;&lt;span&gt;以顶点序列表示的多边形，输出也是一个顶点序列，构成一个或多个多边形&lt;/span&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;考虑以窗口的一条边以及延长线构成的裁剪线，该线把平面分成两部分：&lt;strong&gt;&lt;span&gt;一部分包含窗口，称为可见侧；另一部分称为不可见侧&lt;/span&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;每条线段端点S、P与裁剪线比较后可输出0至2个顶点。&lt;br/&gt;&lt;strong&gt;&lt;span&gt;S、P都在可见一侧，则输出P。&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;S、P都在不可见一侧，则输出0个顶点。&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;S在可见一侧，P在不可见一侧，则输出SP与裁剪线的交点I。&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;S在不可见一侧，P在可见一侧，则输出SP与裁剪线的交点I和P。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1358881/201910/1358881-20191019211344043-879312107.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1358881/201910/1358881-20191019212712687-1785165121.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1358881/201910/1358881-20191019212730550-1665666753.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1358881/201910/1358881-20191019212737602-994864060.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;五、字符裁剪&lt;/h2&gt;
&lt;p&gt;字符裁剪的策略有以下三种:&lt;br/&gt;&lt;strong&gt;&lt;span&gt;串精度裁剪&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;字符串完全落入窗口之内时才显示，否则不显示，裁剪结果如图(b)所示。其思想是求出字符串的包围盒，比较包围盒的边界极值与窗口的边界极值，若包围盒完全落于窗口之内，则显示字符串，否则不显示。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;字符精度裁剪&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;当一个字符完全包含于窗口内时，显示该字符，否则不显示。可先用字符串包围盒判断应该完全、部分还是不显示字符串，对部分显示的字符串，再用每个字符的包围盒判断该字符是不是应该显示。裁剪结果如图(c)所示。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;基于构成字符最小元素的裁剪&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这种策略最为精确，即使字符只有一部分在窗口内，也要把这一部分显示出来。对点阵字符来说，构成字符的最小元素为像素，此时字符的裁剪转化为点裁剪；对矢量字符来说，构成字符的最小元素是曲线段，字符的裁剪转化为曲线的裁剪。裁剪结果如图(d)所示。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1358881/201910/1358881-20191019213004024-1638962378.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 19 Oct 2019 13:32:00 +0000</pubDate>
<dc:creator>王陸</dc:creator>
<og:description>裁剪作用：选择显示的内容--图形在窗口内的部分被显示出来，窗口外的部分被裁剪掉&amp;#160;图形中每个图形基本元素都要经过裁剪，因此裁剪直接影响整个图形系统的效率。 裁剪窗口：矩形，凸多边形，任意多边形</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wkfvawl/p/11705842.html</dc:identifier>
</item>
<item>
<title>采用WPF开发截图程序，so easy！ - 源之缘</title>
<link>http://www.cnblogs.com/yuanchenhui/p/screenshot-easy.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuanchenhui/p/screenshot-easy.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;前言&lt;/strong&gt;  QQ、微信截图功能已很强大了，似乎没必要在开发一个截图程序了。但是有时QQ热键就是被占用，不能快速的开启截屏；有时，天天挂着QQ，领导也不乐意。既然是程序员，就要自己开发截屏工具，功能随心所欲，岂不快哉。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;再强调一点：工具就是生产力！没有掌握WPF之前，我是不会开发这么一个程序的，如果采用MFC、winform框架，工作量是相当的大，开发出来的效果肯定也比较low。本人用WPF，花了一天的功夫，开发了这个小程序。程序的定位就功能简单，平时工作不碍事，用着的时候，一键截图！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; 界面 &lt;/strong&gt; 执行程序下载 &lt;a href=&quot;https://files.cnblogs.com/files/yuanchenhui/%E4%B8%80%E9%94%AE%E6%88%AA%E5%9B%BE.zip&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;&lt;span&gt;一键截图&lt;/span&gt;&lt;/strong&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/245753/201910/245753-20191020053833579-1320231834.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 程序就一个按钮，点击开始截屏，就是这么简单。看似简单，对开发技巧要求很高。内行看门道！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;开发思虑&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt; &lt;span&gt;常言道：看到的不一定是真实的。开发也要这样。程序叫截屏，你不要一股劲想着怎么截取别的窗口图案，肯定很费劲！思虑就是掩人耳目：先将整个屏幕复制，放到自己程序窗体中，窗体最大化，覆盖整个屏幕！用户看到还是整个屏幕，但是整个屏幕已被偷梁换柱！此后，你所有的操作都是在自己窗体上处理，当然可以随心所欲了！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;截取整个屏幕&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
       &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Bitmap GetScreenSnapshot()
        {
            System.Drawing.Rectangle rc &lt;/span&gt;=&lt;span&gt; SystemInformation.VirtualScreen;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; bitmap = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Bitmap(rc.Width, rc.Height, System.Drawing.Imaging.PixelFormat.Format32bppArgb);

            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (Graphics memoryGrahics =&lt;span&gt; Graphics.FromImage(bitmap))
            {
                memoryGrahics.CopyFromScreen(rc.X, rc.Y, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, rc.Size, CopyPixelOperation.SourceCopy);
            }

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; bitmap;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;创建全屏窗体&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/245753/201910/245753-20191019210014508-219614997.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 注意窗体属性，这样才能全面覆盖整个屏幕。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;图层布局&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个很有技巧！为了实现非截图区域阴影效果，费了一番心机！即使这样，感觉也比winform用起来得心应手！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注：我不是一直贬低winform，但是要承认，这两个东西不是一个时代产物。wpf设计思路比winform先进很多。只是wpf新概念多，用的人少，开发起来常常蒙圈！经过一段迷茫期，前途就会光明了！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;窗口的布局，不多说了！直接上代码。我对代码做了注释！&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Grid&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 整个屏幕图像 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Image &lt;/span&gt;&lt;span&gt;x:Name&lt;/span&gt;&lt;span&gt;=&quot;imgScreen&quot;&lt;/span&gt;&lt;span&gt;
               MouseDown&lt;/span&gt;&lt;span&gt;=&quot;ImgScreen_MouseDown&quot;&lt;/span&gt;&lt;span&gt;
               MouseUp&lt;/span&gt;&lt;span&gt;=&quot;ImgScreen_MouseUp&quot;&lt;/span&gt;&lt;span&gt;
               Stretch&lt;/span&gt;&lt;span&gt;=&quot;None&quot;&lt;/span&gt;&lt;span&gt;           
               MouseMove&lt;/span&gt;&lt;span&gt;=&quot;ImgScreen_MouseMove&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Image&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 覆盖一层黑色，半透明状 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Grid &lt;/span&gt;&lt;span&gt;x:Name&lt;/span&gt;&lt;span&gt;=&quot;gridCover&quot;&lt;/span&gt;&lt;span&gt; Visibility&lt;/span&gt;&lt;span&gt;=&quot;Collapsed&quot;&lt;/span&gt;&lt;span&gt; Background&lt;/span&gt;&lt;span&gt;=&quot;Black&quot;&lt;/span&gt;&lt;span&gt; Opacity&lt;/span&gt;&lt;span&gt;=&quot;0.5&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Grid&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Grid&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Grid.RowDefinitions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;RowDefinition &lt;/span&gt;&lt;span&gt;Height&lt;/span&gt;&lt;span&gt;=&quot;*&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;RowDefinition&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;RowDefinition &lt;/span&gt;&lt;span&gt;Height&lt;/span&gt;&lt;span&gt;=&quot;auto&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;RowDefinition&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Grid.RowDefinitions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 前面覆盖了一层黑色，但是截取的图像不能覆盖，只能在这里再显示截取图像 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Image &lt;/span&gt;&lt;span&gt;x:Name&lt;/span&gt;&lt;span&gt;=&quot;imgCut&quot;&lt;/span&gt;&lt;span&gt; Grid.RowSpan&lt;/span&gt;&lt;span&gt;=&quot;3&quot;&lt;/span&gt;&lt;span&gt; Stretch&lt;/span&gt;&lt;span&gt;=&quot;None&quot;&lt;/span&gt;&lt;span&gt;  
                   HorizontalAlignment&lt;/span&gt;&lt;span&gt;=&quot;Left&quot;&lt;/span&gt;&lt;span&gt; VerticalAlignment&lt;/span&gt;&lt;span&gt;=&quot;Top&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Image&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;显示提示信息&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextBlock &lt;/span&gt;&lt;span&gt;HorizontalAlignment&lt;/span&gt;&lt;span&gt;=&quot;Center&quot;&lt;/span&gt;&lt;span&gt; VerticalAlignment&lt;/span&gt;&lt;span&gt;=&quot;Center&quot;&lt;/span&gt;&lt;span&gt;
                           FontSize&lt;/span&gt;&lt;span&gt;=&quot;22&quot;&lt;/span&gt;&lt;span&gt; Foreground&lt;/span&gt;&lt;span&gt;=&quot;Yellow&quot;&lt;/span&gt;&lt;span&gt;
                          Opacity&lt;/span&gt;&lt;span&gt;=&quot;0.8&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt;滑动鼠标开始截屏 按ESC键退出&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;TextBlock&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;StackPanel  &lt;/span&gt;&lt;span&gt;Grid.RowSpan&lt;/span&gt;&lt;span&gt;=&quot;3&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;截图指示框&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Border &lt;/span&gt;&lt;span&gt;x:Name&lt;/span&gt;&lt;span&gt;=&quot;borderSelect&quot;&lt;/span&gt;&lt;span&gt; 
                HorizontalAlignment&lt;/span&gt;&lt;span&gt;=&quot;Left&quot;&lt;/span&gt;&lt;span&gt; VerticalAlignment&lt;/span&gt;&lt;span&gt;=&quot;Top&quot;&lt;/span&gt;&lt;span&gt;
                BorderThickness&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt; BorderBrush&lt;/span&gt;&lt;span&gt;=&quot;Red&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Border&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;宽和高指示&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;StackPanel &lt;/span&gt;&lt;span&gt;Orientation&lt;/span&gt;&lt;span&gt;=&quot;Horizontal&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextBlock &lt;/span&gt;&lt;span&gt;x:Name&lt;/span&gt;&lt;span&gt;=&quot;txtCutInfo&quot;&lt;/span&gt;&lt;span&gt; Background&lt;/span&gt;&lt;span&gt;=&quot;Black&quot;&lt;/span&gt;&lt;span&gt; Padding&lt;/span&gt;&lt;span&gt;=&quot;3&quot;&lt;/span&gt;&lt;span&gt; 
                               HorizontalAlignment&lt;/span&gt;&lt;span&gt;=&quot;Left&quot;&lt;/span&gt;&lt;span&gt;
                               Foreground&lt;/span&gt;&lt;span&gt;=&quot;White&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;TextBlock&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;StackPanel&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;StackPanel&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Grid&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Grid&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;当鼠标移动时，不断的计算选中区域，设置borderSelect属性。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ImgScreen_MouseMove(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, MouseEventArgs e)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;_isMouseDown)
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;

            gridCover.Visibility &lt;/span&gt;=&lt;span&gt; Visibility.Visible;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算鼠标选中区域&lt;/span&gt;
            Point currentPoint =&lt;span&gt; e.GetPosition(imgScreen);
            Point borderPoint &lt;/span&gt;=&lt;span&gt; e.GetPosition(borderSelect);

            &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; xDelta =&lt;span&gt; xDelta_BoderToImgScreen;
            &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; yDelta =&lt;span&gt; yDelta_BoderToImgScreen;

            _rectImgCut &lt;/span&gt;=&lt;span&gt; ImageHelper.ToRect(currentPoint, _startPoint);

            Rect rectBoderCut &lt;/span&gt;= ImageHelper.ToRect(&lt;span&gt;new&lt;/span&gt; Point(currentPoint.X + xDelta, currentPoint.Y +&lt;span&gt; yDelta),
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Point(_startPoint.X + xDelta, _startPoint.Y +&lt;span&gt; yDelta));

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置方框位置和大小&lt;/span&gt;
            Thickness thickness = &lt;span&gt;new&lt;/span&gt; Thickness(rectBoderCut.Left, rectBoderCut.Top, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
            borderSelect.SetValue(FrameworkElement.MarginProperty, thickness);
            imgCut.SetValue(FrameworkElement.MarginProperty, thickness);

            thickness &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thickness(rectBoderCut.Left, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
            txtCutInfo.SetValue(FrameworkElement.MarginProperty, thickness);

            borderSelect.Width &lt;/span&gt;= Math.Abs(_startPoint.X -&lt;span&gt; currentPoint.X);
            borderSelect.Height &lt;/span&gt;= Math.Abs(_startPoint.Y -&lt;span&gt; currentPoint.Y);
            borderSelect.Visibility &lt;/span&gt;=&lt;span&gt; Visibility.Visible;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;为了防止整个图 变暗，鼠标选中区域图像抠图，再在上层图像上显示&lt;/span&gt;
            imgCut.Source =&lt;span&gt; GetBitmapCut();

            Int32Rect imgDestRect &lt;/span&gt;=&lt;span&gt; GetCutRect();
            txtCutInfo.Text &lt;/span&gt;= &lt;span&gt;string&lt;/span&gt;.Format($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;宽:{imgDestRect.Width} 高:{imgDestRect.Height}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;到此，程序主要逻辑处理完毕！麻雀虽小五脏俱全！这里用到不少wpf布局技巧。这些技巧与winform处理思虑差别还是很大的！wpf虽然苦涩难懂，感觉一入候门深似海！如果坚持下来，就会感到豁然开朗，也理解了微软的一片苦心！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;程序运行效果与QQ截图很类似了。顺着这个思虑往前走，完全可以开发出与QQ截图一样的效果！&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 19 Oct 2019 13:30:00 +0000</pubDate>
<dc:creator>源之缘</dc:creator>
<og:description>前言 QQ、微信截图功能已很强大了，似乎没必要在开发一个截图程序了。但是有时QQ热键就是被占用，不能快速的开启截屏；有时，天天挂着QQ，领导也不乐意。既然是程序员，就要自己开发截屏工具，功能随心所欲，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yuanchenhui/p/screenshot-easy.html</dc:identifier>
</item>
<item>
<title>【源码解析】凭什么？spring boot 一个 jar 就能开发 web 项目 - 逸飞兮</title>
<link>http://www.cnblogs.com/lw5946/p/11705090.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lw5946/p/11705090.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1775867/201910/1775867-20191019203205390-861439532.jpg&quot; alt=&quot;why&quot;/&gt;&lt;/p&gt;

&lt;p&gt;为什么开发web项目，spring-boot-starter-web 一个jar就搞定了？这个jar做了什么？&lt;/p&gt;
&lt;p&gt;通过 spring-boot 工程可以看到所有开箱即用的的引导模块 spring-boot-starter-xxx 都在 &lt;code&gt;spring-boot-starters&lt;/code&gt; 子模块中，&lt;strong&gt;且所有的 spring-boot-starter-xxx 模块中都没有代码&lt;/strong&gt;，都是在其他包中就完成对应的功能。首先，分析其依赖&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1775867/201910/1775867-20191019203205669-1276615659.jpg&quot; alt=&quot;spring-boot-starter-web 依赖&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意：图中的 Jakarta.xxxx 包是原来的 javax.xxxx 包，Java EE 改名为 Jakarta EE 了，&lt;code&gt;spring-boot-starter-web-2.1.8.RELEASE&lt;/code&gt; 版本是直接依赖于hibernate-validator，spring-boot-2.2.0 版本开始使用的是 Jakarta，并用一个新模块 spring-boot-starter-validation 来管理&lt;/p&gt;
&lt;p&gt;从依赖图中可以看到，最核心的 &lt;code&gt;spring-boot&lt;/code&gt; 依赖于 &lt;code&gt;spring-context&lt;/code&gt; 和 &lt;code&gt;spring-core&lt;/code&gt; ，因此，正如官方所说，&lt;code&gt;spring-boot&lt;/code&gt; 是基于 &lt;code&gt;spring&lt;/code&gt; 的。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;spring boot可以轻松地创建可运行的、独立的、生产级的基于spring的应用程序。我们对spring平台和第三方库有自己的见解，这样您就可以从最少的麻烦开始了。大多数spring引导应用程序只需要很少的spring配置。&lt;br/&gt;可以使用 Spring Boot 创建Java应用程序，Java应用程序可以通过使用 &lt;code&gt;java -jar&lt;/code&gt; 或更传统的war 来部署。我们还提供了一个运行“spring脚本”的命令行工具。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;我们首要的目标是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;为所有spring开发提供一个更快、更容易获得的入门体验。&lt;/li&gt;
&lt;li&gt;开箱即用，但要在需求开始偏离默认值时迅速改变。&lt;/li&gt;
&lt;li&gt;提供一系列对大型项目通用的非功能性特性（如嵌入式服务器、安全性、流量、运行状况检查和外部化配置）。&lt;/li&gt;
&lt;li&gt;绝对不需要代码生成，也不需要XML配置。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MDIxODU2Nw==&amp;amp;mid=2247483663&amp;amp;idx=1&amp;amp;sn=32f5a934f58c94e526b082c04af32045&amp;amp;chksm=ce28f4a7f95f7db1b43de5955521da8dcf6abaf95c5b3b3499e1389e96ae647756b6edc5bcdf&amp;amp;token=1563255338&amp;amp;lang=zh_CN#rd&quot;&gt;【spring-boot 源码解析】spring-boot 依赖管理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MDIxODU2Nw==&amp;amp;mid=2247483667&amp;amp;idx=1&amp;amp;sn=2d7c3657e3565386e9cb35a570374a4c&amp;amp;chksm=ce28f4bbf95f7dad3786dc2cda8888aa69113e1b7c1222e78301a138cc341350e7e5d2bbbbda&amp;amp;token=1563255338&amp;amp;lang=zh_CN#rd&quot;&gt;【spring-boot 源码解析】spring-boot 依赖管理梳理图&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;此模块是所有 spring-boot-starter-xxxx 引导器核心，非常重要！！！&lt;/p&gt;
&lt;p&gt;包含以下模块：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-autoconfigure&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-logging&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;javax.annotation&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;javax.annotation-api&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-core&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.yaml&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;snakeyaml&amp;lt;/artifactId&amp;gt;
    &amp;lt;scope&amp;gt;runtime&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;spring-boot&quot;&gt;spring-boot&lt;/h2&gt;
&lt;p&gt;spring-boot 内核，spring-boot 特性功能都是在此包实现。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1775867/201910/1775867-20191019203205920-2065872508.jpg&quot; alt=&quot;spring boot 核心原理&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;spring-boot-autoconfigure&quot;&gt;spring-boot-autoconfigure&lt;/h2&gt;
&lt;p&gt;spring-boot 自动配置，提供一些常用包的默认配置&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MDIxODU2Nw==&amp;amp;mid=2247483687&amp;amp;idx=1&amp;amp;sn=ec82f9380af9555002bed58818add529&amp;amp;chksm=ce28f48ff95f7d9943c92c1355937b3ce17a667edb109a4eb02b77d2dc96881d68c4638a7ede&amp;amp;token=1563255338&amp;amp;lang=zh_CN#rd&quot;&gt;【源码解析】自动配置的这些细节不知道，别说你会 spring-boot&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;spring-boot-starter-logging&quot;&gt;spring-boot-starter-logging&lt;/h2&gt;
&lt;p&gt;spring-boot 默认日志引导器&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;ch.qos.logback&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;logback-classic&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.apache.logging.log4j&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;log4j-to-slf4j&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;jul-to-slf4j&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;什么都没做，就引入了几个依赖，那引入这几个依赖解决了什么问题呢？&lt;br/&gt;通过引入这几个依赖，直接或间接的引入了 slf4j、logback日志框架所需jar，以及 log4j、jul日志工具对 Slf4j的适配。&lt;br/&gt;因此，&lt;strong&gt;引入了这个jar，工程中的日志实现使用 logback&lt;/strong&gt;。&lt;br/&gt;嗯？那 log4j2 呢？&lt;br/&gt;原来如果想用 log4j2，还有一个 &lt;code&gt;spring-boot-starter-log4j2&lt;/code&gt; 包供我们选择。&lt;/p&gt;
&lt;p&gt;日志的具体配置，建议还是用原本的 xml 配置，用 yaml 或 properties 不好配置。&lt;br/&gt;如：logback 使用根目录下的 logback-spring.xml 配置。&lt;/p&gt;
&lt;h2 id=&quot;snakeyaml&quot;&gt;snakeyaml&lt;/h2&gt;
&lt;p&gt;支持yaml语法的生成与解析工具包&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/d8136c913e52&quot;&gt;SnakeYaml快速入门&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;没有做任何处理，直接使用嵌入式 tomcat 相关jar。spring 项目由外部 tomcat 调用 spring框架，而 spring-boot 是由 框架内部去调用嵌入式 tomcat，主被动关系发生了转化。&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;
&amp;lt;!-- 相当于去掉的tomcat-annotations-api --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;javax.annotation&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;javax.annotation-api&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.apache.tomcat.embed&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;tomcat-embed-core&amp;lt;/artifactId&amp;gt;
    &amp;lt;exclusions&amp;gt;
        &amp;lt;exclusion&amp;gt;
            &amp;lt;groupId&amp;gt;org.apache.tomcat&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;tomcat-annotations-api&amp;lt;/artifactId&amp;gt;
        &amp;lt;/exclusion&amp;gt;
    &amp;lt;/exclusions&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.apache.tomcat.embed&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;tomcat-embed-el&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.apache.tomcat.embed&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;tomcat-embed-websocket&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;没有做任何处理，使用 jackson 作为默认json工具&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
   &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-web&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.fasterxml.jackson.core&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;jackson-databind&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.fasterxml.jackson.datatype&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;jackson-datatype-jdk8&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.fasterxml.jackson.datatype&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;jackson-datatype-jsr310&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.fasterxml.jackson.module&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;jackson-module-parameter-names&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;2.1.8.RELEASE 版本直接依赖于 hibernate-validator，没有此模块&lt;/p&gt;
&lt;p&gt;2.2.0 版本依赖于 Jakarta.validation-api 和 hibernate-validator，并去掉了 hibernate-validator中的 javax.validation-api。&lt;/p&gt;
&lt;p&gt;两者在使用的时候没有任何区别，是无感切换的。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MDIxODU2Nw==&amp;amp;mid=2247483682&amp;amp;idx=1&amp;amp;sn=c9ef26d68a173a059137305c064f24b7&amp;amp;chksm=ce28f48af95f7d9c5906d2143ed5481c9d48ece83d06340c56d74ecb5280d645b9dbaa1e8c87&amp;amp;token=1563255338&amp;amp;lang=zh_CN#rd&quot;&gt;validator 自动化校验&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;!-- 2.2.0.M6 --&amp;gt;

&amp;lt;!-- 相当于去掉的javax validation-api --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;jakarta.validation&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;jakarta.validation-api&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.apache.tomcat.embed&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;tomcat-embed-el&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.hibernate.validator&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;hibernate-validator&amp;lt;/artifactId&amp;gt;
    &amp;lt;exclusions&amp;gt;
        &amp;lt;exclusion&amp;gt;
            &amp;lt;groupId&amp;gt;javax.validation&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;validation-api&amp;lt;/artifactId&amp;gt;
        &amp;lt;/exclusion&amp;gt;
    &amp;lt;/exclusions&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1775867/201910/1775867-20191017092843285-1565153444.png&quot; alt=&quot;逸飞兮&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 19 Oct 2019 12:32:00 +0000</pubDate>
<dc:creator>逸飞兮</dc:creator>
<og:description>问题 为什么开发web项目，spring boot starter web 一个jar就搞定了？这个jar做了什么？ 通过 spring boot 工程可以看到所有开箱即用的的引导模块 spring</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lw5946/p/11705090.html</dc:identifier>
</item>
<item>
<title>声学回声消除(Acoustic Echo Cancellation)原理与实现 - 凌逆战</title>
<link>http://www.cnblogs.com/LXP-Never/p/11703440.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/LXP-Never/p/11703440.html</guid>
<description>&lt;p&gt;　　回声就是声音信号经过一系列反射之后，又听到了自己讲话的声音，这就是回声。一些回声是必要的，比如剧院里的音乐回声以及延迟时间较短的房间回声；而大多数回声会造成负面影响，比如在有线或者无线通信时重复听到自己讲话的声音（回想那些年我们开黑打游戏时，如果其中有个人开了外放，他的声音就会回荡来回荡去）。因此消除回声的负面影响对通信系统是十分必要的。&lt;/p&gt;
&lt;p&gt;　　针对回声消除（Acoustic Echo Cancellation，AEC ）问题，现如今最流行的算法就是基于自适应滤波的回声消除算法。本文从回声信号的两种分类以及 AEC 的基本原理出发，介绍几种经典的 AEC 算法并对其性能进行阐释。&lt;/p&gt;

&lt;p&gt;　　在通信系统中，回声主要分为两类：&lt;span&gt;&lt;strong&gt;电路回声&lt;/strong&gt;&lt;/span&gt;和&lt;span&gt;&lt;strong&gt;声学回声&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;电路回声&lt;/h2&gt;
&lt;p&gt;　　电路回声通常产生于有线通话中，而造成电路回声的根本原因是&lt;span&gt;&lt;strong&gt;转换混合器的二线-四线阻抗不能完全匹配&lt;/strong&gt;&lt;/span&gt;。中心局至转换混合器之间采用四线的连接方式传输信号，上面两条线路用于发送给用户端信号，下面两条线路用于接收用户端信号。通信公司为了降低远距离信号传输成本，将混合器至用户端的连接线减少为二线连接，分别用于用户端信号的接受与发送。中间的转换混合电路功能是将四线连接转换为二线连接，由于在转换过程中使用了不同型号的电线或者负载线圈没有被使用的原因，不可避免地会产生阻抗不匹配现象，导致混合器接收线路上的语音信号流失到了发送线路，产生了回声信号，使得另一端的用户在接收信号的同时听到了自己的声音。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433301/201910/1433301-20191019121933645-98986979.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;电路回声产生原理&lt;/p&gt;
&lt;p&gt;　　在现如今的数字通信网络中，转换混合器与数模转换器融为一体，但无论是模拟电子线路还是数字电子线路，二-四线的转换都会造成阻抗不匹配问题，从而导致其产生电路回声，影响现代通信质量。由于电路回声的线性以及稳定性，&lt;span&gt;&lt;strong&gt;用一个简单的线性叠加器就可以实现电路回声消除&lt;/strong&gt;&lt;/span&gt;。首先将产生的回声信号在数值上取反，线性地叠加在回声信号上，将产生的回声信号抵消，实现电路回声的初步消除。然而由于技术缺陷，线性叠加器不能完整地将回声信号抹去，因此需要添加一个非线性处理器，其实质是一个阻挡信号的开关，将残余的回声信号经过非线性处理之后，就可以实现电路回声的消除，或者得到噪声很小的静音信号。由于电路回声信号是线性且稳定的，所以比较容易将其消除，而本文主要研究的是如何消除非线性的声学回声。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433301/201910/1433301-20191019121950009-864916728.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;电路回声消除的基本原理&lt;/p&gt;
&lt;h2&gt;声学回声&lt;/h2&gt;
&lt;p&gt;　　在麦克风与扬声器互相作用影响的双工通信系统中极易产生声学回声。如下图所示&lt;/p&gt;
&lt;p&gt;&lt;span&gt;远端讲话者A--&amp;gt;麦克风A--&amp;gt;电话A--&amp;gt;电话B----&amp;gt;扬声器B---&amp;gt;麦克风B--&amp;gt;电话B--&amp;gt;电话A--&amp;gt;扬声器A---&amp;gt;麦克风A---&amp;gt;.........&lt;/span&gt;就这样无限循环，&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;详细讲解：&lt;/strong&gt;远端讲话者A的话语被麦克风采集并传入至通信设备，经过无线或有线传输之后达到近端的通信设备，并通过近端 B 的扬声器播放，这个声音又会被近端 B 的麦克风拾取至其通信设备形成声学回声，经传输又返回了远端 A 的通信设备，并通过远端 A 的扬声器播放出来，从而远端讲话者就听到了自己的回声。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433301/201910/1433301-20191019121444053-536751494.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;声学回声产生原理&lt;/p&gt;
&lt;p&gt;声学回声信号根据传输途径的差别可以分别&lt;strong&gt;直接回声&lt;/strong&gt;信号和&lt;strong&gt;间接回声&lt;/strong&gt;信号。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;直接回声&lt;/strong&gt;&lt;/span&gt;：近端扬声器B将语音信号播放出来后，近端麦克风B直接将其采集后得到的回声。&lt;/p&gt;
&lt;p&gt;　　直接回声不受环境的印象，与扬声器到麦克风的距离及位置有很大的关系，因此直接回声是一种&lt;strong&gt;线性信号&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;间接回声&lt;/strong&gt;&lt;/span&gt;：近端扬声器B将语音信号播放出来后，语音信号经过复杂多变的墙面反射后由近端麦克风B将其拾取。&lt;/p&gt;
&lt;p&gt;　　间接回声的大小与房间环境、物品摆放以及墙面吸引系数等等因素有关，因此间接回声是一种&lt;strong&gt;非线性信号&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;回声消除技术主要用于&lt;strong&gt;在免提电话、电话会议系统&lt;/strong&gt;等情形中。&lt;/p&gt;

&lt;p&gt;　　如今解决 AEC 问题最常用的方法，就是&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;使用不同的&lt;span&gt;自适应滤波算法&lt;/span&gt;调整滤波器的权值向量，&lt;span&gt;估计一个近似的回声路径&lt;/span&gt;来逼近真实回声路径，从而得到&lt;span&gt;估计的回声信号&lt;/span&gt;，并在纯净语音和回声的混合信号中除去此信号来实现回声的消除。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433301/201910/1433301-20191019185408414-967440258.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; AEC的基本原理&lt;/p&gt;
&lt;p&gt;　　$x(n)$为远端输入信号，经过未知的回声路径$w(n)$得到$y(n)=x(n)*w(n)$，再加上观测噪声$v(n)$即为期望信号$d(n)= y(n) + v(n)$。x(n)通过自适应滤波器$\hat{w}(n)$得到估计的回声信号，并与期望信号$d(n)$相减得到误差信号$e(n)$，即$e(n)=d(n)-\hat{w}^T(n)x(n)$，误差信号的值越小说明自适应滤波算法所估计的回声路径就越接近实际的回声路径。&lt;/p&gt;
&lt;p&gt;　　滤波器采用特定的自适应算法不停地调整权值向量，使估计的回声路径 \hat{w}(n) 逐渐趋近于真实回声路径$w(n)$。显然，在 AEC 问题中，自适应滤波器的选择对回声消除的性能好坏起着十分关键的作用。&lt;/p&gt;

&lt;p&gt;　　自适应滤波器是一个对输入信号进行处理并不停学习，直到其达到期望值的器件。自适应滤波器在输入信号非平稳条件下，也可以根据环境不断调节滤波器权值向量，使算法达到特定的收敛条件，从而实现自适应滤波过程。&lt;/p&gt;
&lt;p&gt;　　自适应滤波器按输入信号类型可分为模拟滤波器和离散滤波器，本文中使用的是离散滤波器中的&lt;strong&gt;数字滤波器&lt;span&gt;（&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;数字滤波器按结构可划分为输入不仅与过去和当前的输入有关、还与过去的输出有关的&lt;strong&gt;无限冲激响应滤波器（IIR）&lt;/strong&gt;，以及输出与有限个过去和当前的输入有关的&lt;strong&gt;有限冲激响应滤波器（FIR））&lt;/strong&gt;&lt;/span&gt;为了使得自适应滤波器具有更强的稳定性，并且具有足够的滤波器系数可以用来调整以达到特定的收敛准则，一般选取&lt;span&gt;&lt;strong&gt;横向的 FIR 滤波器&lt;/strong&gt;&lt;/span&gt;进行来进行回声的消除&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433301/201910/1433301-20191019192342538-329848962.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 横向FIR滤波器结构框图&lt;/p&gt;
&lt;p&gt;　　$x(n)$是远端输入信号，$\hat{w}_i(n)$是滤波器系数，其中$i=0,1,...,L-1$，$L$为滤波器的长度，$n$为采样点数，$\hat{w}(n)$为滤波器的权值向量且$\hat{w}(n)=[\hat{w}_0(n),\hat{w}_1(n),...,\hat{w}_{L-1}(n)]^T$，根据误差信号$e(n)=d(n)-\hat{w}^T(n)x(n)$的值以及不同算法的收敛准则调整滤波器的权值向量。&lt;/p&gt;
&lt;p&gt;　　然而&lt;strong&gt;自适应滤波算法的选择&lt;/strong&gt;从根本上决定了回声消除的效果是否良好，接下来将介绍几种解决 AEC 问题的经典自适应滤波算法。&lt;/p&gt;

&lt;h2&gt;LSM算法&lt;/h2&gt;
&lt;p&gt;　　通过上面AEC的基本原理我们知道了误差信号$e(n)$等于期望信号减去滤波器输出信号：&lt;/p&gt;
&lt;p&gt;$$e(n)=d(n)-\hat{w}^T(n)x(n)$$&lt;/p&gt;
&lt;p&gt;对上式两端先平方，然后再求其数学期望，可将$e(n)$的MSE表示为：&lt;/p&gt;
&lt;p&gt;$$\xi=E[e^2(n)]=E[d^2(n)]-2P^T\hat{w}(n)+\hat{w}^T(n)R\hat{w}(n)$$&lt;/p&gt;
&lt;p&gt;其中，$P=E[d(n)x(n)]$为$d(n)$与输入信号$x(n)$的负相关矩阵，$R=E[x(n)x^T(n)]$为$x(n)$的自相关矩阵。&lt;/p&gt;
&lt;p&gt;　　对误差信号求导并且使导数值置零，求解得到使得误差最小的“最优权重” $\hat{w}_{opt}(n)=\frac{P}{R}$，R 和 P 的估计分别为$\hat{R}(n) 和$\hat{P}(n)$ ，利用各自的瞬时估计值将其分别表示为：\hat{R}(n)=x(x)x^T(n)；\hat{P}(n)=d(n)x(n) 。另外，用$\hat{g}_w(n)$表示误差信号对权值向量导数的估计值，利用下式方法求解最优权值向量的维纳解：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433301/201910/1433301-20191019201104197-813896950.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 得到：$\hat{g}_w(n)=-2e(n)x(n)$ ，算法取瞬时平方误差作为目标函数，那么$\hat{g}_w(n)$为其真实梯度，因为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433301/201910/1433301-20191019201126882-69148441.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因此得到 LMS 算法的权值向量更新公式：&lt;/p&gt;
&lt;p&gt;$$\hat{w}(n+1)=\hat{w}(n)+2\mu e(n)x(n)$$&lt;/p&gt;
&lt;p&gt;式中，$\mu$为固定步长因子，$\mu$的大小很大程度上决定了算法的收敛与稳态性能。LMS 算法复杂性低，但是它的收敛速度慢。为改善 LMS 这个不足之处，科研人员提出一系列改进算法，NLMS 算法就是其中一种&lt;/p&gt;
&lt;h2&gt;NLMS算法&lt;/h2&gt;
&lt;h2&gt;NSAF算法&lt;/h2&gt;

&lt;p&gt;本文讲解WebRTC的matlab梳理，由于matlab代码和webRTC的c++代码命名几乎一致。所以c++的实现就一笔带过。&lt;/p&gt;
&lt;p&gt;RERL-residual_echo_return_loss&lt;br/&gt;ERL-echo return loss&lt;br/&gt;ERLE echo return loss enhancement&lt;br/&gt;NLP non-linear processing&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
%&lt;span&gt; 首先matlab读入远端和近端信号
&lt;/span&gt;%&lt;span&gt; near.pcm 是麦克风捕捉到的信号
fid&lt;/span&gt;=fopen(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;near.pcm&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;rb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;); %&lt;span&gt; 加载far端
ssin&lt;/span&gt;=fread(fid,inf,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;float32&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
fclose(fid);
&lt;/span&gt;%&lt;span&gt; far.pcm 是扬声器播放的音乐
fid&lt;/span&gt;=fopen(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;far.pcm&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;rb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;); %&lt;span&gt; 加载near端
rrin&lt;/span&gt;=fread(fid,inf,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;float32&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
fclose(fid);

&lt;/span&gt;% ------- 对变量赋初始值 -----------&lt;span&gt;
fs&lt;/span&gt;=&lt;span&gt;16000&lt;/span&gt;&lt;span&gt;;
NLPon&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;;     %&lt;span&gt; 非线性处理 on
M &lt;/span&gt;= &lt;span&gt;16&lt;/span&gt;;     %&lt;span&gt; 分区数
N &lt;/span&gt;= &lt;span&gt;64&lt;/span&gt;;     %&lt;span&gt; 分区长度
L &lt;/span&gt;= M*N;     %&lt;span&gt; 滤波器长度
VADtd&lt;/span&gt;=&lt;span&gt;48&lt;/span&gt;&lt;span&gt;;
alp &lt;/span&gt;= &lt;span&gt;0.15&lt;/span&gt;; %&lt;span&gt; 功率估计因子
alc &lt;/span&gt;= &lt;span&gt;0.1&lt;/span&gt;;     %&lt;span&gt; 相干估计因子
step &lt;/span&gt;= &lt;span&gt;0.1875&lt;/span&gt;;%&lt;span&gt;0.1875&lt;/span&gt;&lt;span&gt;; 下台阶尺寸 Downward step size

len&lt;/span&gt;=&lt;span&gt;length(ssin);
NN&lt;/span&gt;=&lt;span&gt;len;
Nb&lt;/span&gt;=floor(NN/N)-&lt;span&gt;M;
&lt;/span&gt;% Nb=麦克风采集到的数据块数-&lt;span&gt;16&lt;/span&gt;&lt;span&gt;(分区数)
&lt;/span&gt;%&lt;span&gt; 这是因为第一次输入了16块，所以这里减掉了16
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; kk=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;:Nb    
    pos &lt;/span&gt;= N * (kk-&lt;span&gt;1&lt;/span&gt;) + start;    %&lt;span&gt; pos是每一次添加一块时的地址指针
    &lt;/span&gt;%far &lt;span&gt;is&lt;/span&gt;&lt;span&gt; speaker played music
    xk &lt;/span&gt;= rrin(pos:pos+N-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;%near &lt;span&gt;is&lt;/span&gt;&lt;span&gt; micphone captured signal
    dk &lt;/span&gt;= ssin(pos:pos+N-&lt;span&gt;1&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 明天继续写&lt;/p&gt;






&lt;p&gt;《基于自适应滤波器的声学回声消除研究——冯江浩》&lt;/p&gt;

</description>
<pubDate>Sat, 19 Oct 2019 12:16:00 +0000</pubDate>
<dc:creator>凌逆战</dc:creator>
<og:description>回声就是声音信号经过一系列反射之后，又听到了自己讲话的声音，这就是回声。一些回声是必要的，比如剧院里的音乐回声以及延迟时间较短的房间回声；而大多数回声会造成负面影响，比如在有线或者无线通信时重复听到自</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/LXP-Never/p/11703440.html</dc:identifier>
</item>
<item>
<title>golang 服务平滑重启小结 - 王清培</title>
<link>http://www.cnblogs.com/wangiqngpei557/p/11704747.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangiqngpei557/p/11704747.html</guid>
<description>&lt;hr/&gt;&lt;ul&gt;&lt;li&gt;背景&lt;/li&gt;
&lt;li&gt;golang 程序平滑重启框架&lt;/li&gt;
&lt;li&gt;supervisor 出现 defunct 原因&lt;/li&gt;
&lt;li&gt;使用 master/worker 模式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在业务快速增长中，前期只是验证模式是否可行，初期忽略程序发布重启带来的暂短停机影响。当模式实验成熟之后会逐渐放量，此时我们的发布停机带来的影响就会大很多。我们整个服务都是基于云，请求流量从 四层-&amp;gt;七层-&amp;gt;机器。&lt;/p&gt;
&lt;p&gt;要想实现平滑重启大致有三种方案，一种是在流量调度的入口处理，一般的做法是 &lt;strong&gt;ApiGateway + CD&lt;/strong&gt; ，发布的时候自动摘除机器，等待程序处理完现有请求再做发布处理，这样的好处就是程序不需要关心如何做平滑重启。&lt;/p&gt;
&lt;p&gt;第二种就是程序自己完成平滑重启，保证在重启的时候 &lt;strong&gt;listen socket FD&lt;/strong&gt;（文件描述符） 依然可以接受请求进来，只不过切换新老进程，但是这个方案需要程序自己去完成，有些技术栈可能实现起来不是很简单，有些语言无法控制到操作系统级别，实现起来会很麻烦。&lt;/p&gt;
&lt;p&gt;第三种方案就是完全 &lt;strong&gt;docker&lt;/strong&gt;，所有的东西交给 &lt;strong&gt;k8s&lt;/strong&gt; 统一管理，我们正在小规模接入中。&lt;/p&gt;

&lt;p&gt;与 &lt;strong&gt;java、net&lt;/strong&gt; 等基于虚拟机的语言不同，&lt;strong&gt;golang&lt;/strong&gt; 天然支持系统级别的调用，平滑重启处理起来很容易。从原理上讲，基于 &lt;strong&gt;linux fork&lt;/strong&gt; 子进程的方式，启动新的代码，再切换 &lt;strong&gt;listen socket FD&lt;/strong&gt;，原理固然不难，但是完全自己实现还是会有很多细节问题的。好在有比较成熟的开源库帮我们实现了。&lt;/p&gt;
&lt;blockquote readability=&quot;1.0588235294118&quot;&gt;
&lt;p&gt;graceful &lt;a href=&quot;https://github.com/tylerb/graceful&quot; class=&quot;uri&quot;&gt;https://github.com/tylerb/graceful&lt;/a&gt;&lt;br/&gt;endless &lt;a href=&quot;https://github.com/fvbock/endless&quot; class=&quot;uri&quot;&gt;https://github.com/fvbock/endless&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面两个是 &lt;strong&gt;github&lt;/strong&gt; 排名靠前的 &lt;strong&gt;web host&lt;/strong&gt; 框架，都是支持平滑重启的，只不过接受的进程信号有点区别 &lt;strong&gt;endless&lt;/strong&gt; 接受 &lt;strong&gt;signal HUP&lt;/strong&gt;，&lt;strong&gt;graceful&lt;/strong&gt; 接受 &lt;strong&gt;signal USR2&lt;/strong&gt; 。&lt;strong&gt;graceful&lt;/strong&gt; 比较纯粹的 &lt;strong&gt;web host&lt;/strong&gt;，&lt;strong&gt;endless&lt;/strong&gt; 支持一些 &lt;strong&gt;routing&lt;/strong&gt; 的能力。&lt;/p&gt;
&lt;p&gt;我们看下 &lt;strong&gt;endless&lt;/strong&gt; 处理信号。（如果对 &lt;strong&gt;srv.fork()&lt;/strong&gt; 内部感兴趣可以品读品读。）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func (srv *endlessServer) handleSignals() {
    var sig os.Signal

    signal.Notify(
        srv.sigChan,
        hookableSignals...,
    )

    pid := syscall.Getpid()
    for {
        sig = &amp;lt;-srv.sigChan
        srv.signalHooks(PRE_SIGNAL, sig)
        switch sig {
        case syscall.SIGHUP:
            log.Println(pid, &quot;Received SIGHUP. forking.&quot;)
            err := srv.fork()
            if err != nil {
                log.Println(&quot;Fork err:&quot;, err)
            }
        case syscall.SIGUSR1:
            log.Println(pid, &quot;Received SIGUSR1.&quot;)
        case syscall.SIGUSR2:
            log.Println(pid, &quot;Received SIGUSR2.&quot;)
            srv.hammerTime(0 * time.Second)
        case syscall.SIGINT:
            log.Println(pid, &quot;Received SIGINT.&quot;)
            srv.shutdown()
        case syscall.SIGTERM:
            log.Println(pid, &quot;Received SIGTERM.&quot;)
            srv.shutdown()
        case syscall.SIGTSTP:
            log.Println(pid, &quot;Received SIGTSTP.&quot;)
        default:
            log.Printf(&quot;Received %v: nothing i care about...\n&quot;, sig)
        }
        srv.signalHooks(POST_SIGNAL, sig)
    }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;使用 &lt;strong&gt;supervisor&lt;/strong&gt; 管理的进程，中间需要加一层代理，原因就是 &lt;strong&gt;supervisor&lt;/strong&gt; 可以管理自己启动的进程，意思就是 &lt;strong&gt;supervisor&lt;/strong&gt; 可以拿到自己启动的进程id（PID），可以检测进程是否还存活，carsh后做自动拉起，退出时能接收到进程退出信号。&lt;/p&gt;
&lt;p&gt;但是如果我们用了平滑重启框架，原来被 &lt;strong&gt;supervisor&lt;/strong&gt; 启动的进程发布重启 __fork__子进程之后正常退出，当再次发布重启 &lt;strong&gt;fork&lt;/strong&gt; 子进程后就会变成无主进程就会出现 &lt;strong&gt;defunct(僵尸进程)&lt;/strong&gt; 的问题，原因就是此子进程无法完成退出，没有主进程来接受它退出的信号，退出进程本身的少量数据结构无法销毁。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;supervisor&lt;/strong&gt; 本身提供了 &lt;strong&gt;pidproxy&lt;/strong&gt; 程序，我们在配置 &lt;strong&gt;supervisor command&lt;/strong&gt; 时候使用 &lt;strong&gt;pidproxy&lt;/strong&gt; 来做一层代理。由于进程的id会随着不停的发布 &lt;strong&gt;fork&lt;/strong&gt; 子进程而变化，所以需要将程序的每次启动 &lt;strong&gt;PID&lt;/strong&gt; 保存在一个文件中，一般大型分布式软件都需要这样的一个文件，&lt;strong&gt;mysql&lt;/strong&gt;、&lt;strong&gt;zookeeper&lt;/strong&gt; 等，目的就是为了拿到目标进程id。&lt;/p&gt;
&lt;p&gt;这其实是一种 &lt;strong&gt;master/worker&lt;/strong&gt; 模式，&lt;strong&gt;master&lt;/strong&gt; 进程交给 &lt;strong&gt;supervisor&lt;/strong&gt; 管理，&lt;strong&gt;supervisor&lt;/strong&gt; 启动 &lt;strong&gt;master&lt;/strong&gt; 进程，也就是 &lt;strong&gt;pidproxy&lt;/strong&gt; 程序，再由 &lt;strong&gt;pidproxy&lt;/strong&gt; 来启动我们目标程序，随便我们目标程序 &lt;strong&gt;fork&lt;/strong&gt; 多少次子进程都不会影响 &lt;strong&gt;pidproxy master&lt;/strong&gt; 进程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;pidproxy&lt;/strong&gt; 依赖 &lt;strong&gt;PID&lt;/strong&gt; 文件，我们需要保证程序每次启动的时候都要写入当前进程 &lt;strong&gt;id&lt;/strong&gt; 进 &lt;strong&gt;PID&lt;/strong&gt; 文件，这样 &lt;strong&gt;pidproxy&lt;/strong&gt; 才能工作。&lt;br/&gt;&lt;strong&gt;supervisor&lt;/strong&gt; 默认的 &lt;strong&gt;pidproxy&lt;/strong&gt; 文件是不能直接使用的，我们需要适当的修改。&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Supervisor/supervisor/blob/master/supervisor/pidproxy.py&quot; class=&quot;uri&quot;&gt;https://github.com/Supervisor/supervisor/blob/master/supervisor/pidproxy.py&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;#!/usr/bin/env python

&quot;&quot;&quot; An executable which proxies for a subprocess; upon a signal, it sends that
signal to the process identified by a pidfile. &quot;&quot;&quot;

import os
import sys
import signal
import time

class PidProxy:
    pid = None
    def __init__(self, args):
        self.setsignals()
        try:
            self.pidfile, cmdargs = args[1], args[2:]
            self.command = os.path.abspath(cmdargs[0])
            self.cmdargs = cmdargs
        except (ValueError, IndexError):
            self.usage()
            sys.exit(1)

    def go(self):
        self.pid = os.spawnv(os.P_NOWAIT, self.command, self.cmdargs)
        while 1:
            time.sleep(5)
            try:
                pid = os.waitpid(-1, os.WNOHANG)[0]
            except OSError:
                pid = None
            if pid:
                break

    def usage(self):
        print(&quot;pidproxy.py &amp;lt;pidfile name&amp;gt; &amp;lt;command&amp;gt; [&amp;lt;cmdarg1&amp;gt; ...]&quot;)

    def setsignals(self):
        signal.signal(signal.SIGTERM, self.passtochild)
        signal.signal(signal.SIGHUP, self.passtochild)
        signal.signal(signal.SIGINT, self.passtochild)
        signal.signal(signal.SIGUSR1, self.passtochild)
        signal.signal(signal.SIGUSR2, self.passtochild)
        signal.signal(signal.SIGQUIT, self.passtochild)
        signal.signal(signal.SIGCHLD, self.reap)

    def reap(self, sig, frame):
        # do nothing, we reap our child synchronously
        pass

    def passtochild(self, sig, frame):
        try:
            with open(self.pidfile, 'r') as f:
                pid = int(f.read().strip())
        except:
            print(&quot;Can't read child pidfile %s!&quot; % self.pidfile)
            return
        os.kill(pid, sig)
        if sig in [signal.SIGTERM, signal.SIGINT, signal.SIGQUIT]:
            sys.exit(0)

def main():
    pp = PidProxy(sys.argv)
    pp.go()

if __name__ == '__main__':
    main()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们重点看下这个方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def go(self):
        self.pid = os.spawnv(os.P_NOWAIT, self.command, self.cmdargs)
        while 1:
            time.sleep(5)
            try:
                pid = os.waitpid(-1, os.WNOHANG)[0]
            except OSError:
                pid = None
            if pid:
                break&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;go 方法是守护方法，会拿到启动进程的id，然后做 &lt;strong&gt;waitpid&lt;/strong&gt; ，但是当我们 &lt;strong&gt;fork&lt;/strong&gt; 进程的时候主进程会退出，&lt;strong&gt;os.waitpid&lt;/strong&gt; 会收到退出信号，然后就退出了，但是这是个正常的切换逻辑。&lt;/p&gt;
&lt;p&gt;可以两个办法解决，第一个就是让 &lt;strong&gt;go&lt;/strong&gt; 方法纯粹是个守护进程，去掉退出逻辑，在信号处理方法中处理：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    def passtochild(self, sig, frame):
        pid = self.getPid()
        os.kill(pid, sig)
        time.sleep(5)
        try:
            pid = os.waitpid(self.pid, os.WNOHANG)[0]
        except OSError:
            print(&quot;wait pid null pid %s&quot;, self.pid)
        print(&quot;pid shutdown.%s&quot;, pid)
        self.pid = self.getPid()

        if self.pid == 0:
            sys.exit(0)

        if sig in [signal.SIGTERM, signal.SIGINT, signal.SIGQUIT]:
            print(&quot;exit:%s&quot;, sig)
            sys.exit(0)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还有一个方法就是修改原有go方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    def go(self):
        self.pid = os.spawnv(os.P_NOWAIT, self.command, self.cmdargs)
        while 1:
            time.sleep(5)
            try:
                pid = os.waitpid(-1, os.WNOHANG)[0]
            except OSError:
                pid = None
            try:
                with open(self.pidfile, 'r') as f:
                    pid = int(f.read().strip())
            except:
                print(&quot;Can't read child pidfile %s!&quot; % self.pidfile)
            try:
                os.kill(pid, 0)
            except OSError:
                sys.exit(0)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然还可以用其他方法或者思路，这里只是抛出问题。如果你想知道真正问题在哪里，可以直接在本地 &lt;strong&gt;debug pidproxy&lt;/strong&gt; 脚本文件，还是比较有意思的，知道真正问题在哪里如何修改，就完全由你来发挥了。&lt;/p&gt;
&lt;p&gt;作者：王清培 （趣头条 Tech Leader）&lt;/p&gt;
</description>
<pubDate>Sat, 19 Oct 2019 10:33:00 +0000</pubDate>
<dc:creator>王清培</dc:creator>
<og:description>背景 golang 程序平滑重启框架 supervisor 出现 defunct 原因 使用 master/worker 模式 背景 在业务快速增长中，前期只是验证模式是否可行，初期忽略程序发布重启带</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wangiqngpei557/p/11704747.html</dc:identifier>
</item>
<item>
<title>Android OkHttp + Retrofit 下载文件与进度监听 - RustFisher</title>
<link>http://www.cnblogs.com/rustfisher/p/11704563.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rustfisher/p/11704563.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://rustfisher.com/2019/10/18/Android/Android-OkHttp_Retrofit_download_file/&quot;&gt;本文链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下载文件是一个比较常见的需求。给定一个url，我们可以&lt;a href=&quot;https://rustfisher.com/2019/09/23/Android/Android-Media_download_stream_file/&quot;&gt;使用URLConnection下载文件&lt;/a&gt;。&lt;br/&gt;使用OkHttp也可以通过流来下载文件。&lt;br/&gt;给OkHttp中添加拦截器，即可实现下载进度的监听功能。&lt;/p&gt;
&lt;h2 id=&quot;使用流来实现下载文件&quot;&gt;使用流来实现下载文件&lt;/h2&gt;
&lt;p&gt;代码可以参考：https://github.com/RustFisher/android-Basic4/tree/master/appdowloadsample&lt;/p&gt;
&lt;p&gt;获取并使用字节流，需要注意两个要点，一个是服务接口方法的 @Streaming 注解，另一个是获取到ResponseBody。&lt;/p&gt;
&lt;p&gt;获取流（Stream）。先定义一个服务ApiService。给方法添加上@Streaming的注解。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    private interface ApiService {
        @Streaming
        @GET
        Observable&amp;lt;ResponseBody&amp;gt; download(@Url String url);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;初始化OkHttp。记得填入你的baseUrl。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    OkHttpClient okHttpClient = new OkHttpClient.Builder()
            .connectTimeout(8, TimeUnit.SECONDS)
            .build();

    retrofit = new Retrofit.Builder()
            .client(okHttpClient)
            .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
            .baseUrl(&quot;https://yourbaseurl.com&quot;)
            .build();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;发起网络请求。获取到ResponseBody。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    String downUrl = &quot;xxx.com/aaa.apk&quot;;
    retrofit.create(ApiService.class)
            .download(downUrl)
            .subscribeOn(Schedulers.io())
            .observeOn(Schedulers.io())
            .doOnNext(new Consumer&amp;lt;ResponseBody&amp;gt;() {
                @Override
                public void accept(ResponseBody responseBody) throws Exception {
                    // 处理 ResponseBody 中的流
                }
            })
            .doOnError(new Consumer&amp;lt;Throwable&amp;gt;() {
                @Override
                public void accept(Throwable throwable) throws Exception {
                    Log.e(TAG, &quot;accept on error: &quot; + downUrl, throwable);
                }
            })
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe(new Observer&amp;lt;ResponseBody&amp;gt;() {
                @Override
                public void onSubscribe(Disposable d) {

                }

                @Override
                public void onNext(ResponseBody responseBody) {

                }

                @Override
                public void onError(Throwable e) {
                    Log.e(TAG, &quot;Download center retrofit onError: &quot;, e);
                }

                @Override
                public void onComplete() {

                }
            });&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过ResponseBody拿到字节流 body.byteStream()。这里会先创建一个临时文件tmpFile，把数据写到临时文件里。&lt;br/&gt;下载完成后再重命名成目标文件targetFile。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    public void saveFile(ResponseBody body) {
        state = DownloadTaskState.DOWNLOADING;
        byte[] buf = new byte[2048];
        int len;
        FileOutputStream fos = null;
        try {
            Log.d(TAG, &quot;saveFile: body content length: &quot; + body.contentLength());
            srcInputStream = body.byteStream();
            File dir = tmpFile.getParentFile();
            if (dir == null) {
                throw new FileNotFoundException(&quot;target file has no dir.&quot;);
            }
            if (!dir.exists()) {
                boolean m = dir.mkdirs();
                onInfo(&quot;Create dir &quot; + m + &quot;, &quot; + dir);
            }
            File file = tmpFile;
            if (!file.exists()) {
                boolean c = file.createNewFile();
                onInfo(&quot;Create new file &quot; + c);
            }
            fos = new FileOutputStream(file);
            long time = System.currentTimeMillis();
            while ((len = srcInputStream.read(buf)) != -1 &amp;amp;&amp;amp; !isCancel) {
                fos.write(buf, 0, len);
                int duration = (int) (System.currentTimeMillis() - time);

                int overBytes = len - downloadBytePerMs() * duration;
                if (overBytes &amp;gt; 0) {
                    try {
                        Thread.sleep(overBytes / downloadBytePerMs());
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
                time = System.currentTimeMillis();
                if (isCancel) {
                    state = DownloadTaskState.CLOSING;
                    srcInputStream.close();
                    break;
                }
            }
            if (!isCancel) {
                fos.flush();
                boolean rename = tmpFile.renameTo(targetFile);
                if (rename) {
                    setState(DownloadTaskState.DONE);
                    onSuccess(url);
                } else {
                    setState(DownloadTaskState.ERROR);
                    onError(url, new Exception(&quot;Rename file fail. &quot; + tmpFile));
                }
            }
        } catch (FileNotFoundException e) {
            Log.e(TAG, &quot;saveFile: FileNotFoundException &quot;, e);
            setState(DownloadTaskState.ERROR);
            onError(url, e);
        } catch (Exception e) {
            Log.e(TAG, &quot;saveFile: IOException &quot;, e);
            setState(DownloadTaskState.ERROR);
            onError(url, e);
        } finally {
            try {
                if (srcInputStream != null) {
                    srcInputStream.close();
                }
                if (fos != null) {
                    fos.close();
                }
            } catch (IOException e) {
                Log.e(TAG, &quot;saveFile&quot;, e);
            }
            if (isCancel) {
                onCancel(url);
            }
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;每次读数据的循环，计算读了多少数据和用了多少时间。超过限速后主动sleep一下，达到控制下载速度的效果。&lt;br/&gt;要注意不能sleep太久，以免socket关闭。&lt;br/&gt;这里控制的是网络数据流与本地文件的读写速度。&lt;/p&gt;
&lt;h2 id=&quot;下载进度监听&quot;&gt;下载进度监听&lt;/h2&gt;
&lt;p&gt;OkHttp实现下载进度监听，可以从字节流的读写那里入手。也可以使用拦截器，参考&lt;a href=&quot;https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/Progress.java&quot;&gt;官方的例子&lt;/a&gt;。&lt;br/&gt;这里用拦截器的方式实现网络下载进度监听功能。&lt;/p&gt;
&lt;h3 id=&quot;定义回调与网络拦截器&quot;&gt;定义回调与网络拦截器&lt;/h3&gt;
&lt;p&gt;先定义回调。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface ProgressListener {
    void update(String url, long bytesRead, long contentLength, boolean done);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;自定义ProgressResponseBody。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ProgressResponseBody extends ResponseBody {

    private final ResponseBody responseBody;
    private final ProgressListener progressListener;
    private BufferedSource bufferedSource;
    private final String url;

    ProgressResponseBody(String url, ResponseBody responseBody, ProgressListener progressListener) {
        this.responseBody = responseBody;
        this.progressListener = progressListener;
        this.url = url;
    }

    @Override
    public MediaType contentType() {
        return responseBody.contentType();
    }

    @Override
    public long contentLength() {
        return responseBody.contentLength();
    }

    @Override
    public BufferedSource source() {
        if (bufferedSource == null) {
            bufferedSource = Okio.buffer(source(responseBody.source()));
        }
        return bufferedSource;
    }

    private Source source(final Source source) {
        return new ForwardingSource(source) {
            long totalBytesRead = 0L;

            @Override
            public long read(Buffer sink, long byteCount) throws IOException {
                long bytesRead = super.read(sink, byteCount);
                // read() returns the number of bytes read, or -1 if this source is exhausted.
                totalBytesRead += bytesRead != -1 ? bytesRead : 0;
                progressListener.update(url, totalBytesRead, responseBody.contentLength(), bytesRead == -1);
                return bytesRead;
            }
        };
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;定义拦截器。从Response中获取信息。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ProgressInterceptor implements Interceptor {

    private ProgressListener progressListener;

    public ProgressInterceptor(ProgressListener progressListener) {
        this.progressListener = progressListener;
    }

    @NotNull
    @Override
    public Response intercept(@NotNull Chain chain) throws IOException {
        Response originalResponse = chain.proceed(chain.request());
        return originalResponse.newBuilder()
                .body(new ProgressResponseBody(chain.request().url().url().toString(), originalResponse.body(), progressListener))
                .build();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;添加拦截器&quot;&gt;添加拦截器&lt;/h3&gt;
&lt;p&gt;在创建OkHttpClient时添加ProgressInterceptor。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    OkHttpClient okHttpClient = new OkHttpClient.Builder()
            .connectTimeout(8, TimeUnit.SECONDS)
            .addInterceptor(new ProgressInterceptor(new ProgressListener() {
                @Override
                public void update(String url, long bytesRead, long contentLength, boolean done) {
                    // tellProgress(url, bytesRead, contentLength, done);
                }
            }))
            .build();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;值得注意的是这里的进度更新非常频繁。并不一定每次回调都要去更新UI。&lt;/p&gt;
</description>
<pubDate>Sat, 19 Oct 2019 09:30:00 +0000</pubDate>
<dc:creator>RustFisher</dc:creator>
<og:description>'本文链接' 下载文件是一个比较常见的需求。给定一个url，我们可以 '使用URLConnection下载文件' 。 使用OkHttp也可以通过流来下载文件。 给OkHttp中添加拦截器，即可实现下载</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/rustfisher/p/11704563.html</dc:identifier>
</item>
<item>
<title>通俗易懂设计模式解析——访问者模式 - 小世界的野孩子</title>
<link>http://www.cnblogs.com/hulizhong/p/11704390.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hulizhong/p/11704390.html</guid>
<description>&lt;h2&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　今天我们看的是访问者模式【Visitor Pattern&lt;a href=&quot;https://www.cnblogs.com/PatrickLiu/p/8135083.html&quot;&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/a&gt;】，我们理解访问者模式这个名称可能会有利于我们理解其核心代码块。我们看这么个例子：我去朋友家做客，那么朋友属于主人，我则属于访问者。这时刚好朋友在炒菜，却没得酱油了。如果朋友下去买酱油将会很麻烦而且会影响炒菜。这时就到我这个访问者出马了。一溜烟的出去打着酱油就回来了。简单理解的来说就是，访问者在主人原来的基础上帮助主人去完成主人不方便或者完不成的东西。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;访问者模式介绍&lt;/strong&gt;&lt;/h2&gt;
&lt;h3&gt;一、&lt;strong&gt;来由&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　在软件系统开发中，我们经常会遇见一些层次结构完好的代码因为需求的更改而更改。你说这个时候我更改其基类吧，所有子类都要更改、这是一件很麻烦的事情。那么我能不能在不修改器层次结构完整的前提下完成新的需求的更改呢？&lt;/p&gt;
&lt;h3&gt;二、&lt;strong&gt;意图&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　表示一个作用于某对象结构中的各个元素的操作。它可以在不改变各元素的类的前提下定义作用于这些元素的新的操作。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;三、&lt;strong&gt;案例图&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1470432/201910/1470432-20191019164347122-1768367025.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;四、&lt;strong&gt;访问者模式代码示例&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;看上面案例图可以发现访问者模式包含以下部分：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;结构对象：&lt;/strong&gt;&lt;strong&gt;节点的容器，包含多个类或者接口&lt;/strong&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;strong&gt;抽象节点：&lt;/strong&gt;&lt;strong&gt;声明一个接收操作，接收访问者对象作为参数，声明处理接口，处理节点数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;具体节点：&lt;/strong&gt;&lt;strong&gt;实现抽象节点的接收操作和处理操作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;抽象访问者：&lt;/strong&gt;&lt;strong&gt;声明一个或多个访问操作，使得所有具体访问者都必须实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;具体访问者：&lt;/strong&gt;&lt;strong&gt;实现抽象访问者声明的接口&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们看这么一个需求，我们需要计算图形的面积并输出、图形包括长方形圆形。我们一起看看代码实现吧：&lt;/p&gt;
&lt;p&gt;　　首先我们看不采用访问者模式实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Visitor_Pattern
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; VisitorPattern
    {
    }

    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 抽象节点类
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Element 
    {
       &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; CalculatedArea();
    }

    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 长方形计算面积输出
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Rectangle : Element
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; _long;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; _wide;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;  Rectangle(&lt;span&gt;double&lt;/span&gt; Long, &lt;span&gt;double&lt;/span&gt;&lt;span&gt; Wide) 
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._long =&lt;span&gt; Long;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._wide =&lt;span&gt; Wide;
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; CalculatedArea()
        {
            Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;长方形面积是：{_long*_wide}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }

    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 圆形计算面积输出
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Circular : Element
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; _r; 

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Circular(&lt;span&gt;double&lt;/span&gt;&lt;span&gt; r)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._r =&lt;span&gt; r; 
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; CalculatedArea()
        {
            Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;圆形面积是：{Math.PI * _r*_r}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }

    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 结构对象
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Graphical 
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;Element&amp;gt; elements = &lt;span&gt;new&lt;/span&gt; List&amp;lt;Element&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;Element&amp;gt;&lt;span&gt; Elements
        {
            &lt;/span&gt;&lt;span&gt;get&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; elements; }
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Graphical() 
        {
            Element element &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Rectangle(&lt;span&gt;10&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;&lt;span&gt;);
            Element element1&lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Circular(&lt;span&gt;5&lt;/span&gt;&lt;span&gt;);
            elements.Add(element);
            elements.Add(element1);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Visitor_Pattern
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            Graphical graphical &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Graphical();
            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; graphical.Elements)
            {
                item.CalculatedArea();
            }

        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1470432/201910/1470432-20191019164332507-750093939.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　我们可以看到实现起来还是较为简单的。但是如果这里需求进行了变动，需要加上图形的周长并且输出、同时输出其参数。这就麻烦了。就需要对基类进行更改然后修改子类。就感觉有点得不偿失了。&lt;/p&gt;
&lt;p&gt;　　我们再看采用模式实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Visitor_Pattern
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; UseVisitorPattern
    {
    }

    &lt;/span&gt;&lt;span&gt;#region&lt;/span&gt; 访问者

    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 抽象访问者
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IVistor 
    {
        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; Visit(UseRectangle rectangle);
        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; Visit(UseCircular  useCircular);
    }

    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 具体访问者
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Vistor : IVistor
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Visit(UseRectangle rectangle)
        {
            rectangle.CalculatedArea();
            Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;长方形长是：{rectangle._long}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;长方形宽是：{rectangle._wide}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;长方形周长是：{2*(rectangle._long+rectangle._wide)}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Visit(UseCircular useCircular)
        {
            useCircular.CalculatedArea();
            Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;圆形的半径是：{useCircular._r}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;圆形的周长是是：{2*Math.PI*useCircular._r}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }

    &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;

    &lt;span&gt;#region&lt;/span&gt; 节点类

    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 抽象节点类
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UseElement
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Accept(IVistor vistor);
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; CalculatedArea();
    }

    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 长方形计算面积输出
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UseRectangle : UseElement
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; _long;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; _wide;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; UseRectangle(&lt;span&gt;double&lt;/span&gt; Long, &lt;span&gt;double&lt;/span&gt;&lt;span&gt; Wide)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._long =&lt;span&gt; Long;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._wide =&lt;span&gt; Wide;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Accept(IVistor vistor)
        {
            vistor.Visit(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; CalculatedArea()
        {
            Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;长方形面积是：{_long * _wide}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }

    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 圆形计算面积输出
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UseCircular : UseElement
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; _r;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; UseCircular(&lt;span&gt;double&lt;/span&gt;&lt;span&gt; r)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._r =&lt;span&gt; r;
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Accept(IVistor vistor)
        {
            vistor.Visit(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; CalculatedArea()
        {
            Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;圆形面积是：{Math.PI * _r * _r}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }

    &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;

    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 结构对象
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UseGraphical
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;UseElement&amp;gt; elements = &lt;span&gt;new&lt;/span&gt; List&amp;lt;UseElement&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;UseElement&amp;gt;&lt;span&gt; Elements
        {
            &lt;/span&gt;&lt;span&gt;get&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; elements; }
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; UseGraphical()
        {
            UseElement element &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; UseRectangle(&lt;span&gt;10&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;&lt;span&gt;);
            UseElement element1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; UseCircular(&lt;span&gt;5&lt;/span&gt;&lt;span&gt;);
            elements.Add(element);
            elements.Add(element1);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Visitor_Pattern
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {

            UseGraphical graphical &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UseGraphical();
            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; graphical.Elements)
            {
                item.Accept(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vistor());
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1470432/201910/1470432-20191019164416621-1594962320.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这里我们对每个节点都加入了访问者，这样我们需求变动增加周长和参数的输出的时候修改增加具体访问者就可以实现了。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;使用场景及优缺点&lt;/strong&gt;&lt;/h2&gt;
&lt;h3&gt;一、&lt;strong&gt;使用场景&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1、对象结构中对象对应的类较少改变、但是会经常在此对象结构上定义新的操作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、需要对一个对象结构中进行一些不相关的操作、需要在新增操作时避免改变其原来的类&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;二、&lt;strong&gt;优点&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1、符合单一职责原则。每个类负责一个职责&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、具有优秀的扩展性和灵活性、添加新的操作会变得较为容易、同时也不会改变其原来的结构代码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、访问者模式将一些相关的行为操作集合在了访问者对象中，并没有分散在其元素类中&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;三、&lt;strong&gt;缺点&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1、具体元素对访问者公开了细节，违背了迪米特原则&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、增加具体元素节点变得困难、与之随之增加的就是在访问者中新增。&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　访问者模式就介绍到这里啦。访问者模式主要是将数据结构及操作分离、解决了稳定的数据结构和容易变化的操作的耦合性。在新增操作的时候不修改原来的结构对象的类。直接修改访问者对象中的操作即可新增操作。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt; 　　　　 &lt;span&gt;&lt;strong&gt;如果我们想要更多的玫瑰花，就必须种植更多的玫瑰树。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　&lt;strong&gt;&lt;strong&gt;　　　&lt;a href=&quot;https://www.cnblogs.com/hulizhong/p/11394686.html&quot; target=&quot;_blank&quot;&gt;C#设计模式系列目录&lt;/a&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;　 　　欢迎大家扫描下方二维码，&lt;/strong&gt;和我一起踏上设计模式的闯关之路吧!&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1470432/201907/1470432-20190718162718327-1175594568.jpg&quot; alt=&quot;&quot; width=&quot;278&quot; height=&quot;278&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 19 Oct 2019 08:54:00 +0000</pubDate>
<dc:creator>小世界的野孩子</dc:creator>
<og:description>前言 今天我们看的是访问者模式【Visitor Pattern&amp;#160;】，我们理解访问者模式这个名称可能会有利于我们理解其核心代码块。我们看这么个例子：我去朋友家做客，那么朋友属于主人，我则属于访</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hulizhong/p/11704390.html</dc:identifier>
</item>
<item>
<title>数据存储检索之B+树和LSM-Tree - XIAO的博客</title>
<link>http://www.cnblogs.com/xiaodf/p/11704328.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaodf/p/11704328.html</guid>
<description>&lt;p&gt;作为一名应用系统开发人员，为什么要关注数据内部的存储和检索呢？首先，你不太可能从头开始实现一套自己的存储引擎，往往需要从众多现有的存储引擎中选择一个适合自己应用的存储引擎。因此，为了针对你特定的工作负载而对数据库调优时，最好对存储引擎的底层机制有一个大概的了解。&lt;/p&gt;
&lt;p&gt;今天我们就先来了解下关系型数据库MySQL和NoSQL存储引擎HBase的底层存储机制。对于一个数据库的性能来说，其数据的组织方式至关重要。众所周知，数据库的数据大多存储在磁盘上，而磁盘的访问相对内存的访问来说是一项很耗时的操作，对比如下。因此，提高数据库数据的查找速度的关键点之一便是尽量减少磁盘的访问次数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/852983/201910/852983-20191019163245508-309613004.jpg&quot;/&gt;&lt;br/&gt;磁盘与内存的访问速度对比&lt;/p&gt;
&lt;p&gt;为了加速数据库数据的访问，大多传统的关系型数据库都会使用特殊的数据结构来帮助查找数据，这种数据结构叫作索引（ Index）。对于传统的关系型数据库，考虑到经常需要范围查找某一批数据，因此其索引一般不使用 Hash算法，而使用树（ Tree）结构。然而，树结构的种类很多，却不一定都适合用于做数据库索引。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二叉查找树与平衡二叉树&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最常见的树结构是二叉查找树（ Binary Search Tree），它就是一棵二叉有序树：保证左子树上所有节点的值都小于根节点的值，而右子树上所有节点的值都大于根节点的值。其优点在于实现简单，并且树在平衡的状态下查找效率能达到 O(log n)；缺点是在极端非平衡情况下查找效率会退化到 O(n)，因此很难保证索引的效率。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/852983/201910/852983-20191019163245802-221628220.jpg&quot;/&gt;&lt;br/&gt;二叉查找树的查找效率&lt;/p&gt;
&lt;p&gt;针对上述二叉查找树的缺点，人们很自然就想到是否能用平衡二叉树（ Balanced Binary Tree）来解决这个问题。但是平衡二叉树依然有个比较大的问题：它的树高为 log n——对于索引树来说，树的高度越高，意味着查找所要花费的访问次数越多，查询效率越低。&lt;/p&gt;
&lt;p&gt;况且，主存从磁盘读数据一般以页为单位，因此每次访问磁盘都会读取多个扇区的数据（比如 4KB大小的数据），远大于单个二叉树节点的值（字节级别），这也是造成二叉树相对索引树效率低下的原因。正因如此，人们就想到了通过增加每个树节点的度来提高访问效率，而 B+树（B+-tree）便受到了更多的关注。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;B+树&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在传统的关系型数据库里， B+树（ B+-tree）及其衍生树是被用得比较多的索引树。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/852983/201910/852983-20191019163245973-480785134.jpg&quot;/&gt;&lt;br/&gt;B+树&lt;/p&gt;
&lt;p&gt;B+树的主要特点如下。&lt;br/&gt;每个树节点只存放键值，不存放数值，而由叶子节点存放数值。这样会使树节点的度比较大，而树的高度就比较低，从而有利于提高查询效率。&lt;br/&gt;叶子节点存放数值，并按照值大小顺序排序，且带指向相邻节点的指针，以便高效地进行区间数据查询；并且所有叶子节点与根节点的距离相同，因此任何查询的效率都很相似。&lt;br/&gt;与二叉树不同， B+树的数据更新操作不从根节点开始，而从叶子节点开始，并且在更新过程中树能以比较小的代价实现自平衡。&lt;/p&gt;
&lt;p&gt;正是由于 B+树的上述优点，它成了传统关系型数据库的宠儿。当然，它也并非无懈可击，它的主要缺点在于随着数据插入的不断发生，叶子节点会慢慢分裂——这可能会导致逻辑上原本连续的数据实际上存放在不同的物理磁盘块位置上，在做范围查询的时候会导致较高的磁盘 IO，以致严重影响到性能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;日志结构合并树&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;众所周知，数据库的数据大多存储在磁盘上，而无论是传统的机械硬盘（ HardDiskDrive, HDD）还是固态硬盘（ Solid State Drive, SSD），对磁盘数据的顺序读写速度都远高于随机读写。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/852983/201910/852983-20191019163246389-1351495085.jpg&quot;/&gt;&lt;br/&gt;磁盘顺序与随机访问吞吐对比&lt;/p&gt;
&lt;p&gt;然而，基于 B+树的索引结构是违背上述磁盘基本特点的——它会需要较多的磁盘随机读写，于是， 1992年，名为日志结构（ Log-Structured）的新型索引结构方法便应运而生。日志结构方法的主要思想是将磁盘看作一个大的日志，每次都将新的数据及其索引结构添加到日志的最末端，以实现对磁盘的顺序操作，从而提高索引性能。不过，日志结构方法也有明显的缺点，随机读取数据时效率很低。&lt;/p&gt;
&lt;p&gt;1996年，一篇名为 Thelog-structured merge-tree（LSM-tree）的论文创造性地提出了日志结构合并树（ Log-Structured Merge-Tree）的概念，该方法既吸收了日志结构方法的优点，又通过将数据文件预排序克服了日志结构方法随机读性能较差的问题。尽管当时 LSM-tree新颖且优势鲜明，但它真正声名鹊起却是在 10年之后的 2006年，那年谷歌的一篇使用了 LSM-tree技术的论文 Bigtable: A Distributed Storage System for Structured Data横空出世，在分布式数据处理领域掀起了一阵旋风，随后两个声名赫赫的大数据开源组件（ 2007年的 HBase与 2008年的 Cassandra，目前两者同为 Apache顶级项目）直接在其思想基础上破茧而出，彻底改变了大数据基础组件的格局，同时也极大地推广了 LSM-tree技术。&lt;/p&gt;
&lt;p&gt;LSM-tree最大的特点是同时使用了两部分类树的数据结构来存储数据，并同时提供查询。其中一部分数据结构（ C0树）存在于内存缓存（通常叫作 memtable）中，负责接受新的数据插入更新以及读请求，并直接在内存中对数据进行排序；另一部分数据结构（ C1树）存在于硬盘上 (这部分通常叫作 sstable)，它们是由存在于内存缓存中的 C0树冲写到磁盘而成的，主要负责提供读操作，特点是有序且不可被更改。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/852983/201910/852983-20191019163246525-1002116006.jpg&quot;/&gt;&lt;br/&gt;LSM-tree的 C0与 C1部分&lt;/p&gt;
&lt;p&gt;LSM-tree的另一大特点是除了使用两部分类树的数据结构外，还会使用日志文件（通常叫作 commit log）来为数据恢复做保障。这三类数据结构的协作顺序一般是：所有的新插入与更新操作都首先被记录到 commit log中——该操作叫作 WAL（Write Ahead Log），然后再写到 memtable，最后当达到一定条件时数据会从 memtable冲写到 sstable，并抛弃相关的 log数据； memtable与 sstable可同时供查询；当 memtable出问题时，可从 commit log与 sstable中将 memtable的数据恢复。&lt;/p&gt;
&lt;p&gt;我们可以参考 HBase的架构来体会其架构中基于 LSM-tree的部分特点。按照 WAL的原则，数据首先会写到 HBase的 HLog(相当于 commit log)里，然后再写到 MemStore（相当于 memtable）里，最后会冲写到磁盘 StoreFile（相当于 sstable）中。这样 HBase的 HRegionServer就通过 LSM-tree实现了数据文件的生成。HBase LSM-tree架构示意图如下图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/852983/201910/852983-20191019163247530-812799018.jpg&quot;/&gt;&lt;br/&gt;HBase LSM-tree架构示意图&lt;/p&gt;
&lt;p&gt;LSM-tree的这种结构非常有利于数据的快速写入（理论上可以接近磁盘顺序写速度），但是不利于读——因为理论上读的时候可能需要同时从 memtable和所有硬盘上的 sstable中查询数据，这样显然会对性能造成较大的影响。为了解决这个问题， LSM-tree采取了以下主要的相关措施。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;定期将硬盘上小的 sstable合并（通常叫作 Merge或 Compaction操作）成大的 sstable，以减少 sstable的数量。而且，平时的数据更新删除操作并不会更新原有的数据文件，只会将更新删除操作加到当前的数据文件末端，只有在 sstable合并的时候才会真正将重复的操作或更新去重、合并。&lt;/li&gt;
&lt;li&gt;对每个 sstable使用布隆过滤器（ Bloom Filter），以加速对数据在该 sstable的存在性进行判定，从而减少数据的总查询时间。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;LSM树和B+树的差异主要在于读性能和写性能进行权衡，在牺牲的同时寻找其余补救方案。&lt;/p&gt;
&lt;p&gt;B+树存储引擎，不仅支持单条记录的增、删、读、改操作，还支持顺序扫描（B+树的叶子节点之间的指针），对应的存储系统就是关系数据库。但随着写入操作增多，为了维护B+树结构，节点分裂，读磁盘的随机读写概率会变大，性能会逐渐减弱。LSM树（Log-Structured MergeTree）存储引擎和B+树存储引擎一样，同样支持增、删、读、改、顺序扫描操作。而且通过批量存储技术规避磁盘随机写入问题。当然凡事有利有弊，LSM树和B+树相比，LSM树牺牲了部分读性能，用来大幅提高写性能。&lt;/p&gt;
&lt;p&gt;订阅关注微信公众号《大数据技术进阶》，及时获取更多大数据架构和应用相关技术文章！&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/852983/201909/852983-20190930181646477-1821684704.png&quot; width=&quot;95%&quot; height=&quot;95%&quot; align=&quot;center&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 19 Oct 2019 08:33:00 +0000</pubDate>
<dc:creator>XIAO的博客</dc:creator>
<og:description>作为一名应用系统开发人员，为什么要关注数据内部的存储和检索呢？首先，你不太可能从头开始实现一套自己的存储引擎，往往需要从众多现有的存储引擎中选择一个适合自己应用的存储引擎。因此，为了针对你特定的工作负</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiaodf/p/11704328.html</dc:identifier>
</item>
</channel>
</rss>