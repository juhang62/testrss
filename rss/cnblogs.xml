<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>ASP.NET Core应用基本编程模式[2]：依赖注入 - Artech</title>
<link>http://www.cnblogs.com/artech/p/asp-net-core-program-model-2.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/artech/p/asp-net-core-program-model-2.html</guid>
<description>&lt;p&gt;基于IHostBuilder/IHost的服务承载系统建立在依赖注入框架之上，它在服务承载过程中依赖的服务（包括作为宿主的IHost对象）都由代表依赖注入容器的IServiceProvider对象提供。在定义承载服务时，也可以采用依赖注入方式来消费它所依赖的服务。作为依赖注入容器的IServiceProvider对象能否提供我们需要的服务实例，取决于相应的服务注册是否预先添加到依赖注入框架中。服务注册可以通过调用IHostBuilder接口或者IWebHostBuilder接口相应的方法来完成，前者在《&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-09-01.html&quot;&gt;服务承载系统&lt;/a&gt;》已经有详细介绍，下面介绍基于IWebHostBuilder接口的服务注册。[本文节选自《ASP.NET Core 3框架揭秘》第11章, 更多关于ASP.NET Core的文章请点&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-3.html&quot;&gt;这里&lt;/a&gt;]&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;目录&lt;br/&gt;一、服务注册&lt;br/&gt;二、服务的消费&lt;br/&gt;    在Startup中注入服务&lt;br/&gt;     在中间件中注入服务   &lt;br/&gt;三、生命周期&lt;br/&gt;    两个IServiceProvider对象&lt;br/&gt;     基于服务范围的验证&lt;br/&gt;四、集成第三方依赖注入框架&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;ASP.NET Core应用提供了两种服务注册方式，一种是调用IWebHostBuilder接口的ConfigureServices方法。如下面的代码片段所示，IWebHostBuilder定义了两个Configure&lt;br/&gt;Services方法重载，它们的参数类型分别是Action&amp;lt;IServiceCollection&amp;gt;和Action&amp;lt;WebHostBuilderContext, IServiceCollection&amp;gt;，我们注册的服务最终会被添加到作为这两个委托对象输入的IServiceCollection集合中。WebHostBuilderContext代表当前IWebHostBuilder在构建WebHost过程中采用的上下文，我们可以利用它得到当前应用的配置和与承载环境相关的信息。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IWebHostBuilder
{
    IWebHostBuilder ConfigureServices(Action&lt;/span&gt;&amp;lt;IServiceCollection&amp;gt;&lt;span&gt; configureServices);
    IWebHostBuilder ConfigureServices(Action&lt;/span&gt;&amp;lt;WebHostBuilderContext, IServiceCollection&amp;gt;&lt;span&gt; configureServices);
    ...
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WebHostBuilderContext
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IConfiguration Configuration { &lt;span&gt;get&lt;/span&gt;;  &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IWebHostEnvironment  HostingEnvironment { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;除了直接调用IWebHostBuilder接口的ConfigureServices方法注册服务，还可以利用注册的Startup类型来完成服务的注册。所谓的Startup类型就是通过调用如下两个扩展方法注册到IWebHostBuilder接口上用来对应用程序进行初始化的。由于ASP.NET Core应用针对请求的处理能力与方式完全取决于注册的中间件，所以这里所谓的针对应用程序的初始化主要体现在针对中间件的注册上。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WebHostBuilderExtensions
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IWebHostBuilder UseStartup&amp;lt;TStartup&amp;gt;(&lt;span&gt;this&lt;/span&gt; IWebHostBuilder hostBuilder)  &lt;span&gt;where&lt;/span&gt; TStartup: &lt;span&gt;class&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IWebHostBuilder UseStartup(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; IWebHostBuilder hostBuilder, Type startupType);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于注册的中间件来说，它往往具有针对其他服务的依赖。当ASP.NET Core框架在创建具体的中间件对象时，会利用依赖注入框架来提供注入的依赖服务。中间件依赖的这些服务自然需要被预先注册，所以中间件和服务注册成为Startup对象的两个核心功能。与中间件类型类似，我们在大部分情况下会采用约定的形式来定义Startup类型。如下所示的代码片段就是一个典型的Startup的定义，中间件和服务的注册分别实现在Configure方法和ConfigureServices方法中。由于并不是在任何情况下都有服务注册的需求，所以ConfigureServices方法并不是必需的。Startup对象的ConfigureServices方法的调用发生在整个服务注册的最后阶段，在此之后，ASP.NET Core应用就会利用所有的服务注册来创建作为依赖注入容器的IServiceProvider对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Startup
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection servives);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuidler app);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;除了可以采用上述两种方式为应用程序注册所需的服务，ASP.NET Core框架本身在构建请求处理管道之前也会注册一些服务，这些公共服务除了供框架自身消费，也可以供应用程序使用。那么ASP.NET Core框架究竟预先注册了哪些服务？为了得到这个问题的答案，我们编写了如下这段简单的程序。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
    {
        Host.CreateDefaultBuilder().ConfigureWebHostDefaults(builder &lt;/span&gt;=&amp;gt; builder.UseStartup&amp;lt;Startup&amp;gt;&lt;span&gt;())
        .Build()
        .Run();
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Startup
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; provider =&lt;span&gt; services.BuildServiceProvider();
        &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; service &lt;span&gt;in&lt;/span&gt;&lt;span&gt; services)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; serviceTypeName =&lt;span&gt; GetName(service.ServiceType);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; implementationType =&lt;span&gt; service.ImplementationType 
                    &lt;/span&gt;?? service.ImplementationInstance?&lt;span&gt;.GetType()
                    &lt;/span&gt;?? service.ImplementationFactory?.Invoke(provider)?&lt;span&gt;.GetType();                
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (implementationType != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{service.Lifetime,-15} {GetName(service.ServiceType),-50}{GetName(implementationType)}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
        }
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app) { }
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; GetName(Type type)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;type.IsGenericType)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; type.Name;
        }
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; name = type.Name.Split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;`&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; args = type.GetGenericArguments().Select(it =&amp;gt;&lt;span&gt; it.Name);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{name}&amp;lt;{string.Join(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, args)}&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在如上所示的Startup类型的ConfigureServices方法中，我们从作为参数的IServiceCollection对象中获取当前注册的所有服务，并打印每个服务对应的声明类型、实现类型和生命周期。这段程序执行之后，系统注册的所有公共服务会以图11-7所示的方式输出到控制台上，我们可以从这个列表中发现很多熟悉的类型。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/19327/202011/19327-20201112084605495-1151389289.png&quot;&gt;&lt;img width=&quot;621&quot; height=&quot;497&quot; title=&quot;7&quot; alt=&quot;7&quot; src=&quot;https://img2020.cnblogs.com/blog/19327/202011/19327-20201112084606485-942453320.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ASP.NET Core框架中的很多核心对象都是通过依赖注入方式提供的，如用来对应用进行初始化的Startup对象、中间件对象，以及ASP.NET Core MVC应用中的Controller对象和View对象等，所以我们可以在定义它们的时候采用注入的形式来消费已经注册的服务。下面简单介绍几种服务注入的应用场景。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在Startup中注入服务&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;构成HostBuilderContext上下文的两个核心对象（表示配置的IConfiguration对象和表示承载环境的IHostEnvironment对象）可以直接注入Startup构造函数中进行消费。由于ASP.NET Core应用中的承载环境通过IWebHostEnvironment接口表示，IWebHostEnvironment接口派生于IHostEnvironment接口，所以也可以通过注入IWebHostEnvironment对象的方式得到当前承载环境相关的信息。&lt;/p&gt;
&lt;p&gt;我们可以通过一个简单的实例来验证针对Startup的构造函数注入。如下面的代码片段所示，我们在调用IWebHostBuilder接口的Startup&amp;lt;TStartup&amp;gt;方法时注册了自定义的Startup类型。在定义Startup类型时，我们在其构造函数中注入上述3个对象，提供的调试断言不仅证明了3个对象不为Null，还表明采用IHostEnvironment接口和IWebHostEnvironment接口得到的其实是同一个实例。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
    {
        Host.CreateDefaultBuilder().ConfigureWebHostDefaults(builder &lt;/span&gt;=&amp;gt; builder.UseStartup&amp;lt;Startup&amp;gt;&lt;span&gt;())
        .Build()
        .Run();
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Startup
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Startup(IConfiguration configuration, IHostEnvironment  hostingEnvironment, IWebHostEnvironment webHostEnvironment)
    {
        Debug.Assert(configuration &lt;/span&gt;!= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        Debug.Assert(hostingEnvironment &lt;/span&gt;!= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        Debug.Assert(webHostEnvironment &lt;/span&gt;!= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        Debug.Assert(ReferenceEquals(hostingEnvironment, webHostEnvironment));
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app) { }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;依赖服务还可以直接注入用于注册中间件的Configure方法中。如果构造函数注入还可以对注入的服务有所选择，那么对于Configure方法来说，通过任意方式注册的服务都可以注入其中，包括通过调用IHostBuilder、IWebHostBuilder和Startup自身的ConfigureServices方法注册的服务，还包括框架自行注册的所有服务。&lt;/p&gt;
&lt;p&gt;如下面的代码片段所示，我们分别调用IWebHostBuilder和Startup的ConfigureServices方法注册了针对IFoo接口与IBar接口的服务，这两个服务直接注入Startup的Configure方法中。另外，Configure方法要求提供一个用来注册中间件的IApplicationBuilder对象作为参数，但是对该参数出现的位置并未做任何限制。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
    {
        Host.CreateDefaultBuilder().ConfigureWebHostDefaults(builder &lt;/span&gt;=&amp;gt;&lt;span&gt; builder
            .UseStartup&lt;/span&gt;&amp;lt;Startup&amp;gt;&lt;span&gt;()
            .ConfigureServices(svcs &lt;/span&gt;=&amp;gt; svcs.AddSingleton&amp;lt;IFoo, Foo&amp;gt;&lt;span&gt;()))
        .Build()
        .Run();
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Startup
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ConfigureServices(IServiceCollection services)  =&amp;gt; services.AddSingleton&amp;lt;IBar, Bar&amp;gt;&lt;span&gt;();
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app, IFoo foo, IBar bar)
    {
        Debug.Assert(foo &lt;/span&gt;!= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        Debug.Assert(bar &lt;/span&gt;!= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;在中间件中注入服务&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ASP.NET Core请求处理管道最重要的对象是真正用来处理请求的中间件。由于ASP.NET Core在创建中间件对象并利用它们构建整个请求处理管道时，所有的服务都已经注册完毕，所以注册的任何一个服务都可以注入中间件类型的构造函数中。如下所示的代码片段体现了针对中间件类型的构造函数注入。（S1107）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
    {
        Host.CreateDefaultBuilder().ConfigureWebHostDefaults(builder &lt;/span&gt;=&amp;gt; builder.ConfigureServices(svcs =&amp;gt;&lt;span&gt; svcs
                .AddSingleton&lt;/span&gt;&amp;lt;FoobarMiddleware&amp;gt;&lt;span&gt;()
                .AddSingleton&lt;/span&gt;&amp;lt;IFoo, Foo&amp;gt;&lt;span&gt;()
                .AddSingleton&lt;/span&gt;&amp;lt;IBar, Bar&amp;gt;&lt;span&gt;())
            .Configure(app &lt;/span&gt;=&amp;gt; app.UseMiddleware&amp;lt;FoobarMiddleware&amp;gt;&lt;span&gt;()))
        .Build()
        .Run();
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FoobarMiddleware: IMiddleware
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; FoobarMiddleware(IFoo foo, IBar bar)
    {
        Debug.Assert(foo &lt;/span&gt;!= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        Debug.Assert(bar &lt;/span&gt;!= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Task InvokeAsync(HttpContext context, RequestDelegate next)
    {
        Debug.Assert(next &lt;/span&gt;!= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Task.CompletedTask;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果采用基于约定的中间件类型定义方式，注册的服务还可以直接注入真正用于处理请求的InvokeAsync方法或者Invoke方法中。另外，将方法命名为InvokeAsync更符合TAP（Task-based Asynchronous Pattern）编程模式，之所以保留Invoke方法命名，主要是出于版本兼容的目的。如下所示的代码片段展示了针对InvokeAsync方法的服务注入。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
    {
        Host.CreateDefaultBuilder().ConfigureWebHostDefaults(builder &lt;/span&gt;=&amp;gt; builder.ConfigureServices(svcs =&amp;gt;&lt;span&gt; svcs
                .AddSingleton&lt;/span&gt;&amp;lt;IFoo, Foo&amp;gt;&lt;span&gt;()
                .AddSingleton&lt;/span&gt;&amp;lt;IBar, Bar&amp;gt;&lt;span&gt;())
            .Configure(app &lt;/span&gt;=&amp;gt; app.UseMiddleware&amp;lt;FoobarMiddleware&amp;gt;&lt;span&gt;()))
        .Build()
        .Run();
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FoobarMiddleware
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; RequestDelegate _next;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; FoobarMiddleware(RequestDelegate next) =&amp;gt; _next =&lt;span&gt; next;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Task InvokeAsync(HttpContext context, IFoo foo, IBar bar)
    {
        Debug.Assert(context &lt;/span&gt;!= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        Debug.Assert(foo &lt;/span&gt;!= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        Debug.Assert(bar &lt;/span&gt;!= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; _next(context);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;虽然约定定义的中间件类型和Startup类型采用了类似的服务注入方式，它们都支持构造函数注入和方法注入，但是它们之间有一些差别。中间件类型的构造函数、Startup类型的Configure方法和中间件类型的Invoke方法或者InvokeAsync方法都具有一个必需的参数，其类型分别为RequestDelegate、IApplicationBuilder和HttpContext，对于该参数在整个参数列表的位置，前两者都未做任何限制，只有后者要求表示当前请求上下文的参数HttpContext必须作为方法的第一个参数。按照上述约定，如下这个中间件类型FoobarMiddleware的定义是不合法的，但是Startup类型的定义则是合法的。对于这一点，笔者认为可以将这个限制放开，这样不仅可以使中间件类型的定义更加灵活，还能保证注入方式的一致性。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FoobarMiddleware
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; FoobarMiddleware(RequestDelegate next);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Task InvokeAsync(IFoo foo, IBar bar, HttpContext context);
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Startup
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IFoo foo, IBar bar, IApplicationBuilder app);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于基于约定的中间件，构造函数注入与方法注入存在一个本质区别。由于中间件被注册为一个Singleton对象，所以我们不应该在它的构造函数中注入Scoped服务。Scoped服务只能注入中间件类型的InvokeAsync方法中，因为依赖服务是在针对当前请求的服务范围中提供的，所以能够确保Scoped服务在当前请求处理结束之后被释放。&lt;/p&gt;

&lt;p&gt;当我们调用IServiceCollection相关方法注册服务的时候，总是会指定一种生命周期。由第3章和第4章的介绍可知，作为依赖注入容器的多个IServiceProvider对象通过ServiceScope 构成一种层次化结构。Singleton服务实例保存在作为根容器的IServiceProvider对象上，而Scoped服务实例以及需要回收释放的Transient服务实例则保存在当前IServiceProvider对象中，只有不需要回收的Transient服务才会用完就被丢弃。&lt;/p&gt;
&lt;p&gt;至于服务实例是否需要回收释放，取决于服务实现类型是否实现IDisposable接口，服务实例的回收释放由保存它的IServiceProvider对象负责。具体来说，当IServiceProvider对象因自身的Dispose方法被调用而被回收释放时，它会调用自身维护的所有服务实例的Dispose方法。对于一个非根容器的IServiceProvider对象来说，其生命周期决定于对应的IServiceScope对象，调用ServiceScope的Dispose方法会导致对封装IServiceProvider对象的回收释放。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;两个IServiceProvider对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果在一个具体的ASP.NET Core应用中讨论服务生命周期会更加易于理解：Singleton是针对应用程序的生命周期，而Scoped是针对请求的生命周期。换句话说，Singleton服务的生命周期会一直延续到应用程序关闭，而Scoped服务的生命周期仅仅与当前请求上下文绑定在一起，那么这样的生命周期模式是如何实现的？&lt;/p&gt;
&lt;p&gt;ASP.NET Core应用针对服务生命周期管理的实现原理其实也很简单。在应用程序正常启动后，它会利用注册的服务创建一个作为根容器的IServiceProvider对象，我们可以将它称为ApplicationServices。如果应用在处理某个请求的过程中需要采用依赖注入的方式激活某个服务实例，那么它会利用这个IServiceProvider对象创建一个代表服务范围的IServiceScope对象，后者会指定一个IServiceProvider对象作为子容器，请求处理过程中所需的服务实例均由它来提供，我们可以将它称为RequestServices。&lt;/p&gt;
&lt;p&gt;在处理完当前请求后，这个IServiceScope对象的Dispose方法会被调用，与它绑定的这个IServiceProvider对象也随之被回收释放，由它提供的实现了IDisposable接口的Transient服务实例也会随之被回收释放，最终由它提供的Scoped服务实例变成可以被GC回收的垃圾对象。表示当前请求上下文的HttpContext类型具有如下所示的RequestServices属性，它返回的就是这个针对当前请求的IServiceProvider对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HttpContext
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; IServiceProvider RequestServices { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    ...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为了使读者对注入服务的生命周期有深刻的认识，下面演示一个简单的实例。这是一个ASP.NET Core MVC应用，我们在该应用中定义了3个服务接口（IFoo、IBar和IBaz）和对应的实现类（Foo、Bar和Baz），后者派生于实现了IDisposable接口的基类Base。我们分别在Base的构造函数和实现的Dispose方法中输出相应的文字，以确定服务实例被创建和释放的时间。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
    {
        Host.CreateDefaultBuilder().ConfigureWebHostDefaults(builder &lt;/span&gt;=&amp;gt;&lt;span&gt; builder
            .ConfigureServices(svcs &lt;/span&gt;=&amp;gt;&lt;span&gt; svcs
                .AddSingleton&lt;/span&gt;&amp;lt;IFoo, Foo&amp;gt;&lt;span&gt;()
                .AddScoped&lt;/span&gt;&amp;lt;IBar, Bar&amp;gt;&lt;span&gt;()
                .AddTransient&lt;/span&gt;&amp;lt;IBaz, Baz&amp;gt;&lt;span&gt;()
                .AddControllersWithViews())
            .Configure(app &lt;/span&gt;=&amp;gt;&lt;span&gt; app
                .Use(next &lt;/span&gt;=&amp;gt; httpContext =&amp;gt;&lt;span&gt; {
                    Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Receive request to {httpContext.Request.Path}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; next(httpContext);
                })
                .UseRouting()
                .UseEndpoints(endpoints &lt;/span&gt;=&amp;gt;&lt;span&gt; endpoints.MapControllers())))
        .ConfigureLogging(builder&lt;/span&gt;=&amp;gt;&lt;span&gt;builder.ClearProviders())
        .Build()
        .Run();
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HomeController: Controller
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; IHostApplicationLifetime _lifetime; 
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; HomeController(IHostApplicationLifetime lifetime, IFoo foo,  IBar bar1, IBar bar2, IBaz baz1, IBaz baz2)
        &lt;/span&gt;=&amp;gt;_lifetime =&lt;span&gt; lifetime;

    [HttpGet(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/index&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Index() {}

    [HttpGet(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/stop&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Stop() =&amp;gt;&lt;span&gt; _lifetime.StopApplication();
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IFoo {}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IBar {}  
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IBaz {}   
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Base : IDisposable
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Base()=&amp;gt; Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{this.GetType().Name} is created.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Dispose() =&amp;gt; Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{this.GetType().Name} is disposed.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
}    
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo : Base, IFoo {}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Bar : Base, IBar {}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Baz : Base, IBaz {}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在注册ASP.NET Core MVC框架相关的服务之前，我们采用不同的生命周期对这3个服务进行了注册。为了确定应用程序何时开始处理接收的请求，可以利用注册的中间件打印出当前请求的路径。我们在HomeController的构造函数中注入了上述3个服务和1个用来远程关闭应用的IHostApplicationLifetime服务，其中IBar和IBaz被注入了两次。HomeController包含Index和Stop两个Action方法，它们的路由指向的路径分别为“/index”和“/stop”，Stop方法利用注入的IHostApplicationLifetime服务关闭当前应用。&lt;/p&gt;
&lt;p&gt;我们先采用命令行的形式来启动该应用程序，然后利用浏览器依次向该应用发送3个请求，前两个请求指向Action方法Index（“/index”），后一个指向Action方法Stop（“ /stop”），此时控制台上出现的输出结果如下图所示。由输出结果可知：由于IFoo服务采用的生命周期模式为Singleton，所以在整个应用的生命周期中只会创建一次。对于每个接收的请求，虽然IBar和IBaz都被注入了两次，但是采用Scoped模式的Bar对象只会被创建一次，而采用Transient模式的Baz对象则被创建了两次。再来看释放服务相关的输出，采用Singleton模式的IFoo服务会在应用被关闭的时候被释放，而生命周期模式分别为Scoped和Transient的IBar服务与IBaz服务都会在应用处理完当前请求之后被释放。（S1110）&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/19327/202011/19327-20201112084606950-708412713.png&quot;&gt;&lt;img width=&quot;246&quot; height=&quot;426&quot; title=&quot;9&quot; alt=&quot;9&quot; src=&quot;https://img2020.cnblogs.com/blog/19327/202011/19327-20201112084607299-2060573178.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基于服务范围的验证&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由《&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-08.html&quot;&gt;依赖注入[8]：服务实例的生命周期&lt;/a&gt;》的介绍可知，Scoped服务既不应该由作为根容器的ApplicationServices来提供，也不能注入一个Singleton服务中，否则它将无法在请求结束之后释放。如果忽视了这个问题，就容易造成内存泄漏，下面是一个典型的例子。&lt;/p&gt;
&lt;p&gt;如下所示的实例程序使用了一个名为FoobarMiddleware的中间件。在该中间件初始化过程中，它需要从数据库中加载由Foobar类型表示的数据。在这里我们采用Entity Framework Core提供的基于SQL Server的数据访问，所以可以为实体类型Foobar定义对应的FoobarDbContext，它以服务的形式通过调用IServiceCollection的AddDbContext&amp;lt;TDbContext&amp;gt;扩展方法进行注册，注册的服务默认采用Scoped生命周期。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
    {
        Host.CreateDefaultBuilder().ConfigureWebHostDefaults(builder &lt;/span&gt;=&amp;gt;&lt;span&gt; builder
            .UseDefaultServiceProvider(options&lt;/span&gt;=&amp;gt;options.ValidateScopes = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
            .ConfigureServices(svcs &lt;/span&gt;=&amp;gt; svcs.AddDbContext&amp;lt;FoobarDbContext&amp;gt;(options=&amp;gt;options.UseSqlServer(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;connection string&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)))                   
            .Configure(app &lt;/span&gt;=&amp;gt;app.UseMiddleware&amp;lt;FoobarMiddleware&amp;gt;&lt;span&gt;()))
        .Build()
        .Run();
    }
}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FoobarMiddleware
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; RequestDelegate  _next;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; Foobar  _foobar; 
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; FoobarMiddleware(RequestDelegate next, FoobarDbContext dbContext)
    {
        _next &lt;/span&gt;=&lt;span&gt; next;
        _foobar &lt;/span&gt;=&lt;span&gt; dbContext.Foobar.SingleOrDefault();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Task InvokeAsync(HttpContext context) 
    {
        ...
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; _next(context);
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foobar
{
    [Key]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Foo { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Bar { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FoobarDbContext : DbContext
{    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DbSet&amp;lt;Foobar&amp;gt; Foobar { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; FoobarDbContext(DbContextOptions options) : &lt;span&gt;base&lt;/span&gt;&lt;span&gt;(options){}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;采用约定方式定义的中间件实际上是一个Singleton对象，而且它是在应用初始化过程中由根容器的IServiceProvider对象创建的。由于FoobarMiddleware的构造函数中注入了FoobarDbContext对象，所以该对象自然也由同一个IServiceProvider对象来提供。这就意味着FoobarDbContext对象的生命周期会延续到当前应用程序被关闭的那一刻，造成的后果就是数据库连接不能及时地被释放。&lt;/p&gt;
&lt;p&gt;在一个ASP.NET Core应用中，如果将服务的生命周期注册为Scoped模式，那么我们希望服务实例真正采用基于请求的生命周期模式。由第4章的介绍可知，我们可以通过启用针对服务范围的验证来避免采用作为根容器的IServiceProvider对象来提供Scoped服务实例。我们只需要调用IWebHostBuilder接口的两个UseDefaultServiceProvider方法重载将ServiceProviderOptions的ValidateScopes属性设置为True即可。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WebHostBuilderExtensions
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IWebHostBuilder UseDefaultServiceProvider(&lt;span&gt;this&lt;/span&gt; IWebHostBuilder hostBuilder, Action&amp;lt;ServiceProviderOptions&amp;gt;&lt;span&gt; configure);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IWebHostBuilder UseDefaultServiceProvider(&lt;span&gt;this&lt;/span&gt; IWebHostBuilder hostBuilder, Action&amp;lt;WebHostBuilderContext, ServiceProviderOptions&amp;gt;&lt;span&gt; configure);
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ServiceProviderOptions
{   
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; ValidateScopes { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; } 
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; ValidateOnBuild { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;出于性能方面的考虑，如果在Development环境下调用Host的静态方法CreateDefaultBuilder来创建IHostBuilder对象，那么该方法会将ValidateScopes属性设置为True。在上面演示的实例中，我们刻意关闭了针对服务范围的验证，如果将这行代码删除，在开发环境下启动该程序之后会出现下图所示的异常。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/19327/202011/19327-20201112084607581-2119904517.png&quot;&gt;&lt;img width=&quot;383&quot; height=&quot;195&quot; title=&quot;10&quot; alt=&quot;10&quot; src=&quot;https://img2020.cnblogs.com/blog/19327/202011/19327-20201112084607864-152259442.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果确实需要在中间件中注入Scoped服务，可以采用强类型（实现IMiddleware接口）的中间件定义方式，并将中间件以Scoped服务进行注册即可。如果采用基于约定的中间件定义方式，我们有两种方案来解决这个问题：第一种解决方案就是按照如下所示的方式在InvokeAsync方法中利用HttpContext的RequestServices属性得到基于当前请求的IServiceProvider对象，并利用它来提供依赖的服务。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FoobarMiddleware
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; RequestDelegate _next;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; FoobarMiddleware(RequestDelegate next)=&amp;gt; _next =&lt;span&gt; next;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Task InvokeAsync(HttpContext context)
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; dbContext = context.RequestServices.GetRequiredService&amp;lt;FoobarDbContext&amp;gt;&lt;span&gt;();
        Debug.Assert(dbContext &lt;/span&gt;!= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; _next(context);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第二种解决方案则是按照如下所示的方式直接在InvokeAsync方法中注入依赖的服务。我们在上面介绍两种中间件定义方式时已经提及：InvokeAsync方法注入的服务就是由基于当前请求的IServiceProvider对象提供的，所以这两种解决方案其实是等效的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FoobarMiddleware
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; RequestDelegate _next;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; FoobarMiddleware(RequestDelegate next)=&amp;gt; _next =&lt;span&gt; next;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Task InvokeAsync(HttpContext context)
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; dbContext = context.RequestServices.GetRequiredService&amp;lt;FoobarDbContext&amp;gt;&lt;span&gt;();
        Debug.Assert(dbContext &lt;/span&gt;!= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; _next(context);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;由《&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-09-06.html&quot;&gt;服务承载系统[6]: 承载服务启动流程[下篇]&lt;/a&gt;》的介绍可知，通过调用IHostBuilder接口的UseServiceProviderFactory&amp;lt;TContainerBuilder&amp;gt; 方法注册IServiceProviderFactory&amp;lt;TContainerBuilder&amp;gt;工厂的方式可以实现与第三方依赖注入框架的整合。该接口定义的ConfigureContainer&amp;lt;TContainerBuilder&amp;gt;方法可以对提供的依赖注入容器做进一步设置，这样的设置同样可以定义在注册的Startup类型中。&lt;/p&gt;
&lt;p&gt;《&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-04.html&quot;&gt;依赖注入[4]：一个Mini版的依赖注入框架&lt;/a&gt;》创建了一个名为Cat的简易版依赖注入框架，并在第4章为其创建了一个IServiceProviderFactory&amp;lt;TContainerBuilder&amp;gt;实现，具体类型为CatServiceProvider，下面演示如何通过注册这个CatServiceProvider实现与第三方依赖注入框架Cat的整合。如果使用Cat框架，我们可以通过在服务类型上标注MapToAttribute特性的方式来定义服务注册信息。在创建的演示程序中，我们采用如下方式定义了3个服务（Foo、Bar和Baz）和对应的接口（IFoo、IBar和IBaz）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IFoo { }
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IBar { }
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IBaz { }

[MapTo(&lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(IFoo), Lifetime.Root)]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo :  IFoo { }

[MapTo(&lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(IBar), Lifetime.Root)]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Bar :  IBar { }

[MapTo(&lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(IBaz), Lifetime.Root)]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Baz :  IBaz { }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在如下所示的代码片段中，我们调用IHostBuilder接口的UseServiceProviderFactory方法注册了CatServiceProviderFactory工厂。我们将针对Cat框架的服务注册实现在注册Startup类型的ConfigureContainer方法中，这是除Configure方法和ConfigureServices方法外的第三个约定的方法。我们将CatBuilder对象作为该方法的参数，并调用它的Register方法实现了针对当前程序集的批量服务注册。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
    {
        Host.CreateDefaultBuilder()
            .ConfigureWebHostDefaults(builder &lt;/span&gt;=&amp;gt; builder.UseStartup&amp;lt;Startup&amp;gt;&lt;span&gt;())
            .UseServiceProviderFactory(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; CatServiceProviderFactory())
            .Build()
            .Run();
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Startup
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app, IFoo foo, IBar bar, IBaz baz)
    {
        app.Run(&lt;/span&gt;&lt;span&gt;async&lt;/span&gt; context =&amp;gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; response =&lt;span&gt; context.Response;
            response.ContentType &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt; response.WriteAsync($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;foo: {foo}&amp;lt;br/&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt; response.WriteAsync($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bar: {bar}&amp;lt;br/&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt; response.WriteAsync($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;baz: {baz}&amp;lt;br/&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        });
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ConfigureContainer(CatBuilder container) =&amp;gt;&lt;span&gt; container.Register(Assembly.GetEntryAssembly());
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为了检验ASP.NET Core能否利用Cat框架来提供所需的服务，我们将注册的3个服务直接注入Startup类型的Configure方法中。我们在该方法中利用注册的中间件将这3个注入的服务实例的类型写入相应的HTML文档中。如果利用浏览器访问该应用，得到的输出结果如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/19327/202011/19327-20201112084608134-1159332696.png&quot;&gt;&lt;img width=&quot;240&quot; height=&quot;127&quot; title=&quot;11&quot; alt=&quot;11&quot; src=&quot;https://img2020.cnblogs.com/blog/19327/202011/19327-20201112084608416-1887438076.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/asp-net-core-program-model-1.html&quot;&gt;ASP.NET Core编程模式[1]：管道式的请求处理&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/asp-net-core-program-model-2.html&quot;&gt;ASP.NET Core编程模式[2]：依赖注入的运用&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/asp-net-core-program-model-3.html&quot;&gt;ASP.NET Core编程模式[3]：配置多种使用形式&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/asp-net-core-program-model-4.html&quot;&gt;ASP.NET Core编程模式[4]：基于承载环境的编程&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/asp-net-core-program-model-5.html&quot;&gt;ASP.NET Core编程模式[5]：如何放置你的初始化代码&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 12 Nov 2020 00:46:00 +0000</pubDate>
<dc:creator>Artech</dc:creator>
<og:description>目录一、服务注册 二、服务的消费 在Startup中注入服务 在中间件中注入服务 三、生命周期 两个IServiceProvider对象 基于服务范围的验证 四、集成第三方依赖注入框架 一、服务注册</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/artech/p/asp-net-core-program-model-2.html</dc:identifier>
</item>
<item>
<title>Android测试三件套：传文件、抓包、看日志 - dongfanger</title>
<link>http://www.cnblogs.com/df888/p/13960487.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/df888/p/13960487.html</guid>
<description>&lt;p&gt;在对安卓进行测试时，我们需要把 apk 传到安卓机上，对请求抓包，同时监控应用日志。本文就来讲讲具体操作。&lt;/p&gt;
&lt;p&gt;安卓机是指基于安卓的机器 ，如手机、POS 机、电视盒子等。&lt;/p&gt;

&lt;p&gt;我们拒绝用 U 盘传文件。直接用 WIFI 传。别问，问就是想装逼。哈哈哈。&lt;/p&gt;
&lt;p&gt;① 先把装逼神器 adb 下载下来，打开以下网址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://adb.clockworkmod.com/&quot;&gt;https://adb.clockworkmod.com/&lt;/a&gt;&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202011/1629545-20201111193214742-769298011.png&quot;/&gt;&lt;/center&gt;
&lt;p&gt;下载后得到 UniversalAdbDriverSetup.msi 文件，只有 16.2 M，相比有些人让安装 Android Studio，轻巧了太多。&lt;/p&gt;
&lt;p&gt;② 安装之后打开 cmd，输入 &lt;code&gt;adb&lt;/code&gt;：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202011/1629545-20201111193215319-1147379398.png&quot;/&gt;&lt;/center&gt;
&lt;p&gt;出现如图所示就算安装成功了。&lt;/p&gt;
&lt;p&gt;③ 接着继续装逼，把安卓机掏出来，打开设置 | 系统 | 关于手机，对着“版本号”一顿猛戳，戳到开发者模式为止，启用它（不同安卓机可能方式不同）。&lt;/p&gt;
&lt;p&gt;④ 装，接着装。在 WIFI 设置中，找到已经和电脑处于同一网络的 WIFI，查看高级选项，获取 IP 地址。&lt;/p&gt;
&lt;p&gt;⑤ 在电脑的 cmd 中，输入以下命令使用 adb 连接安卓机：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;adb connect 192.168.x.x
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;出现如图所示就算连接成功了：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202011/1629545-20201111193215518-765302551.png&quot;/&gt;&lt;/center&gt;
&lt;p&gt;⑥ 好，一切就绪，开始骚操作，电脑 → 手机：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;adb push D:\test.apk  /storage/emulated/0/
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;电脑 ← 手机：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;adb pull /storage/emulated/0/test.apk D:\
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;抓包用到的工具是 Charles。下载地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.charlesproxy.com/&quot;&gt;https://www.charlesproxy.com/&lt;/a&gt;&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202011/1629545-20201111193215892-1482743517.png&quot;/&gt;&lt;/center&gt;
&lt;p&gt;下载后直接安装即可。建议找下破解，不然用着会有点卡。&lt;/p&gt;
&lt;p&gt;抓包很简单，只需要两步。第一步在电脑端启动代理。第二步在安卓机上手动设置代理。&lt;/p&gt;
&lt;p&gt;第一步在电脑端启动代理。Charles 中打开 Proxy | Proxy Settings 启用代理，默认端口 8888：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202011/1629545-20201111193216377-1392303657.png&quot;/&gt;&lt;/center&gt;
&lt;p&gt;第二步在安卓机上手动设置代理。打开安卓机 WIFI 设置，编辑网络（不同手机可能方式不同），添加手动代理，填写&lt;strong&gt;电脑 IP 和 Charles 代理端口&lt;/strong&gt;：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202011/1629545-20201111193216592-473421268.png&quot;/&gt;&lt;/center&gt;
&lt;p&gt;保存后 Charles 会提示有连接请求：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202011/1629545-20201111193216803-288650557.png&quot;/&gt;&lt;/center&gt;
&lt;p&gt;允许即可。&lt;/p&gt;

&lt;p&gt;电脑端 cmd 一行命令搞定：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;adb logcat
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不过这样打出来的日志会比较多。可以做下过滤。&lt;/p&gt;
&lt;p&gt;Windows：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;adb logcat | find &quot;some&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Linux：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;adb locat | grep &quot;some&quot;
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;有可能会抓不到包。不同机器原因各有不同。这里我不能给出完美的解决办法。只能分享下我的经验。如果无法解决，还是找下百度。&lt;/p&gt;
&lt;p&gt;一种可能就是 HTTPS 证书问题，在 Help | SSL Proxying 有对应功能：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202011/1629545-20201111193217052-412336552.png&quot;/&gt;&lt;/center&gt;
&lt;p&gt;有些时候电脑端安装完证书就可以了，有些时候还需要在安卓机上下载证书：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://charlesproxy.com/getssl&quot;&gt;http://charlesproxy.com/getssl&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;有一次我访问这个链接无响应，重启 Charles 又可以了下载了。&lt;/p&gt;
&lt;p&gt;还有一种可能是没有添加白名单，Proxy | SSL Proxying setttings：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202011/1629545-20201111193217327-606432838.png&quot;/&gt;&lt;/center&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202011/1629545-20201111193217560-909116731.png&quot;/&gt;&lt;/center&gt;

&lt;p&gt;本文介绍了安卓机测试环境的准备，用到了 adb、Charles 软件，进行传文件、抓包、看日志。操作还是比较简单，不过实际过程中，可能会由于机器不同导致遇到奇奇怪怪的问题。通过百度，一般是能够解决的。最后温馨提示，如果第二天安卓机提示无法连接网络，那么看看是不是电脑的 Charles 关掉了。哈哈哈。&lt;/p&gt;
</description>
<pubDate>Wed, 11 Nov 2020 23:42:00 +0000</pubDate>
<dc:creator>dongfanger</dc:creator>
<og:description>传文件、抓包、看日志。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/df888/p/13960487.html</dc:identifier>
</item>
<item>
<title>ansible快速部署cassandra3集群 - 程序员欣宸</title>
<link>http://www.cnblogs.com/bolingcavalry/p/13961943.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bolingcavalry/p/13961943.html</guid>
<description>&lt;h3 id=&quot;欢迎访问我的github&quot;&gt;欢迎访问我的GitHub&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;内容：所有原创文章分类汇总及配套源码，涉及Java、Docker、Kubernetes、DevOPS等；&lt;/p&gt;
&lt;h3 id=&quot;关于cassandra3集群部署&quot;&gt;关于cassandra3集群部署&lt;/h3&gt;
&lt;p&gt;通常情况下的cassandra3集群部署操作如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;安装JDK；&lt;/li&gt;
&lt;li&gt;设置JDK环境变量；&lt;/li&gt;
&lt;li&gt;创建运行cassandra服务的群组和账号；&lt;/li&gt;
&lt;li&gt;安装cassandra；&lt;/li&gt;
&lt;li&gt;设置cassandra环境变量；&lt;/li&gt;
&lt;li&gt;设置cassandra参数；&lt;/li&gt;
&lt;li&gt;设置cassandra日志目录和文件目录；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;上述操作要在每台机器执行，手动操作较为费时，因此用ansible来完成上述所有步骤，除了省事儿，还减少了操作失误的概览；&lt;/p&gt;
&lt;h3 id=&quot;关于ansible部署&quot;&gt;关于ansible部署&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;ansible是常用的运维工具，可以大幅度简化整个部署过程；&lt;/li&gt;
&lt;li&gt;接下来使用ansible完成部署工作，如果您想了解ansible，请参考&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/105342744&quot;&gt;《ansible2.4安装和体验》&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;部署操作如下图所示，在一台安装了ansible的电脑上运行脚本，由ansible远程连接到三台CentOS7.7的服务器上，完成部署工作：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202011/485422-20201112050936831-1282813221.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;软件版本&quot;&gt;软件版本&lt;/h3&gt;
&lt;p&gt;本次实战的软件版本信息如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;ansible电脑操作系统：CentOS Linux release 7.7.1908&lt;/li&gt;
&lt;li&gt;cassandra服务器操作系统：CentOS Linux release 7.7.1908&lt;/li&gt;
&lt;li&gt;cassandra版本：3.11.6&lt;/li&gt;
&lt;li&gt;jdk：1.8.0_191&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;材料准备&quot;&gt;材料准备&lt;/h3&gt;
&lt;p&gt;ansible远程操作最重要的是提前把材料准备好，本次实战一共需要如下7文件（稍后有下载地址）：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;ansible.cfg：ansible配置文件；&lt;/li&gt;
&lt;li&gt;hosts：保存了三台cassansra服务器信息；&lt;/li&gt;
&lt;li&gt;cluster-3-nodes.yml：ansible脚本，即playbook文件，里面是整个安装部署的逻辑；&lt;/li&gt;
&lt;li&gt;vars-cluster-3-nodes.yml：ansible脚本用到的变量配置信息，例如JDK文件名，cassandra文件名等；&lt;/li&gt;
&lt;li&gt;cassandra.yaml：cassandra配置文件，我从安装包里取出来做了些修改(几个和目录有关的配置，被我从注释状态改成了生效状态)&lt;/li&gt;
&lt;li&gt;apache-cassandra-3.11.6-bin.tar.gz：cassandra官方安装包；&lt;/li&gt;
&lt;li&gt;jdk-8u191-linux-x64.tar.gz：jdk8的官方安装包；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;所有材料的下载地址&quot;&gt;所有材料的下载地址&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;从1到5的内容可以在我的GitHub下载，仓库地址：&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt; ，在仓库的&lt;span&gt;playbooks/cassandra3&lt;/span&gt;目录下，有个名为&lt;span&gt;cluster-3-nodes&lt;/span&gt;文件夹，如下图红框所示，这里面有那五个文件：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202011/485422-20201112050937829-667185405.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;apache-cassandra-3.11.6-bin.tar.gz：在官方下载：&lt;a href=&quot;http://ftp.kddilabs.jp/infosystems/apache/cassandra/3.11.6/apache-cassandra-3.11.6-bin.tar.gz&quot;&gt;http://ftp.kddilabs.jp/infosystems/apache/cassandra/3.11.6/apache-cassandra-3.11.6-bin.tar.gz&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;jdk-8u191-linux-x64.tar.gz：Oracle官网可下，也可以在csdn下载(不用积分)，地址：&lt;a href=&quot;https://download.csdn.net/download/boling_cavalry/12098987&quot;&gt;https://download.csdn.net/download/boling_cavalry/12098987&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;文件摆放位置&quot;&gt;文件摆放位置&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;登录ansible电脑，在家目录创建名为palybooks的目录，命令是：mkdir ~/playbooks&lt;/li&gt;
&lt;li&gt;上面的七个文件中，1到4放入playbooks目录；&lt;/li&gt;
&lt;li&gt;playbooks目录下新建名为files的目录，将5到7放进去；&lt;/li&gt;
&lt;li&gt;最终七个文件的摆放位置如下图：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202011/485422-20201112050938674-1587585537.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;修改配置&quot;&gt;修改配置&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;cassandra服务器的IP地址、账号、密码等需要修改成您自己那边的信息，请修改hosts文件中的相关内容，如下图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202011/485422-20201112050939469-596082143.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;cassandra集群的seed配置是其中两台机器的IP地址，这个信息在vars-cluster-3-nodes.yml，请您改成自己机器的IP地址，如下图黄框所示：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202011/485422-20201112050940130-219266836.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;如果您的集群名称、jdk版本、cassandra版本和我这里不同，都可以在&lt;span&gt;vars-cluster-3-nodes.yml&lt;/span&gt;中修改；&lt;/li&gt;
&lt;li&gt;第一次ssh连接到cassandra机器时会有提示要求输入&quot;Yes&quot;，为了避免这种情况出现在ansible连接cassandra机器的时候，建议先手动连接一次，这样后面就不再出现提示了，如下图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202011/485422-20201112050942207-550971423.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;准备完毕，可以开始部署了；&lt;/p&gt;
&lt;h3 id=&quot;部署&quot;&gt;部署&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;在playbooks目录下执行&lt;strong&gt;ansible-playbook cluster-3-nodes.yml&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;等待大约5分钟左右，如果控制台没有报错，整个安装过程完成；&lt;/li&gt;
&lt;li&gt;如果有报错，请按照错误提示做好处理再重复执行&lt;strong&gt;ansible-playbook cluster-3-nodes.yml&lt;/strong&gt;，该命令可以反复多次执行；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;启动&quot;&gt;启动&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;部署的时候会创建名为&lt;span&gt;cassandra&lt;/span&gt;的群组，以及名为&lt;span&gt;cassandra&lt;/span&gt;的账号；&lt;/li&gt;
&lt;li&gt;以cassandra账号分别SSH登录三台cassandra机器，密码是&lt;span&gt;888888&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;登录cassandra机器后，在任意位置执行命令&lt;span&gt;cassandra&lt;/span&gt;，即可启动cassandra服务；&lt;/li&gt;
&lt;li&gt;等待大约几分钟，服务初始化、构建集群成功：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202011/485422-20201112050945845-98247676.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;在三台机器的任意目录下执行命令&lt;span&gt;nodetool status&lt;/span&gt;，查看集群情况：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202011/485422-20201112050947743-262832859.png&quot; alt=&quot;ansible快速部署cassandra3集群&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;验证&quot;&gt;验证&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;在任意一台cassandra机器上，cqlsh进入交互模式后，执行以下操作：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202011/485422-20201112050949120-1647696285.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;创建一个springboot应用，访问上面新建的student表，如下图红框所示，应用启动时连接cassandra成功：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202011/485422-20201112050950912-2076768962.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;springboot应用中有个根据名称查找记录的web接口，如下图，可以查到数据库中的记录：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202011/485422-20201112050951318-317642720.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;上面的springboot应用源码已上传到GitHub，仓库地址：&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt; ，在仓库的&lt;span&gt;cassandrahelloworld&lt;/span&gt;目录下，如下图红框所示：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202011/485422-20201112050951745-1049276594.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;至此，cassandra集群从部署到验证已经操作完成，希望能给您一些参考；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;欢迎关注公众号：程序员欣宸&quot;&gt;欢迎关注公众号：程序员欣宸&lt;/h3&gt;
&lt;blockquote readability=&quot;4.258064516129&quot;&gt;
&lt;p&gt;微信搜索「程序员欣宸」，我是欣宸，期待与您一同畅游Java世界...&lt;br/&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 11 Nov 2020 21:10:00 +0000</pubDate>
<dc:creator>程序员欣宸</dc:creator>
<og:description>欢迎访问我的GitHub https://github.com/zq2599/blog_demos 内容：所有原创文章分类汇总及配套源码，涉及Java、Docker、Kubernetes、DevOPS</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bolingcavalry/p/13961943.html</dc:identifier>
</item>
<item>
<title>使用git处理github中提交有冲突的pull request - 追逐时光者</title>
<link>http://www.cnblogs.com/Can-daydayup/p/13961931.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Can-daydayup/p/13961931.html</guid>
<description>&lt;h2&gt;前言：&lt;/h2&gt;
&lt;p&gt;　　为什么要写这篇文章，因为前段时间有一个开源的github中的项目有一个朋友提交了一个pr看了下是帮忙优化了下代码（十分感谢这位网友）。但是他提交的pr刚好和我的项目有许多的冲突导致无法自动合并，在github中提示只能使用命令行指令进行合并，因为这种情况处理的比较少为了以后方便使用在这里记录一下。&lt;/p&gt;
&lt;h2&gt;github中的大概命令合并指令&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1336199/202011/1336199-20201112021526502-20021429.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;1、首先我们需要下载一个git分布式管理工具&lt;/h2&gt;
&lt;p&gt;下载Git链接地址：&lt;a href=&quot;https://git-scm.com/&quot; target=&quot;_blank&quot;&gt;https://git-scm.com/&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;2、然后我们需要clone下我们的项目&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
git clone sgit@github.com:YSGStudyHards/NPOI-ExportWordAndExcel-ImportExcelData.git（ssh项目链接）
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3、创建并切换到该分支，并同步到master中&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
git checkout -b 创建的分支名 master
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用git branch查看当前所属分支&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1336199/202011/1336199-20201112020615742-551856509.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4&gt; 4、拉取有冲突的pr到该分支中&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
git pull https&lt;span&gt;//&lt;/span&gt;&lt;span&gt;github.com/某人的/某项目的.git master　　&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;github中的命令语句&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
git pull git:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;github.com/hongbobaoer/NPOI-ExportWordAndExcel-ImportExcelData.git 20201109&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;4057-1591807501841&quot;&gt;5、直接打开冲突文件手动解决冲突&lt;/h4&gt;
&lt;p&gt;当项目拉取下来以后，我们就需要解决有冲突的文件信息了　　&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1336199/202011/1336199-20201112022742586-1578755673.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由下面的冲突文件中的冲突内容我们了解到：&lt;/p&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; HEAD
6月19日 pingrixuexilianxi添加了内容
=======
6月18日 pingrixuexilianxi2修改了这个文件哦
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; a8284fd41903c54212d1105a6feb6c57292e07b5
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; HEAD到 =======里面的【6月19日 pingrixuexilianxi添加了内容】是自己刚才的Commit提交的内容&lt;/p&gt;
&lt;p&gt;=======到 &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; a8284fd41903c54212d1105a6feb6c57292e07b5里面的【6月18日 pingrixuexilianxi2修改了这个文件哦】是远程代码库更新的内容（即为pingrixuexilianxi2本地代码库推送修改内容）。&lt;/p&gt;
&lt;h4&gt;手动冲突解决方法&lt;/h4&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;根据项目需求删除不需要的代码就行了，假如都需要的话我们只需要把 &amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; HEAD=======     &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; a8284fd41903c54212d1105a6feb6c57292e07b5都删掉冲突就解决了（注意，在项目中最后这些符号都不能存在，否则可能会报异常）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;或者可以使用git可视化管理工具（推荐）&lt;/h4&gt;
&lt;p&gt;原因：由于有些人使用代码合并比较生疏，为了避免出错推荐使用sourcetree进行解决冲突合并。&lt;/p&gt;
&lt;p&gt;详细使用sourcetree地址参考：&lt;a href=&quot;https://www.cnblogs.com/Can-daydayup/p/13128633.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/Can-daydayup/p/13128633.html&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;6、合并更改并在GitHub上更新&lt;/h2&gt;
&lt;p&gt;注意：这里是没有使用可视化工具合并的时候才需要自己使用代码去执行合并，提交，更新操作！&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
git commit -a &lt;span&gt;//&lt;/span&gt;&lt;span&gt;把修改提交到新建的分支上，会提示你成功merge本地代码到这个人的代码库&lt;/span&gt;
&lt;span&gt;
git checkout master &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;切换到自己的主分支上&lt;/span&gt;
&lt;span&gt;
git merge 创建的分支名 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将新建的分支合并到自己的分支上&lt;/span&gt;
&lt;span&gt;
git push origin master &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将代码推送的远程仓库中&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Wed, 11 Nov 2020 18:41:00 +0000</pubDate>
<dc:creator>追逐时光者</dc:creator>
<og:description>前言： 为什么要写这篇文章，因为前段时间有一个开源的github中的项目有一个朋友提交了一个pr看了下是帮忙优化了下代码（十分感谢这位网友）。但是他提交的pr刚好和我的项目有许多的冲突导致无法自动合并</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Can-daydayup/p/13961931.html</dc:identifier>
</item>
<item>
<title>分布式文档存储数据库之MongoDB分片集群 - Linux-1874</title>
<link>http://www.cnblogs.com/qiuhom-1874/p/13958295.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qiuhom-1874/p/13958295.html</guid>
<description>&lt;p&gt;　　前文我们聊到了mongodb的副本集以及配置副本集，回顾请参考&lt;a href=&quot;https://www.cnblogs.com/qiuhom-1874/p/13953598.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/qiuhom-1874/p/13953598.html&lt;/a&gt;；今天我们来聊下mongodb的分片；&lt;/p&gt;
&lt;p&gt;　　1、什么是分片？为什么要分片？&lt;/p&gt;
&lt;p&gt;　　我们知道数据库服务器一般出现瓶颈是在磁盘io上，或者高并发网络io，又或者单台server的cpu、内存等等一系列原因；于是，为了解决这些瓶颈问题，我们就必须扩展服务器性能；通常扩展服务器有向上扩展和向外扩展；所谓向上扩展就是给服务器加更大的磁盘，使用更大更好的内存，更换更好的cpu；这种扩展在一定程度上是可以解决性能瓶颈问题，但随着数据量大增大，瓶颈会再次出现；所以通常这种向上扩展的方式不推荐；向外扩展是指一台服务器不够加两台，两台不够加三台，以这种方式扩展，只要出现瓶颈我们就可以使用增加服务器来解决；这样一来服务器性能解决了，但用户的读写怎么分散到多个服务器上去呢？所以我们还要想办法把数据切分成多块，让每个服务器只保存整个数据集的部分数据，这样一来使得原来一个很大的数据集就通过切片的方式，把它切分成多分，分散的存放在多个服务器上，这就是分片；分片是可以有效解决用户写操作性能瓶颈；虽然解决了服务器性能问题和用户写性能问题，同时也带来了一个新问题，就是用户的查询；我们把整个数据集分散到多个server上，那么用户怎么查询数据呢？比如用户要查询年龄大于30的用户，该怎么查询呢？而年龄大于30的用户的数据，可能server1上有一部分数据，server2上有部分数据，我们怎么才能够把所有满足条件的数据全部查询到呢？这个场景有点类似我们之前说的mogilefs的架构，用户上传图片到mogilefs首先要把图片的元数据写进tracker，然后在把数据存放在对应的data节点，这样一来用户来查询，首先找tracker节点,tracker会把用户的请求文件的元数据告诉客户端，然后客户端在到对应的data节点取数据，最后拼凑成一张图片；而在mongodb上也是很类似，不同的的是在mogilefs上，客户端需要自己去和后端的data节点交互，取出数据；在mongdb上客户端不需要直接和后端的data节点交互，而是通过mongodb专有的客户端代理去代客户端交互，最后把数据统一由代理返回给客户端；这样一来就可以解决用户的查询问题；简单讲所谓分片就是把一个大的数据集通过切分的方式切分成多分，分散的存放在多个服务器上；分片的目的是为了解决数据量过大而导致的性能问题；&lt;/p&gt;
&lt;p&gt;　　2、数据集分片示意图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201111205414044-330622784.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：我们通过分片，可以将原本1T的数据集，平均分成4分，每个节点存储原有数据集的1/4，使得原来用一台服务器处理1T的数据，现在可以用4台服务器来处理，这样一来就有效的提高了数据处理过程；这也是分布式系统的意义；在mongodb中我们把这种共同处理一个数据集的部分数据的节点叫shard，我们把使用这种分片机制的mongodb集群就叫做mongodb分片集群；&lt;/p&gt;
&lt;p&gt;　　3、mongodb分片集群架构&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201111134954297-1176703224.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：在mongodb分片集群中，通常有三类角色，第一类是router角色，router角色主要用来接收客户端的读写请求，主要运行mongos这个服务；为了使得router角色的高可用，通常会用多个节点来组成router高可用集群；第二类是config server，这类角色主要用来保存mongodb分片集群中的数据和集群的元数据信息，有点类似mogilefs中的tracker的作用；为了保证config server的高可用性，通常config server也会将其运行为一个副本集；第三类是shard角色，这类角色主要用来存放数据，类似mogilefs的数据节点，为了保证数据的高可用和完整性，通常每个shard是一个副本集；&lt;/p&gt;
&lt;p&gt;　　4、mongodb分片集群工作过程&lt;/p&gt;
&lt;p&gt;　　首先用户将请求发送给router，router接收到用户请求，然后去找config server拿对应请求的元数据信息，router拿到元数据信息后，然后再向对应的shard请求数据，最后将数据整合后响应给用户；在这个过程中router 就相当于mongodb的一个客户端代理；而config server用来存放数据的元数据信息，这些信息主要包含了那些shard上存放了那些数据，对应的那些数据存放在那些shard上，和mogilefs上的tracker非常类似，主要存放了两张表，一个是以数据为中心的一张表，一个是以shard节点为中心的一张表；&lt;/p&gt;
&lt;p&gt; 　　5、mongodb是怎么分片的？&lt;/p&gt;
&lt;p&gt;　　在mongodb的分片集群中，分片是按照collection字段来分的，我们把指定的字段叫shard key；根据shard key的取值不同和应用场景，我们可以基于shard key取值范围来分片，也可以基于shard key做hash分片；分好片以后将结果保存在config server上；在configserver 上保存了每一个分片对应的数据集；比如我们基于shardkey的范围来分片，在configserver上就记录了一个连续范围的shardkey的值都保存在一个分片上；如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201111191733009-1766182313.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　上图主要描述了基于范围的分片，从shardkey最小值到最大值进行分片，把最小值到-75这个范围值的数据块保存在第一个分片上，把-75到25这个范围值的数据块保存在第二个分片上，依次类推；这种基于范围的分片，很容易导致某个分片上的数据过大，而有的分片上的数据又很小，造成分片数据不均匀；所以除了基与shard key的值的范围分片，也可以基于shard key的值做hash分片，如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201111192939501-1296330157.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　基于hash分片，主要是对shardkey做hash计算后，然后根据最后的结果落在哪个分片上就把对应的数据块保存在对应的分片上；比如我们把shandkey做hash计算，然后对分片数量进行取模计算，如果得到的结果是0，那么就把对应的数据块保存在第一个分片上，如果取得到结果是1就保存在第二个分片上依次类推；这种基于hash分片，就有效的降低分片数据不均衡的情况，因为hash计算的值是散列的；&lt;/p&gt;
&lt;p&gt;　　除了上述两种切片的方式以外，我们还可以根据区域切片，也叫基于列表切片，如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201111205732227-328952750.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　上图主要描述了基于区域分片，这种分片一般是针对shardkey的取值范围不是一个顺序的集合，而是一个离散的集合，比如我们可用这种方式对全国省份这个字段做切片，把流量特别大的省份单独切一个片，把流量小的几个省份组合切分一片，把国外的访问或不是国内省份的切分为一片；这种切片有点类似给shardkey做分类；不管用什么方式去做分片，我们尽可能的遵循写操作要越分散越好，读操作要越集中越好；&lt;/p&gt;
&lt;p&gt;　　6、mongodb分片集群搭建&lt;/p&gt;
&lt;p&gt;　　环境说明&lt;/p&gt;
&lt;table border=&quot;0&quot; align=&quot;left&quot;&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr&gt;&lt;td&gt;主机名&lt;/td&gt;
&lt;td&gt;角色&lt;/td&gt;
&lt;td&gt;ip地址&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;node01&lt;/td&gt;
&lt;td&gt;router&lt;/td&gt;
&lt;td&gt;192.168.0.41&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;node02/node03/node04&lt;/td&gt;
&lt;td&gt;config server replication set&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;192.168.0.42&lt;/p&gt;
&lt;p&gt;192.168.0.43&lt;/p&gt;
&lt;p&gt;192.168.0.44&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;node05/node06/node07&lt;/td&gt;
&lt;td&gt;shard1 replication set&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;192.168.0.45&lt;/p&gt;
&lt;p&gt;192.168.0.46&lt;/p&gt;
&lt;p&gt;192.168.0.47&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;node08/node09/node10&lt;/td&gt;
&lt;td&gt;shard2 replication set&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;192.168.0.48&lt;/p&gt;
&lt;p&gt;192.168.0.49&lt;/p&gt;
&lt;p&gt;192.168.0.50&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;














&lt;p&gt;　　基础环境，各server做时间同步，关闭防火墙，关闭selinux，ssh互信，主机名解析&lt;/p&gt;
&lt;p&gt;　　主机名解析&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node01 ~]# cat /etc/hosts
127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
::1         localhost localhost.localdomain localhost6 localhost6.localdomain6
192.168.0.99 time.test.org time-node
192.168.0.41 node01.test.org node01
192.168.0.42 node02.test.org node02
192.168.0.43 node03.test.org node03
192.168.0.44 node04.test.org node04
192.168.0.45 node05.test.org node05
192.168.0.46 node06.test.org node06
192.168.0.47 node07.test.org node07
192.168.0.48 node08.test.org node08
192.168.0.49 node09.test.org node09
192.168.0.50 node10.test.org node10
192.168.0.51 node11.test.org node11
192.168.0.52 node12.test.org node12
[root@node01 ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　准备好基础环境以后，配置mongodb yum源&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node01 ~]# cat /etc/yum.repos.d/mongodb.repo
[mongodb-org]
name = MongoDB Repository
baseurl = https://mirrors.aliyun.com/mongodb/yum/redhat/7/mongodb-org/4.4/x86_64/
gpgcheck = 1
enabled = 1
gpgkey = https://www.mongodb.org/static/pgp/server-4.4.asc
[root@node01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　将mongodb yum源复制给其他节点&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node01 ~]# for i in {02..10} ; do scp /etc/yum.repos.d/mongodb.repo node$i:/etc/yum.repos.d/; done
mongodb.repo                                                                  100%  206   247.2KB/s   00:00    
mongodb.repo                                                                  100%  206   222.3KB/s   00:00    
mongodb.repo                                                                  100%  206   118.7KB/s   00:00    
mongodb.repo                                                                  100%  206   164.0KB/s   00:00    
mongodb.repo                                                                  100%  206   145.2KB/s   00:00    
mongodb.repo                                                                  100%  206   119.9KB/s   00:00    
mongodb.repo                                                                  100%  206   219.2KB/s   00:00    
mongodb.repo                                                                  100%  206   302.1KB/s   00:00    
mongodb.repo                                                                  100%  206   289.3KB/s   00:00    
[root@node01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在每个节点上安装mongodb-org这个包&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
for i in {01..10} ; do ssh node$i ' yum -y install mongodb-org '; done
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在config server 和shard节点上创建数据目录和日志目录，并将其属主和属组更改为mongod&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node01 ~]# for i in {02..10} ; do ssh node$i 'mkdir -p /mongodb/{data,log} &amp;amp;&amp;amp; chown -R mongod.mongod /mongodb/ &amp;amp;&amp;amp; ls -ld /mongodb'; done
drwxr-xr-x 4 mongod mongod 29 Nov 11 22:47 /mongodb
drwxr-xr-x 4 mongod mongod 29 Nov 11 22:45 /mongodb
drwxr-xr-x 4 mongod mongod 29 Nov 11 22:45 /mongodb
drwxr-xr-x 4 mongod mongod 29 Nov 11 22:45 /mongodb
drwxr-xr-x 4 mongod mongod 29 Nov 11 22:45 /mongodb
drwxr-xr-x 4 mongod mongod 29 Nov 11 22:45 /mongodb
drwxr-xr-x 4 mongod mongod 29 Nov 11 22:45 /mongodb
drwxr-xr-x 4 mongod mongod 29 Nov 11 22:45 /mongodb
drwxr-xr-x 4 mongod mongod 29 Nov 11 22:45 /mongodb
[root@node01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　配置shard1 replication set&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node05 ~]# cat /etc/mongod.conf 
systemLog:
  destination: file
  logAppend: true
  path: /mongodb/log/mongod.log

storage:
  dbPath: /mongodb/data/
  journal:
    enabled: true

processManagement:
  fork: true
  pidFilePath: /var/run/mongodb/mongod.pid
  timeZoneInfo: /usr/share/zoneinfo

net:
  bindIp: 0.0.0.0

sharding:
  clusterRole: shardsvr

replication:
  replSetName: shard1_replset
[root@node05 ~]# scp /etc/mongod.conf node06:/etc/
mongod.conf                                                                   100%  360   394.5KB/s   00:00    
[root@node05 ~]# scp /etc/mongod.conf node07:/etc/
mongod.conf                                                                   100%  360   351.7KB/s   00:00    
[root@node05 ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　配置shard2 replication set&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node08 ~]# cat /etc/mongod.conf
systemLog:
  destination: file
  logAppend: true
  path: /mongodb/log/mongod.log

storage:
  dbPath: /mongodb/data/
  journal:
    enabled: true

processManagement:
  fork: true
  pidFilePath: /var/run/mongodb/mongod.pid
  timeZoneInfo: /usr/share/zoneinfo

net:
  bindIp: 0.0.0.0

sharding:
  clusterRole: shardsvr

replication:
  replSetName: shard2_replset
[root@node08 ~]# scp /etc/mongod.conf node09:/etc/
mongod.conf                                                                   100%  360   330.9KB/s   00:00    
[root@node08 ~]# scp /etc/mongod.conf node10:/etc/
mongod.conf                                                                   100%  360   385.9KB/s   00:00    
[root@node08 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　启动shard1 replication set和shard2 replication set&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node05 ~]# systemctl start mongod.service 
[root@node05 ~]# ss -tnl
State      Recv-Q Send-Q           Local Address:Port                          Peer Address:Port              
LISTEN     0      128                          *:22                                       *:*                  
LISTEN     0      100                  127.0.0.1:25                                       *:*                  
LISTEN     0      128                          *:27018                                    *:*                  
LISTEN     0      128                         :::22                                      :::*                  
LISTEN     0      100                        ::1:25                                      :::*                  
[root@node05 ~]#for i in {06..10} ; do ssh node$i 'systemctl start mongod.service &amp;amp;&amp;amp; ss -tnl';done
State      Recv-Q Send-Q Local Address:Port               Peer Address:Port              
LISTEN     0      128          *:22                       *:*                  
LISTEN     0      100    127.0.0.1:25                       *:*                  
LISTEN     0      128          *:27018                    *:*                  
LISTEN     0      128         :::22                      :::*                  
LISTEN     0      100        ::1:25                      :::*                  
State      Recv-Q Send-Q Local Address:Port               Peer Address:Port              
LISTEN     0      128          *:22                       *:*                  
LISTEN     0      100    127.0.0.1:25                       *:*                  
LISTEN     0      128          *:27018                    *:*                  
LISTEN     0      128         :::22                      :::*                  
LISTEN     0      100        ::1:25                      :::*                  
State      Recv-Q Send-Q Local Address:Port               Peer Address:Port              
LISTEN     0      128          *:22                       *:*                  
LISTEN     0      100    127.0.0.1:25                       *:*                  
LISTEN     0      128          *:27018                    *:*                  
LISTEN     0      128         :::22                      :::*                  
LISTEN     0      100        ::1:25                      :::*                  
State      Recv-Q Send-Q Local Address:Port               Peer Address:Port              
LISTEN     0      128          *:22                       *:*                  
LISTEN     0      100    127.0.0.1:25                       *:*                  
LISTEN     0      128          *:27018                    *:*                  
LISTEN     0      128         :::22                      :::*                  
LISTEN     0      100        ::1:25                      :::*                  
State      Recv-Q Send-Q Local Address:Port               Peer Address:Port              
LISTEN     0      128          *:22                       *:*                  
LISTEN     0      100    127.0.0.1:25                       *:*                  
LISTEN     0      128          *:27018                    *:*                  
LISTEN     0      128         :::22                      :::*                  
LISTEN     0      100        ::1:25                      :::*                  
[root@node05 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：默认不指定shard监听端口，它默认就监听在27018端口，所以启动shard节点后，请确保27018端口正常监听即可；&lt;/p&gt;
&lt;p&gt;　　连接node05的mongodb 初始化shard1_replset副本集&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;48&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
&amp;gt; rs.initiate(
...   {
...     _id : &quot;shard1_replset&quot;,
...     members: [
...       { _id : 0, host : &quot;node05:27018&quot; },
...       { _id : 1, host : &quot;node06:27018&quot; },
...       { _id : 2, host : &quot;node07:27018&quot; }
...     ]
...   }
... )
{
        &quot;ok&quot; : 1,
        &quot;$clusterTime&quot; : {
                &quot;clusterTime&quot; : Timestamp(1605107401, 1),
                &quot;signature&quot; : {
                        &quot;hash&quot; : BinData(0,&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAA=&quot;),
                        &quot;keyId&quot; : NumberLong(0)
                }
        },
        &quot;operationTime&quot; : Timestamp(1605107401, 1)
}
shard1_replset:SECONDARY&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　连接node08的mongodb 初始化shard2_replset副本集&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;48&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
&amp;gt; rs.initiate(
...   {
...     _id : &quot;shard2_replset&quot;,
...     members: [
...       { _id : 0, host : &quot;node08:27018&quot; },
...       { _id : 1, host : &quot;node09:27018&quot; },
...       { _id : 2, host : &quot;node10:27018&quot; }
...     ]
...   }
... )
{
        &quot;ok&quot; : 1,
        &quot;$clusterTime&quot; : {
                &quot;clusterTime&quot; : Timestamp(1605107644, 1),
                &quot;signature&quot; : {
                        &quot;hash&quot; : BinData(0,&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAA=&quot;),
                        &quot;keyId&quot; : NumberLong(0)
                }
        },
        &quot;operationTime&quot; : Timestamp(1605107644, 1)
}
shard2_replset:OTHER&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　配置configserver replication set &lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node02 ~]# cat /etc/mongod.conf
systemLog:
  destination: file
  logAppend: true
  path: /mongodb/log/mongod.log

storage:
  dbPath: /mongodb/data/
  journal:
    enabled: true

processManagement:
  fork: true
  pidFilePath: /var/run/mongodb/mongod.pid
  timeZoneInfo: /usr/share/zoneinfo

net:
  bindIp: 0.0.0.0

sharding:
  clusterRole: configsvr

replication:
  replSetName: cfg_replset
[root@node02 ~]# scp /etc/mongod.conf node03:/etc/mongod.conf 
mongod.conf                                                                   100%  358   398.9KB/s   00:00    
[root@node02 ~]# scp /etc/mongod.conf node04:/etc/mongod.conf  
mongod.conf                                                                   100%  358   270.7KB/s   00:00    
[root@node02 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　启动config server&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node02 ~]# systemctl start mongod.service 
[root@node02 ~]# ss -tnl
State      Recv-Q Send-Q           Local Address:Port                          Peer Address:Port              
LISTEN     0      128                          *:27019                                    *:*                  
LISTEN     0      128                          *:22                                       *:*                  
LISTEN     0      100                  127.0.0.1:25                                       *:*                  
LISTEN     0      128                         :::22                                      :::*                  
LISTEN     0      100                        ::1:25                                      :::*                  
[root@node02 ~]# ssh node03 'systemctl start mongod.service &amp;amp;&amp;amp; ss -tnl'  
State      Recv-Q Send-Q Local Address:Port               Peer Address:Port              
LISTEN     0      128          *:27019                    *:*                  
LISTEN     0      128          *:22                       *:*                  
LISTEN     0      100    127.0.0.1:25                       *:*                  
LISTEN     0      128         :::22                      :::*                  
LISTEN     0      100        ::1:25                      :::*                  
[root@node02 ~]# ssh node04 'systemctl start mongod.service &amp;amp;&amp;amp; ss -tnl' 
State      Recv-Q Send-Q Local Address:Port               Peer Address:Port              
LISTEN     0      128          *:27019                    *:*                  
LISTEN     0      128          *:22                       *:*                  
LISTEN     0      100    127.0.0.1:25                       *:*                  
LISTEN     0      128         :::22                      :::*                  
LISTEN     0      100        ::1:25                      :::*                  
[root@node02 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：config server 默认在不指定端口的情况监听在27019这个端口，启动后，请确保该端口处于正常监听；&lt;/p&gt;
&lt;p&gt;　　连接node02的mongodb，初始化cfg_replset 副本集&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;54&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
&amp;gt; rs.initiate(
...   {
...     _id: &quot;cfg_replset&quot;,
...     configsvr: true,
...     members: [
...       { _id : 0, host : &quot;node02:27019&quot; },
...       { _id : 1, host : &quot;node03:27019&quot; },
...       { _id : 2, host : &quot;node04:27019&quot; }
...     ]
...   }
... )
{
        &quot;ok&quot; : 1,
        &quot;$gleStats&quot; : {
                &quot;lastOpTime&quot; : Timestamp(1605108177, 1),
                &quot;electionId&quot; : ObjectId(&quot;000000000000000000000000&quot;)
        },
        &quot;lastCommittedOpTime&quot; : Timestamp(0, 0),
        &quot;$clusterTime&quot; : {
                &quot;clusterTime&quot; : Timestamp(1605108177, 1),
                &quot;signature&quot; : {
                        &quot;hash&quot; : BinData(0,&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAA=&quot;),
                        &quot;keyId&quot; : NumberLong(0)
                }
        },
        &quot;operationTime&quot; : Timestamp(1605108177, 1)
}
cfg_replset:SECONDARY&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　配置router&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node01 ~]# cat /etc/mongos.conf
systemLog:
   destination: file
   path: /var/log/mongodb/mongos.log
   logAppend: true

processManagement:
   fork: true

net:
   bindIp: 0.0.0.0
sharding:
  configDB: &quot;cfg_replset/node02:27019,node03:27019,node04:27019&quot;
[root@node01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：configDB必须是副本集名称/成员监听地址：port的形式，成员至少要写一个；&lt;/p&gt;
&lt;p&gt;　　启动router&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node01 ~]# mongos -f /etc/mongos.conf
about to fork child process, waiting until server is ready for connections.
forked process: 1510
child process started successfully, parent exiting
[root@node01 ~]# ss -tnl
State      Recv-Q Send-Q           Local Address:Port                          Peer Address:Port              
LISTEN     0      128                          *:22                                       *:*                  
LISTEN     0      100                  127.0.0.1:25                                       *:*                  
LISTEN     0      128                          *:27017                                    *:*                  
LISTEN     0      128                         :::22                                      :::*                  
LISTEN     0      100                        ::1:25                                      :::*                  
[root@node01 ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　连接mongos，添加shard1 replication set 和shard2 replication set&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;55&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
mongos&amp;gt; sh.addShard(&quot;shard1_replset/node05:27018,node06:27018,node07:27018&quot;)
{
        &quot;shardAdded&quot; : &quot;shard1_replset&quot;,
        &quot;ok&quot; : 1,
        &quot;operationTime&quot; : Timestamp(1605109085, 3),
        &quot;$clusterTime&quot; : {
                &quot;clusterTime&quot; : Timestamp(1605109086, 1),
                &quot;signature&quot; : {
                        &quot;hash&quot; : BinData(0,&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAA=&quot;),
                        &quot;keyId&quot; : NumberLong(0)
                }
        }
}
mongos&amp;gt; sh.addShard(&quot;shard2_replset/node08:27018,node09:27018,node10:27018&quot;)
{
        &quot;shardAdded&quot; : &quot;shard2_replset&quot;,
        &quot;ok&quot; : 1,
        &quot;operationTime&quot; : Timestamp(1605109118, 2),
        &quot;$clusterTime&quot; : {
                &quot;clusterTime&quot; : Timestamp(1605109118, 3),
                &quot;signature&quot; : {
                        &quot;hash&quot; : BinData(0,&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAA=&quot;),
                        &quot;keyId&quot; : NumberLong(0)
                }
        }
}
mongos&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：添加shard 副本集也是需要指明副本集名称/成员的格式添加；&lt;/p&gt;
&lt;p&gt;　　到此分片集群就配置好了&lt;/p&gt;
&lt;p&gt;　　查看sharding 集群状态&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;49&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
mongos&amp;gt; sh.status()
--- Sharding Status --- 
  sharding version: {
        &quot;_id&quot; : 1,
        &quot;minCompatibleVersion&quot; : 5,
        &quot;currentVersion&quot; : 6,
        &quot;clusterId&quot; : ObjectId(&quot;5fac01dd8d6fa3fe899662c8&quot;)
  }
  shards:
        {  &quot;_id&quot; : &quot;shard1_replset&quot;,  &quot;host&quot; : &quot;shard1_replset/node05:27018,node06:27018,node07:27018&quot;,  &quot;state&quot; : 1 }
        {  &quot;_id&quot; : &quot;shard2_replset&quot;,  &quot;host&quot; : &quot;shard2_replset/node08:27018,node09:27018,node10:27018&quot;,  &quot;state&quot; : 1 }
  active mongoses:
        &quot;4.4.1&quot; : 1
  autosplit:
        Currently enabled: yes
  balancer:
        Currently enabled:  yes
        Currently running:  yes
        Collections with active migrations: 
                config.system.sessions started at Wed Nov 11 2020 23:43:14 GMT+0800 (CST)
        Failed balancer rounds in last 5 attempts:  0
        Migration Results for the last 24 hours: 
                45 : Success
  databases:
        {  &quot;_id&quot; : &quot;config&quot;,  &quot;primary&quot; : &quot;config&quot;,  &quot;partitioned&quot; : true }
                config.system.sessions
                        shard key: { &quot;_id&quot; : 1 }
                        unique: false
                        balancing: true
                        chunks:
                                shard1_replset  978
                                shard2_replset  46
                        too many chunks to print, use verbose if you want to force print
mongos&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到当前分片集群中有两个shard 副本集，分别是shard1_replset和shard2_replset；以及一个config server &lt;/p&gt;
&lt;p&gt;　　对testdb数据库启用sharding功能&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;60&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
mongos&amp;gt; sh.enableSharding(&quot;testdb&quot;)
{
        &quot;ok&quot; : 1,
        &quot;operationTime&quot; : Timestamp(1605109993, 9),
        &quot;$clusterTime&quot; : {
                &quot;clusterTime&quot; : Timestamp(1605109993, 9),
                &quot;signature&quot; : {
                        &quot;hash&quot; : BinData(0,&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAA=&quot;),
                        &quot;keyId&quot; : NumberLong(0)
                }
        }
}
mongos&amp;gt; sh.status()
--- Sharding Status --- 
  sharding version: {
        &quot;_id&quot; : 1,
        &quot;minCompatibleVersion&quot; : 5,
        &quot;currentVersion&quot; : 6,
        &quot;clusterId&quot; : ObjectId(&quot;5fac01dd8d6fa3fe899662c8&quot;)
  }
  shards:
        {  &quot;_id&quot; : &quot;shard1_replset&quot;,  &quot;host&quot; : &quot;shard1_replset/node05:27018,node06:27018,node07:27018&quot;,  &quot;state&quot; : 1 }
        {  &quot;_id&quot; : &quot;shard2_replset&quot;,  &quot;host&quot; : &quot;shard2_replset/node08:27018,node09:27018,node10:27018&quot;,  &quot;state&quot; : 1 }
  active mongoses:
        &quot;4.4.1&quot; : 1
  autosplit:
        Currently enabled: yes
  balancer:
        Currently enabled:  yes
        Currently running:  no
        Failed balancer rounds in last 5 attempts:  0
        Migration Results for the last 24 hours: 
                214 : Success
  databases:
        {  &quot;_id&quot; : &quot;config&quot;,  &quot;primary&quot; : &quot;config&quot;,  &quot;partitioned&quot; : true }
                config.system.sessions
                        shard key: { &quot;_id&quot; : 1 }
                        unique: false
                        balancing: true
                        chunks:
                                shard1_replset  810
                                shard2_replset  214
                        too many chunks to print, use verbose if you want to force print
        {  &quot;_id&quot; : &quot;testdb&quot;,  &quot;primary&quot; : &quot;shard2_replset&quot;,  &quot;partitioned&quot; : true,  &quot;version&quot; : {  &quot;uuid&quot; : UUID(&quot;454aad2e-b397-4c88-b5c4-c3b21d37e480&quot;),  &quot;lastMod&quot; : 1 } }
mongos&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：在对某个数据库启动sharding功能后，它会给我们分片一个主shard所谓主shard是用来存放该数据库下没有做分片的colleciton；对于分片的collection会分散在各个shard上；&lt;/p&gt;
&lt;p&gt;　　启用对testdb库下的peoples集合启动sharding，并指明在age字段上做基于范围的分片&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;64&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
mongos&amp;gt; sh.shardCollection(&quot;testdb.peoples&quot;,{&quot;age&quot;:1})
{
        &quot;collectionsharded&quot; : &quot;testdb.peoples&quot;,
        &quot;collectionUUID&quot; : UUID(&quot;ec095411-240d-4484-b45d-b541c33c3975&quot;),
        &quot;ok&quot; : 1,
        &quot;operationTime&quot; : Timestamp(1605110694, 11),
        &quot;$clusterTime&quot; : {
                &quot;clusterTime&quot; : Timestamp(1605110694, 11),
                &quot;signature&quot; : {
                        &quot;hash&quot; : BinData(0,&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAA=&quot;),
                        &quot;keyId&quot; : NumberLong(0)
                }
        }
}
mongos&amp;gt; sh.status()
--- Sharding Status --- 
  sharding version: {
        &quot;_id&quot; : 1,
        &quot;minCompatibleVersion&quot; : 5,
        &quot;currentVersion&quot; : 6,
        &quot;clusterId&quot; : ObjectId(&quot;5fac01dd8d6fa3fe899662c8&quot;)
  }
  shards:
        {  &quot;_id&quot; : &quot;shard1_replset&quot;,  &quot;host&quot; : &quot;shard1_replset/node05:27018,node06:27018,node07:27018&quot;,  &quot;state&quot; : 1 }
        {  &quot;_id&quot; : &quot;shard2_replset&quot;,  &quot;host&quot; : &quot;shard2_replset/node08:27018,node09:27018,node10:27018&quot;,  &quot;state&quot; : 1 }
  active mongoses:
        &quot;4.4.1&quot; : 1
  autosplit:
        Currently enabled: yes
  balancer:
        Currently enabled:  yes
        Currently running:  no
        Failed balancer rounds in last 5 attempts:  0
        Migration Results for the last 24 hours: 
                408 : Success
  databases:
        {  &quot;_id&quot; : &quot;config&quot;,  &quot;primary&quot; : &quot;config&quot;,  &quot;partitioned&quot; : true }
                config.system.sessions
                        shard key: { &quot;_id&quot; : 1 }
                        unique: false
                        balancing: true
                        chunks:
                                shard1_replset  616
                                shard2_replset  408
                        too many chunks to print, use verbose if you want to force print
        {  &quot;_id&quot; : &quot;testdb&quot;,  &quot;primary&quot; : &quot;shard2_replset&quot;,  &quot;partitioned&quot; : true,  &quot;version&quot; : {  &quot;uuid&quot; : UUID(&quot;454aad2e-b397-4c88-b5c4-c3b21d37e480&quot;),  &quot;lastMod&quot; : 1 } }
                testdb.peoples
                        shard key: { &quot;age&quot; : 1 }
                        unique: false
                        balancing: true
                        chunks:
                                shard2_replset  1
                        { &quot;age&quot; : { &quot;$minKey&quot; : 1 } } --&amp;gt;&amp;gt; { &quot;age&quot; : { &quot;$maxKey&quot; : 1 } } on : shard2_replset Timestamp(1, 0) 
mongos&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：如果对应的collection存在，我们还需要先对collection创建shardkey索引，然后在使用sh.shardCollection()来对colleciton启用sharding功能；基于范围做分片，我们可以在多个字段上做；&lt;/p&gt;
&lt;p&gt;　　基于hash做分片&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;68&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
mongos&amp;gt; sh.shardCollection(&quot;testdb.peoples1&quot;,{&quot;name&quot;:&quot;hashed&quot;})
{
        &quot;collectionsharded&quot; : &quot;testdb.peoples1&quot;,
        &quot;collectionUUID&quot; : UUID(&quot;f6213da1-7c7d-4d5e-8fb1-fc554efb9df2&quot;),
        &quot;ok&quot; : 1,
        &quot;operationTime&quot; : Timestamp(1605111014, 2),
        &quot;$clusterTime&quot; : {
                &quot;clusterTime&quot; : Timestamp(1605111014, 2),
                &quot;signature&quot; : {
                        &quot;hash&quot; : BinData(0,&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAA=&quot;),
                        &quot;keyId&quot; : NumberLong(0)
                }
        }
}
mongos&amp;gt; sh.status()
--- Sharding Status --- 
  sharding version: {
        &quot;_id&quot; : 1,
        &quot;minCompatibleVersion&quot; : 5,
        &quot;currentVersion&quot; : 6,
        &quot;clusterId&quot; : ObjectId(&quot;5fac01dd8d6fa3fe899662c8&quot;)
  }
  shards:
        {  &quot;_id&quot; : &quot;shard1_replset&quot;,  &quot;host&quot; : &quot;shard1_replset/node05:27018,node06:27018,node07:27018&quot;,  &quot;state&quot; : 1 }
        {  &quot;_id&quot; : &quot;shard2_replset&quot;,  &quot;host&quot; : &quot;shard2_replset/node08:27018,node09:27018,node10:27018&quot;,  &quot;state&quot; : 1 }
  active mongoses:
        &quot;4.4.1&quot; : 1
  autosplit:
        Currently enabled: yes
  balancer:
        Currently enabled:  yes
        Currently running:  yes
        Collections with active migrations: 
                config.system.sessions started at Thu Nov 12 2020 00:10:16 GMT+0800 (CST)
        Failed balancer rounds in last 5 attempts:  0
        Migration Results for the last 24 hours: 
                480 : Success
  databases:
        {  &quot;_id&quot; : &quot;config&quot;,  &quot;primary&quot; : &quot;config&quot;,  &quot;partitioned&quot; : true }
                config.system.sessions
                        shard key: { &quot;_id&quot; : 1 }
                        unique: false
                        balancing: true
                        chunks:
                                shard1_replset  543
                                shard2_replset  481
                        too many chunks to print, use verbose if you want to force print
        {  &quot;_id&quot; : &quot;testdb&quot;,  &quot;primary&quot; : &quot;shard2_replset&quot;,  &quot;partitioned&quot; : true,  &quot;version&quot; : {  &quot;uuid&quot; : UUID(&quot;454aad2e-b397-4c88-b5c4-c3b21d37e480&quot;),  &quot;lastMod&quot; : 1 } }
                testdb.peoples
                        shard key: { &quot;age&quot; : 1 }
                        unique: false
                        balancing: true
                        chunks:
                                shard2_replset  1
                        { &quot;age&quot; : { &quot;$minKey&quot; : 1 } } --&amp;gt;&amp;gt; { &quot;age&quot; : { &quot;$maxKey&quot; : 1 } } on : shard2_replset Timestamp(1, 0) 
                testdb.peoples1
                        shard key: { &quot;name&quot; : &quot;hashed&quot; }
                        unique: false
                        balancing: true
                        chunks:
                                shard1_replset  2
                                shard2_replset  2
                        { &quot;name&quot; : { &quot;$minKey&quot; : 1 } } --&amp;gt;&amp;gt; { &quot;name&quot; : NumberLong(&quot;-4611686018427387902&quot;) } on : shard1_replset Timestamp(1, 0) 
                        { &quot;name&quot; : NumberLong(&quot;-4611686018427387902&quot;) } --&amp;gt;&amp;gt; { &quot;name&quot; : NumberLong(0) } on : shard1_replset Timestamp(1, 1) 
                        { &quot;name&quot; : NumberLong(0) } --&amp;gt;&amp;gt; { &quot;name&quot; : NumberLong(&quot;4611686018427387902&quot;) } on : shard2_replset Timestamp(1, 2) 
                        { &quot;name&quot; : NumberLong(&quot;4611686018427387902&quot;) } --&amp;gt;&amp;gt; { &quot;name&quot; : { &quot;$maxKey&quot; : 1 } } on : shard2_replset Timestamp(1, 3) 
mongos&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：基于hash做分片只能在一个字段上做，不能指定多个字段；从上面的状态信息可以看到testdb.peoples被分到了shard2上，peoples1一部分分到了shard1，一部分分到了shard2上；所以在peoples中插入多少条数据，它都会写到shard2上，在peoples1中插入数据会被写入到shard1和shard2上；&lt;/p&gt;
&lt;p&gt;　　验证：在peoples1 集合上插入数据，看看是否将数据分片到不同的shard上呢？&lt;/p&gt;
&lt;p&gt;　　在mongos上插入数据&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
mongos&amp;gt; use testdb
switched to db testdb
mongos&amp;gt; for (i=1;i&amp;lt;=10000;i++) db.peoples1.insert({name:&quot;people&quot;+i,age:(i%120),classes:(i%20)})
WriteResult({ &quot;nInserted&quot; : 1 })
mongos&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在shard1上查看数据&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
shard1_replset:PRIMARY&amp;gt; show dbs
admin   0.000GB
config  0.001GB
local   0.001GB
testdb  0.000GB
shard1_replset:PRIMARY&amp;gt; use testdb
switched to db testdb
shard1_replset:PRIMARY&amp;gt; show tables
peoples1
shard1_replset:PRIMARY&amp;gt; db.peoples1.find().count()
4966
shard1_replset:PRIMARY&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：在shard1上可以看到对应collection保存了4966条数据；&lt;/p&gt;
&lt;p&gt;　　在shard2上查看数据&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
shard2_replset:PRIMARY&amp;gt; show dbs
admin   0.000GB
config  0.001GB
local   0.011GB
testdb  0.011GB
shard2_replset:PRIMARY&amp;gt; use testdb
switched to db testdb
shard2_replset:PRIMARY&amp;gt; show tables
peoples
peoples1
shard2_replset:PRIMARY&amp;gt; db.peoples1.find().count()
5034
shard2_replset:PRIMARY&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：在shard2上可以看到有peoples集合和peoples1集合，其中peoples1集合保存了5034条数据；shard1和shard2总共就保存了我们刚才插入的10000条数据；&lt;/p&gt;
&lt;p&gt;　　ok,到此mongodb的分片集群就搭建，测试完毕了；&lt;/p&gt;
</description>
<pubDate>Wed, 11 Nov 2020 17:12:00 +0000</pubDate>
<dc:creator>Linux-1874</dc:creator>
<og:description>前文我们聊到了mongodb的副本集以及配置副本集，回顾请参考https://www.cnblogs.com/qiuhom-1874/p/13953598.html；今天我们来聊下mongodb的分片</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qiuhom-1874/p/13958295.html</dc:identifier>
</item>
<item>
<title>时间序列数据的定义，读取与指数平滑（Java） - 心拍数#0822</title>
<link>http://www.cnblogs.com/zhaoke271828/p/13960761.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhaoke271828/p/13960761.html</guid>
<description>&lt;p&gt;　　应上头的要求，需要实现以下指数平滑进行资源调度负载的预测，那就是用我最喜欢的Java做一下吧。&lt;/p&gt;
&lt;p&gt;　　引用《计量经济学导论》的一句话：时间序列数据区别于横截面数据的一个明显特点是，时间序列数据集是按照时间顺序排列的。&lt;/p&gt;
&lt;p&gt;　　显然，横截面数据被视为随机的结果，也就是说在总体中随机抽取样本。时间序列数据和横截面数据区别较为微妙，虽然它也满足随机性，但是这个序列标有时间脚标，依照时间有序，而不可以让时间随机排列导致错乱，我们不能让时间逆转重新开始这个过程。对于这样的序列我们称之为随机过程，或者时间序列过程。&lt;/p&gt;
&lt;p&gt;　　对于时间序列，经常研究的一个问题就是预测，而指数平滑法是非常常见也常用的方法之一。这里对于二次指数平滑进行Java的实现（一次指数平滑包含在二次指数平滑之内）。其原理参照： https://cloud.tencent.com/developer/article/1058557 。这里就不再赘述。&lt;/p&gt;

&lt;p&gt;数据也是参照我国1981年至1983年度平板玻璃月产量数据，以下文件保存为data2.txt&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;71&quot;&gt;
&lt;pre&gt;
&lt;span&gt;我国1981年至1983年度平板玻璃月产量数据
&lt;/span&gt;1,240.3
2,222.8
3,243.1
4,222.2
5,222.6
6,218.7
7,234.5
8,248.6
9,261
10,275.3
11,269.4
12,291.2
13,301.9
14,285.5
15,286.6
16,260.5
17,298.5
18,291.8
19,267.3
20,277.9
21,303.5
22,313.3
23,327.6
24,338.3
25,340.37
26,318.51
27,336.85
28,326.64
29,342.9
30,337.53
31,320.09
32,332.17
33,344.01
34,335.79
35,350.67
36,367.37
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于以上数据，时间是int类型，而产量是double类型，为了便于读取，对于以上数据定义行数据类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; timeSeries;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RowData {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; time;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; value;
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; RowData() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated constructor stub&lt;/span&gt;
&lt;span&gt;    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; RowData(&lt;span&gt;int&lt;/span&gt; time, &lt;span&gt;double&lt;/span&gt;&lt;span&gt; value) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.time =&lt;span&gt; time;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.value =&lt;span&gt; value;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getTime() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; time;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setTime(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; time) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.time =&lt;span&gt; time;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; getValue() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; value;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setValue(&lt;span&gt;double&lt;/span&gt;&lt;span&gt; value) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.value =&lt;span&gt; value;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后定义文件读取类，读取所得数据为RowData数组&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; utilFile;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.BufferedReader;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.File;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.FileNotFoundException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.FileReader;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.ArrayList;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; timeSeries.RowData;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FileOpts {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ArrayList&amp;lt;RowData&amp;gt; loadTxt(String dataPath, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; ishead) {
        File file &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; File(dataPath);
        FileReader fr;
        ArrayList&lt;/span&gt;&amp;lt;RowData&amp;gt; datas = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;RowData&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            fr &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileReader(file);
            BufferedReader br &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BufferedReader(fr);
            String line &lt;/span&gt;= &quot;&quot;&lt;span&gt;;
            String[] splitdata;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ishead) {
                br.readLine();
            }
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; ((line = br.readLine()) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                splitdata &lt;/span&gt;= line.split(&quot;,&quot;&lt;span&gt;);
                datas.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; RowData(Integer.parseInt(splitdata[0]), Double.parseDouble(splitdata[1&lt;span&gt;])));
            }
            br.close();
            fr.close();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (FileNotFoundException e) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated catch block&lt;/span&gt;
&lt;span&gt;            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated catch block&lt;/span&gt;
&lt;span&gt;            e.printStackTrace();
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; datas;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后定义时间序列分析类，其实就是一个函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;110&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; timeSeries;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.ArrayList;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Iterator;


&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ExponentialSmoothing2 {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;[][] expSmoothOrder2(&lt;span&gt;int&lt;/span&gt;[] time, &lt;span&gt;double&lt;/span&gt;[] values, &lt;span&gt;double&lt;/span&gt; alpha, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; preNum) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; len =&lt;span&gt; time.length;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回一个汇总表&lt;/span&gt;
        &lt;span&gt;double&lt;/span&gt;[][] result = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;[len + preNum][7&lt;span&gt;];
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第一列时间，第二列实际观察值&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; len; i++&lt;span&gt;) {
            result[i][&lt;/span&gt;0] =&lt;span&gt; time[i];
            result[i][&lt;/span&gt;1] =&lt;span&gt; values[i];
        }
    
        result[&lt;/span&gt;0][2] = values[0&lt;span&gt;];
        result[&lt;/span&gt;0][3] = result[0][2&lt;span&gt;];
    
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第三列一次指数平滑值，第四列二次指数平滑值
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; S1, S2 2, 3&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 1; i &amp;lt; len; i++&lt;span&gt;) {
            result[i][&lt;/span&gt;2] = alpha*values[i] + (1-alpha)*result[i-1][2&lt;span&gt;];
            result[i][&lt;/span&gt;3] = alpha*result[i][2] + (1-alpha)*result[i-1][3&lt;span&gt;];
        }
    
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第五列a，第六列b
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; a, b 4, 5&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 1; i &amp;lt; len; i++&lt;span&gt;) {
            result[i][&lt;/span&gt;4] = 2*result[i][2] - result[i][3&lt;span&gt;];
            result[i][&lt;/span&gt;5] = alpha/(1-alpha) * (result[i][2] - result[i][3&lt;span&gt;]);
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第七列预测值F
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; F 6&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 1; i &amp;lt; len; i++&lt;span&gt;) {
            result[i&lt;/span&gt;+preNum][6] = result[i][4] + result[i][5] *&lt;span&gt; preNum;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取数据&lt;/span&gt;
        ArrayList&amp;lt;RowData&amp;gt; data = utilFile.FileOpts.loadTxt(&quot;src/timeSeries/data2.txt&quot;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; len =&lt;span&gt; data.size();
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;[] time = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[len];
        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;[] values = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt;[len];
        Iterator&lt;/span&gt;&amp;lt;RowData&amp;gt; it =&lt;span&gt; data.iterator();
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; index = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (it.hasNext()) {
            RowData rowData &lt;/span&gt;=&lt;span&gt; (RowData) it.next();
            time[index] &lt;/span&gt;=&lt;span&gt; rowData.getTime();
            values[index] &lt;/span&gt;=&lt;span&gt; rowData.getValue();
            index&lt;/span&gt;++&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; -------------------数据准备完毕---------------
        
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        System.out.println(Arrays.toString(time));
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        System.out.println(Arrays.toString(values));
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ------------------二次指数平滑---------------------&lt;/span&gt;
        &lt;span&gt;double&lt;/span&gt;[][] pre2= expSmoothOrder2(time, values, 0.5, 1&lt;span&gt;);
        System.out.printf(&lt;/span&gt;&quot;%6s, %6s, %6s, %6s, %6s, %6s, %6s\n&quot;, &quot;time&quot;, &quot;y&quot;, &quot;s1&quot;, &quot;s2&quot;, &quot;a&quot;, &quot;b&quot;, &quot;F&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; values.length; i++&lt;span&gt;) {
            System.out.printf(&lt;/span&gt;&quot;%6.2f, %6.2f, %6.2f, %6.2f, %6.2f, %6.2f, %6.2f \n&quot;, pre2[i][0], pre2[i][1], pre2[i][2&lt;span&gt;],
                    pre2[i][&lt;/span&gt;3], pre2[i][4], pre2[i][5], pre2[i][6&lt;span&gt;]);
        }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        System.out.printf(&quot;%6d, %6d, %6d, %6d, %6d, %6d, %6.2f \n&quot;, 37, 0, 0, 0, 0, 0, pre2[values.length][3]);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        System.out.printf(&quot;%6d, %6d, %6d, %6d, %6d, %6d, %6.2f \n&quot;, 38, 0, 0, 0, 0, 0, pre2[35][1] + pre2[35][2] * 2);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 误差分析&lt;/span&gt;
        &lt;span&gt;double&lt;/span&gt; MSE = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; MAPE = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt; temp;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        System.out.println(&quot;pre2.length = &quot;+pre2.length);&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 2; i &amp;lt; pre2.length-1; i++&lt;span&gt;) {
            MSE &lt;/span&gt;+= (pre2[i][1]-pre2[i][6])*(pre2[i][1]-pre2[i][6])/(pre2.length-2&lt;span&gt;);
            temp &lt;/span&gt;= (pre2[i][1]-pre2[i][6])/pre2[i][1&lt;span&gt;];
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (temp &amp;lt; 0&lt;span&gt;) {
                MAPE &lt;/span&gt;-= temp/(pre2.length-2&lt;span&gt;);
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                MAPE &lt;/span&gt;+= temp/(pre2.length-2&lt;span&gt;);
            }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            System.out.printf(&quot;iter: %d, y = %6.2f, F = %6.2f, MSE = %6.2f, MAPE = %6.5f\n&quot;, i, pre2[i][1], pre2[i][6], MSE, MAPE);&lt;/span&gt;
&lt;span&gt;        }
        System.out.printf(&lt;/span&gt;&quot;MSE = %6.2f, MAPE = %6.5f\n&quot;&lt;span&gt;, MSE, MAPE);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (MAPE &amp;lt; 0.05&lt;span&gt;) {
            System.out.println(&lt;/span&gt;&quot;百分误差小于0.05，预测精度较高&quot;&lt;span&gt;);
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            System.out.println(&lt;/span&gt;&quot;预测误差超过了0.05&quot;&lt;span&gt;);
        }
    }


}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1812789/202011/1812789-20201112003007564-75011383.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1812789/202011/1812789-20201112003020810-601209385.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　事实上还可以使用Java进行时间序列图像绘制，毕竟Java跑完python或matlab绘图还挺麻烦，Java也是可以实现的，只不过为了方便需要写一个庞大的API，日后闲下来再写一篇博客细说。&lt;/p&gt;
</description>
<pubDate>Wed, 11 Nov 2020 16:33:00 +0000</pubDate>
<dc:creator>心拍数#0822</dc:creator>
<og:description>时间序列，指数平滑，文件读取，数据建模</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhaoke271828/p/13960761.html</dc:identifier>
</item>
<item>
<title>你还再为下载jar包慢而烦恼吗？Maven配置阿里云镜像 - 一只胡说八道的猴子</title>
<link>http://www.cnblogs.com/pjhaymy/p/13961719.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pjhaymy/p/13961719.html</guid>
<description>&lt;h2 id=&quot;maven配置阿里云镜像&quot;&gt;Maven配置阿里云镜像&lt;/h2&gt;
&lt;h2 id=&quot;为什么我们下载jar这么慢&quot;&gt;为什么我们下载jar这么慢&lt;/h2&gt;
&lt;p&gt;maven默认会从中央仓库下载jar包，这个仓库在国外，而且全世界的人都会从这里下载，所以下载速度肯定是非常慢的。&lt;/p&gt;
&lt;h2 id=&quot;解决方案使用镜像&quot;&gt;解决方案使用镜像&lt;/h2&gt;
&lt;h2 id=&quot;什么是镜像？&quot;&gt;什么是镜像？&lt;/h2&gt;
&lt;p&gt;你照镜子是时候镜子里的人就是镜像&lt;/p&gt;
&lt;p&gt;镜像就相当于是中央仓库的一个副本，内容和中央仓库完全一样，目前有不少国内镜像，其中阿里云算是比较稳定的，同时也能保证下载速度。&lt;br/&gt;其实我们可以简单的来理解什么是镜像：&lt;br/&gt;如果仓库A可以提供仓库B存储的所有内容，那么就可以认为A是B的一个镜像。换句话说，任何一个可以从仓库Y获得的构件，都胡够从它的镜像中获取。&lt;br/&gt;这里的A就是：阿里云镜像（其实还有其他的镜像OSChina），而B就是：Maven的中央仓库&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020111121151253.png#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;在maven的settingxml中配置&quot;&gt;在maven的setting.xml中配置&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;配置代码&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;&amp;lt;mirrors&amp;gt;
    &amp;lt;mirror&amp;gt;
      &amp;lt;id&amp;gt;alimaven&amp;lt;/id&amp;gt;
      &amp;lt;name&amp;gt;aliyun maven&amp;lt;/name&amp;gt;
      &amp;lt;url&amp;gt;http://maven.aliyun.com/nexus/content/groups/public/&amp;lt;/url&amp;gt;
      &amp;lt;mirrorOf&amp;gt;central&amp;lt;/mirrorOf&amp;gt;        
    &amp;lt;/mirror&amp;gt;
  &amp;lt;/mirrors&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;只需要在我们的本地maven安装位置下的conf文件夹下的setting.xml中的镜像集合中添加如上的中央仓库的镜像就可以解决maven下载依赖速度慢的问题。&lt;/p&gt;
&lt;h2 id=&quot;以上就是阿里云镜像配置的相关步骤，如有帮助还请点赞关注支持，如有疑问评论私信都可，看到后可帮助解答本博客主要侧重于数据结构于算法和java开发，操作系统，计算机网络，觉得我的文章有帮助的小伙伴可以关注我，有疑问可评论私信，相逢即是缘，大家高处见&quot;&gt;以上就是阿里云镜像配置的相关步骤，如有帮助还请点赞关注支持，如有疑问评论私信都可，看到后可帮助解答本博客主要侧重于数据结构于算法和java开发，操作系统，计算机网络，觉得我的文章有帮助的小伙伴可以关注我，有疑问可评论私信，相逢即是缘，大家高处见&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201111211944918.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BqaDg4,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 11 Nov 2020 15:34:00 +0000</pubDate>
<dc:creator>一只胡说八道的猴子</dc:creator>
<og:description>Maven配置阿里云镜像 为什么我们下载jar这么慢 maven默认会从中央仓库下载jar包，这个仓库在国外，而且全世界的人都会从这里下载，所以下载速度肯定是非常慢的。 解决方案使用镜像 什么是镜像？</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/pjhaymy/p/13961719.html</dc:identifier>
</item>
<item>
<title>Pytest学习（六） - conftest.py结合接口自动化的举例使用 - 久曲健</title>
<link>http://www.cnblogs.com/longronglang/p/13961685.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/longronglang/p/13961685.html</guid>
<description>&lt;h2 id=&quot;一、conftestpy作用&quot;&gt;一、conftest.py作用&lt;/h2&gt;
&lt;p&gt;可以理解成存放fixture的配置文件&lt;/p&gt;
&lt;h2 id=&quot;二、conftestpy配置fixture注意事项&quot;&gt;二、conftest.py配置fixture注意事项&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;pytest会默认读取conftest.py里面的所有fixture&lt;/li&gt;
&lt;li&gt;conftest.py 文件名称是固定的，不能改动&lt;/li&gt;
&lt;li&gt;conftest.py只对同一个package下的所有测试用例生效&lt;/li&gt;
&lt;li&gt;不同目录可以有自己的conftest.py，一个项目中可以有多个conftest.py&lt;/li&gt;
&lt;li&gt;测试用例文件中不需要手动import conftest.py，pytest会自动查找&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;三、实例场景应用&quot;&gt;三、实例场景应用&lt;/h2&gt;
&lt;p&gt;多个测试用例脚本都需要先进行登录，再进行业务操作，按照封装的特性，肯定需要抽离登录这部分，那么我们现在就使用conftest.py来实现。&lt;/p&gt;
&lt;p&gt;工程目录结构如下：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/718867/202011/718867-20201111232811194-143179322.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;1、最顶层conftest&quot;&gt;1、最顶层conftest&lt;/h3&gt;
&lt;p&gt;即项目根目录下的conftest文件，一般写全局的fixture，在接口自动化中抽离登录使用，示例代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# -*- coding: utf-8 -*-
# @Time    : 2020/11/11 21:26
# @Author  : longrong.lang
# @FileName: conftest.py
# @Software: PyCharm
# @Cnblogs ：https://www.cnblogs.com/longronglang
import pytest


@pytest.fixture(scope='session')
def login():
    print(u'调用登录接口')
    username=&quot;zhangsan&quot;
    token=&quot;ZXF3ZTEyMTIzMTIxYWUxcWUxYGAyYDJgYDIx&quot;
    yield username, token
    print(&quot;====登录成功，返回用户名，token！&quot;)

@pytest.fixture(autouse=True)
def get_userinfo(login):
    username, token = login
    print(f&quot;== 每个用例都调用的外层fixture：打印用户名username：{username} 和token： {token} ==&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;说明：此处必须要配合yield使用，也就是teardown（可以理解为afterclass）&lt;/p&gt;
&lt;h3 id=&quot;2、同级目录下的第一个用例&quot;&gt;2、同级目录下的第一个用例&lt;/h3&gt;
&lt;p&gt;示例代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# -*- coding: utf-8 -*-
# @Time    : 2020/11/11 21:56
# @Author  : longrong.lang
# @FileName: test_getUserInfo.py
# @Software: PyCharm
# @Cnblogs ：https://www.cnblogs.com/longronglang
def test_getUserInfo(login):
    username,token=login
    print(f&quot;== 每个用例都调用的外层fixture：打印用户名\nusername：{username} 和token： {token} ==&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/718867/202011/718867-20201111221340982-957445731.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;3、test_query目录&quot;&gt;3、test_query目录&lt;/h3&gt;
&lt;p&gt;通过conftest.py，配置一些针对query的测试用例独有的fixture，比如：查询商品，示例代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# -*- coding: utf-8 -*-
# @Time    : 2020/11/11 22:19
# @Author  : longrong.lang
# @FileName: conftest.py.py
# @Software: PyCharm
# @Cnblogs ：https://www.cnblogs.com/longronglang
import pytest


@pytest.fixture(scope='module')
def query(login):
    print(&quot;====调用查询接口&quot;)
    shopName=&quot;AJ男鞋&quot;
    size=44
    colour=&quot;红色&quot;
    yield shopName, size,colour
    print(f&quot;调用查询接口成功，返回查询商品信息&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对应测试用例，示例代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# -*- coding: utf-8 -*-
# @Time    : 2020/11/11 22:27
# @Author  : longrong.lang
# @FileName: test_case1.py
# @Software: PyCharm
# @Cnblogs ：https://www.cnblogs.com/longronglang
def test_query_shop(query):
    shopName,size,colour=query
    print(f&quot;\n返回查询商品信息：商品名称： {shopName} 颜色：{colour} 鞋号： {size}&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/718867/202011/718867-20201111223544140-1685937849.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;4、test_loginout目录&quot;&gt;4、test_loginout目录&lt;/h3&gt;
&lt;p&gt;没有__init__.py文件也没有conftest.py文件，对应测试用例，示例代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# -*- coding: utf-8 -*-
# @Time    : 2020/11/11 22:40
# @Author  : longrong.lang
# @FileName: test_nofixture.py
# @Software: PyCharm
# @Cnblogs ：https://www.cnblogs.com/longronglang
def test_no_fixture(login):
    print(&quot;==\n没有__init__测试用例，登录后，我就想退出登录了==&quot;, login)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/718867/202011/718867-20201111224501595-1896583989.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;5、test_addcart目录&quot;&gt;5、test_addcart目录&lt;/h3&gt;
&lt;p&gt;通过conftest.py，配置一些针对addcart的测试用例独有的fixture，比如：加入购物车，示例代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# -*- coding: utf-8 -*-
# @Time    : 2020/11/11 22:50
# @Author  : longrong.lang
# @FileName: conftest.py
# @Software: PyCharm
# @Cnblogs ：https://www.cnblogs.com/longronglang
import pytest


@pytest.fixture(scope='function')
def addcart(login):
    print(&quot;从详情页登录，将商品加入购物车&quot;)
    price=&quot;2099元&quot;
    yield price
    print('添加购物车成功，累计计算中')
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对应测试用例，示例代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# -*- coding: utf-8 -*-
# @Time    : 2020/11/11 22:56
# @Author  : longrong.lang
# @FileName: test_case.py
# @Software: PyCharm
# @Cnblogs ：https://www.cnblogs.com/longronglang
def test_addCart(addcart):
    price=addcart
    print(f&quot;\n返回商品价格： {price} &quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/718867/202011/718867-20201111230509761-15350122.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;四、运行目录下所有用例&quot;&gt;四、运行目录下所有用例&lt;/h2&gt;
&lt;p&gt;示例代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# -*- coding: utf-8 -*-
# @Time    : 2020/11/11 23:17
# @Author  : longrong.lang
# @FileName: run.py
# @Software: PyCharm
# @Cnblogs ：https://www.cnblogs.com/longronglang
import pytest

if __name__ == '__main__':
    pytest.main([&quot;-q&quot;, &quot;../python-practice/&quot;])

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/718867/202011/718867-20201111232312085-1163843652.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 11 Nov 2020 15:31:00 +0000</pubDate>
<dc:creator>久曲健</dc:creator>
<og:description>一、conftest.py作用 可以理解成存放fixture的配置文件 二、conftest.py配置fixture注意事项 pytest会默认读取conftest.py里面的所有fixture co</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/longronglang/p/13961685.html</dc:identifier>
</item>
<item>
<title>最全总结 | 聊聊 Python 办公自动化之 Excel（下） - AirPython</title>
<link>http://www.cnblogs.com/xingag/p/13961636.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xingag/p/13961636.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1466987-53b1eeac548ed01b?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-前言&quot;&gt;1. 前言&lt;/h2&gt;
&lt;p&gt;前面谈到 Python 处理 Excel 文件最常见的两种方式，即：xlrd/xlwt、openpyxl&lt;/p&gt;
&lt;p&gt;​其中，&lt;/p&gt;
&lt;p&gt;xlrd/xlwt 这一组合，xlrd 可以负责读取数据，而 xlwt 则负责写入数据，缺点是不支持 xlsx&lt;/p&gt;
&lt;p&gt;openpyxl 同时支持对 Excel 文档的读取、写入操作，缺点是不支持 xls&lt;/p&gt;
&lt;p&gt;本篇文章将继续聊聊 Python 操作 Excel 文档的其他几种方式&lt;/p&gt;
&lt;h2 id=&quot;2-xlsxwriter&quot;&gt;2. xlsxwriter&lt;/h2&gt;
&lt;p&gt;xlsxwriter 主要用于将数据、图表写入到 Excel 文件中，可以配置使用较小的内存快速写入数据&lt;/p&gt;
&lt;p&gt;它的缺点是：无法读取、修改已有的 Excel 文件；如果需要读取修改 Excel 文件，只能搭配其他依赖库使用，比如：xlrd&lt;/p&gt;
&lt;p&gt;首先安装 xlsxwriter 的依赖包&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 安装依赖包
pip3 install xlsxwriter
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;xlsxwriter 提供了 Workbook(filename) 方法，用于创建一个工作簿对象&lt;/p&gt;
&lt;p&gt;使用工作簿对象的 add_worksheet(sheet_name) 函数，就可以在工作簿中创建 Sheet 了&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def create_workbook_and_worksheet(filename, worksheet_names):
    &quot;&quot;&quot;
    创建工作簿和Sheet
    :param filename: 文件名称
    :param worksheet_names: sheet名称列表
    :return:
    &quot;&quot;&quot;
    wb = xlsxwriter.Workbook(filename)

    sheets = []

    # 新增sheet
    for worksheet_name in worksheet_names:
        sheets.append(wb.add_worksheet(worksheet_name))

    return wb, sheets
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着，就可以往某个 Sheet 单元格中写入数据了&lt;/p&gt;
&lt;p&gt;如果需要定制单元格的样式，比如：字体大小、字体、颜色、背景、是否加粗等，可以使用工作簿对象的 add_format() 方法创建一个样式&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def create_format_styles(wb, format_stuyles):
    &quot;&quot;&quot;
    创建一个样式，包含：字体大小、字体、颜色、背景、是否加粗等
    :param wb:
    :param format_stuyles:
    :return:
    &quot;&quot;&quot;
    return wb.add_format(format_stuyles)

# 单元格字体样式
self.title_style = {'bold': True, 'bg_color': '#B0C4DE', 'font_size': 10,'font_name': 'Microsoft yahei'}

# 创建标题字体样式
title_font_style = create_format_styles(self.wb, self.title_style)

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Sheet 对象的 write(...) 函数用于向单元格中写入数据，参数包含：行索引、列索引、值、字体样式等&lt;/p&gt;
&lt;p&gt;需要注意的是，默认 xlsxwriter 的行索引、列索引都是从 0 开始，即： 0 代表第一行&lt;/p&gt;
&lt;p&gt;写入数据的同时配置单元格样式的写法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def write_to_cell(sheet, row_index, column_index, value, format_styles=None):
    &quot;&quot;&quot;
    往单元格中写入数据
    :param row_index: 行索引，1：第一行
    :param column_index: 列索引，1：第一列
    :param format_styles 字体样式
    :return:
    &quot;&quot;&quot;
    if row_index &amp;lt; 1 or column_index &amp;lt; 1:
        print('参数输入不正确，写入失败！')
    else:
        # 注意：默认xlsxwriter的行索引、列索引从0开始
        sheet.write(row_index - 1, column_index - 1, value, format_styles)

# 往worksheet中写入数据
# 第一行
write_to_cell(self.current_sheet, 1, 1, &quot;姓名&quot;, title_font_style)
write_to_cell(self.current_sheet, 1, 2, &quot;年龄&quot;, title_font_style)
# 第二行
write_to_cell(self.current_sheet, 2, 1, 'xingag')
write_to_cell(self.current_sheet, 2, 2, 23)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;xlsxwriter 同样支持在单元格中插入图片，包含：本地图片和网络图片&lt;/p&gt;
&lt;p&gt;使用的方法是：insert_image()&lt;/p&gt;
&lt;p&gt;参数包含：单元格行索引（索引从 0 开始）、单元格列索引、图片文件、可选参数（图片位置、缩放、url 超链接、image_data 图片字节流等）&lt;/p&gt;
&lt;p&gt;以插入一张网络图片为例&lt;/p&gt;
&lt;p&gt;首先，定义一个图片展示可选参数，指定图片的缩放比、url 超链接&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def create_image_options(x_offset=0, y_offset=0, x_scale=1, y_scale=1, url=None, tip=None, image_data=None,
                         positioning=None):
    &quot;&quot;&quot;
    插入图片的参数配置
    包含：偏移量、缩放比、网络图片链接、超链接、悬停提示灯
    :param x_offset:
    :param y_offset:
    :param x_scale:
    :param y_scale:
    :param url:
    :param tip:
    :param image_data:
    :param positioning:
    :return:
    &quot;&quot;&quot;
    image_options = {
        'x_offset': x_offset,
        'y_offset': y_offset,
        'x_scale': x_scale,
        'y_scale': y_scale,
        'url': url,
        'tip': tip,
        'image_data': image_data,
        'positioning': positioning,
    }
    return image_options

image_options = create_image_options(x_scale=0.5, y_scale=0.5, url='https://www.jianshu.com/u/f3b476549169')
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着，将网络图片转为字节流&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from io import BytesIO
import ssl

def get_image_data_from_network(url):
    &quot;&quot;&quot;
    获取网络图片字节流
    :param url: 图片地址
    :return:
    &quot;&quot;&quot;
    ssl._create_default_https_context = ssl._create_unverified_context
    # 获取网络图片的字节流
    image_data = BytesIO(urlopen(url).read())
    return image_data
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后，将图片插入到单元格中&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def insert_network_image(sheet, row_index, column_index, url, filepath, image_options=None):
    &quot;&quot;&quot;
    插入网络图片
    :param sheet:
    :param row_index:
    :param column_index:
    :param url:
    :param filepath:
    :param image_options:
    :return:
    &quot;&quot;&quot;
    if row_index &amp;lt; 1 or column_index &amp;lt; 1:
        return &quot;参数输入有误，插入失败！&quot;

    # 获取图片字节流
    image_data = get_image_data_from_network(url)

    if image_options:
        image_options['image_data'] = image_data
    print(image_options)

    sheet.insert_image(row_index - 1, column_index - 1, filepath, image_options)

insert_network_image(self.current_sheet, 1, 1, url, '1.png', image_options4)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用 set_column() 方法可以设置列宽&lt;/p&gt;
&lt;p&gt;和 openpyxl 类似，有 2 种使用方式，分别是：字符串索引、列索引数字索引&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def set_column_width(sheet, index_start, index_end, width):
    &quot;&quot;&quot;
    设置列宽
    :param sheet:
    :param index_start: 开始位置，从1开始
    :param index_end: 结束位置
    :param width: 宽度
    :return:
    &quot;&quot;&quot;
    # 方式二选一
    # self.current_sheet.set_column('A:C', width)

    # 默认0代表第一列
    sheet.set_column(index_start - 1, index_end - 1, width)

# 设置列宽度
# 设置第1列到第3列的宽度为：100
set_column_width(self.current_sheet, 1, 3, 100)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;行高使用 set_row() 方法，传入行索引和高度即可&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def set_row_height(sheet, row_index, height):
    &quot;&quot;&quot;
    设置行高
    :param sheet:
    :param row_index: 行索引，从1开始
    :param height:
    :return:
    &quot;&quot;&quot;
    sheet.set_row(row_index - 1, height)

# 设置行高
set_row_height(self.current_sheet, 1, 50)
set_row_height(self.current_sheet, 2, 100)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;写入数据完毕之后，将工作簿关闭，文件会自动保存到本地&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def teardown(self):
    # 写入文件，并关闭文件
    self.wb.close()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;xlsxwriter 还支持插入图表，比如：条形图、柱状图、雷达图等，受限于篇幅，这部分内容就不展开说明了&lt;/p&gt;
&lt;h2 id=&quot;3-其他方式&quot;&gt;3. 其他方式&lt;/h2&gt;
&lt;p&gt;还有一种比较常见的方式是：xlwings&lt;/p&gt;
&lt;p&gt;xlwings 是一款开源免费的依赖库，同时支持 Excel 文件的读取、写入、修改&lt;/p&gt;
&lt;p&gt;它功能非常强大，还可以和 Matplotlib、Numpy 和 Pandas 无缝连接，支持读写 Numpy、Pandas 数据类型；同时，xlwings 可以直接调用 Excel 文件中 VBA 程序&lt;/p&gt;
&lt;p&gt;需要注意的是，xlwings 依赖于 Microsoft Excel 软件，所以使用 WPS 的用户建议直接使用 openpyxl&lt;/p&gt;
&lt;p&gt;官方文档：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.xlwings.org/zh_CN/latest/quickstart.html&quot;&gt;https://docs.xlwings.org/zh_CN/latest/quickstart.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;另外，还有一个操作 Excel 比较强大的方式，即：Pywin32&lt;/p&gt;
&lt;p&gt;其中，&lt;/p&gt;
&lt;p&gt;Pywin32 相当于调用 Win 下的系统 API 来操作 Excel 文件&lt;/p&gt;
&lt;p&gt;优点是：可以处理复杂图表的数据表&lt;/p&gt;
&lt;p&gt;缺点也非常明显，包含：速度慢、占用 CPU 高，仅支持 Win 系统&lt;/p&gt;
&lt;h2 id=&quot;4-最后&quot;&gt;4. 最后&lt;/h2&gt;
&lt;p&gt;综合发现，xlrd/xlwt、openpyxl、xlsxwriter 基本上可以满足大部分的日常 Excel 文档操作&lt;/p&gt;
&lt;p&gt;要获取全部源码，关注公众号「 &lt;strong&gt;AirPython&lt;/strong&gt; 」，后台回复「 &lt;strong&gt;excel&lt;/strong&gt; 」即可获得全部源码&lt;/p&gt;
&lt;p&gt;如果你觉得文章还不错，请大家 &lt;strong&gt;点赞、分享、留言&lt;/strong&gt;下，因为这将是我持续输出更多优质文章的最强动力！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;推荐阅读&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1OTI0NjI1NQ==&amp;amp;mid=2247486752&amp;amp;idx=1&amp;amp;sn=bc58a3127bad72f2210817c3b4087801&amp;amp;chksm=fc1b73e0cb6cfaf6b1dbe8943d13a805d384ae74f043720a1d048c498405cc1ada93437f58ce&amp;amp;scene=21#wechat_redirect&quot;&gt;最全总结 | 聊聊 Python 办公自动化之 Excel（上）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1OTI0NjI1NQ==&amp;amp;mid=2247486789&amp;amp;idx=1&amp;amp;sn=e565569c17815a897ab6089f9c305d90&amp;amp;chksm=fc1b7385cb6cfa93c17632269677f60439e1738b23c7522eb75a5e8dedc61a5c44e0c681c447&amp;amp;scene=21#wechat_redirect&quot;&gt;最全总结 | 聊聊 Python 办公自动化之 Excel（中）&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 11 Nov 2020 15:13:00 +0000</pubDate>
<dc:creator>AirPython</dc:creator>
<og:description>1. 前言 前面谈到 Python 处理 Excel 文件最常见的两种方式，即：xlrd/xlwt、openpyxl ​其中， xlrd/xlwt 这一组合，xlrd 可以负责读取数据，而 xlwt</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xingag/p/13961636.html</dc:identifier>
</item>
<item>
<title>利用远程桌面管理winserver集群 - 柿沼</title>
<link>http://www.cnblogs.com/kakinuma/p/13961529.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kakinuma/p/13961529.html</guid>
<description>&lt;p&gt;在适用mstsc连接winserver服务器的场景下（别问为什么不VNC），可以利用rdp文件等方式减轻连接的操作负担&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;利用.rdp文件免密登录&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;rdp文件本质上是一个mstsc的选择，或者不如说mstsc的手动连接窗口是一个由系统管理的rdp文件。&lt;/p&gt;
&lt;p&gt;&amp;gt; mstsc --help&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/837926/202011/837926-20201111215307933-715197092.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在mstsc命令中可以利用已有的rdp文件（中的已有信息）来补全当次的远程连接，最简单的rdp文件包含地址、用户名、密码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;address:s:远程桌面地址
username:s:用户名
password &lt;/span&gt;&lt;span&gt;51&lt;/span&gt;:b:加密后的密码
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如只提供部分信息，如不包含地址，在指令中补全即可&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
mstsc D:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;file.rdp -v:10.10.2.128&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;rdp文件麻烦的地方在于password是经过一次加密的，加密方法在crypt32.lib，WinCrypt.h是有的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;BOOL WINAPI CryptProtectData (
DATA_BLOB &lt;/span&gt;*&lt;span&gt; pDataIn ,
LPCWSTR szDataDescr ,
DATA_BLOB &lt;/span&gt;*&lt;span&gt; pOptionalEntropy ,
PVOID pvReserved ,
CRYPTPROTECT_PROMPTSTRUCT &lt;/span&gt;*&lt;span&gt; pPromptStruct ,
DWORD dwFlags ,
DATA_BLOB &lt;/span&gt;*&lt;span&gt; pDataOut
) ;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;直接使用rdp加密工具即可，百度一大堆，应该也都是封了CryptProtectData的工具&lt;/p&gt;
&lt;p&gt;如果有特殊场景不能使用不明exe，或者场景复杂需要批量操作，可以自己C++实现 ，有一些宽字符之类的细节，使用可以参考（一个10年前的文章）&lt;/p&gt;
&lt;p&gt;https://www.codeproject.com/Articles/59882/Decrypt-Remote-Desktop-Mobile-password&lt;/p&gt;
&lt;p&gt;懒得看英文说明直接照抄转了八百手的博客也行↓这已经不知道是第几百手了&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/wzsy/article/details/14120853&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main ( )
{
    DATA_BLOB DataIn ;
    DATA_BLOB DataOut ;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; mstsc.exe中使用的是unicode,所以必须做宽字符转换&lt;/span&gt;
    BYTE * pbDataInput = ( BYTE * ) L &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;freedom&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ;
    DWORD cbDataInput &lt;/span&gt;= wcslen ( L &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;freedom&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ) * &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(wchar_t ) ;
    DataIn . pbData &lt;/span&gt;=&lt;span&gt; pbDataInput ;
    DataIn . cbData &lt;/span&gt;=&lt;span&gt; cbDataInput ;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( CryptProtectData ( &amp;amp;DataIn, L&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;password&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, NULL, NULL, NULL, &lt;span&gt;0&lt;/span&gt;, &amp;amp;&lt;span&gt;DataOut ) )
    {
        printf ( &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;The encryption phase worked.\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ) ;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; count = &lt;span&gt;0&lt;/span&gt;&lt;span&gt; ;
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; ( count &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 因为一个unsigned int 占32位
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 转换成成16进制要占两位
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 所以这里需要用%02&lt;/span&gt;
        printf ( &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%02X&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; , DataOut . pbData [ count ] ) ;
        count &lt;/span&gt;++&lt;span&gt; ;
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    {
        printf ( &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Encryption error using CryptProtectData.\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ) ;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; - &lt;span&gt;1&lt;/span&gt;&lt;span&gt; ;
    }
}
                            &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;进一步减少操作：忽略证书和链接身份确认&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;使用rdp打开远程连接需要进行两次确认，证书的跳过方法参照&lt;/p&gt;
&lt;p&gt;https://stackoverflow.com/questions/20686361/how-to-ignore-the-certificate-warning-on-remote-desktop-connection&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;reg add &quot;HKEY_CURRENT_USER\Software\Microsoft\Terminal Server Client&quot; /v &quot;AuthenticationLevelOverride&quot; /t &quot;REG_DWORD&quot; /d 0 /f&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;rdp的签名则可以参照&lt;/p&gt;
&lt;p&gt;https://vircloud.net/operations/rdpsign.html&lt;/p&gt;
&lt;p&gt;或者也直接上注册表，参照&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/weixin_41111659/article/details/893722537&lt;/p&gt;
&lt;p&gt;创建一个test.reg&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Windows Registry Editor Version &lt;span&gt;5.00&lt;/span&gt;&lt;span&gt;
[HKEY_CURRENT_USER\Software\Microsoft\Terminal Server Client\LocalDevices]
&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;=dword:0000004c
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或者直接使用cmd&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
reg add &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;HKEY_CURRENT_USER\Software\Microsoft\Terminal Server Client\LocalDevices&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /v &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /t &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;REG_DWORD&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /d &lt;span&gt;76&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;根据适用场景的封装&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在我这个环境下，很多server属于同一个网段，且用户密码都一样，所以不用为每一个server创建一个rdp，只创建一个含用户密码的rdp文件即可：ys.rdp&lt;/p&gt;
&lt;p&gt;然后稍微包一个bat脚本&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;set input&lt;/span&gt;=%&lt;span&gt;1&lt;/span&gt;%
&lt;span&gt;echo&lt;/span&gt; %input% ^ ^&lt;span&gt;
@start reg add &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;HKEY_CURRENT_USER\Software\Microsoft\Terminal Server Client\LocalDevices&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /v &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;127.0.0.%input%&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /t &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;REG_DWORD&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /d &lt;span&gt;76&lt;/span&gt;&lt;span&gt;
@start mstsc F:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ys.bat -v:127.0.0.%input%&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;需要的时候直接可以连接127.0.0.125&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&amp;gt;ys.bat &lt;span&gt;125&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果server情况比较复杂，根据密码表批量创建对应的rdp，直接双击使用也可以，至于生成密钥要不要封之类的细节就看个人需求了&lt;/p&gt;

</description>
<pubDate>Wed, 11 Nov 2020 14:55:00 +0000</pubDate>
<dc:creator>柿沼</dc:creator>
<og:description>在适用mstsc连接winserver服务器的场景下（别问为什么不VNC），可以利用rdp文件等方式减轻连接的操作负担 利用.rdp文件免密登录 rdp文件本质上是一个mstsc的选择，或者不如说ms</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kakinuma/p/13961529.html</dc:identifier>
</item>
</channel>
</rss>