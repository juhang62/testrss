<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>CountDownLatch和CyclicBarrier 傻傻的分不清？超长精美图文又来了 - 日拱一兵</title>
<link>http://www.cnblogs.com/FraserYu/p/13217283.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/FraserYu/p/13217283.html</guid>
<description>&lt;blockquote&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;你有一个思想，我有一个思想，我们交换后，一个人就有两个思想&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;If you can NOT explain it simply, you do NOT understand it well enough&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;现陆续将Demo代码和技术文章整理在一起 &lt;a href=&quot;https://github.com/FraserYu/learnings&quot;&gt;Github实践精选&lt;/a&gt; ，方便大家阅读查看，本文同样收录在此，觉得不错，还请Star&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202007/1583165-20200701083743714-1614749688.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;并发编程的三大核心是&lt;code&gt;分工&lt;/code&gt;，&lt;code&gt;同步&lt;/code&gt;和&lt;code&gt;互斥&lt;/code&gt;。在日常开发中，经常会碰到需要在主线程中开启多个子线程去并行的执行任务，并且主线程需要等待所有子线程执行完毕再进行汇总的场景，这就涉及到分工与同步的内容了&lt;/p&gt;
&lt;p&gt;在讲 &lt;a href=&quot;https://dayarch.top/p/java-concurrency-happens-before-rule.html#join-%E8%A7%84%E5%88%99&quot;&gt;有序性可见性，Happens-before来搞定&lt;/a&gt; 时，提到过 join() 规则，使用 join() 就可以简单的实现上述场景：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Slf4j
public class JoinExample {

        public static void main(String[] args) throws InterruptedException {
                Thread thread1 = new Thread(() -&amp;gt; {
                        try {
                                Thread.sleep(1000);
                        } catch (InterruptedException e) {
                                e.printStackTrace();
                        } finally {
                                log.info(&quot;Thread-1 执行完毕&quot;);
                        }
                }, &quot;Thread-1&quot;);

                Thread thread2 = new Thread(() -&amp;gt; {
                        try {
                                Thread.sleep(1000);
                        } catch (InterruptedException e) {
                                e.printStackTrace();
                        } finally {
                                log.info(&quot;Thread-2 执行完毕&quot;);
                        }
                }, &quot;Thread-2&quot;);

                thread1.start();
                thread2.start();

                thread1.join();
                thread2.join();

                log.info(&quot;主线程执行完毕&quot;);
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202007/1583165-20200701083743951-211048549.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;整个过程可以这么理解&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202007/1583165-20200701083744798-605987946.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们来查看 join() 的实现源码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202007/1583165-20200701083745198-725246509.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其实现原理是不停的检查 join 线程是否存活，如果 join 线程存活，则 wait(0) 永远的等下去，直至 join 线程终止后，线程的 this.notifyAll() 方法会被调用（该方法是在 JVM 中实现的，JDK 中并不会看到源码），退出循环恢复主线程执行。很显然这种循环检查的方式比较低效&lt;/p&gt;
&lt;p&gt;除此之外，使用 join() 缺少很多灵活性，比如实际项目中很少让自己单独创建线程（原因在 &lt;a href=&quot;https://dayarch.top/p/why-we-need-to-use-threadpool.html&quot;&gt;我会手动创建线程，为什么要使用线程池?&lt;/a&gt; 中说过）而是使用 Executor, 这进一步减少了 join() 的使用场景，所以 join() 的使用在多数是停留在 demo 演示上&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;那如何实现文中开头提到的场景呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;countdownlatch&quot;&gt;CountDownLatch&lt;/h2&gt;
&lt;p&gt;CountDownLatch, 直译过来【数量向下门闩】，那肯定里面有计数器的存在了。我们将上述程序用 CountDownLatch 实现一下，先让大家有个直观印象&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Slf4j
public class CountDownLatchExample {

        private static CountDownLatch countDownLatch = new CountDownLatch(2);

        public static void main(String[] args) throws InterruptedException {
                // 这里不推荐这样创建线程池，最好通过 ThreadPoolExecutor 手动创建线程池
                ExecutorService executorService = Executors.newFixedThreadPool(2);

                executorService.submit(() -&amp;gt; {
                        try {
                                Thread.sleep(1000);
                        } catch (InterruptedException e) {
                                e.printStackTrace();
                        } finally {
                                log.info(&quot;Thread-1 执行完毕&quot;);
                                //计数器减1
                                countDownLatch.countDown();
                        }
                });

                executorService.submit(() -&amp;gt; {
                        try {
                                Thread.sleep(1000);
                        } catch (InterruptedException e) {
                                e.printStackTrace();
                        } finally {
                                log.info(&quot;Thread-2 执行完毕&quot;);
                                //计数器减1
                                countDownLatch.countDown();
                        }
                });

                log.info(&quot;主线程等待子线程执行完毕&quot;);
                log.info(&quot;计数器值为：&quot; + countDownLatch.getCount());
                countDownLatch.await();
                log.info(&quot;计数器值为：&quot; + countDownLatch.getCount());
                log.info(&quot;主线程执行完毕&quot;);
                executorService.shutdown();
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202007/1583165-20200701083745479-2007230018.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;结合上述示例的运行结果，相信你也能猜出 CountDownLatch 的实现原理了：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;初始化计数器数值，比如为2&lt;/li&gt;
&lt;li&gt;子线程执行完则调用 &lt;code&gt;countDownLatch.countDown()&lt;/code&gt; 方法将计数器数值减1&lt;/li&gt;
&lt;li&gt;主线程调用 await() 方法阻塞自己，直至计数器数值为0（即子线程全部执行结束）&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;不知道你是否注意，&lt;code&gt;countDownLatch.countDown();&lt;/code&gt; 这行代码可以写在子线程执行的任意位置，不像 join() 要完全等待子线程执行完，这也是 CountDownLatch 灵活性的一种体现&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上述的例子还是过于简单，&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CountDownLatch.html&quot;&gt;Oracle 官网 CountDownLatch 说明&lt;/a&gt; 有两个非常经典的使用场景，示例很简单，强烈建议查看相关示例代码，打开使用思路。我将两个示例代码以图片的形式展示在此处：&lt;/p&gt;
&lt;h3 id=&quot;官网示例1&quot;&gt;官网示例1&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;第一个是开始信号 &lt;code&gt;startSignal&lt;/code&gt;，阻止任何工人 &lt;code&gt;Worker&lt;/code&gt; 继续工作，直到司机 &lt;code&gt;Driver&lt;/code&gt; 准备好让他们继续工作&lt;/li&gt;
&lt;li&gt;第二个是完成信号 &lt;code&gt;doneSignal&lt;/code&gt;，允许司机 &lt;code&gt;Driver&lt;/code&gt; 等待，直到所有的工人 &lt;code&gt;Worker&lt;/code&gt; 完成。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202007/1583165-20200701083745928-814311711.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;官网示例2&quot;&gt;官网示例2&lt;/h3&gt;
&lt;p&gt;另一种典型的用法是将一个问题分成 N 个部分 （比如将一个大的 list 拆分成多分，每个 Worker 干一部分），Worker 执行完自己所处理的部分后，计数器减1，当所有子部分完成后，Driver 才继续向下执行&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202007/1583165-20200701083746633-1524866131.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;结合官网示例，相信你已经可以结合你自己的业务场景解，通过 CountDownLatch 解决一些串行瓶颈来提高运行效率了，会用还远远不够，咱得知道 CountDownLatch 的实现原理&lt;/p&gt;
&lt;h3 id=&quot;源码分析&quot;&gt;源码分析&lt;/h3&gt;
&lt;p&gt;CountDownLatch 是 AQS 实现中的最后一个内容，有了前序文章的知识铺垫：&lt;/p&gt;
&lt;p&gt;当你看到 CountDownLatch 的源码内容，你会高兴的笑起来，内容真是太少了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202007/1583165-20200701083747106-69642271.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;展开类结构全部内容就这点东西&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202007/1583165-20200701083747466-1174435905.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;既然 CountDownLatch 是基于 AQS 实现的，那肯定也离不开对同步状态变量 state 的操作，我们在初始化的时候就将计数器的值赋值给了state&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202007/1583165-20200701083747756-1385463727.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外，它可以多个线程同时获取，那一定是基于共享式获取同步变量的用法了，所以它需要通过重写下面两个方法控制同步状态变量 state ：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;tryAcquireShared()&lt;/li&gt;
&lt;li&gt;tryReleaseShared()&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;CountDownLatch 暴露给使用者的只有 &lt;code&gt;await()&lt;/code&gt; 和 &lt;code&gt;countDown()&lt;/code&gt; 两个方法，前者是阻塞自己，因为只有获取同步状态才会才会出现阻塞的情况，那自然是在 &lt;code&gt;await()&lt;/code&gt; 的方法内部会用到 &lt;code&gt;tryAcquireShared()&lt;/code&gt;；有获取就要有释放，那后者 &lt;code&gt;countDown()&lt;/code&gt; 方法内部自然是要用到 &lt;code&gt;tryReleaseShared()&lt;/code&gt; 方法了&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;PS：如果你对上面这个很自然的推断理解有困难，强烈建议你看一下前序文章的铺垫，以防止知识断层带来的困扰&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;&quot;/&gt;
&lt;h4 id=&quot;await&quot;&gt;await()&lt;/h4&gt;
&lt;p&gt;先来看 await() 方法, 从方法签名上看，该方法会抛出 InterruptedException, 所以它是可以响应中断的，这个我们在 &lt;a href=&quot;https://dayarch.top/p/java-concurrency-interrupt-mechnism.html&quot;&gt;Java多线程中断机制&lt;/a&gt; 中明确说明过&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void await() throws InterruptedException {
    sync.acquireSharedInterruptibly(1);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其内部调用了同步器提供的模版方法 &lt;code&gt;acquireSharedInterruptibly&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public final void acquireSharedInterruptibly(int arg)
        throws InterruptedException {
        // 如果监测到中断标识为true,会重置标识，然后抛出 InterruptedException
    if (Thread.interrupted())
        throw new InterruptedException();
        // 调用重写的 tryAcquireShared 方法，该方法结果如果大于零则直接返回，程序继续向下执行，如果小于零，则会阻塞自己
    if (tryAcquireShared(arg) &amp;lt; 0)
        // state不等于0，则尝试阻塞自己
        doAcquireSharedInterruptibly(arg);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重写的 &lt;code&gt;tryAcquireShared&lt;/code&gt; 方法非常简单, 就是判断同步状态变量 state 的值是否为 0， 如果为零 （子线程已经全部执行完毕）则返回1， 否则返回 -1&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;protected int tryAcquireShared(int acquires) {
    return (getState() == 0) ? 1 : -1;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果子线程没有全部执行完毕，则会通过 &lt;code&gt;doAcquireSharedInterruptibly&lt;/code&gt; 方法阻塞自己，这个方法在 &lt;a href=&quot;https://dayarch.top/p/java-aqs-acquireshared-and-semaphore.html&quot;&gt;Java AQS共享式获取同步状态及Semaphore的应用分析&lt;/a&gt; 中已经仔细分析过了，这里就不再赘述了&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private void doAcquireSharedInterruptibly(int arg)
    throws InterruptedException {
    final Node node = addWaiter(Node.SHARED);
    boolean failed = true;
    try {
        for (;;) {
            final Node p = node.predecessor();
            if (p == head) {
                // 再次尝试获取同步装阿嚏，如果大于0，说明子线程全部执行完毕，直接返回
                int r = tryAcquireShared(arg);
                if (r &amp;gt;= 0) {
                    setHeadAndPropagate(node, r);
                    p.next = null; // help GC
                    failed = false;
                    return;
                }
            }
                // 阻塞自己
            if (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;
                parkAndCheckInterrupt())
                throw new InterruptedException();
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;await()&lt;/code&gt; 方法的实现就是这么简单，接下来看看 &lt;code&gt;countDown()&lt;/code&gt; 的实现原理&lt;/p&gt;
&lt;h4 id=&quot;countdown&quot;&gt;countDown()&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void countDown() {
    sync.releaseShared(1);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同样是调用同步器提供的模版方法 &lt;code&gt;releaseShared&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public final boolean releaseShared(int arg) {
        // 调用自己重写的同步器方法
    if (tryReleaseShared(arg)) {
        // 唤醒调用 await() 被阻塞的线程
        doReleaseShared();
        return true;
    }
    return false;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重写的 &lt;code&gt;tryReleaseShared&lt;/code&gt; 同样很简单&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;protected boolean tryReleaseShared(int releases) {
    // Decrement count; signal when transition to zero
    for (;;) {
        int c = getState();
        // 如果当前状态值为0，则直接返回 （1）
        if (c == 0)
            return false;
        // 使用 CAS 让计数器的值减1 （2）
        int nextc = c-1;
        if (compareAndSetState(c, nextc))
            return nextc == 0;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码 （1） 判断当前同步状态值，如果为0 则直接返回 false；否则执行代码 （2），使用 CAS 将计数器减1，如果 CAS 失败，则循环重试，最终返回 &lt;code&gt;nextc == 0&lt;/code&gt; 的结果值，如果该值返回 true，说明最后一个线程已调用 countDown() 方法，然后就要唤醒调用 await() 方法被阻塞的线程，同样由于分析过 AQS 的模版方法 doReleaseShared 整个释放同步状态以及唤醒的过程，所以这里同样不再赘述了&lt;/p&gt;
&lt;p&gt;仔细看CountDownLatch重写的 &lt;code&gt;tryReleaseShared&lt;/code&gt; 方法，有一点需要和大家说明：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;代码 （1） &lt;code&gt;if (c == 0)&lt;/code&gt; 看似没什么用处，其实用处大大滴，如果没有这个判断，当计数器值已经为零了，其他线程再调用 countDown 方法会将计数器值变为负值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;现在就差 &lt;code&gt;await(long timeout, TimeUnit unit)&lt;/code&gt; 方法没介绍了&lt;/p&gt;
&lt;h4 id=&quot;awaitlong-timeout-timeunit-unit&quot;&gt;await(long timeout, TimeUnit unit)&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public boolean await(long timeout, TimeUnit unit)
    throws InterruptedException {
    return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout));
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该方法签名同样抛出 InterruptedException，意思可响应中断。它其实就是 await() 更完善的一个版本，简单来说就是&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;主线程设定等待超时时间，如果该时间内子线程没有执行完毕，主线程也会&lt;strong&gt;直接返回&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们将上面的例子稍稍修改一下你就会明白(主线程超时时间设置为 2 秒，而子线程要 sleep 5 秒)&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Slf4j
public class CountDownLatchTimeoutExample {

   private static CountDownLatch countDownLatch = new CountDownLatch(2);

   public static void main(String[] args) throws InterruptedException {
      // 这里不推荐这样创建线程池，最好通过 ThreadPoolExecutor 手动创建线程池
      ExecutorService executorService = Executors.newFixedThreadPool(2);

      executorService.submit(() -&amp;gt; {
         try {
            Thread.sleep(5000);
         } catch (InterruptedException e) {
            e.printStackTrace();
         } finally {
            log.info(&quot;Thread-1 执行完毕&quot;);
            //计数器减1
            countDownLatch.countDown();
         }
      });

      executorService.submit(() -&amp;gt; {
         try {
            Thread.sleep(5000);
         } catch (InterruptedException e) {
            e.printStackTrace();
         } finally {
            log.info(&quot;Thread-2 执行完毕&quot;);
            //计数器减1
            countDownLatch.countDown();
         }
      });

      log.info(&quot;主线程等待子线程执行完毕&quot;);
      log.info(&quot;计数器值为：&quot; + countDownLatch.getCount());
      countDownLatch.await(2, TimeUnit.SECONDS);
      log.info(&quot;计数器值为：&quot; + countDownLatch.getCount());
      log.info(&quot;主线程执行完毕&quot;);
      executorService.shutdown();
   }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202007/1583165-20200701083748025-473488961.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;形象化的展示上述示例的运行过程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202007/1583165-20200701083748451-1886349863.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;小结&quot;&gt;小结&lt;/h3&gt;
&lt;p&gt;CountDownLatch 的实现原理就是这么简单，了解了整个实现过程后，你也许发现了使用 CountDownLatch 的一个问题：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;计数器减 1 操作是&lt;strong&gt;一次性&lt;/strong&gt;的，也就是说当计数器减到 0， 再有线程调用 await() 方法，该线程会直接通过，&lt;strong&gt;不会再起到等待其他线程执行结果起到同步的作用了&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为了解决这个问题，贴心的 Doug Lea 大师早已给我们准备好相应策略 &lt;code&gt;CyclicBarrier&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202007/1583165-20200701083748907-396027545.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;本来想将 &lt;code&gt;CyclicBarrier&lt;/code&gt; 的内容放到下一个章节，但是 CountDownLatch 的内容着实有些少，不够解渴，另外有对比才有伤害，所以内容没结束，咱得继续看 &lt;code&gt;CyclicBarrier&lt;/code&gt;）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202007/1583165-20200701083749184-1548194009.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;cyclicbarrier&quot;&gt;CyclicBarrier&lt;/h2&gt;
&lt;p&gt;上面简单说了一下 CyclicBarrier 被创造出来的理由，这里先看一下它的字面解释：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202007/1583165-20200701083749563-566821305.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;概念总是有些抽象，我们将上面的例子用 CyclicBarrier 再做个改动，先让大家有个直观的使用概念&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Slf4j
public class CyclicBarrierExample {

   // 创建 CyclicBarrier 实例，计数器的值设置为2
   private static CyclicBarrier cyclicBarrier = new CyclicBarrier(2);

   public static void main(String[] args) {
      ExecutorService executorService = Executors.newFixedThreadPool(2);
      int breakCount = 0;

        // 将线程提交到线程池
      executorService.submit(() -&amp;gt; {
         try {
            log.info(Thread.currentThread() + &quot;第一回合&quot;);
            Thread.sleep(1000);
            cyclicBarrier.await();

            log.info(Thread.currentThread() + &quot;第二回合&quot;);
            Thread.sleep(2000);
            cyclicBarrier.await();

            log.info(Thread.currentThread() + &quot;第三回合&quot;);
         } catch (InterruptedException | BrokenBarrierException e) {
            e.printStackTrace();
         } 
      });

      executorService.submit(() -&amp;gt; {
         try {
            log.info(Thread.currentThread() + &quot;第一回合&quot;);
            Thread.sleep(2000);
            cyclicBarrier.await();

            log.info(Thread.currentThread() + &quot;第二回合&quot;);
            Thread.sleep(1000);
            cyclicBarrier.await();

            log.info(Thread.currentThread() + &quot;第三回合&quot;);
         } catch (InterruptedException | BrokenBarrierException e) {
            e.printStackTrace();
         }
      });

      executorService.shutdown();
   }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202007/1583165-20200701083749948-623133941.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;结合程序代码与运行结果，我们可以看出，子线程执行完第一回合后（执行回合所需时间不同），都会调用 await() 方法，等所有线程都到达屏障点后，会突破屏障继而执行第二回合，同样的道理最终到达第三回合&lt;/p&gt;
&lt;p&gt;形象化的展示上述示例的运行过程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202007/1583165-20200701083750397-692629063.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看到这里，你应该明白 CyclicBarrier 的基本用法，但随之你内心也应该有了一些疑问：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;怎么判断所有线程都到达屏障点的？&lt;/li&gt;
&lt;li&gt;突破某一屏障后，又是怎么重置 CyclicBarrier 计数器，等待线程再一次突破屏障呢？&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;带着这些问题我们来看一看源码&lt;/p&gt;
&lt;h3 id=&quot;源码分析-2&quot;&gt;源码分析&lt;/h3&gt;
&lt;p&gt;同样先打开 CyclicBarrier 的类结构，展开类全部内容，其实也没多少内容&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202007/1583165-20200701083750779-1980596660.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从类结构中看到有：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;await() 方法，猜测应该和 CountDownLatch 是类似的，都是获取同步状态，阻塞自己&lt;/li&gt;
&lt;li&gt;ReentrantLock，CyclicBarrier 内部竟然也用到了我们之前讲过的 ReentrantLock，猜测这个锁一定保护 CyclicBarrier 的某个变量，那肯定也是基于 AQS 相关知识了&lt;/li&gt;
&lt;li&gt;Condition，存在条件，猜测会有等待/通知机制的运用&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我们继续带着这些猜测，结合上面的实例代码一点点来验证&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 创建 CyclicBarrier 实例，计数器的值设置为2
private static CyclicBarrier cyclicBarrier = new CyclicBarrier(2);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看构造函数 (这里的英文注释舍不得删掉，因为说的太清楚了，我来结合注释来说明一下)：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private final int parties;
private int count;

public CyclicBarrier(int parties) {
    this(parties, null);
}

    /**
     * Creates a new {@code CyclicBarrier} that will trip when the
     * given number of parties (threads) are waiting upon it, and which
     * will execute the given barrier action when the barrier is tripped,
     * performed by the last thread entering the barrier.
     *
     * @param parties the number of threads that must invoke {@link #await}
     *        before the barrier is tripped
     * @param barrierAction the command to execute when the barrier is
     *        tripped, or {@code null} if there is no action
     * @throws IllegalArgumentException if {@code parties} is less than 1
     */
    public CyclicBarrier(int parties, Runnable barrierAction) {
        if (parties &amp;lt;= 0) throw new IllegalArgumentException();
        this.parties = parties;
        this.count = parties;
        this.barrierCommand = barrierAction;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据注释说明，parties 代表冲破屏障之前要触发的线程总数，count 本身又是计数器，那问题来了&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;直接就用 count 不就可以了嘛？为啥同样用于初始化计数器，要维护两个变量呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从 parties 和 count 的变量声明中，你也能看出一些门道，前者有 final 修饰，初始化后就不可以改变了，因为 CyclicBarrier 的设计目的是可以循环利用的，所以始终用 parties 来记录线程总数，当 count 计数器变为 0 后，如果没有 parties 的值赋给它，怎么进行重新复用再次计数呢，所以这里维护两个变量很有必要&lt;/p&gt;
&lt;p&gt;接下来就看看 await() 到底是怎么实现的&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 从方法签名上可以看出，该方法同样可以被中断，另外还有一个 BrokenBarrierException 异常，我们一会看
public int await() throws InterruptedException, BrokenBarrierException {
    try {
        // 调用内部 dowait 方法， 第一个参数为 false，表示不设置超时时间，第二个参数也就没了意义
        return dowait(false, 0L);
    } catch (TimeoutException toe) {
        throw new Error(toe); // cannot happen
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来看看 &lt;code&gt;dowait(false, 0L)&lt;/code&gt; 做了哪些事情 （这个方法内容有点多，别担心，逻辑并不复杂，请看关键代码注释）&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private int dowait(boolean timed, long nanos)
    throws InterruptedException, BrokenBarrierException,
           TimeoutException {
    final ReentrantLock lock = this.lock;
    // 还记得之前说过的 Lock 标准范式吗？ JDK 内部都是这么使用的，你一定也要遵循范式
    lock.lock();
    try {
        final Generation g = generation;

        // broken 是静态内部类 Generation唯一的一个成员变量，用于记录当前屏障是否被打破，如果打破，则抛出 BrokenBarrierException 异常
        // 这里感觉挺困惑的，我们要【冲破】屏障，这里【打破】屏障却抛出异常，注意我这里的用词
        if (g.broken)
            throw new BrokenBarrierException();

        // 如果线程被中断，则会通过 breakBarrier 方法将 broken 设置为true，也就是说，如果有线程收到中断通知，直接就打破屏障，停止 CyclicBarrier， 并唤醒所有线程
        if (Thread.interrupted()) {
            breakBarrier();
            throw new InterruptedException();
        }
      
        // ************************************
        // 因为 breakBarrier 方法在这里会被调用多次，为了便于大家理解，我直接将 breakBarrier 代码插入到这里
        private void breakBarrier() {
          // 将打破屏障标识 设置为 true
          generation.broken = true;
          // 重置计数器
          count = parties;
          // 唤醒所有等待的线程
          trip.signalAll();
                }
        // ************************************

                                // 每当一个线程调用 await 方法，计数器 count 就会减1
        int index = --count;
        // 当 count 值减到 0 时，说明这是最后一个调用 await() 的子线程，则会突破屏障
        if (index == 0) {  // tripped
            boolean ranAction = false;
            try {
                // 获取构造函数中的 barrierCommand，如果有值，则运行该方法
                final Runnable command = barrierCommand;
                if (command != null)
                    command.run();
                ranAction = true;
                // 激活其他因调用 await 方法而被阻塞的线程，并重置 CyclicBarrier
                nextGeneration();
              
                // ************************************
                // 为了便于大家理解，我直接将 nextGeneration 实现插入到这里
                private void nextGeneration() {
                    // signal completion of last generation
                    trip.signalAll();
                    // set up next generation
                    count = parties;
                    generation = new Generation();
                }
                // ************************************
              
                return 0;
            } finally {
                if (!ranAction)
                    breakBarrier();
            }
        }

        // index 不等于0， 说明当前不是最后一个线程调用 await 方法
        // loop until tripped, broken, interrupted, or timed out
        for (;;) {
            try {
                // 没有设置超时时间
                if (!timed)
                        // 进入条件等待
                    trip.await();
                else if (nanos &amp;gt; 0L)
                        // 否则，判断超时时间，这个我们在 AQS 中有说明过，包括为什么最后超时阈值 spinForTimeoutThreshold 不再比较的原因，大家会看就好
                    nanos = trip.awaitNanos(nanos);
            } catch (InterruptedException ie) {
                // 条件等待被中断，则判断是否有其他线程已经使屏障破坏。若没有则进行屏障破坏处理，并抛出异常；否则再次中断当前线程

                if (g == generation &amp;amp;&amp;amp; ! g.broken) {
                    breakBarrier();
                    throw ie;
                } else {
                    Thread.currentThread().interrupt();
                }
            }

            if (g.broken)
                throw new BrokenBarrierException();

                // 如果新一轮回环结束，会通过 nextGeneration 方法新建 generation 对象
            if (g != generation)
                return index;

            if (timed &amp;amp;&amp;amp; nanos &amp;lt;= 0L) {
                breakBarrier();
                throw new TimeoutException();
            }
        }
    } finally {
        lock.unlock();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;doWait 就是 CyclicBarrier 的核心逻辑， 可以看出，该方法入口使用了 ReentrantLock，这也就是为什么 Generation broken 变量没有被声明为 volatile 类型保持可见性，因为对其的更改都是在锁的内部，同样在锁的内部对计数器 count 做更新，也保证了原子性&lt;/p&gt;
&lt;p&gt;doWait 方法中，是通过 nextGeneration 方法来重新初始化/重置 CyclicBarrier 状态的，该类中还有一个 reset() 方法，也是重置 CyclicBarrier 状态的&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void reset() {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        breakBarrier();   // break the current generation
        nextGeneration(); // start a new generation
    } finally {
        lock.unlock();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但 reset() 方法并没有在 CyclicBarrier 内部被调用，显然是给 CyclicBarrier 使用者来调用的，那问题来了&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;什么时候调用 reset() 方法呢&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;正常情况下，CyclicBarrier 是会被自动重置状态的，从 reset 的方法实现中可以看出调用了 breakBarrier&lt;/p&gt;
&lt;p&gt;方法，也就是说，调用 reset 会使当前处在等待中的线程最终抛出 BrokenBarrierException 并立即被唤醒，所以说 reset() 只会在你想打破屏障时才会使用&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202007/1583165-20200701083750972-129608231.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上述示例，我们构建 CyclicBarrier 对象时，并没有传递 barrierCommand 对象， 我们修改示例传入一个 barrierCommand 对象，看看会有什么结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 创建 CyclicBarrier 实例，计数器的值设置为2
private static CyclicBarrier cyclicBarrier = new CyclicBarrier(2, () -&amp;gt; {
   log.info(&quot;全部运行结束&quot;);
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202007/1583165-20200701083751455-1501984510.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从运行结果中来看，每次冲破屏障后都会执行 CyclicBarrier 初始化 barrierCommand 的方法， 这与我们对 doWait() 方法的分析完全吻合，从上面的运行结果中可以看出，最后一个线程是运行 barrierCommand run() 方法的线程，我们再来形象化的展示一下整个过程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202007/1583165-20200701083752163-387761899.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上图可以看出，barrierAction 与每次突破屏障是串行化的执行过程，假如 barrierAction 是很耗时的汇总操作，那这就是可以优化的点了，我们继续修改代码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 创建单线程线程池
private static Executor executor = Executors.newSingleThreadExecutor();

// 创建 CyclicBarrier 实例，计数器的值设置为2
private static CyclicBarrier cyclicBarrier = new CyclicBarrier(2, () -&amp;gt; {
   executor.execute(() -&amp;gt; gather());
});

private static void gather() {
   try {
      Thread.sleep(2000);
   } catch (InterruptedException e) {
      e.printStackTrace();
   }
   log.info(&quot;全部运行结束&quot;);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们这里将 CyclicBarrier 的回调函数 barrierAction使用单线程的线程池，这样最后一个冲破屏障的线程就不用等待 barrierAction 的执行，直接分配个线程池里的线程异步执行，进一步提升效率&lt;/p&gt;
&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202007/1583165-20200701083752607-1483329165.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们再形象化的看一下整个过程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202007/1583165-20200701083800717-1792792743.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里使用了单一线程池，增加了并行操作，提高了程序运行效率，那问题来了：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果 barrierAction 非常非常耗时，冲破屏障的任务就可能堆积在单一线程池的等待队列中，就存在 OOM 的风险，那怎么办呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是就要需要一定的限流策略或者使用线程池的拒绝的略等&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;那把单一线程池换成非单一的固定线程池不就可以了嘛？比如 fixed(5)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;乍一看确实能缓解单线程池可能引起的任务堆积问题，上面代码我们看到的 gather() 方法，假如该方法内部没有使用锁或者说存在竟态条件，那 CyclicBarrier 的回调函数 barrierAction 使用多线程必定引起结果的不准确&lt;/p&gt;
&lt;p&gt;所以在实际使用中还要结合具体的业务场景不断优化代码，使之更加健壮&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;本文讲解了 CountDownLatch 和 CyclicBarrier 的经典使用场景以及实现原理，以及在使用过程中可能会遇到的问题，比如将大的 list 拆分作业就可以用到前者，读取多个 Excel 的sheet 页，最后进行结果汇总就可以用到后者 （文中完整示例代码已上传）&lt;/p&gt;
&lt;p&gt;最后，再形象化的比喻一下&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;CountDownLatch 主要用来解决一个线程等待多个线程的场景，可以类比旅游团团长要等待所有游客到齐才能去下一个景点&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;而 CyclicBarrier 是一组线程之间的相互等待，可以类比几个驴友之间的不离不弃，共同到达某个地方，再继续出发，这样反复&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;灵魂追问&quot;&gt;灵魂追问&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;怎样拿到 CyclicBarrier 的汇总结果呢？&lt;/li&gt;
&lt;li&gt;线程池中的 Future 特性你有使用过吗？&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;接下来，咱们就聊聊那些可以使用的 Future 特性&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;Java 并发编程实战&lt;/li&gt;
&lt;li&gt;Java 并发编程的艺术&lt;/li&gt;
&lt;li&gt;Java 并发编程之美&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/24104642/when-to-reset-cyclicbarrier-in-java-multithreading#:~:text=CyclicBarriers%20are%20useful%20in%20programs,the%20waiting%20threads%20are%20released.&quot;&gt;When to reset CyclicBarrier in java multithreading&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://dayarch.top&quot;&gt;个人博客：https://dayarch.top&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/G7BXuZh0Qh1-mE6ts4LJqQ&quot;&gt;加我微信好友&lt;/a&gt;, 进群娱乐学习交流，备注「进群」&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote&gt;
&lt;h3 id=&quot;欢迎持续关注公众号：「日拱一兵」&quot;&gt;欢迎持续关注公众号：「日拱一兵」&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;前沿 Java 技术干货分享&lt;/li&gt;
&lt;li&gt;高效工具汇总 | 回复「工具」&lt;/li&gt;
&lt;li&gt;面试问题分析与解答&lt;/li&gt;
&lt;li&gt;技术资料领取 | 回复「资料」&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;以读侦探小说思维轻松趣味学习 Java 技术栈相关知识，本着将复杂问题简单化，抽象问题具体化和图形化原则逐步分解技术问题，技术持续更新，请持续关注......&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202007/1583165-20200701083802790-1821816286.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 01 Jul 2020 00:38:00 +0000</pubDate>
<dc:creator>日拱一兵</dc:creator>
<og:description>你有一个思想，我有一个思想，我们交换后，一个人就有两个思想 If you can NOT explain it simply, you do NOT understand it well enough</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/FraserYu/p/13217283.html</dc:identifier>
</item>
<item>
<title>恕我直言你可能真的不会java第10篇-集合元素归约 - 字母哥博客</title>
<link>http://www.cnblogs.com/zimug/p/13217248.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zimug/p/13217248.html</guid>
<description>&lt;p&gt;Stream API为我们提供了&lt;code&gt;Stream.reduce&lt;/code&gt;用来实现集合元素的归约。reduce函数有三个参数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;em&gt;Identity标识&lt;/em&gt;：一个元素，它是归约操作的初始值，如果流为空，则为默认结果。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Accumulator累加器&lt;/em&gt;：具有两个参数的函数：归约运算的部分结果和流的下一个元素。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Combiner合并器（可选）&lt;/em&gt;：当归约并行化时，或当累加器参数的类型与累加器实现的类型不匹配时，用于合并归约操作的部分结果的函数。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202007/1815316-20200701082324009-60985318.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;注意观察上面的图，我们先来理解累加器：&lt;/li&gt;
&lt;li&gt;阶段累加结果作为累加器的第一个参数&lt;/li&gt;
&lt;li&gt;集合遍历元素作为累加器的第二个参数&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;integer类型归约&quot;&gt;Integer类型归约&lt;/h2&gt;
&lt;p&gt;reduce初始值为0，累加器可以是lambda表达式，也可以是方法引用。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;List&amp;lt;Integer&amp;gt; numbers = Arrays.asList(1, 2, 3, 4, 5, 6);
int result = numbers
        .stream()
        .reduce(0, (subtotal, element) -&amp;gt; subtotal + element);
System.out.println(result);  //21

int result = numbers
        .stream()
        .reduce(0, Integer::sum);
System.out.println(result); //21
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;string类型归约&quot;&gt;String类型归约&lt;/h2&gt;
&lt;p&gt;不仅可以归约Integer类型，只要累加器参数类型能够匹配，可以对任何类型的集合进行归约计算。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;List&amp;lt;String&amp;gt; letters = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;);
String result = letters
        .stream()
        .reduce(&quot;&quot;, (partialString, element) -&amp;gt; partialString + element);
System.out.println(result);  //abcde


String result = letters
        .stream()
        .reduce(&quot;&quot;, String::concat);
System.out.println(result);  //ancde
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;复杂对象归约&quot;&gt;复杂对象归约&lt;/h2&gt;
&lt;p&gt;计算所有的员工的年龄总和。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Employee e1 = new Employee(1,23,&quot;M&quot;,&quot;Rick&quot;,&quot;Beethovan&quot;);
Employee e2 = new Employee(2,13,&quot;F&quot;,&quot;Martina&quot;,&quot;Hengis&quot;);
Employee e3 = new Employee(3,43,&quot;M&quot;,&quot;Ricky&quot;,&quot;Martin&quot;);
Employee e4 = new Employee(4,26,&quot;M&quot;,&quot;Jon&quot;,&quot;Lowman&quot;);
Employee e5 = new Employee(5,19,&quot;F&quot;,&quot;Cristine&quot;,&quot;Maria&quot;);
Employee e6 = new Employee(6,15,&quot;M&quot;,&quot;David&quot;,&quot;Feezor&quot;);
Employee e7 = new Employee(7,68,&quot;F&quot;,&quot;Melissa&quot;,&quot;Roy&quot;);
Employee e8 = new Employee(8,79,&quot;M&quot;,&quot;Alex&quot;,&quot;Gussin&quot;);
Employee e9 = new Employee(9,15,&quot;F&quot;,&quot;Neetu&quot;,&quot;Singh&quot;);
Employee e10 = new Employee(10,45,&quot;M&quot;,&quot;Naveen&quot;,&quot;Jain&quot;);


List&amp;lt;Employee&amp;gt; employees = Arrays.asList(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10);


Integer total = employees.stream().map(Employee::getAge).reduce(0,Integer::sum);
System.out.println(total); //346
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;先用map将Stream流中的元素由Employee类型处理为Integer类型（age）。&lt;/li&gt;
&lt;li&gt;然后对Stream流中的Integer类型进行归约&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;combiner合并器的使用&quot;&gt;Combiner合并器的使用&lt;/h2&gt;
&lt;p&gt;除了使用map函数实现类型转换后的集合归约，我们还可以用Combiner合并器来实现，这里第一次使用到了Combiner合并器。&lt;br/&gt;因为Stream流中的元素是Employee，累加器的返回值是Integer，所以二者的类型不匹配。这种情况下可以使用Combiner合并器对累加器的结果进行二次归约，相当于做了类型转换。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Integer total3 = employees.stream()
        .reduce(0,(totalAge,emp) -&amp;gt; totalAge + emp.getAge(),Integer::sum); //注意这里reduce方法有三个参数
System.out.println(total); //346
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;计算结果和使用map进行数据类型转换的方式是一样的。&lt;/p&gt;
&lt;h2 id=&quot;并行流数据归约（使用合并器）&quot;&gt;并行流数据归约（使用合并器）&lt;/h2&gt;
&lt;p&gt;对于大数据量的集合元素归约计算，更能体现出Stream并行流计算的威力。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202007/1815316-20200701082324290-1283751364.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在进行并行流计算的时候，可能会将集合元素分成多个组计算。为了更快的将分组计算结果累加，可以使用合并器。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Integer total2 = employees
        .parallelStream()
        .map(Employee::getAge)
        .reduce(0,Integer::sum,Integer::sum);  //注意这里reduce方法有三个参数

System.out.println(total); //346
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;欢迎关注我的博客，里面有很多精品合集&quot;&gt;欢迎关注我的博客，里面有很多精品合集&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;本文转载注明出处（必须带连接，不能只转文字）：&lt;a href=&quot;http://www.zimug.com&quot;&gt;字母哥博客&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;觉得对您有帮助的话，帮我点赞、分享！您的支持是我不竭的创作动力！&lt;/strong&gt; 。另外，笔者最近一段时间输出了如下的精品内容，期待您的关注。&lt;/p&gt;
</description>
<pubDate>Wed, 01 Jul 2020 00:23:00 +0000</pubDate>
<dc:creator>字母哥博客</dc:creator>
<og:description>Stream API为我们提供了Stream.reduce用来实现集合元素的归约。reduce函数有三个参数： Identity标识：一个元素，它是归约操作的初始值，如果流为空，则为默认结果。 Acc</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zimug/p/13217248.html</dc:identifier>
</item>
<item>
<title>深入理解JVM（③）Java的模块化 - 纪莫</title>
<link>http://www.cnblogs.com/jimoer/p/13216782.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jimoer/p/13216782.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;JDK9引入的Java模块化系统（Java Platform Module System ，JPMS）是 对Java技术的一次重要升级，除了像之前JAR包那样充当代码的容器之外，还包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;依赖其他模块的列表。&lt;/li&gt;
&lt;li&gt;导出的包列表，即其他模块可以使用的列表。&lt;/li&gt;
&lt;li&gt;开放的包列表，即其他模块可反射访问模块的列表。&lt;/li&gt;
&lt;li&gt;使用的服务列表。&lt;/li&gt;
&lt;li&gt;提供服务的实现列表。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;模块化系统&quot;&gt;模块化系统&lt;/h3&gt;
&lt;p&gt;可配置的封装隔离机制解决了原来类路径上跨文件的public类的可访问性的问题。public类型不再意味着所有地方代码都可以访问它们，&lt;strong&gt;未导出&lt;/strong&gt;和&lt;strong&gt;未开放&lt;/strong&gt;的类是不能够被外部使用。&lt;/p&gt;
&lt;h4 id=&quot;举例说明：&quot;&gt;举例说明：&lt;/h4&gt;
&lt;p&gt;新创建一个maven工程，并创建两个module。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200630000037675.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,size_60,color_c8cae6,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在每个module的Language level 和 SDK 设置成JDK9&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200629235046232.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,size_16,color_c8cae6,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200629235114583.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,size_16,color_c8cae6,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后在每个module的顶层目录中创建module-info.java&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200629235323740.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,size_60,color_c8cae6,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在ExampleOne中创建两个不同package下的类，&lt;code&gt;ExampleFirst&lt;/code&gt;和&lt;code&gt;ExampleOne&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.jimoer.jdkmoduleOne.test;

public class ExampleFirst {

    private int id;

    private String name;

    private String sex;

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getSex() {
        return sex;
    }

    public void setSex(String sex) {
        this.sex = sex;
    }

    @Override
    public String toString() {
        return &quot;ExampleFirst{&quot; +
                &quot;id=&quot; + id +
                &quot;, name='&quot; + name + '\'' +
                &quot;, sex='&quot; + sex + '\'' +
                '}';
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.jimoer.jdkmoduleOne;

public class ExampleOne {


    private int id;

    private String name;

    private String arg;

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getArg() {
        return arg;
    }

    public void setArg(String arg) {
        this.arg = arg;
    }

    @Override
    public String toString() {
        return &quot;ExampleOne{&quot; +
                &quot;id=&quot; + id +
                &quot;, name='&quot; + name + '\'' +
                &quot;, arg='&quot; + arg + '\'' +
                '}';
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在ExampleOne的module-info.java中声明导出包的路径。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;module exampleOne {

     // 导出包路径
    exports com.jimoer.jdkmoduleOne.test;

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在ExampleTwo中声明requires为引入包&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;module exampleTwo {
    requires exampleOne;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在ExampleTwo中使用ExampleOne中的类&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;ublic class ExampleTwo {

    public static void main(String[] args) {

        ExampleFirst first = new ExampleFirst();

        first.setId(1);
        first.setName(&quot;余欢水&quot;);
        first.setSex(&quot;男&quot;);
        
        System.out.println(first);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;ExampleFirst{id=1, name='余欢水', sex='男'}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是当在ExampleTwo中引用ExampleOne中非导出包下的类时就会编译出错。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020063022185537.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,size_60,color_c8cae6,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;如上图提示，所有不被导出的包默认都被封装在模块里面。&lt;/p&gt;
&lt;h4 id=&quot;模块的兼容性&quot;&gt;模块的兼容性&lt;/h4&gt;
&lt;p&gt;为了使可配置的封装隔离机制能够兼容传统的类路径查找机制，JDK9提出了与“类路径”（ClassPath）相对应的“&lt;strong&gt;模块路径&lt;/strong&gt;”（ModulePath）的概念。只要放在类路径上的JAR文件，都会被当作传统的JAR包来对待；相应地，只要放在模块路径上的JAR文件，即使没有使用JMOD后缀，甚至不包含module-info.class文件，也仍然会被当作一个模块来对待。&lt;/p&gt;
&lt;p&gt;为了保证Java应用升级到JDK9之后依然使用传统的类路径，不会受到影响，制定了三条规则来保证兼容性。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;JAR文件在类路径的访问规则&lt;/strong&gt;：所有类路径下的JAR文件及其他资源文件，都被视为自动打包在一个匿名模块（Unnamed Module）里，这个匿名模块几乎是没有任何隔离的，它可以看到和使用类路径上所有的包、JDK模块中所有的导出包，以及模块路径是哪个所有模块中导出的包。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;模块在模块路径的访问规则&lt;/strong&gt;：模块路径下的具名模块（Named Module）只能访问到她依赖定义中列明依赖的模块和包，匿名模块里所有的内容对具名模块来说都是不可见的，即具名模块看不见传统JAR包的内容。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;JAR文件在模块路径的访问规则&lt;/strong&gt;：如果把一个传统的、不包含模块定义的JAR文件放置到模块路径中，它就会变成一个自动模块（Automatic Module）。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;模块化下的类加载器&quot;&gt;模块化下的类加载器&lt;/h3&gt;
&lt;p&gt;JDK9为了保证兼容性，依然保持了三层类加载器架构以及双亲委派模型。但是为了模块化系统的顺利实施，还是对类加载器做了一些改动。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先，扩展类加载器（Extension Class Loader）被平台类加载器（Platform Class Loader）取代。因为模块化天然的支持扩展，自然不需要在存在扩展类加载器了。&lt;/li&gt;
&lt;li&gt;其次，平台类加载器和应用类加载器都不再派生自java.net.URLClassLoader，如果有程序直接依赖了这种继承关系，或者依赖了URLClassLoader类特定方法，那代码很可能会在JDK9及更高版本的JDK中崩溃。&lt;/li&gt;
&lt;li&gt;最后，&lt;mark&gt;JDK9中虽然仍然维持着三层类加载器和双亲委派架构，但类加载的委派关系也发生了变动。当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责哪个模块的加载器完成加载，这可以算是对双亲委派的第四次破坏&lt;/mark&gt;。&lt;br/&gt;JDK9前后三层类加载器的架构图对比如下：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200630231507191.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,size_60,color_c8cae6,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Wed, 01 Jul 2020 00:20:00 +0000</pubDate>
<dc:creator>纪莫</dc:creator>
<og:description>前言 JDK9引入的Java模块化系统（Java Platform Module System ，JPMS）是 对Java技术的一次重要升级，除了像之前JAR包那样充当代码的容器之外，还包括： 依赖其</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jimoer/p/13216782.html</dc:identifier>
</item>
<item>
<title>【Flutter 实战】简约而不简单的计算器 - 老孟Flutter</title>
<link>http://www.cnblogs.com/mengqd/p/13217179.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mengqd/p/13217179.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200701071511828-1763949338.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5.5471698113208&quot;&gt;
&lt;p&gt;老孟导读：这是 【Flutter 实战】组件系列文章的最后一篇，其他组件地址：&lt;a href=&quot;http://laomengit.com/guide/widgets/Text.html&quot;&gt;http://laomengit.com/guide/widgets/Text.html&lt;/a&gt;，接下来将会讲解动画系列，关注老孟，精彩不断。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;先看一下效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200701071512388-723084121.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;大家学习UI编程语言时喜欢用哪个 App 当作第一个练手的项目呢？，我喜欢使用 &lt;strong&gt;计算器&lt;/strong&gt; ，可能是习惯了吧，学习 Android 和 React Native 都用此 App 当作练手的项目。&lt;/p&gt;
&lt;p&gt;下面我会一步一步的教大家如何实现此项目。&lt;/p&gt;
&lt;p&gt;整个项目的 UI 分为两大部分，一部分是顶部显示数字和计算结果，另一部分是底部的输入按钮。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200701071512688-132771494.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以整体布局使用 &lt;strong&gt;Column&lt;/strong&gt;，在不同分辨率的手机上，规定底部固定大小，剩余空间都由顶部组件填充，所以顶部组件使用 &lt;strong&gt;Expanded&lt;/strong&gt; 扩充，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;Container(
  padding: EdgeInsets.symmetric(horizontal: 18),
  child: Column(
    children: &amp;lt;Widget&amp;gt;[
      Expanded(
        child: Container(
          alignment: Alignment.bottomRight,
          padding: EdgeInsets.only(right: 10),
          child: Text(
            '$_text',
            maxLines: 1,
            style: TextStyle(
                color: Colors.white,
                fontSize: 48,
                fontWeight: FontWeight.w400),
          ),
        ),
      ),
      SizedBox(
        height: 20,
      ),
      _CalculatorKeyboard(
        onValueChange: _onValueChange,
      ),
      SizedBox(
        height: 80,
      )
    ],
  ),
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;SizedBox&lt;/strong&gt; 组件用于两个组件之间的间隔。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;_CalculatorKeyboard&lt;/strong&gt; 是底部的输入按钮组件，也是此项目的重点，除了 &lt;strong&gt;0&lt;/strong&gt; 这个按钮外，其余都是圆形按钮，不同之处是 高亮颜色（按住时颜色）、背景颜色、按钮文本、文本颜色不同，因此先实现一个按钮组件，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;Ink(
  decoration: BoxDecoration(
      color: Color(0xFF363636),
      borderRadius: BorderRadius.all(Radius.circular(200))),
  child: InkWell(
    borderRadius: BorderRadius.all(Radius.circular(200)),
    highlightColor: Color(0xFF363636),
    child: Container(
      width: 70,
      height: 70,
      alignment: Alignment.center,
      child: Text(
        '1',
        style: TextStyle(color: Colors.white, fontSize: 24),
      ),
    ),
  ),
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200701071512803-187080446.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而 &lt;strong&gt;0&lt;/strong&gt; 这个按钮的宽度是两个按钮的宽度 + 两个按钮的间隙，所以 &lt;strong&gt;0&lt;/strong&gt; 按钮代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;Ink(
  decoration: BoxDecoration(
      color: Color(0xFF363636),
      borderRadius: BorderRadius.all(Radius.circular(200))),
  child: InkWell(
    borderRadius: BorderRadius.all(Radius.circular(200)),
    highlightColor: Color(0xFF363636),
    child: Container(
      width: 158,
      height: 70,
      alignment: Alignment.center,
      child: Text(
        '0',
        style: TextStyle(color: Colors.white, fontSize: 24),
      ),
    ),
  ),
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200701071512944-1767557653.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;将按钮组件进行封装，其中高亮颜色（按住时颜色）、背景颜色、按钮文本、文本颜色属性作为参数，封装如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;class _CalculatorItem extends StatelessWidget {
  final String text;
  final Color textColor;
  final Color color;
  final Color highlightColor;
  final double width;
  final ValueChanged&amp;lt;String&amp;gt; onValueChange;

  _CalculatorItem(
      {this.text,
      this.textColor,
      this.color,
      this.highlightColor,
      this.width,
      this.onValueChange});

  @override
  Widget build(BuildContext context) {
    return Ink(
      decoration: BoxDecoration(
          color: color, borderRadius: BorderRadius.all(Radius.circular(200))),
      child: InkWell(
        onTap: () {
          onValueChange('$text');
        },
        borderRadius: BorderRadius.all(Radius.circular(200)),
        highlightColor: highlightColor ?? color,
        child: Container(
          width: width ?? 70,
          height: 70,
          padding: EdgeInsets.only(left: width == null ? 0 : 25),
          alignment: width == null ? Alignment.center : Alignment.centerLeft,
          child: Text(
            '$text',
            style: TextStyle(color: textColor ?? Colors.white, fontSize: 24),
          ),
        ),
      ),
    );
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;输入按钮&quot;&gt;输入按钮&lt;/h4&gt;
&lt;p&gt;输入按钮的布局使用 &lt;strong&gt;Wrap&lt;/strong&gt; 布局组件，如果没有 0 这个组件也可以使用 &lt;strong&gt;GridView&lt;/strong&gt;组件，按钮的数据：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;final List&amp;lt;Map&amp;gt; _keyboardList = [
  {
    'text': 'AC',
    'textColor': Colors.black,
    'color': Color(0xFFA5A5A5),
    'highlightColor': Color(0xFFD8D8D8)
  },
  {
    'text': '+/-',
    'textColor': Colors.black,
    'color': Color(0xFFA5A5A5),
    'highlightColor': Color(0xFFD8D8D8)
  },
  {
    'text': '%',
    'textColor': Colors.black,
    'color': Color(0xFFA5A5A5),
    'highlightColor': Color(0xFFD8D8D8)
  },
  {
    'text': '÷',
    'color': Color(0xFFE89E28),
    'highlightColor': Color(0xFFEDC68F)
  },
  {'text': '7', 'color': Color(0xFF363636)},
  {'text': '8', 'color': Color(0xFF363636)},
  {'text': '9', 'color': Color(0xFF363636)},
  {
    'text': 'x',
    'color': Color(0xFFE89E28),
    'highlightColor': Color(0xFFEDC68F)
  },
  {'text': '4', 'color': Color(0xFF363636)},
  {'text': '5', 'color': Color(0xFF363636)},
  {'text': '6', 'color': Color(0xFF363636)},
  {
    'text': '-',
    'color': Color(0xFFE89E28),
    'highlightColor': Color(0xFFEDC68F)
  },
  {'text': '1', 'color': Color(0xFF363636)},
  {'text': '2', 'color': Color(0xFF363636)},
  {'text': '3', 'color': Color(0xFF363636)},
  {
    'text': '+',
    'color': Color(0xFFE89E28),
    'highlightColor': Color(0xFFEDC68F)
  },
  {'text': '0', 'color': Color(0xFF363636), 'width': 158.0},
  {'text': '.', 'color': Color(0xFF363636)},
  {
    'text': '=',
    'color': Color(0xFFE89E28),
    'highlightColor': Color(0xFFEDC68F)
  },
];
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;整个输入按钮组件：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;class _CalculatorKeyboard extends StatelessWidget {
  final ValueChanged&amp;lt;String&amp;gt; onValueChange;

  const _CalculatorKeyboard({Key key, this.onValueChange}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Wrap(
      runSpacing: 18,
      spacing: 18,
      children: List.generate(_keyboardList.length, (index) {
        return _CalculatorItem(
          text: _keyboardList[index]['text'],
          textColor: _keyboardList[index]['textColor'],
          color: _keyboardList[index]['color'],
          highlightColor: _keyboardList[index]['highlightColor'],
          width: _keyboardList[index]['width'],
          onValueChange: onValueChange,
        );
      }),
    );
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200701071513075-1645789205.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;onValueChange&lt;/strong&gt; 是点击按钮的回调，参数是当前按钮的文本，用于计算，下面说下计算逻辑：&lt;/p&gt;
&lt;p&gt;这里有4个变量：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;_text&lt;/strong&gt;：显示当前输入的数字和计算结果。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;_beforeText&lt;/strong&gt;：用于保存被加数，比如输入 5+1，保存 5 ，用于后面的计算。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;_isResult&lt;/strong&gt;：表示当前值是否为计算的结果，true：新输入数字直接显示，false：新输入数字和当前字符串相加，比如当前显示 5，如果是计算的结果，点击 1 时，直接显示1，否则显示 51。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;_operateText&lt;/strong&gt;：保存加减乘除。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;AC&lt;/strong&gt; 按钮表示清空当前输入，显示 0，同时初始化其他变量：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;case 'AC':
  _text = '0';
  _beforeText = '0';
  _isResult = false;
  break;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;+/-&lt;/strong&gt; 按钮表示对当前数字取反，比如 5-&amp;gt;-5:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;case '+/-':
  if (_text.startsWith('-')) {
    _text = _text.substring(1);
  } else {
    _text = '-$_text';
  }
  break;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;%&lt;/strong&gt; 按钮表示当前数除以100:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;case '%':
  double d = _value2Double(_text);
  _isResult = true;
  _text = '${d / 100.0}';
  break;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;+、-、x、÷&lt;/strong&gt; 按钮，保存当前 操作符号：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;case '+':
case '-':
case 'x':
case '÷':
  _isResult = false;
  _operateText = value;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;0-9 和 .&lt;/strong&gt; 按钮根据是否是计算结果和是否有操作符号进行显示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;case '0':
case '1':
case '2':
case '3':
case '4':
case '5':
case '6':
case '7':
case '8':
case '9':
case '.':
  if (_isResult) {
    _text = value;
  }
  if (_operateText.isNotEmpty &amp;amp;&amp;amp; _beforeText.isEmpty) {
    _beforeText = _text;
    _text = '';
  }
  _text += value;
  if (_text.startsWith('0')) {
    _text = _text.substring(1);
  }
  break;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;=&lt;/strong&gt; 按钮计算结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;case '=':
  double d = _value2Double(_beforeText);
  double d1 = _value2Double(_text);
  switch (_operateText) {
    case '+':
      _text = '${d + d1}';
      break;
    case '-':
      _text = '${d - d1}';
      break;
    case 'x':
      _text = '${d * d1}';
      break;
    case '÷':
      _text = '${d / d1}';
      break;
  }
  _beforeText = '';
  _isResult = true;
  _operateText = '';
  break;


double _value2Double(String value) {
    if (_text.startsWith('-')) {
      String s = value.substring(1);
      return double.parse(s) * -1;
    } else {
      return double.parse(value);
    }
  }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;回过头来，发现代码仅仅只有250多行，当然App也是有&lt;strong&gt;不足&lt;/strong&gt;的地方：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;不足之一：计算结果逻辑，上面计算结果的逻辑是不完美的，当增加一个操作符（比如 &lt;strong&gt;取余&lt;/strong&gt;），计算逻辑复杂度将会以指数级方式增加，那为什么还要用此方式？最重要的原因是计算结果逻辑不是此项目的重点，作为一个Flutter的入门项目重点是熟悉组件的使用，计算器的计算逻辑有一个比较著名的方式：&lt;strong&gt;后缀表达式的计算过程&lt;/strong&gt;，然而此方式偏向于算法，对初学者非常不友好，因此，我采用了一种不完美但适合初学者的逻辑。&lt;/li&gt;
&lt;li&gt;不足之二：此App没有考虑横屏的情况，为什么？因为横屏很可能导致整体布局发生变化，横屏时按钮是变大还是拉伸，或者拉伸间隙？不同的方式使用的布局会发生变化，因此，目前只考虑了竖屏的布局，实际项目中要考虑横屏情况吗？其实这是一个用户体验的问题，首先问问自己，为什么要横屏？横屏可以显著的提升用户体验吗？如果不能，为什么要花费大力气适配横屏呢？&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;交流&quot;&gt;交流&lt;/h2&gt;
&lt;p&gt;老孟Flutter博客地址（330个控件用法）：&lt;a href=&quot;http://laomengit.com&quot;&gt;http://laomengit.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎加入Flutter交流群（微信：laomengit）、关注公众号【老孟Flutter】：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th/&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200701071513326-1060877681.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200701071513533-392251630.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</description>
<pubDate>Tue, 30 Jun 2020 23:15:00 +0000</pubDate>
<dc:creator>老孟Flutter</dc:creator>
<og:description>老孟导读：这是 【Flutter 实战】组件系列文章的最后一篇，其他组件地址：http://laomengit.com/guide/widgets/Text.html，接下来将会讲解动画系列，关注老孟</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mengqd/p/13217179.html</dc:identifier>
</item>
<item>
<title>台阶很高，青蛙跳不跳？ - WindWant</title>
<link>http://www.cnblogs.com/niejunlei/p/13200746.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/niejunlei/p/13200746.html</guid>
<description>&lt;p&gt;青蛙总是被被要求跳台阶，我想，他一定很累的！&lt;/p&gt;
&lt;p&gt;一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法？&lt;/p&gt;
&lt;p&gt;对于这样的问题，n可大可小，如果n很小，我们可以直观暴力拆解就可以得到答案，但是如果n很大，那么这个问题就升级了。&lt;/p&gt;
&lt;p&gt;一般处理问题，我们最直接的思路，可能就是分治，将大问题拆解为小问题，分而解决。&lt;/p&gt;
&lt;p&gt;在此，也不例外。&lt;/p&gt;
&lt;p&gt;首先我们知道青蛙一次能跳一级或者两级。&lt;/p&gt;
&lt;p&gt;假定最后一跳跳一级，则剩余n-1个台阶，则问题化为解决跳上n-1个台阶的问题。&lt;/p&gt;
&lt;p&gt;假定最后一跳跳两级，则剩余n-2个台阶，则问题化为解决跳上n-2个台阶的问题。&lt;/p&gt;
&lt;p&gt;所以归总起来，总的可能的跳法为（n-1）个台阶和（n-2）个台阶问题的总和。&lt;/p&gt;
&lt;p&gt;我们假定解决方案为f(n)，则f(n) = f(n-1) + f(n-2) ，这里我们假定n是大于2的。&lt;/p&gt;
&lt;p&gt;当n = 1 时，青蛙跳一级即可，f(1) = 1。&lt;/p&gt;
&lt;p&gt;当n = 2 时，青蛙可以连跳两个一级或者跳一个两级，f(2) = 2。&lt;/p&gt;
&lt;p&gt;观察f(n) = f(n-1) + f(n-2) 公式，你们首先想到的是什么？对的，是递归，级联求解：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; jump(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (n &amp;lt; 3&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; n;
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; jump(n - 1) + jump(n - 2&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们以图像化展示一下这个过程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/603942/202006/603942-20200628003457024-242743714.png&quot; alt=&quot;&quot; width=&quot;497&quot; height=&quot;301&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图中以相同颜色标识了递归过程中会产生重复计算的节点。&lt;/p&gt;
&lt;p&gt;重复是一种算力和资源不必要的浪费，我们可以对此进行优化：&lt;/p&gt;
&lt;p&gt;对于上述的递归运算，我们可以看到，是由后至前计算的，也即从f(n)-&amp;gt;f(1)。也就是我们需要知道向前的每一个位置的方案结果。我们换个方向，从前至后连续计算出每个位置的方案，则最后的位置即为我们所要的结果，同时也可以规避重复计算的问题：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/603942/202006/603942-20200629151728723-328018184.png&quot; alt=&quot;&quot; width=&quot;641&quot; height=&quot;118&quot; loading=&quot;lazy&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;代码实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; jumpx(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (n &amp;lt; 3&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; n;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;每个位置存储下标（i + 1）个台阶的可能结果f(i + 1)，所以n个台阶即为计算f(n - 1)&lt;/span&gt;
        Long[] arr = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Long[n];
        arr[&lt;/span&gt;0] = 1L; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;一个台阶&lt;/span&gt;
        arr[1] = 2L; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;两个台阶
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从 n = 3 开始循环计算&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 2; i &amp;lt; n; i++&lt;span&gt;) {
            arr[i] &lt;/span&gt;= arr[i - 1] + arr[i - 2&lt;span&gt;];
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; arr[n - 1&lt;span&gt;];
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们通过增加一个长度为n的数组空间占用来换取算法耗时优化，相对于递归算法，耗时上有数量级差别。&lt;/p&gt;
&lt;p&gt;耗时减少了，但是空间似乎浪费了，其实，也没必要存储每一个方案的结果，我们只需要知道【前一个】，【前两个】以及【当前】的几个变量。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/603942/202007/603942-20200701002455633-1556526277.png&quot; alt=&quot;&quot; width=&quot;533&quot; height=&quot;337&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;改造如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; jumpy(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (n &amp;lt; 3&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; n;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第三节台阶方案值f(3) = f(2) + f(1) = 1 + 2 = 3;&lt;/span&gt;
        &lt;span&gt;long&lt;/span&gt; preTwoCount = 1; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;一个台阶&lt;/span&gt;
        &lt;span&gt;long&lt;/span&gt; preOneCount = 2; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;两个台阶&lt;/span&gt;
        &lt;span&gt;long&lt;/span&gt; stepsCount = 0; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;n个台阶
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从 n = 3 开始循环计算&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 2; i &amp;lt; n; i++&lt;span&gt;) {
            stepsCount &lt;/span&gt;= preOneCount +&lt;span&gt; preTwoCount;
            preOneCount &lt;/span&gt;=&lt;span&gt; stepsCount;
            preTwoCount &lt;/span&gt;=&lt;span&gt; preOneCount;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; stepsCount;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;空间复杂度降为O(1)。&lt;/p&gt;

</description>
<pubDate>Tue, 30 Jun 2020 16:26:00 +0000</pubDate>
<dc:creator>WindWant</dc:creator>
<og:description>青蛙总是被被要求跳台阶，我想，他一定很累的！ 一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法？ 对于这样的问题，n可大可小，如果n很小，我们可以直观暴</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/niejunlei/p/13200746.html</dc:identifier>
</item>
<item>
<title>#Google HTML&amp;CSS规范指南 - jaycethanks</title>
<link>http://www.cnblogs.com/jaycethanks/p/13216957.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jaycethanks/p/13216957.html</guid>
<description>&lt;blockquote&gt;
&lt;p&gt;翻译自&lt;a href=&quot;https://google.github.io/styleguide/htmlcssguide.html#Parting_Words&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;1-背景&quot;&gt;1. 背景&lt;/h2&gt;
&lt;p&gt;本文档定义了HTML和CSS的样式以及格式规则，旨在提高协同合作，代码质量，基础架构支持。本规则应用于基于HTML和CSS为源代码的项目。只要保持常规代码的质量，工具就可以自由地进行混淆、压缩和编译。&lt;/p&gt;
&lt;h2 id=&quot;2-通用&quot;&gt;2. 通用&lt;/h2&gt;
&lt;h3 id=&quot;21-通用样式规则&quot;&gt;2.1 通用样式规则&lt;/h3&gt;
&lt;h4 id=&quot;211-协议&quot;&gt;2.1.1 &lt;strong&gt;协议&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;在可能的情况下，尽可能的使用HTTPS来嵌入内容资源&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;始终使用HTTPS(&lt;code&gt;https:&lt;/code&gt;)来引用图像和其它的媒体文件，css样式表，以及js脚本。除非没有对应的通过HTTPS提供的资源。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!-- 不推荐: 省略协议规则 --&amp;gt;
&amp;lt;script src=&quot;//ajax.googleapis.com/ajax/libs/jquery/3.4.0/jquery.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;

&amp;lt;!-- 不推荐: 使用 HTTP --&amp;gt;
&amp;lt;script src=&quot;http://ajax.googleapis.com/ajax/libs/jquery/3.4.0/jquery.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!-- 推荐 --&amp;gt;
&amp;lt;script src=&quot;https://ajax.googleapis.com/ajax/libs/jquery/3.4.0/jquery.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-css&quot;&gt;/* 不推荐: 省略协议 */
@import '//fonts.googleapis.com/css?family=Open+Sans';

/* 不推荐: 使用 HTTP */
@import 'http://fonts.googleapis.com/css?family=Open+Sans';
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-css&quot;&gt;/* 推荐 */
@import 'https://fonts.googleapis.com/css?family=Open+Sans';
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;22-通用格式规则&quot;&gt;2.2 通用格式规则&lt;/h3&gt;
&lt;h4 id=&quot;221-缩进&quot;&gt;2.2.1 缩进&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;一个缩进等同于两个空格，不要使用多个tabs或者混用tabs和空格来缩进&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;ul&amp;gt;
  &amp;lt;li&amp;gt;Fantastic
  &amp;lt;li&amp;gt;Great
&amp;lt;/ul&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-css&quot;&gt;.example {
  color: blue;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;23-通用元规则&quot;&gt;2.3 通用元规则&lt;/h3&gt;
&lt;h4 id=&quot;231-编码&quot;&gt;2.3.1 编码&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;使用UTF-8&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;确保你的编辑器使用了UTF-8字符编码，没有字节顺序标记。&lt;/p&gt;
&lt;p&gt;通过&lt;code&gt;&amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;&lt;/code&gt;来指定HTML模版和文档编码。&lt;/p&gt;
&lt;p&gt;不要为样式表指定字符集，因为样式表默认是UTF-8字符编码。&lt;/p&gt;
&lt;p&gt;（更多编码以及何如指定他们，参考&lt;a href=&quot;https://www.w3.org/International/tutorials/tutorial-char-enc/&quot;&gt;LINK&lt;/a&gt;）&lt;/p&gt;
&lt;h4 id=&quot;232-注释&quot;&gt;2.3.2 注释&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;在可能的时候，为必要的代码注释。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;233-操作项&quot;&gt;2.3.3 操作项&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;使用&lt;code&gt;TODO&lt;/code&gt;来标记代办事项和操作项&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;高亮的显示待办事项，仅使用&lt;code&gt;TODO&lt;/code&gt;，不要使用其它的常见格式，例如&lt;code&gt;@@&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在括号中去缀加用户名或者邮箱列表之类的联系方式，如&lt;code&gt;TODO(联系方式)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在冒号后面缀加操作项，如&lt;code&gt;TODO:操作项&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;{# TODO(john.doe): revisit centering #}
&amp;lt;center&amp;gt;Test&amp;lt;/center&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!-- TODO: remove optional tags --&amp;gt;
&amp;lt;ul&amp;gt;
  &amp;lt;li&amp;gt;Apples&amp;lt;/li&amp;gt;
  &amp;lt;li&amp;gt;Oranges&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;3-html&quot;&gt;3. HTML&lt;/h2&gt;
&lt;h3 id=&quot;31-html样式规则&quot;&gt;3.1 HTML样式规则&lt;/h3&gt;
&lt;h4 id=&quot;311-文档类型&quot;&gt;3.1.1 文档类型&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;使用HTML5&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;HTML5 标记&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/code&gt;是所有HTML文档的首选。&lt;/p&gt;
&lt;p&gt;（建议使用HTML，即&lt;code&gt;text/html&lt;/code&gt;，不要使用XHTML，即&lt;code&gt;application/xhtml+xml&lt;/code&gt;，因为缺少浏览器和基础架构支持，并且比HTML提供更少的优化空间。）&lt;/p&gt;
&lt;p&gt;不要关闭void元素（非文字内容元素，也叫空元素），例如使用&lt;code&gt;&amp;lt;br&amp;gt;&lt;/code&gt;而不是&lt;code&gt;&amp;lt;/br&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&quot;312-hmtl有效性&quot;&gt;3.1.2 HMTL有效性&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;尽可能使用有效的HTML，除非由于文件大小的其他无法达到的性能目标而无法这样做。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以使用像&lt;a href=&quot;https://validator.w3.org/nu/&quot;&gt;W3C HTML validator&lt;/a&gt;这样的工具去检测。&lt;br/&gt;使用有效的HTML是一个可测量的基本质量指标，有效的HTML代码有助于了解技术要求和约束，并且确保正确的使用HTML。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!-- 不推荐 --&amp;gt;
&amp;lt;title&amp;gt;Test&amp;lt;/title&amp;gt;
&amp;lt;article&amp;gt;This is only a test.
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!-- 推荐 --&amp;gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;
&amp;lt;title&amp;gt;Test&amp;lt;/title&amp;gt;
&amp;lt;article&amp;gt;This is only a test.&amp;lt;/article&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;313-语义化&quot;&gt;3.1.3 语义化&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;根据不同的目的去使用不同的HTML标签&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;根据目的去使用合适的HTML标签，对于html文档的可访问性，复用，以及代码效率等原因都起着重要的作用。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!-- 不推荐 --&amp;gt;
&amp;lt;div onclick=&quot;goToRecommendations();&quot;&amp;gt;All recommendations&amp;lt;/div&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!-- 推荐 --&amp;gt;
&amp;lt;a href=&quot;recommendations/&quot;&amp;gt;All recommendations&amp;lt;/a&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;314-为多媒体内容留下挽救方案&quot;&gt;3.1.4 为多媒体内容留下挽救方案&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;为多媒体替代的内容&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于对媒体资源，像图片，视频，使用canvas实现的动画对象，要确保提供可替代的内容，对于图片而言，应该指定有意义的替代文本（&lt;code&gt;alt&lt;/code&gt;属性），对于音视频，如果可能的情况下，应当提供对应的文本和字幕。&lt;/p&gt;
&lt;p&gt;提供可替代的内容对提高可访问性而言是很重要的，如果没有&lt;code&gt;alt&lt;/code&gt;属性，盲人用户几乎无法知道图片是关于什么，而其它用户也有可能没办法理解音视频是什么内容。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!-- 不推荐 --&amp;gt;
&amp;lt;img src=&quot;spreadsheet.png&quot;&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!-- 推荐 --&amp;gt;
&amp;lt;img src=&quot;spreadsheet.png&quot; alt=&quot;Spreadsheet screenshot.&quot;&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（对于图像而言，&lt;code&gt;alt&lt;/code&gt;属性有时候也会造成冗余，例如，对于用于装饰用的图片，不具备实际含义，就不应当指定&lt;code&gt;alt&lt;/code&gt;属性，即&lt;code&gt;alt=&quot;&quot;&lt;/code&gt;。）&lt;/p&gt;
&lt;h4 id=&quot;315-业务分离&quot;&gt;3.1.5 业务分离&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;应当把文档结构、表现样式、和行为分开。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;严格的保持文档结构（markup），表现样式（styling）和行为（scripting）分离，并且应该尽量的让这三部分相互影响达到最小。&lt;/p&gt;
&lt;p&gt;为了实现这一目的，要确保文档和模版只含有HTML代码，且HTML代码仅用于提供布局结构的作用，把所有的样式都放在样式表中，把所有的行为全都放在脚本中。&lt;/p&gt;
&lt;p&gt;另外，通过从文档和模板中链接尽可能少的样式表和脚本，使联系区域尽可能小。&lt;/p&gt;
&lt;p&gt;项目的可维护性，分离结构和样式以及行为是十分必要的。从样式表和脚本文件中去修改相应逻辑远比直接在html中去修改代价小。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!-- 不推荐 --&amp;gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;title&amp;gt;HTML sucks&amp;lt;/title&amp;gt;
&amp;lt;link rel=&quot;stylesheet&quot; href=&quot;base.css&quot; media=&quot;screen&quot;&amp;gt;
&amp;lt;link rel=&quot;stylesheet&quot; href=&quot;grid.css&quot; media=&quot;screen&quot;&amp;gt;
&amp;lt;link rel=&quot;stylesheet&quot; href=&quot;print.css&quot; media=&quot;print&quot;&amp;gt;
&amp;lt;h1 style=&quot;font-size: 1em;&quot;&amp;gt;HTML sucks&amp;lt;/h1&amp;gt;
&amp;lt;p&amp;gt;I’ve read about this on a few sites but now I’m sure:
  &amp;lt;u&amp;gt;HTML is stupid!!1&amp;lt;/u&amp;gt;
&amp;lt;center&amp;gt;I can’t believe there’s no way to control the styling of
  my website without doing everything all over again!&amp;lt;/center&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!-- 推荐 --&amp;gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;title&amp;gt;My first CSS-only redesign&amp;lt;/title&amp;gt;
&amp;lt;link rel=&quot;stylesheet&quot; href=&quot;default.css&quot;&amp;gt;
&amp;lt;h1&amp;gt;My first CSS-only redesign&amp;lt;/h1&amp;gt;
&amp;lt;p&amp;gt;I’ve read about this on a few sites but today I’m actually
  doing it: separating concerns and avoiding anything in the HTML of
  my website that is presentational.
&amp;lt;p&amp;gt;It’s awesome!
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;316-实体引用&quot;&gt;3.1.6 实体引用&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;不要使用实体引用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设文件和编辑器以及团队之间使用相同的编码(UTF-8)，就没有必要使用实体引用，例如 &lt;code&gt;&amp;amp;mdash;&lt;/code&gt;,&lt;code&gt;&amp;amp;rdquo;&lt;/code&gt;,&lt;code&gt;&amp;amp;#x263a;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;唯一的例外就是当在HTML中表示特殊含义字符的时候，起到类似转义的作用，（例如&lt;code&gt;&amp;lt;&lt;/code&gt;和&lt;code&gt;&amp;amp;&lt;/code&gt;）,以及一些不可见的字符（例如不间断空格）。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!-- 不推荐 --&amp;gt;
The currency symbol for the Euro is &amp;amp;ldquo;&amp;amp;eur;&amp;amp;rdquo;.
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!-- 推荐 --&amp;gt;
The currency symbol for the Euro is “€”.
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;317-可选的标签&quot;&gt;3.1.7 可选的标签&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;省略可选的标签&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了优化文件大小和便于扫面，请考虑省略可选的标记，HTML5规范（&lt;a href=&quot;https://html.spec.whatwg.org/multipage/syntax.html#syntax-tag-omission&quot;&gt;HTML5 specification&lt;/a&gt; ）定义了那些标记可以被省略。&lt;/p&gt;
&lt;p&gt;(这种方法可能需要一段宽限期来作为更广泛的指导原则，因为它与web开发人员通常被教导的内容有很大的不同。出于一致性和简单性的原因，最好忽略所有可选标记，而不仅仅是一个选项。)&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!-- 不推荐 --&amp;gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;Spending money, spending bytes&amp;lt;/title&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;p&amp;gt;Sic.&amp;lt;/p&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!-- 推荐 --&amp;gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;title&amp;gt;Saving money, saving bytes&amp;lt;/title&amp;gt;
&amp;lt;p&amp;gt;Qed.
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;318-type属性&quot;&gt;3.1.8 &lt;code&gt;type&lt;/code&gt;属性&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;为样式表和脚本省略&lt;code&gt;type&lt;/code&gt;属性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不要使用&lt;code&gt;type&lt;/code&gt;属性为样式表和脚本指明文件类型，除非用的不是css和javascript。&lt;/p&gt;
&lt;p&gt;因为HTML5默认指定了&lt;code&gt;type&lt;/code&gt;为&lt;code&gt;text/css&lt;/code&gt;以及&lt;code&gt;text/javascript&lt;/code&gt;,所以在文档中再去使用&lt;code&gt;type&lt;/code&gt;属性明确文件类型是不必要的。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!-- 不推荐 --&amp;gt;
&amp;lt;link rel=&quot;stylesheet&quot; href=&quot;https://www.google.com/css/maia.css&quot; type=&quot;text/css&quot;&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!-- 推荐 --&amp;gt;
&amp;lt;link rel=&quot;stylesheet&quot; href=&quot;https://www.google.com/css/maia.css&quot;&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!-- 不推荐 0--&amp;gt;
&amp;lt;script src=&quot;https://www.google.com/js/gweb/analytics/autotrack.js&quot; type=&quot;text/javascript&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!-- 推荐 --&amp;gt;
&amp;lt;script src=&quot;https://www.google.com/js/gweb/analytics/autotrack.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;32-html格式规则&quot;&gt;3.2 HTML格式规则&lt;/h3&gt;
&lt;h4 id=&quot;321-通用格式&quot;&gt;3.2.1 通用格式&lt;/h4&gt;
&lt;p&gt;每一个块区、列表或者表格都应该在新的一行中开始，并且，缩进每个子元素。&lt;/p&gt;
&lt;p&gt;(如果您遇到列表项之间存在空格的问题，可以将所有li元素放在一行中。鼓励linter抛出警告而不是错误。)&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;blockquote&amp;gt;
  &amp;lt;p&amp;gt;&amp;lt;em&amp;gt;Space&amp;lt;/em&amp;gt;, the final frontier.&amp;lt;/p&amp;gt;
&amp;lt;/blockquote&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;ul&amp;gt;
  &amp;lt;li&amp;gt;Moe
  &amp;lt;li&amp;gt;Larry
  &amp;lt;li&amp;gt;Curly
&amp;lt;/ul&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;table&amp;gt;
  &amp;lt;thead&amp;gt;
    &amp;lt;tr&amp;gt;
      &amp;lt;th scope=&quot;col&quot;&amp;gt;Income
      &amp;lt;th scope=&quot;col&quot;&amp;gt;Taxes
  &amp;lt;tbody&amp;gt;
    &amp;lt;tr&amp;gt;
      &amp;lt;td&amp;gt;$ 5.00
      &amp;lt;td&amp;gt;$ 4.50
&amp;lt;/table&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;322-html-换行&quot;&gt;3.2.2 HTML 换行&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;断开长行（可选的）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虽然对于HTML没有限制列的建议，但是如果可以显著提高可读性，可以考虑换行。&lt;/p&gt;
&lt;p&gt;当换行之后，每一个衔接行都应该至少额外多缩紧4个空格。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;md-progress-circular md-mode=&quot;indeterminate&quot; class=&quot;md-accent&quot;
    ng-show=&quot;ctrl.loading&quot; md-diameter=&quot;35&quot;&amp;gt;
&amp;lt;/md-progress-circular&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;md-progress-circular
    md-mode=&quot;indeterminate&quot;
    class=&quot;md-accent&quot;
    ng-show=&quot;ctrl.loading&quot;
    md-diameter=&quot;35&quot;&amp;gt;
&amp;lt;/md-progress-circular&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;md-progress-circular md-mode=&quot;indeterminate&quot;
                      class=&quot;md-accent&quot;
                      ng-show=&quot;ctrl.loading&quot;
                      md-diameter=&quot;35&quot;&amp;gt;
&amp;lt;/md-progress-circular&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;323-html-引号&quot;&gt;3.2.3 HTML 引号&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;当引用属性值的时候，使用双引号&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用双引号（&lt;code&gt;&quot;&quot;&lt;/code&gt;）和不是单引号去包裹属性值。.&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!-- 不推荐 --&amp;gt;
&amp;lt;a class='maia-button maia-button-secondary'&amp;gt;Sign in&amp;lt;/a&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!-- 推荐 --&amp;gt;
&amp;lt;a class=&quot;maia-button maia-button-secondary&quot;&amp;gt;Sign in&amp;lt;/a&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;4-css&quot;&gt;4. CSS&lt;/h2&gt;
&lt;h3 id=&quot;41-css样式规则&quot;&gt;4.1 CSS样式规则&lt;/h3&gt;
&lt;h4 id=&quot;411-css-有效性&quot;&gt;4.1.1 CSS 有效性&lt;/h4&gt;
&lt;p&gt;使用有效的CSS&lt;/p&gt;
&lt;h4 id=&quot;412-id和class命名&quot;&gt;4.1.2 ID和Class命名&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;使用有含义的或者通用的ID和Class名。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;避免使用描述性的或者晦涩难懂的命名，始终使用反映了元素目的或功能的ID和类名，或者通用的名称。&lt;/p&gt;
&lt;p&gt;特定的且反映目的功能的命名应该尽可能的易于理解且最小的被再次修改的可能性。&lt;/p&gt;
&lt;p&gt;通用名称只是与它们的兄弟姐妹没有特殊或没有意义的元素的后备。 通常需要它们作为“帮助者”。&lt;/p&gt;
&lt;p&gt;使用功能名称或通用名称可以减少不必要的文档或模板更改的可能性&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-css&quot;&gt;/* 不推荐: meaningless */
#yee-1901 {}

/* 不推荐: presentational */
.button-green {}
.clear {}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-css&quot;&gt;/* 推荐: specific */
#gallery {}
#login {}
.video {}

/* 推荐: generic */
.aux {}
.alt {}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;413-id-和-class-命名样式&quot;&gt;4.1.3 ID 和 Class 命名样式&lt;/h4&gt;
&lt;p&gt;使用尽可能短但必要的ID和类名。&lt;/p&gt;
&lt;p&gt;尽量简短地传达ID或类的含义。&lt;/p&gt;
&lt;p&gt;以这种方式使用ID和类名有助于提高可接受的可理解性和代码效率。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-css&quot;&gt;/* 不推荐 */
#navigation {}
.atr {}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-css&quot;&gt;/* 推荐 */
#nav {}
.author {}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;414--类型选择器（type-selectors）&quot;&gt;4.1.4 类型选择器（Type Selectors）&lt;/h4&gt;
&lt;p&gt;避免使用类型选择器来限定ID和类名。&lt;/p&gt;
&lt;p&gt;除非必要(例如使用helper类)，否则不要将元素名与id或类结合使用。&lt;/p&gt;
&lt;p&gt;避免不必要的祖先选择器有助于提高性能(&lt;a href=&quot;http://www.stevesouders.com/blog/2009/06/18/simplifying-css-selectors/&quot;&gt;performance reasons&lt;/a&gt;)。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-css&quot;&gt;/* 不推荐 */
ul#example {}
div.error {}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-css&quot;&gt;/* 推荐 */
#example {}
.error {}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;415-简写属性&quot;&gt;4.1.5 简写属性&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;尽可能的使用简写属性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;CSS提供了很多的简写属性，例如&lt;code&gt;font&lt;/code&gt;，我们应当尽可能的使用简写属性，即便只有一个需要被显示设定的属性值。&lt;/p&gt;
&lt;p&gt;使用简写属性有助于我们理解代码，且有助于代码效率。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-css&quot;&gt;/* 不推荐 */
border-top-style: none;
font-family: palatino, georgia, serif;
font-size: 100%;
line-height: 1.6;
padding-bottom: 2em;
padding-left: 1em;
padding-right: 1em;
padding-top: 0;
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-css&quot;&gt;/* 推荐 */
border-top: 0;
font: 100%/1.6 palatino, georgia, serif;
padding: 0 1em 2em;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;416-0-和-单位&quot;&gt;4.1.6 0 和 单位&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;如非必要，我们应该总是省略属性值为0时的单位，例如0px。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-css&quot;&gt;flex: 0px; /* This flex-basis component requires a unit. */
flex: 1 1 0px; /* Not ambiguous without the unit, but needed in IE11. */
margin: 0;
padding: 0;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;417-前置-0&quot;&gt;4.1.7 前置 0&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;省略属性值中的前置0&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不要在值或者长度介于-1到1之间的值中使用0.&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-css&quot;&gt;font-size: .8em;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;418-十六进制表示法&quot;&gt;4.1.8 十六进制表示法&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;如非必要，尽可能的使用三位十六进制表示法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于允许的颜色值，三个字符的十六进制表示法更短，更简洁。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-css&quot;&gt;/* 不推荐 */
color: #eebbcc;
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-css&quot;&gt;/* 推荐 */
color: #ebc;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;419-前缀&quot;&gt;4.1.9 前缀&lt;/h4&gt;
&lt;p&gt;在大型项目以及嵌入到其他项目或外部站点中的代码中，请使用前缀（作为名称空间）作为ID和类名。 使用简短的唯一标识符，后接破折号。、&lt;/p&gt;
&lt;p&gt;使用名称空间有助于防止命名冲突，并可以简化维护，例如在搜索和替换操作中。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-css&quot;&gt;.adw-help {} /* AdWords */
#maia-note {} /* Maia */
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;4110-id-和-class-名称分隔符&quot;&gt;4.1.10 ID 和 Class 名称分隔符&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;在ID或者Class名称中，使用连接符分开多个单词&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了提高理解和可扫描性 ，在选择器中，除了连字符以外，不要用任何字符连接单词和缩写(不包括任何字符)。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-css&quot;&gt;/* 不推荐: 不分开单词 “demo”和 “image” */
.demoimage {}

/*  不推荐: 使用下划线而不是连接符 */
.error_status {}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-css&quot;&gt;/* 推荐 */
#video-id {}
.ads-sample {}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;4111-黑客&quot;&gt;4.1.11 黑客&lt;/h4&gt;
&lt;p&gt;避免用户代理检测和CSS&quot;黑客攻击&quot;，首先尝试其他方法。&lt;/p&gt;
&lt;p&gt;通过用户代理检测或特殊的CSS过滤器、变通方法和hack来解决样式差异是很诱人的。这两种方法都应该作为最后的手段，以实现和维护一个有效的、可管理的代码库。换句话说，从长远来看，给检测和黑客提供免费通行证将损害项目，因为项目往往会采取阻力最小的方式。也就是说，允许并简化检测和破解意味着更频繁地使用检测和破解太频繁了。&lt;/p&gt;
&lt;h3 id=&quot;42-css格式规则&quot;&gt;4.2 CSS格式规则&lt;/h3&gt;
&lt;h4 id=&quot;421-声明顺序&quot;&gt;4.2.1 声明顺序&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;按照字母顺序进行声明&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将声明按照字母顺序进行排列，以便以一种易于记忆和维护的方式实现一致性的代码。&lt;/p&gt;
&lt;p&gt;忽略供应商特定的前缀以进行排序。然而，针对某个CSS属性的多个供应商特定的前缀&lt;/p&gt;
&lt;p&gt;应该保持排序。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;background: fuchsia;
border: 1px solid;
-moz-border-radius: 4px;
-webkit-border-radius: 4px;
border-radius: 4px;
color: black;
text-align: center;
text-indent: 2em;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;422-块中内容缩进&quot;&gt;4.2.2 块中内容缩进&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;缩进所有的块级内容&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是规则以及声明中的规则，以便反映层次结构并增进理解。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-css&quot;&gt;@media screen, projection {

  html {
    background: #fff;
    color: #444;
  }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;423-声明终止&quot;&gt;4.2.3 声明终止&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;使用分号以结束每行声明&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;出于一致性和可扩展性的原因，每个声明都以分号结尾。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-css&quot;&gt;/* 不推荐 */
.test {
  display: block;
  height: 100px
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-css&quot;&gt;/* 推荐 */
.test {
  display: block;
  height: 100px;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;424-属性名终止&quot;&gt;4.2.4 属性名终止&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;在每个属性名的冒号后，属性值之前，用一个空格隔开&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;始终在最后一个选择器之后，和开括号之前用一个空格隔开&lt;/p&gt;
&lt;p&gt;开括号应该和最后一个选择器始终在同一行&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-css&quot;&gt;/* 不推荐: 缺失空格 */
#video{
  margin-top: 1em;
}

/* 不推荐: 不必要的折行 */
#video
{
  margin-top: 1em;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-css&quot;&gt;/* 推荐 */
#video {
  margin-top: 1em;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;426-选择器和声明分离&quot;&gt;4.2.6 选择器和声明分离&lt;/h4&gt;
&lt;p&gt;通过折行来分割不同的选择器和声明&lt;/p&gt;
&lt;p&gt;每一个选择器始终从新的一行开始&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-css&quot;&gt;/* 不推荐 */
a:focus, a:active {
  position: relative; top: 1px;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-css&quot;&gt;/* 推荐 */
h1,
h2,
h3 {
  font-weight: normal;
  line-height: 1.2;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;427-分割样式规则&quot;&gt;4.2.7 分割样式规则&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;始终通过新的空行来分离不同的样式规则&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-css&quot;&gt;html {
  background: #fff;
}

body {
  margin: auto;
  width: 50%;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;428-css-引号使用规则&quot;&gt;4.2.8 CSS 引号使用规则&lt;/h4&gt;
&lt;p&gt;为属性选择器和属性值应用单引号（&lt;code&gt;''&lt;/code&gt;），而不是双引号（&quot;&quot;）&lt;/p&gt;
&lt;p&gt;URL 值不要使用引号&lt;/p&gt;
&lt;p&gt;例外：除非你使用 &lt;code&gt;@charset&lt;/code&gt; 规则, 才会用到双引号—&lt;a href=&quot;https://www.w3.org/TR/CSS21/syndata.html#charset&quot;&gt;single quotation marks are not permitted&lt;/a&gt;.&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-css&quot;&gt;/* 不推荐 */
@import url(&quot;https://www.google.com/css/maia.css&quot;);

html {
  font-family: &quot;open sans&quot;, arial, sans-serif;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-css&quot;&gt;/* 推荐 */
@import url(https://www.google.com/css/maia.css);

html {
  font-family: 'open sans', arial, sans-serif;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;43-css元规则&quot;&gt;4.3 CSS元规则&lt;/h3&gt;
&lt;h4 id=&quot;431-节注释&quot;&gt;4.3.1 节注释&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;通过注释对节进行分组（可选的）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;尽可能的使用注释对不同的节进行分组，不同的分组间用红白行来分隔。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-css&quot;&gt;/* Header */

#adw-header {}

/* Footer */

#adw-footer {}

/* Gallery */

.adw-gallery {}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;最后的话&quot;&gt;最后的话&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;始终保持前后一致&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果您正在编辑代码，请花几分钟时间查看您周围的代码并确定其样式。 如果他们在所&lt;/p&gt;
&lt;p&gt;有算术运算符周围使用空格，您也应该这样做。 如果他们的注释周围有小方框，则使您&lt;/p&gt;
&lt;p&gt;的注释周围也有小方框。&lt;/p&gt;
&lt;p&gt;制定样式指南的目的是拥有通用的编码词汇，以便人们可以专注于您在说的而不是在怎么&lt;/p&gt;
&lt;p&gt;说。 我们在这里介绍全局样式规则，以便人们了解词汇表，但是局部样式也很重要。 如&lt;/p&gt;
&lt;p&gt;果您添加到文件中的代码看起来与周围的现有代码完全不同，则当读者阅读文件时，会使&lt;/p&gt;
&lt;p&gt;他们的节奏变慢。 避免这种情况。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;翻译自&lt;a href=&quot;https://google.github.io/styleguide/htmlcssguide.html#Parting_Words&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 30 Jun 2020 16:19:00 +0000</pubDate>
<dc:creator>jaycethanks</dc:creator>
<og:description>翻译自原文 1. 背景 本文档定义了HTML和CSS的样式以及格式规则，旨在提高协同合作，代码质量，基础架构支持。本规则应用于基于HTML和CSS为源代码的项目。只要保持常规代码的质量，工具就可以自由</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jaycethanks/p/13216957.html</dc:identifier>
</item>
<item>
<title>【Spring注解驱动开发】如何使用@Value注解为bean的属性赋值，我们一起吊打面试官！ - 冰河团队</title>
<link>http://www.cnblogs.com/binghe001/p/13216798.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/binghe001/p/13216798.html</guid>
<description>&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;blockquote readability=&quot;6.6666666666667&quot;&gt;
&lt;p&gt;在之前的文章中，我们探讨了如何向Spring的IOC容器中注册bean组件，讲解了有关bean组件的生命周期的知识。今天，我们就来一起聊聊@Value注解的用法。&lt;/p&gt;
&lt;p&gt;项目工程源码已经提交到GitHub：&lt;a href=&quot;https://github.com/sunshinelyz/spring-annotation&quot;&gt;https://github.com/sunshinelyz/spring-annotation&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;value注解&quot;&gt;@Value注解&lt;/h2&gt;
&lt;p&gt;Spring中的@Value注解可以为bean中的属性赋值。我们先来看看@Value注解的源码，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package org.springframework.beans.factory.annotation;
import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.ANNOTATION_TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Value {
        String value();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从@Value注解的源码，我们可以看出：@Value注解可以标注在字段、方法、参数、注解上，在程序运行期间生效。&lt;/p&gt;
&lt;h2 id=&quot;value注解用法&quot;&gt;@Value注解用法&lt;/h2&gt;
&lt;h3 id=&quot;1不通过配置文件注入属性的情况&quot;&gt;1.不通过配置文件注入属性的情况&lt;/h3&gt;
&lt;p&gt;通过@Value将外部的值动态注入到Bean中，使用的情况有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;注入普通字符串&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Value(&quot;normal&quot;)
private String normal; // 注入普通字符串
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;注入操作系统属性&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Value(&quot;#{systemProperties['os.name']}&quot;)
private String systemPropertiesName; // 注入操作系统属性
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;注入表达式结果&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Value(&quot;#{ T(java.lang.Math).random() * 100.0 }&quot;)
private double randomNumber; //注入表达式结果
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;注入其他Bean属性&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Value(&quot;#{person.name}&quot;)
private String name; // 注入其他Bean属性：注入person对象的属性name
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;注入文件资源&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Value(&quot;classpath:io/mykit/spring/config/config.properties&quot;)
private Resource resourceFile; // 注入文件资源
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;注入URL资源&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Value(&quot;http://www.baidu.com&quot;)
private Resource url; // 注入URL资源
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;2通过配置文件注入属性的情况&quot;&gt;2.通过配置文件注入属性的情况&lt;/h3&gt;
&lt;p&gt;通过@Value(“${app.name}”)语法将属性文件的值注入到bean的属性中，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Component
// 引入外部配置文件组：${app.configinject}的值来自config.properties。
// 如果相同
@PropertySource({&quot;classpath:io/mykit/spring/config/config.properties&quot;,
    &quot;classpath:io/mykit/spring/config/config_${anotherfile.configinject}.properties&quot;})
public class ConfigurationFileInject{
    // 这里的值来自application.properties，spring boot启动时默认加载此文件
    @Value(&quot;${app.name}&quot;)
    private String appName; 

    // 注入第一个配置外部文件属性
    @Value(&quot;${book.name}&quot;)
    private String bookName; 

    // 注入第二个配置外部文件属性
    @Value(&quot;${book.name.placeholder}&quot;)
    private String bookNamePlaceholder; 

    // 注入环境变量对象，存储注入的属性值
    @Autowired
    private Environment env;  

    public String toString(){
        StringBuilder sb = new StringBuilder();
        sb.append(&quot;bookName=&quot;).append(bookName).append(&quot;\r\n&quot;)
        .append(&quot;bookNamePlaceholder=&quot;).append(bookNamePlaceholder).append(&quot;\r\n&quot;)
        .append(&quot;appName=&quot;).append(appName).append(&quot;\r\n&quot;)
        .append(&quot;env=&quot;).append(env).append(&quot;\r\n&quot;)
        // 从eniroment中获取属性值
        .append(&quot;env=&quot;).append(env.getProperty(&quot;book.name.placeholder&quot;)).append(&quot;\r\n&quot;);
        return sb.toString();
    }   
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;3value中和的区别&quot;&gt;3.@Value中#{..}和${...}的区别&lt;/h3&gt;
&lt;p&gt;我们这里提供一个测试属性文件：advance_value_inject.properties，大致的内容如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;server.name=server1,server2,server3
author.name=binghe
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试类AdvanceValueInject：引入advance_value_inject.properties文件，作为属性的注入&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Component
@PropertySource({&quot;classpath:io/mykit/spring/config/advance_value_inject.properties&quot;})
public class AdvanceValueInject {
...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;${...}的用法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;{}里面的内容必须符合SpEL表达式， 通过@Value(“${spelDefault.value}”)可以获取属性文件中对应的值，但是如果属性文件中没有这个属性，则会报错。可以通过赋予默认值解决这个问题，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Value(&quot;${author.name:binghe}&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述代码的含义表示向bean的属性中注入配置文件中的author.name属性的值，如果配置文件中没有author.name属性，则向bean的属性中注入默认值binghe。例如下面的代码片段。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Value(&quot;${author.name:binghe}&quot;)
private String name;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;#{…}的用法&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// SpEL：调用字符串Hello World的concat方法
@Value(&quot;#{'Hello World'.concat('!')}&quot;)
private String helloWorld;

// SpEL: 调用字符串的getBytes方法，然后调用length属性
@Value(&quot;#{'Hello World'.bytes.length}&quot;)
private String helloWorldbytes;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;${…}和#{…}混合使用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;${...}和#{...}可以混合使用，如下文代码执行顺序：通过${server.name}从属性文件中获取值并进行替换，然后就变成了 执行SpEL表达式{‘server1,server2,server3’.split(‘,’)}。&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// SpEL: 传入一个字符串，根据&quot;,&quot;切分后插入列表中， #{}和${}配置使用(注意单引号，注意不能反过来${}在外面，#{}在里面)
@Value(&quot;#{'${server.name}'.split(',')}&quot;)
private List&amp;lt;String&amp;gt; servers;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;在上文中#{}在外面，${}在里面可以执行成功，那么反过来是否可以呢？也就是说能否让${}在外面，#{}在里面，如下代码所示。&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// SpEL: 注意不能反过来${}在外面，#{}在里面，这个会执行失败
@Value(&quot;${#{'HelloWorld'.concat('_')}}&quot;)
private List&amp;lt;String&amp;gt; servers2;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;答案是不能。因为Spring执行${}时机要早于#{}，当Spring执行外层的${}时，内部的#{}为空，所以会执行失败！&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@Value注解用法小结：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;#{…} 用于执行SpEl表达式，并将内容赋值给属性。&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;${…} 主要用于加载外部属性文件中的值。&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#{…} 和${…} 可以混合使用，但是必须#{}外面，${}在里面。&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;value注解案例&quot;&gt;@Value注解案例&lt;/h2&gt;
&lt;p&gt;这里，我们还是以一个小案例的形式来说明。&lt;/p&gt;
&lt;p&gt;首先，我们来创建一个Person类作为测试的bean组件，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package io.mykit.spring.plugins.register.bean;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.ToString;
import java.io.Serializable;
/**
 * @author binghe
 * @version 1.0.0
 * @description 测试实体类
 */
@Data
@ToString
@NoArgsConstructor
@AllArgsConstructor
public class Person implements Serializable {
    private static final long serialVersionUID = 7387479910468805194L;
    private String name;
    private Integer age;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来，创建一个新的配置类PropertyValueConfig，用来配置Spring的bean组件，我们在PropertyValueConfig类中将Person类的对象注册到IOC容器中，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package io.mykit.spring.plugins.register.config;
import io.mykit.spring.plugins.register.bean.Person;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
/**
 * @author binghe
 * @version 1.0.0
 * @description 测试属性赋值
 */
@Configuration
public class PropertyValueConfig {
    @Bean
    public Person person(){
        return new Person();
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们再来创建一个测试类PropertyValueTest，在PropertyValueTest类中创建测试方法testPropertyValue01()，并在testPropertyValue01()方法中通过PropertyValueConfig类创建AnnotationConfigApplicationContext对象，打印出目前IOC容器中存在的bean名称，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package io.mykit.spring.test;
import io.mykit.spring.plugins.register.config.PropertyValueConfig;
import org.junit.Test;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import java.util.Arrays;
/**
 * @author binghe
 * @version 1.0.0
 * @description 测试bean的生命周期
 */
public class PropertyValueTest {
    @Test
    public void testPropertyValue01(){
        //创建IOC容器
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(PropertyValueConfig.class);
        String[] names = context.getBeanDefinitionNames();
        Arrays.stream(names).forEach(System.out::println);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时，我们运行PropertyValueTest类的testPropertyValue01()方法，输出的结果信息如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;org.springframework.context.annotation.internalConfigurationAnnotationProcessor
org.springframework.context.annotation.internalAutowiredAnnotationProcessor
org.springframework.context.annotation.internalCommonAnnotationProcessor
org.springframework.context.event.internalEventListenerProcessor
org.springframework.context.event.internalEventListenerFactory
propertyValueConfig
person
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从输出的结果信息中，可以看出，IOC容器中除了Spring框架注册的bean之外，还包含我们自己向IOC容器中注册的bean组件：propertyValueConfig和person。&lt;/p&gt;
&lt;p&gt;接下来，我们改造下PropertyValueTest类的testPropertyValue01()方法，输出Person对象的信息，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package io.mykit.spring.test;
import io.mykit.spring.plugins.register.bean.Person;
import io.mykit.spring.plugins.register.config.PropertyValueConfig;
import org.junit.Test;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import java.util.Arrays;
/**
 * @author binghe
 * @version 1.0.0
 * @description 测试bean的生命周期
 */
public class PropertyValueTest {
    @Test
    public void testPropertyValue01(){
        //创建IOC容器
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(PropertyValueConfig.class);
        String[] names = context.getBeanDefinitionNames();
        Arrays.stream(names).forEach(System.out::println);

        System.out.println(&quot;================================&quot;);
        Person person = (Person) context.getBean(&quot;person&quot;);
        System.out.println(person);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来，再次运行PropertyValueTest类的testPropertyValue01()方法，输出的结果信息如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;org.springframework.context.annotation.internalConfigurationAnnotationProcessor
org.springframework.context.annotation.internalAutowiredAnnotationProcessor
org.springframework.context.annotation.internalCommonAnnotationProcessor
org.springframework.context.event.internalEventListenerProcessor
org.springframework.context.event.internalEventListenerFactory
propertyValueConfig
person
================================
Person(name=null, age=null)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，向IOC容器中注册的Person对象的name属性为null，age属性为null。那如何向Person对象的name属性和age属性赋值呢？此时，Spring中的@Value注解就派上了用场。&lt;/p&gt;
&lt;p&gt;如果我们通过XML文件为bean的属性赋值，则可以通过如下配置的方式实现。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;bean id = &quot;person&quot; class=&quot;io.mykit.spring.plugins.register.bean.Person&quot;&amp;gt;
    &amp;lt;property name=&quot;name&quot; value=&quot;binghe&quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;property name=&quot;age&quot; value=&quot;18&quot;&amp;gt;&amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果使用注解该如何实现呢？别急，往下看！&lt;/p&gt;
&lt;p&gt;我们可以在Person类的属性上使用@Value注解为属性赋值，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package io.mykit.spring.plugins.register.bean;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.ToString;
import org.springframework.beans.factory.annotation.Value;
import java.io.Serializable;
/**
 * @author binghe
 * @version 1.0.0
 * @description 测试实体类
 */
@Data
@ToString
@NoArgsConstructor
@AllArgsConstructor
public class Person implements Serializable {
    private static final long serialVersionUID = 7387479910468805194L;
    @Value(&quot;binghe&quot;)
    private String name;
    @Value(&quot;#{20-2}&quot;)
    private Integer age;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时，我们再次运行PropertyValueTest类的testPropertyValue01()方法，输出的结果信息如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;org.springframework.context.annotation.internalConfigurationAnnotationProcessor
org.springframework.context.annotation.internalAutowiredAnnotationProcessor
org.springframework.context.annotation.internalCommonAnnotationProcessor
org.springframework.context.event.internalEventListenerProcessor
org.springframework.context.event.internalEventListenerFactory
propertyValueConfig
person
================================
Person(name=binghe, age=18)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，使用@Value注解已经向Person对象的name属性中注入了binghe，向age属性中注入了18。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;好了，咱们今天就聊到这儿吧！别忘了给个在看和转发，让更多的人看到，一起学习一起进步！！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;2.3333333333333&quot;&gt;
&lt;p&gt;项目工程源码已经提交到GitHub：&lt;a href=&quot;https://github.com/sunshinelyz/spring-annotation&quot;&gt;https://github.com/sunshinelyz/spring-annotation&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;写在最后&quot;&gt;写在最后&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;如果觉得文章对你有点帮助，请微信搜索并关注「 &lt;strong&gt;冰河技术&lt;/strong&gt; 」微信公众号，跟冰河学习Spring注解驱动开发。公众号回复“spring注解”关键字，领取Spring注解驱动开发核心知识图，让Spring注解驱动开发不再迷茫。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p align=&quot;right&quot;&gt;&lt;span&gt;部分参考：blog.csdn.net/hry2015/article/details/72453920&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 30 Jun 2020 15:48:00 +0000</pubDate>
<dc:creator>冰河团队</dc:creator>
<og:description>写在前面 在之前的文章中，我们探讨了如何向Spring的IOC容器中注册bean组件，讲解了有关bean组件的生命周期的知识。今天，我们就来一起聊聊@Value注解的用法。 项目工程源码已经提交到Gi</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/binghe001/p/13216798.html</dc:identifier>
</item>
<item>
<title>Java中栈和堆讲解 - Jerryoned</title>
<link>http://www.cnblogs.com/Jerryoned/p/13216144.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Jerryoned/p/13216144.html</guid>
<description>&lt;p&gt;&lt;span&gt;之前对JVM中堆内存和栈内存都是一直半解，今天有空就好好整理一下，用做学习笔记。   &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;包括Java程序在内，任何程序在运行时都是要开辟内存空间的。JVM运行时在内存中开辟一片内存区域，启动时在自己的内存区域中进行更细致的划分，因为虚拟机中每一片内存处理的方式都不同，所以要单独进行管理。实际上在JVM有五种内存管理形式：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;寄存器；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;本地方法区；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;方法区；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;栈内存（stack）；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;堆内存（heap）；&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;    今天重点梳理一下栈内存和堆内存。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     在讲解之前我们要了解一个计算机发展至今仍然无法解决的一个矛盾，就是内存的存取速度和数据大小之间的矛盾。当我们对存取速度越快，存储的数据量就越少，反之亦然。栈内存、堆内存其实就是对这种矛盾的一种妥协方式，它们有自己的优点也有自己的缺点：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;栈内存：存取速度要比堆内存快，仅次于CPU中的寄存器，但栈内存中数据大小和周期时固定的。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;堆内存：可以动态地分配内存大小，但存取速度慢。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;     那么栈内存、堆内存到底存储那些数据呢？&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;栈内存中存储都是局部变量，栈中数据生存空间一般在当前scopes内（可以简单理解为{...}括起来的区域）包含所有的基本类型（int、bool、char、float、double、short、long、byte）和引用类型。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;堆内存存储时类的对象，即类的实体，凡是new建立的都是在堆中，堆中存放的都是实体（对象），实体用于封装数据，而且是封装多个（实体的多个属性）。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;    另外，在举例前我们需要了解一个概念，什么是变量？变量是内存中分配的区域的名称。换句话说就是变量其实分配地址的别称，我们通过这个变量的名字就可以找到一个指向这个变量所引用的数据的内存指针。我们知道了变量的类型，也就知道了这个指针地址后面连续几个字节内存储的数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    我们以int[] arr=new int[]{1,2,3}为例，它的内存分配如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1990135/202006/1990135-20200630231607781-409026863.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; 从上图我们可以看到，“变量”是存在栈内存中，“变量所指向的数据”是存在堆内存中的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   下面我们举一个更为复杂的类， 来展示每一部分到底是怎么存储的：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;package&lt;/span&gt;&lt;span&gt; class1;

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Fruit{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; x=10&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; BigWaterMelon bigWaterMelon_1=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; BigWaterMelon(x);
    
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; y=20&lt;span&gt;;
    BigWaterMelon bigWaterMelon_2&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; BigWaterMelon(y);
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Fruit fruit=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Fruit();
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; z=30&lt;span&gt;;
        BigWaterMelon bigWaterMelon_3&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; BigWaterMelon(z);    
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(){
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run(){
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; k=100&lt;span&gt;;
                setWeight(k);
            }
            
            &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; setWeight(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; waterMelonWeight){
                fruit.bigWaterMelon_2.Weight&lt;/span&gt;=&lt;span&gt;waterMelonWeight;
            }
        }.start();
    }
    
}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; BigWaterMelon{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; Weight;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; BigWaterMelon(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; Weight){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Weight=&lt;span&gt;Weight;
    }
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;内存图如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1990135/202006/1990135-20200630224454793-1026361096.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;同一种颜色代表变量和对象的引用关系&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由于方法区和堆内存的数据都是线程间共享的，所以线程Main Thread，New Thread和Another Thread都可以访问方法区中的静态变量以及访问这个变量所引用的对象的实例变量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;栈内存中每个线程都有自己的虚拟机栈，每一个栈帧之间的数据就是线程独有的了，也就是说线程New Thread中setWeight方法是不能访问线程Main Thread中的局部变量bigWaterMelon_3，但是我们发现setWeight却访问了同为Main Thread局部变量的“fruit”，这是为什么呢？因为“fruit”被声明为final了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当“fruit”被声明为final后，“fruit”会作为New Thread的构造函数的一个参数传入New Thread，也就是堆内存中Fruit$1对象中的实例变量val$fruit会引用“fruit”引用的对象，从而New Thread可以访问到Main Thread的局部变量“fruit”。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;此外，栈内存有先进后出（Last in first Out）的特点，并且栈中数据生存空间一般在当前scopes内（可以简单理解为{...}括起来的区域），也就是说当方法执行结束后，方法内的局部变量在内存中就被清除了。但堆内存不会自动清除，它回不断地申请新的堆内存地址来存储新的数据。不再使用地旧数据只会当作“垃圾数据”，在C++中需要你手动清除，在JVM会自动将这些垃圾数据回收，也就是传说中地GC。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;无论是栈内存还是堆内存，内存空间都是有限的。当堆内存没有可用空间时，比如递归没有跳出，JVM会抛出java.lang.StackOverFlowError；当堆内存没有空间时，比如在while循环中不断创建实例，JVM会抛出java.lang.OutOfMemoryError。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;那么最后一个问题，为什么变量要放在栈内存中，而变量指向的数据要放在堆内存中呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我觉得可以这样理解，其一，变量实际上是地址的别称，本质上就是个地址，数据量不大，而实体数据量很大；其二，变量当不在使用时内存空间被回收，这是也就没有指针指向原来的实体数据，也就是成为了垃圾状态，当JVM再此检查时发现没有指针指向这块空间就会将其收回。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;------------------------------------------------------&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参考博文：&lt;a href=&quot;https://www.cnblogs.com/pomodoro/p/11912025.html&quot;&gt;https://www.cnblogs.com/pomodoro/p/11912025.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参考博文：&lt;a href=&quot;https://blog.csdn.net/jianghao233/article/details/82777789&quot;&gt;https://blog.csdn.net/jianghao233/article/details/82777789&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 30 Jun 2020 15:40:00 +0000</pubDate>
<dc:creator>Jerryoned</dc:creator>
<og:description>之前对JVM中堆内存和栈内存都是一直半解，今天有空就好好整理一下，用做学习笔记。 包括Java程序在内，任何程序在运行时都是要开辟内存空间的。JVM运行时在内存中开辟一片内存区域，启动时在自己的内存区</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Jerryoned/p/13216144.html</dc:identifier>
</item>
<item>
<title>关于线上一次DDOS攻击和阿里云DDOS防护相关内容 - 自由早晚乱余生</title>
<link>http://www.cnblogs.com/operationhome/p/13216765.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/operationhome/p/13216765.html</guid>
<description>&lt;h2 id=&quot;问题&quot;&gt;问题&lt;/h2&gt;
&lt;p&gt;最近我们的一台阿里云服务器 (ECS,有公网IP，Nginx 服务器，开放了80,443)，遭受到了DDOS攻击，主要攻击的行为是 攻击我们443 端口。发起大量的请求。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://djxblog.oss-cn-shenzhen.aliyuncs.com/djxblog/picture/typora/image-20200604140131494.png&quot; alt=&quot;image-20200604140131494&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是我们在 &lt;code&gt;Nginx&lt;/code&gt; 层面是做了限制的。只允许部分 IP 访问我们的&lt;code&gt;Nginx&lt;/code&gt; （allow ....; deny all;）所以实际是没有访问到我们的服务的接口的。请求未到我们的后端。&lt;/p&gt;
&lt;h4 id=&quot;疑问点&quot;&gt;疑问点&lt;/h4&gt;
&lt;p&gt;但是诡异的是，我们的 &lt;code&gt;Nginx&lt;/code&gt; 在被攻击之后，先是进入了流量清洗，清洗完了之后，直接进入黑洞了。也就是说我们服务器将接受不了请求。但是查看服务器的 &lt;code&gt;Nginx&lt;/code&gt; 日志，我们发现流量还是正常从 &lt;code&gt;WAF&lt;/code&gt; 进来的。没有受影响。&lt;/p&gt;
&lt;p&gt;我们怀疑问题可能是出在：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;进入流量黑洞抛弃所有外部流量是针对除了阿里云之外的流量&lt;/li&gt;
&lt;li&gt;阿里云可能单独对WAF做了策略。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;问题原因&quot;&gt;问题原因&lt;/h2&gt;
&lt;h3 id=&quot;名词解释&quot;&gt;名词解释&lt;/h3&gt;
&lt;h4 id=&quot;黑洞&quot;&gt;黑洞&lt;/h4&gt;
&lt;p&gt;按照阿里云的官方文档的对黑洞的解释是:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;当ECS或SLB实例的公网IP遭到大量DDoS攻击，且DDoS攻击的流量超出对应的黑洞阈值后，该公网IP将被黑洞，所有来自外部的流量都将被丢弃，导致相关的业务无法正常访问。您可以在云盾DDoS防护控制台查看账号下资产的黑洞事件信息，例如IP进入黑洞的时间及所遭受的攻击流量。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;继续翻查阿里云官方文档，终于发现了蛛丝马迹，&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;假如您的服务器遭受大流量攻击而进入黑洞，则所有来自外部的流量都会被丢弃，但是阿里云内部与该服务器同地域的云产品仍然能够正常连通该服务器。

因此，在您的服务器进入黑洞后，您可以使用阿里云内部的ECS云服务器连接该服务器。
https://help.aliyun.com/knowledge_detail/63613.html?spm=a2c4g.11186623.6.569.133d50f7uyQ8Cy
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也就是虽然进入了流量黑洞，但是这个同地域的阿里云产品还是可以访问到我们的服务的。 &lt;strong&gt;(注意是同地域哦。)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;查看 WAF 是否有地域之分 ，看到控制台就只有一个 中国内地和海外地区。这个就很尴尬了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;重点：&lt;/strong&gt;但是我们域名接入WAF 的时候 在添加域名的过程中，我们填入后端的 &lt;code&gt;Nginx IP&lt;/code&gt; 时 &lt;code&gt;Waf&lt;/code&gt; 会判断我们的 后端是在哪个地域，然后生成的 CNAME 解析地址为 你后端所在地域的 WAF 地址。 所以我们只需要查看下 CNAME 的地址是否和我们的 ECS 的机器在同一个地域，如果在同一个地域就是可以访问的。&lt;/p&gt;
</description>
<pubDate>Tue, 30 Jun 2020 15:39:00 +0000</pubDate>
<dc:creator>自由早晚乱余生</dc:creator>
<og:description>问题 最近我们的一台阿里云服务器 (ECS,有公网IP，Nginx 服务器，开放了80,443)，遭受到了DDOS攻击，主要攻击的行为是 攻击我们443 端口。发起大量的请求。 但是我们在 Nginx</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/operationhome/p/13216765.html</dc:identifier>
</item>
<item>
<title>高速缓存一致性协议MESI与内存屏障 - 小熊餐馆</title>
<link>http://www.cnblogs.com/xiaoxiongcanguan/p/13184801.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaoxiongcanguan/p/13184801.html</guid>
<description>&lt;p&gt;　　CPU高速缓存机制的引入，主要是为了解决CPU越来越快的运行速度与相对较慢的主存访问速度的矛盾。CPU中的寄存器数量有限，在执行内存寻址指令时，经常需要从内存中读取指令所需的数据或是将寄存器中的数据写回内存。而CPU对内存的存取相对CPU自身的速度而言过于缓慢，在内存存取的过程中CPU只能等待，机器效率太低。&lt;/p&gt;
&lt;p&gt;　　为此，设计者在CPU与内存之间引入了高速缓存。CPU中寄存器的存储容量小，访问速度极快；内存存储容量很大，但相对寄存器而言访问速度很慢。而高速缓存的存储大小和访问速度都介于二者之间，作为一个缓冲桥梁来填补寄存器与主存间访问速度过大的差异。&lt;/p&gt;
&lt;p&gt;　　引入高速缓存后，CPU在需要访问主存中某一地址空间时，高速缓存会拦截所有对于内存的访问，并判断所需数据是否已经存在于高速缓存中。如果缓存命中，则直接将高速缓存中的数据交给CPU；如果缓存未命中，则进行常规的主存访问，获取数据交给CPU的同时也将数据存入高速缓存。&lt;strong&gt;但由于高速缓存容量远小于内存，因此在高速缓存已满而又需要存入新的内存映射数据时，需要通过某种算法选出一个缓存单元调度出高速缓存，进行替换。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;由于对内存中数据的访问具有局部性，使用高速缓存能够极大的提高CPU访问存储器的效率。&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;高速缓存与内存的一致性问题&lt;/h2&gt;
&lt;p&gt;　　高速缓存在命中时，意味着内存和高速缓存中拥有了同一份数据的两份拷贝。CPU在执行修改内存数据的指令时如果高速缓存命中，只会修改高速缓存中的数据，此时便出现了高速缓存与内存中数据不一致的问题。&lt;/p&gt;
&lt;p&gt;　　这个不一致问题在早期单核CPU环境下似乎不是什么大问题，因为所有的内存操作都来自唯一的CPU。但即使是单核环境下，为了减轻CPU在I/O时的负载、提高I/O效率，先进的硬件设计都引入了DMA机制。DMA芯片在工作时会直接访问内存，如果高速缓存首先被CPU修改和内存不一致，就会出现DMA实际写回磁盘的内容和程序所需要写入的内容不一致的问题。&lt;/p&gt;
&lt;p&gt;　　为了更好的理解多核CPU环境下工作的MESI协议，这里先简单介绍单核环境下&lt;strong&gt;高速缓存被首先改写而导致cache与主存不一致问题&lt;/strong&gt;的解决方案，简单来说有两种方法：&lt;strong&gt;通写法&lt;/strong&gt;和&lt;strong&gt;回写法&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通写法（Write Through）：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;即CPU在&lt;strong&gt;对cache写入数据时，同时也直接写入主存&lt;/strong&gt;，这样就能使得主存和cache中的数据始终保存一致。&lt;/p&gt;
&lt;p&gt;　　通写法的优点是简单，硬件上容易实现，同时在调度缓存单元时不会有脏数据，调度速度快；缺点是每次cache写入操作时都增加了写主存的等待时间，效率较低。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;回写法（Write Back）：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　回写法和通写法的主要区别在于，回写法在CPU&lt;strong&gt;写cache时并不实时同步写主存，而是在进行调度被覆盖前整体的写回主存&lt;/strong&gt;。如果被调度出的cache单元并没有被写入过，则直接被覆盖无需写回主存。&lt;/p&gt;
&lt;p&gt;　　回写法的优点是写入cache时无需同步主存，总体效率比通写法高。缺点是硬件实现较为复杂。&lt;/p&gt;
&lt;h2&gt;多核CPU高速缓存间的一致性问题&lt;/h2&gt;
&lt;p&gt;　　随着单核主频速度的增长受到制约，CPU的发展由单核逐渐过度到了多核，目前主流的CPU都是多核心的。但随着多核CPU提高计算机并发性能的同时，也带来了一系列的问题，这其中就包括了&lt;strong&gt;多核CPU下的高速缓存一致性问题&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　在多核CPU的架构下，通常每一个核心都拥有着自己独有的高速缓存，每个核心能并发的读写自己的高速缓存。&lt;strong&gt;高速缓存可以有多个，但其对应的内存数据逻辑上却只有一份，多核并发的修改其高速缓存中同一内存的映射数据就会出现高速缓存中的数据不一致的问题。&lt;/strong&gt;如果不对多核CPU下的高速缓存并发访问施加一定的约束，那么并发程序中对共享内存数据的存取就会出现问题，&lt;strong&gt;并发程序的正确性将无法得到有效保障&lt;/strong&gt;。&lt;/p&gt;
&lt;h2&gt;高速缓存一致的存储系统定义&lt;/h2&gt;
&lt;p&gt;　　在讨论解决高速缓存一致性问题的方法前，我们需要更精确的定义&lt;strong&gt;什么是高速缓存一致性。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　内存系统的一个本质特征是：一个内存系统应该能提供一组保存值的存储单元，当对一个存储单元执行读操作时，应该能返回&lt;strong&gt;“最近”&lt;/strong&gt;一个对该存储单元的写操作所写入的值。在串行程序中，程序员利用内存来将程序中某一点计算出来的值，传递到该值的使用点，实际上就是利用了上述基本性质。同样，运行在单处理器上的多个进程或线程利用共享地址空间进行通信，实际上也是利用了内存系统的这个性质。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;一个读操作应返回最近的向那个位置的写操作所写的值，而不管是哪个线程写的。&lt;/strong&gt;当所有的线程运行在同一个物理处理器上时，它们通过相同的高速缓存层次来看内存，因此在这种情况下，高速缓存不会引起问题。当在共享存储的多处理器系统上运行一个具有多个线程的程序时，希望不管这些线程是运行在同一个处理器上，还是位于不同的处理器上，程序的运行结果都是相同的。&lt;/p&gt;
&lt;p&gt;　　上面摘抄自书上的概念描述有些晦涩，我个人的理解是：&lt;strong&gt;按照程序指令的运行顺序，对于同一内存单元内容(变量值)能够令后面的读操作读取到之前最近写操作后的结果，保证程序逻辑序的正确性&lt;/strong&gt;。这一顺序性的保证在单核环境下不是问题，因为所有的指令顺序都使用同一个高速缓存，但在多核多高速缓存副本的情况下运行某一程序的多个并发任务时就会出现问题，因为并没有约定多个处理器核心对同一存储单元并发操作时的&lt;strong&gt;全局顺序&lt;/strong&gt;，即&lt;strong&gt;“最近”&lt;/strong&gt;这一概念是模糊、不明确的。&lt;/p&gt;
&lt;p&gt;　　因此，一个高速缓存一致的存储系统其首先要满足的一个条件便是：&lt;strong&gt;根据一个程序的任意一次执行结果，都能够对每个内存单元的存取操作构造出逻辑上的全局串行序列（即使是多核体系下，对内存的存取逻辑上也要强制串行化）&lt;/strong&gt;。这一全局逻辑串行序列还需要满足额外的两个条件：&lt;strong&gt;一是同一处理器所发出的程序内存存取指令顺序(程序逻辑序)，与在全局逻辑串行序列中的先后顺序保持一致；二是每个读操作的值，返回的是在全局逻辑串行序列中最近的写操作之后的值。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　上述高速缓存一致性的定义隐含了在多核环境下的两个重要性质：一是&lt;strong&gt;写传播&lt;/strong&gt;，二是&lt;strong&gt;写串行化&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;写传播（Write Propagation）：&lt;/strong&gt;一个处理器对一个位置的所写入的值，最终对其它处理器是可见的。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;写串行化（Write Serialization）：&lt;/strong&gt;对同一内存单元的所有写操作（无论是来自一个处理器还是多个处理器）都能串行化。换句话说，所有的处理器能以相同的次序看到这些写操作。&lt;/p&gt;

&lt;p&gt;　　通常多核并行架构的CPU，每个核虽然都独自工作，但与外部存储器的交互依然是共用同一总线进行的。通过总线，每个核心都能够监听、接收到来自其它核心的消息通知，这一机制被称为&lt;strong&gt;总线侦听&lt;/strong&gt;或是&lt;strong&gt;总线嗅探&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基于总线侦听的写传播：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;每个核心在对自己独有的高速缓存行进行修改时，需要将修改通知送至总线进行广播。其它核心在监听到总线上来自其它核心的远程写通知时，需要查询本地高速缓存中是否存在同样内存位置的数据。如果存在，需要选择将其设置为&lt;strong&gt;失效&lt;/strong&gt;状态或是&lt;strong&gt;更新&lt;/strong&gt;为最新的值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基于总线侦听的写串行化：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　总线上任意时间只能出现一个核的一个写通知消息。&lt;strong&gt;多个核心并发的写事件会通过总线仲裁机制将其转换为串行化的写事件序列(可以简单理解为逻辑上的一个FIFO事件队列)&lt;/strong&gt;，在每个写事件广播时，必须得到每个核心对事件的响应后，才进行下一个事件的处理，这一机制被称作&lt;strong&gt;总线事务&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　而本文的主角&lt;strong&gt;MESI协议&lt;/strong&gt;便是&lt;strong&gt;基于总线侦听机制，采用回写法、写传播失效策略的高速缓存一致性协议&lt;/strong&gt;，其另一个更精确的名称是&lt;strong&gt;四态缓存写回无效协议。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;下面介绍MESI协议是如何工作以实现多核间高速缓存一致性的。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;MESI协议缓存行状态介绍&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;MESI四态缓存写回无效协议，为高速缓存中的每个存储单元行cache line赋予了一个状态属性，状态类型共有4种：&lt;strong&gt;Modified(已被修改)、Exclusive(被独占)、Shared(被共享)、Invalid(无效)，这也是MESI这一名称的由来。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　任意时刻每个缓存行都处于上述四种状态的其中一种，并且&lt;strong&gt;可能&lt;/strong&gt;会因为发生的&lt;strong&gt;缓存事件&lt;/strong&gt;而迁移至另一种状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Modified:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;缓存数据有效&lt;/strong&gt;，在读入缓存后&lt;strong&gt;曾经被当前CPU修改&lt;/strong&gt;过却没有写回，导致&lt;strong&gt;与内存中的对应数据不一致&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　内存中对应的数据&lt;strong&gt;只在本地核心的高速缓存中存在&lt;/strong&gt;，其它核的高速缓存中并没有缓存这一内存数据。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;有效，本地cache独占，与内存数据不一致(被修改 Modified)。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Exclusive:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;缓存数据有效&lt;/strong&gt;，在读入缓存后&lt;strong&gt;没有被当前CPU修改过&lt;/strong&gt;，&lt;strong&gt;与内存中的对应数据保持一致&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　内存中对应的数据&lt;strong&gt;只在本地核心的高速缓存中存在&lt;/strong&gt;，其它核的高速缓存中并没有缓存这一内存数据。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;有效，本地cache独占，与内存数据一致(被独占 &lt;strong&gt;Exclusive&lt;/strong&gt;)。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Shared:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　缓存数据有效，在读入缓存后&lt;/strong&gt;没有被当前CPU修改过，&lt;strong&gt;与内存中的对应数据保持一致&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;内存中对应的数据&lt;strong&gt;除了本地核心的高速缓存中存在，其它核的高速缓存中也缓存了这一内存数据&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;有效，与其它cache共享，与内存数据一致(被共享 Shared)。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Invalid:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　缓存数据无效。无效的含义既代表着之前缓存行有效，却因为某些事件变为无效；也代表着对应缓存行不存在。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　上述缓存行的共享/独占状态，指的是本地高速缓存中存在&lt;strong&gt;有效&lt;/strong&gt;的对应存储单元缓存行，而其它核的高速缓存中&lt;strong&gt;不存在对应单元的内容&lt;/strong&gt;或是&lt;strong&gt;对应的缓存行是Invalid无效状态。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　在MESI协议中不存在与Invalid无效可以视作是等价的&lt;/strong&gt;。&lt;/p&gt;
&lt;h3&gt;内存缓存行的稳定态与非稳定态&lt;/h3&gt;
&lt;p&gt;　　了解了MESI的四种内存缓存行状态后，下面引入缓存内存行稳定态与非稳定态的概念。缓存内存行的稳定态指的是&lt;strong&gt;多核下高速缓存中的对应内存中在所有高速缓存中数据是一致的&lt;/strong&gt;；非稳定态是稳定态的反面，指的是&lt;strong&gt;多核高速缓存中对应内存中在所有的高速缓存中数据出现了不一致，有不同的副本值&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　当处于稳定态的缓存行由于某些事件的发生转向不稳定态时，MESI协议能够采取一些措施令整个多核存储系统重新回到稳定态(可以类比自平衡二叉树在发生插入/删除事件时，引起失衡后进行的重平衡操作)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;内存&lt;/strong&gt;缓存行处于稳定态的几种情况：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　1、对应内存行在所有核的高速缓存中都不存在。&lt;/p&gt;
&lt;p&gt;　　2、对应内存行有且仅在一个核的高速缓存中存在，其状态可以是Exclusive也可以是Modified。&lt;/p&gt;
&lt;p&gt;　　3、对应内存行在一个以上核的高速缓存中存在，每个缓存行中的存储的数据都和内存一致，其状态都为Shared。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;MESI协议缓存事件&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　随着多核CPU中并发程序的不断运行，高速缓存被反复的读写，缓存内存行的状态也会在MESI这四种状态间反复变化。&lt;/p&gt;
&lt;p&gt;　　在MESI协议中，抽象出了四种会导致缓存内存行状态的变化缓存事件：&lt;strong&gt;本地读、本地写、远程读&lt;/strong&gt;以及&lt;strong&gt;远程写&lt;/strong&gt;。缓存事件针对的是某一内存缓存行的事件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本地读(Local Read):&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;本地读事件指的是本地核心对自己的缓存行进行读取。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本地写(Local Write):&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;本地写事件指的是本地核心对自己的缓存行进行写入。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;远程读(Remote Read):&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;远程读事件指的是总线上的其它核心对某一内存缓存行进行了读取，当前核心监听到的事件。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;某一个核心的本地读事件，对于其他核心就是针对其对应内存缓存行的远程读事件。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;远程写(Remote Write):&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　远程写事件指的是总线上的其它核心对某一内存缓存行进行了写入，当前核心监听到的事件。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;某一个核心的本地写事件，对于其他核心就是针对其对应内存缓存行的远程写事件。&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;MESI协议缓存行状态迁移&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;缓存事件的发生可能会使得本地/远程的对应缓存行状态发生变化。比如当原本处于独占状态的本地缓存行监听到远程读事件时，需要将其由Exclusive被独占转变为Shared被共享；当监听到远程写事件时，如果发现对应的缓存行存在(此时必定是Shared被共享状态)，此时的内存缓存行便失去了稳定，MESI协议是采取的是写无效策略，需要将本地对应的缓存行设置为Invalid无效。&lt;/p&gt;
&lt;p&gt;　　MESI协议中的四种状态在发生上述四种缓存事件时都可能发生对应的状态迁移，两两组合之后共有4*4=16种情况，下面进行详细讨论。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;本地读/写事件和其它核的远程读/写事件是互相对应的，相互之间对照能更好的理解MESI协议的工作机制。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;当前缓存行处于Invalid状态时：&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;发生local read本地读事件：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　Invalid无效的缓存行，在发生本地读事件时，必须从内存或是处于Exclusive状态的远程高速缓存中获取对应的最新数据写入本地缓存。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　1.当其它核心中都不存在对应缓存行数据时，从内存中获取。&lt;strong&gt;加载后全局有且只有本地缓存中有此缓存行记录，本地缓存行&lt;/strong&gt;的状态由Invalid变成Exclusive。&lt;/p&gt;
&lt;p&gt;　　2.当其它的某一核心中恰好也存在对应缓存行数据，且状态为Exclusive或Shared时，从内存或是存在缓存行的核心中获取。&lt;strong&gt;此时由于本地和其它核心都保存了对应缓存行数据，但不独占缓存行，本地缓存行&lt;/strong&gt;的状态由Invalid变成Shared。&lt;/p&gt;
&lt;p&gt;　　3.当其它的某一核心中恰好也存在对应缓存行数据，且状态为Modified时，触发其远程读事件，将修改过的最新值写入内存后，由本地核心从内存中读取最新的值。&lt;strong&gt;此时由于本地和之前状态为modified的核心都保存了对应缓存行数据，本地缓存行&lt;/strong&gt;的状态由Invalid变成Shared。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;发生local write本地写事件：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　Invalid无效的缓存行，在发生本地写事件时，必须从内存或是处于Exclusive状态的远程高速缓存中获取对应的最新数据写入本地缓存，再进行修改。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　1.当其它核心中都不存在对应缓存行数据时，从内存获取并修改。&lt;strong&gt;加载后全局有且只有本地缓存中有此缓存行记录，由于修改过和内存中数据不同，本地缓存行&lt;/strong&gt;的状态由Invalid变成Modified。&lt;/p&gt;
&lt;p&gt;　　2.当其它的某一核心中恰好也存在对应缓存行数据时，且状态为Exclusive或Shared时，从内存或是存在缓存行的核心中获取并修改。为了保持高速缓存一致性的稳定，远端的其它核心中的数据不能与本地核心本地写的最新数据产生冲突，远端的其它核触发远程写事件，状态都设置为Invalid(写失效协议)。&lt;strong&gt;此时全局有且只有本地缓存中有此缓存行记录，本地缓存行的状态由Invalid变成Modified。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　2.当其它的某一核心中恰好也存在对应缓存行数据时，且状态为Modified，触发其远程写事件，将修改过最新值写入内存后，由本地核心从内存中读取最新的值并修改。远端的核心(之前为modified)中的数据不能与本地核心本地写的最新数据产生冲突，状态设置为Invalid。&lt;strong&gt;此时全局有且只有本地缓存中有此缓存行记录，本地缓存行的状态由Invalid变成Modified。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;发生remote read远程读事件：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;Invalid无效状态等价于缓存行不存在，不对远程读事件进行任何处理，状态依然为Invalid。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;发生remote write远程写事件：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　I&lt;strong&gt;nvalid无效状态等价于缓存行不存在，&lt;/strong&gt;不对远程写事件进行任何处理，状态依然为Invalid。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;当前缓存行处于Exclusive状态时：&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;发生local read本地读事件：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;Exclucive代表本地核独占当前缓存行。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;本地读时直接从自己的高速缓存中获取数据即可，状态不变，依然为Exclusive。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;发生local write本地写事件：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　Exclucive代表本地核独占当前缓存行，且数据和内存中一致。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;本地写会使得缓存中的数据与内存不一致，但依然独占，状态由Exclusive变为Modified。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;发生remote read远程读事件：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;strong&gt;当监听到远程读事件时，意味着当前缓存行已经不再是独占状态，而是共享状态了，状态由Exclusive变为Shared。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;发生remote write远程写事件：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　当监听到远程写事件时，意味着当前缓存行的数据已经和本地缓存中的数据不一致了，需要废弃本地的缓存行，状态由Exclusive变为Invalid。&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;当前缓存行处于Shared状态时：&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;发生local read本地读事件：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　Shared代表本地核心和远程核心共享了缓存行，且数据是最新的。&lt;strong&gt;本地读时直接从自己的高速缓存中获取数据即可，状态不变，依然为Shared。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;发生local write本地写事件：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　本地写会触发其它核的(处于Shared状态)远程写事件，&lt;strong&gt;远程核的状态会被统一设置为无效，本地核心将独占这一缓存行。由于本地写使得缓存行数据和内存不一致，状态由Shared变为Modified&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;发生remote read远程读事件：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　当监听到远程读事件时，其并没有改变全局状态下缓存行的数据，状态不变依然为Shared。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;发生remote write远程写事件：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　当监听到远程写事件时，意味着当前缓存行的数据已经和本地缓存中的数据不一致了，需要废弃本地的缓存行，状态由Shared变为Invalid。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当前缓存行处于Modified状态时：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;发生local read本地读事件：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　Modified代表本地核心独占当前缓存行，在全局串行写序列中，本地读事件读取的依然是最新的值。本地读时直接从自己的高速缓存中获取数据即可，状态不变，依然为Modified。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;发生local write本地写事件：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　本地写时依然独占缓存行，且和内存中数据不一致，状态不变，依然为Modified。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;发生remote read远程读事件：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　当监听到远程写事件时，为了使得其获取到的值是全局串行序列中最近的值，需要先将Modified之后的最新值写回内存，令最新值对其它核心可见。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;远程读事件意味着有其它核心共享了对应的缓存行，本地不再独占，但数据依然和本地缓存中的值保持一致，状态由Modified变为Shared。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;发生remote write远程写事件：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;当监听到远程写事件时，为了使得其获取到的值是全局串行序列中最近的值，需要先将Modified之后的最新值写回内存，令最新值对其它核心可见。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;　　远程读事件意味着有其它核心共享了对应的缓存行，本地不再独占，且本地缓存的数据不再是最新的，需要令其失效，状态由Modified变为Invalid。&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　通过MESI协议，在强制串行化的总线事务帮助下能够始终保持一个全局高速缓存一致的稳定状态。&lt;/p&gt;
&lt;p&gt;　　MESI协议依赖总线侦听机制，在某个核心发生本地写事件时，为了保证全局只能有一份缓存数据，要求其它核对应的缓存行统统设置为Invalid无效状态。为了确保总线写事务的强一致性，发生本地写的高速缓存需要等到远端的所有核心都处理完对应的失效缓存行，返回Ack确认消息后才能继续执行下面的内存寻址指令(阻塞)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原始MESI协议实现时的性能问题：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　1.对于进行本地写事件的核心，远端核心处理失效并进行响应确认相对处理器自身的指令执行速度来说是相当耗时的，在等待所有核心响应的过程中令处理器空转效率并不高。&lt;/p&gt;
&lt;p&gt;　　2.对于响应远程写事件的核心，在其高速缓存压力很大时，要求实时的处理失效事件也存在一定的困难，会有一定的延迟。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;不进行优化的MESI协议在实际工作中效率会非常的低下，因此CPU的设计者在实现时对MESI协议进行了一定的改良。&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;存储缓存(Store Bufferes)&lt;/h2&gt;
&lt;p&gt;　　针对上述本地写事件需要等待远端核心ACK确认，阻塞本地处理器的问题，引入了存储缓存机制。&lt;/p&gt;
&lt;p&gt;　　存储缓存是属于每个CPU核心的。当使用了存储缓存后，每当发生本地写事件时，本地核心不再阻塞的等待远程核的确认响应，而是将写入的新值放入存储缓存中，继续执行后面的指令。存储缓存会替处理器接受远端核心的ACK确认，当对应本地写事件广播得到了全部远程核心的确认后，再提交事务，将其新值写入本地高速缓存中。存储缓存的大小是十分有限的，当堆积的事务满了之后，依然会阻塞CPU，直到有事务提交释放出新的空间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　存储缓存的引入将本地写事件---&amp;gt;等待远程写通知确认消息并提交这一事务，从同步、强一致性变成了异步、最终一致性，提高了本地写事件的处理效率。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　本地处理器在进行本地读事件时，由于可能存储缓存中新修改的数据还未提交到本地缓存中，这就会造成一个核心内，对于同一缓存行其后续指令的读操作无法读取到之前写操作的最新值。为此，在进行本地读操作时，处理器会先在存储缓存中查询对应记录是否存在，如果存在则会从存储缓存中直接获取，这一机制被称为&lt;strong&gt;Store Fowarding&lt;/strong&gt;。&lt;/p&gt;
&lt;h2&gt;失效队列(Invalid Queue)&lt;/h2&gt;
&lt;p&gt;　　针对上述远端核心响应远程写事件，实时的将对应缓存行设置为Invalid无效状态延迟高的问题，引入了失效队列机制。&lt;/p&gt;
&lt;p&gt;　　失效队列同样是属于每个CPU核心的。当使用了失效队列后，每当监听到远程写事件时，对应的高速缓存不再同步的处理失效缓存行后返回ACK确认信息，而是将失效通知存入失效队列，立即返回ACK确认消息。对于失效队列中的写失效通知，会在空闲时逐步的进行处理，将对应的高速缓存中的缓存行设置为无效。失效队列的引入在很大程度上缓解了存储缓存空间有限，容易阻塞的问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　失效队列的引入将监听到远程写事件处理失效缓存行---&amp;gt;返回ACK确认消息这一事务，从同步、强一致性变成了异步、最终一致性，提高了远程写事件的处理效率。&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;内存屏障(Memory B&lt;strong&gt;arrier&lt;/strong&gt;)&lt;/h2&gt;
&lt;p&gt;　　存储缓存和失效队列的引入在提升MESI协议实现的性能同时，也带来了一些问题。由于&lt;strong&gt;MESI的高速缓存一致性是建立在强一致性的总线串行事务上的，而存储缓存和失效队列将事务的强一致性弱化为了最终一致性，使得在一些临界点上全局的高速缓存中的数据并不是完全一致的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　对于一般的缓存数据，基于异步最终一致的缓存间数据同步不是大问题。但对于并发程序，多核高速缓存间短暂的不一致将会影响共享数据的可见性，使得并发程序的正确性无法得到可靠保证，这是十分致命的。但CPU在执行指令时，缺失了太多的上下文信息，无法识别出缓存中的内存数据是否是并发程序的共享变量，是否需要舍弃性能进行强一致性的同步。&lt;/p&gt;
&lt;p&gt;　　CPU的设计者提供了&lt;strong&gt;内存屏障&lt;/strong&gt;机制将对共享变量读写的高速缓存的强一致性控制权交给了程序的编写者或者编译器。&lt;/p&gt;
&lt;p&gt;　　内存屏障分为&lt;strong&gt;读屏障&lt;/strong&gt;和&lt;strong&gt;写屏障&lt;/strong&gt;两种，内存屏障以机器指令的形式进行工作。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;写屏障&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;　　写屏障用于保证高速缓存间写事务的强一致性。&lt;/strong&gt;当CPU执行写屏障指令时，必须强制等待存储缓存中的写事务全部处理完再继续执行后面的指令。相当于将存储缓存中异步处理的本地写事务做了强一致的同步。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;写屏障指令执行完后，当前核心位于写屏障执行前的本地写事务全部处理完毕，其它的核心都已经接收到了当前所有的远程写事件的写无效通知。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;读屏障&lt;/h3&gt;
&lt;p&gt;　　&lt;strong&gt;读屏障用于保证高速缓存间读事务的强一致性。&lt;/strong&gt;当CPU执行读屏障指令时，必须先将当前处于失效队列中的写无效事务全部处理完，再继续的执行读屏障后面的指令。相当于将异步队列中异步处理的远程写事务做了强一致的同步。　&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;读屏障指令执行完后，当前核心位于读屏障执行前的远程写无效事务全部处理完毕，对于读屏障之后的共享数据读取会得到最新的值。　&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　在进行并发程序的开发时，针对关键的任务间共享变量的读写需要使用内存屏障保证其在多核间高速缓存的一致性。在对共享变量的写入指令后，加入写屏障，令新的数据立即对其它核心可见；在对共享变量的读取指令前，加入读屏障，令其能获取最新的共享变量值。&lt;/p&gt;
&lt;p&gt;　　通过在指令中的适当位置加入读/写内存屏障，虽然一定程度上降低了效率，但保证了并发程序在多核高速缓存条件下对于共享变量的可见性，是一个很好的折中解决方案。&lt;/p&gt;

&lt;p&gt;　　由于最近在学习有关硬件和操作系统相关的知识，在看到高速缓存相关的内容时，便想把一直以来都一知半解的MESI协议弄懂。通过广泛的阅读有关博客和书籍等资料，理解并整理后写下了这篇博客，希望能帮到对MESI协议等相关内容感兴趣的人。&lt;/p&gt;
&lt;p&gt;　　MESI协议和内存屏障的知识，在其基础之上有高级语言中c、java的volatile关键字的工作原理，在其下有多核并行处理器、高速缓存、总线等硬件电路工作原理等相关的内容。在学习的过程中，一方面使我更好的理解了更上层的知识，另一方面黑盒子下还有黑盒子，令我感叹吾生也有涯，而知也无涯。但在学习的过程中，满足了对底层工作机制的好奇心，有着理解通透之后的快乐，还是挺有意思的。&lt;/p&gt;
&lt;p&gt;　　本篇博客还存在很多不足之处，请多多指教。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主要参考书籍与博客：&lt;/strong&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.baidu.com/s?ie=utf-8&amp;amp;f=8&amp;amp;rsv_bp=1&amp;amp;ch=11&amp;amp;tn=98012088_5_dg&amp;amp;wd=%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84&amp;amp;oq=%25E9%2582%25B9&amp;amp;rsv_pq=f98bd0ed00028511&amp;amp;rsv_t=57f9LygJm9jT%2F46z7d%2Fl5bg2brTTfgJLKXL8hD%2F8sfmaDFxriXUtIECpIcev5vqv4ylD%2Fg&amp;amp;rqlang=cn&amp;amp;rsv_enter=1&amp;amp;rsv_dl=tb&amp;amp;rsv_sug3=2&amp;amp;rsv_sug1=3&amp;amp;rsv_sug7=100&amp;amp;rsv_n=2&amp;amp;rsv_sug2=0&amp;amp;rsv_btype=t&amp;amp;inputT=458&amp;amp;rsv_sug4=922&quot; target=&quot;_blank&quot;&gt;《并行计算机体系结构》&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.baidu.com/s?ie=utf-8&amp;amp;f=8&amp;amp;rsv_bp=1&amp;amp;ch=11&amp;amp;tn=98012088_5_dg&amp;amp;wd=%E5%BE%AE%E5%9E%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E6%8A%80%E6%9C%AF%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%20%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%20%E9%82%B9%E9%80%A2%E5%85%B4%20&amp;amp;oq=%25E5%25B9%25B6%25E8%25A1%258C%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E4%25BD%2593%25E7%25B3%25BB%25E7%25BB%2593%25E6%259E%2584&amp;amp;rsv_pq=b49712a5000285ce&amp;amp;rsv_t=b102HYCOlpIaNHGnXWpCl71UGeFisvBLewvJXBrXppxFq2Jz2E81tLpi257tw9OolD3TBQ&amp;amp;rqlang=cn&amp;amp;rsv_enter=1&amp;amp;rsv_dl=tb&amp;amp;rsv_btype=t&amp;amp;inputT=1&amp;amp;rsv_sug3=37&amp;amp;rsv_sug2=0&amp;amp;rsv_sug4=1&quot; target=&quot;_blank&quot;&gt;《微型计算机硬件技术及应用基础 微机原理》 邹逢兴 &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/hello-shf/p/12091591.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/hello-shf/p/12091591.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/article/1152642&quot; target=&quot;_blank&quot;&gt;https://cloud.tencent.com/developer/article/1152642&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/yanlong300/p/8986041.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/yanlong300/p/8986041.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/u013546788/article/details/105829283&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/u013546788/article/details/105829283&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/0e036fa7af2a&quot; target=&quot;_blank&quot;&gt;https://www.jianshu.com/p/0e036fa7af2a&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_44936828/article/details/89430358&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/weixin_44936828/article/details/89430358&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.wowotech.net/kernel_synchronization/memory-barrier.html&quot; target=&quot;_blank&quot;&gt;http://www.wowotech.net/kernel_synchronization/memory-barrier.html&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 30 Jun 2020 15:37:00 +0000</pubDate>
<dc:creator>小熊餐馆</dc:creator>
<og:description>一、CPU高速缓存简单介绍 CPU高速缓存机制的引入，主要是为了解决CPU越来越快的运行速度与相对较慢的主存访问速度的矛盾。CPU中的寄存器数量有限，在执行内存寻址指令时，经常需要从内存中读取指令所需</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiaoxiongcanguan/p/13184801.html</dc:identifier>
</item>
</channel>
</rss>