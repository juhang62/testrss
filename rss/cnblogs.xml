<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>架构师主要做些什么，你知道吗？ - IT老兵哥</title>
<link>http://www.cnblogs.com/itlaobingge/p/12131419.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/itlaobingge/p/12131419.html</guid>
<description>&lt;blockquote readability=&quot;13&quot;&gt;

&lt;p&gt;&lt;strong&gt;小伙伴们，新年好！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;感谢大家对「&lt;span&gt;&lt;strong&gt;&lt;span&gt;IT老兵哥&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;」原创文章的支持顶赞，❤️❤️❤️！把有价值的知识或经验分享给更多人，在分享中提升个人价值，这是我写作、分享的初衷和动力，在新的一年里我会更加努力，也希望能够继续获得各位小伙伴的支持！坚持原创不易，如果文章有价值，千万要记得在手动点个「&lt;span&gt;&lt;strong&gt;推荐&lt;/strong&gt;&lt;/span&gt;」哦，^_^&lt;/p&gt;
&lt;p&gt;祝大家新年在家庭、事业和生活上都有新的进步，我们一起加油干！⛽️⛽️⛽️&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;年前我们一起聊了 &lt;a href=&quot;https://www.cnblogs.com/itlaobingge/p/11928564.html&quot; target=&quot;_blank&quot;&gt;程序员为什么要懂架构&lt;/a&gt;、&lt;a href=&quot;https://www.cnblogs.com/itlaobingge/p/12119080.html&quot; target=&quot;_blank&quot;&gt;架构是什么&lt;/a&gt; 和 &lt;a href=&quot;https://www.cnblogs.com/itlaobingge/p/12122692.html&quot; target=&quot;_blank&quot;&gt;架构都有哪些类型&lt;/a&gt; 这三个话题，今天我们来看看架构师是怎样开展工作的，他/她需要对接上下游哪些角色，以什么作为工作输入，最终要对外输出什么产物。这些内容既有助于我们跟架构岗同事更好的协作，也可以作为是否往架构转型的参考，接下来我们一起揭开架构师的神秘面纱吧！&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1. 架构设计的输入是什么？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;架构驱动因素&quot; src=&quot;http://q2zx8rp1q.bkt.clouddn.com/architecture-introductory-6.png&quot; alt=&quot;架构驱动因素&quot; width=&quot;751&quot; height=&quot;387&quot;/&gt;&lt;/p&gt;
&lt;p&gt;软件系统最终要构建成什么样，这是由项目干系人的各种要求决定的。通常，我们将这些要求归集在产品需求文档之中，这份产品需求就是架构设计的输入。我们可以将这些需求划分为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;功能需求：完成某项业务需要的功能操作，例如：共享单车客户端软件需要支持单车定位、扫码解锁等。&lt;/li&gt;
&lt;li&gt;质量需求：每项功能操作要达到什么样的质量要求，例如：易用性、可靠性、安全性、性能等等。&lt;/li&gt;
&lt;li&gt;商业需求：软件系统需要以什么样的成本、迭代速度推向市场，如何提升产品的市场竞争力等等。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2. 架构师要对接哪些角色？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这些需求源自项目干系人、商业管理、商业竞争、法律法规、技术环境、政治约束和生命周期等不同维度的诉求，架构设计就是要区分这些需求的优先级权重，然后找出相对最优的方案来平衡满足各个方面的诉求，最终基于这个架构设计方案研发出相应的软件系统推向市场，并收集市场反馈输入到下一次迭代演化当中。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;架构师干系人&quot; src=&quot;http://q2zx8rp1q.bkt.clouddn.com/architecture-introductory-8.png&quot; alt=&quot;架构师干系人&quot; width=&quot;583&quot; height=&quot;487&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因此，架构在开展工作的过程中需要对接老板、产品、项目、开发、测试、安全和运营等各种岗位角色，他们都是架构需要关注和服务的内部客户，他们的痛点就是架构工作的驱动因素。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3. 架构设计的输出&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;架构设计输出&quot; src=&quot;http://q2zx8rp1q.bkt.clouddn.com/architecture-introductory-7.png&quot; alt=&quot;架构设计输出&quot; width=&quot;577&quot; height=&quot;523&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;关键场景（Key Scenarios）&lt;/strong&gt;：分析产品需求并从中提炼出关键的业务场景，架构设计必须要通过这些关键业务场景的验证，例如：共享单车的关键业务场景包括：用户注册登录、支付账号绑定、单车租借归还等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;逻辑视图（Logical View）&lt;/strong&gt;：为了实现关键业务场景，整个软件系统从逻辑上需要划分成多少个子系统。如果关键业务场景比作一幕话剧，那么逻辑视图就是出演话剧的主要角色，它是面向最终用户，对功能需求负责。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;过程视图（Process View）&lt;/strong&gt;：过程视图是以逻辑视图为基础的，逻辑视图是系统的静态结构，过程视图是系统的动态流程。如果把关键场景比作故事剧本，逻辑视图就是角色人物，过程视图就是让这些角色人物把故事剧本演练一遍，在该视图中每个角色人物的分工定位和交互关系都会被明确下来，集成人员可以根据它来验证系统。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;开发视图（Development View）&lt;/strong&gt;：通过逻辑视图、过程视图确定了子系统的划分和职责定位，开发视图就是明确每个子系统采用什么样的技术栈来实现，包括编程语言、开发框架、分层结构、项目工程等。开发视图主要是输出给编程人员，编程人员基于此就可以开始编码实现相关的工作了，所以说架构设计就是桥接需求和实现的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;物理视图（Physical View）&lt;/strong&gt;：待构成整个系统的子系统都开发完成之后，我们需要将这些子系统部署到真实的物理环境当中，物理视图就是明确每个子系统需要什么规格的软硬件环境，分别部署到哪个网络区域，不同网络区域是否要开通防火墙，以及每个子系统需要部署多少个实例才能满足业务需求等，它主要是面向系统工程师。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img title=&quot;四种视图详解&quot; src=&quot;http://q2zx8rp1q.bkt.clouddn.com/architecture-introductory-9.png&quot; alt=&quot;四种视图详解&quot; width=&quot;619&quot; height=&quot;492&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4. 架构设计的工作流程&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一步，分析产品需求梳理出关键业务场景；&lt;/li&gt;
&lt;li&gt;第二步，基于关键场景划分子系统，输出逻辑视图；&lt;/li&gt;
&lt;li&gt;第三步，基于关键场景、逻辑视图确定业务交互流程，输出过程视图；&lt;/li&gt;
&lt;li&gt;第四步，基于逻辑视图、过程视图确定子系统技术栈，输出开发视图；&lt;/li&gt;
&lt;li&gt;第五步，基于逻辑视图、过程视图和开发视图确定部署方案，输出物理视图。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;今天暂时先分享到这里，接下来我们还要继续聊架构，敬请关注哦。坚持原创不易，如果你觉得有价值，麻烦动动手指点下文 「 &lt;span&gt;&lt;strong&gt;推荐&lt;/strong&gt;&lt;/span&gt; 」按钮，让更多小伙伴可以看到，老兵哥会更有动力坚持分享的。另外，我后续还会分享职业规划、应聘面试、技能提升、影响力打造等经验，欢迎 &lt;strong&gt;&lt;span&gt;关注&lt;/span&gt; &lt;/strong&gt;本专栏或歪信公主号 「 &lt;strong&gt;&lt;span&gt;IT老兵哥&lt;/span&gt; 」&lt;/strong&gt;！&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;关注「 IT老兵哥 」，赋能程序人生！&quot; src=&quot;http://q2zx8rp1q.bkt.clouddn.com/itlaobingge-weixin-mp.jpeg&quot; alt=&quot;微信公众号「 IT老兵哥 」&quot; width=&quot;674&quot; height=&quot;288&quot;/&gt;&lt;/p&gt;
&lt;p&gt;关注「&lt;span&gt; &lt;strong&gt;IT老兵哥&lt;/strong&gt;&lt;/span&gt; 」，赋能程序人生！&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;软技能-热门文章：（首发公众号）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;2020 来了，你的 2019 晒好封存了吗？&lt;/li&gt;
&lt;li&gt;“花式”裁员套路深，你知道吗？&lt;/li&gt;
&lt;li&gt;遭遇裁员，如何渡过心理危机？&lt;/li&gt;
&lt;li&gt;如何在寒冬中找到好工作？&lt;/li&gt;
&lt;li&gt;2C 还是 2B，跟找工作有什么关系？&lt;/li&gt;
&lt;li&gt;大公司 vs 小公司，你会选哪个？&lt;/li&gt;
&lt;li&gt;记住这一点，不怕找不到好工作！&lt;/li&gt;
&lt;li&gt;跳槽，跳还是不跳，该怎么跳？&lt;/li&gt;
&lt;li&gt;程序员“求包养”攻略揭秘&lt;/li&gt;
&lt;li&gt;很努力了，为什么我还在原地踏步？&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;硬技能-热门文章：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/itlaobingge/p/11928564.html&quot; target=&quot;_blank&quot;&gt;程序员必须懂的架构入门课 1 2 3&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/itlaobingge/p/12119080.html&quot;&gt;架构到底是什么？来听程序老兵怎么说！&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/itlaobingge/p/12122692.html&quot;&gt;架构竟然有这么多种，那我该怎么选呢？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/itlaobingge/p/12089657.html&quot;&gt;如何设计出优美的Web API？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/itlaobingge/p/12105722.html&quot; target=&quot;_blank&quot;&gt;程序员必须掌握的性能调优 X Y Z&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/itlaobingge/p/12095774.html&quot; target=&quot;_blank&quot;&gt;如何把单体式应用拆解成微服务？【上】&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/itlaobingge/p/12100154.html&quot; target=&quot;_blank&quot;&gt;如何把单体式应用拆解成微服务？【下】&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/itlaobingge/p/11962255.html&quot;&gt;图解 Spring：HTTP 请求的处理流程与机制【1】&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/itlaobingge/p/11963286.html&quot;&gt;图解 Spring：HTTP 请求的处理流程与机制【2】&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/itlaobingge/p/11963311.html&quot;&gt;图解 Spring：HTTP 请求的处理流程与机制【3】&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p class=&quot;_mce_tagged_br&quot;&gt; &lt;/p&gt;
</description>
<pubDate>Thu, 02 Jan 2020 00:46:00 +0000</pubDate>
<dc:creator>IT老兵哥</dc:creator>
<og:description>年前我们一起聊了 程序员为什么要懂架构、架构是什么 和 架构都有哪些类型 这三个话题，今天我们来看看架构师是怎样开展工作的，他/她需要对接上下游哪些角色，以什么作为工作输入，最终要对外输出什么产物。这</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/itlaobingge/p/12131419.html</dc:identifier>
</item>
<item>
<title>编程语言排名到底是哪来的？ - 极客挖掘机</title>
<link>http://www.cnblogs.com/babycomeon/p/12131415.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/babycomeon/p/12131415.html</guid>
<description>&lt;p&gt;又是周末，这应该是 2019 年度最后一个周末了，各位同学周末快乐。&lt;/p&gt;
&lt;p&gt;PS：小编没断更~~~~&lt;/p&gt;
&lt;p&gt;一到年终，总归会有各种各样的排名，和编程相关度比较大的莫过于编程语言排名。&lt;/p&gt;
&lt;p&gt;好像我们在网络上经常会见到编程语言排名，那么这个排名到底是从哪里来的？&lt;/p&gt;
&lt;p&gt;神秘的面纱就要揭晓了，这个排名来自于： TIOBE 。&lt;/p&gt;
&lt;p&gt;它的官网的地址是：&lt;a href=&quot;https://www.tiobe.com/tiobe-index/&quot; class=&quot;uri&quot;&gt;https://www.tiobe.com/tiobe-index/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;接着小编要证实一个可能会挨打的问题，PHP 到底是不是全球最好的语言？&lt;/p&gt;
&lt;p&gt;我们用 TIOBE 排行榜来说话：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/202001/908359-20200102084251135-343068085.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图是从 2002 年至 2019 年的前十大编程语言的排名情况。&lt;/p&gt;
&lt;p&gt;可以明显的看到，自从 2010 年前后， PHP 的排名呈现一个总体下降的趋势，并且在历史上从来没有成为过第一。在 2010 之前，最巅峰的时期也不过第 3 、4 名的样子。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/202001/908359-20200102084251645-1741058822.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们找到了编程语言排行的来源，那么，TIOBE 这又是一家什么样的公司呢？&lt;/p&gt;
&lt;p&gt;TIOBE 公司成立于 2000年10月1日，由瑞士的公司 Synspace 和一些独立的投资人创建。TIOBE是&quot;The Importance Of Being Earnest&quot;的缩写，该公司主要关注于软件质量的评估。&lt;/p&gt;
&lt;p&gt;TIOBE 程序设计语言指数是由该公司推出并进行维护的，这个指数将程序设计语言以排名列表的形式提供出来，并且每个月更新一次，用来表示程序设计语言的流行度。&lt;/p&gt;
&lt;p&gt;TIOBE 排行榜是根据互联网上有经验的程序员、课程和第三方厂商的数量，并使用搜索引擎（如Google、Bing、Yahoo!）以及 Wikipedia、Amazon、YouTube 统计出排名数据，只是反映某个编程语言的热门程度，并不能说明一门编程语言好不好，或者一门语言所编写的代码数量多少。&lt;/p&gt;
&lt;p&gt;该指数可以用来检阅开发者的编程技能能否跟上趋势，或是否有必要作出战略改变，以及什么编程语言是应该及时掌握的。观察认为，该指数反应的虽并非当前最流行或应用最广的语言，但对世界范围内开发语言的走势仍具有重要参考意义。&lt;/p&gt;
&lt;p&gt;下图为 TIOBE 12 月最新编程语言前20名：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/202001/908359-20200102084252194-859588275.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么 TIOBE 是如何来给这些编程语言进行排名的呢？难道是做抽样调查？站在张江或者中关村的大街上，逢人便问：小哥哥（小姐姐），你最喜欢的编程语言是什么？&lt;/p&gt;
&lt;p&gt;明显很不靠谱嘛~~~&lt;/p&gt;
&lt;p&gt;TIOBE 采用的方式是统计编程语言在主流搜索引擎上被搜索的次数来计算的。&lt;/p&gt;
&lt;p&gt;简单来讲就是看看哪些编程语言被搜索了多少次，用搜索的次数来进行排名。&lt;/p&gt;
&lt;p&gt;TIOBE 对需要统计的主流搜索引擎也是有定义的，如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;该站点的入口页面包含搜索工具&lt;/li&gt;
&lt;li&gt;查询站点的结果包含页面点击数的指示&lt;/li&gt;
&lt;li&gt;结果应该在带有清晰标签的HTML中可用&lt;/li&gt;
&lt;li&gt;具有特殊字符的语言的搜索引擎应正确编码&lt;/li&gt;
&lt;li&gt;搜索引擎应至少返回1个查询的1个匹配项&lt;/li&gt;
&lt;li&gt;查询网站的结果不应包含太多异常值&lt;/li&gt;
&lt;li&gt;色情网站被排除在外&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;而 TIOBE 所选择的搜索引擎是在满足以上条件下还要是在 Alexa 排名最高前 25 个，具体如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Google.com: 7.69%&lt;/li&gt;
&lt;li&gt;Baidu.com: 7.38%&lt;/li&gt;
&lt;li&gt;Wikipedia.org: 7.08%&lt;/li&gt;
&lt;li&gt;Yahoo.com: 6.77%&lt;/li&gt;
&lt;li&gt;Csdn.net: 6.46%&lt;/li&gt;
&lt;li&gt;Bing.com: 6.15%&lt;/li&gt;
&lt;li&gt;Google.com.hk: 5.85%&lt;/li&gt;
&lt;li&gt;Ebay.com: 5.54%&lt;/li&gt;
&lt;li&gt;Google.co.in: 5.23%&lt;/li&gt;
&lt;li&gt;Msn.com: 4.92%&lt;/li&gt;
&lt;li&gt;Amazon.in: 4.62%&lt;/li&gt;
&lt;li&gt;Hao123.com: 4.31%&lt;/li&gt;
&lt;li&gt;Google.com.br: 4.00%&lt;/li&gt;
&lt;li&gt;Google.co.jp: 3.69%&lt;/li&gt;
&lt;li&gt;Google.de: 3.38%&lt;/li&gt;
&lt;li&gt;Amazon.co.uk: 3.08%&lt;/li&gt;
&lt;li&gt;Google.ru: 2.77%&lt;/li&gt;
&lt;li&gt;Indeed.com: 2.46%&lt;/li&gt;
&lt;li&gt;Google.fr: 2.15%&lt;/li&gt;
&lt;li&gt;Google.it: 1.85%&lt;/li&gt;
&lt;li&gt;Google.es: 1.54%&lt;/li&gt;
&lt;li&gt;Google.com.tw: 1.23%&lt;/li&gt;
&lt;li&gt;Freepik.com: 0.92%&lt;/li&gt;
&lt;li&gt;Google.com.sg: 0.62%&lt;/li&gt;
&lt;li&gt;Google.com.mx: 0.31%&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;具体编程语言的指数计算公式小编就简单列举一下，有兴趣的同学可以研究下：&lt;/p&gt;
&lt;p&gt;如果用 &quot;hits(PL#i,SE)&quot;表示编程语言 PL 在搜索引擎 SE 上的指数排名为 i 的搜索次数，n 表示搜索引擎个数，则 PL 在前 50 名编程语言中排名评估的计算公式为：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;((hits(PL,SE1)/hits(SE1) + ... + hits(PL,SEn)/hits(SEn))/n&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;排名的机构有了，排名的算法有了，那么还剩一个问题，什么样的语言才能够称得上是编程语言？&lt;/p&gt;
&lt;p&gt;TIOBE 指数选择编程语言的时候有 3 个要求：&lt;/p&gt;
&lt;p&gt;非常相似的编程语言被分组在一起。当前，在计算分组的等级时会考虑单个语言的最大点击量。 TIOBE 根据以下规则对分组语言的定义进行了分组化：&lt;/p&gt;
&lt;p&gt;除了上面介绍一些指数， TIOBE 每年还会评选出一门年度编程语言，用来表示在过去的一年中，上升的最快的编程语言，下面是一些历年的数据，今年的年度编程语言目前还不清楚：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/202001/908359-20200102084252671-211550923.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不过 TIOBE 能反映的只是一个编程语言的流行程度，和这个编程语言的好坏从根本上讲是毫无关系的。&lt;/p&gt;
&lt;p&gt;当然，关注 TIOBE 编程语言排行榜也是具有一定指导意义的，毕竟做为编程领域内唯一具有权威性的排行榜，对我们选择编程语言时起到一个参考作用，毕竟谁也不想学一个没有市场的编程语言。&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.tiobe.com/tiobe-index/&quot; class=&quot;uri&quot;&gt;https://www.tiobe.com/tiobe-index/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/ityouknow/p/12096366.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/ityouknow/p/12096366.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.tiobe.com/company/about/&quot; class=&quot;uri&quot;&gt;https://www.tiobe.com/company/about/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.tiobe.com/tiobe-index/programming-languages-definition/&quot; class=&quot;uri&quot;&gt;https://www.tiobe.com/tiobe-index/programming-languages-definition/&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 02 Jan 2020 00:43:00 +0000</pubDate>
<dc:creator>极客挖掘机</dc:creator>
<og:description>又是周末，这应该是 2019 年度最后一个周末了，各位同学周末快乐。 PS：小编没断更~~~~ 一到年终，总归会有各种各样的排名，和编程相关度比较大的莫过于编程语言排名。 好像我们在网络上经常会见到编</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/babycomeon/p/12131415.html</dc:identifier>
</item>
<item>
<title>TypeScript躬行记（8）——装饰器 - 咖啡机（K.F.J）</title>
<link>http://www.cnblogs.com/strick/p/11792566.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/strick/p/11792566.html</guid>
<description>&lt;p&gt;　　装饰器（Decorator）可声明在类及其成员（例如属性、方法等）之上，为它们提供一种标注，用于分离复杂逻辑或附加额外逻辑，其语法形式为@expression。expression是一个会在运行时被调用的函数，它的参数是被装饰的声明信息。假设有一个@sealed装饰器，那么可以像下面这样定义sealed()函数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; sealed(target) {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　有两种方式可以开启装饰器，第一种是在输入命令时添加--experimentalDecorators参数，如下所示，其中--target参数不能省略，它的值为“ES5”。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
tsc &lt;span&gt;default&lt;/span&gt;.ts --target ES5 --experimentalDecorators
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　第二种是在tsconfig.json配置文件中添加experimentalDecorators属性，如下所示，对应的target属性也不能省略。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  compilerOptions: {
    target: &lt;/span&gt;&quot;ES5&quot;&lt;span&gt;,
    experimentalDecorators: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　类装饰器用于监听、修改或替换类的构造函数，并将其作为类装饰器唯一可接收的参数。当装饰器返回undefined时，延用原来的构造函数；而当装饰器有返回值时，会用它来覆盖原来的构造函数。下面的示例会通过类装饰器封闭类的构造函数和原型，其中@sealed声明在类之前。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@sealed
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person {
  name: &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;;
  constructor(name: &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
  }
}
function &lt;/span&gt;&lt;span&gt;sealed&lt;/span&gt;&lt;span&gt;(constructor: Function) {
  Object.seal(constructor);
  Object.seal(constructor.prototype);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在经过TypeScript编译后，将会生成一个__decorated()函数，并应用到Person类上，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; Person = &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;* @class &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt; (&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
  &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Person(name) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
  }
  Person &lt;/span&gt;=&lt;span&gt; __decorate([sealed], Person);
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Person;
})();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　注意，类装饰器不能出现在.d.ts声明文件和外部类之中。&lt;/p&gt;

&lt;p&gt;　　方法装饰器声明在类的方法之前，作用于方法的属性描述符，比类装饰器还多一个重载限制。它能接收三个参数，如下所列：&lt;/p&gt;
&lt;p&gt;　　（1）对于静态成员来说是类的构造函数，而对于实例成员则是类的原型对象。&lt;/p&gt;
&lt;p&gt;　　（2）成员的名字，一个字符串或符号。&lt;/p&gt;
&lt;p&gt;　　（3）成员的属性描述符，当输出版本低于ES5时，该值将会是undefined。&lt;/p&gt;
&lt;p&gt;　　当方法装饰器返回一个值时，会覆盖当前方法的属性描述符。下面是一个简单的例子，方法装饰器的第一个参数是Person.prototype，第二个是“cover”，调用getName()方法得到的将是“freedom”，而不是原先的“strick”。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person {
  @cover
  getName(name) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
  }
}
function cover(target: any, key: &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;, descriptor: PropertyDescriptor) {
  descriptor.value &lt;/span&gt;=&lt;span&gt; function() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;freedom&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
  };
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; descriptor;
}
let person &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Person();
person.getName(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;strick&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;&quot;freedom&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　访问器装饰器声明在类的访问器属性之前，作用于相应的属性描述符，其限制与类装饰器相同，而接收的三个参数与方法装饰器相同。并且还需要注意一点，TypeScript不允许同时装饰一个成员的get和set访问器，只能应用在第一个访问器上。&lt;/p&gt;
&lt;p&gt;　　以下面的Person类为例，定义了一个访问器属性name，当访问它时，得到的将是“freedom”，而不是原先的“strick”。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person {
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; _name: &lt;span&gt;string&lt;/span&gt;&lt;span&gt;;
  @access
  &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt; name() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;._name;
  }
  &lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt; name(name) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._name =&lt;span&gt; name;
  }
}
function access(target: any, key: &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;, descriptor: PropertyDescriptor) {
  descriptor.&lt;/span&gt;&lt;span&gt;get&lt;/span&gt; =&lt;span&gt; function() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;freedom&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
  };
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; descriptor;
}
let person &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Person();
person.name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;strick&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
console.log(person.name);        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;&quot;freedom&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　属性装饰器声明在属性之前，其限制与访问器装饰器相同，但只能接收两个参数，不存在第三个属性描述符参数，并且没有返回值。仍然以下面的Person类为例，定义一个name属性，并且在@property装饰器中修改其值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person {
  @property
  name: &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;;
}
function property(target: any, key: &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;) {
  Object.defineProperty(target, key, {
    value: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;freedom&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  });
}
let person &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Person();
person.name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;strick&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
console.log(person.name);        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;&quot;freedom&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　参数装饰器声明在参数之前，它没有返回值，其限制与方法装饰器相同，并且也能接收三个参数，但第三个参数表示装饰的参数在函数的参数列表中所处的位置（即索引）。下面用一个例子来演示参数装饰器的用法，需要与方法装饰器配合。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
let &lt;span&gt;params&lt;/span&gt; =&lt;span&gt; [];
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person {
  @func
  getName(@required name) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在@func中调用getName()方法，并向其传入params数组中的值，@required用于修改指定位置的参数的值，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; func(target: any, key: string, descriptor: PropertyDescriptor) {
  const method &lt;/span&gt;=&lt;span&gt; descriptor.value;
  descriptor.value &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; method.apply(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, params);
  };
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; descriptor;
}
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; required(target: any, key: string, index: number) {
  params[index] &lt;/span&gt;= &quot;freedom&quot;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　当实例化Person类，调用getName()方法，得到的将是“freedom”。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
let person = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Person();
person.getName(&lt;/span&gt;&quot;strick&quot;);        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;&quot;freedom&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　装饰器工厂是一个能接收任意个参数的函数，用来包裹装饰器，使其更易使用，它能返回上述任意一种装饰器函数。接下来改造方法装饰器一节中的cover()函数，接收一个字符串类型的value参数，返回一个方法装饰器函数，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; cover(value: string) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(target: any, key: string, descriptor: PropertyDescriptor) {
    descriptor.value &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; value;
    };
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; descriptor;
  };
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在将@cover作用于类中的方法时，需要传入一个字符串，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person {
  @cover(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;freedom&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
  getName(name) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　将多个装饰器应用到同一个声明上时，既可以写成一行，也可以写成多行，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;***** 一行 *****&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@first @second desc
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;***** 多行 *****&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@first 
@second
desc&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这些装饰器的求值方式与复合函数类似，先由上至下依次执行装饰器，再将求值结果作为函数，由下至上依次调用。例如定义两个装饰器工厂函数，如下代码所示，在函数体和返回的装饰器中都会打印一个数字。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; first() {
  console.log(&lt;/span&gt;1&lt;span&gt;);
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(target: any, key: string, descriptor: PropertyDescriptor) {
    console.log(&lt;/span&gt;2&lt;span&gt;);
  };
}
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; second() {
  console.log(&lt;/span&gt;3&lt;span&gt;);
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(target: any, key: string, descriptor: PropertyDescriptor) {
    console.log(&lt;/span&gt;4&lt;span&gt;);
  };
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　将它们先后声明到类中的同一个方法，如下代码所示。根据求值顺序可知，先打印出1和3，再打印出4和2。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person {
  @first()
  @second()
  getName(name) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Thu, 02 Jan 2020 00:38:00 +0000</pubDate>
<dc:creator>咖啡机（K.F.J）</dc:creator>
<og:description>装饰器（Decorator）可声明在类及其成员（例如属性、方法等）之上，为它们提供一种标注，用于分离复杂逻辑或附加额外逻辑，其语法形式为@expression。expression是一个会在运行时被调</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/strick/p/11792566.html</dc:identifier>
</item>
<item>
<title>一份让你效率翻倍的年终总结  - Vi的技术博客</title>
<link>http://www.cnblogs.com/viyoung/p/12131335.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/viyoung/p/12131335.html</guid>
<description>&lt;h3 id=&quot;回顾-2019&quot;&gt;回顾 2019&lt;/h3&gt;
&lt;p&gt;韶光易逝，岁月难追，一转眼 2019 就匆匆的画下了句号。&lt;/p&gt;
&lt;p&gt;上半年在北京上海来回中来回漂泊度过，见过凌晨六点的北京，也见过午夜一点的上海，不止一次的一日辗转两千公里，早上五点从家出发去机场，晚上十二点到达高铁站然后打车回家。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;匆匆的从魔都赶回家，差点没有赶上高铁，幸好遇到了老司机&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://viyoungblog.oss-cn-beijing.aliyuncs.com/viyoung/2019-12-27-101640.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;出差仍然不忘记在酒店熬夜写文&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://viyoungblog.oss-cn-beijing.aliyuncs.com/viyoung/2019-12-27-101805.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;从前东家离职后发出的感慨，庆幸历尽山河，仍觉人间值得。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://viyoungblog.oss-cn-beijing.aliyuncs.com/viyoung/2019-12-27-101914.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;下半年的第一天离开了家乡，来到了广东。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://viyoungblog.oss-cn-beijing.aliyuncs.com/viyoung/2019-12-27-102007.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;今年是认知提升的一年，离开了一个熟悉的地方，注定会带来一些全新的体验，技术栈获得了一些更新，比如，Skywalking，云原生，vert.x，收获良多，这些我都会在博客中一一去写出来给大家伙分享。&lt;/p&gt;
&lt;p&gt;但是我觉得今年给我带来的最大改变并非技术上的某项具体的技能，而是一个&lt;strong&gt;不仅程序员可以用到&lt;/strong&gt;，其他职业都可以用到的一项使自己 work life balance 的技能——&lt;strong&gt;GTD&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;也许你知道怎么改变世界，却不知道一个下雨的下午该做些什么？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;程序员-gtd-的道与术&quot;&gt;程序员 GTD 的道与术&lt;/h3&gt;
&lt;p&gt;说来惭愧，下半年的重心基本上都集中到了这个上面，《搞定（一）》，《搞定（二）》，《搞定（三）》阅读了三遍以上，以及参考了网上一些 GTD 的资料，加上自己的不断实践和改善，配合着一些现代化的工具总算是摸索出一套自己的使用模式。虽然消耗了大量的精力和时间，但是我觉得对于我未来的改变是十分巨大的。&lt;/p&gt;
&lt;h4 id=&quot;工具准备非广告&quot;&gt;工具准备（非广告）&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;滴答清单&lt;/li&gt;
&lt;li&gt;印象笔记（有道云笔记，Onenote也可）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;为什么会选择这两个工具呢，原因比较简单，在设备的兼容性和同步上来说，这两个软件是我用过的软件中做的最好的两个了~&lt;/p&gt;
&lt;h4 id=&quot;概念了解&quot;&gt;概念了解&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;GTD：GTD 这个名称于《搞定》一书的原名简写《Get Things Done》，它确切的来说是一种&lt;strong&gt;行为管理&lt;/strong&gt;的方法&lt;/li&gt;
&lt;li&gt;GTD 的原理简述：大脑是用来&lt;strong&gt;思考如何做事情&lt;/strong&gt;的，不是用来&lt;strong&gt;记事情&lt;/strong&gt;的，脑容量是有限的，人的精力也是有限的，记得太多，就会做的太少。所以我们需要塑造一个第二大脑去帮助我们去记住我们需要做的事情，我们要做的是去&lt;strong&gt;完全相信&lt;/strong&gt;我们的第二大脑，然后找出一个事情，并完成它（Get Things Done）。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;collect收集&quot;&gt;Collect（收集）&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://viyoungblog.oss-cn-beijing.aliyuncs.com/viyoung/2019-12-29-035814.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;GTD 的第一步是收集我们所有杂乱的现实事务和盘旋在我们脑海中的想法到 Inbox，作为游戏玩家，我更喜欢称之为「仓库」，遇到的所有的事情都集中到这个「仓库」中来。&lt;/p&gt;
&lt;p&gt;这一步的关键是：一定要&lt;strong&gt;清空！清空！清空！&lt;/strong&gt;，&lt;strong&gt;你必须完全相信你的系统，它才会有价值&lt;/strong&gt;（记住这句话，后面会经常出现）&lt;/p&gt;
&lt;p&gt;作为一个程序员，我是怎么做的呢？&lt;/p&gt;
&lt;ol readability=&quot;2&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;收拾办公桌上的无用的东西（虽然一般情况下，桌面上没有什么无用的东西），然后把抽屉中的统统拿出来，放到一个大盒子中（某宝上很多，也很便宜），我一般用的是租的公寓里面给的一个放衣服的篓子，把东西一股脑的丢进去的感觉真的很爽，试过一次你就会爱上这个感觉~（看过《断舍离》应该不会陌生这一块儿）&lt;br/&gt;&lt;img src=&quot;http://viyoungblog.oss-cn-beijing.aliyuncs.com/viyoung/2019-12-28-013808.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://viyoungblog.oss-cn-beijing.aliyuncs.com/viyoung/2019-12-29-040404.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;现实世界的收拾干净以后，下面就是虚拟世界的了，作为程序员，我一般会去&lt;strong&gt;禅道/jira，邮箱，Confluence/Git，钉钉，微信，短信&lt;/strong&gt;等通信协同工具中去收集一些未完成的事项，然后顺手把电脑和手机上不经常用的软件删掉，存在价值的东西就把位置记录好，写入到&lt;strong&gt;滴答清单中的收集箱&lt;/strong&gt;(不能改名字，可恶！&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;http://viyoungblog.oss-cn-beijing.aliyuncs.com/viyoung/2019-12-28-020406.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://viyoungblog.oss-cn-beijing.aliyuncs.com/viyoung/2019-12-29-040609.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里要表扬一下&lt;strong&gt;滴答清单&lt;/strong&gt;的收集的便利性，简洁的 UI和一些很走心的小功能，比如 Siri 快速添加任务，自动识别输入的日期，重复任务可以选择农历（这个用来记录亲人的生日真的超赞）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://viyoungblog.oss-cn-beijing.aliyuncs.com/viyoung/2019-12-28-020710.png&quot;/&gt;&lt;/p&gt;
&lt;ol readability=&quot;5.5&quot;&gt;&lt;li readability=&quot;14&quot;&gt;
&lt;p&gt;第三步是清理大脑中的一些事情，我一般会制作一个提醒清单作为滴答清单的目录项，每次收集的时候都会按照这个去捋一遍，这里我是把日常事务分成了四种：&lt;strong&gt;工作&lt;/strong&gt;，&lt;strong&gt;生活&lt;/strong&gt;，&lt;strong&gt;个人&lt;/strong&gt;，&lt;strong&gt;技术&lt;/strong&gt;（这里由于保持对技术的热爱，把技术单独分出了一类，用来整理自己的不足和要学习的技术）&lt;/p&gt;
&lt;p&gt;工作：我分成了&lt;strong&gt;业务需求，技术研究，项目管理，其他&lt;/strong&gt;四个类别&lt;/p&gt;
&lt;p&gt;生活：我分为了&lt;strong&gt;娱乐，健身，日常，旅行，家庭，假期&lt;/strong&gt;五个类别&lt;/p&gt;
&lt;p&gt;技术：这个的话就不再细聊了，这个针对性比较强 ~ 每个人都会有自己的理解&lt;/p&gt;
&lt;p&gt;个人：主要分为了&lt;strong&gt;学历，博客，英语，认知&lt;/strong&gt;四个类别~&lt;/p&gt;
&lt;p&gt;我通过对这些类别下的东西进行回想和收集到&lt;strong&gt;滴答清单&lt;/strong&gt;，可以让自己的大脑保持一个空空如也的状态。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://viyoungblog.oss-cn-beijing.aliyuncs.com/viyoung/2019-12-29-040706.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;http://viyoungblog.oss-cn-beijing.aliyuncs.com/viyoung/2020-01-01-095500.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第一步收集到「仓库」的步骤到这里就告一段落了，切记以下几点建议：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;一定不要觉得事情小，就把这件事情放到脑子里面，&lt;strong&gt;你 必须 完全 相信 你的 第二大脑&lt;/strong&gt;（请一字一句的读这句话三遍！！！），做一件事情之前不要去你的大脑中去找，而是要去你的第二大脑中去找。&lt;/li&gt;
&lt;li&gt;不要在收集的时候尝试去完成这些事情，这是&lt;strong&gt;血的教训！！！&lt;/strong&gt;如果你在收集的时候尝试去完成这些事情，你一定会慢慢的偏离原有的方向，打乱收集的节奏是&lt;strong&gt;非常致命的！！！&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;http://viyoungblog.oss-cn-beijing.aliyuncs.com/viyoung/2019-12-28-033905.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;process明确意义&quot;&gt;Process（明确意义）&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://viyoungblog.oss-cn-beijing.aliyuncs.com/viyoung/2019-12-29-035845.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第二步 GTD 通常被叫做&lt;strong&gt;处理&lt;/strong&gt;，我更喜欢叫这一步为：「问自己」，当我们看到「仓库」中密密麻麻的材料的时候，肯定觉得头皮发麻，发麻很简单，快刀斩乱麻！&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一步很简单，问自己第一个问题：&lt;strong&gt;这是什么？对我有什么意义？&lt;/strong&gt;这里需要有一个&lt;strong&gt;思考&lt;/strong&gt;的过程，要去思考这件事对于我们的&lt;strong&gt;意义&lt;/strong&gt;，然后把意义写到我们的这一步是你能否真的去相信你的 GTD 系统的关键。那么该如何去思考呢？问自己下面四个问题：
&lt;ul&gt;&lt;li&gt;我希望的结果是什么？&lt;/li&gt;
&lt;li&gt;我决心实现完成它吗？&lt;/li&gt;
&lt;li&gt;下一步该怎么做？&lt;/li&gt;
&lt;li&gt;为了向这个目标迈进，接下来我要做哪些事？&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;第二个问题：&lt;strong&gt;可以采取行动吗？&lt;/strong&gt;这里的可以采取行动是指这个待办事项是不是一个动词，还是说像资料那样是一个名词。
&lt;ul&gt;&lt;li&gt;答案为 no ，问自己第二个问题：&lt;strong&gt;是不是垃圾？&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;答案为 no，直接删除，或者丢掉垃圾箱&lt;/li&gt;
&lt;li&gt;答案为 yes，问自己第三个问题：&lt;strong&gt;是不是电子版？&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;答案为否，放到书架或者一个自己可以方便取放查阅的地方&lt;/li&gt;
&lt;li&gt;答案为是，放到&lt;strong&gt;印象笔记&lt;/strong&gt;，（如果是电子书也可以直接上传附件哟）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;答案为 yes，再问自己第四个问题：&lt;strong&gt;是否现在采取行动？采取什么样的行动？&lt;/strong&gt;这里需要注意，关键词是现在，一定要把握&lt;strong&gt;现在&lt;/strong&gt;这两个字
&lt;ul&gt;&lt;li&gt;答案为 no，可以把这些事项放到一个叫做&lt;strong&gt;印象笔记——愿望清单&lt;/strong&gt;的地方中去，比如想去的城市，想买的东西，想做的事情，想看的书，想学的技能等等&lt;/li&gt;
&lt;li&gt;答案为 yes，到这里，你&lt;strong&gt;可以确定&lt;/strong&gt;你现阶段（一般是指最近一周）需要做的事情有这么多，现在你需要问自己问自己下一个问题：&lt;strong&gt;是否由自己完成？&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;答案为 no，放到一个&lt;strong&gt;印象笔记——等待回复清单&lt;/strong&gt;中去即可&lt;/li&gt;
&lt;li&gt;答案为 yes，如果是自己完成的话，进行判断，是否可以一步完成，这里的一步是指一个动作，比如：&lt;strong&gt;打开网页搜索广州志愿者相关信息&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;如果不能一步完成，放到&lt;strong&gt;印象笔记——项目清单&lt;/strong&gt;中去&lt;/li&gt;
&lt;li&gt;如果&lt;strong&gt;可以一步完成且两分钟内可以完成，就立即去完成它&lt;/strong&gt;，如果不能，就放到&lt;strong&gt;印象笔记——下一步清单&lt;/strong&gt;中去。这里我特别推荐两分钟内可以完成的事情，就立马去完成它，因为你的很多事情都是可以在两分钟内完成的。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://viyoungblog.oss-cn-beijing.aliyuncs.com/viyoung/2019-12-29-135551.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到这里，我们的第二步就算是告一段落了，我们「仓库」中的材料经过我们的处理分别进入了印象笔记中的几个笔记中去：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;项目清单&lt;/li&gt;
&lt;li&gt;callback（等待回复清单）&lt;/li&gt;
&lt;li&gt;材料库（印象笔记和随时可以查阅的存放资料的地方）&lt;/li&gt;
&lt;li&gt;愿望清单&lt;/li&gt;
&lt;li&gt;下一步行动清单&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;第二步有几个需要注意的点：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;不要尝试去在&lt;strong&gt;问自己的同时去完成那些两分钟之内无法完成的事情&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;回答问题的时候一定要对自己诚实，诚于心，诚于己。&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;organize组织整理&quot;&gt;Organize（组织整理）&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://viyoungblog.oss-cn-beijing.aliyuncs.com/viyoung/2019-12-29-035926.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;经过第二步的几个问题之后，我们的待办事项被分类到几个清单之中，但是如果想让我们的系统起到一个良好的作用，仅仅做到第二步是远远不够的，接下来我们就需要对刚刚分类到清单中的事项进行进一步的处理，使之可以变为可执行的，具体明确的行动。&lt;/p&gt;
&lt;ol readability=&quot;15.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;首先，我们需要对下一步行动清单进行进一步的划分，如果我们承诺了在某个时间点之前或者某段时间之内要完成某件事情，那么我们需要把它加入到我们的&lt;strong&gt;印象笔记——日程表&lt;/strong&gt;中，这里还请注意，日程表是神圣的，不能随意添加的，&lt;strong&gt;如果添加到日程表中，我们就一定要去完成这件事情&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;然后，我们在这一步要对我们的项目清单中的项目进行挨个的项目规划（这个也许会耗费你很久的时间，但是请保持足够的耐心），找出每个项目的下一步行动，放到&lt;strong&gt;印象笔记——下一步清单&lt;/strong&gt;中去。&lt;/p&gt;
&lt;p&gt;那么在这里如何去制定一个项目计划？答案就是&lt;strong&gt;自然规划法&lt;/strong&gt;&lt;/p&gt;
&lt;ol readability=&quot;9&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;定义目标和原则&lt;/p&gt;
&lt;p&gt;做一件事情，一定要知道，&lt;strong&gt;我为什么要去做这件事情&lt;/strong&gt;，这件事情对于我的意义在哪，对于我的成长或者说我的人生来说有什么意义，知道自己要的是什么，才能更好的去实现，也不会从内心去抗拒这件事情，才会真正的用心去做这件事情。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;展望结果&lt;/p&gt;
&lt;p&gt;展望结果很简单，我需要完成这件事情到哪种程度，&lt;strong&gt;为过程鼓掌，为结果买单&lt;/strong&gt;，只有当你真正明白了你要做的事情最后会达成一个什么样的效果，你才会有方向，会下意识去往这个结果靠拢。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;头脑风暴&lt;/p&gt;
&lt;p&gt;对于你想要的结果，你有什么想法都可以大胆的写出来，必须要写出来，不要让他存于你的脑海之中，一定要尽量全，不用在乎对错，不用在乎是否切合实际，写出来就好。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;组织整理&lt;/p&gt;
&lt;p&gt;把脑海中的想法进行组织整理，这一步可能没有经验的人会感到困惑，不知道如何做起，那么没关系，你只需要列出一个大概的先后顺序就行了，随着事情的推动和发展，你会慢慢的去完善你的项目规划。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;明确下一步的行动方案&lt;/p&gt;
&lt;p&gt;下面就是最后一个步骤，&lt;strong&gt;下一步我该去做什么&lt;/strong&gt;，比如说，我要学习 vert.x，可能我需要做的就是打开 Google，去查找一些官方文档和 demo，这一步的关键点在于一定要是&lt;strong&gt;可执行&lt;/strong&gt;的一个动作，而不是很空泛的一个名词，比如：学习 vert.x，这样的下一步动作不会给你任何的帮助，反而会让你再去花时间去思考，到底如何去学习，其实思考的这一过程，应该放到这一步中去做，而不是事情到跟前了，再去思考如何去做。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;接下来，我们需要考虑的一个问题是，我们对于我们人生目标的愿景，原则，价值观，这个的话就仁者见仁智者见智啦，没有的同学可以在以后的实践中慢慢的补上，我的人生目标很简单~ 就是让世界因为我而有一点点不一样~&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;然后，我们可以去做最后一步，把印象笔记中清单转移到滴答清单，有些人可能会有疑问，为什么不直接写到滴答清单中去，因为滴答清单中是通过种类来划分的，我们必须有一个&lt;strong&gt;总控&lt;/strong&gt;的机制去保证我们的事情不会有所遗漏。&lt;/p&gt;
&lt;p&gt;那么，我们该怎么去迁移呢？&lt;/p&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;首先，我们从空间和场景上来定义两类标签。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://viyoungblog.oss-cn-beijing.aliyuncs.com/viyoung/2019-12-30-133303.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;然后在导入清单中事项的时候注意将这些标签给附带上，通过我们上一步的人生长期目标短期目标以及价值观和愿景来给出对应的优先级（这些都可以在滴答清单中很方便的设置）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://viyoungblog.oss-cn-beijing.aliyuncs.com/viyoung/2019-12-30-133437.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;然后我们在滴答清单的智能清单中进行设置，这样就可以获得一个与情景相关的清单~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://viyoungblog.oss-cn-beijing.aliyuncs.com/viyoung/2019-12-30-141036.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;这里我们也可以把一些重复性的任务进行录入，支持农历重复也是我支持滴答清单的重要原因之一&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://viyoungblog.oss-cn-beijing.aliyuncs.com/viyoung/2019-12-30-141221.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;我们的项目清单如果可以划分为多个&lt;strong&gt;确定&lt;/strong&gt;的步骤，可以使用滴答清单的子任务功能进行设置~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://viyoungblog.oss-cn-beijing.aliyuncs.com/viyoung/2019-12-30-141444.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;把&lt;strong&gt;印象笔记——日程表&lt;/strong&gt;中的任务迁移到滴答清单，并设置好时间和对应的提醒，并将优先级设置为第一优先级&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://viyoungblog.oss-cn-beijing.aliyuncs.com/viyoung/2019-12-30-141643.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;最后一步，把等待回复清单中的事项也同样分类添加到我们的滴答清单，最好可以在清单前用&lt;strong&gt;等待&lt;/strong&gt;标签来标识，这样有便于我们去查找和自定义智能清单去管理。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这一个流程完成之后，我们印象笔记中的清单除了将来也许清单和材料清单之外的都已经转移到了我们的滴答清单中来，也许你会觉得这个过程很繁琐，但是如果你用 GTD 的思想去做这件事，我们每次要做的&lt;strong&gt;下一步行动&lt;/strong&gt;其实都是非常简单的&lt;/p&gt;
&lt;h4 id=&quot;review回顾&quot;&gt;Review（回顾）&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://viyoungblog.oss-cn-beijing.aliyuncs.com/viyoung/2019-12-29-040030.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;吾日三省吾身，为人谋而不忠乎，与朋友交而不信乎，传不习乎？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果说前面的三步是我们创建我们自己的 GTD 系统中的一个开始，那么剩下的这两步就是我们让我们建立的这个系统保持&lt;strong&gt;活性和有效性&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;回顾是我们 GTD 系统保持活性的一大法宝，这个就要看个人贵在坚持了，如果我们辛辛苦苦搭建的系统没有定期的去回顾，去维护，那么我们的系统可能在有效一段时间之后，很快的就会恢复原样，那么我们应该怎么去维护去回顾我们的系统呢，这里又要引入一个新的概念——&lt;strong&gt;五万英尺理论&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;跑道——行动&lt;/strong&gt;，也就是我们当前需要为推动项目而进行或者正在进行的下一步行动，是需要执行的&lt;strong&gt;单次行动&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;一般参考的清单是滴答清单中的&lt;strong&gt;日程表&lt;/strong&gt;和&lt;strong&gt;下一步行动清单&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;每天进行多次，只要我们疑惑下一步做什么的时候去看这个清单即可&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;1万英尺——项目&lt;/strong&gt;。我们想实现的结果，一般来说是指需要分步执行，我们想要在一年内完成。
&lt;ul&gt;&lt;li&gt;参考清单是&lt;strong&gt;全部项目的总清单&lt;/strong&gt;，以及在&lt;strong&gt;上一步制定的对应的项目规划&lt;/strong&gt;，这个时候我们在印象笔记的总览就起到了很重要的作用，可以很方便的去帮助我们做总览~&lt;/li&gt;
&lt;li&gt;每周回顾的时候进行这个层面的回顾，或者当我们查看下一步行动但是不明确的时候去回顾和查看&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;2万英尺——关注和职责范围&lt;/strong&gt;。生活或工作中必须维持在&lt;strong&gt;一定标准&lt;/strong&gt;之上，使生活正常运转的重要区域。
&lt;ul&gt;&lt;li&gt;这个没有具体的清单让我们去参考，需要我们去创建，我们要做的是&lt;strong&gt;你看到这里的时候，现在把这件事情记录到你的「仓库」&lt;/strong&gt;，然后可以参考易效能时间管理提倡的：健康、家庭、事业、学习、财富、休闲、社交、效能，这几个方面去思考和考虑，维护一篇笔记，然后下次进行回顾的时候去和当前的情况做对比。&lt;/li&gt;
&lt;li&gt;回顾频率一般是一个月一次，或者当我们的工作，家庭，个人方向发生重大变动的时候&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;3万英尺——具体的长短期目标&lt;/strong&gt;，为了实现我们的愿景（理想蓝图），我们在今后的一年希望实现什么。
&lt;ul&gt;&lt;li&gt;这个一般可以参考你的年度计划和年度目标，如果你还没有制定你的年度目标，那么趁着2020年的到来，让我们一起为新年加油，制定新年计划吧~&lt;/li&gt;
&lt;li&gt;回顾频率一般是&lt;strong&gt;每个季度&lt;/strong&gt;进行总结和调整&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;4万英尺——愿景&lt;/strong&gt;，愿景一般来说是指3-5年的一个需要达到的目标和规划。
&lt;ul&gt;&lt;li&gt;2020年是新十年的开始，我们可以趁这个机会来开始制定我们的个人五年计划，这里也许会苦恼没有方向，没有一个详细的目标，没关系，我们需要的是一个方向，只是大概绘制出我们的人生的方向，可以在根据实际情况去调整。&lt;/li&gt;
&lt;li&gt;回顾频率一般是&lt;strong&gt;一年一次&lt;/strong&gt;，或者当我们觉得有必要进一步明确和指明方向，协调努力，激发动力的时候&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;5万英尺——宗旨和核心价值观&lt;/strong&gt;，我们人生的原则和目标所在，这是一个十分抽象的概念，需要我们在实践中去慢慢体会
&lt;ul&gt;&lt;li&gt;一般来说可以参考自己的人生规划，人生规划其实和五年计划一样，随着我们的成长会不断的发生调整&lt;/li&gt;
&lt;li&gt;频率不定，一般是一年以上，或者当我们觉得有必要进一步明确和指明方向，协调努力，激发动力的时候。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;http://viyoungblog.oss-cn-beijing.aliyuncs.com/viyoung/2020-01-01-021856.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在我们知道了&lt;strong&gt;六个层面的回顾频率以及回顾什么东西&lt;/strong&gt;，那么接下来我来重点说一下&lt;strong&gt;每周回顾&lt;/strong&gt;该怎么去做，一周的时间不长不短，适合我们不断的去成长，调整方向，如果初学者没有能力去做到每年回顾，季度回顾，那么&lt;strong&gt;每周回顾&lt;/strong&gt;一定要做好！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;每周回顾&lt;/strong&gt;&lt;/p&gt;
&lt;ol readability=&quot;5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;保持清爽&lt;/strong&gt;，一周的时间下来，我们可能积累了不少的事情放在「仓库」中等待我们去处理，我们要做的就是简单的进行一次 Collect 的操作，&lt;strong&gt;保持我们的环境和大脑清爽。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;保持最新&lt;/strong&gt;，检查我们的下一步行动清单，日程表，等待清单，项目清单，查看未完成的事项，以及马上要进入工作的事项，做好准备，把项目清单中需要的做的下一步行动挪到滴答清单中，每周更新我们的清单，每周都是一个全新的开始。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;&lt;strong&gt;创造&lt;/strong&gt;，check 我们的愿望清单，看看下周是否有可以达成的愿望，拿出来放到项目中，进行自然规划法后放入到各个清单中去。&lt;/p&gt;
&lt;p&gt;这一步的重点就两个字：&lt;strong&gt;坚持&lt;/strong&gt;，坚持去做回顾，前面不要在乎对错，试错总是有代价，但是一周的时间我们可以承受这个代价，关键在坚持下去，就会拥有一个崭新的自己。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;do执行&quot;&gt;Do（执行）&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://viyoungblog.oss-cn-beijing.aliyuncs.com/viyoung/2020-01-01-094750.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;终于到了我们的最后一步，也是最关键的一步，执行，我们的系统打造的再完美，如果我们不去执行，一切都是白搭，那么我们该怎么去执行呢？&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;首先我们要去执行我们日程表上的事务，这个是第一重要的。&lt;/li&gt;
&lt;li&gt;然后我们要根据当前的时间，地点，精力，可用时间的长短去选择事务进行完成。&lt;/li&gt;
&lt;li&gt;临时的事务如果不超过两分钟的话，立即执行，超过两分钟丢到「仓库」，把手头工作做完之后再去看这个问题（特别重要的事情除外，比如生产事故）&lt;/li&gt;
&lt;li&gt;我们在前面制定了一些由标签组合的自定义智能清单，我们根据不同的情景，按照清单的优先级去做就可以了。&lt;/li&gt;
&lt;li&gt;在做这些事情之前，我们可以利用手机上的滴答清单去给高耗脑力行动预设一个番茄钟估时，然后在执行的时候启动我们的番茄钟，在防止我们分心的同时也可以去帮助我们去&lt;strong&gt;统计&lt;/strong&gt;我们完成脑力任务这种不好预估时间的任务所需的时间，从而更好的去安排我们在什么时候应该做什么，这是一个反哺的过程。&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;总结&quot;&gt;总结&lt;/h4&gt;
&lt;p&gt;GTD 的几个步骤到这里就告一段落了，看起来虽然比较繁琐，但是其实有好多方法我们已经在日常的生活和工作中使用了，只不过在这里进行了完善和串联，&lt;strong&gt;我们不能管理时间，我们能做的就是管理自己&lt;/strong&gt;，这是 GTD 也是所有时间管理的关键，&lt;strong&gt;如果我们可以管理自己，就掌握了 GTD 的道，术只不过是一种形式&lt;/strong&gt;，而我上面讲解的只不过是最为简便通俗的一种，可以让从来没有接触过 GTD 的朋友掌握一个入门的方向，每个人的习惯和爱好都不同，但是我们的目标都是一样的，那就是 &lt;strong&gt;Get Things Done&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;展望2020&quot;&gt;展望2020&lt;/h3&gt;
&lt;p&gt;上面介绍完了，我2019年的最大收获，如果觉得意犹未尽或者有什么疑问和指教，可以关注我的公众号：「Vi的技术博客」或者直接加我 vx：cm_950825 进行探讨。&lt;/p&gt;
&lt;p&gt;下面大概说一下今年的方向吧&lt;/p&gt;
&lt;h4 id=&quot;健康&quot;&gt;健康&lt;/h4&gt;
&lt;p&gt;来到广州之后，体重暴涨了十几斤，希望2020年可以把这十几斤还回去，然后保持住，&lt;/p&gt;
&lt;h4 id=&quot;博客更新&quot;&gt;博客更新&lt;/h4&gt;
&lt;p&gt;2019年因为一些个人的原因，博客的更新频率不是很高，这不又停更了好久，2020年的目标是至少每周一更，一年打底完成52篇原创，当然在保证质量的情况自然是多多益善啦&lt;/p&gt;
&lt;h4 id=&quot;英语&quot;&gt;英语&lt;/h4&gt;
&lt;p&gt;出来之后才发现英语的重要性，2019年已经学习了一部分，2020年要把英语水平提高到和歪果仁正常交流无障碍，可以支持一次全英面试。&lt;/p&gt;
&lt;h4 id=&quot;家庭&quot;&gt;家庭&lt;/h4&gt;
&lt;p&gt;2019年是没有旅游的一年，从年初到年尾，由于各种原因，旅游的计划屡被搁置，2020年至少打卡澳门广州新加坡这三个地方吧~&lt;/p&gt;
&lt;h4 id=&quot;技术&quot;&gt;技术&lt;/h4&gt;
&lt;p&gt;技术方面的话，因为非科班的原因，今年会更偏向于基础方面，比如计算机网络和算法数据结构这些基础性的知识（主要还是去商汤面试被虐了的原因。。），总之，要学的东西还有很多，要走的路还有很长，共勉吧~&lt;/p&gt;
&lt;h4 id=&quot;github&quot;&gt;Github&lt;/h4&gt;
&lt;p&gt;被我拖了两年的打造github项目终于要提上日程了，大概方向的话暂时还没确定，不过已经有几个方案了，农历年后就会开始启动，说不定你们会在 B 站上看到我&lt;strong&gt;女装直播撸代码&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;大概就是这些吧，2020年，希望可以让自己变的更强~ 最后的最后，送给大家一段我超级喜欢的话&lt;/p&gt;
&lt;h3 id=&quot;无问西东&quot;&gt;无问西东&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;如果提前了解了你们要面对得人生，

不知道你们是否还有勇气前来，

看见得和听到的，

经常会令你们沮丧，

世俗是这样强大，

强大到生不出改变它们的念头来。



可是如果有机会提前了解了你们的人生，

知道青春也不过只有这些日子，

不知你们是否还会在意

那些世俗希望你们在意的事情，

比如占有多少才更荣耀，

拥有什么，才能被爱。



等你们长大，

你们因绿芽冒出土地而喜悦，

会对初升的朝阳欢呼跳跃，

也会给别人善意和温暖，

但是却会在赞美别的生命的同时，

常常

甚至永远地忘了自己的珍贵。



愿你在被打击时，

记起你的珍贵，

抵抗恶意;

愿你在迷茫时，

坚信你的珍贵，

**爱你所爱，**

**行你所行，**

**听从你心，**

**无问西东。**&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;参考资料&quot;&gt;参考资料&lt;/h3&gt;
&lt;p&gt;《搞定Ⅲ—平衡工作和生活的艺术》&lt;/p&gt;
&lt;p&gt;《无问西东》电影台词&lt;/p&gt;
&lt;h3 id=&quot;絮叨两句&quot;&gt;絮叨两句&lt;/h3&gt;
&lt;p&gt;如果你可以坚持看到这一段，那么说明你至少和我一样优秀了，哈哈哈哈，开个玩笑，这篇文章是我&lt;strong&gt;半年&lt;/strong&gt;前就开始构思的，动笔是在两周前，准备了好久，洋洋洒洒写了七千多字，准备了近三十张图，只为了可以帮助我的读者在新的十年可以更高效的挣钱，更高效的生活。&lt;/p&gt;
&lt;p&gt;如果对你有所帮助，请你给我一个关注+点赞，也算是对我这两周辛勤耕耘的一个鼓励，第一次求读者大大们，希望可以给个面子哈哈哈，爱你们么么哒。&lt;/p&gt;
&lt;p&gt;最后愿我们奔走在热爱中去迎接下一个十年~&lt;/p&gt;
&lt;h3 id=&quot;公众号&quot;&gt;公众号&lt;/h3&gt;
&lt;p&gt;一个有趣的灵魂，让技术变的有趣，欢迎关注我，和我一起成长进步。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1528535/202001/1528535-20200102063411289-55116478.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 02 Jan 2020 00:27:00 +0000</pubDate>
<dc:creator>Vi的技术博客</dc:creator>
<og:description>一份呕心沥血两周 共计七千五百字 三十张图的让你效率翻倍的年度总结</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/viyoung/p/12131335.html</dc:identifier>
</item>
<item>
<title>大规模机器集群-故障自动处理(二) - 曲行人</title>
<link>http://www.cnblogs.com/qxren7/p/12130927.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qxren7/p/12130927.html</guid>
<description>&lt;p&gt;本篇开始介绍具体的实现过程，为表述方便，先定义一些名词，&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;em&gt;AutoRepairSystem: &lt;/em&gt;&lt;em&gt;故障自动维修系统, 缩写为ARS&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;em&gt;原子操作：&lt;/em&gt;任务的最小操作，机器任务通常是指重启、重装&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;em&gt;运维人员：运维工程师= SRE = OP，系统工程师 = sys&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;em&gt;远程管理工具： 远程控制操作物理机器的工具，如ipmi、ilo&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;先来看ARS的整体视图和流程图，&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1904670/202001/1904670-20200101230851807-1728160768.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1904670/202001/1904670-20200101230907850-1435032638.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;&lt;img class=&quot;rich_pages&quot; src=&quot;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&quot; alt=&quot;&quot; data-ratio=&quot;0.046296296296296294&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ia83lBt8vCJb7BicU7uRoTx0n7ZJrEZ1ssoTBW1nAHXTuD1HHZiaeCmOFCtKqibuqBTqqmy1Z9CGOic5jOxrz4kcLcw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1728&quot;/&gt;&lt;/p&gt;

&lt;p&gt;ARS的工作流程，&lt;/p&gt;
&lt;ol class=&quot;list-paddingleft-2&quot; readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;故障检测: 每5分钟发起一次故障检测，获取当前时刻整个集群的故障机器列表，推送到工作流子系统&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;安全策略: 遍历故障机器列表，依次执行安全策略，过滤不符合要求的机器，得到一个可安全执行重启、重装的机器列表&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;服务离线: 遍历可安全操作的机器列表，执行服务离线&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;故障维修: 服务离线后，发起重启、维修操作，轮询机器状态，直至重启成功或维修完成&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;环境初始化: 执行环境初始化，保证机器环境符合业务需求&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;服务上线: 恢复服务，检查服务达到可服务状态，流程结束&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;接下来将介绍工作流子系统，这是所有具体操作任务执行的基础；&lt;/p&gt;
&lt;p&gt;再依次介绍上述流程中的关键环节： 服务上下线，故障检测，安全策略，维修工具及SLA;&lt;/p&gt;
&lt;p&gt;然后通过一个线上例子，说明整体的工作流程；&lt;/p&gt;
&lt;p&gt;最后分享系统上线后的运行数据。&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;2.1 工作流子系统&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;工作流最基本的功能，是驱动一系列预定义任务顺序执行，达到明确的结束状态；在机器故障自动处理这个问题域里，对工作流还有闭环、扩展性的要求(详见第一篇的分析).&lt;/p&gt;

&lt;p&gt;经过分析统计机器相关的操作任务， 比如机器重启、重装、初始化环境、启动/停止服务、查看信息等，抽象出机器操作的任务模型，即”对一组机器执行相同的任务，且任务可以进一步拆分为一系列更小的原子操作组合”，如图所示，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1904670/202001/1904670-20200101230938148-1395115843.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;img class=&quot;rich_pages img_loading&quot; src=&quot;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&quot; alt=&quot;&quot; data-ratio=&quot;1.1178597252349964&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ia83lBt8vCJb7BicU7uRoTx0n7ZJrEZ1ssPJjmGZObXAfmeGJxHzib7ogrkHYc6boP9f4grmZhILEoERhEvOBxNJg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1383&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图表示对一组机器执行相同的任务，下图表示，这个任务具体有4个原子操作。&lt;/p&gt;
&lt;p&gt;由此，我们可以定义工作流的几个关键类，以及他们的关系，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1904670/202001/1904670-20200101230958691-1562640916.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1904670/202001/1904670-20200101231020945-269577717.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;&lt;img class=&quot;rich_pages img_loading&quot; src=&quot;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&quot; alt=&quot;&quot; data-ratio=&quot;0.46905725853094277&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ia83lBt8vCJb7BicU7uRoTx0n7ZJrEZ1ssdDzrDsftmR68uE3NIdxiaQSJRGF4LtPFibvicYW5wwNP0aTce1rQMicTPw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1729&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;rich_pages img_loading&quot; src=&quot;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&quot; alt=&quot;&quot; data-ratio=&quot;0.4366685945633314&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ia83lBt8vCJb7BicU7uRoTx0n7ZJrEZ1ssNGkThqubs7761BUx4BUd34caqERVNB5dKhVG52922TkpgEAL4P9vUA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1729&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注：为了简化表述，这里只列出和流程执行、任务分支、通用性相关的字段和逻辑，工作流子系统的完整信息，后续会另写文章介绍。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; &lt;/em&gt;&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Job，定义了任务类型以及要操作的目标集合&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Task，定义了一个具体的操作目标，以及action_tree的root节点&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Action，定义了业务逻辑的内容和加载方式&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Scheduler, 调度Job的运行&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Monitor, 监控 Job、Task、Action 的状态&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Executor, 控制Job下的task/action 的执行顺序、并发等&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来重点看看工作流系统是如何达到前文提到的扩展性、闭环要求的。&lt;/p&gt;

&lt;p&gt;第一点，扩展性。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1904670/202001/1904670-20200101231043479-213495320.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;img class=&quot;rich_pages img_loading&quot; src=&quot;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&quot; alt=&quot;&quot; data-ratio=&quot;0.39097744360902253&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ia83lBt8vCJb7BicU7uRoTx0n7ZJrEZ1ss8KJKIyFibtG6nB6up8LSpmrEFG6ibvxB1licN7AYlrm8EibeWSfCS7vz9Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1729&quot;/&gt;&lt;/p&gt;
&lt;p&gt;扩展性需求，最初来自于不同服务上下线操作的差异，主要是有状态服务。&lt;/p&gt;
&lt;p&gt;它们之间的差异，体现在操作步骤的数量和顺序不同。例如，&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;em&gt;推荐模型服务，要求先寻找可用的机器资源，在新资源上部署相同版本的服务，启动服务加载数据，判断数据加载进度，直到达到某个阈值，才算是完成“迁移”，此时才达到可维修的状态&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;em&gt;Docker服务，相对简单，只需向docker发起迁移命令，等待docker返回迁移进度，迁移完成后即可维修&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;em&gt;Hadoop服务，主要痛点在磁盘故障上，要求维修过程中不能长时间停服，所以维修逻辑很复杂，要先停止本机服务，umount故障磁盘，启动服务，维修故障磁盘，修复之后再停服，起服，让Hadoop重新使用这块磁盘&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;em&gt;其他无状态服务相对简单，通常直接维修即可&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可见，不同服务的差异化是不可穷举的，如果ARS要介入具体的维修逻辑，无异于“揽屎上身”，最终陷入泥潭里无法自拔。&lt;/p&gt;

&lt;p&gt;我们的思路是： 对外提供一套机制，能简易地将维修逻辑嵌入工作流子系统，实现步骤如下，&lt;/p&gt;
&lt;ol class=&quot;list-paddingleft-2&quot; readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;em&gt;将复杂任务拆解成多个原子操作，每个原子操作实现为一个python方法，返回值格式固定&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;em&gt;定义原子操作的执行顺序以及分支&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;只要满足上述条件，系统就能支持任意数量、任意顺序的原子操作集合。&lt;/p&gt;

&lt;p&gt;原子操作的python实现如下图所示，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1904670/202001/1904670-20200101231058850-433775015.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;action1为原子操作名字，do_hard_work()方法由业务sre 完成，工作流子系统只负责调用， is_succ表明本次操作是否执行成功，result通常是操作结果信息。&lt;/p&gt;

&lt;p&gt;只要按照这个约定编写的任务，都可注册到系统里被执行，哪怕提交人只是用python 包了一坨 shell 脚本，也是可嵌入系统的，虽然我们在review的时候会“建议”他重写。&lt;/p&gt;

&lt;p&gt;有了原子操作的实现，就可以定义它们的执行顺序，我们使用了“树”的概念，如下图json配置示例所示，&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1904670/202001/1904670-20200101231116908-1862316914.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;可以看到，整棵树有多棵子树组成，每棵子树指向一个nodes list，每个node就是一个action, action的数量和顺序可以在nodes list里任意配置扩展。&lt;/p&gt;
&lt;p&gt;在example_trees里， action1～action6就是原子操作，执行的顺序有两种可能分支，&lt;/p&gt;
&lt;p&gt;action1-&amp;gt; action2 (true)--&amp;gt; action3-&amp;gt;action4-&amp;gt;结束;&lt;/p&gt;
&lt;p&gt;action1-&amp;gt; action2 (false)--&amp;gt; action5-&amp;gt;action6-&amp;gt;结束;&lt;/p&gt;

&lt;p&gt;假设现在业务有一个大的改动，需要在action2之前增加一个操作action7, 并在action6之后，增加一个分支action8,  这只需在配置上小改动即可实现，&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;rich_pages img_loading&quot; src=&quot;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&quot; alt=&quot;&quot; data-ratio=&quot;1.6336386344712739&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ia83lBt8vCJb7BicU7uRoTx0n7ZJrEZ1ssrrmD0Ow7k1yMCDz4OZaaFfENajWywJsxmdmwic8YwlGs8IB58YBpuicg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1201&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1904670/202001/1904670-20200101231132292-562061557.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;example_trees 会被保存在Action类的action_definition字段里，这个配置记录了执行逻辑的python 文件，类和方法; 工作流在运行时，会动态加载相应的类，根据方法名调用方法，如下图所示，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1904670/202001/1904670-20200101231144984-708960356.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;&lt;img class=&quot;rich_pages img_loading&quot; src=&quot;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&quot; alt=&quot;&quot; data-ratio=&quot;0.7694300518134715&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ia83lBt8vCJb7BicU7uRoTx0n7ZJrEZ1ssEpaw9EPSoBsYeWLGZibZYNC1AxoLlJY36tRpRU27qFO2P0tcibk2KkWw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;386&quot;/&gt;&lt;/p&gt;

&lt;p&gt;凭借这些特性，业务sre可以灵活多变的定义自己的任务树，其中公共部分，由平台sre编写，与业务相关部分由业务sre编写。&lt;/p&gt;

&lt;p&gt;第二点，闭环。&lt;/p&gt;
&lt;p&gt;以无状态的 web机器的宕机自动处理流程为例，&lt;em&gt;(这里为了方便表述，做了简化)&lt;/em&gt;&lt;/p&gt;
&lt;ol class=&quot;list-paddingleft-2&quot; readability=&quot;1&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;em&gt;检测宕机的机器&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;重启机器&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;em&gt;如果能起来，检查程序版本，启动web 服务，流程结束&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;em&gt;如果不能起来，则报修硬件故障&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;em&gt;如果能修复，回到第3步&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;em&gt;如果不能修复，则检查是否过保，如果是，则下架机器，流程结束&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其流程树的配置如下，&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;rich_pages img_loading&quot; src=&quot;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&quot; alt=&quot;&quot; data-ratio=&quot;0.8426966292134831&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ia83lBt8vCJb7BicU7uRoTx0n7ZJrEZ1ss5ePqIp1Kl10DbcMGprhaZBE4MjFHOIleCXdohib2iavYQrPeEALHZDCA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1602&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1904670/202001/1904670-20200101231206183-1978438123.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1904670/202001/1904670-20200101231212181-961139587.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;可以看到，reboot_host、check_host_alive、repair_host等action为原子操作；&lt;/p&gt;
&lt;p&gt;这棵树有两个分支节点，&lt;/p&gt;
&lt;p&gt;如果 reboot_host之后 check_host_alive为Ture, 则执行online_service 分支，流程结束； &lt;/p&gt;
&lt;p&gt;如果为false, 则执行repair_host 分支，如果能修好，则回到 tree2 ，最后也达到 online_service的状态,  流程结束；（只要是没过保，都能修好）&lt;/p&gt;
&lt;p&gt;如果修不好，那么则进入 off_rack 下架流程，流程结束。（通常是机器过保）&lt;/p&gt;

&lt;p&gt;这里之所以反复强调任务分支，是因为有了任务分支，就可以在各个可能执行失败的环节，指定下一步的操作，最终将目标操作到一个可预期的状态(机器要么被修好重新投入使用，要么修不好被下架)，形成闭环，不用人工介入，真正提高自动化程度。&lt;/p&gt;
&lt;p&gt;同时，由于在一开始就设定了维修只有两种操作:重启，重装，这两种操作都由sys来保证交付时间，所以这棵树能保证流程是闭环的。&lt;/p&gt;

&lt;p&gt;在ARS上线之前，早期的自动工具发起重启命令之后，机器起不来，通常是人工通知sys 报修，报修之后 sys 再根据机器是否过保来给sre 反馈维修状态，这个过程，如同黑洞，吞噬了rd-sre-sys-机房外包四方大量的沟通时间, 如图所示，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1904670/202001/1904670-20200101231238886-1843899502.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;img class=&quot;rich_pages img_loading&quot; src=&quot;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&quot; alt=&quot;&quot; data-ratio=&quot;0.6385193753614806&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ia83lBt8vCJb7BicU7uRoTx0n7ZJrEZ1ssPC49CxHokRBfibmeAKdOcLX9Vh9UoBnxvOW6MvbIVVOSRib8XlegiaZgA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1729&quot;/&gt;&lt;/p&gt;
&lt;p&gt;工作流子系统还涉及状态机、并发控制、重试、任务重入、超时、执行进度等，后续另写文章介绍。&lt;/p&gt;

&lt;p&gt;在下一节里，将介绍故障检测、安全策略等内容。&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;2.2故障检测&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;故障检测的完整性、正确性是故障维修自动化的前提。&lt;/p&gt;
&lt;p&gt;通过分析历史机器故障类型，可将故障分为5个层次，如下表，基本覆盖了sre日常处理的故障。&lt;/p&gt;

&lt;table cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;8.5&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;73&quot;&gt;
&lt;p&gt;&lt;strong&gt;层次&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;100&quot;&gt;
&lt;p&gt;&lt;strong&gt;异常类型&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;458&quot;&gt;
&lt;p&gt;&lt;strong&gt;常见问题&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;134&quot;&gt;
&lt;p&gt;&lt;strong&gt;检测方式&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;73&quot;&gt;
&lt;p&gt;业务相关&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;100&quot;&gt;
&lt;p&gt;执行异常&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;458&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;磁盘空间不足、部署时调用的control脚本返回值异常、目录权限&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;134&quot;&gt;
&lt;p&gt;Falcon&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;73&quot;&gt;
&lt;p&gt;运维系统&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;100&quot;&gt;
&lt;p&gt;平台自身异常&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;458&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;帐号异常、Executor执行任务异常、部署系统异常&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;134&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;Falcon+运维系统接口&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;73&quot;&gt;
&lt;p&gt;基础环境&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;100&quot;&gt;
&lt;p&gt;依赖异常&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;458&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;环境异常(依赖库/文件缺失)、版本不符(内核/python/perl)、limits.conf不符&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;134&quot;&gt;
&lt;p&gt;Falcon+shell/python&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;73&quot;&gt;
&lt;p&gt;系统层&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;100&quot;&gt;
&lt;p&gt;读写异常&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;458&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;文件系统错误(Input/Output Error)、文件系统挂载错误(read-only、home未挂载)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;134&quot;&gt;
&lt;p&gt;Falcon+shell/python&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;10.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;73&quot;&gt;
&lt;p&gt;机器层&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;100&quot;&gt;
&lt;p&gt;连接异常&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;458&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;硬盘故障, 宕机故障, 内存故障, 电源故障, 风扇故障, CPU/GPU故障&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;134&quot;&gt;
&lt;p&gt;ping/ssh/Falcon+ipmi&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;ARS主要覆盖了机器层、系统层，下面分别做说明。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;磁盘故障&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;磁盘故障率高的业务类型很多， 如hadoop、索引服务、分布式文件系统服务、机器学习模型训练服务等，这些服务的机器，磁盘块数最高多达36块，大量读写磁盘，造成磁盘故障率很高。&lt;/p&gt;
&lt;p&gt;常见的磁盘故障类型有掉盘、读写错误(Input/Output Error)、漂盘、挂载错误、 read-only错误、性能剧降(ls /disk/ 超过10分钟无反应)；&lt;/p&gt;
&lt;p&gt;磁盘故障的积累，有可能会导致数据丢失，以及拖慢整个系统的性能，所以要尽早检测到尽早处理。&lt;/p&gt;

&lt;p&gt;宕机故障&lt;/p&gt;
&lt;p&gt;宕机故障分为完全死机，假死。&lt;/p&gt;
&lt;p&gt;完全死机(指连续3个小时失去心跳，并且主动ssh 探测失败的机器)，这种情况容易处理，直接进入自动重启流程；&lt;/p&gt;
&lt;p&gt;假死，有如下类型，&lt;/p&gt;
&lt;p&gt;l  Connection timed out&lt;/p&gt;
&lt;p&gt;l  Connection closed by remotehost&lt;/p&gt;
&lt;p&gt;l  Connection reset by peer&lt;/p&gt;
&lt;p&gt;l  Connection refused&lt;/p&gt;
&lt;p&gt;l  Connection closed by&lt;/p&gt;

&lt;p&gt;这些假死状态，可能会造成业务受损。&lt;/p&gt;
&lt;p&gt;比如机器假死，服务端口还能连接，但实际业务进程内部无法正常工作，如果是前端web机器出现这种情况，会导致业务5xx监控飙升；此时，想手动重启，ssh已经无法连接，只能通过ilo重启，或者紧急联系机房，处理耗时往往超过半小时。&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;内存故障&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;内存故障时，通常机器还没有死机，(在/var/log/message 里显示CE error on CPU#1Channel#2_DIMM#1)&lt;/p&gt;
&lt;p&gt; rd认为机器还能跑，不愿意停服务；&lt;/p&gt;
&lt;p&gt;如果积攒到多台机器出现类似错误，极有可能在短时间内出现连续死机，导致服务容量突然减少，服务性能大幅下降的业务故障，所以对于一些敏感服务，出现这种故障，还是要当作死机来处理。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;电源故障&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;双电源是突然断电、市政施工的保障，如果电源坏了不修，在这种情况下，机器会断电关机，如果积攒多了，服务容量会突减，影响业务。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;风扇故障&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不会马上造成死机，但是会产生连锁反应。风扇故障会导致cpu温度升高，引发死机。&lt;/p&gt;


&lt;p&gt;上述故障检测的实现，主要是通过 Falcon监控系统 + scripts 实现，涉及了 ping/ssh/ipmi/dmesg/proc/sar…等大量系统命令和系统信息。&lt;/p&gt;
&lt;p&gt;Falcon 运行这些scripts，检测故障，外部应用就可以从接口里查询故障列表信息，如下，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1904670/202001/1904670-20200101231305777-1434192693.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;img class=&quot;rich_pages img_loading&quot; src=&quot;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&quot; alt=&quot;&quot; data-ratio=&quot;1.2497055359246172&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ia83lBt8vCJb7BicU7uRoTx0n7ZJrEZ1ssnXslnzDicDicCUGsctg2fQAJ3DQJAFV8TyZr6XvfHqMXFavg1cCEkciaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;849&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ARS从Falcon拉取当前时刻集群内所有故障机器的列表，附带了相应的故障信息，推送到工作流里，进行维修。&lt;/p&gt;


&lt;h2&gt;&lt;strong&gt;2.3 安全策略&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;对机器的操作，通常是重装、重启、root环境修改、部署基础agent等；此类操作往往不可逆且无法暂停，所以需要严格的安全策略保证机器操作不影响线上服务或影响最小。&lt;/p&gt;

&lt;p&gt;经过“故障检测”这个环节后，得到一个当前时刻所有故障机器列表，安全策略会对这个列表进行分析过滤，下表是我们使用的安全策略列表，&lt;/p&gt;

&lt;table cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;thead&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;103&quot;&gt;
&lt;p&gt;&lt;strong&gt;策略&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;147&quot;&gt;
&lt;p&gt;&lt;strong&gt;作用&amp;amp;应用场景&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;253&quot;&gt;
&lt;p&gt;&lt;strong&gt;实现&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;27&quot;&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;122&quot;&gt;
&lt;p&gt;filter_bw _lists&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;144&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;黑白名单；&lt;/p&gt;
&lt;p&gt;通常用于敏感服务，如支付、隔离环境服务&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;252&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;只处理白名单内的机器&lt;/p&gt;
&lt;p&gt;跳过黑名单内的机器&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;10&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;122&quot;&gt;
&lt;p&gt;filter_alive_hosts&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;144&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;过滤掉处于非死机的机器；&lt;/p&gt;
&lt;p&gt;防止误判，重启了非死机的机器&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;252&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;1、3分钟内连续ping机器，如果有响应，则过滤机器&lt;/p&gt;
&lt;p&gt;2、过滤可以响应 ssh 请求的机器&lt;/p&gt;
&lt;p&gt;3、防止网络抖动误判，在多个机房 ping，交叉验证&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;122&quot;&gt;
&lt;p&gt;filter_switch_fail&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;144&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;防止交换机故障引起误判，比如批量机器无法联通&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;252&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;按分钟统计机器的故障时间，如是同一分钟内报上来的(falcon采集周期是1分钟)，本次就不会向后端推送任何机&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;122&quot;&gt;
&lt;p&gt;filter_base_agent&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;144&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;过滤掉基础agent端口存活的机器；&lt;/p&gt;
&lt;p&gt;某些特殊服务会禁止ping/ssh命令，所以通过基础agent端口来判断存活&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;252&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;通过 telnet/curl  ip:port 判断基础agent是否存活，基础agent存活代表机器存活，过滤机器&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;11&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;122&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;filter_running_service_hosts&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;144&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;过滤掉有服务处于running状态的机器；&lt;/p&gt;
&lt;p&gt;防止误判，操作了服务还在运行的机器&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;252&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;检查机器网卡流量、磁盘io等指标，超过阈值则认为存在服务，过滤机器&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;122&quot;&gt;
&lt;p&gt;filter_capacities&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;144&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;根据服务容量过滤；&lt;/p&gt;
&lt;p&gt;防止因操作了机器，导致服务容量不足&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;252&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;计算服务容量, 当前running实例数/总实例数  &amp;lt; 阈值(90%)，过滤机器&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;122&quot;&gt;
&lt;p&gt;filter_duplicate&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;144&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;去重，保证同一时刻同一台机器只有一个操作任务在执行；&lt;/p&gt;
&lt;p&gt;防止多个任务叠加到同一台机器，出现未预期结果&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;252&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;遍历系统所有任务，如果此机器有处于running的任务，跳过此机器&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;122&quot;&gt;
&lt;p&gt;filter_pattern&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;144&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;过滤指定patterns的机器；&lt;/p&gt;
&lt;p&gt;这是最严格的过滤器，通常是单点服务使用此策略&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;252&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;对机器的机器名、节点名、运行服务名、在各类配置中心注册名进行正则匹配，如果匹配，则过滤机器&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;14.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;122&quot;&gt;
&lt;p&gt;filter_threshold&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;144&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;阈值保护，保证同时进行的机器操作任务数低于允许维修的数量&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;252&quot; readability=&quot;16&quot;&gt;
&lt;p&gt;1、按机房粒度，对于不同的任务类型，如果当前此机房的机器操作任务数大于阈值，跳过此机器&lt;/p&gt;
&lt;p&gt;2、按服务(app)粒度，如果当前此服务(app)的机器操作任务数大于阈值，跳过此机器&lt;/p&gt;
&lt;p&gt;例如这个例子，当前app1任务数是3，而允许维修的阈值是5，所以只能再发起2台机器的维修&lt;/p&gt;
&lt;p&gt;current_repairing/beijing/app1: 3  &lt;/p&gt;
&lt;p&gt;threshold /beijing/app1: 5&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;122&quot;&gt;
&lt;p&gt;filter_by_date&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;144&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;遵循分级发布原则，在一个星期内的某一天，只能维修对应机房的机器&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;252&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;1、指定每天允许维修的机房&lt;/p&gt;
&lt;p&gt;2、遍历所有机器，如果一台机器所属的机房不是当天允许维修的，跳过此机器&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;这个安全策略表，是总结分析多个业务线的历史case study得出来的， 在线上运行以来，未出现过误判，保证了自动任务的安全性。&lt;/p&gt;

&lt;p&gt;每一个安全策略，实现为工作流里的一个原子操作，即action，结合上述重启的例子，json配置如下，(维修的流程也可以使用这些安全策略，这里不再单独列出)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1904670/202001/1904670-20200101231321896-704392317.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;这些策略，可复用也可自由组合、调整顺序，这对于接入不同业务的机器进行自动维修，有很大的便利性和灵活性，同时降低了接入成本。&lt;/p&gt;

&lt;p&gt;如果业务有自己的安全策略需求，只需按照上述的action 方法规范，自己写一个安全策略方法，在配置里指定即可使用。&lt;/p&gt;


&lt;h2&gt;&lt;strong&gt;2.4 维修工具及SLA&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;机器硬件故障维修，是真实世界中的事件，这个过程需要人去到机房现场，从仓库拿出配件，走到机架旁边，拆卸机器，装配硬件。&lt;/p&gt;
&lt;p&gt;所以这个环节是“不可抗力”产生的地方，比如配件备货不足；节假日厂商人员放假，无法赶赴机房；赶上两会，机房封禁，不让进入等各种问题。&lt;/p&gt;

&lt;p&gt;1  交付时间&lt;/p&gt;
&lt;p&gt;为了达到流程闭环，我们(甲方)和机器厂商(乙方)约定机器维修交付时间， 通常是36小时交付(不同公司、厂商可能不一样)，至于怎么解决上述“不可抗力”，由乙方负责。&lt;/p&gt;

&lt;p&gt;2  远程管理工具可用率&lt;/p&gt;
&lt;p&gt;远程管理工具是机器操作自动化的必备工具，reboot_host/repair_host底层调用的就是ipmi;&lt;/p&gt;
&lt;p&gt;为了尽可能地减少机房现场人员操作，我们要求sys保证远程管理工具可用率达到 99.9%，比如，ilo，ipmi&lt;/p&gt;

&lt;p&gt;有了这两个SLA，我们可以认为 reboot_host、repair_host 这两个原子操作的最长耗时为36小时，所以维修流程是一定可以闭环的，避免了因任务中断导致的人工介入。&lt;/p&gt;

&lt;p&gt;当然，有了这些，也只是修复了硬件，还有系统参数设置、环境初始化、基础agent的问题，这个内容比较多，在下一篇讲。&lt;/p&gt;

&lt;p&gt;将上述提及的技术细节汇总，得到ARS的完整视图，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1904670/202001/1904670-20200101231335447-766488979.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;最后，看一个自动重启的例子，&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;rich_pages img_loading&quot; src=&quot;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&quot; alt=&quot;&quot; data-ratio=&quot;1.0202429149797572&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ia83lBt8vCJbgx7omaTVic7ogsPM3mFyFibyOuVg5XHt80Aia5DPLC3KZUMOkCibp6ABvMqXDVehscgJ65We5CaBGag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1729&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到任务树定义的actions 是怎么执行的，先是执行一系列的 filter_*安全策略，然后屏蔽报警，执行服务离线，发起重启，然后轮询机器状态，直到任务结束。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1904670/202001/1904670-20200101231351115-1178349489.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;h2&gt;&lt;strong&gt;2.5 系统运行数据&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;ARS上线后，覆盖数万台机器的故障自动处理，死机数量保持在10台左右，所有硬件故障总数量保持在100台以下，这对于一个数万台机器的集群来说，是非常理想的状态了。&lt;/p&gt;

&lt;p&gt;人力方面，对于20人的sre 团队，机器故障只需要 0.5人力维护系统正常运转，例如新服务的接入、业务要求紧急修复之类的情况；当机器规模增长时，人力并不需要相应的增加。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.6 总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最后，总结一下几个关键点，&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;2&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;标准，定义了有哪些类型的故障，什么故障执行什么样的修复，修复的标准流程&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;闭环，对于机器的操作，用任务分支覆盖操作成功或失败的情况，用SLA约束厂商在约定时间内交付机器，保证流程可达到明确的结束状态，避免人工介入&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;安全，10个安全策略组成的过滤链，并支持低成本的增加新策略，保证自动化任务是安全的&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在本文中，有一个重要的事项没有提到，就是环境初始化，这个再下一篇文章讲述。&lt;/p&gt;

&lt;hr/&gt;
&lt;p&gt;排列文字，重组感受。&lt;/p&gt;
&lt;p&gt;我是曲行人，日常写码，闲时写点儿文字，&lt;/p&gt;
&lt;p&gt;如果你觉得有点意思，或者有点用，可以关注我，&lt;/p&gt;
&lt;p&gt;我将在大脑里的思维原子做布朗运动时，输出文字。&lt;/p&gt;
&lt;p&gt;公众号: qxren7&lt;/p&gt;
&lt;p&gt;二维码: &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1904670/202001/1904670-20200101231416479-1679854444.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 02 Jan 2020 00:23:00 +0000</pubDate>
<dc:creator>曲行人</dc:creator>
<og:description>本篇开始介绍具体的实现过程，为表述方便，先定义一些名词， AutoRepairSystem:&amp;#160;故障自动维修系统, 缩写为ARS 原子操作：任务的最小操作，机器任务通常是指重启、重装 运维人员</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qxren7/p/12130927.html</dc:identifier>
</item>
<item>
<title>机器学习回顾篇（12）：集成学习之Bagging与随机森林 - 奥辰</title>
<link>http://www.cnblogs.com/chenhuabin/p/12131356.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenhuabin/p/12131356.html</guid>
<description>&lt;p&gt;在这两个条件前提下，对于第一个问题，有两种解决思路。一种是使用不同类别的算法来构建个体学习器，例如对于同一个任务分别使用决策树算法、支持向量机、神经网络等不同算法来构建学习器。另一种思路是所有个体学习器都使用同一种算法进行构建，这种思路是目前集成学习算法的主流。在所有个体学习器都使用同种算法构建时，如何保证学习器之间的差异性呢？有两种方案：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;每次训练个体学习器时，对原始数据集进行抽样获得不同数据集作为当前训练集，每一个训练样本在抽样训练集中可以多次或不出现，经过$T$次训练后，可得到$T$个不同的没有相互依赖的个体学习器学习器。Bagging、随机森林就是这种方案的代表。&lt;/li&gt;
&lt;li&gt;通过更新权重的方式不断地使用一个弱学习器弥补前一个弱学习器的“不足”的过程，来串行地构造一个较强的学习器，这个强学习器能够使目标函数值足够小。这一方案的代表是Boosting系列的算法，包括Adaboost、GBDT、XGBOOST等&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在本文中，我们先对第一种方案的两种算法——Bagging和随机森林进行介绍，在后续的博文中，再对Adaboost、GBDT等算法进行分析。&lt;/p&gt;

&lt;p&gt;Bagging是并行式集成学习方法的最典型代表，算法名称来源于Bootstrap aggregating的简写，又称装袋算法，这种算法直接采用自助采样法获得$T$个各不相同的数据集，分别使用这$T$个数据集进行训练可获得$T$个个体学习器，再将这些学习器组合起来共同完成分类或者回归任务。当完成分类任务时，采用简单投票法对$T$个体学习器结果进行组合后输出；当染成回归任务时，采用简单平均法对$T$个个体学习器学习结果进行组合输出。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAqsAAACdCAYAAACTpzFoAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAADt6SURBVHhe7Z0H2BXF9f8VFEuwIEUQpUgRAcUgUkWDigULWEBj7CBi1EQTDVH4RRPsFRuKioLG2HvBiKKi0quohKKCSlBAQBABBc7//x1nwrzzzt4td8vsvefzPOe5O7Oze2dnp+3MmTNbEcMwDMMwDMM4CndWGYZhGIZhGGfhzirDMAzDMAzjLNxZZRiGYRiGYZyFO6sMwzAMwzCMs3BnlWEYhmEYhnEW7qwyDMMwDMMwzsKdVYZhGIZhGMZZuLNaorzwwgvUt29fatOmDe2+++70m9/8hrbaaquCgjAI27VrVzr//PPppZdekndjmPKByw7DMIxbcGe1xHjzzTfp0EMPpV69etGoUaNo5syZ9M0338iz/iDsxx9/TA888ACdcMIJ1KFDB3r//fflWYYpXbjsMAzDuAl3VkuICy64gLp3707r1q2TPsWzZMkSOvjgg+nCCy+UPgxTenDZYRiGcRfurJYA69evp1q1atH9998vfeJn2LBhVKNGDfFfDFMqcNkpzGuvvUYDBgygtm3bUr169f6nErH11ltTlSpVqGrVqkK22WYb2nbbbalatWpCtttuO9p+++1phx12ELLjjjvSr371K6pevbqQnXbaiXbeeWfaZZddhOy6664ijXbbbTchNWvWFO+ldu3aQurUqSPULOrWrSsEcdljjz2ofv36Qvbcc0/aa6+9qEGDBkIaNmxIjRo1osaNGwvZe++9qUmTJtS0aVMhzZo1o+bNm9M+++wjpEWLFrTvvvtSy5YthbRq1Ypat25N++23n5D9999fqIUccMABQn7961+LNDnwwAOFtGvXjg466CBq3769EIyqd+zYkTp16iSkc+fO1KVLF/HxAoG6yCGHHCJG8vv160enn346XXXVVaw+wjAecGe1BEAjsHDhQulKjnnz5omGIg9wI8uNbBC47NiZNGkSHX744dSjRw8aMWIETZs2jf773//Ks0SbN2+mTZs20caNG4X8/PPP9NNPP9GGDRuEoGOOUeoff/xRyNq1a+mHH36gNWvWCFm9ejV9//33tGrVKiErV66kFStW0HfffSdk+fLltGzZMlq6dKmQ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&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;3.1-自助采样法&quot;&gt;3.1 自助采样法&lt;a class=&quot;anchor-link&quot; href=&quot;https://www.cnblogs.com/chenhuabin/p/12131356.html#3.1-自助采样法&quot;&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;自助采样法（Bootstrap sampling是一种从给定原始数据集中有放回的均匀抽样，也就是说，每当选中一个样本，它等可能地被再次选中并被再次添加到训练集中。对于给定包含$m$个样本的原始数据集$D$，进行自助采样获得$D'$，具体操作方式：每次采样时，从几何$D$中随机抽取一个样本拷贝一份到集合$D'$中，然后将样本放回集合$D$中，是的该羊被后续采样中仍有可能被采集到；重复这一步骤$m$次后，就可以获得同样包含$m$个样本的集合$D'$，集合$D'$就是自助采样的最终结果。可以想象，集合$D$中的样本有一部分会在集合$D'$中出现重复出现，而有些样本却一次都不出现。在$m$次抽样中，某个样本从未被抽到的概率为${(1 - \frac{1}{m})^m}$，当集合$D$样本足够多时有： $$\mathop {\lim }\limits_{m \to \infty } {(1 - \frac{1}{m})^m} = \frac{1}{e} \approx 0.368$$ 也就是说，原始集合$D$中有36.8%的样本不包含在通过自助采样法获得的集合$D'$中。在Bagging中，未被采集到的36.8%的样本可以用作测试集对个体学习器性能进行评估，当个体学习器使用决策树算法构建时，这部分用本可以用来辅助树剪枝；使用神经网络构建个体学习器时，可以用来防止过拟合。&lt;/p&gt;
&lt;h2 id=&quot;3.2-结合策略&quot;&gt;3.2 结合策略&lt;a class=&quot;anchor-link&quot; href=&quot;https://www.cnblogs.com/chenhuabin/p/12131356.html#3.2-结合策略&quot;&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;假设共有$T$个个体学习器，以$\{ {h_1},{h_2}, \cdots ,{h_T}\} $表示，其中样本$x$经$h_i$后的输出值为$h_i(x)$。对于结合$T$个个体学习器输出值，主要有一下几种策略：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）平均法&lt;/strong&gt; 平均法常用于回归类任务的数值型输出，包括简单平均法、加权平均法等。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;简单平均法&lt;/strong&gt; $$H(x) = \frac{1}{T}\sum\limits_{i = 1}^T {{h_i}(x)} $$&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;加权平均法&lt;/strong&gt; $$H(x) = \sum\limits_{i = 1}^T {{w_i}{h_i}(x)} $$ 式中，$w_i$是个体学习器$h_i$的权重，通常要求${w_i} \geqslant 0$且$\sum\limits_{i = 1}^T {{w_i}} = 1$。至于$w_i$的具体值，可以根据$h_i$的具体表现来确定，$h_i$准确率越高，$w_i$越大。&lt;br/&gt;对于两种平均法的选择上，当个体学习器性能相差较大时，选用加权平均法；当各个体学习器性能相近时，使用简单加权平均法。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;（2）投票法&lt;/strong&gt;&lt;br/&gt;投票法更多用于作为分类任务的集成学习的结合策略。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;相对多数投票法&lt;/strong&gt; 也可以认为是多数决策法，即预测结果中票数最高的分类类别。如果不止一个类别获得最高票，则随机选择一个作为最终类别。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;绝对多数投票法&lt;/strong&gt; 不光要求获得票数最高，而且要求票数过半，否则决绝输出。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;加权投票法&lt;/strong&gt; 与加权平均法类似，每个个体学习器的分类票数要乘以一个权重，最终将各个类别的加权票数求和，最大的值对应的类别为最终类别。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;（3）学习法&lt;/strong&gt;&lt;br/&gt;学习法是一种比平均法和投票法更为强大复杂的结合策略，学习法以所有个体学习器的输出作为一个数据集，额外使用一个学习器对该数据及进行学习，然后输出最终的结果。Stacking方法是学习法的一个经典代表，目前大多数应用中所说的学习法都是指Stacking方法。甚至因为Stacking方法的特殊性和复杂性，很多资料中将Stacking方法当做是与Bagging和Boosting一样的一类集成学习算法。&lt;br/&gt;Stacking方法中将之前提到的所有个体学习器称为初级学习器，将用于结合的学习器称为次级学习器。Stacking方法先从原始数据集训练处初级学习器，然后“生成”一个新的数据集用于训练次级学习器。在新的数据集中，初级学习器的输出被当做样本输出特征，而初始样本的类别标签人被当做新数据及的类别标签。（注：关于Stacking可以参考&lt;a href=&quot;https://www.cnblogs.com/wqbin/p/11634111.html&quot;&gt;这篇博客&lt;/a&gt;）&lt;/p&gt;
</description>
<pubDate>Wed, 01 Jan 2020 23:58:00 +0000</pubDate>
<dc:creator>奥辰</dc:creator>
<og:description>集成学习算法是当下炙手可热的一类算法，在诸多机器学习大赛中都频繁出现它的身影。准确来说，集成学习算法并不是一个单独的机器学习算法，而是通过构建多个学习器，博采众家之长，共同求解问题的一种思想。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chenhuabin/p/12131356.html</dc:identifier>
</item>
<item>
<title>聊聊多线程那一些事儿 之 五 async.await深度剖析 - 程序员修炼之旅</title>
<link>http://www.cnblogs.com/xiaoXuZhi/p/XYH_tsak_async_await.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaoXuZhi/p/XYH_tsak_async_await.html</guid>
<description>&lt;p&gt;　　 hello task,咱们又见面啦！！是不是觉得很熟读的开场白，哈哈你哟这感觉那就对了，说明你已经阅读过了我总结的前面4篇关于task的文章，谢谢支持！感觉不熟悉的也没有关系，在文章末尾我会列出前四篇文章的地址，可以点击详细阅读。&lt;/p&gt;
&lt;p&gt;    前几篇文章分享了以后，无论是公众号还是博客园，都有小伙伴问我async/await的专栏总结分享，既然这样，那今天我们就专门来聊聊关于async/await的那一些事，通过该文章你也该对async的使用还有更加清晰的理解，谢谢！&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;async/await入门：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    async也就是我们说的异步方法，不废话，也不先说那么多的大理论，先上一个简单的实例，通过这个简单的实例实现和asyncd 初相识！！&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
 {
     Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;主线程开始，线程ID：{Thread.CurrentThread.ManagedThreadId}\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 同步实现 &lt;/span&gt;
     AddSync(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);

     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 异步方法,没有 Await&lt;/span&gt;
     AddNoAwaitSyncHas(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);

     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 异步方法,有 Await&lt;/span&gt;
     AddHasAwaitAsync(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);

     Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;主线程结束，线程ID：{Thread.CurrentThread.ManagedThreadId}\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
     Console.ReadLine();
     &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
 }

 &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
 &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 同步计算两个数字之和
 &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
 &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;num1&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;参数1&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
 &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;num2&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;参数2&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
 &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
 &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; AddSync(&lt;span&gt;int&lt;/span&gt; num1, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; num2)
 {
     Thread.Sleep(&lt;/span&gt;&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;);
     Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;同步方法，线程ID：{Thread.CurrentThread.ManagedThreadId}\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
     &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; num1 +&lt;span&gt; num2;
 }

 &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
 &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 对两个数字求和 (异步方法,没有 Await)
 &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
 &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;num1&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;参数1&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
 &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;num2&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;参数2&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
 &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;&lt;span&gt;结果&lt;/span&gt;&lt;span&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
 &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; AddNoAwaitSyncHas(&lt;span&gt;int&lt;/span&gt; num1, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; num2)
 {
     Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;异步线程没有await前，线程ID：{Thread.CurrentThread.ManagedThreadId}\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 两个数字求和，假设其中会涉及到很耗时的逻辑&lt;/span&gt;
     Thread.Sleep(&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;);
     Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;异步线程没有await后，线程ID：{Thread.CurrentThread.ManagedThreadId}\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
     &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; num1 +&lt;span&gt; num2;
 }

 &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
 &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 对两个数字求和 (异步方法,有 Await)
 &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
 &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;num1&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;参数1&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
 &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;num2&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;参数2&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
 &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;&lt;span&gt;结果&lt;/span&gt;&lt;span&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
 &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; AddHasAwaitAsync(&lt;span&gt;int&lt;/span&gt; num1, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; num2)
 {
     Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;异步线程await前，线程ID：{Thread.CurrentThread.ManagedThreadId}\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 两个数字求和，假设其中会涉及到很耗时的逻辑&lt;/span&gt;
     &lt;span&gt;var&lt;/span&gt; add =&lt;span&gt; Add(num1, num2);
     &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; result = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; add;
     Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;异步线程await后，线程ID：{Thread.CurrentThread.ManagedThreadId}\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
     &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
 }

 &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
 &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Task 对两个数字求和
 &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
 &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;num1&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;参数1&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
 &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;num2&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;参数2&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
 &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;&lt;span&gt;结果&lt;/span&gt;&lt;span&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
 &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Task&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; Add(&lt;span&gt;int&lt;/span&gt; num1, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; num2)
 {
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 假设该逻辑执行起来很耗时&lt;/span&gt;
     &lt;span&gt;var&lt;/span&gt; task = Task.Run(() =&amp;gt;&lt;span&gt;
     {
         Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;我是Task内部执行开始：线程ID :{Thread.CurrentThread.ManagedThreadId}\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
         Thread.Sleep(&lt;/span&gt;&lt;span&gt;5000&lt;/span&gt;&lt;span&gt;);
         Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;我是Task内部执行结束：线程ID :{Thread.CurrentThread.ManagedThreadId}\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
         &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; num1 +&lt;span&gt; num2;
     });

     &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; task;
 }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;执行结果：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SIB9aSbJhQkXhVqr9ibQaFyLb1VPcPTJK3oerrl8z9TDvU61Uv5q23Ct3FJEibtF90EKMX823NX4IeUZ42OO3fibg/640?wx_fmt=png&quot; alt=&quot;&quot; data-ratio=&quot;0.623400365630713&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;547&quot;/&gt;&lt;/p&gt;

&lt;p&gt;结合代码和执行结果，我们分析可以得出以下一些结论：&lt;/p&gt;
&lt;p&gt;   1、通过async的写法和同步方法在实现和调用上都很相似&lt;/p&gt;
&lt;p&gt;   2、异步方法async如果没有await关键词，其整体执行都是在主线中运行&lt;/p&gt;
&lt;p&gt;    ----同步调用&lt;/p&gt;
&lt;p&gt;    3、异步方法async有await关键词，其线程执行分水岭就在await&lt;/p&gt;
&lt;p&gt;     ----await前，async执行还是在主线中执行&lt;/p&gt;
&lt;p&gt;     ----await后，async的执行逻辑会新开一个线程&lt;/p&gt;
&lt;p&gt;     ----也就是说，async其真正的异步还是await实现&lt;/p&gt;
&lt;p&gt;     ​----而await修饰的实际是一个task修饰的变量或者返回的类型为task的方法体&lt;/p&gt;
&lt;p&gt;     ​----所以最后的最后，async的异步还是通过task来实现的&lt;/p&gt;
&lt;p&gt;    4、await是不能单独使用，一定是在是和async成对使用&lt;/p&gt;
&lt;p&gt;     ----当然aysnc修饰的方法可以没有await关键词&lt;/p&gt;
&lt;p&gt;　　通过上面的一个简单实例，是不是发现要实现一个异步方法，是不是so easy，是的 ，你没说错，就是那么简单，但是也许你会问，干嘛实现一个异步方法整的的如此复杂，创建了这么多方法，是的，不急不急，我这样写，是为了更加清晰的明白其执行流程。好了，下面我们在一起来探讨一下aysnc/await的组成结构吧！&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;aysnc/await的组成结构：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;其实异步方法的整体结构和一个普通的方法没有多大区别，唯一不一样的点，就是多了一个task逻辑主体，下面简单的分别来概要说明一下每一个环节：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; src=&quot;https://mmbiz.qlogo.cn/mmbiz_png/SIB9aSbJhQkXhVqr9ibQaFyLb1VPcPTJKSSWmSiaCgnXmg7wHdUQbiaSAibqIiba4jibntFclTrDNmjfBiadicT9WNQZNA/0?wx_fmt=png&quot; alt=&quot;&quot; data-s=&quot;300,640&quot; data-ratio=&quot;0.5793650793650794&quot; data-w=&quot;630&quot; data-type=&quot;png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    上面的图简单的绘制了一个异步方法在整体执行时的一个执行顺序。&lt;/p&gt;
&lt;p&gt;异步方法调用&lt;/p&gt;
&lt;p&gt;    个人觉得这个没有什么说的，其实很普通方法调用一样，只是说异步方法的调用结果一般为一个Task对象，那么需要获获取其执行结果的值，或者对执行结果需要做一些逻辑处理，这个和操作一个普通的task一样，这儿就不在细说，不清楚的可以看我前面分享的几篇文章，会有详细的说明，谢谢！&lt;/p&gt;
&lt;p&gt;aysnc的方法体&lt;/p&gt;
&lt;p&gt;    通过实例我们应该已经知道，其实异步方法，也就是在普通的方法体上，加了一个async修饰罢了，其简单的结构大概是&lt;/p&gt;
&lt;p&gt;    private aysnc task MyAysnc(){具体方法实现}&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;说说aysnc的返回类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    其返回类型有三种情况，每一种情况适用于不同的业务场景，如下：&lt;/p&gt;
&lt;p&gt;    A、Tsak：其主要适用场景是，主程序只关心异步方法执行状态，不需要和主线程有任何执行结果数据交互。&lt;/p&gt;
&lt;p&gt;    B、Task&amp;lt;T&amp;gt;：其主要适用场景是，主程序不仅仅关心异步方法执行状态，并且还希望执行后返回一个数据类型为T的结果&lt;/p&gt;
&lt;p&gt;    C、void: 主程序既不关系异步方法执行状态，也不关心其执行结果，只是主程序调用一次异步方法，对于除事件处理程序以外的代码，通常不鼓励使用 async void 方法，因为调用方不能&lt;/p&gt;
&lt;p&gt;task逻辑主体&lt;/p&gt;
&lt;p&gt;    aysnc为了实现异步，其中最关键的一个点就是await修饰符，await修饰的也就是task实现逻辑主体。task实现逻辑主体，其实在上就是一个task实例，所以其里面的实例逻辑使用和一个普通的task实例定义操作都是一样的，在此也就不在详细说明，前面的几篇文章也有详细的说明了，如果不清楚的可以查看以前的几篇文章。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;aysnc/await的原理分析：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;    在说这一块之前，我们先把写的代码编译后，在通过反编译后发现在代码里面根本找不到aysnc/await关键词，有兴趣的小伙伴，你也可以这样操作分析一下。那么我们就明白了aysnc/await其实是编译器层面给的一个语法糖，是为了方便实现一个异步方罢了。&lt;/p&gt;
&lt;p&gt;从反编译后的代码看出编译器新生成一个继承IAsyncStateMachine 的状态机结构asyncd（代码中叫&amp;lt;AddHasAwaitAsync&amp;gt;d__2)，下面是基于反编译后的代码来分析的。&lt;/p&gt;
&lt;p&gt;IAsyncStateMachine最基本的状态机接口定义：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IAsyncStateMachine {       
 &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; MoveNext();       
 &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; SetStateMachine(IAsyncStateMachine stateMachine); 
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;    好了，说道这儿我们已经知道aysnc/await是编程器层面的一个语法糖，那么我们在来分析一下其执行的流程如下：&lt;/p&gt;
&lt;p&gt;    第一步：主线程调用 AddHasAwaitAsync(1,2)异步方法&lt;/p&gt;
&lt;p&gt;   第二步：AddHasAwaitAsync()方法内初始化状态机状态为-1，启动&amp;lt;AddHasAwaitAsync&amp;gt;d__2&lt;/p&gt;
&lt;p&gt;    第三步：MoveNext方法内部开始执行，task.run实现了把业务逻辑执行丢到线程池中，返回一个可等待的任务句柄。其底层还是借助委托实现。&lt;/p&gt;
&lt;p&gt;    第四步：到此程序以及开启了两个线程，一个主线程，一个task线程，两个线程相互独立互不阻塞，各自执行对应的业务逻辑。&lt;/p&gt;
&lt;p&gt;    好了，时间不早了，就先到这儿吧，感觉这一篇文章总结的不怎么好，先这样，后续我们在持续交流，谢谢！&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;猜您喜欢：&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;　第一篇：&lt;a href=&quot;https://www.cnblogs.com/xiaoXuZhi/p/XYH_tsak_one.html&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;聊聊多线程哪一些事儿（task）之 一创建运行与阻塞&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　第二篇：&lt;a href=&quot;https://www.cnblogs.com/xiaoXuZhi/p/XYH_tsak_WhenAll.html&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;聊聊多线程哪一些事儿（task）之 二 延续操作&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　第三篇：&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/xiaoXuZhi/p/XYH_tsak_WhenAny1.html&quot;&gt;聊聊多线程那一些事儿（task）之 三 异步取消和异步方法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　第四篇：&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/xiaoXuZhi/p/XYH_Task_o4.html&quot;&gt;聊聊多线程那一些事儿 之 四 经典应用（取与舍、动态创建）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;END&lt;br/&gt;为了更高的交流，欢迎大家关注我的公众号，扫描下面二维码即可关注，谢谢：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/381957/201912/381957-20191228212329551-622814065.jpg&quot; alt=&quot;&quot; width=&quot;262&quot; height=&quot;262&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 01 Jan 2020 16:30:00 +0000</pubDate>
<dc:creator>程序员修炼之旅</dc:creator>
<og:description>前面已经讲解了task的运行、阻塞、同步、延续操作、取消等！今天我们就专门来聊聊关于async/await的那一些事，分析其实现原理，通过该文章你也该对async的使用还有更加清晰的理解</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiaoXuZhi/p/XYH_tsak_async_await.html</dc:identifier>
</item>
<item>
<title>内存管理、磁盘和文件拾遗 - 鸢翔赤空</title>
<link>http://www.cnblogs.com/xuewei/p/12131005.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuewei/p/12131005.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/549159/202001/549159-20200101233838980-1118566795.jpg&quot; alt=&quot;mr-cup-fabien-barral-o6GEPQXnqMY-unsplash&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;part1.-内存管理&quot;&gt;Part1. 内存管理&lt;/h2&gt;
&lt;p&gt;一个程序的可执行文件在内存中的结果，从大的角度可以分为两个部分：只读部分和可读写部分。只读部分包括程序代码（.text）和程序中的常量（.rodata）。&lt;br/&gt;可读写部分（变量）大致可分为下面几个部分：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;.data&lt;/code&gt;：初始化了的全局变量和静态变量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.bss&lt;/code&gt;：即 &lt;code&gt;Block Started by Symbol&lt;/code&gt;，未初始化的全局变量和静态变量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;heap&lt;/code&gt;：堆，使用 &lt;code&gt;malloc&lt;/code&gt;、&lt;code&gt;realloc&lt;/code&gt;和&lt;code&gt;free&lt;/code&gt;函数控制的变量，堆在所有的线程，共享库，和动态加载的模块中被共享使用。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stack&lt;/code&gt;：栈，函数调用时使用栈来保存函数现场，自动变量（即生命周期限制在某个 scope 的变量）也存放在栈中。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;data-和-.bss-区&quot;&gt;1. &lt;code&gt;.data&lt;/code&gt; 和 &lt;code&gt;.bss&lt;/code&gt; 区&lt;/h3&gt;
&lt;p&gt;这两个经常放在一起说，因为他们都是用来存储全局变量和静态变量的，区别在于 &lt;code&gt;.data&lt;/code&gt; 区存放的初始化过的，&lt;code&gt;.bss&lt;/code&gt;区存放的是没有初始化过的。例如：&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;int val = 3;
char string[] = 'Hello World';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这两个变量的值会在一开始被存储在 &lt;code&gt;.text&lt;/code&gt; 中，因为值是写在代码里面的，在程序启动时会拷贝到 &lt;code&gt;.data&lt;/code&gt; 区中。&lt;br/&gt;若不初始化，类似:&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;static int i;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个变量就会被放在 &lt;code&gt;.bss&lt;/code&gt; 区中。&lt;/p&gt;
&lt;h4 id=&quot;静态变量和全局变量&quot;&gt;静态变量和全局变量&lt;/h4&gt;
&lt;h5 id=&quot;全局变量&quot;&gt;全局变量&lt;/h5&gt;
&lt;p&gt;在一个代码文件中，一个变量要么定义在函数中，要么定义在函数外。当定义在函数外时，这个变量就有了全局作用域，成为了全局变量。&lt;br/&gt;全局变量不光意味着这个变量可以在整个文件中使用，也意味着这个变量可以在其他文件中使用（这种叫 &lt;code&gt;external linkage&lt;/code&gt;）。&lt;br/&gt;当有如下两个文件时：&lt;br/&gt;A.c&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
int a;
int compute(void);
int main()
{
    a = 1;
    printf(&quot;%d %d&quot;, a, compute());
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;B.c&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;int a;
int compute(void)
{
    a = 0;
    return a;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在编译过程中会产生重复定义的错误！因为有两个全局的 a 变量，编译器不知道应该使用哪一个，为了避免这种问题，就需要引入 &lt;code&gt;static&lt;/code&gt;。&lt;/p&gt;
&lt;h5 id=&quot;静态变量&quot;&gt;静态变量&lt;/h5&gt;
&lt;p&gt;使用 &lt;code&gt;static&lt;/code&gt; 关键字修饰的变量，&lt;code&gt;static&lt;/code&gt; 关键字对变量的作用域进行了限制，具体的限制如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在函数外定义：全局变量，但是只在当前文件中可见（叫做 internal linkage）。&lt;/li&gt;
&lt;li&gt;在函数内定义：全局变量，但是只在此函数内可见（同时，在多次函数调用中，变量的值不会丢失）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;C++&lt;/code&gt; 在类中定义：全局变量，但是只在此类中可见&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于全局变量来说，为了避免上面提到的重复定义错误，我们可以在一个文件中使用 &lt;code&gt;static&lt;/code&gt;，另一个不使用，这样使用 &lt;code&gt;static&lt;/code&gt; 的就会使用自己的 a 变量，而没有用 &lt;code&gt;static&lt;/code&gt; 的会使用全局的 a 变量。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注意：&lt;code&gt;静态&lt;/code&gt;这个中文翻译有点莫名其妙，给人的感觉像是不可改变的，实际上&lt;code&gt;static&lt;/code&gt; 跟不可改变没有关系，不可改变的变量使用 &lt;code&gt;const&lt;/code&gt; 关键字修饰！！！&lt;/em&gt;&lt;/p&gt;
&lt;h5 id=&quot;extern&quot;&gt;&lt;code&gt;extern&lt;/code&gt;&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;extern&lt;/code&gt; 是 C 语言的另一个关键字，用来指示变量或函数的定义在别的文件中，使用 &lt;code&gt;extern&lt;/code&gt; 可以在多个源文件中共享某个变量。&lt;/p&gt;
&lt;h4 id=&quot;程序在内存和硬盘上不同的存在形式&quot;&gt;程序在内存和硬盘上不同的存在形式&lt;/h4&gt;
&lt;p&gt;这里提到的四个区，是指程序在&lt;strong&gt;内存&lt;/strong&gt;中存在的形式，和程序在&lt;strong&gt;硬盘&lt;/strong&gt;上存储的格式不是完全对应的。程序在硬盘上存储的格式更加复杂，而且是和操作系统有关的，具体可以参考：&lt;a href=&quot;https://en.wikipedia.org/wiki/Comparison_of_executable_file_formats&quot;&gt;wikipedia&lt;/a&gt;。&lt;br/&gt;一个明显的例子区分这个差别：&lt;br/&gt;之前提到的未定义的全局变量存储在 &lt;code&gt;.bss&lt;/code&gt; 区，这个区域不会占用可执行文件的空间（一般只存储这个区域的长度），但是却会占用内存空间。这些变量没有定义，因此可执行文件中不需要存储他们的值，在程序启动过程中，他们的值会被初始化成 0，存储在内存中。&lt;/p&gt;
&lt;h3 id=&quot;栈&quot;&gt;2. 栈&lt;/h3&gt;
&lt;p&gt;栈是用于存放本地变量，内部临时变量以及有关上下文的内存区域。程序在调用函数时，操作系统会自动通过压栈和弹栈完成保存函数现场等操作，不需要程序员手动干预。&lt;br/&gt;栈是一块连续的内存区域，栈顶的地址和栈的最大容量是系统预先规定好的，能从栈获得的空间较小。如果申请的空间超过栈的剩余空间时，例如递归深度过深，将提示：&lt;code&gt;stackoverflow&lt;/code&gt;。&lt;br/&gt;栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈、出栈都有专门的指令执行，这就决定了栈的效率比较高。&lt;/p&gt;
&lt;h3 id=&quot;堆&quot;&gt;3. 堆&lt;/h3&gt;
&lt;p&gt;堆是用于存放除了栈里的东西之外所有其他东西的内存区域，当使用 &lt;code&gt;malloc&lt;/code&gt; 和 &lt;code&gt;free&lt;/code&gt; 时就是在操作堆中的内存。对于堆来说，释放工作由程序员控制，容易产生 &lt;code&gt;memory leak&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;堆是向高地址扩展的数据结构，是不连续的内存区域。这里由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。&lt;/p&gt;
&lt;p&gt;对于堆而言，频繁的 &lt;code&gt;new&lt;/code&gt;/&lt;code&gt;delete&lt;/code&gt; 势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈而言，则不会出现这个问题，因为栈是先进后出的队列，永远都不可能有一个内存块从栈中间弹出。&lt;/p&gt;
&lt;p&gt;堆都是动态分配的，没有静态分配的堆。栈有两种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由 &lt;code&gt;alloca&lt;/code&gt; 函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。&lt;/p&gt;
&lt;p&gt;计算机底层并没有对堆的支持，堆则是 C/C++ 函数库提供的，同时由于上面提到的碎片问题，都会导致堆的效率比栈要低。&lt;/p&gt;
&lt;h2 id=&quot;part.2-内存分配&quot;&gt;Part.2 内存分配&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;虚拟地址：用户编译时将代码（或数据）分成若干个段，每条代码或每个数据的地址由段名称 + 段内相对地址构成，这样的程序地址称为虚拟地址。&lt;/li&gt;
&lt;li&gt;逻辑地址：虚拟地址中，段内相对地址部分称为逻辑地址。&lt;/li&gt;
&lt;li&gt;物理地址：实际物理内存中所看到的存储地址称为物理地址。&lt;/li&gt;
&lt;li&gt;逻辑地址空间：在实际应用中，将虚拟地址和逻辑地址经常不加以区分，通称为逻辑地址，逻辑地址的几个称为逻辑地址空间。&lt;/li&gt;
&lt;li&gt;线性地址空间：CPU 地址总线可以访问的所有地址合称为线性地址空间。&lt;/li&gt;
&lt;li&gt;物理地址空间：实际存在的可访问的物理内存地址集合称为物理地址空间。&lt;/li&gt;
&lt;li&gt;MMU（Memery Management Unit）内存管理单元：实现将用户程序的虚拟地址（逻辑地址）-&amp;gt; 物理地址映射的 CPU 中的硬件电路。&lt;/li&gt;
&lt;li&gt;基地址：在进行地址映射时，经常以段或页为单位并以其最小地址（即起始地址）为基值来进行计算。&lt;/li&gt;
&lt;li&gt;偏移量：在以段或页为单位进行地址映射时，相对于基地址的地址值。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;虚拟地址先经过分段机制映射到线性地址，然后线性地址通过分页机制映射到物理地址。&lt;/p&gt;
&lt;h2 id=&quot;part.3-虚拟内存&quot;&gt;Part.3 虚拟内存&lt;/h2&gt;
&lt;h3 id=&quot;请求调页&quot;&gt;请求调页&lt;/h3&gt;
&lt;p&gt;也成为按需调页，即对不在内存中的“页”，当进程执行时才调入，否则有可能到程序结束时也不会调入。&lt;/p&gt;
&lt;h3 id=&quot;页面置换算法&quot;&gt;页面置换算法&lt;/h3&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;FIFO 算法&lt;br/&gt;先入先出，即淘汰最早调入的页面。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;OPT（MIN） 算法&lt;br/&gt;选未来最远将使用的页淘汰，是一种最优的方案，可以证明缺页数最小。&lt;br/&gt;可惜，MIN 需要知道将来发生的事，只能在理论中存在，实际不可应用。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;LRU（Least-Recently-Used） 算法&lt;br/&gt;用过去的历史预测将来，选最近最长时间没有使用的页淘汰（也称最近最少使用）。LRU 准确实现：计数器法，页码栈法。由于代价较高，通常不使用准确实现，而是采用近似实现，例如 &lt;code&gt;Clock&lt;/code&gt; 算法。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;内存抖动&quot;&gt;内存抖动&lt;/h3&gt;
&lt;p&gt;页面的频繁更换，导致整个系统效率急剧下降，这个现象称为内存抖动（或颠簸）。&lt;br/&gt;抖动一般是内存分配算法不好，内存太小引起或者程序的算法不佳引起的。&lt;/p&gt;
&lt;h3 id=&quot;belady-现象&quot;&gt;&lt;code&gt;Belady&lt;/code&gt; 现象&lt;/h3&gt;
&lt;p&gt;对有的页面置换算法，页错误率可能会随着分配帧数的增加而增加。&lt;br/&gt;FIFO 会产生 &lt;code&gt;Belady&lt;/code&gt; 异常。&lt;br/&gt;栈式算法无 &lt;code&gt;Belady&lt;/code&gt; 异常，LRU、LFU（最不经常使用）、OPT 都属于栈式算法。&lt;/p&gt;
&lt;h2 id=&quot;part.4-磁盘调度&quot;&gt;Part.4 磁盘调度&lt;/h2&gt;
&lt;p&gt;磁盘访问延迟 = 队列时间 + 控制器时间 + 寻道时间 + 旋转时间 + 传输时间。&lt;br/&gt;磁盘调度的目的是减小延迟，其中前两项可以忽略，寻道时间是主要矛盾。&lt;/p&gt;
&lt;h3 id=&quot;磁盘调度算法&quot;&gt;磁盘调度算法&lt;/h3&gt;
&lt;ul readability=&quot;8&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;FCFS&lt;br/&gt;先进先出的调度策略，这个策略具有公平的优点，因为每个请求都会得到处理，并且是按照接收到的顺序进行处理。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;SSTF（Shortest-seek-time 最短寻道时间优先）&lt;br/&gt;选择使磁头从当前位置开始移动最少的磁盘 I/O 请求，所以 SSTF 总是选择导致最小寻道时间的请求。&lt;br/&gt;总是选择最小寻找时间并不能保证平均寻找时间最小，但是能提供比 FCFS 算法更好的性能，会存在饥饿现象。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;SCAN&lt;br/&gt;SSTF + 中途不回折，每个请求都有处理机会。&lt;br/&gt;SCAN 要求磁头仅仅沿一个方向移动，并在途中满足所有未完成的请求，直到它到达这个方向上的最后一个磁道，或者在这个方向上没有其他请求为止。&lt;br/&gt;由于磁头移动规律与电梯运行相似，SCAN 也被称为电梯算法。&lt;br/&gt;SCAN 算法对最近扫描过的区域不公平，因此，它的访问局部性方面不如 FCFS 算法和 SSTF 算法好。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;C-SCAN&lt;br/&gt;SCAN + 直接移到另一端，两端请求都能很快处理。&lt;br/&gt;把扫描限定在一个方向，当访问到某个方向的最后一个磁道时，磁道返回磁盘相反方向磁道的末端，并再次开始扫描。&lt;br/&gt;其中 “C” 是 &lt;code&gt;Circular(环)&lt;/code&gt;的意思。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;LOOK 和 C-LOOK&lt;br/&gt;采用 SCAN 算法和 C-SCAN 算法时磁头总是严格地遵循从盘面的一端到另一端，显然，在实际使用时还可以改进，即磁头移动只需要到达最远端的一个请求即可返回，不需要到达磁盘端点。这种形式的 SCAN 算法和 C-SCAN 算法称为 LOOK 和 C-LOOK 调度。这是因为它们在朝一个给定方向移动前会查看是否有请求。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;part5.-文件系统&quot;&gt;Part5. 文件系统&lt;/h2&gt;
&lt;h3 id=&quot;分区表&quot;&gt;分区表&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;MBR：支持最大卷为 2TB（Terabytes），并且每个磁盘最多有 4 个主分区（或 3 个主分区、1 个扩展分区和无限制的逻辑驱动器）&lt;/li&gt;
&lt;li&gt;GPT：支持最大卷为 18EB（Exabytes），并且每磁盘的分区数没有上限，只受到操作系统限制，由于分区表本身需要占用一定空间，最初规划硬盘分区时，留给分区表的空间决定了最多可以有多少个分区，IA-64版 Windows 限制最多有 128 个分区，这也是 EFI 标准规定的分区表的最小尺寸。另外 GPT 分区磁盘有备份分区表来提高分区数据结构的完整性。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;raid-技术&quot;&gt;RAID 技术&lt;/h3&gt;
&lt;p&gt;独立硬盘冗余阵列（RAID, Redundant Array of Independent Disks），旧称廉价磁盘冗余阵列（Redundant Array of Inexpensive Disks），简称磁盘阵列。利用虚拟化存储技术把多个硬盘组合起来，成为一个或多个硬盘阵列组，目的为提升性能或数据冗余，或是两者同时提升。&lt;/p&gt;
&lt;p&gt;在运作中，取决于 RAID 层级不同，数据会以多种模式分散于各个硬盘，RAID 层级的命名会以 RAID 开头并带数字，例如：RAID 0、RAID 1、RAID 5、RAID 6、RAID 7、RAID 01、RAID 10、RAID 50、RAID 60。每种等级都有其理论上的优缺点，不同的等级在两个目标间获取平衡，分别是增加数据可靠性以及增加存储器（群）读写性能。&lt;/p&gt;
&lt;ul readability=&quot;21.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;RAID 0&lt;br/&gt;RAID 0 是最早出现的 RAID 模式，需要两块以上的硬盘，可以提高整个磁盘的性能和吞吐量。&lt;br/&gt;RAID 0 没有提供冗余或错误修复能力，其中一块硬盘损坏，所有的数据将遗失。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/549159/202001/549159-20200101233839419-835994492.jpg&quot; alt=&quot;-w183&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;RAID 1&lt;br/&gt;RAID 1 就是镜像，其原理为在主硬盘上存放数据的同时也在镜像硬盘上写一样的数据，当主硬盘（物理）损坏时，镜像硬盘则代替主硬盘的工作。因为有镜像硬盘做数据备份，所以 RAID 1 的数据安全性在所有 RAID 级别上来说是最好的。&lt;br/&gt;但无论用多少磁盘做 RAID 1，仅算一个磁盘的容量，是所有 RAID 中磁盘利用率最低的。&lt;br/&gt;实际容量：&lt;code&gt;Size = min(S1, S2, S3 ... Sn)&lt;/code&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/549159/202001/549159-20200101233839677-1004390545.jpg&quot; alt=&quot;-w175&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;RAID 2&lt;br/&gt;这是 RAID 0 的改良版，以汉明码（Hamming Code）的方式将数据进行编码后分区为独立的比特，并将数据分别写入硬盘中。因为在数据中加入了错误修正码（ECC，Error Correction Code），所以数据整体的容量会比原始数据大一些，RAID 2 至少需要三台磁盘驱动器方能运作。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/549159/202001/549159-20200101233840225-654627377.jpg&quot; alt=&quot;-w348&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;RAID 3&lt;br/&gt;采用 Bit-interleaving（数据交错存储）技术，它需要通过编码再将数据比特分割后分别存在磁盘中，而将同比特检查后单独存在一个硬盘中，但由于数据内的比特分散在不同的硬盘上，因此就算要读取一小段数据资料都可能需要所有的硬盘进行工作，所以这种规格比较适用于读取大量数据时使用。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/549159/202001/549159-20200101233840785-1915410220.jpg&quot; alt=&quot;-w258&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;RAID 4&lt;br/&gt;它与 RAID 3 不同的是它在分区时是以区块为单位分别存在硬盘中，但每次的数据访问都必须从同比特检查的那个硬盘中取出对应的同比特数据进行核对，由于过于频繁的使用，所以对硬盘的损耗可能会提高。（快交织技术，Block interleaving）。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/549159/202001/549159-20200101233841067-1605188256.jpg&quot; alt=&quot;-w256&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RAID 2、3、4 在实际应用中很少使用&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;RAID 5&lt;br/&gt;RAID Level 5 是一种存储性能、数据安全和存储成本兼顾的存储解决方案，他使用的是 Disk Striping（硬盘分区）技术。&lt;br/&gt;RAID 5 至少需要三块硬盘，RAID 5 不是对存储的数据进行备份，而是把数据和相对应的数据分别存储于不同的磁盘上。&lt;br/&gt;RAID 5 允许一块硬盘损坏。&lt;br/&gt;实际容量：&lt;code&gt;Size = (N - 1) * min(S1, S2, S3... SN)&lt;/code&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/549159/202001/549159-20200101233841726-611217344.jpg&quot; alt=&quot;-w263&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;RAID 6&lt;br/&gt;与 RAID 5 相比，RAID 6 增加第二个独立的奇偶校验信息块。两个独立的奇偶系统使用不同的算法，数据的可靠性非常高，即使两块磁盘同时失效也不会影响数据的使用。&lt;br/&gt;RAID 6 至少需要 4 块硬盘。&lt;br/&gt;实际容量：&lt;code&gt;Size = (N - 2) * min(S1, S2, S3 ... SN)&lt;/code&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/549159/202001/549159-20200101233842897-316755807.jpg&quot; alt=&quot;-w304&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;RAID 10/01 (RAID 1 + 0, RAID 0 + 1)&lt;br/&gt;RAID 10 是先镜射再分区数据，再将所有硬盘分为两组，视为是 RAID 0 的最低组合，然后将这两组各自视为 RAID 1 运作。&lt;br/&gt;RAID 01 则是跟 RAID 10 的程序相反，是先分区再将数据镜射到两组硬盘。它将所有的硬盘分为两组，变成 RAID 1 的最低组合，而将两组硬盘各自视为 RAID 0 运作。&lt;br/&gt;当 RAID 10 有一个硬盘受损，其余硬盘会继续运作，RAID 01 只要有一个硬盘受损，同组 RAID 0 的所有硬盘都会停止运作，只剩下其他组的硬盘运作，可靠性较低。&lt;br/&gt;如果以 6 个硬盘建 RAID 01，镜射再用三个建 RAID 0，那么坏一个硬盘便会有三个硬盘脱机，因此，RAID 10 远比 RAID 01 常用，零售主板绝大多数支持 RAID 0/1/5/10, 但不支持 RAID 01.&lt;br/&gt;RAID 10 至少需要 4 块硬盘，且硬盘数量必须为偶数。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/549159/202001/549159-20200101233844344-1229160770.jpg&quot; alt=&quot;-w271&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;常见的文件系统&quot;&gt;常见的文件系统&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;Windows：FAT，FAT16，FAT32，NTFS&lt;/li&gt;
&lt;li&gt;Linux：ext2/3/4，btrfs，ZFS&lt;/li&gt;
&lt;li&gt;Mac OS X：HFS+&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h3 id=&quot;更多干货文章&quot;&gt;更多干货文章&lt;/h3&gt;
&lt;h5 id=&quot;博客www.qiuxuewei.com&quot;&gt;博客：&lt;a href=&quot;http://www.qiuxuewei.com&quot;&gt;www.qiuxuewei.com&lt;/a&gt;&lt;/h5&gt;
&lt;h5 id=&quot;微信公众号开发者成长之路&quot;&gt;微信公众号：&lt;strong&gt;@开发者成长之路&lt;/strong&gt;&lt;/h5&gt;
&lt;h5 id=&quot;公众号二维码&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/549159/202001/549159-20200101233844580-1043726677.png&quot; alt=&quot;公众号二维码&quot;/&gt;&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;一个没有鸡汤只有干货的公众号&lt;/strong&gt;&lt;br/&gt;****************************************************&lt;/p&gt;
</description>
<pubDate>Wed, 01 Jan 2020 15:39:00 +0000</pubDate>
<dc:creator>鸢翔赤空</dc:creator>
<og:description>内存管理、磁盘和文件拾遗 Part1. 内存管理 一个程序的可执行文件在内存中的结果，从大的角度可以分为两个部分：只读部分和可读写部分。只读部分包括程序代码（.text）和程序中的常量（.rodata</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xuewei/p/12131005.html</dc:identifier>
</item>
<item>
<title>消息队列介绍 - Yabea</title>
<link>http://www.cnblogs.com/ybjourney/p/12130985.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ybjourney/p/12130985.html</guid>
<description>&lt;p&gt;本文将介绍大名鼎鼎的消息队列（MQ）的原理，应用场景和常见问题。&lt;/p&gt;
&lt;p&gt;日常开发中，可能会经常遇到这几类问题：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;系统中批量更新（增，删，改）功能接口，如果业务比较复杂，加之数据量庞大，这类同步操作是很耗时的，这时候需要进行&lt;strong&gt;异步处理&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;电子商务网站在促销活动时，会在短时间内高并发，需要&lt;strong&gt;削平高峰期的并发事务&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;为了提高系统的可扩展性，希望各个模块之间不存在直接调用，开发低耦合的系统，对各个模块之间进行&lt;strong&gt;解耦&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;以上场景，都可以使用消息队列有效解决。&lt;/p&gt;
&lt;h2 id=&quot;什么是消息队列&quot;&gt;什么是消息队列？&lt;/h2&gt;
&lt;p&gt;消息(Message)是指在应用间传送的数据（比如字符串，json等），消息队列（Message Queue，简称MQ）是一个古老的计算机术语，UNIX进程间通信就用到了消息队列技术：一个进程把数据写入某个特定队列中，其它队列读取特定队列中的数据实现异步通信。而现在我们所说的MQ通常指的是独立的消息队列中间件，利用高效可靠的消息传递机制进行与平台无关的数据交流，并基于数据通信来进行分布式系统的集成。&lt;/p&gt;
&lt;h3 id=&quot;传递模式&quot;&gt;传递模式&lt;/h3&gt;
&lt;p&gt;消息队列一般有两种传递模式：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;点对点（Point to Point，简称PTP）：消息生产者发送消息到队列，消费者从队列中接收消息。消息被消费以后，queue中不再存储，queue支持存在多个消费者，但是一个消息只能被一个消费者消费。&lt;/li&gt;
&lt;li&gt;发布 / 订阅（Pub / Sub）：发布订阅（一对多）广播形式，消息发布者将消息发布到某个主题(Topic），消息订阅者从主题中订阅消息（得到消息的拷贝），一个消息可以同时被多个消费者订阅，并会被所有订阅者消费。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;组成&quot;&gt;组成&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;Broker: 消息服务器，作为server提供消息核心服务&lt;/li&gt;
&lt;li&gt;Producer：消息生产者，业务的发起方，生产消息传输给broker&lt;/li&gt;
&lt;li&gt;Consumer：消息消费者，业务处理方，负责从broker获取消息并进行业务逻辑处理&lt;/li&gt;
&lt;li&gt;Topic：主题，Pub/sub模式下 消息统一汇聚地，不同生产者向topic发送消息，由MQ服务器分发到不同订阅者，实现消息的广播。&lt;/li&gt;
&lt;li&gt;Queue：队列，PTP模式下，特定生产者向特定队列发送消息，消费者订阅特定的queue完成指定消息的接收与消费。&lt;/li&gt;
&lt;li&gt;Message：消息体，根据不同通信协议定义的固定格式编码数据包，来封装业务数据，实现消息的传输。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;消息队列的作用&quot;&gt;消息队列的作用&lt;/h2&gt;
&lt;p&gt;介绍几个消息队列的重要作用：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;解耦：&lt;/strong&gt;传统的软件开发模式，各个模块之间相互调用，数据共享，每个模块都要时刻关注其他模块的是否更改或者是否挂掉等等，使用消息队列，可以避免模块之间直接调用，将所需共享的数据放在消息队列中，对于新增业务模块，只要对该类消息感兴趣，即可订阅该类消息，对原有系统和业务没有任何影响，降低了系统各个模块的耦合度，提高了系统的&lt;strong&gt;可扩展性&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;异步：&lt;/strong&gt;消息队列提供了异步处理机制，在很多时候应用不想也不需要立即处理消息，允许应用把一些消息放入消息中间件中，并不立即处理它，在之后需要的时候再慢慢处理。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;削峰：&lt;/strong&gt;在访问了骤增的场景下，需要保证应用系统的平稳性，但是这样突发流量并不常见，如果以这类峰值的标准而投放资源的话，那无疑是巨大的浪费，使用消息队列能够使关键组件支撑突发访问压力，不会因为突发的超负荷请求而完全崩溃。消息队列的容量可以配置的很大，如果采用磁盘存储消息，则几乎等于“无限”容量，这样一来，高峰期的消息可以被积压起来，在随后的时间内进行平滑的处理完成，而不至于让系统短时间内无法承载而导致崩溃，在电商网站的秒杀抢购这种突发性流量很强的业务场景中，消息队列的强大缓冲能力可以很好的起到削峰作用。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;消息队列技术选型&quot;&gt;消息队列技术选型&lt;/h2&gt;
&lt;p&gt;现在有很多主流的消息中间件，包括：ActiveMQ, RabbitMQ，Kafka, RocketMQ，Redis。选型时要结合具体的应用场景和自身的业务需求，从功能、性能、运维、可靠性+可用性等维度进行多重考量。&lt;/p&gt;
&lt;h3 id=&quot;activemq&quot;&gt;ActiveMQ&lt;/h3&gt;
&lt;p&gt;Apache出品，Java开发，目前所占的市场份额不多。&lt;/p&gt;
&lt;h3 id=&quot;rabbitmq&quot;&gt;RabbitMQ&lt;/h3&gt;
&lt;p&gt;Erlang语言实现AMQP协议的消息中间件，并发能力很强，性能及其好，延时很低（达到微妙级），特点：可靠性，可用性，扩展性，功能丰富。&lt;/p&gt;
&lt;h3 id=&quot;kafka&quot;&gt;Kafka&lt;/h3&gt;
&lt;p&gt;LinkedIn使用Scala开发的分布式，多分区，多副本且基于zookeeper协调的分布式消息系统，提供了超高的吞吐量，毫秒级延迟，极高的可用性和可靠性。&lt;/p&gt;
&lt;h3 id=&quot;rocketmq&quot;&gt;RocketMQ&lt;/h3&gt;
&lt;p&gt;阿里出品，Java开发，高吞吐，高可用，适合大规模分布式应用，经过多次双十一的洗礼，实力不容小觑。&lt;/p&gt;
&lt;p&gt;所谓的&lt;strong&gt;消息中间件大道至简：一发一存一消费，没有最好的消息中间件，只有最合适的消息中间件。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;带来的问题&quot;&gt;带来的问题&lt;/h2&gt;
&lt;p&gt;引入消息队列后，我们需要考虑哪些问题呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 消息堆积&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是一个很常见的问题，如果消息消费的时间太久，或者服务器故障，导致消息堆积。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 消息丢失&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;消息堆积一个处理方案就是给消息加上超时时间判定，这样就会衍生一个问题，当消息堆积，处理完成之后，就会存在一定消息的丢失，或者服务器宕机也会导致消息丢失，需要针对此类问题做好应对方案。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 消息准确消费&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;保证消息被准确消费，且不存在重复消费的问题。&lt;/p&gt;
&lt;p&gt;以上。&lt;/p&gt;
&lt;p&gt;最后，祝大家新年快乐！&lt;/p&gt;
</description>
<pubDate>Wed, 01 Jan 2020 15:31:00 +0000</pubDate>
<dc:creator>Yabea</dc:creator>
<og:description>本文将介绍大名鼎鼎的消息队列（MQ）的原理，应用场景和常见问题。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ybjourney/p/12130985.html</dc:identifier>
</item>
<item>
<title>曹工杂谈--使用mybatis的同学，进来看看怎么在日志打印完整sql吧，在数据库可执行那种 - 三国梦回</title>
<link>http://www.cnblogs.com/grey-wolf/p/12130803.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/grey-wolf/p/12130803.html</guid>
<description>&lt;p&gt;今天新年第一天，给大家拜个年，祝大家新的一年里，技术突突突，头发长长长！&lt;/p&gt;
&lt;p&gt;咱们搞技术的，比较直接，那就开始吧。我给大家看看我demo工程的效果（代码下边会给大家的）：&lt;/p&gt;
&lt;p&gt;技术栈是&lt;code&gt;mybatis/mybatis plus&lt;/code&gt;，&lt;code&gt;spring boot&lt;/code&gt; ，日志是&lt;code&gt;logback&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/519126/202001/519126-20200101210205281-542658367.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其实这个痛点吧，我是一直有的，测试或者开发时，日志里每次打印的都是带?的sql，然后还得自己手动一个参数一个参数地贴过去，这真是一个体力活。虽然是体力活，还是做了这么多年了，这次，终于决定不忍了。&lt;/p&gt;
&lt;p&gt;在弄这个之前呢，我知道idea里有个插件可以实现这个功能，&lt;code&gt;mybatis-log-plugin&lt;/code&gt;，但我这边idea一直用不起，具体原因不明，反正就是完整sql打印不出来。&lt;/p&gt;
&lt;p&gt;然后我刚搜了下，mybatis plus也支持，加下面这样一行配置即可：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;mybatis-plus:
  configuration:
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但我注意到，这个是打印到控制台的，我试了下，效果如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/519126/202001/519126-20200101224044471-1516541325.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我觉得，这样挺好的，但是有优化空间：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;console打印，不适用于开发环境和测试环境；本地调试还不错；&lt;/li&gt;
&lt;li&gt;本地调试时，一般我只挂起当前线程，如果请求多了，这里的打印会很乱；分不清哪个日志是我这个请求的，而不是其他线程打印的&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我自己这个项目也用的&lt;code&gt;mybatis-plus&lt;/code&gt;，因此，我最终配置是下面这样：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;mybatis-plus:
  configuration:
    log-impl: org.apache.ibatis.logging.slf4j.Slf4jImpl&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用&lt;code&gt;slf4j&lt;/code&gt;打印，而不是&lt;code&gt;console&lt;/code&gt;直接&lt;code&gt;print&lt;/code&gt;。但这依然没有解决：拼装完整sql，并打印到日志的需求。&lt;/p&gt;

&lt;p&gt;因为是自己瞎摸索出来的方案，不保证是最优的，只能说：it works。&lt;/p&gt;
&lt;p&gt;大家再看看，正常情况下，是会打印下面这样的sql的（mybatis默认支持）：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;[http-nio-8083-exec-1] DEBUG  c.e.w.mapper.AppealDisposalOnOffMapper.selectList
                    - ==&amp;gt;  Preparing: SELECT appeal_disposal_on_off_id,disposal_on_off_status,appeal_on_off_status,user_id FROM appeal_disposal_on_off WHERE (disposal_on_off_status = ?)  [BaseJdbcLogger.java:143]
                    
[http-nio-8083-exec-1] DEBUG  c.e.w.mapper.AppealDisposalOnOffMapper.selectList
                    - ==&amp;gt; Parameters: 0(Integer) [BaseJdbcLogger.java:143]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;即，默认打印出：一行&lt;code&gt;preparedStatement&lt;/code&gt;的语句，带？；下一行就是对应的参数。&lt;/p&gt;
&lt;p&gt;我的方案是，对&lt;code&gt;logger&lt;/code&gt;进行动态代理，当调用&lt;code&gt;logger.info/debug/...&lt;/code&gt;的时候，拦截之。&lt;/p&gt;
&lt;p&gt;拦截后的逻辑，如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;当打印的语句，以&lt;code&gt;==&amp;gt; Preparing:&lt;/code&gt;开头时，将当前语句存放到线程局部变量中，假设为A；&lt;/li&gt;
&lt;li&gt;当打印的语句，以&lt;code&gt;==&amp;gt; Parameters:&lt;/code&gt;开头时，将当前线程局部变量中的A拿出来，和当前语句一起，拼成一个完整的sql，然后调用当前方法（记住，我们动态代理了logger.info等方法）打印之。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;画图解决：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/519126/202001/519126-20200101213448948-1511618515.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面的逻辑图，大家看着没问题吧，其实问题的关键变成了，怎么去生成这个logger的动态代理，且最重要的是，你生成的动态代理对象要怎么生效。&lt;/p&gt;

&lt;p&gt;要讲解这部分，我们只能切入细节了，毕竟我们得找到一个切入点，去使用我们的动态代理logger。&lt;/p&gt;
&lt;p&gt;大家应该记得，我们平时使用slf4j时，生成logger是不是下面这样写（现在虽然用lombok了，本质没变）：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private static final Logger logger = LoggerFactory.getLogger(A.class);&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static Logger getLogger(String name) {
    ILoggerFactory iLoggerFactory = getILoggerFactory();
    return iLoggerFactory.getLogger(name);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这一行里，&lt;code&gt;getILoggerFactory&lt;/code&gt;就要去获取classpath中绑定的日志实现了，具体的过程，我在另一篇里也有讲：&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12104977.html&quot;&gt;曹工改bug--这次，我遇到了一个难缠的栈溢出bug，还是日志相关的，真的难&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;因为我们用的logback，所以这里会进入到logback包内的（包名怎么是slf4j的？没错，这就是slf4j-api怎么去找实现类的核心，类似java的SPI机制，具体看上面的博文）：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;logback-classic包内的：
org.slf4j.impl.StaticLoggerBinder#getSingleton
 public static StaticLoggerBinder getSingleton() {
        return SINGLETON;
 }
 进入上面代码前，会先执行静态代码：
 private static StaticLoggerBinder SINGLETON = new StaticLoggerBinder();
 static {
    SINGLETON.init();
 }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的静态代码块中，进行初始化：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    void init() {
            try {
                new ContextInitializer(defaultLoggerContext).autoConfig();
            } catch (JoranException je) {
                Util.report(&quot;Failed to auto configure default logger context&quot;, je);
            }
            //核心代码
            contextSelectorBinder.init(defaultLoggerContext, KEY);
            initialized = true;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;ch.qos.logback.classic.util.ContextSelectorStaticBinder#init
public void init(LoggerContext defaultLoggerContext, Object key) {
        if (this.key == null) {
            this.key = key;
        }
        // 这个contextSelector很重要，loggerFactory就是调用它的方法来生成
        String contextSelectorStr = OptionHelper.getSystemProperty(ClassicConstants.LOGBACK_CONTEXT_SELECTOR);
        if (contextSelectorStr == null) {
            contextSelector = new DefaultContextSelector(defaultLoggerContext);
        } else if (contextSelectorStr.equals(&quot;JNDI&quot;)) {
            contextSelector = new ContextJNDISelector(defaultLoggerContext);
        } else {
            contextSelector = dynamicalContextSelector(defaultLoggerContext, contextSelectorStr);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;经过我多方调试，发现这里的&lt;code&gt;contextSelector&lt;/code&gt;，发现它很关键。它是个接口，方法如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
/**
 * An interface that provides access to different contexts.
 * 
 * It is used by the LoggerFactory to access the context
 * it will use to retrieve loggers.
 *
 * @author Ceki G&amp;amp;uuml;lc&amp;amp;uuml;
 * @author S&amp;amp;eacute;bastien Pennec
 */
public interface ContextSelector {
    // 获取LoggerContext，这个LoggerContext其实就是LoggerFactory
    LoggerContext getLoggerContext();

    LoggerContext getLoggerContext(String name);

    LoggerContext getDefaultLoggerContext();

    LoggerContext detachLoggerContext(String loggerContextName);

    List&amp;lt;String&amp;gt; getContextNames();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;大家注意，这个类的方法，&lt;code&gt;LoggerContext getLoggerContext();&lt;/code&gt;，返回值是&lt;code&gt;LoggerContext&lt;/code&gt;,这个返回值类型比较牛逼，因为它其实就是&lt;code&gt;LoggerFactory&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class LoggerContext extends ContextBase implements ILoggerFactory, LifeCycle &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;大家看到了，这个&lt;code&gt;LoggerContext&lt;/code&gt;实现了&lt;code&gt;ILoggerFactory&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface ILoggerFactory {
    // 这个东西，大家熟悉了噻，logger工厂啊
    public Logger getLogger(String name);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;综上分析，我们要换Logger，可能没那么容易，因为Logger，是&lt;code&gt;ILoggerFactory&lt;/code&gt;调用&lt;code&gt;getLogger&lt;/code&gt;获得的。&lt;/p&gt;
&lt;p&gt;那么，我们只能把原始的&lt;code&gt;ILoggerFactory&lt;/code&gt;（假设为A）给它换了，生成一个&lt;code&gt;ILoggerFactory&lt;/code&gt;的动态代理（假A），保证每次调用&lt;code&gt;A的getLogger&lt;/code&gt;时，就会被假A拦截。然后我们在拦截的逻辑中，先使用A获取到原始logger，然后生成对原始logger进行动态代理的logger。&lt;/p&gt;
&lt;p&gt;所以，现在完整的逻辑是这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/519126/202001/519126-20200101221726635-403240822.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;问题，现在就变成了，怎么去生成&lt;code&gt;org.slf4j.ILoggerFactory&lt;/code&gt;的动态代理，因为我们需要这个原始的factory，不然我们作为动态代理，自己也不知道怎么去生成Logger。&lt;/p&gt;
&lt;p&gt;前面大家也看到了，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/519126/202001/519126-20200101221934929-1588843161.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;LoggerContext&lt;/code&gt;满足要求，那我们只要在能拿到&lt;code&gt;LoggerContext&lt;/code&gt;的地方，处理下就行了。&lt;/p&gt;
&lt;p&gt;能拿到&lt;code&gt;LoggerContext&lt;/code&gt;的地方，就是&lt;code&gt;ContextSelector&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;大家回头再看看之前那段代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void init(LoggerContext defaultLoggerContext, Object key) throws ClassNotFoundException, NoSuchMethodException, InstantiationException,
                    IllegalAccessException, InvocationTargetException {
        if (this.key == null) {
            this.key = key;
        }
        //扩展点就在这里了，这里会去取环境变量，如果取不到，就用默认的，取到了，就用环境变量里的类
        String contextSelectorStr = OptionHelper.getSystemProperty(ClassicConstants.LOGBACK_CONTEXT_SELECTOR);
        if (contextSelectorStr == null) {
           A： contextSelector = new DefaultContextSelector(defaultLoggerContext);
        } else if (contextSelectorStr.equals(&quot;JNDI&quot;)) {
           B： contextSelector = new ContextJNDISelector(defaultLoggerContext);
        } else {
           C： contextSelector = dynamicalContextSelector(defaultLoggerContext, contextSelectorStr);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里就是扩展点，我们自己设置一个环境变量&lt;code&gt;ClassicConstants.LOGBACK_CONTEXT_SELECTOR&lt;/code&gt;，就不会走A逻辑，而是走上面的C逻辑。具体的里面很简单，就是根据环境变量的值，去new一个对应的&lt;code&gt;contextSelector&lt;/code&gt;。&lt;/p&gt;

&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@SpringBootApplication
@MapperScan(&quot;com.example.webdemo.mapper&quot;)
public class WebDemoApplicationUsingMybatisPlus {

    private static Logger log= null;
    static {
       // 这里设置环境变量，指向我们自定义的class System.setProperty(ClassicConstants.LOGBACK_CONTEXT_SELECTOR,&quot;com.example.webdemo.util.CustomDefaultContextSelector&quot;);
        log = LoggerFactory.getLogger(WebDemoApplicationUsingMybatisPlus.class);
    }

    public static void main(String[] args) {
        ConfigurableApplicationContext context = SpringApplication.run(WebDemoApplicationUsingMybatisPlus.class, args);
    }

}&lt;/code&gt;
&lt;/pre&gt;

&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.example.webdemo.util;

import ch.qos.logback.classic.Logger;
import ch.qos.logback.classic.LoggerContext;
import ch.qos.logback.classic.selector.ContextSelector;
import org.springframework.cglib.proxy.Enhancer;
import org.springframework.cglib.proxy.MethodInterceptor;
import org.springframework.cglib.proxy.MethodProxy;

public class CustomDefaultContextSelector implements ContextSelector, MethodInterceptor {

    private LoggerContext defaultLoggerContext;

    private LoggerContext proxyedDefaultLoggerContext;

    private static ConcurrentHashMap&amp;lt;String, org.slf4j.Logger&amp;gt; cachedLogger = new ConcurrentHashMap&amp;lt;&amp;gt;(1000);


    public CustomDefaultContextSelector(LoggerContext context) {
        //1：原始的LoggerContext，框架会传进来
        this.defaultLoggerContext = context;
    }

    @Override
    public LoggerContext getLoggerContext() {
        return getDefaultLoggerContext();
    }

    @Override
    public LoggerContext getDefaultLoggerContext() {
        if (proxyedDefaultLoggerContext == null) {
            //2：我们这里，将原始的LogegrContext进行代理，这里返回代理过的对象，完成偷天换日的效果，callback就设为自己
            Enhancer enhancer = new Enhancer();
            enhancer.setSuperclass(defaultLoggerContext.getClass());
            enhancer.setCallback(this);
            proxyedDefaultLoggerContext = (LoggerContext) enhancer.create();
        }
        return proxyedDefaultLoggerContext;
    }

    @Override
    public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
        Object result;
        result = methodProxy.invokeSuper(o,args);
        //3：当原始的LoggerContext的getLogger被调用时，生成一个动态代理的Logger，会组装sql日志那种
        if (Objects.equals(method.getReturnType().getName(), org.slf4j.Logger.class.getName()) &amp;amp;&amp;amp; Objects.equals(method.getName(), &quot;getLogger&quot;)) {
            org.slf4j.Logger logger = (org.slf4j.Logger) result;
            String loggerName = logger.getName();

            /**
             * 只关心mybatis层的logger，mybatis层的logger的包名，我们这边是固定的包下面
             * 如果不是这个包下的，直接返回
             */
            if (!loggerName.startsWith(&quot;com.example.webdemo.mapper&quot;)) {
                return result;
            }

            /**
             * 对mybatis mapper的log，需要进行代理；代理后的对象，我们暂存一下，免得每次都创建代理对象
             * 从缓存获取代理logger
             */
            if (cachedLogger.get(loggerName) != null) {
                return cachedLogger.get(loggerName);
            }

            CustomLoggerInterceptor customLoggerInterceptor = new CustomLoggerInterceptor();
            customLoggerInterceptor.setLogger((Logger) result);
            Object newProxyInstance = Proxy.newProxyInstance(result.getClass().getClassLoader(), result.getClass().getInterfaces(), customLoggerInterceptor);

            cachedLogger.put(loggerName, (org.slf4j.Logger) newProxyInstance);

            return newProxyInstance;
        }

        return result;
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里做了一点优化，将代理Logger进行了缓存，同名的logger只会有一个。&lt;/p&gt;

&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//摘录了一部分，因为处理字符串比较麻烦，所以代码多一点，这里就不贴出来了，大家自己去clone哈
private String assemblyCompleteMybatisQueryLog(Object[] args) {
        if (args != null &amp;amp;&amp;amp; args.length &amp;gt; 1) {
            if (!(args[0] instanceof BasicMarker)) {
                return null;
            }
            /**
             * marker不匹配，直接返回
             */
            BasicMarker arg = (BasicMarker) args[0];
            if (!Objects.equals(arg.getName(), &quot;MYBATIS&quot;)) {
                return null;
            }

            String message = null;
            for (int i = (args.length - 1); i &amp;gt;= 0 ; i--) {
                if (args[i] != null &amp;amp;&amp;amp; args[i] instanceof String) {
                    message = (String) args[i];
                    break;
                }
            }
            if (message == null) {
                return null;
            }
            // 这里就是判断当前打印的sql是啥，进行对应的处理
            if (message.startsWith(&quot;==&amp;gt;  Preparing:&quot;)) {
                String newMessage = message.substring(&quot;==&amp;gt;  Preparing:&quot;.length()).trim();
                SQL_LOG_VO_THREAD_LOCAL.get().setPrepareSqlStr(newMessage);
            } else if (message.startsWith(&quot;==&amp;gt; Parameters:&quot;)) {
                try {
                    return populateSqlWithParams(message);
                } catch (Exception e) {
                    logger.error(&quot;{}&quot;,e);
                }finally {
                    SQL_LOG_VO_THREAD_LOCAL.remove();
                }
            }
        }

        return null;
    }&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;源码地址奉上，大家deug一下，马上就明白了。&lt;/p&gt;
&lt;p&gt;针对&lt;code&gt;mybatis&lt;/code&gt;的：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/ckl111/all-simple-demo-in-work/tree/master/log-complete-sql-demo-mybatis&quot; class=&quot;uri&quot;&gt;https://gitee.com/ckl111/all-simple-demo-in-work/tree/master/log-complete-sql-demo-mybatis&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;针对&lt;code&gt;mybatis-plus&lt;/code&gt;的：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/ckl111/all-simple-demo-in-work/tree/master/log-complete-sql-demo-mybatis-plus&quot; class=&quot;uri&quot;&gt;https://gitee.com/ckl111/all-simple-demo-in-work/tree/master/log-complete-sql-demo-mybatis-plus&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;具体就这么多吧，大家把3个工具类拷过去基本就能用了，然后改为自己mapper的包名，大家觉得有帮助，请点个赞哈，大过年的，哈哈！&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 01 Jan 2020 14:43:00 +0000</pubDate>
<dc:creator>三国梦回</dc:creator>
<og:description>前言 今天新年第一天，给大家拜个年，祝大家新的一年里，技术突突突，头发长长长！ 咱们搞技术的，比较直接，那就开始吧。我给大家看看我demo工程的效果（代码下边会给大家的）： 技术栈是 ，`spring</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/grey-wolf/p/12130803.html</dc:identifier>
</item>
</channel>
</rss>