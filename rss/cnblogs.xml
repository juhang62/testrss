<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Springboot 1.5.x 集成基于Centos7的RabbitMQ集群安装及配置 - xu_shuyi</title>
<link>http://www.cnblogs.com/xushuyi/p/10457330.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xushuyi/p/10457330.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;RabbitMQ简介&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;RabbitMQ是实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件）。&lt;/p&gt;
&lt;p&gt;RabbitMQ是一套开源（MPL）的消息队列服务软件，是由LShift提供的一个Advanced Message Queuing Protocol（AMQP）的开源实现，由以高性能、健壮以及可伸缩性出名的Erlang写成。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;选择RabbitMQ&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;市面上有很多MQ可以选择，如：ActiveMQ、ZeroMQ、Apache Qpid及RocketMQ，为什么要选择RabbitMQ呢？&lt;/p&gt;
&lt;p&gt;1. 除了Qpid，RabbitMQ是唯一一个实现了AMQP标准的消息服务器；&lt;/p&gt;
&lt;p&gt;2. 可靠性，RabbitMQ的持久化支持，保证了消息的稳定性；&lt;/p&gt;
&lt;p&gt;3. 高并发，RabbitMQ使用了Erlang开发语言，Erlang是为电话交换机开发的语言，天生自带高并发光环和高可用特性；&lt;/p&gt;
&lt;p&gt;4. 集群部署简单，正是应为Erlang使得RabbitMQ集群部署变的超级简单；&lt;/p&gt;
&lt;p&gt;5. 社区活跃度高，从网上资料来看，RabbitMQ也是首选&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;工作机制&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1. 消息模型&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;生产者、消费者和代理&lt;/p&gt;
&lt;p&gt;生产者（producer）：消息的创建者，负责创建和推送数据到消息服务器；&lt;/p&gt;
&lt;p&gt;消费者（consumer）：消息的接收方，用于处理数据和确认消息；&lt;/p&gt;
&lt;p&gt;代理（proxy）：就是RabbitMQ本身，用于扮演“快递”的角色，本身不生产消息，只是扮演“快递”的角色。&lt;/p&gt;
&lt;p&gt;图片来源：&lt;a href=&quot;https://www.jianshu.com/p/79ca08116d57&quot; target=&quot;_blank&quot;&gt;消息队列之 RabbitMQ&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/740218/201903/740218-20190301170156978-2079483842.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2. 基本概念&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;RabbitMQ内部结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/740218/201903/740218-20190301170920043-1211054301.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1. Message&lt;/p&gt;
&lt;p&gt;消息是不具名的，它由消息头和消息体组成。消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持久性存储）等。&lt;/p&gt;
&lt;p&gt;2. Publisher&lt;/p&gt;
&lt;p&gt;消息得生产者，也是一个向交换器发布消息的客户端应用程序。&lt;/p&gt;
&lt;p&gt;3. Exchange&lt;/p&gt;
&lt;p&gt;交换器，用来接收生产者发送的消息并将这些消息路由给服务器中的队列。&lt;/p&gt;
&lt;p&gt;4. Binding&lt;/p&gt;
&lt;p&gt;绑定，用于消息队列和交换器之间的关联，一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。&lt;/p&gt;
&lt;p&gt;5. Queue&lt;/p&gt;
&lt;p&gt;消息队列，用来保存消息知道发送给消费者。他是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。&lt;/p&gt;
&lt;p&gt;6. Connection&lt;/p&gt;
&lt;p&gt;网络连接，比如一个TCP连接&lt;/p&gt;
&lt;p&gt;7. Channel&lt;/p&gt;
&lt;p&gt;信道，多路复用连接中的一条独立的双向数据流通道。信道是建立在真实的TCP连接内地虚拟连接，AMQP命令都是通过信道发出去的，不管是发布消息、订阅队列还是接收消息，这些动作都是通过信道完成。因为对于操作系统来说建立和销毁TCP都是非常昂贵的开销，所以引入了信道的概念，以复用一条TCP连接。&lt;/p&gt;
&lt;p&gt;8. Consumer&lt;/p&gt;
&lt;p&gt;消息的消费者，表示一个从消息队列中取得消息的客户端应用程序。&lt;/p&gt;
&lt;p&gt;9. Virtual Host&lt;/p&gt;
&lt;p&gt;虚拟主机，表示一批交换器、消息队列和相关对象。虚拟主机是共享相同的身份认证和加密环境的独立服务器域。每个vhost本质上就是一个mini版的RabbitMQ服务器，拥有自己的队列、交换器、绑定和权限机制。vhost是AMQP概念的基础，必须在连接时指定，RabbitMQ默认的vhost是 / 。&lt;/p&gt;
&lt;p&gt;10. Broker&lt;/p&gt;
&lt;p&gt;表示消息队列服务器实体。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;3. AMQP中的消息路由&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; AMQP中消息的路由过程和Java开发者熟悉的JMS存在一些差异，AMQP中增加了Exchange和Binding的角色。生产者把消息发布到Exchange上，消息最终达到队列并被消费者接收，而Binding决定交换器的消息应该发送到哪个队列。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/740218/201903/740218-20190301201618756-926632183.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;4. 交换机Exchange&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Exchange分发消息时根据类型的不同分发策略有区别，目前存在四种类型：direct、fanout、topic、headers。headers匹配AMQP消息的header而不是路由主键，此外headers交换机和direct交换机完全一致，但性能差很多，目前基本上用不到了，所以直接看其他类型。&lt;/p&gt;
&lt;p&gt;1. direct&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/740218/201903/740218-20190314133857384-508914696.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;消息中的路由主键（routing key）如何和Binding中的binding key一致，交换机就将消息发到对应的队列中。路由键和队列名完全匹配，如果一个队列绑定到交换机要求路由键为“dog”，则只能转发routing key标记为“dog”的消息。它是完全匹配，单播的模式。&lt;/p&gt;
&lt;p&gt;2. fanout&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/740218/201903/740218-20190314134230859-811131035.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每个发到fanout类型交换器的消息都会分到所有绑定的队列上去。fanout交换机不处理路由键，只是简单的将队列绑定到交换机上，每个发送到交换机的消息都会被转发到与该交换机绑定的所有队列上。很像子网广播，每台子网内的主机都获得了一份复制的消息。它是转发消息最快的。&lt;/p&gt;
&lt;p&gt;3. topic&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/740218/201903/740218-20190314134450951-750675934.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;topic交换机通过模式匹配分配消息的路由键属性，将路由键和某个模式进行匹配，此时队列需要绑定到一个模式上。它将路由键和绑定键的字符串切分成单词，这些单词之间用点隔开。它同样也会识别两个通配符：符号“#”和符号“”。#匹配0个活多个单词，“”匹配不多不少一个单词。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;5. 消息持久化&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;RabbitMQ队列和交换器在默认情况下，重启服务器会导致消息丢失，如何保证RabbitMQ在重启的时候消息不丢失呢？答案：消息持久化&lt;/p&gt;
&lt;p&gt;RabbitMQ持久化会将你的持久化消息写入到磁盘中的持久化日志文件中，等消息被消费后，RabbitMQ会把这条消息标识为等待垃圾回收。&lt;/p&gt;
&lt;p&gt;当你把消息发送到RabbitMQ服务器的时候，你需要选择是否要进行持久化，但这并不能保证RabbitMQ能从崩溃中恢复，想要消息恢复必须满足以下3个条件：&lt;/p&gt;
&lt;p&gt;1. 投递消息的时候durable设置为true，消息持久化，代码：channel.queueDeclare(x, true, false, false, null)，参数2设置为true持久化；&lt;/p&gt;
&lt;p&gt;2. 设置投递模式deliveryMode设置为2（持久），代码：channel.basicPublish(x, x, MessageProperties.PERSISTENT_TEXT_PLAIN,x)，参数3设置为存储纯文本到磁盘；&lt;/p&gt;
&lt;p&gt;3. 消息已经到达持久化交换器上；&lt;/p&gt;
&lt;p&gt;4. 消息已经到达持久化的队列；&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4. 持久化缺点&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;消息持久化的优点显而易见，但缺点也很明显，那就是性能，因为要写入硬盘要比写入内存性能较低很多，从而降低了服务器的吞吐量，尽管使用SSD硬盘可以使事情得到缓解，但他仍然吸干了Rabbit的性能，当消息成千上万条要写入磁盘的时候，性能是很低的。所以需要根据自己项目的实际情况，选择适合自己的方式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;5. 虚拟主机&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 每个Rabbit都能创建很多vhost，我们称之为虚拟主机，每个虚拟主机其实都是mini版的RabbitMQ，拥有自己的队列，交换机和绑定，拥有自己的权限机制。&lt;/p&gt;
&lt;p&gt;vhost 特性：&lt;/p&gt;
&lt;p&gt;1. RabbitMQ默认的vhost是“/”开箱即用&lt;/p&gt;
&lt;p&gt;2. 多个vhost是隔离的，多个vhost无法通讯，并且不用担心命名冲突（队列和交换机进行绑定），实现了多层分离&lt;/p&gt;
&lt;p&gt;3. 创建用户的时候必须指定vhost&lt;/p&gt;
&lt;p&gt;vhost操作：&lt;/p&gt;
&lt;p&gt;1. 可以通过rabbitmqctl工具命令创建：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
rabbitmqctl add_vhost[vhost_name]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2. 删除vhost：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
rabbitmqctl delete_vhost[vhost_name]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3. 查看所有的vhost：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
rabbitmqctl list_vhosts
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;RabbitMQ安装及搭建&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1. 选择版本&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;选择Erlang与RabbitMQ对应版本 &lt;a href=&quot;http://www.rabbitmq.com/which-erlang.html&quot; target=&quot;_blank&quot;&gt;RabbitMQ Erlang Version Requirements&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2. 安装Erlang&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2.1 下载Erlang需要依赖的包&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
cd /&lt;span&gt;
mkdir downloads&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/740218/201903/740218-20190314141238635-1207765651.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.2 将Erlang需要的依赖通过yum下载并安装&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
yum -y install make gcc gcc-c++ kernel-devel m4 ncurses-devel openssl-devel unixODBC-devel
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/740218/201903/740218-20190314141424987-776926148.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/740218/201903/740218-20190314141458428-819335882.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注：Erlang所需依赖下载安装完成后，开始下载Erlang。&lt;/p&gt;
&lt;p&gt;2.3 开始下载Erlang&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
cd /usr/local/&lt;span&gt;
mkdir rabbitmq
cd rabbitmq&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
wget http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.rabbitmq.com/releases/erlang/erlang-19.0.4-1.el7.centos.x86_64.rpm&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/740218/201903/740218-20190314141159869-374003945.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 2.4 开始安装Erlang&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
rpm -ivh erlang-19.0.4-1.el7.centos.x86_64.rpm
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/740218/201903/740218-20190314141609340-1919583529.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3. 安装RabbitMQ&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 3.1 下载RabbitMQ&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
cd /usr/local/rabbitmq/
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
wget http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.rabbitmq.com/releases/rabbitmq-server/v3.6.6/rabbitmq-server-3.6.6-1.el7.noarch.rpm&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
rpm -ivh rabbitmq-server-3.6.6-1.el7.noarch.rpm
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/740218/201903/740218-20190314141958845-1375703803.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.2 在安装RabbitMQ过程中提示依赖socat软件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
yum install socat
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.3 安装完socat，重新执行安装RabbitMQ&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/740218/201903/740218-20190314142106414-1638565100.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.4 查找安装RabbitMQ bin的位置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/740218/201903/740218-20190314142227911-949916528.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.5 启动RabbitMQ&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39.43119266055&quot;&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt;cd /sbin/&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt;./rabbitmq-server -detached&lt;/span&gt;&lt;span&gt; # &lt;span&gt;启动服务命令&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt;./&lt;/span&gt;&lt;span&gt;rabbitmqctl stop&lt;/span&gt;&lt;span&gt; # &lt;span&gt;停止服务命令&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt;./rabbitmq-plugins enable rabbitmq_management&lt;/span&gt;&lt;span&gt; # &lt;span&gt;安装管理插件&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt;./rabbitmq-server -detached&lt;/span&gt;&lt;span&gt; # &lt;span&gt;重新启动服务命令&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt;./rabbitmqctl status&lt;/span&gt;&lt;span&gt; # &lt;span&gt;查看服务运行状态&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;wget&lt;/span&gt; &lt;a href=&quot;http://master1:15672&quot;&gt;&lt;span&gt;http://master1:15672&lt;/span&gt;&lt;/a&gt;&lt;span&gt; # &lt;span&gt;验证是否成功安装&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/740218/201903/740218-20190314142342689-1271697926.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/740218/201903/740218-20190314142355071-506262867.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.6 创建用户&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
./&lt;span&gt;rabbitmqctl add_user admin admin
.&lt;/span&gt;/&lt;span&gt;rabbitmqctl set_user_tags admin administrator
.&lt;/span&gt;/rabbitmqctl set_permissions -p &quot;/&quot; admin &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;&lt;span&gt;
.&lt;/span&gt;/rabbitmqctl list_users
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt;如果发现远程访问不了：&lt;/span&gt;http&lt;span&gt;：&lt;/span&gt;&lt;span&gt;//192.168.56.101:15672&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt;应该是&lt;/span&gt;iptables&lt;span&gt;的原因&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
1&lt;span&gt;.关闭firewall
[root@localhost &lt;/span&gt;~]# systemctl stop firewalld.service            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;停止firewall&lt;/span&gt;
[root@localhost ~]# systemctl disable firewalld.service        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;禁止firewall开机启动&lt;/span&gt;
2&lt;span&gt;.安装iptables
[root@localhost &lt;/span&gt;~]# yum install iptables-services            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;安装&lt;/span&gt;
[root@localhost ~&lt;span&gt;]# systemctl restart iptables.service #重启防火墙使配置生效
[root@localhost &lt;/span&gt;~&lt;span&gt;]# systemctl enable iptables.service #设置防火墙开机启动
[root@localhost &lt;/span&gt;~]# systemctl disable iptables.service #禁止防火墙开机启动
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;15&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4. RabbitMQ集群配置&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;4.1 服务器&lt;/p&gt;
&lt;p&gt;192.168.56.101，192.168.56.102&lt;/p&gt;
&lt;p&gt;4.2 在102机器按照之上101模式重新安装RabbitMQ即可&lt;/p&gt;
&lt;p&gt;4.3 两台RabbitMQ服务重启后，通过cluster_status命令查看集群状态&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/740218/201903/740218-20190314144954315-963720539.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.4 连接集群&lt;/p&gt;
&lt;p&gt;为了连接集群中的两个节点，我们把rabbit@slave1加入到rabbit@master1节点集群中，调整两台服务器hosts文件，加入域名&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/740218/201903/740218-20190314145155202-1249689436.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1、&lt;span&gt;停止&lt;/span&gt;rabbit@salve1&lt;span&gt;的&lt;/span&gt;&lt;span&gt;rabbitmq&lt;/span&gt;&lt;span&gt;应用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2、&lt;span&gt;加入&lt;/span&gt;rabbit@master1&lt;span&gt;集群&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3、&lt;span&gt;启动&lt;/span&gt;rabbit@salve1&lt;/p&gt;
&lt;p&gt;4、&lt;span&gt;在&lt;/span&gt;master1/slave1&lt;span&gt;任意一个节点查看集群状态&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
cd /sbin/&lt;span&gt;
.&lt;/span&gt;/&lt;span&gt;rabbitmqctl stop_app
.&lt;/span&gt;/&lt;span&gt;rabbitmqctl join_cluster rabbit@master1
.&lt;/span&gt;/&lt;span&gt;rabbitmqctl start_app
.&lt;/span&gt;/rabbitmqctl cluster_status
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/740218/201903/740218-20190314145259348-1529412063.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/740218/201903/740218-20190314145312956-287670614.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.5 停止master1查看集群状态&lt;/p&gt;
&lt;p&gt;针对master1操作：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
cd /sbin/&lt;span&gt;
.&lt;/span&gt;/rabbitmqctl stop
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/740218/201903/740218-20190314145506490-825707713.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.6 重启master1查看集群状态&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/740218/201903/740218-20190314145536949-256909081.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.7 注意问题&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当整个集群关闭时，最后一个关闭的节点必须是第一个要联机的节点。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;如果要脱机的最后一个节点无法恢复，可以使用forget_cluster_node命令将其从群集中删除&lt;/span&gt;&lt;br/&gt;&lt;span&gt;如果所有集群节点同时停止并且不受控制（例如断电），则可能会留下所有节点都认为其他节点在其后停止的情况。在这种情况下，您可以在一个节点上使用force_boot命令使其再次可引导&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.8 移除集群&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;当节点不再是节点的一部分时，需要从集群中明确地删除节点。我们首先从集群中删除rabbit@slave1，并将其返回到独立操作。&lt;/p&gt;
&lt;p&gt;在rabbit@slave1上：&lt;/p&gt;
&lt;p&gt;1、停止RabbitMQ应用程序&lt;/p&gt;
&lt;p&gt;2、重置节点&lt;/p&gt;
&lt;p&gt;3、重新启用RabbitMQ应用程序&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
./&lt;span&gt;rabbitmqctl stop_app
.&lt;/span&gt;/&lt;span&gt;rabbitmqctl reset
.&lt;/span&gt;/&lt;span&gt;rabbitmqctl start_app
.&lt;/span&gt;/rabbitmqctl cluster_status
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/740218/201903/740218-20190314145805755-104385949.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、远程删除节点，在处理无响应的节点服务&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如我们在master1上将slave1从集群中移除&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;停止节点slave1&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;在master1上通过forget_cluster_node命令移除slave1&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;重置slave1节点&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;启动slave1节点&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;Slave1服务器：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
./&lt;span&gt;rabbitmqctl stop_app
.&lt;/span&gt;/&lt;span&gt;rabbitmqctl reset # 执行此命令前 先执行master1 上的forget命令
.&lt;/span&gt;/&lt;span&gt;rabbitmqctl start_app
.&lt;/span&gt;/rabbitmqctl cluster_status
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;master1服务器：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
./&lt;span&gt;rabbitmqctl forget_cluster_node rabbit@slave1 # 执行此命令前 先执行slave1 停止节点
.&lt;/span&gt;/rabbitmqctl cluster_status
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/740218/201903/740218-20190314145912435-1651284274.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.9 主机名更改&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;RabbitMQ节点使用主机名相互通信。因此，所有节点名称必须能够解析所有集群对等的名称。像rabbitmqctl这样的工具也是如此&lt;/span&gt;&lt;br/&gt;&lt;span&gt;除此之外，默认情况下RabbitMQ使用系统的当前主机名来命名数据库目录。如果主机名更改，则会创建一个新的空数据库。为了避免数据丢失，建立一个固定和可解析的主机名至关重要。每当主机名更改时，您应该重新启动RabbitMQ&lt;/span&gt;&lt;br/&gt;&lt;span&gt;如果要使用节点名称的完整主机名（RabbitMQ默认为短名称），并且可以使用DNS解析完整的主机名，则可能需要调查设置环境变量 RABBITMQ_USE_LONGNAME = true&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;5. 使用HAProxy实现RabbitMQ集群的负载&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;5.1 资源包下载，并上传服务器&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;download.csdn.net/download/u014518626/10122459?web=web&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
cd /usr/local/&lt;span&gt;
mkdir haproxy&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/740218/201903/740218-20190314150324221-1944218910.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5.2 解压&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
tar -xzvf haproxy-1.7.9.tar.gz
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;5.3 查看内核&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/740218/201903/740218-20190314150449204-1194215003.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5.4 编译安装&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
make TARGET=&lt;span&gt;linux2628
make install&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/740218/201903/740218-20190314150605406-1287128263.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;安装后，查看版本&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
./haproxy -v
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/740218/201903/740218-20190314150636900-426309461.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;复制haproxy文件到&lt;span&gt;/usr/sbin&lt;/span&gt;下，因为下面的&lt;span&gt;haproxy.init&lt;/span&gt;启动脚本默认会去&lt;span&gt;/usr/sbin&lt;/span&gt;下找，当然你也可以修改，不过比较麻烦。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
cp haproxy /usr/sbin/
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/740218/201903/740218-20190314150710453-1394317503.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;复制&lt;/span&gt;haproxy&lt;span&gt;脚本，到&lt;/span&gt;&lt;span&gt;/etc/init.d&lt;/span&gt;&lt;span&gt;下&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
cp ./examples/haproxy.init /etc/init.d/&lt;span&gt;haproxy
chmod &lt;/span&gt;755 /etc/init.d/haproxy
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;5.5 创建系统账号&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
useradd -r haproxy
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;5.6 创建配置文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
mkdir /etc/&lt;span&gt;haproxy
vi &lt;/span&gt;/etc/haproxy/haproxy.cfg
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;Haproxy.cfg内容如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;global
    log &lt;/span&gt;127.0.0.1&lt;span&gt; local0 info
    chroot &lt;/span&gt;/usr/local/&lt;span&gt;haproxy
    user haproxy
    group haproxy
    daemon
    maxconn &lt;/span&gt;4096&lt;span&gt;

defaults
    log     global
    mode    tcp
    option  tcplog
    option  dontlognull
    retries &lt;/span&gt;3&lt;span&gt;
    option  abortonclose
    maxconn &lt;/span&gt;4096&lt;span&gt;
    timeout connect  5000ms
    timeout client  3000ms
    timeout server  3000ms
    balance roundrobin

listen private_monitoring
    bind    &lt;/span&gt;0.0.0.0:8100&lt;span&gt;
    mode    http
    option  httplog
    stats   refresh  5s
    stats   uri  &lt;/span&gt;/&lt;span&gt;stats
    stats   realm   Haproxy
    stats   auth  admin:admin

listen rabbitmq_admin
    bind    &lt;/span&gt;0.0.0.0:8102&lt;span&gt;
    server  &lt;span&gt;master1  &lt;/span&gt;&lt;/span&gt;&lt;span&gt;192.168.56.101:15672&lt;/span&gt;&lt;span&gt;
    server  &lt;span&gt;slave1   &lt;/span&gt;&lt;/span&gt;&lt;span&gt;192.168.56.102:15672&lt;/span&gt;&lt;span&gt;

listen rabbitmq_cluster
    bind    &lt;/span&gt;0.0.0.0:8101&lt;span&gt;
    mode    tcp
    option  tcplog
    balance roundrobin
    timeout client  3h
    timeout server  3h
    &lt;span&gt;server  master1 &lt;/span&gt;&lt;/span&gt;&lt;span&gt;192.168.56.101:5672  check  inter  3000  rise  2  fall  3
    server  slave1  192.168.56.102:5672  check  inter  3000  rise  2  fall  3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于我打开了 log 127.0.0.1 local0 info 日志，需要调整rsyslog配置文件。&lt;/p&gt;
&lt;p&gt;打开rsyslog配置&lt;/p&gt;
&lt;p&gt;vi /etc/rsyslog.conf&lt;/p&gt;
&lt;p&gt;去掉下面两行前面的#号&lt;/p&gt;
&lt;p&gt;$ModLoad imudp&lt;/p&gt;
&lt;p&gt;$UDPServerRun 514&lt;/p&gt;
&lt;p&gt;并添加下面一行&lt;/p&gt;
&lt;p&gt;local0.* /var/log/haproxy.log&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/740218/201903/740218-20190314151021656-2117781327.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;重新启动rsyslog&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
systemctl restart rsyslog
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;启动haproxy&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
service haproxy start
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/740218/201903/740218-20190314151104217-917004947.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;6. Springboot 集成RabbitMQ集群&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 6.1 引入依赖&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-amqp&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;6.2 地址配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
---&lt;span&gt;
# 集群 RabbitMQ
spring:
  rabbitmq:
    host: &lt;/span&gt;192.168.56.101&lt;span&gt;
    port: &lt;/span&gt;8101&lt;span&gt;
    username: admin
    password: admin&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意：8101 是 haproxy 负载均衡器的地址，因为之上我已经使用了 haproxy作为 rabbitmq集群的负载器&lt;/p&gt;
&lt;p&gt;6.3 创建队列&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.sinosoft.config;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.amqp.core.Queue;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Bean;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Configuration;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Created by xushuyi on 2017/7/20.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Configuration
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Queues {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 创建队列 hello.foo
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Queue helloQueue() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Queue(&quot;hello.foo&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;6.4 生产消息&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.sinosoft.rabbit;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.amqp.core.AmqpTemplate;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Component;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Date;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Created by xushuyi on 2017/7/20.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RabbitSend {

    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; AmqpTemplate rabbitTemplate;


    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; send(String val) {
        String context &lt;/span&gt;= &quot;hello &quot; + &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date();
        System.out.println(&lt;/span&gt;&quot;Sender : &quot; +&lt;span&gt; val);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.rabbitTemplate.convertAndSend(&quot;hello.foo&quot;&lt;span&gt;, val);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;6.5 消息消费&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.sinosoft.rabbit;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.amqp.rabbit.annotation.RabbitListener;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Component;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Created by xushuyi on 2017/7/20.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RabbitReceive {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 接收通道
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; i
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @RabbitListener(queues &lt;/span&gt;= &quot;hello.foo&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; process(String i) {
        System.out.println(&lt;/span&gt;&quot;执行接收Receiver1  : &quot; +&lt;span&gt; i.toString());
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注：这是一个非常精简的demo示例，已经可以达到队列消息的生产与消费，当然还有很多详细的配置内容，在这里就不多赘述了。&lt;/p&gt;
&lt;p&gt;技术参考：&lt;/p&gt;
&lt;p&gt;1. &lt;a href=&quot;https://www.cnblogs.com/liaojie970/p/6138278.html&quot; target=&quot;_blank&quot;&gt;Centos7 安装RabbitMQ&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2. &lt;a href=&quot;https://www.cnblogs.com/sellsa/p/8056173.html&quot; target=&quot;_blank&quot;&gt;RabbitMQ集群&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 14 Mar 2019 07:20:00 +0000</pubDate>
<dc:creator>xu_shuyi</dc:creator>
<og:description>RabbitMQ简介 RabbitMQ是实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件）。 RabbitMQ是一套开源（MPL）的消息队列服务软件，是由LShift提供的一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xushuyi/p/10457330.html</dc:identifier>
</item>
<item>
<title>链接测试工具总结 - 许小猪</title>
<link>http://www.cnblogs.com/xuxiaozhu/p/10530461.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuxiaozhu/p/10530461.html</guid>
<description>&lt;p&gt;近期迫于公司的要求接触到了链接测试，了解和自行安装了一些链接测试的工具，在这里做一下总结：&lt;/p&gt;

&lt;p&gt;&lt;span&gt;一、&lt;strong&gt;XENU&lt;/strong&gt;（&lt;a href=&quot;https://www.oschina.net/p/xenu&quot; target=&quot;_blank&quot;&gt;https://www.oschina.net/p/xenu&lt;/a&gt;）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1、原理：如果网站内文件、链接或者制定页面不存在，则将该链接和处于什么文件的具体位置记录下来，一直到该网站所有页面中的所有链接都测试完成才结束测试，并输出测试报告。&lt;/p&gt;
&lt;p&gt;2、优缺点：&lt;/p&gt;
&lt;p&gt;优：这个软件是检测网站链接有效性的免费软件，最大支持100线程；测试链接目标是否存在和是否孤立页面都可以通过程序自动完成；可以生成很好的错误报告；可以一个链接查看所有的“失败链接报告”；&lt;/p&gt;
&lt;p&gt;缺：只能测试链接存不存在，但是没法验证链接的正确性，只有Windows版本，网速慢，可能会发生超时错误，导致无法得知目标到底是不是死链接。&lt;/p&gt;
&lt;p&gt; （本人的电脑是Mac，在电脑上安装了CrossOver之后才可以用这个东东，如果有需要的可以网上下载，不过试用期只有15天，过了之后就要购买了，在用的过程中出现了卡机的情况，也不知道是不是打开的方式不对，后来还特意下了一个杀毒软件，然后就没有出现过卡机的情况了。）&lt;/p&gt;
&lt;p&gt;在下用菜鸟教程（&lt;a href=&quot;http://www.runoob.com/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;http://www.runoob.com/&lt;/span&gt;&lt;/a&gt;）做个示范，页面如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1525550/201903/1525550-20190314145616670-1393118681.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后的结果页面是这样的（个人认为检测的速度有点慢）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1525550/201903/1525550-20190314151034098-1519445309.png&quot; alt=&quot;&quot; width=&quot;1400&quot; height=&quot;695&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、W3C的link checker（在线测试工具）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;优：速度还可以；&lt;/p&gt;
&lt;p&gt;缺：最后的结果比较模糊，不太明了。&lt;/p&gt;
&lt;p&gt;额外再分享两个在线工具：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.deadlinkchecker.com/%20&quot; target=&quot;_blank&quot;&gt;http://www.deadlinkchecker.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.brokenlinkcheck.com/&quot; target=&quot;_blank&quot;&gt;http://www.brokenlinkcheck.com/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;=====================分割线===================================&lt;/p&gt;
&lt;p&gt;由于上面的那俩货头头都不满意，所以本人又开始了找开源工具之路，找到了以下两个：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、gurlchecker(&lt;a href=&quot;https://www.oschina.net/p/gurlchecker&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://www.oschina.net/p/gurlchecker&lt;/span&gt;&lt;/a&gt;)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这个是一个图形化的web网站链接检查程序，可以对整个网站、某个本地页或者是浏览器的书签文件进行检查。&lt;/p&gt;
&lt;p&gt;界面如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1525550/201903/1525550-20190314142853144-1655205245.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（这个工具到目前为止本人还没用起来，在摸索的过程中放弃了哈哈哈，很是惭愧，不过链接在👆，大家可以自寻摸索～）&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;四、LinkChecker(&lt;a href=&quot;https://www.oschina.net/p/linkchecker&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://www.oschina.net/p/linkchecker&lt;/span&gt;&lt;/a&gt;)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;LinkChecker 是一个网页链接检查程序，主要特性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;循环遍历和多线程检查&lt;/li&gt;
&lt;li&gt;输出各种格式检查结果：text, HTML, SQL, CSV, XML&lt;/li&gt;
&lt;li&gt;支持 HTTP/1.1, HTTPS, FTP, mailto:, news:, nntp:, Telnet 和本地文件链接检查&lt;/li&gt;
&lt;li&gt;可使用正则表达式对链接的url进行过滤&lt;/li&gt;
&lt;li&gt;支持代理服务器&lt;/li&gt;
&lt;li&gt;支持用户名和密码验证&lt;/li&gt;
&lt;li&gt;遵守 robots.txt 法则&lt;/li&gt;
&lt;li&gt;支持 Cookie&lt;/li&gt;
&lt;li&gt;支持 HTML 和 CSS 语法检查&lt;/li&gt;
&lt;li&gt;反病毒检查&lt;/li&gt;
&lt;li&gt;提供命令行和图形界面和Web三种用户接口&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在下依旧用菜鸟教程（&lt;a href=&quot;http://www.runoob.com/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;http://www.runoob.com/&lt;/span&gt;&lt;/a&gt;）做个示范，界面如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1525550/201903/1525550-20190314144827261-1858929961.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以上，本人也在不断的学习和摸索中，如果有不对的地方请及时指出～&lt;/p&gt;

</description>
<pubDate>Thu, 14 Mar 2019 07:16:00 +0000</pubDate>
<dc:creator>许小猪</dc:creator>
<og:description>近期迫于公司的要求接触到了链接测试，了解和自行安装了一些链接测试的工具，在这里做一下总结： 一、XENU（https://www.oschina.net/p/xenu） 1、原理：如果网站内文件、链接</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xuxiaozhu/p/10530461.html</dc:identifier>
</item>
<item>
<title>Date相关 - Shapeying</title>
<link>http://www.cnblogs.com/shapeY/p/10530444.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shapeY/p/10530444.html</guid>
<description>&lt;p&gt;处理时间是常见的需求，总结下Date类的相关知识&lt;/p&gt;
&lt;h2 id=&quot;构建时间对象&quot;&gt;构建时间对象&lt;/h2&gt;
&lt;blockquote readability=&quot;4.7297297297297&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date&quot;&gt;Date&lt;/a&gt; 对象基于1970年1月1日（世界标准时间）起的毫秒数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;构建对象实例有多种方式:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;不传入参数，默认以系统当前时间返回一个时间对象.&lt;code&gt;new Date();&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;    new Date();
    // Wed Mar 13 2019 10:49:28 GMT+0800 (中国标准时间)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回的是一个&lt;em&gt;对象实例&lt;/em&gt;，控制台打印了时间字符串，是默认调用了&lt;code&gt;toString()&lt;/code&gt;方法。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;传入 自1970年1月1日00:00:00 (世界标准时间) 起经过的&lt;em&gt;毫秒数&lt;/em&gt;.&lt;code&gt;new Date(value);&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;    new Date(1323532800000);
    // Sun Dec 11 2011 00:00:00 GMT+0800 (中国标准时间)

    // 可以传入负数，代表1970年1月1日00:00:00之前的时间
    new Date(-10000);
    // Thu Jan 01 1970 07:59:50 GMT+0800 (中国标准时间)&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;传入 表示日期的字符串.&lt;code&gt;new Date(dateString);&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;    new Date('2011-11-11')
    new Date('2011/11/11')
    new Date('11/11/2011')
    // Fri Nov 11 2011 00:00:00 GMT+0800 (中国标准时间)

    new Date('Sun Dec 11 2011 00:00:00')
    // Sun Dec 11 2011 00:00:00 GMT+0800 (中国标准时间)  注意这里是12月份了，11代表的12月

    new Date('2011-11-11 11:11:11')
    new Date('2011-11-11T11:11:11')
    // Fri Nov 11 2011 11:11:11 GMT+0800 (中国标准时间)

    new Date('aa')
    // Invalid Date&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;只要能被&lt;code&gt;[Date.parse()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date/parse)&lt;/code&gt;解析的字符串，都可以作为参数传入。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;传入 年月日等多个整数参数. &lt;code&gt;new Date(year, month[, day[, hour[, minutes[, seconds[, milliseconds]]]]]);&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;    new Date(2011,11,11,11,11,11,111)
    // Sun Dec 11 2011 11:11:11 GMT+0800 (中国标准时间)
    new Date(2011,11)
    // Thu Dec 01 2011 00:00:00 GMT+0800 (中国标准时间)
   
    new Date(2011)
    // Thu Jan 01 1970 08:00:02 GMT+0800 (中国标准时间)  只传入一个整数参数，会被当做毫秒数解析

    new Date('2011',11,11) 
    //Sun Dec 11 2011 00:00:00 GMT+0800 (中国标准时间)  传入的参数会进行转换
    new Date('2011.11',11,11)
    //Sun Dec 11 2011 00:00:00 GMT+0800 (中国标准时间)

    new Date('a',11,11)
    // Invalid Date  无法转换成数字的参数&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种方式&lt;strong&gt;至少需要传入两个整数参数&lt;/strong&gt;标志年、月，只传入一个参数会当做毫秒数进行构建；传入的参数会自动转换成数字，所以例子中传入数字字符串也是可以创建成功的。&lt;/p&gt;
&lt;p&gt;如果&lt;strong&gt;把&lt;code&gt;Date()&lt;/code&gt;直接当作函数调用&lt;/strong&gt;，不过有没有传入参数，都会返回当前时间的时间字符串&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;Date()
// &quot;Wed Mar 13 2019 20:22:42 GMT+0800 (中国标准时间)&quot;
Date(2011,11)
// &quot;Wed Mar 13 2019 20:22:47 GMT+0800 (中国标准时间)&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;自动折算&quot;&gt;自动折算&lt;/h2&gt;
&lt;p&gt;时间的参数都是有范围的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;年 使用四位数年份，比如2000。如果写成两位数或个位数，则加上1900，即10代表1910年。如果是负数，表示公元前&lt;/li&gt;
&lt;li&gt;月份的范围是0~11 (0是一月份，11是12月份)&lt;/li&gt;
&lt;li&gt;天数的范围是1~31&lt;/li&gt;
&lt;li&gt;小时的范围是0~23&lt;/li&gt;
&lt;li&gt;分钟的范围是0~59&lt;/li&gt;
&lt;li&gt;秒数的范围是0~59&lt;/li&gt;
&lt;li&gt;毫秒的范围是0~999&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果创建时间对象的时候，传入的参数超出了实际范围会怎样呢？&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;    new Date(2010,12,11)
    // Tue Jan 11 2011 00:00:00 GMT+0800 (中国标准时间)  月的参数12超出了范围，年份多了一年，然后月份变成了1月份（对应参数0）
    new Date(2010,11,0)
    // Tue Nov 30 2010 00:00:00 GMT+0800 (中国标准时间)  天的参数0不在范围内，所以月份变成了11（对应参数10），然后天变成了30
    new Date(2010,11,11,25)
    // Sun Dec 12 2010 01:00:00 GMT+0800 (中国标准时间)  小时的参数25超出了范围，天数变成了12，然后小时变成了1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当传入的参数超出了实际范围，&lt;strong&gt;会自动折算成合理的范围&lt;/strong&gt; ， 相邻的数值也会进行调整。&lt;/p&gt;
&lt;p&gt;利用这个特性可以做很多的事情，比如，你想&lt;strong&gt;获取2012年2月有共有多少天&lt;/strong&gt;，可以这样处理。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;    new Date(2012,2,0).getDate()
    // 29  -- 三月(对应2)没有0天，所以折算到二月（对应1）的最后一天，这时取得getDate()即是该月的天数&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;类型转换&quot;&gt;类型转换&lt;/h2&gt;
&lt;p&gt;如果&lt;code&gt;+&lt;/code&gt; 或者 &lt;code&gt;==&lt;/code&gt; 运算符其中一个操作数是对象时，需要先把对象转化成原始值。其他的对象都会先调用&lt;code&gt;valueOf()&lt;/code&gt; 方法，而时间对象类型会先调用&lt;code&gt;toString()&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;1 + new Date()
// &quot;1Thu Mar 14 2019 13:51:46 GMT+0800 (中国标准时间)&quot;

new Date(2011,11,11).getTime() == new Date(2011,11,11)
// false 后面的Date对象，调用了toString()
new Date(2011,11,11).getTime() == +new Date(2011,11,11)
// true 此时隐式转换期待转换为数字，调用了valueOf()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其他期待转换为数字的场景，也是正常先调用&lt;code&gt;valueOf()&lt;/code&gt;的&lt;/p&gt;
&lt;h2 id=&quot;时间戳&quot;&gt;时间戳&lt;/h2&gt;
&lt;p&gt;时间对象在传递过程中，一般会转换为时间戳，有多种实现方式&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;new Date(2011,11,11).valueOf()
// 1323532800000
new Date(2011,11,11).getTime()
// 1323532800000
+new Date(2011,11,11)
// 1323532800000

Date.now()
// 1552543813256  当前时间距离时间零点（1970年1月1日 00:00:00 UTC）的毫秒数&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意以上都是毫秒，如果要转成UNIX时间戳（从1970年1月1日（UTC/GMT的午夜）开始所经过的秒数），可以用以下方法&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;Math.round(ms/1000)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;原生方法&quot;&gt;原生方法&lt;/h2&gt;
&lt;p&gt;Date对象提供了多种方法来获取/设置时间数据&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Date对象提供了一系列get*方法，用来获取实例对象某个方面的值。&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;getTime()：返回实例距离1970年1月1日00:00:00的毫秒数，等同于valueOf方法。&lt;/li&gt;
&lt;li&gt;getDate()：返回实例对象对应每个月的几号（从1开始）。&lt;/li&gt;
&lt;li&gt;getDay()：返回星期几，星期日为0，星期一为1，以此类推。&lt;/li&gt;
&lt;li&gt;getFullYear()：返回四位的年份。&lt;/li&gt;
&lt;li&gt;getMonth()：返回月份（0表示1月，11表示12月）。&lt;/li&gt;
&lt;li&gt;getHours()：返回小时（0-23）。&lt;/li&gt;
&lt;li&gt;getMilliseconds()：返回毫秒（0-999）。&lt;/li&gt;
&lt;li&gt;getMinutes()：返回分钟（0-59）。&lt;/li&gt;
&lt;li&gt;getSeconds()：返回秒（0-59）。&lt;/li&gt;
&lt;li&gt;getTimezoneOffset()：返回当前时间与 UTC 的时区差异，以分钟表示，返回结果考虑到了夏令时因素。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;还提供了这些方法对应的 UTC 版本，用来返回 UTC 时间。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;getUTCDate()&lt;/li&gt;
&lt;li&gt;getUTCFullYear()&lt;/li&gt;
&lt;li&gt;getUTCMonth()&lt;/li&gt;
&lt;li&gt;getUTCDay()&lt;/li&gt;
&lt;li&gt;getUTCHours()&lt;/li&gt;
&lt;li&gt;getUTCMinutes()&lt;/li&gt;
&lt;li&gt;getUTCSeconds()&lt;/li&gt;
&lt;li&gt;getUTCMilliseconds()&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;new Date(2011,11,11,11,11,11,111).getHours()
// 11
new Date(2011,11,11,11,11,11,111).getUTCHours()
// 3 可见UTC时间比北京时间晚8个小时，也就是下面的时区差异 -480分钟
new Date(2011,11,11,11,11,11,111).getTimezoneOffset()
// -480&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;Date对象提供了一系列set*方法，用来设置实例对象的各个方面。&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;setDate(date)：设置实例对象对应的每个月的几号（1-31），返回改变后毫秒时间戳。&lt;/li&gt;
&lt;li&gt;setFullYear(year [, month, date])：设置四位年份。&lt;/li&gt;
&lt;li&gt;setHours(hour [, min, sec, ms])：设置小时（0-23）。&lt;/li&gt;
&lt;li&gt;setMilliseconds()：设置毫秒（0-999）。&lt;/li&gt;
&lt;li&gt;setMinutes(min [, sec, ms])：设置分钟（0-59）。&lt;/li&gt;
&lt;li&gt;setMonth(month [, date])：设置月份（0-11）。&lt;/li&gt;
&lt;li&gt;setSeconds(sec [, ms])：设置秒（0-59）。&lt;/li&gt;
&lt;li&gt;setTime(milliseconds)：设置毫秒时间戳。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这些方法基本是跟get&lt;em&gt;方法一一对应的，但是&lt;strong&gt;没有setDay方法，因为星期几是计算出来的，而不是设置的&lt;/strong&gt;。&lt;br/&gt;set&lt;/em&gt;系列方法除了setTime()，都有对应的 UTC 版本，即设置 UTC 时区的时间。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;setUTCDate()&lt;/li&gt;
&lt;li&gt;setUTCFullYear()&lt;/li&gt;
&lt;li&gt;setUTCHours()&lt;/li&gt;
&lt;li&gt;setUTCMilliseconds()&lt;/li&gt;
&lt;li&gt;setUTCMinutes()&lt;/li&gt;
&lt;li&gt;setUTCMonth()&lt;/li&gt;
&lt;li&gt;setUTCSeconds()&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;设置时间的方法，配合自动折算，可以很便捷的得到相对时间&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;let now = new Date();

// 99天之后的时间
now.setDate(now.getDate() + 99)

// 10小时之前
now.setHours(now.getHours() - 10)
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;date对象提供一系列to* ，用来将时间对象转换为字符串&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;toString() 返回一个完整的日期字符串。&lt;/li&gt;
&lt;li&gt;toDateString() 返回年月日的字符串&lt;/li&gt;
&lt;li&gt;toTimeString() 返回时间字符串，不包含年月日&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;也有对应的 UTC 版本 和 local版本&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;toUTCString() 返回对应的 UTC 时间，也就是比北京时间晚8个小时。&lt;/li&gt;
&lt;li&gt;toLocaleString() 返回完整的本地时间。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;let now = new Date()
undefined
now.toString()
// &quot;Thu Mar 14 2019 14:32:18 GMT+0800 (中国标准时间)&quot;
now.toUTCString()
// &quot;Thu, 14 Mar 2019 06:32:18 GMT&quot;    UTC时间比北京时间晚8个小时
now.toLocaleString()
// &quot;2019/3/14 下午2:32:18&quot;&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 14 Mar 2019 07:14:00 +0000</pubDate>
<dc:creator>Shapeying</dc:creator>
<og:description>处理时间是常见的需求，总结下Date类的相关知识 构建时间对象 'Date' 对象基于1970年1月1日（世界标准时间）起的毫秒数。 构建对象实例有多种方式: 1. 不传入参数，默认以系统当前时间返回</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shapeY/p/10530444.html</dc:identifier>
</item>
<item>
<title>为什么要讲数据结构和算法？以及如何学习数据结构和算法 - 自由飞</title>
<link>http://www.cnblogs.com/freeflying/p/10530279.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/freeflying/p/10530279.html</guid>
<description>&lt;div readability=&quot;90&quot;&gt;
&lt;p&gt;“飞哥你变了！”&lt;/p&gt;
&lt;p&gt;“没想到你这个浓眉大眼的，也叛变了革命……”&lt;/p&gt;
&lt;p&gt;这就是我在讲《数据结构和算法》的时候，脑子里浮现出来的台词。&lt;/p&gt;
&lt;p&gt;熟悉我的同学都知道，我是一个“实战派”，&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;img-responsive&quot; title=&quot;&quot; src=&quot;http://17bang.ren/Images/Summary/2019/3/13/1/v2-12b4f5b965b9f8b473568b7dd3c52e06_hd.jpg&quot; alt=&quot;&quot; data-original-title=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一直在强调学编程要尽快“上手”，做出东西来，看到效果，获得正反馈和自激励……而《计算机组成和原理》《编译原理》《数据结构和算法》之类的，是能排在多后面，就排在多后面的东西。&lt;/p&gt;

&lt;p&gt;但为什么源栈一开课就讲数据机构，第二天就写“二分查找”呢？（对了，附上当天群聊天记录若干……）&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;img-responsive&quot; title=&quot;&quot; src=&quot;http://17bang.ren/Images/Summary/2019/3/13/1/%E4%BA%8C%E5%88%86%E6%90%9E%E7%AC%91.jpg&quot; alt=&quot;&quot; data-original-title=&quot;&quot;/&gt;&lt;/p&gt;
&lt;img class=&quot;img-responsive&quot; title=&quot;&quot; src=&quot;http://17bang.ren/Images/Summary/2019/3/13/1/%E4%BA%8C%E5%88%86%E6%90%9E%E7%AC%91-code.jpg&quot; alt=&quot;&quot; data-original-title=&quot;&quot;/&gt;&lt;p&gt;这特么的就是传说中的“人工”智能啊！&lt;/p&gt;
&lt;p&gt;当然，以上为搞笑版。&lt;/p&gt;
&lt;p&gt;事实上同学们最后都写出来了。写出来之后回头看看，“其实也没有那么难嘛！”&lt;/p&gt;
&lt;p&gt;^_^，你确定？&lt;/p&gt;

&lt;p&gt;其实，讲《数据机构和算法》，最大最大的原因，就&lt;strong&gt;是“面向就业”编程的需要&lt;/strong&gt;。有非常大的概率，你面试的时候，面试官就让你写一个“冒泡排序法”，你一脸懵逼，写个:&lt;/p&gt;
&lt;pre class=&quot;prettyprint lang-cs prettyprinted&quot;&gt;
&lt;span class=&quot;pln&quot;&gt;            &lt;span class=&quot;typ&quot;&gt;int&lt;span class=&quot;pun&quot;&gt;[]&lt;span class=&quot;pln&quot;&gt; numbers &lt;span class=&quot;pun&quot;&gt;=&lt;span class=&quot;pln&quot;&gt; &lt;span class=&quot;kwd&quot;&gt;new&lt;span class=&quot;pln&quot;&gt; &lt;span class=&quot;typ&quot;&gt;int&lt;span class=&quot;pun&quot;&gt;[]&lt;span class=&quot;pln&quot;&gt; &lt;span class=&quot;pun&quot;&gt;{&lt;span class=&quot;pln&quot;&gt; &lt;span class=&quot;lit&quot;&gt;3&lt;span class=&quot;pun&quot;&gt;,&lt;span class=&quot;pln&quot;&gt; &lt;span class=&quot;lit&quot;&gt;1&lt;span class=&quot;pun&quot;&gt;,&lt;span class=&quot;pln&quot;&gt; &lt;span class=&quot;lit&quot;&gt;8&lt;span class=&quot;pun&quot;&gt;,&lt;span class=&quot;pln&quot;&gt; &lt;span class=&quot;lit&quot;&gt;12&lt;span class=&quot;pun&quot;&gt;,&lt;span class=&quot;pln&quot;&gt; &lt;span class=&quot;lit&quot;&gt;7&lt;span class=&quot;pun&quot;&gt;,&lt;span class=&quot;pln&quot;&gt; &lt;span class=&quot;lit&quot;&gt;9&lt;span class=&quot;pun&quot;&gt;,&lt;span class=&quot;pln&quot;&gt; &lt;span class=&quot;lit&quot;&gt;10&lt;span class=&quot;pln&quot;&gt; &lt;span class=&quot;pun&quot;&gt;};&lt;span class=&quot;pln&quot;&gt;
            &lt;span class=&quot;kwd&quot;&gt;var&lt;span class=&quot;pln&quot;&gt; result &lt;span class=&quot;pun&quot;&gt;=&lt;span class=&quot;pln&quot;&gt;  numbers&lt;span class=&quot;pun&quot;&gt;.&lt;span class=&quot;typ&quot;&gt;AsEnumerable&lt;span class=&quot;pun&quot;&gt;().&lt;span class=&quot;typ&quot;&gt;OrderBy&lt;span class=&quot;pun&quot;&gt;(&lt;span class=&quot;pln&quot;&gt;m &lt;span class=&quot;pun&quot;&gt;=&amp;gt;&lt;span class=&quot;pln&quot;&gt; m&lt;span class=&quot;pun&quot;&gt;);&lt;span class=&quot;pln&quot;&gt;
            &lt;span class=&quot;kwd&quot;&gt;foreach&lt;span class=&quot;pln&quot;&gt; &lt;span class=&quot;pun&quot;&gt;(&lt;span class=&quot;kwd&quot;&gt;var&lt;span class=&quot;pln&quot;&gt; item &lt;span class=&quot;kwd&quot;&gt;in&lt;span class=&quot;pln&quot;&gt; result&lt;span class=&quot;pun&quot;&gt;)&lt;span class=&quot;pln&quot;&gt;
            &lt;span class=&quot;pun&quot;&gt;{&lt;span class=&quot;pln&quot;&gt;
                &lt;span class=&quot;typ&quot;&gt;Console&lt;span class=&quot;pun&quot;&gt;.&lt;span class=&quot;typ&quot;&gt;WriteLine&lt;span class=&quot;pun&quot;&gt;(&lt;span class=&quot;pln&quot;&gt;item&lt;span class=&quot;pun&quot;&gt;);&lt;span class=&quot;pln&quot;&gt;
            &lt;span class=&quot;pun&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
那就比较尴尬了。

&lt;p&gt;这不一看就是培训班出来的嘛！&lt;/p&gt;
&lt;p&gt;虽然说飞哥对培训班的同学毫无偏见，但其他人不这么想啊，所以我也没有办法——至少目前是没有办法的。只能是希望通过我们所有人持之以恒的不懈努力，逐渐的改变这种歧视和偏见。在此之前，大家还是委曲求全，憋说是“源栈”培训出来的，就是是自己“自学”的吧……&lt;/p&gt;

&lt;p&gt;除此以外的理由，应该就是自己说服自己，硬找的了。按靠谱程度，依次排列：&lt;/p&gt;
&lt;ol readability=&quot;2&quot;&gt;&lt;li&gt;理解并学会“用循环和分支解决问题”的“电脑”思维。很多零基础的同学对此是一脸懵逼的（包括当年飞哥自己），比如排序，人的思维是怎么样的？找到最大值放第一个，然后第二个第三个啊……我们就不会考虑：电脑怎么知道哪一个数是最大的呢？但是呢，这种训练，是一把双刃剑，过深的纠结于具体的过程，会给我们理解“面向对象”造成干扰：又让我们不敢抽象不能抽象！&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;教学需要。你说，刚学会变量赋值，if...else和for循环的孩子，你能给他布置一个什么作业呢？就只有这些排序啊查找啊需求简单，不涉及任何类库框架，刚刚好。其实这也是面试新人时爱用简单算法的原因。就面试那点时间，总不能讲需求就讲半个小时吧？!&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;向其中所凝聚的人类智慧致敬。这是真心的，反正我在准备软考，博览群书的时候，是被震撼到了的。作为一个文科生，我真心好奇这些人的脑子是怎么构造的，能想出这么多匪夷所思的办法出来？其实有很多东西，不一定是要有用才需要学，那些美好瑰丽的东西，只是看一看，都是一种享受。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;浪漫和逼格，偶尔还是可以有——而且可以用来怼人！一直有同学问我考了软考有什么用没有。我想了又想，除了一部分的知识在以后潜移默化的滋润渗透，对编程开发有所裨益之外，最重要的一个作用就是给了我底气：当某些（注意，仅仅是某些）科班生，在我面前鼻孔朝天，但其实渣渣的时候，我可以毫不心虚的怼回去：要不我们来比一比？看看什么你会的我不会，我会的你不会？他们自然就怂了，其实他们也就多知道那么几个名词而已，¯\_(ツ)_/¯，上了个大学有什么了不起，学的又不是国家机密核心技术……&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我说了为什么教，可能同学们更关心的是怎么学。&lt;/p&gt;
&lt;p&gt;其实我一直反对的，是“数据结构和算法”至上论（同样我反对的，还有“学历”至上论），注意“&lt;strong&gt;至上&lt;/strong&gt;”这两个字。比如那种说法，“不学数据结构和算法，一辈子都是码畜”，我就非常讨厌。真的是非常讨厌，哪怕我自己好歹学了点。知识，是没有高低贵贱之分的。&lt;/p&gt;
&lt;p&gt;总有些人，觉得有什么缺了它就不行的“核心”技术——但我告诉你，做成一件事，其实缺了哪一门技术都不行。比如造汽车，大家都觉得发动机是核心是关键，但其实一款汽车在市场上卖得好卖得不好，难道就是因为她的发动机好或者不好？用大拇指想想也知道是不可能的！可能一款车大卖，靠的就是最不核心最不核心的技术：好看。这个世界还是看脸的，比如说飞哥，明明就可以靠颜值……唉哟！哪里来的臭鸡蛋？唉哟，又是一个，嫉妒，赤果果的嫉妒啊！&lt;/p&gt;
&lt;p&gt;好了好了，说正事，如果你因为众多车型因为外观热卖，就说“外观设计”就说汽车工业的核心，那就又犯了同样的错误。难道发动机制动就不重要了么？没有发动机，跑都跑不起来，还卖个屁！&lt;/p&gt;
&lt;p&gt;所以，其实无论是一件事，或者一个人的成功，都是综合因素的结果。只是我们看问题的时候，有意无意的，忽略了很多很多方面，按我们的想象，把成功简单的归结于某一点。&lt;/p&gt;
&lt;p&gt;好像又有一点跑题。长话短说，数据结构和算法，怎么学，看你的兴趣。实际上，学无止境，&lt;strong&gt;只要尽力了，能学到哪里就到哪里&lt;/strong&gt;，没有什么问题。计算机发展到今天，其实已经大量封装高度抽象啦，我们做程序员，不一定个个都得造轮子。其实能把别人的轮子用好，能做一个所谓的好码农，都已经很了不起了。定义稍稍严格一点，很多很多的程序猿，连“合格”都够不上。&lt;/p&gt;
&lt;p&gt;当然，你说，我对这玩意儿特别感兴趣……那没关系啊，盘他！是不是？但是呢，给个小建议，别盘出什么优越感来了。没必要，还拉仇恨值，关键的关键，这很有可能让你变得狭隘，局限你的视野：除了数据结构和算法，原本还有很多很多很有意思很有挑战性的东西。&lt;/p&gt;

&lt;p&gt;最后的最后，给没时间看我视频的同学简单总结两条：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;知其然，更要知其所以然。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据机构是算法的基础&lt;/strong&gt;，两者不可割裂。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;很多教材，讲数据结构就“链表”“二叉树”的讲数据结构，数据结构是什么样子的，怎么插入怎么删除怎么查找，什么都讲了，但为什么需要这样的数据结构？不讲！或者一笔带过……这是非常非常不负责任的！飞哥那时候学数据结构，这一点是把我坑死了的。很后来很后来，也不知道是哪里东看一句西捡一段，“哦，链表是为了内存管理！”“栈，是方便函数调用”“二叉树就是数据库的索引”……这样点点滴滴的才把这些东西串起来，数据结构的世界才豁然开朗。&lt;/p&gt;
&lt;p&gt;学习，你一定要知道学习的目的，学习的意义，你才能更好的坚持下去。就像走路，蒙着你的眼睛，让旁边人告诉你“往前三步，左转两步，再右转走十步”，你想想，这种模式，有几个人能撑到下去？还不如一开始就告诉他，“今天我们去哪里，跟着我走！”&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Thu, 14 Mar 2019 06:52:00 +0000</pubDate>
<dc:creator>自由飞</dc:creator>
<og:description>“飞哥你变了！” “没想到你这个浓眉大眼的，也叛变了革命……” 这就是我在讲《数据结构和算法》的时候，脑子里浮现出来的台词。 熟悉我的同学都知道，我是一个“实战派”， 一直在强调学编程要尽快“上手”，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/freeflying/p/10530279.html</dc:identifier>
</item>
<item>
<title>类加载机制 - 不该相遇在秋天</title>
<link>http://www.cnblogs.com/fengyumeng/p/10530218.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fengyumeng/p/10530218.html</guid>
<description>&lt;h3&gt;类的生命周期&lt;/h3&gt;
&lt;p&gt;　　一个java文件的整个生命周期，总共要经历加载-验证-准备-解析-初始化-使用-卸载这几个阶段，有的人把验证准备解析归纳为一个阶段称为链接，所有有的说5个阶段的，也有说7个阶段的，两种说法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1181622/201903/1181622-20190314142514399-763139427.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;什么时候开始加载？&lt;/h3&gt;
&lt;p&gt;　　1.用new实例化对象的时候。&lt;/p&gt;
&lt;p&gt;　　2.读取或者设置一个类的静态字段的时候。&lt;/p&gt;
&lt;p&gt;　　3.调用一个类的静态方法的时候。&lt;/p&gt;
&lt;p&gt;　　4.使用java.lang.reflect包的方法对类进行反射的时候，如果类没有进行过初始化，则需要先触发其初始化。&lt;/p&gt;
&lt;p&gt;　　5.当初始化一个类的时候，如果发现这个类的父类还没有进行过初始化，则需要先触发其父类的初始化。&lt;/p&gt;
&lt;p&gt;　　6.当虚拟机启动的时候，如果java程序中包含main()主函数的类，则该类的加载由JVM自动触发。&lt;/p&gt;
&lt;h3&gt;加载&lt;/h3&gt;
&lt;h4&gt;反射机制的原理&lt;/h4&gt;
&lt;p&gt;　　所谓加载，就是将java类的字节码文件加载到机器内存中，并在内存中构建出java类的原型-类模板对象。&lt;/p&gt;
&lt;p&gt;　　所谓类模板对象，其实就是java类在JVM内存中的一个快照，JVM将从字节码文件中解析出常量池、类字段、类方法等信息存储到类模板中，这样JVM在运行期便能通过类模板而获取Java类中的任意信息，能够对java类的成员变量进行遍历，也能进行java方法的调用，这就是反射机制背后的原理，如果JVM没有将java类的声明信息保存起来，则JVM在运行期也无法对类进行反射。&lt;/p&gt;
&lt;h4&gt;要完成的三件事&lt;/h4&gt;
&lt;p&gt;　　在这个加载阶段，虚拟机需要完成以下三件事情：&lt;/p&gt;
&lt;p&gt;　　1.通过一个类的全限定名（完整包名、URL地址、数据库生成、等等）来获取定义此类的二进制字节流。&lt;/p&gt;
&lt;p&gt;　　2.将整个字节流所代表的静态存储结构转化为方法区的运行时数据结构。&lt;/p&gt;
&lt;p&gt;　　3.在内存中生成一个代表整个类的java.lang.Class对象，作为方法区整个类的各种数据的访问入口。&lt;/p&gt;
&lt;p&gt;加载阶段完成之后，虚拟机外部的二进制字节流就按照虚拟机所需要的格式存储在方法区之中，然后在内存中实例化一个java.lang.Class类的对象。&lt;/p&gt;
&lt;h4&gt;交叉进行&lt;/h4&gt;
&lt;p&gt;　　需要注意的是，加载阶段与后面的验证准备解析阶段并非是阻塞式进行，可能加载阶段尚未完成，后面的阶段就已经开始了。&lt;/p&gt;
&lt;h3&gt;验证&lt;/h3&gt;
&lt;h4&gt;验证的重要性&lt;/h4&gt;
&lt;p&gt;　　验证这一阶段的目的是为了确保class文件的字节流中包含的信息是否符合虚拟机的要求。这个很好理解，随便一个程序，你少写一个标点符号看看还能不能进行编译。&lt;/p&gt;
&lt;p&gt;　　虚拟机如果不检查输入的字节流，对其完全信任的话，很可能会因为载入了有害的字节流而导致系统崩溃，所以验证是虚拟机对自身保护的一项重要操作。&lt;/p&gt;
&lt;h4&gt;文件格式验证&lt;/h4&gt;
&lt;p&gt;　　首先需要验证字节流是否符合class文件格式的规范，并且可以被当前虚拟机处理。&lt;/p&gt;
&lt;p&gt;验证内容列举几项：&lt;/p&gt;
&lt;p&gt;　　1.版本号是否在当前虚拟机处理范围之内。&lt;/p&gt;
&lt;p&gt;　　2.常量池的唱两种是否有不被支持的常量类型。&lt;/p&gt;
&lt;p&gt;　　3.指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。&lt;/p&gt;
&lt;p&gt;　　4.class文件中各个部分以及文件本身是否有被删除的或附加的其他信息。&lt;/p&gt;
&lt;h4&gt;元数据验证&lt;/h4&gt;
&lt;p&gt;　　接下来是对字节码描述的信息进行语义分析，以保证符合java语言规范的要求。&lt;/p&gt;
&lt;p&gt;验证内容列举几项：&lt;/p&gt;
&lt;p&gt;　　1.这个类有没有父类，因为除了java.lang.Object之外，所有的类都应该有父类 。&lt;/p&gt;
&lt;p&gt;　　2.这个类的父类是否继承了不允许被继承的类（比如被final修饰的类）。&lt;/p&gt;
&lt;p&gt;　　3.如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。&lt;/p&gt;
&lt;p&gt;　　4.类中的字段、方法是否与父类产生矛盾。&lt;/p&gt;
&lt;h4&gt;字节码验证&lt;/h4&gt;
&lt;p&gt;　　这个验证将对类的方法体进行校验分析，保证被校验的方法在运行时不会做出危害虚拟机安全的事件。&lt;/p&gt;
&lt;p&gt;验证内容举例几项：&lt;/p&gt;
&lt;p&gt;　　1.保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似这样的情况：在操作栈放置了一个Int类型的数据，使用时却按照long类型来加载入本地变量表中。&lt;/p&gt;
&lt;p&gt;　　2.保证跳转指令不会跳转到方法体以外的字节码指令上。&lt;/p&gt;
&lt;p&gt;　　3.保证方法体中的类型转换是有效合法的。&lt;/p&gt;
&lt;h4&gt;符号引用验证&lt;/h4&gt;
&lt;p&gt;　　符号引用验证可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验。&lt;/p&gt;
&lt;p&gt;验证内容举例几项：&lt;/p&gt;
&lt;p&gt;　　1.符号引用中通过字符串描述的全限定名是否能找到对应的类。&lt;/p&gt;
&lt;p&gt;　　2.在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段。&lt;/p&gt;
&lt;p&gt;　　3.符号引用中类、字段、方法的访问性（private/protected/public/default）是否可被当前类访问。&lt;/p&gt;
&lt;h3&gt;准备&lt;/h3&gt;
&lt;p&gt;　　准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。&lt;/p&gt;
&lt;p&gt;　　这个阶段有两个概念容易产生混淆。首先，准备阶段进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在java堆中。&lt;/p&gt;
&lt;p&gt;　　其次，这里所说的初始值通常情况下是数据类型的零值，假设一个类变量定义为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; value = 123;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　那变量value在准备阶段过后的初始值为0，而不是123，因为这时候还没有开始执行任何java方法。&lt;/p&gt;
&lt;p&gt;　　但是，如果是final修饰的变量，如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; value = 123;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　那么在准备阶段变量value就会被初始化为123。&lt;/p&gt;
&lt;h3&gt;解析&lt;/h3&gt;
&lt;p&gt;　　解析的过程就是JVM将常量池中的符号引用替换为直接引用的过程。&lt;/p&gt;
&lt;p&gt;　　比如说一个变量的类型是某个对象，那么解析的时候需要把这个变量类型替换成直接指向该对象的指针。&lt;/p&gt;
&lt;p&gt;　　对同一个符号引用进行多次解析是很常见的事情，虚拟机会对第一次解析的结果进行缓存，从而避免解析动作重复执行。&lt;/p&gt;
&lt;h3&gt;初始化&lt;/h3&gt;
&lt;p&gt;　　完成上面几个阶段后，便会进入类的初始化阶段。&lt;/p&gt;
&lt;p&gt;　　所谓初始化，说白了就是调用java类的&amp;lt;clinit&amp;gt;()方法，该方法是编译器在编译期间自动生成的，当java类中出现静态字段或者包含static{}块时，编译出来的java字节码文件中就会自动包含一个名为&amp;lt;clinit&amp;gt;的方法，该方法不能由程序员在java程序中调用，只能由JVM在运行期调用，这个调用的过程就是java类的初始化。&lt;/p&gt;
&lt;p&gt;注意：&amp;lt;clinit&amp;gt;()方法并非类的构造函数。&lt;/p&gt;
&lt;h3&gt;类加载器&lt;/h3&gt;
&lt;p&gt;　　要想再JVM内部创建一个与java类完全对等的结构模型，必须经过类加载器。&lt;/p&gt;
&lt;h4&gt;类加载器的定义&lt;/h4&gt;
&lt;p&gt;　　java体系中定义了3种类加载器，分别如下：&lt;/p&gt;

&lt;p&gt;　　1.Bootstrap ClassLoader，引导类加载器，也被称作启动类加载器，加载指定的JDK核心类库，该加载器是由C++语言定义的，是虚拟机自身的一部分，无法由java应用程序直接引用，负责加载下列三种情况下所指定的核心类库：&lt;/p&gt;
&lt;p&gt;①、%JAVA_HOME%/jre/lib目录&lt;br/&gt;②、-Xbootclasspath参数所指定的目录&lt;br/&gt;③、系统属性sun.boot.class.path指定的目录中特定名称的jar包&lt;/p&gt;

&lt;p&gt;　　2.Extension ClassLoader，扩展类加载器，加载扩展类，扩展JVM的类库，该加载器加载下列两种情况下所指定的类库：&lt;/p&gt;
&lt;p&gt;①、%JAVA_HOME%/jre/lib/ext目录&lt;br/&gt;②、系统属性java.ext.dirs所指定的目录中的所有类库&lt;/p&gt;

&lt;p&gt;　　3.App ClassLoader，系统类加载器，也被称作应用程序类加载器，加载java应用程序类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。&lt;/p&gt;

&lt;h4&gt;类与类是否相等&lt;/h4&gt;
&lt;p&gt;　　对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立在java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。&lt;/p&gt;
&lt;p&gt;　　这句话反过来说就是，比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下，比较才有意义，否则，就算这两个类都来源于同一个class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那么这两个类就必定不相等。&lt;/p&gt;
&lt;p&gt;　　这里所指的“相等”，包括equals()方法、isAssignableFrom()方法、isInstance()方法的返回结果，也包括使用instanceof关键字对所属关系判定情况。&lt;/p&gt;
&lt;p&gt;　　以下演示不同类加载器加载出的类比较结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception{
        ClassLoader loader &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ClassLoader() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Class&amp;lt;?&amp;gt; loadClass(String name) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ClassNotFoundException {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
                    String fileName &lt;/span&gt;= name.substring(name.lastIndexOf(&quot;.&quot;) + 1) + &quot;.class&quot;&lt;span&gt;;
                    InputStream is &lt;/span&gt;=&lt;span&gt; getClass().getResourceAsStream(fileName);
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(is == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.loadClass(name);
                    }
                    &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] b = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[is.available()];
                    is.read(b);
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; defineClass(name,b,0&lt;span&gt;,b.length);
                }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e){
                    &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ClassNotFoundException(name);
                }
            }
        };
        Object obj1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Test();
        System.out.println(&lt;/span&gt;&quot;obj1：&quot; +&lt;span&gt; obj1.toString());
        Object obj2 &lt;/span&gt;= loader.loadClass(&quot;Test&quot;&lt;span&gt;).newInstance();
        System.out.println(&lt;/span&gt;&quot;obj2：&quot; +&lt;span&gt; obj2.toString());
        System.out.println(obj1.equals(obj2));
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;p&gt;obj1：Test@88ff2c&lt;br/&gt;obj2：Test@c0663d&lt;br/&gt;false&lt;/p&gt;
&lt;p&gt;　　该示例中，obj1对象是由系统类加载器加载的，obj2对象是由我们自定义的类加载器加载的，虽然都来自于同一个class文件，但依然是两个独立的类。&lt;/p&gt;

&lt;p&gt;　　这里有的人会遇到一个问题，把obj2转成Test类型，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Test obj2 = (Test)loader.loadClass(&quot;Test&quot;).newInstance();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　一运行会发现抛出这样一个错：&lt;/p&gt;
&lt;p&gt;Exception in thread &quot;main&quot; java.lang.ClassCastException: Test cannot be cast to Test&lt;/p&gt;
&lt;p&gt;　　原因在于等号左边所声明的Test类型并没有明确为其指定类加载器，所以JVM会使用系统类加载器加载Test类，而等号右边则明确使用了自定义的类加载器加载Test类，所以等号左右两边的两个Test类型的加载器并不是同一个。&lt;/p&gt;
&lt;p&gt;　　这种异常在使用第三方框架比如Spring的时候会比较常见，究其原因，是因为很多中间件内部都有自定义的类加载器，因此被内存加载器所加载的类型，是没有办法直接转换为使用默认加载器加载的类型。&lt;/p&gt;
&lt;h4&gt;双亲委派模型&lt;/h4&gt;
&lt;p&gt;　　JVM加载一个类的逻辑为以下三步：&lt;/p&gt;
&lt;p&gt;第一步：在当前加载器的缓存中查找有没有这个类，如果有，直接返回，否则走下一步。&lt;/p&gt;
&lt;p&gt;第二步：跳到父加载器，重复第一步内容，直到跳到最顶级的引导类加载器为止，如果缓存中还没有这个类，则继续下一步。&lt;/p&gt;
&lt;p&gt;第三步：引导类加载器进行加载，如果加载不到，则让子加载器一级一级进行加载，直到加载成功。&lt;/p&gt;

&lt;p&gt;　　假设当前加载的是java.lang.Object这个类，当JVM准备加载时，JVM默认会使用系统类加载器去加载，按照上面三步的逻辑，第一步走过，因为系统类加载器和扩展类加载器的缓存中都不会有该类，走到第二步 到了引导类加载器，如果加载过，则取缓存，如果没加载过，则由引导类加载器进行加载，如果引导类加载器的搜索范围内找不到该类，那么会下发到扩展类加载器进行加载。&lt;/p&gt;
&lt;p&gt;　　这就是双亲委派机制。&lt;/p&gt;
&lt;p&gt;　　这种机制保证核心类库一定是由引导类加载器进行加载，而不会被多种加载器加载，否则每个加载器都会加载一遍核心类库，这个世界就乱了，同时也会存在安全隐患。&lt;/p&gt;

&lt;p&gt;　　双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到该类）时，子加载器才会尝试自己去加载。&lt;/p&gt;
&lt;p&gt;如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1181622/201903/1181622-20190314145034644-1585072325.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　简而言之，双亲委派从本质上而言，其实规定了类加载的顺序是：引导类加载器先加载，若加载不到，由扩展类加载器加载，若还加载不到，才会由系统类加载器或自定义的类加载器进行加载。&lt;/p&gt;
&lt;h4&gt;&quot;new&quot;做了什么事情？&lt;/h4&gt;
&lt;p&gt;　　类的生命周期分为7个阶段，加载完成之后需要进行链接（验证、准备、解析）和初始化，在链接阶段，字节码指令会被重写，将其所引用的常量池的索引号转换为直接引用。&lt;/p&gt;
&lt;p&gt;　　比如说，在实例化一个类的时候，编译后生成的字节码指令为：new #2。后面这个#2表示常量池中索引为2的元素，该元素指向某个java类的全限定名。&lt;/p&gt;
&lt;p&gt;　　如果是实例化Long，常量池中2号索引里存在的是字符串：java.lang.Long。重写后的new字节码指令，后面跟着的就不是#2了，就是指向&quot;java.lang.Long&quot;这个字符串的内存地址。&lt;/p&gt;
&lt;p&gt;　　当JVM真正运行到new这条指令的时候，它要根据java类的全限定名称，在内存metaspace区定位到这个java类在内存中的类模板对象-instanceKlass。类模板对象包含了原始java类中的一切信息，JVM会根据这个模板创建出java类的实例对象。&lt;/p&gt;
&lt;p&gt;注意：为了避免每次new都要进行一次定位，JVM会在第一次执行new指令时，就会将定位到的类模板对象缓存起来，这样子后续需要再次实例化同样的java类对象时，便会直接从缓存中读取模板。&lt;/p&gt;

</description>
<pubDate>Thu, 14 Mar 2019 06:43:00 +0000</pubDate>
<dc:creator>不该相遇在秋天</dc:creator>
<og:description>类的生命周期 一个java文件的整个生命周期，总共要经历加载-验证-准备-解析-初始化-使用-卸载这几个阶段，有的人把验证准备解析归纳为一个阶段称为链接，所有有的说5个阶段的，也有说7个阶段的，两种说</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fengyumeng/p/10530218.html</dc:identifier>
</item>
<item>
<title>现身说法：实际业务出发分析百亿数据量下的多表查询优化 - 依乐祝</title>
<link>http://www.cnblogs.com/yilezhu/p/10530223.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yilezhu/p/10530223.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201903/1377250-20190314144207379-830207946.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;今天给大家带来的讨论主题是通过实战经验来对百亿数据量下的多表数据查询进行优化，俗话说的好，一切脱离业务的架构都是耍流氓，接下来我就整理一下今天早上微信群里石头哥给大家分享的百亿数据量多表查询架构以及优化思路。由于本文内容整理自微信群，爬楼不易，整理更不易，如果有遗漏，欢迎大家在评论区留言。&lt;/p&gt;
&lt;blockquote readability=&quot;2.0987654320988&quot;&gt;
&lt;p&gt;作者：依乐祝&lt;br/&gt;原文地址：&lt;a href=&quot;https://www.cnblogs.com/yilezhu/p/10530223.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/yilezhu/p/10530223.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;简单的例子&quot;&gt;简单的例子&lt;/h2&gt;
&lt;p&gt;这里我们先举个简单的例子，来个开胃菜，然后再引出今天的访谈主题。&lt;/p&gt;
&lt;p&gt;举例：比如我们的CzarCms系统权限系统设计中的两张表：用户表以及角色表，这两张表有关联关系。这时候如果我要取一万个用户的数据，然后用户数据又需要关联角色表来查询对应的角色名称，这时候你会怎么做呢？&lt;/p&gt;
&lt;p&gt;按照以往我们的经验我们会对大表进行尽可能的拆分，能分表就分表。我们在取数据的时候使用下join查询即可实现。&lt;/p&gt;
&lt;p&gt;可是，当我们的系统变得足够大的时候，假设我们的用户表有一百万的用户了，角色表也有近10万的数据，这个时候我们如果还继续使用Join进行查询的时候就会变得非常慢了！&lt;/p&gt;
&lt;p&gt;这时候我们可以改变下思路：就是先把一万条用户数据取出来，然后取所有角色id后再去重的组合，然后用一个查询把所有的角色信息取出来，再在内存中进行相应的拼接处理。&lt;br/&gt;这种思路勉强能够支撑。&lt;/p&gt;
&lt;p&gt;可是如果数据量变得越来越大，这时候我们应该如何来进行处理呢？且看下面来自百亿数据实操的经典访谈。&lt;/p&gt;
&lt;h2 id=&quot;实际业务场景分析&quot;&gt;实际业务场景分析&lt;/h2&gt;
&lt;h3 id=&quot;第一段介绍&quot;&gt;第一段介绍&lt;/h3&gt;
&lt;p&gt;这里，石头哥就以他们公司的实际情况为例来进行了相关的实例阐述：&lt;br/&gt;我们的主要表，都是几亿到几十亿行，一个join不小心就可以弄死数据库,&lt;br/&gt;而且每天1亿包裹在路上，产生3亿多扫描数据&lt;br/&gt;数据存储最少T+1，保存完整的一个月，也就是30到60天&lt;br/&gt;数据量90到180亿&lt;br/&gt;这里面，最常见的就是省,市,区,网点,人员，这5个字段&lt;br/&gt;很久以前，我们只有三五百万业务量的时候，大家都是join五次&lt;br/&gt;后来为了省事，用了10个字段，提前把名称写进去&lt;br/&gt;再后来，发现亏大了&lt;br/&gt;多花了好多空间，并且join不一定是只需要名称字段&lt;br/&gt;于是，进入了新时代，所有数据表都有那基本的5个字段，不许join&lt;br/&gt;查询出来数据后，在内存中再关联省，市，区，网点，人员等信息&lt;br/&gt;地区5万行，网点3万行，人员100万，全部提前加载到内存，加起来不到100M&lt;br/&gt;我们小部门有100台服务器，绝大部分用到这些基础数据&lt;br/&gt;不仅仅上百亿的扫描表，其它业务表，几乎都会带有这些字段，所以，缓存基础数据，不吃亏&lt;/p&gt;
&lt;h3 id=&quot;互动环节&quot;&gt;互动环节&lt;/h3&gt;
&lt;ol readability=&quot;2&quot;&gt;&lt;li&gt;多大的数据量，才不能用join？&lt;br/&gt;答：一般来说，从表100万以内，我们都建议内存缓存，10万以内必须用进程内缓存，没得商量，内存中进行关联即可。&lt;/li&gt;
&lt;li&gt;我们删数据只能一条条删。不允许批删除，这个怎么办？&lt;br/&gt;答：你们DBA可以辞退了，这么简单的事情都不会。&lt;br/&gt;大数据分析的时候，每个月几个亿数据，一条条删，删到何年何月啊，当然是整个分区干掉啦&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;可以分享一下你们的缓存方案吗？&lt;br/&gt;这个就不用了吧，我觉得很多大佬关于缓存的文章就写得非常好！&lt;br/&gt;我这里只补充一些量化的数字：内存速度是Redis速度100倍，Redis缓存速度是数据库至少10倍。&lt;br/&gt;10万以内数据量必须缓存在进程内，100万~1亿数据缓存在Redis，10万~100万可以上下商量，超高查询量（比如每天10亿次）时放内存。&lt;br/&gt;很多文章真的写得挺好的，就是少了点经验数据支撑，读者搞不清楚什么时候该用这个，什么时候该用那个。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;吉吉：以下场景：假设缓存了地区，比如查询人员档案信息列表是1万行 以前是关联查询 现在缓存地区不能关联查询 只能查出一万条然后循环拼接地区显示 ，因为一万行显示本身这场景就不可能，所以增加翻页 一页显示20行 完全不会性能问题 这样做对吗 求教？&lt;br/&gt;答：是的，查询一页20行，理论上要去匹配20次地区，但是地区数据少，省市区才四五千行，省市区加上乡镇街道也不过5万行，可以全量缓存到内存。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;吉吉：明白 谢谢 只是举例 这种思路真的很正确 我们总是从技术考虑全部场景却不考虑产品本身根本不能一劳永逸的搞。&lt;/p&gt;
&lt;ol readability=&quot;5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;真是太牛逼了！感谢分享&lt;br/&gt;答：这么Low的办法，大家都可以想得到，只是可能缺少一个遇到这个数据量的机会罢了，这是咱们.net的际遇，遇到问题可以见招拆招.&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;你说的缓存到进程内，那多个进程内数据怎么保持一致？&lt;br/&gt;答：不保持一致，因为进程级缓存，可以定时更新的，我们方案是默认10秒异步更新缓存，然后也可以按照添删改随时更新。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;我的内存数据以哪个为准？如果我机器是负载均衡，那么几个副本内存不一样啊！&lt;br/&gt;答：以本机为准,没关系，每台服务器上都有一份缓存。缓存10万用户信息，一共也就10M左右内存，你还在意？&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;数据怎么进行存储呢？&lt;br/&gt;答：内存字典进行存储，最常用的就是并行字典 ConcurrentDictionary。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;假设你说的人员数据，那就必然存在 某一时刻 A进程10000人，B进程10002人，可能十秒可能八秒，但你们体量这么大，这个问题不需要处理吗&lt;br/&gt;答：没错，的确存在这样的问题，我们公司有100万人员，但是全公司都知道，新加一个帐号，往往要两三天才能在100多个内部系统全部生效，甚至新签约一家网点，也要两三天以后，各个系统才会认它，等你有那个体量的时候，就可以接受更长的不一致时间，我们在淘宝开店，发布商品，有时候发布成功了，跳转到详情页却是看不到的，等几秒就好了。&lt;br/&gt;另外，&lt;br/&gt;我再说一句恶心一点的情况，大家别拍砖啊，在百亿级数据量之下，就算我算错个几百几千，那又怎么样？？？又怎么样？？&lt;br/&gt;对内，我会严格要求部门人员，务必追求准确；&lt;br/&gt;对外，我会反复提醒部门人员，我们提供的数据精度，最高99.99%，你要敢浪费大量时间在0.01%上，我就敢给你绩效C&lt;br/&gt;不用太死板嘛，把整体工作搞定，让系统稳定工作，那才是咱们的主要工作&lt;br/&gt;用户有万分之一的机会看到不正确的数据，只要再刷新一次能够正确，就一定不是bug&lt;br/&gt;万分之一看到不正确的数据，并且只是万分之一的偏差而已&lt;br/&gt;由此换取的好处是，我们再也不用担心各种该死的“数据一致性。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;今天非常感谢石头哥的精彩分享，相信只有实际的业务操作经验才会有如此深刻的讲解！一切从实际业务出发，脱离理论，实践出真知。还是印证了那句话，一切脱离实际业务的架构都是耍流氓！感谢大家的阅读。&lt;/p&gt;
&lt;p&gt;有想进一步了解石头哥的可以这篇文章《&lt;a href=&quot;https://www.cnblogs.com/yilezhu/p/10249547.html&quot;&gt;论一个程序员的自我修养-从一张图片说起&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;最后为石头哥的XCode打个广告：&lt;/p&gt;
&lt;p&gt;NewLife.XCode是一个有10多年历史的开源数据中间件，支持nfx/netstandard，由新生命团队(2002~2019)开发完成并维护至今，以下简称XCode。&lt;br/&gt;xcode在2018年已经完成对大数据场景的特殊优化改造，2019年的目标是是针对分布式数据场景的优化。&lt;br/&gt;最近石头哥也在为XCode编写系列教程：&lt;br/&gt;整个系列教程会大量结合示例代码和运行日志来进行深入分析，蕴含多年开发经验于其中，代表作有百亿级大数据实时计算项目。&lt;/p&gt;
&lt;p&gt;开源地址：&lt;a href=&quot;https://github.com/NewLifeX/X&quot; class=&quot;uri&quot;&gt;https://github.com/NewLifeX/X&lt;/a&gt;（求star, 670+）&lt;/p&gt;
</description>
<pubDate>Thu, 14 Mar 2019 06:43:00 +0000</pubDate>
<dc:creator>依乐祝</dc:creator>
<og:description>今天给大家带来的讨论主题是通过实战经验来对百亿数据量下的多表数据查询进行优化，俗话说的好，一切脱离业务的架构都是耍流氓，接下来我就整理一下今天早上微信群里石头哥给大家分享的百亿数据量多表查询架构以及优</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yilezhu/p/10530223.html</dc:identifier>
</item>
<item>
<title>TensorFlow下利用MNIST训练模型并识别自己手写的数字 - 控球强迫症</title>
<link>http://www.cnblogs.com/XDU-Lakers/p/10526748.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/XDU-Lakers/p/10526748.html</guid>
<description>&lt;p&gt;&lt;span&gt;最近一直在学习李宏毅老师的机器学习视频教程，学到和神经网络那一块知识的时候，我觉得单纯的学习理论知识过于枯燥，就想着自己动手实现一些简单的Demo,毕竟实践是检验真理的唯一标准！！！但是网上很多的与tensorflow或者神经网络相关的Demo教程都只是在验证官方程序的过程，而如何把这些程序变成自己可以真正利用的程序这一块的资料就比较少，就好比被“玩烂的&quot;MNIST数据集(ML界的”hello world&quot;)，网上是有很多手写数字识别的教程，但那些利用的都是官方提供的数据集，这样就算验证成功了带来的满足感还是远远不够！废话不多说，接下来就让我来介绍一下如何使用Tensorflow和MNIST识别自己写的数字(比如下图这个我写的数字5~~)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1179840/201903/1179840-20190313195943128-1891394613.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本文也参考了某些大神博客的内容。希望能帮助和我一样刚刚起步的同学，大家多多指教。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;相应的代码和官方以及自己的数据集：&lt;a href=&quot;https://github.com/tgpcai/digit_recognition&quot; target=&quot;_blank&quot;&gt;https://github.com/tgpcai/digit_recognition&lt;/a&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;目录：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）MNIST数据集简介&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）利用MNIST数据集训练模型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）自己手写数字，并用matlab进行预处理&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（4）将图片输入网络进行识别&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（5）实践过程遇到的坑与总结&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;h2&gt;&lt;span&gt;(1)MNIST数据集简介&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;既然我们要构建自己的数据集，那我们就必须要了解官方提供的数据集的格式，大小等一些特征。MNIST是一个巨大的手写数字数据集，被广泛应用于机器学习识别领域。MNIST有60000张训练集数据和10000张测试集数据，每一个训练元素都是28*28像素的手写数字图片，而且都是黑白色构成（这里的黑色是一个0-1的浮点数，黑色越深表示数值越靠近1）。在网上搜索一下MNIST，你可以发现图片长这样：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1179840/201903/1179840-20190313201834681-1238780039.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上图就是4张MNIST图片。这些图片并不是传统意义上的png或者jpg格式的图片，因为png或者jpg的图片格式，会带有很多干扰信息，所以我们在创建自己的数据集的时候就必须进行预处理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; 划重点：28*28像素，灰度图&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt; (2)利用MNIST数据集训练模型，并保存模型&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;该Demo使用的模型主要是CNN卷积神经网络，该模型广泛应用于图片识别、自然语言处理等方向。有关CNN卷积神经网络的知识在我的其他博客中有详细介绍，欢迎大家一起交流！上代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;157&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; tensorflow as tf
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; tensorflow.examples.tutorials.mnist &lt;span&gt;import&lt;/span&gt;&lt;span&gt; input_data
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt; 
&lt;span&gt;  4&lt;/span&gt; 
&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义初始化权重的函数&lt;/span&gt;
&lt;span&gt;  6&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; weight_variavles(shape):
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt;     w = tf.Variable(tf.truncated_normal(shape, stddev=0.1&lt;span&gt;))   
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; w
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; 
&lt;span&gt; 10&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义一个初始化偏置的函数&lt;/span&gt;
&lt;span&gt; 11&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; bias_variavles(shape):
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt;     b = tf.Variable(tf.constant(0.1, shape=&lt;span&gt;shape))   
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; b 
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt; 
&lt;span&gt; 15&lt;/span&gt; 
&lt;span&gt; 16&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; model():
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt;     
&lt;span&gt; 18&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;1.建立数据的占位符 x [None, 784]  y_true [None, 10]&lt;/span&gt;
&lt;span&gt; 19&lt;/span&gt;     with tf.variable_scope(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;date&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;):
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt;         x = tf.placeholder(tf.float32, [None, 784&lt;span&gt;])
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt;         
&lt;span&gt; 22&lt;/span&gt;         y_true = tf.placeholder(tf.float32, [None, 10&lt;span&gt;])
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt;         
&lt;span&gt; 24&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;2.卷积层1  卷积:5*5*1,32个filter,strides= 1-激活-池化&lt;/span&gt;
&lt;span&gt; 25&lt;/span&gt;     with tf.variable_scope(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;conv1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;):
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;随机初始化权重&lt;/span&gt;
&lt;span&gt; 27&lt;/span&gt;         w_conv1 = weight_variavles([5, 5, 1, 32&lt;span&gt;])
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt;         b_conv1 = bias_variavles([32&lt;span&gt;])
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt;         
&lt;span&gt; 30&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;对x进行形状的改变[None, 784] ----- [None,28,28,1]&lt;/span&gt;
&lt;span&gt; 31&lt;/span&gt;         x_reshape = tf.reshape(x,[-1, 28, 28, 1])  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;不能填None,不知道就填-1&lt;/span&gt;
&lt;span&gt; 32&lt;/span&gt;         
&lt;span&gt; 33&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; [None,28, 28, 1] -------- [None, 28, 28, 32]&lt;/span&gt;
&lt;span&gt; 34&lt;/span&gt;         x_relu1 = tf.nn.relu(tf.nn.conv2d(x_reshape, w_conv1, strides=[1, 1, 1, 1], padding = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SAME&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) +&lt;span&gt; b_conv1)
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt;         
&lt;span&gt; 36&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;池化 2*2，步长为2，【None, 28,28, 32]--------[None,14, 14, 32]&lt;/span&gt;
&lt;span&gt; 37&lt;/span&gt;         x_pool1 = tf.nn.max_pool(x_relu1, ksize=[1, 2, 2, 1],strides = [1,2,2,1],padding = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SAME&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;         
&lt;span&gt; 39&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;3.卷积层2  卷积:5*5*32,64个filter,strides= 1-激活-池化&lt;/span&gt;
&lt;span&gt; 40&lt;/span&gt;     with tf.variable_scope(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;conv2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;):
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;随机初始化权重和偏置&lt;/span&gt;
&lt;span&gt; 42&lt;/span&gt;         w_conv2 = weight_variavles([5, 5, 32, 64&lt;span&gt;])
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt;         b_conv2 = bias_variavles([64&lt;span&gt;])
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt;         
&lt;span&gt; 45&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;卷积、激活、池化&lt;/span&gt;
&lt;span&gt; 46&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;[None,14, 14, 32]----------【NOne, 14, 14, 64]&lt;/span&gt;
&lt;span&gt; 47&lt;/span&gt;         x_relu2 = tf.nn.relu(tf.nn.conv2d(x_pool1, w_conv2,strides=[1, 1, 1, 1], padding = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SAME&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) +&lt;span&gt; b_conv2)
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt;         
&lt;span&gt; 49&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;池化 2*2，步长为2 【None, 14,14，64]--------[None,7, 7, 64]&lt;/span&gt;
&lt;span&gt; 50&lt;/span&gt;         x_pool2 = tf.nn.max_pool(x_relu2, ksize=[1, 2, 2, 1],strides = [1,2,2,1],padding = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SAME&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt;     
&lt;span&gt; 52&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;4.全连接层 [None,7, 7, 64] --------- [None, 7*7*64] * [7*7*64, 10]+[10] = [none, 10]&lt;/span&gt;
&lt;span&gt; 53&lt;/span&gt;     with tf.variable_scope(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;):
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;随机初始化权重和偏置:&lt;/span&gt;
&lt;span&gt; 55&lt;/span&gt;         w_fc = weight_variavles([7 * 7 * 64, 1024&lt;span&gt;])
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt;         b_fc = bias_variavles([1024&lt;span&gt;])
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt;         
&lt;span&gt; 58&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;修改形状 [none, 7, 7, 64] ----------[None, 7*7*64]&lt;/span&gt;
&lt;span&gt; 59&lt;/span&gt;         x_fc_reshape = tf.reshape(x_pool2,[-1,7 * 7 * 64&lt;span&gt;])
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt;         h_fc1 = tf.nn.relu(tf.matmul(x_fc_reshape, w_fc) +&lt;span&gt; b_fc)
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt; 
&lt;span&gt; 62&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 在输出之前加入dropout以减少过拟合&lt;/span&gt;
&lt;span&gt; 63&lt;/span&gt;         keep_prob = tf.placeholder(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;float&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt;         h_fc1_drop =&lt;span&gt; tf.nn.dropout(h_fc1, keep_prob)
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt; 
&lt;span&gt; 66&lt;/span&gt;         w_fc1 = weight_variavles([1024, 10&lt;span&gt;])
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt;         b_fc1 = bias_variavles([10&lt;span&gt;])
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;         
&lt;span&gt; 69&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;进行矩阵运算得出每个样本的10个结果[NONE, 10]，输出&lt;/span&gt;
&lt;span&gt; 70&lt;/span&gt;         y_predict = tf.nn.softmax(tf.matmul(h_fc1_drop, w_fc1) +&lt;span&gt; b_fc1)
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt;     
&lt;span&gt; 72&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; x, y_true, y_predict,keep_prob
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt; 
&lt;span&gt; 74&lt;/span&gt; 
&lt;span&gt; 75&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; conv_fc():
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取数据，MNIST_data是楼主用来存放官方的数据集，如果你要这样表示的话，那MNIST_data这个文件夹应该和这个python文件在同一目录&lt;/span&gt;
&lt;span&gt; 77&lt;/span&gt;     mnist = input_data.read_data_sets(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;MNIST_data&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, one_hot=&lt;span&gt;True)
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt;     
&lt;span&gt; 79&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义模型，得出输出&lt;/span&gt;
&lt;span&gt; 80&lt;/span&gt;     x,y_true,y_predict,keep_prob =&lt;span&gt; model()
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt;     
&lt;span&gt; 82&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;进行交叉熵损失计算&lt;/span&gt;
&lt;span&gt; 83&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;3.计算交叉熵损失    &lt;/span&gt;
&lt;span&gt; 84&lt;/span&gt;     with tf.variable_scope(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;soft_cross&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;):       
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;求平均交叉熵损失,tf.reduce_mean对列表求平均值&lt;/span&gt;
&lt;span&gt; 86&lt;/span&gt;         loss = -tf.reduce_sum(y_true*&lt;span&gt;tf.log(y_predict))
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt;         
&lt;span&gt; 88&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;4.梯度下降求出最小损失,注意在深度学习中，或者网络层次比较复杂的情况下，学习率通常不能太高    &lt;/span&gt;
&lt;span&gt; 89&lt;/span&gt;     with tf.variable_scope(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;optimizer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;):
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt;         
&lt;span&gt; 91&lt;/span&gt;         train_op = tf.train.AdamOptimizer(1e-4&lt;span&gt;).minimize(loss)
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt; 
&lt;span&gt; 93&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;5.计算准确率   &lt;/span&gt;
&lt;span&gt; 94&lt;/span&gt;     with tf.variable_scope(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;acc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;):
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt;         
&lt;span&gt; 96&lt;/span&gt;         equal_list = tf.equal(tf.argmax(y_true, 1), tf.argmax(y_predict, 1&lt;span&gt;))
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;equal_list None个样本 类型为列表1为预测正确，0为预测错误[1, 0, 1, 0......]&lt;/span&gt;
&lt;span&gt; 98&lt;/span&gt;         
&lt;span&gt; 99&lt;/span&gt;         accuray =&lt;span&gt; tf.reduce_mean(tf.cast(equal_list, tf.float32))
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;         
&lt;span&gt;101&lt;/span&gt;     init_op =&lt;span&gt; tf.global_variables_initializer()
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt;     
&lt;span&gt;103&lt;/span&gt;     saver =&lt;span&gt; tf.train.Saver()
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt;     
&lt;span&gt;105&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;开启会话运行&lt;/span&gt;
&lt;span&gt;106&lt;/span&gt; &lt;span&gt;    with tf.Session() as sess:
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt; &lt;span&gt;        sess.run(init_op)
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(3000&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt;             mnist_x, mnist_y = mnist.train.next_batch(50&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; i%100 ==&lt;span&gt; 0:
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 评估模型准确度，此阶段不使用Dropout&lt;/span&gt;
&lt;span&gt;112&lt;/span&gt;                 train_accuracy = accuray.eval(feed_dict={x:mnist_x, y_true: mnist_y, keep_prob: 1.0&lt;span&gt;})
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt;                 &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;step %d, training accuracy %g&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;(i, train_accuracy))
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt;             
&lt;span&gt;115&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 训练模型，此阶段使用50%的Dropout    &lt;/span&gt;
&lt;span&gt;116&lt;/span&gt;             train_op.run(feed_dict={x:mnist_x, y_true: mnist_y, keep_prob: 0.5&lt;span&gt;}) 
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt;         # 将模型保存在你自己想保存的位置
&lt;span&gt;118&lt;/span&gt;         saver.save(sess, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D:/Dict/model/fc_model.ckpt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt;     
&lt;span&gt;120&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; None
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt; 
&lt;span&gt;122&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;     conv_fc()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;然后在你保存模型的目录下会产生4个文件&lt;/span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1179840/201903/1179840-20190313205953012-1467711829.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; .data文件是用来记录权重，偏置等参数信息；.meta是用来记录tensorflow图的结构。以下是我的电脑的结果图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1179840/201903/1179840-20190313210651559-724327101.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我只运行了6000次，按照tensorflow官方文档，运行9000次左右可以达到0.992左右的正确率&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;（3）自己手写数字，并用matlab进行预处理&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt; 首先让我们看一下预处理的结果：&lt;/span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1179840/201903/1179840-20190313210939496-1768855880.jpg&quot; alt=&quot;&quot;/&gt;-&amp;gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1179840/201903/1179840-20190313210954915-323798053.jpg&quot; alt=&quot;&quot;/&gt;-&amp;gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1179840/201903/1179840-20190313211010803-1603376826.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;具体过程也就是分为3个步骤：缩小它的大小为28*28像素，并转变为灰度图，最后进行二值化处理。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;具体matlab的代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;clear all; close all; clc;
&lt;/span&gt;% 改图片像素为28*28&lt;span&gt;

I&lt;/span&gt;=imread(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;5.jpg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;); %&lt;span&gt;你自己手写的数字的图片
J&lt;/span&gt;=imresize(I,[28,28&lt;span&gt;]);
imshow(I);
figure;
imshow(J);
imwrite(J,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;new5.jpp&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;);%生成28*28手写数字图片
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;接下来进行灰度与二值化处理&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;70&quot;&gt;
&lt;pre&gt;
&lt;span&gt;clear all;close all;clc;
&lt;/span&gt;%&lt;span&gt; Read an input image
A &lt;/span&gt;= imread(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;new5.jpg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
 
&lt;/span&gt;% Convert the image to single-&lt;span&gt;channel grayscale image
A_gray &lt;/span&gt;=&lt;span&gt; rgb2gray(A);
 
figure,imhist(A_gray),title(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hist of A_grey&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
 
&lt;/span&gt;% Convert image to double i.e., [0,1&lt;span&gt;]
A_gray &lt;/span&gt;=&lt;span&gt; im2double(A_gray);
 
&lt;/span&gt;% Generate threhold value using Otsu&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s algorithm&lt;/span&gt;
otsu_level =&lt;span&gt; graythresh(A_gray);
 
&lt;/span&gt;% Threshold image using Otsu&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s threshold and manually defined&lt;/span&gt;
%&lt;span&gt; threshold values
B_otsu_thresh &lt;/span&gt;=&lt;span&gt; im2bw(A_gray, otsu_level);
B_thresh_50 &lt;/span&gt;= im2bw(A_gray, 50/255&lt;span&gt;);
B_thresh_100 &lt;/span&gt;= im2bw(A_gray, 100/255&lt;span&gt;);
B_thresh_150 &lt;/span&gt;= im2bw(A_gray, 150/255&lt;span&gt;);
B_thresh_200 &lt;/span&gt;= im2bw(A_gray, 200/255&lt;span&gt;);
 
&lt;/span&gt;% Display original &lt;span&gt;and&lt;/span&gt; thresholded binary images side-by-&lt;span&gt;side
figure, subplot(&lt;/span&gt;2, 3, 1), imshow(A_gray), title(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Original image&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
subplot(&lt;/span&gt;2, 3, 2), imshow(B_otsu_thresh), title(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Binary image using Otsu threshold value&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
subplot(&lt;/span&gt;2, 3, 3), imshow(B_thresh_50), title(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Binary image using threshold value = 50&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
subplot(&lt;/span&gt;2, 3, 4), imshow(B_thresh_100), title(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Binary image using threshold value = 100&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
subplot(&lt;/span&gt;2, 3, 5), imshow(B_thresh_150), title(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Binary image using threshold value = 150&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
subplot(&lt;/span&gt;2, 3, 6), imshow(B_thresh_200), title(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Binary image using threshold value = 200&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
imwrite(B_otsu_thresh,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;newnew5.jpg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;);%填写你希望最终生成的数据集的名字和路径
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;到此就完成了对自己手写图片的预处理过程！&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;预处理的方法有很多，在这我在介绍一种利用OPENCV进行预处理：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;80&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; cv2

&lt;/span&gt;&lt;span&gt;global&lt;/span&gt;&lt;span&gt; img
&lt;/span&gt;&lt;span&gt;global&lt;/span&gt;&lt;span&gt; point1, point2
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; on_mouse(event, x, y, flags, param):
    &lt;/span&gt;&lt;span&gt;global&lt;/span&gt;&lt;span&gt; img, point1, point2
    img2 &lt;/span&gt;=&lt;span&gt; img.copy()
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; event == cv2.EVENT_LBUTTONDOWN:         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;左键点击&lt;/span&gt;
        point1 =&lt;span&gt; (x,y)
        cv2.circle(img2, point1, &lt;/span&gt;10, (0,255,0), 5&lt;span&gt;)
        cv2.imshow(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;image&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, img2)
    &lt;/span&gt;&lt;span&gt;elif&lt;/span&gt; event == cv2.EVENT_MOUSEMOVE &lt;span&gt;and&lt;/span&gt; (flags &amp;amp; cv2.EVENT_FLAG_LBUTTON):   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;按住左键拖曳&lt;/span&gt;
        cv2.rectangle(img2, point1, (x,y), (255,0,0), 5) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 图像，矩形顶点，相对顶点，颜色，粗细&lt;/span&gt;
        cv2.imshow(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;image&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, img2)
    &lt;/span&gt;&lt;span&gt;elif&lt;/span&gt; event == cv2.EVENT_LBUTTONUP:         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;左键释放&lt;/span&gt;
        point2 =&lt;span&gt; (x,y)
        cv2.rectangle(img2, point1, point2, (0,0,&lt;/span&gt;255), 5&lt;span&gt;) 
        cv2.imshow(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;image&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, img2)
        min_x &lt;/span&gt;=&lt;span&gt; min(point1[0], point2[0])     
        min_y &lt;/span&gt;= min(point1[1], point2[1&lt;span&gt;])
        width &lt;/span&gt;= abs(point1[0] -&lt;span&gt; point2[0])
        height &lt;/span&gt;= abs(point1[1] -point2[1&lt;span&gt;])
        cut_img &lt;/span&gt;= img[min_y:min_y+height, min_x:min_x+&lt;span&gt;width]
        resize_img &lt;/span&gt;= cv2.resize(cut_img, (28,28)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 调整图像尺寸为28*28&lt;/span&gt;
        ret, thresh_img = cv2.threshold(resize_img,127,255,cv2.THRESH_BINARY) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 二值化&lt;/span&gt;
        cv2.imshow(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;result&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, thresh_img)
        cv2.imwrite(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;new5.jpg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, thresh_img)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 预处理后图像保存位置&lt;/span&gt;

&lt;span&gt;def&lt;/span&gt;&lt;span&gt; main():
    &lt;/span&gt;&lt;span&gt;global&lt;/span&gt;&lt;span&gt; img
    img &lt;/span&gt;= cv2.imread(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;5.jpg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 手写数字图像所在位置&lt;/span&gt;
    img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 转换图像为单通道(灰度图)&lt;/span&gt;
    cv2.namedWindow(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;image&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    cv2.setMouseCallback(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;image&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, on_mouse) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 调用回调函数&lt;/span&gt;
    cv2.imshow(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;image&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, img)
    cv2.waitKey(0)

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    main()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;以上两种方法都可以，甚至还有大神利用PS自己生成数据集，感兴趣的同学可以自己去搜索一下~&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;（4）将图片输入网络进行识别&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt; 完成图像预处理后，即可将图片输入到网络中进行识别&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;86.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;143&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; PIL &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Image, ImageFilter
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; tensorflow as tf
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; matplotlib.pyplot as plt
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; 
&lt;span&gt;  5&lt;/span&gt; 
&lt;span&gt;  6&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; imageprepare():
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt;     im = Image.open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;C:/Users/tgp/Desktop/newnew5.jpg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; &lt;span&gt;    plt.imshow(im)
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt;     data =&lt;span&gt; list(im.getdata())
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt;     result = [(255-x)*1.0/255.0 &lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt;&lt;span&gt; data] 
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; result
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt; 
&lt;span&gt; 13&lt;/span&gt; 
&lt;span&gt; 14&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义初始化权重的函数&lt;/span&gt;
&lt;span&gt; 15&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; weight_variavles(shape):
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt;     w = tf.Variable(tf.truncated_normal(shape, stddev=0.1&lt;span&gt;))   
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; w
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt; 
&lt;span&gt; 19&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义一个初始化偏置的函数&lt;/span&gt;
&lt;span&gt; 20&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; bias_variavles(shape):
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt;     b = tf.Variable(tf.constant(0.0, shape=&lt;span&gt;shape))   
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; b 
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt; 
&lt;span&gt; 24&lt;/span&gt; 
&lt;span&gt; 25&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; model():
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt; &lt;span&gt;    tf.reset_default_graph()
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;1.建立数据的占位符 x [None, 784]  y_true [None, 10]&lt;/span&gt;
&lt;span&gt; 28&lt;/span&gt;     with tf.variable_scope(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;date&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;):
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt;         x = tf.placeholder(tf.float32, [None, 784&lt;span&gt;])
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt;         
&lt;span&gt; 31&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;y_true = tf.placeholder(tf.float32, [None, 10])&lt;/span&gt;
&lt;span&gt; 32&lt;/span&gt;         
&lt;span&gt; 33&lt;/span&gt;         
&lt;span&gt; 34&lt;/span&gt;     
&lt;span&gt; 35&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;2.卷积层1  卷积:5*5*1,32个filter,strides= 1-激活-池化&lt;/span&gt;
&lt;span&gt; 36&lt;/span&gt;     with tf.variable_scope(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;conv1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;):
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;随机初始化权重&lt;/span&gt;
&lt;span&gt; 38&lt;/span&gt;         w_conv1 = weight_variavles([5, 5, 1, 32&lt;span&gt;])
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt;         b_conv1 = bias_variavles([32&lt;span&gt;])
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt;         
&lt;span&gt; 41&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;对x进行形状的改变[None, 784] ----- [None,28,28,1]&lt;/span&gt;
&lt;span&gt; 42&lt;/span&gt;         x_reshape = tf.reshape(x,[-1, 28, 28, 1])  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;不能填None,不知道就填-1&lt;/span&gt;
&lt;span&gt; 43&lt;/span&gt;         
&lt;span&gt; 44&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; [None,28, 28, 1] -------- [None, 28, 28, 32]&lt;/span&gt;
&lt;span&gt; 45&lt;/span&gt;         x_relu1 = tf.nn.relu(tf.nn.conv2d(x_reshape, w_conv1, strides=[1, 1, 1, 1], padding = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SAME&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) +&lt;span&gt; b_conv1)
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt;         
&lt;span&gt; 47&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;池化 2*2，步长为2，【None, 28,28, 32]--------[None,14, 14, 32]&lt;/span&gt;
&lt;span&gt; 48&lt;/span&gt;         x_pool1 = tf.nn.max_pool(x_relu1, ksize=[1, 2, 2, 1],strides = [1,2,2,1],padding = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SAME&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt;         
&lt;span&gt; 50&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;3.卷积层2  卷积:5*5*32,64个filter,strides= 1-激活-池化&lt;/span&gt;
&lt;span&gt; 51&lt;/span&gt;     with tf.variable_scope(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;conv2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;):
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;随机初始化权重和偏置&lt;/span&gt;
&lt;span&gt; 53&lt;/span&gt;         w_conv2 = weight_variavles([5, 5, 32, 64&lt;span&gt;])
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt;         b_conv2 = bias_variavles([64&lt;span&gt;])
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt;         
&lt;span&gt; 56&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;卷积、激活、池化&lt;/span&gt;
&lt;span&gt; 57&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;[None,14, 14, 32]----------【NOne, 14, 14, 64]&lt;/span&gt;
&lt;span&gt; 58&lt;/span&gt;         x_relu2 = tf.nn.relu(tf.nn.conv2d(x_pool1, w_conv2,strides=[1, 1, 1, 1], padding = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SAME&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) +&lt;span&gt; b_conv2)
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt;         
&lt;span&gt; 60&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;池化 2*2，步长为2 【None, 14,14，64]--------[None,7, 7, 64]&lt;/span&gt;
&lt;span&gt; 61&lt;/span&gt;         x_pool2 = tf.nn.max_pool(x_relu2, ksize=[1, 2, 2, 1],strides = [1,2,2,1],padding = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SAME&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt;     
&lt;span&gt; 63&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;4.全连接层 [None,7, 7, 64] --------- [None, 7*7*64] * [7*7*64, 10]+[10] = [none, 10]&lt;/span&gt;
&lt;span&gt; 64&lt;/span&gt;     with tf.variable_scope(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;):
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;随机初始化权重和偏置:&lt;/span&gt;
&lt;span&gt; 66&lt;/span&gt;         w_fc = weight_variavles([7 * 7 * 64, 1024&lt;span&gt;])
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt;         b_fc = bias_variavles([1024&lt;span&gt;])
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;         
&lt;span&gt; 69&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;修改形状 [none, 7, 7, 64] ----------[None, 7*7*64]&lt;/span&gt;
&lt;span&gt; 70&lt;/span&gt;         x_fc_reshape = tf.reshape(x_pool2,[-1,7 * 7 * 64&lt;span&gt;])
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt;         h_fc1 = tf.nn.relu(tf.matmul(x_fc_reshape, w_fc) +&lt;span&gt; b_fc)
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt; 
&lt;span&gt; 73&lt;/span&gt;         keep_prob = tf.placeholder(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;float&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt;         h_fc1_drop =&lt;span&gt; tf.nn.dropout(h_fc1, keep_prob)
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt; 
&lt;span&gt; 76&lt;/span&gt;         w_fc1 = weight_variavles([1024, 10&lt;span&gt;])
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt;         b_fc1 = bias_variavles([10&lt;span&gt;])
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt;         
&lt;span&gt; 79&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;进行矩阵运算得出每个样本的10个结果[NONE, 10]&lt;/span&gt;
&lt;span&gt; 80&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;y_predict = tf.matmul(h_fc1_drop, w_fc1) + b_fc1&lt;/span&gt;
&lt;span&gt; 81&lt;/span&gt;         y_predict = tf.nn.softmax(tf.matmul(h_fc1_drop, w_fc1) +&lt;span&gt; b_fc1)
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; x, y_predict,keep_prob
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt; 
&lt;span&gt; 84&lt;/span&gt; 
&lt;span&gt; 85&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; conv_fc():
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取数据&lt;/span&gt;
&lt;span&gt; 87&lt;/span&gt;     result =&lt;span&gt; imageprepare()
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt;     
&lt;span&gt; 89&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义模型，得出输出&lt;/span&gt;
&lt;span&gt; 90&lt;/span&gt;     x,y_predict,keep_prob =&lt;span&gt; model()
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt;     
&lt;span&gt; 92&lt;/span&gt;     init_op =&lt;span&gt; tf.global_variables_initializer()
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt;     
&lt;span&gt; 94&lt;/span&gt;     saver =&lt;span&gt; tf.train.Saver()
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt;     
&lt;span&gt; 96&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;开启会话运行&lt;/span&gt;
&lt;span&gt; 97&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;tf.reset_default_graph()&lt;/span&gt;
&lt;span&gt; 98&lt;/span&gt; &lt;span&gt;    with tf.Session() as sess:
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt; &lt;span&gt;        sess.run(init_op)
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(result)
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt;         saver.restore(sess, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D:/Dict/model/fc_model.ckpt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt;         prediction = tf.argmax(y_predict,1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt;         predint = prediction.eval(feed_dict={x: [result],keep_prob: 1.0}, session=&lt;span&gt;sess)
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(predint)
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;recognize result: %d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt;predint[0])
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt; 
&lt;span&gt;107&lt;/span&gt;     
&lt;span&gt;108&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; None
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt; 
&lt;span&gt;110&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;     conv_fc()
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;运行结果如下：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1179840/201903/1179840-20190313213926648-1692106944.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt; （5）实践过程遇到的坑与总结&lt;/span&gt;&lt;/h2&gt;

&lt;hr/&gt;&lt;p&gt;以上就是本次实践的全部过程，欢迎大家交流讨论。&lt;/p&gt;

</description>
<pubDate>Thu, 14 Mar 2019 06:36:00 +0000</pubDate>
<dc:creator>控球强迫症</dc:creator>
<og:description>最近一直在学习李宏毅老师的机器学习视频教程，学到和神经网络那一块知识的时候，我觉得单纯的学习理论知识过于枯燥，就想着自己动手实现一些简单的Demo,毕竟实践是检验真理的唯一标准！！！但是网上很多的与t</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/XDU-Lakers/p/10526748.html</dc:identifier>
</item>
<item>
<title>在Bootstrap开发框架中使用Grid++报表 - 伍华聪</title>
<link>http://www.cnblogs.com/wuhuacong/p/10529587.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wuhuacong/p/10529587.html</guid>
<description>&lt;p&gt;之前在随笔《&lt;a id=&quot;homepage1_HomePageDays_ctl00_DayList_TitleUrl_0&quot; href=&quot;https://www.cnblogs.com/wuhuacong/p/10523734.html&quot;&gt;在Winform开发中使用Grid++报表&lt;/a&gt;》介绍了在Winform环境中使用Grid++报表控件，本篇随笔介绍在Bootstrap开发框架中使用Grid++报表，也就是Web环境中使用Grid++报表，对于我上篇提到的二维码条形码的资产信息表，我系统通过Web方式进行呈现，或者展示其报表的PDF也可以，本篇随笔一步步介绍如何使用Web报表的展示出来。&lt;/p&gt;
&lt;h3&gt;1、Grid++报表在Web端的处理&lt;/h3&gt;
&lt;p&gt;Grid++在Web端，提供了插件的方式展示，不过由于插件是采用COM方式处理的，这种模式限制了它支持浏览器有限。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/8867/201903/8867-20190314123348497-384201572.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过上面表格，也就是说基本上我们应用比较广泛的Chrome和FireFox最新的都不支持了，由于我项目需求，我希望客户能够在不同的浏览器上实现报表的展示，那这种插件方式显示的方式就不太适合了。&lt;/p&gt;
&lt;p&gt;不过Grid++报表还是提供了另外一种方式，也就是HTML5的方式展示，HTML5报表运行在所有支持HTML5的浏览器(目前较新版本的各种浏览器都支持HTML5)。&lt;/p&gt;
&lt;p&gt;例如在Chrome浏览器里面展示HTML报表，效果如下所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/8867/201903/8867-20190314134320654-1962549815.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这种方式还是挺棒的，不过我在做二维码打印的时候，发现和我设计的报表不太一样，我设计的报表样式效果如下所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/8867/201903/8867-20190313155644049-192608337.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而HTML报表给我的效果是如下所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/8867/201903/8867-20190314134533517-2022779371.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也就是没能按我所需要的排列来展示，因此我希望在服务端生成PDF格式展示，因为PDF的效果还是最好的，不会变形，而且我可以通过PDFJS的插件实现在线预览效果，需要的时候，下载PDF打印内容即可。&lt;/p&gt;

&lt;h3&gt;2、Grid++报表在Web端的实现过程&lt;/h3&gt;
&lt;p&gt;前面介绍了我需要的报表效果和具体选型过程，在得出最终结果前，我们来一步步看看具体的实现效果。&lt;/p&gt;
&lt;p&gt;对于一些简单的二维表，如果使用直接报表展示的方式还是很棒的，下面我们先来介绍通过HTML报表直接呈现的方式实现过程。&lt;/p&gt;
&lt;p&gt;由于我这个Bootstrap开发框架是采用MVC开发的，我想把报表的展示放在Report.cshtml视图里面，那么我需要创建一个视图Action，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ActionResult Report()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; View(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Report&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样，我们再创建一个Report.cshtml视图页面，如下所示。首先引入我们需要的JS，一般来说，引入grhtml5-6.6-min.js文件就可以了，由于我们需要使用Jquery的一些处理方式，因此JQueryJS也需要引入的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @*此处添加一些Jquery相关的脚本，方便开发时刻自定义脚本的智能提示*@
    &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;~/Content/metronic/assets/global/plugins/jquery.min.js&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;~/Content/metronic/assets/global/plugins/jquery-migrate.min.js&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;~/Content/metronic/assets/global/plugins/jquery-ui/jquery-ui.min.js&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;Grid++报表需要的JS文件&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;~/Content/JQueryTools/GridReport/grhtml5-6.6-min.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样我们调用报表对象进行数据的处理即可，如下面我们测试一个案例的报表内容处理。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;language&lt;/span&gt;&lt;span&gt;=&quot;javascript&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;function&lt;/span&gt;&lt;span&gt; loadReport() {

            rubylong.grhtml5.barcodeURL &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/Barcode.ashx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建报表显示器，参数指定其在网页中的占位标签的ID，报表模板URL与报表数据URL不指定，而是在后面的AJAX操作中提供相关数据&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt;&lt;span&gt; reportViewer &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; window.rubylong.grhtml5.insertReportViewer(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;report_holder&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            reportViewer.reportPrepared &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;; &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定报表生成需要加载报表模板&lt;/span&gt;
&lt;span&gt;            reportViewer.dataPrepared &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定报表生成需要加载报表数据&lt;/span&gt;

            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;报表在模板与数据都载入后会自动生成&lt;/span&gt;

            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;测试报表&lt;/span&gt;
&lt;span&gt;            $.ajax({
                type: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GET&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                url: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/Report/1a.SimpleList.grf&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                data: &lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;,
                success: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (msg) {
                    reportViewer.loadReport(msg);
                }
            });
            $.ajax({
                type: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GET&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;url: &quot;/Report/xmlCustomer.txt&quot;, //xml格式&lt;/span&gt;
&lt;span&gt;                url: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/Report/jsonCustomer.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;json格式&lt;/span&gt;
&lt;span&gt;                data: &lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;,
                success: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (msg) {
                    reportViewer.loadData(msg);
                }
            });

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;页面初始化&lt;/span&gt;
&lt;span&gt;        $(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
            loadReport();
        });
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;报表内容呈现在HTML元素里面，如下代码所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;report_holder&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过上面我们了解到它的报表内容的赋值处理，我们首先需要确定报表模板文件，以及动态生成报表呈现的数据，代替 jsonCustomer.txt 文件内容。&lt;/p&gt;
&lt;p&gt;我们来看看这个文件的格式如下所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/8867/201903/8867-20190314140047339-84234257.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也就是我们如果需要动态生成数据，则构建这一个JSON格式输出即可。测试报表界面效果如下所示，二维表格展示效果还是很好的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/8867/201903/8867-20190314140634074-1600700864.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;实际报表处理的时候，由于我需要动态展示数据，因此在JS接收一个参数，并根据参数动态构建数据即可。&lt;/p&gt;
&lt;p&gt;如下是我实际的项目报表数据展示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;function&lt;/span&gt;&lt;span&gt; loadReport(ids) {

            rubylong.grhtml5.barcodeURL &lt;/span&gt;= &quot;/Barcode.ashx&quot;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建报表显示器，参数指定其在网页中的占位标签的ID，报表模板URL与报表数据URL不指定，而是在后面的AJAX操作中提供相关数据&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; reportViewer = window.rubylong.grhtml5.insertReportViewer(&quot;report_holder&quot;&lt;span&gt;);
            reportViewer.reportPrepared &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定报表生成需要加载报表模板&lt;/span&gt;
            reportViewer.dataPrepared = &lt;span&gt;false&lt;/span&gt;;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定报表生成需要加载报表数据&lt;/span&gt;

            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;报表在模板与数据都载入后会自动生成&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;正式报表&lt;/span&gt;
&lt;span&gt;            $.ajax({
                type: &lt;/span&gt;&quot;GET&quot;&lt;span&gt;,
                url: &lt;/span&gt;&quot;/Report/barcode.grf&quot;&lt;span&gt;,
                data: &lt;/span&gt;&quot;&quot;&lt;span&gt;,
                success: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (msg) {
                    reportViewer.loadReport(msg);
                }
            });
            $.ajax({
                type: &lt;/span&gt;&quot;GET&quot;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;url: &quot;/Report/jsonbarcode.txt&quot;, //json文件格式&lt;/span&gt;
                url: &quot;/Asset/GetRepotData?ids=&quot; + ids,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;动态json格式&lt;/span&gt;
                data: &quot;&quot;&lt;span&gt;,
                success: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (msg) {
                    reportViewer.loadData(msg);
                }
            });
        };&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我通过 Asset / GetRepotData 的方法实现数据的动态生成。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取Grid++的JSON格式报表数据
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; ActionResult GetRepotData(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; ids)
        {
            ActionResult result &lt;/span&gt;= Content(&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(ids))
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; list = BLLFactory&amp;lt;Asset&amp;gt;&lt;span&gt;.Instance.FindByIDs(ids);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;构建一个合法格式的对象，进行序列号&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; table = &lt;span&gt;new&lt;/span&gt;&lt;span&gt;
                {
                    Table &lt;/span&gt;=&lt;span&gt; list
                };
                result &lt;/span&gt;=&lt;span&gt; ToJsonContent(table);
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其实就是构建一个顶级节点的Table对象，然后序列化为JSON即可。&lt;/p&gt;
&lt;p&gt;这样我们就可以输出所需要的报表了，如下所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/8867/201903/8867-20190314134533517-2022779371.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 不过这样的报表，没有按照我需要的两列排列（估计也是报表的一个Bug吧），没有达到我的期望，因此我希望通过展示PDF的方式，实现严格格式的输出报表。&lt;/p&gt;
&lt;h3&gt;3、Grid++报表在Web端的PDF处理&lt;/h3&gt;
&lt;p&gt;报表控件，后台通过PDF的生成方式，我在之前那篇随笔《&lt;a id=&quot;homepage1_HomePageDays_ctl00_DayList_TitleUrl_0&quot; href=&quot;https://www.cnblogs.com/wuhuacong/p/10523734.html&quot;&gt;在Winform开发中使用Grid++报表&lt;/a&gt;》介绍了如果在Winform下直接导出PDF方式，具体如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; btnExportPdf_Click(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, EventArgs e)
        {
            List&lt;/span&gt;&amp;lt;ProductInfo&amp;gt; list = BLLFactory&amp;lt;Product&amp;gt;&lt;span&gt;.Instance.GetAll();

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从对应文件中载入报表模板数据&lt;/span&gt;
            &lt;span&gt;string&lt;/span&gt; reportPath = Path.Combine(Application.StartupPath, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Reports\\testList.grf&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            GridExportHelper helper &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; GridExportHelper(reportPath);

            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; fileName = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;d:\\my.pdf&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; succeeded =&lt;span&gt; helper.ExportPdf(list, fileName);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(succeeded)
            {
                Process.Start(fileName);
            }
        }&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而其中辅助类的ExportPdf方法就是直接利用报表客户端控件对象导出PDF的，如下代码所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 导出PDF，并返回路径
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;T&quot;&amp;gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;list&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; ExportPdf&amp;lt;T&amp;gt;(List&amp;lt;T&amp;gt; list, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; filePath)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从对应文件中载入报表模板数据&lt;/span&gt;
            Report.LoadFromFile(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.ReportPath);
            Report.FetchRecord &lt;/span&gt;+= () =&amp;gt;&lt;span&gt;
            {
                FillRecordToReport&lt;/span&gt;&amp;lt;T&amp;gt;&lt;span&gt;(Report, list);
            };
            Report.ExportBegin &lt;/span&gt;+= (IGRExportOption option) =&amp;gt;&lt;span&gt;
            {
                option.AbortOpenFile &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;导出后不用关联程序打开导出文件，如导出Excel文件之后不用Excel打开&lt;/span&gt;
                option.FileName =&lt;span&gt; filePath;
                &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (option.ExportType)
                {
                    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; GRExportType.gretPDF:
                        option.AsE2PDFOption.Author &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;My Author&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                        option.AsE2PDFOption.Subject &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;My Subject&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                }
            };

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; succeeded = Report.ExportDirect(GRExportType.gretPDF, filePath, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; succeeded;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;报表导出的效果和报表预览效果一致&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/8867/201903/8867-20190313173932093-222356848.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不过我使用前面报表客户端的对象处理报表导出，在测试后台生成PDF的时候，提示内存损坏，应该就是COM处理的问题，不支持这样的方式，咨询作者后说需要使用 WEB报表服务器 方式来生成PDF。&lt;/p&gt;
&lt;p&gt;改变一下处理过程，实际使用的是GridppReportServer对象来处理，实际代码如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 导出PDF
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;T&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;列表对象类型&lt;/span&gt;&lt;span&gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;list&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;列表对象&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;filePath&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;存储路径&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;context&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; ExportPdf&amp;lt;T&amp;gt;(List&amp;lt;T&amp;gt; list, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; filePath, HttpContextBase context)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从对应文件中载入报表模板数据&lt;/span&gt;
            Report.LoadFromFile(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.ReportPath);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;构建一个合法格式的对象，进行序列化&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; table = &lt;span&gt;new&lt;/span&gt;&lt;span&gt;
            {
                Table &lt;/span&gt;=&lt;span&gt; list
            };
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; json =&lt;span&gt; JsonConvert.SerializeObject(table, Formatting.Indented);
            Report.LoadDataFromXML(json);

            IGRExportOption ExportOption &lt;/span&gt;=&lt;span&gt; Report.PrepareExport(GRExportType.gretPDF);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; exportPdf =&lt;span&gt; Report.ExportToBinaryObject();
            Report.UnprepareExport();

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; succeeded =&lt;span&gt; exportPdf.SaveToFile(filePath);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; succeeded;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;有了这个辅助方法，我们就可以封装一下处理获得数据，并导出PDF文件的操作了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 根据选中的ID记录，生成对应的PDF报表，返回路径
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;ids&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;选中的ID记录，逗号分开&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; ActionResult ExportPdf(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; ids)
        {
            ActionResult result &lt;/span&gt;= Content(&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(ids))
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;利用接口获取列表数据&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; list = BLLFactory&amp;lt;Asset&amp;gt;&lt;span&gt;.Instance.FindByIDs(ids);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;报表文件路径&lt;/span&gt;
                &lt;span&gt;string&lt;/span&gt; reportPath =&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/Report/barcode.grf&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;转换为物理路径&lt;/span&gt;
                reportPath =&lt;span&gt; Server.MapPath(reportPath);

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;导出PDF的文件路径&lt;/span&gt;
                &lt;span&gt;string&lt;/span&gt; exportPdfPath = &lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/GenerateFiles/{0}/AssetReport.pdf&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, CurrentUser.Name);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;转换为物理路径&lt;/span&gt;
                &lt;span&gt;string&lt;/span&gt; realPath =&lt;span&gt; Server.MapPath(exportPdfPath);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;确保目录生成&lt;/span&gt;
                &lt;span&gt;string&lt;/span&gt; parentPath =&lt;span&gt; Directory.GetParent(realPath).FullName;
                DirectoryUtil.AssertDirExist(parentPath);

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;生成PDF报表文档到具体文件&lt;/span&gt;
                GridExportHelper helper = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; GridExportHelper(reportPath);
                &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; success =&lt;span&gt; helper.ExportPdf(list, realPath, HttpContext);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(success)
                {
                    result &lt;/span&gt;= Content(exportPdfPath);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回Web相对路径&lt;/span&gt;
&lt;span&gt;                }
                helper.Dispose();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;销毁对象&lt;/span&gt;
&lt;span&gt;            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这些是后端的代码，要想在前端里面处理并预览PDF文件，需要加入前端的HTML代码&lt;/p&gt;
&lt;p&gt;如下我们加入两个JS函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;查看明细信息&lt;/span&gt;
        &lt;span&gt;function&lt;/span&gt;&lt;span&gt; ViewPDF(ids) {
            $.ajax({
                type: &lt;/span&gt;&quot;GET&quot;&lt;span&gt;,
                url: &lt;/span&gt;&quot;/Asset/ExportPdf?ids=&quot; +&lt;span&gt; ids,
                data: &lt;/span&gt;&quot;&quot;&lt;span&gt;,
                success: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (filePath) {
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; baseUrl = &quot;/Content/JQueryTools/pdfjs/web/viewer.html&quot;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; url = baseUrl + &quot;?file=&quot; + filePath;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实际地址&lt;/span&gt;
&lt;span&gt;                    window.open(url);
                }
            });
        };

        &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; AssetPrint() {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; rows = $table.bootstrapTable('getSelections'&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (rows.length == 0&lt;span&gt;) {
                showTips(&lt;/span&gt;&quot;请选择你要打印编码的记录&quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用Grid++报表，构建数据显示&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; ids = ''&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; rows.length; i++&lt;span&gt;) {
                ids &lt;/span&gt;+= rows[i].ID + ','&lt;span&gt;;
            }
            ids &lt;/span&gt;= ids.substring(0, ids.length - 1&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;loadReport(ids);&lt;/span&gt;
&lt;span&gt;            ViewPDF(ids);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里利用了PDFJS的插件来在线展示生成的PDF，需要了解具体可以参考我之前的随笔《&lt;a id=&quot;cb_post_title_url&quot; href=&quot;https://www.cnblogs.com/wuhuacong/p/9566764.html&quot;&gt;实现在线预览PDF的几种解决方案&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;然后在HTML页面里面加入对应的处理按钮即可。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;button&quot;&lt;/span&gt;&lt;span&gt; onclick&lt;/span&gt;&lt;span&gt;=&quot;AssetPrint()&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;btn btn-circle btn-sm red&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;i &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;fa fa-plus&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;i&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    资产编码打印
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如下页面的界面效果所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/8867/201903/8867-20190314142632973-1002214268.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;单击【资产编码打印】，首先在后台动态生成一个PDF文件，成功后前端弹出一个新的预览PDF界面，预览我们的二维码报表，效果比HTML5界面效果标准，和我们原来的设计报表初衷一直，两列排列。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/8867/201903/8867-20190314141817835-581222699.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 以上就是我在实际项目中，在Bootstrap开发框架中使用Grid++报表的几个处理过程，希望对你使用有帮助，报表确实具有很好的应用场景，使用起来还是很方便的。&lt;/p&gt;
</description>
<pubDate>Thu, 14 Mar 2019 06:30:00 +0000</pubDate>
<dc:creator>伍华聪</dc:creator>
<og:description>之前在随笔《在Winform开发中使用Grid++报表》介绍了在Winform环境中使用Grid++报表控件，本篇随笔介绍在Boostrap开发框架中使用Grid++报表，也就是Web环境中使用Gri</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wuhuacong/p/10529587.html</dc:identifier>
</item>
<item>
<title>GraphQL ---02 GraphQL和C#结合的实战项目 - 畅想技术</title>
<link>http://www.cnblogs.com/kingkangstudy/p/10471751.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kingkangstudy/p/10471751.html</guid>
<description>&lt;p&gt;本文章是介绍和记录如何创建GraphQL项目，以及如何使用GraphQL进行数据的相关操作。项目参照&lt;a href=&quot;https://graphql-dotnet.github.io/&quot; target=&quot;_blank&quot;&gt;GraphQL .Net 的官方文档&lt;/a&gt;进行实践&lt;/p&gt;
&lt;p&gt;一、项目结构:&lt;/p&gt;
&lt;p&gt;　　为了更好的和原有的项目结合在一起，尽可能减少对原项目的修改。我对项目结构做了如下分层。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1041005/201903/1041005-20190304164137960-1556989440.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;二、项目结构分层说明&lt;/p&gt;
&lt;p&gt;　　Contracts层: 项目的接口层，重点存放项目的一些接口。和原项目的分层结构的Contracts一致&lt;/p&gt;
&lt;p&gt;　　Entities层: 实体模型层，存放实体模型。与原有项目的分层结构Entites层一致&lt;/p&gt;
&lt;p&gt;　　GraphQLDemo: 是使用Console控制台应用程序对GraphQL的调用实例&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;GraphQLs: 使用GraphQL 的模型定义和查询、变更等操作的定义&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　Services: 提供服务的具体实现层，和原有项目分层中的Services 层一致&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;Tests: 使用Unit Test 测试调用GraphQL&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在这里重点关注 标红的部分的介绍&lt;/p&gt;
&lt;p&gt;三、GraphQLs项目介绍：&lt;/p&gt;
&lt;p&gt;　　GraphQLs重点是存储项目的GraphQL操作相关的内容&lt;/p&gt;
&lt;p&gt;　　1.在项目解决方案中，新建程序集，命名为GraphQLs&lt;/p&gt;
&lt;p&gt;　　2. 安装Graphql&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
NuGet 搜索 GraphQL
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　3.创建GraphQL 的相关概念&lt;/p&gt;
&lt;p&gt;　　GraphQL有两种方式创建Schema,&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;一种是使用Schema First，也就是使用&lt;a href=&quot;https://graphql.org/learn/schema/#type-language&quot; target=&quot;_blank&quot;&gt;GraphQL Schema Language&lt;/a&gt;创建Schema. 可以对比EntityFramework的DB First&lt;/li&gt;
&lt;li&gt;一种是使用Graph Type定义Schema，可以对比EntityFramework 的Code First&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　在这里适用Code First定义数据模型，可以与原有的数据服务应用一起使用。可分为以下步骤：&lt;/p&gt;
&lt;p&gt;　　1)&lt;span&gt;定义数据模型:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　假设原有的数据模型Book的结构是这样的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; User
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Id { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Age { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Gender { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　那么定义对应的GraphQL的数据模型可以是这样的:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; UserType:ObjectGraphType&amp;lt;User&amp;gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 继承自ObjectGraphType，并传递范型User&lt;/span&gt;
&lt;span&gt;    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; UserType()&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在构造函数中，对属性作影射&lt;/span&gt;
&lt;span&gt;        {
            Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;User&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

            Field(x &lt;/span&gt;=&amp;gt;&lt;span&gt; x.Id);
            Field(x &lt;/span&gt;=&amp;gt;&lt;span&gt; x.Name);
            Field(x &lt;/span&gt;=&amp;gt;&lt;span&gt; x.Age);
            Field(x &lt;/span&gt;=&amp;gt;&lt;span&gt; x.Gender);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2)&lt;span&gt;定义操作模型&lt;/span&gt;: &lt;/p&gt;
&lt;p&gt;　　GraphQL的操作分为： Query(Select), Mutation(Create,Update,Delete),Subscription(订阅)&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;定义Query操作&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Query : ObjectGraphType&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义Query&lt;/span&gt;
&lt;span&gt;    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; IWrapper wrapper = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Wrapper();
        IEnumerable&lt;/span&gt;&amp;lt;User&amp;gt; users = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Query()
        {
            Field&lt;/span&gt;&amp;lt;ListGraphType&amp;lt;UserType&amp;gt;&amp;gt;(&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在构造函数中定义查询操作&lt;/span&gt;
                name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;users&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, //注意这个名字，后边查询的时候需要对应
                arguments: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; QueryArguments &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义查询参数&lt;/span&gt;
&lt;span&gt;                {
                    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; QueryArgument&amp;lt;StringGraphType&amp;gt;&lt;span&gt;
                    {
                        Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                        Description &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;The name for the user&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                    },
                    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; QueryArgument&amp;lt;IntGraphType&amp;gt;&lt;span&gt;
                    {
                        Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                        Description &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;The age for the user&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                    },
                    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; QueryArgument&amp;lt;StringGraphType&amp;gt;&lt;span&gt;
                    {
                        Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gender&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                        Description &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;The gender for user&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                    }
                },
                resolve: context &lt;/span&gt;=&amp;gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义查询操作的执行&lt;/span&gt;
&lt;span&gt;                {
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; usercontext = context.UserContext;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取上下文，可在此作用户验证操作&lt;/span&gt;
                    users = wrapper.User.Find(u =&amp;gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; name = context.GetArgument&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    users &lt;/span&gt;= users.Where(u =&amp;gt; name == &lt;span&gt;null&lt;/span&gt; || u.Name ==&lt;span&gt; name);
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; age = context.GetArgument&amp;lt;&lt;span&gt;int&lt;/span&gt;?&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    users &lt;/span&gt;= users.Where(u =&amp;gt; age == &lt;span&gt;null&lt;/span&gt; || u.Age ==&lt;span&gt; age);
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; gender = context.GetArgument&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gender&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    users &lt;/span&gt;= users.Where(u =&amp;gt; gender == &lt;span&gt;null&lt;/span&gt; || u.Gender ==&lt;span&gt; gender);
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; users;
                });&lt;br/&gt;　　　　}&lt;br/&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;定义Mutation操作&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Mutation:ObjectGraphType
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; IWrapper wrapper = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Wrapper();
        IEnumerable&lt;/span&gt;&amp;lt;User&amp;gt; users = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Mutation()
        {
            Field&lt;/span&gt;&amp;lt;UserType&amp;gt;&lt;span&gt;(
                name: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;createUser&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                arguments: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; QueryArguments(
                    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; QueryArgument&amp;lt;NonNullGraphType&amp;lt;UserInputType&amp;gt;&amp;gt;&lt;span&gt;
                    {
                        Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                    }
                ),
                resolve: context &lt;/span&gt;=&amp;gt;&lt;span&gt;
                {
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; user = context.GetArgument&amp;lt;User&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; wrapper.User.Add(user);
                }
            );
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　3. &lt;span&gt;定义GraphSchema&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　定义GraphSchema就是定义Schema的Query、Mutation、Subscription操作&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; GraphSchema:Schema
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; GraphSchema()
        {
            Query &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Query();
            Mutation &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Mutation();&lt;/span&gt;&lt;span&gt;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　4. 附.&lt;/p&gt;
&lt;p&gt;　　为了检验查询、修改操作，这里定义一个GraphQLQuery来定义操作，并定义一个查询操作类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; GraphQLQuery
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; OperationName { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; NamedQuery { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Query { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; UserContext { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; JObject Variables { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ActionExecute
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; IDocumentExecuter executer;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; IDocumentWriter writer;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; ISchema schema;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ActionExecute()
        {
            executer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DocumentExecuter();
            writer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DocumentWriter();
            schema &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; GraphSchema();
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;ExecutionResult&amp;gt;&lt;span&gt; ExecuteAction(GraphQLQuery query)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result = &lt;span&gt;await&lt;/span&gt; executer.ExecuteAsync(_ =&amp;gt;&lt;span&gt;
            {
                _.Schema &lt;/span&gt;=&lt;span&gt; schema;
                _.Query &lt;/span&gt;=&lt;span&gt; query.Query;
                _.Inputs &lt;/span&gt;= query.Variables.ToInputs();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 查询变量的输入&lt;/span&gt;
                _.OperationName = query.OperationName;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 操作名称&lt;/span&gt;
                _.UserContext = query.UserContext;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加用户上下文对象&lt;/span&gt;
                _.ValidationRules = DocumentValidator.CoreRules(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加自定义查询验证 逻辑 &lt;/span&gt;
                _.ExposeExceptions = &lt;span&gt;true&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 是否追踪错误&lt;/span&gt;
                _.FieldMiddleware.Use&amp;lt;ErrorHandlerMiddleware&amp;gt;(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用中间件&lt;/span&gt;
                _.EnableMetrics = &lt;span&gt;true&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 是否使用查询度量&lt;/span&gt;
&lt;span&gt;
                _.ComplexityConfiguration &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ComplexityConfiguration &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 防止恶意查询&lt;/span&gt;
&lt;span&gt;                {
                    MaxComplexity &lt;/span&gt;= &lt;span&gt;12&lt;/span&gt;&lt;span&gt;,
                    MaxDepth &lt;/span&gt;= &lt;span&gt;15&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 允许查询总最大嵌套数&lt;/span&gt;
&lt;span&gt;                };
            });
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; Execute(GraphQLQuery query)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result = &lt;span&gt;await&lt;/span&gt; ExecuteAction(query).ConfigureAwait(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; json = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; writer.WriteToStringAsync(result);

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; json;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;四、 测试和检验&lt;/p&gt;
&lt;p&gt;　　一切准备就绪,下边对创建的GraphQL进行测试&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1041005/201903/1041005-20190314112253989-1215127456.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;查询测试:&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; QueryTest
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; ActionExecute execute = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ActionExecute();
        [Fact]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; TestMethod1()
        {
            Assert.True(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt; == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
        }
        [Theory]
        [InlineData(&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Male&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        [InlineData(&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;FeMale&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; QueryUsers(&lt;span&gt;int&lt;/span&gt; age, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; gender)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; queryStr = &lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;{users(age:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + age + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,gender:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\&quot;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + gender + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\&quot;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;){id name gender age}}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result = &lt;span&gt;await&lt;/span&gt; execute.ExecuteAction(&lt;span&gt;new&lt;/span&gt; GraphQLQuery { Query = queryStr,UserContext= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Add Role&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; });
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; data =&lt;span&gt; result.Data;
            Assert.Null(result.Errors&lt;/span&gt;?&lt;span&gt;.Count);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　为了检验GraphQL的查询优越性，你可以修改一下queryStr=@&quot;{users{id name gender age}}&quot;; 或queryStr=@&quot;{users{gender age}}&quot;;queryStr=@&quot;{users{ name age}}&quot;;注意这里的@和{}只是C# 对字符串操作的一种方式。&lt;/p&gt;
&lt;p&gt;　　发现了什么？&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;如果我们在前端(Web、微信小程序、手机APP)，在web端，作为后台管理系统，我可能需要获取用户的所有信息，那么我可能需要使用queryStr=@&quot;{users{id name gender age}}&quot;。在微信小程序端，我只要根据用户的id查询用户名字就可以了，那么我只用变动查询语句：queryStr=@&quot;{users(id){ name}}&quot;;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　意味着什么？&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;意味着我们只需要提供一个API接口，该端口接受传递的查询字符串就可以了。所有的实体都可以只用这一个接口了。想查询什么，由前端决定了，再也不需要追着后端接口开发工程师要数据了。我想这样以来，前端和后端只需要一个接口沟通，会比REST API来的更方便了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2.变更测试:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MutationTest
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; ActionExecute execute = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ActionExecute();

        [Theory]
        [InlineData(&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Test1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        [InlineData(&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Test2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; CreateUser(&lt;span&gt;int&lt;/span&gt; age, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; name)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; queryStr = &lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;{query: mutation ($user: UserInput!){createUser(user:$user){id name age}},variables:{user:{name: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + name + &lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;,age:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + age + &lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;}}}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; query = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; GraphQLQuery
            {
                Query &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mutation ($user: UserInput!){createUser(user:$user){id name age}}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                Variables &lt;/span&gt;= JObject.Parse(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{user:{\&quot;name\&quot;: \&quot;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + name + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\&quot;,\&quot;age\&quot;:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + age + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            };
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; execute.ExecuteAction(query);
            Assert.Null(result.Errors.Count);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　发现了什么？&lt;/p&gt;
&lt;p&gt;　　同样的。我们只需要传递查询的参数，传递对应的参数Variables 就能完成修改动作。同时，该变更和查询的操作字符串语句很像，只是多了一个mutation。&lt;/p&gt;
&lt;p&gt;五、后续&lt;/p&gt;
&lt;p&gt;　　这篇文章只是介绍了使用控制台和UnitTest测试使用了GraphQL，后续会更新在Asp.Net Core MVC 中使用GraphQL，也可以学习杨旭的文章。很好的博主&lt;a href=&quot;https://www.cnblogs.com/cgzl/p/9691323.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/cgzl/p/9691323.html&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 14 Mar 2019 06:23:00 +0000</pubDate>
<dc:creator>畅想技术</dc:creator>
<og:description>本文章是介绍和记录如何创建GraphQL项目，以及如何使用GraphQL进行数据的相关操作。项目参照GraphQL .Net 的官方文档进行实践 一、项目结构: 为了更好的和原有的项目结合在一起，尽可</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kingkangstudy/p/10471751.html</dc:identifier>
</item>
<item>
<title>独立使用Asp.net Core 的razor模板 (一):Razor引擎的一些细节 - 启天</title>
<link>http://www.cnblogs.com/kugar/p/10527782.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kugar/p/10527782.html</guid>
<description>&lt;p&gt;&lt;span&gt;    由于最近需要写一些界面稍微好看点的Winform程序,如果用原生控件,,想要达到好看的程度,需要花费比较大的功夫,因为之前使用过CefSharp,因此发觉如果是使用CEF+Html的方式,界面可以相对容易做的精致一点(其实就是设计完之后,找个前端人员切切图),但是,使用CEF+Html有个弊端就是,正常的软件,Header跟Footer大体是通用的,包括一些通用的js/css的引用以及菜单栏等等,,如果直接用html,有个问题就在于,,每个界面都要复制一遍,如果万一发生修改,每个页面又要来一次,或许都这里有朋友会说:&quot;那可以使用vue或者ng的模板啊&quot;,,实际情况是,,会用的人不多,但是会用jq的人大把.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     由于服务器端有Razor模板,可以很方便的使用Layout以及各种自己封装的View,但实际情况下,如果单独把Razor拿出来,实际上是只有将模板string+model解析成新的string的功能而已,因此,想要独立的使用Razor就需要为独立的Razor引擎补充一些功能,&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;首先需要补充的就是Layout功能&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 开始动工之前,我们先来了解一下一些功能对应到Razor中,是怎么个实现方式的:&lt;/p&gt;

&lt;p&gt;1.先来看一段简单的cshtml文件以及生成后的类:&lt;/p&gt;
&lt;p&gt;   _Layout.cshtml&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('9b1bd7aa-19fb-4f35-b0f1-05b42dcbca41')&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_9b1bd7aa-19fb-4f35-b0f1-05b42dcbca41&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_9b1bd7aa-19fb-4f35-b0f1-05b42dcbca41&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('9b1bd7aa-19fb-4f35-b0f1-05b42dcbca41',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_9b1bd7aa-19fb-4f35-b0f1-05b42dcbca41&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     
&lt;span&gt; 7&lt;/span&gt;     
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;@RenderBody()
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;@RenderSection(&quot;test&quot;,false)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;   Index.cshtml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('a4bcc6a3-e99e-45c4-be89-c96d593ccc37')&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_a4bcc6a3-e99e-45c4-be89-c96d593ccc37&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_a4bcc6a3-e99e-45c4-be89-c96d593ccc37&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('a4bcc6a3-e99e-45c4-be89-c96d593ccc37',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_a4bcc6a3-e99e-45c4-be89-c96d593ccc37&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@{
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    Layout = &quot;_Layout.cshtml&quot;;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;sdfsdfsdfs&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;@section test{
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;ddddddddd&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;   Index.cshtml生成后的代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('24b15e9e-5896-4a39-abe4-d48374f2fdcb')&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_24b15e9e-5896-4a39-abe4-d48374f2fdcb&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_24b15e9e-5896-4a39-abe4-d48374f2fdcb&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('24b15e9e-5896-4a39-abe4-d48374f2fdcb',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_24b15e9e-5896-4a39-abe4-d48374f2fdcb&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#pragma&lt;/span&gt; warning disable 1591
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; TEst
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;#line&lt;/span&gt; hidden
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; TextFile1 : WindowsFormsApp2.RazorViewBase&amp;lt;WindowsFormsApp2.Model&amp;gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;#pragma&lt;/span&gt; warning disable 1998
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;global&lt;/span&gt;&lt;span&gt;::System.Threading.Tasks.Task ExecuteAsync()
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             WriteLiteral(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             WriteLiteral(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;#line&lt;/span&gt; 5 &quot;TextFile1.cshtml&quot;
&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;             Layout = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sdfsdfsdfsf&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;#line&lt;/span&gt; default
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;#line&lt;/span&gt; hidden
&lt;span&gt;21&lt;/span&gt;             WriteLiteral(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n&amp;lt;html&amp;gt;\r\n&amp;lt;head&amp;gt;\r\n    &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;\r\n&amp;lt;/head&amp;gt;\r\n&amp;lt;body&amp;gt;\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             DefineSection(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ui&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;async&lt;/span&gt; () =&amp;gt;
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                 WriteLiteral(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;#line&lt;/span&gt; 15 &quot;TextFile1.cshtml&quot;
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;                Write(Model.A1);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;#line&lt;/span&gt; default
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;#line&lt;/span&gt; hidden
&lt;span&gt;30&lt;/span&gt;                 WriteLiteral(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;\r\n    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;#line&lt;/span&gt; 16 &quot;TextFile1.cshtml&quot;
&lt;span&gt;32&lt;/span&gt;                 Write(Model.A1?.StartsWith(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sfdsfdf&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt; &lt;span&gt;#line&lt;/span&gt; default
&lt;span&gt;35&lt;/span&gt; &lt;span&gt;#line&lt;/span&gt; hidden
&lt;span&gt;36&lt;/span&gt;                 WriteLiteral(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n        &amp;lt;p&amp;gt;&amp;lt;/p&amp;gt;\r\n    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;            );
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;             WriteLiteral(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;/body&amp;gt;\r\n&amp;lt;/html&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;#pragma&lt;/span&gt; warning restore 1998
&lt;span&gt;42&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;#pragma&lt;/span&gt; warning restore 1591
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;1.关于基类,Razor引擎可以设置本次生成的类的基类,并且,要求基类中需要实现几个函数,已供生成的子类调用&lt;/p&gt;
&lt;p&gt;2.@section : 如果使用section关键字,编译后,其实是调用基类的DefineSection(string name, Func&amp;lt;Task&amp;gt; act)函数,&lt;/p&gt;
&lt;p&gt;   如:在Layout 中,使用 Html.RenderSesction 函数输出&lt;/p&gt;
&lt;p&gt;    那么在引用该Layout的页面中,如Index.csthml中,使用&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;@section header{
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     sdfsdfsdfsdfs
&lt;span&gt;3&lt;/span&gt;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;TODO:其他需要输出在头部的标签&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;     对应到实际生成的代码,其实是这样的&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; DefineSection(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;header&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;async&lt;/span&gt; () =&amp;gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;                 WriteLiteral(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;#line&lt;/span&gt; 15 &quot;TextFile1.cshtml&quot;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;                Write(Model.A1);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;#line&lt;/span&gt; default
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;#line&lt;/span&gt; hidden
&lt;span&gt; 9&lt;/span&gt;                 WriteLiteral(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;\r\n    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;#line&lt;/span&gt; 16 &quot;TextFile1.cshtml&quot;
&lt;span&gt;11&lt;/span&gt;                 Write(Model.A1?.StartsWith(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sfdsfdf&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;#line&lt;/span&gt; default
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;#line&lt;/span&gt; hidden
&lt;span&gt;15&lt;/span&gt;                 WriteLiteral(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n        &amp;lt;p&amp;gt;&amp;lt;/p&amp;gt;\r\n    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             )
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;     由生成的代码可以看到 ,@section 段的使用,需要基类实现 DefineSection(string name, Func&amp;lt;Task&amp;gt; act) 函数,并且将传入的函数存起来,等待Html.RenderSesction 触发时调用&lt;/p&gt;

&lt;p&gt;3.RenderBody,该函数其实是直接把Index.cshtml中,非@section的部分直接输出,由ExecuteAsync函数开始,所有的WriteLiteral的结果总和,因为@section部分已经是通过DefineSection定义了,所以直接输出其他结果并不会干扰到&lt;/p&gt;

&lt;p&gt;4.WriteLiteral和Write: WriteLiteral 直接输原始数据,Write除非是输出HtmlString,否则需要转码&lt;/p&gt;
&lt;p&gt;5.ExecuteAsync函数:Razor其实上是把cshtml转成对ExecuteAsync函数的内容&lt;/p&gt;
&lt;p&gt;6.VS 的IDE支持,,由于.net core 3.0还未出正式版.所以创建的项目为.net 4.5的,而引用的又是asp.net core 的Razor,所以在IDE支持上会有一点点的小区别:&lt;/p&gt;
&lt;p&gt;   因此为了省的IDE报太多的错误,需要在基类中,添加几个用于糊弄IDE的函数和属性:&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; HttpContextFake Context { &lt;span&gt;set&lt;/span&gt;; &lt;span&gt;get&lt;/span&gt;; }  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回自己模拟的一个HttpContext的类,&lt;/span&gt;
   &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; DefineSection(&lt;span&gt;string&lt;/span&gt; name, Action act)  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;函数签名略微不同&lt;/span&gt;
   &lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Execute() &lt;span&gt;//&lt;/span&gt;&lt;span&gt;IDE认的就是这个函数,不存在会报错,但没有实际用途&lt;/span&gt;
&lt;span&gt;   

   [Browsable(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;),Obsolete]
   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HttpContextFake
   {
      &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; System.Web.HttpApplication ApplicationInstance { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;顺带附上Razor+NaneUI的项目的地址: https://gitee.com/kugar/Kugar.UI.RazorUI&lt;/p&gt;

&lt;p&gt;以上是Razor一些小的细节,,下篇文章就开始来说怎么创建一个支持Layout的独立Razor了&lt;/p&gt;

</description>
<pubDate>Thu, 14 Mar 2019 05:43:00 +0000</pubDate>
<dc:creator>启天</dc:creator>
<og:description>由于最近需要写一些界面稍微好看点的Winform程序,如果用原生控件,,想要达到好看的程度,需要花费比较大的功夫,因为之前使用过CefSharp,因此发觉如果是使用CEF+Html的方式,界面可以相对</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kugar/p/10527782.html</dc:identifier>
</item>
</channel>
</rss>