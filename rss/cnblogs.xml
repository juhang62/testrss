<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>ASP.NET Core 2.2  十九. 你扔过来个json，我怎么接 - FlyLolo</title>
<link>http://www.cnblogs.com/FlyLolo/p/ASPNETCore2_19.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/FlyLolo/p/ASPNETCore2_19.html</guid>
<description>&lt;p&gt;　　前文说道了Action的激活，这里有个关键的操作就是Action参数的映射与模型绑定，这里即涉及到简单的string、int等类型，也包含Json等复杂类型，本文详细分享一下这一过程。（&lt;a href=&quot;http://www.cnblogs.com/FlyLolo/p/ASPNETCore2_0.html&quot; target=&quot;_blank&quot;&gt;&lt;span data-ttu-id=&quot;4542a-111&quot;&gt;ASP.NET Core 系列目录&lt;/span&gt;&lt;/a&gt;）&lt;/p&gt;

&lt;p&gt;　　当客户端发出一个请求的时候，参数可能存在于URL中也可能是在请求的Body中，而参数类型也大不相同，可能是简单类型的参数，如字符串、整数或浮点数，也可能是复杂类型的参数，比如常见的Json、XML等，这些事怎么与目标Action的参数关联在一起并赋值的呢？&lt;/p&gt;
&lt;p&gt;　　故事依然是发生在通过路由确定了被请求的Action之后，invoker的创建与执行阶段（详见&lt;a href=&quot;https://www.cnblogs.com/FlyLolo/p/ASPNETCore2_17.html&quot; target=&quot;_blank&quot;&gt;Action的执行&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;       invoker的创建阶段，创建处理方法，并根据目标Action的actionDescriptor获取到它的所有参数，分析各个参数的类型确定对应参数的绑定方法，&lt;/p&gt;
&lt;p&gt;       invoker的执行阶段，调用处理方法，遍历参数逐一进行赋值。&lt;/p&gt;
&lt;p&gt;        为了方便描述，创建一个测试Action如下，它有两个参数，下文以此为例进行描述。：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; JsonResult Test([FromBody]User user,&lt;span&gt;string&lt;/span&gt; note = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;FlyLolo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; JsonResult(user.Code + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; user.Name );
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;   1. 创建绑定方法&lt;/h2&gt;
&lt;p&gt;　当收到请求后，由路由系统确定了被访问的目标Action是我们定义的Test方法， 这时进入invoker的创建阶段，前文说过它有一个关键属性cacheEntry是由多个对象组装而成（发生在ControllerActionInvokerCache的GetCachedResult方法中），其中一个是propertyBinderFactory：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; propertyBinderFactory =&lt;span&gt; ControllerBinderDelegateProvider.CreateBinderDelegate(_parameterBinder,_modelBinderFactory,_modelMetadataProvider,actionDescriptor,_mvcOptions);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;      看一下CreateBinderDelegate这个方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; ControllerBinderDelegate CreateBinderDelegate(ParameterBinder parameterBinder,IModelBinderFactory modelBinderFactory,&lt;br/&gt;IModelMetadataProvider modelMetadataProvider, ControllerActionDescriptor actionDescriptor,  MvcOptions mvcOptions)
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;各种验证  略&lt;/span&gt;

    &lt;span&gt;var&lt;/span&gt; parameterBindingInfo =&lt;span&gt; GetParameterBindingInfo(modelBinderFactory,  modelMetadataProvider, actionDescriptor, mvcOptions);
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; propertyBindingInfo =&lt;span&gt; GetPropertyBindingInfo(modelBinderFactory, modelMetadataProvider, actionDescriptor);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (parameterBindingInfo == &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; propertyBindingInfo == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Bind;

    &lt;/span&gt;&lt;span&gt;async&lt;/span&gt; Task Bind(ControllerContext controllerContext, &lt;span&gt;object&lt;/span&gt; controller, Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt; arguments)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;后文详细描述&lt;/span&gt;
&lt;span&gt;    }
 }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;      前文说过，invoker的创建阶段就是创建一些关键对象和一些用于执行的方法，而propertyBinderFactory 就是众多方法之中的一个，前文介绍它是一个用于参数绑定的Task，而没有详细说明，现在可以知道它被定义为一个名为Bind的Task，最终作为invoker的一部分等待被执行进行参数绑定。&lt;/p&gt;
&lt;h2&gt;    2. 为每个参数匹配Binder&lt;/h2&gt;
&lt;p&gt;      上面的CreateBinderDelegate方法创建了两个对象parameterBindingInfo 和propertyBindingInfo ，顾名思义，一个用于参数一个用于属性。看一下parameterBindingInfo 的创建：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; BinderItem[] GetParameterBindingInfo(IModelBinderFactory modelBinderFactory,IModelMetadataProvider modelMetadataProvider,ControllerActionDescriptor actionDescriptor, MvcOptions mvcOptions)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; parameters =&lt;span&gt; actionDescriptor.Parameters;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (parameters.Count == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; parameterBindingInfo = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BinderItem[parameters.Count];
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; parameters.Count; i++&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; parameter =&lt;span&gt; parameters[i];&lt;/span&gt;&lt;span&gt;
　　　　　　　　　　//略。。。
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; binder = modelBinderFactory.CreateBinder(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ModelBinderFactoryContext
                {
                    BindingInfo &lt;/span&gt;=&lt;span&gt; parameter.BindingInfo,
                    Metadata &lt;/span&gt;=&lt;span&gt; metadata,
                    CacheToken &lt;/span&gt;=&lt;span&gt; parameter,
                });

                parameterBindingInfo[i] &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BinderItem(binder, metadata);
            }

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; parameterBindingInfo;
        }&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 可以看到parameterBindingInfo 本质是一个BinderItem[]&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; BinderItem
        {
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; BinderItem(IModelBinder modelBinder, ModelMetadata modelMetadata)
            {
                ModelBinder &lt;/span&gt;=&lt;span&gt; modelBinder;
                ModelMetadata &lt;/span&gt;=&lt;span&gt; modelMetadata;
            }

            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IModelBinder ModelBinder { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }

            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ModelMetadata ModelMetadata { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过遍历目标Action的所有参数actionDescriptor.Parameters，根据参数逐一匹配一个对应定的处理对象BinderItem。&lt;/p&gt;
&lt;p&gt;如本例，会匹配到两个Binder：&lt;/p&gt;
&lt;p&gt;参数 user   ===&amp;gt;  {Microsoft.AspNetCore.Mvc.ModelBinding.Binders.BodyModelBinder}&lt;/p&gt;
&lt;p&gt;参数 note  ===&amp;gt;   {Microsoft.AspNetCore.Mvc.ModelBinding.Binders.SimpleTypeModelBinder}&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这是如何匹配的呢&lt;/span&gt;，系统定义了一系列provider，如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/548134/201902/548134-20190225170716368-1355631770.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　　　图一&lt;/p&gt;
&lt;p&gt;会遍历他们分别与当前参数做匹配：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; _providers.Length; i++&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; provider =&lt;span&gt; _providers[i];
                result &lt;/span&gt;=&lt;span&gt; provider.GetBinder(providerContext);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (result != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                }
            }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;同样以这两个Binder为例看一下，&lt;strong&gt;BodyModelBinderProvider&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; IModelBinder GetBinder(ModelBinderProviderContext context)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (context == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArgumentNullException(nameof(context));
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (context.BindingInfo.BindingSource != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt;
                context.BindingInfo.BindingSource.CanAcceptDataFrom(BindingSource.Body))
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (_formatters.Count == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InvalidOperationException(Resources.FormatInputFormattersAreRequired(
                        &lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(MvcOptions).FullName,
                        nameof(MvcOptions.InputFormatters),
                        &lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(IInputFormatter).FullName));
                }

                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BodyModelBinder(_formatters, _readerFactory, _loggerFactory, _options);
            }

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;BodyModelBinder的主要判断依据是BindingSource.Body  也就是user参数我们设置了[FromBody]。&lt;/p&gt;
&lt;p&gt;同理SimpleTypeModelBinder的判断依据是 &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;if&lt;/span&gt; (!context.Metadata.IsComplexType)&lt;/span&gt; 。&lt;/p&gt;
&lt;p&gt;找到对应的provider后，则会由该provider来new 一个 ModelBinder返回，也就有了上文的BodyModelBinder和SimpleTypeModelBinder。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;小结：至此前期准备工作已经完成，这里创建了三个重要的对象：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. Task Bind() ，用于绑定的方法，并被封装到了invoker内的CacheEntry中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. parameterBindingInfo ：本质是一个BinderItem[]，其中的BinderItem数量与Action的参数数量相同。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3. propertyBindingInfo：类似parameterBindingInfo， 用于属性绑定，下面详细介绍。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/548134/201902/548134-20190226104626545-654318007.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　　　　　图二&lt;/p&gt;

&lt;p&gt;　　从上一节的小结可以猜到，执行阶段就是调用Bind方法，利用创建的parameterBindingInfo和propertyBindingInfo将请求发送来的参数处理后赋值给Action对应的参数。&lt;/p&gt;
&lt;p&gt;　　同样，这个阶段发生在invoker（即ControllerActionInvoker）的InvokeAsync()阶段，当调用到它的Next方法的时候，首先第一步State为ActionBegin的时候就会调用BindArgumentsAsync()方法，如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;private&lt;/span&gt; Task Next(&lt;span&gt;ref&lt;/span&gt; State next, &lt;span&gt;ref&lt;/span&gt; Scope scope, &lt;span&gt;ref&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; state, &lt;span&gt;ref&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; isCompleted)
        {
            &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (next)
            {
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; State.ActionBegin:
                    {
&lt;span&gt;　　　　　　　　　　　　　　//略。。。&lt;/span&gt;&lt;/span&gt;&lt;span&gt;
                        _arguments &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt;(StringComparer.OrdinalIgnoreCase);

                        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; task =&lt;span&gt; BindArgumentsAsync();&lt;/span&gt;&lt;span&gt;
                    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而BindArgumentsAsync()方法会调用上一节创建的_cacheEntry.ControllerBinderDelegate，也就是Task Bind() 方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Task BindArgumentsAsync()
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 略。。。&lt;/span&gt;&lt;span&gt;            return&lt;/span&gt;&lt;span&gt; _cacheEntry.ControllerBinderDelegate(_controllerContext, _instance, _arguments);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上一节略了，现在详细看一下这个方法，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;            async&lt;/span&gt; Task Bind(ControllerContext controllerContext, &lt;span&gt;object&lt;/span&gt; controller, Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt; arguments)
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; valueProvider = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; CompositeValueProvider.CreateAsync(controllerContext);
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; parameters =&lt;span&gt; actionDescriptor.Parameters;

                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; parameters.Count; i++&lt;span&gt;) &lt;span&gt;//遍历参数集和，逐一处理&lt;/span&gt;
                {
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; parameter =&lt;span&gt; parameters[i];
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; bindingInfo =&lt;span&gt; parameterBindingInfo[i];
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; modelMetadata =&lt;span&gt; bindingInfo.ModelMetadata;

                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;modelMetadata.IsBindingAllowed)
                    {
                        &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
                    }

                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; parameterBinder.BindModelAsync(
                        controllerContext,
                        bindingInfo.ModelBinder,
                        valueProvider,
                        parameter,
                        modelMetadata,
                        value: &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);

                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (result.IsModelSet)
                    {
                        arguments[parameter.Name] &lt;/span&gt;=&lt;span&gt; result.Model;
                    }
                }

                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; properties =&lt;span&gt; actionDescriptor.BoundProperties;
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; properties.Count; i++&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;略&lt;/span&gt;
            }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　主体就是两个for循环，分别用于处理参数和属性，依然是以参数处理为例说明。 &lt;/p&gt;
&lt;p&gt;　　依然是先获取到Action所有的参数，然后进入for循环进行遍历，通过parameterBindingInfo[i]获取到参数对应的BinderItem，这些都准备好后调用parameterBinder.BindModelAsync()方法进行参数处理和赋值。注意这里传入了 &lt;span class=&quot;cnblogs_code&quot;&gt;bindingInfo.ModelBinder&lt;/span&gt; ，在parameterBinder中会调用传入的modelBinder的BindModelAsync方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
modelBinder.BindModelAsync(modelBindingContext);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而这个modelBinder是根据参数匹配的，也就是到现在已经将被处理对象交给了上文的BodyModelBinder、SimpleTypeModelBinder等具体的ModelBinder了。&lt;/p&gt;
&lt;p&gt; 以BodyModelBinder为例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;        public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task BindModelAsync(ModelBindingContext bindingContext)
        {
           &lt;span&gt; //略。。。&lt;/span&gt;&lt;/span&gt;&lt;span&gt;            var&lt;/span&gt; formatterContext = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InputFormatterContext(httpContext,modelBindingKey,bindingContext.ModelState, bindingContext.ModelMetadata,  _readerFactory, allowEmptyInputInModelBinding);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; formatter = (IInputFormatter)&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; _formatters.Count; i++&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (_formatters[i].CanRead(formatterContext))
                {
                    formatter &lt;/span&gt;=&lt;span&gt; _formatters[i];
                    _logger&lt;/span&gt;?&lt;span&gt;.InputFormatterSelected(formatter, formatterContext);
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                {
                    _logger&lt;/span&gt;?&lt;span&gt;.InputFormatterRejected(_formatters[i], formatterContext);
                }
            }&lt;/span&gt;&lt;span&gt;            var&lt;/span&gt; result = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; formatter.ReadAsync(formatterContext);&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;            //略。。。&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;       }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       部分代码已省略，剩余部分可以看到，这里像上文匹配provider一样，会遍历一个名为_formatters的集和，通过子项的CanRead方法来确定是否可以处理这样的formatterContext。若可以，则调用该formatter的ReadAsync()方法进行处理。这个_formatters集和默认有两个Formatter， &lt;span class=&quot;cnblogs_code&quot;&gt;Microsoft.AspNetCore.Mvc.Formatters.JsonPatchInputFormatter}&lt;/span&gt; 和 &lt;span class=&quot;cnblogs_code&quot;&gt; Microsoft.AspNetCore.Mvc.Formatters.JsonInputFormatter&lt;/span&gt; , JsonPatchInputFormatter的判断逻辑是这样的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;typeof&lt;/span&gt;(IJsonPatchDocument).GetTypeInfo().IsAssignableFrom(modelTypeInfo) ||
                !&lt;span&gt;modelTypeInfo.IsGenericType)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　它会判断请求的类型是否为IJsonPatchDocument，JsonPatch见本文后面的备注，回到本例，我们经常情况遇到的还是用JsonInputFormatter，此处它会被匹配到。它继承自TextInputFormatter ， TextInputFormatter 又继承自 InputFormatter，JsonInputFormatter未重写CanRead方法，采用InputFormatter的CanRead方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; CanRead(InputFormatterContext context)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (SupportedMediaTypes.Count == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; message =&lt;span&gt; Resources.FormatFormatter_NoMediaTypes(GetType().FullName, nameof(SupportedMediaTypes));
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InvalidOperationException(message);
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;CanReadType(context.ModelType))
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; contentType =&lt;span&gt; context.HttpContext.Request.ContentType;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(contentType))
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }
&lt;/span&gt;            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; IsSubsetOfAnySupportedContentType(contentType);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　例如要求ContentType不能为空。本例参数为 &lt;span class=&quot;cnblogs_code&quot;&gt;[FromBody]User user&lt;/span&gt; ，并标识了 &lt;span class=&quot;cnblogs_code&quot;&gt;content-type: application/json&lt;/span&gt; ，通过CanRead验证后，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;InputFormatterResult&amp;gt;&lt;span&gt; ReadRequestBodyAsync(InputFormatterContext context,Encoding encoding)
        {
&lt;span&gt;           //略。。。。&lt;/span&gt;&lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; streamReader =&lt;span&gt; context.ReaderFactory(request.Body, encoding))
            {
                &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; jsonReader = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JsonTextReader(streamReader))
                {
                    jsonReader.ArrayPool &lt;/span&gt;=&lt;span&gt; _charPool;
                    jsonReader.CloseInput &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;span&gt;　　　　　　　　　　　　//略。。&lt;/span&gt;&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; type =&lt;span&gt; context.ModelType;
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; jsonSerializer =&lt;span&gt; CreateJsonSerializer();
                    jsonSerializer.Error &lt;/span&gt;+=&lt;span&gt; ErrorHandler;
                    &lt;/span&gt;&lt;span&gt;object&lt;/span&gt;&lt;span&gt; model;
                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
                    {
                        model &lt;/span&gt;=&lt;span&gt; jsonSerializer.Deserialize(jsonReader, type);
                    }
                    &lt;/span&gt;&lt;span&gt;
&lt;span&gt;　　　　　　　　　　　　//略。。。&lt;/span&gt;&lt;/span&gt;&lt;span&gt;
                }
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　可以看到此处就是将收到的请求的内容Deserialize，获取到一个model返回。此处的jsonSerializer是 &lt;span class=&quot;cnblogs_code&quot;&gt;Newtonsoft.Json.JsonSerializer&lt;/span&gt; ，系统默认采用的json处理组件是Newtonsoft。model返回后，被赋值给对应的参数，至此赋值完毕。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;小结：本阶段的工作是获取请求参数的值并赋值给Action的对应参数的过程。由于参数不同，会分配到一些不同的处理方法中处理。例如本例涉及到的provider（图一）、不同的ModelBinder（BodyModelBinder和SimpleTypeModelBinder）、不同的Formatter等等，实际项目中还会遇到其他的类型，这里不再赘述。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;而文中有两个需要单独说明的，在后面的小节里说一下。 &lt;/span&gt;&lt;/p&gt;

&lt;p&gt; 上文提到了但没有介绍，它主要用于处理Controller的属性的赋值，例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FlyLoloController : Controller
    {
        [ModelBinder]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Key { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;有一个属性Key被标记为[ModelBinder]，它会在Action被请求的时候，像给参数赋值一样赋值，处理方式也类似，不再描述。&lt;/p&gt;

&lt;p&gt;上文中提到了JsonPatchInputFormatter，简要说一下JsonPatch，可以理解为操作json的文档，比如上文的User类是这样的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    public class&lt;span&gt; User
    {
        public string Code { get; set&lt;span&gt;; }
        public string Name { get; set&lt;span&gt;; }&lt;br/&gt;//other ...
    }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　现在我只想修改它的Name属性，默认情况下我仍然会需要提交这样的json&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
{&quot;Code&quot;:&quot;001&quot;,&quot;Name&quot;:&quot;张三&quot;, .........}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这不科学，从省流量的角度来说也觉得太多了，用JsonPatch可以这样写&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[
   { &quot;op&quot; : &quot;replace&quot;, &quot;path&quot; : &quot;/Name&quot;, &quot;value&quot; : &quot;张三&quot;&lt;span&gt; }
]&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Tue, 26 Feb 2019 22:46:00 +0000</pubDate>
<dc:creator>FlyLolo</dc:creator>
<og:description>前文说道了Action的激活，这里有个关键的操作就是Action参数的映射与模型绑定，这里即涉及到简单的string、int等类型，也包含Json等复杂类型，本文详细分享一下这一过程。（ASP.NET</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/FlyLolo/p/ASPNETCore2_19.html</dc:identifier>
</item>
<item>
<title>iOS 性能优化 - 国孩</title>
<link>http://www.cnblogs.com/guohai-stronger/p/10430106.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/guohai-stronger/p/10430106.html</guid>
<description>&lt;p&gt;大家在面试一些B轮以上的公司，很多面试大佬都会问怎么优化tableView或者iOS程序如何优化等。本篇博客将讲述iOS性能优化，围绕以下问题讲述：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、内存&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;内存布局&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;retain&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;weak&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;二、Runloop&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;NSTimer&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;面试-Runloop&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;三、界面&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;内存泄露&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TableView优化&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;下面我们一一讲述上面内容。&lt;/p&gt;

&lt;h2&gt;1.1 内存布局&lt;/h2&gt;
&lt;p&gt;代码的文件是可执行的二进制文件，在二进制文件中，我们怎么区分这些文件呢，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1305302/201902/1305302-20190225120502134-1788068657.png&quot; alt=&quot;&quot; width=&quot;333&quot; height=&quot;324&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;1.1.1 内核&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;内核是操作系统最关键的组成部分。内核的功能是负责接触底层，所以大部分会用到C语音进行编写的，有的甚至使用到汇编语言。iOS的核心是XNU内核。 &lt;/p&gt;
&lt;p&gt;XNU内核是混合内核，其核心是叫Mach的微内核，其中Mach中亦是消息传递机制，但是使用的是指针形式传递。因为大部分的服务都在XNU内核中。Mach没有昂贵的复制操作，只用指针就可以完成的消息传递。&lt;/p&gt;
&lt;h3&gt;1.1.2 栈（stack）&lt;/h3&gt;
&lt;p&gt;栈主要存放局部变量和函数参数等相关的变量，如果超出其作用域后也会自动释放。栈区：是向低字节扩展的数据结构，也是一块连续的内存区域。&lt;/p&gt;
&lt;h3&gt;1.1.3 堆（heap）&lt;/h3&gt;
&lt;p&gt;堆区存放new，alloc等关键字创造的对象，我们在之前常说的内存管理管理的也是这部分内存。堆区：是向高地址扩展的数据结构，不连续的内存区域，会造成大量的碎片。&lt;/p&gt;
&lt;h3&gt;1.1.4 BSS段&lt;/h3&gt;
&lt;p&gt;BSS段存放未初始化的全局变量以及静态变量，一旦初始化就会从BSS段去掉，转到数据段中。&lt;/p&gt;
&lt;h3&gt;1.1.5 Data段&lt;/h3&gt;
&lt;p&gt;Data段存储已经初始化好的静态变量和全局变量，以及常量数据，直到程序结束之后才会被立即收回。&lt;/p&gt;
&lt;h3&gt;1.1.6 text段&lt;/h3&gt;
&lt;p&gt;text段是用来存放程序代码执行的一块内存区域。这一块内存区域的大小在程序运行前就已经确定，通常也是只读属性。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;拓展：全局变量、成员变量、局部变量、实例属性和静态变量以及类属性区别&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;变量按作用范围可以分为全局变量和局部变量，其中全局变量也就是成员变量。成员变量按调用的方式可以分为类属性和实例属性。类属性是用static修饰的成员变量，也就是静态变量。实例属性是没有用static修饰的成员变量，也叫作非静态变量&lt;/strong&gt;。如下图更直观看出关系：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1305302/201902/1305302-20190225164822677-399797050.jpg&quot; alt=&quot;&quot; width=&quot;475&quot; height=&quot;236&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在这其中，如果局部变量和全局变量的名字是一样的，局部变量的作用范围区域内全局变量就会被隐藏；但是如果在局部变量的范围内想要访问成员变量，必须要使用&lt;strong&gt;关键字this&lt;/strong&gt;来引用全局变量（成员变量）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;全局变量（成员变量）和局部变量的区别&lt;/span&gt;：&lt;/span&gt; &lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;内存中位置不同&lt;/strong&gt;：全局变量（成员变量）在堆内存，全局变量（成员变量）属于对象，对象进入堆内存；局部变量属于方法，方法进入栈内存&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;生命周期不同&lt;/strong&gt;：全局变量（成员变量）随着对象的创建而存在的，对象消失也随之消失；局部变量随着方法调用而存在，方法调用完毕而消失&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;初始化不同&lt;/strong&gt;：全局变量（成员变量）有默认的初始化值；局部变量是没有默认初始化的，必须定义，然后才能使用。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;全局变量（成员变量）和静态变量的区别：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt; 内存位置不同：静态变量也就是类属性，存放在静态区；成员变量存放在堆内存&lt;/li&gt;
&lt;li&gt;调用方式不同：静态变量可以通过对象调用，也可以通过类名调用；成员变量就只能用对象名调用&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;1.2 retain&lt;/h2&gt;
&lt;p&gt;对于retain，如果经过taggerPointer修饰过的，就直接return，如果不是的话，就调用当前的retain-rootRetain方法 。需要关注当前引用计数什么时候加1-----通过sideTable方法，加一个偏移量refcntStorage。这就是内部实现的过程。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;拓展：retain与copy有什么区别？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;copy&lt;/strong&gt;：建立索引计数为1的对象，然后释放对象；copy建立一个相同的对象，如果一个NSString对象，假如地址为0x1111，内容为@&quot;hello&quot;，通过Copy到另一个对象之后，地址为0x2322，内容也相同，而新的对象retain为1，旧的对象是不会发生变化；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;retain&lt;/strong&gt;：retain到另外一个对象之后，地址是不会变化的，地址也为0x1111，实质上是建立一个指针，也就是指针拷贝，内容也是相同的，retain值会加1。&lt;/p&gt;

&lt;h2&gt;1.3 weak&lt;/h2&gt;
&lt;p&gt;weak的底层实现也是面试官经常被问到的，本人也在杭州有赞面试中被问到，不过说实话，把我问倒了,回来看了一下weak的实现源码runtime，然后写了一篇博客。在这里就不重复了，看一下下面的博客地址就可以了解weak底层是怎么实现的。&lt;/p&gt;
&lt;p&gt; weak实现原理：&lt;a href=&quot;https://www.cnblogs.com/guohai-stronger/p/10161870.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/guohai-stronger/p/10161870.html&lt;/a&gt;&lt;/p&gt;


&lt;h2&gt; 2.1 NSTimer&lt;/h2&gt;
&lt;p&gt;关于NSTimer造成的潜在循环引用问题，想必大家都知道，很菜的我都不继续说了，如果想要了解iOS可能存在的循环引用问题，大家可以读本人写的专门针对iOS循环引用问题的博客。&lt;/p&gt;
&lt;p&gt;循环引用的博客地址：&lt;a href=&quot;https://www.cnblogs.com/guohai-stronger/p/9011806.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/guohai-stronger/p/9011806.html&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;2.1.1 NSTimer与Block处理方式&lt;/h3&gt;
&lt;p&gt;首先看下面代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
_timer = [NSTimer scheduledTimerWithTimeInterval:&lt;span&gt;1.0f&lt;/span&gt; target:self selector:@selector(fire) userInfo:nil repeats:YES];
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于上面的代码会造成循环引用，那我们加上这句代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;__weak typeof(self) weakSelf =&lt;/span&gt;&lt;span&gt;&lt;span&gt; self;&lt;/span&gt;
_timer &lt;/span&gt;= [NSTimer scheduledTimerWithTimeInterval:&lt;span&gt;1.0f&lt;/span&gt; target:&lt;span&gt;weakSelf&lt;/span&gt; selector:@selector(fire) userInfo:nil repeats:YES];
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;加上这句代码，为什么就不可以解决循环引用呢？&lt;/p&gt;
&lt;p&gt;&lt;span&gt;答案是&lt;/span&gt;当然不可以解决循环引用。__weak typeof(self) weakSelf = self;这个weakSelf指向的地址就是当前self指向的地址；如果再使用strong---&amp;gt;weakSelf，也会使self连带指针retain（加1）操作，没有办法避免当前VC引用计数加1。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1305302/201902/1305302-20190226134823174-736109600.png&quot; alt=&quot;&quot; width=&quot;680&quot; height=&quot;180&quot;/&gt;&lt;/p&gt;
&lt;p&gt;反之，为什么block就可以呢?&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
self.name = &lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;logic&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
__weak typeof(self) weakSelf =&lt;/span&gt;&lt;span&gt;&lt;span&gt; self;&lt;/span&gt;
_block &lt;/span&gt;= ^(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;){&lt;br/&gt;NSLog(&lt;/span&gt;&lt;span&gt;&quot;%@&lt;/span&gt;&lt;span&gt;&quot;,self.name&lt;/span&gt;&lt;span&gt;);  
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过上面代码，原本是block--&amp;gt;self,self--&amp;gt;block两者相互持有，导致无法释放；&lt;span&gt;现在有weakSelf&lt;/span&gt;打破这种关系，用weak修饰，在block执行完就会被释放，不会循环引用。&lt;/p&gt;
&lt;p&gt;再看一个viewDidLoad代码中如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
self.name = &lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;logic&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
__weak &lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;(self) weakSelf =&lt;span&gt; self;
_block &lt;/span&gt;= ^(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;){
    &lt;span&gt;__strong &lt;/span&gt;&lt;/span&gt;&lt;span&gt;typeof(weakSelf) strongSelf =&lt;/span&gt;&lt;span&gt;&lt;span&gt; weakSelf;&lt;/span&gt;
    NSLog(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%@&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,self.name);  
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在block内使用__strong 同样会使当前的self引用计数retain(加1),会延迟当前对象的释放，那为什么不造成引用呢？&lt;/p&gt;
&lt;p&gt;&lt;span&gt;原因&lt;/span&gt;是__strongSelf是在block代码块里面。当我们viewDidLoad执行完之后，初始化的局部变量也会被随之释放；类比来说，block也是这个原理，当我们代码块的逻辑执行完之后,__strong声明的__strongSelf也会被回收，__strongSelf会被回收，代表着self的引用计数回归正常，调用析构函数，完成回收。&lt;/p&gt;

&lt;h3&gt;2.1.2 NSTimer创建方式区别&lt;/h3&gt;
&lt;p&gt;NSTimer官方的类并不是很多，我们把它粘贴出来&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@interface&lt;/span&gt;&lt;span&gt; NSTimer : NSObject
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化，最好用scheduled方式初始化，不然需要手动addTimer:forMode: 将timer添加到一个runloop中。&lt;/span&gt;
+ (NSTimer *)timerWithTimeInterval:(NSTimeInterval)ti invocation:(NSInvocation *&lt;span&gt;)invocation repeats:(BOOL)yesOrNo;
&lt;/span&gt;+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)ti invocation:(NSInvocation *&lt;span&gt;)invocation repeats:(BOOL)yesOrNo;

&lt;/span&gt;+ (NSTimer *)timerWithTimeInterval:(NSTimeInterval)ti target:(&lt;span&gt;id&lt;/span&gt;)aTarget selector:(SEL)aSelector userInfo:(&lt;span&gt;id&lt;/span&gt;&lt;span&gt;)userInfo repeats:(BOOL)yesOrNo;
&lt;/span&gt;+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)ti target:(&lt;span&gt;id&lt;/span&gt;)aTarget selector:(SEL)aSelector userInfo:(&lt;span&gt;id&lt;/span&gt;&lt;span&gt;)userInfo repeats:(BOOL)yesOrNo;

&lt;/span&gt;- (&lt;span&gt;id&lt;/span&gt;)initWithFireDate:(NSDate *)date interval:(NSTimeInterval)ti target:(&lt;span&gt;id&lt;/span&gt;)t selector:(SEL)s userInfo:(&lt;span&gt;id&lt;/span&gt;&lt;span&gt;)ui repeats:(BOOL)rep;

&lt;/span&gt;- (&lt;span&gt;void&lt;/span&gt;)fire;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;立即触发定时器&lt;/span&gt;

- (NSDate *)fireDate;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开始时间&lt;/span&gt;
- (&lt;span&gt;void&lt;/span&gt;)setFireDate:(NSDate *)date;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置fireData，其实暂停、开始会用到&lt;/span&gt;

- (NSTimeInterval)timeInterval;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;延迟时间&lt;/span&gt;

- (&lt;span&gt;void&lt;/span&gt;)invalidate;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;停止并删除&lt;/span&gt;
- (BOOL)isValid;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断是否valid&lt;/span&gt;

- (&lt;span&gt;id&lt;/span&gt;)userInfo;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通常用nil&lt;/span&gt;

&lt;span&gt;@end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而创建方式有三种&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;&lt;span&gt;. scheduledTimerWithTimeInterval:invocation:repeats:或者scheduledTimerWithTimeInterval:target:selector:userInfo:repeats:

&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;.timerWithTimeInterval:invocation:repeats:或者timerWithTimeInterval:target:selector:userInfo:repeats:

&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;.initWithFireDate:interval:target:selector:userInfo:repeats:
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;第一种创建方式&lt;/span&gt;：scheduledTimerWithTimeInterval这两个类方法会创建一个timer，并将timer指定到一个默认的runloop模式，也是NSDefaultRunLoopMode，但是有一个问题，当UI刷新滚动的时候，就不会是NSDefaultRunLoopMode了，这样timer就会停下来了。scheduledTimerWithTimeInterval不需要添加adddTimer:forMode：方法，方法也就是会自动运行timer。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第二种创建方式&lt;/span&gt;：timerWithTimeInterval这两个类方法创建的timer对象没有安排到运行循环中，必须通过NSRunloop对象对应的方法adddTimer:forMode：方法，必须手动添加运行循环。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第三种创建方式&lt;/span&gt;：initWithFireDate方法创建timer，也是需要NSRunloop下对应的adddTimer:forMode：，然后订到一个runloop模式中。&lt;/p&gt;
&lt;p&gt;我们一般使用&lt;/p&gt;

&lt;h3&gt;2.1.3 使用NSProxy解决NSTimer循环引用详解&lt;/h3&gt;
&lt;p&gt;NSTimer循环引用的解决方法，目前有以下几种&lt;/p&gt;
&lt;p&gt;(1)类方法&lt;/p&gt;
&lt;p&gt;(2)GCD方法&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(3)weakProxy&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;今天我们着重讲解weakProxy方法解决NSTimer造成的循环引用，其他方法自行百度哈。&lt;/p&gt;
&lt;p&gt;使用weakProxy解决循环引用的原因是：&lt;/p&gt;
&lt;p&gt;weakProxy是利用runtime消息转发机制来断开NSTimer对象与视图的强引用关系。初始NSTimer时把触发事件的target对象替换成了另一个单独的对象，紧接着对象中NSTimer的SEL方法触发时让这个方法在当前视图中实现。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1305302/201902/1305302-20190226163436078-2142700822.png&quot; alt=&quot;&quot; width=&quot;310&quot; height=&quot;264&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面是代码实现。&lt;/p&gt;
&lt;p&gt;新建一个继承NSProxy类的子类WeakProxy类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#import&lt;/span&gt; &amp;lt;Foundation/Foundation.h&amp;gt;&lt;span&gt;
NS_ASSUME_NONNULL_BEGIN

&lt;/span&gt;&lt;span&gt;@interface&lt;/span&gt;&lt;span&gt; WeakProxy : NSProxy
@property(nonatomic , weak)&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt; target;

&lt;/span&gt;&lt;span&gt;@end&lt;/span&gt;&lt;span&gt;

NS_ASSUME_NONNULL_END


&lt;/span&gt;&lt;span&gt;#import&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;WeakProxy.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;#import&lt;/span&gt; &amp;lt;objc/runtime.h&amp;gt;

&lt;span&gt;@implementation&lt;/span&gt;&lt;span&gt; WeakProxy

&lt;/span&gt;- (&lt;span&gt;void&lt;/span&gt;)&lt;span&gt;forwardInvocation&lt;/span&gt;:(NSInvocation *&lt;span&gt;)invocation{
    [self.target forwardInvocation:invocation];
}

&lt;/span&gt;- (nullable NSMethodSignature *&lt;span&gt;)&lt;span&gt;methodSignatureForSelector&lt;/span&gt;:(SEL)sel{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; [self.target methodSignatureForSelector:sel];
}

&lt;/span&gt;&lt;span&gt;@end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后在需要用到的类中引入WeakProxy，并声明属性&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#import&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ViewController.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;#import&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;WeakProxy.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;@interface&lt;/span&gt;&lt;span&gt; ViewController ()
@property (strong, nonatomic) NSTimer &lt;/span&gt;*&lt;span&gt;timer;
&lt;span&gt;@property(nonatomic,strong)WeakProxy &lt;/span&gt;&lt;/span&gt;&lt;span&gt;*weakProxy;

&lt;/span&gt;&lt;span&gt;@end&lt;/span&gt;

&lt;span&gt;@implementation&lt;/span&gt;&lt;span&gt; ViewController

&lt;/span&gt;- (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)viewDidLoad {
    [super viewDidLoad];
    
   &lt;span&gt; _weakProxy &lt;/span&gt;&lt;/span&gt;&lt;span&gt;= [WeakProxy alloc];
    _weakProxy.target =&lt;/span&gt;&lt;span&gt;&lt;span&gt; self;&lt;/span&gt;
    _timer &lt;/span&gt;= [NSTimer &lt;span&gt;scheduledTimerWithTimeInterval&lt;/span&gt;:&lt;span&gt;1.0f&lt;/span&gt;&lt;span&gt; target:&lt;span&gt;_weakProxy&lt;/span&gt; selector:@selector(fire) userInfo:nil repeats:YES];

}

&lt;/span&gt;- (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)fire{
    NSLog(&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;fire&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
}

&lt;/span&gt;- (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)dealloc{
    [self.timer invalidate];
    self.timer &lt;/span&gt;=&lt;span&gt; nil;
}

&lt;/span&gt;&lt;span&gt;@end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;利用上面的代码，可以解决NSTimer的循环引用问题，原理就是上面的一幅图，在这不必多言。&lt;/p&gt;

&lt;h2&gt;2.2 Runloop&lt;/h2&gt;
&lt;p&gt;对于Runloop的详解，本人也已经在以前写过Runloop底层原理的讲解，对于Runloop的面试题，那篇博客可以为大家解答。&lt;/p&gt;
&lt;p&gt;Runloop底层原理：&lt;a href=&quot;https://www.cnblogs.com/guohai-stronger/p/9190220.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/guohai-stronger/p/9190220.html&lt;/a&gt;&lt;/p&gt;


&lt;h2&gt;3.1 内存泄露&lt;/h2&gt;
&lt;h3&gt;3.1.1 内存泄露的检测&lt;/h3&gt;
&lt;p&gt;举例，如何检测VC(ViewController)是不是内存泄露？&lt;/p&gt;
&lt;p&gt;平常的思路可以使用dealloc方法，打印一下是否造成了内存泄露，但为了以后不想在dealloc方法写太多，可以写一个工具类实现。&lt;/p&gt;
&lt;p&gt;如果想要检测ViewController内存有没有泄露，就要Hook生命周期函数。在离开VC时调用ViewDidDisAppear，可以向ViewDidDisAppear延迟发送一个消息，如果当前消息的处理者为nil，则什么都不会发生，反之有对象，发送消息时就会响应。而我们并不想改变原ViewDidDisAppear的内部逻辑，所以我们想到了分类Category。下面就是思路图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1305302/201902/1305302-20190226172521334-1300734498.jpg&quot; alt=&quot;&quot; width=&quot;540&quot; height=&quot;143&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个代码逻辑也是腾讯使用memoryLeak第三方内存泄露的原理。&lt;/p&gt;
&lt;p&gt;首先我们需要创建一个分类，基于UIViewController，新建分类UIViewController+LGLeaks&lt;/p&gt;
&lt;p&gt;下面是分类实现代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#import&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UIViewController+LGLeaks.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;#import&lt;/span&gt; &amp;lt;objc/runtime.h&amp;gt;

&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *LGVCPOPFLAG = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LGVCPOPFLAG&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;@implementation&lt;/span&gt;&lt;span&gt; UIViewController (LGLeaks)

&lt;/span&gt;+ (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)load{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; dispatch_once_t onceToken;
    dispatch_once(&lt;/span&gt;&amp;amp;onceToken, ^&lt;span&gt;{
        [self lg_methodExchangeWithOriginSEL:@selector(viewWillAppear:) currentSEL:@selector(lg_viewWillAppear:)];
        [self lg_methodExchangeWithOriginSEL:@selector(viewDidDisappear:) currentSEL:@selector(lg_viewDidDisAppear:)];
    });
}

&lt;/span&gt;+ (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)lg_methodExchangeWithOriginSEL:(SEL)originSEL currentSEL:(SEL)currentSEL{
    Method originMethod &lt;/span&gt;= class_getInstanceMethod([self &lt;span&gt;class&lt;/span&gt;&lt;span&gt;], originSEL);
    Method currentMethod &lt;/span&gt;= class_getInstanceMethod([self &lt;span&gt;class&lt;/span&gt;&lt;span&gt;], currentSEL);
    method_exchangeImplementations(originMethod, currentMethod);
}

&lt;/span&gt;- (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)lg_viewWillAppear:(BOOL)animate{
    [self lg_viewWillAppear:animate];
    &lt;/span&gt;&lt;span&gt;//
&lt;/span&gt;&lt;span&gt;    objc_setAssociatedObject(self, LGVCPOPFLAG, @(NO), OBJC_ASSOCIATION_ASSIGN);
}

&lt;/span&gt;- (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)lg_viewDidDisAppear:(BOOL)animate{
    [self lg_viewDidDisAppear:animate];
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; ([objc_getAssociatedObject(self, LGVCPOPFLAG) boolValue]) {
        [self lg_WillDelloc];
    }
}

&lt;/span&gt;- (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)lg_WillDelloc{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;给 nil 对象发消息 ---
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;pop -- 回收内存&lt;/span&gt;
    __weak &lt;span&gt;typeof&lt;/span&gt;(self) weakSelf =&lt;span&gt; self;
    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&lt;span&gt;{
        __strong &lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;(self) strongSelf =&lt;span&gt; weakSelf;
        NSLog(&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;lg_NotDelloc : %@&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,NSStringFromClass([strongSelf &lt;span&gt;class&lt;/span&gt;&lt;span&gt;]));
    });
}

&lt;/span&gt;&lt;span&gt;@end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们在导航栏控制器下进行传值LGVCPOPFLAG&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#import&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UINavigationController+LGLeaks.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;#import&lt;/span&gt; &amp;lt;objc/runtime.h&amp;gt;

&lt;span&gt;@implementation&lt;/span&gt;&lt;span&gt; UINavigationController (LGLeaks)

&lt;/span&gt;+ (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)load{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; dispatch_once_t onceToken;
    dispatch_once(&lt;/span&gt;&amp;amp;onceToken, ^&lt;span&gt;{
        Method originMethod &lt;/span&gt;= class_getInstanceMethod([self &lt;span&gt;class&lt;/span&gt;&lt;span&gt;], @selector(popViewControllerAnimated:));
        Method currentMethod &lt;/span&gt;= class_getInstanceMethod([self &lt;span&gt;class&lt;/span&gt;&lt;span&gt;], @selector(lg_popViewControllerAnimated:));
        method_exchangeImplementations(originMethod, currentMethod);
    });
}

&lt;/span&gt;- (UIViewController *&lt;span&gt;)lg_popViewControllerAnimated:(BOOL)animated{
    UIViewController &lt;/span&gt;*popViewController =&lt;span&gt; [self lg_popViewControllerAnimated:animated];
    &lt;/span&gt;&lt;span&gt;extern&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;LGVCPOPFLAG;
    objc_setAssociatedObject(popViewController, LGVCPOPFLAG, @(YES), OBJC_ASSOCIATION_ASSIGN);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; popViewController;
}

&lt;/span&gt;&lt;span&gt;@end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上检测VC内存是否泄漏demo已上传到github。&lt;/p&gt;
&lt;p&gt;Demo：&lt;a href=&quot;https://github.com/zxy1829760/iOS-CustomLeakTest&quot; target=&quot;_blank&quot;&gt;https://github.com/zxy1829760/iOS-CustomLeakTest&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;3.2 &lt;strong&gt;TableView优化&lt;/strong&gt;&lt;/h2&gt;
&lt;h3&gt;3.2.1 TableView为什么会出现卡顿？&lt;/h3&gt;
&lt;p&gt;1.cellForRowAtIndexPath：方法中处理了很多的业务&lt;/p&gt;
&lt;p&gt;2.tableViewCell的subView层级太复杂，其中做了很多的透明处理&lt;/p&gt;
&lt;p&gt;cell的高度动态变化的时候计算方式不对&lt;/p&gt;
&lt;h3&gt;3.2.2 TableView优化&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1&lt;/span&gt;.&lt;/strong&gt;提前计算好并缓存好高度(布局)，因为heightForRowAtIndexPath是最频繁调用的方法。&lt;/p&gt;
&lt;p&gt;对于cell高度的计算，我们分为两种cell，一种是动态高度的cell，还有一种是定高的cell。&lt;/p&gt;
&lt;p&gt;1）对于定高的cell，我们应该采用这种方式：&lt;/p&gt;
&lt;div class=&quot;page&quot; title=&quot;Page 59&quot;&gt;
&lt;div class=&quot;section&quot;&gt;
&lt;div class=&quot;layoutArea&quot; readability=&quot;31&quot;&gt;
&lt;div class=&quot;column&quot; readability=&quot;63.5&quot;&gt;
&lt;p&gt;self.tableView.rowHeight = 66;&lt;/p&gt;
&lt;p&gt;此方法指定了tableView所有的cell高度都是66，对于tableView默认的cell高度是rowHeight=44，所以经常看到一个空的tableView会显示成那样。我们不要去是实现tableView:heightForRowAtIndexPath:，因为这样会多次调用，不用这种方式以节省不必要的开销和计算。&lt;/p&gt;
&lt;p&gt;2）动态高度的cell&lt;/p&gt;
&lt;p&gt;需要实现-(CGFloat)tableView:(UITableView *)tableViewheightForRowAtIndexPath:(NSIndexPath *)indexPath&lt;/p&gt;
&lt;p&gt;这个代理实现之后，上面rowHeight的设置就会变为无效，我们就需要提高cell高度计算效率，以此来节省时间。&lt;/p&gt;
&lt;p&gt;下面是定义高度：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;新建一个继承于UITableViewCell的子类&lt;/li&gt;
&lt;li&gt;重写initWithStyle：reuseIdentifier：的方法&lt;/li&gt;
&lt;li&gt;添加所有需要显示的子控件（不需要设置子控件的数据和frame，其中子控件要添加到contentView中）&lt;/li&gt;
&lt;li&gt;进行子控件一次性的属性设置&lt;/li&gt;
&lt;li&gt;提供两个模型：数据模型：存放文字数据/图片数据；frame模型：存放所有子控件的frame/cell的高度/存放数据模型&lt;/li&gt;
&lt;li&gt;然后cell拥有一个frame模型（不直接拥有数据模型）&lt;/li&gt;
&lt;li&gt;最后重写frame模型属性的setter方法，然后在方法中直接赋值和frame&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如果是自定义高度，下面是自定义高度的原理：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;因为heightForRow比cellForRow方法是先调用，创建frame模型保存的高度，实现自定义高度的cell。&lt;/li&gt;
&lt;li&gt;设置最大尺寸，为了更好地展示尺寸。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;2&lt;/span&gt;.UITableViewCell的重用机制。&lt;/p&gt;
&lt;p&gt;UITableView只会创建一个屏幕或者一个屏幕多点的大的UITableViewCell，其它的都是从中取出来重用的。每当UITableViewCell的cell滑出屏幕的时候，就会放到一个缓冲池中，当要准备显示某一个Cell时，会先去缓冲池中取（根据reuseIndetifier）。如果有，就直接从缓冲池取出来；反之，就会创建，将创建好的再次放入缓冲池以便下次再取，这样做就会极大的减少了内存开销。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3&lt;/span&gt;.TableView渲染&lt;/p&gt;
&lt;p&gt;为保证TableView滚动的流畅，当我们快速滚动时，cell必须被快速的渲染出来，这就要求cell的渲染速度必须要快。如何提高cell渲染速度？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;有图像的时候，预渲染图片，在bitmao context应该先画一遍，导出为UIImage对象，然后再绘制到屏幕中去，就会大大的提高渲染的速度。&lt;/li&gt;
&lt;li&gt;我们不要使用透明的背景，将opaque值设置为Yes，背景色尽量不要使用clearColor，也不要使用阴影渐变效果。&lt;/li&gt;
&lt;li&gt;可以使用CPU渲染，也可以在drawRect方法中自定义绘制。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;4&lt;/span&gt;.减少视图数目&lt;/p&gt;
&lt;p&gt;尽量在TableViewCell中少添加过多的视图，这样会导致渲染速度变慢，消耗过大的资源。&lt;/p&gt;
&lt;p&gt;5.减少多余的绘制&lt;/p&gt;
&lt;p&gt;在drawRect方法中，rect是绘制的区域，在rect之外的区域不需要绘制，否则会消耗资源。&lt;/p&gt;
&lt;p&gt;6. 不要给cell动态的添加subView&lt;/p&gt;
&lt;p&gt;我们在初始化Cell的时候可以将所有需要展示的子控件添加完之后，然后根据需要来设置hide属性设置显示和隐藏起来。&lt;/p&gt;
&lt;p&gt;7.异步UI，坚决不要阻塞主线程&lt;/p&gt;
&lt;p&gt;8.滑动时可以按需加载对应的内容&lt;/p&gt;
&lt;p&gt;举例：目标行和当前行相差超过了指定行数，只需要在目标滚动范围的前后指定3行加载。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
-(&lt;span&gt;void&lt;/span&gt;)scrollViewWillEndDragging:(UIScrollView *&lt;span&gt;)scrollViewwithVelocity:(CGPoint)v
elocitytargetContentOffset:(inoutCGPoint &lt;/span&gt;*&lt;span&gt;)targetContentOffset{
    NSIndexPath &lt;/span&gt;*ip=[selfindexPathForRowAtPoint:CGPointMake(&lt;span&gt;0&lt;/span&gt;,targetContentOffset-
&amp;gt;&lt;span&gt;y)];
    NSIndexPath &lt;/span&gt;*cip=&lt;span&gt;[[selfindexPathsForVisibleRows]firstObject];
    NSIntegerskipCount&lt;/span&gt;=&lt;span&gt;8&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(labs(cip.row-ip.row)&amp;gt;&lt;span&gt;skipCount){
        NSArray &lt;/span&gt;*temp=[selfindexPathsForRowsInRect:CGRectMake(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,targetContentOffse
t&lt;/span&gt;-&amp;gt;&lt;span&gt;y,self.width,self.height)];
        NSMutableArray &lt;/span&gt;*arr=&lt;span&gt;[NSMutableArrayarrayWithArray:temp];
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(velocity.y&amp;lt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;){
:&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]];
:&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]];
:&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]];
}
}
NSIndexPath &lt;/span&gt;*indexPath=&lt;span&gt;[templastObject];
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(indexPath.row+&lt;span&gt;33&lt;/span&gt;&lt;span&gt;){
    [arraddObject:[NSIndexPathindexPathForRow:indexPath.row&lt;/span&gt;-&lt;span&gt;3inSection
    [arraddObject:[NSIndexPathindexPathForRow:indexPath.row&lt;/span&gt;-&lt;span&gt;2inSection
    [arraddObject:[NSIndexPathindexPathForRow:indexPath.row&lt;/span&gt;-&lt;span&gt;1inSection
        [needLoadArraddObjectsFromArray:arr];
    }
}&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;page&quot; title=&quot;Page 61&quot;&gt;
&lt;div class=&quot;section&quot;&gt;
&lt;div class=&quot;layoutArea&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;column&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
if(needLoadArr.count&amp;gt;0&amp;amp;&amp;amp;[needLoadArrindexOfObject:indexPath]==NSNotFound){
    [cellclear];
&lt;/pre&gt;
&lt;p&gt;return;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;滚动很快时，只加载目标范围内的cell，这就是按需加载。&lt;/p&gt;
&lt;p&gt;9.离屏渲染的问题&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;图层的设置遮罩(layer.mask)&lt;/li&gt;
&lt;li&gt;图层的masksToBounds，以及ClipsToBounds属性设为ture&lt;/li&gt;
&lt;li&gt;图层设置阴影&lt;/li&gt;
&lt;li&gt;图层设置边角问题,cornerRadius&lt;/li&gt;
&lt;li&gt;使用CGContext在drawRect：方法也会导致离屛渲染。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;针对这个问题，下面是有一些优化：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;圆角优化：可以使用贝塞尔曲线&lt;/li&gt;
&lt;li&gt;对于shadow优化：我们可以设置shadowPath来优化，大幅度提高性能。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
mageView.layer.shadowColor=&lt;span&gt;[UIColorgrayColor].CGColor;
imageView.layer.shadowOpacity&lt;/span&gt;=&lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;;
imageView.layer.shadowRadius&lt;/span&gt;=&lt;span&gt;2.0&lt;/span&gt;&lt;span&gt;;
UIBezierPath &lt;/span&gt;*path=&lt;span&gt;[UIBezierPathbezierPathWithRect:imageView.frame];
imageView.layer.shadowPath&lt;/span&gt;=path.CGPath;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;需要圆角效果，可以使用中间透明图片蒙上去&lt;/li&gt;
&lt;li&gt;可以使用Core Animation工具来检测离屏渲染。可以通过Xcode-&amp;gt;Open Develeper Tools-&amp;gt;Instruments找到&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1305302/201902/1305302-20190227001333002-124140370.png&quot; alt=&quot;&quot; width=&quot;455&quot; height=&quot;191&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Core Animation工具用来检测性能，提供了FPS值，也提供了几个参数值来展示渲染性能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1305302/201902/1305302-20190227001533904-105856249.png&quot; alt=&quot;&quot; width=&quot;323&quot; height=&quot;390&quot;/&gt;􏱤􏶫􏱀下面我们说一下每个选项的功能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Color Blended Layers：这个选项勾选，出现效果中如果显示红色就是代表透明的，绿色代表不透明的。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;page&quot; title=&quot;Page 63&quot;&gt;
&lt;div class=&quot;section&quot;&gt;
&lt;div class=&quot;layoutArea&quot;&gt;
&lt;div class=&quot;column&quot;&gt;
&lt;ul&gt;&lt;li&gt;Color Hits Green and Misses Red：红色是代表没有复用离屏渲染的缓存，绿色是表示复用了缓存，作为开发，我们是需要复用的。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;page&quot; title=&quot;Page 64&quot;&gt;
&lt;div class=&quot;section&quot;&gt;
&lt;div class=&quot;layoutArea&quot;&gt;
&lt;div class=&quot;column&quot;&gt;
&lt;ul&gt;&lt;li&gt;Color Copied Images：当图片颜色格式GPU不支持时，Core Animation会拷贝数据让CPU进行转化。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;page&quot; title=&quot;Page 64&quot;&gt;
&lt;div class=&quot;section&quot;&gt;
&lt;div class=&quot;layoutArea&quot;&gt;
&lt;div class=&quot;column&quot;&gt;
&lt;ul&gt;&lt;li&gt;Color Immediately：如果勾选上，默认是每毫秒10次的频率更新图层调试的颜色。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;page&quot; title=&quot;Page 64&quot;&gt;
&lt;div class=&quot;section&quot;&gt;
&lt;div class=&quot;layoutArea&quot;&gt;
&lt;div class=&quot;column&quot;&gt;
&lt;ul&gt;&lt;li&gt;Color Misaligned Images：如果勾选此项，图片需要缩放时就会标记为黄色，没有像素对齐时会标记为紫色。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;page&quot; title=&quot;Page 64&quot;&gt;
&lt;div class=&quot;section&quot;&gt;
&lt;div class=&quot;layoutArea&quot;&gt;
&lt;div class=&quot;column&quot;&gt;
&lt;ul&gt;&lt;li&gt;Color Offscreen-Rendered Yellow：勾选上是用来检测离屏渲染。如果显示有黄色，代表有离屛渲染，还是要结合&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;page&quot; title=&quot;Page 64&quot;&gt;
&lt;div class=&quot;section&quot;&gt;
&lt;div class=&quot;layoutArea&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;column&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;　　　Color Hits Green and Misses Red来看，看是否已经开复用了缓存。&lt;/p&gt;
&lt;div class=&quot;page&quot; title=&quot;Page 64&quot;&gt;
&lt;div class=&quot;section&quot;&gt;
&lt;div class=&quot;layoutArea&quot; readability=&quot;8.5&quot;&gt;
&lt;div class=&quot;column&quot; readability=&quot;12&quot;&gt;
&lt;ul&gt;&lt;li&gt;Color OpenGL Fast Path Blue：此选项对使用OpenGL的图层才有用。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上面就是UITableView的优化方案，可能大家还有其它的方法，欢迎分享，可以博客下面留言。&lt;/p&gt;

&lt;p&gt;以上就是本人关于iOS性能优化方面的方案，总结出来了一篇博客，希望对大家有所帮助，现在已经晚上1点啦，哈哈，希望大家看完的同时，可以点赞一下哈！祝大家好梦！！！&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Tue, 26 Feb 2019 16:33:00 +0000</pubDate>
<dc:creator>国孩</dc:creator>
<og:description>大家在面试一些B轮以上的公司，很多面试大佬都会问怎么优化tableView或者iOS程序如何优化等。本篇博客将讲述iOS性能优化，围绕以下问题讲述： 一、内存 二、Runloop 三、界面 下面我们一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/guohai-stronger/p/10430106.html</dc:identifier>
</item>
<item>
<title>使用C#编写自己的代码生成器，附代码讲解(一) - 江湖逍遥</title>
<link>http://www.cnblogs.com/xu-yi/p/10441062.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xu-yi/p/10441062.html</guid>
<description>&lt;p&gt;使用过代码生成器的开发人员应该知道，通过代码生成器生成项目的代码，可以大大的减少重复编码的时间，提供项目开发的效率，将自己从繁杂重复的代码中解放出来。现在网络上也有很多的开源的代码生成器或者使用比较广泛的代码生成器，如动软代码生成器相信不少开发人员使用过。有时候在线的代码生成器生成的代码未必百分之百符合我们的心意，符合项目的需要，此时我们可以考虑自己使用C#编写一套自己的代码生成器软件，可以按照自己指定的规则生成相应的代码文件以及目录。博主在工作过程中接触以及开发过2类代码生成器，一类是WinForm窗体程序的代码生成器，开发者可以安装到自己的电脑上。另一类是Web版本的代码生成器，整个生成器的界面是个HTML网页，可以单独部署成一个网站站点，Web代码生成器有个优点就是你不需要在自己电脑上安装软件，只要电脑能联网，即可通过浏览器访问到代码生成器页面进行操作。&lt;/p&gt;
&lt;p&gt;首先来阐述下代码生成器制作的几个大的步骤流程：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）分析项目代码结构：&lt;/strong&gt;此步比较关键，是制作开发过程中最基础的部分。通过分析项目代码的结构，得出每个类的共同点或者相似点，这些共同点和相似点即可抽象出来作为一个定式。如分析实体类Model结构、DAL数据层结构以及含有的公用类似方法、BLL业务逻辑层的结构以及公用类似方法、View数据展示层相同类似代码等。&lt;/p&gt;
&lt;p&gt;举个例子：假设你项目代码中的实体类Model的结构都是如下这种，那你在生成实体类的.CS类文件就得按下面方式的方式生成一个私有字段，然后对应一个共有属性的方式。在DAL层和BLL层的代码类似，如DAL层必须含有一个根据主键Id的查询函数，则你在生成实体类对应DAL层的时候自动生成该查询函数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
Public class Teacher

{

     Private string _Name;

    Public  string Name

   {

        get { return _Name}

        set {_Name=value;}

   }

}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（2）&lt;strong&gt;设计项目实体类图，并分析相应的数据流操作：&lt;/strong&gt;根据步骤一的分析，设计出相应的项目实体类图，并且画出对应的数据流向图，帮助你的代码编写。&lt;/p&gt;
&lt;p&gt;（3）&lt;strong&gt;数据库层面操作：&lt;/strong&gt;连接数据库，并且能够自动展示出数据库中的所有表Table以及视图View等数据库对象，支持开发者在选择对应数据表的时候，程序自动查询出该表含有的所有字段信息等。同时建议考虑支持多表SQL语句操作。&lt;/p&gt;
&lt;p&gt;（4）&lt;strong&gt;操作界面设计层面考虑：&lt;/strong&gt;根据上述几个步骤的分析，结合我们最后要实现的效果，设计出界面操作图。如博主当初在设计Web版本的代码生成器的时候，当选择对应的数据表后，需要添加该表对应的页面的Title信息，表的字段分别对应数据展示列表的哪一列，该列是否需要设置格式化函数等（如设置数据表中的字段Name最终展示在HTML前端界面的列表列【姓名】列中）。&lt;/p&gt;
&lt;p&gt;（5）&lt;strong&gt;代码的生成以及保存：&lt;/strong&gt;根据第一步分析出来的结果，结合后面几部的操作，使用C#代码自动生成对应的代码格式，并将该代码格式的字符串保存到相应的文件中，如.CS为后缀的实体类文件、.cshtml为后缀的展示层View文件等。在生成代码保存文件的时候，建议生成对应的文件夹目录，这样方便在生成代码后直接将文件夹拷贝到对应的项目中即可，省去了自己新建文件的流程。&lt;/p&gt;
&lt;p&gt;（6）&lt;strong&gt;Web版本代码生成器建议最后做一个代码文件打包压缩下载功能。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;鉴于代码生成器的整个流程比较繁琐复杂，针对这套的实现，将分文章章节来记录，此篇文章优先记录如何从数据库中获取所有的表对象、视图对象，以及选择相应的数据表后读取对应表的所有字段信息。&lt;/p&gt;
&lt;p&gt;需要获取数据库的表对象、视图对象以及表中的字段，需要从数据库中的系统表中查询。&lt;/p&gt;
&lt;p&gt;（1）获取选中数据库中的用户表，可以用以下几种方式都可以：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
       Select name from sys.tables;

       Select name from sys.objects where type='U';

      Select name from sysobjects where type='U';

      Select table_name FROM InFormAtion_Schema.tables;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这里稍微做下解释：sys.tables是sqlserver2005版本中新增一个目录视图，它存储了当前数据库中的所有表信息。sys.objects和sysobjects都代表系统对象表。&lt;/p&gt;
&lt;p&gt;其中type的类型有多种，分别代表不同的含义：U=用户表、S=系统表、V=视图、FN=标量函数、TF=表函数、P=存储过程、TR=触发器、D=默认值或者Default约束、PK=主键约束、F=外键约束、UQ=&lt;em&gt;UNIQUE &lt;/em&gt;唯一约束。&lt;/p&gt;
&lt;p&gt;（2）获取选中数据库中的视图View，可以用以下几种方式都可以：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
SELECT * FROM INFORMATION_SCHEMA.VIEWS；

SELECT * FROM sysobjects where type='V';

SELECT * FROM sys.objects where type='V';
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（3）获取选中的数据表中的所有字段信息以及字段的类型&lt;/p&gt;
&lt;p&gt;查找出对应的字段类型后在生成实体类的时候就可以自动生成属性的对应的C#类型，如nvarchar、varchar、ntext等类型对应C#中的String类型。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
//查询表Product下面的所有字段信息
SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = 'Product' 
//查询视图V_Product下面的所有字段信息
SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = 'V_Product' 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;使用C#开发代码生成器的流程暂时先记录到这，后续的相关设计流程等将在下一篇的文章中记录。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最后附上博主的个人技术站点，里面也发布了不少技术知识点文章，包含服务器运维等知识：&lt;span&gt;&lt;a href=&quot;http://www.50bit.cn&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;IT技术小趣屋&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 26 Feb 2019 16:14:00 +0000</pubDate>
<dc:creator>江湖逍遥</dc:creator>
<og:description>使用过代码生成器的开发人员应该知道，通过代码生成器生成项目的代码，可以大大的减少重复编码的时间，提供项目开发的效率，将自己从繁杂重复的代码中解放出来。现在网络上也有很多的开源的代码生成器或者使用比较广</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xu-yi/p/10441062.html</dc:identifier>
</item>
<item>
<title>netty源码解解析(4.0)-14 Channel NIO实现:读取数据 - 自带buff</title>
<link>http://www.cnblogs.com/brandonli/p/10278285.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/brandonli/p/10278285.html</guid>
<description>&lt;p&gt;　　 本章分析Nio Channel的数据读取功能的实现。&lt;/p&gt;
&lt;p&gt;　　Channel读取数据需要Channel和ChannelHandler配合使用，netty设计数据读取功能包括三个要素：Channel, EventLoop和ChannelHandler。Channel有个read方法，这个方法不会直接读取数据，它的作用是通知持有当前channel的eventLoop可以从这个这个channel读取数据了，这个方法被调用之后eventLoop会在channel有数据可读的时候从channel读出数据然后把数据放在channelRead事件中交给ChannelInboundHandler的channelRead方法处理，当eventLoop发现channel中暂时没时间可读会触发一个channelReadComplete事件。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;read: Nio Channel通知eventLoop开始读数据&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　channel read方法的调用栈:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;io.netty.channel.AbstractChannel#read
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;io.netty.channel.DefaultChannelPipeline#read
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;io.netty.channel.AbstractChannelHandlerContext#read
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;io.netty.channel.AbstractChannelHandlerContext#invokeRead
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;io.netty.channel.DefaultChannelPipeline.HeadContext#read
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;io.netty.channel.AbstractChannel.AbstractUnsafe#beginRead
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; io.netty.channel.nio.AbstractNioChannel#doBeginRead
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 　　调用channel的read的方法，会触发read事件，通过pipeline调用AbstractChannel unsafe的beginRead方法，这个方法的语义是通知eventLoop可以从channel读数据了，但他没有实现具体功能，把具体功能留给doBeginRead实现。doBeginRead在AbstractChannel中定义，它是一个抽象方法。AbstractNioChannel实现了这个方法:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; doBeginRead() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Channel.read() or ChannelHandlerContext.read() was called&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (inputShutdown) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;final&lt;/span&gt; SelectionKey selectionKey = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.selectionKey;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;selectionKey.isValid()) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     readPending = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; interestOps =&lt;span&gt; selectionKey.interestOps();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; ((interestOps &amp;amp; readInterestOp) == 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;selectionKey.interestOps(interestOps | readInterestOp);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里的doBeginRead实现，只有第17行是核心代码：把readInterestOps保存是的read操作标志添加到SelectableChannel的SelectionKey中。这里的readInterestOps是一个类的属性，在AbstractNioChannel中，它没有明确的定义，只有一个抽象的定义:NIO中的一个可以可以当成read操作的的标志。在NIO中可以当成read的有SelectionKey.OP_READ和SelectionKey.OP_ACCEPT。readInterestOps在AbstractNioChannel的构造方法中使用传入的参数初始化，子类就可以根据需要确定interestOps的具体含义。&lt;/p&gt;
&lt;p&gt;　　设置好beginRead之后，NioEventLoop就可以使用Selector得到检测到channel上的read事件了，下面是NioEventLoop中处理read事件的代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;io.netty.channel.nio.NioEventLoop#processSelectedKey(java.nio.channels.SelectionKey, io.netty.channel.nio.AbstractNioChannel)&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; ((readyOps &amp;amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != 0 || readyOps == 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    unsafe.read();
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里调用了unsafe的read的方法，在Channel的Unsafe中并没有定义这个方法，它在io.netty.channel.nio.AbstractNioChannel.NioUnsafe中定义，在io.netty.channel.nio.AbstractNioMessageChannel.NioMessageUnsafe和io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe中有两个不同的实现。这两个实现的区别是：NioMessageUnsafe.read是把从channel中读出的数据转换成Object, NioByteUnsafe.read是从channel中读出byte数据流。下面来详解分析这两种实现。&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;AbstractNioChannel.NioUnsafe.read实现：从channel读取数据&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　netty在NIO Channel的设计上，把读数据设计成独立的抽象层。之所以这样设计有两个方面的原因:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在NIO中，三中不同类型的Channel读取的数据类型是不一样的，NioServerSocketChannel读出的是一个新建的NioSockeChannel, NioSocketChannel读出的byte数据流，NioDatagramChannel读出是数据报。&lt;/li&gt;
&lt;li&gt;NIO三种Channel都运行在非阻塞模式下，相比于阻塞模式，非阻塞模式下读数据要处理的问题要复杂的多。使用Selector和非阻塞模式被动地读取数据，需要处理连接断开和socket异常，由于Selector使用的是边缘触发模式，一次read调用务必要把已经在socket recvbuffer中的数据全部读出来，否则可以导致数据丢失或数据接收不及时。把read独立出来处理读取数据的复杂性，代码结构会比较清晰。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　　接下来开始详细分析NioUnsafe read方法的两种不同的实现。　&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;io.netty.channel.nio.AbstractNioMessageChannel.NioMessageUnsafe.read实现: 从channel中读出Object&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　这个实现是主要功能是调用doReadMessages方法，从channel中读出Object消息，具体的类型这里没有限制，doReadMessages是一个抽象方法，留给子类实现, 下面是read方法的实现:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;io.netty.channel.nio.AbstractNioMessageChannel.NioMessageUnsafe&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; read() {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;assert&lt;/span&gt;&lt;span&gt; eventLoop().inEventLoop();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;final&lt;/span&gt; ChannelConfig config =&lt;span&gt; config();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!config.isAutoRead() &amp;amp;&amp;amp; !&lt;span&gt;isReadPending()) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ChannelConfig.setAutoRead(false) was called in the meantime&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        removeReadOp();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; maxMessagesPerRead =&lt;span&gt; config.getMaxMessagesPerRead();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;final&lt;/span&gt; ChannelPipeline pipeline =&lt;span&gt; pipeline();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;boolean&lt;/span&gt; closed = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     Throwable exception = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                 &lt;span&gt;int&lt;/span&gt; localRead =&lt;span&gt; doReadMessages(readBuf);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (localRead == 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (localRead &amp;lt; 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                     closed = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; stop reading and remove op&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;config.isAutoRead()) {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (readBuf.size() &amp;gt;=&lt;span&gt; maxMessagesPerRead) {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable t) {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;             exception =&lt;span&gt; t;
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;         setReadPending(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; size =&lt;span&gt; readBuf.size();
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; size; i ++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;            pipeline.fireChannelRead(readBuf.get(i));
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; 
&lt;span&gt;46&lt;/span&gt; &lt;span&gt;        readBuf.clear();
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;        pipeline.fireChannelReadComplete();
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; 
&lt;span&gt;49&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (exception != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;             closed =&lt;span&gt; closeOnReadError(exception);
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; 
&lt;span&gt;52&lt;/span&gt; &lt;span&gt;            pipeline.fireExceptionCaught(exception);
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; 
&lt;span&gt;55&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (closed) {
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isOpen()) {
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; &lt;span&gt;                close(voidPromise());
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;     } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Check if there is a readPending which was not processed yet.
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; This could be for two reasons:
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; * The user called Channel.read() or ChannelHandlerContext.read() in channelRead(...) method
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; * The user called Channel.read() or ChannelHandlerContext.read() in channelReadComplete(...) method
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;
&lt;span&gt;66&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; See &lt;/span&gt;&lt;span&gt;https://github.com/netty/netty/issues/2254&lt;/span&gt;
&lt;span&gt;67&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!config.isAutoRead() &amp;amp;&amp;amp; !&lt;span&gt;isReadPending()) {
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt; &lt;span&gt;            removeReadOp();
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　 第12行，得到一次循环读取消息的最大数量maxMessagesPerRead，这个配置的默认值因不同的channel类型而不同，io.netty.channel.ChannelConfig提供了setMaxMessagesPerRead方法设置这个配置的值。调节这个值的大小可以影响I/O操作在eventLoop线程分配的执行时间，它的值越大，I/O操作站的时间越大。&lt;/p&gt;
&lt;p&gt;　　18-36行，使用doReadMessages读取消息，并把消息放到readBuf中，readBuf是List&amp;lt;Object&amp;gt;类型。20,21行，没有可读的数据结束循环。23-25行，socket已经关闭。33，34行，readBuf中的消息数量已经超过限制，跳出循环。&lt;/p&gt;
&lt;p&gt;　　41-47行，对readBuf中的每一个消息触发一次channelRead事件，然后清空readBuf, 触发channelReadComplete事件。&lt;/p&gt;
&lt;p&gt;　　49-53行，处理异常。&lt;/p&gt;
&lt;p&gt;　　55-59行，处理channel正常关闭。&lt;/p&gt;
&lt;p&gt;　　doReadMessages方法有两个实现。一个是io.netty.channel.socket.nio.NioServerSocketChannel#doReadMessages，这个实现中读出的消息是NioSocketChannel。另一个是io.netty.channel.socket.nio.NioDatagramChannel#doReadMessages，这个实现中读出的消息时DatagramPacket。&lt;/p&gt;
&lt;p&gt;　　io.netty.channel.socket.nio.NioServerSocketChannel#doReadMessages实现代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; doReadMessages(List&amp;lt;Object&amp;gt; buf) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     SocketChannel ch =&lt;span&gt; SocketUtils.accept(javaChannel());
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (ch != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             buf.add(&lt;span&gt;new&lt;/span&gt; NioSocketChannel(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, ch));
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable t) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         logger.warn(&quot;Failed to create a new channel from an accepted socket.&quot;&lt;span&gt;, t);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            ch.close();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable t2) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             logger.warn(&quot;Failed to close a socket.&quot;&lt;span&gt;, t2);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　第3行, 使用accept方法得到一个新的SocketChannel。&lt;/p&gt;
&lt;p&gt;　　7,8行，使用新的SocketChannel创建NioSocketChannel，并把它放到buf中。&lt;/p&gt;
&lt;p&gt;　　11-20行，出现异常，关闭这个socket, 最后返回0.&lt;/p&gt;

&lt;p&gt;　　io.netty.channel.socket.nio.NioDatagramChannel#doReadMessages实现代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; doReadMessages(List&amp;lt;Object&amp;gt; buf) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     DatagramChannel ch =&lt;span&gt; javaChannel();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     DatagramChannelConfig config =&lt;span&gt; config();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     RecvByteBufAllocator.Handle allocHandle = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.allocHandle;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (allocHandle == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.allocHandle = allocHandle =&lt;span&gt; config.getRecvByteBufAllocator().newHandle();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     ByteBuf data =&lt;span&gt; allocHandle.allocate(config.getAllocator());
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;boolean&lt;/span&gt; free = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         ByteBuffer nioData =&lt;span&gt; data.internalNioBuffer(data.writerIndex(), data.writableBytes());
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; pos =&lt;span&gt; nioData.position();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         InetSocketAddress remoteAddress =&lt;span&gt; (InetSocketAddress) ch.receive(nioData);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (remoteAddress == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; readBytes = nioData.position() -&lt;span&gt; pos;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         data.writerIndex(data.writerIndex() +&lt;span&gt; readBytes);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        allocHandle.record(readBytes);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;         buf.add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; DatagramPacket(data, localAddress(), remoteAddress));
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         free = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable cause) {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;        PlatformDependent.throwException(cause);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; -1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     }  &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (free) {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;            data.release();
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　　4-12行，得到接收数据的缓冲区data。&lt;/p&gt;
&lt;p&gt;　　   13-21行，从socket收到一个数据包，这个数据报包含两部分: data中的二进制数据和发送端的地址remoteAddress(第14行)。然后设置data中的数据长度。&lt;/p&gt;
&lt;p&gt;　　　23-25行，把数据报转换成DatagramPacket类型放到buf中返回。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe#read实现：从channel中读byte流&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　这个实现的主要功能是调用doReadBytes读取byte流。doReadBytes是一个抽象方法，留给子类实现。下面是这个read的实现。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; read() {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;final&lt;/span&gt; ChannelConfig config =&lt;span&gt; config();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!config.isAutoRead() &amp;amp;&amp;amp; !&lt;span&gt;isReadPending()) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ChannelConfig.setAutoRead(false) was called in the meantime&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        removeReadOp();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;final&lt;/span&gt; ChannelPipeline pipeline =&lt;span&gt; pipeline();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;final&lt;/span&gt; ByteBufAllocator allocator =&lt;span&gt; config.getAllocator();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; maxMessagesPerRead =&lt;span&gt; config.getMaxMessagesPerRead();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     RecvByteBufAllocator.Handle allocHandle = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.allocHandle;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (allocHandle == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.allocHandle = allocHandle =&lt;span&gt; config.getRecvByteBufAllocator().newHandle();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;     ByteBuf byteBuf = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; messages = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;boolean&lt;/span&gt; close = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; totalReadAmount = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;boolean&lt;/span&gt; readPendingReset = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;do&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             byteBuf =&lt;span&gt; allocHandle.allocate(allocator);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; writable =&lt;span&gt; byteBuf.writableBytes();
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; localReadAmount =&lt;span&gt; doReadBytes(byteBuf);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (localReadAmount &amp;lt;= 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; not was read release the buffer&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;                byteBuf.release();
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                 byteBuf = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;                 close = localReadAmount &amp;lt; 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (close) {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; There is nothing left to read as we received an EOF.&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;                     setReadPending(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;readPendingReset) {
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;                 readPendingReset = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;                 setReadPending(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;            pipeline.fireChannelRead(byteBuf);
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;             byteBuf = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; 
&lt;span&gt;46&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (totalReadAmount &amp;gt;= Integer.MAX_VALUE -&lt;span&gt; localReadAmount) {
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Avoid overflow.&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt;                 totalReadAmount =&lt;span&gt; Integer.MAX_VALUE;
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; 
&lt;span&gt;52&lt;/span&gt;             totalReadAmount +=&lt;span&gt; localReadAmount;
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; 
&lt;span&gt;54&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; stop reading&lt;/span&gt;
&lt;span&gt;55&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;config.isAutoRead()) {
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; 
&lt;span&gt;59&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (localReadAmount &amp;lt;&lt;span&gt; writable) {
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Read less than what the buffer can hold,
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; which might mean we drained the recv buffer completely.&lt;/span&gt;
&lt;span&gt;62&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;         } &lt;span&gt;while&lt;/span&gt; (++ messages &amp;lt;&lt;span&gt; maxMessagesPerRead);
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt; 
&lt;span&gt;66&lt;/span&gt; &lt;span&gt;        pipeline.fireChannelReadComplete();
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt; &lt;span&gt;        allocHandle.record(totalReadAmount);
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt; 
&lt;span&gt;69&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (close) {
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; &lt;span&gt;            closeOnRead(pipeline);
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt;             close = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt;     } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable t) {
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt; &lt;span&gt;        handleReadException(pipeline, byteBuf, t, close);
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt;     } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Check if there is a readPending which was not processed yet.
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; This could be for two reasons:
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; * The user called Channel.read() or ChannelHandlerContext.read() in channelRead(...) method
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; * The user called Channel.read() or ChannelHandlerContext.read() in channelReadComplete(...) method
&lt;/span&gt;&lt;span&gt;80&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;
&lt;span&gt;81&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; See &lt;/span&gt;&lt;span&gt;https://github.com/netty/netty/issues/2254&lt;/span&gt;
&lt;span&gt;82&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!config.isAutoRead() &amp;amp;&amp;amp; !&lt;span&gt;isReadPending()) {
&lt;/span&gt;&lt;span&gt;83&lt;/span&gt; &lt;span&gt;            removeReadOp();
&lt;/span&gt;&lt;span&gt;84&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;85&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;86&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　10-16行，得到一个接受缓冲区的分配器和分配器的的专用handle。这两个东西的功能是高效的创建大量的接接收数据缓冲区，具体原理和实现会在后面buffer相关章节中详细分析，这里暂时略过。&lt;/p&gt;
&lt;p&gt;　　24-64行，这是一个使用doReadBytes读取数据并触发channelRead事件的循环。25-27行，得到一个接受数据的缓冲区，然后从socket中读取数据。28-38行，没有数据可读了，或socket已经断开了。43行，正确收到了数据，触发channelRead事件。59-62行，读出的数据小于缓冲区的长度，表示没有socket中暂时没有数据可读了。 64行，读取次数大于上限配置，跳出。&lt;/p&gt;
&lt;p&gt;　　66行，读循环完成，触发channelReadComplete事件。&lt;/p&gt;
&lt;p&gt;　　69-72, 处理socket正常关闭。&lt;/p&gt;
&lt;p&gt;　　74,83行，处理其他异常。&lt;/p&gt;
&lt;p&gt;　　doReadBytes只有一个实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;io.netty.channel.socket.nio.NioSocketChannel#doWriteBytes&lt;/span&gt;
&lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; doWriteBytes(ByteBuf buf) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
    &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; expectedWrittenBytes =&lt;span&gt; buf.readableBytes();
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; buf.readBytes(javaChannel(), expectedWrittenBytes);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这个实现非常简单，使用ByteBuf的能力从SocketChannel中读取byte流。&lt;/p&gt;



</description>
<pubDate>Tue, 26 Feb 2019 16:08:00 +0000</pubDate>
<dc:creator>自带buff</dc:creator>
<og:description>本章分析Nio Channel的数据读取功能的实现。 Channel读取数据需要Channel和ChannelHandler配合使用，netty设计数据读取功能包括三个要素：Channel, Even</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/brandonli/p/10278285.html</dc:identifier>
</item>
<item>
<title>HoloLens开发手记- SpectatorView for iOS编译指南 - msp的昌伟哥哥</title>
<link>http://www.cnblogs.com/mantgh/p/10441085.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mantgh/p/10441085.html</guid>
<description>&lt;p&gt;微软前两天发布了HoloLens 2，给MR开发带来了新的希望，全面的性能和显示效果提升，让人期待。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/599309/201902/599309-20190226235808557-1773546051.png&quot; alt=&quot;&quot; width=&quot;663&quot; height=&quot;274&quot;/&gt;&lt;/p&gt;

&lt;p&gt;去年推出的预览版的全新SpectatorView for iOS解决方案，这允许我们直接使用带ARKit的iOS设备实现HoloLens MR场景的共享，以及第三方观察视角，对于演示也是非常方便好用的。效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/599309/201902/599309-20190226231343328-1541352154.png&quot; alt=&quot;&quot; width=&quot;684&quot; height=&quot;417&quot;/&gt;&lt;/p&gt;

&lt;p&gt;本篇文章主要介绍一下怎么将配置好的SpectatorView Unity项目部署到iPhone上。&lt;/p&gt;

&lt;h3&gt;配置Unity场景&lt;/h3&gt;
&lt;hr/&gt;&lt;h3&gt; &lt;/h3&gt;
&lt;p&gt;打开已配置好的Unity3D场景，选中SpectatorView对象，在右侧窗口中Platform Switcher选项卡下，点击IPhone按钮。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/599309/201902/599309-20190226232047061-2017862241.png&quot; alt=&quot;&quot; width=&quot;958&quot; height=&quot;528&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这步操作会自动配置Unity项目和场景到合适的配置&lt;/p&gt;

&lt;h3&gt;导出iOS项目&lt;/h3&gt;
&lt;hr/&gt;&lt;h3&gt; &lt;/h3&gt;
&lt;p&gt;打开Unity的Build Settings窗体，将目标导出平台设为iOS&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/599309/201902/599309-20190226232501180-647278390.png&quot; alt=&quot;&quot; width=&quot;951&quot; height=&quot;890&quot;/&gt;&lt;/p&gt;

&lt;p&gt;下一步设置Player Settings，主要是将Other Setting选项卡下的 target SDK、target minimum iOS version分别设置为Device SDK和11.0+，然后正常Build，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/599309/201902/599309-20190226233005561-1461267330.png&quot; alt=&quot;&quot; width=&quot;381&quot; height=&quot;536&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;注意：&lt;/span&gt;这里target SDK的设置很重要，因为Unity默认使用Simulator SDK，这会导致导出的iOS项目编译时不能直接部署到iPhone真机上。这是因为simulator sdk的编译架构是x86，而不是device SDK使用的ARM64架构。&lt;/p&gt;
&lt;p&gt;因为我们使用到ARKit这个从iOS 11才出现的功能，所以我们的目标iOS版本因该是至少11.0.&lt;/p&gt;

&lt;h3&gt;部署iOS项目&lt;/h3&gt;
&lt;hr/&gt;&lt;h3&gt; &lt;/h3&gt;
&lt;p&gt;打开我们导出成功的iOS项目目录，双击Unity-iPhone.xcodeproj文件使用XCode打开。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/599309/201902/599309-20190226233728786-1038803590.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在打开的项目窗口中，点击项目，在右边的配置界面中，选则你的苹果开发者账户，使得可以对真机部署&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/599309/201902/599309-20190226234037856-460537364.png&quot; alt=&quot;&quot; width=&quot;940&quot; height=&quot;547&quot;/&gt;&lt;/p&gt;

&lt;p&gt;如果你没有苹果开发者账户，请先去苹果开发者中心注册申请：&lt;a href=&quot;https://developer.apple.com&quot; target=&quot;_blank&quot;&gt;https://developer.apple.com&lt;/a&gt;,要注意的一点是，付费需要使用双币信用卡，单标的全币卡不能用，太坑了。&lt;/p&gt;
&lt;p&gt;最后在左上角设备列表中选中你的iPhone，然后直接点击运行按钮部署&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/599309/201902/599309-20190226234531977-1622511686.png&quot; alt=&quot;&quot; width=&quot;778&quot; height=&quot;290&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;运行效果&lt;/h3&gt;
&lt;hr/&gt;&lt;h3&gt; &lt;/h3&gt;
&lt;p&gt;下面是我实际使用HoloLens和iPhone X真机运行的效果&lt;/p&gt;


&lt;p&gt; btw，我的HoloLens系列将恢复更新啦～&lt;/p&gt;
</description>
<pubDate>Tue, 26 Feb 2019 16:00:00 +0000</pubDate>
<dc:creator>msp的昌伟哥哥</dc:creator>
<og:description>微软前两天发布了HoloLens 2，给MR开发带来了新的希望，全面的性能和显示效果提升，让人期待。 去年推出的预览版的全新SpectatorView for iOS解决方案，这允许我们直接使用带AR</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mantgh/p/10441085.html</dc:identifier>
</item>
<item>
<title>Asp.Net Core中HttpClient的使用方式 - 微笑刺客D</title>
<link>http://www.cnblogs.com/CKExp/p/10426170.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CKExp/p/10426170.html</guid>
<description>&lt;p&gt;&lt;strong&gt;　　在.Net Core应用开发中，调用第三方接口也是常有的事情，HttpClient使用人数、使用频率算是最高的一种了，在.Net Core中，HttpClient的使用方式随着版本的升级也发生了一些变化，本次就讲解一下Asp.Net Core2.1前后使用的两种方式。&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;一、原先HttpClient使用方式&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt; 　　一般来讲，喜欢要用的时候才会选择去获取资源，因此，当在有需求时才会用HttpClient去调用资源，便会使用如下这种方式或其它方式获取资源。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;do something...&lt;/span&gt;
&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; httpClient = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpClient())
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; requestUri = &lt;span&gt;&quot;http://aspnetcore.online/api/resource/getresource&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; httpResponseMessage = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; httpClient.GetAsync(requestUri);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;do something...&lt;/span&gt;

    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Ok(httpResponseMessage);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　如果可以正常访问目标地址的话，则会返回相应的资源信息。　　&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201902/1133736-20190226195417684-2118419899.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　又如Post方式提交并返回相应的内容，都是可以直接使用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;do something...&lt;/span&gt;
&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; httpClient = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpClient())
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; requestUri = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://aspnetcore.online/api/resource/postresource&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; httpResponseMessage = &lt;span&gt;await&lt;/span&gt; httpClient.PostAsJsonAsync(requestUri,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;星城软件&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;do something...&lt;/span&gt;

    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Ok(httpResponseMessage);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　但是这种情况下会出现一个严重的问题，在不停的调用情形下，tcp连接数会被耗尽，虽然使用using方式调用HttpClient并在退出前调用Dispose()方法将HttpClient释放了，但是tcp连接仍然处于保持状态，在240s后才会自动断开，这里就涉及到一个连接状态了，首先得理解下http的工作原理，http协议是建立在tcp协议基础之上，当浏览器需要从服务器获取数据的时候，会发出一次http请求。http会通过tcp建立起一个到服务器的连接通道，当本次请求需要的数据完毕后，http会立即将tcp连接断开，这个过程是很短的。所以http连接是一种短连接，是一种无状态的连接。但是tcp的连接只要我们不通过代码把连接关闭，这个连接就会在客户端和服务端的进程中一直存在，相关状态数据会一直保存着，直到无响应状态持续了默认关闭时间后自动断开。&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201902/1133736-20190226220159423-1246659262.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　当短期请求量过大时，这就可能导致了&quot;套接字资源耗尽异常&quot;，因此，为了解决这个问题，想到不释放HttpClient，将它作为单例一直使用，实现单例方式有很多种。&lt;/p&gt;
&lt;p&gt;　　如使用单例模式，只生成一个HttpClient&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; HttpClient _httpClient = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; HttpClient CreateHttpClient()
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (_httpClient == &lt;span&gt;null&lt;/span&gt;) _httpClient = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpClient();
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; _httpClient;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　亦或是在初始化时完成单例注入，创建一个IHttpClient接口，及相应的实现StandardHttpClient，实现类种加入HttpClient属性，在实现类构造函数中完成初始化后便可直接使用该实现类完成资源请求工作。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在startup中完成单例注入&lt;/span&gt;
services.AddSingleton&amp;lt;IHttpClient, StandardHttpClient&amp;gt;&lt;span&gt;();

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IHttpClient
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;do something&lt;/span&gt;
&lt;span&gt;}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; StandardHttpClient : IHttpClient
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; HttpClient _client;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; StandardHttpClient()
    {
        _client &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpClient();
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;do something...&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;虽然这样解决了&quot;套接字资源耗尽异常&quot;，但是又带来了新的问题，熬不过DNS生存时间（TTL），&lt;/span&gt;当主机 DNS 更新时，又可能产生异常，提示无法解析主机名称，因为单例HttpClient不会随着主机DNS更新而更新，&lt;a href=&quot;https://github.com/dotnet/corefx/issues/11224&quot; target=&quot;_blank&quot;&gt;Singleton HttpClient doesn't respect DNS changes&lt;/a&gt;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
An error occurred &lt;span&gt;while&lt;/span&gt; sending the request. Couldn&lt;span&gt;'&lt;/span&gt;&lt;span&gt;t resolve host name An error occurred while sending the request. Couldn&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;t resolve host name
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;二、现有HttpClient使用方式&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt; 　　在.Net Core2.1后，微软引入了&lt;a href=&quot;https://github.com/aspnet/HttpClientFactory&quot; target=&quot;_blank&quot;&gt;HttpClientFactory&lt;/a&gt;彻底解决这个问题，工厂模式的职责是负责创建对象，这个类主要负责创建HttpClient实例&lt;/p&gt;
&lt;p&gt;　　首先在StartUp中注册，可能会提示安装这个Nuget包&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 services.AddHttpClient();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;　　&lt;/em&gt;该方法内部实现过程可以浏览：&lt;a href=&quot;https://www.cnblogs.com/lizhizhang/p/9502862.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/lizhizhang/p/9502862.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　其次，在需要使用时，使用构造函数注入即可&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[Route(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api/[controller]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
[ApiController]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HttpClientController : ControllerBase
{
    IHttpClientFactory _httpClientFactory;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; HttpClientController(IHttpClientFactory httpClientFactory)
    {
        _httpClientFactory &lt;/span&gt;=&lt;span&gt; httpClientFactory;
    }

    [HttpGet]
    [Route(nameof(Index))]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;IActionResult&amp;gt;&lt;span&gt; Index()
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; client =&lt;span&gt; _httpClientFactory.CreateClient();
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result = &lt;span&gt;await&lt;/span&gt; client.GetAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://aspnetcore.online/api/resource/getresource&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Ok(result);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　具体实现原理简述为：HttpClientFactory内部管理着一个连接句柄池，对每一个HttpClient使用一个句柄进行跟踪管理，当该实例使用完毕后，句柄仍然控制资源释放，在短期大量处理时，可以将这部分句柄完成对不同实例的跟踪管理，使得句柄，也就是相应的套接字生命周期延长，对套接字完成了复用。&lt;/p&gt;

&lt;p&gt;　近日，长沙.NET技术社区已经建立，微信群：长沙.NET社区一群已满，如有需要来长沙发展或是回归长沙可以进入二群，加一下我来邀请进去。各大城市间的人才拉锯战进行中，不管是什么行业，什么职业，长沙都应&lt;strong&gt;留住人才，培养人才&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201902/1133736-20190226225124875-649517983.png&quot; alt=&quot;&quot; width=&quot;149&quot; height=&quot;149&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;lang-java prettyprint prettyprinted&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;str&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;lit&quot;&gt;&lt;strong&gt;&lt;span class=&quot;hljs-number&quot;&gt;2019-02&lt;span class=&quot;hljs-number&quot;&gt;-&lt;span class=&quot;hljs-number&quot;&gt;26,望技术有成后能回来看见自己的脚步&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 26 Feb 2019 15:00:00 +0000</pubDate>
<dc:creator>微笑刺客D</dc:creator>
<og:description>在.Net Core应用开发中，调用第三方接口也是常有的事情，HttpClient使用人数、使用频率算是最高的一种了，在.Net Core中，HttpClient的使用方式随着版本的升级也发生了一些变</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CKExp/p/10426170.html</dc:identifier>
</item>
<item>
<title>在BOSS直聘上和面试官的一问一答 - 夏天里的Jasmine</title>
<link>http://www.cnblogs.com/qianjinyan/p/10440326.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qianjinyan/p/10440326.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;岗位描述：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;信用卡核心系统功能测试，负责测试计划制定，测试设计，测试执行，测试进度掌控，自动化工具建设等工作。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;有责任心，执行力强，工作认真细致，逻辑思维强&lt;/span&gt;&lt;br/&gt;&lt;span&gt;熟悉linux，oracle或者IBM大型机操作&lt;/span&gt;&lt;br/&gt;&lt;span&gt;精通功能测试技术，有5年以上相关经验&lt;/span&gt;&lt;br/&gt;&lt;span&gt;掌握后端系统性能测试或自动化测试技术&lt;/span&gt;&lt;br/&gt;&lt;span&gt;有分布式架构测试经验，大型系统迁移项目经验，或者熟悉信用卡业务&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;手抖点了下申请岗位，面试官，这个项目里的测试经理在BOSS直聘上直接发问了：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1. 做过测试环境监控吗？比如常驻进程，日志等？有没有用过什么监控工具？&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;常见命令行工具&lt;/span&gt;&lt;br/&gt;&lt;span&gt;top&lt;/span&gt;&lt;br/&gt;&lt;span&gt;vmstat 是用来实时查看内存使用情况,反映的情况比用top直观一些&lt;/span&gt;&lt;br/&gt;&lt;span&gt;vmstat 2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;free&lt;/span&gt;&lt;br/&gt;&lt;span&gt;下面是对内存查看free命令输出内容的解释：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;total：总计物理内存的大小。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;used：已使用多大。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;free：可用有多少。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Shared：多个进程共享的内存总额。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Buffers/cached：磁盘缓存的大小。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1064427/201902/1064427-20190226213019017-867412938.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1064427/201902/1064427-20190226213033465-1280965238.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1064427/201902/1064427-20190226213047733-554218223.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;2. 是手工部署还是自动化部署？&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;第一次搭环境都是手工，诸如配置tomcat，jboss，nginx，memcached，后期提交代码了，Jenkins自动部署&lt;/span&gt;&lt;br/&gt;&lt;span&gt;自动化部署脚本谁建的？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;我啊， 就一个build文件啊&lt;/span&gt;&lt;br/&gt;&lt;span&gt;中间件只用过tomcat还有别的吗？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;tomcat和Jboss&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Weblogic和websphere用过么？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;没有用过，但我学起来很快&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.接口自动化做的都是http的么？&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;大部分是，有一些是soap协议的，也是用jmeter开发的自动化脚本&lt;/span&gt;&lt;br/&gt;&lt;span&gt;都是用jmeter做的自动化和性能测试吗？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;对的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.场景过程中有涉及字符转码的场景么？&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;字符串做md5加密算不算？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;算的，请求和应答都加密解密是么？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;请求中一般有字段需要做md5加密，应答中的解密一般没有，md5解密一般都不成功啊&lt;/span&gt;&lt;br/&gt;&lt;span&gt;URL解码还可能些，但目前公司几乎用不到&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;5.那Jmeter里你用什么方法实现这些处理？&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;比如MD5加密需求是32位大写加密，Jmeter可以连接数据库，每一个http请求添加一个预置数据处理，编写了一个存储过程，调用该proc可以算出md5加密的值&lt;/span&gt;&lt;br/&gt;&lt;span&gt;我也编写了一个md5加密的java方法导出成jar，可以添加到Jmeter中的beanshell中计算md5的值&lt;/span&gt;&lt;br/&gt;&lt;span&gt;不过常用第一种，自动化总是要处理数据的，连DB最方便&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;6.那对应答的预处理和断言是怎么做的？&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;断言是根据需求文档，写死了的；比如场景规定返回000，E01等等；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;如果要处理应答呢？比如场景，响应报文以ebcdic编码，变长报文根据前16个字节决定断言字段的位置，断言预期结果是utf8编码&lt;/span&gt;&lt;br/&gt;&lt;span&gt;用正则表达式提取出需要转码的字段，再用后置处理器或者beanshell对值转码后，之后进行判断&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;7. 对登录态和session的处理有怎样的经验？&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;cookie是在本地的&lt;/span&gt;&lt;br/&gt;&lt;span&gt;session保存在服务器上，服务器关了你登陆就断了；或者时间久了session会过期；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;现在有的前后端分离系统，喜欢用token验证登录态。将token作为header或者请求体，去调用接口。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;登录之后有些系统要求必须带有token才能访问，session什么的建立连接之后获得sessionID塞入request head中&lt;/span&gt;&lt;br/&gt;&lt;span&gt;token怎么获取？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;也是正则表达式提取&lt;/span&gt;&lt;br/&gt;&lt;span&gt;用两个交易串行获取么？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;http请求后，请求中会有token：xxx aaa。正则表达式直接获取token：（.+）aaa&lt;/span&gt;&lt;br/&gt;&lt;span&gt;带着token去请求？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;带着token去请求，还需要再获取token吗？为什么要获取，是要刷新token吗？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;8. 集群服务器在垂直分片的数据库用多线程做批量数据DML要关注什么？&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;这个不会。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1064427/201902/1064427-20190226213101763-1168178182.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;9. Oracle的adg备份技术了解么？&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;会应用在读写分离上&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;10. 读写分离和缓存数据存取的测试有经验吗？&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;缓存数据存取，接触过memcache数据库&lt;/span&gt;&lt;br/&gt;&lt;span&gt;有什么关注点？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;当时主要是测试双机场景，两台机器同时在工作，不是主备模式。测试之后发现高并发的时候，客户端给到一个请求，服务器端可能响应两次；如若是多台服务器，有可能一个请求，服务器多次响应。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;还有什么吗，比如数据一致性？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;一致性方式测试发现是满足的。一般查看下稳定向，容错性，一致性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;11. 你刚说的双机测试，用的是什么负载均衡策略？&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;当时只关注了ip用的是nonsticky模式，负载均衡策略可能是轮询法吧。当时是it搭的环境。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;大概是nginx通过设置weight轮询权值吧。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;12. 灾备的测试有经验么？&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;很少涉及，压力测试下会遇到响应延迟场景。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;还有双机热备，人为shutdown一台机器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;13.你个人的职业规划是怎样的？&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;想做一个有技术含量的测试工程师，从用户角度，到系统安全角度都能深入了解；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;还有俗的，有技术含量了才能涨工资。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;个人感觉测试比较有创新性，目前没有问题的系统不能保证线上没有问题，只有测试懂的多了，想的全了，才能降低风险，比开发有意思，比运维也有意思。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;14.有带过团队么？&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;哈哈哈，只带过实习生，后来公司还没要。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;15.有没有想过怎么把你的技能、想法传递给别人？&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;培训，目前写写博客园博客，一来自己记录，二来同行共勉。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;有专业人士带，学一门技术，二周就差不多了。&lt;/span&gt;&lt;/p&gt;





&lt;p&gt;&lt;span&gt;==========================================================================================================&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;上次你见到我的时候&lt;/span&gt;&lt;br/&gt;&lt;span&gt;我还能嘟起小嘴&lt;/span&gt;&lt;br/&gt;&lt;span&gt;像小鱼吐吐气&lt;/span&gt;&lt;br/&gt;&lt;span&gt;再次相见的时候&lt;/span&gt;&lt;br/&gt;&lt;span&gt;我只能浅浅笑&lt;/span&gt;&lt;br/&gt;&lt;span&gt;用口罩拉远彼此的距离&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 26 Feb 2019 13:39:00 +0000</pubDate>
<dc:creator>夏天里的Jasmine</dc:creator>
<og:description>岗位描述： 信用卡核心系统功能测试，负责测试计划制定，测试设计，测试执行，测试进度掌控，自动化工具建设等工作。有责任心，执行力强，工作认真细致，逻辑思维强熟悉linux，oracle或者IBM大型机操</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qianjinyan/p/10440326.html</dc:identifier>
</item>
<item>
<title>js中对象和对象创建方法 - Yellow_ice</title>
<link>http://www.cnblogs.com/Yellow-ice/p/10439386.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Yellow-ice/p/10439386.html</guid>
<description>&lt;p&gt;&lt;span&gt;这一次我们来说一说在JavaScript中经常会用到的一个复杂基本类型，对象，先从对象的属性讲起，再讲对象的创建方法，基本涵盖了创建对象的各种方法，大家一起学习呀~&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、对象&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    要掌握对象的使用及继承，首先当然需要先理解它，接下来，将会对对象的属性类型进行一个整理&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;strong&gt;1、什么是对象&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;    &lt;/strong&gt;对象其实是无序属性的集合，其属性可以包含基本值，对象或者函数，比如像下面这个例子就是一个person对象啦&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; person =&lt;span&gt; {
    name: &lt;/span&gt;&quot;NIcholas&quot;&lt;span&gt;,
    age: &lt;/span&gt;29&lt;span&gt;,
    sayName: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    &lt;span&gt;从上面的例子我们可以看到，对象可以是由属性和其相应的值构成，对象中可以包含函数，也可以包含其它对象&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;    &lt;strong&gt;2、属性类型&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;    &lt;/strong&gt;在JavaScript中，其实有两种属性，包括数据属性和访问器属性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    （1）数据属性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    数据属性包含一个数据值的位置，在这个位置可以读取和写入值，一般来说，有4个描述其行为的特性：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    a、[[Configurable]]：表示能否通过delete删除属性从而重新定义属性，默认值为true&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    b、[[Enumerable]]：表示能否通过for-in循环返回属性，默认值为true&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    c、[[Writable]]：表示能否修改属性的值，默认值为true&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    d、[[Value]]：包含这个属性的数据值，默认值为undefined&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    一般来说，数据属性都有自己的默认值，那么如果我们要修改数据属性默认的特性，应该怎么办呢？这个时候就需要用到&lt;span&gt;Object,defineProperty()方法&lt;/span&gt;啦，这个方法接收三个参数：属性所在的对象，属性的名字和一个描述对象，来看下面的例子&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; person =&lt;span&gt; {};
Object.defineProperty(person, &lt;/span&gt;&quot;name&quot;&lt;span&gt;, {
    writable: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
    value: &lt;/span&gt;&quot;Nicholas&quot;&lt;span&gt;
});

console.log(person.name);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Nicholas&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; 重新赋值&lt;/span&gt;
person.name = &quot;Greg&quot;&lt;span&gt;;
console.log(person.name);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Nicholas&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    &lt;span&gt;从上面的例子我们可以看到，因为设置了person对象的name属性为不可修改，因此无论你在后面怎么修改person的name属性的值，name属性的值都不会发生改变&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    （2）访问器属性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    访问器属性不包含数据值，它们包含一对儿getter和setter函数，在读取访问器属性时，会调用getter函数，这个函数负责返回有效的值，在写入访问器属性时，会调用setter函数并传入新值，这个函数负责决定如何处理数据，访问器属性有以下4个特性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    a、[[Configurable]]：表示能否通过delete删除属性从而重新定义属性，默认值为true&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    b、[[Enumerable]]：表示能否通过for-in循环返回属性，默认值为true&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    c、[[Get]]：在读取属性时调用的函数，默认值为undefined&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    d、[[Set]]：在写入属性时调用的函数，默认值为undefined&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    访问器属性不能直接定义，必须调用&lt;span&gt;Object.definedProperty()&lt;/span&gt;来定义的，来看下面的例子&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; book =&lt;span&gt; {
    _year:&lt;/span&gt;2004&lt;span&gt;,
    edition:&lt;/span&gt;1&lt;span&gt;
}

Object.defineProperty(book, &lt;/span&gt;&quot;year&quot;&lt;span&gt;, {
    get: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;._year;
    },
    set: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(newValue) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._year =&lt;span&gt; newValue;
    }
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    &lt;span&gt;这里要说明一下，book对象中_year前面的&lt;span&gt;下划线是一种常用的记号，用于表示只能通过对象方法访问的属性&lt;/span&gt;，还有呀，大家不要小看了Object.definedProperty()这个方法，这个方法可是很强大呀，像&lt;span&gt;vue的双向数据绑定，其实就是用到了这个方法去实现&lt;/span&gt;的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    （3）读取属性的特性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    既然JavaScript有数据属性和访问器属性，那么我们怎样才能读取它们呀，这个时候就需要用到&lt;span&gt;Object.getOwnPropertyDescriptor()&lt;/span&gt;方法了，这个方法可以取得给定属性的描述符，接收两个参数，分别是属性所在的对象和要读取其描述符的属性名称&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、对象的创建&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    在了解了对象之后，接下来我们就需要说下怎么创建对象了，最简单的方法，当然就是使用前面说的对象字面量的方法去创建啦，但是如果我们需要创建好多个对象，用前面的方法就不行了，我们需要用到其它更加简便的方法，帮助我们创建出多个对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;strong&gt;1、工厂模式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;    &lt;/strong&gt;这种模式其实是一个设计模式，抽象了创建具体对象的过程，主要是通过在函数内部创建一个对象，为其添加属性和方法，并将对象返回，从而实现创建多个对象的目的，来看下面的例子&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; createPerson(name, age) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; o = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object();
    o.name &lt;/span&gt;=&lt;span&gt; name;
    o.age &lt;/span&gt;=&lt;span&gt; age;
    o.sayName &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name);
    };
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; o;
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; person1 = createPerson(&quot;Nicholas&quot;, 29&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; person2 = createPerson(&quot;Greg&quot;, 27);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    &lt;span&gt;优点：能够解决创建多个对象的问题，兼容各个浏览器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    缺点：没有解决对象识别的问题，不能知道一个对象的类型&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;    &lt;strong&gt;2、构造函数模式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    这种模式主要通过创建自定义的构造函数，从而定义自定义对象类型的属性和方法，来看下面例子&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Person(name, age) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sayName = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name);
    }
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; person1 = &lt;span&gt;new&lt;/span&gt; Person(&quot;Nicholas&quot;, 29&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; person2 = &lt;span&gt;new&lt;/span&gt; Person(&quot;Greg&quot;, 27);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    &lt;span&gt;这里要说明一下，&lt;span&gt;构造函数需要以一个大写字母开头，而非构造函数应该以一个小写字母开头&lt;/span&gt;，这个主要是为了区别构造函数和其它函数，构造函数其实本身也是函数，只是用来创建对象而已&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    其中，要创建Person的新实例，需要&lt;span&gt;使用new操作符，其实这里会经过4个步骤，首先，将会创建一个新对象，接着会将构造函数的作用域赋给新对象，this指向了这个对象，接着会执行构造函数中的代码，为这个新对象添加属性，最后会返回新对象&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    优点：可以创建多个对象，解决对象的识别问题&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    缺点：每个实例都会创建不同的function实例，而其实创建完成同样任务的function实例是很没有必要的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    这里还是要说明一下，对象类型的检测需要用到&lt;span&gt;instanceof操作符&lt;/span&gt;，比如像上面的例子可以用下面的方法检测&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
console.log(person1 &lt;span&gt;instanceof&lt;/span&gt; Person);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;  true&lt;/span&gt;
console.log(person2 &lt;span&gt;instanceof&lt;/span&gt; Person);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;  true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    &lt;span&gt;使用构造函数模式可以解决对象的识别问题，而这也是工厂模式无法办到的&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;    &lt;strong&gt;&lt;span&gt;3、原型模式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;   &lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 我们都知道，每个函数都有一个prototype属性，这个属性是一个指针，指向一个对象，而这个对象就是原型对象，包含了所有实例共享的属性和方法，如果我们要创建的对象需要共享属性和方法，就可以使用这种方法创建&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Person() {
}

Person.prototype.name &lt;/span&gt;= &quot;Nicholas&quot;&lt;span&gt;;
Person.prototype.age &lt;/span&gt;= 29&lt;span&gt;;
Person.prototype.sayName &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name);
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; person1 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Person();
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; person2 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Person();
person1.sayName();  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  Nicholas&lt;/span&gt;
person2.sayName();  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;  Nicholas&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    &lt;span&gt;优点：不用为构造函数传递参数，可以创建多个相同的对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    缺点：原型中的属性被很多实例共享，当属性为包含引用类型值的属性时，修改一个实例中属性的值，另一个实例中的属性的值也会改变&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;    &lt;strong&gt;4、组合使用构造函数模式和原型模式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;    &lt;/strong&gt;通过前面的分析，我们应该可以看到构造函数模式和原型模式的优点和缺点啦，构造函数可以创建多个不同属性值的对象，原型模式可以用于定义方法和共享的属性，我们可以将这两种模式结合起来，这种模式现在是使用最广泛的一种模式啦&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Person(name, age) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
}

Person.prototype &lt;/span&gt;=&lt;span&gt; {
    constructor: Person,
    sayName: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name);
    }
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; person1 = &lt;span&gt;new&lt;/span&gt; Person(&quot;Nicholas&quot;, 29&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; person2 = &lt;span&gt;new&lt;/span&gt; Person(&quot;Greg&quot;, 27&lt;span&gt;);

person1.sayName();  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  Nicholas&lt;/span&gt;
person2.sayName();  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;  Greg&lt;/span&gt;
person1.sayName === person2.sayName; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    &lt;span&gt;从上面的例子我们可以看到，使用这种模式创建对象，每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度地节省了内存，另外，这种混成模式还支持向构造函数传递参数，可谓是集两种模式之长&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;    &lt;strong&gt;5、动态原型模式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;   &lt;/strong&gt; 这种模式主要是将所有信息都封装在了构造函数里，因为在组合构造函数模式和原型模式中，构造函数和原型模式是独立的，有些开发人员会感到很困惑，因此，这种模式也是为了解决这个问题，通过在构造函数中初始化初始化原型，又保持了同时使用构造函数和原型的优点，换句话说，就是可以通过在构造函数中，检查某个应该存在的方法是否有效，来决定是否需要初始化原型&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Person(name, age) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;typeof&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.sayName != &quot;function&quot;&lt;span&gt;) {
        Person.prototype.sayName &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
            console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name);
        }
    }
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; person1 = &lt;span&gt;new&lt;/span&gt; Person(&quot;Nicholas&quot;, 29&lt;span&gt;);
person1.sayName();  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Nicholas&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;    &lt;span&gt;这里要说明一下，在if语句中的代码，只有在首次调用构造函数时才会执行，之后原型已经得到初始化，不需要再做什么修改了&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;    &lt;strong&gt;6、寄生构造函数模式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;    &lt;/strong&gt;这种模式其实和工厂模式很像，除了使用new操作符并把使用的包装函数叫做构造函数之外，和工厂模式可以说是一模一样的，这种模式的基本思想是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Person(name, age) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; o = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object();
    o.name &lt;/span&gt;=&lt;span&gt; name;
    o.age &lt;/span&gt;=&lt;span&gt; age;
    o.sayName &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name);
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; o;
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; person1 = &lt;span&gt;new&lt;/span&gt; Person(&quot;Nicholas&quot;, 29&lt;span&gt;);
person1.sayName();  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  Nicholas&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    &lt;span&gt;寄生构造函数模式和工厂模式真的是很像，那么既然有了工厂模式，为什么还要有寄生构造函数模式呢？其实&lt;span&gt;这个模式主要是用来给js原生的构造函数定义一些新的方法&lt;/span&gt;，我们可以看下面这个例子&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; SpecialArray() {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; values = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Array();
    values.push.apply(values, argumens);
    values.toPipedString &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.join(&quot;|&quot;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; values;
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; colors = &lt;span&gt;new&lt;/span&gt; SpecialArray(&quot;red&quot;,&quot;blue&quot;&lt;span&gt;);
console.log(colors.toPipedString());  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  red|blue&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    &lt;span&gt;从上面这个例子我们可以看到，我们在构造函数里面创建了一个新的数组，然后通过push方法初始化这个数组，并且又给数组的实例添加了一个toPipedString方法，并且将所创建的数组返回，因此呢，当我们通过new创建了SpecialArray实例时，其实就得到增加了新方法的数组实例啦，就可以在这个实例上使用我们添加的新的方法toPipedString&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;    &lt;strong&gt;7、稳妥构造函数模式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;    &lt;/strong&gt;在说这种模式之前，要先说一下稳妥对象，&lt;span&gt;稳妥对象就是指没有公共属性，而且其方法也不引用this的对象，稳妥对象最适合在一些安全的环境中，或者防止数据被其他应用程序改动时使用&lt;/span&gt;，稳妥构造函数模式遵循与寄生构造函数类似的模式，但是还是有下面的不同，&lt;span&gt;第一个是新创建的对象实例方法不引用this，第二个是不使用new操作符调用构造函数&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Person(name, age) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; o = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object();
    _name &lt;/span&gt;=&lt;span&gt; name;
    _age &lt;/span&gt;=&lt;span&gt; age;
    o.sayName &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; _name;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; o;
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; person1 = &lt;span&gt;new&lt;/span&gt; Person(&quot;Nicholas&quot;, 29&lt;span&gt;);
person1.sayName();  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  Nicholas&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    &lt;span&gt;在上面这个例子中，我们在构造函数中创建了一个对象后，可以继续添加一些私有的变量和函数，要修改这些私有的变量和函数，只能通过创建的对象的方法进行访问，这里在对象上创建的方法其实可以看作就是公有方法，比如说这里的_name和_age就是私有变量，而对象o的sayName方法就是访问私有变量的公有方法了，这里除了调用sayName()方法外，没有其它方法可以访问其数据成员&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;    8、es6中创建对象的方法&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;   &lt;/span&gt;&lt;/strong&gt; &lt;span&gt;最后要来说下es6中创建对象新增的方法啦，在es6中，引入了 Class（类）这个概念，作为对象的模板，通过&lt;code&gt;class&lt;/code&gt;关键字，可以定义类，基本上，ES6 的&lt;code&gt;class&lt;/code&gt;可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的&lt;code&gt;class&lt;/code&gt;写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class Person {
    constructor(name, age) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
    }
    sayName() {
        console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name);
    }
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; person1 = &lt;span&gt;new&lt;/span&gt; Person(&quot;Nicholas&quot;, 29&lt;span&gt;);
person1.sayName();  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  Nicholas&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    &lt;span&gt;上面这个例子其实就是组合构造函数模式和原型模式的改写，其中，constructor属性直接指向类本身，该方法会默认返回实例对象，在里面定义的属性和方法都是实例本身具有的方法，不是其它实例共享的，而像sayName方法就是定义在原型上的方法了，是所有实例一起共享的&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;    好啦，今天就介绍到这里了，不知道大家对对象和对象的创建是否有了一个比较详细的了解了呢&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;    &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;  &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;    &lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 26 Feb 2019 12:54:00 +0000</pubDate>
<dc:creator>Yellow_ice</dc:creator>
<og:description>这一次我们来说一说在JavaScript中经常会用到的一个复杂基本类型，对象，先从对象的属性讲起，再讲对象的创建方法，基本涵盖了创建对象的各种方法，大家一起学习呀~ 一、对象 要掌握对象的使用及继承，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Yellow-ice/p/10439386.html</dc:identifier>
</item>
<item>
<title>Docker应用：Docker-compose（容器编排） - 漂亮的猫</title>
<link>http://www.cnblogs.com/lanxiaoke/p/10439282.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lanxiaoke/p/10439282.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;阅读目录：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;前言：&lt;/h2&gt;
&lt;p&gt;　　昨天完成了Docker入门示例（&lt;span&gt;Docker应用：Hello World&lt;/span&gt;），示例只是粗略展示了单机应用在Docker中部署的大概流程；&lt;/p&gt;
&lt;p&gt;但是即使先不考虑大型项目关联的多个应用服务，单单只是单机应用部署来说，过程也是略为复杂。&lt;/p&gt;
&lt;p&gt;　　因为现在的软件公司开发、测试、部署基本上分开，甚至交由不同的人完成各个阶段的工作，如果软件部署要敲写大量的命令，&lt;/p&gt;
&lt;p&gt;那还是很容易出错；甚至有些公司只是运维人员、工程人员在部署，一旦出了问题，他们想找到原因基本很难。&lt;/p&gt;
&lt;p&gt;所以要求部署必须是接近傻瓜式的，所以有了容器编排技术。&lt;/p&gt;

&lt;h2&gt;一、遗留问题&lt;/h2&gt;
&lt;p&gt;　　昨天的示例是遗留有一些问题的，比如容器重启后IP地址变化，容器重启后应用相关的远程容器服务都将失效，这点是非常致命的。&lt;/p&gt;
&lt;p&gt;第二是网络通信问题，昨天的示例中Web调用Mysql是通过ip映射，出到容器外部在访问另外一个容器内部的数据，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; conn = &lt;span&gt;new&lt;/span&gt; MySqlConnection(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;server=&lt;strong&gt;&lt;span&gt;198.198.198.181&lt;/span&gt;&lt;/strong&gt;;User Id=root;password=mima2100;Database=mysql-db&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;198.198.198.181是我本地机器的局域网IP，由于这个IP，导致Web应用对Mysql容器有了硬耦合，得想办法去掉。&lt;/p&gt;

&lt;h2&gt;二、解决问题&lt;/h2&gt;
&lt;p&gt;1、其实也简单，在Dockerfile文件相同目录创建docker-compose.yml文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; version: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;services:
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;  web:
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;      build: .
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;      ports:
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;        - &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;8000:80&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;      depends_on:
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;        -&lt;span&gt; mysql
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;  mysql:
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    container_name: mysql_dc
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    environment:
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;       - MYSQL_ROOT_PASSWORD=&lt;span&gt;mima2100
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    image: mysql
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    ports:
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;       - &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;3306:3306&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、上边的docker-compose.yml文件格式，其他参数各自百度一下，意思就是创建2个应用：web、mysql&lt;/p&gt;
&lt;p&gt;2.1、web在本直接build（也有从镜像下载的方式），80端口映射到本地8000端口，依赖mysql&lt;/p&gt;
&lt;p&gt;2.2、mysql指定登录密码mima2100，容器3306端口映射到本地3306&lt;/p&gt;
&lt;p&gt;2.3、Mysql连接改成如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; Dapper;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Data;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; MySql.Data.MySqlClient;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; WebApp_HelloWorld.Controllers
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DBService
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;protected&lt;/span&gt;&lt;span&gt; IDbConnection conn;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; DBService()
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             conn = &lt;span&gt;new&lt;/span&gt; MySqlConnection(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;server=&lt;span&gt;&lt;strong&gt;mysql_dc&lt;/strong&gt;&lt;/span&gt;;User Id=root;password=mima2100;Database=mysql-db&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;T&amp;gt; Single&amp;lt;T&amp;gt;(&lt;span&gt;string&lt;/span&gt; sql, &lt;span&gt;object&lt;/span&gt; paramPairs = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;await&lt;/span&gt; conn.QuerySingleOrDefaultAsync&amp;lt;T&amp;gt;&lt;span&gt;(sql, paramPairs);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; Count(&lt;span&gt;string&lt;/span&gt; sql, &lt;span&gt;object&lt;/span&gt; paramPairs = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;await&lt;/span&gt; conn.QuerySingleOrDefaultAsync&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt;(sql, paramPairs);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;三、验证&lt;/h2&gt;
&lt;p&gt;1、验证一下docker-compose版本&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; docker-compose version
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/254672/201902/254672-20190226195359422-1414535603.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、定位到web目录，输入指令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; docker-compose up -d
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/254672/201902/254672-20190226194909572-158119402.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/254672/201902/254672-20190226195007619-1413217159.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;3、查看容器&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; docker ps -a
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/254672/201902/254672-20190226195842420-997735990.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到mysql与web都创建成功了，无报错。&lt;/p&gt;
&lt;p&gt;4、访问一下localhost:8000&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/254672/201902/254672-20190226195126559-1257134305.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;搞定。。&lt;/p&gt;

</description>
<pubDate>Tue, 26 Feb 2019 11:56:00 +0000</pubDate>
<dc:creator>漂亮的猫</dc:creator>
<og:description>阅读目录： Docker应用：Hello World Docker应用：Docker-compose（容器编排） 前言： 昨天完成了Docker入门示例（Docker应用：Hello World），示</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lanxiaoke/p/10439282.html</dc:identifier>
</item>
<item>
<title>KOA中间件的基本运作原理 - 大史不说话</title>
<link>http://www.cnblogs.com/dashnowords/p/10439605.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dashnowords/p/10439605.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354575/201902/1354575-20190226194955708-873816086.jpg&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;3.2041884816754&quot;&gt;
&lt;p&gt;示例代码托管在：&lt;a href=&quot;http://www.github.com/dashnowords/blogs&quot; class=&quot;uri&quot;&gt;http://www.github.com/dashnowords/blogs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;博客园地址：&lt;a href=&quot;https://www.cnblogs.com/dashnowords/p/10127926.html&quot;&gt;《大史住在大前端》原创博文目录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;华为云社区地址：&lt;a href=&quot;https://bbs.huaweicloud.com/blogs/8ae7e6420a4611e9bd5a7ca23e93a891&quot;&gt;【你要的前端打怪升级指南】&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在中间件系统的实现上，&lt;code&gt;KOA&lt;/code&gt;中间件通过&lt;code&gt;async/await&lt;/code&gt;来在不同中间件之间交换控制权，工作机制和&lt;strong&gt;栈&lt;/strong&gt;结构非常相似，建议结合&lt;a href=&quot;https://www.cnblogs.com/dashnowords/p/9683361.html&quot;&gt;《express中间件系统的基本实现》&lt;/a&gt;对比学习，两个框架所基于的语法特性有区别（&lt;code&gt;express&lt;/code&gt;使用&lt;code&gt;ES5&lt;/code&gt;的回调风格语法，&lt;code&gt;KOA&lt;/code&gt;使用&lt;code&gt;ES7&lt;/code&gt;的扁平式异步&lt;code&gt;async/await&lt;/code&gt;风格语法），但在框架基本原理上是很类似的，只是中间件写法和遍历机制稍有不同。&lt;/p&gt;
&lt;h2 id=&quot;一.-api层&quot;&gt;一. API层&lt;/h2&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;初始化方法&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;let middleware = new MiddleWare();&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;添加中间件函数的方法&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;//Fn为被添加的中间件,KOA中间件为async函数
middleware.use(Fn);&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;预处理中间件栈&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;//将存储于数组中的各个中间件组合为按照“先进后出”原则执行的中间件系统。
middleware.start = middleware.compose();&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;启动中间件队列&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;middleware.start(ctx);&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;二.-核心类的定义&quot;&gt;二. 核心类的定义&lt;/h2&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;/*
* KOA中间件框架的基本实现
*/

class MiddleWare {
    constructor(){
        this.queue = []
    }

    //添加中间件函数
    use(fn){
       this.queue.push(fn);
    }

    //合并中间件处理流，是一个高阶函数，调用一次后会生成真正需要的函数。
    compose(){
        return function (ctx, next) {
           let _this= this;
           let index = -1;
           return dispatch(0);
           
           /**
            * KOA中间件的工作的步进函数
            */
           function dispatch(i) {
             index = i;
             //依次取用数组中添加的中间件函数
             let fn = i === _this.queue.length ? next : _this.queue[i];
             if(!fn){
               return Promise.resolve();
             }
             
             try{
                 /*
                 *中间件函数的形式为 async fn(ctx, next),可以看到此处透传了ctx的引用，
                 *同时next是一个延迟执行中间件队列中下一个中间件的函数，也就是说如果在前
                 *一个中间件的函数体中调用 await next()，就会启动下一个中间件,实际执行
                 *的函数是dispatch(i+1)。
                 */
                 return Promise.resolve(fn(ctx,()=&amp;gt;{
                   return dispatch(i+1);
                 }));
             }catch(err){
                 return Promise.reject(err);
             }
           }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;三.-使用use方法添加中间件&quot;&gt;三. 使用use方法添加中间件&lt;/h2&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;//添加回调函数
middleware.use(async function(ctx, next){
  console.log('step 001');
  ctx.info = 'go through middleware1';
  await next();
  console.log('step 006');
});

middleware.use(async function(ctx, next){
  console.log('step 002');
  await next();
  console.log('step 005');
});

middleware.use(async function(ctx, next){
  console.log('step 003');
  await next();
  console.log('step 004');
});&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;四.-中间件实例&quot;&gt;四. 中间件实例&lt;/h2&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;//初始化
let middleware = new MiddleWare();

/*
...此处为添加中间件的代码
*/

middleware.start = middleware.compose();&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;五.-查看运行结果&quot;&gt;五. 查看运行结果&lt;/h2&gt;
&lt;p&gt;可以看到有错误发生和正常响应时的不同结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354575/201902/1354575-20190226195034819-1269481118.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;六.-在服务器端运行&quot;&gt;六. 在服务器端运行&lt;/h2&gt;
&lt;p&gt;用&lt;code&gt;node&lt;/code&gt;起一个web服务器那真是太随意了~&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;//启动http服务
http.createServer(function(req, res){
    console.log(req.url);
    let info = {};
    middleware.start(info);
    res.end(JSON.stringify(info));
}).listen(9527);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看一下效果(访问服务器时自定义消息就可以传至前台了)：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354575/201902/1354575-20190226195104487-883315086.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 26 Feb 2019 11:51:00 +0000</pubDate>
<dc:creator>大史不说话</dc:creator>
<og:description>示例代码托管在： 'http://www.github.com/dashnowords/blogs' 博客园地址： '《大史住在大前端》原创博文目录' 华为云社区地址： '【你要的前端打怪升级指南】'</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dashnowords/p/10439605.html</dc:identifier>
</item>
</channel>
</rss>