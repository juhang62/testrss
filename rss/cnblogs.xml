<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Spring Boot 修改静态资源一定要重启项目才会生效吗？未必！ - 江南一点雨</title>
<link>http://www.cnblogs.com/lenve/p/11325041.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lenve/p/11325041.html</guid>
<description>&lt;p&gt;Spring Boot 中的热部署相信大家都用过吧，只需要添加 &lt;code&gt;spring-boot-devtools&lt;/code&gt; 依赖就可以轻松实现热部署。Spring Boot 中热部署最最关键的原理就是两个不同的 classloader：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;base classloader&lt;/li&gt;
&lt;li&gt;restart classloader&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其中 base classloader 用来加载那些不会变化的类，例如各种第三方依赖，而 restart classloader 则用来加载那些会发生变化的类，例如你自己写的代码。Spring Boot 中热部署的原理就是当代码发生变化时，base classloader 不变，而 restart classloader 则会被废弃，被另一个新的 restart classloader 代替。在整个过程中，因为只重新加载了变化的类，所以启动速度要被重启快。&lt;/p&gt;
&lt;p&gt;但是有另外一个问题，就是静态资源文件！使用 devtools ，默认情况下当静态资源发生变化时，并不会触发项目重启。虽然我们可以通过配置解决这一问题，但是没有必要！因为静态资源文件发生变化后不需要编译，按理说保存后刷新下就可以访问到了。&lt;/p&gt;
&lt;p&gt;那么如何才能实现静态资源变化后，不编译就能自动刷新呢？ LiveReload 可以帮助我们实现这一功能！&lt;/p&gt;

&lt;p&gt;devtools 中默认嵌入了 LiveReload 服务器，利用 LiveReload 可以实现静态文件的热部署，LiveReload 可以在资源发生变化时自动触发浏览器更新，LiveReload 支持 Chrome、Firefox 以及 Safari 。以 Chrome 为例，在 Chrome 应用商店搜索 LiveReload ，结果如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/747810/201908/747810-20190809085836354-211788092.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;将第一个搜索结果添加到 Chrome 中，添加成功后，在 Chrome 右上角有一个 LiveReload 图标&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/747810/201908/747810-20190809085847031-720363630.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在浏览器中打开项目的页面，然后点击浏览器右上角的 LiveReload 按钮，打开 LiveReload 连接。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;LiveReload 是和浏览器选项卡绑定在一起的，在哪个选项卡中打开了 LiveReload，就在哪个选项卡中访问页面，这样才有效果。&lt;/p&gt;
&lt;p&gt;打开 LiveReload 之后，我们启动一个加了 devtools 依赖的 Spring Boot 项目：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-devtools&amp;lt;/artifactId&amp;gt;
    &amp;lt;scope&amp;gt;runtime&amp;lt;/scope&amp;gt;
    &amp;lt;optional&amp;gt;true&amp;lt;/optional&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时随便在 resources/static 目录下添加一个静态 html 页面，然后启动 Spring Boot 项目，在&lt;strong&gt;打开了 LiveReload 的选项卡中访问 html 页面&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;访问成功后，我们再去手动修改 html 页面代码，修改成功后，回到浏览器，不用做任何操作，就会发现浏览器自动刷新了，页面已经更新了。&lt;/p&gt;
&lt;p&gt;整个过程中，我的 Spring Boot 项目并没有重启。&lt;/p&gt;
&lt;p&gt;如果开发者安装并且启动了 LiveReload 插件，同时也添加了 devtools 依赖，但是却并不想当静态页面发生变化时浏览器自动刷新，那么可以在 application.properties 中添加如下代码进行配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;spring.devtools.livereload.enabled=false&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;建议开发者使用 LiveReload 策略而不是项目重启策略来实现静态资源的动态加载，因为项目重启所耗费时间一般来说要超过使用LiveReload 所耗费的时间。&lt;/p&gt;
&lt;p&gt;Firefox 也可以安装 LiveReload 插件，装好之后和 Chrome 用法基本一致，这里不再赘述。&lt;/p&gt;
&lt;p&gt;关注公众号【江南一点雨】，专注于 Spring Boot+微服务以及前后端分离等全栈技术，定期视频教程分享，关注后回复 Java ，领取松哥为你精心准备的 Java 干货！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/747810/201907/747810-20190710095647242-469154686.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 09 Aug 2019 00:59:00 +0000</pubDate>
<dc:creator>江南一点雨</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lenve/p/11325041.html</dc:identifier>
</item>
<item>
<title>什么是实时流式计算？ - 独孤风</title>
<link>http://www.cnblogs.com/tree1123/p/11325009.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tree1123/p/11325009.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1089984/201908/1089984-20190809084953784-1703301113.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;实时流式计算，也就是RealTime,Streaming,Analyse,在不同的领域有不同的定义,这里我们说的是大数据领域的实时流式计算。&lt;br/&gt;实时流式计算,或者是实时计算,流式计算,在大数据领域都是差不多的概念。那么，到底什么是实时流式计算呢？&lt;br/&gt;谷歌大神Tyler Akidau在《the-world-beyond-batch-streaming-101》一文中提到过实时流式计算的三个特征：&lt;br/&gt;1、无限数据&lt;br/&gt;2、无界数据处理&lt;br/&gt;3、低延迟&lt;/p&gt;
&lt;p&gt;无限数据指的是,一种不断增长的，基本上无限的数据集。这些通常被称为“流数据”，而与之相对的是有限的数据集。&lt;br/&gt;无界数据处理,一种持续的数据处理模式,能够通过处理引擎重复的去处理上面的无限数据，是能够突破有限数据处理引擎的瓶颈的。&lt;br/&gt;低延迟，延迟是多少并没有明确的定义。但我们都知道数据的价值将随着时间的流逝降低，时效性将是需要持续解决的问题。&lt;/p&gt;
&lt;p&gt;现在大数据应用比较火爆的领域，比如推荐系统在实践之初受技术所限，可能要一分钟，一小时，甚至更久对用户进行推荐，这远远不能满足需要，我们需要更快的完成对数据的处理，而不是进行离线的批处理。&lt;br/&gt;但是这种模型肯定会带来离线批处理所不存在的两个问题：正确性与时间。&lt;br/&gt;而这也正是实时流式计算的关键点：&lt;br/&gt;1、正确性 一旦正确性有了保证，可以匹敌批处理。&lt;br/&gt;2、时间推导工具 而一旦提供了时间推导的工具，变完全超过了批处理。&lt;/p&gt;
&lt;p&gt;总结来说，我们得到的会是一条条的，随着时间流逝不断增长的数据，我们需要进行实时的数据分析，我们要解决大数据量，灾备，时序，时间窗口，性能等等问题。&lt;br/&gt;而实时，流式其实是相对的概念，现在的很多技术更应该说是近实时，微批。但只要能不断的优化这些问题，实时流式的计算的价值就会越来越大。&lt;/p&gt;
&lt;p&gt;由于大数据兴起之初，Hadoop并没有给出实时计算解决方案，随后Storm，SparkStreaming，Flink等实时计算框架应运而生，而Kafka，ES的兴起使得实时计算领域的技术越来越完善，而随着物联网，机器学习等技术的推广，实时流式计算将在这些领域得到充分的应用。&lt;br/&gt;下面简单介绍目前常用的几种应用场景，未来将对Kafka，Storm，SparkStreaming，Flink等相关技术做具体介绍。&lt;/p&gt;
&lt;p&gt;主要应用&lt;/p&gt;
&lt;p&gt;1、日志分析&lt;br/&gt;比如对网站的用户访问日志进行实时的分析，计算访问量，用户画像，留存率等等，实时的进行数据分析，帮助企业进行决策。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1089984/201908/1089984-20190809085018110-528066629.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、物联网&lt;br/&gt;比如对电力系统进行实时的数据检测，进行报警，实时的显示，或者根据历史数据进行实时的分析，预测。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1089984/201908/1089984-20190809085042564-1504985484.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3、车联网&lt;br/&gt;如今的车联网已经不限于物联网，还包括对用户，交通等等进行分析的一个庞大的系统，改善用户出行。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1089984/201908/1089984-20190809085103279-615786543.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4、金融风控&lt;br/&gt;通过对交易等金融行为实时分析，预测出未知风险。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1089984/201908/1089984-20190809085133884-47314666.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还有很多应用的领域，而且未来会越来越多，在这个过程中具体的业务，以及与技术结合能产生什么样的价值，还需要不断的探索。&lt;/p&gt;
&lt;p&gt;《the-world-beyond-batch-streaming-101》地址：&lt;br/&gt;&lt;a href=&quot;https://www.oreilly.com/ideas/the-world-beyond-batch-streaming-101&quot; class=&quot;uri&quot;&gt;https://www.oreilly.com/ideas/the-world-beyond-batch-streaming-101&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 09 Aug 2019 00:52:00 +0000</pubDate>
<dc:creator>独孤风</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tree1123/p/11325009.html</dc:identifier>
</item>
<item>
<title>Activiti 开发案例之动态指派任务 - 小柒2012</title>
<link>http://www.cnblogs.com/smallSevens/p/11324995.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/smallSevens/p/11324995.html</guid>
<description>[unable to retrieve full-text content]流程图 以上是一个请假的流程图，以下为流程任务节点描述： 员工发起请假流程 部门经理审批 同意则进入人事审批 拒绝则调整申请或者直接结束流程 人事审批通过则进入销假环节 人事审批拒绝则调整申请或者直接结束流程 员工销假结束流程 任务分配 员工发起申请 部门经理审批 通过逻辑： 拒绝逻辑： 待办任务 </description>
<pubDate>Fri, 09 Aug 2019 00:49:00 +0000</pubDate>
<dc:creator>小柒2012</dc:creator>
<dc:identifier>https://www.cnblogs.com/smallSevens/p/11324995.html</dc:identifier>
</item>
<item>
<title>Java学习多线程第二天 - 菜鸟小于</title>
<link>http://www.cnblogs.com/Young111/p/11324986.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Young111/p/11324986.html</guid>
<description>&lt;p&gt;&lt;strong&gt;内容介绍&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li class=&quot;2&quot;&gt; 线程安全&lt;/li&gt;
&lt;li class=&quot;2&quot;&gt; 线程同步&lt;/li&gt;
&lt;li class=&quot;2&quot;&gt; 死锁&lt;/li&gt;
&lt;li class=&quot;2&quot;&gt; Lock锁&lt;/li&gt;
&lt;li class=&quot;2&quot;&gt; 等待唤醒机制&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;1.1     线程安全&lt;/h2&gt;
&lt;p&gt;如果有多个线程在同时运行，而这些线程可能会同时运行这段代码。程序每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。&lt;/p&gt;
&lt;p class=&quot;a&quot;&gt; 我们通过一个案例，演示线程的安全问题：&lt;/p&gt;
&lt;p&gt;电影院要卖票，我们模拟电影院的卖票过程。假设要播放的电影是 “功夫熊猫3”，本次电影的座位共100个(本场电影只能卖100张票)。&lt;/p&gt;
&lt;p&gt;我们来模拟电影院的售票窗口，实现多个窗口同时卖 “魔童哪吒”这场电影票(多个窗口一起卖这100张票)&lt;/p&gt;
&lt;p&gt;需要窗口，采用线程对象来模拟；需要票，Runnable接口子类来模拟&lt;/p&gt;
&lt;ul&gt;&lt;li class=&quot;a&quot;&gt; 测试类&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ThreadDemo {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建票对象&lt;/span&gt;
        Ticket ticket = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Ticket();
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建3个窗口&lt;/span&gt;
        Thread t1  = &lt;span&gt;new&lt;/span&gt; Thread(ticket, &quot;窗口1&quot;&lt;span&gt;);
        Thread t2  &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(ticket, &quot;窗口2&quot;&lt;span&gt;);
        Thread t3  &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(ticket, &quot;窗口3&quot;&lt;span&gt;);
        
        t1.start();
        t2.start();
        t3.start();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p class=&quot;a&quot;&gt;  模拟票&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Ticket &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;共100票&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; ticket = 100&lt;span&gt;;

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;模拟卖票&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ticket &amp;gt; 0&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;模拟选坐的操作&lt;/span&gt;
                &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    Thread.sleep(&lt;/span&gt;1&lt;span&gt;);
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName() &lt;/span&gt;+ &quot;正在卖票:&quot; + ticket--&lt;span&gt;);
            }
        }
    }
} &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1408728/201908/1408728-20190809083645814-353304166.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;运行结果发现：上面程序出现了问题&lt;/p&gt;
&lt;ul&gt;&lt;li class=&quot;a&quot;&gt;  票出现了重复的票&lt;/li&gt;
&lt;li class=&quot;a&quot;&gt;  错误的票 0、-1&lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;left&quot;&gt;其实，线程安全问题都是由全局变量及静态变量引起的。若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。&lt;/p&gt;
&lt;h2&gt;1.2     线程同步（线程安全处理Synchronized）&lt;/h2&gt;
&lt;p&gt;java中提供了线程同步机制，它能够解决上述的线程安全问题。&lt;/p&gt;
&lt;p&gt;         线程同步的方式有两种：&lt;/p&gt;
&lt;ul&gt;&lt;li class=&quot;a&quot;&gt;  方式1：同步代码块&lt;/li&gt;
&lt;li class=&quot;a&quot;&gt;  方式2：同步方法&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;1.2.1    同步代码块&lt;/h3&gt;
&lt;p&gt;同步代码块: 在代码块声明上 加上synchronized&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; (锁对象) {
    可能会产生线程安全问题的代码
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;同步代码块中的锁对象可以是任意的对象；但多个线程时，要使用同一个锁对象才能够保证线程安全。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;a&quot;&gt;使用同步代码块，对电影院卖票案例中Ticket类进行如下代码修改：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Ticket &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;共100票&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; ticket = 100&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义锁对象&lt;/span&gt;
    Object lock = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object();
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;模拟卖票&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;同步代码块&lt;/span&gt;
            &lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; (lock){
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ticket &amp;gt; 0&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;模拟电影选坐的操作&lt;/span&gt;
                    &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                        Thread.sleep(&lt;/span&gt;10&lt;span&gt;);
                    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println(Thread.currentThread().getName() &lt;/span&gt;+ &quot;正在卖票:&quot; + ticket--&lt;span&gt;);
                }
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当使用了同步代码块后，上述的线程的安全问题，解决了。&lt;/p&gt;
&lt;h3&gt;1.2.3    同步方法&lt;/h3&gt;
&lt;ul&gt;&lt;li class=&quot;a&quot;&gt;  同步方法：在方法声明上加上synchronized&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; method(){
       可能会产生线程安全问题的代码
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;同步方法中的锁对象是 this&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;a&quot;&gt;使用同步方法，对电影院卖票案例中Ticket类进行如下代码修改：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Ticket &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;共100票&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; ticket = 100&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义锁对象&lt;/span&gt;
    Object lock = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object();
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;模拟卖票&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;同步方法&lt;/span&gt;
&lt;span&gt;            method();
        }
    }

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;同步方法,锁对象this&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; method(){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ticket &amp;gt; 0&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;模拟选坐的操作&lt;/span&gt;
            &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                Thread.sleep(&lt;/span&gt;10&lt;span&gt;);
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName() &lt;/span&gt;+ &quot;正在卖票:&quot; + ticket--&lt;span&gt;);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li class=&quot;a&quot;&gt;  静态同步方法: 在方法声明上加上&lt;span&gt;static synchronized&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; method(){
可能会产生线程安全问题的代码
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;静态同步方法中的锁对象是&lt;/strong&gt; &lt;strong&gt;类名.class&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;1.3     死锁&lt;/h2&gt;
&lt;p&gt;同步锁使用的弊端：当线程任务中出现了多个同步(多个锁)时，如果同步中嵌套了其他的同步。这时容易引发一种现象：程序出现无限等待，这种现象我们称为死锁。这种情况能避免就避免掉。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;synchronzied(A锁){
    &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt;(B锁){
         
}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;a&quot;&gt;我们进行下死锁情况的代码演示：&lt;/p&gt;
&lt;ul&gt;&lt;li class=&quot;a&quot;&gt;  定义锁对象类&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyLock {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Object lockA = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object();
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Object lockB = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li class=&quot;a&quot;&gt;  线程任务类&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ThreadTask &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; x = &lt;span&gt;new&lt;/span&gt; Random().nextInt(1);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;0,1
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定线程要执行的任务代码&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (x%2 ==0&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;情况一&lt;/span&gt;
                &lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; (MyLock.lockA) {
                    System.out.println(&lt;/span&gt;&quot;if-LockA&quot;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; (MyLock.lockB) {
                        System.out.println(&lt;/span&gt;&quot;if-LockB&quot;&lt;span&gt;);
                        System.out.println(&lt;/span&gt;&quot;if大口吃肉&quot;&lt;span&gt;);
                    }
                }
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;情况二&lt;/span&gt;
                &lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; (MyLock.lockB) {
                    System.out.println(&lt;/span&gt;&quot;else-LockB&quot;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; (MyLock.lockA) {
                        System.out.println(&lt;/span&gt;&quot;else-LockA&quot;&lt;span&gt;);
                        System.out.println(&lt;/span&gt;&quot;else大口吃肉&quot;&lt;span&gt;);
                    }
                }
            }
            x&lt;/span&gt;++&lt;span&gt;;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li class=&quot;a&quot;&gt;  测试类&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ThreadDemo {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建线程任务类对象&lt;/span&gt;
        ThreadTask task = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadTask();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建两个线程&lt;/span&gt;
        Thread t1 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(task);
        Thread t2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(task);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动线程&lt;/span&gt;
&lt;span&gt;        t1.start();
        t2.start();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;1.4     Lock接口&lt;/h2&gt;
&lt;p&gt;查阅API，查阅Lock接口描述，&lt;code&gt;Lock&lt;/code&gt; 实现提供了比使用 &lt;code&gt;synchronized&lt;/code&gt; 方法和语句可获得的更广泛的锁定操作。&lt;/p&gt;
&lt;p&gt;Lock提供了一个更加面对对象的锁，在该锁中提供了更多的操作锁的功能。&lt;/p&gt;
&lt;p&gt;我们使用Lock接口，以及其中的lock()方法和unlock()方法替代同步，对电影院卖票案例中Ticket类进行如下代码修改：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Ticket &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;共100票&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; ticket = 100&lt;span&gt;;
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建Lock锁对象&lt;/span&gt;
    Lock ck = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReentrantLock();
    
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;模拟卖票&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;synchronized (lock){&lt;/span&gt;
&lt;span&gt;            ck.lock();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ticket &amp;gt; 0&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;模拟选坐的操作&lt;/span&gt;
                    &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                        Thread.sleep(&lt;/span&gt;10&lt;span&gt;);
                    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println(Thread.currentThread().getName() &lt;/span&gt;+ &quot;正在卖票:&quot; + ticket--&lt;span&gt;);
                }
            ck.unlock();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;
&lt;span&gt;        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;1.5     等待唤醒机制&lt;/h2&gt;
&lt;p&gt;在开始讲解等待唤醒机制之前，有必要搞清一个概念——线程之间的通信：多个线程在处理同一个资源，但是处理的动作（线程的任务）却不相同。通过一定的手段使各个线程能有效的利用资源。而这种手段即—— 等待唤醒机制。&lt;/p&gt;
&lt;p&gt;等待唤醒机制所涉及到的方法：&lt;/p&gt;
&lt;ul&gt;&lt;li class=&quot;a&quot;&gt;  wait（） :等待，将正在执行的线程释放其执行资格 和 执行权，并存储到线程池中。&lt;/li&gt;
&lt;li class=&quot;a&quot;&gt;  notify（）：唤醒，唤醒线程池中被wait（）的线程，一次唤醒一个，而且是任意的。&lt;/li&gt;
&lt;li class=&quot;a&quot;&gt;  notifyAll（）： 唤醒全部：可以将线程池中的所有wait() 线程都唤醒。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其实，所谓唤醒的意思就是让 线程池中的线程具备执行资格。必须注意的是，这些方法都是在 同步中才有效。同时这些方法在使用时必须标明所属锁，这样才可以明确出这些方法操作的到底是哪个锁上的线程。&lt;/p&gt;
&lt;p&gt;仔细查看JavaAPI之后，发现这些方法 并不定义在 Thread中，也没定义在Runnable接口中，却被定义在了Object类中，为什么这些操作线程的方法定义在Object类中？&lt;/p&gt;
&lt;p&gt;因为这些方法在使用时，必须要标明所属的锁，而锁又可以是任意对象。能被任意对象调用的方法一定定义在Object类中。&lt;/p&gt;
&lt;p&gt;接下里，我们先从一个简单的示例入手:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1408728/201908/1408728-20190809084351421-32953627.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图说示，输入线程向Resource中输入name ,sex , 输出线程从资源中输出，先要完成的任务是：&lt;/p&gt;
&lt;ul&gt;&lt;li class=&quot;a&quot;&gt;  1.当input发现Resource中没有数据时，开始输入，输入完成后，叫output来输出。如果发现有数据，就wait();&lt;/li&gt;
&lt;li class=&quot;a&quot;&gt;  2.当output发现Resource中没有数据时，就wait() ；当发现有数据时，就输出，然后，叫醒input来输入数据。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面代码，模拟等待唤醒机制的实现：&lt;/p&gt;
&lt;ul&gt;&lt;li class=&quot;a&quot;&gt; 模拟资源类&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Resource {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String sex;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; flag = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; set(String name, String sex) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (flag)
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                wait();
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                e.printStackTrace();
            }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置成员变量&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sex =&lt;span&gt; sex;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置之后，Resource中有值，将标记该为 true ,&lt;/span&gt;
        flag = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 唤醒output&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.notify();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; out() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;flag)
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                wait();
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                e.printStackTrace();
            }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出线程将数据输出&lt;/span&gt;
        System.out.println(&quot;姓名: &quot; + name + &quot;，性别: &quot; +&lt;span&gt; sex);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 改变标记，以便输入线程输入数据&lt;/span&gt;
        flag = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 唤醒input，进行数据输入&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.notify();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;输入线程任务类&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Input &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Resource r;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Input(Resource r) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.r =&lt;span&gt; r;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; count = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (count == 0&lt;span&gt;) {
                r.set(&lt;/span&gt;&quot;小明&quot;, &quot;男生&quot;&lt;span&gt;);
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                r.set(&lt;/span&gt;&quot;小花&quot;, &quot;女生&quot;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在两个数据之间进行切换&lt;/span&gt;
            count = (count + 1) % 2&lt;span&gt;;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;输出线程任务类&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Output &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Resource r;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Output(Resource r) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.r =&lt;span&gt; r;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
            r.out();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ResourceDemo {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 资源对象&lt;/span&gt;
        Resource r = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Resource();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 任务对象&lt;/span&gt;
        Input in = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Input(r);
        Output out &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Output(r);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 线程对象&lt;/span&gt;
        Thread t1 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(in);
        Thread t2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(out);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 开启线程&lt;/span&gt;
&lt;span&gt;        t1.start();
        t2.start();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Fri, 09 Aug 2019 00:46:00 +0000</pubDate>
<dc:creator>菜鸟小于</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Young111/p/11324986.html</dc:identifier>
</item>
<item>
<title>七天学会NodeJS——第一天 - 葡萄城技术团队</title>
<link>http://www.cnblogs.com/powertoolsteam/p/11324966.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/powertoolsteam/p/11324966.html</guid>
<description>&lt;blockquote readability=&quot;5.5212765957447&quot;&gt;
&lt;p&gt;转载请注明出处：&lt;a href=&quot;https://www.grapecity.com.cn/&quot;&gt;葡萄城官网&lt;/a&gt;，葡萄城为开发者提供专业的开发工具、解决方案和服务，赋能开发者。&lt;br/&gt;原文出处：http://nqdeng.github.io/7-days-nodejs&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Node.js 是一个能够在服务器端运行JavaScript的开放源代码、跨平台JavaScript运行环境。Node.js采用Google开发的V8内核运行代码，使用事件驱动、非阻塞和异步输入输出模型等技术来提高性能，可优化应用程序的传输量和规模。这些技术通常用于数据密集的即时应用程序。&lt;/p&gt;
&lt;p&gt;在越来越多的Web应用程序中，Node的应用将会更加的得心应手，所以这就是本文出现的目的，就是不论使用Node与否，但希望通过这篇文章让更多的同学了解Node。&lt;/p&gt;
&lt;h2 id=&quot;1&quot;&gt;第一天——NodeJS基础&lt;/h2&gt;
&lt;h3 id=&quot;1.1&quot;&gt;什么是NodeJS&lt;/h3&gt;
&lt;p&gt;JS是脚本语言，脚本语言都需要一个解析器才能运行。对于写在HTML页面里的JS，浏览器充当了解析器的角色。而对于需要独立运行的JS，NodeJS就是一个解析器。&lt;/p&gt;
&lt;p&gt;每一种解析器都是一个运行环境，不但允许JS定义各种数据结构，进行各种计算，还允许JS使用运行环境提供的内置对象和方法做一些事情。例如运行在浏览器中的JS的用途是操作DOM，浏览器就提供了&lt;code&gt;document&lt;/code&gt;之类的内置对象。而运行在NodeJS中的JS的用途是操作磁盘文件或搭建HTTP服务器，NodeJS就相应提供了&lt;code&gt;fs&lt;/code&gt;、&lt;code&gt;http&lt;/code&gt;等内置对象。&lt;/p&gt;
&lt;h3 id=&quot;1.2&quot;&gt;有啥用处&lt;/h3&gt;
&lt;p&gt;尽管存在一听说可以直接运行JS文件就觉得很酷的同学，但大多数同学在接触新东西时首先关心的是有啥用处，以及能带来啥价值。&lt;/p&gt;
&lt;p&gt;NodeJS的作者说，他创造NodeJS的目的是为了实现高性能Web服务器，他首先看重的是事件机制和异步IO模型的优越性，而不是JS。但是他需要选择一种编程语言实现他的想法，这种编程语言不能自带IO功能，并且需要能良好支持事件机制。JS没有自带IO功能，天生就用于处理浏览器中的DOM事件，并且拥有一大群程序员，因此就成为了天然的选择。&lt;/p&gt;
&lt;p&gt;如他所愿，NodeJS在服务端活跃起来，出现了大批基于NodeJS的Web服务。而另一方面，NodeJS让前端众如获神器，终于可以让自己的能力覆盖范围跳出浏览器窗口，更大批的前端工具如雨后春笋。&lt;/p&gt;
&lt;p&gt;因此，对于前端而言，虽然不是人人都要拿NodeJS写一个服务器程序，但简单可至使用命令交互模式调试JS代码片段，复杂可至编写工具提升工作效率。&lt;/p&gt;
&lt;p&gt;NodeJS生态圈正欣欣向荣。&lt;/p&gt;
&lt;h3 id=&quot;1.3&quot;&gt;如何安装&lt;/h3&gt;
&lt;h4 id=&quot;1.3.1&quot;&gt;安装程序&lt;/h4&gt;
&lt;p&gt;NodeJS提供了一些安装程序，都可以在&lt;a href=&quot;http://nodejs.org/download/&quot;&gt;nodejs.org&lt;/a&gt;这里下载并安装。&lt;/p&gt;
&lt;p&gt;Windows系统下，选择和系统版本匹配的&lt;code&gt;.msi&lt;/code&gt;后缀的安装文件。Mac OS X系统下，选择&lt;code&gt;.pkg&lt;/code&gt;后缀的安装文件。&lt;/p&gt;
&lt;h4 id=&quot;1.3.2&quot;&gt;编译安装&lt;/h4&gt;
&lt;p&gt;Linux系统下没有现成的安装程序可用，虽然一些发行版可以使用&lt;code&gt;apt-get&lt;/code&gt;之类的方式安装，但不一定能安装到最新版。因此Linux系统下一般使用以下方式编译方式安装NodeJS。&lt;/p&gt;
&lt;ol readability=&quot;0.96153846153846&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;确保系统下g++版本在4.6以上，python版本在2.6以上。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-0.88636363636364&quot;&gt;
&lt;p&gt;从&lt;a href=&quot;http://nodejs.org/download/&quot;&gt;nodejs.org&lt;/a&gt;下载&lt;code&gt;tar.gz&lt;/code&gt;后缀的NodeJS最新版源代码包并解压到某个位置。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;进入解压到的目录，使用以下命令编译和安装。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; $ ./configure
 $ make
 $ sudo make install&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;1.4&quot;&gt;如何运行&lt;/h3&gt;
&lt;p&gt;打开终端，键入&lt;code&gt;node&lt;/code&gt;进入命令交互模式，可以输入一条代码语句后立即执行并显示结果，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ node
&amp;gt; console.log('Hello World!');
Hello World!&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果要运行一大段代码的话，可以先写一个JS文件再运行。例如有以下&lt;code&gt;hello.js&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function hello() {
    console.log('Hello World!');
}
hello();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;写好后在终端下键入&lt;code&gt;node hello.js&lt;/code&gt;运行，结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ node hello.js
Hello World!&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;1.4.1&quot;&gt;权限问题&lt;/h4&gt;
&lt;p&gt;在Linux系统下，使用NodeJS监听80或443端口提供HTTP(S)服务时需要root权限，有两种方式可以做到。&lt;/p&gt;
&lt;p&gt;一种方式是使用&lt;code&gt;sudo&lt;/code&gt;命令运行NodeJS。例如通过以下命令运行的&lt;code&gt;server.js&lt;/code&gt;中有权限使用80和443端口。一般推荐这种方式，可以保证仅为有需要的JS脚本提供root权限。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ sudo node server.js&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另一种方式是使用&lt;code&gt;chmod +s&lt;/code&gt;命令让NodeJS总是以root权限运行，具体做法如下。因为这种方式让任何JS脚本都有了root权限，不太安全，因此在需要很考虑安全的系统下不推荐使用。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ sudo chown root /usr/local/bin/node
$ sudo chmod +s /usr/local/bin/node&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;1.5&quot;&gt;模块&lt;/h3&gt;
&lt;p&gt;编写稍大一点的程序时一般都会将代码模块化。在NodeJS中，一般将代码合理拆分到不同的JS文件中，每一个文件就是一个模块，而文件路径就是模块名。&lt;/p&gt;
&lt;p&gt;在编写每个模块时，都有&lt;code&gt;require&lt;/code&gt;、&lt;code&gt;exports&lt;/code&gt;、&lt;code&gt;module&lt;/code&gt;三个预先定义好的变量可供使用。&lt;/p&gt;
&lt;h4 id=&quot;1.5.1&quot;&gt;require&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;require&lt;/code&gt;函数用于在当前模块中加载和使用别的模块，传入一个模块名，返回一个模块导出对象。模块名可使用相对路径（以&lt;code&gt;./&lt;/code&gt;开头），或者是绝对路径（以&lt;code&gt;/&lt;/code&gt;或&lt;code&gt;C:&lt;/code&gt;之类的盘符开头）。另外，模块名中的&lt;code&gt;.js&lt;/code&gt;扩展名可以省略。以下是一个例子。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var foo1 = require('./foo');
var foo2 = require('./foo.js');
var foo3 = require('/home/user/foo');
var foo4 = require('/home/user/foo.js');

// foo1至foo4中保存的是同一个模块的导出对象。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另外，可以使用以下方式加载和使用一个JSON文件。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var data = require('./data.json');&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;1.5.2&quot;&gt;exports&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;exports&lt;/code&gt;对象是当前模块的导出对象，用于导出模块公有方法和属性。别的模块通过&lt;code&gt;require&lt;/code&gt;函数使用当前模块时得到的就是当前模块的&lt;code&gt;exports&lt;/code&gt;对象。以下例子中导出了一个公有方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;exports.hello = function () {
    console.log('Hello World!');
};&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;1.5.3&quot;&gt;module&lt;/h4&gt;
&lt;p&gt;通过&lt;code&gt;module&lt;/code&gt;对象可以访问到当前模块的一些相关信息，但最多的用途是替换当前模块的导出对象。例如模块导出对象默认是一个普通对象，如果想改成一个函数的话，可以使用以下方式。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;module.exports = function () {
    console.log('Hello World!');
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上代码中，模块默认导出对象被替换为一个函数。&lt;/p&gt;
&lt;h4 id=&quot;1.5.4&quot;&gt;模块初始化&lt;/h4&gt;
&lt;p&gt;一个模块中的JS代码仅在模块第一次被使用时执行一次，并在执行过程中初始化模块的导出对象。之后，缓存起来的导出对象被重复利用。&lt;/p&gt;
&lt;h4 id=&quot;1.5.5&quot;&gt;主模块&lt;/h4&gt;
&lt;p&gt;通过命令行参数传递给NodeJS以启动程序的模块被称为主模块。主模块负责调度组成整个程序的其它模块完成工作。例如通过以下命令启动程序时，&lt;code&gt;main.js&lt;/code&gt;就是主模块。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ node main.js&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;1.5.6&quot;&gt;完整示例&lt;/h4&gt;
&lt;p&gt;例如有以下目录。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;- /home/user/hello/
    - util/
        counter.js
    main.js&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中&lt;code&gt;counter.js&lt;/code&gt;内容如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var i = 0;

function count() {
    return ++i;
}

exports.count = count;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该模块内部定义了一个私有变量&lt;code&gt;i&lt;/code&gt;，并在&lt;code&gt;exports&lt;/code&gt;对象导出了一个公有方法&lt;code&gt;count&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;主模块&lt;code&gt;main.js&lt;/code&gt;内容如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var counter1 = require('./util/counter');
var    counter2 = require('./util/counter');

console.log(counter1.count());
console.log(counter2.count());
console.log(counter2.count());&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行该程序的结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ node main.js
1
2
3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，&lt;code&gt;counter.js&lt;/code&gt;并没有因为被require了两次而初始化两次。&lt;/p&gt;
&lt;h3 id=&quot;1.6&quot;&gt;二进制模块&lt;/h3&gt;
&lt;p&gt;虽然一般我们使用JS编写模块，但NodeJS也支持使用C/C++编写二进制模块。编译好的二进制模块除了文件扩展名是&lt;code&gt;.node&lt;/code&gt;外，和JS模块的使用方式相同。虽然二进制模块能使用操作系统提供的所有功能，拥有无限的潜能，但对于前端同学而言编写过于困难，并且难以跨平台使用，因此不在本教程的覆盖范围内。&lt;/p&gt;
&lt;h3 id=&quot;1.7&quot;&gt;小结&lt;/h3&gt;
&lt;p&gt;本章介绍了有关NodeJS的基本概念和使用方法，总结起来有以下知识点：&lt;/p&gt;
&lt;ul readability=&quot;3.4823232323232&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;NodeJS是一个JS脚本解析器，任何操作系统下安装NodeJS本质上做的事情都是把NodeJS执行程序复制到一个目录，然后保证这个目录在系统PATH环境变量下，以便终端下可以使用&lt;code&gt;node&lt;/code&gt;命令。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;终端下直接输入&lt;code&gt;node&lt;/code&gt;命令可进入命令交互模式，很适合用来测试一些JS代码片段，比如正则表达式。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;NodeJS使用&lt;a href=&quot;http://wiki.commonjs.org/&quot;&gt;CMD&lt;/a&gt;模块系统，主模块作为程序入口点，所有模块在执行过程中只初始化一次。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;除非JS模块不能满足需求，否则不要轻易使用二进制模块，否则你的用户会叫苦连天。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;2&quot;&gt;代码的组织和部署&lt;/h2&gt;
&lt;p&gt;有经验的C程序员在编写一个新程序时首先从make文件写起。同样的，使用NodeJS编写程序前，为了有个良好的开端，首先需要准备好代码的目录结构和部署方式，就如同修房子要先搭脚手架。本章将介绍与之相关的各种知识。&lt;/p&gt;
&lt;h3 id=&quot;2.1&quot;&gt;模块路径解析规则&lt;/h3&gt;
&lt;p&gt;我们已经知道，&lt;code&gt;require&lt;/code&gt;函数支持斜杠（&lt;code&gt;/&lt;/code&gt;）或盘符（&lt;code&gt;C:&lt;/code&gt;）开头的绝对路径，也支持&lt;code&gt;./&lt;/code&gt;开头的相对路径。但这两种路径在模块之间建立了强耦合关系，一旦某个模块文件的存放位置需要变更，使用该模块的其它模块的代码也需要跟着调整，变得牵一发动全身。因此，&lt;code&gt;require&lt;/code&gt;函数支持第三种形式的路径，写法类似于&lt;code&gt;foo/bar&lt;/code&gt;，并依次按照以下规则解析路径，直到找到模块位置。&lt;/p&gt;
&lt;ol readability=&quot;6.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;内置模块&lt;/p&gt;
&lt;p&gt;如果传递给&lt;code&gt;require&lt;/code&gt;函数的是NodeJS内置模块名称，不做路径解析，直接返回内部模块的导出对象，例如&lt;code&gt;require('fs')&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;node_modules目录&lt;/p&gt;
&lt;p&gt;NodeJS定义了一个特殊的&lt;code&gt;node_modules&lt;/code&gt;目录用于存放模块。例如某个模块的绝对路径是&lt;code&gt;/home/user/hello.js&lt;/code&gt;，在该模块中使用&lt;code&gt;require('foo/bar')&lt;/code&gt;方式加载模块时，则NodeJS依次尝试使用以下路径。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; /home/user/node_modules/foo/bar
 /home/node_modules/foo/bar
 /node_modules/foo/bar&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;NODE_PATH环境变量&lt;/p&gt;
&lt;p&gt;与PATH环境变量类似，NodeJS允许通过NODE_PATH环境变量来指定额外的模块搜索路径。NODE_PATH环境变量中包含一到多个目录路径，路径之间在Linux下使用&lt;code&gt;:&lt;/code&gt;分隔，在Windows下使用&lt;code&gt;;&lt;/code&gt;分隔。例如定义了以下NODE_PATH环境变量：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; NODE_PATH=/home/user/lib:/home/lib&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当使用&lt;code&gt;require('foo/bar')&lt;/code&gt;的方式加载模块时，则NodeJS依次尝试以下路径。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; /home/user/lib/foo/bar
 /home/lib/foo/bar&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;2.2&quot;&gt;包（package）&lt;/h3&gt;
&lt;p&gt;我们已经知道了JS模块的基本单位是单个JS文件，但复杂些的模块往往由多个子模块组成。为了便于管理和使用，我们可以把由多个子模块组成的大模块称做&lt;code&gt;包&lt;/code&gt;，并把所有子模块放在同一个目录里。&lt;/p&gt;
&lt;p&gt;在组成一个包的所有子模块中，需要有一个入口模块，入口模块的导出对象被作为包的导出对象。例如有以下目录结构。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;- /home/user/lib/
    - cat/
        head.js
        body.js
        main.js&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中&lt;code&gt;cat&lt;/code&gt;目录定义了一个包，其中包含了3个子模块。&lt;code&gt;main.js&lt;/code&gt;作为入口模块，其内容如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var head = require('./head');
var body = require('./body');

exports.create = function (name) {
    return {
        name: name,
        head: head.create(),
        body: body.create()
    };
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在其它模块里使用包的时候，需要加载包的入口模块。接着上例，使用&lt;code&gt;require('/home/user/lib/cat/main')&lt;/code&gt;能达到目的，但是入口模块名称出现在路径里看上去不是个好主意。因此我们需要做点额外的工作，让包使用起来更像是单个模块。&lt;/p&gt;
&lt;h4 id=&quot;2.2.1&quot;&gt;index.js&lt;/h4&gt;
&lt;p&gt;当模块的文件名是&lt;code&gt;index.js&lt;/code&gt;，加载模块时可以使用模块所在目录的路径代替模块文件路径，因此接着上例，以下两条语句等价。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var cat = require('/home/user/lib/cat');
var cat = require('/home/user/lib/cat/index');&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样处理后，就只需要把包目录路径传递给&lt;code&gt;require&lt;/code&gt;函数，感觉上整个目录被当作单个模块使用，更有整体感。&lt;/p&gt;
&lt;h4 id=&quot;2.2.2&quot;&gt;package.json&lt;/h4&gt;
&lt;p&gt;如果想自定义入口模块的文件名和存放位置，就需要在包目录下包含一个&lt;code&gt;package.json&lt;/code&gt;文件，并在其中指定入口模块的路径。上例中的&lt;code&gt;cat&lt;/code&gt;模块可以重构如下。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;- /home/user/lib/
    - cat/
        + doc/
        - lib/
            head.js
            body.js
            main.js
        + tests/
        package.json&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中&lt;code&gt;package.json&lt;/code&gt;内容如下。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
    &quot;name&quot;: &quot;cat&quot;,
    &quot;main&quot;: &quot;./lib/main.js&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如此一来，就同样可以使用&lt;code&gt;require('/home/user/lib/cat')&lt;/code&gt;的方式加载模块。NodeJS会根据包目录下的&lt;code&gt;package.json&lt;/code&gt;找到入口模块所在位置。&lt;/p&gt;
&lt;h3 id=&quot;2.3&quot;&gt;命令行程序&lt;/h3&gt;
&lt;p&gt;使用NodeJS编写的东西，要么是一个包，要么是一个命令行程序，而前者最终也会用于开发后者。因此我们在部署代码时需要一些技巧，让用户觉得自己是在使用一个命令行程序。&lt;/p&gt;
&lt;p&gt;例如我们用NodeJS写了个程序，可以把命令行参数原样打印出来。该程序很简单，在主模块内实现了所有功能。并且写好后，我们把该程序部署在&lt;code&gt;/home/user/bin/node-echo.js&lt;/code&gt;这个位置。为了在任何目录下都能运行该程序，我们需要使用以下终端命令。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ node /home/user/bin/node-echo.js Hello World
Hello World&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种使用方式看起来不怎么像是一个命令行程序，下边的才是我们期望的方式。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ node-echo Hello World&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;2.3.1&quot;&gt;Linux&lt;/h4&gt;
&lt;p&gt;在Linux系统下，我们可以把JS文件当作shell脚本来运行，从而达到上述目的，具体步骤如下：&lt;/p&gt;
&lt;ol readability=&quot;4&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;在shell脚本中，可以通过&lt;code&gt;#!&lt;/code&gt;注释来指定当前脚本使用的解析器。所以我们首先在&lt;code&gt;node-echo.js&lt;/code&gt;文件顶部增加以下一行注释，表明当前脚本使用NodeJS解析。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; #! /usr/bin/env node&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;NodeJS会忽略掉位于JS模块首行的&lt;code&gt;#!&lt;/code&gt;注释，不必担心这行注释是非法语句。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;然后，我们使用以下命令赋予&lt;code&gt;node-echo.js&lt;/code&gt;文件执行权限。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; $ chmod +x /home/user/bin/node-echo.js&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;最后，我们在PATH环境变量中指定的某个目录下，例如在&lt;code&gt;/usr/local/bin&lt;/code&gt;下边创建一个软链文件，文件名与我们希望使用的终端命令同名，命令如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; $ sudo ln -s /home/user/bin/node-echo.js /usr/local/bin/node-echo&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这样处理后，我们就可以在任何目录下使用&lt;code&gt;node-echo&lt;/code&gt;命令了。&lt;/p&gt;
&lt;h4 id=&quot;2.3.2&quot;&gt;Windows&lt;/h4&gt;
&lt;p&gt;在Windows系统下的做法完全不同，我们得靠&lt;code&gt;.cmd&lt;/code&gt;文件来解决问题。假设&lt;code&gt;node-echo.js&lt;/code&gt;存放在&lt;code&gt;C:\Users\user\bin&lt;/code&gt;目录，并且该目录已经添加到PATH环境变量里了。接下来需要在该目录下新建一个名为&lt;code&gt;node-echo.cmd&lt;/code&gt;的文件，文件内容如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@node &quot;C:\User\user\bin\node-echo.js&quot; %*&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样处理后，我们就可以在任何目录下使用&lt;code&gt;node-echo&lt;/code&gt;命令了。&lt;/p&gt;
&lt;h3 id=&quot;2.4&quot;&gt;工程目录&lt;/h3&gt;
&lt;p&gt;了解了以上知识后，现在我们可以来完整地规划一个工程目录了。以编写一个命令行程序为例，一般我们会同时提供命令行模式和API模式两种使用方式，并且我们会借助三方包来编写代码。除了代码外，一个完整的程序也应该有自己的文档和测试用例。因此，一个标准的工程目录都看起来像下边这样。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;- /home/user/workspace/node-echo/   # 工程目录
    - bin/                          # 存放命令行相关代码
        node-echo
    + doc/                          # 存放文档
    - lib/                          # 存放API相关代码
        echo.js
    - node_modules/                 # 存放三方包
        + argv/
    + tests/                        # 存放测试用例
    package.json                    # 元数据文件
    README.md                       # 说明文件&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中部分文件内容如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/* bin/node-echo */
var argv = require('argv'),
    echo = require('../lib/echo');
console.log(echo(argv.join(' ')));

/* lib/echo.js */
module.exports = function (message) {
    return message;
};

/* package.json */
{
    &quot;name&quot;: &quot;node-echo&quot;,
    &quot;main&quot;: &quot;./lib/echo.js&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上例子中分类存放了不同类型的文件，并通过&lt;code&gt;node_moudles&lt;/code&gt;目录直接使用三方包名加载模块。此外，定义了&lt;code&gt;package.json&lt;/code&gt;之后，&lt;code&gt;node-echo&lt;/code&gt;目录也可被当作一个包来使用。&lt;/p&gt;
&lt;h3 id=&quot;2.5&quot;&gt;NPM&lt;/h3&gt;
&lt;p&gt;NPM是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题，常见的使用场景有以下几种：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;允许用户从NPM服务器下载别人编写的三方包到本地使用。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;可以看到，NPM建立了一个NodeJS生态圈，NodeJS开发者和用户可以在里边互通有无。以下分别介绍这三种场景下怎样使用NPM。&lt;/p&gt;
&lt;h4 id=&quot;2.5.1&quot;&gt;下载三方包&lt;/h4&gt;
&lt;p&gt;需要使用三方包时，首先得知道有哪些包可用。虽然&lt;a href=&quot;https://npmjs.org/&quot;&gt;npmjs.org&lt;/a&gt;提供了个搜索框可以根据包名来搜索，但如果连想使用的三方包的名字都不确定的话，就请百度一下吧。知道了包名后，比如上边例子中的&lt;code&gt;argv&lt;/code&gt;，就可以在工程目录下打开终端，使用以下命令来下载三方包。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ npm install argv
...
argv@0.0.2 node_modules\argv&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下载好之后，&lt;code&gt;argv&lt;/code&gt;包就放在了工程目录下的&lt;code&gt;node_modules&lt;/code&gt;目录中，因此在代码中只需要通过&lt;code&gt;require('argv')&lt;/code&gt;的方式就好，无需指定三方包路径。&lt;/p&gt;
&lt;p&gt;以上命令默认下载最新版三方包，如果想要下载指定版本的话，可以在包名后边加上&lt;code&gt;@&amp;lt;version&amp;gt;&lt;/code&gt;，例如通过以下命令可下载0.0.1版的&lt;code&gt;argv&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ npm install argv@0.0.1
...
argv@0.0.1 node_modules\argv&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果使用到的三方包比较多，在终端下一个包一条命令地安装未免太人肉了。因此NPM对&lt;code&gt;package.json&lt;/code&gt;的字段做了扩展，允许在其中申明三方包依赖。因此，上边例子中的&lt;code&gt;package.json&lt;/code&gt;可以改写如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
    &quot;name&quot;: &quot;node-echo&quot;,
    &quot;main&quot;: &quot;./lib/echo.js&quot;,
    &quot;dependencies&quot;: {
        &quot;argv&quot;: &quot;0.0.2&quot;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样处理后，在工程目录下就可以使用&lt;code&gt;npm install&lt;/code&gt;命令批量安装三方包了。更重要的是，当以后&lt;code&gt;node-echo&lt;/code&gt;也上传到了NPM服务器，别人下载这个包时，NPM会根据包中申明的三方包依赖自动下载进一步依赖的三方包。例如，使用&lt;code&gt;npm install node-echo&lt;/code&gt;命令时，NPM会自动创建以下目录结构。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;- project/
    - node_modules/
        - node-echo/
            - node_modules/
                + argv/
            ...
    ...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如此一来，用户只需关心自己直接使用的三方包，不需要自己去解决所有包的依赖关系。&lt;/p&gt;
&lt;h4 id=&quot;2.5.2&quot;&gt;安装命令行程序&lt;/h4&gt;
&lt;p&gt;从NPM服务上下载安装一个命令行程序的方法与三方包类似。例如上例中的&lt;code&gt;node-echo&lt;/code&gt;提供了命令行使用方式，只要&lt;code&gt;node-echo&lt;/code&gt;自己配置好了相关的&lt;code&gt;package.json&lt;/code&gt;字段，对于用户而言，只需要使用以下命令安装程序。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ npm install node-echo -g&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数中的&lt;code&gt;-g&lt;/code&gt;表示全局安装，因此&lt;code&gt;node-echo&lt;/code&gt;会默认安装到以下位置，并且NPM会自动创建好Linux系统下需要的软链文件或Windows系统下需要的&lt;code&gt;.cmd&lt;/code&gt;文件。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;- /usr/local/               # Linux系统下
    - lib/node_modules/
        + node-echo/
        ...
    - bin/
        node-echo
        ...
    ...

- %APPDATA%\npm\            # Windows系统下
    - node_modules\
        + node-echo\
        ...
    node-echo.cmd
    ...&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;2.5.3&quot;&gt;发布代码&lt;/h4&gt;
&lt;p&gt;第一次使用NPM发布代码前需要注册一个账号。终端下运行&lt;code&gt;npm adduser&lt;/code&gt;，之后按照提示做即可。账号搞定后，接着我们需要编辑&lt;code&gt;package.json&lt;/code&gt;文件，加入NPM必需的字段。接着上边&lt;code&gt;node-echo&lt;/code&gt;的例子，&lt;code&gt;package.json&lt;/code&gt;里必要的字段如下。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
    &quot;name&quot;: &quot;node-echo&quot;,           # 包名，在NPM服务器上须要保持唯一
    &quot;version&quot;: &quot;1.0.0&quot;,            # 当前版本号
    &quot;dependencies&quot;: {              # 三方包依赖，需要指定包名和版本号
        &quot;argv&quot;: &quot;0.0.2&quot;
      },
    &quot;main&quot;: &quot;./lib/echo.js&quot;,       # 入口模块位置
    &quot;bin&quot; : {
        &quot;node-echo&quot;: &quot;./bin/node-echo&quot;      # 命令行程序名和主模块位置
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;之后，我们就可以在&lt;code&gt;package.json&lt;/code&gt;所在目录下运行&lt;code&gt;npm publish&lt;/code&gt;发布代码了。&lt;/p&gt;
&lt;h4 id=&quot;2.5.4&quot;&gt;版本号&lt;/h4&gt;
&lt;p&gt;使用NPM下载和发布代码时都会接触到版本号。NPM使用语义版本号来管理代码，这里简单介绍一下。&lt;/p&gt;
&lt;p&gt;语义版本号分为&lt;code&gt;X.Y.Z&lt;/code&gt;三位，分别代表主版本号、次版本号和补丁版本号。当代码变更时，版本号按以下原则更新。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;+ 如果只是修复bug，需要更新Z位。

+ 如果是新增了功能，但是向下兼容，需要更新Y位。

+ 如果有大变动，向下不兼容，需要更新X位。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;版本号有了这个保证后，在申明三方包依赖时，除了可依赖于一个固定版本号外，还可依赖于某个范围的版本号。例如&lt;code&gt;&quot;argv&quot;: &quot;0.0.x&quot;&lt;/code&gt;表示依赖于&lt;code&gt;0.0.x&lt;/code&gt;系列的最新版&lt;code&gt;argv&lt;/code&gt;。NPM支持的所有版本号范围指定方式可以查看&lt;a href=&quot;https://npmjs.org/doc/files/package.json.html#dependencies&quot;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;
&lt;h4 id=&quot;2.5.5&quot;&gt;灵机一点&lt;/h4&gt;
&lt;p&gt;除了本章介绍的部分外，NPM还提供了很多功能，&lt;code&gt;package.json&lt;/code&gt;里也有很多其它有用的字段。除了可以在&lt;a href=&quot;https://npmjs.org/doc/&quot;&gt;npmjs.org/doc/&lt;/a&gt;查看官方文档外，这里再介绍一些NPM常用命令。&lt;/p&gt;
&lt;ul readability=&quot;5.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;NPM提供了很多命令，例如&lt;code&gt;install&lt;/code&gt;和&lt;code&gt;publish&lt;/code&gt;，使用&lt;code&gt;npm help&lt;/code&gt;可查看所有命令。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;使用&lt;code&gt;npm help &amp;lt;command&amp;gt;&lt;/code&gt;可查看某条命令的详细帮助，例如&lt;code&gt;npm help install&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;在&lt;code&gt;package.json&lt;/code&gt;所在目录下使用&lt;code&gt;npm install . -g&lt;/code&gt;可先在本地安装当前命令行程序，可用于发布前的本地测试。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;使用&lt;code&gt;npm update &amp;lt;package&amp;gt;&lt;/code&gt;可以把当前目录下&lt;code&gt;node_modules&lt;/code&gt;子目录里边的对应模块更新至最新版本。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;使用&lt;code&gt;npm update &amp;lt;package&amp;gt; -g&lt;/code&gt;可以把全局安装的对应命令行程序更新至最新版。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;使用&lt;code&gt;npm cache clear&lt;/code&gt;可以清空NPM本地缓存，用于对付使用相同版本号发布新版本代码的人。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;使用&lt;code&gt;npm unpublish &amp;lt;package&amp;gt;@&amp;lt;version&amp;gt;&lt;/code&gt;可以撤销发布自己发布过的某个版本代码。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;2.6&quot;&gt;小结&lt;/h3&gt;
&lt;p&gt;本章介绍了使用NodeJS编写代码前需要做的准备工作，总结起来有以下几点：&lt;/p&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;编写代码前先规划好目录结构，才能做到有条不紊。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;稍大些的程序可以将代码拆分为多个模块管理，更大些的程序可以使用包来组织模块。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;合理使用&lt;code&gt;node_modules&lt;/code&gt;和&lt;code&gt;NODE_PATH&lt;/code&gt;来解耦包的使用方式和物理路径。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;使用NPM加入NodeJS生态圈互通有无。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;想到了心仪的包名时请提前在NPM上抢注。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;3&quot;&gt;文件操作&lt;/h2&gt;
&lt;p&gt;让前端觉得如获神器的不是NodeJS能做网络编程，而是NodeJS能够操作文件。小至文件查找，大至代码编译，几乎没有一个前端工具不操作文件。换个角度讲，几乎也只需要一些数据处理逻辑，再加上一些文件操作，就能够编写出大多数前端工具。本章将介绍与之相关的NodeJS内置模块。&lt;/p&gt;
&lt;h3 id=&quot;3.1&quot;&gt;开门红&lt;/h3&gt;
&lt;p&gt;NodeJS提供了基本的文件操作API，但是像文件拷贝这种高级功能就没有提供，因此我们先拿文件拷贝程序练手。与&lt;code&gt;copy&lt;/code&gt;命令类似，我们的程序需要能接受源文件路径与目标文件路径两个参数。&lt;/p&gt;
&lt;h4 id=&quot;3.1.1&quot;&gt;小文件拷贝&lt;/h4&gt;
&lt;p&gt;我们使用NodeJS内置的&lt;code&gt;fs&lt;/code&gt;模块简单实现这个程序如下。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var fs = require('fs');

function copy(src, dst) {
    fs.writeFileSync(dst, fs.readFileSync(src));
}

function main(argv) {
    copy(argv[0], argv[1]);
}

main(process.argv.slice(2));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上程序使用&lt;code&gt;fs.readFileSync&lt;/code&gt;从源路径读取文件内容，并使用&lt;code&gt;fs.writeFileSync&lt;/code&gt;将文件内容写入目标路径。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;豆知识：&lt;/strong&gt; &lt;code&gt;process&lt;/code&gt;是一个全局变量，可通过&lt;code&gt;process.argv&lt;/code&gt;获得命令行参数。由于&lt;code&gt;argv[0]&lt;/code&gt;固定等于NodeJS执行程序的绝对路径，&lt;code&gt;argv[1]&lt;/code&gt;固定等于主模块的绝对路径，因此第一个命令行参数从&lt;code&gt;argv[2]&lt;/code&gt;这个位置开始。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;3.1.2&quot;&gt;大文件拷贝&lt;/h4&gt;
&lt;p&gt;上边的程序拷贝一些小文件没啥问题，但这种一次性把所有文件内容都读取到内存中后再一次性写入磁盘的方式不适合拷贝大文件，内存会爆仓。对于大文件，我们只能读一点写一点，直到完成拷贝。因此上边的程序需要改造如下。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var fs = require('fs');

function copy(src, dst) {
    fs.createReadStream(src).pipe(fs.createWriteStream(dst));
}

function main(argv) {
    copy(argv[0], argv[1]);
}

main(process.argv.slice(2));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上程序使用&lt;code&gt;fs.createReadStream&lt;/code&gt;创建了一个源文件的只读数据流，并使用&lt;code&gt;fs.createWriteStream&lt;/code&gt;创建了一个目标文件的只写数据流，并且用&lt;code&gt;pipe&lt;/code&gt;方法把两个数据流连接了起来。连接起来后发生的事情，说得抽象点的话，水顺着水管从一个桶流到了另一个桶。&lt;/p&gt;
&lt;h3 id=&quot;3.2&quot;&gt;API走马观花&lt;/h3&gt;
&lt;p&gt;我们先大致看看NodeJS提供了哪些和文件操作有关的API。这里并不逐一介绍每个API的使用方法，官方文档已经做得很好了。&lt;/p&gt;
&lt;h4 id=&quot;3.2.1&quot;&gt;Buffer（数据块）&lt;/h4&gt;
&lt;blockquote readability=&quot;1.7&quot;&gt;
&lt;p&gt;&lt;strong&gt;官方文档： &lt;/strong&gt;&lt;a href=&quot;http://nodejs.org/api/buffer.html&quot;&gt;http://nodejs.org/api/buffer.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;JS语言自身只有字符串数据类型，没有二进制数据类型，因此NodeJS提供了一个与&lt;code&gt;String&lt;/code&gt;对等的全局构造函数&lt;code&gt;Buffer&lt;/code&gt;来提供对二进制数据的操作。除了可以读取文件得到&lt;code&gt;Buffer&lt;/code&gt;的实例外，还能够直接构造，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var bin = new Buffer([ 0x68, 0x65, 0x6c, 0x6c, 0x6f ]);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Buffer&lt;/code&gt;与字符串类似，除了可以用&lt;code&gt;.length&lt;/code&gt;属性得到字节长度外，还可以用&lt;code&gt;[index]&lt;/code&gt;方式读取指定位置的字节，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;bin[0]; // =&amp;gt; 0x68;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Buffer&lt;/code&gt;与字符串能够互相转化，例如可以使用指定编码将二进制数据转化为字符串：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var str = bin.toString('utf-8'); // =&amp;gt; &quot;hello&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者反过来，将字符串转换为指定编码下的二进制数据：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var bin = new Buffer('hello', 'utf-8'); // =&amp;gt; &amp;lt;Buffer 68 65 6c 6c 6f&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Buffer&lt;/code&gt;与字符串有一个重要区别。字符串是只读的，并且对字符串的任何修改得到的都是一个新字符串，原字符串保持不变。至于&lt;code&gt;Buffer&lt;/code&gt;，更像是可以做指针操作的C语言数组。例如，可以用&lt;code&gt;[index]&lt;/code&gt;方式直接修改某个位置的字节。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;bin[0] = 0x48;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而&lt;code&gt;.slice&lt;/code&gt;方法也不是返回一个新的&lt;code&gt;Buffer&lt;/code&gt;，而更像是返回了指向原&lt;code&gt;Buffer&lt;/code&gt;中间的某个位置的指针，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[ 0x68, 0x65, 0x6c, 0x6c, 0x6f ]
    ^           ^
    |           |
   bin     bin.slice(2)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因此对&lt;code&gt;.slice&lt;/code&gt;方法返回的&lt;code&gt;Buffer&lt;/code&gt;的修改会作用于原&lt;code&gt;Buffer&lt;/code&gt;，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var bin = new Buffer([ 0x68, 0x65, 0x6c, 0x6c, 0x6f ]);
var sub = bin.slice(2);

sub[0] = 0x65;
console.log(bin); // =&amp;gt; &amp;lt;Buffer 68 65 65 6c 6f&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也因此，如果想要拷贝一份&lt;code&gt;Buffer&lt;/code&gt;，得首先创建一个新的&lt;code&gt;Buffer&lt;/code&gt;，并通过&lt;code&gt;.copy&lt;/code&gt;方法把原&lt;code&gt;Buffer&lt;/code&gt;中的数据复制过去。这个类似于申请一块新的内存，并把已有内存中的数据复制过去。以下是一个例子。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var bin = new Buffer([ 0x68, 0x65, 0x6c, 0x6c, 0x6f ]);
var dup = new Buffer(bin.length);

bin.copy(dup);
dup[0] = 0x48;
console.log(bin); // =&amp;gt; &amp;lt;Buffer 68 65 6c 6c 6f&amp;gt;
console.log(dup); // =&amp;gt; &amp;lt;Buffer 48 65 65 6c 6f&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;总之，&lt;code&gt;Buffer&lt;/code&gt;将JS的数据处理能力从字符串扩展到了任意二进制数据。&lt;/p&gt;
&lt;h4 id=&quot;3.2.2&quot;&gt;Stream（数据流）&lt;/h4&gt;
&lt;blockquote readability=&quot;1.7&quot;&gt;
&lt;p&gt;&lt;strong&gt;官方文档： &lt;/strong&gt;&lt;a href=&quot;http://nodejs.org/api/stream.html&quot;&gt;http://nodejs.org/api/stream.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当内存中无法一次装下需要处理的数据时，或者一边读取一边处理更加高效时，我们就需要用到数据流。NodeJS中通过各种&lt;code&gt;Stream&lt;/code&gt;来提供对数据流的操作。&lt;/p&gt;
&lt;p&gt;以上边的大文件拷贝程序为例，我们可以为数据来源创建一个只读数据流，示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var rs = fs.createReadStream(pathname);

rs.on('data', function (chunk) {
    doSomething(chunk);
});

rs.on('end', function () {
    cleanUp();
});&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5.3454545454545&quot;&gt;
&lt;p&gt;&lt;strong&gt;豆知识：&lt;/strong&gt; &lt;code&gt;Stream&lt;/code&gt;基于事件机制工作，所有&lt;code&gt;Stream&lt;/code&gt;的实例都继承于NodeJS提供的&lt;a href=&quot;http://nodejs.org/api/events.html&quot;&gt;EventEmitter&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上边的代码中&lt;code&gt;data&lt;/code&gt;事件会源源不断地被触发，不管&lt;code&gt;doSomething&lt;/code&gt;函数是否处理得过来。代码可以继续做如下改造，以解决这个问题。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var rs = fs.createReadStream(src);

rs.on('data', function (chunk) {
    rs.pause();
    doSomething(chunk, function () {
        rs.resume();
    });
});

rs.on('end', function () {
    cleanUp();
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上代码给&lt;code&gt;doSomething&lt;/code&gt;函数加上了回调，因此我们可以在处理数据前暂停数据读取，并在处理数据后继续读取数据。&lt;/p&gt;
&lt;p&gt;此外，我们也可以为数据目标创建一个只写数据流，示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var rs = fs.createReadStream(src);
var ws = fs.createWriteStream(dst);

rs.on('data', function (chunk) {
    ws.write(chunk);
});

rs.on('end', function () {
    ws.end();
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们把&lt;code&gt;doSomething&lt;/code&gt;换成了往只写数据流里写入数据后，以上代码看起来就像是一个文件拷贝程序了。但是以上代码存在上边提到的问题，如果写入速度跟不上读取速度的话，只写数据流内部的缓存会爆仓。我们可以根据&lt;code&gt;.write&lt;/code&gt;方法的返回值来判断传入的数据是写入目标了，还是临时放在了缓存了，并根据&lt;code&gt;drain&lt;/code&gt;事件来判断什么时候只写数据流已经将缓存中的数据写入目标，可以传入下一个待写数据了。因此代码可以改造如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var rs = fs.createReadStream(src);
var ws = fs.createWriteStream(dst);

rs.on('data', function (chunk) {
    if (ws.write(chunk) === false) {
        rs.pause();
    }
});

rs.on('end', function () {
    ws.end();
});

ws.on('drain', function () {
    rs.resume();
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上代码实现了数据从只读数据流到只写数据流的搬运，并包括了防爆仓控制。因为这种使用场景很多，例如上边的大文件拷贝程序，NodeJS直接提供了&lt;code&gt;.pipe&lt;/code&gt;方法来做这件事情，其内部实现方式与上边的代码类似。&lt;/p&gt;
&lt;h4 id=&quot;3.2.3&quot;&gt;File System（文件系统）&lt;/h4&gt;
&lt;blockquote readability=&quot;1.8478260869565&quot;&gt;
&lt;p&gt;&lt;strong&gt;官方文档： &lt;/strong&gt;&lt;a href=&quot;http://nodejs.org/api/fs.html&quot;&gt;http://nodejs.org/api/fs.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;NodeJS通过&lt;code&gt;fs&lt;/code&gt;内置模块提供对文件的操作。&lt;code&gt;fs&lt;/code&gt;模块提供的API基本上可以分为以下三类：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;文件属性读写。&lt;/p&gt;
&lt;p&gt;其中常用的有&lt;code&gt;fs.stat&lt;/code&gt;、&lt;code&gt;fs.chmod&lt;/code&gt;、&lt;code&gt;fs.chown&lt;/code&gt;等等。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;文件内容读写。&lt;/p&gt;
&lt;p&gt;其中常用的有&lt;code&gt;fs.readFile&lt;/code&gt;、&lt;code&gt;fs.readdir&lt;/code&gt;、&lt;code&gt;fs.writeFile&lt;/code&gt;、&lt;code&gt;fs.mkdir&lt;/code&gt;等等。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;底层文件操作。&lt;/p&gt;
&lt;p&gt;其中常用的有&lt;code&gt;fs.open&lt;/code&gt;、&lt;code&gt;fs.read&lt;/code&gt;、&lt;code&gt;fs.write&lt;/code&gt;、&lt;code&gt;fs.close&lt;/code&gt;等等。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;NodeJS最精华的异步IO模型在&lt;code&gt;fs&lt;/code&gt;模块里有着充分的体现，例如上边提到的这些API都通过回调函数传递结果。以&lt;code&gt;fs.readFile&lt;/code&gt;为例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;fs.readFile(pathname, function (err, data) {
    if (err) {
        // Deal with error.
    } else {
        // Deal with data.
    }
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上边代码所示，基本上所有&lt;code&gt;fs&lt;/code&gt;模块API的回调参数都有两个。第一个参数在有错误发生时等于异常对象，第二个参数始终用于返回API方法执行结果。&lt;/p&gt;
&lt;p&gt;此外，&lt;code&gt;fs&lt;/code&gt;模块的所有异步API都有对应的同步版本，用于无法使用异步操作时，或者同步操作更方便时的情况。同步API除了方法名的末尾多了一个&lt;code&gt;Sync&lt;/code&gt;之外，异常对象与执行结果的传递方式也有相应变化。同样以&lt;code&gt;fs.readFileSync&lt;/code&gt;为例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;try {
    var data = fs.readFileSync(pathname);
    // Deal with data.
} catch (err) {
    // Deal with error.
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;fs&lt;/code&gt;模块提供的API很多，这里不一一介绍，需要时请自行查阅官方文档。&lt;/p&gt;
&lt;h4 id=&quot;3.2.4&quot;&gt;Path（路径）&lt;/h4&gt;
&lt;blockquote readability=&quot;1.7708333333333&quot;&gt;
&lt;p&gt;&lt;strong&gt;官方文档： &lt;/strong&gt;&lt;a href=&quot;http://nodejs.org/api/path.html&quot;&gt;http://nodejs.org/api/path.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;操作文件时难免不与文件路径打交道。NodeJS提供了&lt;code&gt;path&lt;/code&gt;内置模块来简化路径相关操作，并提升代码可读性。以下分别介绍几个常用的API。&lt;/p&gt;
&lt;ul readability=&quot;8.5&quot;&gt;&lt;li readability=&quot;10.5&quot;&gt;
&lt;p&gt;path.normalize&lt;/p&gt;
&lt;p&gt;将传入的路径转换为标准路径，具体讲的话，除了解析路径中的&lt;code&gt;.&lt;/code&gt;与&lt;code&gt;..&lt;/code&gt;外，还能去掉多余的斜杠。如果有程序需要使用路径作为某些数据的索引，但又允许用户随意输入路径时，就需要使用该方法保证路径的唯一性。以下是一个例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  var cache = {};

  function store(key, value) {
      cache[path.normalize(key)] = value;
  }

  store('foo/bar', 1);
  store('foo//baz//../bar', 2);
  console.log(cache);  // =&amp;gt; { &quot;foo/bar&quot;: 2 }&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;坑出没注意： &lt;/strong&gt;标准化之后的路径里的斜杠在Windows系统下是&lt;code&gt;\&lt;/code&gt;，而在Linux系统下是&lt;code&gt;/&lt;/code&gt;。如果想保证任何系统下都使用&lt;code&gt;/&lt;/code&gt;作为路径分隔符的话，需要用&lt;code&gt;.replace(/\\/g, '/')&lt;/code&gt;再替换一下标准路径。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;path.join&lt;/p&gt;
&lt;p&gt;将传入的多个路径拼接为标准路径。该方法可避免手工拼接路径字符串的繁琐，并且能在不同系统下正确使用相应的路径分隔符。以下是一个例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  path.join('foo/', 'baz/', '../bar'); // =&amp;gt; &quot;foo/bar&quot;&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;path.extname&lt;/p&gt;
&lt;p&gt;当我们需要根据不同文件扩展名做不同操作时，该方法就显得很好用。以下是一个例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  path.extname('foo/bar.js'); // =&amp;gt; &quot;.js&quot;&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;path&lt;/code&gt;模块提供的其余方法也不多，稍微看一下官方文档就能全部掌握。&lt;/p&gt;
&lt;h3 id=&quot;3.3&quot;&gt;遍历目录&lt;/h3&gt;
&lt;p&gt;遍历目录是操作文件时的一个常见需求。比如写一个程序，需要找到并处理指定目录下的所有JS文件时，就需要遍历整个目录。&lt;/p&gt;
&lt;h4 id=&quot;3.3.1&quot;&gt;递归算法&lt;/h4&gt;
&lt;p&gt;遍历目录时一般使用递归算法，否则就难以编写出简洁的代码。递归算法与数学归纳法类似，通过不断缩小问题的规模来解决问题。以下示例说明了这种方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function factorial(n) {
    if (n === 1) {
        return 1;
    } else {
        return n * factorial(n - 1);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上边的函数用于计算N的阶乘（N!）。可以看到，当N大于1时，问题简化为计算N乘以N-1的阶乘。当N等于1时，问题达到最小规模，不需要再简化，因此直接返回1。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;陷阱：&lt;/strong&gt; 使用递归算法编写的代码虽然简洁，但由于每递归一次就产生一次函数调用，在需要优先考虑性能时，需要把递归算法转换为循环算法，以减少函数调用次数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;3.3.2&quot;&gt;遍历算法&lt;/h4&gt;
&lt;p&gt;目录是一个树状结构，在遍历时一般使用深度优先+先序遍历算法。深度优先，意味着到达一个节点后，首先接着遍历子节点而不是邻居节点。先序遍历，意味着首次到达了某节点就算遍历完成，而不是最后一次返回某节点才算数。因此使用这种遍历方式时，下边这棵树的遍历顺序是&lt;code&gt;A &amp;gt; B &amp;gt; D &amp;gt; E &amp;gt; C &amp;gt; F&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;          A
         / \
        B   C
       / \   \
      D   E   F&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;3.3.3&quot;&gt;同步遍历&lt;/h4&gt;
&lt;p&gt;了解了必要的算法后，我们可以简单地实现以下目录遍历函数。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function travel(dir, callback) {
    fs.readdirSync(dir).forEach(function (file) {
        var pathname = path.join(dir, file);

        if (fs.statSync(pathname).isDirectory()) {
            travel(pathname, callback);
        } else {
            callback(pathname);
        }
    });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，该函数以某个目录作为遍历的起点。遇到一个子目录时，就先接着遍历子目录。遇到一个文件时，就把文件的绝对路径传给回调函数。回调函数拿到文件路径后，就可以做各种判断和处理。因此假设有以下目录：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;- /home/user/
    - foo/
        x.js
    - bar/
        y.js
    z.css&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用以下代码遍历该目录时，得到的输入如下。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;travel('/home/user', function (pathname) {
    console.log(pathname);
});

------------------------
/home/user/foo/x.js
/home/user/bar/y.js
/home/user/z.css&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;3.3.4&quot;&gt;异步遍历&lt;/h4&gt;
&lt;p&gt;如果读取目录或读取文件状态时使用的是异步API，目录遍历函数实现起来会有些复杂，但原理完全相同。&lt;code&gt;travel&lt;/code&gt;函数的异步版本如下。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function travel(dir, callback, finish) {
    fs.readdir(dir, function (err, files) {
        (function next(i) {
            if (i &amp;lt; files.length) {
                var pathname = path.join(dir, files[i]);

                fs.stat(pathname, function (err, stats) {
                    if (stats.isDirectory()) {
                        travel(pathname, callback, function () {
                            next(i + 1);
                        });
                    } else {
                        callback(pathname, function () {
                            next(i + 1);
                        });
                    }
                });
            } else {
                finish &amp;amp;&amp;amp; finish();
            }
        }(0));
    });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里不详细介绍异步遍历函数的编写技巧，在后续章节中会详细介绍这个。总之我们可以看到异步编程还是蛮复杂的。&lt;/p&gt;
&lt;h3 id=&quot;3.4&quot;&gt;文本编码&lt;/h3&gt;
&lt;p&gt;使用NodeJS编写前端工具时，操作得最多的是文本文件，因此也就涉及到了文件编码的处理问题。我们常用的文本编码有&lt;code&gt;UTF8&lt;/code&gt;和&lt;code&gt;GBK&lt;/code&gt;两种，并且&lt;code&gt;UTF8&lt;/code&gt;文件还可能带有BOM。在读取不同编码的文本文件时，需要将文件内容转换为JS使用的&lt;code&gt;UTF8&lt;/code&gt;编码字符串后才能正常处理。&lt;/p&gt;
&lt;h4 id=&quot;3.4.1&quot;&gt;BOM的移除&lt;/h4&gt;
&lt;p&gt;BOM用于标记一个文本文件使用Unicode编码，其本身是一个Unicode字符（&quot;\uFEFF&quot;），位于文本文件头部。在不同的Unicode编码下，BOM字符对应的二进制字节如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    Bytes      Encoding
----------------------------
    FE FF       UTF16BE
    FF FE       UTF16LE
    EF BB BF    UTF8&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因此，我们可以根据文本文件头几个字节等于啥来判断文件是否包含BOM，以及使用哪种Unicode编码。但是，BOM字符虽然起到了标记文件编码的作用，其本身却不属于文件内容的一部分，如果读取文本文件时不去掉BOM，在某些使用场景下就会有问题。例如我们把几个JS文件合并成一个文件后，如果文件中间含有BOM字符，就会导致浏览器JS语法错误。因此，使用NodeJS读取文本文件时，一般需要去掉BOM。例如，以下代码实现了识别和去除UTF8 BOM的功能。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function readText(pathname) {
    var bin = fs.readFileSync(pathname);

    if (bin[0] === 0xEF &amp;amp;&amp;amp; bin[1] === 0xBB &amp;amp;&amp;amp; bin[2] === 0xBF) {
        bin = bin.slice(3);
    }

    return bin.toString('utf-8');
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;3.4.2&quot;&gt;GBK转UTF8&lt;/h4&gt;
&lt;p&gt;NodeJS支持在读取文本文件时，或者在&lt;code&gt;Buffer&lt;/code&gt;转换为字符串时指定文本编码，但遗憾的是，GBK编码不在NodeJS自身支持范围内。因此，一般我们借助&lt;code&gt;iconv-lite&lt;/code&gt;这个三方包来转换编码。使用NPM下载该包后，我们可以按下边方式编写一个读取GBK文本文件的函数。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var iconv = require('iconv-lite');

function readGBKText(pathname) {
    var bin = fs.readFileSync(pathname);

    return iconv.decode(bin, 'gbk');
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;3.4.3&quot;&gt;单字节编码&lt;/h4&gt;
&lt;p&gt;有时候，我们无法预知需要读取的文件采用哪种编码，因此也就无法指定正确的编码。比如我们要处理的某些CSS文件中，有的用GBK编码，有的用UTF8编码。虽然可以一定程度可以根据文件的字节内容猜测出文本编码，但这里要介绍的是有些局限，但是要简单得多的一种技术。&lt;/p&gt;
&lt;p&gt;首先我们知道，如果一个文本文件只包含英文字符，比如&lt;code&gt;Hello World&lt;/code&gt;，那无论用GBK编码或是UTF8编码读取这个文件都是没问题的。这是因为在这些编码下，ASCII0~128范围内字符都使用相同的单字节编码。&lt;/p&gt;
&lt;p&gt;反过来讲，即使一个文本文件中有中文等字符，如果我们需要处理的字符仅在ASCII0~128范围内，比如除了注释和字符串以外的JS代码，我们就可以统一使用单字节编码来读取文件，不用关心文件的实际编码是GBK还是UTF8。以下示例说明了这种方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1. GBK编码源文件内容：
    var foo = '中文';
2. 对应字节：
    76 61 72 20 66 6F 6F 20 3D 20 27 D6 D0 CE C4 27 3B
3. 使用单字节编码读取后得到的内容：
    var foo = '{乱码}{乱码}{乱码}{乱码}';
4. 替换内容：
    var bar = '{乱码}{乱码}{乱码}{乱码}';
5. 使用单字节编码保存后对应字节：
    76 61 72 20 62 61 72 20 3D 20 27 D6 D0 CE C4 27 3B
6. 使用GBK编码读取后得到内容：
    var bar = '中文';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的诀窍在于，不管大于0xEF的单个字节在单字节编码下被解析成什么乱码字符，使用同样的单字节编码保存这些乱码字符时，背后对应的字节保持不变。&lt;/p&gt;
&lt;p&gt;NodeJS中自带了一种&lt;code&gt;binary&lt;/code&gt;编码可以用来实现这个方法，因此在下例中，我们使用这种编码来演示上例对应的代码该怎么写。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function replace(pathname) {
    var str = fs.readFileSync(pathname, 'binary');
    str = str.replace('foo', 'bar');
    fs.writeFileSync(pathname, str, 'binary');
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;3.5&quot;&gt;小结&lt;/h3&gt;
&lt;p&gt;本章介绍了使用NodeJS操作文件时需要的API以及一些技巧，总结起来有以下几点：&lt;/p&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;学好文件操作，编写各种程序都不怕。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如果不是很在意性能，&lt;code&gt;fs&lt;/code&gt;模块的同步API能让生活更加美好。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;需要对文件读写做到字节级别的精细控制时，请使用&lt;code&gt;fs&lt;/code&gt;模块的文件底层操作API。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;不要使用拼接字符串的方式来处理路径，使用&lt;code&gt;path&lt;/code&gt;模块。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;掌握好目录遍历和文件编码处理技巧，很实用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;4&quot;&gt;网络操作&lt;/h2&gt;
&lt;p&gt;不了解网络编程的程序员不是好前端，而NodeJS恰好提供了一扇了解网络编程的窗口。通过NodeJS，除了可以编写一些服务端程序来协助前端开发和测试外，还能够学习一些HTTP协议与Socket协议的相关知识，这些知识在优化前端性能和排查前端故障时说不定能派上用场。本章将介绍与之相关的NodeJS内置模块。&lt;/p&gt;
&lt;h3 id=&quot;4.1&quot;&gt;开门红&lt;/h3&gt;
&lt;p&gt;NodeJS本来的用途是编写高性能Web服务器。我们首先在这里重复一下官方文档里的例子，使用NodeJS内置的&lt;code&gt;http&lt;/code&gt;模块简单实现一个HTTP服务器。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var http = require('http');

http.createServer(function (request, response) {
    response.writeHead(200, { 'Content-Type': 'text-plain' });
    response.end('Hello World\n');
}).listen(8124);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上程序创建了一个HTTP服务器并监听&lt;code&gt;8124&lt;/code&gt;端口，打开浏览器访问该端口&lt;code&gt;http://127.0.0.1:8124/&lt;/code&gt;就能够看到效果。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;豆知识：&lt;/strong&gt; 在Linux系统下，监听1024以下端口需要root权限。因此，如果想监听80或443端口的话，需要使用&lt;code&gt;sudo&lt;/code&gt;命令启动程序。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;4.2&quot;&gt;API走马观花&lt;/h3&gt;
&lt;p&gt;我们先大致看看NodeJS提供了哪些和网络操作有关的API。这里并不逐一介绍每个API的使用方法，官方文档已经做得很好了。&lt;/p&gt;
&lt;h4 id=&quot;4.2.1&quot;&gt;HTTP&lt;/h4&gt;
&lt;blockquote readability=&quot;1.7708333333333&quot;&gt;
&lt;p&gt;&lt;strong&gt;官方文档： &lt;/strong&gt;&lt;a href=&quot;http://nodejs.org/api/http.html&quot;&gt;http://nodejs.org/api/http.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;'http'模块提供两种使用方式：&lt;/p&gt;
&lt;p&gt;首先我们来看看服务端模式下如何工作。如开门红中的例子所示，首先需要使用&lt;code&gt;.createServer&lt;/code&gt;方法创建一个服务器，然后调用&lt;code&gt;.listen&lt;/code&gt;方法监听端口。之后，每当来了一个客户端请求，创建服务器时传入的回调函数就被调用一次。可以看出，这是一种事件机制。&lt;/p&gt;
&lt;p&gt;HTTP请求本质上是一个数据流，由请求头（headers）和请求体（body）组成。例如以下是一个完整的HTTP请求数据内容。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;POST / HTTP/1.1
User-Agent: curl/7.26.0
Host: localhost
Accept: */*
Content-Length: 11
Content-Type: application/x-www-form-urlencoded

Hello World&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，空行之上是请求头，之下是请求体。HTTP请求在发送给服务器时，可以认为是按照从头到尾的顺序一个字节一个字节地以数据流方式发送的。而&lt;code&gt;http&lt;/code&gt;模块创建的HTTP服务器在接收到完整的请求头后，就会调用回调函数。在回调函数中，除了可以使用&lt;code&gt;request&lt;/code&gt;对象访问请求头数据外，还能把&lt;code&gt;request&lt;/code&gt;对象当作一个只读数据流来访问请求体数据。以下是一个例子。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;http.createServer(function (request, response) {
    var body = [];

    console.log(request.method);
    console.log(request.headers);

    request.on('data', function (chunk) {
        body.push(chunk);
    });

    request.on('end', function () {
        body = Buffer.concat(body);
        console.log(body.toString());
    });
}).listen(80);

------------------------------------
POST
{ 'user-agent': 'curl/7.26.0',
  host: 'localhost',
  accept: '*/*',
  'content-length': '11',
  'content-type': 'application/x-www-form-urlencoded' }
Hello World&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;HTTP响应本质上也是一个数据流，同样由响应头（headers）和响应体（body）组成。例如以下是一个完整的HTTP请求数据内容。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;HTTP/1.1 200 OK
Content-Type: text/plain
Content-Length: 11
Date: Tue, 05 Nov 2013 05:31:38 GMT
Connection: keep-alive

Hello World&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在回调函数中，除了可以使用&lt;code&gt;response&lt;/code&gt;对象来写入响应头数据外，还能把&lt;code&gt;response&lt;/code&gt;对象当作一个只写数据流来写入响应体数据。例如在以下例子中，服务端原样将客户端请求的请求体数据返回给客户端。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;http.createServer(function (request, response) {
    response.writeHead(200, { 'Content-Type': 'text/plain' });

    request.on('data', function (chunk) {
        response.write(chunk);
    });

    request.on('end', function () {
        response.end();
    });
}).listen(80);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来我们看看客户端模式下如何工作。为了发起一个客户端HTTP请求，我们需要指定目标服务器的位置并发送请求头和请求体，以下示例演示了具体做法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var options = {
        hostname: 'www.example.com',
        port: 80,
        path: '/upload',
        method: 'POST',
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded'
        }
    };

var request = http.request(options, function (response) {});

request.write('Hello World');
request.end();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，&lt;code&gt;.request&lt;/code&gt;方法创建了一个客户端，并指定请求目标和请求头数据。之后，就可以把&lt;code&gt;request&lt;/code&gt;对象当作一个只写数据流来写入请求体数据和结束请求。另外，由于HTTP请求中&lt;code&gt;GET&lt;/code&gt;请求是最常见的一种，并且不需要请求体，因此&lt;code&gt;http&lt;/code&gt;模块也提供了以下便捷API。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;http.get('http://www.example.com/', function (response) {});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当客户端发送请求并接收到完整的服务端响应头时，就会调用回调函数。在回调函数中，除了可以使用&lt;code&gt;response&lt;/code&gt;对象访问响应头数据外，还能把&lt;code&gt;response&lt;/code&gt;对象当作一个只读数据流来访问响应体数据。以下是一个例子。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;http.get('http://www.example.com/', function (response) {
    var body = [];

    console.log(response.statusCode);
    console.log(response.headers);

    response.on('data', function (chunk) {
        body.push(chunk);
    });

    response.on('end', function () {
        body = Buffer.concat(body);
        console.log(body.toString());
    });
});

------------------------------------
200
{ 'content-type': 'text/html',
  server: 'Apache',
  'content-length': '801',
  date: 'Tue, 05 Nov 2013 06:08:41 GMT',
  connection: 'keep-alive' }
&amp;lt;!DOCTYPE html&amp;gt;
...&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;4.2.2&quot;&gt;HTTPS&lt;/h4&gt;
&lt;blockquote readability=&quot;1.734693877551&quot;&gt;
&lt;p&gt;&lt;strong&gt;官方文档： &lt;/strong&gt;&lt;a href=&quot;http://nodejs.org/api/https.html&quot;&gt;http://nodejs.org/api/https.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;https&lt;/code&gt;模块与&lt;code&gt;http&lt;/code&gt;模块极为类似，区别在于&lt;code&gt;https&lt;/code&gt;模块需要额外处理SSL证书。&lt;/p&gt;
&lt;p&gt;在服务端模式下，创建一个HTTPS服务器的示例如下。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var options = {
        key: fs.readFileSync('./ssl/default.key'),
        cert: fs.readFileSync('./ssl/default.cer')
    };

var server = https.createServer(options, function (request, response) {
        // ...
    });&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，与创建HTTP服务器相比，多了一个&lt;code&gt;options&lt;/code&gt;对象，通过&lt;code&gt;key&lt;/code&gt;和&lt;code&gt;cert&lt;/code&gt;字段指定了HTTPS服务器使用的私钥和公钥。&lt;/p&gt;
&lt;p&gt;另外，NodeJS支持SNI技术，可以根据HTTPS客户端请求使用的域名动态使用不同的证书，因此同一个HTTPS服务器可以使用多个域名提供服务。接着上例，可以使用以下方法为HTTPS服务器添加多组证书。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;server.addContext('foo.com', {
    key: fs.readFileSync('./ssl/foo.com.key'),
    cert: fs.readFileSync('./ssl/foo.com.cer')
});

server.addContext('bar.com', {
    key: fs.readFileSync('./ssl/bar.com.key'),
    cert: fs.readFileSync('./ssl/bar.com.cer')
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在客户端模式下，发起一个HTTPS客户端请求与&lt;code&gt;http&lt;/code&gt;模块几乎相同，示例如下。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var options = {
        hostname: 'www.example.com',
        port: 443,
        path: '/',
        method: 'GET'
    };

var request = https.request(options, function (response) {});

request.end();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但如果目标服务器使用的SSL证书是自制的，不是从颁发机构购买的，默认情况下&lt;code&gt;https&lt;/code&gt;模块会拒绝连接，提示说有证书安全问题。在&lt;code&gt;options&lt;/code&gt;里加入&lt;code&gt;rejectUnauthorized: false&lt;/code&gt;字段可以禁用对证书有效性的检查，从而允许&lt;code&gt;https&lt;/code&gt;模块请求开发环境下使用自制证书的HTTPS服务器。&lt;/p&gt;
&lt;h4 id=&quot;4.2.3&quot;&gt;URL&lt;/h4&gt;
&lt;blockquote readability=&quot;1.8085106382979&quot;&gt;
&lt;p&gt;&lt;strong&gt;官方文档： &lt;/strong&gt;&lt;a href=&quot;http://nodejs.org/api/url.html&quot;&gt;http://nodejs.org/api/url.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;处理HTTP请求时&lt;code&gt;url&lt;/code&gt;模块使用率超高，因为该模块允许解析URL、生成URL，以及拼接URL。首先我们来看看一个完整的URL的各组成部分。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;                           href
 -----------------------------------------------------------------
                            host              path
                      --------------- ----------------------------
 http: // user:pass @ host.com : 8080 /p/a/t/h ?query=string #hash
 -----    ---------   --------   ---- -------- ------------- -----
protocol     auth     hostname   port pathname     search     hash
                                                ------------
                                                   query&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以使用&lt;code&gt;.parse&lt;/code&gt;方法来将一个URL字符串转换为URL对象，示例如下。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;url.parse('http://user:pass@host.com:8080/p/a/t/h?query=string#hash');
/* =&amp;gt;
{ protocol: 'http:',
  auth: 'user:pass',
  host: 'host.com:8080',
  port: '8080',
  hostname: 'host.com',
  hash: '#hash',
  search: '?query=string',
  query: 'query=string',
  pathname: '/p/a/t/h',
  path: '/p/a/t/h?query=string',
  href: 'http://user:pass@host.com:8080/p/a/t/h?query=string#hash' }
*/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;传给&lt;code&gt;.parse&lt;/code&gt;方法的不一定要是一个完整的URL，例如在HTTP服务器回调函数中，&lt;code&gt;request.url&lt;/code&gt;不包含协议头和域名，但同样可以用&lt;code&gt;.parse&lt;/code&gt;方法解析。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;http.createServer(function (request, response) {
    var tmp = request.url; // =&amp;gt; &quot;/foo/bar?a=b&quot;
    url.parse(tmp);
    /* =&amp;gt;
    { protocol: null,
      slashes: null,
      auth: null,
      host: null,
      port: null,
      hostname: null,
      hash: null,
      search: '?a=b',
      query: 'a=b',
      pathname: '/foo/bar',
      path: '/foo/bar?a=b',
      href: '/foo/bar?a=b' }
    */
}).listen(80);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;.parse&lt;/code&gt;方法还支持第二个和第三个布尔类型可选参数。第二个参数等于&lt;code&gt;true&lt;/code&gt;时，该方法返回的URL对象中，&lt;code&gt;query&lt;/code&gt;字段不再是一个字符串，而是一个经过&lt;code&gt;querystring&lt;/code&gt;模块转换后的参数对象。第三个参数等于&lt;code&gt;true&lt;/code&gt;时，该方法可以正确解析不带协议头的URL，例如&lt;code&gt;//www.example.com/foo/bar&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;反过来，&lt;code&gt;format&lt;/code&gt;方法允许将一个URL对象转换为URL字符串，示例如下。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;url.format({
    protocol: 'http:',
    host: 'www.example.com',
    pathname: '/p/a/t/h',
    search: 'query=string'
});
/* =&amp;gt;
'http://www.example.com/p/a/t/h?query=string'
*/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另外，&lt;code&gt;.resolve&lt;/code&gt;方法可以用于拼接URL，示例如下。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;url.resolve('http://www.example.com/foo/bar', '../baz');
/* =&amp;gt;
http://www.example.com/baz
*/&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;4.2.4&quot;&gt;Query String&lt;/h4&gt;
&lt;blockquote readability=&quot;1.5454545454545&quot;&gt;
&lt;p&gt;&lt;strong&gt;官方文档： &lt;/strong&gt;&lt;a href=&quot;http://nodejs.org/api/querystring.html&quot;&gt;http://nodejs.org/api/querystring.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;querystring&lt;/code&gt;模块用于实现URL参数字符串与参数对象的互相转换，示例如下。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;querystring.parse('foo=bar&amp;amp;baz=qux&amp;amp;baz=quux&amp;amp;corge');
/* =&amp;gt;
{ foo: 'bar', baz: ['qux', 'quux'], corge: '' }
*/

querystring.stringify({ foo: 'bar', baz: ['qux', 'quux'], corge: '' });
/* =&amp;gt;
'foo=bar&amp;amp;baz=qux&amp;amp;baz=quux&amp;amp;corge='
*/&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;4.2.5&quot;&gt;Zlib&lt;/h4&gt;
&lt;blockquote readability=&quot;1.7708333333333&quot;&gt;
&lt;p&gt;&lt;strong&gt;官方文档： &lt;/strong&gt;&lt;a href=&quot;http://nodejs.org/api/zlib.html&quot;&gt;http://nodejs.org/api/zlib.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;zlib&lt;/code&gt;模块提供了数据压缩和解压的功能。当我们处理HTTP请求和响应时，可能需要用到这个模块。&lt;/p&gt;
&lt;p&gt;首先我们看一个使用&lt;code&gt;zlib&lt;/code&gt;模块压缩HTTP响应体数据的例子。这个例子中，判断了客户端是否支持gzip，并在支持的情况下使用&lt;code&gt;zlib&lt;/code&gt;模块返回gzip之后的响应体数据。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;http.createServer(function (request, response) {
    var i = 1024,
        data = '';

    while (i--) {
        data += '.';
    }

    if ((request.headers['accept-encoding'] || '').indexOf('gzip') !== -1) {
        zlib.gzip(data, function (err, data) {
            response.writeHead(200, {
                'Content-Type': 'text/plain',
                'Content-Encoding': 'gzip'
            });
            response.end(data);
        });
    } else {
        response.writeHead(200, {
            'Content-Type': 'text/plain'
        });
        response.end(data);
    }
}).listen(80);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着我们看一个使用&lt;code&gt;zlib&lt;/code&gt;模块解压HTTP响应体数据的例子。这个例子中，判断了服务端响应是否使用gzip压缩，并在压缩的情况下使用&lt;code&gt;zlib&lt;/code&gt;模块解压响应体数据。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var options = {
        hostname: 'www.example.com',
        port: 80,
        path: '/',
        method: 'GET',
        headers: {
            'Accept-Encoding': 'gzip, deflate'
        }
    };

http.request(options, function (response) {
    var body = [];

    response.on('data', function (chunk) {
        body.push(chunk);
    });

    response.on('end', function () {
        body = Buffer.concat(body);

        if (response.headers['content-encoding'] === 'gzip') {
            zlib.gunzip(body, function (err, data) {
                console.log(data.toString());
            });
        } else {
            console.log(data.toString());
        }
    });
}).end();&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;4.2.6&quot;&gt;Net&lt;/h4&gt;
&lt;blockquote readability=&quot;1.8085106382979&quot;&gt;
&lt;p&gt;&lt;strong&gt;官方文档： &lt;/strong&gt;&lt;a href=&quot;http://nodejs.org/api/net.html&quot;&gt;http://nodejs.org/api/net.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;net&lt;/code&gt;模块可用于创建Socket服务器或Socket客户端。由于Socket在前端领域的使用范围还不是很广，这里先不涉及到WebSocket的介绍，仅仅简单演示一下如何从Socket层面来实现HTTP请求和响应。&lt;/p&gt;
&lt;p&gt;首先我们来看一个使用Socket搭建一个很不严谨的HTTP服务器的例子。这个HTTP服务器不管收到啥请求，都固定返回相同的响应。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;net.createServer(function (conn) {
    conn.on('data', function (data) {
        conn.write([
            'HTTP/1.1 200 OK',
            'Content-Type: text/plain',
            'Content-Length: 11',
            '',
            'Hello World'
        ].join('\n'));
    });
}).listen(80);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着我们来看一个使用Socket发起HTTP客户端请求的例子。这个例子中，Socket客户端在建立连接后发送了一个HTTP GET请求，并通过&lt;code&gt;data&lt;/code&gt;事件监听函数来获取服务器响应。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var options = {
        port: 80,
        host: 'www.example.com'
    };

var client = net.connect(options, function () {
        client.write([
            'GET / HTTP/1.1',
            'User-Agent: curl/7.26.0',
            'Host: www.baidu.com',
            'Accept: */*',
            '',
            ''
        ].join('\n'));
    });

client.on('data', function (data) {
    console.log(data.toString());
    client.end();
});&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;4.3&quot;&gt;灵机一点&lt;/h3&gt;
&lt;p&gt;使用NodeJS操作网络，特别是操作HTTP请求和响应时会遇到一些惊喜，这里对一些常见问题做解答。&lt;/p&gt;
&lt;ul readability=&quot;8&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;问： 为什么通过&lt;code&gt;headers&lt;/code&gt;对象访问到的HTTP请求头或响应头字段不是驼峰的？&lt;/p&gt;
&lt;p&gt;答： 从规范上讲，HTTP请求头和响应头字段都应该是驼峰的。但现实是残酷的，不是每个HTTP服务端或客户端程序都严格遵循规范，所以NodeJS在处理从别的客户端或服务端收到的头字段时，都统一地转换为了小写字母格式，以便开发者能使用统一的方式来访问头字段，例如&lt;code&gt;headers['content-length']&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;问： 为什么&lt;code&gt;http&lt;/code&gt;模块创建的HTTP服务器返回的响应是&lt;code&gt;chunked&lt;/code&gt;传输方式的？&lt;/p&gt;
&lt;p&gt;答： 因为默认情况下，使用&lt;code&gt;.writeHead&lt;/code&gt;方法写入响应头后，允许使用&lt;code&gt;.write&lt;/code&gt;方法写入任意长度的响应体数据，并使用&lt;code&gt;.end&lt;/code&gt;方法结束一个响应。由于响应体数据长度不确定，因此NodeJS自动在响应头里添加了&lt;code&gt;Transfer-Encoding: chunked&lt;/code&gt;字段，并采用&lt;code&gt;chunked&lt;/code&gt;传输方式。但是当响应体数据长度确定时，可使用&lt;code&gt;.writeHead&lt;/code&gt;方法在响应头里加上&lt;code&gt;Content-Length&lt;/code&gt;字段，这样做之后NodeJS就不会自动添加&lt;code&gt;Transfer-Encoding&lt;/code&gt;字段和使用&lt;code&gt;chunked&lt;/code&gt;传输方式。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;问： 为什么使用&lt;code&gt;http&lt;/code&gt;模块发起HTTP客户端请求时，有时候会发生&lt;code&gt;socket hang up&lt;/code&gt;错误？&lt;/p&gt;
&lt;p&gt;答： 发起客户端HTTP请求前需要先创建一个客户端。&lt;code&gt;http&lt;/code&gt;模块提供了一个全局客户端&lt;code&gt;http.globalAgent&lt;/code&gt;，可以让我们使用&lt;code&gt;.request&lt;/code&gt;或&lt;code&gt;.get&lt;/code&gt;方法时不用手动创建客户端。但是全局客户端默认只允许5个并发Socket连接，当某一个时刻HTTP客户端请求创建过多，超过这个数字时，就会发生&lt;code&gt;socket hang up&lt;/code&gt;错误。解决方法也很简单，通过&lt;code&gt;http.globalAgent.maxSockets&lt;/code&gt;属性把这个数字改大些即可。另外，&lt;code&gt;https&lt;/code&gt;模块遇到这个问题时也一样通过&lt;code&gt;https.globalAgent.maxSockets&lt;/code&gt;属性来处理。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;4.4&quot;&gt;小结&lt;/h3&gt;
&lt;p&gt;本章介绍了使用NodeJS操作网络时需要的API以及一些坑回避技巧，总结起来有以下几点：&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;http&lt;/code&gt;和&lt;code&gt;https&lt;/code&gt;模块支持服务端模式和客户端模式两种使用方式。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;request&lt;/code&gt;和&lt;code&gt;response&lt;/code&gt;对象除了用于读写头数据外，都可以当作数据流来操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;url.parse&lt;/code&gt;方法加上&lt;code&gt;request.url&lt;/code&gt;属性是处理HTTP请求时的固定搭配。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;使用&lt;code&gt;zlib&lt;/code&gt;模块可以减少使用HTTP协议时的数据传输量。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;通过&lt;code&gt;net&lt;/code&gt;模块的Socket服务器与客户端可对HTTP协议做底层操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;小心踩坑。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;5&quot;&gt;进程管理&lt;/h2&gt;
&lt;p&gt;NodeJS可以感知和控制自身进程的运行环境和状态，也可以创建子进程并与其协同工作，这使得NodeJS可以把多个程序组合在一起共同完成某项工作，并在其中充当胶水和调度器的作用。本章除了介绍与之相关的NodeJS内置模块外，还会重点介绍典型的使用场景。&lt;/p&gt;
&lt;h3 id=&quot;5.1&quot;&gt;开门红&lt;/h3&gt;
&lt;p&gt;我们已经知道了NodeJS自带的&lt;code&gt;fs&lt;/code&gt;模块比较基础，把一个目录里的所有文件和子目录都拷贝到另一个目录里需要写不少代码。另外我们也知道，终端下的&lt;code&gt;cp&lt;/code&gt;命令比较好用，一条&lt;code&gt;cp -r source/* target&lt;/code&gt;命令就能搞定目录拷贝。那我们首先看看如何使用NodeJS调用终端命令来简化目录拷贝，示例代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var child_process = require('child_process');
var util = require('util');

function copy(source, target, callback) {
    child_process.exec(
        util.format('cp -r %s/* %s', source, target), callback);
}

copy('a', 'b', function (err) {
    // ...
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从以上代码中可以看到，子进程是异步运行的，通过回调函数返回执行结果。&lt;/p&gt;
&lt;h3 id=&quot;5.2&quot;&gt;API走马观花&lt;/h3&gt;
&lt;p&gt;我们先大致看看NodeJS提供了哪些和进程管理有关的API。这里并不逐一介绍每个API的使用方法，官方文档已经做得很好了。&lt;/p&gt;
&lt;h4 id=&quot;5.2.1&quot;&gt;Process&lt;/h4&gt;
&lt;blockquote readability=&quot;1.6666666666667&quot;&gt;
&lt;p&gt;&lt;strong&gt;官方文档： &lt;/strong&gt;&lt;a href=&quot;http://nodejs.org/api/process.html&quot;&gt;http://nodejs.org/api/process.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;任何一个进程都有启动进程时使用的命令行参数，有标准输入标准输出，有运行权限，有运行环境和运行状态。在NodeJS中，可以通过&lt;code&gt;process&lt;/code&gt;对象感知和控制NodeJS自身进程的方方面面。另外需要注意的是，&lt;code&gt;process&lt;/code&gt;不是内置模块，而是一个全局对象，因此在任何地方都可以直接使用。&lt;/p&gt;
&lt;h4 id=&quot;5.2.2&quot;&gt;Child Process&lt;/h4&gt;
&lt;blockquote readability=&quot;1.4912280701754&quot;&gt;
&lt;p&gt;&lt;strong&gt;官方文档： &lt;/strong&gt;&lt;a href=&quot;http://nodejs.org/api/child_process.html&quot;&gt;http://nodejs.org/api/child_process.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用&lt;code&gt;child_process&lt;/code&gt;模块可以创建和控制子进程。该模块提供的API中最核心的是&lt;code&gt;.spawn&lt;/code&gt;，其余API都是针对特定使用场景对它的进一步封装，算是一种语法糖。&lt;/p&gt;
&lt;h4 id=&quot;5.2.3&quot;&gt;Cluster&lt;/h4&gt;
&lt;blockquote readability=&quot;1.6666666666667&quot;&gt;
&lt;p&gt;&lt;strong&gt;官方文档： &lt;/strong&gt;&lt;a href=&quot;http://nodejs.org/api/cluster.html&quot;&gt;http://nodejs.org/api/cluster.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;cluster&lt;/code&gt;模块是对&lt;code&gt;child_process&lt;/code&gt;模块的进一步封装，专用于解决单进程NodeJS Web服务器无法充分利用多核CPU的问题。使用该模块可以简化多进程服务器程序的开发，让每个核上运行一个工作进程，并统一通过主进程监听端口和分发请求。&lt;/p&gt;
&lt;h3 id=&quot;5.3&quot;&gt;应用场景&lt;/h3&gt;
&lt;p&gt;和进程管理相关的API单独介绍起来比较枯燥，因此这里从一些典型的应用场景出发，分别介绍一些重要API的使用方法。&lt;/p&gt;
&lt;h4 id=&quot;5.3.1&quot;&gt;如何获取命令行参数&lt;/h4&gt;
&lt;p&gt;在NodeJS中可以通过&lt;code&gt;process.argv&lt;/code&gt;获取命令行参数。但是比较意外的是，&lt;code&gt;node&lt;/code&gt;执行程序路径和主模块文件路径固定占据了&lt;code&gt;argv[0]&lt;/code&gt;和&lt;code&gt;argv[1]&lt;/code&gt;两个位置，而第一个命令行参数从&lt;code&gt;argv[2]&lt;/code&gt;开始。为了让&lt;code&gt;argv&lt;/code&gt;使用起来更加自然，可以按照以下方式处理。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function main(argv) {
    // ...
}

main(process.argv.slice(2));&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;5.3.2&quot;&gt;如何退出程序&lt;/h4&gt;
&lt;p&gt;通常一个程序做完所有事情后就正常退出了，这时程序的退出状态码为&lt;code&gt;0&lt;/code&gt;。或者一个程序运行时发生了异常后就挂了，这时程序的退出状态码不等于&lt;code&gt;0&lt;/code&gt;。如果我们在代码中捕获了某个异常，但是觉得程序不应该继续运行下去，需要立即退出，并且需要把退出状态码设置为指定数字，比如&lt;code&gt;1&lt;/code&gt;，就可以按照以下方式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;try {
    // ...
} catch (err) {
    // ...
    process.exit(1);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;5.3.3&quot;&gt;如何控制输入输出&lt;/h4&gt;
&lt;p&gt;NodeJS程序的标准输入流（stdin）、一个标准输出流（stdout）、一个标准错误流（stderr）分别对应&lt;code&gt;process.stdin&lt;/code&gt;、&lt;code&gt;process.stdout&lt;/code&gt;和&lt;code&gt;process.stderr&lt;/code&gt;，第一个是只读数据流，后边两个是只写数据流，对它们的操作按照对数据流的操作方式即可。例如，&lt;code&gt;console.log&lt;/code&gt;可以按照以下方式实现。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function log() {
    process.stdout.write(
        util.format.apply(util, arguments) + '\n');
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;5.3.4&quot;&gt;如何降权&lt;/h4&gt;
&lt;p&gt;在Linux系统下，我们知道需要使用root权限才能监听1024以下端口。但是一旦完成端口监听后，继续让程序运行在root权限下存在安全隐患，因此最好能把权限降下来。以下是这样一个例子。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;http.createServer(callback).listen(80, function () {
    var env = process.env,
        uid = parseInt(env['SUDO_UID'] || process.getuid(), 10),
        gid = parseInt(env['SUDO_GID'] || process.getgid(), 10);

    process.setgid(gid);
    process.setuid(uid);
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上例中有几点需要注意：&lt;/p&gt;
&lt;ol readability=&quot;1&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;如果是通过&lt;code&gt;sudo&lt;/code&gt;获取root权限的，运行程序的用户的UID和GID保存在环境变量&lt;code&gt;SUDO_UID&lt;/code&gt;和&lt;code&gt;SUDO_GID&lt;/code&gt;里边。如果是通过&lt;code&gt;chmod +s&lt;/code&gt;方式获取root权限的，运行程序的用户的UID和GID可直接通过&lt;code&gt;process.getuid&lt;/code&gt;和&lt;code&gt;process.getgid&lt;/code&gt;方法获取。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;process.setuid&lt;/code&gt;和&lt;code&gt;process.setgid&lt;/code&gt;方法只接受&lt;code&gt;number&lt;/code&gt;类型的参数。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;降权时必须先降GID再降UID，否则顺序反过来的话就没权限更改程序的GID了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;5.3.5&quot;&gt;如何创建子进程&lt;/h4&gt;
&lt;p&gt;以下是一个创建NodeJS子进程的例子。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var child = child_process.spawn('node', [ 'xxx.js' ]);

child.stdout.on('data', function (data) {
    console.log('stdout: ' + data);
});

child.stderr.on('data', function (data) {
    console.log('stderr: ' + data);
});

child.on('close', function (code) {
    console.log('child process exited with code ' + code);
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上例中使用了&lt;code&gt;.spawn(exec, args, options)&lt;/code&gt;方法，该方法支持三个参数。第一个参数是执行文件路径，可以是执行文件的相对或绝对路径，也可以是根据PATH环境变量能找到的执行文件名。第二个参数中，数组中的每个成员都按顺序对应一个命令行参数。第三个参数可选，用于配置子进程的执行环境与行为。&lt;/p&gt;
&lt;p&gt;另外，上例中虽然通过子进程对象的&lt;code&gt;.stdout&lt;/code&gt;和&lt;code&gt;.stderr&lt;/code&gt;访问子进程的输出，但通过&lt;code&gt;options.stdio&lt;/code&gt;字段的不同配置，可以将子进程的输入输出重定向到任何数据流上，或者让子进程共享父进程的标准输入输出流，或者直接忽略子进程的输入输出。&lt;/p&gt;
&lt;h4 id=&quot;5.3.6&quot;&gt;进程间如何通讯&lt;/h4&gt;
&lt;p&gt;在Linux系统下，进程之间可以通过信号互相通信。以下是一个例子。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/* parent.js */
var child = child_process.spawn('node', [ 'child.js' ]);

child.kill('SIGTERM');

/* child.js */
process.on('SIGTERM', function () {
    cleanUp();
    process.exit(0);
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上例中，父进程通过&lt;code&gt;.kill&lt;/code&gt;方法向子进程发送&lt;code&gt;SIGTERM&lt;/code&gt;信号，子进程监听&lt;code&gt;process&lt;/code&gt;对象的&lt;code&gt;SIGTERM&lt;/code&gt;事件响应信号。不要被&lt;code&gt;.kill&lt;/code&gt;方法的名称迷惑了，该方法本质上是用来给进程发送信号的，进程收到信号后具体要做啥，完全取决于信号的种类和进程自身的代码。&lt;/p&gt;
&lt;p&gt;另外，如果父子进程都是NodeJS进程，就可以通过IPC（进程间通讯）双向传递数据。以下是一个例子。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/* parent.js */
var child = child_process.spawn('node', [ 'child.js' ], {
        stdio: [ 0, 1, 2, 'ipc' ]
    });

child.on('message', function (msg) {
    console.log(msg);
});

child.send({ hello: 'hello' });

/* child.js */
process.on('message', function (msg) {
    msg.hello = msg.hello.toUpperCase();
    process.send(msg);
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，父进程在创建子进程时，在&lt;code&gt;options.stdio&lt;/code&gt;字段中通过&lt;code&gt;ipc&lt;/code&gt;开启了一条IPC通道，之后就可以监听子进程对象的&lt;code&gt;message&lt;/code&gt;事件接收来自子进程的消息，并通过&lt;code&gt;.send&lt;/code&gt;方法给子进程发送消息。在子进程这边，可以在&lt;code&gt;process&lt;/code&gt;对象上监听&lt;code&gt;message&lt;/code&gt;事件接收来自父进程的消息，并通过&lt;code&gt;.send&lt;/code&gt;方法向父进程发送消息。数据在传递过程中，会先在发送端使用&lt;code&gt;JSON.stringify&lt;/code&gt;方法序列化，再在接收端使用&lt;code&gt;JSON.parse&lt;/code&gt;方法反序列化。&lt;/p&gt;
&lt;h4 id=&quot;5.3.7&quot;&gt;如何守护子进程&lt;/h4&gt;
&lt;p&gt;守护进程一般用于监控工作进程的运行状态，在工作进程不正常退出时重启工作进程，保障工作进程不间断运行。以下是一种实现方式。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/* daemon.js */
function spawn(mainModule) {
    var worker = child_process.spawn('node', [ mainModule ]);

    worker.on('exit', function (code) {
        if (code !== 0) {
            spawn(mainModule);
        }
    });
}

spawn('worker.js');&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，工作进程非正常退出时，守护进程立即重启工作进程。&lt;/p&gt;
&lt;h3 id=&quot;5.4&quot;&gt;小结&lt;/h3&gt;
&lt;p&gt;本章介绍了使用NodeJS管理进程时需要的API以及主要的应用场景，总结起来有以下几点：&lt;/p&gt;
&lt;h2 id=&quot;6&quot;&gt;异步编程&lt;/h2&gt;
&lt;p&gt;NodeJS最大的卖点——事件机制和异步IO，对开发者并不是透明的。开发者需要按异步方式编写代码才用得上这个卖点，而这一点也遭到了一些NodeJS反对者的抨击。但不管怎样，异步编程确实是NodeJS最大的特点，没有掌握异步编程就不能说是真正学会了NodeJS。本章将介绍与异步编程相关的各种知识。&lt;/p&gt;
&lt;h3 id=&quot;6.1&quot;&gt;回调&lt;/h3&gt;
&lt;p&gt;在代码中，异步编程的直接体现就是回调。异步编程依托于回调来实现，但不能说使用了回调后程序就异步化了。我们首先可以看看以下代码。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function heavyCompute(n, callback) {
    var count = 0,
        i, j;

    for (i = n; i &amp;gt; 0; --i) {
        for (j = n; j &amp;gt; 0; --j) {
            count += 1;
        }
    }

    callback(count);
}

heavyCompute(10000, function (count) {
    console.log(count);
});

console.log('hello');

-- Console ------------------------------
100000000
hello&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，以上代码中的回调函数仍然先于后续代码执行。JS本身是单线程运行的，不可能在一段代码还未结束运行时去运行别的代码，因此也就不存在异步执行的概念。&lt;/p&gt;
&lt;p&gt;但是，如果某个函数做的事情是创建一个别的线程或进程，并与JS主线程并行地做一些事情，并在事情做完后通知JS主线程，那情况又不一样了。我们接着看看以下代码。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;setTimeout(function () {
    console.log('world');
}, 1000);

console.log('hello');

-- Console ------------------------------
hello
world&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这次可以看到，回调函数后于后续代码执行了。如同上边所说，JS本身是单线程的，无法异步执行，因此我们可以认为&lt;code&gt;setTimeout&lt;/code&gt;这类JS规范之外的由运行环境提供的特殊函数做的事情是创建一个平行线程后立即返回，让JS主进程可以接着执行后续代码，并在收到平行进程的通知后再执行回调函数。除了&lt;code&gt;setTimeout&lt;/code&gt;、&lt;code&gt;setInterval&lt;/code&gt;这些常见的，这类函数还包括NodeJS提供的诸如&lt;code&gt;fs.readFile&lt;/code&gt;之类的异步API。&lt;/p&gt;
&lt;p&gt;另外，我们仍然回到JS是单线程运行的这个事实上，这决定了JS在执行完一段代码之前无法执行包括回调函数在内的别的代码。也就是说，即使平行线程完成工作了，通知JS主线程执行回调函数了，回调函数也要等到JS主线程空闲时才能开始执行。以下就是这么一个例子。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function heavyCompute(n) {
    var count = 0,
        i, j;

    for (i = n; i &amp;gt; 0; --i) {
        for (j = n; j &amp;gt; 0; --j) {
            count += 1;
        }
    }
}

var t = new Date();

setTimeout(function () {
    console.log(new Date() - t);
}, 1000);

heavyCompute(50000);

-- Console ------------------------------
8520&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，本来应该在1秒后被调用的回调函数因为JS主线程忙于运行其它代码，实际执行时间被大幅延迟。&lt;/p&gt;
&lt;h3 id=&quot;6.2&quot;&gt;代码设计模式&lt;/h3&gt;
&lt;p&gt;异步编程有很多特有的代码设计模式，为了实现同样的功能，使用同步方式和异步方式编写的代码会有很大差异。以下分别介绍一些常见的模式。&lt;/p&gt;
&lt;h4 id=&quot;6.2.1&quot;&gt;函数返回值&lt;/h4&gt;
&lt;p&gt;使用一个函数的输出作为另一个函数的输入是很常见的需求，在同步方式下一般按以下方式编写代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var output = fn1(fn2('input'));
// Do something.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而在异步方式下，由于函数执行结果不是通过返回值，而是通过回调函数传递，因此一般按以下方式编写代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;fn2('input', function (output2) {
    fn1(output2, function (output1) {
        // Do something.
    });
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，这种方式就是一个回调函数套一个回调函多，套得太多了很容易写出&lt;code&gt;&amp;gt;&lt;/code&gt;形状的代码。&lt;/p&gt;
&lt;h4 id=&quot;6.2.2&quot;&gt;遍历数组&lt;/h4&gt;
&lt;p&gt;在遍历数组时，使用某个函数依次对数据成员做一些处理也是常见的需求。如果函数是同步执行的，一般就会写出以下代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var len = arr.length,
    i = 0;

for (; i &amp;lt; len; ++i) {
    arr[i] = sync(arr[i]);
}

// All array items have processed.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果函数是异步执行的，以上代码就无法保证循环结束后所有数组成员都处理完毕了。如果数组成员必须一个接一个串行处理，则一般按照以下方式编写异步代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;(function next(i, len, callback) {
    if (i &amp;lt; len) {
        async(arr[i], function (value) {
            arr[i] = value;
            next(i + 1, len, callback);
        });
    } else {
        callback();
    }
}(0, arr.length, function () {
    // All array items have processed.
}));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，以上代码在异步函数执行一次并返回执行结果后才传入下一个数组成员并开始下一轮执行，直到所有数组成员处理完毕后，通过回调的方式触发后续代码的执行。&lt;/p&gt;
&lt;p&gt;如果数组成员可以并行处理，但后续代码仍然需要所有数组成员处理完毕后才能执行的话，则异步代码会调整成以下形式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;(function (i, len, count, callback) {
    for (; i &amp;lt; len; ++i) {
        (function (i) {
            async(arr[i], function (value) {
                arr[i] = value;
                if (++count === len) {
                    callback();
                }
            });
        }(i));
    }
}(0, arr.length, 0, function () {
    // All array items have processed.
}));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，与异步串行遍历的版本相比，以上代码并行处理所有数组成员，并通过计数器变量来判断什么时候所有数组成员都处理完毕了。&lt;/p&gt;
&lt;h4 id=&quot;6.2.3&quot;&gt;异常处理&lt;/h4&gt;
&lt;p&gt;JS自身提供的异常捕获和处理机制——&lt;code&gt;try..catch..&lt;/code&gt;，只能用于同步执行的代码。以下是一个例子。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function sync(fn) {
    return fn();
}

try {
    sync(null);
    // Do something.
} catch (err) {
    console.log('Error: %s', err.message);
}

-- Console ------------------------------
Error: object is not a function&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，异常会沿着代码执行路径一直冒泡，直到遇到第一个&lt;code&gt;try&lt;/code&gt;语句时被捕获住。但由于异步函数会打断代码执行路径，异步函数执行过程中以及执行之后产生的异常冒泡到执行路径被打断的位置时，如果一直没有遇到&lt;code&gt;try&lt;/code&gt;语句，就作为一个全局异常抛出。以下是一个例子。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function async(fn, callback) {
    // Code execution path breaks here.
    setTimeout(function ()　{
        callback(fn());
    }, 0);
}

try {
    async(null, function (data) {
        // Do something.
    });
} catch (err) {
    console.log('Error: %s', err.message);
}

-- Console ------------------------------
/home/user/test.js:4
        callback(fn());
                 ^
TypeError: object is not a function
    at null._onTimeout (/home/user/test.js:4:13)
    at Timer.listOnTimeout [as ontimeout] (timers.js:110:15)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为代码执行路径被打断了，我们就需要在异常冒泡到断点之前用&lt;code&gt;try&lt;/code&gt;语句把异常捕获住，并通过回调函数传递被捕获的异常。于是我们可以像下边这样改造上边的例子。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function async(fn, callback) {
    // Code execution path breaks here.
    setTimeout(function ()　{
        try {
            callback(null, fn());
        } catch (err) {
            callback(err);
        }
    }, 0);
}

async(null, function (err, data) {
    if (err) {
        console.log('Error: %s', err.message);
    } else {
        // Do something.
    }
});

-- Console ------------------------------
Error: object is not a function&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，异常再次被捕获住了。在NodeJS中，几乎所有异步API都按照以上方式设计，回调函数中第一个参数都是&lt;code&gt;err&lt;/code&gt;。因此我们在编写自己的异步函数时，也可以按照这种方式来处理异常，与NodeJS的设计风格保持一致。&lt;/p&gt;
&lt;p&gt;有了异常处理方式后，我们接着可以想一想一般我们是怎么写代码的。基本上，我们的代码都是做一些事情，然后调用一个函数，然后再做一些事情，然后再调用一个函数，如此循环。如果我们写的是同步代码，只需要在代码入口点写一个&lt;code&gt;try&lt;/code&gt;语句就能捕获所有冒泡上来的异常，示例如下。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function main() {
    // Do something.
    syncA();
    // Do something.
    syncB();
    // Do something.
    syncC();
}

try {
    main();
} catch (err) {
    // Deal with exception.
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是，如果我们写的是异步代码，就只有呵呵了。由于每次异步函数调用都会打断代码执行路径，只能通过回调函数来传递异常，于是我们就需要在每个回调函数里判断是否有异常发生，于是只用三次异步函数调用，就会产生下边这种代码。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function main(callback) {
    // Do something.
    asyncA(function (err, data) {
        if (err) {
            callback(err);
        } else {
            // Do something
            asyncB(function (err, data) {
                if (err) {
                    callback(err);
                } else {
                    // Do something
                    asyncC(function (err, data) {
                        if (err) {
                            callback(err);
                        } else {
                            // Do something
                            callback(null);
                        }
                    });
                }
            });
        }
    });
}

main(function (err) {
    if (err) {
        // Deal with exception.
    }
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，回调函数已经让代码变得复杂了，而异步方式下对异常的处理更加剧了代码的复杂度。如果NodeJS的最大卖点最后变成这个样子，那就没人愿意用NodeJS了，因此接下来会介绍NodeJS提供的一些解决方案。&lt;/p&gt;
&lt;h3 id=&quot;6.3&quot;&gt;域（Domain）&lt;/h3&gt;
&lt;blockquote readability=&quot;1.7&quot;&gt;
&lt;p&gt;&lt;strong&gt;官方文档： &lt;/strong&gt;&lt;a href=&quot;http://nodejs.org/api/domain.html&quot;&gt;http://nodejs.org/api/domain.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;NodeJS提供了&lt;code&gt;domain&lt;/code&gt;模块，可以简化异步代码的异常处理。在介绍该模块之前，我们需要首先理解“域”的概念。简单的讲，一个域就是一个JS运行环境，在一个运行环境中，如果一个异常没有被捕获，将作为一个全局异常被抛出。NodeJS通过&lt;code&gt;process&lt;/code&gt;对象提供了捕获全局异常的方法，示例代码如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;process.on('uncaughtException', function (err) {
    console.log('Error: %s', err.message);
});

setTimeout(function (fn) {
    fn();
});

-- Console ------------------------------
Error: undefined is not a function&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;虽然全局异常有个地方可以捕获了，但是对于大多数异常，我们希望尽早捕获，并根据结果决定代码的执行路径。我们用以下HTTP服务器代码作为例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function async(request, callback) {
    // Do something.
    asyncA(request, function (err, data) {
        if (err) {
            callback(err);
        } else {
            // Do something
            asyncB(request, function (err, data) {
                if (err) {
                    callback(err);
                } else {
                    // Do something
                    asyncC(request, function (err, data) {
                        if (err) {
                            callback(err);
                        } else {
                            // Do something
                            callback(null, data);
                        }
                    });
                }
            });
        }
    });
}

http.createServer(function (request, response) {
    async(request, function (err, data) {
        if (err) {
            response.writeHead(500);
            response.end();
        } else {
            response.writeHead(200);
            response.end(data);
        }
    });
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上代码将请求对象交给异步函数处理后，再根据处理结果返回响应。这里采用了使用回调函数传递异常的方案，因此&lt;code&gt;async&lt;/code&gt;函数内部如果再多几个异步函数调用的话，代码就变成上边这副鬼样子了。为了让代码好看点，我们可以在每处理一个请求时，使用&lt;code&gt;domain&lt;/code&gt;模块创建一个子域（JS子运行环境）。在子域内运行的代码可以随意抛出异常，而这些异常可以通过子域对象的&lt;code&gt;error&lt;/code&gt;事件统一捕获。于是以上代码可以做如下改造：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function async(request, callback) {
    // Do something.
    asyncA(request, function (data) {
        // Do something
        asyncB(request, function (data) {
            // Do something
            asyncC(request, function (data) {
                // Do something
                callback(data);
            });
        });
    });
}

http.createServer(function (request, response) {
    var d = domain.create();

    d.on('error', function () {
        response.writeHead(500);
        response.end();
    });

    d.run(function () {
        async(request, function (data) {
            response.writeHead(200);
            response.end(data);
        });
    });
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，我们使用&lt;code&gt;.create&lt;/code&gt;方法创建了一个子域对象，并通过&lt;code&gt;.run&lt;/code&gt;方法进入需要在子域中运行的代码的入口点。而位于子域中的异步函数回调函数由于不再需要捕获异常，代码一下子瘦身很多。&lt;/p&gt;
&lt;h4 id=&quot;6.3.1&quot;&gt;陷阱&lt;/h4&gt;
&lt;p&gt;无论是通过&lt;code&gt;process&lt;/code&gt;对象的&lt;code&gt;uncaughtException&lt;/code&gt;事件捕获到全局异常，还是通过子域对象的&lt;code&gt;error&lt;/code&gt;事件捕获到了子域异常，在NodeJS官方文档里都强烈建议处理完异常后立即重启程序，而不是让程序继续运行。按照官方文档的说法，发生异常后的程序处于一个不确定的运行状态，如果不立即退出的话，程序可能会发生严重内存泄漏，也可能表现得很奇怪。&lt;/p&gt;
&lt;p&gt;但这里需要澄清一些事实。JS本身的&lt;code&gt;throw..try..catch&lt;/code&gt;异常处理机制并不会导致内存泄漏，也不会让程序的执行结果出乎意料，但NodeJS并不是存粹的JS。NodeJS里大量的API内部是用C/C++实现的，因此NodeJS程序的运行过程中，代码执行路径穿梭于JS引擎内部和外部，而JS的异常抛出机制可能会打断正常的代码执行流程，导致C/C++部分的代码表现异常，进而导致内存泄漏等问题。&lt;/p&gt;
&lt;p&gt;因此，使用&lt;code&gt;uncaughtException&lt;/code&gt;或&lt;code&gt;domain&lt;/code&gt;捕获异常，代码执行路径里涉及到了C/C++部分的代码时，如果不能确定是否会导致内存泄漏等问题，最好在处理完异常后重启程序比较妥当。而使用&lt;code&gt;try&lt;/code&gt;语句捕获异常时一般捕获到的都是JS本身的异常，不用担心上诉问题。&lt;/p&gt;
&lt;h3 id=&quot;6.4&quot;&gt;小结&lt;/h3&gt;
&lt;p&gt;本章介绍了JS异步编程相关的知识，总结起来有以下几点：&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;不掌握异步编程就不算学会NodeJS。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;异步编程依托于回调来实现，而使用回调不一定就是异步编程。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;异步编程下的函数间数据传递、数组遍历和异常处理与同步编程有很大差别。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;使用&lt;code&gt;domain&lt;/code&gt;模块简化异步代码的异常处理，并小心陷阱。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;7&quot;&gt;大示例&lt;/h2&gt;
&lt;p&gt;学习讲究的是学以致用和融会贯通。至此我们已经分别介绍了NodeJS的很多知识点，本章作为最后一章，将完整地介绍一个使用NodeJS开发Web服务器的示例。&lt;/p&gt;
&lt;h3 id=&quot;7.1&quot;&gt;需求&lt;/h3&gt;
&lt;p&gt;我们要开发的是一个简单的静态文件合并服务器，该服务器需要支持类似以下格式的JS或CSS文件合并请求。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;http://assets.example.com/foo/??bar.js,baz.js&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在以上URL中，&lt;code&gt;??&lt;/code&gt;是一个分隔符，之前是需要合并的多个文件的URL的公共部分，之后是使用&lt;code&gt;,&lt;/code&gt;分隔的差异部分。因此服务器处理这个URL时，返回的是以下两个文件按顺序合并后的内容。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/foo/bar.js
/foo/baz.js&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另外，服务器也需要能支持类似以下格式的普通的JS或CSS文件请求。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;http://assets.example.com/foo/bar.js&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上就是整个需求。&lt;/p&gt;
&lt;h3 id=&quot;7.2&quot;&gt;第一次迭代&lt;/h3&gt;
&lt;p&gt;快速迭代是一种不错的开发方式，因此我们在第一次迭代时先实现服务器的基本功能。&lt;/p&gt;
&lt;h4 id=&quot;7.2.1&quot;&gt;设计&lt;/h4&gt;
&lt;p&gt;简单分析了需求之后，我们大致会得到以下的设计方案。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;           +---------+   +-----------+   +----------+
request --&amp;gt;|  parse  |--&amp;gt;|  combine  |--&amp;gt;|  output  |--&amp;gt; response
           +---------+   +-----------+   +----------+&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也就是说，服务器会首先分析URL，得到请求的文件的路径和类型（MIME）。然后，服务器会读取请求的文件，并按顺序合并文件内容。最后，服务器返回响应，完成对一次请求的处理。&lt;/p&gt;
&lt;p&gt;另外，服务器在读取文件时需要有个根目录，并且服务器监听的HTTP端口最好也不要写死在代码里，因此服务器需要是可配置的。&lt;/p&gt;
&lt;h4 id=&quot;7.2.2&quot;&gt;实现&lt;/h4&gt;
&lt;p&gt;根据以上设计，我们写出了第一版代码如下。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var fs = require('fs'),
    path = require('path'),
    http = require('http');

var MIME = {
    '.css': 'text/css',
    '.js': 'application/javascript'
};

function combineFiles(pathnames, callback) {
    var output = [];

    (function next(i, len) {
        if (i &amp;lt; len) {
            fs.readFile(pathnames[i], function (err, data) {
                if (err) {
                    callback(err);
                } else {
                    output.push(data);
                    next(i + 1, len);
                }
            });
        } else {
            callback(null, Buffer.concat(output));
        }
    }(0, pathnames.length));
}

function main(argv) {
    var config = JSON.parse(fs.readFileSync(argv[0], 'utf-8')),
        root = config.root || '.',
        port = config.port || 80;

    http.createServer(function (request, response) {
        var urlInfo = parseURL(root, request.url);

        combineFiles(urlInfo.pathnames, function (err, data) {
            if (err) {
                response.writeHead(404);
                response.end(err.message);
            } else {
                response.writeHead(200, {
                    'Content-Type': urlInfo.mime
                });
                response.end(data);
            }
        });
    }).listen(port);
}

function parseURL(root, url) {
    var base, pathnames, parts;

    if (url.indexOf('??') === -1) {
        url = url.replace('/', '/??');
    }

    parts = url.split('??');
    base = parts[0];
    pathnames = parts[1].split(',').map(function (value) {
        return path.join(root, base, value);
    });

    return {
        mime: MIME[path.extname(pathnames[0])] || 'text/plain',
        pathnames: pathnames
    };
}

main(process.argv.slice(2));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上代码完整实现了服务器所需的功能，并且有以下几点值得注意：&lt;/p&gt;
&lt;ol readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;使用命令行参数传递JSON配置文件路径，入口函数负责读取配置并创建服务器。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;入口函数完整描述了程序的运行逻辑，其中解析URL和合并文件的具体实现封装在其它两个函数里。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;解析URL时先将普通URL转换为了文件合并URL，使得两种URL的处理方式可以一致。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;合并文件时使用异步API读取文件，避免服务器因等待磁盘IO而发生阻塞。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我们可以把以上代码保存为&lt;code&gt;server.js&lt;/code&gt;，之后就可以通过&lt;code&gt;node server.js config.json&lt;/code&gt;命令启动程序，于是我们的第一版静态文件合并服务器就顺利完工了。&lt;/p&gt;
&lt;p&gt;另外，以上代码存在一个不那么明显的逻辑缺陷。例如，使用以下URL请求服务器时会有惊喜。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    http://assets.example.com/foo/bar.js,foo/baz.js&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;经过分析之后我们会发现问题出在&lt;code&gt;/&lt;/code&gt;被自动替换&lt;code&gt;/??&lt;/code&gt;这个行为上，而这个问题我们可以到第二次迭代时再解决。&lt;/p&gt;
&lt;h3 id=&quot;7.3&quot;&gt;第二次迭代&lt;/h3&gt;
&lt;p&gt;在第一次迭代之后，我们已经有了一个可工作的版本，满足了功能需求。接下来我们需要从性能的角度出发，看看代码还有哪些改进余地。&lt;/p&gt;
&lt;h4 id=&quot;7.3.1&quot;&gt;设计&lt;/h4&gt;
&lt;p&gt;把&lt;code&gt;map&lt;/code&gt;方法换成&lt;code&gt;for&lt;/code&gt;循环或许会更快一些，但第一版代码最大的性能问题存在于从读取文件到输出响应的过程当中。我们以处理&lt;code&gt;/??a.js,b.js,c.js&lt;/code&gt;这个请求为例，看看整个处理过程中耗时在哪儿。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; 发送请求       等待服务端响应         接收响应
---------+----------------------+-------------&amp;gt;
         --                                        解析请求
           ------                                  读取a.js
                 ------                            读取b.js
                       ------                      读取c.js
                             --                    合并数据
                               --                  输出响应&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，第一版代码依次把请求的文件读取到内存中之后，再合并数据和输出响应。这会导致以下两个问题：&lt;/p&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;当请求的文件比较多比较大时，串行读取文件会比较耗时，从而拉长了服务端响应等待时间。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;由于每次响应输出的数据都需要先完整地缓存在内存里，当服务器请求并发数较大时，会有较大的内存开销。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;对于第一个问题，很容易想到把读取文件的方式从串行改为并行。但是别这样做，因为对于机械磁盘而言，因为只有一个磁头，尝试并行读取文件只会造成磁头频繁抖动，反而降低IO效率。而对于固态硬盘，虽然的确存在多个并行IO通道，但是对于服务器并行处理的多个请求而言，硬盘已经在做并行IO了，对单个请求采用并行IO无异于拆东墙补西墙。因此，正确的做法不是改用并行IO，而是一边读取文件一边输出响应，把响应输出时机提前至读取第一个文件的时刻。这样调整后，整个请求处理过程变成下边这样。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;发送请求 等待服务端响应 接收响应
---------+----+-------------------------------&amp;gt;
         --                                        解析请求
           --                                      检查文件是否存在
             --                                    输出响应头
               ------                              读取和输出a.js
                     ------                        读取和输出b.js
                           ------                  读取和输出c.js&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;按上述方式解决第一个问题后，因为服务器不需要完整地缓存每个请求的输出数据了，第二个问题也迎刃而解。&lt;/p&gt;
&lt;h4 id=&quot;7.3.2&quot;&gt;实现&lt;/h4&gt;
&lt;p&gt;根据以上设计，第二版代码按以下方式调整了部分函数。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function main(argv) {
    var config = JSON.parse(fs.readFileSync(argv[0], 'utf-8')),
        root = config.root || '.',
        port = config.port || 80;

    http.createServer(function (request, response) {
        var urlInfo = parseURL(root, request.url);

        validateFiles(urlInfo.pathnames, function (err, pathnames) {
            if (err) {
                response.writeHead(404);
                response.end(err.message);
            } else {
                response.writeHead(200, {
                    'Content-Type': urlInfo.mime
                });
                outputFiles(pathnames, response);
            }
        });
    }).listen(port);
}

function outputFiles(pathnames, writer) {
    (function next(i, len) {
        if (i &amp;lt; len) {
            var reader = fs.createReadStream(pathnames[i]);

            reader.pipe(writer, { end: false });
            reader.on('end', function() {
                next(i + 1, len);
            });
        } else {
            writer.end();
        }
    }(0, pathnames.length));
}

function validateFiles(pathnames, callback) {
    (function next(i, len) {
        if (i &amp;lt; len) {
            fs.stat(pathnames[i], function (err, stats) {
                if (err) {
                    callback(err);
                } else if (!stats.isFile()) {
                    callback(new Error());
                } else {
                    next(i + 1, len);
                }
            });
        } else {
            callback(null, pathnames);
        }
    }(0, pathnames.length));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，第二版代码在检查了请求的所有文件是否有效之后，立即就输出了响应头，并接着一边按顺序读取文件一边输出响应内容。并且，在读取文件时，第二版代码直接使用了只读数据流来简化代码。&lt;/p&gt;
&lt;h3 id=&quot;7.4&quot;&gt;第三次迭代&lt;/h3&gt;
&lt;p&gt;第二次迭代之后，服务器本身的功能和性能已经得到了初步满足。接下来我们需要从稳定性的角度重新审视一下代码，看看还需要做些什么。&lt;/p&gt;
&lt;h4 id=&quot;7.4.1&quot;&gt;设计&lt;/h4&gt;
&lt;p&gt;从工程角度上讲，没有绝对可靠的系统。即使第二次迭代的代码经过反复检查后能确保没有bug，也很难说是否会因为NodeJS本身，或者是操作系统本身，甚至是硬件本身导致我们的服务器程序在某一天挂掉。因此一般生产环境下的服务器程序都配有一个守护进程，在服务挂掉的时候立即重启服务。一般守护进程的代码会远比服务进程的代码简单，从概率上可以保证守护进程更难挂掉。如果再做得严谨一些，甚至守护进程自身可以在自己挂掉时重启自己，从而实现双保险。&lt;/p&gt;
&lt;p&gt;因此在本次迭代时，我们先利用NodeJS的进程管理机制，将守护进程作为父进程，将服务器程序作为子进程，并让父进程监控子进程的运行状态，在其异常退出时重启子进程。&lt;/p&gt;
&lt;h4 id=&quot;7.4.2&quot;&gt;实现&lt;/h4&gt;
&lt;p&gt;根据以上设计，我们编写了守护进程需要的代码。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var cp = require('child_process');

var worker;

function spawn(server, config) {
    worker = cp.spawn('node', [ server, config ]);
    worker.on('exit', function (code) {
        if (code !== 0) {
            spawn(server, config);
        }
    });
}

function main(argv) {
    spawn('server.js', argv[0]);
    process.on('SIGTERM', function () {
        worker.kill();
        process.exit(0);
    });
}

main(process.argv.slice(2));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此外，服务器代码本身的入口函数也要做以下调整。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function main(argv) {
    var config = JSON.parse(fs.readFileSync(argv[0], 'utf-8')),
        root = config.root || '.',
        port = config.port || 80,
        server;

    server = http.createServer(function (request, response) {
        ...
    }).listen(port);

    process.on('SIGTERM', function () {
        server.close(function () {
            process.exit(0);
        });
    });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以把守护进程的代码保存为&lt;code&gt;daemon.js&lt;/code&gt;，之后我们可以通过&lt;code&gt;node daemon.js config.json&lt;/code&gt;启动服务，而守护进程会进一步启动和监控服务器进程。此外，为了能够正常终止服务，我们让守护进程在接收到&lt;code&gt;SIGTERM&lt;/code&gt;信号时终止服务器进程。而在服务器进程这一端，同样在收到&lt;code&gt;SIGTERM&lt;/code&gt;信号时先停掉HTTP服务再正常退出。至此，我们的服务器程序就靠谱很多了。&lt;/p&gt;
&lt;h3 id=&quot;7.5&quot;&gt;第四次迭代&lt;/h3&gt;
&lt;p&gt;在我们解决了服务器本身的功能、性能和可靠性的问题后，接着我们需要考虑一下代码部署的问题，以及服务器控制的问题。&lt;/p&gt;
&lt;h4 id=&quot;7.5.1&quot;&gt;设计&lt;/h4&gt;
&lt;p&gt;一般而言，程序在服务器上有一个固定的部署目录，每次程序有更新后，都重新发布到部署目录里。而一旦完成部署后，一般也可以通过固定的服务控制脚本启动和停止服务。因此我们的服务器程序部署目录可以做如下设计。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;- deploy/
    - bin/
        startws.sh
        killws.sh
    + conf/
        config.json
    + lib/
        daemon.js
        server.js&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在以上目录结构中，我们分类存放了服务控制脚本、配置文件和服务器代码。&lt;/p&gt;
&lt;h4 id=&quot;7.5.2&quot;&gt;实现&lt;/h4&gt;
&lt;p&gt;按以上目录结构分别存放对应的文件之后，接下来我们看看控制脚本怎么写。首先是&lt;code&gt;start.sh&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#!/bin/sh
if [ ! -f &quot;pid&quot; ]
then
    node ../lib/daemon.js ../conf/config.json &amp;amp;
    echo $! &amp;gt; pid
fi&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后是&lt;code&gt;killws.sh&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#!/bin/sh
if [ -f &quot;pid&quot; ]
then
    kill $(tr -d '\r\n' &amp;lt; pid)
    rm pid
fi&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;于是这样我们就有了一个简单的代码部署目录和服务控制脚本，我们的服务器程序就可以上线工作了。&lt;/p&gt;
&lt;h3 id=&quot;7.6&quot;&gt;后续迭代&lt;/h3&gt;
&lt;p&gt;我们的服务器程序正式上线工作后，我们接下来或许会发现还有很多可以改进的点。比如服务器程序在合并JS文件时可以自动在JS文件之间插入一个&lt;code&gt;;&lt;/code&gt;来避免一些语法问题，比如服务器程序需要提供日志来统计访问量，比如服务器程序需要能充分利用多核CPU，等等。而此时的你，在学习了这么久NodeJS之后，应该已经知道该怎么做了。&lt;/p&gt;
&lt;h3 id=&quot;7.7&quot;&gt;小结&lt;/h3&gt;
&lt;p&gt;本章将之前零散介绍的知识点串了起来，完整地演示了一个使用NodeJS开发程序的例子，至此我们的课程就全部结束了。以下是对新诞生的NodeJSer的一些建议。&lt;/p&gt;
&lt;ul readability=&quot;6&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;要熟悉官方API文档。并不是说要熟悉到能记住每个API的名称和用法，而是要熟悉NodeJS提供了哪些功能，一旦需要时知道查询API文档的哪块地方。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;要先设计再实现。在开发一个程序前首先要有一个全局的设计，不一定要很周全，但要足够能写出一些代码。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;要实现后再设计。在写了一些代码，有了一些具体的东西后，一定会发现一些之前忽略掉的细节。这时再反过来改进之前的设计，为第二轮迭代做准备。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;要充分利用三方包。NodeJS有一个庞大的生态圈，在写代码之前先看看有没有现成的三方包能节省不少时间。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;不要迷信三方包。任何事情做过头了就不好了，三方包也是一样。三方包是一个黑盒，每多使用一个三方包，就为程序增加了一份潜在风险。并且三方包很难恰好只提供程序需要的功能，每多使用一个三方包，就让程序更加臃肿一些。因此在决定使用某个三方包之前，最好三思而后行。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Fri, 09 Aug 2019 00:45:00 +0000</pubDate>
<dc:creator>葡萄城技术团队</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/powertoolsteam/p/11324966.html</dc:identifier>
</item>
<item>
<title>互联网公司面试经——你不得不知道的哈希表 - 崖边小生</title>
<link>http://www.cnblogs.com/hunternet/p/11324945.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hunternet/p/11324945.html</guid>
<description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;    哈希表，又名散列表。是非常常用的一种数据结构，C#的Hashtable、字典，Java的HashMap，Redis的Hash，其底层实现都是散列表。而在一些互联网公司的面试中，更是技术面试官们必问的一道题目。本文将简单了解哈希表(散列表)这种数据结构。&lt;/p&gt;
&lt;h3 id=&quot;一散列表&quot;&gt;一、散列表&lt;/h3&gt;
&lt;h4 id=&quot;散列表&quot;&gt;1.1 散列表&lt;/h4&gt;
&lt;p&gt;    散列表(哈希表)，其思想主要是基于数组支持按照下标随机访问数据时间复杂度为O(1)的特性。可是说是数组的一种扩展。假设，我们为了方便记录某高校数学专业的所有学生的信息。要求可以按照学号(学号格式为:入学时间+年级+专业+专业内自增序号，如2011 1101 0001)能够快速找到某个学生的信息。这个时候我们可以取学号的自增序号部分，即后四位作为数组的索引下标，把学生相应的信息存储到对应的空间内即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-19/16747511.jpg&quot; alt=&quot;散列思想&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    如上图所示,我们把学号作为key,通过截取学号后四位的函数后计算后得到索引下标，将数据存储到数组中。当我们按照键值(学号)查找时，只需要再次计算出索引下标，然后取出相应数据即可。以上便是散列思想。&lt;/p&gt;
&lt;h4 id=&quot;散列函数&quot;&gt;1.2 散列函数&lt;/h4&gt;
&lt;p&gt;    上面的例子中，截取学号后四位的函数即是一个简单的散列函数。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;//散列函数 伪代码 
int Hash(string key) {
  // 获取后四位字符
  string hashValue =int.parse(key.Substring(key.Length-4, 4));
  // 将后两位字符转换为整数
  return hashValue;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这里散列函数的作用就是讲key值映射成数组的索引下标。关于散列函数的设计方法有很多，如:直接寻址法、数字分析法、随机数法等等。但即使是再优秀的设计方法也不能避免散列冲突。在散列表中散列函数不应设计太复杂。&lt;/p&gt;
&lt;h4 id=&quot;散列冲突&quot;&gt;1.3 散列冲突&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-19/96951971.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    散列函数具有确定性和不确定性。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;确定性:哈希的散列值不同，那么哈希的原始输入也就不同。即:key1=key2,那么hash(key1)=hash(key2)。&lt;/li&gt;
&lt;li&gt;不确定性:同一个散列值很有可能对应多个不同的原始输入。即:key1≠key2，hash(key1)=hash(key2)。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;散列冲突,即key1≠key2，hash(key1)=hash(key2)的情况。散列冲突是不可避免的，如果我们key的长度为100，而数组的索引数量只有50，那么再优秀的算法也无法避免散列冲突。关于散列冲突也有很多解决办法，这里简单复习两种：开放寻址法和链表法。&lt;/p&gt;
&lt;h5 id=&quot;开放寻址法&quot;&gt;1.3.1 开放寻址法&lt;/h5&gt;
&lt;p&gt;    开放寻址法的核心思想是，如果出现了散列冲突，我们就重新探测一一个空闲位置，将其插入。比如，我们可以使用线性探测法。当我们往散列表中插入数据时，如果某个数据经过散列函数散列之后，存储位置已经被占用了，我们就从当前位置开始，依次往后查找，看是否有空闲位置，如果遍历到尾部都没有找到空闲的位置，那么我们就再从表头开始找，直到找到为止。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-19/20232835.jpg&quot; alt=&quot;开放寻址法&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    散列表中查找元素的时候，我们通过散列函数求出要查找元素的键值对应的散列值，然后比较数组中下标为散列值的元素和要查找的元素。如果相等，则说明就是我们要找的元素；否则就顺序往后依次查找。如果遍历到数组中的空闲位置还没有找到，就说明要查找的元素并没有在散列表中。&lt;/p&gt;
&lt;p&gt;    对于删除操作稍微有些特别，不能单纯地把要删除的元素设置为空。因为在查找的时候，一旦我们通过线性探测方法，找到一个空闲位置，我们就可以认定散列表中不存在这个数据。但是，如果这个空闲位置是我们后来删除的，就会导致原来的查找算法失效。这里我们可以将删除的元素，特殊标记为 deleted。当线性探测查找的时候，遇到标记为 deleted 的空间，并不是停下来，而是继续往下探测。&lt;/p&gt;
&lt;p&gt;    线性探测法存在很大问题。当散列表中插入的数据越来越多时，其散列冲突的可能性就越大，极端情况下甚至要探测整个散列表,因此最坏时间复杂度为O(N)。在开放寻址法中，除了线性探测法，我们还可以二次探测和双重散列等方式。&lt;/p&gt;
&lt;h5 id=&quot;链表法拉链法&quot;&gt;1.3.2 链表法(拉链法)&lt;/h5&gt;
&lt;p&gt;    简单来讲就是在冲突的位置拉一条链表来存储数据。&lt;/p&gt;
&lt;p&gt;    链表法是一种比较常用的散列冲突解决办法,Redis使用的就是链表法来解决散列冲突。链表法的原理是:如果遇到冲突，他就会在原地址新建一个空间，然后以链表结点的形式插入到该空间。当插入的时候，我们只需要通过散列函数计算出对应的散列槽位，将其插入到对应链表中即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-19/89123753.jpg&quot; alt=&quot;链表法&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;负载因子与rehash&quot;&gt;1.3.3 负载因子与rehash&lt;/h5&gt;
&lt;p&gt;    我们可以使用装载因子来衡量散列表的“健康状况”。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;散列表的负载因子 = 填入表中的元素个数/散列表的长度&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;散列表负载因子越大，代表空闲位置越少，冲突也就越多，散列表的性能会下降。&lt;/p&gt;
&lt;p&gt;    对于散列表来说，负载因子过大或过小都不好，负载因子过大，散列表的性能会下降。而负载因子过小，则会造成内存不能合理利用，从而形成内存浪费。因此我们为了保证负载因子维持在一个合理的范围内，要对散列表的大小进行收缩或扩展，即rehash。散列表的rehash过程类似于数组的收缩与扩容。&lt;/p&gt;
&lt;h5 id=&quot;开放寻址法与链表法比较&quot;&gt;1.3.4 开放寻址法与链表法比较&lt;/h5&gt;
&lt;p&gt;    对于开放寻址法解决冲突的散列表，由于数据都存储在数组中，因此可以有效地利用 CPU 缓存加快查询速度(数组占用一块连续的空间)。但是删除数据的时候比较麻烦，需要特殊标记已经删除掉的数据。而且，在开放寻址法中，所有的数据都存储在一个数组中，比起链表法来说，冲突的代价更高。所以，使用开放寻址法解决冲突的散列表，负载因子的上限不能太大。这也导致这种方法比链表法更浪费内存空间。&lt;/p&gt;
&lt;p&gt;    对于链表法解决冲突的散列表,对内存的利用率比开放寻址法要高。因为链表结点可以在需要的时候再创建，并不需要像开放寻址法那样事先申请好。链表法比起开放寻址法，对大装载因子的容忍度更高。开放寻址法只能适用装载因子小于1的情况。接近1时，就可能会有大量的散列冲突，性能会下降很多。但是对于链表法来说，只要散列函数的值随机均匀，即便装载因子变成10，也就是链表的长度变长了而已，虽然查找效率有所下降，但是比起顺序查找还是快很多。但是，链表因为要存储指针，所以对于比较小的对象的存储，是比较消耗内存的，而且链表中的结点是零散分布在内存中的，不是连续的，所以对CPU缓存是不友好的，这对于执行效率有一定的影响。&lt;/p&gt;
&lt;h3 id=&quot;小结&quot;&gt;小结&lt;/h3&gt;
&lt;p&gt;    对于一些一线城市的互联网公司，技术面试官比较喜欢考察一个人的基础，像哈希这种经典而又应用广泛的数据结构更是老生常谈之题目。大致提问方式无非以下几种&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;C#字典（java hashmap或者Redis hash）的底层实现方式&lt;/li&gt;
&lt;li&gt;说一下什么是哈希表(散列表)&lt;/li&gt;
&lt;li&gt;哈希如何解决碰撞(散列如何解决冲突)&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;end-----&quot;&gt;-----END-----&lt;/h3&gt;
&lt;p&gt;感谢大家阅读，如有问题可在文章下方留言，我会在第一时间回复！&lt;/p&gt;
</description>
<pubDate>Fri, 09 Aug 2019 00:35:00 +0000</pubDate>
<dc:creator>崖边小生</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hunternet/p/11324945.html</dc:identifier>
</item>
<item>
<title>.netcore持续集成测试篇之开篇简介及Xunit基本使用 - 周国通</title>
<link>http://www.cnblogs.com/tylerzhou/p/11324902.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tylerzhou/p/11324902.html</guid>
<description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/tylerzhou/p/11204826.html&quot;&gt;系列目录&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为了支持跨平台,微软为.net平台提供了.net core test sdk,这样第三方测试框架诸如Nunit,Xunit等只需要按照sdk提供的api规范进行开发便可以被dotnet cli工具调用,这样就解决了在持续集成过程中第三方框架依赖于windows平台上的各自runner的问题,使得测试框架开发者不需要花费很大功夫就可以快速迁移到.net core平台,同时封装了各测试框架的实现细节,对外暴露统一调用接口,大大减少devops开发者的工作量.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;作为单元测试基础知识介绍,这里只介绍常用单元测试框架Nunit和Xunit如何在.net core平台上使用,并介绍由于.net core的变化所引起的需要注意的测试代码的相应改变,对于如何在Jenkins环境中自动完成测试的相关内容Jenkins基础知识里面介绍&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;考虑到实际工作中可能有的项目组已经使用或者尝试使用xunit,并且.net core对xunit支持较好,诸多开源项目的单元测试也都使用的是Xunit,本章节作为补充对Xunit基础知识进行讲解,以帮助还不太了解这个框架的同学快速入门.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;25&quot;&gt;
&lt;p&gt;我们知道在.net framework下相要对mvc项目进行集成测试非常困难,一方面.net http管道里有很多黑盒子,开发者对它的实现细节一无所知,二者需要mock的对象太多,工作量巨大.因此很难在持续集成环境中对web项目进行集成测试.开发者或者测试人员大都依赖postman,fiddler,以及浏览器的http请求插件来进行集成测试,这样带来的一个很大问题这些http请求很难复用,更难以有效的组织管理.即使使用postman这样强大的http工具如果测试接口过多代码也会变得一塌糊涂,过一段时间后想要知道哪个方法是测试哪个接口用的就需要通过搜索来导航到指定的测试方法,并且很多时候有于各模块有相同名称的方法,往往需要先找到方法所在的area,然后再找到controller然后再找到相应方法...如果出现问题的代码过多往往把开发者搞的焦头烂额,苦不堪言.&lt;br/&gt;幸运的是在.net core里很容易模拟一个httpt管道,这一方面使得集成测试在持续集成环境中使用提供了可能,另一方http请求写成程序里,可以很方便的导航到指定的测试方法,极大提供可维护性.本章节最后会介绍如何搭建一个.net core web项目的selfhost环境以供在单元测试框架中使用.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面我们将简要介绍如何在vs中配置xunt环境以及Xunit断言的基本使用&lt;/p&gt;
&lt;h2 id=&quot;net-core-中使用xunit&quot;&gt;.net core 中使用Xunit&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Xunit是.net平台下的一款单元测试工具,类似Nunit.但是更为轻量,更加专注于单元测试而不像Nunit提供了很多额外的功能&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;.net core对Xunit支持较好,VisualStudio 2017提供有一个Xunit单元测试模板可以很方便的创建一个Xunit单元测试项目.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201908/811801-20190809080516737-885138873.png&quot; alt=&quot;avatar&quot;/&gt;&lt;br/&gt;如图,在visual studio里创建项目时,选择.net core项目,然后从模板里面找到Xunit单元测试项目便可以创建一个Xunit单元测试项目了.&lt;/p&gt;
&lt;p&gt;我们打开刚创建的项目右键选择&quot;Nuget包管理&quot;,从包管理工具里我们可以看到,实际上这个模板引用了xunit,和xunit.runner.visualstudio这两个包.这样,我们也可以自己手动创建一个.net core类型的库文件,然后引入这两个包,能达到同样的效果.&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;这里建议大家通过模板来创建单元测试项目,因为单元测试框架不同版本可能需要引用不同的包,没有经验的同学常常由于引用的包不对导致单元测试项目跑不起来,搞得灰头土脸,非常郁闷.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们编写以下单元测试代码&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt; public class UnitTest1
    {
        [Fact]
        public void Test1()
        {
            int intt = 3 + 2;
            Assert.True(intt==5);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过以上代码我们看到Xunit就测试断言和Nunit很类似(这里指Nunit3,早期版本Nunit差异较大,建议大这在工作中也尽量选用Nunit3,而不是1或者2)&lt;/p&gt;
&lt;p&gt;这里有一点差异需要指出,Xunit并不需要对单元测试类进行注解(Nunit是需要的,否则无法识别),只需要在需要测试的方法上加上fact注解即可.&lt;/p&gt;
&lt;p&gt;单元测试方法的运行也和前面讲的Nunit单元测试运行方法相同,这里不再赘述.&lt;/p&gt;
&lt;h2 id=&quot;常见基本断言&quot;&gt;常见基本断言&lt;/h2&gt;
&lt;p&gt;虽然Xunit和Nunit在断言上有很多相似的地方,并且有越来越像的趋势,但是仍然有不少差别,因此这里仍然会对Xunit的断言功能进行一个全面的列举,以供大家速查.并且有时候会指出它和Nunit的差别或者指出Nunit中比较难以实现或者技巧性很强的功能如何在Xunit里实现.如果有读者直接阅读本章节而没有了解过Nunit,可以有选择的略过二者比较的内容.&lt;/p&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;这里首先指出一个很大的差别.Xunit里并没有像Nunit里的stringAssertion,FileAssertion和CollectionAssertion,而是所有的断言都在Assert静态类里,方法也不是很多,语义也相对更加明确,很适应没有单元测试基础的同学快速入门.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面开始介绍Xunit里的断言方法&lt;/p&gt;
&lt;h3 id=&quot;assert.null&quot;&gt;&lt;code&gt;Assert.Null&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;用于断言一个对象是否是Null&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;这个方法有一个相对含义的断言就是Assert.NotNull,很多其它的方法也有带Not的断言,很容易理解.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;assert.-assert.equal&quot;&gt;&lt;code&gt;Assert. Assert.Equal&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;此方法有很多重载,用于比较两个字符串,int,decimal或者对象类型是否相等.&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;注意这里比较两个对象是否相等时,相当于Object.equals()来比较两个对象是否相等&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;这个方法用于比较两个double类型值是否相等时,可以指定精度.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;assert.strictequal&quot;&gt;&lt;code&gt;Assert.StrictEqual&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;从字面上来看,它用于比较两个对象是否是严格相等,然而它的表现行为和以上Equal方法非常类似,&lt;code&gt;并不是比较两个对象内存地址是否相等&lt;/code&gt;.实际上它是在比较的时候指定一个默认的&lt;code&gt;比较器&lt;/code&gt;.这个方法着实非常让人困惑.&lt;/p&gt;
&lt;h3 id=&quot;assert.same&quot;&gt;&lt;code&gt;Assert.same&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;用于比较两个对象运行是是否指定同一块内存地址,如果要比较两个对象是否完全相等,则使用它.&lt;/p&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;注意,虽然Assert.same接收的是两个object类型对象,但是不建议用它来比较简单类型,它其实是用于比较两个对象是否指向同一内存地址,因此只有比较引用对象才是有意义的.这个方法应该设计成泛型方法才比较好,不知道为什么要这样设计.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;assert.startswith-assert.endswith&quot;&gt;&lt;code&gt;Assert.StartsWith Assert.EndsWith&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;用于断言一个字符串是否以特定字符(串)开头(结尾),并且这两个方法都有一个重载用于指定是否忽略大小写&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;用过Nunit的同学可能知道,Nunit里要实现区分大小写的StartsWith有点麻烦.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;assert.true-assert.false&quot;&gt;&lt;code&gt;Assert.True Assert.False&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;用于断言两个布尔变量(包括可空)的值是否是真(假).&lt;/p&gt;
&lt;h3 id=&quot;assert.all&quot;&gt;&lt;code&gt;Assert.All&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;用于断言集合里的所有元素是否都满足通过测试,奇怪的是这个方法接收的是Action委托而不是Func&amp;lt;T,bool&amp;gt;类型委托.这将导致写出来的代码看上去有点怪异.&lt;/p&gt;
&lt;p&gt;下面举个用于断言集合里的元素值是否都大于0的例子来看看如何使用它&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;       [Fact]
        public void Test1()
        {
            int[] intt =  {3, 4, 5, 9, 22};
            Assert.All(intt, t =&amp;gt; Assert.True(t &amp;gt; 0));
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意以上写法,由于不接收Func&amp;lt;T,bool&amp;gt;类型委托,因此以上方法不能想当然的写为 &lt;code&gt;Assert.All(intt, t =&amp;gt; t&amp;gt;0);&lt;/code&gt; 这样将导致编译错误.&lt;/p&gt;
&lt;h3 id=&quot;assert.contains&quot;&gt;&lt;code&gt;Assert.Contains&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;这个方法有多个重载,功能也非常多,但是语义都非常明确.&lt;/p&gt;
&lt;h4 id=&quot;用于断言字符串是否包含指定字符串&quot;&gt;&lt;code&gt;用于断言字符串是否包含指定字符串&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;相当于字符串里的Contains,并且表现行为类似,也有一个重载支持&lt;code&gt;不区分大小写&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;用于断言集合是否包含指定元素&quot;&gt;&lt;code&gt;用于断言集合是否包含指定元素&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;请看以下代码&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;       [Fact]
        public void Test1()
        {
            int[] intt = {3, 4, 5, 9};
            Assert.Contains(4, intt);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上代码用于断言集合intt里是否包含元素4,显然是包含的&lt;/p&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;注意,对于包含引用对象的集合判断是否包含某一元素这一个元素必须和集合中的某一个元素的引用地址一样.这很多时候并不是我们想要的行为,多数时候引用对象的对应的字段分别相等时我们就认为它相等,更极端的情况是某些情况下两个对象只有某一个或者少数几个字段相等时我们也认为相等,这要看具体实际业务.前面讲Nunit时对这个问题有过详细讲解.这里Contains方法同样有一个重载以支持一个&lt;code&gt;比较器&lt;/code&gt;,用于自定义相等性逻辑.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;14&quot;&gt;
&lt;p&gt;还有一点需要指出,Contains方法只能断言集合是否包含某&lt;code&gt;一个&lt;/code&gt;元素,而不能断言是否包含某几个元素(也即一个集合是否是另一个集合的子集),Nunit里并没有提供直接方法用于处理这样的问题.有些同学可能认为Assert.Subset是用来解决这个问题的,然而并不是,Subset只能用于实现了ISet接口的集合,很多时候并不是特别有帮助.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;用于断言集合中是否包含指定类型的元素&quot;&gt;&lt;code&gt;用于断言集合中是否包含指定类型的元素&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;这个重载方法语义稍显不是很明确,它其实相当于linq里的any方法,只要有一个(一些)满足条件的元素就会返回true&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;       [Fact]
        public void Test1()
        {
            int[] intt = {3, 4, 5, 9};
            Assert.Contains(intt, a =&amp;gt; a &amp;gt; 3);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上方法用于断言intt集合中是否包含大于3的元素,显然是包含的.&lt;/p&gt;
&lt;h3 id=&quot;assert.empty&quot;&gt;Assert.Empty&lt;/h3&gt;
&lt;p&gt;用于断言集合是否不包含任何元素,也即集合是否是一个空集合&lt;/p&gt;
&lt;h3 id=&quot;assert.matches&quot;&gt;&lt;code&gt;Assert.Matches&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;此方法接收两个参数,第一个表示要匹配的正则规则,第二个表示要测试的字符串,语义类似正则表达式里的IsMatch&lt;/p&gt;
&lt;h3 id=&quot;assert.inrange&quot;&gt;&lt;code&gt;Assert.InRange&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;用于断言指定元素是否在指定的范围内&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;        [Fact]
        public void Test1()
        {
            Assert.InRange(20, 3, 20);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上代码片段断言20是否在3到20这个范围内,显然是在的.&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;此方法支持一个重载接收一个Icomparer参数用于自定义一个比较器,这样就可以判断任意对象是否在某一范围内,有这方面需求的同学可以研究一下&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;assert.single&quot;&gt;&lt;code&gt;Assert.Single&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;用于断言集合只包含 &lt;strong&gt;&lt;code&gt;一个&lt;/code&gt;&lt;/strong&gt; 元素,这个方法有几个重载.&lt;/p&gt;
&lt;h4 id=&quot;重载1&quot;&gt;重载1&lt;/h4&gt;
&lt;p&gt;用于断言集合中是仅包含一个元素,这个重载可能大部分时候不是很有用&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;       [Fact]
        public void Test1()
        {
            Assert.Single(new[] {3});
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;重载2-接收一个参数用于断言这个元素是否是指定元素&quot;&gt;重载2 接收一个参数,用于断言这个元素是否是指定元素&lt;/h4&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;      [Fact]
       public void Test1()
       {
           Assert.Single(new[] {3,4,5,9},3);
       }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上代码断言集体中只有一个元素是3&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;此方法相当于对集合执行linq的first方法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;重载3-接收一个predict类型委托用于断言这个元素是否满足指定条件&quot;&gt;重载3 接收一个predict类型委托,用于断言这个元素是否满足指定条件&lt;/h4&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;      [Fact]
       public void Test1()
       {
           Assert.Single(new[] {3,4,5,9},a=&amp;gt;a&amp;gt;5);
       }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上方法断言集合中的这个是否只包含一个大于5的元素.&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;此方法相当于linq里面的single方法的有参重载&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;assert.isassignablefrom&quot;&gt;&lt;code&gt;Assert.IsAssignableFrom&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;用于断言实例对象的类型是否是一个类型的子类(或者本身)&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;这个方法Nunit里也有,和反射里的&lt;code&gt;IsAssignableFrom&lt;/code&gt;语义相同&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;assert.istype&quot;&gt;&lt;code&gt;Assert.IsType&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;用于断言实例对象的类型是否是某一指定类型&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;和IsAssignableFrom相比,此方法要求实例对象类型必须确切地是某一类型&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 09 Aug 2019 00:10:00 +0000</pubDate>
<dc:creator>周国通</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tylerzhou/p/11324902.html</dc:identifier>
</item>
<item>
<title>利用ImageAI库只需几行python代码超简实现目标检测 - 闽A2436</title>
<link>http://www.cnblogs.com/multhree/p/11324786.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/multhree/p/11324786.html</guid>
<description>&lt;p&gt;目标检测关注图像中特定的物体目标，需要同时解决解决定位（localization） + 识别（Recognition）。相比分类，检测给出的是对图片前景和背景的理解，我们需要从背景中分离出感兴趣的目标，并确定这一目标的描述（类别和位置），因此检测模型的输出是一个列表，列表的每一项使用一个数组给出检出目标的类别和位置（常用矩形检测框的坐标表示）。&lt;/p&gt;
&lt;p&gt;通俗的说，Object Detection的目的是在目标图中将目标用一个框框出来，并且识别出这个框中的是啥，而且最好的话是能够将图片的所有物体都框出来。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1410231/201908/1410231-20190808203734408-1188688985.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;目前目标检测领域的深度学习方法主要分为两类：两阶段（Two Stages）的目标检测算法；一阶段（One Stage）目标检测算法。&lt;/p&gt;
&lt;h2 id=&quot;two-stages&quot;&gt;Two Stages&lt;/h2&gt;
&lt;p&gt;首先由算法（algorithm）生成一系列作为样本的候选框，再通过卷积神经网络进行样本（Sample）分类。也称为基于候选区域（Region Proposal）的算法。常见的算法有R-CNN、Fast R-CNN、Faster R-CNN等等。&lt;/p&gt;
&lt;h2 id=&quot;one-stage&quot;&gt;One Stage&lt;/h2&gt;
&lt;p&gt;不需要产生候选框，直接将目标框定位的问题转化为回归（Regression）问题处理，也称为基于端到端（End-to-End）的算法。常见的算法有YOLO、SSD等等。&lt;/p&gt;

&lt;p&gt;本文主要讲述如何实现目标检测，至于背后的原理不过多赘述，可以去看相关的论文。&lt;/p&gt;
&lt;p&gt;ImageAI是一个简单易用的计算机视觉Python库，使得开发者可以轻松的将最新的最先进的人工智能功能整合进他们的应用。&lt;/p&gt;
&lt;p&gt;ImageAI本着简洁的原则，支持最先进的机器学习算法，用于图像预测，自定义图像预测，物体检测，视频检测，视频对象跟踪和图像预测训练。&lt;/p&gt;
&lt;h2 id=&quot;依赖&quot;&gt;依赖&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Python 3.5.1（及更高版本）&lt;/li&gt;
&lt;li&gt;pip3&lt;/li&gt;
&lt;li&gt;Tensorflow 1.4.0（及更高版本）&lt;/li&gt;
&lt;li&gt;Numpy 1.13.1（及更高版本）&lt;/li&gt;
&lt;li&gt;SciPy 0.19.1（及更高版本）&lt;/li&gt;
&lt;li&gt;OpenCV&lt;/li&gt;
&lt;li&gt;pillow&lt;/li&gt;
&lt;li&gt;Matplotlib&lt;/li&gt;
&lt;li&gt;h5py&lt;/li&gt;
&lt;li&gt;Keras 2.x&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;安装&quot;&gt;安装&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;命令行安装&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;pip3 install https://github.com/OlafenwaMoses/ImageAI/releases/download/2.0.1/imageai-2.0.1-py3-none-any.whl&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;pip3 install .\imageai-2.1.0-py3-none-any.whl&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;使用&quot;&gt;使用&lt;/h2&gt;
&lt;p&gt;Image支持的深度学习的算法有&lt;strong&gt;RetinaNet&lt;/strong&gt;,&lt;strong&gt;YOLOv3&lt;/strong&gt;,&lt;strong&gt;TinyYoLOv3&lt;/strong&gt;。ImageAI已经在&lt;strong&gt;COCO数据集&lt;/strong&gt;上预先训练好了对应的三个模型，根据需要可以选择不同的模型。可以通过下面的链接进行下载使用：&lt;/p&gt;
&lt;p&gt;以上模型可以检测并识别以下80种不同的目标：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;person,   bicycle,   car,   motorcycle,   airplane,
bus,   train,   truck,   boat,   traffic light,   fire hydrant, stop_sign,
parking meter,   bench,   bird,   cat,   dog,   horse,   sheep, cow,
elephant,   bear,   zebra,   giraffe,   backpack,   umbrella,
handbag,   tie,   suitcase, frisbee,   skis,   snowboard,  
sports ball,   kite,   baseball bat,   baseball glove,   skateboard,
surfboard,   tennis racket,   bottle,   wine glass,   cup,   fork,   knife,
spoon,   bowl, banana,   apple,   sandwich,   orange,   broccoli,   carrot,
hot dog,   pizza,   donot,   cake,   chair,   couch,   potted plant,   bed,
dining table,   toilet,   tv,   laptop,   mouse,   remote,   keyboard,
cell phone,   microwave,   oven,   toaster,   sink,   refrigerator,
book,   clock,   vase,   scissors,   teddy bear,   hair dryer,
toothbrush&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;先来看看完整的代码，使用YOLOv3算法对13张照片进行目标识别。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from imageai.Detection import ObjectDetection
import os

detector = ObjectDetection()
detector.setModelTypeAsYOLOv3()
detector.setModelPath(&quot;./model/yolo.h5&quot;)
detector.loadModel()

path = os.getcwd()
input_image_list = os.listdir(path+&quot;\pic\input&quot;)
input_image_list = sorted(input_image_list, key = lambda i:len(i),reverse = False)
size = len(input_image_list)
for i in range(size):
    input_image_path = os.path.join(path+&quot;\pic\input&quot;, input_image_list[i])
    output_image_path = os.path.join(path+&quot;\pic\output&quot;, input_image_list[i])
    detections, extract_detected_objects = detector.detectObjectsFromImage(input_image=input_image_path,
                                                 output_image_path=output_image_path,
                                                 extract_detected_objects=True)
    print('------------------- %d -------------------' % int(i + 1))
    for eachObject in detections:
        print(eachObject[&quot;name&quot;], &quot; : &quot;, eachObject[&quot;percentage_probability&quot;], &quot; : &quot;, eachObject[&quot;box_points&quot;])
    print('------------------- %d -------------------' % int(i + 1))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先第一行导入&lt;code&gt;ImageAI Object Detection&lt;/code&gt;类，在第二行导入&lt;code&gt;os&lt;/code&gt;库。&lt;br/&gt;然后创建了ObjectDetection类的新实例，接着就可以选择要使用的算法。分别有以下三个函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;.setModelTypeAsRetinaNet() 
.setModelTypeAsYOLOv3()
.setModelTypeAsTinyYOLOv3()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;选择好算法之后就要设置模型文件路径，这里给出的路径必须要和选择的算法一样。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;.setModelPath() 
- 参数path（必须）：模型文件的路径&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;载入模型。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;.loadModel()
- 参数detection_speed（可选）：最多可以减少80%的时间，单身会导致精确度的下降。可选的值有： “normal”, “fast”, “faster”, “fastest” 和 “flash”。默认值是 “normal”。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过os库的函数得到输入输出文件的路径等，这不是本文重点，跳过不表。&lt;br/&gt;开始对图像进行目标检测。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;.detectObjectsFromImage()
- 参数input_image（必须）：待检测图像的路径
- 参数output_image（必须）：输出图像的路径
- 参数parameter minimum_percentage_probability（可选）：能接受的最低预测概率。默认值是50%。
- 参数display_percentage_probability（可选）：是否展示预测的概率。默认值是True。
- 参数display_object_name（可选）：是否展示识别物品的名称。默认值是True。
- 参数extract_detected_objects（可选）：是否将识别出的物品图片保存。默认是False。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回值根据不同的参数也有不同，但都会返回一个an array of dictionaries。字典包括以下几个属性：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;* name (string)
* percentage_probability (float)
* box_points (tuple of x1,y1,x2 and y2 coordinates)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;前面说过可以识别80种目标，在这里也可以选择只识别自己想要的目标。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;custom = detector.CustomObjects(person=True, dog=True)

detections = detector.detectCustomObjectsFromImage( custom_objects=custom, input_image=os.path.join(execution_path , &quot;image3.jpg&quot;), output_image_path=os.path.join(execution_path , &quot;image3new-custom.jpg&quot;), minimum_percentage_probability=30)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先用定义自己想要的目标，其余的目标会被设置为False。然后配合&lt;code&gt;.detectCustomObjectsFromImage()&lt;/code&gt;进行目标检测。&lt;/p&gt;
&lt;p&gt;主要的代码基本如上所述，接下来看结果。先看看图片中只有一个目标的效果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1410231/201908/1410231-20190808231800281-221338801.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1410231/201908/1410231-20190808231812781-614212624.jpg&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;------------------- 10 -------------------
dog  :  98.83476495742798  :  (117, 91, 311, 360)
dog  :  99.24255609512329  :  (503, 133, 638, 364)
dog  :  99.274742603302  :  (338, 38, 487, 379)
------------------- 10 -------------------&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果还是不错的。再看看如果图片中有多个目标识别的结果如何。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1410231/201908/1410231-20190808232311310-2017172999.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1410231/201908/1410231-20190808232335144-1629179811.jpg&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;------------------- 4 -------------------
book  :  55.76887130737305  :  (455, 74, 487, 146)
book  :  82.22097754478455  :  (466, 11, 482, 69)
tv  :  99.34800863265991  :  (25, 40, 182, 161)
bed  :  88.7190580368042  :  (60, 264, 500, 352)
cat  :  99.54025745391846  :  (214, 125, 433, 332)
------------------- 4 -------------------
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;识别度还是很高的，背后人眼都看不清的书本都能被识别。&lt;/p&gt;

&lt;p&gt;GitHub：&lt;a href=&quot;https://github.com/Professorchen/Computer-Vision/tree/master/object-detection&quot; class=&quot;uri&quot;&gt;https://github.com/Professorchen/Computer-Vision/tree/master/object-detection&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 08 Aug 2019 17:21:00 +0000</pubDate>
<dc:creator>闽A2436</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/multhree/p/11324786.html</dc:identifier>
</item>
<item>
<title>从图片中把人物抠出来 - 三人行工作室</title>
<link>http://www.cnblogs.com/timeddd/p/11324682.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/timeddd/p/11324682.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;图片中物体（人物，动物或其它特定物品）的精确识别与提取是人工智能领域重要的一个方面，通过机器学习，最终能达到不需要人工干预准确的进行识别。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;以云服务的方式提供&quot;&gt;以云服务的方式提供&lt;/h3&gt;
&lt;p&gt;由于这些算法依赖于大量的训练或基础数据，所以，对于一些成果，以静态的算法，每个应用独立去完成漫漫的训练不是个好办法。因此，很多类似的成果会以一种 api 服务接口方式提供，当然服务可能需要付费，但一般有一定的免费量。&lt;/p&gt;
&lt;h3 id=&quot;使用-removebg&quot;&gt;使用 removeBG&lt;/h3&gt;
&lt;p&gt;removeBG 就是这样一种服务，其详细的 api 接口详见 &lt;a href=&quot;https://www.remove.bg/api&quot; class=&quot;uri&quot;&gt;https://www.remove.bg/api&lt;/a&gt;，它使用简单，就一个 api 并且提供了多种语言的调用示例。api 免费使用量的限制为&lt;strong&gt;每月50次调用&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;c-使用示例&quot;&gt;C# 使用示例&lt;/h3&gt;
&lt;h4 id=&quot;获取-api-密钥&quot;&gt;（1）获取 api 密钥&lt;/h4&gt;
&lt;p&gt;注册登录后，在 My Account 中可以查看到 apiKey，实现的方法中需要用到。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/577842/201908/577842-20190809000648180-370226230.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;根据示例代码形成易调用方法&quot;&gt;（2）根据示例代码形成易调用方法&lt;/h4&gt;
&lt;p&gt;这里，需求定义为，传入图片 url，返回提取结果的 url。&lt;br/&gt;则方法实现如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private string Cutout(string picUrl)
{
    if (String.IsNullOrEmpty(picUrl)) throw new Exception(&quot;空空如也&quot;);

    using (var client = new HttpClient())
    using (var formData = new MultipartFormDataContent())
    {
        // 申请的 apikey 可考虑动态的调整
        string key = &quot;myremovebgapikey&quot;;  // apiKey

        formData.Headers.Add(&quot;X-Api-Key&quot;, key);
        formData.Add(new StringContent(picUrl), &quot;image_url&quot;);
        formData.Add(new StringContent(&quot;auto&quot;), &quot;size&quot;);
        var response = client.PostAsync(&quot;https://api.remove.bg/v1.0/removebg&quot;, formData).Result;

        if (response.IsSuccessStatusCode)
        {
            string imgName = DateTime.Now.ToString(&quot;yyyyMMddHHmmss&quot;);
            FileStream fileStream = new FileStream(HttpContext.Current.Server.MapPath(String.Format(&quot;~/images/{0}.png&quot;, imgName)), FileMode.Create, FileAccess.Write, FileShare.None);
            response.Content.CopyToAsync(fileStream).ContinueWith((copyTask) =&amp;gt; { fileStream.Close(); });

            string imgUrl = String.Format(&quot;http://mydomain/images/{0}.png&quot;, imgName);
            return imgUrl;
        }
        else
        { 
            throw new Exception(response.Content.ReadAsStringAsync().Result); 
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;示例体验&quot;&gt;示例体验&lt;/h3&gt;
&lt;p&gt;如下图，左边的图片，去除背景，抠出的人物效果如右图。图片会是背景透明的 png 文件，很方便自已添加背景。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/577842/201908/577842-20190808233540633-1358161623.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;操作方式&quot;&gt;操作方式&lt;/h4&gt;
&lt;p&gt;关注公众号“时间维度”：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/17509417-84c6fb9852188aff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/108/format/webp&quot;/&gt;&lt;/p&gt;
&lt;p&gt;发送带有人物的图片即可。&lt;strong&gt;有使用量限制&lt;/strong&gt;，哈哈！&lt;/p&gt;
</description>
<pubDate>Thu, 08 Aug 2019 16:11:00 +0000</pubDate>
<dc:creator>三人行工作室</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/timeddd/p/11324682.html</dc:identifier>
</item>
<item>
<title>NLP（十四）自制序列标注平台 - jclian91</title>
<link>http://www.cnblogs.com/jclian91/p/11324681.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jclian91/p/11324681.html</guid>
<description>[unable to retrieve full-text content]在平时的NLP任务中，我们经常用到命名实体识别（NER），常用的识别实体类型为人名、地名、组织机构名，但是我们往往也会有识别其它实体的需求，比如时间、品牌名等。在利用算法做实体识别的时候，我们一般采用序列标注算法，这就对标注的文本格式有一定的要求，因此，一个好的序列标注的平台必不可少，将会大大减少我...</description>
<pubDate>Thu, 08 Aug 2019 16:10:00 +0000</pubDate>
<dc:creator>jclian91</dc:creator>
<dc:identifier>https://www.cnblogs.com/jclian91/p/11324681.html</dc:identifier>
</item>
</channel>
</rss>