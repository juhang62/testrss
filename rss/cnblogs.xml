<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>angular6 填坑之sdk - wangmiao2606</title>
<link>http://www.cnblogs.com/wangmiao2606/p/10179287.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangmiao2606/p/10179287.html</guid>
<description>&lt;p&gt;技术背景：angular + ant zorro&lt;/p&gt;
&lt;p&gt;最为大型前端团队首选的前端技术框架，angular，在国内多少还是有些水土不服。本人将针对angular做个一系列的填坑分享。&lt;/p&gt;
&lt;p&gt;坑一：sdk&lt;/p&gt;
&lt;p&gt;angular的sdk不属于各个模块，直接挂载在body下面， ant design直接使用sdk，导致任何的弹出层，如select，dropdown，picker等在弹出来的时候自动创建覆盖全局的sdk，需要点击sdk才能关闭已打开的下拉。&lt;/p&gt;
&lt;p&gt;明显需要点击两次才能出现一个下拉是产品们不能接受的。&lt;/p&gt;
&lt;p&gt;解决方案有两个，一个是修改底层源码，抛弃sdk，明显成本巨大，而且bug会层出不穷，考虑不周全，建议缺少前端架构组的团队就不用考虑了。&lt;/p&gt;
&lt;p&gt;本人选择了另外一个方案，有点取巧，但是能快速解决问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/756735/201812/756735-20181226151347639-1675837550.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;步奏一：&lt;/p&gt;
&lt;p&gt;将sdk缩小至1x1px，让鼠标可以点击网页中任意地方。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:css;gutter:true;&quot;&gt;
.cdk-overlay-backdrop {
    width: 1px!important;
    height: 1px!important;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;步奏二：监听document点击事件&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
document.addEventListener('click', (e) =&amp;gt; {
    this.prepareHideModal(e);
});
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;步奏三：获取当前点击的select等的唯一标识&lt;/p&gt;
&lt;p&gt;使用sdk的组件比较多，有的有唯一标识，没有的特殊处理&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
getSign(e) {
        for (const v of e['path']) {
            if (v.tagName == 'NZ-SELECT' || v.tagName == 'APP-SUBJECTPICKER') {
                // 下拉框获取sign
                if (v.classList[0].includes('ng-tns-')) {
                    this.sign = v.classList[0];
                } else {
                    this.sign = v.classList[1];
                }
                this.signType = 'NZ-NORMAL';
                break;
            } else if (v.tagName == 'NZ-PICKER') {
                // picker 获取sign
                this.sign = v.classList[0];
                this.signType = 'NZ-PICKER';
                break;
            }
            // popover 获取sign
            if (v.getAttributeNode &amp;amp;&amp;amp; v.getAttributeNode('nz-popover') &amp;amp;&amp;amp; v.getAttribute('nz-popover') == '') {
                this.sign = 'NZ-POPOVER';
                this.signType = 'NZ-POPOVER';
                break;
            }
        }
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;步奏四：关闭已打开的下拉组件&lt;/p&gt;
&lt;p&gt;为什么叫prepareHideModal，这是获取sign前的操作，先关闭再去获取点击下拉的sign&lt;/p&gt;
&lt;p&gt;getSign方法在关闭后执行&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
prepareHideModal(e) {
        let doClose = true;
        if (window['globalSignType']) {
            this.hideAllmodal();
            window['globalSignType'] = null;
            return;
        }
        // 如果有sign，关闭已打开的
        if (this.sign) {
            let _sign = this.sign;
            // 判断某些情况下不关闭弹框
            if (_sign == 'NZ-POPOVER') {
                // 解决没有特使标识时点击cdk本身不消失
                for (const v of e['path']) {
                    if (v.classList &amp;amp;&amp;amp; v.classList.contains('cdk-overlay-container')) {
                        doClose = false;
                    }
                }
            } else {
                // 常规有指定sign时点击选择器自身时不消失
                for (const v of e['path']) {
                    if (v.classList &amp;amp;&amp;amp; v.classList.contains(_sign)) {
                        doClose = false;
                        break;
                    }

                }
            }
            doClose &amp;amp;&amp;amp; this.hideModal(_sign);
        }
        this.getSign(e);
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;步奏五：最重要的关闭sdk，这边采用了最简单的，模拟sdk点击，完全使用sdk自己的方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
hideModal(sign) {
        let cdkDom = document.querySelectorAll('.cdk-overlay-backdrop.cdk-overlay-dark-backdrop.cdk-overlay-backdrop-showing');
        let domLen = cdkDom.length;
        // 循环cdk，找到它自身的cdk，模拟点击隐藏
        for (var i = 0; i &amp;lt; domLen; i++) {
            var v = cdkDom[i];
            if (v['style'].display != 'none') {
                v['click']();
                break;
            }
        }
        this.sign = null;
        this.signType = null;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;至此算是解决了使用skd组件需要点击两次的坑，但是会引起另外一个坑，当页面出现滚动条时，已打开的下来组件位置不会跟着滚动而去改变。这边会在另外一篇博客中解决&lt;/p&gt;

</description>
<pubDate>Wed, 26 Dec 2018 07:16:00 +0000</pubDate>
<dc:creator>wangmiao2606</dc:creator>
<og:description>最为大型前端团队首选的前端技术框架，angular，在国内多少还是有些水土不服。本人将针对angular做个一系列的填坑分享。 坑一：sdk</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wangmiao2606/p/10179287.html</dc:identifier>
</item>
<item>
<title>数据结构入门（三）栈的应用 - jclian91</title>
<link>http://www.cnblogs.com/jclian91/p/10179235.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jclian91/p/10179235.html</guid>
<description>&lt;p&gt;  在之前的两篇文章——&lt;a href=&quot;https://www.jianshu.com/p/d47397c21f2e&quot;&gt;数据结构入门（一）栈的实现&lt;/a&gt;和&lt;a href=&quot;https://www.jianshu.com/p/0e17f00d7559&quot;&gt;数据结构入门（二）栈的应用之数学表达式求值&lt;/a&gt;中，笔者分别介绍了“栈”这个数据结构在数的进制转换和数学表达式求值方面的应用。在本文中，笔者将会再介绍栈的四个应用，它们分别是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;判断字符串是否回文&lt;/li&gt;
&lt;li&gt;括号匹配&lt;/li&gt;
&lt;li&gt;行编辑程序&lt;/li&gt;
&lt;li&gt;二叉树的深度优先遍历&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;  栈的结构实现可以参考&lt;a href=&quot;https://www.jianshu.com/p/0e17f00d7559&quot;&gt;数据结构入门（二）栈的应用之数学表达式求值&lt;/a&gt;，本文将不再具体给出。&lt;/p&gt;
&lt;h3 id=&quot;判断字符串是否回文&quot;&gt;判断字符串是否回文&lt;/h3&gt;
&lt;p&gt;  所谓回文字符串就是指正读反读均相同的字符序列，如“12321”、“aha”、“ahaha”、“清水池里池水清”均是回文，但“ahah”不是回文。通过栈这个数据结构我们将很容易判断一个字符串是否为回文。&lt;br/&gt;  首先我们需要找到该字符串的中心点。对于长度为奇数的字符串，中心点就是中间的那个元素；对于长度为偶数的字符串，中心点恰好位于长度为一半的那个元素及其后一个元素的中间。接着将中心点前面的字符依次入栈，然后将当前栈中的字符依次出栈，看看是否能与 中心点之后的字符一一匹配，如果都能匹配则说明这个字符串是回文字符串，否则就不是回文字符串。&lt;br/&gt;  以下是利用栈来实现判断字符串是否回文的Python代码：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# -*- coding: utf-8 -*-
# using Stack to check if a string is plalindrome

from Stack import Stack

def isPlalindrome(words):
    length = len(words)
    flag = length//2
    s = Stack()
    for i in range(flag):
        s.push(words[i])

    start = flag+1 if length % 2 else flag
    for item in words[start:]:
        if s.pop() != item:
            return False

    return True

def main():
    words_list = [&quot;12321&quot;, &quot;aha&quot;, &quot;ahaha&quot;, &quot;清水池里池水清&quot;, &quot;ahah&quot;]
    for words in words_list:
        res = isPlalindrome(words)
        print(&quot;'%s' is plalindrome: %s&quot; % (words, res))

main()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果如下：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;'12321' is plalindrome: True&lt;br/&gt;'aha' is plalindrome: True&lt;br/&gt;'ahaha' is plalindrome: True&lt;br/&gt;'清水池里池水清' is plalindrome: True&lt;br/&gt;'ahah' is plalindrome: False&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;括号匹配&quot;&gt;括号匹配&lt;/h3&gt;
&lt;p&gt;  在字符串中，我们常常会遇到括号匹配的问题，常见的括号如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;小括号： “(”和“）”&lt;/li&gt;
&lt;li&gt;中括号： “[”和“]”&lt;/li&gt;
&lt;li&gt;花括号： “{”和“}”&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;每一个开符号必须匹配与其对应的闭符号。以下为匹配示例：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;正确: ( )(( )){([( )])}&lt;/li&gt;
&lt;li&gt;正确: ((( )(( )){([( )])}))&lt;/li&gt;
&lt;li&gt;错误: )(( )){([( )])}&lt;/li&gt;
&lt;li&gt;错误: ({[])}&lt;/li&gt;
&lt;li&gt;错误: (&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;  下面说明括号匹配的算法。从左至右检查每个元素，用栈S储存括号。每当遇到一个开符号时，就入栈，每当遇到闭符号时，就出栈（假设S非空），并检查两者是否匹配。如果所有元素都检查完毕，且栈S为空，那么原来的表达式括号匹配，否则就不匹配。&lt;br/&gt;  下面是括号匹配的Python代码：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# -*- coding: utf-8 -*-
# matching parentheses

from Stack import Stack

def is_matched(expr):
    # return True if all delimiters are properly match; False otherwise
    lefty = '({['   # opening delimiters
    righty = ')}]'  # respective closing delimiters
    s = Stack()
    for c in expr:
        if c in lefty:
            s.push(c)
        elif c in righty:
            if s.is_empty():    # nothing to match with
                return False
            if righty.index(c) != lefty.index(s.pop()): # mismatched
                return False
    return s.is_empty()

def main():
    expr_list = ['[(5+x)-(y+z)]', '(5+x))*y', '{[1+(x+y)]}*[(3*z)]']
    for expr in expr_list:
        Flag = is_matched(expr)
        print('%s is matched: %s' %(expr, Flag))

main()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果如下：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;[(5+x)-(y+z)] is matched: True&lt;br/&gt;(5+x))&lt;em&gt;y is matched: False&lt;br/&gt;{[1+(x+y)]}&lt;/em&gt;[(3*z)] is matched: True&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;行编辑程序&quot;&gt;行编辑程序&lt;/h3&gt;
&lt;p&gt;  一个简单的行编辑程序的功能是：接收用户从终端输入的程序或数据，并存入用户的数据区。由于用户在终端上进行输入时，不能保证不出差错，因此，若在编辑程序中，“每接收一个字符即存入用户数据区”的做法是不恰当的。较好的做法是，设立一个输入缓冲区，用以接受用户输入的每一行字符，然后逐行存入用户数据区。允许用户输入出差错，并在发现有误时可以及时更正。例如，当用户发现刚刚输入的一个字符是错的时，可以补进一个退格符“#”，表示前一个字符无效；如果发现当前输入的行内差错较多或难以补救，则可以输入一个退行符“@”，表示当前行中的字符均无效。比如，假设从终端接收了两行这样的字符：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;whli##ilr#e(s#*s)&lt;br/&gt;outcha@putchar(*s=#++);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;则实际有效的是下列两行：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;while(*s)&lt;br/&gt;putchar(*s++);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;  行编辑程序的输出结果可用栈来解决。可设这个输入缓冲区为一个栈结构，每当从终端接受了一个字符后先做如下判别：如果它既不是退格符也不是退行符，则将该字符入栈；如果是一个退格符，则从栈顶删去一个字符；如果它是退行符，则将该栈清空。以下为实现行编辑程序的Python代码：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# -*- coding: utf-8 -*-
# line edit programming
from Stack import Stack

# line edit programming using Stack
def LineEdit(chars):

    s = Stack()
    for char in chars:
        if char != '\n':    # line edit
            if char == '#':
                s.pop()
            elif char == '@':
                s.clear()
            else:
                s.push(char)
        else:   # output
            line = []
            while not s.is_empty():
                line.append(s.pop())
            print(''.join(line[::-1]))

def main():
    chars = &quot;&quot;&quot;whli##ilr#e(s#*s)
    outcha@putchar(*s=#++)
    fi@if a=# == 'exti##it':
    system@    sys.tiex####exit((#)
    &quot;&quot;&quot;

    LineEdit(chars)

main()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;while(*s)
putchar(*s++)
if a == 'exit':
    sys.exit()&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;二叉树的深度优先遍历&quot;&gt;二叉树的深度优先遍历&lt;/h3&gt;
&lt;p&gt;  关于二叉树的介绍与实现，可以参考笔者的文章：&lt;a href=&quot;https://www.jianshu.com/p/9503238394df&quot;&gt;二叉树的Python实现&lt;/a&gt;。二叉树的深度优先遍历，也就是先序、中序、后续遍历，在文章&lt;a href=&quot;https://www.jianshu.com/p/9503238394df&quot;&gt;二叉树的Python实现&lt;/a&gt;中，我们已经用递归的方法实现了，这是因为二叉树天然就具有良好的递归性质，就连它的定义也可用递归来实现。在本文中，笔者将要用栈来实现二叉树的深度优先遍历。&lt;br/&gt;  以先序遍历为例，先访问根结点，然后遍历左子树接着是遍历右子树，因此我们可以利用堆栈的先进后出的特点，先将右子树压栈，再将左子树压栈，这样左子树就位于栈顶，可以保证结点的左子树先与右子树被遍历。&lt;br/&gt;  二叉树的实现代码不再给出，读者可参考&lt;a href=&quot;https://www.jianshu.com/p/9503238394df&quot;&gt;二叉树的Python实现&lt;/a&gt;，用栈实现前序遍历的函数如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;    # 使用栈结构实现前序遍历
    def preStack(self):
        if self.data is not None:
            s = Stack()
            s.push(self)
            while not s.is_empty():
                currentNode = s.pop()
                print(currentNode.data, end=' ')
                if currentNode.right is not None:
                    s.push(currentNode.right)
                if currentNode.left is not None:
                    s.push(currentNode.left)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;构建的示例二叉树如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9419034-11f244bbbd251bb9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;示例二叉树&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输出的结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;先序遍历（递归）为:
18 7 3 4 11 5 1 3 6 2 4 
先序遍历（非递归）为:
18 7 3 4 11 5 1 3 6 2 4 &lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;  堆栈（Stack）最早由 Alan M. Turing（艾伦·图灵）于 1946 年提出，当时是为了解决子程序的调用和返回。在本文及前面的文章中，介绍了一些关于栈的应用，当然，还有许多话题未涉及，比如：解决迷宫问题，HTML标签匹配，子程序的调用和返回等。另外，栈还常常与递归方法一起使用，能轻松地解决很多问题~&lt;br/&gt;  关于栈在其它问题中的应用，可以参考网址: https://www.geeksforgeeks.org/stack-data-structure/ 。&lt;/p&gt;
&lt;h3 id=&quot;参考文献&quot;&gt;参考文献&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;《啊哈！算法》啊哈磊著 人民邮电出版社 p32-35&lt;/li&gt;
&lt;li&gt;《数据结构(C语言版)》 严蔚敏 吴伟民 著 清华大学出版社 p48-50&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Data Structures &amp;amp; Algorithms in Python&lt;/em&gt;, M.T.Goodrich, R.Tamassia, M.H.Goldwasser著, p229-237&lt;/li&gt;
&lt;li&gt;二叉树深度遍历的非递归算法分析及Java实现: https://my.oschina.net/husthang/blog/852982&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Wed, 26 Dec 2018 07:08:00 +0000</pubDate>
<dc:creator>jclian91</dc:creator>
<og:description>数据结构入门（三）栈的应用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jclian91/p/10179235.html</dc:identifier>
</item>
<item>
<title>Chrome获取微信授权，调试公众号页面 - 馨语随风</title>
<link>http://www.cnblogs.com/tracyjfly/p/10179023.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tracyjfly/p/10179023.html</guid>
<description>&lt;p&gt;        你可能遇到过这种情况，在微信中打开公众号是这样的。&lt;br/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/298768/201812/298768-20181226143257270-1408172605.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;        复制链接，在chrome中打开是这样的&lt;img src=&quot;http://img.baidu.com/hi/jx2/j_0004.gif&quot; alt=&quot;&quot;/&gt;。&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/298768/201812/298768-20181226143309399-754890593.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;         博主今天要解决的就是，如果在chrome中加载需要微信授权的页面，至于加载成功后要干嘛，测试？抓包？查看源码？...这就是你的事情了，先来说说怎么绕过这个验证吧。&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;        工欲善其事必先利其器，先来说说工具。&lt;br/&gt;&lt;/p&gt;

&lt;table&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr class=&quot;ue-table-interlace-color-single firstRow&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;707&quot;&gt;&lt;span&gt;&lt;strong&gt;工具名称&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;707&quot;&gt;&lt;span&gt;&lt;strong&gt;用途&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;ue-table-interlace-color-double&quot; readability=&quot;2&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;707&quot;&gt;微信PC版&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;707&quot;&gt;PC版的微信内置浏览器能获取微信授权、复制页面链接&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;ue-table-interlace-color-single&quot; readability=&quot;2&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;707&quot;&gt;Chrome浏览器&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;707&quot;&gt;调试工具，我们的目的就是在chrome里面绕过微信授权&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;ue-table-interlace-color-double&quot; readability=&quot;2&quot;&gt;&lt;td rowspan=&quot;1&quot; colspan=&quot;1&quot; valign=&quot;top&quot;&gt;Fiddler4&lt;br/&gt;&lt;/td&gt;
&lt;td rowspan=&quot;1&quot; colspan=&quot;1&quot; valign=&quot;top&quot;&gt;抓包工具，需要靠它的网络抓包来获取微信授权信息&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;        &lt;img src=&quot;http://img.baidu.com/hi/jx2/j_0003.gif&quot; alt=&quot;&quot;/&gt;准备就绪，开工。&lt;/p&gt;
&lt;p&gt;        &lt;span&gt;01 开启&lt;span&gt;Fiddler4抓包&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;        Fiddler4使用方法，可以自行百度，不过本文讲述的使用很简单，安装-直接运行即可。&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;       &lt;span&gt; 02 登录微信PC版&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;        Fiddler4运行后，手机微信扫码登录，然后点击需要调试的公众号内容。示例如下图。&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/298768/201812/298768-20181226143325568-983286630.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/298768/201812/298768-20181226143330206-263604802.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;        &lt;span&gt;03 抓取微信授权信息&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;        这个时候看到Fiddler4里面出现了很多网络抓取数据，先看当前页面的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/298768/201812/298768-20181226143554901-548691817.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;        看到右侧的参数没？下一步我们就将在Chrome中使用到这些。&lt;/p&gt;
&lt;p&gt;        &lt;span&gt;04 配置Chrome，绕过微信客户端检测&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;        直接复制URL地址：http://play10.beetobees.com/play/tpl_airfight/lT0tW1gt/ 。粘贴到chrome，不用猜，肯定提示“请在微信客户端中打开链接”。&lt;/p&gt;
&lt;p&gt;        处理方法，复制“User-Agent”参数， Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.95 Safari/537.36 MicroMessenger/6.5.2.501 NetType/WIFI WindowsWechat QBCore/3.43.901.400 QQBrowser/9.0.2524.400&lt;/p&gt;
&lt;p&gt;        为什么会提示在微信客户端中打开链接，原因就在User-Agent这个里面，微信公众号是通过这个参数来识别浏览器版本的，如果不是腾讯自家的浏览器就不给你授权。Chrome中配置User-Agent的方法。&lt;/p&gt;
&lt;p&gt;        F12，然后点击下图的按钮，打开“NetWork conditions”选项卡。&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/298768/201812/298768-20181226143409575-568984177.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.cnblogs.com/Upload/9024b98a-37d4-44a9-ac05-60860c51581b8.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;        按照下图，填入“User-Agent”内容。&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/298768/201812/298768-20181226143424163-1245199976.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.cnblogs.com/Upload/ae9c6138-31f1-411d-a274-366b1f6cf45f9.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;        然后刷新下页面。不会再出现“请在微信客户端中打开链接”的提示了，但是却出现了空白，title变成了“出错了”。原因很简单，浏览器获取不到微信的授权信息，解决方法见第5步。        &lt;/p&gt;
&lt;p&gt;        &lt;span&gt;05 获取微信授权真实地址&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;        微信授权机制是这样的，浏览器请求，微信验证，然后通过后返回到请求页面，所以是我们的链接地址不对，那真实的链接在哪儿呢？看下图。、&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/298768/201812/298768-20181226143608868-2145712151.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;        紧挨着上一个抓取记录下面有一个open.weixin.qq.com的记录，查看下URL：&lt;a href=&quot;https://open.weixin.qq.com/connect/oauth2/authorize?appid=xxxxxxxxxxxxx&amp;amp;redirect_uri=http%3A%2F%2Fplay10.beetobees.com%2Fplay%2Ftpl_airfight%2FlT0tW1gt%2F&amp;amp;response_type=code&amp;amp;scope=snsapi_userinfo&amp;amp;state=545e667db4256209ca5be9f4d6e44c89&amp;amp;uin=NjMwMTIzNDQw&amp;amp;key=4322f3c03a626475293b9c1bf1d1c80b5adc689b8a4701331f9c139bef6ba8904f7155518d63ba539966f0c7ec4c2074c393c784366971c89c93a2f085ac2cef4570a99b2b19e47ae0248288ee7d4edf&amp;amp;version=62060526&amp;amp;pass_ticket=T%2FoANTyAIgN9WXrK5OpCaHOQqk15QjaBB3z94VvCz6oSsItFxZ8KFSCqRGAiMEsy&quot;&gt;https://open.weixin.qq.com/connect/oauth2/authorize?appid=xxxxxxxxxxxxx&amp;amp;redirect_uri=http%3A%2F%2Fplay10.beetobees.com%2Fplay%2Ftpl_airfight%2FlT0tW1gt%2F&amp;amp;response_type=code&amp;amp;scope=snsapi_userinfo&amp;amp;state=545e667db4256209ca5be9f4d6e44c89&amp;amp;uin=NjMwMTIzNDQw&amp;amp;key=4322f3c03a626475293b9c1bf1d1c80b5adc689b8a4701331f9c139bef6ba8904f7155518d63ba539966f0c7ec4c2074c393c784366971c89c93a2f085ac2cef4570a99b2b19e47ae0248288ee7d4edf&amp;amp;version=62060526&amp;amp;pass_ticket=T%2FoANTyAIgN9WXrK5OpCaHOQqk15QjaBB3z94VvCz6oSsItFxZ8KFSCqRGAiMEsy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;        里面的redirect_uri参数就是访问的页面，我们把这个地址复制到刚才的Chrome里面，访问，结果如下图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/298768/201812/298768-20181226143617292-693098873.png&quot; alt=&quot;&quot;/&gt;        &lt;img src=&quot;http://www.cnblogs.com/Upload/5d0901c1-2141-43bd-9eaa-c9c27958662810.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;        &lt;span&gt;06 收工&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;        到了这一步，后面的操作就看自己了。用类似方法，基本可以绕过所有的微信公众号授权。打卡收工&lt;img src=&quot;http://img.baidu.com/hi/jx2/j_0061.gif&quot; alt=&quot;&quot;/&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;　　更多前端、GIS相关博客，请访问我的&lt;a href=&quot;http://www.88gis.cn/&quot; target=&quot;_blank&quot;&gt;个人博客88gis.cn&lt;/a&gt;查看更多&lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 26 Dec 2018 06:38:00 +0000</pubDate>
<dc:creator>馨语随风</dc:creator>
<og:description>1.目的 你可能遇到过这种情况，在微信中打开公众号是这样的。 复制链接，在chrome中打开是这样的。 博主今天要解决的就是，如果在chrome中加载需要微信授权的页面，至于加载成功后要干嘛，测试？抓</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tracyjfly/p/10179023.html</dc:identifier>
</item>
<item>
<title>006.Docker网络管理 - 木二</title>
<link>http://www.cnblogs.com/itzgr/p/10179003.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/itzgr/p/10179003.html</guid>
<description>&lt;h2&gt;&lt;span&gt;一&lt;/span&gt; &lt;span&gt;docker网络模式&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;Docker使用Linux的Namespaces技术来进行资源隔离，如PID Namespace隔离进程，Mount Namespace隔离文件系统，Network Namespace隔离网络等。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;一个Network Namespace提供了一份独立的网络环境，包括网卡、路由、Iptable规则等都与其他的Network Namespace隔离，Docker容器一般会分配一个独立的Network Namespace。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;1.1 四种模式&lt;/h3&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;host模式&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;指定方式：--net=host&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;container模式&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;指定方式：--net=container:NAME_or_ID&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;none模式&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;指定方式：--net=none&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;bridge模式&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;指定方式：--net=bridge&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; root@docker:~# docker network ls           #默认已经创建好三种模式，且无法删除
&lt;span&gt;  2&lt;/span&gt; NETWORK ID          NAME                DRIVER              SCOPE
&lt;span&gt;  3&lt;/span&gt; 4237839afd99        bridge              bridge              local
&lt;span&gt;  4&lt;/span&gt; c7a14aafc3b5        host                host                local
&lt;span&gt;  5&lt;/span&gt; 3cc2eba3eb5f        none                null                local
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;1.2 host模式&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;容器网络指定为host模式，则容器将不会获得独立的Network Namespace，该模式下宿主机共用一个Network Namespace。容器将不会虚拟出自己的网卡，不会配置独有的IP等，而是使用宿主机的IP和端口。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;其具有以下特点：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;host模式下的容器没有隔离的 network namespace；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;容器的 IP 地址同 Docker host 的 IP 地址；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;需要注意容器中服务的端口号不能与 Docker host 上已经使用的端口号相冲突；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;host 模式能够和其它模式共存。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181226143445714-1014763104.png&quot;&gt;&lt;img title=&quot;49_thumb1&quot; src=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181226143446734-1666061157.png&quot; alt=&quot;49_thumb1&quot; width=&quot;631&quot; height=&quot;319&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; root@docker:~# docker run -d --name docker_host1 --network host training/webapp python app.py
&lt;span&gt;  2&lt;/span&gt; root@docker:~# docker exec -it docker_host1 /bin/bash
&lt;span&gt;  3&lt;/span&gt; root@docker:/opt/webapp# ifconfig -a
&lt;/pre&gt;&lt;/div&gt;

&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181226143447230-966616442.png&quot;&gt;&lt;img title=&quot;50_thumb1&quot; src=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181226143447538-1009036062.png&quot; alt=&quot;50_thumb1&quot; width=&quot;575&quot; height=&quot;451&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;宿主机172.24.8.90/24上使用host模式启动一个容器，则查看的网卡信息为宿主机信息，容器中的应用对外直接采用宿主机IP地址提供服务，无任何NAT转换。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;注意：除网络外，容器的其他方面，如文件系统、进程列表等还是和宿主机隔离的，同时采用host模式，端口无法做映射，无需指定，否则会出现warning告警。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;1.3 container模式&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;Container 网络模式是 Docker 中一种较为特别的网络的模式，处于container模式下的 Docker 容器会共享其他容器的网络环境，因此，两个或以上的容器之间不存在网络隔离，而配置container模式的容器又与宿主机以及除此之外其他的容器存在网络隔离。 &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181226143448144-175164657.png&quot;&gt;&lt;img title=&quot;51_thumb1&quot; src=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181226143448814-1239069466.png&quot; alt=&quot;51_thumb1&quot; width=&quot;629&quot; height=&quot;389&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; root@docker:~# docker run -dit --name docker_host2 centos7-xhy /bin/bash
&lt;span&gt;  2&lt;/span&gt; root@docker:~# docker run -dit --name docker_host3 --network container:docker_host2 centos7-xhy /bin/bash
&lt;span&gt;  3&lt;/span&gt; root@docker:~# docker exec -it docker_host2 /bin/bash
&lt;span&gt;  4&lt;/span&gt; [root@c9b51e88f75a /]# ifconfig -a
&lt;/pre&gt;&lt;/div&gt;

&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181226143449483-1280694137.png&quot;&gt;&lt;img title=&quot;52_thumb1&quot; src=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181226143449875-1009408928.png&quot; alt=&quot;52_thumb1&quot; width=&quot;569&quot; height=&quot;275&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; root@docker:~# docker exec -it docker_host3 /bin/bash
&lt;span&gt;  2&lt;/span&gt; [root@c9b51e88f75a /]# ifconfig -a
&lt;/pre&gt;&lt;/div&gt;

&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181226143450207-239934017.png&quot;&gt;&lt;img title=&quot;53_thumb1&quot; src=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181226143450703-409026197.png&quot; alt=&quot;53_thumb1&quot; width=&quot;571&quot; height=&quot;273&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;注意：因为此时两个容器要共享一个 network namespace，因此需要注意端口冲突情况，否则第二个容器将无法被启动，以上docker_host3因为端口原因，无法正常启动。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;1.4 none模式&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;none模式下，Docker容器拥有自己的Network Namespace，但是，并不为Docker容器进行任何网络配置和构造任何网络环境。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;Docker 容器采用了none 网络模式，那么容器内部就只能使用loopback网络设备，不会再有其他的网络资源。Docker Container的none网络模式意味着不给该容器创建任何网络环境，容器只能使用127.0.0.1的本机网络。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; root@docker:~# docker run -dit --name docker_host4 --network none centos7-xhy /bin/bash
&lt;span&gt;  2&lt;/span&gt; root@docker:~# docker exec -it docker_host4 /bin/bash
&lt;/pre&gt;&lt;/div&gt;

&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181226143450937-765590166.png&quot;&gt;&lt;img title=&quot;54_thumb1&quot; src=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181226143451299-1652279447.png&quot; alt=&quot;54_thumb1&quot; width=&quot;536&quot; height=&quot;145&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;h3&gt;1.5 bridge模式&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;见二。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;二 bridge模式&lt;/h2&gt;
&lt;h3&gt;2.1 bridge模式简介&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;bridge模式是Docker默认的网络设置，此模式会为每一个容器分配Network Namespace、设置IP等，并将该宿主机上的Docker容器连接到一个虚拟网桥上。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;使用docker run -p时，docker会在iptables写入DNAT规则，实现端口转发功能。可使用以下命令查看。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; root@docker:~# iptables -t nat -vnL
&lt;/pre&gt;&lt;/div&gt;

&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181226143451728-1448562206.png&quot;&gt;&lt;img title=&quot;55_thumb1&quot; src=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181226143452124-1719839012.png&quot; alt=&quot;55_thumb1&quot; width=&quot;955&quot; height=&quot;309&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;当Docker server启动时，会在主机上创建一个名为docker0的虚拟网桥，此主机上启动的Docker容器会连接到此虚拟网桥上，因此所有连接到此网桥的容器默认能互相通信。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;虚拟网桥会使该宿主机上所有容器就通过交换机连在了一个二层网络中，宿主机会选择一个和宿主机不同的IP地址和子网分配给docker0，连接到docker0的容器就从此子网中选择一个未占用的IP使用。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181226143452437-1821546680.png&quot;&gt;&lt;img title=&quot;56_thumb1&quot; src=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181226143453029-1717263494.png&quot; alt=&quot;56_thumb1&quot; width=&quot;574&quot; height=&quot;150&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;h3&gt;2.2 bridge模式特点&lt;/h3&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;使用一个 linux bridge，默认为 docker0；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;使用 veth 对，一端在容器的网络 namespace 中，另一端在 docker0 上；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;该模式下Docker Container不具有一个公有IP，因为宿主机的IP地址与veth pair的 IP地址不在同一个网段内；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;Docker采用 NAT 方式，将容器内部的服务监听的端口与宿主机的某一个端口port 进行“绑定”，使得宿主机以外的网络可以主动将网络报文发送至容器内部；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;外界访问容器内的服务时，需要访问宿主机的 IP 以及宿主机的端口 port；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;NAT 模式基于三层网络上的实现方式，故肯定会影响网络的传输效率；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;容器拥有独立、隔离的网络栈，以便于使得容器和宿主机以外的网络通过NAT建立通信；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181226143453693-206671192.png&quot;&gt;&lt;img title=&quot;57_thumb1&quot; src=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181226143454514-1627209791.png&quot; alt=&quot;57_thumb1&quot; width=&quot;630&quot; height=&quot;317&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; root@docker:~# docker run -dit --name docker_host5 -p 5005:80 training/webapp python app.py
&lt;span&gt;  2&lt;/span&gt; root@docker:~# docker exec -it docker_host5 /bin/bash
&lt;span&gt;  3&lt;/span&gt; root@951e6cd51cd0:/opt/webapp# ifconfig -a
&lt;/pre&gt;&lt;/div&gt;

&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181226143455104-363284204.png&quot;&gt;&lt;img title=&quot;58_thumb1&quot; src=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181226143455590-684455997.png&quot; alt=&quot;58_thumb1&quot; width=&quot;571&quot; height=&quot;279&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; root@docker:~# iptables -t nat -vnL                        #查看端口映射
&lt;/pre&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181226143456026-224970106.png&quot;&gt;&lt;img title=&quot;59_thumb1&quot; src=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181226143456528-1206359130.png&quot; alt=&quot;59_thumb1&quot; width=&quot;973&quot; height=&quot;344&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; root@docker:~# iptables-save
&lt;span&gt;  2&lt;/span&gt; ……
&lt;span&gt;  3&lt;/span&gt; -A POSTROUTING -s 172.17.0.3/32 -d 172.17.0.3/32 -p tcp -m tcp --dport 80 -j MASQUERADE
&lt;span&gt;  4&lt;/span&gt; ……
&lt;span&gt;  5&lt;/span&gt; -A DOCKER ! -i docker0 -p tcp -m tcp --dport 5005 -j DNAT --to-destination 172.17.0.3:80
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;解释：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;-s ：源地址172.17.0.0/16&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;-o：指定数据报文流出接口为docker0&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;-j ：动作为MASQUERADE（地址伪装）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;iptables规则中nat、filter的Docker链中分别增加了一条规则，这两条规则将访问宿主机5005端口的流量转发到了172.17.0.3的80端口上，即真正提供服务的Docker容器IP和端口，因此外界访问Docker容器是通过iptables做DNAT（目的地址转换）实现。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;三 docker容器的DNS和主机名&lt;/h2&gt;
&lt;h3&gt;3.1 DNS和主机名配置文件&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;同一个Docker镜像可以启动很多Docker容器，但各自容器的主机名并不一样，即主机名并非是被写入镜像中。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;通过在容器中运行mount命令可以查看/etc/目录下有3个文件，即容器启动后被虚拟文件覆盖的，分别是/etc/hostname、/etc/hosts、/etc/resolv.conf：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; root@docker:~# docker run -dit --name docker_host6 centos7-xhy /bin/bash
&lt;span&gt;  2&lt;/span&gt; root@docker:~# docker exec -it docker_host6 /bin/bash
&lt;span&gt;  3&lt;/span&gt; [root@12ac200c6a4c /]# mount
&lt;span&gt;  4&lt;/span&gt; ...
&lt;span&gt;  5&lt;/span&gt; /dev/sda4 on /etc/resolv.conf type ext4 (rw,relatime,data=ordered)
&lt;span&gt;  6&lt;/span&gt; /dev/sda4 on /etc/hostname type ext4 (rw,relatime,data=ordered)
&lt;span&gt;  7&lt;/span&gt; /dev/sda4 on /etc/hosts type ext4 (rw,relatime,data=ordered)
&lt;span&gt;  8&lt;/span&gt; ...
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;提示：此方式能解决主机名的问题，同时也能让DNS及时更新（改变resolv.conf）。由于这些文件的维护方法随着Docker版本演进而不断变化，因此尽量不修改这些文件。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;3.2 修改dns和主机名&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;docker容器的dns和主机名配置可通过Docker提供的参数进行相关设置，配置方式如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;-h HOSTNAME 或 --hostname=HOSTNAME：设置容器的主机名，此名称会写入/etc/hostname和/etc/hosts文件中，也会在容器的bash提示符看到。但是在外部，容器的主机名是无法查看的，不会出现在其他容器的hosts文件中，即使使用docker ps命令也无法查看。此参数是docker run命令的参数，而非docker daemon的启动参数。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;--dns=IP_ADDRESS...：为容器配置DNS，写入/etc/resolv.conf中。该参数可以在docker daemon 启动的时候设置，也可以在docker run时设置，默认为8.8.8.8或8.8.4.4。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;注意：对以上3个文件的修改不会被docker commit保存，即不会保存在镜像中，重启容器也会导致修改失效。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;四 多节点docker网络&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;docker跨主机通信按原理可通过以下三种方式实现：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;直接路由方式；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;桥接方式（如pipework）；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;Overlay隧道方式（如flannel、ovs+gre）等。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;Docker 多节点Overlay网络模式可以分为两类:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;一类是基于 VxLAN ，对跨节点网络的原生支持；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;另一种是通过插件（plugin）方式引入的第三方实现方案，比如 Flannel，Calico 等等。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;h3&gt;4.1 直接路由方式&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;在docker所在的不同宿主机上采用静态路由方式实现。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;4.2 桥接-pipework方式&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;当两台网络已联通的宿主机01和02都存在多个容器组成的集群时，需要相互访问容器应用时，可通过静态指定容器IP为宿主机IP同一个网络的形式，即可实现。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181226143456981-751171311.png&quot;&gt;&lt;img title=&quot;60_thumb1&quot; src=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181226143457482-1285671129.png&quot; alt=&quot;60_thumb1&quot; width=&quot;745&quot; height=&quot;713&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; root@docker01:~# apt-get install bridge-utils      #两台docker宿主机都建议安装此工具
&lt;span&gt;  2&lt;/span&gt; root@docker02:~# apt-get install bridge-utils   #两台docker宿主机都建议安装此工具
&lt;span&gt;  3&lt;/span&gt; root@docker01:~# docker run -dit --name container01 --net=none centos:7 /bin/bash
&lt;span&gt;  4&lt;/span&gt; root@docker01:~# docker run -dit --name container02 --net=none centos:7 /bin/bash
&lt;span&gt;  5&lt;/span&gt; root@docker02:~# docker run -dit --name container03 --net=none centos:7 /bin/bash
&lt;span&gt;  6&lt;/span&gt; root@docker02:~# docker run -dit --name container04 --net=none centos:7 /bin/bash
&lt;span&gt;  7&lt;/span&gt; 
&lt;span&gt;  8&lt;/span&gt; root@docker01:~# git clone https://github.com/jpetazzo/pipework
&lt;span&gt;  9&lt;/span&gt; root@docker02:~# git clone https://github.com/jpetazzo/pipework
&lt;span&gt; 10&lt;/span&gt; root@docker01:~# cp pipework/pipework /usr/local/bin/
&lt;span&gt; 11&lt;/span&gt; root@docker02:~# cp pipework/pipework /usr/local/bin/
&lt;span&gt; 12&lt;/span&gt; root@docker01:~# chmod u+x /usr/local/bin/pipework
&lt;span&gt; 13&lt;/span&gt; root@docker01:~# brctl show                     #查看当前默认的桥接网卡
&lt;/pre&gt;&lt;/div&gt;

&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181226143457702-1511139413.png&quot;&gt;&lt;img title=&quot;61_thumb1&quot; src=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181226143458153-2124424090.png&quot; alt=&quot;61_thumb1&quot; width=&quot;537&quot; height=&quot;52&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; root@docker01:~# pipework br0 container01 172.24.8.201/24@172.24.8.2
&lt;span&gt;  2&lt;/span&gt; root@docker01:~# pipework br0 container02 172.24.8.202/24@172.24.8.2
&lt;span&gt;  3&lt;/span&gt; root@docker02:~# pipework br0 container03 172.24.8.203/24@172.24.8.2
&lt;span&gt;  4&lt;/span&gt; root@docker02:~# pipework br0 container04 172.24.8.204/24@172.24.8.2
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;若提示Warning: arping not found，可采用以下方式安装：apt-get -y install arping&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; root@docker01:~# brctl show
&lt;/pre&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181226143458387-513180410.png&quot;&gt;&lt;img title=&quot;62_thumb1&quot; src=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181226143458769-862393668.png&quot; alt=&quot;62_thumb1&quot; width=&quot;544&quot; height=&quot;80&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; root@docker02:~# brctl show
&lt;/pre&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181226143458972-393270516.png&quot;&gt;&lt;img title=&quot;63_thumb1&quot; src=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181226143459378-1805987880.png&quot; alt=&quot;63_thumb1&quot; width=&quot;543&quot; height=&quot;85&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;pipework通过network namespace，veth pair以及linux bridge完成容器网络的设置，执行过程大概如下：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;查看主机是否包含br0（可以自定义）网桥，如果不存在就创建；&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;向容器实例添加一块网卡（可以设置网卡名），并配置相应的固定IP；&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;若容器实例已经有默认的路由，则删除掉，将@后面的IP设置为默认路由的网关；&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;将容器实例连接到创建的br0网桥上。&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意：pipework通过link名字来判断是bridge还是ovs switch，br开头为网桥, ovs开头为openvswitch，所以pipework创建的网卡必须以br开头。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;也可通过以下命令手动提前创建网桥：&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; root@docker01:~# docker network create --driver bridge --subnet 172.24.8.0/24 --gateway 172.24.8.2 br1
&lt;span&gt;  2&lt;/span&gt; root@docker:~# docker network inspect br1
&lt;/pre&gt;&lt;/div&gt;

&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181226143459607-874332713.png&quot;&gt;&lt;img title=&quot;64_thumb1&quot; src=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181226143500239-1565507992.png&quot; alt=&quot;64_thumb1&quot; width=&quot;653&quot; height=&quot;502&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; root@docker01:~# ip addr add 172.24.8.90/24 dev br0;\
&lt;span&gt;  2&lt;/span&gt; ip addr del 172.24.8.90/24 dev eth0;\
&lt;span&gt;  3&lt;/span&gt; brctl addif br0 eth0;\
&lt;span&gt;  4&lt;/span&gt; ip route del default;\
&lt;span&gt;  5&lt;/span&gt; ip route add default via 172.24.8.2 dev br0
&lt;span&gt;  6&lt;/span&gt; root@docker02:~# ip addr add 172.24.8.91/24 dev br0 ;\
&lt;span&gt;  7&lt;/span&gt; ip addr del 172.24.8.91/24 dev eth0;\
&lt;span&gt;  8&lt;/span&gt; brctl addif br0 eth0;\
&lt;span&gt;  9&lt;/span&gt; ip route del default;\
&lt;span&gt; 10&lt;/span&gt; ip route add default via 172.24.8.2 dev br0
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;提示：将两台宿主机eth0桥接到br0上，并把eth0的IP配置在br0上。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181226143500615-1164923329.png&quot;&gt;&lt;img title=&quot;65_thumb1&quot; src=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181226143500892-1696201141.png&quot; alt=&quot;65_thumb1&quot; width=&quot;543&quot; height=&quot;97&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181226143501083-1445171144.png&quot;&gt;&lt;img title=&quot;66_thumb1&quot; src=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181226143501632-1029610018.png&quot; alt=&quot;66_thumb1&quot; width=&quot;545&quot; height=&quot;99&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; root@docker01:~# ping 172.24.8.201
&lt;/pre&gt;&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181226143501829-1735657668.png&quot;&gt;&lt;img title=&quot;67_thumb1&quot; src=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181226143502308-248714991.png&quot; alt=&quot;67_thumb1&quot; width=&quot;478&quot; height=&quot;84&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;注意：pipework设置固定IP的情况下，容器重启后IP会自动消失，需要重新设置。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;4.3 基于etcd Docker原生overlay网络&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;见《007.docker etcd分布式网络部署》&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;4.4 基于Flannel的overlay网络&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;Overlay网络指一种网络架构上叠加的虚拟化技术模式，其大体框架是对基础网络不进行大规模修改的情况下，实现应用在网络上的承载，并能与其他网络业务分离，并且以基于IP的网络技术为主。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;案例见《008.docker flannel+etcd分布式网络部署》&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 26 Dec 2018 06:35:00 +0000</pubDate>
<dc:creator>木二</dc:creator>
<og:description>一 docker网络模式 Docker使用Linux的Namespaces技术来进行资源隔离，如PID Namespace隔离进程，Mount Namespace隔离文件系统，Network Name</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/itzgr/p/10179003.html</dc:identifier>
</item>
<item>
<title>看动画轻松理解「递归」与「动态规划」 - 五分钟学算法</title>
<link>http://www.cnblogs.com/fivestudy/p/10178970.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fivestudy/p/10178970.html</guid>
<description>&lt;p&gt;在学习「数据结构和算法」的过程中，因为人习惯了平铺直叙的思维方式，所以「递归」与「动态规划」这种带循环概念（绕来绕去）的往往是相对比较难以理解的两个抽象知识点。&lt;/p&gt;
&lt;p&gt;程序员小吴打算使用动画的形式来帮助理解「递归」，然后通过「递归」的概念延伸至理解「动态规划」算法思想。&lt;/p&gt;
&lt;h3 id=&quot;h&quot;&gt;什么是递归&lt;/h3&gt;
&lt;p&gt;先下定义：&lt;strong&gt;递归算法是一种直接或者间接调用自身函数或者方法的算法。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通俗来说，递归算法的实质是把问题分解成规模缩小的同类问题的子问题，然后递归调用方法来表示问题的解。它有如下特点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1. 一个问题的解可以分解为几个子问题的解&lt;/li&gt;
&lt;li&gt;2. 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样&lt;/li&gt;
&lt;li&gt;3. 存在递归终止条件，即必须有一个明确的递归结束条件，称之为递归出口&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img title=&quot;递归动画&quot; src=&quot;https://user-gold-cdn.xitu.io/2018/12/26/167e8d9d047ce29b?w=953&amp;amp;h=537&amp;amp;f=gif&amp;amp;s=156148&quot; alt=&quot;递归动画&quot;/&gt;递归动画&lt;/p&gt;
&lt;p&gt;通过动画一个一个特点来进行分析。&lt;/p&gt;
&lt;h4 id=&quot;h1&quot;&gt;1.一个问题的解可以分解为几个子问题的解&lt;/h4&gt;
&lt;p&gt;子问题就是相对与其前面的问题数据规模更小的问题。&lt;/p&gt;
&lt;p&gt;在动图中①号问题（一块大区域）划分为②号问题，②号问题由两个子问题（两块中区域）组成。&lt;/p&gt;
&lt;h4 id=&quot;h2&quot;&gt;2. 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样&lt;/h4&gt;
&lt;p&gt;「①号划分为②号」与「②号划分为③号」的逻辑是一致的，求解思路是一样的。&lt;/p&gt;
&lt;h4 id=&quot;h3&quot;&gt;3. 存在递归终止条件，即存在递归出口&lt;/h4&gt;
&lt;p&gt;把问题分解为子问题，把子问题再分解为子子问题，一层一层分解下去，不能存在无限循环，这就需要有终止条件。&lt;/p&gt;
&lt;p&gt;①号划分为②号，②号划分为③号，③号划分为④号，划分到④号的时候每个区域只有一个不能划分的问题，这就表明存在递归终止条件。&lt;/p&gt;
&lt;h3 id=&quot;h-1&quot;&gt;从递归的经典示例开始&lt;/h3&gt;
&lt;h4 id=&quot;h-2&quot;&gt;一.数组求和&lt;/h4&gt;
&lt;p&gt;&lt;img title=&quot;数组求和&quot; src=&quot;https://user-gold-cdn.xitu.io/2018/12/26/167e8d9d04680364?w=953&amp;amp;h=537&amp;amp;f=gif&amp;amp;s=170958&quot; alt=&quot;数组求和&quot;/&gt;数组求和&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;1Sum(arr[0...n-1]) = arr[0] + Sum(arr[1...n-1])&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;后面的 Sum 函数要解决的就是比前一个 Sum 更小的同一问题。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;1Sum(arr[1...n-1]) = arr[1] + Sum(arr[2...n-1])&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以此类推，直到对一个空数组求和，空数组和为 0 ，此时变成了最基本的问题。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;1Sum(arr[n-1...n-1] ) = arr[n-1] + Sum([])&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;h-3&quot;&gt;二.汉诺塔问题&lt;/h4&gt;
&lt;p&gt;汉诺塔（Hanoi Tower）问题也是一个经典的递归问题，该问题描述如下：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;汉诺塔问题：古代有一个梵塔，塔内有三个座A、B、C，A座上有64个盘子，盘子大小不等，大的在下，小的在上。有一个和尚想把这个盘子从A座移到B座，但每次只能允许移动一个盘子，并且在移动过程中，3个座上的盘子始终保持大盘在下，小盘在上。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img title=&quot;两个盘子&quot; src=&quot;https://user-gold-cdn.xitu.io/2018/12/26/167e8d9d06ac04b2?w=953&amp;amp;h=537&amp;amp;f=gif&amp;amp;s=129013&quot; alt=&quot;两个盘子&quot;/&gt;两个盘子 &lt;img title=&quot;三个盘子&quot; src=&quot;https://user-gold-cdn.xitu.io/2018/12/26/167e8d9d053ae4f6?w=953&amp;amp;h=537&amp;amp;f=gif&amp;amp;s=191396&quot; alt=&quot;三个盘子&quot;/&gt;三个盘子&lt;/p&gt;
&lt;ul readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;① 如果只有 1 个盘子，则不需要利用 B 塔，直接将盘子从 A 移动到 C 。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;② 如果有 2 个盘子，可以先将盘子 2 上的盘子 1 移动到 B ；将盘子 2 移动到 C ；将盘子 1 移动到 C 。这说明了：可以借助 B 将 2 个盘子从 A 移动到 C ，当然，也可以借助 C 将 2 个盘子从 A 移动到 B 。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;③ 如果有 3 个盘子，那么根据 2 个盘子的结论，可以借助 C 将盘子 3 上的两个盘子从 A 移动到 B ；将盘子 3 从 A 移动到 C ，A 变成空座；借助 A 座，将 B 上的两个盘子移动到 C 。&lt;br/&gt;　　&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;④ 以此类推，上述的思路可以一直扩展到 n 个盘子的情况，将将较小的 n-1个盘子看做一个整体，也就是我们要求的子问题，以借助 B 塔为例，可以借助空塔 B 将盘子A上面的 n-1 个盘子从 A 移动到 B ；将A 最大的盘子移动到 C ， A 变成空塔；借助空塔 A ，将 B 塔上的 n-2 个盘子移动到 A，将 C 最大的盘子移动到 C， B 变成空塔。。。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;h-4&quot;&gt;三.爬台阶问题&lt;/h4&gt;
&lt;p&gt;问题描述：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;一个人爬楼梯，每次只能爬1个或2个台阶，假设有n个台阶，那么这个人有多少种不同的爬楼梯方法？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;先从简单的开始，以 4 个台阶为例，可以通过每次爬 1 个台阶爬完楼梯：&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;每次爬 1 个台阶&quot; src=&quot;https://user-gold-cdn.xitu.io/2018/12/26/167e8d9d06bc802f?w=953&amp;amp;h=537&amp;amp;f=gif&amp;amp;s=160386&quot; alt=&quot;每次爬 1 个台阶&quot;/&gt;每次爬 1 个台阶&lt;/p&gt;
&lt;p&gt;可以通过先爬 2 个台阶，剩下的每次爬 1 个台阶爬完楼梯&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;先爬 2 个台阶&quot; src=&quot;https://user-gold-cdn.xitu.io/2018/12/26/167e8d9d06c90ce5?w=953&amp;amp;h=537&amp;amp;f=gif&amp;amp;s=123221&quot; alt=&quot;先爬 2 个台阶&quot;/&gt;先爬 2 个台阶&lt;/p&gt;
&lt;p&gt;在这里，可以思考一下：可以根据第一步的走法把所有走法分为两类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;① 第一类是第一步走了 1 个台阶&lt;/li&gt;
&lt;li&gt;② 第二类是第一步走了 2 个台阶&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以 n 个台阶的走法就等于先走 1 阶后，n-1 个台阶的走法 ，然后加上先走 2 阶后，n-2 个台阶的走法。&lt;/p&gt;
&lt;p&gt;用公式表示就是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;f(n) = f(n-1)+f(n-2)&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有了递推公式，递归代码基本上就完成了一半。那么接下来考虑递归终止条件。&lt;/p&gt;
&lt;p&gt;当有一个台阶时，我们不需要再继续递归，就只有一种走法。&lt;/p&gt;
&lt;p&gt;所以 &lt;code&gt;f(1)=1&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;通过用 &lt;code&gt;n = 2&lt;/code&gt;，&lt;code&gt;n = 3&lt;/code&gt; 这样比较小的数试验一下后发现这个递归终止条件还不足够。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;n = 2&lt;/code&gt; 时，&lt;code&gt;f(2) = f(1) + f(0)&lt;/code&gt;。如果递归终止条件只有一个&lt;code&gt;f(1) = 1&lt;/code&gt;，那 &lt;code&gt;f(2)&lt;/code&gt; 就无法求解，递归无法结束。&lt;br/&gt;所以除了 &lt;code&gt;f(1) = 1&lt;/code&gt; 这一个递归终止条件外，还要有 &lt;code&gt;f(0) = 1&lt;/code&gt;，表示走 0 个台阶有一种走法，从思维上以及动图上来看，这显得的有点不符合逻辑。所以为了便于理解，把 &lt;code&gt;f(2) = 2&lt;/code&gt; 作为一种终止条件，表示走 2 个台阶，有两种走法，一步走完或者分两步来走。&lt;/p&gt;
&lt;p&gt;总结如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;① 假设只有一个台阶，那么只有一种走法，那就是爬 1 个台阶&lt;/li&gt;
&lt;li&gt;② 假设有两个个台阶，那么有两种走法，一步走完或者分两步来走&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img title=&quot;递归终止条件&quot; src=&quot;https://user-gold-cdn.xitu.io/2018/12/26/167e8d9d3cd8be6b?w=953&amp;amp;h=537&amp;amp;f=gif&amp;amp;s=303733&quot; alt=&quot;递归终止条件&quot;/&gt;递归终止条件&lt;/p&gt;
&lt;p&gt;通过递归条件：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;1f(1) = 1;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;2f(2) = 2;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;3f(n) = f(n-1)+f(n-2)&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;很容易推导出递归代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cpp&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;1&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int &lt;span class=&quot;hljs-title&quot;&gt;f&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int n) {&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;2  &lt;span class=&quot;hljs-keyword&quot;&gt;if (n == &lt;span class=&quot;hljs-number&quot;&gt;1) &lt;span class=&quot;hljs-keyword&quot;&gt;return &lt;span class=&quot;hljs-number&quot;&gt;1;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;3  &lt;span class=&quot;hljs-keyword&quot;&gt;if (n == &lt;span class=&quot;hljs-number&quot;&gt;2) &lt;span class=&quot;hljs-keyword&quot;&gt;return &lt;span class=&quot;hljs-number&quot;&gt;2;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;4  &lt;span class=&quot;hljs-keyword&quot;&gt;return f(n&lt;span class=&quot;hljs-number&quot;&gt;-1) + f(n&lt;span class=&quot;hljs-number&quot;&gt;-2);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;5}&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过上述三个示例，总结一下如何写递归代码：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1.找到如何将大问题分解为小问题的规律&lt;/li&gt;
&lt;li&gt;2.通过规律写出递推公式&lt;/li&gt;
&lt;li&gt;3.通过递归公式的临界点推敲出终止条件&lt;/li&gt;
&lt;li&gt;4.将递推公式和终止条件翻译成代码&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;h-5&quot;&gt;什么是动态规划&lt;/h3&gt;
&lt;p&gt;介绍动态规划之前先介绍一下分治策略（Divide and Conquer）。&lt;/p&gt;
&lt;h4 id=&quot;h-6&quot;&gt;分治策略&lt;/h4&gt;
&lt;p&gt;将原问题分解为若干个规模较小但类似于原问题的子问题（&lt;strong&gt;Divide&lt;/strong&gt;），「递归」的求解这些子问题（&lt;strong&gt;Conquer&lt;/strong&gt;），然后再合并这些子问题的解来建立原问题的解。&lt;/p&gt;
&lt;p&gt;因为在求解大问题时，需要递归的求小问题，因此一般用「递归」的方法实现，即自顶向下。&lt;/p&gt;
&lt;h4 id=&quot;hdynamicprogramming&quot;&gt;动态规划（Dynamic Programming）&lt;/h4&gt;
&lt;p&gt;动态规划其实和分治策略是类似的，也是将一个原问题分解为若干个规模较小的子问题，递归的求解这些子问题，然后合并子问题的解得到原问题的解。&lt;br/&gt;区别在于这些子问题会有重叠，一个子问题在求解后，可能会再次求解，于是我们想到将这些子问题的&lt;strong&gt;解存储起来&lt;/strong&gt;，当下次再次求解这个子问题时，直接拿过来就是。&lt;br/&gt;其实就是说，动态规划所解决的问题是分治策略所解决问题的一个子集，只是这个子集更适合用动态规划来解决从而得到更小的运行时间。&lt;br/&gt;&lt;strong&gt;即用动态规划能解决的问题分治策略肯定能解决，只是运行时间长了&lt;/strong&gt;。因此，分治策略一般用来解决子问题相互对立的问题，称为标准分治，而动态规划用来解决子问题重叠的问题。&lt;/p&gt;
&lt;p&gt;与「分治策略」「动态规划」概念接近的还有「贪心算法」「回溯算法」，由于篇幅限制，程序员小吴就不在这进行展开，在后续的文章中将分别详细的介绍「贪心算法」、「回溯算法」、「分治算法」，敬请关注：）&lt;/p&gt;
&lt;p&gt;将「动态规划」的概念关键点抽离出来描述就是这样的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1.动态规划法试图只解决每个子问题一次&lt;/li&gt;
&lt;li&gt;2.一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;h-7&quot;&gt;从递归到动态规划&lt;/h3&gt;
&lt;p&gt;还是以 &lt;strong&gt;爬台阶&lt;/strong&gt; 为例，如果以递归的方式解决的话，那么这种方法的时间复杂度为O(2^n)，具体的计算可以查看笔者之前的文章 《冰与火之歌：时间复杂度与空间复杂度》。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;相同颜色代表着 爬台阶问题 在递归计算过程中重复计算的部分。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img title=&quot;爬台阶的时间复杂度&quot; src=&quot;https://user-gold-cdn.xitu.io/2018/12/26/167e8d9d3cf51362?w=1518&amp;amp;h=858&amp;amp;f=png&amp;amp;s=86406&quot; alt=&quot;爬台阶的时间复杂度&quot;/&gt;爬台阶的时间复杂度&lt;/p&gt;
&lt;p&gt;通过图片可以发现一个现象，我们是 自顶向下 的进行递归运算，比如：&lt;code&gt;f(n)&lt;/code&gt; 是&lt;code&gt;f(n-1)&lt;/code&gt;与&lt;code&gt;f(n-2)&lt;/code&gt;相加，&lt;code&gt;f(n-1)&lt;/code&gt; 是&lt;code&gt;f(n-2)&lt;/code&gt;与&lt;code&gt;f(n-3)&lt;/code&gt;相加。&lt;/p&gt;
&lt;p&gt;思考一下：如果反过来，采取自底向上，用迭代的方式进行推导会怎么样了？&lt;/p&gt;
&lt;p&gt;下面通过表格来解释 &lt;code&gt;f(n)&lt;/code&gt;自底向上的求解过程。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;台阶数&lt;/th&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;th&gt;2&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th&gt;4&lt;/th&gt;
&lt;th&gt;5&lt;/th&gt;
&lt;th&gt;6&lt;/th&gt;
&lt;th&gt;7&lt;/th&gt;
&lt;th&gt;8&lt;/th&gt;
&lt;th&gt;9&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;走法数&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;表格的第一行代表了楼梯台阶的数目，第二行代表了若干台阶对应的走法数。&lt;br/&gt;其中&lt;code&gt;f(1) = 1&lt;/code&gt; 和 &lt;code&gt;f(2) = 2&lt;/code&gt;是前面明确的结果。&lt;/p&gt;
&lt;p&gt;第一次迭代，如果台阶数为 3 ，那么走法数为 3 ，通过 &lt;code&gt;f(3) = f(2) + f(1)&lt;/code&gt;得来。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;台阶数&lt;/th&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;th&gt;2&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th&gt;4&lt;/th&gt;
&lt;th&gt;5&lt;/th&gt;
&lt;th&gt;6&lt;/th&gt;
&lt;th&gt;7&lt;/th&gt;
&lt;th&gt;8&lt;/th&gt;
&lt;th&gt;9&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;走法数&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;第二次迭代，如果台阶数为 4 ，那么走法数为 5 ，通过 &lt;code&gt;f(4) = f(3) + f(2)&lt;/code&gt;得来。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;台阶数&lt;/th&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;th&gt;2&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th&gt;4&lt;/th&gt;
&lt;th&gt;5&lt;/th&gt;
&lt;th&gt;6&lt;/th&gt;
&lt;th&gt;7&lt;/th&gt;
&lt;th&gt;8&lt;/th&gt;
&lt;th&gt;9&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;走法数&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://user-gold-cdn.xitu.io/2018/12/26/167e8d9d3ded7651?w=953&amp;amp;h=537&amp;amp;f=gif&amp;amp;s=71448&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由此可见，每一次迭代过程中，只需要保留之前的两个状态，就可以推到出新的状态。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;show me the code&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cpp&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 1&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int &lt;span class=&quot;hljs-title&quot;&gt;f&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int n) {&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 2    &lt;span class=&quot;hljs-keyword&quot;&gt;if (n == &lt;span class=&quot;hljs-number&quot;&gt;1) &lt;span class=&quot;hljs-keyword&quot;&gt;return &lt;span class=&quot;hljs-number&quot;&gt;1;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 3    &lt;span class=&quot;hljs-keyword&quot;&gt;if (n == &lt;span class=&quot;hljs-number&quot;&gt;2) &lt;span class=&quot;hljs-keyword&quot;&gt;return &lt;span class=&quot;hljs-number&quot;&gt;2;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 4    &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;程序从 &lt;code&gt;i = 3&lt;/code&gt; 开始迭代，一直到 &lt;code&gt;i = n&lt;/code&gt; 结束。每一次迭代，都会计算出多一级台阶的走法数量。迭代过程中只需保留两个临时变量 a 和 b ，分别代表了上一次和上上次迭代的结果。为了便于理解，引入了temp变量。temp代表了当前迭代的结果值。&lt;/p&gt;
&lt;p&gt;看一看出，事实上并没有增加太多的代码，只是简单的进行了优化，时间复杂度便就降为O(n)，而空间复杂度也变为O(1)，这，就是「动态规划」的强大！&lt;/p&gt;
&lt;h3 id=&quot;h-8&quot;&gt;详解动态规划&lt;/h3&gt;
&lt;p&gt;「动态规划」中包含三个重要的概念：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;【最优子结构】&lt;/li&gt;
&lt;li&gt;【边界】&lt;/li&gt;
&lt;li&gt;【状态转移公式】&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在「 爬台阶问题 」中&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;code&gt;f(10) = f(9) + f(8)&lt;/code&gt; 是【最优子结构】&lt;br/&gt;&lt;code&gt;f(1) 与 f(2)&lt;/code&gt; 是【边界】&lt;br/&gt;&lt;code&gt;f(n) = f(n-1) + f(n-2)&lt;/code&gt; 【状态转移公式】&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;「 爬台阶问题 」 只是动态规划中相对简单的问题，因为它只有一个变化维度，如果涉及多个维度的话，那么问题就变得复杂多了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;难点就在于找出 「动态规划」中的这三个概念。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比如「 国王和金矿问题 」。&lt;/p&gt;
&lt;h4 id=&quot;h-9&quot;&gt;国王和金矿问题&lt;/h4&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;有一个国家发现了 5 座金矿，每座金矿的黄金储量不同，需要参与挖掘的工人数也不同。参与挖矿工人的总数是 10 人。每座金矿要么全挖，要么不挖，不能派出一半人挖取一半金矿。要求用程序求解出，要想得到尽可能多的黄金，应该选择挖取哪几座金矿？&lt;/p&gt;
&lt;img title=&quot; 5 座金矿&quot; src=&quot;https://user-gold-cdn.xitu.io/2018/12/26/167e8d9d3e0c8a2a?w=1448&amp;amp;h=284&amp;amp;f=png&amp;amp;s=27005&quot; alt=&quot; 5 座金矿&quot;/&gt; 5 座金矿&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;找出 「动态规划」中的这三个概念&lt;/strong&gt;&lt;/p&gt;
&lt;h5 id=&quot;h-10&quot;&gt;国王和金矿问题中的【最优子结构】&lt;/h5&gt;
&lt;p&gt;&lt;img title=&quot;国王和金矿问题中的【最优子结构】&quot; src=&quot;https://user-gold-cdn.xitu.io/2018/12/26/167e8d9d3e263ca2?w=1918&amp;amp;h=1080&amp;amp;f=png&amp;amp;s=126900&quot; alt=&quot;国王和金矿问题中的【最优子结构】&quot;/&gt;国王和金矿问题中的【最优子结构】&lt;/p&gt;
&lt;p&gt;国王和金矿问题中的【最优子结构】有两个：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;① 4 金矿 10 工人的最优选择&lt;/li&gt;
&lt;li&gt;② 4 金矿 （10 - 5） 工人的最优选择&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;4 金矿的最优选择与 5 金矿的最优选择之间的关系是&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MAX[（4 金矿 10 工人的挖金数量），（4 金矿 5 工人的挖金数量 + 第 5 座金矿的挖金数量）]&lt;/code&gt;&lt;/p&gt;
&lt;h5 id=&quot;h-11&quot;&gt;国王和金矿问题中的【边界】&lt;/h5&gt;
&lt;p&gt;国王和金矿问题中的【边界】 有两个：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;① 当只有 1 座金矿时，只能挖这座唯一的金矿，得到的黄金数量为该金矿的数量&lt;/li&gt;
&lt;li&gt;② 当给定的工人数量不够挖 1 座金矿时，获取的黄金数量为 0&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;h-12&quot;&gt;国王和金矿问题中的【状态转移公式】&lt;/h5&gt;
&lt;p&gt;我们把金矿数量设为 N，工人数设为 W，金矿的黄金量设为数组G[]，金矿的用工量设为数组P[]，得到【状态转移公式】：&lt;br/&gt;​&lt;/p&gt;
&lt;ul readability=&quot;7&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;边界值：F(n,w) = 0 (n &amp;lt;= 1, w &amp;lt; p[0])&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;code&gt;F(n,w) = g[0] (n==1, w &amp;gt;= p[0])&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;F(n,w) = F(n-1,w) (n &amp;gt; 1, w &amp;lt; p[n-1])&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;&lt;code&gt;F(n,w) = max(F(n-1,w), F(n-1,w-p[n-1]) + g[n-1]) (n &amp;amp;gt; 1, w &amp;amp;gt;= p[n-1])&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;h-13&quot;&gt;国王和金矿问题中的【实现】&lt;/h3&gt;
&lt;p&gt;先通过几幅动画来理解 「工人」 与 「金矿」 搭配的方式&lt;/p&gt;
&lt;h6 id=&quot;h1-1&quot;&gt;1.只挖第一座金矿&lt;/h6&gt;
&lt;p&gt;&lt;img title=&quot;只挖第一座金矿&quot; src=&quot;https://user-gold-cdn.xitu.io/2018/12/26/167e8d9d670b0774?w=957&amp;amp;h=538&amp;amp;f=gif&amp;amp;s=318658&quot; alt=&quot;只挖第一座金矿&quot;/&gt;只挖第一座金矿&lt;/p&gt;
&lt;p&gt;在只挖第一座金矿前面两个工人挖矿收益为 零，当有三个工人时，才开始产生收益为 200，而后即使增加再多的工人收益不变，因为只有一座金矿可挖。&lt;/p&gt;
&lt;h6 id=&quot;h2-1&quot;&gt;2.挖第一座与第二座金矿&lt;/h6&gt;
&lt;p&gt;&lt;img title=&quot;挖第一座与第二座金矿&quot; src=&quot;https://user-gold-cdn.xitu.io/2018/12/26/167e8d9d404376c8?w=957&amp;amp;h=538&amp;amp;f=gif&amp;amp;s=586737&quot; alt=&quot;挖第一座与第二座金矿&quot;/&gt;挖第一座与第二座金矿&lt;/p&gt;
&lt;p&gt;在第一座与第二座金矿这种情况中，前面两个工人挖矿收益为 零，因为 W &amp;lt; 3,所以F(N,W) = F(N-1,W) = 0。&lt;/p&gt;
&lt;p&gt;当有 三 个工人时，将其安排挖第 一 个金矿，开始产生收益为 200。&lt;/p&gt;
&lt;p&gt;当有 四 个工人时，挖矿位置变化，将其安排挖第 二 个金矿，开始产生收益为 300。&lt;/p&gt;
&lt;p&gt;当有 五、六 个工人时，由于多于 四 个工人的人数不足以去开挖第 一 座矿，因此收益还是为 300。&lt;/p&gt;
&lt;p&gt;当有 七 个工人时，可以同时开采第 一 个和第 二 个金矿，开始产生收益为 500。&lt;/p&gt;
&lt;h6 id=&quot;h3-1&quot;&gt;3.挖前三座金矿&lt;/h6&gt;
&lt;p&gt;&lt;strong&gt;这是「国王和金矿」 问题中最重要的一个动画之一，可以多看几遍&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;挖前三座金矿&quot; src=&quot;https://user-gold-cdn.xitu.io/2018/12/26/167e8d9d685f6826?w=957&amp;amp;h=536&amp;amp;f=gif&amp;amp;s=543368&quot; alt=&quot;挖前三座金矿&quot;/&gt;挖前三座金矿&lt;/p&gt;
&lt;h6 id=&quot;h4&quot;&gt;4.挖前四座金矿&lt;/h6&gt;
&lt;p&gt;&lt;strong&gt;这是「国王和金矿」 问题中最重要的一个动画之一，可以多看几遍&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;挖前四座金矿&quot; src=&quot;https://user-gold-cdn.xitu.io/2018/12/26/167e8d9d6ef42679?w=957&amp;amp;h=536&amp;amp;f=gif&amp;amp;s=329570&quot; alt=&quot;挖前四座金矿&quot;/&gt;挖前四座金矿&lt;/p&gt;
&lt;h3 id=&quot;h-14&quot;&gt;国王和金矿问题中的【规律】&lt;/h3&gt;
&lt;p&gt;仔细观察上面的几组动画可以发现：&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;对比「挖第一座与第二座金矿」和「挖前三座金矿」，在「挖前三座金矿」中，3 金矿 7 工人的挖矿收益，来自于 2 金矿 7 工人和 2 金矿 4 工人的结果，Max(500,300 + 350) = 650；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;对比「挖前三座金矿」和「挖前四座金矿」，在「挖前四座金矿」中，4 金矿 10 工人的挖矿收益，来自于 3 金矿 10 工人和 3 金矿 5 工人的结果，Max(850,400 + 300) = 850；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;h-15&quot;&gt;国王和金矿问题中的【动态规划代码】&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs markdown&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 1代码来源：https://www.cnblogs.com/SDJL/archive/2008/08/22/1274312.html&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 2&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 3//maxGold[&lt;span class=&quot;hljs-string&quot;&gt;i][&lt;span class=&quot;hljs-symbol&quot;&gt;j] 保存了i个人挖前j个金矿能够得到的最大金子数，等于 -1 时表示未知&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 4int maxGold[&lt;span class=&quot;hljs-string&quot;&gt;max_people][&lt;span class=&quot;hljs-symbol&quot;&gt;max_n];&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 5&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 6int GetMaxGold(int people, int mineNum){&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 7    int retMaxGold;                            //声明返回的最大金矿数量&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 8    //如果这个问题曾经计算过&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 9    if(maxGold[&lt;span class=&quot;hljs-string&quot;&gt;people][&lt;span class=&quot;hljs-symbol&quot;&gt;mineNum] != -1){&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;10        retMaxGold = maxGold[&lt;span class=&quot;hljs-string&quot;&gt;people][&lt;span class=&quot;hljs-symbol&quot;&gt;mineNum]; //获得保存起来的值&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;11    }else if(mineNum == 0) {                   //如果仅有一个金矿时 [ 对应动态规划中的&quot;边界&quot;]&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;12        if(people &amp;gt;= peopleNeed[mineNum])      //当给出的人数足够开采这座金矿&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;13            retMaxGold = gold[mineNum];        //得到的最大值就是这座金矿的金子数&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;14        else                                   //否则这唯一的一座金矿也不能开采&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;15            retMaxGold = 0;                    //得到的最大值为 0 个金子&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;16    }else if(people &amp;gt;= peopleNeed[mineNum])    // 如果人够开采这座金矿[对应动态规划中的&quot;最优子结构&quot;]&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;17    {&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;18        //考虑开采与不开采两种情况，取最大值&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;19        retMaxGold = max(&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;20                         GetMaxGold(people - peopleNeed[mineNum],mineNum - 1) + gold[mineNum],&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;21                         GetMaxGold(people,mineNum - 1)&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;22                         );&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;23    }else//否则给出的人不够开采这座金矿 [ 对应动态规划中的&quot;最优子结构&quot;]&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;24    {&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;25        retMaxGold = GetMaxGold(people,mineNum - 1);     //仅考虑不开采的情况&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;26        maxGold[&lt;span class=&quot;hljs-string&quot;&gt;people][&lt;span class=&quot;hljs-symbol&quot;&gt;mineNum] = retMaxGold;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;27    }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;28    return retMaxGold;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;29}&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img title=&quot;动态规划代码&quot; src=&quot;https://user-gold-cdn.xitu.io/2018/12/26/167e8d9d6fea1634?w=2048&amp;amp;h=1708&amp;amp;f=png&amp;amp;s=555294&quot; alt=&quot;动态规划代码&quot;/&gt;动态规划代码&lt;/p&gt;
&lt;p&gt;希望通过这篇文章，大家能对「递归」与「动态规划」有一定的理解。后续将以「动态规划」为基础研究多重背包算法、迪杰特斯拉算法等更高深的算法问题，同时「递归」的更多概念也会在「分治算法」章节再次延伸，敬请对程序员小吴保持关注：）&lt;/p&gt;
</description>
<pubDate>Wed, 26 Dec 2018 06:30:00 +0000</pubDate>
<dc:creator>五分钟学算法</dc:creator>
<og:description>在学习「数据结构和算法」的过程中，因为人习惯了平铺直叙的思维方式，所以「递归」与「动态规划」这种带循环概念（绕来绕去）的往往是相对比较难以理解的两个抽象知识点。 程序员小吴打算使用动画的形式来帮助理解</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fivestudy/p/10178970.html</dc:identifier>
</item>
<item>
<title>protobuf 在win10系统如何编译jar包 - 花开如梦</title>
<link>http://www.cnblogs.com/ruber/p/10178925.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ruber/p/10178925.html</guid>
<description>&lt;p&gt;最近在搞java服务器项目，前段要求用protobuf进行数据传输，以前没搞过，查了很多资料，走了一些弯路！&lt;/p&gt;
&lt;p&gt;先把一些需要下载的链接放上来：&lt;/p&gt;
&lt;p&gt;protobuf下载地址：&lt;span&gt;&lt;a title=&quot;protobuf下载链接地址&quot; href=&quot;https://github.com/protocolbuffers/protobuf/releases?after=v3.5.2&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://github.com/protocolbuffers/protobuf/releases?after=v3.5.2&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;maven下载地址：&lt;span&gt;&lt;a title=&quot;maven下载地址&quot; href=&quot;http://maven.apache.org/download.cgi&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;http://maven.apache.org/download.cgi&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;关于protobuf下载那些内容，看图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908256/201812/908256-20181226120501640-1620161059.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;使用protobuf的流程无非就是三部分。数据定义、数据生成、数据解析&lt;/p&gt;
&lt;p&gt;数据定义其实就是自己编写一个.proto文件 例如这个 protoDemo.proto文件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908256/201812/908256-20181226115126833-2012443387.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这只是一个简单的结构，里面定义了 id、name等的一些属性，required 、optional这一部分是关键字部分，结构并不复杂，大家自行百度自学！这个地址不错 &lt;span&gt;&lt;a title=&quot;proto文件说明&quot; href=&quot;https://blog.csdn.net/skh2015java/article/details/78404235&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://blog.csdn.net/skh2015java/article/details/78404235&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这个文件通过我们下载的proto.exe这个工具生成我们对应的java文件，供项目使用！直接打开cmd窗口，怎么使用从网上查查，有很多&lt;/p&gt;
&lt;p&gt;最终我是将&lt;span&gt;protoDemo.proto&lt;/span&gt;  通过&lt;span&gt;protoc.exe&lt;/span&gt; 生成了想要的 &lt;span&gt;ProtoDemo.java&lt;/span&gt;文件&lt;/p&gt;
&lt;p&gt;到这里是比较容易的，那么怎么在项目里使用protobuf解析这个文件呢！其实是有两种方式&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.编译jar包，在项目里导入jar包&lt;/strong&gt;  &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其实人家有提供说明就在README.md里，只是我们不知道看罢了，结果浪费了很多时间查资料看文档的！&lt;/p&gt;
&lt;p&gt;README.md就在protobuf-3.4.0\java文件夹下里面试这样描述的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908256/201812/908256-20181226133625321-140197319.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里主要说几点遇到的问题：&lt;/p&gt;
&lt;p&gt;1. maven下载解压后，需要在环境变量进行配置&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908256/201812/908256-20181226134012970-1559328902.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;配置成功在cmd里测试一下: 执行命令：mvn -v&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908256/201812/908256-20181226134230887-298648996.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;配置成功会打印一些maven的信息出来&lt;/p&gt;
&lt;p&gt;然后直接cd到protobuf-3.4.0\java文件夹下，按照图里的步骤，进行编译就行！&lt;/p&gt;
&lt;p&gt;maven默认的情况下是从Google的官网下载那些所需的文件，所以我们在国内如果网不行的还是，还是应该走一些国内的镜像，这里就需要对maven进行一下配置&lt;/p&gt;
&lt;p&gt;在&lt;span&gt;xxx\apache-maven-3.6.0-bin\conf&lt;/span&gt;路径下找到&lt;span&gt;settings.xml &lt;span&gt;打开，在 &amp;lt;mirrors&amp;gt;标签下添加&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;    &amp;lt;mirror&amp;gt;&lt;br/&gt;      &amp;lt;id&amp;gt;aliyun&amp;lt;/id&amp;gt;&lt;br/&gt;        &amp;lt;name&amp;gt;aliyun Maven&amp;lt;/name&amp;gt;&lt;br/&gt;        &amp;lt;mirrorOf&amp;gt;*&amp;lt;/mirrorOf&amp;gt;&lt;br/&gt;        &amp;lt;url&amp;gt;&lt;span&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/span&gt;&amp;lt;/url&amp;gt;&lt;br/&gt;    &amp;lt;/mirror&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;如图&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908256/201812/908256-20181226135110401-1451338027.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这个就是用的阿里云的镜像下载的，当然还有其他的镜像，大家自行百度吧！&lt;/p&gt;
&lt;p&gt;开始编译其实就是下载资源的过程，从镜像网站会下载资源到你的本地，你本地路径怎么设置呢！参考链接：&lt;span&gt;&lt;a title=&quot;maven仓库设置&quot; href=&quot;http://www.cnblogs.com/duanxz/p/5210189.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;http://www.cnblogs.com/duanxz/p/5210189.html&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;因为有些文件下载到本地仓库后，会&lt;span&gt;优先从本地仓库查找并使用，这时候你编译出问题了，很可能是你本地残酷的文件下载下来的就有问题，所以，根据提示，在本地仓库找到对应的文件，删除，再重新编译！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;还有就是&lt;span&gt;有些版本的test代码有问题，编译报错，果断删除相应的test里的java代码&lt;/span&gt;，再编译，因为那些只是例子，编译jar包根本不需要！&lt;/p&gt;
&lt;p&gt;就这两句红字我就搞了一天，因为我从没用过maven，我是菜鸡！你们不要走我的弯路&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.使用protobuf源码&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;行对与第一种方式，第二种方式就简单多了，直接引入 &lt;span&gt;xxx\protobuf-3.4.0\java\core\src\main\java&lt;/span&gt;下的源码！其实也不能完全copy过去，在这之前还需要编译一个文件，不然copy过去会报错&lt;/p&gt;
&lt;p&gt;如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908256/201812/908256-20181226140950853-199586662.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;他这个2)里的命令是不是多了\呀，我上传我的大家借鉴下吧&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908256/201812/908256-20181226142913693-664491727.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;生成&lt;span&gt;DescriptorProtos.java&lt;/span&gt;后，就可以直接将源码直接拷贝到工程里直接用了！&lt;/p&gt;
&lt;p&gt;但是工程里还会报错，妈了个鸡，一个&lt;span&gt;unsafe&lt;/span&gt;什么玩意的错误，好吧，鼓捣半天，这是个eclipse设置问题，如图修改一下&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908256/201812/908256-20181226141446171-2086009619.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个默认情况下是error，改成warning，就不提示unsafe相关的错误了！&lt;/p&gt;
&lt;p&gt;至此，天下太平！&lt;/p&gt;
&lt;p&gt;趁着热乎，赶紧整理出来，如果有不周到的地方，烦请留言！还有，csdn上的资源太贵了！你想不折腾下载个现成的，不如好好想想自己搞！&lt;/p&gt;
&lt;p&gt;maven还有很多东西要学习，不懂得看看这个文章 &lt;span&gt;&lt;a title=&quot;maven学习资料&quot; href=&quot;https://blog.csdn.net/java_2017_csdn/article/details/77450598&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://blog.csdn.net/java_2017_csdn/article/details/77450598 &lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我就是看了这篇文章，才知道maven是个什么东西！大家共勉吧！&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图片里写的proto.exe就是protoc.exe，笔误，不要误导大家哈！&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 26 Dec 2018 06:20:00 +0000</pubDate>
<dc:creator>花开如梦</dc:creator>
<og:description>最近在搞java服务器项目，前段要求用protobuf进行数据传输，以前没搞过，查了很多资料，走了一些弯路！ 先把一些需要下载的链接放上来： protobuf下载地址：https://github.c</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ruber/p/10178925.html</dc:identifier>
</item>
<item>
<title>开发.NET Core NuGet包并实现CI/CD - AllanHao</title>
<link>http://www.cnblogs.com/hao-zhang/p/10178641.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hao-zhang/p/10178641.html</guid>
<description>&lt;p&gt;实际开发中我们需要对一些公共类库进行开发，并基于Jenkins进行CI/CD（CI:持续集成，CD:持续部署）,其他项目通过NuGet引用。&lt;a href=&quot;https://allanhao.com/2018/12/19/nugetserver/&quot;&gt;上文&lt;/a&gt;讲述了如何搭建本地NuGet服务器并发布NuGet包，这里不再赘述。&lt;/p&gt;
&lt;p&gt;CI/CD流程如下图：&lt;br/&gt;&lt;img src=&quot;https://allanhao.com/images/2018-12-25-22-34-01.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先公共类库代码通过Git管理，编辑完代码后上传到Git服务器。&lt;/p&gt;
&lt;p&gt;配置Jenkins Job，按设定的触发条件进行构建任务。&lt;/p&gt;
&lt;p&gt;构建开始，删除Workspace中旧文件，从Git服务器下载最新代码，执行编译，生成NuGet包，上传到NuGet服务器。&lt;/p&gt;
&lt;p&gt;这样，别人就可以引用或者更新最新的公共类库的NuGet包进行业务开发了。&lt;/p&gt;
&lt;h2 id=&quot;在visual-studio中操作&quot;&gt;在Visual Studio中操作&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;自定义打包类库&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;新建一个.net core 的类库，在工程文件处右键，选择属性，在“打包”中勾选“在版本中生成NuGet包”，然后设置基本信息。如下图：&lt;br/&gt;&lt;img src=&quot;https://allanhao.com/images/2018-12-26-08-52-59.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;编译生成，就会在Debug/Release目录生成一个nupkg文件：&lt;br/&gt;&lt;img src=&quot;https://allanhao.com/images/2018-12-26-08-57-35.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;自动更新编译版本&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;关于版本号：&lt;br/&gt;这里指Net Framework风格的版本号，&lt;br/&gt;即，&lt;strong&gt;主版本号.子版本号[.编译版本号[.修订版本号]]&lt;/strong&gt;&lt;br/&gt;英文对照：&lt;br/&gt;Major_Version_Number.Minor_Version_Number[.Build_Number[.Revision_Number]]&lt;br/&gt;主版本号和次版本号是必选的；&lt;br/&gt;编译版本号和修订号是可选的，但是如果定义了修订号部分，则编译版本号就是必选的。&lt;br/&gt;所有定义的部分都必须是大于或等于 0 的整数。&lt;br/&gt;应根据下面的约定使用这些部分：&lt;br/&gt;&lt;strong&gt;Major&lt;/strong&gt; ：具有相同名称但不同主版本号的程序集不可互换。例如，这适用于对产品的大量重写，这些重写使得无法实现向后兼容性。&lt;br/&gt;&lt;strong&gt;Minor&lt;/strong&gt; ：如果两个程序集的名称和主版本号相同，而次版本号不同，这指示显著增强，但照顾到了向后兼容性。例如，这适用于产品的修正版或完全向后兼容的新版本。&lt;br/&gt;&lt;strong&gt;Build&lt;/strong&gt; ：编译版本号（内部版本号）的不同表示对相同源所作的重新编译。这适合于更改处理器、平台或编译器的情况。&lt;br/&gt;&lt;strong&gt;Revision&lt;/strong&gt; ：名称、主版本号和次版本号都相同但修订号不同的程序集应是完全可互换的。这适用于修复以前发布的程序集中的安全漏洞。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在Visual Studio中选择NuGet包管理器，搜索“MSBump”,安装，然后在工程文件下新建一个.msbump文件，写入如下代码：&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
  Configurations: {
    &quot;Debug&quot;: {
      BumpLabel: &quot;dev&quot;,
      LabelDigits: 4
    },
    
    &quot;Release&quot;: {
      BumpRevision: true,
      ResetLabel: &quot;dev&quot;
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上文表示：当编译配置为“Debug”时，版本号生成一个dev前缀后面跟四位数字的标签，数字从0001开始递增。当编译配置为“Release”时，修订版本号会+1，清除dev标签。当然，也可以直接在.msbump中这样写：&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
    BumpRevision: true
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;意思就是每次编译不管debug还是release，都会使修订版本号+1&lt;/p&gt;
&lt;h2 id=&quot;在jenkins中操作&quot;&gt;在Jenkins中操作&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;前提操作：&lt;br/&gt;需要下载NuGet.exe，并且把NuGet.exe所在目录和MSBuild所在目录加入到环境变量中，这样方便在Jenkins中直接使用msbuild和nuget命令。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;安装Jenkins&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里不再赘述，自行百度，就是安装Java那套环境&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;新建任务&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;新建任务，起个名字，选择“构建一个自由风格的软件项目”，点击“OK”：&lt;br/&gt;&lt;img src=&quot;https://allanhao.com/images/2018-12-26-09-26-46.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;编辑配置信息&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们用的是Git管理代码，所以源代码管理里选择Git，输入仓库地址和用户名密码，选择需要拉取的分支名称：&lt;br/&gt;&lt;img src=&quot;https://allanhao.com/images/2018-12-26-09-28-36.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;触发条件，可以根据自己的需求，比如每日定时调度：&lt;br/&gt;&lt;img src=&quot;https://allanhao.com/images/2018-12-26-09-29-19.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;编译环境中选择编译开始前清空Workspace，保证拉取最新代码不冲突：&lt;br/&gt;&lt;img src=&quot;https://allanhao.com/images/2018-12-26-09-31-14.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;编译步骤中，选择执行Windows批处理命令，主要执行如下操作：&lt;br/&gt;1.进入工程文件目录&lt;br/&gt;2.还原所有依赖的包&lt;br/&gt;3.执行编译Release版本&lt;br/&gt;4.进入Releas目录&lt;br/&gt;5.将生成的nupkg文件推送到NuGet服务器&lt;br/&gt;6.由于生成操作修改的修订版本号，所以将修改的文件提交&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;cd GAIA.GIS\
msbuild -t:restore
msbuild /p:Configuration=Release
cd bin\Release\
nuget push *.nupkg -Source http://192.168.1.209:1024/nuget iwehave2305!
git commit -a -m updateversion&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如图 ：&lt;br/&gt;&lt;img src=&quot;https://allanhao.com/images/2018-12-26-09-35-04.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;创建编译后事件，将修改记录推送到git服务器，也可以加失败邮件通知等等操作：&lt;br/&gt;&lt;img src=&quot;https://allanhao.com/images/2018-12-26-09-37-03.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;保存&lt;/p&gt;
&lt;p&gt;立即构建测试一下，大功告成~&lt;/p&gt;
</description>
<pubDate>Wed, 26 Dec 2018 05:32:00 +0000</pubDate>
<dc:creator>AllanHao</dc:creator>
<og:description>实际开发中我们需要对一些公共类库进行开发，并基于Jenkins进行CI/CD（CI:持续集成，CD:持续部署）,其他项目通过NuGet引用。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hao-zhang/p/10178641.html</dc:identifier>
</item>
<item>
<title>模板方法模式 Template method 行为型 设计模式（二十六） - noteless</title>
<link>http://www.cnblogs.com/noteless/p/10178477.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/noteless/p/10178477.html</guid>
<description>&lt;p&gt;模板方法模式 Template method&lt;/p&gt;
&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201812/897393-20181226123323020-1636278400.png&quot;&gt;&lt;img title=&quot;image_5c230441_24ee&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201812/897393-20181226123323453-2084565041.png&quot; alt=&quot;image_5c230441_24ee&quot; width=&quot;757&quot; height=&quot;671&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;上图为网上百度的一份简历模板截图&lt;/p&gt;

&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201812/897393-20181226123323835-704368672.png&quot;&gt;&lt;img title=&quot;image_5c230441_1b35&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201812/897393-20181226123324088-1749592612.png&quot; alt=&quot;image_5c230441_1b35&quot; width=&quot;871&quot; height=&quot;134&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;相信大家都有求职的经历，那么必然需要简历，写简历的时候，很可能你会网上检索一份&lt;span&gt;&lt;strong&gt;简历模板&lt;/strong&gt;&lt;/span&gt;，使用此模板的格式，然后替换为你的内容。 &lt;/p&gt;

&lt;p&gt;我们从小就有语文课，逢考必有作文，而学习的途径之一就是参考优秀的&lt;span&gt;&lt;strong&gt;范文&lt;/strong&gt;&lt;/span&gt;，学习了解他们的结构，风格等。&lt;/p&gt;
&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201812/897393-20181226123324276-1060359690.png&quot;&gt;&lt;img title=&quot;image_5c230441_782a&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201812/897393-20181226123324548-1536673009.png&quot; alt=&quot;image_5c230441_782a&quot; width=&quot;877&quot; height=&quot;136&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;以上就是现实世界中的模板，模板的概念随处可见，所有的工业制品哪个不是&lt;span&gt;&lt;strong&gt;模具&lt;/strong&gt;&lt;/span&gt;生产的？&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;在程序设计中，也有模板的概念&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;在软件开发过程中，可能经常会用到类似的处理逻辑，但是可能又有一些细节的差异&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;比如做菜，不管做什么菜，基本上都离不开买菜，洗菜，切菜，做菜几个主要步骤&lt;/p&gt;
&lt;p&gt;这几个步骤中，只有做菜的差别最大，不同的菜不同的做法，而买菜洗菜切菜的过程，却基本类似&lt;/p&gt;

&lt;p&gt;我们常常希望能够&lt;span&gt;&lt;strong&gt;定义一个通用的处理框架&lt;/strong&gt;&lt;/span&gt;，然后将一部分实现细节交由子类进行处理&lt;/p&gt;
&lt;p&gt;也就是&lt;span&gt;&lt;strong&gt;面向框架进行编程&lt;/strong&gt;&lt;/span&gt;，而不是每次都复制粘贴修改代码，具体的细节依靠子类确定，这就是模板的初衷。 &lt;/p&gt;

&lt;p&gt;比如定义一个做菜的抽象类，实现了买菜，洗菜，切菜，做菜方法定义为抽象方法留待子类实现&lt;/p&gt;
&lt;p&gt;那么，回锅肉和大头菜就可以通过继承扩展做菜类，只需要实现做菜的环节即可。&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;意图&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;定义一个操作中的算法的骨架，而将一些步骤延时到子类中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;TemplateMethod使得子类可以不改变一个算法的结构即可重新定义算法的某些特定步骤。&lt;/span&gt; &lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;结构&lt;/span&gt;&lt;/h3&gt;
&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201812/897393-20181226123324760-1130630533.png&quot;&gt;&lt;img title=&quot;image_5c230441_6923&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201812/897393-20181226123325056-1212543594.png&quot; alt=&quot;image_5c230441_6923&quot; width=&quot;207&quot; height=&quot;256&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;

&lt;div readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;抽象模板角色AbstractClass&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;定义一个或者多个抽象步骤，这些抽象操作叫做基本操作&lt;/p&gt;
&lt;p&gt;他们可能是一个复杂操作的组成步骤&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;实现类角色ConcreteClass&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;实现父类所定义的一个或者多个抽象方法&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;每一个抽象模板都可以有任意多个具体的模板角色与之对应，而实际中，一般不止一个&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;代码示例&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;定义做菜步骤:买菜，洗菜，切菜，做菜。&lt;/p&gt;
&lt;p&gt;买菜、洗菜、切菜都一样，做菜不同菜不同做法&lt;/p&gt;
&lt;p&gt;上菜将他们步骤进行打包&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; template;
 
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; 做菜 {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; 买菜(){
        System.out.println(&lt;/span&gt;&quot;买菜...&quot;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; 洗菜(){
        System.out.println(&lt;/span&gt;&quot;洗菜...&quot;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; 切菜(){
        System.out.println(&lt;/span&gt;&quot;切菜...&quot;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; 做菜();
     
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; 上菜(){
        买菜();
        洗菜();
        切菜();
        做菜();
        System.out.println(&lt;/span&gt;&quot;客官,菜来了~~~&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;做回锅肉和做大头菜都重写了“做菜”的方法&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; template;
 
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; 做回锅肉 &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; 做菜 {
@Override
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; 做菜() {
System.out.println(&lt;/span&gt;&quot;做回锅肉...&quot;&lt;span&gt;);
}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; template;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; 做大头菜 &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; 做菜 {
@Override
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; 做菜() {
System.out.println(&lt;/span&gt;&quot;做大头菜...&quot;&lt;span&gt;);
}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试代码&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201812/897393-20181226123325600-269221522.png&quot;&gt;&lt;img title=&quot;image_5c230442_6920&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201812/897393-20181226123325828-245313366.png&quot; alt=&quot;image_5c230442_6920&quot; width=&quot;463&quot; height=&quot;538&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;方法分类&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;通常模板模式中会涉及到两类方法，模板方法和基本方法&lt;/strong&gt;&lt;/span&gt;；&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;模板方法&lt;/strong&gt;&lt;/span&gt;指的是定义在抽象类中，把基本方法组合在一起形成复杂逻辑的方法，通常子类是不修改这个方法的&lt;/p&gt;
&lt;p&gt;模板方法给出来顶层的逻辑框架。&lt;/p&gt;
&lt;p&gt;比如上面的“上菜”，上菜方法调用了“买菜，洗菜，切菜，做菜”&lt;/p&gt;
&lt;p&gt;可以有任意多个的模板方法&lt;/p&gt;

&lt;p&gt;另一类就是&lt;span&gt;&lt;strong&gt;基本方法&lt;/strong&gt;&lt;/span&gt;了，基本方法就是复杂方法的组成部分&lt;/p&gt;
&lt;p&gt;基本方法又有几种形式&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;抽象方法，具体方法，钩子方法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;抽象方法&lt;/strong&gt;&lt;/span&gt;：abstract定义，子类实现&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;具体方法&lt;/strong&gt;&lt;/span&gt;：抽象类具体实现&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;钩子方法&lt;/strong&gt;&lt;/span&gt;：抽象类提供默认实现的方法，经常是一个空实现，好处是子类不是必须实现&lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt;

&lt;p&gt;前面说到，模板方法定义了顶层的框架逻辑，而且子类一般不修改，直接继承。&lt;/p&gt;
可以通过钩子方法对顶层框架逻辑进行微调&lt;/div&gt;
&lt;p&gt;比如上面做菜的示例中，上菜的环节中，新增加一个方法用来判断是否需要切菜&lt;/p&gt;
&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201812/897393-20181226123326092-1583198555.png&quot;&gt;&lt;img title=&quot;image_5c230442_711e&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201812/897393-20181226123326712-1245167220.png&quot; alt=&quot;image_5c230442_711e&quot; width=&quot;446&quot; height=&quot;298&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;

&lt;p&gt;做大头菜类中，重写这个方法，做大头菜，不切了&lt;/p&gt;
&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201812/897393-20181226123326979-719618342.png&quot;&gt;&lt;img title=&quot;image_5c230442_6905&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201812/897393-20181226123327198-1714972665.png&quot; alt=&quot;image_5c230442_6905&quot; width=&quot;386&quot; height=&quot;251&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;

&lt;p&gt;再来看看打印结果，大头菜，没切就做了。。。。。&lt;/p&gt;
&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201812/897393-20181226123327449-1583714421.png&quot;&gt;&lt;img title=&quot;image_5c230442_1cd4&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201812/897393-20181226123327845-196529919.png&quot; alt=&quot;image_5c230442_1cd4&quot; width=&quot;466&quot; height=&quot;225&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;模板方法模式的根本在于共性的提取与解题步骤框架化&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;通常使用继承机制完成这一目标&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;继承使得类型的等级结构易于理解，层次分明，非常适合抽象化的设计&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;但是&lt;span&gt;&lt;strong&gt;继承随之而来的强耦合，也将会导致很多的不便&lt;/strong&gt;&lt;/span&gt;，比如打破了封装，父类向子类暴露&lt;/p&gt;
&lt;p&gt;不能在运行时动态更改，父类改变，子类很可能也需要改变&lt;/p&gt;
&lt;p&gt;所以继承是一把双刃剑，使用不当也会导致很大的问题。&lt;/p&gt;
&lt;p&gt;但是，不能因噎废食，个人认为对继承的态度应该是&lt;span&gt;&lt;strong&gt;不滥用，不弃用&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;

&lt;p&gt;模板模式也可以用于方法层次上&lt;span&gt;&lt;strong&gt;方法的拆解&lt;/strong&gt;&lt;/span&gt;，如果一个方法中有很多的代码逻辑步骤&lt;/p&gt;
&lt;p&gt;那么，可以借助于模板模式定义解题步骤，将步骤进行拆解&lt;/p&gt;
&lt;p&gt;比如原方法为&lt;/p&gt;
&lt;p&gt;step（）&lt;/p&gt;
&lt;p&gt;拆分后为&lt;/p&gt;
&lt;p&gt;step（）{&lt;/p&gt;
&lt;p&gt;  step1（）；&lt;/p&gt;
&lt;p&gt;  step2（）；&lt;/p&gt;
&lt;p&gt;  ....&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;原来的step的方法就相当于抽象类，step1，step2就相当于具体的子类&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;模板模式的根本就是共性的提取以及解题步骤框架化&lt;/strong&gt;&lt;/span&gt;（就是步骤分明处理）&lt;/p&gt;
&lt;p&gt;所以千万不要认为模板就仅仅只是继承，实现接口就表示模板的概念了么？个人认为仍旧是&lt;/p&gt;
&lt;p&gt;没有模板方法，仅仅是基本方法就不是模板模式了么？个人认为仍旧是&lt;/p&gt;
&lt;p&gt;模板方法仍旧是依赖倒置原则的实现方案。&lt;/p&gt;
&lt;p&gt;只不过模板模式相对于面向抽象编程，又进一步期望父类提供更多给子类，比如算法逻辑框架&lt;/p&gt;
&lt;p&gt;将部分职责延迟到子类。&lt;/p&gt;

&lt;p&gt;借助于钩子方法的形式，可以引入更多的灵活性，子类可以对父类的整体逻辑做出微调&lt;/p&gt;
&lt;p&gt;达到了反向控制的效果---子类控制了父类方法的细节步骤&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;涉及到共性提取或者框架步骤分割的都可以考虑模板模式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;


</description>
<pubDate>Wed, 26 Dec 2018 04:39:00 +0000</pubDate>
<dc:creator>noteless</dc:creator>
<og:description>模板方法模式是一种非常简单实用的模式，本文对模板方法模式进行了简单的介绍，对意图，结构等进行了描述，并且给出了Java的示例代码，模板方法模式是对面向对象程序设计继承的一个很优秀的使用，想一下Thre</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/noteless/p/10178477.html</dc:identifier>
</item>
<item>
<title>偏前端-vue.js学习之路初级（一）概念 - 睿舞霓裳</title>
<link>http://www.cnblogs.com/Lrn14616/p/10178439.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Lrn14616/p/10178439.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;首先--不推荐新手直接使用 &lt;code&gt;vue-cli&lt;/code&gt;，尤其是在你还不熟悉基于 Node.js 的构建工具时。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;   新建一个html,引入一下js:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;/&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;/&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;html:&lt;br/&gt;1&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;  {{ message }}
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;js:&lt;br/&gt;1&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; app = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;   el: '#app'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;  data: {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     message: 'Hello Vue!'
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; })
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;el：&lt;/p&gt;
&lt;p&gt;简单的理解为  选中 id 为 app 的div，（提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标。）&lt;/p&gt;
&lt;p&gt;data: &lt;/p&gt;
&lt;div readability=&quot;21&quot;&gt;
&lt;p&gt;　　文档一：1.类型可以是 &lt;span&gt;object&lt;/span&gt; 或者 &lt;span&gt;function  &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　&lt;span&gt;2.组件的定义只接受 &lt;span&gt;function&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　&lt;span&gt;分析一：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;首先，data的类型可以是Object&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
   el:&lt;/span&gt;'app'&lt;span&gt;,
   data:{
     newTodoText:&lt;/span&gt;''&lt;span&gt;,
     visitCount:&lt;/span&gt;0&lt;span&gt;,
     zhen:&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
     todos:[],
     error:&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt; 
   }  
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       分析二：组件（component）里的定义的data必须是方法类型&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
Vue.component('myComponent'&lt;span&gt;,{
   props:[],
   data:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;{
              newTodoText:&lt;/span&gt;''&lt;span&gt;,
              visitCount:&lt;/span&gt;0&lt;span&gt;,
              zhen:&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
              todos:[],
              error:&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
        }
    }         
})               &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;div readability=&quot;23&quot;&gt;
&lt;p&gt;　　文档二：Vue 实例的数据对象。Vue 将会递归将 data 的属性转换为 getter/setter，从而让 data 的属性能够响应数据变化。对象必须是纯粹的对象 (含有零个或多个的 key/value 对)：浏览器 API 创建的原生对象，原型上的属性会被忽略。大概来说，data 应该只能是数据 - 不推荐观察拥有状态行为的对象。&lt;/p&gt;
&lt;p&gt;一旦观察过，不需要再次在数据对象上添加响应式属性。因此推荐在创建实例之前，就声明所有的根级响应式属性。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　&lt;span&gt;分析二：在上图的实例中，app的data对象中有五个属性，分别是：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;
     newTodoText:&lt;/span&gt;''&lt;span&gt;,
     visitCount:&lt;/span&gt;0&lt;span&gt;,
     zhen:&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
     todos:[],
     error:&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       分析二：Vue会把这五个属性转化为getter和setter来控制访问对象app的属性，以第一个属性newTodoText为例设置了getter和setter：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;const Vue = {&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;     _newTodoText:''&lt;span&gt;,&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;     /***************/&lt;br/&gt;get &lt;/span&gt;newTodoText(){&lt;br/&gt;return this._newTodoText;
&lt;/pre&gt;
&lt;pre&gt;
    },
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;    set newTodoText(value){&lt;br/&gt;this._newTodoText = value;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
    },
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;    /****************/&lt;br/&gt;}              &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;div readability=&quot;24.5&quot;&gt;
&lt;p&gt;　　文档三：实例创建之后，可以通过 &lt;code&gt;vm.$data&lt;/code&gt; 访问原始数据对象。Vue 实例也代理了 data 对象上所有的属性，因此访问 &lt;code&gt;vm.a&lt;/code&gt; 等价于访问 &lt;code&gt;vm.$data.a&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;　　　　　　以 &lt;code&gt;_&lt;/code&gt; 或 &lt;code&gt;$&lt;/code&gt; 开头的属性 不会 被 Vue 实例代理，因为它们可能和 Vue 内置的属性、API 方法冲突。你可以使用例如 &lt;code&gt;vm.$data._property&lt;/code&gt; 的方式访问这些属性。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　&lt;span&gt;分析三：这个好理解，就是你可以在data中可以定义属性时在属性名开头加上下划线“_”或者美元符号“$”，就不可以直接访问，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&amp;lt;body&amp;gt;&lt;br/&gt;　　　　&amp;lt;div id=&quot;app&quot;&amp;gt;&lt;br/&gt;　　　　{{first}}&lt;br/&gt;　　　　{{_first}}
&lt;/pre&gt;
&lt;pre&gt;
　　　　&amp;lt;/div&amp;gt;&lt;br/&gt;&amp;lt;script&amp;gt;
&lt;/pre&gt;
&lt;pre&gt;
new&lt;span&gt; Vue({
   el:'app'&lt;span&gt;,
   data:{
     first:'ok'&lt;span&gt;,
     _first:'nope'&lt;span&gt;,&lt;span&gt;&lt;span&gt; 
   }  
})&lt;br/&gt;//这里会报错，下面才是正解&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       分析三：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
//这里才是正确姿势！！&lt;br/&gt;&amp;lt;body&amp;gt;&lt;br/&gt;　　　　&amp;lt;div id=&quot;app&quot;&amp;gt;&lt;br/&gt;　　　　{{first}}&lt;br/&gt;　　　　{{$data._first}}
&lt;/pre&gt;
&lt;pre&gt;
　　　　&amp;lt;/div&amp;gt;&lt;br/&gt;&amp;lt;script&amp;gt;
&lt;/pre&gt;
&lt;pre&gt;
new Vue({
   el:'app',
   data:{
     first:'ok',
     _first:'nope', 
   }  
})
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;div readability=&quot;18&quot;&gt;
&lt;p&gt;　　文档四：当一个组件被定义，&lt;code&gt;data&lt;/code&gt; 必须声明为返回一个初始数据对象的函数，因为组件可能被用来创建多个实例。如果 &lt;code&gt;data&lt;/code&gt; 仍然是一个纯粹的对象，则所有的实例将共享引用同一个数据对象！通过提供 &lt;code&gt;data&lt;/code&gt; 函数，每次创建一个新实例后，我们能够调用 &lt;code&gt;data&lt;/code&gt; 函　数，从而返回初始数据的一个全新副本数据对象。&lt;/p&gt;
&lt;p&gt;如果需要，可以通过将 &lt;code&gt;vm.$data&lt;/code&gt; 传入 &lt;code&gt;JSON.parse(JSON.stringify(...))&lt;/code&gt; 得到深拷贝的原始数据对象。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　&lt;span&gt;分析四：这就是分析一要解决的问题了，为什么组件（component）里的定义的data必须是方法类型，原因就是在此，在工程中，每个组件都有可能用来被创建多个实例，而这个组件的实例他们的属性是不能共用的！意思是组件A的属性改变不能引起组件B的同一属性改变，结合原型链知识很容易就能想清楚&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;br/&gt;&lt;span&gt;除了文本插值，我们还可以像这样来绑定元素特性：v-bind 特性被称为指令。指令带有前缀 &lt;code&gt;v-&lt;/code&gt;&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app-2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;v-bind:title&lt;/span&gt;&lt;span&gt;=&quot;message&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    鼠标悬停几秒钟查看此处动态绑定的提示信息！
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;   &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; app2 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;   el: '#app-2'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;  data: {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     message: '页面加载于 ' + &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date().toLocaleString()
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; })
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;二、条件与循环&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.条件判断使用 v-if 指令：可以用 v-else 指令给 v-if 添加一个 &quot;else&quot; 块：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;随机生成一个数字，判断是否大于0.5，然后输出对应信息：&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &amp;lt;div id=&quot;app&quot;&amp;gt;
&lt;span&gt; 3&lt;/span&gt;     &amp;lt;div v-&lt;span&gt;if&lt;/span&gt;=&quot;Math.random() &amp;gt; 0.5&quot;&amp;gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;      Sorry
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &amp;lt;/div&amp;gt;
&lt;span&gt; 6&lt;/span&gt;     &amp;lt;div v-&lt;span&gt;else&lt;/span&gt;&amp;gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;      Not sorry
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &amp;lt;/div&amp;gt;
&lt;span&gt; 9&lt;/span&gt; &amp;lt;/div&amp;gt;
&lt;span&gt;10&lt;/span&gt;     
&lt;span&gt;11&lt;/span&gt; &amp;lt;script&amp;gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;   el: '#app'
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;})
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.v-else-if　　&lt;/p&gt;
&lt;p&gt;　　v-else-if 在 2.1.0 新增，顾名思义，用作 v-if 的 else-if 块。可以链式的多次使用：&lt;/p&gt;
&lt;p&gt;　　v-else 、v-else-if 必须跟在 v-if 或者 v-else-if之后。&lt;/p&gt;
&lt;p&gt;3.v-show  &lt;/p&gt;
&lt;p&gt;　　v-show 指令来根据条件展示元素：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &amp;lt;div id=&quot;app&quot;&amp;gt;
&lt;span&gt; 2&lt;/span&gt;     &amp;lt;h1 v-show=&quot;ok&quot;&amp;gt;Hello!&amp;lt;/h1&amp;gt;
&lt;span&gt; 3&lt;/span&gt; &amp;lt;/div&amp;gt;
&lt;span&gt; 4&lt;/span&gt;     
&lt;span&gt; 5&lt;/span&gt; &amp;lt;script&amp;gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;   el: '#app'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;  data: {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     ok: &lt;span&gt;true&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;})
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4.v-if与v-show的区别：&lt;/p&gt;
&lt;p&gt;　　在切换 &lt;span class=&quot;marked&quot;&gt;v-if 块时，Vue.js 有一个局部编译/卸载过程，因为 &lt;span class=&quot;marked&quot;&gt;v-if 之中的模板也可能包括数据绑定或子组件。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;marked&quot;&gt;&lt;span class=&quot;marked&quot;&gt;　　&lt;span class=&quot;marked&quot;&gt;v-if 是真实的条件渲染，因为它会确保条件块在切换当中合适地销毁与重建条件块内的事件监听器和子组件。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;marked&quot;&gt;　　v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——在条件第一次变为真时才开始局部编译（编译会被缓存起来）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　相比之下，&lt;span class=&quot;marked&quot;&gt;v-show 简单得多——元素始终被编译并保留，只是简单地基于 CSS 切换。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　一般来说，&lt;span class=&quot;marked&quot;&gt;v-if 有更高的切换消耗而 &lt;span class=&quot;marked&quot;&gt;v-show 有更高的初始渲染消耗。因此，如果需要频繁切换 &lt;span class=&quot;marked&quot;&gt;v-show 较好，如果在运行时条件不大可能改变 &lt;span class=&quot;marked&quot;&gt;v-if 较好。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;span class=&quot;marked&quot;&gt;&lt;span class=&quot;marked&quot;&gt;&lt;span class=&quot;marked&quot;&gt;&lt;span class=&quot;marked&quot;&gt;5.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;循环使用 v-for 指令。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　v-for 指令需要以 &lt;strong&gt;site in sites&lt;/strong&gt; 形式的特殊语法， &lt;strong&gt;sites 是源数据数组，并且 site 是数组元素迭代的别名&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　v-for 可以绑定数据到数组来渲染一个列表：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &amp;lt;div id=&quot;app&quot;&amp;gt;
&lt;span&gt; 2&lt;/span&gt;   &amp;lt;ol&amp;gt;
&lt;span&gt; 3&lt;/span&gt;     &amp;lt;li v-&lt;span&gt;for&lt;/span&gt;=&quot;site in sites&quot;&amp;gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;      {{ site.name }}
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &amp;lt;/li&amp;gt;
&lt;span&gt; 6&lt;/span&gt;   &amp;lt;/ol&amp;gt;
&lt;span&gt; 7&lt;/span&gt; &amp;lt;/div&amp;gt;
&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &amp;lt;script&amp;gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;   el: '#app'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;  data: {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    sites: [
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;       { name: 'Runoob'&lt;span&gt; },
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;       { name: 'Google'&lt;span&gt; },
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;       { name: 'Taobao'&lt;span&gt; }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    ]
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;})
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;模板中使用 v-for：根据sites数组内容循环展示模板里的 li 标签&lt;/p&gt;
&lt;p&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;1&lt;/span&gt; &amp;lt;ul&amp;gt; &lt;span&gt;2&lt;/span&gt; &amp;lt;template v-&lt;span&gt;for&lt;/span&gt;=&quot;site in sites&quot;&amp;gt; &lt;span&gt;3&lt;/span&gt; &amp;lt;li&amp;gt;{{ site.name }}&amp;lt;/li&amp;gt; &lt;span&gt;4&lt;/span&gt; &amp;lt;li&amp;gt;--------------&amp;lt;/li&amp;gt; &lt;span&gt;5&lt;/span&gt; &amp;lt;/template&amp;gt; &lt;span&gt;6&lt;/span&gt; &amp;lt;/ul&amp;gt;&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;5.1 v-for 迭代对象&lt;/p&gt;
&lt;p&gt;v-for 可以通过一个对象的属性来迭代数据：&lt;/p&gt;
&lt;p&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;1&lt;/span&gt; &amp;lt;li v-&lt;span&gt;for&lt;/span&gt;=&quot;value in object&quot;&amp;gt; &lt;span&gt;2&lt;/span&gt; &lt;span&gt;{{ value }}&lt;/span&gt; &lt;span&gt;3&lt;/span&gt; &amp;lt;/li&amp;gt;&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;也可以提供第二个的参数为键名：&lt;/p&gt;
&lt;p&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;1&lt;/span&gt; &amp;lt;li v-&lt;span&gt;for&lt;/span&gt;=&quot;(value, key) in object&quot;&amp;gt; &lt;span&gt;2&lt;/span&gt; &lt;span&gt;{{ key }} : {{ value }}&lt;/span&gt; &lt;span&gt;3&lt;/span&gt; &amp;lt;/li&amp;gt;&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;第三个参数为索引：&lt;/p&gt;
&lt;p&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;1&lt;/span&gt; &amp;lt;li v-&lt;span&gt;for&lt;/span&gt;=&quot;(value, key, index) in object&quot;&amp;gt; &lt;span&gt;2&lt;/span&gt; &lt;span&gt;{{ index }}. {{ key }} : {{ value }}&lt;/span&gt; &lt;span&gt;3&lt;/span&gt; &amp;lt;/li&amp;gt;&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;不仅如此，在迭代属性输出的之前，v-for会对属性进行升序排序输出：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &amp;lt;div id=&quot;app&quot;&amp;gt;
&lt;span&gt; 2&lt;/span&gt; &amp;lt;ul&amp;gt;
&lt;span&gt; 3&lt;/span&gt;     &amp;lt;li v-&lt;span&gt;for&lt;/span&gt;=&quot;n in object&quot;&amp;gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     {{ n }}
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &amp;lt;/li&amp;gt;
&lt;span&gt; 6&lt;/span&gt;   &amp;lt;/ul&amp;gt;
&lt;span&gt; 7&lt;/span&gt; &amp;lt;/div&amp;gt;
&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;   el: '#app'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;  data: {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    object: {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;       2: '第三'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;       0: '第一'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;       1: '第二'
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; })
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;5.2 v-for 迭代整数&lt;/p&gt;
&lt;p&gt;v-for 也可以循环整数&lt;/p&gt;
&lt;p&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;1&lt;/span&gt; &amp;lt;li v-&lt;span&gt;for&lt;/span&gt;=&quot;n in 10&quot;&amp;gt; &lt;span&gt;2&lt;/span&gt; &lt;span&gt;{{ n }}&lt;/span&gt; &lt;span&gt;3&lt;/span&gt; &amp;lt;/li&amp;gt; &lt;span&gt;4&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;从1展示到10&lt;/span&gt;&lt;/span&gt; &lt;/p&gt;

&lt;p&gt;5.3 v-for 循环数组&lt;/p&gt;
&lt;p&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;1&lt;/span&gt; &amp;lt;li v-&lt;span&gt;for&lt;/span&gt;=&quot;n in [1,3,5]&quot;&amp;gt; &lt;span&gt;2&lt;/span&gt; &lt;span&gt;{{ n }}&lt;/span&gt; &lt;span&gt;3&lt;/span&gt; &amp;lt;/li&amp;gt; &lt;span&gt;4&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;展示1/3/5&lt;/span&gt;&lt;/span&gt; &lt;/p&gt;


&lt;p&gt;&lt;span&gt;三、处理用户输入&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.v-on指令绑定事件监听&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&amp;lt;div id=&quot;app-5&quot;&amp;gt;
  &amp;lt;p&amp;gt;{{ message }}&amp;lt;/p&amp;gt;
  &amp;lt;button v-on:click=&quot;reverseMessage&quot;&amp;gt;逆转消息&amp;lt;/button&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var app5 = &lt;span class=&quot;keyword&quot;&gt;new Vue({&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  el: &lt;span class=&quot;string&quot;&gt;'#app-5',&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  data: {&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    message: &lt;span class=&quot;string&quot;&gt;'Hello Vue.js!'&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  },&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  methods: {&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    reverseMessage: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function (&lt;span class=&quot;params&quot;&gt;) {&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;this.message = &lt;span class=&quot;keyword&quot;&gt;this.message.split(&lt;span class=&quot;string&quot;&gt;'').reverse().join(&lt;span class=&quot;string&quot;&gt;'')&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    }&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  }&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;})&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2.v-model（它能轻松实现表单输入和应用状态之间的双向绑定。）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;div id=&quot;app-6&quot;&amp;gt;
  &amp;lt;p&amp;gt;{{ message }}&amp;lt;/p&amp;gt;
  &amp;lt;input v-model=&quot;message&quot;&amp;gt;
&amp;lt;/div&amp;gt;
&lt;span&gt;var&lt;/span&gt; app6 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
  el: &lt;/span&gt;'#app-6'&lt;span&gt;,
  data: {
    message: &lt;/span&gt;'Hello Vue!'&lt;span&gt;
  }
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;四、组件化应用构建&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;组件系统是 Vue 的另一个重要概念，因为它是一种抽象，允许我们使用小型、独立和通常可复用的组件构建大型应用.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;组件化构建，需要理解的还是比较多的，这里单独写一篇方便学习  &lt;a href=&quot;https://www.cnblogs.com/Lrn14616/p/10179463.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;vue.js 组件化构建&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 26 Dec 2018 04:23:00 +0000</pubDate>
<dc:creator>睿舞霓裳</dc:creator>
<og:description>首先--不推荐新手直接使用 vue-cli，尤其是在你还不熟悉基于 Node.js 的构建工具时。 新建一个html,引入一下js: el： 简单的理解为 选中 id 为 app 的div，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Lrn14616/p/10178439.html</dc:identifier>
</item>
<item>
<title>python套接字解决tcp粘包问题 - -零</title>
<link>http://www.cnblogs.com/-wenli/p/10178436.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/-wenli/p/10178436.html</guid>
<description>&lt;p&gt;目录&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot; readability=&quot;5&quot;&gt;
什么是粘包&lt;p&gt;演示粘包现象

解决粘包

实际应用
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;




&lt;p&gt;首先只有tcp有粘包现象，udp没有粘包&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;socket收发消息的原理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1477786/201812/1477786-20181226095004782-1766408052.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
发送端可以是一K一K地发送数据，而接收端的应用程序可以两K两K地提走数据，当然也有可能一次提走3K或6K数据，或者一次只提走几个字节的数据，也就是说，应用程序所看到的数据是一个整体，或说是一个流（stream），&lt;br/&gt;一条消息有多少字节对应用程序是不可见的，因此TCP协议是面向流的协议，这也是容易出现粘包问题的原因。而UDP是面向消息的协议，每个UDP段都是一条消息，应用程序必须以消息为单位提取数据，不能一次提取任意字节&lt;br/&gt;的数据，这一点和TCP是很不同的。怎样定义消息呢？可以认为对方一次性write/send的数据为一个消息，需要明白的是当对方send一条信息的时候，无论底层怎样分段分片，TCP协议层会把构成整条消息的数据段排序完成后&lt;br/&gt;才呈现在内核缓冲区。

例如基于tcp的套接字客户端往服务端上传文件，发送时文件内容是按照一段一段的字节流发送的，在接收方看了，根本不知道该文件的字节流从何处开始，在何处结束

&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;粘包问题的根源&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
所谓粘包问题主要还是因为接收方不知道消息之间的界限，不知道一次性提取多少字节的数据所造成的。
&lt;/pre&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
此外，发送方引起的粘包是由TCP协议本身造成的，TCP为提高传输效率，发送方往往要收集到足够多的数据后才发送一个TCP段。若连续几次需要send的数据都很少，通常TCP会根据优化算法把这些数据合成一个TCP段后一次发&lt;br/&gt;送出去，这样接收方就收到了粘包数据。
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;tcp和udp协议&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
TCP（transport control protocol，传输控制协议）是&lt;strong&gt;面向连接&lt;/strong&gt;的，&lt;strong&gt;面向流&lt;/strong&gt;的，提供高可靠性服务。收发两端（客户端和服务器端）都要有一一成对的socket，因此，发送端为了将多个发往接收端的包，更有效的发到对&lt;br/&gt;方，使用了优化方法（Nagle算法），将&lt;strong&gt;多次间隔较小且数据量小&lt;/strong&gt;的数据，合并成一个大的数据块，然后进行封包。这样，接收端，就难于分辨出来了，必须提供科学的拆包机制。 即面向流的通信是无消息保护边界的。&lt;br/&gt;UDP（user datagram protocol，用户数据报协议）是&lt;strong&gt;无连接&lt;/strong&gt;的，&lt;strong&gt;面向消息&lt;/strong&gt;的，提供高效率服务。不会使用块的合并优化算法，, 由于UDP支持的是一对多的模式，所以接收端的skbuff(套接字缓冲区）采用了&lt;strong&gt;链式结构&lt;/strong&gt;来记&lt;br/&gt;录每一个到达的UDP包，在每个UDP包中就有了消息头（消息来源地址，端口等信息），这样，对于接收端来说，就容易进行区分处理了。 即面向消息的通信是有消息保护边界的。&lt;br/&gt;tcp是基于数据流的，于是收发的消息不能为空，这就需要在&lt;strong&gt;客户端和服务端都添加空消息的处理机制&lt;/strong&gt;，防止程序卡住，而udp是基于数据报的，即便是你输入的是空内容（直接回车），那也不是空消息，udp协议会帮你封装上&lt;br/&gt;消息头，实验略

&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;&lt;span&gt;补充&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
拆包的发生情况

当发送端缓冲区的长度大于网卡的MTU时，tcp会将这次发送的数据拆成几个数据包发送出去。&lt;br/&gt;补充问题一：为何tcp是可靠传输，udp是不可靠传输

基于tcp的数据传输请参考我的另一篇文章http://www.cnblogs.com/linhaifeng/articles/5937962.html，tcp在数据传输时，发送端先把数据发送到自己的缓存中，然后协议控制将缓存中的数据发往对端，对端返回&lt;br/&gt;一个ack=1，发送端则清理缓存中的数据，对端返回ack=0，则重新发送数据，所以tcp是可靠的

而udp发送数据，对端是不会返回确认信息的，因此不可靠&lt;br/&gt;补充问题二：send(字节流)和recv(1024)及sendall

recv里指定的1024意思是从缓存里一次拿出1024个字节的数据

send的字节流是先放入己端缓存，然后由协议控制将缓存内容发往对端，如果待发送的字节流大小大于缓存剩余空间，那么数据丢失，用sendall就会循环调用send，数据不会丢失

&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
udp的recvfrom是阻塞的，一个recvfrom(x)必须对唯一一个sendinto(y),收完了x个字节的数据就算完成,若是y&amp;gt;x数据就丢失，这意味着udp根本不会粘包，但是会丢数据，不可靠

tcp的协议数据不会丢，没有收完包，下次接收，会继续上次继续接收，己端总是在收到ack时才会清除缓冲区内容。数据是可靠的，但是会粘包。&lt;/pre&gt;&lt;/div&gt;





&lt;p&gt;&lt;span&gt;两种情况下会发生粘包&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
发送端需要等缓冲区满才发送出去，造成粘包（发送数据时间间隔很短，数据量很小，会合到一起，产生粘包），这是由于tcp的优化算法。


接收方不及时接收缓冲区的包，造成多个包接收（客户端发送了一段数据，服务端只收了一小部分，服务端下次再收的时候还是从缓冲区拿上次遗留的数据，产生粘包） 
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;&lt;span&gt;第一种情况&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;客户端多次间隔时间短，数据量小的发送数据&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
#服务端&lt;br/&gt;import socket


def main():
    ip_port= ('127.0.0.1',4444)
    back_log=5
    buffer_size=1024

    s1 = socket.socket(socket.AF_INET,socket.SOCK_STREAM) #基于tcp的网络通信
    s1.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)
    s1.bind(ip_port) #绑定ip和端口
    s1.listen(back_log)  # 最多连接几个客户端
    conn, addr = s1.accept()

    data1=conn.recv(buffer_size)
    data2=conn.recv(buffer_size)
    data3=conn.recv(buffer_size)
    print('第一次',data1.decode('utf-8'))
    print('第二次',data2.decode('utf-8'))
    print('第三次',data3.decode('utf-8'))
    conn.close()
    s1.close()

if __name__ == '__main__':
    main()
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
#客户端
import socket


def main():
    ip_port = ('127.0.0.1', 4444)

    buffer_size = 1024

    s2 = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    s2.connect(ip_port)  # 连接服务端

    data1 = 'hello'
    s2.send(data1.encode('utf-8'))
    data2 ='wrold'
    s2.send(data2.encode('utf-8'))
    data3 = 'pop'
    s2.send(data3.encode('utf-8'))
    s2.close()

if __name__ == '__main__':
    main()
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;演示&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;可以看出来服务端在第一次就把三次发送的数据都接收了，这就是粘包，服务端不知道一次读取多少的数据，一次全部读取出来。&lt;/p&gt;
&lt;p&gt;首先我们要知道并不是客户端发几次，服务端就要接收几次，一次发的数据也可以三次读取出来，收发信息都是从自己的内核缓存区读取。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1477786/201812/1477786-20181226102057108-1363211747.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;第二种情况&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;接收方不及时接收缓冲区的包，造成多个包接收（客户端发送了一段数据，服务端只收了一小部分，服务端下次再收的时候还是从缓冲区拿上次遗留的数据，产生粘包） &lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;44&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
#服务端&lt;br/&gt;import socket


def main():
    ip_port= ('127.0.0.1',4444)
    back_log=5
    buffer_size=1024

    s1 = socket.socket(socket.AF_INET,socket.SOCK_STREAM) #基于tcp的网络通信
    s1.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)
    s1.bind(ip_port) #绑定ip和端口
    s1.listen(back_log)  # 最多连接几个客户端
    conn, addr = s1.accept()

    data1=conn.recv(5)
    data2=conn.recv(buffer_size)
   
    print('第一次',data1.decode('utf-8'))
    print('第二次',data2.decode('utf-8'))
  
    conn.close()
    s1.close()

if __name__ == '__main__':
    main()


&lt;br/&gt;#客户端
import socket


def main():
    ip_port = ('127.0.0.1', 4444)

   

    s2 = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    s2.connect(ip_port)  # 连接服务端

    data1 = 'hellowroldpop'
    s2.send(data1.encode('utf-8'))
    s2.close()

if __name__ == '__main__':
    main()
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;演示&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;服务端读取数据没有全部读取出来，导致第一次应该接收完的数据还要第二次读取出来&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1477786/201812/1477786-20181226105418029-416502254.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;






&lt;p&gt;&lt;span&gt;问题的根源在于，接收端不知道发送端将要传送的字节流的长度，所以解决粘包的方法就是围绕，如何让发送端在发送数据前，把自己将要发送的字节流总大小让接收端知晓，然后接收端来一个死循环接收完所有数据&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;第一种解决方法&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
#服务端
import socket


def main():
    ip_port = ('127.0.0.1', 4444)
    back_log = 5
    buffer_size = 1024

    s1 = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  # 基于tcp的网络通信
    s1.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    s1.bind(ip_port)  # 绑定ip和端口
    s1.listen(back_log)  # 最多连接几个客户端
    conn, addr = s1.accept()

    while True:
　　　　 #接收数据大小
        length= conn.recv(buffer_size).decode('utf-8')&lt;br/&gt;　　　　 #为防止客户端连续发包，回应
        conn.send('ready'.encode('utf-8'))
        length=int(length)

        recv_size=0   #已经接收到数据的大小
        recv_msg=b''  #已经接收到的数据&lt;br/&gt;　　　　 #接收数据
        while recv_size&amp;lt;length:
            r_msg = conn.recv(buffer_size) 
            recv_msg+=r_msg
            recv_size +=len(r_msg)
　　　　　　　#另一种方法接收数据的方法&lt;br/&gt;#recv_msg+=conn.recv(buffer_size)
            #recv_size=len(recv_msg)




    s1.close()


if __name__ == '__main__':
    main()
&lt;/pre&gt;&lt;/div&gt;



&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
#客户端
import socket


def main():
    ip_port = ('127.0.0.1', 4444)

    buffer_size = 1024

    s2 = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    s2.connect(ip_port)  # 连接服务端

    while True:

        data1 = input('input:')&lt;br/&gt;　　　　　#将数据大小转为字符型然后编码发出去
        s2.send(str(len(data1)).encode('utf-8'))&lt;br/&gt;　　　　　　#接收服务端的回应
        server_Ready=s2.recv(buffer_size)&lt;br/&gt;　　　　　　#接收到服务端回应
        if server_Ready==b'ready':
            s2.send(data1.encode('utf-8'))
    s2.close()


if __name__ == '__main__':
    main()
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
 总结：客户端在发送数据时，先发送数据大小，这时不能把数据内容一起发送出去，服务端第一次接收的时候，并不知道该读取多少的数据大小和多少的数据内容，所以还是会造成粘包，我们的解决办法是，服务端获取到数据大小后，要回应一次，然后根据数据大小来循环读取内容。

这种方法不好，需要服务端多发一次回应，这很影响服务端的性能。

程序的运行速度远快于网络传输速度，所以在发送一段字节前，先用send去发送该字节流长度，这种方式会放大网络延迟带来的性能损耗
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;&lt;span&gt;第二种解决方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为字节流加上自定义固定长度报头，报头中包含字节流长度，然后一次send到对端，对端在接收时，先从缓存中取出定长的报头，然后再取真实数据&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;struct模块 &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
该模块可以把一个类型，如数字，转成固定长度的bytes

&amp;gt;&amp;gt;&amp;gt; struct.pack('i',1111111111111) #第一个参数是要封装的格式类型，第二个参数是要封装的内容

struct.error: 'i' format requires -2147483648 &amp;lt;= number &amp;lt;= 2147483647 #这个封装数据的范围，只要在这个范围里面，就可以把内容封装成固定大小

&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1477786/201812/1477786-20181226113701871-677981814.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
#服务端

import socket
import struct


def main():
    ip_port = ('127.0.0.1', 4444)
    back_log = 5
    buffer_size = 1024

    s1 = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  # 基于tcp的网络通信
    s1.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    s1.bind(ip_port)  # 绑定ip和端口
    s1.listen(back_log)  # 最多连接几个客户端
    conn, addr = s1.accept()

    while True:

        length＿data= conn.recv(4)
        length=struct.unpack('i',length＿data)[0]

        recv_size=0   #已经接收到数据的大小
        recv_msg=b''  #已经接收到的数据

        while recv_size&amp;lt;length:
            r_msg = conn.recv(buffer_size)
            recv_msg+=r_msg
            recv_size +=len(r_msg)

            #recv_msg+=conn.recv(buffer_size)
            #recv_size=len(recv_msg)


    s1.close()


if __name__ == '__main__':
    main()
&lt;/pre&gt;&lt;/div&gt;



&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
#客户端

import socket
import struct


def main():
    ip_port = ('127.0.0.1', 4444)

    buffer_size = 1024

    s2 = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    s2.connect(ip_port)  # 连接服务端

    while True:

        data1 = input('input:')
        length=len(data1)
        #定制包头 i为4个字节，所以接收方为四个字节，这个大小并不是输入的大小，而是封装固定的大小
        data_length=struct.pack('i',length) #使用struct，直接将int转为二进制型数据传输，对方使用struct解包
        s2.send(data_length)

        s2.send(data1.encode('utf-8'))
    s2.close()


if __name__ == '__main__':
    main()
&lt;/pre&gt;&lt;/div&gt;


&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
总结：客户端把数据长度封装成一个固定大小的数据，这时服务端就可以指定读取固定大小的内容，不会读取数据的内容，服务端只要根据数据长度再来接收数据内容就好了，所以客户端连续两次发数据，不会粘包，因为服务&lt;br/&gt;端每次接收都只接收了本次该接收的数据。&lt;/pre&gt;&lt;/div&gt;





&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;47&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
#服务端&lt;br/&gt;from socket import  *
import subprocess
import struct


def main():
    ip_port=('127.0.0.1',8080)
    back_log=5
    buffer_size=1024


    s1 = socket(AF_INET,SOCK_STREAM)
    s1.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1)
    s1.bind(ip_port)
    s1.listen(back_log)

    while True:
        conn,addr=s1.accept()

        while True:
            try:
                #收信息
                 cmd = conn.recv(buffer_size)
                 if not cmd:break
                 print('收到的命令是:',cmd.decode('utf-8'))


                 #执行命令
                 res = subprocess.Popen(cmd.decode('utf-8'),shell=True,
                                        stderr=subprocess.PIPE,
                                        stdout=subprocess.PIPE,
                                        stdin=subprocess.PIPE)

                 err = res.stderr.read()
                 if  err:
                     cmd_res=err
                 else:
                     cmd_res=res.stdout.read()

                 if not cmd_res:
                     cmd_res='执行成功'.encode('gbk')

                 length=len(cmd_res)
                #第一次发送数据大小
                 data_length = struct.pack('i', length)  # 使用struct，直接将int转为二进制型数据传输，对方使用struct解包
                 conn.send(data_length)
                #发信息
                #注意：执行的结果默认jbk编码方式,所以客户端必须使用gbk方式解码
                 conn.send(cmd_res)

            except Exception:
                break
        conn.close()
    s1.close()  # 关闭服务端套接字


if __name__ == '__main__':
    main()
&lt;/pre&gt;&lt;/div&gt;


&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
#客户端&lt;br/&gt;from socket import  *
import struct


def main():
    ip_port=('127.0.0.1',8080)
    buffer_size=1024

    s1 = socket(AF_INET,SOCK_STREAM)
    s1.connect(ip_port)

    while True:
        cmd = input('--&amp;gt;')
        if not cmd:continue
        if cmd =='quite':break
        s1.send(cmd.encode('utf-8'))
        length＿data =s1.recv(4)
        length = struct.unpack('i', length＿data)[0]

        recv_size = 0  # 已经接收到数据的大小
        recv_msg = b''  # 已经接收到的数据

        while recv_size &amp;lt; length:
            r_msg = s1.recv(buffer_size)
            recv_msg += r_msg
            recv_size += len(r_msg)


            # recv_msg+=conn.recv(buffer_size)
            # recv_size=len(recv_msg)

        print('命令执行结果:',recv_msg.decode('gbk'))

    s1.close()

if __name__=='__main__':
    main()
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
如果没有粘包的处理

服务端把命令执行的结果发给客户端的时候，数据太大，客户端一次没有接收完，在客户端第二次执行命令的时候，就会把第一次没有读取完的部分也读取出来，这属于我们刚才说的第二种粘包的情况。

有了粘包的处理

只要服务端把结果发过来，就算超过网卡的限制（拆包发送），客户端能保证在循环的过程中接收完结果
&lt;/pre&gt;&lt;/div&gt;


</description>
<pubDate>Wed, 26 Dec 2018 04:22:00 +0000</pubDate>
<dc:creator>-零</dc:creator>
<og:description>python套接字解决tcp粘包问题 目录 什么是粘包 首先只有tcp有粘包现象，udp没有粘包 socket收发消息的原理 粘包问题的根源 tcp和udp协议 补充 总结 演示粘包现象 两种情况下会</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/-wenli/p/10178436.html</dc:identifier>
</item>
</channel>
</rss>