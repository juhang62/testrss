<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>【趣味设计模式系列】之【装饰器模式】 - 小猪爸爸</title>
<link>http://www.cnblogs.com/father-of-little-pig/p/13622216.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/father-of-little-pig/p/13622216.html</guid>
<description>&lt;h2 id=&quot;1-简介&quot;&gt;1. 简介&lt;/h2&gt;
&lt;p&gt;装饰器模式（Decorator Pattern）：动态地给一个对象添加职责，就增加功能来说，装饰器比生成子类更灵活。&lt;/p&gt;
&lt;h2 id=&quot;2-示例&quot;&gt;2. 示例&lt;/h2&gt;
&lt;p&gt;水果店需要给网上客户发货，除了包装之外，需要对特定水果包装加额外装饰，比如加防伪标志、加固、加急等额外功能，但在外部看来还是打包组件。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1765702/202009/1765702-20200910151944648-1588275968.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;类图设计&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1765702/202009/1765702-20200910161904827-818531910.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;水果包装接口类Bag，接口方法pack，完成水果打包。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.wzj.decorator;

/**
 * @Author: wzj
 * @Date: 2020/9/8 10:13
 * @Desc: 包装接口
 */
public interface Bag {
    void pack();
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;苹果、橘子、香蕉各自实现包装接口，用自己的特定的外包装。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.wzj.decorator;

/**
 * @Author: wzj
 * @Date: 2020/9/8 10:15
 * @Desc: 苹果包装类
 */
public class AppleBag implements Bag {
    @Override
    public void pack() {
        System.out.println(&quot;苹果使用纸箱包装&quot;);
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;package com.wzj.decorator;

/**
 * @Author: wzj
 * @Date: 2020/9/8 10:15
 * @Desc: 橘子包装类
 */
public class OrangeBag implements Bag {
    @Override
    public void pack() {
        System.out.println(&quot;橘子使用网兜包装&quot;);
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;package com.wzj.decorator;

/**
 * @Author: wzj
 * @Date: 2020/9/8 10:15
 * @Desc: 香蕉包装类
 */
public class BananaBag implements Bag {
    @Override
    public void pack() {
        System.out.println(&quot;香蕉使用竹箩包装&quot;);
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;装饰器类BagDecorator，实现包装类Bag接口，同时拥有包装接口的引用，为了组装更多具体装饰器加入进来，增加包装类的装饰功能。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.wzj.decorator;

/**
 * @Author: wzj
 * @Date: 2020/9/8 10:23
 * @Desc: 装饰器类
 */
public class BagDecorator implements Bag {
    private Bag bag;  //维持一个对抽象构件对象的引用

    public BagDecorator(Bag bag)  //注入一个抽象构件类型的对象
    {
        this.bag = bag;
    }

    public void pack() {
        bag.pack();
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;防伪装饰器CheckedBagDecorator，继承BagDecorator类，并增加自己的防伪标识方法checked。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.wzj.decorator;

/**
 * @Author: wzj
 * @Date: 2020/9/8 10:32
 * @Desc: 防伪装饰器
 */
public class CheckedBagDecorator extends BagDecorator {
    public CheckedBagDecorator(Bag bag) {
        super(bag);
    }

    @Override
    public void pack() {
        super.pack();
        checked();  //打印防伪标识
    }

    //增加防伪标识
    public void checked() {
        System.out.println(&quot;===============&quot;);
        System.out.println(&quot;打印上防伪标识&quot;);
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;加固装饰器ReinforceBagDecorator，继承BagDecorator类，并增加自己的加固方法reinforce。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.wzj.decorator;

/**
 * @Author: wzj
 * @Date: 2020/9/8 10:34
 * @Desc: 加固装饰器
 */
public class ReinforceBagDecorator extends BagDecorator{
    public ReinforceBagDecorator(Bag bag) {
        super(bag);
    }

    public void pack() {
        super.pack();  //调用原有业务方法
        reinforce();
    }

    //加固包装
    public void reinforce() {
        System.out.println(&quot;===============&quot;);
        System.out.println(&quot;加固了包装&quot;);
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;加急装饰器SpeedBagDecorator，继承BagDecorator类，并增加自己的加急方法speedy。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.wzj.decorator;

/**
 * @Author: wzj
 * @Date: 2020/9/8 10:34
 * @Desc: 加急装饰器
 */
public class SpeedBagDecorator extends BagDecorator {

    public SpeedBagDecorator(Bag bag) {
        super(bag);
    }

    public void pack() {
        super.pack();  //调用原有业务方法
        speedy();
    }

    //快件加急
    public void speedy() {
        System.out.println(&quot;===============&quot;);
        System.out.println(&quot;打上加急标识&quot;);
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;客户端类&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.wzj.decorator;

import org.aspectj.weaver.ast.Or;

/**
 * @Author: wzj
 * @Date: 2020/9/8 10:40
 * @Desc:
 */
public class Client {
    public static void main(String[] args) {
        AppleBag appleBag = new AppleBag();
        OrangeBag orangeBag = new OrangeBag();
        BananaBag bananaBag = new BananaBag();
        // 苹果纸箱包装后，外加防伪标识、加固包装
        new ReinforceBagDecorator(new CheckedBagDecorator(appleBag)).pack();
        System.out.println(&quot;*********************************&quot;);
        // 橘子网兜包装后，外加防伪标识、加固包装
        new SpeedBagDecorator(new ReinforceBagDecorator(new CheckedBagDecorator(orangeBag))).pack();

    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;苹果使用纸箱包装
===============
打印上防伪标识
===============
加固了包装
*********************************
橘子使用网兜包装
===============
打印上防伪标识
===============
加固了包装
===============
打上加急标识
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上述例子可以看出，装饰器的好处，不仅可以对具体的水果包装类进行装饰，多个装饰器还可以&lt;span&gt;&lt;strong&gt;&lt;code&gt;嵌套装饰&lt;/code&gt;&lt;/strong&gt;&lt;/span&gt;，非常灵活，这也是为什么，装饰器中需要引用Bag类，就是方便嵌套，因为每个具体的装饰器，本身也是Bag的子类。&lt;/p&gt;
&lt;h2 id=&quot;3-源码分析&quot;&gt;3. 源码分析&lt;/h2&gt;
&lt;p&gt;Java IO类库非常庞大，从大类分，如果从按流的方向来分的话，分为输入流InputStream，输出流OutputStream，如果按照读取的方式分的话，分为字节流与字符流，具体如下图&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1765702/202009/1765702-20200910185419552-1620078586.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;针对不同的读取和写入场景，Java IO 又在这四个父类基础之上，扩展出了很多子类，如下图&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1765702/202009/1765702-20200910211347298-1232777386.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;OutputStream 是一个抽象类，FileOutputStream 是专门用来写文件流的子类，FilterOutputStream很特殊，它实现了OutputStream，同时持有OutputStream的引用，部分源码如下图：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class FilterInputStream extends InputStream {
    /**
     * The input stream to be filtered.
     */
    protected volatile InputStream in;

    ...
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以FilterOutputStream在设计的时候本质就是一个装饰器，其子类BufferedOutputStream，DataOutputStream，PrintStream都是具体的装饰器，实现额外的功能。&lt;br/&gt;同样FilterInputStream、InputStreamReader、OutputStreamWriter都是装饰器类，其子类充当具体装饰的功能。&lt;br/&gt;在平时写代码的时候都有如下几行嵌套的写法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;File f = new File(&quot;c:/work/test.data&quot;);
FileOutputStream fos = new FileOutputStream(f);
OutputStreamWriter osw = new OutputStreamWriter(fos);
BufferedWriter bw = new BufferedWriter(osw);
bw.write(&quot;https://githup.com&quot;);
bw.flush();
bw.close();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;本质上，OutputStream的实现类可以与具体装饰器实现相互嵌套，具体的装饰器之间也可以相互嵌套，非常灵活，避免了独立为每个类创建子类而产生累爆炸的不合理设计。&lt;/p&gt;
&lt;h2 id=&quot;4-总结&quot;&gt;4. 总结&lt;/h2&gt;
&lt;h3 id=&quot;41-优点&quot;&gt;4.1 优点&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。&lt;/li&gt;
&lt;li&gt;处理可以撤销的职责。&lt;/li&gt;
&lt;li&gt;扩展子类灵活，避免产生累爆炸。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;42-缺点&quot;&gt;4.2 缺点&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;如果最里面的装饰器出错，需要从外面一层一层往里面去查看，多层嵌套导致增加复杂性。&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Sun, 13 Sep 2020 00:22:00 +0000</pubDate>
<dc:creator>小猪爸爸</dc:creator>
<og:description>1. 简介 装饰器模式（Decorator Pattern）：动态地给一个对象添加职责，就增加功能来说，装饰器比生成子类更灵活。 2. 示例 水果店需要给网上客户发货，除了包装之外，需要对特定水果包装</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/father-of-little-pig/p/13622216.html</dc:identifier>
</item>
<item>
<title>Nginx(二): worker 进程处理流程框架 - 等你归去来</title>
<link>http://www.cnblogs.com/yougewe/p/13659987.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yougewe/p/13659987.html</guid>
<description>&lt;p&gt;　　Nginx 启动起来之后，会有几个进程运行：1. master 进程接收用户命令并做出响应; 2. worker 进程负责处理各网络事件，并同时接收来自master的处理协调命令；&lt;/p&gt;
&lt;p&gt;　　master 主要是一控制命令，我们后面再说，而worker则是处理的nginx的核心任务，请求转发、反向代理、负载均衡等工作。所以我们先来啃啃worker这块硬骨头吧！&lt;/p&gt;

&lt;h3&gt;1. worker 主循环&lt;/h3&gt;
&lt;p&gt;　　worker 的启动是被master 操作的，作为一个 fork 出来的进程，它拥有和master一样的内存数据信息。但它的活动范围相对较小，所以它并不会替代master的位置。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;204&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; unix/ngx_process_cycle.c&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt;
ngx_master_process_cycle(ngx_cycle_t &lt;/span&gt;*&lt;span&gt;cycle)
{
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;              *&lt;span&gt;title;
    u_char            &lt;/span&gt;*&lt;span&gt;p;
    size_t             size;
    ngx_int_t          i;
    ngx_uint_t         sigio;
    sigset_t           &lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; itimerval   itv;
    ngx_uint_t         live;
    ngx_msec_t         delay;
    ngx_core_conf_t   &lt;/span&gt;*&lt;span&gt;ccf;

    sigemptyset(&lt;/span&gt;&amp;amp;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;);
    sigaddset(&lt;/span&gt;&amp;amp;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;, SIGCHLD);
    sigaddset(&lt;/span&gt;&amp;amp;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;, SIGALRM);
    sigaddset(&lt;/span&gt;&amp;amp;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;, SIGIO);
    sigaddset(&lt;/span&gt;&amp;amp;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;, SIGINT);
    sigaddset(&lt;/span&gt;&amp;amp;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;, ngx_signal_value(NGX_RECONFIGURE_SIGNAL));
    sigaddset(&lt;/span&gt;&amp;amp;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;, ngx_signal_value(NGX_REOPEN_SIGNAL));
    sigaddset(&lt;/span&gt;&amp;amp;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;, ngx_signal_value(NGX_NOACCEPT_SIGNAL));
    sigaddset(&lt;/span&gt;&amp;amp;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;, ngx_signal_value(NGX_TERMINATE_SIGNAL));
    sigaddset(&lt;/span&gt;&amp;amp;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;, ngx_signal_value(NGX_SHUTDOWN_SIGNAL));
    sigaddset(&lt;/span&gt;&amp;amp;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;, ngx_signal_value(NGX_CHANGEBIN_SIGNAL));

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (sigprocmask(SIG_BLOCK, &amp;amp;&lt;span&gt;set&lt;/span&gt;, NULL) == -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
        ngx_log_error(NGX_LOG_ALERT, cycle&lt;/span&gt;-&amp;gt;&lt;span&gt;log, ngx_errno,
                      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sigprocmask() failed&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }

    sigemptyset(&lt;/span&gt;&amp;amp;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;);


    size &lt;/span&gt;= &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(master_process);

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; ngx_argc; i++&lt;span&gt;) {
        size &lt;/span&gt;+= ngx_strlen(ngx_argv[i]) + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    }

    title &lt;/span&gt;= ngx_pnalloc(cycle-&amp;gt;&lt;span&gt;pool, size);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (title ==&lt;span&gt; NULL) {
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; fatal &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        exit(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
    }

    p &lt;/span&gt;= ngx_cpymem(title, master_process, &lt;span&gt;sizeof&lt;/span&gt;(master_process) - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; ngx_argc; i++&lt;span&gt;) {
        &lt;/span&gt;*p++ = &lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
        p &lt;/span&gt;= ngx_cpystrn(p, (u_char *&lt;span&gt;) ngx_argv[i], size);
    }

    ngx_setproctitle(title);


    ccf &lt;/span&gt;= (ngx_core_conf_t *) ngx_get_conf(cycle-&amp;gt;&lt;span&gt;conf_ctx, ngx_core_module);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 启动之后会主动启动 worker 进程&lt;/span&gt;
    ngx_start_worker_processes(cycle, ccf-&amp;gt;&lt;span&gt;worker_processes,
                               NGX_PROCESS_RESPAWN);
    ngx_start_cache_manager_processes(cycle, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);

    ngx_new_binary &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    delay &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    sigio &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    live &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; ( ;; ) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (delay) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ngx_sigalrm) {
                sigio &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
                delay &lt;/span&gt;*= &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
                ngx_sigalrm &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            }

            ngx_log_debug1(NGX_LOG_DEBUG_EVENT, cycle&lt;/span&gt;-&amp;gt;log, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
                           &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;termination cycle: %M&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, delay);

            itv.it_interval.tv_sec &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            itv.it_interval.tv_usec &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            itv.it_value.tv_sec &lt;/span&gt;= delay / &lt;span&gt;1000&lt;/span&gt;&lt;span&gt;;
            itv.it_value.tv_usec &lt;/span&gt;= (delay % &lt;span&gt;1000&lt;/span&gt; ) * &lt;span&gt;1000&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (setitimer(ITIMER_REAL, &amp;amp;itv, NULL) == -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
                ngx_log_error(NGX_LOG_ALERT, cycle&lt;/span&gt;-&amp;gt;&lt;span&gt;log, ngx_errno,
                              &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;setitimer() failed&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
        }

        ngx_log_debug0(NGX_LOG_DEBUG_EVENT, cycle&lt;/span&gt;-&amp;gt;log, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sigsuspend&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

        sigsuspend(&lt;/span&gt;&amp;amp;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;);

        ngx_time_update();

        ngx_log_debug1(NGX_LOG_DEBUG_EVENT, cycle&lt;/span&gt;-&amp;gt;log, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
                       &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wake up, sigio %i&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, sigio);

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ngx_reap) {
            ngx_reap &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            ngx_log_debug0(NGX_LOG_DEBUG_EVENT, cycle&lt;/span&gt;-&amp;gt;log, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;reap children&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            live &lt;/span&gt;=&lt;span&gt; ngx_reap_children(cycle);
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!live &amp;amp;&amp;amp; (ngx_terminate ||&lt;span&gt; ngx_quit)) {
            ngx_master_process_exit(cycle);
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ngx_terminate) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (delay == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
                delay &lt;/span&gt;= &lt;span&gt;50&lt;/span&gt;&lt;span&gt;;
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (sigio) {
                sigio&lt;/span&gt;--&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
            }

            sigio &lt;/span&gt;= ccf-&amp;gt;worker_processes + &lt;span&gt;2&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; cache processes &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (delay &amp;gt; &lt;span&gt;1000&lt;/span&gt;&lt;span&gt;) {
                ngx_signal_worker_processes(cycle, SIGKILL);
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                ngx_signal_worker_processes(cycle,
                                       ngx_signal_value(NGX_TERMINATE_SIGNAL));
            }

            &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ngx_quit) {
            ngx_signal_worker_processes(cycle,
                                        ngx_signal_value(NGX_SHUTDOWN_SIGNAL));
            ngx_close_listening_sockets(cycle);

            &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ngx_reconfigure) {
            ngx_reconfigure &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ngx_new_binary) {
                ngx_start_worker_processes(cycle, ccf&lt;/span&gt;-&amp;gt;&lt;span&gt;worker_processes,
                                           NGX_PROCESS_RESPAWN);
                ngx_start_cache_manager_processes(cycle, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
                ngx_noaccepting &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

                &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
            }

            ngx_log_error(NGX_LOG_NOTICE, cycle&lt;/span&gt;-&amp;gt;log, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;reconfiguring&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            cycle &lt;/span&gt;=&lt;span&gt; ngx_init_cycle(cycle);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (cycle ==&lt;span&gt; NULL) {
                cycle &lt;/span&gt;= (ngx_cycle_t *&lt;span&gt;) ngx_cycle;
                &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
            }

            ngx_cycle &lt;/span&gt;=&lt;span&gt; cycle;
            ccf &lt;/span&gt;= (ngx_core_conf_t *) ngx_get_conf(cycle-&amp;gt;&lt;span&gt;conf_ctx,
                                                   ngx_core_module);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 收到reconfig命令时，重启worker 进程                                       &lt;/span&gt;
            ngx_start_worker_processes(cycle, ccf-&amp;gt;&lt;span&gt;worker_processes,
                                       NGX_PROCESS_JUST_RESPAWN);
            ngx_start_cache_manager_processes(cycle, &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; allow new processes to start &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            ngx_msleep(&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;);

            live &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
            ngx_signal_worker_processes(cycle,
                                        ngx_signal_value(NGX_SHUTDOWN_SIGNAL));
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ngx_restart) {
            ngx_restart &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 收到重启命令时，传递消息给 worker&lt;/span&gt;
            ngx_start_worker_processes(cycle, ccf-&amp;gt;&lt;span&gt;worker_processes,
                                       NGX_PROCESS_RESPAWN);
            ngx_start_cache_manager_processes(cycle, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
            live &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ngx_reopen) {
            ngx_reopen &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            ngx_log_error(NGX_LOG_NOTICE, cycle&lt;/span&gt;-&amp;gt;log, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;reopening logs&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            ngx_reopen_files(cycle, ccf&lt;/span&gt;-&amp;gt;&lt;span&gt;user);
            ngx_signal_worker_processes(cycle,
                                        ngx_signal_value(NGX_REOPEN_SIGNAL));
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ngx_change_binary) {
            ngx_change_binary &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            ngx_log_error(NGX_LOG_NOTICE, cycle&lt;/span&gt;-&amp;gt;log, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;changing binary&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            ngx_new_binary &lt;/span&gt;=&lt;span&gt; ngx_exec_new_binary(cycle, ngx_argv);
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ngx_noaccept) {
            ngx_noaccept &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            ngx_noaccepting &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
            ngx_signal_worker_processes(cycle,
                                        ngx_signal_value(NGX_SHUTDOWN_SIGNAL));
        }
    }
}


&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt;
ngx_start_worker_processes(ngx_cycle_t &lt;/span&gt;*&lt;span&gt;cycle, ngx_int_t n, ngx_int_t type)
{
    ngx_int_t      i;
    ngx_channel_t  ch;

    ngx_log_error(NGX_LOG_NOTICE, cycle&lt;/span&gt;-&amp;gt;log, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;start worker processes&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

    ngx_memzero(&lt;/span&gt;&amp;amp;ch, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(ngx_channel_t));

    ch.command &lt;/span&gt;=&lt;span&gt; NGX_CMD_OPEN_CHANNEL;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; n 代表worker的进程数， 在 nginx.conf 中配置&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; (i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; n; i++&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 依次启动 worker 进程，实际上就是通过fork进行子进程启动的&lt;/span&gt;
&lt;span&gt;        ngx_spawn_process(cycle, ngx_worker_process_cycle,
                          (&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; *) (intptr_t) i, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;worker process&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, type);

        ch.pid &lt;/span&gt;=&lt;span&gt; ngx_processes[ngx_process_slot].pid;
        ch.slot &lt;/span&gt;=&lt;span&gt; ngx_process_slot;
        ch.fd &lt;/span&gt;= ngx_processes[ngx_process_slot].channel[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];

        ngx_pass_open_channel(cycle, &lt;/span&gt;&amp;amp;&lt;span&gt;ch);
    }
}

ngx_pid_t
ngx_spawn_process(ngx_cycle_t &lt;/span&gt;*cycle, ngx_spawn_proc_pt proc, &lt;span&gt;void&lt;/span&gt; *&lt;span&gt;data,
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *&lt;span&gt;name, ngx_int_t respawn)
{
    u_long     on;
    ngx_pid_t  pid;
    ngx_int_t  s;

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (respawn &amp;gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
        s &lt;/span&gt;=&lt;span&gt; respawn;

    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (s = &lt;span&gt;0&lt;/span&gt;; s &amp;lt; ngx_last_process; s++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ngx_processes[s].pid == -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (s ==&lt;span&gt; NGX_MAX_PROCESSES) {
            ngx_log_error(NGX_LOG_ALERT, cycle&lt;/span&gt;-&amp;gt;log, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
                          &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;no more than %d processes can be spawned&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                          NGX_MAX_PROCESSES);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NGX_INVALID_PID;
        }
    }


    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (respawn !=&lt;span&gt; NGX_PROCESS_DETACHED) {

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Solaris 9 still has no AF_LOCAL &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

        &lt;span&gt;if&lt;/span&gt; (socketpair(AF_UNIX, SOCK_STREAM, &lt;span&gt;0&lt;/span&gt;, ngx_processes[s].channel) == -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
        {
            ngx_log_error(NGX_LOG_ALERT, cycle&lt;/span&gt;-&amp;gt;&lt;span&gt;log, ngx_errno,
                          &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;socketpair() failed while spawning \&quot;%s\&quot;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, name);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NGX_INVALID_PID;
        }

        ngx_log_debug2(NGX_LOG_DEBUG_CORE, cycle&lt;/span&gt;-&amp;gt;log, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
                       &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;channel %d:%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                       ngx_processes[s].channel[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;],
                       ngx_processes[s].channel[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]);

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ngx_nonblocking(ngx_processes[s].channel[&lt;span&gt;0&lt;/span&gt;]) == -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
            ngx_log_error(NGX_LOG_ALERT, cycle&lt;/span&gt;-&amp;gt;&lt;span&gt;log, ngx_errno,
                          ngx_nonblocking_n &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; failed while spawning \&quot;%s\&quot;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                          name);
            ngx_close_channel(ngx_processes[s].channel, cycle&lt;/span&gt;-&amp;gt;&lt;span&gt;log);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NGX_INVALID_PID;
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ngx_nonblocking(ngx_processes[s].channel[&lt;span&gt;1&lt;/span&gt;]) == -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
            ngx_log_error(NGX_LOG_ALERT, cycle&lt;/span&gt;-&amp;gt;&lt;span&gt;log, ngx_errno,
                          ngx_nonblocking_n &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; failed while spawning \&quot;%s\&quot;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                          name);
            ngx_close_channel(ngx_processes[s].channel, cycle&lt;/span&gt;-&amp;gt;&lt;span&gt;log);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NGX_INVALID_PID;
        }

        on &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ioctl(ngx_processes[s].channel[&lt;span&gt;0&lt;/span&gt;], FIOASYNC, &amp;amp;on) == -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
            ngx_log_error(NGX_LOG_ALERT, cycle&lt;/span&gt;-&amp;gt;&lt;span&gt;log, ngx_errno,
                          &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ioctl(FIOASYNC) failed while spawning \&quot;%s\&quot;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, name);
            ngx_close_channel(ngx_processes[s].channel, cycle&lt;/span&gt;-&amp;gt;&lt;span&gt;log);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NGX_INVALID_PID;
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (fcntl(ngx_processes[s].channel[&lt;span&gt;0&lt;/span&gt;], F_SETOWN, ngx_pid) == -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
            ngx_log_error(NGX_LOG_ALERT, cycle&lt;/span&gt;-&amp;gt;&lt;span&gt;log, ngx_errno,
                          &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fcntl(F_SETOWN) failed while spawning \&quot;%s\&quot;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, name);
            ngx_close_channel(ngx_processes[s].channel, cycle&lt;/span&gt;-&amp;gt;&lt;span&gt;log);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NGX_INVALID_PID;
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (fcntl(ngx_processes[s].channel[&lt;span&gt;0&lt;/span&gt;], F_SETFD, FD_CLOEXEC) == -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
            ngx_log_error(NGX_LOG_ALERT, cycle&lt;/span&gt;-&amp;gt;&lt;span&gt;log, ngx_errno,
                          &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fcntl(FD_CLOEXEC) failed while spawning \&quot;%s\&quot;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                           name);
            ngx_close_channel(ngx_processes[s].channel, cycle&lt;/span&gt;-&amp;gt;&lt;span&gt;log);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NGX_INVALID_PID;
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (fcntl(ngx_processes[s].channel[&lt;span&gt;1&lt;/span&gt;], F_SETFD, FD_CLOEXEC) == -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
            ngx_log_error(NGX_LOG_ALERT, cycle&lt;/span&gt;-&amp;gt;&lt;span&gt;log, ngx_errno,
                          &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fcntl(FD_CLOEXEC) failed while spawning \&quot;%s\&quot;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                           name);
            ngx_close_channel(ngx_processes[s].channel, cycle&lt;/span&gt;-&amp;gt;&lt;span&gt;log);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NGX_INVALID_PID;
        }

        ngx_channel &lt;/span&gt;= ngx_processes[s].channel[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];

    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        ngx_processes[s].channel[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;] = -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        ngx_processes[s].channel[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] = -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    }

    ngx_process_slot &lt;/span&gt;=&lt;span&gt; s;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; fork 出子进程出来&lt;/span&gt;
    pid =&lt;span&gt; fork();

    &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (pid) {

    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;:
        ngx_log_error(NGX_LOG_ALERT, cycle&lt;/span&gt;-&amp;gt;&lt;span&gt;log, ngx_errno,
                      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fork() failed while spawning \&quot;%s\&quot;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, name);
        ngx_close_channel(ngx_processes[s].channel, cycle&lt;/span&gt;-&amp;gt;&lt;span&gt;log);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NGX_INVALID_PID;

    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;:
        ngx_parent &lt;/span&gt;=&lt;span&gt; ngx_pid;
        ngx_pid &lt;/span&gt;=&lt;span&gt; ngx_getpid();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 子进程将调用传入的处理方法，worker 则会进入循环处理事件逻辑中
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 即 ngx_worker_process_cycle 循环&lt;/span&gt;
&lt;span&gt;        proc(cycle, data);
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
    }

    ngx_log_error(NGX_LOG_NOTICE, cycle&lt;/span&gt;-&amp;gt;log, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;start %s %P&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, name, pid);

    ngx_processes[s].pid &lt;/span&gt;=&lt;span&gt; pid;
    ngx_processes[s].exited &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (respawn &amp;gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; pid;
    }

    ngx_processes[s].proc &lt;/span&gt;=&lt;span&gt; proc;
    ngx_processes[s].data &lt;/span&gt;=&lt;span&gt; data;
    ngx_processes[s].name &lt;/span&gt;=&lt;span&gt; name;
    ngx_processes[s].exiting &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (respawn) {

    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; NGX_PROCESS_NORESPAWN:
        ngx_processes[s].respawn &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        ngx_processes[s].just_spawn &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        ngx_processes[s].detached &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; NGX_PROCESS_JUST_SPAWN:
        ngx_processes[s].respawn &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        ngx_processes[s].just_spawn &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        ngx_processes[s].detached &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; NGX_PROCESS_RESPAWN:
        ngx_processes[s].respawn &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        ngx_processes[s].just_spawn &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        ngx_processes[s].detached &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; NGX_PROCESS_JUST_RESPAWN:
        ngx_processes[s].respawn &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        ngx_processes[s].just_spawn &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        ngx_processes[s].detached &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; NGX_PROCESS_DETACHED:
        ngx_processes[s].respawn &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        ngx_processes[s].just_spawn &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        ngx_processes[s].detached &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (s ==&lt;span&gt; ngx_last_process) {
        ngx_last_process&lt;/span&gt;++&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; pid;
}


&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; os/unix/ngx_process_cycle.c
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; worker 主循环服务&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt;
ngx_worker_process_cycle(ngx_cycle_t &lt;/span&gt;*cycle, &lt;span&gt;void&lt;/span&gt; *&lt;span&gt;data)
{
    ngx_int_t worker &lt;/span&gt;=&lt;span&gt; (intptr_t) data;

    ngx_process &lt;/span&gt;=&lt;span&gt; NGX_PROCESS_WORKER;
    ngx_worker &lt;/span&gt;=&lt;span&gt; worker;

    ngx_worker_process_init(cycle, worker);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 进程标题 worker process&lt;/span&gt;
    ngx_setproctitle(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;worker process&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 死循环处理 worker 事务&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt;&lt;span&gt; ( ;; ) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 大部分逻辑在接受 master 传递过来折命令&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ngx_exiting) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ngx_event_no_timers_left() ==&lt;span&gt; NGX_OK) {
                ngx_log_error(NGX_LOG_NOTICE, cycle&lt;/span&gt;-&amp;gt;log, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;exiting&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                ngx_worker_process_exit(cycle);
            }
        }

        ngx_log_debug0(NGX_LOG_DEBUG_EVENT, cycle&lt;/span&gt;-&amp;gt;log, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;worker cycle&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这是其核心任务，检测事件、处理事件&lt;/span&gt;
&lt;span&gt;        ngx_process_events_and_timers(cycle);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 大部分逻辑在接受 master 传递过来折命令&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ngx_terminate) {
            ngx_log_error(NGX_LOG_NOTICE, cycle&lt;/span&gt;-&amp;gt;log, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;exiting&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            ngx_worker_process_exit(cycle);
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 退出事件&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ngx_quit) {
            ngx_quit &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            ngx_log_error(NGX_LOG_NOTICE, cycle&lt;/span&gt;-&amp;gt;log, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
                          &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gracefully shutting down&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            ngx_setproctitle(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;worker process is shutting down&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;ngx_exiting) {
                ngx_exiting &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
                ngx_set_shutdown_timer(cycle);
                ngx_close_listening_sockets(cycle);
                ngx_close_idle_connections(cycle);
            }
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; reopen 事件&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ngx_reopen) {
            ngx_reopen &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            ngx_log_error(NGX_LOG_NOTICE, cycle&lt;/span&gt;-&amp;gt;log, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;reopening logs&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            ngx_reopen_files(cycle, &lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面就是nginx worker的主要功能体现, 使用一个死循环提供服务. 有很多是接口master命令进行响应的逻辑, 咱们忽略其对master命令的响应，观其业务核心: ngx_process_events_and_timers .&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; event/ngx_event.c
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; nginx worker 处理io事件和超时队列流程&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt;
ngx_process_events_and_timers(ngx_cycle_t &lt;/span&gt;*&lt;span&gt;cycle)
{
    ngx_uint_t  flags;
    ngx_msec_t  timer, delta;

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ngx_timer_resolution) {
        timer &lt;/span&gt;=&lt;span&gt; NGX_TIMER_INFINITE;
        flags &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取timer&lt;/span&gt;
        timer =&lt;span&gt; ngx_event_find_timer();
        flags &lt;/span&gt;=&lt;span&gt; NGX_UPDATE_TIME;

&lt;/span&gt;&lt;span&gt;#if&lt;/span&gt; (NGX_WIN32)

        &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; handle signals from master in case of network inactivity &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

        &lt;span&gt;if&lt;/span&gt; (timer == NGX_TIMER_INFINITE || timer &amp;gt; &lt;span&gt;500&lt;/span&gt;&lt;span&gt;) {
            timer &lt;/span&gt;= &lt;span&gt;500&lt;/span&gt;&lt;span&gt;;
        }

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;&lt;span&gt;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用锁进行 tcp 监听
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 该锁基于 shm 实现，多进程共享内存&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ngx_use_accept_mutex) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; disabled 用于优化监听锁竞争，直到 ngx_accept_disabled 小于0&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (ngx_accept_disabled &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
            ngx_accept_disabled&lt;/span&gt;--&lt;span&gt;;

        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过 shm 获取一个进程锁，没抢到锁则直接返回了
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取到accept锁之后，其会注册 read 事件监听，所以，当其返回后，则意味着数据就绪&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (ngx_trylock_accept_mutex(cycle) ==&lt;span&gt; NGX_ERROR) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取到锁，设置 flags&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ngx_accept_mutex_held) {
                flags &lt;/span&gt;|=&lt;span&gt; NGX_POST_EVENTS;

            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (timer ==&lt;span&gt; NGX_TIMER_INFINITE
                    &lt;/span&gt;|| timer &amp;gt;&lt;span&gt; ngx_accept_mutex_delay)
                {
                    timer &lt;/span&gt;=&lt;span&gt; ngx_accept_mutex_delay;
                }
            }
        }
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; post 事件队列不为空，则触发事件处理&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (!ngx_queue_empty(&amp;amp;&lt;span&gt;ngx_posted_next_events)) {
        ngx_event_move_posted_next(cycle);
        timer &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    }

    delta &lt;/span&gt;=&lt;span&gt; ngx_current_msec;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 处理事件 ngx_event_actions.process_events, 将会进行阻塞等待
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 此处的 ngx_event_actions 由系统决定如何初始化，如 linux 下
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用 event/modules/ngx_epoll_module.c 中的定义 ngx_event_actions = ngx_epoll_module_ctx.actions; 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 而其他系统则另外决定, 总体来说可能有以下几种可能
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ngx_devpoll_module_ctx.actions;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ngx_epoll_module_ctx.actions;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ngx_eventport_module_ctx.actions;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ngx_iocp_module_ctx.actions;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ngx_kqueue_module_ctx.actions;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ngx_select_module_ctx.actions;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ngx_poll_module_ctx.actions;&lt;/span&gt;
    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * 其定义样例如下: 
        static ngx_event_module_t  ngx_select_module_ctx = {
            &amp;amp;select_name,
            NULL,                                  /* create configuration &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            ngx_select_init_conf,                  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; init configuration &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

            {
                ngx_select_add_event,              &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; add an event &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
                ngx_select_del_event,              &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; delete an event &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
                ngx_select_add_event,              &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; enable an event &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
                ngx_select_del_event,              &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; disable an event &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
                NULL,                              &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; add an connection &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
                NULL,                              &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; delete an connection &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
                NULL,                              &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; trigger a notify &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
                ngx_select_process_events,         &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; process the events &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
                ngx_select_init,                   &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; init the events &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
                ngx_select_done                    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; done the events &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            }

        };
    &lt;/span&gt;*/&lt;span&gt;
    (&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt;) ngx_process_events(cycle, timer, flags);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 计算耗时&lt;/span&gt;
    delta = ngx_current_msec -&lt;span&gt; delta;

    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, cycle&lt;/span&gt;-&amp;gt;log, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
                   &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;timer delta: %M&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, delta);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 处理 posted 事件，它存放在 ngx_posted_accept_events 队列中&lt;/span&gt;
    ngx_event_process_posted(cycle, &amp;amp;&lt;span&gt;ngx_posted_accept_events);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 处理完事件后，释放锁&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ngx_accept_mutex_held) {
        ngx_shmtx_unlock(&lt;/span&gt;&amp;amp;&lt;span&gt;ngx_accept_mutex);
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 处理超时的任务&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (delta) {
        ngx_event_expire_timers();
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 读写事件将会被添加到 ngx_posted_events 队列中&lt;/span&gt;
    ngx_event_process_posted(cycle, &amp;amp;&lt;span&gt;ngx_posted_events);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　以上也就是nginx worker的主要功能框架了:&lt;/p&gt;
&lt;p&gt;　　　　1. 先通过shm获取tcp的监听锁, 避免socket惊群;&lt;br/&gt;　　　　2. 获取到锁的worker进程, 将会注册accept的read事件;&lt;br/&gt;　　　　3. 如果有 ngx_posted_next_events 队列, 则先处理其队列请求;&lt;br/&gt;　　　　4. 根据系统类型调用网络io模块, select 机制接收io事件;&lt;br/&gt;　　　　5. 接入accept事件后, 释放accept锁(基于shm);&lt;br/&gt;　　　　6. 处理过期超时队列;&lt;br/&gt;　　　　7. 处理普通的已接入的socket的读写事件;&lt;/p&gt;
&lt;p&gt;　　一次处理往往只会处理部分事件, 比如可能只是处理了 accept, read 则需要在下一次或n次之后才会处理, 这也是异步机制非阻塞的体现.&lt;/p&gt;
&lt;p&gt;　　下面我先给到一个整个worker的工作时序图, 以便有个整体的认知.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/830731/202009/830731-20200913073930269-1883511731.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　接下来我们从几个点依次简单看看 nginx 是如何处理各细节的.&lt;/p&gt;

&lt;h3&gt;2. 获取accept锁及注册accept事件&lt;/h3&gt;
&lt;p&gt;　　由于nginx是基于多进程实现的并发处理, 那么各进程必然都需要监听相同的端口数据, 如果没有锁控制, 则当有事件到达时, 必然导致各进程同时被唤醒, 即所谓的惊群. 所以, nginx 提供了一个锁机制, 使同一时刻只有一个进程在监听某端口, 从而避免竞争.  实现方式是基于共享内存 shm 实现.(如果是多线程方式会更简单哟)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;76&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; event/ngx_event_accept.c&lt;/span&gt;
&lt;span&gt;ngx_int_t
ngx_trylock_accept_mutex(ngx_cycle_t &lt;/span&gt;*&lt;span&gt;cycle)
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 首先获取shm锁, 通过 shm 实现进程数据共享&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (ngx_shmtx_trylock(&amp;amp;&lt;span&gt;ngx_accept_mutex)) {

        ngx_log_debug0(NGX_LOG_DEBUG_EVENT, cycle&lt;/span&gt;-&amp;gt;log, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
                       &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;accept mutex locked&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果上一次就是自己执行的accept操作, 则直接返回
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 否则需要重新注册accept监听&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (ngx_accept_mutex_held &amp;amp;&amp;amp; ngx_accept_events == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NGX_OK;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注册 accept 事件&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (ngx_enable_accept_events(cycle) ==&lt;span&gt; NGX_ERROR) {
            ngx_shmtx_unlock(&lt;/span&gt;&amp;amp;&lt;span&gt;ngx_accept_mutex);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NGX_ERROR;
        }

        ngx_accept_events &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        ngx_accept_mutex_held &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NGX_OK;
    }

    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, cycle&lt;/span&gt;-&amp;gt;log, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
                   &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;accept mutex lock failed: %ui&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, ngx_accept_mutex_held);

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ngx_accept_mutex_held) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果没有获取到锁，则将之前注册的 accept 事件取消，避免惊群&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (ngx_disable_accept_events(cycle, &lt;span&gt;0&lt;/span&gt;) ==&lt;span&gt; NGX_ERROR) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NGX_ERROR;
        }

        ngx_accept_mutex_held &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 不管有没有获取到锁, 都会执行后续的逻辑, 因为除了 accept 外, 还有read/write事件需要处理&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; NGX_OK;
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; core/ngx_shmtx.c, 获取锁，锁的值为当前进程id&lt;/span&gt;
&lt;span&gt;ngx_uint_t
ngx_shmtx_trylock(ngx_shmtx_t &lt;/span&gt;*&lt;span&gt;mtx)
{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (*mtx-&amp;gt;&lt;span&gt;lock&lt;/span&gt; == &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; ngx_atomic_cmp_set(mtx-&amp;gt;&lt;span&gt;lock&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, ngx_pid));
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注册 accept 事件监听
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; event/ngx_event_accept.c&lt;/span&gt;
&lt;span&gt;ngx_int_t
ngx_enable_accept_events(ngx_cycle_t &lt;/span&gt;*&lt;span&gt;cycle)
{
    ngx_uint_t         i;
    ngx_listening_t   &lt;/span&gt;*&lt;span&gt;ls;
    ngx_connection_t  &lt;/span&gt;*&lt;span&gt;c;

    ls &lt;/span&gt;= cycle-&amp;gt;&lt;span&gt;listening.elts;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; cycle-&amp;gt;listening.nelts; i++&lt;span&gt;) {

        c &lt;/span&gt;=&lt;span&gt; ls[i].connection;

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (c == NULL || c-&amp;gt;read-&amp;gt;&lt;span&gt;active) {
            &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注册accept事件，READ ?
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 交由 ngx_event_actions.add 处理, 实际运行由系统决定, 如 ngx_select_add_event&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (ngx_add_event(c-&amp;gt;read, NGX_READ_EVENT, &lt;span&gt;0&lt;/span&gt;) ==&lt;span&gt; NGX_ERROR) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NGX_ERROR;
        }
    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NGX_OK;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; event/module/ngx_select_module.c
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注册一个 io 事件监听, fd_set&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt;&lt;span&gt; ngx_int_t
ngx_select_add_event(ngx_event_t &lt;/span&gt;*ev, ngx_int_t &lt;span&gt;event&lt;/span&gt;&lt;span&gt;, ngx_uint_t flags)
{
    ngx_connection_t  &lt;/span&gt;*&lt;span&gt;c;

    c &lt;/span&gt;= ev-&amp;gt;&lt;span&gt;data;

    ngx_log_debug2(NGX_LOG_DEBUG_EVENT, ev&lt;/span&gt;-&amp;gt;log, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
                   &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;select add event fd:%d ev:%i&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, c-&amp;gt;fd, &lt;span&gt;event&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ev-&amp;gt;index !=&lt;span&gt; NGX_INVALID_INDEX) {
        ngx_log_error(NGX_LOG_ALERT, ev&lt;/span&gt;-&amp;gt;log, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
                      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;select event fd:%d ev:%i is already set&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, c-&amp;gt;fd, &lt;span&gt;event&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NGX_OK;
    }

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((&lt;span&gt;event&lt;/span&gt; == NGX_READ_EVENT &amp;amp;&amp;amp; ev-&amp;gt;&lt;span&gt;write)
        &lt;/span&gt;|| (&lt;span&gt;event&lt;/span&gt; == NGX_WRITE_EVENT &amp;amp;&amp;amp; !ev-&amp;gt;&lt;span&gt;write))
    {
        ngx_log_error(NGX_LOG_ALERT, ev&lt;/span&gt;-&amp;gt;log, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
                      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;invalid select %s event fd:%d ev:%i&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                      ev&lt;/span&gt;-&amp;gt;write ? &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;write&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;read&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, c-&amp;gt;fd, &lt;span&gt;event&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NGX_ERROR;
    }

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;event&lt;/span&gt; ==&lt;span&gt; NGX_READ_EVENT) {
        FD_SET(c&lt;/span&gt;-&amp;gt;fd, &amp;amp;&lt;span&gt;master_read_fd_set);

    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;event&lt;/span&gt; ==&lt;span&gt; NGX_WRITE_EVENT) {
        FD_SET(c&lt;/span&gt;-&amp;gt;fd, &amp;amp;&lt;span&gt;master_write_fd_set);
    }

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (max_fd != -&lt;span&gt;1&lt;/span&gt; &amp;amp;&amp;amp; max_fd &amp;lt; c-&amp;gt;&lt;span&gt;fd) {
        max_fd &lt;/span&gt;= c-&amp;gt;&lt;span&gt;fd;
    }

    ev&lt;/span&gt;-&amp;gt;active = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

    event_index[nevents] &lt;/span&gt;=&lt;span&gt; ev;
    ev&lt;/span&gt;-&amp;gt;index =&lt;span&gt; nevents;
    nevents&lt;/span&gt;++&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NGX_OK;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　主要就是shm的应用，以及fd_set处理。&lt;/p&gt;

&lt;h3&gt;3. 通用处理队列实现&lt;/h3&gt;
&lt;p&gt;　　在 ngx_process_events_and_timers 中, 我们看到, 在io事件返回之后, 都会多次进行队列处理. 它们的不同仅在于 队列不同. 那么, 它是如何实现这个处理过程的呢?&lt;/p&gt;
&lt;p&gt;　　我们分两块来看这事: 1. 队列的数据结构; 2. 执行队列任务; so... 就这样呗.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1. 队列数据结构
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 额, 两个循环嵌套的指针就是其结构了&lt;/span&gt;
typedef &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; ngx_queue_s  ngx_queue_t;
&lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; ngx_queue_s {
    ngx_queue_t  &lt;/span&gt;*&lt;span&gt;prev;
    ngx_queue_t  &lt;/span&gt;*&lt;span&gt;next;
};
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 实际上, 此处还会有一个强制类型转换 ngx_event_t&lt;/span&gt;
typedef &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; ngx_event_s           ngx_event_t;
&lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; ngx_event_s {
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;            *&lt;span&gt;data;

    unsigned         write:&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

    unsigned         accept:&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; used to detect the stale events in kqueue and epoll &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    unsigned         instance:&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
     * the event was passed or would be passed to a kernel;
     * in aio mode - operation was posted.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    unsigned         active:&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

    unsigned         disabled:&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; the ready event; in aio mode 0 means that no operation can be posted &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    unsigned         ready:&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

    unsigned         oneshot:&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; aio operation is complete &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    unsigned         complete:&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

    unsigned         eof:&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    unsigned         error:&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

    unsigned         timedout:&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    unsigned         timer_set:&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

    unsigned         delayed:&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

    unsigned         deferred_accept:&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; the pending eof reported by kqueue, epoll or in aio chain operation &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    unsigned         pending_eof:&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

    unsigned         posted:&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

    unsigned         closed:&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; to test on worker exit &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    unsigned         channel:&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    unsigned         resolver:&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

    unsigned         cancelable:&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;#if&lt;/span&gt; (NGX_HAVE_KQUEUE)&lt;span&gt;
    unsigned         kq_vnode:&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; the pending errno reported by kqueue &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt;&lt;span&gt;              kq_errno;
&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
     * kqueue only:
     *   accept:     number of sockets that wait to be accepted
     *   read:       bytes to read when event is ready
     *               or lowat when event is set with NGX_LOWAT_EVENT flag
     *   write:      available space in buffer when event is ready
     *               or lowat when event is set with NGX_LOWAT_EVENT flag
     *
     * iocp: TODO
     *
     * otherwise:
     *   accept:     1 if accept many, 0 otherwise
     *   read:       bytes to read when event is ready, -1 if not known
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

    &lt;span&gt;int&lt;/span&gt;&lt;span&gt;              available;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这个handler 比较重要, 它决定了本事件如何进行处理&lt;/span&gt;
&lt;span&gt;    ngx_event_handler_pt  handler;


&lt;/span&gt;&lt;span&gt;#if&lt;/span&gt; (NGX_HAVE_IOCP)&lt;span&gt;
    ngx_event_ovlp_t ovlp;
&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;&lt;span&gt;

    ngx_uint_t       index;

    ngx_log_t       &lt;/span&gt;*&lt;span&gt;log;

    ngx_rbtree_node_t   timer;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; queue 则是存放整个队列所有数据的地方&lt;/span&gt;
    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; the posted queue &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    ngx_queue_t      queue;

&lt;/span&gt;&lt;span&gt;#if&lt;/span&gt; 0

    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; the threads support &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
     * the event thread context, we store it here
     * if $(CC) does not understand __thread declaration
     * and pthread_getspecific() is too costly
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

    &lt;span&gt;void&lt;/span&gt;            *&lt;span&gt;thr_ctx;

&lt;/span&gt;&lt;span&gt;#if&lt;/span&gt; (NGX_EVENT_T_PADDING)

    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; event should not cross cache line in SMP &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

    uint32_t         padding[NGX_EVENT_T_PADDING];
&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;
&lt;span&gt;#endif&lt;/span&gt;&lt;span&gt;
};

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 有了数据结构支持后, 要处理队列就简单了, 只需遍历数据即可    
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; event/ngx_event_posted.c&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt;
ngx_event_process_posted(ngx_cycle_t &lt;/span&gt;*cycle, ngx_queue_t *&lt;span&gt;posted)
{
    ngx_queue_t  &lt;/span&gt;*&lt;span&gt;q;
    ngx_event_t  &lt;/span&gt;*&lt;span&gt;ev;

    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (!&lt;span&gt;ngx_queue_empty(posted)) {

        q &lt;/span&gt;=&lt;span&gt; ngx_queue_head(posted);
        ev &lt;/span&gt;=&lt;span&gt; ngx_queue_data(q, ngx_event_t, queue);

        ngx_log_debug1(NGX_LOG_DEBUG_EVENT, cycle&lt;/span&gt;-&amp;gt;log, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
                      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;posted event %p&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, ev);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 先删除事件，再进行处理， 这在单进程单线程下没有问题的哟&lt;/span&gt;
&lt;span&gt;        ngx_delete_posted_event(ev);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用 event 对应的handler 处理事件
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 所以核心在于这个 handler 的定义&lt;/span&gt;
        ev-&amp;gt;&lt;span&gt;handler(ev);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　以上的实现, 虽然是面向过程语言写的, 但因为有 struct 数据类型的支持, 实际上也是面向对象的概念呢.&lt;/p&gt;

&lt;h3&gt;4. io事件的监听实现&lt;/h3&gt;
&lt;p&gt;　　作为一个web服务器或者反向代理服务器, 其核心必然是网络io事件的处理. nginx 会根据不同的操作系统支持, 选择不同的io模型进行io事件的监听, 充分发挥系统的性能. 这也是其制胜之道吧. 具体如何确定哪种类型, 实际上可以在进行编译的时候, 获取系统变量来断定. (稍详细的说明, 见前面代码注释)&lt;/p&gt;
&lt;p&gt;　　我们以 select 的实现来看看细节:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;88&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; event/module/ngx_select_module.c
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; io 事件监听&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt;&lt;span&gt; ngx_int_t
ngx_select_process_events(ngx_cycle_t &lt;/span&gt;*&lt;span&gt;cycle, ngx_msec_t timer,
    ngx_uint_t flags)
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;                ready, nready;
    ngx_err_t          err;
    ngx_uint_t         i, found;
    ngx_event_t       &lt;/span&gt;*&lt;span&gt;ev;
    ngx_queue_t       &lt;/span&gt;*&lt;span&gt;queue;
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; timeval     tv, *&lt;span&gt;tp;
    ngx_connection_t  &lt;/span&gt;*&lt;span&gt;c;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取 max_fd, 系统传值需要&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (max_fd == -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; nevents; i++&lt;span&gt;) {
            c &lt;/span&gt;= event_index[i]-&amp;gt;&lt;span&gt;data;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (max_fd &amp;lt; c-&amp;gt;&lt;span&gt;fd) {
                max_fd &lt;/span&gt;= c-&amp;gt;&lt;span&gt;fd;
            }
        }

        ngx_log_debug1(NGX_LOG_DEBUG_EVENT, cycle&lt;/span&gt;-&amp;gt;log, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
                       &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;change max_fd: %i&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, max_fd);
    }

&lt;/span&gt;&lt;span&gt;#if&lt;/span&gt; (NGX_DEBUG)
    &lt;span&gt;if&lt;/span&gt; (cycle-&amp;gt;log-&amp;gt;log_level &amp;amp;&lt;span&gt; NGX_LOG_DEBUG_ALL) {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; nevents; i++&lt;span&gt;) {
            ev &lt;/span&gt;=&lt;span&gt; event_index[i];
            c &lt;/span&gt;= ev-&amp;gt;&lt;span&gt;data;
            ngx_log_debug2(NGX_LOG_DEBUG_EVENT, cycle&lt;/span&gt;-&amp;gt;log, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
                           &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;select event: fd:%d wr:%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, c-&amp;gt;fd, ev-&amp;gt;&lt;span&gt;write);
        }

        ngx_log_debug1(NGX_LOG_DEBUG_EVENT, cycle&lt;/span&gt;-&amp;gt;log, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
                       &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;max_fd: %i&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, max_fd);
    }
&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

    &lt;span&gt;if&lt;/span&gt; (timer ==&lt;span&gt; NGX_TIMER_INFINITE) {
        tp &lt;/span&gt;=&lt;span&gt; NULL;

    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        tv.tv_sec &lt;/span&gt;= (&lt;span&gt;long&lt;/span&gt;) (timer / &lt;span&gt;1000&lt;/span&gt;&lt;span&gt;);
        tv.tv_usec &lt;/span&gt;= (&lt;span&gt;long&lt;/span&gt;) ((timer % &lt;span&gt;1000&lt;/span&gt;) * &lt;span&gt;1000&lt;/span&gt;&lt;span&gt;);
        tp &lt;/span&gt;= &amp;amp;&lt;span&gt;tv;
    }

    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, cycle&lt;/span&gt;-&amp;gt;log, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
                   &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;select timer: %M&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, timer);

    work_read_fd_set &lt;/span&gt;=&lt;span&gt; master_read_fd_set;
    work_write_fd_set &lt;/span&gt;=&lt;span&gt; master_write_fd_set;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在此处交由内核进行处理网络事件，epoll 机制，至少有一个事件到来时返回
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; tp 代表是否要超时退出&lt;/span&gt;
    ready = &lt;span&gt;select&lt;/span&gt;(max_fd + &lt;span&gt;1&lt;/span&gt;, &amp;amp;work_read_fd_set, &amp;amp;&lt;span&gt;work_write_fd_set, NULL, tp);

    err &lt;/span&gt;= (ready == -&lt;span&gt;1&lt;/span&gt;) ? ngx_errno : &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (flags &amp;amp; NGX_UPDATE_TIME ||&lt;span&gt; ngx_event_timer_alarm) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 事件结束后，先尝试更新gmtTime 时间信息&lt;/span&gt;
&lt;span&gt;        ngx_time_update();
    }

    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, cycle&lt;/span&gt;-&amp;gt;log, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
                   &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;select ready %d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, ready);

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (err) {
        ngx_uint_t  level;

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (err ==&lt;span&gt; NGX_EINTR) {

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ngx_event_timer_alarm) {
                ngx_event_timer_alarm &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NGX_OK;
            }

            level &lt;/span&gt;=&lt;span&gt; NGX_LOG_INFO;

        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            level &lt;/span&gt;=&lt;span&gt; NGX_LOG_ALERT;
        }

        ngx_log_error(level, cycle&lt;/span&gt;-&amp;gt;log, err, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;select() failed&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (err ==&lt;span&gt; NGX_EBADF) {
            ngx_select_repair_fd_sets(cycle);
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NGX_ERROR;
    }

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ready == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (timer !=&lt;span&gt; NGX_TIMER_INFINITE) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NGX_OK;
        }

        ngx_log_error(NGX_LOG_ALERT, cycle&lt;/span&gt;-&amp;gt;log, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
                      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;select() returned no events without timeout&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NGX_ERROR;
    }

    nready &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 遍历所有事件&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; (i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; nevents; i++&lt;span&gt;) {
        ev &lt;/span&gt;=&lt;span&gt; event_index[i];
        c &lt;/span&gt;= ev-&amp;gt;&lt;span&gt;data;
        found &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 写事件处理&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (ev-&amp;gt;&lt;span&gt;write) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (FD_ISSET(c-&amp;gt;fd, &amp;amp;&lt;span&gt;work_write_fd_set)) {
                found &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
                ngx_log_debug1(NGX_LOG_DEBUG_EVENT, cycle&lt;/span&gt;-&amp;gt;log, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
                               &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;select write %d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, c-&amp;gt;&lt;span&gt;fd);
            }

        } 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 读或accept事件&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (FD_ISSET(c-&amp;gt;fd, &amp;amp;&lt;span&gt;work_read_fd_set)) {
                found &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
                ngx_log_debug1(NGX_LOG_DEBUG_EVENT, cycle&lt;/span&gt;-&amp;gt;log, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
                               &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;select read %d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, c-&amp;gt;&lt;span&gt;fd);
            }
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 读写就绪事件 found 都为1&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (found) {
            ev&lt;/span&gt;-&amp;gt;ready = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
            ev&lt;/span&gt;-&amp;gt;available = -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果是 accept 事件则取 ngx_posted_accept_events 队列
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 否则取 ngx_posted_events 队列&lt;/span&gt;
            queue = ev-&amp;gt;accept ? &amp;amp;&lt;span&gt;ngx_posted_accept_events
                               : &lt;/span&gt;&amp;amp;&lt;span&gt;ngx_posted_events;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将事件插入到相应队列尾部&lt;/span&gt;
&lt;span&gt;            ngx_post_event(ev, queue);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 有效就绪事件+1&lt;/span&gt;
            nready++&lt;span&gt;;
        }
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果两个值不相等，则需要修正下&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (ready !=&lt;span&gt; nready) {
        ngx_log_error(NGX_LOG_ALERT, cycle&lt;/span&gt;-&amp;gt;log, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
                      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;select ready != events: %d:%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, ready, nready);

        ngx_select_repair_fd_sets(cycle);
    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NGX_OK;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面就是io事件的处理的了, 因为是 select 的实现, 所以调用系统的 select() 函数即可接收网络事件了. 具体能获取哪些事件, 实际上前面的工作已经决定了. 此处只是一个执行者的角色. 它是否高效, 则是取决于操作系统的io模型是否高效了. 有兴趣的同学可以看下 epoll 的实现.&lt;/p&gt;

&lt;h3&gt;5. accept 事件的处理&lt;/h3&gt;
&lt;p&gt;　　当系统发现有新的网络连接进来时, 会生成一个accept的事件, 给到应用. nginx 接收到accept事件后, 会放入 ngx_posted_accept_events 中, 然后调用通用队列处理方法处理队列. 此处的 handler 是 ngx_event_accept .  其核心工作就是建立新的socket连接, 以便后续读写.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;128&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; event/ngx_event_accept.c
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; accept 事件处理入口&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt;
ngx_event_accept(ngx_event_t &lt;/span&gt;*&lt;span&gt;ev)
{
    socklen_t          socklen;
    ngx_err_t          err;
    ngx_log_t         &lt;/span&gt;*&lt;span&gt;log;
    ngx_uint_t         level;
    ngx_socket_t       s;
    ngx_event_t       &lt;/span&gt;*rev, *&lt;span&gt;wev;
    ngx_sockaddr_t     sa;
    ngx_listening_t   &lt;/span&gt;*&lt;span&gt;ls;
    ngx_connection_t  &lt;/span&gt;*c, *&lt;span&gt;lc;
    ngx_event_conf_t  &lt;/span&gt;*&lt;span&gt;ecf;
&lt;/span&gt;&lt;span&gt;#if&lt;/span&gt; (NGX_HAVE_ACCEPT4)
    &lt;span&gt;static&lt;/span&gt; ngx_uint_t  use_accept4 = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

    &lt;span&gt;if&lt;/span&gt; (ev-&amp;gt;&lt;span&gt;timedout) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ngx_enable_accept_events((ngx_cycle_t *) ngx_cycle) !=&lt;span&gt; NGX_OK) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }

        ev&lt;/span&gt;-&amp;gt;timedout = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取配置信息&lt;/span&gt;
    ecf = ngx_event_get_conf(ngx_cycle-&amp;gt;&lt;span&gt;conf_ctx, ngx_event_core_module);

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!(ngx_event_flags &amp;amp;&lt;span&gt; NGX_USE_KQUEUE_EVENT)) {
        ev&lt;/span&gt;-&amp;gt;available = ecf-&amp;gt;&lt;span&gt;multi_accept;
    }

    lc &lt;/span&gt;= ev-&amp;gt;&lt;span&gt;data;
    ls &lt;/span&gt;= lc-&amp;gt;&lt;span&gt;listening;
    ev&lt;/span&gt;-&amp;gt;ready = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

    ngx_log_debug2(NGX_LOG_DEBUG_EVENT, ev&lt;/span&gt;-&amp;gt;log, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
                   &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;accept on %V, ready: %d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &amp;amp;ls-&amp;gt;addr_text, ev-&amp;gt;&lt;span&gt;available);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 循环处理socket数据&lt;/span&gt;
    &lt;span&gt;do&lt;/span&gt;&lt;span&gt; {
        socklen &lt;/span&gt;= &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(ngx_sockaddr_t);

&lt;/span&gt;&lt;span&gt;#if&lt;/span&gt; (NGX_HAVE_ACCEPT4)
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (use_accept4) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用accept() 方法接入socket连接&lt;/span&gt;
            s = accept4(lc-&amp;gt;fd, &amp;amp;sa.sockaddr, &amp;amp;&lt;span&gt;socklen, SOCK_NONBLOCK);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            s &lt;/span&gt;= accept(lc-&amp;gt;fd, &amp;amp;sa.sockaddr, &amp;amp;&lt;span&gt;socklen);
        }
&lt;/span&gt;&lt;span&gt;#else&lt;/span&gt;&lt;span&gt;
        s &lt;/span&gt;= accept(lc-&amp;gt;fd, &amp;amp;sa.sockaddr, &amp;amp;&lt;span&gt;socklen);
&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

        &lt;span&gt;if&lt;/span&gt; (s == (ngx_socket_t) -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
            err &lt;/span&gt;=&lt;span&gt; ngx_socket_errno;

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (err ==&lt;span&gt; NGX_EAGAIN) {
                ngx_log_debug0(NGX_LOG_DEBUG_EVENT, ev&lt;/span&gt;-&amp;gt;&lt;span&gt;log, err,
                               &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;accept() not ready&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }

            level &lt;/span&gt;=&lt;span&gt; NGX_LOG_ALERT;

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (err ==&lt;span&gt; NGX_ECONNABORTED) {
                level &lt;/span&gt;=&lt;span&gt; NGX_LOG_ERR;

            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (err == NGX_EMFILE || err ==&lt;span&gt; NGX_ENFILE) {
                level &lt;/span&gt;=&lt;span&gt; NGX_LOG_CRIT;
            }

&lt;/span&gt;&lt;span&gt;#if&lt;/span&gt; (NGX_HAVE_ACCEPT4)&lt;span&gt;
            ngx_log_error(level, ev&lt;/span&gt;-&amp;gt;&lt;span&gt;log, err,
                          use_accept4 &lt;/span&gt;? &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;accept4() failed&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;accept() failed&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (use_accept4 &amp;amp;&amp;amp; err ==&lt;span&gt; NGX_ENOSYS) {
                use_accept4 &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
                ngx_inherited_nonblocking &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
            }
&lt;/span&gt;&lt;span&gt;#else&lt;/span&gt;&lt;span&gt;
            ngx_log_error(level, ev&lt;/span&gt;-&amp;gt;log, err, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;accept() failed&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

            &lt;span&gt;if&lt;/span&gt; (err ==&lt;span&gt; NGX_ECONNABORTED) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ngx_event_flags &amp;amp;&lt;span&gt; NGX_USE_KQUEUE_EVENT) {
                    ev&lt;/span&gt;-&amp;gt;available--&lt;span&gt;;
                }

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ev-&amp;gt;&lt;span&gt;available) {
                    &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
                }
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (err == NGX_EMFILE || err ==&lt;span&gt; NGX_ENFILE) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ngx_disable_accept_events((ngx_cycle_t *) ngx_cycle, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
                    &lt;/span&gt;!=&lt;span&gt; NGX_OK)
                {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                }

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ngx_use_accept_mutex) {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ngx_accept_mutex_held) {
                        ngx_shmtx_unlock(&lt;/span&gt;&amp;amp;&lt;span&gt;ngx_accept_mutex);
                        ngx_accept_mutex_held &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
                    }

                    ngx_accept_disabled &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

                } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    ngx_add_timer(ev, ecf&lt;/span&gt;-&amp;gt;&lt;span&gt;accept_mutex_delay);
                }
            }

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }

&lt;/span&gt;&lt;span&gt;#if&lt;/span&gt; (NGX_STAT_STUB)&lt;span&gt;
        (&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;) ngx_atomic_fetch_add(ngx_stat_accepted, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;&lt;span&gt;

        ngx_accept_disabled &lt;/span&gt;= ngx_cycle-&amp;gt;connection_n / &lt;span&gt;8&lt;/span&gt;
                              - ngx_cycle-&amp;gt;&lt;span&gt;free_connection_n;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取socket读写指针&lt;/span&gt;
        c = ngx_get_connection(s, ev-&amp;gt;&lt;span&gt;log);

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (c ==&lt;span&gt; NULL) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ngx_close_socket(s) == -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
                ngx_log_error(NGX_LOG_ALERT, ev&lt;/span&gt;-&amp;gt;&lt;span&gt;log, ngx_socket_errno,
                              ngx_close_socket_n &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; failed&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }

        c&lt;/span&gt;-&amp;gt;type =&lt;span&gt; SOCK_STREAM;

&lt;/span&gt;&lt;span&gt;#if&lt;/span&gt; (NGX_STAT_STUB)&lt;span&gt;
        (&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;) ngx_atomic_fetch_add(ngx_stat_active, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建内存空间&lt;/span&gt;
        c-&amp;gt;pool = ngx_create_pool(ls-&amp;gt;pool_size, ev-&amp;gt;&lt;span&gt;log);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (c-&amp;gt;pool ==&lt;span&gt; NULL) {
            ngx_close_accepted_connection(c);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (socklen &amp;gt; (socklen_t) &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(ngx_sockaddr_t)) {
            socklen &lt;/span&gt;= &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(ngx_sockaddr_t);
        }

        c&lt;/span&gt;-&amp;gt;sockaddr = ngx_palloc(c-&amp;gt;&lt;span&gt;pool, socklen);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (c-&amp;gt;sockaddr ==&lt;span&gt; NULL) {
            ngx_close_accepted_connection(c);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }

        ngx_memcpy(c&lt;/span&gt;-&amp;gt;sockaddr, &amp;amp;&lt;span&gt;sa, socklen);

        log &lt;/span&gt;= ngx_palloc(c-&amp;gt;pool, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(ngx_log_t));
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (log ==&lt;span&gt; NULL) {
            ngx_close_accepted_connection(c);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; set a blocking mode for iocp and non-blocking mode for others &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ngx_inherited_nonblocking) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ngx_event_flags &amp;amp;&lt;span&gt; NGX_USE_IOCP_EVENT) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ngx_blocking(s) == -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
                    ngx_log_error(NGX_LOG_ALERT, ev&lt;/span&gt;-&amp;gt;&lt;span&gt;log, ngx_socket_errno,
                                  ngx_blocking_n &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; failed&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    ngx_close_accepted_connection(c);
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                }
            }

        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!(ngx_event_flags &amp;amp;&lt;span&gt; NGX_USE_IOCP_EVENT)) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ngx_nonblocking(s) == -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
                    ngx_log_error(NGX_LOG_ALERT, ev&lt;/span&gt;-&amp;gt;&lt;span&gt;log, ngx_socket_errno,
                                  ngx_nonblocking_n &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; failed&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    ngx_close_accepted_connection(c);
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                }
            }
        }

        &lt;/span&gt;*log = ls-&amp;gt;&lt;span&gt;log;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建各种上下文环境给到socket连接&lt;/span&gt;
        c-&amp;gt;recv =&lt;span&gt; ngx_recv;
        c&lt;/span&gt;-&amp;gt;send =&lt;span&gt; ngx_send;
        c&lt;/span&gt;-&amp;gt;recv_chain =&lt;span&gt; ngx_recv_chain;
        c&lt;/span&gt;-&amp;gt;send_chain =&lt;span&gt; ngx_send_chain;

        c&lt;/span&gt;-&amp;gt;log =&lt;span&gt; log;
        c&lt;/span&gt;-&amp;gt;pool-&amp;gt;log =&lt;span&gt; log;

        c&lt;/span&gt;-&amp;gt;socklen =&lt;span&gt; socklen;
        c&lt;/span&gt;-&amp;gt;listening =&lt;span&gt; ls;
        c&lt;/span&gt;-&amp;gt;local_sockaddr = ls-&amp;gt;&lt;span&gt;sockaddr;
        c&lt;/span&gt;-&amp;gt;local_socklen = ls-&amp;gt;&lt;span&gt;socklen;

&lt;/span&gt;&lt;span&gt;#if&lt;/span&gt; (NGX_HAVE_UNIX_DOMAIN)
        &lt;span&gt;if&lt;/span&gt; (c-&amp;gt;sockaddr-&amp;gt;sa_family ==&lt;span&gt; AF_UNIX) {
            c&lt;/span&gt;-&amp;gt;tcp_nopush =&lt;span&gt; NGX_TCP_NOPUSH_DISABLED;
            c&lt;/span&gt;-&amp;gt;tcp_nodelay =&lt;span&gt; NGX_TCP_NODELAY_DISABLED;
&lt;/span&gt;&lt;span&gt;#if&lt;/span&gt; (NGX_SOLARIS)
            &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Solaris's sendfilev() supports AF_NCA, AF_INET, and AF_INET6 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            c&lt;/span&gt;-&amp;gt;sendfile = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;&lt;span&gt;
        }
&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;&lt;span&gt;

        rev &lt;/span&gt;= c-&amp;gt;&lt;span&gt;read;
        wev &lt;/span&gt;= c-&amp;gt;&lt;span&gt;write;

        wev&lt;/span&gt;-&amp;gt;ready = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ngx_event_flags &amp;amp;&lt;span&gt; NGX_USE_IOCP_EVENT) {
            rev&lt;/span&gt;-&amp;gt;ready = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ev-&amp;gt;&lt;span&gt;deferred_accept) {
            rev&lt;/span&gt;-&amp;gt;ready = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;#if&lt;/span&gt; (NGX_HAVE_KQUEUE || NGX_HAVE_EPOLLRDHUP)&lt;span&gt;
            rev&lt;/span&gt;-&amp;gt;available = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;&lt;span&gt;
        }

        rev&lt;/span&gt;-&amp;gt;log =&lt;span&gt; log;
        wev&lt;/span&gt;-&amp;gt;log =&lt;span&gt; log;

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
         * TODO: MT: - ngx_atomic_fetch_add()
         *             or protection by critical section or light mutex
         *
         * TODO: MP: - allocated in a shared memory
         *           - ngx_atomic_fetch_add()
         *             or protection by critical section or light mutex
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

        c&lt;/span&gt;-&amp;gt;number = ngx_atomic_fetch_add(ngx_connection_counter, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;#if&lt;/span&gt; (NGX_STAT_STUB)&lt;span&gt;
        (&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;) ngx_atomic_fetch_add(ngx_stat_handled, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

        &lt;span&gt;if&lt;/span&gt; (ls-&amp;gt;&lt;span&gt;addr_ntop) {
            c&lt;/span&gt;-&amp;gt;addr_text.data = ngx_pnalloc(c-&amp;gt;pool, ls-&amp;gt;&lt;span&gt;addr_text_max_len);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (c-&amp;gt;addr_text.data ==&lt;span&gt; NULL) {
                ngx_close_accepted_connection(c);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }

            c&lt;/span&gt;-&amp;gt;addr_text.len = ngx_sock_ntop(c-&amp;gt;sockaddr, c-&amp;gt;&lt;span&gt;socklen,
                                             c&lt;/span&gt;-&amp;gt;&lt;span&gt;addr_text.data,
                                             ls&lt;/span&gt;-&amp;gt;addr_text_max_len, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (c-&amp;gt;addr_text.len == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
                ngx_close_accepted_connection(c);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }
        }

&lt;/span&gt;&lt;span&gt;#if&lt;/span&gt; (NGX_DEBUG)&lt;span&gt;
        {
        ngx_str_t  addr;
        u_char     text[NGX_SOCKADDR_STRLEN];

        ngx_debug_accepted_connection(ecf, c);

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (log-&amp;gt;log_level &amp;amp;&lt;span&gt; NGX_LOG_DEBUG_EVENT) {
            addr.data &lt;/span&gt;=&lt;span&gt; text;
            addr.len &lt;/span&gt;= ngx_sock_ntop(c-&amp;gt;sockaddr, c-&amp;gt;&lt;span&gt;socklen, text,
                                     NGX_SOCKADDR_STRLEN, &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);

            ngx_log_debug3(NGX_LOG_DEBUG_EVENT, log, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
                           &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*%uA accept: %V fd:%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, c-&amp;gt;number, &amp;amp;&lt;span&gt;addr, s);
        }

        }
&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

        &lt;span&gt;if&lt;/span&gt; (ngx_add_conn &amp;amp;&amp;amp; (ngx_event_flags &amp;amp; NGX_USE_EPOLL_EVENT) == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ngx_add_conn(c) ==&lt;span&gt; NGX_ERROR) {
                ngx_close_accepted_connection(c);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }
        }

        log&lt;/span&gt;-&amp;gt;data =&lt;span&gt; NULL;
        log&lt;/span&gt;-&amp;gt;handler =&lt;span&gt; NULL;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 处理就绪的io事件，读写事件，此处将会转到 http 模块处理&lt;/span&gt;
        ls-&amp;gt;&lt;span&gt;handler(c);

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ngx_event_flags &amp;amp;&lt;span&gt; NGX_USE_KQUEUE_EVENT) {
            ev&lt;/span&gt;-&amp;gt;available--&lt;span&gt;;
        }

    } &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (ev-&amp;gt;&lt;span&gt;available);
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; http/ngx_http_request.c
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化socket连接, 接入 http模块&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt;
ngx_http_init_connection(ngx_connection_t &lt;/span&gt;*&lt;span&gt;c)
{
    ngx_uint_t              i;
    ngx_event_t            &lt;/span&gt;*&lt;span&gt;rev;
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; sockaddr_in     *&lt;span&gt;sin;
    ngx_http_port_t        &lt;/span&gt;*&lt;span&gt;port;
    ngx_http_in_addr_t     &lt;/span&gt;*&lt;span&gt;addr;
    ngx_http_log_ctx_t     &lt;/span&gt;*&lt;span&gt;ctx;
    ngx_http_connection_t  &lt;/span&gt;*&lt;span&gt;hc;
&lt;/span&gt;&lt;span&gt;#if&lt;/span&gt; (NGX_HAVE_INET6)
    &lt;span&gt;struct&lt;/span&gt; sockaddr_in6    *&lt;span&gt;sin6;
    ngx_http_in6_addr_t    &lt;/span&gt;*&lt;span&gt;addr6;
&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 分配数据内存&lt;/span&gt;
    hc = ngx_pcalloc(c-&amp;gt;pool, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(ngx_http_connection_t));
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (hc ==&lt;span&gt; NULL) {
        ngx_http_close_connection(c);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }

    c&lt;/span&gt;-&amp;gt;data =&lt;span&gt; hc;

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; find the server configuration for the address:port &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

    port &lt;/span&gt;= c-&amp;gt;listening-&amp;gt;&lt;span&gt;servers;

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (port-&amp;gt;naddrs &amp;gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
         * there are several addresses on this port and one of them
         * is an &quot;*:port&quot; wildcard so getsockname() in ngx_http_server_addr()
         * is required to determine a server address
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

        &lt;span&gt;if&lt;/span&gt; (ngx_connection_local_sockaddr(c, NULL, &lt;span&gt;0&lt;/span&gt;) !=&lt;span&gt; NGX_OK) {
            ngx_http_close_connection(c);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据网络类型处理&lt;/span&gt;
        &lt;span&gt;switch&lt;/span&gt; (c-&amp;gt;local_sockaddr-&amp;gt;&lt;span&gt;sa_family) {

&lt;/span&gt;&lt;span&gt;#if&lt;/span&gt; (NGX_HAVE_INET6)
        &lt;span&gt;case&lt;/span&gt;&lt;span&gt; AF_INET6:
            sin6 &lt;/span&gt;= (&lt;span&gt;struct&lt;/span&gt; sockaddr_in6 *) c-&amp;gt;&lt;span&gt;local_sockaddr;

            addr6 &lt;/span&gt;= port-&amp;gt;&lt;span&gt;addrs;

            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; the last address is &quot;*&quot; &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

            &lt;span&gt;for&lt;/span&gt; (i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; port-&amp;gt;naddrs - &lt;span&gt;1&lt;/span&gt;; i++&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ngx_memcmp(&amp;amp;addr6[i].addr6, &amp;amp;sin6-&amp;gt;sin6_addr, &lt;span&gt;16&lt;/span&gt;) == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                }
            }

            hc&lt;/span&gt;-&amp;gt;addr_conf = &amp;amp;&lt;span&gt;addr6[i].conf;

            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

        &lt;span&gt;default&lt;/span&gt;: &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; AF_INET &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            sin &lt;/span&gt;= (&lt;span&gt;struct&lt;/span&gt; sockaddr_in *) c-&amp;gt;&lt;span&gt;local_sockaddr;

            addr &lt;/span&gt;= port-&amp;gt;&lt;span&gt;addrs;

            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; the last address is &quot;*&quot; &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

            &lt;span&gt;for&lt;/span&gt; (i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; port-&amp;gt;naddrs - &lt;span&gt;1&lt;/span&gt;; i++&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (addr[i].addr == sin-&amp;gt;&lt;span&gt;sin_addr.s_addr) {
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                }
            }

            hc&lt;/span&gt;-&amp;gt;addr_conf = &amp;amp;&lt;span&gt;addr[i].conf;

            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }

    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {

        &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt; (c-&amp;gt;local_sockaddr-&amp;gt;&lt;span&gt;sa_family) {

&lt;/span&gt;&lt;span&gt;#if&lt;/span&gt; (NGX_HAVE_INET6)
        &lt;span&gt;case&lt;/span&gt;&lt;span&gt; AF_INET6:
            addr6 &lt;/span&gt;= port-&amp;gt;&lt;span&gt;addrs;
            hc&lt;/span&gt;-&amp;gt;addr_conf = &amp;amp;addr6[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;].conf;
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

        &lt;span&gt;default&lt;/span&gt;: &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; AF_INET &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            addr &lt;/span&gt;= port-&amp;gt;&lt;span&gt;addrs;
            hc&lt;/span&gt;-&amp;gt;addr_conf = &amp;amp;addr[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;].conf;
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
    }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; the default server configuration for the address:port &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    hc&lt;/span&gt;-&amp;gt;conf_ctx = hc-&amp;gt;addr_conf-&amp;gt;default_server-&amp;gt;&lt;span&gt;ctx;

    ctx &lt;/span&gt;= ngx_palloc(c-&amp;gt;pool, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(ngx_http_log_ctx_t));
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ctx ==&lt;span&gt; NULL) {
        ngx_http_close_connection(c);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }

    ctx&lt;/span&gt;-&amp;gt;connection =&lt;span&gt; c;
    ctx&lt;/span&gt;-&amp;gt;request =&lt;span&gt; NULL;
    ctx&lt;/span&gt;-&amp;gt;current_request =&lt;span&gt; NULL;

    c&lt;/span&gt;-&amp;gt;log-&amp;gt;connection = c-&amp;gt;&lt;span&gt;number;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 每个http server 都有自己的日志记录控制&lt;/span&gt;
    c-&amp;gt;log-&amp;gt;handler =&lt;span&gt; ngx_http_log_error;
    c&lt;/span&gt;-&amp;gt;log-&amp;gt;data =&lt;span&gt; ctx;
    c&lt;/span&gt;-&amp;gt;log-&amp;gt;action = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;waiting for request&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

    c&lt;/span&gt;-&amp;gt;log_error =&lt;span&gt; NGX_ERROR_INFO;

    rev &lt;/span&gt;= c-&amp;gt;&lt;span&gt;read;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置接收数据处理器为 ngx_http_wait_request_handler&lt;/span&gt;
    rev-&amp;gt;handler =&lt;span&gt; ngx_http_wait_request_handler;
    c&lt;/span&gt;-&amp;gt;write-&amp;gt;handler =&lt;span&gt; ngx_http_empty_handler;

&lt;/span&gt;&lt;span&gt;#if&lt;/span&gt; (NGX_HTTP_V2)
    &lt;span&gt;if&lt;/span&gt; (hc-&amp;gt;addr_conf-&amp;gt;&lt;span&gt;http2) {
        rev&lt;/span&gt;-&amp;gt;handler =&lt;span&gt; ngx_http_v2_init;
    }
&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (NGX_HTTP_SSL)&lt;span&gt;
    {
    ngx_http_ssl_srv_conf_t  &lt;/span&gt;*&lt;span&gt;sscf;

    sscf &lt;/span&gt;= ngx_http_get_module_srv_conf(hc-&amp;gt;&lt;span&gt;conf_ctx, ngx_http_ssl_module);

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (sscf-&amp;gt;enable || hc-&amp;gt;addr_conf-&amp;gt;&lt;span&gt;ssl) {
        hc&lt;/span&gt;-&amp;gt;ssl = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        c&lt;/span&gt;-&amp;gt;log-&amp;gt;action = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SSL handshaking&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        rev&lt;/span&gt;-&amp;gt;handler =&lt;span&gt; ngx_http_ssl_handshake;
    }
    }
&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

    &lt;span&gt;if&lt;/span&gt; (hc-&amp;gt;addr_conf-&amp;gt;&lt;span&gt;proxy_protocol) {
        hc&lt;/span&gt;-&amp;gt;proxy_protocol = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        c&lt;/span&gt;-&amp;gt;log-&amp;gt;action = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;reading PROXY protocol&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (rev-&amp;gt;&lt;span&gt;ready) {
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; the deferred accept(), iocp &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ngx_use_accept_mutex) {
            ngx_post_event(rev, &lt;/span&gt;&amp;amp;&lt;span&gt;ngx_posted_events);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }

        rev&lt;/span&gt;-&amp;gt;&lt;span&gt;handler(rev);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将rev 放入到 ngx_event_timer_rbtree 队列中, 红黑树实现&lt;/span&gt;
    ngx_add_timer(rev, c-&amp;gt;listening-&amp;gt;&lt;span&gt;post_accept_timeout);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 重用 connection&lt;/span&gt;
    ngx_reusable_connection(c, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 处理 读就绪事件，注册 read 监听&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (ngx_handle_read_event(rev, &lt;span&gt;0&lt;/span&gt;) !=&lt;span&gt; NGX_OK) {
        ngx_http_close_connection(c);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; event/ngx_event.c
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通用处理: 读事件逻辑&lt;/span&gt;
&lt;span&gt;ngx_int_t
ngx_handle_read_event(ngx_event_t &lt;/span&gt;*&lt;span&gt;rev, ngx_uint_t flags)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ngx_event_flags &amp;amp;&lt;span&gt; NGX_USE_CLEAR_EVENT) {

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; kqueue, epoll &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

        &lt;span&gt;if&lt;/span&gt; (!rev-&amp;gt;active &amp;amp;&amp;amp; !rev-&amp;gt;&lt;span&gt;ready) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ngx_add_event(rev, NGX_READ_EVENT, NGX_CLEAR_EVENT)
                &lt;/span&gt;==&lt;span&gt; NGX_ERROR)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NGX_ERROR;
            }
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NGX_OK;

    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (ngx_event_flags &amp;amp;&lt;span&gt; NGX_USE_LEVEL_EVENT) {

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; select, poll, /dev/poll &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (!rev-&amp;gt;active &amp;amp;&amp;amp; !rev-&amp;gt;&lt;span&gt;ready) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ngx_event_actions.add, 实际为 ngx_select_add_event
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注册读事件&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ngx_add_event(rev, NGX_READ_EVENT, NGX_LEVEL_EVENT)
                &lt;/span&gt;==&lt;span&gt; NGX_ERROR)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NGX_ERROR;
            }

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NGX_OK;
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (rev-&amp;gt;active &amp;amp;&amp;amp; (rev-&amp;gt;ready || (flags &amp;amp;&lt;span&gt; NGX_CLOSE_EVENT))) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ngx_del_event(rev, NGX_READ_EVENT, NGX_LEVEL_EVENT |&lt;span&gt; flags)
                &lt;/span&gt;==&lt;span&gt; NGX_ERROR)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NGX_ERROR;
            }

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NGX_OK;
        }

    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (ngx_event_flags &amp;amp;&lt;span&gt; NGX_USE_EVENTPORT_EVENT) {

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; event ports &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

        &lt;span&gt;if&lt;/span&gt; (!rev-&amp;gt;active &amp;amp;&amp;amp; !rev-&amp;gt;&lt;span&gt;ready) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ngx_add_event(rev, NGX_READ_EVENT, &lt;span&gt;0&lt;/span&gt;) ==&lt;span&gt; NGX_ERROR) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NGX_ERROR;
            }

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NGX_OK;
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (rev-&amp;gt;oneshot &amp;amp;&amp;amp; !rev-&amp;gt;&lt;span&gt;ready) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ngx_del_event(rev, NGX_READ_EVENT, &lt;span&gt;0&lt;/span&gt;) ==&lt;span&gt; NGX_ERROR) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NGX_ERROR;
            }

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NGX_OK;
        }
    }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; iocp &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; NGX_OK;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　大体上就是，先调用内核的accept() 方法，接入socket, 然后调用 http 模块init handler, 注册读事件， 以便后续可以读取数据。至于什么时候会进行真正地读数据请求，则不一定。&lt;/p&gt;

&lt;h3&gt;6. read 事件处理&lt;/h3&gt;
&lt;p&gt;　　经过前面的accept处理，nginx会注册read事件，且会将handler设置为 ngx_http_wait_request_handler, 当数据就绪后，就会从 通用处理队列 的入口处，转到http处理模块处理 io 事件。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;107&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; http/ngx_http_request.c
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 处理socket读事件&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt;
ngx_http_wait_request_handler(ngx_event_t &lt;/span&gt;*&lt;span&gt;rev)
{
    u_char                    &lt;/span&gt;*&lt;span&gt;p;
    size_t                     size;
    ssize_t                    n;
    ngx_buf_t                 &lt;/span&gt;*&lt;span&gt;b;
    ngx_connection_t          &lt;/span&gt;*&lt;span&gt;c;
    ngx_http_connection_t     &lt;/span&gt;*&lt;span&gt;hc;
    ngx_http_core_srv_conf_t  &lt;/span&gt;*&lt;span&gt;cscf;

    c &lt;/span&gt;= rev-&amp;gt;&lt;span&gt;data;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c&lt;/span&gt;-&amp;gt;log, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http wait request handler&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (rev-&amp;gt;&lt;span&gt;timedout) {
        ngx_log_error(NGX_LOG_INFO, c&lt;/span&gt;-&amp;gt;log, NGX_ETIMEDOUT, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;client timed out&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        ngx_http_close_connection(c);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (c-&amp;gt;&lt;span&gt;close) {
        ngx_http_close_connection(c);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }

    hc &lt;/span&gt;= c-&amp;gt;&lt;span&gt;data;
    cscf &lt;/span&gt;= ngx_http_get_module_srv_conf(hc-&amp;gt;&lt;span&gt;conf_ctx, ngx_http_core_module);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 默认1024 缓冲大小&lt;/span&gt;
    size = cscf-&amp;gt;&lt;span&gt;client_header_buffer_size;

    b &lt;/span&gt;= c-&amp;gt;&lt;span&gt;buffer;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 首次接入时，创建初始空间&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (b ==&lt;span&gt; NULL) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建缓冲区接收http传过来的数据&lt;/span&gt;
        b = ngx_create_temp_buf(c-&amp;gt;&lt;span&gt;pool, size);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (b ==&lt;span&gt; NULL) {
            ngx_http_close_connection(c);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }

        c&lt;/span&gt;-&amp;gt;buffer =&lt;span&gt; b;

    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (b-&amp;gt;start ==&lt;span&gt; NULL) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 缓冲冲填满，需要另外增加空间？&lt;/span&gt;
        b-&amp;gt;start = ngx_palloc(c-&amp;gt;&lt;span&gt;pool, size);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (b-&amp;gt;start ==&lt;span&gt; NULL) {
            ngx_http_close_connection(c);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }

        b&lt;/span&gt;-&amp;gt;pos = b-&amp;gt;&lt;span&gt;start;
        b&lt;/span&gt;-&amp;gt;last = b-&amp;gt;&lt;span&gt;start;
        b&lt;/span&gt;-&amp;gt;end = b-&amp;gt;last +&lt;span&gt; size;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 接收数据&lt;/span&gt;
    n = c-&amp;gt;recv(c, b-&amp;gt;&lt;span&gt;last, size);

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (n ==&lt;span&gt; NGX_AGAIN) {

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!rev-&amp;gt;&lt;span&gt;timer_set) {
            ngx_add_timer(rev, c&lt;/span&gt;-&amp;gt;listening-&amp;gt;&lt;span&gt;post_accept_timeout);
            ngx_reusable_connection(c, &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ngx_handle_read_event(rev, &lt;span&gt;0&lt;/span&gt;) !=&lt;span&gt; NGX_OK) {
            ngx_http_close_connection(c);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
         * We are trying to not hold c-&amp;gt;buffer's memory for an idle connection.
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果还要等待更多数据，释放占有空间&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (ngx_pfree(c-&amp;gt;pool, b-&amp;gt;start) ==&lt;span&gt; NGX_OK) {
            b&lt;/span&gt;-&amp;gt;start =&lt;span&gt; NULL;
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (n ==&lt;span&gt; NGX_ERROR) {
        ngx_http_close_connection(c);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (n == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
        ngx_log_error(NGX_LOG_INFO, c&lt;/span&gt;-&amp;gt;log, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
                      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;client closed connection&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        ngx_http_close_connection(c);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }

    b&lt;/span&gt;-&amp;gt;last +=&lt;span&gt; n;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果配置了  proxy_pass （且匹配了模式）,  则直代理逻辑&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (hc-&amp;gt;&lt;span&gt;proxy_protocol) {
        hc&lt;/span&gt;-&amp;gt;proxy_protocol = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

        p &lt;/span&gt;= ngx_proxy_protocol_read(c, b-&amp;gt;pos, b-&amp;gt;&lt;span&gt;last);

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (p ==&lt;span&gt; NULL) {
            ngx_http_close_connection(c);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }

        b&lt;/span&gt;-&amp;gt;pos =&lt;span&gt; p;

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (b-&amp;gt;pos == b-&amp;gt;&lt;span&gt;last) {
            c&lt;/span&gt;-&amp;gt;log-&amp;gt;action = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;waiting for request&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            b&lt;/span&gt;-&amp;gt;pos = b-&amp;gt;&lt;span&gt;start;
            b&lt;/span&gt;-&amp;gt;last = b-&amp;gt;&lt;span&gt;start;
            ngx_post_event(rev, &lt;/span&gt;&amp;amp;&lt;span&gt;ngx_posted_events);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
    }

    c&lt;/span&gt;-&amp;gt;log-&amp;gt;action = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;reading client request line&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置不可重用连接&lt;/span&gt;
    ngx_reusable_connection(c, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建 http 连接请求, 分配内存空, 设置下一个 handler 等等&lt;/span&gt;
    c-&amp;gt;data =&lt;span&gt; ngx_http_create_request(c);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (c-&amp;gt;data ==&lt;span&gt; NULL) {
        ngx_http_close_connection(c);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置读取数据的处理器为 ngx_http_process_request_line, 以便下次使用&lt;/span&gt;
    rev-&amp;gt;handler =&lt;span&gt; ngx_http_process_request_line;
    ngx_http_process_request_line(rev);
}


&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; http/ngx_http_request.c
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 读取body数据，并响应客户端&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt;
ngx_http_process_request_line(ngx_event_t &lt;/span&gt;*&lt;span&gt;rev)
{
    ssize_t              n;
    ngx_int_t            rc, rv;
    ngx_str_t            host;
    ngx_connection_t    &lt;/span&gt;*&lt;span&gt;c;
    ngx_http_request_t  &lt;/span&gt;*&lt;span&gt;r;

    c &lt;/span&gt;= rev-&amp;gt;&lt;span&gt;data;
    r &lt;/span&gt;= c-&amp;gt;&lt;span&gt;data;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, rev&lt;/span&gt;-&amp;gt;log, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
                   &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http process request line&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (rev-&amp;gt;&lt;span&gt;timedout) {
        ngx_log_error(NGX_LOG_INFO, c&lt;/span&gt;-&amp;gt;log, NGX_ETIMEDOUT, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;client timed out&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        c&lt;/span&gt;-&amp;gt;timedout = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        ngx_http_close_request(r, NGX_HTTP_REQUEST_TIME_OUT);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }

    rc &lt;/span&gt;=&lt;span&gt; NGX_AGAIN;

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; ( ;; ) {

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (rc ==&lt;span&gt; NGX_AGAIN) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 读取header&lt;/span&gt;
            n =&lt;span&gt; ngx_http_read_request_header(r);

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (n == NGX_AGAIN || n ==&lt;span&gt; NGX_ERROR) {
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 读取body 数据, 按照http协议解析，非常长&lt;/span&gt;
        rc = ngx_http_parse_request_line(r, r-&amp;gt;&lt;span&gt;header_in);

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (rc ==&lt;span&gt; NGX_OK) {

            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; the request line has been parsed successfully &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

            r&lt;/span&gt;-&amp;gt;request_line.len = r-&amp;gt;request_end - r-&amp;gt;&lt;span&gt;request_start;
            r&lt;/span&gt;-&amp;gt;request_line.data = r-&amp;gt;&lt;span&gt;request_start;
            r&lt;/span&gt;-&amp;gt;request_length = r-&amp;gt;header_in-&amp;gt;pos - r-&amp;gt;&lt;span&gt;request_start;

            ngx_log_debug1(NGX_LOG_DEBUG_HTTP, c&lt;/span&gt;-&amp;gt;log, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
                           &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http request line: \&quot;%V\&quot;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &amp;amp;r-&amp;gt;&lt;span&gt;request_line);

            r&lt;/span&gt;-&amp;gt;method_name.len = r-&amp;gt;method_end - r-&amp;gt;request_start + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
            r&lt;/span&gt;-&amp;gt;method_name.data = r-&amp;gt;&lt;span&gt;request_line.data;

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (r-&amp;gt;&lt;span&gt;http_protocol.data) {
                r&lt;/span&gt;-&amp;gt;http_protocol.len = r-&amp;gt;request_end - r-&amp;gt;&lt;span&gt;http_protocol.data;
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 处理 uri, 解析路径&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (ngx_http_process_request_uri(r) !=&lt;span&gt; NGX_OK) {
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (r-&amp;gt;&lt;span&gt;schema_end) {
                r&lt;/span&gt;-&amp;gt;schema.len = r-&amp;gt;schema_end - r-&amp;gt;&lt;span&gt;schema_start;
                r&lt;/span&gt;-&amp;gt;schema.data = r-&amp;gt;&lt;span&gt;schema_start;
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (r-&amp;gt;&lt;span&gt;host_end) {

                host.len &lt;/span&gt;= r-&amp;gt;host_end - r-&amp;gt;&lt;span&gt;host_start;
                host.data &lt;/span&gt;= r-&amp;gt;&lt;span&gt;host_start;

                rc &lt;/span&gt;= ngx_http_validate_host(&amp;amp;host, r-&amp;gt;pool, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (rc ==&lt;span&gt; NGX_DECLINED) {
                    ngx_log_error(NGX_LOG_INFO, c&lt;/span&gt;-&amp;gt;log, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
                                  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;client sent invalid host in request line&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                }

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (rc ==&lt;span&gt; NGX_ERROR) {
                    ngx_http_close_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                }

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ngx_http_set_virtual_server(r, &amp;amp;host) ==&lt;span&gt; NGX_ERROR) {
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                }

                r&lt;/span&gt;-&amp;gt;headers_in.server =&lt;span&gt; host;
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (r-&amp;gt;http_version &amp;lt;&lt;span&gt; NGX_HTTP_VERSION_10) {

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (r-&amp;gt;headers_in.server.len == &lt;span&gt;0&lt;/span&gt;
                    &amp;amp;&amp;amp; ngx_http_set_virtual_server(r, &amp;amp;r-&amp;gt;&lt;span&gt;headers_in.server)
                       &lt;/span&gt;==&lt;span&gt; NGX_ERROR)
                {
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                }

                ngx_http_process_request(r);
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }


            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ngx_list_init(&amp;amp;r-&amp;gt;headers_in.headers, r-&amp;gt;pool, &lt;span&gt;20&lt;/span&gt;&lt;span&gt;,
                              &lt;/span&gt;&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(ngx_table_elt_t))
                &lt;/span&gt;!=&lt;span&gt; NGX_OK)
            {
                ngx_http_close_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }

            c&lt;/span&gt;-&amp;gt;log-&amp;gt;action = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;reading client request headers&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

            rev&lt;/span&gt;-&amp;gt;handler =&lt;span&gt; ngx_http_process_request_headers;
            ngx_http_process_request_headers(rev);

            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (rc !=&lt;span&gt; NGX_AGAIN) {

            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; there was error while a request line parsing &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

            ngx_log_error(NGX_LOG_INFO, c&lt;/span&gt;-&amp;gt;log, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
                          ngx_http_client_errors[rc &lt;/span&gt;-&lt;span&gt; NGX_HTTP_CLIENT_ERROR]);

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (rc ==&lt;span&gt; NGX_HTTP_PARSE_INVALID_VERSION) {
                ngx_http_finalize_request(r, NGX_HTTP_VERSION_NOT_SUPPORTED);

            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);
            }

            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; NGX_AGAIN: a request line parsing is still incomplete &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

        &lt;span&gt;if&lt;/span&gt; (r-&amp;gt;header_in-&amp;gt;pos == r-&amp;gt;header_in-&amp;gt;&lt;span&gt;end) {

            rv &lt;/span&gt;= ngx_http_alloc_large_header_buffer(r, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (rv ==&lt;span&gt; NGX_ERROR) {
                ngx_http_close_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (rv ==&lt;span&gt; NGX_DECLINED) {
                r&lt;/span&gt;-&amp;gt;request_line.len = r-&amp;gt;header_in-&amp;gt;end - r-&amp;gt;&lt;span&gt;request_start;
                r&lt;/span&gt;-&amp;gt;request_line.data = r-&amp;gt;&lt;span&gt;request_start;

                ngx_log_error(NGX_LOG_INFO, c&lt;/span&gt;-&amp;gt;log, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
                              &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;client sent too long URI&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                ngx_http_finalize_request(r, NGX_HTTP_REQUEST_URI_TOO_LARGE);
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }
        }
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 处理请求, 响应客户端&lt;/span&gt;
&lt;span&gt;    ngx_http_run_posted_requests(c);
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; http/ngx_http_request.c
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 已经处理好的请求处理&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt;
ngx_http_run_posted_requests(ngx_connection_t &lt;/span&gt;*&lt;span&gt;c)
{
    ngx_http_request_t         &lt;/span&gt;*&lt;span&gt;r;
    ngx_http_posted_request_t  &lt;/span&gt;*&lt;span&gt;pr;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 循环处理数据，直到完成&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt;&lt;span&gt; ( ;; ) {

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (c-&amp;gt;&lt;span&gt;destroyed) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }

        r &lt;/span&gt;= c-&amp;gt;&lt;span&gt;data;
        pr &lt;/span&gt;= r-&amp;gt;main-&amp;gt;&lt;span&gt;posted_requests;

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (pr ==&lt;span&gt; NULL) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }

        r&lt;/span&gt;-&amp;gt;main-&amp;gt;posted_requests = pr-&amp;gt;&lt;span&gt;next;

        r &lt;/span&gt;= pr-&amp;gt;&lt;span&gt;request;

        ngx_http_set_log_request(c&lt;/span&gt;-&amp;gt;&lt;span&gt;log, r);

        ngx_log_debug2(NGX_LOG_DEBUG_HTTP, c&lt;/span&gt;-&amp;gt;log, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
                       &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http posted request: \&quot;%V?%V\&quot;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &amp;amp;r-&amp;gt;uri, &amp;amp;r-&amp;gt;&lt;span&gt;args);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 写客户端&lt;/span&gt;
        r-&amp;gt;&lt;span&gt;write_event_handler(r);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　以上就是一个简单视角的 http 请求的处理大体流程了。从中我们大概也理解了，nginx的处理逻辑，和我们想像的方案并没有太大差别，先读取url请求，判断是否特殊转发设置，读取body数据，如果没有特殊设置则定位到相应文件直接响应客户端。（具体如何响应，我们后续再说）&lt;/p&gt;

&lt;p&gt;　　本篇主要站在一个全局的角度，整体上理解nginx的处理请求流程，希望对大家理解nginx有一定的帮助。当然有很多的细节还未厘清，敬请期待。&lt;/p&gt;
</description>
<pubDate>Sat, 12 Sep 2020 23:51:00 +0000</pubDate>
<dc:creator>等你归去来</dc:creator>
<og:description>Nginx 启动起来之后，会有几个进程运行：1. master 进程接收用户命令并做出响应; 2. worker 进程负责处理各网络事件，并同时接收来自master的处理协调命令； master 主要</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yougewe/p/13659987.html</dc:identifier>
</item>
<item>
<title>Combine 框架，从0到1  —— 4.在 Combine 中使用计时器 - Ficow</title>
<link>http://www.cnblogs.com/ficow/p/13659974.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ficow/p/13659974.html</guid>
<description>
&lt;p&gt;本文首发于 &lt;a href=&quot;https://ficowshen.com&quot;&gt;Ficow Shen's Blog&lt;/a&gt;，原文地址： &lt;a href=&quot;https://blog.ficowshen.com/page/post/16&quot;&gt;Combine 框架，从0到1 —— 4.在 Combine 中使用计时器&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&quot;内容概览&quot;&gt;内容概览&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;前言&lt;/li&gt;
&lt;li&gt;使用计时器执行周期性的工作&lt;/li&gt;
&lt;li&gt;将计时器转换为计时器发布者(&lt;code&gt;Timer.TimerPublisher&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;总结&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;计时器是苹果开发者常用的功能。如果你的应用使用 &lt;code&gt;Foundation&lt;/code&gt; 框架中的计时器 &lt;code&gt;Timer&lt;/code&gt; 来周期性地执行某些操作，你可以用 &lt;code&gt;Combine&lt;/code&gt; 简化这些代码。&lt;/p&gt;
&lt;p&gt;现在，让我们来学习如何使用 &lt;code&gt;Combine&lt;/code&gt; 处理计时器，并将已有的计时器处理代码迁移到 &lt;code&gt;Combine&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;使用计时器执行周期性的工作&quot;&gt;使用计时器执行周期性的工作&lt;/h2&gt;

&lt;p&gt;对于 &lt;code&gt;iOS&lt;/code&gt; 开发人员而言，以下代码一定非常眼熟：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-swift&quot;&gt;var timer: Timer?

override func viewDidLoad() {
    super.viewDidLoad()
        
    timer = Timer.scheduledTimer(withTimeInterval: 1, repeats: true) { _ in
        self.myDispatchQueue.async() {
            self.myDataModel.lastUpdated = Date()
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上代码使用 &lt;code&gt;scheduledTimer(withTimeInterval:repeats:block:)&lt;/code&gt; 来实现每秒钟在 &lt;code&gt;myDispatchQueue&lt;/code&gt; 中更新 &lt;code&gt;self.myDataModel.lastUpdated&lt;/code&gt; 的功能。&lt;/p&gt;

&lt;h2 id=&quot;将计时器转换为计时器发布者timertimerpublisher&quot;&gt;将计时器转换为计时器发布者(&lt;code&gt;Timer.TimerPublisher&lt;/code&gt;)&lt;/h2&gt;

&lt;p&gt;要将以上代码迁移到 &lt;code&gt;Combine&lt;/code&gt;，只需将 &lt;code&gt;Timer&lt;/code&gt;（&lt;code&gt;scheduledTimer(withTimeInterval:repeats:block:)&lt;/code&gt;的返回值） 替换为 &lt;code&gt;Timer.TimerPublisher&lt;/code&gt;。调用 &lt;code&gt;Timer. publish(every:tolerance:on:in:options:)&lt;/code&gt; 方法即可创建一个发布者。&lt;/p&gt;
&lt;p&gt;每次底层的计时器(&lt;code&gt;Timer&lt;/code&gt;)触发时，发布者都会发出一个新的日期(&lt;code&gt;Date&lt;/code&gt;)实例，该日期代表计时器触发的瞬间。然后，你可以将 &lt;code&gt;Combine&lt;/code&gt; 操作符应用到这个日期实例上，最终将这个发布者和一个订阅者(如：&lt;code&gt;sink(receiveValue:)&lt;/code&gt; 或 &lt;code&gt;assign(to:on:)&lt;/code&gt;)连接。&lt;/p&gt;

&lt;blockquote readability=&quot;7.7009345794393&quot;&gt;
&lt;p&gt;由于 &lt;code&gt;Timer.TimerPublisher&lt;/code&gt; 遵从 &lt;code&gt;ConnectablePublisher&lt;/code&gt; 协议，因此在您显式地连接之前，它不会产生任何元素。为此，可以通过手动调用 &lt;code&gt;connect()&lt;/code&gt; 或使用 &lt;code&gt;autoconnect()&lt;/code&gt; 运算符在订阅者连接时自动连接来实现。关于 &lt;code&gt;ConnectablePublisher&lt;/code&gt; 的用法，可以参考 &lt;a href=&quot;https://blog.ficow.cn/page/post/13&quot;&gt;这篇文章&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;下一个示例将展示如何使用 &lt;code&gt;Timer.TimerPublisher&lt;/code&gt; 替换上一个示例。它使用 &lt;code&gt;Combine&lt;/code&gt; 的操作符来完成上一个示例中的闭包中的操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-swift&quot;&gt;var cancellable: Cancellable?

override func viewDidLoad() {
    super.viewDidLoad()
        
    cancellable = Timer.publish(every: 1, on: .main, in: .default)
        .autoconnect()
        .receive(on: myDispatchQueue)
        .assign(to: \.lastUpdated, on: myDataModel)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这个例子中，&lt;code&gt;Combine&lt;/code&gt; 操作符替换了上一个示例的闭包中的所有行为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;receive(on:options:)&lt;/code&gt; 操作符确保了后续操作在指定的调度队列中执行，它替代了前面用到的 &lt;code&gt;async()&lt;/code&gt; 调用；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;assign(to:on:)&lt;/code&gt; 操作符通过键路径来更新数据模型的 &lt;code&gt;lastUpdated&lt;/code&gt; 属性；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用 &lt;code&gt;Combine&lt;/code&gt; 来简化你的代码时，你会发现 &lt;code&gt;Timer.TimerPublisher&lt;/code&gt; 会产生新的 &lt;code&gt;Date&lt;/code&gt; 实例作为其输出类型。而第一个示例的闭包是将 &lt;code&gt;Timer&lt;/code&gt; 本身作为其参数，因此它必须手动创建新的 &lt;code&gt;Date&lt;/code&gt; 实例。&lt;/p&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;使用 &lt;code&gt;Combine&lt;/code&gt; 来简化你的计时器代码时，你会发现：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;代码易读性明显提升；&lt;/li&gt;
&lt;li&gt;线程切换变得更简单；&lt;/li&gt;
&lt;li&gt;数据模型的更新可以通过键路径(&lt;code&gt;key path&lt;/code&gt;)来简化；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;朋友，行动起来吧！把现有项目中的旧代码重构成使用 &lt;code&gt;Combine&lt;/code&gt; 的代码~&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;本文内容来源：&lt;/strong&gt;&lt;br/&gt;&lt;a href=&quot;https://developer.apple.com/documentation/combine/replacing-foundation-timers-with-timer-publishers&quot;&gt;Replacing Foundation Timers with Timer Publishers&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 12 Sep 2020 23:33:00 +0000</pubDate>
<dc:creator>Ficow</dc:creator>
<og:description>本文首发于 Ficow Shen&amp;amp;#39;s Blog，原文地址： Combine 框架，从0到1 —— 4.在 Combine 中使用计时器。 内容概览 前言 使用计时器执行周期性的工作 将</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ficow/p/13659974.html</dc:identifier>
</item>
<item>
<title>一文了解进制之间的原理和转换 - 初一丶</title>
<link>http://www.cnblogs.com/wyl-0120/p/13659581.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wyl-0120/p/13659581.html</guid>
<description>&lt;p&gt;生活中我们使用的数字都是十进制的，而二进制是机器能够识别的最直接的语言。但是二进制又太大，记录起来非常的不方便。所以通常会将二进制转化为八进制或者十六进制。&lt;/p&gt;
&lt;p&gt;日常生活中我们所说的数字 （十进制）在0~9之间，同理 二进制的范围是0&lt;sub&gt;1，八进制的范围0&lt;/sub&gt;7，十六进制的范围0~15。 那问题来了，当超过9之后，十六进制该如何表示呢？ 答案是用a&lt;sub&gt;f，表示对应的10&lt;/sub&gt;15&lt;/p&gt;
&lt;h3 id=&quot;进制的表达&quot;&gt;进制的表达&lt;/h3&gt;
&lt;p&gt;在Python中该如何表示每一种进制呢？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;默认输入的数字为十进制&lt;/li&gt;
&lt;li&gt;以0b开头的数字表示二进制&lt;/li&gt;
&lt;li&gt;以0o开头的数字表示八进制&lt;/li&gt;
&lt;li&gt;以0x开头的数字表示十六进制&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 普通的十进制
a = 12
print(a) # 12

# 0b表示二进制
b = 0b100100 
print(b) # 36

# 0o表示八进制
c = 0o56
print(c) # 46

# 0x表示十六进制
d = 0x2a1
print(d) # 673
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;进制之间的转换&quot;&gt;进制之间的转换&lt;/h3&gt;
&lt;h4 id=&quot;1、十进制转二进制&quot;&gt;1、十进制转二进制&lt;/h4&gt;
&lt;p&gt;将十进制数除2取余数，直到商为0时。&lt;/p&gt;
&lt;p&gt;以12为例，&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;12 / 2 = 6  余 0 

6  /  2 = 3  余 0

3  /  2 = 1  余 1

1  /  2 = 0  余 1
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;从上到下取余数&lt;/strong&gt;，因此，&lt;strong&gt;12 对应的 二进制 为 ：1100&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;2、二进制转十进制&quot;&gt;2、二进制转十进制&lt;/h4&gt;
&lt;p&gt;把二进阶按权展开，相加即可。如二进制位：1100，按照下面的格式展开&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   0    0      1                1

1\*2^0  1\*2^1  1\*2^2  1\*2^3  
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;0 * 1*2^0 + 0 * 1*2^1 + 1 * 1*2^2 + 1 * 1*2^3 = 12&lt;/p&gt;
&lt;h4 id=&quot;3、二进制与八进制转换&quot;&gt;3、二进制与八进制转换&lt;/h4&gt;
&lt;p&gt;将2进制从右到左的顺序按照3位拆分，不足时 补0。 例如二进制：1100可拆分成&lt;/p&gt;
&lt;p&gt;001 100 然后按权展开组合起来即可。&lt;/p&gt;
&lt;p&gt;即：&lt;/p&gt;
&lt;p&gt;0*2^2 + 0 * 2 ^ 1 + 1 * 2 ^ 0 = 1&lt;/p&gt;
&lt;p&gt;1*2^2 + 0 * 2 ^ 1 + 0 * 2 ^ 0 = 4&lt;/p&gt;
&lt;p&gt;因此对应的八进制为 14。&lt;/p&gt;
&lt;h3 id=&quot;4、八进制转二进制&quot;&gt;4、八进制转二进制&lt;/h3&gt;
&lt;p&gt;通过对八进制除2取余数，&lt;/p&gt;
&lt;p&gt;1的二进制为1 ，不够3位补0，即001&lt;/p&gt;
&lt;p&gt;4的二进制为100&lt;/p&gt;
&lt;p&gt;因此八进制14转二进制的结果 为：001100&lt;/p&gt;
&lt;p&gt;事实上，日常中用到的主要就是二进制和十进制的转换，其他了解一下就可以了。&lt;/p&gt;
&lt;p&gt;在Python中，已经讲各种进制的转换进行了封装，直接调用即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;a = 12
print(bin(a)) # 0b1100   十进制转二进制
print(oct(a)) # 0o14  十进制转八进制
print(hex(a)) # 0xc   十进制转十六进制

# 二进制转十进制
print(int('0b1100', 2))

# 八进制转十进制
print(int('0o14', 8))

# 十六进制转十进制
print(int('0xc', 16))
&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;&lt;a href=&quot;https://shimo.im/docs/g3tdyXkjCTGtvd8d&quot;&gt;文末福利，史上最全Python资料汇总（长期更新）。隔壁小孩都馋哭了 --- 点击领取&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 12 Sep 2020 18:29:00 +0000</pubDate>
<dc:creator>初一丶</dc:creator>
<og:description>生活中我们使用的数字都是十进制的，而二进制是机器能够识别的最直接的语言。但是二进制又太大，记录起来非常的不方便。所以通常会将二进制转化为八进制或者十六进制。 日常生活中我们所说的数字 （十进制）在09</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wyl-0120/p/13659581.html</dc:identifier>
</item>
<item>
<title>将微服务部署到 Azure Kubernetes 服务 (AKS) 实践 - 技术译民</title>
<link>http://www.cnblogs.com/ittranslator/p/13659516.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ittranslator/p/13659516.html</guid>
<description>&lt;p&gt;本文的目的是：通过使用 DockerHub 和 Azure Kubernetes Service (AKS) 将之前使用 .NET 和 Docker 构建的微服务部署到微软 Azure 云上，来介绍微服务的基本部署过程。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;211.63800277393&quot;&gt;
&lt;blockquote readability=&quot;4.1204819277108&quot;&gt;
&lt;p&gt;本文是对 &lt;a href=&quot;https://dotnet.microsoft.com/learn/aspnet/deploy-microservice-tutorial/intro&quot;&gt;《.NET Tutorial - Deploy a microservice to Azure》&lt;/a&gt; 的翻译和实践。入门级踩坑实践，k8s 大佬请回避，以免浪费您宝贵的时间。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;介绍&quot;&gt;介绍&lt;/h2&gt;
&lt;p&gt;本文的目的是：通过使用 DockerHub 和 Azure Kubernetes Service (AKS) 将之前 &lt;a href=&quot;https://mp.weixin.qq.com/s/Sia9QEOERGAah_SJ5s3pNQ&quot;&gt;使用 .NET 和 Docker 构建的微服务&lt;/a&gt; 部署到微软 Azure 云上，来介绍微服务的基本部署过程。&lt;/p&gt;
&lt;h2 id=&quot;推送到-docker-hub&quot;&gt;推送到 Docker Hub&lt;/h2&gt;
&lt;p&gt;Docker Hub 是世界上最大的容器镜像库和社区。许多产品，包括微软 Azure，都可以基于 Docker Hub 中的镜像创建容器。&lt;/p&gt;
&lt;h3 id=&quot;登录-docker-hub&quot;&gt;登录 Docker Hub&lt;/h3&gt;
&lt;blockquote readability=&quot;4.0258064516129&quot;&gt;
&lt;p&gt;如果还没有 Docker Hub 账号，可以到 &lt;a href=&quot;https://hub.docker.com/&quot;&gt;https://hub.docker.com/&lt;/a&gt; 注册一个， 注册步骤可以参考 &lt;a href=&quot;https://www.cnblogs.com/ittranslator/p/13215081.html&quot;&gt;Docker 快速入门（三）&lt;/a&gt; 中的说明。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在命令提示符窗口，运行以下命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;docker login
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输入您的 &lt;strong&gt;Docker ID&lt;/strong&gt; 和密码，如果输出如下错误：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;Login with your Docker ID to push and pull images from Docker Hub. If you don't have a Docker ID, head over to https://hub.docker.com to create one.
Username:xxxxxx
Password:
Error response from daemon: Get https://registry-1.docker.io/v2/: net/http: TLS handshake timeout
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;表示登录超时，可以尝试设置首选 DNS 服务器为 &lt;code&gt;8.8.8.8&lt;/code&gt;（Google 提供的免费 DNS），命令行修改 DNS 的命令为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# 使用时请将 &quot;WLAN&quot; 改为实际的本地链接名称，需要以管理员身份运行命令提示符窗口
netsh interface ip set dnsservers &quot;WLAN&quot; static 8.8.8.8 primary
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后再次登录，若输出 &lt;code&gt;Login Succeeded&lt;/code&gt;，表示登录成功了。&lt;/p&gt;
&lt;h3 id=&quot;将镜像推送到-docker-hub&quot;&gt;将镜像推送到 Docker Hub&lt;/h3&gt;
&lt;p&gt;根据您的 Docker ID 重新标记（重命名）您的 Docker 镜像，并使用以下命令将其推送到 Docker Hub：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;docker tag mymicroservice [YOUR DOCKER ID]/mymicroservice
docker push [YOUR DOCKER ID]/mymicroservice
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;等待推送完成，在 Docker Hub 中访问您的仓库 &lt;a href=&quot;https://hub.docker.com/repositories&quot;&gt;https://hub.docker.com/repositories&lt;/a&gt;，可以看到刚推送的镜像，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2074831/202009/2074831-20200913012100417-1611534318.png#center&quot; alt=&quot;docker-hub-mymicroservice&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;镜像完成推送后，如果前面有修改过 DNS，务必将 DNS 地址改回原来的动态获取，不然可能会影响网络访问速度：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# 使用时请将 &quot;WLAN&quot; 改为实际的本地连接名称，需要以管理员身份运行命令提示符窗口

# 改为动态获取 DNS 地址
netsh interface ip set dnsservers &quot;WLAN&quot; source=dhcp

# 或者将 DNS 改为 114.114.114.114（国内移动、电信和联通通用的DNS）
netsh interface ip set dnsservers &quot;WLAN&quot; static 114.114.114.114 primary
# 还可以添加第二个 DNS 地址
netsh interface ip add dnsservers &quot;WLAN&quot; 8.8.8.8 index=2
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;安装-azure-工具&quot;&gt;安装 Azure 工具&lt;/h2&gt;
&lt;h3 id=&quot;创建-azure-账户&quot;&gt;创建 Azure 账户&lt;/h3&gt;
&lt;p&gt;如果您是 Azure 云的新手，可以创建一个免费帐户。如果您有一个现有的帐户，可以跳过这一步。&lt;/p&gt;
&lt;p&gt;创建账户的步骤，请查看 『&lt;a href=&quot;https://azure.microsoft.com/free/dotnet/?utm_source=dotnet-website&amp;amp;utm_medium=page&amp;amp;utm_campaign=dotnet-banner&quot;&gt;创建免费 Azure 账户&lt;/a&gt;』&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注册时需要填写姓名、邮箱、手机号、信用卡等一些个人信息，注册成功后扣除了 $1，然后赠送了 $200 一个月的信用额度供免费试用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;安装-azure-cli&quot;&gt;安装 Azure CLI&lt;/h3&gt;
&lt;p&gt;Azure Command Line Interface（CLI）提供了用于管理 Azure 帐户的工具。&lt;/p&gt;
&lt;p&gt;安装 Azure CLI 的步骤，请查看 『&lt;a href=&quot;https://docs.microsoft.com/cli/azure/install-azure-cli-windows?view=azure-cli-latest&quot;&gt;安装 Azure CLI for Windows&lt;/a&gt;』&lt;/p&gt;
&lt;blockquote readability=&quot;4.0140845070423&quot;&gt;
&lt;p&gt;如果从官网下载 Azure CLI 比较慢，可以到这里下载：&lt;br/&gt;链接：&lt;a href=&quot;https://pan.baidu.com/s/1FZhkAFX2o4GRCqSWYmYvmA&quot;&gt;https://pan.baidu.com/s/1FZhkAFX2o4GRCqSWYmYvmA&lt;/a&gt; 提取码：fi8x&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;安装完成后，打开一个&lt;strong&gt;新的&lt;/strong&gt;命令提示符窗口，运行 &lt;code&gt;az --version&lt;/code&gt; 命令检验是否安装成功。&lt;/p&gt;
&lt;h3 id=&quot;登录-azure&quot;&gt;登录 Azure&lt;/h3&gt;
&lt;p&gt;在命令提示符中运行 &lt;code&gt;az login&lt;/code&gt; 命令登录您的 Azure 账户：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;C:\WINDOWS\system32&amp;gt;az login
# 会提示弹出一个登录网页，登录成功后输出如下信息：
You have logged in. Now let us find all the subscriptions to which you have access...
[
  {
    &quot;cloudName&quot;: &quot;AzureCloud&quot;,
    &quot;homeTenantId&quot;: &quot;7cfff80b-cb8f-461f-8bb4-19bd80xxxxxx&quot;,
    &quot;id&quot;: &quot;0123237e-4c5e-4eb5-a4cc-205b0cxxxxxx&quot;,
    &quot;isDefault&quot;: true,
    &quot;managedByTenants&quot;: [],
    &quot;name&quot;: &quot;免费试用&quot;,
    &quot;state&quot;: &quot;Enabled&quot;,
    &quot;tenantId&quot;: &quot;7cfff80b-cb8f-461f-8bb4-19bd80xxxxxx&quot;,
    &quot;user&quot;: {
      &quot;name&quot;: &quot;xxxxxx@163.com&quot;,
      &quot;type&quot;: &quot;user&quot;
    }
  }
]
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;安装-aks-cli-失败！使用线上-azure-cloud-shell-替代&quot;&gt;安装 AKS CLI 失败！使用线上 Azure Cloud Shell 替代&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://kubernetes.io/&quot;&gt;&lt;code&gt;Kubernetes&lt;/code&gt;&lt;/a&gt; 是一个容器编排平台。编排器负责运行、分发、缩放和修复由容器集合组成的应用程序。&lt;code&gt;Azure Kubernetes Service&lt;/code&gt; (&lt;code&gt;AKS&lt;/code&gt;) 将 &lt;code&gt;Kubernetes&lt;/code&gt; 作为一个托管服务提供。&lt;/p&gt;
&lt;p&gt;运行以下命令为 AKS 安装命令行工具。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;az aks install-cli
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5.3929961089494&quot;&gt;
&lt;p&gt;然而，这条命令重试了很多次始终因网络问题而执行失败，最后放弃在本机安装 AKS CLI，直接使用线上 Azure Cloud Shell，关于 Azure Cloud Shell 请参考文档：&lt;a href=&quot;https://docs.microsoft.com/en-us/azure/cloud-shell/overview&quot;&gt;https://docs.microsoft.com/en-us/azure/cloud-shell/overview&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在 Azure Portal 中打开 Azure Cloud Shell 的方法是：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2074831/202009/2074831-20200913012157505-2000041275.png#center&quot; alt=&quot;Azure Cloud Shell&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;创建-azure-资源&quot;&gt;创建 Azure 资源&lt;/h2&gt;
&lt;h3 id=&quot;创建资源组&quot;&gt;创建资源组&lt;/h3&gt;
&lt;p&gt;资源组是用于组织与单个应用程序相关的一组资源。&lt;/p&gt;
&lt;p&gt;在本机命令提示符窗口中运行下面命令创建一个资源组：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;az group create --name myMicroserviceResources --location eastasia
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;C:\Users\xxx&amp;gt;az group create --name myMicroserviceResources --location eastasia
{
  &quot;id&quot;: &quot;/subscriptions/0123237e-4c5e-4eb5-a4cc-205b0cxxxxxx/resourceGroups/myMicroserviceResources&quot;,
  &quot;location&quot;: &quot;eastasia&quot;,
  &quot;managedBy&quot;: null,
  &quot;name&quot;: &quot;myMicroserviceResources&quot;,
  &quot;properties&quot;: {
    &quot;provisioningState&quot;: &quot;Succeeded&quot;
  },
  &quot;tags&quot;: null,
  &quot;type&quot;: &quot;Microsoft.Resources/resourceGroups&quot;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行完，在 Azure Portal 中点击 “Resource groups” 查看：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2074831/202009/2074831-20200913012249381-1325272991.png#center&quot; alt=&quot;portal-azure-resource-groups&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;使用-azure-cloud-shell-创建-aks-集群&quot;&gt;使用 Azure Cloud Shell 创建 AKS 集群&lt;/h3&gt;
&lt;p&gt;使用 Azure Cloud Shell 运行下面命令在资源组中创建一个 AKS 集群：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;此命令通常需要等待几分钟才能完成。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;az aks create --resource-group myMicroserviceResources --name myMicroserviceCluster --node-count 1 --enable-addons http_application_routing --generate-ssh-keys
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行完成后，查看资源组列表，可以看到多了一个 AKS 集群资源组和一个网络观察资源组：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2074831/202009/2074831-20200913012338773-1989501431.png#center&quot; alt=&quot;portal-azure-resource-groups-aks&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用 Azure Cloud Shell 运行以下命令下载要部署到 AKS 集群的凭证：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;az aks get-credentials --resource-group myMicroserviceResources --name myMicroserviceCluster
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;部署到-azure&quot;&gt;部署到 Azure&lt;/h2&gt;
&lt;p&gt;与 Kubernetes 一样，AKS 使用 &lt;code&gt;.yaml&lt;/code&gt; 文件来定义如何部署容器。&lt;/p&gt;
&lt;h3 id=&quot;使用-azure-cloud-shell-创建部署文件&quot;&gt;使用 Azure Cloud Shell 创建部署文件&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2074831/202009/2074831-20200913012422350-122200153.png#center&quot; alt=&quot;azure-cloud-shell-vim-yaml&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在 Azure Portal 中打开 Azure Cloud Shell 窗口， 运行 &lt;code&gt;cd clouddrive&lt;/code&gt; 命令打开 &lt;code&gt;clouddrive&lt;/code&gt; 目录，&lt;/p&gt;
&lt;p&gt;运行下面的命令创建一个空的 &lt;code&gt;deploy-myMicroservice.yaml&lt;/code&gt; 文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;echo . &amp;gt; deploy-myMicroservice.yaml
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后运行 &lt;code&gt;vim deploy-myMicroservice.yaml&lt;/code&gt; 命令编辑 &lt;code&gt;deploy-myMicroservice.yaml&lt;/code&gt; 文件，将内容替换为以下内容：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt;---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mymicroservice
spec:
  replicas: 1
  template:
    metadata:
      labels:
        app: mymicroservice
    spec:
      containers:
      - name: mymicroservice
        image: [YOUR DOCKER ID]/mymicroservice:latest
        ports:
        - containerPort: 80
        env:
        - name: ASPNETCORE_URLS
          value: http://*:80
  selector:
    matchLabels:
      app: mymicroservice
---
apiVersion: v1
kind: Service
metadata:
  name: mymicroservice
spec:
  type: LoadBalancer
  ports:
  - port: 80
  selector:
    app: mymicroservice
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;按 &lt;code&gt;Esc&lt;/code&gt; 键再输入 &lt;code&gt;:wq&lt;/code&gt; 保存并退出 &lt;code&gt;vim&lt;/code&gt; 命令。&lt;/p&gt;
&lt;p&gt;此时打开 “cloud-shell-storage-southeastasia” 资源组，可以看到里面多了一个 &lt;code&gt;deploy-myMicroservice.yaml&lt;/code&gt; 文件，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2074831/202009/2074831-20200913012502477-1929315670.png#center&quot; alt=&quot;cloud-shell-storage-file&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;运行部署&quot;&gt;运行部署&lt;/h3&gt;
&lt;p&gt;在 Azure Cloud Shell 中定位到 &lt;code&gt;clouddrive&lt;/code&gt; 目录，运行下面的命令，根据 &lt;code&gt;deploy-helloMicroservice.yaml&lt;/code&gt; 中的设置进行部署：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;kubectl apply -f deploy-myMicroservice.yaml
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;测试已部署的服务&quot;&gt;测试已部署的服务&lt;/h3&gt;
&lt;p&gt;在 Azure Cloud Shell 中运行以下命令查看已部署服务的详细信息：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;kubectl get service mymicroservice --watch
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2074831/202009/2074831-20200913012537841-828542179.png#center&quot; alt=&quot;azure-cloud-shell-kubectl-apply&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外，前面的 &lt;code&gt;kubectl get service&lt;/code&gt; 命令会显示服务可用的外部 IP 地址（&lt;code&gt;EXTERNAL-IP&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;使用这个外部 IP 地址，在浏览器中浏览『&lt;code&gt;http://[YOUR EXTERNAL IP ADDRESS]/WeatherForecast&lt;/code&gt;』。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果 &lt;code&gt;EXTERNAL-IP&lt;/code&gt; 标记为 &lt;code&gt;&amp;lt;pending&amp;gt;&lt;/code&gt;，则在分配了外部 IP 之后，将会自动出现一个新行来显示。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;服务缩放&quot;&gt;服务缩放&lt;/h2&gt;
&lt;p&gt;运行以下命令将服务扩展到两个实例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;kubectl scale --replicas=2 deployment/mymicroservice
# 输出如下信息：
deployment.apps/mymicroservice scaled
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Good Job！现在已将微服务部署到 Azure，并进行了缩放。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;操作体验：Docker Hub，慢！Azure，慢！ 一顿操作猛如虎，步履蹒跚慢如牛，而且还是只蜗牛。&lt;/p&gt;
&lt;p&gt;可以用 &lt;a href=&quot;https://azure.microsoft.com/zh-cn/services/container-registry/&quot;&gt;Azure 容器注册表&lt;/a&gt; 替代 Docker Hub 管理镜像。&lt;/p&gt;
&lt;p&gt;Azure 虽好，但在国内使用，网络问题难以解决，大大影响使用感受！&lt;/p&gt;
&lt;p&gt;在微服务和 DevOps 普及的时代，越来越多的大厂服务商提供了对 Kubernetes 的支持，Azure 的 “Azure Kubernetes 服务 (AKS) ”和“Azure 容器注册表”，国内有阿里云的“阿里云容器服务 Kubernetes 版（ACK）”和“阿里云容器镜像服务（ACR）” 对标，另外腾讯云和华为云也提供了云容器引擎服务。&lt;/p&gt;
&lt;h2 id=&quot;参考文献及一些相关产品和文档&quot;&gt;参考文献及一些相关产品和文档&lt;/h2&gt;
&lt;br/&gt;&lt;blockquote readability=&quot;3.7234042553191&quot;&gt;
&lt;p&gt;作者 ： 技术译民&lt;br/&gt;出品 ： &lt;a href=&quot;https://ITTranslator.cn/&quot;&gt;技术译站&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;</description>
<pubDate>Sat, 12 Sep 2020 17:37:00 +0000</pubDate>
<dc:creator>技术译民</dc:creator>
<og:description>本文的目的是：通过使用 DockerHub 和 Azure Kubernetes Service (AKS) 将之前使用 .NET 和 Docker 构建的微服务部署到微软 Azure 云上，来介绍微</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ittranslator/p/13659516.html</dc:identifier>
</item>
<item>
<title>高可用服务之Keepalived高可用LVS集群 - Linux-1874</title>
<link>http://www.cnblogs.com/qiuhom-1874/p/13659428.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qiuhom-1874/p/13659428.html</guid>
<description>&lt;div id=&quot;cnblogs_post_description&quot; readability=&quot;35&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/qiuhom-1874/1655970/o_200907045236keepalived.png&quot; class=&quot;desc_img&quot;/&gt; 我们知道一个服务通常是以一个套接字形式对外提供服务，所谓套接字就是ip+端口；前面的博客中我们主要聊到了keepalived对ip地址的高可用，但通常对ip地址高可用没有多大实质的作用，重要的是我们高可用的ip地址后端对应的服务才是根本，这一篇博客主要讲怎么利用keepalived高可用LVS集群，生成ipvs规则，以及对LVS集群的rs做健康状态检测；&lt;/div&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;153.03455992044&quot;&gt;
&lt;p&gt;　　前文我们聊了下keepalived的邮件通知相关配置，回顾请参考&lt;a href=&quot;https://www.cnblogs.com/qiuhom-1874/p/13645163.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/qiuhom-1874/p/13645163.html&lt;/a&gt;；今天我们来说说keepalived高可用LVS集群；&lt;/p&gt;
&lt;p&gt;　　我们知道一个服务通常是以一个套接字形式对外提供服务，所谓套接字就是ip+端口；前面的博客中我们主要聊到了keepalived对ip地址的高可用，但通常对ip地址高可用没有多大实质的作用，重要的是我们高可用的ip地址后端对应的服务才是根本，这一篇博客主要讲怎么利用keepalived高可用LVS集群，生成ipvs规则，以及对LVS集群的rs做健康状态检测；&lt;/p&gt;
&lt;p&gt;　　环境说明&lt;/p&gt;
&lt;table border=&quot;0&quot; align=&quot;left&quot;&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr&gt;&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;ip地址&lt;/td&gt;
&lt;td&gt;端口&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;keepalived-node01(master)&lt;/td&gt;
&lt;td&gt;192.168.0.41&lt;/td&gt;
&lt;td&gt;\&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;keepalived-node02(backup)&lt;/td&gt;
&lt;td&gt;192.168.0.42&lt;/td&gt;
&lt;td&gt;\&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;LVS-RS1&lt;/td&gt;
&lt;td&gt;192.168.0.43&lt;/td&gt;
&lt;td&gt;80&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;LVS-RS2&lt;/td&gt;
&lt;td&gt;192.168.0.44&lt;/td&gt;
&lt;td&gt;80&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;VIP&lt;/td&gt;
&lt;td&gt;192.168.0.111&lt;/td&gt;
&lt;td&gt;80&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;







&lt;p&gt;　　准备LVS集群RS1和RS2&lt;/p&gt;
&lt;p&gt;　　1、安装webserver&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
 yum install nginx -y
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：rs1和rs2上都要安装nginx服务，用于后端rs提供的服务；&lt;/p&gt;
&lt;p&gt;　　2、提供测试页&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200912221750738-882740094.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　3、启动rs1和rs2上的nginx服务&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200912221920965-1339950212.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　4、编写修改内核参数，并配置vip给RS1和RS2的脚本&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200912222359748-97363679.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_fd262b5b-e60d-4742-91c8-7b440dec18c9&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_fd262b5b-e60d-4742-91c8-7b440dec18c9&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_fd262b5b-e60d-4742-91c8-7b440dec18c9&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
#/bin/&lt;span&gt;bash
#
vip&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;192.168.0.111&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
mask&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;255.255.255.255&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
interface&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;lo:0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
 
&lt;span&gt;case&lt;/span&gt; $&lt;span&gt;1&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;span&gt;
start)
        &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; &amp;gt; /proc/sys/net/ipv4/conf/all/&lt;span&gt;arp_announce
        &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; &amp;gt; /proc/sys/net/ipv4/conf/lo/&lt;span&gt;arp_announce
        &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; &amp;gt; /proc/sys/net/ipv4/conf/all/&lt;span&gt;arp_ignore
        &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; &amp;gt; /proc/sys/net/ipv4/conf/lo/&lt;span&gt;arp_ignore
        &lt;/span&gt;&lt;span&gt;ifconfig&lt;/span&gt;&lt;span&gt; $interface  $vip netmask $mask broadcast $vip up
        route add &lt;/span&gt;-&lt;span&gt;host $vip dev $interface
        ;;
stop)
        &lt;/span&gt;&lt;span&gt;ifconfig&lt;/span&gt;&lt;span&gt; $interface down
        &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &amp;gt;/proc/sys/net/ipv4/conf/all/&lt;span&gt;arp_announce
        &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &amp;gt;/proc/sys/net/ipv4/conf/lo/&lt;span&gt;arp_announce
        &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &amp;gt;/proc/sys/net/ipv4/conf/all/&lt;span&gt;arp_ignore
        &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &amp;gt;/proc/sys/net/ipv4/conf/lo/&lt;span&gt;arp_ignore
        ;;
&lt;/span&gt;*&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Usage:bash $0 start|stop&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        exit &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
        ;;
&lt;/span&gt;&lt;span&gt;esac&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　提示：以上脚本主要实现了两个参数，给定start参数就把对应的内核参数修改以后，并vip配置到指定的接口；给stop参数就把vip从指定的端口上删除，并还原内核参数的设定；&lt;/p&gt;
&lt;p&gt;　　在rs1和rs2上执行设置内核参数的脚本&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200912222821431-346328556.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200912222953728-704024063.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：到此后端两个RS的环境就准备好了；&lt;/p&gt;
&lt;p&gt;　　配置keepalived，生成lvs规则&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200913000232000-764077211.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　完整的配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_964138d9-8a11-45b6-9461-fa3eab4e929b&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_964138d9-8a11-45b6-9461-fa3eab4e929b&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_964138d9-8a11-45b6-9461-fa3eab4e929b&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
[root@node01 ~]# &lt;span&gt;cat&lt;/span&gt; /etc/keepalived/&lt;span&gt;keepalived.conf
&lt;/span&gt;! Configuration File &lt;span&gt;for&lt;/span&gt;&lt;span&gt; keepalived

global_defs {
   notification_email {
        root@localhost
   }
   notification_email_from node01_keepalived@localhost
   smtp_server &lt;/span&gt;&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;&lt;span&gt;
   smtp_connect_timeout &lt;/span&gt;&lt;span&gt;30&lt;/span&gt;&lt;span&gt;
   router_id node01
   vrrp_skip_check_adv_addr
   vrrp_strict
   vrrp_garp_interval &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
   vrrp_gna_interval &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
   vrrp_mcast_group4 &lt;/span&gt;&lt;span&gt;224.0&lt;/span&gt;.&lt;span&gt;12.132&lt;/span&gt;&lt;span&gt;
}

vrrp_instance VI_1 {
    state MASTER
    interface ens33
    virtual_router_id &lt;/span&gt;&lt;span&gt;51&lt;/span&gt;&lt;span&gt;
    priority &lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;
    advert_int &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
    authentication {
        auth_type PASS
        auth_pass &lt;/span&gt;&lt;span&gt;12345678&lt;/span&gt;&lt;span&gt;
    }
    virtual_ipaddress {
        &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;0.111&lt;/span&gt;/&lt;span&gt;24&lt;/span&gt; brd &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;0.255&lt;/span&gt; dev ens33 label ens33:&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
    }
    notify_master &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/etc/keepalived/notify.sh master&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    notify_backup &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/etc/keepalived/notify.sh backup&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    notify_fault  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/etc/keepalived/notify.sh fault&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
}

virtual_server &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;0.111&lt;/span&gt; &lt;span&gt;80&lt;/span&gt;&lt;span&gt; {
        delay_loop &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;
        lb_algo wrr
        lb_kind DR
        protocol TCP
        sorry_server &lt;/span&gt;&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt; &lt;span&gt;80&lt;/span&gt;&lt;span&gt;

        real_server &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;0.43&lt;/span&gt; &lt;span&gt;80&lt;/span&gt;&lt;span&gt; {
                weight &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
                nb_get_retry &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
                delay_before_retry &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
                connect_timeout &lt;/span&gt;&lt;span&gt;30&lt;/span&gt;&lt;span&gt;
                HTTP_GET {
                    url {
                    path &lt;/span&gt;/&lt;span&gt;index.html
                    status_code &lt;/span&gt;&lt;span&gt;200&lt;/span&gt;&lt;span&gt;
                    }
                }
        }
        real_server &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;0.44&lt;/span&gt; &lt;span&gt;80&lt;/span&gt;&lt;span&gt; {
                weight &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
                nb_get_retry &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
                delay_before_retry &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
                connect_timeout &lt;/span&gt;&lt;span&gt;30&lt;/span&gt;&lt;span&gt;
                HTTP_GET {
                    url {
                    path &lt;/span&gt;/&lt;span&gt;index.html
                    status_code &lt;/span&gt;&lt;span&gt;200&lt;/span&gt;&lt;span&gt;
                    }
                }
        }
}

[root@node01 &lt;/span&gt;~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　提示：virtual_server用于定义LVS对外集群ip地址和端口（vip），用大括号括起来，其中delay_loop用于指定对后端rs做健康状态检查的时间间隔；lb_algo/lvs_sched用于指定lvs的调度算法，常用的算法有rr，wrr，lc，wlc，lblc，sh，dh；lb_kind/lvs_method用于指定lvs集群的类型，常用的类型有DR，NAT，TUN，需注意这里的类型的值必须大写，否则服务有异常；有关LVS集群类型的相关说明请参考&lt;a href=&quot;https://www.cnblogs.com/qiuhom-1874/p/12327506.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/qiuhom-1874/p/12327506.html&lt;/a&gt;；protocol用于指定4层协议，常用的4层协议有TCP ,UDP,SCTP，需注意这里的值必须大写；sorry_server用于指定，当后端RS都宕机情况下，临时对用户说sorry的服务器地址和端口；real_server：用来定义后端RS的相关配置，其中weight用于指定当前rs的权重，nb_get_retry用指定对rs检测的重试次数，如果在指定的次数上都监测失败就标记该RS为下线状态，并从当前集群中下线；delay_before_retry用于指定重试之前延迟的时间；connect_timeout用于指定对rs检测的超时时长；HTTP_GET 用于配置对rs的检查方法，HTTP_GET表示应用层http检测，其中path用于指定检测到uri，status_code用于指定对指定URI检测到状态码，通常为200；以上virtual_server的配置在node02上也是相同的配置；&lt;/p&gt;
&lt;p&gt;　　安装sorryserver，并配置测试页面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200912231954795-1443341164.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200912232127362-1739227700.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　启动keepalived&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200912232457324-757408341.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：到此基于keepalived高可用LVS集群就配置完成了；&lt;/p&gt;
&lt;p&gt;　　验证：用浏览器对VIP访问，看看是否能够访问到后端RS提供的页面？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200912232811612-463857437.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：我们用浏览器访问VIP并没有访问到后端的rs提供的页面；其中的原因是我们在配置keepalived时，开启了严格遵守vrrp协议，所以启动keepalived它默认会自动生成iptables规则，禁止任何地址访问VIP；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200912233120187-528697479.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：解决办法用iptables -F清空iptables规则；这种清空iptables规则的方式只是临时的方式，重启以后，或者vip飘逸后，对应的规则又会生成，永久解决办法是在keepalived的配置文件，禁用它自动生成iptabels规则；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200912233406493-679706418.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：在/etc/keepalived/keepalived.conf的global_defs中加上vrrp_iptables这个配置，这个配置表示禁用自动生成iptables规则；当然我们也可配置不严格遵守vrrp协议，把vrrp_strict去掉也行；选择其中一种方式即可；&lt;/p&gt;
&lt;p&gt;　　验证：重启keepalived，看看对应iptables规则是否还会生成？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200912233634923-1921038478.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：可以看到现在vip所在节点的iptables规则就没有在自动生成了，对于node02也是相同的配置，重启keepalived即可解决自动生成iptables规则的问题；&lt;/p&gt;
&lt;p&gt;　　现在在用浏览器访问vip，看看是否能够访问到后端RS提供的页面？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200913000650089-1699350247.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200913000706230-798657473.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：可以看到我们在浏览器上访问VIP是可以正常访问到后端rs提供的页面；&lt;/p&gt;
&lt;p&gt;　　验证：把node01上的keepalived停掉，看看node02是否会自动将vip配置上对应的接口？用浏览器是否还会访问到rs提供的页面呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200913001222169-409974891.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：可以看到当node01的keepalived宕机以后，对应vip会自动飘逸到node02上去，并且在客户端访问VIP几乎不受影响；&lt;/p&gt;
&lt;p&gt;　　验证：在node01上查看ipvs规则，看看是否都生成了ipvs规则呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200913001427664-297732267.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：可以看到node01上并没有生成ipvs规则，原因是keepalived停掉了，对应的ipvs规则也就删除了；node02上的keepalived是活跃状态，所以对应ipvs规则也是有keepalived自动生成；&lt;/p&gt;
&lt;p&gt;　　验证：把rs1的web服务停掉，看看keepalived是否会检测到rs1不再线，从而把rs1自动从集群踢出去呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200913001826772-683600075.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：可以看到当rs1故障以后，keepalived会检测到rs1故障，然后把rs1从集群中提出去，所以我们在ipvs规则表中就没有rs1；&lt;/p&gt;
&lt;p&gt;　　验证：把rs2停掉，看看对应的sorryserver是否会被激活？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200913002106228-1506506499.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：可以看到把rs2停掉以后，对应ipvs规则表中就没有RS2，并且它会把我们之前配置的sorryserver 的地址和端口配置上；&lt;/p&gt;
&lt;p&gt;　　验证：用浏览器访问VIP看看对应相应的内容是否是vip所在节点的sorryserver提供的页面呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200913002306118-713231718.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：可以看到当rs都宕机以后，再次访问VIP就会响应我们之前在配置文件中提供的sorryserver的页面；&lt;/p&gt;
&lt;p&gt;　　验证：启动rs1或rs2看看对应sorryserver是否会下线呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200913002513852-470587114.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：可以看到当rs2恢复以后，对应的sorryserver就从集群下线；&lt;/p&gt;
&lt;p&gt;　　到此基于keepalived高可用LVS集群的配置，测试就结束了；&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Sat, 12 Sep 2020 17:15:00 +0000</pubDate>
<dc:creator>Linux-1874</dc:creator>
<og:description>前文我们聊了下keepalived的邮件通知相关配置，回顾请参考https://www.cnblogs.com/qiuhom-1874/p/13645163.html；今天我们来说说keepalive</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qiuhom-1874/p/13659428.html</dc:identifier>
</item>
<item>
<title>消除代码中的坏味道，编写高质量代码 - WeihanLi</title>
<link>http://www.cnblogs.com/weihanli/p/13651033.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/weihanli/p/13651033.html</guid>
<description>&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;/h2&gt;
&lt;p&gt;想要写出较好的代码，保证代码的高质量需要时刻警惕代码中的坏味道，今天分享一下，我觉得平时写的代码中可能会出现的坏味道代码的一些示例&lt;/p&gt;
&lt;h2 id=&quot;常见的坏味道代码&quot;&gt;常见的坏味道代码&lt;/h2&gt;
&lt;ol start=&quot;0&quot;&gt;&lt;li&gt;Bug Logically(null check etc.)&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;严格的来说，这可能是一个 BUG 级别的代码了，最简单的一个实例，你应该明确你的输入数据是不是可能为 null，如果可能为 null 需要检查一下，有一些代码中往往会在代码中写下一些坑，明明这个变量是 &lt;code&gt;null&lt;/code&gt; 还是直接用这个变量中的属性或方法&lt;/p&gt;
&lt;p&gt;还有一种情况是明确对象不是 &lt;code&gt;null&lt;/code&gt; 的情况下就不要 null check 或使用 null 传播符号，下面的这个是一个错误示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;var list = new List&amp;lt;int&amp;gt;(){1,2,3,-2,3,6,2};
var arr = list?.Where(x=&amp;gt;x&amp;gt;0)?.Where(x=&amp;gt;(x%2)==0)?.ToArray()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码里 &lt;code&gt;list&lt;/code&gt; 是不会为 &lt;code&gt;null&lt;/code&gt; 的所以 &lt;code&gt;list&lt;/code&gt; 后不需要加 &lt;code&gt;?&lt;/code&gt;，&lt;code&gt;Where&lt;/code&gt; 这个 LINQ 方法是不会返回一个 &lt;code&gt;null&lt;/code&gt; 的，所以 &lt;code&gt;Where&lt;/code&gt; 后面也是不需要加 &lt;code&gt;?&lt;/code&gt; 的&lt;/p&gt;
&lt;p&gt;这里特别想说一下，很多人对象 &lt;code&gt;First&lt;/code&gt; 和 &lt;code&gt;FirstOrDefault&lt;/code&gt; 的用法有些不清楚，如果能找到数据并且要找到第一个数据就用 &lt;code&gt;First&lt;/code&gt;，如果找不到会有 exception，&lt;br/&gt;而 &lt;code&gt;FirstOrDefault&lt;/code&gt; 在不确定有没有的时候用它更合适，如果没有就返回一个默认值。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;unnecessary namespace using&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;代码中没有用到的命名空间引用请移除它，避免不必要的代码&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;unused code, commented code&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;没有用到的代码或者被注释的代码直接从代码中删除，不要保留在代码库中，一个是可能会让人很费解，一个是没有任何用处&lt;/p&gt;
&lt;p&gt;现在我们的代码基本都会使用源代码版本管理，如果没有，我建议你使用，这样可以保证每次修改都是一个版本，可追溯&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;exception throw&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在应用中主动抛异常的时候应该抛出具体的异常，例如参数为 &lt;code&gt;null&lt;/code&gt; 的时候应该抛出 &lt;code&gt;throw new ArgumentNullException(&quot;paramName&quot;)&lt;/code&gt; 而不是 &lt;code&gt;throw new Exception()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;还有一些异常应该是系统内部抛出的异常，不应该从用户代码中抛出，例如： &lt;code&gt;IndexOutOfRangeException&lt;/code&gt;&lt;/p&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;obsolete members&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;对于过时的方法，我们一般会标记一个 &lt;code&gt;[Obsolete]&lt;/code&gt;，标记的同时应该提供一个 message 提示用户不要使用这个方法或者使用哪一个方法代替&lt;/p&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;抽象类&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;抽象类的构造器方法应该是 &lt;code&gt;protected&lt;/code&gt;，因为抽象类是不能实例化的，所以抽象类的构造方法是不是被直接调用的，所以通常来说应该考虑抽象类的构造方法设置为 &lt;code&gt;protected&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;抽象类中外部要使用的方法才设置为 &lt;code&gt;public&lt;/code&gt;，仅内部会用到的成员设置为 protected 即可，体现封装特性，最小化访问权限&lt;/p&gt;
&lt;ol start=&quot;6&quot;&gt;&lt;li&gt;方法重载&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;方法重载应该放在一起，这样方便我们查找代码，也会更方便了解这个方法的参数&lt;/p&gt;
&lt;ol start=&quot;7&quot;&gt;&lt;li&gt;method &lt;strong&gt;complexity&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;减少方法的复杂度，不要让一个方法过于复杂，如果太复杂了就可能需要考虑重构了，方法参数不能太多，方法逻辑不要太复杂，详细可以参考上一篇文章方法重构分析&lt;/p&gt;
&lt;ol start=&quot;8&quot;&gt;&lt;li&gt;&lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;对于 &lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt; 使用 &lt;code&gt;Any()&lt;/code&gt; 来代替 &lt;code&gt;Count()==0&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;对于数组和列表分别使用 &lt;code&gt;array.Length&lt;/code&gt; 和 &lt;code&gt;list.Count&lt;/code&gt; 代替 &lt;code&gt;Count()&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;recommendations&quot;&gt;Recommendations&lt;/h2&gt;
&lt;p&gt;推荐为你的 Visual Studio 安装 &lt;strong&gt;CodeMaid&lt;/strong&gt; 和 &lt;strong&gt;ReSharper&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用 &lt;strong&gt;CodeMaid&lt;/strong&gt; 来做代码整理，通常我会使用 &lt;code&gt;CodeMaid&lt;/code&gt; 来自动整理代码，防止有些地方会有多余的空格，和自动清理命名空间，除此之外 &lt;code&gt;CodeMaid&lt;/code&gt; 还有一个比较赞的功能是在使用 region 来区分代码块的时候，&lt;code&gt;CodeMaid&lt;/code&gt; 会在 EndRegion 处增加对应的 Region 的描述信息，这样方法较长，region 较多的情况下会比较容易区分哪里是哪一部分的会比较清晰&lt;/p&gt;
&lt;p&gt;遵循 &lt;strong&gt;ReSharper&lt;/strong&gt; 的建议编写更整洁的代码，ReSharper 会提供很多实用的建议，比如使用新的 C# 语法来简化代码，移除没有使用的变量等很多很实用的建议，按照 &lt;code&gt;ReSharper&lt;/code&gt; 的建议我们就可以比较轻松的写出比较良好的代码，有时候 &lt;code&gt;ReSharper&lt;/code&gt; 的命名规则可能会于自己的习惯不符，可以通过定制 &lt;code&gt;editorconfig&lt;/code&gt; 来指定命名规范&lt;/p&gt;
&lt;h2 id=&quot;more&quot;&gt;More&lt;/h2&gt;
&lt;p&gt;Resharper 也有代码整理的，不过我没用过，习惯了 CodeMaid 了，有兴趣的可以研究一下，一起交流一下哈~~&lt;/p&gt;
</description>
<pubDate>Sat, 12 Sep 2020 17:01:00 +0000</pubDate>
<dc:creator>WeihanLi</dc:creator>
<og:description>如何写高质量代码</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/weihanli/p/13651033.html</dc:identifier>
</item>
<item>
<title>二叉树路径查找 - 广大青年</title>
<link>http://www.cnblogs.com/damon-dhc/p/13659367.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/damon-dhc/p/13659367.html</guid>
<description>&lt;h3 align=&quot;left&quot;&gt;&lt;span&gt;最近笔试做了这么一道题，想和大家分享一下我的做法&lt;/span&gt;&lt;/h3&gt;
&lt;h2 align=&quot;left&quot;&gt;&lt;strong&gt;目录：1.题目&lt;/strong&gt;&lt;/h2&gt;
&lt;h2 align=&quot;left&quot;&gt;&lt;strong&gt;　　　2.题目分析&lt;/strong&gt;&lt;/h2&gt;
&lt;h2 align=&quot;left&quot;&gt;&lt;strong&gt;　　　3.功能与模块实现&lt;/strong&gt;&lt;/h2&gt;
&lt;h2 align=&quot;left&quot;&gt;&lt;strong&gt;　　　4.完整代码&lt;/strong&gt;&lt;/h2&gt;
&lt;h2&gt;&lt;strong&gt;　　　5.总结&lt;br/&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;h2 align=&quot;left&quot;&gt;&lt;strong&gt;一、题目&lt;/strong&gt;&lt;/h2&gt;
&lt;h2 align=&quot;left&quot;&gt;&lt;strong&gt;二叉树路径查找&lt;/strong&gt;&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;给定一棵二叉树(结构如下)，其中每个节点值为整数。给定一个值K，求所有满足如下条件的路径并将路径上节点的值打印出来：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;1、路径方向必须向下，即只能从父节点指向子节点&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;2、路径并不是必须从根节点开始或在叶节点结束。即树上任意节点开始向下走到任意节点的路径都允许。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;3、路径上的节点得分之和等于给定值K。节点得分=节点值+节点所在层(根节点为0，之后每层+1)。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;l  示例：给定二叉树[5,3,7,9,null,11,2,4,-1, null,null,2,-2]，K=22&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1361834/202009/1361834-20200912125235146-1612053825.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;输出：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;5 3 9 -1&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;5 7 2 2&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;3 9 4&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;解释：如第一个路径5 3 9 -1，路径上节点得分分别为5+0,3+1,9+2,-1+3,和为22&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;l  输入格式: 第一行为一个整数K，第二行为一个二叉树的层次遍历序列，其中空子树用 null 表示，每两个数字或者null之间用空格分隔，例如:&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;22&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;5 3 7 9 null 11 2 4 -1 null null 2 -2&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;需要注意的是，&lt;span&gt;null节点的子节点不会显式的写出来，如上例中第二行值为3的节点的右子树为空，则该右空子树的左右子树不会再以null表示。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;l  输出格式: 分为多行，每行为一个满足条件的路径上节点的值的序列，例如:&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;5 3 9 -1&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;5 7 2 2&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;3 9 4&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;现有如下输入：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;35&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;5 4 8 11 null 13 4 7 2 null null 5 1 8 null 7 10 6 null null null&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1361834/202009/1361834-20200912125255729-260068212.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;请用程序将正确结果输出&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;二、题目分析&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt; 1.题目表面上想要查找出所有符合条件的路径，其实更深层次考察的是，如何构造二叉树&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2.如题目所述，二叉树的&lt;span&gt;层次&lt;/span&gt;遍历序列是直接从中控台输入的，仅仅依靠此序列来&lt;span&gt;层次&lt;/span&gt;构造二叉树。这与我们以往的说法不同，通常需要两条序列（比如前序和中序）来构造二叉树，或者构造完全二叉树的时候，可以直接使用前序遍历序列。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3.题目还有一个要求，&lt;span&gt;null节点的子节点不会显式的写出来，如上例中第二行值为3的节点的右子树为空，则该右空子树的左右子树不会再以null表示。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;4.层次构造二叉树过程：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/1361834/202009/1361834-20200912165330081-2128287910.png&quot; alt=&quot;&quot; width=&quot;885&quot; height=&quot;544&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/1361834/202009/1361834-20200912165654781-1504256943.png&quot; alt=&quot;&quot; width=&quot;1001&quot; height=&quot;492&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;



&lt;p&gt; 　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/1361834/202009/1361834-20200912171116382-136819283.png&quot; alt=&quot;&quot; width=&quot;1185&quot; height=&quot;539&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;



&lt;p&gt;　　　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/1361834/202009/1361834-20200912170354597-936320971.png&quot; alt=&quot;&quot; width=&quot;994&quot; height=&quot;235&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;第五步和第六步中间红色字段很重要，这是子节点找父节点的思路&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　5.上面的分析是从上到下，按层次分析，通过父节点找其子节点，很好理解。但是代码实现无法做到这一点，我们只能由子节点找其父节点，怎么说呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　原因是，&lt;span&gt;父节点找其子节点，我们通常会想到用递归，非常简单，直接套用公式（n-NULLSUM)*2-x,这里n表示父节点下标，x表示左右（左为一，右为二），一直找下去。但是仔细会发现，这里的NULLSUM值可能不正确，&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　　　 &lt;img src=&quot;https://img2020.cnblogs.com/blog/1361834/202009/1361834-20200912174133273-947113413.png&quot; alt=&quot;&quot; width=&quot;777&quot; height=&quot;241&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1361834/202009/1361834-20200912221630237-171805120.png&quot; alt=&quot;&quot; width=&quot;854&quot; height=&quot;303&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt; 　　在递归构造二叉树的过程中，无法发做到层次构造，它更像前序遍历构造形式。比如上图，从根节点的右节点7开始，读到11，此时11节点的下标是5，&lt;/span&gt;&lt;span&gt;此时（5-NULLSUM）*2+1=11得到左子节点2的下标，这里NULLSUM为什么是0呢？11节点的前面有null节点啊，NULLSUM不应该是1吗？我们在看一下NULLSUM的定义：统计当前节点前面出现null值的节点。嗯我们理解的定义没有问题，问题出现在递归调用上，它不层次算法，而是一头扎到底再回头的那种，这就导致读到11这个节点的时候，跳过了下标为4的null节点，故NULLSUM值还是为0。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　6.基于以上问题，如何做到层次构造二叉树呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这里我想到了一个办法，那就是让子节点找父节点，这样做的好处是，一对一思想，找到父节点，就可以跳到下一个节点继续寻找其父节点。那么还有个问题，怎么知道当前节点是父节点的左节点还是右节点？其实很简单，可以在第四点的层次构造二叉树过程图中可以发现，每个节点的左节点的下标一定是奇数，右节点的下标一定是偶数，那么可以根据当前节点的下标奇偶性判断其是左节点还是右节点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　子节点找父节点，可以通过（n-NULLSUM)*2-x这个公式的逆运算算出父节点的下标n,在利用树的遍历查询，即可找到父节点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　7.不知道大家发现第六点又产生了个问题，那就是利用树的遍历查询，因为从中控台输入一连串序列，这个序列中的数可以不唯一，可重复，导致构造的树每个节点的值不唯一，那么树的遍历就不好使了。如何解决这个问题呢？其实很简单，既然节点的值不唯一，那我们可以在树的数据结构里，给节点增加一个下标变量用来标识该节点，比如：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TreeNode {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; val;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     * 由于题目给的二叉树中节点值不唯一，
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;     * 增加treeIndex做唯一标识
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; treeIndex;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对应数组下标&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; TreeNode left;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; TreeNode right;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;由于数组为String类型，需要转型为整型，方便后面运算&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; TreeNode(String x) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         val =&lt;span&gt; Integer.parseInt(x);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; TreeNode() {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &quot;TreeNode [val=&quot; + val + &quot;]&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     
&lt;span&gt;24&lt;/span&gt;     
&lt;span&gt;25&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;




&lt;h2&gt; 三、功能和模块实现&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;　　1、建立二叉树&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　1.1、寻找父节点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; TreeNode searchNode(TreeNode root,&lt;span&gt;int&lt;/span&gt; index) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;广度优先搜索,查找父节点&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(root==&lt;span&gt;null&lt;/span&gt;||index&amp;lt;0)&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         LinkedList&amp;lt;TreeNode&amp;gt; list = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;链表，这里我将其作为队列&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         list.add(root);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;把数据加入到队列尾部&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt;(!&lt;span&gt;list.isEmpty()) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             TreeNode node =&lt;span&gt; list.poll();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(node.treeIndex==&lt;span&gt;index) 
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; node;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(node.left!=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;                list.add(node.left);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(node.right!=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;                list.add(node.right);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         
&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;　　&lt;span&gt;1.2、处理传入的序列&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; TreeNode create(String[] levelOrder) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;考虑到给的数组有null值，故用String类型&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(levelOrder.length==0&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         TreeNode root = &lt;span&gt;new&lt;/span&gt; TreeNode(levelOrder[0]);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根节点&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         LinkedList&amp;lt;Integer&amp;gt; list = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;链表，这里我将其作为队列&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=1;i&amp;lt;levelOrder.length;i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(levelOrder[i]==&lt;span&gt;null&lt;/span&gt;||&quot;null&quot;&lt;span&gt;.equals(levelOrder[i])) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;                list.add(i);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             TreeNode node = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TreeNode(levelOrder[i]);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             node.treeIndex =&lt;span&gt; i;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             
&lt;span&gt;14&lt;/span&gt;             LinkedList&amp;lt;Integer&amp;gt; newList = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LinkedList();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (Iterator iterator =&lt;span&gt; list.iterator(); iterator.hasNext();) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;                newList.add((Integer) iterator.next());
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                 
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;            buildTree(root,node,i,newList,levelOrder);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; root;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;1.3、建立二叉树&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;69&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;建立树&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; TreeNode buildTree(TreeNode root,TreeNode node,&lt;span&gt;int&lt;/span&gt; i,LinkedList&amp;lt;Integer&amp;gt;&lt;span&gt; list,String[] levelOrder) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; NULLSUM =&lt;span&gt; compareIndex(list,levelOrder,i);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;         * 如题目给的示例：给定二叉树[5,3,7,9,null,11,2,4,-1, null,null,2 ,-2]
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;         *                 index： 0,1,2,3,  4 ,5 ,6,7, 8,   9 , 10 ,11,12
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;         * 
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;         *                 5
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;         *                / \
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;         *               3    7
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;         *              /    / \
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;         *          9    11  2
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;         *         / \      / \
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;         *        4   -1   2  -2
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;         * 思路:1.定义NULLSUM变量记录null节点个数
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;         *        2.通过compareIndex函数计算该节点的父节点层及以上出现null节点个数
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;         *        3.(i-2)/2+NULLSUM可以计算出该节点的父节点
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(i%2==0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             TreeNode parent = searchNode(root,(i-2)/2+&lt;span&gt;NULLSUM);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;while&lt;/span&gt;(parent==&lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                 NULLSUM++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                 parent = searchNode(root,(i-2)/2+&lt;span&gt;NULLSUM);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             parent.right =&lt;span&gt; node;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         }&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             TreeNode parent = searchNode(root,(i-1)/2+&lt;span&gt;NULLSUM);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             &lt;span&gt;while&lt;/span&gt;(parent==&lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;                 NULLSUM++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                 parent = searchNode(root,(i-1)/2+&lt;span&gt;NULLSUM);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             parent.left =&lt;span&gt; node;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         
&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; root;
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;为什么在第21和28行设立while循环判断找到的父节点是否为null？还记得下面这张图吗，父节点为null时，就会跳到下一个不为null的节点来代替指向原本父节点的子节点。逆过来，子节点找父节点，如果父节点时null,那可以跳到下一个直至不为null的父节点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1361834/202009/1361834-20200912171116382-136819283.png&quot; alt=&quot;&quot; width=&quot;1038&quot; height=&quot;472&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;　2、二叉树路径查找&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2.1、路径查找入口&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;     * 传入的参数分别为根节点root、定值K和当前节点所在层数dept(这个非常好用，因为传入的根节点有可能只是树中某节点)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; pathSumEntry(TreeNode root,&lt;span&gt;int&lt;/span&gt; K,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; dept){
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; result = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用于保存所有匹配路径&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt;         List&amp;lt;Integer&amp;gt; currentResult = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;Integer&amp;gt;();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用于保存找到的当前匹配的路径&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt; &lt;span&gt;        pathSum(root,K,currentResult,result,dept);
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;2.2、路径查找主函数&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;     * 这里主要使用递归加回溯的思想
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; pathSum(TreeNode root,&lt;span&gt;int&lt;/span&gt; K,List&amp;lt;Integer&amp;gt;currentResult,List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;result,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; dept) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(root==&lt;span&gt;null&lt;/span&gt;)&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         currentResult.add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Integer(root.val));
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(root.left==&lt;span&gt;null&lt;/span&gt;&amp;amp;&amp;amp;root.right==&lt;span&gt;null&lt;/span&gt;&amp;amp;&amp;amp;K==root.val+&lt;span&gt;dept) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             result.add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; LinkedList(currentResult));
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         }&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             pathSum(root.left,K-root.val-dept,currentResult,result,dept+1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             pathSum(root.right,K-root.val-dept,currentResult,result,dept+1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         currentResult.remove(currentResult.size()-1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;四、完整代码&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;1.树的数据结构&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_3343866c-8a9c-4b29-ab82-55dda25532c3&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_3343866c-8a9c-4b29-ab82-55dda25532c3&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_3343866c-8a9c-4b29-ab82-55dda25532c3&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TreeNode {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; val;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     * 由于题目给的二叉树中节点值不唯一，
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;     * 增加treeIndex做唯一标识
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; treeIndex;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对应数组下标&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; TreeNode left;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; TreeNode right;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;由于数组为String类型，需要转型为整型，方便后面运算&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; TreeNode(String x) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         val =&lt;span&gt; Integer.parseInt(x);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; TreeNode() {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &quot;TreeNode [val=&quot; + val + &quot;]&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     
&lt;span&gt;24&lt;/span&gt;     
&lt;span&gt;25&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;2.构造二叉树类&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54.5&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_345b4ed2-3d9e-48af-8a1e-60d308f41435&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_345b4ed2-3d9e-48af-8a1e-60d308f41435&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_345b4ed2-3d9e-48af-8a1e-60d308f41435&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;104&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BuildTree {
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt;     
&lt;span&gt;  3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; TreeNode searchNode(TreeNode root,&lt;span&gt;int&lt;/span&gt; index) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;广度优先搜索,查找父节点&lt;/span&gt;
&lt;span&gt;  4&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(root==&lt;span&gt;null&lt;/span&gt;||index&amp;lt;0)&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt;         LinkedList&amp;lt;TreeNode&amp;gt; list = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;链表，这里我将其作为队列&lt;/span&gt;
&lt;span&gt;  6&lt;/span&gt;         list.add(root);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;把数据加入到队列尾部&lt;/span&gt;
&lt;span&gt;  7&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt;(!&lt;span&gt;list.isEmpty()) {
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt;             TreeNode node =&lt;span&gt; list.poll();
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(node.treeIndex==&lt;span&gt;index) 
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; node;
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(node.left!=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt; &lt;span&gt;                list.add(node.left);
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(node.right!=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt; &lt;span&gt;                list.add(node.right);
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt;         
&lt;span&gt; 17&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt;     
&lt;span&gt; 20&lt;/span&gt;     
&lt;span&gt; 21&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; TreeNode create(String[] levelOrder) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;考虑到给的数组有null值，故用String类型&lt;/span&gt;
&lt;span&gt; 22&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(levelOrder.length==0&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt;         TreeNode root = &lt;span&gt;new&lt;/span&gt; TreeNode(levelOrder[0]);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根节点&lt;/span&gt;
&lt;span&gt; 25&lt;/span&gt;         LinkedList&amp;lt;Integer&amp;gt; list = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;链表，这里我将其作为队列&lt;/span&gt;
&lt;span&gt; 26&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=1;i&amp;lt;levelOrder.length;i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(levelOrder[i]==&lt;span&gt;null&lt;/span&gt;||&quot;null&quot;&lt;span&gt;.equals(levelOrder[i])) {
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt; &lt;span&gt;                list.add(i);
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt;                 &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt;             TreeNode node = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TreeNode(levelOrder[i]);
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt;             node.treeIndex =&lt;span&gt; i;
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt;             
&lt;span&gt; 34&lt;/span&gt;             LinkedList&amp;lt;Integer&amp;gt; newList = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LinkedList();
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (Iterator iterator =&lt;span&gt; list.iterator(); iterator.hasNext();) {
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt; &lt;span&gt;                newList.add((Integer) iterator.next());
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt;                 
&lt;span&gt; 38&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt; &lt;span&gt;            buildTree(root,node,i,newList,levelOrder);
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt;             
&lt;span&gt; 41&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; root;
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt; 
&lt;span&gt; 45&lt;/span&gt; 
&lt;span&gt; 46&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;建立树&lt;/span&gt;
&lt;span&gt; 47&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; TreeNode buildTree(TreeNode root,TreeNode node,&lt;span&gt;int&lt;/span&gt; i,LinkedList&amp;lt;Integer&amp;gt;&lt;span&gt; list,String[] levelOrder) {
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; NULLSUM =&lt;span&gt; compareIndex(list,levelOrder,i);
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 50&lt;/span&gt; &lt;span&gt;         * 如题目给的示例：给定二叉树[5,3,7,9,null,11,2,4,-1, null,null,2 ,-2]
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt; &lt;span&gt;         *                 index： 0,1,2,3,  4 ,5 ,6,7, 8,   9 , 10 ,11,12
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt; &lt;span&gt;         * 
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt; &lt;span&gt;         *                 5
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt; &lt;span&gt;         *                / \
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt; &lt;span&gt;         *               3    7
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt; &lt;span&gt;         *              /    / \
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt; &lt;span&gt;         *          9    11  2
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt; &lt;span&gt;         *         / \      / \
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt; &lt;span&gt;         *        4   -1   2  -2
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt; &lt;span&gt;         * 思路:1.定义NULLSUM变量记录null节点个数
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt; &lt;span&gt;         *        2.通过compareIndex函数计算该节点的父节点层及以上出现null节点个数
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt; &lt;span&gt;         *        3.(i-2)/2+NULLSUM可以计算出该节点的父节点
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 64&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(i%2==0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt;             TreeNode parent = searchNode(root,(i-2)/2+&lt;span&gt;NULLSUM);
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt;             &lt;span&gt;while&lt;/span&gt;(parent==&lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt;                 NULLSUM++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;                 parent = searchNode(root,(i-2)/2+&lt;span&gt;NULLSUM);
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt;             parent.right =&lt;span&gt; node;
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt;         }&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt;             TreeNode parent = searchNode(root,(i-1)/2+&lt;span&gt;NULLSUM);
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt;             &lt;span&gt;while&lt;/span&gt;(parent==&lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt;                 NULLSUM++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt;                 parent = searchNode(root,(i-1)/2+&lt;span&gt;NULLSUM);
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt;             parent.left =&lt;span&gt; node;
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt;         
&lt;span&gt; 80&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; root;
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt;     
&lt;span&gt; 83&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 84&lt;/span&gt; &lt;span&gt;     * 比较下标所指向的值，判断当前节点的父节点下标所在数组位置的值是否等于null
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt; &lt;span&gt;     * list为存储空值的下标队列，从头到尾取值，并计算比较当前节点下标比栈值的子节点大
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt; &lt;span&gt;     * 若大于，这NULLSUM++,否则停止，返回NULLSUM值
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 88&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; compareIndex(LinkedList&amp;lt;Integer&amp;gt; list,String[] order,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i) {
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; sum,NULLSUM = 0;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;记录数组中null的数量&lt;/span&gt;
&lt;span&gt; 90&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(list==&lt;span&gt;null&lt;/span&gt;&amp;amp;&amp;amp;list.size()==0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt;(!list.isEmpty()&amp;amp;&amp;amp;i&amp;gt;list.poll()*2&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt;             NULLSUM++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; NULLSUM;
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt;     
&lt;span&gt; 99&lt;/span&gt;     
&lt;span&gt;100&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　3.路径查找类&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41.5&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_37971d64-69ef-4404-8cd6-1ed68386aa2c&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_37971d64-69ef-4404-8cd6-1ed68386aa2c&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_37971d64-69ef-4404-8cd6-1ed68386aa2c&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;78&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; PathSum {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     * 传入的参数分别为根节点root、定值K和当前节点所在层数dept(这个非常好用，因为传入的根节点有可能只是树中某节点)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; pathSumEntry(TreeNode root,&lt;span&gt;int&lt;/span&gt; K,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; dept){
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; result = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用于保存所有匹配路径&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;         List&amp;lt;Integer&amp;gt; currentResult = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;Integer&amp;gt;();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用于保存找到的当前匹配的路径&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        pathSum(root,K,currentResult,result,dept);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;     * 这里主要使用递归加回溯的思想
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; pathSum(TreeNode root,&lt;span&gt;int&lt;/span&gt; K,List&amp;lt;Integer&amp;gt;currentResult,List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;result,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; dept) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(root==&lt;span&gt;null&lt;/span&gt;)&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         currentResult.add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Integer(root.val));
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(root.left==&lt;span&gt;null&lt;/span&gt;&amp;amp;&amp;amp;root.right==&lt;span&gt;null&lt;/span&gt;&amp;amp;&amp;amp;K==root.val+&lt;span&gt;dept) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             result.add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; LinkedList(currentResult));
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         }&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             pathSum(root.left,K-root.val-dept,currentResult,result,dept+1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             pathSum(root.right,K-root.val-dept,currentResult,result,dept+1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         currentResult.remove(currentResult.size()-1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　4.主函数&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_37e58ca2-0393-454a-b7ec-b301a37eb7ea&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_37e58ca2-0393-454a-b7ec-b301a37eb7ea&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_37e58ca2-0393-454a-b7ec-b301a37eb7ea&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;71&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Main {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         Scanner input = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Scanner(System.in);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         System.out.print(&quot;输入K:&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; K =&lt;span&gt; input.nextInt();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         System.out.println(&quot;输入数组(以'#'结束,例如：5 3 7 9 null 11 2 4 -1 null null 2 -2 #)&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         List&amp;lt;String&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;String&amp;gt;();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;集合接收输入串&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         String cin = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt;(!&quot;#&quot;.equals((cin=&lt;span&gt;input.next()))) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            list.add(cin);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将集合转成字符串数组&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;         String[] levelOrder = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; String[list.size()];
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;=list.size()-1;i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             levelOrder[i] =&lt;span&gt; list.get(i);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         
&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;从左到右构造二叉树，并寻找路径和等于K的路径&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;         BuildTree tree = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BuildTree();
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         TreeNode root =&lt;span&gt; tree.create(levelOrder);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         printTree(root,K,0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     
&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; printTree(TreeNode root,&lt;span&gt;int&lt;/span&gt; K,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; dept) {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(root==&lt;span&gt;null&lt;/span&gt;)&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         PathSum pathSum = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PathSum();
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt;         List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; result =&lt;span&gt; pathSum.pathSumEntry(root, K,dept);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (List resultList : result) {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;            System.out.println(resultList);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         
&lt;span&gt;35&lt;/span&gt;         printTree(root.left,K,dept+1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         printTree(root.right,K,dept+1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;


&lt;h2&gt;&lt;strong&gt;五、总结&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;span&gt;一开始我还以为这道题就是个简单的路径查找算题，采用递归加回溯算法分分钟钟就可以解决这道题，当我再仔细看题的时候，才知道这不是一道简简单单的回溯算法题。还有二叉树如何构建问题，一看到构建二叉树题，还是觉得简单，结果自己还是太嫩了！没错，这是笔者第一次做分层构造二叉树题，笔者的思考可以参考题目分析部分，这里有笔者的思考的部分过程。第一次做分层构造二叉树，所以花费了不少时间，考虑不周还望各位老师同学指点，如果大家有更好的分层构造二叉树想法，可以分享链接到评论区，比如可以直接父节点找子节点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　每日一囧，微笑面对生活，我是懂先森&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 12 Sep 2020 15:53:00 +0000</pubDate>
<dc:creator>广大青年</dc:creator>
<og:description>最近笔试做了这么一道题，想和大家分享一下我的做法 目录：1.题目 2.题目分析 3.功能与模块实现 4.完整代码 5.总结 一、题目 二叉树路径查找 给定一棵二叉树(结构如下)，其中每个节点值为整数。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/damon-dhc/p/13659367.html</dc:identifier>
</item>
<item>
<title>如何编写一个简单的Linux驱动（二）——设备操作集file_operations - 山无言</title>
<link>http://www.cnblogs.com/UnfriendlyARM/p/13659337.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/UnfriendlyARM/p/13659337.html</guid>
<description>&lt;p&gt;&lt;span&gt;前期知识&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;a href=&quot;https://www.cnblogs.com/UnfriendlyARM/p/13629905.html&quot; target=&quot;_blank&quot;&gt;如何编写一个简单的Linux驱动（一）——驱动的基本框架&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;前言&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在上一篇文章中，我们学习了驱动的基本框架。这一章，我们会在上一章代码的基础上，继续对驱动的框架进行完善。要下载上一篇文章的全部代码，请点击&lt;a href=&quot;https://github.com/shanwuyan/Linux-Drivers-Learning/tree/master/1.%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84Linux%E9%A9%B1%E5%8A%A8%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;这里&lt;/span&gt;&lt;/a&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.字符设备的四个基本操作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　驱动让用户程序具备操作硬件设备的能力，那么对硬件设备有哪些操作呢？在学习编程语言时，我们都学过对文件的操作，包括打开文件、关闭文件、读文件、写文件这四个基本操作。对于Linux来说，一切设备皆文件，所以对设备的基本操作也可以分为打开、关闭、读、写这四个。而对于设备（已字符设备为例），Linux提供了一个操作集合——file_operarions。file_operations是一个结构体，其原型如下。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;102&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; file_operations {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;struct&lt;/span&gt; module *&lt;span&gt;owner;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     loff_t (*llseek) (&lt;span&gt;struct&lt;/span&gt; file *, loff_t, &lt;span&gt;int&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     ssize_t (*read) (&lt;span&gt;struct&lt;/span&gt; file *, &lt;span&gt;char&lt;/span&gt; __user *, size_t, loff_t *&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     ssize_t (*write) (&lt;span&gt;struct&lt;/span&gt; file *, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; __user *, size_t, loff_t *&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     ssize_t (*read_iter) (&lt;span&gt;struct&lt;/span&gt; kiocb *, &lt;span&gt;struct&lt;/span&gt; iov_iter *&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     ssize_t (*write_iter) (&lt;span&gt;struct&lt;/span&gt; kiocb *, &lt;span&gt;struct&lt;/span&gt; iov_iter *&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; (*iterate) (&lt;span&gt;struct&lt;/span&gt; file *, &lt;span&gt;struct&lt;/span&gt; dir_context *&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; (*iterate_shared) (&lt;span&gt;struct&lt;/span&gt; file *, &lt;span&gt;struct&lt;/span&gt; dir_context *&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     unsigned &lt;span&gt;int&lt;/span&gt; (*poll) (&lt;span&gt;struct&lt;/span&gt; file *, &lt;span&gt;struct&lt;/span&gt; poll_table_struct *&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;long&lt;/span&gt; (*unlocked_ioctl) (&lt;span&gt;struct&lt;/span&gt; file *, unsigned &lt;span&gt;int&lt;/span&gt;, unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;long&lt;/span&gt; (*compat_ioctl) (&lt;span&gt;struct&lt;/span&gt; file *, unsigned &lt;span&gt;int&lt;/span&gt;, unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; (*mmap) (&lt;span&gt;struct&lt;/span&gt; file *, &lt;span&gt;struct&lt;/span&gt; vm_area_struct *&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; (*open) (&lt;span&gt;struct&lt;/span&gt; inode *, &lt;span&gt;struct&lt;/span&gt; file *&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; (*flush) (&lt;span&gt;struct&lt;/span&gt; file *&lt;span&gt;, fl_owner_t id);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; (*release) (&lt;span&gt;struct&lt;/span&gt; inode *, &lt;span&gt;struct&lt;/span&gt; file *&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; (*fsync) (&lt;span&gt;struct&lt;/span&gt; file *, loff_t, loff_t, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; datasync);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; (*fasync) (&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;struct&lt;/span&gt; file *, &lt;span&gt;int&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; (*&lt;span&gt;lock&lt;/span&gt;) (&lt;span&gt;struct&lt;/span&gt; file *, &lt;span&gt;int&lt;/span&gt;, &lt;span&gt;struct&lt;/span&gt; file_lock *&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     ssize_t (*sendpage) (&lt;span&gt;struct&lt;/span&gt; file *, &lt;span&gt;struct&lt;/span&gt; page *, &lt;span&gt;int&lt;/span&gt;, size_t, loff_t *, &lt;span&gt;int&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     unsigned &lt;span&gt;long&lt;/span&gt; (*get_unmapped_area)(&lt;span&gt;struct&lt;/span&gt; file *, unsigned &lt;span&gt;long&lt;/span&gt;, unsigned &lt;span&gt;long&lt;/span&gt;, unsigned &lt;span&gt;long&lt;/span&gt;, unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; (*check_flags)(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; (*flock) (&lt;span&gt;struct&lt;/span&gt; file *, &lt;span&gt;int&lt;/span&gt;, &lt;span&gt;struct&lt;/span&gt; file_lock *&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     ssize_t (*splice_write)(&lt;span&gt;struct&lt;/span&gt; pipe_inode_info *, &lt;span&gt;struct&lt;/span&gt; file *, loff_t *, size_t, unsigned &lt;span&gt;int&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     ssize_t (*splice_read)(&lt;span&gt;struct&lt;/span&gt; file *, loff_t *, &lt;span&gt;struct&lt;/span&gt; pipe_inode_info *, size_t, unsigned &lt;span&gt;int&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; (*setlease)(&lt;span&gt;struct&lt;/span&gt; file *, &lt;span&gt;long&lt;/span&gt;, &lt;span&gt;struct&lt;/span&gt; file_lock **, &lt;span&gt;void&lt;/span&gt; **&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;long&lt;/span&gt; (*fallocate)(&lt;span&gt;struct&lt;/span&gt; file *file, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; mode, loff_t offset,
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;              loff_t len);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; (*show_fdinfo)(&lt;span&gt;struct&lt;/span&gt; seq_file *m, &lt;span&gt;struct&lt;/span&gt; file *&lt;span&gt;f);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;#ifndef CONFIG_MMU
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     unsigned (*mmap_capabilities)(&lt;span&gt;struct&lt;/span&gt; file *&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;     ssize_t (*copy_file_range)(&lt;span&gt;struct&lt;/span&gt; file *, loff_t, &lt;span&gt;struct&lt;/span&gt; file *&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             loff_t, size_t, unsigned &lt;span&gt;int&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; (*clone_file_range)(&lt;span&gt;struct&lt;/span&gt; file *, loff_t, &lt;span&gt;struct&lt;/span&gt; file *&lt;span&gt;, loff_t,
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;            u64);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;     ssize_t (*dedupe_file_range)(&lt;span&gt;struct&lt;/span&gt; file *, u64, u64, &lt;span&gt;struct&lt;/span&gt; file *&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;            u64);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; } 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　要使用该结构体，需要包含头文件&quot;linux/fs.h&quot;。该结构体中的成员变量很多，但在本章中，我们只用到打开(open)、关闭(release)、读(read)、写(write)这四个成员变量，以及一个默认需要的所有者(owner)成员变量。　　　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; file_operations {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    ...
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;struct&lt;/span&gt; module *&lt;span&gt;owner;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; (*open) (&lt;span&gt;struct&lt;/span&gt; inode *, &lt;span&gt;struct&lt;/span&gt; file *&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; (*release) (&lt;span&gt;struct&lt;/span&gt; inode *, &lt;span&gt;struct&lt;/span&gt; file *&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     ssize_t (*read) (&lt;span&gt;struct&lt;/span&gt; file *, &lt;span&gt;char&lt;/span&gt; __user *, size_t, loff_t *&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;     ssize_t (*write) (&lt;span&gt;struct&lt;/span&gt; file *, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; __user *, size_t, loff_t *&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt;    ...
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　file_operations结构体的成员变量向应用程序提供一个对设备操作的接口，但是接口的具体操作需要我们自己来实现。打开上一章所写的驱动源代码&quot;shanwuyan.c&quot;，定义一个&quot;file_operations&quot;类型的结构体，再定义四个函数&quot;shanwuyan_open&quot;、&quot;shanwuyan_release&quot;、&quot;shanwuyan_read&quot;、&quot;shanwuyan_write&quot;，让file_operations结构体变量的成员变量初始化为这四个函数。　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;打开设备&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; shanwuyan_open(&lt;span&gt;struct&lt;/span&gt; inode *inode, &lt;span&gt;struct&lt;/span&gt; file *&lt;span&gt;filp)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;释放（关闭）设备&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; shanwuyan_release(&lt;span&gt;struct&lt;/span&gt; inode *inode, &lt;span&gt;struct&lt;/span&gt; file *&lt;span&gt;filp)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;读设备&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ssize_t shanwuyan_read(&lt;span&gt;struct&lt;/span&gt; file *filp, &lt;span&gt;char&lt;/span&gt; __user *buf, size_t count, loff_t *&lt;span&gt;ppos)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;写设备&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ssize_t shanwuyan_write(&lt;span&gt;struct&lt;/span&gt; file *filp, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; __user *buf, size_t count, loff_t *&lt;span&gt;ppos)
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; file_operations shanwuyan_fops = 
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     .owner = THIS_MODULE,            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;默认&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;     .open = shanwuyan_open,            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;打开设备&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;     .release = shanwuyan_release,    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭设备&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;     .read = shanwuyan_read,            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;读设备&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;     .write = shanwuyan_write,        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;写设备&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt; };
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这样，用户在使用库函数&quot;open&quot;打开设备时，就会调用函数&quot;shanwuyan_open&quot;；用&quot;close&quot;函数关闭设备时，就会调用函数&quot;shanwuyan_release&quot;；用&quot;read&quot;函数读设备时，就会调用函数&quot;shanwuyan_read&quot;；用&quot;write&quot;函数写设备时，就会调用函数&quot;shanwuyan_write&quot;。为了让这四个函数的调用更直观地为程序员所观察，我们可以在这四个函数中添加打印语句，这样每次对设备进行操作的时候，程序员都能在终端观察到相应的信息，如下方代码。　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;打开设备&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; shanwuyan_open(&lt;span&gt;struct&lt;/span&gt; inode *inode, &lt;span&gt;struct&lt;/span&gt; file *&lt;span&gt;filp)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     printk(KERN_EMERG &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;shanwuyan_open\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;释放（关闭）设备&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; shanwuyan_release(&lt;span&gt;struct&lt;/span&gt; inode *inode, &lt;span&gt;struct&lt;/span&gt; file *&lt;span&gt;filp)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     printk(KERN_EMERG &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;shanwuyan_close\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;读设备&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ssize_t shanwuyan_read(&lt;span&gt;struct&lt;/span&gt; file *filp, &lt;span&gt;char&lt;/span&gt; __user *buf, size_t count, loff_t *&lt;span&gt;ppos)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     printk(KERN_EMERG &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;shanwuyan_read\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;写设备&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ssize_t shanwuyan_write(&lt;span&gt;struct&lt;/span&gt; file *filp, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; __user *buf, size_t count, loff_t *&lt;span&gt;ppos)
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     printk(KERN_EMERG &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;shanwuyan_write\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2.注册与注销字符设备&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　字符设备的注册是在入口函数&quot;shanwuyan_init&quot;中完成的，字符设备的注销是在出口函数&quot;shanwuyan_exit&quot;中完成的。在上一篇文章中，这两个函数的作用只是打印一行字符串，并没有注册和注销字符设备的功能。在本章，我们将完善这两个函数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　首先介绍一个函数&quot;register_chrdev&quot;，函数原型如下。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; inline &lt;span&gt;int&lt;/span&gt; register_chrdev(unsigned &lt;span&gt;int&lt;/span&gt; major, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;name, &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; file_operations *fops);    &lt;span&gt;//major是主设备号，name是设备名，fops是字符设备操作集的地址&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　该函数的作用是注册字符设备，设备号为程序员给定的一个主设备号major，设备名为用户给定的一个字符串，字符操作集为上文中定义的结构体地址。如果函数该函数返回值为负数，说明设备注册失败，否则说明设备注册成功。&lt;/p&gt;
&lt;p&gt;　　接下来介绍注销字符设备的函数&quot;unregister_chrdev&quot;，该函数的原型如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; inline &lt;span&gt;void&lt;/span&gt; unregister_chrdev(unsigned &lt;span&gt;int&lt;/span&gt; major, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *name);    &lt;span&gt;//major是主设备号，name是设备名&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　该函数的作用是注销字符设备。&lt;/p&gt;
&lt;p&gt;　　打开开发板的系统终端，输入命令&quot;cat /proc/devices&quot;可以查看有哪些设备号已经被占用。经过查看，本系统的设备号&quot;200&quot;处于空闲状态，可以用来注册字符设备。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　完善入口函数和出口函数，代码如下。&lt;/span&gt;&lt;span&gt;　&lt;/span&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;...
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; SHANWUYAN_MAJOR 200    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;程序员给定的主设备号&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; SHANWUYAN_NAME &quot;shanwuyan&quot;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;程序员给定的设备名字符串&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;...
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; file_operations shanwuyan_fops = 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    ...
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; }   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义的字符设备操作集&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; __init shanwuyan_init(&lt;span&gt;void&lt;/span&gt;)    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;驱动入口函数&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; ret = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;  
&lt;span&gt;13&lt;/span&gt;     ret = register_chrdev(SHANWUYAN_MAJOR, SHANWUYAN_NAME, &amp;amp;&lt;span&gt;shanwuyan_fops);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(ret &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         printk(KERN_EMERG &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;init failed\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;注册失败&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         printk(KERN_EMERG &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;shanwuyan_init\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注册成功&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; __exit shanwuyan_exit(&lt;span&gt;void&lt;/span&gt;)    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;驱动出口函数&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     unregister_chrdev(SHANWUYAN_MAJOR, SHANWUYAN_NAME);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;注销字符设备&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;     printk(KERN_EMERG &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;shanwuyan_exit\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; ...
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span&gt;　　这样，一个字符设备驱动的雏形就完成了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.编写应用程序&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　编写一个应用程序，包含对设备的打开、关闭、读和写的操作。源代码如下&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;文件名为&quot;shanwuyan_APP.c&quot;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; #include &amp;lt;sys/types.h&amp;gt;
&lt;span&gt; 3&lt;/span&gt; #include &amp;lt;sys/stat.h&amp;gt;
&lt;span&gt; 4&lt;/span&gt; #include &amp;lt;fcntl.h&amp;gt;
&lt;span&gt; 5&lt;/span&gt; #include &amp;lt;stdio.h&amp;gt;
&lt;span&gt; 6&lt;/span&gt; #include &amp;lt;unistd.h&amp;gt;
&lt;span&gt; 7&lt;/span&gt; #include &amp;lt;stdlib.h&amp;gt;
&lt;span&gt; 8&lt;/span&gt; #include &amp;lt;&lt;span&gt;string&lt;/span&gt;.h&amp;gt;
&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;*argc:应用程序参数个数，包括应用程序本身
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;*argv[]:具体的参数内容，字符串形式
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;*./shanwuyan_APP &amp;lt;filename&amp;gt; &amp;lt;r:w&amp;gt;    r表示读，w表示写
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;argv[])
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; ret = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; fd = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;filename;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(argc != &lt;span&gt;3&lt;/span&gt;)    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;共有三个参数&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Error usage!\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         
&lt;span&gt;27&lt;/span&gt;     filename = argv[&lt;span&gt;1&lt;/span&gt;];    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取文件名称&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt;     fd =&lt;span&gt; open(filename, O_RDWR);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(fd &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cannot open file %s\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, filename);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(!strcmp(argv[&lt;span&gt;2&lt;/span&gt;], &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;))    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;读设备&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         
&lt;span&gt;39&lt;/span&gt;         read(fd, NULL, &lt;span&gt;0&lt;/span&gt;);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;只是使用读函数，但不读出数据&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(!strcmp(argv[&lt;span&gt;2&lt;/span&gt;], &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;))    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;写设备&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;         write(fd, NULL, &lt;span&gt;0&lt;/span&gt;);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;只是使用写函数，但并不向设备写数据&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt; 
&lt;span&gt;45&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;47&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ERROR usage!\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; 
&lt;span&gt;51&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;关闭设备&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;52&lt;/span&gt; &lt;span&gt;    close(fd);
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; 
&lt;span&gt;54&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;4.应用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　编译驱动文件，交叉编译应用程序，拷贝到开发板中，并加载驱动。&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;　　驱动加载完成后，使用命令&quot;mknod /dev/shanwuyan c 200 0&quot;，在&quot;/dev&quot;目录下创建&quot;shanwuyan&quot;设备节点。其中参数&quot;c&quot;是指创建一个字符设备节点，200表示主设备号，0表示次设备号。然后使用ls命令查看是否创建成功。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503563/202009/1503563-20200912224118784-593477674.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　分别输入命令&quot;./shanwuyan_APP /dev/shanwuyan r&quot;和命令&quot;./shanwuyan_APP /dev/shanwuyan w&quot;，可以看到终端打印了如下信息。可以看到，应用程序打开设备、关闭设备、读设备、写设备的操作都有所体现。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503563/202009/1503563-20200912224333510-1813223613.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在本章中，我们只是单纯得调用了read和write函数，但是并没有真正的读写数据。读写数据操作将在下一章中出现。&lt;/p&gt;
&lt;p&gt;　　本章的全部代码在&lt;a href=&quot;https://github.com/shanwuyan/Linux-Drivers-Learning/tree/master/2.%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84Linux%E9%A9%B1%E5%8A%A8%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E8%AE%BE%E5%A4%87%E6%93%8D%E4%BD%9C%E9%9B%86file_operations&quot; target=&quot;_blank&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;

</description>
<pubDate>Sat, 12 Sep 2020 15:37:00 +0000</pubDate>
<dc:creator>山无言</dc:creator>
<og:description>前期知识 如何编写一个简单的Linux驱动（一）——驱动的基本框架 前言 在上一篇文章中，我们学习了驱动的基本框架。这一章，我们会在上一章代码的基础上，继续对驱动的框架进行完善。要下载上一篇文章的全部</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/UnfriendlyARM/p/13659337.html</dc:identifier>
</item>
<item>
<title>基于 ramfs 的 OTA - zqb-all</title>
<link>http://www.cnblogs.com/zqb-all/p/13659306.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zqb-all/p/13659306.html</guid>
<description>&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;
&lt;p&gt;默认的 &lt;code&gt;OTA&lt;/code&gt; 方案是基于 &lt;code&gt;recovery&lt;/code&gt; 系统完成的。某个产品考虑产品形态和 &lt;code&gt;flash&lt;/code&gt; 容量之后，计划去掉 &lt;code&gt;recovery&lt;/code&gt; 系统（不考虑掉电安全），这就需要 &lt;code&gt;OTA&lt;/code&gt; 方案能支持在只有单个系统的情况下完成升级动作。&lt;/p&gt;
&lt;h2 id=&quot;默认的-recovery-系统方式&quot;&gt;默认的 recovery 系统方式&lt;/h2&gt;
&lt;p&gt;先介绍下默认使用的基于 &lt;code&gt;recovery&lt;/code&gt; 系统的升级方式。&lt;/p&gt;
&lt;p&gt;主系统由内核和根文件系统组成，分别保存在 &lt;code&gt;flash&lt;/code&gt; 上的 &lt;code&gt;kenrel&lt;/code&gt; 和 &lt;code&gt;rootfs&lt;/code&gt; 分区。另外设置一个 &lt;code&gt;recovery&lt;/code&gt; 分区，用于保存 &lt;code&gt;recovery&lt;/code&gt; 系统。&lt;/p&gt;
&lt;p&gt;此处的 &lt;code&gt;recovery&lt;/code&gt; 系统，是一个带 &lt;code&gt;initramfs&lt;/code&gt; 的内核，&lt;code&gt;OTA&lt;/code&gt; 所需的应用和库都包含在 &lt;code&gt;initramfs&lt;/code&gt; 中，因此启动到 &lt;code&gt;recovery&lt;/code&gt; 系统之后，可不再依赖 &lt;code&gt;flash&lt;/code&gt; 上的其他分区。&lt;/p&gt;
&lt;p&gt;当需要进行系统升级时，先设置标志并重启，&lt;code&gt;bootloader&lt;/code&gt; 检测到标志后会启动进入 &lt;code&gt;recovery&lt;/code&gt;系统。在 &lt;code&gt;recovery&lt;/code&gt; 系统中，&lt;code&gt;kernel&lt;/code&gt; 和 &lt;code&gt;rootfs&lt;/code&gt; 分区都是处于未使用状态，直接将新的数据写入分区中即可。&lt;/p&gt;
&lt;p&gt;更新完主系统之后，设置标志，重启到新的主系统即可。&lt;/p&gt;
&lt;h2 id=&quot;没有-recovery-带来的问题&quot;&gt;没有 recovery 带来的问题&lt;/h2&gt;
&lt;p&gt;系统默认是将 &lt;code&gt;flash&lt;/code&gt; 上的 &lt;code&gt;rootfs&lt;/code&gt; 分区挂载为根文件系统，即系统运行时随时都可能会读写 &lt;code&gt;rootfs&lt;/code&gt; 分区的数据。&lt;/p&gt;
&lt;p&gt;若 &lt;code&gt;OTA&lt;/code&gt; 不重启到 &lt;code&gt;recovery&lt;/code&gt; 系统中，直接在正常系统中，即在 &lt;code&gt;rootfs&lt;/code&gt; 分区仍被挂载为根文件系统的情况下，直接从块设备接口将数据写入 &lt;code&gt;rootfs&lt;/code&gt; 分区，会有概率导致系统崩溃。&lt;/p&gt;
&lt;p&gt;毕竟 &lt;code&gt;OTA&lt;/code&gt; 应用和库本身都是放在 &lt;code&gt;rootfs&lt;/code&gt; 中的，系统其他活跃进程也随时有可能对文件系统发出请求。&lt;/p&gt;
&lt;h2 id=&quot;基于-initramfs-的解决方式&quot;&gt;基于 initramfs 的解决方式&lt;/h2&gt;
&lt;p&gt;问题很明确，不能再挂载着rootfs的时候更新 &lt;code&gt;rootfs&lt;/code&gt;，那先考虑下，在挂载 &lt;code&gt;rootfs&lt;/code&gt; 之前进行&lt;code&gt;OTA&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;原本的内核是直接在内核初始化之后挂载 &lt;code&gt;flash&lt;/code&gt; 上的 &lt;code&gt;rootfs&lt;/code&gt; 分区作为根文件系统。现在 &lt;code&gt;recovery&lt;/code&gt; 系统没了，但我们可以借鉴 &lt;code&gt;recovery&lt;/code&gt; 系统的形式，为这个内核加上 &lt;code&gt;initramfs&lt;/code&gt;，在其中包含 &lt;code&gt;OTA&lt;/code&gt; 所需的程序。&lt;/p&gt;
&lt;p&gt;存在&lt;code&gt;initramfs&lt;/code&gt;的情况下，启动时内核会先挂载 &lt;code&gt;initramfs&lt;/code&gt; 并执行 &lt;code&gt;rdinit&lt;/code&gt; 指定的程序，到了 &lt;code&gt;initramfs&lt;/code&gt; 的 &lt;code&gt;init&lt;/code&gt; 脚本中，就可以判断是正常启动还是 &lt;code&gt;OTA&lt;/code&gt; 了，若为正常启动则直接挂载 &lt;code&gt;rootfs&lt;/code&gt; 分区，并进行根文件系统切换，后续的流程就跟原方案的主系统启动流程一致了。&lt;/p&gt;
&lt;p&gt;若判断到正在进行 &lt;code&gt;OTA&lt;/code&gt;，则转而执行 &lt;code&gt;OTA&lt;/code&gt; 流程，将新的数据写入 &lt;code&gt;kernel&lt;/code&gt; 和 &lt;code&gt;rootfs&lt;/code&gt; 分区，此时的环境跟原方案的 &lt;code&gt;recovery&lt;/code&gt; 系统是一样的。&lt;/p&gt;
&lt;p&gt;这种方案的优点是跟之前的流程较为类似，可复用一些成果。缺点是内核带上 &lt;code&gt;initramfs&lt;/code&gt; 之后，不可避免地体积会变大，启动时间会变长。&lt;/p&gt;
&lt;h2 id=&quot;关于标志传递&quot;&gt;关于标志传递&lt;/h2&gt;
&lt;p&gt;如何告知 &lt;code&gt;initramfs&lt;/code&gt; 中的启动脚本，当前需要进行 &lt;code&gt;OTA&lt;/code&gt; 呢？&lt;/p&gt;
&lt;p&gt;方式一：通过自定义分区传递标志，在 &lt;code&gt;flash&lt;/code&gt; 上的划定某个分区，例如划定一个 &lt;code&gt;misc&lt;/code&gt; 分区，约定好标志，&lt;code&gt;OTA&lt;/code&gt; 时更新其中的标志即可&lt;/p&gt;
&lt;p&gt;方式二：通过 &lt;code&gt;uboot&lt;/code&gt; 的 &lt;code&gt;env&lt;/code&gt; 分区传递标志，&lt;code&gt;uboot&lt;/code&gt; 原生提供了可以在 &lt;code&gt;linux&lt;/code&gt; 用户空间读写 &lt;code&gt;env&lt;/code&gt; 分区的应用，编译后使用 &lt;code&gt;fw_printenv&lt;/code&gt; 和 &lt;code&gt;fw_setenv&lt;/code&gt; 应用即可。详见 &lt;code&gt;uboot&lt;/code&gt; 文档。&lt;/p&gt;
&lt;p&gt;方式三：通过&lt;code&gt;cmdline&lt;/code&gt;传递标志，&lt;code&gt;initramfs&lt;/code&gt;可直接读取方式一和二设置的标志，也可以请 &lt;code&gt;bootloader&lt;/code&gt; 约定好，由&lt;code&gt;bootloader&lt;/code&gt;检测到方式一和二设置的标志后，修改传递给 &lt;code&gt;kernel&lt;/code&gt; 的 &lt;code&gt;cmdline&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;方式四：通过芯片提供的寄存器传递标志。例如某些芯片的 &lt;code&gt;RTC&lt;/code&gt; 模块中，会预留一些寄存器，供用户自定义使用，不掉电重启数据是不会丢的。&lt;/p&gt;
&lt;h2 id=&quot;基于临时-ramfs-的解决方式&quot;&gt;基于临时 ramfs 的解决方式&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;initramfs&lt;/code&gt; 是在挂载 &lt;code&gt;rootfs&lt;/code&gt; 之前进行 &lt;code&gt;OTA&lt;/code&gt;，那有没有办法在挂载 &lt;code&gt;rootfs&lt;/code&gt; 之后进行 &lt;code&gt;OTA&lt;/code&gt; 呢？也是有的，先把 &lt;code&gt;rootfs&lt;/code&gt; 分区卸载掉就可以了。&lt;/p&gt;
&lt;p&gt;当然，直接 &lt;code&gt;umount&lt;/code&gt; 是不行的，&lt;code&gt;rootfs&lt;/code&gt; 分区现在还是尊贵的根文件系统，要想卸载，就得先切换到另一个根文件系统去。那另外的根文件系统从何而来呢？没有现成的，但可以造！&lt;/p&gt;
&lt;p&gt;我们看看 &lt;code&gt;openwrt&lt;/code&gt; 如何做的。切换根文件之前，先调用 &lt;code&gt;kill_remaining&lt;/code&gt; 函数 &lt;code&gt;kill&lt;/code&gt; 掉无关进程，这样可以让构造的 &lt;code&gt;ramfs&lt;/code&gt; 只需包含 &lt;code&gt;OTA&lt;/code&gt; 所需的应用和库。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;kill_remaining() { # [ &amp;lt;signal&amp;gt; [ &amp;lt;loop&amp;gt; ] ]
        local loop_limit=10

        local sig=&quot;${1:-TERM}&quot;
        local loop=&quot;${2:-0}&quot;
        local run=true
        local stat
        local proc_ppid=$(cut -d' ' -f4  /proc/$$/stat)

        echo -n &quot;Sending $sig to remaining processes ... &quot;

        while $run; do
                run=false
                for stat in /proc/[0-9]*/stat; do
                        [ -f &quot;$stat&quot; ] || continue

                        local pid name state ppid rest
                        read pid name state ppid rest &amp;lt; $stat
                        name=&quot;${name#(}&quot;; name=&quot;${name%)}&quot;

                        # Skip PID1, our parent, ourself and our children
                        [ $pid -ne 1 -a $pid -ne $proc_ppid -a $pid -ne $$ -a $ppid -ne $$ ] || continue

                        local cmdline
                        read cmdline &amp;lt; /proc/$pid/cmdline

                        # Skip kernel threads
                        [ -n &quot;$cmdline&quot; ] || continue

                        echo -n &quot;$name &quot;
                        kill -$sig $pid 2&amp;gt;/dev/null

                        [ $loop -eq 1 ] &amp;amp;&amp;amp; run=true
                done

                let loop_limit--
                [ $loop_limit -eq 0 ] &amp;amp;&amp;amp; {
                        echo
                        echo &quot;Failed to kill all processes.&quot;
                        exit 1
                }
        done
        echo
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后拷贝所需文件到 &lt;code&gt;ram&lt;/code&gt; 中，构造出所需的 &lt;code&gt;ramfs&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;switch_to_ramfs() {
         # 将一些基础文件拷贝到ram中，构造ramfs
        for binary in \
                /bin/busybox /bin/ash /bin/sh /bin/mount /bin/umount    \
                pivot_root mount_root reboot sync kill sleep            \
                md5sum hexdump cat zcat bzcat dd tar                    \
                ls basename find cp mv rm mkdir rmdir mknod touch chmod \
                '[' printf wc grep awk sed cut                          \
                mtd partx losetup mkfs.ext4 nandwrite flash_erase       \
                ubiupdatevol ubiattach ubiblock ubiformat               \
                ubidetach ubirsvol ubirmvol ubimkvol                    \
                snapshot snapshot_tool                                  \
                # 除了上面列出来的，还可以将自定义的一些文件赋值到 $RAMFS_COPY_BIN 中，这样就无需改动官方的这份文件
                $RAMFS_COPY_BIN
        do
                local file=&quot;$(which &quot;$binary&quot; 2&amp;gt;/dev/null)&quot;
                [ -n &quot;$file&quot; ] &amp;amp;&amp;amp; install_bin &quot;$file&quot;
        done
        install_file /etc/resolv.conf /lib/*.sh /lib/functions/*.sh /lib/upgrade/*.sh /lib/upgrade/do_stage2 /usr/share/libubox/jshn.sh $RAMFS_COPY_DATA

        [ -L &quot;/lib64&quot; ] &amp;amp;&amp;amp; ln -s /lib $RAM_ROOT/lib64
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着进行关键的根文件系统切换&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;     supivot $RAM_ROOT /mnt || {
                echo &quot;Failed to switch over to ramfs. Please reboot.&quot;
                exit 1
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;切换后收个尾&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        #原本的根文件系统，变成挂载在 /mnt 下，现在可以卸载掉
        /bin/mount -o remount,ro /mnt
        /bin/umount -l /mnt

        grep /overlay /proc/mounts &amp;gt; /dev/null &amp;amp;&amp;amp; {
                /bin/mount -o noatime,remount,ro /overlay
                /bin/umount -l /overlay
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后在 &lt;code&gt;ramfs&lt;/code&gt; 中调用真正的 &lt;code&gt;OTA&lt;/code&gt; 命令&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# Exec new shell from ramfs
exec /bin/busybox ash -c &quot;$COMMAND&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种做法的好处是，避免了 &lt;code&gt;intiramfs&lt;/code&gt; 带来的体积和启动速度问题，且 &lt;code&gt;OTA&lt;/code&gt; 过程只有一次重启。&lt;/p&gt;
&lt;p&gt;更具体请参考 &lt;code&gt;openwrt&lt;/code&gt; 官方的升级脚本（旧版本搜索&lt;code&gt;run_ramfs&lt;/code&gt;，新版本搜索 &lt;code&gt;switch_to_ramfs&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;毕竟是 &lt;code&gt;shell&lt;/code&gt; 脚本，很容易便可以移植到其他的环境中使用的。&lt;/p&gt;
</description>
<pubDate>Sat, 12 Sep 2020 15:29:00 +0000</pubDate>
<dc:creator>zqb-all</dc:creator>
<og:description>背景 默认的 OTA 方案是基于 recovery 系统完成的。某个产品考虑产品形态和 flash 容量之后，计划去掉 recovery 系统（不考虑掉电安全），这就需要 OTA 方案能支持在只有单个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zqb-all/p/13659306.html</dc:identifier>
</item>
</channel>
</rss>