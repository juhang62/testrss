<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>JavaCV FFmpeg采集摄像头YUV数据 - HiIT青年</title>
<link>http://www.cnblogs.com/itqn/p/13789079.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/itqn/p/13789079.html</guid>
<description>&lt;p&gt;前阵子使用利用树莓派搭建了一个视频监控平台（&lt;a href=&quot;https://www.cnblogs.com/itqn/p/13268916.html&quot;&gt;传送门&lt;/a&gt;），不过使用的是JavaCV封装好的&lt;code&gt;OpenCVFrameGrabber&lt;/code&gt;和&lt;code&gt;FFmpegFrameRecorder&lt;/code&gt;。&lt;br/&gt;其实在&lt;code&gt;javacpp&lt;/code&gt;项目集中有提供FFmpeg的JNI封装，可以直接使用FFmpeg API的来处理音视频数据，下面是一个简单的案例，通过FFmpeg API采集摄像头的YUV数据。&lt;/p&gt;
&lt;p&gt;javacpp-ffmpeg依赖：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.bytedeco.javacpp-presets&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;ffmpeg&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;${ffmpeg.version}&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;1-查找摄像头设备&quot;&gt;1. 查找摄像头设备&lt;/h5&gt;
&lt;p&gt;要采集摄像头的YUV数据，首先得知道摄像头的设备名称，可以通过FFmpeg来查找摄像头设备。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;ffmpeg.exe -list_devices true -f dshow -i dummy  
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在我的电脑上结果显示如下：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2083963/202010/2083963-20201009210929517-1932731965.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中 “Integrated Camera” 就是摄像头的设备名称。&lt;/p&gt;
&lt;h5 id=&quot;2-利用ffmpeg解码&quot;&gt;2. 利用FFmpeg解码&lt;/h5&gt;
&lt;p&gt;采集摄像头数据即将摄像头作为视频流输入，通过FFmpeg解码获取视频帧，然后将视频帧转为YUV格式，最后将数据写入文件即可。&lt;br/&gt;下面是FFmpeg解码的流程:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2083963/202010/2083963-20201009212028133-396691014.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;3-开发视频帧采集器&quot;&gt;3. 开发视频帧采集器&lt;/h5&gt;
&lt;p&gt;根据FFmpeg的解码流程，实现视频帧采集器大概需要经过以下几个步骤：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;FFmpeg初始化&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先需要使用&lt;code&gt;av_register_all()&lt;/code&gt;这个函数完成编码器和解码器的初始化，只有初始化了编码器和解码器才能正常使用；另外要采集的是设备，所以还需要调用&lt;code&gt;avdevice_register_all()&lt;/code&gt;完成初始化。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;分配AVFormatContext&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接着需要分配一个AVFormatContext，可以通过&lt;code&gt;avformat_alloc_context()&lt;/code&gt;来分配AVFormatContext。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;pFormatCtx = avformat_alloc_context();
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;打开视频流&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通过&lt;code&gt;avformat_open_input()&lt;/code&gt;来打开视频流，这里需要注意的是input format要指定为&lt;code&gt;dshow&lt;/code&gt;，可以通过&lt;code&gt;av_find_input_format(&quot;dshow&quot;)&lt;/code&gt;获取AVInputFormat对象。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;ret = avformat_open_input(pFormatCtx, String.format(&quot;video=%s&quot;, input), av_find_input_format(&quot;dshow&quot;), (AVDictionary) null);
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;查找视频流&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;需要注意的是，查找视频流之前需要调用&lt;code&gt;avformat_find_stream_info()&lt;/code&gt;，下面是查找视频流的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;ret = avformat_find_stream_info(pFormatCtx, (AVDictionary) null);
for (int i = 0; i &amp;lt; pFormatCtx.nb_streams(); i++) {
    if (pFormatCtx.streams(i).codec().codec_type() == AVMEDIA_TYPE_VIDEO) {
        videoIdx = i;
        break;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;打开解码器&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以通过视频流来查找解码器，然后打开解码器，对视频流进行解码，Java代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;pCodecCtx = pFormatCtx.streams(videoIdx).codec();
pCodec = avcodec_find_decoder(pCodecCtx.codec_id());
if (pCodec == null) {
    throw new FFmpegException(&quot;没有找到合适的解码器：&quot; + pCodecCtx.codec_id());
}
// 打开解码器
ret = avcodec_open2(pCodecCtx, pCodec, (AVDictionary) null);
if (ret != 0) {
    throw new FFmpegException(ret, &quot;avcodec_open2 解码器打开失败&quot;);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;采集视频帧&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最后就是采集视频帧了，这里需要注意的是采集摄像头的视频流解码得到的不一定是YUV格式的视频帧，所以需要对视频帧进行转化一下（videoConverter.scale(pFrame)）。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public AVFrame grab() throws FFmpegException {
    if (av_read_frame(pFormatCtx, pkt) &amp;gt;= 0 &amp;amp;&amp;amp; pkt.stream_index() == videoIdx) {
        ret = avcodec_decode_video2(pCodecCtx, pFrame, got, pkt);
        if (ret &amp;lt; 0) {
            throw new FFmpegException(ret, &quot;avcodec_decode_video2 解码失败&quot;);
        }
        if (got[0] != 0) {
            return videoConverter.scale(pFrame);
        }
        av_packet_unref(pkt);
    }
    return null;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;4-将视频帧数据写入文件&quot;&gt;4. 将视频帧数据写入文件&lt;/h5&gt;
&lt;p&gt;通过视频解码之后可以得到YUV格式的视频帧，只需要将视频帧的数据写入文件就可以完成整个摄像头YUV数据的采集流程，RGB数据是存在AVFrame.data[0]中，而YUV格式的数据分三个地方存储，Y数据存在AVFrame.data[0]，U数据存在AVFrame.data[1]，V数据存在AVFrame.data[2]，其中U、V的数量是Y的1/4。&lt;br/&gt;所以只需要根据YUV存储的位置和容量取出数据即可：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;int fps = 25;
Yuv420PGrabber g = new Yuv420PGrabber();
g.open(&quot;Integrated Camera&quot;);
                
byte[] y = new byte[g.getVideoWidth() * g.getVideoHeight()];
byte[] u = new byte[g.getVideoWidth() * g.getVideoHeight() / 4];
byte[] v = new byte[g.getVideoWidth() * g.getVideoHeight() / 4];
//  1280x720
OutputStream fos = new FileOutputStream(&quot;yuv420p.yuv&quot;);
for (int i = 0; i &amp;lt; 200; i ++) {
    AVFrame avFrame = g.grab();
    avFrame.data(0).get(y);
    avFrame.data(1).get(u);
    avFrame.data(2).get(v);
    fos.write(y);
    fos.write(u);
    fos.write(v);
    Thread.sleep(1000 / fps);
}
fos.flush();
fos.close();
                
g.close();
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;5-播放采集的yuv数据&quot;&gt;5. 播放采集的YUV数据&lt;/h5&gt;
&lt;p&gt;采集的YUV数据可以通过YUV Player Deluxe，效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2083963/202010/2083963-20201009215333110-322611622.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也可以通过ffplay来播放，命令如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;ffplay.exe -f rawvideo -video_size 1280x720 yuv420p.yuv
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2083963/202010/2083963-20201009215740844-2141879026.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;=========================================================&lt;br/&gt;视频帧采集器源码可&lt;strong&gt;关注&lt;/strong&gt;公众号 “HiIT青年” 发送 “ffmpeg-yuv” 获取。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/itqn/1797476/o_200702010008qrcode.jpg&quot; alt=&quot;HiIT青年&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;strong&gt;关注公众号&lt;/strong&gt;，阅读更多文章。&lt;/p&gt;
</description>
<pubDate>Sat, 10 Oct 2020 00:49:00 +0000</pubDate>
<dc:creator>HiIT青年</dc:creator>
<og:description>前阵子使用利用树莓派搭建了一个视频监控平台（传送门），不过使用的是JavaCV封装好的OpenCVFrameGrabber和FFmpegFrameRecorder。 其实在javacpp项目集中有提供</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/itqn/p/13789079.html</dc:identifier>
</item>
<item>
<title>谈谈InnoDB中的B+树索引 - 大~熊</title>
<link>http://www.cnblogs.com/floor/p/13782223.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/floor/p/13782223.html</guid>
<description>&lt;p&gt;本文介绍一下索引相关知识。《MySQL技术内幕-InnoDB存储引擎》这个书确实非常经典，但是有些地方理解起来还是比较费劲的，比如与索引有关的覆盖索引，感觉看完仍然不是特别理解。本文算是个人的一个读书笔记，里边加入了自己的一些理解，对每种索引都画了一个对应的树的示意图，不一定对，但是有助于理解。期望对你有所启示, 如果错误，欢迎批评指正。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;316.73641268588&quot;&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;索引类似于书的&lt;code&gt;目录&lt;/code&gt;，他是帮助我们&lt;code&gt;从大量数据中快速定位&lt;/code&gt;某一条或者某个范围数据的一种数据结构。有序数组，搜索树都可以被用作索引。MySQL中有三大索引，分别是&lt;code&gt;B+树索引&lt;/code&gt;、&lt;code&gt;Hash索引&lt;/code&gt;、&lt;code&gt;全文索引&lt;/code&gt;。B+树索引是最最重要的索引，Hash索引和全文索引用的并不是太多，InnoDB不支持Hash索引，不过存储引擎内部去定位数据页时会使用Hash索引, 这不是本文重点。本文将简单介绍B+树索引。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;b树的基本结构&quot;&gt;B+树的基本结构&lt;/h2&gt;
&lt;p&gt;这里不对B+树做精确定义，直接给出一个B+树的示意图并做一些解释说明。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1128201/202010/1128201-20201008182000370-274030447.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;center&gt;图1：B+树的基本结构（来自网络）&lt;/center&gt;
&lt;p&gt;B+树是一颗&lt;code&gt;多路平衡查找树&lt;/code&gt;，所有节点称为&lt;code&gt;页&lt;/code&gt;，页就是一个数据块，里面可以放数据，页是固定大小的，在InnoDB中是16kb。页里边的数据是一些key值，n个key可以划分为n+1个区间，每个区间有一个指向下级节点的指针，每个页之间以双向链表的方式连接，一层中的key是&lt;code&gt;有序&lt;/code&gt;的。以磁盘块1这个页为例，他有两个key，17,35，划分了三个区间（-无穷,17) p1,[17, 35) p2, [35, +无穷] p3三个区间，也称扇出为3. p1指向的下级节点里边的key都是比17小的；p2指向的下级节点里边的key大于等于17，小于35；p3指向的下级节点里边的key都大于等于35。&lt;/p&gt;
&lt;p&gt;在B+树查找数据的流程：&lt;/p&gt;
&lt;p&gt;例如要在上边这棵树查找28，首先定位到磁盘1，通过&lt;code&gt;二分&lt;/code&gt;的方式找到他属于哪个区间，发现是p2，从而定位到磁盘块3，在磁盘块3的key里边做二分查找，找到p2, 定位到磁盘块8，然后二分找到28这个key。对于数据库来说，查找一个key最终一定会定位到叶子节点，因为只有叶子节点才包含行记录或者主键key。&lt;/p&gt;
&lt;p&gt;插入节点与删除节点：&lt;/p&gt;
&lt;p&gt;这里不对其详细流程做介绍，给大家安利一个工具：&lt;a href=&quot;https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html%EF%BC%8C&quot;&gt;https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html，&lt;/a&gt; 这个工具可以以动画方式演示B+树插入和删除的过程，非常直观，大家可以去动手试试看。如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1128201/202010/1128201-20201008182034122-771571947.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;center&gt;图2：B+树演示工具截图&lt;/center&gt;
&lt;p&gt;值得注意的是，插入节点时，可能存在&lt;code&gt;页分裂&lt;/code&gt;的情况，删除节点时可能存在&lt;code&gt;页合并&lt;/code&gt;的情况。页的分裂就是指当一个页容纳不了新的key时，分为多个页的过程。页合并是指当删除一个节点使得页中的key的数量少到一定程度时与相邻的页合在一起成为新的页。并非一个页满插入就会发生页分裂，会优先通过类似&lt;code&gt;旋转&lt;/code&gt;的方式进行调整，这样可以避免浪费空间。&lt;/p&gt;
&lt;p&gt;下图演示一种最简单的页分裂情况，假设一页只能放3个key，插入efg时，叶子页放了了，所以分裂为了两个页，并且增加了一层。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1128201/202010/1128201-20201008182049037-382509795.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;center&gt;图3：页分裂演示&lt;/center&gt;
&lt;p&gt;数据库索引的B+树的显著特点是&lt;code&gt;高扇出&lt;/code&gt;，也就是说一个页存放的数据多，这样的好处是树的&lt;code&gt;高度小&lt;/code&gt;，大概在2到4层，&lt;code&gt;高度越小，查找的IO次数越少&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;为什么要用b树&quot;&gt;为什么要用B+树&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;为什么不用有序数组&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;有序数组可以通过二分的方法查找，查找时间复杂度为O(logn). 他的缺点是&lt;code&gt;插入和删除操作代价太高&lt;/code&gt;，例如删除0位置，那么1到n-1位置的数据都要往前移动，代价O(n)&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;为什么不用Hash表&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;存储引擎内部是有用到Hash表的，这里说的不用Hash表是我们自己建索引时通常不会去建立Hash索引（InnoDB也是不支持的）&lt;/p&gt;
&lt;p&gt;Hash表是一种查找效率很高的结构，例如我们Java中的HashMap，基本可以认为他的插入、查询、删除都是O(1)的。&lt;/p&gt;
&lt;p&gt;Hash表的底层是一个&lt;code&gt;数组&lt;/code&gt;，插入数据时对数据的hashCode对数组长度&lt;code&gt;取模&lt;/code&gt;，确定他在数组中的位置，放到数组里边。当然这里可能存在你要放的位置被占用了，这个叫&lt;code&gt;碰撞&lt;/code&gt;，或者Hash冲突，此时可以用拉链法解决，具体就是在冲突的位置建一个链表。如下图所示，BCD三个数据在1位置发生冲突，因此在这里形成了链表。Hash表中的查找也很容易，先按插入的方式找到待查找数据在的位置，然后看这个位置有没有，有就找到了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1128201/202010/1128201-20201008182107513-132821044.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;center&gt;图4：Hash表示意图链表法&lt;/center&gt;
&lt;p&gt;Hash表的一个缺点在于&lt;code&gt;对范围查询的支持不友好&lt;/code&gt;，比如要查[F，K]之间数据，那么就需要将F到K之间的所有值枚举出来计算hashcode，一个一个去hash表查。而且他是无序的，&lt;code&gt;对于order by不友好&lt;/code&gt;。因此除非你的查询就只有等值查询，否则不可能使用Hash表做索引。&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;为什么不用搜索二叉树&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;不管是不经调整的搜索二叉树，还是AVL树、红黑树都是搜索二叉树，他的特点是，对于任意一个节点，他的左孩子（如果有）小于自己，右孩子（如果有）大于自己。&lt;/p&gt;
&lt;p&gt;搜索二叉树的缺点在于，他的&lt;code&gt;高度会随着节点数增加而增加&lt;/code&gt;。我们知道，数据库索引是很大的，不可能直接装进内存，根节点可能是直接在内存的，其他节点存放在磁盘上，查找的时候&lt;code&gt;每往下找一层就需要读一次磁盘&lt;/code&gt;。读磁盘的&lt;code&gt;效率是比较低的&lt;/code&gt;，因此需要减少读磁盘的次数，那么也就需要减少树的高度。搜索二叉树当数据很多时，高度就会很高，那么磁盘IO次数就会很多，效率低下。&lt;/p&gt;
&lt;p&gt;另外，数据库是以页的形式存储的，InnoDB存储引擎默认一页16K，一页可以看成一个节点 ，二叉树一个结点只能存储一个一个数据.假如索引字段为int 也就是一个4字节的数字要占16k的空间，极大的&lt;code&gt;浪费了空间&lt;/code&gt;。&lt;/p&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;B+树有什么特点&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;高扇出&lt;/code&gt;，高扇出使得一个节点可以存放更多的数据，整棵树会更加&lt;code&gt;矮胖&lt;/code&gt;。InnoDB中一棵树的高度在2-4层，这意味着一次查询只需要1-3次磁盘IO&lt;/li&gt;
&lt;li&gt;非叶子节点只存放key值（也就是列值），这使得一页可以存更多的数据，这是高扇出的保证&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;聚集索引&quot;&gt;聚集索引&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;聚集索引（Clustered index)&lt;/code&gt; 也叫聚簇索引、主键索引。他的显著特点是&lt;code&gt;其叶子节点包含行数据（表中的一行）&lt;/code&gt;，没错，InnoDB存储引擎表数据存在索引中，表是&lt;code&gt;索引组织表&lt;/code&gt;。显然表数据不可能有多份，但是必须有一份，所以聚集索引在一张表有且仅有一个。&lt;/p&gt;
&lt;p&gt;什么样的列会建立聚集索引？&lt;/p&gt;
&lt;p&gt;&lt;code&gt;主键列&lt;/code&gt;，也就是你指定一个表的主键就会创建聚集索引。InnoDB中的表必有主键列，如果没有指定主键，那么会选择一个非空唯一列作为主键，，否则隐式创建一个列作为主键。&lt;/p&gt;
&lt;p&gt;假设有如下一张表，a为主键，假设一页只能放三个数据&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;编号&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;b&lt;/th&gt;
&lt;th&gt;c&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;b&lt;/td&gt;
&lt;td&gt;12&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;c&lt;/td&gt;
&lt;td&gt;13&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;d&lt;/td&gt;
&lt;td&gt;14&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;center&gt;表1：示例数据表&lt;/center&gt;
&lt;p&gt;我们看一看他的聚集索引大概是张什么样的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1128201/202010/1128201-20201008182137278-334104206.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;center&gt;图5：聚集索引索引树示意图&lt;/center&gt;
&lt;p&gt;其中r1到r4分别表示编号从1到4的行&lt;/p&gt;
&lt;p&gt;使用聚集索引的好处：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;查询快&lt;/code&gt;，等值和范围查询都快，使用索引必然查询效率会高，使用聚集索引比非聚集索引查询更快，因为他能直接在叶子节点找到数据，而不需要回表（后文说明）&lt;/li&gt;
&lt;li&gt;基于主键（聚集索引）的&lt;code&gt;排序快&lt;/code&gt;，数据本身就是根据主键排序的&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;下面我们创建一个表看一下&lt;/p&gt;
&lt;p&gt;建表语句和初始化数据如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;-- a为主键
create table t (
    a int not null,
    b varchar(600),
    c int not null,
    primary key(a)
) engine=INNODB;

insert into t values 
(1,'a',11),
(2, 'b', 12),
(3, 'c', 13),
(4, 'd', 14);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1128201/202010/1128201-20201008182203507-1426397658.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;center&gt;图6：聚集索引查询计划演示&lt;/center&gt;
&lt;p&gt;&lt;em&gt;关于explain不太了解的朋友可以参看文末最后一个参考资料&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;第一个查询我们在a列上做等值查询，第二个在c上做等值查询。从key列可以看到，第一个查询用到了聚集索引，第二个由于c没有索引，所以全表扫描&lt;/p&gt;
&lt;p&gt;第三个查询对a做排序,第四个查询对c列做排序。发现对主键的排序不会用filesort.&lt;/p&gt;
&lt;h2 id=&quot;非聚集索引&quot;&gt;非聚集索引&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;非聚集索引（Secondary Index)&lt;/code&gt;也叫辅助索引、二级索引、非主键索引。非主键列创建的索引就是这种索引。他的显著特点是&lt;code&gt;叶子节点不包括完整的行数据&lt;/code&gt;（如果包括，这是一件多么恐怖的事啊！），而是包含行记录对应的&lt;code&gt;主键key&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;还是以上边的表为例，我们在b列创建一个索引。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1128201/202010/1128201-20201008182253586-1028075925.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意我们只用了b的前10个字符创建索引，所以你能看到Sub_part这列显示的为10。&lt;/p&gt;
&lt;p&gt;此时，idx_b这个索引对应B+树类似下边这种形式&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1128201/202010/1128201-20201008182321264-947805631.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;center&gt;图7：非聚集索引索引树示意图&lt;/center&gt;
&lt;p&gt;可以看到叶子节点中的1,2,3,4其实是主键里边的值&lt;/p&gt;
&lt;p&gt;在非聚集索引的查找过程是：&lt;/p&gt;
&lt;p&gt;先在非聚集索引树找到指定key，同时能得到主键key，拿着主键key到聚集索引里找到对应的行。&lt;/p&gt;
&lt;p&gt;拿着主键key到聚集索引找行的过程称为&lt;code&gt;回表&lt;/code&gt;，回表有可能避免，详见后文的覆盖索引。&lt;/p&gt;
&lt;p&gt;使用非聚集索引的好处：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;占用的空间相比聚集索引小&lt;/code&gt;，因为他的叶子节点并不包含完整的行数据，只包含主键key&lt;br/&gt;2. &lt;code&gt;查询快&lt;/code&gt;，这和聚集索引是类似的，但是效率可能比聚集索引低，因为存在回表过程&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;缺点：&lt;/p&gt;
&lt;p&gt;回表问题，就是要查两棵索引树才能找到数据，当然后面会提到并不是所有用非聚集索引查询都有回表过程。&lt;/p&gt;
&lt;p&gt;下边来看几个查询计划&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1128201/202010/1128201-20201008182348200-954138754.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;center&gt;图8：二级索引查询计划&lt;/center&gt;
&lt;p&gt;第一个 key为idx_b, 表明用到了非聚集索引，extra是mysql5.6后做的一个优化，Index Push Down优化，简言之就是在使用索引查询时直接通过where条件过滤掉了不符合条件的数据。&lt;/p&gt;
&lt;p&gt;第二个演示了按非聚集索引的列做排序的情况，发现会用到filesort，因为没法直接根据索引排序了，需要回表。&lt;/p&gt;
&lt;p&gt;第三个和第二个类似，但是他只选择了b这个列，发现没有用filesort.因为不用回表，这个其实就是用到了覆盖索引。&lt;/p&gt;
&lt;h2 id=&quot;联合索引&quot;&gt;联合索引&lt;/h2&gt;
&lt;p&gt;联合索引就是索引&lt;code&gt;包含多个列&lt;/code&gt;的情况，此时的B+树每个key包含了几个部分，而不是单一值。&lt;/p&gt;
&lt;p&gt;继续上边的例子，我们建立b，c列上的联合索引。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1128201/202010/1128201-20201008182403426-1533494116.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;center&gt;图9：创建联合索引演示&lt;/center&gt;
&lt;p&gt;这个索引树可能的形式如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1128201/202010/1128201-20201008182434482-1023389765.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;center&gt;图10：联合索引索引树示意图&lt;/center&gt;
&lt;p&gt;这个图画的不太好，其实第二个列在一页里边也可以是无序的&lt;/p&gt;
&lt;p&gt;每个key有两个列值组成，叶子节点也是包含了主键key，可见这个联合索引是非聚集索引。当然主键索引也可以包含多个列，自然也可以是联合索引。&lt;/p&gt;
&lt;p&gt;联合索引的作用：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;对左边的列做查询排序都可以用到这个索引（最左原则）&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;-- 这里可以假设没有idx_b这个索引
select * from t where b='a';
select * from t where b='a' and c=11;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;左边的列做等值查询，对后边的列做排序友好，因为后边的已经是排序的&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;-- 这里可以假设没有idx_b这个索引
select * from t where b='a' order by  c;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;让索引包含更多数据，走覆盖索引，一旦放到一个列被索引，那么索引树必包含这个列的数据&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;对于字符串类型的列，也是满足最左前缀原则，like '%a' 不能命中索引，like 'a%'就可以。&lt;/p&gt;
&lt;p&gt;注意下边这个语句用不到索引&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;select * from t where c=11;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面看几个查询计划：&lt;/p&gt;
&lt;p&gt;先来看一看索引情况&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1128201/202010/1128201-20201008182455910-59520671.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到我们在b，c两列建立了idx_b_c的联合索引&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1128201/202010/1128201-20201008182516133-1536364361.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;center&gt;图11：联合索引查询计划&lt;/center&gt;
&lt;p&gt;1号查询，条件包含最左列，b列，命中索引&lt;/p&gt;
&lt;p&gt;2号查询，条件不包含最左列，key列显示为NULL，未命中索引，type为ALL，是全表扫描&lt;/p&gt;
&lt;p&gt;3号查询，对最左列做等值，然后右列做排序，命中了索引&lt;/p&gt;
&lt;p&gt;4号查询，没有命中索引，用到了filesort&lt;/p&gt;
&lt;p&gt;通过这四个查询我们能够了解到联合索引的最左原则是怎么回事了，结合前面提到的联合索引的树结构，这个原则是理所当然的。&lt;/p&gt;
&lt;h2 id=&quot;覆盖索引&quot;&gt;覆盖索引&lt;/h2&gt;
&lt;p&gt;覆盖的意思就是&lt;code&gt;包含&lt;/code&gt;的意思，覆盖索引就是说&lt;code&gt;索引里包含了你需要的数据&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;聚集索引直接包含了行数据，因此是覆盖索引，但是一般不这么说。非聚集索引索引数据里边有索引列的列值（这不完全对，后面有说明）。覆盖索引不是一种新的索引结构，只是&lt;code&gt;恰好你要查的数据就在索引树里有&lt;/code&gt;，这样就&lt;code&gt;不用回表查询&lt;/code&gt;了（非聚集索引叶子节点只有主键key，和索引列值，如果需要其他列值，就需要在通过聚集索引查一次，也就是要走回表）。&lt;code&gt;如果使用了覆盖索引，那么查询计划的Extra列为Using index&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;看几个具体的例子：&lt;/p&gt;
&lt;p&gt;目前的索引情况如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1128201/202010/1128201-20201008182535391-947840082.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一些执行计划&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1128201/202010/1128201-20201008182548040-2026688191.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;center&gt;图12：覆盖索引执行计划演示&lt;/center&gt;
&lt;p&gt;c的索引包含c列和主键列的值，所以第一第二个查询不需要回表，使用了覆盖索引。&lt;/p&gt;
&lt;p&gt;c的索引不包含b列，所以当c列索引查b列时就需要回表了&lt;/p&gt;
&lt;p&gt;第四个查询，b列上有索引，索引里边有b列的值，要查的也是b列，索引覆盖了要查询的列，所以也使用了覆盖索引。&lt;/p&gt;
&lt;p&gt;需要注意的是，不要忘记了&lt;code&gt;主键列在所有索引都可以被覆盖到&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;测试发现一个奇怪的现象，这里分享给大伙儿，一个列的varchar给超过767的长度，然后在上边建索引，会有一个自动的截取。如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1128201/202010/1128201-20201008182607669-373690392.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;center&gt;图13：varchar过长索引截取演示&lt;/center&gt;
&lt;p&gt;大家可以思考一下，如果你的索引key只是列的一部分，比如，有一个字段为varchar(100), 你的索引只包含前50个字符，这个时候能不能走覆盖索引？&lt;/p&gt;
&lt;h2 id=&quot;cardinality&quot;&gt;Cardinality&lt;/h2&gt;
&lt;p&gt;使用&lt;code&gt;show index from 表名&lt;/code&gt;时， 可以看到有一个Cardinality列，这个列是衡量我们&lt;code&gt;索引有效性&lt;/code&gt;的方式。他的含义是索引列中不重复的行数，Cardinality除以表行数称为&lt;code&gt;索引的选择性&lt;/code&gt;，&lt;code&gt;选择性越高越好&lt;/code&gt;，选择性小于30%通常认为这个索引建的不好。&lt;/p&gt;
&lt;p&gt;Cardinality是一个&lt;code&gt;采样估计值&lt;/code&gt;，会随机选择若干页计算平均不同记录的个数，然后乘上页数量。所以可能你每次查到的值不一样，即使你的表没有更新。&lt;/p&gt;
&lt;p&gt;这个值并不是每一次表更新都会计算的，他会有自己的一个计算策略。&lt;/p&gt;
&lt;p&gt;执行如下语句会导致这个值的重新计算, 当然也可以配置为不进行计算：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;analyze table&lt;/li&gt;
&lt;li&gt;show table status&lt;/li&gt;
&lt;li&gt;show index&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;b树索引管理&quot;&gt;B+树索引管理&lt;/h2&gt;
&lt;p&gt;索引的创建：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;建表的时候创建&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;create table t4 
(
    id int primary key,
    a int not null, key(a)
);
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;通过修改表创建&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;alter table t4 add index idx_a (a);
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;通过create index创建&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;create index idx_a on t4(a);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;索引的删除：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;修改表删除&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;alter table t4 drop index idx_a;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;drop index语法&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;drop index idx_a on t4;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;索引的查看&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;show index from t4;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;关于索引的思考&quot;&gt;关于索引的思考&lt;/h2&gt;
&lt;p&gt;学习B+树索引，最最根本是需要弄清楚各种&lt;code&gt;索引树的结构&lt;/code&gt;是怎样的，做到“心中有树”。当看到一条优化策略时，我们就能知道这个优化策略&lt;code&gt;为什么能够优化&lt;/code&gt;。基于我们对索引结构的理解，甚至还可以提出一些新（对你来讲是新的，但是可能人家已经写了或者在用了）的优化策略。例如，我们知道每一个非聚集索引叶子节点都会包含主键，因此我们的&lt;code&gt;主键应该在满足业务的情况下尽量小&lt;/code&gt;，这样可以减少所有索引的空间，当然，事实上，每一个列数据类型都应当尽量小。&lt;/p&gt;
&lt;p&gt;索引之路，道阻且长，奥利给！&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1128201/202010/1128201-20201008182637230-1369493449.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Sat, 10 Oct 2020 00:29:00 +0000</pubDate>
<dc:creator>大~熊</dc:creator>
<og:description>本文介绍一下索引相关知识。《MySQL技术内幕-InnoDB存储引擎》这个书确实非常经典，但是有些地方理解起来还是比较费劲的，比如与索引有关的覆盖索引，感觉看完仍然不是特别理解。本文算是个人的一个读书</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/floor/p/13782223.html</dc:identifier>
</item>
<item>
<title>诊断日志知多少 | DiagnosticSource 在.NET上的应用 - 「圣杰」</title>
<link>http://www.cnblogs.com/sheng-jie/p/how-much-you-know-about-diagnostic-in-dotnet.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sheng-jie/p/how-much-you-know-about-diagnostic-in-dotnet.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2799767-f9fe53d73a593166.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;最近为了解决ABP集成CAP时无法通过拦截器启用工作单元的问题，从小伙伴那里学了一招。借助&lt;code&gt;DiagnossticSource&lt;/code&gt;，可以最小改动完成需求。关于DiagnosticSource晓东大佬18年在文章 &lt;a href=&quot;https://www.cnblogs.com/savorboard/p/diagnostics.html&quot;&gt;在 .NET Core 中使用 Diagnostics (Diagnostic Source) 记录跟踪信息&lt;/a&gt;就有介绍，文章开头就说明了Diagnostics 一直是一个被大多数开发者忽视的东西。是的，我也忽略了，这个好东西，有必要学习一下，下面就和大家简单聊一聊&lt;a href=&quot;https://github.com/dotnet/runtime/tree/master/src/libraries/System.Diagnostics.DiagnosticSource/src/System/Diagnostics&quot;&gt;System.Diagnostics.DiagnosticSource&lt;/a&gt;在.NET上的应用。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Diagnostics&lt;/code&gt;位于&lt;code&gt;System&lt;/code&gt;命名空间下，由此可见&lt;code&gt;Diagnostics&lt;/code&gt;在.NET 运行时中的地位不可小觑。其中&lt;a href=&quot;https://github.com/dotnet/runtime/tree/master/src/libraries&quot;&gt;System.Diagnostics&lt;/a&gt;命名空间下又包含不同类库，提供了允许与系统进程，事件日志和性能计数器进行交互的类。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2799767-f00800a0b8dbfe92.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Diagnostic Namespace&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中System.Diagnostics.DiagnosticSource模块，它允许对代码进行检测，以在生产时记录丰富的数据负载（可以传递不可序列化的数据类型），以便在&lt;strong&gt;进程内&lt;/strong&gt;进行消耗。消费者可以在运行时动态发现数据源并订阅感兴趣的数据源。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2799767-7197a426f10d7b66.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在展开之前，有必要先梳理下涉及的以下核心概念：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;IObservable：可观测对象&lt;/li&gt;
&lt;li&gt;IObserver：观察者&lt;/li&gt;
&lt;li&gt;DiagnosticSource ：诊断来源&lt;/li&gt;
&lt;li&gt;DiagnosticListener：诊断监听器&lt;/li&gt;
&lt;li&gt;Activity：活动&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;IObservable&lt;/code&gt; 和 &lt;code&gt;IObserver&lt;/code&gt;位于&lt;code&gt;System&lt;/code&gt;命名空间下，是.NET中对观察者模式的抽象。&lt;/p&gt;
&lt;blockquote readability=&quot;7.6248275862069&quot;&gt;
&lt;p&gt;观察者设计模式使观察者能够从可观察对象订阅并接收通知。 它适用于需要基于推送通知的任何方案。 此模式定义可观察对象，以及零个、一个或多个观察者。 观察者订阅可观察对象，并且每当预定义的条件、事件或状态发生更改时，该可观察对象会通过调用其方法之一来自动通知所有观察者。 在此方法调用中，该可观察对象还可向观察者提供当前状态信息。 在 .NET Framework 中，通过实现泛型 &lt;a href=&quot;https://docs.microsoft.com/zh-cn/dotnet/api/system.iobservable-1&quot;&gt;System.IObservable&lt;/a&gt; 和 &lt;a href=&quot;https://docs.microsoft.com/zh-cn/dotnet/api/system.iobserver-1&quot;&gt;System.IObserver&lt;/a&gt; 接口来应用观察者设计模式。 泛型类型参数表示提供通知信息的类型。 泛型类型参数表示提供通知信息的类型。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;第一次学习观察者模式，应该是大学课本中基于事件烧水的例子，咱们就基于此实现个简单的Demo吧。首先执行&lt;code&gt;dotnet new web -n Dotnet.Diagnostic.Demo&lt;/code&gt;创建示例项目。&lt;/p&gt;
&lt;h2 id=&quot;31-定义可观察对象（实现iobservable接口）&quot;&gt;3.1. 定义可观察对象（实现IObservable接口）&lt;/h2&gt;
&lt;p&gt;对于烧水的示例，主要关注水温的变化，因此先定义&lt;code&gt;Temperature&lt;/code&gt;来表示温度变化：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Temperature
{
    public Temperature(decimal temperature, DateTime date)
    {
        Degree = temperature;
        Date = date;
    }
    public decimal Degree { get;  }
    public DateTime Date { get;  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来通过实现&lt;code&gt;IObservable&amp;lt;T&amp;gt;&lt;/code&gt;接口来定义可观察对象。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public interface IObservable&amp;lt;out T&amp;gt;
{
  IDisposable Subscribe(IObserver&amp;lt;T&amp;gt; observer);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从接口申明来看，只定义了一个&lt;code&gt;Subscribe&lt;/code&gt;方法，从观察者模式讲，观察者应该既能订阅又能取消订阅消息。为什么没有定义一个&lt;code&gt;UnSubscribe&lt;/code&gt;方法呢？其实这里方法申明已经说明，期望通过返回&lt;code&gt;IDisposable&lt;/code&gt;对象的&lt;code&gt;Dispose&lt;/code&gt;方法来达到这个目的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// 热水壶
/// &amp;lt;/summary&amp;gt;
public class Kettle : IObservable&amp;lt;Temperature&amp;gt;
{
    private List&amp;lt;IObserver&amp;lt;Temperature&amp;gt;&amp;gt; observers;
    private decimal temperature = 0;

    public Kettle()
    {
        observers = new List&amp;lt;IObserver&amp;lt;Temperature&amp;gt;&amp;gt;();
    }

    public decimal Temperature
    {
        get =&amp;gt; temperature;
        private set
        {
            temperature = value;
            observers.ForEach(observer =&amp;gt; observer.OnNext(new Temperature(temperature, DateTime.Now)));
            
            if (temperature == 100)
                observers.ForEach(observer =&amp;gt; observer.OnCompleted());
        }
    }
    public IDisposable Subscribe(IObserver&amp;lt;Temperature&amp;gt; observer)
    {
        if (!observers.Contains(observer))
        {
            Console.WriteLine(&quot;Subscribed!&quot;);
            observers.Add(observer);
        }
        //使用UnSubscriber包装，返回IDisposable对象，用于观察者取消订阅
        return new UnSubscriber&amp;lt;Temperature&amp;gt;(observers, observer);
    }
    /// &amp;lt;summary&amp;gt;
    /// 烧水方法
    /// &amp;lt;/summary&amp;gt;
    public async Task StartBoilWaterAsync()
    {
        var random = new Random(DateTime.Now.Millisecond);
        while (Temperature &amp;lt; 100)
        {
            Temperature += 10;
            await Task.Delay(random.Next(5000));
        }
    }
}

//定义泛型取消订阅对象，用于取消订阅
internal class UnSubscriber&amp;lt;T&amp;gt; : IDisposable
{
    private List&amp;lt;IObserver&amp;lt;T&amp;gt;&amp;gt; _observers;
    private IObserver&amp;lt;T&amp;gt; _observer;
    internal UnSubscriber(List&amp;lt;IObserver&amp;lt;T&amp;gt;&amp;gt; observers, IObserver&amp;lt;T&amp;gt; observer)
    {
        this._observers = observers;
        this._observer = observer;
    }
    public void Dispose()
    {
        if (_observers.Contains(_observer))
        {
            Console.WriteLine(&quot;Unsubscribed!&quot;);
            _observers.Remove(_observer);
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;以上代码中List&amp;lt;IObserver&amp;gt;存在线程安全问题，因为简单Demo，就不予优化了。&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;32-定义观察者（实现iobserver接口&quot;&gt;3.2. 定义观察者（实现IObserver接口)&lt;/h2&gt;
&lt;p&gt;比如定义一个报警器，实时播报温度。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Alter : IObserver&amp;lt;Temperature&amp;gt;
{
    public void OnCompleted()
    {
        Console.WriteLine(&quot;du du du !!!&quot;);
    }
    public void OnError(Exception error)
    {
        //Nothing to do
    }
    public void OnNext(Temperature value)
    {
        Console.WriteLine($&quot;{value.Date.ToString()}: Current temperature is {value.Degree}.&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;添加测试代码，访问&lt;code&gt;localhost:5000/subscriber&lt;/code&gt;控制台输出结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;endpoints.MapGet(&quot;/subscriber&quot;, async context =&amp;gt;
{
    var kettle = new Kettle();//初始化热水壶
    var subscribeRef = kettle.Subscribe(new Alter());//订阅
    
    var boilTask = kettle.StartBoilWaterAsync();//启动开始烧水任务
    var timoutTask = Task.Delay(TimeSpan.FromSeconds(15));//定义15s超时任务
    //等待，如果超时任务先返回则取消订阅
    var firstReturnTask = await Task.WhenAny(boilTask, timoutTask);
    if (firstReturnTask == timoutTask)
        subscribeRef.Dispose();
    await context.Response.WriteAsync(&quot;Hello subscriber!&quot;);
});

------------------------------------------------------------------

Subscribed!
10/2/2020 4:53:20 PM: Current temperature is 10.
10/2/2020 4:53:20 PM: Current temperature is 20.
10/2/2020 4:53:21 PM: Current temperature is 30.
10/2/2020 4:53:21 PM: Current temperature is 40.
10/2/2020 4:53:24 PM: Current temperature is 50.
10/2/2020 4:53:25 PM: Current temperature is 60.
10/2/2020 4:53:26 PM: Current temperature is 70.
10/2/2020 4:53:30 PM: Current temperature is 80.
Unsubscribed!
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;41-概念讲解&quot;&gt;4.1. 概念讲解&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;DiagnosticSource&lt;/code&gt;直译就是诊断源，也就是它是诊断日志的来源入口。DiagnosticSource其是一个&lt;em&gt;抽象类&lt;/em&gt;主要定义了以下方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//Provides a generic way of logging complex payloads
public abstract void Write(string name, object value);
//Verifies if the notification event is enabled.
public abstract bool IsEnabled(string name);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;DiagnosticListener&lt;/code&gt;直译就是诊断监听器，继承自&lt;code&gt;DiagnosticSource&lt;/code&gt;，同时实现了&lt;code&gt;IObservable&amp;lt;KeyValuePair&amp;lt;string, object&amp;gt;&amp;gt;&lt;/code&gt;接口，因此其本质是一个可观察对象。小结以下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;DiagnosticSource&lt;/code&gt; 作为诊断日志来源，提供接口，用于写入诊断日志。&lt;/li&gt;
&lt;li&gt;诊断日志的可观察数据类型为&lt;code&gt;KeyValuePair&amp;lt;string, object&amp;gt;&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DiagnosticListener&lt;/code&gt; 继承自&lt;code&gt;DiagnosticSource&lt;/code&gt;，作为可观察对象，可由其他观察者订阅，以获取诊断日志。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;code&gt;DiagnosticListener&lt;/code&gt; 其构造函数接收一个&lt;code&gt;name&lt;/code&gt;参数。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private static DiagnosticSource httpLogger = new DiagnosticListener(&quot;System.Net.Http&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以通过下面这种方式记录诊断日志：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if (httpLogger.IsEnabled(&quot;RequestStart&quot;))
    httpLogger.Write(&quot;RequestStart&quot;, new { Url=&quot;http://clr&quot;, Request=aRequest });
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后需要实现&lt;code&gt;IObserver&amp;lt;KeyValuePair&amp;lt;string, object&amp;gt;&amp;gt;&lt;/code&gt;接口，以便消费诊断数据。定义&lt;code&gt;DiagnosticObserver&lt;/code&gt;，进行诊断日志消费：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class DiagnosticObserver : IObserver&amp;lt;KeyValuePair&amp;lt;string, object&amp;gt;&amp;gt;
{
    public void OnCompleted()
    {
        //Noting to do
    }
    public void OnError(Exception error)
    {
        Console.WriteLine($&quot;{error.Message}&quot;);
    }
    public void OnNext(KeyValuePair&amp;lt;string, object&amp;gt; pair)
    { 
        // 这里消费诊断数据
        Console.WriteLine($&quot;{pair.Key}-{pair.Value}&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ASP.NET Core 项目中默认就依赖了&lt;code&gt;System.Diagnostics.DiagnosticSource&lt;/code&gt;Nuget包，同时在构建通用Web主机时，就注入了名为&lt;code&gt;Microsoft.AspNetCore&lt;/code&gt;的&lt;code&gt;DiagnosticListener&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//GenericWebHostBuilder.cs
DiagnosticListener instance = new DiagnosticListener(&quot;Microsoft.AspNetCore&quot;);
services.TryAddSingleton&amp;lt;DiagnosticListener&amp;gt;(instance);
services.TryAddSingleton&amp;lt;DiagnosticSource&amp;gt;((DiagnosticSource) instance);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因此我们可以直接通过注入&lt;code&gt;DiagnosticListener&lt;/code&gt;进行诊断日志的订阅：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void Configure(IApplicationBuilder app, IWebHostEnvironment env, DiagnosticListener diagnosticListener)
{
    diagnosticListener.Subscribe(new DiagnosticObserver());//订阅诊断日志
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;当然也可以直接使用&lt;code&gt;DiagnosticListener.AllListeners.Subscribe(IObserver&amp;lt;DiagnosticListener&amp;gt; observer);&lt;/code&gt;进行订阅，不过区别是，接收的参数类型为&lt;code&gt;IObserver&amp;lt;DiagnosticListener&amp;gt;&lt;/code&gt;。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;运行项目输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Microsoft.AspNetCore.Hosting.HttpRequestIn.Start-Microsoft.AspNetCore.Http.DefaultHttpContext
Microsoft.AspNetCore.Hosting.BeginRequest-{ httpContext = Microsoft.AspNetCore.Http.DefaultHttpContext, timestamp = 7526300014352 }
Microsoft.AspNetCore.Routing.EndpointMatched-Microsoft.AspNetCore.Http.DefaultHttpContext
Microsoft.AspNetCore.Hosting.EndRequest-{ httpContext = Microsoft.AspNetCore.Http.DefaultHttpContext, timestamp = 7526300319214 }
Microsoft.AspNetCore.Hosting.HttpRequestIn.Stop-Microsoft.AspNetCore.Http.DefaultHttpContext
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从中可以看出，ASP.NET Core Empty Web Project在一次正常的Http请求过程中分别在请求进入、请求处理、路由匹配都埋了点，除此之外还有请求异常、Action处理都有埋点。因此，根据需要，可以实现比如请求拦截、耗时统计等系列操作。&lt;/p&gt;
&lt;h2 id=&quot;42-耗时统计&quot;&gt;4.2. 耗时统计&lt;/h2&gt;
&lt;p&gt;基于以上知识，下面尝试完成一个简单的耗时统计。从上面的内容可知，ASP.NET Core在BeginRequest和EndRequest返回的诊断数据类型如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Microsoft.AspNetCore.Hosting.BeginRequest-{ httpContext = Microsoft.AspNetCore.Http.DefaultHttpContext, timestamp = 7526300014352 }
Microsoft.AspNetCore.Hosting.EndRequest-{ httpContext = Microsoft.AspNetCore.Http.DefaultHttpContext, timestamp = 7526300319214 }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因此只要拿到两个timestamp就可以直接计算耗时，修改&lt;code&gt;DiagnosticObserver&lt;/code&gt;的&lt;code&gt;OnNext&lt;/code&gt;方法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private ConcurrentDictionary&amp;lt;string, long&amp;gt; startTimes = new ConcurrentDictionary&amp;lt;string, long&amp;gt;();
public void OnNext(KeyValuePair&amp;lt;string, object&amp;gt; pair)
{
    //Console.WriteLine($&quot;{pair.Key}-{pair.Value}&quot;);
    //获取httpContext
    var context = pair.Value.GetType().GetTypeInfo().GetDeclaredProperty(&quot;httpContext&quot;)
        ?.GetValue(pair.Value) as DefaultHttpContext;
    //获取timestamp
    var timestamp = pair.Value.GetType().GetTypeInfo().GetDeclaredProperty(&quot;timestamp&quot;)
        ?.GetValue(pair.Value) as long?;
    switch (pair.Key)
    {
        case &quot;Microsoft.AspNetCore.Hosting.BeginRequest&quot;:
            Console.WriteLine($&quot;Request {context.TraceIdentifier} Begin:{context.Request.GetUri()}&quot;);
            startTimes.TryAdd(context.TraceIdentifier, timestamp.Value);//记录请求开始时间
            break;
        case &quot;Microsoft.AspNetCore.Hosting.EndRequest&quot;:
            startTimes.TryGetValue(context.TraceIdentifier, out long startTime);
            var elapsedMs = (timestamp - startTime) / TimeSpan.TicksPerMillisecond;//计算耗时
            Console.WriteLine(
                $&quot;Request {context.TraceIdentifier} End: Status Code is {context.Response.StatusCode},Elapsed {elapsedMs}ms&quot;);
            startTimes.TryRemove(context.TraceIdentifier, out _);
            break;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出如下，大功告成：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Request 0HM37UNERKGF0:00000001 Begin:https://localhost:44330
Request 0HM37UNERKGF0:00000001 End: Status Code is 200,Elapsed 38ms
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面有通过反射去获取诊断数据属性的代码（&lt;code&gt;var timestamp = pair.Value.GetType().GetTypeInfo().GetDeclaredProperty(&quot;timestamp&quot;) ?.GetValue(pair.Value) as long?;&lt;/code&gt;），非常不优雅。但我们可以安装&lt;strong&gt;&lt;code&gt;Microsoft.Extensions.DiagnosticAdapter&lt;/code&gt;&lt;/strong&gt;包来简化诊断数据的消费。安装后，添加&lt;code&gt;HttpContextDiagnosticObserver&lt;/code&gt;，通过添加&lt;code&gt;DiagnosticName&lt;/code&gt;指定监听的诊断名称，即可进行诊断数据消费。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public sealed class HttpContextDiagnosticObserver
{
    private ConcurrentDictionary&amp;lt;string, long&amp;gt; startTimes = new ConcurrentDictionary&amp;lt;string, long&amp;gt;();
    
    [DiagnosticName(&quot;Microsoft.AspNetCore.Hosting.BeginRequest&quot;)]
    public void BeginRequest(HttpContext httpContext,long timestamp)
    {
        Console.WriteLine($&quot;Request {httpContext.TraceIdentifier} Begin:{httpContext.Request.GetUri()}&quot;);
        startTimes.TryAdd(httpContext.TraceIdentifier, timestamp);//记录请求开始时间
    }
    
    [DiagnosticName(&quot;Microsoft.AspNetCore.Hosting.EndRequest&quot;)]
    public void EndRequest(HttpContext httpContext,long timestamp)
    {
        startTimes.TryGetValue(httpContext.TraceIdentifier, out long startTime);
        var elapsedMs = (timestamp - startTime) / TimeSpan.TicksPerMillisecond;//计算耗时
        Console.WriteLine(
            $&quot;Request {httpContext.TraceIdentifier} End: Status Code is {httpContext.Response.StatusCode},Elapsed {elapsedMs}ms&quot;);
        startTimes.TryRemove(httpContext.TraceIdentifier, out _);
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后使用&lt;code&gt;SubscribeWithAdapter&lt;/code&gt;进行订阅即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void Configure(IApplicationBuilder app, IWebHostEnvironment env, DiagnosticListener diagnosticListener)
{
    // diagnosticListener.Subscribe(new DiagnosticObserver());
    diagnosticListener.SubscribeWithAdapter(new HttpContextDiagnosticObserver());
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到这里可能也有小伙伴说，我用&lt;code&gt;ActionFilter&lt;/code&gt;也可以实现，没错，但这两种方式是完全不同的，&lt;code&gt;DiagnosticSource&lt;/code&gt;是完全异步的。&lt;/p&gt;
&lt;h2 id=&quot;43-应用场景思考&quot;&gt;4.3. 应用场景思考&lt;/h2&gt;
&lt;p&gt;根据DiagnosticSource的特性，可以运用于以下场景 ：&lt;/p&gt;
&lt;p&gt;1. AOP：因为Diagnostics命名事件一般是成对出现的，因此可以做些拦截操作。比如在Abp集成&lt;a href=&quot;https://github.com/dotnetcore/CAP&quot;&gt;Cap&lt;/a&gt;时，若想默认启用Uow，就可以消费&lt;code&gt;DotNetCore.CAP.WriteSubscriberInvokeBefore&lt;/code&gt;命名事件，创建Uow，再在命名事件&lt;code&gt;DotNetCore.CAP.WriteSubscriberInvokeAfter&lt;/code&gt;中提交事务，并Dispose。&lt;br/&gt;2. APM：&lt;a href=&quot;https://github.com/SkyAPM/SkyAPM-dotnet&quot;&gt;SkyAPM-dotnet&lt;/a&gt;的&lt;a href=&quot;https://github.com/SkyAPM/SkyAPM-dotnet/blob/master/src/SkyApm.Diagnostics.AspNetCore/HostingDiagnosticProcessor.cs&quot;&gt;实现&lt;/a&gt;就是通过消费诊断日志，进行链路跟踪。&lt;br/&gt;3. EventBus：充分利用其发布订阅模式，可将其用于进程内事件的发布与消费。&lt;/p&gt;

&lt;h2 id=&quot;51-activity-概述&quot;&gt;5.1. Activity 概述&lt;/h2&gt;
&lt;p&gt;那Activity又是何方神圣，用于解决什么问题呢？关于Activity官方只有一句简要介绍：Represents an operation with context to be used for logging。（表示包含上下文的操作，用于日志记录。）&lt;/p&gt;
&lt;p&gt;Activity用来存储和访问诊断上下文，并由日志系统进行消费。当应用程序开始处理操作时，例如HTTP请求或队列中的任务，它会在处理请求时创建Activity以在系统中跟踪该Activity。Activity中存储的上下文可以是HTTP请求路径，方法，用户代理或关联ID：所有重要信息都应与每个跟踪一起记录。当应用程序调用外部依赖关系以完成操作时，它可能需要传递一些上下文（例如，关联ID）以及依赖关系调用，以便能够关联来自多个服务的日志。&lt;/p&gt;
&lt;p&gt;先来看下Activity主要以下核心属性：&lt;/p&gt;
&lt;ol readability=&quot;20&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;Tags（标签）&lt;br/&gt;&lt;code&gt;IEnumerable&amp;lt;KeyValuePair&amp;lt;string, string&amp;gt;&amp;gt; Tags { get; }&lt;/code&gt; - 表示与活动一起记录的信息。标签的好例子是实例/机器名称，传入请求HTTP方法，路径，用户/用户代理等。标签&lt;strong&gt;不传递&lt;/strong&gt;给子活动。&lt;br/&gt;典型的标签用法包括添加一些自定义标签，并通过它们进行枚举以填充日志事件的有效负载。可通过&lt;code&gt;Activity AddTag(string key, string value)&lt;/code&gt;添加Tag，但不支持通过Key检索标签。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;Baggage（行李）&lt;br/&gt;&lt;code&gt;IEnumerable&amp;lt;KeyValuePair&amp;lt;string, string&amp;gt;&amp;gt; Baggage { get; }&lt;/code&gt; - 表示要与活动一起记录&lt;strong&gt;并传递给其子项&lt;/strong&gt;的信息。行李的例子包括相关ID，采样和特征标记。&lt;br/&gt;Baggage被序列化并与外部依赖项请求一起传递。&lt;br/&gt;典型的Baggage用法包括添加一些Baggage属性，并通过它们进行枚举以填充日志事件的有效负载。&lt;br/&gt;可通过&lt;code&gt;Activity AddBaggage(string key, string value)&lt;/code&gt;添加Baggage。并通过&lt;code&gt;string GetBaggageItem(string key)&lt;/code&gt;获取指定Key的Baggage。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;OperationName（操作名称）&lt;br/&gt;&lt;code&gt;string OperationName { get; }&lt;/code&gt; - 活动名称，必须在构造函数中指定。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;StartTimeUtc&lt;br/&gt;&lt;code&gt;DateTime StartTimeUtc { get; private set; }&lt;/code&gt; - UTC格式的启动时间，如果不指定，则在启动时默认指定为&lt;code&gt;DateTime.UtcNow&lt;/code&gt;。可通过&lt;code&gt;Activity SetStartTime(DateTime startTimeUtc)&lt;/code&gt;指定。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Duration&lt;br/&gt;&lt;code&gt;TimeSpan Duration { get; private set; }&lt;/code&gt; - 如果活动已停止，则代表活动持续时间，否则为0。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;Id&lt;br/&gt;&lt;code&gt;string Id { get; private set; }&lt;/code&gt; - 表示特定的活动标识符。过滤特定ID可确保您仅获得与操作中特定请求相关的日志记录。该Id在活动开始时生成。Id传递给外部依赖项，并被视为新的外部活动的[ParentId]。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;ParentId&lt;br/&gt;&lt;code&gt;string ParentId { get; private set; }&lt;/code&gt; - 如果活动是根据请求反序列化的，则该活动可能具有进程中的[Parent]或外部Parent。 ParentId和Id代表日志中的父子关系，并允许您关联传出和传入请求。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;RootId&lt;br/&gt;&lt;code&gt;string RootId { get; private set; }&lt;/code&gt; - 代表根Id&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Current&lt;br/&gt;&lt;code&gt;static Activity Current { get; }&lt;/code&gt; - 返回在异步调用之间流动的当前Activity。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;Parent&lt;br/&gt;&lt;code&gt;Activity Parent { get; private set; }&lt;/code&gt; - 如果活动是在同一过程中从另一个活动创建的，则可以使用&lt;code&gt;Partent&lt;/code&gt;获得该活动。但是，如果“活动”是根活动或父项来自流程外部，则此字段可能为null。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Start()&lt;br/&gt;&lt;code&gt;Activity Start()&lt;/code&gt; - 启动活动：设置活动的Activity.Current和Parent，生成唯一的ID并设置StartTimeUtc（如果尚未设置）。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Stop()&lt;br/&gt;&lt;code&gt;void Stop()&lt;/code&gt; - 停止活动：设置活动的Activity.Current，并使用&lt;code&gt;Activity SetEndTime(DateTime endTimeUtc)&lt;/code&gt;或DateTime.UtcNow中提供的时间戳计算Duration。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;另外&lt;code&gt;DiagnosticSource&lt;/code&gt;中也定义了两个相关方法：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;StartActivity&lt;br/&gt;&lt;code&gt;Activity StartActivity(Activity activity, object args)&lt;/code&gt; - 启动给定的Activity，并将&lt;code&gt;DiagnosticSource&lt;/code&gt;事件消息写入&lt;code&gt;OperationName.Start&lt;/code&gt;格式的命名事件中。&lt;/li&gt;
&lt;li&gt;StopActivity&lt;br/&gt;&lt;code&gt;void StopActivity(Activity activity, object args)&lt;/code&gt; - 停止给定的Activity，并将&lt;code&gt;DiagnosticSource&lt;/code&gt;事件消息写入&lt;code&gt;{OperationName}.Stop&lt;/code&gt;格式的命名事件中。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;52-activity在aspnet-core中的应用&quot;&gt;5.2. Activity在ASP.NET Core中的应用&lt;/h2&gt;
&lt;p&gt;要想弄懂Activity，我们还是得向源码学习，看一下&lt;a href=&quot;https://github.com/dotnet/aspnetcore/blob/master/src/Hosting/Hosting/src/Internal/HostingApplicationDiagnostics.cs&quot;&gt;HostingApplicationDiagnostics&lt;/a&gt;的实现。首先来看下&lt;code&gt;BeginRequst&lt;/code&gt;中的&lt;code&gt;StartActivity&lt;/code&gt;方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private Activity StartActivity(HttpContext httpContext, out bool hasDiagnosticListener)
{
  Activity activity = new Activity(&quot;Microsoft.AspNetCore.Hosting.HttpRequestIn&quot;);
  hasDiagnosticListener = false;
  IHeaderDictionary headers = httpContext.Request.Headers;
  StringValues stringValues1;
  if (!headers.TryGetValue(HeaderNames.TraceParent, out stringValues1))
    headers.TryGetValue(HeaderNames.RequestId, out stringValues1);
  if (!StringValues.IsNullOrEmpty(stringValues1))
  {
    activity.SetParentId((string) stringValues1);
    StringValues stringValues2;
    if (headers.TryGetValue(HeaderNames.TraceState, out stringValues2))
      activity.TraceStateString = (string) stringValues2;
    string[] commaSeparatedValues = headers.GetCommaSeparatedValues(HeaderNames.CorrelationContext);
    if (commaSeparatedValues.Length != 0)
    {
      foreach (string str in commaSeparatedValues)
      {
        NameValueHeaderValue parsedValue;
        if (NameValueHeaderValue.TryParse((StringSegment) str, out parsedValue))
          activity.AddBaggage(parsedValue.Name.ToString(), parsedValue.Value.ToString());
      }
    }
  }
  this._diagnosticListener.OnActivityImport(activity, (object) httpContext);
  if (this._diagnosticListener.IsEnabled(&quot;Microsoft.AspNetCore.Hosting.HttpRequestIn.Start&quot;))
  {
    hasDiagnosticListener = true;
    this.StartActivity(activity, httpContext);
  }
  else
    activity.Start();
  return activity;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从中可以看出，在ASP.NET Core 开始处理请求之前：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;首先，创建了名为&lt;code&gt;Microsoft.AspNetCore.Hosting.HttpRequestIn&lt;/code&gt;的Activity，该Activity首先尝试从HTTP请求头中获取TraceParent/euqstId作为当前Activity的ParentId，这个很显然，是用来链路跟踪的。&lt;/li&gt;
&lt;li&gt;其次，尝试从&lt;code&gt;CorrelationContext&lt;/code&gt;中获取关联上下文信息，然后将其添加到创建的Activity的Baggage中，进行关联上下文的继续传递。&lt;/li&gt;
&lt;li&gt;然后，启动Activity，然后向Name为&lt;code&gt;Microsoft.AspNetCore.Hosting.HttpRequestIn.Start&lt;/code&gt;中写入诊断日志。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这里大家可能有个疑问，这个关联上下文信息&lt;code&gt;CorrelationContext&lt;/code&gt;又是何时添加到Http请求头中的呢？在&lt;code&gt;System.Net.Http&lt;/code&gt;中的&lt;a href=&quot;https://github.com/dotnet/runtime/blob/master/src/libraries/System.Net.Http/src/System/Net/Http/DiagnosticsHandler.cs&quot;&gt;DiagnosticsHandler&lt;/a&gt;中添加的。&lt;br/&gt;因此我们应该明白了，整个关联上下文的传递机制。&lt;/p&gt;
&lt;p&gt;紧接着再来看一看&lt;code&gt;RequestEnd&lt;/code&gt;中的&lt;code&gt;StopActivity&lt;/code&gt;方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private void StopActivity(Activity activity, HttpContext httpContext)
{
  if (activity.Duration == TimeSpan.Zero)
    activity.SetEndTime(DateTime.UtcNow);
  this._diagnosticListener.Write(&quot;Microsoft.AspNetCore.Hosting.HttpRequestIn.Stop&quot;, (object) httpContext);
  activity.Stop();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从中可以看出主要是先&lt;code&gt;SetEndTime&lt;/code&gt;，再写入&lt;code&gt;Microsoft.AspNetCore.Hosting.HttpRequestIn.Stop&lt;/code&gt;命名事件；最后调用&lt;code&gt;Stop&lt;/code&gt;方法停止当前Activity。&lt;/p&gt;
&lt;p&gt;简单总结一下，借助Activity中附加的Baggage信息可以实现请求链路上上下文数据的共享。&lt;/p&gt;
&lt;h2 id=&quot;53-应用场景思考&quot;&gt;5.3. 应用场景思考&lt;/h2&gt;
&lt;p&gt;从上面的命名事件中可以看出，其封送的数据类型是特定的，因此可以借助Activity的Tags或Baggage添加自定义的数据进行共享。&lt;/p&gt;
&lt;p&gt;按照上面我们的耗时统计，只能统计到整个http请求的耗时，但对于我们定位问题来说还是有困难，比如，某个api即有调用redis，又操作了消息队列，同时又访问了数据库，那到底是那一段超时了呢？显然不好直接定位，借助activity，我们就可以很好的实现细粒度的链路跟踪。通过activity携带的信息，可以将一系列的操作关联起来，记录日志，再借助AMP进行可视化快速定位跟踪。&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/savorboard/p/diagnostics.html&quot;&gt;在 .NET Core 中使用 Diagnostics (Diagnostic Source) 记录跟踪信息&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://andrewlock.net/logging-using-diagnosticsource-in-asp-net-core/&quot;&gt;Logging using DiagnosticSource in ASP.NET Core&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/wucy/p/13532534.html&quot;&gt;.Net Core中的诊断日志DiagnosticSource讲解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/standard/events/observer-design-pattern&quot;&gt;Observer Design Pattern&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/runtime/blob/master/src/libraries/System.Diagnostics.DiagnosticSource/src/DiagnosticSourceUsersGuide.md&quot;&gt;DiagnosticSource User Guide&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/runtime/blob/master/src/libraries/System.Diagnostics.DiagnosticSource/src/ActivityUserGuide.md&quot;&gt;Activity User Guide&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a&gt;DiagnosticSourcery 101 - Mark Rendle&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://devblogs.microsoft.com/aspnet/improvements-in-net-core-3-0-for-troubleshooting-and-monitoring-distributed-apps/&quot;&gt;Improvements in .NET Core 3.0 for troubleshooting and monitoring distributed apps&lt;br/&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Sat, 10 Oct 2020 00:03:00 +0000</pubDate>
<dc:creator>「圣杰」</dc:creator>
<og:description>1. 引言 最近为了解决ABP集成CAP时无法通过拦截器启用工作单元的问题，从小伙伴那里学了一招。借助DiagnossticSource，可以最小改动完成需求。关于DiagnosticSource晓东</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sheng-jie/p/how-much-you-know-about-diagnostic-in-dotnet.html</dc:identifier>
</item>
<item>
<title>js日志输出还是只会console.log么，那你就out了 - 字母哥博客</title>
<link>http://www.cnblogs.com/zimug/p/13790005.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zimug/p/13790005.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202010/1815316-20201010073804416-899051342.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;几乎所有的javascript开发者最常使用的日志打印调试api都是&lt;code&gt;console.log()&lt;/code&gt;,其实还有很多的选项供我们选择，笔者下面就为大家一一介绍.&lt;/p&gt;
&lt;h2 id=&quot;一、consoletable&quot;&gt;一、console.table()&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;console.table()&lt;/code&gt;是我非常建议大家去使用的方法，它可以接受JSON或数组并以表格格式打印，在对json对象和数组进行可视化打印的时候简单易用，结果直观。&lt;/p&gt;
&lt;p&gt;比如下面的json数据对象使用&lt;code&gt;console.table()&lt;/code&gt;打印&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    console.table({
    &quot;id&quot;:&quot;1&quot;,
    &quot;key&quot;:&quot;value&quot;,
    &quot;count&quot;:2
    });
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;控制台的输出结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202010/1815316-20201010073805044-1063580885.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;又比如对下面代码中的数组进行打印：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; console.table([
    {
        id: &quot;1&quot;,
        key: &quot;value&quot;,
        count: 2,
        },
     {
         id: &quot;2&quot;,
         key: &quot;value2&quot;,
             count: 22,
       },
       {
            id: &quot;3&quot;,
            key: &quot;value3&quot;,
                count: 5,
               },
     ]);

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;控制台的输出结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202010/1815316-20201010073805255-892142785.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;二、consoleerror&quot;&gt;二、console.error()&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;console.error()&lt;/code&gt;相对于&lt;code&gt;console.log()&lt;/code&gt;更有助于在调试时从输出日志中区分错误信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202010/1815316-20201010073805528-272372703.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上图中可以看到，它的输出打印结果是红色的。&lt;/p&gt;
&lt;h2 id=&quot;三、timetimetimelogtimeend&quot;&gt;三、Time(time,timeLog,timeEnd)&lt;/h2&gt;
&lt;p&gt;console.time()、console.timeLog()、console.timeEnd() 这三个方法当我们对程序运行时间进行计时的时候特别有用。&lt;/p&gt;
&lt;p&gt;参考下图理解这三个方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202010/1815316-20201010073805714-1362255397.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;console.time()相当于秒表中的开始按钮&lt;/li&gt;
&lt;li&gt;console.timeLog()相当于秒表中的按圈计时/按点计时&lt;/li&gt;
&lt;li&gt;console.timeEnd()相当于计时结束&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;console.time(&quot;ForLoop&quot;);  
 // &quot;ForLoop&quot; is label here
for (let i = 0; i &amp;lt; 5; i++) {
    console.timeLog('ForLoop'); 
}
console.timeEnd(&quot;ForLoop&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;控制台打印输出结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202010/1815316-20201010073805886-1882328881.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;四、consolewarn&quot;&gt;四、&lt;code&gt;console.warn()&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;用黄色字体输出日志，更直观的方便的查看警告类日志信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202010/1815316-20201010073806125-1598764827.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;五、consoleassert&quot;&gt;五、console.assert()&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;console.assert(assert_statement,message)&lt;/code&gt;用来设定断言，如果为&lt;strong&gt;false&lt;/strong&gt;则显示message消息&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if(3!=2){
    console.error({ msg1: &quot;msg1&quot;, msg2: &quot;msg2&quot; });
}
//上面的日志判断语句，可以简写为下面的断言
console.assert(3 === 2, { msg1: &quot;msg1&quot;, msg2: &quot;msg2&quot; });

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202010/1815316-20201010073806282-238168627.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;另一种可以用来格式化输出的断言方式&lt;/strong&gt;&lt;code&gt;console.assert(assert_statement,message,args)&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;console.assert(false, &quot;%d nd type for  %s &quot;,2,&quot;console.assert() method&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202010/1815316-20201010073806462-64734286.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;六、consolecount&quot;&gt;六、console.count()&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;console.count()&lt;/code&gt;特别适合用来计数，可以传递参数，可以根据根据参数标签统计次数。代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; for (let i = 0; i &amp;lt; 3; i++) {
   console.count(&quot;label&quot;);
   console.count();
   console.count(i);
 }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;控制台打印输出的结果，类似于下面这样&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; console.count()  console.count(&quot;label&quot;)   console.count(i)
 default: 1                label: 1                0: 1
 default: 2                label: 2                1: 1
 default: 3                label: 3                2: 1
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;console.count()&lt;/code&gt;如果不传递参数，则使用默认的default标签。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;console.countReset(标签参数)&lt;/code&gt;可以将指定标签的计数重置为&lt;strong&gt;0&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;欢迎关注我的博客，里面有很多精品合集&quot;&gt;欢迎关注我的博客，里面有很多精品合集&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;本文转载注明出处（必须带连接，不能只转文字）：&lt;a href=&quot;http://www.zimug.com&quot;&gt;字母哥博客&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;觉得对您有帮助的话，帮我点赞、分享！您的支持是我不竭的创作动力！&lt;/strong&gt; 。另外，笔者最近一段时间输出了如下的精品内容，期待您的关注。&lt;/p&gt;
</description>
<pubDate>Fri, 09 Oct 2020 23:38:00 +0000</pubDate>
<dc:creator>字母哥博客</dc:creator>
<og:description>几乎所有的javascript开发者最常使用的日志打印调试api都是console.log(),其实还有很多的选项供我们选择，笔者下面就为大家一一介绍. 一、console.table() conso</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zimug/p/13790005.html</dc:identifier>
</item>
<item>
<title>全方位剖析 Linux 操作系统，太全了！！！ - 程序员cxuan</title>
<link>http://www.cnblogs.com/cxuanBlog/p/13789900.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cxuanBlog/p/13789900.html</guid>
<description>&lt;h2 id=&quot;linux-简介&quot;&gt;Linux 简介&lt;/h2&gt;
&lt;p&gt;UNIX 是一个交互式系统，用于同时处理多进程和多用户同时在线。为什么要说 UNIX，那是因为 Linux 是由 UNIX 发展而来的，UNIX 是由程序员设计，它的主要服务对象也是程序员。Linux 继承了 UNIX 的设计目标。从智能手机到汽车，超级计算机和家用电器，从家用台式机到企业服务器，Linux 操作系统无处不在。&lt;/p&gt;
&lt;p&gt;大多数程序员都喜欢让系统尽量简单，优雅并具有一致性。举个例子，从最底层的角度来讲，一个文件应该只是一个字节集合。为了实现顺序存取、随机存取、按键存取、远程存取只能是妨碍你的工作。相同的，如果命令&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;ls A*
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;意味着只列出以 A 为开头的所有文件，那么命令&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;rm A*
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;应该会移除所有以 A 为开头的文件而不是只删除文件名是 &lt;code&gt;A*&lt;/code&gt; 的文件。这个特性也是&lt;code&gt;最小吃惊原则(principle of least surprise)&lt;/code&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;最小吃惊原则一半常用于用户界面和软件设计。它的原型是：该功能或者特征应该符合用户的预期，不应该使用户感到惊讶和震惊。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一些有经验的程序员通常希望系统具有较强的功能性和灵活性。设计 Linux 的一个基本目标是每个应用程序只做一件事情并把他做好。所以编译器只负责编译的工作，编译器不会产生列表，因为有其他应用比编译器做的更好。&lt;/p&gt;
&lt;p&gt;很多人都不喜欢冗余，为什么在 cp 就能描述清楚你想干什么时候还使用 copy？这完全是在浪费宝贵的 &lt;code&gt;hacking time&lt;/code&gt;。为了从文件中提取所有包含字符串 &lt;code&gt;ard&lt;/code&gt; 的行，Linux 程序员应该输入&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;grep ard f
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;linux-接口&quot;&gt;Linux 接口&lt;/h3&gt;
&lt;p&gt;Linux 系统是一种金字塔模型的系统，如下所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202010/1515111-20201010070233641-1312039505.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;应用程序发起系统调用把参数放在寄存器中(有时候放在栈中)，并发出 &lt;code&gt;trap&lt;/code&gt; 系统陷入指令切换用户态至内核态。因为不能直接在 C 中编写 trap 指令，因此 C 提供了一个库，库中的函数对应着系统调用。有些函数是使用汇编编写的，但是能够从 C 中调用。每个函数首先把参数放在合适的位置然后执行系统调用指令。因此如果你想要执行 read 系统调用的话，C 程序会调用 read 函数库来执行。这里顺便提一下，是由 POSIX 指定的库接口而不是系统调用接口。也就是说，POSIX 会告诉一个标准系统应该提供哪些库过程，它们的参数是什么，它们必须做什么以及它们必须返回什么结果。&lt;/p&gt;
&lt;p&gt;除了操作系统和系统调用库外，Linux 操作系统还要提供一些标准程序，比如文本编辑器、编译器、文件操作工具等。直接和用户打交道的是上面这些应用程序。因此我们可以说 Linux 具有三种不同的接口：&lt;strong&gt;系统调用接口、库函数接口和应用程序接口&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Linux 中的 &lt;code&gt;GUI(Graphical User Interface)&lt;/code&gt; 和 UNIX 中的非常相似，这种 GUI 创建一个桌面环境，包括窗口、目标和文件夹、工具栏和文件拖拽功能。一个完整的 GUI 还包括窗口管理器以及各种应用程序。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202010/1515111-20201010070244927-1172503843.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Linux 上的 GUI 由 X 窗口支持，主要组成部分是 X 服务器、控制键盘、鼠标、显示器等。当在 Linux 上使用图形界面时，用户可以通过鼠标点击运行程序或者打开文件，通过拖拽将文件进行复制等。&lt;/p&gt;
&lt;h3 id=&quot;linux-组成部分&quot;&gt;Linux 组成部分&lt;/h3&gt;
&lt;p&gt;事实上，Linux 操作系统可以由下面这几部分构成&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;引导程序(Bootloader)&lt;/code&gt;：引导程序是管理计算机启动过程的软件，对于大多数用户而言，只是弹出一个屏幕，但其实内部操作系统做了很多事情&lt;/li&gt;
&lt;li&gt;&lt;code&gt;内核(Kernel)&lt;/code&gt;：内核是操作系统的核心，负责管理 CPU、内存和外围设备等。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;初始化系统(Init System)&lt;/code&gt;：这是一个引导用户空间并负责控制守护程序的子系统。一旦从引导加载程序移交了初始引导，它就是用于管理引导过程的初始化系统。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;后台进程(Daemon)&lt;/code&gt;：后台进程顾名思义就是在后台运行的程序，比如打印、声音、调度等，它们可以在引导过程中启动，也可以在登录桌面后启动&lt;/li&gt;
&lt;li&gt;&lt;code&gt;图形服务器(Graphical server)&lt;/code&gt;：这是在监视器上显示图形的子系统。通常将其称为 X 服务器或 X。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;桌面环境(Desktop environment)&lt;/code&gt;：这是用户与之实际交互的部分，有很多桌面环境可供选择，每个桌面环境都包含内置应用程序，比如文件管理器、Web 浏览器、游戏等&lt;/li&gt;
&lt;li&gt;&lt;code&gt;应用程序(Applications)&lt;/code&gt;：桌面环境不提供完整的应用程序，就像 Windows 和 macOS 一样，Linux 提供了成千上万个可以轻松找到并安装的高质量软件。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;shell&quot;&gt;Shell&lt;/h3&gt;
&lt;p&gt;尽管 Linux 应用程序提供了 GUI ，但是大部分程序员仍偏好于使用&lt;code&gt;命令行(command-line interface)&lt;/code&gt;，称为&lt;code&gt;shell&lt;/code&gt;。用户通常在 GUI 中启动一个 shell 窗口然后就在 shell 窗口下进行工作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202010/1515111-20201010070253705-671153863.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;shell 命令行使用速度快、功能更强大、而且易于扩展、并且不会带来&lt;code&gt;肢体重复性劳损(RSI)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;下面会介绍一些最简单的 bash shell。当 shell 启动时，它首先进行初始化，在屏幕上输出一个 &lt;code&gt;提示符(prompt)&lt;/code&gt;，通常是一个百分号或者美元符号，等待用户输入&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202010/1515111-20201010070300569-1672754686.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;等用户输入一个命令后，shell 提取其中的第一个词，这里的词指的是被空格或制表符分隔开的一连串字符。假定这个词是将要运行程序的程序名，那么就会搜索这个程序，如果找到了这个程序就会运行它。然后 shell 会将自己挂起直到程序运行完毕，之后再尝试读入下一条指令。shell 也是一个普通的用户程序。它的主要功能就是读取用户的输入和显示计算的输出。shell 命令中可以包含参数，它们作为字符串传递给所调用的程序。比如&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;cp src dest
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;会调用 cp 应用程序并包含两个参数 &lt;code&gt;src&lt;/code&gt; 和 &lt;code&gt;dest&lt;/code&gt;。这个程序会解释第一个参数是一个已经存在的文件名，然后创建一个该文件的副本，名称为 dest。&lt;/p&gt;
&lt;p&gt;并不是所有的参数都是文件名，比如下面&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;head -20 file
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第一个参数 -20，会告诉 head 应用程序打印文件的前 20 行，而不是默认的 10 行。控制命令操作或者指定可选值的参数称为&lt;code&gt;标志(flag)&lt;/code&gt;，按照惯例标志应该使用 &lt;code&gt;-&lt;/code&gt; 来表示。这个符号是必要的，比如&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;head 20 file
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;是一个完全合法的命令，它会告诉 head 程序输出文件名为 20 的文件的前 10 行，然后输出文件名为 file 文件的前 10 行。Linux 操作系统可以接受一个或多个参数。&lt;/p&gt;
&lt;p&gt;为了更容易的指定多个文件名，shell 支持 &lt;code&gt;魔法字符(magic character)&lt;/code&gt;，也被称为&lt;code&gt;通配符(wild cards)&lt;/code&gt;。比如，&lt;code&gt;*&lt;/code&gt; 可以匹配一个或者多个可能的字符串&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;ls *.c
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;告诉 ls 列举出所有文件名以 &lt;code&gt;.c&lt;/code&gt; 结束的文件。如果同时存在多个文件，则会在后面进行并列。&lt;/p&gt;
&lt;p&gt;另一个通配符是问号，负责匹配任意一个字符。一组在中括号中的字符可以表示其中任意一个，因此&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;ls [abc]*
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;会列举出所有以 &lt;code&gt;a&lt;/code&gt;、&lt;code&gt;b&lt;/code&gt; 或者 &lt;code&gt;c&lt;/code&gt; 开头的文件。&lt;/p&gt;
&lt;p&gt;shell 应用程序不一定通过终端进行输入和输出。shell 启动时，就会获取 &lt;strong&gt;标准输入、标准输出、标准错误&lt;/strong&gt;文件进行访问的能力。&lt;/p&gt;
&lt;p&gt;标准输出是从键盘输入的，标准输出或者标准错误是输出到显示器的。许多 Linux 程序默认是从标准输入进行输入并从标准输出进行输出。比如&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;sort  
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;会调用 sort 程序，会从终端读取数据(直到用户输入 ctrl-d 结束)，根据字母顺序进行排序，然后将结果输出到屏幕上。&lt;/p&gt;
&lt;p&gt;通常还可以重定向标准输入和标准输出，重定向标准输入使用 &lt;code&gt;&amp;lt;&lt;/code&gt; 后面跟文件名。标准输出可以通过一个大于号 &lt;code&gt;&amp;gt;&lt;/code&gt; 进行重定向。允许一个命令中重定向标准输入和输出。例如命令&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;sort &amp;lt;in &amp;gt;out
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;会使 sort 从文件 in 中得到输入，并把结果输出到 out 文件中。由于标准错误没有重定向，所以错误信息会直接打印到屏幕上。从标准输入读入，对其进行处理并将其写入到标准输出的程序称为 &lt;code&gt;过滤器&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;考虑下面由三个分开的命令组成的指令&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;sort &amp;lt;in &amp;gt;temp;head -30 &amp;lt;temp;rm temp
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先会调用 sort 应用程序，从标准输入 in 中进行读取，并通过标准输出到 temp。当程序运行完毕后，shell 会运行 head ，告诉它打印前 30 行，并在标准输出(默认为终端)上打印。最后，temp 临时文件被删除。&lt;strong&gt;轻轻的，你走了，你挥一挥衣袖，不带走一片云彩&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;命令行中的第一个程序通常会产生输出，在上面的例子中，产生的输出都不 temp 文件接收。然而，Linux 还提供了一个简单的命令来做这件事，例如下面&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;sort &amp;lt;in | head -30
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面 &lt;code&gt;|&lt;/code&gt; 称为竖线符号，它的意思是从 sort 应用程序产生的排序输出会直接作为输入显示，无需创建、使用和移除临时文件。由管道符号连接的命令集合称为&lt;code&gt;管道(pipeline)&lt;/code&gt;。例如如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;grep cxuan *.c | sort | head -30 | tail -5 &amp;gt;f00
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对任意以 &lt;code&gt;.t&lt;/code&gt; 结尾的文件中包含 &lt;code&gt;cxuan&lt;/code&gt; 的行被写到标准输出中，然后进行排序。这些内容中的前 30 行被 head 出来并传给 tail ，它又将最后 5 行传递给 foo。这个例子提供了一个管道将多个命令连接起来。&lt;/p&gt;
&lt;p&gt;可以把一系列 shell 命令放在一个文件中，然后将此文件作为输入来运行。shell 会按照顺序对他们进行处理，就像在键盘上键入命令一样。包含 shell 命令的文件被称为 &lt;code&gt;shell 脚本(shell scripts)&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;3.0714285714286&quot;&gt;
&lt;p&gt;推荐一个 shell 命令的学习网站：&lt;a href=&quot;https://www.shellscript.sh/&quot;&gt;https://www.shellscript.sh/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;shell 脚本其实也是一段程序，shell 脚本中可以对变量进行赋值，也包含循环控制语句比如 &lt;strong&gt;if、for、while&lt;/strong&gt; 等，shell 的设计目标是让其看起来和 C 相似(There is no doubt that C is father)。由于 shell 也是一个用户程序，所以用户可以选择不同的 shell。&lt;/p&gt;
&lt;h3 id=&quot;linux-应用程序&quot;&gt;Linux 应用程序&lt;/h3&gt;
&lt;p&gt;Linux 的命令行也就是 shell，它由大量标准应用程序组成。这些应用程序主要有下面六种&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;文件和目录操作命令&lt;/li&gt;
&lt;li&gt;过滤器&lt;/li&gt;
&lt;li&gt;文本程序&lt;/li&gt;
&lt;li&gt;系统管理&lt;/li&gt;
&lt;li&gt;程序开发工具，例如编辑器和编译器&lt;/li&gt;
&lt;li&gt;其他&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;除了这些标准应用程序外，还有其他应用程序比如 &lt;strong&gt;Web 浏览器、多媒体播放器、图片浏览器、办公软件和游戏程序等&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我们在上面的例子中已经见过了几个 Linux 的应用程序，比如 sort、cp、ls、head，下面我们再来认识一下其他 Linux 的应用程序。&lt;/p&gt;
&lt;p&gt;我们先从几个例子开始讲起，比如&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;cp a b
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;是将 a 复制一个副本为 b ，而&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;mv a b
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;是将 a 移动到 b ，但是删除原文件。&lt;/p&gt;
&lt;p&gt;上面这两个命令有一些区别，&lt;code&gt;cp&lt;/code&gt; 是将文件进行复制，复制完成后会有两个文件 a 和 b；而 &lt;code&gt;mv&lt;/code&gt; 相当于是文件的移动，移动完成后就不再有 a 文件。&lt;code&gt;cat&lt;/code&gt; 命令可以把多个文件内容进行连接。使用 &lt;code&gt;rm&lt;/code&gt; 可以删除文件；使用 &lt;code&gt;chmod&lt;/code&gt; 可以允许所有者改变访问权限；文件目录的的创建和删除可以使用 &lt;code&gt;mkdir&lt;/code&gt; 和 &lt;code&gt;rmdir&lt;/code&gt; 命令；使用 &lt;code&gt;ls&lt;/code&gt; 可以查看目录文件，ls 可以显示很多属性，比如大小、用户、创建日期等；sort 决定文件的显示顺序&lt;/p&gt;
&lt;p&gt;Linux 应用程序还包括过滤器 grep，&lt;code&gt;grep&lt;/code&gt; 从标准输入或者一个或多个输入文件中提取特定模式的行；&lt;code&gt;sort&lt;/code&gt; 将输入进行排序并输出到标准输出；&lt;code&gt;head&lt;/code&gt; 提取输入的前几行；tail 提取输入的后面几行；除此之外的过滤器还有 &lt;code&gt;cut&lt;/code&gt; 和 &lt;code&gt;paste&lt;/code&gt;，允许对文本行的剪切和复制；&lt;code&gt;od&lt;/code&gt; 将输入转换为 ASCII ；&lt;code&gt;tr&lt;/code&gt; 实现字符大小写转换；&lt;code&gt;pr&lt;/code&gt; 为格式化打印输出等。&lt;/p&gt;
&lt;p&gt;程序编译工具使用 &lt;code&gt;gcc&lt;/code&gt; ；&lt;/p&gt;
&lt;p&gt;&lt;code&gt;make&lt;/code&gt; 命令用于自动编译，这是一个很强大的命令，它用于维护一个大的程序，往往这类程序的源码由许多文件构成。典型的，有一些是 &lt;code&gt;header files 头文件&lt;/code&gt;，源文件通常使用 &lt;code&gt;include&lt;/code&gt; 指令包含这些文件，make 的作用就是跟踪哪些文件属于头文件，然后安排自动编译的过程。&lt;/p&gt;
&lt;p&gt;下面列出了 POSIX 的标准应用程序&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;程序&lt;/th&gt;
&lt;th&gt;应用&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr&gt;&lt;td&gt;ls&lt;/td&gt;
&lt;td&gt;列出目录&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;cp&lt;/td&gt;
&lt;td&gt;复制文件&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;head&lt;/td&gt;
&lt;td&gt;显示文件的前几行&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;make&lt;/td&gt;
&lt;td&gt;编译文件生成二进制文件&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;cd&lt;/td&gt;
&lt;td&gt;切换目录&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;mkdir&lt;/td&gt;
&lt;td&gt;创建目录&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;chmod&lt;/td&gt;
&lt;td&gt;修改文件访问权限&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;ps&lt;/td&gt;
&lt;td&gt;列出文件进程&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;pr&lt;/td&gt;
&lt;td&gt;格式化打印&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;rm&lt;/td&gt;
&lt;td&gt;删除一个文件&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;rmdir&lt;/td&gt;
&lt;td&gt;删除文件目录&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;tail&lt;/td&gt;
&lt;td&gt;提取文件最后几行&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;tr&lt;/td&gt;
&lt;td&gt;字符集转换&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;grep&lt;/td&gt;
&lt;td&gt;分组&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;cat&lt;/td&gt;
&lt;td&gt;将多个文件连续标准输出&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;od&lt;/td&gt;
&lt;td&gt;以八进制显示文件&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;cut&lt;/td&gt;
&lt;td&gt;从文件中剪切&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;paste&lt;/td&gt;
&lt;td&gt;从文件中粘贴&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;linux-内核结构&quot;&gt;Linux 内核结构&lt;/h3&gt;
&lt;p&gt;在上面我们看到了 Linux 的整体结构，下面我们从整体的角度来看一下 Linux 的内核结构&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202010/1515111-20201010070321871-1490308607.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;内核直接坐落在硬件上，内核的主要作用就是 I/O 交互、内存管理和控制 CPU 访问。上图中还包括了 &lt;code&gt;中断&lt;/code&gt; 和 &lt;code&gt;调度器&lt;/code&gt;，中断是与设备交互的主要方式。中断出现时调度器就会发挥作用。这里的低级代码停止正在运行的进程，将其状态保存在内核进程结构中，并启动驱动程序。进程调度也会发生在内核完成一些操作并且启动用户进程的时候。图中的调度器是 dispatcher。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;注意这里的调度器是 &lt;code&gt;dispatcher&lt;/code&gt; 而不是 &lt;code&gt;scheduler&lt;/code&gt;，这两者是有区别的&lt;/p&gt;
&lt;p&gt;scheduler 和 dispatcher 都是和进程调度相关的概念，不同的是 scheduler 会从几个进程中随意选取一个进程；而 dispatcher 会给 scheduler 选择的进程分配 CPU。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然后，我们把内核系统分为三部分。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;I/O 部分负责与设备进行交互以及执行网络和存储 I/O 操作的所有内核部分。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;从图中可以看出 I/O 层次的关系，最高层是一个&lt;code&gt;虚拟文件系统&lt;/code&gt;，也就是说不管文件是来自内存还是磁盘中，都是经过虚拟文件系统中的。从底层看，所有的驱动都是字符驱动或者块设备驱动。二者的主要区别就是是否允许随机访问。网络驱动设备并不是一种独立的驱动设备，它实际上是一种字符设备，不过网络设备的处理方式和字符设备不同。&lt;/p&gt;
&lt;p&gt;上面的设备驱动程序中，每个设备类型的内核代码都不同。字符设备有两种使用方式，有&lt;code&gt;一键式&lt;/code&gt;的比如 vi 或者 emacs ，需要每一个键盘输入。其他的比如 shell ，是需要输入一行按回车键将字符串发送给程序进行编辑。&lt;/p&gt;
&lt;p&gt;网络软件通常是模块化的，由不同的设备和协议来支持。大多数 Linux 系统在内核中包含一个完整的硬件路由器的功能，但是这个不能和外部路由器相比，路由器上面是&lt;code&gt;协议栈&lt;/code&gt;，包括 TCP/IP 协议，协议栈上面是 socket 接口，socket 负责与外部进行通信，充当了门的作用。&lt;/p&gt;
&lt;p&gt;磁盘驱动上面是 I/O 调度器，它负责排序和分配磁盘读写操作，以尽可能减少磁头的无用移动。&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;I/O 右边的是内存部件，程序被装载进内存，由 CPU 执行，这里会涉及到虚拟内存的部件，页面的换入和换出是如何进行的，坏页面的替换和经常使用的页面会进行缓存。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;进程模块负责进程的创建和终止、进程的调度、Linux 把进程和线程看作是可运行的实体，并使用统一的调度策略来进行调度。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在内核最顶层的是系统调用接口，所有的系统调用都是经过这里，系统调用会触发一个 trap，将系统从用户态转换为内核态，然后将控制权移交给上面的内核部件。&lt;/p&gt;
&lt;h2 id=&quot;linux-进程和线程&quot;&gt;Linux 进程和线程&lt;/h2&gt;
&lt;p&gt;下面我们就深入理解一下 Linux 内核来理解 Linux 的基本概念之进程和线程。系统调用是操作系统本身的接口，它对于创建进程和线程，内存分配，共享文件和 I/O 来说都很重要。&lt;/p&gt;
&lt;p&gt;我们将从各个版本的共性出发来进行探讨。&lt;/p&gt;
&lt;h3 id=&quot;基本概念&quot;&gt;基本概念&lt;/h3&gt;
&lt;p&gt;每个进程都会运行一段独立的程序，并且在初始化的时候拥有一个独立的控制线程。换句话说，每个进程都会有一个自己的程序计数器，这个程序计数器用来记录下一个需要被执行的指令。Linux 允许进程在运行时创建额外的线程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202010/1515111-20201010070332421-1302383462.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Linux 是一个多道程序设计系统，因此系统中存在彼此相互独立的进程同时运行。此外，每个用户都会同时有几个活动的进程。因为如果是一个大型系统，可能有数百上千的进程在同时运行。&lt;/p&gt;
&lt;p&gt;在某些用户空间中，即使用户退出登录，仍然会有一些后台进程在运行，这些进程被称为 &lt;code&gt;守护进程(daemon)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;Linux 中有一种特殊的守护进程被称为 &lt;code&gt;计划守护进程(Cron daemon)&lt;/code&gt; ，计划守护进程可以每分钟醒来一次检查是否有工作要做，做完会继续回到睡眠状态等待下一次唤醒。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202010/1515111-20201010070340841-355969658.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Cron 是一个守护程序，可以做任何你想做的事情，比如说你可以定期进行系统维护、定期进行系统备份等。在其他操作系统上也有类似的程序，比如 Mac OS X 上 Cron 守护程序被称为 &lt;code&gt;launchd&lt;/code&gt; 的守护进程。在 Windows 上可以被称为 &lt;code&gt;计划任务(Task Scheduler)&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在 Linux 系统中，进程通过非常简单的方式来创建，&lt;code&gt;fork&lt;/code&gt; 系统调用会创建一个源进程的&lt;code&gt;拷贝(副本)&lt;/code&gt;。调用 fork 函数的进程被称为 &lt;code&gt;父进程(parent process)&lt;/code&gt;，使用 fork 函数创建出来的进程被称为 &lt;code&gt;子进程(child process)&lt;/code&gt;。父进程和子进程都有自己的内存映像。如果在子进程创建出来后，父进程修改了一些变量等，那么子进程是看不到这些变化的，也就是 fork 后，父进程和子进程相互独立。&lt;/p&gt;
&lt;p&gt;虽然父进程和子进程保持相互独立，但是它们却能够共享相同的文件，如果在 fork 之前，父进程已经打开了某个文件，那么 fork 后，父进程和子进程仍然共享这个打开的文件。对共享文件的修改会对父进程和子进程同时可见。&lt;/p&gt;
&lt;p&gt;那么该如何区分父进程和子进程呢？子进程只是父进程的拷贝，所以它们几乎所有的情况都一样，包括内存映像、变量、寄存器等。区分的关键在于 &lt;code&gt;fork&lt;/code&gt; 函数调用后的返回值，如果 fork 后返回一个非零值，这个非零值即是子进程的 &lt;code&gt;进程标识符(Process Identiier, PID)&lt;/code&gt;，而会给子进程返回一个零值，可以用下面代码来进行表示&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;pid = fork();    // 调用 fork 函数创建进程
if(pid &amp;lt; 0){
  error()                                // pid &amp;lt; 0,创建失败
}
else if(pid &amp;gt; 0){
  parent_handle() // 父进程代码
}
else {
  child_handle()  // 子进程代码
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;父进程在 fork 后会得到子进程的 PID，这个 PID 即能代表这个子进程的唯一标识符也就是 PID。如果子进程想要知道自己的 PID，可以调用 &lt;code&gt;getpid&lt;/code&gt; 方法。当子进程结束运行时，父进程会得到子进程的 PID，因为一个进程会 fork 很多子进程，子进程也会 fork 子进程，所以 PID 是非常重要的。我们把第一次调用 fork 后的进程称为 &lt;code&gt;原始进程&lt;/code&gt;，一个原始进程可以生成一颗继承树&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202010/1515111-20201010070355675-561579263.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;linux-进程间通信&quot;&gt;Linux 进程间通信&lt;/h3&gt;
&lt;p&gt;Linux 进程间的通信机制通常被称为 &lt;code&gt;Internel-Process communication,IPC&lt;/code&gt; 下面我们来说一说 Linux 进程间通信的机制，大致来说，Linux 进程间的通信机制可以分为 6 种&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202010/1515111-20201010071358913-1960224314.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面我们分别对其进行概述&lt;/p&gt;
&lt;h4 id=&quot;信号-signal&quot;&gt;信号 signal&lt;/h4&gt;
&lt;p&gt;信号是 UNIX 系统最先开始使用的进程间通信机制，因为 Linux 是继承于 UNIX 的，所以 Linux 也支持信号机制，通过向一个或多个进程发送&lt;code&gt;异步事件信号&lt;/code&gt;来实现，信号可以从键盘或者访问不存在的位置等地方产生；信号通过 shell 将任务发送给子进程。&lt;/p&gt;
&lt;p&gt;你可以在 Linux 系统上输入 &lt;code&gt;kill -l&lt;/code&gt; 来列出系统使用的信号，下面是我提供的一些信号&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202010/1515111-20201010070427949-1825126513.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;进程可以选择忽略发送过来的信号，但是有两个是不能忽略的：&lt;code&gt;SIGSTOP&lt;/code&gt; 和 &lt;code&gt;SIGKILL&lt;/code&gt; 信号。SIGSTOP 信号会通知当前正在运行的进程执行关闭操作，SIGKILL 信号会通知当前进程应该被杀死。除此之外，进程可以选择它想要处理的信号，进程也可以选择阻止信号，如果不阻止，可以选择自行处理，也可以选择进行内核处理。如果选择交给内核进行处理，那么就执行默认处理。&lt;/p&gt;
&lt;p&gt;操作系统会中断目标程序的进程来向其发送信号、在任何非原子指令中，执行都可以中断，如果进程已经注册了新号处理程序，那么就执行进程，如果没有注册，将采用默认处理的方式。&lt;/p&gt;
&lt;p&gt;例如：当进程收到 &lt;code&gt;SIGFPE&lt;/code&gt; 浮点异常的信号后，默认操作是对其进行 &lt;code&gt;dump(转储)&lt;/code&gt;和退出。信号没有优先级的说法。如果同时为某个进程产生了两个信号，则可以将它们呈现给进程或者以任意的顺序进行处理。&lt;/p&gt;
&lt;p&gt;下面我们就来看一下这些信号是干什么用的&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;SIGABRT 和 SIGIOT&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;SIGABRT 和 SIGIOT 信号发送给进程，告诉其进行终止，这个 信号通常在调用 C标准库的&lt;code&gt;abort()&lt;/code&gt;函数时由进程本身启动&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;SIGALRM 、 SIGVTALRM、SIGPROF&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当设置的时钟功能超时时会将 SIGALRM 、 SIGVTALRM、SIGPROF 发送给进程。当实际时间或时钟时间超时时，发送 SIGALRM。 当进程使用的 CPU 时间超时时，将发送 SIGVTALRM。 当进程和系统代表进程使用的CPU 时间超时时，将发送 SIGPROF。&lt;/p&gt;
&lt;p&gt;SIGBUS 将造成&lt;code&gt;总线中断&lt;/code&gt;错误时发送给进程&lt;/p&gt;
&lt;p&gt;当子进程终止、被中断或者被中断恢复，将 SIGCHLD 发送给进程。此信号的一种常见用法是指示操作系统在子进程终止后清除其使用的资源。&lt;/p&gt;
&lt;p&gt;SIGCONT 信号指示操作系统继续执行先前由 SIGSTOP 或 SIGTSTP 信号暂停的进程。该信号的一个重要用途是在 Unix shell 中的作业控制中。&lt;/p&gt;
&lt;p&gt;SIGFPE 信号在执行错误的算术运算（例如除以零）时将被发送到进程。&lt;/p&gt;
&lt;p&gt;当 SIGUP 信号控制的终端关闭时，会发送给进程。许多守护程序将重新加载其配置文件并重新打开其日志文件，而不是在收到此信号时退出。&lt;/p&gt;
&lt;p&gt;SIGILL 信号在尝试执行非法、格式错误、未知或者特权指令时发出&lt;/p&gt;
&lt;p&gt;当用户希望中断进程时，操作系统会向进程发送 SIGINT 信号。用户输入 ctrl - c 就是希望中断进程。&lt;/p&gt;
&lt;p&gt;SIGKILL 信号发送到进程以使其马上进行终止。 与 SIGTERM 和 SIGINT 相比，这个信号无法捕获和忽略执行，并且进程在接收到此信号后无法执行任何清理操作，下面是一些例外情况&lt;/p&gt;
&lt;p&gt;僵尸进程无法杀死，因为僵尸进程已经死了，它在等待父进程对其进行捕获&lt;/p&gt;
&lt;p&gt;处于阻塞状态的进程只有再次唤醒后才会被 kill 掉&lt;/p&gt;
&lt;p&gt;&lt;code&gt;init&lt;/code&gt; 进程是 Linux 的初始化进程，这个进程会忽略任何信号。&lt;/p&gt;
&lt;p&gt;SIGKILL 通常是作为最后杀死进程的信号、它通常作用于 SIGTERM 没有响应时发送给进程。&lt;/p&gt;
&lt;p&gt;SIGPIPE 尝试写入进程管道时发现管道未连接无法写入时发送到进程&lt;/p&gt;
&lt;p&gt;当在明确监视的文件描述符上发生事件时，将发送 SIGPOLL 信号。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;SIGRTMIN 至 SIGRTMAX&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;SIGRTMIN 至 SIGRTMAX 是&lt;code&gt;实时信号&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;当用户请求退出进程并执行核心转储时，SIGQUIT 信号将由其控制终端发送给进程。&lt;/p&gt;
&lt;p&gt;当 SIGSEGV 信号做出无效的虚拟内存引用或分段错误时，即在执行分段违规时，将其发送到进程。&lt;/p&gt;
&lt;p&gt;SIGSTOP 指示操作系统终止以便以后进行恢复时&lt;/p&gt;
&lt;p&gt;当 SIGSYS 信号将错误参数传递给系统调用时，该信号将发送到进程。&lt;/p&gt;
&lt;p&gt;我们上面简单提到过了 SYSTERM 这个名词，这个信号发送给进程以请求终止。与 SIGKILL 信号不同，该信号可以被过程捕获或忽略。这允许进程执行良好的终止，从而释放资源并在适当时保存状态。 SIGINT 与SIGTERM 几乎相同。&lt;/p&gt;
&lt;p&gt;SIGTSTP 信号由其控制终端发送到进程，以请求终端停止。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;SIGTTIN 和 SIGTTOU&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当 SIGTTIN 和SIGTTOU 信号分别在后台尝试从 tty 读取或写入时，信号将发送到该进程。&lt;/p&gt;
&lt;p&gt;在发生异常或者 trap 时，将 SIGTRAP 信号发送到进程&lt;/p&gt;
&lt;p&gt;当套接字具有可读取的紧急或带外数据时，将 SIGURG 信号发送到进程。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;SIGUSR1 和 SIGUSR2&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;SIGUSR1 和 SIGUSR2 信号被发送到进程以指示用户定义的条件。&lt;/p&gt;
&lt;p&gt;当 SIGXCPU 信号耗尽 CPU 的时间超过某个用户可设置的预定值时，将其发送到进程&lt;/p&gt;
&lt;p&gt;当 SIGXFSZ 信号增长超过最大允许大小的文件时，该信号将发送到该进程。&lt;/p&gt;
&lt;p&gt;SIGWINCH 信号在其控制终端更改其大小（窗口更改）时发送给进程。&lt;/p&gt;
&lt;h4 id=&quot;管道-pipe&quot;&gt;管道 pipe&lt;/h4&gt;
&lt;p&gt;Linux 系统中的进程可以通过建立管道 pipe 进行通信。&lt;/p&gt;
&lt;p&gt;在两个进程之间，可以建立一个通道，一个进程向这个通道里写入字节流，另一个进程从这个管道中读取字节流。管道是同步的，当进程尝试从空管道读取数据时，该进程会被阻塞，直到有可用数据为止。shell 中的&lt;code&gt;管线 pipelines&lt;/code&gt; 就是用管道实现的，当 shell 发现输出&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;sort &amp;lt;f | head
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它会创建两个进程，一个是 sort，一个是 head，sort，会在这两个应用程序之间建立一个管道使得 sort 进程的标准输出作为 head 程序的标准输入。sort 进程产生的输出就不用写到文件中了，如果管道满了系统会停止 sort 以等待 head 读出数据&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202010/1515111-20201010070443986-1595305731.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;管道实际上就是 &lt;code&gt;|&lt;/code&gt;，两个应用程序不知道有管道的存在，一切都是由 shell 管理和控制的。&lt;/p&gt;
&lt;h4 id=&quot;共享内存-shared-memory&quot;&gt;共享内存 shared memory&lt;/h4&gt;
&lt;p&gt;两个进程之间还可以通过共享内存进行进程间通信，其中两个或者多个进程可以访问公共内存空间。两个进程的共享工作是通过共享内存完成的，一个进程所作的修改可以对另一个进程可见(很像线程间的通信)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202010/1515111-20201010070456002-284727000.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在使用共享内存前，需要经过一系列的调用流程，流程如下&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;创建共享内存段或者使用已创建的共享内存段&lt;code&gt;(shmget())&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;将进程附加到已经创建的内存段中&lt;code&gt;(shmat())&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;从已连接的共享内存段分离进程&lt;code&gt;(shmdt())&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;对共享内存段执行控制操作&lt;code&gt;(shmctl())&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;先入先出队列-fifo&quot;&gt;先入先出队列 FIFO&lt;/h4&gt;
&lt;p&gt;先入先出队列 FIFO 通常被称为 &lt;code&gt;命名管道(Named Pipes)&lt;/code&gt;，命名管道的工作方式与常规管道非常相似，但是确实有一些明显的区别。未命名的管道没有备份文件：操作系统负责维护内存中的缓冲区，用来将字节从写入器传输到读取器。一旦写入或者输出终止的话，缓冲区将被回收，传输的数据会丢失。相比之下，命名管道具有支持文件和独特 API ，命名管道在文件系统中作为设备的专用文件存在。当所有的进程通信完成后，命名管道将保留在文件系统中以备后用。命名管道具有严格的 FIFO 行为&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202010/1515111-20201010070504154-1010179496.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;写入的第一个字节是读取的第一个字节，写入的第二个字节是读取的第二个字节，依此类推。&lt;/p&gt;
&lt;h4 id=&quot;消息队列-message-queue&quot;&gt;消息队列 Message Queue&lt;/h4&gt;
&lt;p&gt;一听到消息队列这个名词你可能不知道是什么意思，消息队列是用来描述内核寻址空间内的内部链接列表。可以按几种不同的方式将消息按顺序发送到队列并从队列中检索消息。每个消息队列由 IPC 标识符唯一标识。消息队列有两种模式，一种是&lt;code&gt;严格模式&lt;/code&gt;， 严格模式就像是 FIFO 先入先出队列似的，消息顺序发送，顺序读取。还有一种模式是 &lt;code&gt;非严格模式&lt;/code&gt;，消息的顺序性不是非常重要。&lt;/p&gt;
&lt;h4 id=&quot;套接字-socket&quot;&gt;套接字 Socket&lt;/h4&gt;
&lt;p&gt;还有一种管理两个进程间通信的是使用 &lt;code&gt;socket&lt;/code&gt;，socket 提供端到端的双相通信。一个套接字可以与一个或多个进程关联。就像管道有命令管道和未命名管道一样，套接字也有两种模式，套接字一般用于两个进程之间的网络通信，网络套接字需要来自诸如&lt;code&gt;TCP（传输控制协议）&lt;/code&gt;或较低级别&lt;code&gt;UDP（用户数据报协议）&lt;/code&gt;等基础协议的支持。&lt;/p&gt;
&lt;p&gt;套接字有以下几种分类&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;顺序包套接字(Sequential Packet Socket)&lt;/code&gt;： 此类套接字为最大长度固定的数据报提供可靠的连接。此连接是双向的并且是顺序的。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;数据报套接字(Datagram Socket)&lt;/code&gt;：数据包套接字支持双向数据流。数据包套接字接受消息的顺序与发送者可能不同。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;流式套接字(Stream Socket)&lt;/code&gt;：流套接字的工作方式类似于电话对话，提供双向可靠的数据流。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;原始套接字(Raw Socket)&lt;/code&gt;： 可以使用原始套接字访问基础通信协议。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;linux-中进程管理系统调用&quot;&gt;Linux 中进程管理系统调用&lt;/h3&gt;
&lt;p&gt;现在关注一下 Linux 系统中与进程管理相关的系统调用。在了解之前你需要先知道一下什么是系统调用。&lt;/p&gt;
&lt;p&gt;操作系统为我们屏蔽了硬件和软件的差异，它的最主要功能就是为用户提供一种抽象，隐藏内部实现，让用户只关心在 GUI 图形界面下如何使用即可。操作系统可以分为两种模式&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;内核态：操作系统内核使用的模式&lt;/li&gt;
&lt;li&gt;用户态：用户应用程序所使用的模式&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们常说的&lt;code&gt;上下文切换&lt;/code&gt; 指的就是内核态模式和用户态模式的频繁切换。而&lt;code&gt;系统调用&lt;/code&gt;指的就是引起内核态和用户态切换的一种方式，系统调用通常在后台静默运行，表示计算机程序向其操作系统内核请求服务。&lt;/p&gt;
&lt;p&gt;系统调用指令有很多，下面是一些与进程管理相关的最主要的系统调用&lt;/p&gt;
&lt;h4 id=&quot;fork&quot;&gt;fork&lt;/h4&gt;
&lt;p&gt;fork 调用用于创建一个与父进程相同的子进程，创建完进程后的子进程拥有和父进程一样的程序计数器、相同的 CPU 寄存器、相同的打开文件。&lt;/p&gt;
&lt;h4 id=&quot;exec&quot;&gt;exec&lt;/h4&gt;
&lt;p&gt;exec 系统调用用于执行驻留在活动进程中的文件，调用 exec 后，新的可执行文件会替换先前的可执行文件并获得执行。也就是说，调用 exec 后，会将旧文件或程序替换为新文件或执行，然后执行文件或程序。新的执行程序被加载到相同的执行空间中，因此进程的 &lt;code&gt;PID&lt;/code&gt; 不会修改，因为我们&lt;strong&gt;没有创建新进程，只是替换旧进程&lt;/strong&gt;。但是进程的数据、代码、堆栈都已经被修改。如果当前要被替换的进程包含多个线程，那么所有的线程将被终止，新的进程映像被加载执行。&lt;/p&gt;
&lt;p&gt;这里需要解释一下&lt;code&gt;进程映像(Process image)&lt;/code&gt; 的概念&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;什么是进程映像呢&lt;/strong&gt;？进程映像是执行程序时所需要的可执行文件，通常会包括下面这些东西&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;代码段（codesegment/textsegment）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;又称文本段，用来存放指令，运行代码的一块内存空间&lt;/p&gt;
&lt;p&gt;此空间大小在代码运行前就已经确定&lt;/p&gt;
&lt;p&gt;内存空间一般属于只读，某些架构的代码也允许可写&lt;/p&gt;
&lt;p&gt;在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;数据段（datasegment）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;可读可写&lt;/p&gt;
&lt;p&gt;存储初始化的全局变量和初始化的 static 变量&lt;/p&gt;
&lt;p&gt;数据段中数据的生存期是随程序持续性（随进程持续性）&lt;br/&gt;随进程持续性：进程创建就存在，进程死亡就消失&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;bss 段（bsssegment）：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;可读可写&lt;/p&gt;
&lt;p&gt;存储未初始化的全局变量和未初始化的 static 变量&lt;/p&gt;
&lt;p&gt;bss 段中的数据一般默认为 0&lt;/p&gt;
&lt;p&gt;是可读写的，因为变量的值可以在运行时更改。此段的大小也固定。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;栈（stack）：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;可读可写&lt;/p&gt;
&lt;p&gt;存储的是函数或代码中的局部变量(非 static 变量)&lt;/p&gt;
&lt;p&gt;栈的生存期随代码块持续性，代码块运行就给你分配空间，代码块结束，就自动回收空间&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;堆（heap）：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;可读可写&lt;/p&gt;
&lt;p&gt;存储的是程序运行期间动态分配的 malloc/realloc 的空间&lt;/p&gt;
&lt;p&gt;堆的生存期随进程持续性，从 malloc/realloc 到 free 一直存在&lt;/p&gt;
&lt;p&gt;下面是这些区域的构成图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202010/1515111-20201010070518672-139695051.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;exec 系统调用是一些函数的集合，这些函数是&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;execl&lt;/li&gt;
&lt;li&gt;execle&lt;/li&gt;
&lt;li&gt;execlp&lt;/li&gt;
&lt;li&gt;execv&lt;/li&gt;
&lt;li&gt;execve&lt;/li&gt;
&lt;li&gt;execvp&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面来看一下 exec 的工作原理&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;当前进程映像被替换为新的进程映像&lt;/li&gt;
&lt;li&gt;新的进程映像是你做为 exec 传递的灿睡&lt;/li&gt;
&lt;li&gt;结束当前正在运行的进程&lt;/li&gt;
&lt;li&gt;新的进程映像有 PID，相同的环境和一些文件描述符(因为未替换进程，只是替换了进程映像)&lt;/li&gt;
&lt;li&gt;CPU 状态和虚拟内存受到影响，当前进程映像的虚拟内存映射被新进程映像的虚拟内存代替。&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;waitpid&quot;&gt;waitpid&lt;/h4&gt;
&lt;p&gt;等待子进程结束或终止&lt;/p&gt;
&lt;h4 id=&quot;exit&quot;&gt;exit&lt;/h4&gt;
&lt;p&gt;在许多计算机操作系统上，计算机进程的终止是通过执行 &lt;code&gt;exit&lt;/code&gt; 系统调用命令执行的。0 表示进程能够正常结束，其他值表示进程以非正常的行为结束。&lt;/p&gt;
&lt;p&gt;其他一些常见的系统调用如下&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;系统调用指令&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr&gt;&lt;td&gt;pause&lt;/td&gt;
&lt;td&gt;挂起信号&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;nice&lt;/td&gt;
&lt;td&gt;改变分时进程的优先级&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;ptrace&lt;/td&gt;
&lt;td&gt;进程跟踪&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;kill&lt;/td&gt;
&lt;td&gt;向进程发送信号&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;pipe&lt;/td&gt;
&lt;td&gt;创建管道&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;mkfifo&lt;/td&gt;
&lt;td&gt;创建 fifo 的特殊文件（命名管道）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;sigaction&lt;/td&gt;
&lt;td&gt;设置对指定信号的处理方法&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;msgctl&lt;/td&gt;
&lt;td&gt;消息控制操作&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;semctl&lt;/td&gt;
&lt;td&gt;信号量控制&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;linux-进程和线程的实现&quot;&gt;Linux 进程和线程的实现&lt;/h3&gt;
&lt;h4 id=&quot;linux-进程&quot;&gt;Linux 进程&lt;/h4&gt;
&lt;p&gt;在 Linux 内核结构中，进程会被表示为 &lt;code&gt;任务&lt;/code&gt;，通过结构体 &lt;code&gt;structure&lt;/code&gt; 来创建。不像其他的操作系统会区分进程、轻量级进程和线程，Linux 统一使用任务结构来代表执行上下文。因此，对于每个单线程进程来说，单线程进程将用一个任务结构表示，对于多线程进程来说，将为每一个用户级线程分配一个任务结构。Linux 内核是多线程的，并且内核级线程不与任何用户级线程相关联。&lt;/p&gt;
&lt;p&gt;对于每个进程来说，在内存中都会有一个 &lt;code&gt;task_struct&lt;/code&gt; 进程描述符与之对应。进程描述符包含了内核管理进程所有有用的信息，包括 &lt;strong&gt;调度参数、打开文件描述符等等&lt;/strong&gt;。进程描述符从进程创建开始就一直存在于内核堆栈中。&lt;/p&gt;
&lt;p&gt;Linux 和 Unix 一样，都是通过 &lt;code&gt;PID&lt;/code&gt; 来区分不同的进程，内核会将所有进程的任务结构组成为一个双向链表。PID 能够直接被映射称为进程的任务结构所在的地址，从而不需要遍历双向链表直接访问。&lt;/p&gt;
&lt;p&gt;我们上面提到了进程描述符，这是一个非常重要的概念，我们上面还提到了进程描述符是位于内存中的，这里我们省略了一句话，那就是进程描述符是存在用户的任务结构中，当进程位于内存并开始运行时，进程描述符才会被调入内存。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;code&gt;进程位于内存&lt;/code&gt;被称为 &lt;code&gt;PIM(Process In Memory)&lt;/code&gt; ，这是冯诺伊曼体系架构的一种体现，加载到内存中并执行的程序称为进程。简单来说，一个进程就是正在执行的程序。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;进程描述符可以归为下面这几类&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;调度参数(scheduling parameters)&lt;/code&gt;：进程优先级、最近消耗 CPU 的时间、最近睡眠时间一起决定了下一个需要运行的进程&lt;/li&gt;
&lt;li&gt;&lt;code&gt;内存映像(memory image)&lt;/code&gt;：我们上面说到，进程映像是执行程序时所需要的可执行文件，它由数据和代码组成。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;信号(signals)&lt;/code&gt;：显示哪些信号被捕获、哪些信号被执行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;寄存器&lt;/code&gt;：当发生内核陷入 (trap) 时，寄存器的内容会被保存下来。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;系统调用状态(system call state)&lt;/code&gt;：当前系统调用的信息，包括参数和结果&lt;/li&gt;
&lt;li&gt;&lt;code&gt;文件描述符表(file descriptor table)&lt;/code&gt;：有关文件描述符的系统被调用时，文件描述符作为索引在文件描述符表中定位相关文件的 i-node 数据结构&lt;/li&gt;
&lt;li&gt;&lt;code&gt;统计数据(accounting)&lt;/code&gt;：记录用户、进程占用系统 CPU 时间表的指针，一些操作系统还保存进程最多占用的 CPU 时间、进程拥有的最大堆栈空间、进程可以消耗的页面数等。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;内核堆栈(kernel stack)&lt;/code&gt;：进程的内核部分可以使用的固定堆栈&lt;/li&gt;
&lt;li&gt;&lt;code&gt;其他&lt;/code&gt;： 当前进程状态、事件等待时间、距离警报的超时时间、PID、父进程的 PID 以及用户标识符等&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;有了上面这些信息，现在就很容易描述在 Linux 中是如何创建这些进程的了，创建新流程实际上非常简单。&lt;strong&gt;为子进程开辟一块新的用户空间的进程描述符，然后从父进程复制大量的内容。为这个子进程分配一个 PID，设置其内存映射，赋予它访问父进程文件的权限，注册并启动&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;当执行 fork 系统调用时，调用进程会陷入内核并创建一些和任务相关的数据结构，比如&lt;code&gt;内核堆栈(kernel stack)&lt;/code&gt; 和 &lt;code&gt;thread_info&lt;/code&gt; 结构。&lt;/p&gt;
&lt;blockquote readability=&quot;2.1560283687943&quot;&gt;
&lt;p&gt;关于 thread_info 结构可以参考&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.huihoo.com/doxygen/linux/kernel/3.7/arch_2avr32_2include_2asm_2thread__info_8h_source.html&quot;&gt;https://docs.huihoo.com/doxygen/linux/kernel/3.7/arch_2avr32_2include_2asm_2thread__info_8h_source.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个结构中包含进程描述符，进程描述符位于固定的位置，使得 Linux 系统只需要很小的开销就可以定位到一个运行中进程的数据结构。&lt;/p&gt;
&lt;p&gt;进程描述符的主要内容是根据&lt;code&gt;父进程&lt;/code&gt;的描述符来填充。Linux 操作系统会寻找一个可用的 PID，并且此 PID 没有被任何进程使用，更新进程标示符使其指向一个新的数据结构即可。为了减少 hash table 的碰撞，进程描述符会形成&lt;code&gt;链表&lt;/code&gt;。它还将 task_struct 的字段设置为指向任务数组上相应的上一个/下一个进程。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;task_struct ： Linux 进程描述符，内部涉及到众多 C++ 源码，我们会在后面进行讲解。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从原则上来说，为子进程开辟内存区域并为子进程分配数据段、堆栈段，并且对父进程的内容进行复制，但是实际上 fork 完成后，子进程和父进程没有共享内存，所以需要复制技术来实现同步，但是复制开销比较大，因此 Linux 操作系统使用了一种 &lt;code&gt;欺骗&lt;/code&gt; 方式。即为子进程分配页表，然后新分配的页表指向父进程的页面，同时这些页面是只读的。当进程向这些页面进行写入的时候，会开启保护错误。内核发现写入操作后，会为进程分配一个副本，使得写入时把数据复制到这个副本上，这个副本是共享的，这种方式称为 &lt;code&gt;写入时复制(copy on write)&lt;/code&gt;，这种方式避免了在同一块内存区域维护两个副本的必要，节省内存空间。&lt;/p&gt;
&lt;p&gt;在子进程开始运行后，操作系统会调用 exec 系统调用，内核会进行查找验证可执行文件，把参数和环境变量复制到内核，释放旧的地址空间。&lt;/p&gt;
&lt;p&gt;现在新的地址空间需要被创建和填充。如果系统支持映射文件，就像 Unix 系统一样，那么新的页表就会创建，表明内存中没有任何页，除非所使用的页面是堆栈页，其地址空间由磁盘上的可执行文件支持。新进程开始运行时，立刻会收到一个&lt;code&gt;缺页异常(page fault)&lt;/code&gt;，这会使具有代码的页面加载进入内存。最后，参数和环境变量被复制到新的堆栈中，重置信号，寄存器全部清零。新的命令开始运行。&lt;/p&gt;
&lt;p&gt;下面是一个示例，用户输出 ls，shell 会调用 fork 函数复制一个新进程，shell 进程会调用 exec 函数用可执行文件 ls 的内容覆盖它的内存。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202010/1515111-20201010070537261-1218173422.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;linux-线程&quot;&gt;Linux 线程&lt;/h4&gt;
&lt;p&gt;现在我们来讨论一下 Linux 中的线程，线程是轻量级的进程，想必这句话你已经听过很多次了，&lt;code&gt;轻量级&lt;/code&gt;体现在所有的进程切换都需要清除所有的表、进程间的共享信息也比较麻烦，一般来说通过管道或者共享内存，如果是 fork 函数后的父子进程则使用共享文件，然而线程切换不需要像进程一样具有昂贵的开销，而且线程通信起来也更方便。线程分为两种：用户级线程和内核级线程&lt;/p&gt;
&lt;h4 id=&quot;用户级线程&quot;&gt;用户级线程&lt;/h4&gt;
&lt;p&gt;用户级线程避免使用内核，通常，每个线程会显示调用开关，发送信号或者执行某种切换操作来放弃 CPU，同样，计时器可以强制进行开关，用户线程的切换速度通常比内核线程快很多。在用户级别实现线程会有一个问题，即单个线程可能会垄断 CPU 时间片，导致其他线程无法执行从而 &lt;code&gt;饿死&lt;/code&gt;。如果执行一个 I/O 操作，那么 I/O 会阻塞，其他线程也无法运行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202010/1515111-20201010070547298-209131475.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一种解决方案是，一些用户级的线程包解决了这个问题。可以使用时钟周期的监视器来控制第一时间时间片独占。然后，一些库通过特殊的包装来解决系统调用的 I/O 阻塞问题，或者可以为非阻塞 I/O 编写任务。&lt;/p&gt;
&lt;h4 id=&quot;内核级线程&quot;&gt;内核级线程&lt;/h4&gt;
&lt;p&gt;内核级线程通常使用几个进程表在内核中实现，每个任务都会对应一个进程表。在这种情况下，内核会在每个进程的时间片内调度每个线程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202010/1515111-20201010070555156-403296964.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所有能够阻塞的调用都会通过系统调用的方式来实现，当一个线程阻塞时，内核可以进行选择，是运行在同一个进程中的另一个线程（如果有就绪线程的话）还是运行一个另一个进程中的线程。&lt;/p&gt;
&lt;p&gt;从用户空间 -&amp;gt; 内核空间 -&amp;gt; 用户空间的开销比较大，但是线程初始化的时间损耗可以忽略不计。这种实现的好处是由时钟决定线程切换时间，因此不太可能将时间片与任务中的其他线程占用时间绑定到一起。同样，I/O 阻塞也不是问题。&lt;/p&gt;
&lt;h4 id=&quot;混合实现&quot;&gt;混合实现&lt;/h4&gt;
&lt;p&gt;结合用户空间和内核空间的优点，设计人员采用了一种&lt;code&gt;内核级线程&lt;/code&gt;的方式，然后将用户级线程与某些或者全部内核线程多路复用起来&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202010/1515111-20201010070604256-1866299407.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这种模型中，编程人员可以自由控制用户线程和内核线程的数量，具有很大的灵活度。采用这种方法，内核只识别内核级线程，并对其进行调度。其中一些内核级线程会被多个用户级线程多路复用。&lt;/p&gt;
&lt;h3 id=&quot;linux-调度&quot;&gt;Linux 调度&lt;/h3&gt;
&lt;p&gt;下面我们来关注一下 Linux 系统的调度算法，首先需要认识到，Linux 系统的线程是内核线程，所以 Linux 系统是基于线程的，而不是基于进程的。&lt;/p&gt;
&lt;p&gt;为了进行调度，Linux 系统将线程分为三类&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;实时先入先出&lt;/li&gt;
&lt;li&gt;实时轮询&lt;/li&gt;
&lt;li&gt;分时&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;实时先入先出线程具有最高优先级，它不会被其他线程所抢占，除非那是一个刚刚准备好的，拥有更高优先级的线程进入。实时轮转线程与实时先入先出线程基本相同，只是每个实时轮转线程都有一个时间量，时间到了之后就可以被抢占。如果多个实时线程准备完毕，那么每个线程运行它时间量所规定的时间，然后插入到实时轮转线程末尾。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意这个实时只是相对的，无法做到绝对的实时，因为线程的运行时间无法确定。它们相对分时系统来说，更加具有实时性&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Linux 系统会给每个线程分配一个 &lt;code&gt;nice&lt;/code&gt; 值，这个值代表了优先级的概念。nice 值默认值是 0 ，但是可以通过系统调用 nice 值来修改。修改值的范围从 -20 - +19。nice 值决定了线程的静态优先级。一般系统管理员的 nice 值会比一般线程的优先级高，它的范围是 -20 - -1。&lt;/p&gt;
&lt;p&gt;下面我们更详细的讨论一下 Linux 系统的两个调度算法，它们的内部与&lt;code&gt;调度队列(runqueue)&lt;/code&gt; 的设计很相似。运行队列有一个数据结构用来监视系统中所有可运行的任务并选择下一个可以运行的任务。每个运行队列和系统中的每个 CPU 有关。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Linux O(1)&lt;/code&gt; 调度器是历史上很流行的一个调度器。这个名字的由来是因为它能够在常数时间内执行任务调度。在 O(1) 调度器里，调度队列被组织成两个数组，一个是任务&lt;strong&gt;正在活动&lt;/strong&gt;的数组，一个是任务&lt;strong&gt;过期失效&lt;/strong&gt;的数组。如下图所示，每个数组都包含了 140 个链表头，每个链表头具有不同的优先级。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202010/1515111-20201010070614114-2008031150.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;大致流程如下：&lt;/p&gt;
&lt;p&gt;调度器从正在活动数组中选择一个优先级最高的任务。如果这个任务的时间片过期失效了，就把它移动到过期失效数组中。如果这个任务阻塞了，比如说正在等待 I/O 事件，那么在它的时间片过期失效之前，一旦 I/O 操作完成，那么这个任务将会继续运行，它将被放回到之前正在活动的数组中，因为这个任务之前已经消耗一部分 CPU 时间片，所以它将运行剩下的时间片。当这个任务运行完它的时间片后，它就会被放到过期失效数组中。一旦正在活动的任务数组中没有其他任务后，调度器将会交换指针，使得正在活动的数组变为过期失效数组，过期失效数组变为正在活动的数组。使用这种方式可以保证每个优先级的任务都能够得到执行，不会导致线程饥饿。&lt;/p&gt;
&lt;p&gt;在这种调度方式中，不同优先级的任务所得到 CPU 分配的时间片也是不同的，高优先级进程往往能得到较长的时间片，低优先级的任务得到较少的时间片。&lt;/p&gt;
&lt;p&gt;这种方式为了保证能够更好的提供服务，通常会为 &lt;code&gt;交互式进程&lt;/code&gt; 赋予较高的优先级，交互式进程就是&lt;code&gt;用户进程&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;Linux 系统不知道一个任务究竟是 I/O 密集型的还是 CPU 密集型的，它只是依赖于交互式的方式，Linux 系统会区分是&lt;code&gt;静态优先级&lt;/code&gt; 还是 &lt;code&gt;动态优先级&lt;/code&gt;。动态优先级是采用一种奖励机制来实现的。奖励机制有两种方式：&lt;strong&gt;奖励交互式线程、惩罚占用 CPU 的线程&lt;/strong&gt;。在 Linux O(1) 调度器中，最高的优先级奖励是 -5，注意这个优先级越低越容易被线程调度器接受，所以最高惩罚的优先级是 +5。具体体现就是操作系统维护一个名为 &lt;code&gt;sleep_avg&lt;/code&gt; 的变量，任务唤醒会增加 sleep_avg 变量的值，当任务被抢占或者时间量过期会减少这个变量的值，反映在奖励机制上。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;O(1) 调度算法是 2.6 内核版本的调度器，最初引入这个调度算法的是不稳定的 2.5 版本。早期的调度算法在多处理器环境中说明了通过访问正在活动数组就可以做出调度的决定。使调度可以在固定的时间 O(1) 完成。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;O(1) 调度器使用了一种 &lt;code&gt;启发式&lt;/code&gt; 的方式，这是什么意思？&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;在计算机科学中，启发式是一种当传统方式解决问题很慢时用来快速解决问题的方式，或者找到一个在传统方法无法找到任何精确解的情况下找到近似解。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;O(1) 使用启发式的这种方式，会使任务的优先级变得复杂并且不完善，从而导致在处理交互任务时性能很糟糕。&lt;/p&gt;
&lt;p&gt;为了改进这个缺点，O(1) 调度器的开发者又提出了一个新的方案，即 &lt;code&gt;公平调度器(Completely Fair Scheduler, CFS)&lt;/code&gt;。 CFS 的主要思想是使用一颗&lt;code&gt;红黑树&lt;/code&gt;作为调度队列。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;数据结构太重要了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;CFS 会根据任务在 CPU 上的运行时间长短而将其有序地排列在树中，时间精确到纳秒级。下面是 CFS 的构造模型&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202010/1515111-20201010070624179-1052046389.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;CFS 的调度过程如下：&lt;/p&gt;
&lt;p&gt;CFS 算法总是优先调度哪些使用 CPU 时间最少的任务。最小的任务一般都是在最左边的位置。当有一个新的任务需要运行时，CFS 会把这个任务和最左边的数值进行对比，如果此任务具有最小时间值，那么它将进行运行，否则它会进行比较，找到合适的位置进行插入。然后 CPU 运行红黑树上当前比较的最左边的任务。&lt;/p&gt;
&lt;p&gt;在红黑树中选择一个节点来运行的时间可以是常数时间，但是插入一个任务的时间是 &lt;code&gt;O(loog(N))&lt;/code&gt;，其中 N 是系统中的任务数。考虑到当前系统的负载水平，这是可以接受的。&lt;/p&gt;
&lt;p&gt;调度器只需要考虑可运行的任务即可。这些任务被放在适当的调度队列中。不可运行的任务和正在等待的各种 I/O 操作或内核事件的任务被放入一个&lt;code&gt;等待队列&lt;/code&gt;中。等待队列头包含一个指向任务链表的指针和一个自旋锁。自旋锁对于并发处理场景下用处很大。&lt;/p&gt;
&lt;h4 id=&quot;linux-系统中的同步&quot;&gt;Linux 系统中的同步&lt;/h4&gt;
&lt;p&gt;下面来聊一下 Linux 中的同步机制。早期的 Linux 内核只有一个 &lt;code&gt;大内核锁(Big Kernel Lock,BKL)&lt;/code&gt; 。它阻止了不同处理器并发处理的能力。因此，需要引入一些粒度更细的锁机制。&lt;/p&gt;
&lt;p&gt;Linux 提供了若干不同类型的同步变量，这些变量既能够在内核中使用，也能够在用户应用程序中使用。在地层中，Linux 通过使用 &lt;code&gt;atomic_set&lt;/code&gt; 和 &lt;code&gt;atomic_read&lt;/code&gt; 这样的操作为硬件支持的原子指令提供封装。硬件提供内存重排序，这是 Linux 屏障的机制。&lt;/p&gt;
&lt;p&gt;具有高级别的同步像是自旋锁的描述是这样的，当两个进程同时对资源进行访问，在一个进程获得资源后，另一个进程不想被阻塞，所以它就会自旋，等待一会儿再对资源进行访问。Linux 也提供互斥量或信号量这样的机制，也支持像是 &lt;code&gt;mutex_tryLock&lt;/code&gt; 和 &lt;code&gt;mutex_tryWait&lt;/code&gt; 这样的非阻塞调用。也支持中断处理事务，也可以通过动态禁用和启用相应的中断来实现。&lt;/p&gt;
&lt;h3 id=&quot;linux-启动&quot;&gt;Linux 启动&lt;/h3&gt;
&lt;p&gt;下面来聊一聊 Linux 是如何启动的。&lt;/p&gt;
&lt;p&gt;当计算机电源通电后，&lt;code&gt;BIOS&lt;/code&gt;会进行&lt;code&gt;开机自检(Power-On-Self-Test, POST)&lt;/code&gt;，对硬件进行检测和初始化。因为操作系统的启动会使用到磁盘、屏幕、键盘、鼠标等设备。下一步，磁盘中的第一个分区，也被称为 &lt;code&gt;MBR(Master Boot Record)&lt;/code&gt; 主引导记录，被读入到一个固定的内存区域并执行。这个分区中有一个非常小的，只有 512 字节的程序。程序从磁盘中调入 boot 独立程序，boot 程序将自身复制到高位地址的内存从而为操作系统释放低位地址的内存。&lt;/p&gt;
&lt;p&gt;复制完成后，boot 程序读取启动设备的根目录。boot 程序要理解文件系统和目录格式。然后 boot 程序被调入内核，把控制权移交给内核。直到这里，boot 完成了它的工作。系统内核开始运行。&lt;/p&gt;
&lt;p&gt;内核启动代码是使用&lt;code&gt;汇编语言&lt;/code&gt;完成的，主要包括创建内核堆栈、识别 CPU 类型、计算内存、禁用中断、启动内存管理单元等，然后调用 C 语言的 main 函数执行操作系统部分。&lt;/p&gt;
&lt;p&gt;这部分也会做很多事情，首先会分配一个消息缓冲区来存放调试出现的问题，调试信息会写入缓冲区。如果调试出现错误，这些信息可以通过诊断程序调出来。&lt;/p&gt;
&lt;p&gt;然后操作系统会进行自动配置，检测设备，加载配置文件，被检测设备如果做出响应，就会被添加到已链接的设备表中，如果没有相应，就归为未连接直接忽略。&lt;/p&gt;
&lt;p&gt;配置完所有硬件后，接下来要做的就是仔细手工处理进程0，设置其堆栈，然后运行它，执行初始化、配置时钟、挂载文件系统。创建 &lt;code&gt;init 进程(进程 1 )&lt;/code&gt; 和 &lt;code&gt;守护进程(进程 2)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;init 进程会检测它的标志以确定它是否为单用户还是多用户服务。在前一种情况中，它会调用 fork 函数创建一个 shell 进程，并且等待这个进程结束。后一种情况调用 fork 函数创建一个运行系统初始化的 shell 脚本（即 /etc/rc）的进程，这个进程可以进行文件系统一致性检测、挂载文件系统、开启守护进程等。&lt;/p&gt;
&lt;p&gt;然后 /etc/rc 这个进程会从 /etc/ttys 中读取数据，/etc/ttys 列出了所有的终端和属性。对于每一个启用的终端，这个进程调用 fork 函数创建一个自身的副本，进行内部处理并运行一个名为 &lt;code&gt;getty&lt;/code&gt; 的程序。&lt;/p&gt;
&lt;p&gt;getty 程序会在终端上输入&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;login:
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;等待用户输入用户名，在输入用户名后，getty 程序结束，登陆程序 &lt;code&gt;/bin/login&lt;/code&gt; 开始运行。login 程序需要输入密码，并与保存在 &lt;code&gt;/etc/passwd&lt;/code&gt; 中的密码进行对比，如果输入正确，login 程序以用户 shell 程序替换自身，等待第一个命令。如果不正确，login 程序要求输入另一个用户名。&lt;/p&gt;
&lt;p&gt;整个系统启动过程如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202010/1515111-20201010070637056-1661326082.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;linux-内存管理&quot;&gt;Linux 内存管理&lt;/h2&gt;
&lt;p&gt;Linux 内存管理模型非常直接明了，因为 Linux 的这种机制使其具有可移植性并且能够在内存管理单元相差不大的机器下实现 Linux，下面我们就来认识一下 Linux 内存管理是如何实现的。&lt;/p&gt;
&lt;h3 id=&quot;基本概念-2&quot;&gt;基本概念&lt;/h3&gt;
&lt;p&gt;每个 Linux 进程都会有地址空间，这些地址空间由三个段区域组成：&lt;strong&gt;text 段、data 段、stack 段&lt;/strong&gt;。下面是进程地址空间的示例。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202010/1515111-20201010070645204-504951634.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;数据段(data segment)&lt;/code&gt; 包含了程序的变量、字符串、数组和其他数据的存储。数据段分为两部分，已经初始化的数据和尚未初始化的数据。其中&lt;code&gt;尚未初始化的数据&lt;/code&gt;就是我们说的 BSS。数据段部分的初始化需要编译就期确定的常量以及程序启动就需要一个初始值的变量。所有 BSS 部分中的变量在加载后被初始化为 0 。&lt;/p&gt;
&lt;p&gt;和 &lt;code&gt;代码段(Text segment)&lt;/code&gt; 不一样，data segment 数据段可以改变。程序总是修改它的变量。而且，许多程序需要在执行时动态分配空间。Linux 允许数据段随着内存的分配和回收从而增大或者减小。为了分配内存，程序可以增加数据段的大小。在 C 语言中有一套标准库 &lt;code&gt;malloc&lt;/code&gt; 经常用于分配内存。进程地址空间描述符包含动态分配的内存区域称为 &lt;code&gt;堆(heap)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;第三部分段是 &lt;code&gt;栈段(stack segment)&lt;/code&gt;。在大部分机器上，栈段会在虚拟内存地址顶部地址位置处，并向低位置处（向地址空间为 0 处）拓展。举个例子来说，在 32 位 x86 架构的机器上，栈开始于 &lt;code&gt;0xC0000000&lt;/code&gt;，这是用户模式下进程允许可见的 3GB 虚拟地址限制。如果栈一直增大到超过栈段后，就会发生硬件故障并把页面下降一个页面。&lt;/p&gt;
&lt;p&gt;当程序启动时，栈区域并不是空的，相反，它会包含所有的 shell 环境变量以及为了调用它而向 shell 输入的命令行。举个例子，当你输入&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;cp cxuan lx
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;时，cp 程序会运行并在栈中带着字符串 &lt;code&gt;cp cxuan lx&lt;/code&gt; ，这样就能够找出源文件和目标文件的名称。&lt;/p&gt;
&lt;p&gt;当两个用户运行在相同程序中，例如&lt;code&gt;编辑器(editor)&lt;/code&gt;，那么就会在内存中保持编辑器程序代码的两个副本，但是这种方式并不高效。Linux 系统支持&lt;code&gt;共享文本段作&lt;/code&gt;为替代。下面图中我们会看到 A 和 B 两个进程，它们有着相同的文本区域。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202010/1515111-20201010070654221-1687164897.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;数据段和栈段只有在 fork 之后才会共享，共享也是共享未修改过的页面。如果任何一个都需要变大但是没有相邻空间容纳的话，也不会有问题，因为相邻的虚拟页面不必映射到相邻的物理页面上。&lt;/p&gt;
&lt;p&gt;除了动态分配更多的内存，Linux 中的进程可以通过&lt;code&gt;内存映射文件&lt;/code&gt;来访问文件数据。这个特性可以使我们把一个文件映射到进程空间的一部分而该文件就可以像位于内存中的字节数组一样被读写。把一个文件映射进来使得随机读写比使用 read 和 write 之类的 I/O 系统调用要容易得多。共享库的访问就是使用了这种机制。如下所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202010/1515111-20201010070704619-494868919.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以看到两个相同文件会被映射到相同的物理地址上，但是它们属于不同的地址空间。&lt;/p&gt;
&lt;p&gt;映射文件的优点是，两个或多个进程可以同时映射到同一文件中，任意一个进程对文件的写操作对其他文件可见。通过使用映射临时文件的方式，可以为多线程共享内存&lt;code&gt;提供高带宽&lt;/code&gt;，临时文件在进程退出后消失。但是实际上，并没有两个相同的地址空间，因为每个进程维护的打开文件和信号不同。&lt;/p&gt;
&lt;h3 id=&quot;linux-内存管理系统调用&quot;&gt;Linux 内存管理系统调用&lt;/h3&gt;
&lt;p&gt;下面我们探讨一下关于内存管理的系统调用方式。事实上，POSIX 并没有给内存管理指定任何的系统调用。然而，Linux 却有自己的内存系统调用，主要系统调用如下&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;系统调用&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3.5&quot;&gt;&lt;tr&gt;&lt;td&gt;s = brk(addr)&lt;/td&gt;
&lt;td&gt;改变数据段大小&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td&gt;a = mmap(addr,len,prot,flags,fd,offset)&lt;/td&gt;
&lt;td&gt;进行映射&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;s = unmap(addr,len)&lt;/td&gt;
&lt;td&gt;取消映射&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;如果遇到错误，那么 s 的返回值是 -1，a 和 addr 是内存地址，len 表示的是长度，prot 表示的是控制保护位，flags 是其他标志位，fd 是文件描述符，offset 是文件偏移量。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;brk&lt;/code&gt; 通过给出超过数据段之外的第一个字节地址来指定数据段的大小。如果新的值要比原来的大，那么数据区会变得越来越大，反之会越来越小。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mmap&lt;/code&gt; 和 &lt;code&gt;unmap&lt;/code&gt; 系统调用会控制映射文件。mmp 的第一个参数 addr 决定了文件映射的地址。它必须是页面大小的倍数。如果参数是 0，系统会分配地址并返回 a。第二个参数是长度，它告诉了需要映射多少字节。它也是页面大小的倍数。prot 决定了映射文件的保护位，保护位可以标记为 &lt;strong&gt;可读、可写、可执行或者这些的结合&lt;/strong&gt;。第四个参数 flags 能够控制文件是私有的还是可读的以及 addr 是必须的还是只是进行提示。第五个参数 fd 是要映射的文件描述符。只有打开的文件是可以被映射的，因此如果想要进行文件映射，必须打开文件；最后一个参数 offset 会指示文件从什么时候开始，并不一定每次都要从零开始。&lt;/p&gt;
&lt;h3 id=&quot;linux-内存管理实现&quot;&gt;Linux 内存管理实现&lt;/h3&gt;
&lt;p&gt;内存管理系统是操作系统最重要的部分之一。从计算机早期开始，我们实际使用的内存都要比系统中实际存在的内存多。&lt;code&gt;内存分配策略&lt;/code&gt;克服了这一限制，并且其中最有名的就是 &lt;code&gt;虚拟内存(virtual memory)&lt;/code&gt;。通过在多个竞争的进程之间共享虚拟内存，虚拟内存得以让系统有更多的内存。虚拟内存子系统主要包括下面这些概念。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;大地址空间&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;操作系统使系统使用起来好像比实际的物理内存要大很多，那是因为虚拟内存要比物理内存大很多倍。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;保护&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;系统中的每个进程都会有自己的虚拟地址空间。这些虚拟地址空间彼此完全分开，因此运行一个应用程序的进程不会影响另一个。并且，硬件虚拟内存机制允许内存保护关键内存区域。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;内存映射&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;内存映射用来向进程地址空间映射图像和数据文件。在内存映射中，文件的内容直接映射到进程的虚拟空间中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;公平的物理内存分配&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;内存管理子系统允许系统中的每个正在运行的进程公平分配系统的物理内存。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;共享虚拟内存&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;尽管虚拟内存让进程有自己的内存空间，但是有的时候你是需要共享内存的。例如几个进程同时在 shell 中运行，这会涉及到 IPC 的进程间通信问题，这个时候你需要的是共享内存来进行信息传递而不是通过拷贝每个进程的副本独立运行。&lt;/p&gt;
&lt;p&gt;下面我们就正式探讨一下什么是 &lt;code&gt;虚拟内存&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;虚拟内存的抽象模型&quot;&gt;虚拟内存的抽象模型&lt;/h4&gt;
&lt;p&gt;在考虑 Linux 用于支持虚拟内存的方法之前，考虑一个不会被太多细节困扰的抽象模型是很有用的。&lt;/p&gt;
&lt;p&gt;处理器在执行指令时，会从内存中读取指令并将其&lt;code&gt;解码(decode)&lt;/code&gt;，在指令解码时会获取某个位置的内容并将他存到内存中。然后处理器继续执行下一条指令。这样，处理器总是在访问存储器以获取指令和存储数据。&lt;/p&gt;
&lt;p&gt;在虚拟内存系统中，所有的地址空间都是虚拟的而不是物理的。但是实际存储和提取指令的是物理地址，所以需要让处理器根据操作系统维护的一张表将虚拟地址转换为物理地址。&lt;/p&gt;
&lt;p&gt;为了简单的完成转换，虚拟地址和物理地址会被分为固定大小的块，称为 &lt;code&gt;页(page)&lt;/code&gt;。这些页有相同大小，如果页面大小不一样的话，那么操作系统将很难管理。Alpha AXP系统上的 Linux 使用 8 KB 页面，而 Intel x86 系统上的 Linux 使用 4 KB 页面。每个页面都有一个唯一的编号，即&lt;code&gt;页面框架号（PFN）&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202010/1515111-20201010070716392-543120720.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面就是 Linux 内存映射模型了，在这个页模型中，虚拟地址由两部分组成：&lt;strong&gt;偏移量和虚拟页框号&lt;/strong&gt;。每次处理器遇到虚拟地址时都会提取偏移量和虚拟页框号。处理器必须将虚拟页框号转换为物理页号，然后以正确的偏移量的位置访问物理页。&lt;/p&gt;
&lt;p&gt;上图中展示了两个进程 A 和 B 的虚拟地址空间，每个进程都有自己的页表。这些页表将进程中的虚拟页映射到内存中的物理页中。页表中每一项均包含&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;有效标志(valid flag)&lt;/code&gt;： 表明此页表条目是否有效&lt;/li&gt;
&lt;li&gt;该条目描述的物理页框号&lt;/li&gt;
&lt;li&gt;访问控制信息，页面使用方式，是否可写以及是否可以执行代码&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;要将处理器的虚拟地址映射为内存的物理地址，首先需要计算虚拟地址的页框号和偏移量。页面大小为 2 的次幂，可以通过移位完成操作。&lt;/p&gt;
&lt;p&gt;如果当前进程尝试访问虚拟地址，但是访问不到的话，这种情况称为 &lt;code&gt;缺页异常&lt;/code&gt;，此时虚拟操作系统的错误地址和页面错误的原因将通知操作系统。&lt;/p&gt;
&lt;p&gt;通过以这种方式将虚拟地址映射到物理地址，虚拟内存可以以任何顺序映射到系统的物理页面。&lt;/p&gt;
&lt;h4 id=&quot;按需分页&quot;&gt;按需分页&lt;/h4&gt;
&lt;p&gt;由于物理内存要比虚拟内存少很多，因此操作系统需要注意尽量避免直接使用&lt;code&gt;低效&lt;/code&gt;的物理内存。节省物理内存的一种方式是仅加载执行程序当前使用的页面（这何尝不是一种懒加载的思想呢？）。例如，可以运行数据库来查询数据库，在这种情况下，不是所有的数据都装入内存，只装载需要检查的数据。这种仅仅在需要时才将虚拟页面加载进内中的技术称为按需分页。&lt;/p&gt;
&lt;h4 id=&quot;交换&quot;&gt;交换&lt;/h4&gt;
&lt;p&gt;如果某个进程需要将虚拟页面传入内存，但是此时没有可用的物理页面，那么操作系统必须丢弃物理内存中的另一个页面来为该页面腾出空间。&lt;/p&gt;
&lt;p&gt;如果页面已经修改过，那么操作系统必须保留该页面的内容，以便以后可以访问它。这种类型的页面被称为脏页，当将其从内存中移除时，它会保存在称为&lt;code&gt;交换文件&lt;/code&gt;的特殊文件中。相对于处理器和物理内存的速度，对交换文件的访问非常慢，并且操作系统需要兼顾将页面写到磁盘的以及将它们保留在内存中以便再次使用。&lt;/p&gt;
&lt;p&gt;Linux 使用&lt;code&gt;最近最少使用(LRU)&lt;/code&gt;页面老化技术来公平的选择可能会从系统中删除的页面，这个方案涉及系统中的每个页面，页面的年龄随着访问次数的变化而变化，如果某个页面访问次数多，那么该页就表示越 &lt;code&gt;年轻&lt;/code&gt;，如果某个呃页面访问次数太少，那么该页越容易被&lt;code&gt;换出&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&quot;物理和虚拟寻址模式&quot;&gt;物理和虚拟寻址模式&lt;/h4&gt;
&lt;p&gt;大多数多功能处理器都支持 &lt;code&gt;物理地址&lt;/code&gt;模式和&lt;code&gt;虚拟地址&lt;/code&gt;模式的概念。物理寻址模式不需要页表，并且处理器不会在此模式下尝试执行任何地址转换。 Linux 内核被链接在物理地址空间中运行。&lt;/p&gt;
&lt;p&gt;Alpha AXP 处理器没有物理寻址模式。相反，它将内存空间划分为几个区域，并将其中两个指定为物理映射的地址。此内核地址空间称为 KSEG 地址空间，它包含从 0xfffffc0000000000 向上的所有地址。为了从 KSEG 中链接的代码（按照定义，内核代码）执行或访问其中的数据，该代码必须在内核模式下执行。链接到 Alpha 上的 Linux内核以从地址 0xfffffc0000310000 执行。&lt;/p&gt;
&lt;h4 id=&quot;访问控制&quot;&gt;访问控制&lt;/h4&gt;
&lt;p&gt;页面表的每一项还包含访问控制信息，访问控制信息主要检查进程是否应该访问内存。&lt;/p&gt;
&lt;p&gt;必要时需要对内存进行&lt;code&gt;访问限制&lt;/code&gt;。 例如包含可执行代码的内存，自然是只读内存； 操作系统不应允许进程通过其可执行代码写入数据。 相比之下，包含数据的页面可以被写入，但是尝试执行该内存的指令将失败。 大多数处理器至少具有两种执行模式：内核态和用户态。 你不希望访问用户执行内核代码或内核数据结构，除非处理器以内核模式运行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202010/1515111-20201010070727424-1283111958.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;访问控制信息被保存在上面的 Page Table Entry ，页表项中，上面这幅图是 Alpha AXP的 PTE。位字段具有以下含义&lt;/p&gt;
&lt;p&gt;表示 valid ，是否有效位&lt;/p&gt;
&lt;p&gt;读取时故障，在尝试读取此页面时出现故障&lt;/p&gt;
&lt;p&gt;写入时错误，在尝试写入时发生错误&lt;/p&gt;
&lt;p&gt;执行时发生错误，在尝试执行此页面中的指令时，处理器都会报告页面错误并将控制权传递给操作系统，&lt;/p&gt;
&lt;p&gt;地址空间匹配，当操作系统希望清除转换缓冲区中的某些条目时，将使用此选项。&lt;/p&gt;
&lt;p&gt;当在使用&lt;code&gt;单个转换缓冲区&lt;/code&gt;条目而不是&lt;code&gt;多个转换缓冲区&lt;/code&gt;条目映射整个块时使用的提示。&lt;/p&gt;
&lt;p&gt;内核模式运行下的代码可以读取页面&lt;/p&gt;
&lt;p&gt;用户模式下的代码可以读取页面&lt;/p&gt;
&lt;p&gt;以内核模式运行的代码可以写入页面&lt;/p&gt;
&lt;p&gt;以用户模式运行的代码可以写入页面&lt;/p&gt;
&lt;p&gt;对于设置了 V 位的 PTE，此字段包含此 PTE 的物理页面帧号（页面帧号）。对于无效的 PTE，如果此字段不为零，则包含有关页面在交换文件中的位置的信息。&lt;/p&gt;
&lt;p&gt;除此之外，Linux 还使用了两个位&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;_PAGE_DIRTY&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果已设置，则需要将页面写出到交换文件中&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;_PAGE_ACCESSED&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Linux 用来将页面标记为已访问。&lt;/p&gt;
&lt;h3 id=&quot;缓存&quot;&gt;缓存&lt;/h3&gt;
&lt;p&gt;上面的虚拟内存抽象模型可以用来实施，但是效率不会太高。操作系统和处理器设计人员都尝试提高性能。 但是除了提高处理器，内存等的速度之外，最好的方法就是维护有用信息和数据的高速缓存，从而使某些操作更快。在 Linux 中，使用很多和内存管理有关的缓冲区，使用缓冲区来提高效率。&lt;/p&gt;
&lt;h4 id=&quot;缓冲区缓存&quot;&gt;缓冲区缓存&lt;/h4&gt;
&lt;p&gt;缓冲区高速缓存包含&lt;code&gt;块设备&lt;/code&gt;驱动程序使用的数据缓冲区。&lt;/p&gt;
&lt;p&gt;还记得什么是块设备么？这里回顾下&lt;/p&gt;
&lt;p&gt;块设备是一个能存储&lt;code&gt;固定大小块&lt;/code&gt;信息的设备，它支持&lt;strong&gt;以固定大小的块，扇区或群集读取和（可选）写入数据&lt;/strong&gt;。每个块都有自己的&lt;code&gt;物理地址&lt;/code&gt;。通常块的大小在 512 - 65536 之间。所有传输的信息都会以&lt;code&gt;连续&lt;/code&gt;的块为单位。块设备的基本特征是每个块都较为对立，能够独立的进行读写。常见的块设备有 &lt;strong&gt;硬盘、蓝光光盘、USB 盘&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;与字符设备相比，块设备通常需要较少的引脚。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202010/1515111-20201010070749170-168962795.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;缓冲区高速缓存通过&lt;code&gt;设备标识符&lt;/code&gt;和块编号用于快速查找数据块。 如果可以在缓冲区高速缓存中找到数据，则无需从物理块设备中读取数据，这种访问方式要快得多。&lt;/p&gt;
&lt;h4 id=&quot;页缓存&quot;&gt;页缓存&lt;/h4&gt;
&lt;p&gt;页缓存用于加快对磁盘上图像和数据的访问&lt;/p&gt;
&lt;p&gt;它用于一次一页地缓存文件中的内容，并且可以通过文件和文件中的偏移量进行访问。当页面从磁盘读入内存时，它们被缓存在页面缓存中。&lt;/p&gt;
&lt;h4 id=&quot;交换区缓存&quot;&gt;交换区缓存&lt;/h4&gt;
&lt;p&gt;仅仅已修改（脏页）被保存在交换文件中&lt;/p&gt;
&lt;p&gt;只要这些页面在写入交换文件后没有修改，则下次交换该页面时，无需将其写入交换文件，因为该页面已在交换文件中。 可以直接丢弃。 在大量交换的系统中，这节省了许多不必要的和昂贵的磁盘操作。&lt;/p&gt;
&lt;h4 id=&quot;硬件缓存&quot;&gt;硬件缓存&lt;/h4&gt;
&lt;p&gt;处理器中通常使用一种硬件缓存。页表条目的缓存。在这种情况下，处理器并不总是直接读取页表，而是根据需要缓存页的翻译。 这些是&lt;code&gt;转换后备缓冲区&lt;/code&gt; 也被称为 &lt;code&gt;TLB&lt;/code&gt;，包含来自系统中一个或多个进程的页表项的缓存副本。&lt;/p&gt;
&lt;p&gt;引用虚拟地址后，处理器将尝试查找匹配的 TLB 条目。 如果找到，则可以将虚拟地址直接转换为物理地址，并对数据执行正确的操作。 如果处理器找不到匹配的 TLB 条目， 它通过向操作系统发信号通知已发生 TLB 丢失获得操作系统的支持和帮助。系统特定的机制用于将该异常传递给可以修复问题的操作系统代码。 操作系统为地址映射生成一个新的 TLB 条目。 清除异常后，处理器将再次尝试转换虚拟地址。这次能够执行成功。&lt;/p&gt;
&lt;p&gt;使用缓存也存在缺点，为了节省精力，Linux 必须使用更多的时间和空间来维护这些缓存，并且如果缓存损坏，系统将会崩溃。&lt;/p&gt;
&lt;h3 id=&quot;linux-页表&quot;&gt;Linux 页表&lt;/h3&gt;
&lt;p&gt;Linux 假定页表分为三个级别。访问的每个页表都包含下一级页表&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202010/1515111-20201010070758149-1697765434.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图中的 PDG 表示全局页表，当创建一个新的进程时，都要为新进程创建一个新的页面目录，即 PGD。&lt;/p&gt;
&lt;p&gt;要将虚拟地址转换为物理地址，处理器必须获取每个级别字段的内容，将其转换为包含页表的物理页的偏移量，并读取下一级页表的页框号。这样重复三次，直到找到包含虚拟地址的物理页面的页框号为止。&lt;/p&gt;
&lt;p&gt;Linux 运行的每个平台都必须提供翻译宏，这些宏允许内核遍历特定进程的页表。这样，内核无需知道页表条目的格式或它们的排列方式。&lt;/p&gt;
&lt;h3 id=&quot;页分配和取消分配&quot;&gt;页分配和取消分配&lt;/h3&gt;
&lt;p&gt;对系统中物理页面有很多需求。例如，当图像加载到内存中时，操作系统需要分配页面。&lt;/p&gt;
&lt;p&gt;系统中所有物理页面均由 &lt;code&gt;mem_map&lt;/code&gt; 数据结构描述，这个数据结构是 &lt;code&gt;mem_map_t&lt;/code&gt; 的列表。它包括一些重要的属性&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;count ：这是页面的用户数计数，当页面在多个进程之间共享时，计数大于 1&lt;/li&gt;
&lt;li&gt;age：这是描述页面的年龄，用于确定页面是否适合丢弃或交换&lt;/li&gt;
&lt;li&gt;map_nr ：这是此mem_map_t描述的物理页框号。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;页面分配代码使用 &lt;code&gt;free_area&lt;/code&gt;向量查找和释放页面，free_area 的每个元素都包含有关页面块的信息。&lt;/p&gt;
&lt;h4 id=&quot;页面分配&quot;&gt;页面分配&lt;/h4&gt;
&lt;p&gt;Linux 的页面分配使用一种著名的伙伴算法来进行页面的分配和取消分配。页面以 2 的幂为单位进行块分配。这就意味着它可以分配 1页、2 页、4页等等，只要系统中有足够可用的页面来满足需求就可以。判断的标准是&lt;strong&gt;nr_free_pages&amp;gt; min_free_pages&lt;/strong&gt;，如果满足，就会在 free_area 中搜索所需大小的页面块完成分配。free_area 的每个元素都有该大小的块的已分配页面和空闲页面块的映射。&lt;/p&gt;
&lt;p&gt;分配算法会搜索请求大小的页面块。如果没有任何请求大小的页面块可用的话，会搜寻一个是请求大小二倍的页面块，然后重复，直到一直搜寻完 free_area 找到一个页面块为止。如果找到的页面块要比请求的页面块大，就会对找到的页面块进行细分，直到找到合适的大小块为止。&lt;/p&gt;
&lt;p&gt;因为每个块都是 2 的次幂，所以拆分过程很容易，因为你只需将块分成两半即可。空闲块在适当的队列中排队，分配的页面块返回给调用者。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202010/1515111-20201010070807709-503424615.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果请求一个 2 个页的块，则 4 页的第一个块（从第 4 页的框架开始）将被分成两个 2 页的块。第一个页面（从第 4 页的帧开始）将作为分配的页面返回给调用方，第二个块（从第 6 页的页面开始）将作为 2 页的空闲块排队到 free_area 数组的元素 1 上。&lt;/p&gt;
&lt;h4 id=&quot;页面取消分配&quot;&gt;页面取消分配&lt;/h4&gt;
&lt;p&gt;上面的这种内存方式最造成一种后果，那就是内存的碎片化，会将较大的空闲页面分成较小的页面。页面解除分配代码会尽可能将页面重新组合成为更大的空闲块。每释放一个页面，都会检查相同大小的相邻的块，以查看是否空闲。如果是，则将其与新释放的页面块组合以形成下一个页面大小块的新的自由页面块。 每次将两个页面块重新组合为更大的空闲页面块时，页面释放代码就会尝试将该页面块重新组合为更大的空闲页面。 通过这种方式，可用页面的块将尽可能多地使用内存。&lt;/p&gt;
&lt;p&gt;例如上图，如果要释放第 1 页的页面，则将其与已经空闲的第 0 页页面框架组合在一起，并作为大小为 2页的空闲块排队到 free_area 的元素 1 中&lt;/p&gt;
&lt;h3 id=&quot;内存映射&quot;&gt;内存映射&lt;/h3&gt;
&lt;p&gt;内核有两种类型的内存映射：&lt;code&gt;共享型(shared)&lt;/code&gt; 和&lt;code&gt;私有型(private)&lt;/code&gt;。私有型是当进程为了只读文件，而不写文件时使用，这时，私有映射更加高效。 但是，任何对私有映射页的写操作都会导致内核停止映射该文件中的页。所以，写操作既不会改变磁盘上的文件，对访问该文件的其它进程也是不可见的。&lt;/p&gt;
&lt;h3 id=&quot;按需分页-2&quot;&gt;按需分页&lt;/h3&gt;
&lt;p&gt;一旦可执行映像被内存映射到虚拟内存后，它就可以被执行了。因为只将映像的开头部分物理的拉入到内存中，因此它将很快访问物理内存尚未存在的虚拟内存区域。当进程访问没有有效页表的虚拟地址时，操作系统会报告这项错误。&lt;/p&gt;
&lt;p&gt;页面错误描述页面出错的虚拟地址和引起的内存访问（RAM）类型。&lt;/p&gt;
&lt;p&gt;Linux 必须找到代表发生页面错误的内存区域的 vm_area_struct 结构。由于搜索 vm_area_struct 数据结构对于有效处理页面错误至关重要，因此它们以 &lt;code&gt;AVL（Adelson-Velskii和Landis）&lt;/code&gt;树结构链接在一起。如果引起故障的虚拟地址没有 &lt;code&gt;vm_area_struct&lt;/code&gt; 结构，则此进程已经访问了非法地址，Linux 会向进程发出 &lt;code&gt;SIGSEGV&lt;/code&gt; 信号，如果进程没有用于该信号的处理程序，那么进程将会终止。&lt;/p&gt;
&lt;p&gt;然后，Linux 会针对此虚拟内存区域所允许的访问类型，检查发生的页面错误类型。 如果该进程以非法方式访问内存，例如写入仅允许读的区域，则还会发出内存访问错误信号。&lt;/p&gt;
&lt;p&gt;现在，Linux 已确定页面错误是合法的，因此必须对其进行处理。&lt;/p&gt;
&lt;h2 id=&quot;文件系统&quot;&gt;文件系统&lt;/h2&gt;
&lt;p&gt;在 Linux 中，最直观、最可见的部分就是 &lt;code&gt;文件系统(file system)&lt;/code&gt;。下面我们就来一起探讨一下关于 Linux 中国的文件系统，系统调用以及文件系统实现背后的原理和思想。这些思想中有一些来源于 MULTICS，现在已经被 Windows 等其他操作系统使用。Linux 的设计理念就是 &lt;code&gt;小的就是好的(Small is Beautiful)&lt;/code&gt; 。虽然 Linux 只是使用了最简单的机制和少量的系统调用，但是 Linux 却提供了强大而优雅的文件系统。&lt;/p&gt;
&lt;h3 id=&quot;linux-文件系统基本概念&quot;&gt;Linux 文件系统基本概念&lt;/h3&gt;
&lt;p&gt;Linux 在最初的设计是 MINIX1 文件系统，它只支持 14 字节的文件名，它的最大文件只支持到 64 MB。在 MINIX 1 之后的文件系统是 ext 文件系统。ext 系统相较于 MINIX 1 来说，在支持字节大小和文件大小上均有很大提升，但是 ext 的速度仍没有 MINIX 1 快，于是，ext 2 被开发出来，它能够支持长文件名和大文件，而且具有比 MINIX 1 更好的性能。这使他成为 Linux 的主要文件系统。只不过 Linux 会使用 &lt;code&gt;VFS&lt;/code&gt; 曾支持多种文件系统。在 Linux 链接时，用户可以动态的将不同的文件系统挂载倒 VFS 上。&lt;/p&gt;
&lt;p&gt;Linux 中的文件是一个任意长度的字节序列，Linux 中的文件可以包含任意信息，比如 ASCII 码、二进制文件和其他类型的文件是不加区分的。&lt;/p&gt;
&lt;p&gt;为了方便起见，文件可以被组织在一个目录中，目录存储成文件的形式在很大程度上可以作为文件处理。目录可以有子目录，这样形成有层次的文件系统，Linux 系统下面的根目录是 &lt;code&gt;/&lt;/code&gt; ，它通常包含了多个子目录。字符 &lt;code&gt;/&lt;/code&gt; 还用于对目录名进行区分，例如 &lt;strong&gt;/usr/cxuan&lt;/strong&gt; 表示的就是根目录下面的 usr 目录，其中有一个叫做 cxuan 的子目录。&lt;/p&gt;
&lt;p&gt;下面我们介绍一下 Linux 系统根目录下面的目录名&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;/bin&lt;/code&gt;，它是重要的二进制应用程序，包含二进制文件，系统的所有用户使用的命令都在这里&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/boot&lt;/code&gt;，启动包含引导加载程序的相关文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/dev&lt;/code&gt;，包含设备文件，终端文件，USB 或者连接到系统的任何设备&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/etc&lt;/code&gt;，配置文件，启动脚本等，包含所有程序所需要的配置文件，也包含了启动/停止单个应用程序的启动和关闭 shell 脚本&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/home&lt;/code&gt;，本地主要路径，所有用户用 home 目录存储个人信息&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/lib&lt;/code&gt;，系统库文件，包含支持位于 /bin 和 /sbin 下的二进制库文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/lost+found&lt;/code&gt;，在根目录下提供一个遗失+查找系统，必须在 root 用户下才能查看当前目录下的内容&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/media&lt;/code&gt;，挂载可移动介质&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/mnt&lt;/code&gt;，挂载文件系统&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/opt&lt;/code&gt;，提供一个可选的应用程序安装目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/proc&lt;/code&gt;，特殊的动态目录，用于维护系统信息和状态，包括当前运行中进程信息&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/root&lt;/code&gt;，root 用户的主要目录文件夹&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/sbin&lt;/code&gt;，重要的二进制系统文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/tmp&lt;/code&gt;， 系统和用户创建的临时文件，系统重启时，这个目录下的文件都会被删除&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/usr&lt;/code&gt;，包含绝大多数用户都能访问的应用程序和文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/var&lt;/code&gt;，经常变化的文件，诸如日志文件或数据库等&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在 Linux 中，有两种路径，一种是 &lt;code&gt;绝对路径(absolute path)&lt;/code&gt; ，绝对路径告诉你从根目录下查找文件，绝对路径的缺点是太长而且不太方便。还有一种是 &lt;code&gt;相对路径(relative path)&lt;/code&gt; ，相对路径所在的目录也叫做&lt;code&gt;工作目录(working directory)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果 &lt;code&gt;/usr/local/books&lt;/code&gt; 是工作目录，那么 shell 命令&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;cp books books-replica 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;就表示的是相对路径，而&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;cp /usr/local/books/books /usr/local/books/books-replica
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;则表示的是绝对路径。&lt;/p&gt;
&lt;p&gt;在 Linux 中经常出现一个用户使用另一个用户的文件或者使用文件树结构中的文件。两个用户共享同一个文件，这个文件位于某个用户的目录结构中，另一个用户需要使用这个文件时，必须通过绝对路径才能引用到他。如果绝对路径很长，那么每次输入起来会变的非常麻烦，所以 Linux 提供了一种 &lt;code&gt;链接(link)&lt;/code&gt; 机制。&lt;/p&gt;
&lt;p&gt;举个例子，下面是一个使用链接之前的图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202010/1515111-20201010070820554-1259057808.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以上所示，比如有两个工作账户 jianshe 和 cxuan，jianshe 想要使用 cxuan 账户下的 A 目录，那么它可能会输入 &lt;code&gt;/usr/cxuan/A&lt;/code&gt; ，这是一种未使用链接之后的图。&lt;/p&gt;
&lt;p&gt;使用链接后的示意如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202010/1515111-20201010070827891-1440677136.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在，jianshe 可以创建一个链接来使用 cxuan 下面的目录了。‘&lt;/p&gt;
&lt;p&gt;当一个目录被创建出来后，有两个目录项也同时被创建出来，它们就是 &lt;code&gt;.&lt;/code&gt; 和 &lt;code&gt;..&lt;/code&gt; ，前者代表工作目录自身，后者代表该目录的父目录，也就是该目录所在的目录。这样一来，在 /usr/jianshe 中访问 cxuan 中的目录就是 &lt;code&gt;../cxuan/xxx&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Linux 文件系统不区分磁盘的，这是什么意思呢？一般来说，一个磁盘中的文件系统相互之间保持独立，如果一个文件系统目录想要访问另一个磁盘中的文件系统，在 Windows 中你可以像下面这样。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202010/1515111-20201010070836011-2135160112.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;两个文件系统分别在不同的磁盘中，彼此保持独立。&lt;/p&gt;
&lt;p&gt;而在 Linux 中，是支持&lt;code&gt;挂载&lt;/code&gt;的，它允许一个磁盘挂在到另外一个磁盘上，那么上面的关系会变成下面这样&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202010/1515111-20201010070843726-987290073.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;挂在之后，两个文件系统就不再需要关心文件系统在哪个磁盘上了，两个文件系统彼此可见。&lt;/p&gt;
&lt;p&gt;Linux 文件系统的另外一个特性是支持 &lt;code&gt;加锁(locking)&lt;/code&gt;。在一些应用中会出现两个或者更多的进程同时使用同一个文件的情况，这样很可能会导致&lt;code&gt;竞争条件(race condition)&lt;/code&gt;。一种解决方法是对其进行加不同粒度的锁，就是为了防止某一个进程只修改某一行记录从而导致整个文件都不能使用的情况。&lt;/p&gt;
&lt;p&gt;POSIX 提供了一种灵活的、不同粒度级别的锁机制，允许一个进程使用一个不可分割的操作对一个字节或者整个文件进行加锁。加锁机制要求尝试加锁的进程指定其 &lt;strong&gt;要加锁的文件，开始位置以及要加锁的字节&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Linux 系统提供了两种锁：&lt;strong&gt;共享锁和互斥锁&lt;/strong&gt;。如果文件的一部分已经加上了共享锁，那么再加排他锁是不会成功的；如果文件系统的一部分已经被加了互斥锁，那么在互斥锁解除之前的任何加锁都不会成功。为了成功加锁、请求加锁的部分的所有字节都必须是可用的。&lt;/p&gt;
&lt;p&gt;在加锁阶段，进程需要设计好加锁失败后的情况，也就是判断加锁失败后是否选择阻塞，如果选择阻塞式，那么当已经加锁的进程中的锁被删除时，这个进程会解除阻塞并替换锁。如果进程选择非阻塞式的，那么就不会替换这个锁，会立刻从系统调用中返回，标记状态码表示是否加锁成功，然后进程会选择下一个时间再次尝试。&lt;/p&gt;
&lt;p&gt;加锁区域是可以重叠的。下面我们演示了三种不同条件的加锁区域。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202010/1515111-20201010070852788-967357050.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，A 的共享锁在第四字节到第八字节进行加锁&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202010/1515111-20201010070901302-2070984447.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，进程在 A 和 B 上同时加了共享锁，其中 6 - 8 字节是重叠锁&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202010/1515111-20201010070907206-1225942801.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，进程 A 和 B 和 C 同时加了共享锁，那么第六字节和第七字节是共享锁。&lt;/p&gt;
&lt;p&gt;如果此时一个进程尝试在第 6 个字节处加锁，此时会设置失败并阻塞，由于该区域被 A B C 同时加锁，那么只有等到 A B C 都释放锁后，进程才能加锁成功。&lt;/p&gt;
&lt;h3 id=&quot;linux-文件系统调用&quot;&gt;Linux 文件系统调用&lt;/h3&gt;
&lt;p&gt;许多系统调用都会和文件与文件系统有关。我们首先先看一下对单个文件的系统调用，然后再来看一下对整个目录和文件的系统调用。&lt;/p&gt;
&lt;p&gt;为了创建一个新的文件，会使用到 &lt;code&gt;creat&lt;/code&gt; 方法，注意没有 &lt;code&gt;e&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;这里说一个小插曲，曾经有人问 UNIX 创始人 Ken Thompson，如果有机会重新写 UNIX ，你会怎么办，他回答自己要把 creat 改成 create ，哈哈哈哈。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个系统调用的两个参数是文件名和保护模式&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;fd = creat(&quot;aaa&quot;,mode);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段命令会创建一个名为 aaa 的文件，并根据 mode 设置文件的保护位。这些位决定了哪个用户可能访问文件、如何访问。&lt;/p&gt;
&lt;p&gt;creat 系统调用不仅仅创建了一个名为 aaa 的文件，还会打开这个文件。为了允许后续的系统调用访问这个文件，这个 creat 系统调用会返回一个 &lt;code&gt;非负整数&lt;/code&gt;， 这个就叫做 &lt;code&gt;文件描述符(file descriptor)&lt;/code&gt;，也就是上面的 fd。&lt;/p&gt;
&lt;p&gt;如果在已经存在的文件上调用了 creat 系统调用，那么该文件中的内容会被清除，从 0 开始。通过设置合适的参数，&lt;code&gt;open&lt;/code&gt; 系统调用也能够创建文件。&lt;/p&gt;
&lt;p&gt;下面让我们看一看主要的系统调用，如下表所示&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;系统调用&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;12&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;fd = creat(name,mode)&lt;/td&gt;
&lt;td&gt;一种创建一个新文件的方式&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;fd = open(file, ...)&lt;/td&gt;
&lt;td&gt;打开文件读、写或者读写&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;s = close(fd)&lt;/td&gt;
&lt;td&gt;关闭一个打开的文件&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;n = read(fd, buffer, nbytes)&lt;/td&gt;
&lt;td&gt;从文件中向缓存中读入数据&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;n = write(fd, buffer, nbytes)&lt;/td&gt;
&lt;td&gt;从缓存中向文件中写入数据&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;position = lseek(fd, offset, whence)&lt;/td&gt;
&lt;td&gt;移动文件指针&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;s = stat(name, &amp;amp;buf)&lt;/td&gt;
&lt;td&gt;获取文件信息&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;s = fstat(fd, &amp;amp;buf)&lt;/td&gt;
&lt;td&gt;获取文件信息&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;s = pipe(&amp;amp;fd[0])&lt;/td&gt;
&lt;td&gt;创建一个管道&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;s = fcntl(fd,...)&lt;/td&gt;
&lt;td&gt;文件加锁等其他操作&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;为了对一个文件进行读写的前提是先需要打开文件，必须使用 creat 或者 open 打开，参数是打开文件的方式，是只读、可读写还是只写。open 系统调用也会返回文件描述符。打开文件后，需要使用 &lt;code&gt;close&lt;/code&gt; 系统调用进行关闭。close 和 open 返回的 fd 总是未被使用的最小数量。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;什么是文件描述符？文件描述符就是一个数字，这个数字标示了计算机操作系统中打开的文件。它描述了数据资源，以及访问资源的方式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当程序要求打开一个文件时，内核会进行如下操作&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;授予访问权限&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;全局文件表(global file table)&lt;/code&gt;中创建一个&lt;code&gt;条目(entry)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;向软件提供条目的位置&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;文件描述符由唯一的非负整数组成，系统上每个打开的文件至少存在一个文件描述符。文件描述符最初在 Unix 中使用，并且被包括 Linux，macOS 和 BSD 在内的现代操作系统所使用。&lt;/p&gt;
&lt;p&gt;当一个进程成功访问一个打开的文件时，内核会返回一个文件描述符，这个文件描述符指向全局文件表的 entry 项。这个文件表项包含文件的 inode 信息，字节位移，访问限制等。例如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202010/1515111-20201010070918103-1210433994.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;默认情况下，前三个文件描述符为 &lt;code&gt;STDIN(标准输入)&lt;/code&gt;、&lt;code&gt;STDOUT(标准输出)&lt;/code&gt;、&lt;code&gt;STDERR(标准错误)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;标准输入的文件描述符是 0 ，在终端中，默认为用户的键盘输入&lt;/p&gt;
&lt;p&gt;标准输出的文件描述符是 1 ，在终端中，默认为用户的屏幕&lt;/p&gt;
&lt;p&gt;与错误有关的默认数据流是 2，在终端中，默认为用户的屏幕。&lt;/p&gt;
&lt;p&gt;在简单聊了一下文件描述符后，我们继续回到文件系统调用的探讨。&lt;/p&gt;
&lt;p&gt;在文件系统调用中，开销最大的就是 read 和 write 了。read 和 write 都有三个参数&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;文件描述符&lt;/code&gt;：告诉需要对哪一个打开文件进行读取和写入&lt;/li&gt;
&lt;li&gt;&lt;code&gt;缓冲区地址&lt;/code&gt;：告诉数据需要从哪里读取和写入哪里&lt;/li&gt;
&lt;li&gt;&lt;code&gt;统计&lt;/code&gt;：告诉需要传输多少字节&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这就是所有的参数了，这个设计非常简单轻巧。&lt;/p&gt;
&lt;p&gt;虽然几乎所有程序都按顺序读取和写入文件，但是某些程序需要能够随机访问文件的任何部分。与每个文件相关联的是一个指针，该指针指示文件中的当前位置。顺序读取（或写入）时，它通常指向要读取（写入）的下一个字节。如果指针在读取 1024 个字节之前位于 4096 的位置，则它将在成功读取系统调用后自动移至 5120 的位置。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Lseek&lt;/code&gt; 系统调用会更改指针位置的值，以便后续对 read 或 write 的调用可以在文件中的任何位置开始，甚至可以超出文件末尾。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;lseek = Lseek ，段首大写。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;lseek 避免叫做 seek 的原因就是 seek 已经在之前 16 位的计算机上用于搜素功能了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Lseek&lt;/code&gt; 有三个参数：第一个是文件的文件描述符，第二个是文件的位置；第三个告诉文件位置是相对于文件的开头，当前位置还是文件的结尾&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;lseek(int fildes, off_t offset, int whence);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;lseek 的返回值是更改文件指针后文件中的绝对位置。lseek 是唯一从来不会造成真正磁盘查找的系统调用，它只是更新当前的文件位置，这个文件位置就是内存中的数字。&lt;/p&gt;
&lt;p&gt;对于每个文件，Linux 都会跟踪文件模式（常规，目录，特殊文件），大小，最后修改时间以及其他信息。程序能够通过 &lt;code&gt;stat&lt;/code&gt; 系统调用看到这些信息。第一个参数就是文件名，第二个是指向要放置请求信息结构的指针。这些结构的属性如下图所示。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;存储文件的设备&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr&gt;&lt;td&gt;存储文件的设备&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;i-node 编号&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;文件模式(包括保护位信息)&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;文件链接的数量&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;文件所有者标识&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;文件所属的组&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;文件大小(字节)&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;创建时间&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;最后一个修改/访问时间&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;code&gt;fstat&lt;/code&gt; 调用和 &lt;code&gt;stat&lt;/code&gt; 相同，只有一点区别，fstat 可以对打开文件进行操作，而 stat 只能对路径进行操作。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pipe&lt;/code&gt; 文件系统调用被用来创建 shell 管道。它会创建一系列的&lt;code&gt;伪文件&lt;/code&gt;，来缓冲和管道组件之间的数据，并且返回读取或者写入缓冲区的文件描述符。在管道中，像是如下操作&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;sort &amp;lt;in | head –40
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;sort 进程将会输出到文件描述符1，也就是标准输出，写入管道中，而 head 进程将从管道中读入。在这种方式中，sort 只是从文件描述符 0 中读取并写入到文件描述符 1 （管道）中，甚至不知道它们已经被重定向了。如果没有重定向的话，sort 会自动的从键盘读入并输出到屏幕中。&lt;/p&gt;
&lt;p&gt;最后一个系统调用是 &lt;code&gt;fcntl&lt;/code&gt;，它用来锁定和解锁文件，应用共享锁和互斥锁，或者是执行一些文件相关的其他操作。&lt;/p&gt;
&lt;p&gt;现在我们来关心一下和整体目录和文件系统相关的系统调用，而不是把精力放在单个的文件上，下面列出了这些系统调用，我们一起来看一下。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;系统调用&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3.5&quot;&gt;&lt;tr&gt;&lt;td&gt;s = mkdir(path,mode)&lt;/td&gt;
&lt;td&gt;创建一个新的目录&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;s = rmdir(path)&lt;/td&gt;
&lt;td&gt;移除一个目录&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;s = link(oldpath,newpath)&lt;/td&gt;
&lt;td&gt;创建指向已有文件的链接&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;s = unlink(path)&lt;/td&gt;
&lt;td&gt;取消文件的链接&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;s = chdir(path)&lt;/td&gt;
&lt;td&gt;改变工作目录&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;dir = opendir(path)&lt;/td&gt;
&lt;td&gt;打开一个目录读取&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;s = closedir(dir)&lt;/td&gt;
&lt;td&gt;关闭一个目录&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;dirent = readdir(dir)&lt;/td&gt;
&lt;td&gt;读取一个目录项&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;rewinddir(dir)&lt;/td&gt;
&lt;td&gt;回转目录使其在此使用&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;可以使用 mkdir 和 rmdir 创建和删除目录。但是需要注意，只有目录为空时才可以删除。&lt;/p&gt;
&lt;p&gt;创建一个指向已有文件的链接时会创建一个&lt;code&gt;目录项(directory entry)&lt;/code&gt;。系统调用 link 来创建链接，oldpath 代表已有的路径，newpath 代表需要链接的路径，使用 &lt;code&gt;unlink&lt;/code&gt; 可以删除目录项。当文件的最后一个链接被删除时，这个文件会被自动删除。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;chdir&lt;/code&gt; 系统调用可以改变工作目录。&lt;/p&gt;
&lt;p&gt;最后四个系统调用是用于读取目录的。和普通文件类似，他们可以被打开、关闭和读取。每次调用 &lt;code&gt;readdir&lt;/code&gt; 都会以固定的格式返回一个目录项。用户不能对目录执行写操作，但是可以使用 creat 或者 link 在文件夹中创建一个目录，或使用 unlink 删除一个目录。用户不能在目录中查找某个特定文件，但是可以使用 &lt;code&gt;rewindir&lt;/code&gt; 作用于一个打开的目录，使他能在此从头开始读取。&lt;/p&gt;
&lt;h3 id=&quot;linux-文件系统的实现&quot;&gt;Linux 文件系统的实现&lt;/h3&gt;
&lt;p&gt;下面我们主要讨论一下 &lt;code&gt;虚拟文件系统(Virtual File System)&lt;/code&gt;。 VFS 对高层进程和应用程序隐藏了 Linux 支持的所有文件系统的区别，以及文件系统是存储在本地设备，还是需要通过网络访问远程设备。设备和其他特殊文件和 VFS 层相关联。接下来，我们就会探讨一下第一个 Linux 广泛传播的文件系统： &lt;code&gt;ext2&lt;/code&gt;。随后，我们就会探讨 &lt;code&gt;ext4&lt;/code&gt; 文件系统所做的改进。各种各样的其他文件系统也正在使用中。 所有 Linux 系统都可以处理多个磁盘分区，每个磁盘分区上都有不同的文件系统。&lt;/p&gt;
&lt;h4 id=&quot;linux-虚拟文件系统&quot;&gt;Linux 虚拟文件系统&lt;/h4&gt;
&lt;p&gt;为了能够使应用程序能够在不同类型的本地或者远程设备上的文件系统进行交互，因为在 Linux 当中文件系统千奇百种，比较常见的有 EXT3、EXT4，还有基于内存的 ramfs、tmpfs 和基于网络的 nfs，和基于用户态的 fuse，当然 fuse 应该不能完全的文件系统，只能算是一个能把文件系统实现放到用户态的模块，满足了内核文件系统的接口，他们都是文件系统的一种实现。对于这些文件系统，Linux 做了一层抽象就是 &lt;code&gt;VFS&lt;/code&gt; 虚拟文件系统，&lt;/p&gt;
&lt;p&gt;下表总结了 VFS 支持的四个主要的文件系统结构。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;对象&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr&gt;&lt;td&gt;超级块&lt;/td&gt;
&lt;td&gt;特定的文件系统&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Dentry&lt;/td&gt;
&lt;td&gt;目录项，路径的一个组成部分&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;I-node&lt;/td&gt;
&lt;td&gt;特定的文件&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;File&lt;/td&gt;
&lt;td&gt;跟一个进程相关联的打开文件&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;code&gt;超级块(superblock)&lt;/code&gt; 包含了有关文件系统布局的重要信息，超级块如果遭到破坏那么就会导致整个文件系统不可读。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;i-node&lt;/code&gt; 索引节点，包含了每一个文件的描述符。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;在 Linux 中，目录和设备也表示为文件，因为它们具有对应的 i-node&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;超级块和索引块所在的文件系统都在磁盘上有对应的结构。&lt;/p&gt;
&lt;p&gt;为了便于某些目录操作和路径遍历，比如 /usr/local/cxuan，VFS 支持一个 &lt;code&gt;dentry&lt;/code&gt; 数据结构，该数据结构代表着目录项。这个 dentry 数据结构有很多东西（&lt;a href=&quot;http://books.gigatux.nl/mirror/kerneldevelopment/0672327201/ch12lev1sec7.html%EF%BC%89%E8%BF%99%E4%B8%AA%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%94%B1%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E3%80%82&quot;&gt;http://books.gigatux.nl/mirror/kerneldevelopment/0672327201/ch12lev1sec7.html）这个数据结构由文件系统动态创建。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;目录项被缓存在 &lt;code&gt;dentry_cache&lt;/code&gt; 缓存中。例如，缓存条目会缓存 /usr 、 /usr/local 等条目。如果多个进程通过硬连接访问相同的文件，他们的文件对象将指向此缓存中的相同条目。&lt;/p&gt;
&lt;p&gt;最后，文件数据结构是代表着打开的文件，也代表着内存表示，它根据 open 系统调用创建。它支持 &lt;strong&gt;read、write、sendfile、lock&lt;/strong&gt; 和其他在我们之前描述的系统调用中。&lt;/p&gt;
&lt;p&gt;在 VFS 下实现的实际文件系统不需要在内部使用完全相同的抽象和操作。 但是，它们必须在语义上实现与 VFS 对象指定的文件系统操作相同的文件系统操作。 四个 VFS 对象中每个对象的操作数据结构的元素都是指向基础文件系统中功能的指针。&lt;/p&gt;
&lt;h4 id=&quot;linux-ext2-文件系统&quot;&gt;Linux Ext2 文件系统&lt;/h4&gt;
&lt;p&gt;现在我们一起看一下 Linux 中最流行的一个磁盘文件系统，那就是 &lt;code&gt;ext2&lt;/code&gt; 。Linux 的第一个版本用于 &lt;code&gt;MINIX1&lt;/code&gt; 文件系统，它的文件名大小被限制为最大 64 MB。MINIX 1 文件系统被永远的被它的扩展系统 ext 取代，因为 ext 允许更长的文件名和文件大小。由于 ext 的性能低下，ext 被其替代者 ext2 取代，ext2 目前仍在广泛使用。&lt;/p&gt;
&lt;p&gt;一个 ext2 Linux 磁盘分区包含了一个文件系统，这个文件系统的布局如下所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202010/1515111-20201010070934113-860700382.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Boot 块也就是第 0 块不是让 Linux 使用的，而是用来加载和引导计算机启动代码的。在块 0 之后，磁盘分区被分成多个组，这些组与磁盘柱面边界所处的位置无关。&lt;/p&gt;
&lt;p&gt;第一个块是 &lt;code&gt;超级块(superblock)&lt;/code&gt;。它包含有关文件系统布局的信息，包括 i-node、磁盘块数量和以及空闲磁盘块列表的开始。下一个是 &lt;code&gt;组描述符(group descriptor)&lt;/code&gt;，其中包含有关位图的位置，组中空闲块和 i-node 的数量以及组中的目录数量的信息。这些信息很重要，因为 ext2 会在磁盘上均匀分布目录。&lt;/p&gt;
&lt;p&gt;图中的两个位图用来记录空闲块和空闲 i-node，这是从 MINIX 1文件系统继承的选择，大多数 UNIX 文件系统使用位图而不是空闲列表。每个位图的大小是一个块。如果一个块的大小是 1 KB，那么就限制了块组的数量是 8192 个块和 8192 个 i-node。块的大小是一个严格的限制，块组的数量不固定，在 4KB 的块中，块组的数量增大四倍。&lt;/p&gt;
&lt;p&gt;在超级块之后分布的是 &lt;code&gt;i-node&lt;/code&gt; 它们自己，i-node 取值范围是 1 - 某些最大值。每个 i-node 是 128 字节的 &lt;code&gt;long&lt;/code&gt; ，这些字节恰好能够描述一个文件。i-node 包含了统计信息(包含了 &lt;code&gt;stat&lt;/code&gt; 系统调用能获得的所有者信息，实际上 stat 就是从 i-node 中读取信息的)，以及足够的信息来查找保存文件数据的所有磁盘块。&lt;/p&gt;
&lt;p&gt;在 i-node 之后的是 &lt;code&gt;数据块(data blocks)&lt;/code&gt;。所有的文件和目录都保存在这。如果一个文件或者目录包含多个块，那么这些块在磁盘中的分布不一定是连续的，也有可能不连续。事实上，大文件块可能会被拆分成很多小块散布在整个磁盘上。&lt;/p&gt;
&lt;p&gt;对应于目录的 i-node 分散在整个磁盘组上。如果有足够的空间，ext2 会把普通文件组织到与父目录相同的块组中，而把同一块上的数据文件组织成初始 &lt;code&gt;i-node&lt;/code&gt; 节点。位图用来快速确定新文件系统数据的分配位置。在分配新的文件块时，ext2 也会给该文件预分配许多额外的数据块，这样可以减少将来向文件写入数据时产生的文件碎片。这种策略在整个磁盘上实现了文件系统的 &lt;code&gt;负载&lt;/code&gt;，后续还有对文件碎片的排列和整理，而且性能也比较好。&lt;/p&gt;
&lt;p&gt;为了达到访问的目的，需要首先使用 Linux 系统调用，例如 &lt;code&gt;open&lt;/code&gt;，这个系统调用会确定打开文件的路径。路径分为两种，&lt;code&gt;相对路径&lt;/code&gt; 和 &lt;code&gt;绝对路径&lt;/code&gt;。如果使用相对路径，那么就会从当前目录开始查找，否则就会从根目录进行查找。&lt;/p&gt;
&lt;p&gt;目录文件的文件名最高不能超过 255 个字符，它的分配如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202010/1515111-20201010070943003-1843370810.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每一个目录都由整数个磁盘块组成，这样目录就可以整体的写入磁盘。在一个目录中，文件和子目录的目录项都是未经排序的，并且一个挨着一个。目录项不能跨越磁盘块，所以通常在每个磁盘块的尾部会有部分未使用的字节。&lt;/p&gt;
&lt;p&gt;上图中每个目录项都由四个固定长度的属性和一个长度可变的属性组成。第一个属性是 &lt;code&gt;i-node&lt;/code&gt; 节点数量，文件 first 的 i-node 编号是 19 ，文件 second 的编号是 42，目录 third 的 i-node 编号是 88。紧随其后的是 &lt;code&gt;rec_len&lt;/code&gt; 域，表明目录项大小是多少字节，名称后面会有一些扩展，当名字以未知长度填充时，这个域被用来寻找下一个目录项，直至最后的未使用。这也是图中箭头的含义。紧随其后的是 &lt;code&gt;类型域&lt;/code&gt;：F 表示的是文件，D 表示的是目录，最后是固定长度的文件名，上面的文件名的长度依次是 5、6、5，最后以文件名结束。&lt;/p&gt;
&lt;p&gt;rec_len 域是如何扩展的呢？如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202010/1515111-20201010070950117-527712385.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以看到，中间的 &lt;code&gt;second&lt;/code&gt; 被移除了，所以将其所在的域变为第一个目录项的填充。当然，这个填充可以作为后续的目录项。&lt;/p&gt;
&lt;p&gt;由于目录是按照线性的顺序进行查找的，因此可能需要很长时间才能在大文件末尾找到目录项。因此，系统会为近期的访问目录维护一个缓存。这个缓存用文件名来查找，如果缓存命中，那么就会避免线程搜索这样昂贵的开销。组成路径的每个部分都在目录缓存中保存一个 &lt;code&gt;dentry&lt;/code&gt; 对象，并且通过 i-node 找到后续的路径元素的目录项，直到找到真正的文件 i - node。&lt;/p&gt;
&lt;p&gt;比如说要使用绝对路径来寻找一个文件，我们暂定这个路径是 &lt;code&gt;/usr/local/file&lt;/code&gt;，那么需要经过如下几个步骤：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先，系统会确定根目录，它通常使用 2 号 i -node ，也就是索引 2 节点，因为索引节点 1 是 ext2 /3/4 文件系统上的&lt;code&gt;坏块&lt;/code&gt;索引节点。系统会将一项放在 dentry 缓存中，以应对将来对根目录的查找。&lt;/li&gt;
&lt;li&gt;然后，在根目录中查找字符串 &lt;code&gt;usr&lt;/code&gt;，得到 /usr 目录的 i - node 节点号。/usr 的 i - node 同样也进入 dentry 缓存。然后节点被取出，并从中解析出磁盘块，这样就可以读取 /usr 目录并查找字符串 &lt;code&gt;local&lt;/code&gt; 了。一旦找到这个目录项，目录 &lt;code&gt;/usr/local&lt;/code&gt; 的 i - node 节点就可以从中获得。有了 /usr/local 的 i - node 节点号，就可以读取 i - node 并确定目录所在的磁盘块。最后，从 /usr/local 目录查找 file 并确定其 i - node 节点呢号。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果文件存在，那么系统会提取 i - node 节点号并把它作为索引在 i - node 节点表中定位相应的 i - node 节点并装入内存。i - node 被存放在 i - node &lt;code&gt;节点表(i-node table)&lt;/code&gt; 中，节点表是一个内核数据结构，它会持有当前打开文件和目录的 i - node 节点号。下面是一些 Linux 文件系统支持的 i - node 数据结构。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;字节&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;7&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Mode&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;文件属性、保护位、setuid 和 setgid 位&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Nlinks&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;指向 i - node 节点目录项的数目&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Uid&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;文件所有者的 UID&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Gid&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;文件所有者的 GID&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Size&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;文件字节大小&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Addr&lt;/td&gt;
&lt;td&gt;60&lt;/td&gt;
&lt;td&gt;12 个磁盘块以及后面 3 个间接块的地址&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Gen&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;每次重复使用 i - node 时增加的代号&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Atime&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;最近访问文件的时间&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Mtime&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;最近修改文件的时间&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Ctime&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;最近更改 i - node 的时间&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;现在我们来一起探讨一下文件读取过程，还记得 &lt;code&gt;read&lt;/code&gt; 函数是如何调用的吗？&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;n = read(fd,buffer,nbytes);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当内核接管后，它会从这三个参数以及内部表与用户有关的信息开始。内部表的其中一项是文件描述符数组。文件描述符数组用&lt;code&gt;文件描述符&lt;/code&gt; 作为索引并为每一个打开文件保存一个表项。&lt;/p&gt;
&lt;p&gt;文件是和 i - node 节点号相关的。那么如何通过一个文件描述符找到文件对应的 i - node 节点呢？&lt;/p&gt;
&lt;p&gt;这里使用的一种设计思想是在文件描述符表和 i - node 节点表之间插入一个新的表，叫做 &lt;code&gt;打开文件描述符(open-file-description table)&lt;/code&gt;。文件的读写位置会在打开文件描述符表中存在，如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202010/1515111-20201010070959382-1820589440.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们使用 shell 、P1 和 P2 来描述一下父进程、子进程、子进程的关系。Shell 首先生成 P1，P1 的数据结构就是 Shell 的一个副本，因此两者都指向相同的打开文件描述符的表项。当 P1 运行完成后，Shell 的文件描述符仍会指向 P1 文件位置的打开文件描述。然后 Shell 生成了 P2，新的子进程自动继承文件的读写位置，甚至 P2 和 Shell 都不知道文件具体的读写位置。&lt;/p&gt;
&lt;p&gt;上面描述的是父进程和子进程这两个 &lt;code&gt;相关&lt;/code&gt; 进程，如果是一个不相关进程打开文件时，它将得到自己的打开文件描述符表项，以及自己的文件读写位置，这是我们需要的。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;因此，打开文件描述符相当于是给相关进程提供同一个读写位置，而给不相关进程提供各自私有的位置。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;i - node 包含三个间接块的磁盘地址，它们每个指向磁盘块的地址所能够存储的大小不一样。&lt;/p&gt;
&lt;h4 id=&quot;linux-ext4-文件系统&quot;&gt;Linux Ext4 文件系统&lt;/h4&gt;
&lt;p&gt;为了防止由于系统崩溃和电源故障造成的数据丢失，ext2 系统必须在每个数据块创建之后立即将其写入到磁盘上，磁盘磁头寻道操作导致的延迟是无法让人忍受的。为了增强文件系统的健壮性，Linux 依靠&lt;code&gt;日志文件系统&lt;/code&gt;，ext3 是一个日志文件系统，它在 ext2 文件系统的基础之上做了改进，ext4 也是 ext3 的改进，ext4 也是一个日志文件系统。ext4 改变了 ext3 的块寻址方案，从而支持更大的文件和更大的文件系统大小。下面我们就来描述一下 ext4 文件系统的特性。&lt;/p&gt;
&lt;p&gt;具有记录的文件系统最基本的功能就是&lt;code&gt;记录日志&lt;/code&gt;，这个日志记录了按照顺序描述所有文件系统的操作。通过顺序写出文件系统数据或元数据的更改，操作不受磁盘访问期间磁盘头移动的开销。最终，这个变更会写入并提交到合适的磁盘位置上。如果这个变更在提交到磁盘前文件系统宕机了，那么在重启期间，系统会检测到文件系统未正确卸载，那么就会遍历日志并应用日志的记录来对文件系统进行更改。&lt;/p&gt;
&lt;p&gt;Ext4 文件系统被设计用来高度匹配 ext2 和 ext3 文件系统的，尽管 ext4 文件系统在内核数据结构和磁盘布局上都做了变更。尽管如此，一个文件系统能够从 ext2 文件系统上卸载后成功的挂载到 ext4 文件系统上，并提供合适的日志记录。&lt;/p&gt;
&lt;p&gt;日志是作为循环缓冲区管理的文件。日志可以存储在与主文件系统相同或者不同的设备上。日志记录的读写操作会由单独的 &lt;code&gt;JBD(Journaling Block Device)&lt;/code&gt; 来扮演。&lt;/p&gt;
&lt;p&gt;JBD 中有三个主要的数据结构，分别是 &lt;strong&gt;log record(日志记录)、原子操作和事务&lt;/strong&gt;。一个日志记录描述了一个低级别的文件系统操作，这个操作通常导致块内的变化。因为像是 &lt;code&gt;write&lt;/code&gt; 这种系统调用会包含多个地方的改动 --- i - node 节点，现有的文件块，新的文件块和空闲列表等。相关的日志记录会以原子性的方式分组。ext4 会通知系统调用进程的开始和结束，以此使 JBD 能够确保原子操作的记录都能被应用，或者一个也不被应用。最后，主要从效率方面考虑，JBD 会视原子操作的集合为事务。一个事务中的日志记录是连续存储的。只有在所有的变更一起应用到磁盘后，日志记录才能够被丢弃。&lt;/p&gt;
&lt;p&gt;由于为每个磁盘写出日志的开销会很大，所以 ext4 可以配置为保留所有磁盘更改的日志，或者仅仅保留与文件系统元数据相关的日志更改。仅仅记录元数据可以减少系统开销，提升性能，但不能保证不会损坏文件数据。其他的几个日志系统维护着一系列元数据操作的日志，例如 SGI 的 XFS。&lt;/p&gt;
&lt;h4 id=&quot;proc-文件系统&quot;&gt;/proc 文件系统&lt;/h4&gt;
&lt;p&gt;另外一个 Linux 文件系统是 &lt;code&gt;/proc&lt;/code&gt; (process) 文件系统&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;它的主要思想来源于贝尔实验室开发的第 8 版的 UNIX，后来被 BSD 和 System V 采用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然而，Linux 在一些方面上对这个想法进行了扩充。它的基本概念是为系统中的每个进程在 &lt;code&gt;/proc&lt;/code&gt; 中创建一个目录。目录的名字就是进程 PID，以十进制数进行表示。例如，&lt;code&gt;/proc/1024&lt;/code&gt; 就是一个进程号为 1024 的目录。在该目录下是进程信息相关的文件，比如进程的命令行、环境变量和信号掩码等。事实上，这些文件在磁盘上并不存在磁盘中。当需要这些信息的时候，系统会按需从进程中读取，并以标准格式返回给用户。&lt;/p&gt;
&lt;p&gt;许多 Linux 扩展与 &lt;code&gt;/proc&lt;/code&gt; 中的其他文件和目录有关。它们包含各种各样的关于 CPU、磁盘分区、设备、中断向量、内核计数器、文件系统、已加载模块等信息。非特权用户可以读取很多这样的信息，于是就可以通过一种安全的方式了解系统情况。&lt;/p&gt;
&lt;h3 id=&quot;nfs-网络文件系统&quot;&gt;NFS 网络文件系统&lt;/h3&gt;
&lt;p&gt;从一开始，网络就在 Linux 中扮演了很重要的作用。下面我们会探讨一下 &lt;code&gt;NFS(Network File System)&lt;/code&gt; 网络文件系统，它在现代 Linux 操作系统的作用是将不同计算机上的不同文件系统链接成一个逻辑整体。&lt;/p&gt;
&lt;h4 id=&quot;nfs-架构&quot;&gt;NFS 架构&lt;/h4&gt;
&lt;p&gt;NFS 最基本的思想是允许任意选定的一些&lt;code&gt;客户端&lt;/code&gt;和&lt;code&gt;服务器&lt;/code&gt;共享一个公共文件系统。在许多情况下，所有的客户端和服务器都会在同一个 &lt;code&gt;LAN(Local Area Network)&lt;/code&gt; 局域网内共享，但是这并不是必须的。也可能是下面这样的情况：如果客户端和服务器距离较远，那么它们也可以在广域网上运行。客户端可以是服务器，服务器可以是客户端，但是为了简单起见，我们说的客户端就是消费服务，而服务器就是提供服务的角度来聊。&lt;/p&gt;
&lt;p&gt;每一个 NFS 服务都会导出一个或者多个目录供远程客户端访问。当一个目录可用时，它的所有子目录也可用。因此，通常整个目录树都会作为一个整体导出。服务器导出的目录列表会用一个文件来维护，这个文件是 &lt;code&gt;/etc/exports&lt;/code&gt;，当服务器启动后，这些目录可以自动的被导出。客户端通过挂载这些导出的目录来访问它们。当一个客户端挂载了一个远程目录，这个目录就成为客户端目录层次的一部分，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202010/1515111-20201010071010621-928986431.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这个示例中，一号客户机挂载到服务器的 bin 目录下，因此它现在可以使用 shell 访问 /bin/cat 或者其他任何一个目录。同样，客户机 1 也可以挂载到 二号服务器上从而访问 /usr/local/projects/proj1 或者其他目录。二号客户机同样可以挂载到二号服务器上，访问路径是 /mnt/projects/proj2。&lt;/p&gt;
&lt;p&gt;从上面可以看到，由于不同的客户端将文件挂载到各自目录树的不同位置，同一个文件在不同的客户端有不同的访问路径和不同的名字。挂载点一般通常在客户端本地，服务器不知道任何一个挂载点的存在。&lt;/p&gt;
&lt;h4 id=&quot;nfs-协议&quot;&gt;NFS 协议&lt;/h4&gt;
&lt;p&gt;由于 NFS 的协议之一是支持 &lt;code&gt;异构&lt;/code&gt; 系统，客户端和服务器可能在不同的硬件上运行不同的操作系统，因此有必要在服务器和客户端之间进行接口定义。这样才能让任何写一个新客户端能够和现有的服务器一起正常工作，反之亦然。&lt;/p&gt;
&lt;p&gt;NFS 就通过定义两个客户端 - 服务器协议从而实现了这个目标。协议就是客户端发送给服务器的一连串的请求，以及服务器发送回客户端的相应答复。&lt;/p&gt;
&lt;p&gt;第一个 NFS 协议是处理挂载。客户端可以向服务器发送路径名并且请求服务器是否能够将服务器的目录挂载到自己目录层次上。因为服务器不关心挂载到哪里，因此请求不会包含挂载地址。如果路径名是合法的并且指定的目录已经被导出，那么服务器会将文件 &lt;code&gt;句柄&lt;/code&gt; 返回给客户端。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;文件句柄包含唯一标识文件系统类型，磁盘，目录的i节点号和安全性信息的字段。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;随后调用读取和写入已安装目录或其任何子目录中的文件，都将使用文件句柄。&lt;/p&gt;
&lt;p&gt;当 Linux 启动时会在多用户之前运行 shell 脚本 /etc/rc 。可以将挂载远程文件系统的命令写入该脚本中，这样就可以在允许用户登陆之前自动挂载必要的远程文件系统。大部分 Linux 版本是支持&lt;code&gt;自动挂载&lt;/code&gt;的。这个特性会支持将远程目录和本地目录进行关联。&lt;/p&gt;
&lt;p&gt;相对于手动挂载到 /etc/rc 目录下，自动挂载具有以下优势&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果列出的 /etc/rc 目录下出现了某种故障，那么客户端将无法启动，或者启动会很困难、延迟或者伴随一些出错信息，如果客户根本不需要这个服务器，那么手动做了这些工作就白费了。&lt;/li&gt;
&lt;li&gt;允许客户端并行的尝试一组服务器，可以实现一定程度的容错率，并且性能也可以得到提高。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;另一方面，我们默认在自动挂载时所有可选的文件系统都是相同的。由于 NFS 不提供对文件或目录复制的支持，用户需要自己确保这些所有的文件系统都是相同的。因此，大部分的自动挂载都只应用于二进制文件和很少改动的只读的文件系统。&lt;/p&gt;
&lt;p&gt;第二个 NFS 协议是为文件和目录的访问而设计的。客户端能够通过向服务器发送消息来操作目录和读写文件。客户端也可以访问文件属性，比如文件模式、大小、上次修改时间。NFS 支持大多数的 Linux 系统调用，但是 open 和 close 系统调用却不支持。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;不支持 open 和 close 并不是一种疏忽，而是一种刻意的设计，完全没有必要在读一个文件之前对其进行打开，也没有必要在读完时对其进行关闭。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;NFS 使用了标准的 UNIX 保护机制，使用 &lt;code&gt;rwx&lt;/code&gt; 位来标示&lt;code&gt;所有者(owner)&lt;/code&gt;、&lt;code&gt;组(groups)&lt;/code&gt;、&lt;code&gt;其他用户&lt;/code&gt; 。最初，每个请求消息都会携带调用者的 groupId 和 userId，NFS 会对其进行验证。事实上，它会信任客户端不会发生欺骗行为。可以使用公钥密码来创建一个安全密钥，在每次请求和应答中使用它验证客户端和服务器。&lt;/p&gt;
&lt;h4 id=&quot;nfs-实现&quot;&gt;NFS 实现&lt;/h4&gt;
&lt;p&gt;即使客户端和服务器的代码实现是独立于 NFS 协议的，大部分的 Linux 系统会使用一个下图的三层实现，顶层是系统调用层，系统调用层能够处理 open 、 read 、 close 这类的系统调用。在解析和参数检查结束后调用第二层，&lt;code&gt;虚拟文件系统 (VFS)&lt;/code&gt; 层。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202010/1515111-20201010071022351-1336182104.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;VFS 层的任务是维护一个表，每个已经打开的文件都在表中有一个表项。VFS 层为每一个打开的文件维护着一个&lt;code&gt;虚拟i节点&lt;/code&gt; ，简称为 v - node。v 节点用来说明文件是本地文件还是远程文件。如果是远程文件的话，那么 v - node 会提供足够的信息使客户端能够访问它们。对于本地文件，会记录其所在的文件系统和文件的 i-node ，因为现代操作系统能够支持多文件系统。虽然 VFS 是为了支持 NFS 而设计的，但是现代操作系统都会使用 VFS，而不管有没有 NFS。&lt;/p&gt;
&lt;h2 id=&quot;linux-io&quot;&gt;Linux IO&lt;/h2&gt;
&lt;p&gt;我们之前了解过了 Linux 的进程和线程、Linux 内存管理，那么下面我们就来认识一下 Linux 中的 I/O 管理。&lt;/p&gt;
&lt;p&gt;Linux 系统和其他 UNIX 系统一样，IO 管理比较直接和简洁。所有 IO 设备都被当作&lt;code&gt;文件&lt;/code&gt;，通过在系统内部使用相同的 read 和 write 一样进行读写。&lt;/p&gt;
&lt;h3 id=&quot;linux-io-基本概念&quot;&gt;Linux IO 基本概念&lt;/h3&gt;
&lt;p&gt;Linux 中也有磁盘、打印机、网络等 I/O 设备，Linux 把这些设备当作一种 &lt;code&gt;特殊文件&lt;/code&gt; 整合到文件系统中，一般通常位于 &lt;code&gt;/dev&lt;/code&gt; 目录下。可以使用与普通文件相同的方式来对待这些特殊文件。&lt;/p&gt;
&lt;p&gt;特殊文件一般分为两种：&lt;/p&gt;
&lt;p&gt;块特殊文件是一个能存储&lt;code&gt;固定大小块&lt;/code&gt;信息的设备，它支持&lt;strong&gt;以固定大小的块，扇区或群集读取和（可选）写入数据&lt;/strong&gt;。每个块都有自己的&lt;code&gt;物理地址&lt;/code&gt;。通常块的大小在 512 - 65536 之间。所有传输的信息都会以&lt;code&gt;连续&lt;/code&gt;的块为单位。块设备的基本特征是每个块都较为对立，能够独立的进行读写。常见的块设备有 &lt;strong&gt;硬盘、蓝光光盘、USB 盘&lt;/strong&gt;与字符设备相比，块设备通常需要较少的引脚。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202010/1515111-20201010071057824-748483475.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;块特殊文件的缺点基于给定固态存储器的块设备比基于相同类型的存储器的字节寻址要慢一些，因为必须在块的开头开始读取或写入。所以，要读取该块的任何部分，必须寻找到该块的开始，读取整个块，如果不使用该块，则将其丢弃。要写入块的一部分，必须寻找到块的开始，将整个块读入内存，修改数据，再次寻找到块的开头处，然后将整个块写回设备。&lt;/p&gt;
&lt;p&gt;另一类 I/O 设备是&lt;code&gt;字符特殊文件&lt;/code&gt;。字符设备以&lt;code&gt;字符&lt;/code&gt;为单位发送或接收一个字符流，而不考虑任何块结构。字符设备是不可寻址的，也没有任何寻道操作。常见的字符设备有 &lt;strong&gt;打印机、网络设备、鼠标、以及大多数与磁盘不同的设备&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202010/1515111-20201010071104970-1808200664.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每个设备特殊文件都会和 &lt;code&gt;设备驱动&lt;/code&gt; 相关联。每个驱动程序都通过一个 &lt;code&gt;主设备号&lt;/code&gt; 来标识。如果一个驱动支持多个设备的话，此时会在主设备的后面新加一个 &lt;code&gt;次设备号&lt;/code&gt; 来标识。主设备号和次设备号共同确定了唯一的驱动设备。&lt;/p&gt;
&lt;p&gt;我们知道，在计算机系统中，CPU 并不直接和设备打交道，它们中间有一个叫作 &lt;code&gt;设备控制器（Device Control Unit）&lt;/code&gt;的组件，例如硬盘有磁盘控制器、USB 有 USB 控制器、显示器有视频控制器等。这些控制器就像代理商一样，它们知道如何应对硬盘、鼠标、键盘、显示器的行为。&lt;/p&gt;
&lt;p&gt;绝大多数字符特殊文件都不能随机访问，因为他们需要使用和块特殊文件不同的方式来控制。比如，你在键盘上输入了一些字符，但是你发现输错了一个，这时有一些人喜欢使用 &lt;code&gt;backspace&lt;/code&gt; 来删除，有人喜欢用 &lt;code&gt;del&lt;/code&gt; 来删除。为了中断正在运行的设备，一些系统使用 &lt;code&gt;ctrl-u&lt;/code&gt; 来结束，但是现在一般使用 &lt;code&gt;ctrl-c&lt;/code&gt; 来结束。&lt;/p&gt;
&lt;h3 id=&quot;网络&quot;&gt;网络&lt;/h3&gt;
&lt;p&gt;I/O 的另外一个概念是&lt;code&gt;网络&lt;/code&gt;， 也是由 UNIX 引入，网络中一个很关键的概念就是 &lt;code&gt;套接字(socket)&lt;/code&gt;。套接字允许用户连接到网络，正如邮筒允许用户连接到邮政系统，套接字的示意图如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202010/1515111-20201010071114282-954760377.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;套接字的位置如上图所示，套接字可以动态创建和销毁。成功创建一个套接字后，系统会返回一个&lt;code&gt;文件描述符(file descriptor)&lt;/code&gt;，在后面的创建链接、读数据、写数据、解除连接时都需要使用到这个文件描述符。每个套接字都支持一种特定类型的网络类型，在创建时指定。一般最常用的几种&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;可靠的面向连接的字节流&lt;/li&gt;
&lt;li&gt;可靠的面向连接的数据包&lt;/li&gt;
&lt;li&gt;不可靠的数据包传输&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;可靠的面向连接的字节流会使用&lt;code&gt;管道&lt;/code&gt; 在两台机器之间建立连接。能够保证字节从一台机器按照顺序到达另一台机器，系统能够保证所有字节都能到达。&lt;/p&gt;
&lt;p&gt;除了数据包之间的分界之外，第二种类型和第一种类型是类似的。如果发送了 3 次写操作，那么使用第一种方式的接受者会直接接收到所有字节；第二种方式的接受者会分 3 次接受所有字节。除此之外，用户还可以使用第三种即不可靠的数据包来传输，使用这种传输方式的优点在于高性能，有的时候它比可靠性更加重要，比如在流媒体中，性能就尤其重要。&lt;/p&gt;
&lt;p&gt;以上涉及两种形式的传输协议，即 &lt;code&gt;TCP&lt;/code&gt; 和 &lt;code&gt;UDP&lt;/code&gt;，TCP 是 &lt;code&gt;传输控制协议&lt;/code&gt;，它能够传输可靠的字节流。&lt;code&gt;UDP&lt;/code&gt; 是 &lt;code&gt;用户数据报协议&lt;/code&gt;，它只能够传输不可靠的字节流。它们都属于 TCP/IP 协议簇中的协议，下面是网络协议分层&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202010/1515111-20201010071122649-1704884232.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，TCP 、UDP 都位于网络层上，可见它们都把 IP 协议 即 &lt;code&gt;互联网协议&lt;/code&gt; 作为基础。&lt;/p&gt;
&lt;p&gt;一旦套接字在源计算机和目的计算机建立成功，那么两个计算机之间就可以建立一个链接。通信一方在本地套接字上使用 &lt;code&gt;listen&lt;/code&gt; 系统调用，它就会创建一个缓冲区，然后阻塞直到数据到来。另一方使用 &lt;code&gt;connect&lt;/code&gt; 系统调用，如果另一方接受 connect 系统调用后，则系统会在两个套接字之间建立连接。&lt;/p&gt;
&lt;p&gt;socket 连接建立成功后就像是一个管道，一个进程可以使用本地套接字的文件描述符从中读写数据，当连接不再需要的时候使用 &lt;code&gt;close&lt;/code&gt; 系统调用来关闭。&lt;/p&gt;
&lt;h3 id=&quot;linux-io-系统调用&quot;&gt;Linux I/O 系统调用&lt;/h3&gt;
&lt;p&gt;Linux 系统中的每个 I/O 设备都有一个&lt;code&gt;特殊文件(special file)&lt;/code&gt;与之关联，什么是特殊文件呢？&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;在操作系统中，特殊文件是一种在文件系统中与硬件设备相关联的文件。特殊文件也被称为 &lt;code&gt;设备文件(device file)&lt;/code&gt;。特殊文件的目的是将设备作为文件系统中的文件进行公开。特殊文件为硬件设备提供了借口，用于文件 I/O 的工具可以进行访问。因为设备有两种类型，同样特殊文件也有两种，即字符特殊文件和块特殊文件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于大部分 I/O 操作来说，只用合适的文件就可以完成，并不需要特殊的系统调用。然后，有时需要一些设备专用的处理。在 POSIX 之前，大多数 UNIX 系统会有一个叫做 &lt;code&gt;ioctl&lt;/code&gt; 的系统调用，它用于执行大量的系统调用。随着时间的发展，POSIX 对其进行了整理，把 ioctl 的功能划分为面向终端设备的独立功能调用，现在已经变成独立的系统调用了。&lt;/p&gt;
&lt;p&gt;下面是几个管理终端的系统调用&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;系统调用&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;tcgetattr&lt;/td&gt;
&lt;td&gt;获取属性&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;tcsetattr&lt;/td&gt;
&lt;td&gt;设置属性&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;cfgetispeed&lt;/td&gt;
&lt;td&gt;获取输入速率&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;cfgetospeed&lt;/td&gt;
&lt;td&gt;获取输出速率&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;cfsetispeed&lt;/td&gt;
&lt;td&gt;设置输入速率&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;cfsetospeed&lt;/td&gt;
&lt;td&gt;设置输出速率&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;linux-io-实现&quot;&gt;Linux IO 实现&lt;/h3&gt;
&lt;p&gt;Linux 中的 IO 是通过一系列设备驱动实现的，每个设备类型对应一个设备驱动。设备驱动为操作系统和硬件分别预留接口，通过设备驱动来屏蔽操作系统和硬件的差异。&lt;/p&gt;
&lt;p&gt;当用户访问一个特殊的文件时，由文件系统提供此特殊文件的主设备号和次设备号，并判断它是一个块特殊文件还是字符特殊文件。主设备号用于标识字符设备还是块设备，次设备号用于参数传递。&lt;/p&gt;
&lt;p&gt;每个&lt;code&gt;驱动程序&lt;/code&gt; 都有两部分：这两部分都是属于 Linux 内核，也都运行在内核态下。上半部分运行在调用者上下文并且与 Linux 其他部分交互。下半部分运行在内核上下文并且与设备进行交互。驱动程序可以调用内存分配、定时器管理、DMA 控制等内核过程。可被调用的内核功能都位于 &lt;code&gt;驱动程序 - 内核接口&lt;/code&gt; 的文档中。&lt;/p&gt;
&lt;p&gt;I/O 实现指的就是对字符设备和块设备的实现&lt;/p&gt;
&lt;h4 id=&quot;块设备实现&quot;&gt;块设备实现&lt;/h4&gt;
&lt;p&gt;系统中处理块特殊文件 I/O 部分的目标是为了使传输次数尽可能的小。为了实现这个目标，Linux 系统在磁盘驱动程序和文件系统之间设置了一个 &lt;code&gt;高速缓存(cache)&lt;/code&gt; ，如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202010/1515111-20201010071132785-923595724.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在 Linux 内核 2.2 之前，Linux 系统维护着两个缓存：&lt;code&gt;页面缓存(page cache)&lt;/code&gt; 和 &lt;code&gt;缓冲区缓存(buffer cache)&lt;/code&gt;，因此，存储在一个磁盘块中的文件可能会在两个缓存中。2.2 版本以后 Linux 内核只有一个统一的缓存一个 &lt;code&gt;通用数据块层(generic block layer)&lt;/code&gt; 把这些融合在一起，实现了磁盘、数据块、缓冲区和数据页之间必要的转换。那么什么是通用数据块层？&lt;/p&gt;
&lt;blockquote readability=&quot;16&quot;&gt;
&lt;p&gt;通用数据块层是一个内核的组成部分，用于处理对系统中所有块设备的请求。通用数据块主要有以下几个功能&lt;/p&gt;
&lt;p&gt;将数据缓冲区放在内存高位处，当 CPU 访问数据时，页面才会映射到内核线性地址中，并且此后取消映射&lt;/p&gt;
&lt;p&gt;实现 &lt;code&gt;零拷贝&lt;/code&gt;机制，磁盘数据可以直接放入用户模式的地址空间，而无需先复制到内核内存中&lt;/p&gt;
&lt;p&gt;管理磁盘卷，会把不同块设备上的多个磁盘分区视为一个分区。&lt;/p&gt;
&lt;p&gt;利用最新的磁盘控制器的高级功能，例如 DMA 等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;cache 是提升性能的利器，不管以什么样的目的需要一个数据块，都会先从 cache 中查找，如果找到直接返回，避免一次磁盘访问，能够极大的提升系统性能。&lt;/p&gt;
&lt;p&gt;如果页面 cache 中没有这个块，操作系统就会把页面从磁盘中调入内存，然后读入 cache 进行缓存。&lt;/p&gt;
&lt;p&gt;cache 除了支持读操作外，也支持写操作，一个程序要写回一个块，首先把它写到 cache 中，而不是直接写入到磁盘中，等到磁盘中缓存达到一定数量值时再被写入到 cache 中。&lt;/p&gt;
&lt;p&gt;Linux 系统中使用 &lt;code&gt;IO 调度器&lt;/code&gt; 来保证减少磁头的反复移动从而减少损失。I/O 调度器的作用是对块设备的读写操作进行排序，对读写请求进行合并。Linux 有许多调度器的变体，从而满足不同的工作需要。最基本的 Linux 调度器是基于传统的 &lt;code&gt;Linux 电梯调度器(Linux elevator scheduler)&lt;/code&gt;。Linux 电梯调度器的主要工作流程就是按照磁盘扇区的地址排序并存储在一个&lt;code&gt;双向链表&lt;/code&gt; 中。新的请求将会以链表的形式插入。这种方法可以有效的防止磁头重复移动。因为电梯调度器会容易产生饥饿现象。因此，Linux 在原基础上进行了修改，维护了两个链表，在 &lt;code&gt;最后日期(deadline)&lt;/code&gt; 内维护了排序后的读写操作。默认的读操作耗时 0.5s，默认写操作耗时 5s。如果在最后期限内等待时间最长的链表没有获得服务，那么它将优先获得服务。&lt;/p&gt;
&lt;h4 id=&quot;字符设备实现&quot;&gt;字符设备实现&lt;/h4&gt;
&lt;p&gt;和字符设备的交互是比较简单的。由于字符设备会产生并使用字符流、字节数据，因此对随机访问的支持意义不大。一个例外是使用 &lt;code&gt;行规则(line disciplines)&lt;/code&gt;。一个行规可以和终端设备相关联，使用 &lt;code&gt;tty_struct&lt;/code&gt; 结构来表示，它表示与终端设备交换数据的解释器，当然这也属于内核的一部分。例如：行规可以对行进行编辑，映射回车为换行等一系列其他操作。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;什么是行规则？&lt;/p&gt;
&lt;p&gt;行规是某些类 UNIX 系统中的一层，终端子系统通常由三层组成：上层提供字符设备接口，下层硬件驱动程序与硬件或伪终端进行交互，中层规则用于实现终端设备共有的行为。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202010/1515111-20201010071143027-930505229.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;网络设备实现&quot;&gt;网络设备实现&lt;/h4&gt;
&lt;p&gt;网络设备的交互是不一样的，虽然 &lt;code&gt;网络设备(network devices)&lt;/code&gt; 也会产生字符流，因为它们的&lt;code&gt;异步(asynchronous)&lt;/code&gt; 特性是他们不易与其他字符设备在同一接口下集成。网络设备驱动程序会产生很多数据包，经由网络协议到达用户应用程序中。&lt;/p&gt;
&lt;h3 id=&quot;linux-中的模块&quot;&gt;Linux 中的模块&lt;/h3&gt;
&lt;p&gt;UNIX 设备驱动程序是被&lt;code&gt;静态加载&lt;/code&gt;到内核中的。因此，只要系统启动后，设备驱动程序都会被加载到内存中。随着个人电脑 Linux 的出现，这种静态链接完成后会使用一段时间的模式被打破。相对于小型机上的 I/O 设备，PC 上可用的 I/O 设备有了数量级的增长。绝大多数用户没有能力去添加一个新的应用程序、更新设备驱动、重新连接内核，然后进行安装。&lt;/p&gt;
&lt;p&gt;Linux 为了解决这个问题，引入了 &lt;code&gt;可加载(loadable module)&lt;/code&gt; 机制。可加载是在系统运行时添加到内核中的代码块。&lt;/p&gt;
&lt;p&gt;当一个模块被加载到内核时，会发生下面几件事情：第一，在加载的过程中，模块会被动态的重新部署。第二，系统会检查程序程序所需的资源是否可用。如果可用，则把这些资源标记为正在使用。第三步，设置所需的中断向量。第四，更新驱动转换表使其能够处理新的主设备类型。最后再来运行设备驱动程序。&lt;/p&gt;
&lt;p&gt;在完成上述工作后，驱动程序就会安装完成，其他现代 UNIX 系统也支持可加载机制。&lt;/p&gt;
&lt;h2 id=&quot;linux-安全&quot;&gt;Linux 安全&lt;/h2&gt;
&lt;p&gt;Linux 作为 MINIX 和 UNIX 的衍生操作系统，从一开始就是一个&lt;code&gt;多用户&lt;/code&gt;系统。这意味着 Linux 从早期开始就建立了安全和信息访问控制机制。下面我们主要探讨的就是 Linux 安全性的一些内容&lt;/p&gt;
&lt;h3 id=&quot;linux-安全基本概念&quot;&gt;Linux 安全基本概念&lt;/h3&gt;
&lt;p&gt;一个 Linux 系统的用户群里由一系列注册用户组成，他们每一个都有一个唯一的 UID (User ID)。一个 UID 是一个位于 0 到 65535 之间的整数。文件（进程或者是其他资源）都标记了它的所有者的 UID。默认情况下，文件的所有者是创建文件的人，文件的所有者是创建文件的用户。&lt;/p&gt;
&lt;p&gt;用户可以被分成许多组，每个组都会由一个 16 位的整数标记，这个组叫做 &lt;code&gt;GID(组 ID)&lt;/code&gt;。给用户分组是手动完成的，它由系统管理员执行，分组就是在数据库中添加一条记录指明哪个用户属于哪个组。一个用户可以属于不同组。&lt;/p&gt;
&lt;p&gt;Linux 中的基本安全机制比较容易理解，每个进程都会记录它所有者的 UID 和 GID。当文件创建后，它会获取创建进程的 UID 和 GID。当一个文件被创建时，它的 UID 和 GID 就会被标记为进程的 UID 和 GID。这个文件同时会获取由该进程决定的一些权限。这些权限会指定所有者、所有者所在组的其他用户及其他用户对文件具有什么样的访问权限。对于这三类用户而言，潜在的访问权限是 &lt;strong&gt;读、写和执行&lt;/strong&gt;，分别由 r、w 和 x 标记。当然，执行文件的权限仅当文件时可逆二进制程序时才有意义。试图执行一个拥有执行权限的非可执行文件，系统会报错。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Linux 用户分为三种&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;root（超级管理员）&lt;/code&gt;，它的 UID 为 0，这个用户有极大的权限，可以直接无视很多的限制 ，包括读写执行的权限。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;系统用户&lt;/code&gt;，UID 为 1～499。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;普通用户&lt;/code&gt;，UID 范围一般是 500～65534。这类用户的权限会受到基本权限的限制，也会受到来自管理员的限制。不过要注意 nobody 这个特殊的帐号，UID 为 65534，这个用户的权限会进一步的受到限制，一般用于实现来宾帐号。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Linux 中的每类用户由 3 个比特为来标记，所以 9 个比特位就能够表示所有的权限。&lt;/p&gt;
&lt;p&gt;下面来看一下一些基本的用户和权限例子&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;二进制&lt;/th&gt;
&lt;th&gt;标记&lt;/th&gt;
&lt;th&gt;准许的文件访问权限&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;7&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;111000000&lt;/td&gt;
&lt;td&gt;rwx------&lt;/td&gt;
&lt;td&gt;所有者可读、写和执行&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;111111000&lt;/td&gt;
&lt;td&gt;rwxrwx---&lt;/td&gt;
&lt;td&gt;所有者和组可以读、写和执行&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;111111111&lt;/td&gt;
&lt;td&gt;rwxrwxrwx&lt;/td&gt;
&lt;td&gt;所有人可以读、写和执行&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;000000000&lt;/td&gt;
&lt;td&gt;---------&lt;/td&gt;
&lt;td&gt;任何人不拥有任何权限&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;000000111&lt;/td&gt;
&lt;td&gt;------rwx&lt;/td&gt;
&lt;td&gt;只有组以外的其他用户拥有所有权&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;110100100&lt;/td&gt;
&lt;td&gt;rw-r--r--&lt;/td&gt;
&lt;td&gt;所有者可以读和写，其他人可以读&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;110100100&lt;/td&gt;
&lt;td&gt;rw-r-----&lt;/td&gt;
&lt;td&gt;所有者可以读和写，组可以读&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;我们上面提到，UID 为 0 的是一个特殊用户，称为 &lt;code&gt;超级用户(或者根用户)&lt;/code&gt;。超级用户能够读和写系统中的任何文件，不管这个文件由谁所有，也不管这个文件的保护模式如何。 UID 为 0 的进程还具有少数调用受保护系统调用的权限，而普通用户是不可能有这些功能的。通常情况下，只有系统管理员知道超级用户的密码。&lt;/p&gt;
&lt;p&gt;在 Linux 系统下，目录也是一种文件，并且具有和普通文件一样的保护模式。不同的是，目录的 x 比特位表示查找权限而不是执行权限。因此，如果一个目录的保护模式是 &lt;code&gt;rwxr-xr-x&lt;/code&gt;，那么它允许所有者读、写和查找目录，而其他人只可以读和查找，而不允许从中添加或者删除目录中的文件。&lt;/p&gt;
&lt;p&gt;与 I/O 有关的特殊文件拥有和普通文件一样的保护位。这种机制可以用来限制对 I/O 设备的访问权限。举个例子，打印机是特殊文件，它的目录是 &lt;code&gt;/dev/lp&lt;/code&gt;，它可以被根用户或者一个叫守护进程的特殊用户拥有，具有保护模式 rw-------，从而阻止其他所有人对打印机的访问。毕竟每个人都使用打印机的话会发生混乱。&lt;/p&gt;
&lt;p&gt;当然，如果 /dev/lp 的保护模式是 rw-------，那就意味着其他任何人都不能使用打印机。&lt;/p&gt;
&lt;p&gt;这个问题通过增加一个保护位 &lt;code&gt;SETUID&lt;/code&gt; 到之前的 9 个比特位来解决。当一个进程的 SETUID 位打开，它的 &lt;code&gt;有效 UID&lt;/code&gt; 将变成相应可执行文件的所有者 UID，而不是当前使用该进程的用户的 UID。将访问打印机的程序设置为守护进程所有，同时打开 SETUID 位，这样任何用户都可以执行此程序，而且拥有守护进程的权限。&lt;/p&gt;
&lt;p&gt;除了 SETUID 之外，还有一个 SETGID 位，SETGID 的工作原理和 SETUID 类似。但是这个位一般很不常用。&lt;/p&gt;
&lt;h3 id=&quot;linux-安全相关的系统调用&quot;&gt;Linux 安全相关的系统调用&lt;/h3&gt;
&lt;p&gt;Linux 中关于安全的系统调用不是很多，只有几个，如下列表所示&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;系统调用&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;chmod&lt;/td&gt;
&lt;td&gt;改变文件的保护模式&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;access&lt;/td&gt;
&lt;td&gt;使用真实的 UID 和 GID 测试访问权限&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;chown&lt;/td&gt;
&lt;td&gt;改变所有者和组&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;setuid&lt;/td&gt;
&lt;td&gt;设置 UID&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;setgid&lt;/td&gt;
&lt;td&gt;设置 GID&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;getuid&lt;/td&gt;
&lt;td&gt;获取真实的 UID&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;getgid&lt;/td&gt;
&lt;td&gt;获取真实的 GID&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;geteuid&lt;/td&gt;
&lt;td&gt;获取有效的 UID&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;getegid&lt;/td&gt;
&lt;td&gt;获取有效的 GID&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;我们在日常开发中用到最多的就是 &lt;code&gt;chmod&lt;/code&gt;了，没想到我们日常开发过程中也能用到系统调用啊，chmod 之前我们一直认为是改变权限，现在专业一点是改变文件的保护模式。它的具体函数如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;s = chmod(&quot;路径名&quot;,&quot;值&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例如&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;s = chmod(&quot;/usr/local/cxuan&quot;,777);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;他就是会把 &lt;code&gt;/usr/local/cxuan&lt;/code&gt; 这个路径的保护模式改为 rwxrwxrwx，任何组和人都可以操作这个路径。只有该文件的所有者和超级用户才有权利更改保护模式。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;access&lt;/code&gt; 系统调用用来检验实际的 UID 和 GID 对某文件是否拥有特定的权限。下面就是四个 getxxx 的系统调用，这些用来获取 uid 和 gid 的。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：其中的 chown、setuid 和 setgid 是超级用户才能使用，用来改变所有者进程的 UID 和 GID。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;linux-安全实现&quot;&gt;Linux 安全实现&lt;/h3&gt;
&lt;p&gt;当用户登录时，登录程序，也被称为 &lt;code&gt;login&lt;/code&gt;，会要求输入用户名和密码。它会对密码进行哈希处理，然后在 &lt;code&gt;/etc/passwd&lt;/code&gt; 中进行查找，看看是否有匹配的项。使用哈希的原因是防止密码在系统中以非加密的方式存在。如果密码正确，登录程序会在 /etc/passwd 中读取用户选择的 shell 程序的名称，有可能是 &lt;code&gt;bash&lt;/code&gt;，有可能是 &lt;code&gt;shell&lt;/code&gt; 或者其他的 &lt;code&gt;csh&lt;/code&gt; 或 &lt;code&gt;ksh&lt;/code&gt;。然后登录程序使用 setuid 和 setgid 这两个系统调用来把自己的 UID 和 GID 变为用户的 UID 和 GID，然后它打开键盘作为标准输入、标准输入的文件描述符是 0 ，屏幕作为标准输出，文件描述符是 1 ，屏幕也作为标准错误输出，文件描述符为 2。最后，执行用户选择的 shell 程序，终止。&lt;/p&gt;
&lt;p&gt;当任何进程想要打开一个文件，系统首先将文件的 i - node 所记录的保护位与用户有效 UID 和 有效 GID 进行对比，来检查访问是否允许。如果访问允许，就打开文件并返回文件描述符；否则不打开文件，返回 - 1。&lt;/p&gt;
&lt;p&gt;Linux 安全模型和实现在本质上与大多数传统的 UNIX 系统相同。&lt;/p&gt;
&lt;p&gt;关注公众号 程序员cxuan 回复 cxuan 领取优质资料。&lt;/p&gt;
&lt;p&gt;我自己写了六本 PDF ，非常硬核，链接如下&lt;/p&gt;
&lt;p&gt;我自己写了六本 PDF ，非常硬核，链接如下&lt;/p&gt;
&lt;p&gt;我自己写了六本 PDF ，非常硬核，链接如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202009/1515111-20200928073258556-2142265096.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI0ODk2NDIyMQ==&amp;amp;mid=2247485329&amp;amp;idx=1&amp;amp;sn=673f306bb229e73e8f671443488b42d4&amp;amp;chksm=e999f283deee7b95a3cce247907b6557bf5f228c85434fc6cbadf42b2ec4c64443742a8bea7a&amp;amp;token=581641926&amp;amp;lang=zh_CN#rd&quot;&gt;cxuan 呕心沥血肝了四本 PDF。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU2NDg0OTgyMA==&amp;amp;mid=2247494165&amp;amp;idx=1&amp;amp;sn=4e0247006bef89701529d765e6ce32a4&amp;amp;chksm=fc4617e6cb319ef0991ff70c8a769b92f59cf92122f27785b848604493653fdcc206d6830a23&amp;amp;token=794467841&amp;amp;lang=zh_CN#rd&quot;&gt;cxuan 又肝了两本 PDF。&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 09 Oct 2020 23:13:00 +0000</pubDate>
<dc:creator>程序员cxuan</dc:creator>
<og:description>Linux 简介 UNIX 是一个交互式系统，用于同时处理多进程和多用户同时在线。为什么要说 UNIX，那是因为 Linux 是由 UNIX 发展而来的，UNIX 是由程序员设计，它的主要服务对象也是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cxuanBlog/p/13789900.html</dc:identifier>
</item>
<item>
<title>你知道CPU结构也会影响Redis性能吗？ - _BKing</title>
<link>http://www.cnblogs.com/xiaowei123/p/13789806.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaowei123/p/13789806.html</guid>
<description>&lt;p&gt;啦啦啦，我是卖身不卖艺的二哈，ε=(´ο｀*)))唉错啦（我是开车的二哈），我又来了，铁子们一起开车呀！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;今天来分析下CPU结构对Redis性能会有影响吗？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在进行Redis性能分析的时候，通常我们会考虑下面这些方面，如：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;1. 缩短 key 的长度&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;strong&gt;2. 禁止使用 keys *&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;   　我们都知道 keys *， 在使用的时候 Redis 会处于阻塞状态，导致其它任何命令在你的 Redis 实例中都无法执行。这个情况在 Redis 数据量大的时候就很明显，严重影响系统的运行。（一般我们用 scan 来代替）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　3. 进行数据压缩&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　在把数据存入 Redis 中，我们一般不会使用完整全名的数据，一般会进行适当的数据压缩，这样可以提高 Redis 性能，方便我们数据的储存。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　4. 设置过期时间&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　我们对一些不是永久性需要的数据，可以进行键的过期时间设置，这样到时间后，数据就会自动清除，节省我们 Redis 存储空间（内存）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　5. 使用回收策略&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　为数据设置相关的过期回收策略，节省内存的开销，提高 Redis 运行的性能。（ Redis 目前有8种回收策略，有兴趣可以查看 redis.conf ，多了LFU）。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;6. 适当使用 bit （位图）&lt;/strong&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　适当使用 bit，可节省我们 Redis 存储的成本，即内存的大小。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;7. 对所存储的数据字段进行优化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　如：我们只需要在 Redis 存储关键信息即可，详细信息存储到磁盘上即可。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;8. 使用管道进行数据操作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　对于命令执行操作，我们要使用管道 pipeline，这样可以节省 Redis 传输过程的成本，提高 Redis 的性能。我们知道如果不适用管道，命令是一个一个进行操作，如果我们加上管道，这样由原来的单条命令变成多条命令进行传输操作，节省多次传输过程的网络开销。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;N .... (还有很多很多~~)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;但是，我们可能有时候会真正忽略 Redis 运行的前提条件，单核 CPU 和多核 CPU 对 Redis 性能影响也是相差甚远。在计算机组成原理中，我们都知道 CPU 是计算机的核心构成之一，中央处理器（Central Processing Unit），是计算机系统的运算和控制中心。一个CPU处理器中一般包含有多个运行核心（物理核），运行核心我们也叫作物理核，一般包含一级缓存（L1 Cache）和二级缓存（L2 Cache）。其架构图如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1323607/202010/1323607-20201009235632389-674807903.png&quot; alt=&quot;&quot; width=&quot;715&quot; height=&quot;379&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 对于 L1 缓存和 L2 缓存，在每个物理核上都是独自拥有的，访问速度非常快，基本都在 ns 级别。我们设想如果把数据运行的指令放在这两个缓存上，那么可以大大提高计算机的访问性能。这样我们可以设想这样一个情形：&lt;/p&gt;
&lt;p&gt;　　如果，我们把 Redis 实例的数据和指令绑定到一个 CPU 核上，那么当 Redis 频繁执行数据访问和操作时，都是基于CPU 上的缓存进行操作，那么性能是不是大大的提高了，没错，事实就是如此。但是，我们电脑一般都是多核 CPU 的，在进行数据访问和操作时，系统不会只有一个线程在进行操作，是有很多很多的线程在同时进行操作，会同时操作我们的CPU，也就是我们所说的多线程操作CPU。如果一个线程此时在CPU1上运行，后来又跑到了CPU2上运行，这时在CPU1上保留的数据和指令不在CPU2，这时要重新进行数据加载，会降低线程执行的效率，上述所发生的过程，我们也叫作上下文切换，这在操作系统内核环境下，是很常见的现象。&lt;/p&gt;
&lt;p&gt;　　所以，我们要避免线程来回在CPU上进行切换，导致指令和数据进行多次加载，增加锁处理的时间。我们从CPU结构出发，如果在多核CPU上，如果我们的每个Redis实例都只在一个CPU上运行的话，那么我们离解决问题的步伐是不是又更近了一步。（问题都是一步一步的剖析，慢慢解开其真容(*╹▽╹*)）。&lt;/p&gt;
&lt;p&gt;对相关进程进行绑定，我们可以使用  &lt;span class=&quot;cnblogs_code&quot;&gt;taskset&lt;/span&gt; ：&lt;/p&gt;
&lt;p&gt;　　taskset 是依据线程PID（TID）查询或设置线程的CPU亲和性（Affiliation）（与哪个CPU核心绑定）。&lt;/p&gt;
&lt;p&gt;如果有伙伴们不知道 taskset 如何使用，没关系，可以使用 man 或者 help 手册进行查看相关参数使用（  &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;man&lt;/span&gt; taskset&lt;/span&gt; &lt;span&gt; 或 &lt;span class=&quot;cnblogs_code&quot;&gt;taskset -h&lt;/span&gt; &lt;/span&gt;）。在进行绑定的时候，我们要知道自己机器的CPU的核数（ &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;cat&lt;/span&gt; /proc/cpuinfo&lt;/span&gt; ），以方便我们准确的进行CPU绑定，不会说不知道自己CPU核数随便绑定一个超过自己CPU核数的数。&lt;/p&gt;
&lt;p&gt;例子：假如我们要绑定CPU0这个CPU核，那么命令如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
taskset -c &lt;span&gt;0 &lt;/span&gt;./redis-server
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这时，我们可以通过 Redis 的压测工具进行相关测试 &lt;span class=&quot;cnblogs_code&quot;&gt;redis-benchmark&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;例如：对 GET 、PUT 和 SET 进行测试：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre readability=&quot;5&quot;&gt;
redis-benchmark -h &lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt; -p &lt;span&gt;6379&lt;/span&gt; -c &lt;span&gt;50&lt;/span&gt; -n &lt;span&gt;10000&lt;/span&gt; -t get&lt;p&gt;redis-benchmark -h &lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt; -p &lt;span&gt;6379&lt;/span&gt; -c &lt;span&gt;50&lt;/span&gt; -n &lt;span&gt;10000&lt;/span&gt; -t put&lt;/p&gt;&lt;/pre&gt;
&lt;pre&gt;
redis-benchmark -h &lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt; -p &lt;span&gt;6379&lt;/span&gt; -c &lt;span&gt;50&lt;/span&gt; -n &lt;span&gt;10000&lt;/span&gt; -t set
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以发现Redis实例的性能大大提升。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; Redis实例还可以和网络中断程序绑在 CPU Socket 上，这样能减小Redis 跨 Socket 访问内存的网络开销。（在网络传输过程中，这也是一个非常值得考虑优化的问题）。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里或许会有伙伴会问了（一个cpu物理核内部不是还有逻辑核吗，我们不应该绑定在逻辑核上吗？）&lt;/p&gt;
&lt;p&gt;这个小伙伴思考的好！别急，我先给你们维基百科（面向搜索引擎）下这些知识点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;CPU：中央处理单元，记住：&lt;span&gt;CPU不等于物理核，也不等于逻辑核&lt;/span&gt;。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;物理核： 真实的cpu核，可以单独执行指令，由独立电路元件实体以及L1、&lt;/span&gt;&lt;span&gt;L2缓存构成。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;逻辑核（LCPU）：在一个物理核内，逻辑层面的核。（内部物理核通过高速运算诞生的概念）。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;超线程(HT)：超线程可以在一个逻辑核等待指令执行的间隔(等待从cache或内存中获取下一条指令)，把时间片分配到另一个逻辑核。高速在这两个逻辑核之间切换，让应用程序感知不到这个间隔，误认为自己是独占了一个核。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;注意啦！！这里里面的三角关系：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一个CPU可以有多个物理核。但是如果操作系统开启了超线程，一个物理核可以分成 n 个逻辑核，n为超线程的数量。（分身）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;来让我们看看单核CPU的草图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1323607/202010/1323607-20201010011432733-2015929052.png&quot; alt=&quot;&quot; width=&quot;358&quot; height=&quot;245&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 我们可以从上图看出，一个CPU核内在没有开启超线程的时候 ，内部是有两个逻辑核的，但是为什么我们不把 Redis 实例绑定在其中一个逻辑核上，而是绑定在它们的物理核上呢？把 Redis实例绑定在一个物理核上，可以让该实例的主进程、子进程、后台线程都共享这个物理核内的两个逻辑核，这样可以使这些线程和进程不必只争抢一个逻辑核，一定程度上避免的CPU竞争。（因为内部有两个供他们选择使用，不会只因为使用一个而来回切换）。&lt;/p&gt;
&lt;p&gt;以上这些操作，都是小小的起步，如果我们还需要进一步提升Redis性能，我们需要从源码程度去解读Redis，深入研究，在必要时刻我们可以修改Redis的源码，从根源上寻找适合当前问题最佳扳手。&lt;/p&gt;

&lt;p&gt;二哈，今天的分享就到这里啦~~，下次再见，铁子们~&lt;/p&gt;
&lt;p&gt;如果觉得本文还不错，记得帮忙三连下，让更多的伙伴一起上车，启动我们的二哈旅行车(*^▽^*)，Thanks♪(･ω･)ﾉ。&lt;/p&gt;

&lt;p&gt;空间（内存）。&lt;/p&gt;
</description>
<pubDate>Fri, 09 Oct 2020 17:31:00 +0000</pubDate>
<dc:creator>_BKing</dc:creator>
<og:description>啦啦啦，我是卖身不卖艺的二哈，ε=(&amp;#180;ο｀*)))唉错啦（我是开车的二哈），我又来了，铁子们一起开车呀！ 今天来分析下CPU结构对Redis性能会有影响吗？ 在进行Redis性能分析的时候，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiaowei123/p/13789806.html</dc:identifier>
</item>
<item>
<title> 程序员你是如何使用Nacos作为配置中心的？ - 李福春</title>
<link>http://www.cnblogs.com/snidget/p/13789640.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/snidget/p/13789640.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/268922/202010/268922-20201009234957286-366094551.jpg&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;假如你使用的是spring-cloud-alibaba微服务技术栈&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;即去除应用程序的状态，配置统一外部化管理，方便进行水平的伸缩。&lt;/p&gt;
&lt;p&gt;集成步骤：&lt;/p&gt;
&lt;p&gt;假如我有一个应用app-design;&lt;/p&gt;
&lt;p&gt;1，引入依赖：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;dependency&amp;gt;
     &amp;lt;groupId&amp;gt;com.alibaba.cloud&amp;lt;/groupId&amp;gt;
     &amp;lt;artifactId&amp;gt;spring-cloud-starter-alibaba-nacos-config&amp;lt;/artifactId&amp;gt;
     &amp;lt;version&amp;gt;2.2.1.RELEASE&amp;lt;/version&amp;gt;
 &amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2, 配置文件；&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;spring.cloud.nacos.config.enabled=true
spring.cloud.nacos.config.refresh-enabled=true

spring.cloud.nacos.config.server-addr=${spring.cloud.nacos.discovery.server-addr}
spring.cloud.nacos.config.namespace=${spring.cloud.nacos.discovery.namespace}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;说明如下：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;spring.cloud.nacos.config.server-addr=${spring.cloud.nacos.discovery.server-addr}&lt;/td&gt;
&lt;td&gt;nacos配置中心地址&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;spring.cloud.nacos.config.namespace=${spring.cloud.nacos.discovery.namespace}&lt;/td&gt;
&lt;td&gt;nacos的命名空间，这里跟服务发现的配置一致；&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;3，使用配置的方式，同本地配置文件一样。&lt;/p&gt;
&lt;p&gt;@Value @PropertyConfiguration 这些注解都是支持的；&lt;/p&gt;
&lt;p&gt;4，确认方式，比如把之前的application.properties的配置放到了配置中心；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/268922/202010/268922-20201009234957697-1783037964.png&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本地启动的时候，读取到了8081端口和数据库连接池的配置；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/268922/202010/268922-20201009235006569-1599946998.png&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;配置中心的连接原理，后面单独整理出来，知其然并知其所以然。&lt;/p&gt;

&lt;p&gt;场景：多个后端微服务，在同一个集群中共用中间件的配置信息。&lt;/p&gt;
&lt;p&gt;比如 缓存redis, 消息队列kafka, 文件服务器， 邮件服务器；&lt;/p&gt;
&lt;p&gt;那么对应的配置文件没有必要在所有的后端微服务中单独存在，这些配置文件应该放在公共配置文件中，但是也可以被具体的后端微服务自己的独有配置文件覆盖，使用自己的私有配置；&lt;/p&gt;
&lt;p&gt;可结合下图理解：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/268922/202010/268922-20201009235007691-1654129973.svg+xml&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;问题&lt;/th&gt;
&lt;th&gt;回答&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;4.5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;where are we?现状&lt;/td&gt;
&lt;td&gt;中间件配置分散在很多服务中，配置繁琐，不方便统一管理&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;where are we go?目的&lt;/td&gt;
&lt;td&gt;同一个集群的中间件只维护一份，各服务共享，也可按照需要覆盖共享的配置；&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;how can we go there?实现路径&lt;/td&gt;
&lt;td&gt;基于nacos已有功能实现&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;下面是实际的coding过程和测试用例；&lt;/p&gt;
&lt;p&gt;服务app-file;&lt;/p&gt;
&lt;p&gt;在服务对应的nacos的namespace中&lt;/p&gt;
&lt;h2 id=&quot;1-引入共享配置&quot;&gt;1 引入共享配置&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;#共享中间件的配置
spring.cloud.nacos.config.shared-configs[0].data-id=mid.properties
spring.cloud.nacos.config.shared-configs[0].group=DEFAULT_GROUP
spring.cloud.nacos.config.shared-configs[0].refresh=true
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;位置： 模块start下的src/main/resources/bootstrap.properties文件中&lt;/p&gt;
&lt;p&gt;自描述的配置信息，即引入的共享配置文件列表有哪些，可以按照需要，配置各种中间件的配置信息；&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;key&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;data-id&lt;/td&gt;
&lt;td&gt;_the data id of extended configuration 配置文件名称，带上后缀；翻译：扩展配置文件的数据id&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;group&lt;/td&gt;
&lt;td&gt;_the group of extended configuration, the default value is DEFAULT_GROUP 集群名称， 从名字来看，支持多集群的配置文件 翻译：扩展配置文件的集群，默认值是 &lt;em&gt;DEFAULT_GROUP&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;refresh&lt;/td&gt;
&lt;td&gt;_whether to support dynamic refresh, the default does not support 是否刷新 翻译：是否支持动态刷新，默认不支持&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;花括号[0] ,里面的0是序号，如果有多个，按照数字自增顺序进行配置；&lt;/p&gt;
&lt;h2 id=&quot;2-在nacos中新增配置文件&quot;&gt;2 在nacos中新增配置文件&lt;/h2&gt;
&lt;p&gt;根据实际场景在nacos的test命名空间中新增配置文件mid.properties&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/268922/202010/268922-20201009235008032-1384534892.png&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;3-获取配置用例测试&quot;&gt;3 获取配置用例测试&lt;/h2&gt;
&lt;p&gt;测试接口代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt; @ApiOperation(&quot;测试获取公共配置文件&quot;)
    @GetMapping(&quot;/config/test&quot;)
    public Response config(){
        String redisConfigServers = environment.getProperty(&quot;redis.config.servers&quot;,&quot;null&quot;);
        return SingleResponse.of(redisConfigServers);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试用例：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;场景&lt;/th&gt;
&lt;th&gt;期望结果&lt;/th&gt;
&lt;th&gt;实际结果&lt;/th&gt;
&lt;th&gt;是否符合预期&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;6.5&quot;&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;获取共享配置文件中的配置&lt;/td&gt;
&lt;td&gt;r-wz9sp7dhxjnz16bs1jzhutj.redis.rds.aliyuncs.com:6379&lt;/td&gt;
&lt;td&gt;r-wz9sp7dhxjnz16bs1jzhutj.redis.rds.aliyuncs.com:6379&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td&gt;在服务独有app-file.properties配置中重写配置redis.config.servers=r-wz9sp7dhxjnz16bs1jzhutj.redis.rds.aliyuncs.com:637905&lt;/td&gt;
&lt;td&gt;r-wz9sp7dhxjnz16bs1jzhutj.redis.rds.aliyuncs.com:637905&lt;/td&gt;
&lt;td&gt;r-wz9sp7dhxjnz16bs1jzhutj.redis.rds.aliyuncs.com:637905&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;截图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/268922/202010/268922-20201009235008398-1947104286.png&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/268922/202010/268922-20201009235008674-698714325.png&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/268922/202010/268922-20201009235008921-604219324.png&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;掌握用法之后，深入分析源码，知其然而知其所以然；&lt;/p&gt;
&lt;h2 id=&quot;starter调用封装&quot;&gt;starter调用封装&lt;/h2&gt;
&lt;p&gt;使用的starter封装；&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/alibaba/spring-cloud-alibaba/spring-cloud-alibaba-starters/spring-cloud-starter-alibaba-nacos-config&quot;&gt;https://github.com/alibaba/spring-cloud-alibaba/spring-cloud-alibaba-starters/spring-cloud-starter-alibaba-nacos-config&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;版本： 2.2.1.RELEASE&lt;/p&gt;
&lt;p&gt;启动的时候自动装配的配置如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;org.springframework.cloud.bootstrap.BootstrapConfiguration=\
com.alibaba.cloud.nacos.NacosConfigBootstrapConfiguration

org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
com.alibaba.cloud.nacos.NacosConfigAutoConfiguration,\
com.alibaba.cloud.nacos.endpoint.NacosConfigEndpointAutoConfiguration

org.springframework.boot.diagnostics.FailureAnalyzer=\
com.alibaba.cloud.nacos.diagnostics.analyzer.NacosConnectionFailureAnalyzer
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;分解一下key，看一下用途：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;key&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;org.springframework.cloud.bootstrap.BootstrapConfiguration&lt;/td&gt;
&lt;td&gt;&lt;em&gt;A marker interface used as a key in &lt;code&gt;META-INF/spring.factories&lt;/code&gt;. Entries in* the factories file are used to create the bootstrap application context.&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;em&gt;翻译：一个标记注解用来作为key 放在META-INF/spring.factories文件中，文件中的条目用来创建启动应用的上下文；&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;来源：spring-cloud-context-version.jar&lt;/p&gt;
&lt;p&gt;value:&lt;/p&gt;
&lt;p&gt;com.alibaba.cloud.nacos.NacosConfigBootstrapConfiguration |&lt;br/&gt;| org.springframework.boot.autoconfigure.EnableAutoConfiguration | 注释太长了，不放这里.放到附录中。&lt;/p&gt;
&lt;p&gt;来源：spring-boot-autoconfigure-version.jar&lt;/p&gt;
&lt;p&gt;com.alibaba.cloud.nacos.NacosConfigAutoConfiguration,\&lt;/p&gt;
&lt;p&gt;com.alibaba.cloud.nacos.endpoint.NacosConfigEndpointAutoConfiguration |&lt;br/&gt;| org.springframework.boot.diagnostics.FailureAnalyzer | &lt;em&gt;A {@code FailureAnalyzer} is used to analyze a failure and provide diagnostic* information that can be displayed to the user.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;_&lt;/p&gt;
&lt;p&gt;翻译： FailureAnalyzer用来分析错误并提供诊断信息展示给到用户&lt;/p&gt;
&lt;p&gt;来源： spring-boot-version.jar&lt;/p&gt;
&lt;p&gt;com.alibaba.cloud.nacos.diagnostics.analyzer.NacosConnectionFailureAnalyzer |&lt;/p&gt;
&lt;p&gt;然后看看都自动装配了什么？以及自动装配的过程。&lt;/p&gt;
&lt;p&gt;springboot的方式调用；&lt;/p&gt;
&lt;h3 id=&quot;1-nacosconfigbootstrapconfiguration&quot;&gt;1 NacosConfigBootstrapConfiguration&lt;/h3&gt;
&lt;p&gt;源码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.alibaba.cloud.nacos;

import com.alibaba.cloud.nacos.client.NacosPropertySourceLocator;

import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * @author xiaojing
 */
@Configuration(proxyBeanMethods = false)
@ConditionalOnProperty(name = &quot;spring.cloud.nacos.config.enabled&quot;, matchIfMissing = true)
public class NacosConfigBootstrapConfiguration {

        @Bean
        @ConditionalOnMissingBean
        public NacosConfigProperties nacosConfigProperties() {
                return new NacosConfigProperties();
        }

        @Bean
        @ConditionalOnMissingBean
        public NacosConfigManager nacosConfigManager(
                        NacosConfigProperties nacosConfigProperties) {
                return new NacosConfigManager(nacosConfigProperties);
        }

        @Bean
        public NacosPropertySourceLocator nacosPropertySourceLocator(
                        NacosConfigManager nacosConfigManager) {
                return new NacosPropertySourceLocator(nacosConfigManager);
        }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;自动装配流程：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/268922/202010/268922-20201009235009216-1421201079.svg+xml&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;配置文件组装源码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Override
        public PropertySource&amp;lt;?&amp;gt; locate(Environment env) {
                nacosConfigProperties.setEnvironment(env);
                ConfigService configService = nacosConfigManager.getConfigService();

                if (null == configService) {
                        log.warn(&quot;no instance of config service found, can't load config from nacos&quot;);
                        return null;
                }
                long timeout = nacosConfigProperties.getTimeout();
                nacosPropertySourceBuilder = new NacosPropertySourceBuilder(configService,
                                timeout);
                String name = nacosConfigProperties.getName();

                String dataIdPrefix = nacosConfigProperties.getPrefix();
                if (StringUtils.isEmpty(dataIdPrefix)) {
                        dataIdPrefix = name;
                }

                if (StringUtils.isEmpty(dataIdPrefix)) {
                        dataIdPrefix = env.getProperty(&quot;spring.application.name&quot;);
                }

                CompositePropertySource composite = new CompositePropertySource(
                                NACOS_PROPERTY_SOURCE_NAME);

                loadSharedConfiguration(composite);
                loadExtConfiguration(composite);
                loadApplicationConfiguration(composite, dataIdPrefix, nacosConfigProperties, env);

                return composite;
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/268922/202010/268922-20201009235009387-2622454.svg+xml&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;加载应用配置文件的顺序源码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private void loadApplicationConfiguration(
                        CompositePropertySource compositePropertySource, String dataIdPrefix,
                        NacosConfigProperties properties, Environment environment) {
                String fileExtension = properties.getFileExtension();
                String nacosGroup = properties.getGroup();
                // load directly once by default
                loadNacosDataIfPresent(compositePropertySource, dataIdPrefix, nacosGroup,
                                fileExtension, true);
                // load with suffix, which have a higher priority than the default
                loadNacosDataIfPresent(compositePropertySource,
                                dataIdPrefix + DOT + fileExtension, nacosGroup, fileExtension, true);
                // Loaded with profile, which have a higher priority than the suffix
                for (String profile : environment.getActiveProfiles()) {
                        String dataId = dataIdPrefix + SEP1 + profile + DOT + fileExtension;
                        loadNacosDataIfPresent(compositePropertySource, dataId, nacosGroup,
                                        fileExtension, true);
                }

        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;顺序如下：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;序号&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;加载dataIdPrefix对应的配置文件&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;加载dataIdPrefix.fileExtension对应的配置文件&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;加载 dataIdPrefix-activeProfiles.fileExtension对应的配置文件&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;21-nacosconfigautoconfiguration&quot;&gt;2.1 NacosConfigAutoConfiguration&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;序号&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;NacosConfigProperties  nacos配置&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;NacosRefreshProperties  已经不建议被使用&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;NacosRefreshHistory  刷新历史&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;NacosConfigManager 配置&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;NacosContextRefresher 注册nacos的监听器到应用&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;22-nacosconfigendpointautoconfiguration&quot;&gt;2.2 NacosConfigEndpointAutoConfiguration&lt;/h3&gt;
&lt;p&gt;NacosConfigEndpoint&lt;/p&gt;
&lt;p&gt;本地配置同步逻辑&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;       @ReadOperation
        public Map&amp;lt;String, Object&amp;gt; invoke() {
                Map&amp;lt;String, Object&amp;gt; result = new HashMap&amp;lt;&amp;gt;(16);
                result.put(&quot;NacosConfigProperties&quot;, properties);

                List&amp;lt;NacosPropertySource&amp;gt; all = NacosPropertySourceRepository.getAll();

                List&amp;lt;Map&amp;lt;String, Object&amp;gt;&amp;gt; sources = new ArrayList&amp;lt;&amp;gt;();
                for (NacosPropertySource ps : all) {
                        Map&amp;lt;String, Object&amp;gt; source = new HashMap&amp;lt;&amp;gt;(16);
                        source.put(&quot;dataId&quot;, ps.getDataId());
                        source.put(&quot;lastSynced&quot;, dateFormat.get().format(ps.getTimestamp()));
                        sources.add(source);
                }
                result.put(&quot;Sources&quot;, sources);
                result.put(&quot;RefreshHistory&quot;, refreshHistory.getRecords());

                return result;
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;NacosConfigHealthIndicator&lt;/p&gt;
&lt;p&gt;健康检查 UP,DOWN,UNKNOWN ;&lt;/p&gt;
&lt;h3 id=&quot;3-nacosconnectionfailureanalyzer&quot;&gt;3 NacosConnectionFailureAnalyzer&lt;/h3&gt;
&lt;p&gt;连接不上nacos服务端抛出异常&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Override
        protected FailureAnalysis analyze(Throwable rootFailure,
                        NacosConnectionFailureException cause) {
                return new FailureAnalysis(
                                &quot;Application failed to connect to Nacos server: \&quot;&quot;
                                                + cause.getServerAddr() + &quot;\&quot;&quot;,
                                &quot;Please check your Nacos server config&quot;, cause);
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;小结：服务通过集成该starter，通过http请求从nacos的服务端拉取配置数据，并做了 配置刷新历史，注册监听器到spring容器中， 本地缓存，和错误报告；&lt;/p&gt;
&lt;h2 id=&quot;服务端封装&quot;&gt;服务端封装&lt;/h2&gt;
&lt;p&gt;源码位置：&lt;a href=&quot;https://github.com/alibaba/nacos/tree/develop/config&quot;&gt;https://github.com/alibaba/nacos/tree/develop/config&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;应用启动读取配置文件整体调用链：待后续完成；&lt;/p&gt;

&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;如果读完本篇文章你只能记住一句话：nacos作为配置中心可为单独的服务提供外部化配置文件，也支持多应用共享配置文件。&lt;br/&gt;从nacos的客户端源码分析中可看到一些配置优先级的顺序。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;原创不易，关注诚可贵，转发价更高！转载请注明出处，让我们互通有无，共同进步，欢迎沟通交流。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 09 Oct 2020 15:50:00 +0000</pubDate>
<dc:creator>李福春</dc:creator>
<og:description>假如你使用的是spring-cloud-alibaba微服务技术栈 单个服务独有配置文件 即去除应用程序的状态，配置统一外部化管理，方便进行水平的伸缩。 集成步骤： 假如我有一个应用app-desig</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/snidget/p/13789640.html</dc:identifier>
</item>
<item>
<title>Centos下Oracle11gR2安装教程与自动化配置脚本 - Hui_Tong</title>
<link>http://www.cnblogs.com/tongh/p/13789625.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tongh/p/13789625.html</guid>
<description>&lt;h3 id=&quot;开发组件与依赖库安装&quot;&gt;开发组件与依赖库安装&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1480358/202010/1480358-20201009234306007-393743556.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;安装centos时选择Server with GUI，右面的可以不勾选，后面统一来装&lt;/p&gt;
&lt;h4 id=&quot;配置本地yum源&quot;&gt;配置本地yum源&lt;/h4&gt;
&lt;p&gt;以上包如果缺乏可配置本地yum源进行安装&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;sudo mount /dev/cdrom /mnt/

[galen@localhost yum.repos.d]$ sudo vim /etc/yum.repos.d/cdrom.repo
[galen@localhost yum.repos.d]$ cat cdrom.repo 
[c7-media]
name=isofile
baseurl=file:///mnt
enable=1
gpgcheck=1
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7

[galen@localhost yum.repos.d]$ sudo mv CentOS-Base.repo CentOS-Base.repo-bak
[galen@localhost yum.repos.d]$ sudo mv CentOS-Media.repo CentOS-Media.repo-bak
[galen@localhost yum.repos.d]$ sudo mv cdrom.repo CentOS-Media.repo
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置好yum源后开始安装依赖库，如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;yum install glibc glibc-devel glibc-headers ksh libaio libaio-devel libgcc libstdc++ libstdc++-devel make sysstat unixODBC unixODBC-devel pdksh  compat-libcap1   compat-libstdc++ elfutils-libelf-devel gcc-c++
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;关闭防火墙&quot;&gt;关闭防火墙&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;[galen@localhost ~]$ systemctl stop firewalld.service 
[galen@localhost ~]$ systemctl disable firewalld.service 
Removed symlink /etc/systemd/system/multi-user.target.wants/firewalld.service.
Removed symlink /etc/systemd/system/dbus-org.fedoraproject.FirewallD1.service.
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关闭selinux&lt;/p&gt;
&lt;p&gt;编辑/etc/sysconfig/selinux文件，保存退出后执行 setenforce 0命令&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;vim /etc/sysconfig/selinux
SELINUX=disabled
#SELINUXTYPE=targeted   #注释掉
&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;创oracle建用户和组&quot;&gt;创oracle建用户和组&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;[root@localhost galen]# groupadd oinstall
[root@localhost galen]# groupadd dba
[root@localhost galen]# useradd -g oinstall -G dba oracle
[root@localhost galen]# passwd oracle

[root@localhost galen]# id oracle
uid=1001(oracle) gid=1001(oinstall) groups=1001(oinstall),1002(dba)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;系统参数设置&quot;&gt;系统参数设置&lt;/h3&gt;
&lt;p&gt;官方推荐值：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;fs.aio-max-nr = 1048576   
fs.file-max = 6815744    
kernel.shmall = 2097152  
kernel.shmmax = 536870912  #推荐超过一半的物理内存
kernel.shmmni = 4096   
kernel.sem = 250 32000 100 128   
net.ipv4.ip_local_port_range = 9000 65500   
net.core.rmem_default = 262144    
net.core.rmem_max = 4194304   
net.core.wmem_default = 262144 
net.core.wmem_max = 1048576 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过 /sbin/sysctl -a |grep xxx 查看系统各参数，如果大于官方推荐值不修改，如果小于官方推荐值则修改为官方推荐值，写入/etc/sysctl.conf文件中，使用sysctl -p使其生效，示例如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;[root@localhost etc]# cat sysctl.conf
fs.aio-max-nr = 6815744
kernel.sem = 250 32000 100 128
net.ipv4.ip_local_port_range = 9000 65500
net.core.rmem_default = 262144
net.core.rmem_max = 4194304
net.core.wmem_default = 262144
net.core.wmem_max = 1048576
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改资源限制如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;[root@localhost etc]# vim /etc/security/limits.conf
oracle          soft            nproc           2048
oracle          hard            nproc           16384
oracle          soft            nofile          1024
oracle          hard            nofile          65536
oracle          soft            stack           10240 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;添加以下内容到/etc/pam.d/login&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;[root@localhost ~]# vim /etc/pam.d/login
session  required   pam_limits.so
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;添加以下内容到/etc/profile&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;[root@localhost ~]# vim /etc/profile
if [[ $USER = &quot;oracle&quot; ]]; then
        if [[ $SHELL = &quot;/bin/ksh&quot; ]]; then
                ulimit -p 16384
                ulimit -n 65536
        else
                ulimit -u 16384 -n 65536
        fi
fi
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;保存后执行source /etc/profile生效&lt;/p&gt;
&lt;p&gt;配置oracle用户环境变量，在/home/oracle/.bash_profile中加入如下内容&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;[root@localhost ~]# vim /home/oracle/.bash_profile
export ORACLE_BASE=/u01/app/oracle
export ORACLE_HOME=$ORACLE_BASE/product/11.2.0/db_1
export ORACLE_SID=orcl
export PATH=$ORACLE_HOME/bin:$ORACLE_HOME/OPatch:$ORACLE_HOME/jdk/bin:$PATH
export LANG=&quot;en_US.UTF-8&quot;
export NLS_LANG=american_AMERICA.UTF8
export NLS_DATE_FORMAT=&quot;YYYY-MM-DD HH24:MI:SS&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;创建oracle安装目录&quot;&gt;创建oracle安装目录&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;mkdir -p /u01/app/oracle/product/11.2.0/db_1
chown -R oracle:oinstall /u01/app
chmod -R 775 /u01/app
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;挂载oracle11g安装包iso（也可以通过其他方式将oracle安装包传到主机），将安装文件复制到oracle home目录下，修改文件权限给oracle用户&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;[root@localhost /]# mkdir /mnt/oracle11g
[root@localhost /]# mount /dev/cdrom /mnt/oracle11g/
[root@localhost /]# cp -r /mnt/oracle11g /home/oracle/
# 复制到oracle home目录下并修改权限
[root@localhost oracle]# chown -R oracle:oinstall /home/oracle/oracle11g/
[root@localhost oracle]# chmod -R 775 /home/oracle/oracle11g/
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来使用oracle用户登录桌面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1480358/202010/1480358-20201009234355820-1883483676.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;执行./runInstaller开始安装，Centos 7安装的时候错误弹框有时候会变成一条竖线，安装无法进行下去，所以运行时执行&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;./runInstaller -jreLoc /etc/alternatives/jre_1.8.0
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1480358/202010/1480358-20201009234422571-330411360.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每项操作如下&lt;/p&gt;
&lt;p&gt;[Configure Security Updates] 取消勾选 I wish to receive security updates via My Oracle Support，Next&lt;/p&gt;
&lt;p&gt;[Installation Option] Install database software only，Next&lt;/p&gt;
&lt;p&gt;[Grid Options] Next&lt;/p&gt;
&lt;p&gt;[Product Languages] Next&lt;/p&gt;
&lt;p&gt;[Enterprise Edition] Next&lt;/p&gt;
&lt;p&gt;[Installation Location] Next&lt;/p&gt;
&lt;p&gt;[Create Inventory] Next&lt;/p&gt;
&lt;p&gt;[Operating System Groups] Next&lt;/p&gt;
&lt;p&gt;[Prerequisite Checks] Next&lt;/p&gt;
&lt;p&gt;[Summary] Finish，开始安装oracle 11g&lt;/p&gt;
&lt;p&gt;安装到84%的时候可能会出现ins_ctx.mk相关的错误，如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1480358/202010/1480358-20201009234441986-819165580.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;修改/u01/app/oracle/product/11.2.0/db_1/ctx/lib/ins_ctx.mk文件&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# 源文件
ctxhx: $(CTXHXOBJ)
        $(LINK_CTXHX) $(CTXHXOBJ) $(INSO_LINK)
# 修改为
ctxhx: $(CTXHXOBJ)
        -static $(LINK_CTXHX) $(CTXHXOBJ) $(INSO_LINK) /usr/lib64/stdc.a
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改/u01/app/oracle/product/11.2.0/db_1/sysman/lib/ins_emagent.mk文件&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# 源文件
$(SYSMANBIN)emdctl:
        $(MK_EMAGENT_NMECTL)
# 修改为
$(SYSMANBIN)emdctl:
        $(MK_EMAGENT_NMECTL) -lnnz11
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;retry继续安装到94%时，弹出&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1480358/202010/1480358-20201009234455981-1390740515.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用root用户ssh到主机到上述目录分别执行orainstRoot.sh与root.sh，执行root.sh时根据提示填入路径&lt;/p&gt;
&lt;p&gt;/u01/app/oracle/product/11.2.0/dbhome_1/bin，执行完成后到UI点击OK，安装完成&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;使用root用户登录&lt;/li&gt;
&lt;li&gt;确保系统iso驱动器已连接（/dev/cdrom可mount）&lt;/li&gt;
&lt;li&gt;复制脚本到主机并给予可执行权限，执行脚本完成后即可开始安装oracle 11g&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;oracle 11g环境配置脚本&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;#!/bin/bash

# 配置yum源为本地iso
function set_yum_media() {
    cd /etc/yum.repos.d/
    for repo_file in `ls /etc/yum.repos.d/ | grep -v Media`
    do
        new_file=$repo_file.bak
        mv $repo_file $new_file
    done
    mkdir -p /mnt/media-dir
    mount /dev/cdrom /mnt/media-dir
    sed -i -e 's/baseurl=file:\/\/\/.*/baseurl=file:\/\/\/mnt\/media-dir\//g' -e 's/enabled=0/enabled=1/g' `ls /etc/yum.repos.d/ | grep Media`
    cd -
        rm -rf /var/run/yum.pid
    yum -y update
}

function install_packages() {
    for package in glibc glibc-devel glibc-headers ksh libaio libaio-devel libgcc libstdc++ libstdc++-devel make sysstat unixODBC unixODBC-devel pdksh  compat-libcap1   compat-libstdc++ elfutils-libelf-devel gcc-c++
    do
        yum -y install $package
    done
}

function create_oracle_user() {
        groupadd oinstall
        groupadd dba
        useradd -g oinstall -G dba oracle
        # 设置oracle用户密码为oracle
        echo oracle|passwd --stdin oracle
}

function set_system_parm() {
        sed -i '$a\fs.aio-max-nr = 1048576' /etc/sysctl.conf
        sed -i '$a\fs.file-max = 6815744' /etc/sysctl.conf
        sed -i '$a\kernel.shmall = 2097152' /etc/sysctl.conf
        sed -i '$a\kernel.shmmax = 536870912' /etc/sysctl.conf
        sed -i '$a\kernel.shmmni = 4096' /etc/sysctl.conf
        sed -i '$a\kernel.sem = 250 32000 100 128' /etc/sysctl.conf
        sed -i '$a\net.ipv4.ip_local_port_range = 9000 65500' /etc/sysctl.conf
        sed -i '$a\net.core.rmem_default = 262144' /etc/sysctl.conf
        sed -i '$a\net.core.rmem_max = 4194304' /etc/sysctl.conf
        sed -i '$a\net.core.wmem_default = 262144' /etc/sysctl.conf
        sed -i '$a\net.core.wmem_max = 1048586' /etc/sysctl.conf
        sysctl -p
}

function set_system_limit_parm() {
        sed -i '$a\oracle               soft            nproc           2048' /etc/security/limits.conf
        sed -i '$a\oracle               hard            nproc           16384' /etc/security/limits.conf
        sed -i '$a\oracle               soft            nofile          1024' /etc/security/limits.conf
        sed -i '$a\oracle               hard            nofile          65536' /etc/security/limits.conf
        sed -i '$a\oracle               soft            stack           10240' /etc/security/limits.conf
}

function set_profile_parm() {
        sed -i '$a\session  required   pam_limits.so' /etc/pam.d/login
        sed -i '$a\if [[ $USER = &quot;oracle&quot; ]]; then' /etc/profile
        sed -i '$a\   if [[ $SHELL = &quot;/bin/ksh&quot; ]]; then' /etc/profile
        sed -i '$a\       ulimit -p 16384' /etc/profile
        sed -i '$a\       ulimit -n 65536' /etc/profile
        sed -i '$a\   else' /etc/profile
        sed -i '$a\       ulimit -u 16384 -n 65536' /etc/profile
        sed -i '$a\   fi' /etc/profile
        sed -i '$a\fi' /etc/profile
        source /etc/profile
}

function set_oracle_env() {
        sed -i '$a\export ORACLE_BASE=/u01/app/oracle' /home/oracle/.bash_profile
        sed -i '$a\export ORACLE_HOME=$ORACLE_BASE/product/11.2.0/db_1' /home/oracle/.bash_profile
        sed -i '$a\export ORACLE_SID=orcl' /home/oracle/.bash_profile
        sed -i '$a\export PATH=$ORACLE_HOME/bin:$ORACLE_HOME/OPatch:$ORACLE_HOME/jdk/bin:$PATH' /home/oracle/.bash_profile
        sed -i '$a\export LANG=&quot;en_US.UTF-8&quot;' /home/oracle/.bash_profile
        sed -i '$a\export NLS_LANG=american_AMERICA.UTF8' /home/oracle/.bash_profile
        sed -i '$a\export NLS_DATE_FORMAT=&quot;YYYY-MM-DD HH24:MI:SS&quot;' /home/oracle/.bash_profile
        source /home/oracle/.bash_profile
}

function create_oracle_dir() {
        mkdir -p /u01/app/oracle/product/11.2.0/db_1
        chown -R oracle:oinstall /u01/app
        chmod -R 775 /u01/app
}

function disable_firewall() {
        systemctl stop firewalld.service
        systemctl disable firewalld.service
        sed -i &quot;s/SELINUX=enforcing/SELINUX=disabled/g&quot; /etc/sysconfig/selinux
        setenforce 0
}

if [ `whoami` == &quot;root&quot; ]
then
        set_yum_media
        install_packages
        create_oracle_user
        echo &quot;set system parm&quot;
        set_system_parm
        echo &quot;set limits&quot;
        set_system_limit_parm
        echo &quot;set /etc/profile&quot;
        set_profile_parm
        echo &quot;set oracle env&quot;
        set_oracle_env
        echo &quot;create oracle dir&quot;
        create_oracle_dir
        echo &quot;disable firwall&quot;
        disable_firewall
fi
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 09 Oct 2020 15:47:00 +0000</pubDate>
<dc:creator>Hui_Tong</dc:creator>
<og:description>系统环境准备 开发组件与依赖库安装 安装centos时选择Server with GUI，右面的可以不勾选，后面统一来装 配置本地yum源 以上包如果缺乏可配置本地yum源进行安装 sudo moun</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tongh/p/13789625.html</dc:identifier>
</item>
<item>
<title>缓存提升性能的关键性手段 - 程序员修炼之旅</title>
<link>http://www.cnblogs.com/xiaoXuZhi/p/xyh_catch.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaoXuZhi/p/xyh_catch.html</guid>
<description>&lt;p&gt;提高「性能」的主要方式是优化，而优化的其中一个主要手段就是添加缓存！&lt;/p&gt;
&lt;p&gt;在软件工程里有这么一句话：「没有银弹」！就是说由于软件工程的复杂性，没有任何一种技术或方法能解决所有问题！软件工程是复杂的，没有银弹！但是，软件工程中的某一个问题，是有银弹的！&lt;/p&gt;
&lt;p&gt;「 计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决」！而「缓存层」可以说是添加得最多的层！主要目的就是为了提高性能！所以，缓存可以说是「性能银弹」！&lt;/p&gt;
&lt;p&gt;本文将探讨如下内容：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;缓存的作用&lt;/li&gt;
&lt;li&gt;缓存的种类&lt;/li&gt;
&lt;li&gt;缓存算法&lt;/li&gt;
&lt;li&gt;分布式缓存&lt;/li&gt;
&lt;li&gt;缓存的使用&lt;/li&gt;
&lt;li&gt;网络中的缓存&lt;/li&gt;
&lt;li&gt;应用缓存&lt;/li&gt;
&lt;li&gt;数据库缓存&lt;/li&gt;
&lt;li&gt;计算机中的缓存&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
fn longRunningOperations(){ ... // 很耗时}let result = longRunningOperations();// do other thing
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我们来看上面这段伪代码，longRunningOperations是个很耗时的方法（调用一次要几十秒甚至几分钟），比如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;复杂的业务逻辑计算&lt;/li&gt;
&lt;li&gt;复杂的数据查询&lt;/li&gt;
&lt;li&gt;耗时的网络操作等&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于这个方法，如果每次都去调用一次的话，会非常的影响性能，用户体验也非常的不好。&lt;/p&gt;
&lt;p&gt;那我们该如何处理呢？&lt;/p&gt;
&lt;p&gt;一般有几种优化方案：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;优化业务代码，比如：更快的数据结构和算法，更快的IO模型，建立数据库索引等&lt;/li&gt;
&lt;li&gt;简化业务逻辑，导致耗时的原因可能是业务过于复杂，可以通过简化业务逻辑的方式来减少耗时&lt;/li&gt;
&lt;li&gt;将操作的结果存储起来。例如：对于某些统计类的结果，可以先用日终定时的去执行，将结果存储到统计结果表中，查找时，直接从结果中查询即可；对于某些临时操作，可以将结果存储在内存中，再次调用时，直接从内存中获取即可。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;本文主要聊聊第三种方案：使用「缓存」！&lt;/p&gt;

&lt;p&gt;一般我们使用缓存来存储一些内容，这些内容有如下一些特点（符合一条或多条）：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用较频繁&lt;/li&gt;
&lt;li&gt;变更不频繁&lt;/li&gt;
&lt;li&gt;获取较耗时&lt;/li&gt;
&lt;li&gt;多系统访问&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;比如，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;字典数据：系统很多地方都会使用字典数据，而字典数据配置完成后一般不会修改，虽然从数据库中直接获取字典数据不是很耗时，但是多了查询和网络传输，性能上还是不如直接从缓存里面取快速&lt;/li&gt;
&lt;li&gt;秒杀商品信息：在秒杀时访问量很大，从缓存（静态文件、CDN等）获取要比从数据库查询要快得多&lt;/li&gt;
&lt;li&gt;其它访问频次较多的信息：此处的其它信息是因为其缓存的处理方式与上面的字典处理有差异，下面详细说明。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于字典数据来说，一般我们的做法是在系统启动时，将字典数据直接加载到缓存中，此类缓存数据一般没有过期时间；当修改字典时，会同时更新缓存中的内容。此类缓存称为「主动缓存」，因为其缓存数据是由用户的主动修改来触发更新的。&lt;/p&gt;
&lt;p&gt;而对于某些信息来说，因为信息量太大，不能一次性全部加载到缓存中，且也不是太清楚哪些数据访问频次高、哪些数据访问频次低。对于这样的数据，一般的做法是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;先到缓存中查找是否有访问的数据，如果有则直接返回给用户&lt;/li&gt;
&lt;li&gt;如果没有，则去溯源查找&lt;/li&gt;
&lt;li&gt;找到后将其添加到缓存中&lt;/li&gt;
&lt;li&gt;最后返回给用户&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;此类缓存称为「被动缓存」！其缓存的数据的过期由系统来控制。那系统如何控制呢？这就涉及到缓存置换算法！&lt;/p&gt;

&lt;p&gt;上面说了，对于被动缓存来说，由于信息量太大，数据不能一次全部加载到缓存中，当缓存满了以后，需要新增数据时，就需要确定哪些数据要从缓存里清除，给新数据腾出空间。&lt;/p&gt;
&lt;p&gt;用于判断哪些数据优先从缓存中剔除的算法称为「缓存(页面)置换算法」！&lt;/p&gt;
&lt;p&gt;Wiki中列出了如下置换算法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;RR（Random replacement）&lt;/li&gt;
&lt;li&gt;FIFO（First in first out）&lt;/li&gt;
&lt;li&gt;LIFO（Last in first out）&lt;/li&gt;
&lt;li&gt;MRU（Most recently used）&lt;/li&gt;
&lt;li&gt;LFU（Least-frequently used）&lt;/li&gt;
&lt;li&gt;LRU（Least recently used）&lt;/li&gt;
&lt;li&gt;TLRU（Time aware least recently used）&lt;/li&gt;
&lt;li&gt;PLRU（Pseudo-LRU）&lt;/li&gt;
&lt;li&gt;LRU-K&lt;/li&gt;
&lt;li&gt;SLRU（Segmented LRU）&lt;/li&gt;
&lt;li&gt;MQ（Multi queue）&lt;/li&gt;
&lt;li&gt;LFRU（Least frequent recently used）&lt;/li&gt;
&lt;li&gt;LFUDA（LFU with dynamic aging）&lt;/li&gt;
&lt;li&gt;LIRS（Low inter-reference recency set）&lt;/li&gt;
&lt;li&gt;ARC（Adaptive replacement cache）&lt;/li&gt;
&lt;li&gt;CAR（Clock with adaptive replacement）&lt;/li&gt;
&lt;li&gt;Pannier（Container-based caching algorithm for compound objects）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;一般情况下我们不会自己去实现个缓存，市面上有不少开源的缓存中间件，比如：redis,memcached。这里只简单的梳理几个常用的置换算法。&lt;/p&gt;
&lt;p&gt;FIFO&lt;/p&gt;
&lt;p&gt;FIFO应该算是最简单的置换算法了：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;它使用一个队列来维护数据&lt;/li&gt;
&lt;li&gt;数据按照加载到缓存的顺序进行排列，先加载的数据在队列头部，后加载的数据在队列尾部&lt;/li&gt;
&lt;li&gt;当缓存满了以后，从队列头部清除数据，给需要加载的数据腾出空间&lt;/li&gt;
&lt;li&gt;新数据加到队列的尾部&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;FIFO的实现很简单，但是其性能并不总是很好。举个简单的例子，假设一个系统需要10个缓存数据，恰巧此时5个数据在队列头部，另外5个数据不在缓存中，又恰巧此时队列又满了。按照FIFO算法，5条不在内存中的数据被加载到了缓存中，而之前的5条数据被清除了。这就需要再次将被清除的5条数据加载到缓存中。这就影响了性能。&lt;/p&gt;
&lt;p&gt;这个问题可能会随着所分配的缓存大小的增加而增加，原本我们使用缓存是为了提高性能的，现在可能会影响性能，这种现象称为「Belady现象」！&lt;/p&gt;
&lt;p&gt;LIFO和FIFO很类似，这里就不赘述了。&lt;/p&gt;
&lt;p&gt;LRU&lt;/p&gt;
&lt;p&gt;目前比较常用的置换算法称为LRU置换算法：优先替换掉「最近最少使用」的数据&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;每个数据都被关联了该数据上次使用的时间&lt;/li&gt;
&lt;li&gt;当需要置换数据的时候，LRU选择最长时间没有使用的数据&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;LRU的变体有很多，例如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;TLRU（Time aware least recently used）：大部分缓存数据是有过期时间的。PLRU从最少使用和过期时间两个维度来置换数据&lt;/li&gt;
&lt;li&gt;LRU-K：多维护一个队列，用于记录所有缓存数据被访问的次数。当数据的访问次数达到K次的时候，才将数据放入缓存。当需要淘汰数据时，LRU-K会淘汰第K次访问时间距当前时间最大的数据。&lt;/li&gt;
&lt;li&gt;SLRU（Segmented LRU）2Queue？：一个FIFO队列，一个LRU队列。当数据第一次访问时，将数据缓存在FIFO队列里面，当数据第二次被访问时，则将数据从FIFO队列移到LRU队列里面，两个队列各自按照自己的方法淘汰数据。&lt;/li&gt;
&lt;li&gt;PLRU（Pseudo-LRU）：LRU需要维护数据访问时间，占用了额外的空间，对于空间很小的设备来说，此算法太过浪费空间了。PLRU每个缓存数据只需要1bit来存储数据信息，可以达到LRU的效果。具体流程见下图：&lt;/li&gt;
&lt;/ul&gt;&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/381957/202010/381957-20201009233546588-31798271.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/div&gt;
&lt;p&gt;还有和LRU类似的MRU,LFU这里不在赘述！&lt;/p&gt;

&lt;p&gt;为了提高缓存的可用性，一般我们至少会对缓存做个主备，即一个主缓存，一个从缓存。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;缓存的写入只可以写到主缓存&lt;/li&gt;
&lt;li&gt;主缓存同步数据到从缓存中&lt;/li&gt;
&lt;li&gt;可以从主缓存读取数据。也可以从从缓存读取数据（不必须）&lt;/li&gt;
&lt;li&gt;当主缓存挂掉了，从缓存升级为主缓存&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;再安全一点的做法就是做缓存集群：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;多台机器缓存了相同的数据，其中一台为主缓存&lt;/li&gt;
&lt;li&gt;缓存的写入只可以写到主缓存&lt;/li&gt;
&lt;li&gt;主缓存同步数据到其它缓存&lt;/li&gt;
&lt;li&gt;可以从主缓存读取数据。也可以从其它缓存中读取数据（不必须）&lt;/li&gt;
&lt;li&gt;当主缓存挂掉了，会从其它缓存服务中选择一个作为新的主缓存&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;无论是单机缓存，主从备份还是缓存集群，都没法解决缓存大小限制的问题。因为一般缓存会使用内存，而一台机器的内存大小是有限的。当需要缓存的数据远远超过一台机器的内存大小的时候，就需要将缓存的数据分布到多台机器上。每台机器只缓存一部分数据，这就是分布式缓存。&lt;/p&gt;
&lt;p&gt;分布式缓存可以解决一台机器缓存数据有限的问题，但是也引入了新的问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;哪些数据该缓存在哪台服务器上&lt;/li&gt;
&lt;li&gt;如何保证每台服务器缓存的数据量基本相同&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;一般做法是对key进行hash，然后对服务器数量进行取余，来确定数据在哪台服务器上。这解决了「哪些数据该缓存在哪台服务器上」的问题，但是却无法保证「每台服务器缓存的数据量基本相同」，因为可能多个key的hash取余后都落到了同一个服务器上，这就可能导致其中一台服务器缓存的数量很多，其它服务器缓存的数据量很少。缓存数据量多的服务器可能会内存不够用，触发数据置换，进而导致性能下降。&lt;/p&gt;
&lt;p&gt;可以使用一致性hash环来保证服务器缓存的数据量基本相同，大致逻辑如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;将0~2^32个点均匀分配到一个圆上&lt;/li&gt;
&lt;li&gt;每个点对应一台缓存服务器&lt;/li&gt;
&lt;li&gt;缓存服务器数量是远小于2^32个的，所以多个节点对应一台缓存服务器，多出来的节点称为虚拟节点&lt;/li&gt;
&lt;li&gt;确保缓存服务器的分布均匀&lt;/li&gt;
&lt;li&gt;同样是对key进行hash&lt;/li&gt;
&lt;li&gt;对2^32进行求余&lt;/li&gt;
&lt;li&gt;结果对应到hash环上&lt;/li&gt;
&lt;li&gt;如果正好落到节点上，则数据就缓存到对应的缓存服务器上&lt;/li&gt;
&lt;li&gt;否则就存到落点前面的那个节点所对应的缓存服务器上&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面聊的主要是应用缓存，实际上，缓存无处不在。&lt;/p&gt;
&lt;p&gt;下面通过我们访问网站的流程，来简单梳理一下，整个过程中，哪些地方可能会用到缓存。&lt;/p&gt;
&lt;p&gt;网络缓存&lt;/p&gt;
&lt;p&gt;当我们在浏览器中输入URL，按下回车后。&lt;/p&gt;
&lt;p&gt;首先，需要查找域名所对应的IP！这里就有各种缓存！&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;浏览器缓存：浏览器会缓存DNS记录一段时间，首先会从浏览器缓存里去找对应的IP。&lt;/li&gt;
&lt;li&gt;系统缓存：如果在浏览器缓存里没有找到需要的记录，就会到系统缓存中查找记录&lt;/li&gt;
&lt;li&gt;路由器缓存：如果系统缓存中也没找到，就会到路由器缓存中查找记录&lt;/li&gt;
&lt;li&gt;ISP DNS 缓存：如果还是找不到，就到ISP缓存DNS的服务器里查找。在这一般都能找到相应的缓存记录。&lt;/li&gt;
&lt;li&gt;递归搜索：如果上面的缓存都找不到，就需要从根域名服务器开始递归查找了&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;找到IP后，还不一定要发请求，因为你访问的资源可能之前已经访问过，已经被缓存到了浏览器缓存中。此时，浏览器直接返回缓存，而不会发送请求。&lt;/p&gt;
&lt;p&gt;如果没有缓存，则发送请求获取资源。&lt;/p&gt;
&lt;p&gt;后面可能会达到CDN。CDN是一种边缘缓存。在用户访问网站时，利用GSLB（Global Server Load Balance，全局负载均衡）技术将用户的访问指向距离最近的工作正常的缓存服务器上，由缓存服务器直接响应用户请求。如果CDN中找不到需要的资源，则请求可能就到了反向代理。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;某些反向代理能够做到和用户来自同一个网络，那么用户访问反向代理服务器的时候，就会得到很高质量的响应速度，这样的反向代理缓存一般称为边缘缓存，而CDN在边缘缓存的基础上，使用了GSLB&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一般反向代理有两个功能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;隐藏源服务器，防止服务器恶意攻击。客户端感知不到代理服务器和源服务器的区别&lt;/li&gt;
&lt;li&gt;缓存，将原始服务器数据进行缓存，减少源服务器的访问压力&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果反向代理中也找不到需要的资源，请求才到达源服务器来获取资源。&lt;/p&gt;
&lt;p&gt;服务端与数据库缓存&lt;/p&gt;
&lt;p&gt;一般情况下，Server接收到请求后，会根据请求，组装出响应，进行返回。这个过程可能需要查询数据库、进行业务逻辑计算、页面渲染等操作。这里的每一步都可以引入缓存。&lt;/p&gt;
&lt;p&gt;对于数据库查询来说，目前一般的持久化框架都会提供查询缓存。即对于相同的sql，第二次查询开始，可以不用再查询数据库，直接从缓存中获取第一次查询所返回的数据。节省了调用数据库查询的时间消耗。对于某些访问量很大的数据，也可以将其缓存到缓存中间件中。后续直接从缓存中间件中获取。&lt;/p&gt;
&lt;p&gt;而数据库本身也有缓存！&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/381957/202010/381957-20201009233612636-756998886.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;客户端发送一条查询给服务端&lt;/li&gt;
&lt;li&gt;服务端检查查询缓存，如果命中缓存，则立刻返回缓存中的结果。如果没找到，则&lt;/li&gt;
&lt;li&gt;进行sql解析、预处理、再由优化器生成对应的执行计划&lt;/li&gt;
&lt;li&gt;根据执行计划，调用存储引擎的API执行查询&lt;/li&gt;
&lt;li&gt;将结果返回给客户端&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;mysql的查询缓存可能会降低效率。首先，写缓存是独占模式写入。其次，假设一个查询结果被缓存了，当涉及到的其中一张表数据更新，该缓存都会被置为无效。对于频繁修改的数据，使用缓存就会降低效率。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于业务逻辑计算来说，如果某些业务逻辑很复杂，那么可以针对结果进行缓存。可以将结果缓存到数据库或缓存中间件中。对于相同的参数的请求，第二次请求时，就不必进行计算，直接从缓存中返回结果即可。&lt;/p&gt;
&lt;p&gt;对于页面渲染来说，某些访问量很大的页面，且数据基本不变的情况下，可以对页面进行静态化。即生成静态的页面，不必每次访问的时候都动态生成页面进行返回，而是预先生成好页面，将其存到磁盘上，当访问该页面的时候，直接从磁盘获取页面进行返回即可。或者直接将页面内容缓存到缓存中间件中，进一步提高性能。&lt;/p&gt;
&lt;p&gt;另外，对于需要登录的Server来说，用户信息其实也是缓存下来的。不论是存到服务器Session中，还是存到了缓存中间件中。否则，每次用户访问Server都需要到数据库获取用户信息，会影响Server端性能！&lt;/p&gt;
&lt;p&gt;计算机缓存&lt;/p&gt;
&lt;p&gt;最后，运行系统的计算机本身也有很多的缓存！&lt;/p&gt;
&lt;p&gt;我们都知道，一般计算机由CPU、内存、主板、硬盘、显卡、显示器、鼠标、键盘、网卡等组成！其中存储类设备包括了：云存储（例如：百度云盘，NAS等）、本地硬盘、内存、CPU中的高速缓存（我们常说的一级缓存、二级缓存和三级缓存）以及CPU寄存器。它们的速度各异，差异达数个量级。下图显示了各个设备的访问速率。&lt;/p&gt;
&lt;p&gt;![非功能性约束之性能（1）-性能银弹：缓存](https://p1-tt.byteimg.com/origin/pgc-image/d6c8ccf82f6f49fd9fb04ae7750c181c?from=pc)&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;CPU寄存器最快，达到1ns，但只能存储几百个字节，造价也最贵&lt;/li&gt;
&lt;li&gt;高速缓存次之，也达到了10ns，可存储几十兆，造价次之。其中L1，L2，L3速度越来越慢。&lt;/li&gt;
&lt;li&gt;然后是内存，为100ns，可达GB级别，造价比缓存便宜（不过这两年的内存价格贵得离谱）&lt;/li&gt;
&lt;li&gt;硬盘访问速率为10ms级别，可达TB级别，造价可以说是白菜价了&lt;/li&gt;
&lt;li&gt;而云存储则达到了秒级，基本可以无限扩展，只要钱够&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们都知道CPU的高速缓存是「缓存」，实际上上面的设备，上层设备都可以说是下层设备的「缓存」！&lt;/p&gt;
&lt;p&gt;在《深入理解计算机》一书中，简单的介绍了计算机执行C语言的hello world程序时的计算机流程。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通过鼠标、键盘输入执行命令'./hello'&lt;/li&gt;
&lt;li&gt;输入的内容从键盘通过总线，进入寄存器，在进入内存&lt;/li&gt;
&lt;/ul&gt;&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/381957/202010/381957-20201009233646165-1586611458.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;当按下回车后&lt;/li&gt;
&lt;li&gt;通过DMA技术，将目标文件，从硬盘中直接读取到内存中&lt;/li&gt;
&lt;/ul&gt;&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/381957/202010/381957-20201009233726025-1114883674.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;最后执行程序&lt;/li&gt;
&lt;li&gt;将hello world拷贝到寄存器&lt;/li&gt;
&lt;li&gt;再从寄存器拷贝到显示器显示&lt;/li&gt;
&lt;/ul&gt;&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/381957/202010/381957-20201009233754661-1629272066.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/div&gt;
&lt;p&gt;可以看到，绝大部分的操作，都是数据的拷贝！最终被CPU执行，为了数据能更快的到达CPU，就有了一层一层的「缓存」！&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;CPU寄存器里的数据是直接给CPU使用的，相当于是L1的缓存&lt;/li&gt;
&lt;li&gt;L1又是L2的缓存，L2又是L3的缓存&lt;/li&gt;
&lt;li&gt;L3是内存的缓存&lt;/li&gt;
&lt;li&gt;内存又是硬盘的缓存。例如：一般硬盘中的数据，都需要先加载到内存中才能被CPU使用。另外硬盘的“HMB内存缓冲技术”，可以借用内存作为硬盘的缓存。&lt;/li&gt;
&lt;li&gt;硬盘本身也是有缓存的，这是为了减少IO操作，批量的进行读写。&lt;/li&gt;
&lt;li&gt;硬盘也可以是云存储的缓存。例如在网络不太好的情况下，我们可以把电影先下载下来再看，这样就不会有卡顿的情况&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;性能是架构设计时需要着重考虑的一个非功能性约束，而引入缓存是提高系统性能的一个简单且直接的方法。&lt;/p&gt;
&lt;p&gt;本文从一个简单的伪代码开始，简单阐述了，缓存的作用，涉及的技术以及目前缓存的使用场景，以期能对架构设计提供一些参考。&lt;/p&gt;
&lt;p&gt;END&lt;br/&gt;为了更高的交流，欢迎大家关注我的公众号，扫描下面二维码即可关注，谢谢：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/381957/202006/381957-20200609102247158-1709176751.jpg&quot; alt=&quot;&quot; width=&quot;258&quot; height=&quot;258&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 09 Oct 2020 15:27:00 +0000</pubDate>
<dc:creator>程序员修炼之旅</dc:creator>
<og:description>性能是架构设计时需要着重考虑的一个非功能性约束，而引入缓存是提高系统性能的一个简单且直接的方法。本文从一个简单的伪代码开始，简单阐述了，缓存的作用，涉及的技术以及目前缓存的使用场景，以期能对架构设计提</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiaoXuZhi/p/xyh_catch.html</dc:identifier>
</item>
<item>
<title>IO那些事 - 大~熊</title>
<link>http://www.cnblogs.com/floor/p/13789402.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/floor/p/13789402.html</guid>
<description>&lt;p&gt;本文将简单介绍Linux的5大IO模型以及java中的3大IO模型，并介绍java的NIO的基础知识点&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;253.69839851975&quot;&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;IO（Input\Output): 即输入输出，通常指数据在存储器（内部和外部）或其他周边设备之间的输入和输出，是信息处理系统（例如计算机）与外部世界（可能是人类或另一信息处理系统）之间的通信。说的简单点就是&lt;code&gt;与外部设备（比如磁盘）传输数据&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;IO大致可以分为&lt;code&gt;磁盘IO&lt;/code&gt;、&lt;code&gt;网络IO&lt;/code&gt;、&lt;code&gt;内存IO&lt;/code&gt;。通常所说的IO指的是前两者。本文将简单介绍Linux的&lt;code&gt;五大IO模型&lt;/code&gt;，&lt;code&gt;java中的IO模型&lt;/code&gt;，并对java的&lt;code&gt;NIO&lt;/code&gt;做一个基本介绍。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;io基本流程&quot;&gt;IO基本流程&lt;/h2&gt;
&lt;p&gt;外围设备的直接读写涉及到&lt;code&gt;中断&lt;/code&gt;，中断时需要保存进程数据、状态等信息、中断结束后需要恢复进程数据和状态，这种&lt;code&gt;成本是比较高的&lt;/code&gt;。因此出现了一个叫&lt;code&gt;内核缓冲区&lt;/code&gt;（位于内核空间）的东西，我们的程序&lt;code&gt;并不是直接与IO设备交互的，而是与这个内核缓冲区交互&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pcgo-1255634607.cos.ap-shanghai.myqcloud.com/picgo/2020-10-09/%E5%85%B3%E4%BA%8EIO/IO%E5%9F%BA%E6%9C%AC%E8%BF%87%E7%A8%8B.jpg&quot; alt=&quot;IO基本过程&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;center&gt;io流程示意图&lt;/center&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;如图所示，读的时候，先将数据从磁盘或者网卡拷贝到内核缓冲区（这一步是操作系统内核通过读中断完成的），然后从内核缓冲区拷贝到进程缓冲区（位于用户空间）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;写的时候，先将数据写到进程缓冲区，然后拷贝到内核缓冲区，然后写到网卡或者刷到磁盘（这一步是通过写中断完成的）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;读中断和写中断何时进行是内核决定的，大多数的IO操作并没有实际的IO，而是在进程缓冲区与内核缓冲区来回拷贝数据。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;一个完整的读流程包括两个阶段：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;准备数据：将数据从网卡拷贝到内核缓冲区&lt;/li&gt;
&lt;li&gt;拷贝数据：将数据从内核缓冲区复制到进程缓冲区&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;两个重要的名词&quot;&gt;两个重要的名词&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;同步与异步&lt;/code&gt;：同步就是用户空间是发起IO的一方，异步是内核空间是发起IO的一方。也可以理解为同步就是自己要去查IO状态，异步是内核可以通知你&lt;/li&gt;
&lt;li&gt;&lt;code&gt;阻塞与非阻塞&lt;/code&gt;：阻塞就是当你调用了一个IO读或者写时，需要等内核操作&lt;code&gt;彻底(准备与拷贝数据)完成后才能返回&lt;/code&gt;，这一段时间用户空间程序是“卡住的状态”；非阻塞就是，调用了一个读或写时不管内核有没有操作完成，都会立即返回。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;五大io模型&quot;&gt;五大IO模型&lt;/h2&gt;
&lt;h3 id=&quot;同步阻塞&quot;&gt;同步阻塞&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://pcgo-1255634607.cos.ap-shanghai.myqcloud.com/picgo/2020-10-09/%E5%85%B3%E4%BA%8EIO/%E5%90%8C%E6%AD%A5%E9%98%BB%E5%A1%9E.jpg&quot; alt=&quot;同步阻塞&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;center&gt;同步阻塞IO模型&lt;/center&gt;
&lt;p&gt;这个模型印证了上述对同步与异步、阻塞与非阻塞的解释。内核准备和拷贝数据的过程中，用户空间程序一直阻塞，所以是阻塞；用户空间是发起io的一方，所以是同步。&lt;/p&gt;
&lt;h3 id=&quot;同步非阻塞&quot;&gt;同步非阻塞&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://pcgo-1255634607.cos.ap-shanghai.myqcloud.com/picgo/2020-10-09/%E5%85%B3%E4%BA%8EIO/%E5%90%8C%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9E.jpg&quot; alt=&quot;同步非阻塞&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;center&gt;同步非阻塞IO模型&lt;/center&gt;
&lt;p&gt;同步非阻塞的特点就是在数据&lt;code&gt;准备阶段&lt;/code&gt;发起io调用会立即&lt;code&gt;返回一个错误&lt;/code&gt;，用户空间需要&lt;code&gt;轮询&lt;/code&gt;发起IO调用。在数据从内核缓冲区&lt;code&gt;拷贝到进程缓冲区&lt;/code&gt;阶段的调用&lt;code&gt;仍然是会被阻塞&lt;/code&gt;的。这种模型需要一直轮询IO状态，用的比较少。&lt;/p&gt;
&lt;h3 id=&quot;io多路复用&quot;&gt;IO多路复用&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://pcgo-1255634607.cos.ap-shanghai.myqcloud.com/picgo/2020-10-09/%E5%85%B3%E4%BA%8EIO/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.jpg&quot; alt=&quot;IO多路复用&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;center&gt;IO多路复用模型&lt;/center&gt;
&lt;p&gt;在IO多路复用模型中，引入了一种&lt;code&gt;新的系统调用&lt;/code&gt;，&lt;code&gt;查询IO的就绪状态&lt;/code&gt;。在Linux系统中，对应的系统调用为&lt;code&gt;select/epoll系统调用&lt;/code&gt;。通过该系统调用，一个进程&lt;code&gt;可以监视多个文件描述符&lt;/code&gt;，&lt;code&gt;一旦某个描述符就绪（一般是内核缓冲区可读/可写），内核能够将就绪的状态返回给应用程序&lt;/code&gt;。随后，应用程序根据就绪的状态，进行相应的IO系统调用。&lt;/p&gt;
&lt;p&gt;————来自《Netty、Redis、Zookeeper高并发实战》&lt;/p&gt;
&lt;p&gt;相比于同步阻塞模型，这种模型的优势在于&lt;code&gt;一个线程能处理大量的IO连接&lt;/code&gt;，而同步阻塞只能靠开很多线程来处理多个IO连接，对于大量的IO连接无能为力。&lt;/p&gt;
&lt;p&gt;如果连接数少的话，同步阻塞并不一定比IO多路复用性能差，因为IO多路复用有两个系统调用，同步阻塞只有一个。&lt;/p&gt;
&lt;h3 id=&quot;信号驱动&quot;&gt;信号驱动&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://pcgo-1255634607.cos.ap-shanghai.myqcloud.com/picgo/2020-10-09/%E5%85%B3%E4%BA%8EIO/%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8IO.jpg&quot; alt=&quot;信号驱动IO&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;center&gt;信号驱动IO模型&lt;/center&gt;
&lt;p&gt;这种IO模型用的不多，java里边找不到对应实现。信号驱动式模型的一个显著特点就是用&lt;code&gt;户态进程不再等待内核态的数据准备好，直接可以去做别的事情&lt;/code&gt;。但是等待数据从内核缓冲区拷贝到进程缓冲区仍然是阻塞的。&lt;/p&gt;
&lt;h3 id=&quot;异步ioaio&quot;&gt;异步IO(AIO)&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://pcgo-1255634607.cos.ap-shanghai.myqcloud.com/picgo/2020-10-09/%E5%85%B3%E4%BA%8EIO/%E5%BC%82%E6%AD%A5IO.jpg&quot; alt=&quot;异步IO&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;center&gt;异步IO模型&lt;/center&gt;
&lt;p&gt;上述几种IO模型&lt;code&gt;本质上都是同步IO&lt;/code&gt;，就算是信号驱动，他在数据从内核缓冲区拷贝到进程缓冲区也是阻塞的。&lt;/p&gt;
&lt;p&gt;AIO的基本流程是：用户线程通过系统调用，向内核注册某个IO操作。内核在整个IO操作（包括数据准备、数据复制）完成后，通知用户程序，用户执行后续的业务操作.&lt;/p&gt;
&lt;p&gt;这种IO模型是完美的IO模型，但是据说Linux&lt;code&gt;支持的不太好&lt;/code&gt;。大名鼎鼎的netty也是使用的多路复用IO模型，还没有使用AIO。&lt;/p&gt;
&lt;h2 id=&quot;java中的io&quot;&gt;java中的IO&lt;/h2&gt;
&lt;h3 id=&quot;bio&quot;&gt;BIO&lt;/h3&gt;
&lt;p&gt;BIO就是Blocking IO, 对应上面说的同步阻塞IO模型。我们常使用的各种InputStream, 这种Reader，以及在网络编程用到的ServerSocket/Socket都是BIO。以一个Socket程序为例来直观感受一下这种模型。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pcgo-1255634607.cos.ap-shanghai.myqcloud.com/picgo/2020-10-09/%E5%85%B3%E4%BA%8EIO/BIO-server.png&quot; alt=&quot;BIO-server&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;center&gt;BIO-server&lt;/center&gt;
&lt;p&gt;&lt;img src=&quot;https://pcgo-1255634607.cos.ap-shanghai.myqcloud.com/picgo/2020-10-09/%E5%85%B3%E4%BA%8EIO/BIO-client.png&quot; alt=&quot;BIO-client&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;center&gt;BIO-client&lt;/center&gt;
&lt;p&gt;这两段代码分别展示一个tcp服务端和客户端，实现的功能就是客户端从本地读一个文件发送给服务端，服务端将收到的文件写入磁盘。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;服务端的read方法的调用是阻塞的，这意味着这个服务端同一时刻只能处理一个连接&lt;/code&gt;，这显然不合理，为了解决这个问题，我们可以考虑&lt;code&gt;多线程机制&lt;/code&gt;，主线程只负责接受连接，收到连接就丢进其他线程进行处理，可以每次都开一个线程，也可以考虑使用线程池。如下的代码实现了这个想法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pcgo-1255634607.cos.ap-shanghai.myqcloud.com/picgo/2020-10-09/%E5%85%B3%E4%BA%8EIO/BIO-thread.png&quot; alt=&quot;BIO-thread&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;center&gt;BIO的多线程版本&lt;/center&gt;
&lt;h3 id=&quot;nio&quot;&gt;NIO&lt;/h3&gt;
&lt;p&gt;NIO，可以说是java中的新IO（New IO), 也可以叫None-Blocking IO, 他对应的是前文提到的&lt;code&gt;多路复用IO模型&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;NIO包括三个核心成员，Buffer、Channel、Selector, 后文会做详细介绍。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里简单对比一下NIO和BIO：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;NIO&lt;/th&gt;
&lt;th&gt;BIO&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;面向缓冲区&lt;/td&gt;
&lt;td&gt;面向流&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;非阻塞&lt;/td&gt;
&lt;td&gt;阻塞&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;基于通道的双向数据流&lt;/td&gt;
&lt;td&gt;单向数据流&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;有Selector的概念&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;上边BIO的例子可以看到BIO是面向流的，NIO是面向缓冲区的，可以任务他的数据是一块一块的，通过后文的例子可以更清楚的看到这一点。&lt;/p&gt;
&lt;p&gt;BIO都是阻塞的，也是就内核在准备数据拷贝数据阶段，用户空间发起IO的进程没法干别的事。NIO是可以是非阻塞的，他可以通过注册你感兴趣的事件（比如可读）到Selector中，然后干别的事（比如接收新的连接），当收到相应事件后再做处理。&lt;/p&gt;
&lt;p&gt;NIO有一个通道的概念，&lt;code&gt;既可以向通道里写数据也可以从里边读&lt;/code&gt;。但是BIO就不行，只能从输入流里边读数据，不能写；也只能往输出流写数据，而不能从里边读。&lt;/p&gt;
&lt;h3 id=&quot;aio&quot;&gt;AIO&lt;/h3&gt;
&lt;p&gt;对应前文提到的异步IO模型，这种模型支持不太好，JAVA AIO框架在windows下使用windows IOCP技术，在Linux下使用epoll多路复用IO技术模拟异步IO。鼎鼎大名的netty也没有使用AIO，所以这里也不去深入探究了。&lt;/p&gt;
&lt;h2 id=&quot;nio基础详解&quot;&gt;NIO基础详解&lt;/h2&gt;
&lt;h3 id=&quot;buffer&quot;&gt;Buffer&lt;/h3&gt;
&lt;p&gt;Buffer是一个抽象类，可以认为是一个&lt;code&gt;装数据的容器&lt;/code&gt;，底层是数组。他有很多子类：&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ByteBuffer&lt;/li&gt;
&lt;li&gt;CharBuffer&lt;/li&gt;
&lt;li&gt;ShortBuffer&lt;/li&gt;
&lt;li&gt;IntBuffer&lt;/li&gt;
&lt;li&gt;LongBuffer&lt;/li&gt;
&lt;li&gt;FloatBuffer&lt;/li&gt;
&lt;li&gt;DoubleBuffer&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;使用最多的是ByteBuffer&lt;/p&gt;
&lt;p&gt;Buffer的基本结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pcgo-1255634607.cos.ap-shanghai.myqcloud.com/picgo/2020-10-09/%E5%85%B3%E4%BA%8EIO/Buffer%E7%9A%84%E7%BB%93%E6%9E%84.png&quot; alt=&quot;Buffer的结构&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;center&gt;Buffer的结构&lt;/center&gt;
&lt;p&gt;这几个属性的含义是必须要搞清楚的，这里简单列举，后文讨论Buffer的基本操作会做进一步说明。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;position: 表示当前正在读的位置&lt;/li&gt;
&lt;li&gt;limit: 表示可以读取或者写入的上限位置，只有&lt;code&gt;小于&lt;/code&gt;这个值的位置才是有效的&lt;/li&gt;
&lt;li&gt;capacity: 容量，&lt;code&gt;不是字节数，而是能装几个数据&lt;/code&gt;，与每个数据占用的字节数无关，&lt;code&gt;创建时确定，不能再改变&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;mark: 一个标记位置，可以方便的回到这个位置&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;buffer的基本操作：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;put(): 向缓冲区存数据&lt;/li&gt;
&lt;li&gt;get(): 从缓冲区取数据&lt;/li&gt;
&lt;li&gt;flip(): 切换到读取数据的模式&lt;/li&gt;
&lt;li&gt;rewind()：position回到起始位置，可以重复读&lt;/li&gt;
&lt;li&gt;clear()： 清空缓冲区，但是数据仍然存在，limit，position回到最初状态&lt;/li&gt;
&lt;li&gt;hasRemaining()：判断是否还有数据可以读&lt;/li&gt;
&lt;li&gt;remaining()：剩余几个数据可以读&lt;/li&gt;
&lt;li&gt;mark():标记当前操作的位置&lt;/li&gt;
&lt;li&gt;reset(): 回到之前标记的位置&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们直接通过一个demo来说明这些操作:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pcgo-1255634607.cos.ap-shanghai.myqcloud.com/picgo/2020-10-09/%E5%85%B3%E4%BA%8EIO/%E6%B5%8B%E8%AF%95Buffer.png&quot; alt=&quot;测试Buffer&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;center&gt;Buffer的基本操作&lt;/center&gt;
&lt;p&gt;输出如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;创建后：
position=0,capacity=10,limit=10
写入一个数据后：
position=2,capacity=10,limit=10
切换为读模式后：
position=0,capacity=10,limit=2
读取一个数据:1
position=1,capacity=10,limit=2
调用rewind:
position=0,capacity=10,limit=2
再次读一个数据：
position=1,capacity=10,limit=2
调用Buffer.clear后
position=0,capacity=10,limit=10
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过这个测试可以看出各种操作的基本使用及其对Buffer几个属性的影响。&lt;/p&gt;
&lt;p&gt;直接缓冲区与非直接缓冲区：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;非直接缓冲区：通过allocate()分配的缓冲区，将缓冲区建立在jvm的内存中&lt;/li&gt;
&lt;li&gt;直接缓冲区：通过allocateDirect()分配的缓冲区，将缓冲区建立在物理内存中，zero copy&lt;/li&gt;
&lt;li&gt;可以通过isDirect()判断是否是直接缓冲区&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;channel&quot;&gt;Channel&lt;/h3&gt;
&lt;p&gt;NIO中的一个连接用一个通道表示，通道本身并不存放数据，只能与Buffer交互。&lt;/p&gt;
&lt;h4 id=&quot;常见的通道：&quot;&gt;常见的通道：&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;FileChannel: 用于读写文件的通道&lt;/li&gt;
&lt;li&gt;SocketChannel：用于Socket套接字TCP连接的数据读写&lt;/li&gt;
&lt;li&gt;ServerSocketChannel：允许我们监听TCP连接请求，为每个监听到的请求，创建一个SocketChannel套接字通道&lt;/li&gt;
&lt;li&gt;DatagramChannel：用于UDP协议的数据读写&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;通道的获取方法：&quot;&gt;通道的获取方法：&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;通过支持通道的类的getChannel方法&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;本地io：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;FileInputStream&lt;/li&gt;
&lt;li&gt;FileOutputStream&lt;/li&gt;
&lt;li&gt;RandomAccessFile&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;fileInputStream.getChannel();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;网络io：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Socket&lt;/li&gt;
&lt;li&gt;ServerSocket&lt;/li&gt;
&lt;li&gt;DatagramSocket&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;socket.getChannel();
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;使用各个通道的静态方法open()获取，jdk&amp;gt;=1.7&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;FileChannel fileChannel = FileChannel.open(Paths.get(&quot;a.jpg&quot;), StandardOpenOption.READ);
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;使用Files的newByteChannel()获取，jdk&amp;gt;=1.7&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;SeekableByteChannel byteChannel = Files.newByteChannel(Paths.get(&quot;a.jpg&quot;), StandardOpenOption.WRITE);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;通道的基本操作&quot;&gt;通道的基本操作&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;读：将通道里的数据读到buffer里，返回值表示读取到的数据个数，返回0表示没有了。此方法还有几个重载&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;public int read(ByteBuffer dst) throws IOException
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;写: 将buffer写入通道，也有几个重载&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt; public int write(ByteBuffer src) throws IOException
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;获取当前通道的大小，单位byte&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;public abstract long size() throws IOException
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;将一个通道的数据发送到另一个通道&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;public long transferTo(long position, long count,
                                    WritableByteChannel target)
        throws IOException;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;上述反向&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;public long transferFrom(ReadableByteChannel src,
                                      long position, long count)
        throws IOException;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;6&quot;&gt;&lt;li&gt;关闭通道&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;public final void close() throws IOException
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此外还有内存映射文件、锁相关内容。限于篇幅，此处不再展开，之后可能专门写一篇探讨。&lt;/p&gt;
&lt;h3 id=&quot;selector&quot;&gt;Selector&lt;/h3&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;我们可以将一个通道注册到Selector中，并且指定你感兴趣的事件（可以是多个，中间用|）。通过不断调用select选择IO就绪事件，在发生相应事件时会得到一个通知，做后续处理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;选择器的使命是完成IO的多路复用。一个通道代表一条连接通路，通过选择器可以同时监控多个通道的IO（输入输出）状况。选择器和通道的关系，是监控和被监控的关系。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里还涉及到SelectionKey的概念，SelectionKey选择键就是那些被选择器选中的IO事件。&lt;/p&gt;
&lt;p&gt;主要方法：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;打开一个Selector&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;public static Selector open() throws IOException
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;获取SelectionKey&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;public Set&amp;lt;SelectionKey&amp;gt; selectedKeys();
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;选择感兴趣的IO就绪事件&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;1. public int select(long timeout)
        throws IOException;
2. public int select() throws IOException;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;关闭Selector&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;public void close() throws IOException;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;NIO涉及的概念和API较多，下面通过一个具体的例子简单演示（移除了异常处理、关闭通道或连接的操作）&lt;/p&gt;
&lt;p&gt;IO事件：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;（1）可读：SelectionKey.OP_READ&lt;/li&gt;
&lt;li&gt;（2）可写：SelectionKey.OP_WRITE&lt;/li&gt;
&lt;li&gt;（3）连接：SelectionKey.OP_CONNECT&lt;/li&gt;
&lt;li&gt;（4）接收：SelectionKey.OP_ACCEPT&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;并不是所有Channel都支持这几个事件，例如ServerSocketChannel只支持OP_ACCEPT&lt;/p&gt;
&lt;h3 id=&quot;一个nio传文件的例子&quot;&gt;一个NIO传文件的例子&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
    * 移除了一些关闭通道的代码，可能无法运行
    * 正常应该在try finally关闭， 或者使用try with resources语法自动关闭
    * @throws IOException
    */
@Test
public void server() throws IOException {
    // 获得channel
    ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
    // 绑定端口
    serverSocketChannel.bind(new InetSocketAddress(1234));
    // 设置为非阻塞，这很重要!!!
    serverSocketChannel.configureBlocking(false);
    // 打开Selector
    Selector selector = Selector.open();
    // 将通道注册到Selector
    serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);
    int i = 0;
    while (selector.select() &amp;gt; 0) { // 轮询选择感兴趣的io事件
        // 拿到选择键
        Iterator&amp;lt;SelectionKey&amp;gt; iterator = selector.selectedKeys().iterator();
        while (iterator.hasNext()) { // 遍历选择键，对特定时间做处理， 可以单独去开线程处理
            SelectionKey key = iterator.next();
            if (key.isAcceptable()) { // 处理接收事件
                ServerSocketChannel serverChannel = (ServerSocketChannel) key.channel();
                SelectableChannel channel = serverChannel.accept();
                channel.configureBlocking(false);
                // 将客户端连接的SocketChannel也进行注册
                channel.register(selector, SelectionKey.OP_READ);
            } else if (key.isReadable()) { // 处理读事件
                ByteBuffer buffer = ByteBuffer.allocate(1 * mb);
                SocketChannel clientChannel = (SocketChannel) key.channel();
                FileChannel fileChannel = FileChannel.open(Paths.get(path, &quot;qrcode&quot; + (++i) + &quot;.png&quot;),
                        StandardOpenOption.WRITE, StandardOpenOption.CREATE);
                int len = -1;
                while ((len = clientChannel.read(buffer)) &amp;gt; 0) {
                    buffer.flip(); // 切换到读模式
                    fileChannel.write(buffer);
                    buffer.clear(); // 切回写模式，别忘了！！
                }
                clientChannel.close();
                fileChannel.close();
            }
            // 处理过的事件一定要移除
            iterator.remove();
        }
    }
}

@Test
public void client() throws IOException {
    // 获取channel
    SocketChannel socketChannel = SocketChannel.open();
    // 连接
    socketChannel.connect(new InetSocketAddress(1234));
    // 设置非阻塞
    socketChannel.configureBlocking(false);
    // 开选择器
    Selector selector = Selector.open();
    // 将channel注册进选择器
    socketChannel.register(selector, SelectionKey.OP_WRITE);
    while (selector.select() &amp;gt; 0) { // 选择感兴趣的事件
        Iterator&amp;lt;SelectionKey&amp;gt; iterator = selector.selectedKeys().iterator();
        while (iterator.hasNext()) {
            SelectionKey key = iterator.next();
            SocketChannel channel = (SocketChannel) key.channel();
            if (key.isWritable()) { // 处理可写事件
                FileChannel fileChannel = FileChannel.open(Paths.get(path, &quot;qrcode.png&quot;), StandardOpenOption.READ);
                ByteBuffer byteBuffer = ByteBuffer.allocate(1 * mb);
                int len = -1;
                while ((len = fileChannel.read(byteBuffer)) &amp;gt; 0) {
                    byteBuffer.flip();
                    channel.write(byteBuffer);
                    byteBuffer.clear();
                }
            }
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;nio使用步骤总结&quot;&gt;NIO使用步骤总结&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;获取Channel&lt;/li&gt;
&lt;li&gt;打开Selector&lt;/li&gt;
&lt;li&gt;将channel注册到Selector&lt;/li&gt;
&lt;li&gt;轮询感兴趣的事件&lt;/li&gt;
&lt;li&gt;遍历SelectionKey并最不同事件类型做相应处理&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;NIO的难度确实比BIO高不少，而且上述只是一个简单的例子，而且可能存在问题，实际中会比这里复杂的多，比如粘包拆包、序列化之类的问题。正因如此，才有了Netty，Netty有非常广泛的应用，比如Dubbo底层、RocketMQ等等。Netty是后边需要和大家一起研究的话题。&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;本文介绍了5种IO模型，同步阻塞、同步非阻塞、多路复用、信号驱动、异步；然后介绍了java中的三种IO模型；最后对NIO的基础支持点做了简单介绍。期望能帮助你复习或者了解相关知识点，疏漏之处，请不吝指出。IO之路，道阻且长，加油~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pcgo-1255634607.cos.ap-shanghai.myqcloud.com/picgo/2020-10-09/%E5%85%B3%E4%BA%8EIO/IO%E5%B0%8F%E7%BB%93.png&quot; alt=&quot;IO小结&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://pcgo-1255634607.cos.ap-shanghai.myqcloud.com/picgo/2020-10-09/%E5%85%B3%E4%BA%8EIO/%E5%BA%95%E9%83%A8%E5%BC%95%E5%AF%BC-%E5%8D%9A%E5%AE%A2%E5%9B%AD%E9%A3%8E%E6%A0%BC.png&quot; alt=&quot;大雄和你一起学编程&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Fri, 09 Oct 2020 14:59:00 +0000</pubDate>
<dc:creator>大~熊</dc:creator>
<og:description>本文将简单介绍Linux的5大IO模型以及java中的3大IO模型，并介绍java的NIO的基础知识点</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/floor/p/13789402.html</dc:identifier>
</item>
</channel>
</rss>