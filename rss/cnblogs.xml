<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>C#位运算实际作用之操作整型某一位 - 张林-布莱恩特</title>
<link>http://www.cnblogs.com/zhangmumu/p/10805312.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangmumu/p/10805312.html</guid>
<description>&lt;h3 id=&quot;前言&quot;&gt;1.前言&lt;/h3&gt;
&lt;p&gt;前几天写了两篇关于c#位运算的文章&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/zhangmumu/p/10793689.html&quot;&gt;c#位运算基本概念与计算过程&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/zhangmumu/p/10793689.html&quot;&gt;C#位运算实际运用&lt;/a&gt;&lt;br/&gt;在文中也提到了位运算的实际作用之一就是合并整型，当时引用了一个问题：&lt;br/&gt;C# 用两个short，一个int32拼成一个long型，高16位用short，中间32位用int，最低16位用另外一个short。&lt;br/&gt;答案如下：&lt;br/&gt;高16位shortA、中间32位intA、低16位shortB&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;longResult=((long)shortA &amp;lt;&amp;lt; 48 )+ ((long)intA &amp;lt;&amp;lt; 16)+ shortB&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据longResult获取前16位shortA，中间32位intA，后16位shortB&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    shortA=(short)(longResult&amp;gt;&amp;gt;48)
    intA=(int)((longResult&amp;gt;&amp;gt;16)&amp;amp;0xFFFFFFFF)
    shortB=(short)(longResult&amp;amp;0xFFFF)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;评论者pushouli、czd890 评论到，合并这个long类型的结果是使用加法计算，可以使用位逻辑或运算，想了想确实使用| 位逻辑或运算也是可以解决问题的，能够实现相互转换。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;


&lt;p&gt;@ pushouli 用+ 和 | 在这里性能上应该没有太大区别。 但是感觉用 | 更能表达意思一些&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;longResult=(((long)shortA &amp;lt;&amp;lt; 48) |((long)intA &amp;lt;&amp;lt; 16)) | (long)shortB&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;1|0=1、1|1=1、0|0=0&lt;/p&gt;
&lt;p&gt;其计算结果longResult是一样的，运算方式不一样，其计算过程可以看看前面写的一篇&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/zhangmumu/p/10793689.html&quot;&gt;C#位运算实际运用&lt;/a&gt;&lt;br/&gt;如图：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190502001424780.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tlYmkwMDc=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;这篇文章就将记录两个知识点：&lt;br/&gt;1.负数的二进制位表示法&lt;br/&gt;2.位运算如何直接操作Int类型某一位&lt;/p&gt;
&lt;h3 id=&quot;负数的二进制位表示法&quot;&gt;2.负数的二进制位表示法&lt;/h3&gt;
&lt;p&gt;原码：一个整数按照绝对值的大小转换成的二进制数，称为原码&lt;br/&gt;一个short 16位的整数9的原码是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;0000    0000    0000    1001&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;反码：一个二进制数按位取反，所得的二进制数成为原二进制数的反码&lt;br/&gt;取9的二进制数的反码，可以使用位逻辑非运算 ~&lt;br/&gt;取反后的16位二进制&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1111    1111    1111    0110&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;补码：反码加1称为补码，简而言之，要得到一个属的补码，先得到这个数的反码，然后再将反码加上1，所得数称为补码&lt;br/&gt;那么9的补码也就是&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1111    1111    1111    0110&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;加上1的结果，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1111    1111    1111    0111&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;即-9的16位二进制表示是&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1111    1111    1111    0111&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如图：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190502143637956.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tlYmkwMDc=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;cint有符号的和无符号的区别&quot;&gt;3.c#Int有符号的和无符号的区别&lt;/h3&gt;
&lt;p&gt;话不多说，直接明确三点结论：&lt;br/&gt;1.实际开发中，都用的是有符号的Int（应该默认强制要求），只有整型有有无符号的特征，Double、Decimal，是没有这种特征的。&lt;br/&gt;2.无符号数中，所有的位都用于直接表示该值的大小。&lt;br/&gt;3.有符号数中，最高位用于表示正负。&lt;br/&gt;这里还是简单地啰嗦几句关于有符号和无符号的区别，UInt32和Int32的区别&lt;br/&gt;这里说的Int指的是32位有符号的类型&lt;br/&gt;Int32的值范围是 -2147483648 至2147483647，也就是&lt;br/&gt;-2的31次方到2的31次方-1&lt;br/&gt;符号位表示的意义就在于此，最前面的位表示正负。&lt;/p&gt;
&lt;p&gt;-2148483648的32位二进制是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1000    0000    0000    0000    0000    0000    0000    0000&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2147483647的32位二进制是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;0111    1111    1111    1111    1111    1111    1111    1111&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么c#中UInt32的最大值是什么呢？&lt;br/&gt;UInt32的范围是0到2的32次方4294967295，最大值32位二进制是&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1111    1111    1111    1111    1111    1111    1111    1111&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以得出结论无符号只能表示正数，有符号可以表示正负数。&lt;br/&gt;如图：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190503132833247.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tlYmkwMDc=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;cint如何直接操作每一位&quot;&gt;4.c#Int如何直接操作每一位&lt;/h3&gt;
&lt;p&gt;前面已经说到，Int表示的是有符号的，最高位表示的正负，一个Int有32位，虽然我们可以直接操作这32位，但是如果直接操作明显会改变数据类型的正负、最大范围。&lt;br/&gt;这里写了一个泛型的示例，操作整型（int、short、long）的每一位。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;     /// &amp;lt;summary&amp;gt;
        /// Int16\Int32\Int64类型
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;returns&amp;gt;true 1\false 0的集合&amp;lt;/returns&amp;gt;
        public static IEnumerable&amp;lt;bool&amp;gt; GetIntOfBitList&amp;lt;T&amp;gt;(T  intVal)
        {
            Type intType = intVal.GetType();
            byte bitlength = 0;
            if (intType == typeof(Int32))
                bitlength = 32;
            else if (intType == typeof(Int16))
                bitlength = 16;
            else if (intType == typeof(Int64))
                bitlength = 64;
            else
                throw new ArgumentException(&quot;必须是整型&quot;);

            object intOject = (object)intVal;
            var resultList = new List&amp;lt;bool&amp;gt;(bitlength);
            for (var i = 0; i &amp;lt; bitlength; i++)
            {
                var temoIntBit = 1 &amp;lt;&amp;lt; i;
                if (intType == typeof(Int32))
                    resultList.Add((((Int32)intOject) &amp;amp; temoIntBit) == temoIntBit);
                if (intType == typeof(Int16))
                    resultList.Add((((Int16)intOject) &amp;amp; temoIntBit) == temoIntBit);
                if (intType == typeof(Int64))
                    resultList.Add((((Int64)intOject) &amp;amp; temoIntBit) == temoIntBit);
            }
            return resultList;
        }
        /// &amp;lt;summary&amp;gt;
        /// 获取T整型中某一位的值
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;typeparam name=&quot;T&quot;&amp;gt;泛型类型包括int\short\long&amp;lt;/typeparam&amp;gt;
        /// &amp;lt;param name=&quot;intVal&quot;&amp;gt;int\short\long&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;index&quot;&amp;gt;从右到左0-T的总位数&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;true:1\false:0&amp;lt;/returns&amp;gt;
        public static bool GetBitValue&amp;lt;T&amp;gt;(T  intVal,byte index)
        {
            Type intType = intVal.GetType();
            byte bitlength = 0;
            if (intType == typeof(Int32))
                bitlength = 32;
            else if (intType == typeof(Int16))
                bitlength = 16;
            else if (intType == typeof(Int64))
                bitlength = 64;
            else
                throw new ArgumentException(&quot;必须是整型&quot;);

            if (index &amp;gt; bitlength-1 || index &amp;lt; 1)
                throw new ArgumentOutOfRangeException(&quot;index&quot;);

            object intOject = (object)intVal;
            var tempBit = 1 &amp;lt;&amp;lt; index;

            if (intType == typeof(Int32))
                return (((int)intOject) &amp;amp; tempBit) == tempBit;
            else if (intType == typeof(Int16))
                return (((Int16)intOject) &amp;amp; tempBit) == tempBit;
            else
                return (((Int64)intOject) &amp;amp; tempBit) == tempBit;
        }
        /// &amp;lt;summary&amp;gt;
        /// 设置整型数据中某一位的值
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;typeparam name=&quot;T&quot;&amp;gt;int\short\long&amp;lt;/typeparam&amp;gt;
        /// &amp;lt;param name=&quot;intVal&quot;&amp;gt;设置前的值&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;index&quot;&amp;gt;从右到左0-T的总位数&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;bitValue&quot;&amp;gt;需要设置的值 true:1\false:0&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;设置位值后新的整型&amp;lt;/returns&amp;gt;
        public static T SetBitValue&amp;lt;T&amp;gt;(T intVal,byte index,bool bitValue)
        {
            Type intType = intVal.GetType();
            byte bitlength = 0;
            if (intType == typeof(Int32))
                bitlength = 32;
            else if (intType == typeof(Int16))
                bitlength = 16;
            else if (intType == typeof(Int64))
                bitlength = 64;
            else
                throw new ArgumentException(&quot;必须是整型&quot;);
            //不能去设置最高位
            if (index &amp;gt;= bitlength-1 || index &amp;lt; 1)
                throw new ArgumentOutOfRangeException(&quot;index&quot;);

            object intOject = (object)intVal;
            var tempBit = 1 &amp;lt;&amp;lt; index;

            if (intType == typeof(Int32))
            {
                int tempInt = (int)intOject;
                return (T)((bitValue ? (tempInt | tempBit) : (tempInt &amp;amp; ~tempBit)) as Object);
            }
            else if (intType == typeof(Int16))
            {
                Int16 tempInt = (Int16)intOject;
                return (T)((bitValue ? (tempInt | tempBit) : (tempInt &amp;amp; ~tempBit)) as Object);
            }
            else
            {
                Int64 tempInt = (Int64)intOject;
                return (T)((bitValue ? (tempInt | tempBit) : (tempInt &amp;amp; ~tempBit)) as Object);
            }
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试截图：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190503151706230.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tlYmkwMDc=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;思考：这个方法能操作负数吗？&lt;/p&gt;
</description>
<pubDate>Fri, 03 May 2019 07:22:00 +0000</pubDate>
<dc:creator>张林-布莱恩特</dc:creator>
<og:description>1.实际开发中，都用的是有符号的Int（应该默认强制要求），只有整型有有无符号的特征，Double、Decimal，是没有这种特征的。 2.无符号数中，所有的位都用于直接表示该值的大小。 3.有符</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhangmumu/p/10805312.html</dc:identifier>
</item>
<item>
<title>Node学习之（第二章：http模块） - pubdreamcc</title>
<link>http://www.cnblogs.com/dreamcc/p/10805263.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dreamcc/p/10805263.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;继续上一节的探讨，今天我们来聊聊Node中怎么搭建一个简单的web服务器。平时大家在撸码的过程中，经常需要向服务器发送请求，然后服务器接受请求，响应数据。今天我们就来自己手写一个简单服务器，根据前端请求，我们来响应相关数据。&lt;/p&gt;
&lt;h2 id=&quot;开始&quot;&gt;开始&lt;/h2&gt;
&lt;p&gt;开启一个本地服务器需要Node.js中&lt;code&gt;http&lt;/code&gt;核心模块，至于核心模块是什么，我会在接下来的章节中和大家解释，也欢迎大家持续关注我的前端Node.js的学习之旅。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;http--模块提供了搭建本地服务器的API,首先我们在项目中引入；&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;let http = require('http')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;引入之后我们利用http.createServer()方法得到一个服务器实例。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let server = http.createServer() // createServer()方法返回一个server实例，所以我们需要一个变量来接收
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;经过以上两步，我们已经搭建好了一个服务器实例，然后我们给服务器实例绑定接收&lt;code&gt;request&lt;/code&gt;的事情处理函数，代码如下：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;server.on('request', (req, res) =&amp;gt; {
  console.log(req.url) // 获取到请求的路径（请求路径永远以“/”开头）
})

// 给服务器绑定接收请求的处理事件，当服务器接收到客户端发送的请求后，会调用后面的处理函数，处理函数接收两个参数：请求信息对象，响应信息对象。&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;绑定监听端口号，开启服务器。代码如下：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;server.listen(3000, () =&amp;gt; {
  console.log('服务器开启成功，可以通过访问http://127.0.0.1:3000/来获取数据~~')
})

// server.listen()用来绑定监听的端口号，可以传入第二个参数，当服务器开启成功后，触发后面的回调函数
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;最后看到的效果如下图所示：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1632878/201905/1632878-20190503150212384-1586804758.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们看到请求路径被打印在了CMD窗口中。&lt;/p&gt;
&lt;p&gt;好了，经过这简单的操作是不是已经完成了一个服务器的简单搭建，接下来我们来实现一个需求：&lt;/p&gt;
&lt;p&gt;我们实现这个需求，只需要在绑定服务器监听的事件处理函数中获取到用户的请求路径，然后根据不同路径返回不同数据即可，这个也不难。详情代码看下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let http = require('http')
let server = http.createServer()

server.on('request', (req, res) =&amp;gt; {
  let url = req.url //得到请求的路径 （请求的路径永远以‘/’开头）
  if (url === '/') {
    res.end('index page')
  } else if (url === '/login') {
    res.end('login page')
  } else if (url === '/register') {
    res.end('register page')
  } else if (url === '/product'){
    let arr = [
      {
        name: 'iphone X',
        price: 8888
      },
      {
        name: 'iphone 7',
        price: 4320
      }
    ]
    // 响应的数据类型必须是字符串或者二进制数据
    res.end(JSON.stringify(arr))
  } else {
    res.end('404 NOT found')
  }
})

server.listen(3000, () =&amp;gt; {
  console.log('服务器启动成功了，，可以访问http://127.0.0.1:3000/啦')
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后实现的效果图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1632878/201905/1632878-20190503150310008-45121236.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们看到我们请求不同的路径，服务器给我们返回了不同的内容，并且显示在了网页中。&lt;/p&gt;
&lt;h2 id=&quot;说明&quot;&gt;说明&lt;/h2&gt;
&lt;p&gt;本仓库是自己Node.js学习过程的真实记录，以后会每天更新一些新的知识点，希望可以对想要学Node.js的同学有一些帮助，欢迎star，你们的点赞是我更新的持久动力。同时如果你觉得本仓库中的一些知识点有错误也可以issue我，方便后期我订正！&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;本仓库同时在博客园和掘金更新，欢迎写博客的朋友一起学习交流。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;博客园&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/dreamcc/&quot;&gt;找我&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;掘金&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.im/user/5ca1d53451882543f252db97/posts&quot;&gt;找我&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;GitHub&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/pubdreamcc/Node.js&quot;&gt;找我&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 03 May 2019 07:04:00 +0000</pubDate>
<dc:creator>pubdreamcc</dc:creator>
<og:description>前言 继续上一节的探讨，今天我们来聊聊Node中怎么搭建一个简单的web服务器。平时大家在撸码的过程中，经常需要向服务器发送请求，然后服务器接受请求，响应数据。今天我们就来自己手写一个简单服务器，根据</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dreamcc/p/10805263.html</dc:identifier>
</item>
<item>
<title>Python中property属性详解 - 山楂潴</title>
<link>http://www.cnblogs.com/shanzhazhu/p/10805248.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shanzhazhu/p/10805248.html</guid>
<description>&lt;h3 id=&quot;1-什么是property属性&quot;&gt;1. 什么是property属性&lt;/h3&gt;
&lt;p&gt;一种用起来像是使用的实例属性一样的特殊属性，可以对应于某个方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# ############### 定义 ###############
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo:
    def func(self):
        pass

    # 定义property属性
    @property
    def prop(self):
        pass

# ############### 调用 ###############
foo_obj &lt;/span&gt;=&lt;span&gt; Foo()
foo_obj.func()  # 调用实例方法
foo_obj.prop  # 调用property属性&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;1-什么是property属性&quot;&gt;2.为什么使用property属性&lt;/h3&gt;
&lt;p&gt;在绑定属性时，如果我们直接把属性暴露出去，虽然写起来很简单，但是，没办法检查参数，导致可以把成绩随便改：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
s =&lt;span&gt; Student()
s.score &lt;/span&gt;= &lt;span&gt;9999&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这显然不合逻辑。为了限制score的范围，可以通过一个&lt;code&gt;set_score()&lt;/code&gt;方法来设置成绩，再通过一个&lt;code&gt;get_score()&lt;/code&gt;来获取成绩，这样，在&lt;code&gt;set_score()&lt;/code&gt;方法里，就可以检查参数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt; Student(&lt;span&gt;object&lt;/span&gt;&lt;span&gt;):

    def get_score(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; self._score

    def set_score(self, value):
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; not isinstance(value, &lt;span&gt;int&lt;/span&gt;&lt;span&gt;):
            raise ValueError(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;score must be an integer!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; value &amp;lt; &lt;span&gt;0&lt;/span&gt; or value &amp;gt; &lt;span&gt;100&lt;/span&gt;&lt;span&gt;:
            raise ValueError(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;score must between 0 ~ 100!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        self._score &lt;/span&gt;=&lt;span&gt; value

调用：
s &lt;/span&gt;=&lt;span&gt; Student()
s.set_score(&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;) # ok!&lt;span&gt;
s.get_score()
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;&lt;span&gt;
s.set_score(&lt;/span&gt;&lt;span&gt;9999&lt;/span&gt;&lt;span&gt;)
Traceback (most recent call last):
  ...
ValueError: score must between &lt;/span&gt;&lt;span&gt;0&lt;/span&gt; ~ &lt;span&gt;100&lt;/span&gt;!
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是，上面的调用方法又略显复杂，没有直接用属性这么直接简单。&lt;/p&gt;
&lt;p&gt;有没有既能检查参数，又可以用类似属性这样简单的方式来访问类的变量呢？对于追求完美的Python程序员来说，这是必须要做到的！&lt;/p&gt;
&lt;p&gt;还记得装饰器（decorator）可以给函数动态加上功能吗？对于类的方法，装饰器一样起作用。Python内置的&lt;code&gt;@property&lt;/code&gt;装饰器就是负责把一个方法变成属性调用的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt; Student(&lt;span&gt;object&lt;/span&gt;&lt;span&gt;):

    @property
    def score(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; self._score

    @score.setter
    def score(self, value):
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; not isinstance(value, &lt;span&gt;int&lt;/span&gt;&lt;span&gt;):
            raise ValueError(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;score must be an integer!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; value &amp;lt; &lt;span&gt;0&lt;/span&gt; or value &amp;gt; &lt;span&gt;100&lt;/span&gt;&lt;span&gt;:
            raise ValueError(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;score must between 0 ~ 100!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        self._score &lt;/span&gt;= value
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;@property&lt;/code&gt;的实现比较复杂，我们先考察如何使用。把一个getter方法变成属性，只需要加上&lt;code&gt;@property&lt;/code&gt;就可以了，此时，&lt;code&gt;@property&lt;/code&gt;本身又创建了另一个装饰器&lt;code&gt;@score.setter&lt;/code&gt;，负责把一个setter方法变成属性赋值，于是，我们就拥有一个可控的属性操作：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;调用：
s &lt;/span&gt;=&lt;span&gt; Student()
s.score &lt;/span&gt;= &lt;span&gt;60&lt;/span&gt; # OK，实际转化为s.set_score(&lt;span&gt;60&lt;/span&gt;&lt;span&gt;)
s.score # OK，实际转化为s.get_score()
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;&lt;span&gt;
s.score &lt;/span&gt;= &lt;span&gt;9999&lt;/span&gt;&lt;span&gt;
Traceback (most recent call last):
  ...
ValueError: score must between &lt;/span&gt;&lt;span&gt;0&lt;/span&gt; ~ &lt;span&gt;100&lt;/span&gt;!
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;3-property属性的有两种方式&quot;&gt;3. property属性的有两种方式&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;装饰器 即：在方法上应用装饰器&lt;/li&gt;
&lt;li&gt;类属性 即：在类中定义值为property对象的类属性&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;31-装饰器方式&quot;&gt;3.1 装饰器方式&lt;/h4&gt;
&lt;p&gt;在类的实例方法上应用@property装饰器&lt;/p&gt;

&lt;h4 id=&quot;32-类属性方式，创建值为property对象的类属性&quot;&gt;3.2 类属性方式，创建值为property对象的类属性&lt;/h4&gt;
&lt;p&gt;property方法中有个四个参数&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一个参数是方法名，调用 对象.属性 时自动触发执行方法&lt;/li&gt;
&lt;li&gt;第二个参数是方法名，调用 对象.属性 ＝ XXX 时自动触发执行方法&lt;/li&gt;
&lt;li&gt;第三个参数是方法名，调用 del 对象.属性 时自动触发执行方法&lt;/li&gt;
&lt;li readability=&quot;1.5&quot;&gt;第四个参数是字符串，调用 对象.属性.__doc__ ，此参数是该属性的描述信息
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
#coding=utf-&lt;span&gt;8&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt; Foo(&lt;span&gt;object&lt;/span&gt;&lt;span&gt;):
    def get_bar(self):
        print(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;getter...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;laowang&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

    def set_bar(self, value): 
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;必须两个参数&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        print(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;setter...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;set value&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; +&lt;span&gt; value

    def del_bar(self):
        print(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;deleter...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;laowang&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

    BAR &lt;/span&gt;= property(get_bar, set_bar, del_bar, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;description...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

obj &lt;/span&gt;=&lt;span&gt; Foo()

obj.BAR  # 自动调用第一个参数中定义的方法：get_bar
obj.BAR &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;alex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;  # 自动调用第二个参数中定义的方法：set_bar方法，并将“alex”当作参数传入
desc &lt;/span&gt;=&lt;span&gt; Foo.BAR.__doc__  # 自动获取第四个参数中设置的值：description...
print(desc)
del obj.BAR  # 自动调用第三个参数中定义的方法：del_bar方法&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Fri, 03 May 2019 07:00:00 +0000</pubDate>
<dc:creator>山楂潴</dc:creator>
<og:description>1. 什么是property属性 一种用起来像是使用的实例属性一样的特殊属性，可以对应于某个方法 2.为什么使用property属性 在绑定属性时，如果我们直接把属性暴露出去，虽然写起来很简单，但是，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shanzhazhu/p/10805248.html</dc:identifier>
</item>
<item>
<title>MinHook库的使用 64位下,过滤LoadLibraryExW - iBinary</title>
<link>http://www.cnblogs.com/iBinary/p/10805200.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/iBinary/p/10805200.html</guid>
<description>&lt;h2 id=&quot;一丶简介&quot;&gt;一丶简介&lt;/h2&gt;
&lt;p&gt;minHook库是一个支持x64跟x86HOOK的库.Detours也支持x64.不过是收费的所以在x64下使用minHook也是一个不错的选择.&lt;/p&gt;
&lt;h3 id=&quot;minhook库的下载以及安装.&quot;&gt;1.minHook库的下载以及安装.&lt;/h3&gt;
&lt;p&gt;MinHook 我已经打包了一份.可以在我的百度网盘中下载&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://pan.baidu.com/s/1QJcf5_Q9naL2Y48IN2Y5MQ&quot; class=&quot;uri&quot;&gt;https://pan.baidu.com/s/1QJcf5_Q9naL2Y48IN2Y5MQ&lt;/a&gt;&lt;br/&gt;提取码：ndmq&lt;/p&gt;
&lt;p&gt;当然也可以在Github下载.&lt;br/&gt;库源文件:&lt;br/&gt;&lt;a href=&quot;https://github.com/m417z/minhook&quot; class=&quot;uri&quot;&gt;https://github.com/m417z/minhook&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;解压之后:&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1197364/201905/1197364-20190503141335861-1637575594.png&quot;/&gt;&lt;br/&gt;有4个文件目录&lt;br/&gt;build&lt;br/&gt;dll_resources&lt;br/&gt;include&lt;br/&gt;src&lt;/p&gt;
&lt;p&gt;我们打开build目录&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1197364/201905/1197364-20190503141434048-341896326.png&quot;/&gt;&lt;br/&gt;可以看到从 VC9 - VC15 这个代表VS编译器的版本号.&lt;br/&gt;比如我用的是VS2013.其版本号就是VC12.我们进入文件目录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1197364/201905/1197364-20190503141537036-620286058.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;打开后缀名为.sln或者.vcxproj都可以.&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1197364/201905/1197364-20190503141757166-301277095.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;打开之后如上所示.&lt;br/&gt;一个libMinHook&lt;br/&gt;一个MinHOOK&lt;/p&gt;
&lt;p&gt;libMinHook是生成 lib供我们使用的.&lt;br/&gt;MinHook工程是生成DLL供我们使用的.&lt;/p&gt;
&lt;p&gt;x86编译跟x64编译&lt;br/&gt;比如我们要HOOK的程序是x64程序的话.我这里选择的是生成lib库.&lt;br/&gt;你需要将你的VS配置管理器改成x64.来生成libMinHook的库.&lt;br/&gt;这样你的程序引用x64的lib库.就可以Hookx64程序了.&lt;/p&gt;
&lt;h2 id=&quot;二丶使用minhook库过滤loadlibraryexw&quot;&gt;二丶使用MinHook库,过滤LoadLibraryExW&lt;/h2&gt;
&lt;h3 id=&quot;编写x64测试程序.&quot;&gt;2.1编写X64测试程序.&lt;/h3&gt;
&lt;p&gt;既然我们要使用Hook.那么就编写一个X64程序.这个程序就是加载DLL&lt;br/&gt;代码如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;Windows.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;

int main()
{

    HMODULE hDll;
    
    hDll = LoadLibraryExW(TEXT(&quot;x64Hook.dll&quot;), NULL, 0); //加载HOOK的DLL
    hDll = LoadLibraryExW(TEXT(&quot;kernel32.dll&quot;),NULL,NULL);//判断是否被HOOK

    system(&quot;pause&quot;);
    return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;使用minhook库&quot;&gt;2.2使用MinHook库&lt;/h3&gt;
&lt;p&gt;在使用之前.我们有必要介绍一下 Minhook.h头文件中提供给我的函数声明&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  MH_STATUS WINAPI MH_Initialize(VOID);   //初始化HOOK引擎

  MH_STATUS WINAPI MH_Uninitialize(VOID); //反初始化

  MH_STATUS WINAPI MH_CreateHook(LPVOID pTarget, LPVOID pDetour, LPVOID *ppOriginal);//创建HOOK跳板

  MH_STATUS WINAPI MH_CreateHookApi(                                                 //创建APIhook跳板
        LPCWSTR pszModule, LPCSTR pszProcName, LPVOID pDetour, LPVOID *ppOriginal);

  MH_STATUS WINAPI MH_CreateHookApiEx(                                              //扩展
        LPCWSTR pszModule, LPCSTR pszProcName, LPVOID pDetour, LPVOID *ppOriginal, LPVOID *ppTarget);

  MH_STATUS WINAPI MH_RemoveHook(LPVOID pTarget);                                  //删除HOOK

  MH_STATUS WINAPI MH_EnableHook(LPVOID pTarget);                                  //启动HOOK

  MH_STATUS WINAPI MH_DisableHook(LPVOID pTarget);                                 //结束HOOK
 
  MH_STATUS WINAPI MH_QueueEnableHook(LPVOID pTarget);

  MH_STATUS WINAPI MH_QueueDisableHook(LPVOID pTarget);
 
  MH_STATUS WINAPI MH_ApplyQueued(VOID);
 
  const char * WINAPI MH_StatusToString(MH_STATUS status);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果我们要写成HOOK总共步骤如下;&lt;br/&gt;1.初始化HOOK引擎&lt;br/&gt;2.创建HOOK跳板函数&lt;br/&gt;3.启用HOOK&lt;br/&gt;4.结束HOOK&lt;br/&gt;5.删除HOOK&lt;br/&gt;6.反初始化HOOK引擎&lt;/p&gt;
&lt;p&gt;特别注意创建HOOK跳板函数.我们可以用的接口有 &lt;strong&gt;MB_CreateHook&lt;/strong&gt; &lt;strong&gt;MB_CreateHookApi&lt;/strong&gt; &lt;strong&gt;MB_CreateHookApiEx&lt;/strong&gt;&lt;br/&gt;以第一个为例: 参数1: 你要HOOK的函数的函数指针(&amp;amp;LoadLibraryExW) 参数2:你自定义的函数 (&amp;amp;MyLoadLibraryExW) 参数3:跳板函数指针&lt;/p&gt;
&lt;p&gt;参数3的意思就是 我们的函数内部调用参数3.相当于调用原函数.&lt;/p&gt;
&lt;h3 id=&quot;完整hook代码&quot;&gt;2.3完整HOOK代码&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;// dllmain.cpp : 定义 DLL 应用程序的入口点。
#include &quot;stdafx.h&quot;
#include &quot;MinHook.h&quot;
#include &amp;lt;tchar.h&amp;gt;
#include &amp;lt;windows.h&amp;gt;

#if defined _M_X64
#pragma comment(lib, &quot;libMinHook.x64.lib&quot;)
#elif defined _M_IX86
#pragma comment(lib, &quot;libMinHook.x86.lib&quot;)
#endif


typedef HMODULE (WINAPI *PFNloadLibraryExw)(LPCSTR lpLibFileName, HANDLE hFile, DWORD  dwFlags);  //函数的定义

PFNloadLibraryExw pfnLoadLibraryExW = NULL;

BOOL  HOOK();
BOOL UnHOOK();



void __cdecl MyOutputDebugStrig(const _TCHAR* pszFormat, ...)
{
    _TCHAR buf[1024] = { 0 };
    // ZeroMemory( buf, 1024*sizeof(TCHAR ) );
    swprintf_s(buf, 1024, _T(&quot;线程ID = [%lu]&quot;), GetCurrentThreadId());
    va_list arglist;
    va_start(arglist, pszFormat);
    int nBuffSize = _tcslen(buf);
    vswprintf_s(&amp;amp;buf[nBuffSize], 1024 - nBuffSize, pszFormat, arglist);
    va_end(arglist);
    nBuffSize = _tcslen(buf);
    _tcscat_s(buf, 1024 - nBuffSize, _T(&quot;\n&quot;));
    OutputDebugString(buf);
}

HMODULE WINAPI MyLoadLibraryExW(
    LPCSTR lpLibFileName,
    HANDLE hFile,
    DWORD  dwFlags
    )
{

    MyOutputDebugStrig(TEXT(&quot;已经HOOK过了 LoadLibraryExW函数&quot;));
    return pfnLoadLibraryExW(lpLibFileName,hFile,dwFlags);
}
BOOL APIENTRY DllMain( HMODULE hModule,
                       DWORD  ul_reason_for_call,
                       LPVOID lpReserved
                     )
{
    switch (ul_reason_for_call)
    {
    case DLL_PROCESS_ATTACH:
        HOOK();
        break;
    case DLL_THREAD_ATTACH:
        break;

    case DLL_THREAD_DETACH:
        break;

    case DLL_PROCESS_DETACH:
        UnHOOK();
        break;
    }
    return TRUE;
}

BOOL  HOOK()
{
    //初始化MinHOOK HOOK他的函数
    if (MH_Initialize() != MH_OK)
    {
        MyOutputDebugStrig(TEXT(&quot;MH_Initialize Error&quot;));
        return FALSE;
    }

    // Create a hook for MessageBoxW, in disabled state.

    if (MH_CreateHook(&amp;amp;LoadLibraryExW, &amp;amp;MyLoadLibraryExW,        //创建HOOK

        reinterpret_cast&amp;lt;void**&amp;gt;(&amp;amp;pfnLoadLibraryExW)) != MH_OK)
    {
        MyOutputDebugStrig(TEXT(&quot;MH_CreateHook Error&quot;));

        return FALSE;
    }

    // Enable the hook for MessageBoxW.

    if (MH_EnableHook(&amp;amp;LoadLibraryExW) != MH_OK)            //启动HOOK
    {
        MyOutputDebugStrig(TEXT(&quot;MH_EnableHook Error&quot;));

        return FALSE;
    }

    
    return TRUE;
    
}


BOOL UnHOOK()
{

    // Disable the hook for MessageBoxW.
    if (MH_DisableHook(&amp;amp;MessageBoxW) != MH_OK)
    {


        MyOutputDebugStrig(TEXT(&quot;MH_DisableHook Error&quot;));
        return FALSE;
    }

    // Expected to tell &quot;Not hooked...&quot;.


    // Uninitialize MinHook.
    if (MH_Uninitialize() != MH_OK)
    {

        MyOutputDebugStrig(TEXT(&quot;MH_Uninitialize Error&quot;));
        return FALSE;
    }


}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意这个dll 是64的.我们要HOOK的是测试程序中的LoadLibraryExW函数.&lt;/p&gt;
&lt;p&gt;结果:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1197364/201905/1197364-20190503144031262-1112409334.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样说明我们的DLL已经起作用了.我们的测试程序加载我们的x64HookDLL.而我们的X64HookDLL则会进行HOOK.&lt;/p&gt;
&lt;p&gt;代码链接:&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://pan.baidu.com/s/1A-eyJ_CxvptYeerqKKHHyg&quot; class=&quot;uri&quot;&gt;https://pan.baidu.com/s/1A-eyJ_CxvptYeerqKKHHyg&lt;/a&gt;&lt;br/&gt;提取码：iayb&lt;/p&gt;
</description>
<pubDate>Fri, 03 May 2019 06:45:00 +0000</pubDate>
<dc:creator>iBinary</dc:creator>
<og:description>[toc] MinHook库的使用 x64 一丶简介 minHook库是一个支持x64跟x86HOOK的库.Detours也支持x64.不过是收费的所以在x64下使用minHook也是一个不错的选择.</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/iBinary/p/10805200.html</dc:identifier>
</item>
<item>
<title>如何通过 IntelliJ IDEA 来提升 Java8 Stream 的编码效率 - 犬小哈</title>
<link>http://www.cnblogs.com/quanxiaoha/p/10805059.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/quanxiaoha/p/10805059.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155686156436658&quot; title=&quot;如何通过 IntelliJ IDEA 来提升 Java8 Stream 的编码效率&quot; alt=&quot;如何通过 IntelliJ IDEA 来提升 Java8 Stream 的编码效率&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6.6120218579235&quot;&gt;
&lt;p&gt;本文翻译整理自：&lt;a href=&quot;https://winterbe.com/posts/2015/03/05/fixing-java-8-stream-gotchas-with-intellij-idea/&quot;&gt;https://winterbe.com/posts/2015/03/05/fixing-java-8-stream-gotchas-with-intellij-idea&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者：@Winterbe&lt;br/&gt;欢迎关注个人微信公众号: &lt;strong&gt;小哈学Java&lt;/strong&gt;, 文末&lt;strong&gt;分享阿里 P8 资深架构师吐血总结的 《Java 核心知识整理&amp;amp;面试.pdf》资源链接&lt;/strong&gt;！！&lt;br/&gt;个人网站: &lt;a href=&quot;https://exception.site/java8/java8-improve-stream-byidea-tips&quot; class=&quot;uri&quot;&gt;https://exception.site/java8/java8-improve-stream-byidea-tips&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;小哈再次推荐一篇 @Winterbe 的译文，主要是讲如何通过 IntelliJ IDEA 来提升 Stream 的编码效率，算是一个小技巧，经常使用 Java8 Stream 流的小伙伴们，可以试下，能够提升工作效率哦！&lt;/p&gt;
&lt;blockquote readability=&quot;4&quot;&gt;
&lt;p&gt;PS: 在阅读本文前，建议您先阅读一下小哈的另一篇译文：&lt;a href=&quot;https://exception.site/java8/java8-stream-tutorial&quot;&gt;《Java8 新特性 Stream 流教程》&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155685877793063&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;目录&quot;&gt;目录&lt;/h2&gt;
&lt;h2 id=&quot;一java8-stream-api-的不友好性&quot;&gt;一、Java8 Stream API 的不友好性&lt;/h2&gt;
&lt;p&gt;Java8 自 2014 年 3 月发布以来，已经过去很多个年头了。在我们公司内部，也已逐渐将所有的生产代码迁移到这个版本。迁移中，我们主要所做的工作就是，将代码库更新为 lambda 表达式，Steam 流和新的日期 API。另外，我们还使用 &lt;a href=&quot;https://winterbe.com/posts/2014/04/05/java8-nashorn-tutorial/&quot;&gt;Nashorn&lt;/a&gt; 动态编写那些可能在运行时需要被更改的功能。&lt;/p&gt;
&lt;p&gt;除了 lambda 表达式外，最常用的一个功能就是新的 Stream API 了，它可以被用来很方便地操作集合。此外，Stream 还可以很大的提高操作集合代码的可读性。&lt;/p&gt;
&lt;p&gt;但是，关于 Stream 流, 有一件事真的让我很困扰！&lt;/p&gt;
&lt;p&gt;在使用 Stream 流时，类似&lt;code&gt;reduce&lt;/code&gt;和&lt;code&gt;findFirst&lt;/code&gt;这样的终端操作，语义都是简单明了，也很直接，我们无需再额外传参。&lt;/p&gt;
&lt;p&gt;而另一类我们使用比较多的终端操作： &lt;code&gt;collect&lt;/code&gt; 用起来就很繁琐了，如我们要转换成 &lt;code&gt;List&lt;/code&gt; 的时候，我们的写法一般是这样的：&lt;code&gt;.collect(Collectors.toList())&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;例如，下面这段代码对字符串集合进行过滤，并转成一个新的集合：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;stringCollection
    .stream()
    .filter(e -&amp;gt; e.startsWith(&quot;a&quot;))
    .collect(Collectors.toList());&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;又比如，我们要转换成 &lt;code&gt;Set&lt;/code&gt; 的时候，需要写成这样：&lt;code&gt;.collect(Collectors.toSet())&lt;/code&gt;，还有 &lt;code&gt;joining&lt;/code&gt; 和 &lt;code&gt;groupingBy&lt;/code&gt;之类。&lt;/p&gt;
&lt;p&gt;在我完成对 30 万行代码 &lt;code&gt;steam&lt;/code&gt;流的迁移后，我总结了一下，&lt;code&gt;toList&lt;/code&gt;, &lt;code&gt;toSet&lt;/code&gt; 和 &lt;code&gt;groupingBy&lt;/code&gt; 是我们项目目前最常用的终端操作。我无法理解 JDK 的设计者们为什么不对 &lt;code&gt;collect&lt;/code&gt; 方法再简化一下，以让它更人性化一些，比如同样的一段代码，为什么不设计成下面这样：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;stringCollection
    .stream()
    .filter(e -&amp;gt; e.startsWith(&quot;a&quot;))
    .toList();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为没有设计成这样，导致我们在代码中不得不一遍又一遍地使用 &lt;code&gt;Collectors.toXXX&lt;/code&gt;, 这就烦躁了。&lt;/p&gt;
&lt;h2 id=&quot;二借助-intellij-idea-来优化一下&quot;&gt;二、借助 IntelliJ IDEA 来优化一下&lt;/h2&gt;
&lt;p&gt;IntelliJ IDEA 号称宇宙最智能 Java IDE, 看看我们如何通过它来解决这个愁人的问题。&lt;/p&gt;
&lt;p&gt;IntelliJ IDEA 附带了一个名为 &lt;code&gt;Live Templates&lt;/code&gt;(实时模板) 的便捷功能。这是个啥玩意？即使您还不知道它是什么, 但是你也一定经常使用到它。比如输入常用代码段的快捷方式 &lt;code&gt;sout&lt;/code&gt;，IDEA 会插入代码段&lt;code&gt;System.out.println()&lt;/code&gt;。又比如，输入 &lt;code&gt;psvm&lt;/code&gt;, IDEA 会快速帮您生成 &lt;code&gt;main&lt;/code&gt; 方法等。&lt;/p&gt;
&lt;blockquote readability=&quot;4.4230769230769&quot;&gt;
&lt;p&gt;PS: 阅读&lt;a href=&quot;https://www.jetbrains.com/idea/help/live-templates.html&quot;&gt;此处&lt;/a&gt;以了解有关它的更多信息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155685854181590&quot;/&gt;&lt;/p&gt;
&lt;p&gt;哦，就这玩意？&lt;/p&gt;
&lt;p&gt;那要怎么通过 &lt;code&gt;Live Templates&lt;/code&gt;(实时模板) 来解决前面提到的痛点呢？&lt;/p&gt;
&lt;h3 id=&quot;新建-stream-live-templates&quot;&gt;2.1 新建 Stream Live Templates&lt;/h3&gt;
&lt;p&gt;1.按步骤打开 &lt;strong&gt;File -&amp;gt; Setting -&amp;gt; Editor -&amp;gt; LiveTemplates&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155685908838894&quot; title=&quot;新建 Live Group&quot; alt=&quot;新建 Template Group&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.新建一个 &lt;strong&gt;Template Group&lt;/strong&gt; , 取名为 &lt;strong&gt;Stream&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155685924355381&quot; title=&quot;新建 Stream&quot; alt=&quot;新建 Stream&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.&lt;strong&gt;创建完成后，选中 Stream, 新建一个实时模板&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155685947219530&quot; title=&quot;新建一个实时模板&quot; alt=&quot;新建一个实时模板&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.创建一个 &lt;code&gt;toList&lt;/code&gt; 代码片段模板：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155685983359816&quot; title=&quot;创建一个 toList&quot; alt=&quot;创建一个 toList&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注意：代码片段的上下文选 &lt;code&gt;Java -&amp;gt; other&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;5.设置完成后，让我们在实战中看下效果吧！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155685993368961&quot; title=&quot;实战中使用 toList&quot; alt=&quot;实战中使用 toList&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;顺手把其他常用的模板设置一下&quot;&gt;2.2 顺手把其他常用的模板设置一下&lt;/h3&gt;
&lt;p&gt;除了上面演示的 &lt;code&gt;toList&lt;/code&gt;外, &lt;code&gt;toSet&lt;/code&gt;，&lt;code&gt;groupingBy&lt;/code&gt;和&lt;code&gt;join&lt;/code&gt;使用也相当普遍，我们也来设置一下，方法与上面大同小异，这里就不一一贴图了，贴上代码片段内容：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 缩略: .toList
.collect(Collectors.toList());

// 缩略: .toSet
.collect(Collectors.toSet());

// 缩略: .join
.collect(Collectors.joining(&quot;$END$&quot;));

// 缩略: .groupBy
.collect(Collectors.groupingBy(e -&amp;gt; $END$));&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;PS: 特殊变量&lt;code&gt;$END$&lt;/code&gt;用来在代码片段生成后，确定光标位置，这样你就可以直接输入相关代码了，比如，定义 &lt;code&gt;join&lt;/code&gt; 连接分隔符等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;模板都创建好了以后，截图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155686037854461&quot; title=&quot;stream 模板&quot; alt=&quot;stream 模板&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后，我们再来看看，&lt;code&gt;join&lt;/code&gt; 和 &lt;code&gt;groupBy&lt;/code&gt; 的使用效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155686066307359&quot; title=&quot;join&quot; alt=&quot;join&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155686069610023&quot; title=&quot;groupBy&quot; alt=&quot;groupBy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;三结语&quot;&gt;三、结语&lt;/h2&gt;
&lt;p&gt;IntelliJ IDEA 中的实时模板是个功能丰富且强大的工具。善用它，可以大大地提高咱们的编码效率哦。&lt;/p&gt;
&lt;h2 id=&quot;免费分享-面试学习福利资源&quot;&gt;免费分享 | 面试&amp;amp;学习福利资源&lt;/h2&gt;
&lt;p&gt;最近在网上发现一个不错的 PDF 资源《Java 核心知识&amp;amp;面试.pdf》分享给大家，不光是面试，学习，你都值得拥有！！！&lt;/p&gt;
&lt;p&gt;获取方式: 关注公众号: &lt;strong&gt;小哈学Java&lt;/strong&gt;, 后台回复&lt;strong&gt;资源&lt;/strong&gt;，既可&lt;strong&gt;免费无套路获取资源链接&lt;/strong&gt;，下面是目录以及部分截图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155651432676587&quot; title=&quot;关注微信公众号【小哈学Java】,回复【资源】，即可免费无套路领取资源链接哦&quot; alt=&quot;关注微信公众号【小哈学Java】,回复【资源】，即可免费无套路领取资源链接哦&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155651441280253&quot; title=&quot;关注微信公众号【小哈学Java】,回复【资源】，即可免费无套路领取资源链接哦&quot; alt=&quot;关注微信公众号【小哈学Java】,回复【资源】，即可免费无套路领取资源链接哦&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155651443805696&quot; title=&quot;关注微信公众号【小哈学Java】,回复【资源】，即可免费无套路领取资源链接哦&quot; alt=&quot;关注微信公众号【小哈学Java】,回复【资源】，即可免费无套路领取资源链接哦&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155651470347464&quot; title=&quot;关注微信公众号【小哈学Java】,回复【资源】，即可免费无套路领取资源链接哦&quot; alt=&quot;关注微信公众号【小哈学Java】,回复【资源】，即可免费无套路领取资源链接哦&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155651449186666&quot; title=&quot;关注微信公众号【小哈学Java】,回复【资源】，即可免费无套路领取资源链接哦&quot; alt=&quot;关注微信公众号【小哈学Java】,回复【资源】，即可免费无套路领取资源链接哦&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155651451040055&quot; title=&quot;关注微信公众号【小哈学Java】,回复【资源】，即可免费无套路领取资源链接哦&quot; alt=&quot;关注微信公众号【小哈学Java】,回复【资源】，即可免费无套路领取资源链接哦&quot;/&gt;&lt;/p&gt;
&lt;p&gt;重要的事情说两遍，关注公众号: &lt;strong&gt;小哈学Java&lt;/strong&gt;, 后台回复&lt;strong&gt;资源&lt;/strong&gt;，既可&lt;strong&gt;免费无套路获取资源链接&lt;/strong&gt; ！！！&lt;/p&gt;
&lt;h2 id=&quot;欢迎关注微信公众号-小哈学java&quot;&gt;欢迎关注微信公众号: 小哈学Java&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155634562788477&quot; title=&quot;关注微信公众号【小哈学Java】,回复【资源】，即可免费无套路领取资源链接哦&quot; alt=&quot;关注微信公众号【小哈学Java】,回复【资源】，即可免费无套路领取资源链接哦&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 03 May 2019 06:13:00 +0000</pubDate>
<dc:creator>犬小哈</dc:creator>
<og:description>本文翻译整理自： 'https://winterbe.com/posts/2015/03/05/fixing java 8 stream gotchas with intellij idea' 作者：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/quanxiaoha/p/10805059.html</dc:identifier>
</item>
<item>
<title>浅谈如何更好学习前端 - 方向_Nil</title>
<link>http://www.cnblogs.com/fpj-frank/p/10804907.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fpj-frank/p/10804907.html</guid>
<description>&lt;p&gt;　　&lt;span class=&quot;md-tab&quot;&gt;从去年9月中旬加入现在这家公司，到今天刚好7个月左右。也许在职业生涯里，这一段时间并不算很长。但是对于快速迭代的前端领域而言，7个月足以让这个行业刷新好几遍。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span&gt;今晚下班，听了方大（方应杭）的一场知乎live的回放，感觉收益颇丰，特地记录在此。在live中，方大对自己职业生涯以及js发展历史的简单介绍，最后对不同工龄的前端，应如何提升自己能力，提出了一些实用的建议。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span&gt;关于大神的职业生涯，自然是金光闪闪，待过BAT的AT，现在专职搞IT教育。但是，光鲜亮丽的外表，总是需要许多的付出，甚至还会遭遇挫折，尽管他说自己的运气一直都很好。比如，被上级臭骂，硬着头皮啃后端框架，为梦想放弃A的高薪和股票，甘心加入一家小公司等等。具体不做太多的转述，显得离题。唯一要说的，选择的前端，或者说是互联网这一行 ，就注定和稳定无缘，和不断学习相伴 了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-expand&quot;&gt;关于学习，还是坚持一个原则，在适合的时间，做适合的事情。对于学生或刚入行1-2年的前端新手，需要不断打牢基础，不要局限前端知识，一些编程通用的知识也需要学习。具体可以按照这样的学习路径：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1496893/201905/1496893-20190503131041086-781445.jpg&quot; alt=&quot;&quot; width=&quot;752&quot; height=&quot;451&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;C:%5CUsers%5CASUS%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1556859645752.png&quot;&gt;&lt;img alt=&quot;&quot; data-local-refresh=&quot;true&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span&gt;而对于在职，工作2年以上的前端，此时需要做的，应该通过做项目，在项目中不断填坑、学习。项目的类型要多样，确保覆盖的知识面足够广泛。具体可以参考以下路径：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1496893/201905/1496893-20190503131133171-496612157.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt; 　　进阶建议：&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;　　给1年以下的前端：&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;　　　　不满足于60分，对自己的要求高一些；&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;　　　　不断模仿别人的代码，api设计，最终形成自己的风格；&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;　　　　不要重复自己，每一年都要有不同的补充；&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;　　　　不要满足调用第三方的api，自己造轮子；&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;　　给3年以上的前端：&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;　　　　提高效率，不加班；&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;　　　　开始做“分外”的事情，多和产品经理、后端、设计等等聊聊，扩充不同的知识&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;　　　　管理上级，搞好人际关系；&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;　　　　成为重要的、有价值人，对产品要用自己深刻的理解；&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;　　　　坚持写博客；&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;　　　　模仿框架；&lt;/p&gt;
</description>
<pubDate>Fri, 03 May 2019 05:26:00 +0000</pubDate>
<dc:creator>方向_Nil</dc:creator>
<og:description>从去年9月中旬加入现在这家公司，到今天刚好7个月左右。也许在职业生涯里，这一段时间并不算很长。但是对于快速迭代的前端领域而言，7个月足以让这个行业刷新好几遍。 今晚下班，听了方大（方应杭）的一场知乎l</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fpj-frank/p/10804907.html</dc:identifier>
</item>
<item>
<title>代码精进之路读后感（五） - 一只菜鸟攻城狮啊</title>
<link>http://www.cnblogs.com/suihang/p/10804414.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/suihang/p/10804414.html</guid>
<description>&lt;p&gt;由于最近加班的严重就把看文章写读后感的事情耽搁了，昨天刚忙完，所以恢复每日看文章的习惯，今天读了读范学雷老师的代码精进之路第六篇：代码整理&lt;/p&gt;
&lt;p&gt;于我而言，代码的规范是十分必要的，我一直觉得自己可能有点强迫症，代码一定要对齐，所以导致我现在一看别人不规范的代码就感觉很难受，可能有的人会觉得项目有时候特别赶还管什么规范不规范，其实不然，规范的代码会在某种程度上提高你的效率，不规范的代码寻找并修改某个参数花费三分钟，可能规范的代码一分钟就能改好。&lt;/p&gt;
&lt;p&gt;根据文章我整理了一下进行代码规范的一些小方法&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;给代码分块&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;原则:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1. 保持代码块的单⼀性，⼀个代码块只能有⼀个目标。代码块内所有的内容都是为了⼀个目标服务的，不能把无关的内容放在同⼀个代码块里。同⼀个代码块里语句的相互联系比与相邻代码块里的语句关系更为紧密；&lt;/p&gt;
&lt;p&gt;2. 注意代码块的完整性。代码块是⼀个完整的信息块。⼀个代码块要表达⼀个相对完整的意思&lt;/p&gt;
&lt;p&gt;3. 代码块数量要适当。代码块过多，会让⼈觉得路径太长，逻辑复杂，不容易阅读理解。⼀个基础的代码块最好不要超过25行（通常显示屏小半个页面），否则就会有增加阅读理解的困难。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;方法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;合理地运用空白&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.同级别代码块靠左对齐&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.同级别代码块空行分割&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.下一级代码块向右缩进&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.同行内代码块空格区隔&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5.一行一个行为,&lt;/strong&gt;&lt;strong&gt;⼀个重要的原则是每一行代码仅仅表示一个行为这样每一行的代码才是一个常规大小的、可以识别的基础信息块&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;strong&gt;基本的换行原则&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　&lt;/strong&gt;基本的换⾏规范需要考虑以下三点。&lt;/p&gt;
&lt;p&gt;　　　　　　1. 每⾏代码字符数的限制。⼀般情况下，每⾏代码不要超出80个字符（ 80个字符是传统终端的宽度，⽐如vi编译器）。由于屏幕尺⼨和代码阅读终端的变化，现在的很多规范，开始使⽤120个字符的限制。所以我们编码的时候，需要留意⼀下；&lt;/p&gt;
&lt;p&gt;　　　　　　2. 如果⼀⾏不⾜以容纳⼀个表达式，就需要换⾏；&lt;br/&gt;　　　　　　3. ⼀般的换⾏原则包括以下五点&lt;/p&gt;
&lt;p&gt;　　　　　　　　在逗号后换⾏。&lt;/p&gt;
&lt;p&gt;　　　　　　　　在操作符前换⾏&lt;/p&gt;
&lt;p&gt;　　　　　　　　⾼级别的换⾏优先&lt;/p&gt;
&lt;p&gt;　　　　　　　　新的换⾏与上⼀⾏同级别表达式的开头对⻬。&lt;/p&gt;
&lt;p&gt;　　　　　　　　如果上述规则导致代码混乱或者代码太靠右，使⽤8个空格作为缩进（两个缩进单位）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;可以使用各种各样的规范的插件来达到代码规范的目的，例如ESlint等&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 03 May 2019 01:56:00 +0000</pubDate>
<dc:creator>一只菜鸟攻城狮啊</dc:creator>
<og:description>由于最近加班的严重就把看文章写读后感的事情耽搁了，昨天刚忙完，所以恢复每日看文章的习惯，今天读了读范学雷老师的代码精进之路第六篇：代码整理 于我而言，代码的规范是十分必要的，我一直觉得自己可能有点强迫</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/suihang/p/10804414.html</dc:identifier>
</item>
<item>
<title>生产制造追溯系统-再说条码打印 - 无 影</title>
<link>http://www.cnblogs.com/allen0118/p/10804336.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/allen0118/p/10804336.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在之前的博客中我介绍了如何实现生产现场的条码打印，我们的生活中到处都是条码，一维码、二维码随处可见，更别说一家从事生产制造加工的工厂了，而条码种类繁多、离线打印等情况就直接导致了条码管控上的难度，甚至会出现较为严重的品质事件，上一个版本中我是通过Web应用程序调用 WinForm 中的函数进行打印，WinForm中嵌套了 WebBrowser 来浏览网页，通过这几年的实际运用，这个方法基本能够满足大部分需求，但还是美中不足，由于 WebBrowser 所示用的浏览器内核比较低，导致很多样式无法兼容，尽管网络上有一些方法去改变这个问题(比如webkit，cef，修改注册表等等)，但总是或多或少有一些问题。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;新的方案，告别 WinForm &amp;amp; WebBrowser&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们本次以生产线 卡通包装 工位为例，进行描述：&lt;/p&gt;
&lt;p&gt;通常情况下，操作员会扫描多个彩盒条码，这个扫描的数量一个到多个不等，每一个彩盒上面都有一个唯一的条形码或二维码，当彩盒扫描完成以后需要结束装箱，此时系统应该直接将对应的卡通标贴打印出来，操作员从打印机上撕下卡通标贴并贴于卡通箱，在此之前我们需要提前将卡通标贴的打印模板制作出来并上传至系统中，操作界面如下，&lt;strong&gt;&lt;span&gt;支持同一个产品打印多张标贴&lt;/span&gt;&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/141602/201905/141602-20190503090714081-1154324968.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时，我们需要编写一个 Api 来获取服务器上面的模板文件以及需要打印出来的数据列表，关键代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
     &lt;span&gt;string&lt;/span&gt; ServerUrl = XmlHelper.GetXmlReader(path, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Config&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Server&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; Api = XmlHelper.GetXmlReader(path, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Config&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Api&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);


            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过 API 获取模板文件*******************************************************************&lt;/span&gt;
            &lt;span&gt;string&lt;/span&gt; _Btw_Url = Api + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;?action=get_carton_label&amp;amp;carton_sn=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; _carton_sn;
            HttpHelper http_btw &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpHelper();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建Httphelper参数对象&lt;/span&gt;
            HttpItem item_btw = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpItem()
            {
                URL &lt;/span&gt;= _Btw_Url,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;URL必需项   &lt;/span&gt;
                ContentType = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;application/json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, 
            };
          
            HttpResult req_result_btw &lt;/span&gt;=&lt;span&gt; http_btw.GetHtml(item_btw);           
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; btw_str =&lt;span&gt; req_result_btw.Html;
            JObject obj_btw &lt;/span&gt;=&lt;span&gt; (JObject)JsonConvert.DeserializeObject(btw_str);
            DataTable dt &lt;/span&gt;= Library.JsonLib.ToDataTable(obj_btw[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;msg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;].ToString());

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过 API 获取模板文件*******************************************************************&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
 WebClient web = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; WebClient();             
 
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; _Api_Url = Api + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;?action=get_carton_print_list&amp;amp;carton_sn=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; _carton_sn;
            HttpHelper http_data_list &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpHelper();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建Httphelper参数对象&lt;/span&gt;
            HttpItem item_data_list = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpItem()
            {
                URL &lt;/span&gt;= _Api_Url,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;URL必需项   &lt;/span&gt;
                ContentType = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;application/json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, 
            };
            &lt;/span&gt;&lt;span&gt;
            HttpResult req_result_data_list &lt;/span&gt;=&lt;span&gt; http_data_list.GetHtml(item_data_list); 
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; print_str =&lt;span&gt; req_result_data_list.Html;  
            JObject obj &lt;/span&gt;=&lt;span&gt; (JObject)JsonConvert.DeserializeObject(print_str);
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; _Key = obj[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;msg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;][&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;].ToString();
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; _Value = obj[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;msg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;][&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;].ToString(); 
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; splitKey = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;[] keys =&lt;span&gt; _Key.Split(splitKey.ToCharArray(), StringSplitOptions.None);
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;[] values =&lt;span&gt; _Value.Split(splitKey.ToCharArray(), StringSplitOptions.None);
             
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; dt.Rows.Count; i++&lt;span&gt;)
            {
                _file_url &lt;/span&gt;= ServerUrl + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;app/cartonlabel/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + dt.Rows[i][&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LABEL_FILE&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;].ToString();
                _file_name &lt;/span&gt;= System.Guid.NewGuid().ToString() + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + dt.Rows[i][&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LABEL_FILE&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;].ToString();
                web.DownloadFile(_file_url, _directory &lt;/span&gt;+&lt;span&gt; _file_name);
                _print();
            }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Api 编写完成之后我们进行发布，发布到本地指定一个文件夹留作备用，现在我们还差一步，那就是如何通过网页在客户端本地打印？大家都知道我们的网站是部署在服务器而非客户端本地的，但是打印的条码必须出现在客户端本地的打印机，此时你可以考虑通过网络共享打印机的办法来实现，但是这种方法非常不稳定，一些安全方面的设置就足以让你内流满面，因此我们可以考虑使用 CassiniDev 来实现，大致思路如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;新建一个批处理或者其它类型的程序。&lt;/li&gt;
&lt;li&gt;在项目中引用 CassiniDev 文件至。&lt;/li&gt;
&lt;li&gt;在本地new一个服务实例并启动。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;通过如下代码即可启动该服务：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;new&lt;/span&gt; Server(&lt;span&gt;9001&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, System.IO.Path.Combine(AppDomain.CurrentDomain.BaseDirectory, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Service&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;), System.Net.IPAddress.Parse(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;), &lt;span&gt;&quot;&quot;&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 在包装之前我们将该服务启动起来，我做了一个简单的界面，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/141602/201905/141602-20190503094030416-2134857047.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时，我们需要用到上一步发布的 Api，将发布的 Api 文件拷贝至Service目录，这个Service目录在这个批处理程序的根目录下面，至此所有的前期工作已经做完了，现在只需要调用本地这个Api 即可。 我们选择 MO-00002 这个工单进行演示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/141602/201905/141602-20190503092837434-1535632967.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/141602/201905/141602-20190503092750293-832764425.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/141602/201905/141602-20190503092757140-2042586877.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;下面开始扫描条码进行包装，该产品的包装容量为每一个卡通箱需要包装 4 个彩盒。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/141602/201905/141602-20190503093915896-1306439061.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/141602/201905/141602-20190503093928169-2062617000.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;系统提示打印命令发送成功的时候，我们的打印机已经自动将标贴打印出来了，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/141602/201905/141602-20190503094342571-1760210175.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;结论&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;相对之前的 WebBrowser，目前这种方式可以更好的兼容样式表，比如H5，再就是同一套系统不用分为网页端与客户端，尽管打开的是同一个网站；维护起来也要更加方便。&lt;/p&gt;
</description>
<pubDate>Fri, 03 May 2019 01:51:00 +0000</pubDate>
<dc:creator>无 影</dc:creator>
<og:description>前言 在之前的博客中我介绍了如何实现生产现场的条码打印，我们的生活中到处都是条码，一维码、二维码随处可见，更别说一家从事生产制造加工的工厂了，而条码种类繁多、离线打印等情况就直接导致了条码管控上的难度</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/allen0118/p/10804336.html</dc:identifier>
</item>
<item>
<title>Swoole HTTP 的应用 - 新亮笔记</title>
<link>http://www.cnblogs.com/xinliangcoder/p/10804400.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xinliangcoder/p/10804400.html</guid>
<description>&lt;h2 id=&quot;概述&quot;&gt;概述&lt;/h2&gt;
&lt;p&gt;这是关于 Swoole 学习的第四篇文章：Swoole HTTP 的应用。&lt;/p&gt;
&lt;p&gt;我们都知道 HTTP 是一种协议，允许 WEB 服务器和浏览器通过互联网进行发送和接受数据。&lt;/p&gt;
&lt;p&gt;想对 HTTP 进行详细的了解，可以找下其他文章。&lt;/p&gt;
&lt;p&gt;我们在网上能看到的界面，图片，动画，音频，视频 等，都有依赖这个协议的。&lt;/p&gt;
&lt;p&gt;在做 WEB 系统的时候，都使用过 IIS、Apache、Nginx 吧，我们利用 Swoole 也可以 简单的实现一个 WEB 服务器。&lt;/p&gt;
&lt;p&gt;主要使用了 HTTP 的两大对象：Request 请求对象、Response 响应对象。&lt;/p&gt;
&lt;p&gt;Request，包括 GET、POST、COOKIE、Header等。&lt;/p&gt;
&lt;p&gt;Response，包括 状态、响应体、跳转、发送文件等。&lt;/p&gt;
&lt;p&gt;不多说，分享两个程序：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一、实现一个基础的 Demo：“你好，Swoole.”&lt;/li&gt;
&lt;li&gt;二、实现一个简单的 路由控制&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;本地版本：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;PHP 7.2.6&lt;/li&gt;
&lt;li&gt;Swoole 4.3.1&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;代码&quot;&gt;代码&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;一、Demo：“你好，Swoole.”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;示例效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/389840/201905/389840-20190503094748729-1808561000.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;备注：IP 地址是我的虚拟机。&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?php

class Server
{
    private $serv;

    public function __construct() {
        $this-&amp;gt;serv = new swoole_http_server(&quot;0.0.0.0&quot;, 9502);
        $this-&amp;gt;serv-&amp;gt;set([
            'worker_num'      =&amp;gt; 2, //开启2个worker进程
            'max_request'     =&amp;gt; 4, //每个worker进程 max_request设置为4次
            'daemonize'       =&amp;gt; false, //守护进程(true/false)
        ]);

        $this-&amp;gt;serv-&amp;gt;on('Start', [$this, 'onStart']);
        $this-&amp;gt;serv-&amp;gt;on('WorkerStart', [$this, 'onWorkStart']);
        $this-&amp;gt;serv-&amp;gt;on('ManagerStart', [$this, 'onManagerStart']);
        $this-&amp;gt;serv-&amp;gt;on(&quot;Request&quot;, [$this, 'onRequest']);

        $this-&amp;gt;serv-&amp;gt;start();
    }

    public function onStart($serv) {
        echo &quot;#### onStart ####&quot;.PHP_EOL;
        echo &quot;SWOOLE &quot;.SWOOLE_VERSION . &quot; 服务已启动&quot;.PHP_EOL;
        echo &quot;master_pid: {$serv-&amp;gt;master_pid}&quot;.PHP_EOL;
        echo &quot;manager_pid: {$serv-&amp;gt;manager_pid}&quot;.PHP_EOL;
        echo &quot;########&quot;.PHP_EOL.PHP_EOL;
    }

    public function onManagerStart($serv) {
        echo &quot;#### onManagerStart ####&quot;.PHP_EOL.PHP_EOL;
    }

    public function onWorkStart($serv, $worker_id) {
        echo &quot;#### onWorkStart ####&quot;.PHP_EOL.PHP_EOL;
    }

    public function onRequest($request, $response) {
        $response-&amp;gt;header(&quot;Content-Type&quot;, &quot;text/html; charset=utf-8&quot;);
        $html = &quot;&amp;lt;h1&amp;gt;你好 Swoole.&amp;lt;/h1&amp;gt;&quot;;
        $response-&amp;gt;end($html);
    }
}

$server = new Server();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;二、路由控制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;示例效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/go9jpG3BuhS9Sk3RIAwbk3JG2X6Q4ot2uMjpAg7eoN30wLaYkJTT0FLt49SiaGplD6rDibzuHPEwdDKpsqx9QZ4Q/640?wx_fmt=gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;目录结构：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;├─ swoole_http  -- 代码根目录
│  ├─ server.php
│  ├─ controller
│     ├── Index.php
│     ├── Login.php&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;p&gt;server.php&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?php

class Server
{
    private $serv;

    public function __construct() {
        $this-&amp;gt;serv = new swoole_http_server(&quot;0.0.0.0&quot;, 9501);
        $this-&amp;gt;serv-&amp;gt;set([
            'worker_num'      =&amp;gt; 2, //开启2个worker进程
            'max_request'     =&amp;gt; 4, //每个worker进程 max_request设置为4次
            'document_root'   =&amp;gt; '',
            'enable_static_handler' =&amp;gt; true,
            'daemonize'       =&amp;gt; false, //守护进程(true/false)
        ]);

        $this-&amp;gt;serv-&amp;gt;on('Start', [$this, 'onStart']);
        $this-&amp;gt;serv-&amp;gt;on('WorkerStart', [$this, 'onWorkStart']);
        $this-&amp;gt;serv-&amp;gt;on('ManagerStart', [$this, 'onManagerStart']);
        $this-&amp;gt;serv-&amp;gt;on(&quot;Request&quot;, [$this, 'onRequest']);

        $this-&amp;gt;serv-&amp;gt;start();
    }

    public function onStart($serv) {
        echo &quot;#### onStart ####&quot;.PHP_EOL;
        swoole_set_process_name('swoole_process_server_master');

        echo &quot;SWOOLE &quot;.SWOOLE_VERSION . &quot; 服务已启动&quot;.PHP_EOL;
        echo &quot;master_pid: {$serv-&amp;gt;master_pid}&quot;.PHP_EOL;
        echo &quot;manager_pid: {$serv-&amp;gt;manager_pid}&quot;.PHP_EOL;
        echo &quot;########&quot;.PHP_EOL.PHP_EOL;
    }

    public function onManagerStart($serv) {
        echo &quot;#### onManagerStart ####&quot;.PHP_EOL.PHP_EOL;
        swoole_set_process_name('swoole_process_server_manager');
    }

    public function onWorkStart($serv, $worker_id) {
        echo &quot;#### onWorkStart ####&quot;.PHP_EOL.PHP_EOL;
        swoole_set_process_name('swoole_process_server_worker');

        spl_autoload_register(function ($className) {
            $classPath = __DIR__ . &quot;/controller/&quot; . $className . &quot;.php&quot;;
            if (is_file($classPath)) {
                require &quot;{$classPath}&quot;;
                return;
            }
        });
    }

    public function onRequest($request, $response) {
        $response-&amp;gt;header(&quot;Server&quot;, &quot;SwooleServer&quot;);
        $response-&amp;gt;header(&quot;Content-Type&quot;, &quot;text/html; charset=utf-8&quot;);
        $server = $request-&amp;gt;server;
        $path_info    = $server['path_info'];
        $request_uri  = $server['request_uri'];

        if ($path_info == '/favicon.ico' || $request_uri == '/favicon.ico') {
            return $response-&amp;gt;end();
        }

        $controller = 'Index';
        $method     = 'home';


        if ($path_info != '/') {
            $path_info = explode('/',$path_info);
            if (!is_array($path_info)) {
                $response-&amp;gt;status(404);
                $response-&amp;gt;end('URL不存在');
            }

            if ($path_info[1] == 'favicon.ico') {
                return;
            }

            $count_path_info = count($path_info);
            if ($count_path_info &amp;gt; 4) {
                $response-&amp;gt;status(404);
                $response-&amp;gt;end('URL不存在');
            }

            $controller = (isset($path_info[1]) &amp;amp;&amp;amp; !empty($path_info[1])) ? $path_info[1] : $controller;
            $method = (isset($path_info[2]) &amp;amp;&amp;amp; !empty($path_info[2])) ? $path_info[2] : $method;
        }

        $result = &quot;class 不存在&quot;;

        if (class_exists($controller)) {
            $class = new $controller();
            $result = &quot;method 不存在&quot;;
            if (method_exists($controller, $method)) {
                $result = $class-&amp;gt;$method($request);
            }
        }

        $response-&amp;gt;end($result);
    }
}

$server = new Server();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Index.php&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?php

class Index
{
    public function home($request)
    {
        $get = isset($request-&amp;gt;get) ? $request-&amp;gt;get : [];

        //@TODO 业务代码

        $result = &quot;&amp;lt;h1&amp;gt;你好，Swoole。&amp;lt;/h1&amp;gt;&quot;;
        $result.= &quot;GET参数：&quot;.json_encode($get);
        return $result;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Login.php&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?php

class Login
{
    public function index($request)
    {
        $post = isset($request-&amp;gt;post) ? $request-&amp;gt;post : [];

        //@TODO 业务代码

        return &quot;&amp;lt;h1&amp;gt;登录成功。&amp;lt;/h1&amp;gt;&quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;一、Swoole 可以替代 Nginx 吗？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;暂时不能，随着 Swoole 越来越强大，以后说不准。&lt;/p&gt;
&lt;p&gt;官方建议 Swoole 与 Nginx 结合使用。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Http\Server 对 Http 协议的支持并不完整，建议仅作为应用服务器。并且在前端增加Nginx作为代理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;根据自己的 Nginx 配置文件，可以自行调整。&lt;/p&gt;
&lt;p&gt;比如：新增一个配置文件&lt;/p&gt;
&lt;p&gt;enable-swoole-php.conf&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;location ~ [^/]\.php(/|$)
{
    proxy_http_version 1.1;
    proxy_set_header Connection &quot;keep-alive&quot;;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_pass http://127.0.0.1:9501;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们都习惯会将虚拟域名的配置文件放在 vhost 文件夹中。&lt;/p&gt;
&lt;p&gt;比如，虚拟域名的配置文件为：local.swoole.com.conf，可以选择加载 enable-php.conf ，也可以选择加载 enable-swoole-php.conf。&lt;/p&gt;
&lt;p&gt;配置文件供参考：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;server
    {
        listen 80;
        #listen [::]:80;
        server_name local.swoole.com ;
        index index.html index.htm index.php default.html default.htm default.php;
        root  /home/wwwroot/project/swoole;

        #include rewrite/none.conf;
        #error_page   404   /404.html;

        #include enable-php.conf;
        include enable-swoole-php.conf;

        location ~ .*\.(gif|jpg|jpeg|png|bmp|swf)$
        {
            expires      30d;
        }

        location ~ .*\.(js|css)?$
        {
            expires      12h;
        }

        location ~ /.well-known {
            allow all;
        }

        location ~ /\.
        {
            deny all;
        }

        access_log  /home/wwwlogs/local.swoole.com.log;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果直接编辑 server 段的代码也是可以的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、修改了 controller 文件夹中的业务代码，每次都是重启服务才生效吗？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不是，每次重启服务会影响到正常用户使用的，正常处理的请求会被强制关闭。&lt;/p&gt;
&lt;p&gt;在本地运行路由的代码时，试试这个命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ps aux | grep swoole_process_server_master | awk '{print $2}' | xargs kill -USR1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;给 master 进程发送一个 USR1 的信号，当 Swoole Server 接到这个信号后，就会让所有 worker 在处理完当前的请求后，进行重启。&lt;/p&gt;
&lt;p&gt;如果查看所有的进程，试试这个命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ps -ef | grep 'swoole_process_server' | grep -v 'grep'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要文章中源码的，关注公众号，回复“&lt;strong&gt;swoole http&lt;/strong&gt;”即可。&lt;/p&gt;
&lt;h2 id=&quot;扩展&quot;&gt;扩展&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;可以试着上传文件，做一个小的FTP服务器。&lt;/li&gt;
&lt;li&gt;可以试着整合到目前正在使用的PHP框架中。&lt;/li&gt;
&lt;li&gt;可以学习一些Swoole开源框架：EasySwoole、Swoft、One。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;本文欢迎转发，转发请注明作者和出处，谢谢！&lt;/p&gt;
</description>
<pubDate>Fri, 03 May 2019 01:49:00 +0000</pubDate>
<dc:creator>新亮笔记</dc:creator>
<og:description>[TOC] 概述 这是关于 Swoole 学习的第四篇文章：Swoole HTTP 的应用。 '第三篇：Swoole WebSocket 的应用' '第二篇：Swoole Task 的应用' '第一篇</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xinliangcoder/p/10804400.html</dc:identifier>
</item>
<item>
<title>死磕 java集合之LinkedList源码分析 - 彤哥读源码</title>
<link>http://www.cnblogs.com/tong-yuan/p/LinkedList.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tong-yuan/p/LinkedList.html</guid>
<description>&lt;h2 id=&quot;问题&quot;&gt;问题&lt;/h2&gt;
&lt;p&gt;（1）LinkedList只是一个List吗？&lt;/p&gt;
&lt;p&gt;（2）LinkedList还有其它什么特性吗？&lt;/p&gt;
&lt;p&gt;（3）LinkedList为啥经常拿出来跟ArrayList比较？&lt;/p&gt;
&lt;p&gt;（4）我为什么把LinkedList放在最后一章来讲？&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;LinkedList是一个以双向链表实现的List，它除了作为List使用，还可以作为队列或者栈来使用，它是怎么实现的呢？让我们一起来学习吧。&lt;/p&gt;
&lt;h2 id=&quot;继承体系&quot;&gt;继承体系&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/alan-tang-tt/yuan/raw/master/%E6%AD%BB%E7%A3%95%20java%E9%9B%86%E5%90%88%E7%B3%BB%E5%88%97/resource/LinkedList.png&quot; alt=&quot;qrcode&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过继承体系，我们可以看到LinkedList不仅实现了List接口，还实现了Queue和Deque接口，所以它既能作为List使用，也能作为双端队列使用，当然也可以作为栈使用。&lt;/p&gt;
&lt;h2 id=&quot;源码分析&quot;&gt;源码分析&lt;/h2&gt;
&lt;h3 id=&quot;主要属性&quot;&gt;主要属性&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 元素个数
transient int size = 0;
// 链表首节点
transient Node&amp;lt;E&amp;gt; first;
// 链表尾节点
transient Node&amp;lt;E&amp;gt; last;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;属性很简单，定义了元素个数size和链表的首尾节点。&lt;/p&gt;
&lt;h3 id=&quot;主要内部类&quot;&gt;主要内部类&lt;/h3&gt;
&lt;p&gt;典型的双链表结构。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private static class Node&amp;lt;E&amp;gt; {
    E item;
    Node&amp;lt;E&amp;gt; next;
    Node&amp;lt;E&amp;gt; prev;

    Node(Node&amp;lt;E&amp;gt; prev, E element, Node&amp;lt;E&amp;gt; next) {
        this.item = element;
        this.next = next;
        this.prev = prev;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;主要构造方法&quot;&gt;主要构造方法&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public LinkedList() {
}

public LinkedList(Collection&amp;lt;? extends E&amp;gt; c) {
    this();
    addAll(c);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;两个构造方法也很简单，可以看出是一个无界的队列。&lt;/p&gt;
&lt;h3 id=&quot;添加元素&quot;&gt;添加元素&lt;/h3&gt;
&lt;p&gt;作为一个双端队列，添加元素主要有两种，一种是在队列尾部添加元素，一种是在队列首部添加元素，这两种形式在LinkedList中主要是通过下面两个方法来实现的。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 从队列首添加元素
private void linkFirst(E e) {
    // 首节点
    final Node&amp;lt;E&amp;gt; f = first;
    // 创建新节点，新节点的next是首节点
    final Node&amp;lt;E&amp;gt; newNode = new Node&amp;lt;&amp;gt;(null, e, f);
    // 让新节点作为新的首节点
    first = newNode;
    // 判断是不是第一个添加的元素
    // 如果是就把last也置为新节点
    // 否则把原首节点的prev指针置为新节点
    if (f == null)
        last = newNode;
    else
        f.prev = newNode;
    // 元素个数加1
    size++;
    // 修改次数加1，说明这是一个支持fail-fast的集合
    modCount++;
}

// 从队列尾添加元素
void linkLast(E e) {
    // 队列尾节点
    final Node&amp;lt;E&amp;gt; l = last;
    // 创建新节点，新节点的prev是尾节点
    final Node&amp;lt;E&amp;gt; newNode = new Node&amp;lt;&amp;gt;(l, e, null);
    // 让新节点成为新的尾节点
    last = newNode;
    // 判断是不是第一个添加的元素
    // 如果是就把first也置为新节点
    // 否则把原尾节点的next指针置为新节点
    if (l == null)
        first = newNode;
    else
        l.next = newNode;
    // 元素个数加1
    size++;
    // 修改次数加1
    modCount++;
}

public void addFirst(E e) {
    linkFirst(e);
}

public void addLast(E e) {
    linkLast(e);
}

// 作为无界队列，添加元素总是会成功的
public boolean offerFirst(E e) {
    addFirst(e);
    return true;
}

public boolean offerLast(E e) {
    addLast(e);
    return true;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;典型的双链表在首尾添加元素的方法，代码比较简单，这里不作详细描述了。&lt;/p&gt;
&lt;p&gt;上面是作为双端队列来看，它的添加元素分为首尾添加元素，那么，作为List呢？&lt;/p&gt;
&lt;p&gt;作为List，是要支持在中间添加元素的，主要是通过下面这个方法实现的。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 在节点succ之前添加元素
void linkBefore(E e, Node&amp;lt;E&amp;gt; succ) {
    // succ是待添加节点的后继节点
    // 找到待添加节点的前置节点
    final Node&amp;lt;E&amp;gt; pred = succ.prev;
    // 在其前置节点和后继节点之间创建一个新节点
    final Node&amp;lt;E&amp;gt; newNode = new Node&amp;lt;&amp;gt;(pred, e, succ);
    // 修改后继节点的前置指针指向新节点
    succ.prev = newNode;
    // 判断前置节点是否为空
    // 如果为空，说明是第一个添加的元素，修改first指针
    // 否则修改前置节点的next为新节点
    if (pred == null)
        first = newNode;
    else
        pred.next = newNode;
    // 修改元素个数
    size++;
    // 修改次数加1
    modCount++;
}

// 寻找index位置的节点
Node&amp;lt;E&amp;gt; node(int index) {
    // 因为是双链表
    // 所以根据index是在前半段还是后半段决定从前遍历还是从后遍历
    // 这样index在后半段的时候可以少遍历一半的元素
    if (index &amp;lt; (size &amp;gt;&amp;gt; 1)) {
        // 如果是在前半段
        // 就从前遍历
        Node&amp;lt;E&amp;gt; x = first;
        for (int i = 0; i &amp;lt; index; i++)
            x = x.next;
        return x;
    } else {
        // 如果是在后半段
        // 就从后遍历
        Node&amp;lt;E&amp;gt; x = last;
        for (int i = size - 1; i &amp;gt; index; i--)
            x = x.prev;
        return x;
    }
}

// 在指定index位置处添加元素
public void add(int index, E element) {
    // 判断是否越界
    checkPositionIndex(index);
    // 如果index是在队列尾节点之后的一个位置
    // 把新节点直接添加到尾节点之后
    // 否则调用linkBefore()方法在中间添加节点
    if (index == size)
        linkLast(element);
    else
        linkBefore(element, node(index));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在中间添加元素的方法也很简单，典型的双链表在中间添加元素的方法。&lt;/p&gt;
&lt;p&gt;添加元素的三种方式大致如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/alan-tang-tt/yuan/raw/master/%E6%AD%BB%E7%A3%95%20java%E9%9B%86%E5%90%88%E7%B3%BB%E5%88%97/resource/LinkedList-1.png&quot; alt=&quot;qrcode&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在队列首尾添加元素很高效，时间复杂度为O(1)。&lt;/p&gt;
&lt;p&gt;在中间添加元素比较低效，首先要先找到插入位置的节点，再修改前后节点的指针，时间复杂度为O(n)。&lt;/p&gt;
&lt;h3 id=&quot;删除元素&quot;&gt;删除元素&lt;/h3&gt;
&lt;p&gt;作为双端队列，删除元素也有两种方式，一种是队列首删除元素，一种是队列尾删除元素。&lt;/p&gt;
&lt;p&gt;作为List，又要支持中间删除元素，所以删除元素一个有三个方法，分别如下。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 删除首节点
private E unlinkFirst(Node&amp;lt;E&amp;gt; f) {
    // 首节点的元素值
    final E element = f.item;
    // 首节点的next指针
    final Node&amp;lt;E&amp;gt; next = f.next;
    // 添加首节点的内容，协助GC
    f.item = null;
    f.next = null; // help GC
    // 把首节点的next作为新的首节点
    first = next;
    // 如果只有一个元素，删除了，把last也置为空
    // 否则把next的前置指针置为空
    if (next == null)
        last = null;
    else
        next.prev = null;
    // 元素个数减1
    size--;
    // 修改次数加1
    modCount++;
    // 返回删除的元素
    return element;
}
// 删除尾节点
private E unlinkLast(Node&amp;lt;E&amp;gt; l) {
    // 尾节点的元素值
    final E element = l.item;
    // 尾节点的前置指针
    final Node&amp;lt;E&amp;gt; prev = l.prev;
    // 清空尾节点的内容，协助GC
    l.item = null;
    l.prev = null; // help GC
    // 让前置节点成为新的尾节点
    last = prev;
    // 如果只有一个元素，删除了把first置为空
    // 否则把前置节点的next置为空
    if (prev == null)
        first = null;
    else
        prev.next = null;
    // 元素个数减1
    size--;
    // 修改次数加1
    modCount++;
    // 返回删除的元素
    return element;
}
// 删除指定节点x
E unlink(Node&amp;lt;E&amp;gt; x) {
    // x的元素值
    final E element = x.item;
    // x的前置节点
    final Node&amp;lt;E&amp;gt; next = x.next;
    // x的后置节点
    final Node&amp;lt;E&amp;gt; prev = x.prev;
    
    // 如果前置节点为空
    // 说明是首节点，让first指向x的后置节点
    // 否则修改前置节点的next为x的后置节点
    if (prev == null) {
        first = next;
    } else {
        prev.next = next;
        x.prev = null;
    }

    // 如果后置节点为空
    // 说明是尾节点，让last指向x的前置节点
    // 否则修改后置节点的prev为x的前置节点
    if (next == null) {
        last = prev;
    } else {
        next.prev = prev;
        x.next = null;
    }

    // 清空x的元素值，协助GC
    x.item = null;
    // 元素个数减1
    size--;
    // 修改次数加1
    modCount++;
    // 返回删除的元素
    return element;
}
// remove的时候如果没有元素抛出异常
public E removeFirst() {
    final Node&amp;lt;E&amp;gt; f = first;
    if (f == null)
        throw new NoSuchElementException();
    return unlinkFirst(f);
}
// remove的时候如果没有元素抛出异常
public E removeLast() {
    final Node&amp;lt;E&amp;gt; l = last;
    if (l == null)
        throw new NoSuchElementException();
    return unlinkLast(l);
}
// poll的时候如果没有元素返回null
public E pollFirst() {
    final Node&amp;lt;E&amp;gt; f = first;
    return (f == null) ? null : unlinkFirst(f);
}
// poll的时候如果没有元素返回null
public E pollLast() {
    final Node&amp;lt;E&amp;gt; l = last;
    return (l == null) ? null : unlinkLast(l);
}
// 删除中间节点
public E remove(int index) {
    // 检查是否越界
    checkElementIndex(index);
    // 删除指定index位置的节点
    return unlink(node(index));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;删除元素的三种方法都是典型的双链表删除元素的方法，大致流程如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/alan-tang-tt/yuan/raw/master/%E6%AD%BB%E7%A3%95%20java%E9%9B%86%E5%90%88%E7%B3%BB%E5%88%97/resource/LinkedList-2.png&quot; alt=&quot;qrcode&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在队列首尾删除元素很高效，时间复杂度为O(1)。&lt;/p&gt;
&lt;p&gt;在中间删除元素比较低效，首先要找到删除位置的节点，再修改前后指针，时间复杂度为O(n)。&lt;/p&gt;
&lt;h2 id=&quot;栈&quot;&gt;栈&lt;/h2&gt;
&lt;p&gt;前面我们说了，LinkedList是双端队列，还记得双端队列可以作为栈使用吗？&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void push(E e) {
    addFirst(e);
}

public E pop() {
    return removeFirst();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;栈的特性是LIFO(Last In First Out)，所以作为栈使用也很简单，添加删除元素都只操作队列首节点即可。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;（1）LinkedList是一个以双链表实现的List；&lt;/p&gt;
&lt;p&gt;（2）LinkedList还是一个双端队列，具有队列、双端队列、栈的特性；&lt;/p&gt;
&lt;p&gt;（3）LinkedList在队列首尾添加、删除元素非常高效，时间复杂度为O(1)；&lt;/p&gt;
&lt;p&gt;（4）LinkedList在中间添加、删除元素比较低效，时间复杂度为O(n)；&lt;/p&gt;
&lt;p&gt;（5）LinkedList不支持随机访问，所以访问非队列首尾的元素比较低效；&lt;/p&gt;
&lt;p&gt;（6）LinkedList在功能上等于ArrayList + ArrayDeque；&lt;/p&gt;
&lt;h2 id=&quot;彩蛋&quot;&gt;彩蛋&lt;/h2&gt;
&lt;p&gt;java集合部分的源码分析全部完结，整个专题以ArrayList开头，以LinkedList结尾，我觉得非常合适，因为ArrayList代表了List的典型实现，LInkedList代表了Deque的典型实现，同时LinkedList也实现了List，通过这两个类一首一尾正好可以把整个集合贯穿起来。&lt;/p&gt;
&lt;p&gt;还记得我们一共分析了哪些类吗？&lt;/p&gt;
&lt;p&gt;下一章，笔者将对整个java集合做一个总结，并提出一些阅读源码过程中的问题，敬请期待^^&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;欢迎关注我的公众号“彤哥读源码”，查看更多源码系列文章, 与彤哥一起畅游源码的海洋。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/alan-tang-tt/yuan/raw/master/%E6%AD%BB%E7%A3%95%20java%E9%9B%86%E5%90%88%E7%B3%BB%E5%88%97/resource/qrcode_ss.jpg&quot; alt=&quot;qrcode&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 03 May 2019 01:20:00 +0000</pubDate>
<dc:creator>彤哥读源码</dc:creator>
<og:description>LinkedList只是一个List吗？ LinkedList还有其它什么特性吗？ LinkedList为啥经常拿出来跟ArrayList比较？ 我为什么把LinkedList放在最后一章来讲？</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tong-yuan/p/LinkedList.html</dc:identifier>
</item>
</channel>
</rss>