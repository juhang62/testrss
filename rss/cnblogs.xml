<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>udf提权 - sijidou</title>
<link>http://www.cnblogs.com/sijidou/p/10522972.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sijidou/p/10522972.html</guid>
<description>&lt;p&gt;&lt;strong&gt;0x00前言：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;udf提权是通过数据库来实现获取目标的管理员的shell，来达到从低权限提权到高权限&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;0x01什么是udf：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;udf(Userdefined function)是用户自定义函数&lt;/p&gt;
&lt;p&gt;在mysql中函数是什么，比如mysql中常见的sleep(),sum(),ascii()等都是函数&lt;/p&gt;
&lt;p&gt;udf就是为了让我们开发者能够自己写方便自己函数，它有3种返回值，这三种分别是STRING，INTEGER，REAL&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;STRING        字符型
INTEGER       整型
REAL          实数型&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;定义格式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#创建自定义函数&lt;br/&gt;CREATE&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;AGGREGATE&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;FUNCTION&lt;/span&gt; function_name &lt;span&gt;RETURNS&lt;/span&gt; {STRING&lt;span&gt;|&lt;/span&gt;&lt;span&gt;INTEGER&lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt;REAL&lt;/span&gt;&lt;span&gt;} SONAME '文件名'
&lt;br/&gt;[AGGREATE]是聚集函数的表示，系统定义的聚集函数比如有&lt;/span&gt;COUNT()、AVE()、MN()、MAX()、SUM()
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SONAME 'file'表示这个函数从哪个文件里面引入，而这个文件一般是动态链接库，windows下是dll，linux是so，并且这个文件要在mysql的plugin目录下&lt;p&gt;#删除自定义函数
&lt;/p&gt;&lt;/span&gt;&lt;span&gt;DROP&lt;/span&gt; &lt;span&gt;FUNCTION&lt;/span&gt; function_name
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;特别注意mysql版本如果是在5.1以下udf.dll文件在windows server 2003下放置于c:\windows\system32目录，在windows server 2000下放置在c:\winnt\system32目录&lt;/p&gt;
&lt;p&gt;如果颜删除函数，必须udf文件还存在plugin目录下&lt;/p&gt;
&lt;p&gt;举个例子，mysql加载了udf.so文件中的某个函数，然后在没有删除这个函数前，把plugin目录下导入的这个udf.so文件利用rm命令删除了，那么这个导入mysql的函数就无法被删除，没有找到解决办法，如果后面新创的函数名字和该函数相冲突，mysql还不允许创建，所以请注意一下。（我被坑了，重装了mysql才终于把那个自定义导入的函数删掉了）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;0x02一道CTF题目：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先看一道jarvis OJ的一道web题目RE?，来明确如何使用用户自定义函数&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1419450/201903/1419450-20190313142027553-461099587.png&quot; alt=&quot;&quot; width=&quot;400&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://dn.jarvisoj.com/challengefiles/udf.so.02f8981200697e5eeb661e64797fc172&quot; target=&quot;_blank&quot;&gt;https://dn.jarvisoj.com/challengefiles/udf.so.02f8981200697e5eeb661e64797fc172&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;题目下载下来的是一个so文件，那么明显就是针对linux系统，首先可用linux进mysql看看自己的plugin文件夹在哪&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1419450/201903/1419450-20190313142355000-1759337641.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里我ubuntu虚拟机是在/usr/lib/mysql/plugin/下，把下载的文件拖进虚拟机并copy过去&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1419450/201903/1419450-20190313142648193-1194086023.png&quot; alt=&quot;&quot; width=&quot;400&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是有个问题，我们不知道这个so文件有哪些函数怎么办（虽然题目提示有个help_me),这里可以用ida逆向工具打开这个so文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1419450/201903/1419450-20190313142928758-301836989.png&quot; alt=&quot;&quot; width=&quot;400&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到这里面有函数的名字，于是在linux下的mysql里面先加载help_me看看效果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1419450/201903/1419450-20190313143453188-800940173.png&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么继续加载getflag这个函数(请忽略输入错误的语句.....),最终获取了flag&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1419450/201903/1419450-20190313143604321-649806417.png&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么要删除这2个函数也很简单实用drop function语句即可&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1419450/201903/1419450-20190313143722905-35169700.png&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;0x03UDF利用：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;回归正题，那么这几个udf提权文件从哪里来，msf和sqlmap下都有&lt;/p&gt;
&lt;p&gt;metasploit下的动态链接库&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1419450/201903/1419450-20190313141503742-1971649642.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;sqlmap下的动态链接库&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1419450/201903/1419450-20190313141654590-1602933163.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我在这里把metasploit下的4个文件copy出来，sqlmap下的4个udf文件是经过编码的，如果直接丢在mysql的plugin目录下是无法加载的，需要用sqlmap/extra/cloak/cloak.py进行解码&lt;/p&gt;
&lt;p&gt;在sqlmap/extra/cloak/目录下使用以下命令，生成的udf文件就会出现在当前文件夹中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
python .\cloak.py -d -i ..\..\udf\mysql\linux\64\lib_mysqludf_sys.so_ -&lt;span&gt;o linux_udf_64.so&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;首先可以向上面做题的时候瞧瞧这个so文件里面的函数&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1419450/201903/1419450-20190313144442473-495774090.png&quot; alt=&quot;&quot; width=&quot;400&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 那么将文件丢到刚刚的ubuntu下，并添加udf是成功的，但是一运行的时候会断开连接&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1419450/201903/1419450-20190316145908133-1990032668.png&quot; alt=&quot;&quot; width=&quot;400&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我又用msf的作用于windows的udf.dll文件上，在win7的虚拟机运行，也是断开连接&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1419450/201903/1419450-20190316150018824-1980427870.png&quot; alt=&quot;&quot; width=&quot;400&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最先我在思考是为什么会出现这种情况，最先怀疑udf文件能加载那么可能是mysql版本的问题，但是最后看国外的一篇udf提权的文章，最后仅简单的提了一句msf的udf文件原C++函数没有写异常处理，那么mysql加载的时候会使mysql出错导致断开连接。&lt;/p&gt;
&lt;p&gt;然后我比较了下msf和sqlmap的udf文件，发现其实2个文件是一模一样的，也就是如果单独拿出来会在有些环境下（比如我自己的ubuntu16.04 mysql5.7和win7 phpstudy mysql5.5）的环境下会出现无法运行。&lt;/p&gt;
&lt;p&gt;最后在解决这个问题上是，借助大马的udf提权模块能够获取windows的32位和64位的udf文件，并且能够成功运行。（大马是具体是哪个这里就不透露了，有兴趣可以去github翻翻，或者网上查查）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1419450/201903/1419450-20190316150638626-2107021234.png&quot; alt=&quot;&quot; width=&quot;400&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个大马的udf.dll文件是20k，而msf的udf文件普遍只有7~8k，估计里面写了很多操作（可能有后门，不是很安全，所以我就不在这透露了）&lt;/p&gt;
&lt;p&gt;至于linux如何解决，目前我还没有找到现场能直接用的文件，如果可以那么就自己写C++吧。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;0x04关于mysql写文件的注意：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;mysql有个配置是叫secure_file_priv，该参数来觉得mysql可以对哪个目录进行可写操作，在刚装的mysql上该参数是没有写的（不是为空是没有写，也就是被注释掉的）&lt;/p&gt;
&lt;p&gt;在mysql5.5之前 secure_file_priv默认是空，这个情况下可以向任意绝对路径写文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1419450/201903/1419450-20190316151736077-1164075854.png&quot; alt=&quot;&quot; width=&quot;200&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在mysql5.5之后 secure_file_priv默认是NULL，这个情况下不可以写文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1419450/201903/1419450-20190316151646010-306239543.png&quot; alt=&quot;&quot; width=&quot;200&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是如果mysql的配置文件中添加,那么就和mysql5.5之前一样，为空，可以为任意目录写文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1419450/201903/1419450-20190316151925348-2064066985.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而在mysql5.7后 secure_file_priv会默认一个目录，当然这个不是web的目录.....&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1419450/201903/1419450-20190316152300955-84371226.png&quot; alt=&quot;&quot; width=&quot;400&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以现在通过mysql来写webshell是越来越困难了，但是不排除一些配置错误导致的我们“有机可乘”&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;0xff结语：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这次udf提权的学习，也让我理清一条攻击思路，如果挖到sql注入，&lt;/p&gt;
&lt;p&gt;查数据库密码和账号，看看是不是能远程连接&lt;/p&gt;
&lt;p&gt;mysql5.7版本之后有个system可以直接执行命令&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1419450/201903/1419450-20190316151312366-1388321800.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以通过union select 来利用load_file或者dumpfile或者outfile向绝对路径目录写webshell&lt;/p&gt;
&lt;p&gt;拿到webshell可以连接数据库，能够写文件的话，利用udf提权&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/5b34c1b6dee7&quot; target=&quot;_blank&quot;&gt;https://www.jianshu.com/p/5b34c1b6dee7&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.360doc.com/content/18/0228/22/31784658_733287732.shtml&quot; target=&quot;_blank&quot;&gt;http://www.360doc.com/content/18/0228/22/31784658_733287732.shtml&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/ghc666/p/8609067.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/ghc666/p/8609067.html&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 16 Mar 2019 07:33:00 +0000</pubDate>
<dc:creator>sijidou</dc:creator>
<og:description>0x00前言： udf提权是通过数据库来实现获取目标的管理员的shell，来达到从低权限提权到高权限 0x01什么是udf： udf(Userdefined function)是用户自定义函数 在my</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sijidou/p/10522972.html</dc:identifier>
</item>
<item>
<title>js单元测试 - zhanghaiyu</title>
<link>http://www.cnblogs.com/zhanghaiyu-Jade/p/10542511.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhanghaiyu-Jade/p/10542511.html</guid>
<description>&lt;p&gt;最近研究了js的单元测试，分享一下心得。&lt;/p&gt;
&lt;p&gt;说起单元测试以前还真是不太了解，这次索性了解一番，测试有很多包含单元测试，性能测试，安全测试和功能测试等几方面，本次只介绍一下单元测试。&lt;/p&gt;
&lt;p&gt;前端进行单元测试主要是为了提高自己的代码质量，多组测试用例，验证自己的代码是否都能通过，这是在开发中很有必要的。需要倡导的是‘开发者应该吃自己的狗粮’，*——*&lt;/p&gt;
&lt;p&gt;单元测试主要包含断言，测试框架，测试用例等几个方面，&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;断言：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;断言是对代码结果的一种判断，如果这种判断和结果是一样的，那么这个断言就是真的，测试就通过了，如果为假的，程序就会终止执行，并出现错误信息。&lt;/p&gt;
&lt;p&gt;断言库有很多&lt;code&gt;expect&lt;/code&gt;，&lt;code&gt;should，chai,其次就是node的assert断言，本次主要说assert断言&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; assert=require('assert'&lt;span&gt;);
assert.equal(Math.max(&lt;/span&gt;1,100),100);&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一但assert.equal()不满足期望，将会抛出AssertionError异常，整个程序将停止执行。&lt;/p&gt;
&lt;p&gt;断言规范中，我们定义一下几种检测方法：&lt;br/&gt;ok()判断结果是否为真，&lt;/p&gt;
&lt;p&gt;equal()判断实际值与期望值是否相等，&lt;/p&gt;
&lt;p&gt;notEqual()：判断实际值与期望值是否不相等&lt;/p&gt;
&lt;p&gt;deepEqual()：判断实际值与期望值是否深度相等（对象和数组的元素是否相等）&lt;/p&gt;
&lt;p&gt;notDeepEqual：判断实际值与期望值是否不深度相等&lt;/p&gt;
&lt;p&gt;strictEqual：判断实际值与期望值是否严格相等（===）&lt;/p&gt;
&lt;p&gt;notStrictEqual：判断实际值与期望值是否不严格相等（相当于！==）&lt;/p&gt;
&lt;p&gt;throws：判断代码块是否抛出异常&lt;/p&gt;
&lt;p&gt;市面上的大多断言库都是基于assert模块进行封装和扩展的，这包括著名的should.js断言库&lt;/p&gt;
&lt;p&gt;安装：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
npm install  should  --save-dev 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;测试框架&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;前面提到断言一旦检查失败，将会抛出异常停止整个应用，这对于大规模的断言检查时并不友好，更通用的就是抛出异常并且继续执行，最后生成测试报告，这任务承担着就是测试框架，优秀的单元测试框架是mocha(发音：摩卡)，mocha本身不含有断言库，所以必须先引入断言库，像上面提到的断言库，不限于使用哪种。&lt;/p&gt;
&lt;p&gt;安装：&lt;/p&gt;
&lt;p&gt;npm install mocha -g(全局安装)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;测试风格：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;TDD(测试驱动开发)和BDD（行为驱动开发）这两种，他们的不同是什么？&lt;/p&gt;
&lt;p&gt;TDD关注多有功能是否被正确的实现，每个功能都具备对于的测试用例；BDD关注整体行为是否符合规格预期，适合自顶向下的设计方式&lt;/p&gt;
&lt;p&gt;TDD表达方式偏向于功能说明书的风格；BDD的表达方式更接近于自己的语言习惯&lt;/p&gt;
&lt;p&gt;我个人比较习惯BDD风格方式：&lt;/p&gt;
&lt;p&gt;主要采用describe和it进行组织，一个测试脚本与所要测试的源码脚本同名，但是后缀名为&lt;code&gt;.test.js&lt;/code&gt;（表示测试）或者&lt;code&gt;.spec.js&lt;/code&gt;（表示规格），比如，&lt;code&gt;add.js&lt;/code&gt;的测试脚本名字就是&lt;a href=&quot;https://link.jianshu.com/?t=https%3A%2F%2Fgithub.com%2Fruanyf%2Fmocha-demos%2Fblob%2Fmaster%2Fdemo01%2Fadd.test.js&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;add.test.js&lt;/code&gt;&lt;/a&gt;。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; add.test.js  测试脚本名字&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; add = require('../lib/add'&lt;span&gt;);

describe(&lt;/span&gt;'add', &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
  it(&lt;/span&gt;'6 + 7 = 13', &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    add(&lt;/span&gt;6,7).should.equal(13&lt;span&gt;)
  })
  
  it(&lt;/span&gt;'9 + 10 = 19', &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    add(&lt;/span&gt;9 , 10).should.equal(19&lt;span&gt;)
  }) 
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一个测试脚本由一个或多个describe测试套件组成，一个测试套件由一个或多个it测试用例组成，&lt;/p&gt;
&lt;p&gt;&lt;code&gt;describe&lt;/code&gt;块称为&quot;测试套件&quot;（test suite），表示一组相关的测试。它是一个函数，第一个参数是测试套件的名称（&quot;add&quot;），第二个参数是一个实际执行的函数。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;it&lt;/code&gt;块称为&quot;测试用例&quot;（test case），表示一个单独的测试，是测试的最小单位。是一个函数，第一个参数是测试用例的名称（&quot;6 + 7 = 13&quot;），第二个参数是一个实际执行的函数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;mocha基本用法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有了测试脚本就可以使用mocha运行它&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mocha&lt;/code&gt;命令后面紧跟测试脚本的路径和文件名，可以指定多个测试脚本。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
mocha file1 file2 file3
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意：mocha默认运行test子目录第一层的测试用例，不会执行更下层的用例。&lt;/p&gt;
&lt;p&gt;例如：test文件下有个dir目录，里面有个测试脚本add.test.js，这是执行不到的，为了改变这种行为，就必须加上&lt;code&gt;--recursive&lt;/code&gt;参数，这时&lt;code&gt;test&lt;/code&gt;子目录下面所有的测试用例都会执行。&lt;/p&gt;
&lt;p&gt;对于es6，需要经过编译后才可以进行测试，&lt;/p&gt;
&lt;p&gt;转码需要安装&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;ruby&quot;&gt;npm install babel-core babel-preset-es2015 --save-dev&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;然后 在根目录下面创建babelrc，配置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&quot;presets&quot;: [ &quot;es2015&quot;&lt;span&gt; ]
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意，Babel默认不会对Iterator、Generator、Promise、Map、Set等全局对象，以及一些全局对象的方法（比如&lt;code&gt;Object.assign&lt;/code&gt;）转码。如果你想要对这些对象转码，就要安装&lt;code&gt;babel-polyfill&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
npm install babel-polyfill --save-dev
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用时候需要导入&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
import 'babel-polyfill'
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;测试工具&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;karma则属于测试工具，能够模拟各种环境来运行你的测试代码，比如Chrome，Firefox，mobile等等。&lt;/p&gt;
&lt;p&gt;（提一下：travis ci，是一个远程免费的持续集成（CI）服务，你可以通过配置绑定你github上的项目，并且配置运行环境，实现只要github上有代码更新，travis就会自动运行构建和测试，并反馈运行结果。）&lt;/p&gt;
&lt;p&gt;使用karma&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;步骤
全局安装 karma
npm install &lt;/span&gt;-g karma-&lt;span&gt;cli
安装所有依赖
......
初始化测试
karma init
    &lt;/span&gt;1. Which testing framework &lt;span&gt;do&lt;/span&gt; you want to use ?&lt;span&gt; (mocha)
    &lt;/span&gt;2. Do you want to use Require.js ?&lt;span&gt; (no)
    &lt;/span&gt;3. Do you want to capture any browsers automatically ?&lt;span&gt; (Chrome)
    &lt;/span&gt;4. What is the location of your source and test files ? (https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;cdn.bootcss.com/jquery/2.2.4/jquery.js, node_modules/should/should.js, test/**.js)&lt;/span&gt;
    5. Should any of the files included by the previous patterns be excluded ?&lt;span&gt; ()
    &lt;/span&gt;6. Do you want Karma to watch all the files and run the tests on change ?&lt;span&gt; (yes)
启动测试
karma start&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;karma.conf.js:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
module.exports = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(config) {
  config.set({&lt;/span&gt;
    basePath: ''&lt;span&gt;,&lt;/span&gt;
    frameworks: ['mocha'&lt;span&gt;], //使用的框架&lt;/span&gt;
&lt;span&gt;    files: [ //依赖模块
      &lt;/span&gt;'https://cdn.bootcss.com/jquery/2.2.4/jquery.js'&lt;span&gt;,
      &lt;/span&gt;'node_modules/should/should.js'&lt;span&gt;,
      &lt;/span&gt;'test/**/*.js'&lt;span&gt;,
      &lt;/span&gt;'src/**/*.js'&lt;span&gt;
    ],&lt;/span&gt;
&lt;span&gt;    exclude: [//排除文件列表
    ],&lt;/span&gt;
&lt;span&gt;    preprocessors: {
    },&lt;/span&gt;
    reporters: ['progress'&lt;span&gt;],
&lt;/span&gt;
    port: 9876&lt;span&gt;,//服务端口号
&lt;/span&gt;
    colors: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,//启用或禁用输出报告或者日志中的颜色
&lt;/span&gt;
&lt;span&gt;    logLevel: config.LOG_INFO,
&lt;/span&gt;
    autoWatch: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;, //启用或禁用自动检测文件变化进行测试
&lt;/span&gt;
    browsers: ['Chrome'&lt;span&gt;], //测试启动的浏览器&lt;/span&gt;
    singleRun: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;,//&lt;/span&gt;开启或禁用持续集成模式  设置为true, Karma将打开浏览器，执行测试并最后退出
&lt;/pre&gt;
&lt;pre&gt;
&lt;em id=&quot;__mceDel&quot;&gt;&lt;span&gt;    concurrency: Infinity//并发级别（启动的浏览器数）
  })
}&lt;/span&gt;&lt;/em&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;详细了解可以去karma :http://karma-runner.github.io/latest/index.html  &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;json&quot;&gt; &lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;hljs ruby&quot;&gt;
&lt;/pre&gt;

</description>
<pubDate>Sat, 16 Mar 2019 07:33:00 +0000</pubDate>
<dc:creator>zhanghaiyu</dc:creator>
<og:description>最近研究了js的单元测试，分享一下心得。 说起单元测试以前还真是不太了解，这次索性了解一番，测试有很多包含单元测试，性能测试，安全测试和功能测试等几方面，本次只介绍一下单元测试。 前端进行单元测试主要</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhanghaiyu-Jade/p/10542511.html</dc:identifier>
</item>
<item>
<title>第一次阅读作业 - baby孙</title>
<link>http://www.cnblogs.com/230332663abcd/p/10542502.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/230332663abcd/p/10542502.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;span&gt;一.&lt;strong&gt;建立博客并介绍自己&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;我的名字叫孙玥祺，来自软件三班。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;世界很大，喜欢出去走走，去各地旅游看风景，品美食，写游记。喜欢文学，写文章，看书，发表自己的感慨。我的闪光点我认为是有热情，肯上进，愿意为自己的目标不懈努力。向往好的事物，并努力向前。比较乐观，以积极的心态面对未来。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;二.阅读与思考&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.&lt;strong&gt;&lt;span&gt;回想一下你初入大学时对软件工程专业的畅想&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1619752/201903/1619752-20190316114204511-65561332.png&quot; alt=&quot;&quot; width=&quot;22&quot; height=&quot;19&quot;/&gt;&lt;span&gt;当初你是如何做出选择软件工程专业的决定的？&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;刚入大学，因为家人的填的志愿，我读了物联网工程这个专业。大一上学期可以转专业的时候，我才真真开始考虑计算机这门大的课程，我该从哪里入手来学。是从年级大会上了解到物联网，网络工程是硬件方面，而软工和计科是软件方面。所谓的硬件我的理解是偏于能看见的，可视化的。而软件方面则是像app一样，是电脑上的应用，是界面，是摸不着的。后来我查阅了百度资料，明白硬件系统是看得见摸得着的物理部件或设备，就是类似于主板。而软件是以程序和文档的形式存在，通过计算机运行来体现 他的作用。同时我也参观了物联网的嵌入式团队，他们所展示的是将芯片放入赛车里，用遥控器通过网络来控制。而软件工程的团队则是在电脑上向我们展示所做的网页，应用等。巨大的差异，让我认识到也许硬件方面还需要一个人具备立体思维的模式，我觉得我不合适。后来我参加了物联网工程的团队，其中偏于硬件方面的方向也比较单一，而我却被团队在做的web前端的页面所吸引，原来自己也是可以做多彩的网页样式，可以设计成自己喜欢的样子。所以我选择去了软件工程，因为喜欢前端的设计，也考虑的软件市场比较成熟，有更多的路可以选择。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1619752/201903/1619752-20190316114204511-65561332.png&quot; alt=&quot;&quot; width=&quot;22&quot; height=&quot;19&quot;/&gt;你认为过去两年中接触到的课程是否符合你对软件工程专业的期待，为什么？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;我觉得过去的两年接触的课程我自己还是比较满意。首先我接触的是语言方面，学习了C语言和C#，自己学习了C++。学习了这三门语言，我也是第一次感受到作为程序员的快乐，第一次自己可以编写程序，可以做出很多题目，可以调用函数，可以用递归做看似不可解的汉诺塔问题，甚至可以做一些自己小时候玩的简单游戏，这都是学习语言课程带给我的。其次，我接触到了数据结构，了解了更多的算法，可以写出更有 难度的代码，也知道了所谓运行的效率原来可以靠时间复杂度和空间复杂度计算的，也了解了更多的排序方法，算是自己对C语言的了解更进一步。后面学习了数据库，我也觉得自己离现在所谓的大数据时代近了一步，更加接近那个我心目酷酷的程序员的样子。但到现在还有一点小小的遗憾，因为和没有和项目组一起做过一个大的程序，想在接下来的时间中通过课程多去实践。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1619752/201903/1619752-20190316114204511-65561332.png&quot; alt=&quot;&quot; width=&quot;22&quot; height=&quot;19&quot;/&gt;&lt;span&gt;你觉得软件工程是你喜欢的领域吗，它是你擅长的领域吗？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;我比较喜欢，但在这个领域我觉得我还不是很擅长。因为在之前的学习当中我认为我在编写代码这方面还是有所欠缺，逻辑能力不够强。就比如在学习数据结构的时候，我学的线性表，动态链表以及栈，队列。理论知识和代码理解起来都比较轻松，但真正写代码的时候还是很困难，不知道如何下手，这学期我报名参加了蓝桥杯比赛，但在准备的时候，我才发现那些程序题是正真的讲数学思维与编程方法结合组成一道题，在这种灵活运用上我还是欠缺的很多。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1619752/201903/1619752-20190316114204511-65561332.png&quot; alt=&quot;&quot; width=&quot;22&quot; height=&quot;19&quot;/&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;将来你会选择从事软件开发相关的工作吗？是的话给出你想去的城市、公司和岗位，否的话给出原因&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;我将来想从事这方面工作，我想去北京，公司的话还没有想好，想去的岗位是web前端开发，还是坚持我现在所喜爱的设计领域，希望自己设计的网络界面可以让人们眼前一亮。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.即将大三的你，对照前人们走过的路和描述未来发展，现在的你&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1619752/201903/1619752-20190316114204511-65561332.png&quot; alt=&quot;&quot; width=&quot;22&quot; height=&quot;19&quot;/&gt;自我感觉你已经具备的专业知识、技能、能力有哪些？已经写过的代码量是多少？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;我觉得我具备的专业知识是这两年所学的C语言，C#，C++，通过数据结构我能写出较复杂的C语言代码，在团队，在老师的帮助下学习了PS，对画面的排版，制作有一个基本了解，能力方面，我觉得我对一个项目的要求可以做到基本了解，可以简单写出一些程序。代码量大概有2000条。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1619752/201903/1619752-20190316114204511-65561332.png&quot; alt=&quot;&quot; width=&quot;22&quot; height=&quot;19&quot;/&gt;&lt;span&gt;离成为一个合格的软件工程专业本科毕业生，在专业知识、技能、能力上还差距哪些？&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;离成为一个专业的软件工程本科毕业生，我觉得在专业知识上，我还是做不到把一个语言掌握透彻和灵活应用。其次，我的专业知识面比较狭窄，除了课堂开设的课程，没有学更多的与专业相关的课程。技能和能力上，我没有参加过大的项目，没有真正的和团队合作过，没有独立的完成过一个工程，可能在合作和工作的复杂度剖析上我可能很欠缺。在自学能力上，不能较快的掌握一门新语言。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3.大三是一个人生选择的十字路口，考研、工作、考公、出国，不同的选择在大三就有不同的努力方向。而无论考研还是工作的每条路径，也有许多不同的分支。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1619752/201903/1619752-20190316114204511-65561332.png&quot; alt=&quot;&quot; width=&quot;22&quot; height=&quot;19&quot;/&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;对照以上你阅读的前人们的经历，你的选择是什么？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;我的选择是出国，我觉得算是对自己一种升华。读了老师推荐的一些文章，我觉得很多人选择读研或出国去继续加强自己的能力，并有充分时间去准备简历去自己喜欢的公司。其次，读完文章令我最大的感慨是我从他们的文字中感受他们对于自己职业的喜爱，也有人提到，选择职业一定要选择一个自己足够喜欢的领域才能有激情干下去。我到现在学过的一些课程，仅仅是对前端一些简单的了解下，比较喜欢，所以我想去更深入了解它，想在更深入的学习中，去寻找它的乐趣。而我认为我可以通过出国这条路，去更多的学习和接触，去感受兴趣带给我的动力。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1619752/201903/1619752-20190316114204511-65561332.png&quot; alt=&quot;&quot; width=&quot;22&quot; height=&quot;19&quot;/&gt;&lt;span&gt;在这种选择下，你认为你相比其他同学来说有何优势，有何劣势？&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;优势我觉得是我肯学吧，我认为在年轻的时候应该去为自己的目标努力一把，我对学习可以保持热情，愿意去学好，去上进。还有家人的支持吧，没有后顾之忧。劣势的话，可能是英语还没有学的足够好，对于编程能力还没有达到一个很高的水平，还有自学能力还要提高，在自学的时候不能够把知识掌握透彻。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1619752/201903/1619752-20190316114204511-65561332.png&quot; alt=&quot;&quot; width=&quot;22&quot; height=&quot;19&quot;/&gt;&lt;span&gt;针对你的选择，你给自己的大三设定的规划安排是什么？&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;我的计划是在校期间，首先是提高绩点和平均分，达到我想申请大学的要求。其次，参加数学建模比赛和一些编程类的课程，继续加强自己薄弱的方面。争取参加项目，积累经验，多接触一些课外知识。还有最重要的是大二暑假准备雅思的第一次考试，并在大三考出一个满意的成绩。大三进公司参加实习和一些志愿者活动，增加阅历。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;三&lt;/strong&gt;&lt;strong&gt;.&lt;/strong&gt;&lt;strong&gt;提有质量的问题&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1.第五章：团队与流程 &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;5.2.2业余剧团模式中“不同的人会挑选不同的角色。在下一个剧目中，这些人也许会换一个完全不同的角色类型。”&lt;span data-mce-=&quot;&quot;&gt;&lt;span&gt;问题：&lt;/span&gt;&lt;span data-mce-=&quot;&quot;&gt;读完这段话我的理解是在这种模式下是不是每个人都要掌握不同的技能，而且要足够熟练才可以顺利完成。那是不是对一个人工程师的要求过高，现在有没有这样的团队在使用这样的方式。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;span data-mce-=&quot;&quot;&gt;2.第六章：敏捷流程&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;span data-mce-=&quot;&quot;&gt;“订单上的任务是团队成员根据自己的情况来认领。由团队来主导任务的估计和分配。”&lt;span&gt;问题：&lt;/span&gt;那么遇到困难或者大家都不感兴趣的问题，没有人愿意承担此类问题，又恰巧是很关键的，怎么样合理的分配人员，怎么样才能让团队中的愿意做，任务刚好能够分配完。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;span data-mce-=&quot;&quot;&gt;3.第十一章：软件设计与实现&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;span data-mce-=&quot;&quot;&gt;11.3 形式化的方法中提到“很多软件需求可以抽象为对符号的运算和变换”&lt;span&gt;问题：&lt;/span&gt;形式化趋向于数学化，不太明白如何用数学和推理将软件实现出来，有没有类似的表达和案例来说明这种方法。我通过资料了解到如果一个方法有良好的数学基础，那么它就是形式化的，典型地以形式化规约语言给出。也就是说符合此类数学特征才可以使用还是存在广泛性&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;span data-mce-=&quot;&quot;&gt;4.第十五章：稳定和发布阶段&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;span data-mce-=&quot;&quot;&gt;“推迟。如果我们的软件是真正解决用户的问题，是有价值的，那它一定会有下一个版本。”&lt;span&gt;问题：&lt;span&gt;我读这个解决bug问题的时候，我的理解是在这种很有价值的情况下，是不处理这个问题，等到需求量大的时候，再推出下一个版本顺带解决掉这个问题。我不知道我这样考虑这种方式对不对。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;5.&lt;span&gt;第七章：实战中的软件工程&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;“那些我觉得用户会喜欢的东西要及早和用户交流。”&lt;span&gt;问题：&lt;/span&gt;&lt;/span&gt;&lt;span&gt;我想知道及早这个时间点是怎么样把控比较好，是每一步跟进询问客户的意见还是说做出一个大概的模板给客户，让客户提出问题。这个交流的时间怎样才能更有效，更好地完成客户的要求，达到一个满意的效果。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;四.了解和调查源程序版本管理工具&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;1.&lt;/span&gt;    &lt;span&gt;GIT&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Git 是用于 Linux&lt;a href=&quot;https://baike.baidu.com/item/%E5%86%85%E6%A0%B8&quot;&gt;内核&lt;/a&gt;开发的&lt;a href=&quot;https://baike.baidu.com/item/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6&quot;&gt;版本控制&lt;/a&gt;工具。与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持（wingeddevil注：这得分是用什么样的服务端，使用http协议或者git协议等不太一样。并且在push和pull的时候和服务器端还是有交互的。），使&lt;a href=&quot;https://baike.baidu.com/item/%E6%BA%90%E4%BB%A3%E7%A0%81&quot;&gt;源代码&lt;/a&gt;的发布和交流极其方便。 Git 的速度很快，这对于诸如 Linux kernel 这样的大项目来说自然很重要。 Git 最为出色的是它的合并跟踪（merge tracing）能力。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;优点：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1.适合&lt;a href=&quot;https://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BC%80%E5%8F%91&quot;&gt;分布式开发&lt;/a&gt;，强调个体。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2.公共服务器压力和数据量都不会太大。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3.速度快、灵活。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4.任意两个开发者之间可以很容易的解决冲突。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;5.离线工作。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;缺点：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1.资料少（起码中文资料很少）。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2.学习周期相对而言比较长。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3.不符合常规思维。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4.代码保密性差，一旦开发者把整个库克隆下来就可以完全公开所有代码和版本信息。[1]&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;2.&lt;/span&gt;    &lt;span&gt;Bugzilla&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Bugzilla 是一个开源的缺陷跟踪系统（Bug-Tracking System），它可以管理软件开发中缺陷的提交（new），修复（resolve），关闭（close）等整个生命周期。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Bugzilla是一开源&lt;a href=&quot;https://baike.baidu.com/item/Bug/3353935&quot;&gt;Bug&lt;/a&gt; Tracking System，是专门为&lt;a href=&quot;https://baike.baidu.com/item/Unix&quot;&gt;Unix&lt;/a&gt;定制开发的。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;优点:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;⒈ 强大的检索功能&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;⒉ 用户可配置的通过Email公布Bug变更&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;⒊ 历史变更记录&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;⒋ 通过跟踪和描述处理Bug&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;⒌ 附件管理&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;⒍ 完备的产品分类方案和细致的安全策略&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;⒎ 安全的审核机制&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;⒏ 强大的后端数据库支持&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;缺点：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1. 安装需要Perl和配置MYSQL数据库，过程比较繁琐&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2. 修改配置文件比较麻烦&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3. 英文版的，能汉化但是汉化后容易出现乱码[2]&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;3.&lt;/span&gt;  &lt;/span&gt; &lt;span&gt;&lt;span&gt;Trac&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Trac是一个为软件开发项目需要而集成了Wiki和&lt;a href=&quot;https://baike.baidu.com/item/%E9%97%AE%E9%A2%98%E8%B7%9F%E8%B8%AA%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/577451&quot;&gt;问题跟踪管理系统&lt;/a&gt;的应用平台，是一个&lt;a href=&quot;https://baike.baidu.com/item/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/8105369&quot;&gt;开源软件&lt;/a&gt;应用。Trac以简单的方式建立了一个&lt;a href=&quot;https://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/9854387&quot;&gt;软件项目管理&lt;/a&gt;的Web应用，以帮助开发人员更好地写出高质量的软件；Trac应用力求不影响现有团队的开发过程。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;优点： &lt;/span&gt; 1.Trac做一个SCM配置管理平台，意味着它有良好的扩充性&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;        2.Trac的权限体系是比较完备的设计&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;        3.非常灵活，可以随心所欲的定制，可以和TortoiseSVN集成。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;缺点：&lt;/span&gt;  1.不支持多项目，&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;        &lt;strong&gt;2&lt;/strong&gt;.&lt;strong&gt;需求和缺陷没有分离，&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;        3.用 wiki 来替代 Word 等工具编写文档对于产品策划来说门槛太高了，&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;        4.中文化不完整，美术人员接触起来困难重重，&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;        5.不显示中文名，本地化做得很差，&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;        6.核心功能很少，不安装插件基本上没法用。[3]&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;摘自百度百科&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;摘自博客园&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;摘自CSDN&lt;/span&gt;&lt;/p&gt;


















































































&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 16 Mar 2019 07:32:00 +0000</pubDate>
<dc:creator>baby孙</dc:creator>
<og:description>一.建立博客并介绍自己 我的名字叫孙玥祺，来自软件三班。 世界很大，喜欢出去走走，去各地旅游看风景，品美食，写游记。喜欢文学，写文章，看书，发表自己的感慨。我的闪光点我认为是有热情，肯上进，愿意为自己</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/230332663abcd/p/10542502.html</dc:identifier>
</item>
<item>
<title>学习笔记--图 - 殇灬央</title>
<link>http://www.cnblogs.com/shangyang/p/10542499.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shangyang/p/10542499.html</guid>
<description>&lt;h3&gt;图的定义&lt;/h3&gt;
&lt;p&gt;　　图（graph）是一种网状数据结构，图是由非空的顶点集合和一个描述顶点之间关系的集合组成。&lt;/p&gt;
&lt;p&gt;　　其形式化定义为二元组：&lt;/p&gt;
&lt;p&gt;　　　　Graph = （V，E）&lt;/p&gt;
&lt;p&gt;　　其中：&lt;/p&gt;
&lt;p&gt;　　　　V 是具有相同特性的数据元素的集合，V 中的数据元素通常称为 顶点（Vertex），&lt;/p&gt;
&lt;p&gt;　　　　E是连接V中两个不同顶点（顶点对）的边的有限集合。&lt;/p&gt;
&lt;p&gt;　　　　E = { &amp;lt; u , v &amp;gt; | P (u , v) ∩ (u,v ∈ V)}&lt;/p&gt;
&lt;h3&gt;有向图和无向图&lt;/h3&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1591870/201903/1591870-20190316145948613-1198512574.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在一个图中，如果任意两个顶点构成的偶对 (u , v) ∈ E 是无序的，即顶点之间的连线是没有方向的，则称该图为无向图（Undigrpah）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1591870/201903/1591870-20190316150008589-1257851071.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在一个图中，如果任意两个顶点构成的偶对&amp;lt;u , v&amp;gt; ∈ E是有序的，即顶点之间的连线是有方向的，则称该图为有向图（Digrpah）。&lt;/p&gt;
&lt;p&gt;　　有向图顶点之间的连线称为弧。弧有弧头和弧尾区别。&lt;/p&gt;

&lt;p&gt;　　  &lt;span&gt;注意：无向边用“（）”，而有向边用“&amp;lt; &amp;gt;”表示。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;图的存储&lt;/h3&gt;
&lt;p&gt;　　邻接矩阵 ： 二维数组 顺序结构&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1591870/201903/1591870-20190316150910832-78929984.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　其中，wij表示边 (u , v) 或弧&amp;lt;u , v&amp;gt;上的权值；∞表示一个计算机允许的、大于所有边上权值的数。&lt;/p&gt;

&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1591870/201903/1591870-20190316151102208-1321175749.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　邻接表：链表 链式存储结构&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1591870/201903/1591870-20190316151508043-1452626864.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1591870/201903/1591870-20190316151519320-1848674997.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;图的遍历&lt;/h3&gt;
&lt;p&gt;　　深度优先遍历（ DFS depth-first search ）:&lt;/p&gt;
&lt;p&gt;　　　　类似于树的先根遍历，是树的先根遍历的推广（可以采用递归和借助栈的非递归方式实现）。&lt;/p&gt;
&lt;p&gt;　　广度优先遍历（ BFS breadth-first search）:&lt;/p&gt;
&lt;p&gt;　　　　类似于树的层次遍历，是树的按层次遍历的推广（借助队列 非递归方式实现）。&lt;/p&gt;

&lt;h3&gt;最短路径&lt;/h3&gt;
&lt;p&gt;　　权值最小的最短路径：&lt;strong&gt;迪杰斯特拉算法（Dijkstra）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1591870/201903/1591870-20190316152936465-161507348.jpg&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 16 Mar 2019 07:31:00 +0000</pubDate>
<dc:creator>殇灬央</dc:creator>
<og:description>图的基本知识点</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shangyang/p/10542499.html</dc:identifier>
</item>
<item>
<title>一道很经典的 BFS 题 - Skipper-</title>
<link>http://www.cnblogs.com/backwords/p/10542486.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/backwords/p/10542486.html</guid>
<description>&lt;p&gt;想认真的写篇题解。&lt;/p&gt;
&lt;p&gt;题目来自：&lt;a href=&quot;https://www.luogu.org/problemnew/show/P1126&quot; class=&quot;uri&quot;&gt;https://www.luogu.org/problemnew/show/P1126&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;机器人移动学会（&lt;code&gt;RMI&lt;/code&gt;）现在正尝试用机器人搬运物品。机器人的形状是一个直径$1.6米的球。在试验阶段，机器人被用于在一个储藏室中搬运货物。储藏室是一个N×M的网格，有些格子为不可移动的障碍。机器人的中心总是在格点上，当然，机器人必须在最短的时间内把物品搬运到指定的地方。机器人接受的指令有：向前移动1步（&lt;code&gt;Creep&lt;/code&gt;）；向前移动2步（&lt;code&gt;Walk&lt;/code&gt;）；向前移动3步（&lt;code&gt;Run&lt;/code&gt;）；向左转（&lt;code&gt;Left&lt;/code&gt;）；向右转（&lt;code&gt;Right&lt;/code&gt;）。每个指令所需要的时间为1秒。请你计算一下机器人完成任务所需的最少时间。&lt;/p&gt;
&lt;h3 id=&quot;输入&quot;&gt;输入&lt;/h3&gt;
&lt;p&gt;第一行为两个正整数N,M(N,M≤50)，下面N行是储藏室的构造，0表示无障碍，1表示有障碍，数字之间用一个空格隔开。接着一行有4个整数和1个大写字母，分别为起始点和目标点左上角网格的行与列，起始时的面对方向（东E，南S，西W，北N），数与数，数与字母之间均用一个空格隔开。终点的面向方向是任意的。&lt;/p&gt;
&lt;h3 id=&quot;输出&quot;&gt;输出&lt;/h3&gt;
&lt;p&gt;一个整数，表示机器人完成任务所需的最少时间。如果无法到达，输出-1。&lt;/p&gt;
&lt;h3 id=&quot;图例&quot;&gt;图例&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1131119/201903/1131119-20190316152702572-1052676809.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;分析&quot;&gt;分析&lt;/h2&gt;
&lt;p&gt;以前在刷刘汝佳的紫书《算法竞赛入门经典》时做过这道题，现在又再次遇到，幸不汝（辱）命，一次就过了。&lt;/p&gt;
&lt;h4 id=&quot;bfs-性质&quot;&gt;BFS 性质&lt;/h4&gt;
&lt;p&gt;我们都知道，BFS 具有从起点到目标节点（或状态）路径最短的特性，但是使用 BSF 这一特性时需要注意，只有当所有的边权重相同（一般为1）时，它才具有此性质，边权不等时不具有。BFS 每次从一个节点只经历一次转移，当求单纯的求距离时可以认为每次转移的边权为一，转移次数最少的路径一定是距离最短的。我们可以用两张图来直观的表现这个特性：&lt;/p&gt;
&lt;p&gt;在图上：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1131119/201903/1131119-20190316152712622-1681125589.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;初始节点为 0，每次从一个节点向四周节点扩散，访问所有距离为一（相邻，经过一次状态转换）的节点。&lt;/p&gt;
&lt;p&gt;第一次扩散访问了所有蓝色节点，并没有找到目标节点，继续扩散。第二次扩散访问了两个粉色节点，虚线节点并没有被访问。因为在扩散到左边的粉色节点时，我们已经找到了目标节点。那么不去搜索第三个粉色节点（虚线）节点不会丢解吗？在图中我们也确实能看到，虚线节点在经历一次扩散后，到达紫色节点，紫色节点再扩散一次，也可到达目标节点。不过，这个选择无论是从上述图片还是从我的描述文字来看，他的距离都不短。那么为什么会这样呢？我说一下我个人的理解。看下面一幅图：&lt;/p&gt;
&lt;p&gt;在树上：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1131119/201903/1131119-20190316152724348-652241468.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在树上的 BFS 被称为层次遍历。他的工作原理就如其名，每次访问一层的节点，同一层的节点有一个特点就是，他们的层数是相同的，也即到根节点的距离。当扩散到第三层时，（从左向右）第三个粉色节点作为目标节点被发现，此时我们可以对比三种情况：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;由于第三个粉色节点为第一个目标节点，所以所有该节点左侧同层节点都不是目标节点，并且从这些节点继续扩散出的节点的层数（即到根节点的距离）一定 &lt;strong&gt;大于&lt;/strong&gt; 第三个粉色节点到根节点的距离。&lt;/li&gt;
&lt;li&gt;对于第三个粉色节点，也即我们的第一个目标节点（为什么强调 “第一个” 因为可能有不止一个目标节点，即多个解），由他扩散而出的子节点的距离一定 &lt;strong&gt;大于&lt;/strong&gt; 这个节点。&lt;/li&gt;
&lt;li&gt;对于虚线节点，由于他是不是目标节点，在未访问到时未知，而他的性质是和第一种情况相似的，所以去访问并扩散虚线节点我们能得到的结果是他的距离&lt;br/&gt;&lt;strong&gt;大于等于&lt;/strong&gt; 第三个粉色节点&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;由此，可以得出如果只有一个解，那么第一次被发现的目标节点 即第三个粉色节点一定是距离根节点最近的。&lt;/p&gt;
&lt;p&gt;在图上也可以类比层的概念，得出相同的结论。&lt;/p&gt;
&lt;h4 id=&quot;解题思路&quot;&gt;解题思路&lt;/h4&gt;
&lt;p&gt;BFS 的性质讨论完，再来具体考虑这道题。这道题应该能明显看出来，是在图上寻找最短路的问题。不过首先需要对数据进行一些分析处理，才能更好的应用 BFS。此题唯一有些麻烦的就是，机器人具有半径，将每个格子单独处理不方便。由给出的图例可以发现，机器人一定会占据四个格子的空间，而一旦一个格子障碍物出现，那么这个障碍物格子所在的四个四方格上的中心格点机器人都不能走（机器人只走格点）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1131119/201903/1131119-20190316152746029-1181654402.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以在读完输入键一个图后，可以再创建一个简化版的图，mini map。它将原图中每四个格点当做一个点，而机器人只走这四个格子的中心，一旦一个四方格中有一个障碍，那么这个四方格认为不可走。这样一来机器人移动、机器人半径、单个方格障碍物问题就简化成了最常见的情况：在一个图上的点避开障碍物到达另一个点的最短路。（这中简化和机器人在原图上的移动是等价的，可以模拟一下）。&lt;/p&gt;
&lt;p&gt;以下是这部分处理代码：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;    for(int i = 0; i &amp;lt; n; ++i) {
        for(int j = 0; j &amp;lt; m; ++j) {
            cin &amp;gt;&amp;gt; graph[i][j];
        }
    }

    int p = 0,q = 0;
    for(int i = 0; i &amp;lt; n-1; ++i) {
        q = 0;
        for(int j = 0; j &amp;lt; m-1; ++j) {
            if(graph[i][j] || graph[i][j+1] || graph[i+1][j] || graph[i+1][j+1])
                mini[p][q] = 1;//标记为障碍，否则为 0 表示可达
            q++;
        }
        p++;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;建出了图，现在考虑状态的转移。此题中，每个节点可以有三种转移情况，向左转，向右转，移动。&lt;/p&gt;
&lt;p&gt;每种情况耗时为 1（可以认为是距离，权重）。关于转向问题，可以定义一个方向数组，按顺时针顺序给出北东南西，然后无论朝向那个方位，向左转就是数组索引减一，向右转就是加一，检索方向数组获得新的方位。完成一次转向后，就完成了一次状态转移，将新的节点入队列，这个新的节点在下一次被取出考虑进行转移状态时，他的当前方向就是移动的方向。&lt;/p&gt;
&lt;p&gt;宏和数据结构：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#define MAX 50
#define DIR 4
#define N 0
#define E 1
#define S 2
#define W 3

struct Node {
    int x,y;
    int step = 0;
    int d;
    Node (int x,int y,int step,int dir) {
        this-&amp;gt;x = x,this-&amp;gt;y = y,this-&amp;gt;step = step,this-&amp;gt;d = dir;
    }
    // Node () {}
    // int pre = 0;
    // int loc = 0;
};

int graph[MAX + 1][MAX + 1];
int mini[MAX + 1][MAX + 1];     //mini graph
int vis[MAX + 1][MAX + 1][DIR];
//          N  E  S  W
int dx[] = {-1,0, 1, 0};
int dy[] = {0, 1, 0,-1};
int n,m;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;BFS 代码：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;
Node bfs(int sx,int sy,int tx,int ty,int dir) {
    queue&amp;lt;Node&amp;gt; q;
    Node start = Node(sx,sy,0,dir);
    q.push(start);
    // path[pi++] = start;
    vis[sx][sy][dir] = 1;
    while(!q.empty()) {
        Node u = q.front();
        q.pop();

        if(u.x == tx &amp;amp;&amp;amp; u.y == ty) return u;

        //尝试向左转
        if(!vis[u.x][u.y][(u.d-1+DIR)%DIR]) {
            vis[u.x][u.y][(u.d-1+DIR)%DIR] = 1;
            Node nu = Node(u.x,u.y,u.step+1,(u.d-1+DIR)%DIR);
            // nu.pre = u.loc;      //记录路径信息
            // nu.loc = pi;
            // path[pi++] = nu;
            q.push(nu);
        }
        //尝试向右转
        if(!vis[u.x][u.y][(u.d+1)%DIR]) {
            vis[u.x][u.y][(u.d+1)%DIR] = 1;
            Node nu = Node(u.x,u.y,u.step+1,(u.d+1)%DIR);
            // nu.pre = u.loc;
            // nu.loc = pi;
            // path[pi++] = nu;
            q.push(nu);
        }
        //尝试移动 creep，walk，run
        for(int i = 1; i &amp;lt;= 3; ++i) {
            Node nu = Node(u.x,u.y,u.step+1,u.d);
            //判断是是否有障碍物。只要有一个，就不必移动了。
            bool isok = true;
            for(int j = 0; j &amp;lt; i; ++j) {
                if(mini[nu.x+dx[u.d]*j][nu.y+dy[u.d]*j])
                    { isok = false; break; }
            }
            if(isok == false) break;

            nu.x += dx[u.d] * i;
            nu.y += dy[u.d] * i;

            if(inrange(nu) &amp;amp;&amp;amp; !vis[nu.x][nu.y][nu.d]) {
                vis[nu.x][nu.y][nu.d] = 1;
                // nu.pre = u.loc;
                // nu.loc = pi;
                // path[pi++] = nu;
                q.push(nu);
            }
        }
    }
    return Node(-1,-1,-1,-1);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中注释代码是用来记录最短路的路径信息。在这里是我用来测试程序的。&lt;/p&gt;
&lt;p&gt;在调试的时候遇到一个 bug 花了我几个小时，机器人移动方式有 creep，walk，run，分别移动 1 、2 、3 步，在移动步数大于 1 时，不能只判断目标节点是否是障碍物，而要判断每一步是否有障碍物。&lt;/p&gt;
&lt;p&gt;完整程序：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;memory.h&amp;gt;
#include &amp;lt;queue&amp;gt;
using namespace std;

#define MAX 50
#define DIR 4
#define N 0
#define E 1
#define S 2
#define W 3

struct Node {
    int x,y;
    int step = 0;
    int d;
    Node (int x,int y,int step,int dir) {
        this-&amp;gt;x = x,this-&amp;gt;y = y,this-&amp;gt;step = step,this-&amp;gt;d = dir;
    }
    // Node () {}
    // int pre = 0;
    // int loc = 0;
};

int graph[MAX + 1][MAX + 1];
int mini[MAX + 1][MAX + 1];     //mini graph
int vis[MAX + 1][MAX + 1][DIR];
//          N  E  S  W
int dx[] = {-1,0, 1, 0};
int dy[] = {0, 1, 0,-1};
int n,m;

// Node path[MAX * MAX + 1];
// int pi = 0;

bool inrange(Node nd) {
    return nd.x &amp;gt;= 0 &amp;amp;&amp;amp; nd.x &amp;lt;= n-2 &amp;amp;&amp;amp; nd.y &amp;gt;= 0 &amp;amp;&amp;amp; nd.y &amp;lt;= m-2;
}

Node bfs(int sx,int sy,int tx,int ty,int dir) {
    queue&amp;lt;Node&amp;gt; q;
    Node start = Node(sx,sy,0,dir);
    q.push(start);
    // path[pi++] = start;
    vis[sx][sy][dir] = 1;
    while(!q.empty()) {
        Node u = q.front();
        q.pop();

        if(u.x == tx &amp;amp;&amp;amp; u.y == ty) return u;

        //尝试向左转
        if(!vis[u.x][u.y][(u.d-1+DIR)%DIR]) {
            vis[u.x][u.y][(u.d-1+DIR)%DIR] = 1;
            Node nu = Node(u.x,u.y,u.step+1,(u.d-1+DIR)%DIR);
            // nu.pre = u.loc;      //记录路径信息
            // nu.loc = pi;
            // path[pi++] = nu;
            q.push(nu);
        }
        //尝试向右转
        if(!vis[u.x][u.y][(u.d+1)%DIR]) {
            vis[u.x][u.y][(u.d+1)%DIR] = 1;
            Node nu = Node(u.x,u.y,u.step+1,(u.d+1)%DIR);
            // nu.pre = u.loc;
            // nu.loc = pi;
            // path[pi++] = nu;
            q.push(nu);
        }
        //尝试移动 creep，walk，run
        for(int i = 1; i &amp;lt;= 3; ++i) {
            Node nu = Node(u.x,u.y,u.step+1,u.d);
            ////判断是是否有障碍物。只要有一个，就不必移动了。
            bool isok = true;
            for(int j = 1; j &amp;lt;= i; ++j) {
                if(mini[nu.x+dx[u.d]*j][nu.y+dy[u.d]*j])
                    { isok = false; break; }
            }
            if(isok == false) break;

            nu.x += dx[u.d] * i;
            nu.y += dy[u.d] * i;

            if(inrange(nu) &amp;amp;&amp;amp; !vis[nu.x][nu.y][nu.d]) {
                vis[nu.x][nu.y][nu.d] = 1;
                // nu.pre = u.loc;
                // nu.loc = pi;
                // path[pi++] = nu;
                q.push(nu);
            }
        }
    }
    return Node(-1,-1,-1,-1);
}

int main(int argc, char const *argv[])
{
    freopen(&quot;/home/skipper/Documents/code/刷题/洛谷 OJ/重启/in.txt&quot;,&quot;r&quot;,stdin);
    int sx,sy,tx,ty;
    char dir;
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    for(int i = 0; i &amp;lt; n; ++i) {
        for(int j = 0; j &amp;lt; m; ++j) {
            cin &amp;gt;&amp;gt; graph[i][j];
        }
    }

    int p = 0,q = 0;
    for(int i = 0; i &amp;lt; n-1; ++i) {
        q = 0;
        for(int j = 0; j &amp;lt; m-1; ++j) {
            if(graph[i][j] || graph[i][j+1] || graph[i+1][j] || graph[i+1][j+1])
                mini[p][q] = 1;
            q++;
        }
        p++;
    }
    int d;
    cin &amp;gt;&amp;gt; sx &amp;gt;&amp;gt; sy &amp;gt;&amp;gt; tx &amp;gt;&amp;gt; ty &amp;gt;&amp;gt; dir;
    switch(dir) {
        case 'S': d = S;break;
        case 'N': d = N;break;
        case 'E': d = E;break;
        case 'W': d = W;break;
    };

    //test 查看 mini map
    // for(int i = 0; i &amp;lt; p; ++i) {
    //  for(int j = 0; j &amp;lt; q; ++j) {
    //      cout &amp;lt;&amp;lt; mini[i][j] &amp;lt;&amp;lt; &quot; &quot;;
    //  }
    //  cout &amp;lt;&amp;lt; endl;
    // }

    Node res = bfs(sx-1,sy-1,tx-1,ty-1,d);

    //输出路径
    // int pp = res.loc;
    // do {
    //  cout &amp;lt;&amp;lt; path[pp].x &amp;lt;&amp;lt; &quot;,&quot; &amp;lt;&amp;lt; path[pp].y &amp;lt;&amp;lt; endl;
    //  pp = path[pp].pre;
    // }while(pp);

    cout &amp;lt;&amp;lt; res.step &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如有错误，欢迎指正评论。&lt;/p&gt;
</description>
<pubDate>Sat, 16 Mar 2019 07:31:00 +0000</pubDate>
<dc:creator>Skipper-</dc:creator>
<og:description>认真的写篇题解。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/backwords/p/10542486.html</dc:identifier>
</item>
<item>
<title>对象引用、可变性和垃圾回收 - StackNeverOverFlow</title>
<link>http://www.cnblogs.com/StackNeverOverFlow/p/10486279.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/StackNeverOverFlow/p/10486279.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;变量不是盒子，它是对象的标识&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　- 标识、相等性和别名&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
charles = {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Chales L.Dogson&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;born&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:1832&lt;span&gt;}

lewis &lt;/span&gt;=&lt;span&gt; charles

alex &lt;/span&gt;= {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Chales L.Dogson&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;born&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:1832&lt;span&gt;}

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; lewis是charles的别名，is比较的是两个对象的id&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;charles is lewis:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,charles &lt;span&gt;is&lt;/span&gt;&lt;span&gt; lewis)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; alex标识的对象和charles不同&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;charles is alex:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,charles &lt;span&gt;is&lt;/span&gt;&lt;span&gt; alex)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 但它们的值相等，'=='是语法糖，事实上调用的是__eq__&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; dict对'=='进行了重载，比较的是对象的内容&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;charles == alex:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,charles ==&lt;span&gt; alex)

输出：
charles &lt;/span&gt;&lt;span&gt;is&lt;/span&gt;&lt;span&gt; lewis: True
charles &lt;/span&gt;&lt;span&gt;is&lt;/span&gt;&lt;span&gt; alex: False
charles &lt;/span&gt;== alex: True
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;复制&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　- 复制列表或多数内置可变集合，最简单的方式是使用内置的类型构造方法&lt;/p&gt;
&lt;p&gt;　　- 默认是浅复制&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;74&quot;&gt;
&lt;pre&gt;
l1 = [3,[55,44],(7,8,9&lt;span&gt;)]

l2 &lt;/span&gt;=&lt;span&gt; list(l1)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 复制之后,l2和l1内容相同&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;l2==l1:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,l2 ==&lt;span&gt; l1)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 但指向不同对象&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;l2 is l1:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,l2 &lt;span&gt;is&lt;/span&gt;&lt;span&gt; l1)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 但它们内部的元素仍然是同一个对象&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;l2[1] is l1[1]:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,l2[1] &lt;span&gt;is&lt;/span&gt; l1[1&lt;span&gt;])

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 根据内部元素不同，将会产生不同表现&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 可变元素会相互影响&lt;/span&gt;
l1[1].append(33&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;after l1[1] append:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;l1:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,l1)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;l2:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,l2)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 不可变元素不会互相影响&lt;/span&gt;
l1[2] += (10&lt;span&gt;,)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;after l1[2] append:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;l1:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,l1)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;l2:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,l2)

输出：
l2&lt;/span&gt;==&lt;span&gt;l1: True
l2 &lt;/span&gt;&lt;span&gt;is&lt;/span&gt;&lt;span&gt; l1: False
l2[&lt;/span&gt;1] &lt;span&gt;is&lt;/span&gt; l1[1&lt;span&gt;]: True
after l1[&lt;/span&gt;1&lt;span&gt;] append:
l1: [&lt;/span&gt;3, [55, 44, 33], (7, 8, 9&lt;span&gt;)]
l2: [&lt;/span&gt;3, [55, 44, 33], (7, 8, 9&lt;span&gt;)]
after l1[&lt;/span&gt;2&lt;span&gt;] append:
l1: [&lt;/span&gt;3, [55, 44, 33], (7, 8, 9, 10&lt;span&gt;)]
l2: [&lt;/span&gt;3, [55, 44, 33], (7, 8, 9)]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　- 深复制需要用到copy.deepcopy&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;69&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; copy &lt;span&gt;import&lt;/span&gt;&lt;span&gt; deepcopy

l1 &lt;/span&gt;= [3,[55,44],(7,8,9&lt;span&gt;)]

l2 &lt;/span&gt;=&lt;span&gt; deepcopy(l1)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 内部的元素不再是同一个对象&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;l2[1] is l1[1]:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,l2[1] &lt;span&gt;is&lt;/span&gt; l1[1&lt;span&gt;])


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 无论可变还是不可变元素，都不会相互影响&lt;/span&gt;
l1[1].append(33&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;after l1[1] append:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;l1:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,l1)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;l2:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,l2)

l1[&lt;/span&gt;2] += (10&lt;span&gt;,)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;after l1[2] append:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;l1:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,l1)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;l2:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,l2)

输出：
l2[&lt;/span&gt;1] &lt;span&gt;is&lt;/span&gt; l1[1&lt;span&gt;]: False
after l1[&lt;/span&gt;1&lt;span&gt;] append:
l1: [&lt;/span&gt;3, [55, 44, 33], (7, 8, 9&lt;span&gt;)]
l2: [&lt;/span&gt;3, [55, 44], (7, 8, 9&lt;span&gt;)]
after l1[&lt;/span&gt;2&lt;span&gt;] append:
l1: [&lt;/span&gt;3, [55, 44, 33], (7, 8, 9, 10&lt;span&gt;)]
l2: [&lt;/span&gt;3, [55, 44], (7, 8, 9)]
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;WeakValueDictionary&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; weakref


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Dog:

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self,name):

        self.name &lt;/span&gt;=&lt;span&gt; name

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__repr__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Dog(%s)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; self.name


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; stock保存一个弱引用的可变映射&lt;/span&gt;
stock =&lt;span&gt; weakref.WeakValueDictionary()

catalog &lt;/span&gt;= [Dog(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Alen&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;),Dog(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Bob&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;),Dog(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Wendy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)]

&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; dog &lt;span&gt;in&lt;/span&gt;&lt;span&gt; catalog:
    stock[dog.name] &lt;/span&gt;=&lt;span&gt; dog

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(sorted(stock.keys()))

&lt;/span&gt;&lt;span&gt;del&lt;/span&gt;&lt;span&gt; catalog

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 其他Dog对象的引用都消失了，只剩下dog引用了Wendy&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(sorted(stock.keys()))

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 把dog删除，Wendy也消失了&lt;/span&gt;
&lt;span&gt;del&lt;/span&gt;&lt;span&gt; dog

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(sorted(stock.keys()))&lt;p&gt;输出：
&lt;/p&gt;&lt;/pre&gt;
&lt;p&gt;['Alen', 'Bob', 'Wendy']&lt;br/&gt;['Wendy']&lt;br/&gt;[]&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;WeakKeyDictionary&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; weakref


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Dog:

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self,name):

        self.name &lt;/span&gt;=&lt;span&gt; name

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__repr__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Dog(%s)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; self.name


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; stock保存一个弱引用的可变映射&lt;/span&gt;
stock =&lt;span&gt; weakref.WeakKeyDictionary()

catalog &lt;/span&gt;= [Dog(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Alen&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;),Dog(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Bob&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;),Dog(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Wendy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)]

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 和WeakValueDictionary不同，WeakKeyDictionary的键是被引用的对象&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; dog &lt;span&gt;in&lt;/span&gt;&lt;span&gt; catalog:
    stock[dog] &lt;/span&gt;=&lt;span&gt; dog.name

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;([item.name &lt;span&gt;for&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; stock.keys()])

&lt;/span&gt;&lt;span&gt;del&lt;/span&gt;&lt;span&gt; catalog

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 其他Dog对象的引用都消失了，只剩下dog引用了Wendy&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;([item.name &lt;span&gt;for&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; stock.keys()])

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 把dog删除，Wendy也消失了&lt;/span&gt;
&lt;span&gt;del&lt;/span&gt;&lt;span&gt; dog

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;([item.name &lt;span&gt;for&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt; stock.keys()])&lt;p&gt;输出：
&lt;/p&gt;&lt;/pre&gt;
&lt;p&gt;['Alen', 'Bob', 'Wendy']&lt;br/&gt;['Wendy']&lt;br/&gt;[]&lt;/p&gt;
&lt;/div&gt;

</description>
<pubDate>Sat, 16 Mar 2019 07:29:00 +0000</pubDate>
<dc:creator>StackNeverOverFlow</dc:creator>
<og:description>变量不是盒子，它是对象的标识 - 标识、相等性和别名 复制 - 复制列表或多数内置可变集合，最简单的方式是使用内置的类型构造方法 - 默认是浅复制 - 深复制需要用到copy.deepcopy Wea</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/StackNeverOverFlow/p/10486279.html</dc:identifier>
</item>
<item>
<title>数据结构 之 链表 - 最美的烟火</title>
<link>http://www.cnblogs.com/donghaoblogs/p/10542491.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/donghaoblogs/p/10542491.html</guid>
<description>&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;链表是一种物理&lt;a href=&quot;https://baike.baidu.com/item/%E5%AD%98%E5%82%A8%E5%8D%95%E5%85%83/8727749&quot; target=&quot;_blank&quot; data-lemmaid=&quot;8727749&quot;&gt;存储单元&lt;/a&gt;上非连续、非顺序的&lt;a href=&quot;https://baike.baidu.com/item/%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/350782&quot; target=&quot;_blank&quot; data-lemmaid=&quot;350782&quot;&gt;存储结构&lt;/a&gt;，&lt;a href=&quot;https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0/715313&quot; target=&quot;_blank&quot; data-lemmaid=&quot;715313&quot;&gt;数据元素&lt;/a&gt;的逻辑顺序是通过链表中的&lt;a href=&quot;https://baike.baidu.com/item/%E6%8C%87%E9%92%88/2878304&quot; target=&quot;_blank&quot; data-lemmaid=&quot;2878304&quot;&gt;指针&lt;/a&gt;链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储&lt;a href=&quot;https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0&quot; target=&quot;_blank&quot;&gt;数据元素&lt;/a&gt;的数据域，另一个是存储下一个结点地址的&lt;a href=&quot;https://baike.baidu.com/item/%E6%8C%87%E9%92%88/2878304&quot; target=&quot;_blank&quot; data-lemmaid=&quot;2878304&quot;&gt;指针&lt;/a&gt;域&lt;/p&gt;
&lt;p&gt;　　使用链表结构可以克服&lt;a href=&quot;https://baike.baidu.com/item/%E6%95%B0%E7%BB%84/3794097&quot; target=&quot;_blank&quot; data-lemmaid=&quot;3794097&quot;&gt;数组&lt;/a&gt;链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了&lt;a href=&quot;https://baike.baidu.com/item/%E6%95%B0%E7%BB%84/3794097&quot; target=&quot;_blank&quot; data-lemmaid=&quot;3794097&quot;&gt;数组&lt;/a&gt;随机读取的优点，同时链表由于增加了结点的&lt;a href=&quot;https://baike.baidu.com/item/%E6%8C%87%E9%92%88/2878304&quot; target=&quot;_blank&quot; data-lemmaid=&quot;2878304&quot;&gt;指针&lt;/a&gt;域，空间开销比较大。链表最明显的好处就是，常规&lt;a href=&quot;https://baike.baidu.com/item/%E6%95%B0%E7%BB%84/3794097&quot; target=&quot;_blank&quot; data-lemmaid=&quot;3794097&quot;&gt;数组&lt;/a&gt;排列关联项目的方式可能不同于这些数据项目在&lt;a href=&quot;https://baike.baidu.com/item/%E8%AE%B0%E5%BF%86%E4%BD%93/3029693&quot; target=&quot;_blank&quot; data-lemmaid=&quot;3029693&quot;&gt;记忆体&lt;/a&gt;或&lt;a href=&quot;https://baike.baidu.com/item/%E7%A3%81%E7%9B%98/2842227&quot; target=&quot;_blank&quot; data-lemmaid=&quot;2842227&quot;&gt;磁盘&lt;/a&gt;上顺序，数据的存取往往要在不同的排列顺序中转换。链表允许插入和移除表上任意位置上的&lt;a href=&quot;https://baike.baidu.com/item/%E8%8A%82%E7%82%B9/865052&quot; target=&quot;_blank&quot; data-lemmaid=&quot;865052&quot;&gt;节点&lt;/a&gt;，但是不允许&lt;a href=&quot;https://baike.baidu.com/item/%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%8F%96/4610937&quot; target=&quot;_blank&quot; data-lemmaid=&quot;4610937&quot;&gt;随机存取&lt;/a&gt;。链表有很多种不同的类型：&lt;a href=&quot;https://baike.baidu.com/item/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/8671935&quot; target=&quot;_blank&quot; data-lemmaid=&quot;8671935&quot;&gt;单向链表&lt;/a&gt;，&lt;a href=&quot;https://baike.baidu.com/item/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/2968731&quot; target=&quot;_blank&quot; data-lemmaid=&quot;2968731&quot;&gt;双向链表&lt;/a&gt;以及&lt;a href=&quot;https://baike.baidu.com/item/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/3228465&quot; target=&quot;_blank&quot; data-lemmaid=&quot;3228465&quot;&gt;循环链表&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;单向链表&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　单向链表又称单链表，是链表中最简单的一种形式，他的每个节点包含两个域，一个是信息域（元素域），一个事链接域&lt;/p&gt;
&lt;p&gt;这个链接指向的链表的下一个节点，而最后的一个节点链接域则指向空&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1582729/201903/1582729-20190316151751162-1299667562.png&quot; alt=&quot;&quot; width=&quot;628&quot; height=&quot;307&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;基本操作：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1582729/201903/1582729-20190316151924713-200461191.png&quot; alt=&quot;&quot; width=&quot;408&quot; height=&quot;202&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码实现 (python)：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1. 创建结点&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Node(object):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;结点&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self,item):
        self.item &lt;/span&gt;=&lt;span&gt; item
        self.next &lt;/span&gt;= None
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2. 创建链表&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; SingleList(object):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;单链表&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;(self,node=&lt;span&gt;None):
        self._head &lt;/span&gt;= node
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3. 基本操作&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; is_empty(self):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;链表是否为空&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; self._head ==&lt;span&gt; None


    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; length(self):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;链表长度&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        cur &lt;/span&gt;=&lt;span&gt;  self._head
        count &lt;/span&gt;=&lt;span&gt; 0
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; cur &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; None:
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; cur.next:
                count&lt;/span&gt;+=1&lt;span&gt;
                cur &lt;/span&gt;=&lt;span&gt; cur.next
            count &lt;/span&gt;+= 1  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 补上最后一个节点数量。&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; count

        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; cur = self._head&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; count = 0&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; while cur != None:&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;     count += 1&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;     cur = cur.next&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; return count&lt;/span&gt;


    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; traval(self):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;遍历整个链表&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        cur &lt;/span&gt;=&lt;span&gt; self._head
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; cur!=&lt;span&gt; None:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(cur.item)
            cur &lt;/span&gt;=&lt;span&gt; cur.next
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;*30&lt;span&gt;)


    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; add(self,item):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;头部添加元素&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; node = Node(item)&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; if self.is_empty():&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;     self._head = node&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; else:&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;     oldnode = self._head&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;     self._head = node&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;     node.next = oldnode&lt;/span&gt;

        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 简化：&lt;/span&gt;
        node =&lt;span&gt; Node(item)
        node.next &lt;/span&gt;=&lt;span&gt; self._head
        self._head &lt;/span&gt;=&lt;span&gt; node

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; append(self,item):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;链表尾部添加元素&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        node &lt;/span&gt;=&lt;span&gt; Node(item)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; self.is_empty():
            self._head &lt;/span&gt;=&lt;span&gt; node
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            cur &lt;/span&gt;=&lt;span&gt; self._head
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; cur.next !=&lt;span&gt; None:
                cur &lt;/span&gt;=&lt;span&gt; cur.next
            cur.next &lt;/span&gt;=&lt;span&gt; node

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; insert(self,pos,item):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;指定位置添加元素
        :param pos start is 0
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; pos &amp;lt;&lt;span&gt; 0:
            self.add(item)  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 头插法&lt;/span&gt;
        &lt;span&gt;elif&lt;/span&gt; pos &amp;gt; self.length()-1&lt;span&gt;:
            self.append(item)  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 尾插法&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            node &lt;/span&gt;=&lt;span&gt; Node(item)
            pre &lt;/span&gt;=&lt;span&gt; self._head
            count &lt;/span&gt;=&lt;span&gt; 0
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; count &amp;lt; (pos - 1):  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; pos- 1  移动前一位置,对前一节点进行操作&lt;/span&gt;
                count += 1&lt;span&gt;
                pre &lt;/span&gt;=&lt;span&gt; pre.next
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 当循环退出后，pre 指向pos-1位置&lt;/span&gt;
            node.next, pre.next =&lt;span&gt; pre.next, node


    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; remove(self,item):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;删除节点&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        cur &lt;/span&gt;=&lt;span&gt; self._head
        pre &lt;/span&gt;=&lt;span&gt; None
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; cur!=&lt;span&gt;None:
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; cur.item ==&lt;span&gt; item:
                &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 判断是不是在头节点删除&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; cur &lt;span&gt;is&lt;/span&gt; self._head:  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; pre is None or cur is self._head&lt;/span&gt;
                    self._head =&lt;span&gt; cur.next
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                    pre.next &lt;/span&gt;=&lt;span&gt; cur.next
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;
            pre &lt;/span&gt;=&lt;span&gt; cur
            cur &lt;/span&gt;=&lt;span&gt; cur.next

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; search(self,item):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;查找元素&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        cur &lt;/span&gt;=&lt;span&gt; self._head
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; cur!=&lt;span&gt;None:
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; cur.item ==&lt;span&gt; item:
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; True
            cur &lt;/span&gt;=&lt;span&gt; cur.next
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; False
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('852fc9e4-e0a4-4b2f-94e8-c37ddaa5da47')&quot; readability=&quot;42.5&quot;&gt;&lt;img id=&quot;code_img_closed_852fc9e4-e0a4-4b2f-94e8-c37ddaa5da47&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_852fc9e4-e0a4-4b2f-94e8-c37ddaa5da47&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('852fc9e4-e0a4-4b2f-94e8-c37ddaa5da47',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_852fc9e4-e0a4-4b2f-94e8-c37ddaa5da47&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;80&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;encoding:utf-8&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; __author__ = 'donghao'&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; __time__ = 2019/3/15 21:39&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; a = 10&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; b = 20&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; c = 30&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; print(id(a))&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; print(id(b))&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; print(id(c))&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; a,b,c = b,c,a&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; print('改变后 a ',id(a))&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; print('改变后 b ',id(b))&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; print('改变后 c ',id(c))&lt;/span&gt;

&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Node(object):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;结点&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self,item):
        self.item &lt;/span&gt;=&lt;span&gt; item
        self.next &lt;/span&gt;=&lt;span&gt; None

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; SingleList(object):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;单链表&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;(self,node=&lt;span&gt;None):
        self._head &lt;/span&gt;=&lt;span&gt; node

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; is_empty(self):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;链表是否为空&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; self._head ==&lt;span&gt; None


    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; length(self):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;链表长度&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        cur &lt;/span&gt;=&lt;span&gt;  self._head
        count &lt;/span&gt;=&lt;span&gt; 0
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; cur &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; None:
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; cur.next:
                count&lt;/span&gt;+=1&lt;span&gt;
                cur &lt;/span&gt;=&lt;span&gt; cur.next
            count &lt;/span&gt;+= 1  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 补上最后一个节点数量。&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; count

        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; cur = self._head&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; count = 0&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; while cur != None:&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;     count += 1&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;     cur = cur.next&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; return count&lt;/span&gt;


    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; traval(self):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;遍历整个链表&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        cur &lt;/span&gt;=&lt;span&gt; self._head
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; cur!=&lt;span&gt; None:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(cur.item)
            cur &lt;/span&gt;=&lt;span&gt; cur.next
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;*30&lt;span&gt;)


    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; add(self,item):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;头部添加元素&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; node = Node(item)&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; if self.is_empty():&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;     self._head = node&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; else:&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;     oldnode = self._head&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;     self._head = node&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;     node.next = oldnode&lt;/span&gt;

        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 简化：&lt;/span&gt;
        node =&lt;span&gt; Node(item)
        node.next &lt;/span&gt;=&lt;span&gt; self._head
        self._head &lt;/span&gt;=&lt;span&gt; node

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; append(self,item):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;链表尾部添加元素&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        node &lt;/span&gt;=&lt;span&gt; Node(item)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; self.is_empty():
            self._head &lt;/span&gt;=&lt;span&gt; node
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            cur &lt;/span&gt;=&lt;span&gt; self._head
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; cur.next !=&lt;span&gt; None:
                cur &lt;/span&gt;=&lt;span&gt; cur.next
            cur.next &lt;/span&gt;=&lt;span&gt; node

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; insert(self,pos,item):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;指定位置添加元素
        :param pos start is 0
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; pos &amp;lt;&lt;span&gt; 0:
            self.add(item)  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 头插法&lt;/span&gt;
        &lt;span&gt;elif&lt;/span&gt; pos &amp;gt; self.length()-1&lt;span&gt;:
            self.append(item)  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 尾插法&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            node &lt;/span&gt;=&lt;span&gt; Node(item)
            pre &lt;/span&gt;=&lt;span&gt; self._head
            count &lt;/span&gt;=&lt;span&gt; 0
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; count &amp;lt; (pos - 1):  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; pos- 1  移动前一位置,对前一节点进行操作&lt;/span&gt;
                count += 1&lt;span&gt;
                pre &lt;/span&gt;=&lt;span&gt; pre.next
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 当循环退出后，pre 指向pos-1位置&lt;/span&gt;
            node.next, pre.next =&lt;span&gt; pre.next, node


    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; remove(self,item):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;删除节点&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        cur &lt;/span&gt;=&lt;span&gt; self._head
        pre &lt;/span&gt;=&lt;span&gt; None
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; cur!=&lt;span&gt;None:
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; cur.item ==&lt;span&gt; item:
                &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 判断是不是在头节点删除&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; cur &lt;span&gt;is&lt;/span&gt; self._head:  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; pre is None or cur is self._head&lt;/span&gt;
                    self._head =&lt;span&gt; cur.next
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                    pre.next &lt;/span&gt;=&lt;span&gt; cur.next
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;
            pre &lt;/span&gt;=&lt;span&gt; cur
            cur &lt;/span&gt;=&lt;span&gt; cur.next

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; search(self,item):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;查找元素&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        cur &lt;/span&gt;=&lt;span&gt; self._head
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; cur!=&lt;span&gt;None:
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; cur.item ==&lt;span&gt; item:
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; True
            cur &lt;/span&gt;=&lt;span&gt; cur.next
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; False



single_obj &lt;/span&gt;= SingleList() &lt;span&gt;#&lt;/span&gt;&lt;span&gt;初始化链表&lt;/span&gt;
&lt;span&gt;
single_obj.append(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
single_obj.append(&lt;/span&gt;400&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(single_obj.is_empty())
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(single_obj.length())
single_obj.traval()

single_obj.add(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;add head 1000&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
single_obj.add(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;add head 2000&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
single_obj.add(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;add head 3000&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(single_obj.is_empty())
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(single_obj.length())
single_obj.traval()


single_obj.insert(&lt;/span&gt;-1,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;插入节点&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
single_obj.insert(&lt;/span&gt;5,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;大于长度插入节点&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
single_obj.traval()

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(single_obj.search(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))

single_obj.remove(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;add head 2000&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
single_obj.traval()
single_obj.append(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

single_obj.traval()
single_obj.remove(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1236&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
single_obj.traval()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;&lt;strong&gt;双向链表&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　双向链表也叫&lt;a href=&quot;https://baike.baidu.com/item/%E5%8F%8C%E9%93%BE%E8%A1%A8/5827945&quot; target=&quot;_blank&quot; data-lemmaid=&quot;5827945&quot;&gt;双链表&lt;/a&gt;，是链表的一种，它的每个数据结点中都有两个&lt;a href=&quot;https://baike.baidu.com/item/%E6%8C%87%E9%92%88/2878304&quot; target=&quot;_blank&quot; data-lemmaid=&quot;2878304&quot;&gt;指针&lt;/a&gt;，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。一般我们都构造双向&lt;a href=&quot;https://baike.baidu.com/item/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/3228465&quot; target=&quot;_blank&quot; data-lemmaid=&quot;3228465&quot;&gt;循环链表&lt;/a&gt;&lt;/p&gt;






&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1582729/201903/1582729-20190316152515829-610867900.png&quot; alt=&quot;&quot; width=&quot;475&quot; height=&quot;415&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Node(object):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self,item):
        self.item &lt;/span&gt;=&lt;span&gt; item
        self.next &lt;/span&gt;=&lt;span&gt; None
        self.prev &lt;/span&gt;= None
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;双链表 判断是否为空，链表长度，遍历链表都跟单链表一致，直接继承就好了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; DoubleLinkList(SingleList):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;双链表&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; add(self,item):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;头部添加元素&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        node &lt;/span&gt;=&lt;span&gt; Node(item)
        node.next &lt;/span&gt;=&lt;span&gt; self._head
        self._head &lt;/span&gt;=&lt;span&gt; node
        node.next.prev &lt;/span&gt;=&lt;span&gt; node

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; append(self,item):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;链表尾部添加元素&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        node &lt;/span&gt;=&lt;span&gt; Node(item)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; self.is_empty():
            self._head &lt;/span&gt;=&lt;span&gt; node
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            cur &lt;/span&gt;=&lt;span&gt; self._head
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; cur.next !=&lt;span&gt; None:
                cur &lt;/span&gt;=&lt;span&gt; cur.next
            cur.next &lt;/span&gt;=&lt;span&gt; node
            node.prev &lt;/span&gt;=&lt;span&gt; cur

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; insert(self,pos,item):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;指定位置添加元素
        :param pos start is 0
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; pos &amp;lt;&lt;span&gt; 0:
            self.add(item)  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 头插法&lt;/span&gt;
        &lt;span&gt;elif&lt;/span&gt; pos &amp;gt; self.length()-1&lt;span&gt;:
            self.append(item)  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 尾插法&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            node &lt;/span&gt;=&lt;span&gt; Node(item)
            cur &lt;/span&gt;=&lt;span&gt; self._head
            count &lt;/span&gt;=&lt;span&gt; 0
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; count &amp;lt;&lt;span&gt; pos:
                count &lt;/span&gt;+= 1&lt;span&gt;
                cur &lt;/span&gt;=&lt;span&gt; cur.next
            node.next &lt;/span&gt;=&lt;span&gt; cur
            node.prev &lt;/span&gt;=&lt;span&gt; cur.prev
            cur.prev.next &lt;/span&gt;=&lt;span&gt; node
            cur.prev &lt;/span&gt;=&lt;span&gt; node

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; remove(self,item):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;删除节点&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        cur &lt;/span&gt;=&lt;span&gt; self._head
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; cur!=&lt;span&gt;None:
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; cur.item ==&lt;span&gt; item:
                &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 判断是不是在头节点删除&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; cur &lt;span&gt;is&lt;/span&gt; self._head:  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; pre is None or cur is self._head&lt;/span&gt;
                    self._head =&lt;span&gt; cur.next
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; cur.next:
                        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 判断链表是否就一个结点&lt;/span&gt;
                        cur.next.prev = None &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 结点 置空&lt;/span&gt;
                &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                    cur.next.prev &lt;/span&gt;=&lt;span&gt; cur.prev
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; cur.next:
                        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 判断是否为最后一个结点&lt;/span&gt;
                        cur.prev.next =&lt;span&gt; cur.next
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;
            cur &lt;/span&gt;=&lt;span&gt; cur.next

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; search(self,item):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;查找元素&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        cur &lt;/span&gt;=&lt;span&gt; self._head
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; cur!=&lt;span&gt;None:
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; cur.item ==&lt;span&gt; item:
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; True
            cur &lt;/span&gt;=&lt;span&gt; cur.next
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; False
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('196df874-9a0d-44ec-ba8f-2eaef1f3444c')&quot; readability=&quot;36&quot;&gt;&lt;img id=&quot;code_img_closed_196df874-9a0d-44ec-ba8f-2eaef1f3444c&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_196df874-9a0d-44ec-ba8f-2eaef1f3444c&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('196df874-9a0d-44ec-ba8f-2eaef1f3444c',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_196df874-9a0d-44ec-ba8f-2eaef1f3444c&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;encoding:utf-8&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; __author__ = 'donghao'&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; __time__ = 2019/3/16 13:23&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; 数据结构.链表.Single &lt;span&gt;import&lt;/span&gt;&lt;span&gt; SingleList

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Node(object):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self,item):
        self.item &lt;/span&gt;=&lt;span&gt; item
        self.next &lt;/span&gt;=&lt;span&gt; None
        self.prev &lt;/span&gt;=&lt;span&gt; None

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; DoubleLinkList(SingleList):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;双链表&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; add(self,item):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;头部添加元素&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        node &lt;/span&gt;=&lt;span&gt; Node(item)
        node.next &lt;/span&gt;=&lt;span&gt; self._head
        self._head &lt;/span&gt;=&lt;span&gt; node
        node.next.prev &lt;/span&gt;=&lt;span&gt; node

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; append(self,item):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;链表尾部添加元素&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        node &lt;/span&gt;=&lt;span&gt; Node(item)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; self.is_empty():
            self._head &lt;/span&gt;=&lt;span&gt; node
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            cur &lt;/span&gt;=&lt;span&gt; self._head
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; cur.next !=&lt;span&gt; None:
                cur &lt;/span&gt;=&lt;span&gt; cur.next
            cur.next &lt;/span&gt;=&lt;span&gt; node
            node.prev &lt;/span&gt;=&lt;span&gt; cur

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; insert(self,pos,item):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;指定位置添加元素
        :param pos start is 0
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; pos &amp;lt;&lt;span&gt; 0:
            self.add(item)  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 头插法&lt;/span&gt;
        &lt;span&gt;elif&lt;/span&gt; pos &amp;gt; self.length()-1&lt;span&gt;:
            self.append(item)  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 尾插法&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            node &lt;/span&gt;=&lt;span&gt; Node(item)
            cur &lt;/span&gt;=&lt;span&gt; self._head
            count &lt;/span&gt;=&lt;span&gt; 0
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; count &amp;lt;&lt;span&gt; pos:
                count &lt;/span&gt;+= 1&lt;span&gt;
                cur &lt;/span&gt;=&lt;span&gt; cur.next
            node.next &lt;/span&gt;=&lt;span&gt; cur
            node.prev &lt;/span&gt;=&lt;span&gt; cur.prev
            cur.prev.next &lt;/span&gt;=&lt;span&gt; node
            cur.prev &lt;/span&gt;=&lt;span&gt; node

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; remove(self,item):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;删除节点&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        cur &lt;/span&gt;=&lt;span&gt; self._head
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; cur!=&lt;span&gt;None:
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; cur.item ==&lt;span&gt; item:
                &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 判断是不是在头节点删除&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; cur &lt;span&gt;is&lt;/span&gt; self._head:  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; pre is None or cur is self._head&lt;/span&gt;
                    self._head =&lt;span&gt; cur.next
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; cur.next:
                        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 判断链表是否就一个结点&lt;/span&gt;
                        cur.next.prev = None &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 结点 置空&lt;/span&gt;
                &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                    cur.next.prev &lt;/span&gt;=&lt;span&gt; cur.prev
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; cur.next:
                        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 判断是否为最后一个结点&lt;/span&gt;
                        cur.prev.next =&lt;span&gt; cur.next
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;
            cur &lt;/span&gt;=&lt;span&gt; cur.next

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; search(self,item):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;查找元素&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        cur &lt;/span&gt;=&lt;span&gt; self._head
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; cur!=&lt;span&gt;None:
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; cur.item ==&lt;span&gt; item:
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; True
            cur &lt;/span&gt;=&lt;span&gt; cur.next
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; False
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;插入示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1582729/201903/1582729-20190316152815691-1792815373.png&quot; alt=&quot;&quot; width=&quot;491&quot; height=&quot;393&quot;/&gt;&lt;/p&gt;
&lt;p&gt;链表和顺序表区别：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1582729/201903/1582729-20190316152800213-827639018.png&quot; alt=&quot;&quot; width=&quot;699&quot; height=&quot;455&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 16 Mar 2019 07:29:00 +0000</pubDate>
<dc:creator>最美的烟火</dc:creator>
<og:description>链表 链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/donghaoblogs/p/10542491.html</dc:identifier>
</item>
<item>
<title>设计模式之装饰者模式 - blue星空</title>
<link>http://www.cnblogs.com/BlueStarWei/p/10515145.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/BlueStarWei/p/10515145.html</guid>
<description>&lt;p&gt;　　装饰者（Decorator）模式就是在&lt;span&gt;不修改任何底层代码&lt;/span&gt;的情况下，&lt;span&gt;给对象赋予新的职责&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　装饰者模式又称&lt;span&gt;包装&lt;/span&gt;模式，即：在真实对象的外层包装一层层新的职能。&lt;/p&gt;
&lt;p&gt;　　装饰者模式主要采用&lt;span&gt;组合&lt;/span&gt;的方式拓展对象的行为，是给爱用继承的人一个全新的设计眼界。（&lt;span&gt;继承是在编译时静态决定对象的行为，而组合是在运行时动态地扩展对象的行为&lt;/span&gt;。）&lt;/p&gt;
&lt;p&gt;　　需要格外注意的是：&lt;em&gt;&lt;span&gt;装饰者与被装饰者必须是同一个类型&lt;/span&gt;，即：具有相同的超类。&lt;/em&gt;【这里通过&lt;span&gt;继承&lt;/span&gt;实现类型匹配】&lt;/p&gt;
&lt;p&gt;　　装饰者模式包含四个角色：抽象目标组件，具体目标组件，抽象装饰者，具体装饰者。其中，目标组件就是需要被装饰的对象。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1137223/201903/1137223-20190312101042734-1477105705.png&quot; alt=&quot;&quot; width=&quot;530&quot; height=&quot;404&quot;/&gt;&lt;/p&gt;

&lt;p&gt;1.抽象目标组件（Component）&lt;/p&gt;
&lt;p&gt;　　目标组件的抽象类，是所有装饰者与具体组件的超类。&lt;span&gt;这是为了保持组件被装饰后，返回的对象类型保持不变&lt;/span&gt;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Beverage {

    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; String description = &quot;Unknown Beverage&quot;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getDescription() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; description;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt;&lt;span&gt; BigDecimal cost();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2.具体目标组件&lt;/p&gt;
&lt;p&gt;　　需要赋予新权限的组件。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DarkRoast &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Beverage{

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; DarkRoast() {
        description &lt;/span&gt;= &quot;Dark Roast&quot;&lt;span&gt;;
    }
    
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; BigDecimal cost() {&lt;br/&gt;&lt;span&gt;//定义深焙饮料的价格
        &lt;/span&gt;&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BigDecimal(0.25&lt;span&gt;);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;3.抽象装饰者&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;//需要在饮料中添加的调味品&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//具有两个抽象方法：getDescription()、cost()&lt;/span&gt;&lt;br/&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Condiment &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Beverage {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt;&lt;span&gt; String getDescription();

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;4.具体装饰者&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Mocha &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Condiment{

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Beverage beverage;
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Mocha(Beverage beverage) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.beverage =&lt;span&gt; beverage;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getDescription() {&lt;br/&gt;　　　　&lt;span&gt;　//在原有饮料的描述中增添添加剂的描述
        &lt;/span&gt;&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; beverage.getDescription() + &quot;, Mocha&quot;&lt;span&gt;;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; BigDecimal cost() {&lt;br/&gt;&lt;span&gt;//返回饮料加上添加剂的总价。0.6是摩卡添加剂的价格
        &lt;/span&gt;&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BigDecimal(0.6).add(beverage.cost()).setScale(2&lt;span&gt;, BigDecimal.ROUND_HALF_UP);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Whip &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Condiment{

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Beverage beverage;
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Whip(Beverage beverage) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.beverage =&lt;span&gt; beverage;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getDescription() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;  beverage.getDescription() + &quot;, Whip&quot;&lt;span&gt;;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; BigDecimal cost() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BigDecimal(0.5).add(beverage.cost()).setScale(2&lt;span&gt;, BigDecimal.ROUND_HALF_UP);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;5.Demo&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BeverageDemo {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        Beverage beverage &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DarkRoast();
        System.out.println(beverage.getDescription() &lt;/span&gt;+&quot; : &quot; +&lt;span&gt; beverage.cost());
        
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;use mocha &amp;amp; whip to decorate dark-roast.&lt;/span&gt;
        beverage = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Mocha(beverage);
        beverage &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Whip(beverage);
        System.out.println(beverage.getDescription() &lt;/span&gt;+&quot; : &quot; +&lt;span&gt; beverage.cost());
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;Log:
         * Dark Roast : 0.25
         * Dark Roast, Mocha, Whip : 1.35&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;6.备注&lt;/p&gt;
&lt;p&gt;　　装饰模式是&lt;span&gt;针对抽象组件（Component）类型编程&lt;/span&gt;。但是，如果你要针对具体组件编程时，就应该重新思考你的应用架构，以及装饰者是否合适。当然也可以改变Component接口，增加新的公开的行为，实现“半透明”的装饰者模式。在实际项目中要做出最佳选择。&lt;/p&gt;

&lt;p&gt;     &lt;span&gt;装饰模式会导致设计中出现许多小类&lt;/span&gt;，如果过度使用，会使程序变得很复杂。【可以通过工厂模式和生成器模式进行优化】&lt;/p&gt;

&lt;p&gt;7.拓展&lt;/p&gt;
&lt;div readability=&quot;16.5&quot;&gt;
&lt;p&gt;    7.1  如果只有一个Concrete Component类而没有抽象的Component接口时，可以让Decorator继承Concrete Component。&lt;/p&gt;
&lt;p&gt;    7.2  如果只有一个Concrete Decorator类时，可以将Decorator和Concrete Decorator合并。&lt;/p&gt;

&lt;p&gt;8.使用场景&lt;/p&gt;
&lt;div class=&quot;para&quot; readability=&quot;16&quot;&gt;
&lt;p&gt;    8.1 需要&lt;span&gt;扩展一个类的功能&lt;/span&gt;，或给一个类添加附加职责。&lt;/p&gt;
&lt;p&gt;    8.2 需要动态的&lt;span&gt;给一个对象添加功能&lt;/span&gt;，这些功能可以再动态的撤销。&lt;/p&gt;
&lt;p&gt;    8.3 需要&lt;span&gt;增加由一些基本功能的排列组合而产生的非常大量的功能&lt;/span&gt;，从而使继承关系变的不现实。&lt;/p&gt;
&lt;p&gt;    8.4 当不能采用生成子类的方法进行扩充时。一种情况是，可能&lt;span&gt;有大量独立的扩展&lt;/span&gt;，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是因为&lt;span&gt;类定义被隐藏，或类定义不能用于生成子类&lt;/span&gt;。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;9. 补充&lt;/p&gt;
&lt;p&gt;　　Java I/O是装饰者模式的典型例子。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1137223/201903/1137223-20190312103443609-730334002.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;10. 参考资料&lt;/p&gt;
&lt;p&gt;    10.1 O'Reilly：《Head First设计模式》&lt;/p&gt;
&lt;p&gt;    10.2 百度百科 ： 《装饰者模式》&lt;/p&gt;

</description>
<pubDate>Sat, 16 Mar 2019 06:55:00 +0000</pubDate>
<dc:creator>blue星空</dc:creator>
<og:description>装饰者模式</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/BlueStarWei/p/10515145.html</dc:identifier>
</item>
<item>
<title>Django学习笔记二 - 行者马</title>
<link>http://www.cnblogs.com/ChinacloudTech/p/10542254.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ChinacloudTech/p/10542254.html</guid>
<description>&lt;p&gt;&lt;span class=&quot;tag blue label&quot;&gt;模型类，字段，选项，查询，关联，聚合函数，管理器，&lt;/span&gt;&lt;/p&gt;

&lt;h2 class=&quot;xsj_heading_hash xsj_heading xsj_heading_h2&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;一 字段属性和选项&lt;/span&gt;&lt;/h2&gt;

&lt;h3 class=&quot;xsj_heading_hash xsj_heading xsj_heading_h3&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;1.1 模型类属性命名限制&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;1）不能是python的保留关键字。&lt;br/&gt;2）不允许使用连续的下划线，这是由django的查询方式决定的。&lt;br/&gt;3）定义属性时需要指定字段类型，通过字段类型的参数指定选项，语法如下：&lt;br/&gt;属性名=models.字段类型(选项)&lt;/p&gt;

&lt;h3 class=&quot;xsj_heading_hash xsj_heading xsj_heading_h3&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;1.2 字段的类型&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;使用时需要引入django.db.models包，字段类型如下：&lt;/p&gt;
&lt;table class=&quot;table table-striped table-celled&quot;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;16&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;AutoField&lt;/td&gt;
&lt;td&gt;自动增长的IntegerField，通常不用指定，不指定时Django会自动创建属性名为id的自动增长属性。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;BooleanField&lt;/td&gt;
&lt;td&gt;布尔字段，值为True或False。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;NullBooleanField&lt;/td&gt;
&lt;td&gt;支持Null、True、False三种值。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;CharField(max_length=最大长度)&lt;/td&gt;
&lt;td&gt;字符串。参数max_length表示最大字符个数。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;TextField&lt;/td&gt;
&lt;td&gt;大文本字段，一般超过4000个字符时使用。&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;IntegerField&lt;/td&gt;
&lt;td&gt;整数&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;DecimalField(max_digits=None, decimal_places=None)&lt;/td&gt;
&lt;td&gt;十进制浮点数。参数max_digits表示总位。参数decimal_places表示小数位数。&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;FloatField&lt;/td&gt;
&lt;td&gt;浮点数。参数同上&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8&quot;&gt;&lt;td&gt;DateField：([auto_now=False, auto_now_add=False])&lt;/td&gt;
&lt;td&gt;日期。1)参数auto_now表示每次保存对象时，自动设置该字段为当前时间，用于&quot;最后一次修改&quot;的时间戳，它总是使用当前日期，默认为false。2) 参数auto_now_add表示当对象第一次被创建时自动设置当前时间，用于创建的时间戳，它总是使用当前日期，默认为false。3)参数auto_now_add和auto_now是相互排斥的，组合将会发生错误。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;TimeField&lt;/td&gt;
&lt;td&gt;时间，参数同DateField。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;DateTimeField&lt;/td&gt;
&lt;td&gt;日期时间，参数同DateField。&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;FileField&lt;/td&gt;
&lt;td&gt;上传文件字段。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;ImageField&lt;/td&gt;
&lt;td&gt;继承于FileField，对上传的内容进行校验，确保是有效的图片&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;对比：null是数据库范畴的概念，blank是后台管理页面表单验证范畴的。&lt;br/&gt;经验:&lt;br/&gt;当修改模型类之后，如果添加的选项不影响表的结构，则不需要重新做迁移，商品的选项中default和blank不影响表结构。&lt;br/&gt;参考文档:&lt;br/&gt;&lt;a class=&quot;xsj_link xsj_auto_link&quot; href=&quot;http://python.usyiyi.cn/translate/django_182/index.html&quot; target=&quot;_blank&quot;&gt;http://python.usyiyi.cn/translate/django_182/index.html&lt;/a&gt;&lt;/p&gt;

&lt;h3 class=&quot;xsj_heading_hash xsj_heading xsj_heading_h3&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;1.3 选项&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;通过选项实现对字段的约束，选项如下：&lt;/p&gt;
&lt;table class=&quot;table table-striped table-celled&quot;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;选项名&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;8.5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;default&lt;/td&gt;
&lt;td&gt;默认值。设置默认值。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;primary_key&lt;/td&gt;
&lt;td&gt;若为True，则该字段会成为模型的主键字段，默认值是False，一般作为AutoField的选项使用。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;unique&lt;/td&gt;
&lt;td&gt;如果为True, 这个字段在表中必须有唯一值，默认值是False。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;db_index&lt;/td&gt;
&lt;td&gt;若值为True, 则在表中会为此字段创建索引，默认值是False。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;db_column&lt;/td&gt;
&lt;td&gt;字段的名称，如果未指定，则使用属性的名称。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;null&lt;/td&gt;
&lt;td&gt;如果为True，表示允许为空，默认值是False。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;blank&lt;/td&gt;
&lt;td&gt;如果为True，则该字段允许为空白，默认值是False。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;对比：null是数据库范畴的概念，blank是后台管理页面表单验证范畴的。&lt;br/&gt;经验:&lt;br/&gt;当修改模型类之后，如果添加的选项不影响表的结构，则不需要重新做迁移，商品的选项中default和blank不影响表结构。&lt;br/&gt;参考文档:&lt;br/&gt;&lt;a class=&quot;xsj_link xsj_auto_link&quot; href=&quot;http://python.usyiyi.cn/translate/django_182/index.html&quot; target=&quot;_blank&quot;&gt;http://python.usyiyi.cn/translate/django_182/index.html&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;18&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-django hljs&quot; data-info=&quot;django&quot;&gt;&lt;span class=&quot;xml&quot;&gt;class BookInfo(models.Model):
    '''图书模型类'''
    # 图书名称
    btitle = models.CharField(max_length=20, db_column='title')
    # 图书名字唯一
    # btitle = models.CharField(max_length=20, unique=True, db_index=True)
    # 价格,最大位数为10,小数为2
    # bprice = models.DecimalField(max_digits=10, decimal_places=2)
    # 出版日期
    bpub_date = models.DateField()
    # bpub_date = models.DateField(auto_now_add=True) # 创建时间
    # bpub_date = models.DateField(auto_now=True) # 更新时间
    # 阅读量
    bread = models.IntegerField(default=0)
    # 评论量
    bcomment = models.IntegerField(default=0)
    # 删除标记
    isDelete = models.BooleanField(default=False)

    # book = models.Manager() # 自定一个Manager类对象，管理器对象
    objects = BookInfoManager() # 自定义一个BookInfoManager类的对象

    # @classmethod
    # def create_book(cls, btitle, bpub_date):
    #     '''添加一本图书'''
    #     # 创建一个cls类的对象
    #     obj = cls()
    #     obj.btitle = btitle
    #     obj.bpub_date = bpub_date
    #     # 添加进数据库
    #     obj.save()
    #     # 返回obj
    #     return obj

    class Meta:
        db_table = 'bookinfo' # 指定模型类对应表名
&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 class=&quot;xsj_heading_hash xsj_heading xsj_heading_h2&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;二查询&lt;/span&gt;&lt;/h2&gt;

&lt;h3 class=&quot;xsj_heading_hash xsj_heading xsj_heading_h3&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;2.1 mysql的查询日志&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;mysql.log是mysql的日志文件，里面记录的对MySQL数据库的操作记录。默认情况下mysql的日志文件没有产生，需要修改mysql的配置文件，步骤如下：&lt;br/&gt;1)使用下面的命令打开mysql的配置文件，去除68,69行的注释，然后保存。&lt;br/&gt;sudo vi /etc/mysql/mysql.conf.d/mysqld.cnf&lt;br/&gt;2）重启mysql服务，就会产生mysql日志文件。&lt;br/&gt;sudo service mysql restart&lt;br/&gt;3）打开MySQL的日志文件。&lt;br/&gt;/var/log/mysql/mysql.log 是mysql日志文件所在的位置。&lt;br/&gt;使用下面的命令可以实时查看mysql的日志文件:&lt;br/&gt;sudo tail -f /var/log/mysql/mysql.log&lt;/p&gt;

&lt;h3 class=&quot;xsj_heading_hash xsj_heading xsj_heading_h3&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;2.2 查询函数&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;通过模型类.objects属性可以调用如下函数，实现对模型类对应的数据表的查询。&lt;/p&gt;
&lt;table class=&quot;table table-striped table-celled&quot;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数名&lt;/th&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;th&gt;返回值&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;12.5&quot;&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td&gt;get&lt;/td&gt;
&lt;td&gt;返回表中满足条件的一条且只能有一条数据。&lt;/td&gt;
&lt;td&gt;返回值是一个模型类对象。&lt;/td&gt;
&lt;td&gt;参数中写查询条件。1) 如果查到多条数据，则抛异常MultipleObjectsReturned 2)查询不到数据，则抛异常：DoesNotExist。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;all&lt;/td&gt;
&lt;td&gt;返回模型类对应表格中的所有数据&lt;/td&gt;
&lt;td&gt;返回值是QuerySet类型&lt;/td&gt;
&lt;td&gt;查询集&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;filter&lt;/td&gt;
&lt;td&gt;返回满足条件的数据&lt;/td&gt;
&lt;td&gt;返回值是QuerySet类型&lt;/td&gt;
&lt;td&gt;参数写查询条件。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;exclude&lt;/td&gt;
&lt;td&gt;返回不满足条件的数据&lt;/td&gt;
&lt;td&gt;返回值是QuerySet类型&lt;/td&gt;
&lt;td&gt;参数写查询条件&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;order_by&lt;/td&gt;
&lt;td&gt;对查询结果进行排序&lt;/td&gt;
&lt;td&gt;返回值是QuerySet类型&lt;/td&gt;
&lt;td&gt;参数中写根据哪些字段进行排序&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;get示例：&lt;br/&gt;例：查询图书id为3的图书信息。&lt;br/&gt;all方法示例：&lt;br/&gt;例：查询图书所有信息。&lt;br/&gt;filter方法示例：&lt;br/&gt;条件格式：&lt;br/&gt;模型类属性名__条件名=值&lt;br/&gt;查询图书评论量为34的图书的信息：&lt;br/&gt;a)判等 条件名:exact。&lt;br/&gt;例：查询编号为1的图书。&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-stylus hljs&quot; data-info=&quot;stylus&quot;&gt;BookInfo&lt;span class=&quot;hljs-selector-class&quot;&gt;.objects&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.get&lt;/span&gt;(id=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;b)模糊查询&lt;br/&gt;例：查询书名包含'传'的图书。contains&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-stylus hljs&quot; data-info=&quot;stylus&quot;&gt;BookInfo&lt;span class=&quot;hljs-selector-class&quot;&gt;.objects&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.filter&lt;/span&gt;(btitle__contains=&lt;span class=&quot;hljs-string&quot;&gt;'传'&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;例：查询书名以'部'结尾的图书 endswith 开头:startswith&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-stylus hljs&quot; data-info=&quot;stylus&quot;&gt;BookInfo&lt;span class=&quot;hljs-selector-class&quot;&gt;.objects&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.filter&lt;/span&gt;(btitle__endswith=&lt;span class=&quot;hljs-string&quot;&gt;'部'&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;c)空查询 isnull&lt;br/&gt;例：查询书名不为空的图书。isnull&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql hljs&quot; data-info=&quot;sql&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; booktest_bookinfo &lt;span class=&quot;hljs-keyword&quot;&gt;where&lt;/span&gt; btitle &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;;
BookInfo.objects.filter(btitle__isnull=False)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;d)范围查询 in&lt;br/&gt;例：查询id为1或3或5的图书。&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;11&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-lsl hljs&quot; data-info=&quot;lsl&quot;&gt;select * from booktest_bookinfo where id in (&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;);
BookInfo.objects.filter(id__in = [&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;])&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;e)比较查询 gt(greate than) lt(less than) gte(equal) 大于等于&lt;br/&gt;lte 小于等于&lt;br/&gt;例：查询id大于3的图书。&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql hljs&quot; data-info=&quot;sql&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;Select&lt;/span&gt; * &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; booktest_bookinfo &lt;span class=&quot;hljs-keyword&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;id&lt;/span&gt;&amp;gt;&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;;
BookInfo.objects.filter(id__gt=3)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;f)日期查询&lt;br/&gt;例：查询1980年发表的图书。&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-stylus hljs&quot; data-info=&quot;stylus&quot;&gt;BookInfo&lt;span class=&quot;hljs-selector-class&quot;&gt;.objects&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.filter&lt;/span&gt;(bpub_date__year=&lt;span class=&quot;hljs-number&quot;&gt;1980&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;例：查询1980年1月1日后发表的图书。&lt;br/&gt;from datetime import date&lt;br/&gt;BookInfo.objects.filter(bpub_date__gt=date(1980,1,1))&lt;br/&gt;exclude方法示例：&lt;br/&gt;例：查询id不为3的图书信息。&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-stylus hljs&quot; data-info=&quot;stylus&quot;&gt;BookInfo&lt;span class=&quot;hljs-selector-class&quot;&gt;.objects&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.exclude&lt;/span&gt;(id=&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;order_by方法示例：&lt;br/&gt;作用：进行查询结果进行排序。&lt;br/&gt;例：查询所有图书的信息，按照id从小到大进行排序。&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-stylus hljs&quot; data-info=&quot;stylus&quot;&gt;BookInfo&lt;span class=&quot;hljs-selector-class&quot;&gt;.objects&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.all&lt;/span&gt;().order_by(&lt;span class=&quot;hljs-string&quot;&gt;'id'&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;例：查询所有图书的信息，按照id从大到小进行排序。&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-stylus hljs&quot; data-info=&quot;stylus&quot;&gt;BookInfo&lt;span class=&quot;hljs-selector-class&quot;&gt;.objects&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.all&lt;/span&gt;().order_by(&lt;span class=&quot;hljs-string&quot;&gt;'-id'&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;例：把id大于3的图书信息按阅读量从大到小排序显示。&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-stylus hljs&quot; data-info=&quot;stylus&quot;&gt;BookInfo&lt;span class=&quot;hljs-selector-class&quot;&gt;.objects&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.filter&lt;/span&gt;(id__gt=&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;).order_by(&lt;span class=&quot;hljs-string&quot;&gt;'-bread'&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 class=&quot;xsj_heading_hash xsj_heading xsj_heading_h2&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;三 F和Q对象&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;F对象的作用：用于类属性之间的比较&lt;br/&gt;使用之前需要先导入：&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-stylus hljs&quot; data-info=&quot;stylus&quot;&gt;from django&lt;span class=&quot;hljs-selector-class&quot;&gt;.db&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.models&lt;/span&gt; import F&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;例：查询图书阅读量大于评论量图书信息。&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-stylus hljs&quot; data-info=&quot;stylus&quot;&gt;BookInfo&lt;span class=&quot;hljs-selector-class&quot;&gt;.objects&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.filter&lt;/span&gt;(bread__gt=F(&lt;span class=&quot;hljs-string&quot;&gt;'bcomment'&lt;/span&gt;))&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;例：查询图书阅读量大于2倍评论量图书信息。&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-stylus hljs&quot; data-info=&quot;stylus&quot;&gt;BookInfo&lt;span class=&quot;hljs-selector-class&quot;&gt;.objects&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.filter&lt;/span&gt;(bread__gt=F(&lt;span class=&quot;hljs-string&quot;&gt;'bcomment'&lt;/span&gt;)*&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;Q对象的作用：用于查询时条件之间的逻辑关系。not and or，可以对Q对象进行&amp;amp;|~操作。&lt;br/&gt;使用之前需要先导入：&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-stylus hljs&quot; data-info=&quot;stylus&quot;&gt;from django&lt;span class=&quot;hljs-selector-class&quot;&gt;.db&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.models&lt;/span&gt; import Q&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;例：查询id大于3且阅读量大于30的图书的信息。&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-stylus hljs&quot; data-info=&quot;stylus&quot;&gt;BookInfo&lt;span class=&quot;hljs-selector-class&quot;&gt;.objects&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.filter&lt;/span&gt;(id__gt=&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;, bread__gt=&lt;span class=&quot;hljs-number&quot;&gt;30&lt;/span&gt;)
BookInfo&lt;span class=&quot;hljs-selector-class&quot;&gt;.objects&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.filter&lt;/span&gt;(Q(id__gt=&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;)&amp;amp;Q(bread__gt=&lt;span class=&quot;hljs-number&quot;&gt;30&lt;/span&gt;))&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;例：查询id大于3或者阅读量大于30的图书的信息。&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-lsl hljs&quot; data-info=&quot;lsl&quot;&gt;BookInfo.objects.filter(Q(id__gt=&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;)|Q(bread__gt=&lt;span class=&quot;hljs-number&quot;&gt;30&lt;/span&gt;))&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;例：查询id不等于3图书的信息。&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-stylus hljs&quot; data-info=&quot;stylus&quot;&gt;BookInfo&lt;span class=&quot;hljs-selector-class&quot;&gt;.objects&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.filter&lt;/span&gt;(~Q(id=&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;))&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 class=&quot;xsj_heading_hash xsj_heading xsj_heading_h2&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;四 聚合函数&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;作用：对查询结果进行聚合操作。&lt;br/&gt;sum count avg max min&lt;br/&gt;aggregate：调用这个函数来使用聚合。 返回值是一个字典&lt;br/&gt;使用前需先导入聚合类：&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;11&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-irpf90 hljs&quot; data-info=&quot;irpf90&quot;&gt;from django.db.models &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;Sum&lt;/span&gt;,&lt;span class=&quot;hljs-built_in&quot;&gt;Count&lt;/span&gt;,&lt;span class=&quot;hljs-built_in&quot;&gt;Max&lt;/span&gt;,&lt;span class=&quot;hljs-built_in&quot;&gt;Min&lt;/span&gt;,Avg&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;例：查询所有图书的数目。&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-stylus hljs&quot; data-info=&quot;stylus&quot;&gt;BookInfo&lt;span class=&quot;hljs-selector-class&quot;&gt;.objects&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.all&lt;/span&gt;().aggregate(Count(&lt;span class=&quot;hljs-string&quot;&gt;'id'&lt;/span&gt;))&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;{'id__count': 5}&lt;br/&gt;例：查询所有图书阅读量的总和。&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-stylus hljs&quot; data-info=&quot;stylus&quot;&gt;BookInfo&lt;span class=&quot;hljs-selector-class&quot;&gt;.objects&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.aggregate&lt;/span&gt;(Sum(&lt;span class=&quot;hljs-string&quot;&gt;'bread'&lt;/span&gt;))&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;{'bread__sum': 126}&lt;br/&gt;count函数 返回值是一个数字&lt;br/&gt;作用：统计满足条件数据的数目。&lt;br/&gt;例：统计所有图书的数目。&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-stylus hljs&quot; data-info=&quot;stylus&quot;&gt;BookInfo&lt;span class=&quot;hljs-selector-class&quot;&gt;.objects&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.all&lt;/span&gt;().count()
BookInfo&lt;span class=&quot;hljs-selector-class&quot;&gt;.objects&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.count&lt;/span&gt;()&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;例：统计id大于3的所有图书的数目。&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-stylus hljs&quot; data-info=&quot;stylus&quot;&gt;BookInfo&lt;span class=&quot;hljs-selector-class&quot;&gt;.objects&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.filter&lt;/span&gt;(id__gt=&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;).count()&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;小结:&lt;br/&gt;&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img title=&quot;enter description here&quot; src=&quot;https://img2018.cnblogs.com/blog/1080659/201903/1080659-20190316143804849-1198764024.png&quot; alt=&quot;enter description here&quot; name=&quot;images/1552715336914.png&quot; data-src=&quot;./images/1552715336914.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;参考文档：&lt;br/&gt;&lt;a class=&quot;xsj_link xsj_auto_link&quot; href=&quot;http://python.usyiyi.cn/translate/django_182/ref/models/querysets.html&quot; target=&quot;_blank&quot;&gt;http://python.usyiyi.cn/translate/django_182/ref/models/querysets.html&lt;/a&gt;&lt;/p&gt;

&lt;h2 class=&quot;xsj_heading_hash xsj_heading xsj_heading_h2&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;五 查询集&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;all, filter, exclude, order_by调用这些函数会产生一个查询集，QuerySet类对象可以继续调用上面的所有函数。&lt;br/&gt;5.1 查询集特性&lt;br/&gt;1） 惰性查询：只有在实际使用查询集中的数据的时候才会发生对数据库的真正查询。&lt;br/&gt;2） 缓存：当使用的是同一个查询集时，第一次使用的时候会发生实际数据库的查询，然后把结果缓存起来，之后再使用这个查询集时，使用的是缓存中的结果。&lt;br/&gt;5.2 限制查询集&lt;br/&gt;可以对一个查询集进行取下标或者切片操作来限制查询集的结果。&lt;br/&gt;对一个查询集进行切片操作会产生一个新的查询集，下标不允许为负数。&lt;br/&gt;取出查询集第一条数据的两种方式:&lt;/p&gt;
&lt;table class=&quot;table table-striped table-celled&quot;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;方式&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;b[0]&lt;/td&gt;
&lt;td&gt;如果b[0]不存在，会抛出IndexError异常&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;b[0:1].get()&lt;/td&gt;
&lt;td&gt;如果b[0:1].get()不存在，会抛出DoesNotExist异常。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;exists:判断一个查询集中是否有数据。True False&lt;/p&gt;

&lt;h2 class=&quot;xsj_heading_hash xsj_heading xsj_heading_h2&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;六 模型类的关系&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;1） 一对多关系&lt;br/&gt;例：图书类-英雄类&lt;br/&gt;models.ForeignKey() 定义在多的类中。&lt;br/&gt;2） 多对多关系&lt;br/&gt;例：新闻类-新闻类型类 体育新闻 国际新闻&lt;br/&gt;models.ManyToManyField() 定义在哪个类中都可以。&lt;br/&gt;3） 一对一关系&lt;br/&gt;例：员工基本信息类-员工详细信息类. 员工工号&lt;br/&gt;models.OneToOneField定义在哪个类中都可以。&lt;br/&gt;'''&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python hljs&quot; data-info=&quot;python&quot;&gt;
&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;NewsType&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(models.Model)&lt;/span&gt;:&lt;/span&gt;
    
    type_name = models.CharField(max_length=&lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;)
    
    type_news = models.ManyToManyField(&lt;span class=&quot;hljs-string&quot;&gt;'NewsInfo'&lt;/span&gt;)


&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;NewsInfo&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(models.Model)&lt;/span&gt;:&lt;/span&gt;
    
    title = models.CharField(max_length=&lt;span class=&quot;hljs-number&quot;&gt;128&lt;/span&gt;)
    
    pub_date = models.DateTimeField(auto_now_add=&lt;span class=&quot;hljs-keyword&quot;&gt;True&lt;/span&gt;)
    
    content = models.TextField()
    
    &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 class=&quot;xsj_heading_hash xsj_heading xsj_heading_h2&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;七 关联查询（一对多）&lt;/span&gt;&lt;/h2&gt;

&lt;h3 class=&quot;xsj_heading_hash xsj_heading xsj_heading_h3&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;7.1 查询和对象关联的数据&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;在一对多关系中，一对应的类我们把它叫做一类，多对应的那个类我们把它叫做多类，我们把多类中定义的建立关联的类属性叫做关联属性。&lt;br/&gt;例：查询id为1的图书关联的英雄的信息。&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-stylus hljs&quot; data-info=&quot;stylus&quot;&gt;    b=BookInfo&lt;span class=&quot;hljs-selector-class&quot;&gt;.objects&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.get&lt;/span&gt;(id=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)
    &lt;span class=&quot;hljs-selector-tag&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.heroinfo_set&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.all&lt;/span&gt;()&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;通过模型类查询：&lt;br/&gt;HeroInfo.objects.filter(hbook__id=1)&lt;br/&gt;例：查询id为1的英雄关联的图书信息。&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-stylus hljs&quot; data-info=&quot;stylus&quot;&gt;    h = HeroInfo&lt;span class=&quot;hljs-selector-class&quot;&gt;.objects&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.get&lt;/span&gt;(id=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)
    h.hbook&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;通过模型类查询：&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-stylus hljs&quot; data-info=&quot;stylus&quot;&gt;    BookInfo&lt;span class=&quot;hljs-selector-class&quot;&gt;.objects&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.filter&lt;/span&gt;(heroinfo__id=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;格式：&lt;br/&gt;&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img title=&quot;enter description here&quot; src=&quot;https://img2018.cnblogs.com/blog/1080659/201903/1080659-20190316143806929-1291773622.png&quot; alt=&quot;enter description here&quot; name=&quot;images/1552715943362.png&quot; data-src=&quot;./images/1552715943362.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;由一类的对象查询多类的时候：&lt;br/&gt;&lt;span class=&quot;mark&quot;&gt;一类的对象.多类名小写_set.all() #查询所用数据&lt;/span&gt;&lt;br/&gt;由多类的对象查询一类的时候：&lt;br/&gt;&lt;span class=&quot;mark&quot;&gt;多类的对象.关联属性 #查询多类的对象对应的一类的对象&lt;/span&gt;&lt;br/&gt;由多类的对象查询一类对象的id时候：&lt;br/&gt;&lt;span class=&quot;mark&quot;&gt;多类的对象. 关联属性_id&lt;/span&gt;&lt;/p&gt;

&lt;h3 class=&quot;xsj_heading_hash xsj_heading xsj_heading_h3&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;7.2 通过模型类实现关联查询&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;story_image_container story_block_image&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img title=&quot;enter description here&quot; src=&quot;https://img2018.cnblogs.com/blog/1080659/201903/1080659-20190316143810029-823196637.png&quot; alt=&quot;enter description here&quot; name=&quot;images/1552717264599.png&quot; data-src=&quot;./images/1552717264599.png&quot;/&gt;&lt;p&gt;enter description here&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;例：查询图书信息，要求图书关联的英雄的描述包含'八'。&lt;br/&gt;&lt;span class=&quot;mark&quot;&gt;BookInfo.objects.filter(heroinfo__hcomment__contains='八')&lt;/span&gt;&lt;br/&gt;例：查询图书信息，要求图书中的英雄的id大于3.&lt;br/&gt;&lt;span class=&quot;mark&quot;&gt;BookInfo.objects.filter(heroinfo__id__gt=3)&lt;/span&gt;&lt;br/&gt;例：查询书名为“天龙八部”的所有英雄。&lt;br/&gt;&lt;span class=&quot;mark&quot;&gt;HeroInfo.objects.filter(hbook__btitle='天龙八部')&lt;/span&gt;&lt;br/&gt;通过多类的条件查询一类的数据：&lt;br/&gt;&lt;span class=&quot;mark&quot;&gt;一类名.objects.filter(多类名小写__多类属性名__条件名)&lt;/span&gt;&lt;br/&gt;通过一类的条件查询多类的数据：&lt;br/&gt;&lt;span class=&quot;mark&quot;&gt;多类名.objects.filter(关联属性__一类属性名__条件名)&lt;/span&gt;&lt;/p&gt;

&lt;h2 class=&quot;xsj_heading_hash xsj_heading xsj_heading_h2&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;八 删除，更新，插入，自关联&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;调用一个模型类对象的save方法的时候就可以实现对模型类对应数据表的插入和更新。&lt;br/&gt;调用一个模型类对象的delete方法的时候就可以实现对模型类对应数据表数据的删除。&lt;br/&gt;自关联：&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;story_image_container story_block_image&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img title=&quot;enter description here&quot; src=&quot;https://img2018.cnblogs.com/blog/1080659/201903/1080659-20190316143812450-746240318.png&quot; alt=&quot;enter description here&quot; name=&quot;images/1552717503823.png&quot; data-src=&quot;./images/1552717503823.png&quot;/&gt;&lt;p&gt;enter description here&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;br/&gt;自关联是一种特殊的一对多的关系。&lt;br/&gt;案例：显示广州市的上级地区和下级地区。&lt;br/&gt;地区表：id, atitle, aParent_id;&lt;br/&gt;mysql终端中批量执行sql语句：source areas.sql;

&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;13&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript hljs&quot; data-info=&quot;javascript&quot;&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;AreaInfo&lt;/span&gt;(&lt;span class=&quot;hljs-title&quot;&gt;models&lt;/span&gt;.&lt;span class=&quot;hljs-title&quot;&gt;Model&lt;/span&gt;):
    '''地址模型类'''
    # 地区名称
    &lt;span class=&quot;hljs-title&quot;&gt;atitle&lt;/span&gt; &lt;/span&gt;= models.CharField(verbose_name=&lt;span class=&quot;hljs-string&quot;&gt;'标题'&lt;/span&gt;, max_length=&lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;)
    # 自关联属性
    aParent = models.ForeignKey(&lt;span class=&quot;hljs-string&quot;&gt;'self'&lt;/span&gt;, &lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;=True, blank=True)

    def __str__(self):
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; self.atitle

    def title(self):
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; self.atitle
    title.admin_order_field = &lt;span class=&quot;hljs-string&quot;&gt;'atitle'&lt;/span&gt;
    title.short_description = &lt;span class=&quot;hljs-string&quot;&gt;'地区名称'&lt;/span&gt;

    def parent(self):
        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; self.aParent is None:
            &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;''&lt;/span&gt;
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; self.aParent.atitle
    parent.short_description = &lt;span class=&quot;hljs-string&quot;&gt;'父级地区名称'&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 class=&quot;xsj_heading_hash xsj_heading xsj_heading_h2&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;九 管理器&lt;/span&gt;&lt;/h2&gt;
&lt;ol readability=&quot;3&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_2&quot;&gt;BookInfo.objects.all()-&amp;gt;objects是一个什么东西呢？&lt;br/&gt;答：objects是Django帮我自动生成的管理器对象，通过这个管理器可以实现对数据的查询。&lt;br/&gt;objects是models.Manger类的一个对象。自定义管理器之后Django不再帮我们生成默认的objects管理器。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_2&quot;&gt;自定义模型管理器类&lt;br/&gt;1）自定义一个管理器类，这个类继承models.Manger类。&lt;br/&gt;2）再在具体的模型类里定义一个自定义管理器类的对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_2&quot;&gt;自定义管理器类的应用场景&lt;br/&gt;1） 改变查询的结果集。&lt;br/&gt;比如调用BookInfo.books.all()返回的是没有删除的图书的数据。&lt;br/&gt;2） 添加额外的方法。&lt;br/&gt;管理器类中定义一个方法帮我们操作模型类对应的数据表。&lt;br/&gt;使用self.model()就可以创建一个跟自定义管理器对应的模型类对象。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;12&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python hljs&quot; data-info=&quot;python&quot;&gt;
&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;BookInfoManager&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(models.Manager)&lt;/span&gt;:&lt;/span&gt;
    &lt;span class=&quot;hljs-string&quot;&gt;'''图书模型管理器类'''&lt;/span&gt;
    
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;all&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self)&lt;/span&gt;:&lt;/span&gt;
        
        books = super().all() 
        
        books = books.filter(isDelete=&lt;span class=&quot;hljs-keyword&quot;&gt;False&lt;/span&gt;)
        
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; books

    
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;create_book&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self, btitle, bpub_date)&lt;/span&gt;:&lt;/span&gt;
        &lt;span class=&quot;hljs-string&quot;&gt;'''添加一本图书'''&lt;/span&gt;
        
        
        model_class = self.model
        book = model_class()
        
        book.btitle = btitle
        book.bpub_date = bpub_date
        
        book.save()
        
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; book&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;小结:&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;story_image_container story_block_image&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img title=&quot;enter description here&quot; src=&quot;https://img2018.cnblogs.com/blog/1080659/201903/1080659-20190316143816023-691125004.png&quot; alt=&quot;enter description here&quot; name=&quot;images/1552718116621.png&quot; data-src=&quot;./images/1552718116621.png&quot;/&gt;&lt;p&gt;enter description here&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

</description>
<pubDate>Sat, 16 Mar 2019 06:42:00 +0000</pubDate>
<dc:creator>行者马</dc:creator>
<og:description>Django学习笔记二 模型类，字段，选项，查询，关联，聚合函数，管理器， 一 字段属性和选项 1.1 模型类属性命名限制 1）不能是python的保留关键字。 2）不允许使用连续的下划线，这是由dj</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ChinacloudTech/p/10542254.html</dc:identifier>
</item>
<item>
<title>mybatis查询语句的背后 - 不懂是非</title>
<link>http://www.cnblogs.com/qm-article/p/10542187.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qm-article/p/10542187.html</guid>
<description>&lt;p&gt; 转载请注明出处。。。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;在先了解mybatis查询之前，先大致了解下以下代码的为查询做了哪些铺垫，在这里我们要事先了解，myabtis会默认使用DefaultSqlSessionFactory作为sqlSessionFactory的实现类，而sqlSession的默认实现类为DefaultSqlSession&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; SqlSessionFactory getSessionFactory() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         Reader reader = Resources.getResourceAsReader(&quot;mybatis/mybatis-config.xml&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         SqlSessionFactoryBuilder builder = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SqlSessionFactoryBuilder();
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; builder.build(reader);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;获取mybatis的配置文件流，交给sqlSessionFactoryBuilder进行解析，在这里只会涉及到一部分，具体，请大家移步mybatis源码进行分析&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解析大致步骤(以下说的配置文件，是mybatis配置数据库连接信息的那个配置文件,不是mapper.xml文件)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解析配置文件的核心类在XMLConfigBuilder类中，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代码如下&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Configuration parse() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (parsed) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;       &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BuilderException(&quot;Each XMLConfigBuilder can only be used once.&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     parsed = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     parseConfiguration(parser.evalNode(&quot;/configuration&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; configuration;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;   &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; parseConfiguration(XNode root) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 解析properties节点信息&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;       propertiesElement(root.evalNode(&quot;properties&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 解析settings节点配置信息，其中二级缓存的总开关就是这里配置,当然mybatis默认是开启的，详细见Configuration类中的cacheEnabled属性&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;       Properties settings = settingsAsProperties(root.evalNode(&quot;settings&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;      loadCustomVfs(settings);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;      loadCustomLogImpl(settings);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 解析别名&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;       typeAliasesElement(root.evalNode(&quot;typeAliases&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 解析插件&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;       pluginElement(root.evalNode(&quot;plugins&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这个节点一般不进行配置，myabtis也提供了一个默认实现类DefaultObjectFactory，除非自定义对象工厂实现，才需配置&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;       objectFactoryElement(root.evalNode(&quot;objectFactory&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;       objectWrapperFactoryElement(root.evalNode(&quot;objectWrapperFactory&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;       reflectorFactoryElement(root.evalNode(&quot;reflectorFactory&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;      settingsElement(settings);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; read it after objectFactory and objectWrapperFactory issue #631&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;       environmentsElement(root.evalNode(&quot;environments&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;       databaseIdProviderElement(root.evalNode(&quot;databaseIdProvider&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 处理java类型和数据库类型的转换,mybatis提供了许多默认实现，详细见TypeHandlerRegistry类，如果需自定义，可在此节点中进行配置&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;       typeHandlerElement(root.evalNode(&quot;typeHandlers&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这也是一个核心的配置，mapperElement方法会对mapper.xml文件内容进行一个解析&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;       mapperElement(root.evalNode(&quot;mappers&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;     } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;       &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BuilderException(&quot;Error parsing SQL Mapper Configuration. Cause: &quot; +&lt;span&gt; e, e);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;   }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;解析mapper.xml文件 的类XMLMapperBuilder，&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; parse() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 也就是检测配置文件配置的mapper节点有没有加载到configuration类中，防止重复加载&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;configuration.isResourceLoaded(resource)) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;       configurationElement(parser.evalNode(&quot;/mapper&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;      configuration.addLoadedResource(resource);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这个是绑定,mapper接口的,当处理成功,在configuration类中的mapper注册器中，会添加一个mapper&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;      bindMapperForNamespace();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     parsePendingResultMaps();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 解析resultMap节点&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     parsePendingCacheRefs(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 解析缓存节点，如&amp;lt;cache-ref/&amp;gt;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     parsePendingStatements();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 解析select|update等节点,并封装成mappedStatement类&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;   }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 其中bindMapperForNamespace()方法的操作会导致以下结果&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在configuration类中的MapperRegistry属性中添加一个mapper，结果存储在MapperRegistry类的一个map中,key为mapper的class value为一个代理工厂，负责产生mapper接口代理类。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;当我们使用要使用mybatis进行查询操作，无非大致就是两种方式&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;     * 通过mapper接口形式查询数据
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    @Test
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testSelectByMapper() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         SqlSession sqlSession =&lt;span&gt; MybatisUtil.getSessionFactory().openSession();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         UserMapper mapper = sqlSession.getMapper(UserMapper.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         User user = mapper.selectByPrimaryKey(10&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        System.out.println(user);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        sqlSession.close();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;     * 通过mapper接口的全限定名来进行查询
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; IOException
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    @Test
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testSelectByString() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         SqlSessionFactory sessionFactory =&lt;span&gt; MybatisUtil.getSessionFactory();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         SqlSession sqlSession =&lt;span&gt; sessionFactory.openSession();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         User user = sqlSession.selectOne(&quot;com.mybatis.demo.mybatisdemo.mapper.UserMapper.selectByPrimaryKey&quot;,10&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        System.out.println(user);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        sqlSession.close();
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;先来看第一种的分析，当我们点击getMapper进去，它会去调用configuration类中getMapper方法，就如上面介绍的解析出mapper节点后，会存储在configuration类中的mapper注册器中，&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; defaultSqlSession类&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &amp;lt;T&amp;gt; T getMapper(Class&amp;lt;T&amp;gt;&lt;span&gt; type) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; configuration.&amp;lt;T&amp;gt;getMapper(type, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;configuration类&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &amp;lt;T&amp;gt; T getMapper(Class&amp;lt;T&amp;gt;&lt;span&gt; type, SqlSession sqlSession) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; mapperRegistry.getMapper(type, sqlSession);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 最终获取mapper对象的方法,其主要是创建一个mapper代理工厂，我们都知道mybatis的mapper接口是没有实现类的，
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 但是我们直接查询是能获取数据，这里起作用的就是代理(采用的是jdk动态代理)&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &amp;lt;T&amp;gt; T getMapper(Class&amp;lt;T&amp;gt;&lt;span&gt; type, SqlSession sqlSession) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;final&lt;/span&gt; MapperProxyFactory&amp;lt;T&amp;gt; mapperProxyFactory = (MapperProxyFactory&amp;lt;T&amp;gt;&lt;span&gt;) knownMappers.get(type);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (mapperProxyFactory == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;       &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BindingException(&quot;Type &quot; + type + &quot; is not known to the MapperRegistry.&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;       &lt;span&gt;return&lt;/span&gt;&lt;span&gt; mapperProxyFactory.newInstance(sqlSession);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;       &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BindingException(&quot;Error getting mapper instance. Cause: &quot; +&lt;span&gt; e, e);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;   }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;然后最终会经过代理类MapperProxy的invoke方法，进行返回结果。在这里为了更好的能理解这个类，举个例子，步骤如下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;先创建一个接口，再使用一个类去实现java的jdk代理的核心接口InvocationHandler，&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; TestMapper {


    User findByUserId(Integer id);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MapperProxyTest &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; InvocationHandler {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Class&amp;lt;?&amp;gt;&lt;span&gt; target;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; MapperProxyTest(Class&amp;lt;?&amp;gt;&lt;span&gt; target) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.target =&lt;span&gt; target;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object getProxyInstances(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(),&lt;span&gt;new&lt;/span&gt; Class[]{target},&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Object invoke(Object proxy, Method method, Object[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (Object.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.equals(method.getDeclaringClass())) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; method.invoke(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, args);
        }
        User user &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User();
        user.setPassword(&lt;/span&gt;&quot;123&quot;&lt;span&gt;);
        user.setUsername(&lt;/span&gt;&quot;李四&quot;&lt;span&gt;);
        user.setAddress(&lt;/span&gt;&quot;123&quot;&lt;span&gt;);
        user.setRegistertime(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date());
        user.setCellphone(&lt;/span&gt;&quot;1111111&quot;&lt;span&gt;);
        user.setAge(&lt;/span&gt;25&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; user;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;测试类&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MapperTest {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
        MapperProxyTest proxyTest &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; MapperProxyTest(TestMapper.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        TestMapper testMapper &lt;/span&gt;=&lt;span&gt; (TestMapper) proxyTest.getProxyInstances();
        System.out.println(testMapper.findByUserId(&lt;/span&gt;10&lt;span&gt;));
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;执行结果&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
User{id=&lt;span&gt;null&lt;/span&gt;, username='李四', password='123', age=25, address='123', cellphone='1111111', registertime=Sat Mar 09 15:02:16 CST 2019}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;由上面例子也可以看出最终结果是在invoke方法内，同理在mybatis中的MapperProxy的invoke方法也是负责返回最终结果的&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; Object invoke(Object proxy, Method method, Object[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;       &lt;span&gt;if&lt;/span&gt; (Object.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.equals(method.getDeclaringClass())) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; method.invoke(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, args);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;       } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isDefaultMethod(method)) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; invokeDefaultMethod(proxy, method, args);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable t) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;       &lt;span&gt;throw&lt;/span&gt;&lt;span&gt; ExceptionUtil.unwrapThrowable(t);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 交给了mpperMethod类去处理&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;final&lt;/span&gt; MapperMethod mapperMethod =&lt;span&gt; cachedMapperMethod(method);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; mapperMethod.execute(sqlSession, args);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;   }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span&gt;mapperMethod类中有两个重要属性，也就是它的内部类，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/900767/201903/900767-20190310122027821-786381889.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;也可以很清楚的了解到SqlCommand是用来存储当前执行方法的信息，如全限定名，还有该方法是属于select|update|delete|insert|flush的哪一种，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于methodSignature，则是纪录该方法的一些信息，如返回值类型，参数等信息，paramNameResolver处理mapper接口中的参数，下面代码中有一个大致的介绍，以后会做一个详细的介绍，这里只贴下代码，只针对select做介绍&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object execute(SqlSession sqlSession, Object[] args) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    Object result;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (command.getType()) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;       &lt;span&gt;case&lt;/span&gt;&lt;span&gt; INSERT: {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         Object param =&lt;span&gt; method.convertArgsToSqlCommandParam(args);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         result =&lt;span&gt; rowCountResult(sqlSession.insert(command.getName(), param));
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;       &lt;span&gt;case&lt;/span&gt;&lt;span&gt; UPDATE: {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         Object param =&lt;span&gt; method.convertArgsToSqlCommandParam(args);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         result =&lt;span&gt; rowCountResult(sqlSession.update(command.getName(), param));
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;       &lt;span&gt;case&lt;/span&gt;&lt;span&gt; DELETE: {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         Object param =&lt;span&gt; method.convertArgsToSqlCommandParam(args);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         result =&lt;span&gt; rowCountResult(sqlSession.delete(command.getName(), param));
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;       &lt;span&gt;case&lt;/span&gt;&lt;span&gt; SELECT:
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (method.returnsVoid() &amp;amp;&amp;amp;&lt;span&gt; method.hasResultHandler()) {// 返回值为void类型，但是有ResultHandler参数，并且只能有一个，不然会报错
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;          executeWithResultHandler(sqlSession, args);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;           result = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (method.returnsMany()) {// 处理返回值类型为集合类型或者数组类型
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;           result =&lt;span&gt; executeForMany(sqlSession, args);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (method.returnsMap()) {//处理返回值类型为Map类型
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;           result =&lt;span&gt; executeForMap(sqlSession, args);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (method.returnsCursor()) {//返回值是否为cursor类型
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;           result =&lt;span&gt; executeForCursor(sqlSession, args);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {//其他类型
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;           Object param =&lt;span&gt; method.convertArgsToSqlCommandParam(args);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;           result =&lt;span&gt; sqlSession.selectOne(command.getName(), param);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;           &lt;span&gt;if&lt;/span&gt; (method.returnsOptional() &amp;amp;&amp;amp;
&lt;span&gt;33&lt;/span&gt;               (result == &lt;span&gt;null&lt;/span&gt; || !&lt;span&gt;method.getReturnType().equals(result.getClass()))) {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             result =&lt;span&gt; Optional.ofNullable(result);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;          }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;       &lt;span&gt;case&lt;/span&gt;&lt;span&gt; FLUSH:
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         result =&lt;span&gt; sqlSession.flushStatements();
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;         &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;       &lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;         &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BindingException(&quot;Unknown execution method for: &quot; +&lt;span&gt; command.getName());
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (result == &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; method.getReturnType().isPrimitive() &amp;amp;&amp;amp; !&lt;span&gt;method.returnsVoid()) {
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;       &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BindingException(&quot;Mapper method '&quot; +&lt;span&gt; command.getName()
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;           + &quot; attempted to return null from a method with a primitive return type (&quot; + method.getReturnType() + &quot;).&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;   }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 这里只介绍select部分中常用返回多个实例对象的情况，也就是返回值为集合类型。&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &amp;lt;E&amp;gt;&lt;span&gt; Object executeForMany(SqlSession sqlSession, Object[] args) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     List&amp;lt;E&amp;gt;&lt;span&gt; result;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将mapper接口的参数名称和args整成一个map结构，最后在会将值赋给sql中对应的变量
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在3.5版本中，默认的mapper结构(假如没使用@param注解或者处于jdk1.8版本中在代码编译时加上 -parameters 参数)，结构为
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; param1 -&amp;gt; args[0]  param2 -&amp;gt; args[1]
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; arg0 -&amp;gt; args[0]    arg1 -&amp;gt; args[1]  mybatis之前有些版本不是arg0 而是0 1 。。数字代替。&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     Object param =&lt;span&gt; method.convertArgsToSqlCommandParam(args);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (method.hasRowBounds()) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 处理参数中带有rowBounds参数&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;       RowBounds rowBounds =&lt;span&gt; method.extractRowBounds(args);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;       result = sqlSession.&amp;lt;E&amp;gt;&lt;span&gt;selectList(command.getName(), param, rowBounds);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt; {&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 其它情况&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;       result = sqlSession.&amp;lt;E&amp;gt;&lt;span&gt;selectList(command.getName(), param);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; issue #510 Collections &amp;amp; arrays support
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 说明返回类型不是集合List类型，而是数组类型或其它集合类型。&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;method.getReturnType().isAssignableFrom(result.getClass())) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;       &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (method.getReturnType().isArray()) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; convertToArray(result);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;       } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; convertToDeclaredCollection(sqlSession.getConfiguration(), result);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;   }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 从上面知道，最终还是回到了sqlSession里面，&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Override
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt;&lt;span&gt; selectList(String statement, Object parameter, RowBounds rowBounds) {
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
      MappedStatement ms &lt;/span&gt;=&lt;span&gt; configuration.getMappedStatement(statement);
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);
    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
      &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; ExceptionFactory.wrapException(&quot;Error querying database.  Cause: &quot; +&lt;span&gt; e, e);
    } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
      ErrorContext.instance().reset();
    }
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; MappedStatement存储的其实就是对每一个select|update|delete|insert 标签的解析结果&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;关于MappedStatement是怎么解析得来的，又是怎么存储在Configuration中，可沿着以下路线进行查看&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;SqlSessionFactoryBuilder&lt;/span&gt;  ---&amp;gt; build方法 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;XMLConfigBuilder &lt;/span&gt; ----&amp;gt;  parse、parseConfiguration、mapperElement方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;XMLMapperBuilder   &lt;/span&gt;----&amp;gt; parse、parsePendingStatements、parseStatementNode&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;MapperBuilderAssistant   &lt;/span&gt; ----&amp;gt; addMappedStatement&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里不做过多介绍，详情见源码&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在selectList中executor的默认实现类是，SimpleExecutor，不过它还由Configuration类中的一个属性决定最后的类型，&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Executor newExecutor(Transaction transaction, ExecutorType executorType) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     executorType = executorType == &lt;span&gt;null&lt;/span&gt; ?&lt;span&gt; defaultExecutorType : executorType;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     executorType = executorType == &lt;span&gt;null&lt;/span&gt; ?&lt;span&gt; ExecutorType.SIMPLE : executorType;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    Executor executor;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (ExecutorType.BATCH ==&lt;span&gt; executorType) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;       executor = &lt;span&gt;new&lt;/span&gt; BatchExecutor(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, transaction);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (ExecutorType.REUSE ==&lt;span&gt; executorType) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;       executor = &lt;span&gt;new&lt;/span&gt; ReuseExecutor(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, transaction);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;       executor = &lt;span&gt;new&lt;/span&gt; SimpleExecutor(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, transaction);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果cacheEnabled为true,其实这个属性默认为true的，
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 则由CachingExecutor进行包装，也就是常说的装饰设计模式&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (cacheEnabled) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;       executor = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CachingExecutor(executor);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     executor =&lt;span&gt; (Executor) interceptorChain.pluginAll(executor);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; executor;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;   }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 最后回到selectList中来，由此可见，调用了CachingExecutor类中的query方法来执行。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;   &lt;span&gt;public&lt;/span&gt; &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt;&lt;span&gt; query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;       &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果不为空，则启用了二级缓存&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     Cache cache =&lt;span&gt; ms.getCache();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (cache != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;      flushCacheIfRequired(ms);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;       &lt;span&gt;if&lt;/span&gt; (ms.isUseCache() &amp;amp;&amp;amp; resultHandler == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        ensureNoOutParams(ms, boundSql);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         @SuppressWarnings(&quot;unchecked&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         List&amp;lt;E&amp;gt; list = (List&amp;lt;E&amp;gt;&lt;span&gt;) tcm.getObject(cache, key);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (list == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;           list =&lt;span&gt; delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;           tcm.putObject(cache, key, list); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; issue #578 and #116&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; list;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;   }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt; 关于二级缓存，相信熟悉的都清楚，要想使用它，需要动两个地方，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一个是mybatis的配置文件，将cacheEnabled设置为true，其实mybatis对这个属性的默认值就是true，所以二级缓存的总开关是打开的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第二个就是在mpper.xml文件中使用 &amp;lt;cache/&amp;gt;  或&amp;lt;cache-ref/&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里对缓存不做介绍。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后调用了BaseExecutor的query方法，这个类起的作用就是对一级缓存进行了操作，最终调用了SimpleExecutor的doQuery方法进行查询。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 16 Mar 2019 06:21:00 +0000</pubDate>
<dc:creator>不懂是非</dc:creator>
<og:description>转载请注明出处。。。 一、前言 在先了解mybatis查询之前，先大致了解下以下代码的为查询做了哪些铺垫，在这里我们要事先了解，myabtis会默认使用DefaultSqlSessionFactory</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qm-article/p/10542187.html</dc:identifier>
</item>
</channel>
</rss>