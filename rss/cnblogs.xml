<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>ubuntu 制作本地yum仓库 - 还债之路--小白的成长历程</title>
<link>http://www.cnblogs.com/shoufu/p/10344455.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shoufu/p/10344455.html</guid>
<description>&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;笔者: 张首富
W X: y18163201(请备注)
qq群:895291458
时间:2019-01-31晚&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;今天到某银行进行软件部署的时候,碰到所有电脑都不允许联网的要求,我们的服务器带过去还不能用我们自己的硬盘,必须使用它们银行内部提供的硬盘,这就意味着我需要重新安装服务器系统,需要重新部署我们的软件环境,这些都小意思(no problem),但是最大的问题是我不能联网,不能联网,不能联网.这就意味着我所有需要在线安装的软件都必须在本地完成.&lt;br/&gt;于似乎我有想到了centos利用光盘做yum仓库,想到了方法就开始实施&lt;/p&gt;
&lt;h2 id=&quot;ubuntu通过光盘安装软件&quot;&gt;ubuntu通过光盘安装软件&lt;/h2&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;&amp;gt; 首先我们需要准备一个ntfs格式或者其他ubuntu能识别的格式的u盘(你如果不知道请你mount -t tab补全一下查看一下)
&amp;gt; 然后把(**.iso)的文件拷贝到U盘里(我这里采用的是ntfs格式的u盘)

插上u盘到服务器上,切换到root身份下
fdisk -l 查看刚才的u盘是哪一个,一定要看到分区的名字,我这里是/dev/sdb1
mount -t ntfs /dev/sdb1 /mnt/
cp /mnt/*.iso /root
mkdir /medis/cdrom   (和我的目录保持一致,如果你不听话,那么一会你就知道问题所在)
mount -tiso9660 -o loop /roo/*.iso /media/cdrom
apt-cdrom -m -d /media/cdrom add
apt-get update&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到此为止你就可以安装最基本的ssh服务了,可以使用远程软件进行连接了,你终于可以远离这个机房了,后续的方法在写,如果有时间会写&lt;code&gt;ubuntu 服务器通过uefi安装系统无坑篇--目前网上还没有无坑篇&lt;/code&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 31 Jan 2019 15:18:00 +0000</pubDate>
<dc:creator>还债之路--小白的成长历程</dc:creator>
<og:description>ubuntu 制作本地yum仓库 今天到某银行进行软件部署的时候,碰到所有电脑都不允许联网的要求,我们的服务器带过去还不能用我们自己的硬盘,必须使用它们银行内部提供的硬盘,这就意味着我需要重新安装服务</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shoufu/p/10344455.html</dc:identifier>
</item>
<item>
<title>用Python实现数据结构之树 - sfencs</title>
<link>http://www.cnblogs.com/sfencs-hcy/p/10341449.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sfencs-hcy/p/10341449.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;树是由根结点和若干颗子树构成的。树是由一个集合以及在该集合上定义的一种关系构成的。集合中的元素称为树的结点，所定义的关系称为父子关系。父子关系在树的结点之间建立了一个层次结构。在这种层次结构中有一个结点具有特殊的地位，这个结点称为该树的根结点，或称为树根。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul readability=&quot;9.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;根节点：树中最顶部的元素&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;父节点：处了根节点都有父节点，每个节点最多只有一个父节点&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;孩子节点：一个父节点具有0个或多个孩子节点&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;兄弟节点：同一个父节点的孩子节点之间是兄弟关系&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;外部节点：一个没有孩子的节点称为外部节点，也叫叶子结点&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;内部节点：有一个或多个孩子节点的节点叫做内部节点&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;树的边：指一对节点(u,v)，其中u是v的父节点或者v是u的父节点&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;树的路径：一系列连续的边组成了一条路径&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;节点的深度：节点的深度就是该节点的祖先的个数，不包括该节点本身，如果根节点的层数为1，则深度即为该节点的层数-1&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;节点的高度：如果p是树中的叶子节点，那么它的高度为0.否则p的高度是它的孩子节点中的最大高度+1&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;有序树：每个孩子之间有一定的顺序，例如：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1469015/201901/1469015-20190131121045807-1953372153.png&quot; alt=&quot;&quot; width=&quot;465&quot; height=&quot;309&quot;/&gt;&lt;/p&gt;

&lt;pre&gt;
&lt;code class=&quot;hljs language-python&quot;&gt;
&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Tree&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;
    &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&quot;
    树的抽象基类
    &quot;&quot;&quot;&lt;/span&gt;

    
    &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Position&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;

        &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self)&lt;/span&gt;:&lt;/span&gt;
            &lt;span class=&quot;hljs-keyword&quot;&gt;raise&lt;/span&gt; NotImplementedError(&lt;span class=&quot;hljs-string&quot;&gt;'must be implemented by subclass'&lt;/span&gt;)

        &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;__eq__&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self, other)&lt;/span&gt;:&lt;/span&gt;
            &lt;span class=&quot;hljs-keyword&quot;&gt;raise&lt;/span&gt; NotImplementedError(&lt;span class=&quot;hljs-string&quot;&gt;'must be implemented by subclass'&lt;/span&gt;)

    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self)&lt;/span&gt;:&lt;/span&gt;
        &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&quot;
        return 根节点的position
        &quot;&quot;&quot;&lt;/span&gt;
        &lt;span class=&quot;hljs-keyword&quot;&gt;raise&lt;/span&gt; NotImplementedError(&lt;span class=&quot;hljs-string&quot;&gt;'must be implemented by subclass'&lt;/span&gt;)

    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self,p)&lt;/span&gt;:&lt;/span&gt;
        &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&quot;

        :param p:一个位置对象
        :return: 返回p的父节点的position对象，如果p是根节点则饭后空
        &quot;&quot;&quot;&lt;/span&gt;
        &lt;span class=&quot;hljs-keyword&quot;&gt;raise&lt;/span&gt; NotImplementedError(&lt;span class=&quot;hljs-string&quot;&gt;'must be implemented by subclass'&lt;/span&gt;)

    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;num_children&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self,p)&lt;/span&gt;:&lt;/span&gt;
        &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&quot;

        :param p:一个位置对象
        :return: 返回该位置的孩子节点的数量
        &quot;&quot;&quot;&lt;/span&gt;
        &lt;span class=&quot;hljs-keyword&quot;&gt;raise&lt;/span&gt; NotImplementedError(&lt;span class=&quot;hljs-string&quot;&gt;'must be implemented by subclass'&lt;/span&gt;)

    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;children&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self,p)&lt;/span&gt;:&lt;/span&gt;
        &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&quot;

        :param p: 一个位置对象
        :return: 返回位置p的孩子的迭代
        &quot;&quot;&quot;&lt;/span&gt;
        &lt;span class=&quot;hljs-keyword&quot;&gt;raise&lt;/span&gt; NotImplementedError(&lt;span class=&quot;hljs-string&quot;&gt;'must be implemented by subclass'&lt;/span&gt;)

    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;__len__&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self)&lt;/span&gt;:&lt;/span&gt;
        &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&quot;

        :return: 返回整个树的节点个数
        &quot;&quot;&quot;&lt;/span&gt;

　　　　　&lt;span class=&quot;hljs-keyword&quot;&gt;raise&lt;/span&gt; NotImplementedError(&lt;span class=&quot;hljs-string&quot;&gt;'must be implemented by subclass'&lt;/span&gt;)

    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;is_root&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self,p)&lt;/span&gt;:&lt;/span&gt;
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; self.root() == p

    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;is_leaf&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self,p)&lt;/span&gt;:&lt;/span&gt;
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; self.num_children(p) == &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;

    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;is_empty&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self)&lt;/span&gt;:&lt;/span&gt;
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; len(self) == &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个抽象类中的方法必须在子类中实现才能调用，不然会产生NotImplementedError(‘must be implemented by subclass’)的异常&lt;/p&gt;
&lt;p&gt;除此之外，对于Position()这个内嵌类可能较难理解，为什么要有这么一个内嵌类&lt;/p&gt;
&lt;p&gt;这个内嵌类目前也是抽象类，具体方法都没有实现，但使用它的目的已经有了，就是将树中的节点进行封装，那为什么要封装节点呢？当调用树的相关方法时，节点可能为一个必要的参数，但我们手动传入时，实际上可以是任意的对象，这就会导致错误发生，所以我们必须保证传入的节点是节点的对象，同时也是本树对象的节点，不然就会弄混树与树的节点。同时将节点进行封装，可以避免使用者直接使用节点对象本身，相关节点的方法可以在封装成的Position对象调用。目前只是抽象类的定义，节点类等其他方法还未定义，后面还会看到具体的position对象的使用。&lt;/p&gt;
&lt;p&gt;目前有了Tree这个抽象类，虽然其中的大多数方法还是抽象方法，但使用这些方法已经可以构成一些其他的功能了，所以就有了is_root，is_leaf，is_empty方法的定义。同时还可以定义计算节点的深度与高度的方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs language-python&quot;&gt;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;depth&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self,p)&lt;/span&gt;:&lt;/span&gt;
    &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&quot;
    计算节点在树中的深度
    &quot;&quot;&quot;&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; self.is_root(p):
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;:
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; + self.depth(self.parent(p))

&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self,p)&lt;/span&gt;:&lt;/span&gt;
    &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&quot;
    计算节点在树中的深度 
    &quot;&quot;&quot;&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; self.is_leaf(p):
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;:
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; + max(self.height(c) &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; c &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; self.children(p))
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;我们现在介绍一种树的特殊化形式二叉树&lt;/p&gt;
&lt;p&gt;二叉树的特点：&lt;/p&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;每个父节点最多只有两个孩子节点&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;两个孩子节点又叫做左孩子和右孩子&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;以左孩子为根节点形成的树叫做左子树，以右孩子为根节点形成的树叫做右子树&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如果每个非叶子节点都有两个孩子，那么这个树就叫做完全二叉树&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;非空完全二叉树中，外部节点数=内部节点数+1&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;二叉树的实现可以以继承树的抽象类的方式实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs language-python&quot;&gt;
&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;BinaryTree&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Tree)&lt;/span&gt;:&lt;/span&gt;

    &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;

        &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self, element, parent=None, left=None, right=None)&lt;/span&gt;:&lt;/span&gt;
            self.element = element
            self.parent = parent
            self.left = left
            self.right = right

    &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Position&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Tree.Position)&lt;/span&gt;:&lt;/span&gt;

        &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self, container, node)&lt;/span&gt;:&lt;/span&gt;
            self.container = container
            self.node = node

        &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self)&lt;/span&gt;:&lt;/span&gt;
            &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; self.node.element

        &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;__eq__&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self, other)&lt;/span&gt;:&lt;/span&gt;
            &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; isinstance(other, type(self)) &lt;span class=&quot;hljs-keyword&quot;&gt;and&lt;/span&gt; other.node &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; self.node

    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;validate&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self, p)&lt;/span&gt;:&lt;/span&gt;
        &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&quot;
        进行位置验证
        &quot;&quot;&quot;&lt;/span&gt;
        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;not&lt;/span&gt; isinstance(p, self.Position):
            &lt;span class=&quot;hljs-keyword&quot;&gt;raise&lt;/span&gt; TypeError(&lt;span class=&quot;hljs-string&quot;&gt;'p must be proper Position type'&lt;/span&gt;)
        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; p.container &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;not&lt;/span&gt; self:
            &lt;span class=&quot;hljs-keyword&quot;&gt;raise&lt;/span&gt; ValueError(&lt;span class=&quot;hljs-string&quot;&gt;'p does not belong to this container'&lt;/span&gt;)
        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; p.node.parent &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; p.node:
            &lt;span class=&quot;hljs-keyword&quot;&gt;raise&lt;/span&gt; ValueError(&lt;span class=&quot;hljs-string&quot;&gt;'p is no longer valid'&lt;/span&gt;)
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; p.node

    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;make_position&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self, node)&lt;/span&gt;:&lt;/span&gt;
        &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&quot;
        封装节点
        &quot;&quot;&quot;&lt;/span&gt;
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; self.Position(self, node) &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; node &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;None&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;None&lt;/span&gt;

    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self)&lt;/span&gt;:&lt;/span&gt;
        self.root = &lt;span class=&quot;hljs-keyword&quot;&gt;None&lt;/span&gt;
        self.size = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;

    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;__len__&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self)&lt;/span&gt;:&lt;/span&gt;
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; self.size

    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self)&lt;/span&gt;:&lt;/span&gt;
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; self.make_position(self.root)

    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self, p)&lt;/span&gt;:&lt;/span&gt;
        node = self.validate(p)
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; self.make_position(node.parent)

    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self, p)&lt;/span&gt;:&lt;/span&gt;
        node = self.validate(p)
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; self.make_position(node.left)

    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self, p)&lt;/span&gt;:&lt;/span&gt;
        node = self.validate(p)
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; self.make_position(node.right)

    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;sibling&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self, p)&lt;/span&gt;:&lt;/span&gt;
        parent = self.parent(p)
        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; parent &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;None&lt;/span&gt;:
            &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;None&lt;/span&gt;
        &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;:
            &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; p == self.left(parent):
                &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; self.right(parent)
            &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;:
                &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; self.left(parent)

    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;num_children&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self, p)&lt;/span&gt;:&lt;/span&gt;
        node = self.validate(p)
        count = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;
        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; node.left &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;None&lt;/span&gt;:
            count += &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;
        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; node.right &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;None&lt;/span&gt;:
            count += &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; count
　　

    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;children&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self,p)&lt;/span&gt;:&lt;/span&gt;
        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; self.left(p) &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;None&lt;/span&gt;:
            &lt;span class=&quot;hljs-keyword&quot;&gt;yield&lt;/span&gt; self.left(p)
        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; self.right(p) &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;None&lt;/span&gt;:
            &lt;span class=&quot;hljs-keyword&quot;&gt;yield&lt;/span&gt; self.right(p)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码中将之前的抽象方法进行了完整的定义，同时添加了validate与make_position方法。validate方法用于对传入的position参数进行验证，make_position方法用于将节点进行封装。除此之外还添加了二叉树特有的方法right，left和sibling，left与right分别返回节点的左孩子节点与右孩子节点，sibling返回的是节点的兄弟节点。&lt;/p&gt;
&lt;p&gt;目前的二叉树的数据结构只是创建了一颗空树，我们接下来要加入的是对二叉树进行更新操作的方法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs language-python&quot;&gt;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;add_root&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self, e)&lt;/span&gt;:&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; self.root &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;None&lt;/span&gt;:
        &lt;span class=&quot;hljs-keyword&quot;&gt;raise&lt;/span&gt; ValueError(&lt;span class=&quot;hljs-string&quot;&gt;'Root exists'&lt;/span&gt;)
    self.size += &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;
    self.root = self.Node(e)
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; self.make_position(self.root)

&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;add_left&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self, e, p)&lt;/span&gt;:&lt;/span&gt;
    node = self.validate(p)
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; node.left &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;None&lt;/span&gt;:
        &lt;span class=&quot;hljs-keyword&quot;&gt;raise&lt;/span&gt; ValueError(&lt;span class=&quot;hljs-string&quot;&gt;'Left child exists'&lt;/span&gt;)
    self.size += &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;
    node.left = self.Node(e, node)
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; self.make_position(node.left)

&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;add_right&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self, e, p)&lt;/span&gt;:&lt;/span&gt;
    node = self.validate(p)
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; node.right &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;None&lt;/span&gt;:
        &lt;span class=&quot;hljs-keyword&quot;&gt;raise&lt;/span&gt; ValueError(&lt;span class=&quot;hljs-string&quot;&gt;'Left child exists'&lt;/span&gt;)
    self.size += &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;
    node.right = self.Node(e, node)
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; self.make_position(node.right)

&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;replace&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self, p, e)&lt;/span&gt;:&lt;/span&gt;
    node = self.validate(p)
    old = node.element
    node.element = e
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; old

&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;delete&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self, p)&lt;/span&gt;:&lt;/span&gt;
    &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&quot;
    删除该位置的节点，如果该节点有两个孩子，则会产生异常，如果只有一个孩子，
    则使其孩子代替该节点与其双亲节点连接
    &quot;&quot;&quot;&lt;/span&gt;
    node = self.validate(p)
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; self.num_children(p) == &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;:
        &lt;span class=&quot;hljs-keyword&quot;&gt;raise&lt;/span&gt; ValueError(&lt;span class=&quot;hljs-string&quot;&gt;'p has two children'&lt;/span&gt;)
    child = node.left &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; node.left &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; node.right
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; child &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;None&lt;/span&gt;:
        child.parent = node.parent
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; node &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; self.root:
        self.root = child
    &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;:
        parent = node.parent
        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; node &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; parent.left:
            parent.left = child
        &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;:
            parent.right = child
    self.size -= &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;
    node.parent = node
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; node.element
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;总共加入了添加根节点，添加左孩子，添加右孩子，代替元素和删除节点5个方法，其中删除几点稍微有一些复杂，因为涉及到许多情况的判断。&lt;/p&gt;
&lt;p&gt;到现在，一个完整的二叉树数据结构基本完成了。&lt;/p&gt;
&lt;p&gt;但是我们还需要掌握一个算法，就是树的遍历算法&lt;/p&gt;

&lt;p&gt;树的遍历一般有先序遍历，后序遍历，广度优先遍历（层序遍历），对于二叉树还有中序遍历&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;先序遍历&lt;/h3&gt;
&lt;p&gt;先序遍历是按照根节点-&amp;gt;从左到右的孩子节点的顺序遍历，而且把每个孩子节点看作是子树的根节点同样如此，例如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1469015/201901/1469015-20190131221658089-699515787.png&quot; alt=&quot;&quot; width=&quot;414&quot; height=&quot;323&quot;/&gt;&lt;/p&gt;
&lt;p&gt;用python实现先序遍历为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs language-python&quot;&gt;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;preorder&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self,p)&lt;/span&gt;:&lt;/span&gt;
    &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&quot;
    先序遍历节点p为根节点的树
    &quot;&quot;&quot;&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;yield&lt;/span&gt; p
    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; c &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; self.children(p):
        &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; other &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; self.preorder(c):
            &lt;span class=&quot;hljs-keyword&quot;&gt;yield&lt;/span&gt; other
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;虽然代码只有4行，但理解起来却不是很容易的，首先该方法是一个生成器，所以通过yield返回一个可迭代对象，也就是可以for循环该方法，由于是先序遍历，所以要先yield p，之后便要返回孩子节点，由于孩子节点可能还具有孩子，所以并不能只返回孩子节点，应该返回以孩子节点为根节点的树的所有节点，而要想for循环得到左右的孩子节点为根节点的所有节点，还需要调用孩子节点的先序遍历方法才能得到。总而言之，代码理解的难度还是由于递归算法造成的，一个复杂的递归终归还是不是那么容易就能看出来的。&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;后序遍历&lt;/h3&gt;
&lt;p&gt;后序遍历是按照先从左到右孩子节点-&amp;gt;根节点，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1469015/201901/1469015-20190131224502360-2057776378.png&quot; alt=&quot;&quot; width=&quot;420&quot; height=&quot;329&quot;/&gt;&lt;/p&gt;
&lt;p&gt;用python实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs language-python&quot;&gt;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;postorder&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self,p)&lt;/span&gt;:&lt;/span&gt;
    &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&quot;
    后序遍历节点p为根的树 
    &quot;&quot;&quot;&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; c &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; self.children(p):
        &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; other &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; self.postorder(c):
            &lt;span class=&quot;hljs-keyword&quot;&gt;yield&lt;/span&gt; other
    &lt;span class=&quot;hljs-keyword&quot;&gt;yield&lt;/span&gt; p
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;理解与先序遍历相同&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;广度优先遍历&lt;/h3&gt;
&lt;p&gt;广度优先遍历也叫层序遍历，一层一层的遍历，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1469015/201901/1469015-20190131225231376-1336894463.png&quot; alt=&quot;&quot; width=&quot;410&quot; height=&quot;288&quot;/&gt;&lt;/p&gt;
&lt;p&gt;用python实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs language-python&quot;&gt;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;breadthfirst&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self)&lt;/span&gt;:&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;not&lt;/span&gt; self.is_empty():
        queue = Queue()
        queue.enqueue(self.root())
        &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;not&lt;/span&gt; queue.is_empty():
            p = queue.dequeue()
            &lt;span class=&quot;hljs-keyword&quot;&gt;yield&lt;/span&gt; p
            &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; self.children(p):
                queue.enqueue(i)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;-&quot;&gt;中序遍历二叉树&lt;/h3&gt;
&lt;p&gt;对于二叉树，遍历顺序为左孩子-&amp;gt;父节点-&amp;gt;右孩子&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1469015/201901/1469015-20190131230734548-1385602217.png&quot; alt=&quot;&quot; width=&quot;413&quot; height=&quot;326&quot;/&gt;&lt;/p&gt;
&lt;p&gt;python实现为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs language-python&quot;&gt;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;inorder&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self,p)&lt;/span&gt;:&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; self.left(p) &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;None&lt;/span&gt;:
        &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; other &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; self.inorder(self.left(p)):
            &lt;span class=&quot;hljs-keyword&quot;&gt;yield&lt;/span&gt; other
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; self.right(p) &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;None&lt;/span&gt;:
        &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; other &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; self.inorder(self.right(p)):
            &lt;span class=&quot;hljs-keyword&quot;&gt;yield&lt;/span&gt; other
&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;参考《数据结构与算法Python语言实现》&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
</description>
<pubDate>Thu, 31 Jan 2019 15:16:00 +0000</pubDate>
<dc:creator>sfencs</dc:creator>
<og:description>树 树是由根结点和若干颗子树构成的。树是由一个集合以及在该集合上定义的一种关系构成的。集合中的元素称为树的结点，所定义的关系称为父子关系。父子关系在树的结点之间建立了一个层次结构。在这种层次结构中有一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sfencs-hcy/p/10341449.html</dc:identifier>
</item>
<item>
<title>socket-demo的实现 - David丁</title>
<link>http://www.cnblogs.com/ading-blog/p/10344447.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ading-blog/p/10344447.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;

&lt;p&gt;最近公司在预研设备app端与服务端的交互方案，主要方案有&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;服务端和app端通过阿里iot套件实现消息的收发；&lt;/li&gt;
&lt;li&gt;服务端通过极光推送主动给app端推消息，app通过rest接口与服务端进行交互；&lt;/li&gt;
&lt;li&gt;服务端与app通过mqtt消息队列来实现彼此的消息交互；&lt;/li&gt;
&lt;li&gt;服务端与app通过原生socket长连接交互。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;虽然上面的一些成熟方案肯定更利于上生产环境，但它们通讯基础也都是socket长连接，所以本人主要是预研了一下socket长连接的交互，写了个简单demo，采用了BIO的多线程方案，实现了自定义简单协议，心跳机制，socket客户端身份强制验证，socket客户端断线获知等功能，并暴露了一些接口，可通过接口简单实现客户端与服务端的socket交互。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/DavidDingXu/springboot-socket-demo&quot;&gt;Github 地址点此&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;io通讯模型简介&quot;&gt;IO通讯模型简介&lt;/h2&gt;
&lt;p&gt;IO通讯模型主要包括阻塞式同步IO(BIO)，非阻塞式同步IO，多路复用IO以及异步IO。&lt;a href=&quot;https://blog.csdn.net/yinwenjie/column/info/sys-communication/3&quot;&gt;大神博客请点此&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;阻塞式同步io&quot;&gt;1. 阻塞式同步IO&lt;/h3&gt;
&lt;p&gt;BIO就是：blocking IO。最容易理解、最容易实现的IO工作方式，应用程序向操作系统请求网络IO操作，这时应用程序会一直等待；另一方面，操作系统收到请求后，也会等待，直到网络上有数据传到监听端口；操作系统在收集数据后，会把数据发送给应用程序；最后应用程序受到数据，并解除等待状态。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1008446/201901/1008446-20190131230726463-401001923.png&quot; alt=&quot;BIO示意图&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;非阻塞式同步io&quot;&gt;2. 非阻塞式同步IO&lt;/h3&gt;
&lt;p&gt;这种模式下，应用程序的线程不再一直等待操作系统的IO状态，而是在等待一段时间后，就解除阻塞。如果没有得到想要的结果，则再次进行相同的操作。这样的工作方式，暴增了应用程序的线程可以不会一直阻塞，而是可以进行一些其他工作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1008446/201901/1008446-20190131230743983-62089405.png&quot; alt=&quot;非阻塞式同步IO示意图&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;多路复用io阻塞非阻塞&quot;&gt;3. 多路复用IO（阻塞+非阻塞）&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1008446/201901/1008446-20190131230804688-1635822572.png&quot; alt=&quot;多路复用io示意图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;目前流程的多路复用IO实现主要包括四种：select、poll、epoll、kqueue。下表是他们的一些重要特性的比较：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1008446/201901/1008446-20190131230903751-1911151870.png&quot; alt=&quot;多路复用io模式比较&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;异步io&quot;&gt;4. 异步IO&lt;/h3&gt;
&lt;p&gt;异步IO则是采用“订阅-通知”模式：即应用程序向操作系统注册IO监听，然后继续做自己的事情。当操作系统发生IO事件，并且准备好数据后，在主动通知应用程序，触发相应的函数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1008446/201901/1008446-20190131230923432-192949040.png&quot; alt=&quot;异步IO示意图&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;和同步IO一样，异步IO也是由操作系统进行支持的。微软的windows系统提供了一种异步IO技术：IOCP（I/O Completion Port，I/O完成端口）；&lt;/li&gt;
&lt;li&gt;Linux下由于没有这种异步IO技术，所以使用的是epoll（上文介绍过的一种多路复用IO技术的实现）对异步IO进行模拟。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;java对io模型的支持&quot;&gt;Java对IO模型的支持&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Java&lt;/code&gt;对阻塞式同步IO的支持主要是&lt;code&gt;java.net&lt;/code&gt;包中的&lt;code&gt;Socket&lt;/code&gt;套接字实现；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Java&lt;/code&gt;中非阻塞同步IO模式通过设置&lt;code&gt;serverSocket.setSoTimeout(100);&lt;/code&gt;即可实现；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Java 1.4&lt;/code&gt;中引入了&lt;code&gt;NIO&lt;/code&gt;框架(&lt;code&gt;java.nio&lt;/code&gt;包)可以构建多路复用、同步非阻塞&lt;code&gt;IO&lt;/code&gt;程序；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Java 7&lt;/code&gt;中对&lt;code&gt;NIO&lt;/code&gt;进行了进一步改进，即&lt;code&gt;NIO2&lt;/code&gt;,引入了异步非阻塞IO方式。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;由于是要实现socket长连接的demo，主要关注其一些实现注意点及方案，所以本demo采用了&lt;code&gt;BIO&lt;/code&gt;的多线程方案，该方案代码比较简单、直观，引入了多线程技术后，IO的处理吞吐量也大大提高了。下面是&lt;code&gt;BIO&lt;/code&gt;多线程方案&lt;code&gt;server&lt;/code&gt;端的简单实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; public static void main(String[] args) throws Exception{
        ServerSocket serverSocket = new ServerSocket(83);
        try {
            while(true) {
                Socket socket = null;
                socket = serverSocket.accept();
                //这边获得socket连接后开启一个线程监听处理数据
                SocketServerThread socketServerThread = new SocketServerThread(socket);
                new Thread(socketServerThread).start();
            }
        } catch(Exception e) {
            log.error(&quot;Socket accept failed. Exception:{}&quot;, e.getMessage());
        } finally {
            if(serverSocket != null) {
                serverSocket.close();
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;@slf4j
class SocketServerThread implements Runnable {

    private Socket socket;

    public SocketServerThread (Socket socket) {
        this.socket = socket;
    }

    @Override
    public void run() {
        InputStream in = null;
        OutputStream out = null;
        try {
            in = socket.getInputStream();
            out = socket.getOutputStream();
            Integer sourcePort = socket.getPort();
            int maxLen = 2048;
            byte[] contextBytes = new byte[maxLen];
            int realLen;
            StringBuffer message = new StringBuffer();
            BIORead:while(true) {
                try {
                    while((realLen = in.read(contextBytes, 0, maxLen)) != -1) {
                        message.append(new String(contextBytes , 0 , realLen));
                        /*
                         * 我们假设读取到“over”关键字，
                         * 表示客户端的所有信息在经过若干次传送后，完成
                         * */
                        if(message.indexOf(&quot;over&quot;) != -1) {
                            break BIORead;
                        }
                    }
            }
            //下面打印信息
           log.info(&quot;服务器(收到来自于端口：&quot; + sourcePort + &quot;的信息：&quot; + message);
            //下面开始发送信息
            out.write(&quot;回发响应信息！&quot;.getBytes());
            //关闭
            out.close();
            in.close();
            this.socket.close();
        } catch(Exception e) {
           log.error(&quot;Socket read failed. Exception:{}&quot;, e.getMessage());
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;tcp粘包拆包&quot;&gt;TCP粘包/拆包&lt;/h2&gt;
&lt;h3 id=&quot;问题说明&quot;&gt;1. 问题说明&lt;/h3&gt;
&lt;p&gt;假设客户端分别发送了两个数据包D1和D2给服务端，由于服务端一次读取到的字节数是不确定的，故可能存在以下4种情况。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;服务端分两次读取到了两个独立的数据包，分别是D1和D2，没有粘包和拆包；&lt;/li&gt;
&lt;li&gt;服务端一次接收到了两个数据包，D1和D2粘合在一起，被称为TCP粘包；&lt;/li&gt;
&lt;li&gt;服务端分两次读取到了两个数据包，第一次读取到了完整的D1包和D2包的部分内容，第二次读取到了D2包的剩余内容，这被称为TCP拆包；&lt;/li&gt;
&lt;li&gt;服务端分两次读取到了两个数据包，第一次读取到了D1包的部分内容D1_1，第二次读取到了D1包的剩余内容D1_2和D2包的整包。如果此时服务端TCP接收滑窗非常小，而数据包D1和D2比较大，很有可能会发生第五种可能，即服务端分多次才能将D1和D2包接收完全，期间发生多次拆包。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;解决思路&quot;&gt;2. 解决思路&lt;/h3&gt;
&lt;p&gt;由于底层的TCP无法理解上层的业务数据，所以在底层是无法保证数据包不被拆分和重组的，这个问题只能通过上层的应用协议栈设计来解决，根据业界的主流协议的解决方案，可以归纳如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;消息定长，例如每个报文的大小为固定长度200字节，如果不够，空位补空格；&lt;/li&gt;
&lt;li&gt;在包尾增加回车换行符进行分割，例如FTP协议；&lt;/li&gt;
&lt;li&gt;将消息分为消息头和消息体，消息头中包含表示消息总长度（或者消息体长度）的字段，通常设计思路为消息头的第一个字段使用int32来表示消息的总长度；&lt;/li&gt;
&lt;li&gt;更复杂的应用层协议。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;demo方案&quot;&gt;3. demo方案&lt;/h3&gt;
&lt;p&gt;作为socket长连接的demo，使用了上述的解决思路2，即在包尾增加回车换行符进行数据的分割，同时整体数据使用约定的&lt;code&gt;Json&lt;/code&gt;体进行作为消息的传输格式。&lt;/p&gt;
&lt;p&gt;使用换行符进行数据分割，可如下进行数据的单行读取：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));
String message;
while ((message = reader.readLine()) != null) {
//....
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可如下进行数据的单行写入：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;PrintWriter writer = new PrintWriter(new OutputStreamWriter(socket.getOutputStream()), true);
writer.println(message);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Json&lt;/code&gt;消息格式如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;服务端接收消息实体类&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;@Data
public class ServerReceiveDto implements Serializable {

    private static final long serialVersionUID = 6600253865619639317L;

    /**
     * 功能码 0 心跳 1 登陆 2 登出 3 发送消息
     */
    private Integer functionCode;

    /**
     * 用户id
     */
    private String userId;

    /**
     * 这边假设是string的消息体
     */
    private String message;

}&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;服务端发送消息实体类&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;@Data
public class ServerSendDto implements Serializable {

    private static final long serialVersionUID = -7453297551797390215L;

    /**
     * 状态码 20000 成功，否则有errorMessage
     */
    private Integer statusCode;

    private String message;

    /**
     * 功能码
     */
    private Integer functionCode;

    /**
     * 错误消息
     */
    private String errorMessage;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;客户端发送消息实体类&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;@Data
public class ClientSendDto implements Serializable {

    private static final long serialVersionUID = 97085384412852967L;

    /**
     * 功能码 0 心跳 1 登陆 2 登出 3 发送消息
     */
    private Integer functionCode;

    /**
     * 用户id
     */
    private String userId;

    /**
     * 这边假设是string的消息体
     */
    private String message;

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;客户端或服务端掉线检测功能&quot;&gt;客户端或服务端掉线检测功能&lt;/h2&gt;
&lt;h3 id=&quot;实现思路&quot;&gt;1. 实现思路&lt;/h3&gt;
&lt;p&gt;通过自定义心跳包来实现掉线检测功能，具体思路如下：&lt;/p&gt;
&lt;p&gt;客户端连接上服务端后，在服务端会维护一个在线客户端列表。客户端每隔一段时间，向服务端发送一个心跳包，服务端受收到包以后，会更新客户端最近一次在线时间。一旦服务端超过规定时间没有接收到客户端发来的包，则视为掉线。&lt;/p&gt;
&lt;h3 id=&quot;代码实现&quot;&gt;2. 代码实现&lt;/h3&gt;
&lt;p&gt;维护一个客户端map，其中key代表用户的唯一id(用户唯一id的身份验证下面会说明),value代表用户对应的一个实体&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 存储当前由用户信息活跃的的socket线程
 */
private ConcurrentMap&amp;lt;String, Connection&amp;gt; existSocketMap = new ConcurrentHashMap&amp;lt;&amp;gt;();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中&lt;code&gt;Connection&lt;/code&gt;对象包含的信息如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Slf4j
@Data
public class Connection {

    /**
     * 当前的socket连接实例
     */
    private Socket socket;

    /**
     * 当前连接线程
     */
    private ConnectionThread connectionThread;

    /**
     * 当前连接是否登陆
     */
    private boolean isLogin;

    /**
     * 存储当前的user信息
     */
    private String userId;

    /**
     * 创建时间
     */
    private Date createTime;

    /**
     * 最后一次更新时间，用于判断心跳
     */
    private Date lastOnTime;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;主要关注其中的&lt;code&gt;lastOnTime&lt;/code&gt;字段，每次服务端接收到标识是心跳数据，会更新当前的&lt;code&gt;lastOnTime&lt;/code&gt;字段，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if (functionCode.equals(FunctionCodeEnum.HEART.getValue())) {
    //心跳类型
    connection.setLastOnTime(new Date());
    //发送同样的心跳数据给客户端
    ServerSendDto dto = new ServerSendDto();
    dto.setFunctionCode(FunctionCodeEnum.HEART.getValue());
    connection.println(JSONObject.toJSONString(dto));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;额外会有一个监测进程，以一定频率来监测上述维护的map中的每一个Connection对象，如果当前时间与&lt;code&gt;lastOnTime&lt;/code&gt;的时间间隔超过自定义的长度，则自动将其对应的socket连接关闭,代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Date now = new Date();
Date lastOnTime = connectionThread.getConnection().getLastOnTime();
long heartDuration = now.getTime() - lastOnTime.getTime();
if (heartDuration &amp;gt; SocketConstant.HEART_RATE) {
    //心跳超时,关闭当前线程
    log.error(&quot;心跳超时&quot;);
    connectionThread.stopRunning();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上面代码中，服务端收到标识是心跳数据的时候，除了更新该&lt;code&gt;socket&lt;/code&gt;对应的&lt;code&gt;lastOnTime&lt;/code&gt;，还会同样同样心跳类型的数据给客户端，客户端收到标识是心跳数据的时候也会更新自己的&lt;code&gt;lastOnTime&lt;/code&gt;字段，同时也有一个心跳监测线程在监测当前的socket连接心跳是否超时&lt;/p&gt;
&lt;h2 id=&quot;客户端身份获知强制身份验证&quot;&gt;客户端身份获知、强制身份验证&lt;/h2&gt;
&lt;h3 id=&quot;实现思路-1&quot;&gt;1. 实现思路&lt;/h3&gt;
&lt;p&gt;通过代码&lt;code&gt;socket = serverSocket.accept()&lt;/code&gt;获得的一个&lt;code&gt;socket&lt;/code&gt;连接我们仅仅只能知道其客户端的&lt;code&gt;ip&lt;/code&gt;以及端口号，并不能获知这个&lt;code&gt;socket&lt;/code&gt;连接对应的到底是哪一个客户端，因此必须得先获得客户端的身份并且验证通过其身份才能让其正常连接。&lt;/p&gt;
&lt;p&gt;具体的实现思路是：&lt;/p&gt;
&lt;p&gt;自定义一个登陆处理接口，当&lt;code&gt;server&lt;/code&gt;端受到标识是用户登陆的时候（此时会携带用户信息或者token，此处简化为用户id），调用用户的登陆验证，验证通过的话则将该&lt;code&gt;socket&lt;/code&gt;连接与用户信息绑定，设置其为已登录，并且封装对应的对象放入前面提的客户端map中，由此可获得具体用户对应的哪一个&lt;code&gt;socket&lt;/code&gt;连接。&lt;/p&gt;
&lt;p&gt;为了实现&lt;code&gt;socket&lt;/code&gt;连接的强制验证，在监测线程中，也会判断当前用户多长时间内没有实现登录态，若超时则认为该&lt;code&gt;socket&lt;/code&gt;连接为非法连接，主动关闭该&lt;code&gt;socket&lt;/code&gt;连接。&lt;/p&gt;
&lt;h3 id=&quot;代码实现-1&quot;&gt;2. 代码实现&lt;/h3&gt;
&lt;p&gt;自定义登陆处理接口,这边简单以userId来判断是否允许登陆：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public interface LoginHandler {

    /**
     * client登陆的处理函数
     *
     * @param userId 用户id
     *
     * @return 是否验证通过
     */
    boolean canLogin(String userId);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;收到客户端发来的数据时候的处理：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if (functionCode.equals(FunctionCodeEnum.LOGIN.getValue())) {
    //登陆，身份验证
    String userId = receiveDto.getUserId();
    if (socketServer.getLoginHandler().canLogin(userId)) {
        //设置用户对象已登录状态
        connection.setLogin(true);
        connection.setUserId(userId);
        if (socketServer.getExistSocketMap().containsKey(userId)) {
            //存在已登录的用户，发送登出指令并主动关闭该socket
            Connection existConnection = socketServer.getExistSocketMap().get(userId);
            ServerSendDto dto = new ServerSendDto();
            dto.setStatusCode(999);
            dto.setFunctionCode(FunctionCodeEnum.MESSAGE.getValue());
            dto.setErrorMessage(&quot;force logout&quot;);
            existConnection.println(JSONObject.toJSONString(dto));
            existConnection.getConnectionThread().stopRunning();
            log.error(&quot;用户被客户端重入踢出，userId:{}&quot;, userId);
        }
        //添加到已登录map中
        socketServer.getExistSocketMap().put(userId, connection);
} &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;监测线程判断用户是否完成身份验证：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if (!connectionThread.getConnection().isLogin()) {
    //还没有用户登陆成功
    Date createTime = connectionThread.getConnection().getCreateTime();
    long loginDuration = now.getTime() - createTime.getTime();
    if (loginDuration &amp;gt; SocketConstant.LOGIN_DELAY) {
        //身份验证超时
        log.error(&quot;身份验证超时&quot;);
        connectionThread.stopRunning();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;socket异常处理与垃圾线程回收&quot;&gt;socket异常处理与垃圾线程回收&lt;/h2&gt;
&lt;h3 id=&quot;实现思路-2&quot;&gt;1. 实现思路&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;socket&lt;/code&gt;在读取数据或者发送数据的时候会出现各种异常，比如客户端的&lt;code&gt;socket&lt;/code&gt;已断开连接（正常断开或物理连接断开等），但是服务端还在发送数据或者还在接受数据的过程中，此时&lt;code&gt;socket&lt;/code&gt;会抛出相关异常，对于该异常的处理需要将自身的&lt;code&gt;socket&lt;/code&gt;连接关闭，避免资源的浪费，同时由于是多线程方案，还需将该&lt;code&gt;socket&lt;/code&gt;对应的线程正常清理。&lt;/p&gt;
&lt;h3 id=&quot;代码实现-2&quot;&gt;2. 代码实现&lt;/h3&gt;
&lt;p&gt;下面以server端发送数据为例,改代码中加入了重试机制：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void println(String message) {
    int count = 0;
    PrintWriter writer;
    do {
        try {
            writer = new PrintWriter(new OutputStreamWriter(socket.getOutputStream()), true);
            writer.println(message);
            break;
        } catch (IOException e) {
            count++;
            if (count &amp;gt;= RETRY_COUNT) {
                //重试多次失败，说明client端socket异常
                this.connectionThread.stopRunning();
            }
        }
        try {
            Thread.sleep(2 * 1000);
        } catch (InterruptedException e1) {
            log.error(&quot;Connection.println.IOException interrupt,userId:{}&quot;, userId);
        }
    } while (count &amp;lt; 3);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述调用的&lt;code&gt;this.connectionThread.stopRunning();&lt;/code&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void stopRunning() {
    //设置线程对象状态，便于线程清理
    isRunning = false;
    try {
        //异常情况需要将该socket资源释放
        socket.close();
    } catch (IOException e) {
        log.error(&quot;ConnectionThread.stopRunning failed.exception:{}&quot;, e);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述代码中设置了线程对象的状态，下述代码在监测线程中执行，将没有运行的线程给清理掉&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 存储只要有socket处理的线程
 */
private List&amp;lt;ConnectionThread&amp;gt; existConnectionThreadList = Collections.synchronizedList(new ArrayList&amp;lt;&amp;gt;());

/**
 * 中间list，用于遍历的时候删除
 */
private List&amp;lt;ConnectionThread&amp;gt; noConnectionThreadList = Collections.synchronizedList(new ArrayList&amp;lt;&amp;gt;());

//...

//删除list中没有用的thread引用
existConnectionThreadList.forEach(connectionThread -&amp;gt; {
    if (!connectionThread.isRunning()) {
        noConnectionThreadList.add(connectionThread);
    }
});
noConnectionThreadList.forEach(connectionThread -&amp;gt; {
    existConnectionThreadList.remove(connectionThread);
    if (connectionThread.getConnection().isLogin()) {
        //说明用户已经身份验证成功了，需要删除map
        this.existSocketMap.remove(connectionThread.getConnection().getUserId());
    }
});
noConnectionThreadList.clear();&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;由于使用了&lt;code&gt;springboot&lt;/code&gt;框架来实现该demo，所以项目结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1008446/201901/1008446-20190131231005119-806743561.png&quot; alt=&quot;整体目录&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;socket&lt;/code&gt;工具包目录如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1008446/201901/1008446-20190131231036798-1440153229.png&quot; alt=&quot;socket工具包目录&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pom&lt;/code&gt;文件主要添加了&lt;code&gt;springboot&lt;/code&gt;的相关依赖，以及&lt;code&gt;json&lt;/code&gt;工具和&lt;code&gt;lombok&lt;/code&gt;工具等，依赖如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;parent&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.0.3.RELEASE&amp;lt;/version&amp;gt;
    &amp;lt;relativePath/&amp;gt;
&amp;lt;/parent&amp;gt;

&amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;fastjson&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.2.36&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;自己写的&lt;code&gt;socket&lt;/code&gt;工具包的使用方式如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Configuration
@Slf4j
public class SocketServerConfig {

@Bean
public SocketServer socketServer() {
    SocketServer socketServer = new SocketServer(60000);
    socketServer.setLoginHandler(userId -&amp;gt; {
        log.info(&quot;处理socket用户身份验证,userId:{}&quot;, userId);
        //用户名中包含了dingxu则允许登陆
        return userId.contains(&quot;dingxu&quot;);

    });
    socketServer.setMessageHandler((connection, receiveDto) -&amp;gt; log
            .info(&quot;处理socket消息,userId:{},receiveDto:{}&quot;, connection.getUserId(),
                    JSONObject.toJSONString(receiveDto)));
    socketServer.start();
    return socketServer;
}
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该demo中主要提供了以下几个接口进行测试：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;服务端：获得当前用户列表，发送一个消息&lt;/li&gt;
&lt;li&gt;客户端：开始一个socket客户端，发送一个消息，关闭一个socket客户端，查看已开启的客户端&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;具体的postman文件也放已在项目中，具体可点此&lt;a href=&quot;https://github.com/DavidDingXu/springboot-socket-demo/blob/master/src/main/resources/Socket%E6%B5%8B%E8%AF%95.postman_collection.json&quot;&gt;链接&lt;/a&gt;获得&lt;/p&gt;
&lt;p&gt;demo中还提供了一个简单压测函数，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Slf4j
public class SocketClientTest {

    public static void main(String[] args) {
        ExecutorService clientService = Executors.newCachedThreadPool();
        String userId = &quot;dingxu&quot;;
        for (int i = 0; i &amp;lt; 1000; i++) {
            int index = i;
            clientService.execute(() -&amp;gt; {
                try {
                    SocketClient client;
                    client = new SocketClient(InetAddress.getByName(&quot;127.0.0.1&quot;), 60000);
                    //登陆
                    ClientSendDto dto = new ClientSendDto();
                    dto.setFunctionCode(FunctionCodeEnum.LOGIN.getValue());
                    dto.setUserId(userId + index);
                    client.println(JSONObject.toJSONString(dto));
                    ScheduledExecutorService clientHeartExecutor = Executors.newSingleThreadScheduledExecutor(
                            r -&amp;gt; new Thread(r, &quot;socket_client+heart_&quot; + r.hashCode()));
                    clientHeartExecutor.scheduleWithFixedDelay(() -&amp;gt; {
                        try {
                            ClientSendDto heartDto = new ClientSendDto();
                            heartDto.setFunctionCode(FunctionCodeEnum.HEART.getValue());
                            client.println(JSONObject.toJSONString(heartDto));
                        } catch (Exception e) {
                            log.error(&quot;客户端异常,userId:{},exception：{}&quot;, userId, e.getMessage());
                            client.close();
                        }
                    }, 0, 5, TimeUnit.SECONDS);
                    while (true){

                    }
                } catch (Exception e) {
                    log.error(e.getMessage());
                }

            });
        }
    }

}&lt;/code&gt;
&lt;/pre&gt;

</description>
<pubDate>Thu, 31 Jan 2019 15:14:00 +0000</pubDate>
<dc:creator>David丁</dc:creator>
<og:description>采用了BIO的多线程方案，实现了自定义简单协议，心跳机制，socket客户端身份强制验证，socket客户端断线获知等功能，并暴露了一些接口，可通过接口简单实现客户端与服务端的socket交互。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ading-blog/p/10344447.html</dc:identifier>
</item>
<item>
<title>JS 关于this p9 - 李鹏飞ONLINE</title>
<link>http://www.cnblogs.com/jony-it/p/10344405.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jony-it/p/10344405.html</guid>
<description>&lt;p&gt;关于this这个货，常常让我感到头疼，也很难说清这货到底是什么机制，今天就详细记录一下this，了解他就跟理解闭包差不多，不理解的时候我们会感到很难受总想着避开他，当我们真正理解之后，会有种茅塞顿开的感觉，但是也不要掉以轻心，说不定哪天又给来一脚~&lt;/p&gt;

&lt;p&gt;先看一个例子，之前的博客中也提过到的this使用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; fn(){
   console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.a)
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; a = 2&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; o = {a:7&lt;span&gt;};

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用之前讲到的apply&lt;/span&gt;
fn.apply(o); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;
fn();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;那么this那么简单好用么，当前不是，this是比较复杂的机制，有很多规则，不小心的话很会难受。&lt;/p&gt;
&lt;p&gt;一、抛开上面的例子，对于this我们平时会有一些误解：&lt;/p&gt;
&lt;p&gt;1.指向自身：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; fn(){
    console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.a);
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.a ++&lt;span&gt;;
}

fn.a &lt;/span&gt;= 0&lt;span&gt;;

fn(&lt;/span&gt;1&lt;span&gt;);

console.log(fn.a);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们预期是输出1，因为fn被调用了1次，并且那么a++ 会导致 变成1，但是最终却是0，如果下面再来一句~&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
var a = 0&lt;span&gt;;
fn(&lt;/span&gt;1&lt;span&gt;);

console.log(a);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;this.a 实际改变的是全局作用域a，所以例子中的 this 并没有指定为所包含的这个函数当中 = =。&lt;/p&gt;
&lt;p&gt;如果非要调用自身，可以采用具名函数的方式（不要使用arguments.callee，在上一章提到了，被废弃的方法我们还是不要接触了)：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; fn(){
    fn.a &lt;/span&gt;++&lt;span&gt;;
}

fn.a &lt;/span&gt;= 0&lt;span&gt;;

fn();

fn.a;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;或者，使用apply或者call&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; fn(){
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.a ++&lt;span&gt;;
}

fn.a &lt;/span&gt;= 0&lt;span&gt;;

&lt;span&gt;&lt;strong&gt;fn.call(fn);&lt;/strong&gt;&lt;/span&gt;

fn.a;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;说一下第一个例子为毛会是0，this 在当时指向的是全局作用域，而不是函数本身，当调用fn()方法时，this.a 会在全局作用域中声明一个 a 并执行 ++，就像下面这样&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; fn(){
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.a ++&lt;span&gt;;
}

fn();

console.log(a); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; NaN （因为a只是声明，当执行RHS的时候并没有a，那么undefined+1 会是啥？ NaN）&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所以：this 并不是指向自身。&lt;/p&gt;
&lt;p&gt;2.作用域&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; fn(){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; a = 0&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.fn2();
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; fn2(){
    console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.a)

}

fn();    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; undefined&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;首先this.fn2() 确实找到了fn2，在fn2中怎么会找到a=0呢，按照之前说的，它也只是在全局作用域中创建了一个a而已（实际上都没有创建，因为此处只有LHS 没有RHS，详细了解的话到之前的文章中看一下&lt;a href=&quot;https://www.cnblogs.com/jony-it/p/10331488.html&quot; target=&quot;_blank&quot;&gt;作用域&lt;/a&gt;，在此调用成功就当成是个意外吧 = =）。&lt;/p&gt;
&lt;p&gt;那么var a 把它理解为私有的属性，而在fn2中想要用fn的私有属性怎么可能呢？ 这段代码实际上想通过词法作用域的概念来用来fn中的a，但this并不会查到啥，除非这样（平常使用的比较多的）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; fn(){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; a = 0&lt;span&gt;;
    fn2(a);
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; fn2(a){
    console.log(a)
}&lt;p&gt;fn();&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;fn2中的a通过RHS 查询在上一层找到了 0。&lt;/p&gt;
&lt;p&gt;so、this和词法作用的查找是冲突的，不要再想着这样用了，忘了它吧~~&lt;/p&gt;
&lt;p&gt;那么下一句你可能在很多地方都看到过：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;this实际上是在函数被调用时发生的绑定，它的指向取决与函数在哪里被调用。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;二、调用位置：&lt;/p&gt;
&lt;p&gt;如何寻找位置，先告诉你，上一层或者说最后一层~ 别急着想像，看代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; fn(){
   fn2();
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; fn2(){
   console.log(&lt;/span&gt;'fn2'&lt;span&gt;);
}

fn();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; fn2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;fn的调用位置在全局作用域下，fn2的调用位置在fn下（fn2的调用栈就是 fn - &amp;gt; fn2)。&lt;/p&gt;
&lt;p&gt;所以，明白了调用位置了？ 如果是多层，还有一种办法通过强大的浏览器开发者界面，如下图：（多加了一个fn3，这样可能更清晰一点）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1515793/201901/1515793-20190131171302952-1629011193.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 三、绑定规则：&lt;/p&gt;
&lt;p&gt;在调用栈中找了调用位置，接下来看看绑定规则：4种&lt;/p&gt;
&lt;p&gt;优先级为：new &amp;gt; 显式 &amp;gt; 隐式 &amp;gt; 默认（为啥最后说）&lt;/p&gt;
&lt;p&gt;1.默认规则&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; fn(){
   console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.a);
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; a =2&lt;span&gt;;

fn(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个例子上面基本上都用到了，它用到的时候默认规则，this指向的是全局对象（并不是一定指向全局对象的哦，后面会说到）&lt;/p&gt;
&lt;p&gt;因为fn直接调用fn()，我们或许也可以这样理解 window.fn() ，this.a 指向window.a ，输出2~  是不是很好理解（有点像隐式绑定这样说~）&lt;/p&gt;
&lt;p&gt;但是有一点是需要注意的是，严格模式下不适用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; fn(){
  &lt;/span&gt;&quot;use strict&quot;&lt;span&gt;;
  console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.a);
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; a = 2&lt;span&gt;;

fn(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TypeError: Cannot read property 'a' of undefined&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;this不会默认绑定到window上，除非~：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
window.fn();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;真正意义上用到了隐式绑定~~（别急，马上就说隐式绑定）&lt;/p&gt;
&lt;p&gt;还有很&lt;strong&gt;&lt;span&gt;重要的一点&lt;/span&gt;&lt;/strong&gt;，严格模式下默认绑定只会关注函数体内部，不会关注被谁调用，像下面这样，是可以使用的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; fn(){
  console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.a);
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; a = 2&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; fn2(){
   &lt;/span&gt;&quot;use strict&quot;&lt;span&gt;;
    fn();
}

fn2();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2.隐式绑定：&lt;/p&gt;
&lt;p&gt;是否调用位置有上下文对象或者是上下文对象，或者说被某个对象包含或拥有：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; fn(){
  console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.a);
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; o =&lt;span&gt; {
  a:&lt;/span&gt;2&lt;span&gt;,
  fn: fn
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; o.fn = fn;&lt;/span&gt;
o.fn();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;不管是先定义或者是后引用&lt;/span&gt;&lt;/strong&gt;，在此隐式绑定的规则会把函数调用中的this 绑定到这个上下文对象。（回顾一下，在这里o的fn拥有所在作用域o的闭包或者说行使权、使用权，把它看成 o = {a:2,fn:function(){ console.log(this.a) }}）&lt;/p&gt;
&lt;p&gt;在声明一次：对象引用链只有&lt;strong&gt;&lt;span&gt;上一层或则最后一层&lt;/span&gt;&lt;/strong&gt;在调用位置起作用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; fn(){
   console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.a)

}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; o =&lt;span&gt; {
   a:&lt;/span&gt;0&lt;span&gt;,
   fn:fn
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; o2 =&lt;span&gt; {
   a:&lt;/span&gt;2&lt;span&gt;,
   o:o,
   fn:o.fn
}

o2.o.fn(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 0 （绑定的是o）&lt;/span&gt;
o.fn();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2   （这里o2的fn为函数本身，与o没有直接关系，所以this绑定的是o2这个对象，或者说叫隐式丢失）&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;tip：隐式丢失&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 跟上面的例子一个意思&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; fn(){
   console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.a)
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; o =&lt;span&gt; {
   a:&lt;/span&gt;2&lt;span&gt;,
   fn : fn
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; x =&lt;span&gt; o.fn;

x();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;undefined&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;o.fn 引用的是函数本身，并没有执行fn函数，所以x知识引用了fn函数，当执行x函数时，应用了到了上面说到的默认绑定，（在全局作用域声明了a，但是没有赋值），好吧，怕忘记了，如果像下面这样就更清晰了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在上面例子的基础上加2句&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; a =7&lt;span&gt;;
x();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再来一个，参考书《你不知道的javascript》：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; fn(){
  console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.a)
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; fn2(f){

  f();
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; o =&lt;span&gt; {
  a:&lt;/span&gt;2&lt;span&gt;,
  fn:fn
}

fn2(o.fn); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; undefined&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;fn2执行的f  是fn函数本身，跟o没有毛关系，所以最终也是使用了默认绑定。&lt;/p&gt;
&lt;p&gt;还有一种就是window内置对象，跟上面结果一样，在此就不写例子了。&lt;/p&gt;

&lt;p&gt;3.显示绑定&lt;/p&gt;
&lt;p&gt;这个可能最好理解，就是指定this要绑定的上下文对象，主要用到的就是 apply、call、bind，关于这3个货，想看的可以看看之前的文章 &lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/jony-it/p/10338047.html&quot;&gt;JS 关于 bind ,call,apply 和arguments p8&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里主要说一个概念：如果你传入一个原始值比如：“”、1、true，当作this 的绑定对象，这个值会转为它的对象形式（new String（）、new Number（）、new Boolean（）），称为装箱。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; fn(){
    console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.a);
}

fn.call({a:&lt;/span&gt;2});&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;
&lt;span&gt;
fn();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; undefined&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上面看到的显示绑定也不会解决丢失绑定的问题。&lt;/p&gt;
&lt;p&gt;但是我们可以通过&lt;strong&gt;&lt;span&gt;硬绑定&lt;/span&gt;&lt;/strong&gt;来解决这个问题：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
function fn(){
  console.log(this.a)
}

var o = {
  a:2
}

function fn2(){
  fn.call(o);
}

fn2();//2
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样调用fn2的时候都会默认显示绑定。&lt;/p&gt;
&lt;p&gt; 它的典型行为是：创建一个包裹函数，负责接收参数并返回值。&lt;/p&gt;
&lt;p&gt;看这个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; fn(f){
   console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.a);
   console.log(f);
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; o =&lt;span&gt; {
  a:&lt;/span&gt;2&lt;span&gt;
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; fn2(){
   fn.apply(o,arguments)
}

fn2(&lt;/span&gt;6&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;跟上一个例子差不多，这里利用了arguments内置对象来传递参数。&lt;/p&gt;
&lt;p&gt;还有一种是创建辅助函数:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; fn(f){
  console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.a);
  console.log(f);
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; o = { a:3&lt;span&gt;}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; fn2(){

   &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (){
        fn.apply(o,arguments); 
   }
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; fn3 =&lt;span&gt; fn2();

fn3(&lt;/span&gt;8&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对比上一个例子，一个是立即执行，另一个是返回绑定后的函数本身再进行调用。或者使用bind也行&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; fn(f){
  console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.a);
  console.log(f);
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; o = { a:3&lt;span&gt;}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; fn2(){
   &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;  fn.bind(o); 
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; fn3 =&lt;span&gt; fn2();

fn3(&lt;/span&gt;5&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另外关于API 调用上下文在实际应用中有需要函数上就是通过call 与apply 实现了显示绑定，比如[].forEach();&lt;/p&gt;
&lt;p&gt;4.new 绑定&lt;/p&gt;
&lt;p&gt;首先要说的是，new不会实例化某个类（和我之前的说法有些冲突，但是实例我们会比较好理解），因为他们是被new操作符调用的普通函数。&lt;/p&gt;
&lt;p&gt;类似这种 new String() ，正确的说法叫做“&lt;strong&gt;&lt;span&gt;函数调用&lt;/span&gt;&lt;/strong&gt;”，因为实际上js中并不存在构造函数之说，只存在函数调用。&lt;/p&gt;
&lt;p&gt;上面是官方一点的语言，其实我们只需要知道这几点暂时：&lt;/p&gt;
&lt;p&gt;new 会创建一个&lt;span&gt;全新的对象&lt;/span&gt;，并且这个对象会&lt;span&gt;绑定到函数调用的this&lt;/span&gt;，如果这个函数&lt;span&gt;没有return&lt;/span&gt; 那么就&lt;span&gt;返回这个函数本身的&lt;strong&gt;新对象&lt;/strong&gt;&lt;/span&gt;~&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; fn(){&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.a = 3&lt;span&gt;;
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; fn2 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; fn();

fn2.a;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上，new出来的新对象fn2 绑定到了fn的this上，是一个全新的对象（这跟之前的文自定义创建对象中说到的一样，如果为私有变量，则不会拥有它，或者它看不到，但是可以使用它比如下面这种：）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; fn(){
   &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.a = 3&lt;span&gt;;
   &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; b = 4&lt;span&gt;;

   &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.fn2 = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
       console.log(b) ;
   }
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; fn3 =&lt;span&gt; fn();

console.log(fn3);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; {a: 3, fn2: ƒ}&lt;/span&gt;
fn3.fn2();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里除了this，还有闭包的相关概念，在此就不多说了。大家只要知道this绑定到了新对象上（全新的）。&lt;/p&gt;

&lt;p&gt;好了，4种绑定说完了，接下来说下优先级：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; fn(){
   console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.a)
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; o = {a:2&lt;span&gt;,fn:fn};

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; o2 = {a:5&lt;span&gt;,fn:fn}

o.fn();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;
o.fn.call(o1);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么看显示绑定应该是优先于隐式绑定的，通过最后一行可以看出来（这里我感觉有点不好理解，或者我们可以这样理解，o.fn() 是显示绑定this所以从调用位置来看，上下文o的a为2所以this.a输出的为2；o.fn 为函数本身，所以在对函数本身进行显示绑定，所以this绑定到了o2上面）&lt;/p&gt;
&lt;p&gt;并且显示绑定和隐式绑定都会丢失this（上面提到的）。&lt;/p&gt;

&lt;p&gt;看下一个new 绑定和隐式绑定：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; fn(f){
  &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.a =&lt;span&gt; f
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; o =&lt;span&gt; {
  fn:fn
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; o2 =&lt;span&gt;{}

o.fn(&lt;/span&gt;0&lt;span&gt;);
console.log(o.a);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;
&lt;span&gt;
o.fn.call(o2,&lt;/span&gt;3&lt;span&gt;);
console.log(o2.a);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;

&lt;span&gt;var&lt;/span&gt; fn2 = &lt;span&gt;new&lt;/span&gt; o.fn(5&lt;span&gt;);
console.log(o.a);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;
console.log(o2.a);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;
console.log(fn2.a);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;o.fn(0) 为隐式绑定，this绑定到o 上，o.a 为0 这点不用多说。&lt;/p&gt;
&lt;p&gt;o.fn.call(o2,3); fn函数本身中this被显示绑定带o2上，o2对象获得a并为3；&lt;/p&gt;
&lt;p&gt;最后fn2为一个new出来的新对象，this绑定到这个新对象上（上下文），它的a为5。（因为函数就是对象）&lt;/p&gt;
&lt;p&gt;不是很明显，下面来一个(比较new 和显示绑定)：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; fn(f){
  &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.a =&lt;span&gt; f
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; o =&lt;span&gt; {}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; x =&lt;span&gt; fn.bind(o)

x(&lt;/span&gt;1&lt;span&gt;)；

o.a;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;

&lt;span&gt;var&lt;/span&gt; y = &lt;span&gt;new&lt;/span&gt; x(3&lt;span&gt;)

y.a;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;个人感觉在判断优先级时，不能只是记住哪种规则优先级高，而是需要仔细分析，还是理解最重要&lt;/p&gt;
&lt;p&gt;比如：&lt;/p&gt;
&lt;p&gt;o.fn.call()    ，首先o是一个对象，o对象中包涵的函数fn 在这里并没有调用它，按照之前所说，它只是表示函数本身，那么在调用call的显示绑定并执行了该函数，那么this肯定会绑定到显示绑定的第一个参数上，所以是显示优先&lt;/p&gt;
&lt;p&gt;var fn2 = new o.fn();  记住最关键的那句，new会&lt;span&gt;&lt;strong&gt;创建一个新对象&lt;/strong&gt;&lt;/span&gt;并绑定到this上，这样就不会迷糊了，o.fn 是函数本身，并且创建一个新对象，那么fn2 是一个全新的对象，所以这里就是new 优先&lt;/p&gt;
&lt;p&gt;（this与call无法同时使用但是可以用bind）&lt;/p&gt;
&lt;p&gt;var fn2 = fn.bind(o);&lt;/p&gt;
&lt;p&gt;var bar = new fn2();&lt;/p&gt;
&lt;p&gt;纵使怎么变，fn2是显示绑定没错，如果像上面例子 fn是这样的  function(f){ this.a = f },那么fn2.a 肯定是o的a，&lt;/p&gt;
&lt;p&gt;但是bar 声明使用new 绑定，那么会创建一个&lt;strong&gt;&lt;span&gt;新对象~新对象~新对象&lt;/span&gt;&lt;/strong&gt;，所以，fn2里如果加上一个参数比如 new fn2(3) ，那么新声明的bar.a 肯定就是3~&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不要被所谓的优先级弄晕了，记住这几条重要的规则，管它怎么变，相信都能找到最终的那个this。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;这里有一个概念：第一个参数用于绑定this，剩余的参数用于传递给下层函数的这种行为被称为“部分应用”、或者“&lt;strong&gt;&lt;span&gt;柯里化&lt;/span&gt;&lt;/strong&gt;”。（bind、apply、call）&lt;/p&gt;
&lt;p&gt;那么这里对于判断this绑定的是什么就很好查了：&lt;/p&gt;
&lt;p&gt;1.先看new&lt;/p&gt;
&lt;p&gt;2.再看call、apply、bind&lt;/p&gt;
&lt;p&gt;3.看隐式调用 o.fn()&lt;/p&gt;
&lt;p&gt;4.啥都没，那就是默认绑定（官方的语言是，如果在严格模式下，就绑定到undefined，否则绑定到&lt;strong&gt;&lt;span&gt;全局对象&lt;/span&gt;&lt;/strong&gt;） &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;但是&lt;/span&gt;&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;如果把null 或则undefined作为this的绑定对象传给apply的话，嘿嘿~&lt;/p&gt;
&lt;p&gt;调用的时候会被忽略~&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; fn(){
  console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.a)
}

fn.apply(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; undefined&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其实就等于直接调用 fn()罢了。&lt;/p&gt;
&lt;p&gt;当然我们可以另类的用这种机制：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; fn(){
   &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(let i = 0 ;i&amp;lt;arguments.length;i++&lt;span&gt;){
         console.log(arguments[i]);
   }
}

fn.apply(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;,[1,2&lt;span&gt;]);  
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;是的，可以用来做展开数组（但是这里看着没必要）（在es6里可以通过...来解决展开数组的问题，像这样fn(...[1,2])）&lt;/p&gt;
&lt;p&gt;如果使用null 作为柯里化的这种操作很危险，为啥，看下面：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; fn(a){
   &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.a =&lt;span&gt; a;
}

fn.call(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;,2&lt;span&gt;);

console.log(a);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;默认绑定使全局作用域的a 赋值了2（成功进行了RHS 查询）。&lt;/p&gt;

&lt;p&gt;如果非要使用的话：可以使用空对象，如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; fn(a){
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.a =&lt;span&gt; a;
    console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.a)
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; n = Object.create(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);

fn.call(n,&lt;/span&gt;2&lt;span&gt;);

console.log(a);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; a is not defined&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 或者使用严格模式也未尝不可，但是代码中混用严格模式与懒惰模式真的会很不好维护~~&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; fn(a){
    &lt;/span&gt;'use strict'&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.a =&lt;span&gt; a;
}

fn.call(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;,2) ; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Uncaught TypeError: Cannot set property 'a' of null&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;拓展一下Object.create()&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;&lt;code&gt;Object.create()&lt;/code&gt;&lt;/strong&gt;方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。 （请打开浏览器控制台以查看运行结果。&lt;/a&gt;）&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;另外：间接引用也会使用默认绑定&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; fn(){
  console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.a)
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; o = {a:2&lt;span&gt;,fn:fn}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; o2 =&lt;span&gt; {}


&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; x =&lt;span&gt; o.fn;

x();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; undefined&lt;/span&gt;
&lt;span&gt;
(o2.fn &lt;/span&gt;= o.fn)();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;undefined&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里其实很简单，按照之前说的，o.fn 是函数本身，并没有进行绑定~&lt;/p&gt;

&lt;p&gt;还有一种绑定叫做“&lt;strong&gt;&lt;span&gt;软绑定&lt;/span&gt;&lt;/strong&gt;”，可以给默认绑定指定一个全局对象和undefined的值，同事保留隐式绑定或者显示绑定this的能力~&lt;/p&gt;
&lt;p&gt;说实话，平时我们不太会用到，了解一下就好，软绑定在内置方法中并不存在，如果想要使用，必须自己实现，下面给出官方的例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;Function.prototype.softBind){
    Function.prototype.softBind &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (obj){ 
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; fn=&lt;span&gt;this&lt;/span&gt;&lt;span&gt;; 
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; curried = [].slice.call(arguments,1&lt;span&gt;); 
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; bound = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){ 
              &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; fn.apply((!&lt;span&gt;this&lt;/span&gt;||&lt;span&gt;this&lt;/span&gt;===(window||global))?obj:&lt;span&gt;this&lt;/span&gt;&lt;span&gt;,curried.concat.apply(curried,arguments));
        };&lt;br/&gt;bound.prototype &lt;/span&gt;=&lt;span&gt; Object.create(fn.prototype);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; bound;
   };
        
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;检查调用对象this绑定的对象到底是谁？如果是window或者undefined、null之类的那么this绑定就交给参数对象obj去处理，相反&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;如果不是，则交给this本身去处理，方法的最后一步把fn 也就是this的原型保留并传给新声明的还说bound并返回~ 😵&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt; fn(){console.log(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.a)}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; o = {a:0&lt;span&gt;},
     o1 &lt;/span&gt;= {a:1&lt;span&gt;},
     o2 &lt;/span&gt;= {a:2&lt;span&gt;};

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; x =&lt;span&gt; fn.softBind(o);
x();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 0 &lt;/span&gt;
&lt;span&gt;
o1.fn &lt;/span&gt;=&lt;span&gt; fn.softBind(o);
o1.fn();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1  ~ 绑定的是o  但是最终o1为1不是0&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; 为了与bind区分下面来一个bind&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; y =&lt;span&gt; {}
y.fn &lt;/span&gt;=&lt;span&gt; fn.bind(o)；
y.fn() &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;bind 是显示绑定，并返回一个显示绑定后的函数（this已绑定，不是函数本身），所以y.fn() 中的this.a为显示绑定对象o中的a 也就是0。&lt;/p&gt;
&lt;p&gt;那么软绑定：&lt;/p&gt;
&lt;p&gt;如果this绑定到全局对象或者undefined，那么把默认对象交给this （x=fn.softBind）这里，因为x() 默认其实就是 window.x(), 调用对象是window所以，在执行x（）没有使用默认绑定，而是交给了obj也就是传给softBind的o去处理。&lt;/p&gt;
&lt;p&gt;因为o1.fn = fn.softBind(o),再看fn.softBind(o), 返回的方法交给了o去处理，但是调用o1.fn 时，调用对象o1 并不是window，所以交给了o1 去处理，也就是使用了隐式绑定。&lt;/p&gt;
&lt;p&gt;那么显示绑定呢：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
o2.fn = fn.softBind(o);
o2.fn();//2
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 同上面一句话，我就不多打一遍了。&lt;/p&gt;
&lt;p&gt;软绑定我们平时用的很少~ 没事就不要用了，省得跟bind 搞晕掉了 = =~~&lt;/p&gt;

&lt;p&gt;五、胖函数（箭头函数）对this的影响&lt;/p&gt;
&lt;p&gt;箭头函数跟let一样会劫持所在的块作用域{....}，是隐式的或者说不会干扰父级，在这里，它并不是使用以上4中绑定this的规则，而是根据外层作用域来决定this由谁绑定~！&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; fn(){
   console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.a);
   &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ()=&amp;gt;&lt;span&gt;{
         console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.a);
    }
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; o = {a:2&lt;span&gt;}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; x =&lt;span&gt; fn.bind(o)

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; y = x();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2 一切正常fn的this绑定到o的a&lt;/span&gt;
&lt;span&gt;
y(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2   胖箭头里的this 也绑定了o？&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;按照之前所说，bind 只会绑定函数的作用域，而不会管子孙的死活，像是下面这样&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; fn(){
   console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.a);
   &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt; (){console.log(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.a)}
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; o = {a:2&lt;span&gt;}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; x =&lt;span&gt; fn.bind(o)

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; y = x();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;
&lt;span&gt;
y();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; undefined&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是胖箭头打破了这种规则，而且谁都不鸟~并且，箭头函数在绑定后，无法被修改，及时new 也不行&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; fn(){
   console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.a);
   &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ()=&amp;gt;&lt;span&gt;{
         console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.a);
    }
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; o = {a:2&lt;span&gt;}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; x =&lt;span&gt; fn.bind(o)；

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; y = x(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;
&lt;span&gt;
y();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 下面开始装了，根本不鸟你显示绑定&lt;/span&gt;
y.call({a:5});&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这里，箭头函数更适合回调函数~比如定时器等等，可以根据外层（词法作用域）来绑定this。&lt;/p&gt;
&lt;p&gt;另外：&lt;/p&gt;
&lt;p&gt;其实之前降到的var self = this； 与之相似，道理都是一样的。&lt;/p&gt;
&lt;p&gt;如果在代码中你觉得用self = this 用的爽，那就不要考虑用箭头函数，&lt;/p&gt;
&lt;p&gt;如果你觉得直接用this显得niuX，那么如果遇到类似情况，可以使用胖箭头 = =~&lt;/p&gt;

&lt;p&gt;结束。（文章主要以书《你不知道的javascript为基础》，加上大部分自己的理解，顺便做个记录，加深印象）&lt;/p&gt;

</description>
<pubDate>Thu, 31 Jan 2019 14:54:00 +0000</pubDate>
<dc:creator>李鹏飞ONLINE</dc:creator>
<og:description>关于this这个货，常常让我感到头疼，也很难说清这货到底是什么机制，今天就详细记录一下this，了解他就跟理解闭包差不多，不理解的时候我们会感到很难受总想着避开他，当我们真正理解之后，会有种茅塞顿开的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jony-it/p/10344405.html</dc:identifier>
</item>
<item>
<title>electron热更新与windows下的安装包 - dx39066</title>
<link>http://www.cnblogs.com/TaoLand/p/10344235.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/TaoLand/p/10344235.html</guid>
<description>&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;帮朋友公司做了点东西，他说有很多bug，我一看，基本问题都是浏览器兼容引起的，而electron内带Chromium内核，正好一直想尝试下electron,所以研究了一波。这里只是简单的使用electron作为壳，把自己的项目嵌进去，更多深入研究以后再来。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;打包自己的项目&quot;&gt;打包自己的项目&lt;/h3&gt;
&lt;p&gt;这里没啥说的自己的项目打包下来,类似下面&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9492879-25b3e80e6dab4310.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;1.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;快速开始electron&quot;&gt;快速开始electron&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;上手electron，官方提供了一个非常好的快速上手实例&quot;electron-quick-start&quot;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;热更新&quot;&gt;热更新&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;因为Chromium的缘故，即使很小的项目打包出来也有120M左右，如果给客户使用，不可能每次有点改动就让客户重新安装，显然我们需要热更新。&lt;/li&gt;
&lt;li&gt;热更新的原理：每次启动程序我们就去拿本地的版本号和服务器上的版本号做对比，如果不一致就去请求资源，下载下来更新本地文件。&lt;/li&gt;
&lt;li&gt;首先我们观察打包出来的文件，发现原始文件都放在resources/app下面的，也即是说我们下载下来的文件直接覆盖到resources/app下就可以达到更新了。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9492879-1381e80a437435af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;3.png&quot;/&gt;&lt;/li&gt;
&lt;li&gt;这里我推荐七牛云，免费的可以使用10G内存，我们把更新资源放上去，需要版本号package.json和更新包dist.zip&lt;/li&gt;
&lt;li&gt;然后改写electron配置main.js，加入检测更新的代码&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;/**
 * 检测更新
 */
// const baseUrl = &quot;./&quot;;
const baseUrl = &quot;./resources/app/&quot;;
const fileUrl = &quot;http://pm72qibzx.bkt.clouddn.com/&quot;;//这里需要修改为自己的资源外网
(function () {
  return new Promise((resolve, reject) =&amp;gt; {
    request(
      {
        url: `${fileUrl}package.json?v=${new Date().getTime()}`,//请求package.json，与本地对比版本号
      },
      (error, res, body) =&amp;gt; {
        try {
          if (error || res.statusCode !== 200) {
            throw '更新版本号失败，请联系管理员';
          }
          const json = JSON.parse(body);
          const { version, description } = json;
          const localVersion = electron.app.getVersion();
          // console.log(version, localVersion)
          if (version != localVersion) {
            mainWindow.webContents.send('updating', '更新中')
            console.log('need update')
            dialog.showMessageBox({
              type: 'info',
              title: '发现新版本',
              message: '请点击按钮进行更新，预计持续几分钟，期间请不要操作，更新后会自动重启',
              buttons: ['马上更新']
            },
              // (index) =&amp;gt; {
              //   if (index == 0) {
              //     mainWindow.setProgressBar(0.5)
              //   } else {
              //   }
              // }
            )
            mainWindow.setProgressBar(0.5);
            downLoad()
              .then(() =&amp;gt; {
                console.log('update success')
                //重写版本号到本地
                fs.readFile(`${baseUrl}package.json`, function (err, data) {
                  if (err) {
                    return console.error(err);
                  }
                  let newData = JSON.parse(data);
                  newData.version = version;
                  fs.writeFile(`${baseUrl}package.json`, JSON.stringify(newData), function (err) {
                    if (err) {
                      return console.error(err);
                    }
                    // 重启
                    app.relaunch({ args: process.argv.slice(1) });
                    app.exit(0);
                  });
                });
              })
          } else {
            console.log('no update')
          }
        } catch (err) {
          reject(err);
        }
      })
  })
})()
/**
 * 更新
 */
const downLoad = () =&amp;gt; {
  return new Promise((resolve, reject) =&amp;gt; {
    const stream = fs.createWriteStream(`${baseUrl}temp/dist.zip`);
    const url = `${fileUrl}dist.zip?v=${new Date().getTime()}`;
    request(url).pipe(stream).on('close', () =&amp;gt; {
      const unzip = new adm_zip(`${baseUrl}temp/dist.zip`);   //下载压缩更新包
      unzip.extractAllTo(`${baseUrl}`, /*overwrite*/true);   //解压替换本地文件
      resolve()
    });
  })
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;windows下的安装包&quot;&gt;windows下的安装包&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;这里使用electron-winstaller&lt;/li&gt;
&lt;li&gt;配置在build.js&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;resultPromise = electronInstaller.createWindowsInstaller({
  appDirectory: path.join('./electron/ElectronTest-win32-x64'), //入口
  outputDirectory: path.join('./installer/installer64'),     //出口
  authors: 'yyt',
  exe: 'ElectronTest.exe',        //名称
  setupIcon: path.join('icon.ico'),//安装图标，必须本地
  iconUrl: 'http://pm72qibzx.bkt.clouddn.com/icon.ico',//程序图标，必须url
  noMsi: true,
});&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;node build.js 打包成win安装包&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9492879-3a360a0c204e2dd9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;4.png&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;完成&quot;&gt;完成&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;完成安装后，玩耍吧&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9492879-5fe80903b96987c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;5.png&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;源码&quot;&gt;&lt;a href=&quot;https://github.com/bestRenekton/demos/tree/master/electron-test&quot;&gt;源码&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;删除electron和install,防止老文件&lt;/li&gt;
&lt;li&gt;考入自己项目文件到跟目录，覆盖index.html&lt;/li&gt;
&lt;li&gt;cnpm i 或者npm i&lt;/li&gt;
&lt;li&gt;修改main.js中fileUrl为自己的更新包资源地&lt;/li&gt;
&lt;li&gt;修改build.js中的安装包名称，图标等&lt;/li&gt;
&lt;li&gt;npm run packager 打包&lt;/li&gt;
&lt;li&gt;注意：需要先进入electron项目，‘比如D:\phpStudy\WWW\others\electron-test\electron\ElectronTest-win32-x64\resources\app’，安装cnpm i request adm-zip&lt;/li&gt;
&lt;li&gt;node build.js 打包成win安装包&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;最后&quot;&gt;最后&lt;/h3&gt;
&lt;blockquote readability=&quot;6.4146341463415&quot;&gt;
&lt;p&gt;大家好，这里是「 TaoLand 」，这个博客主要用于记录一个菜鸟程序猿的Growth之路。这也是自己第一次做博客，希望和大家多多交流，一起成长！文章将会在下列地址同步更新……&lt;br/&gt;个人博客：&lt;a href=&quot;https://www.yangyuetao.cn/&quot;&gt;www.yangyuetao.cn&lt;/a&gt;&lt;br/&gt;小程序：&lt;a href=&quot;https://yangyuetao.cn/static/img/wx.f2e492a.jpg&quot;&gt;TaoLand&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 31 Jan 2019 13:52:00 +0000</pubDate>
<dc:creator>dx39066</dc:creator>
<og:description>帮朋友公司做了点东西，他说有很多bug，我一看，基本问题都是浏览器兼容引起的，而electron内带Chromium内核，正好一直想尝试下electron,所以研究了一波。这里只是简单的使用elect</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/TaoLand/p/10344235.html</dc:identifier>
</item>
<item>
<title>Unity3D中Isometric Tilemap功能实践 - 韩子卢</title>
<link>http://www.cnblogs.com/vvjiang/p/10344007.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/vvjiang/p/10344007.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;最近出于兴趣想自己做一个2D的游戏，因为有着C#的基础，所以决定使用Unity3D来做。&lt;/p&gt;
&lt;p&gt;之前对于Unity3D其实了解不多，不过看了一些Unity3D的视频和官方文档后，暂时做起来也没遇到什么太大的困难。&lt;/p&gt;
&lt;p&gt;本篇博客要说的是Unity 2018.3新增的一个东西——Isometric TileMap，一般用于做一个2.5D的地图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/746209/201901/746209-20190131203256797-1454051664.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个东西官方文档讲的并不详细,并且有些配置完全没有说出来，导致始终无法达到预期效果。&lt;/p&gt;
&lt;p&gt;国内的各种中文社区和问答网站都没有这方面的资料，最后还是在Unity的英文社区找到了一篇答案才有了进展：&lt;a href=&quot;https://forum.unity.com/threads/isometric-tilemap-sorting-issues.554914/&quot;&gt;参考链接&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;但是即使按照这篇答案中的方法进行操作，在我这里依然没法成功实现这个2.5D的地图。&lt;/p&gt;
&lt;p&gt;后来自己慢慢摸索才最终实现，所以特此记录下实现的步骤。&lt;/p&gt;
&lt;h2 id=&quot;导入图片生成纹理图片&quot;&gt;导入图片生成纹理图片&lt;/h2&gt;
&lt;p&gt;如果将使用TileMap画地图比作给墙贴瓷砖，那么首先我们需要为瓷砖设置不同的花纹，所以我们要导入一张图片作为花纹。&lt;/p&gt;
&lt;p&gt;导入图片生成纹理图片后，需要将其纹理类型设置为Sprite (2D and UI)，因为Tilemaps不支持其它的纹理类型。&lt;/p&gt;
&lt;p&gt;注意到纹理属性中的Pixels Per Unit (PPU)，它的值默认为100。&lt;/p&gt;
&lt;p&gt;这个属性很关键，它决定了这个纹理图片在Unity中显示时，1个Unity的单元显示多少个像素。&lt;/p&gt;
&lt;p&gt;也就是说一张400 X 200的纹理图片在Unity中，相当于4*2个Unity单元。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/746209/201901/746209-20190131203836059-1949301271.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;新建瓷砖&quot;&gt;新建瓷砖&lt;/h2&gt;
&lt;p&gt;纹理就是一个花纹，不可能将花纹直接花在墙上，我们需要根据花纹生成不同的瓷砖，然后再将瓷砖贴到墙上，Tile就是我们的瓷砖。&lt;/p&gt;
&lt;p&gt;通过Assets &amp;gt; Create &amp;gt; Tile生成一个Tile文件，然后将之前导入的纹理图片与Tile文件关联。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/746209/201901/746209-20190131204011365-1745085265.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;新建isometric-tilemap&quot;&gt;新建Isometric Tilemap&lt;/h2&gt;
&lt;p&gt;要贴瓷砖还需要一面墙，而Isometric Tilemap就是我们的墙。&lt;/p&gt;
&lt;p&gt;使用GameObject &amp;gt; 2D Object &amp;gt; Tilemap，创建一个带有一个Tilemap子节点的Grid对象。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/746209/201901/746209-20190131204204402-1809641612.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个Grid对象的Cell Layout选项有我们发现关于Isometric Tilemap有两个，一个是Isometric，而另外一个是Isometric Z As Y。&lt;/p&gt;
&lt;p&gt;Isometric实现的是相当于一个地形一样的东西，但是想要在这个地形上放上房子和树木之类的，那么需要设置为Isometric Z As Y。&lt;/p&gt;
&lt;p&gt;在这里我们看到还有一个Cell Size的设置，我在这里设置为 X：1，Y：0.5，Z：1。（请注意，这里的Z的大小务必为1，否则同样无法再地形上放置房子）&lt;/p&gt;
&lt;p&gt;Cell Size中的X为1，表示一个Unity的单元格中X的长度相当于多少个Unity单元。&lt;/p&gt;
&lt;p&gt;导入一张400 X 200的纹理图片，它的PPU为100，那么相当于需要4 X 2的Unity单元。&lt;/p&gt;
&lt;p&gt;因为我们这里讲CellSize的X与Y设置为1和0.5，所以这张纹理图片在TileMap中的显示占4个单元格。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/746209/201901/746209-20190131204836943-487681427.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而对于Grid下的Tilemap对象，我们只需要修改一个属性，即将Tilemap Render的Mode改为Individual。&lt;/p&gt;
&lt;p&gt;这么做的原因是只有在Individual下，Scene视图中Tilemap的各个Tile间才能正确排序。&lt;/p&gt;
&lt;p&gt;如果是Chunk模式，不同的Tile在绘制时会出现下面这种遮挡的现象：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/746209/201901/746209-20190131211157344-1929158111.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不过在我们打包时，还是需要将Mode改为Chunk，因为Chunk会按位置对Tiles进行分组，并将它们的Sprite一起批处理以进行渲染，这样会提高性能。&lt;/p&gt;
&lt;p&gt;另外在Chunk模式下，还需要将不同的Sprite放到一个Sprite Altas中，这样它们才能正确排序。&lt;/p&gt;
&lt;p&gt;因为这篇博客的主题不是这方面所以只是捎带提起，具体如何使用Chunk模式可以查询官方文档，这里不再赘述，先将Mode设置为Individual即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/746209/201901/746209-20190131205825083-1804768641.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;新建tile-palette&quot;&gt;新建Tile Palette&lt;/h2&gt;
&lt;p&gt;有了瓷砖和墙，那么我们还需要一个装瓷砖的箱子。&lt;/p&gt;
&lt;p&gt;这个瓷砖箱装着各种各样的瓷砖，当我们贴瓷砖时，就从这个瓷砖箱中取出来用。&lt;/p&gt;
&lt;p&gt;Tile Palette就是我们瓷砖箱。&lt;/p&gt;
&lt;p&gt;使用Window &amp;gt; 2D &amp;gt; Tile Palette，打开Tile Palette视图。&lt;/p&gt;
&lt;p&gt;点击Create New Palette创建一个Tile Palette，请保证这个Tile Palette的属性和Isometric Tilemap的属性匹配，即：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Cell Size为Manuel，值为 X：1，Y：0.5，Z：1&lt;/li&gt;
&lt;li&gt;Grid为Isometric Z As Y&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果你的图片是矩形图片那么就是，那么这里的Y为0.5，如果基于等距投射的图片，那么Y为0.57735。&lt;/p&gt;
&lt;p&gt;创建了Tile Palette后，我们将之前导入的Tile文件拖动到Tile Palette上，也就相当于将瓷砖放到了瓷砖箱中。&lt;/p&gt;
&lt;p&gt;如果拖动纹理图片到Tile Palette上，也会自动生成一个Tile文件，这样方便得多。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/746209/201901/746209-20190131205002830-1138418425.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;开始绘制tilemap&quot;&gt;开始绘制Tilemap&lt;/h2&gt;
&lt;p&gt;贴瓷砖就是从瓷砖箱中选择瓷砖，然后贴到墙上。&lt;/p&gt;
&lt;p&gt;而绘制地图，就是在Tile Palette中选择不同的Tile，然后选定Active Tilemap为指定的TileMap后就可以绘制了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/746209/201901/746209-20190131205102321-1580387766.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是当我们准备画图的时候发现，一个Unity单元格实在太小了，就相当于一个像素那么大。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/746209/201901/746209-20190131205156447-180432603.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里可以通过设置TileMap对象的scale，将其X和Y放大100倍来处理。（当然也可以通过同时调节Grid的Cell Size的X为100，Y为50，然后再将图片的PPU从100改为1）&lt;/p&gt;
&lt;p&gt;此时可以看到我们的Tile大小正好合适。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/746209/201901/746209-20190131205658480-1745317043.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么我们可以在两个单元格内绘制不同的Tile，但是这里注意到，Tile之间的遮挡存在问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/746209/201901/746209-20190131212048791-1478187435.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;解决tile间的遮挡问题&quot;&gt;解决Tile间的遮挡问题&lt;/h2&gt;
&lt;p&gt;上面Tile间的遮挡问题，我通过之前提到的&lt;a href=&quot;https://forum.unity.com/threads/isometric-tilemap-sorting-issues.554914/&quot;&gt;Unity英文社区的参考链接&lt;/a&gt;解决了。&lt;/p&gt;
&lt;p&gt;操作就是通过Edit &amp;gt; Settings &amp;gt; Graphics，修改Transparency Sort Mode为Custom Axis，并将其值设为X：0，Y：1，Z：-0.49。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/746209/201901/746209-20190131212649049-417875676.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;不同z-position下tile的绘制&quot;&gt;不同Z Position下Tile的绘制&lt;/h2&gt;
&lt;p&gt;上面我们实现了基本地形的绘制，现在我们需要在地形上面绘制房子。&lt;/p&gt;
&lt;p&gt;之前我们绘制Tile时，Tile Palette的Z Position为0。&lt;/p&gt;
&lt;p&gt;现在我们需要在地形上绘制房子，那么就需要调高Z Position,将Z Position设为1。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/746209/201901/746209-20190131212806510-1951417232.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;绘制后发现遮挡顺序不对，咱们的Z Position为1的房子竟然被Z Position为0的地形给遮挡了。&lt;/p&gt;
&lt;p&gt;到这里参考之前的帖子也没办法处理这个事，没有任何文档和资料有关于这个事情的处理。&lt;/p&gt;
&lt;p&gt;我这里也纠结了很久，搞了一两个晚上都没搞出来，最后直接加了几个QQ群，把问题甩在那里，然后打Dota2去了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/vvjiang/996881/o_webwxgetmsgimg.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而果然指望别人也不怎么靠谱，结果最后还是自己去研究。&lt;/p&gt;
&lt;p&gt;虽然不清楚内部工作原理，但是按照排除法去想了一下相关的几个设置点，问题应该就是出现在透明度排序那里。&lt;/p&gt;
&lt;p&gt;于是调节XYZ这三个值，发现将Z进一步调小到-26后就没有问题了，虽然不知道发生了什么，但是终究是搞定了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/746209/201901/746209-20190131213632988-1413300419.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;不知道为什么最后一个那么大的坑在官方文档上完全没有提及，而且这个功能从这个角度来看，不像是完全做完了的样子。&lt;/p&gt;
&lt;p&gt;希望我的这篇博客对后来的趟坑者有用吧，当然如果有用也别忘了点个赞。&lt;/p&gt;
&lt;p&gt;如文中有谬误，还望不吝赐教。&lt;/p&gt;
&lt;p&gt;PS：&lt;/p&gt;
&lt;p&gt;自己建了一个QQ群328544641，用于Unity2D技术的学习交流群，里面暂时就我一个人。&lt;/p&gt;
&lt;p&gt;如果您对Unity的2D技术有兴趣，可以互相学习交流。&lt;/p&gt;
&lt;p&gt;人不在多，只希望进群的人可以得到自己想要的答案，也同样希望您能在了解的情况下给予一些Unity菜鸡帮助，比如身为菜鸡的我。&lt;/p&gt;
</description>
<pubDate>Thu, 31 Jan 2019 13:49:00 +0000</pubDate>
<dc:creator>韩子卢</dc:creator>
<og:description>前言 最近出于兴趣想自己做一个2D的游戏，因为有着C 的基础，所以决定使用Unity3D来做。 之前对于Unity3D其实了解不多，不过看了一些Unity3D的视频和官方文档后，暂时做起来也没遇到什么</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/vvjiang/p/10344007.html</dc:identifier>
</item>
<item>
<title>C++STL特殊容器stack - 回首不知身是客</title>
<link>http://www.cnblogs.com/cloudplankroader/p/10344203.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cloudplankroader/p/10344203.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;stack的基本性能&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;stack准确的说并不是STL framework所提供的容器，而是一个为了满足特殊需求而设计的容器。属于&lt;strong&gt;容器适配器&lt;/strong&gt;（container adapter），它提供了简单而清晰的接口满足我们对数据结构堆栈的需求。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于stack（也称LIFO，后进先出），我们可以使用 push（）将任意数量的元素放入stack内，也可以使用 pop（）将元素以其插入的反序从容器中移除。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1520224/201901/1520224-20190131205708772-2047046534.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上图可以很形象的看出，我们的压入顺序是A-&amp;gt;B，待到我们弹出时的顺序就变成了B-&amp;gt;A。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;1.包含头文件&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;1&lt;/span&gt; #include&amp;lt;stack&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2.在头文件&amp;lt;stack&amp;gt;中，class stack 定义如下&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;1&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; template &amp;lt;&lt;span&gt;typename T,
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;           typename Container = deque&amp;lt;T&amp;gt;&amp;gt;
&lt;span&gt;5&lt;/span&gt;         &lt;span&gt;class&lt;/span&gt;&lt;span&gt; stack;
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;第一个template参数代表元素类型，带有默认值的第二个template参数用来定义stack内部存放元素的实际容器，&lt;strong&gt;默认为deque&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;很多人问为什么不用vector，具体原因可能是dequ有移除元素时会自动释放内存，并且不必在重新分配reallocation时复制全部元素的优点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.我们可以&lt;strong&gt;自定义stack的内部容器&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;stack的实现只是很单纯的把各项操作转化为内部容器的对应调用，事实上，你可以使用任何sequence容器支持stack，只要它们提供函数：back()、push_back()、pop_back。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;举个栗子&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;1&lt;/span&gt; stack&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; st;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义一个int类型内部为deque的stack&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; stack&amp;lt;&lt;span&gt;int&lt;/span&gt;,vector&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&amp;gt; st; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义一个int类型内部为vector的stack&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;1.&lt;strong&gt;核心接口成员函数&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;1&lt;/span&gt; st.push();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将一个元素放入stack内&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; st.top();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回stack内的“下一个”元素&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; st.pop();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从stack中移除元素&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;注意，pop弹出栈顶元素但不返回它，top返回栈顶元素但不移除它。两者在stack为空时使用会造成不明确的行为，所以在使用前可以采用 empty() 来检验stack是否为空&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.常用函数&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;1&lt;/span&gt; st.size();  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回stack内元素数量&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; st.empty(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回容器是否为空&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;3.comparison的重载&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;stack支持两个相同类型间的比较(比较原则是字典序),&lt;strong&gt;从栈底元素开始比较&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;comparison可以是下列任何运算：==、 !=、 &amp;gt;=、 &amp;lt;=、 &amp;gt;、 &amp;lt;。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;本文主要针对的是竞赛方向的stack使用，没有涉及更深度的使用，若有错误，请提出指正。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果能帮助到您，我会非常开心QWQ&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2019-01-31&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 31 Jan 2019 13:37:00 +0000</pubDate>
<dc:creator>回首不知身是客</dc:creator>
<og:description>stack的基本性能 stack准确的说并不是STL framework所提供的容器，而是一个为了满足特殊需求而设计的容器。属于容器适配器（container adapter），它提供了简单而清晰的接</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cloudplankroader/p/10344203.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core 打造一个简单的图书馆管理系统（六）图书信息的增删改查 - NanaseRuri</title>
<link>http://www.cnblogs.com/gokoururi/p/10344016.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gokoururi/p/10344016.html</guid>
<description>&lt;p&gt;&amp;#13;
                                    &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;modal&quot;&gt;&lt;span aria-hidden=&quot;true&quot;&gt;×&lt;/span&gt;&lt;span class=&quot;sr-only&quot;&gt;Close&lt;/span&gt;&lt;/button&gt;&amp;#13;
                                    &lt;h4 class=&quot;modal-title&quot;&gt;&amp;#13;
                                        请完成人机识别验证&amp;#13;
                                    &lt;/h4&gt;&amp;#13;
                                &lt;/p&gt;
                                &lt;div class=&quot;modal-body&quot; readability=&quot;33&quot;&gt;
                                    
                                    &lt;p&gt;&amp;#13;
                                        &lt;span id=&quot;geetestLoading&quot;&gt; 验证码组件加载中,请稍后...&lt;/span&gt;&amp;#13;
                                    &lt;/p&gt;
                                &lt;/div&gt;
                            </description>
<pubDate>Thu, 31 Jan 2019 13:30:00 +0000</pubDate>
<dc:creator>NanaseRuri</dc:creator>
<dc:format>text/html</dc:format>
<dc:identifier>https://passport.cnblogs.com/user/signin?ReturnUrl=https%3A%2F%2Fwww.cnblogs.com%2Fgokoururi%2Fp%2F10344016.html&amp;AspxAutoDetectCookieSupport=1</dc:identifier>
</item>
<item>
<title>Ajax之跨域请求 - W的一天</title>
<link>http://www.cnblogs.com/12345huangchun/p/10339812.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/12345huangchun/p/10339812.html</guid>
<description>&lt;h2&gt;　　一、引子&lt;/h2&gt;
&lt;p&gt;　　我现在开启了两个django项目，分别叫Demo1和Demo2，Demo1中有一个路径‘http://127.0.0.1:8000/index/’,对应的视图是index视图返回一个index页面，页面中只有一个button按钮，按钮绑定了一个单击事件，点击之后会发送一个ajax请求，请求的路径为‘http://127.0.0.1:8001/ajax/’，Demo1的ip和端口号是：‘http://127.0.0.1:8000/’，Demo2的ip和端口号是：‘http://127.0.0.1:8001/’。前面一段描述就是在Demo1项目的一个页面向Demo2项目发送一个ajax请求，在Demo2有对应的路径和视图来处理请求，并返回值。我们运行一下。报错如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519076/201901/1519076-20190130172431293-973599588.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这就是一个已拦截的跨域请求的错误，错误内容是CORS头少“Access-Control-Allow-Origin”。这就是我们用ajax发送一个跨域请求出现的错误，这就是今天我要处理的一个问题。&lt;/p&gt;
&lt;h2&gt;　　二、同源策略&lt;/h2&gt;
&lt;p&gt;　　同源策略（Same origin policy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能就会受到影响，可以说web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。&lt;/p&gt;
&lt;p&gt;同源策略，它是由Netscape提出的一个著名的安全策略。现在所有支持JavaScript的浏览器都会用这个策略。所谓的同源，即指：域名、端口、协议同时相同。比如说你用ajax发请求时，会检查你发送的请求是否发送路径是否ajax所在的JavaScript属于同源，即是两者的ip、端口、协议相同。如果不是同源，浏览器就会报错，提示拒绝访问。&lt;/p&gt;
&lt;p&gt;　　想要实现用ajax发送跨域请求有两种方式，一是jsonp，而是cors。&lt;/p&gt;
&lt;h2&gt;　　三、基于JSONP的ajax跨域请求&lt;/h2&gt;
&lt;h3&gt;　　1，版本1&lt;/h3&gt;
&lt;p&gt;　　我们在用script引入js代码，有时用的是网上路径，意思就是在我们的项目去请求其他项目的，如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519076/201901/1519076-20190130194226500-169240586.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这种情况下是可以请求成功的，于是，我们可以运用这一功能，给button按钮绑定事件，事件的功能是创建一个script标签，然后添加到页面上，这样当我们点击button按钮就会发送一个跨域请求，而且还是允许的。&lt;/p&gt;
&lt;p&gt;　　Demo1项目index.html页面上添加js代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function get_ele_script(url){
            var ele_script=$('&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
            ele_script.attr(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,url);
            ele_script.attr(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ele_script&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
            $(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).append(ele_script);
            $(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#ele_script&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).remove()
        }
 $(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.cli&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).click(function () {
            get_ele_script(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;127.0.0.1:8001/ajax/')&lt;/span&gt;
&lt;span&gt;        })&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这样就成功用点击事件发送了一个跨域请求，在Demo2的视图中，有返回值，但如果我不定义返回的值，HTML文件就会报没有定义的错误，而且视图返回的值在前端页面是以变量的形式显示。&lt;/p&gt;
&lt;p&gt;　　Demo2项目的视图：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; ajax(request):
    dic&lt;/span&gt;={&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;zhnag&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:46&lt;span&gt;}
    dic_json&lt;/span&gt;=&lt;span&gt;json.dumps(dic)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; HttpResponse(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;f(%s)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;%dic_json)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　此时，我们就应该在HTML文件中定义f()&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function f(params) {
            console.log(params);
            console.log(typeof params);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这样，当我们点击button时，会往Demo2发送一个请求，Demo2会返回带参数的f(),由于已经定义了f()函数，所以当返回时会执行这个函数，这种方法就实现了发送跨域请求，然后接受返回值，并对返回值进行处理。&lt;/p&gt;
&lt;h3&gt;　　2，版本2&lt;/h3&gt;
&lt;p&gt;　　其实版本1在Demo2项目中把返回的函数名写死了，如果照版本1，所有来反问Demo2的浏览器都会得到一个叫f()的函数，我们在声明的时候也只能写成f()。其实我们可以这样在请求的时候把我们定义的函数名一起发过去，让他就给我返回我发送过去的函数，这样，我们定义函数名就可以随意了。&lt;/p&gt;
&lt;p&gt;　　Demo1项目的index.html页面上就应这样写：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function f(params) {
            console.log(params);
            console.log(typeof params);
        }
$('.cli').click(function () {
            get_ele_script('http://127.0.0.1:8001/ajax/?callbacks=f')&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　Demo2项目的视图：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; ajax(request):
    &lt;/span&gt;&lt;span&gt;a=request.GET.get('callbacks')
    dic={'name':'zhnag','age':46}
    dic_json=json.dumps(dic)
    return HttpResponse('%s(%s)'%(a,dic_json))&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　3，版本3&lt;/h3&gt;
&lt;p&gt;　　上面两个版本就没有基于ajax请求，这个版本就基于ajax发送跨域请求。&lt;/p&gt;
&lt;p&gt;　　Demo1项目下的index.html页面上：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function f(params) {
            console.log(params);
            console.log(typeof params);
        }&lt;/span&gt;&lt;span&gt;
$(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.cli&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).click(function () {
            $.ajax({
                url:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;127.0.0.1:8001/ajax/callbacks=f',&lt;/span&gt;
&lt;span&gt;                type:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;GET&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                dataType:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;jsonp&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;
            })
        })&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　Demo2项目的视图：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; ajax(request):
    &lt;/span&gt;&lt;span&gt;a=request.GET.get('callbacks')
    dic={'name':'zhnag','age':46}
    dic_json=json.dumps(dic)
    print(type(dic_json))
    return HttpResponse('%s(%s)'%(a,dic_json))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　4,版本4&lt;/h3&gt;
&lt;p&gt;　　这也是基于ajax发送的跨域请求，只是比上一版本更简单。&lt;/p&gt;
&lt;p&gt;　　Demo1项目下的index.html：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function f(params) {
            console.log(params);
            console.log(typeof params);
        }
$('.cli').click(function () {
            $.ajax({
                url:'http://127.0.0.1:8001/ajax/',
                type:'GET',
                dataType:'jsonp',
                jsonp:'callbacks',
                jsonpCallback:'f'
            })
        })&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　Demo2项目的视图：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def ajax(request):
    a&lt;/span&gt;=request.GET.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;callbacks&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    dic&lt;/span&gt;={&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;zhnag&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:46&lt;span&gt;}
    dic_json&lt;/span&gt;=&lt;span&gt;json.dumps(dic)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(type(dic_json))
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; HttpResponse(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%s(%s)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;%(a,dic_json))
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　5，版本5（终极版本）&lt;/h3&gt;
&lt;p&gt;　　基于ajax的跨域请求，并把返回值给ajax的success。&lt;/p&gt;
&lt;p&gt;　　Demo1项目下的index.html:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$('.cli').click(function () {
            $.ajax({
                url:'http://127.0.0.1:8001/ajax/',
                type:'GET',
                dataType:'jsonp',
                jsonp:'callbacks',
                success:function (data) {
                    console.log(data)
                }
            })
        })&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　Demo2项目下的视图：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; ajax(request):
    a&lt;/span&gt;=request.GET.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;callbacks&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    dic&lt;/span&gt;={&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;zhnag&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:46&lt;span&gt;}
    dic_json&lt;/span&gt;=&lt;span&gt;json.dumps(dic)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; HttpResponse(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%s(%s)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;%(a,dic_json))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这个版本就比较简单，书写方便&lt;/p&gt;
&lt;h2&gt;　　四、基于CORS的ajax跨域请求&lt;/h2&gt;
&lt;p&gt;　　最开始，我们讲的报错是：CORS头少：‘Access-Control-Allow-Origin’，既然少一个，我们就加一个，就可以了，其实这种方式才是最常用。&lt;/p&gt;
&lt;p&gt;　　Demo1项目下的index.html:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$('.cli').click(function () {
            $.ajax({
                url:'http://127.0.0.1:8001/ajax/',
                type:'get',
                data:{'a':1},
                success:function (res) {
                    console.log(res)
                }
            })
        })&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　Demo2项目下的视图：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; ajax(request):
    dic &lt;/span&gt;= {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;zhnag&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 46&lt;span&gt;}
    http&lt;/span&gt;=&lt;span&gt;HttpResponse(json.dumps(dic))
    http[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Access-Control-Allow-Origin&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://127.0.0.1:8000&lt;/span&gt;&lt;span&gt;'     #这相当于加了一个白名单，对于‘http://127.0.01:8000’的跨域请求就允许通行&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; http
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Thu, 31 Jan 2019 12:58:00 +0000</pubDate>
<dc:creator>W的一天</dc:creator>
<og:description>一、引子 我现在开启了两个django项目，分别叫Demo1和Demo2，Demo1中有一个路径‘http://127.0.0.1:8000/index/’,对应的视图是index视图返回一个inde</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/12345huangchun/p/10339812.html</dc:identifier>
</item>
<item>
<title>mysql优化 | 存储引擎，建表，索引，sql的优化建议 - 叫我明羽</title>
<link>http://www.cnblogs.com/cmyxn/p/10343976.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cmyxn/p/10343976.html</guid>
<description>&lt;p&gt;个人对于选择存储引擎，建表，建索引，sql优化的一些总结，给读者提供一些参考意见&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;推荐访问我的个人网站，排版更好看： &lt;a href=&quot;https://chenmingyu.top/mysql-optimize/&quot; class=&quot;uri&quot;&gt;https://chenmingyu.top/mysql-optimize/&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;存储引擎&quot;&gt;存储引擎&lt;/h4&gt;
&lt;p&gt;mysql中查看支持的引擎的sql：&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;show engines; &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190131203328528.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NzgzMDk1,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;日常工作中使用较多的存储引擎对比：InnoDB，MyISAM&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;存储限制&lt;/td&gt;
&lt;td&gt;64T&lt;/td&gt;
&lt;td&gt;256T&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;支持事务&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;支持索引&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;支持全文索引&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;支持数据缓存&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;支持外键&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;支持Hash索引&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h5 id=&quot;innodb&quot;&gt;innodb&lt;/h5&gt;
&lt;p&gt;支持提交、回滚和崩溃恢复能力的事物安全（ACID），支持行锁，支持外键完整性约束&lt;/p&gt;
&lt;p&gt;适合场景&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;需要事务处理&lt;/li&gt;
&lt;li&gt;表数据量大，高并发操作&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;myisam&quot;&gt;MyISAM&lt;/h5&gt;
&lt;p&gt;MyISAM存储引擎提供了高速检索和存储的能力，支持全文索引&lt;/p&gt;
&lt;p&gt;适合场景&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;很多count计算的&lt;/li&gt;
&lt;li&gt;查询非常频繁的&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其余几种存储引擎&lt;/p&gt;
&lt;h5 id=&quot;memory引擎&quot;&gt;MEMORY引擎&lt;/h5&gt;
&lt;p&gt;数据只保存在内存中，因为是在内存中，拥有极高的插入，更新，查询的效率，但是重启后数据都会丢失，表级锁，并发性能低。&lt;/p&gt;
&lt;h5 id=&quot;merge引擎&quot;&gt;MERGE引擎&lt;/h5&gt;
&lt;p&gt;merge表是一组MyISAM表的组合，所以merge表是没有数据的，对这个表的操作实际上是操作内部的MyISAM表，将多个MyISAM表合并适合做一些报表之类的操作。&lt;/p&gt;
&lt;h5 id=&quot;archive引擎&quot;&gt;ARCHIVE引擎&lt;/h5&gt;
&lt;p&gt;仅支持插入和查询，使用zlib压缩库，在记录被请求的时候实时压缩，不支持事务，支持行级锁，适合存储大量的日志数据。&lt;/p&gt;
&lt;p&gt;个人是推荐Innodb引擎的，公司部门里也是规定新建表的时候必须使用Innodb引擎，Innodb引擎较MyISAM引擎可以提供更多的功能，不是很实时的查询场景可以使用缓存，近实时的查询可以使用es，当然了这只是个人看法，针对不同的场景选择不同的存储引擎还是很有必要滴。所以在知道不同存储引擎的特性之后，才可以根据不同业务需求选择合适的存储引擎。&lt;/p&gt;
&lt;h4 id=&quot;建表原则&quot;&gt;建表原则&lt;/h4&gt;
&lt;h5 id=&quot;在建表的时候尽量遵循以下原则&quot;&gt;在建表的时候尽量遵循以下原则&lt;/h5&gt;
&lt;ol readability=&quot;14&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;尽量选择小的数据类型，数据类型选择上尽量tinyint(1字节)&amp;gt;smallint(2字节)&amp;gt;int(4字节)&amp;gt;bigint(8字节)，比如逻辑删除yn字段上（1代表可用，0代表）就可以选择tinyint（1字节）类型&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;尽量保证字段数据类型长度固定&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;尽量避免使用null，使用null的字段查询很难优化，影响索引，可以使用0或''代替&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;避免宽表，能拆分就拆分，一个表往往跟一个实体域对应，就像设计对象的时候一样，保持单一原则&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;尽量避免使用text和blob，如果非使用不可，将类型为text和blob的字段在独立成一张新表，然后使用主键对应原表&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;禁止使用float或double类型，这个坑超大，float或double存在精度问题，在进行比较或者加减操作的时候会丢失精度导致数据异常，凡是使用float或double类型的时候考虑下可不可使用int或bigint代替。比如金额，以元为单位使用float或double类型的时候，可以考虑以分为单位使用int，bigint类型代替，然后由业务代码进行单位的转换。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;每张表都加上createUser,createTime.updateUser,updateTime字段&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;起名字要规范，包括：库名，表名，字段名，索引名&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;查询频繁使用的字段记得加索引&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;尽量避免使用外键，不用外键约束，性能更高，然后数据的完整性有程序进行管理&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果表的数量可以预测到非常大，最好在建表的时候，就进行分表，不至于一时间数据量非常大导致效率问题&lt;/p&gt;
&lt;p&gt;未完待补充，，，&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;索引&quot;&gt;索引&lt;/h4&gt;
&lt;p&gt;索引是为来加速对表中数据行中的检索而创建的一种分散的数据结果,是针对表而建立的，它是由数据页面以外的索引页面组成,每个索引页中的行都含有逻辑指针,以便加速检索物理数据，创建索引的目的在于提高查询效率，innodb的索引都是基于b tree实现的&lt;/p&gt;
&lt;h5 id=&quot;索引类型&quot;&gt;索引类型&lt;/h5&gt;
&lt;p&gt;普通索引：最基本的索引，无限制&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;#方式1
CREATE INDEX idx_username ON sys_user(user_name(32)); 
#方式2
ALTER table sys_user ADD INDEX idx_username(user_name(32))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;主键索引：一个表只能有一个主键索引，且不能为空&lt;/p&gt;
&lt;p&gt;一般建表时同时创建了主键索引&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;CREATE TABLE `sys_user` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `user_name` varchar(32) DEFAULT NULL,
  `pass_word` varchar(32) DEFAULT NULL,
  `token` varchar(32) DEFAULT NULL,
  `token_expire` int(11) DEFAULT NULL,
  `yn` smallint(6) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=348007 DEFAULT CHARSET=utf8;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;唯一索引：与普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;CREATE UNIQUE INDEX idx_token ON sys_user(token_expire)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;组合索引：指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用组合索引时遵循最左前缀集合&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;ALTER TABLE sys_user ADD INDEX idx_un_te (user_name(32),token_expire); &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;全文索引：用来查找文本中的关键字，而不是直接与索引中的值相比较。只有char、varchar，text 列上可以创建全文索引&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;CREATE FULLTEXT INDEX idx_ ON sys_user(pass_word)&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;创建使用索引的原则&quot;&gt;创建使用索引的原则&lt;/h5&gt;
&lt;ol&gt;&lt;li&gt;索引的字段尽量要小，根据索引查询数据的快慢取决于b tree的高度，当数据量恒定的时候，字节越少，存的索引的数量就越多，树的高度就越会越低&lt;/li&gt;
&lt;li&gt;遵循索引的最左匹配原则&lt;/li&gt;
&lt;li&gt;注意使用like的时候尽量不要使用“%a%”，这样的不走索引，可以使用“a%”，走索引&lt;/li&gt;
&lt;li&gt;不要在索引的列上进行计算，比如 select * from sys_user where token_expire+1 = 10000，这样的语句 不会走有索引&lt;/li&gt;
&lt;li&gt;什么样的字段建索引，就是那种频繁在where，group by，order by中出现的列，最好加上索引&lt;/li&gt;
&lt;/ol&gt;&lt;h5 id=&quot;索引的缺点&quot;&gt;索引的缺点&lt;/h5&gt;
&lt;p&gt;虽然索引的可以提高查询的效率，但是在进行insert，update，和delete的时候会降低效率，因为在保存数据的同时也会去保存索引。&lt;/p&gt;
&lt;p&gt;不要在一个表里建过多的索引，问题跟上面一样，在操作数据的时候效率降低，而且数据量少的表要看情况建索引，如果建索引跟没建索引的效果差不多少的情况下就不要建索引了，如果是数据量大的表，就需要建索引去优化查询效率。&lt;/p&gt;
&lt;h5 id=&quot;explain分析sql&quot;&gt;explain分析sql&lt;/h5&gt;
&lt;p&gt;可以使用explain去分析sql的执行情况，比如&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;explain select * from sys_user where token_expire = 10000; &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190131203348270.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在阿里的开发手册中提到过，sql性能优化的标准：至少要达到range，要求ref级别，如果可以是consts最好&lt;/p&gt;
&lt;p&gt;说明一下，这里的级别指的就是上图的type字段：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;consts 是指单表中最多只有一个匹配行（主键或唯一索引）&lt;/li&gt;
&lt;li&gt;ref 指的是使用普通索引&lt;/li&gt;
&lt;li&gt;range 是指对索引进行范围查询&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;sql优化&quot;&gt;sql优化&lt;/h4&gt;
&lt;p&gt;关于sql语句的优化主要是两方面，一个是在建sql的时候需要注意的问题，另一个就是在发现有慢sql的时候可以根据不同情况进行分析，然后优化sql&lt;/p&gt;
&lt;h5 id=&quot;优化的建议&quot;&gt;优化的建议&lt;/h5&gt;
&lt;ol readability=&quot;5.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;查询的时候一定要记得使用limit进行限制&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;对于结果只需要一条数据的查询用limit 1进行限制&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;使用count(*)来统计行数或者使用count(主键)来查询，使用count(列)的时候，不会统计此列为null的情况&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;不要使用select * 来查数据，使用select 需要的列名，这样的方式去查询&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;使用join链接代替子查询&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;不要使用外键，外键的约束可以放在程序里解决&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;控制一下in操作的集合数量，不要太大了&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;针对慢查询使用explain去分析原因，然后优化sql，让其尽量走索引&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;上面说的四个方面就是我目前对于sql优化各个方面的注意事项，希望可以给大家提供一个参考，有问题的可以指出来，交流交流&lt;/p&gt;
</description>
<pubDate>Thu, 31 Jan 2019 12:41:00 +0000</pubDate>
<dc:creator>叫我明羽</dc:creator>
<og:description>个人对于选择存储引擎，建表，建索引，sql优化的一些总结，给读者提供一些参考意见 推荐访问我的个人网站，排版更好看： https://chenmingyu.top/mysql optimize/ 存储</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cmyxn/p/10343976.html</dc:identifier>
</item>
</channel>
</rss>