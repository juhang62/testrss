<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>一文带你了解爬虫 - 猪哥66</title>
<link>http://www.cnblogs.com/pig66/p/11080757.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pig66/p/11080757.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/pig66/p/10995446.html&quot;&gt;六月分享主题：爬虫&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/pig66/p/11013289.html&quot;&gt;HTTP详解&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/pig66/p/11059146.html&quot;&gt;网页结构简介&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;前段时间我妈突然问我：儿子，爬虫是什么？我当时既惊讶又尴尬，惊讶的是为什么我妈会对爬虫好奇？尴尬的是我该怎么给她解释呢？&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;一、爬虫介绍&lt;/h2&gt;
&lt;h3 id=&quot;1-&quot;&gt;1.爬虫是什么&lt;/h3&gt;
&lt;p&gt;网络爬虫(web crawler 简称爬虫)就是&lt;strong&gt;按照一定规则从互联网上抓取信息的程序&lt;/strong&gt;，既然是程序那和正常用户访问页面有何区别？爬虫与用户正常访问信息的区别就在于：用户是缓慢、少量的获取信息，而爬虫是&lt;strong&gt;大量&lt;/strong&gt;的获取信息。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190622203408822.jpg?&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里还需要注意的是：&lt;strong&gt;爬虫并不是Python语言的专利&lt;/strong&gt;，Java、Js、C、PHP、Shell、Ruby等等语言都可以实现，那为什么Python爬虫会这么火？我觉得相比其他语言做爬虫Python可能就是各种库完善点、上手简单大家都在用，社区自然活跃，而社区活跃促成Python爬虫慢慢变成熟，成熟又促使更多用户来使用，如此良性循环，所以Python爬虫相比其他语言的爬虫才更火。&lt;/p&gt;
&lt;p&gt;下面是一段hello world级别的Python爬虫，&lt;strong&gt;它等效于你在百度搜索关键字：python&lt;/strong&gt;。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190624215046139.jpg?&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;2-&quot;&gt;2.爬虫案例&lt;/h3&gt;
&lt;p&gt;既然爬虫是大量抓取网页，那是不是爬虫都是不好的呢？答案当然不是，可以说我们的日常上网已经离不开爬虫了，为什么这么说？下面我就为大家盘点几个爬虫日常应用：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;搜索引擎：如Google、百度、雅虎、搜狗、必应等等很多搜索引擎其本质就是一个（可能多个）巨大爬虫，这些搜索引擎工作原理是：&lt;strong&gt;页面收录-&amp;gt;页面分析-&amp;gt;页面排序-&amp;gt;响应关键字查询&lt;/strong&gt;，也就是说它会先把互联网上很多页面保存到服务器，然后分析网页内容建立关键字索引，最后用户输入关键字的时候去查询内容，然后根据相关性排序（百度害人的竞价排名毫无相关性可言），第一步的&lt;strong&gt;页面收录&lt;/strong&gt;就是爬虫，百度查看一个网站有多少网页被收录方法，百度输入：site:你想查询的网站，如：site:blog.csdn.net。&lt;img src=&quot;https://img-blog.csdnimg.cn/2019062221483572.jpg?&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/li&gt;
&lt;li&gt;抢票软件：很多人在吐槽12306卡，可你不知道12306几乎每天都相当于淘宝双11的流量，这谁受得了。为什么每天都是如此高的流量？答案自然是爬虫了，为什么抢票软件可以抢票？因为它在不断的刷新和监控是否有余票，大大小小这么多抢票app，访问量之高可想而知。之前很多公司都出过抢票插件，如：百度、360、金山、搜狗等等，后来都被铁道部约谈下线了，而现在又流行抢票app，为什么抢票app可以，插件就不可以？可能是因为管理和可控性的原因。&lt;/li&gt;
&lt;li&gt;惠惠购物助手：这是一款能进行多个网站比价并能知道最低价的一个网站，其工作原理也是通过大量爬虫爬取商品价格然后存储，这样就可以制作一个价格走势图，帮助你了解商品最低价。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190624224607887.jpg?&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;二、爬虫的价值&lt;/h2&gt;
&lt;p&gt;从上面举的几个例子来看，爬虫对整个互联网的价值真的无法估量，那对于小我而言，爬虫能给我们带来哪些价值？&lt;/p&gt;
&lt;h3 id=&quot;1-&quot;&gt;1.隐形的翅膀&lt;/h3&gt;
&lt;p&gt;如果你问我学完Python基础之后该学习什么技能？我会毫不犹疑的说爬虫，为什么是爬虫？&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;爬虫相对其他技能简单易学，且效果立即可见，会有一定的成就感&lt;/li&gt;
&lt;li&gt;爬虫可以说是其他技能的基石，因为他是数据的来源，现在这个时代谁有数据谁才能称王，所以会爬虫绝对会让你如虎添翼&lt;/li&gt;
&lt;li&gt;在国内，很多企业巴不得你啥都会，所以在应聘时，爬虫会是一个不错的加分项&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;2-&quot;&gt;2.看不见的商战&lt;/h3&gt;
&lt;p&gt;职场对话：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;老板：小明给你个重要任务。&lt;br/&gt;小明：就算996我也在所不辞（第一次接到老板的直接需求）！&lt;br/&gt;老板：你能不能搞到竞争对手的商品价格？&lt;br/&gt;小明：没问题（牛逼先吹出去），小事！&lt;br/&gt;老板：这可不是小事，只要你能持续获取竞品价格，我们就可以标价低于他们一点点，持续如此大家就知道我们的价格肯定是比他们低，这样大家就直接来我们这里购买商品了，到时候庆功宴上你就是最大功臣（先画个饼）。&lt;br/&gt;小明：老板牛逼，老板英明！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;3-&quot;&gt;3.会爬虫就可以创业&lt;/h3&gt;
&lt;p&gt;工作之后很多同学会利用上班空余时间，来做自己的东西或者项目，别看开始是一个小打小闹的东西，慢慢丰富将来也许会成为一款成熟的产品。&lt;/p&gt;
&lt;p&gt;而爬虫可以让你很轻松的实现自己的产品，做的好的话就可以创业。这里猪哥给大家列几个简单的创业项目，当然作为一个思维引导。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2019062315071250.png?&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;如果你想做一款好的产品，&lt;strong&gt;你需要从用户需求出发去思考&lt;/strong&gt;，做解决目前存在的问题的产品或者目前还没有的服务，也许你的产品就是下一个头条。&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;三、盗亦有道&lt;/h2&gt;
&lt;p&gt;爬虫既然如此强大而优秀，那是不是会了爬虫就可以为所欲为？&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;延伸话题：其实我内心一直有一个疑问：为什么互联网公司都偏爱用动植物来命名或作为logo？如：蚂蚁金服、天猫、菜鸟、金东狗、腾讯企鹅，百度的熊掌、搜狗、途牛、美团的袋鼠。。。真的是太多了，难道仅仅是因为好记？我认为好记是一个原因，其根本原因是受到编程行业的影响，你想想编程行业有多少动植物：Java（咖啡）、Python（蟒蛇）、Go（囊地鼠）、PHP（大象）、Linux（企鹅）、Perl（骆驼）、Mysql（海豚）等等，具体为什么编程行业喜欢用动植物这猪哥就不清楚，还请明白的同学留言告知大家！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;讲上面的延伸话题想表达的是，大自然世间万物，相生相克，衡而不祸！而爬虫也是如此，下面就为大家介绍一下约束爬虫的几个点。&lt;/p&gt;
&lt;h3 id=&quot;1-robots-&quot;&gt;1.robots协议&lt;/h3&gt;
&lt;p&gt;做过网站的同学也许知道，我们在建站的时候需要在网站根目录下放一个文件：&lt;strong&gt;robots.txt&lt;/strong&gt;，这个文件是干什么用的呢？&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;Robots协议，也称为爬虫协议、机器人协议等，其全称为“网络爬虫排除标准（Robots Exclusion Protocol）”。网站通过Robots协议告诉搜索引擎哪些页面可以抓取，哪些页面不能抓取。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;每个网站的根目录下都必须放置robots.txt文件，否则搜索引擎将不收录网站任何网页。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面我们以百度为例子，来看看百度的robots.txt文件：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190623184136652.jpg?&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;我们在百度robots协议的最下面，有这样一条：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;User-agent: *
Disallow: /
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;这表示除上面那些定义过的爬虫以外其他爬虫都不允许爬取百度任何东西！&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;2-&quot;&gt;2.法律&lt;/h3&gt;
&lt;p&gt;我们都知道在发起请求时User-agent是可以自定义的，也就是说我们可以绕过&lt;strong&gt;robots协议&lt;/strong&gt;和以User-agent来定义的反爬虫技术，所以&lt;strong&gt;robots协议&lt;/strong&gt;可能更像一个君子协议，那咱们国家有没有法律明文规定呢？我们来了解一下&lt;strong&gt;非法侵入计算机信息系统罪&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;第二百八十五条 非法侵入计算机信息系统罪：违反国家规定，&lt;strong&gt;侵入&lt;/strong&gt;前款规定以外的计算机信息系统或者采用其他技术手段，获取该计算机信息系统中存储、处理或者传输的数据，或者对该计算机信息系统实施非法控制，情节严重的，处三年以下有期徒刑或者拘役，并处或者单处罚金；情节特别严重的，处三年以上七年以下有期徒刑，并处罚金。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们可以看到重点信息：&lt;strong&gt;入侵计算机获取数据是违法的，也就是说爬虫技术本身是无罪的&lt;/strong&gt;，因为它是获取的公开信息，并未非法入侵计算机。但是如果你用爬取到的数据去从事商业化操作，那也许就构成了违法犯罪行为！&lt;/p&gt;
&lt;p&gt;给大家介绍下因爬虫而被判刑的案件：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;头条爬虫官司：&lt;a href=&quot;https://dwz.cn/qBBHc2fq&quot;&gt;https://dwz.cn/qBBHc2fq&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;酷米客公司官司：&lt;a href=&quot;https://dwz.cn/9IpAOHGB&quot;&gt;https://dwz.cn/9IpAOHGB&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;360和百度爬虫官司：&lt;a href=&quot;https://dwz.cn/RGRa3HJc&quot;&gt;https://dwz.cn/RGRa3HJc&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我发现这几起案件的通性有两点：1、公司性质。2、竞争对手。3、让人家找到线索。&lt;/p&gt;
&lt;p&gt;最后提醒大家：&lt;strong&gt;技术人，要守住自己的底线，违反国家法律法规的事情咱们坚决不能做！&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;3-&quot;&gt;3.反爬虫工程师&lt;/h3&gt;
&lt;p&gt;本来想采访一位携程反爬虫工程师，但是他说由于工作保密原因不便接受采访，所以只好尊重他的选择！&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;四、爬虫现状&lt;/h2&gt;
&lt;p&gt;之前猪哥说过互联网中有超过50%的流量来自爬虫，那我们就来简单聊聊目前爬虫的现状吧！&lt;/p&gt;
&lt;h3 id=&quot;1-&quot;&gt;1.技术&lt;/h3&gt;
&lt;p&gt;反爬虫几乎和爬虫同时诞生，它们是相爱相杀的连个技术，如果没有爬虫就没有反扒，而反扒技术又反过来又可以促进爬虫技术的发展。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;交互问题：各种变态的验证码充斥，尤其是12306，分分钟都想爆粗口，以后会越来越变态。。。&lt;/li&gt;
&lt;li&gt;js加密：最近很流行的一种反扒技术，会爬虫还得先学js，然后反爬虫工程师在js里面各种投毒，杀人诛心。。。&lt;/li&gt;
&lt;li&gt;IP限制：限制单个ip某段时间内访问次数&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;猪哥只介绍了一个反扒技术，当然都有现成的技术解决，但是作为爬虫员最重的并不是会使用工具或框架去应对反扒，而是能通过自己的思考和摸索破解反扒，因为反扒技术更新快且多样化。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190624180430724.jpg?&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;2-&quot;&gt;2.就业&lt;/h3&gt;
&lt;p&gt;就业的话主要从招聘、薪资、就业形势三个方面分析，我从网上查阅了一些资料，然后整理以图片形式提供给大家参考。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190624205537727.jpg?&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190624205603345.jpg?&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190624205623942.jpg?&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;数据来源：职友集：&lt;a href=&quot;https://dwz.cn/6PeU46QY&quot;&gt;https://dwz.cn/6PeU46QY&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;3-&quot;&gt;3.前景&lt;/h3&gt;
&lt;p&gt;现在很多人并不看好爬虫的前景，只搞爬虫的话技术只停留在当前水平，不再学习新知识，不再进步的话，那么是没有前途的，总有一天会被时代淘汰，其实其他职位也只如此。&lt;/p&gt;
&lt;p&gt;每个职业都是有一个横向和纵向的发展，也就是所谓的广度和深度的意思。第一、如果专研得够深，你的爬虫功能很强大，性能很高，扩展性很好等等，那么还是很有前途的。第二、爬虫作为数据的来源，后面还有很多方向可以发展，比如可以往大数据分析、数据展示、机器学习等方面发展，前途不可限量，现在作为大数据时代，你占据在数据的的入口，还怕找不到发展方向？所以爬虫也许只是一个起点一个跳板，是你走向人生巅峰的一个基石，总有一天你会迎娶白富美！&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190624223830801.jpg?&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;五、总结&lt;/h2&gt;
&lt;p&gt;本期为大家讲解什么是爬虫、爬虫的价值、爬虫的合法性以及爬虫的现状，下期猪哥将采访一位牛逼的爬虫工程师，让他为大家讲讲实际工作中的一些知识以及作为一名爬虫工程师该掌握和学习哪些技能，让大家能更近距离接触爬虫，如果你有想对他提问的问题，可以在下方留言哦，我会抽取一些问题让他为大家解答，问题不限&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
</description>
<pubDate>Tue, 25 Jun 2019 00:47:00 +0000</pubDate>
<dc:creator>猪哥66</dc:creator>
<og:description>六月分享主题：爬虫HTTP详解网页结构简介 前段时间我妈突然问我：儿子，爬虫是什么？我当时既惊讶又尴尬，惊讶的是为什么我妈会对爬虫好奇？尴尬的是我该怎么给她解释呢？ 一、爬虫介绍 1.爬虫是什么 网络</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/pig66/p/11080757.html</dc:identifier>
</item>
<item>
<title>SpringBoot启动流程分析（五）：SpringBoot自动装配原理实现 - 超级小小黑</title>
<link>http://www.cnblogs.com/hello-shf/p/11057861.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hello-shf/p/11057861.html</guid>
<description>&lt;p&gt;SpringBoot系列文章简介&lt;/p&gt;
&lt;p&gt;SpringBoot源码阅读辅助篇：&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;https://www.cnblogs.com/hello-shf/p/11006750.html&quot; target=&quot;_blank&quot;&gt;Spring IoC容器与应用上下文的设计与实现&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;SpringBoot启动流程源码分析：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/hello-shf/p/10976646.html&quot; target=&quot;_blank&quot;&gt;SpringBoot启动流程分析（一）：SpringApplication类初始化过程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/hello-shf/p/10992377.html&quot; target=&quot;_blank&quot;&gt;SpringBoot启动流程分析（二）：SpringApplication的run方法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/hello-shf/p/11018403.html&quot; target=&quot;_blank&quot;&gt;SpringBoot启动流程分析（三）：SpringApplication的run方法之prepareContext()方法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/hello-shf/p/11051476.html&quot; target=&quot;_blank&quot;&gt;SpringBoot启动流程分析（四）：IoC容器的初始化过程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/hello-shf/p/11057861.html&quot; target=&quot;_blank&quot;&gt;SpringBoot启动流程分析（五）：SpringBoot自动装配原理实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/hello-shf/p/11060546.html&quot; target=&quot;_blank&quot;&gt;SpringBoot启动流程分析（六）：IoC容器依赖注入&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;笔者注释版Spring Framework与SpringBoot源码git传送门：请不要吝啬小星星&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/hello-shf/spring-framework-5.0.8.RELEASE.git&quot; target=&quot;_blank&quot;&gt;spring-framework-5.0.8.RELEASE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/hello-shf/spring-boot-build.git&quot; target=&quot;_blank&quot;&gt;SpringBoot-2.0.4.RELEASE&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;自定义Starter：&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;https://www.cnblogs.com/hello-shf/p/10864977.html&quot; target=&quot;_blank&quot;&gt;SpringBoot应用篇（一）：自定义starter&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　上一篇文章，通过分析refresh()方法中的invokeBeanFactoryPostProcessors()方法，分析了IoC容器的初始化过程，这一节从代码上如下所示，接上一节ConfigurationClassParser类中的parse()方法，接着分析SpringBoot的自动装配原理。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ConfigurationClassParser类&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; parse(Set&amp;lt;BeanDefinitionHolder&amp;gt;&lt;span&gt; configCandidates) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.deferredImportSelectors = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (BeanDefinitionHolder holder : configCandidates) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         BeanDefinition bd =&lt;span&gt; holder.getBeanDefinition();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果是SpringBoot项目进来的，bd其实就是前面主类封装成的 AnnotatedGenericBeanDefinition（AnnotatedBeanDefinition接口的实现类）&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (bd &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; AnnotatedBeanDefinition) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;                parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (bd &lt;span&gt;instanceof&lt;/span&gt; AbstractBeanDefinition &amp;amp;&amp;amp;&lt;span&gt; ((AbstractBeanDefinition) bd).hasBeanClass()) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;                parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;                parse(bd.getBeanClassName(), holder.getBeanName());
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (BeanDefinitionStoreException ex) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt;&lt;span&gt; ex;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable ex) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BeanDefinitionStoreException(
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                     &quot;Failed to parse configuration class [&quot; + bd.getBeanClassName() + &quot;]&quot;&lt;span&gt;, ex);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 加载默认的配置---》（对springboot项目来说这里就是自动装配的入口了）&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    processDeferredImportSelectors();
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;2.1、@SpringBootApplication注解&lt;/h2&gt;
&lt;p&gt;　　对这个注解详细大家一定非常熟悉了。再来好好看看这个注解。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@Target(ElementType.TYPE)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;@Retention(RetentionPolicy.RUNTIME)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;@Documented
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;@Inherited
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;@SpringBootConfiguration
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;@EnableAutoConfiguration
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; @ComponentScan(excludeFilters =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;),
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;) })
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; SpringBootApplication {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    ...
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　接着看@EnableAutoConfiguration&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;@Target(ElementType.TYPE)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;@Retention(RetentionPolicy.RUNTIME)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;@Documented
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;@Inherited
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;@AutoConfigurationPackage
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; @Import(AutoConfigurationImportSelector.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; EnableAutoConfiguration {
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt;    ...
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　OK，看到@Import(AutoConfigurationImportSelector.class)导入了一个重要的类AutoConfigurationImportSelector。&lt;/p&gt;
&lt;h2&gt;2.2、AutoConfigurationImportSelector&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; AutoConfigurationImportSelector类
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;自动装配&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String[] selectImports(AnnotationMetadata annotationMetadata) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;isEnabled(annotationMetadata)) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; NO_IMPORTS;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     AutoConfigurationMetadata autoConfigurationMetadata =&lt;span&gt; AutoConfigurationMetadataLoader
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             .loadMetadata(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.beanClassLoader);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     AnnotationAttributes attributes =&lt;span&gt; getAttributes(annotationMetadata);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取所有的自动配置类（META-INF/spring.factories中配置的key为org.springframework.boot.autoconfigure.EnableAutoConfiguration的类）&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     List&amp;lt;String&amp;gt; configurations =&lt;span&gt; getCandidateConfigurations(annotationMetadata,
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;            attributes);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     configurations =&lt;span&gt; removeDuplicates(configurations);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;需要排除的自动装配类（springboot的主类上 @SpringBootApplication(exclude = {com.demo.starter.config.DemoConfig.class})指定的排除的自动装配类）&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;     Set&amp;lt;String&amp;gt; exclusions =&lt;span&gt; getExclusions(annotationMetadata, attributes);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    checkExcludedClasses(configurations, exclusions);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将需要排除的类从 configurations remove掉&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    configurations.removeAll(exclusions);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     configurations =&lt;span&gt; filter(configurations, autoConfigurationMetadata);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    fireAutoConfigurationImportEvents(configurations, exclusions);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; StringUtils.toStringArray(configurations);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　至于怎么从章节一中提到的ConfigurationClassParser类中的parse()===&amp;gt;processDeferredImportSelectors()==&amp;gt;AutoConfigurationImportSelector#selectImports()，篇幅有限不做过多介绍。&lt;/p&gt;
&lt;p&gt;　　 &lt;span class=&quot;cnblogs_code&quot;&gt;List&amp;lt;String&amp;gt; configurations = &lt;span&gt;getCandidateConfigurations(annotationMetadata, attributes);&lt;/span&gt;&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;　　我们来看一下getCandidateConfigurations()方法是怎么拿到这些自动配置类的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;// AutoConfigurationImportSelector类&lt;br/&gt;1&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; List&amp;lt;String&amp;gt;&lt;span&gt; getCandidateConfigurations(AnnotationMetadata metadata,
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;                                                  AnnotationAttributes attributes) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     List&amp;lt;String&amp;gt; configurations =&lt;span&gt; SpringFactoriesLoader.loadFactoryNames(
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;            getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader());
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;    Assert.notEmpty(configurations,
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;             &quot;No auto configuration classes found in META-INF/spring.factories. If you &quot;
&lt;span&gt;7&lt;/span&gt;                     + &quot;are using a custom packaging, make sure that file is correct.&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; configurations;
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　是不是又看到一个十分熟悉的方法loadFactoryNames()，没错，其实我们在分析SpringBoot启动流程的第一篇文章的时候，就已经分析了，SpringBoot是如何从META-INF/spring.factories中加载指定key的value的。ok，我们在这里再次回顾一遍。&lt;/p&gt;
&lt;p&gt;　　看看loadFactoryNames()方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;// SpringFactoriesLoader类&lt;br/&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; List&amp;lt;String&amp;gt; loadFactoryNames(Class&amp;lt;?&amp;gt;&lt;span&gt; factoryClass, @Nullable ClassLoader classLoader) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     String factoryClassName =&lt;span&gt; factoryClass.getName();
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　debug，看看要从META-INF/spring.factories中加载的类的key，如下图所示：org.springframework.boot.autoconfigure.EnableAutoConfiguration&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1635748/201906/1635748-20190620110132169-1919930608.png&quot; alt=&quot;&quot; width=&quot;1440&quot; height=&quot;357&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　回到selectImports()方法，debug，跳过List&amp;lt;String&amp;gt; configurations = getCandidateConfigurations(annotationMetadata,attributes);看一下configurations&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1635748/201906/1635748-20190620110832607-459749278.png&quot; alt=&quot;&quot; width=&quot;1438&quot; height=&quot;513&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　竟然有110个，那这些类都在哪里呢？看spring-boot-autoconfigure（当然在SpringBoot的工程中，也不止这一个依赖包中存在该配置文件）工程下的META-INF/spring.factories，我们能看到org.springframework.boot.autoconfigure.EnableAutoConfiguration定义了一大堆。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1635748/201906/1635748-20190620112155435-1992263130.png&quot; alt=&quot;&quot; width=&quot;1435&quot; height=&quot;633&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　其中还有一个com.demo.starter.config.DemoConfig是我自定义的starter。如下所示，我在测试工程中添加了自定义starter的依赖，所以SpringBoot就能扫描到。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &amp;lt;dependency&amp;gt;
&lt;span&gt;2&lt;/span&gt;     &amp;lt;groupId&amp;gt;com.demo&amp;lt;/groupId&amp;gt;
&lt;span&gt;3&lt;/span&gt;     &amp;lt;artifactId&amp;gt;demo-spring-boot-starter&amp;lt;/artifactId&amp;gt;
&lt;span&gt;4&lt;/span&gt;     &amp;lt;version&amp;gt;0.0.1-RELEASE&amp;lt;/version&amp;gt;
&lt;span&gt;5&lt;/span&gt; &amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1635748/201906/1635748-20190620112628588-919628111.png&quot; alt=&quot;&quot; width=&quot;1439&quot; height=&quot;399&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　继续看Set&amp;lt;String&amp;gt; exclusions = getExclusions(annotationMetadata, attributes);方法，该方法是排除主类上@SpringBootApplication注解上排除的自动装配的类。比如我们在该注解上排除我们自定义starter的自动装配的类，@SpringBootApplication(exclude = {com.demo.starter.config.DemoConfig.class})（当然也可以用excludeName进行排除），那么在后面的configurations.removeAll(exclusions);方法中将会删除我们的com.demo.starter.config.DemoConfig.class。&lt;/p&gt;
&lt;p&gt;　　configurations = filter(configurations, autoConfigurationMetadata);该行代码将会过滤掉不需要装配的类。过滤的逻辑有很多，比如我们常用的@ConditionXXX注解。如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@ConditionalOnBean:容器中有指定的Bean 
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;@ConditionalOnClass：当类路径下有指定的类
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;@ConditionalOnExpression:基于SpEL表达式作为判断条件  
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;@ConditionalOnJava:基于JVM版本作为判断条件  
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;@ConditionalOnJndi:在JNDI存在的条件下查找指定的位置  
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;@ConditionalOnMissingBean:当容器中没有指定Bean的情况下  
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;@ConditionalOnMissingClass:当类路径下没有指定的类
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;@ConditionalOnNotWebApplication:当前项目不是Web项目
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;@ConditionalOnProperty:配置文件中指定的属性是否有指定的值  
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;@ConditionalOnResource:类路径下是否有指定的资源  
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;@ConditionalOnSingleCandidate:当指定Bean在容器中只有一个，或者虽然有多个但是指定首选Bean
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; @ConditionalOnWebApplication:当前项目是Web项目的条件下
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　至于如何将这些类解析成BeanDefinition并注册进beanDefinition中的，和上一节讲的过程是一样的，不再赘述了。&lt;/p&gt;
&lt;p&gt;　　debug，跳过refresh()方法中的invokeBeanFactoryPostProcessors(beanFactory);方法。如下图所示，最终在beanFactory的BeanDefinitionMap中找到了自定义starter中的自动装配的类。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1635748/201906/1635748-20190620143556279-1040601205.png&quot; alt=&quot;&quot; width=&quot;1438&quot; height=&quot;637&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　综合本文和上一篇博文我们详细的梳理了IoC容器的初始化过程，到此IoC容器的初始化过程就结束了。&lt;/p&gt;


&lt;p&gt;　　原创不易，转载请注明出处。&lt;/p&gt;
&lt;p&gt;　　如有错误的地方还请留言指正。&lt;/p&gt;
</description>
<pubDate>Tue, 25 Jun 2019 00:45:00 +0000</pubDate>
<dc:creator>超级小小黑</dc:creator>
<og:description>SpringBoot系列文章简介 SpringBoot源码阅读辅助篇： Spring IoC容器与应用上下文的设计与实现 SpringBoot启动流程源码分析： 笔者注释版Spring Fr</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hello-shf/p/11057861.html</dc:identifier>
</item>
<item>
<title>高速输出-我们戏说缓存 - Ron.Liang</title>
<link>http://www.cnblogs.com/viter/p/11080160.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/viter/p/11080160.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;缓存要解决的问题是速度的问题，使用缓存的目的是为了减少对物理资源的访问，缓存大量的应用在软硬件的方方面面，从 CPU 到硬盘，就应用了 一级缓存、二级缓存，少部分高速缓存和大量低速缓存相结合，以提高 CPU 的计算能力，本文讲的主要是系统集成项目中的软件级别的缓存。&lt;/p&gt;
&lt;h5 id=&quot;缓存因果图&quot;&gt;缓存因果图&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/26882/201906/26882-20190624231056694-811798014.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;缓存在现代系统中的位置可以说是举足轻重，不是可有可无的问题了，而是怎么样用好的问题。怎么样讲好缓存这个话题，我思考了很久；如果是生搬硬套，我估计我肯定是凉凉，但要是上来就一顿代码操作，显得字太多，各位看官老爷也是要喷死我的（你们喷我算我赢）。各位看官就当故事随便看看就好了。&lt;/p&gt;
&lt;h2 id=&quot;客户端缓存&quot;&gt;客户端缓存&lt;/h2&gt;
&lt;p&gt;小明同学是一个大学生，每个月都会从爸爸那里领取生活费，由于爸爸给的生活费比较充裕，他就将一部分存了起来，周而复始，固定频率，这就是浏览器网页缓存；有一天，他接到爸爸的一个电话，说每个月给现金，我总是从银行拿也不方便，这样，咱给存银行卡里头，但是说好了，每个月1号的时候转1000块进去，3号之前可以领取，过时不侯。这就是 Cookie！小明说爸，这时间太紧迫了，我万一太过于专心学习忘记取钱那你儿子可是要饿死的吖，到时候没人给你养老送终事儿就大了。他爸爸经过深思熟虑后，决定放开取现时间的限制：行，你想什么时候取都成，就是别把卡给弄掉了就行。这就是LocalStorage/IndexDB，浏览器本地存储。如果银行卡掉了（浏览器重装，删库跑路），那还得找爸爸。&lt;/p&gt;
&lt;h2 id=&quot;服务器缓存&quot;&gt;服务器缓存&lt;/h2&gt;
&lt;p&gt;我们本次讨论的重点就是服务器缓存，对于小明的爸爸来说，每次给小明生活费之前都要到银行（数据库）去取钱出来，实在是太麻烦，不如提前把钱取出来准备好，每次取半年的钱出来放家里保险箱里（缓存），小明申请生活费的时候，直接给他就好了，节约时间效率又高，唯一的问题就是可能没那么安全，有可能被小偷把钱给偷了（缓存更新），然后就是半年时间过后再重新取一笔出来（缓存过期策略）。&lt;/p&gt;
&lt;h5 id=&quot;静态对象缓存&quot;&gt;静态对象缓存&lt;/h5&gt;
&lt;p&gt;静态对象也是一种特殊的缓存，静态对象作用于程序的整个生命周期中。需要注意的是，静态对象不会被 GC 回收 ，但是，如果静态对象被多次引用覆盖，那么之前的引用就有可能被 GC 回收。这就好像，小明在向爸爸领取生活费的时候，发现这次领到手的钱实在是太破旧了，都不好意思花出去，爸爸只好重新给了另一份。&lt;/p&gt;
&lt;h5 id=&quot;会话级缓存&quot;&gt;会话级缓存&lt;/h5&gt;
&lt;p&gt;在 Web 站点中，Session 是私有制的，各个 Session 之间是不会共享内存对象的，我们可以利用这个特性（在Asp.NET 时代常用）来暂时保存一些数据，例如用户购物车。还是以小明的需求为例子，小明下面还有一个妹妹，妹妹每个月都可以从爸爸那里多领取200元生活费，看到妹妹的资源这么好，小明愤愤不平，就像妹妹提议共享生活费，一家人一起用，多好吖！结果小明被爸爸揍了一顿，还收回了部分生活费。&lt;/p&gt;
&lt;h5 id=&quot;进程级别缓存&quot;&gt;进程级别缓存&lt;/h5&gt;
&lt;p&gt;基本上每个应用程序都具有本地缓存的能力，在 Asp.NET 中就有 MemoryCache ，也叫做进程级缓存（本地缓存），MemoryCache 和 分布式缓存的作用基本一致，所不同的是，本地缓存在应用程序停止后就会被释放掉，无法进行持久存储。就好像，小明在上大学期间，每个月都是生活费的，但是到暑假的时候就没有了（只能靠苦逼的暑期工挣点生活费啊）。&lt;/p&gt;
&lt;h2 id=&quot;分布式缓存&quot;&gt;分布式缓存&lt;/h2&gt;
&lt;p&gt;分布式缓存是个好东西，目前市场上出现了非常多的 nosql 数据库，都可用作缓存数据库，有时候，这些缓存数据库也提供持久化的能力。&lt;/p&gt;
&lt;p&gt;小明家的生活条件，在经过爸爸的不懈努力之后，生活水平渐渐提高了；有一天，爸爸对小明说：明仔吖，咱们家现在生活水平提高了，但是爸爸也越来越忙了，这样，如果我忙的时候，你问妈妈或者爷爷奶奶，也是可以拿到生活费的，咱们家这几位长辈手里都有钱了，这就是分布式缓存。&lt;/p&gt;
&lt;p&gt;但是分布式缓存又分为主从模式和集群模式，上面说的是集群模式，爸爸妈妈爷爷奶奶都可以拿钱，但是主从模式就不同了，主从模式就是钱都在爸爸手里，爸爸会把钱分给每个长辈一份，如果当时正好爸爸太忙了，没来得及分给妈妈，而小明又恰好问妈妈要生活费的话；妈妈只能对他说：小命呀，不好意思，妈妈这里也没有，你看看再问问其它人（客户端自己轮询），在问了妈妈、爷爷后（引用指向），终于知道，钱在爸爸那里，还得问爸爸要生活费。而且爸爸给其它人分钱的时候，还要占用他工作的时间。&lt;/p&gt;
&lt;h2 id=&quot;缓存雪崩&quot;&gt;缓存雪崩&lt;/h2&gt;
&lt;p&gt;缓存雪崩就是在某一个时刻，大量的缓存同时失效，造成数据库访问压力倍增。小明的爸爸最近压力比较大，因为收入减少了，他爸爸做的一个工程因为种种原因，货款只能分期付清，为了防止小明和妹妹同时申请生活费，造成资金周转困难；爸爸规定妹妹 1 号领取生活费，而小明在 5 号才能领取，小明心里的苦啊！&lt;/p&gt;
&lt;h2 id=&quot;缓存穿透&quot;&gt;缓存穿透&lt;/h2&gt;
&lt;p&gt;缓存穿透就是客户端总是尝试访问某个不存在的缓存，造成了每次都要取请求数据库读取数据。就好像小明吧，本来生活挺平静的，这刚上大二，就交了个女朋友，每个月的 1000 元生活费有点捉襟见肘，然后他又不能让爸爸知道，就在申请生活费的时候，每次都多要一点；这样就搞得爸爸很被动，本来计划得好好的，每个月都是 1000 块，这没次都不够，老是要跑银行取现金，终于在3个月后，爸爸发现了这个问题，想着儿子也大了，为了早日抱上孙子，就提高了小明的生活费，解决了每次都要跑银行的问题。&lt;/p&gt;
&lt;h2 id=&quot;缓存击穿&quot;&gt;缓存击穿&lt;/h2&gt;
&lt;p&gt;缓存击穿和缓存雪崩有点类似，其中不同的是；缓存雪崩是大量缓存 key 同时过期，而缓存击穿是大量的请求指向同一个缓存key，在这个 key 过期的时候，大量的请求涌入数据库中，造成了瞬间巨大的压力。举个栗子，因为小明交了女朋友的原因，他的生活费总是很快用完了；这种情况下，他也必须在 1 号的时候拿到生活费，不然就要吃土了，但是妈妈不允许他们一起取打扰爸爸，妈妈就指定了妹妹去问，在妹妹没有回来之前，小明只能等着，这就是为了解决缓存击穿而采用的策略：互斥锁(mutex key)&lt;/p&gt;
&lt;h2 id=&quot;运维级别缓存&quot;&gt;运维级别缓存&lt;/h2&gt;
&lt;p&gt;除了在应用程序中可以接入缓存以外，部分运维工具也集成了缓存服务，比如 Nginx、IIS。&lt;/p&gt;
&lt;h5 id=&quot;代理缓存&quot;&gt;代理缓存&lt;/h5&gt;
&lt;p&gt;Nginx 就是反向代理缓存，通过配置 Nginx 的缓存功能，在客户端请求到来到时候去加载缓存内容，用以提高响应能力，IIS 缓存又分为用户缓存和内核缓存。IIS 的输出缓存设置中，内核模式缓存不会对验证等用户信息进行检查，就好像小明等爸爸因为太赶时间，把钱放门卫大妈那里了，结果随便来了个学生就把小明等生活费给领走了，但是加上用户模式缓存后，就可以添加对身份的检查（请求标头），这样大妈就会知道谁是小明而不会随便把生活费交给别人了。&lt;/p&gt;
&lt;h5 id=&quot;网页静态化&quot;&gt;网页静态化&lt;/h5&gt;
&lt;p&gt;这种技术，在 Web1.0 时代非常的流行，我还记得那些个年头的网站开发项目中的要求，大部分项目的需求分析文档里面就明晃晃的写着：网页静态化！，而静态化常见于各种企业型、论坛帖子，在发表这些信息后就将其生成静态网页，客户端访问的时候，直接重定向到该静态网页，基本无需访问数据库。&lt;/p&gt;
&lt;h5 id=&quot;cdn-缓存&quot;&gt;CDN 缓存&lt;/h5&gt;
&lt;p&gt;CDN 缓存类似于上面提到的分布式缓存，但是实际上 CDN 缓存服务目前来说，主要说针对静态资源的，比如图片、视频、文件等等；大家经常可以看到，很多站点都号称提供了 CDN 加速服务，这些站点就像一个个代办信用卡的销售中介，实际上拿的都是银行的资源。&lt;/p&gt;
&lt;p&gt;更形象一些的说法，就是大家的钱都是中国人民银行发行的，我们可以通过各个不同的银行（CDN节点）查询我们的银行卡余额（我怎么可能有余额），在以前没有手机银行的时候，大家就可以到附近的银行去查询，然后取款（CDN缓存），如果附近的银行的柜员机没有现金，那么可能就需要到总行去取了（回源），如果发生了太多回源的事件，就会造成 CDN 的拥堵，所以 CDN 服务商也不敢打包票自己的基础服务没有问题，反正我是没见到哪家 CDN 服务商敢注明服务稳定性 100%，基本上都是 99.99%&lt;/p&gt;
&lt;h2 id=&quot;结束语&quot;&gt;结束语&lt;/h2&gt;
&lt;p&gt;缓存的理论知识，其实是非常宏大的，我这里只是抛砖引玉，希望能给入门的朋友带来一点帮助，如果你喜欢这篇文章，请给我点赞，让更多同学可以看到。&lt;/p&gt;
</description>
<pubDate>Tue, 25 Jun 2019 00:07:00 +0000</pubDate>
<dc:creator>Ron.Liang</dc:creator>
<og:description>缓存要解决的问题是速度的问题，使用缓存的目的是为了减少对物理资源的访问，缓存大量的应用在软硬件的方方面面</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/viter/p/11080160.html</dc:identifier>
</item>
<item>
<title>kubernetes高级之动态准入控制 - 周国通</title>
<link>http://www.cnblogs.com/tylerzhou/p/11080653.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tylerzhou/p/11080653.html</guid>
<description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/tylerzhou/p/10969041.html&quot;&gt;系列目录&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;动态准入控制器文档介绍了如何使用标准的,插件式的准入控制器.但是,但是由于以下原因,插件式的准入控制器在一些场景下并不灵活:&lt;/p&gt;
&lt;p&gt;准入钩子(Admission Webhooks 从1.9版本开始)解决了这些问题,它允许准入控制器独立于核心代码编译并且可以在运行时配置.&lt;/p&gt;
&lt;h2 id=&quot;什么是准入钩子&quot;&gt;什么是准入钩子&lt;/h2&gt;
&lt;p&gt;准入钩子是一种http回调,它接收准入请求然后做一些处理.你可以定义两种类型的准入钩子:&lt;a href=&quot;https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#validatingadmissionwebhook&quot;&gt;验证钩子&lt;/a&gt;和&lt;a href=&quot;https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#mutatingadmissionwebhook&quot;&gt;变换钩子&lt;/a&gt;.对于验证钩子,你可以拒绝请求以使自定义准入策略生效.对于变换钩子,你可以改变请求来使自定义的默认配置生效.&lt;/p&gt;
&lt;h2 id=&quot;体验准入钩子&quot;&gt;体验准入钩子&lt;/h2&gt;
&lt;p&gt;准入控制钩子是集群管制面板不可缺少的一部分.你在编写部署它们时必须要警惕.如果你想要编写/布置生产级别的准入控制器,请阅读以下&lt;a href=&quot;https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/#write-an-admission-webhook-server&quot;&gt;用户指南&lt;/a&gt;.下面我们将介绍如何快速体验准入钩子.&lt;/p&gt;
&lt;p&gt;准备工作:&lt;/p&gt;
&lt;ul readability=&quot;-0.48507462686567&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;确保你的kubernetes集群版本至少是1.9版本.&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;确保变换钩子(MutatingAdmissionWebhook) 和验证钩子(ValidatingAdmissionWebhook)已经启用.&lt;a href=&quot;https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#is-there-a-recommended-set-of-admission-controllers-to-use&quot;&gt;这里&lt;/a&gt;是推荐开启的一组准入控制器.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;编写一个准入钩子服务器admission-webhook-server&quot;&gt;编写一个准入钩子服务器(admission webhook server)&lt;/h2&gt;
&lt;p&gt;请参阅已经被kubernetes e2e测试验证通过的准入&lt;a href=&quot;https://github.com/kubernetes/kubernetes/blob/v1.13.0/test/images/webhook/main.go&quot;&gt;服务器钩子( admission webhook server)&lt;/a&gt;的实现.这个web钩子处理apiserver发出的&lt;code&gt;admissionReview&lt;/code&gt;请求,然后把结果封装成一个&lt;code&gt;admissionResponse&lt;/code&gt;返回给请求者.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;admissionReview&lt;/code&gt;请求可能有多个版本( v1beta1 或者 未来的v1),web钩子可以通过&lt;code&gt;admissionReviewVersions&lt;/code&gt;字段来定义它们接受的版本.apiserver会尝试使用列表中出现的,支持的第一个版本.如果列表中的版本没有一个是被支持的,验证将失败.如果webhook配置已经持久化,对web钩子的请求将会失败并被失败策略控制.&lt;/p&gt;
&lt;p&gt;示例钩子服务器(admission webhook server)把&lt;code&gt;ClientAuth&lt;/code&gt;字段留空,默认为&lt;code&gt;NoClientCert&lt;/code&gt;.这意味着钩子服务器不验证客户端身份.如果你需要使用&lt;code&gt;mutual TLS&lt;/code&gt;或者其它方法来验证客户端请求,请参考&lt;a href=&quot;https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/#authenticate-apiservers&quot;&gt;如何认证apiserver&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;部署准入控制服务&quot;&gt;部署准入控制服务&lt;/h2&gt;
&lt;p&gt;e2e测试的钩子服务器通过部署api(&lt;a href=&quot;https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.14/#deployment-v1beta1-apps)%E8%A2%AB%E9%83%A8%E7%BD%B2%E5%88%B0kubernetes%E9%9B%86%E7%BE%A4%E4%B8%AD.%E6%B5%8B%E8%AF%95%E9%A1%B9%E7%9B%AE%E4%B9%9F%E4%B8%BA%E9%92%A9%E5%AD%90%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%88%9B%E5%BB%BA%E4%BA%86%E4%B8%80%E4%B8%AA%E5%89%8D%E7%AB%AF%E6%9C%8D%E5%8A%A1&quot; class=&quot;uri&quot;&gt;https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.14/#deployment-v1beta1-apps)被部署到kubernetes集群中.测试项目也为钩子服务器创建了一个前端服务&lt;/a&gt;,&lt;a href=&quot;https://github.com/kubernetes/kubernetes/blob/v1.13.0/test/e2e/apimachinery/webhook.go#L227&quot;&gt;代码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;你也可以把你的钩子服务部署到集群外,你需要相应地更新&lt;a href=&quot;https://github.com/kubernetes/kubernetes/blob/v1.13.0/staging/src/k8s.io/api/admissionregistration/v1beta1/types.go#L247&quot;&gt;web钩子客户端配置&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;运行时配置准入web钩子&quot;&gt;运行时配置准入web钩子&lt;/h2&gt;
&lt;p&gt;你可以通过&lt;a href=&quot;https://github.com/kubernetes/kubernetes/blob/v1.13.0/staging/src/k8s.io/api/admissionregistration/v1beta1/types.go#L84&quot;&gt;ValidatingWebhookConfiguration&lt;/a&gt;和&lt;a href=&quot;https://github.com/kubernetes/kubernetes/blob/v1.13.0/staging/src/k8s.io/api/admissionregistration/v1beta1/types.go#L114&quot;&gt;MutatingWebhookConfiguration&lt;/a&gt;动态地配置哪些资源被哪些web钩子控制.&lt;/p&gt;
&lt;p&gt;以下是一个&lt;code&gt;validatingWebhookConfiguration&lt;/code&gt;配置的示例,变换钩子的配置也类似&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;apiVersion: admissionregistration.k8s.io/v1beta1
kind: ValidatingWebhookConfiguration
metadata:
  name: &amp;lt;name of this configuration object&amp;gt;
webhooks:
- name: &amp;lt;webhook name, e.g., pod-policy.example.io&amp;gt;
  rules:
  - apiGroups:
    - &quot;&quot;
    apiVersions:
    - v1
    operations:
    - CREATE
    resources:
    - pods
    scope: &quot;Namespaced&quot;
  clientConfig:
    service:
      namespace: &amp;lt;namespace of the front-end service&amp;gt;
      name: &amp;lt;name of the front-end service&amp;gt;
    caBundle: &amp;lt;pem encoded ca cert that signs the server cert used by the webhook&amp;gt;
  admissionReviewVersions:
  - v1beta1
  timeoutSeconds: 1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;scope&lt;/code&gt;字段指定了集群级别的资源(&quot;Cluster&quot;)或者名称空间级别的资源(&quot;Namespaced&quot;)需要匹配这些规则.&quot;*&quot;表示没有任何范围限制.&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;注意,如果使用&lt;code&gt;clientConfig.service&lt;/code&gt;,服务端证书必须对&lt;code&gt;&amp;lt;svc_name&amp;gt;.&amp;lt;svc_namespace&amp;gt;.svc&lt;/code&gt;有效.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;web钩子请求默认超时时间为30秒,但是从1.14版本开始,你可以自由设置超时时间但是建议设置较小的时间.如果web钩子请求超时,请求将被web钩子的失败策略处理.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当apiserver接收到一个匹配规则的请求,apiserver将会发送一个&lt;code&gt;admissionReview&lt;/code&gt;请求到&lt;code&gt;clientConfig&lt;/code&gt;配置的web钩子里.&lt;/p&gt;
&lt;p&gt;创建web钩子配置以后,系统将会经过一段时间使新配置生效.&lt;/p&gt;
&lt;h2 id=&quot;认证apiserver&quot;&gt;认证apiserver&lt;/h2&gt;
&lt;p&gt;如果你的准入web钩子需要认证,你可以配置apiserver使用基本认证(basic auth), bearer token 或者证书认证.需要三个步骤来完成认证配置.&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;当启动apiserver时,通过&lt;code&gt;--admission-control-config-file&lt;/code&gt;选项来指定准入控制配置文件的位置.&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;在准入控制配置文件里,指定变换控制器(MutatingAdmissionWebhook)和验证控制器(ValidatingAdmissionWebhook)从哪里读取证书.证书存储在&lt;code&gt;kubeConfig&lt;/code&gt;文件里(和kubectl使用的相同),字段名为&lt;code&gt;kubeConfigFile&lt;/code&gt;.下面是准入控制配置文件示例&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;apiVersion: apiserver.k8s.io/v1alpha1
kind: AdmissionConfiguration
plugins:
- name: ValidatingAdmissionWebhook
  configuration:
    apiVersion: apiserver.config.k8s.io/v1alpha1
    kind: WebhookAdmission
    kubeConfigFile: &amp;lt;path-to-kubeconfig-file&amp;gt;
- name: MutatingAdmissionWebhook
  configuration:
    apiVersion: apiserver.config.k8s.io/v1alpha1
    kind: WebhookAdmission
    kubeConfigFile: &amp;lt;path-to-kubeconfig-file&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里是&lt;code&gt;admissionConfiguration&lt;/code&gt;的&lt;a href=&quot;https://github.com/kubernetes/kubernetes/blob/v1.13.0/staging/src/k8s.io/apiserver/pkg/apis/apiserver/v1alpha1/types.go#L27&quot;&gt;schema定义&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在kubeConfig文件里,提供证书&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;apiVersion: v1
kind: Config
users:
# DNS name of webhook service, i.e., &amp;lt;service name&amp;gt;.&amp;lt;namespace&amp;gt;.svc, or the URL
# of the webhook server.
- name: 'webhook1.ns1.svc'
  user:
    client-certificate-data: &amp;lt;pem encoded certificate&amp;gt;
    client-key-data: &amp;lt;pem encoded key&amp;gt;
# The `name` supports using * to wildmatch prefixing segments.
- name: '*.webhook-company.org'
  user:
    password: &amp;lt;password&amp;gt;
    username: &amp;lt;name&amp;gt;
# '*' is the default match.
- name: '*'
  user:
    token: &amp;lt;token&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然,你需要设置web钩子服务器来处理这些认证.&lt;/p&gt;
</description>
<pubDate>Mon, 24 Jun 2019 23:58:00 +0000</pubDate>
<dc:creator>周国通</dc:creator>
<og:description>'系列目录' 动态准入控制器文档介绍了如何使用标准的,插件式的准入控制器.但是,但是由于以下原因,插件式的准入控制器在一些场景下并不灵活: 它们需要编译到kube apiserver里 它们仅在api</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tylerzhou/p/11080653.html</dc:identifier>
</item>
<item>
<title>基于 ZooKeeper 搭建 Hadoop 高可用集群 - 单人影</title>
<link>http://www.cnblogs.com/danrenying/p/11080640.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/danrenying/p/11080640.html</guid>
<description>&lt;nav&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/danrenying/p/11080640.html#一高可用简介&quot;&gt;一、高可用简介&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/danrenying/p/11080640.html#二集群规划&quot;&gt;二、集群规划&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/danrenying/p/11080640.html#三前置条件&quot;&gt;三、前置条件&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/danrenying/p/11080640.html#四集群配置&quot;&gt;四、集群配置&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/danrenying/p/11080640.html#五启动集群&quot;&gt;五、启动集群&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/danrenying/p/11080640.html#六查看集群&quot;&gt;六、查看集群&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/danrenying/p/11080640.html#七集群的二次启动&quot;&gt;七、集群的二次启动&lt;/a&gt;&lt;br/&gt;&lt;/nav&gt;&lt;h2 id=&quot;一高可用简介&quot;&gt;一、高可用简介&lt;/h2&gt;
&lt;p&gt;Hadoop 高可用 (High Availability) 分为 HDFS 高可用和 YARN 高可用，两者的实现基本类似，但 HDFS NameNode 对数据存储及其一致性的要求比 YARN ResourceManger 高得多，所以它的实现也更加复杂，故下面先进行讲解：&lt;/p&gt;
&lt;h3 id=&quot;高可用整体架构&quot;&gt;1.1 高可用整体架构&lt;/h3&gt;
&lt;p&gt;HDFS 高可用架构如下：&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/heibaiying/BigData-Notes/master/pictures/HDFS-HA-Architecture-Edureka.png&quot;/&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;em&gt;图片引用自：https://www.edureka.co/blog/how-to-set-up-hadoop-cluster-with-hdfs-high-availability/&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;HDFS 高可用架构主要由以下组件所构成：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Active NameNode 和 Standby NameNode&lt;/strong&gt;：两台 NameNode 形成互备，一台处于 Active 状态，为主 NameNode，另外一台处于 Standby 状态，为备 NameNode，只有主 NameNode 才能对外提供读写服务。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;主备切换控制器 ZKFailoverController&lt;/strong&gt;：ZKFailoverController 作为独立的进程运行，对 NameNode 的主备切换进行总体控制。ZKFailoverController 能及时检测到 NameNode 的健康状况，在主 NameNode 故障时借助 Zookeeper 实现自动的主备选举和切换，当然 NameNode 目前也支持不依赖于 Zookeeper 的手动主备切换。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Zookeeper 集群&lt;/strong&gt;：为主备切换控制器提供主备选举支持。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;共享存储系统&lt;/strong&gt;：共享存储系统是实现 NameNode 的高可用最为关键的部分，共享存储系统保存了 NameNode 在运行过程中所产生的 HDFS 的元数据。主 NameNode 和 NameNode 通过共享存储系统实现元数据同步。在进行主备切换的时候，新的主 NameNode 在确认元数据完全同步之后才能继续对外提供服务。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DataNode 节点&lt;/strong&gt;：除了通过共享存储系统共享 HDFS 的元数据信息之外，主 NameNode 和备 NameNode 还需要共享 HDFS 的数据块和 DataNode 之间的映射关系。DataNode 会同时向主 NameNode 和备 NameNode 上报数据块的位置信息。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;基于-qjm-的共享存储系统的数据同步机制分析&quot;&gt;1.2 基于 QJM 的共享存储系统的数据同步机制分析&lt;/h3&gt;
&lt;p&gt;目前 Hadoop 支持使用 Quorum Journal Manager (QJM) 或 Network File System (NFS) 作为共享的存储系统，这里以 QJM 集群为例进行说明：Active NameNode 首先把 EditLog 提交到 JournalNode 集群，然后 Standby NameNode 再从 JournalNode 集群定时同步 EditLog，当 Active NameNode 宕机后， Standby NameNode 在确认元数据完全同步之后就可以对外提供服务。&lt;/p&gt;
&lt;p&gt;需要说明的是向 JournalNode 集群写入 EditLog 是遵循 “过半写入则成功” 的策略，所以你至少要有3个 JournalNode 节点，当然你也可以继续增加节点数量，但是应该保证节点总数是奇数。同时如果有 2N+1 台 JournalNode，那么根据过半写的原则，最多可以容忍有 N 台 JournalNode 节点挂掉。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/heibaiying/BigData-Notes/master/pictures/hadoop-QJM-%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6.png&quot;/&gt;&lt;/div&gt;
&lt;h3 id=&quot;namenode-主备切换&quot;&gt;1.3 NameNode 主备切换&lt;/h3&gt;
&lt;p&gt;NameNode 实现主备切换的流程下图所示：&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/heibaiying/BigData-Notes/master/pictures/hadoop-namenode%E4%B8%BB%E5%A4%87%E5%88%87%E6%8D%A2.png&quot;/&gt;&lt;/div&gt;
&lt;ol readability=&quot;5.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;HealthMonitor 初始化完成之后会启动内部的线程来定时调用对应 NameNode 的 HAServiceProtocol RPC 接口的方法，对 NameNode 的健康状态进行检测。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;HealthMonitor 如果检测到 NameNode 的健康状态发生变化，会回调 ZKFailoverController 注册的相应方法进行处理。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果 ZKFailoverController 判断需要进行主备切换，会首先使用 ActiveStandbyElector 来进行自动的主备选举。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;ActiveStandbyElector 与 Zookeeper 进行交互完成自动的主备选举。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;ActiveStandbyElector 在主备选举完成后，会回调 ZKFailoverController 的相应方法来通知当前的 NameNode 成为主 NameNode 或备 NameNode。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;ZKFailoverController 调用对应 NameNode 的 HAServiceProtocol RPC 接口的方法将 NameNode 转换为 Active 状态或 Standby 状态。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;yarn高可用&quot;&gt;1.4 YARN高可用&lt;/h3&gt;
&lt;p&gt;YARN ResourceManager 的高可用与 HDFS NameNode 的高可用类似，但是 ResourceManager 不像 NameNode ，没有那么多的元数据信息需要维护，所以它的状态信息可以直接写到 Zookeeper 上，并依赖 Zookeeper 来进行主备选举。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/heibaiying/BigData-Notes/master/pictures/hadoop-rm-ha-overview.png&quot;/&gt;&lt;/div&gt;
&lt;h2 id=&quot;二集群规划&quot;&gt;二、集群规划&lt;/h2&gt;
&lt;p&gt;按照高可用的设计目标：需要保证至少有两个 NameNode (一主一备) 和 两个 ResourceManager (一主一备) ，同时为满足“过半写入则成功”的原则，需要至少要有3个 JournalNode 节点。这里使用三台主机进行搭建，集群规划如下：&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/heibaiying/BigData-Notes/master/pictures/hadoop%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4%E8%A7%84%E5%88%92.png&quot;/&gt;&lt;/div&gt;
&lt;h2 id=&quot;三前置条件&quot;&gt;三、前置条件&lt;/h2&gt;
&lt;h2 id=&quot;四集群配置&quot;&gt;四、集群配置&lt;/h2&gt;
&lt;h3 id=&quot;下载并解压&quot;&gt;4.1 下载并解压&lt;/h3&gt;
&lt;p&gt;下载Hadoop。这里我下载的是CDH版本Hadoop，下载地址为：http://archive.cloudera.com/cdh5/cdh/5/&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# tar -zvxf hadoop-2.6.0-cdh5.15.2.tar.gz &lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;配置环境变量&quot;&gt;4.2 配置环境变量&lt;/h3&gt;
&lt;p&gt;编辑&lt;code&gt;profile&lt;/code&gt;文件：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# vim /etc/profile&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;增加如下配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;export HADOOP_HOME=/usr/app/hadoop-2.6.0-cdh5.15.2
export  PATH=${HADOOP_HOME}/bin:$PATH&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行&lt;code&gt;source&lt;/code&gt;命令，使得配置立即生效：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# source /etc/profile&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;修改配置&quot;&gt;4.3 修改配置&lt;/h3&gt;
&lt;p&gt;进入&lt;code&gt;${HADOOP_HOME}/etc/hadoop&lt;/code&gt;目录下，修改配置文件。各个配置文件内容如下：&lt;/p&gt;
&lt;h4 id=&quot;hadoop-env.sh&quot;&gt;1. hadoop-env.sh&lt;/h4&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# 指定JDK的安装位置
export JAVA_HOME=/usr/java/jdk1.8.0_201/&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;core-site.xml&quot;&gt;2. core-site.xml&lt;/h4&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;configuration&amp;gt;
    &amp;lt;property&amp;gt;
        &amp;lt;!-- 指定namenode的hdfs协议文件系统的通信地址 --&amp;gt;
        &amp;lt;name&amp;gt;fs.defaultFS&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;hdfs://hadoop001:8020&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;property&amp;gt;
        &amp;lt;!-- 指定hadoop集群存储临时文件的目录 --&amp;gt;
        &amp;lt;name&amp;gt;hadoop.tmp.dir&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;/home/hadoop/tmp&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;property&amp;gt;
        &amp;lt;!-- ZooKeeper集群的地址 --&amp;gt;
        &amp;lt;name&amp;gt;ha.zookeeper.quorum&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;hadoop001:2181,hadoop002:2181,hadoop002:2181&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;property&amp;gt;
        &amp;lt;!-- ZKFC连接到ZooKeeper超时时长 --&amp;gt;
        &amp;lt;name&amp;gt;ha.zookeeper.session-timeout.ms&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;10000&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
&amp;lt;/configuration&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;hdfs-site.xml&quot;&gt;3. hdfs-site.xml&lt;/h4&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;configuration&amp;gt;
    &amp;lt;property&amp;gt;
        &amp;lt;!-- 指定HDFS副本的数量 --&amp;gt;
        &amp;lt;name&amp;gt;dfs.replication&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;3&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;property&amp;gt;
        &amp;lt;!-- namenode节点数据（即元数据）的存放位置，可以指定多个目录实现容错，多个目录用逗号分隔 --&amp;gt;
        &amp;lt;name&amp;gt;dfs.namenode.name.dir&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;/home/hadoop/namenode/data&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;property&amp;gt;
        &amp;lt;!-- datanode节点数据（即数据块）的存放位置 --&amp;gt;
        &amp;lt;name&amp;gt;dfs.datanode.data.dir&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;/home/hadoop/datanode/data&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;property&amp;gt;
        &amp;lt;!-- 集群服务的逻辑名称 --&amp;gt;
        &amp;lt;name&amp;gt;dfs.nameservices&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;mycluster&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;property&amp;gt;
        &amp;lt;!-- NameNode ID列表--&amp;gt;
        &amp;lt;name&amp;gt;dfs.ha.namenodes.mycluster&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;nn1,nn2&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;property&amp;gt;
        &amp;lt;!-- nn1的RPC通信地址 --&amp;gt;
        &amp;lt;name&amp;gt;dfs.namenode.rpc-address.mycluster.nn1&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;hadoop001:8020&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;property&amp;gt;
        &amp;lt;!-- nn2的RPC通信地址 --&amp;gt;
        &amp;lt;name&amp;gt;dfs.namenode.rpc-address.mycluster.nn2&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;hadoop002:8020&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;property&amp;gt;
        &amp;lt;!-- nn1的http通信地址 --&amp;gt;
        &amp;lt;name&amp;gt;dfs.namenode.http-address.mycluster.nn1&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;hadoop001:50070&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;property&amp;gt;
        &amp;lt;!-- nn2的http通信地址 --&amp;gt;
        &amp;lt;name&amp;gt;dfs.namenode.http-address.mycluster.nn2&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;hadoop002:50070&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;property&amp;gt;
        &amp;lt;!-- NameNode元数据在JournalNode上的共享存储目录 --&amp;gt;
        &amp;lt;name&amp;gt;dfs.namenode.shared.edits.dir&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;qjournal://hadoop001:8485;hadoop002:8485;hadoop003:8485/mycluster&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;property&amp;gt;
        &amp;lt;!-- Journal Edit Files的存储目录 --&amp;gt;
        &amp;lt;name&amp;gt;dfs.journalnode.edits.dir&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;/home/hadoop/journalnode/data&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;property&amp;gt;
        &amp;lt;!-- 配置隔离机制，确保在任何给定时间只有一个NameNode处于活动状态 --&amp;gt;
        &amp;lt;name&amp;gt;dfs.ha.fencing.methods&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;sshfence&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;property&amp;gt;
        &amp;lt;!-- 使用sshfence机制时需要ssh免密登录 --&amp;gt;
        &amp;lt;name&amp;gt;dfs.ha.fencing.ssh.private-key-files&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;/root/.ssh/id_rsa&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;property&amp;gt;
        &amp;lt;!-- SSH超时时间 --&amp;gt;
        &amp;lt;name&amp;gt;dfs.ha.fencing.ssh.connect-timeout&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;30000&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;property&amp;gt;
        &amp;lt;!-- 访问代理类，用于确定当前处于Active状态的NameNode --&amp;gt;
        &amp;lt;name&amp;gt;dfs.client.failover.proxy.provider.mycluster&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;org.apache.hadoop.hdfs.server.namenode.ha.ConfiguredFailoverProxyProvider&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;property&amp;gt;
        &amp;lt;!-- 开启故障自动转移 --&amp;gt;
        &amp;lt;name&amp;gt;dfs.ha.automatic-failover.enabled&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;true&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
&amp;lt;/configuration&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;yarn-site.xml&quot;&gt;4. yarn-site.xml&lt;/h4&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;configuration&amp;gt;
    &amp;lt;property&amp;gt;
        &amp;lt;!--配置NodeManager上运行的附属服务。需要配置成mapreduce_shuffle后才可以在Yarn上运行MapReduce程序。--&amp;gt;
        &amp;lt;name&amp;gt;yarn.nodemanager.aux-services&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;mapreduce_shuffle&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;property&amp;gt;
        &amp;lt;!-- 是否启用日志聚合(可选) --&amp;gt;
        &amp;lt;name&amp;gt;yarn.log-aggregation-enable&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;true&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;property&amp;gt;
        &amp;lt;!-- 聚合日志的保存时间(可选) --&amp;gt;
        &amp;lt;name&amp;gt;yarn.log-aggregation.retain-seconds&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;86400&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;property&amp;gt;
        &amp;lt;!-- 启用RM HA --&amp;gt;
        &amp;lt;name&amp;gt;yarn.resourcemanager.ha.enabled&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;true&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;property&amp;gt;
        &amp;lt;!-- RM集群标识 --&amp;gt;
        &amp;lt;name&amp;gt;yarn.resourcemanager.cluster-id&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;my-yarn-cluster&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;property&amp;gt;
        &amp;lt;!-- RM的逻辑ID列表 --&amp;gt;
        &amp;lt;name&amp;gt;yarn.resourcemanager.ha.rm-ids&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;rm1,rm2&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;property&amp;gt;
        &amp;lt;!-- RM1的服务地址 --&amp;gt;
        &amp;lt;name&amp;gt;yarn.resourcemanager.hostname.rm1&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;hadoop002&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;property&amp;gt;
        &amp;lt;!-- RM2的服务地址 --&amp;gt;
        &amp;lt;name&amp;gt;yarn.resourcemanager.hostname.rm2&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;hadoop003&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;property&amp;gt;
        &amp;lt;!-- RM1 Web应用程序的地址 --&amp;gt;
        &amp;lt;name&amp;gt;yarn.resourcemanager.webapp.address.rm1&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;hadoop002:8088&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;property&amp;gt;
        &amp;lt;!-- RM2 Web应用程序的地址 --&amp;gt;
        &amp;lt;name&amp;gt;yarn.resourcemanager.webapp.address.rm2&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;hadoop003:8088&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;property&amp;gt;
        &amp;lt;!-- ZooKeeper集群的地址 --&amp;gt;
        &amp;lt;name&amp;gt;yarn.resourcemanager.zk-address&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;hadoop001:2181,hadoop002:2181,hadoop003:2181&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;property&amp;gt;
        &amp;lt;!-- 启用自动恢复 --&amp;gt;
        &amp;lt;name&amp;gt;yarn.resourcemanager.recovery.enabled&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;true&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;property&amp;gt;
        &amp;lt;!-- 用于进行持久化存储的类 --&amp;gt;
        &amp;lt;name&amp;gt;yarn.resourcemanager.store.class&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;org.apache.hadoop.yarn.server.resourcemanager.recovery.ZKRMStateStore&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
&amp;lt;/configuration&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;mapred-site.xml&quot;&gt;5. mapred-site.xml&lt;/h4&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;configuration&amp;gt;
    &amp;lt;property&amp;gt;
        &amp;lt;!--指定mapreduce作业运行在yarn上--&amp;gt;
        &amp;lt;name&amp;gt;mapreduce.framework.name&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;yarn&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
&amp;lt;/configuration&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;slaves&quot;&gt;5. slaves&lt;/h4&gt;
&lt;p&gt;配置所有从属节点的主机名或IP地址，每行一个。所有从属节点上的&lt;code&gt;DataNode&lt;/code&gt;服务和&lt;code&gt;NodeManager&lt;/code&gt;服务都会被启动。&lt;/p&gt;
&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;hadoop001
hadoop002
hadoop003&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;分发程序&quot;&gt;4.4 分发程序&lt;/h3&gt;
&lt;p&gt;将Hadoop安装包分发到其他两台服务器，分发后建议在这两台服务器上也配置一下Hadoop的环境变量。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# 将安装包分发到hadoop002
scp -r /usr/app/hadoop-2.6.0-cdh5.15.2/  hadoop002:/usr/app/
# 将安装包分发到hadoop003
scp -r /usr/app/hadoop-2.6.0-cdh5.15.2/  hadoop003:/usr/app/&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;五启动集群&quot;&gt;五、启动集群&lt;/h2&gt;
&lt;h3 id=&quot;启动zookeeper&quot;&gt;5.1 启动ZooKeeper&lt;/h3&gt;
&lt;p&gt;分别到三台服务器上启动ZooKeeper服务：&lt;/p&gt;
&lt;pre class=&quot;ssh&quot;&gt;
&lt;code&gt; zkServer.sh start&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;启动journalnode&quot;&gt;5.2 启动Journalnode&lt;/h3&gt;
&lt;p&gt;分别到三台服务器的的&lt;code&gt;${HADOOP_HOME}/sbin&lt;/code&gt;目录下，启动&lt;code&gt;journalnode&lt;/code&gt;进程：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;hadoop-daemon.sh start journalnode&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;初始化namenode&quot;&gt;5.3 初始化NameNode&lt;/h3&gt;
&lt;p&gt;在&lt;code&gt;hadop001&lt;/code&gt;上执行&lt;code&gt;NameNode&lt;/code&gt;初始化命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;hdfs namenode -format&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行初始化命令后，需要将&lt;code&gt;NameNode&lt;/code&gt;元数据目录的内容，复制到其他未格式化的&lt;code&gt;NameNode&lt;/code&gt;上。元数据存储目录就是我们在&lt;code&gt;hdfs-site.xml&lt;/code&gt;中使用&lt;code&gt;dfs.namenode.name.dir&lt;/code&gt;属性指定的目录。这里我们需要将其复制到&lt;code&gt;hadoop002&lt;/code&gt;上：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt; scp -r /home/hadoop/namenode/data hadoop002:/home/hadoop/namenode/&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;初始化ha状态&quot;&gt;5.4 初始化HA状态&lt;/h3&gt;
&lt;p&gt;在任意一台&lt;code&gt;NameNode&lt;/code&gt;上使用以下命令来初始化ZooKeeper中的HA状态：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;hdfs zkfc -formatZK&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;启动hdfs&quot;&gt;5.5 启动HDFS&lt;/h3&gt;
&lt;p&gt;进入到&lt;code&gt;hadoop001&lt;/code&gt;的&lt;code&gt;${HADOOP_HOME}/sbin&lt;/code&gt;目录下，启动HDFS。此时&lt;code&gt;hadoop001&lt;/code&gt;和&lt;code&gt;hadoop002&lt;/code&gt;上的&lt;code&gt;NameNode&lt;/code&gt;服务，和三台服务器上的&lt;code&gt;DataNode&lt;/code&gt;服务都会被启动：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;start-dfs.sh
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;启动yarn&quot;&gt;5.6 启动YARN&lt;/h3&gt;
&lt;p&gt;进入到&lt;code&gt;hadoop002&lt;/code&gt;的&lt;code&gt;${HADOOP_HOME}/sbin&lt;/code&gt;目录下，启动YARN。此时&lt;code&gt;hadoop002&lt;/code&gt;上的&lt;code&gt;ResourceManager&lt;/code&gt;服务，和三台服务器上的&lt;code&gt;NodeManager&lt;/code&gt;服务都会被启动：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;start-yarn.sh
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要注意的是，这个时候&lt;code&gt;hadoop003&lt;/code&gt;上的&lt;code&gt;ResourceManager&lt;/code&gt;服务通常是没有启动的，需要手动启动：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;yarn-daemon.sh start resourcemanager
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;六查看集群&quot;&gt;六、查看集群&lt;/h2&gt;
&lt;h3 id=&quot;查看进程&quot;&gt;6.1 查看进程&lt;/h3&gt;
&lt;p&gt;成功启动后，每台服务器上的进程应该如下：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[root@hadoop001 sbin]# jps
4512 DFSZKFailoverController
3714 JournalNode
4114 NameNode
3668 QuorumPeerMain
5012 DataNode
4639 NodeManager


[root@hadoop002 sbin]# jps
4499 ResourceManager
4595 NodeManager
3465 QuorumPeerMain
3705 NameNode
3915 DFSZKFailoverController
5211 DataNode
3533 JournalNode


[root@hadoop003 sbin]# jps
3491 JournalNode
3942 NodeManager
4102 ResourceManager
4201 DataNode
3435 QuorumPeerMain
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;查看web-ui&quot;&gt;6.2 查看Web UI&lt;/h3&gt;
&lt;p&gt;HDFS和YARN的端口号分别为&lt;code&gt;50070&lt;/code&gt;和&lt;code&gt;8080&lt;/code&gt;，界面应该如下：&lt;/p&gt;
&lt;p&gt;此时hadoop001上的&lt;code&gt;NameNode&lt;/code&gt;处于可用状态：&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/heibaiying/BigData-Notes/master/pictures/hadoop%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A41.png&quot;/&gt;&lt;/div&gt;
&lt;p&gt;而hadoop002上的&lt;code&gt;NameNode&lt;/code&gt;则处于备用状态：&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/heibaiying/BigData-Notes/master/pictures/hadoop%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A43.png&quot;/&gt;&lt;/div&gt;

&lt;p&gt;hadoop002上的&lt;code&gt;ResourceManager&lt;/code&gt;处于可用状态：&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/heibaiying/BigData-Notes/master/pictures/hadoop%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A44.png&quot;/&gt;&lt;/div&gt;

&lt;p&gt;hadoop003上的&lt;code&gt;ResourceManager&lt;/code&gt;则处于备用状态：&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/heibaiying/BigData-Notes/master/pictures/hadoop%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A45.png&quot;/&gt;&lt;/div&gt;

&lt;p&gt;同时界面上也有&lt;code&gt;Journal Manager&lt;/code&gt;的相关信息：&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/heibaiying/BigData-Notes/master/pictures/hadoop%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A42.png&quot;/&gt;&lt;/div&gt;
&lt;h2 id=&quot;七集群的二次启动&quot;&gt;七、集群的二次启动&lt;/h2&gt;
&lt;p&gt;上面的集群初次启动涉及到一些必要初始化操作，所以过程略显繁琐。但是集群一旦搭建好后，想要再次启用它是比较方便的，步骤如下（首选需要确保ZooKeeper集群已经启动）：&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;hadoop001&lt;/code&gt;启动 HDFS，此时会启动所有与 HDFS 高可用相关的服务，包括 NameNode，DataNode 和 JournalNode：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;start-dfs.sh
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在&lt;code&gt;hadoop002&lt;/code&gt;启动YARN：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;start-yarn.sh
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个时候&lt;code&gt;hadoop003&lt;/code&gt;上的&lt;code&gt;ResourceManager&lt;/code&gt;服务通常还是没有启动的，需要手动启动：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;yarn-daemon.sh start resourcemanager
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
&lt;p&gt;以上搭建步骤主要参考自官方文档：&lt;/p&gt;
&lt;p&gt;关于Hadoop高可用原理的详细分析，推荐阅读：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.ibm.com/developerworks/cn/opensource/os-cn-hadoop-name-node/index.html&quot;&gt;Hadoop NameNode 高可用 (High Availability) 实现解析&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;3.8333333333333&quot;&gt;
&lt;p&gt;更多大数据系列文章可以参见个人 GitHub 开源项目： &lt;a href=&quot;https://github.com/heibaiying/BigData-Notes&quot;&gt;大数据入门指南&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 24 Jun 2019 23:29:00 +0000</pubDate>
<dc:creator>单人影</dc:creator>
<og:description>一、高可用简介 二、集群规划 三、前置条件 四、集群配置 五、启动集群 六、查看集群 七、集群的二次启动 一、高可用简介 Hadoop 高可用 (High Availability) 分为 HDFS</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/danrenying/p/11080640.html</dc:identifier>
</item>
<item>
<title>来阿里有段时间了，谈谈这几个月最真实的感受 - 黄小斜</title>
<link>http://www.cnblogs.com/xll1025/p/11080502.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xll1025/p/11080502.html</guid>
<description>&lt;p&gt;&lt;strong&gt;作者：黄小斜&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文章来源：微信公众号【程序员江湖】&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;阅读本文大概需要 4 分钟。&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;9&quot;&gt;&lt;img class=&quot;cke_widget_element has&quot; src=&quot;http://picturecdn.ejianmedia.com/a1dae186706848dab3c50ae14471f8e1.png&quot; alt=&quot;&quot; data-cke-saved-src=&quot;http://picturecdn.ejianmedia.com/a1dae186706848dab3c50ae14471f8e1.png&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;http://picturecdn.ejianmedia.com/a1dae186706848dab3c50ae14471f8e1.png&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:[]}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;有段时间没写过原创了，想了各种理由，发现其实理由就一个，没时间。&lt;/p&gt;

&lt;p&gt;我来阿里，已经几个月了。这段时间，最大的感受就是累。我是在今年的四月份加入阿里的。&lt;/p&gt;

&lt;p&gt;当初我没有参加阿里巴巴的实习，而是选择了直接进行校园招聘，这也是因为当时我对实习的部门不感兴趣，于是在校招的时候我就选择了自己感兴趣的部门，也就是现在我所在的蚂蚁金服。&lt;/p&gt;

&lt;p&gt;之前就听说过阿里的工作强度，可能会比较大，但是，当我在真正来到这家公司的时候，才发现996，并不是虚言，这倒不是说制度上规定的 996 ，而是因为，你手上的工作，是很难做完的，所以导致你不得不用加班的方式来完成，996 最终的目的只有一个，就是你要把手上的工作做完，对其他人有一个交代。&lt;/p&gt;

&lt;p&gt;刚来一个月的时候只其实我是非常不适应的，毕竟从学校到公司，整个变化是颠覆性的，虽然之前有过实习经历，但是是比较划水的，和正式工作差别还是比较大的，第一个月大抵的状态就是，每天九点多上班，晚上九点及以后下班，这是生活规律上的不适应。&lt;/p&gt;

&lt;p&gt;除此之外，在工作上也会有一些不适应，虽然前期给我的活儿都比较的零散，只要求这里修修补补，那里加点东西。这倒是其次。&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;8&quot;&gt;&lt;img class=&quot;cke_widget_element has&quot; src=&quot;http://picturecdn.ejianmedia.com/13d8ff98441748e79c498e3c40f0610b.png&quot; alt=&quot;&quot; data-cke-saved-src=&quot;http://picturecdn.ejianmedia.com/13d8ff98441748e79c498e3c40f0610b.png&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;http://picturecdn.ejianmedia.com/13d8ff98441748e79c498e3c40f0610b.png&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:[]}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;主要的原因还是因为我对业务线的研发流程不太了解，以及对大家在做的事情不太了解，这会导致我在工作上遇到很多困难。因为我会听不懂大家在说什么。所以第一个月，更多的是思考。&lt;/p&gt;

&lt;p&gt;如何去提高自己的效率，如何去融入这个公司，如何去熟悉部门的业务和技术战，自己感觉是一个比较外向的人，所以一旦有问题就会咨询，我的同事，我的师兄。&lt;/p&gt;

&lt;p&gt;阿里的师兄是一种文化。就像武侠小说里的同门师兄弟一样，师兄会带领着你去做那些工作，并且让你去熟悉整个部门的一些事情。我的师兄是一个寡言少语的人，但是技术能力非常强，也很有责任心。他总是对总是对工作要求特别高，不放过任何一个问题，不漏掉任何一行问题代码。&lt;/p&gt;

&lt;p&gt;在第一个月的时间里。我学习了很多阿里巴巴的一些中间件技术。其实这些技术。在学校复习的时候，多少也听说过一些，看过一些文章。只不过外面用的都是开源的东西，而在阿里内部，更多的是自研的产品，比如说，消息中间件，分布式事务，数据库中间件，等等等等。这些东西，在平时的学习和研发中，是经常会用到的，如果你在学校或者是在其他小公司，可能根本没有机会接触到这些东西。&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;7&quot;&gt;&lt;img class=&quot;cke_widget_element has&quot; src=&quot;http://picturecdn.ejianmedia.com/0a794659a05242fc9689fb3ff558f384.png&quot; alt=&quot;&quot; data-cke-saved-src=&quot;http://picturecdn.ejianmedia.com/0a794659a05242fc9689fb3ff558f384.png&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;http://picturecdn.ejianmedia.com/0a794659a05242fc9689fb3ff558f384.png&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:[]}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;作为一个Java工程师，在这家公司的职责可不止是写代码，你需要熟悉整个研发流程，从系统设计，代码开发，测试联调，发布上线，问题排查都是你的职责，其实这很锻炼人，这也是为什么加班会这么多的原因，写代码只占你日常工作的一小部分时间，你需要花更多时间在解决各类问题上。&lt;/p&gt;

&lt;p&gt;阿里对校招生有一个培训，不同部门可能不太一样，蚂蚁的培训长达一个月，这个月应该也是我觉得成长最快，过得最快乐的一个月，其实无非就是上课，拓展和各类活动，这段时间认识了很多人，其中也有很多大牛，大家一起上课，一起做项目，同甘共苦度过一个月，这样的经历也是非常值得纪念的。&lt;/p&gt;

&lt;p&gt;培训结束后，我也开始承担更多的工作，当自己逐渐习惯这种节奏之后，才感觉自己逐渐在融入这家公司，每次搞懂一个业务问题或者技术问题都会觉得自己在成长，当肩头上承担更多责任的时候，同时也承担了更多压力，如果不能调整好自己的心态，我想在这家公司是很难待久的。&lt;/p&gt;

&lt;p&gt;可能你在其他互联网公司也会感受到相似的压力，但这就是大部分互联网公司的现状，追求效率，追求极致，我们身在其中，就必须适应环境，尊重游戏规则，马上又是新一年的校招季，去年这个时候，这个公众号才刚刚诞生，转眼一年时间，多的是更多思考，希望公众号的文章对你们有会有更多帮助。&lt;/p&gt;

&lt;p&gt;下一篇文章应该也不会让你们等太久。&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;6&quot;&gt;&lt;img class=&quot;cke_widget_element has&quot; src=&quot;http://picturecdn.ejianmedia.com/e2fd5b0aaf3c42f380b4b39920d0322f.png&quot; alt=&quot;&quot; data-cke-saved-src=&quot;http://picturecdn.ejianmedia.com/e2fd5b0aaf3c42f380b4b39920d0322f.png&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;http://picturecdn.ejianmedia.com/e2fd5b0aaf3c42f380b4b39920d0322f.png&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:[]}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;文能码字，武能coding，是我黄小斜，不是黄老邪噢。&lt;/p&gt;


&lt;p&gt;推荐阅读：&lt;/p&gt;

&lt;p&gt;焦虑的 BAT、不安的编程语言，揭秘程序员技术圈生存现状！&lt;/p&gt;



&lt;p&gt;为什么有些大公司技术弱爆了？&lt;/p&gt;


&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;10&quot;&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;5&quot;&gt;&lt;img class=&quot;cke_widget_element has&quot; src=&quot;http://picturecdn.ejianmedia.com/c8fe01de88f94452aac7d346a53e6c7c.png&quot; alt=&quot;&quot; data-cke-saved-src=&quot;http://picturecdn.ejianmedia.com/c8fe01de88f94452aac7d346a53e6c7c.png&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;http://picturecdn.ejianmedia.com/c8fe01de88f94452aac7d346a53e6c7c.png&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:[]}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​你点的每个好看，我都认真当成了喜欢&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 24 Jun 2019 16:17:00 +0000</pubDate>
<dc:creator>黄小斜</dc:creator>
<og:description>作者：黄小斜 文章来源：微信公众号【程序员江湖】 阅读本文大概需要 4 分钟。 ​ 有段时间没写过原创了，想了各种理由，发现其实理由就一个，没时间。 我来阿里，已经几个月了。这段时间，最大的感受就是累</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xll1025/p/11080502.html</dc:identifier>
</item>
<item>
<title>【拆分版】Docker-compose构建Elasticsearch 7.1.0集群 - 东北小狐狸</title>
<link>http://www.cnblogs.com/hellxz/p/docker_es_cluster.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hellxz/p/docker_es_cluster.html</guid>
<description>&lt;h2 id=&quot;写在前边&quot;&gt;写在前边&lt;/h2&gt;
&lt;p&gt;搞了两三天了，一直有个问题困扰着我，ES集群中配置怎么能正确映射到主机上，这边经常报&lt;code&gt;ClusterFormationFailureHelper master not discovered or elected yet.&lt;/code&gt;原因是容器中的ES节点没有正确的映射到主机上，而且容器内ip是易变的，我该怎么配置呢？&lt;/p&gt;
&lt;p&gt;临下班了，终于想到个法子，&lt;strong&gt;固定容器ip——使用network_mode: host&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;看到主机模式的我眼前一亮，容器就相当于一个主机服务，你占哪个端口就是哪个，没有必要再去自己指定port去映射到主机。这样只要主机ip不变，容器中ip不就没问题了么！！！&lt;/p&gt;
&lt;h2 id=&quot;本文内容架构图&quot;&gt;本文内容架构图&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1149398/201906/1149398-20190624183535269-1575048949.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;解释&quot;&gt;解释：&lt;/h3&gt;
&lt;p&gt;Master节点作为Master节点与协调节点，为防止脑裂问题，降低负载，不存数据&lt;/p&gt;
&lt;p&gt;Node1~Node3为数据节点，不参与Master竞选&lt;/p&gt;
&lt;p&gt;TribeNode节点不存数据，不参与Master竞选&lt;/p&gt;
&lt;h2 id=&quot;准备环境&quot;&gt;准备环境&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;GNU/Debain Stretch 9.9 linux-4.19&lt;/li&gt;
&lt;li&gt;Docker 18.09.6&lt;/li&gt;
&lt;li&gt;Docker-Compose 1.17.1&lt;/li&gt;
&lt;li&gt;elasticsearch:7.1.0&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;配置脚本参见我的Github &amp;lt;&lt;a href=&quot;https://github.com/hellxz/docker-es-cluster.git&quot; class=&quot;uri&quot;&gt;https://github.com/hellxz/docker-es-cluster.git&lt;/a&gt;&amp;gt;&lt;/p&gt;
&lt;h2 id=&quot;目录结构&quot;&gt;目录结构&lt;/h2&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;.
├── docker-es-data01
│   ├── data01
│   ├── data01-logs
│   ├── docker-compose.yml
│   ├── .env
│   └── es-config
│       └── elasticsearch.yml
├── docker-es-data02
│   ├── data02
│   ├── data02-logs
│   ├── docker-compose.yml
│   ├── .env
│   └── es-config
│       └── elasticsearch.yml
├── docker-es-data03
│   ├── data03
│   ├── data03-logs
│   ├── docker-compose.yml
│   ├── .env
│   └── es-config
│       └── elasticsearch.yml
├── docker-es-master
│   ├── docker-compose.yml
│   ├── .env
│   ├── es-config
│   │   └── elasticsearch.yml
│   ├── master-data
│   └── master-logs
└── docker-es-tribe
    ├── docker-compose.yml
    ├── .env
    ├── es-config
    │   └── elasticsearch.yml
    ├── tribe-data
    └── tribe-logs
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;各目录代表节点与端口号&quot;&gt;各目录代表节点与端口号&lt;/h2&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;docker-es-data01&lt;/td&gt;
&lt;td&gt;data01&lt;/td&gt;
&lt;td&gt;9301&lt;/td&gt;
&lt;td&gt;数据节点1，非master节点&lt;/td&gt;
&lt;td&gt;9201&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;docker-es-data02&lt;/td&gt;
&lt;td&gt;data02&lt;/td&gt;
&lt;td&gt;9302&lt;/td&gt;
&lt;td&gt;数据节点2，非master节点&lt;/td&gt;
&lt;td&gt;9202&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;docker-es-data03&lt;/td&gt;
&lt;td&gt;data03&lt;/td&gt;
&lt;td&gt;9303&lt;/td&gt;
&lt;td&gt;数据节点3，非master节点&lt;/td&gt;
&lt;td&gt;9203&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;docker-es-master&lt;/td&gt;
&lt;td&gt;master&lt;/td&gt;
&lt;td&gt;9300&lt;/td&gt;
&lt;td&gt;master节点，非数据节点&lt;/td&gt;
&lt;td&gt;9200&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;docker-es-tribe&lt;/td&gt;
&lt;td&gt;tribe&lt;/td&gt;
&lt;td&gt;9304&lt;/td&gt;
&lt;td&gt;协调节点，非master非数据节点&lt;/td&gt;
&lt;td&gt;9204&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;想测试这些节点是否可用，只需要修改&lt;strong&gt;每个&lt;/strong&gt;节点目录下的&lt;code&gt;es-config/elasticsearch.yml&lt;/code&gt;中的ip地址，全部换成你需要的ip即可。&lt;/p&gt;
&lt;h2 id=&quot;各文件功用举例说明&quot;&gt;各文件功用举例说明&lt;/h2&gt;
&lt;p&gt;鉴于这里边有很多是重复操作，这里仅拿其中的master节点进行举例，其余代码参见&lt;a href=&quot;https://github.com/hellxz/docker-es-cluster.git&quot;&gt;Github&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;.env&lt;/strong&gt; 这个文件为docker-compose.yml提供默认参数，方便修改&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;# the default environment for es-master
# set es node jvm args
ES_JVM_OPTS=-Xms256m -Xmx256m
# set master node data folder
MASTER_DATA_DIR=./master-data
# set master node logs folder
MASTER_LOGS_DIR=./master-logs&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;docker-compose.yml&lt;/strong&gt; docker-compose的配置文件&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;version: &quot;3&quot;
services:
    es-master:
        image: elasticsearch:7.1.0
        container_name: es-master
        environment: # setting container env
            - ES_JAVA_OPTS=${ES_JVM_OPTS}   # set es bootstrap jvm args
        restart: always
        volumes:
            - ./es-config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml
            - ${MASTER_DATA_DIR}:/usr/share/elasticsearch/data:rw
            - ${MASTER_LOGS_DIR}:/usr/share/elasticsearch/logs:rw
        network_mode: &quot;host&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;简单来说，就是&lt;strong&gt;修改pull的镜像，替换其中的变量与配置文件，挂载数据与日志目录，最后用的host主机模式，让节点服务占用到实体机端口&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;elaticsearch.yml&lt;/strong&gt; elasticsearch的配置文件，搭建集群最关键的文件之一&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;# ======================== Elasticsearch Configuration =========================
cluster.name: es-cluster
node.name: master 
node.master: true
node.data: false
node.attr.rack: r1 
bootstrap.memory_lock: true 
http.port: 9200
network.host: 10.2.114.110
transport.tcp.port: 9300
discovery.seed_hosts: [&quot;10.2.114.110:9301&quot;,&quot;10.2.114.110:9302&quot;,&quot;10.2.114.110:9303&quot;,&quot;10.2.114.110:9304&quot;] 
cluster.initial_master_nodes: [&quot;master&quot;] 
gateway.recover_after_nodes: 2&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;按照前几篇文章下来，大家对这些参数已经不是很陌生了，这里简单说下几个比较重要的参数&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;transport.tcp.port&lt;/code&gt; 设置es多节点协调的端口号&lt;/li&gt;
&lt;li&gt;&lt;code&gt;discovery.seed_hosts&lt;/code&gt; 设置当前节点启动后要发现的&lt;strong&gt;协调节点位置&lt;/strong&gt;，当然自己不需要发现自己，推荐使用&lt;strong&gt;ip:port&lt;/strong&gt;形式，集群形成快&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cluster.initial_master_nodes&lt;/code&gt; 集群中可以成为master节点的节点名，这里指定唯一的一个，防止脑裂&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h2 id=&quot;使用说明&quot;&gt;使用说明&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;若想将此脚本使用到生产上，需要修改每个节点下的&lt;code&gt;.env&lt;/code&gt;文件，将挂载数据、日志目录修改为启动es的集群的用户可读写的位置，可以通过&lt;code&gt;sudo chmod 777 -R 目录&lt;/code&gt; 或 &lt;code&gt;sudo chown -R 当前用户名:用户组 目录&lt;/code&gt; 来修改被挂载的目录权限&lt;/li&gt;
&lt;li&gt;修改.&lt;code&gt;env&lt;/code&gt;下的JVM参数，扩大堆内存，启动与最大值最好相等，以减少gc次数，提高效率&lt;/li&gt;
&lt;li&gt;修改所有节点下的&lt;code&gt;docker-compose.yml&lt;/code&gt; 中的&lt;code&gt;network.host&lt;/code&gt;地址 为当前所放置的主机的ip，&lt;code&gt;discovery.seed_hosts&lt;/code&gt;需要填写具体各待发现节点的实体机ip，以确保可以组成集群&lt;/li&gt;
&lt;li&gt;确保各端口在其宿主机上没有被占用，如有占用需确认是否有用，无用kill，有用则更新&lt;code&gt;docker-compose.yml&lt;/code&gt;的&lt;code&gt;http.port&lt;/code&gt;或&lt;code&gt;transport.tcp.port&lt;/code&gt;，注意与此同时要更新其它节点的&lt;code&gt;discovery.seed_hosts&lt;/code&gt;对应的port&lt;/li&gt;
&lt;li&gt;如果在同一台主机上，可以参考使用文章后边的简单的shell脚本&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;各节点操作命令&quot;&gt;各节点操作命令&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;后台启动命令&lt;/strong&gt;均为&lt;code&gt;docker-compose up -d&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关闭命令&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;docker-compose down&lt;/code&gt;: 关闭同时移除容器与多余虚拟网卡&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker stop contains_name&lt;/code&gt;: 根据容器名称关闭容器，不移除容器&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;简单的shell脚本&quot;&gt;简单的Shell脚本&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;docker-es-cluster-up.sh&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;#/bin/bash
# please put this shell script to the root of each node folder.
# this shell script for start up the docker-es-cluster designed in the one of linux server.
cd docker-es-master &amp;amp;&amp;amp; docker-compose up -d &amp;amp;&amp;amp; \
cd ../docker-es-data01 &amp;amp;&amp;amp; docker-compose up -d &amp;amp;&amp;amp; \
cd ../docker-es-data02 &amp;amp;&amp;amp; docker-compose up -d &amp;amp;&amp;amp; \
cd ../docker-es-data03 &amp;amp;&amp;amp; docker-compose up -d &amp;amp;&amp;amp; \
cd ../docker-es-tribe &amp;amp;&amp;amp; docker-compose up -d &amp;amp;&amp;amp; \
cd ..&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;docker-es-cluster-down.sh&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;#/bin/bash
# please put this shell script to the root of each node folder.
# this shell script for remove the docker-es-cluster's containers and networks designed in the one of linux server.
cd docker-es-tribe &amp;amp;&amp;amp; docker-compose down &amp;amp;&amp;amp; \
cd ../docker-es-data03 &amp;amp;&amp;amp; docker-compose down &amp;amp;&amp;amp; \
cd ../docker-es-data02 &amp;amp;&amp;amp; docker-compose down &amp;amp;&amp;amp; \
cd ../docker-es-data01 &amp;amp;&amp;amp; docker-compose down &amp;amp;&amp;amp; \
cd ../docker-es-master &amp;amp;&amp;amp; docker-compose down &amp;amp;&amp;amp; \
cd ..&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;docker-es-cluster-stop.sh&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;#/bin/bash
# please put this shell script to the root of each node folder.
# this shell script for stop the docker-es-cluster's containers designed in the one of linux server.
docker stop es-tribe es-data03 es-data02 es-data01 es-master&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;如果你想让这些脚本有执行权限，不妨试试&lt;code&gt;sudo chmod +x *.sh&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这些脚本中没有使用sudo，如需要使用sudo才能启动docker,请添加当前用户到docker组&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Enjoy.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文系原创文章，禁止转载。&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 24 Jun 2019 15:38:00 +0000</pubDate>
<dc:creator>东北小狐狸</dc:creator>
<og:description>写在前边 搞了两三天了，一直有个问题困扰着我，ES集群中配置怎么能正确映射到主机上，这边经常报 原因是容器中的ES节点没有正确的映射到主机上，而且容器内ip是易变的，我该怎么配置呢？ 临下班了，终于想</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hellxz/p/docker_es_cluster.html</dc:identifier>
</item>
<item>
<title>spring源码解析之IOC容器（二）------加载和注册 - 蜗牛背着马</title>
<link>http://www.cnblogs.com/helei123/p/11080191.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/helei123/p/11080191.html</guid>
<description>&lt;p&gt;　　上一篇跟踪了IOC容器对配置文件的定位，现在我们继续跟踪代码，看看IOC容器是怎么加载和注册配置文件中的信息的。开始之前，首先我们先来了解一下IOC容器所使用的数据结构-------BeanDefinition，它是一个上层接口，有很多实现类，分别对应不同的数据载体。我们平时开发的时候，也会定义很多pojo类，来作为获取数据的载体。最常见的就是，从数据库中获取数据之后，使用一个定义的pojo来装载，然后我们就可以在程序中使用这个pojo类来编写各种业务逻辑。同样，IOC容器首先会读取配置的XML中各个节点，即各个标签元素，然后根据不同的标签元素，使用不同的数据结构来装载该元素中的各种属性的值。比如我们最熟悉的&amp;lt;bean&amp;gt;标签，就是使用AbstractBeanDefinition这个数据结构，接下来的分析中我们可以看到。&lt;/p&gt;
&lt;p&gt;　　先回到上篇资源的定位那里，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; loadBeanDefinitions(String location, Set&amp;lt;Resource&amp;gt; actualResources) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeanDefinitionStoreException {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         ResourceLoader resourceLoader =&lt;span&gt; getResourceLoader();
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (resourceLoader == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BeanDefinitionStoreException(
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;                     &quot;Cannot import bean definitions from location [&quot; + location + &quot;]: no ResourceLoader available&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (resourceLoader &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; ResourcePatternResolver) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Resource pattern matching available.&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 Resource[] resources =&lt;span&gt; ((ResourcePatternResolver) resourceLoader).getResources(location);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 &lt;span&gt;int&lt;/span&gt; loadCount =&lt;span&gt; loadBeanDefinitions(resources);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (actualResources != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                     &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Resource resource : resources) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;                        actualResources.add(resource);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isDebugEnabled()) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                     logger.debug(&quot;Loaded &quot; + loadCount + &quot; bean definitions from location pattern [&quot; + location + &quot;]&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; loadCount;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException ex) {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                 &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BeanDefinitionStoreException(
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                         &quot;Could not resolve bean definition resource pattern [&quot; + location + &quot;]&quot;&lt;span&gt;, ex);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定位到资源之后，封装成一个resource对象&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;             Resource resource =&lt;span&gt; resourceLoader.getResource(location);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; loadCount =&lt;span&gt; loadBeanDefinitions(resource);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (actualResources != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;                actualResources.add(resource);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isDebugEnabled()) {
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                 logger.debug(&quot;Loaded &quot; + loadCount + &quot; bean definitions from location [&quot; + location + &quot;]&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; loadCount;
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　进入loadBeanDefinitions(resource)方法，正式开始加载源码的跟踪：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;        @Override
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; loadBeanDefinitions(Resource resource) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeanDefinitionStoreException {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; loadBeanDefinitions(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; EncodedResource(resource));
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     }    
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; loadBeanDefinitions(EncodedResource encodedResource) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeanDefinitionStoreException {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         Assert.notNull(encodedResource, &quot;EncodedResource must not be null&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isInfoEnabled()) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             logger.info(&quot;Loading XML bean definitions from &quot; +&lt;span&gt; encodedResource);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;         Set&amp;lt;EncodedResource&amp;gt; currentResources = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.resourcesCurrentlyBeingLoaded.get();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (currentResources == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             currentResources = &lt;span&gt;new&lt;/span&gt; HashSet&amp;lt;EncodedResource&amp;gt;(4&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.resourcesCurrentlyBeingLoaded.set(currentResources);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;currentResources.add(encodedResource)) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BeanDefinitionStoreException(
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                     &quot;Detected cyclic loading of &quot; + encodedResource + &quot; - check your import definitions!&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             InputStream inputStream =&lt;span&gt; encodedResource.getResource().getInputStream();
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                 InputSource inputSource = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InputSource(inputStream);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (encodedResource.getEncoding() != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;                    inputSource.setEncoding(encodedResource.getEncoding());
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; doLoadBeanDefinitions(inputSource, encodedResource.getResource());
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;                inputStream.close();
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException ex) {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BeanDefinitionStoreException(
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                     &quot;IOException parsing XML document from &quot; +&lt;span&gt; encodedResource.getResource(), ex);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;            currentResources.remove(encodedResource);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (currentResources.isEmpty()) {
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                 &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.resourcesCurrentlyBeingLoaded.remove();
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　进入doLoadBeanDefinitions(inputSource, encodedResource.getResource())方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; doLoadBeanDefinitions(InputSource inputSource, Resource resource)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;             &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeanDefinitionStoreException {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             Document doc =&lt;span&gt; doLoadDocument(inputSource, resource);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; registerBeanDefinitions(doc, resource);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (BeanDefinitionStoreException ex) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt;&lt;span&gt; ex;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (SAXParseException ex) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; XmlBeanDefinitionStoreException(resource.getDescription(),
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                     &quot;Line &quot; + ex.getLineNumber() + &quot; in XML document from &quot; + resource + &quot; is invalid&quot;&lt;span&gt;, ex);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (SAXException ex) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; XmlBeanDefinitionStoreException(resource.getDescription(),
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                     &quot;XML document from &quot; + resource + &quot; is invalid&quot;&lt;span&gt;, ex);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ParserConfigurationException ex) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BeanDefinitionStoreException(resource.getDescription(),
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                     &quot;Parser configuration exception parsing XML from &quot; +&lt;span&gt; resource, ex);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException ex) {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BeanDefinitionStoreException(resource.getDescription(),
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                     &quot;IOException parsing XML document from &quot; +&lt;span&gt; resource, ex);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable ex) {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BeanDefinitionStoreException(resource.getDescription(),
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                     &quot;Unexpected exception parsing XML document from &quot; +&lt;span&gt; resource, ex);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　继续进入registerBeanDefinitions(doc, resource)方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; registerBeanDefinitions(Document doc, Resource resource) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeanDefinitionStoreException {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;此时documentReader已经是DefaultBeanDefinitionDocumentReader类了&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;         BeanDefinitionDocumentReader documentReader =&lt;span&gt; createBeanDefinitionDocumentReader();
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; countBefore =&lt;span&gt; getRegistry().getBeanDefinitionCount();
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;        documentReader.registerBeanDefinitions(doc, createReaderContext(resource));
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回当前注册的beanDefinition的个数&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; getRegistry().getBeanDefinitionCount() -&lt;span&gt; countBefore;
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　进入registerBeanDefinitions(doc, createReaderContext(resource))方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; registerBeanDefinitions(Document doc, XmlReaderContext readerContext) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.readerContext =&lt;span&gt; readerContext;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         logger.debug(&quot;Loading bean definitions&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         Element root =&lt;span&gt; doc.getDocumentElement();
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;        doRegisterBeanDefinitions(root);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　进入doRegisterBeanDefinitions(root)方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doRegisterBeanDefinitions(Element root) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Any nested &amp;lt;beans&amp;gt; elements will cause recursion in this method. In
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; order to propagate and preserve &amp;lt;beans&amp;gt; default-* attributes correctly,
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; keep track of the current (parent) delegate, which may be null. Create
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; the new (child) delegate with a reference to the parent for fallback purposes,
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; then ultimately reset this.delegate back to its original (parent) reference.
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; this behavior emulates a stack of delegates without actually necessitating one.&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;         BeanDefinitionParserDelegate parent = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.delegate;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.delegate =&lt;span&gt; createDelegate(getReaderContext(), root, parent);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.delegate.isDefaultNamespace(root)) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;profile属性平时使用非常少，该属性可以用于配置数据库的切换（常用），使用时，需要在web.xml中配置context-parm
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;&amp;lt;context-parm&amp;gt;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    &amp;lt;parm-name&amp;gt;Spring.profiles.active&amp;lt;/parm-name&amp;gt;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    &amp;lt;parm-value&amp;gt;dev(在applicationContext.xml中配置的profile属性的beans的profile属性值)&amp;lt;/parm-name&amp;gt;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;&amp;lt;/context-parm&amp;gt;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在applicationContext.xml中的配置
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;&amp;lt;beans profile=&quot;dev&quot;&amp;gt;    &amp;lt;/beans&amp;gt;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;&amp;lt;beans profile=&quot;produce&quot;&amp;gt;   &amp;lt;/beans&amp;gt;&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;             String profileSpec =&lt;span&gt; root.getAttribute(PROFILE_ATTRIBUTE);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (StringUtils.hasText(profileSpec)) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                 String[] specifiedProfiles =&lt;span&gt; StringUtils.tokenizeToStringArray(
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;                        profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isInfoEnabled()) {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                         logger.info(&quot;Skipped XML bean definition file due to specified profiles [&quot; + profileSpec +
&lt;span&gt;27&lt;/span&gt;                                 &quot;] not matching: &quot; +&lt;span&gt; getReaderContext().getResource());
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt; &lt;span&gt;        preProcessXml(root);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         parseBeanDefinitions(root, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.delegate);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;        postProcessXml(root);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.delegate =&lt;span&gt; parent;
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里也用到了模板方法，preProcessXml(root)和postProcessXml(root)这两个方法都是空实现，是留给客户来实现自己的逻辑的。重点研究一下parseBeanDefinitions(root, this.delegate)方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (delegate.isDefaultNamespace(root)) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             NodeList nl =&lt;span&gt; root.getChildNodes();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; nl.getLength(); i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;                 Node node =&lt;span&gt; nl.item(i);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (node &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; Element) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                     Element ele =&lt;span&gt; (Element) node;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (delegate.isDefaultNamespace(ele)) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;                        parseDefaultElement(ele, delegate);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                     &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;                        delegate.parseCustomElement(ele);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            delegate.parseCustomElement(root);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　parseCustomElement(root)方法不需要怎么研究，我们平时几乎不会用到自定义的标签，所以只跟踪parseDefaultElement(ele, delegate)里面的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;import标签&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) {
            importBeanDefinitionResource(ele);
        }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;alias标签&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) {
            processAliasRegistration(ele);
        }
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;bean标签&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) {
            processBeanDefinition(ele, delegate);
        }
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;beans标签&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; recurse&lt;/span&gt;
&lt;span&gt;            doRegisterBeanDefinitions(ele);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　可以看到，对于不同的标签，spring采用不同的策略进行处理，重点跟踪一下处理bean标签的方法processBeanDefinition(ele, delegate)：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;委托给delegate去进行各种标签的解析，parseBeanDefinitionElement方法中包含了各种标签元素的解析，
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;并将解析好的内容封装成BeanDefinitionHolder对象&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         BeanDefinitionHolder bdHolder =&lt;span&gt; delegate.parseBeanDefinitionElement(ele);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (bdHolder != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             bdHolder =&lt;span&gt; delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Register the final decorated instance.&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;                BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (BeanDefinitionStoreException ex) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 getReaderContext().error(&quot;Failed to register bean definition with name '&quot; +
&lt;span&gt;13&lt;/span&gt;                         bdHolder.getBeanName() + &quot;'&quot;&lt;span&gt;, ele, ex);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Send registration event.&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;             getReaderContext().fireComponentRegistered(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; BeanComponentDefinition(bdHolder));
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在这个方法中，delegate.parseBeanDefinitionElement(ele)是解析bean元素中各种属性的方法，registerBeanDefinition(bdHolder, getReaderContext().getRegistry())是将封装好的数据进行存储的方法。先看一下解析的方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; BeanDefinitionHolder parseBeanDefinitionElement(Element ele, BeanDefinition containingBean) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取bean标签的id属性的值&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;         String id =&lt;span&gt; ele.getAttribute(ID_ATTRIBUTE);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取bean标签上name属性的值&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         String nameAttr =&lt;span&gt; ele.getAttribute(NAME_ATTRIBUTE);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;         List&amp;lt;String&amp;gt; aliases = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;String&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (StringUtils.hasLength(nameAttr)) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将name的值进行分割，并将它们当作别名存到aliases中&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;             String[] nameArr =&lt;span&gt; StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            aliases.addAll(Arrays.asList(nameArr));
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;         String beanName =&lt;span&gt; id;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果bean标签的id没有值，但是name属性有值，则将name属性的第一个值当作id的值，并从aliases中将第一个别名移除掉&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!StringUtils.hasText(beanName) &amp;amp;&amp;amp; !&lt;span&gt;aliases.isEmpty()) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             beanName = aliases.remove(0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isDebugEnabled()) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                 logger.debug(&quot;No XML 'id' specified - using '&quot; + beanName +
&lt;span&gt;20&lt;/span&gt;                         &quot;' as bean name and &quot; + aliases + &quot; as aliases&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (containingBean == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;检查bean的唯一性&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;            checkNameUniqueness(beanName, aliases, ele);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里已经是将XML中bean元素中的所有属性都封装到beanDefinition对象中了&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;         AbstractBeanDefinition beanDefinition =&lt;span&gt; parseBeanDefinitionElement(ele, beanName, containingBean);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (beanDefinition != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;StringUtils.hasText(beanName)) {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                 &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (containingBean != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                         beanName =&lt;span&gt; BeanDefinitionReaderUtils.generateBeanName(
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                                 beanDefinition, &lt;span&gt;this&lt;/span&gt;.readerContext.getRegistry(), &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                     &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;                         beanName = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.readerContext.generateBeanName(beanDefinition);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Register an alias for the plain bean class name, if still possible,
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; if the generator returned the class name plus a suffix.
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; This is expected for Spring 1.2/2.0 backwards compatibility.&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt;                         String beanClassName =&lt;span&gt; beanDefinition.getBeanClassName();
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; (beanClassName != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;
&lt;span&gt;45&lt;/span&gt;                                 beanName.startsWith(beanClassName) &amp;amp;&amp;amp; beanName.length() &amp;gt; beanClassName.length() &amp;amp;&amp;amp;
&lt;span&gt;46&lt;/span&gt;                                 !&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.readerContext.getRegistry().isBeanNameInUse(beanClassName)) {
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;                            aliases.add(beanClassName);
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isDebugEnabled()) {
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;                         logger.debug(&quot;Neither XML 'id' nor 'name' specified - &quot; +
&lt;span&gt;52&lt;/span&gt;                                 &quot;using generated bean name [&quot; + beanName + &quot;]&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;                 &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex) {
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;                    error(ex.getMessage(), ele);
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;             String[] aliasesArray =&lt;span&gt; StringUtils.toStringArray(aliases);
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;最后将封装好的beanDefinition、它的id、以及它的别名一起封装成BeanDefinitionHolder对象返回&lt;/span&gt;
&lt;span&gt;62&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; 
&lt;span&gt;65&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我们可以得到如下信息：&lt;/p&gt;
&lt;p&gt;　　1、获取bean标签的id属性和name属性的值；&lt;/p&gt;
&lt;p&gt;　　2、name属性是可以都有多个值的，以逗号或者分号分割；&lt;/p&gt;
&lt;p&gt;　　3、如果id没有赋值，则取name的第一个值作为id的值。所以，我们一般都会给id赋值，这样效率高一些；&lt;/p&gt;
&lt;p&gt;　　4、检查以这个id标识的bean是不是唯一的；&lt;/p&gt;
&lt;p&gt;　　5、进行其他属性的解析，并最终封装测AbstractBeanDefinition对象，也就是我们前文中提到的数据结构；&lt;/p&gt;
&lt;p&gt;　　6、最后封装成BeanDefinitionHolder对象之后返回。&lt;/p&gt;
&lt;p&gt;　　进入parseBeanDefinitionElement(ele, beanName, containingBean)方法，看一下其他元素的解析过程：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; AbstractBeanDefinition parseBeanDefinitionElement(
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;            Element ele, String beanName, BeanDefinition containingBean) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.parseState.push(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; BeanEntry(beanName));
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;         String className = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ele.hasAttribute(CLASS_ATTRIBUTE)) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             className =&lt;span&gt; ele.getAttribute(CLASS_ATTRIBUTE).trim();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             String parent = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ele.hasAttribute(PARENT_ATTRIBUTE)) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 parent =&lt;span&gt; ele.getAttribute(PARENT_ATTRIBUTE);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             AbstractBeanDefinition bd =&lt;span&gt; createBeanDefinition(className, parent);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;            bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;            parseMetaElements(ele, bd);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;            parseLookupOverrideSubElements(ele, bd.getMethodOverrides());
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;            parseReplacedMethodSubElements(ele, bd.getMethodOverrides());
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;            parseConstructorArgElements(ele, bd);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;            parsePropertyElements(ele, bd);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;            parseQualifierElements(ele, bd);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt;             bd.setResource(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.readerContext.getResource());
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;            bd.setSource(extractSource(ele));
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; bd;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ClassNotFoundException ex) {
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;             error(&quot;Bean class [&quot; + className + &quot;] not found&quot;&lt;span&gt;, ele, ex);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (NoClassDefFoundError err) {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;             error(&quot;Class that bean class [&quot; + className + &quot;] depends on not found&quot;&lt;span&gt;, ele, err);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;         &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable ex) {
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;             error(&quot;Unexpected failure during bean definition parsing&quot;&lt;span&gt;, ele, ex);
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;         &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.parseState.pop();
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; 
&lt;span&gt;47&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　解析封装成BeanDefinitionHolder对象之后，就可以进行注册了，先回到之前的processBeanDefinition(ele, delegate)：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;委托给delegate去进行各种标签的解析，parseBeanDefinitionElement方法中包含了各种标签元素的解析，
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;并将解析好的内容封装成BeanDefinitionHolder对象&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         BeanDefinitionHolder bdHolder =&lt;span&gt; delegate.parseBeanDefinitionElement(ele);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (bdHolder != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             bdHolder =&lt;span&gt; delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Register the final decorated instance.&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;                BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (BeanDefinitionStoreException ex) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 getReaderContext().error(&quot;Failed to register bean definition with name '&quot; +
&lt;span&gt;13&lt;/span&gt;                         bdHolder.getBeanName() + &quot;'&quot;&lt;span&gt;, ele, ex);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Send registration event.&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;             getReaderContext().fireComponentRegistered(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; BeanComponentDefinition(bdHolder));
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　现在进入BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry())方法进行分析：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; registerBeanDefinition(
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;            BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeanDefinitionStoreException {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Register bean definition under primary name.&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         String beanName =&lt;span&gt; definitionHolder.getBeanName();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Register aliases for bean name, if any.&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         String[] aliases =&lt;span&gt; definitionHolder.getAliases();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (aliases != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (String alias : aliases) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;                registry.registerAlias(beanName, alias);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里的beanName就是之前封装好的bean的id。这个方法中分别以id和别名作为key来注册bean，其实就是存储在map中。&lt;/p&gt;
&lt;p&gt;　　进入registerBeanDefinition(beanName, definitionHolder.getBeanDefinition())，在其子类DefaultListableBeanFactory中有实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; registerBeanDefinition(String beanName, BeanDefinition beanDefinition)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;             &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeanDefinitionStoreException {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;         Assert.hasText(beanName, &quot;Bean name must not be empty&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         Assert.notNull(beanDefinition, &quot;BeanDefinition must not be null&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (beanDefinition &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; AbstractBeanDefinition) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;                ((AbstractBeanDefinition) beanDefinition).validate();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (BeanDefinitionValidationException ex) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                         &quot;Validation of bean definition failed&quot;&lt;span&gt;, ex);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;         BeanDefinition existingDefinition = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.beanDefinitionMap.get(beanName);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (existingDefinition != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;isAllowBeanDefinitionOverriding()) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                 &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                         &quot;Cannot register bean definition [&quot; + beanDefinition + &quot;] for bean '&quot; + beanName +
&lt;span&gt;22&lt;/span&gt;                         &quot;': There is already [&quot; + existingDefinition + &quot;] bound.&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (existingDefinition.getRole() &amp;lt;&lt;span&gt; beanDefinition.getRole()) {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isWarnEnabled()) {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                     logger.warn(&quot;Overriding user-defined bean definition for bean '&quot; + beanName +
&lt;span&gt;28&lt;/span&gt;                             &quot;' with a framework-generated bean definition: replacing [&quot; +
&lt;span&gt;29&lt;/span&gt;                             existingDefinition + &quot;] with [&quot; + beanDefinition + &quot;]&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;beanDefinition.equals(existingDefinition)) {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isInfoEnabled()) {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;                     logger.info(&quot;Overriding bean definition for bean '&quot; + beanName +
&lt;span&gt;35&lt;/span&gt;                             &quot;' with a different definition: replacing [&quot; + existingDefinition +
&lt;span&gt;36&lt;/span&gt;                             &quot;] with [&quot; + beanDefinition + &quot;]&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isDebugEnabled()) {
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;                     logger.debug(&quot;Overriding bean definition for bean '&quot; + beanName +
&lt;span&gt;42&lt;/span&gt;                             &quot;' with an equivalent definition: replacing [&quot; + existingDefinition +
&lt;span&gt;43&lt;/span&gt;                             &quot;] with [&quot; + beanDefinition + &quot;]&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.beanDefinitionMap.put(beanName, beanDefinition);
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (hasBeanCreationStarted()) {
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Cannot modify startup-time collection elements anymore (for stable iteration)&lt;/span&gt;
&lt;span&gt;51&lt;/span&gt;                 &lt;span&gt;synchronized&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.beanDefinitionMap) {
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;                     &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.beanDefinitionMap.put(beanName, beanDefinition);
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;                     List&amp;lt;String&amp;gt; updatedDefinitions = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;String&amp;gt;(&lt;span&gt;this&lt;/span&gt;.beanDefinitionNames.size() + 1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;                     updatedDefinitions.addAll(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.beanDefinitionNames);
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;                    updatedDefinitions.add(beanName);
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;                     &lt;span&gt;this&lt;/span&gt;.beanDefinitionNames =&lt;span&gt; updatedDefinitions;
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.manualSingletonNames.contains(beanName)) {
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;                         Set&amp;lt;String&amp;gt; updatedSingletons = &lt;span&gt;new&lt;/span&gt; LinkedHashSet&amp;lt;String&amp;gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.manualSingletonNames);
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; &lt;span&gt;                        updatedSingletons.remove(beanName);
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;                         &lt;span&gt;this&lt;/span&gt;.manualSingletonNames =&lt;span&gt; updatedSingletons;
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Still in startup registration phase&lt;/span&gt;
&lt;span&gt;66&lt;/span&gt;                 &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.beanDefinitionMap.put(beanName, beanDefinition);
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt;                 &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.beanDefinitionNames.add(beanName);
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;                 &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.manualSingletonNames.remove(beanName);
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.frozenBeanDefinitionNames = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt; 
&lt;span&gt;73&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (existingDefinition != &lt;span&gt;null&lt;/span&gt; ||&lt;span&gt; containsSingleton(beanName)) {
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt; &lt;span&gt;            resetBeanDefinition(beanName);
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我们可以看到：这个beanDefinitionMap就是用来存储解析好的bean的，以id作为key。至此，就将所有的bean标签解析好之后封装成BeanDefinition注册到了IOC容器中。但是，到目前为止，IOC容器并没有为我们将这些解析好的数据生成一个一个bean实例，我们仍然不能就这样直接使用。下一篇接着跟踪。&lt;/p&gt;
</description>
<pubDate>Mon, 24 Jun 2019 15:22:00 +0000</pubDate>
<dc:creator>蜗牛背着马</dc:creator>
<og:description>上一篇跟踪了IOC容器对配置文件的定位，现在我们继续跟踪代码，看看IOC容器是怎么加载和注册配置文件中的信息的。开始之前，首先我们先来了解一下IOC容器所使用的数据结构 BeanDefinition，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/helei123/p/11080191.html</dc:identifier>
</item>
<item>
<title>基于vue + axios + lrz.js 微信端图片压缩上传 - 沉淀的风</title>
<link>http://www.cnblogs.com/xyb0226/p/11080137.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xyb0226/p/11080137.html</guid>
<description>&lt;p&gt;微信端项目是基于Vux + Axios构建的，关于图片上传的业务场景有以下几点需求:&lt;/p&gt;
&lt;p&gt;1、单张图片上传(如个人头像,实名认证等业务)&lt;br/&gt;2、多张图片上传(如某类工单记录)&lt;br/&gt;3、上传图片时期望能按指定尺寸压缩处理&lt;br/&gt;4、上传图片可以从相册中选择或者直接拍照&lt;/p&gt;

&lt;h2 id=&quot;采用微信jssdk上传图片&quot;&gt;采用微信JSSDK上传图片&lt;/h2&gt;
&lt;p&gt;在之前开发的项目中(mui + jquery)，有使用过微信JSSDK的接口上传图片，本想应该能快速迁移至此项目。事实证明编程没有简单的事:&lt;br/&gt;1、按指定尺寸压缩图片&lt;br/&gt;JSSDK提供的接口wx.chooseImage 是不能指定图片压缩尺寸的,只能在后端的接口通过localId获取图片时，再转换成指定的尺寸。&lt;br/&gt;2、微信JSSDK的接口权限验证&lt;br/&gt;只要是单页面应用项目，微信JSSDK注入权限验证都会有这个坑，而这个与路由模式(hash 或 history)也有关联。有关此坑， 后续会再次写文总结。参考解决方案&lt;a href=&quot;https://www.cnblogs.com/scottjeremy/p/8515495.html&quot;&gt;[微信JSSDK] 解决SDK注入权限验证 安卓正常，IOS出现config fail&lt;/a&gt;&lt;br/&gt;经过权衡考虑网页可能需要在微信以外的浏览器上也能上传文件，顾后来放弃了采用微信JSSDK接口上传图片的方式。&lt;/p&gt;
&lt;h2 id=&quot;android版微信input-onchange事件不触发&quot;&gt;android版微信,input onchange事件不触发&lt;/h2&gt;
&lt;p&gt;这个坑，圈内有很多人踩过了。在PC端测试是正常的，发布之后，微信端上传时能选择文件，但之后没有任何效果。日志跟踪，后台的api都未调用，由此判断是input的onchange事件未被触发。&lt;br/&gt;解决方案, 更改input的 accept属性：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;&amp;lt;input ref=&quot;file&quot; type=&quot;file&quot; accept=&quot;image/jpeg,image/png&quot; @change=&quot;selectImgs&quot; /&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将以上代码更改为:&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;&amp;lt;input ref=&quot;file&quot; type=&quot;file&quot; accept=&quot;image/*&quot; @change=&quot;selectImgs&quot; /&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果不允许从相册中选择，只能拍照，增加capture=&quot;camera&quot;：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;&amp;lt;input ref=&quot;file&quot; type=&quot;file&quot; accept=&quot;image/*&quot; capture=&quot;camera&quot; @change=&quot;selectImgs&quot; /&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(&lt;span&gt;注:如果场景支持从相册选择或拍照，测试发现某些机型拍照后返回到了主页。哈哈，也有可能是其他因素引起的问题，未做深究了&lt;/span&gt;)&lt;/p&gt;

&lt;p&gt;目前手机拍照的图片文件大小一般在3-4M，如果在上传时不做压缩处理会相当浪费流量并且占用服务器的存储空间(期望上传原图的另做讨论)。如果能够在前端压缩处理，那肯定是最理想的方案。而&lt;a href=&quot;https://github.com/think2011/localResizeIMG&quot;&gt;lrz.js&lt;/a&gt;则提供了前端图片文件的压缩方案，并且可以指定尺寸压缩。实测:3M左右的图片文件，按宽度450px尺寸压缩上传后的文件大小在500kb左右，上传时间2s以内。&lt;br/&gt;其核心源码，如下:&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;selectImgs () {
  let file = this.$refs.file.files[0]
  lrz(file, { width: 450, fieldName: 'file' }).then((rst) =&amp;gt; {
    var xhr = new XMLHttpRequest()
    xhr.open('POST', 'http://xxx.com/upload')

    xhr.onload = () =&amp;gt; {
      if (xhr.status === 200 || xhr.status === 304) {
        // 无论后端抛出何种错误，都会走这里
        try {
          // 如果后端跑异常,则能解析成功, 否则解析不成功
          let resp = JSON.parse(xhr.responseText)
          console.log('response: ', resp)
        } catch (e) {
          this.imageUrl = xhr.responseText
        }
      }
    }

    // 添加参数
    rst.formData.append('folder', 'wxAvatar') // 保存的文件夹
    rst.formData.append('base64', rst.base64)
    // 触发上传
    xhr.send(rst.formData)

    return rst
  })
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;单个图片上传组件完整代码，如下(&lt;span&gt;注: icon图标使用的是svg-icon组件&lt;/span&gt;):&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;div class=&quot;imgUploader&quot;&amp;gt;
    &amp;lt;section v-if=&quot;imageUrl&quot;
             class=&quot;file-item &quot;&amp;gt;
      &amp;lt;img :src=&quot;imageUrl&quot;
           alt=&quot;&quot;&amp;gt;
      &amp;lt;span class=&quot;file-remove&quot;
            @click=&quot;remove()&quot;&amp;gt;+&amp;lt;/span&amp;gt;
    &amp;lt;/section&amp;gt;
    &amp;lt;section v-else
             class=&quot;file-item&quot;&amp;gt;
      &amp;lt;div class=&quot;add&quot;&amp;gt;
        &amp;lt;svg-icon v-if=&quot;!text&quot;
                  class=&quot;icon&quot;
                  icon-class=&quot;plus&quot; /&amp;gt;
        &amp;lt;span v-if=&quot;text&quot;
              class=&quot;text&quot;&amp;gt;{{text}}&amp;lt;/span&amp;gt;
        &amp;lt;input type=&quot;file&quot;
               accept=&quot;image/*&quot;
               @change=&quot;selectImgs&quot;
               ref=&quot;file&quot;&amp;gt;
      &amp;lt;/div&amp;gt;
    &amp;lt;/section&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
import lrz from 'lrz'
export default {
  props: {
    text: String,
    // 压缩尺寸,默认宽度为450px
    size: {
      type: Number,
      default: 450
    }
  },
  data () {
    return {
      img: {
        name: '',
        src: ''
      },
      uploadUrl:  'http://ff-ff.xxx.cn/UploaderV2/Base64FileUpload',
      imageUrl: ''
    }
  },
  watch: {
    imageUrl (val, oldVal) {
      this.$emit('input', val)
    },
    value (val) {
      this.imageUrl = val
    }
  },
  mounted () {
    this.imageUrl = this.value
  },
  methods: {
    // 选择图片
    selectImgs () {
      let file = this.$refs.file.files[0]
      lrz(file, { width: this.size, fieldName: 'file' }).then((rst) =&amp;gt; {
        var xhr = new XMLHttpRequest()
        xhr.open('POST', this.uploadUrl)

        xhr.onload = () =&amp;gt; {
          if (xhr.status === 200 || xhr.status === 304) {
            // 无论后端抛出何种错误，都会走这里
            try {
              // 如果后端跑异常,则能解析成功, 否则解析不成功
              let resp = JSON.parse(xhr.responseText)
              console.log('response: ', resp)
            } catch (e) {
              this.imageUrl = xhr.responseText
            }
          }
        }

        // 添加参数
        rst.formData.append('folder', this.folder) // 保存的文件夹
        rst.formData.append('base64', rst.base64)
        // 触发上传
        xhr.send(rst.formData)

        return rst
      })
    },
    // 移除图片
    remove () {
      this.imageUrl = ''
    }
  }
}
&amp;lt;/script&amp;gt;

&amp;lt;style lang=&quot;less&quot; scoped&amp;gt;
.imgUploader {
  margin-top: 0.5rem;
  .file-item {
    float: left;
    position: relative;
    width: 100px;
    text-align: center;
    left: 2rem;
    img {
      width: 100px;
      height: 100px;
      border: 1px solid #ececec;
    }
    .file-remove {
      position: absolute;
      right: 0px;
      top: 4px;
      width: 14px;
      height: 14px;
      color: white;
      cursor: pointer;
      line-height: 12px;
      border-radius: 100%;
      transform: rotate(45deg);
      background: rgba(0, 0, 0, 0.5);
    }

    &amp;amp;:hover .file-remove {
      display: inline;
    }
    .file-name {
      margin: 0;
      height: 40px;
      word-break: break-all;
      font-size: 14px;
      overflow: hidden;
      text-overflow: ellipsis;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
    }
  }
  .add {
    width: 100px;
    height: 100px;
    float: left;
    text-align: center;
    line-height: 100px;
    font-size: 30px;
    cursor: pointer;
    border: 1px dashed #40c2da;
    color: #40c2da;
    position: relative;
    background: #ffffff;
    .icon {
      font-size: 1.4rem;
      color: #7dd2d9;
      vertical-align: -0.25rem;
    }
    .text {
      font-size: 1.2rem;
      color: #7dd2d9;
      vertical-align: 0.25rem;
    }
  }
}
input[type=&quot;file&quot;] {
  position: absolute;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  border: 1px solid #000;
  opacity: 0;
}
&amp;lt;/style&amp;gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;后端api对图片的处理，是必不可少的环节，需要将前端提交过来的base64字符串转换成图片格式，并存放至指定的文件夹，接口返回图片的Url路径。各项目后端对图片的处理逻辑都不一致，以下方案仅供参考(&lt;span&gt;我们使用asp.net MVC 构建了独立的文件存储站点&lt;/span&gt;)。&lt;br/&gt;其核心源码,如下:&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// 图片文件base64上传
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;folder&quot;&amp;gt;对应文件夹位置&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&quot;base64&quot;&amp;gt;图片文件base64字符串&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
public ActionResult Base64FileUpload(string folder, string base64)
{
    var context = System.Web.HttpContext.Current;
    context.Response.ClearContent();
    // 因为前端调用时，需要做跨域处理
    context.Response.AddHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);
    context.Response.AddHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;POST, GET, OPTIONS&quot;);
    context.Response.AddHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;content-type&quot;);
    context.Response.AddHeader(&quot;Access-Control-Max-Age&quot;, &quot;30&quot;);
    if (context.Request.HttpMethod.Equals(&quot;OPTIONS&quot;))
    {
        return Content(&quot;&quot;);
    }

    var resultStr = base64.Substring(base64.IndexOf(&quot;,&quot;) + 1);//需要去掉头部信息，这很重要
    byte[] bytes = Convert.FromBase64String(resultStr);
    var fileName = Guid.NewGuid().ToString() + &quot;.png&quot;;
    if (folder.IsEmpty()) folder = &quot;folder&quot;;
    //本地上传
    string root = string.Format(&quot;/Resource/{0}/&quot;, folder);
    string virtualPath = root + fileName;
    string path = Server.MapPath(&quot;~&quot; + virtualPath);
    //创建文件夹
    if (!Directory.Exists(Path.GetDirectoryName(path)))
    {
        Directory.CreateDirectory(Path.GetDirectoryName(path));
    }
    System.IO.MemoryStream ms = new System.IO.MemoryStream(bytes);//转换成无法调整大小的MemoryStream对象
    System.Drawing.Bitmap bitmap = new System.Drawing.Bitmap(ms);
    bitmap.Save(path, System.Drawing.Imaging.ImageFormat.Png);//保存到服务器路径
    ms.Close();//关闭当前流，并释放所有与之关联的资源
    return Content(Net.Url + virtualPath); //返回文件路径
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;由于项目实际情况，上述的方案中还存在诸多未完善的点:&lt;br/&gt;1、多张图片上传，还是采用的与单张图片相同的接口处理, 更为完善的方案是，前端的多图上传组件只绑定一个关联Id，即可通过实现上传和将图片列表查询展示(&lt;span&gt;注:该功能在微信端未实现&lt;/span&gt;)。&lt;br/&gt;2、后端图片上传的接口，未做严格的安全校验，更为完善的方案是，每个上传的场景，都应该限制文件类型，限制文件大小，以及文件数据来源校验(&lt;span&gt;注: 如软件需要按二级等保标准测评，则后端接口会检测通不过&lt;/span&gt;)。&lt;br/&gt;3、上传组件，未显示上传进度，体验性稍差。&lt;br/&gt;正如前文所述，出于项目实际情况考虑，只是简单实现图片压缩上传功能，如要支持更多的场景，还得细细雕琢。&lt;/p&gt;

&lt;p&gt;1、&lt;a href=&quot;https://segmentfault.com/a/1190000010034177&quot;&gt;移动端H5实现图片上传&lt;/a&gt;&lt;br/&gt;2、&lt;a href=&quot;https://blog.csdn.net/nabywe/article/details/79068470&quot;&gt;安卓版微信 input onchange事件不生效&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 24 Jun 2019 15:08:00 +0000</pubDate>
<dc:creator>沉淀的风</dc:creator>
<og:description>业务场景 微信端项目是基于Vux + Axios构建的，关于图片上传的业务场景有以下几点需求: 1、单张图片上传(如个人头像,实名认证等业务) 2、多张图片上传(如某类工单记录) 3、上传图片时期望能</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xyb0226/p/11080137.html</dc:identifier>
</item>
<item>
<title>自定义Spring Shell - 2Simple</title>
<link>http://www.cnblogs.com/nuccch/p/11080056.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nuccch/p/11080056.html</guid>
<description>&lt;h2 id=&quot;目录&quot;&gt;目录&lt;/h2&gt;
&lt;h2 id=&quot;概述&quot;&gt;概述&lt;/h2&gt;
&lt;p&gt;官网：&lt;a href=&quot;https://projects.spring.io/spring-shell/&quot; class=&quot;uri&quot;&gt;https://projects.spring.io/spring-shell/&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;Spring Shell除了提供一些常用的内置命令之外，还允许开发者对一些默认功能进行定制。&lt;/p&gt;
&lt;h2 id=&quot;自定义内置命令&quot;&gt;自定义内置命令&lt;/h2&gt;
&lt;h3 id=&quot;禁用内置命令&quot;&gt;禁用内置命令&lt;/h3&gt;
&lt;p&gt;禁用Spring Shell的内置命令非常简单，只需要在pom.xml文件中进行简单配置即可，如下所示：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;!-- Spring Shell --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.shell&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-shell-starter&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.0.0.RELEASE&amp;lt;/version&amp;gt;
    &amp;lt;exclusions&amp;gt;
        &amp;lt;!-- 禁用内置命令 --&amp;gt;
        &amp;lt;exclusion&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.shell&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-shell-standard-commands&amp;lt;/artifactId&amp;gt;
        &amp;lt;/exclusion&amp;gt;
    &amp;lt;/exclusions&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;shell:&amp;gt;help
No command found for 'help'
shell:&amp;gt;exit
No command found for 'exit'
shell:&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;完全禁用了所有内置命令之后，将无法通过&lt;code&gt;help&lt;/code&gt;命令查询其他命令信息，也不能再使用&lt;code&gt;exit&lt;/code&gt;命令退出应用。&lt;br/&gt;因此，如果有需要的情况下，应该只是禁用某些内置命令。&lt;/p&gt;
&lt;p&gt;如果需要禁用指定内置命令，需要在代码中设置对应的命令属性为false，格式为：&lt;code&gt;spring.shell.command.&amp;lt;command&amp;gt;.enabled=true&lt;/code&gt;。&lt;br/&gt;例如，需要禁用&lt;code&gt;help&lt;/code&gt;命令：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@SpringBootApplication
public class TestSpringshellApplication {
    public static void main(String[] args) {
        String[] disabledCommands = new String[]{&quot;--spring.shell.command.help.enabled=false&quot;};
        String[] fullArgs = StringUtils.concatenateStringArrays(args, disabledCommands);
        SpringApplication.run(TestSpringshellApplication.class, fullArgs);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# help命令将不再能使用
shell:&amp;gt;help
No command found for 'help'
Details of the error have been omitted. You can use the stacktrace command to print the full stacktrace.
shell:&amp;gt;exit&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果禁用的是其他命令，如：&lt;code&gt;clear&lt;/code&gt;，在Spring Shell应用启动之后通过&lt;code&gt;help&lt;/code&gt;命令不再能看被禁用的命令了。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@SpringBootApplication
public class TestSpringshellApplication {
    public static void main(String[] args) {
        // 禁用了内置的clear命令
        String[] disabledCommands = new String[]{&quot;--spring.shell.command.clear.enabled=false&quot;};
        String[] fullArgs = StringUtils.concatenateStringArrays(args, disabledCommands);
        SpringApplication.run(TestSpringshellApplication.class, fullArgs);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;shell:&amp;gt;help
AVAILABLE COMMANDS

Built-In Commands
        exit, quit: Exit the shell.
        help: Display help about available commands.
        script: Read and execute commands from a file.
        stacktrace: Display the full stacktrace of the last error.
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;显然，在禁用了指定的内置命令之后，通过&lt;code&gt;help&lt;/code&gt;命令将不能看到该命令了。&lt;/p&gt;
&lt;h3 id=&quot;覆盖内置命令&quot;&gt;覆盖内置命令&lt;/h3&gt;
&lt;p&gt;如果希望重写内置命令的实现，可以通过实现接口&lt;code&gt;org.springframework.shell.standard.commands.&amp;lt;Command&amp;gt;.Command&lt;/code&gt;来完成（如：需要重写clear命令的实现，实现接口&lt;code&gt;org.springframework.shell.standard.commands.Clear.Command&lt;/code&gt;）。&lt;br/&gt;如下为重写内置命令script的实现：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import org.springframework.shell.standard.ShellComponent;
import org.springframework.shell.standard.ShellMethod;
import org.springframework.shell.standard.commands.Script;
// 实现接口org.springframework.shell.standard.commands.Script.Command
@ShellComponent
public class MyScript implements Script.Command {
    // 注意：命令名称与内置命令保持一致
    @ShellMethod(&quot;Read and execute commands from a file.&quot;)
    public void script() {
      / // 实现自定义逻辑
        System.out.println(&quot;override default script command&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有意思的是，此时在内置命令“Built-In Commands”分组中将不能看到&lt;code&gt;script&lt;/code&gt;命令了，而是在自定义的分组中，&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;shell:&amp;gt;help
AVAILABLE COMMANDS

Built-In Commands  # 在内置命令分组中看不到重写的命令了
        clear: Clear the shell screen.
        exit, quit: Exit the shell.
        help: Display help about available commands.
        stacktrace: Display the full stacktrace of the last error.

My Script          # 重写的命令此时在自定义分组中
        scriptdo: Read and execute commands from a file.
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果希望被覆盖的内置命令依然能够在“Built-In Commands”分组中看到，可以通过注解&lt;code&gt;@ShellMethod&lt;/code&gt;的group属性指定。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 指定被覆盖的内置命令分组为“Built-In Commands”
@ShellMethod(value = &quot;Read and execute commands from a file.&quot;, group = &quot;Built-In Commands&quot;)
public void script() {
    System.out.println(&quot;override default script command&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;shell:&amp;gt;help
AVAILABLE COMMANDS

Built-In Commands
        clear: Clear the shell screen.
        exit, quit: Exit the shell.
        help: Display help about available commands.
        script: Read and execute commands from a file.
        stacktrace: Display the full stacktrace of the last error.

shell:&amp;gt;script
override default script command&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;自定义命令提示符&quot;&gt;自定义命令提示符&lt;/h2&gt;
&lt;p&gt;默认情况下，Spring Shell启动之后显示的是一个黄色的命令提示符（&lt;code&gt;shell:&amp;gt;&lt;/code&gt;）等待用户输入。&lt;br/&gt;可以通过Spring Shell提供的接口&lt;code&gt;org.springframework.shell.jline.PromptProvider&lt;/code&gt;对该命令提示符进行定制。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 通过实现接口org.springframework.shell.jline.PromptProvider定制命令提示符
import org.jline.utils.AttributedString;
import org.jline.utils.AttributedStyle;
import org.springframework.shell.jline.PromptProvider;
import org.springframework.stereotype.Component;
@Component
public class MyPromptProvider implements PromptProvider {
    @Override
    public AttributedString getPrompt() {
        // 定制命令提示符为红色的“#”
        return new AttributedString(&quot;#&quot;, AttributedStyle.DEFAULT.foreground(AttributedStyle.RED));
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如下为定制的命令提示符：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/722072/201906/722072-20190624225006592-1976963542.png&quot; alt=&quot;Spring Shell定制命令提示符&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;自定义命令行选项行为&quot;&gt;自定义命令行选项行为&lt;/h2&gt;
&lt;p&gt;Spring Shell提供了2个默认的&lt;code&gt;ApplicationRunner&lt;/code&gt;，用于实现命令行选项的行为。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/722072/201906/722072-20190624225038936-159179816.png&quot; alt=&quot;Spring Shell实现的AppicationRunner&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1.&lt;code&gt;InteractiveShellApplicationRunner&lt;/code&gt;用于启动交互式界面，接收用户输入命令。&lt;br/&gt;2.&lt;code&gt;ScriptShellApplicationRunner&lt;/code&gt;用于在应用启动时从程序参数中读取指定文件中的命令并执行，具体来讲：将多个命令写在文件中，并通过参数的形式将包含了批量命令的文件路径传递给程序，传递的文件路径参数必须以“@”开始，如下示例：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ java -jar /home/test/sun/workspace/test-springshell/target/test-springshell-0.0.1-SNAPSHOT.jar @/home/test/cmd&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;文件&lt;code&gt;/home/test/cmd&lt;/code&gt;中的内容为：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ cat /home/test/cmd 
help&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样，在启动程序时，将会自动执行&lt;code&gt;/home/test/cmd&lt;/code&gt;文件中的命令（如果文件不存在，启动应用时报错）。&lt;br/&gt;&lt;strong&gt;值得注意的是：&lt;/strong&gt; 当在程序参数中存在“@local_file_path”这样的参数时，应用启动后执行完文件“local_file_path”内命令之后就退出了，不会进入交互式命令行界面（上述示例中，应用启动后执行&lt;code&gt;help&lt;/code&gt;命令之后就退出了）。&lt;/p&gt;
&lt;p&gt;如果Spring Shell默认提供的上述2个&lt;code&gt;ApplicationRunner&lt;/code&gt;无法满足需求，可以自定义其他的命令行选项行为，直接实现接口&lt;code&gt;org.springframework.boot.ApplicationRunner&lt;/code&gt;即可。&lt;/p&gt;
&lt;h2 id=&quot;自定义参数转换器&quot;&gt;自定义参数转换器&lt;/h2&gt;
&lt;p&gt;默认情况下，Spring Shell使用&lt;a href=&quot;https://docs.spring.io/spring/docs/4.3.11.RELEASE/spring-framework-reference/htmlsingle/#core-convert&quot;&gt;标准的Spring类型转换机制&lt;/a&gt;将命令行的文本参数转换为指定的类型。&lt;br/&gt;实际上，Spring Shell是通过&lt;code&gt;DefaultConversionService&lt;/code&gt;注册&lt;code&gt;Converter&amp;lt;S, T&amp;gt;&lt;/code&gt;，&lt;code&gt;GenericConverter&lt;/code&gt;或者&lt;code&gt;ConverterFactory&amp;lt;S, R&amp;gt;&lt;/code&gt;类型的Bean对象来实现对命令行参数进行类型转换的。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/722072/201906/722072-20190624225109728-997928686.png&quot; alt=&quot;注册Spring Shell类型转换器&quot;/&gt;&lt;/p&gt;
&lt;p&gt;换句话说，如果我们需要自定义类型转换器，只需要简单实现接口&lt;code&gt;org.springframework.core.convert.converter.Converter&amp;lt;S, T&amp;gt;&lt;/code&gt;就可以了。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/722072/201906/722072-20190624225134253-1752532500.png&quot; alt=&quot;Spring Shell的类型转化器&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 自定义类型
public class Food {
    private String value = null;
    public Food(String value) {
        this.value = value;
    }

    @Override
    public String toString() {
        return new StringBuilder()
                .append(&quot;Food{&quot;).append(&quot;value='&quot;).append(value).append(&quot;'}&quot;)
                .toString();
    }
}

// 自定义类型转换器
@Component
public class MyConverter implements Converter&amp;lt;String, Food&amp;gt; {
    @Override
    public Food convert(String s) {
        // 将输入参数转换为Food类型实例
        return new Food(s);
    }
}

// 使用自定义转换类型
@ShellComponent
public class ConvertionCmd {
    // 在命令方法中直接可以获取Food对象，这是通过前面的自定义类型转换器MyConverter实现的
    @ShellMethod(&quot;Conversion food&quot;)
    public String food(Food food) {
        return food.toString();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在命令行指定命令&lt;code&gt;food&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;#food apple
Food{value='apple'}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;显然，通过自定义类型转换器可以实现对命令参数的特殊处理，非常实用。&lt;/p&gt;
&lt;p&gt;【参考】&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/zknxx/article/details/52196427&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/zknxx/article/details/52196427&lt;/a&gt; SpringBoot之CommandLineRunner接口和ApplicationRunner接口&lt;br/&gt;&lt;a href=&quot;https://www.jianshu.com/p/5d4ffe267596&quot; class=&quot;uri&quot;&gt;https://www.jianshu.com/p/5d4ffe267596&lt;/a&gt; CommandLineRunner或者ApplicationRunner接口&lt;/p&gt;
</description>
<pubDate>Mon, 24 Jun 2019 14:52:00 +0000</pubDate>
<dc:creator>2Simple</dc:creator>
<og:description>目录 '概述' '自定义内置命令' '禁用内置命令' '覆盖内置命令' '自定义命令提示符' '自定义命令行选项行为' '自定义参数转换器' 概述 官网：。 Spring Shell除了提供一些常用的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/nuccch/p/11080056.html</dc:identifier>
</item>
</channel>
</rss>