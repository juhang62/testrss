<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Spring Cloud（二）：Eureka 服务注册中心 - 朝雾轻寒</title>
<link>http://www.cnblogs.com/zwqh/p/12008993.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zwqh/p/12008993.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;h3 id=&quot;服务治理&quot;&gt;服务治理&lt;/h3&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;随着业务的发展，微服务应用也随之增加，这些服务的管理和治理会越来越难，并且集群规模、服务位置、服务命名都会发生变化，手动维护的方式极易发生错误或是命名冲突等问题。而服务治理正是为了解决这个问题，服务治理是微服务架构中最为核心和基础的模块，它主要实现各个微服务实例的&lt;strong&gt;自动化注册和发现&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;服务注册&quot;&gt;服务注册&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;在服务治理框架中，都会构建一个或多个服务注册中心。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;每个服务模块向注册中心登记自己所提供的服务，将主机host、端口号、版本号、通信协议等一些附加信息告知注册中心，注册中心按服务名分类组织服务清单。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;服务注册中心还需要以心跳的方式去监测清单中的服务是否可用，若不可用需要从服务清单中剔除，达到排除故障服务的效果。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;服务发现&quot;&gt;服务发现&lt;/h4&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;服务间调用不再通过指定具体实例地址来实现，而是通过向服务名发起请求调用实现。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;服务调用方需要先从服务注册中心获取所有服务的实例清单，才能实现对具体服务实例的访问。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;服务调用方在发起调用时，会以某种策略取出一个具体的服务实例进行服务调用(客户端负载均衡)。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;在生产环境中为了考虑性能等因素，不会采用每次都向服务注册中心获取服务的方式，并且不同的应用场景在缓存和服务剔除等机制上也会采用不同的实现策略。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;spring-cloud-eureka&quot;&gt;Spring Cloud Eureka&lt;/h2&gt;
&lt;p&gt;Spring Cloud Eureka 是基于 Netflix Eureka 来实现服务注册和发现的。它主要包括两个组件：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Eureka Server（服务端）&lt;/strong&gt;：服务注册中心，支持高可用配置，依托于强一致性提供良好的服务实例可用性，服务注册中心之间可以通过异步模式互相复制各自的状态。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Eureka Client（客户端）&lt;/strong&gt;：处理服务的注册与发现，客户端可以通过注解和参数配置的方式实现注册与发现，客户端向注册中心注册自身提供的服务并周期性地发送心跳来更新它的服务租约，Eureka客户端从服务端查询当前注册的服务信息并把它们缓存到本地并周期性的刷新服务状态。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Eureka 基础架构&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;服务注册中心（Eureka Server）&lt;/strong&gt;：服务端，提供服务注册和发现功能。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;服务提供者（Service Provider）&lt;/strong&gt;：提供服务的应用，将自己提供的服务注册到 Eureka Server，供其他应用发现。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;服务消费者（Service Consumer）&lt;/strong&gt;：消费者应用从 Eureka Server 获取服务列表，从而调用对应的服务（ribbon或者feign）。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;基础架构图&lt;br/&gt;&lt;img src=&quot;https://img.zwqh.top/article/2019/12/1575709958349.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img.zwqh.top/article/2019/12/1575710023957.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;快速搭建服务注册中心eureka-server&quot;&gt;快速搭建服务注册中心（Eureka Server）&lt;/h3&gt;
&lt;h4 id=&quot;创建-spring-boot-项目添加依赖&quot;&gt;1. 创建 Spring Boot 项目，添加依赖&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;properties&amp;gt;
        &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt;
        &amp;lt;spring-cloud.version&amp;gt;Hoxton.RELEASE&amp;lt;/spring-cloud.version&amp;gt;
    &amp;lt;/properties&amp;gt;

    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-server&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
            &amp;lt;exclusions&amp;gt;
                &amp;lt;exclusion&amp;gt;
                    &amp;lt;groupId&amp;gt;org.junit.vintage&amp;lt;/groupId&amp;gt;
                    &amp;lt;artifactId&amp;gt;junit-vintage-engine&amp;lt;/artifactId&amp;gt;
                &amp;lt;/exclusion&amp;gt;
            &amp;lt;/exclusions&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;

    &amp;lt;dependencyManagement&amp;gt;
        &amp;lt;dependencies&amp;gt;
            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-cloud-dependencies&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;${spring-cloud.version}&amp;lt;/version&amp;gt;
                &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt;
                &amp;lt;scope&amp;gt;import&amp;lt;/scope&amp;gt;
            &amp;lt;/dependency&amp;gt;
        &amp;lt;/dependencies&amp;gt;
    &amp;lt;/dependencyManagement&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;enableeurekaserver-注解启动服务注册中心&quot;&gt;2. @EnableEurekaServer 注解启动服务注册中心&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;@SpringBootApplication
@EnableEurekaServer
public class SpringCloudEurekaServerApplication {

    public static void main(String[] args) {
        SpringApplication.run(SpringCloudEurekaServerApplication.class, args);
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;配置文件-application.properties&quot;&gt;3. 配置文件 application.properties&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;server.port=9999
#eureka
eureka.instance.hostname=127.0.0.1
eureka.client.register-with-eureka=false
eureka.client.fetch-registry=false
eureka.client.serviceUrl.defaultZone=http://${eureka.instance.hostname}:${server.port}/eureka/&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;eureka.client.register-with-eureka：当前应用为服务注册中心，所以设置为false，代表不向注册中心注册自己。&lt;/li&gt;
&lt;li&gt;eureka.client.fetch-registry：注册中心的职责主要是维护服务实例，所以设置为false，代表不去检索当前应用的服务。&lt;/li&gt;
&lt;li&gt;eureka.client.serviceUrl.defaultZone：用于与 Eureka Server 交互的地址，注册服务和发现服务都需要依赖这个地址。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;启动应用访问http127.0.0.19999&quot;&gt;4.启动应用，访问：http://127.0.0.1:9999/&lt;/h4&gt;
&lt;p&gt;可以看到 Eureka 的信息面板，其中 Instances currently registered with Eureka 中列表显示 No instances available，说明该注册中心还没有注册任何服务。&lt;br/&gt;&lt;img src=&quot;https://img.zwqh.top/article/2019/12/1575536893189.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;服务提供者service-provider&quot;&gt;服务提供者（Service Provider）&lt;/h3&gt;
&lt;h4 id=&quot;创建-spring-boot-项目添加依赖-1&quot;&gt;1. 创建 Spring Boot 项目，添加依赖&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;properties&amp;gt;
        &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt;
        &amp;lt;spring-cloud.version&amp;gt;Hoxton.RELEASE&amp;lt;/spring-cloud.version&amp;gt;
    &amp;lt;/properties&amp;gt;

    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-client&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
            &amp;lt;exclusions&amp;gt;
                &amp;lt;exclusion&amp;gt;
                    &amp;lt;groupId&amp;gt;org.junit.vintage&amp;lt;/groupId&amp;gt;
                    &amp;lt;artifactId&amp;gt;junit-vintage-engine&amp;lt;/artifactId&amp;gt;
                &amp;lt;/exclusion&amp;gt;
            &amp;lt;/exclusions&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;

    &amp;lt;dependencyManagement&amp;gt;
        &amp;lt;dependencies&amp;gt;
            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-cloud-dependencies&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;${spring-cloud.version}&amp;lt;/version&amp;gt;
                &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt;
                &amp;lt;scope&amp;gt;import&amp;lt;/scope&amp;gt;
            &amp;lt;/dependency&amp;gt;
        &amp;lt;/dependencies&amp;gt;
    &amp;lt;/dependencyManagement&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;enablediscoveryclient-注解启动-eureka-客户端&quot;&gt;2. @EnableDiscoveryClient 注解启动 Eureka 客户端&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;@SpringBootApplication
//@EnableEurekaClient  该注解在采用eureka作为注册中心时使用，场景较为单一
@EnableDiscoveryClient //场景更为广泛
public class SpringCloudEurekaServiceApplication {

    public static void main(String[] args) {
        SpringApplication.run(SpringCloudEurekaServiceApplication.class, args);
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;@EnableEurekaClient&lt;/code&gt; 和 &lt;code&gt;@EnableDiscoveryClient&lt;/code&gt; 在当前示例中使用效果好是一样的，&lt;code&gt;@EnableEurekaClient&lt;/code&gt; 注解在采用eureka作为注册中心时使用，场景较为单一，&lt;code&gt;@EnableDiscoveryClient&lt;/code&gt; 场景更为广泛。&lt;/p&gt;
&lt;h4 id=&quot;配置文件-application.properties-1&quot;&gt;3. 配置文件 application.properties&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;server.port=8888
spring.application.name=spring-cloud-eureka-service
#info 应用信息
info.app.name=spring-cloud-eureka-service
info.app.version=v1.0.0
info.app.description=spring-cloud-eureka-service
#eureka
eureka.instance.hostname=127.0.0.1
#每隔5s心跳一次,证明本服务还活着
eureka.instance.lease-renewal-interval-in-seconds=5
#本服务10s内没有心跳,就将该服务从服务端剔除
eureka.instance.lease-expiration-duration-in-seconds=10
eureka.client.serviceUrl.defaultZone=http://127.0.0.1:9999/eureka/
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;eureka.instance.lease-renewal-interval-in-seconds：设置心跳间隔秒数&lt;/li&gt;
&lt;li&gt;eureka.instance.lease-expiration-duration-in-seconds：设置秒数内无心跳，则剔除服务&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;启动应用访问http127.0.0.19999-1&quot;&gt;4. 启动应用，访问：http://127.0.0.1:9999/&lt;/h4&gt;
&lt;p&gt;在服务注册中心的控制台中我们可以看到如下输出，说明服务被注册成功了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; c.n.e.registry.AbstractInstanceRegistry  : Registered instance SPRING-CLOUD-EUREKA-SERVICE/192.168.101.201:spring-cloud-eureka-service:8888 with status UP (replication=false)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而在 Eureka 的信息面板上，在 Instances currently registered with Eureka 列表中同样可以看到服务的注册信息。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.zwqh.top/article/2019/12/1575536951943.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;高可用注册中心集群&quot;&gt;高可用注册中心（集群）&lt;/h3&gt;
&lt;p&gt;上面介绍了单节点模式的服务注册中心，不过在实际生产环境中，通常不会采用这种模式。在分布式系统中，服务注册中心是非常重要的组成部分，如果是单节点模式，发生故障的话将会是毁灭性的灾害。所以为了维护服务的高可用性，通常采用集群的解决方案。&lt;/p&gt;
&lt;p&gt;Eureka 的服务治理设计中，所有的节点既是服务提供方，也是服务消费方，服务注册中心也不例外。Eureka 通过互相注册服务的方式，以实现服务清单的互相同步，达到高可用的效果。&lt;/p&gt;
&lt;h4 id=&quot;双节点注册中心&quot;&gt;双节点注册中心&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;搭建服务注册中心 A，配置文件如下：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;server.port=9991
spring.application.name=eureka-server
spring.profiles.active=nodea
#eureka
eureka.instance.hostname=nodea
#设置微服务调用地址为IP优先（缺省为false）
#eureka.instance.prefer-ip-address=true
eureka.client.serviceUrl.defaultZone=http://nodeb:9992/eureka/&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;搭建服务注册中心 B，配置文件如下：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;server.port=9992
spring.application.name=eureka-server
spring.profiles.active=nodeb
#eureka
eureka.instance.hostname=nodeb
#设置微服务调用地址为IP优先（缺省为false）
#eureka.instance.prefer-ip-address=true
eureka.client.serviceUrl.defaultZone=http://nodea:9991/eureka/&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;在 /etc/hosts（windows系统路径为 C:\Windows\System32\drivers\etc\hosts） 文件中添加 nodea 和 nodeb 的转换，如下：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;127.0.0.1 nodea
127.0.0.1 nodeb&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;启动两个项目，分别访问&lt;code&gt;http://nodea:9991/&lt;/code&gt;和&lt;code&gt;http://nodeb:9992/&lt;/code&gt;，我们可以看到两个节点都已经被注册，如下图所示：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img.zwqh.top/article/2019/12/1575599125564.png&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;搭建完多节点服务注册中心之后，服务提供者也需要做一些简单的配置，以上面的服务提供者为例，修改如下:&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;eureka.client.serviceUrl.defaultZone=http://nodea:9991/eureka/,http://nodeb:9992/eureka/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动项目后，访问两个服务注册中心，我们看到服务被注册到这两个节点内。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.zwqh.top/article/2019/12/1575599177918.png&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;这时我们关闭服务注册中心节点 A，我们可以看到服务注册中心节点 B 依然可以提供服务，而节点 A 从 available-replicas（可以分片） 变为 unavailable-replicas（不可用分片）。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img.zwqh.top/article/2019/12/1575599229993.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;服务消费者service-consumer&quot;&gt;服务消费者（Service Consumer）&lt;/h3&gt;
&lt;h4 id=&quot;使用-ribbon-调用服务&quot;&gt;使用 Ribbon 调用服务&lt;/h4&gt;
&lt;h5 id=&quot;pom-相关依赖配置&quot;&gt;1. pom 相关依赖配置&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;properties&amp;gt;
        &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt;
        &amp;lt;spring-cloud.version&amp;gt;Hoxton.RELEASE&amp;lt;/spring-cloud.version&amp;gt;
    &amp;lt;/properties&amp;gt;

    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-server&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-ribbon&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;

    &amp;lt;dependencyManagement&amp;gt;
        &amp;lt;dependencies&amp;gt;
            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-cloud-dependencies&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;${spring-cloud.version}&amp;lt;/version&amp;gt;
                &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt;
                &amp;lt;scope&amp;gt;import&amp;lt;/scope&amp;gt;
            &amp;lt;/dependency&amp;gt;
        &amp;lt;/dependencies&amp;gt;
    &amp;lt;/dependencyManagement&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;配置文件-application.properties-2&quot;&gt;2. 配置文件 application.properties&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;spring.application.name=spring-cloud-ribbon-consumer
server.port=8081
eureka.client.serviceUrl.defaultZone=http://nodea:9991/eureka/,http://nodeb:9992/eureka/&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;启动类配置&quot;&gt;3. 启动类配置&lt;/h5&gt;
&lt;p&gt;通过 &lt;code&gt;@EnableDiscoveryClient&lt;/code&gt; 注解将应用注册为 Eureka 客户端，获得服务发现能力。&lt;/p&gt;
&lt;p&gt;创建 RestTemplate 的 Spring Bean 实例用来调用服务。&lt;/p&gt;
&lt;p&gt;通过 &lt;code&gt;@LoadBalanced&lt;/code&gt; 注解来开启客户端的负载均衡。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@SpringBootApplication
@EnableDiscoveryClient
public class SpringCloudRibbonConsumerApplication {

    @Bean
    @LoadBalanced
    RestTemplate restTemplate(){
        return new RestTemplate();
    }
    
    public static void main(String[] args) {
        SpringApplication.run(SpringCloudRibbonConsumerApplication.class, args);
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;consumercontroller-来实现服务调用&quot;&gt;4. ConsumerController 来实现服务调用&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;@RestController
public class ConsumerController {

    @Autowired
    RestTemplate restTemplate;
    
    @RequestMapping(&quot;/test&quot;)
    public String test() {
        return restTemplate.getForEntity(&quot;http://spring-cloud-eureka-service/test&quot;, String.class).getBody();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;spring-cloud-eureka-service 为服务注册中心的应用名称，大小写均可。&lt;/p&gt;
&lt;h4 id=&quot;使用-feign-调用服务&quot;&gt;使用 Feign 调用服务&lt;/h4&gt;
&lt;h5 id=&quot;pom-相关依赖配置-1&quot;&gt;1. pom 相关依赖配置&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;properties&amp;gt;
        &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt;
        &amp;lt;spring-cloud.version&amp;gt;Hoxton.RELEASE&amp;lt;/spring-cloud.version&amp;gt;
    &amp;lt;/properties&amp;gt;

    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-server&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-cloud-starter-openfeign&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;

    &amp;lt;dependencyManagement&amp;gt;
        &amp;lt;dependencies&amp;gt;
            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-cloud-dependencies&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;${spring-cloud.version}&amp;lt;/version&amp;gt;
                &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt;
                &amp;lt;scope&amp;gt;import&amp;lt;/scope&amp;gt;
            &amp;lt;/dependency&amp;gt;
        &amp;lt;/dependencies&amp;gt;
    &amp;lt;/dependencyManagement&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;配置文件-application.properties-3&quot;&gt;2. 配置文件 application.properties&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;spring.application.name=spring-cloud-feign-consumer
server.port=8080
eureka.client.serviceUrl.defaultZone=http://nodea:9991/eureka/,http://nodeb:9992/eureka/&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;启动类配置-1&quot;&gt;3. 启动类配置&lt;/h5&gt;
&lt;p&gt;通过 &lt;code&gt;@EnableDiscoveryClient&lt;/code&gt; 注解将应用注册为 Eureka 客户端，获得服务发现能力。&lt;/p&gt;
&lt;p&gt;通过 &lt;code&gt;@EnableFeignClients&lt;/code&gt; 注解来启用feign进行远程调用。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@SpringBootApplication
@EnableDiscoveryClient//启用服务注册与发现
@EnableFeignClients//启用feign进行远程调用
public class SpringCloudFeignConsumerApplication {

    public static void main(String[] args) {
        SpringApplication.run(SpringCloudFeignConsumerApplication.class, args);
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;实现服务调用接口&quot;&gt;4. 实现服务调用接口&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;@FeignClient(name = &quot;spring-cloud-eureka-service&quot;)
public interface TestService {

    @RequestMapping(&quot;/test&quot;)
    public String test();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;spring-cloud-eureka-service 为服务注册中心的应用名称，大小写均可。&lt;/p&gt;
&lt;p&gt;此接口中的方法和远程服务中contoller中的方法名和参数需保持一致。&lt;/p&gt;
&lt;h5 id=&quot;consumercontroller-来实现服务调用-1&quot;&gt;5. ConsumerController 来实现服务调用&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;@RestController
public class ConsumerController {

    @Autowired
    private TestService testService;
    
    @RequestMapping(&quot;/test&quot;)
    public String test() {
        return testService.test();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;示例代码&quot;&gt;示例代码&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/zwqh1992/Spring-Cloud/tree/master/spring-cloud-eureka&quot; title=&quot;github&quot;&gt;github&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/zwqh/Spring-Cloud/tree/master/spring-cloud-eureka&quot; title=&quot;码云&quot;&gt;码云&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;4.2307692307692&quot;&gt;
&lt;p&gt;非特殊说明，本文版权归 &lt;a href=&quot;https://www.zwqh.top&quot; title=&quot;朝雾轻寒&quot;&gt;朝雾轻寒&lt;/a&gt; 所有，转载请注明出处.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;原文标题：Spring Cloud（二）：Eureka 服务注册中心&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;1.4705882352941&quot;&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;https://www.zwqh.top/article/info/28&quot; class=&quot;uri&quot;&gt;https://www.zwqh.top/article/info/28&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果文章有不足的地方，欢迎提点建议，后续会完善~&lt;/p&gt;
&lt;p&gt;如果文章对您有帮助，请给我点个赞哦~&lt;/p&gt;
&lt;p&gt;关注下我的公众号，文章持续更新中...&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.zwqh.top/logo/qrcode_for_wx.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 09 Dec 2019 00:54:00 +0000</pubDate>
<dc:creator>朝雾轻寒</dc:creator>
<og:description>前言 服务治理 随着业务的发展，微服务应用也随之增加，这些服务的管理和治理会越来越难，并且集群规模、服务位置、服务命名都会发生变化，手动维护的方式极易发生错误或是命名冲突等问题。而服务治理正是为了解决</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zwqh/p/12008993.html</dc:identifier>
</item>
<item>
<title>浅谈设计模式(一):状态模式|外观模式|代理模式 - 彭湖湾</title>
<link>http://www.cnblogs.com/penghuwan/p/12005845.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/penghuwan/p/12005845.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;计划开一个设计模式的系列，介绍常见的几种设计模式，本文涉及的设计模式包含以下3种&lt;/span&gt;&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;状态模式：state pattern&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;外观模式：facade pattern&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;代理模式：proxy pattern&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;备注&lt;/strong&gt;：下文适合看过《海贼王》的人阅读，没看过海贼王的观众请在父母陪同下阅读&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;9194-1575775169459&quot;&gt;&lt;span&gt;状态模式：state pattern&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;在状态模式的设计方案里，一个主类(称为context类)，可以在内部状态变化的时候一次性改变它的「所有行为」，而这个「所有行为」会被我们聚合到不同的类（state1,state2,state3）里面去。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个内部状态我们可以理解为一个可以手动设置的state变量，设置它可以让context内部的state1切换为state2，或者是从state2切换为state3。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这么做，相比起传统的代码逻辑会发生什么变化呢？在传统的代码里，我们可能会在每个方法下，都写一大段if-else的状态判断逻辑里，然后对不同状态分别做处理，这个时候代码非常松散，不利于阅读和扩展，所以我们选择以「状态」为依据, 把这些if-else的每一部分都「聚合」到不同的状态(不同的state类)里面去，然后通过一个主类(context)，去统一维护和管理。这样，逻辑上就清晰了很多，也大大降低了维护和扩展的难度。&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p id=&quot;9559-1575777161694&quot;&gt;&lt;strong&gt;&lt;span&gt;Example&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;草帽路飞，是热血漫《海贼王》的主角，像其他许多同类型的作品一样，主角有自己不同层次战斗的状态，进化过程如下所示&lt;/span&gt;&lt;/p&gt;
&lt;ol readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;二档：加速血液的流动，大幅提高速度和身体强度，代表大招是「橡胶Jet火箭炮」(拳)和 「橡胶Jet」(踢)&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;三档：向橡胶的身体吹入空气，使身体变成巨人，攻击力大增。代表大招是「橡胶巨人火箭炮」(拳)和「橡胶巨人战斧」(踢)&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;四档：将武装色霸气和橡胶果实融合，攻击和速度再次强化，代表大招是「橡胶狮子火箭炮」(拳)和「橡胶犀牛榴弹炮」(踢)&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下图描述的是主角路飞初次进化为「二档」的历史性时刻&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/9e839465d262ca20e12b9c759d07aa80/xmlnote/WEBRESOURCE047f96438b1f8314e3dd4255b3f3bf25/40250&quot; alt=&quot;&quot; width=&quot;562&quot; height=&quot;426&quot; data-media-type=&quot;image&quot; data-original=&quot;https://note.youdao.com/yws/public/resource/9e839465d262ca20e12b9c759d07aa80/xmlnote/WEBRESOURCE047f96438b1f8314e3dd4255b3f3bf25/40250&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们发现，主角路飞拥有不同的战斗状态：二档，三档，四档，并且大招的使用是类似的，无非就是用拳头还是用脚踢的问题，但是攻击力和招式上都不同，我们可以根据这个状态的统一性抽象一个state接口出来：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;para-text&quot; readability=&quot;31&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public interface State {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 拳打&lt;/span&gt;
    public &lt;span&gt;void&lt;/span&gt;&lt;span&gt; punch ();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 脚踢&lt;/span&gt;
    public &lt;span&gt;void&lt;/span&gt;&lt;span&gt; kick ();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;然后创建二档，三档，四档类，并且实现state接口&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;para-text&quot; readability=&quot;32.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 二档&lt;/span&gt;
&lt;span&gt;public class SecGearState implements State {
    public &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; punch () {
        System.out.println(&lt;/span&gt;&quot;二档：橡胶Jet火箭炮&quot;&lt;span&gt;);
    };
    public &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; kick () {
        System.out.println(&lt;/span&gt;&quot;二档：橡胶Jet鞭&quot;&lt;span&gt;);
    };
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 三档&lt;/span&gt;
&lt;span&gt;public class ThirdGearState implements State {
    public &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; punch () {
        System.out.println(&lt;/span&gt;&quot;三档：橡胶巨人火箭炮&quot;&lt;span&gt;);
    };
    public &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; kick () {
        System.out.println(&lt;/span&gt;&quot;三档：橡胶巨人战斧&quot;&lt;span&gt;);
    };
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 四档&lt;/span&gt;
&lt;span&gt;public class FourGearState implements State{
    public &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; punch () {
        System.out.println(&lt;/span&gt;&quot;四档：橡胶狮子火箭炮&quot;&lt;span&gt;);
    };
    public &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; kick () {
        System.out.println(&lt;/span&gt;&quot;四档：橡胶犀牛榴弹炮&quot;&lt;span&gt;);
    };
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;最后，路飞可能会在战斗中随时切换状态，比如从二档切换到三档，或者从三档切换到四档，所以我们要设置一个Context类去管理，在这个类里面，它有两个功能&lt;/span&gt;&lt;/p&gt;
&lt;ol readability=&quot;-2&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;span&gt;随时切换状态&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;代理调用状态类的方法&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;para-text&quot; readability=&quot;32&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public class Context {
    State state;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 随时切换状态&lt;/span&gt;
    public &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setState(State state){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.state =&lt;span&gt; state;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 代理调用状态类的方法&lt;/span&gt;
    public &lt;span&gt;void&lt;/span&gt;&lt;span&gt; punch () {
        state.punch();
    }
 
    public  &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; kick () {
        state.kick();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;测试&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;para-text&quot; readability=&quot;32.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public class Test {
    public static &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String args []) {
        State secGearState &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SecGearState();
        State thirdGearState &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThirdGearState();
        State fourGearState &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FourGearState();
        Context context &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Context();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 路飞进化成二档&lt;/span&gt;
&lt;span&gt;        context.setState(secGearState);
        context.punch();
        context.kick();
        System.out.println(&lt;/span&gt;&quot;----------------&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 路飞进化成三档&lt;/span&gt;
&lt;span&gt;        context.setState(thirdGearState);
        context.punch();
        context.kick();
        System.out.println(&lt;/span&gt;&quot;----------------&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 路飞进化成四档&lt;/span&gt;
&lt;span&gt;        context.setState(fourGearState);
        context.punch();
        context.kick();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p id=&quot;6245-1575783945628&quot;&gt;&lt;span&gt;输出&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/9e839465d262ca20e12b9c759d07aa80/xmlnote/WEBRESOURCEa636da9d98d85169c42657ca4174319c/40363&quot; alt=&quot;&quot; data-media-type=&quot;image&quot; data-original=&quot;https://note.youdao.com/yws/public/resource/9e839465d262ca20e12b9c759d07aa80/xmlnote/WEBRESOURCEa636da9d98d85169c42657ca4174319c/40363&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p id=&quot;5011-1575785711058&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;8520-1575785711197&quot;&gt;&lt;span&gt;外观模式：facade pattern&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;外观模式很简单且容易理解，但理解之后却非常有用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;说白了就是：把不同类的不同接口，统一代理到一个类里面对外输出，使代码具有良好的封装性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p id=&quot;8463-1575784708881&quot;&gt;&lt;strong&gt;&lt;span&gt;Example&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;咱们还是拿海贼王的一个情境举个例子&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如说，在海贼王367里，草帽海贼团 VS 巨人僵尸奥兹 的时候，索隆，山治，佛兰奇，乌索普和乔巴使用了一招非常精(you)彩(zhi)的技能：合体-大皇帝。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/9e839465d262ca20e12b9c759d07aa80/xmlnote/WEBRESOURCE361dcb7fcec80fb32d648b581776fbad/40335&quot; alt=&quot;&quot; data-media-type=&quot;image&quot; data-original=&quot;https://note.youdao.com/yws/public/resource/9e839465d262ca20e12b9c759d07aa80/xmlnote/WEBRESOURCE361dcb7fcec80fb32d648b581776fbad/40335&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;也就是说，合体后的草帽海贼团，在能够使用每个人的绝招的同时，是作为“大皇帝”这个整体对外暴露的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们使用外观模式去实现的话，代码逻辑如下所示&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先每个成员我们用一个类去表示&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;para-text&quot; readability=&quot;32.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 索隆&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Zoro {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; useSword () {
        System.out.println(&lt;/span&gt;&quot;三刀流斩击&quot;&lt;span&gt;);
    }
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 山治&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Sanj {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; kick () {
        System.out.println(&lt;/span&gt;&quot;恶魔风脚&quot;&lt;span&gt;);
    }
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 弗兰奇&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Franky {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; openFire () {
        System.out.println(&lt;/span&gt;&quot;风来炮&quot;&lt;span&gt;);
    }
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 爱吃棉花糖的乔巴&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; QiaoBa {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; cure () {
        System.out.println(&lt;/span&gt;&quot;回血治疗&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后我们用一个整体的类，去代理上面的每个成员类的逻辑&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;para-text&quot; readability=&quot;32.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 合体后的大皇帝&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BigKing {
    Franky franky;
    QiaoBa qiaoba;
    Sanj sanj;
    Zoro zoro;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; BigKing () {
        franky &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Franky();
        qiaoba &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QiaoBa();
        sanj &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Sanj();
        zoro &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Zoro();
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 索隆类的功能&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; useSord () {
        zoro.useSword();
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 山治类的功能&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; kick () {
        sanj.kick();
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 佛兰奇类的功能&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; openFire () {
        franky.openFire();
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 乔巴类的功能&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; cure () {
        qiaoba.cure();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;测试&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;para-text&quot; readability=&quot;31.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String args []) {
        BigKing bigking &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BigKing();
        bigking.useSord();
        bigking.kick();
        bigking.cure();
        bigking.openFire();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;输出&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/9e839465d262ca20e12b9c759d07aa80/xmlnote/WEBRESOURCE81cd95c8567519adf59d60bf60ea7f64/40367&quot; alt=&quot;&quot; data-media-type=&quot;image&quot; data-original=&quot;https://note.youdao.com/yws/public/resource/9e839465d262ca20e12b9c759d07aa80/xmlnote/WEBRESOURCE81cd95c8567519adf59d60bf60ea7f64/40367&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;附带一张图，hhhh&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/9e839465d262ca20e12b9c759d07aa80/xmlnote/WEBRESOURCEab6d23905269332cffa87cb7c2bb7e71/40344&quot; alt=&quot;&quot; width=&quot;477&quot; height=&quot;538&quot; data-media-type=&quot;image&quot; data-original=&quot;https://note.youdao.com/yws/public/resource/9e839465d262ca20e12b9c759d07aa80/xmlnote/WEBRESOURCEab6d23905269332cffa87cb7c2bb7e71/40344&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;5188-1575785886546&quot;&gt;&lt;span&gt;代理模式：proxy pattern&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;使用一个类接管另一个类所有的方法调用，同时能在原来类的方法调用前，加入一些自己的“中间逻辑”。这种方式被称为代理模式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假设类B 是类A的代理类，那么在调用类B的方法的时候，实际还是通过类B去调用类A的接口，但是现在所有的「控制权」都已经牢牢掌握在类B手里了，代理类B能够很自由的加入一些中间逻辑。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;显然，类B和类A起到的功能是相同的，我们可以抽象一个接口，去让原类(A )和代理类(B)去实现&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p id=&quot;1011-1575786223531&quot;&gt;&lt;strong&gt;&lt;span&gt;Example&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不好意思，这里还是用我熟悉的海贼王打个比方，在七武海-多佛朗明哥刚刚出场的时候，他就用线线果实提供的能力，操控两名海军自相残杀。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果我们把海军抽象为一个类的话，那么多佛朗明哥就是「海军类」的代理类了，实际上我们发现&lt;/span&gt;&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;实质出手伤人的并不是海军，而是多佛朗明哥，也就是代理类掌握了真正的控制权&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;直接出手伤人的仍然是海军，也就是代理类仍然调用的是原类的接口&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/9e839465d262ca20e12b9c759d07aa80/xmlnote/WEBRESOURCE6ba7b32010c152d1e11c6e4f6cc9904e/40385&quot; alt=&quot;&quot; data-media-type=&quot;image&quot; data-original=&quot;https://note.youdao.com/yws/public/resource/9e839465d262ca20e12b9c759d07aa80/xmlnote/WEBRESOURCE6ba7b32010c152d1e11c6e4f6cc9904e/40385&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/9e839465d262ca20e12b9c759d07aa80/xmlnote/WEBRESOURCE8ec6a9329b28cab9100ad14ce17a0004/40383&quot; alt=&quot;&quot; width=&quot;307&quot; height=&quot;173&quot; data-media-type=&quot;image&quot; data-original=&quot;https://note.youdao.com/yws/public/resource/9e839465d262ca20e12b9c759d07aa80/xmlnote/WEBRESOURCE8ec6a9329b28cab9100ad14ce17a0004/40383&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代码如下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.我们抽象一个海军战士的接口出来&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;para-text&quot; readability=&quot;31.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 海军战士接口&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; NavyFighter {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用刀剑&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; useSword ();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 徒手格斗&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; fight();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用枪炮&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; useGuns();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2.让海军军官实现这个接口&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;para-text&quot; readability=&quot;32.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; NavyCaptain &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; NavyFighter {
    String name &lt;/span&gt;= &quot;海军上尉&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 海军装备预算不够，不能购买二十一大快刀&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; useSword() {
      System.out.println(name &lt;/span&gt;+&quot;发动了一次普通的斩击&quot;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 没有果实能力，只能徒手格斗了&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; fight() {
        System.out.println(name &lt;/span&gt;+ &quot;发动了一次普通的拳击&quot;&lt;span&gt;);
    }
 
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; useGuns() {
        System.out.println(name &lt;/span&gt;+&quot;打出了一发普通的海楼石子弹&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;3.让多佛朗明哥也实现这个接口&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;para-text&quot; readability=&quot;34&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Doflamingo &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; NavyFighter {
    NavyFighter navyFighter;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Doflamingo (NavyFighter navyFighter) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.navyFighter =&lt;span&gt; navyFighter;
    }
 
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; useSword() {
        System.out.print(&lt;/span&gt;&quot;在多佛朗明哥操控下,&quot;&lt;span&gt;);
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.navyFighter.useSword();
    }
 
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; fight() {
        System.out.print(&lt;/span&gt;&quot;在多佛朗明哥操控下,&quot;&lt;span&gt;);
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.navyFighter.fight();
    }
 
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; useGuns() {
        System.out.print(&lt;/span&gt;&quot;在多佛朗明哥操控下,&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.navyFighter.useGuns();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;测试&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;para-text&quot; readability=&quot;32.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String args []) {
        NavyFighter navyCaptain &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NavyCaptain();
        navyCaptain.useSword();
        navyCaptain.fight();
        navyCaptain.useGuns();
        System.out.println(&lt;/span&gt;&quot;-----------------------------&quot;&lt;span&gt;);
        NavyFighter doflamingo &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Doflamingo(navyCaptain);
        doflamingo.useSword();
        doflamingo.fight();
        doflamingo.useSword();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;输出&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/9e839465d262ca20e12b9c759d07aa80/xmlnote/WEBRESOURCE886ff3065a65aa635b607045293e10b5/40406&quot; alt=&quot;&quot; width=&quot;614&quot; height=&quot;220&quot; data-media-type=&quot;image&quot; data-original=&quot;https://note.youdao.com/yws/public/resource/9e839465d262ca20e12b9c759d07aa80/xmlnote/WEBRESOURCE886ff3065a65aa635b607045293e10b5/40406&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;End&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 09 Dec 2019 00:50:00 +0000</pubDate>
<dc:creator>彭湖湾</dc:creator>
<og:description>计划开一个设计模式的系列，介绍常见的几种设计模式，本文涉及的设计模式包含以下3种:状态模式，外观模式和代理模式</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/penghuwan/p/12005845.html</dc:identifier>
</item>
<item>
<title>小白学 Python 爬虫（13）：urllib 基础使用（三） - 极客挖掘机</title>
<link>http://www.cnblogs.com/babycomeon/p/12008967.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/babycomeon/p/12008967.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201912/908359-20191209084441071-1306280917.jpg&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;人生苦短，我用 Python&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;前文传送门：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/13/3303836941/&quot;&gt;小白学 Python 爬虫（1）：开篇&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/20/2586166930/&quot;&gt;小白学 Python 爬虫（2）：前置准备（一）基本类库的安装&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/21/1005563697/&quot;&gt;小白学 Python 爬虫（3）：前置准备（二）Linux基础入门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/22/3679472340/&quot;&gt;小白学 Python 爬虫（4）：前置准备（三）Docker基础入门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/24/334078215/&quot;&gt;小白学 Python 爬虫（5）：前置准备（四）数据库基础&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/25/1881661601/&quot;&gt;小白学 Python 爬虫（6）：前置准备（五）爬虫框架的安装&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/26/1197821400/&quot;&gt;小白学 Python 爬虫（7）：HTTP 基础&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/27/101847406/&quot;&gt;小白学 Python 爬虫（8）：网页基础&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/28/1668465912/&quot;&gt;小白学 Python 爬虫（9）：爬虫基础&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/12/01/2475257648/&quot;&gt;小白学 Python 爬虫（10）：Session 和 Cookies&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/12/02/2333822325/&quot;&gt;小白学 Python 爬虫（11）：urllib 基础使用（一）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/12/03/819896244/&quot;&gt;小白学 Python 爬虫（12）：urllib 基础使用（二）&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;引言&quot;&gt;引言&lt;/h2&gt;
&lt;p&gt;前面两篇基础，我们介绍请求发送的过程。&lt;/p&gt;
&lt;p&gt;不知道各位同学有没有想过这样一个问题，如果在爬虫运行的过程中，网络突然波动了下，比如突然网速很慢很慢，造成当前的请求超时，程序很可能会直接挂掉。&lt;/p&gt;
&lt;p&gt;这种处理方式显然不是我们希望看到的，我们希望看到的肯定是如果当前的请求挂掉，那就挂掉，不要影响其他的请求或者是下一次的请求。&lt;/p&gt;
&lt;p&gt;那么，我们在发送请求的时候，异常处理就显得十分有必要。&lt;/p&gt;
&lt;p&gt;urllib 的 error 模块定义了由 request 模块产生的异常，如果出现问题， request 模块便会抛出 error 模块中定义的异常。&lt;/p&gt;
&lt;h2 id=&quot;urlerror&quot;&gt;URLError&lt;/h2&gt;
&lt;p&gt;URLError 这个类来自于 urllib 库的 error 模块，它继承自 OSError ，是 error 异常模块的基类，由 request 模块产生的异常都可以通过捕获这个类来处理。&lt;/p&gt;
&lt;p&gt;它只有一个属性 reason ，即返回错误的原因。&lt;/p&gt;
&lt;p&gt;我们来写一个简单的示例大家看一下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from urllib import request, error

# 访问明显不存在的地址，报错：Not Found
try:
    response = request.urlopen('https://www.geekdigging.com/aa')
except error.URLError as e:
    print(e.reason)

# 访问超时，报错：timed out
try:
    response = request.urlopen('https://www.baidu.com', timeout=0.001)
except error.URLError as e:
    print(e.reason)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我们访问了一个明显不存在的链接和限定了极短的超时时间，这里会抛出异常，但是我们捕获了 URLError 这个异常，运行结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Not Found
timed out&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;程序没有直接抛出异常终止运行，而是输出了上面这个异常，通过这样的操作，我们可以避免程序异常终止，同时还可以对这个异常做出针对性的处理。&lt;/p&gt;
&lt;p&gt;此外，异常捕捉抛出的异常不一定都是字符串类型，比如访问超时的报错，我们将打印结果的代码稍作改动：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from urllib import request, error
import socket

# 异常类型示例
try:
    response = request.urlopen('https://www.baidu.com', timeout=0.001)
except error.URLError as e:
    print(type(e.reason))
    if isinstance(e.reason, socket.timeout):
        print('TIME OUT')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;class 'socket.timeout'&amp;gt;
TIME OUT&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;httperror&quot;&gt;HTTPError&lt;/h2&gt;
&lt;p&gt;它是 URLError 的子类，专门用来处理 HTTP 请求错误，比如认证请求失败等。它有如下 3 个属性。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;code：返回HTTP状态码，比如404表示网页不存在，500表示服务器内部错误等。&lt;/li&gt;
&lt;li&gt;reason：同父类一样，用于返回错误的原因。&lt;/li&gt;
&lt;li&gt;headers：返回请求头。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;还是先看一个最简单的示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from urllib import request, error

# 访问明显不存在的地址，使用 HTTPError 捕捉异常
try:
    response = request.urlopen('https://www.geekdigging.com/aa')
except error.HTTPError as e:
    print(e.reason, e.code, e.headers, sep='\n')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Not Found
404
Date: Sun, 01 Dec 2019 15:11:48 GMT
Content-Type: text/html
Content-Length: 49307
Connection: close
Server: tencent-cos
Last-Modified: Sun, 01 Dec 2019 15:03:24 GMT
X-NWS-UUID-VERIFY: c89959eb27b89a0fb1c0326d1b2e7171
Accept-Ranges: bytes
ETag: &quot;1bb6cc2c28a5621cf0c3238107edc229&quot;
x-cos-error-code: NoSuchKey
x-cos-error-detail-Key: aa
x-cos-error-message: The specified key does not exist.
x-cos-request-id: NWRlM2Q4MzRfMzNhNzAzMDlfYTljZl8yNGU1NTgx
x-cos-trace-id: OGVmYzZiMmQzYjA2OWNhODk0NTRkMTBiOWVmMDAxODc0OWRkZjk0ZDM1NmI1M2E2MTRlY2MzZDhmNmI5MWI1OTQ5YWUxMjNkYTk3NzdjZmZlMDQzOTgxOThkOTNlOWFkOGJiN2YzOGQ5MDdjNGY0ODQ1MGIzYjUyMzg2NjFhNzc=
X-Daa-Tunnel: hop_count=2
X-NWS-LOG-UUID: 7c3fe80b-af9a-4e59-969b-10c8b3963a1d
X-Cache-Lookup: Hit From Upstream
X-Cache-Lookup: Hit From Upstream&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为 URLError 是 HTTPError 的父类，所以可以先选择捕获子类的错误，再去捕获父类的错误，这样对异常的处理更具针对性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 捕捉异常一般先捕捉子类异常，再捕捉父类异常。&lt;/p&gt;
&lt;p&gt;所以我们可以更改下前面的异常捕捉的代码进行一些优化：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 优化异常捕捉代码
try:
    response = request.urlopen('https://www.geekdigging.com/aa')
except error.HTTPError as e:
    print(e.reason, e.code, e.headers, sep='\n')
except error.URLError as e:
    print(e.reason)
else:
    print('Request Success!')&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;示例代码&quot;&gt;示例代码&lt;/h2&gt;
&lt;p&gt;本系列的所有代码小编都会放在代码管理仓库 Github 和 Gitee 上，方便大家取用。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/meteor1993/python-learning/tree/master/python-spider/urllib-request&quot; title=&quot;示例代码-Github&quot;&gt;示例代码-Github&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/inwsy/python-learning/tree/master/python-spider/urllib-request&quot; title=&quot;示例代码-Gitee&quot;&gt;示例代码-Gitee&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/zhangxinqi/p/9170312.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/zhangxinqi/p/9170312.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 09 Dec 2019 00:45:00 +0000</pubDate>
<dc:creator>极客挖掘机</dc:creator>
<og:description>人生苦短，我用 Python 前文传送门： '小白学 Python 爬虫（1）：开篇' '小白学 Python 爬虫（2）：前置准备（一）基本类库的安装' '小白学 Python 爬虫（3）：前置准备</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/babycomeon/p/12008967.html</dc:identifier>
</item>
<item>
<title>基于JDK1.8的JVM 内存结构【JVM篇三】 - 宜春</title>
<link>http://www.cnblogs.com/yichunguo/p/12007038.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yichunguo/p/12007038.html</guid>
<description>&lt;p&gt;在我的上一篇文章&lt;a href=&quot;https://blog.csdn.net/qq_44543508/article/details/102983363&quot;&gt;别翻了，这篇文章绝对让你深刻理解java类的加载以及ClassLoader源码分析【JVM篇二】&lt;/a&gt;中，相信大家已经对java类加载机制有一个比较全面的理解了，那么类加载之后，字节码数据在 Java 虚拟机内存中是如何存放的 ？Java 虚拟机在为类实例或成员变量分配内存是如何分配的 ？是的，这两个问题就涉及到了JVM 内存结构的知识了，那么这篇文章将进行解答。&lt;/p&gt;
&lt;p&gt;@&lt;/p&gt;
&lt;h2 id=&quot;内存结构还是运行时数据区&quot;&gt;1、内存结构还是运行时数据区？&lt;/h2&gt;
&lt;p&gt;要解答本篇上面的这些问题，我们首先需要了解一下 Java 虚拟机的内存结构。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;从某一角度来说，&lt;span&gt;&lt;strong&gt;Java 虚拟机的内存结构 == 运行时数据区&lt;/strong&gt;&lt;/span&gt;，在《Java 虚拟机规范》中用的是【运行时数据区】术语的，并没有内存结构这么一说法。内存结构只是听着更加贴切，更加形象，&lt;strong&gt;因此知道内存结构就是运行时数据区的意思就好了&lt;/strong&gt;！也没必要钻牛角尖纠结这个问题~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;运行时数据区&quot;&gt;2、运行时数据区&lt;/h2&gt;
&lt;p&gt;JVM被分为三个主要的子系统：类加载器子系统、运行时数据区和执行引擎 。而今天的这篇文章主要讲解其中的运行时数据区（Runtime Data Areas）&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2019120710435597.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;在 Java 虚拟机规范中，定义了五种运行时数据区，分别是 Java &lt;span&gt;&lt;strong&gt;堆&lt;/strong&gt;&lt;/span&gt;、方法区、虚拟机&lt;span&gt;&lt;strong&gt;栈&lt;/strong&gt;&lt;/span&gt;、本地方法区、程序计数器 !&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;顺道提一句运行时常量池也会进入方法区，也就是说方法区中就已经包括了常量池。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;特别注意其中Java 堆和方法区是 &lt;span&gt;&lt;strong&gt;线程共享&lt;/strong&gt;&lt;/span&gt;的。其他都是 &lt;span&gt;&lt;strong&gt;线程私有&lt;/strong&gt;&lt;/span&gt;的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191206182727699.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;线程共享java堆方法区&quot;&gt;3、线程共享：Java堆、方法区&lt;/h2&gt;
&lt;p&gt;我们首先来了解了解一下线程共享的Java堆和方法区！&lt;/p&gt;
&lt;h4 id=&quot;java堆&quot;&gt;3.1、Java堆&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;Java 堆是所有线程共享的，它在虚拟机启动时就会被创建&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Java 堆是内存空间占据的最大一块区域了，Java 堆是用来存放&lt;strong&gt;对象实例&lt;/strong&gt;及&lt;strong&gt;数组&lt;/strong&gt;，也就是说我们代码中通过 new 关键字 new 出来的对象都存放在这里。所以这里也就成为了垃圾回收器的主要活动营地了，于是它就有了一个别名叫做 &lt;strong&gt;GC 堆&lt;/strong&gt;，并且单个 JVM 进程有且仅有一个 Java 堆。根据垃圾回收器的规则，我们可以对 Java 堆进行进一步的划分，具体 Java 堆内存结构如下图所示：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191208160358777.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;从上图可以看出Java 堆并不是单纯的一整块区域，&lt;span&gt;&lt;strong&gt;实际上java堆是根据对象存活时间的不同&lt;/strong&gt;&lt;/span&gt;，Java 堆还被分为年轻代、老年代两个区域，年轻代还被进一步划分为 Eden 区、From Survivor 0、To Survivor 1 区。并且默认的虚拟机配置比例是Eden：from ：to = 8:1:1 。简单来说就是：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;Java堆 = 老年代 + 新生代&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;新生代 = Eden + S0 + S1&lt;br/&gt;&lt;/p&gt;

&lt;br/&gt;默认Eden：from ：to = 8:1:1&lt;/blockquote&gt;
&lt;p&gt;仔细看过上面的 Java 堆结构图童鞋可能会发现了-Xms和-Xmn的字样，是的这个正是控制堆的JVM的参数，实际上我们是可以通过JVM参数动态控制 Java 堆中的各空间大小的，关于JVM的参数是有很多的，但是常用的也就那么几个，不多的，用的多了都会很容易记住的，下面我们来讲讲关于堆的JVM常见的参数：&lt;/p&gt;
&lt;blockquote readability=&quot;14&quot;&gt;
&lt;p&gt;&lt;code&gt;-Xms&lt;/code&gt;： 堆容量初始大小（堆包括新生代和老年代）。 例如：-Xms 20M&lt;br/&gt;&lt;code&gt;-Xmx&lt;/code&gt;： 堆总共（最大）大小。 例如：-Xmx 30M&lt;br/&gt;&lt;strong&gt;注意：建议将 -Xms 和 -Xmx 设为相同值，避免每次垃圾回收完成后JVM重新分配内存！&lt;/strong&gt;&lt;br/&gt;&lt;code&gt;-Xmn&lt;/code&gt;： 新生代容量大小。例如：-Xmn 10M&lt;br/&gt;&lt;code&gt;-XX： SurvivorRatio&lt;/code&gt; 设置参数Eden、form和to的比例 【比例参数Eden、form和to默认是8：1：1】例如：-XX： SurvivorRatio=8 代表比例8：1：1&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;虽然没有直接设置老年代的参数，但是可以设置堆空间大小和新生代空间大小两个参数来间接控制：&lt;br/&gt;&lt;strong&gt;老年代空间大小 = 堆空间大小 - 年轻代大空间大小&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当我们的 Java 堆内有足够的空间去完成实例分配时，并且堆也无法扩展，将会抛出我们常见的&lt;span&gt;&lt;strong&gt;OutOfMemoryError&lt;/strong&gt;&lt;/span&gt; 异常，也就是我们常说的&lt;span&gt;&lt;strong&gt;OOM&lt;/strong&gt;&lt;/span&gt; 异常&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;jvm-堆内存溢出后其他线程是否可继续工作&quot;&gt;3.2、 JVM 堆内存溢出后，其他线程是否可继续工作？&lt;/h4&gt;
&lt;p&gt;JVM 堆内存溢出后也就是OOM 异常，网上有一道非常火的面试题：JVM 堆内存溢出后，其他线程是否可继续工作？&lt;/p&gt;
&lt;p&gt;实际上这个问题需要具体的场景分析。但是就一般情况下，发生OOM的线程都会终结（除非代码写的太烂），该线程持有的对象占用的heap都会被gc了，释放内存。因为发生OOM之前要进行gc，就算其他线程能够正常工作，也会因为频繁gc产生较大的影响。&lt;/p&gt;
&lt;p&gt;也就是说发生OOM的线程一般情况下会死亡，也就是会被终结掉，该线程持有的对象占用的heap都会被gc了，释放内存。因为发生OOM之前要进行gc，就算其他线程能够正常工作，也会因为频繁gc产生较大的影响。&lt;/p&gt;
&lt;h4 id=&quot;方法区&quot;&gt;3.3、方法区&lt;/h4&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;拿HotSpot 虚拟机来说，在 &lt;span&gt;&lt;strong&gt;JDK1.7&lt;/strong&gt;&lt;/span&gt;的时候，方法区被称作为&lt;span&gt;&lt;strong&gt;永久代&lt;/strong&gt;&lt;/span&gt;， 从&lt;span&gt;&lt;strong&gt;JDK1.8&lt;/strong&gt;&lt;/span&gt;开始，&lt;span&gt;&lt;strong&gt;Metaspace （元空间）&lt;/strong&gt;&lt;/span&gt;也就是我们所谓的方法区！&lt;br/&gt;&lt;/p&gt;

&lt;br/&gt;也就是说，如果你身边的小伙伴还在说着永久代，那绝壁是在扯1.8之前的概念了，1.8之后已经废弃了永久代这个概念！&lt;/blockquote&gt;
&lt;p&gt;方法区（Method Area）与上面讲的Java堆一样，都是各个线程共享的，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;Java虚拟机规范中是这样定义方法区的：&lt;br/&gt;它存储了每个类的结构信息，例如运行时常量池、字段、方法数据、构造函数和普通方法的字节码内容，还包括一些在类、实例、接口初始化时用到的特殊方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;jdk1.8-之前的方法区&quot;&gt;3.4、JDK1.8 之前的方法区&lt;/h4&gt;
&lt;p&gt;就以HotSpot 虚拟机来说，在 JDK1.8 之前，方法区也被称作为永久代，这个方法区会发生我们常见的 &lt;strong&gt;java.lang.OutOfMemoryError: &lt;span&gt;PermGen space&lt;/span&gt;&lt;/strong&gt; 异常,注意是&lt;strong&gt;永久代&lt;/strong&gt;异常信息，我们也可以通过启动参数来控制方法区的大小：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;-XX:PermSize 设置方法区最小空间&lt;br/&gt;-XX:MaxPermSize 设置方法区最大空间&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在JDK7之前的HotSpot虚拟机中，纳入字符串常量池的字符串被存储在永久代中，因此导致了一系列的性能问题和内存溢出错误。特别突出的例子就是&lt;code&gt;String&lt;/code&gt;的&lt;span&gt;&lt;strong&gt;intern（）&lt;/strong&gt;&lt;/span&gt;方法&lt;/p&gt;
&lt;h4 id=&quot;jdk1.8-之后的方法区&quot;&gt;3.5、JDK1.8 之后的方法区&lt;/h4&gt;
&lt;p&gt;JDK8之后就没有永久代这一说法变成叫做&lt;span&gt;&lt;strong&gt;元空间（meta space）&lt;/strong&gt;&lt;/span&gt;，而且将老年代与元空间剥离。元空间放置于本地的内存中，因此元空间的最大空间就是系统的内存空间了，从而不会再出现像永久代的内存溢出错误了，也不会出现泄漏的数据移到交换区这样的事情。用户可以为元空间设置一个可用空间最大值，不设置默认根据类的元数据大小动态增加元空间的容量。对于一个 64 位的服务器端 JVM 来说，其默认的&lt;code&gt;–XX:MetaspaceSize&lt;/code&gt; 值为 21MB。也就是说&lt;span&gt;&lt;strong&gt;默认的元空间大小是21MB&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;==只要类加载器还存活，其加载的类的元数据也是存活的，不会被回收掉！也就是同生共死==&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191208183301923.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;jdk1.8-之后的方法区为何变化如此之大&quot;&gt;3.6、JDK1.8 之后的方法区为何变化如此之大？&lt;/h4&gt;
&lt;p&gt;做这个改变呢也许主要是基于以下两点原因：&lt;/p&gt;
&lt;p&gt;1、由于 永久代（PermGen）内存经常会溢出，引发恼人的 &lt;strong&gt;&lt;code&gt;java.lang.OutOfMemoryError: PermGen&lt;/code&gt;&lt;/strong&gt;，因此 JVM 的开发者希望这一块内存可以更灵活地被管理，不要再经常出现这样的 OOM错误。&lt;/p&gt;
&lt;p&gt;2、移除 永久代（PermGen）可以促进 HotSpot JVM 与 JRockit VM 的融合，因为 JRockit 没有永久代。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;还有需要注意一点的是永久代的移除并不代表自定义的类加载器泄露问题就解决了。因此，你还必须监控你的内存消耗情况，因为一旦发生泄漏，会占用你的大量本地内存，并且还可能导致交换区交换更加糟糕。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;线程私有程序计数器java-虚拟机栈本地方法栈&quot;&gt;4、线程私有：程序计数器、Java 虚拟机栈、本地方法栈&lt;/h2&gt;
&lt;p&gt;Java 堆以及方法区的数据是共享的，但是有一些部分则是线程私有的。线程私有部分可以分为：程序计数器、Java 虚拟机栈、本地方法栈三大部分。&lt;/p&gt;
&lt;h4 id=&quot;java-虚拟机栈jvm-stacks&quot;&gt;4.1、Java 虚拟机栈（JVM Stacks）&lt;/h4&gt;
&lt;p&gt;1、 Java 虚拟机的每一条线程都有自己私有的 Java 虚拟机栈，这个 Java 虚拟机栈跟线程同时创建，所以它跟线程有相同的生命周期。&lt;/p&gt;
&lt;p&gt;2、Java 虚拟机栈描述的是 ==Java 方法==执行的内存模型：&lt;span&gt;每一个方法在执行的同时都会创建一个栈帧&lt;/span&gt;，用于存储局部变量表、操作数栈、动态链接、方法出口等信息，==每一个方法从调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中的入栈到出栈的过程==。&lt;/p&gt;
&lt;p&gt;3、&lt;strong&gt;局部变量表&lt;/strong&gt;存放了编译期可知的各种基本数据类型、对象引用和 returnAddress 类型。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;1、基本类型：八种基本类型&lt;br/&gt;2、对象引用：reference 类型，它不等同于对象本身，根据不同的虚拟机实现，它可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或者其他与此对象相关的位置。&lt;br/&gt;3、 returnAddress 类型：指向了一条字节码指令的地址。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其中 64 位长度的 long 和 double 类型的数据会占用 2 个局部变量空间（Slot），其余的数据类型只占用 1 个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。&lt;/p&gt;
&lt;p&gt;4、Java 虚拟机栈既允许被实现成固定的大小，也允许根据计算动态来扩展和收缩，如果采用固定大小的话，每一个线程的 Java 虚拟机栈容量可以在线程创建的时候独立选定。在 Java 虚拟机栈中会发生两种异常，这个在虚拟机规范中有指出：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果线程请求分配的栈容量超过 Java 虚拟机栈允许的最大容量，Java 虚拟机将会抛出 &lt;code&gt;StackOverflowError&lt;/code&gt; 异常；也就是栈溢出错误！&lt;span&gt;&lt;strong&gt;方法递归&lt;/strong&gt;&lt;/span&gt;调用产生&lt;code&gt;StackOverflowError&lt;/code&gt; 异常这种结果。&lt;/li&gt;
&lt;li&gt;如果 Java 虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存或者在创建新的线程时没有足够的内存去创建对应的 Java 虚拟机栈，那么虚拟机将会抛出 &lt;code&gt;OutOfMemoryError&lt;/code&gt; 异常。也就是OOM内存溢出错误！(线程启动过多)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当然，可以通过参数 &lt;code&gt;-Xss&lt;/code&gt; 去调整JVM栈的大小！&lt;/p&gt;
&lt;h4 id=&quot;本地方法栈native-method-stacks&quot;&gt;4.2、本地方法栈（Native Method Stacks）&lt;/h4&gt;
&lt;p&gt;==和虚拟栈相似，只不过它服务于Native方法==，&lt;span&gt;&lt;strong&gt;线程私有&lt;/strong&gt;&lt;/span&gt;。当 Java 虚拟机使用其他语言（例如 C 语言）来实现指令集解释器时，也会使用到本地方法栈。如果 Java 虚拟机不支持 natvie 方法，并且自己也不依赖传统栈的话，可以无需支持本地方法栈。&lt;/p&gt;
&lt;p&gt;与 Java 虚拟机栈一样，本地方法栈区域也会抛出 &lt;code&gt;StackOverflowError&lt;/code&gt; 和 &lt;code&gt;OutOfMemoryError&lt;/code&gt; 异常。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;HotSpot虚拟机直接就把本地方法栈和虚拟机栈合二为一。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;程序计数器&quot;&gt;4.3、程序计数器&lt;/h4&gt;
&lt;p&gt;当前线程所执行的字节码的行号指示器，用于记录正在执行的虚拟机字节指令地址，线程私有。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;需要特别注意的是，程序计数器是唯一一个在Java虚拟机规范中没有规定任何 &lt;code&gt;OutOfMemoryError&lt;/code&gt; 情况的区域。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;jvm-内存结构总结&quot;&gt;5、JVM 内存结构总结&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191206182727699.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;程序计数器：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;1、 当前线程所执行的字节码的行号指示器，用于记录正在执行的虚拟机字节指令地址，线程私有。&lt;br/&gt;2、程序计数器是唯一一个在Java虚拟机规范中没有规定任何 &lt;code&gt;OutOfMemoryError&lt;/code&gt; 情况的区域。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Java虚拟栈：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;1、存放基本数据类型、对象的引用、方法出口等，线程私有。&lt;br/&gt;2、栈容量超过 Java 虚拟机栈的最大容量，会抛出 &lt;code&gt;StackOverflowError&lt;/code&gt; 异常；也就是栈溢出错误！&lt;span&gt;&lt;strong&gt;方法递归&lt;/strong&gt;&lt;/span&gt;产生&lt;br/&gt;3、如果 Java 虚拟机栈可以动态扩展，无法申请到足够的内存或者在创建新的线程时没有足够的内存去创建对应的 Java 虚拟机栈，会抛出 &lt;code&gt;OutOfMemoryError&lt;/code&gt; 异常。也就是OOM内存溢出错误！(线程启动过多)&lt;br/&gt;4、参数 &lt;code&gt;-Xss&lt;/code&gt; 调整JVM栈的大小&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Native方法栈：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;1、和虚拟栈相似，只不过它服务于Native方法，线程私有。&lt;br/&gt;2、&lt;span&gt;&lt;strong&gt;HotSpot虚拟机直接就把本地方法栈和虚拟机栈合二为一。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Java堆：&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;java内存最大的一块，所有对象实例、数组都存放在java堆，GC回收的地方，线程共享。&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Java堆 = 老年代 + 新生代&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;新生代 = Eden + S0 + S1&lt;br/&gt;&lt;/p&gt;

&lt;br/&gt;默认Eden：from ：to = 8:1:1&lt;br/&gt;方法区：&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;1、存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码数据等，回收目标主要是常量池的回收和类型的卸载，各线程共享&lt;br/&gt;2、&lt;span&gt;&lt;strong&gt;方法区&lt;/strong&gt;&lt;/span&gt;在&lt;strong&gt;JDK1.7&lt;/strong&gt;的时候叫做&lt;span&gt;&lt;strong&gt;永久代&lt;/strong&gt;&lt;/span&gt;，到&lt;strong&gt;JDK1.8&lt;/strong&gt;之后废弃了永久代改为&lt;span&gt;&lt;strong&gt;元空间&lt;/strong&gt;&lt;/span&gt;（meta space）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;如果本文对你有一点点帮助，那么请点个赞呗，谢谢~&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;最后，若有不足或者不正之处，欢迎指正批评，感激不尽！如果有疑问欢迎留言，绝对第一时间回复！&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;欢迎各位关注我的公众号，一起探讨技术，向往技术，追求技术，说好了来了就是盆友喔...&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2019112519430061.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 09 Dec 2019 00:05:00 +0000</pubDate>
<dc:creator>宜春</dc:creator>
<og:description>在我的上一篇文章 '别翻了，这篇文章绝对让你深刻理解java类的加载以及ClassLoader源码分析【JVM篇二】' 中，相信大家已经对java类加载机制有一个比较全面的理解了，那么类加载之后，字节</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yichunguo/p/12007038.html</dc:identifier>
</item>
<item>
<title>Java泛型之上、下界通配符的理解(适合初学) - 远方有你，伴余生</title>
<link>http://www.cnblogs.com/glassysky/p/12008721.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/glassysky/p/12008721.html</guid>
<description>&lt;h2 id=&quot;泛型的由来&quot;&gt;泛型的由来&lt;/h2&gt;
&lt;h3 id=&quot;为什么需要泛型&quot;&gt;为什么需要泛型&lt;/h3&gt;
&lt;p&gt;  Java的数据类型一般都是在定义时就需要确定，这种强制的好处就是类型安全，不会出现像弄一个ClassCastException的数据给jvm，数据安全那么执行的class就会很稳定。但是假如说我不知道这个参数要传什么类型的，因为公司需求在变，如果写死的那就只能便以此需求就改一次，很麻烦。sun公司也注意到这个问题，这样会让代码的灵活性降低，他们就研究出了泛型。&lt;/p&gt;
&lt;h3 id=&quot;泛型初识&quot;&gt;泛型初识&lt;/h3&gt;
&lt;p&gt;  什么是泛型，可以字面理解就是一个泛泛的类型，他是不确定的，在Java代码编译的时候用泛型是不会出错的，而在运行期时就会报错，说你这种第一是不合理的。这是为什么呢。因为为了提高灵活性，就在编译时期将条件放宽，但是泛型一定要在运行的时候告诉jvm你给我的数据到底是什么类型的，否则jvm会是懵逼的。所以泛型的好处就是将类型的灵活性提高，也只是在Java语法的基础上提高，不过泛型还是比较实用的。&lt;/p&gt;
&lt;h3 id=&quot;何时使用泛型&quot;&gt;何时使用泛型&lt;/h3&gt;
&lt;p&gt;  泛型的应用场景就是应用在模型（可以理解为存储数据的盒子），我为了这个盒子适用更多的地方我就用将需要存入的数据用一个泛型表示，当然可以传入多值。如果是相同类型的对象就用一个泛型的数组比较好，学过集合的小伙伴应该都知道，没学过的那你应该补补课了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;泛型的语法&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class A&amp;lt;T extends B&amp;gt;{
   T t;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;泛型的缺点或者为什么需要上下边界&quot;&gt;泛型的缺点或者为什么需要上、下边界&lt;/h2&gt;
&lt;p&gt;  泛型的虽然强大，但是世界上任何东西东部是完美的。它也有缺陷。比如说我有一个盒子我想装苹果，但是我还可能想装香蕉那怎么办。那还不好说，在给一个参数不就行了，那十个呢，二十个呢。em....的确是。如果说我们想装的东西都属于一个类并且只要是这个类的子类就可以装。这个想法sun为我们想好了。那就是用上边界通配符。语法是 T是泛型，M是T的父类。我们就定义一个水果类（Fruit），盛装就容器就是盘子（Dish），现在我们就可以装任何水果了，不错吧！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;上边界Java代码&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Dish&amp;lt;T extends Fruit&amp;gt;{
  private T fruitChild;

  public Dish(T fruitChild){
    this.fruitChild = fruitChild;
  }

  public T getFruitChild(){
    return fruitChild;
  }
  
  public void setFruitChild(T f){
    this.fruitChild = f;
  }

  public static void main(String[] args){

    Dish dish = new Dish&amp;lt;apple&amp;gt;();
    Apple apple = new apple(); //apple must be Fruit child;
    dish.setFruitChild(apple);

    system.out.printf(dish.getFruitChild);
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;下边界Java代码&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Dish&amp;lt;T super Apple&amp;gt;{
  private T appleFather;

  public Dish(T appleFather){
    this.appleFather = appleFather;
  }

  public T getAppleFather(){
    return appleFather;
  }

  public void setAppleFather(T f){
    this.appleFather = f;
  }

  public static void main(String[] args){

    Dish dish = new Dish&amp;lt;Fruit&amp;gt;();
    Fruit fruit = new Fruit(); //fruit must be apple son;
    dish.setAppleFather(fruit);

    system.out.printf(dish.getAppleFather);
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;什么是上边界通配符&quot;&gt;什么是上边界通配符&lt;/h2&gt;
&lt;p&gt;  当泛型T给定形如 的A类型到A类型任何子类的限制域，可以匹配任何在此限制域中的类型，此种表示叫上边界通配符。&lt;/p&gt;
&lt;h3 id=&quot;上边界通配符理解&quot;&gt;上边界通配符理解&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/820480/201611/820480-20161125004120143-1731938777.png&quot; alt=&quot;png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;什么是下边界通配符&quot;&gt;什么是下边界通配符&lt;/h2&gt;
&lt;p&gt;  当泛型T给定形如 的A类型到A类型任何父类的限制域，可以匹配任何在此限制域中的类型，此种表示叫下边界通配符。&lt;/p&gt;
&lt;h3 id=&quot;下边界通配符理解&quot;&gt;下边界通配符理解&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/820480/201611/820480-20161125004216471-1377946016.png&quot; alt=&quot;png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;上下边界通配符的缺点&quot;&gt;上下边界通配符的缺点&lt;/h2&gt;
&lt;p&gt;  上界&amp;lt;? extends T&amp;gt;不能往里存，只能往外取。&lt;/p&gt;
&lt;h3 id=&quot;解释&quot;&gt;解释&lt;/h3&gt;
&lt;p&gt;  因为编译器只知道传入的是T的子类，但具体是哪一个编译器不知道，他只标注了一个占位符，当？传过来时，他不知道这能不能和占位符匹配，所以set不了。&lt;br/&gt;  下界&amp;lt;? super T&amp;gt;不影响往里存，但往外取只能放在Object对象里。&lt;/p&gt;
&lt;h3 id=&quot;解释-1&quot;&gt;解释&lt;/h3&gt;
&lt;p&gt;  因为下边界已经限制了？的粒度，他只可能是T本身或者是T的父类。我们想想，我想要一个T，你却返回给我一个比T小的Object，这样我们就因为精度损失而拿不到想要的数据了。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;感谢各位童鞋的阅读，希望大家动一动发财的小手点一下推荐QAQ。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sun, 08 Dec 2019 19:51:00 +0000</pubDate>
<dc:creator>远方有你，伴余生</dc:creator>
<og:description>泛型的由来 为什么需要泛型 Java的数据类型一般都是在定义时就需要确定，这种强制的好处就是类型安全，不会出现像弄一个ClassCastException的数据给jvm，数据安全那么执行的class就</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/glassysky/p/12008721.html</dc:identifier>
</item>
<item>
<title>React - 组件：类组件 - xing.org1^</title>
<link>http://www.cnblogs.com/padding1015/p/12008771.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/padding1015/p/12008771.html</guid>
<description>&lt;h3&gt;&lt;strong&gt;目录：&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
1. 类组件有自己的状态
2. 继承React.Component-会有生命周期和this
3. 内部需要一个render函数（类组件会默认调用render方法，但不会默认添加，需要手动填写render函数，并return一个能渲染的值。）
4. 类组件的基本架构
5. constructor里边添加自己的属性和状态、方法
  a. 写了constructor就要写super
  b. 如果c里边没内容只有super，name可以不写
6. 添加状态this.state = {}; es7写法state = {}。非双向绑定
7. setState接收对象的情况、批量更新
8. setState接收函数的情况、state与penddingState
9. class里方法的写法
  a. 方法里边this的指向undefined的情况
  class Person {
    fn(){
      console.log(this);
    }
  }
  var person = new Person();
  var fn1 = person.fn;
  fn1(); //undefined
  b. bind改变this指向
  c. 箭头函数继承this指向
  d. 匿名函数传参
10. TodoList实战
11. 类组件注意：
注意绑定事件时，&quot;on&quot;后边事件名的首字母大写，如&quot;change&quot;要写成&quot;Change&quot;注意回调函数内部this的指向默认为undefined，要改变this指向
不能直接改变state的值、需要用函数setState来修改state的值
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;strong&gt;类组件：&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;做复杂的数据处理、需要有自己的状态的时候，需要用类组件。&lt;/p&gt;
&lt;p&gt;他有自己的生命周期也有react给他提供的一些内置函数方法。有自己的this和状态。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;要点：&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;• 类的名字就是组件的名字&lt;br/&gt;• 类的开头一定要大写&lt;br/&gt;• 类要继承自React.Component&lt;br/&gt;• 组件内部一定要有render函数，否则报错&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;定义一个组件：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; import React from 'react'
&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;class TodoList extends React.Component {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    render(){
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         let todoList = &amp;lt;div&amp;gt;
&lt;span&gt; 6&lt;/span&gt;                 &amp;lt;h3&amp;gt;我是类组件&amp;lt;/h3&amp;gt;
&lt;span&gt; 7&lt;/span&gt;             &amp;lt;/div&amp;gt;
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; todoList; 
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 所以类组件内部必须有render函数，并return返回一个可渲染的值。&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    };
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; export &lt;span&gt;default&lt;/span&gt; TodoList
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;引入组件：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
import TodoList from '../components/TodoList'
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;调用组件：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TodoList&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;TodoList&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;类组件内部没有render函数报错：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/956663/201912/956663-20191208235838421-1861444324.png&quot; alt=&quot;&quot; width=&quot;308&quot; height=&quot;169&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为看到class组件会默认调用render方法&lt;br/&gt;如果看到函数组件，会自动在函数内部添加一个render方法，把函数的return返回值放到render中运行。&lt;br/&gt;所以类组件内部必须有render函数，并return返回一个可渲染的值。不会进行自动添加。&lt;/p&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;开发1个类组件 - TodoList：&lt;/h3&gt;
&lt;p&gt;组件内部要使用的数据称之为状态state。&lt;br/&gt;state的值一定是对象，并且state这个拼写也是固定的： &lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/956663/201912/956663-20191208235845560-1999763712.png&quot; alt=&quot;&quot; width=&quot;398&quot; height=&quot;22&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1、准备一个模块，并做初步数据渲染尝试：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/956663/201912/956663-20191208235853446-1307533556.png&quot; alt=&quot;&quot; width=&quot;438&quot; height=&quot;512&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、填写数据并执行添加功能，将input内容添加到list&lt;/strong&gt;&lt;br/&gt;（没有vue的双向数据绑定功能，只是单向的。应该知道input的内容，然后把值设置给state数据，再把state数据放到list列表中渲染。）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2-1、需要onChange事件监听input输入。回调函数=类里边定义的函数。&lt;/strong&gt;&lt;br/&gt;注意&quot;on&quot;后边事件名的首字母大写，如&quot;change&quot;要写成&quot;Change&quot;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/956663/201912/956663-20191209000149301-255702364.png&quot; alt=&quot;&quot; width=&quot;448&quot; height=&quot;487&quot;/&gt;&lt;/p&gt;
&lt;p&gt;=== &lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/956663/201912/956663-20191209000208475-1848140006.png&quot; alt=&quot;&quot; width=&quot;786&quot; height=&quot;315&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2-2、onChange后给state里的inputVal赋值&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;注意回调函数内部this的指向：&lt;span&gt;默认，this指向undefined&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/956663/201912/956663-20191209000222607-1784397991.png&quot; alt=&quot;&quot; width=&quot;1031&quot; height=&quot;64&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;因为只是监听change事件的时候，调用handleChange函数，这个函数没人调用，就会指向undefined。&lt;br/&gt;跟下边这段代码一样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/956663/201912/956663-20191209000233766-1934170712.png&quot; alt=&quot;&quot; width=&quot;224&quot; height=&quot;186&quot;/&gt;&lt;/p&gt;

&lt;p&gt;改变this指向：通过绑定&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
onChange= { &lt;span&gt;this&lt;/span&gt;.handleChange.bind(&lt;span&gt;this&lt;/span&gt;) }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; &lt;span&gt;&lt;strong&gt;不能直接改变state的值&lt;/strong&gt;&lt;/span&gt;，会有警告：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; this.state.inputVal = e.target.value;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/956663/201912/956663-20191209000309461-93523267.png&quot; alt=&quot;&quot; width=&quot;528&quot; height=&quot;49&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;需要用函数setState来修改state的值&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setState({
    inputVal: e.target.value
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;最终代码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/956663/201912/956663-20191209000335031-406345649.png&quot; alt=&quot;&quot; width=&quot;510&quot; height=&quot;652&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2-3、添加功能&lt;/strong&gt;&lt;br/&gt;注意this绑定、空值的防抖判断等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/956663/201912/956663-20191209000400891-1567066756.png&quot; alt=&quot;&quot; width=&quot;346&quot; height=&quot;93&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/956663/201912/956663-20191209000412478-374424700.png&quot; alt=&quot;&quot; width=&quot;563&quot; height=&quot;909&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3、删除功能&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/956663/201912/956663-20191209000518807-1363021084.png&quot; alt=&quot;&quot; width=&quot;507&quot; height=&quot;235&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/956663/201912/956663-20191209002739893-242443263.png&quot; alt=&quot;&quot; width=&quot;378&quot; height=&quot;530&quot;/&gt;&lt;/p&gt;


&lt;h3&gt;改变this指向的其他方法：&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1、bind绑定&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;this&lt;/span&gt;.handleDelete.bind(&lt;span&gt;this&lt;/span&gt;,i)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;没点击一次就执行了多少次的函数。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2、顶部绑定&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/956663/201912/956663-20191209000632535-191491007.png&quot; alt=&quot;&quot; width=&quot;439&quot; height=&quot;50&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
onChange= { &lt;span&gt;this&lt;/span&gt;.handleChange }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;3、箭头函数改变this指向【重点、核心方案】&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
onChange= { &lt;span&gt;this&lt;/span&gt;.handleChange }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/956663/201912/956663-20191209000642515-127970689.png&quot; alt=&quot;&quot; width=&quot;295&quot; height=&quot;89&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4、匿名函数【要传参的情况】&lt;/strong&gt;&lt;br/&gt;在匿名函数内部让函数去执行&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/956663/201912/956663-20191209000656711-2058395266.png&quot; alt=&quot;&quot; width=&quot;445&quot; height=&quot;154&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/956663/201912/956663-20191209002225884-1702243414.png&quot; alt=&quot;&quot; width=&quot;414&quot; height=&quot;510&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;一个函数里有多个setState：&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/956663/201912/956663-20191209000741111-1014766595.png&quot; alt=&quot;&quot; width=&quot;387&quot; height=&quot;105&quot;/&gt;&lt;/p&gt;
&lt;p&gt;setState里边传入对象，会有参数覆盖的情况。上图示例中只执行最后一个。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;批量更新：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在一个函数里有多个setState的情况下，react就会把多个setState放到一起，进行合并。合并完了以后再去执行。那么就只剩下最后一个会起作用了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;目的/好处：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;减少虚拟dom的比对，提高渲染的性能。&lt;/p&gt;

&lt;h3&gt;setState接收函数的情况：setState纯函数&lt;/h3&gt;
&lt;p&gt;就想设置多个setState还想绕过批量更新，就可以在setState函数里传参函数：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/956663/201912/956663-20191209000805074-2117049911.png&quot; alt=&quot;&quot; width=&quot;319&quot; height=&quot;403&quot;/&gt;&lt;/p&gt;
&lt;p&gt;return的对象里边是你要更改的状态。&lt;/p&gt;

&lt;p&gt;流程是先进行更改，更改的内容放在pendingState中进行等待。函数完毕后再把pendingState的内容一次性再设置给state里。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/956663/201912/956663-20191209000857001-1394005850.png&quot; alt=&quot;&quot; width=&quot;443&quot; height=&quot;137&quot;/&gt;&lt;/p&gt;


&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/956663/201912/956663-20191209000904285-1103113568.png&quot; alt=&quot;&quot; width=&quot;437&quot; height=&quot;143&quot;/&gt;&lt;/p&gt;


&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/956663/201912/956663-20191209000910576-462549566.png&quot; alt=&quot;&quot; width=&quot;432&quot; height=&quot;131&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;2019-12-09 00:24:02&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 08 Dec 2019 16:25:00 +0000</pubDate>
<dc:creator>xing.org1^</dc:creator>
<og:description>类组件class</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/padding1015/p/12008771.html</dc:identifier>
</item>
<item>
<title>【灵魂拷问】你真的懂得Mysql的管理和使用吗？ - 达达前端小酒馆</title>
<link>http://www.cnblogs.com/dashucoding/p/12008700.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dashucoding/p/12008700.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1434670/201912/1434670-20191208234832802-471331977.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;作者 | Jeskson&lt;/p&gt;
&lt;p&gt;来源 | 达达前端小酒馆&lt;/p&gt;
&lt;p&gt;MySQL管理，数据库管理和数据表管理，用户管理。&lt;/p&gt;
&lt;p&gt;初始化数据库，创建数据库，查看数据库，删除数据库。&lt;/p&gt;
&lt;p&gt;创建数据表，查看数据表，修改数据表，删除数据表。&lt;/p&gt;
&lt;p&gt;用户管理，创建与删除用户，授予与回收用户权限，设置与更改用户密码。&lt;/p&gt;

&lt;p&gt;初始化数据库&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysqld --initialize&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动数据库：&lt;/p&gt;
&lt;p&gt;使用windows服务器管理界面启动；或使用MySQL命令启动。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql -u root -p&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建数据库&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CREATE DATABASE&lt;/code&gt;语句用于创建一个新的数据库&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;CREATE DATABASE [db_name];&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;// 创建一个名为dada的数据库
create database data;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;数据库创建好后，会在&lt;code&gt;data&lt;/code&gt;目录下自动生成一个名为&lt;code&gt;data&lt;/code&gt;的目录，该数据库的数据会存储于此目录下，&lt;code&gt;MySQL&lt;/code&gt;是一个数据库管理系统，支持运行多个数据库。&lt;/p&gt;
&lt;p&gt;查看数据库&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SHOW DATABASES&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;show databases;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;删除数据库&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;DROP DATABASE db_name;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;drop database dada; // 删除dada数据库&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;删除数据库是一个不可逆的操作。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;MySQL&lt;/code&gt;的每个数据库就相当于一个容器，里面放着很多许多表，表中的每行包含一条具体的数据关系信息，为数据记录。在&lt;code&gt;data&lt;/code&gt;目录下，每个数据库对应一个目录。&lt;/p&gt;
&lt;p&gt;每个数据表对应3个文件，分别为&quot;.frm&quot;,&quot;myd&quot;,&quot;.myi&quot;类型的文件。&lt;/p&gt;
&lt;p&gt;创建数据表：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;USE 数据库名；
CREATE TABLE 表名（字段名 类型（长度），字段名 类型（长度））；&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看数据表&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SHOW语句和DESCRIBE语句

// 查看数据库中有哪些表
SHOW TABLES;

// 此命令可以列出所有表名
show tables;

// DESCRIBE
DESCRIBE 库名.表名;
使用DESCRIBE语句可以查看某一个表的具体结构，并查看组成表的各字段的信息&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;use mysql;
describe user;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用describe语句可以查看表的各个字段名称，类型，长度，是否非空，是否有主键，默认值以及备注等信息。&lt;/p&gt;
&lt;p&gt;修改数据表&lt;/p&gt;
&lt;p&gt;修改数据表使用ALTER语句来实现，alter，修改表，包括修改表的名，字段的名，字段类型等表结构。&lt;/p&gt;
&lt;p&gt;修改表名&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ALTER TABLE 旧表名 RENAME 新表名；&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;ALTER TABLE student RENAME student1;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改字段名：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ALTER TABLE 表名 CHANGE 旧属性名 新属性名 新数据类型;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;ALTER TABLE student1 CHANGE name s_name varchar(50);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改字段类型&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ALTER TABLE 表名 MODIFY 属性名 数据类型;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;ALTER TABLE student1 MODIFY name varchar(2);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;增加字段：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ALTER TABLE 表名 ADD 属性名 数据类型;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;ALTER TABLE student1 ADD sex char(1)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;删除字段：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ALTER TABLE 表名 DROP 属性名;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;ALTER TABLE student1 DROP sex;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;删除数据表&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;USE 数据库名;
DROP 表名;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用&lt;code&gt;DROP&lt;/code&gt;语句可以删除数据库中的表&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;DROP TABLE 数据库名.表名;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;USE test;
DROP TABLE student1;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;DROP TABLE test.sudent1;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;创建与删除用户&lt;/p&gt;
&lt;p&gt;创建用户&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;CREATE USER 'username'@'host' IDENTIFIED BY 'password';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;username&lt;/code&gt;表名要创建的用户名&lt;br/&gt;&lt;code&gt;host&lt;/code&gt;表示在哪个主机上可以登录&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;CREATE USER 'test1'@'localhost' IDENTIFIED BY '123';&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;CREATE USER 'test2'@'192.123.2.2' IDENTIFIED BY '12';&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;CREATE USER 'test3'@'%' IDENTIFIED BY '';
// identified&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用户删除&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;DROP USER 'username'@'host';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;删除用户的语法与创建用户的语法相同&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;DROP USER 'test1'@'localhost';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;删除本地主机数据库用户&lt;/p&gt;

&lt;p&gt;可以对用户进行授权：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;GRANT privileges ON dbname.tablename To 'username'@'host';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;privileges&lt;/code&gt;表示要授予用户的操作权限&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dbname&lt;/code&gt;表示数据库名&lt;/p&gt;
&lt;p&gt;&lt;code&gt;tablename&lt;/code&gt;表示数据表名&lt;/p&gt;
&lt;p&gt;&lt;code&gt;username&lt;/code&gt;和&lt;code&gt;host&lt;/code&gt;分别表示用户名和登录主机&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;GRANT SELECT, INSERT ON mysql.test TO 'test1'@'%';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;表示授权用户&lt;code&gt;test1&lt;/code&gt;在所有登录主机均对&lt;code&gt;mysql&lt;/code&gt;库的&lt;code&gt;test&lt;/code&gt;表拥有&lt;code&gt;select&lt;/code&gt;和&lt;code&gt;insert&lt;/code&gt;权限。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;GRANT ALL ON *.* TO 'test2'@'localhost';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果要授予用户对所有数据库和表的相应操作权限，可用&lt;code&gt;“*”表示，如“*.*”。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;回收用户权限&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;REVOKE privileges ON databasenamme,tablename FROM 'username'@'host';&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;REVOKE SELECT ON *.* FROM 'test2'@'localhost';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;回收用户&lt;code&gt;test2&lt;/code&gt;在本地主机数据库对所有库的所有表的SELECT权限&lt;/p&gt;
&lt;p&gt;设置与更改用户密码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SET PASSWORD FOR 'username'@'host' = PASSWORD('newpassword');;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;username&lt;/code&gt;为要设置或更改密码的用户名&lt;/p&gt;
&lt;p&gt;&lt;code&gt;host&lt;/code&gt;为用户的登录主机&lt;/p&gt;
&lt;p&gt;&lt;code&gt;newpassword&lt;/code&gt;为设置或更改的密码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SET PASSWORD FOR 'test1'@'localhost' = PASSWORD('123');&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1434670/201912/1434670-20191208234833082-1699264211.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;不要忘记留下你学习的脚印-点赞-收藏-评论&quot;&gt;❤️ 不要忘记留下你学习的脚印 [点赞 + 收藏 + 评论]&lt;/h2&gt;
&lt;p&gt;作者Info：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;【作者】：Jeskson&lt;br/&gt;【原创公众号】：达达前端小酒馆。&lt;br/&gt;【福利】：公众号回复 “资料” 送自学资料大礼包（进群分享，想要啥就说哈，看我有没有）！&lt;br/&gt;【转载说明】：转载请说明出处，谢谢合作！~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;大前端开发，定位前端开发技术栈博客，PHP后台知识点，web全栈技术领域，数据结构与算法、网络原理等通俗易懂的呈现给小伙伴。谢谢支持，承蒙厚爱！！！&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;若本号内容有做得不到位的地方（比如：涉及版权或其他问题），请及时联系我们进行整改即可，会在第一时间进行处理。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;请点赞因为你们的赞同鼓励是我写作的最大动力&quot;&gt;请点赞！因为你们的赞同/鼓励是我写作的最大动力！&lt;/h2&gt;
&lt;h3 id=&quot;欢迎关注达达的csdn&quot;&gt;欢迎关注&lt;a href=&quot;https://blog.csdn.net/qq_36232611&quot;&gt;达达&lt;/a&gt;的CSDN！&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;这是一个有质量，有态度的博客&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1434670/201912/1434670-20191208234833303-1249653356.jpg&quot; alt=&quot;前端技术栈&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 08 Dec 2019 15:49:00 +0000</pubDate>
<dc:creator>达达前端小酒馆</dc:creator>
<og:description>作者 | Jeskson 来源 | 达达前端小酒馆 MySQL管理，数据库管理和数据表管理，用户管理。 初始化数据库，创建数据库，查看数据库，删除数据库。 创建数据表，查看数据表，修改数据表，删除数据</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/dashucoding/p/12008700.html</dc:identifier>
</item>
<item>
<title>拿 C# 搞函数式编程 - 2 - hez2010</title>
<link>http://www.cnblogs.com/hez2010/p/12008677.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hez2010/p/12008677.html</guid>
<description>&lt;p&gt;前一阵子在写 CPU，导致一直没有什么时间去做其他的事情，现在好不容易做完闲下来了，我又可以水文章了哈哈哈哈哈。&lt;/p&gt;
&lt;p&gt;有关 FP 的类型部分我打算放到明年再讲，因为现有的 C# 虽然有一个 &lt;code&gt;pattern matching expressions&lt;/code&gt;，但是没有 &lt;code&gt;discriminated unions&lt;/code&gt; 和 &lt;code&gt;records&lt;/code&gt;，只能说是个半残废，要实现 FP 那一套的类型异常的复杂。西卡西，&lt;code&gt;discriminated unions&lt;/code&gt; 和 &lt;code&gt;records&lt;/code&gt; 这两个东西官方已经定到 C# 9 了，所以等明年 C# 9 发布了之后我再继续说这部分的内容。&lt;/p&gt;
&lt;p&gt;另外，&lt;code&gt;concepts&lt;/code&gt;（&lt;code&gt;type classes&lt;/code&gt;）、&lt;code&gt;traits&lt;/code&gt; 、&lt;code&gt;intersect &amp;amp; sum types&lt;/code&gt; 和高阶类型也可能会随着 C# 9、10 一并到来。因此到时候再讲才会讲得更爽。另外吹一波 &lt;code&gt;traits&lt;/code&gt;类型系统，同样是图灵完备的类型系统，在表达力上要比&lt;code&gt;OOP&lt;/code&gt;强太多，欢迎大家入坑，比如 Rust 和未来的 C#。&lt;/p&gt;
&lt;p&gt;这一部分我们介绍一下 &lt;code&gt;Functor&lt;/code&gt;、&lt;code&gt;Applicative&lt;/code&gt;和 &lt;code&gt;Monad&lt;/code&gt; 都是些什么。&lt;/p&gt;
&lt;p&gt;本文试图直观地讲，目的是让读者能比较容易的理解，而不是准确知道其概念如何，因此会尽量避免使用一些专用的术语，如范畴学、数学、λ 计算等等里面的东西。感兴趣的话建议参考其他更专业的资料。&lt;/p&gt;
&lt;h2&gt;Functor&lt;/h2&gt;
&lt;p&gt;Functor 也叫做函子。想象一下这样一件事情：&lt;/p&gt;
&lt;p&gt;现在我们有一个纯函数 &lt;code&gt;IsOdd&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;bool&lt;/span&gt; IsOdd(&lt;span&gt;int&lt;/span&gt; value) =&amp;gt; (value &amp;amp; &lt;span&gt;1&lt;/span&gt;) == &lt;span&gt;1&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个纯函数只干一件事情：判断输入是不是奇数。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;那么现在问题来了，如果我们有一个整数列表，要怎么去做上面这件事情呢？&lt;/p&gt;
&lt;p&gt;可能会有人说这太简单了，这样就可：&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;9&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; list = &lt;span&gt;new&lt;/span&gt; List&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; list.Select(IsOdd).ToList();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面这句干了件什么事情呢？其实就是：我们将 &lt;code&gt;IsOdd&lt;/code&gt; 函数应用到了列表中的每一个元素上，将产生的新的列表返回。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;现在我们做一次抽象，我们将这个列表想象成一个箱子&lt;code&gt;M&lt;/code&gt;，那么我们的需要干的事情就是：把一个装着 &lt;code&gt;A&lt;/code&gt; 类型东西的箱子变成一个装着 &lt;code&gt;B&lt;/code&gt; 类型东西的箱子（&lt;code&gt;A&lt;/code&gt;、&lt;code&gt;B&lt;/code&gt;类型可相同），即 &lt;code&gt;fmap&lt;/code&gt;函数，而做这个变化的方法就是：进入箱子&lt;code&gt;M&lt;/code&gt;，把里面的&lt;code&gt;A&lt;/code&gt;变成&lt;code&gt;B&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;它分别接收一个把东西从&lt;code&gt;A&lt;/code&gt;变成&lt;code&gt;B&lt;/code&gt;的函数、一个装着&lt;code&gt;A&lt;/code&gt;的&lt;code&gt;M&lt;/code&gt;，产生一个装着&lt;code&gt;B&lt;/code&gt;的&lt;code&gt;M&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;10&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
M&amp;lt;B&amp;gt; Fmap(&lt;span&gt;this&lt;/span&gt; M&amp;lt;A&amp;gt; input, Func&amp;lt;A, B&amp;gt; func);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;你暂且可以简单地认为，判断一个箱子是不是 &lt;code&gt;Functor&lt;/code&gt;，就是判断它有没有 &lt;code&gt;fmap&lt;/code&gt;这个操作。&lt;/p&gt;
&lt;/div&gt;
&lt;h2&gt;Maybe&lt;/h2&gt;
&lt;p&gt;我们应该都接触过 C# 的 &lt;code&gt;Nullable&amp;lt;T&amp;gt;&lt;/code&gt;类型，比如 &lt;code&gt;Nullable&amp;lt;int&amp;gt; t&lt;/code&gt;，或者写成 &lt;code&gt;int? t&lt;/code&gt;，这个t，当里面的值为 &lt;code&gt;null&lt;/code&gt; 时，它为 &lt;code&gt;null&lt;/code&gt;，否则他为包含的值。&lt;/p&gt;
&lt;p&gt;此时我们把这个 &lt;code&gt;Nullable&amp;lt;T&amp;gt;&lt;/code&gt;想象成这个箱子 &lt;code&gt;M&lt;/code&gt;。那么我们可以这么说，这个&lt;code&gt;M&lt;/code&gt;有两种形式，一种是 &lt;code&gt;Just&amp;lt;T&amp;gt;&lt;/code&gt;，表示有值，且值在 &lt;code&gt;Just&lt;/code&gt; 里面存放；另一种是 &lt;code&gt;Nothing&lt;/code&gt;，表示没有值。&lt;/p&gt;
&lt;p&gt;用 Haskell 写这个&lt;code&gt;Nullable&amp;lt;T&amp;gt;&lt;/code&gt;类型定义的话，大概长这个样子：&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;9&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
data Nullable x = Just x | Nothing
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而之所以这个&lt;code&gt;Nullable&amp;lt;T&amp;gt;&lt;/code&gt;既可能是 &lt;code&gt;Nothing&lt;/code&gt;，又可能是 &lt;code&gt;Just&amp;lt;T&amp;gt;&lt;/code&gt;，只是因为 C# 的 BCL 中包含相关的隐式转换而已。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;由于自带的 &lt;code&gt;Nullable&amp;lt;T&amp;gt;&lt;/code&gt;不太好具体讲我们的各种实现，且只接受值类型的数据，因此我们自己实现一个&lt;code&gt;Maybe&amp;lt;T&amp;gt;&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;9.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Maybe&amp;lt;T&amp;gt; &lt;span&gt;where&lt;/span&gt;&lt;span&gt; T : notnull
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; T innerValue;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; HasValue { &lt;span&gt;get&lt;/span&gt;; } = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; T Value =&amp;gt; HasValue ? innerValue : &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InvalidOperationException();

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Maybe(T value)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (value &lt;span&gt;is&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        innerValue &lt;/span&gt;=&lt;span&gt; value;
        HasValue &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Maybe(Maybe&amp;lt;T&amp;gt;&lt;span&gt; value)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!value.HasValue) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        innerValue &lt;/span&gt;=&lt;span&gt; value.Value;
        HasValue &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Maybe() { }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;implicit&lt;/span&gt; &lt;span&gt;operator&lt;/span&gt; Maybe&amp;lt;T&amp;gt;(T value) =&amp;gt; &lt;span&gt;new&lt;/span&gt; Maybe&amp;lt;T&amp;gt;&lt;span&gt;(value);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Maybe&amp;lt;T&amp;gt; Nothing() =&amp;gt; &lt;span&gt;new&lt;/span&gt; Maybe&amp;lt;T&amp;gt;&lt;span&gt;();
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; ToString() =&amp;gt; HasValue ? Value.ToString() : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Nothing&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于 &lt;code&gt;Maybe&amp;lt;T&amp;gt;&lt;/code&gt;，我们可以写一下它的 &lt;code&gt;fmap&lt;/code&gt;函数：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;10.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Maybe&amp;lt;B&amp;gt; Fmap&amp;lt;A, B&amp;gt;(&lt;span&gt;this&lt;/span&gt; Maybe&amp;lt;A&amp;gt; input, Func&amp;lt;A, B&amp;gt;&lt;span&gt; func)
    &lt;/span&gt;=&amp;gt; input &lt;span&gt;switch&lt;/span&gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;null&lt;/span&gt; =&amp;gt; Maybe&amp;lt;B&amp;gt;&lt;span&gt;.Nothing(),
        { HasValue: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt; } =&amp;gt; &lt;span&gt;new&lt;/span&gt; Maybe&amp;lt;B&amp;gt;&lt;span&gt;(func(input.Value)),
        _ &lt;/span&gt;=&amp;gt; Maybe&amp;lt;B&amp;gt;&lt;span&gt;.Nothing()
    };

Maybe&lt;/span&gt;&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; t1 = &lt;span&gt;7&lt;/span&gt;&lt;span&gt;;
Maybe&lt;/span&gt;&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; t2 = Maybe&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt;.Nothing();
Func&lt;/span&gt;&amp;lt;&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;bool&lt;/span&gt;&amp;gt; func = x =&amp;gt; (x &amp;amp; &lt;span&gt;1&lt;/span&gt;) == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
t1.Fmap(func); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Just True&lt;/span&gt;
t2.Fmap(func); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Nothing&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;h2&gt;Applicative&lt;/h2&gt;
&lt;p&gt;有了上面的东西，现在我们说说 &lt;code&gt;Applicative&lt;/code&gt; 是干什么的。&lt;/p&gt;
&lt;p&gt;你可以非常容易的发现，如果你为 &lt;code&gt;Maybe&amp;lt;T&amp;gt;&lt;/code&gt;实现一个 fmap，那么你可以说 &lt;code&gt;Maybe&amp;lt;T&amp;gt;&lt;/code&gt;就是一个 &lt;code&gt;Functor&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;那 &lt;code&gt;Applicative&lt;/code&gt; 也差不多，首先&lt;code&gt;Applicative&lt;/code&gt;是继承自&lt;code&gt;Functor&lt;/code&gt;的，所以&lt;code&gt;Applicative&lt;/code&gt;本身就具有了 &lt;code&gt;fmap&lt;/code&gt;。另外在 &lt;code&gt;Applicative&lt;/code&gt;中，我们有两个分别叫做&lt;code&gt;pure&lt;/code&gt;和 &lt;code&gt;apply&lt;/code&gt;的函数。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pure&lt;/code&gt;干的事情很简单，就是把东西装到箱子里：&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;11&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
M&amp;lt;T&amp;gt; Pure&amp;lt;T&amp;gt;(T input);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那 &lt;code&gt;apply&lt;/code&gt; 干了件什么事情呢？想象一下这件事情，此时我们把之前所说的那个用于变换的函数（&lt;code&gt;Func&amp;lt;A, B&amp;gt;&lt;/code&gt;）也装到了箱子当中，变成了&lt;code&gt;M&amp;lt;Func&amp;lt;A, B&amp;gt;&amp;gt;&lt;/code&gt;，那么&lt;code&gt;apply&lt;/code&gt;所做的就是下面这件事情：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;10&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
M&amp;lt;B&amp;gt; Apply(&lt;span&gt;this&lt;/span&gt; M&amp;lt;A&amp;gt; input, M&amp;lt;Func&amp;lt;A, B&amp;gt;&amp;gt; func);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看起来和 &lt;code&gt;fmap&lt;/code&gt;没有太大的区别，唯一的不同就是我们把&lt;code&gt;func&lt;/code&gt;也装到了箱子&lt;code&gt;M&lt;/code&gt;里面。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;以 &lt;code&gt;Maybe&amp;lt;T&amp;gt;&lt;/code&gt;为例实现 &lt;code&gt;apply&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;12.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Maybe&amp;lt;B&amp;gt; Apply&amp;lt;A, B&amp;gt;(&lt;span&gt;this&lt;/span&gt; Maybe&amp;lt;A&amp;gt; input, Maybe&amp;lt;Func&amp;lt;A, B&amp;gt;&amp;gt;&lt;span&gt; func)
    &lt;/span&gt;=&amp;gt; (input, func) &lt;span&gt;switch&lt;/span&gt;&lt;span&gt;
    {
        _ when input &lt;/span&gt;&lt;span&gt;is&lt;/span&gt; &lt;span&gt;null&lt;/span&gt; || func &lt;span&gt;is&lt;/span&gt; &lt;span&gt;null&lt;/span&gt; =&amp;gt; Maybe&amp;lt;B&amp;gt;&lt;span&gt;.Nothing(),
        ({ HasValue: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt; }, { HasValue: &lt;span&gt;true&lt;/span&gt; }) =&amp;gt; &lt;span&gt;new&lt;/span&gt; Maybe&amp;lt;B&amp;gt;&lt;span&gt;(func.Value(input.Value)),
        _ &lt;/span&gt;=&amp;gt; Maybe&amp;lt;B&amp;gt;&lt;span&gt;.Nothing()
    };&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后我们就可以干这件事情了：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;10.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
Maybe&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; input = &lt;span&gt;3&lt;/span&gt;&lt;span&gt;;
Maybe&lt;/span&gt;&amp;lt;Func&amp;lt;&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;bool&lt;/span&gt;&amp;gt;&amp;gt; isOdd = &lt;span&gt;new&lt;/span&gt; Func&amp;lt;&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;bool&lt;/span&gt;&amp;gt;(x =&amp;gt; (x &amp;amp; &lt;span&gt;1&lt;/span&gt;) == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);

input.Apply(isOdd); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Just True&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们的这个函数 &lt;code&gt;isOdd&lt;/code&gt;本身可能是 &lt;code&gt;Nothing&lt;/code&gt;，当 &lt;code&gt;input&lt;/code&gt;和&lt;code&gt;isOdd&lt;/code&gt;任何一个为&lt;code&gt;Nothing&lt;/code&gt;的时候，结果都是&lt;code&gt;Nothing&lt;/code&gt;，否则是&lt;code&gt;Just&lt;/code&gt;，并且将值存到这个 &lt;code&gt;Just&lt;/code&gt;里面。&lt;/p&gt;
&lt;/div&gt;
&lt;h2&gt;Monad&lt;/h2&gt;
&lt;p&gt;Monad 继承自 Applicative，并另外包含几个额外的操作：&lt;code&gt;returns&lt;/code&gt;、&lt;code&gt;bind&lt;/code&gt;和&lt;code&gt;then&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;returns&lt;/code&gt;干的事情和上面的&lt;code&gt;Applicative&lt;/code&gt;中&lt;code&gt;pure&lt;/code&gt;干的事情没有区别。&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Maybe&amp;lt;A&amp;gt; Returns&amp;lt;A&amp;gt;(&lt;span&gt;this&lt;/span&gt; A input) =&amp;gt; &lt;span&gt;new&lt;/span&gt; Maybe&amp;lt;A&amp;gt;(input);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;bind&lt;/code&gt;干这么一件事情 ：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;9.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
M&amp;lt;B&amp;gt; Bind&amp;lt;A, B&amp;gt;(&lt;span&gt;this&lt;/span&gt; M&amp;lt;A&amp;gt; input, Func&amp;lt;A, M&amp;lt;B&amp;gt;&amp;gt; func);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它用一个装在 &lt;code&gt;M&lt;/code&gt;中的&lt;code&gt;A&lt;/code&gt;，和一个&lt;code&gt;A -&amp;gt; M&amp;lt;B&amp;gt;&lt;/code&gt;这样的函数，产生一个&lt;code&gt;M&amp;lt;B&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;code&gt;then&lt;/code&gt;用来充当胶水的作用，将一个个操作连接起来：&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;10.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
M&amp;lt;B&amp;gt; Then(&lt;span&gt;this&lt;/span&gt; M&amp;lt;A&amp;gt; a, M&amp;lt;B&amp;gt; b);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为什么说这是充当胶水的作用呢？想象一下如果我们有两个 &lt;code&gt;Monad&lt;/code&gt;，那么使用 &lt;code&gt;then&lt;/code&gt;，就可以将上一个 &lt;code&gt;Monad&lt;/code&gt;和下一个&lt;code&gt;Monad&lt;/code&gt;利用函数组合起来将其连接，而不是写为两行语句。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;实现以上操作：&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;10&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Maybe&amp;lt;B&amp;gt; Bind&amp;lt;A, B&amp;gt;(&lt;span&gt;this&lt;/span&gt; Maybe&amp;lt;A&amp;gt; input, Func&amp;lt;A, Maybe&amp;lt;B&amp;gt;&amp;gt;&lt;span&gt; func)
    &lt;/span&gt;=&amp;gt; input &lt;span&gt;switch&lt;/span&gt;&lt;span&gt;
    {
        { HasValue: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt; } =&amp;gt;&lt;span&gt; func(input.Value),
        _ &lt;/span&gt;=&amp;gt; Maybe&amp;lt;B&amp;gt;&lt;span&gt;.Nothing()
    };

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Maybe&amp;lt;B&amp;gt; Then&amp;lt;A, B&amp;gt;(&lt;span&gt;this&lt;/span&gt; Maybe&amp;lt;A&amp;gt; input, Maybe&amp;lt;B&amp;gt; next) =&amp;gt; next;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;h2&gt;完整&lt;code&gt;Maybe&amp;lt;T&amp;gt;&lt;/code&gt;实现&lt;/h2&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;16.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Maybe&amp;lt;T&amp;gt; &lt;span&gt;where&lt;/span&gt;&lt;span&gt; T : notnull
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; T innerValue;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; HasValue { &lt;span&gt;get&lt;/span&gt;; } = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; T Value =&amp;gt; HasValue ? innerValue : &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InvalidOperationException();

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Maybe(T value)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (value &lt;span&gt;is&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        innerValue &lt;/span&gt;=&lt;span&gt; value;
        HasValue &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Maybe(Maybe&amp;lt;T&amp;gt;&lt;span&gt; value)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!value.HasValue) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        innerValue &lt;/span&gt;=&lt;span&gt; value.Value;
        HasValue &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Maybe() { }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;implicit&lt;/span&gt; &lt;span&gt;operator&lt;/span&gt; Maybe&amp;lt;T&amp;gt;(T value) =&amp;gt; &lt;span&gt;new&lt;/span&gt; Maybe&amp;lt;T&amp;gt;&lt;span&gt;(value);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Maybe&amp;lt;T&amp;gt; Nothing() =&amp;gt; &lt;span&gt;new&lt;/span&gt; Maybe&amp;lt;T&amp;gt;&lt;span&gt;();
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; ToString() =&amp;gt; HasValue ? Value.ToString() : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Nothing&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MaybeExtensions
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Maybe&amp;lt;B&amp;gt; Fmap&amp;lt;A, B&amp;gt;(&lt;span&gt;this&lt;/span&gt; Maybe&amp;lt;A&amp;gt; input, Func&amp;lt;A, B&amp;gt;&lt;span&gt; func)
        &lt;/span&gt;=&amp;gt; input &lt;span&gt;switch&lt;/span&gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;null&lt;/span&gt; =&amp;gt; Maybe&amp;lt;B&amp;gt;&lt;span&gt;.Nothing(),
            { HasValue: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt; } =&amp;gt; &lt;span&gt;new&lt;/span&gt; Maybe&amp;lt;B&amp;gt;&lt;span&gt;(func(input.Value)),
            _ &lt;/span&gt;=&amp;gt; Maybe&amp;lt;B&amp;gt;&lt;span&gt;.Nothing()
        };

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Maybe&amp;lt;B&amp;gt; Apply&amp;lt;A, B&amp;gt;(&lt;span&gt;this&lt;/span&gt; Maybe&amp;lt;A&amp;gt; input, Maybe&amp;lt;Func&amp;lt;A, B&amp;gt;&amp;gt;&lt;span&gt; func)
        &lt;/span&gt;=&amp;gt; (input, func) &lt;span&gt;switch&lt;/span&gt;&lt;span&gt;
        {
            _ when input &lt;/span&gt;&lt;span&gt;is&lt;/span&gt; &lt;span&gt;null&lt;/span&gt; || func &lt;span&gt;is&lt;/span&gt; &lt;span&gt;null&lt;/span&gt; =&amp;gt; Maybe&amp;lt;B&amp;gt;&lt;span&gt;.Nothing(),
            ({ HasValue: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt; }, { HasValue: &lt;span&gt;true&lt;/span&gt; }) =&amp;gt; &lt;span&gt;new&lt;/span&gt; Maybe&amp;lt;B&amp;gt;&lt;span&gt;(func.Value(input.Value)),
            _ &lt;/span&gt;=&amp;gt; Maybe&amp;lt;B&amp;gt;&lt;span&gt;.Nothing()
        };

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Maybe&amp;lt;A&amp;gt; Returns&amp;lt;A&amp;gt;(&lt;span&gt;this&lt;/span&gt; A input) =&amp;gt; &lt;span&gt;new&lt;/span&gt; Maybe&amp;lt;A&amp;gt;&lt;span&gt;(input);

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Maybe&amp;lt;B&amp;gt; Bind&amp;lt;A, B&amp;gt;(&lt;span&gt;this&lt;/span&gt; Maybe&amp;lt;A&amp;gt; input, Func&amp;lt;A, Maybe&amp;lt;B&amp;gt;&amp;gt;&lt;span&gt; func)
        &lt;/span&gt;=&amp;gt; input &lt;span&gt;switch&lt;/span&gt;&lt;span&gt;
        {
            { HasValue: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt; } =&amp;gt;&lt;span&gt; func(input.Value),
            _ &lt;/span&gt;=&amp;gt; Maybe&amp;lt;B&amp;gt;&lt;span&gt;.Nothing()
        };

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Maybe&amp;lt;B&amp;gt; Then&amp;lt;A, B&amp;gt;(&lt;span&gt;this&lt;/span&gt; Maybe&amp;lt;A&amp;gt; input, Maybe&amp;lt;B&amp;gt; next) =&amp;gt;&lt;span&gt; next;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;以上方法可以自行柯里化后使用，以及我调换了一些参数顺序便于使用，所以可能和定义有所出入。&lt;/p&gt;
&lt;h2&gt;有哪些常见的 Monads&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Maybe&lt;/li&gt;
&lt;li&gt;Either&lt;/li&gt;
&lt;li&gt;Try&lt;/li&gt;
&lt;li&gt;Reader&lt;/li&gt;
&lt;li&gt;Writer&lt;/li&gt;
&lt;li&gt;State&lt;/li&gt;
&lt;li&gt;IO&lt;/li&gt;
&lt;li&gt;List&lt;/li&gt;
&lt;li&gt;......&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;C# 中有哪些 Monads&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Task&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Nullable&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt;+&lt;code&gt;SelectMany&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;......&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;为什么需要 Monads&lt;/h2&gt;
&lt;p&gt;想象一下，现在世界上只有一种函数：纯函数。它接收一个参数，并且对于每一个参数值，给出固定的返回值，即 &lt;code&gt;f(x)&lt;/code&gt;对于相同参数恒不变。&lt;/p&gt;
&lt;p&gt;那现在问题来了，如果我需要可空的值 &lt;code&gt;Maybe&lt;/code&gt;或者随机数&lt;code&gt;Random&lt;/code&gt;等等，前者除了值本身之外，还带有一个是否有值的状态，而后者还跟计算机的运行环境、时间等随机数种子的因素有关。如果我们所有的函数都是纯函数，那么我们如何用一个函数去产生 &lt;code&gt;Maybe&lt;/code&gt; 和 &lt;code&gt;Random&lt;/code&gt; 呢？&lt;/p&gt;
&lt;p&gt;前者可能只需要给函数增加一个参数：是否有值，然而后者呢？牵扯到时间、硬件、环境等等一切和产生随机数种子有关的状态，我们当然可以将所有状态都当作参数传入，然后生成一个随机数，那更复杂的，&lt;code&gt;IO&lt;/code&gt;如何处理？&lt;/p&gt;
&lt;p&gt;这类函数都是与环境和状态密切相关的，状态是可变的，并不能简单的由参数做映射产生固定的结果，即这类函数具有副作用。但是，我们可以将状态和值打包起来装在箱子里，这个箱子即 &lt;code&gt;Monad&lt;/code&gt;，这样我们所有涉及到副作用的操作都可以在这个箱子内部完成，将可变的状态隔离在其中，而对外则为一个单体，仍然保持了其不变性。&lt;/p&gt;
&lt;p&gt;以随机数 &lt;code&gt;Random&lt;/code&gt;为例，我们想给随机数加 1。（下面的代码我就用 Haskell 放飞自我了）&lt;/p&gt;
&lt;p&gt;我们现在已经有两个函数，&lt;code&gt;nextRandom&lt;/code&gt;用于产生一个 &lt;code&gt;Random Int&lt;/code&gt;，&lt;code&gt;plusOne&lt;/code&gt;用于给一个 &lt;code&gt;Int&lt;/code&gt; 加 1：&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;9.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
nextRandom :: Random Int &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回值类型为 Random Int&lt;/span&gt;
plusOne :: Int -&amp;gt; Int &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 参数类型为 Int，返回值类型为 Int&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后我们有 &lt;code&gt;bind&lt;/code&gt;和&lt;code&gt;returns&lt;/code&gt;操作，那我们只需要利用着两个操作将我们已有的两个函数组合即可：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
bind (nextRandom (returns plusOne))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;利用符号表示即为：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
nextRandom &amp;gt;&amp;gt;= plusOne
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样我们将状态等带有副作用的操作全部隔离在了 Monad 中，我们接触到的东西都是不变的，并且满足 &lt;code&gt;f(g(x)) = g(f(x))&lt;/code&gt;！&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;当然这个例子使用&lt;code&gt;Monad&lt;/code&gt;的&lt;code&gt;bind&lt;/code&gt;操作纯属小题大做，此例子中只需要利用&lt;code&gt;Functor&lt;/code&gt;的 &lt;code&gt;fmap&lt;/code&gt;操作能搞定：&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
fmap plusOne nextRandom
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;利用符号表示即为：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;highlight&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
plusOne &amp;lt;$&amp;gt; nextRandom
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Sun, 08 Dec 2019 15:39:00 +0000</pubDate>
<dc:creator>hez2010</dc:creator>
<og:description>前一阵子在写 CPU，导致一直没有什么时间去做其他的事情，现在好不容易做完闲下来了，我又可以水文章了哈哈哈哈哈。 有关 FP 的类型部分我打算放到明年再讲，因为现有的 C# 虽然有一个&amp;#160;pa</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hez2010/p/12008677.html</dc:identifier>
</item>
<item>
<title>01-TensorFlow2.0基础 - hp_lake</title>
<link>http://www.cnblogs.com/hp-lake/p/12008559.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hp-lake/p/12008559.html</guid>
<description>&lt;h2 id=&quot;tensorflow是什么&quot;&gt;Tensorflow是什么&lt;/h2&gt;
&lt;p&gt;Google的开源软件库&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;采取数据流图，用于数值计算&lt;/li&gt;
&lt;li&gt;支持多种平台 - GPU、CPU、 移动设备&lt;/li&gt;
&lt;li&gt;最初用于深度学习，变得越来越通用&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;tensorflow数据结构&quot;&gt;Tensorflow数据结构&lt;/h3&gt;
&lt;h3 id=&quot;数据流图&quot;&gt;#数据流图&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1851919/201912/1851919-20191208230334342-337189380.png&quot;/&gt;&lt;/p&gt;
&lt;ol readability=&quot;-2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;线：节点之间的输入输出关系，线上运输张量. &lt;strong&gt;tensor：张量&lt;/strong&gt;- 指代数据&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;节点：operation (op): 专门运算的操作节点，所有的操作都是一个op，处理数据&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;只要使用tensorflow的API定义的函数都是OP&lt;/li&gt;
&lt;li&gt;节点被分配到各种计算设备上运行&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1851919/201912/1851919-20191208230351379-1933850892.png&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;graph: 图 整个的程序结构&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;本质上是一个分配的内存位置，默认有一个图，所有的tensor 和 op 的内存地址都是一样的。&lt;/li&gt;
&lt;li&gt;不同的图内存地址不一样，计算的过程中互不干扰&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;session: 会话： 运算程序的图 （只能运行一张图，可以在会话中指定图去运行 graph = g）&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;运行图的结构&lt;/li&gt;
&lt;li&gt;分配资源计算&lt;/li&gt;
&lt;li&gt;掌握资源（变量、队列、线程）&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;tensorflow的特性&quot;&gt;Tensorflow的特性&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;高度的灵活性，便于调用函数，也可以写自己的封装&lt;/li&gt;
&lt;li&gt;真正的可移植性，在不同的设备上都可以简单运行&lt;/li&gt;
&lt;li&gt;产品和科研结合&lt;/li&gt;
&lt;li&gt;自动求微分，主要用于反向传播计算&lt;/li&gt;
&lt;li&gt;多语言支持，C++， Java , JS, R&lt;/li&gt;
&lt;li&gt;性能最优化&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;tensorflow的前后端系统&quot;&gt;Tensorflow的前后端系统&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;前端系统：定义程序的图的机构&lt;/li&gt;
&lt;li&gt;后端系统： 运算图结构&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;tensorflow版本变迁&quot;&gt;Tensorflow版本变迁&lt;/h2&gt;
&lt;h3 id=&quot;tensorflow1.0-主要特性&quot;&gt;Tensorflow1.0 主要特性&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;XLA: Accelerate Linear Algebra
&lt;ul&gt;&lt;li&gt;提升训练速度58倍&lt;/li&gt;
&lt;li&gt;可以在移动设备上运行&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;引用更高级别的API
&lt;ul&gt;&lt;li&gt;tf.layers/ tf.metrics / tf.losses/ tf.keras&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Tensorflow调试器&lt;/li&gt;
&lt;li&gt;支持docker镜像，引入tensorflow serving 服务&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1851919/201912/1851919-20191208230521585-583340704.png&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;tensorflow-2.0-主要特性&quot;&gt;Tensorflow 2.0 主要特性&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;使用tf.keras 和 eager mode 进行简单模型构建&lt;/li&gt;
&lt;li&gt;鲁棒的跨平台模型部署&lt;/li&gt;
&lt;li&gt;强大的研究实验&lt;/li&gt;
&lt;li&gt;清除了不推荐使用和重复的API&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1851919/201912/1851919-20191208230428225-1846099188.png&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;tensorflow2.0-简化模型开发流程&quot;&gt;Tensorflow2.0 简化模型开发流程&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;使用tf.data加载数据&lt;/li&gt;
&lt;li&gt;使用tf.keras 构建模型，也可以使用premade estimator 验证模型
&lt;ul&gt;&lt;li&gt;使用tensorflow hub进行迁移学习&lt;/li&gt;
&lt;li&gt;注： 迁移学习 - 使用一个前人预先训练好的，应用在其他领域的网络作为模型训练的起点，站在前人基础上更进一步，不必重新发明轮子。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;使用eager mode 进行运行和调试&lt;/li&gt;
&lt;li&gt;使用分发策略进行分布式训练&lt;/li&gt;
&lt;li&gt;导出到SavedModel&lt;/li&gt;
&lt;li&gt;使用Tensorflow Serve, Tensorflow Lite, Tensorflow.js&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;tensorflow-强大的跨平台能力&quot;&gt;Tensorflow 强大的跨平台能力&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;Tensorflow 服务
&lt;ul&gt;&lt;li&gt;直接通过HTTP/ TEST 或 GTPC/协议缓冲区&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Tensorflow Lite - Android, iOS 和嵌入式&lt;/li&gt;
&lt;li&gt;Tensorflow.js - Javascript 部署&lt;/li&gt;
&lt;li&gt;其他语言&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;tensorflow-vs.-pytorch&quot;&gt;Tensorflow vs. Pytorch&lt;/h2&gt;
&lt;h3 id=&quot;入门时间易用性&quot;&gt;入门时间（易用性）&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;Tensorflow 1.*
&lt;ul&gt;&lt;li&gt;静态图 ，构建完之后不可以更改, 效率高&lt;/li&gt;
&lt;li&gt;额外概念， 会话，变量，占位符&lt;/li&gt;
&lt;li&gt;写样本代码&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Tensorflow 2.0
&lt;ul&gt;&lt;li&gt;动态图， 构建完之后可以更改， 效率不高，调试容易&lt;/li&gt;
&lt;li&gt;Eager mode 直接集成在python中&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Pytorch
&lt;ul&gt;&lt;li&gt;动态图&lt;/li&gt;
&lt;li&gt;numpy扩展，集成在python&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;&quot;&quot;&quot;
不同方式求解 1 + 1/2 + 1/2^2 + 1/2^3 + ...... + 1/2^50
&quot;&quot;&quot;

# 1. tensorflow 1.*求解
import tensorflow as tf
print(tf.__version__)
x = tf.Variable(0.)
y = tf.Variable(1.)

add_op = x.assign(x + y)
div_op = y.assign(y / 2)

with tf.Session() as sess:
    sess.run(tf.global_variables_initializer()) 
    for iteration in range(50):
        sess.run(add_op)
        sess.run(div_op)
    print(x.eval())


# 2. pytorch 求解
import torch
print(torch.__version__)

x = torch.Tensor([0.])
y = torch.Tensor([1.])
for iteration in range(50):
    x = x + y
    y = y / 2
print(x)


# 3. tensorflow 2.0 求解
import tensorflow as tf
print(tf.__version__)
x = tf.constant(0.)
y = tf.constant(1.)
for iteration in range(50):
    x = x + y
    y = y / 2
print(x.numpy())


# 4. 纯python求解
x = 0
y = 1
for iteration in range(50):
    x = x + y
    y = y / 2
print(x)  # 精度有点不一样&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;图创建和调试&quot;&gt;图创建和调试&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;Tensorflow 1.*
&lt;ul&gt;&lt;li&gt;静态图，难以调试， 需要使用tfdbg&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Tensorflow 2.0 与 pytorch
&lt;ul&gt;&lt;li&gt;动态图，python自带的调试工具&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;全面性&quot;&gt;全面性&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;python缺少少量的功能，使用频次很低
&lt;ul&gt;&lt;li&gt;沿维翻转张量 （np.flip, np.flipud, np.fliplr)&lt;/li&gt;
&lt;li&gt;检查无穷与非数值张量（np.is_nan, np.is_inf)&lt;/li&gt;
&lt;li&gt;快速傅里叶变换 （np.fft)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;序列化和部署&quot;&gt;序列化和部署&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;Tensorflow 支持更加广泛，多语言，跨平台&lt;/li&gt;
&lt;li&gt;pytorch 支持比较简单&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Sun, 08 Dec 2019 15:06:00 +0000</pubDate>
<dc:creator>hp_lake</dc:creator>
<og:description>01 TensorFlow基础 Tensorflow是什么 Google的开源软件库 采取数据流图，用于数值计算 支持多种平台 GPU、CPU、 移动设备 最初用于深度学习，变得越来越通用 Tenso</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hp-lake/p/12008559.html</dc:identifier>
</item>
<item>
<title>基于springboot的web项目最佳实践 - 赵孤鸿</title>
<link>http://www.cnblogs.com/zhaoguhong/p/12008499.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhaoguhong/p/12008499.html</guid>
<description>&lt;p&gt;&lt;code&gt;springboot&lt;/code&gt; 可以说是现在做&lt;code&gt;javaweb&lt;/code&gt;开发最火的技术，我在基于&lt;code&gt;springboot&lt;/code&gt;搭建项目的过程中，踩过不少坑，发现整合框架时并非仅仅引入&lt;code&gt;starter&lt;/code&gt; 那么简单。&lt;/p&gt;
&lt;p&gt;要做到简单，易用，扩展性更好，还需做不少二次封装，于是便写了个基于&lt;code&gt;springboot&lt;/code&gt;的web项目脚手架，对一些常用的框架进行整合，并进行了简单的二次封装。&lt;/p&gt;
&lt;p&gt;项目名&lt;code&gt;baymax&lt;/code&gt;取自动画片超能陆战队里面的大白，大白是一个医护充气机器人，希望这个项目你能像大白一样贴心，可以减少你的工作量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;github&lt;/strong&gt; https://github.com/zhaoguhong/baymax&lt;/p&gt;
&lt;h2 id=&quot;web&quot;&gt;&lt;span id=&quot;web&quot;&gt;web&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;web模块是开发web项目必不可少的一个模块&lt;/p&gt;
&lt;p&gt;maven 依赖&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于前后端分离项目，推荐直接使用&lt;code&gt;@RestController&lt;/code&gt;注解&lt;br/&gt;需要注意的是，&lt;strong&gt;不建议直接用RequstMapping注解并且不指定方法类型的写法&lt;/strong&gt;，推荐使用&lt;code&gt;GetMaping&lt;/code&gt;或者&lt;code&gt;PostMaping&lt;/code&gt;之类的注解&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@SpringBootApplication
@RestController
public class BaymaxApplication {

  public static void main(String[] args) {
    SpringApplication.run(BaymaxApplication.class, args);
  }

  @GetMapping(&quot;/test&quot;)
  public String test() {
    return &quot;hello baymax&quot;;
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;单元测试&quot;&gt;&lt;span id=&quot;test&quot;&gt;单元测试&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;spring 对单元测试也提供了很好的支持&lt;/p&gt;
&lt;p&gt;maven 依赖&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
      &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;添加 &lt;code&gt;@RunWith(SpringRunner.class)&lt;/code&gt; 和 &lt;code&gt;@SpringBootTest&lt;/code&gt; 即可进行测试&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RunWith(SpringRunner.class)
@SpringBootTest
public class WebTest {
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于&lt;code&gt;Controller&lt;/code&gt;层的接口，可以直接用&lt;code&gt;MockMvc&lt;/code&gt;进行测试&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RunWith(SpringRunner.class)
@SpringBootTest
public class WebTest {

  @Autowired
  private WebApplicationContext context;
  private MockMvc mvc;

  @Before
  public void setUp() throws Exception {
    mvc = MockMvcBuilders.webAppContextSetup(context).build();
  }

  @Test
  public void testValidation() throws Exception {
    mvc.perform(MockMvcRequestBuilders.get(&quot;/test&quot;))
        .andExpect(MockMvcResultMatchers.status().isOk())
        .andDo(MockMvcResultHandlers.print())
        .andExpect(MockMvcResultMatchers.content().string(&quot;hello baymax&quot;));
  }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;actuator应用监控&quot;&gt;&lt;span id=&quot;actuator&quot;&gt;actuator应用监控&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;actuator 是 spring 提供的应用监控功能，常用的配置项如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# actuator端口 默认应用端口
management.server.port=8082
# 加载所有的端点 默认只加载 info,health
management.endpoints.web.exposure.include=*
# actuator路径前缀，默认 /actuator
management.endpoints.web.base-path=/actuator&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;lombok&quot;&gt;&lt;span id=&quot;lombok&quot;&gt;lombok&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;lombok可以在编译期生成对应的java代码，使代码看起来更简洁，同时减少开发工作量&lt;/p&gt;
&lt;p&gt;用lombok后的实体类&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Data
public class Demo {
  private Long id;
  private String userName;
  private Integer age;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要注意，&lt;code&gt;@Data&lt;/code&gt; 包含 &lt;code&gt;@ToString、@Getter、@Setter、@EqualsAndHashCode、@RequiredArgsConstructor&lt;/code&gt;，&lt;strong&gt;RequiredArgsConstructor 并不是无参构造&lt;/strong&gt;，无参构造的注解是&lt;code&gt;NoArgsConstructor&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;RequiredArgsConstructor&lt;/code&gt; 会生成 会生成一个包含常量（final），和标识了@NotNull的变量 的构造方法&lt;/p&gt;
&lt;h2 id=&quot;baseentity&quot;&gt;&lt;span id=&quot;baseEntity&quot;&gt;baseEntity&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;把表中的基础字段抽离出来一个BaseEntity,所有的实体类都继承该类&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 实体类基础类
 */
@Data
public abstract class BaseEntity implements Serializable {
  /**
   * 主键id
   */
  private Long id;
  /**
   * 创建人
   */
  private Long createdBy;
  /**
   * 创建时间
   */
  private Date createdTime;
  /**
   * 更新人
   */
  private Long updatedBy;
  /**
   * 更新时间
   */
  private Date updatedTime;
  /**
   * 是否删除
   */
  private Integer isDeleted;

}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;统一响应返回值&quot;&gt;&lt;span id=&quot;result&quot;&gt;统一响应返回值&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;前后端分离项目基本上都是ajax调用，所以封装一个统一的返回对象有利于前端统一处理&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 用于 ajax 请求的响应工具类
 */
@Data
public class ResponseResult&amp;lt;T&amp;gt; {
  // 未登录
  public static final String UN_LOGIN_CODE = &quot;401&quot;;
  // 操作失败
  public static final String ERROR_CODE = &quot;400&quot;;
  // 服务器内部执行错误
  public static final String UNKNOWN_ERROR_CODE = &quot;500&quot;;
  // 操作成功
  public static final String SUCCESS_CODE = &quot;200&quot;;
  // 响应信息
  private String msg;
  // 响应code
  private String code;
  // 操作成功，响应数据
  private T data;

  public ResponseResult(String code, String msg, T data) {
    this.msg = msg;
    this.code = code;
    this.data = data;
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回给前端的值用&lt;code&gt;ResponseResult&lt;/code&gt;包装一下&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;  /**
   * 测试成功的 ResponseResult
   */
  @GetMapping(&quot;/successResult&quot;)
  public ResponseResult&amp;lt;List&amp;lt;Demo&amp;gt;&amp;gt; test() {
    List&amp;lt;Demo&amp;gt; demos = demoMapper.getDemos();
    return ResponseResult.success(demos);
  }

  /**
   * 测试失败的 ResponseResult
   */
  @GetMapping(&quot;/errorResult&quot;)
  public ResponseResult&amp;lt;List&amp;lt;Demo&amp;gt;&amp;gt; demo() {
    return ResponseResult.error(&quot;操作失败&quot;);
  }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;responseentity&quot;&gt;ResponseEntity&lt;/h3&gt;
&lt;p&gt;spring其实封装了ResponseEntity 处理响应，ResponseEntity 包含 状态码，头部信息，响应体 三部分&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;  /**
   * 测试请求成功
   * @return
   */
  @GetMapping(&quot;/responseEntity&quot;)
  public ResponseEntity&amp;lt;String&amp;gt; responseEntity() {
    return ResponseEntity.ok(&quot;请求成功&quot;);
  }

  /**
   * 测试服务器内部错误
   * @return
   */
  @GetMapping(&quot;/InternalServerError&quot;)
  public ResponseEntity&amp;lt;String&amp;gt; responseEntityerror() {
    return new ResponseEntity&amp;lt;&amp;gt;(&quot;出错了&quot;, HttpStatus.INTERNAL_SERVER_ERROR);
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;异常&quot;&gt;&lt;span id=&quot;exception&quot;&gt;异常&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;自定义异常体系&quot;&gt;自定义异常体系&lt;/h3&gt;
&lt;p&gt;为了方便异常处理，定义一套异常体系，BaymaxException 做为所有自定义异常的父类&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 项目所有自定义异常的父类
public class BaymaxException extends RuntimeException
// 业务异常 该异常的信息会返回给用户
public class BusinessException  extends BaymaxException
// 用户未登录异常
public class NoneLoginException  extends BaymaxException&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;全局异常处理&quot;&gt;全局异常处理&lt;/h3&gt;
&lt;p&gt;对所有的异常处理后再返回给前端&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RestControllerAdvice
public class GlobalControllerExceptionHandler {

  /**
   * 业务异常
   */
  @ExceptionHandler(value = {BusinessException.class})
  public ResponseResult&amp;lt;?&amp;gt; handleBusinessException(BusinessException ex) {
    String msg = ex.getMessage();
    if (StringUtils.isBlank(msg)) {
      msg = &quot;操作失败&quot;;
    }
    return ResponseResult.error(msg);
  }

  /**
   * 处理未登录异常
   */
  @ExceptionHandler(value = {NoneLoginException.class})
  public ResponseResult&amp;lt;?&amp;gt; handleNoneLoginException(NoneLoginException ex) {
    return ResponseResult.unLogin();
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;异常持久化&quot;&gt;异常持久化&lt;/h3&gt;
&lt;p&gt;对于未知的异常，保存到数据库，方便后续排错&lt;/p&gt;
&lt;p&gt;需要说明是的，如果项目访问量比较大，推荐用 ELK 这种成熟的日志分析系统，不推荐日志保存到关系型数据库&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;  @Autowired
  private ExceptionLogMapper exceptionLogMapper;
  /**
   * 处理未知的错误
   */
  @ExceptionHandler(value = {Exception.class})
  public ResponseResult&amp;lt;Long&amp;gt; handleunknownException(Exception ex) {
    ExceptionLog log = new ExceptionLog(new Date(), ExceptionUtils.getStackTrace(ex));
    exceptionLogMapper.insert(log);
    ResponseResult&amp;lt;Long&amp;gt; result = ResponseResult.unknownError(&quot;服务器异常:&quot; + log.getId());
    result.setData(log.getId());
    return result;
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;异常日志接口&quot;&gt;异常日志接口&lt;/h3&gt;
&lt;p&gt;对外开一个异常日志查询接口&lt;code&gt;/anon/exception/{异常日志id}&lt;/code&gt;，方便查询&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RestController
@RequestMapping(&quot;/anon/exception&quot;)
public class ExceptionController {

  @Autowired
  private ExceptionLogMapper exceptionLogMapper;

  @GetMapping(value = &quot;/{id}&quot;)
  public String getDemo(@PathVariable(value = &quot;id&quot;) Long id) {
    return exceptionLogMapper.selectByPrimaryKey(id).getException();
  }

} &lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;数据校验&quot;&gt;&lt;span id=&quot;validation&quot;&gt;数据校验&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.ibm.com/developerworks/cn/java/j-lo-jsr303/&quot;&gt;JSR 303&lt;/a&gt;定义了一系列的 Bean Validation 规范，Hibernate Validator 是 Bean Validation 的实现，并进行了扩展&lt;/p&gt;
&lt;p&gt;spring boot 使用 也非常方便&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Demo extends BaseEntity{
  @NotBlank(message = &quot;用户名不允许为空&quot;)
  private String userName;
  @NotBlank
  private String title;
  @NotNull
  private Integer age;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数前面添加@Valid注解即可&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;  @PostMapping(&quot;/add&quot;)
  public ResponseResult&amp;lt;String&amp;gt; add(@RequestBody @Valid Demo demo) {
    demoMapper.insert(demo);
    return ResponseResult.success();
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于校验结果可以每个方法单独处理，如果不处理，会抛出有异常，可以对校验的异常做全局处理&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;GlobalControllerExceptionHandler&lt;/code&gt; 添加&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;  /**
   * 处理校验异常
   */
  @ExceptionHandler(MethodArgumentNotValidException.class)
  public ResponseResult&amp;lt;?&amp;gt; handleValidationException(MethodArgumentNotValidException ex) {
    BindingResult result = ex.getBindingResult();
    if (result.hasErrors()) {
      StringJoiner joiner = new StringJoiner(&quot;，&quot;);
      List&amp;lt;ObjectError&amp;gt; errors = result.getAllErrors();
      errors.forEach(error -&amp;gt; {
        FieldError fieldError = (FieldError) error;
        joiner.add(fieldError.getField() + &quot; &quot; + error.getDefaultMessage());
      });
      return ResponseResult.error(joiner.toString());
    } else {
      return ResponseResult.error(&quot;操作失败&quot;);
    }
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;log&quot;&gt;&lt;span id=&quot;log&quot;&gt;log&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;spring boot 的默认使用的日志是&lt;code&gt;logback&lt;/code&gt;,web模块依赖的有日志 &lt;code&gt;starter&lt;/code&gt;，所以这里不用再引入依赖，&lt;a href=&quot;https://docs.spring.io/spring-boot/docs/2.1.5.RELEASE/reference/htmlsingle/#boot-features-logging&quot;&gt;详细配置&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;修改日志级别&quot;&gt;修改日志级别&lt;/h3&gt;
&lt;p&gt;Actuator 组件提供了日志相关接口，可以查询日志级别或者动态修改日志级别&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 查看所有包/类的日志级别
/actuator/loggers
// 查看指定包/类日志级别 get 请求
/actuator/loggers/com.zhaoguhong.baymax.demo.controller.DemoController
//修改日志级别 post 请求 参数 {&quot;configuredLevel&quot;:&quot;debug&quot;}
/actuator/loggers/com.zhaoguhong.baymax.demo.controller.DemoController&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;日志切面&quot;&gt;日志切面&lt;/h3&gt;
&lt;p&gt;添加一个日志切面，方便记录方法执行的入参和出参&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface LogAspect {

  /**
   * 日志描述
   */
  String value() default &quot;&quot;;

  /**
   * 日志级别
   */
  String level() default &quot;INFO&quot;;

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用时直接添加到方法上即可&lt;/p&gt;
&lt;h2 id=&quot;swagger&quot;&gt;&lt;span id=&quot;swagger&quot;&gt;swagger&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;swagger 是一个很好用的文档生成工具&lt;/p&gt;
&lt;p&gt;maven 依赖&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;io.springfox&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;springfox-swagger2&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;2.7.0&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;io.springfox&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;springfox-swagger-ui&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;2.7.0&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;相关配置&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Configuration
@EnableSwagger2
public class SwaggerConfig {

  @Value(&quot;${swagger.enable:false}&quot;)
  private boolean swaggerEnable;

  //文档访问前缀
  public static final String ACCESS_PREFIX = &quot;/swagger-resources/**,/swagger-ui.html**,/webjars/**,/v2/**&quot;;

  @Bean
  public Docket docket() {
    return new Docket(DocumentationType.SWAGGER_2)
        .apiInfo(apiInfo())
        // 设置是否开启swagger,生产环境关闭
        .enable(swaggerEnable)
        .select()
        // 当前包路径
        .apis(RequestHandlerSelectors.basePackage(&quot;com.zhaoguhong.baymax&quot;))
        .apis(RequestHandlerSelectors.withMethodAnnotation(ApiOperation.class))
        .paths(PathSelectors.any())
        .build();
  }

  // 构建api文档的详细信息
  private ApiInfo apiInfo() {
    return new ApiInfoBuilder()
        // 页面标题
        .title(&quot;接口文档&quot;)
        // 创建人
        .contact(new Contact(&quot;孤鸿&quot;, &quot;https://github.com/zhaoguhong/baymax&quot;, &quot;&quot;))
        // 版本号
        .version(&quot;1.0&quot;)
        // 描述
        .description(&quot;大白的接口文档&quot;)
        .build();
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为文档加一个开关&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#是否开启swagger文档，生产环境关闭
swagger.enable=true&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后就可以愉快的在写代码的同时写文档了&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;  @PostMapping(&quot;/add&quot;)
  @ApiOperation(value = &quot;新增 demo&quot;)
  public ResponseResult&amp;lt;String&amp;gt; add(@RequestBody @Valid Demo demo) {
    demoMapper.insert(demo);
    return ResponseResult.success();
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@ApiModel(&quot;示例&quot;)
public class Demo extends BaseEntity{
  @ApiModelProperty(&quot;用户名&quot;)
  private String userName;
  @ApiModelProperty(&quot;标题&quot;)
  private String title;
  @ApiModelProperty(&quot;年龄&quot;)
  private Integer age;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;访问 &lt;code&gt;localhost:8080/swagger-ui.html&lt;/code&gt; 就可以看到效果了&lt;/p&gt;
&lt;h2 id=&quot;数据库连接池&quot;&gt;&lt;span id=&quot;datasource&quot;&gt;数据库连接池&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;springboot1.X的数据库连接池是tomcat连接池，springboot2默认的数据库连接池由Tomcat换成 &lt;a href=&quot;https://github.com/brettwooldridge/HikariCP&quot;&gt;HikariCP&lt;/a&gt;，&lt;code&gt;HikariCP&lt;/code&gt;是一个高性能的JDBC连接池，号称最快的连接池&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/alibaba/druid&quot;&gt;Druid&lt;/a&gt; 是阿里巴巴数据库事业部出品，为监控而生的数据库连接池，这里选取&lt;code&gt;Druid&lt;/code&gt;作为项目的数据库连接池&lt;/p&gt;
&lt;p&gt;maven 依赖&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;druid-spring-boot-starter&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;1.1.10&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;设置用户名密码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;spring.datasource.druid.stat-view-servlet.login-username=admin
spring.datasource.druid.stat-view-servlet.login-password=123456&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后就可以访问 &lt;code&gt;localhost:8080/druid&lt;/code&gt;看监控信息了&lt;/p&gt;
&lt;h2 id=&quot;spring-jdbc&quot;&gt;&lt;span id=&quot;jdbc&quot;&gt;spring jdbc&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;maven 依赖&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;     &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;spring-boot-starter-jdbc&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;spring对jdbc做了封装和抽象，最常用的是 &lt;code&gt;jdbcTemplate&lt;/code&gt; 和 &lt;code&gt;NamedParameterJdbcTemplate&lt;/code&gt;两个类，前者使用占位符，后者使用命名参数，我在&lt;code&gt;jdbcDao&lt;/code&gt;做了一层简单的封装，提供统一的对外接口&lt;/p&gt;
&lt;p&gt;&lt;code&gt;jdbcDao&lt;/code&gt;主要方法如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 占位符
find(String sql, Object... args)
// 占位符，手动指定映射mapper
find(String sql, Object[] args, RowMapper&amp;lt;T&amp;gt; rowMapper)
// 命名参数
find(String sql, Map&amp;lt;String, ?&amp;gt; paramMap)
// 命名参数，手动指定映射mapper
find(String sql, Map&amp;lt;String, ?&amp;gt; paramMap, RowMapper&amp;lt;T&amp;gt; rowMapper)
//springjdbc 原queryForMap方法,如果没查询到会抛异常，此处如果没有查询到，返回null
queryForMap(String sql, Object... args)
queryForMap(String sql, Map&amp;lt;String, ?&amp;gt; paramMap)
// 分页查询
find(Page&amp;lt;T&amp;gt; page, String sql, Map&amp;lt;String, ?&amp;gt; parameters, RowMapper&amp;lt;?&amp;gt; mapper)
// 分页查询
find(Page&amp;lt;T&amp;gt; page, String sql, RowMapper&amp;lt;T&amp;gt; mapper, Object... args)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;jpa&quot;&gt;&lt;span id=&quot;jpa&quot;&gt;jpa&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;jpa&lt;/code&gt; 是 &lt;code&gt;java&lt;/code&gt; 持久化的标准，&lt;code&gt;spring data jpa&lt;/code&gt; 使操作数据库变得更方便，需要说明的 &lt;code&gt;spring data jpa&lt;/code&gt; 本身并不是jpa的实现，它默认使用的 &lt;code&gt;provider&lt;/code&gt; 是 &lt;code&gt;hibernate&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;maven 依赖&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;spring-boot-starter-data-jpa&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我把通用的方法抽取了出来了，封装了一个BaseRepository，使用时，直接继承该接口即可&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface DemoRepository extends BaseRepository&amp;lt;Demo&amp;gt; {

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;BaseRepository&lt;/code&gt; 主要方法如下&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 新增，会对创建时间，创建人自动赋值
void saveEntity(T entity)
// 更新，会对更新时间，更新人自动赋值
void updateEntity(T entity)
// 逻辑删除
void deleteEntity(T entity)
// 批量保存
void saveEntites(Collection&amp;lt;T&amp;gt; entitys)
// 批量更新
void updateEntites(Collection&amp;lt;T&amp;gt; entitys)
// 批量逻辑删除
void deleteEntites(Collection&amp;lt;T&amp;gt; entitys)
// 根据id获取实体，会过滤掉逻辑删除的
T getById(Long id)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果想使用传统的sql形式，可以直接使用JpaDao,为了方便使用，我尽量使JpaDao和JdbcDao的接口保持统一&lt;/p&gt;
&lt;p&gt;&lt;code&gt;JpaDao&lt;/code&gt;主要方法如下&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 占位符 例如：from Demo where id =?
find(String sql, Object... args)
// 命名参数
find(String sql, Map&amp;lt;String, ?&amp;gt; paramMap)
// 分页
find(Page&amp;lt;T&amp;gt; page, String hql, Map&amp;lt;String, ?&amp;gt; parameters)
// 分页
find(Page&amp;lt;T&amp;gt; page, String hql, Object... parameters)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;redis&quot;&gt;&lt;span id=&quot;redis&quot;&gt;redis&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;Redis 是性能极佳key-value数据库，常用来做缓存，&lt;br/&gt;java 中常用的客户端有 &lt;code&gt;Jedis&lt;/code&gt; 和 &lt;code&gt;Lettuce&lt;/code&gt;, &lt;code&gt;spring data redis&lt;/code&gt; 是基于 &lt;code&gt;Lettuce&lt;/code&gt; 做的二次封装&lt;/p&gt;
&lt;p&gt;maven 依赖&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;spring-boot-starter-data-redis&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了在redis读起来更方便，更改序列化方式&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Configuration
public class RedisConfig {

  /**
   * 设置序列化方式
   */
  @Bean
  public RedisTemplate&amp;lt;Object, Object&amp;gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) {
    RedisTemplate&amp;lt;Object, Object&amp;gt; redisTemplate = new RedisTemplate&amp;lt;&amp;gt;();
    redisTemplate.setConnectionFactory(redisConnectionFactory);
    redisTemplate.setKeySerializer(RedisSerializer.string());
    redisTemplate.setValueSerializer(jackson2JsonRedisSerializer());
    redisTemplate.setHashKeySerializer(RedisSerializer.string());
    redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer());
    return redisTemplate;
  }

  @Bean
  public Jackson2JsonRedisSerializer&amp;lt;Object&amp;gt; jackson2JsonRedisSerializer() {
    ObjectMapper om = new ObjectMapper();
    om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
    // 将类名称序列化到json串中
    om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
    Jackson2JsonRedisSerializer&amp;lt;Object&amp;gt; jackson2JsonRedisSerializer =
        new Jackson2JsonRedisSerializer&amp;lt;Object&amp;gt;(Object.class);
    jackson2JsonRedisSerializer.setObjectMapper(om);
    return jackson2JsonRedisSerializer;
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;spring-cache&quot;&gt;&lt;span id=&quot;springcache&quot;&gt;spring cache&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;spring cache 抽象出了一组缓存接口，通过注解的方式使用，可以很方便的配置其具体实现，&lt;a href=&quot;https://docs.spring.io/spring-boot/docs/2.1.5.RELEASE/reference/htmlsingle/#boot-features-caching&quot;&gt;详细配置&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里使用redis做为缓存 provider, 默认的value序列化方式是JDK，为方便查看，可以修改为用json序列化&lt;/p&gt;
&lt;p&gt;有时会有设置&lt;code&gt;redis key&lt;/code&gt;前缀的需求，默认是这样的&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    static CacheKeyPrefix simple() {
        // 在 cacheName 后面添加 &quot;::&quot;
        return name -&amp;gt; name + &quot;::&quot;;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;spring boot 提供的有配置前缀的属性&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;spring.cache.redis.key-prefix= # Key prefix.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但这是一个坑，这样写的效果实际这样的，会把&lt;code&gt;cacheName&lt;/code&gt;干掉，显然不是我们想要的&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;CacheKeyPrefix cacheKeyPrefix = (cacheName) -&amp;gt; prefix;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们想要的是把前缀加在最前面，保留&lt;code&gt;cacheName&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;CacheKeyPrefix cacheKeyPrefix = (cacheName) -&amp;gt; keyPrefix + &quot;::&quot; + cacheName + &quot;::&quot;;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参考&lt;code&gt;org.springframework.boot.autoconfigure.cache.RedisCacheConfiguration&lt;/code&gt;，声明 &lt;code&gt;RedisCacheManager&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Configuration
@EnableConfigurationProperties(CacheProperties.class)
@EnableCaching
public class SpringCacheConfig {

  @Autowired
  private CacheProperties cacheProperties;

  @Bean
  public RedisCacheManager cacheManager(RedisConnectionFactory redisConnectionFactory) {
    RedisCacheManagerBuilder builder = RedisCacheManager
        .builder(redisConnectionFactory)
        .cacheDefaults(determineConfiguration());
    List&amp;lt;String&amp;gt; cacheNames = this.cacheProperties.getCacheNames();
    if (!cacheNames.isEmpty()) {
      builder.initialCacheNames(new LinkedHashSet&amp;lt;&amp;gt;(cacheNames));
    }
    return builder.build();
  }

  private org.springframework.data.redis.cache.RedisCacheConfiguration determineConfiguration() {
    Redis redisProperties = this.cacheProperties.getRedis();
    org.springframework.data.redis.cache.RedisCacheConfiguration config = org.springframework.data.redis.cache.RedisCacheConfiguration
        .defaultCacheConfig();
    // 修改序列化为json
    config = config.serializeValuesWith(RedisSerializationContext.SerializationPair
        .fromSerializer(jackson2JsonRedisSerializer()));
    if (redisProperties.getTimeToLive() != null) {
      config = config.entryTtl(redisProperties.getTimeToLive());
    }
    if (redisProperties.getKeyPrefix() != null) {
      // 重写前缀拼接方式
      config = config.computePrefixWith((cacheName) -&amp;gt; redisProperties.getKeyPrefix() + &quot;::&quot; + cacheName + &quot;::&quot;);
    }
    if (!redisProperties.isCacheNullValues()) {
      config = config.disableCachingNullValues();
    }
    if (!redisProperties.isUseKeyPrefix()) {
      config = config.disableKeyPrefix();
    }
    return config;
  }
    // 省略 jackson2JsonRedisSerializer() 

}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;mogodb&quot;&gt;&lt;span id=&quot;mogodb&quot;&gt;mogodb&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;MongoDB 是文档型数据库，使用 &lt;code&gt;spring data mogodb&lt;/code&gt; 可以很方便对mogodb进行操作&lt;/p&gt;
&lt;p&gt;maven 依赖&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;spring-boot-starter-data-mongodb&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;sprign data mogodb&lt;/code&gt; 提供了 &lt;code&gt;MongoTemplate&lt;/code&gt; 对mogodb进行操作，我在该类的基础上又扩展了一下，可以自定义自己的方法&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Configuration
public class MongoDbConfig {

  /**
   * 扩展自己的mogoTemplate
   */
  @Bean
  public MyMongoTemplate mongoTemplate(MongoDbFactory mongoDbFactory,
      MongoConverter converter) {
    return new MyMongoTemplate(mongoDbFactory, converter);
  }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我扩展了一个分页的方法，可以根据自己的情况扩展其它方法&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// mogodb 分页
public &amp;lt;T&amp;gt; Page&amp;lt;T&amp;gt; find(Page&amp;lt;T&amp;gt; page, Query query, Class&amp;lt;T&amp;gt; entityClass)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;mybatis&quot;&gt;&lt;span id=&quot;mybatis&quot;&gt;mybatis&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;maven 依赖&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;org.mybatis.spring.boot&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;mybatis-spring-boot-starter&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;1.3.2&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;常用配置如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 配置文件位置 classpath后面要加*，不然后面通配符不管用
mybatis.mapperLocations=classpath*:com/zhaoguhong/baymax/*/mapper/*Mapper.xml
# 开启驼峰命名自动映射
mybatis.configuration.map-underscore-to-camel-case=true&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;dao层直接用接口，简洁，方便&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Mapper
public interface DemoMapper {
  /**
   * 注解方式
   */
  @Select(&quot;SELECT * FROM demo WHERE user_name = #{userName}&quot;)
  List&amp;lt;Demo&amp;gt; findByUserName(@Param(&quot;userName&quot;) String userName);
  /**
   * xml方式
   */
  List&amp;lt;Demo&amp;gt; getDemos();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要注意，xml的namespace必须是mapper类的全限定名，这样才可以建立dao接口与xml的关系&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;mapper namespace=&quot;com.zhaoguhong.baymax.demo.dao.DemoMapper&quot;&amp;gt;
  &amp;lt;select id=&quot;getDemos&quot; resultType=&quot;com.zhaoguhong.baymax.demo.entity.Demo&quot;&amp;gt;
        select * from demo
    &amp;lt;/select&amp;gt;
&amp;lt;/mapper&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;通用mapper&quot;&gt;通用mapper&lt;/h3&gt;
&lt;p&gt;mybatis 的单表增删改查写起来很啰嗦，&lt;a href=&quot;https://github.com/abel533/Mapper&quot;&gt;通用mapper&lt;/a&gt;很好的解决了这个问题&lt;/p&gt;
&lt;p&gt;maven 依赖&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;tk.mybatis&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;mapper-spring-boot-starter&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;1.2.4&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;常用配置如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 通用mapper 多个接口时用逗号隔开
mapper.mappers=com.zhaoguhong.baymax.mybatis.MyMapper
mapper.not-empty=false
mapper.identity=MYSQL&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;定义自己的 &lt;code&gt;MyMapper&lt;/code&gt; 方便扩展，&lt;code&gt;MyMapper&lt;/code&gt; 接口 中封装了通用的方法，和&lt;code&gt;jpa&lt;/code&gt;的&lt;code&gt;BaseRepository&lt;/code&gt;类似，这里不再赘述&lt;/p&gt;
&lt;p&gt;声明&lt;code&gt;mapper&lt;/code&gt;需要加&lt;code&gt;Mapper&lt;/code&gt;注解，还稍显麻烦，可以用扫描的方式&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Configuration
@tk.mybatis.spring.annotation.MapperScan(basePackages = &quot;com.zhaoguhong.baymax.**.dao&quot;)
public class MybatisConfig {
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用时直接继承MyMapper接口即可&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface DemoMapper extends MyMapper&amp;lt;Demo&amp;gt;{
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;分页&quot;&gt;分页&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/pagehelper&quot;&gt;pagehelper&lt;/a&gt;是一个很好用的mybatis的分页插件&lt;/p&gt;
&lt;p&gt;maven 依赖&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;com.github.pagehelper&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;pagehelper-spring-boot-starter&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;1.2.3&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;常用配置如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#pagehelper
#指定数据库类型
pagehelper.helperDialect=mysql
#分页合理化参数
pagehelper.reasonable=true&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用分页&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    PageHelper.startPage(1, 5);
    List&amp;lt;Demo&amp;gt; demos = demoMapper.selectAll();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;pagehelper 还有好多玩法，可以参考&lt;a href=&quot;https://github.com/pagehelper/Mybatis-PageHelper/blob/master/wikis/zh/HowToUse.md&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;自定义分页&quot;&gt;自定义分页&lt;/h3&gt;
&lt;p&gt;pagehelper 虽然好用，但项目中有自己的分页对象，所以单独写一个拦截器，把他们整合到一起&lt;br/&gt;这个地方要特别注意插件的顺序不要搞错&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Configuration
// 设置mapper扫描的包
@tk.mybatis.spring.annotation.MapperScan(basePackages = &quot;com.zhaoguhong.baymax.**.dao&quot;)
@Slf4j
public class MybatisConfig {

  @Autowired
  private List&amp;lt;SqlSessionFactory&amp;gt; sqlSessionFactoryList;

  /**
   * 添加自定义的分页插件，pageHelper 的分页插件PageInterceptor是用@PostConstruct添加的，自定义的应该在其后面添加
   * 真正执行时顺序是反过来，先执行MyPageInterceptor，再执行 PageInterceptor
   *
   * 所以要保证 PageHelperAutoConfiguration 先执行
   */
  @Autowired
  public void addPageInterceptor(PageHelperAutoConfiguration pageHelperAutoConfiguration) {
    MyPageInterceptor interceptor = new MyPageInterceptor();
    for (SqlSessionFactory sqlSessionFactory : sqlSessionFactoryList) {
      sqlSessionFactory.getConfiguration().addInterceptor(interceptor);
      log.info(&quot;注册自定义分页插件成功&quot;);
    }
  }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在使用时只需要传入自定义的分页对象即可&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    Page&amp;lt;Demo&amp;gt; page = new Page&amp;lt;&amp;gt;(1, 10);
    demos = demoMapper.getDemos(page);&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;spring-security&quot;&gt;&lt;span id=&quot;security&quot;&gt;spring security&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;安全模块是项目中必不可少的一环，常用的安全框架有&lt;code&gt;shiro&lt;/code&gt;和&lt;code&gt;spring security&lt;/code&gt;，shiro相对轻量级，使用非常灵活，&lt;code&gt;spring security&lt;/code&gt;相对功能更完善，而且可以和spring 无缝衔接。这里选取&lt;code&gt;spring security&lt;/code&gt;做为安全框架&lt;/p&gt;
&lt;p&gt;maven 依赖&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;spring-boot-starter-security&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;继承WebSecurityConfigurerAdapter类就可以进行配置了&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class WebSecurityConfig extends WebSecurityConfigurerAdapter {

  @Autowired
  private SecurityProperties securityProperties;

  @Autowired
  private UserDetailsService userDetailsService;

  @Override
  protected void configure(HttpSecurity http) throws Exception {

    http
        .authorizeRequests()
        // 设置可以匿名访问的url
        .antMatchers(securityProperties.getAnonymousArray()).permitAll()
        // 其它所有请求都要认证
        .anyRequest().authenticated()
        .and()
        .formLogin()
        // 自定义登录页
        .loginPage(securityProperties.getLoginPage())
        // 自定义登录请求路径
        .loginProcessingUrl(securityProperties.getLoginProcessingUrl())
        .permitAll()
        .and()
        .logout()
        .permitAll();

    // 禁用CSRF
    http.csrf().disable();
  }


  @Override
  public void configure(WebSecurity web) throws Exception {
    String[] ignoringArray = securityProperties.getIgnoringArray();
    // 忽略的资源，直接跳过spring security权限校验
    if (ArrayUtils.isNotEmpty(ignoringArray)) {
      web.ignoring().antMatchers(ignoringArray);
    }
  }

  /**
   *
   * 声明密码加密方式
   */
  @Bean
  public PasswordEncoder passwordEncoder() {
    return new BCryptPasswordEncoder();
  }

  @Override
  protected void configure(AuthenticationManagerBuilder auth)
      throws Exception {
    auth.userDetailsService(userDetailsService)
        // 配置密码加密方式，也可以不指定，默认就是BCryptPasswordEncoder
        .passwordEncoder(passwordEncoder());
  }


}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实现&lt;code&gt;UserDetailsService&lt;/code&gt;接口，定义自己的&lt;code&gt;UserDetailsService&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Service
public class UserDetailsServiceImpl implements UserDetailsService {

  @Autowired
  private UserRepository userRepository;

  @Override
  @Transactional
  public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
    User user = userRepository.findByUsernameAndIsDeleted(username, SystemConstants.UN_DELETED);

    if (user == null) {
      throw new UsernameNotFoundException(&quot;username Not Found&quot;);
    }
    return user;
  }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置项&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#匿名访问的url,多个用逗号分隔
security.anonymous=/test
#忽略的资源,直接跳过spring security权限校验,一般是用做静态资源，多个用逗号分隔
security.ignoring=/static/**,/images/**
#自定义登录页面
security.loginPage=/login.html
#自定义登录请求路径
security.loginProcessingUrl=/login&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;项目上下文&quot;&gt;&lt;span id=&quot;ContextHolder&quot;&gt;项目上下文&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;为了方面使用，封装一个上下文对象 &lt;code&gt;ContextHolder&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 获取当前线程HttpServletRequest
getRequest()
// 获取当前线程HttpServletResponse
getResponse()
// 获取当前HttpSession
getHttpSession()
setSessionAttribute(String key, Serializable entity)
getSessionAttribute(String key)
setRequestAttribute(String key, Object entity)
getRequestAttribute(String key)
// 获取 ApplicationContext
getApplicationContext()
//根据beanId获取spring bean
getBean(String beanId)
// 获取当前登录用户
getLoginUser()
// 获取当前登录用户 id
getLoginUserId()
// 获取当前登录用户 为空则抛出异常
getRequiredLoginUser()
// 获取当前登录用户id， 为空则抛出异常
getRequiredLoginUserId()&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;单点登录&quot;&gt;&lt;span id=&quot;sso&quot;&gt;单点登录&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;单点登录系统（SSO，single sign-on）指的的，多个系统，共用一套用户体系，只要登录其中一个系统，访问其他系统不需要重新登录&lt;/p&gt;
&lt;h3 id=&quot;cas&quot;&gt;CAS&lt;/h3&gt;
&lt;p&gt;CAS(Central Authentication Service)是耶鲁大学的一个开源项目，是比较流行的单独登录解决方案。在CAS中，只负责登录的系统被称为服务端，其它所有系统被称为客户端&lt;/p&gt;
&lt;h4 id=&quot;登录流程&quot;&gt;登录流程&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;用户访问客户端，客户端判断是否登录，如果没有登录，重定向到服务端去登录&lt;/li&gt;
&lt;li&gt;服务端登录成功，带着ticket重定向到客户端&lt;/li&gt;
&lt;li&gt;客户端拿着ticket发送请求到服务端换取用户信息，获取到后就表示登录成功&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;登出流程&quot;&gt;登出流程&lt;/h4&gt;
&lt;p&gt;跳转到sso认证中心进行统一登出，cas 会通知所有客户端进行登出&lt;/p&gt;
&lt;h3 id=&quot;spring-security-整合-cas&quot;&gt;spring security 整合 cas&lt;/h3&gt;
&lt;p&gt;maven 依赖&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;org.springframework.security&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;spring-security-cas&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;spring security 对 cas 做了很好的封装,在使用的过程中，只需要定义好对应的登录fifter和登出fifter即可，整合cas的代码我写在了&lt;code&gt;WebSecurityConfig&lt;/code&gt;类中&lt;/p&gt;
&lt;p&gt;相关属性配置&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#是否开启单点登录
cas.enable = true
#服务端地址
cas.serverUrl=
#客户端地址
cas.clientUrl=
#登录地址
cas.loginUrl=${cas.serverUrl}/login
#服务端登出地址
cas.serverLogoutUrl=${cas.serverUrl}/logout
#单点登录成功回调地址
cas.clientCasUrl=${cas.clientUrl}/login/cas&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;邮件&quot;&gt;&lt;span id=&quot;mail&quot;&gt;邮件&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;因为要使用freeMarker解析模板，所以也要引入freeMarker依赖&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;spring-boot-starter-mail&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;org.freemarker&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;freemarker&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;相关配置&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#邮件
#设置邮箱主机,163邮箱为smtp.163.com，qq为smtp.qq.com
spring.mail.host = smtp.163.com
spring.mail.username =
#授权码
spring.mail.password =
#默认的邮件发送人
mail.sender =&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;封装一个 &lt;code&gt;MailService&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;   // 根据相关配置发送邮件
  void sendMail(MailModel mailModel);
   // 发送简单的邮件
  void sendSimleMail(String to, String subject, String content);
   // 发送html格式的邮件
  void sendHtmlMail(String to, String subject, String content);
   // 发送带附件的邮件
  void sendAttachmentMail(String to, String subject, String content, String path);
   // 发送带附件的html格式邮件
  void sendAttachmentHtmlMail(String to, String subject, String content, String path);
   // 根据模版发送简单邮件
  void sendMailByTemplate(String to, String subject, String templateName,
      Map&amp;lt;String, Object&amp;gt; params);
  
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;maven&quot;&gt;&lt;span id=&quot;mail&quot;&gt;maven&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;镜像&quot;&gt;镜像&lt;/h3&gt;
&lt;p&gt;设置阿里云镜像，加快下载速度&lt;br/&gt;修改 setting.xml，在 mirrors 节点上，添加&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;mirror&amp;gt; 
    &amp;lt;id&amp;gt;alimaven&amp;lt;/id&amp;gt; 
    &amp;lt;name&amp;gt;aliyun maven&amp;lt;/name&amp;gt; 
    &amp;lt;url&amp;gt;http://maven.aliyun.com/nexus/content/groups/public/&amp;lt;/url&amp;gt; 
    &amp;lt;mirrorOf&amp;gt;central&amp;lt;/mirrorOf&amp;gt; 
&amp;lt;/mirror&amp;gt; &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也可以在项目 pom.xml 文件添加 ，仅当前项目有效&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;  &amp;lt;repositories&amp;gt;
    &amp;lt;repository&amp;gt;
      &amp;lt;id&amp;gt;alimaven&amp;lt;/id&amp;gt;
      &amp;lt;name&amp;gt;aliyun maven&amp;lt;/name&amp;gt;
      &amp;lt;url&amp;gt;http://maven.aliyun.com/nexus/content/groups/public/&amp;lt;/url&amp;gt;
      &amp;lt;releases&amp;gt;
        &amp;lt;enabled&amp;gt;true&amp;lt;/enabled&amp;gt;
        &amp;lt;updatePolicy&amp;gt;daily&amp;lt;/updatePolicy&amp;gt;
      &amp;lt;/releases&amp;gt;
      &amp;lt;snapshots&amp;gt;
        &amp;lt;enabled&amp;gt;false&amp;lt;/enabled&amp;gt;
        &amp;lt;checksumPolicy&amp;gt;warn&amp;lt;/checksumPolicy&amp;gt;
      &amp;lt;/snapshots&amp;gt;
      &amp;lt;layout&amp;gt;default&amp;lt;/layout&amp;gt;
    &amp;lt;/repository&amp;gt;
  &amp;lt;/repositories&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;总结&quot;&gt;&lt;span id=&quot;总结&quot;&gt;总结&lt;/span&gt;&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;spring boot 遵循开箱即用的原则，并不需要做过多配置，网上的教程质量参差不齐，并且1.X和2.X使用时还有诸多不同，因此在使用时尽量参考&lt;a href=&quot;https://spring.io/projects/spring-boot#learn&quot;&gt;官方文档&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;有时候默认的配置并不能满足我们的需求，需要做一些自定义配置，推荐先看一下&lt;code&gt;springboot&lt;/code&gt;自动配置的源码，再做定制化处理&lt;/li&gt;
&lt;li&gt;技术没有银弹，在做技术选型时不要过于迷信一种技术，适合自己的业务的技术才是最好的&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Sun, 08 Dec 2019 14:54:00 +0000</pubDate>
<dc:creator>赵孤鸿</dc:creator>
<og:description>`springboot javaweb springboot starter` 那么简单。 要做到简单，易用，扩展性更好，还需做不少二次封装，于是便写了个基于 的web项目脚手架，对一些常用的框架进行</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhaoguhong/p/12008499.html</dc:identifier>
</item>
</channel>
</rss>