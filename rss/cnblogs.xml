<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>「补课」进行时：设计模式(2)——通过一个超级汽车工厂来了解工厂模式 - 极客挖掘机</title>
<link>http://www.cnblogs.com/babycomeon/p/13856006.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/babycomeon/p/13856006.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://cdn.geekdigging.com/DesignPatterns/java_design_pattern.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-超级汽车工厂&quot;&gt;1. 超级汽车工厂&lt;/h2&gt;
&lt;p&gt;汽车相信大家都不陌生，我们现在最常用的交通工具得益于在奔驰在 1885 年研制的第一辆「三轮车」，就是下面这个家伙：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.geekdigging.com/DesignPatterns/02/benz_sanlunche.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;今天我来试一下使用程序通过汽车工厂来造汽车。&lt;/p&gt;
&lt;h3 id=&quot;11-定义一辆汽车&quot;&gt;1.1 定义一辆汽车&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface Car {
    void name();
    void drive();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;身为一辆汽车，首先要有自己的名字，其次是要能开，有了这两个东西，基本上就能叫一辆汽车了。&lt;/p&gt;
&lt;h3 id=&quot;12-定义一辆特斯拉、一辆奔驰、一辆奥迪&quot;&gt;1.2 定义一辆特斯拉、一辆奔驰、一辆奥迪&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Tesla implements Car {
    @Override
    public void name() {
        System.out.println(&quot;我是特斯拉！！！&quot;);
    }

    @Override
    public void drive() {
        System.out.println(&quot;我是特斯拉，速度贼快！！！&quot;);
    }
}

public class Benz implements Car {
    @Override
    public void name() {
        System.out.println(&quot;我是奔驰！！！&quot;);
    }

    @Override
    public void drive() {
        System.out.println(&quot;我是奔驰，内饰豪华！！！&quot;);
    }
}

public class Audi implements Car {
    @Override
    public void name() {
        System.out.println(&quot;我是奥迪！！！&quot;);
    }

    @Override
    public void drive() {
        System.out.println(&quot;我是奥迪，科技感十足！！！&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里定义了三辆汽车，分别实现了他们的父亲的两个方法。&lt;/p&gt;
&lt;h3 id=&quot;13-定义抽象汽车工厂&quot;&gt;1.3 定义抽象汽车工厂&lt;/h3&gt;
&lt;p&gt;身为一个超级汽车工厂，当然是要能造汽车，我们创建汽车的时候，肯定是希望直接告诉工厂，我要造一辆特斯拉还是造一辆奥迪。&lt;/p&gt;
&lt;p&gt;如果是使用特斯拉或者是奥迪作为输入参数，那么创建的方法我们就需要分别写 3 个了，在 Java 中，这里可以使用泛型来作为输入参数，控制参数的输入类型。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public abstract class AbstractCarFactory {
    public abstract  &amp;lt;T extends Car&amp;gt; T createCar(Class&amp;lt;T&amp;gt; clazz);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里使用泛型首先定义了泛型 T 是 Car 的子类，限制了 T 的类型，其次是输入参数必须是 Class 类型。&lt;/p&gt;
&lt;h3 id=&quot;14-汽车创建工厂&quot;&gt;1.4 汽车创建工厂&lt;/h3&gt;
&lt;p&gt;接下来，我们定义一个实际的汽车创建工厂：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class CarFactory extends AbstractCarFactory {
    @Override
    public &amp;lt;T extends Car&amp;gt; T createCar(Class&amp;lt;T&amp;gt; clazz) {
        Car car = null;
        try {
            car = (T)Class.forName(clazz.getName()).newInstance();
        } catch (Exception e) {
            System.out.println(&quot;汽车生产出错啦，请回炉重造！&quot;);
        }
        return (T) car;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;15-开始生产汽车&quot;&gt;1.5 开始生产汽车&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Test {
    public static void main(String[] args) {
        AbstractCarFactory carFactory = new CarFactory();
        System.out.println(&quot;-- 第一辆车生产特斯拉 --&quot;);
        Car tesla = carFactory.createCar(Tesla.class);
        tesla.name();
        tesla.drive();

        System.out.println(&quot;-- 第二辆车生产奔驰 --&quot;);
        Car benz = carFactory.createCar(Benz.class);
        benz.name();
        benz.drive();

        System.out.println(&quot;-- 第三辆车生产奥迪 --&quot;);
        Car audi = carFactory.createCar(Audi.class);
        audi.name();
        audi.drive();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;生产的结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;-- 第一辆车生产特斯拉 --
我是特斯拉！！！
我是特斯拉，速度贼快！！！
-- 第二辆车生产奔驰 --
我是奔驰！！！
我是奔驰，内饰豪华！！！
-- 第三辆车生产奥迪 --
我是奥迪！！！
我是奥迪，科技感十足！！！
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;2-工厂模式&quot;&gt;2. 工厂模式&lt;/h2&gt;
&lt;p&gt;首先是工厂模式的定义：&lt;/p&gt;
&lt;p&gt;Define an interface for creating an object,but let subclasses decide whichclass to instantiate.Factory Method lets a class defer instantiation tosubclasses.（定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。）&lt;/p&gt;
&lt;p&gt;下面是一个通用类图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.geekdigging.com/DesignPatterns/02/Factory_UML.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Product: 用于定义产品特性，实现对事物最抽象的定义，就像上面定义的 Car 。&lt;/li&gt;
&lt;li&gt;ConcreteProduct: 具体对产品定义的实现，就上上面定义的特斯拉和奥迪。&lt;/li&gt;
&lt;li&gt;Creator: 抽象工厂，用于最抽象对 Product 的构造的定义。&lt;/li&gt;
&lt;li&gt;ConcreteCreator: Creator 的具体实现，具体实现如何创建产品类。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;21-抽象产品类&quot;&gt;2.1 抽象产品类&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public abstract class Product {
    public void method1() {

    }
    public abstract void method2();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;22-具体产品类&quot;&gt;2.2 具体产品类&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class ConcreteProduct1 extends Product {
    @Override
    public void method2() {

    }
}

public class ConcreteProduct2 extends Product {
    @Override
    public void method2() {

    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体的产品类可以有多个，都继承于抽象的产品类。&lt;/p&gt;
&lt;h3 id=&quot;23-抽象工厂类&quot;&gt;2.3 抽象工厂类&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public abstract class Creator {
    public abstract &amp;lt;T extends Product&amp;gt; T createProduct(Class&amp;lt;T&amp;gt; clazz);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;24-具体工厂类&quot;&gt;2.4 具体工厂类&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class ConcreteCreator extends Creator {
    @Override
    public &amp;lt;T extends Product&amp;gt; T createProduct(Class&amp;lt;T&amp;gt; clazz) {
        Product product = null;
        try {
            product = (Product) Class.forName(clazz.getName()).newInstance();
        } catch (Exception e) {
            // 异常处理
        }
        return (T) product;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体如何产生一个产品的对象的实现，是由具体的工厂类进行实现的，具体的工厂类可以有多个，用于实现多条产品线的生产。&lt;/p&gt;
&lt;h3 id=&quot;25-优点&quot;&gt;2.5 优点&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;良好的封装性，代码结构清晰。&lt;/li&gt;
&lt;li&gt;良好的扩展性。如果我们需要增加产品类，只需要修改具体的工厂类或者扩展一个新的具体工厂类即可。&lt;/li&gt;
&lt;li&gt;屏蔽产品类。工厂模式是点型的解耦框架，高层次的模块只需要知道产品的抽象类，其他的实现类都不需要关心。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;3-工厂模式扩展多个工厂类&quot;&gt;3. 工厂模式扩展——多个工厂类&lt;/h2&gt;
&lt;p&gt;前面说工厂模式可以有多个具体工厂，如果项目复杂度足够高，将所有的产品都放在一个工厂类中做初始化有点不够清晰，那么我们可以实现多个工厂类，由每一个工厂类对应不同的业务规则做对应的产品类的初始化操作。&lt;/p&gt;
&lt;p&gt;我如果把上面的那个超级汽车工厂改成多工厂类，先画一个类图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.geekdigging.com/DesignPatterns/02/More_Factory_UML.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个代码我就不写了，和上面的差不多，就是从原来的一个工厂生产三种车变成了三个专属工厂生产三种车。&lt;/p&gt;
</description>
<pubDate>Thu, 22 Oct 2020 00:46:00 +0000</pubDate>
<dc:creator>极客挖掘机</dc:creator>
<og:description>1. 超级汽车工厂 汽车相信大家都不陌生，我们现在最常用的交通工具得益于在奔驰在 1885 年研制的第一辆「三轮车」，就是下面这个家伙： 今天我来试一下使用程序通过汽车工厂来造汽车。 1.1 定义一辆</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/babycomeon/p/13856006.html</dc:identifier>
</item>
<item>
<title>我是一个秒杀请求，正在逃离这颗星球... - 悟空聊架构</title>
<link>http://www.cnblogs.com/jackson0714/p/SecKill.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jackson0714/p/SecKill.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/f30c9973df53c1b70f2581ac4939dfdf.png&quot; alt=&quot;A-731电商星球&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;星球简介&quot;&gt;星球简介&lt;/h2&gt;
&lt;p&gt;地点：β-410 星系，&lt;code&gt;A-731电商星球&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;时间：新纪元 2036 年。&lt;/p&gt;
&lt;p&gt;星球简介：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;中文名：A-731电商星球&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;外文名：A-731 Mall&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分类：行星&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;公转周期：一年&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;常驻用户：中间件工作者、各种请求。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;星球总历史：二十万年。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;星球危机&quot;&gt;星球危机&lt;/h2&gt;
&lt;p&gt;我是一个秒杀请求，每天的工作就是将秒杀请求的数据运送给后端工作者。&lt;/p&gt;
&lt;p&gt;这天我在 Nginx 转发服务器上遇见了请求&lt;strong&gt;小空&lt;/strong&gt; ，我跟小空说有重要消息不方便在现在告诉他，下班再约，然后就都匆匆赶路了，因为我俩都要快速将请求数据运送到订单星球去。&lt;/p&gt;
&lt;p&gt;我和小空晚上十点下班后来到一家酒吧，点了两杯 &lt;code&gt;mojito&lt;/code&gt;，找了一个角落坐下。&lt;/p&gt;
&lt;p&gt;小空：你最近看起来心事重重。&lt;/p&gt;
&lt;p&gt;我：你有没有发现最近我们星球的订单数急剧增加，每天有一千万订单数据产生，也不是一天、两天的事了。&lt;/p&gt;
&lt;p&gt;小空：难怪我每天加班到晚上十点来运送请求数据。&lt;/p&gt;
&lt;p&gt;我：我有个舅舅在航天局上班，告诉我说我们星球承载不了那么多请求和订单数据，不久就会出现&lt;strong&gt;行星大爆炸&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;小空：那怎么办？&lt;/p&gt;
&lt;p&gt;我：我们可以去 100 光年外的 T-714 星球，但是只能通过&lt;code&gt;秒杀通道&lt;/code&gt;坐&lt;code&gt;时空穿梭机&lt;/code&gt;去那颗星球。而且名额有限制，不知道我有没有机会登上穿梭机。&lt;/p&gt;
&lt;p&gt;我：明天通道会开启两次，上午十点和下午两点。你明天和我一起去吧！&lt;/p&gt;
&lt;p&gt;小空：好的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/64a064e1a819fa6bf3c83af8dcf835a5.png&quot; alt=&quot;星球大爆炸&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;涉及的知识点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;这里的行星大爆炸指的是什么？
&lt;ul&gt;&lt;li&gt;因订单数据量很大，数据库撑不住了。数据库可能宕机。&lt;/li&gt;
&lt;li&gt;因每天有大量请求发送到服务器，服务器也扛不住了。服务器可能宕机。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;秒杀通道每天开启两次代表了什么？
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;流量错峰&lt;/strong&gt; ，将流量分摊到两个秒杀场次。&lt;/li&gt;
&lt;li&gt;当然&lt;strong&gt;流量错峰&lt;/strong&gt; 的手段还有输入验证、加入购物车等分摊流量的操作。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;秒杀通道&quot;&gt;秒杀通道&lt;/h2&gt;
&lt;p&gt;地点：A-731 星球机场&lt;/p&gt;
&lt;p&gt;时间：09 : 45&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/431c023c47dd4f2163735fcf9c884653.png&quot; alt=&quot;通道&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;“请前往 T-714 星球的请求旅客到 Y1 站台排队等待进入特殊通道， 15 分钟后开始进入穿梭机大厅”。大厅的广播连续播放了三遍。&lt;/p&gt;
&lt;p&gt;我走向了特殊通道，看到通道旁立着一个牌子：秒杀通道，只给秒杀请求使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;涉及知识点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;秒杀场景为什么单独弄了条通道？
&lt;ul&gt;&lt;li&gt;秒杀业务为了不影响系统的其他业务单独部署了一套秒杀系统。&lt;/li&gt;
&lt;li&gt;总结为&lt;strong&gt;服务单一职责 + 独立部署&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;实时大屏&quot;&gt;实时大屏&lt;/h2&gt;
&lt;p&gt;一抬头看到通道上方有一个大屏，在不断播放 T-714 星球的照片，以及机票的订单信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/c2a7633821748bed8f60abfdc1d59ef0.png&quot; alt=&quot;mark&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有两个穿制服的工作者正在大屏旁巡逻。一个制服上印着 Nginx，一个制服上印着 CDN。&lt;/p&gt;
&lt;p&gt;[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-6P1fVR1b-1603325598167)(&lt;a href=&quot;http://cdn.jayh.club/blog/20201021/162136369.png&quot;&gt;http://cdn.jayh.club/blog/20201021/162136369.png&lt;/a&gt;)]&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;涉及知识点：&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;验证通道&quot;&gt;验证通道&lt;/h2&gt;
&lt;p&gt;时间：10:00&lt;/p&gt;
&lt;p&gt;“验证通道已开启，请携带密码进入！” 又是播放了三遍广播。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/fb8d60e0007c61fea700b13793dd7032.png&quot; alt=&quot;输入密码&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;涉及的知识点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;为什么需要密码？
&lt;ul&gt;&lt;li&gt;为了防止大量模拟的秒杀请求进入业务处理流程，所以先加一道验证，丢弃这些假请求。&lt;/li&gt;
&lt;li&gt;怎么做到的？前端网页先发送请求拿到密码，点击抢购时，请求体中携带加密密码，后端校验密码是否匹配。可以通过 MD5 加密。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;总结为&lt;strong&gt;秒杀请求加密&lt;/strong&gt; 。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;穿梭机大厅&quot;&gt;穿梭机大厅&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/96e6603f917ab85cc63745c94ded81fd.png&quot; alt=&quot;穿梭机大厅&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;经过验证通道的筛选后，有一半的假请求被挡在门外，像我这种拿到了正确密码的顺利进入了穿梭机大厅。&lt;/p&gt;
&lt;p&gt;来到大厅，发现大厅的正中央摆放着一个显示器，上面显示的红色数字 100 赫然映入眼中。&lt;/p&gt;
&lt;p&gt;显示屏的左手边站着一位穿着 Redis 统一制服的靓女。在一旁的我偷听到原来她是控制显示器显示穿梭机剩余数量的。如果数字变为 0 ，则表示穿梭机已经全部被占用，后来的人就得无功而返了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/4400934315ee6e7b3b4a29e9f40abaad.png&quot; alt=&quot;Redis&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;涉及的知识点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;秒杀场景中，查询剩余库存并不是直接查数据库，而是查 Redis 缓存的。&lt;/li&gt;
&lt;li&gt;为什么是查缓存？因为查缓存的速度要远远快于查数据库，减少了响应时间，而且对数据库的压力减小了很多。如果很多查库存的请求都到数据库了，那数据库就要崩了，而且数据库干不了其他的活了。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;抢票&quot;&gt;抢票&lt;/h2&gt;
&lt;p&gt;显示屏的右手边站着一位西装笔挺的年轻帅哥，看到他的袖口上挂着一个红袖章，印着 Redisson 字样。他一脸严肃的模样，对大厅内黑压压一片的请求熟视无睹。可能是见惯了这种场景吧。&lt;/p&gt;
&lt;p&gt;正在打量这位帅哥时，发现他的左手拿着一叠机票，没错，有了一张机票就可以登入穿梭机了。我以百米冲速的速度到达了他面前，到达他面前时，已经有十几个请求也到了他身边，他按照先来后到的顺序依次发放机票，到我的时候，机票已经只剩几张了，庆幸的是我的百米冲速帮我抢到了一张机票。我问帅哥是否可以再发一张票给我，他拒绝了。&lt;/p&gt;
&lt;p&gt;每一次发放票，穿 Redis 制服的靓女都会操作显示屏，让其数量减一。&lt;/p&gt;
&lt;p&gt;十秒钟后，票已经发完，显示屏显示数字 0 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;涉及的知识点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Redisson 是啥呢？Redis 客户端，解决了分布式的一些常见问题。&lt;/li&gt;
&lt;li&gt;这里其实用到了 Redisson 的信号量功能，总共有 100 张票，也就是 100 个信号量，而且票的数量不会因为多线程并发或分布式系统的原因而导致票的数量被超卖。比如卖出了 101 张票。&lt;/li&gt;
&lt;li&gt;每个人只能获得一张票，这就是秒杀系统中涉及到的幂等性校验，不能重复抢票。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/e72d6ccacc579d5366965e3dcfdc559f.png&quot; alt=&quot;售票窗口&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;登机牌&quot;&gt;登机牌&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/9ef3ee8e6df354d23ac4ceec3df55a0e.png&quot; alt=&quot;登机牌&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;发放机票的帅哥告诉我，拿到票后，到 A 窗口排队付款，才能拿到登记牌。于是我和另外 99 个请求一起在 A 窗口排队了。&lt;/p&gt;
&lt;p&gt;看到一个请求想要放弃付款了，说是机票太贵了，然后准备离开大厅时，被发放机票的帅哥拦住了，他问请求是否要考虑下，有 15 分钟的考虑时间，如果请求还是觉得不行，可以将机票还给他，他可以再发放给其他人。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/e5299088edf811a881caed3a1ddadbd7.png&quot; alt=&quot;阻塞&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;涉及的知识点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;秒杀系统中常用的&lt;strong&gt;队列削峰&lt;/strong&gt; 。秒杀成功的请求，进入队列，慢慢创建订单、扣减库存。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;秒杀成功后，快速告诉用户已经秒杀成功，而不是等待订单完在告诉用户，那用户就要多等一会了，影响体验。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;为什么要做队列削峰？成功的请求不必一下子都去数据库创建订单，这样对数据库的压力也会小一些。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;在秒杀场景中，很有可能有用户抢到了但是不付款的场景，这个时候库存是要加回去的，可以提供给其他用户。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;启航&quot;&gt;启航&lt;/h2&gt;
&lt;p&gt;订单创建成功后，我顺利拿到了登机牌，通过了登机牌的校验后，成功登上了穿梭机。&lt;/p&gt;
&lt;p&gt;出发，去往 T-714 星球。听说那个星球的数据库进行了分库分表、服务也拆分成了微服务。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/93d66a0f6acdc4d6d05f4a94eca23d39.png&quot; alt=&quot;启航&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;上面通过科幻小说的方式来讲解了秒杀系统中关注的点，但并没有讲全，所以下面列出了秒杀系统关注的八大点：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/55783c92fcd02c612039891d13b6ab2e.png&quot; alt=&quot;秒杀场景关注点&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;服务单一职责、独立部署&lt;/li&gt;
&lt;li&gt;库存预热、快速扣减&lt;/li&gt;
&lt;li&gt;秒杀链接加密&lt;/li&gt;
&lt;li&gt;动静分离&lt;/li&gt;
&lt;li&gt;恶意请求拦截&lt;/li&gt;
&lt;li&gt;流量错峰&lt;/li&gt;
&lt;li&gt;限流&amp;amp;熔断&amp;amp;降级&lt;/li&gt;
&lt;li&gt;队列削峰&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;只讲原理好像不得劲，是不是要来篇实战！&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;你好，我是&lt;code&gt;悟空哥&lt;/code&gt;，&lt;strong&gt;「7年项目开发经验，全栈工程师，开发组长，超喜欢图解编程底层原理」&lt;/strong&gt;。&lt;br/&gt;我还&lt;code&gt;手写了 2 个小程序&lt;/code&gt;，&lt;code&gt;Java 刷题小程序&lt;/code&gt;，&lt;code&gt;PMP 刷题小程序&lt;/code&gt;，点击我的公众号菜单打开！&lt;br/&gt;另外有 111 本架构师资料以及 1000 道 Java 面试题，都整理成了PDF。&lt;br/&gt;可以关注公众号 &lt;strong&gt;「悟空聊架构」&lt;/strong&gt; 回复 &lt;code&gt;悟空&lt;/code&gt; 领取优质资料。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;「转发-&amp;gt;在看-&amp;gt;点赞-&amp;gt;收藏-&amp;gt;评论！！！」&lt;/strong&gt; 是对我最大的支持！&lt;/p&gt;
&lt;p&gt;我是悟空哥，努力变强，变身超级赛亚人！我们下期见！&lt;/p&gt;
</description>
<pubDate>Thu, 22 Oct 2020 00:10:00 +0000</pubDate>
<dc:creator>悟空聊架构</dc:creator>
<og:description>星球简介 地点：β-410 星系，A-731电商星球。 时间：新纪元 2036 年。 星球简介： 中文名：A-731电商星球 外文名：A-731 Mall 分类：行星 公转周期：一年 常驻用户：中间件</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jackson0714/p/SecKill.html</dc:identifier>
</item>
<item>
<title>CDH+Kylin三部曲之一：准备工作 - 程序员欣宸</title>
<link>http://www.cnblogs.com/bolingcavalry/p/13855839.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bolingcavalry/p/13855839.html</guid>
<description>&lt;h3 id=&quot;欢迎访问我的github&quot;&gt;欢迎访问我的GitHub&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;内容：所有原创文章分类汇总及配套源码，涉及Java、Docker、Kubernetes、DevOPS等；&lt;/p&gt;
&lt;h3 id=&quot;关于《cdhkylin三部曲》系列&quot;&gt;关于《CDH+Kylin三部曲》系列&lt;/h3&gt;
&lt;p&gt;本文是《CDH+Kylin三部曲》的第一篇，整个系列由以下三篇组成：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;准备工作：搭建CDH+Kylin环境前，将所有硬件、软件资源准备好&lt;/li&gt;
&lt;li&gt;部署和设置：部署CDH和Kylin，再做相关设置&lt;/li&gt;
&lt;li&gt;Kylin实战：在搭好的环境上运行Kylin官方demo&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;整个三部曲的实战内容如下图所示：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201022075900338-1823120945.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;接下来，就从最基本的准备工作开始吧。&lt;/p&gt;
&lt;h3 id=&quot;关于cdh与kylin&quot;&gt;关于CDH与Kylin&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;Kylin的运行需要Hadoop、Hive、HBase等服务，因此用CDH来集中部署这些应用更为方便，下图来自Kylin官方，可见是支持CDH的：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201022075900735-1217685835.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;2. 官方说支持CDH6.0版本，但实际部署中发现Kylin2.6在CDH6.0.1环境启动会有问题，经尝试发现Kylin2.6+CDH5.16可以正常运行，本次实战就用这样的版本搭配；&lt;/p&gt;
&lt;h3 id=&quot;部署方式&quot;&gt;部署方式&lt;/h3&gt;
&lt;p&gt;ansible是常用的运维工具，可大幅度简化整个部署过程，接下来会使用ansible来完成部署工作，如果您对ansible还不够了解，请参考&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/105342744&quot;&gt;《ansible2.4安装和体验》&lt;/a&gt;，部署操作如下图所示，在一台安装了ansible的电脑上运行脚本，由ansible远程连接到一台CentOS7.7的服务器上，完成部署工作：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201022075901022-842391335.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;硬件准备&quot;&gt;硬件准备&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;一部能运行ansible的电脑，我用的是MacBook Pro，也用CentOS验证过，都能顺利完成部署；&lt;/li&gt;
&lt;li&gt;一台CentOS7.7电脑，用于运行HDFS、Hive、HBase、Spark、Kylin等所有服务(后续文中的&lt;span&gt;CDH服务器&lt;/span&gt;就是指该电脑)，&lt;span&gt;用一台机器部署所有服务仅适用于学习和开发阶段&lt;/span&gt;，实测发现，此电脑&lt;span&gt;CPU至少要双核&lt;/span&gt;，内存不低于&lt;span&gt;16G&lt;/span&gt;，如果您想用多台电脑部署CDH，建议自行修改ansible脚本来分别部署，脚本地址后面会给出；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;cdh服务器设置&quot;&gt;CDH服务器设置&lt;/h3&gt;
&lt;p&gt;需要登录CDH服务器做以下设置：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;检查/etc/hostname文件是否正确，如下图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201022075901414-916736318.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;修改&lt;span&gt;/etc/hosts&lt;/span&gt;文件，将自己的IP地址和hostname配置上去，如下图红框所示（&lt;span&gt;事实证明这一步很重要&lt;/span&gt;，如果不做可能导致在部署时一直卡在&quot;分配&quot;阶段，看agent日志显示agent下载parcel的进度一直是百分之零）：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201022075901793-2008213031.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;下载文件ansible电脑&quot;&gt;下载文件(ansible电脑)&lt;/h3&gt;
&lt;p&gt;本次实战一共要准备13个文件，这里用表格列举如下：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;编号&lt;/th&gt;
&lt;th&gt;文件名&lt;/th&gt;
&lt;th&gt;简介&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;16&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;jdk-8u191-linux-x64.tar.gz&lt;/td&gt;
&lt;td&gt;Linux版的jdk安装包&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;mysql-connector-java-5.1.34.jar&lt;/td&gt;
&lt;td&gt;mysql的JDBC驱动&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;cloudera-manager-server-6.3.1-1466458.el7.x86_64.rpm&lt;/td&gt;
&lt;td&gt;cm的server安装包&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;cloudera-manager-daemons-6.3.1-1466458.el7.x86_64.rpm&lt;/td&gt;
&lt;td&gt;cm的daemon安装包&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;cloudera-manager-agent-6.3.1-1466458.el7.x86_64.rpm&lt;/td&gt;
&lt;td&gt;cm的agent安装包&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;CDH-5.16.2-1.cdh5.16.2.p0.8-el7.parcel&lt;/td&gt;
&lt;td&gt;CDH应用离线安装包&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;CDH-5.16.2-1.cdh5.16.2.p0.8-el7.parcel.sha&lt;/td&gt;
&lt;td&gt;CDH应用离线安装包sha验证码&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;apache-kylin-2.6.4-bin-cdh57.tar.gz&lt;/td&gt;
&lt;td&gt;kylin安装包(适配CDH版本)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;hosts&lt;/td&gt;
&lt;td&gt;ansible用到的远程主机配置，里面记录了CDH6服务器的信息&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;ansible.cfg&lt;/td&gt;
&lt;td&gt;ansible用到的配置信息&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;cm6-cdh5-kylin264-single-install.yml&lt;/td&gt;
&lt;td&gt;部署CDH时用到的ansible脚本&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;12&lt;/td&gt;
&lt;td&gt;cdh-single-start.yml&lt;/td&gt;
&lt;td&gt;初次启动CDH时用到的ansible脚本&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;13&lt;/td&gt;
&lt;td&gt;var.yml&lt;/td&gt;
&lt;td&gt;脚本中用到的变量都在在此设值，&lt;br/&gt;例如CDH包名、flink文件名等，便于维护&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;下面是每个文件的下载地址：&lt;/p&gt;
&lt;ol readability=&quot;7.1188340807175&quot;&gt;&lt;li readability=&quot;0.76229508196721&quot;&gt;
&lt;p&gt;jdk-8u191-linux-x64.tar.gz：Oracle官网可下，另外我将jdk-8u191-linux-x64.tar.gz和mysql-connector-java-5.1.34.jar一起打包上传到csdn，您可以一次性下载，地址：&lt;a href=&quot;https://download.csdn.net/download/boling_cavalry/12098987&quot;&gt;https://download.csdn.net/download/boling_cavalry/12098987&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0.77165354330709&quot;&gt;
&lt;p&gt;mysql-connector-java-5.1.34.jar：maven中央仓库可下，另外我将jdk-8u191-linux-x64.tar.gz和mysql-connector-java-5.1.34.jar一起打包上传到csdn，您可以一次性下载，地址：&lt;a href=&quot;https://download.csdn.net/download/boling_cavalry/12098987&quot;&gt;https://download.csdn.net/download/boling_cavalry/12098987&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;cloudera-manager-server-6.3.1-1466458.el7.x86_64.rpm：&lt;a href=&quot;https://archive.cloudera.com/cm6/6.3.1/redhat7/yum/RPMS/x86_64/cloudera-manager-server-6.3.1-1466458.el7.x86_64.rpm&quot;&gt;https://archive.cloudera.com/cm6/6.3.1/redhat7/yum/RPMS/x86_64/cloudera-manager-server-6.3.1-1466458.el7.x86_64.rpm&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;cloudera-manager-daemons-6.3.1-1466458.el7.x86_64.rpm：&lt;a href=&quot;https://archive.cloudera.com/cm6/6.3.1/redhat7/yum/RPMS/x86_64/cloudera-manager-daemons-6.3.1-1466458.el7.x86_64.rpm&quot;&gt;https://archive.cloudera.com/cm6/6.3.1/redhat7/yum/RPMS/x86_64/cloudera-manager-daemons-6.3.1-1466458.el7.x86_64.rpm&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;cloudera-manager-agent-6.3.1-1466458.el7.x86_64.rpm：&lt;a href=&quot;https://archive.cloudera.com/cm6/6.3.1/redhat7/yum/RPMS/x86_64/cloudera-manager-agent-6.3.1-1466458.el7.x86_64.rpm&quot;&gt;https://archive.cloudera.com/cm6/6.3.1/redhat7/yum/RPMS/x86_64/cloudera-manager-agent-6.3.1-1466458.el7.x86_64.rpm&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;CDH-5.16.2-1.cdh5.16.2.p0.8-el7.parcel：&lt;a href=&quot;https://archive.cloudera.com/cdh5/parcels/5.16.2/CDH-5.16.2-1.cdh5.16.2.p0.8-el7.parcel&quot;&gt;https://archive.cloudera.com/cdh5/parcels/5.16.2/CDH-5.16.2-1.cdh5.16.2.p0.8-el7.parcel&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;CDH-5.16.2-1.cdh5.16.2.p0.8-el7.parcel.sha：&lt;a href=&quot;https://archive.cloudera.com/cdh5/parcels/5.16.2/CDH-5.16.2-1.cdh5.16.2.p0.8-el7.parcel.sha1&quot;&gt;https://archive.cloudera.com/cdh5/parcels/5.16.2/CDH-5.16.2-1.cdh5.16.2.p0.8-el7.parcel.sha1&lt;/a&gt; （下载完毕后，将扩展名从.sha1为.sha）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;apache-kylin-2.6.4-bin-cdh57.tar.gz：&lt;a href=&quot;https://archive.apache.org/dist/kylin/apache-kylin-2.6.4/apache-kylin-2.6.4-bin-cdh57.tar.gz&quot;&gt;https://archive.apache.org/dist/kylin/apache-kylin-2.6.4/apache-kylin-2.6.4-bin-cdh57.tar.gz&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1.7757009345794&quot;&gt;
&lt;p&gt;hosts、ansible.cfg、cm6-cdh5-kylin264-single-install.yml、cdh-single-start.yml、vars.yml ：这五个文件都保存在我的GitHub仓库，地址是：&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt; ，这里面有多个文件夹，上述文件在名为&lt;span&gt;ansible-cm6-cdh5-kylin264-single&lt;/span&gt;的文件夹中，如下图红框所示：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201022075902295-792000562.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;文件摆放ansible电脑&quot;&gt;文件摆放(ansible电脑)&lt;/h3&gt;
&lt;p&gt;如果您已经下载好了上述13个文件，请按照如下位置摆放，这样才能顺利完成部署：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在家目录下新建名为playbooks的文件夹：mkdir ~/playbooks&lt;/li&gt;
&lt;li&gt;把这五个文件放入playbooks文件夹：hosts、ansible.cfg、cm6-cdh5-kylin264-single-install.yml、cdh-single-start.yml、vars.yml&lt;/li&gt;
&lt;li&gt;在playbooks文件夹里新建名为cdh6的子文件夹；&lt;/li&gt;
&lt;li&gt;把这八个文件放入cdh6文件夹(即剩余的八个)：jdk-8u191-linux-x64.tar.gz、mysql-connector-java-5.1.34.jar、cloudera-manager-server-6.3.1-1466458.el7.x86_64.rpm、cloudera-manager-daemons-6.3.1-1466458.el7.x86_64.rpm、cloudera-manager-agent-6.3.1-1466458.el7.x86_64.rpm、CDH-5.16.2-1.cdh5.16.2.p0.8-el7.parcel、CDH-5.16.2-1.cdh5.16.2.p0.8-el7.parcel.sha、apache-kylin-2.6.4-bin-cdh57.tar.gz&lt;/li&gt;
&lt;li&gt;摆放完毕后目录和文件情况如下图，再次提醒：&lt;span&gt;文件夹playbooks一定要放在家目录下&lt;/span&gt;（即：&lt;span&gt;~/&lt;/span&gt;）：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201022075902884-283424501.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;ansible参数设置ansible电脑&quot;&gt;ansible参数设置(ansible电脑)&lt;/h3&gt;
&lt;p&gt;ansible参数设置的操作设置很简单：配置好CDH服务器的访问参数即可，包括IP地址、登录账号、密码等，修改&lt;span&gt;~/playbooks/hosts&lt;/span&gt;文件，内容如下所示，您需要根据自身情况修改deskmini、ansible_host、ansible_port、ansible_user、ansible_password：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;[cdh_group]deskmini ansible_host=192.168.50.134 ansible_port=22 ansible_user=root ansible_password=888888
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至此，所有准备工作已完成，下一篇文章我们将完成这些操作：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;部署CDH和Kylin&lt;/li&gt;
&lt;li&gt;启动CDH&lt;/li&gt;
&lt;li&gt;设置CDH、在线安装Yarn、HDFS等&lt;/li&gt;
&lt;li&gt;调整HDFS、Yarn参数&lt;/li&gt;
&lt;li&gt;修改Spark设置(否则Kylin启动会失败)&lt;/li&gt;
&lt;li&gt;启动Kylin&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;欢迎关注公众号：程序员欣宸&quot;&gt;欢迎关注公众号：程序员欣宸&lt;/h3&gt;
&lt;blockquote readability=&quot;4.258064516129&quot;&gt;
&lt;p&gt;微信搜索「程序员欣宸」，我是欣宸，期待与您一同畅游Java世界...&lt;br/&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 21 Oct 2020 23:59:00 +0000</pubDate>
<dc:creator>程序员欣宸</dc:creator>
<og:description>欢迎访问我的GitHub https://github.com/zq2599/blog_demos 内容：所有原创文章分类汇总及配套源码，涉及Java、Docker、Kubernetes、DevOPS</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bolingcavalry/p/13855839.html</dc:identifier>
</item>
<item>
<title>Java9系列第8篇-Module模块化编程 - 字母哥博客</title>
<link>http://www.cnblogs.com/zimug/p/13855837.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zimug/p/13855837.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202010/1815316-20201022075530265-420200530.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我计划在后续的一段时间内，写一系列关于java 9的文章，虽然java 9 不像Java 8或者Java 11那样的核心java版本，但是还是有很多的特性值得关注。期待您能关注我，我将把java 9 写成一系列的文章，大概十篇左右，本文是第8篇。&lt;/p&gt;
&lt;p&gt;在Java 9版本中Java 语言引入了一个非常重要的概念：模块(module)。如果对javascript代码模块化管理比较熟悉的小伙伴，看到Java 9的模块化管理，应该有似曾相识的感觉。&lt;/p&gt;
&lt;h2 id=&quot;一、什么是java-module？&quot;&gt;一、什么是Java module？&lt;/h2&gt;
&lt;p&gt;与Java 中的package有些类似，module引入了Java代码分组的另一个级别。每个这样的分组（module）都包含许多子package包。通过在一个模块的源代码文件package的根部，添加文件module-info.java来声明该文件夹及其子文件夹为一个模块。该文件语法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; module xxx.yyy{
  ....
 }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中xxx.yyy是模块module声明的名称，不是package名称。&lt;/p&gt;
&lt;h2 id=&quot;二、模块导出package&quot;&gt;二、模块导出package&lt;/h2&gt;
&lt;p&gt;文件module-info.java可以指定该模块下面的哪些package对外可见、可访问。通过一个新的关键字&lt;code&gt;exports&lt;/code&gt;来实现该功能。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; module xxx.yyy{
  exports com.zimug.java9;
 }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;com.zimug.java9&lt;/code&gt;代表一个package。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;需要注意的是：即使给定package包中的类是public的，如果未通过'exports'显式导出其程序包，则它们在模块外部也是不可见的（在编译时和运行时都是如此）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;三、模块导入package&quot;&gt;三、模块导入package&lt;/h2&gt;
&lt;p&gt;如果另一个模块想要使用被导出的package包中的类，可以用&lt;code&gt;requires&lt;/code&gt;关键字在其module-info.java文件中来导入（读取）目标模块的package包。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;module def.stu{
 requires xxx.yyy;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;四、java-module的意义&quot;&gt;四、Java module的意义&lt;/h2&gt;
&lt;p&gt;在笔者看来，Java 9引入module 模块化管理系统，更多的是从安全性的角度考虑。Java 代码中90%以上的漏洞都是由反射和访问权限控制粒度不足引起的，Java 9的模块化系统正好能解决这个问题。Java 9 module提供另一个级别的Java 代码可见性、可访问性的控制。&lt;/p&gt;
&lt;p&gt;比如说：我们都知道当一个class被修饰为private的时候，意味着这个类是内部类。对于顶级类(外部类)来说，只有两种修饰符：public和默认(default)。这也就意味着一个问题，有些public class我们本来是打算在jar包定义的范围内使用的，但是结果却是任何引入了这个jar的项目都可以使用这个jar里面所有的public class代码。&lt;/p&gt;
&lt;p&gt;也就是我们的原意是在有限范围内提供公开访问，结果却是无限制的对外公开。在引入Java 9模块化之后，可以实现&lt;strong&gt;有限范围内的代码public访问权限&lt;/strong&gt;，将代码公开区分为：&lt;strong&gt;模块外部有限范围的公开访问&lt;/strong&gt;和&lt;strong&gt;模块内部的公开访问&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;五、实例&quot;&gt;五、实例&lt;/h2&gt;
&lt;p&gt;在此示例中，我将创建两个模块“ common.widget”和“ data.widget”，并将它们放置在单个文件夹“ modules-examples/src”下。文件“ module-info.java”将放置在每个模块的根文件夹下。&lt;br/&gt;文件及目录格式如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;D:\modules-example&amp;gt;tree /F /A
\---src
    +---common.widget
    |   |   module-info.java
    |   |   
    |   +---com
    |   |   \---zimug
    |   |           RendererSupport.java
    |   |           
    |   \---org
    |       \---jwidgets
    |               SimpleRenderer.java
    |               
    \---data.widget
        |   module-info.java
        |   
        \---com
            \---example
                    Component.java
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;第一个模块&quot;&gt;第一个模块&lt;/h3&gt;
&lt;p&gt;本代码文件目录：modules-example/src/common.widget/org/jwidgets/SimpleRenderer.java。这个package在后文中没有被exports。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package org.jwidgets;

public class SimpleRenderer {
  public void renderAsString(Object object) {
      System.out.println(object);
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;本代码文件目录：modules-example/src/common.widget/com/zimug/RendererSupport.java。这个package在后文中被exports了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.zimug;

import org.jwidgets.SimpleRenderer;

public class RendererSupport {
  public void render(Object object) {
      new SimpleRenderer().renderAsString(object);
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;模块导出，本代码文件目录：modules-example/src/common.widget/module-info.java。只导出&lt;code&gt;com.zimug&lt;/code&gt;包,没有导出 &lt;code&gt;org.jwidgets&lt;/code&gt;包。导出的模块名称为&lt;code&gt;common.widget&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;module common.widget{
  exports com.zimug;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;第二个模块&quot;&gt;第二个模块&lt;/h3&gt;
&lt;p&gt;模块导入&lt;code&gt;common.widget&lt;/code&gt;，本代码文件目录：modules-example/src/data.widget/module-info.java&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;module data.widget {
  requires common.widget;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用导入模块&lt;code&gt;common.widget&lt;/code&gt;中的package:&lt;code&gt;com.zimug&lt;/code&gt;。本代码文件路径： modules-example/src/data.widget/com/example/Component.java&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.example;

import com.zimug.RendererSupport;

public class Component {
  public static void main(String[] args) {
      RendererSupport support = new RendererSupport();
      support.render(&quot;Test Object&quot;);
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;正常编译执行，结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Test Object
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;尝试使用未被exports的package代码&quot;&gt;尝试使用未被exports的package代码&lt;/h3&gt;
&lt;p&gt;由于包“ org.jwidgets”尚未通过“ common.widget”模块导出，因此另一个模块“ data.widget”无法使用该package包下的类&lt;code&gt;SimpleRenderer&lt;/code&gt;。我们做一个反例，看看会发生什么：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.example;
import org.jwidgets.SimpleRenderer;

public class Component {
  public static void main(String[] args) {
    SimpleRenderer simpleRenderer = new SimpleRenderer(); 
    simpleRenderer.renderAsString(&quot;Test Object&quot;);
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;编译报错信息如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;D:\modules-example\src\data.widget\com\example\Component.java:3: error: package org.jwidgets is not visible
import org.jwidgets.SimpleRenderer;
          ^
  (package org.jwidgets is declared in module common.widget, which does not export it)
1 error
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;正如我们所看到的，未被exports的package下面的class即使是public的也不能被访问。&lt;/p&gt;
&lt;h2 id=&quot;欢迎关注我的博客，里面有很多精品合集&quot;&gt;欢迎关注我的博客，里面有很多精品合集&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;本文转载注明出处（必须带连接，不能只转文字）：&lt;a href=&quot;http://www.zimug.com&quot;&gt;字母哥博客&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;觉得对您有帮助的话，帮我点赞、分享！您的支持是我不竭的创作动力！&lt;/strong&gt; 。另外，笔者最近一段时间输出了如下的精品内容，期待您的关注。&lt;/p&gt;
</description>
<pubDate>Wed, 21 Oct 2020 23:56:00 +0000</pubDate>
<dc:creator>字母哥博客</dc:creator>
<og:description>我计划在后续的一段时间内，写一系列关于java 9的文章，虽然java 9 不像Java 8或者Java 11那样的核心java版本，但是还是有很多的特性值得关注。期待您能关注我，我将把java 9</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zimug/p/13855837.html</dc:identifier>
</item>
<item>
<title>【Flutter 混合开发】与原生通信-BasicMessageChannel - 老孟Flutter</title>
<link>http://www.cnblogs.com/mengqd/p/13855813.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mengqd/p/13855813.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202010/467322-20201022065958023-166951808.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;Flutter 混合开发系列 包含如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;嵌入原生View-Android&lt;/li&gt;
&lt;li&gt;嵌入原生View-iOS&lt;/li&gt;
&lt;li&gt;与原生通信-MethodChannel&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;与原生通信-BasicMessageChannel&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;与原生通信-EventChannel&lt;/li&gt;
&lt;li&gt;添加 Flutter 到 Android Activity&lt;/li&gt;
&lt;li&gt;添加 Flutter 到 Android Fragment&lt;/li&gt;
&lt;li&gt;添加 Flutter 到 iOS&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;每个工作日分享一篇，欢迎关注、点赞及转发。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;平台通信的3中方式&quot;&gt;平台通信的3中方式&lt;/h3&gt;
&lt;p&gt;Flutter 与 Native 端通信有如下3个方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;MethodChannel&lt;/strong&gt;：Flutter 与 Native 端相互调用，调用后可以返回结果，可以 Native 端主动调用，也可以Flutter主动调用，属于双向通信。此方式为最常用的方式， Native 端调用需要在主线程中执行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;BasicMessageChannel&lt;/strong&gt;：用于使用指定的编解码器对消息进行编码和解码，属于双向通信，可以 Native 端主动调用，也可以Flutter主动调用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;EventChannel&lt;/strong&gt;：用于数据流（event streams）的通信， Native 端主动发送数据给 Flutter，通常用于状态的监听，比如网络变化、传感器数据等。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;flutter-端&quot;&gt;Flutter 端&lt;/h3&gt;
&lt;p&gt;Flutter 端创建 &lt;strong&gt;MethodChannel&lt;/strong&gt; 通道，用于与原生端通信：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;var channel = BasicMessageChannel('com.flutter.guide.BasicMessageChannel',StandardMessageCodec());
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;com.flutter.guide.BasicMessageChannel&lt;/strong&gt; 是 BasicMessageChannel 的名称，原生端要与之对应。&lt;/p&gt;
&lt;p&gt;发送消息：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;var result = await channel.send({'name': 'laomeng', 'age': 18});
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;参数类型任意，多个参数通常使用&lt;strong&gt;Map&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;返回 &lt;strong&gt;Future&lt;/strong&gt;，原生端返回的数据。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;完整代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;class BasicMessageChannelDemo extends StatefulWidget {
  @override
  _BasicMessageChannelDemoState createState() =&amp;gt; _BasicMessageChannelDemoState();
}

class _BasicMessageChannelDemoState extends State&amp;lt;BasicMessageChannelDemo&amp;gt; {
  var channel = BasicMessageChannel('com.flutter.guide.BasicMessageChannel',StandardMessageCodec());

  var _data;

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(),
      body: Column(
        children: [
          SizedBox(
            height: 50,
          ),
          RaisedButton(
            child: Text('发送数据到原生'),
            onPressed: () async {
              var result = await channel.send({'name': 'laomeng', 'age': 18});
              var name = result['name'];
              var age = result['age'];
              setState(() {
                _data = '$name,$age';
              });
            },
          ),
          Text('原生返回数据：$_data'),
        ],
      ),
    );
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;android-端&quot;&gt;Android 端&lt;/h3&gt;
&lt;p&gt;android 下创建 &lt;strong&gt;BasicMessageChannelDemo&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-kotlin&quot;&gt;class BasicMessageChannelDemo(messenger: BinaryMessenger) : BasicMessageChannel.MessageHandler&amp;lt;Any&amp;gt; {

    private var channel: BasicMessageChannel&amp;lt;Any&amp;gt;

    init {
        channel = BasicMessageChannel(messenger, &quot;com.flutter.guide.BasicMessageChannel&quot;, StandardMessageCodec())
        channel.setMessageHandler(this)
    }

    override fun onMessage(message: Any?, reply: BasicMessageChannel.Reply&amp;lt;Any&amp;gt;) {
        val name = (message as Map&amp;lt;String, Any&amp;gt;)[&quot;name&quot;]
        val age = (message as Map&amp;lt;String, Any&amp;gt;)[&quot;age&quot;]

        var map = mapOf(&quot;name&quot; to &quot;hello,$name&quot;,
                &quot;age&quot; to &quot;$age&quot;
        )

        reply.reply(map)
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202010/467322-20201022065958621-24596550.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;onMessage&lt;/strong&gt; 方法在 Flutter 端调用 send 方法后调用，解析方法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-kotlin&quot;&gt;override fun onMessage(message: Any?, reply: BasicMessageChannel.Reply&amp;lt;Any&amp;gt;) {
        val name = (message as Map&amp;lt;String, Any&amp;gt;)[&quot;name&quot;]
        val age = (message as Map&amp;lt;String, Any&amp;gt;)[&quot;age&quot;]

        var map = mapOf(&quot;name&quot; to &quot;hello,$name&quot;,
                &quot;age&quot; to &quot;$age&quot;
        )

        reply.reply(map)
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;message&lt;/strong&gt; 是传入的参数，由于 Flutter 端传入的是 Map，所以上面的解析按照 Map 解析。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;reply.reply()&lt;/strong&gt; 是返回给 Flutter 的结果。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Flutter 端解析：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;var result = await channel.send({'name': 'laomeng', 'age': 18});
var name = result['name'];
var age = result['age'];
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;两端的解析要相互对应。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在 &lt;strong&gt;MainActivity&lt;/strong&gt; 启动：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-kotlin&quot;&gt;class MainActivity : FlutterActivity() {

    override fun configureFlutterEngine(flutterEngine: FlutterEngine) {
        super.configureFlutterEngine(flutterEngine)
        BasicMessageChannelDemo(flutterEngine.dartExecutor.binaryMessenger)
        flutterEngine.plugins.add(MyPlugin())
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202010/467322-20201022065959466-840057973.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;ios-端&quot;&gt;iOS 端&lt;/h3&gt;
&lt;p&gt;ios 下创建 &lt;strong&gt;MethodChannelDemo&lt;/strong&gt;，按如下方式：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-swift&quot;&gt;import Flutter
import UIKit

public class BasicMessageChannelDemo {
    
    var channel:FlutterBasicMessageChannel
    
    init(messenger: FlutterBinaryMessenger) {
        channel = FlutterBasicMessageChannel(name: &quot;com.flutter.guide.BasicMessageChannel&quot;, binaryMessenger: messenger)
        channel.setMessageHandler { (message, reply) in
            if let dict = message as? Dictionary&amp;lt;String, Any&amp;gt; {
                let name:String = dict[&quot;name&quot;] as? String ?? &quot;&quot;
                let age:Int = dict[&quot;age&quot;] as? Int ?? -1
                reply([&quot;name&quot;:&quot;hello,\(name)&quot;,&quot;age&quot;:age])
            }
        }  
    }  
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202010/467322-20201022070000345-113816986.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在 &lt;strong&gt;AppDelegate&lt;/strong&gt; 启动：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-swift&quot;&gt;import UIKit
import Flutter

@UIApplicationMain
@objc class AppDelegate: FlutterAppDelegate {
  override func application(
    _ application: UIApplication,
    didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?
  ) -&amp;gt; Bool {
    
    let controller : FlutterViewController = window?.rootViewController as! FlutterViewController
    MethodChannelDemo(messenger: controller.binaryMessenger)
    BasicMessageChannelDemo(messenger: controller.binaryMessenger)
    GeneratedPluginRegistrant.register(with: self)

    return super.application(application, didFinishLaunchingWithOptions: launchOptions)
  }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202010/467322-20201022070001385-811782312.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;原生端主动发送消息给flutter&quot;&gt;原生端主动发送消息给Flutter&lt;/h3&gt;
&lt;h5 id=&quot;flutter-端接收数据&quot;&gt;Flutter 端接收数据&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;@override
  void initState() {
    super.initState();
    channel.setMessageHandler((message) {
      setState(() {
        _nativeData = message['count'];
      });
    });
  }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;android-发送数据&quot;&gt;Android 发送数据&lt;/h5&gt;
&lt;p&gt;原生端启动定时器，每隔一秒向 Flutter 发送数据，Android 端代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;class BasicMessageChannelDemo(var activity: Activity, messenger: BinaryMessenger) : BasicMessageChannel.MessageHandler&amp;lt;Any&amp;gt; {

    private var channel: BasicMessageChannel&amp;lt;Any&amp;gt;
    private var count = 0

    init {
        channel = BasicMessageChannel(messenger, &quot;com.flutter.guide.BasicMessageChannel&quot;, StandardMessageCodec())
        channel.setMessageHandler(this)
        startTimer()
    }


    fun startTimer() {
        var timer = Timer().schedule(timerTask {
            activity.runOnUiThread {
                var map = mapOf(&quot;count&quot; to count++)
                channel.send(map,object :BasicMessageChannel.Reply&amp;lt;Any&amp;gt;{
                    override fun reply(reply: Any?) {

                    }
                })
            }
        }, 0, 1000)

    }

    override fun onMessage(message: Any?, reply: BasicMessageChannel.Reply&amp;lt;Any&amp;gt;) {
        val name = (message as Map&amp;lt;String, Any&amp;gt;)[&quot;name&quot;]
        val age = (message as Map&amp;lt;String, Any&amp;gt;)[&quot;age&quot;]

        var map = mapOf(&quot;name&quot; to &quot;hello,$name&quot;,
                &quot;age&quot; to &quot;$age&quot;
        )

        reply.reply(map)
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;注意：Android 端发送数据要在&lt;strong&gt;主现场&lt;/strong&gt;中调用，即：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-kotlin&quot;&gt;activity.runOnUiThread {
          var map = mapOf(&quot;count&quot; to count++)
          channel.invokeMethod(&quot;timer&quot;, map)
      }
&lt;/code&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;启动修改如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-kotlin&quot;&gt;class MainActivity : FlutterActivity() {

    override fun configureFlutterEngine(flutterEngine: FlutterEngine) {
        super.configureFlutterEngine(flutterEngine)
        BasicMessageChannelDemo(this,flutterEngine.dartExecutor.binaryMessenger)
        flutterEngine.plugins.add(MyPlugin())
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202010/467322-20201022070001744-131192499.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;ios-发送数据&quot;&gt;iOS 发送数据&lt;/h5&gt;
&lt;p&gt;iOS 端启动定时器代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;
import Flutter
import UIKit

public class BasicMessageChannelDemo {
    
    var channel:FlutterBasicMessageChannel
    var count =  0
    
    init(messenger: FlutterBinaryMessenger) {
        channel = FlutterBasicMessageChannel(name: &quot;com.flutter.guide.BasicMessageChannel&quot;, binaryMessenger: messenger)
        channel.setMessageHandler { (message, reply) in
            if let dict = message as? Dictionary&amp;lt;String, Any&amp;gt; {
                let name:String = dict[&quot;name&quot;] as? String ?? &quot;&quot;
                let age:Int = dict[&quot;age&quot;] as? Int ?? -1
                reply([&quot;name&quot;:&quot;hello,\(name)&quot;,&quot;age&quot;:age])
            }
        }
        startTimer()
    }
    
    func startTimer() {
        var timer = Timer.scheduledTimer(timeInterval:1, target: self, selector:#selector(self.tickDown),userInfo:nil,repeats: true)
    }
    @objc func tickDown(){
        count += 1
        var args = [&quot;count&quot;:count]
        channel.sendMessage(args) { (reply) in
            
        }
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202010/467322-20201022070002006-678733584.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;交流&quot;&gt;交流&lt;/h2&gt;
&lt;p&gt;老孟Flutter博客（330个控件用法+实战入门系列文章）：&lt;a href=&quot;http://laomengit.com&quot;&gt;http://laomengit.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎加入Flutter交流群（微信：laomengit）、关注公众号【老孟Flutter】：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th/&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202010/467322-20201022070003243-471197159.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202010/467322-20201022070003756-1491690750.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</description>
<pubDate>Wed, 21 Oct 2020 23:00:00 +0000</pubDate>
<dc:creator>老孟Flutter</dc:creator>
<og:description>Flutter 混合开发系列 包含如下： 嵌入原生View-Android 嵌入原生View-iOS 与原生通信-MethodChannel 与原生通信-BasicMessageChannel 与原生</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mengqd/p/13855813.html</dc:identifier>
</item>
<item>
<title>[开源] .Net ORM FreeSql 1.10.0 稳步向前 - nicye</title>
<link>http://www.cnblogs.com/kellynic/p/13855784.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kellynic/p/13855784.html</guid>
<description>&lt;p&gt;FreeSql 是 .NET 开源生态下的 ORM 轮子，转眼快两年了，说真的开源不容易（只有经历过才明白）。今天带点干货和湿货给大家，先说下湿货。&lt;/p&gt;
&lt;p&gt;认识我的人，知道 CSRedisCore 是我写的另外一个开源组件，这个项目是 2016 年从 ctstone/csredis 项目 clone 到自己工作的项目中，修改源码经过一年多生产考验，于 2017 年发布开源 &lt;a href=&quot;https://github.com/2881099/csredis&quot;&gt;https://github.com/2881099/csredis&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ctstone/csredis 项目于 2014 年停止了更新，到我手里完善的功能如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;连接池&lt;/li&gt;
&lt;li&gt;哨兵高可用&lt;/li&gt;
&lt;li&gt;集群&lt;/li&gt;
&lt;li&gt;redis 2.8 以上的版本命令补充，包括 Geo、Stream&lt;/li&gt;
&lt;li&gt;通讯协议 bug 修复&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;暂时想到的只有这些，之后可能再补充。FreeSql 文章标题为什么要来说 csredis？&lt;/p&gt;
&lt;p&gt;这两年的时间里 95% 精力都用在了 FreeSql 上面， 5400+ 单元测试、支持十几种数据库适配，渣男辜负了 csredis 这个项目。最近一个多月开源圈子的奇葩事接二连三，居然有人跑去 ctstone/csredis 原作者的 issues 告我的状，这个告状的人还是 NOPI 原作者，因为当初他自己不维护 NPOI .NET Core 版本了，社区有好人把 .NET Core 版本测试做好了开源(dotnetcore/NPOI)，告状的人很真心厉害，已经成功把 nuget.org/dotnetcore.npoi 整下架了。&lt;/p&gt;
&lt;p&gt;他并没有得到满足，之后开始针对整个 NCC 社区成员，包括我。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;他去了 sqlsugar issues 发表，说要找出 FreeSql 抄袭 sqlsugar 的证据&lt;/li&gt;
&lt;li&gt;他又去 fur issues 发表声援，说我黑他&lt;/li&gt;
&lt;li&gt;他还去 csredis 原作者 issues 发布内容，企图告我的状&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;并不是人人都像你一样，强迫要求下游项目“归档”、“制裁”，试问 mysql 可以要求 mariadb 归档？针对 NCC 组织还是针对我本人？CSRedisCore 并不在 NCC 开源组织下！！！&lt;/p&gt;
&lt;p&gt;几天月前我已经开始了新的 redis .NET 开源组件库的编写，完全自主的看你能上哪里告状。有了这么长时间的 csredis 经验，重新写一个能避免很多问题，设计也会更好，后面我会花大部分时间做新项目，这便是今天带来的湿货，敬请期待发布！~！&lt;/p&gt;

&lt;p&gt;2018 年 12 月份开发 FreeSql 到现在，2200 颗星，500 Issues，200K 包下载量。说明还是有开发者关注和喜爱，只要有人关注，就不会停更不修 BUG 一说。大家有兴趣可以看看更新记录，看看我们的代码提交量，5400+ 单元测试不说非常多，个人觉得已经超过很多国产项目。&lt;/p&gt;
&lt;p&gt;23个月了，FreeSql 还活着，而且生命力顽强见下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/31407/202010/31407-20201022021555253-1521774408.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;年底发布 2.0 版本正在收集需求中（欢迎前去 issues 诚意登记），本文将介绍在过去的几个月完成的一些有意义的功能介绍。&lt;/p&gt;
&lt;p&gt;FreeSql 是 .Net ORM，能支持 .NetFramework4.0+、.NetCore、Xamarin、XAUI、Blazor、以及还有说不出来的运行平台，因为代码绿色无依赖，支持新平台非常简单。目前单元测试数量：5400+，Nuget下载数量：200K+，源码几乎每天都有提交。值得高兴的是 FreeSql 加入了 ncc 开源社区：&lt;a href=&quot;https://github.com/dotnetcore/FreeSql&quot;&gt;https://github.com/dotnetcore/FreeSql&lt;/a&gt;，加入组织之后社区责任感更大，需要更努力做好品质，为开源社区出一份力。&lt;/p&gt;
&lt;p&gt;QQ群：4336577(已满)、8578575(在线)、52508226(在线)&lt;/p&gt;
&lt;p&gt;为什么要重复造轮子？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/31407/202005/31407-20200525013907903-1470982538.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;FreeSql 主要优势在于易用性上，基本是开箱即用，在不同数据库之间切换兼容性比较好。作者花了大量的时间精力在这个项目，肯请您花半小时了解下项目，谢谢。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;FreeSql 整体的功能特性如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;支持 CodeFirst 对比结构变化迁移；&lt;/li&gt;
&lt;li&gt;支持 DbFirst 从数据库导入实体类；&lt;/li&gt;
&lt;li&gt;支持 丰富的表达式函数，自定义解析；&lt;/li&gt;
&lt;li&gt;支持 批量添加、批量更新、BulkCopy；&lt;/li&gt;
&lt;li&gt;支持 导航属性，贪婪加载、延时加载、级联保存；&lt;/li&gt;
&lt;li&gt;支持 读写分离、分表分库，租户设计；&lt;/li&gt;
&lt;li&gt;支持 MySql/SqlServer/PostgreSQL/Oracle/Sqlite/Firebird/达梦/神通/人大金仓/MsAccess Ado.net 实现包，以及 Odbc 的专门实现包；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;1.5.0 -&amp;gt; 1.10.0 更新的重要功能如下：&lt;/p&gt;
&lt;p&gt;一、增加 Firebird 数据库实现；&lt;/p&gt;
&lt;p&gt;二、增加 人大金仓/神通 数据库的访问支持；&lt;/p&gt;
&lt;p&gt;三、增加 GlobalFilter.ApplyIf 创建动态过滤器；&lt;/p&gt;
&lt;p&gt;四、增加 ISelect.InsertInto 将查询转换为 INSERT INTO t1 SELECT ... FROM t2 执行插入；&lt;/p&gt;
&lt;p&gt;五、增加 IncludeMany(a =&amp;gt; a.Childs).ToList(a =&amp;gt; new { a.Childs }) 指定集合属性返回；&lt;/p&gt;
&lt;p&gt;六、增加 $&quot;{a.Code}_{a.Id}&quot; lambda 解析；&lt;/p&gt;
&lt;p&gt;七、增加 lambda 表达式树解析子查询 ToList + string.Join() 产生 类似 group_concat 的效果；&lt;/p&gt;
&lt;p&gt;八、增加 SqlExt 常用开窗函数的自定义表达式解析；&lt;/p&gt;
&lt;p&gt;九、增加 ISelect/IInsert/IUpdate/IDelete CommandTimeout 方法设置命令超时；&lt;/p&gt;
&lt;p&gt;十、完善 WhereDynamicFilter 动态过滤查询；&lt;/p&gt;
&lt;p&gt;十一、增加 BeginEdit/EndEdit 批量编辑数据的功能；&lt;/p&gt;
&lt;p&gt;十二、增加 父子表（树表）递归查询、删除功能；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/31407/202005/31407-20200525014307613-207448539.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;FreeSql 使用非常简单，只需要定义一个 IFreeSql 对象即可：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;static IFreeSql fsql = new FreeSql.FreeSqlBuilder()
    .UseConnectionString(FreeSql.DataType.MySql, connectionString)
    .UseAutoSyncStructure(true) //自动同步实体结构到数据库
    .Build(); //请务必定义成 Singleton 单例模式
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;它的体积比前辈Interbase缩小了几十倍，但功能并无阉割。为了体现Firebird短小精悍的特色，开发小组在增加了超级服务器版本之后，又增加了嵌入版本，最新版本为2.0。Firebird的嵌入版有如下特色：&lt;/p&gt;
&lt;p&gt;1、数据库文件与Firebird网络版本完全兼容，差别仅在于连接方式不同，可以实现零成本迁移。&lt;br/&gt;2、数据库文件仅受操作系统的限制，且支持将一个数据库分割成不同文件，突破了操作系统最大文件的限制，提高了IO吞吐量。&lt;br/&gt;3、完全支持SQL92标准，支持大部分SQL-99标准功能。&lt;br/&gt;4、丰富的开发工具支持，绝大部分基于Interbase的组件，可以直接使用于Firebird。&lt;br/&gt;5、支持事务、存储过程、触发器等关系数据库的所有特性。&lt;br/&gt;6、可自己编写扩展函数(UDF)。&lt;br/&gt;7、firebird其实并不是纯粹的嵌入式数据库，embed版只是其众多版本中的一个。不过做的也很小，把几个dll加起来才不到5M，但是它支持绝大部份SQL92与SQL99标准&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;嵌入式，等于无需安装的本地数据库，欢迎体验！~~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;
&lt;p&gt;天津神舟通用数据技术有限公司（简称“神舟通用公司”），隶属于中国航天科技集团（CASC）。是国内从事数据库、大数据解决方案和数据挖掘分析产品研发的专业公司。公司获得了国家核高基科技重大专项重点支持，是核高基专项的牵头承担单位。自1993年在航天科技集团开展数据库研发以来，神通数据库已历经27年的发展历程。公司核心产品主要包括神通关系型数据库、神通KStore海量数据管理系统、神通商业智能套件等系列产品研发和市场销售。基于产品组合，可形成支持交易处理、MPP数据库集群、数据分析与处理等解决方案，可满足多种应用场景需求。产品通过了国家保密局涉密信息系统、公安部等保四级、军B +级等安全评测和认证。&lt;/p&gt;
&lt;p&gt;北京人大金仓信息技术股份有限公司（以下简称“人大金仓”）是具有自主知识产权的国产数据管理软件与服务提供商。人大金仓由中国人民大学一批最早在国内开展数据库教学、科研、开发的专家于1999年发起创立，先后承担了国家“863”、“核高基”等重大专项，研发出了具有国际先进水平的大型通用数据库产品。2018年，人大金仓申报的“数据库管理系统核心技术的创新与金仓数据库产业化”项目荣获2018年度国家科学技术进步二等奖，产学研的融合进一步助力国家信息化建设。&lt;/p&gt;
&lt;p&gt;随着华为、中兴事务，国产数据库市场相信是未来是趋势走向，纵观 .net core 整个圈子对国产神舟通用、人大金仓数据库的支持几乎为 0，今天 FreeSql ORM 可以使用 CodeFirst/DbFirst 两种模式进行开发。&lt;/p&gt;
&lt;p&gt;并且声称：FreeSql 对各数据库没有亲儿子一说，除了 MsAcces 其他全部是亲儿子，在功能提供方面一碗水端平。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/31407/202005/31407-20200525014801483-1494727409.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;众所周知 EFCore for oracle 问题多，并且现在才刚刚更新到 3.x，在这样的背景下，一个国产数据库更不能指望谁实现好用的 EFCore。目前看来除了 EFCore for sqlserver 我们没把握完全占优势，起码在其他数据库肯定是我们更接地气。&lt;/p&gt;
&lt;p&gt;使用 FreeSql 访问人大金仓/神通 数据库，只需要修改代码如下即可：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;static IFreeSql fsql = new FreeSql.FreeSqlBuilder()
    .UseConnectionString(FreeSql.DataType.ShenTong, connectionString) //修改 DataType 设置切换数据库
    .UseAutoSyncStructure(true) //自动同步实体结构到数据库
    .Build(); //请务必定义成 Singleton 单例模式
&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;
&lt;p&gt;FreeSql 使用全局过滤器非常简单，我们的过滤器支持多表查询、子查询，只需要设置一次：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public static AsyncLocal&amp;lt;Guid&amp;gt; TenantId { get; set; } = new AsyncLocal&amp;lt;Guid&amp;gt;();

fsql.GlobalFilter
    .Apply&amp;lt;ISoftDelete&amp;gt;(&quot;name1&quot;, a =&amp;gt; a.IsDeleted == false)
    .ApplyIf&amp;lt;ITenant&amp;gt;(&quot;tenant&quot;, () =&amp;gt; TenantId.Value != Guid.Empty, a =&amp;gt; a.TenantId == TenantId.Value);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面增加了两个过滤器，tenant 第二个参数正是增加的功能，当委托条件成立时才会附加过滤器。&lt;/p&gt;
&lt;hr/&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;int affrows = fsql.Select&amp;lt;Topic&amp;gt;()
  .Limit(10)
  .InsertInto(null, a =&amp;gt; new Topic2
  {
    Title = a.Title
  });
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;INSERT INTO `Topic2`(`Title`, `Clicks`, `CreateTime`)
SELECT a.`Title`, 0, '0001-01-01 00:00:00' 
FROM `Topic` a 
limit 10
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：因为 Clicks、CreateTime 没有被选择，所以使用目标实体属性 [Column(InsertValueSql = xx)] 设置的值，或者使用目标实体属性的 c# 默认值。&lt;/p&gt;
&lt;p&gt;又一次完善了批量操作数据的功能，之前已经有的功能如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;fsql.InsertOrUpdate 相当于 Merge Into/on duplicate key update&lt;/li&gt;
&lt;/ul&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Database&lt;/th&gt;
&lt;th&gt;Features&lt;/th&gt;
&lt;th/&gt;
&lt;th&gt;Database&lt;/th&gt;
&lt;th&gt;Features&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;MySql&lt;/td&gt;
&lt;td&gt;on duplicate key update&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;达梦&lt;/td&gt;
&lt;td&gt;merge into&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;PostgreSQL&lt;/td&gt;
&lt;td&gt;on conflict do update&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;人大金仓&lt;/td&gt;
&lt;td&gt;on conflict do update&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;SqlServer&lt;/td&gt;
&lt;td&gt;merge into&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;神通&lt;/td&gt;
&lt;td&gt;merge into&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Oracle&lt;/td&gt;
&lt;td&gt;merge into&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;MsAccess&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Sqlite&lt;/td&gt;
&lt;td&gt;replace into&lt;/td&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Firebird&lt;/td&gt;
&lt;td&gt;merge into&lt;/td&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;ul&gt;&lt;li&gt;fsql.Insert(数组).ExecuteAffrows() 相当于批量插入&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;var t2 = fsql.Insert(items).ExecuteAffrows();
//INSERT INTO `Topic`(`Clicks`, `Title`, `CreateTime`) 
//VALUES(?Clicks0, ?Title0, ?CreateTime0), (?Clicks1, ?Title1, ?CreateTime1), 
//(?Clicks2, ?Title2, ?CreateTime2), (?Clicks3, ?Title3, ?CreateTime3), 
//(?Clicks4, ?Title4, ?CreateTime4), (?Clicks5, ?Title5, ?CreateTime5), 
//(?Clicks6, ?Title6, ?CreateTime6), (?Clicks7, ?Title7, ?CreateTime7), 
//(?Clicks8, ?Title8, ?CreateTime8), (?Clicks9, ?Title9, ?CreateTime9)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当插入大批量数据时，内部采用分割分批执行的逻辑进行。分割规则：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th&gt;数量&lt;/th&gt;
&lt;th&gt;参数量&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;MySql&lt;/td&gt;
&lt;td&gt;5000&lt;/td&gt;
&lt;td&gt;3000&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;PostgreSQL&lt;/td&gt;
&lt;td&gt;5000&lt;/td&gt;
&lt;td&gt;3000&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;SqlServer&lt;/td&gt;
&lt;td&gt;1000&lt;/td&gt;
&lt;td&gt;2100&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Oracle&lt;/td&gt;
&lt;td&gt;500&lt;/td&gt;
&lt;td&gt;999&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Sqlite&lt;/td&gt;
&lt;td&gt;5000&lt;/td&gt;
&lt;td&gt;999&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;hr/&gt;
&lt;p&gt;这个功能实在太重要了，在此之前 IncludeMany 和 ToList(指定字段) 八字不合，用起来有些麻烦。现在终于解决了！！~~&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;var t111 = fsql.Select&amp;lt;Topic&amp;gt;()
    .IncludeMany(a =&amp;gt; a.TopicType.Photos)
    .Where(a =&amp;gt; a.Id &amp;lt;= 100)
    .ToList(a =&amp;gt; new
    {
        a.Id,
        a.TopicType.Photos,
        Photos2 = a.TopicType.Photos
    });
&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;
&lt;p&gt;在之前查询数据的时候，$&quot;&quot; 这种语法糖神器居然不能使用在 lambda 表达式中，实属遗憾。现在终于可以了，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;var item = fsql.GetRepository&amp;lt;Topic&amp;gt;().Insert(new Topic { Clicks = 101, Title = &quot;我是中国人101&quot;, CreateTime = DateTime.Parse(&quot;2020-7-5&quot;) });
var sql = fsql.Select&amp;lt;Topic&amp;gt;().WhereDynamic(item).ToSql(a =&amp;gt; new
{
    str = $&quot;x{a.Id + 1}z-{a.CreateTime.ToString(&quot;yyyyMM&quot;)}{a.Title}{a.Title}&quot;
});
Assert.Equal($@&quot;SELECT concat('x',ifnull((a.`Id` + 1), ''),'z-',ifnull(date_format(a.`CreateTime`,'%Y%m'), ''),'',ifnull(a.`Title`, ''),'',ifnull(a.`Title`, ''),'') as1 
FROM `tb_topic` a 
WHERE (a.`Id` = {item.Id})&quot;, sql);
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;再次说明：都是亲儿子，并且都有对应的单元测试，兄台大可放心用在不同的数据库中&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;
&lt;p&gt;v1.8.0+ string.Join + ToList 实现将子查询的多行结果，拼接为一个字符串，如：&quot;1,2,3,4&quot;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;fsql.Select&amp;lt;Topic&amp;gt;().ToList(a =&amp;gt; new {
  id = a.Id,
  concat = string.Join(&quot;,&quot;, fsql.Select&amp;lt;StringJoin01&amp;gt;().ToList(b =&amp;gt; b.Id))
});
//SELECT a.`Id`, (SELECT group_concat(b.`Id` separator ',') 
//    FROM `StringJoin01` b) 
//FROM `Topic` a
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该语法，在不同数据库都作了相应的 SQL 翻译。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;SqlExt.cs 定义了一些常用的表达式树解析，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;fsql.Select&amp;lt;T1, T2&amp;gt;()
  .InnerJoin((a, b) =&amp;gt; b.Id == a.Id)
  .ToList((a, b) =&amp;gt; new
  {
    Id = a.Id,
    EdiId = b.Id,
    over1 = SqlExt.Rank().Over().OrderBy(a.Id).OrderByDescending(b.EdiId).ToValue(),
    case1 = SqlExt.Case()
      .When(a.Id == 1, 10)
      .When(a.Id == 2, 11)
      .When(a.Id == 3, 12)
      .When(a.Id == 4, 13)
      .When(a.Id == 5, SqlExt.Case().When(b.Id == 1, 10000).Else(999).End())
  .End(), //这里因为复杂才这样，一般使用三元表达式即可：a.Id == 1 ? 10 : 11
  groupct1 = SqlExt.GroupConcat(a.Id).Distinct().OrderBy(b.EdiId).Separator(&quot;_&quot;).ToValue()
  });
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;本功能利用 FreeSql 自定义解析实现常用表达式树解析，欢迎 PR 补充&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;
&lt;p&gt;现在每条 crud 都可以设置命令执行的超时值，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;fsql.Insert&amp;lt;items).CommandTimeout(60).ExecuteAffrows();

fsql.Delete&amp;lt;T&amp;gt;().Where(...).CommandTimeout(60).ExecuteAffrows();

fsql.Update&amp;lt;T&amp;gt;()
    .Set(a =&amp;gt; a.Clicks + 1)
    .Where(...)
    .CommandTimeout(60).ExecuteAffrows();

fsql.Select&amp;lt;T&amp;gt;().Where(...).CommandTimeout(60).ToList();
&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/31407/202005/31407-20200524235718959-1427957349.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;是否见过这样的高级查询功能，WhereDynamicFilter 在后端可以轻松完成这件事情，前端根据 UI 组装好对应的 json 字符串传给后端就行，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;DynamicFilterInfo dyfilter = JsonConvert.DeserializeObject&amp;lt;DynamicFilterInfo&amp;gt;(@&quot;
{
  &quot;&quot;Logic&quot;&quot; : &quot;&quot;Or&quot;&quot;,
  &quot;&quot;Filters&quot;&quot; :
  [
    {
      &quot;&quot;Field&quot;&quot; : &quot;&quot;Code&quot;&quot;, &quot;&quot;Operator&quot;&quot; : &quot;&quot;NotContains&quot;&quot;, &quot;&quot;Value&quot;&quot; : &quot;&quot;val1&quot;&quot;, 
      &quot;&quot;Filters&quot;&quot; : [{ &quot;&quot;Field&quot;&quot; : &quot;&quot;Name&quot;&quot;, &quot;&quot;Operator&quot;&quot; : &quot;&quot;NotStartsWith&quot;&quot;, &quot;&quot;Value&quot;&quot; : &quot;&quot;val2&quot;&quot; }]
    },
    {
      &quot;&quot;Field&quot;&quot; : &quot;&quot;Parent.Code&quot;&quot;, &quot;&quot;Operator&quot;&quot; : &quot;&quot;Equals&quot;&quot;, &quot;&quot;Value&quot;&quot; : &quot;&quot;val11&quot;&quot;,
      &quot;&quot;Filters&quot;&quot; : [{ &quot;&quot;Field&quot;&quot; : &quot;&quot;Parent.Name&quot;&quot;, &quot;&quot;Operator&quot;&quot; : &quot;&quot;Contains&quot;&quot;, &quot;&quot;Value&quot;&quot; : &quot;&quot;val22&quot;&quot; }]
    }
  ]
}&quot;);
fsql.Select&amp;lt;VM_District_Parent&amp;gt;().WhereDynamicFilter(dyfilter).ToList();
//SELECT a.&quot;&quot;Code&quot;&quot;, a.&quot;&quot;Name&quot;&quot;, a.&quot;&quot;ParentCode&quot;&quot;, a__Parent.&quot;&quot;Code&quot;&quot; as4, a__Parent.&quot;&quot;Name&quot;&quot; as5, a__Parent.&quot;&quot;ParentCode&quot;&quot; as6 
//FROM &quot;&quot;D_District&quot;&quot; a 
//LEFT JOIN &quot;&quot;D_District&quot;&quot; a__Parent ON a__Parent.&quot;&quot;Code&quot;&quot; = a.&quot;&quot;ParentCode&quot;&quot; 
//WHERE (not((a.&quot;&quot;Code&quot;&quot;) LIKE '%val1%') AND not((a.&quot;&quot;Name&quot;&quot;) LIKE 'val2%') OR a__Parent.&quot;&quot;Code&quot;&quot; = 'val11' AND (a__Parent.&quot;&quot;Name&quot;&quot;) LIKE '%val22%')
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ISelect.WhereDynamicFilter 方法实现动态过滤条件（与前端交互），支持的操作符：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Contains/StartsWith/EndsWith/NotContains/NotStartsWith/NotEndsWith：包含/不包含，like '%xx%'，或者 like 'xx%'，或者 like '%xx'&lt;/li&gt;
&lt;li&gt;Equal/NotEqual：等于/不等于&lt;/li&gt;
&lt;li&gt;GreaterThan/GreaterThanOrEqual：大于/大于等于&lt;/li&gt;
&lt;li&gt;LessThan/LessThanOrEqual：小于/小于等于&lt;/li&gt;
&lt;li&gt;Range：范围查询&lt;/li&gt;
&lt;li&gt;DateRange：日期范围，有特殊处理 value[1] + 1&lt;/li&gt;
&lt;li&gt;Any/NotAny：是否符合 value 中任何一项（直白的说是 SQL IN）&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;
&lt;p&gt;场景：winform 加载表数据后，一顿添加、修改、删除操作之后，点击【保存】&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;[Fact]
public void BeginEdit()
{
    fsql.Delete&amp;lt;BeginEdit01&amp;gt;().Where(&quot;1=1&quot;).ExecuteAffrows();
    var repo = fsql.GetRepository&amp;lt;BeginEdit01&amp;gt;();
    var cts = new[] {
        new BeginEdit01 { Name = &quot;分类1&quot; },
        new BeginEdit01 { Name = &quot;分类1_1&quot; },
        new BeginEdit01 { Name = &quot;分类1_2&quot; },
        new BeginEdit01 { Name = &quot;分类1_3&quot; },
        new BeginEdit01 { Name = &quot;分类2&quot; },
        new BeginEdit01 { Name = &quot;分类2_1&quot; },
        new BeginEdit01 { Name = &quot;分类2_2&quot; }
    }.ToList();
    repo.Insert(cts);

    repo.BeginEdit(cts); //开始对 cts 进行编辑

    cts.Add(new BeginEdit01 { Name = &quot;分类2_3&quot; });
    cts[0].Name = &quot;123123&quot;;
    cts.RemoveAt(1);

    Assert.Equal(3, repo.EndEdit());
}
class BeginEdit01
{
    public Guid Id { get; set; }
    public string Name { get; set; }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码 EndEdit 方法执行的时候产生 3 条 SQL 如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;INSERT INTO &quot;BeginEdit01&quot;(&quot;Id&quot;, &quot;Name&quot;) VALUES('5f26bf07-6ac3-cbe8-00da-7dd74818c3a6', '分类2_3')


UPDATE &quot;BeginEdit01&quot; SET &quot;Name&quot; = '123123' 
WHERE (&quot;Id&quot; = '5f26bf00-6ac3-cbe8-00da-7dd01be76e26')


DELETE FROM &quot;BeginEdit01&quot; WHERE (&quot;Id&quot; = '5f26bf00-6ac3-cbe8-00da-7dd11bcf54dc')
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;提醒：该操作只对变量 cts 有效，不是针对全表对比更新。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;无限级分类（父子）是一种比较常用的表设计，每种设计方式突出优势的同时也带来缺陷，如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;方法1：表设计中只有 parent_id 字段，困扰：查询麻烦（本文可解决）；&lt;/li&gt;
&lt;li&gt;方法2：表设计中冗余子级id便于查询，困扰：添加/更新/删除的时候需要重新计算；&lt;/li&gt;
&lt;li&gt;方法3：表设计中存储左右值编码，困扰：同上；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;方法1设计最简单，我们正是解决它设计简单，使用复杂的问题。&lt;/p&gt;
&lt;p&gt;首先，按照导航属性的定义，定义好父子属性：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public class Area
{
  [Column(IsPrimary = true)]
  public string Code { get; set; }

  public string Name { get; set; }
  public virtual string ParentCode { get; set; }

  [Navigate(nameof(ParentCode))]
  public Area Parent { get; set; }
  [Navigate(nameof(ParentCode))]
  public List&amp;lt;Area&amp;gt; Childs { get; set; }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;定义 Parent 属性，在表达式中可以这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;fsql.Select&amp;lt;Area&amp;gt;().Where(a =&amp;gt; a.Parent.Parent.Parent.Name == &quot;中国&quot;).First();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;定义 Childs 属性，在表达式中可以这样（子查询）：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;fsql.Select&amp;lt;Area&amp;gt;().Where(a =&amp;gt; a.Childs.AsSelect().Any(c =&amp;gt; c.Name == &quot;北京&quot;)).First();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;定义 Childs 属性，还可以使用&lt;a href=&quot;https://github.com/dotnetcore/FreeSql/wiki/%E8%81%94%E7%BA%A7%E4%BF%9D%E5%AD%98&quot;&gt;【级联保存】&lt;/a&gt;、&lt;a href=&quot;https://github.com/2881099/FreeSql/wiki/%e8%b4%aa%e5%a9%aa%e5%8a%a0%e8%bd%bd&quot;&gt;【贪婪加载】&lt;/a&gt; 等等操作。&lt;/p&gt;
&lt;p&gt;利用级联保存，添加测试数据如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;fsql.Delete&amp;lt;Area&amp;gt;().Where(&quot;1=1&quot;).ExecuteAffrows();
var repo = fsql.GetRepository&amp;lt;Area&amp;gt;();
repo.DbContextOptions.EnableAddOrUpdateNavigateList = true;
repo.DbContextOptions.NoneParameter = true;
repo.Insert(new Area
{
  Code = &quot;100000&quot;,
  Name = &quot;中国&quot;,
  Childs = new List&amp;lt;Area&amp;gt;(new[] {
    new Area
    {
      Code = &quot;110000&quot;,
      Name = &quot;北京&quot;,
      Childs = new List&amp;lt;Area&amp;gt;(new[] {
        new Area{ Code=&quot;110100&quot;, Name = &quot;北京市&quot; },
        new Area{ Code=&quot;110101&quot;, Name = &quot;东城区&quot; },
      })
    }
  })
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;功能1：ToTreeList&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;配置好父子属性之后，就可以这样用了：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;var t1 = fsql.Select&amp;lt;Area&amp;gt;().ToTreeList();
Assert.Single(t1);
Assert.Equal(&quot;100000&quot;, t1[0].Code);
Assert.Single(t1[0].Childs);
Assert.Equal(&quot;110000&quot;, t1[0].Childs[0].Code);
Assert.Equal(2, t1[0].Childs[0].Childs.Count);
Assert.Equal(&quot;110100&quot;, t1[0].Childs[0].Childs[0].Code);
Assert.Equal(&quot;110101&quot;, t1[0].Childs[0].Childs[1].Code);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查询数据本来是平面的，ToTreeList 方法将返回的平面数据在内存中加工为树型 List 返回。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;功能2：AsTreeCte 递归删除&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;很常见的无限级分类表功能，删除树节点时，把子节点也处理一下。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;fsql.Select&amp;lt;Area&amp;gt;()
  .Where(a =&amp;gt; a.Name == &quot;中国&quot;)
  .AsTreeCte()
  .ToDelete()
  .ExecuteAffrows(); //删除 中国 下的所有记录
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果软删除：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;fsql.Select&amp;lt;Area&amp;gt;()
  .Where(a =&amp;gt; a.Name == &quot;中国&quot;)
  .AsTreeCte()
  .ToUpdate()
  .Set(a =&amp;gt; a.IsDeleted, true)
  .ExecuteAffrows(); //软删除 中国 下的所有记录
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;功能3：AsTreeCte 递归查询&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;若不做数据冗余的无限级分类表设计，递归查询少不了，AsTreeCte 正是解决递归查询的封装，方法参数说明：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;(可选) pathSelector&lt;/td&gt;
&lt;td&gt;路径内容选择，可以设置查询返回：中国 -&amp;gt; 北京 -&amp;gt; 东城区&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;(可选) up&lt;/td&gt;
&lt;td&gt;false(默认)：由父级向子级的递归查询，true：由子级向父级的递归查询&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;(可选) pathSeparator&lt;/td&gt;
&lt;td&gt;设置 pathSelector 的连接符，默认：-&amp;gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;(可选) level&lt;/td&gt;
&lt;td&gt;设置递归层级&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;通过测试的数据库：MySql8.0、SqlServer、PostgreSQL、Oracle、Sqlite、达梦、人大金仓&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;姿势一：AsTreeCte() + ToTreeList&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;var t2 = fsql.Select&amp;lt;Area&amp;gt;()
  .Where(a =&amp;gt; a.Name == &quot;中国&quot;)
  .AsTreeCte() //查询 中国 下的所有记录
  .OrderBy(a =&amp;gt; a.Code)
  .ToTreeList(); //非必须，也可以使用 ToList（见姿势二）
Assert.Single(t2);
Assert.Equal(&quot;100000&quot;, t2[0].Code);
Assert.Single(t2[0].Childs);
Assert.Equal(&quot;110000&quot;, t2[0].Childs[0].Code);
Assert.Equal(2, t2[0].Childs[0].Childs.Count);
Assert.Equal(&quot;110100&quot;, t2[0].Childs[0].Childs[0].Code);
Assert.Equal(&quot;110101&quot;, t2[0].Childs[0].Childs[1].Code);
// WITH &quot;as_tree_cte&quot;
// as
// (
// SELECT 0 as cte_level, a.&quot;Code&quot;, a.&quot;Name&quot;, a.&quot;ParentCode&quot; 
// FROM &quot;Area&quot; a 
// WHERE (a.&quot;Name&quot; = '中国')

// union all

// SELECT wct1.cte_level + 1 as cte_level, wct2.&quot;Code&quot;, wct2.&quot;Name&quot;, wct2.&quot;ParentCode&quot; 
// FROM &quot;as_tree_cte&quot; wct1 
// INNER JOIN &quot;Area&quot; wct2 ON wct2.&quot;ParentCode&quot; = wct1.&quot;Code&quot;
// )
// SELECT a.&quot;Code&quot;, a.&quot;Name&quot;, a.&quot;ParentCode&quot; 
// FROM &quot;as_tree_cte&quot; a 
// ORDER BY a.&quot;Code&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;姿势二：AsTreeCte() + ToList&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;var t3 = fsql.Select&amp;lt;Area&amp;gt;()
  .Where(a =&amp;gt; a.Name == &quot;中国&quot;)
  .AsTreeCte()
  .OrderBy(a =&amp;gt; a.Code)
  .ToList();
Assert.Equal(4, t3.Count);
Assert.Equal(&quot;100000&quot;, t3[0].Code);
Assert.Equal(&quot;110000&quot;, t3[1].Code);
Assert.Equal(&quot;110100&quot;, t3[2].Code);
Assert.Equal(&quot;110101&quot;, t3[3].Code);
//执行的 SQL 与姿势一相同
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;姿势三：AsTreeCte(pathSelector) + ToList&lt;/p&gt;
&lt;p&gt;设置 pathSelector 参数后，如何返回隐藏字段？&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;var t4 = fsql.Select&amp;lt;Area&amp;gt;()
  .Where(a =&amp;gt; a.Name == &quot;中国&quot;)
  .AsTreeCte(a =&amp;gt; a.Name + &quot;[&quot; + a.Code + &quot;]&quot;)
  .OrderBy(a =&amp;gt; a.Code)
  .ToList(a =&amp;gt; new { 
    item = a, 
    level = Convert.ToInt32(&quot;a.cte_level&quot;), 
    path = &quot;a.cte_path&quot; 
  });
Assert.Equal(4, t4.Count);
Assert.Equal(&quot;100000&quot;, t4[0].item.Code);
Assert.Equal(&quot;110000&quot;, t4[1].item.Code);
Assert.Equal(&quot;110100&quot;, t4[2].item.Code);
Assert.Equal(&quot;110101&quot;, t4[3].item.Code);
Assert.Equal(&quot;中国[100000]&quot;, t4[0].path);
Assert.Equal(&quot;中国[100000] -&amp;gt; 北京[110000]&quot;, t4[1].path);
Assert.Equal(&quot;中国[100000] -&amp;gt; 北京[110000] -&amp;gt; 北京市[110100]&quot;, t4[2].path);
Assert.Equal(&quot;中国[100000] -&amp;gt; 北京[110000] -&amp;gt; 东城区[110101]&quot;, t4[3].path);
// WITH &quot;as_tree_cte&quot;
// as
// (
// SELECT 0 as cte_level, a.&quot;Name&quot; || '[' || a.&quot;Code&quot; || ']' as cte_path, a.&quot;Code&quot;, a.&quot;Name&quot;, a.&quot;ParentCode&quot; 
// FROM &quot;Area&quot; a 
// WHERE (a.&quot;Name&quot; = '中国')

// union all

// SELECT wct1.cte_level + 1 as cte_level, wct1.cte_path || ' -&amp;gt; ' || wct2.&quot;Name&quot; || '[' || wct2.&quot;Code&quot; || ']' as cte_path, wct2.&quot;Code&quot;, wct2.&quot;Name&quot;, wct2.&quot;ParentCode&quot; 
// FROM &quot;as_tree_cte&quot; wct1 
// INNER JOIN &quot;Area&quot; wct2 ON wct2.&quot;ParentCode&quot; = wct1.&quot;Code&quot;
// )
// SELECT a.&quot;Code&quot; as1, a.&quot;Name&quot; as2, a.&quot;ParentCode&quot; as5, a.cte_level as6, a.cte_path as7 
// FROM &quot;as_tree_cte&quot; a 
// ORDER BY a.&quot;Code&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;更多姿势...请根据代码注释进行尝试&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;给 .NET 开源社区贡献一点力时，希望作者的努力能打动到你，请求正在使用的、善良的您能动一动小手指，把文章转发一下，让更多人知道 .NET 有这样一个好用的 ORM 存在。谢谢了！！&lt;/p&gt;
&lt;p&gt;FreeSql 使用最宽松的开源协议 MIT &lt;a href=&quot;https://github.com/dotnetcore/FreeSql&quot;&gt;https://github.com/dotnetcore/FreeSql&lt;/a&gt;，完全可以商用，文档齐全。QQ群：4336577(已满)、8578575(在线)、52508226(在线)&lt;/p&gt;
&lt;p&gt;如果你有好的 ORM 实现想法，欢迎给作者留言讨论，谢谢观看！&lt;/p&gt;
&lt;p&gt;2.0 版本意见正在登记中：&lt;a href=&quot;https://github.com/dotnetcore/FreeSql/issues/469&quot;&gt;https://github.com/dotnetcore/FreeSql/issues/469&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 21 Oct 2020 19:32:00 +0000</pubDate>
<dc:creator>nicye</dc:creator>
<og:description>写在开头 FreeSql 是 .NET 开源生态下的 ORM 轮子，转眼快两年了，说真的开源不容易（只有经历过才明白）。今天带点干货和湿货给大家，先说下湿货。 认识我的人，知道 CSRedisCore</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kellynic/p/13855784.html</dc:identifier>
</item>
<item>
<title>EFS加密 - chuyaoxin</title>
<link>http://www.cnblogs.com/cyx-b/p/13855707.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cyx-b/p/13855707.html</guid>
<description>&lt;div class=&quot;toc&quot;&gt;
&lt;p&gt;&lt;span&gt;目录&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/cyx-b/p/13855707.html#efs简介&quot;&gt;EFS简介&lt;/a&gt;&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/cyx-b/p/13855707.html#efs的特点&quot;&gt;EFS的特点&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/cyx-b/p/13855707.html#efs的缺陷&quot;&gt;EFS的缺陷&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/cyx-b/p/13855707.html#efs证书&quot;&gt;EFS证书&lt;/a&gt;&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/cyx-b/p/13855707.html#证书的导出&quot;&gt;证书的导出&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/cyx-b/p/13855707.html#证书的安装&quot;&gt;证书的安装&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/cyx-b/p/13855707.html#efs加密&quot;&gt;EFS加密&lt;/a&gt;&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/cyx-b/p/13855707.html#方法一&quot;&gt;方法一&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/cyx-b/p/13855707.html#方法二&quot;&gt;方法二&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;h2 id=&quot;efs简介&quot;&gt;&lt;span&gt;EFS简介&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;EFS（Encrypting File System，加密文件系统）是Windows操作系统中基于NTFS（New Technology File System，新技术文件系统）实现对文件进行加密与解密服务的一项技术。EFS采用核心文件加密技术，当文件或文件夹被加密之后，对于合法Windows用户来说不会改变其使用习惯。当操作经EFS加密后的文件时与操作普通文件没有任何区别，所有的用户身份认证和解密操作由系统在后台自动完成。而对于非法Windows用户来说，则无法打开经EFS加密的文件或文件夹。在多用户Windows操作系统中，不同的用户，可通过EFS加密自己的文件或文件夹，实现对重要数据的安全保护。&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;efs的特点&quot;&gt;&lt;span&gt;EFS的特点&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;EFS技术的特点主要体现在以下几个方面。&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;对于用户来说，EFS技术采用了透明加密操作方式，即所有的加密和解密过程对用户来说是感觉不到的。这是因为EFS运行在操作系统的内核模式下，通过操作文件系统，向整个系统提供实时、透明、动态的数据加密和解密服务。当合法用户操作经EFS加密的数据时，系统将自动进行解密操作。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;由于FEK和用户主密钥的生成都与登录账户的用户名和口令相关，所以用户登录操作系统的同时已经完成了身份验证。在用户访问经EFS技术加密的文件时，用户身份的合法性已经得到验证，无须再次输入其认证信息。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;EFS允许文件的原加密者指派其他的合法用户以数据恢复代理的身份来解密经加密的数据，同一个加密文件可以根据需要由多个合法用户访问。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;EFS技术可以与Windows操作系统的权限管理机制结合，实现对数据的安全管理。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;efs的缺陷&quot;&gt;&lt;span&gt;EFS的缺陷&lt;/span&gt;&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;EFS技术中密钥的生成基于登录账户的用户名和口令，但并不完全依赖于登录账户的用户名和口令，如FEK由用户的SID生成。当重新安装了操作系统后，虽然创建了与之前完全相同的用户名和口令，但此账户非彼账户，导致原来加密的文件无法访问。为解决此问题，EFS提供了密钥导出或备份功能，但此操作仅取决于用户的安全意识。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;由于EFS将所有的密钥都保存在Windows分区中，攻击者可以通过破解登录账户进一步获取所需要的密钥，以解密并得到加密文件。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;EFS技术可以防止非法用户访问受保护的数据，但是具有删除权限的用户可以删除经EFS加密的文件或文件夹，安全性受到威胁。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;efs证书&quot;&gt;&lt;span&gt;EFS证书&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;文件加密后，即使被复制到其他电脑中，如果没有同时复制该文件的EFS证书，也是不能正常访问的&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;证书的导出&quot;&gt;&lt;span&gt;证书的导出&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;使用快捷键win+R，输入CertMgr.msc，点击确定打开证书管理界面&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1776217/202010/1776217-20201022001407370-195232823.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;在出现的“证书”对话框中依次双击展开“证书-当前用户→个人→证书”选项，在右侧栏目里会出现以你的用户名为名称的证书&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1776217/202010/1776217-20201022001912545-197940559.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;接着点击鼠标右键，选择“所有任务→导出”命令，打开“证书导出向导”对话框&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1776217/202010/1776217-20201022002538703-745196936.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;点击下一步&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1776217/202010/1776217-20201022002609215-232815595.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;当出现“是否要将私钥跟证书一起导出”提示时，要选择“是，导出私钥”选项&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1776217/202010/1776217-20201022002845821-279209880.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;选择要导出的文件格式，默认选择个人信息交换—PKCS#12(.PFX)，格式，点击下一步&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1776217/202010/1776217-20201022003003124-987563228.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;输入证书加密的密码，点击下一步&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1776217/202010/1776217-20201022003152812-472562677.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;选择好保存的文件名及文件路径后，点击“完成”按钮即可顺利将证书导出，此时会发现在保存路径上出现一个以PFX为后缀的文件&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1776217/202010/1776217-20201022003327406-602714028.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1776217/202010/1776217-20201022003508350-2066597829.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1776217/202010/1776217-20201022003526406-1170463213.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;证书的安装&quot;&gt;&lt;span&gt;证书的安装&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1776217/202010/1776217-20201022004229079-916670433.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1776217/202010/1776217-20201022004252404-174591573.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1776217/202010/1776217-20201022004337560-143435888.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1776217/202010/1776217-20201022004448301-1469957700.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1776217/202010/1776217-20201022004516762-1423535654.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;efs加密&quot;&gt;&lt;span&gt;EFS加密&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;方法一&quot;&gt;&lt;span&gt;方法一&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;选中要加密的文件夹，右键点击属性&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1776217/202010/1776217-20201022005131885-635139849.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;在属性页面点击高级，勾选加密内容以便保护数据，点击确定&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1776217/202010/1776217-20201022005216316-2111907302.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;回到文件夹属性页面，点击应用，点击确定&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1776217/202010/1776217-20201022005546213-902128995.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;加密完成后，文件夹多了上锁的标识。若需解密，按照上述步骤，取消勾选【加密内容以便保护数据即可】&lt;br/&gt;解密时如果出错，如下图所示：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1776217/202010/1776217-20201022010620549-1593956018.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;首先看在高级设置里面电脑是否没有将存档和索引属性下面的可以存档文件夹（A）子选项勾选上&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1776217/202010/1776217-20201022010910923-1341830963.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;如果勾选上之后还是无法解密在对文件夹进行加密以后鼠标右键会有一个文件所有权的属性，我们将鼠标移动到哪里，选择右边的个人，然后再进行解密就行了&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1776217/202010/1776217-20201022011216724-202502433.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;方法二&quot;&gt;&lt;span&gt;方法二&lt;/span&gt;&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;同时按下Win键+R键，输入regedit回车&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1776217/202010/1776217-20201022005835089-92048983.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;在注册表中定位到&lt;br/&gt;HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\Advanced，空白处右击鼠标，选择新建DWORD（32位）值&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1776217/202010/1776217-20201022010000775-968247823.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;将数值名称重命名为EncryptionContextMenu，修改数值数据为1，确认选择了十六进制（H），点击确定即可&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1776217/202010/1776217-20201022010018923-1718188175.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;在任意文件上右击，即可看到菜单中新增了加密的选项，一键加密&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1776217/202010/1776217-20201022011241619-956384836.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;解密时，鼠标右键点击需解密的文件或文件夹，点击解密即可。如果出错，参照方法一种的解决办法&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Wed, 21 Oct 2020 17:34:00 +0000</pubDate>
<dc:creator>chuyaoxin</dc:creator>
<og:description>EFS简介 EFS（Encrypting File System，加密文件系统）是Windows操作系统中基于NTFS（New Technology File System，新技术文件系统）实现对文件</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cyx-b/p/13855707.html</dc:identifier>
</item>
<item>
<title> IL角度理解C#中字段，属性与方法的区别 - JerryMouseLi</title>
<link>http://www.cnblogs.com/JerryMouseLi/p/13855733.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/JerryMouseLi/p/13855733.html</guid>
<description>&lt;p&gt;字段的本质是变量，直接在类或者结构体中声明。类或者结构体中会有实例字段，静态字段等（静态字段可实现内存共享功能，比如数学上的pi就可以存在静态字段）。一般来说字段应该带有private 或者 protected访问属性。一般来说字段需要通过类中的方法，或者属性来暴露给其他类。通过限制间接访问内部字段，来保护输入数据的安全。&lt;/p&gt;
&lt;p&gt;属性的本质是类的一个成员，它提供了私有字段读，写，计算值的灵活机制。属性如果是数据成员能直接被使用，但本质是特殊方法，我们称之为访问器。它的作用是使得数据访问更容易，数据更安全，方法访问更灵活。属性使得类暴露了get,set公有方法，它隐藏了实现，get属性访问器，用来返回属性值，set属性访问器，用来设置值。综上，属性的本质是一对方法的包装，get,set。&lt;/p&gt;
&lt;p&gt;他们是完全不同的语言元素。字段是类里保存数据的基本单元（变量），属性不能保存。&lt;/p&gt;
&lt;p&gt;需要创建属性来控制私有变量（字段）基于对象的读写访问控制。&lt;/p&gt;
&lt;p&gt;一个字段给其他类访问，只有两种方法，字段的访问属性修改为public，不建议，因为字段是可读可写的，无法阻止用户写某些字段，比如出生日期，只读不可写，使用属性。&lt;/p&gt;
&lt;p&gt;字段不能抛出异常，调用方法，属性可以。&lt;/p&gt;
&lt;p&gt;在属性里， Set 或者 Get 方法由编译器预定义好了。&lt;/p&gt;

&lt;h2 id=&quot;21-c代码&quot;&gt;2.1 C#代码&lt;/h2&gt;
&lt;p&gt;主程序&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    class Program
    {
        static void Main(string[] args)
        {
            Person Tom = new Person();
            
            Tom.SayHello();
            
            Console.WriteLine(&quot;{0}&quot;, Tom.Name);
            
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Person类&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        public class Person
        {
            private string _name;
            public string _firstName;
            public string Name
            {
                get
                {
                   // return _name;
                   return &quot;Hello&quot;;
                }
                set
                {
                    _name = value;
                }
            }
            public int Age{get;private set;} //AutoProperty generates private field for us

            public void SayHello()
            {
                Console.WriteLine(&quot;Hello World!&quot;);
            }
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;22-il代码分析&quot;&gt;2.2 IL代码分析&lt;/h2&gt;
&lt;h3 id=&quot;221-字段的il代码&quot;&gt;2.2.1 字段的IL代码&lt;/h3&gt;
&lt;p&gt;可以看到字段的IL代码的关键字是 field。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  .field private string _name
  .field public string _firstName
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;222-属性的il代码&quot;&gt;2.2.2 属性的IL代码&lt;/h3&gt;
&lt;h4 id=&quot;2221-属性&quot;&gt;2.2.2.1 属性&lt;/h4&gt;
&lt;p&gt;属性的IL关键字即是property。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  .property instance string Name()
  {
    .get instance string FieldPropertyMethod.Person::get_Name()
    .set instance void FieldPropertyMethod.Person::set_Name(string)
  } // end of property Person::Name
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;点到对应的get,set访问器。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  .method public hidebysig specialname instance string
    get_Name() cil managed
  {
    .maxstack 1
    .locals init (
      [0] string V_0
    )

    IL_0000: nop
    IL_0001: ldstr        &quot;Hello&quot;
    IL_0006: stloc.0      // V_0
    IL_0007: br.s         IL_0009
    IL_0009: ldloc.0      // V_0
    IL_000a: ret

  } // end of method Person::get_Name

  .method public hidebysig specialname instance void
    set_Name(
      string 'value'
    ) cil managed
  {
    .maxstack 8

    IL_0000: nop
    IL_0001: ldarg.0      // this
    IL_0002: ldarg.1      // 'value'
    IL_0003: stfld        string FieldPropertyMethod.Person::_name
    IL_0008: ret

  } // end of method Person::set_Name
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上可以看出get,set访问器的本质就是方法(method).由上属性就是对get,set两种方法及其访问特性的封装。由此可见，属性就是对get，set方法的封装。&lt;/p&gt;
&lt;h4 id=&quot;2222-自动生成属性&quot;&gt;2.2.2.2 自动生成属性&lt;/h4&gt;
&lt;p&gt;a. 自动生成属性代码&lt;br/&gt;代码量小，实用，此语法从C#3.0开始定义自动属性&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; public int Age{get;private set;} 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;b. 自动生成属性的IL代码分析&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  .property instance int32 Age()
  {
    .get instance int32 FieldPropertyMethod.Person::get_Age()
    .set instance void FieldPropertyMethod.Person::set_Age(int32)
  } // end of property Person::Age
} // end of class FieldPropertyMethod.Person
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由上可以看出，其IL代码证明也是属性。继续看get，set字段属性方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  .method public hidebysig specialname instance int32
    get_Age() cil managed
  {
    .custom instance void [System.Runtime]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor()
      = (01 00 00 00 )
    .maxstack 8

    IL_0000: ldarg.0      // this
    IL_0001: ldfld        int32 FieldPropertyMethod.Person::'&amp;lt;Age&amp;gt;k__BackingField'
    IL_0006: ret

  } // end of method Person::get_Age

  .method private hidebysig specialname instance void
    set_Age(
      int32 'value'
    ) cil managed
  {
    .custom instance void [System.Runtime]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor()
      = (01 00 00 00 )
    .maxstack 8

    IL_0000: ldarg.0      // this
    IL_0001: ldarg.1      // 'value'
    IL_0002: stfld        int32 FieldPropertyMethod.Person::'&amp;lt;Age&amp;gt;k__BackingField'
    IL_0007: ret

  } // end of method Person::set_Age
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;k__BackingField 即是属性背后的字段变量，这是编译器自动生成的后台字段。由此自动属性与我们自己定义的属性功能一模一样。&lt;/p&gt;
&lt;h3 id=&quot;223-方法的il代码分析&quot;&gt;2.2.3 方法的IL代码分析&lt;/h3&gt;
&lt;p&gt;IL代码中的关键字method即表示方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  .method public hidebysig instance void
    SayHello() cil managed
  {
    .maxstack 8

    IL_0000: nop
    IL_0001: ldstr        &quot;Hello World!&quot;
    IL_0006: call         void [System.Console]System.Console::WriteLine(string)
    IL_000b: nop
    IL_000c: ret

  } // end of method Person::SayHello
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;备注：本IL代码由rider的IL View功能产生&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;31-设置只读属性&quot;&gt;3.1 设置只读属性&lt;/h2&gt;
&lt;p&gt;像出生年月这种只读不能写的属性，易用属性。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public datetime birthday{get;private set;} 
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;32-调用方法&quot;&gt;3.2 调用方法&lt;/h2&gt;
&lt;p&gt;在属性Count中调用CalculateNoOfRows方法；&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Rows
{       
    private string _count;        


    public int Count
    {
        get
        {
           return CalculateNoOfRows();
        }  
    } 

    public int CalculateNoOfRows()
    {
         // Calculation here and finally set the value to _count
         return _count;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;33-赖加载&quot;&gt;3.3 赖加载&lt;/h2&gt;
&lt;p&gt;有些数据加载的功能可以放在属性中加载，不放在构造函数中，以此来加快对象创建的速度。&lt;/p&gt;
&lt;h2 id=&quot;34-接口继承&quot;&gt;3.4 接口继承&lt;/h2&gt;
&lt;p&gt;可以对接口里的属性进行继承，而字段不行；&lt;/p&gt;
&lt;h2 id=&quot;35-属性做个简单的校验&quot;&gt;3.5 属性做个简单的校验&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;class Name
{
    private string MFullName=&quot;&quot;;
    private int MYearOfBirth;

    public string FullName
    {
        get
        {
            return(MFullName);
        }
        set
        {
            if (value==null)
            {
                throw(new InvalidOperationException(&quot;Error !&quot;));
            }

            MFullName=value;
        }
    }

    public int YearOfBirth
    {
        get
        {
            return(MYearOfBirth);
        }
        set
        {
            if (MYearOfBirth&amp;lt;1900 || MYearOfBirth&amp;gt;DateTime.Now.Year)
            {
                throw(new InvalidOperationException(&quot;Error !&quot;));
            }

            MYearOfBirth=value;
        }
    }

    public int Age
    {
        get
        {
            return(DateTime.Now.Year-MYearOfBirth);
        }
    }

    public string FullNameInUppercase
    {
        get
        {
            return(MFullName.ToUpper());
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例子而已，ddd中一般来说值对象来定义，校验也同样会放在值对象中。&lt;/p&gt;
&lt;h2 id=&quot;36-属性中调用事件&quot;&gt;3.6 属性中调用事件&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;public class Person {
 private string _name;

 public event EventHandler NameChanging;     
 public event EventHandler NameChanged;

 public string Name{
  get
  {
     return _name;
  }
  set
  {
     OnNameChanging();
     _name = value;
     OnNameChanged();
  }
 }

 private void OnNameChanging(){       
     NameChanging?.Invoke(this,EventArgs.Empty);       
 }

 private void OnNameChanged(){
     NameChanged?.Invoke(this,EventArgs.Empty);
 }
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;字段作为属性的存储基元功用之外，还有没有应用场景是性能超越属性的呢？答案是肯定的，字段作为ref/out参数时，性能更优异，&lt;br/&gt;下面举一例。&lt;/p&gt;
&lt;h2 id=&quot;41-属性赋值代码&quot;&gt;4.1 属性赋值代码&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;    class Program
    {
        static void Main(string[] args)
        {
            #region 属性性能测试
         Point[] points = new Point[1000000];
         Initializ(points);
        var bigRunTime = DateTime.Now;
        for (int i = 0; i &amp;lt; points.Length; i++)
        {
            int x = points[i].X;
            int y = points[i].Y;
            TransformPoint(ref x, ref y);
            points[i].X = x;
            points[i].Y = y;
        }
        var endRunTime = DateTime.Now;
        var timeSpend=ExecDateDiff(bigRunTime,endRunTime);
        Console.WriteLine(&quot;变换后首元素坐标：{0},{1}&quot;,points[0].X,points[0].Y);
        
        Console.WriteLine(&quot;程序执行花费时间：{0}&quot;,timeSpend);
           #endregion
           
        }

        /// 程序执行时间测试
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;dateBegin&quot;&amp;gt;开始时间&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;dateEnd&quot;&amp;gt;结束时间&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;返回(秒)单位，比如: 0.00239秒&amp;lt;/returns&amp;gt;
        public static string ExecDateDiff(DateTime dateBegin, DateTime dateEnd)
        {
            TimeSpan ts1 = new TimeSpan(dateBegin.Ticks);
            TimeSpan ts2 = new TimeSpan(dateEnd.Ticks);
            TimeSpan ts3 = ts1.Subtract(ts2).Duration();
            //你想转的格式
             return ts3.TotalMilliseconds.ToString();
        }
        static Point[] Initializ(Point[] points)
        {
            
            for (int i = 0; i &amp;lt; points.Length; i++)
           {
              points[i] =new Point();
              points[i].X = 1;
              points[i].Y = 2;
           }

           Console.WriteLine(&quot;首元素坐标：{0},{1}&quot;,points[0].X,points[0].Y);
            return points;
        }
        
        static void TransformPoint(ref int x, ref int y)
        {
            x = 3;
            y = 4;
        }

    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;    public class Point
    {
        public  int X {  get;  set; } 
        public  int Y { get; set; } 
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里属性为什么不能直接绑定ref参数呢？rider的智能提示给我们做了解答&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1606616/202010/1606616-20201022003101299-1640836015.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;翻译过来的意思是属性返回的是临时变量，ref需要绑定特定的变量，如字段，数组元素等。&lt;br/&gt;属性拷贝需要的时间：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1606616/202010/1606616-20201022003110196-1475033567.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;花费时间大约是31ms。&lt;/p&gt;
&lt;h2 id=&quot;42-字段赋值&quot;&gt;4.2 字段赋值&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;    class Program
    {
        static void Main(string[] args)
        {
           
           #region 字段性能测试
           PointField[] points = new PointField[1000000];
           InitializField(points);
           var bigRunTime = DateTime.Now;
           for (int i = 0; i &amp;lt; points.Length; i++)
           {
               TransformPoint(ref points[i].X, ref points[i].Y);
           }
           var endRunTime = DateTime.Now;
           var timeSpend=ExecDateDiff(bigRunTime,endRunTime);
           Console.WriteLine(&quot;变换后首元素坐标：{0},{1}&quot;,points[0].X,points[0].Y);
           
           Console.WriteLine(&quot;字段赋值执行花费时间：{0}&quot;,timeSpend);
           #endregion
        }

        /// 程序执行时间测试
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;dateBegin&quot;&amp;gt;开始时间&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;dateEnd&quot;&amp;gt;结束时间&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;返回(秒)单位，比如: 0.00239秒&amp;lt;/returns&amp;gt;
        public static string ExecDateDiff(DateTime dateBegin, DateTime dateEnd)
        {
            TimeSpan ts1 = new TimeSpan(dateBegin.Ticks);
            TimeSpan ts2 = new TimeSpan(dateEnd.Ticks);
            TimeSpan ts3 = ts1.Subtract(ts2).Duration();
            //你想转的格式
             return ts3.TotalMilliseconds.ToString();
        }

        
        static PointField[] InitializField(PointField[] points)
        {
            
            for (int i = 0; i &amp;lt; points.Length; i++)
            {
                points[i] =new PointField();
                points[i].X = 1;
                points[i].Y = 2;
            }

            Console.WriteLine(&quot;首元素坐标：{0},{1}&quot;,points[0].X,points[0].Y);
            return points;
        }

        

        static void TransformPoint(ref int x, ref int y)
        {
            x = 3;
            y = 4;
        }

    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;    public class PointField
    {
        public int X;
        public int Y;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1606616/202010/1606616-20201022003011524-1259014545.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;综上，使用字段的性能比使用属性性能提升了38.7%（31-19/31=38.7%），很可观。&lt;br/&gt;究其原因，属性开辟了临时变量作为中转进行了深拷贝，而字段则是直接对地址（指针）进行解引用，直接赋值。&lt;br/&gt;出赋值速度提升外，字段不需开辟临时内存，更加节省内存。&lt;/p&gt;

&lt;p&gt;在vs中prop 按tab键可自动生成属性&lt;/p&gt;

&lt;p&gt;写在文末，也算是本文的彩蛋。该方法的形参通过关键字ref将变量设置成了引用。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        static void TransformPoint(ref int x, ref int y)
        {
            x = 3;
            y = 4;
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;引用ref的IL代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  .method private hidebysig static void
    TransformPoint(
      int32&amp;amp; x,
      int32&amp;amp; y
    ) cil managed
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对没错，你看到了&amp;amp;，熟悉C语言的道友知道，在这里是取了传入整形变量的地址。所以在方法里进行解引用赋值，就能改变形参的值，&lt;br/&gt;本质就是通过指针（传入变量的地址）来对形参值的修改。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/JerryMouseLi/RefField&quot;&gt;gitHub代码地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;参考文章：&lt;br/&gt;&lt;a href=&quot;https://stackoverflow.com/questions/295104/what-is-the-difference-between-a-field-and-a-property?page=1&amp;amp;tab=votes#tab-top&quot;&gt;What is the difference between a field and a property?&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;
版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://www.cnblogs.com/JerryMouseLi/p/13855733.html</description>
<pubDate>Wed, 21 Oct 2020 16:34:00 +0000</pubDate>
<dc:creator>JerryMouseLi</dc:creator>
<og:description>IL角度理解C#中字段，属性与方法的区别 1.字段，属性与方法的区别 字段的本质是变量，直接在类或者结构体中声明。类或者结构体中会有实例字段，静态字段等（静态字段可实现内存共享功能，比如数学上的pi就</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/JerryMouseLi/p/13855733.html</dc:identifier>
</item>
<item>
<title>【线上排查实战】AOP切面执行顺序你真的了解吗 - 后端技术漫谈</title>
<link>http://www.cnblogs.com/rude3knife/p/13855548.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rude3knife/p/13855548.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;忙，是我这个月的主旋律，也是我频繁鸽文章的接口————蛮三刀把刀&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;公司这两个月启动了全新的项目，项目排期满满当当，不过该学习还是要学习。这不，给公司搭项目的时候，踩到了一个Spring AOP的坑。&lt;/p&gt;
&lt;p&gt;本文内容重点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;问题描述&lt;/li&gt;
&lt;li&gt;Spring AOP执行顺序&lt;/li&gt;
&lt;li&gt;探究顺序错误的真相&lt;/li&gt;
&lt;li&gt;代码验证&lt;/li&gt;
&lt;li&gt;结论&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;本文阅读大概需要：3分钟&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;码字不易，求个关注，欢迎关注我的个人原创公众号：后端技术漫谈（二维码见文章底部）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;公司新项目需要搭建一个新的前后分离HTTP服务，我选择了目前比较熟悉的SpringBoot Web来快速搭建一个可用的系统。&lt;/p&gt;
&lt;p&gt;鲁迅说过，&lt;strong&gt;不要随便升级已经稳定使用的版本&lt;/strong&gt;。我偏不信这个邪，仗着自己用了这么久Spring，怎么能不冲呢。不说了，直接引入了最新的SprinBoot 2.3.4.RELEASE版本，开始给项目搭架子。&lt;/p&gt;
&lt;p&gt;起初，大多数的组件引入都一切顺利，本以为就要大功告成了，没想到在搭建&lt;strong&gt;日志切面&lt;/strong&gt;时栽了跟头。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;作为一个接口服务，为了方便查询接口调用情况和定位问题，一般都会将请求日志打印出来，而Spring的AOP作为切面支持，完美的切合了日志记录的需求。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;之前的项目中，运行正确的切面日志记录效果如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/qqxx6661/markdown-pic/raw/master/2020-10-16/1602777844392-image.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到图内的一次方法调用，会输出请求url，出入参，以及请求IP等等，之前为了好看，还加入了分割线。&lt;/p&gt;
&lt;p&gt;我把这个实现类放入新项目中，执行出来却是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/qqxx6661/markdown-pic/raw/master/2020-10-16/1602777853908-image.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我揉了揉眼睛，仔细看了看复制过来的老代码，精简版如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 在切点之前织入
 * @param joinPoint
 * @throws Throwable
 */
@Before(&quot;webLog()&quot;)
public void doBefore(JoinPoint joinPoint) throws Throwable {
    // 开始打印请求日志
    ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
    HttpServletRequest request = attributes.getRequest();

    // 初始化traceId
    initTraceId(request);

    // 打印请求相关参数
    LOGGER.info(&quot;========================================== Start ==========================================&quot;);
    // 打印请求 url
    LOGGER.info(&quot;URL            : {}&quot;, request.getRequestURL().toString());
    // 打印 Http method
    LOGGER.info(&quot;HTTP Method    : {}&quot;, request.getMethod());
    // 打印调用 controller 的全路径以及执行方法
    LOGGER.info(&quot;Class Method   : {}.{}&quot;, joinPoint.getSignature().getDeclaringTypeName(), joinPoint.getSignature().getName());
    // 打印请求的 IP
    LOGGER.info(&quot;IP             : {}&quot;, IPAddressUtil.getIpAdrress(request));
    // 打印请求入参
    LOGGER.info(&quot;Request Args   : {}&quot;, joinPoint.getArgs());
}

/**
 * 在切点之后织入
 * @throws Throwable
 */
@After(&quot;webLog()&quot;)
public void doAfter() throws Throwable {
    LOGGER.info(&quot;=========================================== End ===========================================&quot;);
}

/**
 * 环绕
 * @param proceedingJoinPoint
 * @return
 * @throws Throwable
 */
@Around(&quot;webLog()&quot;)
public Object doAround(ProceedingJoinPoint proceedingJoinPoint) throws Throwable {
    long startTime = System.currentTimeMillis();
    Object result = proceedingJoinPoint.proceed();
    // 打印出参
    LOGGER.info(&quot;Response Args  : {}&quot;, result);
    // 执行耗时
    LOGGER.info(&quot;Time-Consuming : {} ms&quot;, System.currentTimeMillis() - startTime);
    return result;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码感觉完全没有问题，难道新版本的SpringBoot出Bug了。&lt;/p&gt;
&lt;p&gt;显然，成熟的框架不会在这种大方向上犯错误，那会不会是新版本的SpringBoot把@After和@Around的顺序反过来了？&lt;/p&gt;
&lt;p&gt;其实事情也没有那么简单。&lt;/p&gt;

&lt;p&gt;我们先来回顾下Spring AOP执行顺序。&lt;/p&gt;
&lt;p&gt;我们在网上查找关于SpringAop执行顺序的的资料，大多数时候，你会查到如下的答案：&lt;/p&gt;
&lt;h2 id=&quot;正常情况&quot;&gt;正常情况&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/qqxx6661/markdown-pic/raw/master/2020-10-16/1602777864590-image.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;异常情况&quot;&gt;异常情况&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/qqxx6661/markdown-pic/raw/master/2020-10-16/1602777870756-image.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;多个切面的情况&quot;&gt;多个切面的情况&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/qqxx6661/markdown-pic/raw/master/2020-10-16/1602777876850-image.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以@Around理应在@After之前，但是在SprinBoot 2.3.4.RELEASE版本中，@Around切切实实执行在了@After之后。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当我尝试切换回2.2.5.RELEASE版本后，执行顺序又回到了@Around--&amp;gt;@After&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;既然知道了是SpringBoot版本升级导致的问题（或者说顺序变化），那么就要来看看究竟是哪个库对AOP执行的顺序进行了变动，毕竟，SpringBoot只是“形”，真正的内核在Spring。&lt;/p&gt;
&lt;p&gt;我们打开pom.xml文件，使用插件查看spring-aop的版本，发现SpringBoot 2.3.4.RELEASE 版本使用的AOP是spring-aop-5.2.9.RELEASE。&lt;/p&gt;
&lt;p&gt;而2.2.5.RELEASE对应的是spring-aop-5.2.4.RELEASE&lt;/p&gt;
&lt;p&gt;于是我去官网搜索文档，不得不说Spring由于过于庞大，官网的文档已经到了冗杂的地步，不过最终还是找到了：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.spring.io/spring-framework/docs/5.2.9.RELEASE/spring-framework-reference/core.html#aop-ataspectj-advice-ordering&quot;&gt;https://docs.spring.io/spring-framework/docs/5.2.9.RELEASE/spring-framework-reference/core.html#aop-ataspectj-advice-ordering&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/qqxx6661/markdown-pic/raw/master/2020-10-16/1602777930052-image.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;As of Spring Framework 5.2.7, advice methods defined in the same @Aspect class that need to run at the same join point are assigned precedence based on their advice type in the following order, from highest to lowest precedence: @Around, @Before, @After, @AfterReturning, @AfterThrowing.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我粗浅的翻译一下重点：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;从Spring5.2.7开始，在相同@Aspect类中，通知方法将根据其类型按照从高到低的优先级进行执行：@Around，@Before ，@After，@AfterReturning，@AfterThrowing。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这样看其实对比不明显，我们再回到老版本，也就是2.2.5.RELEASE对应的spring-aop-5.2.4.RELEASE，当时的文档是这么写的：&lt;/p&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;What happens when multiple pieces of advice all want to run at the same join point? Spring AOP follows the same precedence rules as AspectJ to determine the order of advice execution. The highest precedence advice runs first &quot;on the way in&quot; (so, given two pieces of before advice, the one with highest precedence runs first). &quot;On the way out&quot; from a join point, the highest precedence advice runs last (so, given two pieces of after advice, the one with the highest precedence will run second).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;简单翻译：在相同@Aspect类中Spring AOP遵循与AspectJ相同的优先级规则来确定advice执行的顺序。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;再挖深一点，那么AspectJ的优先级规则是什么样的？&lt;/p&gt;
&lt;p&gt;我找了AspectJ的文档：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.eclipse.org/aspectj/doc/next/progguide/semantics-advice.html&quot;&gt;https://www.eclipse.org/aspectj/doc/next/progguide/semantics-advice.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/qqxx6661/markdown-pic/raw/master/2020-10-16/1602777941209-image.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;37&quot;&gt;
&lt;p&gt;At a particular join point, advice is ordered by precedence.&lt;/p&gt;
&lt;p&gt;A piece of around advice controls whether advice of lower precedence will run by calling proceed. The call to proceed will run the advice with next precedence, or the computation under the join point if there is no further advice.&lt;/p&gt;
&lt;p&gt;A piece of before advice can prevent advice of lower precedence from running by throwing an exception. If it returns normally, however, then the advice of the next precedence, or the computation under the join pint if there is no further advice, will run.&lt;/p&gt;
&lt;p&gt;Running after returning advice will run the advice of next precedence, or the computation under the join point if there is no further advice. Then, if that computation returned normally, the body of the advice will run.&lt;/p&gt;
&lt;p&gt;Running after throwing advice will run the advice of next precedence, or the computation under the join point if there is no further advice. Then, if that computation threw an exception of an appropriate type, the body of the advice will run.&lt;/p&gt;
&lt;p&gt;Running after advice will run the advice of next precedence, or the computation under the join point if there is no further advice. Then the body of the advice will run.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;大伙又要说了，哎呀太长不看！简短地说，Aspectj的规则就是上面我们能够在网上查阅到的顺序图展示的那样，依旧是老的顺序。&lt;/p&gt;

&lt;p&gt;我把业务逻辑从代码中删除，只验证下这几个advice的执行顺序：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.bj58.xfbusiness.cloudstore.system.aop;

import com.bj58.xfbusiness.cloudstore.utils.IPAddressUtil;
import com.bj58.xfbusiness.cloudstore.utils.TraceIdUtil;
import org.apache.commons.lang3.StringUtils;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;

import javax.servlet.http.HttpServletRequest;

/**
 * 日志切面
 */
@Aspect
@Component
public class WebLogAspect {

    private final static Logger LOGGER = LoggerFactory.getLogger(WebLogAspect.class);

    /** 以 controller 包下定义的所有请求为切入点 */
    @Pointcut(&quot;execution(public * com.xx.xxx.xxx.controller..*.*(..))&quot;)
    public void webLog() {}

    /**
     * 在切点之前织入
     * @param joinPoint
     * @throws Throwable
     */
    @Before(&quot;webLog()&quot;)
    public void doBefore(JoinPoint joinPoint) throws Throwable {
        LOGGER.info(&quot;-------------doBefore-------------&quot;);
    }

    @AfterReturning(&quot;webLog()&quot;)
    public void afterReturning() {
        LOGGER.info(&quot;-------------afterReturning-------------&quot;);
    }
    @AfterThrowing(&quot;webLog()&quot;)
    public void afterThrowing() {
        LOGGER.info(&quot;-------------afterThrowing-------------&quot;);
    }

    /**
     * 在切点之后织入
     * @throws Throwable
     */
    @After(&quot;webLog()&quot;)
    public void doAfter() throws Throwable {
        LOGGER.info(&quot;-------------doAfter-------------&quot;);
    }

    /**
     * 环绕
     * @param proceedingJoinPoint
     * @return
     * @throws Throwable
     */
    @Around(&quot;webLog()&quot;)
    public Object doAround(ProceedingJoinPoint proceedingJoinPoint) throws Throwable {
        long startTime = System.currentTimeMillis();
        LOGGER.info(&quot;-------------doAround before proceed-------------&quot;);
        Object result = proceedingJoinPoint.proceed();
        LOGGER.info(&quot;-------------doAround after proceed-------------&quot;);
        return result;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们将版本改为2.2.5.RELEASE，结果如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/qqxx6661/markdown-pic/raw/master/2020-10-16/1602777908003-image.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们将版本改为2.3.4.RELEASE，结果如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/qqxx6661/markdown-pic/raw/master/2020-10-16/1602777899090-image.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;经过上面的资料文档查阅，&lt;strong&gt;我能给出的结论是&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;从Spring5.2.7开始，Spring AOP不再严格按照AspectJ定义的规则来执行advice，而是根据其类型按照从高到低的优先级进行执行：@Around，@Before ，@After，@AfterReturning，@AfterThrowing。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这次的研究思考十分仓促，如果结论有误请大家踊跃指正，也欢迎大家自己尝试，毕竟口说无凭，实验室检验真理的唯一标准！&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/dennyLee2025/p/13724981.html&quot;&gt;https://www.cnblogs.com/dennyLee2025/p/13724981.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000011283029&quot;&gt;https://segmentfault.com/a/1190000011283029&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;关注我&quot;&gt;关注我&lt;/h2&gt;
&lt;p&gt;我是一名后端开发工程师。主要关注后端开发，数据安全，边缘计算等方向，欢迎交流。&lt;/p&gt;
&lt;h3 id=&quot;各大平台都可以找到我&quot;&gt;各大平台都可以找到我&lt;/h3&gt;
&lt;h3 id=&quot;原创文章主要内容&quot;&gt;原创文章主要内容&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;后端开发实战&lt;/li&gt;
&lt;li&gt;Java面试知识&lt;/li&gt;
&lt;li&gt;设计模式/数据结构/算法题解&lt;/li&gt;
&lt;li&gt;读书笔记/逸闻趣事/程序人生&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;个人公众号：后端技术漫谈&quot;&gt;个人公众号：后端技术漫谈&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/8de6a3d3gy1genhmip8aqg20go0gojz5.gif&quot; alt=&quot;个人公众号：后端技术漫谈&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果文章对你有帮助，不妨点赞，收藏起来~&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 21 Oct 2020 15:25:00 +0000</pubDate>
<dc:creator>后端技术漫谈</dc:creator>
<og:description>前言 忙，是我这个月的主旋律，也是我频繁鸽文章的接口————蛮三刀把刀 公司这两个月启动了全新的项目，项目排期满满当当，不过该学习还是要学习。这不，给公司搭项目的时候，踩到了一个Spring AOP的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/rude3knife/p/13855548.html</dc:identifier>
</item>
<item>
<title>APP打开（一）—以亲身经历谈APP注册登录 - 花开可缓归</title>
<link>http://www.cnblogs.com/zshcnblogs/p/13855504.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zshcnblogs/p/13855504.html</guid>
<description>&lt;p&gt;&lt;span&gt;如果不是自己接手过这样的产品，我可能也很难相信，会有公司能够做出十四个注册页面的&lt;/span&gt;APP&lt;span&gt;，将选站点、输账号、输密码、用户协议、用户权限等全部拆解成一个一个单独的页面来做，用户在注册的时候仿佛在攀登一座云雾缭绕的大山，看不到山顶，不知道自己还要爬多久才能够抵达终点，即使已经攀爬了百分之九十，用户的心中也不是达到胜利的喜悦，而是不知道何时到达终点的迷茫、无奈和怒气。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;这么长的注册页面对于公司的推广来说简直就是一场灾难，如果给每个环节都进行埋点，那么一定能够发现，用户在每一个环节都在不断的流失，最终能够爬上&lt;/span&gt;“注册成功”这座大山的人寥寥无几。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;先上一个图，看一下十四个页面的注册流程都存在哪些问题（仅标识页面元素，未细化）：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/2135113/202010/2135113-20201021231205673-1929627124.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;全局图在这上面看的可能不是很清晰，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;我们可以挨个页面看一下存在的问题。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;①必要的权限可以要，不必要的权限等要用的时候再要（&lt;span&gt;01/02/03&lt;/span&gt;&lt;span&gt;页面）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一打开就开始要权限。这就相当于相亲的时候我连你叫什么都还不知道，你一上来就开始问我有几套房几辆车一样，不仅问，还问了三次，想想就很糟心。必须要向用户索要的权限也要让用户对&lt;/span&gt;APP&lt;span&gt;有一个简单了解之后了再要，注意用户体验。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/2135113/202010/2135113-20201021231238652-1373301089.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;②需要声明的提前声明，不要多弹个框让用户多点一下（&lt;span&gt;07&lt;/span&gt;&lt;span&gt;页面）。能简则简原则。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/2135113/202010/2135113-20201021231252073-1846282822.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;③用户协议、隐私条款的声明要靠前，一般在第一步，这样用户一进来就能看到一个基本情况，可以加深信任（&lt;span&gt;08&lt;/span&gt;&lt;span&gt;页面）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/2135113/202010/2135113-20201021231303217-1420383056.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;④流程要连贯，形成闭环（&lt;span&gt;12&lt;/span&gt;&lt;span&gt;页面），激活成功之后，页面应该提供入口使用户能够直接通过点击进入&lt;/span&gt;&lt;span&gt;APP&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/2135113/202010/2135113-20201021231313141-1927602290.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;⑤不必要的流程一定不要有（&lt;span&gt;13&lt;/span&gt;&lt;span&gt;页面）。注册成功之后，直接跳转到&lt;/span&gt;&lt;span&gt;APP&lt;/span&gt;&lt;span&gt;首页，不需要再让用户走一遍登录流程，画蛇添足用处不大。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/2135113/202010/2135113-20201021231323436-1263023747.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;毫无疑问，用这样的流程去进行推广，只能惨淡收场，在我第一次试用这个流程之后，就想对其进行整改，虽然中间遭受了一些阻碍，但我还是拿出了方案并坚持按照新方案来做一定能够大幅提升我们的打开注册率。中间公司也使用原方案陆陆续续进行了几次试推，都是惨淡收场。接下来说一下我是怎么样做打开注册登录这一块的优化方案的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;首先，&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;我们的&lt;/span&gt;APP&lt;span&gt;应用于海外，原版本使用的是邮箱注册登录，所以需要进行邮箱激活，但国内实际上已经有微信&lt;/span&gt;&lt;span&gt;/QQ&lt;/span&gt;&lt;span&gt;等一键登录的模式了，那么海外也应该有才对，经过了解，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;当地情况&lt;/span&gt;95%&lt;span&gt;以上的用户都有谷歌账户，于是最终决定采用谷歌登录的方式来进行注册登录。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;其次，&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;根据以上分析的流程上的一些缺陷和海外调研的一些实际情况进行整改，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;将流程最优最简&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，最终三步到首页。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/2135113/202010/2135113-20201021231344823-1410442248.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;那么，把注册流程从十四个页面做到三个是什么体验？感受如下：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;① 方案设计方面：&lt;/strong&gt;&lt;span&gt;想要做好产品，就要做好市场调研和竞品分析，即使是做一个注册登录，也要贴合实际，选择最佳方案。在上面的优化方案上线之后，打开注册率提升&lt;/span&gt;20+%&lt;span&gt;，获客成本降低￥&lt;/span&gt;&lt;span&gt;20+&lt;/span&gt;&lt;span&gt;，效果还是非常可观的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;② 产品设计方面：&lt;/strong&gt;&lt;span&gt;操作要简单，步骤要少，不要麻烦用户；有始有终有闭环。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;③产品工作方面：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Ⅰ 要敢于挑战“权威”。我所说的权威就是当时接手的公版内容，接手时我还是一个产品新人，因此要对公版进行改变经历了一个漫长的“内部斗争”，最终才开动。&lt;/p&gt;
&lt;p&gt;Ⅱ 尽量不要因为时间原因临时妥协，否则可能会浪费更长的时间。因为谷歌注册登录上线至少需要一个月的时间，所以在最终版本之前妥协上线了一个折中的临时方案，数据并没有多少提升，还花了时间和精力，实在是不值当。&lt;/p&gt;
&lt;p&gt;Ⅲ 产品经理在出方案做设计的时候一定要沉淀，要考虑清楚，不要一有想法就拍脑门去做。&lt;/p&gt;
&lt;p&gt;Ⅳ 目标要清晰，行动要迅速，头脑要清楚。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;写在最后：产品经理要有自己的思考和坚持，在有充足的背调和分析的情况下，据理力争不轻易妥协，努力做出为公司创造最大效益、为用户创造最大价值的好产品。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 21 Oct 2020 15:21:00 +0000</pubDate>
<dc:creator>花开可缓归</dc:creator>
<og:description>如果不是自己接手过这样的产品，我可能也很难相信，会有公司能够做出十四个注册页面的APP，将选站点、输账号、输密码、用户协议、用户权限等全部拆解成一个一个单独的页面来做，用户在注册的时候仿佛在攀登一座云</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zshcnblogs/p/13855504.html</dc:identifier>
</item>
</channel>
</rss>