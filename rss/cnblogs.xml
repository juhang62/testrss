<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>上周热点回顾（1.6-1.12） - 博客园团队</title>
<link>http://www.cnblogs.com/cmt/p/12185600.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cmt/p/12185600.html</guid>
<description>[unable to retrieve full-text content]热点随笔： · 我&quot;2019&quot; 年跳槽3次的悲惨故事 (张子浩)· 《吐血整理》顶级大佬学习方法 (敖丙)· 开箱即用~基于.NET Core的统一应用逻辑分层框架设计[含源码] (张飞洪[厦门])· 微服务统计，分析，图表，监控一体化的HttpReports项目在.Net Core 中的使用 (S</description>
<pubDate>Mon, 13 Jan 2020 00:51:00 +0000</pubDate>
<dc:creator>博客园团队</dc:creator>
<og:description>热点随笔： &amp;#183;&amp;#160;我&amp;quot;2019&amp;quot; 年跳槽3次的悲惨故事&amp;#160;(张子浩)&amp;#183;&amp;#160;《吐血整理》顶级大佬学习方法&amp;#160;(敖丙)&amp;#183;&amp;</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cmt/p/12185600.html</dc:identifier>
</item>
<item>
<title>[ASP.NET Core 3框架揭秘] Options[3]: Options模型[上篇] - Artech</title>
<link>http://www.cnblogs.com/artech/p/inside-asp-net-core-06-03.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/artech/p/inside-asp-net-core-06-03.html</guid>
<description>&lt;p&gt;通过前面演示的几个实例（&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-06-01.html&quot;&gt;配置选项的正确使用方式[上篇]&lt;/a&gt;、&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-06-02.html&quot;&gt;配置选项的正确使用方式[下篇]&lt;/a&gt;），我们已经对基于Options的编程方式有了一定程度的了解，下面从设计的角度介绍Options模型。我们演示的实例已经涉及Options模型的3个重要的接口，它们分别是IOptions&amp;lt;TOptions&amp;gt;和&lt;span&gt;IOptionsSnapshot&amp;lt;TOptions&amp;gt;，&lt;/span&gt;最终的Options对象正是利用它们来提供的。在Options模型中，这两个接口具有同一个实现类型&lt;span&gt;OptionsManager&amp;lt;TOptions&amp;gt;&lt;/span&gt;。Options模型的核心接口和类型定义在NuGet包“Microsoft.Extensions.Options”中。&lt;/p&gt;

&lt;p&gt;在Options模式的编程中，我们会利用作为依赖注入容器的IServiceProvider对象来提供IOptions&amp;lt;TOptions&amp;gt;服务或者IOptionsSnapshot&amp;lt;TOptions&amp;gt;服务，实际上，最终得到的服务实例都是一个OptionsManager&amp;lt;TOptions&amp;gt;对象。在Options模型中，OptionsManager&amp;lt;TOptions&amp;gt;相关的接口和类型主要体现在下图中。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/202001/19327-20200113085058655-139143205.png&quot;&gt;&lt;img width=&quot;348&quot; height=&quot;212&quot; title=&quot;7-7&quot; alt=&quot;7-7&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/202001/19327-20200113085059222-2122441666.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下面以上图为基础介绍OptionsManager&amp;lt;TOptions&amp;gt;对象是如何提供Options对象的。如下面的代码片段所示，IOptions&amp;lt;TOptions&amp;gt;接口和IOptionsSnapshot&amp;lt;TOptions&amp;gt;接口的泛型参数的TOptions类型要求具有一个默认的构造函数，也就是说，Options对象可以在无须指定参数的情况下直接采用new关键字进行实例化，实际上，Options最初就是采用这种方式创建的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; IOptions&amp;lt;&lt;span&gt;out&lt;/span&gt; TOptions&amp;gt; &lt;span&gt;where&lt;/span&gt; TOptions: &lt;span&gt;class&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt;()
{
    TOptions Value { &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; IOptionsSnapshot&amp;lt;&lt;span&gt;out&lt;/span&gt; TOptions&amp;gt; : IOptions&amp;lt;TOptions&amp;gt;  &lt;span&gt;where&lt;/span&gt; TOptions: &lt;span&gt;class&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt;()
{
    TOptions Get(&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt; name);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;IOptions&amp;lt;TOptions&amp;gt;接口通过Value属性提供对应的Options对象，继承它的IOptionsSnapshot&amp;lt;TOptions&amp;gt;接口则利用其Get方法根据指定的名称提供对应的Options对象。OptionsManager&amp;lt;TOptions&amp;gt;针对这两个接口成员的实现依赖其他两个对象，分别通过IOptionsFactory&amp;lt;TOptions&amp;gt;接口和IOptionsMonitorCache&amp;lt;TOptions&amp;gt;接口表示，这也是Options模型的两个核心成员。&lt;/p&gt;
&lt;p&gt;作为Options对象的工厂，IOptionsFactory&amp;lt;TOptions&amp;gt;对象负责创建Options对象并对其进行初始化。出于性能方面的考虑，由IOptionsFactory&amp;lt;TOptions&amp;gt;工厂创建的Options对象会被缓存起来，针对Options对象的缓存就由IOptionsMonitorCache&amp;lt;TOptions&amp;gt;对象负责。下面会对IOptionsFactory&amp;lt;TOptions&amp;gt;和IOptionsMonitorCache&amp;lt;TOptions&amp;gt;进行单独讲解，在此之前需要先了解OptionsManager&amp;lt;TOptions&amp;gt;类型是如何定义的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; OptionsManager&amp;lt;TOptions&amp;gt;  :IOptions&amp;lt;TOptions&amp;gt;,  IOptionsSnapshot&amp;lt;TOptions&amp;gt; &lt;span&gt;where&lt;/span&gt; TOptions : &lt;span&gt;class&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt;()
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; IOptionsFactory&amp;lt;TOptions&amp;gt;&lt;span&gt; _factory;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; OptionsCache&amp;lt;TOptions&amp;gt;  _cache =  &lt;span&gt;new&lt;/span&gt; OptionsCache&amp;lt;TOptions&amp;gt;&lt;span&gt;();  

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; OptionsManager(IOptionsFactory&amp;lt;TOptions&amp;gt; factory)  =&amp;gt; _factory =&lt;span&gt; factory;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; TOptions Value =&amp;gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.Get(Options.DefaultName);    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; TOptions Get(&lt;span&gt;string&lt;/span&gt; name)  =&amp;gt; _cache.GetOrAdd(name, () =&amp;gt;&lt;span&gt; _factory.Create(name));
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Options
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; DefaultName = &lt;span&gt;string&lt;/span&gt;&lt;span&gt;.Empty;  
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;OptionsManager&amp;lt;TOptions&amp;gt;对象提供Options对象的逻辑基本上体现在上面给出的代码中。在创建一个OptionsManager&amp;lt;TOptions&amp;gt;对象时需要提供一个IOptionsFactory&amp;lt;TOptions&amp;gt;工厂，而它自己还会创建一个&lt;span&gt;OptionsCache&amp;lt;TOptions&amp;gt;&lt;/span&gt;（该类型实现了IOptionsMonitorCache&amp;lt;TOptions&amp;gt;接口）对象来缓存Options对象，也就是说，Options对象实际上是被OptionsManager&amp;lt;TOptions&amp;gt;对象以“&lt;span&gt;独占&lt;/span&gt;”的方式缓存起来的，后续内容还会提到这个设计细节。&lt;/p&gt;
&lt;p&gt;从编程的角度来讲，IOptions&amp;lt;TOptions&amp;gt;接口和IOptionsSnapshot&amp;lt;TOptions&amp;gt;接口分别体现了非具名与具名的Options提供方式，但是对于同时实现这两个接口的OptionsManager&amp;lt;TOptions&amp;gt;来说，提供的Options都是具名的，唯一的不同之处在于以IOptions&amp;lt;TOptions&amp;gt;接口名义提供Options对象时会采用一个&lt;span&gt;空字符串作为名称&lt;/span&gt;。默认Options名称可以通过静态类型Options的只读字段DefaultName来获取。&lt;/p&gt;
&lt;p&gt;OptionsManager&amp;lt;TOptions&amp;gt;针对Options对象的提供（具名或者非具名）最终体现在其实现的Get方法上。由于Options对象缓存在自己创建的OptionsCache&amp;lt;TOptions&amp;gt;对象上，所以它只需要将指定的Options名称作为参数调用其GetOrAdd方法就能获取对应的Options对象。如果Options对象尚未被缓存，它会利用作为参数传入的Func&amp;lt;TOptions&amp;gt;委托对象来创建新的Options对象，从前面给出的代码可以看出，这个委托对象最终会利用IOptionsFactory&amp;lt;TOptions&amp;gt;工厂来创建Options对象。&lt;/p&gt;

&lt;p&gt;顾名思义，IOptionsFactory&amp;lt;TOptions&amp;gt;接口表示创建和初始化Options对象的工厂。如下面的代码片段所示，该接口定义了唯一的Create方法，可以根据指定的名称创建对应的Options对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; IOptionsFactory&amp;lt;TOptions&amp;gt; &lt;span&gt;where&lt;/span&gt; TOptions: &lt;span&gt;class&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt;()
{
    TOptions Create(&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt; name);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;OptionsFactory&amp;lt;TOptions&amp;gt;OptionsFactory&amp;lt;TOptions&amp;gt;是IOptionsFactory&amp;lt;TOptions&amp;gt;接口的默认实现。OptionsFactory&amp;lt;TOptions&amp;gt;对象针对Options对象的创建主要分3个步骤来完成，笔者将这3个步骤称为Options对象相关的“实例化”、“初始化”和“验证”。由于Options类型总是具有一个公共默认的构造函数，所以OptionsFactory&amp;lt;TOptions&amp;gt;的实现只需要利用new关键字调用这个构造函数就可以创建一个空的Options对象。当Options对象被实例化之后，OptionsFactory&amp;lt;TOptions&amp;gt;对象会根据注册的一些服务对其进行初始化。Options模型中针对Options对象初始化的工作由如下3个接口表示的服务负责。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; IConfigureOptions&amp;lt;&lt;span&gt;in&lt;/span&gt; TOptions&amp;gt; &lt;span&gt;where&lt;/span&gt; TOptions: &lt;span&gt;class&lt;/span&gt;&lt;span&gt;
{    
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(TOptions options);
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; IConfigureNamedOptions&amp;lt;&lt;span&gt;in&lt;/span&gt; TOptions&amp;gt; :  IConfigureOptions&amp;lt;TOptions&amp;gt; &lt;span&gt;where&lt;/span&gt; TOptions : &lt;span&gt;class&lt;/span&gt;&lt;span&gt;
{
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; Configure(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; name, TOptions options);
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; IPostConfigureOptions&amp;lt;&lt;span&gt;in&lt;/span&gt; TOptions&amp;gt; &lt;span&gt;where&lt;/span&gt; TOptions : &lt;span&gt;class&lt;/span&gt;&lt;span&gt;
{    
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; PostConfigure(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; name, TOptions options);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述3个接口分别通过定义的Configure方法和PostConfigure方法对指定的Options对象进行初始化，其中，IConfigureNamedOptions&amp;lt;TOptions&amp;gt;和IPostConfigureOptions&amp;lt;TOptions&amp;gt;还指定了Options的名称。由于IConfigureOptions&amp;lt;TOptions&amp;gt;接口的Configure方法没有指定Options的名称，意味着该方法仅仅用来初始化默认的Options对象，而这个默认的Options对象就是以空字符串命名的Options对象。从接口命名就可以看出定义其中的3个方法的执行顺序：定义在IPostConfigureOptions&amp;lt;TOptions&amp;gt;中的PostConfigure方法会在IConfigureOptions&amp;lt;TOptions&amp;gt;和IConfigureNamedOptions&amp;lt;TOptions&amp;gt;的Configure方法之后执行。&lt;/p&gt;
&lt;p&gt;当注册的IConfigureNamedOptions&amp;lt;TOptions&amp;gt;服务和IPostConfigureOptions&amp;lt;TOptions&amp;gt;服务完成了对Options对象的初始化之后，IOptionsFactory&amp;lt;TOptions&amp;gt;对象还应该验证最终得到的Options对象是否有效。针对Options对象有效性的验证由IValidateOptions&amp;lt;TOptions&amp;gt;接口表示的服务对象来完成。如下面的代码片段所示，IValidateOptions&amp;lt;TOptions&amp;gt;接口定义的唯一的方法Validate用来对指定的Options对象（参数options）进行验证，而参数name则代表Options的名称。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; IValidateOptions&amp;lt;TOptions&amp;gt; &lt;span&gt;where&lt;/span&gt; TOptions : &lt;span&gt;class&lt;/span&gt;&lt;span&gt;
{
    ValidateOptionsResult Validate(&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt; name, TOptions options);
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ValidateOptionsResult
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; ValidateOptionsResult Success;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; ValidateOptionsResult Skip;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ValidateOptionsResult Fail(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; failureMessage);

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; Succeeded { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; Skipped { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; Failed { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; FailureMessage { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Options的验证结果由ValidateOptionsResult类型表示。总的来说，针对Options对象的验证会产生3种结果，即&lt;span&gt;成功、失败和忽略&lt;/span&gt;，它们分别通过3个对应的属性来表示（Succeeded、Failed和Skipped）。一个表示验证失败的ValidateOptionsResult对象会通过其FailureMessage属性来描述具体的验证错误。可以调用两个静态只读字段Success和Skip以及静态方法Fail得到或者创建对应的ValidateOptionsResult对象。&lt;/p&gt;
&lt;p&gt;Options模型提供了一个名为OptionsFactory&amp;lt;TOptions&amp;gt;的类型作为IOptionsFactory&amp;lt;TOptions&amp;gt;接口的默认实现。对上述3个接口有了基本了解后，对实现在OptionsFactory&amp;lt;TOptions&amp;gt;类型中用来创建并初始化Options对象的实现逻辑比较容易理解了。下面的代码片段基本体现了OptionsFactory&amp;lt;TOptions&amp;gt;类型的完整定义。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; OptionsFactory&amp;lt;TOptions&amp;gt; :IOptionsFactory&amp;lt;TOptions&amp;gt; &lt;span&gt;where&lt;/span&gt; TOptions : &lt;span&gt;class&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt;()
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; IEnumerable&amp;lt;IConfigureOptions&amp;lt;TOptions&amp;gt;&amp;gt;&lt;span&gt; _setups;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; IEnumerable&amp;lt;IPostConfigureOptions&amp;lt;TOptions&amp;gt;&amp;gt;&lt;span&gt; _postConfigures;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; IEnumerable&amp;lt;IValidateOptions&amp;lt;TOptions&amp;gt;&amp;gt;&lt;span&gt; _validations;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; OptionsFactory(IEnumerable&amp;lt;IConfigureOptions&amp;lt;TOptions&amp;gt;&amp;gt; setups, IEnumerable&amp;lt;IPostConfigureOptions&amp;lt;TOptions&amp;gt;&amp;gt;&lt;span&gt; postConfigures)
        : &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;(setups, postConfigures, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
    { }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; OptionsFactory(IEnumerable&amp;lt;IConfigureOptions&amp;lt;TOptions&amp;gt;&amp;gt; setups, IEnumerable&amp;lt;IPostConfigureOptions&amp;lt;TOptions&amp;gt;&amp;gt; postConfigures, IEnumerable&amp;lt;IValidateOptions&amp;lt;TOptions&amp;gt;&amp;gt;&lt;span&gt; validations)
    {
        _setups &lt;/span&gt;=&lt;span&gt; setups;
        _postConfigures &lt;/span&gt;=&lt;span&gt; postConfigures;
        _validations &lt;/span&gt;=&lt;span&gt; validations;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; TOptions Create(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; name)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;步骤1：实例化&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; options = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TOptions();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;步骤2-1：针对IConfigureNamedOptions&amp;lt;TOptions&amp;gt;的初始化&lt;/span&gt;
        &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; setup &lt;span&gt;in&lt;/span&gt;&lt;span&gt; _setups)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (setup &lt;span&gt;is&lt;/span&gt; IConfigureNamedOptions&amp;lt;TOptions&amp;gt;&lt;span&gt; namedSetup)
            {
                namedSetup.Configure(name, options);
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (name ==&lt;span&gt; Options.DefaultName)
            {
                setup.Configure(options);
            }
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;步骤2-2：针对IPostConfigureOptions&amp;lt;TOptions&amp;gt;的初始化&lt;/span&gt;
        &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; post &lt;span&gt;in&lt;/span&gt;&lt;span&gt; _postConfigures)
        {
            post.PostConfigure(name, options);
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;步骤3：有效性验证&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; failedMessages = &lt;span&gt;new&lt;/span&gt; List&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; validator &lt;span&gt;in&lt;/span&gt;&lt;span&gt; _validations)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; reusult =&lt;span&gt; validator.Validate(name, options);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (reusult.Failed)
            {
                failedMessages.Add(reusult.FailureMessage);
            }
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (failedMessages.Count &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; OptionsValidationException(name, &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(TOptions),
                failedMessages);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; options;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上面的代码片段所示，调用构造函数创建OptionsFactory&amp;lt;TOptions&amp;gt;对象时需要提供IConfigureOptions&amp;lt;TOptions&amp;gt;对象、IPostConfigureOptions&amp;lt;TOptions&amp;gt;对象和IValidateOptions&amp;lt;TOptions&amp;gt;对象。在实现的Create方法中，它首先调用默认构造函数创建一个空Options对象，再先后利用IConfigureOptions&amp;lt;TOptions&amp;gt;对象和IPostConfigureOptions&amp;lt;TOptions&amp;gt;对象对这个Options对象进行“再加工”。这一切完成之后，指定的IValidateOptions&amp;lt;TOptions&amp;gt;会被逐个提取出来对最终生成的Options对象进行验证，如果没有通过验证，就会抛出一个OptionsValidationException类型的异常。图7-8所示的UML展示了OptionsFactory&amp;lt;TOptions&amp;gt;针对Options对象的初始化。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/202001/19327-20200113085334996-1104204140.png&quot;&gt;&lt;img width=&quot;460&quot; height=&quot;159&quot; title=&quot;7-8&quot; alt=&quot;7-8&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/202001/19327-20200113085335471-927557479.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;对于上述3个用来初始化Options对象的接口，Options模型均提供了默认实现，其中，ConfigureNamedOptions&amp;lt;TOptions&amp;gt;类同时实现了IConfigureOptions&amp;lt;TOptions&amp;gt;和IConfigureNamedOptions&amp;lt;TOptions&amp;gt;接口。当我们创建这样一个对象时，需要指定Options的名称和一个用来初始化Options对象的Action&amp;lt;TOptions&amp;gt;委托对象。如果指定了一个非空的名称，那么提供的委托对象将会用于初始化与该名称相匹配的Options对象；如果指定的名称为Null（不是空字符串），就意味着提供的初始化操作适用于所有同类的Options对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ConfigureNamedOptions&amp;lt;TOptions&amp;gt; :IConfigureNamedOptions&amp;lt;TOptions&amp;gt;,IConfigureOptions&amp;lt;TOptions&amp;gt; &lt;span&gt;where&lt;/span&gt; TOptions : &lt;span&gt;class&lt;/span&gt;&lt;span&gt;
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Action&amp;lt;TOptions&amp;gt; Action { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ConfigureNamedOptions(&lt;span&gt;string&lt;/span&gt; name, Action&amp;lt;TOptions&amp;gt;&lt;span&gt; action)
    {
        Name &lt;/span&gt;=&lt;span&gt; name;
        Action &lt;/span&gt;=&lt;span&gt; action;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Configure(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; name, TOptions options)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (Name == &lt;span&gt;null&lt;/span&gt; || name ==&lt;span&gt; Name)
        {
            Action&lt;/span&gt;?&lt;span&gt;.Invoke(options);
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Configure(TOptions options)  =&amp;gt;&lt;span&gt; Configure(Options.DefaultName, options);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;有时针对某个Options的初始化工作需要依赖另一个服务。比较典型的就是根据当前承载环境（开发、预发和产品）对某个Options对象做动态设置。为了解决这个问题，Options模型提供了一个ConfigureNamedOptions&amp;lt;TOptions, TDep&amp;gt;，其中，第二个反省参数代表依赖的服务类型。如下面的代码片段所示，ConfigureNamedOptions&amp;lt;TOptions, TDep&amp;gt;依然是IConfigureNamedOptions&amp;lt;TOptions&amp;gt;接口的实现类型，它利用Action&amp;lt;TOptions, TDep&amp;gt;对象针对指定的依赖服务对Options做针对性初始化。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ConfigureNamedOptions&amp;lt;TOptions, TDep&amp;gt; : IConfigureNamedOptions&amp;lt;TOptions&amp;gt;
    &lt;span&gt;where&lt;/span&gt; TOptions : &lt;span&gt;class&lt;/span&gt;
    &lt;span&gt;where&lt;/span&gt; TDep : &lt;span&gt;class&lt;/span&gt;&lt;span&gt;
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Action&amp;lt;TOptions, TDep&amp;gt; Action { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; TDep Dependency { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ConfigureNamedOptions(&lt;span&gt;string&lt;/span&gt; name, TDep dependency, Action&amp;lt;TOptions, TDep&amp;gt;&lt;span&gt; action)
    {
        Name &lt;/span&gt;=&lt;span&gt; name;
        Action &lt;/span&gt;=&lt;span&gt; action;
        Dependency &lt;/span&gt;=&lt;span&gt; dependency;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Configure(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; name, TOptions options)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (Name == &lt;span&gt;null&lt;/span&gt; || name ==&lt;span&gt; Name)
        {
            Action&lt;/span&gt;?&lt;span&gt;.Invoke(options, Dependency);
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Configure(TOptions options)  =&amp;gt;&lt;span&gt; Configure(Options.DefaultName, options);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ConfigureNamedOptions&amp;lt;TOptions, TDep&amp;gt;仅仅实现了针对单一服务的依赖，针对Options的初始化可能依赖多个服务，Options模型为此定义了如下所示的一系列类型。这些类型都实现了IConfigureNamedOptions&amp;lt;TOptions&amp;gt;接口，并采用类似于ConfigureNamedOptions&amp;lt;TOptions, TDep&amp;gt;类型的方式实现了Configure方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ConfigureNamedOptions&amp;lt;TOptions, TDep1, TDep2, TDep3, TDep4, TDep5&amp;gt; : IConfigureNamedOptions&amp;lt;TOptions&amp;gt;
    &lt;span&gt;where&lt;/span&gt; TOptions : &lt;span&gt;class&lt;/span&gt;
    &lt;span&gt;where&lt;/span&gt; TDep1 : &lt;span&gt;class&lt;/span&gt;
    &lt;span&gt;where&lt;/span&gt; TDep2 : &lt;span&gt;class&lt;/span&gt;
    &lt;span&gt;where&lt;/span&gt; TDep3 : &lt;span&gt;class&lt;/span&gt;
    &lt;span&gt;where&lt;/span&gt; TDep4 : &lt;span&gt;class&lt;/span&gt;
    &lt;span&gt;where&lt;/span&gt; TDep5 : &lt;span&gt;class&lt;/span&gt;&lt;span&gt;
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; TDep1 Dependency1 { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; TDep2 Dependency2 { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; TDep3 Dependency3 { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; TDep4 Dependency4 { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; TDep5 Dependency5 { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Action&amp;lt;TOptions, TDep1, TDep2, TDep3, TDep4, TDep5&amp;gt; Action { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ConfigureNamedOptions(&lt;span&gt;string&lt;/span&gt; name, TDep1 dependency, TDep2 dependency2, TDep3 dependency3, TDep4 dependency4, TDep5 dependency5, Action&amp;lt;TOptions, TDep1, TDep2, TDep3, TDep4, TDep5&amp;gt;&lt;span&gt; action);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(TOptions options);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Configure(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; name, TOptions options);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;默认实现IPostConfigureOptions&amp;lt;TOptions&amp;gt;接口的是PostConfigureOptions&amp;lt;TOptions&amp;gt;类型。从给出的代码片段可以看出它针对Options对象的初始化实现方式与ConfigureNamedOptions&amp;lt;TOptions&amp;gt;类型并没有本质的差别。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; PostConfigureOptions&amp;lt;TOptions&amp;gt; : IPostConfigureOptions&amp;lt;TOptions&amp;gt; &lt;span&gt;where&lt;/span&gt; TOptions : &lt;span&gt;class&lt;/span&gt;&lt;span&gt;
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Action&amp;lt;TOptions&amp;gt; Action { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; PostConfigureOptions(&lt;span&gt;string&lt;/span&gt; name, Action&amp;lt;TOptions&amp;gt;&lt;span&gt; action)
    {
        Name &lt;/span&gt;=&lt;span&gt; name;
        Action &lt;/span&gt;=&lt;span&gt; action;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; PostConfigure(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; name, TOptions options)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (Name == &lt;span&gt;null&lt;/span&gt; || name ==&lt;span&gt; Name)
        {
            Action&lt;/span&gt;?&lt;span&gt;.Invoke(options);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Options模型同样定义了如下这一系列针对依赖服务的IPostConfigureOptions&amp;lt;TOptions&amp;gt;接口实现。如果针对Options对象的后置初始化操作依赖于其他服务，就可以根据服务的数量选择对应的类型。这些类型针对PostConfigure方法的实现与ConfigureNamedOptions&amp;lt;TOptions, TDep&amp;gt;类型实现Configure方法并没有本质区别。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;PostConfigureOptions&amp;lt;TOptions, TDep&amp;gt;。&lt;/li&gt;
&lt;li&gt;PostConfigureOptions&amp;lt;TOptions, TDep1, TDep2&amp;gt;。&lt;/li&gt;
&lt;li&gt;PostConfigureOptions&amp;lt;TOptions, TDep1, TDep2, TDep3&amp;gt;。&lt;/li&gt;
&lt;li&gt;PostConfigureOptions&amp;lt;TOptions, TDep1, TDep2, TDep3, TDep4&amp;gt;。&lt;/li&gt;
&lt;li&gt;PostConfigureOptions&amp;lt;TOptions, TDep1, TDep2, TDep3, TDep4, TDep5&amp;gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ValidateOptions&amp;lt;TOptions&amp;gt;是对IValidateOptions&amp;lt;TOptions&amp;gt;接口的默认实现。如下面的代码片段所示，创建一个ValidateOptions&amp;lt;TOptions&amp;gt;对象时，需要提供Options的名称和验证错误消息，以及真正用于对Options进行验证的Func&amp;lt;TOptions, bool&amp;gt;对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ValidateOptions&amp;lt;TOptions&amp;gt; : IValidateOptions&amp;lt;TOptions&amp;gt;&lt;span&gt;where&lt;/span&gt; TOptions : &lt;span&gt;class&lt;/span&gt;&lt;span&gt;
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; FailureMessage { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Func&amp;lt;TOptions, &lt;span&gt;bool&lt;/span&gt;&amp;gt; Validation { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ValidateOptions(&lt;span&gt;string&lt;/span&gt; name, Func&amp;lt;TOptions, &lt;span&gt;bool&lt;/span&gt;&amp;gt; validation, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; failureMessage);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ValidateOptionsResult Validate(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; name, TOptions options);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对Options的验证同样可能具有对其他服务的依赖，比较典型的依然是针对不同的承载环境（开发、预发和产品）具有不同的验证规则，所以IValidateOptions&amp;lt;TOptions&amp;gt;接口同样具有如下5个针对不同依赖服务数量的实现类型。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ValidateOptions&amp;lt;TOptions, TDep&amp;gt;&lt;/li&gt;
&lt;li&gt;ValidateOptions&amp;lt;TOptions, TDep1, TDep2&amp;gt;&lt;/li&gt;
&lt;li&gt;ValidateOptions&amp;lt;TOptions, TDep1, TDep2, TDep3&amp;gt;&lt;/li&gt;
&lt;li&gt;ValidateOptions&amp;lt;TOptions, TDep1, TDep2, TDep3, TDep4&amp;gt;&lt;/li&gt;
&lt;li&gt;ValidateOptions&amp;lt;TOptions, TDep1, TDep2, TDep3, TDep4, TDep5&amp;gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;前面介绍了OptionsFactory&amp;lt;TOptions&amp;gt;类型针对Options对象的创建和初始化的实现原理，以及涉及的一些相关的接口和类型，下图基本上反映了这些接口与类型的关系。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/202001/19327-20200113085335783-816187017.png&quot;&gt;&lt;img width=&quot;712&quot; height=&quot;353&quot; title=&quot;7-9&quot; alt=&quot;7-9&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/202001/19327-20200113085336507-826028605.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-06-01.html&quot;&gt;[ASP.NET Core 3框架揭秘] Options[1]: 配置选项的正确使用方式[上篇]&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-06-02.html&quot;&gt;[ASP.NET Core 3框架揭秘] Options[2]: 配置选项的正确使用方式[下篇]&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-06-03.html&quot;&gt;[ASP.NET Core 3框架揭秘] Options[3]: Options模型[上篇]&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-06-04.html&quot;&gt;[ASP.NET Core 3框架揭秘] Options[4]: Options模型[下篇]&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-06-05.html&quot;&gt;[ASP.NET Core 3框架揭秘] Options[5]: 依赖注入&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-06-06.html&quot;&gt;[ASP.NET Core 3框架揭秘] Options[6]: 扩展与定制&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-06-07.html&quot;&gt;[ASP.NET Core 3框架揭秘] Options[7]: 与配置系统的整合&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 13 Jan 2020 00:51:00 +0000</pubDate>
<dc:creator>Artech</dc:creator>
<og:description>通过前面演示的几个实例（配置选项的正确使用方式[上篇]、配置选项的正确使用方式[下篇]），我们已经对基于Options的编程方式有了一定程度的了解，下面从设计的角度介绍Options模型。我们演示的实</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/artech/p/inside-asp-net-core-06-03.html</dc:identifier>
</item>
<item>
<title>最强常用开发库总结 - JSON库详解 - pdai</title>
<link>http://www.cnblogs.com/pengdai/p/12185594.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pengdai/p/12185594.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;JSON应用非常广泛，对于Java常用的JSON库要完全掌握。@pdai&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;json简介&quot;&gt;JSON简介&lt;/h2&gt;
&lt;h3 id=&quot;json是什么&quot;&gt;JSON是什么&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;JSON 指的是 JavaScript 对象表示法（JavaScript Object Notation）&lt;/li&gt;
&lt;li&gt;JSON 是轻量级的文本数据交换格式&lt;/li&gt;
&lt;li&gt;JSON 独立于语言：JSON 使用 Javascript语法来描述数据对象，但是 JSON 仍然独立于语言和平台。JSON 解析器和 JSON 库支持许多不同的编程语言。 目前非常多的动态（PHP，JSP，.NET）编程语言都支持JSON。&lt;/li&gt;
&lt;li&gt;JSON 具有自我描述性，更易理解&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;结构与类型&quot;&gt;结构与类型&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;只有两种结构：对象内的键值对集合结构和数组，对象用{}表示、内部是”key”:”value”，数组用[]表示，不同值用逗号分开&lt;/li&gt;
&lt;li&gt;基本数值有7个： false / null / true / object / array / number / string&lt;/li&gt;
&lt;li&gt;再加上结构可以嵌套，进而可以用来表达复杂的数据&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;一个简单实例&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
   &quot;Image&quot;: {
       &quot;Width&quot;:  800,
       &quot;Height&quot;: 600,
       &quot;Title&quot;:  &quot;View from 15th Floor&quot;,
       &quot;Thumbnail&quot;: {
           &quot;Url&quot;:    &quot;http://www.example.com/image/481989943&quot;,
           &quot;Height&quot;: 125,
           &quot;Width&quot;:  &quot;100&quot;
       },
       &quot;IDs&quot;: [116, 943, 234, 38793]
     }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;json优秀资源&quot;&gt;JSON优秀资源&lt;/h3&gt;
&lt;h3 id=&quot;json在线解析工具&quot;&gt;JSON在线解析工具&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://www.pdai.tech/_images/develop/package/dev-package-json-3.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;json类库&quot;&gt;JSON类库&lt;/h2&gt;
&lt;p&gt;Java中并没有内置JSON的解析，因此使用JSON需要借助第三方类库。&lt;/p&gt;
&lt;p&gt;下面是几个常用的 JSON 解析类库：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;FastJson: 阿里巴巴开发的 JSON 库，性能十分优秀。&lt;/li&gt;
&lt;li&gt;Jackson: 社区十分活跃且更新速度很快。&lt;/li&gt;
&lt;li&gt;Gson: 谷歌开发的 JSON 库，功能十分全面。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;性能测试对比&quot;&gt;性能测试对比&lt;/h3&gt;
&lt;p&gt;从下面的测试结果可以看出，序列化次数比较小的时候，Gson性能最好，当不断增加的时候到了100000，Gson明细弱于Jackson和FastJson， 这时候FastJson性能是真的牛，另外还可以看到不管数量少还是多，Jackson一直表现优异。而那个Json-lib可以直接忽略。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;JSON序列化性能&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://www.pdai.tech/_images/develop/package/dev-package-json-1.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;JSON反序列化性能&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://www.pdai.tech/_images/develop/package/dev-package-json-2.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;更多请参考： &lt;a href=&quot;https://www.xncoding.com/2018/01/09/java/jsons.html&quot;&gt;Java几种常用JSON库性能比较&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;fastjson&quot;&gt;FastJson&lt;/h2&gt;
&lt;h3 id=&quot;fastjson-简介&quot;&gt;Fastjson 简介&lt;/h3&gt;
&lt;p&gt;Fastjson 是一个 Java 库，可以将 Java 对象转换为 JSON 格式，当然它也可以将 JSON 字符串转换为 Java 对象。&lt;/p&gt;
&lt;p&gt;Fastjson 可以操作任何 Java 对象，即使是一些预先存在的没有源码的对象。&lt;/p&gt;
&lt;h3 id=&quot;fastjson-特性&quot;&gt;Fastjson 特性&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;提供服务器端、安卓客户端两种解析工具，性能表现较好。&lt;/li&gt;
&lt;li&gt;提供了 toJSONString() 和 parseObject() 方法来将 Java 对象与 JSON 相互转换。调用toJSONString方 法即可将对象转换成 JSON 字符串，parseObject 方法则反过来将 JSON 字符串转换成对象。&lt;/li&gt;
&lt;li&gt;允许转换预先存在的无法修改的对象（只有class、无源代码）。&lt;/li&gt;
&lt;li&gt;Java泛型的广泛支持。&lt;/li&gt;
&lt;li&gt;允许对象的自定义表示、允许自定义序列化类。&lt;/li&gt;
&lt;li&gt;支持任意复杂对象（具有深厚的继承层次和广泛使用的泛型类型）。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;下载和使用&quot;&gt;下载和使用&lt;/h3&gt;
&lt;p&gt;你可以在 maven 中央仓库中直接下载：&lt;a href=&quot;http://repo1.maven.org/maven2/com/alibaba/fastjson/&quot; class=&quot;uri&quot;&gt;http://repo1.maven.org/maven2/com/alibaba/fastjson/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;配置 maven 依赖:&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;fastjson&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;x.x.x&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中 x.x.x 是版本号，根据需要使用特定版本，建议使用最新版本。&lt;/p&gt;
&lt;h3 id=&quot;序列化一个对象成json字符串&quot;&gt;序列化一个对象成JSON字符串&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;User user = new User();
user.setName(&quot;校长&quot;);
user.setAge(3);
user.setSalary(new BigDecimal(&quot;123456789.0123&quot;));
String jsonString = JSON.toJSONString(user);
System.out.println(jsonString);
// 输出 {&quot;age&quot;:3,&quot;name&quot;:&quot;校长&quot;,&quot;old&quot;:false,&quot;salary&quot;:123456789.0123}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;反序列化一个json字符串成java对象&quot;&gt;反序列化一个JSON字符串成Java对象&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;String jsonString = &quot;{\&quot;age\&quot;:3,\&quot;birthdate\&quot;:1496738822842,\&quot;name\&quot;:\&quot;校长\&quot;,\&quot;old\&quot;:true,\&quot;salary\&quot;:123456789.0123}&quot;;
 User u = JSON.parseObject(jsonString ,User.class);
 System.out.println(u.getName());
 // 输出 校长

String jsonStringArray = &quot;[{\&quot;age\&quot;:3,\&quot;birthdate\&quot;:1496738822842,\&quot;name\&quot;:\&quot;校长\&quot;,\&quot;old\&quot;:true,\&quot;salary\&quot;:123456789.0123}]&quot;;
List&amp;lt;User&amp;gt; userList = JSON.parseArray(jsonStringArray, User.class);
System.out.println(userList.size());
// 输出 1&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;对于日期的处理&quot;&gt;对于日期的处理&lt;/h3&gt;
&lt;p&gt;默认序列化Date输出使用”yyyy-MM-dd HH:mm:ss”格式，可以用UseISO8601DateFormat特性换成”yyyy-MM-dd’T’HH:mm:ss”格式。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;JSON.defaultTimeZone = TimeZone.getTimeZone(&quot;Asia/Shanghai&quot;);
JSON.defaultLocale = Locale.US;
        
public static class Model {
    @JSONField(format = &quot;MMM dd, yyyy h:mm:ss aa&quot;)
    private java.util.Date date;

    public java.util.Date getDate() {
        return date;
    }

    public void setDate(java.util.Date date) {
        this.date = date;
    }

    @JSONField(format = &quot;MMM-dd-yyyy h:mm:ss aa&quot;)
    public java.sql.Date date2;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;bean和数组转换&quot;&gt;Bean和数组转换&lt;/h3&gt;
&lt;h3 id=&quot;设置字段名&quot;&gt;设置字段名&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class A {
    @JSONField(name=&quot;ID&quot;)
    private int id;

    public int getId() {return id;}
    public void setId(int value) {this.id = id;}
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;设置是否不序列化某字段&quot;&gt;设置是否不序列化某字段&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class A {
    @JSONField(serialize=false)
    public Date date;
}

public class A {
    @JSONField(deserialize=false)
    public Date date;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;设置字段顺序&quot;&gt;设置字段顺序&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static class VO {
    @JSONField(ordinal = 3)
    private int f0;

    @JSONField(ordinal = 2)
    private int f1;

    @JSONField(ordinal = 1)
    private int f2;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;自定义序列化和反序列化&quot;&gt;自定义序列化和反序列化&lt;/h3&gt;
&lt;h3 id=&quot;fastjson漏洞问题&quot;&gt;FastJson漏洞问题&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;尽量使用最新版本。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;jackson&quot;&gt;JackSon&lt;/h2&gt;
&lt;h3 id=&quot;jackson简介&quot;&gt;JackSon简介&lt;/h3&gt;
&lt;h3 id=&quot;jackson组件&quot;&gt;Jackson组件&lt;/h3&gt;
&lt;h4 id=&quot;个核心模块&quot;&gt;3个核心模块：&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Streaming&lt;/strong&gt;: jackson-core jar，定义了底层的streaming API和实现了Json特性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Annotations&lt;/strong&gt;: jackson-annotations jar，包含了标准的Jackson注解。本文暂不介绍。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Databind&lt;/strong&gt;: jackson-databind jar，实现了数据绑定和对象序列化，它依赖于streaming和annotations的包。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;第三方数据类型模块&quot;&gt;第三方数据类型模块&lt;/h4&gt;
&lt;p&gt;这些扩展是插件式的Jackson模块，用ObjectMapper.registerModule()注册，并且通过添加serializers和deserializers以便Databind包（ObjectMapper / ObjectReader / ObjectWriter）可以读写这些类型，来增加对各种常用的Java库的数据类型的支持。&lt;/p&gt;
&lt;h4 id=&quot;数据格式模块&quot;&gt;数据格式模块&lt;/h4&gt;
&lt;p&gt;Jackson也有处理程序对JAX-RS标准实现者例如Jersey, RESTeasy, CXF等提供了数据格式支持。处理程序实现了MessageBodyReader和MessageBodyWriter，目前支持的数据格式包括JSON, Smile, XML, YAML和CBOR。&lt;/p&gt;
&lt;p&gt;数据格式提供了除了Json之外的数据格式支持，它们绝大部分仅仅实现了streaming API abstractions，以便数据绑定组件可以按照原来的方式使用。另一些（几乎不需要）提供了databind标准功能来处理例如schemas。&lt;/p&gt;
&lt;h3 id=&quot;jackson的使用&quot;&gt;Jackson的使用&lt;/h3&gt;
&lt;p&gt;引用maven jar包：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;&amp;lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-core --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.fasterxml.jackson.core&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;jackson-core&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.10.1&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.fasterxml.jackson.core&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;jackson-databind&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.10.1&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-annotations --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.fasterxml.jackson.core&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;jackson-annotations&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.10.1&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;序列化一个对象成json字符串-1&quot;&gt;序列化一个对象成JSON字符串&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void toJson() throws JsonProcessingException {

    ObjectMapper mapper = new ObjectMapper();

    City case1 = new City();
    case1.setCity(&quot;SZ&quot;);
    case1.setAge(123);

    String jsonStr = mapper.writeValueAsString(case1);
    System.out.println(&quot;JSON:&quot; + jsonStr);
}
// 输出：JSON:{&quot;city&quot;:&quot;SZ&quot;,&quot;age&quot;:123}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;反序列化一个json字符串成java对象-1&quot;&gt;反序列化一个JSON字符串成Java对象&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void toObj() throws JsonParseException, JsonMappingException, IOException {
    ObjectMapper mapper = new ObjectMapper();
    String inputjsonstr = &quot;{\&quot;city\&quot;:\&quot;SZ\&quot;,\&quot;age\&quot;:123}&quot;;
    
    City readcase = mapper.readValue(inputjsonstr, City.class);

    System.out.println(&quot;city info:&quot; + readcase);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;如果里面有未知属性，比如json中有&lt;code&gt;desc&lt;/code&gt;字段，但是City中没有相应字段，会报错, 需要设置如下：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;mapper.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;常用注解&quot;&gt;常用注解&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;@JsonProperty(&quot;xxx&quot;)&lt;/code&gt;: 将当前的属性名在json字符串中重新命名为当前设置的这个值，比如在示例中，将age--&amp;gt;mAge&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@JsonIgnore&lt;/code&gt;: 将被标注的属性在生成json字符串的时候，直接忽略&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@JsonInclude&lt;/code&gt;: 是一个类级别的设置，JsonInclude.Include.NON_EMPTY标识只有非NULL的值才会被纳入json string之中，其余的都被忽略，比如这里的location属性，并没有出现在最终的结果字符串中。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@JsonSerialize&lt;/code&gt;: 使用自定义的类来实现自定义的字段转换。写入操作。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@JsonDeserialize&lt;/code&gt;: 解析的时候，自定义的转换器；读取操作。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@JsonAutoDetect&lt;/code&gt;: 设置类的访问策略，是否所有的属性都可以，还是按照一定的方式来提取。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@JsonRawValue&lt;/code&gt;: 无转换的将属性值写入到json 字符串中。 写入操作&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@JsonValue&lt;/code&gt;: 标注方法，用以替代缺省的方法，由该方法来完成json的字符输出。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;gson&quot;&gt;GSON&lt;/h2&gt;
&lt;h3 id=&quot;gson简介&quot;&gt;Gson简介&lt;/h3&gt;
&lt;p&gt;Gson是这样一个Java类库，它可以将Java对象转换为相应的JSON形式，也可以将JSON字符串转换为对应的Java对象。&lt;br/&gt;Gson可以使用任意Java对象，包括哪些预先存在的、不在你的源代码中的对象（因此，你并不知道对象的属性）。&lt;/p&gt;
&lt;h3 id=&quot;gson的目标&quot;&gt;Gson的目标&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;提供一种机制，使得将Java对象转换为JSON或相反如使用toString()以及构造器（工厂方法）一样简单。&lt;/li&gt;
&lt;li&gt;允许预先存在的不可变的对象转换为JSON或与之相反。&lt;/li&gt;
&lt;li&gt;允许自定义对象的表现形式&lt;/li&gt;
&lt;li&gt;支持任意复杂的对象&lt;/li&gt;
&lt;li&gt;输出轻量易读的JSON&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;gson的使用&quot;&gt;Gson的使用&lt;/h3&gt;
&lt;p&gt;使用Gson的首要类是Gson类，你可以仅仅通过new Gson()的方式创建它。你也可以通过GsonBuilder类去创建Gson实例，这个类允许你进行一系列配置，例如版本控制等等。&lt;/p&gt;
&lt;p&gt;Gson实例不会保存任何进行Json操作时的状态。因此，你可以自由的服用相同的Gson对象进行诸多的Json序列化和反序列化操作。&lt;/p&gt;
&lt;p&gt;引用maven jar包：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;!-- https://mvnrepository.com/artifact/com.google.guava/guava --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.google.guava&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;guava&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;28.2-jre&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;序列化&quot;&gt;序列化&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 基础类型
Gson gson = new Gson();
gson.toJson(1);            ==&amp;gt; prints 1
gson.toJson(&quot;abcd&quot;);       ==&amp;gt; prints &quot;abcd&quot;
gson.toJson(new Long(10)); ==&amp;gt; prints 10
int[] values = { 1 };
gson.toJson(values);       ==&amp;gt; prints [1]

// 对象
BagOfPrimitives obj = new BagOfPrimitives();
Gson gson = new Gson();
String json = gson.toJson(obj);  
==&amp;gt; json is {&quot;value1&quot;:1,&quot;value2&quot;:&quot;abc&quot;}

// 数组
Gson gson = new Gson();
int[] ints = {1, 2, 3, 4, 5};
String[] strings = {&quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;};
gson.toJson(ints);     ==&amp;gt; prints [1,2,3,4,5]
gson.toJson(strings);  ==&amp;gt; prints [&quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;]

// 集合
Gson gson = new Gson();
Collection&amp;lt;Integer&amp;gt; ints = Lists.immutableList(1,2,3,4,5);
String json = gson.toJson(ints); ==&amp;gt; json is [1,2,3,4,5]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中的对象代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class BagOfPrimitives {
  private int value1 = 1;
  private String value2 = &quot;abc&quot;;
  private transient int value3 = 3;
  BagOfPrimitives() {
    // no-args constructor
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;反序列化&quot;&gt;反序列化&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 基础类型
Gson gson = new Gson();
int one = gson.fromJson(&quot;1&quot;, int.class);
Integer one = gson.fromJson(&quot;1&quot;, Integer.class);
Long one = gson.fromJson(&quot;1&quot;, Long.class);
Boolean false = gson.fromJson(&quot;false&quot;, Boolean.class);
String str = gson.fromJson(&quot;\&quot;abc\&quot;&quot;, String.class);
String anotherStr = gson.fromJson(&quot;[\&quot;abc\&quot;]&quot;, String.class);

// 对象
BagOfPrimitives obj2 = gson.fromJson(json, BagOfPrimitives.class);   
==&amp;gt; obj2 is just like obj

// 数组
Gson gson = new Gson();
int[] ints2 = gson.fromJson(&quot;[1,2,3,4,5]&quot;, int[].class); 
==&amp;gt; ints2 will be same as ints

// 集合
Gson gson = new Gson();
Type collectionType = new TypeToken&amp;lt;Collection&amp;lt;Integer&amp;gt;&amp;gt;(){}.getType();
Collection&amp;lt;Integer&amp;gt; ints2 = gson.fromJson(json, collectionType);
ints2 is same as ints&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;自定义序列化和反序列化机制&quot;&gt;自定义序列化和反序列化机制&lt;/h3&gt;
&lt;p&gt;有时候，默认的实现并不是你想要的。这在处理类库时常常发生（例如DateTime）。Gson允许你注册自己自定义的序列化器和反序列化器。该过程分为两部分：&lt;/p&gt;
&lt;p&gt;实例构造者：并不需要，如果无参构造器是可用的或者注册了一个反序列化器。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;GsonBuilder gson = new GsonBuilder();
gson.registerTypeAdapter(MyType2.class, new MyTypeAdapter());
gson.registerTypeAdapter(MyType.class, new MySerializer());
gson.registerTypeAdapter(MyType.class, new MyDeserializer());
gson.registerTypeAdapter(MyType.class, new MyInstanceCreator());&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;registerTypeAdapter会检查类型适配器是否实现了上面三个接口中的一个以上并且它们都注册了类型适配器。&lt;/p&gt;
&lt;p&gt;更多请参考：&lt;a href=&quot;https://www.jianshu.com/p/1e20b28c39d1&quot;&gt;Gson用户指南（中文翻译）&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;参考文章&quot;&gt;参考文章&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;https://github.com/FasterXML/jackson&lt;/li&gt;
&lt;li&gt;https://www.runoob.com/w3cnote/fastjson-intro.html&lt;/li&gt;
&lt;li&gt;https://blog.csdn.net/m0_37076574/article/details/81317403&lt;/li&gt;
&lt;li&gt;https://blog.csdn.net/blueheart20/article/details/52212221&lt;/li&gt;
&lt;li&gt;https://blog.csdn.net/gjb724332682/article/details/51586701&lt;/li&gt;
&lt;li&gt;https://www.jianshu.com/p/1e20b28c39d1&lt;/li&gt;
&lt;li&gt;https://www.jianshu.com/p/923a9fe78108&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;更多内容&quot;&gt;更多内容&lt;/h2&gt;
&lt;blockquote readability=&quot;4.3421052631579&quot;&gt;
&lt;p&gt;&lt;span&gt;最全的Java后端知识体系&lt;/span&gt; &lt;span&gt;&lt;a href=&quot;https://www.pdai.tech&quot; class=&quot;uri&quot;&gt;https://www.pdai.tech&lt;/a&gt;&lt;/span&gt;, &lt;span&gt;每天更新中...&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 13 Jan 2020 00:49:00 +0000</pubDate>
<dc:creator>pdai</dc:creator>
<og:description>最强常用开发库总结 JSON库详解 JSON应用非常广泛，对于Java常用的JSON库要完全掌握。@pdai JSON简介 JSON是什么 + JSON 指的是 JavaScript 对象表示法（Ja</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/pengdai/p/12185594.html</dc:identifier>
</item>
<item>
<title>「newbee-mall新蜂商城开源啦」1000 Star Get !仓库Star数破千！记录一下 - 我是13</title>
<link>http://www.cnblogs.com/han-1034683568/p/12184529.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/han-1034683568/p/12184529.html</guid>
<description>&lt;p&gt;新蜂商城已经开源了 3 个多月左右的时间，在 2019 年的年末，仓库的 Star 数量冲破了 1000，整理本篇文章的时间是 2020 年 1 月 12 日，目前的 Star 数量是 1180 左右，在这里向喜欢这个项目的朋友道个谢，同时也做一个简单的记录，项目的 Star 统计图如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://starchart.cc/newbee-ltd/newbee-mall.svg&quot; alt=&quot;newbee-mall&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;star破千做一个简单的记录&quot;&gt;Star破千！做一个简单的记录&lt;/h2&gt;
&lt;p&gt;我在 2019 年 10 月初把新蜂商城项目第一个版本的所有代码都放到了仓库里，到今天为止差不多是 3 个多月的时间，如下图所示，Star 数量涨的很快，尤其是 12 月份差不多增加了 600 多个 Star 数量。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/859549/202001/859549-20200112201052609-617365127.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个数量也是很出乎我的意料，因为我之前也写过几个开源项目，但是像现在这种场面我是第一次见，没见过什么大场面，大家不要见怪，之前的几个项目也有破千的，不过都没有专门写篇记录文章，因为那几个项目做得比较久，Star 数虽然不少，但是没见过如此疯涨的势头。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/859549/202001/859549-20200112201100270-503549573.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这里也感谢大家的支持和认可，当然，这是大家对新蜂商城这个开源项目的认可，我就不厚着脸皮往自己脸上贴金了，只有真诚的向大家表达一下我的谢意了。&lt;/p&gt;
&lt;h2 id=&quot;新蜂商城的由来&quot;&gt;新蜂商城的由来&lt;/h2&gt;
&lt;p&gt;在 GitHub 上写一些开源项目，这件事情我做了三年了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/859549/202001/859549-20200112201112623-316102666.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从 2017 年的第一个 &lt;a href=&quot;https://github.com/ZHENFENG13/ssm-demo&quot;&gt;ssm-demo&lt;/a&gt; 开源项目，到今天的 &lt;a href=&quot;https://github.com/newbee-ltd/newbee-mall&quot;&gt;newbee-mall&lt;/a&gt; 项目，我也没想到能够一直坚持了下来。&lt;/p&gt;
&lt;p&gt;至于为什么会写这个商城项目呢？大家通过我过往做的项目应该有一点清楚，一开始是做基础的 demo，后面是做一些小项目，之后也写过开源博客项目，由小项目到大项目，这是一个循序渐进的过程罢了，在三年时间里慢慢过渡，从无到有、由小至大，最终有了这样一系列的项目，至于为什么会选择走商城方向，主要是在几个交流群里和大家沟通过，貌似大家对商城类的项目更为感兴趣，所以就决定开发了它。&lt;/p&gt;
&lt;p&gt;这个项目其实 2018 年就在开发计划中了，但是一直没想好怎么做，做哪些功能，页面又怎么写，一方面因为这种项目比较麻烦，毕竟不是写一个工资管理系统，另一方面是工作安排的满，也一直没时间去做，所以一直拖到 2019 年的下半年。&lt;/p&gt;
&lt;p&gt;自从在网上写博客、在 GitHub 上开源了几个不值一提的小项目之后，很多朋友都会选择与我沟通，或者问我一些问题，这其中有相当一部分还是学生或者 1-3 年经验的朋友，通过与他们的沟通呢，我在写项目和想问题的时候也有所改变，目前做的几个项目都更注重一些基础的东西：&lt;strong&gt;别太麻烦、运行顺利、别缺代码。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;回到项目本身，通过上面说的几点呢，相信大家也能够看出来，我就是想写一个能够让大部分人，即使是初学者或者在校大学生，都能够运行起来的开源商城项目。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;于是，新蜂商城就开源了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/859549/202001/859549-20200112201134144-647032036.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;新蜂商城的名字&quot;&gt;新蜂商城的名字&lt;/h2&gt;
&lt;p&gt;这个项目的名称是 &lt;strong&gt;newbee-mall&lt;/strong&gt;，也有朋友会在群里叫他“牛逼商城”，因为它的谐音就是“niu bi”。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/859549/202001/859549-20200112201144494-39744641.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;newbee 呢，其实是新兵、菜鸟的意思，因为我觉得优秀的开源项目不计其数，我虽然也做了一些，不过与优秀二字实在搭不上边，我还是对自己有认识的，也就是个菜鸟而已，而且这个商城项目毕竟也是第一个版本，问题还是有的，&lt;strong&gt;所以它就是一个菜鸟，与牛逼真的搭不上边，大家喜欢就好，能学到东西那更好。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;新蜂商城的持续迭代&quot;&gt;新蜂商城的持续迭代&lt;/h2&gt;
&lt;p&gt;仅仅开源这么一段时间，却已经得到了不少的关注度，我也是诚惶诚恐，当然，大家有任何问题也都可以在交流群里与群里的朋友们一起交流，目前已经解决了很多很多很多很多大家提出的关于新蜂商城这个项目的问题。&lt;/p&gt;
&lt;p&gt;新蜂商城这个项目也会一直更新迭代，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/859549/202001/859549-20200112201226210-1383589113.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;目前已经改了不少的问题，今后也会继续修改 bug，持续的去完善这个项目。&lt;/p&gt;
&lt;p&gt;目前仓库里的代码有不少的问题，也改了挺多，有我自己发现的，也有其他朋友提的 issue 或者在群里提到的问题，比如之前就有人在 issue 列表给我提了一个bug，还被国家信息安全漏洞共享平台公布了，详见&lt;a href=&quot;https://juejin.im/post/5df0c0705188251222737053&quot;&gt;捅娄子了，写个bug被国家信息安全漏洞共享平台抓到了？&lt;/a&gt;，为了减少这种问题，也为了让这个项目体验更好，我会一直好好做下去的。&lt;/p&gt;
&lt;h2 id=&quot;新蜂商城的未来&quot;&gt;新蜂商城的未来&lt;/h2&gt;
&lt;p&gt;除了修复 bug 继续优化项目之外，也会规划一下新蜂商城的大版本更迭，我的计划是往移动端去更新迭代，PC 商城目前已经开发并且开源，移动化也尽快整起来，下一个重大的改版也已经在安排时间做了，目前是在做功能设计和页面原型设计。&lt;/p&gt;
&lt;p&gt;在我的几个技术交流群里和很多朋友都商量过，当然，如果你不在群里也可以给我在文章后留言或者直接发我邮件，交流群里小伙伴们的意见比较类似，首先是修改一些 bug、增加一些功能，关于大版本的变动，更多人是希望让我把它做成前后端分离形式的大型商城项目，技术栈也固定了一直比较火热的 VUE 上，这样就是后端 Spring Boot 技术栈，而前端是 VUE 技术栈。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/859549/202001/859549-20200112201240499-561388853.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最近由于工作上的一些事情，没有时间做这些事情，所以年后会抽时间把这个 VUE 版本的商城项目开发出来，做成前后端分离形式的项目，同时也增加一些大家都希望看到的一些功能模块和技术栈，包括前端项目和后端接口，都会一并开源。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;除注明转载/出处外，皆为作者原创，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接，否则保留追究法律责任的权利。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;感谢大家的观看，我是十三，文章首发于我的公众号“程序员的小故事”。&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 13 Jan 2020 00:41:00 +0000</pubDate>
<dc:creator>我是13</dc:creator>
<og:description>新蜂商城已经开源 3 个多月左右的时间，在 2019 年的年末，仓库的 Star 数量冲破了 1000，整理本篇文章的时间是 2020 年 1 月 12 日，目前的 Star 数量是 1180 左右，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/han-1034683568/p/12184529.html</dc:identifier>
</item>
<item>
<title>rabbitmq系列（一）初识rabbitmq - 执偕</title>
<link>http://www.cnblogs.com/zhixie/p/12185574.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhixie/p/12185574.html</guid>
<description>&lt;h2 id=&quot;为什么要使用消息中间件&quot;&gt;为什么要使用消息中间件&lt;/h2&gt;
&lt;p&gt;案例：假如我们开发了一个商品抢购网站。这个网站的目的就是在某一时间点进行抢购商品，同时要求用户注册，在注册的时候会同时给用户电话和邮箱中发送验证码，以便完成信息注册。传统做法应该是这样的。两种方式，并行即启用两个线程，当用户提交信息后，分别去发送邮件和发送短信。这种方式很明显比串行的方式更快。当我们加入消息队列后，处理方式如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1719198/202001/1719198-20200113084016817-1776104199.png&quot; alt=&quot;串行并行.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;加入消息中间件后，我们只需要注册信息存库后，给消息队列中添加一条消息就完事了。然后邮件服务和短信服务分别去消费消息即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1719198/202001/1719198-20200113084017217-1320956982.png&quot; alt=&quot;消息队列.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当用户注册完成后，到了抢购商品的时间，大家都去抢购某个商品的时候这个量很大。消息队列可以设置队列长度来保证系统的稳定性。当队列满了的时候，则不再处理这些用户请求。&lt;/p&gt;
&lt;p&gt;因此我们可以总结一下消息队列的特点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;异步处理 -- 用户注册信息提交后，直接返回响应。然后邮件服务和短信服务监听到队列有消息后去主动处理&lt;/li&gt;
&lt;li&gt;应用解耦 -- 用户注册流程分成了三个服务，注册服务、邮件服务、短信服务互不干扰。&lt;/li&gt;
&lt;li&gt;流量削峰 -- 控制用户请求，以防系统奔溃。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;常见消息中间件介绍&quot;&gt;常见消息中间件介绍&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;ActiveMQ&lt;/strong&gt;：apache出品，能力强劲的开源消息总线，完全支持jms规范的消息中间件。api丰富，在传统行业的中小型企业中应用广泛。缺点：服务性能和数据存储性能不好。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Kafka&lt;/strong&gt;：apache顶级项目，追求高吞吐量。一开始的目的是用于日志收集和传输。不支持事务，对消息重复，丢失，错误没有严格的请求。适合产生大量数据的互联网服务的数据收集业务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RocketMQ&lt;/strong&gt;：阿里开源中间件，目前已孵化成apache顶级项目，纯java开发，思路起源于kafka，对消息的可靠性传输和事务性做了优化。特点：高吞吐量、高可用。适合大规模分布式系统应用。目前在阿里集团被广泛使用，用于交易、充值，流计算，日志处理，消息推送等。现在推出了商业版，有些功能对外不开发。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RabbitMQ&lt;/strong&gt;：是一个开源的消息代理和队列服务器，用来通过普通协议在完全不同的应用之间共享数据，RabbitMQ是使用ErLang语言来编写的，并且基于AMQP协议。erlang语言开发，性能较好，高并发。社区活跃度高，网上资料比较多。&lt;/p&gt;
&lt;h2 id=&quot;什么是amqp协议&quot;&gt;什么是AMQP协议&lt;/h2&gt;
&lt;p&gt;AMQP（Advanced Message Queuing Protocol，高级消息队列协议）是一个进程间传递&lt;strong&gt;异步消息&lt;/strong&gt;的&lt;strong&gt;网络协议&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;涉及到的具体概念：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;server - 又称broker，接收客户端的链接，实现amqp实体服务。&lt;/li&gt;
&lt;li&gt;Connection - 链接，应用程序跟broker的网络链接。&lt;/li&gt;
&lt;li&gt;channel - 网络信道，几乎所有的操作都是在channel中进行，数据的流转都要在channel上进行。channel是进行消息读写的通道。客户端可以建立多个channel，每个channel代表一个会话任务。&lt;/li&gt;
&lt;li&gt;message - 消息，服务器与应用程序之间传送的数据。由properties和body组成。properties可以对消息进行修饰，比如消息的升级，延迟等高级特性。body就是消息体的内容。&lt;/li&gt;
&lt;li&gt;virtual host - 虚拟主机，用于进行逻辑隔离，最上层的消息路由，一个虚拟地址里面可以有多个交换机。exchange和消息队列message quene。&lt;/li&gt;
&lt;li&gt;exchange - 交换机，接收消息，根据路由器转发消息到绑定的队列。&lt;/li&gt;
&lt;li&gt;binding - 绑定，交换机和队列之间的虚拟链接，绑定中可以包含routing key。&lt;/li&gt;
&lt;li&gt;routing key - 一个路由规则，虚拟机可以用它来确定如何路由一个特定消息。&lt;/li&gt;
&lt;li&gt;quene - 消息队列，保存消息并将它们转发给消费者。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;详细了解AMQP协议可参考这篇文章--------&lt;a href=&quot;https://blog.csdn.net/m0_37968982/article/details/103864888&quot;&gt;详解AMQP协议&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;交换机简单介绍&quot;&gt;交换机简单介绍&lt;/h2&gt;
&lt;p&gt;exchange：接收消息，并根据路由键转发消息所绑定的队列。&lt;/p&gt;
&lt;p&gt;交换机的属性：&lt;/p&gt;
&lt;p&gt;name：交换机的名称&lt;/p&gt;
&lt;p&gt;type：交换机的类型direct，topic，fanout，headers&lt;/p&gt;
&lt;p&gt;durability：是否需要持久化，true为持久化。&lt;/p&gt;
&lt;p&gt;auto delete：当最后一个绑定到exchange上的队列删除后，自动删除该exchange。&lt;/p&gt;
&lt;p&gt;internal：当前exchange是否用于rabbitMQ内部使用，默认为false。&lt;/p&gt;
&lt;p&gt;arguments：可扩展参数。用户自自定义的交换机时，用到的参数。&lt;/p&gt;
&lt;p&gt;交换机常用的类型为direct，topic，fanout。headers不常用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;direct（直连交换机）:&lt;/strong&gt;&lt;/p&gt;
&lt;ol readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;所有发送到directExchange的消息被转发到RouteKey中指定的Queue&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;rabbitmq有一个自带的exchange叫default exchange，这个交换机是direct类型的。rabbitmq会让路由键跟队列名相等进行绑定。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;topic（主题交换机）:&lt;/strong&gt;&lt;/p&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;所有发送到topic exchange的消息被转发到所有关心RouteKey的Queue上&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Exchange将RouteKey和某些队列进行模糊匹配，此时队列需要绑定一个Topic&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;模糊匹配可以使用通配符：&lt;/p&gt;
&lt;p&gt;#可以匹配一个或多个词&lt;/p&gt;
&lt;p&gt;*只能匹配一个词&lt;/p&gt;
&lt;p&gt;比如：&quot;log.#&quot;可以匹配到“log.info.oa”。“log.*”只会匹配到“log.error”&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Fanout（扇型交换机）：&lt;/strong&gt;&lt;/p&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;不处理路由键，只需要简单的将队列绑定到交换机上。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;发送到交换机的消息都会被转发到与该交换机绑定的所有队列上&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;fanout交换机转发消息是最快的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果文章对您有帮助，请记得点赞关注哟~&lt;br/&gt;欢迎大家关注我的公众号：字节传说，每日推送技术文章供大家学习参考。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 13 Jan 2020 00:40:00 +0000</pubDate>
<dc:creator>执偕</dc:creator>
<og:description>为什么要使用消息中间件 案例：假如我们开发了一个商品抢购网站。这个网站的目的就是在某一时间点进行抢购商品，同时要求用户注册，在注册的时候会同时给用户电话和邮箱中发送验证码，以便完成信息注册。传统做法应</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhixie/p/12185574.html</dc:identifier>
</item>
<item>
<title>005.kubernets之pods的资源限制和健康检查 - 梦中泪</title>
<link>http://www.cnblogs.com/zyxnhr/p/12183107.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zyxnhr/p/12183107.html</guid>
<description>&lt;h2&gt;一 POD的容器资源限制&lt;/h2&gt;
&lt;h3&gt;1.1 限制内容&lt;/h3&gt;
&lt;p&gt;有两个参数&lt;/p&gt;
&lt;p&gt;QoS Class: BestEffort，表示尽可能的满足使用，级别较低，但当资源不够时，会杀掉这个容器&lt;/p&gt;
&lt;p&gt;resources: {}这里指定为空，则使用上面的参数&lt;/p&gt;
&lt;p&gt;一般定义&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;resources:
      requests:         #表示最小需求
        cpu: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0.1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        memory: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;32Mi&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
      limits:           #最大限制
        cpu: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        memory: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;128Mi&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;1.2 配置资源限制&lt;/h3&gt;
&lt;p&gt;[root@docker-server1 pods]# vim nginx-pods.yaml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;apiVersion: v1
kind: Pod
metadata:
  annotations:
    test: this is a test app
  labels:
    app: nginx
  name: nginx
  namespace: default
spec:
  containers:
  &lt;/span&gt;- &lt;span&gt;env&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;-&lt;span&gt; name: test
      value: aaa
    &lt;/span&gt;-&lt;span&gt; name: test1
      value: bbb
    image: nginx
    imagePullPolicy: Always
    name: nginx
    ports:
    &lt;/span&gt;- containerPort: &lt;span&gt;80&lt;/span&gt;&lt;span&gt;
      hostPort: &lt;/span&gt;&lt;span&gt;8080&lt;/span&gt;&lt;span&gt;
      protocol: TCP
    resources:
      requests:
        cpu: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0.2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        memory: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;128Mi&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
      limits:
        cpu: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        memory: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2Gi&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
  -&lt;span&gt; command:
    &lt;/span&gt;- &lt;span&gt;sh&lt;/span&gt;
    - -&lt;span&gt;c
    &lt;/span&gt;- &lt;span&gt;sleep&lt;/span&gt; &lt;span&gt;3600&lt;/span&gt;&lt;span&gt;
    image: busybox
    imagePullPolicy: Always
    name: busybox
    resources:
      requests:
        cpu: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0.1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        memory: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;32Mi&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
      limits:
        cpu: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        memory: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;128Mi&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  restartPolicy: Always&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;[root@docker-server1 pods]# kubectl delete pod nginx&lt;/p&gt;
&lt;h3&gt;1.3 创建pod&lt;/h3&gt;
&lt;p&gt;[root@docker-server1 pods]# kubectl apply -f nginx-pods.yaml&lt;/p&gt;
&lt;p&gt;[root@docker-server1 pods]# kubectl get pods&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;NAME    READY   STATUS    RESTARTS   AGE
nginx   &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;/&lt;span&gt;2&lt;/span&gt;     Running   &lt;span&gt;0&lt;/span&gt;          26s
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;[root@docker-server1 pods]# kubectl get pods -o wide&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;NAME    READY   STATUS    RESTARTS   AGE   IP           NODE              NOMINATED NODE   READINESS GATES
nginx   &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;/&lt;span&gt;2&lt;/span&gt;     Running   &lt;span&gt;0&lt;/span&gt;          32s   &lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;2.9&lt;/span&gt;   &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;132.133&lt;/span&gt;   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;1.4 查看资源限制信息&lt;/h3&gt;
&lt;p&gt;[root@docker-server1 pods]# kubectl describe pods nginx&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Name:         nginx
Namespace:    default
Priority:     &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
Node:         &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;132.133&lt;/span&gt;/&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;132.133&lt;/span&gt;&lt;span&gt;
Start Time:   Thu, &lt;/span&gt;&lt;span&gt;09&lt;/span&gt; Jan &lt;span&gt;2020&lt;/span&gt; &lt;span&gt;19&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;56&lt;/span&gt; -&lt;span&gt;0500&lt;/span&gt;&lt;span&gt;
Labels:       app&lt;/span&gt;=&lt;span&gt;nginx
Annotations:  kubectl.kubernetes.io&lt;/span&gt;/&lt;span&gt;last&lt;/span&gt;-applied-&lt;span&gt;configuration:
                {&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;apiVersion&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;v1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;kind&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Pod&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;metadata&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:{&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;annotations&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:{&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;this is a test app&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;},&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;labels&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:{&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;app&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;nginx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;},&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;nginx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;namespace...&lt;/span&gt;
&lt;span&gt;              test: this is a test app
Status:       Running
IP:           &lt;/span&gt;&lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;2.9&lt;/span&gt;&lt;span&gt;
IPs:
  IP:  &lt;/span&gt;&lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;2.9&lt;/span&gt;&lt;span&gt;
Containers:
  nginx:
    Container ID:   docker:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;80287ddae6b23bbb066246a00e1d764182517ae065015fa56017ecc8627f7bd5&lt;/span&gt;
&lt;span&gt;    Image:          nginx
    Image ID:       docker&lt;/span&gt;-pullable:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;nginx@sha256:8aa7f6a9585d908a63e5e418dc5d14ae7467d2e36e1ab4f0d8f9d059a3d071ce&lt;/span&gt;
    Port:           &lt;span&gt;80&lt;/span&gt;/&lt;span&gt;TCP
    Host Port:      &lt;/span&gt;&lt;span&gt;8080&lt;/span&gt;/&lt;span&gt;TCP
    State:          Running
      Started:      Thu, &lt;/span&gt;&lt;span&gt;09&lt;/span&gt; Jan &lt;span&gt;2020&lt;/span&gt; &lt;span&gt;19&lt;/span&gt;:&lt;span&gt;01&lt;/span&gt;:&lt;span&gt;03&lt;/span&gt; -&lt;span&gt;0500&lt;/span&gt;&lt;span&gt;
    Ready:          True
    Restart Count:  &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
    Limits:
      cpu:     &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
      memory:  2Gi
    Requests:
      cpu:     200m
      memory:  128Mi
    Environment:
      test:   aaa
      test1:  bbb
    Mounts:
      &lt;/span&gt;/var/run/secrets/kubernetes.io/serviceaccount from default-token-&lt;span&gt;bwbrn (ro)
  busybox:
    Container ID:  docker:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;91ac7538f51d8ffa33328dc0af2e2b7ef094d5439e948b0fc849f444d94ec61b&lt;/span&gt;
&lt;span&gt;    Image:         busybox
    Image ID:      docker&lt;/span&gt;-pullable:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;busybox@sha256:6915be4043561d64e0ab0f8f098dc2ac48e077fe23f488ac24b665166898115a&lt;/span&gt;
    Port:          &amp;lt;none&amp;gt;&lt;span&gt;
    Host Port:     &lt;/span&gt;&amp;lt;none&amp;gt;&lt;span&gt;
    Command:
      &lt;/span&gt;&lt;span&gt;sh&lt;/span&gt;
      -&lt;span&gt;c
      &lt;/span&gt;&lt;span&gt;sleep&lt;/span&gt; &lt;span&gt;3600&lt;/span&gt;&lt;span&gt;
    State:          Running
      Started:      Thu, &lt;/span&gt;&lt;span&gt;09&lt;/span&gt; Jan &lt;span&gt;2020&lt;/span&gt; &lt;span&gt;19&lt;/span&gt;:&lt;span&gt;01&lt;/span&gt;:&lt;span&gt;08&lt;/span&gt; -&lt;span&gt;0500&lt;/span&gt;&lt;span&gt;
    Ready:          True
    Restart Count:  &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
    Limits:
      cpu:     &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
      memory:  128Mi
    Requests:
      cpu:        100m
      memory:     32Mi
    Environment:  &lt;/span&gt;&amp;lt;none&amp;gt;&lt;span&gt;
    Mounts:
      &lt;/span&gt;/var/run/secrets/kubernetes.io/serviceaccount from default-token-&lt;span&gt;bwbrn (ro)
Conditions:
  Type              Status
  Initialized       True 
  Ready             True 
  ContainersReady   True 
  PodScheduled      True 
Volumes:
  default&lt;/span&gt;-token-&lt;span&gt;bwbrn:
    Type:        Secret (a volume populated by a Secret)
    SecretName:  default&lt;/span&gt;-token-&lt;span&gt;bwbrn
    Optional:    &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
QoS Class:       Burstable
Node&lt;/span&gt;-Selectors:  &amp;lt;none&amp;gt;&lt;span&gt;
Tolerations:     node.kubernetes.io&lt;/span&gt;/not-ready:NoExecute &lt;span&gt;for&lt;/span&gt;&lt;span&gt; 300s
                 node.kubernetes.io&lt;/span&gt;/unreachable:NoExecute &lt;span&gt;for&lt;/span&gt;&lt;span&gt; 300s
Events:
  Type    Reason     Age    From                      Message
  &lt;/span&gt;----    ------     ----   ----                      -------&lt;span&gt;
  Normal  Pulling    2m37s  kubelet, &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;132.133&lt;/span&gt;  Pulling image &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;nginx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  Normal  Scheduled  2m35s  default&lt;/span&gt;-scheduler         Successfully assigned default/nginx to &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;132.133&lt;/span&gt;&lt;span&gt;
  Normal  Pulled     2m31s  kubelet, &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;132.133&lt;/span&gt;  Successfully pulled image &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;nginx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  Normal  Created    2m31s  kubelet, &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;132.133&lt;/span&gt;&lt;span&gt;  Created container nginx
  Normal  Started    2m31s  kubelet, &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;132.133&lt;/span&gt;&lt;span&gt;  Started container nginx
  Normal  Pulling    2m31s  kubelet, &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;132.133&lt;/span&gt;  Pulling image &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;busybox&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  Normal  Pulled     2m26s  kubelet, &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;132.133&lt;/span&gt;  Successfully pulled image &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;busybox&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  Normal  Created    2m26s  kubelet, &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;132.133&lt;/span&gt;&lt;span&gt;  Created container busybox
  Normal  Started    2m26s  kubelet, &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;132.133&lt;/span&gt;  Started container busybox
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;1.5 不同时配置requests和limits&lt;/h3&gt;
&lt;p&gt;[root@docker-server1 pods]# vim nginx-pods.yaml &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;apiVersion: v1
kind: Pod
metadata:
  annotations:
    test: this is a test app
  labels:
    app: nginx
  name: nginx
  namespace: default
spec:
  containers:
  &lt;/span&gt;- &lt;span&gt;env&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;-&lt;span&gt; name: test
      value: aaa
    &lt;/span&gt;-&lt;span&gt; name: test1
      value: bbb
    image: nginx
    imagePullPolicy: Always
    name: nginx
    ports:
    &lt;/span&gt;- containerPort: &lt;span&gt;80&lt;/span&gt;&lt;span&gt;
      hostPort: &lt;/span&gt;&lt;span&gt;8080&lt;/span&gt;&lt;span&gt;
      protocol: TCP
    resources:
      requests:
        cpu: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0.2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        memory: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;128Mi&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
  -&lt;span&gt; command:
    &lt;/span&gt;- &lt;span&gt;sh&lt;/span&gt;
    - -&lt;span&gt;c
    &lt;/span&gt;- &lt;span&gt;sleep&lt;/span&gt; &lt;span&gt;3600&lt;/span&gt;&lt;span&gt;
    image: busybox
    imagePullPolicy: Always
    name: busybox
    resources:
      limits:
        cpu: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        memory: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;128Mi&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  restartPolicy: Always&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;[root@docker-server1 pods]# kubectl delete pod nginx&lt;/p&gt;
&lt;p&gt;[root@docker-server1 pods]# kubectl apply -f nginx-pods.yaml &lt;/p&gt;
&lt;p&gt;[root@docker-server1 pods]# kubectl describe pods nginx&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Name:         nginx
Namespace:    default
Priority:     &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
Node:         &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;132.133&lt;/span&gt;/&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;132.133&lt;/span&gt;&lt;span&gt;
Start Time:   Thu, &lt;/span&gt;&lt;span&gt;09&lt;/span&gt; Jan &lt;span&gt;2020&lt;/span&gt; &lt;span&gt;19&lt;/span&gt;:&lt;span&gt;07&lt;/span&gt;:&lt;span&gt;55&lt;/span&gt; -&lt;span&gt;0500&lt;/span&gt;&lt;span&gt;
Labels:       app&lt;/span&gt;=&lt;span&gt;nginx
Annotations:  kubectl.kubernetes.io&lt;/span&gt;/&lt;span&gt;last&lt;/span&gt;-applied-&lt;span&gt;configuration:
                {&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;apiVersion&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;v1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;kind&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Pod&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;metadata&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:{&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;annotations&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:{&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;this is a test app&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;},&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;labels&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:{&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;app&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;nginx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;},&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;nginx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;namespace...&lt;/span&gt;
&lt;span&gt;              test: this is a test app
Status:       Pending
IP:           
IPs:          &lt;/span&gt;&amp;lt;none&amp;gt;&lt;span&gt;
Containers:
  nginx:
    Container ID:   
    Image:          nginx
    Image ID:       
    Port:           &lt;/span&gt;&lt;span&gt;80&lt;/span&gt;/&lt;span&gt;TCP
    Host Port:      &lt;/span&gt;&lt;span&gt;8080&lt;/span&gt;/&lt;span&gt;TCP
    State:          Waiting
      Reason:       ContainerCreating
    Ready:          False
    Restart Count:  &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
    Requests:
      cpu:     200m
      memory:  128Mi
    Environment:
      test:   aaa
      test1:  bbb
    Mounts:
      &lt;/span&gt;/var/run/secrets/kubernetes.io/serviceaccount from default-token-&lt;span&gt;bwbrn (ro)
  busybox:
    Container ID:  
    Image:         busybox
    Image ID:      
    Port:          &lt;/span&gt;&amp;lt;none&amp;gt;&lt;span&gt;
    Host Port:     &lt;/span&gt;&amp;lt;none&amp;gt;&lt;span&gt;
    Command:
      &lt;/span&gt;&lt;span&gt;sh&lt;/span&gt;
      -&lt;span&gt;c
      &lt;/span&gt;&lt;span&gt;sleep&lt;/span&gt; &lt;span&gt;3600&lt;/span&gt;&lt;span&gt;
    State:          Waiting
      Reason:       ContainerCreating
    Ready:          False
    Restart Count:  &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
    Limits:
      cpu:     &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
      memory:  128Mi
    Requests:      #自己定义了requests
      cpu:        &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
      memory:     128Mi
    Environment:  &lt;/span&gt;&amp;lt;none&amp;gt;&lt;span&gt;
    Mounts:
      &lt;/span&gt;/var/run/secrets/kubernetes.io/serviceaccount from default-token-&lt;span&gt;bwbrn (ro)
Conditions:
  Type              Status
  Initialized       True 
  Ready             False 
  ContainersReady   False 
  PodScheduled      True 
Volumes:
  default&lt;/span&gt;-token-&lt;span&gt;bwbrn:
    Type:        Secret (a volume populated by a Secret)
    SecretName:  default&lt;/span&gt;-token-&lt;span&gt;bwbrn
    Optional:    &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
QoS Class:       Burstable
Node&lt;/span&gt;-Selectors:  &amp;lt;none&amp;gt;&lt;span&gt;
Tolerations:     node.kubernetes.io&lt;/span&gt;/not-ready:NoExecute &lt;span&gt;for&lt;/span&gt;&lt;span&gt; 300s
                 node.kubernetes.io&lt;/span&gt;/unreachable:NoExecute &lt;span&gt;for&lt;/span&gt;&lt;span&gt; 300s
Events:
  Type    Reason     Age   From                      Message
  &lt;/span&gt;----    ------     ----  ----                      -------&lt;span&gt;
  Normal  Pulling    7s    kubelet, &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;132.133&lt;/span&gt;  Pulling image &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;nginx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  Normal  Scheduled  6s    default&lt;/span&gt;-scheduler         Successfully assigned default/nginx to &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;132.133&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;说明定义了limites，会自动定义一个和limites相同资源的requests，但是不定义limits，也不会定义limits设置&lt;/p&gt;
&lt;h2&gt;二 pods对容器的健将检查&lt;/h2&gt;
&lt;h3&gt;2.1 健康检查种类&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;pod通过LivenessProbe和ReadinessProbe两种探针来检查容器的健康状态：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1 LivenessProbe用于判断容器是否健康，如果LivenessProbe探测到容器不健康，kubelet将删除该容器并根据容器的重启策略做相应的处理。如果容器不包含LivenessProbe，则kubelet认为该容器的LivenessProbe探针永远返回sucess。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2 ReadinessProbe用于判断容器是否启动完成且准备接受请求。如果该探针探测到失败，则Endpoint Controoler将会从Service的Endpoint中删除包含该容器Pod的条目。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;使用httpGet配置示例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;livenessProbe: 
  httpGet: 
    path: &lt;/span&gt;/&lt;span&gt;
    port: &lt;/span&gt;&lt;span&gt;80&lt;/span&gt;&lt;span&gt; 
    httpHeaders: 
    &lt;/span&gt;- name: X-Custom-&lt;span&gt;Header 
      value: Awesome 
  initialDelaySeconds: &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;   #容器延迟检查时间
  periodSeconds: &lt;/span&gt;&lt;span&gt;3         #每3秒探测一次&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;检查执行操作就是：curl -H 　&quot;X-Custom-Header:Awesome&quot;  http://127.0.01:80/     使用curl传递一个头部来检查80端口根&lt;/p&gt;
&lt;p&gt;查看官方介绍&lt;a href=&quot;https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/&quot;&gt;https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/&lt;/a&gt;&lt;/p&gt;
&lt;p id=&quot;define-a-liveness-HTTP-request&quot;&gt;探测器参数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
initialDelaySeconds：容器启动后要等待多少秒后存活和就绪探测器才被初始化，默认是 &lt;span&gt;0&lt;/span&gt; 秒，最小值是 &lt;span&gt;0&lt;/span&gt;&lt;span&gt;。
periodSeconds：执行探测的时间间隔（单位是秒）。默认是 &lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 秒。最小值是 &lt;span&gt;1&lt;/span&gt;&lt;span&gt;。
timeoutSeconds：探测的超时后等待多少秒。默认值是 &lt;/span&gt;&lt;span&gt;1&lt;/span&gt; 秒。最小值是 &lt;span&gt;1&lt;/span&gt;&lt;span&gt;。
successThreshold：探测器在失败后，被视为成功的最小连续成功数。默认值是 &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;。存活探测的这个值必须是 &lt;span&gt;1&lt;/span&gt;。最小值是 &lt;span&gt;1&lt;/span&gt;&lt;span&gt;。
failureThreshold：当 Pod 启动了并且探测到失败，Kubernetes 的重试次数。存活探测情况下的放弃就意味着重新启动容器。就绪探测情况下的放弃 Pod 会被打上未就绪的标签。默认值是 &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;。最小值是 &lt;span&gt;1&lt;/span&gt;。
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;define-a-liveness-HTTP-request&quot;&gt;2.2 定义一个存活态 HTTP 请求接口&lt;/h3&gt;
&lt;p&gt;示例配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;apiVersion: v1
kind: Pod
metadata:
  labels:
    test: liveness
  name: liveness&lt;/span&gt;-&lt;span&gt;http
spec:
  containers:
  &lt;/span&gt;-&lt;span&gt; name: liveness
    image: k8s.gcr.io&lt;/span&gt;/&lt;span&gt;liveness
    args:
    &lt;/span&gt;- /&lt;span&gt;server
    livenessProbe:
      httpGet:
        path: &lt;/span&gt;/&lt;span&gt;healthz
        port: &lt;/span&gt;&lt;span&gt;8080&lt;/span&gt;&lt;span&gt;
        httpHeaders:
        &lt;/span&gt;- name: X-Custom-&lt;span&gt;Header
          value: Awesome
      initialDelaySeconds: &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;
      periodSeconds: &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在这个配置文件中，可以看到 Pod 也只有一个容器。&lt;code&gt;periodSeconds&lt;/code&gt; 字段指定了 kubelet 每隔 3 秒执行一次存活探测。&lt;code&gt;initialDelaySeconds&lt;/code&gt; 字段告诉 kubelet 在执行第一次探测前应该等待 3 秒。kubelet 会向容器内运行的服务（服务会监听 8080 端口）发送一个 HTTP GET 请求来执行探测。如果服务上 &lt;code&gt;/healthz&lt;/code&gt; 路径下的处理程序返回成功码，则 kubelet 认为容器是健康存活的。如果处理程序返回失败码，则 kubelet 会杀死这个容器并且重新启动它。&lt;/p&gt;
&lt;p&gt;　　任何大于或等于 200 并且小于 400 的返回码标示成功，其它返回码都标示失败。&lt;/p&gt;
&lt;p&gt;HTTP 探测器可以在 &lt;code&gt;httpGet&lt;/code&gt; 上配置额外的字段&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;host：连接使用的主机名，默认是 Pod 的 IP。也可以在 HTTP 头中设置 “Host” 来代替。
scheme ：用于设置连接主机的方式（HTTP 还是 HTTPS）。默认是 HTTP。
path：访问 HTTP 服务的路径。
httpHeaders：请求中自定义的 HTTP 头。HTTP 头字段允许重复。
port：访问容器的端口号或者端口名。如果数字必须在 &lt;/span&gt;&lt;span&gt;1&lt;/span&gt; ～ &lt;span&gt;65535&lt;/span&gt; 之间。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　对于 HTTP 探测，kubelet 发送一个 HTTP 请求到指定的路径和端口来执行检测。除非 httpGet 中的 host 字段设置了，否则 kubelet 默认是给 Pod 的 IP 地址发送探测。如果 scheme 字段设置为了 HTTPS，kubelet 会跳过证书验证发送 HTTPS 请求。大多数情况下，不需要设置host 字段。这里有个需要设置 host 字段的场景，假设容器监听 127.0.0.1，并且 Pod 的 hostNetwork 字段设置为了 true。那么 httpGet 中的 host 字段应该设置为 127.0.0.1。可能更常见的情况是如果 Pod 依赖虚拟主机，你不应该设置 host 字段，而是应该在 httpHeaders 中设置 Host。&lt;/p&gt;
&lt;h3&gt;2.3 基于conmand探测&lt;/h3&gt;
&lt;p&gt;许多长时间运行的应用程序最终会过渡到断开的状态，除非重新启动，否则无法恢复。Kubernetes 提供了存活探测器来发现并补救这种情况&lt;/p&gt;
&lt;p&gt;配置实例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;apiVersion: v1
kind: Pod
metadata:
  labels:
    test: liveness
  name: liveness&lt;/span&gt;-&lt;span&gt;exec
spec:
  containers:
  &lt;/span&gt;-&lt;span&gt; name: liveness
    image: k8s.gcr.io&lt;/span&gt;/&lt;span&gt;busybox
    args:
    &lt;/span&gt;- /bin/&lt;span&gt;sh&lt;/span&gt;
    - -&lt;span&gt;c
    &lt;/span&gt;- &lt;span&gt;touch&lt;/span&gt; /tmp/healthy; &lt;span&gt;sleep&lt;/span&gt; &lt;span&gt;30&lt;/span&gt;; &lt;span&gt;rm&lt;/span&gt; -rf /tmp/healthy; &lt;span&gt;sleep&lt;/span&gt; &lt;span&gt;600&lt;/span&gt;&lt;span&gt;
    livenessProbe:
      exec:
        command:
        &lt;/span&gt;- &lt;span&gt;cat&lt;/span&gt;
        - /tmp/&lt;span&gt;healthy
      initialDelaySeconds: &lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;
      periodSeconds: &lt;/span&gt;&lt;span&gt;5&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这个配置文件中，可以看到 Pod 中只有一个容器。&lt;code&gt;periodSeconds&lt;/code&gt; 字段指定了 kubelet 应该每 5 秒执行一次存活探测。&lt;code&gt;initialDelaySeconds&lt;/code&gt; 字段告诉 kubelet 在执行第一次探测前应该等待 5 秒。kubelet 在容器内执行命令 &lt;code&gt;cat /tmp/healthy&lt;/code&gt; 来进行探测。如果命令执行成功并且返回值为 0，kubelet 就会认为这个容器是健康存活的。如果这个命令返回非 0 值，kubelet 会杀死这个容器并重新启动它。&lt;/p&gt;
&lt;p&gt;当容器启动时，执行如下的命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
/bin/&lt;span&gt;sh&lt;/span&gt; -c &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;touch /tmp/healthy; sleep 30; rm -rf /tmp/healthy; sleep 600&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2.4 操作测试&lt;/h3&gt;
&lt;p&gt;[root@docker-server1 pods]# vim busybox-healthcheck.yaml&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1624149/202001/1624149-20200112144719073-1833612992.png&quot; alt=&quot;&quot; width=&quot;806&quot; height=&quot;369&quot;/&gt;&lt;/p&gt;
&lt;p&gt;[root@docker-server1 pods]# kubectl apply -f busybox-healthcheck.yaml&lt;/p&gt;
&lt;p&gt;[root@docker-server1 pods]# kubectl get pods&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;NAME            READY   STATUS    RESTARTS   AGE
liveness&lt;/span&gt;-exec   &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;     Running   &lt;span&gt;0&lt;/span&gt;&lt;span&gt;          9s
nginx           &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;/&lt;span&gt;2&lt;/span&gt;     Running   &lt;span&gt;1&lt;/span&gt;          97m
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;[root@docker-&lt;span&gt;server1 pods]# kubectl get pods&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;
NAME            READY   STATUS    RESTARTS   AGE
liveness&lt;/span&gt;-exec   &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;     Running   &lt;span&gt;1&lt;/span&gt;&lt;span&gt;          79s    #已经有一次restart
nginx           &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;/&lt;span&gt;2&lt;/span&gt;     Running   &lt;span&gt;1&lt;/span&gt;          98m
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;[root@docker-server1 pods]# kubectl describe pods liveness-exec&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
Name:         liveness-&lt;span&gt;exec
Namespace:    default
Priority:     &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
Node:         &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;132.132&lt;/span&gt;/&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;132.132&lt;/span&gt;&lt;span&gt;
Start Time:   Thu, &lt;/span&gt;&lt;span&gt;09&lt;/span&gt; Jan &lt;span&gt;2020&lt;/span&gt; &lt;span&gt;20&lt;/span&gt;:&lt;span&gt;45&lt;/span&gt;:&lt;span&gt;50&lt;/span&gt; -&lt;span&gt;0500&lt;/span&gt;&lt;span&gt;
Labels:       test&lt;/span&gt;=&lt;span&gt;liveness
Annotations:  kubectl.kubernetes.io&lt;/span&gt;/&lt;span&gt;last&lt;/span&gt;-applied-&lt;span&gt;configuration:
                {&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;apiVersion&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;v1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;kind&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Pod&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;metadata&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:{&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;annotations&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:{},&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;labels&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:{&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;liveness&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;},&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;liveness-exec&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;},&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;s...&lt;/span&gt;
&lt;span&gt;Status:       Running
IP:           &lt;/span&gt;&lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;1.6&lt;/span&gt;&lt;span&gt;
IPs:
  IP:  &lt;/span&gt;&lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;1.6&lt;/span&gt;&lt;span&gt;
Containers:
  liveness:
    Container ID:  docker:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;b864e74fd7fc0c16f39d7b8ecaec1d771c5a63139fe4907b5d07389cc88d9f86&lt;/span&gt;
    Image:         k8s.gcr.io/&lt;span&gt;busybox
    Image ID:      docker&lt;/span&gt;-pullable:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;k8s.gcr.io/busybox@sha256:d8d3bc2c183ed2f9f10e7258f84971202325ee6011ba137112e01e30f206de67&lt;/span&gt;
    Port:          &amp;lt;none&amp;gt;&lt;span&gt;
    Host Port:     &lt;/span&gt;&amp;lt;none&amp;gt;&lt;span&gt;
    Args:
      &lt;/span&gt;/bin/&lt;span&gt;sh&lt;/span&gt;
      -&lt;span&gt;c
      &lt;/span&gt;&lt;span&gt;touch&lt;/span&gt; /tmp/healthy; &lt;span&gt;sleep&lt;/span&gt; &lt;span&gt;30&lt;/span&gt;; &lt;span&gt;rm&lt;/span&gt; -rf /tmp/healthy; &lt;span&gt;sleep&lt;/span&gt; &lt;span&gt;600&lt;/span&gt;&lt;span&gt;
    State:          Running
      Started:      Thu, &lt;/span&gt;&lt;span&gt;09&lt;/span&gt; Jan &lt;span&gt;2020&lt;/span&gt; &lt;span&gt;20&lt;/span&gt;:&lt;span&gt;48&lt;/span&gt;:&lt;span&gt;24&lt;/span&gt; -&lt;span&gt;0500&lt;/span&gt;&lt;span&gt;
    Last State:     Terminated
      Reason:       Error
      Exit Code:    &lt;/span&gt;&lt;span&gt;137&lt;/span&gt;&lt;span&gt;
      Started:      Thu, &lt;/span&gt;&lt;span&gt;09&lt;/span&gt; Jan &lt;span&gt;2020&lt;/span&gt; &lt;span&gt;20&lt;/span&gt;:&lt;span&gt;47&lt;/span&gt;:&lt;span&gt;08&lt;/span&gt; -&lt;span&gt;0500&lt;/span&gt;&lt;span&gt;
      Finished:     Thu, &lt;/span&gt;&lt;span&gt;09&lt;/span&gt; Jan &lt;span&gt;2020&lt;/span&gt; &lt;span&gt;20&lt;/span&gt;:&lt;span&gt;48&lt;/span&gt;:&lt;span&gt;22&lt;/span&gt; -&lt;span&gt;0500&lt;/span&gt;&lt;span&gt;
    Ready:          True
    Restart Count:  &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
    Liveness:       exec [&lt;/span&gt;&lt;span&gt;cat&lt;/span&gt; /tmp/healthy] delay=5s timeout=1s period=5s #success=&lt;span&gt;1&lt;/span&gt; #failure=&lt;span&gt;3&lt;/span&gt;&lt;span&gt;
    Environment:    &lt;/span&gt;&amp;lt;none&amp;gt;&lt;span&gt;
    Mounts:
      &lt;/span&gt;/var/run/secrets/kubernetes.io/serviceaccount from default-token-&lt;span&gt;bwbrn (ro)
Conditions:
  Type              Status
  Initialized       True 
  Ready             True 
  ContainersReady   True 
  PodScheduled      True 
Volumes:
  default&lt;/span&gt;-token-&lt;span&gt;bwbrn:
    Type:        Secret (a volume populated by a Secret)
    SecretName:  default&lt;/span&gt;-token-&lt;span&gt;bwbrn
    Optional:    &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
QoS Class:       BestEffort
Node&lt;/span&gt;-Selectors:  &amp;lt;none&amp;gt;&lt;span&gt;
Tolerations:     node.kubernetes.io&lt;/span&gt;/not-ready:NoExecute &lt;span&gt;for&lt;/span&gt;&lt;span&gt; 300s
                 node.kubernetes.io&lt;/span&gt;/unreachable:NoExecute &lt;span&gt;for&lt;/span&gt;&lt;span&gt; 300s
Events:
  Type     Reason     Age                       From                      Message
  &lt;/span&gt;----     ------     ----                      ----                      -------&lt;span&gt;
  Normal   Scheduled  2m36s                     default&lt;/span&gt;-scheduler         Successfully assigned default/liveness-exec to &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;132.132&lt;/span&gt;&lt;span&gt;
  Warning  Unhealthy  3s (x6 over 87s)          kubelet, &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;132.132&lt;/span&gt;  Liveness probe failed: &lt;span&gt;cat&lt;/span&gt;: can&lt;span&gt;'&lt;/span&gt;&lt;span&gt;t open &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;/tmp/healthy&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: No such file or directory    #这里已经有一个不健康的状态&lt;/span&gt;
  Normal   Killing    3s (x2 over 78s)          kubelet, &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;132.132&lt;/span&gt;&lt;span&gt;  Container liveness failed liveness probe, will be restarted
  Normal   Pulling    &lt;/span&gt;&amp;lt;invalid&amp;gt; (x3 over 2m3s)  kubelet, &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;132.132&lt;/span&gt;  Pulling image &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;k8s.gcr.io/busybox&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  Normal   Pulled     &lt;/span&gt;&amp;lt;invalid&amp;gt; (x3 over 119s)  kubelet, &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;132.132&lt;/span&gt;  Successfully pulled image &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;k8s.gcr.io/busybox&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  Normal   Created    &lt;/span&gt;&amp;lt;invalid&amp;gt; (x3 over 119s)  kubelet, &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;132.132&lt;/span&gt;&lt;span&gt;  Created container liveness
  Normal   Started    &lt;/span&gt;&amp;lt;invalid&amp;gt; (x3 over 119s)  kubelet, &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;132.132&lt;/span&gt;  Started container liveness
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里在杀掉后会重启，使用不重启操作&lt;/p&gt;
&lt;p&gt;[root@docker-server1 pods]# kubectl delete pods liveness-exec&lt;/p&gt;
&lt;p&gt;[root@docker-server1 pods]# vi busybox-healthcheck.yaml &lt;/p&gt;
&lt;p&gt;[root@docker-server1 pods]# kubectl apply -f busybox-healthcheck.yaml&lt;/p&gt;
&lt;p&gt;[root@docker-server1 pods]# kubectl get pods&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;NAME            READY   STATUS    RESTARTS   AGE
liveness&lt;/span&gt;-exec   &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;     Running   &lt;span&gt;0&lt;/span&gt;&lt;span&gt;          7s
nginx           &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;/&lt;span&gt;2&lt;/span&gt;     Running   &lt;span&gt;1&lt;/span&gt;          109m
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;[root@docker-server1 pods]# kubectl get pods&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;NAME            READY   STATUS    RESTARTS   AGE
liveness&lt;/span&gt;-exec   &lt;span&gt;0&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;     Error     &lt;span&gt;0&lt;/span&gt;&lt;span&gt;          2m11s    #已经失败
nginx           &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;/&lt;span&gt;2&lt;/span&gt;     Running   &lt;span&gt;1&lt;/span&gt;          111m
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;[root@docker-server1 pods]# kubectl describe pods liveness-exec&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
Name:         liveness-&lt;span&gt;exec
Namespace:    default
Priority:     &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
Node:         &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;132.132&lt;/span&gt;/&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;132.132&lt;/span&gt;&lt;span&gt;
Start Time:   Thu, &lt;/span&gt;&lt;span&gt;09&lt;/span&gt; Jan &lt;span&gt;2020&lt;/span&gt; &lt;span&gt;20&lt;/span&gt;:&lt;span&gt;57&lt;/span&gt;:&lt;span&gt;54&lt;/span&gt; -&lt;span&gt;0500&lt;/span&gt;&lt;span&gt;
Labels:       test&lt;/span&gt;=&lt;span&gt;liveness
Annotations:  kubectl.kubernetes.io&lt;/span&gt;/&lt;span&gt;last&lt;/span&gt;-applied-&lt;span&gt;configuration:
                {&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;apiVersion&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;v1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;kind&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Pod&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;metadata&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:{&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;annotations&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:{},&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;labels&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:{&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;liveness&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;},&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;liveness-exec&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;},&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;s...&lt;/span&gt;
&lt;span&gt;Status:       Failed
IP:           &lt;/span&gt;&lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;1.7&lt;/span&gt;&lt;span&gt;
IPs:
  IP:  &lt;/span&gt;&lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;1.7&lt;/span&gt;&lt;span&gt;
Containers:
  liveness:
    Container ID:  docker:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;d1bc23c8d6ef3e773ebbfeeff058eea39f1363a046df58da47e05e247c28b159&lt;/span&gt;
    Image:         k8s.gcr.io/&lt;span&gt;busybox
    Image ID:      docker&lt;/span&gt;-pullable:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;k8s.gcr.io/busybox@sha256:d8d3bc2c183ed2f9f10e7258f84971202325ee6011ba137112e01e30f206de67&lt;/span&gt;
    Port:          &amp;lt;none&amp;gt;&lt;span&gt;
    Host Port:     &lt;/span&gt;&amp;lt;none&amp;gt;&lt;span&gt;
    Args:
      &lt;/span&gt;/bin/&lt;span&gt;sh&lt;/span&gt;
      -&lt;span&gt;c
      &lt;/span&gt;&lt;span&gt;touch&lt;/span&gt; /tmp/healthy; &lt;span&gt;sleep&lt;/span&gt; &lt;span&gt;30&lt;/span&gt;; &lt;span&gt;rm&lt;/span&gt; -rf /tmp/healthy; &lt;span&gt;sleep&lt;/span&gt; &lt;span&gt;600&lt;/span&gt;&lt;span&gt;
    State:          Terminated
      Reason:       Error
      Exit Code:    &lt;/span&gt;&lt;span&gt;137&lt;/span&gt;&lt;span&gt;
      Started:      Thu, &lt;/span&gt;&lt;span&gt;09&lt;/span&gt; Jan &lt;span&gt;2020&lt;/span&gt; &lt;span&gt;20&lt;/span&gt;:&lt;span&gt;57&lt;/span&gt;:&lt;span&gt;56&lt;/span&gt; -&lt;span&gt;0500&lt;/span&gt;&lt;span&gt;
      Finished:     Thu, &lt;/span&gt;&lt;span&gt;09&lt;/span&gt; Jan &lt;span&gt;2020&lt;/span&gt; &lt;span&gt;20&lt;/span&gt;:&lt;span&gt;59&lt;/span&gt;:&lt;span&gt;10&lt;/span&gt; -&lt;span&gt;0500&lt;/span&gt;&lt;span&gt;
    Ready:          False
    Restart Count:  &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
    Liveness:       exec [&lt;/span&gt;&lt;span&gt;cat&lt;/span&gt; /tmp/healthy] delay=5s timeout=1s period=5s #success=&lt;span&gt;1&lt;/span&gt; #failure=&lt;span&gt;3&lt;/span&gt;&lt;span&gt;
    Environment:    &lt;/span&gt;&amp;lt;none&amp;gt;&lt;span&gt;
    Mounts:
      &lt;/span&gt;/var/run/secrets/kubernetes.io/serviceaccount from default-token-&lt;span&gt;bwbrn (ro)
Conditions:
  Type              Status
  Initialized       True 
  Ready             False 
  ContainersReady   False 
  PodScheduled      True 
Volumes:
  default&lt;/span&gt;-token-&lt;span&gt;bwbrn:
    Type:        Secret (a volume populated by a Secret)
    SecretName:  default&lt;/span&gt;-token-&lt;span&gt;bwbrn
    Optional:    &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
QoS Class:       BestEffort
Node&lt;/span&gt;-Selectors:  &amp;lt;none&amp;gt;&lt;span&gt;
Tolerations:     node.kubernetes.io&lt;/span&gt;/not-ready:NoExecute &lt;span&gt;for&lt;/span&gt;&lt;span&gt; 300s
                 node.kubernetes.io&lt;/span&gt;/unreachable:NoExecute &lt;span&gt;for&lt;/span&gt;&lt;span&gt; 300s
Events:
  Type     Reason     Age                From                      Message
  &lt;/span&gt;----     ------     ----               ----                      -------&lt;span&gt;
  Normal   Scheduled  2m9s               default&lt;/span&gt;-scheduler         Successfully assigned default/liveness-exec to &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;132.132&lt;/span&gt;&lt;span&gt;
  Normal   Pulling    96s                kubelet, &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;132.132&lt;/span&gt;  Pulling image &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;k8s.gcr.io/busybox&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  Normal   Pulled     95s                kubelet, &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;132.132&lt;/span&gt;  Successfully pulled image &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;k8s.gcr.io/busybox&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  Normal   Created    95s                kubelet, &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;132.132&lt;/span&gt;&lt;span&gt;  Created container liveness
  Normal   Started    95s                kubelet, &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;132.132&lt;/span&gt;&lt;span&gt;  Started container liveness
  Warning  Unhealthy  51s (x3 over 61s)  kubelet, &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;132.132&lt;/span&gt;  Liveness probe failed: &lt;span&gt;cat&lt;/span&gt;: can&lt;span&gt;'&lt;/span&gt;&lt;span&gt;t open &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;/tmp/healthy&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: No such file or directory&lt;/span&gt;
  Normal   Killing    51s                kubelet, &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;132.132&lt;/span&gt;  Stopping container liveness
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;define-a-TCP-liveness-probe&quot;&gt;2.5 定义 TCP 的存活探测&lt;/h3&gt;
&lt;p&gt;第三种类型的存活探测是使用 TCP 套接字。通过配置，kubelet 会尝试在指定端口和容器建立套接字链接。如果能建立链接，这个容器就被看作是健康的，如果不能则这个容器就被看作是有问题的。&lt;/p&gt;
&lt;p&gt;实例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;apiVersion: v1
kind: Pod
metadata:
  name: goproxy
  labels:
    app: goproxy
spec:
  containers:
  &lt;/span&gt;-&lt;span&gt; name: goproxy
    image: k8s.gcr.io&lt;/span&gt;/goproxy:&lt;span&gt;0.1&lt;/span&gt;&lt;span&gt;
    ports:
    &lt;/span&gt;- containerPort: &lt;span&gt;8080&lt;/span&gt;&lt;span&gt;
    readinessProbe:
      tcpSocket:
        port: &lt;/span&gt;&lt;span&gt;8080&lt;/span&gt;&lt;span&gt;
      initialDelaySeconds: &lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;
      periodSeconds: &lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;
    livenessProbe:
      tcpSocket:
        port: &lt;/span&gt;&lt;span&gt;8080&lt;/span&gt;&lt;span&gt;
      initialDelaySeconds: &lt;/span&gt;&lt;span&gt;15&lt;/span&gt;&lt;span&gt;
      periodSeconds: &lt;/span&gt;&lt;span&gt;20&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　TCP 检测的配置和 HTTP 检测非常相似。下面这个例子同时使用就绪和存活探测器。kubelet 会在容器启动 5 秒后发送第一个就绪探测。这会尝试连接 &lt;code&gt;goproxy&lt;/code&gt; 容器的 8080 端口。如果探测成功，这个 Pod 会被标记为就绪状态，kubelet 将继续每隔 10 秒运行一次检测。&lt;/p&gt;
&lt;p&gt;　　除了就绪探测，这个配置包括了一个存活探测。kubelet 会在容器启动 15 秒后进行第一次存活探测。就像就绪探测一样，会尝试连接 &lt;code&gt;goproxy&lt;/code&gt; 容器的 8080 端口。如果存活探测失败，这个容器会被重新启动&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
kubectl apply -f https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;k8s.io/examples/pods/probe/tcp-liveness-readiness.yaml&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;三 pod的其他操作&lt;/h2&gt;
&lt;p&gt;初始化容器&lt;/p&gt;
&lt;p&gt;Init Container在所有容器运行之前执行（run-to-completion），常用来初始化配置。就是在业务容器启动之前，启动一个临时的初始化容器，用于完成业务容器启动之前的初始化操作，当初始化容器完成初始化任务后，然后退出，业务容器开始启动&lt;/p&gt;
&lt;p&gt;先学习volume挂载&lt;/p&gt;
&lt;h3&gt;3.1 volume挂载&lt;/h3&gt;
&lt;p&gt;[root@docker-server1 pods]# vim nginx-pods-volumes.yaml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;apiVersion: v1
kind: Pod
metadata:
  annotations:
    test: this is a test app
  labels:
    app: nginx
  name: nginx&lt;/span&gt;-&lt;span&gt;volume
  namespace: default
spec:
  volumes: 
    &lt;/span&gt;-&lt;span&gt; name: datadir
      hostPath:
        path: &lt;/span&gt;/&lt;span&gt;data
  containers:
  &lt;/span&gt;- &lt;span&gt;env&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;-&lt;span&gt; name: test
      value: aaa
    &lt;/span&gt;-&lt;span&gt; name: test1
      value: bbb
    volumeMounts:
      &lt;/span&gt;-&lt;span&gt; name: datadir
        mountPath: &lt;/span&gt;/usr/share/nginx/&lt;span&gt;html
    image: nginx
    imagePullPolicy: Always
    name: nginx
    ports:
    &lt;/span&gt;- containerPort: &lt;span&gt;80&lt;/span&gt;&lt;span&gt;
      hostPort: &lt;/span&gt;&lt;span&gt;8080&lt;/span&gt;&lt;span&gt;
      protocol: TCP
    resources:
      requests:
        cpu: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0.2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        memory: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;128Mi&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  restartPolicy: Always&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;[root@docker-server1 pods]# kubectl apply -f nginx-pods-volumes.yaml&lt;/p&gt;
&lt;p&gt;[root@docker-server1 pods]# kubectl get pods&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;NAME           READY   STATUS    RESTARTS   AGE
goproxy        &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;     Running   &lt;span&gt;0&lt;/span&gt;&lt;span&gt;          38m
nginx          &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;/&lt;span&gt;2&lt;/span&gt;     Running   &lt;span&gt;2&lt;/span&gt;&lt;span&gt;          166m
nginx&lt;/span&gt;-volume   &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;     Running   &lt;span&gt;0&lt;/span&gt;          68s
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;[root@docker-server1 pods]# kubectl get pods -o wide&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;NAME           READY   STATUS    RESTARTS   AGE    IP            NODE              NOMINATED NODE   READINESS GATES
goproxy        &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;     Running   &lt;span&gt;0&lt;/span&gt;          38m    &lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;1.8&lt;/span&gt;    &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;132.132&lt;/span&gt;   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;&lt;span&gt;
nginx          &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;/&lt;span&gt;2&lt;/span&gt;     Running   &lt;span&gt;2&lt;/span&gt;          166m   &lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;2.10&lt;/span&gt;   &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;132.133&lt;/span&gt;   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;&lt;span&gt;
nginx&lt;/span&gt;-volume   &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;     Running   &lt;span&gt;0&lt;/span&gt;          105s   &lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;1.9&lt;/span&gt;    &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;132.132&lt;/span&gt;   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;[root@docker-server1 pods]# curl http://10.244.1.9&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;html&amp;gt;
&amp;lt;&lt;span&gt;head&lt;/span&gt;&amp;gt;&amp;lt;title&amp;gt;&lt;span&gt;403&lt;/span&gt; Forbidden&amp;lt;/title&amp;gt;&amp;lt;/&lt;span&gt;head&lt;/span&gt;&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;center&amp;gt;&amp;lt;h1&amp;gt;&lt;span&gt;403&lt;/span&gt; Forbidden&amp;lt;/h1&amp;gt;&amp;lt;/center&amp;gt;
&amp;lt;hr&amp;gt;&amp;lt;center&amp;gt;nginx/&lt;span&gt;1.17&lt;/span&gt;.&lt;span&gt;7&lt;/span&gt;&amp;lt;/center&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;容器运行在docker-server2上&lt;/p&gt;
&lt;p&gt;[root@docker-server2 ~]# echo  &quot;index on docker-server2&quot;  &amp;gt; /data/index.html&lt;/p&gt;
&lt;p&gt;再次访问&lt;/p&gt;
&lt;p&gt;[root@docker-server1 pods]# curl http://10.244.1.9&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1624149/202001/1624149-20200112155519720-841500483.png&quot; alt=&quot;&quot; width=&quot;602&quot; height=&quot;23&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过这种方式可以挂载一个容器卷，但是不可取，因为挂载本地目录，k8s容器换到其他节点，数据就会变化&lt;/p&gt;
&lt;h3&gt;3.2 初始化容器&lt;/h3&gt;
&lt;p&gt;[root@docker-server1 pods]# vim init-container.yaml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;apiVersion: v1
kind: Pod
metadata:
  name: init&lt;/span&gt;-&lt;span&gt;demo
spec:
  initContainers:
  &lt;/span&gt;- name: &lt;span&gt;install&lt;/span&gt;&lt;span&gt;
    image: busybox
    command:
      &lt;/span&gt;- &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sh&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
      - &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-c&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
      - &amp;gt;
        &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;nginx in kubernetes&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;gt; /work-&lt;span&gt;dir&lt;/span&gt;/&lt;span&gt;index.html
    volumeMounts:
      &lt;/span&gt;-&lt;span&gt; name: workdir
        mountPath: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/work-dir&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  volumes:
  &lt;/span&gt;-&lt;span&gt; name: workdir
    emptyDir: {}
  containers:
    &lt;/span&gt;-&lt;span&gt; name: nginx
      image: nginx
      ports:
        &lt;/span&gt;- containerPort: &lt;span&gt;80&lt;/span&gt;&lt;span&gt;
      volumeMounts:
        &lt;/span&gt;-&lt;span&gt; name: workdir
          mountPath: &lt;/span&gt;/usr/share/nginx/html 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;emptyDir: {}这个不指定，表示会在本地找一个临时的目录，挂载到容器中，生命周期的容器相同，但是这个目录可以让两个容器都可以看到，这样当初始化容器任务结束后，业务容器就可以读取这个目录中的数据&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;[root@docker-server1 pods]# kubectl apply -f init-container.yaml &lt;/p&gt;
&lt;p&gt;[root@docker-server1 pods]# kubectl get pods&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;NAME           READY   STATUS    RESTARTS   AGE
goproxy        &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;     Running   &lt;span&gt;0&lt;/span&gt;&lt;span&gt;          58m
init&lt;/span&gt;-demo      &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;     Running   &lt;span&gt;0&lt;/span&gt;&lt;span&gt;          40s
nginx          &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;/&lt;span&gt;2&lt;/span&gt;     Running   &lt;span&gt;3&lt;/span&gt;&lt;span&gt;          3h6m
nginx&lt;/span&gt;-volume   &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;     Running   &lt;span&gt;0&lt;/span&gt;          21m
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;[root@docker-server1 pods]# kubectl get pods -o wide&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;NAME           READY   STATUS    RESTARTS   AGE    IP            NODE              NOMINATED NODE   READINESS GATES
goproxy        &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;     Running   &lt;span&gt;0&lt;/span&gt;          58m    &lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;1.8&lt;/span&gt;    &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;132.132&lt;/span&gt;   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;&lt;span&gt;
init&lt;/span&gt;-demo      &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;     Running   &lt;span&gt;0&lt;/span&gt;          44s    &lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;1.10&lt;/span&gt;   &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;132.132&lt;/span&gt;   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;&lt;span&gt;
nginx          &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;/&lt;span&gt;2&lt;/span&gt;     Running   &lt;span&gt;3&lt;/span&gt;          3h6m   &lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;2.10&lt;/span&gt;   &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;132.133&lt;/span&gt;   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;&lt;span&gt;
nginx&lt;/span&gt;-volume   &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;     Running   &lt;span&gt;0&lt;/span&gt;          21m    &lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;1.9&lt;/span&gt;    &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;132.132&lt;/span&gt;   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;[root@docker-server1 pods]# curl http://10.244.1.10&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1624149/202001/1624149-20200112161046131-1360458579.png&quot; alt=&quot;&quot; width=&quot;525&quot; height=&quot;37&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3.3 生命周期管理&lt;/h3&gt;
&lt;p&gt;容器生命周期的钩子&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;容器生命周期钩子（Container Lifecycle Hooks）监听容器生命周期的特定事件，并在事件发生时执行已注册的回调函数。支持两种钩子：&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;postStart： 容器创建后立即执行，注意由于是异步执行，它无法保证一定在ENTRYPOINT之前运行。如果失败，容器会被杀死，并根据RestartPolicy决定是否重启&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;preStop：容器终止前执行，常用于资源清理。如果失败，容器同样也会被杀死&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;而钩子的回调函数支持两种方式：&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;exec：在容器内执行命令，如果命令的退出状态码是0表示执行成功，否则表示失败&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;httpGet：向指定URL发起GET请求，如果返回的HTTP状态码在[200, 400)之间表示请求成功，否则表示失败&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;[root@docker-server1 pods]# vim nginx-pods-lifecycle.yaml &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;apiVersion: v1
kind: Pod
metadata:
  name: lifecycle&lt;/span&gt;-&lt;span&gt;demo
spec:
  containers:
  &lt;/span&gt;- name: lifecycle-demo-&lt;span&gt;container
    image: nginx
    lifecycle:
      postStart:
        httpGet:
          path: &lt;/span&gt;/&lt;span&gt;
          port: &lt;/span&gt;&lt;span&gt;80&lt;/span&gt;&lt;span&gt;
      preStop:
        exec:
          command: [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/usr/sbin/nginx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;quit&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;[root@docker-server1 pods]# kubectl apply -f nginx-pods-lifecycle.yaml&lt;/p&gt;
&lt;p&gt;[root@docker-server1 pods]# kubectl get pods -o wide&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;NAME             READY   STATUS              RESTARTS   AGE     IP            NODE              NOMINATED NODE   READINESS GATES
goproxy          &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;     Running             &lt;span&gt;0&lt;/span&gt;          76m     &lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;1.8&lt;/span&gt;    &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;132.132&lt;/span&gt;   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;&lt;span&gt;
init&lt;/span&gt;-demo        &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;     Running             &lt;span&gt;0&lt;/span&gt;          18m     &lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;1.10&lt;/span&gt;   &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;132.132&lt;/span&gt;   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;&lt;span&gt;
lifecycle&lt;/span&gt;-demo   &lt;span&gt;0&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;     ContainerCreating   &lt;span&gt;0&lt;/span&gt;          4s      &amp;lt;none&amp;gt;        &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;132.132&lt;/span&gt;   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;&lt;span&gt;
nginx            &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;/&lt;span&gt;2&lt;/span&gt;     Running             &lt;span&gt;3&lt;/span&gt;          3h24m   &lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;2.10&lt;/span&gt;   &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;132.133&lt;/span&gt;   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;&lt;span&gt;
nginx&lt;/span&gt;-volume     &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;     Running             &lt;span&gt;0&lt;/span&gt;          39m     &lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;1.9&lt;/span&gt;    &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;132.132&lt;/span&gt;   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.4 静态POD&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　kubelet的运行方式有两种，一种是通过与kubernetes的master节点连接，接受任务并执行。另外一种则是可以作为一个独立组件运行。监听某个目录中的yml文件，当发现变化，就执行yml文件，我们可以在这个目录中定义启动Pod的yml文件，这样不需要master端，kubelet也会自行启动pod，但通过这方式启动的pod没法被master端调度。只能在当前的kubelet主机节点上运行，这种pod就被称作静态pod&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　kubeadm初始化集群的方式就是借助了静态Pod的方式将容器运行在kubelet管理的静态Pod中&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;比如在安装master节点的时候，kubeadm安装kubectl，kubelet，master节点就是以静态POD方式运行&lt;/p&gt;
&lt;p&gt;[root@docker-server1 pods]# cd /etc/kubernetes/&lt;/p&gt;
&lt;p&gt;[root@docker-server1 kubernetes]# ll&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1624149/202001/1624149-20200112163444231-1227960751.png&quot; alt=&quot;&quot; width=&quot;780&quot; height=&quot;125&quot;/&gt;&lt;/p&gt;
&lt;p&gt;[root@docker-server1 kubernetes]# cd manifests/&lt;/p&gt;
&lt;p&gt;[root@docker-server1 manifests]# ll&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1624149/202001/1624149-20200112163532429-829770183.png&quot; alt=&quot;&quot; width=&quot;777&quot; height=&quot;76&quot;/&gt;&lt;/p&gt;
&lt;p&gt;[root@docker-server1 manifests]# vim  etcd.yaml &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;apiVersion: v1
kind: Pod
metadata:
  creationTimestamp: &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
  labels:
    component: etcd
    tier: control&lt;/span&gt;-&lt;span&gt;plane
  name: etcd
  namespace: kube&lt;/span&gt;-&lt;span&gt;system
spec:
  containers:
  &lt;/span&gt;-&lt;span&gt; command:
    &lt;/span&gt;-&lt;span&gt; etcd
    &lt;/span&gt;- --advertise-client-urls=https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;192.168.132.131:2379&lt;/span&gt;
    - --cert-&lt;span&gt;file&lt;/span&gt;=/etc/kubernetes/pki/etcd/&lt;span&gt;server.crt
    &lt;/span&gt;- --client-cert-auth=&lt;span&gt;true&lt;/span&gt;
    - --data-&lt;span&gt;dir&lt;/span&gt;=/var/lib/&lt;span&gt;etcd
    &lt;/span&gt;- --initial-advertise-peer-urls=https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;192.168.132.131:2380&lt;/span&gt;
    - --initial-cluster=&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;132.131&lt;/span&gt;=https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;192.168.132.131:2380&lt;/span&gt;
    - --key-&lt;span&gt;file&lt;/span&gt;=/etc/kubernetes/pki/etcd/&lt;span&gt;server.key
    &lt;/span&gt;- --listen-client-urls=https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;127.0.0.1:2379,&lt;/span&gt;&lt;span&gt;https://192.168.132.131&lt;/span&gt;&lt;span&gt;:2379&lt;/span&gt;
    - --listen-metrics-urls=http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;127.0.0.1:2381&lt;/span&gt;
    - --listen-peer-urls=https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;192.168.132.131:2380&lt;/span&gt;
    - --name=&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;132.131&lt;/span&gt;
    - --peer-cert-&lt;span&gt;file&lt;/span&gt;=/etc/kubernetes/pki/etcd/&lt;span&gt;peer.crt
    &lt;/span&gt;- --peer-client-cert-auth=&lt;span&gt;true&lt;/span&gt;
    - --peer-key-&lt;span&gt;file&lt;/span&gt;=/etc/kubernetes/pki/etcd/&lt;span&gt;peer.key
    &lt;/span&gt;- --peer-trusted-ca-&lt;span&gt;file&lt;/span&gt;=/etc/kubernetes/pki/etcd/&lt;span&gt;ca.crt
    &lt;/span&gt;- --snapshot-count=&lt;span&gt;10000&lt;/span&gt;
    - --trusted-ca-&lt;span&gt;file&lt;/span&gt;=/etc/kubernetes/pki/etcd/&lt;span&gt;ca.crt
    image: k8s.gcr.io&lt;/span&gt;/etcd:&lt;span&gt;3.4&lt;/span&gt;.&lt;span&gt;3&lt;/span&gt;-&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
    imagePullPolicy: IfNotPresent
    livenessProbe:
      failureThreshold: &lt;/span&gt;&lt;span&gt;8&lt;/span&gt;&lt;span&gt;
      httpGet:
        host: &lt;/span&gt;&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;&lt;span&gt;
        path: &lt;/span&gt;/&lt;span&gt;health
        port: &lt;/span&gt;&lt;span&gt;2381&lt;/span&gt;&lt;span&gt;
        scheme: HTTP
      initialDelaySeconds: &lt;/span&gt;&lt;span&gt;15&lt;/span&gt;&lt;span&gt;
      timeoutSeconds: &lt;/span&gt;&lt;span&gt;15&lt;/span&gt;&lt;span&gt;
    name: etcd
    resources: {}
    volumeMounts:
    &lt;/span&gt;- mountPath: /var/lib/&lt;span&gt;etcd
      name: etcd&lt;/span&gt;-&lt;span&gt;data
    &lt;/span&gt;- mountPath: /etc/kubernetes/pki/&lt;span&gt;etcd
      name: etcd&lt;/span&gt;-&lt;span&gt;certs
  hostNetwork: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
  priorityClassName: system&lt;/span&gt;-cluster-&lt;span&gt;critical
  volumes:
  &lt;/span&gt;-&lt;span&gt; hostPath:
      path: &lt;/span&gt;/etc/kubernetes/pki/&lt;span&gt;etcd
      type: DirectoryOrCreate
    name: etcd&lt;/span&gt;-&lt;span&gt;certs
  &lt;/span&gt;-&lt;span&gt; hostPath:
      path: &lt;/span&gt;/var/lib/&lt;span&gt;etcd
      type: DirectoryOrCreate
    name: etcd&lt;/span&gt;-&lt;span&gt;data
status: {}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;尝试修改yml文件&lt;/p&gt;
&lt;p&gt;这里添加一个参数&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1624149/202001/1624149-20200112164113962-1409870446.png&quot; alt=&quot;&quot; width=&quot;804&quot; height=&quot;223&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再次查看，容器已经重启&lt;/p&gt;
&lt;p&gt;[root@docker-server1 manifests]# docker ps -a|grep apiserver&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
c28921f0415        0cae8d5cc64c           &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;kube-apiserver --ad…&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;   &lt;span&gt;37&lt;/span&gt; seconds ago       &lt;span&gt;&lt;strong&gt;Up 36 seconds&lt;/strong&gt; &lt;/span&gt;                                   k8s_kube-apiserver_kube-apiserver-&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;132&lt;/span&gt;.131_kube-&lt;span&gt;system_35be3047d357a34596bdda175ae3edd5_1
f5e6441e09a0        0cae8d5cc64c           &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;kube-apiserver --ad…&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;   &lt;span&gt;10&lt;/span&gt; hours ago         Exited (&lt;span&gt;0&lt;/span&gt;) &lt;span&gt;37&lt;/span&gt; seconds ago                        k8s_kube-apiserver_kube-apiserver-&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;132&lt;/span&gt;.131_kube-&lt;span&gt;system_35be3047d357a34596bdda175ae3edd5_0
f5aff40580f5        k8s.gcr.io&lt;/span&gt;/pause:&lt;span&gt;3.1&lt;/span&gt;   &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/pause&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;                 &lt;span&gt;10&lt;/span&gt; hours ago         Up &lt;span&gt;10&lt;/span&gt; hours                                      k8s_POD_kube-apiserver-&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;132&lt;/span&gt;.131_kube-system_35be3047d357a34596bdda175ae3edd5_0
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;关于POD的部分学习到这里&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;博主声明：本文的内容来源主要来自誉天教育晏威老师，由本人实验完成操作验证，需要的博友请联系誉天教育（http://www.yutianedu.com/），获得官方同意或者晏老师（&lt;a class=&quot;gray&quot; href=&quot;https://www.cnblogs.com/breezey/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://www.cnblogs.com/breezey/&lt;/span&gt;&lt;/a&gt;）本人同意即可转载，谢谢！&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 13 Jan 2020 00:33:00 +0000</pubDate>
<dc:creator>梦中泪</dc:creator>
<og:description>一 POD的容器资源限制 1.1 限制内容 有两个参数 QoS Class: BestEffort，表示尽可能的满足使用，级别较低，但当资源不够时，会杀掉这个容器 resources: {}这里指定为</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zyxnhr/p/12183107.html</dc:identifier>
</item>
<item>
<title>缓存中间件-缓存架构的实现（下） - 血夜之末</title>
<link>http://www.cnblogs.com/Tiancheng-Duan/p/12185507.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Tiancheng-Duan/p/12185507.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;缓存架构，说白了就是利用各种手段，来实现缓存，从而降低服务器，乃至数据库的压力。&lt;/p&gt;
&lt;p&gt;这里把之前提出的缓存架构的技术分类放出来：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;浏览器缓存
&lt;ul&gt;&lt;li&gt;Cookie&lt;/li&gt;
&lt;li&gt;LocalStorage&lt;/li&gt;
&lt;li&gt;SessionStorage&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;CDN缓存&lt;/li&gt;
&lt;li&gt;负载层缓存
&lt;ul&gt;&lt;li&gt;Nginx缓存模块&lt;/li&gt;
&lt;li&gt;Squid缓存服务器&lt;/li&gt;
&lt;li&gt;Lua扩展&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;应用层缓存
&lt;ul&gt;&lt;li&gt;Etag&lt;/li&gt;
&lt;li&gt;ThreadLocal&lt;/li&gt;
&lt;li&gt;Guava&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;外部缓存
&lt;/li&gt;
&lt;li&gt;数据库缓存
&lt;ul&gt;&lt;li&gt;MySql缓存&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;前面的&lt;a href=&quot;https://www.cnblogs.com/Tiancheng-Duan/p/12154529.html&quot;&gt;《缓存中间件-缓存架构的实现（上）》&lt;/a&gt;已经简单说明了浏览器缓存，CDN缓存，负载层缓存。这次将会继续阐述应用层缓存，外部缓存，数据库缓存。&lt;/p&gt;
&lt;h2 id=&quot;应用层缓存&quot;&gt;应用层缓存&lt;/h2&gt;
&lt;p&gt;应用层的缓存，往往用户的请求最终达到了应用服务器，但是未达到数据库，其涉及应用服务器的具体开发。&lt;/p&gt;
&lt;h3 id=&quot;etag&quot;&gt;Etag&lt;/h3&gt;
&lt;p&gt;之所以将Etag技术放在应用层缓存，是因为用户的请求必定达到应用层。&lt;/p&gt;
&lt;p&gt;Etag的意思就是，如果连续两次请求的请求内容是一致的，那么两次响应也应该是一致的。那么第一次请求的响应，就可以充当第二次请求的响应。&lt;/p&gt;
&lt;p&gt;当然实际业务中，也存在两次请求一致，但是响应不一致（如都是查询银行余额，但是并不一样，可能两次操作中间，工资到账了）。这就涉及到缓存的数据一致性问题，后面会提到。这里不再深入。&lt;/p&gt;
&lt;p&gt;那么应用服务器怎么判断两次请求一致呢。它可以通过两次请求的hash，进行对比判断。其中涉及HTTP协议，如304状态码，请求协议头If-None-Match字段，响应协议头Etag字段。&lt;/p&gt;
&lt;h4 id=&quot;请求流程&quot;&gt;请求流程&lt;/h4&gt;
&lt;p&gt;服务端已经做好了对应的开发与设置（如Spring的ShallowEtagHeaderFilter()）。&lt;/p&gt;
&lt;h5 id=&quot;第一次请求&quot;&gt;第一次请求&lt;/h5&gt;
&lt;ol&gt;&lt;li&gt;客户端发出请求RequestA&lt;/li&gt;
&lt;li&gt;服务端接收到客户端的请求RequestA，进行以下处理：
&lt;ol&gt;&lt;li&gt;在应用中，根据请求RequestA计算对应的MD5值&lt;/li&gt;
&lt;li&gt;在返回响应ResponseA的协议头中的Etag字段设置前面计算出来的MD5值&lt;/li&gt;
&lt;li&gt;返回对应页面&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;客户端接收到响应ResponseA，在浏览器中展示。并在浏览器中缓存ResponseA&lt;/li&gt;
&lt;/ol&gt;&lt;h5 id=&quot;第二次请求&quot;&gt;第二次请求&lt;/h5&gt;
&lt;ol&gt;&lt;li&gt;客户端再次发出请求RequestB，并且RequestB与RequestA请求内容相同（如都是请求同一个页面等）&lt;/li&gt;
&lt;li&gt;服务端接收到客户端的请求RequestB，进行以下处理：
&lt;ol&gt;&lt;li&gt;根据请求计算的新ETag，并判断是否与请求RequestB协议头中的If-None-Match字段对应的值（就是之前ResponseA的ETag字段的值）一致
&lt;ol&gt;&lt;li&gt;如果没有超限， 在Response中设置协议状态为304，向客户端返回对应ReponseB&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;客户端接收到响应ReponseB，确认其协议状态为304，则直接使用之前缓存的响应ResponseA，作为请求RequestB的返回响应&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;上述其实是功能逻辑，如果按照代码逻辑，其实应该这样说：&lt;/p&gt;
&lt;h5 id=&quot;客户端&quot;&gt;客户端&lt;/h5&gt;
&lt;ol&gt;&lt;li&gt;客户端准备发送请求&lt;/li&gt;
&lt;li&gt;浏览器检测该页面是否有对应的ETag字段的值&lt;/li&gt;
&lt;li&gt;如果有对应的值，就置入请求的协议头&lt;/li&gt;
&lt;li&gt;准备妥当后，浏览器想服务器发送请求&lt;/li&gt;
&lt;/ol&gt;&lt;h5 id=&quot;服务端&quot;&gt;服务端&lt;/h5&gt;
&lt;ol&gt;&lt;li&gt;根据请求的协议头，判断是否具备Last-Modified/If-None-Match字段&lt;/li&gt;
&lt;li&gt;如果有对应字段，进行以下判断
&lt;ol&gt;&lt;li&gt;根据请求计算的新ETag，并判断是否与请求协议头中的If-None-Match字段对应的值（就是之前ResponseA的ETag字段的值一致
&lt;ol&gt;&lt;li&gt;如果没有超限，在Response中设置协议状态为304，向客户端返回对应Reponse&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;如果上述2中任一条件未满足，则执行以下逻辑：
&lt;ol&gt;&lt;li&gt;在应用中，根据请求RequestA计算对应的MD5值，保存在应用中&lt;/li&gt;
&lt;li&gt;返回对应页面&lt;/li&gt;
&lt;li&gt;在返回响应ResponseA的协议头中的Etag字段设置前面计算出来的MD5值&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;准确地说，这应该是HTTP协议提供的缓存方案，而不仅仅只是ETag。因为ETag仅仅与HTTP协议的五大条件请求首部中的If-None-Match与If-Match两个首部相关。除此之外，还有If-Modified-Since，If-Unmodified-Since，If-Range三个条件请求首部。如果以后有机会专门写一篇有关HTTP协议的博客。迫切的小伙伴，也可以翻阅《HTTP权威指南》一书的第七章（尤其是7.8）。&lt;/p&gt;
&lt;h4 id=&quot;优势&quot;&gt;优势&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;降低数据库访问压力。如果ETag成功，则直接返回状态码304，没有数据库操作。&lt;/li&gt;
&lt;li&gt;降低应用服务器压力。如果ETag成功，则直接返回状态码304，无需业务操作等，如日志。&lt;/li&gt;
&lt;li&gt;降低带宽压力。根据统计表明，一般请求响应模型中，响应的报文大小远大于请求的保温大小。那么如果返回响应的主体为空，只有304状态码等协议头，则可以大大降低系统带宽压力。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;缺点&quot;&gt;缺点&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;技术学习投入。如果想要较好利用 ，需要熟悉HTTP协议的缓存设计（包括理念，架构，步骤等）&lt;/li&gt;
&lt;li&gt;需要对现有的业务体系，进行一定的调整&lt;/li&gt;
&lt;li&gt;数据刷新问题的处理，确保数据的“新鲜度”&lt;/li&gt;
&lt;li&gt;应用系统的计算资源占用。有人提出ETag的MD5计算带来了对应的应用系统的CPU占用问题。这个需要说一下：
&lt;ul&gt;&lt;li&gt;这取决于具体请求本身是否有比MD5计算更大的CPU占用问题。&lt;/li&gt;
&lt;li&gt;合理的缓存架构设计一般不会有这样的问题（如静态资源等CPU占用少的请求，根本就在前面的浏览器，CDN，负载均衡层处理掉了）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;实际应用&quot;&gt;实际应用&lt;/h4&gt;
&lt;p&gt;实际应用部分，主要有两点需要提及。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;由于If-None-Match的部分缺点，有需要的小伙伴最好引入Last-Modified-Since搭配使用&lt;/li&gt;
&lt;li&gt;实际开发方面，Spring提供了ShallowEtagHeaderFilter()，也可以自行扩展&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;PS：部分人认为只需要Last-Modified-Since即可，但是仅使用Last-Modified-Since存在以下问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1s周期内的变化，无法处理（因为Last-Modified-Since记录的最小时间单位为秒）&lt;/li&gt;
&lt;li&gt;部分数据虽然发生了变化，但其实我们所需要的内容并没有变化（如周期性的重写等）&lt;/li&gt;
&lt;li&gt;部分应用系统的系统时间存在冲突（即集群内的应用服务器实例的绝对系统时间存在秒级差别。至于集群的时间统一相关的问题，日后有机会专门写一篇博客（感觉自己立下了无数flag））。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;threadlocal&quot;&gt;ThreadLocal&lt;/h3&gt;
&lt;p&gt;ThreadLocal是什么，我就不在此解释了。不了解的小伙伴，可以这样理解：ThreadLocal就是一个类中的静态Map，其key就是执行线程（调用类实例的线程）的name，而value就是调用位置设置的值。&lt;/p&gt;
&lt;h4 id=&quot;优势-1&quot;&gt;优势&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;（核心）避免接口定义污染。如应用系统中（同一JVM中）存在A-&amp;gt;B-&amp;gt;C这样的操作链路。但只有A和C用到了特定参数（如用户信息），那么为了能够调用C，B也必须引入该特定参数（如用户参数），即使B没有用到该特定参数。这就造成了接口定义的污染（详见&lt;a href=&quot;https://blog.csdn.net/ykdsg/article/details/88707978&quot;&gt;线程级缓存ThreadLocalCache&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;数据缓存。由于ThreadLocal是通过栈封闭的理念实现了线程安全，所以其在一些场景下有着特定的使用。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;缺点-1&quot;&gt;缺点&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;ThreadLocal缓存设计与学习，及原有系统的改动&lt;/li&gt;
&lt;li&gt;（核心）由于可能涉及多线程与调用链上多个调用节点，所以设计与问题排查会有较大的难度&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;实际应用-1&quot;&gt;实际应用&lt;/h4&gt;
&lt;p&gt;在我之前接收的IOT项目中，终端系统通过传感器数据读取程序与传感器配置，获得原始数据（包括原始监测值，以及配置表中对应配置（如硬件标识，报警阈值等））。但是原始数据采集后，会进行数据清洗，数据报警评估，数据保存等多个操作。但是其中的数据清洗并不涉及硬件标识，与报警阈值等。所以采用ThreadLocal来保存对应数据（硬件配置），避免方法接口的污染。当然，后来由于该流程并不都是有前后顺序要求，所以添加了事件监听，进行异步解耦，降低系统复杂度。&lt;/p&gt;
&lt;h3 id=&quot;guavacache&quot;&gt;GuavaCache&lt;/h3&gt;
&lt;p&gt;Guava代表着应用级缓存，更准确说是单JVM实例缓存。在原单机系统时，我们往往并不是采用Redis这样的分布式缓存（除非是希望利用其数据处理，如GEO处理，集合处理等），而是采用GuavaCache或自定义缓存（自定义缓存的设计，后面会有一篇专门的博客）。&lt;/p&gt;
&lt;h4 id=&quot;优势-2&quot;&gt;优势&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;资源占用小。毕竟只是运行于单机的一种缓存工具&lt;/li&gt;
&lt;li&gt;实现了一种简便的缓存管理工具，满足了大多数单机系统对缓存的需求&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;劣势&quot;&gt;劣势&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;功能没有分布式缓存中间件完善（尤其是自定义的缓存工具）&lt;/li&gt;
&lt;li&gt;如果是采用Guava这样的第三方缓存工具，需要对工具的一定学习成本&lt;/li&gt;
&lt;li&gt;如果是自定义实现（为了更为精简，定制化），往往性能的提高对技术水平有着一定的需求（如SoftReference的利用等）&lt;/li&gt;
&lt;li&gt;对原有应用的改变&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;外部缓存&quot;&gt;外部缓存&lt;/h2&gt;
&lt;p&gt;外部缓存的一个重要代表，就是Redis，Memcache这样的分布式缓存中间件。当然外部缓存，你要把文件系统等划分进来，也不是不行，只要可以满足对缓存的定义即可。&lt;/p&gt;
&lt;p&gt;这里以Redis为例。&lt;/p&gt;
&lt;h3 id=&quot;redis&quot;&gt;Redis&lt;/h3&gt;
&lt;p&gt;Redis作为当下最为流行的分布式缓存中间件，其应用可以说是非常广泛的，也是我非常喜欢使用的一种分布式缓存中间件。其是一个开源的，C语言编写的，基于内存，支持持久化的日志型，KV型的网络程序。&lt;/p&gt;
&lt;h4 id=&quot;优点&quot;&gt;优点&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;使用简单。Redis的单机使用不要太简单。即使是新人，也可以在很短的时间内上手，并在实际开发中应用（当然，如果项目中已经有了相关配置，并提供了相关Util就更方便了）&lt;/li&gt;
&lt;li&gt;性能强悍。即使是单机的Redis，也可以在一个普通性能的服务器上，提供每秒十万级的读写能力（当然影响的情况很多，详见&lt;a href=&quot;https://redis.io/topics/benchmarks&quot;&gt;redis的BenchMark&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;功能强大。Redis提供了GEO的相关操作（计算两点距离等），集合相关操作（交集，并集等），流相关操作（类似消息队列）&lt;/li&gt;
&lt;li&gt;应用场景多。如Session服务器（分布式Session的优秀解决方案），计数器（Incr），分布式锁等&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;缺点-2&quot;&gt;缺点&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;需要部署Redis服务器。并且为了确保可用性，往往需要进行集群部署&lt;/li&gt;
&lt;li&gt;精通较难。
&lt;ul&gt;&lt;li&gt;功能方面。功能强大的Redis，其内部实现还是有不少东西的，包括其持久化机制，内存管理&lt;/li&gt;
&lt;li&gt;理论方面。如Redis内存管理方面，涉及LRU，LFU算法，以及其自定义简化版的实现。又或者其哨兵机制涉及的Raft分布式选举算法等&lt;/li&gt;
&lt;li&gt;部署方面。单机部署，以及多种集群部署（生产级部署，可以看我之前的博客-&lt;a href=&quot;https://www.cnblogs.com/Tiancheng-Duan/p/12115156.html&quot;&gt;Redis安装（单机及各类集群，阿里云）&lt;/a&gt;）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;实际应用-2&quot;&gt;实际应用&lt;/h4&gt;
&lt;p&gt;在我之前接手过的某综合系统（涵盖社交，在线教育，直播等），其Session服务器是通过Redis进行支撑的。通过将&amp;lt;SessionId,Session&amp;gt;的方式，存储在Redis，而SeesionId会保存在用户的Cookie中（至于某些小伙伴担心的Cookie禁用问题，这就涉及Cookie的知识内容了。Cookie会保存在URL中）&lt;/p&gt;
&lt;p&gt;再举一个例子（Redis的应用场景太多了）。之前负责的IOT项目中，其中控系统的报警模块有这么一个需求：同一个终端的同一个传感器在30min中，只报警一次，避免报警刷屏的现象。而中控系统已经采用了Redis（中控系统是可以集群部署，确保可用性，避免性能瓶颈），所以利用Redis的集合特性与expire特性，进行了对应的缓存设计。这个在之后会专门写一篇博客，进行阐述。&lt;/p&gt;
&lt;h2 id=&quot;数据库缓存&quot;&gt;数据库缓存&lt;/h2&gt;
&lt;p&gt;这里说的数据库，是指Mysql，Oracle这样的数据库，而不是Redis这样的。&lt;/p&gt;
&lt;p&gt;这里就以Mysql举例，这个大家应该是最熟悉的。&lt;/p&gt;
&lt;h3 id=&quot;mysql&quot;&gt;Mysql&lt;/h3&gt;
&lt;p&gt;Mysql缓存机制，就是缓存sql文本，及其对应的缓存结果，通过KV形式保存到Mysql服务器内存中。之后Mysql服务器，再次遇到同样的sql语句，就会从缓存中直接返回结果，而不需要再进行sql解析，优化，执行。&lt;/p&gt;
&lt;p&gt;可能某些人担心，如果数据改变了，而请求的语句是select * from xxx，那不就一直拿到旧数据了嘛。放心，mysql有这方面的处理，当对应表的数据有所修改，那么使用了这个表的数据的缓存就全部失效。所以对于经常变动的数据表，缓存并没有太大价值。&lt;/p&gt;
&lt;h4 id=&quot;优势-3&quot;&gt;优势&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;提升性能。同样的语句，第一次执行可能需要1s，而第二次执行往往只需要几毫秒。&lt;/li&gt;
&lt;li&gt;避免索引时间。因为是通过请求的sql，直接从缓存中获取对应结果，所以没有进行索引查询操作。&lt;/li&gt;
&lt;li&gt;降低数据库磁盘操作。虽然请求到达了数据库，但如果没有进行硬盘操作（寻道，读取数据等），那么该次数据库操作对数据库的资源消耗就小了许多（因为在数据库中最消耗时间的就是索引操作与硬盘操作）&lt;/li&gt;
&lt;li&gt;降低数据库资源消耗，提高查询时间。因为其避免了数据库获得sql后的所有操作，取而代之的是从缓存获取数据（一个KV读取操作，资源消耗可以几乎可以忽略了）&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;缺点-3&quot;&gt;缺点&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;mysql缓存的应用，及配置需要足够的专业知识（一般的后端并不会非常深入这个层次，往往需要专门的DBA进行处理）&lt;/li&gt;
&lt;li&gt;mysql缓存的判断规则不够智能，提高了查询缓存的使用门槛，降低了其效率&lt;/li&gt;
&lt;li&gt;mysql缓存的检查与清理需要占用一定资源&lt;/li&gt;
&lt;li&gt;mysql缓存的内存管理不够完善，会产生一定内存碎片（貌似mysql并不是直接采用数据库的内存，就像JVM一样。如果有不同意见的，可以私信或@我。毕竟我并不擅长数据库，虽然刚接手的工作是进行数据库中间件开发。囧）&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;扩展&quot;&gt;扩展&lt;/h4&gt;
&lt;h4 id=&quot;实际应用-3&quot;&gt;实际应用&lt;/h4&gt;
&lt;p&gt;在我之前接收的IOT项目中，无论是终端系统，还是中控系统，往往都存在大数据量的数据查询，单次的数据查询往往涉及万级，十万级数据的查询，并且可能频繁查询（就是多次刷新页面数据）。&lt;/p&gt;
&lt;p&gt;一方面，我通过批量写入（降低数据库连接的占用频次），降低数据库对应数据表的修改频次（从原来的几秒一次，变为一分钟一次）。另一方面，进行数据库缓存相关配置，确保在一分钟内的数据库不需要进行索引操作与硬盘操作，直接返回内存内的结果。从而有效提高了前端页面数据展示效果。&lt;/p&gt;
&lt;p&gt;当然后续，我为了针对这一特定业务场景与需求，对业务稍做了调整，从而大大提高了数据查询效果，大幅降低应用系统资源消耗（这个我会专门写一篇博客，甚至专门开一个系列，用来描写这种粒度的特定业务场景的方案设计）。&lt;/p&gt;
&lt;h2 id=&quot;布隆过滤器&quot;&gt;布隆过滤器&lt;/h2&gt;
&lt;p&gt;之前有人私信我，认为布隆过滤器应该归类于缓存架构的一部分。&lt;/p&gt;
&lt;p&gt;我开始认为这有一定道理，因为布隆过滤器确实涉及数据的缓存，它需要以往数据的记录，来实现。但是后来我想了想，布隆过滤器并不应该划分为缓存中，因为布隆过滤器是基于缓存的，应用缓存的。就像你可以说Redis缓存属于缓存架构的一部分，但是你不可以说调用缓存的应用服务器属于缓存。所以最终，我并没有将布隆过滤器划分为缓存的一部分。而是将它作为一种非常有意思的过滤器，一种限流方式，一种安全手段等。&lt;/p&gt;
&lt;p&gt;不过作为扩展，这里简单说一下布隆过滤器。说白了，就是利用Hash的散列映射特性，进行数据过滤。如我在应用中设置一个数组Array（其所有值都为0），其长度为固定的10W。我针对每个用户计算一个hash值，并将这个hasn值对10W进行取余操作，获得index值（如1000）。我将Array中第index位置的value设置为1。这样放在生产环境后，如果有一个用户，其计算出来的index在Array中对应位置的值为0，则说明这个用户在系统中不存在（当然，如果是1，也并不能就说明其就是系统的用户，毕竟存在哈希冲突与取余冲突，不过概率较低）。通过这样的手段，有效避免无效请求等。&lt;/p&gt;
&lt;p&gt;后续可能会专门写一篇有关布隆过滤器的博客。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;以上就是缓存架构相关的知识了。当然，这些知识都是粒度比较大的，虽然我举了一些实际例子，但是需要大家针对具体应用场景，进行调整应用。另外，这些知识都是比较通用的。可能在特定业务场景下，还有一些方案没有列在这里。最后，没有最好的技术，只有最合适的技术。这里的许多技术都需要一定的业务规模（数据量，请求数，并发量等），采用比较好的性价比，需要大家仔细考虑。&lt;/p&gt;
&lt;p&gt;如果有什么问题或者想法，可以私信或@我。&lt;/p&gt;
&lt;p&gt;愿与诸君共进步。&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
</description>
<pubDate>Mon, 13 Jan 2020 00:31:00 +0000</pubDate>
<dc:creator>血夜之末</dc:creator>
<og:description>缓存中间件 缓存架构的实现（下） 前言 缓存架构，说白了就是利用各种手段，来实现缓存，从而降低服务器，乃至数据库的压力。 这里把之前提出的缓存架构的技术分类放出来： 浏览器缓存 Cookie Loca</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Tiancheng-Duan/p/12185507.html</dc:identifier>
</item>
<item>
<title>基于 HTML5 + WebGL 的 3D 风力发电场 - HT学习笔记</title>
<link>http://www.cnblogs.com/htdaydayup/p/12121126.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/htdaydayup/p/12121126.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;   &lt;/strong&gt;风能是一种开发中的洁净能源，它取之不尽、用之不竭。当然，建风力发电场首先应考虑气象条件和社会自然条件。近年来，我国海上和陆上风电发展迅猛。海水、陆地为我们的风力发电提供了很好地质保障。正是这些场地为我们的风力提供了用之不竭的能源。现在我们正在努力探索这些领域。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;本文章实现了风力发电场的整体流程。能让大家能够看到一套完整风力发电预览体系。&lt;/p&gt;
&lt;p&gt;需要注意的是，本次项目是使用 &lt;strong&gt;Hightopo&lt;/strong&gt; 的  &lt;strong&gt;HT for Web &lt;/strong&gt; 产品来搭建的。&lt;/p&gt;
&lt;p&gt;预览地址：&lt;a href=&quot;https://hightopo.com/demo/wind-power-station/&quot;&gt;https://hightopo.com/demo/wind-power-station/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;大致流程&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 下面是整个项目的流程图。我们从首页可以进入到场区分布页面和集控页面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  场区分布页面又包括两个不同的 3D 场景，分别是陆地风机场和海上风机场。点击两个 3D 风机场最终都会进入到 3D 风机场景。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1496396/201912/1496396-20191230134104917-323127925.jpg&quot; alt=&quot;&quot; width=&quot;836&quot; height=&quot;540&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;预览效果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;首页:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 世界地图效果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1496396/201912/1496396-20191230132528587-1458571169.gif&quot; alt=&quot;&quot; width=&quot;681&quot; height=&quot;323&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;2. 中国地&lt;span&gt;图效果&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1496396/201912/1496396-20191230132608634-613576312.gif&quot; alt=&quot;&quot; width=&quot;679&quot; height=&quot;322&quot;/&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;2. 城市地图效果&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1496396/201912/1496396-20191230132711903-2144957127.gif&quot; alt=&quot;&quot; width=&quot;678&quot; height=&quot;322&quot;/&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;&lt;span&gt;集控中心页面（没有动画效果）：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1496396/201912/1496396-20191230134649508-1918301175.png&quot; alt=&quot;&quot; width=&quot;670&quot; height=&quot;363&quot;/&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;场区分布页面&lt;strong&gt;（没有动画效果）&lt;/strong&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1496396/201912/1496396-20191230135310631-788203361.png&quot; alt=&quot;&quot; width=&quot;666&quot; height=&quot;376&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;陆地风机场： &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1496396/201912/1496396-20191230135437427-543102986.gif&quot; alt=&quot;&quot; width=&quot;668&quot; height=&quot;359&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;海上风机场：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1496396/201912/1496396-20191230135434393-1927800171.gif&quot; alt=&quot;&quot; width=&quot;662&quot; height=&quot;356&quot;/&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;代码实现&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 我们可以看到，首页的地球有三种视角状态，世界地图、中国地图、城市地图。点击每个状态相机就会转到对应的位置。在这之前我们要先预先存一下对应的 &lt;strong&gt;center&lt;/strong&gt; 和 &lt;strong&gt;eye 。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 我们最好新建一个 &lt;strong&gt;data.js&lt;/strong&gt; 文件，专门用来提供数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;strong&gt;相关伪代码如下：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 记录位置&lt;/span&gt;
var cameraLocations =&lt;span&gt; {
    earth: {
        eye: [&lt;/span&gt;-73, 448, 2225&lt;span&gt;],
        center: [&lt;/span&gt;0, 0, 0&lt;span&gt;]
    },

    china: {
        eye: [&lt;/span&gt;-91, 476, 916&lt;span&gt;],
        center: [&lt;/span&gt;0, 0, 0&lt;span&gt;]
    },

    tsankiang: {
        eye: [&lt;/span&gt;35, 241, 593&lt;span&gt;],
        center: [&lt;/span&gt;0, 0, 0&lt;span&gt;]
    }&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 好了，有了数据之后。我们接下来该监听事件了。我们可以点击按钮，也可以点击高亮区域（世界地图只有按钮可以点击）进入到中国地图视角。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1496396/201912/1496396-20191230141107299-1531882026.png&quot; alt=&quot;&quot; width=&quot;674&quot; height=&quot;496&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 我们可以这样先获取这两个节点，然后对它们的点击事件进行相同的处理。但是，我觉得这种方式可以进行优化，更换一种思考方式。&lt;/p&gt;
&lt;p&gt; 我们可以先将事件进行过滤，我们创建两个数组，一个保存着类似 &lt;strong&gt;click、onEnter&lt;/strong&gt; 这样可以执行的事件，一个保存着所有可以触发事件的节点。这样可以有利于我们维护，也可以使结构更加清晰。&lt;/p&gt;
&lt;p&gt; 下图，我们可以看到，如果当前节点没有事件权限或者当前事件本身就没有权限的话，就会被过滤掉。如果都可以正确返回，则执行对应的事件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1496396/201912/1496396-20191230152250366-1229846969.png&quot; alt=&quot;&quot; width=&quot;852&quot; height=&quot;375&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;相关伪代码如下：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 权限事件&lt;/span&gt;
&lt;span&gt;this&lt;/span&gt;.eventMap =&lt;span&gt; {
    clickData: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
    onEnter: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
    onLeave: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 权限节点&lt;/span&gt;
&lt;span&gt;this&lt;/span&gt;.nodeMap =&lt;span&gt; {
    outline: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
    outline2: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
    earth: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
    bubbles: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
    circle: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
  * 监听事件
  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
initMonitor() {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; gv = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.gv
　　 var self = this&lt;br/&gt;&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; evntFlow = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (e) {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; event =&lt;span&gt; e.kind
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; tag = e.data &amp;amp;&amp;amp;&lt;span&gt; e.data.getTag()

         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 检查当前事件或者节点是否能够被执行&lt;/span&gt;
         &lt;span&gt;if&lt;/span&gt; (!self.eventMap[event] &amp;amp;&amp;amp; !&lt;span&gt;self&lt;/span&gt;.nodeMap[tag]) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;

         &lt;span&gt;self&lt;/span&gt;&lt;span&gt;.nodeEvent(event, tag)
    }

    gv.mi(eventFlow)
}    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 只要我们当前要执行的节点符合要求，我们就会把 &lt;strong&gt;event&lt;/strong&gt; &lt;strong&gt;(当前执行的事件)&lt;/strong&gt; 和 &lt;strong&gt;tag (节点标签) &lt;/strong&gt;传给执行函数 &lt;strong&gt;nodeEvent&lt;/strong&gt; 执行&lt;strong&gt;。&lt;/strong&gt;这样就不会浪费资源去处理那些无效的事件或者节点了。&lt;/p&gt;
&lt;p&gt; 我们接下来来看看 &lt;strong&gt;nodeEvent&lt;/strong&gt; 怎么处理吧！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 相关伪代码如下：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 气泡事件
 * @param { string } event 当前事件
 * @param { string } propertyName 当前节点标签
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
bubblesEvent(&lt;/span&gt;&lt;span&gt;event&lt;/span&gt;&lt;span&gt;, propertyName) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; dm = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.dm
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; account = dm.getDataByTag(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;account&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; currentNode =&lt;span&gt; dm.getDataByTag(propertyName)
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; self = &lt;span&gt;this&lt;/span&gt;

    &lt;span&gt;var&lt;/span&gt; clickData =&lt;span&gt; function() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行清除动作&lt;/span&gt;
&lt;span&gt;        self.clearAction()
    }

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; onEnter =&lt;span&gt; function() {
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; do something&lt;/span&gt;
&lt;span&gt;    }

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; onLeave =&lt;span&gt; function() {
　　　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; do something&lt;/span&gt;
&lt;span&gt;    }

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; allEvent =&lt;span&gt; { clickData, onEnter, onLeave }

    allEvent[&lt;/span&gt;&lt;span&gt;event&lt;/span&gt;] &amp;amp;&amp;amp; allEvent[&lt;span&gt;event&lt;/span&gt;&lt;span&gt;]()
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到，我们可以利用 &lt;strong&gt;propertyName(节点标签) &lt;/strong&gt;字符串拼接组成一个方法名。比如当前拿到的节点标签是 &lt;strong&gt;bubbles ，&lt;/strong&gt; &lt;strong&gt;this[`${ properName }Event`]&lt;/strong&gt; 之后，拿到就是 &lt;strong&gt;this['bubblesEvent']&lt;/strong&gt; 这个方法。当然，这个方法是我们事先定义好的。&lt;/p&gt;
&lt;p&gt;在具体的节点方法里面，我们创建了对应的事件函数。根据传过来的 &lt;strong&gt;event&lt;/strong&gt; 来判断是否拥有对应的方法。如果有的话执行，否则返回 &lt;strong&gt;false&lt;/strong&gt; 。这样做的好处是：&lt;strong&gt;解耦、结构简洁、出现问题能够快速定位。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;但是，如果我们仔细想想，我们点击世界地图和中国地图的时候，功能都差不多！如果我们可以将他们合并的话，就会方便很多了！！我们来改造一下代码。&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;相关伪代码如下：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
  * 执行节点事件
  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
nodeEvent(event, propertyName) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 过滤是否有可以合并的事件&lt;/span&gt;
    var filterEvents = function(propertyName)&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;var &lt;span&gt;isCombine = false&lt;/span&gt;&lt;br/&gt;　　　　　var &lt;/span&gt;self = this
&lt;/pre&gt;
&lt;pre&gt;
        &lt;span&gt;if&lt;/span&gt; (['earth', 'china'&lt;span&gt;].includes(propertyName)) {
            &lt;/span&gt;&lt;span&gt;self&lt;/span&gt;&lt;span&gt;.changeCameraLocaltions(event, propertyName)
            isCombine &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; !&lt;span&gt;isCombine
    }
   var eventFun = this[`${propertyName}Event`]
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行对应的节点事件&lt;/span&gt;
&lt;span&gt;   filterEvents(propertyName)
   &lt;/span&gt;&amp;amp;&amp;amp;
   eventFun&lt;span&gt;&lt;br/&gt;&lt;/span&gt;　　&amp;amp;&amp;amp;
   &lt;span&gt;eventFun&lt;/span&gt;&lt;span&gt;(event, propertyName)
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 我们事&lt;span&gt;先判&lt;/span&gt;断当前事件是否能合并，如果能的话返回 &lt;strong&gt;false ，&lt;/strong&gt;不再执行下面的代码，然后执行自己的函数。&lt;/p&gt;
&lt;p&gt; 这时候，我们就可以通过对应的节点标签，从 &lt;strong&gt;data.js&lt;/strong&gt; 的 &lt;strong&gt;cameraLocations&lt;/strong&gt; 变量中取到对应的 &lt;strong&gt;center、eye 。&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;107&quot;&gt; &lt;strong&gt;&lt;strong&gt;相关伪代码如下：&lt;/strong&gt;&lt;/strong&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 移动镜头动画
 * @param { object } config 坐标对象
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
moveCameraAnim(gv, config) {&lt;/span&gt;&lt;span&gt;
　　var eye = config.eye&lt;br/&gt;　　var center = config.center&lt;br/&gt;&lt;/span&gt;&lt;span&gt;　　//&lt;/span&gt;&lt;span&gt; 如果动画已经存在，进行清空&lt;/span&gt;
   &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(globalAnim.moveCameraAnim) {
      globalAnim.moveCameraAnim.stop()&lt;br/&gt;　　　 globalAnim.moveCameraAnim = null
   }

   var animConfig &lt;/span&gt;=&lt;span&gt; {
   　　duration: &lt;/span&gt;2e3&lt;span&gt;
   }

   globalAnim.moveCameraAnim &lt;/span&gt;=&lt;span&gt; gv.moveCamera(eye, center, animConfig)
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 需要改变相机位置&lt;/span&gt;
&lt;span&gt;changeCameraLocaltions(event, properName) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; config =&lt;span&gt; cameraLocations[properName]

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 移动相机&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.moveCameraAnim(this.gv, config)
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 移动镜头动画使用到了 &lt;strong&gt;gv&lt;/strong&gt; 的 &lt;strong&gt;moveCamera&lt;/strong&gt; 方法，该方法接受 3 个参数，&lt;strong&gt;eye (相机)&lt;/strong&gt;，&lt;strong&gt;center (目标)，animConfig (动画配置) 。&lt;/strong&gt;然后我们把当前动画返回给 &lt;strong&gt;globalAnim&lt;/strong&gt; 的 &lt;strong&gt;moveCameraAnim&lt;/strong&gt; 属性，方便我们进行清理。&lt;/p&gt;
&lt;p&gt; 接下来，就是切换页面了，这点需要非常小心谨慎。因为一旦没有把某个属性清除的话，将会导致内存泄漏等问题，性能会越来越慢。将会导致页面卡死的情况！&lt;/p&gt;
&lt;p&gt; 所以我们需要一个专门用来清除数据模型的函数 &lt;strong&gt;clearAction 。&lt;/strong&gt;我们应该把所有的动画对象放到一个对象或者数组中。这样方便切换页面的时候清理掉。&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;相关伪代码如下：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 清除动作
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
clearAction(index) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; { dm, gv } = &lt;span&gt;this&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; { g3d, d3d } =&lt;span&gt; window

    allListener.mi3d &lt;/span&gt;&amp;amp;&amp;amp;&lt;span&gt; g3d.umi(allListener.mi3d)
    allListener.mi2d &lt;/span&gt;&amp;amp;&amp;amp;&lt;span&gt; gv.umi(allListener.mi2d)
    dm.removeScheduleTask(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.schedule)

    dm &lt;/span&gt;&amp;amp;&amp;amp;&lt;span&gt; dm.clear()
    d3d &lt;/span&gt;&amp;amp;&amp;amp;&lt;span&gt; d3d.clear()

    window.d3d &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;
    window.dm &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;

    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; globalAnim) {
        globalAnim[i] &lt;/span&gt;&amp;amp;&amp;amp;&lt;span&gt; globalAnim[i].pause()
        globalAnim[i] &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 清除对应的 3D 图纸&lt;/span&gt;
&lt;span&gt;    ht.Default.removeHTML(g3d)&lt;/span&gt;&lt;span&gt;

    gv.addToDOM()
    ht.Default.xhrLoad(`displays&lt;/span&gt;/HT-project_2019/风电/${index}.json`, function (text) {
        let json =&lt;span&gt; ht.Default.parse(text)
        gv.deserialize(json, function(json, dm2, gv2, datas)&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (json.title) document.title =&lt;span&gt; json.title

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (json.a['json.background'&lt;span&gt;]) {
                let bgJSON &lt;/span&gt;= json.a['json.background'&lt;span&gt;]
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (bgJSON.indexOf('scenes') === 0&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; bgG3d

                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (g3d) {
                        bgG3d &lt;/span&gt;=&lt;span&gt; g3d
                    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                        bgG3d &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ht.graph3d.Graph3dView()
                    }

                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; bgG3dStyle =&lt;span&gt; bgG3d.getView()
                    bgG3dStyle.className &lt;/span&gt;= index === 1 ? '' : index === 3 ? 'land' : 'offshore'&lt;span&gt;

                    bgG3d.deserialize(bgJSON, function(json, dm3, gv3, datas) &lt;/span&gt;&lt;span&gt;{
                        init3d(dm3, gv3)
                    })

                    bgG3d.addToDOM()
                    gv.addToDOM(bgG3dStyle)
                }
                gv.handleScroll &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {}
            }

            init2d(dm2, gv2)
        })
    })
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;首先我们需要把 &lt;strong&gt;dm(数据模型)&lt;/strong&gt; 和 &lt;strong&gt;gv(图纸)&lt;/strong&gt; 清除掉。还要注意：&lt;strong&gt;mi(监听函数)&lt;/strong&gt;、&lt;strong&gt;schedule(调度任务)&lt;/strong&gt; 应该在 &lt;strong&gt;dm.clear()&lt;/strong&gt; 之前 &lt;strong&gt;remove&lt;/strong&gt;。所有的动画进行 &lt;strong&gt;stop()&lt;/strong&gt; 操作，然后将其值设为 &lt;strong&gt;null&lt;/strong&gt; 。这里需要注意的是， 执行 &lt;strong&gt;stop&lt;/strong&gt; 之后，会调用一次 &lt;strong&gt;finishFunc&lt;/strong&gt; 回调函数。&lt;/p&gt;
&lt;p&gt;当我们的 2D 图纸里面包含 3D 背景的情况下，需要判断是否已经存在了 3D 的实例，如果存在不需要再次创建。有兴趣可以了解一下 webGL 的应用内存泄漏问题。&lt;/p&gt;
&lt;p&gt;当进入两个 3D 场景场景的时候，我们需要一个开场动画，如开头效果 gif 图一样。所以我们，需要把两个开场动画的 center 和 eye 都存到我们已经定义好的 &lt;strong&gt;cameraLocations&lt;/strong&gt; 中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;76&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 记录位置&lt;/span&gt;
var cameraLocations =&lt;span&gt; {
    earth: {
        eye: [&lt;/span&gt;-73, 448, 2225&lt;span&gt;],
        center: [&lt;/span&gt;0, 0, 0&lt;span&gt;]
    },

    china: {
        eye: [&lt;/span&gt;-91, 476, 916&lt;span&gt;],
        center: [&lt;/span&gt;0, 0, 0&lt;span&gt;]
    },

    tsankiang: {
        eye: [&lt;/span&gt;35, 241, 593&lt;span&gt;],
        center: [&lt;/span&gt;0, 0, 0&lt;span&gt;]
    },

    offshoreStart: {
        eye: [&lt;/span&gt;-849, 15390, -482&lt;span&gt;],
        center: [&lt;/span&gt;0, 0, 0&lt;span&gt;]

    },

    landStart: {
        eye: [&lt;/span&gt;61, 27169, 55&lt;span&gt;],
        center: [&lt;/span&gt;0, 0, 0&lt;span&gt;]
    },

    offshoreEnd: {
        eye: [&lt;/span&gt;-3912, 241, 834&lt;span&gt;],
        center: [&lt;/span&gt;0, 0, 0&lt;span&gt;]
    },

    landEnd: {
        eye: [&lt;/span&gt;4096, 4122, -5798&lt;span&gt;],
        center: [&lt;/span&gt;1261, 2680, -2181&lt;span&gt;]
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;strong&gt;offshoreStart、offshoreEnd、landStart、landEnd&lt;/strong&gt; 表示海上和陆上发电场的开始位置和结束位置&lt;strong&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;我们需要判断当前加载的是海上发电场还是陆上发电场。我们可以在加载对应图纸的时候添加 &lt;strong&gt;className 。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;我们在 &lt;strong&gt;clearAction&lt;/strong&gt; 这个函数已经定义了 index 这个参数，如果点击的是陆地发电场传的就是数字3，如果是海上发电场的话，就是数字4。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;比如我需要加载陆地发电场，那么就可以通过判断 &lt;strong&gt;g3d.className = index === 3 ? 'land' : 'offshore'&lt;/strong&gt; 来添加 &lt;strong&gt;className 。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;然后在 init 里面进行初始化的判断。&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;相关伪代码如下：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;init() {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; className = &lt;strong&gt;g3d&lt;/strong&gt;&lt;span&gt;.getView().className
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行单独的事件&lt;/span&gt;
    &lt;span&gt;this.&lt;/span&gt;&lt;span&gt;selfAnimStart(className)&lt;br/&gt;&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.initData()

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 监听事件&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.monitor()
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 我们拿到对应的 &lt;strong&gt;className ，&lt;/strong&gt;传入相对应的类型并且执行对应的初始化事件，通过我们已经定义好的 &lt;strong&gt;moveCameraAnim&lt;/strong&gt; 函数进行相机的动画。&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;相关伪代码如下：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
  * 不同风电场的开场动画
  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
selfAnimStart(type) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; gv = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.gv
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; { eye, center } =&lt;span&gt; cameraLocations[`${type}End`]
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; config =&lt;span&gt; {
        duration: &lt;/span&gt;3000&lt;span&gt;,
        eye,
        center,
     }

     &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.moveCameraAnim(gv, config)
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;总结&lt;br/&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt; 这个项目让我们更加了解了风力发电。不管是风力发电场的地区优势，还是风机的结构、运转原理。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt; 做完这个项目，自己得到了很多的成长和感悟。对于技术快速成长的一个好方法就是去不断的抠细节。&lt;/span&gt;&lt;/span&gt;项目是一件艺术品，需要不断对其进行打磨，要做到自己满意为止。每个细微的点都会影响后面的性能。所以，我们应该以匠人的精神去做任何事。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt; 当然，我也希望一些伙伴能够勇于探索工业互联网领域。我们能够实现的远远不止于此。这需要发挥我们的想象力，为这个领域增添更多好玩的、实用的 demo。而且还能学到很多工业领域的知识。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Mon, 13 Jan 2020 00:26:00 +0000</pubDate>
<dc:creator>HT学习笔记</dc:creator>
<og:description>前言 风能是一种开发中的洁净能源，它取之不尽、用之不竭。当然，建风力发电场首先应考虑气象条件和社会自然条件。近年来，我国海上和陆上风电发展迅猛。海水、陆地为我们的风力发电提供了很好地质保障。正是这些场</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/htdaydayup/p/12121126.html</dc:identifier>
</item>
<item>
<title>.NET Core 3 WPF MVVM框架 Prism系列之模块化 - RyzenAdorer</title>
<link>http://www.cnblogs.com/ryzen/p/12185054.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ryzen/p/12185054.html</guid>
<description>&lt;p&gt;本文将介绍如何在.NET Core3环境下使用MVVM框架Prism的应用程序的模块化&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt; 我们都知道，为了构成一个低耦合，高内聚的应用程序，我们会分层，拿一个WPF程序来说，我们通过MVVM模式去将一个应用程序的分成View-ViewModel-Model，大大消除之前业务逻辑和界面元素之间存在的高耦合，使我们后台开发人员可以将重点更放在业务逻辑层面上，属于UI界面的则可以交给更专业的UI人员&lt;/p&gt;
&lt;p&gt; 但是一个应用程序是由不同的业务模块来组合而成，我们理想状态下，每个业务模块拥有着能够独立的功能，并且和其他业务模块之间的是低耦合关系的，且每个业务模块可以单独用来开发,测试和部署，这样组成的应用程序是非常容易扩展，测试和维护的，而Prism提供将应用程序模块化的功能&lt;/p&gt;
&lt;p&gt;我们先来看下一个小Demo&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1294271/202001/1294271-20200112222346661-1174566829.gif&quot;/&gt;&lt;br/&gt;再来看看解决方案的项目：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1294271/202001/1294271-20200112222409282-229485275.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我将该小demo，分为四个项目，其中Shell为主窗体项目，然后MedicineModule和PatientModule为我们分割开的业务模块，最后Infrastructure则为我们的公共共享项目，我们将一步步讲解该demo如何进行模块化的.&lt;/p&gt;
&lt;p&gt;首先，我们引用官方的一个图，大致讲解了创建加载模块的流程：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1294271/202001/1294271-20200112222424028-2135995057.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;注册/发现模块&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;加载模块&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;初始化模块&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们就根据这个流程来看看demo是如何进行模块化的？&lt;/p&gt;
&lt;h2 id=&quot;一.注册发现模块&quot;&gt;一.注册/发现模块&lt;/h2&gt;
&lt;h3 id=&quot;注册模块&quot;&gt;1.注册模块&lt;/h3&gt;
&lt;p&gt;prism注册模块有三种方式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;代码注册&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;目录文件扫描注册&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;配置文件App.config注册&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们先用代码注册的方式，首先我们要先定义模块，我们分别在PrismMetroSample.MedicineModule和PrismMetroSample.PatientModule两个项目中创建MedicineModule类和PatientModule类,代码如下：&lt;/p&gt;
&lt;p&gt;MedicineModule.cs:&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt; public class MedicineModule : IModule
 {
     public void OnInitialized(IContainerProvider containerProvider)
     {
         var regionManager = containerProvider.Resolve&amp;lt;IRegionManager&amp;gt;();


         //MedicineMainContent
         regionManager.RegisterViewWithRegion(RegionNames.MedicineMainContentRegion, typeof(MedicineMainContent));

         //SearchMedicine-Flyout
         regionManager.RegisterViewWithRegion(RegionNames.FlyoutRegion, typeof(SearchMedicine));

         //rightWindowCommandsRegion
         regionManager.RegisterViewWithRegion(RegionNames.ShowSearchPatientRegion, typeof(ShowSearchPatient));
        }

     public void RegisterTypes(IContainerRegistry containerRegistry)
     {
            
     }
 }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;PatientModule.cs:&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt; public class PatientModule : IModule
 {
     public void OnInitialized(IContainerProvider containerProvider)
     {
         var regionManager = containerProvider.Resolve&amp;lt;IRegionManager&amp;gt;();

         //PatientList
         regionManager.RegisterViewWithRegion(RegionNames.PatientListRegion, typeof(PatientList));
         //PatientDetail-Flyout
         regionManager.RegisterViewWithRegion(RegionNames.FlyoutRegion, typeof(PatientDetail));
           
     }

     public void RegisterTypes(IContainerRegistry containerRegistry)
     {
           
     }
 }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;代码注册&quot;&gt;1.代码注册&lt;/h4&gt;
&lt;p&gt;然后我们在PrismMetroSample.Shell主窗体的项目分别引用PrismMetroSample.MedicineModule和PrismMetroSample.PatientModule程序集，之后在App.xaml.cs中代码注册：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;protected override void ConfigureModuleCatalog(IModuleCatalog moduleCatalog)
{
   moduleCatalog.AddModule&amp;lt;PrismMetroSample.PatientModule.PatientModule&amp;gt;();
    
    //将MedicineModule模块设置为按需加载
   var MedicineModuleType = typeof(PrismMetroSample.MedicineModule.MedicineModule);
   moduleCatalog.AddModule(new ModuleInfo()
   {
        ModuleName= MedicineModuleType.Name,
        ModuleType=MedicineModuleType.AssemblyQualifiedName,
        InitializationMode=InitializationMode.OnDemand
    });
            
 }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注：代码注册是没有所谓的发现模块部分，是直接注册部分&lt;/p&gt;
&lt;h4 id=&quot;目录文件扫描注册&quot;&gt;2.目录文件扫描注册&lt;/h4&gt;
&lt;h5 id=&quot;注册模块-1&quot;&gt;2.1注册模块&lt;/h5&gt;
&lt;p&gt;首先我们先在MedicineModule加上特性,OnDemand为true为&quot;按需&quot;加载，而PatientModule默认加载则可以不加&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt; [Module(ModuleName = &quot;MedicineModule&quot;, OnDemand =true)]
 public class MedicineModule : IModule&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们将PrismMetroSample.MedicineModule项目和PrismMetroSample.PatientModule项目设置生成事件dll拷贝到PrismMetroSample.Shell项目bin\Debug下的Modules文件夹下&lt;/p&gt;
&lt;p&gt;生成事件命令行如下：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;xcopy &quot;$(TargetDir)$(TargetName)*$(TargetExt)&quot; &quot;$(SolutionDir)\PrismMetroSample.Shell\bin\Debug\netcoreapp3.1\Modules\&quot; /Y /S&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;发现模块&quot;&gt;2.2发现模块&lt;/h5&gt;
&lt;p&gt;然后我们在App.xaml.cs重载实现该函数：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;protected override IModuleCatalog CreateModuleCatalog()
{
   //获取该路径下的文件夹的模块目录
   return new DirectoryModuleCatalog() { ModulePath = @&quot;.\Modules&quot; };
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;使用配置文件app.config注册&quot;&gt;3.使用配置文件App.config注册&lt;/h4&gt;
&lt;h5 id=&quot;注册模块-2&quot;&gt;3.1注册模块&lt;/h5&gt;
&lt;p&gt;我们在主窗体项目PrismMetroSample.Shell添加一个App.config文件:&lt;/p&gt;
&lt;p&gt;App.config:&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&amp;gt;
&amp;lt;configuration&amp;gt;
  &amp;lt;configSections&amp;gt;
    &amp;lt;section name=&quot;modules&quot; type=&quot;Prism.Modularity.ModulesConfigurationSection, Prism.Wpf&quot;/&amp;gt;
  &amp;lt;/configSections&amp;gt;
  &amp;lt;modules&amp;gt;
    &amp;lt;!--注册PatientModule模块--&amp;gt;
    &amp;lt;module assemblyFile=&quot;PrismMetroSample.PatientModule.dll&quot; moduleType=&quot;PrismMetroSample.PatientModule.PatientModule, PrismMetroSample.PatientModule, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null&quot; moduleName=&quot;PatientModule&quot; startupLoaded=&quot;True&quot; /&amp;gt;
    &amp;lt;!--注册MedicineModule模块--&amp;gt;
    &amp;lt;module assemblyFile=&quot;PrismMetroSample.MedicineModule.dll&quot; moduleType=&quot;PrismMetroSample.MedicineModule.MedicineModule, PrismMetroSample.MedicineModule, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null&quot; moduleName=&quot;MedicineModule&quot; startupLoaded=&quot;false&quot; /&amp;gt;
  &amp;lt;/modules&amp;gt;
&amp;lt;/configuration&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中startupLoaded为true则设置自动加载，为&quot;可用时&quot;模块，为false则不加载，设置为“按需”模块&lt;/p&gt;
&lt;h5 id=&quot;发现模块-1&quot;&gt;3.2发现模块&lt;/h5&gt;
&lt;p&gt;修改App.xaml.cs的CreateModuleCatalog函数：&lt;br/&gt;App.xaml.cs：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt; protected override IModuleCatalog CreateModuleCatalog()
 {
    return new ConfigurationModuleCatalog();//加载配置文件模块目录
 }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;二.加载模块&quot;&gt;二.加载模块&lt;/h2&gt;
&lt;p&gt;prism应用程序加载模块有两种方式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;加载“可用时”的模块(默认方式)&lt;/li&gt;
&lt;li&gt;根据情况加载“按需”模块&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; 在代码注册时候，我将通过默认方式注册了PatientModule，然后注册MedicineModule将其设置为&quot;按需&quot;加载，“按需”加载有个好处就是，应用程序运行初始化后，MedicineModule模块是不加载到内存的，这样就提供了很大的灵活空间，默认我们可以加载一些&quot;可用&quot;的模块,然后我们可以根据自身要求去&quot;按需&quot;加载我们所需要的模块&lt;/p&gt;
&lt;p&gt; 这里可以讲解下按需加载MedicineModule的代码实现，首先我们已经在App.cs中将MedicineModule设置为&quot;按需&quot;加载，然后我们在主窗体通过一个按钮去加载MedicineModule，代码如下:&lt;br/&gt;MainWindowViewModle.cs:&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt; public class MainWindowViewModel : BindableBase
 {
    IModuleManager _moduleManager;
    public MainWindowViewModel(IModuleManager moduleManager)
    {
       _moduleManager = moduleManager;
    }

    private DelegateCommand _loadPatientModuleCommand;
    public DelegateCommand LoadPatientModuleCommand =&amp;gt;
        _loadPatientModuleCommand ?? (_loadPatientModuleCommand = new DelegateCommand(ExecuteLoadPatientModuleCommand));

    void ExecuteLoadPatientModuleCommand()
    {
       _moduleManager.LoadModule(&quot;MedicineModule&quot;);
    }
 }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们还可以去检测加载模块完成事件，我们MainWindowViewModle中加上这几句：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;IModuleManager _moduleManager;
public MainWindowViewModel(IModuleManager moduleManager)
{
   _moduleManager = moduleManager;
   _moduleManager.LoadModuleCompleted += _moduleManager_LoadModuleCompleted;
}

private void _moduleManager_LoadModuleCompleted(object sender, LoadModuleCompletedEventArgs e)
{
   MessageBox.Show($&quot;{e.ModuleInfo.ModuleName}模块被加载了&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果如下:&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1294271/202001/1294271-20200112222721020-1743875164.gif&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;三.初始化模块&quot;&gt;三.初始化模块&lt;/h2&gt;
&lt;p&gt;加载模块后，模块就会进行初始化，我们以MedicineModule为例子,先来看看代码：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt; public class MedicineModule : IModule
 {
     public void OnInitialized(IContainerProvider containerProvider)
     {
         var regionManager = containerProvider.Resolve&amp;lt;IRegionManager&amp;gt;();


         //MedicineMainContent
         regionManager.RegisterViewWithRegion(RegionNames.MedicineMainContentRegion, typeof(MedicineMainContent));

         //SearchMedicine-Flyout
         regionManager.RegisterViewWithRegion(RegionNames.FlyoutRegion, typeof(SearchMedicine));

         //rightWindowCommandsRegion
         regionManager.RegisterViewWithRegion(RegionNames.ShowSearchPatientRegion, typeof(ShowSearchPatient));
        }

     public void RegisterTypes(IContainerRegistry containerRegistry)
     {
            
     }
 }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt; 其中，IModule接口定义了两个函数OnInitialized和RegisterTypes,其中初始化顺序是RegisterTypes-&amp;gt;OnInitialized，也就是RegisterTypes函数会先于OnInitialized函数，虽然这里我没在RegisterTypes写代码，但是这里通过是可以依赖注入到容器，给MedicineModule模块使用的，而OnInitialized我们通常会注册模块试图，或者订阅应用程序级别的事件和服务，这里我是将三个View分别分区域注册模块视图&lt;/p&gt;
&lt;p&gt; 最后，其实一开始我们看到Demo演示，点击病人列表，出来的病人详细页是没有数据的，这涉及到窗体之间的通讯，病人列表和病人详细页属于同一模块,这很好办，如何我要将搜索到的药物加到当前病人详细页的药物列表里面，这就涉及到不同模块窗体之间的通讯，处理不好是会造成模块之间的强耦合，下篇我们会讲到如何使用事件聚合器来实现同一模块不同窗体的通讯和不同模块不同窗体的通讯，而完整的Demo也会在下一篇放出。&lt;/p&gt;
</description>
<pubDate>Mon, 13 Jan 2020 00:18:00 +0000</pubDate>
<dc:creator>RyzenAdorer</dc:creator>
<og:description>本文将介绍如何在.NET Core3环境下使用MVVM框架Prism的应用程序的模块化 前言 我们都知道，为了构成一个低耦合，高内聚的应用程序，我们会分层，拿一个WPF程序来说，我们通过MVVM模式去</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ryzen/p/12185054.html</dc:identifier>
</item>
<item>
<title>重新认识C语言的指针(上) - 龙跃十二</title>
<link>http://www.cnblogs.com/zhonglongbo/p/12185530.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhonglongbo/p/12185530.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;​ 独创性并不是首次观察某种新事物，而是把旧的、很早就是已知的，或者是人人都视而不见的事物当新事物观察，这才证明是有真正的独创头脑 —尼采&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p align=&quot;center&quot;&gt;本文已经收录至我的GitHub,欢迎大家踊跃star 和 issues。&lt;/p&gt;
&lt;h3 align=&quot;center&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://github.com/midou-tech/articles&quot; target=&quot;_blank&quot;&gt;https://github.com/midou-tech/articles&lt;/a&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;span&gt;点关注，不迷路！！！&lt;/span&gt;&lt;/h4&gt;
&lt;h3 id=&quot;h&quot;&gt;&lt;span&gt;序言&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt; 指针是C语言学习者绕不过的一道坎，也是C语言学习者不得绕过的一道坎。辨别一个人C语言学的好赖就看他对指针的理解怎么样。指针内容也是工作面试经常问到的问题。本文将带你重新认识那个绊倒你的指针，以解大家的心头之惑(恨)。&lt;/p&gt;
&lt;h4 id=&quot;h-1&quot;&gt;&lt;span&gt;为什么要学习指针？&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt; 有同学就要说了，既然指针这么难，这么不通俗易懂，为什么要学习他呢？其他高级语言都是把这块基本屏蔽掉了，不在让程序员直接操作指针，这里不直接操作指的是不让程序员用指针进行运算和强转而不是彻底没有了。举个java的例子&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;Object obj= &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Object();&lt;br/&gt;Object sec= obj;&lt;br/&gt;sec = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Object();&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt; 如果你去仔细研究他们的行为，就会发现 obj, sec 都只是一个指向对象的东西，可以为空，也可以修改指向，所以它们其实都是指针，只是 Java 的教材里面不在去提这东西而已，具体原因看我后面讲解便知道了。&lt;/p&gt;
&lt;p&gt;​ 继续说为什么学习指针，为什么学习指针就必须要说到指针的优点了。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;指针可以直接操作变量地址，所以很灵活。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;指针操作会减少很多变量的拷贝使得程序性能提升。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;可以动态分配内存。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; 这些优点使得很多后台性能要求很高的系统、游戏内核、一些高并发的中间件都是使用C&amp;amp;C++语言开发出来的。比如强大的linux系统、nginx，mysql、redis等等。&lt;/p&gt;
&lt;p&gt; 曾经看到一个搞笑的评论，hhh&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;道生一，一生二，二生三，三生万物&lt;/p&gt;
&lt;p&gt;电脑生汇编，汇编生C , C生C++，C/C++生万物&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;h-2&quot;&gt;&lt;span&gt;指针是什么？&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt; 其实指针看起来复杂，听起来复杂，学起来复杂，但是总结下来指针到底是个啥，也就一句话。&lt;/p&gt;

&lt;h4&gt;&lt;span&gt;指针就是地址，指针变量就是一个存放内存地址的变量&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://i01piccdn.sogoucdn.com/db3bc129d2c88816&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 你没看看错，是的就是这么简单明了。通常我们说的指针就约等于说的是指针变量。&lt;/p&gt;
&lt;h3 id=&quot;h-3&quot;&gt;&lt;span&gt;指针和内存地址的关系&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt; 很多人不明白指针其实也就是不明白内存地址，所以要想明白指针必须先明白指针和内存之间的关系。在讲内存和指针之间的关系之前先说下什么是内存。&lt;/p&gt;
&lt;p&gt; 先明白一个问题，什么是内存？编程人员常说的内存指的是什么？&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;​ 内存是电脑的一个硬件组成部分。从单片机的组成我们可以看到，CPU、内存和输入输出接口，就组成一个完整的电脑，其他统统属于外设。内存是可以被CPU通过总线进行操作的，也就是与CPU之间有总线相连接的。电脑所有的输入输出，都是要从内存来实现的。内存包括只读内存ROM和读写内存RAM，但在个人电脑（PC）中，我们通常所说的内存，是指读写内存。&lt;/p&gt;
&lt;p&gt;​ 程序人员常说的内存其实是虚拟内存，程序直接操作的是虚拟内存而不是真正的物理内存。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;纳尼&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1ganbc7v3g0j3050050747.jpg&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;程序都是操作的虚拟内存？ 那虚拟内存是个啥东西？

&lt;p&gt; 这里先给大家画张C语言程序的内存布局图。&lt;strong&gt;关于进程和内存管理会在后面的文章讲出来，记得微信搜索 龙跃十二 点关注。&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gaoeriqv47j30r90mp77g.jpg&quot; alt=&quot;内存布局图&quot; title=&quot;内存布局图&quot;/&gt;内存布局图
&lt;p&gt; 这个图很好的描述了内存地址的布局，指针变量里面存放的地址也就是这个内存地址。顺便说下啥是内存地址，用十六进制表示出来的一串数字编号(就好比你家的门牌号)，只是这个数字是给内存标号的。32位系统下这个编号是4byte(32个bit)表示的，64位系统下是8byte(64bit)表示的。(这个小问题面试会被问到的)&lt;/p&gt;
&lt;h3 id=&quot;h-4&quot;&gt;&lt;span&gt;如何使用指针？&lt;/span&gt;&lt;/h3&gt;
&lt;h4 id=&quot;h-5&quot;&gt;&lt;span&gt;指针的声明&lt;/span&gt;&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;c language-c hljs cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; *p;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;char&lt;/span&gt; *p1;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;float&lt;/span&gt; *p2;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt; 声明还是很简单，指针的类型 * 变量名即可声明一个指针变量。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;c language-c hljs cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; num = &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; *p = &amp;amp;num;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt; 此时就是一个int类型的指针变量指向一个int变量，画个图解释下。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gapmdjy879j30lo0camxr.jpg&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt; 以很清楚的看到指针p存放着变量num的地址，我们通常说指针p指向变量num，当p知道变量num之后，p就可以对变量num为非作歹了，比如&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;c language-c hljs cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; num = &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; *p = &amp;amp;num;&lt;br/&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;*p=%d,num=%d\n&quot;&lt;/span&gt;,*p,num);  &lt;br/&gt;p+=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;*p=%d\n&quot;&lt;/span&gt;,*p);    &lt;br/&gt;} &lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;h-6&quot;&gt;&lt;span&gt;指针的大小和类型&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt; 从上面的声明实例可以看到我定义了三种类型的指针，可以看出指针是有类型的。这里有同学就有疑问了，不是存放内存地址的么，内存地址不就是一串十六进制表示的数字么(其实底层都是二进制)，哪来的什么类型一说呢，为什么又需要类型呢？&lt;/p&gt;
&lt;p&gt; 这个疑问很好，我当时学习的时候也是很疑惑。首先我们明白了指针是一个存放地址的变量，明白这点还不够还必须理解另外一个问题就是&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;字节（Byte）是用于计量存储容量的一种单位，每一个字节由8位组成（1Byte = 8bit）。地址可以理解为在一片内存中，每个字节（Byte）的编号。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 所以很多人肯定会明白了，指针存放的是一个变量的首个字节的地址，那么问题来了。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;c language-c hljs cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; a = &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;; &lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; *p = &amp;amp;a;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt; 我们声明指针p指向变量a的地址，也就是说指针p里面存放着变量a的首地址，在32位平台下，int a 是4字节，指针去取a的值的时候找到的是a的首地址，那怎么拿到变量a，聪明的同学已经恍然大悟，是的，没错，所以我们的指针需要类型的，编译器去取指针指向的内容时候会根据指针的类型去取。画个图如下&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gat1k1ncnjj30ve0i0jsw.jpg&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt; 此刻我相信你对指针已经有了很高的理解了。指针的大小很好理解 &lt;strong&gt;就是存放地址的范围，地址的范围是操作系统地址线的根数决定，所以指针的大小是随操作系统的寻址范围决定的，一般32位系统地址总线也是32根，寻址范围是2^32次方&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 顺便说下32位操作系统和64位操作系统的区别在哪里，系统的位数代表运算能力，所谓32位就是能计算的字长是32位的，64位系统能计算的字长是64位。&lt;strong&gt;处理器的字长越大，说明它的运算能力越强。&lt;/strong&gt;&lt;/p&gt;
&lt;h5 align=&quot;center&quot;&gt;&lt;span&gt;点赞👍 关注❤️ 走一波，精彩内容不错过&lt;/span&gt;&lt;/h5&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gat1lew0img308c08cwex.gif&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;h4 id=&quot;h-7&quot;&gt;&lt;span&gt;指针的操作符&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt; 目前我们已经了解到指针的解引用 *p 和 &amp;amp; 两个操作符，下面将带你了解更多的操作符。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;操作符&lt;/th&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;*p&lt;/td&gt;
&lt;td&gt;解引用&lt;/td&gt;
&lt;td&gt;取出指针对应的内容&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;-&amp;gt;&lt;/td&gt;
&lt;td&gt;指向&lt;/td&gt;
&lt;td&gt;用来访问指针引用的字段&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;+ &amp;amp; +=&lt;/td&gt;
&lt;td&gt;加 和 加等&lt;/td&gt;
&lt;td&gt;指针的加法&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;- &amp;amp; -=&lt;/td&gt;
&lt;td&gt;减 和 减等&lt;/td&gt;
&lt;td&gt;指针的减法&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;==&lt;/td&gt;
&lt;td&gt;等于&lt;/td&gt;
&lt;td&gt;比较两个指针&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;!=&lt;/td&gt;
&lt;td&gt;不等于&lt;/td&gt;
&lt;td&gt;比较两个指针&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&amp;gt; &amp;amp;&amp;gt;=&lt;/td&gt;
&lt;td&gt;大于 和 大于等于&lt;/td&gt;
&lt;td&gt;比较两个指针&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&amp;lt; &amp;amp; &amp;lt;=&lt;/td&gt;
&lt;td&gt;小于 和 小于等于&lt;/td&gt;
&lt;td&gt;比较两个指针&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;​  不知道还记不记得上面代码中的这个例子。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gat282f4ehj30vk096ta3.jpg&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt; 这里使用到了两个指针的操作符，*p 和 p+=1。重点说下p+=1，他代表的是p=p+1，p指针此时指向了num变量的最后一个字节的下一个地址，指向了一个未声明的内容。不知道大家有没有尝试那句代码会不会报错？&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gat2da59hhj305k05kglg.jpg&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt; 还是要多练习一下的，说下结果，那句代码不会报错，会很顺利的打印出一个内容。是不是好危险，这个内容明明不是你的，是的操作指针就是很危险，但是同时也会很灵活。（世界就是这样子你得到一些东西就会失去一些东西。此时你得到了指针的高效，灵活，你就必须去平衡一些其他问题。还有一个很明显的例子，算法中常常面临到时间和空间的平衡问题。）&lt;/p&gt;
&lt;p&gt; 平时用到最多的是前面六个，含义上面表里已经罗列，我重点介绍下+和-操作符。指针的＋1代表指针的位置移动指针对应大小个字节。看个图，大家肯定瞬间明白。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gat2wnctmjj30g80eut93.jpg&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;h4 id=&quot;h-8&quot;&gt;&lt;span&gt;多级指针&amp;amp;多级指针的解引用&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt; 看到这里，我相信聪明的大家对一级指针有了很明确的认识了，接下来带大家了解下多级指针和多级指针的解引用问题。很多人看到多级指针这就想放弃了，但是龙叔我就想说&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gat36egbqcj308u064q2y.jpg&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt; &lt;strong&gt;把握一个核心本质就是，指针就是地址，指针变量就是存放地址的变量&lt;/strong&gt; 多级指针无非就是饶了几个弯子，本质没变的。例如&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;c language-c hljs cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; num = &lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; *p = &amp;amp;num;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; **sp = &amp;amp;p;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; ***ssp = &amp;amp;sp;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt; 没错吧，本质没变的，就是饶了几个弯子。所以学习这件事情一定要把握本质的东西，那些变着花样也不过如此，岂能难道我辈。&lt;/p&gt;
&lt;p&gt; 当然这只是举例子，多级指针很明显不是这种用法，这样用符合逻辑，但是没啥意义。看个多级指针的示例&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;c language-c hljs cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; arr[&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;][&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;] = {{&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;},{&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;},{&lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;}};&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; **p = arr;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt; 说到使用指针，减少数据拷贝，我就想到经历的一个bug，差点线上瘫痪。&lt;/p&gt;
&lt;h4 id=&quot;hcase&quot;&gt;&lt;span&gt;工作case&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt; 写了一个简单的代码，展示下伪代码。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;c language-c hljs cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;fun&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt; a,&lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt; b)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt; 就这样简单的一个功能函数，写完，自己测试ok，还让同事review了代码。完全没问题，大概十二点左右我发布上线了，一般发布之前会小流量灰度，发布也是轮流上线，这些都ok。但是晚上九点多，我意外收到报警了，内存瞬间飙升95.7%，我没有丝毫犹豫，我自己今天发布代码了，留了一台机器现场，其他立马回滚，一通操作。老大跑过来一起review代码，观察监控数据。老大还是厉害，扫了一眼代码，立马发现问题，你这里函数参数为啥不使用引用或者const char* 类型，你把这个改了自己压测下。&lt;/p&gt;
&lt;p&gt; 错误很明显，就是没用指针导致函数参数数据拷贝，在晚上流量高峰的时候，内存被瞬间抽干。这样的例子看起来很简单，我们日常写代码时候可能不会太在意，但是在处理高并发、强实时的问题上一定要慎重处理。&lt;/p&gt;
&lt;p&gt; 今天就说到这里吧，下一篇给大家讲解指针的特性和指针的安全。&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;求点赞👍 求关注❤️&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;span&gt;「转发」是明目张胆的喜欢，「在看」是偷偷摸摸的爱。&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;如果有人想发文章，我这里提供&lt;/code&gt;&lt;span&gt;有偿征文&lt;/span&gt;&lt;code&gt;(具体细则微信联系)，欢迎投稿或推荐你的项目。提供以下几种投稿方式：&lt;/code&gt;&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;去我的github提交 issue:&lt;/code&gt; https://github.com/midou-tech/articles&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;发送到邮箱: 2507367760@qq.com 或者 longyueshier@163.com 或者 longyueshier@gmail.com&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;微信发送: 扫描下面二维码，公众号里面有作者微信号。&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;精选文章都同步在公众号里面，公众号看起会更方便，随时随地想看就看。微信搜索 龙跃十二 或者扫码即可订阅。&lt;/code&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1galsp9a07kj30p00dwae3.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 13 Jan 2020 00:00:00 +0000</pubDate>
<dc:creator>龙跃十二</dc:creator>
<og:description>指针是C语言学习者绕不过的一道坎，也是C语言学习者不得绕过的一道坎。辨别一个人C语言学的好赖就看他对指针的理解怎么样。指针内容也是工作面试经常问到的问题。本文将带你重新认识那个绊倒你的指针，以解大家的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhonglongbo/p/12185530.html</dc:identifier>
</item>
</channel>
</rss>