<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>使用 CompletableFuture 异步组装数据 - 猫咪大王_lkb</title>
<link>http://www.cnblogs.com/catlkb/p/12250725.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/catlkb/p/12250725.html</guid>
<description>&lt;p&gt;&lt;strong&gt;一种快捷、优雅的异步组装数据方式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;实际项目中经常遇到这种情况： 从多个表中查找到数据然后拼装成一个VO返回给前端。&lt;br/&gt;这个过程有可能会非常耗时。因为最终每一条返回的VO数据是由多个表中的数据拼装而成，如果项目还是微服务需要从其他服务获取数据，那将会更加耗时，更加麻烦。简单的几十条、几百条数据单个线程跑起来可能没有什么压力，但是当数量达到成千上万，几十万，几百万，组装的逻辑也变得非常复杂时，这个操作就非常耗时。&lt;/p&gt;
&lt;p&gt;最近我在项目中就遇到这个的情况。项目中我们需要做一个相关流程数据的下载功能。&lt;br/&gt;最初版本使用单线程，因为业务的复杂性，5000多条数据完全下载下来需要30min。以为是从数据库分拣数据比较耗时，查询日志后发现数据库查询并没有耗时多久，反而是组装数据占用了大多数时间。&lt;/p&gt;
&lt;p&gt;因此机智的我就想起之前同组小伙伴分享的Java8一个新的类CompletableFuture。&lt;/p&gt;
&lt;h2 id=&quot;completablefuture-简介&quot;&gt;CompletableFuture 简介&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;CompletableFuture 是Java 8 新增加的Api,该类实现，Future和CompletionStage两个接口，提供了非常强大的Future的扩展功能，可以帮助我们简化异步编程的复杂性，提供了函数式编程的能力，可以通过回调的方式处理计算结果，并且提供了转换和组合CompletableFuture的方法。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;具体大家可以查看&lt;a href=&quot;https://www.apiref.com/java11-zh/java.base/java/util/concurrent/CompletableFuture.html&quot; title=&quot;java api文档&quot;&gt;Java Api 文档&lt;/a&gt;，或者阅读网上一些博客。&lt;/p&gt;
&lt;h2 id=&quot;completablefuture-异步组装数据&quot;&gt;CompletableFuture 异步组装数据&lt;/h2&gt;
&lt;p&gt;代码示例如下&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
     * 功能描述: 拼装数据
     * @author lkb
     * @date 2019/12/25
     * @param
     * @return java.util.List&amp;lt;com.laidian.erp.crm.vo.DeviceProcessListExportVO&amp;gt;
     */
    private List&amp;lt;DeviceProcessListExportVO&amp;gt; listByFlowJobIds(List&amp;lt;String&amp;gt; flowJobIds, Map&amp;lt;String, ProcessInfoVo&amp;gt; map, Map&amp;lt;Integer,UserInfoDTO&amp;gt; userInfoDTOMap, Map&amp;lt;Integer,HatCity&amp;gt; cityMap){
        //result 列表保存组装完成的数据
        List&amp;lt;DeviceProcessListExportVO&amp;gt; result = new LinkedList&amp;lt;&amp;gt;();
        //每次组装100条数据
        List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; partition = Lists.partition(flowJobIds,100);
        List&amp;lt;CompletableFuture&amp;gt; futures = partition.stream().map(subList -&amp;gt; CompletableFuture.supplyAsync(() -&amp;gt; {
            //packVOs 方法就是组装数据
            return packVOs(subList,map,userInfoDTOMap,cityMap);
        },ASYNC_IO_POOL).whenCompleteAsync((r,e)-&amp;gt;result.addAll(r))
                        .exceptionally(e-&amp;gt;{
                            log.error(e.getMessage(),e);
                            log.error(&quot;listByFlowJobIds error.&quot;);
                            return result;
                        })).collect(Collectors.toList());

        CompletableFuture&amp;lt;Void&amp;gt; all = CompletableFuture.allOf(futures.toArray(new CompletableFuture[futures.size()]));
        log.info(&quot;任务阻塞 &quot;);
        Instant start = Instant.now();
        //阻塞，直到所有任务结束。
        all.join();
        log.info(&quot;任务阻塞结束 耗时 = {}&quot;,ChronoUnit.MILLIS.between(start, Instant.now()));
        return result;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体步骤如下：&lt;/p&gt;
&lt;ol readability=&quot;1.5&quot;&gt;&lt;li&gt;将原始数据按照每组100条进行拆分。（具体每组拆分多少条需要根据实际的业务情况和服务器性能，多测试一下应该就知道了）&lt;/li&gt;
&lt;li&gt;多线程组成数据，每个线程组装一组数据（上面拆分的100条原始数据）。packVOs 方法就是组装数据。为了高效，我建议 &lt;strong&gt;在组装数据的时候多采用批量，缓存的思想&lt;/strong&gt;，能批量尽量批量，重复数据就尽量缓存下来。&lt;/li&gt;
&lt;li readability=&quot;3.5&quot;&gt;
&lt;p&gt;CompletableFuture.supplyAsync() 方法说明如下。第一个参数是线程需要执行的动作，第二个参数是线程执行用的Executor，可以填自定义的，也可以不填写，不填写程序会使用默认的执行器。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;public static CompletableFuture supplyAsync(Supplier supplier, Executor executor)&lt;br/&gt;返回由给定执行程序中运行的任务异步完成的新CompletableFuture，其中包含通过调用给定供应商获得的值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;whenCompleteAsync 方法含义和名字一样，将上一步执行的结果或者异常作为参数传给指定的参数。这里我们希望分批组装的结果能过add进result中。&lt;/li&gt;
&lt;li&gt;exceptionally 是用来处理异常。当一个线程执行出现异常的时候应该执行怎样的操作。&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;all.join() 这个方法是等待所有的任务（所有的CompletableFuture）完成。组装数据是耗时的，如果我们不等待所有组装任务完成，直接返回result，相信result中不会有数据，或者数据是不完整的。我们期待的结果是所有的数据都正常组装完成，添加进result。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;使用了CompletableFuture方式实现多线程分批组装，并且在组装时采用 “批量+缓存” 的思想，原来5000条数据30min缩短为3min。当然还有优化的空间，但是能达到这个效果已经让我非常满意了。&lt;/p&gt;
&lt;p&gt;下次遇到类似的情况，我会优先考虑CompletableFuture分批组装的方式，快捷、优雅。你们有好的方法呢？&lt;/p&gt;
</description>
<pubDate>Sat, 01 Feb 2020 15:41:00 +0000</pubDate>
<dc:creator>猫咪大王_lkb</dc:creator>
<og:description>使用 CompletableFuture 异步组装数据 一种快捷、优雅的异步组装数据方式 实际项目中经常遇到这种情况： 从多个表中查找到数据然后拼装成一个VO返回给前端。 这个过程有可能会非常耗时。因</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/catlkb/p/12250725.html</dc:identifier>
</item>
<item>
<title>机器学习-TensorFlow应用之classification和ROC curve - HappyPuppy</title>
<link>http://www.cnblogs.com/tangxiaobo199181/p/12250562.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tangxiaobo199181/p/12250562.html</guid>
<description>&lt;p&gt;前面几节讲的是linear regression的内容，这里咱们再讲一个非常常用的一种模型那就是classification，classification顾名思义就是分类的意思，在实际的情况是非常常用的，例如咱们可以定义房价是否过高，如果房价高于100万，则房价过高，设置成true；如果房价低于100万，则房价不高，target就可以设置成false。这里的target就只有2种，分别只有True和False，而不像咱们的的linear regression那样target是连续的。在实际的应用中，这是有非常广泛的应用的，这一节的第一部分主要是讲如何用TensorFlow来训练一个classifier模型来预测classification problems。第二部分主要解释一下measure classification模型的的方法，那就是ROC curve。在linear regression中咱们知道有MAE，MSE等等一些列的方式来判断咱们的模型的表现怎么样，那么在classification中，MAE和MSE都不适用的，那么咱们用什么measurement来判断咱们的模型好不好呢？这时候就需要介绍咱们的ROC curve了。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;TensorFlow应用之Classification&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果咱们的target只有2个（True/False 或者 1/0等等），这种情况咱们一般称之为binary classification problem；如果咱们的target的数量大于2，咱们一般称之为multi_class classification problem。这两种方式无论是哪一种，在咱们用TensorFlow训练的时候，它的的API都是一样的，只是multi-class需要在定义模型的的时候设置一个n_classes参数而已，其他都一样。另外的建模过程跟前面章节说的一样，这一节主要介绍一下他在TensorFlow的应用中跟linear regression的区别，所以我就不会展示整个建模的过程，只会展示他们的不同。第一个不同就是模型定义的时候不同，那么现在来看一下吧&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
linear_classifier = tf.estimator.LinearClassifier(feature_columns =&lt;span&gt; construct_feature_columns(trainning_features),
                                                      optimizer &lt;/span&gt;=&lt;span&gt; my_optimizer&lt;br/&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　)

linear_classifier &lt;/span&gt;= tf.estimator.LinearClassifier(feature_columns =&lt;span&gt; configure_feature_columns(),                                                      
                                                      n_classes &lt;/span&gt;= 10&lt;span&gt;,
                                                      optimizer &lt;/span&gt;=&lt;span&gt; my_optimizer,
                                                      &lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面咱们可以看出来有两种定义classifier的方式，他们用的是LinearClassifier()来实例化模型的，而不像linear regression那样用LinearRegressor(); 其次上面的第一种没有n_classes这个参数，则说明是binary classification，因为他的默认值就是2；上面第二种方式则说明这是一个multi_class classification的问题。所以综上所述，它也是一个非常简单的定义的过程；&lt;/p&gt;
&lt;p&gt;其次当咱们用的这个classifier来predict的时候，咱们可以看出来它的结果的数据结构跟linear regressor是不同的，下面我把的的结构在Spyder中打开给大家看一下&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1287224/202002/1287224-20200201103913593-2049739966.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 咱们可以看出来，它的prediction的结果是一个list，list里面的element是dictionary，每一个dictionary都有6个key-value pairs。这个dictionary的信息也是非常丰富的，从上面的图片可以看出来咱们的模型计算出来的结果就是class_ids这个key对应的value，当然啦，classifier计算的结果是每一种class的概率，然后选择概率最大的那一个；概率的对于的key很显然是probabilities这个字段。在其他方面，TensorFlow在classification problem中的应用的流程基本跟linear regression是一样的。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Classifier measurement&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;　　Accuracy&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　我们知道在前面的linear regression中，咱们可以用MAE,MES等等measurements来判断一个模型是否好呢？这里对于binary classification的问题，咱们可以经常使用Accuracy, ROC等方式来判断一个模型是否合格，另外在multi-classes的场景中，咱们也可以使用Accuracy和logloss等方法来判断，但是英文accuracy有它固定的缺陷，所以咱们经常不拿它作为最终参考的对象，只起一个辅助的作用。好了，那么咱们接下来来分别讲述一下他们的细节部分，在正式将这些metric之前，先给大家看一个谷歌官方教程的matrix&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1287224/202002/1287224-20200201213021653-1406719067.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 咱先来看看几个概念分别是TP, TN, FP, FN; 在这个例子中我们定义Malignant 的值是True, Benign的值是False。那么很显然上面绿色的部分就是咱们的模型预测的跟实际的是一样的；红色的部分则是怎么预测错误了，就是预测的跟实际的不一样。根据Accuracy的的定义，咱们很容易就能得到下面的公式&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1287224/202002/1287224-20200201213514274-389895787.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 咱们来看看上面的例子，咱们总共的数据有100条，分别有91个Benign（良性）, 9个Malignant（恶性）; 如果咱们的模型预测的结果如上的matrix所示，那么根据accuracy的公式，咱们可以看出咱的的准确率高达91%，看其实还不错哦，对吧？那么咱们能用这个模型来预测吗？？答案是不可以！！！咱们来仔细分析一下哈，上面的数据一共有9个malignant 恶性肿瘤，可是咱们的模型竟然只准确的预测出一个malignant （TP），其他的8个malignant竟然都没有预测出来，很显然这是有很大问题的！！！！那么为什么咱们的accuracy还是这么高呢？？这是因为咱们的数据target的分布是非常不均匀的，换句话说咱们的数据是class-imbalanced dataset, 例如咱们的数据中有高达91%的Benign, 只有19%的的malignant，这个数据是非常不平衡的；咱们再举个极端的例子，上面的情况，即使咱们的模型prediction始终等于Negative，即无论什么数据送进来，咱们的预测结果始终都是Negative, 咱们的accuracy也是高达91%，这是不是很不合理？？所以在判断咱们模型的时候，一定要慎用accuracy，尤其是在class-imbalanced dataset中。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;　　AUC-ROC Curve&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这个是咱们在binary classification problem中判断一个模型好坏的一个最常用的一种方式， AUC是Aera Under Curve的缩写，很显然它是一个计算一条曲线下面的面积的函数， ROC是Receiver Operating Characteristics的缩写；那么根据名字咱们就知道AUC-ROC curve就是计算ROC curve下面的面积的一个方法。那么ROC curve到底长什么样呢？首先ROC的纵坐标是TPR（Ture Positive Rate）, 横坐标是FPR(False Positive Rate). 那么具体的TPR和FPR又是什么意思呢，咱们看下面的公式&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1287224/202002/1287224-20200201220110561-317890125.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1287224/202002/1287224-20200201220135840-578808302.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1287224/202002/1287224-20200201220154801-663995857.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 上面的公式分别表达TPR和FPR的定义的意思，其中Specificity咱们可以将它看成是Ture Negative Rate。那么这么看，咱们还是有点懵懵懂懂的不知道他们的具体含有，咱们可以结合下面的图来理解TPR, FPR&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1287224/202002/1287224-20200201220803093-1711062799.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 结合上面的图片，咱们可以认为TPR就是在所有的Positive的数据中，咱们正确预测出的Positive占咱们整个Positive数据数量的比例； FPR就是在咱们所有的Negative的数据中， 咱们错误的预测的数量占咱们整个Negative数据的比例。上面一句话一定一定要理解，否则什么都白瞎。那么咱们最终的ROC长什么样呢？看下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1287224/202002/1287224-20200201221256408-955923537.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;咱们每选择一个threshold，咱ROC上面就绘制一个点，通过选择多个threshold最终画出了上面的ROC curve。 那么接着问题又来了，咱们既然已经绘制了ROC curve，咱们如何用它来判断咱们模型的好坏呢？其实就是通过计算ROC curve下面的面积（AUC）来判断的， &lt;strong&gt;AUC的意思是代表这这个模型分辨咱们classes的能力！！！！&lt;/strong&gt;记住这句话，一定要记住。AUC-&amp;gt;1代表着咱们的模型能够完全分辨出classes，AUC-&amp;gt;0则说明咱们的模型预测的classes完全是相反的，其实这种情况也非常好，咱们只需要通过简单的取反就能够达到几乎完美的模型；最差的一种情况是AUC-&amp;gt; 0.5,这个时候意味着咱们的模型一点分辨能力都没有，跟咱们胡乱猜的结果是一样的。&lt;/p&gt;
&lt;p&gt;根据咱们的分析，上面的ROC的方式只适用于binary classes的情况，那么如果咱们的classes有很多怎么办，例如有10个classes，这时候咱们就无法通过计算AUC-ROC的方式来判断咱们的模型了，咱们就得通过另外一种方式来判断咱们的模型好坏了，那么这个就是Log Loss了。具体LogLoss的数学意义以及原理，我会在下一节来解释，这里我就用最简单的方式演示一下他的应用，其实在classification problem中，咱们的loss function就是Log Loss, 在linear regression中咱们的loss function是 Mean Squared Error. 具体它们的意义，我会在后面的一节详细的展示它们的意义和推导过程。好了，那么现在咱们来看一下，咱们如何计算出咱们的log loss从而来判断出咱们classfier是不是一个好的可用的模型&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
trainning_predictions_one_hot = tf.keras.utils.to_categorical(trainning_class_id,10&lt;span&gt;)
metrics.log_loss(trainning_targets, trainning_predictions_one_hot)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面咱们介绍了一些classification 模型在训练中和linear regression不一样的地方，以及用什么metrics来最终判断咱们的classification模型，这里介绍了一下Accuracy， AUC-ROC和Log Loss. 其中的重点是AUC-ROC的含义和过程，然后知道Accuracy的一些应用场景，以为为什么有时候不能用它。最后了解一下Log loss是用来干什么的以及如何用它就行了。&lt;/p&gt;
</description>
<pubDate>Sat, 01 Feb 2020 14:45:00 +0000</pubDate>
<dc:creator>HappyPuppy</dc:creator>
<og:description>概述 前面几节讲的是linear regression的内容，这里咱们再讲一个非常常用的一种模型那就是classification，classification顾名思义就是分类的意思，在实际的情况是非</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tangxiaobo199181/p/12250562.html</dc:identifier>
</item>
<item>
<title>《即时消息技术剖析与实战》学习笔记9——IM系统如何支持消息的多终端漫游 - 鹿呦呦</title>
<link>http://www.cnblogs.com/sunshineliulu/p/12248674.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sunshineliulu/p/12248674.html</guid>
<description>&lt;h4 id=&quot;一什么是多终端漫游&quot;&gt;一、什么是多终端漫游&lt;/h4&gt;
&lt;p&gt;多终端漫游是指：用户在任意一个设备登录后，都能获取到历史的聊天记录。如：QQ 默认漫游 7 天的聊天记录，开通 VIP 会员可漫游 30 天，开通 SVIP 会员可漫游 2 年。&lt;/p&gt;
&lt;h4 id=&quot;二多终端漫游的实现&quot;&gt;二、多终端漫游的实现&lt;/h4&gt;
&lt;p&gt;支持消息多终端漫游一般需要两个条件：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;设备在线状态&lt;/li&gt;
&lt;li&gt;离线消息存储&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;通过设备的在线状态来实现&quot;&gt;1. 通过设备的在线状态来实现&lt;/h5&gt;
&lt;p&gt;记录设备的在线状态，当用户在多个终端同时登录并发送消息时，IM 服务端将收到的消息推给接收方的多台在线设备，同时推给发送方的其他登录设备。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/953680/202002/953680-20200201223714884-1773855166.png&quot;/&gt;&lt;br/&gt;可以看到，当多终端同时在线，只需要维护设备的在线状态就可以了。&lt;/p&gt;
&lt;h5 id=&quot;通过离线消息存储来实现&quot;&gt;2. 通过离线消息存储来实现&lt;/h5&gt;
&lt;p&gt;上面的图是假设接收方或发送方的多台终端设备都是在线状态，若发送方或接收方用户的多台终端设备中，某些设备是离线状态，此时发送消息，IM 服务端只会将消息推送给在线设备，同时将消息存储到服务器，以便离线设备上线后同步历史消息。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/953680/202002/953680-20200201223733166-1531426501.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;离线消息的同步机制&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;用户的某台离线设备上线后，需要知道获取哪些离线消息，一般采用版本号实现多终端和服务端的数据同步，保证离线消息可以做到按需拉取。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/953680/202002/953680-20200201223751298-599488190.png&quot;/&gt;&lt;br/&gt;同步流程如图所示：&lt;br/&gt;① 当有消息需要推送给用户时，会为每条消息生成一个版本号，并连同消息存入离线存储中，同时更新服务端维护的接收方用户的最新版本号，并将只携带版本号的消息发送给发送方设备，使发送方设备的最新版本号和服务端同步。&lt;br/&gt;② 接收方的在线设备接收到消息后，更新本地的最新版本号为收到的最后一条消息的版本号。&lt;br/&gt;③ 当接收方的离线设备上线时，会提交本地最新版本号到服务端，服务端比对服务端维护的该用户的最新版本号和客户端提交上来的版本号，如不一致，服务端会根据客户端的版本号从离线存储获取“比客户端版本号新”的消息，并推送给新上线的客户端。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;离线消息的存储&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;离线消息的存储，不仅包括消息内容本身，还需要存储一些操作（删除、撤销等）的信令。比如：用户 A 在一台已上线的设备删除/撤销了某条发送给用户 B 的消息，这个操作的信令也会和消息一起存储起来，这样当用户 A 的另一台离线设备上线时，就不会同步这个已删除/撤销的消息。&lt;/p&gt;
&lt;p&gt;所以存储离线消息时，会存储消息内容、操作信令、消息对应的版本号。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;离线消息的淘汰机制&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;离线消息的存储成本比较高，因为不知道用户有几个设备，也不知道用户的离线设备多久上线，所以离线消息的存储一般会有时限和条数的限制，比如保留 1 周时间，最多存储 1000 条，若在保留时间内消息超过规定条数，在不超过大小限制和时效限制的前提下，采用 &lt;strong&gt;FIFO（先进先出）&lt;/strong&gt; 的淘汰机制，这样用户的离线设备如果某一天上线，只会同步最近一周的历史记录，也可能消息超过保留时间反而什么都没同步哦🤷‍♀️&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;消息打包下推和压缩&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于较长时间不上线的用户，上线后需要拉取的离线消息比较多，如果一条一条下推会导致整个过程很长，客户端看到的就是一条一条消息蹦出来，体验会很差。因此，针对离线消息的下推会采用&lt;strong&gt;整体打包、压缩推送&lt;/strong&gt;的方式来把多条消息合并成一个大包推下去，不仅能减少网络传输时间，还能节省用户的流量消耗。实现上可以通过 &lt;code&gt;header&lt;/code&gt; 标识告知客户端这是一个压缩过的打包消息，客户端收到后解压即可。&lt;/p&gt;
&lt;h4 id=&quot;后记&quot;&gt;后记&lt;/h4&gt;
&lt;p&gt;这篇文章学完后，感觉有很多不明白的地方，但看完精选留言后又茅塞顿开，还是要多学习、多思考。&lt;/p&gt;
</description>
<pubDate>Sat, 01 Feb 2020 14:39:00 +0000</pubDate>
<dc:creator>鹿呦呦</dc:creator>
<og:description>IM系统如何实现消息的多终端漫游</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sunshineliulu/p/12248674.html</dc:identifier>
</item>
<item>
<title>Mybatis基础（一） - 沐雨橙风~~</title>
<link>http://www.cnblogs.com/coding-996/p/12250469.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/coding-996/p/12250469.html</guid>
<description>&lt;hr/&gt;&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;h2 id=&quot;mybatis概述&quot;&gt;mybatis概述：&lt;/h2&gt;
&lt;p&gt;&lt;big&gt;MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。&lt;/big&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;h2 id=&quot;安装mybatis&quot;&gt;安装mybatis：&lt;/h2&gt;
&lt;p&gt;&lt;big&gt;1.方式一：直接将mybatis-x.x.x.jar文件放置在classpath中，一般情况不用这种。&lt;/big&gt;&lt;/p&gt;
&lt;p&gt;&lt;big&gt;2.方式二：使用 Maven 来创建项目，将下面的 dependency 代码置于 pom.xml 文件中，该方法电脑要连接网络下载配置所需的文件（有时候maven会有点慢，等一下）：&lt;/big&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

    &amp;lt;groupId&amp;gt;org.example&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;MybatisDemo_1&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;!-- 记得加下面这一行--&amp;gt;
    &amp;lt;packaging&amp;gt;jar&amp;lt;/packaging&amp;gt;

&amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;!-- 这个依赖是为了获取mybatis包--&amp;gt;
          &amp;lt;groupId&amp;gt;org.mybatis&amp;lt;/groupId&amp;gt;
          &amp;lt;artifactId&amp;gt;mybatis&amp;lt;/artifactId&amp;gt;
          &amp;lt;version&amp;gt;x.x.x&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;!-- 这个依赖是为了获取mysql数据库包--&amp;gt;
            &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;5.1.40&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
           &amp;lt;!-- 这个依赖是为了获取日志信息--&amp;gt;
            &amp;lt;groupId&amp;gt;log4j&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;log4j&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.2.12&amp;lt;/version&amp;gt;
     &amp;lt;/dependency&amp;gt;
    &amp;lt;!--一般必须配置的就是mybatis包，数据库包，其他项可以根据自己情况而配置 --&amp;gt;
&amp;lt;/dependencies&amp;gt;
&amp;lt;/project&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ &lt;big&gt;到这里maven的基本配置就结束了，接下来演示一个入门案例.&lt;/big&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;ul&gt;&lt;li&gt;
&lt;h2 id=&quot;前期准备创建数据库和数据表&quot;&gt;前期准备：创建数据库和数据表&lt;/h2&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;DROP TABLE IF EXISTS `user`;

CREATE TABLE `user` (
  `id` int(11) NOT NULL auto_increment,
  `username` varchar(32) NOT NULL COMMENT '用户名称',
  `birthday` datetime default NULL COMMENT '生日',
  `sex` char(1) default NULL COMMENT '性别',
     
  `address` varchar(256) default NULL COMMENT '地址',
  PRIMARY KEY  (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

insert  into user(`id`,`username`,`birthday`,`sex`,`address`) values 
(1,'小琼','2018-02-27 17:47:08','女','宣威'),
(2,'小琼琼','2018-03-02 15:09:37','女','南宁'),
(3,'大琼','2018-03-04 11:34:34','女','北海'),
(4,'琼琼','2018-03-04 12:04:06','女','云南'),
(5,'琼包','2018-03-07 17:37:26','男','广西'),
(6,'小杨','2018-03-08 11:44:00','女','贵州');
select * from USER;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;一.mybatis环境配置创建实体类和dao接口&quot;&gt;一.mybatis环境配置：创建实体类和Dao接口&lt;/h2&gt;
&lt;p&gt;&lt;big&gt;1.在&lt;code&gt;src/main/java&lt;/code&gt;下面创建一个三层级的目录结构：&lt;code&gt;com/Test/User&lt;/code&gt;和&lt;code&gt;com/Test/Dao&lt;/code&gt;,其中在&lt;code&gt;Test&lt;/code&gt;目录下面有两个文件夹&lt;code&gt;User&lt;/code&gt;和&lt;code&gt;Dao&lt;/code&gt;。&lt;/big&gt;&lt;/p&gt;
&lt;h2 id=&quot;mybatis基础一&quot;&gt;Mybatis基础（一）&lt;/h2&gt;
&lt;hr/&gt;&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;h2 id=&quot;mybatis概述-1&quot;&gt;mybatis概述：&lt;/h2&gt;
&lt;p&gt;&lt;big&gt;MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。&lt;/big&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;h2 id=&quot;安装mybatis-1&quot;&gt;安装mybatis：&lt;/h2&gt;
&lt;p&gt;&lt;big&gt;1.方式一：直接将mybatis-x.x.x.jar文件放置在classpath中，一般情况不用这种。&lt;/big&gt;&lt;/p&gt;
&lt;p&gt;&lt;big&gt;2.方式二：使用 Maven 来创建项目，将下面的 dependency 代码置于 pom.xml 文件中，该方法电脑要连接网络下载配置所需的文件（有时候maven会有点慢，等一下）：&lt;/big&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

    &amp;lt;groupId&amp;gt;org.example&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;MybatisDemo_1&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;!-- 记得加下面这一行--&amp;gt;
    &amp;lt;packaging&amp;gt;jar&amp;lt;/packaging&amp;gt;

&amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;!-- 这个依赖是为了获取mybatis包--&amp;gt;
          &amp;lt;groupId&amp;gt;org.mybatis&amp;lt;/groupId&amp;gt;
          &amp;lt;artifactId&amp;gt;mybatis&amp;lt;/artifactId&amp;gt;
          &amp;lt;version&amp;gt;x.x.x&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;!-- 这个依赖是为了获取mysql数据库包--&amp;gt;
            &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;5.1.40&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
           &amp;lt;!-- 这个依赖是为了获取日志信息--&amp;gt;
            &amp;lt;groupId&amp;gt;log4j&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;log4j&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.2.12&amp;lt;/version&amp;gt;
     &amp;lt;/dependency&amp;gt;
    &amp;lt;!--一般必须配置的就是mybatis包，数据库包，其他项可以根据自己情况而配置 --&amp;gt;
&amp;lt;/dependencies&amp;gt;
&amp;lt;/project&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ &lt;big&gt;到这里maven的基本配置就结束了，接下来演示一个入门案例.&lt;/big&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;ul&gt;&lt;li&gt;
&lt;h2 id=&quot;前期准备创建数据库和数据表-1&quot;&gt;前期准备：创建数据库和数据表&lt;/h2&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;DROP TABLE IF EXISTS `user`;

CREATE TABLE `user` (
  `id` int(11) NOT NULL auto_increment,
  `username` varchar(32) NOT NULL COMMENT '用户名称',
  `birthday` datetime default NULL COMMENT '生日',
  `sex` char(1) default NULL COMMENT '性别',
     
  `address` varchar(256) default NULL COMMENT '地址',
  PRIMARY KEY  (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

insert  into user(`id`,`username`,`birthday`,`sex`,`address`) values 
(1,'小琼','2018-02-27 17:47:08','女','宣威'),
(2,'小琼琼','2018-03-02 15:09:37','女','南宁'),
(3,'大琼','2018-03-04 11:34:34','女','北海'),
(4,'琼琼','2018-03-04 12:04:06','女','云南'),
(5,'琼包','2018-03-07 17:37:26','男','广西'),
(6,'小杨','2018-03-08 11:44:00','女','贵州');
select * from USER;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;一.mybatis环境配置创建实体类和dao接口-1&quot;&gt;一.mybatis环境配置：创建实体类和Dao接口&lt;/h2&gt;
&lt;p&gt;&lt;big&gt;1.在&lt;code&gt;src/main/java&lt;/code&gt;下面创建一个三层级的目录结构：&lt;code&gt;com/Test/User&lt;/code&gt;和&lt;code&gt;com/Test/Dao&lt;/code&gt;,其中在&lt;code&gt;Test&lt;/code&gt;目录下面有两个文件夹&lt;code&gt;User&lt;/code&gt;和&lt;code&gt;Dao&lt;/code&gt;。&lt;/big&gt;&lt;/p&gt;
&lt;h2 id=&quot;mybatis基础一-1&quot;&gt;Mybatis基础（一）&lt;/h2&gt;
&lt;hr/&gt;&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;h2 id=&quot;mybatis概述-2&quot;&gt;mybatis概述：&lt;/h2&gt;
&lt;p&gt;&lt;big&gt;MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。&lt;/big&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;h2 id=&quot;安装mybatis-2&quot;&gt;安装mybatis：&lt;/h2&gt;
&lt;p&gt;&lt;big&gt;1.方式一：直接将mybatis-x.x.x.jar文件放置在classpath中，一般情况不用这种。&lt;/big&gt;&lt;/p&gt;
&lt;p&gt;&lt;big&gt;2.方式二：使用 Maven 来创建项目，将下面的 dependency 代码置于 pom.xml 文件中，该方法电脑要连接网络下载配置所需的文件（有时候maven会有点慢，等一下）：&lt;/big&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

    &amp;lt;groupId&amp;gt;org.example&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;MybatisDemo_1&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;!-- 记得加下面这一行--&amp;gt;
    &amp;lt;packaging&amp;gt;jar&amp;lt;/packaging&amp;gt;

&amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;!-- 这个依赖是为了获取mybatis包--&amp;gt;
          &amp;lt;groupId&amp;gt;org.mybatis&amp;lt;/groupId&amp;gt;
          &amp;lt;artifactId&amp;gt;mybatis&amp;lt;/artifactId&amp;gt;
          &amp;lt;version&amp;gt;x.x.x&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;!-- 这个依赖是为了获取mysql数据库包--&amp;gt;
            &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;5.1.40&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
           &amp;lt;!-- 这个依赖是为了获取日志信息--&amp;gt;
            &amp;lt;groupId&amp;gt;log4j&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;log4j&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.2.12&amp;lt;/version&amp;gt;
     &amp;lt;/dependency&amp;gt;
    &amp;lt;!--一般必须配置的就是mybatis包，数据库包，其他项可以根据自己情况而配置 --&amp;gt;
&amp;lt;/dependencies&amp;gt;
&amp;lt;/project&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ &lt;big&gt;到这里maven的基本配置就结束了，接下来演示一个入门案例.&lt;/big&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;ul&gt;&lt;li&gt;
&lt;h2 id=&quot;前期准备创建数据库和数据表-2&quot;&gt;前期准备：创建数据库和数据表&lt;/h2&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;DROP TABLE IF EXISTS `user`;

CREATE TABLE `user` (
  `id` int(11) NOT NULL auto_increment,
  `username` varchar(32) NOT NULL COMMENT '用户名称',
  `birthday` datetime default NULL COMMENT '生日',
  `sex` char(1) default NULL COMMENT '性别',
     
  `address` varchar(256) default NULL COMMENT '地址',
  PRIMARY KEY  (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

insert  into user(`id`,`username`,`birthday`,`sex`,`address`) values 
(1,'小琼','2018-02-27 17:47:08','女','宣威'),
(2,'小琼琼','2018-03-02 15:09:37','女','南宁'),
(3,'大琼','2018-03-04 11:34:34','女','北海'),
(4,'琼琼','2018-03-04 12:04:06','女','云南'),
(5,'琼包','2018-03-07 17:37:26','男','广西'),
(6,'小杨','2018-03-08 11:44:00','女','贵州');
select * from USER;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;一.mybatis环境配置创建实体类和dao接口-2&quot;&gt;一.mybatis环境配置：创建实体类和Dao接口&lt;/h2&gt;
&lt;p&gt;&lt;big&gt;1.在&lt;code&gt;src/main/java&lt;/code&gt;下面创建一个三层级的目录结构：&lt;code&gt;com/Test/User&lt;/code&gt;和&lt;code&gt;com/Test/Dao&lt;/code&gt;,其中在&lt;code&gt;Test&lt;/code&gt;目录下面有两个文件夹&lt;code&gt;User&lt;/code&gt;和&lt;code&gt;Dao&lt;/code&gt;。&lt;/big&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1661566/202002/1661566-20200201221619170-328966164.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;big&gt;2.&lt;code&gt;User.java&lt;/code&gt;中定义属性名和数据库中user表的字段名一致。&lt;/big&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.Test.User;

import java.io.Serializable;
import java.util.Date;

public class User implements Serializable {
    private Integer id;
    private String username;
    private Date birthday;
    private String sex;
    private String address;

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public Date getBirthday() {
        return birthday;
    }

    public void setBirthday(Date birthday) {
        this.birthday = birthday;
    }

    public String getSex() {
        return sex;
    }

    public void setSex(String sex) {
        this.sex = sex;
    }

    public String getAddress() {
        return address;
    }

    public void setAddress(String address) {
        this.address = address;
    }

    @Override
    public String toString() {
        return &quot;User[&quot; +
                &quot;id=&quot; + id +
                &quot;, username='&quot; + username + '\'' +
                &quot;, birthday=&quot; + birthday +
                &quot;, sex='&quot; + sex + '\'' +
                &quot;, address='&quot; + address + '\'' +
                ']';
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;big&gt;3.&lt;code&gt;UserDao.java&lt;/code&gt;中提供查询数据库表中所有数据的方法，UserDao.java是一个接口。&lt;/big&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.Test.Dao;

import com.Test.User.User;

import java.util.List;

/*
用户持久层接口
 */
public interface UserDao {
&amp;lt;!-- @Select(&quot;select * from user&quot;)如果这里使用注解来配置，那么SqlMapConfig.xml的mapper 就不一样 --&amp;gt;
    List&amp;lt;User&amp;gt; findAll();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;二.配置mybatis主文件-sqlmapconfig.xml&quot;&gt;二.配置mybatis主文件 : SqlMapConfig.xml&lt;/h2&gt;
&lt;p&gt;&lt;big&gt;&lt;code&gt;SqlMapConfig.xml&lt;/code&gt;文件一开始是没有的，需要自己建，而且需要建在&lt;code&gt;resources&lt;/code&gt;目录下：&lt;/big&gt;&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&amp;gt;
&amp;lt;configuration&amp;gt;
    &amp;lt;!--        配置环境 --&amp;gt;
    &amp;lt;environments default=&quot;mysql&quot;&amp;gt;
    &amp;lt;!--        配置mysql的环境   --&amp;gt;
        &amp;lt;environment id=&quot;mysql&quot;&amp;gt;
    &amp;lt;!--        配置事物类型--&amp;gt;
            &amp;lt;transactionManager type=&quot;JDBC&quot;&amp;gt;&amp;lt;/transactionManager&amp;gt;
    &amp;lt;!--        配置连接池（数据源）--&amp;gt;
            &amp;lt;dataSource type=&quot;POOLED&quot;&amp;gt;
    &amp;lt;!--        配置数据库的基本信息--&amp;gt;
                &amp;lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&amp;gt;
                &amp;lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/数据库名&quot;/&amp;gt;
                &amp;lt;property name=&quot;username&quot; value=&quot;数据库登录名&quot;/&amp;gt;
                &amp;lt;property name=&quot;password&quot; value=&quot;数据库登录密码&quot;/&amp;gt;
            &amp;lt;/dataSource&amp;gt;
        &amp;lt;/environment&amp;gt;
    &amp;lt;/environments&amp;gt;

    &amp;lt;mappers &amp;gt;
        &amp;lt;!--由于此处使用到了UserDao.xml文件，所以需要在resources目录下面创建 com/Test/Dao这样一个目录并且创建UserDao.xml文件，--&amp;gt;
        &amp;lt;mapper resource=&quot;com/Test/Dao/UserDao.xml&quot;&amp;gt;&amp;lt;/mapper&amp;gt;
        &amp;lt;!--&amp;lt;mapper class=&quot;com.Test.Dao.UserDao&quot;&amp;gt;&amp;lt;/mapper&amp;gt; 如果使用注解，那就这样设置--&amp;gt;
    &amp;lt;/mappers&amp;gt;
&amp;lt;/configuration&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;三.配置userdao.xml文件&quot;&gt;三.配置UserDao.xml文件&lt;/h2&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&amp;gt;
&amp;lt;!-- 这里的namespace必须写UserDao.xml对应文件UserDao的全路径--&amp;gt;
&amp;lt;mapper namespace=&quot;com.Test.Dao.UserDao&quot;&amp;gt;
    &amp;lt;select id=&quot;findAll&quot;&amp;gt;
    select * from user
    &amp;lt;/select&amp;gt;
&amp;lt;/mapper&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;big&gt;mybatis的配置基本就完成了，下一篇讲实际操作。&lt;/big&gt;&lt;/p&gt;
&lt;p&gt;&lt;big&gt;2.&lt;code&gt;User.java&lt;/code&gt;中定义属性名和数据库中user表的字段名一致。&lt;/big&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.Test.User;

import java.io.Serializable;
import java.util.Date;

public class User implements Serializable {
    private Integer id;
    private String username;
    private Date birthday;
    private String sex;
    private String address;

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public Date getBirthday() {
        return birthday;
    }

    public void setBirthday(Date birthday) {
        this.birthday = birthday;
    }

    public String getSex() {
        return sex;
    }

    public void setSex(String sex) {
        this.sex = sex;
    }

    public String getAddress() {
        return address;
    }

    public void setAddress(String address) {
        this.address = address;
    }

    @Override
    public String toString() {
        return &quot;User[&quot; +
                &quot;id=&quot; + id +
                &quot;, username='&quot; + username + '\'' +
                &quot;, birthday=&quot; + birthday +
                &quot;, sex='&quot; + sex + '\'' +
                &quot;, address='&quot; + address + '\'' +
                ']';
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;big&gt;3.&lt;code&gt;UserDao.java&lt;/code&gt;中提供查询数据库表中所有数据的方法，UserDao.java是一个接口。&lt;/big&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.Test.Dao;

import com.Test.User.User;

import java.util.List;

/*
用户持久层接口
 */
public interface UserDao {
&amp;lt;!-- @Select(&quot;select * from user&quot;)如果这里使用注解来配置，那么SqlMapConfig.xml的mapper 就不一样 --&amp;gt;
    List&amp;lt;User&amp;gt; findAll();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;二.配置mybatis主文件-sqlmapconfig.xml-1&quot;&gt;二.配置mybatis主文件 : SqlMapConfig.xml&lt;/h2&gt;
&lt;p&gt;&lt;big&gt;&lt;code&gt;SqlMapConfig.xml&lt;/code&gt;文件一开始是没有的，需要自己建，而且需要建在&lt;code&gt;resources&lt;/code&gt;目录下：&lt;/big&gt;&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&amp;gt;
&amp;lt;configuration&amp;gt;
    &amp;lt;!--        配置环境 --&amp;gt;
    &amp;lt;environments default=&quot;mysql&quot;&amp;gt;
    &amp;lt;!--        配置mysql的环境   --&amp;gt;
        &amp;lt;environment id=&quot;mysql&quot;&amp;gt;
    &amp;lt;!--        配置事物类型--&amp;gt;
            &amp;lt;transactionManager type=&quot;JDBC&quot;&amp;gt;&amp;lt;/transactionManager&amp;gt;
    &amp;lt;!--        配置连接池（数据源）--&amp;gt;
            &amp;lt;dataSource type=&quot;POOLED&quot;&amp;gt;
    &amp;lt;!--        配置数据库的基本信息--&amp;gt;
                &amp;lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&amp;gt;
                &amp;lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/数据库名&quot;/&amp;gt;
                &amp;lt;property name=&quot;username&quot; value=&quot;数据库登录名&quot;/&amp;gt;
                &amp;lt;property name=&quot;password&quot; value=&quot;数据库登录密码&quot;/&amp;gt;
            &amp;lt;/dataSource&amp;gt;
        &amp;lt;/environment&amp;gt;
    &amp;lt;/environments&amp;gt;

    &amp;lt;mappers &amp;gt;
        &amp;lt;!--由于此处使用到了UserDao.xml文件，所以需要在resources目录下面创建 com/Test/Dao这样一个目录并且创建UserDao.xml文件，--&amp;gt;
        &amp;lt;mapper resource=&quot;com/Test/Dao/UserDao.xml&quot;&amp;gt;&amp;lt;/mapper&amp;gt;
        &amp;lt;!--&amp;lt;mapper class=&quot;com.Test.Dao.UserDao&quot;&amp;gt;&amp;lt;/mapper&amp;gt; 如果使用注解，那就这样设置--&amp;gt;
    &amp;lt;/mappers&amp;gt;
&amp;lt;/configuration&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;三.配置userdao.xml文件-1&quot;&gt;三.配置UserDao.xml文件&lt;/h2&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&amp;gt;
&amp;lt;!-- 这里的namespace必须写UserDao.xml对应文件UserDao的全路径--&amp;gt;
&amp;lt;mapper namespace=&quot;com.Test.Dao.UserDao&quot;&amp;gt;
    &amp;lt;select id=&quot;findAll&quot;&amp;gt;
    select * from user
    &amp;lt;/select&amp;gt;
&amp;lt;/mapper&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;big&gt;mybatis的配置基本就完成了，下一篇讲实际操作。&lt;/big&gt;&lt;/p&gt;
&lt;p&gt;&lt;big&gt;2.&lt;code&gt;User.java&lt;/code&gt;中定义属性名和数据库中user表的字段名一致。&lt;/big&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.Test.User;

import java.io.Serializable;
import java.util.Date;

public class User implements Serializable {
    private Integer id;
    private String username;
    private Date birthday;
    private String sex;
    private String address;

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public Date getBirthday() {
        return birthday;
    }

    public void setBirthday(Date birthday) {
        this.birthday = birthday;
    }

    public String getSex() {
        return sex;
    }

    public void setSex(String sex) {
        this.sex = sex;
    }

    public String getAddress() {
        return address;
    }

    public void setAddress(String address) {
        this.address = address;
    }

    @Override
    public String toString() {
        return &quot;User[&quot; +
                &quot;id=&quot; + id +
                &quot;, username='&quot; + username + '\'' +
                &quot;, birthday=&quot; + birthday +
                &quot;, sex='&quot; + sex + '\'' +
                &quot;, address='&quot; + address + '\'' +
                ']';
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;big&gt;3.&lt;code&gt;UserDao.java&lt;/code&gt;中提供查询数据库表中所有数据的方法，UserDao.java是一个接口。&lt;/big&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.Test.Dao;

import com.Test.User.User;

import java.util.List;

/*
用户持久层接口
 */
public interface UserDao {
&amp;lt;!-- @Select(&quot;select * from user&quot;)如果这里使用注解来配置，那么SqlMapConfig.xml的mapper 就不一样 --&amp;gt;
    List&amp;lt;User&amp;gt; findAll();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;二.配置mybatis主文件-sqlmapconfig.xml-2&quot;&gt;二.配置mybatis主文件 : SqlMapConfig.xml&lt;/h2&gt;
&lt;p&gt;&lt;big&gt;&lt;code&gt;SqlMapConfig.xml&lt;/code&gt;文件一开始是没有的，需要自己建，而且需要建在&lt;code&gt;resources&lt;/code&gt;目录下：&lt;/big&gt;&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&amp;gt;
&amp;lt;configuration&amp;gt;
    &amp;lt;!--        配置环境 --&amp;gt;
    &amp;lt;environments default=&quot;mysql&quot;&amp;gt;
    &amp;lt;!--        配置mysql的环境   --&amp;gt;
        &amp;lt;environment id=&quot;mysql&quot;&amp;gt;
    &amp;lt;!--        配置事物类型--&amp;gt;
            &amp;lt;transactionManager type=&quot;JDBC&quot;&amp;gt;&amp;lt;/transactionManager&amp;gt;
    &amp;lt;!--        配置连接池（数据源）--&amp;gt;
            &amp;lt;dataSource type=&quot;POOLED&quot;&amp;gt;
    &amp;lt;!--        配置数据库的基本信息--&amp;gt;
                &amp;lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&amp;gt;
                &amp;lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/数据库名&quot;/&amp;gt;
                &amp;lt;property name=&quot;username&quot; value=&quot;数据库登录名&quot;/&amp;gt;
                &amp;lt;property name=&quot;password&quot; value=&quot;数据库登录密码&quot;/&amp;gt;
            &amp;lt;/dataSource&amp;gt;
        &amp;lt;/environment&amp;gt;
    &amp;lt;/environments&amp;gt;

    &amp;lt;mappers &amp;gt;
        &amp;lt;!--由于此处使用到了UserDao.xml文件，所以需要在resources目录下面创建 com/Test/Dao这样一个目录并且创建UserDao.xml文件，--&amp;gt;
        &amp;lt;mapper resource=&quot;com/Test/Dao/UserDao.xml&quot;&amp;gt;&amp;lt;/mapper&amp;gt;
        &amp;lt;!--&amp;lt;mapper class=&quot;com.Test.Dao.UserDao&quot;&amp;gt;&amp;lt;/mapper&amp;gt; 如果使用注解，那就这样设置--&amp;gt;
    &amp;lt;/mappers&amp;gt;
&amp;lt;/configuration&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;三.配置userdao.xml文件-2&quot;&gt;三.配置UserDao.xml文件&lt;/h2&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&amp;gt;
&amp;lt;!-- 这里的namespace必须写UserDao.xml对应文件UserDao的全路径--&amp;gt;
&amp;lt;mapper namespace=&quot;com.Test.Dao.UserDao&quot;&amp;gt;
    &amp;lt;select id=&quot;findAll&quot;&amp;gt;
    select * from user
    &amp;lt;/select&amp;gt;
&amp;lt;/mapper&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;big&gt;mybatis的配置基本就完成了，下一篇讲实际操作。&lt;/big&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 01 Feb 2020 14:19:00 +0000</pubDate>
<dc:creator>沐雨橙风~~</dc:creator>
<og:description>mybatis概述： MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/coding-996/p/12250469.html</dc:identifier>
</item>
<item>
<title>每天玩转3分钟 MyBatis-Plus - 6. select 用法 - 悟空聊架构</title>
<link>http://www.cnblogs.com/jackson0714/p/study-mybatis-plus6.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jackson0714/p/study-mybatis-plus6.html</guid>
<description>&lt;p&gt;&lt;a id=&quot;post_title_link_12207856&quot; href=&quot;https://www.cnblogs.com/jackson0714/p/study-mybatis-plus1.html&quot;&gt;每天玩转3分钟 MyBatis-Plus - 1. 配置环境&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;post_title_link_12213580&quot; href=&quot;https://www.cnblogs.com/jackson0714/p/study-mybatis-plus2.html&quot;&gt;每天玩转3分钟 MyBatis-Plus - 2. 普通查询&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;post_title_link_12213580&quot; href=&quot;https://www.cnblogs.com/jackson0714/p/study-mybatis-plus3.html&quot;&gt;每天玩转3分钟 MyBatis-Plus - 3. 高级查询（一）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;post_title_link_12213580&quot; href=&quot;https://www.cnblogs.com/jackson0714/p/study-mybatis-plus4.html&quot;&gt;每天玩转3分钟 MyBatis-Plus - 4. 高级查询（二）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;post_title_link_12213580&quot; href=&quot;https://www.cnblogs.com/jackson0714/p/study-mybatis-plus5.html&quot;&gt;每天玩转3分钟 MyBatis-Plus - 5. 高级查询（三）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;post_title_link_12213580&quot; href=&quot;https://www.cnblogs.com/jackson0714/p/study-mybatis-plus6.html&quot;&gt;每天玩转3分钟 MyBatis-Plus - 6. select 查询&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;代码下载：https://github.com/Jackson0714/study-mybatis-plus.git&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;note&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;mybatis-plus的查询功能非常强大， 上一篇，我们通过例题的方式讲解了mybatis-plus的高级查询功能：条件查询.&lt;/p&gt;
&lt;p&gt;这一篇我们继续以例题的方式讲解mybatis-plus的 &lt;span&gt;&lt;strong&gt;select&lt;/strong&gt;&lt;/span&gt; 查询功能。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;准备数据&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;75&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#创建用户表
&lt;/span&gt;&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; &lt;span&gt;user&lt;/span&gt;&lt;span&gt; (
    id &lt;/span&gt;&lt;span&gt;BIGINT&lt;/span&gt;(&lt;span&gt;20&lt;/span&gt;) &lt;span&gt;PRIMARY&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt; &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;主键&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    name &lt;/span&gt;&lt;span&gt;VARCHAR&lt;/span&gt;(&lt;span&gt;30&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;姓名&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    age &lt;/span&gt;&lt;span&gt;INT&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;年龄&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    email &lt;/span&gt;&lt;span&gt;VARCHAR&lt;/span&gt;(&lt;span&gt;50&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;邮箱&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    manager_id &lt;/span&gt;&lt;span&gt;BIGINT&lt;/span&gt;(&lt;span&gt;20&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;直属上级id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    create_time &lt;/span&gt;&lt;span&gt;DATETIME&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;创建时间&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;CONSTRAINT&lt;/span&gt; manager_fk &lt;span&gt;FOREIGN&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt;&lt;span&gt; (manager_id)
        &lt;/span&gt;&lt;span&gt;REFERENCES&lt;/span&gt; &lt;span&gt;user&lt;/span&gt;&lt;span&gt; (id)
)  ENGINE&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;INNODB CHARSET&lt;span&gt;=&lt;/span&gt;&lt;span&gt;UTF8;

#初始化数据：
&lt;/span&gt;&lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; &lt;span&gt;user&lt;/span&gt;&lt;span&gt; (id, name, age, email, manager_id
    , create_time)
&lt;/span&gt;&lt;span&gt;VALUES&lt;/span&gt; (&lt;span&gt;1087982257332887553&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;大boss&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;40&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;boss@baomidou.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;NULL&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2019-01-11 14:20:20&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),
    (&lt;/span&gt;&lt;span&gt;1088248166370832385&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;王天风&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;25&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;wtf@baomidou.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;1087982257332887553&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2019-02-05 11:12:22&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),
    (&lt;/span&gt;&lt;span&gt;1088250446457389058&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;李艺伟&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;28&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;lyw@baomidou.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;1088248166370832385&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2019-02-14 08:31:16&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),
    (&lt;/span&gt;&lt;span&gt;1094590409767661570&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;张雨琪&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;31&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;zjq@baomidou.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;1088248166370832385&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2019-01-14 09:15:15&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),
    (&lt;/span&gt;&lt;span&gt;1094592041087729666&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;刘红雨&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;32&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;lhm@baomidou.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;1088248166370832385&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2019-01-14 09:48:16&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;User&lt;/code&gt; 表结构如下：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;id&lt;/th&gt;
&lt;th&gt;name&lt;/th&gt;
&lt;th&gt;age&lt;/th&gt;
&lt;th&gt;email&lt;/th&gt;
&lt;th&gt;manager_id&lt;/th&gt;
&lt;th&gt;create_time&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;Jone&lt;/td&gt;
&lt;td&gt;18&lt;/td&gt;
&lt;td&gt;test1@baomidou.com&lt;/td&gt;
&lt;td&gt;null&lt;/td&gt;
&lt;td&gt;
&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;2020-01-01 14:20:20&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;Jack&lt;/td&gt;
&lt;td&gt;20&lt;/td&gt;
&lt;td&gt;test2@baomidou.com&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;
&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;2020-01-20 14:20:20&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;Tom&lt;/td&gt;
&lt;td&gt;28&lt;/td&gt;
&lt;td&gt;test3@baomidou.com&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;
&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;2020-01-15 14:20:20&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;Sandy&lt;/td&gt;
&lt;td&gt;21&lt;/td&gt;
&lt;td&gt;test4@baomidou.com&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;
&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;2020-01-12 14:20:20&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;Billie&lt;/td&gt;
&lt;td&gt;24&lt;/td&gt;
&lt;td&gt;test5@baomidou.com&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;
&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;2020-01-22 14:20:20&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;


&lt;h2&gt;1.1 查询年龄为20、21、25、26的用户，且只返回id和name字段&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;难度系数 ★&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;1.2 查询年龄为20、21、25、26的用户，且只返回id、name、manager_id字段&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;难度系数 ★★&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;1.1 查询年龄为20、21、25、26的用户，且只返回id和name字段&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;难度系数 ★&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;考察 select 用法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/414640/202002/414640-20200201221323114-1861299609.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * 描述：例1.9 查询年龄为20、21、25、26的用户，且只返回id和name字段
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt; * SQL语句：SELECT id,name FROM user WHERE age IN (20,21,25,26)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; * 作者：博客园-悟空聊架构
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt; * 时间：2019-02-01
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt; * Github：https://github.com/Jackson0714/study-mybatis-plus.git
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt; * 博客园：https://www.cnblogs.com/jackson0714
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;@Test&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; void testSelectByQueryWrapper9() {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     System.out.println((&quot;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--- 查询年龄为20、21、25、26的用户，且只返回id和name字段 ------&quot;));&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     QueryWrapper&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;User&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; queryWrapper &lt;span&gt;=&lt;/span&gt; new QueryWrapper&lt;span&gt;&amp;lt;&amp;gt;&lt;/span&gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     queryWrapper.&lt;span&gt;in&lt;/span&gt;(&quot;age&quot;, Arrays.asList(&lt;span&gt;20&lt;/span&gt;,&lt;span&gt;21&lt;/span&gt;,&lt;span&gt;25&lt;/span&gt;,&lt;span&gt;26&lt;/span&gt;)).&lt;span&gt;select&lt;/span&gt;(&quot;id&quot;,&quot;name&quot;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 针对字段少的情况
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     List&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;User&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; userList &lt;span&gt;=&lt;/span&gt;&lt;span&gt; userMapper.selectList(queryWrapper);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    userList.forEach(System.out::println);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查询日志：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/414640/202002/414640-20200201220340993-435509477.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;查询结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/414640/202002/414640-20200201220434666-740942978.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;1.2 查询年龄为20、21、25、26的用户，且只返回id、name、manager_id字段&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;难度系数 ★★&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;考察 select 用法&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * 描述：例1.10 查询年龄为20、21、25、26的用户，且只返回id、name、manager_id 字段
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt; * SQL语句：SELECT id,name,manager_id FROM user WHERE age IN (20,21,25,26)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; * 作者：博客园-悟空聊架构
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt; * 时间：2019-02-01
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt; * Github：https://github.com/Jackson0714/study-mybatis-plus.git
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt; * 博客园：https://www.cnblogs.com/jackson0714
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;@Test&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; void testSelectByQueryWrapper10() {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     System.out.println((&quot;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--- 查询年龄为20、21、25、26的用户，且只返回id、name、manager_id 字段 ------&quot;));&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     QueryWrapper&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;User&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; queryWrapper &lt;span&gt;=&lt;/span&gt; new QueryWrapper&lt;span&gt;&amp;lt;&amp;gt;&lt;/span&gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     queryWrapper.&lt;span&gt;in&lt;/span&gt;(&quot;age&quot;, Arrays.asList(&lt;span&gt;20&lt;/span&gt;,&lt;span&gt;21&lt;/span&gt;,&lt;span&gt;25&lt;/span&gt;,&lt;span&gt;26&lt;/span&gt;)) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 针对字段多的情况，用排除字段的方式
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             .&lt;span&gt;select&lt;/span&gt;(&lt;span&gt;User&lt;/span&gt;.class, info&lt;span&gt;-&amp;gt;&lt;/span&gt;&lt;span&gt;!info.getColumn()
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                     .equals((&quot;email&quot;)) &lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span&gt; !info.getColumn().equals(&quot;create_time&quot;));
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;     List&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;User&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; userList &lt;span&gt;=&lt;/span&gt;&lt;span&gt; userMapper.selectList(queryWrapper);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    userList.forEach(System.out::println);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 查询日志：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/414640/202002/414640-20200201221118864-1893822700.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 查询结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/414640/202002/414640-20200201221248333-81359525.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;a id=&quot;post_title_link_12207856&quot; href=&quot;https://www.cnblogs.com/jackson0714/p/study-mybatis-plus1.html&quot;&gt;每天玩转3分钟 MyBatis-Plus - 1. 配置环境&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;post_title_link_12213580&quot; href=&quot;https://www.cnblogs.com/jackson0714/p/study-mybatis-plus2.html&quot;&gt;每天玩转3分钟 MyBatis-Plus - 2. 普通查询&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;post_title_link_12213580&quot; href=&quot;https://www.cnblogs.com/jackson0714/p/study-mybatis-plus3.html&quot;&gt;每天玩转3分钟 MyBatis-Plus - 3. 高级查询（一）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;post_title_link_12213580&quot; href=&quot;https://www.cnblogs.com/jackson0714/p/study-mybatis-plus4.html&quot;&gt;每天玩转3分钟 MyBatis-Plus - 4. 高级查询（二）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;post_title_link_12213580&quot; href=&quot;https://www.cnblogs.com/jackson0714/p/study-mybatis-plus5.html&quot;&gt;每天玩转3分钟 MyBatis-Plus - 5. 高级查询（三）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;post_title_link_12213580&quot; href=&quot;https://www.cnblogs.com/jackson0714/p/study-mybatis-plus6.html&quot;&gt;每天玩转3分钟 MyBatis-Plus - 6. select 查询&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关注公众号：悟空聊架构，回复pmp，领取pmp资料！&lt;/strong&gt;回复悟空，领取架构师资料！&lt;/p&gt;
&lt;div id=&quot;MySignature&quot; readability=&quot;9.2889561270802&quot;&gt;
&lt;p&gt;&lt;br/&gt;作　　者：悟空聊架构 &lt;br/&gt;出　　处：&lt;a href=&quot;http://www.cnblogs.com/jackson0714/&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/jackson0714/&lt;/a&gt; &lt;br/&gt;关于作者：专注于移动开发。如有问题或建议，请多多赐教！ &lt;br/&gt;版权声明：本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接。 &lt;br/&gt;特此声明：所有评论和私信都会在第一时间回复。也欢迎园子的大大们指正错误，共同进步。或者&lt;a href=&quot;http://msg.cnblogs.com/msg/send/jackson0714&quot;&gt;直接私信&lt;/a&gt;我 &lt;br/&gt;声援博主：如果您觉得文章对您有帮助，可以点击文章右下角&lt;strong&gt;【推荐】&lt;/strong&gt;一下。您的鼓励是作者坚持原创和持续写作的最大动力！ &lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/414640/201905/414640-20190501174331917-43146210.png&quot; alt=&quot;&quot; width=&quot;243&quot; height=&quot;243&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;悟空聊架构 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;关注我，带你每天进步一点点！&lt;/p&gt;
</description>
<pubDate>Sat, 01 Feb 2020 14:15:00 +0000</pubDate>
<dc:creator>悟空聊架构</dc:creator>
<og:description>每天玩转3分钟 MyBatis-Plus - 1. 配置环境 每天玩转3分钟 MyBatis-Plus - 2. 普通查询 每天玩转3分钟 MyBatis-Plus - 3. 高级查询（一） 每天玩转</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jackson0714/p/study-mybatis-plus6.html</dc:identifier>
</item>
<item>
<title>开发工具篇：Git和Github - 咘雷扎克</title>
<link>http://www.cnblogs.com/ttzzyy/p/12250213.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ttzzyy/p/12250213.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Git是什么？&lt;/p&gt;
&lt;p&gt;Git是目前世界上最先进的分布式版本控制系统。工作原理 / 流程：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1235870/201902/1235870-20190214110547843-1965457539.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Workspace：工作区&lt;/li&gt;
&lt;li&gt;Index / Stage：暂存区&lt;/li&gt;
&lt;li&gt;Repository：仓库区（或本地仓库）&lt;/li&gt;
&lt;li&gt;Remote：远程仓库 (一般公司内网选择GitLab，外网可以选择GitHub或者码云)&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;p&gt;如果没有Git!&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;不能多人并行修改服务器的同一个文件。&lt;/li&gt;
&lt;li&gt;不能对文件的每一次提交的历史记录进行查阅，回退。&lt;/li&gt;
&lt;li&gt;不能对团队中的人进行权限控制&lt;/li&gt;
&lt;li&gt;不能使用分支去进行多线作战&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;blockquote readability=&quot;15&quot;&gt;
&lt;p&gt;SVN与Git的最主要的区别？&lt;/p&gt;
&lt;p&gt;SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而干活的时候，用的都是自己的电脑，所以首先要从中央服务器那里得到最新的版本，然后干活，干完后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，如果在局域网还可以，带宽够大，速度够快，如果在互联网下，如果网速慢的话，就纳闷了。最主要的问题是，如果服务器挂了，那么子节点上的内容只是当前状态，这种单点故障，想恢复以前的内容就很难了。&lt;/p&gt;
&lt;p&gt;Git是分布式版本控制系统，那么它就没有中央服务器的，每个人的电脑就是一个完整的版本库，这样，工作的时候就不需要联网了，因为版本都是在自己的电脑上。既然每个人的电脑都有一个完整的版本库，那多个人如何协作呢？比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。而且每个人的机器就是一整套版本库，可以直接去恢复服务器的故障。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;下载安装&quot;&gt;1 下载安装&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://git-scm.com/&quot; class=&quot;uri&quot;&gt;https://git-scm.com/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;window傻瓜安装&quot;&gt;1.1 window傻瓜安装&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;安装完成后可以在开始菜单或者鼠标右键中看见Git logo，点击Git Bash会出现命令窗口，则说明成功。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1235870/202001/1235870-20200105121938437-1095490670.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1235870/202001/1235870-20200105122154765-1133671186.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;linuxcentos傻瓜安装&quot;&gt;1.2 linux(Centos)傻瓜安装&lt;/h3&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;yum -y install curl-devel expat-devel gettext-devel openssl-devel zlib-devel
yum -y install git-core&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1235870/202001/1235870-20200105122820056-1953142392.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;基本使用篇&quot;&gt;2 基本使用篇&lt;/h2&gt;
&lt;h3 id=&quot;自报家门全局标识&quot;&gt;2.1 自报家门(全局标识)&lt;/h3&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;因为Git是分布式版本控制系统，所以需要填写用户名和邮箱作为一个标识。&lt;/p&gt;
&lt;p&gt;注意：git config --global 参数，有了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置。当然你也可以对某个仓库指定的不同的用户名和邮箱。(针对某个项目不带--global参数)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;git config --global user.name Heaton
git config --global user.email tzy70416450@163.com
#查询当前配置信息
git config --list
#通过文件查看全局配置信息
cat ~/.gitconfig&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1235870/202001/1235870-20200105175324349-1533235903.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;初始化版本库与局部标识&quot;&gt;2.2 初始化版本库与局部标识&lt;/h3&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;什么是版本库？版本库又名仓库，英文名repository，你可以简单的理解一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改，删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻还可以将文件”还原”。简单的理解，就是让我们的项目交给Git大管家来帮我们管理，需要让Git知道是哪个项目。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;创建一个版本库也非常简单，选择一个文件夹目录，例如：D:\testgit。&lt;/li&gt;
&lt;li&gt;通过命令 git init 把这个目录变成git可以管理的仓库。&lt;/li&gt;
&lt;li&gt;这时候你当前testgit目录下会多了一个.git的目录，这个目录是Git来跟踪管理版本的，没事千万不要手动乱改这个目录里面的文件，否则，会把git仓库给破坏了。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1235870/202001/1235870-20200105180532417-1058353604.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;而我们的标识信息就在config文件下。&lt;/p&gt;
&lt;p&gt;没有局部标识就会使用全局标识，一般情况下(推荐)，使用全局标识就好了。&lt;/p&gt;
&lt;p&gt;局部标识优先级大于全局标识。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;cat .git/config
git config user.name Heaton_1
git config user.email tzy70416450@163.com_1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1235870/202001/1235870-20200105181306718-1415822662.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;基础操作&quot;&gt;2.3 基础操作&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1235870/202001/1235870-20200105181754068-1099409728.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;工作区-暂存区-本地库基础操作&quot;&gt;2.3.1 工作区-&amp;gt;暂存区-&amp;gt;本地库基础操作&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1235870/202001/1235870-20200106215134980-2059031357.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1235870/202001/1235870-20200105183122066-1804426624.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1235870/202001/1235870-20200105184555843-1177913185.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1235870/202001/1235870-20200105185908859-1899722713.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1235870/202001/1235870-20200106212640733-967218190.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用git restore撤销工作区修改&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1235870/202001/1235870-20200106212856086-1370549435.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用git add然后使用git commit将文件添加到本地库&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1235870/202001/1235870-20200106213631897-704396227.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用git commit -a 将文件添加到本地库&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1235870/202001/1235870-20200106214118412-2122207572.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;日志分析&quot;&gt;2.3.2 日志分析&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1235870/202001/1235870-20200106220623878-800221038.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;版本跳跃&quot;&gt;2.3.3 版本跳跃&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1235870/202001/1235870-20200106221513409-1995774851.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用git reset --hard 版本号，跳跃到该版本&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1235870/202001/1235870-20200106222014879-1779628149.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用git reset --hard HEAD^ ，跳跃到之前的版本 (^一个就是一个版本，^^两个就是两个版本)&lt;/li&gt;
&lt;li&gt;使用git reset --hard HEAD~1 ，跳跃到之前的版本 (数字就是要回退的版本数)&lt;/li&gt;
&lt;li&gt;以上两个命令只能后退版本号&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1235870/202001/1235870-20200106222632142-1322468925.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;--soft --mixed -- hard 参数对比
&lt;ul&gt;&lt;li&gt;--soft (软回退)仅仅在本地库移动HEAD指针&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1235870/202001/1235870-20200106224321107-1084994626.png&quot;/&gt;&lt;/li&gt;
&lt;li&gt;--mixed (混合回退)在本地库移动HEAD指针，重置暂存区&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1235870/202001/1235870-20200106224805822-763474269.png&quot;/&gt;&lt;/li&gt;
&lt;li&gt;--hard (硬回退)在本地库移动HEAD指针，重置暂存区，重置工作区&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1235870/202001/1235870-20200106225154099-1549303044.png&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;删除文件找回&quot;&gt;2.3.4 删除文件找回&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1235870/202001/1235870-20200106230437929-412350775.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;比较文件改动&quot;&gt;2.3.5 比较文件改动&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1235870/202001/1235870-20200106231916505-1304934084.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;分支使用篇多人协作&quot;&gt;3 分支使用篇：多人协作&lt;/h2&gt;
&lt;h3 id=&quot;分支操作流程&quot;&gt;3.1 分支操作流程&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1235870/202002/1235870-20200201173807508-809096320.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;在实际开发中，我们常常会有很多开发分支，每个小伙伴在自己的开发分支上做完了事情，就会将代码提交到测试分支上面，由测试同学去测试，修改问题后会将代码合并到主分支上发布。&lt;/p&gt;
&lt;p&gt;当然有些公司还会有预发布分支，修改bug分支，原理是一样的，根据规范和喜好来咯。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;分支操作&quot;&gt;3.2 分支操作&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;查看分支：git branch -v&lt;/li&gt;
&lt;li&gt;创建分支：git branch [分支名]&lt;/li&gt;
&lt;li&gt;切换分支：git checkout [分支名]&lt;/li&gt;
&lt;li&gt;合并分支：git merge [分支名]&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;基础分支操作&quot;&gt;3.2.1基础分支操作&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1235870/202002/1235870-20200201174942682-467025021.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;没有冲突的合并操作&quot;&gt;3.2.2没有冲突的合并操作&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1235870/202002/1235870-20200201181247370-1110598688.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1235870/202002/1235870-20200201181431221-1016174715.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;有冲突的合并操作&quot;&gt;3.2.3有冲突的合并操作&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1235870/202002/1235870-20200201182310805-176958564.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1235870/202002/1235870-20200201182714308-1061371065.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;远程仓库操作&quot;&gt;4 远程仓库操作&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/&quot; class=&quot;uri&quot;&gt;https://github.com/&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;github是其中一种远程仓库，注册账号，创建仓库就可以使用了。&lt;/p&gt;
&lt;p&gt;还有码云，gitlab等等远程仓库产品。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1235870/202002/1235870-20200201185813238-1056193971.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;创建&quot;&gt;4.1 创建&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;c:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20200201190311591.png&quot; alt=&quot;image-20200201190311591&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1235870/202002/1235870-20200201190402508-297006674.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1235870/202002/1235870-20200201190742254-836011154.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1235870/202002/1235870-20200201192847352-1779088444.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;保存远程仓库地址&quot;&gt;4.2 保存远程仓库地址&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;git remote -v 查看远程仓库&lt;/li&gt;
&lt;li&gt;git remote add [远程仓库别名] [远程仓库地址]&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1235870/202002/1235870-20200201193151626-830594497.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;推送远程仓库&quot;&gt;4.3 推送远程仓库&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;git push [远程仓库地址] [分支名]&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1235870/202002/1235870-20200201193415690-350125704.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1235870/202002/1235870-20200201193534428-1720268041.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1235870/202002/1235870-20200201193722381-2052750464.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;克隆&quot;&gt;4.4克隆&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;git clone [远程仓库地址]&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1235870/202002/1235870-20200201193837352-92527364.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1235870/202002/1235870-20200201193955882-64305049.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;ssh免密操作&quot;&gt;4.5 ssh免密操作&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果有的话，直接跳过此如下命令，如果没有的话，打开命令行，&lt;br/&gt;输入如下命令(三次回车)：
&lt;ul&gt;&lt;li&gt;ssh-keygen&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1235870/202002/1235870-20200201194448531-1040953674.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;登录github,用户头像下打开” settings”中的SSH Keys页面，然后点击“Add SSH Key”,填上任意title，在Key文本框里黏贴id_rsa.pub文件的内容。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1235870/202002/1235870-20200201194607419-98679869.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1235870/202002/1235870-20200201194644318-827162590.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;邀请其他开发者&quot;&gt;4.6 邀请其他开发者&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1235870/202002/1235870-20200201195241735-811275332.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;拉取操作&quot;&gt;4.7 拉取操作&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;git fetch [远程库地址] [分支名]&lt;/li&gt;
&lt;li&gt;git merge [分支名]&lt;/li&gt;
&lt;li&gt;git pull --&amp;gt;(git fetch 和 git merge 两步操作)&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;用户1修改文件推送到远程库&quot;&gt;4.7.1 用户1修改文件推送到远程库&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1235870/202002/1235870-20200201200100964-341857138.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1235870/202002/1235870-20200201200126256-5753115.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1235870/202002/1235870-20200201200238545-3442100.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;用户2拉取远程库改动2步&quot;&gt;4.7.2 用户2拉取远程库改动(2步)&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1235870/202002/1235870-20200201200705030-1761570310.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;用户2拉取远程库改动1步&quot;&gt;4.7.3 用户2拉取远程库改动(1步)&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;重复4.7.1操作&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1235870/202002/1235870-20200201201133895-1073853650.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1235870/202002/1235870-20200201201213161-1393437944.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;多人协作冲突解决&quot;&gt;4.8 多人协作冲突解决&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;用户1改变文件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1235870/202002/1235870-20200201202744956-203331726.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1235870/202002/1235870-20200201202807198-1307472477.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;用户2改变文件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1235870/202002/1235870-20200201203021182-1408801291.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1235870/202002/1235870-20200201203157817-1829565210.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;修改冲突的文件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1235870/202002/1235870-20200201203357941-1680434251.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1235870/202002/1235870-20200201203522422-476205235.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;远程协作&quot;&gt;4.9 远程协作&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果未加入团队，不是开发者，想提交一些代码怎么办呢。github有远程协作功能。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;使用另一个账户，访问项目地址，Fork，克隆一个项目下来&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1235870/202002/1235870-20200201204458197-807908519.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1235870/202002/1235870-20200201204650774-1156493914.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1235870/202002/1235870-20200201204824146-1262142756.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;修改文件内容，提交远程仓库&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1235870/202002/1235870-20200201205116149-1497313132.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;pull request&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1235870/202002/1235870-20200201205313822-1577428018.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1235870/202002/1235870-20200201205407215-2056535454.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1235870/202002/1235870-20200201205624037-236421713.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;主账号登陆在pull request中就可以看见该次请求了，审核代码，发现主库被修改了。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1235870/202002/1235870-20200201205840462-831379720.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1235870/202002/1235870-20200201210002678-1683353929.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1235870/202002/1235870-20200201210126880-1752543312.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;idea中操作git&quot;&gt;5 idea中操作git&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;添加账号密码-&amp;gt;添加修改提交推送（所有的git操作都可以在idea中进行哦）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1235870/202002/1235870-20200201211507396-67018037.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1235870/202002/1235870-20200201213614381-44497687.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1235870/202002/1235870-20200201213856355-1462987890.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1235870/202002/1235870-20200201214114956-84065382.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1235870/202002/1235870-20200201212109426-1201543850.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;github插件&quot;&gt;6 github插件&lt;/h2&gt;
&lt;p&gt;chrome --&amp;gt; Octotree&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1235870/202002/1235870-20200201211307289-1090870642.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;idea --&amp;gt; ignore&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1235870/202002/1235870-20200201211345049-1976318607.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 01 Feb 2020 13:22:00 +0000</pubDate>
<dc:creator>咘雷扎克</dc:creator>
<og:description>开发工具篇：Git和Github Git是什么？ Git是目前世界上最先进的分布式版本控制系统。工作原理 / 流程： Workspace：工作区 Index / Stage：暂存区 Repositor</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ttzzyy/p/12250213.html</dc:identifier>
</item>
<item>
<title>Java程序员学习Go指南（二） - luozhiyun</title>
<link>http://www.cnblogs.com/luozhiyun/p/12249870.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/luozhiyun/p/12249870.html</guid>
<description>&lt;p&gt;摘抄：&lt;a href=&quot;https://www.luozhiyun.com/archives/211&quot; class=&quot;uri&quot;&gt;https://www.luozhiyun.com/archives/211&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;go中的结构体&quot;&gt;Go中的结构体&lt;/h2&gt;
&lt;h3 id=&quot;构建结构体&quot;&gt;构建结构体&lt;/h3&gt;
&lt;p&gt;如下：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;type AnimalCategory struct {
    kingdom string // 界。
    phylum  string // 门。
    class   string // 纲。
    order   string // 目。
    family  string // 科。
    genus   string // 属。
    species string // 种。
}

func (ac AnimalCategory) String() string {
    return fmt.Sprintf(&quot;%s%s%s%s%s%s%s&quot;,
        ac.kingdom, ac.phylum, ac.class, ac.order,
        ac.family, ac.genus, ac.species)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们在Go中一般构建一个结构体由上面代码块所示。AnimalCategory结构体中有7个string类型的字段，下边有个名叫String的方法，这个方法其实就是java类中的toString方法。其实这个结构体就是java中的类，结构体中有属性，有方法。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;category := AnimalCategory{species: &quot;cat&quot;} 
fmt.Printf(&quot;The animal category: %s\n&quot;, category)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们在上面的代码块中初始化了一个AnimalCategory类型的值，并把它赋给了变量category，通过调用fmt.Printf方法调用了category实例内的String方法，⽽⽆需 显式地调⽤它的String⽅法。&lt;/p&gt;
&lt;h3 id=&quot;在结构体中声明一个嵌入字段&quot;&gt;在结构体中声明一个嵌入字段&lt;/h3&gt;
&lt;p&gt;因为在Go中是没有继承一说，所以使用了嵌入字段的方式来实现类型之间的组合，实现了方法的重用。&lt;/p&gt;
&lt;p&gt;这里继续用到上面的结构体AnimalCategory&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;type Animal struct {
    scientificName string // 学名。
    AnimalCategory        // 动物基本分类。
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;字段声明AnimalCategory代表了Animal类型的⼀个嵌⼊字段。Go语⾔规范规定，如果⼀个字段 的声明中只有字段的类型名⽽没有字段的名称，那么它就是⼀个嵌⼊字段，也可以被称为匿名字段。嵌⼊字段的类型既是类型也是名称。&lt;/p&gt;
&lt;p&gt;如果要像java中引用字段里面的属性，那么可以这么写：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func (a Animal) String() string {
    return a.AnimalCategory.String()
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里还是和java是一样的，但是接下来要讲的却和java有很大区别&lt;/p&gt;
&lt;p&gt;由于我们在AnimalCategory中写了一个String的方法，如果我们没有给Animal写String的方法，那么我们直接打印会得到什么结果？&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;    category := AnimalCategory{species: &quot;cat&quot;}

    animal := Animal{
        scientificName: &quot;American Shorthair&quot;,
        AnimalCategory: category,
    }
    fmt.Printf(&quot;The animal: %s\n&quot;, animal)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这里fmt.Printf函数相当于调用animal的String⽅法。在java中只有父类才会做到方法的覆盖，但是在Go中，嵌⼊字段的⽅法集合会被⽆条件地合并进被嵌⼊类型的⽅法集合中。&lt;/p&gt;
&lt;p&gt;如果为Animal类型编写⼀个String⽅法，那么会将嵌⼊字段AnimalCategory的String⽅法被“屏蔽”了，从而调用Animal的String方法。&lt;/p&gt;
&lt;p&gt;只 要名称相同，⽆论这两个⽅法的签名是否⼀致，被嵌⼊类型的⽅法都会“屏蔽”掉嵌⼊字段的同名⽅法。也就是说不管返回值类型或者方法参数如何，只要名称相同就会屏蔽掉嵌⼊字段的同名⽅法。&lt;/p&gt;
&lt;h3 id=&quot;指针方法&quot;&gt;指针方法&lt;/h3&gt;
&lt;p&gt;上面我们的例子其实都是值方法，下面我们举一个指针方法的例子：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func main() {
    cat := New(&quot;little pig&quot;, &quot;American Shorthair&quot;, &quot;cat&quot;)
    cat.SetName(&quot;monster&quot;) // (&amp;amp;cat).SetName(&quot;monster&quot;)
    fmt.Printf(&quot;The cat: %s\n&quot;, cat)

    cat.SetNameOfCopy(&quot;little pig&quot;)
    fmt.Printf(&quot;The cat: %s\n&quot;, cat)

}
type Cat struct {
    name           string // 名字。
    scientificName string // 学名。
    category       string // 动物学基本分类。
}
//构造一个cat实例
func New(name, scientificName, category string) Cat {
    return Cat{
        name:           name,
        scientificName: scientificName,
        category:       category,
    }
}
//传指针设置cat名字
func (cat *Cat) SetName(name string) {
    cat.name = name
}
//传入值
func (cat Cat) SetNameOfCopy(name string) {
    cat.name = name
}
func (cat Cat) String() string {
    return fmt.Sprintf(&quot;%s (category: %s, name: %q)&quot;,
        cat.scientificName, cat.category, cat.name)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这个例子中，我们为Cat设置了两个方法，SetName是传指针的方法，SetNameOfCopy是传值的方法。&lt;/p&gt;
&lt;p&gt;⽅法SetName的接收者类型是&lt;em&gt;Cat。Cat左边再加个&lt;/em&gt;代表的就是Cat类型的指针类型。&lt;/p&gt;
&lt;p&gt;我们通过运行上面的例子可以得出，&lt;strong&gt;值⽅法&lt;/strong&gt;的接收者是该⽅法所属的那个&lt;strong&gt;类型值&lt;/strong&gt;的⼀个副本。⽽指针⽅法的接收者，是该⽅法所属的那个基本&lt;strong&gt;类型值的指针值&lt;/strong&gt;的⼀个副本。我们在这样的⽅法内对该副本指向的值进⾏ 修改，却⼀定会体现在原值上。&lt;/p&gt;
&lt;h2 id=&quot;接口类型&quot;&gt;接口类型&lt;/h2&gt;
&lt;h3 id=&quot;声明&quot;&gt;声明&lt;/h3&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;type Pet interface {
    SetName(name string)
    Name() string
    Category() string
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当数据类型中的方法实现了接口中的所有方法，那么该数据类型就是该接口的实现类型，如下：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;type Pet interface {
    Name() string
    Category() string
    SetName(name string)
}

type Dog struct {
    name string // 名字。
}

func (dog *Dog) SetName(name string) {
    dog.name = name
}

func (dog Dog) Name() string {
    return dog.name
}

func (dog Dog) Category() string {
    return &quot;dog&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这里Dog类型实现了Pet接口。&lt;/p&gt;
&lt;h3 id=&quot;接口变量赋值&quot;&gt;接口变量赋值&lt;/h3&gt;
&lt;p&gt;接口变量赋值也涉及了值传递和指针传递的概念。如下：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;    // 示例1
    dog := Dog{&quot;little pig&quot;}
    fmt.Printf(&quot;The dog's name is %q.\n&quot;, dog.Name())
    var pet Pet = dog
    dog.SetName(&quot;monster&quot;)
    fmt.Printf(&quot;The dog's name is %q.\n&quot;, dog.Name())
    fmt.Printf(&quot;This pet is a %s, the name is %q.\n&quot;,
        pet.Category(), pet.Name())
    fmt.Println()

    // 示例2。
    dog = Dog{&quot;little pig&quot;}
    fmt.Printf(&quot;The dog's name is %q.\n&quot;, dog.Name())
    pet = &amp;amp;dog
    dog.SetName(&quot;monster&quot;)
    fmt.Printf(&quot;The dog's name is %q.\n&quot;, dog.Name())
    fmt.Printf(&quot;This pet is a %s, the name is %q.\n&quot;,
        pet.Category(), pet.Name())&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;The dog's name is &quot;little pig&quot;.
The dog's name is &quot;monster&quot;.
This pet is a dog, the name is &quot;little pig&quot;.

The dog's name is &quot;little pig&quot;.
The dog's name is &quot;monster&quot;.
This pet is a dog, the name is &quot;monster&quot;.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在示例1中，赋给pet变量的实际上是dog的一个副本，所以当dog设置了name的时候pet的name并没发生改变。&lt;/p&gt;
&lt;p&gt;在实例2中，赋给pet变量的是一个指针的副本，所以pet和dog一样发生了编发。&lt;/p&gt;
&lt;h3 id=&quot;接口之间的组合&quot;&gt;接口之间的组合&lt;/h3&gt;
&lt;p&gt;可以通过接口间的嵌入实现接口的组合。接⼝类型间的嵌⼊不会涉及⽅法间的“屏蔽”。只要组合的接⼝之间有同名的⽅法就会产⽣冲突，从⽽⽆ 法通过编译，即使同名⽅法的签名彼此不同也会是如此。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;type Animal interface {
    // ScientificName 用于获取动物的学名。
    ScientificName() string
    // Category 用于获取动物的基本分类。
    Category() string
}

type Named interface {
    // Name 用于获取名字。
    Name() string
}

type Pet interface {
    Animal
    Named
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;指针&quot;&gt;指针&lt;/h2&gt;
&lt;h3 id=&quot;哪些值是不可寻址的&quot;&gt;哪些值是不可寻址的&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;不可变的变量&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如果一个变量是不可变的，那么基于它的索引或切⽚的结果值都是不可寻址的，因为即使拿到了这种值的内存地址也改变不了什么。&lt;br/&gt;如：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;    const num = 123
    //_ = &amp;amp;num // 常量不可寻址。
    //_ = &amp;amp;(123) // 基本类型值的字面量不可寻址。

    var str = &quot;abc&quot;
    _ = str
    //_ = &amp;amp;(str[0]) // 对字符串变量的索引结果值不可寻址。
    //_ = &amp;amp;(str[0:2]) // 对字符串变量的切片结果值不可寻址。
    str2 := str[0]
    _ = &amp;amp;str2 // 但这样的寻址就是合法的。&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;临时结果&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在我们把临时结果值赋给任何变量或常量之前，即使能拿到它的内存地址也是没有任何意义的。所以也是不可寻址的。&lt;/p&gt;
&lt;p&gt;我们可以把各种对值字⾯量施加的表达式的求值结果都看做是 临时结果。&lt;br/&gt;如：&lt;br/&gt;* ⽤于获得某个元素的索引表达式。&lt;br/&gt;* ⽤于获得某个切⽚（⽚段）的切⽚表达式。&lt;br/&gt;* ⽤于访问某个字段的选择表达式。&lt;br/&gt;* ⽤于调⽤某个函数或⽅法的调⽤表达式。&lt;br/&gt;* ⽤于转换值的类型的类型转换表达式。&lt;br/&gt;* ⽤于判断值的类型的类型断⾔表达式。&lt;br/&gt;* 向通道发送元素值或从通道那⾥接收元素值的接收表达式。&lt;/p&gt;
&lt;p&gt;⼀个需要特别注意的例外是，对切⽚字⾯量的索引结果值是可寻址的。因为不论怎样，每个切⽚值都会持有⼀个底层数组，⽽ 这个底层数组中的每个元素值都是有⼀个确切的内存地址的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//_ = &amp;amp;(123 + 456) // 算术操作的结果值不可寻址。
//_ = &amp;amp;([3]int{1, 2, 3}[0]) // 对数组字面量的索引结果值不可寻址。
//_ = &amp;amp;([3]int{1, 2, 3}[0:2]) // 对数组字面量的切片结果值不可寻址。
_ = &amp;amp;([]int{1, 2, 3}[0]) // 对切片字面量的索引结果值却是可寻址的。
//_ = &amp;amp;([]int{1, 2, 3}[0:2]) // 对切片字面量的切片结果值不可寻址。
//_ = &amp;amp;(map[int]string{1: &quot;a&quot;}[0]) // 对字典字面量的索引结果值不可寻址。&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;不安全&lt;br/&gt;函数在Go语⾔中是⼀等公⺠，所以我们可以把代表函数或⽅法的字⾯量或标识符赋给某个变量、传给某个函数或者从某个函数传出。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;但是，这样的函数和⽅法都是不可寻址的。⼀个原因是函数就是代码，是不可变的。另⼀个原因是，拿到指向⼀段代码的指针是不安全的。&lt;/p&gt;
&lt;p&gt;此外，对函数或⽅法的调⽤结果值也是不可寻址的，这是因为它们都属 于临时结果。&lt;/p&gt;
&lt;p&gt;如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    //_ = &amp;amp;(func(x, y int) int {
    //  return x + y
    //}) // 字面量代表的函数不可寻址。
    //_ = &amp;amp;(fmt.Sprintf) // 标识符代表的函数不可寻址。
    //_ = &amp;amp;(fmt.Sprintln(&quot;abc&quot;)) // 对函数的调用结果值不可寻址。&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;goroutine协程&quot;&gt;goroutine协程&lt;/h2&gt;
&lt;p&gt;在Go语言中，协程是由go函数进行触发的，当程序执⾏到⼀条go语句的时候，Go语⾔ 的运⾏时系统，会先试图从某个存放空闲的G的队列中获取⼀个G（也就是goroutine），它只有在找不到空闲G的情况下才会 去创建⼀个新的G。&lt;/p&gt;
&lt;p&gt;故已存在的goroutine总是会被优先复⽤。&lt;/p&gt;
&lt;p&gt;在拿到了⼀个空闲的G之后，Go语⾔运⾏时系统会⽤这个G去包装当前的那个go函数（或者说该函数中的那些代码），然后再 把这个G追加到某个存放可运⾏的G的队列中。&lt;/p&gt;
&lt;p&gt;在Go语⾔并不会去保证这些goroutine会以怎样的顺序运⾏。所以哪个goroutine先执⾏完、哪个goroutine后执⾏完往往是不可预知的，除⾮我们使⽤了某种Go语⾔提供的⽅式进⾏了⼈为 ⼲预。&lt;/p&gt;
&lt;p&gt;所以，怎样让我们启⽤的多个goroutine按照既定的顺序运⾏？&lt;/p&gt;
&lt;h3 id=&quot;多个goroutine按照既定的顺序运&quot;&gt;多个goroutine按照既定的顺序运⾏&lt;/h3&gt;
&lt;p&gt;下面我们先看个例子：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func main() {
    for i := 0; i &amp;lt; 10; i++ {
        go func() {
            fmt.Println(i)
        }()
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在下面的代码中，由于Go语言并不会按顺序去执行调度，所以没法知道fmt.Println(i)会在什么时候被打印，也不知道fmt.Println(i)打印的时候i是多少，也有可能main方法执行完了，但是没有一条输出。&lt;/p&gt;
&lt;p&gt;所以我们需要进行如下改造：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func main() {
    var count uint32
    trigger := func(i uint32, fn func()) {
        for {
            if n := atomic.LoadUint32(&amp;amp;count); n == i {
                fn()
                atomic.AddUint32(&amp;amp;count, 1)
                break
            }
            time.Sleep(time.Nanosecond)
        }
    }
    for i := uint32(0); i &amp;lt; 10; i++ {
        go func(i uint32) {
            fn := func() {
                fmt.Println(i)
            }
            trigger(i, fn)
        }(i)
    }
    trigger(10, func() {})
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们在for循环中声明了一个fn函数，fn函数里面只是简单的执行打印i的值，然后传入到trigger中。&lt;/p&gt;
&lt;p&gt;trigger函数会不断地获取⼀个名叫count的变量的值，并判断该值是否与参数i的值相同。如果相同，那么就⽴即调⽤fn代 表的函数，然后把count变量的值加1，最后显式地退出当前的循环。否则，我们就先让当前的goroutine“睡眠”⼀个纳秒再进 ⼊下⼀个迭代。&lt;/p&gt;
&lt;p&gt;因为会有多个线程操作trigger函数，所以使用的count变量是通过原子操作来进行获取值和加一操作。&lt;/p&gt;
&lt;p&gt;所以过函数实际执行顺序会根据count的值依次执行，这里实现了一种自旋，未满足条件的时候会不断地进行检查。&lt;/p&gt;
&lt;p&gt;最后防止主协程在其他协程没有运行完的时候就关闭，加上一个&lt;code&gt;trigger(10, func() {})&lt;/code&gt;代码。&lt;/p&gt;
</description>
<pubDate>Sat, 01 Feb 2020 11:59:00 +0000</pubDate>
<dc:creator>luozhiyun</dc:creator>
<og:description>摘抄：https://www.luozhiyun.com/archives/211 Go中的结构体 构建结构体 如下： 我们在Go中一般构建一个结构体由上面代码块所示。AnimalCategory结构</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/luozhiyun/p/12249870.html</dc:identifier>
</item>
<item>
<title>Vue+elementUI 自定义动态数据菜单导航组件实现展开收缩+路由跳转router-view渲染数据 路由跳转到同一个页面带参数ID 自动刷新数据 - 丢你个滑稽</title>
<link>http://www.cnblogs.com/dnghj/p/12249696.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dnghj/p/12249696.html</guid>
<description>&lt;p&gt;准备:导入ElementUI 看官网教程&lt;/p&gt;
&lt;p&gt;数据准备:JSON数据转换成树状&lt;/p&gt;
&lt;p&gt;参考文章: JS实现 JSON扁平数据转换树状数据&lt;/p&gt;
&lt;p&gt;后台我拿的数据是这样的格式:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[
{id:1 , parentId: 0, name: '', level: 0},
{id:2 , parentId: 0, name: '', level: 0},
{id:3 , parentId: 2, name: '', level: 1},
{id:4 , parentId: 2, name: '', level: 1},
{id:5 , parentId: 4, name: '', level: 2},
]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt; 转换后的数据差不多就是这样的格式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    [
        {
            id: 1,
            name: ''
        },
        {
            id: 2,
            name: '',
            children: [
                {
                    id: 3
                },
                {
                    id: 4,
                    children: [
                        {
                            id: 5
                        }
                    ]
                }
            ]
        },
    ]
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;自定义组件 路径 componebts/NavMenu.vue&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;fragment &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;navMenu&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;template &lt;/span&gt;&lt;span&gt;v-for&lt;/span&gt;&lt;span&gt;=&quot;navMenu in navMenus&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 最后一级菜单 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;el-menu-item &lt;/span&gt;&lt;span&gt;v-if&lt;/span&gt;&lt;span&gt;=&quot;!navMenu.children&quot;&lt;/span&gt;&lt;span&gt; :key&lt;/span&gt;&lt;span&gt;=&quot;navMenu.menuId&quot;&lt;/span&gt;&lt;span&gt; :data&lt;/span&gt;&lt;span&gt;=&quot;navMenu&quot;&lt;/span&gt;&lt;span&gt; :index&lt;/span&gt;&lt;span&gt;=&quot;&lt;span&gt;navMenu.menuUrl+'/'+navMenu.&lt;span&gt;menuId&lt;/span&gt;&lt;/span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;//带参数ID&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;i &lt;/span&gt;&lt;span&gt;:class&lt;/span&gt;&lt;span&gt;=&quot;navMenu.menuIcon&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;i&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;slot&lt;/span&gt;&lt;span&gt;=&quot;title&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt;{{navMenu.menuName}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;el-menu-item&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 此菜单下还有子菜单 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;el-submenu &lt;/span&gt;&lt;span&gt;v-if&lt;/span&gt;&lt;span&gt;=&quot;navMenu.children&quot;&lt;/span&gt;&lt;span&gt;
                  :key&lt;/span&gt;&lt;span&gt;=&quot;navMenu.menuId&quot;&lt;/span&gt;&lt;span&gt; :data&lt;/span&gt;&lt;span&gt;=&quot;navMenu&quot;&lt;/span&gt;&lt;span&gt; :index&lt;/span&gt;&lt;span&gt;=&quot;&lt;span&gt;navMenu.&lt;span&gt;menuId&lt;/span&gt;&lt;/span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;//&lt;span&gt;&lt;span&gt;navMenu.&lt;span&gt;menuId&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;解决跳转相同路由页面 展开菜单问题&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;template &lt;/span&gt;&lt;span&gt;slot&lt;/span&gt;&lt;span&gt;=&quot;title&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;i &lt;/span&gt;&lt;span&gt;:class&lt;/span&gt;&lt;span&gt;=&quot;navMenu.menuIcon&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;i&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;slot&lt;/span&gt;&lt;span&gt;=&quot;title&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; {{navMenu.menuName}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 递归 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;NavMenu &lt;/span&gt;&lt;span&gt;:navMenus&lt;/span&gt;&lt;span&gt;=&quot;navMenu.children&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;NavMenu&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;el-submenu&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;fragment&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {
    name: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;NavMenu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    props: [&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;navMenus&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;],
    data() {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {}
    },
    methods: {}
  }
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;自定义组件包含在 fragment 不是div 不然展开和缩人会出现显示问题&lt;br/&gt;如下:&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;span&gt;出现这个问题是因为我们在&amp;lt;el-menu&amp;gt;嵌套中出现了意料之外的&amp;lt;div&amp;gt;,而&amp;lt;el-menu&amp;gt;标签本身希望里面嵌套的是&amp;lt;el-menu-item&amp;gt;,&amp;lt;el-submenu&amp;gt;,&amp;lt;el-menu-item-group&amp;gt;其中之一&lt;br/&gt;但是我们又不能直接删掉&amp;lt;div&amp;gt;,因为&amp;lt;template&amp;gt;中包含的必须是一个根标签，而v-for会形成不确定的并列标签&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre readability=&quot;7&quot;&gt;
&lt;br/&gt;项目安装vue-fragment&lt;br/&gt;cnpm install --save vue-fragment&lt;p&gt;在main.js中引入&lt;br/&gt;// main.js&lt;br/&gt;import Fragment from 'vue-fragment'&lt;br/&gt;Vue.use(Fragment.Plugin)&lt;/p&gt;&lt;p&gt;&amp;lt;div&amp;gt;修改为&amp;lt;fragment&amp;gt;即可&lt;span&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1846087/202002/1846087-20200201185950012-700857138.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;:index&lt;span&gt;=&quot;&lt;span&gt;&quot;  指的是路由跳转的地址&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;路径 在你需要的页面引入组件  嵌套在div里面可以避免不必要的错误&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;     
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;el-menu  &lt;/span&gt;&lt;span&gt;default-active&lt;/span&gt;&lt;span&gt;=&quot;this.$router.path&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;el-menu-vertical-demo&quot;&lt;/span&gt;&lt;span&gt; @open&lt;/span&gt;&lt;span&gt;=&quot;handleOpen&quot;&lt;/span&gt;&lt;span&gt; @close&lt;/span&gt;&lt;span&gt;=&quot;handleClose&quot;&lt;/span&gt;&lt;span&gt; :collapse&lt;/span&gt;&lt;span&gt;=&quot;isCollapse&quot;&lt;/span&gt;&lt;span&gt;
                  mode&lt;/span&gt;&lt;span&gt;=&quot;vertical&quot;&lt;/span&gt;&lt;span&gt;
                  background-color&lt;/span&gt;&lt;span&gt;=&quot;#2c2e2f&quot;&lt;/span&gt;&lt;span&gt;
                  text-color&lt;/span&gt;&lt;span&gt;=&quot;#bfcbd9&quot;&lt;/span&gt;&lt;span&gt;
                  active-text-color&lt;/span&gt;&lt;span&gt;=&quot;#85c1e7&quot;&lt;/span&gt;&lt;span&gt;
                  :default-active&lt;/span&gt;&lt;span&gt;=&quot;activeIndex&quot;&lt;/span&gt;&lt;span&gt;
                  router&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;NavMenu &lt;/span&gt;&lt;span&gt;:navMenus&lt;/span&gt;&lt;span&gt;=&quot;sret&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;NavMenu&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;el-menu&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;router-view &lt;span&gt;:key&lt;span&gt;=&quot;&lt;span&gt;$route&lt;span&gt;.&lt;span&gt;path&lt;span&gt; + &lt;span&gt;$route&lt;span&gt;.&lt;span&gt;query&lt;span&gt;.&lt;span&gt;t&lt;span&gt;&quot;&lt;span&gt;&amp;gt;&amp;lt;/router-view&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;:key&lt;span&gt;=&quot;&lt;span&gt;$route&lt;span&gt;.&lt;span&gt;path&lt;span&gt; + &lt;span&gt;$route&lt;span&gt;.&lt;span&gt;query&lt;span&gt;.&lt;span&gt;t&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; //解决跳转到相同路由页面 数据不刷新问题&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/ecmascript-6&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  import NavMenu from &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;@/components/NavMenu&lt;/span&gt;&lt;span&gt;&quot; //组件位置&lt;/span&gt;&lt;span&gt;
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {
  components: { //定义组件
    NavMenu,
  },
  name: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;login&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  data() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {}
　　}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre readability=&quot;9&quot;&gt;
&lt;span&gt;:navMenus&lt;span&gt;=&quot;sret&quot;&lt;/span&gt;&lt;/span&gt; 这里的sret是后台拿过来的JSON树状数据 数据要转换成树状的 不然不行  吧转换后的数据赋值sret&lt;p&gt;让路由在&lt;span&gt;&amp;lt;&lt;span&gt;router-view&lt;span&gt;&amp;gt;&amp;lt;/&lt;span&gt;router-view&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;打开&lt;/p&gt;&lt;p&gt;定义路由和跳转的页面&lt;/p&gt;&lt;p&gt;路径 router/index.js 里面&lt;/p&gt;&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
需要几个页面就按这样的跳转 都要引入&lt;br/&gt;import Ibookmark from '@/views/bookmark';&lt;br/&gt;..........&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;// 启用路由&lt;br/&gt;Vue.&lt;span&gt;use(Router)&lt;span&gt;;&lt;br/&gt;&lt;span&gt;&lt;br/&gt;&lt;span&gt;// 导出路由 &lt;br/&gt;&lt;span&gt;export default new Router({&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;routes: [{&lt;br/&gt;&lt;span&gt;path: &lt;span&gt;'/login'&lt;span&gt;,&lt;br/&gt;&lt;span&gt;  &lt;span&gt;name: &lt;span&gt;''&lt;span&gt;,&lt;br/&gt;&lt;span&gt;  &lt;span&gt;component: login&lt;span&gt;,&lt;br/&gt;&lt;span&gt;  &lt;span&gt;&lt;span&gt;children&lt;/span&gt;: [ &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
　　　　{&lt;br/&gt;&lt;span&gt;path: &lt;span&gt;'/bookmark/:menuId'&lt;span&gt;,&lt;br/&gt;&lt;span&gt;  &lt;span&gt;component: resolve =&amp;gt; require([&lt;span&gt;'../views/bookmark.vue']&lt;span&gt;, resolve)&lt;span&gt;,&lt;br/&gt;&lt;span&gt;  &lt;span&gt;query:{&lt;br/&gt;&lt;span&gt;t:Date.&lt;span&gt;now()&lt;span&gt;, //解决跳转到相同路由页面 数据不刷新问题&lt;br/&gt;&lt;span&gt;  }&lt;span&gt;,&lt;br/&gt;&lt;span&gt; &lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;}&lt;span&gt;,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;]&lt;span&gt;,&lt;br/&gt;}&lt;span&gt;,........省略&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;父子路由 是层级关系 &lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;children: [&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;]&lt;/p&gt;






&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1846087/202002/1846087-20200201191824841-52434601.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;pre readability=&quot;7&quot;&gt;
&lt;span&gt;:index&lt;span&gt;=&quot;&lt;span&gt;navMenu.menuUrl+'/'+navMenu.&lt;span&gt;menuId&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;p&gt;注意看 路径 我这里传了ID参数 是为了在路由里面显示不同的数据&lt;/p&gt;&lt;p&gt;然后在路由的页面 获取点击的菜单id 渲染不同的数据
&lt;/p&gt;&lt;/pre&gt;
&lt;pre&gt;
&lt;span readability=&quot;0&quot;&gt;&lt;a class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/happybread/p/10156869.html&quot; readability=&quot;27&quot;&gt;this.$route.params this.$route.query 多种取值的方式我都试了 没成功在页面取出id&lt;p&gt;然后我用的是URL的截取/后面的ID方法&lt;/p&gt;&lt;/a&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;aaa() {&lt;br/&gt;&lt;span&gt;var _this=&lt;span&gt;this&lt;br/&gt;&lt;span&gt;  var url = window.&lt;span&gt;location.&lt;span&gt;href&lt;span&gt;;&lt;br/&gt;&lt;span&gt;  var index = url.&lt;span&gt;lastIndexOf(&lt;span&gt;&quot;&lt;span&gt;\/&lt;span&gt;&quot;)&lt;span&gt;;&lt;br/&gt;&lt;span&gt;  _this.&lt;span&gt;menuId = url.&lt;span&gt;substring(index + &lt;span&gt;1&lt;span&gt;,url.&lt;span&gt;length)&lt;span readability=&quot;3&quot;&gt;;&lt;br/&gt;}&lt;span readability=&quot;6&quot;&gt;,&lt;p&gt;获取到最后一个斜杠后面的数据 赋值给&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;menuId &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;实现 菜单跳转到相同的路由 根据ID渲染不同的数据 如果不设置&lt;span&gt;&lt;span&gt;:key&lt;span&gt;=&quot;&lt;span&gt;$route&lt;span&gt;.&lt;span&gt;path&lt;span&gt; + &lt;span&gt;$route&lt;span&gt;.&lt;span&gt;query&lt;span&gt;.&lt;span&gt;t&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 会出现数据ID不刷新问题 &lt;br/&gt;设置后 每次跳转 都会出现读取id 然后操作ID操作数据&lt;br/&gt;&lt;/p&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/happybread/p/10156869.html&quot;/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;/pre&gt;

</description>
<pubDate>Sat, 01 Feb 2020 11:55:00 +0000</pubDate>
<dc:creator>丢你个滑稽</dc:creator>
<og:description>准备:导入ElementUI 看官网教程 数据准备:JSON数据转换成树状 参考文章: JS实现 JSON扁平数据转换树状数据 后台我拿的数据是这样的格式: [ {id:1 , parentId: 0</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/dnghj/p/12249696.html</dc:identifier>
</item>
<item>
<title>Canny边缘检测算法（基于OpenCV的Java实现） - gyro永不抽风</title>
<link>http://www.cnblogs.com/jeffersonqin/p/12249753.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jeffersonqin/p/12249753.html</guid>
<description>&lt;h2 id=&quot;绪论&quot;&gt;绪论&lt;/h2&gt;
&lt;p&gt;最近在学习ORB的过程中又仔细学习了Canny，故写下此篇笔记，以作总结。&lt;/p&gt;
&lt;h2 id=&quot;canny边缘检测算法的发展历史&quot;&gt;Canny边缘检测算法的发展历史&lt;/h2&gt;
&lt;p&gt;Canny边缘检测于1986年由JOHN CANNY首次在论文《A Computational Approach to Edge Detection》中提出，就此拉开了Canny边缘检测算法的序幕。&lt;/p&gt;
&lt;p&gt;Canny边缘检测是从不同视觉对象中提取有用的结构信息并大大减少要处理的数据量的一种技术，目前已广泛应用于各种计算机视觉系统。Canny发现，在不同视觉系统上对边缘检测的要求较为类似，因此，可以实现一种具有广泛应用意义的边缘检测技术。边缘检测的一般标准包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;以低的错误率检测边缘，也即意味着需要尽可能准确的捕获图像中尽可能多的边缘。&lt;/li&gt;
&lt;li&gt;检测到的边缘应精确定位在真实边缘的中心。&lt;/li&gt;
&lt;li&gt;图像中给定的边缘应只被标记一次，并且在可能的情况下，图像的噪声不应产生假的边缘。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;为了满足这些要求，Canny使用了变分法。Canny检测器中的最优函数使用四个指数项的和来描述，它可以由高斯函数的一阶导数来近似。&lt;/p&gt;
&lt;p&gt;在目前常用的边缘检测方法中，Canny边缘检测算法是具有严格定义的，可以提供良好可靠检测的方法之一。由于它具有满足边缘检测的三个标准和实现过程简单的优势，成为边缘检测最流行的算法之一。&lt;/p&gt;
&lt;h2 id=&quot;canny边缘检测算法的处理流程&quot;&gt;Canny边缘检测算法的处理流程&lt;/h2&gt;
&lt;p&gt;Canny边缘检测算法可以分为以下5个步骤：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用高斯滤波器，以平滑图像，滤除噪声。&lt;/li&gt;
&lt;li&gt;计算图像中每个像素点的梯度强度和方向。&lt;/li&gt;
&lt;li&gt;应用非极大值（Non-Maximum Suppression）抑制，以消除边缘检测带来的杂散响应。&lt;/li&gt;
&lt;li&gt;应用双阈值（Double-Threshold）检测来确定真实的和潜在的边缘。&lt;/li&gt;
&lt;li&gt;通过抑制孤立的弱边缘最终完成边缘检测。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面详细介绍每一步的实现思路。&lt;/p&gt;
&lt;h2 id=&quot;用高斯滤波器平滑图像&quot;&gt;用高斯滤波器平滑图像&lt;/h2&gt;
&lt;p&gt;高斯滤波是一种线性平滑滤波，适用于消除高斯噪声，特别是对抑制或消除服从正态分布的噪声非常有效。滤波可以消除或降低图像中噪声的影响，使用高斯滤波器主要是基于在滤波降噪的同时也可以最大限度保留边缘信息的考虑。&lt;/p&gt;
&lt;p&gt;高斯滤波实现步骤：&lt;/p&gt;
&lt;h3 id=&quot;彩色rgb图像转换为灰度图像&quot;&gt;彩色RGB图像转换为灰度图像&lt;/h3&gt;
&lt;p&gt;边缘检测是基于对图像灰度差异运算实现的，所以如果输入的是RGB彩色图像，需要先进行灰度图的转换。&lt;br/&gt;RGB转换成灰度图像的一个常用公式是：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ Gray = R*0.299 + G*0.587 + B*0.114 \]&lt;/span&gt;&lt;br/&gt;注意一般情况下图像处理中彩色图像各分量的排列顺序是B、G、R。&lt;/p&gt;
&lt;p&gt;RGB原图像： 转换后的灰度图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1698645/202002/1698645-20200201181450188-231437906.jpg&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1698645/202002/1698645-20200201181515837-28049615.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Java&lt;/code&gt;代码调用系统库实现：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static Mat RGB2Gray(Mat image) {
    // Gray = R*0.299 + G*0.587 + B*0.114
    Mat gray = new Mat();
    Imgproc.cvtColor(image, gray, Imgproc.COLOR_BGR2GRAY);
    return gray;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;一维二维高斯函数及分布&quot;&gt;一维，二维高斯函数及分布&lt;/h3&gt;
&lt;p&gt;一维高斯函数表述为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ G(x) = \frac {1}{\sqrt {2\pi}\sigma}\exp(-\frac {(x-\mu_x)^2}{2\sigma^2}) \]&lt;/span&gt;&lt;br/&gt;对应图形：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1698645/202002/1698645-20200201181553029-1524087580.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;二维高斯函数表述为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ G(x) = \frac {1}{ {2\pi}\sigma^2}\exp(-\frac {(x-\mu_x)^2+(y-\mu_y)^2}{2\sigma^2}) \]&lt;/span&gt;&lt;br/&gt;对应图形：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1698645/202002/1698645-20200201181612009-81310929.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一些重要特性说明：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;一维二维高斯函数中&lt;span class=&quot;math inline&quot;&gt;\(μ\)&lt;/span&gt;是服从正态分布的随机变量的均值，称为期望或均值影响正态分布的位置，实际的图像处理应用中一般取&lt;span class=&quot;math inline&quot;&gt;\(μ=0;~σ\)&lt;/span&gt;是标准差，&lt;span class=&quot;math inline&quot;&gt;\(σ^2\)&lt;/span&gt;是随机变量的方差，&lt;span class=&quot;math inline&quot;&gt;\(σ\)&lt;/span&gt;定义了正态分布数据的离散程度，&lt;span class=&quot;math inline&quot;&gt;\(σ\)&lt;/span&gt;越大，数据分布越分散，σ越小，数据分布越集中。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在图形或滤波效果上表现为：&lt;span class=&quot;math inline&quot;&gt;\(σ\)&lt;/span&gt;越大，曲线越扁平，高斯滤波器的频带就越宽，平滑程度就越好，&lt;span class=&quot;math inline&quot;&gt;\(σ\)&lt;/span&gt;越小，曲线越瘦高，高斯滤波的频带就越窄，平滑程度也越弱；&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;二维高斯函数具有旋转对称性，即滤波器在各个方向上的平滑程度是相同的．一般来说，一幅图像的边缘方向是事先不知道的，因此，在滤波前是无法确定一个方向上比另一方向上需要更多的平滑．旋转对称性意味着高斯平滑滤波器在后续边缘检测中不会偏向任一方向；&lt;/li&gt;
&lt;li&gt;高斯函数是单值函数。这表明，高斯滤波器用像素邻域的加权均值来代替该点的像素值，而每一邻域像素点权值是随该点与中心点的距离单调增减的。这一性质是很重要的，因为边缘是一种图像局部特征，如果平滑运算对离算子中心很远的像素点仍然有很大作用，则平滑运算会使图像失真；&lt;/li&gt;
&lt;li&gt;相同条件下，高斯卷积核的尺寸越大，图像的平滑效果越好，表现为图像越模糊，同时图像细节丢失的越多；尺寸越小，平滑效果越弱，图像细节丢失越少；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;以下对比一下不同大小标准差&lt;span class=&quot;math inline&quot;&gt;\(σ\)&lt;/span&gt;（Sigma）对图像平滑的影响：&lt;/p&gt;
&lt;p&gt;原图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1698645/202002/1698645-20200201181633400-1383656186.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;卷积核尺寸5*5，σ=0.1：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1698645/202002/1698645-20200201181833312-1298567010.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;卷积核尺寸5*5，σ=1：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1698645/202002/1698645-20200201181935113-1630901092.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对比可以看到，Sigma(σ)越大，平滑效果越明显。&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;生成高斯滤波卷积核&quot;&gt;生成高斯滤波卷积核&lt;/h3&gt;
&lt;p&gt;滤波的主要目的是降噪，一般的图像处理算法都需要先进行降噪。而高斯滤波主要使图像变得平滑（模糊），同时也有可能增大了边缘的宽度。&lt;/p&gt;
&lt;p&gt;高斯函数是一个类似与正态分布的中间大两边小的函数。&lt;/p&gt;
&lt;p&gt;对于一个位置（m,n）的像素点，其灰度值（这里只考虑二值图）为f(m,n)。&lt;/p&gt;
&lt;p&gt;那么经过高斯滤波后的灰度值将变为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ g_\sigma(m,n)=\frac 1 {2\pi\sigma^2} \exp(-\frac {m^2+n^2}{2\sigma^2})f(m,n) \]&lt;/span&gt;&lt;br/&gt;其中，&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \frac 1 {{2\pi\sigma^2}} \exp(-\frac {m^2+n^2}{2\sigma^2}) \]&lt;/span&gt;&lt;br/&gt;是二元高斯函数。&lt;/p&gt;
&lt;p&gt;为了尽可能减少噪声对边缘检测结果的影响，所以必须滤除噪声以防止由噪声引起的错误检测。为了平滑图像，使用高斯滤波器与图像进行卷积，该步骤将平滑图像，以减少边缘检测器上明显的噪声影响。大小为(2k+1)x(2k+1)的高斯滤波器核的生成方程式由下式给出：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1698645/202002/1698645-20200201182018726-365241974.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面是一个sigma = 1.4，尺寸为3x3的高斯卷积核的例子（需要注意归一化）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1698645/202002/1698645-20200201182037844-1969871041.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;若图像中一个3x3的窗口为A，要滤波的像素点为e，则经过高斯滤波之后，像素点e的亮度值为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1698645/202002/1698645-20200201182057927-918293127.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中*为卷积符号，sum表示矩阵中所有元素相加求和。&lt;/p&gt;
&lt;p&gt;重要的是需要理解，高斯卷积核大小的选择将影响Canny检测器的性能。尺寸越大，检测器对噪声的敏感度越低，但是边缘检测的定位误差也将略有增加。一般5x5是一个比较不错的trade off。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static double[][] getGaussianArray(int size, double sigma) {
    double[][] array = new double[size][size];
    double center_i, center_j;
    if (size % 2 == 1) { center_i = (double) (size / 2); center_j = (double) (size / 2); }
    else { center_i = (double) (size / 2) - 0.5; center_j = (double) (size / 2) - 0.5; }
    double sum = 0.0;
    for (int i = 0; i &amp;lt; size; i ++)
            for (int j = 0; j &amp;lt; size; j ++) {
                array[i][j] = Math.exp((-1.0) * ((i - center_i) * (i - center_i) + (j - center_j) * (j - center_j)) / 2.0 / sigma / sigma);
                sum += array[i][j];
            }
    for (int i = 0; i &amp;lt; size; i ++)
            for (int j = 0; j &amp;lt; size; j++)
                array[i][j] /= sum;
    return array;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Sigma为1时，求得的3*3大小的高斯卷积核参数为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1698645/202002/1698645-20200201182118091-383466690.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Sigma为1,5*5大小的高斯卷积核参数为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1698645/202002/1698645-20200201182132065-288717245.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在计算出高斯滤波卷积核之后就是用这个卷积核来扫过整张图像，对每个像素点进行加权平均。&lt;/p&gt;
&lt;h3 id=&quot;单色高斯滤波与彩色高斯滤波&quot;&gt;单色高斯滤波与彩色高斯滤波&lt;/h3&gt;
&lt;p&gt;加入了多线程的优化，代码实现：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static Mat greyGaussianFilter(Mat src, double[][] array, int size) throws InterruptedException {
    Mat temp = src.clone();
    final CountDownLatch latch = new CountDownLatch(src.rows());
    for (int i = 0; i &amp;lt; src.rows(); i ++) {
            int finalI = i;
            new Thread(() -&amp;gt; {
                for (int j = 0; j &amp;lt; src.cols(); j ++)
                        if (finalI &amp;gt; (size / 2) - 1 &amp;amp;&amp;amp; j &amp;gt; (size / 2) - 1 &amp;amp;&amp;amp;
                            finalI &amp;lt; src.rows() - (size / 2) &amp;amp;&amp;amp; j &amp;lt; src.cols() - (size / 2)) {
                            double sum = 0.0;
                            for (int k = 0; k &amp;lt; size; k++)
                                    for (int l = 0; l &amp;lt; size; l++)
                                        sum += src.get(finalI - k + size / 2, j - l + size / 2)[0] * array[k][l];
                            temp.put(finalI, j, sum);
                        }
                latch.countDown();
            }).start();
    }
    latch.await();
    return temp;
}

public static Mat colorGaussianFilter(Mat src, int size, double sigma) throws InterruptedException {
    // return variable
    Mat ret = new Mat();
    // list for merge and split
    List&amp;lt;Mat&amp;gt; channels = new ArrayList&amp;lt;&amp;gt;();
    List&amp;lt;Mat&amp;gt; new_channels = new ArrayList&amp;lt;&amp;gt;();
    Map&amp;lt;Integer, Mat&amp;gt; temp_channels = new TreeMap&amp;lt;&amp;gt;();
    // split into 3 channels (r, g, b)
    Core.split(src, channels);
    // get gaussion array
    double[][] array = SmartGaussian.getGaussianArray(size, sigma);
    // multi-thread
    final CountDownLatch latch = new CountDownLatch(channels.size());
    channels.forEach(mat -&amp;gt; {
            new Thread(() -&amp;gt; {
                Mat tmp = new Mat();
                try {
                        tmp = SmartGaussian.greyGaussianFilter(mat, array, size);
                } catch (InterruptedException e) {
                        e.printStackTrace();
                }
                temp_channels.put(channels.indexOf(mat), tmp);
                latch.countDown();
            }).start();
    });
    latch.await();
    for (int i = 0; i &amp;lt; channels.size(); i ++)
          new_channels.add(temp_channels.get(i));
    Core.merge(new_channels, ret);
    return ret;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果图：（左图为原图，中间为上面的实现，右边是&lt;code&gt;OpenCV&lt;/code&gt;实现）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1698645/202002/1698645-20200201184656350-887010808.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;用sobel等梯度算子计算梯度幅值和方向&quot;&gt;用Sobel等梯度算子计算梯度幅值和方向&lt;/h2&gt;
&lt;h3 id=&quot;梯度&quot;&gt;梯度&lt;/h3&gt;
&lt;p&gt;梯度的本意是一个向量（矢量），表示某一函数在该点处的方向导数沿着该方向取得最大值，即函数在该点处沿着该方向（此梯度的方向）变化最快，变化率最大（为该梯度的模）。&lt;/p&gt;
&lt;p&gt;设二元函数：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ z=f(x,y) \]&lt;/span&gt;&lt;br/&gt;在平面区域D上具有一阶连续偏导数，则对于每一个点&lt;span class=&quot;math inline&quot;&gt;\(P(x,y)\)&lt;/span&gt;都可定出一个向量：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \Big\{\frac {∂ f}{∂ x},\frac {∂ f} {∂ y} \Big\} =f_x(x,y)\vec i + f_y(x,y)\vec j \]&lt;/span&gt;&lt;br/&gt;该函数就称为函数&lt;span class=&quot;math inline&quot;&gt;\(z=f(x,y)\)&lt;/span&gt;在点&lt;span class=&quot;math inline&quot;&gt;\(P(x,y)\)&lt;/span&gt;的梯度，记作&lt;span class=&quot;math inline&quot;&gt;\(\text{grad}~f(x,y)\)&lt;/span&gt;或&lt;span class=&quot;math inline&quot;&gt;\(\nabla f(x,y)\)&lt;/span&gt;，即有：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \text{grad}~f(x,y)=\nabla f(x,y)=\Big\{\frac {∂ f}{∂ x},\frac {∂ f} {∂ y} \Big\} =f_x(x,y)\vec i + f_y(x,y)\vec j \]&lt;/span&gt;&lt;br/&gt;其中&lt;img src=&quot;https://img2018.cnblogs.com/blog/1698645/202002/1698645-20200201184720673-1712920732.png&quot;/&gt;称为（二维的）向量&lt;a href=&quot;https://baike.baidu.com/item/%E5%BE%AE%E5%88%86%E7%AE%97%E5%AD%90&quot;&gt;微分算子&lt;/a&gt;或Nabla算子。&lt;/p&gt;
&lt;p&gt;设&lt;img src=&quot;https://img2018.cnblogs.com/blog/1698645/202002/1698645-20200201184757238-232699116.png&quot;/&gt; 是方向&lt;span class=&quot;math inline&quot;&gt;\(l\)&lt;/span&gt;上的单位向量，则&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1698645/202002/1698645-20200201184818446-47981311.png&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1698645/202002/1698645-20200201184830500-320671486.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于当方向&lt;span class=&quot;math inline&quot;&gt;\(l\)&lt;/span&gt;与梯度方向一致时，有&lt;img src=&quot;https://img2018.cnblogs.com/blog/1698645/202002/1698645-20200201184903698-942311703.png&quot;/&gt;。&lt;/p&gt;
&lt;p&gt;所以当&lt;span class=&quot;math inline&quot;&gt;\(l\)&lt;/span&gt;与梯度方向一致时,方向导数&lt;img src=&quot;https://img2018.cnblogs.com/blog/1698645/202002/1698645-20200201184923552-719939120.png&quot;/&gt;有最大值，且最大值为梯度的模，即&lt;img src=&quot;https://img2018.cnblogs.com/blog/1698645/202002/1698645-20200201184944968-1191976548.png&quot;/&gt;。&lt;/p&gt;
&lt;p&gt;因此说，函数在一点沿梯度方向的变化率最大，最大值为该梯度的&lt;a href=&quot;https://baike.baidu.com/item/%E6%A8%A1/13332717&quot;&gt;模&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;图像灰度值的梯度的简单求法&quot;&gt;图像灰度值的梯度的简单求法&lt;/h3&gt;
&lt;p&gt;图像灰度值的梯度可以使用最简单的一阶有限差分来进行近似，使用以下图像在x和y方向上偏导数的两个矩阵：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1698645/202002/1698645-20200201193031666-939043532.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;计算公式为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1698645/202002/1698645-20200201193050519-192933697.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其中&lt;span class=&quot;math inline&quot;&gt;\(f\)&lt;/span&gt;为图像灰度值，&lt;span class=&quot;math inline&quot;&gt;\(P[i,j]\)&lt;/span&gt;代表&lt;span class=&quot;math inline&quot;&gt;\([i,j]\)&lt;/span&gt;在&lt;span class=&quot;math inline&quot;&gt;\(X\)&lt;/span&gt;方向梯度幅值，&lt;span class=&quot;math inline&quot;&gt;\(Q[i,j]\)&lt;/span&gt;代表&lt;span class=&quot;math inline&quot;&gt;\([i,j]\)&lt;/span&gt;在&lt;span class=&quot;math inline&quot;&gt;\(Y\)&lt;/span&gt;方向的梯度幅值，&lt;span class=&quot;math inline&quot;&gt;\(M[i,j]\)&lt;/span&gt;是该点幅值，&lt;span class=&quot;math inline&quot;&gt;\(\theta[i,j]\)&lt;/span&gt;是梯度方向，也就是角度。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;使用sobel算子来计算梯度的大小及方向&quot;&gt;使用Sobel算子来计算梯度的大小及方向：&lt;/h3&gt;
&lt;p&gt;图像中的边缘可以指向各个方向，因此Canny算法使用四个算子来检测图像中的水平、垂直和对角边缘。边缘检测的算子（如Roberts，Prewitt，Sobel等）返回水平Gx和垂直Gy方向的一阶导数值，由此便可以确定像素点的梯度G和方向theta 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1698645/202002/1698645-20200201193122793-2023167679.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中G为梯度强度， theta表示梯度方向，arctan为反正切函数。下面以Sobel算子为例讲述如何计算梯度强度和方向。&lt;/p&gt;
&lt;p&gt;x和y方向的Sobel算子分别为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1698645/202002/1698645-20200201193206944-1707318586.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中Sx表示x方向的Sobel算子，用于检测y方向的边缘； Sy表示y方向的Sobel算子，用于检测x方向的边缘（边缘方向和梯度方向垂直）。在直角坐标系中，Sobel算子的方向如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1698645/202002/1698645-20200201193315459-2022912165.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;若图像中一个3x3的窗口为A，要计算梯度的像素点为e，则和Sobel算子进行卷积之后，像素点e在x和y方向的梯度值分别为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1698645/202002/1698645-20200201193336605-1054329649.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中*为卷积符号，sum表示矩阵中所有元素相加求和。根据公式（3-2）便可以计算出像素点e的梯度和方向。&lt;/p&gt;
&lt;p&gt;下面是Sobel算子求梯度的java实现：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package edu.sfls.Jeff.JavaDev.CVLib;

import org.opencv.core.Core;
import org.opencv.core.CvType;
import org.opencv.core.Mat;

import java.util.concurrent.CountDownLatch;

public class SmartSobel {

    private Mat gradientX = new Mat(), gradientY = new Mat(), gradientXY = new Mat();
    private double[][] pointDirection;

    public SmartSobel() {}

    public void compute(Mat image) throws InterruptedException {
        pointDirection = new double[image.rows()][image.cols()];
        for (int i = 0; i &amp;lt; image.rows(); i ++)
            for (int j = 0; j &amp;lt; image.cols(); j ++)
                pointDirection[i][j] = 0;
        gradientX = Mat.zeros(image.size(), CvType.CV_32SC1);
        gradientY = Mat.zeros(image.size(), CvType.CV_32SC1);
        gradientXY = Mat.zeros(image.size(), CvType.CV_32SC1);
        final CountDownLatch latch = new CountDownLatch(image.rows() - 2);
        for (int i = 1; i &amp;lt; image.rows() - 1; i ++) {
            int finalI = i;
            new Thread(() -&amp;gt; {
                for (int j = 1; j &amp;lt; image.cols() - 1; j++) {
                    double gX = (-1) * image.get(finalI - 1, j - 1)[0] +
                            1 * image.get(finalI - 1, j + 1)[0] +
                            (-2) * image.get(finalI, j - 1)[0] +
                            2 * image.get(finalI, j + 1)[0] +
                            (-1) * image.get(finalI + 1, j - 1)[0] +
                            1 * image.get(finalI + 1, j + 1)[0];
                    double gY = 1 * image.get(finalI - 1, j - 1)[0] +
                            2 * image.get(finalI - 1, j)[0] +
                            1 * image.get(finalI - 1, j + 1)[0] +
                            (-1) * image.get(finalI + 1, j - 1)[0] +
                            (-2) * image.get(finalI + 1, j)[0] +
                            (-1) * image.get(finalI + 1, j + 1)[0];
                    gradientY.put(finalI, j, Math.abs(gY));
                    gradientX.put(finalI, j, Math.abs(gX));
                    gradientXY.put(finalI, j, Math.sqrt(gX * gX + gY * gY));
                    // 防止除以0的情况发生
                    if (gX == 0) gX = 0.00000000000000001;
                    pointDirection[finalI][j] = Math.atan(gY / gX);
                }
                latch.countDown();
            }).start();
        }
        latch.await();
    }

    public void convert() {
        Core.convertScaleAbs(gradientX, gradientX);
        Core.convertScaleAbs(gradientY, gradientY);
        Core.convertScaleAbs(gradientXY, gradientXY);
    }

    public Mat getGradientX() { return this.gradientX; }

    public Mat getGradientY() { return this.gradientY; }

    public Mat getGradientXY() { return this.gradientXY; }

    public double[][] getPointDirection() { return this.pointDirection; }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于这里使用的是&lt;span class=&quot;math inline&quot;&gt;\(Math.tan()\)&lt;/span&gt;，所以最终的角度是映射在&lt;span class=&quot;math inline&quot;&gt;\([-\frac \pi 2, \frac \pi 2]\)&lt;/span&gt;的范围之内的。如果使用&lt;span class=&quot;math inline&quot;&gt;\(Math.tan2()\)&lt;/span&gt;会映射到&lt;span class=&quot;math inline&quot;&gt;\([-\pi,\pi]\)&lt;/span&gt;的范围内，并且无需考虑符号影响，更加精确。但是这里我们并不关心另外的一个&lt;span class=&quot;math inline&quot;&gt;\(\pi\)&lt;/span&gt;的情况，我们只关心其所在直线（这在后文中会提到，也就是非极大值抑制），所以无需多考虑。&lt;/p&gt;
&lt;p&gt;X方向梯度图： Y方向梯度图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1698645/202002/1698645-20200201193357491-109949366.jpg&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1698645/202002/1698645-20200201193418546-1932836478.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;X、Y方向梯度融合效果： Opencv Sobel函数效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1698645/202002/1698645-20200201193435024-1676390420.jpg&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1698645/202002/1698645-20200201193457528-205951203.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;对梯度幅值进行非极大值抑制&quot;&gt;对梯度幅值进行非极大值抑制&lt;/h2&gt;
&lt;p&gt;非极大值抑制是一种边缘稀疏技术，非极大值抑制的作用在于“瘦”边。对图像进行梯度计算后，仅仅基于梯度值提取的边缘仍然很模糊。对于标准3，对边缘有且应当只有一个准确的响应。而非极大值抑制则可以帮助将局部最大值之外的所有梯度值抑制为0，对梯度图像中每个像素进行非极大值抑制的算法是：&lt;/p&gt;
&lt;p&gt;1) 将当前像素的梯度强度与沿正负梯度方向上的两个像素进行比较。&lt;/p&gt;
&lt;p&gt;2) 如果当前像素的梯度强度与另外两个像素相比最大，则该像素点保留为边缘点，否则该像素点将被抑制。&lt;/p&gt;
&lt;p&gt;通常为了更加精确的计算，在跨越梯度方向的两个相邻像素之间使用线性插值来得到要比较的像素梯度，现举例如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1698645/202002/1698645-20200201193521156-1430295919.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　图3-2 梯度方向分割&lt;/p&gt;
&lt;p&gt;如图3-2所示，将梯度分为8个方向，分别为E、NE、N、NW、W、SW、S、SE，其中0代表&lt;span class=&quot;math inline&quot;&gt;\(0^\circ\sim45^\circ\)&lt;/span&gt;,1代表&lt;span class=&quot;math inline&quot;&gt;\(45^\circ\sim90^\circ\)&lt;/span&gt;，2代表&lt;span class=&quot;math inline&quot;&gt;\(-90^\circ\sim-45^\circ\)&lt;/span&gt;，3代表&lt;span class=&quot;math inline&quot;&gt;\(-45^\circ\sim0^\circ\)&lt;/span&gt;。像素点P的梯度方向为&lt;span class=&quot;math inline&quot;&gt;\(\theta\)&lt;/span&gt;，则像素点P1和P2的梯度线性插值为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \tan \theta = G_y ~/~G_x \\ G_{p1} = (1-\tan\theta)\times E + \tan\theta \times NE \\ G_{p2} = (1-\tan\theta)\times W + \tan\theta \times SW \\ \]&lt;/span&gt;&lt;br/&gt;上面也只是图中的情况，具体情况如下：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \theta \in [0, \frac \pi 4]: \begin {cases} G_{p1} = (1-\tan\theta)\times E + \tan\theta \times NE \\ G_{p2} = (1-\tan\theta)\times W + \tan\theta \times SW \end {cases}\\\theta \in [\frac \pi 4, \frac \pi 2]: \begin {cases} G_{p1} = (1-\tan\theta)\times N + \tan\theta \times NE \\ G_{p2} = (1-\tan\theta)\times S + \tan\theta \times SW \end {cases}\\\theta \in [-\frac \pi 4, 0]: \begin {cases} G_{p1} = (1-\tan(-\theta))\times E + \tan(-\theta) \times SE \\ G_{p2} = (1-\tan(-\theta))\times W + \tan(-\theta) \times NW \end {cases}\\\theta \in [-\frac \pi 2, -\frac \pi 4]: \begin {cases} G_{p1} = (1-\tan(-\theta))\times S + \tan(-\theta) \times SE \\ G_{p2} = (1-\tan(-\theta))\times N + \tan(-\theta) \times NW \end {cases}\\ \]&lt;/span&gt;&lt;br/&gt;因此非极大值抑制的伪代码描写如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1698645/202002/1698645-20200201193540655-689874486.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;需要注意的是，如何标志方向并不重要，重要的是梯度方向的计算要和梯度算子的选取保持一致。&lt;/p&gt;
&lt;p&gt;Java实现：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package edu.sfls.Jeff.JavaDev.CVLib;

import org.opencv.core.CvType;
import org.opencv.core.Mat;

import java.util.concurrent.CountDownLatch;

public class SmartNMS {

    public static Mat NMS(Mat gradientImage, double[][] pointDirection) throws InterruptedException {
        Mat outputImage = gradientImage.clone();
        final CountDownLatch latch = new CountDownLatch(gradientImage.rows() - 2);
        for (int i = 1; i &amp;lt; gradientImage.rows() - 1; i ++) {
            int finalI = i;
            new Thread(() -&amp;gt; {
                for (int j = 1; j &amp;lt; gradientImage.cols() - 1; j ++) {
                    double GP = gradientImage.get(finalI, j)[0],
                            E = gradientImage.get(finalI, j + 1)[0],
                            NE = gradientImage.get(finalI - 1, j + 1)[0],
                            N = gradientImage.get(finalI - 1, j)[0],
                            NW = gradientImage.get(finalI - 1, j - 1)[0],
                            W = gradientImage.get(finalI, j - 1)[0],
                            SW = gradientImage.get(finalI + 1, j - 1)[0],
                            S = gradientImage.get(finalI + 1, j)[0],
                            SE = gradientImage.get(finalI + 1, j + 1)[0];
                    double GP1 = 0, GP2 = 0;
                    double theta = pointDirection[finalI][j];
                    if (theta &amp;gt;= 0 &amp;amp;&amp;amp; theta &amp;lt;= Math.PI / 4) {
                        GP1 = E * (1 - Math.tan(theta)) + NE * Math.tan(theta);
                        GP2 = W * (1 - Math.tan(theta)) + SW * Math.tan(theta);
                    } else if (theta &amp;gt; Math.PI / 4) {
                        GP1 = N * (1 - 1 / Math.tan(theta)) + NE * 1 / Math.tan(theta);
                        GP2 = S * (1 - 1 / Math.tan(theta)) + SW * 1 / Math.tan(theta);
                    } else if (theta &amp;lt; 0 &amp;amp;&amp;amp; theta &amp;gt;= -Math.PI / 4) {
                        GP1 = E * (1 - Math.tan(-theta)) + SE * Math.tan(-theta);
                        GP2 = W * (1 - Math.tan(-theta)) + NW * Math.tan(-theta);
                    } else {
                        GP1 = S * (1 - 1 / Math.tan(-theta)) + SE * 1 / Math.tan(-theta);
                        GP2 = N * (1 - 1 / Math.tan(-theta)) + NW * 1 / Math.tan(-theta);
                    }
                    if (GP &amp;lt; GP1 || GP &amp;lt; GP2) outputImage.put(finalI, j, 0);
                }
                latch.countDown();
            }).start();
        }
        latch.await();
        return outputImage;
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;双阈值检测&quot;&gt;双阈值检测&lt;/h2&gt;
&lt;p&gt;在施加非极大值抑制之后，剩余的像素可以更准确地表示图像中的实际边缘。然而，仍然存在由于噪声和颜色变化引起的一些边缘像素。为了解决这些杂散响应，必须用弱梯度值过滤边缘像素，并保留具有高梯度值的边缘像素，可以通过选择高低阈值来实现。如果边缘像素的梯度值高于高阈值，则将其标记为强边缘像素；如果边缘像素的梯度值小于高阈值并且大于低阈值，则将其标记为弱边缘像素；如果边缘像素的梯度值小于低阈值，则会被抑制。阈值的选择取决于给定输入图像的内容。&lt;/p&gt;
&lt;p&gt;双阈值检测的伪代码描写如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1698645/202002/1698645-20200201193600026-1589677941.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;抑制孤立低阈值点&quot;&gt;抑制孤立低阈值点&lt;/h2&gt;
&lt;p&gt;到目前为止，被划分为强边缘的像素点已经被确定为边缘，因为它们是从图像中的真实边缘中提取出来的。然而，对于弱边缘像素，将会有一些争论，因为这些像素可以从真实边缘提取也可以是因噪声或颜色变化引起的。为了获得准确的结果，应该抑制由后者引起的弱边缘。通常，由真实边缘引起的弱边缘像素将连接到强边缘像素，而噪声响应未连接。为了跟踪边缘连接，通过查看弱边缘像素及其8个邻域像素，只要其中一个为强边缘像素，则该弱边缘点就可以保留为真实的边缘。&lt;/p&gt;
&lt;p&gt;抑制孤立边缘点的伪代码描述如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1698645/202002/1698645-20200201193617604-1310834317.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;实现：（使用递归）&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package edu.sfls.Jeff.JavaDev.CVLib;

import org.opencv.core.Mat;

import java.util.ArrayList;
import java.util.List;

public class SmartCanny {

    private List&amp;lt;Integer[]&amp;gt; highPoints = new ArrayList&amp;lt;Integer[]&amp;gt;();

    private void DoubleThreshold(Mat image, double lowThreshold, double highThreshold) {
        for (int i = 1; i &amp;lt; image.rows() - 1; i ++)
            for (int j = 1; j &amp;lt; image.cols() - 1; j ++)
                if (image.get(i, j)[0] &amp;gt;= highThreshold) {
                    image.put(i, j, 255);
                    Integer[] p = new Integer[2];
                    p[0] = i; p[1] = j;
                    highPoints.add(p);
                } else if (image.get(i, j)[0] &amp;lt; lowThreshold)
                    image.put(i, j, 0);
    }

    private void DoubleThresholdLink(Mat image, double lowThreshold) {
        for (Integer[] p : highPoints) {
            DoubleThresholdLinkRecurrent(image, lowThreshold, p[0], p[1]);
        }
        for (int i = 1; i &amp;lt; image.rows() - 1; i ++)
            for (int j = 1; j &amp;lt; image.cols() - 1; j ++)
                if (image.get(i, j)[0] &amp;lt; 255)
                    image.put(i, j, 0);
    }

    private void DoubleThresholdLinkRecurrent(Mat image, double lowThreshold, int i, int j) {
        if (i &amp;lt;= 0 || j &amp;lt;= 0 || i &amp;gt;= image.rows() - 1 || j &amp;gt;= image.cols() - 1) return;
        if (image.get(i - 1, j - 1)[0] &amp;gt;= lowThreshold &amp;amp;&amp;amp; image.get(i - 1, j - 1)[0] &amp;lt; 255) {
            image.put(i - 1, j - 1, 255);
            DoubleThresholdLinkRecurrent(image, lowThreshold, i - 1, j - 1);
        }
        if (image.get(i - 1, j)[0] &amp;gt;= lowThreshold &amp;amp;&amp;amp; image.get(i - 1, j)[0] &amp;lt; 255) {
            image.put(i - 1, j, 255);
            DoubleThresholdLinkRecurrent(image, lowThreshold, i - 1, j);
        }
        if (image.get(i - 1, j + 1)[0] &amp;gt;= lowThreshold &amp;amp;&amp;amp; image.get(i - 1, j + 1)[0] &amp;lt; 255) {
            image.put(i - 1, j + 1, 255);
            DoubleThresholdLinkRecurrent(image, lowThreshold, i - 1, j + 1);
        }
        if (image.get(i, j - 1)[0] &amp;gt;= lowThreshold &amp;amp;&amp;amp; image.get(i, j - 1)[0] &amp;lt; 255) {
            image.put(i, j - 1, 255);
            DoubleThresholdLinkRecurrent(image, lowThreshold, i, j - 1);
        }
        if (image.get(i, j + 1)[0] &amp;gt;= lowThreshold &amp;amp;&amp;amp; image.get(i, j + 1)[0] &amp;lt; 255) {
            image.put(i, j + 1, 255);
            DoubleThresholdLinkRecurrent(image, lowThreshold, i, j + 1);
        }
        if (image.get(i + 1, j - 1)[0] &amp;gt;= lowThreshold &amp;amp;&amp;amp; image.get(i + 1, j - 1)[0] &amp;lt; 255) {
            image.put(i + 1, j - 1, 255);
            DoubleThresholdLinkRecurrent(image, lowThreshold, i + 1, j - 1);
        }
        if (image.get(i + 1, j)[0] &amp;gt;= lowThreshold &amp;amp;&amp;amp; image.get(i + 1, j)[0] &amp;lt; 255) {
            image.put(i + 1, j, 255);
            DoubleThresholdLinkRecurrent(image, lowThreshold, i + 1, j);
        }
        if (image.get(i + 1, j + 1)[0] &amp;gt;= lowThreshold &amp;amp;&amp;amp; image.get(i + 1, j + 1)[0] &amp;lt; 255) {
            image.put(i + 1, j + 1, 255);
            DoubleThresholdLinkRecurrent(image, lowThreshold, i + 1, j + 1);
        }
    }

    public Mat Canny(Mat image, int size, double sigma, double lowThreshold, double highThreshold) throws InterruptedException {
        Mat tmp = SmartConverter.RGB2Gray((SmartGaussian.colorGaussianFilter(image, size, sigma)));
        SmartSobel ss = new SmartSobel();
        ss.compute(tmp);
        ss.convert();
        Mat ret = SmartNMS.NMS(ss.getGradientXY(), ss.getPointDirection());
        this.DoubleThreshold(ret, lowThreshold, highThreshold);
        this.DoubleThresholdLink(ret, lowThreshold);
        return ret;
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1698645/202002/1698645-20200201193637776-595635928.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1698645/202002/1698645-20200201193656321-1449952129.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
&lt;p&gt;[1] 高斯滤波及高斯卷积核C++实现 &lt;a href=&quot;https://blog.csdn.net/dcrmg/article/details/52304446&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/dcrmg/article/details/52304446&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[2] 边缘检测之Canny &lt;a href=&quot;https://www.cnblogs.com/techyan1990/p/7291771.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/techyan1990/p/7291771.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[3] Canny边缘检测及C++实现 &lt;a href=&quot;https://blog.csdn.net/dcrmg/article/details/52344902&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/dcrmg/article/details/52344902&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[4] Canny边缘检测算法 &lt;a href=&quot;https://zhuanlan.zhihu.com/p/42122107&quot; class=&quot;uri&quot;&gt;https://zhuanlan.zhihu.com/p/42122107&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[5] Sobel算子及C++实现 &lt;a href=&quot;https://blog.csdn.net/dcrmg/article/details/52280768&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/dcrmg/article/details/52280768&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 01 Feb 2020 11:38:00 +0000</pubDate>
<dc:creator>gyro永不抽风</dc:creator>
<og:description>Canny边缘检测算法（基于OpenCV的Java实现） [TOC] 绪论 最近在学习ORB的过程中又仔细学习了Canny，故写下此篇笔记，以作总结。 Canny边缘检测算法的发展历史 Canny边缘</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jeffersonqin/p/12249753.html</dc:identifier>
</item>
<item>
<title>肺炎确诊人数增长趋势拟合和预测（截止2月1日） - 图灵的猫</title>
<link>http://www.cnblogs.com/y1ran/p/12249520.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/y1ran/p/12249520.html</guid>
<description>&lt;p&gt;&lt;strong&gt;预测2月2日确诊感染人数为14000，增长区间为14000-14500&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;昨日（1月31日）预测2月1日确诊感染人数为11500，增长区间为11500-12000。目前实际感染人数11800，误差较小。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;前日（1月30日）预测1月31日确诊感染人数为9500，目前实际感染人数9723例，增速环比上升，但和模型相比再次放缓。增长区间为9500-10000&lt;/p&gt;
&lt;hr/&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; 更新：昨天预测1月30日确诊感染人数为8500，目前实际感染人数8147例，增速再次放缓&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;更新：1月29日，预测感染确诊人数6000（中午12时），实际感染人数5999。预计29日12时至24时增长区间为6000-7000，因为增长速度放缓，区间缩小为6000-6200。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;截止目前（1月28日），数据都符合简单的指数曲线增长趋势。&lt;/p&gt;
&lt;p&gt;所有数据都来自官方公布的确诊人数，取每天中午12点的人数为准。前4天没有拟合，因为数据点太少。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;第4天（1月24日）&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic2.zhimg.com/80/v2-6b4ced163db63662ad77e3b42e115818_hd.jpg&quot; alt=&quot;&quot; width=&quot;601&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;601&quot; data-rawheight=&quot;358&quot; data-default-watermark-src=&quot;https://pic2.zhimg.com/50/v2-10e9ce126db22021435ce0494a9cb991_hd.jpg&quot; data-original=&quot;https://pic2.zhimg.com/v2-6b4ced163db63662ad77e3b42e115818_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/50/v2-6b4ced163db63662ad77e3b42e115818_hd.jpg&quot; data-lazy-status=&quot;ok&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;第6天（1月26日）&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic3.zhimg.com/80/v2-de21b2a7683649d9d990d11c457caa02_hd.jpg&quot; alt=&quot;&quot; width=&quot;604&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;604&quot; data-rawheight=&quot;359&quot; data-default-watermark-src=&quot;https://pic4.zhimg.com/50/v2-b673e98e981e8a22f849288434eecd70_hd.jpg&quot; data-original=&quot;https://pic3.zhimg.com/v2-de21b2a7683649d9d990d11c457caa02_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/50/v2-de21b2a7683649d9d990d11c457caa02_hd.jpg&quot; data-lazy-status=&quot;ok&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;第8天（1月28日）&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic4.zhimg.com/80/v2-5986e62dbe0a1fd567ccceccc02e5040_hd.jpg&quot; alt=&quot;&quot; width=&quot;602&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;602&quot; data-rawheight=&quot;350&quot; data-default-watermark-src=&quot;https://pic2.zhimg.com/50/v2-160db07a1641a05f53d412450a426a7f_hd.jpg&quot; data-original=&quot;https://pic4.zhimg.com/v2-5986e62dbe0a1fd567ccceccc02e5040_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/50/v2-5986e62dbe0a1fd567ccceccc02e5040_hd.jpg&quot; data-lazy-status=&quot;ok&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第9天（1月29日）&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic2.zhimg.com/80/v2-04f77f1b909d3655aaed372754c968e2_hd.jpg&quot; alt=&quot;&quot; width=&quot;601&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;601&quot; data-rawheight=&quot;361&quot; data-default-watermark-src=&quot;https://pic3.zhimg.com/50/v2-0d104975788db84151718067308131c1_hd.jpg&quot; data-original=&quot;https://pic2.zhimg.com/v2-04f77f1b909d3655aaed372754c968e2_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/50/v2-04f77f1b909d3655aaed372754c968e2_hd.jpg&quot; data-lazy-status=&quot;ok&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第10天（1月30日）&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic2.zhimg.com/80/v2-1efd96c339b16ec41d4df370a63353a4_hd.jpg&quot; alt=&quot;&quot; width=&quot;611&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;611&quot; data-rawheight=&quot;372&quot; data-default-watermark-src=&quot;https://pic3.zhimg.com/50/v2-226a4b03d281bae163d0edccbb984be7_hd.jpg&quot; data-original=&quot;https://pic2.zhimg.com/v2-1efd96c339b16ec41d4df370a63353a4_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/50/v2-1efd96c339b16ec41d4df370a63353a4_hd.jpg&quot; data-lazy-status=&quot;ok&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第11天（1月31日）&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic3.zhimg.com/80/v2-d7ca752dd378aeb6db38acee67c20ac0_hd.jpg&quot; alt=&quot;&quot; width=&quot;601&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;601&quot; data-rawheight=&quot;358&quot; data-default-watermark-src=&quot;https://pic2.zhimg.com/50/v2-f4f1a6ab2adc63039f228a3c7d9ec660_hd.jpg&quot; data-original=&quot;https://pic3.zhimg.com/v2-d7ca752dd378aeb6db38acee67c20ac0_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/50/v2-d7ca752dd378aeb6db38acee67c20ac0_hd.jpg&quot; data-lazy-status=&quot;ok&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;第12天（2月1日）&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic1.zhimg.com/80/v2-cc4f89510610ac02d62d8586f8324779_hd.jpg&quot; alt=&quot;&quot; width=&quot;603&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;603&quot; data-rawheight=&quot;359&quot; data-default-watermark-src=&quot;https://pic4.zhimg.com/50/v2-d68d2b87566397c0138484b6d1def10a_hd.jpg&quot; data-original=&quot;https://pic1.zhimg.com/v2-cc4f89510610ac02d62d8586f8324779_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/50/v2-cc4f89510610ac02d62d8586f8324779_hd.jpg&quot; data-lazy-status=&quot;ok&quot;/&gt;&lt;/p&gt;
&lt;p&gt;需要声明的是&lt;/p&gt;
&lt;p&gt;1）没有任何证据显示预测人数是准确无误的，本文也不构成任何建议。这里只是简单的做一个数据分析，用的是指数曲线进行拟合，公式已经在图里了。&lt;/p&gt;
&lt;p&gt;2）这几张图只能说明在疫情扩散前期，是符合简单的指数曲线增长规律的。在国家严密防控的情况下，潜伏期后，确认人数的增长速度一定会放缓。&lt;/p&gt;
&lt;p&gt;这里我没有使用复杂的时间序列模型和RNN类模型，因为预测出来的反而会过拟合。经过测试，只有简单的指数模型拟合度更高，这可能是和传染病扩散的原理有关，具体的大家可以自己去搜索研究。&lt;/p&gt;
&lt;h2&gt;权威专家意见&lt;/h2&gt;
&lt;p&gt;1）1月28日，钟南山院士接受新华社专访，谈了他对疫情的最新看法。钟南山表示，疫情应该在一周或者10天左右达到高峰，不会大规模地增加了。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;发热仍然是新型冠状病毒感染的典型症状。10到14天是一个很好的隔离观察期，潜伏期过去了，发病的及时治疗，没发病也就没病，不会因为春运返程出现大传染，但排查的措施不能停。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2）武汉大学中南医院感染科教授桂希恩预测，发病率“转弯”以周计算，预计正月十五前武汉市的疫情扩散会出现拐点，大家一定要保持信心。3）中国工程院院士、国家卫健委高级别专家组李兰娟院士表示，目前确诊病例增加在我们的预计之中。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;疫情峰值我们也在不断的预测，关键是我们对于已经感染的人全部隔离了。对于那些隐性感染的人全部找到，感染的人全部隔离，那么通过14天的潜伏期在隔离以后，那么新发的感染率就要慢慢的往下降了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在杭州的国家重点实验室分离出了3株新型冠状病毒的毒株，意味着我们已经拥有了疫苗的种子株。通过疫苗株以后，我们就可以制备疫苗。制备疫苗要有个过程，拿到疫苗株需要一个半月，之后还需要一个半月的审批过程。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;PS. 如果有人看，之后每天我都会更新一下曲线，同时验证一下之前的曲线预测的拟合和误差情况。&lt;/p&gt;
&lt;p&gt;最后提醒大家，勤洗手，多通风，记保暖，戴口罩。远离病毒，保护健康，人人有责~&lt;/p&gt;
</description>
<pubDate>Sat, 01 Feb 2020 10:47:00 +0000</pubDate>
<dc:creator>图灵的猫</dc:creator>
<og:description>预测2月2日确诊感染人数为14000，增长区间为14000-14500 昨日（1月31日）预测2月1日确诊感染人数为11500，增长区间为11500-12000。目前实际感染人数11800，误差较小。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/y1ran/p/12249520.html</dc:identifier>
</item>
</channel>
</rss>