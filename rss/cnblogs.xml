<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>一文入门C3 - 鲲逸鹏</title>
<link>http://www.cnblogs.com/dotnetcrazy/p/10748103.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dotnetcrazy/p/10748103.html</guid>
<description>&lt;p&gt;官方文档：&lt;a href=&quot;http://www.w3school.com.cn/cssref/index.asp&quot; class=&quot;uri&quot;&gt;http://www.w3school.com.cn/cssref/index.asp&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;css基础&quot;&gt;2.1.CSS基础&lt;/h2&gt;
&lt;p&gt;基础简单过下，事先说明下：诸如引入、注释、案例就不一一演示了，有个工作1年左右的人都可以熟练掌握，所以基础部分就简单归纳一下&lt;strong&gt;W3C的常用属性列表&lt;/strong&gt;了&lt;/p&gt;
&lt;h3 id=&quot;文本属性fonttext&quot;&gt;2.1.1.文本属性（font、text）&lt;/h3&gt;
&lt;p&gt;官方文档：&lt;a href=&quot;http://www.w3school.com.cn/cssref/index.asp#font&quot; class=&quot;uri&quot;&gt;http://www.w3school.com.cn/cssref/index.asp#font&lt;/a&gt; or &lt;a href=&quot;http://www.w3school.com.cn/cssref/index.asp#text&quot; class=&quot;uri&quot;&gt;http://www.w3school.com.cn/cssref/index.asp#text&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;color&lt;/code&gt;：文字的颜色&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;eg：&lt;code&gt;color:red;&lt;/code&gt;、&lt;code&gt;color: #000;&lt;/code&gt;、&lt;code&gt;color: rgb(0,0,0);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;font-size&lt;/code&gt;：文字的大小&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;eg：&lt;code&gt;font-size:12px;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;font-family&lt;/code&gt;：文字的字体&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;eg：使用微软雅黑字体：&lt;code&gt;font-family:'Microsoft Yahei';&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;font-style&lt;/code&gt;：字体是否倾斜&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;eg：字体不倾斜：&lt;code&gt;font-style:normal;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;PS：&lt;strong&gt;一般对&lt;code&gt;i&lt;/code&gt;、&lt;code&gt;em&lt;/code&gt;这些会导致字体倾斜的标签设置&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;font-weight&lt;/code&gt;：文字是否加粗&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;eg：字体加粗：&lt;code&gt;font-weight:bold;&lt;/code&gt;、字体不加粗：&lt;code&gt;font-weight:normal;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;**line-height**&lt;/code&gt;：文字的行高
&lt;ul&gt;&lt;li&gt;eg：&lt;code&gt;line-height:24px;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;2~6汇总设置&lt;/code&gt;：&lt;strong&gt;&lt;code&gt;font&lt;/code&gt;：同时设置文字的几个属性&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;需按顺序写：&lt;strong&gt;&lt;code&gt;font：是否加粗 字号/行高 字体;&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;eg：&lt;code&gt;font:normal 12px/36px 'Microsoft Yahei';&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;text-align&lt;/code&gt;：文字水平对齐方式&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;eg：水平居中：&lt;code&gt;text-align:center&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;list-style-type&lt;/code&gt;：设置列表项标记符号&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;去除符号：&lt;code&gt;list-style-type:none;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;PS：&lt;strong&gt;一般都是去除标记用的多&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;text-decoration&lt;/code&gt;：文字下划线&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;eg：去除文字下划线：&lt;code&gt;text-decoration:none;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;PS：&lt;strong&gt;一般都是去除&lt;code&gt;a&lt;/code&gt;的下划线&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;text-indent&lt;/code&gt;：文字首行缩进
&lt;ul&gt;&lt;li&gt;eg：首行缩进2个字符：&lt;code&gt;text-indent:2em;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;text-transform&lt;/code&gt;：控制文本的大小写
&lt;ul&gt;&lt;li&gt;&lt;code&gt;none&lt;/code&gt;：定义带有小写字母和大写字母的标准的文本(默认)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;capitalize&lt;/code&gt;：单词中首字母大写&lt;/li&gt;
&lt;li&gt;&lt;code&gt;uppercase&lt;/code&gt;：单词大写&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lowercase&lt;/code&gt;：单词小写&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;背景相关background&quot;&gt;2.1.2.背景相关（background）&lt;/h3&gt;
&lt;p&gt;官方文档：&lt;a href=&quot;http://www.w3school.com.cn/cssref/index.asp#background&quot; class=&quot;uri&quot;&gt;http://www.w3school.com.cn/cssref/index.asp#background&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;background&lt;/code&gt;&lt;/strong&gt;：汇总&lt;code&gt;2~6&lt;/code&gt;
&lt;ul&gt;&lt;li&gt;参考顺序：&lt;strong&gt;&lt;code&gt;background: 颜色 url(背景图) no-repeat 定位 fixed&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;eg：&lt;code&gt;background:url(雪碧图) no-repeat left -3.025rem;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;background-color&lt;/code&gt;：设置元素的背景颜色&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;background-image&lt;/code&gt;：设置元素的背景图像&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;background-repeat&lt;/code&gt;：设置是否及如何重复背景图像&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;background-position&lt;/code&gt;：设置背景图像的开始位置&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;垂直居中 + 水平居中：&lt;code&gt;background-position: center center;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;background-attachment&lt;/code&gt;：设置背景图像是否固定或者随着页面的其余部分滚动&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;盒模型系box&quot;&gt;2.1.3.盒模型系（box）&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;普通盒子&lt;code&gt;宽 | 高&lt;/code&gt; = &lt;code&gt;width | height&lt;/code&gt; + &lt;code&gt;padding&lt;/code&gt; + &lt;code&gt;border&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;尺寸属性widthheight&quot;&gt;1.尺寸属性（width、height）&lt;/h4&gt;
&lt;p&gt;官方文档：&lt;a href=&quot;http://www.w3school.com.cn/cssref/index.asp#dimension&quot; class=&quot;uri&quot;&gt;http://www.w3school.com.cn/cssref/index.asp#dimension&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;width&lt;/code&gt;：宽度&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;height&lt;/code&gt;：高度&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;max-width&lt;/code&gt;：最大宽度&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;max-height&lt;/code&gt;：最大高度&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;min-height&lt;/code&gt;：最小高度&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;min-width&lt;/code&gt;：最小宽度&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;边框属性border&quot;&gt;2.边框属性（border）&lt;/h4&gt;
&lt;p&gt;官方文档：&lt;a href=&quot;http://www.w3school.com.cn/cssref/index.asp#border&quot; class=&quot;uri&quot;&gt;http://www.w3school.com.cn/cssref/index.asp#border&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;border&lt;/code&gt;&lt;/strong&gt;：2~4汇总
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;参考顺序：&lt;code&gt;border:width style color;&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;eg：&lt;code&gt;border:10px solid red;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;border-width&lt;/code&gt;：设置四条边框的宽度&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;border-style&lt;/code&gt;：设置四条边框的样式&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;solid&lt;/code&gt;：实线、&lt;code&gt;dashed&lt;/code&gt;：虚线、&lt;code&gt;dotted&lt;/code&gt;：点线&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;border-color&lt;/code&gt;：设置四条边框的颜色&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;PS：&lt;strong&gt;指定边框样式：&lt;code&gt;border-[top|left|right|bottom]:width style color;&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;eg：&lt;code&gt;border-top: #00c1de .2rem solid;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;浮动溢出定位floatoverflowposition&quot;&gt;3.浮动、溢出、定位（float、overflow、position）&lt;/h4&gt;
&lt;p&gt;官方文档：&lt;a href=&quot;http://www.w3school.com.cn/cssref/index.asp#positioning&quot; class=&quot;uri&quot;&gt;http://www.w3school.com.cn/cssref/index.asp#positioning&lt;/a&gt;&lt;/p&gt;
&lt;h5 id=&quot;浮动&quot;&gt;3.1.浮动&lt;/h5&gt;
&lt;p&gt;浮动本身没什么知识点，清除浮动倒是可以说下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;float: none;&lt;/code&gt;：不浮动(默认值)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;float: left;&lt;/code&gt;：左浮动&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;float: right;&lt;/code&gt;：右浮动&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;clear: both;&lt;/code&gt;&lt;/strong&gt;：清除所有浮动
&lt;ul&gt;&lt;li&gt;PS：可选择：&lt;code&gt;[left | right | both |none]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;以前清除浮动都是在浮动div下添加一个div.clear的空白div，现在基本上都是用&lt;code&gt;淘宝的伪元素大法&lt;/code&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;PS：有利于SEO&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;/* 清除浮动的样式 */
.clearfix::before,
.clearfix::after {
  content: '';
  display: table;
}

.clearfix::after {
  clear: both;
}

/* 兼容IE */
.clearfix {
  zoom: 1;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;溢出&quot;&gt;3.2.溢出&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;overflow：元素溢出&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;visible：超出box也继续显示(默认值)&lt;/li&gt;
&lt;li&gt;hidden：多余内容不可见
&lt;/li&gt;
&lt;li&gt;scroll：内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。&lt;/li&gt;
&lt;li&gt;auto：显示滚动条&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;PS：如果只只对一个方向可以使用&lt;code&gt;overflow-x&lt;/code&gt; | &lt;code&gt;overflow-y&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;eg：移动端主体内容部分：&lt;code&gt;main{position:absolute;left:0;right:0;top:2.5rem;bottom:2.5rem;overflow-x:hidden;overflow-y:auto;}&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;定位&quot;&gt;3.3.定位&lt;/h5&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;position&lt;/code&gt;：定位&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;absolute&lt;/code&gt;：绝对定位&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;fixed&lt;/code&gt;：固定定位&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;relative&lt;/code&gt;：相对定位&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;static&lt;/code&gt;：没有定位(默认值)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;偏移（配合&lt;code&gt;position&lt;/code&gt;使用）
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;top&lt;/code&gt;&lt;/strong&gt;：距离上方的距离&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;left&lt;/code&gt;&lt;/strong&gt;：距离左方的距离&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;right&lt;/code&gt;&lt;/strong&gt;：距离右方的距离&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;bottom&lt;/code&gt;&lt;/strong&gt;：距离下方的距离&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;层级：&lt;code&gt;z-index&lt;/code&gt;
&lt;ul&gt;&lt;li&gt;默认为0，可以为负值&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;PS：绝对定位和固定定位的块元素和行内元素会自动转化为&lt;code&gt;行内块&lt;/code&gt;元素&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201904/1127869-20190422112945373-1922260529.jpg&quot; alt=&quot;1.叠放顺序.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;来个经常使用的案例：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;定位案例&amp;lt;/title&amp;gt;
    &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;https://at.alicdn.com/t/font_1148101_h5fe3ssorlk.css&quot;&amp;gt;
    &amp;lt;style&amp;gt;
        header {
            width: 100px;
            margin: 0 auto;
            text-align: center;
        }
        /* 字体图标 */
        header a.icon-guoxue {
            /* 去除下划线 */
            text-decoration: none;
            color: #1a8236;
            font-size: 100px;
            /* 父类元素设置相对|绝对定位 */
            position: relative;
        }
        header span {
            position: absolute;
            top: 15px;
            right: -5px;
            /* 绝对定位和固定定位的块元素和行内元素会自动转化为行内块元素 */
            width: 30px;
            height: 30px;
            font-size: 16px;
            /* 居中显示 */
            line-height: 30px;
            color: white;
            background-color: red;
            /* 变成圆 */
            border-radius: 50%;
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;!-- a.iconfont.icon-guoxue&amp;gt;span{99} --&amp;gt;
    &amp;lt;header&amp;gt;
        &amp;lt;a href=&quot;#&quot; class=&quot;iconfont icon-guoxue&quot;&amp;gt;&amp;lt;span&amp;gt;99&amp;lt;/span&amp;gt;&amp;lt;/a&amp;gt;
    &amp;lt;/header&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201904/1127869-20190422115433315-1557629708.png&quot; alt=&quot;2.定位案例.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;内外边距marginpadding&quot;&gt;4.内外边距（margin、padding）&lt;/h4&gt;
&lt;p&gt;官方文档：&lt;a href=&quot;http://www.w3school.com.cn/cssref/index.asp#padding&quot; class=&quot;uri&quot;&gt;http://www.w3school.com.cn/cssref/index.asp#padding&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;padding&lt;/code&gt;：汇总属性&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;参考顺序：&lt;code&gt;padding：上 右 下 左;&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;PS：&lt;strong&gt;三个值：&lt;code&gt;padding: 上 左右 下;&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;padding-bottom&lt;/code&gt;：设置元素的下内边距&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;padding-left&lt;/code&gt;：设置元素的左内边距&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;padding-right&lt;/code&gt;：设置元素的右内边距&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;padding-top&lt;/code&gt;：设置元素的上内边距&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;官方文档：&lt;a href=&quot;http://www.w3school.com.cn/cssref/index.asp#margin&quot; class=&quot;uri&quot;&gt;http://www.w3school.com.cn/cssref/index.asp#margin&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;margin&lt;/code&gt;：汇总属性&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;eg：水平居中：&lt;code&gt;margin:x auto;&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;参考顺序：&lt;code&gt;margin：上 右 下 左;&lt;/code&gt;&lt;/strong&gt;、&lt;strong&gt;三个值：&lt;code&gt;margin: 上 左右 下;&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;margin-bottom&lt;/code&gt;：设置元素的下外边距&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;margin-left&lt;/code&gt;：设置元素的左外边距&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;margin-right&lt;/code&gt;：设置元素的右外边距&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;margin-top&lt;/code&gt;：设置元素的上外边距&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;PS：有时候有&lt;code&gt;margin-top&lt;/code&gt;塌陷和&lt;code&gt;外边距合并&lt;/code&gt;的问题，so ==&amp;gt; 尽量用&lt;code&gt;padding&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;重现：在两个盒子嵌套时候，内部的盒子设置的margin-top会加到外边的盒子上，导致内部的盒子margin-top设置失败&lt;br/&gt;解决：外部盒子设置一个边框，并且在外部盒子里设置&lt;code&gt;overflow:hidden&lt;/code&gt;，最后使用伪元素&lt;code&gt;.clearfix:before{content: '';display:table;}&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;扩展与补充&quot;&gt;2.1.4.扩展与补充&lt;/h3&gt;
&lt;h4 id=&quot;块元素内联元素内联块元素&quot;&gt;1.块元素、内联元素、内联块元素&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;块元素：支持所有样式&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;PS：如果没有设置宽度，默认的宽度为父级宽度100%（不管设不设宽度，都独占一行）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内联元素：不支持&lt;code&gt;width&lt;/code&gt;、&lt;code&gt;height&lt;/code&gt;、&lt;code&gt;margin&lt;/code&gt;和&lt;code&gt;padding&lt;/code&gt;&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;子元素是内联元素，则父元素可用text-align属性设置子元素水平对齐方式&lt;/li&gt;
&lt;li&gt;小问题：代码换行，盒子之间会产生间距&lt;/li&gt;
&lt;li&gt;PS：宽高由内容决定，自己设置是不生效的&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内联块(行内块)：支持所有样式&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;子元素是内联元素，则父元素可用text-align属性设置子元素水平对齐方式&lt;/li&gt;
&lt;li&gt;小问题：代码换行，盒子之间会产生间距&lt;/li&gt;
&lt;li&gt;PS：如果没有设置宽高，宽高由内容决定&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;用代码表示一下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;display:inline&lt;/code&gt;：内联元素(默认)
&lt;ul&gt;&lt;li&gt;元素前后没有换行符&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;display:block&lt;/code&gt;：块级元素
&lt;ul&gt;&lt;li&gt;元素前后会带有换行符&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;display:inline-block&lt;/code&gt;：行内块元素&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;隐藏：&lt;code&gt;display:none&lt;/code&gt;此元素不会显示也不占空间，&lt;code&gt;visibility:hidden;&lt;/code&gt;元素是否可见且占空间&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;PS：加过渡动画的时候，visibility有动画效果，而display没有&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;内联元素或内联块元素间隙的解决方案&quot;&gt;2.内联元素或内联块元素间隙的解决方案&lt;/h4&gt;
&lt;p&gt;以前是只要不去换行就没事了（去掉内联元素之间的换行），现在get到一个新skill：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;将内联元素的父级设置font-size为0，内联元素自身再设置font-size&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;其他属性&quot;&gt;3.其他属性&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;鼠标显示为手：&lt;code&gt;cursor:pointer;&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;文字不换行：&lt;code&gt;white-space: nowrap;&lt;/code&gt;&lt;/strong&gt;（&lt;code&gt;normal&lt;/code&gt;是默认值）
&lt;/li&gt;
&lt;li&gt;设置表格的边框合并：&lt;code&gt;border-collapse:collapse;&lt;/code&gt;（现在基本上用不到了）&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;&lt;h2 id=&quot;选择器系&quot;&gt;2.2.选择器系&lt;/h2&gt;
&lt;h3 id=&quot;常用选择器&quot;&gt;2.2.1.常用选择器&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;选择器参考手册&lt;/strong&gt;：&lt;a href=&quot;http://www.w3school.com.cn/cssref/css_selectors.asp&quot; class=&quot;uri&quot;&gt;http://www.w3school.com.cn/cssref/css_selectors.asp&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;标签选择器
&lt;ul&gt;&lt;li&gt;eg：&lt;code&gt;p{color:red;}&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ID选择器
&lt;ul&gt;&lt;li&gt;eg：&lt;code&gt;#footer{color:#a7a8a9;}&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;类选择器
&lt;ul&gt;&lt;li&gt;eg：&lt;code&gt;.copyright {text-align: center;}&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;层级选择器&lt;/strong&gt;：父元素下的子元素（&lt;code&gt;空格间隔&lt;/code&gt;）
&lt;ul&gt;&lt;li&gt;eg：&lt;code&gt;.copyright a{color: #a7a8a9;}&lt;/code&gt;：设置copyright类下的a标签颜色&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;组选择器&lt;/strong&gt;：同时生效（逗号间隔）
&lt;ul&gt;&lt;li&gt;eg：&lt;code&gt;em,i {font-style: normal;}&lt;/code&gt;：去除em和i的斜体样式&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;伪类|伪元素&lt;/code&gt;选择器&lt;/strong&gt;：两个:就是伪元素
&lt;ul&gt;&lt;li&gt;eg：伪类：&lt;code&gt;nav li:hover {color: #000;}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;eg：伪元素：&lt;code&gt;.clearfix::after {content:'';display:table;clear:both;}&lt;/code&gt;：清除浮动&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;扩展伪类与伪元素&quot;&gt;扩展：伪类与伪元素&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;:伪类&lt;/code&gt;（一种选择器）eg:&lt;code&gt;:hover&lt;/code&gt;、&lt;code&gt;a:active&lt;/code&gt;、&lt;code&gt;a:visited&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;::伪元素&lt;/code&gt;（通过CSS实现的页面元素）eg：&lt;code&gt;::before&lt;/code&gt;、&lt;code&gt;::after&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;/* 常用伪类 */
a:link {color: #FF0000}     /* 未访问的链接 */
a:visited {color: #00FF00}  /* 已访问的链接 */
a:hover {color: #FF00FF}    /* 鼠标移动到链接上 */
a:active {color: #0000FF}   /* 选定的链接 */&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;c3新增系&quot;&gt;2.2.2.C3新增系&lt;/h3&gt;
&lt;h4 id=&quot;属性选择器&quot;&gt;1.属性选择器&lt;/h4&gt;
&lt;p&gt;参考文档：&lt;a href=&quot;http://www.w3school.com.cn/css/css_syntax_attribute_selector.asp&quot; class=&quot;uri&quot;&gt;http://www.w3school.com.cn/css/css_syntax_attribute_selector.asp&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;以前就有的：&lt;strong&gt;&lt;code&gt;表单&lt;/code&gt;用的比较多些&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;[属性名] {}&lt;/code&gt;&lt;/strong&gt;：匹配对应的属性即可&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;[属性名=值] {}&lt;/code&gt;&lt;/strong&gt;：匹配属性名是某值&lt;/li&gt;
&lt;li&gt;几乎不用：&lt;code&gt;[属性名|=值]&lt;/code&gt;（属性名以某值开头）和&lt;code&gt;[属性名~=值]&lt;/code&gt;（属性名包含某值）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;CSS3新增：&lt;strong&gt;结合&lt;code&gt;爬虫&lt;/code&gt;有大用&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;[属性名^=值] {}&lt;/code&gt;&lt;/strong&gt;：以值开头
&lt;ul&gt;&lt;li&gt;eg：&lt;code&gt;a[src^=&quot;https&quot;]&lt;/code&gt;：选择src属性以&lt;code&gt;https&lt;/code&gt;开头的每个&lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;元素&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[属性名$=值] {}&lt;/code&gt;：以值结束
&lt;ul&gt;&lt;li&gt;eg：&lt;code&gt;a[src$=&quot;.pdf&quot;]&lt;/code&gt;：选择src属性以&lt;code&gt;.pdf&lt;/code&gt;结尾的所有&lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;元素&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[属性名*=值] {}&lt;/code&gt;：包含某值
&lt;ul&gt;&lt;li&gt;eg：&lt;code&gt;a[src*=&quot;baidu.com&quot;]&lt;/code&gt;：选择src属性包含&lt;code&gt;baidu.com&lt;/code&gt;子串的每个&lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;元素&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;来个简单案例：&lt;/p&gt;
&lt;pre class=&quot;html5&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;属性选择器&amp;lt;/title&amp;gt;
    &amp;lt;style&amp;gt;
        input[type=&quot;password&quot;] {
            background-color: yellow;
        }
        // name以user开头的表单（eg：用户相关字段）
        input[name^=&quot;user&quot;] {
            background-color: green;
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;input type=&quot;hidden&quot; name=&quot;id&quot;&amp;gt;&amp;lt;br/&amp;gt;
    &amp;lt;input type=&quot;text&quot; name=&quot;user_name&quot;&amp;gt;&amp;lt;br/&amp;gt;
    &amp;lt;input type=&quot;text&quot; name=&quot;user_age&quot;&amp;gt;&amp;lt;br/&amp;gt;
    &amp;lt;input type=&quot;password&quot; name=&quot;pass&quot;&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201904/1127869-20190423202946071-774296694.png&quot; alt=&quot;3.属性选择器.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;结构性伪类选择器&quot;&gt;2.结构性伪类选择器&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;结构性伪类选择器：&lt;code&gt;n&lt;/code&gt;可以是&lt;code&gt;数值&lt;/code&gt;也可以是&lt;code&gt;表达式&lt;/code&gt;&lt;/strong&gt;(eg：&lt;code&gt;2n+1&lt;/code&gt;)&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;:nth-child(n) {}&lt;/code&gt;&lt;/strong&gt;：选中父元素中正数第n个子元素
&lt;ul&gt;&lt;li&gt;最特殊：&lt;strong&gt;&lt;code&gt;:first-child {}&lt;/code&gt;：选中父元素中第一个子元素&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:nth-last-child(n) {}&lt;/code&gt;：选中父元素中倒数第n个子元素
&lt;ul&gt;&lt;li&gt;最特殊：&lt;strong&gt;&lt;code&gt;:last-child {}&lt;/code&gt;：选中父元素中最后一个子元素&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;:nth-of-type(n){}&lt;/code&gt;&lt;/strong&gt;：选中父元素中&lt;code&gt;特定&lt;/code&gt;正数第n个子元素
&lt;ul&gt;&lt;li&gt;PS：和上面的区别等会看个案例&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:nth-last-child(n) {}&lt;/code&gt;：选中父元素&lt;code&gt;特定&lt;/code&gt;元素中倒数第n个子元素&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这个看一个必须来个案例：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;结构性伪类选择器&amp;lt;/title&amp;gt;
    &amp;lt;style&amp;gt;
        /* 本意先找到bloginfo类下的第一个div，对它第二个span设置样式 */

        /* 浏览器会这么找：先去bloginfo类下的第一个div中找第二个元素，然后看看是不是span，如果是则生效 */
        /* PS：这边父类下第二个元素不是span，所以不生效 */
        .bloginfo div:first-child span:nth-child(2) {
            color: red;
        }

        /* 如果需要达到这个效果可以这么用： */
        .bloginfo div:first-child span:nth-child(4) {
            color: red;
        }

        /* 本意先找到bloginfo类下的第二个div，对它第二个span设置样式 */

        /* 浏览器会这么找：先去bloginfo类下的第二个div中找所有的span，然后给第二个span设置样式 */
        .bloginfo div:last-child span:nth-of-type(2) {
            color: green;
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div class=&quot;bloginfo&quot;&amp;gt;
        &amp;lt;div&amp;gt;
            &amp;lt;span&amp;gt;逆天&amp;lt;/span&amp;gt;
            &amp;lt;i&amp;gt;this is test&amp;lt;/i&amp;gt;
            &amp;lt;time&amp;gt;2019-04-14&amp;lt;/time&amp;gt;
            &amp;lt;span&amp;gt;【Web】&amp;lt;/span&amp;gt;
        &amp;lt;/div&amp;gt;
        &amp;lt;!-- 和上面一样 --&amp;gt;
        &amp;lt;div&amp;gt;
            &amp;lt;span&amp;gt;逆天&amp;lt;/span&amp;gt;
            &amp;lt;i&amp;gt;this is test&amp;lt;/i&amp;gt;
            &amp;lt;time&amp;gt;2019-04-14&amp;lt;/time&amp;gt;
            &amp;lt;span&amp;gt;【Web】&amp;lt;/span&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出图示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201904/1127869-20190423211155768-1777776621.png&quot; alt=&quot;4.结构性伪类选择器.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;其他选择器&quot;&gt;3.其他选择器&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;:target&lt;/code&gt;：被锚链接指向的时候会触发该选择器&lt;/li&gt;
&lt;li&gt;&lt;code&gt;::selection&lt;/code&gt;：当被鼠标选中的时候的样式&lt;/li&gt;
&lt;li&gt;&lt;code&gt;::first-line&lt;/code&gt;：选中第一行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;::first-letter&lt;/code&gt;：选中第一个字符&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;css权重推荐&quot;&gt;2.2.3.CSS权重（推荐）&lt;/h3&gt;
&lt;p&gt;这个官方文档我倒是没找到，但是流传比较多的是这么个顺序（已验）&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;!important&lt;/code&gt;（&lt;strong&gt;权重值：&lt;code&gt;10000&lt;/code&gt;&lt;/strong&gt;）加在样式属性值后
&lt;ul&gt;&lt;li&gt;eg：&lt;code&gt;display: block!important;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;内联&lt;/code&gt;样式（&lt;strong&gt;权重值：&lt;code&gt;1000&lt;/code&gt;&lt;/strong&gt;）
&lt;ul&gt;&lt;li&gt;eg：&lt;code&gt;style=&quot;xx&quot;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ID&lt;/code&gt;选择器（&lt;strong&gt;权重值：&lt;code&gt;100&lt;/code&gt;&lt;/strong&gt;）
&lt;ul&gt;&lt;li&gt;eg：&lt;code&gt;#content{xx}&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;类&lt;/code&gt;，&lt;code&gt;伪类&lt;/code&gt;和&lt;code&gt;属性&lt;/code&gt;选择器（&lt;strong&gt;权重值：&lt;code&gt;10&lt;/code&gt;&lt;/strong&gt;）
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;标签&lt;/code&gt;选择器和&lt;code&gt;伪元素&lt;/code&gt;选择器（权重值：1）
&lt;ul&gt;&lt;li&gt;eg：&lt;code&gt;div&lt;/code&gt;、&lt;code&gt;p&lt;/code&gt;、&lt;code&gt;:before&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;通用&lt;/code&gt;选择器（*）、&lt;code&gt;子&lt;/code&gt;选择器（&amp;gt;）、&lt;code&gt;相邻&lt;/code&gt;选择器（+）、&lt;code&gt;同胞&lt;/code&gt;选择器（~）的（&lt;strong&gt;权重值：0&lt;/strong&gt;）
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;PS：这个平时用不到，但是对于修改模版样式不生效的时候经常会用到&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;你有没有发现有些样式修改了并不生效？这时候CSS权重的重要性就来了&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;新增属性&quot;&gt;2.3.新增属性&lt;/h2&gt;
&lt;h3 id=&quot;背景&quot;&gt;2.3.1.背景&lt;/h3&gt;
&lt;h4 id=&quot;透明背景&quot;&gt;1.透明背景&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;opacity&lt;/code&gt;&lt;/strong&gt;：设置元素整体透明度&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;rgba&lt;/code&gt;&lt;/strong&gt;：设置带透明色的颜色
&lt;ul&gt;&lt;li&gt;PS：rgba是只设置背景色透明&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;来个区分案例：&lt;/p&gt;
&lt;pre class=&quot;html5&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;透明背景&amp;lt;/title&amp;gt;
    &amp;lt;style&amp;gt;
        div {
            width: 200px;
            height: 100px;
            color: green;
            border: 1px solid black;
        }

        div:nth-child(1) {
            background-color: black;
            /* 设置整个div的透明色 */
            opacity: 0.2;
        }

        div:nth-child(2) {
            /* 只设置背景色的透明度 */
            background-color: rgba(0, 0, 0, 0.2);
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div&amp;gt;
        &amp;lt;h2&amp;gt;我是一个测试文字&amp;lt;/h2&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;div&amp;gt;
        &amp;lt;h2&amp;gt;我是一个测试文字&amp;lt;/h2&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201904/1127869-20190423221933230-322467832.png&quot; alt=&quot;5.透明背景.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;背景尺寸&quot;&gt;2.背景尺寸&lt;/h4&gt;
&lt;p&gt;官方案例：&lt;a href=&quot;http://www.w3school.com.cn/tiy/c.asp?f=css_background-size&quot; class=&quot;uri&quot;&gt;http://www.w3school.com.cn/tiy/c.asp?f=css_background-size&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;background-size&lt;/code&gt;：规定背景图片的尺寸&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;background-size:30% 40%;&lt;/code&gt;&lt;/strong&gt;：可以是数值或百分比
&lt;ul&gt;&lt;li&gt;PS：先宽后高&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;contain&lt;/code&gt;&lt;/strong&gt;：等比缩放，直至宽或者高和盒子相同
&lt;ul&gt;&lt;li&gt;PS：盒子有空闲空间&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cover&lt;/code&gt;：等比缩放，并填充慢容器
&lt;ul&gt;&lt;li&gt;PS：图像可能显示不完整&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;看个案例：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;背景尺寸&amp;lt;/title&amp;gt;
    &amp;lt;style&amp;gt;
        div {
            width: 100px;
            height: 100px;
            background: url(http://github.lesschina.com/html5/images/logo.gif) no-repeat;
            border: 1px solid black;
        }

        div:nth-child(1) {
            /* 宽 高 */
            background-size: 100% 50%;
        }

        div:nth-child(2) {
            /* 等比缩放，直至宽或者高和盒子相同 */
            background-size: contain;
        }

        div:nth-child(3) {
            /* 等比缩放，并填充慢容器 */
            background-size: cover;
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201904/1127869-20190423215457198-1191472512.png&quot; alt=&quot;5.背景图尺寸.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;双背景&quot;&gt;3.双背景&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;CSS3可以设置两个背景图：&lt;code&gt;background-image:url(xxx),url(xxx);&lt;/code&gt;&lt;/strong&gt;（叠加显示）&lt;/p&gt;
&lt;p&gt;看个案例：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;两个背景图&amp;lt;/title&amp;gt;
    &amp;lt;style&amp;gt;
        div {
            width: 260px;
            height: 462px;
            /* 三句合为一句写 */
            background: url(https://github.lesschina.com/html5/images/logo.gif) no-repeat center center, url(https://github.lesschina.com/html5/images/banner/b02.jpg) no-repeat center;
            /* background-image: url(https://github.lesschina.com/html5/images/logo.gif), url(https://github.lesschina.com/html5/images/banner/b02.jpg); */
            /* background-repeat: no-repeat; */
            /* 垂直居中 + 水平居中 */
            /* background-position: center center; */
            border: 1px solid black;
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201904/1127869-20190423223229627-732880597.png&quot; alt=&quot;6.双背景.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;不常用&quot;&gt;3.不常用&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;background-origin&lt;/code&gt;：设置背景图片的定位区域：
&lt;ul&gt;&lt;li&gt;&lt;code&gt;padding-box&lt;/code&gt;：以内边距(&lt;code&gt;padding&lt;/code&gt;)左上角为起点进行定位（默认值）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;border-box&lt;/code&gt;：以边框(&lt;code&gt;border&lt;/code&gt;)左上角为起点进行定位&lt;/li&gt;
&lt;li&gt;&lt;code&gt;content-box&lt;/code&gt;：以内容区域(&lt;code&gt;content&lt;/code&gt;)左上角为起点&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;background-clip&lt;/code&gt;：规定背景的绘制区域
&lt;ul&gt;&lt;li&gt;&lt;code&gt;border-box&lt;/code&gt;：背景图片在整个容器中显示&lt;/li&gt;
&lt;li&gt;&lt;code&gt;padding-box&lt;/code&gt;：背景图片在内边距+正文区域显示&lt;/li&gt;
&lt;li&gt;&lt;code&gt;content-box&lt;/code&gt;：背景图片只在正文区域显示&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;边框&quot;&gt;2.3.2.边框&lt;/h3&gt;
&lt;h4 id=&quot;知识点&quot;&gt;知识点&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;border-radius&lt;/code&gt;：边框圆角&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;border-image&lt;/code&gt;：边框图片&lt;/strong&gt;（eg：&lt;code&gt;border-image:url(border.png) 20 round;&lt;/code&gt;）
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;设置边框图片：&lt;code&gt;border-image-source: url(&quot;xx&quot;);&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;边框图片裁切：&lt;code&gt;border-image-slice: 数值;&lt;/code&gt;&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;PS：&lt;code&gt;不需要带单位&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;border-image-repeat&lt;/code&gt;: 设置边框图片的平铺方式（如何重复图像边框）
&lt;ul&gt;&lt;li&gt;&lt;code&gt;stretch&lt;/code&gt;：拉伸（默认）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;round&lt;/code&gt;：环绕的方式重复显示&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;repeat&lt;/code&gt;：重复显示
&lt;ul&gt;&lt;li&gt;一般都使用round，repeat的方式很多时候都有点小问题&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;图像边框宽度：&lt;code&gt;border-image-width: 数值;&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;box-shadow: 水平阴影的位置 垂直阴影的位置 [模糊距离] [阴影的尺寸] [阴影的颜色] [内|外阴影];&lt;/code&gt;&lt;/strong&gt;
&lt;/li&gt;
&lt;li&gt;颜色渐变：&lt;strong&gt;这个和PS里面的颜色渐变一样&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;线性渐变：&lt;code&gt;linear-gradient&lt;/code&gt;&lt;/strong&gt;
&lt;/li&gt;
&lt;li&gt;径向渐变：&lt;code&gt;radial-gradient&lt;/code&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PS：渐变其实是一种图片，一般都是设置&lt;code&gt;background-image&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;圆角与渐变&quot;&gt;1.圆角与渐变&lt;/h4&gt;
&lt;p&gt;这个比较简单，简单说下常用的两种即可：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, user-scalable=no&quot;&amp;gt;
    &amp;lt;title&amp;gt;圆角案例&amp;lt;/title&amp;gt;
    &amp;lt;style&amp;gt;
        /* 椭圆矩形 */
        div:first-child {
            width: 200px;
            height: 200px;
            background: black;
            border-radius: 10px;
        }
        /* 设置图片大小，并显示为圆 */
        div img {
            /* 半径是长度的50%==&amp;gt;圆 */
            border-radius: 50%;
            width: 200px;
            height: 200px;
        }
        div:last-child i {
            display: block;
            width: 200px;
            height: 200px;
            padding: 5px;
            border-radius: 50%;
            /* 设置一个渐变色 */
            background: linear-gradient(to top right, rgba(0, 153, 255, .9), rgba(42, 228, 197, .7));
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;br /&amp;gt;
    &amp;lt;div&amp;gt;&amp;lt;img src=&quot;https://github.lesschina.com/html5/images/avatar.jpg&quot;&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;br /&amp;gt;
    &amp;lt;div&amp;gt;&amp;lt;i&amp;gt;&amp;lt;img src=&quot;https://github.lesschina.com/html5/images/avatar.jpg&quot;&amp;gt;&amp;lt;/i&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;

&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;图示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201904/1127869-20190424154245371-690073375.png&quot; alt=&quot;8.圆边.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;中国风边框图片案例&quot;&gt;2.中国风边框图片案例&lt;/h4&gt;
&lt;p&gt;我先用PS来简单扩充一下裁切的概念：（&lt;strong&gt;类比Padding和margin的设置方法，然后不算单位&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201904/1127869-20190424152152070-1438830928.jpg&quot; alt=&quot;7.边框裁剪示意图.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看个简单案例：（平时设置网站风格的时候用的比较多，以前是设置背景图片，现在省事也省带宽了）&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, user-scalable=no&quot;&amp;gt;
    &amp;lt;title&amp;gt;边框图片&amp;lt;/title&amp;gt;
    &amp;lt;style&amp;gt;
        div {
            width: 300px;
            height: 300px;
            border: 50px solid black;
            font-family: '钟齐流江毛笔草体';
            font-size: 30px;
            line-height: 300px;
            /* 竖排显示(从左往右方向) */
            writing-mode: vertical-lr;
            text-align: center;
            float: left;
        }
        div:nth-child(2) {
            /* 设置边框图片 */
            border-image-source: url(../images/1.png);
        }
        div:nth-child(3) {
            border-image: url(../images/1.png) 54 80 62 68;
            /* border-image-source: url(../images/1.png); */
            /* 设置边框图片的裁切 */
            /* border-image-slice: 54 80 62 68; */
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div&amp;gt;微信公众号 逸鹏说道&amp;lt;/div&amp;gt;
    &amp;lt;div&amp;gt;微信公众号 逸鹏说道&amp;lt;/div&amp;gt;
    &amp;lt;div&amp;gt;微信公众号 逸鹏说道&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;图示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201904/1127869-20190424151943374-736850332.jpg&quot; alt=&quot;7.边框图片demo.jpg&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;边框图片平铺方式&quot;&gt;3.边框图片平铺方式&lt;/h4&gt;
&lt;p&gt;平铺方式简单说下：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, user-scalable=no&quot;&amp;gt;
    &amp;lt;title&amp;gt;边框图片2&amp;lt;/title&amp;gt;
    &amp;lt;style&amp;gt;
        div {
            width: 250px;
            height: 250px;
            margin-right: 20px;
            border: 50px solid black;
            font-size: 25px;
            line-height: 300px;
            /* 竖排显示(从左往右方向) */
            writing-mode: vertical-lr;
            text-align: center;
            float: left;
        }
        div:first-child {
            border-image: url(../images/2.png);
        }
        div:nth-child(2) {
            /* 裁切20就可以把四个角的爱心完美扣下了 */
            border-image: url(../images/2.png) 20;
        }
        div:nth-child(3) {
            /* 设置边框图片的平铺方式 */
            border-image: url(../images/2.png) 20 repeat;
        }
        div:last-child {
            /* 推荐方式 */
            border-image: url(../images/2.png) 20 round;
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div&amp;gt;只设置了边框图片&amp;lt;/div&amp;gt;
    &amp;lt;div&amp;gt;设置边框图片和裁切&amp;lt;/div&amp;gt;
    &amp;lt;div&amp;gt;边框平铺方式为重复&amp;lt;/div&amp;gt;
    &amp;lt;div&amp;gt;边框平铺方式为环绕&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;图示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201904/1127869-20190424151552546-2019879021.png&quot; alt=&quot;7.边框图片重复.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;课后拓展：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000010969367&quot; target=&quot;_blank&quot;&gt;CSS3 border-image 彻底明白&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;过渡重点&quot;&gt;2.3.3.过渡（重点）&lt;/h3&gt;
&lt;h4 id=&quot;知识点-1&quot;&gt;1.知识点&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;我的理解：如果一个元素设置了&lt;code&gt;transition&lt;/code&gt;，那么它属性改变的时候就会呈现出动画状态&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;transition: property duration timing-function delay&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;transition-property&lt;/code&gt;：设置过渡的属性
&lt;ul&gt;&lt;li&gt;eg：width height background-color&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;transition-duration&lt;/code&gt;：设置过渡的时间
&lt;ul&gt;&lt;li&gt;eg：1s 500ms&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;transition-timing-function&lt;/code&gt;：设置过渡的运动方式
&lt;ul&gt;&lt;li&gt;常用：&lt;code&gt;linear&lt;/code&gt;(匀速). &lt;code&gt;ease&lt;/code&gt;(缓冲运动)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;transition-delay&lt;/code&gt;：设置动画的延迟
&lt;ul&gt;&lt;li&gt;PS：一般用不到&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;PS：一般都这么用：&lt;code&gt;transition: all 500ms ease;&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;简单案例&quot;&gt;2.简单案例&lt;/h4&gt;
&lt;p&gt;看个例子：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, user-scalable=no&quot;&amp;gt;
    &amp;lt;title&amp;gt;过渡动画&amp;lt;/title&amp;gt;
    &amp;lt;style&amp;gt;
        div {
            width: 300px;
            height: 300px;
            margin: 0 auto;
            background-color: black;
            /* 设置了transition，那div任何属性的改动都会有过渡动画 */
            transition: all 1s ease;
        }

        div:hover {
            background-color: yellow;
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;图示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201904/1127869-20190424161615278-2046256157.gif&quot; alt=&quot;9.过渡动画.gif&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;特殊案例&quot;&gt;4.特殊案例&lt;/h4&gt;
&lt;p&gt;只有一个属性是没有过渡动画的：&lt;strong&gt;&lt;code&gt;display:none&lt;/code&gt; ==》 &lt;code&gt;display:block&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;看个区分案例：&lt;/p&gt;
&lt;pre class=&quot;hmtl&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, user-scalable=no&quot;&amp;gt;
    &amp;lt;title&amp;gt;特殊案例&amp;lt;/title&amp;gt;
    &amp;lt;style&amp;gt;
        div {
            width: 300px;
            height: 300px;
            margin: 0 auto;
            background-color: black;
            /* 设置了transition，那div任何属性的改动都会有过渡动画 */
            transition: all 500ms ease;
        }
        /* 第一个盒子使用visibility的方式显示和隐藏 */
        div:first-child {
            visibility: hidden;
        }
        body:hover div:first-child {
            visibility: visible;
            background-color: yellow;
        }
        /* 第二个盒子使用display的方式显示和隐藏 */
        div:last-child {
            display: none;
        }
        body:hover div:last-child {
            display: block;
            background-color: yellow;
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div&amp;gt;visibility&amp;lt;/div&amp;gt;
    &amp;lt;div&amp;gt;display&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;图示：(&lt;strong&gt;&lt;code&gt;visibility&lt;/code&gt;和&lt;code&gt;display&lt;/code&gt;的区别不用说了吧？无非是一个占空间一个不占&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201904/1127869-20190424163048884-2002767866.gif&quot; alt=&quot;9.隐藏和显示.gif&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;transform转换&quot;&gt;2.3.4.transform转换&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;经验：如果多个变换一起用的，那么顺序为：&lt;/strong&gt;&lt;code&gt;从后往前执行&lt;/code&gt;**&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;transform&lt;/code&gt;一定要加初始值**（不然在边角的时候有小问题）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;d转换&quot;&gt;1.2D转换&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;位移&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;transform: translate(x轴,y轴);&lt;/code&gt;&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;eg：&lt;code&gt;transform: translate(100px,100px);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;PS：相对自身位置发生的位置改变&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缩放&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;transform: scale(x,y);&lt;/code&gt;&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;eg：&lt;code&gt;transform: scale(0.5,1);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;PS：倍数关系&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;旋转
&lt;ul&gt;&lt;li&gt;&lt;code&gt;transform: rotate(60deg);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;PS：&lt;code&gt;deg&lt;/code&gt;是角度&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;倾斜
&lt;ul&gt;&lt;li&gt;&lt;code&gt;transform: skew(x轴,y轴);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;eg：&lt;code&gt;transform: skew(30deg,30deg);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;看个案例：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, user-scalable=no&quot;&amp;gt;
    &amp;lt;title&amp;gt;2d变换&amp;lt;/title&amp;gt;
    &amp;lt;style&amp;gt;
        div {
            width: 200px;
            height: 200px;
            float: left;
            border: 1px solid black;
            background-color: yellow;
            /* 添加一个过渡动画 */
            transition: all 1s ease;
        }
        /* x轴平移50px，y轴平移100px */
        div:first-child:hover {
            background-color: green;
            /* 逗号别忘记了 */
            transform: translate(50px, 100px);
        }
        /* x轴放大1.1倍，y轴放大2倍 */
        div:nth-child(2):hover {
            transform: scale(1.1, 2)
        }
        /* 旋转90度 */
        div:last-child:hover {
            transform: rotate(90deg)
        }

    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;图示：（PS：&lt;strong&gt;CSS3样式都不会改变盒模型&lt;/strong&gt;，这个案例就可以看出了）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201904/1127869-20190424183034251-1984129591.gif&quot; alt=&quot;10.2d变换.gif&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;d转换-1&quot;&gt;2.3D转换&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;位移
&lt;ul&gt;&lt;li&gt;transform: translateX() translateY() translateZ()&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;缩放
&lt;ul&gt;&lt;li&gt;transform: scaleX(0.5) scaleY(1) scaleZ(1);&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;旋转
&lt;ul&gt;&lt;li&gt;transform: rotateX(60deg) rotateY(60deg) rotateZ(60deg);&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;倾斜
&lt;ul&gt;&lt;li&gt;transform: skewX(30deg) skewY(30deg);&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这两个是视觉更好体验的参数：（&lt;code&gt;推荐&lt;/code&gt;）&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;transform-style:preserve-3d&lt;/code&gt;&lt;/strong&gt;：允许子元素呈现3d视图&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;perspective&lt;/code&gt;：设置透视距离&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;eg：&lt;code&gt;transform: perspective(800px);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;PS：一般都是600px~1000px&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;其他参数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;tranform-origin&lt;/code&gt;：设置变形的中心点&lt;/li&gt;
&lt;li&gt;&lt;code&gt;backface-visibility&lt;/code&gt;：设置盒子背面是否可见&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;演示案例：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, user-scalable=no&quot;&amp;gt;
    &amp;lt;title&amp;gt;3d变换&amp;lt;/title&amp;gt;
    &amp;lt;style&amp;gt;
        .grandfather {
            width: 300px;
            height: 300px;
            margin: 300px auto;
            background-color: rgba(255, 0, 0, 0.3);
            /* 允许子元素呈现3d视图 */
            transform-style: preserve-3d;
        }
        .parent {
            width: 100%;
            height: 100%;
            background-color: rgba(0, 255, 0, 0.3);
            /* 设置初始值 */
            transform: perspective(0) translateZ(0);
            /* 允许子元素呈现3d视图 */
            transform-style: preserve-3d;
            /* 设置一个补间动画 */
            transition: all 1s ease;
        }
        .child {
            width: 100%;
            height: 50%;
            background-color: rgba(0, 255, 255, 0.3);
            /* 设置初始值 */
            transform: perspective(0) translateZ(0);
            /* 设置一个补间动画 */
            transition: all 1s ease;
        }
        .parent:hover {
            /* z轴移动200px（铺面而来） */
            transform: perspective(800px) translateZ(200px);
        }
        .child:hover {
            /* z轴移动200px（铺面而来） */
            transform: perspective(800px) translateZ(100px);
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div class=&quot;grandfather&quot;&amp;gt;
        &amp;lt;div class=&quot;parent&quot;&amp;gt;
            &amp;lt;div class=&quot;child&quot;&amp;gt;&amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;图示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201904/1127869-20190424193322625-1168312920.gif&quot; alt=&quot;10.3d变换&quot;/&gt;&lt;/p&gt;
&lt;p&gt;PS：更多复杂功能，如果感兴趣可以看看&lt;strong&gt;&lt;code&gt;WebGL&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;动画&quot;&gt;2.3.5.动画&lt;/h3&gt;
&lt;p&gt;animation基本上不太用，复杂的动画我一般使用：&lt;code&gt;Animate.css&lt;/code&gt;，简单的动画&lt;code&gt;transition&lt;/code&gt;+&lt;code&gt;transform&lt;/code&gt;就够了，如果是滚动动画之类的我一般用&lt;code&gt;scrollreveal.js&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;animation:动画名称 动画时间 动画曲线 延迟时间 播放次数 是否反向运动 动画停留在哪一帧;&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;eg：&lt;code&gt;animation: move_search 1s linear 0.5s forwards;&lt;/code&gt;(动画名称 动画时间 动画曲线 延迟时间 停留在最后一帧)&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;&lt;code&gt;@keyframes&lt;/code&gt;：定义关键帧动画&lt;/li&gt;
&lt;li&gt;&lt;code&gt;animation-name&lt;/code&gt;：动画名称&lt;/li&gt;
&lt;li&gt;&lt;code&gt;animation-duration&lt;/code&gt;：动画时间&lt;/li&gt;
&lt;li&gt;&lt;code&gt;animation-timing-function&lt;/code&gt;：动画曲线
&lt;ul&gt;&lt;li&gt;&lt;code&gt;linear&lt;/code&gt;(匀速)、&lt;code&gt;ease&lt;/code&gt;(缓冲)、&lt;code&gt;steps&lt;/code&gt;(做帧动画的&lt;code&gt;步数&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;animation-delay&lt;/code&gt;：动画延迟&lt;/li&gt;
&lt;li&gt;&lt;code&gt;animation-iteration-count&lt;/code&gt;：动画播放次数
&lt;ul&gt;&lt;li&gt;n(指定次数)、infinite(循环)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;animation-direction&lt;/code&gt;：动画结束后是否反向还原
&lt;ul&gt;&lt;li&gt;normal、alternate(反向)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;animation-play-state&lt;/code&gt;：动画状态
&lt;ul&gt;&lt;li&gt;paused(停止)、running(运动)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;animation-fill-mode&lt;/code&gt;：动画前后的状态
&lt;ul&gt;&lt;li&gt;none(缺省)、&lt;strong&gt;forwards&lt;/strong&gt;(结束时停留在最后一帧)&lt;/li&gt;
&lt;li&gt;backwards(开始时停留在定义的开始帧)、both(前后都应用)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;PS：如果设置动画集使用的是百分比，那么这个百分比是指相对整个动画的执行时间&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;简单看个案例就收工吧：&lt;/p&gt;
&lt;p&gt;这次先看效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201904/1127869-20190424205439231-1190448224.gif&quot; alt=&quot;11.动画.gif&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;

&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, user-scalable=no&quot;&amp;gt;
    &amp;lt;title&amp;gt;animate动画&amp;lt;/title&amp;gt;
    &amp;lt;style&amp;gt;
        body {
            width: 100%;
            height: 100%;
            background-color: rgb(22, 186, 157);
        }

        header {
            width: 50%;
            margin: 100px auto;
        }

        .search {
            height: 50px;
            border: 1px solid white;
            /* 水平阴影位置，垂直阴影位置，模糊距离，颜色 */
            box-shadow: 0px 0px 10px #fff;

            /* 为动画准备的相对定位 */
            position: relative;
            /* animation:动画名称 动画时间 动画曲线 停留在最后一帧 */
            animation: move_search 1s linear forwards;
        }

        /* 最简单的移动，也可以百分百来设置进度 */
        @keyframes move_search {
            from {
                left: -200%;
            }

            to {
                left: 0;
            }
        }

        .search div {
            color: white;
            padding-left: 10px;
            /* 为了居中 */
            line-height: 50px;

            /* 为了动画而设置 */
            width: 0;
            height: 50px;
            overflow: hidden;

            /* animation:动画名称 动画时间 8帧显示完 停留在最后一帧 延迟1s显示 */
            animation: show_font 1.5s steps(8) forwards 1s;
        }

        @keyframes show_font {
            0% {
                width: 0;
            }

            50% {
                width: 75px;
            }

            100% {
                width: 130px;
            }
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;
    &amp;lt;header&amp;gt;
        &amp;lt;div class=&quot;search&quot;&amp;gt;
            &amp;lt;div&amp;gt;公众号：逸鹏说道&amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/header&amp;gt;
&amp;lt;/body&amp;gt;

&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;布局相关&quot;&gt;2.4.布局相关&lt;/h2&gt;
&lt;h3 id=&quot;弹性布局&quot;&gt;2.4.1.弹性布局&lt;/h3&gt;
&lt;p&gt;这个基本上用的前端框架都包含了（eg：&lt;code&gt;bootstrap&lt;/code&gt;），这边简单看下即可&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;

&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, user-scalable=no&quot;&amp;gt;
    &amp;lt;title&amp;gt;弹性&amp;lt;/title&amp;gt;
    &amp;lt;style media=&quot;screen&quot;&amp;gt;
        ul {
            display: flex;
        }
        ul li {
            list-style: none;
            border: 1px solid black;
            background-color: yellow;
        }
        ul li:first-child {
            /* 权重为1 */
            flex: 1;
        }
        ul li:nth-child(2) {
            /* 权重为2 */
            flex: 2;
            /* 一般都配合min-宽高来使用 */
            min-width: 100px;
        }
        ul li:last-child {
            /* 权重为2 */
            flex: 2;
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;ul&amp;gt;
        &amp;lt;li&amp;gt;1&amp;lt;/li&amp;gt;
        &amp;lt;li&amp;gt;2&amp;lt;/li&amp;gt;
        &amp;lt;li&amp;gt;3&amp;lt;/li&amp;gt;
    &amp;lt;/ul&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;响应式布局推荐&quot;&gt;2.4.2.响应式布局（推荐）&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;个人理解：规定一个最大或者最小的边界值，超过这个值就对指定元素设置指定样式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不难，看下demo里面的code片段就结束吧：&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;/* 屏幕小于等于1200px使用如下CSS（非宽屏） */
@media screen and (max-width: 1200px) {
  main {
    width: 95%;
  }

  /* 文章宽屏显示 */
  main article,
  .copyright {
    width: 100%;
  }

  /* 侧边栏隐藏 */
  main aside {
    display: none;
  }

  /* 页脚宽屏显示 */
  .copyright {
    width: 100%;
    min-width: auto;
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意一下：响应式看起来加载的东西少了（eg：移动端）但其实和PC端请求页面大小一样（该加载的还是要加载，只是隐藏而已）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最后再提一下移动端的&lt;code&gt;meta&lt;/code&gt;，一般都这么设置：&lt;strong&gt;&lt;code&gt;宽度为屏幕宽度，且不允许用户缩放&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, user-scalable=no&quot;&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;插件扩展&quot;&gt;插件扩展&lt;/h2&gt;
&lt;h3 id=&quot;通过autoprefixer自动给添加不同浏览器css3前缀&quot;&gt;通过&lt;code&gt;Autoprefixer&lt;/code&gt;自动给添加不同浏览器CSS3前缀&lt;/h3&gt;
&lt;p&gt;有些CSS3在谷歌浏览器、火狐、IE的老版本中可能不是标准名称，这时候可以通过&lt;code&gt;Autoprefixer&lt;/code&gt;快速来兼容旧浏览器，之前写过文章，可以看看：&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/Ks7e7TPF2AujQIVbAqu_Rw&quot;&gt;介绍一款自动给添加不同浏览器CSS3前缀的插件~Autoprefixer（附其他前端开发插件）&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;通过cssrem自动转换px到rem&quot;&gt;通过&lt;code&gt;cssrem&lt;/code&gt;自动转换px到rem&lt;/h3&gt;
&lt;p&gt;这个移动布局用的比较多，使用的时候有一点需要注意一下：&lt;strong&gt;需先设置默认root字体大小!&lt;/strong&gt;（一般设置为20px）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201904/1127869-20190424211635381-1053939636.jpg&quot; alt=&quot;12.默认字体大小.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;PS：移动布局一般按照这个尺寸的双倍来设计：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201904/1127869-20190424211603981-1987703542.jpg&quot; alt=&quot;12.尺寸.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;案例小小说明&quot;&gt;案例小小说明&lt;/h3&gt;
&lt;p&gt;开始之前先说下我准备的案例：&lt;a href=&quot;https://github.com/lotapp/h5blog/&quot; class=&quot;uri&quot;&gt;https://github.com/lotapp/h5blog/&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;这次是真费了一番功法去准备了一个博客的案例，从&lt;code&gt;设计&lt;/code&gt;（布局是仿几个模版的）到&lt;code&gt;PC页面&lt;/code&gt;、再到&lt;code&gt;响应式&lt;/code&gt;移动端布局（本来是准备直接出移动页面的，后来一想，算了彻底点吧，含&lt;code&gt;iPad&lt;/code&gt;和&lt;code&gt;iPhone&lt;/code&gt;）、再到&lt;code&gt;移动端&lt;/code&gt;H5页面、最后再到&lt;code&gt;小程序&lt;/code&gt;页面（在H5的基础上简单改了下）算是都弄了个demo&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最后贴下效果图（前端真的没啥，忘了W3C查一下，我这边整理一下也是为了以后方便）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PC端演示&lt;/strong&gt;：&lt;a href=&quot;https://github.lesschina.com/html5/&quot; class=&quot;uri&quot;&gt;https://github.lesschina.com/html5/&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这个动态演示的gif太大，大家自己访问吧，这边就贴一个静态图&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201904/1127869-20190416090911703-56471476.jpg&quot; alt=&quot;PC效果图.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ipad布局：GIF渲染的时候有点小问题，可以直接访问查看效果&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201904/1127869-20190423165139820-126080335.gif&quot; alt=&quot;ipad.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;iPhone：GIF渲染的时候有点小问题，可以直接访问查看效果&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201904/1127869-20190423165243084-972987427.gif&quot; alt=&quot;mobil.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;移动端演示&lt;/strong&gt;：&lt;a href=&quot;http://github.lesschina.com/html5/mobil/&quot; class=&quot;uri&quot;&gt;http://github.lesschina.com/html5/mobil/&lt;/a&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201904/1127869-20190423165656866-455636705.gif&quot; alt=&quot;m.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;微信端演示&lt;/strong&gt;：&lt;a href=&quot;https://github.com/lotapp/H5Blog/tree/master/wechat&quot; class=&quot;uri&quot;&gt;https://github.com/lotapp/H5Blog/tree/master/wechat&lt;/a&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201904/1127869-20190423165838552-732949800.gif&quot; alt=&quot;wechat.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意下图片有时候会有黑边框的问题，设置一下&lt;code&gt;display:block&lt;/code&gt;就可以了&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;PS：本质就是行内块间隙问题（后面会说的）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;小程序方面注意点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;微信的a标签（&lt;code&gt;navigator&lt;/code&gt;）是块级元素，而a标签本来是行内元素&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;微信的img标签（&lt;code&gt;image&lt;/code&gt;）在css中设置&lt;code&gt;width:100%&lt;/code&gt;是有点小问题的，还需要设置&lt;code&gt;mode=&quot;widthFix&quot;&lt;/code&gt;（或者直接设置这个）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其他的没什么好说的了，一切尽在代码中了~ &lt;a href=&quot;https://github.com/lotapp/H5Blog/tree/master/mobil&quot; class=&quot;uri&quot;&gt;https://github.com/lotapp/H5Blog/tree/master/mobil&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;(完)&lt;/p&gt;
</description>
<pubDate>Wed, 24 Apr 2019 22:45:00 +0000</pubDate>
<dc:creator>鲲逸鹏</dc:creator>
<og:description>2.CSS3 官方文档： 2.1.CSS基础 基础简单过下，事先说明下：诸如引入、注释、案例就不一一演示了，有个工作1年左右的人都可以熟练掌握，所以基础部分就简单归纳一下 W3C的常用属性列表 了 2</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dotnetcrazy/p/10748103.html</dc:identifier>
</item>
<item>
<title>深度解密Go语言之关于 interface 的10个问题 - Stefno</title>
<link>http://www.cnblogs.com/qcrao-2018/p/10766091.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qcrao-2018/p/10766091.html</guid>
<description>&lt;p&gt;这次文章依然很长，基本上涵盖了 &lt;code&gt;interface&lt;/code&gt; 的方方面面，有例子，有源码分析，有汇编分析，前前后后写了 20 多天。洋洋洒洒，长篇大论，依然有些东西没有涉及到，比如文章里没有写到&lt;code&gt;反射&lt;/code&gt;，当然，后面会单独写一篇关于&lt;code&gt;反射&lt;/code&gt;的文章，这是后话。&lt;/p&gt;
&lt;p&gt;还是希望看你在看完文章后能有所收获，有任何问题或意见建议，欢迎在文章后面留言。&lt;/p&gt;
&lt;p&gt;这篇文章的架构比较简单，直接抛出 10 个问题，一一解答。&lt;/p&gt;

&lt;p&gt;先直接来看维基百科里的定义：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;If it looks like a duck, swims like a duck, and quacks like a duck, then it probably is a duck.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;翻译过来就是：如果某个东西长得像鸭子，像鸭子一样游泳，像鸭子一样嘎嘎叫，那它就可以被看成是一只鸭子。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Duck Typing&lt;/code&gt;，鸭子类型，是动态编程语言的一种对象推断策略，它更关注对象能如何被使用，而不是对象的类型本身。Go 语言作为一门静态语言，它通过通过接口的方式完美支持鸭子类型。&lt;/p&gt;
&lt;p&gt;例如，在动态语言 python 中，定义一个这样的函数：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def hello_world(coder):
    coder.say_hello()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当调用此函数的时候，可以传入任意类型，只要它实现了 &lt;code&gt;say_hello()&lt;/code&gt; 函数就可以。如果没有实现，运行过程中会出现错误。&lt;/p&gt;
&lt;p&gt;而在静态语言如 Java, C++ 中，必须要显示地声明实现了某个接口，之后，才能用在任何需要这个接口的地方。如果你在程序中调用 &lt;code&gt;hello_world&lt;/code&gt; 函数，却传入了一个根本就没有实现 &lt;code&gt;say_hello()&lt;/code&gt; 的类型，那在编译阶段就不会通过。这也是静态语言比动态语言更安全的原因。&lt;/p&gt;
&lt;p&gt;动态语言和静态语言的差别在此就有所体现。静态语言在编译期间就能发现类型不匹配的错误，不像动态语言，必须要运行到那一行代码才会报错。插一句，这也是我不喜欢用 &lt;code&gt;python&lt;/code&gt; 的一个原因。当然，静态语言要求程序员在编码阶段就要按照规定来编写程序，为每个变量规定数据类型，这在某种程度上，加大了工作量，也加长了代码量。动态语言则没有这些要求，可以让人更专注在业务上，代码也更短，写起来更快，这一点，写 python 的同学比较清楚。&lt;/p&gt;
&lt;p&gt;Go 语言作为一门现代静态语言，是有后发优势的。它引入了动态语言的便利，同时又会进行静态语言的类型检查，写起来是非常 Happy 的。Go 采用了折中的做法：不要求类型显示地声明实现了某个接口，只要实现了相关的方法即可，编译器就能检测到。&lt;/p&gt;
&lt;p&gt;来看个例子：&lt;/p&gt;
&lt;p&gt;先定义一个接口，和使用此接口作为参数的函数：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;type IGreeting interface {
    sayHello()
}

func sayHello(i IGreeting) {
    i.sayHello()
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再来定义两个结构体：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;type Go struct {}
func (g Go) sayHello() {
    fmt.Println(&quot;Hi, I am GO!&quot;)
}

type PHP struct {}
func (p PHP) sayHello() {
    fmt.Println(&quot;Hi, I am PHP!&quot;)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后，在 main 函数里调用 sayHello() 函数：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;func main() {
    golang := Go{}
    php := PHP{}

    sayHello(golang)
    sayHello(php)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;程序输出：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;Hi, I am GO!
Hi, I am PHP!&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 main 函数中，调用调用 sayHello() 函数时，传入了 &lt;code&gt;golang, php&lt;/code&gt; 对象，它们并没有显式地声明实现了 IGreeting 类型，只是实现了接口所规定的 sayHello() 函数。实际上，编译器在调用 sayHello() 函数时，会隐式地将 &lt;code&gt;golang, php&lt;/code&gt; 对象转换成 IGreeting 类型，这也是静态语言的类型检查功能。&lt;/p&gt;
&lt;p&gt;顺带再提一下动态语言的特点：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;变量绑定的类型是不确定的，在运行期间才能确定&lt;br/&gt;函数和方法可以接收任何类型的参数，且调用时不检查参数类型&lt;br/&gt;不需要实现接口&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;总结一下，鸭子类型是一种动态语言的风格，在这种风格中，一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由它&quot;当前方法和属性的集合&quot;决定。Go 作为一种静态语言，通过接口实现了 &lt;code&gt;鸭子类型&lt;/code&gt;，实际上是 Go 的编译器在其中作了隐匿的转换工作。&lt;/p&gt;

&lt;h2 id=&quot;方法&quot;&gt;方法&lt;/h2&gt;
&lt;p&gt;方法能给用户自定义的类型添加新的行为。它和函数的区别在于方法有一个接收者，给一个函数添加一个接收者，那么它就变成了方法。接收者可以是&lt;code&gt;值接收者&lt;/code&gt;，也可以是&lt;code&gt;指针接收者&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在调用方法的时候，值类型既可以调用&lt;code&gt;值接收者&lt;/code&gt;的方法，也可以调用&lt;code&gt;指针接收者&lt;/code&gt;的方法；指针类型既可以调用&lt;code&gt;指针接收者&lt;/code&gt;的方法，也可以调用&lt;code&gt;值接收者&lt;/code&gt;的方法。&lt;/p&gt;
&lt;p&gt;也就是说，不管方法的接收者是什么类型，该类型的值和指针都可以调用，不必严格符合接收者的类型。&lt;/p&gt;
&lt;p&gt;来看个例子：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;package main

import &quot;fmt&quot;

type Person struct {
    age int
}

func (p Person) howOld() int {
    return p.age
}

func (p *Person) growUp() {
    p.age += 1
}

func main() {
    // qcrao 是值类型
    qcrao := Person{age: 18}

    // 值类型 调用接收者也是值类型的方法
    fmt.Println(qcrao.howOld())

    // 值类型 调用接收者是指针类型的方法
    qcrao.growUp()
    fmt.Println(qcrao.howOld())

    // ----------------------

    // stefno 是指针类型
    stefno := &amp;amp;Person{age: 100}

    // 指针类型 调用接收者是值类型的方法
    fmt.Println(stefno.howOld())

    // 指针类型 调用接收者也是指针类型的方法
    stefno.growUp()
    fmt.Println(stefno.howOld())
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上例子的输出结果是：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;18
19
100
101&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用了 &lt;code&gt;growUp&lt;/code&gt; 函数后，不管调用者是值类型还是指针类型，它的 &lt;code&gt;Age&lt;/code&gt; 值都改变了。&lt;/p&gt;
&lt;p&gt;实际上，当类型和方法的接收者类型不同时，其实是编译器在背后做了一些工作，用一个表格来呈现：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;值类型调用者&lt;/td&gt;
&lt;td&gt;方法会使用调用者的一个副本，类似于“传值”&lt;/td&gt;
&lt;td&gt;使用值的引用来调用方法，上例中，&lt;code&gt;qcrao.growUp()&lt;/code&gt; 实际上是 &lt;code&gt;(&amp;amp;qcrao).growUp()&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;指针类型调用者&lt;/td&gt;
&lt;td&gt;指针被解引用为值，上例中，&lt;code&gt;stefno.howOld()&lt;/code&gt; 实际上是 &lt;code&gt;(*stefno).howOld()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;实际上也是“传值”，方法里的操作会影响到调用者，类似于指针传参，拷贝了一份指针&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;值接收者和指针接收者&quot;&gt;值接收者和指针接收者&lt;/h2&gt;
&lt;p&gt;前面说过，不管接收者类型是值类型还是指针类型，都可以通过值类型或指针类型调用，这里面实际上通过语法糖起作用的。&lt;/p&gt;
&lt;p&gt;先说结论：实现了接收者是值类型的方法，相当于自动实现了接收者是指针类型的方法；而实现了接收者是指针类型的方法，不会自动生成对应接收者是值类型的方法。&lt;/p&gt;
&lt;p&gt;来看一个例子，就会完全明白：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;package main

import &quot;fmt&quot;

type coder interface {
    code()
    debug()
}

type Gopher struct {
    language string
}

func (p Gopher) code() {
    fmt.Printf(&quot;I am coding %s language\n&quot;, p.language)
}

func (p *Gopher) debug() {
    fmt.Printf(&quot;I am debuging %s language\n&quot;, p.language)
}

func main() {
    var c coder = &amp;amp;Gopher{&quot;Go&quot;}
    c.code()
    c.debug()
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述代码里定义了一个接口 &lt;code&gt;coder&lt;/code&gt;，接口定义了两个函数：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;code()
debug()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着定义了一个结构体 &lt;code&gt;Gopher&lt;/code&gt;，它实现了两个方法，一个值接收者，一个指针接收者。&lt;/p&gt;
&lt;p&gt;最后，我们在 &lt;code&gt;main&lt;/code&gt; 函数里通过接口类型的变量调用了定义的两个函数。&lt;/p&gt;
&lt;p&gt;运行一下，结果：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;I am coding Go language
I am debuging Go language&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是如果我们把 &lt;code&gt;main&lt;/code&gt; 函数的第一条语句换一下：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;func main() {
    var c coder = Gopher{&quot;Go&quot;}
    c.code()
    c.debug()
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行一下，报错：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;./main.go:24:6: cannot use Programmer literal (type Programmer) as type coder in assignment:
    Programmer does not implement coder (debug method has pointer receiver)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看出这两处代码的差别了吗？第一次是将 &lt;code&gt;&amp;amp;Gopher&lt;/code&gt; 赋给了 &lt;code&gt;coder&lt;/code&gt;；第二次则是将 &lt;code&gt;Gopher&lt;/code&gt; 赋给了 &lt;code&gt;coder&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;第二次报错是说，&lt;code&gt;Gopher&lt;/code&gt; 没有实现 &lt;code&gt;coder&lt;/code&gt;。很明显了吧，因为 &lt;code&gt;Gopher&lt;/code&gt; 类型并没有实现 &lt;code&gt;debug&lt;/code&gt; 方法；表面上看， &lt;code&gt;*Gopher&lt;/code&gt; 类型也没有实现 &lt;code&gt;code&lt;/code&gt; 方法，但是因为 &lt;code&gt;Gopher&lt;/code&gt; 类型实现了 &lt;code&gt;code&lt;/code&gt; 方法，所以让 &lt;code&gt;*Gopher&lt;/code&gt; 类型自动拥有了 &lt;code&gt;code&lt;/code&gt; 方法。&lt;/p&gt;
&lt;p&gt;当然，上面的说法有一个简单的解释：接收者是指针类型的方法，很可能在方法中会对接收者的属性进行更改操作，从而影响接收者；而对于接收者是值类型的方法，在方法中不会对接收者本身产生影响。&lt;/p&gt;
&lt;p&gt;所以，当实现了一个接收者是值类型的方法，就可以自动生成一个接收者是对应指针类型的方法，因为两者都不会影响接收者。但是，当实现了一个接收者是指针类型的方法，如果此时自动生成一个接收者是值类型的方法，原本期望对接收者的改变（通过指针实现），现在无法实现，因为值类型会产生一个拷贝，不会真正影响调用者。&lt;/p&gt;
&lt;p&gt;最后，只要记住下面这点就可以了：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果实现了接收者是值类型的方法，会隐含地也实现了接收者是指针类型的方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;两者分别在何时使用&quot;&gt;两者分别在何时使用&lt;/h2&gt;
&lt;p&gt;如果方法的接收者是值类型，无论调用者是对象还是对象指针，修改的都是对象的副本，不影响调用者；如果方法的接收者是指针类型，则调用者修改的是指针指向的对象本身。&lt;/p&gt;
&lt;p&gt;使用指针作为方法的接收者的理由：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;方法能够修改接收者指向的值。&lt;/li&gt;
&lt;li&gt;避免在每次调用方法时复制该值，在值的类型为大型结构体时，这样做会更加高效。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;是使用值接收者还是指针接收者，不是由该方法是否修改了调用者（也就是接收者）来决定，而是应该基于该类型的&lt;code&gt;本质&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果类型具备“原始的本质”，也就是说它的成员都是由 Go 语言里内置的原始类型，如字符串，整型值等，那就定义值接收者类型的方法。像内置的引用类型，如 slice，map，interface，channel，这些类型比较特殊，声明他们的时候，实际上是创建了一个 &lt;code&gt;header&lt;/code&gt;， 对于他们也是直接定义值接收者类型的方法。这样，调用函数时，是直接 copy 了这些类型的 &lt;code&gt;header&lt;/code&gt;，而 &lt;code&gt;header&lt;/code&gt; 本身就是为复制设计的。&lt;/p&gt;
&lt;p&gt;如果类型具备非原始的本质，不能被安全地复制，这种类型总是应该被共享，那就定义指针接收者的方法。比如 go 源码里的文件结构体（struct File）就不应该被复制，应该只有一份&lt;code&gt;实体&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这一段说的比较绕，大家可以去看《Go 语言实战》5.3 那一节。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;iface&lt;/code&gt; 和 &lt;code&gt;eface&lt;/code&gt; 都是 Go 中描述接口的底层结构体，区别在于 &lt;code&gt;iface&lt;/code&gt; 描述的接口包含方法，而 &lt;code&gt;eface&lt;/code&gt; 则是不包含任何方法的空接口：&lt;code&gt;interface{}&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;从源码层面看一下：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;type iface struct {
    tab  *itab
    data unsafe.Pointer
}

type itab struct {
    inter  *interfacetype
    _type  *_type
    link   *itab
    hash   uint32 // copy of _type.hash. Used for type switches.
    bad    bool   // type does not implement interface
    inhash bool   // has this itab been added to hash?
    unused [2]byte
    fun    [1]uintptr // variable sized
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;iface&lt;/code&gt; 内部维护两个指针，&lt;code&gt;tab&lt;/code&gt; 指向一个 &lt;code&gt;itab&lt;/code&gt; 实体， 它表示接口的类型以及赋给这个接口的实体类型。&lt;code&gt;data&lt;/code&gt; 则指向接口具体的值，一般而言是一个指向堆内存的指针。&lt;/p&gt;
&lt;p&gt;再来仔细看一下 &lt;code&gt;itab&lt;/code&gt; 结构体：&lt;code&gt;_type&lt;/code&gt; 字段描述了实体的类型，包括内存对齐方式，大小等；&lt;code&gt;inter&lt;/code&gt; 字段则描述了接口的类型。&lt;code&gt;fun&lt;/code&gt; 字段放置和接口方法对应的具体数据类型的方法地址，实现接口调用方法的动态分派，一般在每次给接口赋值发生转换时会更新此表，或者直接拿缓存的 itab。&lt;/p&gt;
&lt;p&gt;这里只会列出实体类型和接口相关的方法，实体类型的其他方法并不会出现在这里。如果你学过 C++ 的话，这里可以类比虚函数的概念。&lt;/p&gt;
&lt;p&gt;另外，你可能会觉得奇怪，为什么 &lt;code&gt;fun&lt;/code&gt; 数组的大小为 1，要是接口定义了多个方法可怎么办？实际上，这里存储的是第一个方法的函数指针，如果有更多的方法，在它之后的内存空间里继续存储。从汇编角度来看，通过增加地址就能获取到这些函数指针，没什么影响。顺便提一句，这些方法是按照函数名称的字典序进行排列的。&lt;/p&gt;
&lt;p&gt;再看一下 &lt;code&gt;interfacetype&lt;/code&gt; 类型，它描述的是接口的类型：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;type interfacetype struct {
    typ     _type
    pkgpath name
    mhdr    []imethod
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，它包装了 &lt;code&gt;_type&lt;/code&gt; 类型，&lt;code&gt;_type&lt;/code&gt; 实际上是描述 Go 语言中各种数据类型的结构体。我们注意到，这里还包含一个 &lt;code&gt;mhdr&lt;/code&gt; 字段，表示接口所定义的函数列表， &lt;code&gt;pkgpath&lt;/code&gt; 记录定义了接口的包名。&lt;/p&gt;
&lt;p&gt;这里通过一张图来看下 &lt;code&gt;iface&lt;/code&gt; 结构体的全貌：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/56564826-82527600-65e1-11e9-956d-d98a212bc863.png&quot; alt=&quot;iface 结构体全景&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接着来看一下 &lt;code&gt;eface&lt;/code&gt; 的源码：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;type eface struct {
    _type *_type
    data  unsafe.Pointer
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;相比 &lt;code&gt;iface&lt;/code&gt;，&lt;code&gt;eface&lt;/code&gt; 就比较简单了。只维护了一个 &lt;code&gt;_type&lt;/code&gt; 字段，表示空接口所承载的具体的实体类型。&lt;code&gt;data&lt;/code&gt; 描述了具体的值。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/56565105-318f4d00-65e2-11e9-96bd-4b2e192791dc.png&quot; alt=&quot;eface 结构体全景&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们来看个例子：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;package main

import &quot;fmt&quot;

func main() {
    x := 200
    var any interface{} = x
    fmt.Println(any)

    g := Gopher{&quot;Go&quot;}
    var c coder = g
    fmt.Println(c)
}

type coder interface {
    code()
    debug()
}

type Gopher struct {
    language string
}

func (p Gopher) code() {
    fmt.Printf(&quot;I am coding %s language\n&quot;, p.language)
}

func (p Gopher) debug() {
    fmt.Printf(&quot;I am debuging %s language\n&quot;, p.language)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行命令，打印出汇编语言：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;go tool compile -S ./src/main.go&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，main 函数里调用了两个函数：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;func convT2E64(t *_type, elem unsafe.Pointer) (e eface)
func convT2I(tab *itab, elem unsafe.Pointer) (i iface)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面两个函数的参数和 &lt;code&gt;iface&lt;/code&gt; 及 &lt;code&gt;eface&lt;/code&gt; 结构体的字段是可以联系起来的：两个函数都是将参数&lt;code&gt;组装&lt;/code&gt;一下，形成最终的接口。&lt;/p&gt;
&lt;p&gt;作为补充，我们最后再来看下 &lt;code&gt;_type&lt;/code&gt; 结构体：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;type _type struct {
    // 类型大小
    size       uintptr
    ptrdata    uintptr
    // 类型的 hash 值
    hash       uint32
    // 类型的 flag，和反射相关
    tflag      tflag
    // 内存对齐相关
    align      uint8
    fieldalign uint8
    // 类型的编号，有bool, slice, struct 等等等等
    kind       uint8
    alg        *typeAlg
    // gc 相关
    gcdata    *byte
    str       nameOff
    ptrToThis typeOff
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Go 语言各种数据类型都是在 &lt;code&gt;_type&lt;/code&gt; 字段的基础上，增加一些额外的字段来进行管理的：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;type arraytype struct {
    typ   _type
    elem  *_type
    slice *_type
    len   uintptr
}

type chantype struct {
    typ  _type
    elem *_type
    dir  uintptr
}

type slicetype struct {
    typ  _type
    elem *_type
}

type structtype struct {
    typ     _type
    pkgPath name
    fields  []structfield
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这些数据类型的结构体定义，是反射实现的基础。&lt;/p&gt;

&lt;p&gt;从源码里可以看到：&lt;code&gt;iface&lt;/code&gt;包含两个字段：&lt;code&gt;tab&lt;/code&gt; 是接口表指针，指向类型信息；&lt;code&gt;data&lt;/code&gt; 是数据指针，则指向具体的数据。它们分别被称为&lt;code&gt;动态类型&lt;/code&gt;和&lt;code&gt;动态值&lt;/code&gt;。而接口值包括&lt;code&gt;动态类型&lt;/code&gt;和&lt;code&gt;动态值&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;【引申1】接口类型和 &lt;code&gt;nil&lt;/code&gt; 作比较&lt;/p&gt;
&lt;p&gt;接口值的零值是指&lt;code&gt;动态类型&lt;/code&gt;和&lt;code&gt;动态值&lt;/code&gt;都为 &lt;code&gt;nil&lt;/code&gt;。当仅且当这两部分的值都为 &lt;code&gt;nil&lt;/code&gt; 的情况下，这个接口值就才会被认为 &lt;code&gt;接口值 == nil&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;来看个例子：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;package main

import &quot;fmt&quot;

type Coder interface {
    code()
}

type Gopher struct {
    name string
}

func (g Gopher) code() {
    fmt.Printf(&quot;%s is coding\n&quot;, g.name)
}

func main() {
    var c Coder
    fmt.Println(c == nil)
    fmt.Printf(&quot;c: %T, %v\n&quot;, c, c)

    var g *Gopher
    fmt.Println(g == nil)

    c = g
    fmt.Println(c == nil)
    fmt.Printf(&quot;c: %T, %v\n&quot;, c, c)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;true
c: &amp;lt;nil&amp;gt;, &amp;lt;nil&amp;gt;
true
false
c: *main.Gopher, &amp;lt;nil&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一开始，&lt;code&gt;c&lt;/code&gt; 的 动态类型和动态值都为 &lt;code&gt;nil&lt;/code&gt;，&lt;code&gt;g&lt;/code&gt; 也为 &lt;code&gt;nil&lt;/code&gt;，当把 &lt;code&gt;g&lt;/code&gt; 赋值给 &lt;code&gt;c&lt;/code&gt; 后，&lt;code&gt;c&lt;/code&gt; 的动态类型变成了 &lt;code&gt;*main.Gopher&lt;/code&gt;，仅管 &lt;code&gt;c&lt;/code&gt; 的动态值仍为 &lt;code&gt;nil&lt;/code&gt;，但是当 &lt;code&gt;c&lt;/code&gt; 和 &lt;code&gt;nil&lt;/code&gt; 作比较的时候，结果就是 &lt;code&gt;false&lt;/code&gt; 了。&lt;/p&gt;
&lt;p&gt;【引申2】&lt;br/&gt;来看一个例子，看一下它的输出：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;package main

import &quot;fmt&quot;

type MyError struct {}

func (i MyError) Error() string {
    return &quot;MyError&quot;
}

func main() {
    err := Process()
    fmt.Println(err)

    fmt.Println(err == nil)
}

func Process() error {
    var err *MyError = nil
    return err
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;函数运行结果：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;&amp;lt;nil&amp;gt;
false&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里先定义了一个 &lt;code&gt;MyError&lt;/code&gt; 结构体，实现了 &lt;code&gt;Error&lt;/code&gt; 函数，也就实现了 &lt;code&gt;error&lt;/code&gt; 接口。&lt;code&gt;Process&lt;/code&gt; 函数返回了一个 &lt;code&gt;error&lt;/code&gt; 接口，这块隐含了类型转换。所以，虽然它的值是 &lt;code&gt;nil&lt;/code&gt;，其实它的类型是 &lt;code&gt;*MyError&lt;/code&gt;，最后和 &lt;code&gt;nil&lt;/code&gt; 比较的时候，结果为 &lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;【引申3】如何打印出接口的动态类型和值？&lt;/p&gt;
&lt;p&gt;直接看代码：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;package main

import (
    &quot;unsafe&quot;
    &quot;fmt&quot;
)

type iface struct {
    itab, data uintptr
}

func main() {
    var a interface{} = nil

    var b interface{} = (*int)(nil)

    x := 5
    var c interface{} = (*int)(&amp;amp;x)
    
    ia := *(*iface)(unsafe.Pointer(&amp;amp;a))
    ib := *(*iface)(unsafe.Pointer(&amp;amp;b))
    ic := *(*iface)(unsafe.Pointer(&amp;amp;c))

    fmt.Println(ia, ib, ic)

    fmt.Println(*(*int)(unsafe.Pointer(ic.data)))
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码里直接定义了一个 &lt;code&gt;iface&lt;/code&gt; 结构体，用两个指针来描述 &lt;code&gt;itab&lt;/code&gt; 和 &lt;code&gt;data&lt;/code&gt;，之后将 a, b, c 在内存中的内容强制解释成我们自定义的 &lt;code&gt;iface&lt;/code&gt;。最后就可以打印出动态类型和动态值的地址。&lt;/p&gt;
&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;{0 0} {17426912 0} {17426912 842350714568}
5&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;a 的动态类型和动态值的地址均为 0，也就是 nil；b 的动态类型和 c 的动态类型一致，都是 &lt;code&gt;*int&lt;/code&gt;；最后，c 的动态值为 5。&lt;/p&gt;

&lt;p&gt;经常看到一些开源库里会有一些类似下面这种奇怪的用法：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;var _ io.Writer = (*myWriter)(nil)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这时候会有点懵，不知道作者想要干什么，实际上这就是此问题的答案。编译器会由此检查 &lt;code&gt;*myWriter&lt;/code&gt; 类型是否实现了 &lt;code&gt;io.Writer&lt;/code&gt; 接口。&lt;/p&gt;
&lt;p&gt;来看一个例子：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;package main

import &quot;io&quot;

type myWriter struct {

}

/*func (w myWriter) Write(p []byte) (n int, err error) {
    return
}*/

func main() {
    // 检查 *myWriter 类型是否实现了 io.Writer 接口
    var _ io.Writer = (*myWriter)(nil)

    // 检查 myWriter 类型是否实现了 io.Writer 接口
    var _ io.Writer = myWriter{}
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注释掉为 myWriter 定义的 Write 函数后，运行程序：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;src/main.go:14:6: cannot use (*myWriter)(nil) (type *myWriter) as type io.Writer in assignment:
    *myWriter does not implement io.Writer (missing Write method)
src/main.go:15:6: cannot use myWriter literal (type myWriter) as type io.Writer in assignment:
    myWriter does not implement io.Writer (missing Write method)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;报错信息：*myWriter/myWriter 未实现 io.Writer 接口，也就是未实现 Write 方法。&lt;/p&gt;
&lt;p&gt;解除注释后，运行程序不报错。&lt;/p&gt;
&lt;p&gt;实际上，上述赋值语句会发生隐式地类型转换，在转换的过程中，编译器会检测等号右边的类型是否实现了等号左边接口所规定的函数。&lt;/p&gt;
&lt;p&gt;总结一下，可通过在代码中添加类似如下的代码，用来检测类型是否实现了接口：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;var _ io.Writer = (*myWriter)(nil)
var _ io.Writer = myWriter{}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;我们已经看过了 &lt;code&gt;iface&lt;/code&gt; 和 &lt;code&gt;eface&lt;/code&gt; 的源码，知道 &lt;code&gt;iface&lt;/code&gt; 最重要的是 &lt;code&gt;itab&lt;/code&gt; 和 &lt;code&gt;_type&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;为了研究清楚接口是如何构造的，接下来我会拿起汇编的武器，还原背后的真相。&lt;/p&gt;
&lt;p&gt;来看一个示例代码：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;package main

import &quot;fmt&quot;

type Person interface {
    growUp()
}

type Student struct {
    age int
}

func (p Student) growUp() {
    p.age += 1
    return
}

func main() {
    var qcrao = Person(Student{age: 18})

    fmt.Println(qcrao)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行命令：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;go tool compile -S main.go&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;得到 main 函数的汇编代码如下：&lt;/p&gt;
&lt;pre class=&quot;asm&quot;&gt;
&lt;code&gt;0x0000 00000 (./src/main.go:30) TEXT    &quot;&quot;.main(SB), $80-0
0x0000 00000 (./src/main.go:30) MOVQ    (TLS), CX
0x0009 00009 (./src/main.go:30) CMPQ    SP, 16(CX)
0x000d 00013 (./src/main.go:30) JLS     157
0x0013 00019 (./src/main.go:30) SUBQ    $80, SP
0x0017 00023 (./src/main.go:30) MOVQ    BP, 72(SP)
0x001c 00028 (./src/main.go:30) LEAQ    72(SP), BP
0x0021 00033 (./src/main.go:30) FUNCDATA$0, gclocals·69c1753bd5f81501d95132d08af04464(SB)
0x0021 00033 (./src/main.go:30) FUNCDATA$1, gclocals·e226d4ae4a7cad8835311c6a4683c14f(SB)
0x0021 00033 (./src/main.go:31) MOVQ    $18, &quot;&quot;..autotmp_1+48(SP)
0x002a 00042 (./src/main.go:31) LEAQ    go.itab.&quot;&quot;.Student,&quot;&quot;.Person(SB), AX
0x0031 00049 (./src/main.go:31) MOVQ    AX, (SP)
0x0035 00053 (./src/main.go:31) LEAQ    &quot;&quot;..autotmp_1+48(SP), AX
0x003a 00058 (./src/main.go:31) MOVQ    AX, 8(SP)
0x003f 00063 (./src/main.go:31) PCDATA  $0, $0
0x003f 00063 (./src/main.go:31) CALL    runtime.convT2I64(SB)
0x0044 00068 (./src/main.go:31) MOVQ    24(SP), AX
0x0049 00073 (./src/main.go:31) MOVQ    16(SP), CX
0x004e 00078 (./src/main.go:33) TESTQ   CX, CX
0x0051 00081 (./src/main.go:33) JEQ     87
0x0053 00083 (./src/main.go:33) MOVQ    8(CX), CX
0x0057 00087 (./src/main.go:33) MOVQ    $0, &quot;&quot;..autotmp_2+56(SP)
0x0060 00096 (./src/main.go:33) MOVQ    $0, &quot;&quot;..autotmp_2+64(SP)
0x0069 00105 (./src/main.go:33) MOVQ    CX, &quot;&quot;..autotmp_2+56(SP)
0x006e 00110 (./src/main.go:33) MOVQ    AX, &quot;&quot;..autotmp_2+64(SP)
0x0073 00115 (./src/main.go:33) LEAQ    &quot;&quot;..autotmp_2+56(SP), AX
0x0078 00120 (./src/main.go:33) MOVQ    AX, (SP)
0x007c 00124 (./src/main.go:33) MOVQ    $1, 8(SP)
0x0085 00133 (./src/main.go:33) MOVQ    $1, 16(SP)
0x008e 00142 (./src/main.go:33) PCDATA  $0, $1
0x008e 00142 (./src/main.go:33) CALL    fmt.Println(SB)
0x0093 00147 (./src/main.go:34) MOVQ    72(SP), BP
0x0098 00152 (./src/main.go:34) ADDQ    $80, SP
0x009c 00156 (./src/main.go:34) RET
0x009d 00157 (./src/main.go:34) NOP
0x009d 00157 (./src/main.go:30) PCDATA  $0, $-1
0x009d 00157 (./src/main.go:30) CALL    runtime.morestack_noctxt(SB)
0x00a2 00162 (./src/main.go:30) JMP     0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们从第 10 行开始看，如果不理解前面几行汇编代码的话，可以回去看看公众号前面两篇文章，这里我就省略了。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;10-14&lt;/td&gt;
&lt;td&gt;构造调用 &lt;code&gt;runtime.convT2I64(SB)&lt;/code&gt; 的参数&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;我们来看下这个函数的参数形式：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;func convT2I64(tab *itab, elem unsafe.Pointer) (i iface) {
    // ……
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;convT2I64&lt;/code&gt; 会构造出一个 &lt;code&gt;inteface&lt;/code&gt;，也就是我们的 &lt;code&gt;Person&lt;/code&gt; 接口。&lt;/p&gt;
&lt;p&gt;第一个参数的位置是 &lt;code&gt;(SP)&lt;/code&gt;，这里被赋上了 &lt;code&gt;go.itab.&quot;&quot;.Student,&quot;&quot;.Person(SB)&lt;/code&gt; 的地址。&lt;/p&gt;
&lt;p&gt;我们从生成的汇编找到：&lt;/p&gt;
&lt;pre class=&quot;asm&quot;&gt;
&lt;code&gt;go.itab.&quot;&quot;.Student,&quot;&quot;.Person SNOPTRDATA dupok size=40
        0x0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  
        0x0010 00 00 00 00 00 00 00 00 da 9f 20 d4              
        rel 0+8 t=1 type.&quot;&quot;.Person+0
        rel 8+8 t=1 type.&quot;&quot;.Student+0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;size=40&lt;/code&gt; 大小为40字节，回顾一下：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;type itab struct {
    inter  *interfacetype // 8字节
    _type  *_type // 8字节
    link   *itab // 8字节
    hash   uint32 // 4字节
    bad    bool   // 1字节
    inhash bool   // 1字节
    unused [2]byte // 2字节
    fun    [1]uintptr // variable sized // 8字节
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;把每个字段的大小相加，&lt;code&gt;itab&lt;/code&gt; 结构体的大小就是 40 字节。上面那一串数字实际上是 &lt;code&gt;itab&lt;/code&gt; 序列化后的内容，注意到大部分数字是 0，从 24 字节开始的 4 个字节 &lt;code&gt;da 9f 20 d4&lt;/code&gt; 实际上是 &lt;code&gt;itab&lt;/code&gt; 的 &lt;code&gt;hash&lt;/code&gt; 值，这在判断两个类型是否相同的时候会用到。&lt;/p&gt;
&lt;p&gt;下面两行是链接指令，简单说就是将所有源文件综合起来，给每个符号赋予一个全局的位置值。这里的意思也比较明确：前8个字节最终存储的是 &lt;code&gt;type.&quot;&quot;.Person&lt;/code&gt; 的地址，对应 &lt;code&gt;itab&lt;/code&gt; 里的 &lt;code&gt;inter&lt;/code&gt; 字段，表示接口类型；8-16 字节最终存储的是 &lt;code&gt;type.&quot;&quot;.Student&lt;/code&gt; 的地址，对应 &lt;code&gt;itab&lt;/code&gt; 里 &lt;code&gt;_type&lt;/code&gt; 字段，表示具体类型。&lt;/p&gt;
&lt;p&gt;第二个参数就比较简单了，它就是数字 &lt;code&gt;18&lt;/code&gt; 的地址，这也是初始化 &lt;code&gt;Student&lt;/code&gt; 结构体的时候会用到。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;15&lt;/td&gt;
&lt;td&gt;调用 &lt;code&gt;runtime.convT2I64(SB)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;具体看下代码：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;func convT2I64(tab *itab, elem unsafe.Pointer) (i iface) {
    t := tab._type
    
    //...
    
    var x unsafe.Pointer
    if *(*uint64)(elem) == 0 {
        x = unsafe.Pointer(&amp;amp;zeroVal[0])
    } else {
        x = mallocgc(8, t, false)
        *(*uint64)(x) = *(*uint64)(elem)
    }
    i.tab = tab
    i.data = x
    return
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这块代码比较简单，把 &lt;code&gt;tab&lt;/code&gt; 赋给了 &lt;code&gt;iface&lt;/code&gt; 的 &lt;code&gt;tab&lt;/code&gt; 字段；&lt;code&gt;data&lt;/code&gt; 部分则是在堆上申请了一块内存，然后将 &lt;code&gt;elem&lt;/code&gt; 指向的 &lt;code&gt;18&lt;/code&gt; 拷贝过去。这样 &lt;code&gt;iface&lt;/code&gt; 就组装好了。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;17&lt;/td&gt;
&lt;td&gt;把 &lt;code&gt;i.tab&lt;/code&gt; 赋给 &lt;code&gt;CX&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;18&lt;/td&gt;
&lt;td&gt;把 &lt;code&gt;i.data&lt;/code&gt; 赋给 &lt;code&gt;AX&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;19-21&lt;/td&gt;
&lt;td&gt;检测 &lt;code&gt;i.tab&lt;/code&gt; 是否是 nil，如果不是的话，把 CX 移动 8 个字节，也就是把 &lt;code&gt;itab&lt;/code&gt; 的 &lt;code&gt;_type&lt;/code&gt; 字段赋给了 CX，这也是接口的实体类型，最终要作为 &lt;code&gt;fmt.Println&lt;/code&gt; 函数的参数&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;后面，就是调用 &lt;code&gt;fmt.Println&lt;/code&gt; 函数及之前的参数准备工作了，不再赘述。&lt;/p&gt;
&lt;p&gt;这样，我们就把一个 &lt;code&gt;interface&lt;/code&gt; 的构造过程说完了。&lt;/p&gt;
&lt;p&gt;【引申1】&lt;br/&gt;如何打印出接口类型的 &lt;code&gt;Hash&lt;/code&gt; 值？&lt;/p&gt;
&lt;p&gt;这里参考曹大神翻译的一篇文章，参考资料里会写上。具体做法如下：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;type iface struct {
    tab  *itab
    data unsafe.Pointer
}
type itab struct {
    inter uintptr
    _type uintptr
    link uintptr
    hash  uint32
    _     [4]byte
    fun   [1]uintptr
}

func main() {
    var qcrao = Person(Student{age: 18})

    iface := (*iface)(unsafe.Pointer(&amp;amp;qcrao))
    fmt.Printf(&quot;iface.tab.hash = %#x\n&quot;, iface.tab.hash)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;定义了一个&lt;code&gt;山寨版&lt;/code&gt;的 &lt;code&gt;iface&lt;/code&gt; 和 &lt;code&gt;itab&lt;/code&gt;，说它&lt;code&gt;山寨&lt;/code&gt;是因为 &lt;code&gt;itab&lt;/code&gt; 里的一些关键数据结构都不具体展开了，比如 &lt;code&gt;_type&lt;/code&gt;，对比一下正宗的定义就可以发现，但是&lt;code&gt;山寨版&lt;/code&gt;依然能工作，因为 &lt;code&gt;_type&lt;/code&gt; 就是一个指针而已嘛。&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;main&lt;/code&gt; 函数里，先构造出一个接口对象 &lt;code&gt;qcrao&lt;/code&gt;，然后强制类型转换，最后读取出 &lt;code&gt;hash&lt;/code&gt; 值，非常妙！你也可以自己动手试一下。&lt;/p&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;iface.tab.hash = 0xd4209fda&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;值得一提的是，构造接口 &lt;code&gt;qcrao&lt;/code&gt; 的时候，即使我把 &lt;code&gt;age&lt;/code&gt; 写成其他值，得到的 &lt;code&gt;hash&lt;/code&gt; 值依然不变的，这应该是可以预料的，&lt;code&gt;hash&lt;/code&gt; 值只和他的字段、方法相关。&lt;/p&gt;

&lt;p&gt;我们知道，Go 语言中不允许隐式类型转换，也就是说 &lt;code&gt;=&lt;/code&gt; 两边，不允许出现类型不相同的变量。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;类型转换&lt;/code&gt;、&lt;code&gt;类型断言&lt;/code&gt;本质都是把一个类型转换成另外一个类型。不同之处在于，类型断言是对接口变量进行的操作。&lt;/p&gt;
&lt;h2 id=&quot;类型转换&quot;&gt;类型转换&lt;/h2&gt;
&lt;p&gt;对于&lt;code&gt;类型转换&lt;/code&gt;而言，转换前后的两个类型要相互兼容才行。类型转换的语法为：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&amp;lt;结果类型&amp;gt; := &amp;lt;目标类型&amp;gt; ( &amp;lt;表达式&amp;gt; )&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;package main

import &quot;fmt&quot;

func main() {
    var i int = 9

    var f float64
    f = float64(i)
    fmt.Printf(&quot;%T, %v\n&quot;, f, f)

    f = 10.8
    a := int(f)
    fmt.Printf(&quot;%T, %v\n&quot;, a, a)

    // s := []int(i)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码里，我定义了一个 &lt;code&gt;int&lt;/code&gt; 型和 &lt;code&gt;float64&lt;/code&gt; 型的变量，尝试在它们之前相互转换，结果是成功的：&lt;code&gt;int&lt;/code&gt; 型和 &lt;code&gt;float64&lt;/code&gt; 是相互兼容的。&lt;/p&gt;
&lt;p&gt;如果我把最后一行代码的注释去掉，编译器会报告类型不兼容的错误：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;cannot convert i (type int) to type []int&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;断言&quot;&gt;断言&lt;/h2&gt;
&lt;p&gt;前面说过，因为空接口 &lt;code&gt;interface{}&lt;/code&gt; 没有定义任何函数，因此 Go 中所有类型都实现了空接口。当一个函数的形参是 &lt;code&gt;interface{}&lt;/code&gt;，那么在函数中，需要对形参进行断言，从而得到它的真实类型。&lt;/p&gt;
&lt;p&gt;断言的语法为：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&amp;lt;目标类型的值&amp;gt;，&amp;lt;布尔参数&amp;gt; := &amp;lt;表达式&amp;gt;.( 目标类型 ) // 安全类型断言&lt;br/&gt;&amp;lt;目标类型的值&amp;gt; := &amp;lt;表达式&amp;gt;.( 目标类型 )　　//非安全类型断言&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;类型转换和类型断言有些相似，不同之处，在于类型断言是对接口进行的操作。&lt;/p&gt;
&lt;p&gt;还是来看一个简短的例子：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;package main

import &quot;fmt&quot;

type Student struct {
    Name string
    Age int
}

func main() {
    var i interface{} = new(Student)
    s := i.(Student)
    
    fmt.Println(s)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行一下：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;panic: interface conversion: interface {} is *main.Student, not main.Student&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;直接 &lt;code&gt;panic&lt;/code&gt; 了，这是因为 &lt;code&gt;i&lt;/code&gt; 是 &lt;code&gt;*Student&lt;/code&gt; 类型，并非 &lt;code&gt;Student&lt;/code&gt; 类型，断言失败。这里直接发生了 &lt;code&gt;panic&lt;/code&gt;，线上代码可能并不适合这样做，可以采用“安全断言”的语法：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;func main() {
    var i interface{} = new(Student)
    s, ok := i.(Student)
    if ok {
        fmt.Println(s)
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样，即使断言失败也不会 &lt;code&gt;panic&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;断言其实还有另一种形式，就是用在利用 &lt;code&gt;switch&lt;/code&gt; 语句判断接口的类型。每一个 &lt;code&gt;case&lt;/code&gt; 会被顺序地考虑。当命中一个 &lt;code&gt;case&lt;/code&gt; 时，就会执行 &lt;code&gt;case&lt;/code&gt; 中的语句，因此 &lt;code&gt;case&lt;/code&gt; 语句的顺序是很重要的，因为很有可能会有多个 &lt;code&gt;case&lt;/code&gt; 匹配的情况。&lt;/p&gt;
&lt;p&gt;代码示例如下：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;func main() {
    //var i interface{} = new(Student)
    //var i interface{} = (*Student)(nil)
    var i interface{}

    fmt.Printf(&quot;%p %v\n&quot;, &amp;amp;i, i)

    judge(i)
}

func judge(v interface{}) {
    fmt.Printf(&quot;%p %v\n&quot;, &amp;amp;v, v)

    switch v := v.(type) {
    case nil:
        fmt.Printf(&quot;%p %v\n&quot;, &amp;amp;v, v)
        fmt.Printf(&quot;nil type[%T] %v\n&quot;, v, v)

    case Student:
        fmt.Printf(&quot;%p %v\n&quot;, &amp;amp;v, v)
        fmt.Printf(&quot;Student type[%T] %v\n&quot;, v, v)

    case *Student:
        fmt.Printf(&quot;%p %v\n&quot;, &amp;amp;v, v)
        fmt.Printf(&quot;*Student type[%T] %v\n&quot;, v, v)

    default:
        fmt.Printf(&quot;%p %v\n&quot;, &amp;amp;v, v)
        fmt.Printf(&quot;unknow\n&quot;)
    }
}

type Student struct {
    Name string
    Age int
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;main&lt;/code&gt; 函数里有三行不同的声明，每次运行一行，注释另外两行，得到三组运行结果：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;// --- var i interface{} = new(Student)
0xc4200701b0 [Name: ], [Age: 0]
0xc4200701d0 [Name: ], [Age: 0]
0xc420080020 [Name: ], [Age: 0]
*Student type[*main.Student] [Name: ], [Age: 0]

// --- var i interface{} = (*Student)(nil)
0xc42000e1d0 &amp;lt;nil&amp;gt;
0xc42000e1f0 &amp;lt;nil&amp;gt;
0xc42000c030 &amp;lt;nil&amp;gt;
*Student type[*main.Student] &amp;lt;nil&amp;gt;

// --- var i interface{}
0xc42000e1d0 &amp;lt;nil&amp;gt;
0xc42000e1e0 &amp;lt;nil&amp;gt;
0xc42000e1f0 &amp;lt;nil&amp;gt;
nil type[&amp;lt;nil&amp;gt;] &amp;lt;nil&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于第一行语句：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;var i interface{} = new(Student)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;i&lt;/code&gt; 是一个 &lt;code&gt;*Student&lt;/code&gt; 类型，匹配上第三个 case，从打印的三个地址来看，这三处的变量实际上都是不一样的。在 &lt;code&gt;main&lt;/code&gt; 函数里有一个局部变量 &lt;code&gt;i&lt;/code&gt;；调用函数时，实际上是复制了一份参数，因此函数里又有一个变量 &lt;code&gt;v&lt;/code&gt;，它是 &lt;code&gt;i&lt;/code&gt; 的拷贝；断言之后，又生成了一份新的拷贝。所以最终打印的三个变量的地址都不一样。&lt;/p&gt;
&lt;p&gt;对于第二行语句：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;var i interface{} = (*Student)(nil)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里想说明的其实是 &lt;code&gt;i&lt;/code&gt; 在这里动态类型是 &lt;code&gt;(*Student)&lt;/code&gt;, 数据为 &lt;code&gt;nil&lt;/code&gt;，它的类型并不是 &lt;code&gt;nil&lt;/code&gt;，它与 &lt;code&gt;nil&lt;/code&gt; 作比较的时候，得到的结果也是 &lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;最后一行语句：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;var i interface{}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这回 &lt;code&gt;i&lt;/code&gt; 才是 &lt;code&gt;nil&lt;/code&gt; 类型。&lt;/p&gt;
&lt;p&gt;【引申1】&lt;br/&gt;&lt;code&gt;fmt.Println&lt;/code&gt; 函数的参数是 &lt;code&gt;interface&lt;/code&gt;。对于内置类型，函数内部会用穷举法，得出它的真实类型，然后转换为字符串打印。而对于自定义类型，首先确定该类型是否实现了 &lt;code&gt;String()&lt;/code&gt; 方法，如果实现了，则直接打印输出 &lt;code&gt;String()&lt;/code&gt; 方法的结果；否则，会通过反射来遍历对象的成员进行打印。&lt;/p&gt;
&lt;p&gt;再来看一个简短的例子，比较简单，不要紧张：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;package main

import &quot;fmt&quot;

type Student struct {
    Name string
    Age int
}

func main() {
    var s = Student{
        Name: &quot;qcrao&quot;,
        Age: 18,
    }

    fmt.Println(s)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为 &lt;code&gt;Student&lt;/code&gt; 结构体没有实现 &lt;code&gt;String()&lt;/code&gt; 方法，所以 &lt;code&gt;fmt.Println&lt;/code&gt; 会利用反射挨个打印成员变量：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;{qcrao 18}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;增加一个 &lt;code&gt;String()&lt;/code&gt; 方法的实现：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;func (s Student) String() string {
    return fmt.Sprintf(&quot;[Name: %s], [Age: %d]&quot;, s.Name, s.Age)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打印结果：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[Name: qcrao], [Age: 18]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;按照我们自定义的方法来打印了。&lt;/p&gt;
&lt;p&gt;【引申2】&lt;br/&gt;针对上面的例子，如果改一下：&lt;/p&gt;
&lt;pre class=&quot;goalng&quot;&gt;
&lt;code&gt;func (s *Student) String() string {
    return fmt.Sprintf(&quot;[Name: %s], [Age: %d]&quot;, s.Name, s.Age)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意看两个函数的接受者类型不同，现在 &lt;code&gt;Student&lt;/code&gt; 结构体只有一个接受者类型为 &lt;code&gt;指针类型&lt;/code&gt; 的 &lt;code&gt;String()&lt;/code&gt; 函数，打印结果：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;{qcrao 18}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为什么？&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;类型 &lt;code&gt;T&lt;/code&gt; 只有接受者是 &lt;code&gt;T&lt;/code&gt; 的方法；而类型 &lt;code&gt;*T&lt;/code&gt; 拥有接受者是 &lt;code&gt;T&lt;/code&gt; 和 &lt;code&gt;*T&lt;/code&gt; 的方法。语法上 &lt;code&gt;T&lt;/code&gt; 能直接调 &lt;code&gt;*T&lt;/code&gt; 的方法仅仅是 &lt;code&gt;Go&lt;/code&gt; 的语法糖。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以， &lt;code&gt;Student&lt;/code&gt; 结构体定义了接受者类型是值类型的 &lt;code&gt;String()&lt;/code&gt; 方法时，通过&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;fmt.Println(s)
fmt.Println(&amp;amp;s)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;均可以按照自定义的格式来打印。&lt;/p&gt;
&lt;p&gt;如果 &lt;code&gt;Student&lt;/code&gt; 结构体定义了接受者类型是指针类型的 &lt;code&gt;String()&lt;/code&gt; 方法时，只有通过&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;fmt.Println(&amp;amp;s)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;才能按照自定义的格式打印。&lt;/p&gt;

&lt;p&gt;通过前面提到的 &lt;code&gt;iface&lt;/code&gt; 的源码可以看到，实际上它包含接口的类型 &lt;code&gt;interfacetype&lt;/code&gt; 和 实体类型的类型 &lt;code&gt;_type&lt;/code&gt;，这两者都是 &lt;code&gt;iface&lt;/code&gt; 的字段 &lt;code&gt;itab&lt;/code&gt; 的成员。也就是说生成一个 &lt;code&gt;itab&lt;/code&gt; 同时需要接口的类型和实体的类型。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&amp;lt;interface 类型， 实体类型&amp;gt; -&amp;gt;itable&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当判定一种类型是否满足某个接口时，Go 使用类型的方法集和接口所需要的方法集进行匹配，如果类型的方法集完全包含接口的方法集，则可认为该类型实现了该接口。&lt;/p&gt;
&lt;p&gt;例如某类型有 &lt;code&gt;m&lt;/code&gt; 个方法，某接口有 &lt;code&gt;n&lt;/code&gt; 个方法，则很容易知道这种判定的时间复杂度为 &lt;code&gt;O(mn)&lt;/code&gt;，Go 会对方法集的函数按照函数名的字典序进行排序，所以实际的时间复杂度为 &lt;code&gt;O(m+n)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这里我们来探索将一个接口转换给另外一个接口背后的原理，当然，能转换的原因必然是类型兼容。&lt;/p&gt;
&lt;p&gt;直接来看一个例子：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;package main

import &quot;fmt&quot;

type coder interface {
    code()
    run()
}

type runner interface {
    run()
}

type Gopher struct {
    language string
}

func (g Gopher) code() {
    return
}

func (g Gopher) run() {
    return
}

func main() {
    var c coder = Gopher{}

    var r runner
    r = c
    fmt.Println(c, r)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;简单解释下上述代码：定义了两个 &lt;code&gt;interface&lt;/code&gt;: &lt;code&gt;coder&lt;/code&gt; 和 &lt;code&gt;runner&lt;/code&gt;。定义了一个实体类型 &lt;code&gt;Gopher&lt;/code&gt;，类型 &lt;code&gt;Gopher&lt;/code&gt; 实现了两个方法，分别是 &lt;code&gt;run()&lt;/code&gt; 和 &lt;code&gt;code()&lt;/code&gt;。main 函数里定义了一个接口变量 &lt;code&gt;c&lt;/code&gt;，绑定了一个 &lt;code&gt;Gopher&lt;/code&gt; 对象，之后将 &lt;code&gt;c&lt;/code&gt; 赋值给另外一个接口变量 &lt;code&gt;r&lt;/code&gt; 。赋值成功的原因是 &lt;code&gt;c&lt;/code&gt; 中包含 &lt;code&gt;run()&lt;/code&gt; 方法。这样，两个接口变量完成了转换。&lt;/p&gt;
&lt;p&gt;执行命令：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;go tool compile -S ./src/main.go&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;得到 main 函数的汇编命令，可以看到： &lt;code&gt;r = c&lt;/code&gt; 这一行语句实际上是调用了 &lt;code&gt;runtime.convI2I(SB)&lt;/code&gt;，也就是 &lt;code&gt;convI2I&lt;/code&gt; 函数，从函数名来看，就是将一个 &lt;code&gt;interface&lt;/code&gt; 转换成另外一个 &lt;code&gt;interface&lt;/code&gt;，看下它的源代码：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;func convI2I(inter *interfacetype, i iface) (r iface) {
    tab := i.tab
    if tab == nil {
        return
    }
    if tab.inter == inter {
        r.tab = tab
        r.data = i.data
        return
    }
    r.tab = getitab(inter, tab._type, false)
    r.data = i.data
    return
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码比较简单，函数参数 &lt;code&gt;inter&lt;/code&gt; 表示接口类型，&lt;code&gt;i&lt;/code&gt; 表示绑定了实体类型的接口，&lt;code&gt;r&lt;/code&gt; 则表示接口转换了之后的新的 &lt;code&gt;iface&lt;/code&gt;。通过前面的分析，我们又知道， &lt;code&gt;iface&lt;/code&gt; 是由 &lt;code&gt;tab&lt;/code&gt; 和 &lt;code&gt;data&lt;/code&gt; 两个字段组成。所以，实际上 &lt;code&gt;convI2I&lt;/code&gt; 函数真正要做的事，找到新 &lt;code&gt;interface&lt;/code&gt; 的 &lt;code&gt;tab&lt;/code&gt; 和 &lt;code&gt;data&lt;/code&gt;，就大功告成了。&lt;/p&gt;
&lt;p&gt;我们还知道，&lt;code&gt;tab&lt;/code&gt; 是由接口类型 &lt;code&gt;interfacetype&lt;/code&gt; 和 实体类型 &lt;code&gt;_type&lt;/code&gt;。所以最关键的语句是 &lt;code&gt;r.tab = getitab(inter, tab._type, false)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;因此，重点来看下 &lt;code&gt;getitab&lt;/code&gt; 函数的源码，只看关键的地方：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;func getitab(inter *interfacetype, typ *_type, canfail bool) *itab {
    // ……

    // 根据 inter, typ 计算出 hash 值
    h := itabhash(inter, typ)

    // look twice - once without lock, once with.
    // common case will be no lock contention.
    var m *itab
    var locked int
    for locked = 0; locked &amp;lt; 2; locked++ {
        if locked != 0 {
            lock(&amp;amp;ifaceLock)
        }
        
        // 遍历哈希表的一个 slot
        for m = (*itab)(atomic.Loadp(unsafe.Pointer(&amp;amp;hash[h]))); m != nil; m = m.link {

            // 如果在 hash 表中已经找到了 itab（inter 和 typ 指针都相同）
            if m.inter == inter &amp;amp;&amp;amp; m._type == typ {
                // ……
                
                if locked != 0 {
                    unlock(&amp;amp;ifaceLock)
                }
                return m
            }
        }
    }

    // 在 hash 表中没有找到 itab，那么新生成一个 itab
    m = (*itab)(persistentalloc(unsafe.Sizeof(itab{})+uintptr(len(inter.mhdr)-1)*sys.PtrSize, 0, &amp;amp;memstats.other_sys))
    m.inter = inter
    m._type = typ
    
    // 添加到全局的 hash 表中
    additab(m, true, canfail)
    unlock(&amp;amp;ifaceLock)
    if m.bad {
        return nil
    }
    return m
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;简单总结一下：getitab 函数会根据 &lt;code&gt;interfacetype&lt;/code&gt; 和 &lt;code&gt;_type&lt;/code&gt; 去全局的 itab 哈希表中查找，如果能找到，则直接返回；否则，会根据给定的 &lt;code&gt;interfacetype&lt;/code&gt; 和 &lt;code&gt;_type&lt;/code&gt; 新生成一个 &lt;code&gt;itab&lt;/code&gt;，并插入到 itab 哈希表，这样下一次就可以直接拿到 &lt;code&gt;itab&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这里查找了两次，并且第二次上锁了，这是因为如果第一次没找到，在第二次仍然没有找到相应的 &lt;code&gt;itab&lt;/code&gt; 的情况下，需要新生成一个，并且写入哈希表，因此需要加锁。这样，其他协程在查找相同的 &lt;code&gt;itab&lt;/code&gt; 并且也没有找到时，第二次查找时，会被挂住，之后，就会查到第一个协程写入哈希表的 &lt;code&gt;itab&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;再来看一下 &lt;code&gt;additab&lt;/code&gt; 函数的代码：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;// 检查 _type 是否符合 interface_type 并且创建对应的 itab 结构体 将其放到 hash 表中
func additab(m *itab, locked, canfail bool) {
    inter := m.inter
    typ := m._type
    x := typ.uncommon()

    // both inter and typ have method sorted by name,
    // and interface names are unique,
    // so can iterate over both in lock step;
    // the loop is O(ni+nt) not O(ni*nt).
    // 
    // inter 和 typ 的方法都按方法名称进行了排序
    // 并且方法名都是唯一的。所以循环的次数是固定的
    // 只用循环 O(ni+nt)，而非 O(ni*nt)
    ni := len(inter.mhdr)
    nt := int(x.mcount)
    xmhdr := (*[1 &amp;lt;&amp;lt; 16]method)(add(unsafe.Pointer(x), uintptr(x.moff)))[:nt:nt]
    j := 0
    for k := 0; k &amp;lt; ni; k++ {
        i := &amp;amp;inter.mhdr[k]
        itype := inter.typ.typeOff(i.ityp)
        name := inter.typ.nameOff(i.name)
        iname := name.name()
        ipkg := name.pkgPath()
        if ipkg == &quot;&quot; {
            ipkg = inter.pkgpath.name()
        }
        for ; j &amp;lt; nt; j++ {
            t := &amp;amp;xmhdr[j]
            tname := typ.nameOff(t.name)
            // 检查方法名字是否一致
            if typ.typeOff(t.mtyp) == itype &amp;amp;&amp;amp; tname.name() == iname {
                pkgPath := tname.pkgPath()
                if pkgPath == &quot;&quot; {
                    pkgPath = typ.nameOff(x.pkgpath).name()
                }
                if tname.isExported() || pkgPath == ipkg {
                    if m != nil {
                        // 获取函数地址，并加入到itab.fun数组中
                        ifn := typ.textOff(t.ifn)
                        *(*unsafe.Pointer)(add(unsafe.Pointer(&amp;amp;m.fun[0]), uintptr(k)*sys.PtrSize)) = ifn
                    }
                    goto nextimethod
                }
            }
        }
        // ……
        
        m.bad = true
        break
    nextimethod:
    }
    if !locked {
        throw(&quot;invalid itab locking&quot;)
    }

    // 计算 hash 值
    h := itabhash(inter, typ)
    // 加到Hash Slot链表中
    m.link = hash[h]
    m.inhash = true
    atomicstorep(unsafe.Pointer(&amp;amp;hash[h]), unsafe.Pointer(m))
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;additab&lt;/code&gt; 会检查 &lt;code&gt;itab&lt;/code&gt; 持有的 &lt;code&gt;interfacetype&lt;/code&gt; 和 &lt;code&gt;_type&lt;/code&gt; 是否符合，就是看 &lt;code&gt;_type&lt;/code&gt; 是否完全实现了 &lt;code&gt;interfacetype&lt;/code&gt; 的方法，也就是看两者的方法列表重叠的部分就是 &lt;code&gt;interfacetype&lt;/code&gt; 所持有的方法列表。注意到其中有一个双层循环，乍一看，循环次数是 &lt;code&gt;ni * nt&lt;/code&gt;，但由于两者的函数列表都按照函数名称进行了排序，因此最终只执行了 &lt;code&gt;ni + nt&lt;/code&gt; 次，代码里通过一个小技巧来实现：第二层循环并没有从 0 开始计数，而是从上一次遍历到的位置开始。&lt;/p&gt;
&lt;p&gt;求 hash 值的函数比较简单：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;func itabhash(inter *interfacetype, typ *_type) uint32 {
    h := inter.typ.hash
    h += 17 * typ.hash
    return h % hashSize
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;hashSize&lt;/code&gt; 的值是 1009。&lt;/p&gt;
&lt;p&gt;更一般的，当把实体类型赋值给接口的时候，会调用 &lt;code&gt;conv&lt;/code&gt; 系列函数，例如空接口调用 &lt;code&gt;convT2E&lt;/code&gt; 系列、非空接口调用 &lt;code&gt;convT2I&lt;/code&gt; 系列。这些函数比较相似：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;具体类型转空接口时，_type 字段直接复制源类型的 _type；调用 mallocgc 获得一块新内存，把值复制进去，data 再指向这块新内存。&lt;/li&gt;
&lt;li&gt;具体类型转非空接口时，入参 tab 是编译器在编译阶段预先生成好的，新接口 tab 字段直接指向入参 tab 指向的 itab；调用 mallocgc 获得一块新内存，把值复制进去，data 再指向这块新内存。&lt;/li&gt;
&lt;li&gt;而对于接口转接口，itab 调用 getitab 函数获取。只用生成一次，之后直接从 hash 表中获取。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;Go&lt;/code&gt; 语言并没有设计诸如虚函数、纯虚函数、继承、多重继承等概念，但它通过接口却非常优雅地支持了面向对象的特性。&lt;/p&gt;
&lt;p&gt;多态是一种运行期的行为，它有以下几个特点：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;一种类型具有多种类型的能力&lt;/li&gt;
&lt;li&gt;允许不同的对象对同一消息做出灵活的反应&lt;/li&gt;
&lt;li&gt;以一种通用的方式对待个使用的对象&lt;/li&gt;
&lt;li&gt;非动态语言必须通过继承和接口的方式来实现&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;看一个实现了多态的代码例子：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;package main

import &quot;fmt&quot;

func main() {
    qcrao := Student{age: 18}
    whatJob(&amp;amp;qcrao)

    growUp(&amp;amp;qcrao)
    fmt.Println(qcrao)

    stefno := Programmer{age: 100}
    whatJob(stefno)

    growUp(stefno)
    fmt.Println(stefno)
}

func whatJob(p Person) {
    p.job()
}

func growUp(p Person) {
    p.growUp()
}

type Person interface {
    job()
    growUp()
}

type Student struct {
    age int
}

func (p Student) job() {
    fmt.Println(&quot;I am a student.&quot;)
    return
}

func (p *Student) growUp() {
    p.age += 1
    return
}

type Programmer struct {
    age int
}

func (p Programmer) job() {
    fmt.Println(&quot;I am a programmer.&quot;)
    return
}

func (p Programmer) growUp() {
    // 程序员老得太快 ^_^
    p.age += 10
    return
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码里先定义了 1 个 &lt;code&gt;Person&lt;/code&gt; 接口，包含两个函数：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;job()
growUp()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后，又定义了 2 个结构体，&lt;code&gt;Student&lt;/code&gt; 和 &lt;code&gt;Programmer&lt;/code&gt;，同时，类型 &lt;code&gt;*Student&lt;/code&gt;、&lt;code&gt;Programmer&lt;/code&gt; 实现了 &lt;code&gt;Person&lt;/code&gt; 接口定义的两个函数。注意，&lt;code&gt;*Student&lt;/code&gt; 类型实现了接口， &lt;code&gt;Student&lt;/code&gt; 类型却没有。&lt;/p&gt;
&lt;p&gt;之后，我又定义了函数参数是 &lt;code&gt;Person&lt;/code&gt; 接口的两个函数：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;func whatJob(p Person)
func growUp(p Person)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;main&lt;/code&gt; 函数里先生成 &lt;code&gt;Student&lt;/code&gt; 和 &lt;code&gt;Programmer&lt;/code&gt; 的对象，再将它们分别传入到函数 &lt;code&gt;whatJob&lt;/code&gt; 和 &lt;code&gt;growUp&lt;/code&gt;。函数中，直接调用接口函数，实际执行的时候是看最终传入的实体类型是什么，调用的是实体类型实现的函数。于是，不同对象针对同一消息就有多种表现，&lt;code&gt;多态&lt;/code&gt;就实现了。&lt;/p&gt;
&lt;p&gt;更深入一点来说的话，在函数 &lt;code&gt;whatJob()&lt;/code&gt; 或者 &lt;code&gt;growUp()&lt;/code&gt; 内部，接口 &lt;code&gt;person&lt;/code&gt; 绑定了实体类型 &lt;code&gt;*Student&lt;/code&gt; 或者 &lt;code&gt;Programmer&lt;/code&gt;。根据前面分析的 &lt;code&gt;iface&lt;/code&gt; 源码，这里会直接调用 &lt;code&gt;fun&lt;/code&gt; 里保存的函数，类似于： &lt;code&gt;s.tab-&amp;gt;fun[0]&lt;/code&gt;，而因为 &lt;code&gt;fun&lt;/code&gt; 数组里保存的是实体类型实现的函数，所以当函数传入不同的实体类型时，调用的实际上是不同的函数实现，从而实现多态。&lt;/p&gt;
&lt;p&gt;运行一下代码：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;I am a student.
{19}
I am a programmer.
{100}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;接口定义了一种规范，描述了类的行为和功能，而不做具体实现。&lt;/p&gt;
&lt;p&gt;C++ 的接口是使用抽象类来实现的，如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。纯虚函数是通过在声明中使用 &quot;= 0&quot; 来指定的。例如：&lt;/p&gt;
&lt;pre class=&quot;c++&quot;&gt;
&lt;code&gt;class Shape
{
   public:
      // 纯虚函数
      virtual double getArea() = 0;
   private:
      string name;      // 名称
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;设计抽象类的目的，是为了给其他类提供一个可以继承的适当的基类。抽象类不能被用于实例化对象，它只能作为接口使用。&lt;/p&gt;
&lt;p&gt;派生类需要明确地声明它继承自基类，并且需要实现基类中所有的纯虚函数。&lt;/p&gt;
&lt;p&gt;C++ 定义接口的方式称为“侵入式”，而 Go 采用的是 “非侵入式”，不需要显式声明，只需要实现接口定义的函数，编译器自动会识别。&lt;/p&gt;
&lt;p&gt;C++ 和 Go 在定义接口方式上的不同，也导致了底层实现上的不同。C++ 通过虚函数表来实现基类调用派生类的函数；而 Go 通过 &lt;code&gt;itab&lt;/code&gt; 中的 &lt;code&gt;fun&lt;/code&gt; 字段来实现接口变量调用实体类型的函数。C++ 中的虚函数表是在编译期生成的；而 Go 的 &lt;code&gt;itab&lt;/code&gt; 中的 &lt;code&gt;fun&lt;/code&gt; 字段是在运行期间动态生成的。原因在于，Go 中实体类型可能会无意中实现 N 多接口，很多接口并不是本来需要的，所以不能为类型实现的所有接口都生成一个 &lt;code&gt;itab&lt;/code&gt;， 这也是“非侵入式”带来的影响；这在 C++ 中是不存在的，因为派生需要显示声明它继承自哪个基类。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/51420568-305b1800-1bce-11e9-962a-52b12be7eb2e.png&quot; alt=&quot;QR&quot;/&gt;&lt;/p&gt;

&lt;p&gt;【包含反射、接口等源码分析】&lt;a href=&quot;https://zhuanlan.zhihu.com/p/27055513&quot; class=&quot;uri&quot;&gt;https://zhuanlan.zhihu.com/p/27055513&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【虚函数表和C++的区别】&lt;a href=&quot;https://mp.weixin.qq.com/s/jU9HeR1tOyh-ME5iEYM5-Q&quot; class=&quot;uri&quot;&gt;https://mp.weixin.qq.com/s/jU9HeR1tOyh-ME5iEYM5-Q&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【具体类型向接口赋值】&lt;a href=&quot;https://tiancaiamao.gitbooks.io/go-internals/content/zh/07.2.html&quot; class=&quot;uri&quot;&gt;https://tiancaiamao.gitbooks.io/go-internals/content/zh/07.2.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【Go夜读群的讨论】&lt;a href=&quot;https://github.com/developer-learning/reading-go/blob/master/content/discuss/2018-08-30-understanding-go-interfaces.md&quot; class=&quot;uri&quot;&gt;https://github.com/developer-learning/reading-go/blob/master/content/discuss/2018-08-30-understanding-go-interfaces.md&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【廖雪峰 鸭子类型】&lt;a href=&quot;https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431865288798deef438d865e4c2985acff7e9fad15e3000&quot; class=&quot;uri&quot;&gt;https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431865288798deef438d865e4c2985acff7e9fad15e3000&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【值类型和指针类型，iface源码】&lt;a href=&quot;https://www.jianshu.com/p/5f8ecbe4f6af&quot; class=&quot;uri&quot;&gt;https://www.jianshu.com/p/5f8ecbe4f6af&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【总体说明itab的生成方式、作用】&lt;a href=&quot;http://www.codeceo.com/article/go-interface.html&quot; class=&quot;uri&quot;&gt;http://www.codeceo.com/article/go-interface.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【conv系列函数的作用】&lt;a href=&quot;https://blog.csdn.net/zhonglinzhang/article/details/85772336&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/zhonglinzhang/article/details/85772336&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【convI2I itab作用】&lt;a href=&quot;https://www.jianshu.com/p/a5e99b1d50b1&quot; class=&quot;uri&quot;&gt;https://www.jianshu.com/p/a5e99b1d50b1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【interface 源码解读 很不错 包含反射】&lt;a href=&quot;http://wudaijun.com/2018/01/go-interface-implement/&quot; class=&quot;uri&quot;&gt;http://wudaijun.com/2018/01/go-interface-implement/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【what why how思路来写interface】&lt;a href=&quot;http://legendtkl.com/2017/06/12/understanding-golang-interface/&quot; class=&quot;uri&quot;&gt;http://legendtkl.com/2017/06/12/understanding-golang-interface/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【有汇编分析，不错】&lt;a href=&quot;http://legendtkl.com/2017/07/01/golang-interface-implement/&quot; class=&quot;uri&quot;&gt;http://legendtkl.com/2017/07/01/golang-interface-implement/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【第一幅图可以参考 gdb调试】&lt;a href=&quot;https://www.do1618.com/archives/797/golang-interface%E5%88%86%E6%9E%90/&quot;&gt;https://www.do1618.com/archives/797/golang-interface%E5%88%86%E6%9E%90/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【类型转换和断言】&lt;a href=&quot;https://my.oschina.net/goal/blog/194308&quot; class=&quot;uri&quot;&gt;https://my.oschina.net/goal/blog/194308&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【interface 和 nil】&lt;a href=&quot;https://my.oschina.net/goal/blog/194233&quot; class=&quot;uri&quot;&gt;https://my.oschina.net/goal/blog/194233&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【函数和方法】&lt;a href=&quot;https://www.jianshu.com/p/5376e15966b3&quot; class=&quot;uri&quot;&gt;https://www.jianshu.com/p/5376e15966b3&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【反射】&lt;a href=&quot;https://flycode.co/archives/267357&quot; class=&quot;uri&quot;&gt;https://flycode.co/archives/267357&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【接口特点列表】&lt;a href=&quot;https://segmentfault.com/a/1190000011451232&quot; class=&quot;uri&quot;&gt;https://segmentfault.com/a/1190000011451232&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【interface 全面介绍，包含C++对比】&lt;a href=&quot;https://www.jianshu.com/p/b38b1719636e&quot; class=&quot;uri&quot;&gt;https://www.jianshu.com/p/b38b1719636e&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【Go四十二章经 interface】&lt;a href=&quot;https://github.com/ffhelicopter/Go42/blob/master/content/42_19_interface.md&quot; class=&quot;uri&quot;&gt;https://github.com/ffhelicopter/Go42/blob/master/content/42_19_interface.md&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【对Go接口的反驳，有说到接口的定义】&lt;a href=&quot;http://blog.zhaojie.me/2013/04/why-i-dont-like-go-style-interface-or-structural-typing.html&quot; class=&quot;uri&quot;&gt;http://blog.zhaojie.me/2013/04/why-i-dont-like-go-style-interface-or-structural-typing.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【gopher 接口】&lt;a href=&quot;http://fuxiaohei.me/2017/4/22/gopherchina-2017.html&quot; class=&quot;uri&quot;&gt;http://fuxiaohei.me/2017/4/22/gopherchina-2017.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【译文 还不错】&lt;a href=&quot;https://mp.weixin.qq.com/s/tBg8D1qXHqBr3r7oRt6iGA&quot; class=&quot;uri&quot;&gt;https://mp.weixin.qq.com/s/tBg8D1qXHqBr3r7oRt6iGA&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【infoQ 文章】&lt;a href=&quot;https://www.infoq.cn/article/go-interface-talk&quot; class=&quot;uri&quot;&gt;https://www.infoq.cn/article/go-interface-talk&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【Go接口详解】&lt;a href=&quot;https://zhuanlan.zhihu.com/p/27055513&quot; class=&quot;uri&quot;&gt;https://zhuanlan.zhihu.com/p/27055513&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【Go interface】&lt;a href=&quot;https://sanyuesha.com/2017/07/22/how-to-understand-go-interface/&quot; class=&quot;uri&quot;&gt;https://sanyuesha.com/2017/07/22/how-to-understand-go-interface/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【getitab源码说明】&lt;a href=&quot;https://www.twblogs.net/a/5c245d59bd9eee16b3db561d&quot; class=&quot;uri&quot;&gt;https://www.twblogs.net/a/5c245d59bd9eee16b3db561d&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【浅显易懂】&lt;a href=&quot;https://yami.io/golang-interface/&quot; class=&quot;uri&quot;&gt;https://yami.io/golang-interface/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【golang io包的妙用】&lt;a href=&quot;https://www.jianshu.com/p/8c33f7c84509&quot; class=&quot;uri&quot;&gt;https://www.jianshu.com/p/8c33f7c84509&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【探索C++与Go的接口底层实现】&lt;a href=&quot;https://www.jianshu.com/p/073c09a05da7&quot; class=&quot;uri&quot;&gt;https://www.jianshu.com/p/073c09a05da7&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://github.com/teh-cmc/go-internals/blob/master/chapter2_interfaces/README.md&quot; class=&quot;uri&quot;&gt;https://github.com/teh-cmc/go-internals/blob/master/chapter2_interfaces/README.md&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【汇编层面】&lt;a href=&quot;http://xargin.com/go-and-interface/&quot; class=&quot;uri&quot;&gt;http://xargin.com/go-and-interface/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【有图】&lt;a href=&quot;https://i6448038.github.io/2018/10/01/Golang-interface/&quot; class=&quot;uri&quot;&gt;https://i6448038.github.io/2018/10/01/Golang-interface/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【图】&lt;a href=&quot;https://mp.weixin.qq.com/s/px9BRQrTCLX6BbvXJbysCA&quot; class=&quot;uri&quot;&gt;https://mp.weixin.qq.com/s/px9BRQrTCLX6BbvXJbysCA&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【英文开源书】&lt;a href=&quot;https://github.com/cch123/go-internals/blob/master/chapter2_interfaces/README.md&quot; class=&quot;uri&quot;&gt;https://github.com/cch123/go-internals/blob/master/chapter2_interfaces/README.md&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【曹大的翻译】&lt;a href=&quot;http://xargin.com/go-and-interface/&quot; class=&quot;uri&quot;&gt;http://xargin.com/go-and-interface/&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 24 Apr 2019 22:23:00 +0000</pubDate>
<dc:creator>Stefno</dc:creator>
<og:description>基本涉及到了 interface 的方方面面，有例子、有源码分析、有汇编分析。直接从 10 个问题出发，深度解答。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qcrao-2018/p/10766091.html</dc:identifier>
</item>
<item>
<title>基本查询 - 马一特</title>
<link>http://www.cnblogs.com/mayite/p/10766060.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mayite/p/10766060.html</guid>
<description>&lt;h2 id=&quot;一-sql查询基本结构&quot;&gt;一 SQL查询基本结构&lt;/h2&gt;
&lt;p&gt;SQL查询是由三个基本语句构成，&lt;code&gt;select&lt;/code&gt;，&lt;code&gt;from&lt;/code&gt;和&lt;code&gt;where&lt;/code&gt;，更多的语句也是在这个基础上进行拓展。&lt;code&gt;from&lt;/code&gt;后面添加模型关系，在这些关系上进行&lt;code&gt;where&lt;/code&gt;和&lt;code&gt;select&lt;/code&gt;语句中指定的运算，然后产生一个关系作为结果，查询的结果是一个元组。&lt;/p&gt;
&lt;h2 id=&quot;二-单关系模型查询&quot;&gt;二 单关系模型查询&lt;/h2&gt;
&lt;p&gt;我们使用如下结构构建我们的表结构和数据。&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;# 使用use + 库名切换数据库 
use db1;

# 部门表
create table department
(
    department_name varchar(20),
    building        varchar(15),
    budget          numeric(12, 0),
    primary key (department_name)
);

# 产品表
create table product
(
    # 用int类型 改成自动增长的主键
    product_id      int primary key auto_increment,
    title           varchar(20) not null,
    credits         numeric(8, 0),
    department_name varchar(20),
    foreign key (department_name) references department (department_name)
        on update cascade
        on delete cascade
);

# 人员表
create table staff
(
    staff_id        varchar(10),
    name            varchar(15) not null,
    age             int,

    # 关联的外键与被关联外键数据类型应该一致
    product_id      int,
    department_name varchar(20),

    primary key (staff_id),
    foreign key (product_id) references product (product_id),
    foreign key (department_name) references department (department_name)
        on update cascade
        on delete cascade
);

insert into department(department_name, building, budget)
values ('市场部', '市场部大楼', 35000000),
       ('研发部', '研发部大楼', 20000000),
       ('人事部', '人事部大楼', 1000000);


insert into product(title, credits, department_name)
values ('1号产品', 888888, '研发部'),
       ('2号产品', 7777, '研发部'),
       ('3号产品', 999999, '研发部'),
       ('4号产品', 100000, '市场部'),
       ('5号产品', 5000000, '人事部');

insert into staff(staff_id, name, age, department_name,product_id)
values ('1', 'Albert', 18, '市场部',1),
       ('2', 'James', 35, '市场部',2),
       ('3', '刘德华', 50, '研发部',3),
       ('4', '张学友', 35, '人事部',4),
       ('5', '孙悟空', 500, '人事部',5);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;单模型关系基本的查询语句使用起来非常简单，就像讲话一样方便。&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;# 1 找出所有的产品
select title
from product;

# 2 找出负责所有的产品的部分
select department_name
from product;
# 这样看到的结果会有重复，保留重复元组在大部分的数据库软件中是默认的，如异，可以使用all指明不重复
select all department_name
from product;
# 我们希望看到的结果肯定是没有重复的，在必要的地方使用distinct来完成基本去重
select distinct department_name
from product;

# 3 select中可以使用 + - * / 算数运算，这只是查询结果的的改变，不会影响模型关系的任何变化
select budget + 10000000
from department;
select budget - 800000
from department;
select budget * 1.1
from department;
select budget * 2
from department;

# 4 where允许只选出满足特定条件的元组

# (1) 查出年龄超过100的员工
select name
from staff
where age &amp;gt; 100;

# (2) 查出年龄超过30的市场部人员
select name
from staff
where age &amp;gt; 30
  and department_name = '市场部';&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;三-多关系模型查询&quot;&gt;三 多关系模型查询&lt;/h2&gt;
&lt;h3 id=&quot;多表查询基本形式&quot;&gt;1. 多表查询基本形式&lt;/h3&gt;
&lt;p&gt;依然是上面的表结构，这里面有三个模型关系，我们可以是使用非常简单的查询语句&lt;code&gt;select * from 表名&lt;/code&gt;查询出每个表的数据如下：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;人事部&lt;/td&gt;
&lt;td&gt;人事部大楼&lt;/td&gt;
&lt;td&gt;1000000&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;市场部&lt;/td&gt;
&lt;td&gt;市场部大楼&lt;/td&gt;
&lt;td&gt;35000000&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;研发部&lt;/td&gt;
&lt;td&gt;研发部大楼&lt;/td&gt;
&lt;td&gt;20000000&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1号产品&lt;/td&gt;
&lt;td&gt;888888&lt;/td&gt;
&lt;td&gt;研发部&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;2号产品&lt;/td&gt;
&lt;td&gt;7777&lt;/td&gt;
&lt;td&gt;研发部&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;3号产品&lt;/td&gt;
&lt;td&gt;999999&lt;/td&gt;
&lt;td&gt;研发部&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;4号产品&lt;/td&gt;
&lt;td&gt;100000&lt;/td&gt;
&lt;td&gt;市场部&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;5号产品&lt;/td&gt;
&lt;td&gt;5000000&lt;/td&gt;
&lt;td&gt;人事部&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;Albert&lt;/td&gt;
&lt;td&gt;18&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;市场部&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;James&lt;/td&gt;
&lt;td&gt;35&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;市场部&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;刘德华&lt;/td&gt;
&lt;td&gt;50&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;研发部&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;张学友&lt;/td&gt;
&lt;td&gt;35&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;人事部&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;孙悟空&lt;/td&gt;
&lt;td&gt;500&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;人事部&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;如果我们需要查询出所有的员工名字以及他们负责的产品和所在的部门，就需要找一个关联关系进行跨表查询。&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;select distinct name, title, staff.department_name
from department,
     product,
     staff
where staff.department_name = product.department_name;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;查询语句的理解&quot;&gt;2. 查询语句的理解&lt;/h3&gt;
&lt;p&gt;再来看一下&lt;code&gt;select&lt;/code&gt;，&lt;code&gt;from&lt;/code&gt;和&lt;code&gt;where&lt;/code&gt;三个语句的作用：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;select语句用于列出查询结果所需要的属性&lt;/li&gt;
&lt;li&gt;from语句是查询求值中需要访问的关系模型&lt;/li&gt;
&lt;li&gt;where语句是作用在from语句关系之上的限制要求&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;where限制要求是可选项，如果没有where语句，则限制要求默认为True。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;尽管查询语句必须以&lt;code&gt;select&lt;/code&gt;，&lt;code&gt;from&lt;/code&gt;，&lt;code&gt;where&lt;/code&gt;这样的次序书写，但理解查询所代表的运算最容易的方式是按照运算的顺序来看：首先是from，然后是where，最后是select。&lt;/p&gt;
&lt;h3 id=&quot;查询过程说明&quot;&gt;3. 查询过程说明&lt;/h3&gt;
&lt;p&gt;查询过程是迭代循环，可能在这个过程中不同关系模型中会出现相同的属性名，所以我们在属性名前面加上关系名作为说明，表示该属性来自于哪个关系。如果是单个关系模型，我们通常会去掉关系名，因为这样不会造成任何混淆。查询结果是求笛卡尔积，如果我们我们不指定条件，使用&lt;code&gt;select * from department,product,staff&lt;/code&gt;语句，那么即使是我们测试的数据量这么小，得出的结果也会使你眼花缭乱，而且得出的这些组合也是没有意义的，where语句就是限制笛卡尔积所建立的组合，只留下那些对所需答案有意义的组合。&lt;/p&gt;
&lt;h2 id=&quot;四-自然连接&quot;&gt;四 自然连接&lt;/h2&gt;
&lt;h3 id=&quot;自然连接说明&quot;&gt;1. 自然连接说明&lt;/h3&gt;
&lt;p&gt;在多关系模型查询中我们往往需要多个表的组合信息，匹配条件是属性名相同，为了简化SQL开发者的工作，我们可以使用&lt;code&gt;自然连接&lt;/code&gt;作用在模型关系之上，自然连接会自动的将多关系模型中的所有元组进行连接，重要的是：自然连接只考虑那些在多关系模型中都出现的属性相同的元组对。&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;# 查询每个部门所负责的产品

# 不实用自然连接
select product.department_name, title
from department,
     product
where department.department_name = product.department_name;

# 使用自然连接
select product.department_name, title
from department
         natural join product;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;多关系自然连接&quot;&gt;2. 多关系自然连接&lt;/h3&gt;
&lt;p&gt;自然连接可以两个关系连接，也可以多个关系连接。&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;# 查出一个人负责一个产品的人，产品和所在部门，然后给他涨工资
select name, title, department_name
from staff
         natural join department
         natural join product;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;自然连接的结果依然是关系，所以在自然连接之后的结果依然可以像模型关系那样使用在from语句中。&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;select name, title
from staff
         natural join department,
     product;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;自然连接扬长避短&quot;&gt;3. 自然连接扬长避短&lt;/h3&gt;
&lt;p&gt;自然连接会只考虑那些在多关系模型中都出现的属性相同的元组对，也就是说会考虑多关系模型中所有属性相同的元组对，而在有些时候，我们并不需要所有的元组对。为了发扬自然连接的有点，同时避免不必要的相等的属性带来的限制，SQL提供了一种自然连接的构造形式，允许用书来指定需要哪些属性相等，我们使用&lt;code&gt;using&lt;/code&gt;语句来完成，这时是限制性连接而不是自然连接，所以&lt;code&gt;natural&lt;/code&gt;关键字就不再需要了。&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;select name, title
from staff
         natural join product
         join department using (department_name);&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;五-sql附加运算&quot;&gt;五 SQL附加运算&lt;/h2&gt;
&lt;h3 id=&quot;更名运算&quot;&gt;1. 更名运算&lt;/h3&gt;
&lt;p&gt;数据库设计者为了查询方便，有些字段名会使用一样的，对于调用者在复杂查询中就可能会混淆。而有些时候这个字段名又会很长，调用者使用不方便，这时我们可以使用as对属性名做更名。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select department_name as Dname
from department;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;as可以使用在select中也可以使用在from中&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;select D.department_name as Dname, title as T
from department as D,
     product as P
where D.department_name = P.department_name;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要注意的是：在一些SQL版本，尤其是Oracle中，不允许在from中使用&lt;code&gt;as&lt;/code&gt;，但是也有同样的功能，所以这并不影响大局，Oracle中会把&lt;code&gt;select department_name as Dname&lt;/code&gt;语句写成&lt;code&gt;select department_name Dname&lt;/code&gt;，幸运的是，在MySQL中&lt;code&gt;as&lt;/code&gt;也可以省略，所以影响不大(把以上语句所有as都去掉依然可以正常执行)。&lt;/p&gt;
&lt;h3 id=&quot;字符串运算&quot;&gt;2. 字符串运算&lt;/h3&gt;
&lt;h4 id=&quot;sql标准&quot;&gt;(1) SQL标准&lt;/h4&gt;
&lt;p&gt;在SQL标准中，字符串的相等运算是大小写敏感的，所以在表达式&lt;code&gt;staff.name = staff.Name&lt;/code&gt;的结果是假，然而在一些特定的数据库，如&lt;code&gt;MySQL&lt;/code&gt;和&lt;code&gt;SQL Server&lt;/code&gt;中，默认并不区分大小写，所以返回结果可能为真，但是这种默认方式是可以在数据库级或者特定属性级做修改的。SQL中还允许在字符串上有变种函数，如&lt;code&gt;upper(s)&lt;/code&gt;，&lt;code&gt;lower(s)&lt;/code&gt;和&lt;code&gt;trim(s)去除空格&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&quot;like匹配&quot;&gt;(2) like匹配&lt;/h4&gt;
&lt;p&gt;在字符串上可以使用&lt;code&gt;like&lt;/code&gt;操作符来实现模式匹配。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;百分号&lt;code&gt;%&lt;/code&gt;：匹配任意字符串&lt;/li&gt;
&lt;li&gt;下划线&lt;code&gt;_&lt;/code&gt;：匹配任意一个字符，模式匹配中大小写是敏感的，例如：&lt;code&gt;Pro%&lt;/code&gt;匹配任何以‘Pro’开头的字符串，&lt;code&gt;% Pro %&lt;/code&gt;匹配任何包含‘Pro’的字符串。&lt;/li&gt;
&lt;li&gt;三个下划线&lt;code&gt;___&lt;/code&gt;：匹配只包含三个字符的字符串&lt;/li&gt;
&lt;li&gt;&lt;code&gt;___%&lt;/code&gt;：匹配至少包含三个字符的字符串&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;为了使模式中能够包含特殊模式的字符(百分号或者下划线)，SQL中允许定义转义字符，使用的时候转义字符直接放在特殊字符前面，在&lt;code&gt;like&lt;/code&gt;比较运算中使用&lt;code&gt;escape&lt;/code&gt;关键字来定义转义字符。&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;# \ 为定义的转义字符，

# 转义第一个%为字符串，匹配所有以abc%d开头的字符串
like 'abc\%d %' escape '\'
# 第一个\为转义字符，匹配所有以abc\d开头的字符串
like 'abc\\d %' escape '\'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;SQL中还允许使用&lt;code&gt;not like&lt;/code&gt;比较运算搜索不匹配项。&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;# 匹配所有不是以abc%d开头的字符串
not like 'abc\%d %' escape '\'&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;正则匹配&quot;&gt;(3) 正则匹配&lt;/h4&gt;
&lt;p&gt;SQL可以支持使用&lt;code&gt;REGEXP&lt;/code&gt;来进行正则匹配，用法和Python，PHP等语言非常类似，这里我们给出几个简单的示例。&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;select *
from staff
where name REGEXP 'A.';

select *
from staff
where name REGEXP '^A';

select *
from staff
where name REGEXP 't$';

select *
from staff
where name REGEXP '[abc]';

select *
from staff
where name REGEXP '[^abc]';

select *
from staff
where name REGEXP '[a|b|c]';&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;序列运算&quot;&gt;3. 序列运算&lt;/h3&gt;
&lt;h4 id=&quot;基本排序&quot;&gt;(1) 基本排序&lt;/h4&gt;
&lt;p&gt;SQL为用户提供了一种对关系中元组显示次序的控制，使用&lt;code&gt;order by&lt;/code&gt;语句可以时候查询结果中的元组按照排列顺序显示。&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;# 按照年龄大小排序，默认是升序
select name
from staff
order by age;
# 添加desc改为降序
select name
from staff
order by age desc;

# 按照字符编码表排序，默认是从前往后，asc可以省略
select name
from staff
order by name asc;

# 从后往前排序
select name
from staff
order by name desc;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;时间排序&quot;&gt;(2) 时间排序&lt;/h4&gt;
&lt;p&gt;除此之外，我们常用的还有按照时间排序，这些我们先介绍以下用于存储时间的数据类型。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;date：日期，包括年月日&lt;/li&gt;
&lt;li&gt;time：一天当中的时间，包括时分秒&lt;/li&gt;
&lt;li&gt;timestamp：data与time的组合，包括年月日和时分秒&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;除此之外，SQL中定义了一些函数获取当前的时间和日期。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;current_date：当前日期&lt;/li&gt;
&lt;li&gt;current_time：当前时间(带有时区，时区可以在配置文件中设置，也可手动加减)&lt;/li&gt;
&lt;li&gt;localtime：当前本地时间，与&lt;code&gt;select now()&lt;/code&gt;结果一样&lt;/li&gt;
&lt;li&gt;current_timestamp：带有时区的时间戳(时间戳指的是年月日和时分秒的组合，从Unix元年1970年开始计时)&lt;/li&gt;
&lt;li&gt;localtimestamp：本地时间戳&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;create table time1
(
    name      char(10),
    data_time date
);

create table time2
(
    name      char(10),
    time_time time
);

create table time3
(
    name           char(10),
    timestamp_time timestamp
);


insert into time1 (name, data_time)
values ('1', '2001-04-25'),
       ('2', '2021-04-25'),
       ('3', '2011-01-25'),
       ('4', '2001-12-02'),
       ('5', '2001-04-05'),
       ('6', '2001-04-11');

# 插入数据的时候可以随意一些，但是存储的时候还是按照规范2001-04-11存储
insert into time1 (name, data_time)
values ('1', '2001-04-5'),
       ('2', '2001-4-11');

insert into time2 (name, time_time)
values ('1', '09:30:00'),
       ('2', '21:4:11'),
       ('3', '00:4:11'),
       ('4', '21:14:11'),
       ('5', '21:42:11'),
       ('6', '21:47:11');

insert into time3 (name, timestamp_time)
values ('1', '2001-04-5 09:30:00'),
       ('2', '2011-04-5 09:30:00'),
       ('4', '2011-04-5 01:30:00'),
       ('5', '2011-04-5 10:30:00'),
       ('6', '2011-04-5 01:30:01');

select *
from time1
order by data_time;

select *
from time1
order by data_time desc;

select *
from time2
order by time_time;

select *
from time2
order by time_time desc;

select *
from time3
order by timestamp_time;

select *
from time3
order by timestamp_time desc;

select current_date;
select current_time;
select localtime;
select now();
select current_timestamp;
select localtimestamp;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;比较运算&quot;&gt;4. 比较运算&lt;/h3&gt;
&lt;h4 id=&quot;between比较&quot;&gt;(1) between比较&lt;/h4&gt;
&lt;p&gt;为了简化where语句，SQL提供了&lt;code&gt;between&lt;/code&gt;比较运算符来说明一个值小于等于某个值，同时打不等于另外一个值。&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;use db1;

# 不支持 30 &amp;lt;= age &amp;lt;= 100
select name
from staff
where age &amp;lt;= 100
  and age &amp;gt;= 30;

select name
from staff
where age between 30 and 100;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同理，我们还是可以使用&lt;code&gt;not between&lt;/code&gt;来做排除筛选&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;select name
from staff
where age not between 30 and 100;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;分量比较&quot;&gt;(2) 分量比较&lt;/h4&gt;
&lt;p&gt;在SQL中使用(v1,v2,v3,...,vn)来表示一个分量的值分别为v1，v2，v3，vn的n维元组，在元组上可以使用比较运算，按照字典的顺序进行一对一比较，比如&lt;code&gt;(a1,a2) &amp;lt;= (b1,b2)&lt;/code&gt;，则代表&lt;code&gt;a1&amp;lt;=b1&lt;/code&gt;并且&lt;code&gt;a2&amp;lt;=b2&lt;/code&gt;，同理，比较相当的时候也是一样的。&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;# 查出研发部负责3号产品的人
select name
from staff,
     product
where (product.title, staff.department_name) = ('3号产品', '研发部');&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;集合运算&quot;&gt;5. 集合运算&lt;/h3&gt;
&lt;h4 id=&quot;集合运算说明&quot;&gt;(1) 集合运算说明&lt;/h4&gt;
&lt;p&gt;SQL中有语句&lt;code&gt;union&lt;/code&gt;，&lt;code&gt;intersect&lt;/code&gt;和&lt;code&gt;except&lt;/code&gt;分别对应数学集合中并，交，差运算。&lt;/p&gt;
&lt;h4 id=&quot;并运算&quot;&gt;(2) 并运算&lt;/h4&gt;
&lt;p&gt;与select语句不同的是，union语句会自动去除重复。&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;select name
from staff
where staff.product_id = 1;


(select name
 from staff,
      product
 where staff.product_id = 1)
union
(select name
 from staff,
     product
 where staff.product_id = 2);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果我们希望保留重复，需使用&lt;code&gt;union all&lt;/code&gt;代替&lt;code&gt;union&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;(select name
 from staff,
      product
 where staff.product_id = 1)
union all
(select name
 from staff,
     product
 where staff.product_id = 2);&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;交运算&quot;&gt;(3) 交运算&lt;/h4&gt;
&lt;p&gt;非常遗憾的是MySQL中没有交运算的&lt;code&gt;instersect&lt;/code&gt;语句，但是这样的语句在Oracle，PostgreSQL和SQL Server中都是有的。&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;# 适用于Oracle，PostgreSQL和SQL Server
(select name
 from staff
 where staff.department_name = '市场部');
instersect
(select name
 from staff
 where staff.product_id = 2);
# instersect 语句会自动去重，如果希望显示全部结果，在后面添加一个all即可

# MySQL中等价用法可以用分量比较
select name
from staff
where (staff.product_id, staff.department_name) = (2, '市场部');&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;差运算&quot;&gt;(4) 差运算&lt;/h4&gt;
&lt;p&gt;MySQL中也没有差运算的&lt;code&gt;except&lt;/code&gt;,但是在PostgreSQL和SQL Server中有，Oracle中使用&lt;code&gt;MINUS&lt;/code&gt;语句来实现同样的功能，并运算和交运算都很好理解，差运算这里说明一下：指的是前一个结果关系中有而后一个结果关系中没有，也就是前一个比后一个多的部分，即前一个减去后一个，这也就是差的来源。&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;# PostgreSQL和SQL Server
(select name
 from staff
 where staff.department_name = '市场部');
except
(select name
 from staff
 where staff.product_id = 2);
# 同理，自动去重，可以加all显示全部&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;MySQL中类似于差运算的语句将会在我们下一章节的内容中讲解。&lt;/p&gt;
&lt;h3 id=&quot;空值运算&quot;&gt;6. 空值运算&lt;/h3&gt;
&lt;p&gt;在生产环境中，数据库出现空值是很常见的，空值运算也给我们带来了特殊的问题。如果在比较运算中出现&lt;code&gt;1 &amp;gt; null&lt;/code&gt;这样的语句，由于我们不知道空值代表的是什么，所以也发评定结果是为真还是为假，但是根据我们的逻辑语句来推理，如果&lt;code&gt;1 &amp;gt; null&lt;/code&gt;为真，那么&lt;code&gt;not (1 &amp;gt; null)&lt;/code&gt;就应该为假，反之，亦然。但是这却并没有什么意义，数据库设计者为了程序的健壮性，将涉及空值的任何比较运算的结果视为&lt;code&gt;unknown&lt;/code&gt;，这是除了&lt;code&gt;true&lt;/code&gt;和&lt;code&gt;false&lt;/code&gt;之外的第三个逻辑。由于where语句可以使用&lt;code&gt;and&lt;/code&gt;，&lt;code&gt;or&lt;/code&gt;和&lt;code&gt;not&lt;/code&gt;做逻辑运算，所以&lt;code&gt;unknown&lt;/code&gt;也被扩展到这三个关键字上面。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;and：&lt;code&gt;ture and unknown&lt;/code&gt;的结果是&lt;code&gt;unknown&lt;/code&gt;，&lt;code&gt;false and unknown&lt;/code&gt;的结果是false，&lt;code&gt;unknown and unknown&lt;/code&gt;的结果是&lt;code&gt;unknown&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;or：&lt;code&gt;ture or unknown&lt;/code&gt;的结果是true，&lt;code&gt;false or unknown&lt;/code&gt;的结果是&lt;code&gt;unknown&lt;/code&gt;，&lt;code&gt;unknown or unknown&lt;/code&gt;的结果是&lt;code&gt;unknown&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;not：&lt;code&gt;not unknown&lt;/code&gt;的结果是&lt;code&gt;unknown&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如果是在where语句中对一个元组计算出false或者unknown，那么该元组自然不能被加入到结果中。在where语句中可以使用特殊关键字&lt;code&gt;null&lt;/code&gt;来测试空值，也允许使用&lt;code&gt;is unknown&lt;/code&gt;来测试一个表达式的结果是否为unknown，它们两种的用法前面添加&lt;code&gt;not&lt;/code&gt;自然也是可以使用的。&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;# 插入空值
insert into staff(staff_id, name, product_id)
values ('6', '小龙女', 1);

select *
from staff;

# 找空值
select *
from staff
where age is null;

select *
from staff
where age is not null;

# 条件为unknown
select *
from staff
where name = '小龙女'
  and age &amp;gt; 15;

# 认为条件正确，取其结果
select *
from staff
where (name = '小龙女'
    and age &amp;gt; 15) is unknown;

# unknown is True 自然是false，无结果
select *
from staff
where (name = '小龙女'
    and age &amp;gt; 15) is true;

# 认为条件不正确，取反
select *
from staff
where (name = '小龙女'
    and age &amp;gt; 15) is FALSE;&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 24 Apr 2019 18:37:00 +0000</pubDate>
<dc:creator>马一特</dc:creator>
<og:description>一 SQL查询基本结构 SQL查询是由三个基本语句构成， ，`from where from where select`语句中指定的运算，然后产生一个关系作为结果，查询的结果是一个元组。 二 单关系模</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mayite/p/10766060.html</dc:identifier>
</item>
<item>
<title>[译]背景：着色的物理和数学(3) - BIT祝威</title>
<link>http://www.cnblogs.com/bitzhuwei/p/background-Physics-and-Math-of-Shading-3.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bitzhuwei/p/background-Physics-and-Math-of-Shading-3.html</guid>
<description>&lt;p&gt;&lt;span&gt;[译]背景：着色的物理和数学(3)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（译者注：本文是翻译的Naty Hoffman的《Background: Physics and Math of Shading》。我希望通过翻译此文，彻底理解PBR的原理。某些我实在不知道如何恰当翻译的地方，就把英文原文也放上了。）&lt;/p&gt;

&lt;p&gt;+BIT祝威+悄悄在此留下版了个权的信息说：&lt;/p&gt;

&lt;p&gt;文献中有几种下表面局部反射的模型，Lambertian模型[49]是最简单的，也是应用最广泛的。Lambertian的BRDF实际上是个常量；著名的cos或(nl)因子是反射率方程的一部分，不是BRDF的一部分（如我们在Equation 1所见）。Lambertian的BRDF值为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201904/383191-20190425010606256-71205485.png&quot; alt=&quot;&quot;/&gt;(7)&lt;/p&gt;
&lt;p&gt;这里，c&lt;sub&gt;diff&lt;/sub&gt;是diffuse反射的部分。像F&lt;sub&gt;0&lt;/sub&gt;一样，它是个RGB值，范围为[0, 1]，对应着大多数人认为的那个“表面颜色”。这个参数一般被称为&lt;span&gt;diffuse&lt;/span&gt;&lt;span&gt;颜色&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;其他的模型尝试引入Lambertian模型没有的现象，例如specular和diffuse项在掠射角下的能量分配问题。diffuse项对下表面反射建模，所以只能利用没有被表面反射出去的入射能量。某种意义上，specular项指着入射光能量大喊“归我了”，然后diffuse项只能用“剩下的”。由于菲涅耳效果使得specular项在掠射角增大，结果就是diffuse项在这些角度上必须减小。有很多研究想搞定这个问题，简单的有(用(1-菲涅耳因子)乘以diffuse项（用Schlick Fresnel项的一部分作为插值因子，使得BRDF有了在diffuse和specular项之间线性插值的形式）)，更复杂更精确的也有[2, 3, 41, 65]。&lt;/p&gt;
&lt;p&gt;（译者注：记住Lambertian模型就好，其他的暂时不重要）&lt;/p&gt;
&lt;p&gt;其他的diffuse模型尝试计入表面粗糙度的影响。很重要的一点是，要理解数量级在这个现象中的角色。如我们所见，下表面散射使得光在表面之下传输了一段距离，之后才被重新放出（反射出去）。小于这段距离的表面不规则性质都对下表面反射没有影响，因为任何反射出来的光都已经进入过大于这个不规则地带的表面了。但是，某些表面的粗糙范围比散射距离更大，这会展示出与Lambertian模型明显不同的外观。多种模型已经被开发出来解决这个问题[32, 60]。很多人误以为这些模型是用于渲染特别粗糙的表面的，其实并不是——关键的判据不是粗糙&lt;span&gt;程度&lt;/span&gt;，而是表面细节上相对与下表面散射距离的粗糙的&lt;span&gt;尺寸&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;+BIT祝威+悄悄在此留下版了个权的信息说：&lt;/p&gt;

&lt;p&gt;前文提过，在用diffuse项（multiple-bounce的下表面散射）和微平面项（single-bounce的表面反射）建模的现象中，有两种类型的反射现象被忽略了。&lt;/p&gt;
&lt;p&gt;一个是下表面单次散射，即光的一部分被拆分进入表面，经历一次散射，然后就被折射出表面外。这一现象同时展示了diffuse和specular的特征；它高度依赖角度，它还会受表面下的介质的属性影响。&lt;/p&gt;
&lt;p&gt;另一个现象是multiple-bounce的表面反射，即光在离开表面前被表面上多个点反射过。如前文所述，微平面模型忽略了多次表面反射——它实际上假设所有被遮蔽的光线都损失掉了，因此它比真实世界多了一些能量损失。&lt;/p&gt;
&lt;p&gt;引入额外的BRDF项以涵盖这两种现象也许是可行的，但是目前还没有关于它们的已发表的良好的模型。注意，这些现象也会影响(区分下表面反射和表面反射)的方法（例如偏振测定polarimetry）。例如，single-bounce的下表面反射大量保留了偏振（译者注：不懂），所以用偏振测定法测量的“表面反射”也会包含这一现象的部分贡献。&lt;/p&gt;

&lt;p&gt;之前的章节中，我们看到了典型的用于描述表面反射的数学模型。本节我们将简要讨论这样的模型是如何运用到电影和游戏产品中的。&lt;/p&gt;
&lt;p&gt;为实现一个着色模型，需要联系一个&lt;span&gt;光照模型&lt;/span&gt;。接下来的章节，我们将简述最常见类型的光照模型，以及如何将它们与BRDF联系起来。&lt;/p&gt;

&lt;p&gt;在最一般的情况下，BRDF必须被集成到所有方向的入射光上。这包括天空光和场景中其他物体反射的光。为解决这问题，全局光照算法（例如蒙特卡罗光线追踪）是必需的。这些算法的详情超出本文的范围，但是在很多参考资料[17, 24, 31, 42, 43]中可以找到详细介绍。&lt;/p&gt;

&lt;p&gt;基于图像的光照(Image-based Lighting)一般将光照信息存储到环境贴图中。环境贴图可以很容易地表示光滑（镜子那样的）物体的反射特征。菲涅耳反射率用Equation 5建模（用观察者向量代替光向量（到镜像法线的角度不变，所以代替前后是一样的））。困难点在于表面法线背向观察者方向时（可能由插值的法线或凹凸映射引起），这会同时影响反射方向和菲涅耳反射率（尽管错误的反射方向几乎不会被注意到）。如前文所述，裁剪为0或用绝对值都可以避免观察者与法线的点积为负数；在此特殊情形下，更倾向于采用绝对值。不像裁剪为0，取绝对值会把(掠射角相关的菲涅耳值)限制到(一个很窄的像素带上)，这样看起来比较真实。&lt;/p&gt;
&lt;p&gt;环境贴图也可以被用与任意BRDF函数，但可能需要多次采样才能避免噪音，得到精确的结果。重要性采样[14]有助于将采样量保持在可控的范围内（至少对电影渲染时）。环境贴图前置过滤[39, 40]是另一个产品级的有效方案：它自己（施展单独的前置过滤采样——游戏中常用，电影中不常用）或联合重要性采样[13, 14]。虽然单独的前置过滤采样原则上是反射率公式的粗放近似， 但只要好好用它还是很高效的。It is important to ensure that the prefiltering process accounts for the environment map representation used [36] as well as the shape and size of the NDF lobe [38, 46, 50]. 然后，读取前置过滤采样的时候，要乘以一个近似反射率积分的因子。这可以看作将积分分解为两个因子相乘：前置过滤环境贴图查询因子和用于shader的因子[22, 28, 38, 50]。&lt;/p&gt;
&lt;p&gt;理论上，一个环境贴图只能用于一个物体的反射。这个环境贴图要要描述从一个靠近物体的点观察到的场景（不包含此物体本身）的样子，物体本身要是凸的，并远离周围场景。实际中很多这些假设都不成立。Non-convex objects should self-occlude the environment——this can be ignored (common in games), approximated with some simple occlusion term such as AO [29], or modeled more accurately by tracing rays against some representation of the object [22, 57, 67]. Reflected objects may also be close enough to have noticeable parallax over different surface points——especially common when the reflecting object is large. Finally, the environment map may be sampled from a different location in the scene, or even from a different scene entirely. It turns out that in many cases, the human eye is largely insensitive to the errors caused by parallax or use of environment maps away from their sample location. As long as the overall color and intensity is correct, the shapes being reflected can often be completely wrong without the viewer noticing. It is fairly straightforward to match the overall color and intensity of an environment map to local scene lighting [50], making environment maps an effective tool in many situations. Instances where incorrect reflections are noticeable (e.g. shiny floors, the player's car in a racing game, a shiny metallic hero character in a movie) can often be addressed by warping the reflections as a corrective step [47, 48, 67].&lt;/p&gt;
&lt;p&gt;+BIT祝威+悄悄在此留下版了个权的信息说：&lt;/p&gt;

&lt;p&gt;太阳和台灯这样的光源，既有强度又有面积。理论上，它们可以用环境贴图中的一批HDR纹素处理，但是单独对待它们有更多的好处。(根据面积光源)计算阴影比(根据基于图像的光照)简单，视差可以被处理得更准确，艺术家也更容易调整光源的位置、亮度和尺寸，而不需要编辑基于图像的光照表示。&lt;/p&gt;
&lt;p&gt;用面积光源对任意BRDF着色也比基于图像光照容易。多重重要性采样[72]可以大幅减少噪声[54]（这一技术也可以用于基于图像的光照，但是对面积光源特别有效）。实时近似方案也有[22, 38]，且越来越受欢迎。&lt;/p&gt;

&lt;p&gt;在游戏中（电影中也有），经常用精确光源近似模拟面积光源。经典的计算机图形学的点光源、平行光、聚光灯（也有更复杂一点的[5]）都是精确光源。它们是无限小，无限亮的，所以不是现实世界可能存在的。但是它们很多时候能给出合理的结果，计算起来也很方便。&lt;/p&gt;
&lt;p&gt;精确光源照射到表面点上的效果由2个量决定：光的颜色c&lt;sub&gt;light&lt;/sub&gt;和光的方向l&lt;sub&gt;c&lt;/sub&gt;。不同类型的精确光源，这些量在场景中可能是常量（平行光），也可能是变量（点光源随着距离衰减，其方向由物体和光源共同决定）。为便于可视化，c&lt;sub&gt;light&lt;/sub&gt;一般被定义为在理想表面（100%的Lambertian表面，法线与光的方向l&lt;sub&gt;c&lt;/sub&gt;平行）上的反射的辐射率。与其他颜色量类似，c&lt;sub&gt;light&lt;/sub&gt;是个RGB值，但其值没有边界。&lt;/p&gt;
&lt;p&gt;我们稍后将看到，精确光源最大的优势是极大地简化了辐射率方程(Equation 1)。我们从(一个表面点被一个单独的很小的面积光源照射)开始。光源被包裹进一个椎体里，角半径为ε，朝向l&lt;sub&gt;c&lt;/sub&gt;，所以这个椎体外没有任何入射光：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201904/383191-20190425010638863-1791988488.png&quot; alt=&quot;&quot;/&gt;(8)&lt;/p&gt;
&lt;p&gt;我们根据c&lt;sub&gt;light&lt;/sub&gt;的定义来测量面积光源在给定表面点上的光照。换句话说，c&lt;sub&gt;light&lt;/sub&gt;等于表面点将会反射的辐射率（当材质是100%的白色Lambertian且其法线等于l&lt;sub&gt;c&lt;/sub&gt;）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201904/383191-20190425010647784-503896865.png&quot; alt=&quot;&quot;/&gt;(9)&lt;/p&gt;
&lt;p&gt;这就是将Equation 1和7的c&lt;sub&gt;diff&lt;/sub&gt;指定为1、n指定为l&lt;sub&gt;c&lt;/sub&gt;。现在我们将ε设置为0，使得c&lt;sub&gt;ligh&lt;/sub&gt;为常量。由于我们将ε（l&lt;sub&gt;c&lt;/sub&gt;和l之间的最大角度）设置为0，我们可以认定（l&lt;sub&gt;c&lt;/sub&gt;·l）=1。此时得到了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201904/383191-20190425010656742-774592006.png&quot; alt=&quot;&quot;/&gt;(10)&lt;/p&gt;
&lt;p&gt;简单安排一下，将积分隔离出来：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201904/383191-20190425010704728-263578954.png&quot; alt=&quot;&quot;/&gt;(11)&lt;/p&gt;
&lt;p&gt;现在我们要把我们的小小面积光源放到通用的BRDF函数中，看一下在ε逼近0时它的行为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201904/383191-20190425010713842-1249814459.png&quot; alt=&quot;&quot;/&gt;(12)&lt;/p&gt;
&lt;p&gt;注意，在Equation 12中，通过提取f(l&lt;sub&gt;c&lt;/sub&gt;, v)和(n·l&lt;sub&gt;c&lt;/sub&gt;)， 我们实际上交换了求极限和积分的顺序。只要BRDF函数f()表现正常（实际中用的所有BRDF肯定都是），这个交换就是有意义的。用Equation 11代替Equation 12的右边部分，我们就得到了最终的精确光源公式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201904/383191-20190425010724079-1026426069.png&quot; alt=&quot;&quot;/&gt;(13)&lt;/p&gt;
&lt;p&gt;与原始的反射率公式相比，我们用单值的BRDF代替了积分，这在计算上很廉价。游戏中，经常将(点积裁切到0)作为跳过背面光贡献的简便方法。&lt;/p&gt;
&lt;p&gt;上文提过，在平行光（例如太阳）情况下，l&lt;sub&gt;c&lt;/sub&gt;和c&lt;sub&gt;light&lt;/sub&gt;在整个场景中都是常量。对于其他类型的精确光源（点光源和聚光灯），这两个数值会变化。现实中，c&lt;sub&gt;light&lt;/sub&gt;会随着距离平方的倒数的速度衰减，但在实践中常常使用其他衰减函数（为了性能（在有限距离内衰减为0就可以避免远距离物体的光照计算）或艺术效果）。&lt;/p&gt;
&lt;p&gt;如果多个精确光源在照射表面，那么就将Equation 13多次计算，将结果相加。精确光源很少单独使用，因为缺失(从其他方向的光照)很明显，特别是高度specular的表面。，因此，精确光源经常和某种环境光或基于图像的光联合使用。后者我们讨论过了，前者将在下一节讨论。&lt;/p&gt;
&lt;p&gt;+BIT祝威+悄悄在此留下版了个权的信息说：&lt;/p&gt;

&lt;p&gt;这里我们将环境光定义为某种低频光照的表达，简单时是在所有方向上都相同的颜色和强度，复杂时是球面调和函数(SH)。这种光照类型常常放入BRDF的diffuse项，高频的、基于图像的光照则放入specular项。但是，把环境光放入specular项也是可能的。大多数这方面的已发表的方法都是从游戏工业引发的[11, 27, 64]。&lt;/p&gt;

&lt;p&gt;本节，我们将探讨从零开始建设一个模型。关于将非物理模型转换为基于物理的模型的讨论，请参考我们的SIGGRAPH 2010展示[35]。&lt;/p&gt;
&lt;p&gt;当要根据上文讨论的原则来建设一个基于物理的模型时，需要做出几个选择。需要选择一个diffuse模型，用于微平面specular模型的D()（法线分布函数）和G()（几何函数）也要选择。本节剩下的部分将关注这两个specular函数。&lt;/p&gt;
&lt;p&gt;对D()和G()函数的选择，在某种程度上是相互独立的（对“某种程度”的解释可参考“选择几何函数”一节）。大多数论文给出的心微平面BRDF模型都可以被理解为是在引入一个新的D()和/或G()函数。&lt;/p&gt;
&lt;p&gt;+BIT祝威+悄悄在此留下版了个权的信息说：&lt;/p&gt;

&lt;p&gt;最常见的NDF是各向同性的——它们关于由微平面表面法线n定义的轴是旋转对称的。这意味着NDF可以被定义为一个变量（m（微观几何体的法线）和n之间的角度）的函数。在shader中，最方便处理的是cos值，因为可以用点积来计算。因此，各向同性的NDF函数一般被写成n•m的函数。NDF相关的文献中已经给出了很多这样的函数，但是，它们必须全都被恰当地&lt;span&gt;标准化&lt;/span&gt;之后才能用于微平面的BRDF。少数各向异性的NDF函数也被用于电影和游戏产业了，但由于篇幅的原因我们就仅限在各向同性的NDF里讨论了。&lt;/p&gt;
&lt;p&gt;任何微观几何体分布函数都需要满足这样的要求：从任何角度看，可见的微观几何体面积加起来等于可见的微表面面积。跟准确地说，微观几何体的带符号投影面积的和要等于微观表面的带符号投影面积；这必须对所有观察角度都为真[73]。数学上，这意味着函数对任意的v必须满足下述公式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201904/383191-20190425010736533-1745327112.png&quot; alt=&quot;&quot;/&gt;(14)&lt;/p&gt;
&lt;p&gt;注意，积分包含了整个球体，不是半球，cos因子没有被裁切——背面表面有负数的贡献。这个公式对所有微表面有效，不只是对高度领域。特别的，当v=n：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201904/383191-20190425010743827-1755755840.png&quot; alt=&quot;&quot;/&gt;(15)&lt;/p&gt;
&lt;p&gt;对BRDF的求值，追求的是NDF越容易计算越好，特别是在游戏和其他实时渲染应用程序中。对于光线追踪，每次采样都无比重要。&lt;/p&gt;
&lt;p&gt;我们这里评审的所有微观几何体法线分布函数都被设计为仅用于计算前向的微观几何体的法线（即n•m≥0——这可以被理解为在高度领域建模，绝不会出现微观几何体法线与微表面法线夹角超过90°）。&lt;/p&gt;
&lt;p&gt;这些函数不是用来对负值的n•m求解的，如果用了，就会出现意想不到的结果。在强制实施前向光照和观察方向的渲染器中，这不是问题，因为半向量（NDF的计算目标）也会前向。另外，法线插值和凹凸映射可能导致背向的观察向量，进而导致背向的半向量。这一般通过将n•m裁剪为0或（如果是在分母上，为避免除以零）一个很小的正数来解决。&lt;/p&gt;
&lt;p&gt;Phong着色公式[61]是计算机图形文献中最早（也绝对是最有影响力的）提出的着色公式。&lt;/p&gt;
&lt;p&gt;几年后它被Blinn[7]修改 为更适合微平面结构的BRDF（这一修改被通常被称为Blinn-Phong的BRDF，但是我们将简单地称它的NDF为“Phong NDF”）。尽管Blinn没有声明标准化因子，它也很容易计算：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201904/383191-20190425010753318-431438760.png&quot; alt=&quot;&quot;/&gt;(16)&lt;/p&gt;
&lt;p&gt;指数&lt;em&gt;α&lt;/em&gt;&lt;em&gt;&lt;sub&gt;p&lt;/sub&gt;&lt;/em&gt;是Phong NDF的“粗糙度”参数，高数值表示光滑平面，低数值表示粗糙平面。对于非常光滑的表面，此参数可以是任意大（完美的镜子会要求&lt;em&gt;α&lt;/em&gt;&lt;em&gt;&lt;sub&gt;p&lt;/sub&gt;&lt;/em&gt;=∞）。如果设置&lt;em&gt;α&lt;/em&gt;&lt;em&gt;&lt;sub&gt;p&lt;/sub&gt;&lt;/em&gt;为0，就会实现一个最大限度随机的表面(均匀的NDF)。&lt;em&gt;α&lt;/em&gt;&lt;em&gt;&lt;sub&gt;p&lt;/sub&gt;&lt;/em&gt;参数不便于艺术家操作或绘画，因为它的影响非常不均匀。在&lt;em&gt;α&lt;/em&gt;&lt;em&gt;&lt;sub&gt;p&lt;/sub&gt;&lt;/em&gt;很小的时候，很小的改变就会引起很大的视觉变化，但是大的&lt;em&gt;α&lt;/em&gt;&lt;em&gt;&lt;sub&gt;p&lt;/sub&gt;&lt;/em&gt;值在变化很大后都不怎么影响视觉效果。因此，常用方法是让艺术家操作一个通过非线性方式继承了&lt;em&gt;α&lt;/em&gt;&lt;em&gt;&lt;sub&gt;p&lt;/sub&gt;&lt;/em&gt;的“中间值”。例如，&lt;em&gt;α&lt;/em&gt;&lt;em&gt;&lt;sub&gt;p&lt;/sub&gt;&lt;/em&gt;=m&lt;sup&gt;s&lt;/sup&gt;，其中s是艺术家来操作的一个介于0和1之间的数值，m是一个给定的游戏或show中&lt;em&gt;α&lt;/em&gt;&lt;em&gt;&lt;sub&gt;p&lt;/sub&gt;&lt;/em&gt;的上限。当BRDF的内部参数不便于直接用于生产应用时，这样的“中间函数”相当有用。Figure 30 shows Phong distribution curves for cosine powers evenly spaced according to a logarithmic scale.&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201904/383191-20190425010804941-1822085928.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在Blinn吸收了Phong着色函数并融入微平面NDF的论文[7]中，他还提出了2个其他的NDF。其中一个继承自Torrance-Sparrow的BRDF[70]。比较Torrance-Sparrow的BRDF和Phong，会发现它花费的计算代价高得多，取得的效果却很相似（详见随本讲义的数学笔记），所以这是死路一条。后来Cook和Torrance[15, 16]提出用一个新的NDF代替它，即Beckmann分布。正确地标准化之后，Beckmann分布有如下的形式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201904/383191-20190425010811331-1365262356.png&quot; alt=&quot;&quot;/&gt;(17)&lt;/p&gt;
&lt;p&gt;Beckmann分布在某些方面和Phong分布很相似，但是其他方面有根本不同。根据关系式&lt;em&gt;α&lt;/em&gt;&lt;em&gt;&lt;sub&gt;p&lt;/sub&gt;&lt;/em&gt;=2&lt;em&gt;α&lt;sub&gt;b&lt;/sub&gt;&lt;/em&gt;&lt;sup&gt;-2&lt;/sup&gt; - 2[73]，可以找到这两个参数的相同的值，他们对相对光滑的表面（&lt;em&gt;α&lt;/em&gt;&lt;em&gt;&lt;sub&gt;b&lt;/sub&gt;&lt;/em&gt;＜0.5左右——更高的&lt;em&gt;α&lt;/em&gt;&lt;em&gt;&lt;sub&gt;b&lt;/sub&gt;&lt;/em&gt;对应更粗糙的表面，这与&lt;em&gt;α&lt;/em&gt;&lt;em&gt;&lt;sub&gt;p&lt;/sub&gt;&lt;/em&gt;相反）的反应很接近，如Figure 31左侧所示。对更光滑（&lt;em&gt;α&lt;/em&gt;&lt;em&gt;&lt;sub&gt;b&lt;/sub&gt;&lt;/em&gt;＜0.1）的表面，就接近得完美了。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201904/383191-20190425010820052-757523844.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;鉴于Beckmann的表现与Phong相似，计算代价却更高，看起来它也是条死路。但是，它们参数的不同导致了其结果的根本性区别。参数&lt;em&gt;α&lt;/em&gt;&lt;em&gt;&lt;sub&gt;b&lt;/sub&gt;&lt;/em&gt;等于微观几何体表面斜率的平方根。所以增加&lt;em&gt;α&lt;/em&gt;&lt;em&gt;&lt;sub&gt;b&lt;/sub&gt;&lt;/em&gt;意味着增加微观几何体的平均斜率，这比“粗糙度”的“增加随机性”（通过减小&lt;em&gt;α&lt;/em&gt;&lt;em&gt;&lt;sub&gt;p&lt;/sub&gt;&lt;/em&gt;）更加不同。Phong分布有个“最大粗糙度”参数值（&lt;em&gt;α&lt;/em&gt;&lt;em&gt;&lt;sub&gt;p&lt;/sub&gt;&lt;/em&gt;=0，对应均匀的分布，其微观几何体的法线朝向半球上各个方向的概率都相同），对应的参数值（&lt;em&gt;α&lt;/em&gt;&lt;em&gt;&lt;sub&gt;b&lt;/sub&gt;&lt;/em&gt;=1）对Beckmann却没有特殊的含义——它仅仅是表示微观几何体斜率的平方根为1，即45°。对于&lt;em&gt;α&lt;/em&gt;&lt;em&gt;&lt;sub&gt;b&lt;/sub&gt;&lt;/em&gt;的中庸的值，我们可以看到Beckmann在分布的中间出现一个“下沉”，而不是Phong的水平直线（见Figure 31右侧）。当&lt;em&gt;α&lt;/em&gt;&lt;em&gt;&lt;sub&gt;b&lt;/sub&gt;&lt;/em&gt;增长超过1后你会得到“超级粗糙”的表面，其微观几何体斜率的平方根很大——这比均匀分布的随机性弱，但在平坦方面更“粗糙”。观察曲线（Figure 32），我们可以看到随着粗糙度增加，分布中的“下沉”在90°变成了“反向高峰“（实际上是ring）。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201904/383191-20190425010826339-2493790.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这样“超级粗糙”的分布，对于建模现实世界的表面，有用吗？可能吧，由许多尖锐的纤维组成的表面可能会有这样的分布，绒状的微观结构在某种程度上与此分布也类似[1, 75]——其他材质也是可能的。无论如何，了解一些Beckmann分布在高值&lt;em&gt;α&lt;/em&gt;&lt;em&gt;&lt;sub&gt;b&lt;/sub&gt;&lt;/em&gt;的行为还是很好的，不然，它只是一个Phong NDF的昂贵版本。&lt;/p&gt;
&lt;p&gt;Blinn的论文[7]中提到的最后一个NDF（也是Blinn推荐使用的）来自Trowbridge和Reitz[71]。Blinn也没用为Trowbridge-Reitz NDF标明一个标准化因子，但是后来有篇论文[73]——称其为“GGX分布”——却给出了正确的因子。由于GGX分母的形式稍微复杂点（但是等价），我们使用的是原始版，其形式如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201904/383191-20190425010833996-1492754305.png&quot; alt=&quot;&quot;/&gt;(18)&lt;/p&gt;
&lt;p&gt;Figure 33展示了在参数&lt;em&gt;α&lt;/em&gt;&lt;em&gt;&lt;sub&gt;tr&lt;/sub&gt;&lt;/em&gt;上的表现。增加参数值，表面就比较粗糙，这与Beckmann相似。Trowbridge-Reitz可以建模出一个均匀的分布（像Phong一样），也可以建模出一个“超级粗糙”的表面（像Beckmann一样）。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201904/383191-20190425010842578-457259655.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;当比较Trowbridge-Reitz分布和Phong分布时（Figure 34），很明显，两种分布的图形有根本性区别。在参数空间上，Trowbridge-Reitz一致地表现出比Phong更窄的峰值（对于在高光中心给出相同值的参数值），围绕峰值的“尾巴”也更长。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201904/383191-20190425010848357-1354544470.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Burley[10]提出了Trowbridge-Reitz的一个简单的“中间函数”：&lt;em&gt;α&lt;/em&gt;&lt;em&gt;&lt;sub&gt;tr&lt;/sub&gt;&lt;/em&gt;=s&lt;sup&gt;2&lt;/sup&gt;，其中s艺术家操作的值，范围为0-1。&lt;/p&gt;
&lt;p&gt;着色模型需要在对真实世界建模时有良好的性能。数位研究者[20, 53, 55]已经发表了测量过的BRDF数据[18, 19, 56]，其他人用这些数据（或者他们自己的测量数据）与多种着色模型比较过[10, 52, 76]。这些比较倾向于展示出许多材质没有被任何现有模型良好地建模了。最近，更多的研究用于开发专门为可测量的表面进行建模的模型[4, 10, 51]。我们用三个最近发表的这方面的工作作为我们对NDF的总览的结尾。&lt;/p&gt;
&lt;p&gt;（译者注：这三种模型离我很远，暂时不翻译也不妨碍我目前的学习，所以就省略了。）&lt;/p&gt;
&lt;p&gt;列出所有这些NDF之后，问题是应该选哪个。高光的空间变化一般比形状更重要。既然这样，使用Phong的NDF像是最简单的，它的计算简单，表现力合理。如果需要更真实的高光效果，那么Trowbridge-Reitz是和不错的选择，它的“宽边帽”形状像是比高斯Phong瓣更接近真实世界的材质。Trowbridge-Reitz还有个优势就是已经成功地应用到了电影和游戏中[10, 38, 54, 59]。如果需要更惊艳的NDF，那么在刚刚被讨论过的2参数各向同性NDF（译者注：就是刚刚省略的ABC，SGD和GTR）中，我推荐GTR分布。它比另2种简单点，也成功地用到过电影上[10]。但是，艺术家操作这样的NDF的空间分布是比较难的。一种可能的帮助是，减少参数空间的维度（定义一个一维空间——基于艺术家的品味或材质数据——然后向艺术家暴露一个参数线。另一个可能的帮助是，只暴露一个参数，将另一个设置为对每种材质分别为一个常量。这样，一个再参数化功能就可用了，用来更干净地区分开“光滑度”和“形状”。一个可能用的到的研究是，使用概率分布的统计量，例如方差和峰态（似乎对应了可视化的“光滑度”和“尖刺度”）。&lt;/p&gt;
&lt;p&gt;+BIT祝威+悄悄在此留下版了个权的信息说：&lt;/p&gt;

&lt;p&gt; 未完待续。。&lt;/p&gt;
</description>
<pubDate>Wed, 24 Apr 2019 17:12:00 +0000</pubDate>
<dc:creator>BIT祝威</dc:creator>
<og:description>[译]背景：着色的物理和数学(3) （译者注：本文是翻译的Naty Hoffman的《Background: Physics and Math of Shading》。我希望通过翻译此文，彻底理解PB</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bitzhuwei/p/background-Physics-and-Math-of-Shading-3.html</dc:identifier>
</item>
<item>
<title>Socket模拟HTTP请求 - 东小东</title>
<link>http://www.cnblogs.com/dongxiaodong/p/10724394.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dongxiaodong/p/10724394.html</guid>
<description>&lt;p&gt;WEB服务器可以可以理解为socket的上层封装，其也是TCP/IP协议，只要知道其IP地址和端口号就可以与他进行通信了&lt;/p&gt;
&lt;p&gt;与WEB服务器数据交互，其重点在于请求头，如果请求头不对则不能进行数据传输&lt;/p&gt;
&lt;p&gt;简单的概念理解就是Socket模拟HTTP请求&lt;/p&gt;
&lt;h2&gt;ESP8266测试&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;web服务器代码：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;访问网页即输出当前时间&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485202/201904/1485202-20190417161945539-307800301.png&quot; alt=&quot;&quot; width=&quot;593&quot; height=&quot;226&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;连接：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485202/201904/1485202-20190417161753094-1752848613.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;网页请求：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485202/201904/1485202-20190417161844518-838247170.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 调试：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485202/201904/1485202-20190417162112898-1226839052.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt; 相关请求头&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt; get请求：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;需要携带数据可以直接通过time.php?xx=1&amp;amp;yy=3&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
GET /wx/time.php HTTP/&lt;span&gt;1.1&lt;/span&gt;\r\nHost: &lt;span&gt;193.112&lt;/span&gt;.11&lt;span&gt;.16&lt;/span&gt;\r\nConnection:keep-alive\r\n\r\n
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;post携带数据请求：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
POST /wan.php HTTP/&lt;span&gt;1.1&lt;/span&gt;&lt;span&gt;
Host: &lt;/span&gt;&lt;span&gt;172.16&lt;/span&gt;.&lt;span&gt;105.177&lt;/span&gt;&lt;span&gt;
Content&lt;/span&gt;-Length:&lt;span&gt;16&lt;/span&gt;&lt;span&gt;
Content&lt;/span&gt;-Type:application/x-www-form-&lt;span&gt;urlencoded
Connection:keep&lt;/span&gt;-&lt;span&gt;alive

y&lt;/span&gt;=&lt;span&gt;12345&lt;/span&gt;&amp;amp;x=&lt;span&gt;123456&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485202/201904/1485202-20190417162715458-1606024735.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 24 Apr 2019 17:09:00 +0000</pubDate>
<dc:creator>东小东</dc:creator>
<og:description>WEB服务器可以可以理解为socket的上层封装，其也是TCP/IP协议，只要知道其IP地址和端口号就可以与他进行通信了 与WEB服务器数据交互，其重点在于请求头，如果请求头不对则不能进行数据传输 简</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dongxiaodong/p/10724394.html</dc:identifier>
</item>
<item>
<title>asp.net core 系列之并发冲突 - Vincent-yuan</title>
<link>http://www.cnblogs.com/Vincent-yuan/p/10765989.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Vincent-yuan/p/10765989.html</guid>
<description>
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;本文介&lt;span class=&quot;fontstyle1&quot;&gt;绍&lt;span class=&quot;fontstyle0&quot;&gt;如何&lt;span class=&quot;fontstyle1&quot;&gt;处&lt;span class=&quot;fontstyle0&quot;&gt;理多个用&lt;span class=&quot;fontstyle1&quot;&gt;户&lt;span class=&quot;fontstyle0&quot;&gt;并&lt;span class=&quot;fontstyle1&quot;&gt;发&lt;span class=&quot;fontstyle0&quot;&gt;更新同一&lt;span class=&quot;fontstyle1&quot;&gt;实&lt;span class=&quot;fontstyle0&quot;&gt;体（同&lt;span class=&quot;fontstyle1&quot;&gt;时&lt;span class=&quot;fontstyle0&quot;&gt;）&lt;span class=&quot;fontstyle1&quot;&gt;时&lt;span class=&quot;fontstyle0&quot;&gt;出&lt;span class=&quot;fontstyle1&quot;&gt;现&lt;span class=&quot;fontstyle0&quot;&gt;的冲突 。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;主要是两种：一种，检查属性并发冲突，使用 [ConcurrencyCheck] ;另一种，检测行的并发冲突，使用 rowversion 跟踪属性，如果在保存之前有修改，就报错&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;发生并发冲突的情况：&lt;/h3&gt;
&lt;p&gt;　　1.用户导航到实体编辑页面；&lt;/p&gt;
&lt;p&gt;　　2.第一个用户的更改还未写入数据库之前，另一个用户更新同一实体；&lt;/p&gt;
&lt;p&gt;　　此时，如果未启用并发检测，当发生更新时：&lt;/p&gt;
&lt;p&gt;　　最后一个更新优先。即最后一个更新的值保存到数据库。而第一个保存的值将丢失。&lt;/p&gt;

&lt;h3&gt;举个例子：&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;1. Jane &lt;span class=&quot;fontstyle2&quot;&gt;访问&lt;span class=&quot;fontstyle3&quot;&gt;院系&lt;span class=&quot;fontstyle2&quot;&gt;编辑页&lt;span class=&quot;fontstyle3&quot;&gt;面，将英&lt;span class=&quot;fontstyle2&quot;&gt;语&lt;span class=&quot;fontstyle3&quot;&gt;系的&lt;span class=&quot;fontstyle2&quot;&gt;预&lt;span class=&quot;fontstyle3&quot;&gt;算&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;从 &lt;span class=&quot;fontstyle0&quot;&gt;350,000.00 &lt;span class=&quot;fontstyle3&quot;&gt;美元更改&lt;span class=&quot;fontstyle2&quot;&gt;为 &lt;span class=&quot;fontstyle0&quot;&gt;0.00 &lt;span class=&quot;fontstyle3&quot;&gt;美元 (第一个用户把金额改为0)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1182288/201904/1182288-20190425000430475-110032715.png&quot; alt=&quot;&quot;/&gt;，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;2.&lt;span class=&quot;fontstyle0&quot;&gt;在 &lt;span class=&quot;fontstyle2&quot;&gt;Jane &lt;span class=&quot;fontstyle3&quot;&gt;单击&lt;span class=&quot;fontstyle2&quot;&gt;“&lt;span class=&quot;fontstyle0&quot;&gt;保存&lt;span class=&quot;fontstyle2&quot;&gt;”&lt;span class=&quot;fontstyle0&quot;&gt;之前，&lt;span class=&quot;fontstyle2&quot;&gt;John &lt;span class=&quot;fontstyle3&quot;&gt;访问&lt;span class=&quot;fontstyle0&quot;&gt;了相同&lt;span class=&quot;fontstyle3&quot;&gt;页&lt;span class=&quot;fontstyle0&quot;&gt;面，并将开始日期字段从 &lt;span class=&quot;fontstyle2&quot;&gt;2007/1/9 &lt;span class=&quot;fontstyle0&quot;&gt;更改&lt;span class=&quot;fontstyle3&quot;&gt;为 &lt;span class=&quot;fontstyle2&quot;&gt;2013/1/9&lt;span class=&quot;fontstyle0&quot;&gt;。 (在第一个用户保存之前，第二个用户把时间从07年改为13年，注意此时第二个用户看到的金额还不是0)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1182288/201904/1182288-20190425000543468-942866823.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;em&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt; 3.&lt;span class=&quot;fontstyle0&quot;&gt;Jane &lt;span class=&quot;fontstyle2&quot;&gt;先&lt;span class=&quot;fontstyle3&quot;&gt;单击&lt;span class=&quot;fontstyle0&quot;&gt;“&lt;span class=&quot;fontstyle2&quot;&gt;保存&lt;span class=&quot;fontstyle0&quot;&gt;”&lt;span class=&quot;fontstyle2&quot;&gt;，并在&lt;span class=&quot;fontstyle3&quot;&gt;浏览&lt;span class=&quot;fontstyle2&quot;&gt;器&lt;span class=&quot;fontstyle3&quot;&gt;显&lt;span class=&quot;fontstyle2&quot;&gt;示索引&lt;span class=&quot;fontstyle3&quot;&gt;页时&lt;span class=&quot;fontstyle2&quot;&gt;看到她的更改。 (第一个用户先保存，并且可以在浏览器看到他的修改，金额变0，时间不变)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1182288/201904/1182288-20190425000629793-811547299.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;4.John &lt;span class=&quot;fontstyle2&quot;&gt;单击&lt;span class=&quot;fontstyle0&quot;&gt;“&lt;span class=&quot;fontstyle2&quot;&gt;编辑&lt;span class=&quot;fontstyle0&quot;&gt;”&lt;span class=&quot;fontstyle2&quot;&gt;页&lt;span class=&quot;fontstyle3&quot;&gt;面上的&lt;span class=&quot;fontstyle0&quot;&gt;“&lt;span class=&quot;fontstyle3&quot;&gt;保存&lt;span class=&quot;fontstyle0&quot;&gt;”&lt;span class=&quot;fontstyle3&quot;&gt;，但&lt;span class=&quot;fontstyle2&quot;&gt;页&lt;span class=&quot;fontstyle3&quot;&gt;面的&lt;span class=&quot;fontstyle2&quot;&gt;预&lt;span class=&quot;fontstyle3&quot;&gt;算仍&lt;span class=&quot;fontstyle2&quot;&gt;显&lt;span class=&quot;fontstyle3&quot;&gt;示&lt;span class=&quot;fontstyle2&quot;&gt;为 &lt;span class=&quot;fontstyle0&quot;&gt;350,000.00 &lt;span class=&quot;fontstyle3&quot;&gt;美元。 (第二个用户保存，此时的页面的预算显示未350000美元，时间为13年)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;其实这个结果取决于&lt;strong&gt;并发冲突的处理方式&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;首先声明，这是一个乐观并发冲突，那么什么是乐观并发冲突呢？&lt;/p&gt;
&lt;p&gt;乐观并发冲突允许发生并发冲突，并在并发冲突发生时作出正确的反映。&lt;/p&gt;

&lt;h3&gt;说了这么多，那么，并发冲突的处理方式呢？&lt;/h3&gt;
&lt;p&gt;1. 可以跟踪用户已修改的属性，并只更新数据库中相应的列。&lt;/p&gt;
&lt;p&gt;这样，当两个用户更新了不同的属性，下次查看时，都将生效。&lt;/p&gt;
&lt;p&gt;但是，这种方法，也有一些问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当对同一个属性进行竞争性更改的话，无法避免数据丢失&lt;/li&gt;
&lt;li&gt;通常不适用于web应用。&lt;span class=&quot;fontstyle0&quot;&gt;它需要&lt;span class=&quot;fontstyle1&quot;&gt;维&lt;span class=&quot;fontstyle0&quot;&gt;持重要状&lt;span class=&quot;fontstyle1&quot;&gt;态&lt;span class=&quot;fontstyle0&quot;&gt;，以便跟踪所有提取&lt;span class=&quot;fontstyle1&quot;&gt;值&lt;span class=&quot;fontstyle0&quot;&gt;和新&lt;span class=&quot;fontstyle1&quot;&gt;值&lt;span class=&quot;fontstyle0&quot;&gt;。 &lt;span class=&quot;fontstyle1&quot;&gt;维&lt;span class=&quot;fontstyle0&quot;&gt;持大量状&lt;span class=&quot;fontstyle1&quot;&gt;态&lt;span class=&quot;fontstyle0&quot;&gt;可能影响&lt;span class=&quot;fontstyle1&quot;&gt;应&lt;br/&gt;&lt;span class=&quot;fontstyle0&quot;&gt;用性能。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;可能会增加&lt;span class=&quot;fontstyle1&quot;&gt;应&lt;span class=&quot;fontstyle0&quot;&gt;用复&lt;span class=&quot;fontstyle1&quot;&gt;杂&lt;span class=&quot;fontstyle0&quot;&gt;性（与&lt;span class=&quot;fontstyle1&quot;&gt;实&lt;span class=&quot;fontstyle0&quot;&gt;体上的并&lt;span class=&quot;fontstyle1&quot;&gt;发检测&lt;span class=&quot;fontstyle0&quot;&gt;相比）。 &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;体现在例子中，就是如果&lt;span class=&quot;fontstyle0&quot;&gt;下次有人&lt;span class=&quot;fontstyle1&quot;&gt;浏览&lt;span class=&quot;fontstyle0&quot;&gt;英&lt;span class=&quot;fontstyle1&quot;&gt;语&lt;span class=&quot;fontstyle0&quot;&gt;系&lt;span class=&quot;fontstyle1&quot;&gt;时&lt;span class=&quot;fontstyle0&quot;&gt;，将看到 &lt;span class=&quot;fontstyle3&quot;&gt;Jane &lt;span class=&quot;fontstyle0&quot;&gt;和 &lt;span class=&quot;fontstyle3&quot;&gt;John&lt;br/&gt;&lt;span class=&quot;fontstyle0&quot;&gt;两个人的更改。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2.客户端优先&lt;/p&gt;
&lt;p&gt;即客户端的值优先于数据库存储的值。并且如果不对并发处理进行任何编码，将自动进行客户端优先&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;即John &lt;span class=&quot;fontstyle0&quot;&gt;的更改覆盖 &lt;span class=&quot;fontstyle3&quot;&gt;Jane &lt;span class=&quot;fontstyle0&quot;&gt;的更改 。也就是说，下次有人&lt;span class=&quot;fontstyle0&quot;&gt;浏览&lt;span class=&quot;fontstyle1&quot;&gt;英&lt;span class=&quot;fontstyle0&quot;&gt;语&lt;span class=&quot;fontstyle1&quot;&gt;系&lt;span class=&quot;fontstyle0&quot;&gt;时&lt;span class=&quot;fontstyle1&quot;&gt;，将看到 &lt;span class=&quot;fontstyle3&quot;&gt;2013/9/1 &lt;span class=&quot;fontstyle1&quot;&gt;和提取的&lt;span class=&quot;fontstyle0&quot;&gt;值 &lt;span class=&quot;fontstyle3&quot;&gt;350,000.00 &lt;span class=&quot;fontstyle1&quot;&gt;美元&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt; 3.存储优先&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;这种方式可以阻止在数据库中John的更改。并且可以&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;显&lt;span class=&quot;fontstyle1&quot;&gt;示&lt;span class=&quot;fontstyle0&quot;&gt;错误&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;消息&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;显&lt;span class=&quot;fontstyle1&quot;&gt;示数据的当前状&lt;span class=&quot;fontstyle0&quot;&gt;态&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;允&lt;span class=&quot;fontstyle0&quot;&gt;许&lt;span class=&quot;fontstyle1&quot;&gt;用&lt;span class=&quot;fontstyle0&quot;&gt;户&lt;span class=&quot;fontstyle1&quot;&gt;重新&lt;span class=&quot;fontstyle0&quot;&gt;应&lt;span class=&quot;fontstyle1&quot;&gt;用更改。 &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;处理并发&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;当属性配置&lt;span class=&quot;fontstyle1&quot;&gt;为&lt;span class=&quot;fontstyle0&quot;&gt;并&lt;span class=&quot;fontstyle1&quot;&gt;发&lt;span class=&quot;fontstyle0&quot;&gt;令牌&lt;span class=&quot;fontstyle1&quot;&gt;时&lt;span class=&quot;fontstyle0&quot;&gt;： &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;EF Core &lt;span class=&quot;fontstyle2&quot;&gt;验证&lt;span class=&quot;fontstyle3&quot;&gt;提取属性后是否未更改属性。 &lt;span class=&quot;fontstyle2&quot;&gt;调&lt;span class=&quot;fontstyle3&quot;&gt;用 &lt;span class=&quot;fontstyle0&quot;&gt;SaveChanges &lt;span class=&quot;fontstyle3&quot;&gt;或 &lt;span class=&quot;fontstyle0&quot;&gt;SaveChangesAsync &lt;span class=&quot;fontstyle2&quot;&gt;时&lt;span class=&quot;fontstyle3&quot;&gt;会&lt;span class=&quot;fontstyle2&quot;&gt;执&lt;span class=&quot;fontstyle3&quot;&gt;行此&lt;span class=&quot;fontstyle2&quot;&gt;检查&lt;span class=&quot;fontstyle3&quot;&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;如果提取属性后更改了属性，将引&lt;span class=&quot;fontstyle2&quot;&gt;发 &lt;span class=&quot;fontstyle0&quot;&gt;DbUpdateConcurrencyException&lt;span class=&quot;fontstyle3&quot;&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;数据&lt;span class=&quot;fontstyle1&quot;&gt;库&lt;span class=&quot;fontstyle0&quot;&gt;和数据模型必&lt;span class=&quot;fontstyle1&quot;&gt;须&lt;span class=&quot;fontstyle0&quot;&gt;配置&lt;span class=&quot;fontstyle1&quot;&gt;为&lt;span class=&quot;fontstyle0&quot;&gt;支持引&lt;span class=&quot;fontstyle1&quot;&gt;发 &lt;span class=&quot;fontstyle3&quot;&gt;DbUpdateConcurrencyException&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;strong&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;strong&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;检测&lt;span class=&quot;fontstyle1&quot;&gt;属性的并&lt;span class=&quot;fontstyle0&quot;&gt;发&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;冲突&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;可使用 &lt;span class=&quot;fontstyle2&quot;&gt;ConcurrencyCheck &lt;span class=&quot;fontstyle0&quot;&gt;特性在属性&lt;span class=&quot;fontstyle3&quot;&gt;级别检测&lt;span class=&quot;fontstyle0&quot;&gt;并&lt;span class=&quot;fontstyle3&quot;&gt;发&lt;span class=&quot;fontstyle0&quot;&gt;冲突。 &lt;span class=&quot;fontstyle3&quot;&gt;该&lt;span class=&quot;fontstyle0&quot;&gt;特性可&lt;span class=&quot;fontstyle3&quot;&gt;应&lt;span class=&quot;fontstyle0&quot;&gt;用于模型上的多个属性 。&lt;span class=&quot;fontstyle0&quot;&gt;[ConcurrencyCheck] &lt;span class=&quot;fontstyle2&quot;&gt;特性&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;strong&gt;检测&lt;/strong&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;strong&gt;行的并&lt;/strong&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;strong&gt;发&lt;/strong&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;strong&gt;冲突&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;要&lt;span class=&quot;fontstyle1&quot;&gt;检测&lt;span class=&quot;fontstyle0&quot;&gt;并&lt;span class=&quot;fontstyle1&quot;&gt;发&lt;span class=&quot;fontstyle0&quot;&gt;冲突，&lt;span class=&quot;fontstyle1&quot;&gt;请&lt;span class=&quot;fontstyle0&quot;&gt;将 &lt;span class=&quot;fontstyle3&quot;&gt;rowversion &lt;span class=&quot;fontstyle0&quot;&gt;跟踪列添加到模型。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle4&quot;&gt;注意：rowversion ，　&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle4&quot;&gt;1.它&lt;span class=&quot;fontstyle0&quot;&gt;是 &lt;span class=&quot;fontstyle2&quot;&gt;SQL Server &lt;span class=&quot;fontstyle0&quot;&gt;特定的。 其他数据&lt;span class=&quot;fontstyle3&quot;&gt;库&lt;span class=&quot;fontstyle0&quot;&gt;可能无法提供&lt;span class=&quot;fontstyle3&quot;&gt;类&lt;span class=&quot;fontstyle0&quot;&gt;似功能。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle4&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;2.&lt;span class=&quot;fontstyle0&quot;&gt;用于确定从数据&lt;span class=&quot;fontstyle1&quot;&gt;库&lt;span class=&quot;fontstyle0&quot;&gt;提取&lt;span class=&quot;fontstyle1&quot;&gt;实&lt;span class=&quot;fontstyle0&quot;&gt;体后未更改&lt;span class=&quot;fontstyle1&quot;&gt;实&lt;span class=&quot;fontstyle0&quot;&gt;体。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle4&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span&gt;数据库生成rowversion序号，该数字随着每次行的更新递增。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在 update 或 delete 命令中，where 子句中包括 rowversion提取值 的判断 。&lt;/p&gt;
&lt;p&gt;如果要更新的行已经修改，则 rowversion提取值与现在数据库中rowversion的值不匹配；&lt;/p&gt;
&lt;p&gt;update 或 delete 命令不能找到行。引发一个 &lt;span class=&quot;fontstyle0&quot;&gt;DbUpdateConcurrencyException 异常&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;例子&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;向 &lt;span class=&quot;fontstyle2&quot;&gt;Department &lt;span class=&quot;fontstyle3&quot;&gt;实&lt;span class=&quot;fontstyle0&quot;&gt;体添加跟踪属性&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.ComponentModel.DataAnnotations;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.ComponentModel.DataAnnotations.Schema;
&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; ContosoUniversity.Models
{
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Department
{
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DepartmentID { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
[StringLength(&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;, MinimumLength = &lt;span&gt;3&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
[DataType(DataType.Currency)]
[Column(TypeName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;money&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;decimal&lt;/span&gt; Budget { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
[DataType(DataType.Date)]
[DisplayFormat(DataFormatString &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{0:yyyy-MM-dd}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, ApplyFormatInEditMode = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)]
[Display(Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Start Date&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DateTime StartDate { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;? InstructorID { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }&lt;br/&gt;[Timestamp]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] RowVersion { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }   //跟踪属性&lt;br/&gt;&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Instructor Administrator { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ICollection&amp;lt;Course&amp;gt; Courses { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Timestamp 特性 指定此列包含在 update 和 delete 命令的 where 子句中。&lt;/p&gt;
&lt;p&gt;也可以用 Fluent API 指定跟踪属性：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
modelBuilder.Entity&amp;lt;Department&amp;gt;&lt;span&gt;()
.Property&lt;/span&gt;&amp;lt;&lt;span&gt;byte&lt;/span&gt;[]&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RowVersion&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
.IsRowVersion();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;以下代&lt;span class=&quot;fontstyle1&quot;&gt;码显&lt;span class=&quot;fontstyle0&quot;&gt;示更新 &lt;span class=&quot;fontstyle3&quot;&gt;Department &lt;span class=&quot;fontstyle0&quot;&gt;名称&lt;span class=&quot;fontstyle1&quot;&gt;时&lt;span class=&quot;fontstyle0&quot;&gt;由 &lt;span class=&quot;fontstyle3&quot;&gt;EF Core &lt;span class=&quot;fontstyle0&quot;&gt;生成的部分 &lt;span class=&quot;fontstyle3&quot;&gt;T-SQL&lt;span class=&quot;fontstyle0&quot;&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SET NOCOUNT ON;&lt;br/&gt;UPDATE [Department] SET [Name] &lt;/span&gt;=&lt;span&gt; @p0
WHERE [DepartmentID] &lt;/span&gt;= @p1 AND [RowVersion] =&lt;span&gt; @p2;&lt;br/&gt;SELECT [RowVersion]
FROM [Department]
WHERE @@ROWCOUNT &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt; AND [DepartmentID] = @p1;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;前面的&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;代&lt;span class=&quot;fontstyle1&quot;&gt;码显&lt;span class=&quot;fontstyle0&quot;&gt;示包含 &lt;span class=&quot;fontstyle3&quot;&gt;RowVersion &lt;span class=&quot;fontstyle0&quot;&gt;的 &lt;span class=&quot;fontstyle3&quot;&gt;WHERE &lt;span class=&quot;fontstyle0&quot;&gt;子句。 如果数据&lt;span class=&quot;fontstyle1&quot;&gt;库 &lt;span class=&quot;fontstyle3&quot;&gt;RowVersion &lt;span class=&quot;fontstyle0&quot;&gt;不等于 &lt;span class=&quot;fontstyle3&quot;&gt;RowVersion &lt;span class=&quot;fontstyle0&quot;&gt;参数（ &lt;span class=&quot;fontstyle3&quot;&gt;@p2&lt;br/&gt;&lt;span class=&quot;fontstyle0&quot;&gt;），&lt;span class=&quot;fontstyle1&quot;&gt;则&lt;span class=&quot;fontstyle0&quot;&gt;不更新行。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;@@ROWCOUNT &lt;span class=&quot;fontstyle2&quot;&gt;返回受上一&lt;span class=&quot;fontstyle3&quot;&gt;语&lt;span class=&quot;fontstyle2&quot;&gt;句影响的行数。 在没有行更新的情况下，&lt;span class=&quot;fontstyle0&quot;&gt;EF Core &lt;span class=&quot;fontstyle2&quot;&gt;引&lt;span class=&quot;fontstyle3&quot;&gt;发&lt;br/&gt;&lt;span class=&quot;fontstyle4&quot;&gt;DbUpdateConcurrencyException&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;此文主要是为了方便自己记录学习，如有错误，欢迎指正&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;这里附上参考资料：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;https://docs.microsoft.com/en-us/aspnet/core/data/ef-rp/concurrency?view=aspnetcore-2.2&amp;amp;tabs=visual-studio&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle4&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;strong&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle3&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle4&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 24 Apr 2019 17:04:00 +0000</pubDate>
<dc:creator>Vincent-yuan</dc:creator>
<og:description>本文介绍如何处理多个用户并发更新同一实体（同时）时出现的冲突 。 主要是两种：一种，检查属性并发冲突，使用 [ConcurrencyCheck] ;另一种，检测行的并发冲突，使用 rowversion</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Vincent-yuan/p/10765989.html</dc:identifier>
</item>
<item>
<title>[深度应用]·实战掌握Dlib人脸识别开发教程 - 小宋是呢</title>
<link>http://www.cnblogs.com/xiaosongshine/p/10765958.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaosongshine/p/10765958.html</guid>
<description>&lt;p&gt;个人网站--&amp;gt; &lt;a href=&quot;http://www.yansongsong.cn/&quot; data-cke-saved-href=&quot;http://www.yansongsong.cn/&quot;&gt;http://www.yansongsong.cn/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;项目GitHub地址--&amp;gt; &lt;a href=&quot;https://github.com/xiaosongshine/dlib_face_recognition&quot; data-cke-saved-href=&quot;https://github.com/xiaosongshine/dlib_face_recognition&quot;&gt;https://github.com/xiaosongshine/dlib_face_recognition&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;1.背景介绍&lt;/h3&gt;
&lt;p&gt;Dlib是一个深度学习开源工具，基于C++开发，也支持Python开发接口，功能类似于TensorFlow与PyTorch。但是由于Dlib对于人脸特征提取支持很好，有很多训练好的人脸特征提取模型供开发者使用，所以Dlib人脸识别开发很适合做人脸项目开发。&lt;/p&gt;
&lt;p&gt;上面所说的人脸识别开发，主要是指人脸验证，就是输入两张人脸照片，系统会对比输出0或者1，代表判断是否是同一个人。一般的人脸识别开发可以简单分为&lt;strong&gt;1.人脸特征建模&lt;/strong&gt;与&lt;strong&gt;2.使用人脸特征模型进行验证&lt;/strong&gt;（其实还应包括人脸对齐等,这些也可以划分到1中）。使用Dlib进行开发时，我们直接可以使用训练好的人脸特征提取模型，主要的工作就变成了如何进行人脸的验证。&lt;/p&gt;
&lt;p&gt;人脸的验证其实就是计算相似度，同一个人的相似度就会大，不同的人就会比较小。可以采用余弦相似度或者欧式距离来计算相似度。其中余弦相似度就是计算角度，欧式距离就是指平方差。都可以用来表示两个特征的相似度（距离）。&lt;/p&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;2.环境搭建&lt;/h3&gt;
&lt;p&gt;安装可以参考我的这篇博客：&lt;a href=&quot;http://https//blog.csdn.net/xiaosongshine/article/details/86543836&quot; data-cke-saved-href=&quot;http://https//blog.csdn.net/xiaosongshine/article/details/86543836&quot;&gt;[深度学习工具]·极简安装Dlib人脸识别库&lt;/a&gt;，下面说一下需要注意的点:：&lt;/p&gt;
&lt;p&gt;此博文针对Windows10安装，其他平台可以仿照这个步骤来安装&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;安装Miniconda&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;使用conda指令来安装Dlib库，使用Miniconda与Anaconda都可以，我习惯用Miniconda，简单占用内存小。&lt;br/&gt;推荐使用&lt;a href=&quot;https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/&quot; data-cke-saved-href=&quot;https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/&quot;&gt;清华源&lt;/a&gt;，下载安装，选择合适的平台版本。python==3.6&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;安装dlib&lt;br/&gt;&lt;strong&gt;注意一定要以管理员身份进入CMD，执行（如果是Linux Mac 就使用 sudo）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;&lt;li&gt;需要imageio 库，可以使用下述命令安装&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;3.开发实战 &lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;1.实现人脸检测标记&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;face_test.py&lt;/p&gt;

&lt;p&gt;代码很简单，通过imread读取照片，然后进行检测，输出结果为dets的list，有几张人脸就会有几个item， 每个item都有.left(), .top(), .right(), .bottom()四个元素，代表人脸框的四个边界位置。最后通过win.add_overlay(dets)可以将标记的框显示在原图上。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;原始照片&lt;/em&gt;&lt;br/&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;8&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://img-blog.csdnimg.cn/20190118174157106.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9zb25nc2hpbmU=,size_16,color_FFFFFF,t_70&quot; alt=&quot;原始照片&quot; width=&quot;600&quot; height=&quot;472&quot; data-cke-saved-src=&quot;https://img-blog.csdnimg.cn/20190118174157106.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9zb25nc2hpbmU=,size_16,color_FFFFFF,t_70&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://img-blog.csdnimg.cn/20190118174157106.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9zb25nc2hpbmU=,size_16,color_FFFFFF,t_70&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;原始照片&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;600&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;472&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;br/&gt;&lt;em&gt;输出照片&lt;/em&gt;&lt;br/&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;7&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://img-blog.csdnimg.cn/20190118174432776.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9zb25nc2hpbmU=,size_16,color_FFFFFF,t_70&quot; alt=&quot;输出照片&quot; width=&quot;600&quot; height=&quot;338&quot; data-cke-saved-src=&quot;https://img-blog.csdnimg.cn/20190118174432776.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9zb25nc2hpbmU=,size_16,color_FFFFFF,t_70&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://img-blog.csdnimg.cn/20190118174432776.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9zb25nc2hpbmU=,size_16,color_FFFFFF,t_70&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;输出照片&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;600&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;338&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其实我们就可以使用这个功能做一个简单的应用，用来检测图片或者视频中人脸的个数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.人脸特征点提取&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在实战1的基础上添加人脸特征提取功能。&lt;/p&gt;

&lt;p&gt;这段代码就是在test.py基础上加入了shape_predictor功能，使之可以在检测出人脸基础上，找到人脸的68个特征点。反映在图中就是蓝色的线。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;原始图片&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;5&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://img-blog.csdnimg.cn/20190424225848224.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9zb25nc2hpbmU=,size_16,color_FFFFFF,t_70&quot; alt=&quot;&quot; width=&quot;600&quot; data-cke-saved-src=&quot;https://img-blog.csdnimg.cn/20190424225848224.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9zb25nc2hpbmU=,size_16,color_FFFFFF,t_70&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://img-blog.csdnimg.cn/20190424225848224.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9zb25nc2hpbmU=,size_16,color_FFFFFF,t_70&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;600&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;输出图片&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;4&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://img-blog.csdnimg.cn/20190424225920940.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9zb25nc2hpbmU=,size_16,color_FFFFFF,t_70&quot; alt=&quot;&quot; width=&quot;600&quot; data-cke-saved-src=&quot;https://img-blog.csdnimg.cn/20190424225920940.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9zb25nc2hpbmU=,size_16,color_FFFFFF,t_70&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://img-blog.csdnimg.cn/20190424225920940.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9zb25nc2hpbmU=,size_16,color_FFFFFF,t_70&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;600&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;注意运行这段代码需要这个文件predictor_path = 'shape_predictor_68_face_landmarks.dat'，我会放在我的&lt;a href=&quot;https://github.com/xiaosongshine/dlib_face_recognition&quot; data-cke-saved-href=&quot;https://github.com/xiaosongshine/dlib_face_recognition&quot;&gt;github&lt;/a&gt;中，方便大家下载使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.人脸识别验证&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在第二步的基础上，我们再进一步，实现将人脸提取为特征向量，从而我们就可以对特征向量进行比对来实现人脸的验证，这里采用的是对比欧式距离的方法。&lt;/p&gt;
&lt;p&gt;face_recognition.py&lt;/p&gt;

&lt;p&gt;&lt;em&gt;输出结果&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;我们可以看出，每张人脸都被提取为了128维的向量，我们可以理解为128维的坐标（xyz是三维，128维就是有128个轴组成），我们下面需要做的就是计算两个特征的距离，设定好合适的阈值，小于这个阈值则识别为同一个人。代码正确运行需要这个文件face_rec_model_path = 'dlib_face_recognition_resnet_model_v1.dat'，我已经放在自己的&lt;a href=&quot;https://github.com/xiaosongshine/dlib_face_recognition&quot; data-cke-saved-href=&quot;https://github.com/xiaosongshine/dlib_face_recognition&quot;&gt;github&lt;/a&gt;中，方便大家使用。&lt;/p&gt;
&lt;p&gt;我们从上面测试的结果可以看出，不同的距离为0.25，同一个人为0.06，阈值就可以先设置为其间的一个值。我这里先设置为0.09，这个阈值也是需要大量数据来计算的，选择的准则为使错误识别为最低。&lt;/p&gt;
&lt;p&gt;下面我们把阈值设置为0.09，来测试系统能否区分出不同的人：在face_recognition.py加入下面代码&lt;/p&gt;

&lt;p&gt;&lt;em&gt;输出结果&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;从上面可以看出，已基本满足对人脸区分的功能，如果如要实用化则需要继续调优阈值与代码，调优的准则就是选择合适的阈值使错误识别为最低。&lt;/p&gt;
&lt;p&gt;Hope this helps&lt;/p&gt;
&lt;p&gt;个人网站--&amp;gt; &lt;a href=&quot;http://www.yansongsong.cn/&quot; data-cke-saved-href=&quot;http://www.yansongsong.cn/&quot;&gt;http://www.yansongsong.cn/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;项目GitHub地址--&amp;gt; &lt;a href=&quot;https://github.com/xiaosongshine/dlib_face_recognition&quot; data-cke-saved-href=&quot;https://github.com/xiaosongshine/dlib_face_recognition&quot;&gt;https://github.com/xiaosongshine/dlib_face_recognition&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 24 Apr 2019 16:38:00 +0000</pubDate>
<dc:creator>小宋是呢</dc:creator>
<og:description>[深度应用]·实战掌握Dlib人脸识别开发教程 个人网站--&gt; http://www.yansongsong.cn/ 项目GitHub地址--&gt; https:</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaosongshine/p/10765958.html</dc:identifier>
</item>
<item>
<title>高质量代码实践 - IT文艺男</title>
<link>http://www.cnblogs.com/appsucc/p/10765892.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/appsucc/p/10765892.html</guid>
<description>&lt;p&gt;        &lt;span&gt;&lt;strong&gt;本博文首先分析了强调高质量代码的原因、判别标准：：由于需求的不断变化，系统功能越来越多，而且越来越复杂，软件规模越来越大(代码行数&amp;gt;100万)，导致开发以及维护的成本越来越高，开发效率越来越低，Bug越来越多，因此好的产品需要高质量的代码构建，从而提高开发效率，提升产品稳定性，输出外在质量高、内在质量高的产品；&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;       &lt;span&gt; &lt;strong&gt;本博文然后从代码实践中总结归纳出怎样写出高质量的代码：：从基础的命名（名副其实，做有意义的区分，使用解决方案/业务领域可读的名称，类名/方法名，命名参考）到函数、类以及常用的设计模式、面向对象设计的开发原则（单一职责原则，开闭原则，里氏替换原则，接口隔离原则，依赖倒置原则）、一直到最顶层的模式与架构(分层架构模式，模型-视图-控制器架构模式，事件驱动架构)；&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;       &lt;strong&gt; &lt;span&gt;本博文给读者开发人员有正确的指引作用，产生共鸣；&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/371367/201904/371367-20190424235425420-1646984938.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/371367/201904/371367-20190424235520651-1966968174.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/371367/201904/371367-20190424235548055-986995670.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/371367/201904/371367-20190424235627293-602495321.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/371367/201904/371367-20190424235707415-284262361.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/371367/201904/371367-20190424235735591-1212487693.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/371367/201904/371367-20190424235752587-891772745.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/371367/201904/371367-20190424235810480-569231313.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/371367/201904/371367-20190425000012292-726804064.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/371367/201904/371367-20190425000111616-933106678.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/371367/201904/371367-20190425000136121-136785829.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/371367/201904/371367-20190425000158155-358020821.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/371367/201904/371367-20190425000245615-1640169860.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/371367/201904/371367-20190425000331335-1452342816.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/371367/201904/371367-20190425000351126-489031080.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/371367/201904/371367-20190425000428135-1875217902.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/371367/201904/371367-20190425000453666-1984739220.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/371367/201904/371367-20190425000519277-169673023.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/371367/201904/371367-20190425000535322-1281979997.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/371367/201904/371367-20190425000548435-1178257826.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/371367/201904/371367-20190425000613927-261001539.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/371367/201904/371367-20190425000711266-823918233.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/371367/201904/371367-20190425000740886-2039059391.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/371367/201904/371367-20190425000759145-307851340.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/371367/201904/371367-20190425000822173-1131976949.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/371367/201904/371367-20190425000842980-1140184964.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/371367/201904/371367-20190425000900459-75370342.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/371367/201904/371367-20190425000933340-1062406509.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/371367/201904/371367-20190425000957241-1652588860.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/371367/201904/371367-20190425001024353-1706943134.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/371367/201904/371367-20190425001042063-1757432761.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/371367/201904/371367-20190425001112369-1152793028.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/371367/201904/371367-20190425001126225-612428089.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/371367/201904/371367-20190425001139629-970436225.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/371367/201904/371367-20190425001158388-1042026483.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/371367/201904/371367-20190425001216790-461762958.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/371367/201904/371367-20190425001233102-726135442.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/371367/201904/371367-20190425001243843-1881763957.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/371367/201904/371367-20190425001259096-778714508.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 24 Apr 2019 16:25:00 +0000</pubDate>
<dc:creator>IT文艺男</dc:creator>
<og:description>本博文分析了强调高质量代码的原因、判别标准；然后从代码实践中总结出怎样写出高质量的代码：​：​从基础的命名到函数、类以及设计模式、面向对象设计的开发原则、一直到最顶层的模式与架构；给阅读到该博文的开发</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/appsucc/p/10765892.html</dc:identifier>
</item>
<item>
<title>【JVM虚拟机】(9)-- JVM是如何处理异常的 - 雨点的名字</title>
<link>http://www.cnblogs.com/qdhxhz/p/10765839.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qdhxhz/p/10765839.html</guid>
<description>&lt;center&gt;

&lt;/center&gt;
&lt;p&gt;上篇博客我们简单说过&lt;code&gt;异常信息是存放在属性表集合中的Code属性表里&lt;/code&gt;，那么这篇博客就单独讲Code属性表中的exception_table。&lt;/p&gt;
&lt;p&gt;在讲之前我们先思考两个问题？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、为什么捕获异常会较大的性能消耗？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、为什么finally中的代码会永远执行？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接下来会从JVM虚拟机的角度来解答这两个问题。&lt;/p&gt;
&lt;h2 id=&quot;一概念&quot;&gt;&lt;span&gt;一、概念&lt;/span&gt;&lt;/h2&gt;
&lt;h4 id=&quot;jvm是如何捕获异常的&quot;&gt;1、JVM是如何捕获异常的？&lt;/h4&gt;
&lt;p&gt;1、编译而成的字节码中，每个方法都附带一个&lt;code&gt;异常表&lt;/code&gt;。&lt;br/&gt;2、异常表中每一个条目代表一个&lt;code&gt;异常处理器&lt;/code&gt;&lt;br/&gt;3、触发异常时，JVM会遍历异常表，比较触发异常的字节码的索引值是否在异常处理器的&lt;code&gt;from指针到to指针&lt;/code&gt;的范围内。&lt;br/&gt;4、范围匹配后，会去比较&lt;code&gt;异常类型和异常处理器中的type是否相同&lt;/code&gt;。&lt;br/&gt;5、类型匹配后，会跳转到&lt;code&gt;target指针所指向的字节码&lt;/code&gt;(catch代码块的开始位置)&lt;br/&gt;6、如果没有匹配到异常处理器，会弹出当前方法对应的&lt;code&gt;Java栈帧&lt;/code&gt;，并对调用者重复上述操作。&lt;/p&gt;
&lt;h4 id=&quot;什么是异常表&quot;&gt;2、什么是异常表？&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;1. 每个方法都附带一个异常表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 异常表中每一个条目, 就是一个异常处理器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;异常表如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201904/1090617-20190425000905326-1981139420.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;什么是异常处理器其组成部分有哪些&quot;&gt;3、什么是异常处理器？其组成部分有哪些？&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;1、异常处理器由from指针、to指针、target指针，以及所捕获的异常类型所构成(type)。
2、这些指针的数值就是字节码的索引(bytecode index, bci),可以直接去定位字节码。
3、from指针和to指针，标识了该异常处理器所监控的返回
4、target指针，指向异常处理器的起始位置。如catch代码块的起始位置
5、type：捕获的异常类型，如Exception&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;如果在方法的异常表中没有匹配到异常处理器会怎么样&quot;&gt;4、如果在方法的异常表中没有匹配到异常处理器，会怎么样？&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;1、会弹出当前方法对应的Java栈帧
2、在调用者上重复异常匹配的流程。
3、最坏情况下，JVM需要编译当前线程Java栈上所有方法的异常表&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;二代码演示&quot;&gt;&lt;span&gt;二、代码演示&lt;/span&gt;&lt;/h2&gt;
&lt;h4 id=&quot;try-catch&quot;&gt;1、try-catch&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void main(String[] args) {
  try {
    mayThrowException();
  } catch (Exception e) {
    e.printStackTrace();
  }
}
// 对应的 Java 字节码
public static void main(java.lang.String[]);
  Code:
    0: invokestatic mayThrowException:()V
    3: goto 11
    6: astore_1
    7: aload_1
    8: invokevirtual java.lang.Exception.printStackTrace
   11: return
  Exception table:
    from  to target type
      0   3   6  Class java/lang/Exception  // 异常表条目&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面Code中的字节码自己也没有仔细研究过，我们可以具体看下面的Exception table表，来进行分析。&lt;/p&gt;
&lt;p&gt;1、&lt;code&gt;from和to&lt;/code&gt;: 指是try和catch之间的代码的索引位置。from=0,to=3,代表从字节索引0的位置到3(不包括3)。&lt;/p&gt;
&lt;p&gt;2、&lt;code&gt;target&lt;/code&gt; : 代表catch后代码运行的起始位置。&lt;/p&gt;
&lt;p&gt;3、&lt;code&gt;type&lt;/code&gt; : 指的是异常类型，这里是指Exception异常。&lt;/p&gt;
&lt;p&gt;当程序触发异常时，java虚拟机会从上至下遍历异常表中的所有条目。当触发异常的字节码的索引值在某个异常表条目的监控范围内，Java 虚拟机会判断所抛出的异常&lt;br/&gt;和该条目想要捕获的异常是否匹配。如果匹配，Java 虚拟机会将控制流转移至该条目target 指针指向的字节码。&lt;/p&gt;
&lt;p&gt;如果遍历完所有异常表条目，Java 虚拟机仍未匹配到异常处理器，那么它会弹出当前方法对应的&lt;code&gt;Java 栈帧&lt;/code&gt;，并且在调用者（caller）中重复上述操作。在最坏情况下，&lt;br/&gt;Java 虚拟机需要遍历当前线程 Java 栈上所有方法的异常表。&lt;/p&gt;
&lt;h4 id=&quot;try-catch-finally&quot;&gt;2、try-catch-finally&lt;/h4&gt;
&lt;p&gt;finally 代码块的编译比较复杂。当前版本 Java 编译器的做法，是&lt;code&gt;复制 finally 代码块的内容，分别放在 try-catch 代码块所有正常执行路径以及异常执行路径的出口中&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201904/1090617-20190425000917793-2044914320.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码示例&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void XiaoXiao() {
   try {
       dada();
   } catch (Exception e) {
       e.printStackTrace();
   } finally {
       System.out.println(&quot;Finally&quot;);
   }
}
//通过javap 反编译
public static void XiaoXiao();
    Code:
       0: invokestatic  #3                  // Method dada:()V
       3: getstatic     #6                  // Field java/lang/System.out:Ljava/io/PrintStream;
       6: ldc           #7                  // String Finally
       8: invokevirtual #8                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
      11: goto          41
      14: astore_0
      15: aload_0
      16: invokevirtual #5                  // Method java/lang/Exception.printStackTrace:()V
      19: getstatic     #6                  // Field java/lang/System.out:Ljava/io/PrintStream;
      22: ldc           #7                  // String Finally
      24: invokevirtual #8                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
      27: goto          41
      30: astore_1
      31: getstatic     #6                  // Field java/lang/System.out:Ljava/io/PrintStream;
      34: ldc           #7                  // String Finally
      36: invokevirtual #8                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
      39: aload_1
      40: athrow
      41: return
    Exception table:
       from    to  target type
           0     3    14   Class java/lang/Exception
           0     3    30   any
          14    19    30   any&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;和之前有所不同，这次&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、异常表中，有三条数据，而我们仅仅捕获了一个Exception&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;2、异常表的后两个item的type为any&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上面的三条异常表item的意思为&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、如果0到3之间，发生了Exception类型的异常，调用14位置的异常处理者。&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;2、 如果0到3之间，无论发生什么异常，都调用30位置的处理者。&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;3、 如果14到19之间（即catch部分），不论发生什么异常，都调用30位置的处理者。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;问题&lt;/code&gt;：通过上面那幅图和javap反编译代码就可以很好的解释为什么finally里面的代码永远会执行？&lt;br/&gt;&lt;strong&gt;原因&lt;/strong&gt;：因为当前版本Java编译器的做法，是&lt;code&gt;复制finally代码块的内容，分别放到所有正常执行路径，以及异常执行路径的出口中&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这三份finally代码块都放在什么位置:&lt;br/&gt;&lt;strong&gt;第一份位于try代码后&lt;/strong&gt; : 若果try中代码正常执行，没有异常那么finally代码就在这里执行。&lt;br/&gt;&lt;strong&gt;第二份位于catch代码后&lt;/strong&gt; : 如果try中有异常同时被catch捕获，那么finally代码就在这里执行。&lt;br/&gt;&lt;strong&gt;第三份位于异常执行路径&lt;/strong&gt; : 如果如果try中有异常但没有被catch捕获,或者catch又抛异常，那么就执行最终的finally代码。&lt;/p&gt;&lt;p&gt;&lt;code&gt;问题&lt;/code&gt; :为什么捕获异常会较大的性能消耗?&lt;br/&gt;因为&lt;code&gt;构造异常的实例比较耗性能&lt;/code&gt;。这从代码层面很难理解，不过站在JVM的角度来看就简单了，因为JVM在构造异常实例时需要&lt;code&gt;生成该异常的栈轨迹&lt;/code&gt;。这个操作会逐一访问当前&lt;br/&gt;线程的栈帧，并且记录下各种调试信息，包括栈帧所指向方法的名字，方法所在的类名、文件名，以及在代码中的第几行触发该异常等信息。虽然具体不清楚JVM的实现细节，但&lt;br/&gt;是看描述这件事情也是比较费时费力的。&lt;/p&gt;
&lt;h3 id=&quot;参考&quot;&gt;&lt;span&gt;参考&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;深入拆解 Java 虚拟机（郑雨迪）&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;只要自己变优秀了，其他的事情才会跟着好起来（少将7）&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 24 Apr 2019 16:11:00 +0000</pubDate>
<dc:creator>雨点的名字</dc:creator>
<og:description>【JVM虚拟机】(9) JVM是如何处理异常的 上篇博客我们简单说过 ，那么这篇博客就单独讲Code属性表中的exception_table。 在讲之前我们先思考两个问题？ 1、为什么捕获异常会较大的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qdhxhz/p/10765839.html</dc:identifier>
</item>
<item>
<title>.net core 杂记：日记记录 - 【可乐不加冰】</title>
<link>http://www.cnblogs.com/qiuguochao/p/10765614.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qiuguochao/p/10765614.html</guid>
<description>&lt;p&gt;ASP.NET Core 有内置的log组件，遗憾的是看了微软官方文档，貌似无法直接将日志存于文件或数据库，只能由自己实现或引用第三方日志组件。&lt;/p&gt;
&lt;p&gt;以下为Nlog和log4net的使用记录&lt;/p&gt;
&lt;h2&gt;Nlog使用&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h3&gt; 搜索添加Nuget包&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Nlog
Nlog.Web.AspNetCore&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h3&gt;新建一个xml文件，并改名为nlog.config&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;XML内容如下（可配置日志目录名称、输出格式）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; encoding=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ?&amp;gt;
&amp;lt;nlog xmlns=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.nlog-project.org/schemas/NLog.xsd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
      xmlns:xsi&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.w3.org/2001/XMLSchema-instance&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
      autoReload&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
      internalLogLevel&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Warn&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
      internalLogFile&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;internal-nlog.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;

  &amp;lt;!--define various log targets--&amp;gt;
  &amp;lt;targets&amp;gt;&lt;br/&gt;&amp;lt;!--write logs to file--&amp;gt;
    &amp;lt;target xsi:type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;File&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;allfile&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; fileName=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Logs/service-${shortdate}.log&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                 layout&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;${longdate}|${logger}|${uppercase:${level}}|${message} ${exception}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;&lt;br/&gt;&amp;lt;/targets&amp;gt;&lt;br/&gt;&amp;lt;rules&amp;gt;
    &amp;lt;!--All logs, including &lt;span&gt;from&lt;/span&gt; Microsoft--&amp;gt;
    &amp;lt;logger name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; minlevel=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Trace&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; writeTo=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;allfile&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
  &amp;lt;/rules&amp;gt;
&amp;lt;/nlog&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h3&gt; 将nlog.config设置输出到目录&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;
&lt;h3&gt;在Startup类中配置&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;需要引入命名空间：&lt;/p&gt;
&lt;p&gt;using NLog.Extensions.Logging;&lt;/p&gt;
&lt;p&gt;using NLog.Web;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactor)
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用Nlog&lt;/span&gt;
&lt;strong&gt;&lt;span&gt;    loggerFactor.AddNLog();
    &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;引入配置文件&lt;/span&gt;
   &lt;strong&gt; env.ConfigureNLog(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;nlog.config&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (env.IsDevelopment())
    {
        app.UseDeveloperExceptionPage();
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    {
        app.UseExceptionHandler(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/Error&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
    app.UseStaticFiles();
    app.UseCookiePolicy();

    app.UseMvc();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h3&gt;代码中的使用&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;有两中方式如下：&lt;/p&gt;
&lt;p&gt;1、注入形式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; IndexModel : PageModel
{
    &lt;/span&gt;&lt;strong&gt;&lt;span&gt;private&lt;/span&gt; ILogger&amp;lt;IndexModel&amp;gt;&lt;span&gt; _logger;
    &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;public&lt;/span&gt; IndexModel(&lt;strong&gt;ILogger&amp;lt;IndexModel&amp;gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt; logger&lt;/strong&gt;)
    {
        &lt;strong&gt;_logger &lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;=&lt;/strong&gt;&lt;span&gt;&lt;strong&gt; logger;&lt;/strong&gt;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Customer { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnGet()
    {
        &lt;strong&gt;_logger.LogWarning(&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;111111111111111111111&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;);&lt;/strong&gt;
        Customer &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123456&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、获取实例形式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;strong&gt;Logger Logger =&lt;span&gt; LogManager.GetCurrentClassLogger();
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
{
    Logger.Error(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;22222222222222222222222222222&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    Logger.Info(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;333333333333333333333333333333&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt; log4net&lt;/h2&gt;
&lt;p&gt; log4net已支持net core，来看下在net core下是如何配置的，与之前的版本还是有一点的区别&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h3&gt;使用惯例，引用Nuget&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h3&gt;新建配置文件&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; encoding=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ?&amp;gt;
&amp;lt;configuration&amp;gt;
  &amp;lt;!-- This section contains the log4net configuration settings --&amp;gt;
  &amp;lt;log4net&amp;gt;
    &amp;lt;appender name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ConsoleAppender&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;log4net.Appender.ConsoleAppender&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
      &amp;lt;layout type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;log4net.Layout.PatternLayout&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%date [%thread] %-5level %logger - %message%newline&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
    &amp;lt;/appender&amp;gt;

    &amp;lt;appender name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;FileAppender&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;log4net.Appender.FileAppender&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
      &amp;lt;file value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;log-file.log&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
      &amp;lt;appendToFile value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
      &amp;lt;layout type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;log4net.Layout.PatternLayout&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
        &amp;lt;conversionPattern value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%date [%thread] %-5level %logger [%property{NDC}] - %message%newline&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
      &amp;lt;/layout&amp;gt;
    &amp;lt;/appender&amp;gt;

    &amp;lt;appender name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RollingLogFileAppender&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;log4net.Appender.RollingFileAppender&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
      &amp;lt;file value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;logs/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt; 
      &amp;lt;appendToFile value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
      &amp;lt;rollingStyle value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Date&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
      &amp;lt;staticLogFileName value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
      &amp;lt;datePattern value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yyyy-MM-dd'.log'&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
      &amp;lt;maxSizeRollBackups value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
      &amp;lt;maximumFileSize value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1MB&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
      &amp;lt;layout type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;log4net.Layout.PatternLayout&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
        &amp;lt;conversionPattern value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%date [%thread] %-5level %logger [%property{NDC}] - %message%newline&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
      &amp;lt;/layout&amp;gt;
    &amp;lt;/appender&amp;gt;

    &amp;lt;!-- Setup the root category, add the appenders and &lt;span&gt;set&lt;/span&gt; the &lt;span&gt;default&lt;/span&gt; level --&amp;gt;
    &amp;lt;root&amp;gt;
      &amp;lt;level value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ALL&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
      &amp;lt;appender-&lt;span&gt;ref&lt;/span&gt; &lt;span&gt;ref&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ConsoleAppender&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
      &amp;lt;appender-&lt;span&gt;ref&lt;/span&gt; &lt;span&gt;ref&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;FileAppender&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
      &amp;lt;appender-&lt;span&gt;ref&lt;/span&gt; &lt;span&gt;ref&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RollingLogFileAppender&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
    &amp;lt;/root&amp;gt;

  &amp;lt;/log4net&amp;gt;
&amp;lt;/configuration&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;配置文件的相关说明，可以查看另一篇文章  &lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/qiuguochao/p/6654149.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;点我跳转&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h3&gt;在StartUp.cs中配置log4Net&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ILoggerRepository repository { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }&lt;br/&gt;&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Startup(IConfiguration configuration)
{
    Configuration &lt;/span&gt;=&lt;span&gt; configuration;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;log4net&lt;/span&gt;
    repository = LogManager.CreateRepository(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;NETCoreRepository&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定配置文件&lt;/span&gt;
    XmlConfigurator.Configure(repository, &lt;span&gt;new&lt;/span&gt; FileInfo(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;log4net.config&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;&lt;li&gt;
&lt;h3&gt; Controller中的使用&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;private&lt;/span&gt; ILog log = LogManager.GetLogger(Startup.repository.Name, &lt;span&gt;typeof&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;(ValuesController));&lt;/strong&gt;

[HttpGet]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ActionResult&amp;lt;IEnumerable&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt; Get()
{
    log.Info(&lt;/span&gt;&lt;span&gt;1111111111111111111&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;&lt;li&gt;
&lt;h3&gt;控制台中的使用&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
ILoggerRepository repository = LogManager.CreateRepository(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;NETCoreRepository&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);&lt;br/&gt;XmlConfigurator.Configure(repository, &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; FileInfo(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;log4net.config&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));&lt;br/&gt;ILog log &lt;/span&gt;= LogManager.GetLogger(repository.Name,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;NETCorelog4net&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
 &lt;/span&gt;&lt;span&gt;
log.Info(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test log&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Wed, 24 Apr 2019 15:59:00 +0000</pubDate>
<dc:creator>【可乐不加冰】</dc:creator>
<og:description>ASP.NET Core 有内置的log组件，遗憾的是看了微软官方文档，貌似无法直接将日志存于文件或数据库，只能由自己实现或引用第三方日志组件。 以下为Nlog和log4net的使用记录 Nlog使用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qiuguochao/p/10765614.html</dc:identifier>
</item>
</channel>
</rss>