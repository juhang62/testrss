<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>.NET 增加扩展方法 - 师傅-伞下的雨</title>
<link>http://www.cnblogs.com/shifubug/p/10604805.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shifubug/p/10604805.html</guid>
<description>&lt;p&gt;声明：通过一个js的实例来告诉你C#也可以实现这样的效果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在JS中是这样实现的：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;你是否见过JS中给系统默认Array对象增加一个自定义查重方法contains&lt;/p&gt;
&lt;p&gt;在没有给Array原型上增加contains之前，通过vs编辑器是无法通过点的方式来调用contains&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/240600/201903/240600-20190326233810416-939890151.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当给Array原型上增加contains之后，便可以通过点的方式进行调用&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/240600/201903/240600-20190326234109414-1417755785.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;在C#中是这样实现的：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;先说需求：我们要在String对象上增加一个ToString2()的函数&lt;/p&gt;
&lt;p&gt;在没有给String对象增加ToString2()之前是无法通过点来调用ToString2()函数，下图是无法找到oString2()函数&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/240600/201903/240600-20190326234624914-159424846.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当增加了扩展函数后便可以通过点的方式来调用扩展函数&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/240600/201903/240600-20190326235225102-756524945.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;语法：定义扩展方法，它必须是一个静态类static，并且要使用this关键字来修饰要对那个对象进行操作。以上重点和最终效果军用红线标注。&lt;/p&gt;
&lt;p&gt;你学会了吗？是不是逼格满满？&lt;/p&gt;
</description>
<pubDate>Tue, 26 Mar 2019 15:59:00 +0000</pubDate>
<dc:creator>师傅-伞下的雨</dc:creator>
<og:description>声明：通过一个js的实例来告诉你C#也可以实现这样的效果。 在JS中是这样实现的： 你是否见过JS中给系统默认Array对象增加一个自定义查重方法contains 在没有给Array原型上增加cont</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shifubug/p/10604805.html</dc:identifier>
</item>
<item>
<title>大数据技术之_16_Scala学习_04_函数式编程-基础+面向对象编程-基础 - 黑泽君</title>
<link>http://www.cnblogs.com/chenmingjun/p/10604813.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenmingjun/p/10604813.html</guid>
<description>&lt;p id=&quot;tocid_0&quot; class=&quot;toc&quot;&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h&quot;&gt;第五章 函数式编程-基础&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h51&quot;&gt;5.1 函数式编程内容说明&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h511&quot;&gt;5.1.1 函数式编程内容&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h512&quot;&gt;5.1.2 函数式编程授课顺序&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h52&quot;&gt;5.2 函数式编程介绍&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h521&quot;&gt;5.2.1 几个概念的说明&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h522&quot;&gt;5.2.2 方法、函数、函数式编程和面向对象编程关系分析图&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h523&quot;&gt;5.2.3 函数式编程小结&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h53&quot;&gt;5.3 为什么需要函数&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h54&quot;&gt;5.4 函数的定义&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h541&quot;&gt;5.4.1 函数的定义&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h542&quot;&gt;5.4.2 快速入门案例&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h55&quot;&gt;5.5 函数的调用机制&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h551&quot;&gt;5.5.1 函数的调用过程&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h552&quot;&gt;5.5.2 函数的递归调用&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h553&quot;&gt;5.5.3 递归练习题&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h56&quot;&gt;5.6 函数注意事项和细节讨论&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h57&quot;&gt;5.7 函数练习题&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h58&quot;&gt;5.8 过程&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h581&quot;&gt;5.8.1 基本概念&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h582&quot;&gt;5.8.2 注意事项和细节说明&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h59&quot;&gt;5.9 惰性函数&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h591&quot;&gt;5.9.1 看一个应用场景&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h592&quot;&gt;5.9.2 画图说明（大数据推荐系统）&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h593java&quot;&gt;5.9.3 Java 实现懒加载的代码&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h594&quot;&gt;5.9.4 惰性函数介绍&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h595&quot;&gt;5.9.5 案例演示&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h596&quot;&gt;5.9.6 注意事项和细节&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h510&quot;&gt;5.10 异常&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h5101&quot;&gt;5.10.1 介绍&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h5102java&quot;&gt;5.10.2 Java 异常处理回顾&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h5103java&quot;&gt;5.10.3 Java 异常处理的注意点&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h5104scala&quot;&gt;5.10.4 Scala 异常处理举例&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h5105scala&quot;&gt;5.10.5 Scala 异常处理小结&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h511-1&quot;&gt;5.11 函数的练习题&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h-1&quot;&gt;第六章 面向对象编程-基础&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h61&quot;&gt;6.1 类与对象&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h611scala&quot;&gt;6.1.1 Scala 语言是面向对象的&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h612&quot;&gt;6.1.2 快速入门-面向对象的方式解决养猫问题&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h613&quot;&gt;6.1.3 类和对象的区别和联系&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h614&quot;&gt;6.1.4 如何定义类&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h615&quot;&gt;6.1.5 属性&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h616&quot;&gt;6.1.6 属性/成员变量&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h617&quot;&gt;6.1.7 属性的高级部分&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h618&quot;&gt;6.1.8 如何创建对象&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h619&quot;&gt;6.1.9 类和对象的内存分配机制（重要）&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h62&quot;&gt;6.2 方法&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h621&quot;&gt;6.2.1 基本说明和基本语法&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h622&quot;&gt;6.2.2 方法的调用机制原理&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h623&quot;&gt;6.2.3 方法练习题&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h63&quot;&gt;6.3 类与对象应用实例&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h64&quot;&gt;6.4 构造器&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h641&quot;&gt;6.4.1 看一个需求&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h642java&quot;&gt;6.4.2 回顾-Java 构造器的介绍+基本语法+特点+案例&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h643scala&quot;&gt;6.4.3 Scala 构造器的介绍+基本语法+快速入门&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h644scala&quot;&gt;6.4.4 Scala 构造器注意事项和细节&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h65&quot;&gt;6.5 属性高级&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h651&quot;&gt;6.5.1 构造器参数&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h652bean&quot;&gt;6.5.2 Bean 属性&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h66scala&quot;&gt;6.6 Scala 对象创建的流程分析&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h6703&quot;&gt;6.7 作业03&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;h&quot;&gt;&lt;span&gt;&lt;strong&gt;第五章 函数式编程-基础&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;h51&quot;&gt;&lt;span&gt;&lt;strong&gt;5.1 函数式编程内容说明&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h4 id=&quot;h511&quot;&gt;&lt;span&gt;&lt;strong&gt;5.1.1 函数式编程内容&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;函数式编程-基础&lt;/strong&gt;&lt;br/&gt;  1、函数定义/声明&lt;br/&gt;  2、函数运行机制&lt;br/&gt;  3、&lt;strong&gt;递归&lt;/strong&gt;【难点：最短路径，邮差问题，背包问题，迷宫问题，回溯】&lt;br/&gt;  4、过程&lt;br/&gt;  5、惰性函数和异常&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;函数式编程-高级&lt;/strong&gt;&lt;br/&gt;  6、值函数(函数字面量)&lt;br/&gt;  7、高阶函数&lt;br/&gt;  8、闭包&lt;br/&gt;  9、应用函数&lt;br/&gt;  10、柯里化函数，抽象控制…&lt;/p&gt;
&lt;h4 id=&quot;h512&quot;&gt;&lt;span&gt;&lt;strong&gt;5.1.2 函数式编程授课顺序&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;  1、在 scala 中，函数式编程和面向对象编程融合在一起，学习函数式编程式需要 oop 的知识，同样学习 oop 需要函数式编程的基础。[矛盾]&lt;br/&gt;  2、二者关系如下图:&lt;br/&gt;  &lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/26/Aa9nTU.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;  3、授课顺序：函数式编程基础 -&amp;gt; 面向对象编程 -&amp;gt; 函数式编程高级

&lt;h3 id=&quot;h52&quot;&gt;&lt;span&gt;&lt;strong&gt;5.2 函数式编程介绍&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h4 id=&quot;h521&quot;&gt;&lt;span&gt;&lt;strong&gt;5.2.1 几个概念的说明&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;  在学习 Scala 中将方法、函数、函数式编程和面向对象编程明确一下：&lt;br/&gt;  1、在 scala 中，&lt;code&gt;方法&lt;/code&gt;和&lt;code&gt;函数&lt;/code&gt;几乎可以等同(比如他们的定义、使用、运行机制都一样的)，只是函数的使用方式更加的灵活多样。&lt;br/&gt;  2、&lt;code&gt;函数式编程&lt;/code&gt;是从编程方式(范式)的角度来谈的，可以这样理解：函数式编程把函数当做一等公民&lt;code&gt;，充分利用函数、支持的函数的多种使用方式&lt;/code&gt;。&lt;br/&gt;  比如：在 Scala 当中，函数是一等公民，像变量一样，既可以作为函数的参数使用，也可以将函数赋值给一个变量，函数的创建不用依赖于类或者对象，而在 Java 当中，函数的创建则要依赖于类、抽象类或者接口。&lt;br/&gt;  3、&lt;code&gt;面向对象编程&lt;/code&gt;是以对象为基础的编程方式。&lt;br/&gt;  4、在 scala 中函数式编程和面向对象编程融合在一起了。&lt;br/&gt;示例代码如下：&lt;/p&gt;
&lt;pre readability=&quot;12&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;18&quot;&gt;package com.atguigu.chapter05&lt;p&gt;object Method2Function {&lt;br/&gt;def main(args: Array[String]): Unit = {&lt;br/&gt;// 传统的方式使用方法&lt;br/&gt;// 先创建一个对象&lt;br/&gt;val dog = new Dog&lt;br/&gt;println(dog.sum(10, 20))&lt;/p&gt;&lt;p&gt;// 方法转成函数后使用函数&lt;br/&gt;val f1 = dog.sum _&lt;br/&gt;println(&quot;f1=&quot; + f1) // f1=&amp;lt;function2&amp;gt;&lt;br/&gt;println(&quot;f1=&quot; + f1(50, 60))&lt;/p&gt;&lt;p&gt;// 直接写一个函数并使用函数&lt;br/&gt;// 格式：val f2 = (Int, Int) =&amp;gt; {}&lt;br/&gt;val f2 = (n1: Int, n2: Int) =&amp;gt; {&lt;br/&gt;n1 + n2 // 函数体&lt;br/&gt;}&lt;br/&gt;println(&quot;f2=&quot; + f2) // f2=&amp;lt;function2&amp;gt;&lt;br/&gt;println(&quot;f2=&quot; + f2(80, 90))&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;class Dog {&lt;br/&gt;// 方法&lt;br/&gt;def sum(n1: Int, n2: Int): Int = {&lt;br/&gt;n1 + n2 // 方法体&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs makefile&quot;&gt;30&lt;br/&gt;f1=&amp;lt;function2&amp;gt;&lt;br/&gt;f1=110&lt;br/&gt;f2=&amp;lt;function2&amp;gt;&lt;br/&gt;f2=170&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;h522&quot;&gt;&lt;span&gt;&lt;strong&gt;5.2.2 方法、函数、函数式编程和面向对象编程关系分析图&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;在学习 Scala 中将方法、函数、函数式编程和面向对象编程关系分析图如下：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/26/Aa9emV.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h523&quot;&gt;&lt;span&gt;&lt;strong&gt;5.2.3 函数式编程小结&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;  1、“函数式编程”是一种“编程范式”（programming paradigm）。&lt;br/&gt;  2、它属于“结构化编程”的一种，主要思想是把运算过程尽量写成一系列嵌套的函数调用。&lt;br/&gt;  3、函数式编程中，&lt;code&gt;将函数也当做数据类型&lt;/code&gt;，因此可以接受函数当作输入（参数）和输出（返回值）。&lt;br/&gt;  4、函数式编程中，最重要的就是函数。&lt;/p&gt;
&lt;h3 id=&quot;h53&quot;&gt;&lt;span&gt;&lt;strong&gt;5.3 为什么需要函数&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/26/Aa9MY4.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;学习一个技术或者知识点的流程：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/26/Aa9KkF.png&quot; alt=&quot;&quot;/&gt;&lt;h3 id=&quot;h54&quot;&gt;&lt;span&gt;&lt;strong&gt;5.4 函数的定义&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h4 id=&quot;h541&quot;&gt;&lt;span&gt;&lt;strong&gt;5.4.1 函数的定义&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/26/Aa9mwT.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h542&quot;&gt;&lt;span&gt;&lt;strong&gt;5.4.2 快速入门案例&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;使用函数完全前面的案例。&lt;br/&gt;示例代码如下：&lt;/p&gt;
&lt;pre readability=&quot;8.5&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;11&quot;&gt;package com.atguigu.chapter05&lt;p&gt;object FunDemo01 {&lt;br/&gt;def main(args: Array[String]): Unit = {&lt;br/&gt;println(&quot;&quot; + getRes(10, 20, '+'))&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;// 定义一个函数/方法&lt;br/&gt;def getRes(n1: Int, n2: Int, oper: Char) = { // 返回值形式2: = 表示返回值类型不确定，使用类型推导完成。&lt;br/&gt;if (oper == '+') {&lt;br/&gt;// return n1 + n2 // return 关键字可以写可以不写&lt;br/&gt;n1 + n2&lt;br/&gt;} else if (oper == '-') {&lt;br/&gt;n1 - n2&lt;br/&gt;} else {&lt;br/&gt;// 返回 null&lt;br/&gt;null&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h55&quot;&gt;&lt;span&gt;&lt;strong&gt;5.5 函数的调用机制&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/26/Aa91p9.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h551&quot;&gt;&lt;span&gt;&lt;strong&gt;5.5.1 函数的调用过程&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;  为了让大家更好的理解函数调用机制，看1个案例，并画出示意图，这个很重要，比如 getSum 计算两个数的和，并返回结果。&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/26/Aa9QfJ.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h552&quot;&gt;&lt;span&gt;&lt;strong&gt;5.5.2 函数的递归调用&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/26/Aa93lR.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;&lt;code&gt;注意&lt;/code&gt;：Struts2 中的拦截器的底层实现机制就是把一个对象放到堆中，然后不停的开栈去指向该对象的内存地址，每一个栈都有机会去修改该对象的值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;函数递归需要遵守的重要原则（总结）&lt;/strong&gt;&lt;br/&gt;  1、程序执行一个函数时，就创建一个新的受保护的独立空间(新函数栈)。&lt;br/&gt;  2、函数的局部变量是独立的，不会相互影响。&lt;br/&gt;  3、递归必须向退出递归的条件逼近，否则就是无限递归，死龟了:)&lt;br/&gt;  4、当一个函数执行完毕，或者遇到 return，就会返回，遵守谁调用，就将结果返回给谁。&lt;/p&gt;
&lt;h4 id=&quot;h553&quot;&gt;&lt;span&gt;&lt;strong&gt;5.5.3 递归练习题&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;题1：斐波那契数，请使用递归的方式，求出斐波那契数1,1,2,3,5,8,13…给你一个整数n，求出它的斐波那契数是多少？&lt;br/&gt;示例代码如下：&lt;/p&gt;
&lt;pre readability=&quot;14.5&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;23&quot;&gt;package com.atguigu.chapter05.recursive&lt;p&gt;import scala.io.StdIn&lt;/p&gt;&lt;p&gt;/**&lt;br/&gt;* 题1：斐波那契数，请使用递归的方式，求出斐波那契数1,1,2,3,5,8,13... 给你一个整数n，求出它的斐波那契数是多少？&lt;br/&gt;* 思路：f(1)=1, f(2)=1, f(3)=f(2)+f(1)=1+1=2, f(4)=f(2)+f(3)=1+2=3, ..., f(n)=f(n-1)+f(n-2)&lt;br/&gt;*/&lt;br/&gt;object Exercise01 {&lt;br/&gt;def main(args: Array[String]): Unit = {&lt;/p&gt;&lt;p&gt;println(&quot;请输入一个正整数：&quot;)&lt;br/&gt;val n = StdIn.readInt()&lt;br/&gt;printf(&quot;%d的斐波那契数是：%d&quot;, n, fbn(n))&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;def fbn(n: Int): Int = {&lt;br/&gt;if (n == 1 || n == 2) {&lt;br/&gt;1&lt;br/&gt;} else {&lt;br/&gt;fbn(n - 1) + fbn(n - 2)&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;题2：求函数值，已知 f(1)=3; f(n) = 2*f(n-1)+1; 请使用递归的思想编程，求出 f(n) 的值？&lt;br/&gt;示例代码如下：&lt;/p&gt;
&lt;pre readability=&quot;9&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;12&quot;&gt;package com.atguigu.chapter05.recursive&lt;p&gt;import scala.io.StdIn&lt;/p&gt;&lt;p&gt;/**&lt;br/&gt;* 题2：求函数值，已知 f(1)=3; f(n) = 2*f(n-1)+1; 请使用递归的思想编程，求出 f(n) 的值？&lt;br/&gt;* n=1, f(1)=3&lt;br/&gt;* n=2, f(2)=2*f(1)+1=7&lt;br/&gt;* n=3, f(3)=2*f(2)+1=15&lt;br/&gt;*&lt;br/&gt;*/&lt;br/&gt;object Exercise02 {&lt;br/&gt;def main(args: Array[String]): Unit = {&lt;br/&gt;println(&quot;请输入一个正整数：&quot;)&lt;br/&gt;val n = StdIn.readInt()&lt;br/&gt;printf(&quot;f(%d) 的值是：%d&quot;, n, f(n))&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;def f(n: Int): Int = {&lt;br/&gt;if (n == 1) {&lt;br/&gt;3&lt;br/&gt;} else {&lt;br/&gt;2 * f(n - 1) + 1&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;题3：猴子吃桃子问题：有一堆桃子，猴子第一天吃了其中的一半，并再多吃了一个！以后每天猴子都吃其中的一半，然后再多吃一个。当到第十天时，想再吃时（还没吃），发现只有1个桃子了。问题：最初共多少个桃子？&lt;br/&gt;示例代码如下：&lt;/p&gt;
&lt;pre readability=&quot;7.5&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;9&quot;&gt;package com.atguigu.chapter05.recursive&lt;p&gt;import com.atguigu.chapter05.recursive.Exercise02.f&lt;/p&gt;&lt;p&gt;import scala.io.StdIn&lt;/p&gt;&lt;p&gt;/**&lt;br/&gt;* 题3：猴子吃桃子问题：有一堆桃子，猴子第一天吃了其中的一半，并再多吃了一个！&lt;br/&gt;* 以后每天猴子都吃其中的一半，然后再多吃一个。当到第十天时，想再吃时（还没吃），发现只有1个桃子了。问题：最初共多少个桃子？&lt;br/&gt;*&lt;br/&gt;* day = 10 桃子有 1&lt;br/&gt;* day =  9 桃子有 (day10的桃子 + 1) *2&lt;br/&gt;* day =  8 桃子有 (day9 的桃子 + 1) *2&lt;br/&gt;*&lt;br/&gt;*/&lt;br/&gt;object Exercise03 {&lt;br/&gt;def main(args: Array[String]): Unit = {&lt;br/&gt;println(&quot;最初共有:&quot; + f(1) + &quot;个桃子&quot;)&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;def f(n: Int): Int = {&lt;br/&gt;if (n == 10) {&lt;br/&gt;1&lt;br/&gt;} else {&lt;br/&gt;(f(n + 1) + 1) * 2&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h56&quot;&gt;&lt;span&gt;&lt;strong&gt;5.6 函数注意事项和细节讨论&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;  1、函数的形参列表可以是多个，如果函数没有形参，调用时可以不带()。&lt;/p&gt;
&lt;p&gt;  2、函数的形参列表和返回值列表的数据类型可以是值类型和引用类型。【案例演示】&lt;br/&gt;示例代码如下：&lt;/p&gt;
&lt;pre readability=&quot;9.5&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;13&quot;&gt;package com.atguigu.chapter05.fundetails&lt;p&gt;object Details01 {&lt;br/&gt;def main(args: Array[String]): Unit = {&lt;br/&gt;val tiger = new Tiger&lt;br/&gt;val tiger2 = test01(10, tiger)&lt;br/&gt;println(tiger2.name) // tom&lt;br/&gt;println(tiger.name)  // tom&lt;br/&gt;println(tiger.hashCode() + &quot; &quot; + tiger2.hashCode()) // 2101440631 2101440631&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;// 2、函数的形参列表和返回值列表的数据类型可以是值类型和引用类型。&lt;br/&gt;def test01(n: Int, tiger: Tiger): Tiger = {&lt;br/&gt;println(&quot;n=&quot; + n)&lt;br/&gt;tiger.name = &quot;tom&quot;&lt;br/&gt;tiger&lt;br/&gt;// return tiger // 3、Scala 中的函数可以根据函数体最后一行代码自行推断函数返回值类型。那么在这种情况下，return 关键字可以省略。&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;class Tiger {&lt;br/&gt;var name = &quot;&quot;&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  3、Scala 中的函数可以根据函数体最后一行代码自行推断函数返回值类型。那么在这种情况下，return 关键字可以省略。【案例同上】&lt;br/&gt;  4、因为 Scala 可以自行推断，所以在省略 return 关键字的场合，返回值类型也可以省略。&lt;br/&gt;  &lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/26/Aa9861.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;  5、如果函数明确使用 return 关键字，那么函数返回就不能使用自行推断了，这时要明确写成 &lt;code&gt;: 返回值类型 =&lt;/code&gt; ，当然如果你什么都不写，即使有 return，那么返回值为()，即这时 return 无效。&lt;br/&gt;  6、如果函数明确声明无返回值（声明 Unit），那么函数体中即使使用 return 关键字也不会有返回值。&lt;br/&gt;示例代码如下：
&lt;pre readability=&quot;13&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;20&quot;&gt;package com.atguigu.chapter05.fundetails&lt;p&gt;object Details02 {&lt;br/&gt;def main(args: Array[String]): Unit = {&lt;/p&gt;&lt;p&gt;println(getSum2(10, 30))  // ()&lt;/p&gt;&lt;p&gt;println(getSum3(9, 9))    // ()&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;// 如果写了 return，那么返回值类型就不能省略。&lt;br/&gt;def getSum(n1: Int, n2: Int): Int = {&lt;br/&gt;return n1 + n2&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;// 如果返回值这里什么什么都没有写，即表示该函数没有返回值。&lt;br/&gt;// 这时 return 无效&lt;br/&gt;def getSum2(n1: Int, n2: Int) {&lt;br/&gt;return n1 + n2&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;// 如果函数明确声明无返回值（声明Unit），那么函数体中即使使用 return 关键字也不会有返回值。&lt;br/&gt;def getSum3(n1: Int, n2: Int): Unit = {&lt;br/&gt;return n1 + n2&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  7、如果明确函数无返回值或不确定返回值类型，那么返回值类型可以省略（或声明为 Any）。&lt;br/&gt;示例代码如下：&lt;/p&gt;
&lt;pre readability=&quot;6.5&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;7&quot;&gt;package com.atguigu.chapter05.fundetails&lt;p&gt;object Details03 {&lt;br/&gt;def main(args: Array[String]): Unit = {&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;// 7、如果明确函数无返回值或不确定返回值类型，那么返回值类型可以省略（或声明为 Any）。&lt;br/&gt;def f3(s: String) = {&lt;br/&gt;if (s.length &amp;gt;= 3)&lt;br/&gt;s + &quot;123&quot;&lt;br/&gt;else&lt;br/&gt;3&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;def f4(s: String): Any = {&lt;br/&gt;if (s.length &amp;gt;= 3)&lt;br/&gt;s + &quot;123&quot;&lt;br/&gt;else&lt;br/&gt;3&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  8、Scala 语法中任何的语法结构都可以嵌套其他语法结构(很灵活)，即：&lt;code&gt;函数中可以再声明/定义函数&lt;/code&gt;，&lt;code&gt;类中可以再声明类&lt;/code&gt;，&lt;code&gt;方法中可以再声明/定义方法&lt;/code&gt;。&lt;br/&gt;示例代码如下：&lt;/p&gt;
&lt;pre readability=&quot;7.5&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;9&quot;&gt;package com.atguigu.chapter05.fundetails&lt;p&gt;object Details04 {&lt;br/&gt;def main(args: Array[String]): Unit = { // public void main(String[] args)&lt;/p&gt;&lt;p&gt;def f1():Unit = { // private final void f1$1&lt;br/&gt;println(&quot;f1&quot;)&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;def sayok(): Unit = { // private final void sayok$1&lt;br/&gt;println(&quot;sayok~&quot;)&lt;br/&gt;def sayok(): Unit = { // private final void sayok$2&lt;br/&gt;println(&quot;sayok~~&quot;)&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;println(&quot;ok&quot;)&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;def sayok(): Unit = { // public void sayok()&lt;br/&gt;println(&quot;sayok&quot;)&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  9、Scala 函数的形参，在声明参数时，直接赋初始值(默认值)，这时调用函数时，如果没有指定实参，则会使用默认值。如果指定了实参，则&lt;code&gt;实参会覆盖默认值&lt;/code&gt;。&lt;br/&gt;示例代码如下：&lt;/p&gt;
&lt;pre readability=&quot;5.5&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;5&quot;&gt;package com.atguigu.chapter05.fundetails&lt;p&gt;object Details05 {&lt;br/&gt;def main(args: Array[String]): Unit = {&lt;br/&gt;println(sayOk())      // jack ok!&lt;br/&gt;println(sayOk(&quot;tom&quot;)) // tom ok!&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;def sayOk(name: String = &quot;jack&quot;): String = {&lt;br/&gt;return name + &quot; ok! &quot;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  10、如果函数存在多个参数，每一个参数都可以设定默认值，那么这个时候，传递的参数到底是覆盖默认值，还是赋值给没有默认值的参数，就不确定了(默认按照声明顺序[&lt;strong&gt;从左到右&lt;/strong&gt;])。在这种情况下，可以采用&lt;strong&gt;带名参数&lt;/strong&gt;。&lt;br/&gt;示例代码如下：&lt;/p&gt;
&lt;pre readability=&quot;13&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;20&quot;&gt;package com.atguigu.chapter05.fundetails&lt;p&gt;object Details06 {&lt;br/&gt;def main(args: Array[String]): Unit = {&lt;br/&gt;mysqlCon()&lt;br/&gt;mysqlCon(&quot;127.0.0.1&quot;, 7777) // 从左到右覆盖&lt;/p&gt;&lt;p&gt;// 如果我们希望指定覆盖某一个默认值，则使用带名参数即可，比如只想修改用户名和密码，其他的不改&lt;br/&gt;mysqlCon(user = &quot;tom&quot;, pwd = &quot;1234&quot;)&lt;/p&gt;&lt;p&gt;// 练习&lt;br/&gt;// f6(&quot;v2&quot;) // 报错，p2的值没有指定&lt;br/&gt;f6(p2 = &quot;v2&quot;) // v1v2&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;def mysqlCon(add: String = &quot;localhost&quot;, port: Int = 3306,&lt;br/&gt;user: String = &quot;root&quot;, pwd: String = &quot;root&quot;): Unit = {&lt;br/&gt;println(&quot;add=&quot; + add)&lt;br/&gt;println(&quot;port=&quot; + port)&lt;br/&gt;println(&quot;user=&quot; + user)&lt;br/&gt;println(&quot;pwd=&quot; + pwd)&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;def f6(p1: String = &quot;v1&quot;, p2: String) {&lt;br/&gt;println(p1 + p2);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  11、&lt;code&gt;scala 函数的形参默认是 val 的&lt;/code&gt;，因此不能在函数中进行修改。&lt;/p&gt;
&lt;p&gt;  12、递归函数未执行之前是无法推断出来结果类型，在使用时必须有明确的返回值类型。&lt;br/&gt;示例代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;scala language-scala&quot;&gt;  def f(n: Int) = { // 错误，递归不能使用类型推断，必须指定返回的数据类型。&lt;br/&gt;if (n &amp;lt;= 0)&lt;br/&gt;1&lt;br/&gt;else&lt;br/&gt;n * f(n - 1)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  13、Scala 函数支持&lt;code&gt;可变参数&lt;/code&gt;。&lt;br/&gt;示例代码如下：&lt;/p&gt;
&lt;pre readability=&quot;4.5&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;3&quot;&gt;  // 支持0到多个参数&lt;br/&gt;def sum(args: Int*): Int = {&lt;br/&gt;}&lt;p&gt;// 支持1到多个参数&lt;br/&gt;def sum(n1: Int, args: Int*): Int = {&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  说明:&lt;br/&gt;  1、&lt;code&gt;args 是集合, 通过 for 循环 可以访问到各个值&lt;/code&gt;。【args 是参数名，可以任意起】&lt;br/&gt;  2、案例演示： 编写一个函数 sum，可以求出 1 到多个 int 的和。&lt;br/&gt;  3、可变参数需要写在形参列表的最后。&lt;br/&gt;示例代码如下：&lt;/p&gt;
&lt;pre readability=&quot;7.5&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;9&quot;&gt;package com.atguigu.chapter05.fundetails&lt;p&gt;object VarParameters {&lt;br/&gt;def main(args: Array[String]): Unit = {&lt;br/&gt;println(sum(10, 20, 30)) // 这里可变参数为2个&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;// 支持1到多个参数&lt;br/&gt;def sum(n1: Int, args: Int*): Int = {&lt;br/&gt;println(&quot;args.length=&quot; + args.length)&lt;br/&gt;var sum = n1&lt;br/&gt;for (item &amp;lt;- args) {&lt;br/&gt;sum += item&lt;br/&gt;}&lt;br/&gt;sum&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h57&quot;&gt;&lt;span&gt;&lt;strong&gt;5.7 函数练习题&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;判断下面的代码是否正确：&lt;br/&gt;示例代码如下：&lt;/p&gt;
&lt;pre readability=&quot;5&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;4&quot;&gt;  object Hello01 {&lt;br/&gt;def main(args: Array[String]): Unit = {&lt;br/&gt;def f1 = &quot;venassa&quot;&lt;br/&gt;println(f1) // 输出 venassa&lt;br/&gt;}&lt;br/&gt;}&lt;p&gt;// 上面代码 def f1 = &quot;venassa&quot; 等价于&lt;br/&gt;def f1() = {&lt;br/&gt;&quot;venassa&quot;&lt;br/&gt;}&lt;br/&gt;// 说明：&lt;br/&gt;// 1、函数的形参列表可以是多个，如果函数没有形参，函数可以不带()。&lt;br/&gt;// 2、函数的函数体只有一行代码时，可以省略{}。&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h58&quot;&gt;&lt;span&gt;&lt;strong&gt;5.8 过程&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h4 id=&quot;h581&quot;&gt;&lt;span&gt;&lt;strong&gt;5.8.1 基本概念&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;基本介绍：&lt;/strong&gt;&lt;br/&gt;  将函数的返回类型为 Unit 的函数称之为过程(procedure)，如果明确函数没有返回值，那么等号可以省略。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;案例说明：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;scala language-scala&quot;&gt;  // f10 没有返回值，可以使用 Unit 来说明&lt;br/&gt;// 这时，这个函数我们也叫过程（procedure）&lt;br/&gt;def f10(name: String): Unit = { // 如果明确函数没有返回值，那么等号可以省略。&lt;br/&gt;println(name+ &quot;hello&quot;)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;h582&quot;&gt;&lt;span&gt;&lt;strong&gt;5.8.2 注意事项和细节说明&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;  1、注意区分: 如果函数声明时没有返回值类型，但是有 = 号，可以进行&lt;strong&gt;类型推断&lt;/strong&gt;最后一行代码。这时这个函数实际是有返回值的，该函数并不是过程。(这点在讲解函数细节的时候讲过的)&lt;br/&gt;  2、开发工具的自动代码补全功能，虽然会自动加上 Unit，但是考虑到 Scala 语言的简单，灵活，最好不加。&lt;/p&gt;
&lt;h3 id=&quot;h59&quot;&gt;&lt;span&gt;&lt;strong&gt;5.9 惰性函数&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h4 id=&quot;h591&quot;&gt;&lt;span&gt;&lt;strong&gt;5.9.1 看一个应用场景&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;  惰性计算（&lt;code&gt;尽可能延迟表达式求值&lt;/code&gt;）是许多函数式编程语言的特性。惰性集合在需要时提供其元素，无需预先计算它们，这带来了一些好处。首先，您可以将耗时的计算推迟到绝对需要的时候。其次，您可以创造无限个集合，只要它们继续收到请求，就会继续提供元素。函数的惰性使用让您能够得到更高效的代码。Java 并没有为惰性提供原生支持，Scala 提供了。&lt;/p&gt;
&lt;h4 id=&quot;h592&quot;&gt;&lt;span&gt;&lt;strong&gt;5.9.2 画图说明（大数据推荐系统）&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/26/Aa9akD.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h593java&quot;&gt;&lt;span&gt;&lt;strong&gt;5.9.3 Java 实现懒加载的代码&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;示例代码如下：&lt;/p&gt;
&lt;pre readability=&quot;5&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;4&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;package&lt;/span&gt; com.atguigu.chapter05;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;LazyDemo&lt;/span&gt; &lt;/span&gt;{&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; String property; &lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;hljs-title&quot;&gt;getProperty&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (property == &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;) { &lt;br/&gt;property = initProperty();&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; property;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; String &lt;span class=&quot;hljs-title&quot;&gt;initProperty&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;property&quot;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;h594&quot;&gt;&lt;span&gt;&lt;strong&gt;5.9.4 惰性函数介绍&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;  &lt;code&gt;当函数返回值被声明为 lazy 时&lt;/code&gt;，函数的执行将被推迟，直到我们首次对此取值，该函数才会执行，这种函数我们称之为&lt;code&gt;惰性函数&lt;/code&gt;。在 Java 的某些框架代码中称之为&lt;code&gt;懒加载(延迟加载)&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&quot;h595&quot;&gt;&lt;span&gt;&lt;strong&gt;5.9.5 案例演示&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;示例代码如下：&lt;/p&gt;
&lt;pre readability=&quot;6.5&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;7&quot;&gt;package com.atguigu.chapter05.mylazy&lt;p&gt;object LazyDemo01 {&lt;br/&gt;def main(args: Array[String]): Unit = {&lt;br/&gt;lazy val res = sum(10, 20)&lt;br/&gt;println(&quot;----------&quot;)&lt;br/&gt;println(&quot;res=&quot; + res) // 在要使用 res 前，才执行&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;def sum(n1: Int, n2: Int): Int = {&lt;br/&gt;println(&quot;sum() 执行了..&quot;)&lt;br/&gt;return n1 + n2&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs makefile&quot;&gt;----------&lt;br/&gt;sum() 执行了..&lt;br/&gt;res=30&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;h596&quot;&gt;&lt;span&gt;&lt;strong&gt;5.9.6 注意事项和细节&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;  1、lazy 不能修饰 var 类型的变量。&lt;br/&gt;  2、不但是在调用函数时，加了 lazy，会导致函数的执行被推迟，&lt;code&gt;我们在声明一个变量时，如果声明了 lazy，那么变量值的分配也会推迟&lt;/code&gt;。 比如 lazy val i = 10。&lt;/p&gt;
&lt;h3 id=&quot;h510&quot;&gt;&lt;span&gt;&lt;strong&gt;5.10 异常&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h4 id=&quot;h5101&quot;&gt;&lt;span&gt;&lt;strong&gt;5.10.1 介绍&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;  &lt;code&gt;Scala 提供 try 块和 catch 块来处理异常&lt;/code&gt;。try 块用于包含可能出错的代码。catch 块用于处理 try 块中发生的异常。可以根据需要在程序中有任意数量的 try…catch 块。&lt;br/&gt;  语法处理上和 Java 类似，但是又不尽相同。&lt;/p&gt;
&lt;h4 id=&quot;h5102java&quot;&gt;&lt;span&gt;&lt;strong&gt;5.10.2 Java 异常处理回顾&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;示例代码如下：&lt;/p&gt;
&lt;pre readability=&quot;6&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;6&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;package&lt;/span&gt; com.atguigu.chapter05.exception;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;JavaExceptionDemo&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; b = &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; c = b / i; &lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;e.printStackTrace();&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;finally&lt;/span&gt; {&lt;br/&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;java finally&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;继续执行&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;java &lt;span class=&quot;hljs-keyword&quot;&gt;finally&lt;/span&gt;&lt;br/&gt;继续执行&lt;br/&gt;java.lang.ArithmeticException: / by zero&lt;br/&gt;at com.atguigu.chapter05.exception.JavaExceptionDemo.main(JavaExceptionDemo.java:&lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;h5103java&quot;&gt;&lt;span&gt;&lt;strong&gt;5.10.3 Java 异常处理的注意点&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;  1、java 语言按照 try-catch-catch…-finally 的方式来处理异常。&lt;br/&gt;  2、不管有没有异常捕获，都会执行 finally，因此通常可以在 finally 代码块中释放资源。&lt;br/&gt;  3、可以有多个 catch，分别捕获对应的异常，这时需要把范围小的异常类写在前面，把范围大的异常类写在后面，否则编译错误。会提示 &quot;Exception 'java.lang.xxxxxx' has already been caught&quot;。&lt;/p&gt;
&lt;h4 id=&quot;h5104scala&quot;&gt;&lt;span&gt;&lt;strong&gt;5.10.4 Scala 异常处理举例&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;示例代码如下：&lt;/p&gt;
&lt;pre readability=&quot;7&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;8&quot;&gt;package com.atguigu.chapter05.exception&lt;p&gt;object ScalaExceptionDemo {&lt;br/&gt;def main(args: Array[String]): Unit = {&lt;br/&gt;try {&lt;br/&gt;val r = 10 / 0&lt;br/&gt;} catch {&lt;br/&gt;// 说明&lt;br/&gt;// 1. 在 scala 中只有一个 catch&lt;br/&gt;// 2. 在 catch 中有多个 case, 每个 case 可以匹配一种异常&lt;br/&gt;// 3. =&amp;gt; 关键符号，表示后面是对该异常的处理代码块&lt;br/&gt;// 4. finally 最终要执行的代码&lt;br/&gt;case ex: ArithmeticException =&amp;gt; { println(&quot;捕获了除数为零的算数异常&quot;) } // 当对该异常的处理代码块为一行时，{}可以省略&lt;br/&gt;case ex: Exception =&amp;gt; println(&quot;捕获了异常&quot;)&lt;br/&gt;} finally {&lt;br/&gt;// 最终要执行的代码&lt;br/&gt;println(&quot;scala finally&quot;)&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;System.out.println(&quot;继续执行&quot;)&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;捕获了除数为零的算数异常&lt;br/&gt;scala &lt;span class=&quot;hljs-keyword&quot;&gt;finally&lt;/span&gt;&lt;br/&gt;继续执行&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;h5105scala&quot;&gt;&lt;span&gt;&lt;strong&gt;5.10.5 Scala 异常处理小结&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;  1、我们&lt;code&gt;将可疑代码封装在 try 块中&lt;/code&gt;。在 try 块之后使用了一个 catch 处理程序来捕获异常。如果发生任何异常，catch 处理程序将处理它，&lt;code&gt;异常处理了程序将不会异常终止&lt;/code&gt;。&lt;br/&gt;  2、Scala 的异常的工作机制和 Java 一样，但是 &lt;code&gt;Scala 没有“checked(编译期)” 异常&lt;/code&gt;，即 Scala 没有编译异常这个概念，异常都是在运行的时候捕获处理。&lt;br/&gt;  3、Scala &lt;code&gt;用 throw 关键字，抛出一个异常对象&lt;/code&gt;。所有异常都是 Throwable 的子类型。throw 表达式是有类型的，就是 Nothing，因为 Nothing 是所有类型的子类型，所以 throw 表达式可以用在需要类型的地方。&lt;br/&gt;示例代码如下：&lt;/p&gt;
&lt;pre readability=&quot;10&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;14&quot;&gt;package com.atguigu.chapter05.exception&lt;p&gt;object ThrowDemo {&lt;br/&gt;def main(args: Array[String]): Unit = {&lt;br/&gt;// val res = test()&lt;br/&gt;// println(res.toString)&lt;br/&gt;// println(&quot;继续执行002&quot;) // 异常抛出了，但是没有被处理，后续程序不能执行&lt;/p&gt;&lt;p&gt;// 如果我们希望在 test() 抛出异常后，后续代码可以继续执行，则我们需要如下处理&lt;br/&gt;try {&lt;br/&gt;test()&lt;br/&gt;} catch {&lt;br/&gt;case ex: Exception =&amp;gt; {&lt;br/&gt;println(&quot;捕获到异常是：&quot; + ex.getMessage)&lt;br/&gt;println(&quot;继续执行001&quot;)&lt;br/&gt;}&lt;br/&gt;case ex: ArithmeticException =&amp;gt; println(&quot;得到一个算术异常（小范围异常）&quot;)&lt;br/&gt;} finally {&lt;br/&gt;// 写上对 try{} 中的资源的分配&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;println(&quot;继续执行002&quot;)&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;def test(): Nothing = {&lt;br/&gt;// Exception(&quot;异常出现&quot;)&lt;br/&gt;throw new ArithmeticException(&quot;算术异常&quot;)&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;捕获到异常是：算术异常&lt;br/&gt;继续执行&lt;span class=&quot;hljs-number&quot;&gt;001&lt;/span&gt;&lt;br/&gt;继续执行&lt;span class=&quot;hljs-number&quot;&gt;002&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  4、在 Scala 里，借用了&lt;code&gt;模式匹配的思想来做异常的匹配&lt;/code&gt;，因此，在 catch 的代码里，是一系列 case 子句来匹配异常。【前面案例可以看出这个特点，模式匹配我们后面详解】，当匹配上后 =&amp;gt; 有多条语句可以换行写，类似 java 的 switch case x: 代码块…&lt;br/&gt;  5、异常捕捉的机制与其他语言中一样，如果有异常发生，catch 子句是按次序捕捉的。因此，在 catch 子句中，&lt;code&gt;越具体的异常越要靠前，越普遍的异常越靠后&lt;/code&gt;，如果把越普遍的异常写在前，把具体的异常写在后，在 scala 中也不会报错，但这样是非常不好的编程风格。&lt;br/&gt;  6、finally 子句用于执行不管是正常处理还是有异常发生时都需要执行的步骤，一般用于对象的清理工作，这点和 Java 一样。&lt;br/&gt;  7、Scala 提供了 throws 关键字来声明异常。可以使用方法定义声明异常。它向调用者函数提供了此方法可能引发此异常的信息。它有助于调用函数处理并将该代码包含在 try-catch 块中，以避免程序异常终止。在 scala 中，可以使用 throws 注释来声明异常。&lt;br/&gt;示例代码如下：&lt;/p&gt;
&lt;pre readability=&quot;5.5&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;5&quot;&gt;package com.atguigu.chapter05.exception&lt;p&gt;object ThrowsComment {&lt;br/&gt;def main(args: Array[String]): Unit = {&lt;br/&gt;f()&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;@throws(classOf[NumberFormatException]) // 等同于 Java 中 NumberFormatException.class&lt;br/&gt;def f() = {&lt;br/&gt;&quot;abc&quot;.toInt&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;Exception in thread &lt;span class=&quot;hljs-string&quot;&gt;&quot;main&quot;&lt;/span&gt; java.lang.NumberFormatException: For input string: &lt;span class=&quot;hljs-string&quot;&gt;&quot;abc&quot;&lt;/span&gt;&lt;br/&gt;at java.lang.NumberFormatException.forInputString(NumberFormatException.java:&lt;span class=&quot;hljs-number&quot;&gt;65&lt;/span&gt;)&lt;br/&gt;at java.lang.Integer.parseInt(Integer.java:&lt;span class=&quot;hljs-number&quot;&gt;580&lt;/span&gt;)&lt;br/&gt;at java.lang.Integer.parseInt(Integer.java:&lt;span class=&quot;hljs-number&quot;&gt;615&lt;/span&gt;)&lt;br/&gt;at scala.collection.immutable.StringLike$&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt;.&lt;span class=&quot;hljs-title&quot;&gt;toInt&lt;/span&gt;(&lt;span class=&quot;hljs-title&quot;&gt;StringLike&lt;/span&gt;.&lt;span class=&quot;hljs-title&quot;&gt;scala&lt;/span&gt;:272)&lt;br/&gt;&lt;span class=&quot;hljs-title&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;scala&lt;/span&gt;.&lt;span class=&quot;hljs-title&quot;&gt;collection&lt;/span&gt;.&lt;span class=&quot;hljs-title&quot;&gt;immutable&lt;/span&gt;.&lt;span class=&quot;hljs-title&quot;&gt;StringOps&lt;/span&gt;.&lt;span class=&quot;hljs-title&quot;&gt;toInt&lt;/span&gt;(&lt;span class=&quot;hljs-title&quot;&gt;StringOps&lt;/span&gt;.&lt;span class=&quot;hljs-title&quot;&gt;scala&lt;/span&gt;:29)&lt;br/&gt;&lt;span class=&quot;hljs-title&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;com&lt;/span&gt;.&lt;span class=&quot;hljs-title&quot;&gt;atguigu&lt;/span&gt;.&lt;span class=&quot;hljs-title&quot;&gt;chapter05&lt;/span&gt;.&lt;span class=&quot;hljs-title&quot;&gt;exception&lt;/span&gt;.&lt;span class=&quot;hljs-title&quot;&gt;ThrowsComment&lt;/span&gt;$.&lt;span class=&quot;hljs-title&quot;&gt;f&lt;/span&gt;(&lt;span class=&quot;hljs-title&quot;&gt;ThrowsComment&lt;/span&gt;.&lt;span class=&quot;hljs-title&quot;&gt;scala&lt;/span&gt;:10)&lt;br/&gt;&lt;span class=&quot;hljs-title&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;com&lt;/span&gt;.&lt;span class=&quot;hljs-title&quot;&gt;atguigu&lt;/span&gt;.&lt;span class=&quot;hljs-title&quot;&gt;chapter05&lt;/span&gt;.&lt;span class=&quot;hljs-title&quot;&gt;exception&lt;/span&gt;.&lt;span class=&quot;hljs-title&quot;&gt;ThrowsComment&lt;/span&gt;$.&lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;(&lt;span class=&quot;hljs-title&quot;&gt;ThrowsComment&lt;/span&gt;.&lt;span class=&quot;hljs-title&quot;&gt;scala&lt;/span&gt;:5)&lt;br/&gt;&lt;span class=&quot;hljs-title&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;com&lt;/span&gt;.&lt;span class=&quot;hljs-title&quot;&gt;atguigu&lt;/span&gt;.&lt;span class=&quot;hljs-title&quot;&gt;chapter05&lt;/span&gt;.&lt;span class=&quot;hljs-title&quot;&gt;exception&lt;/span&gt;.&lt;span class=&quot;hljs-title&quot;&gt;ThrowsComment&lt;/span&gt;.&lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;(&lt;span class=&quot;hljs-title&quot;&gt;ThrowsComment&lt;/span&gt;.&lt;span class=&quot;hljs-title&quot;&gt;scala&lt;/span&gt;)&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h511-1&quot;&gt;&lt;span&gt;&lt;strong&gt;5.11 函数的练习题&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;1、函数可以没有返回值案例，编写一个函数，从终端输入一个整数打印出对应的金子塔。&lt;br/&gt;示例代码如下：&lt;/p&gt;
&lt;pre readability=&quot;7.5&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;9&quot;&gt;package com.atguigu.chapter05.exercises&lt;p&gt;import scala.io.StdIn&lt;/p&gt;&lt;p&gt;/**&lt;br/&gt;* 1、函数可以没有返回值案例，编写一个函数，从终端输入一个整数打印出对应的金子塔。&lt;br/&gt;* 思路：本质是打印出所有的 n行m列 数据。 分别循环即可！&lt;br/&gt;*/&lt;br/&gt;object Exercise01 {&lt;br/&gt;def main(args: Array[String]): Unit = {&lt;br/&gt;println(&quot;请输入一个整数n(n&amp;gt;=1)：&quot;)&lt;br/&gt;val n = StdIn.readInt()&lt;br/&gt;printJin(n)&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;def printJin(n: Int): Unit = {&lt;br/&gt;for (i &amp;lt;- 1 to n) { // 行数&lt;br/&gt;for (j &amp;lt;- 1 to (n - i)) {&lt;br/&gt;printf(&quot;-&quot;)&lt;br/&gt;}&lt;br/&gt;for (j &amp;lt;- 1 to (2 * i - 1)) { // 列数&lt;br/&gt;printf(&quot;*&quot;)&lt;br/&gt;}&lt;br/&gt;for (j &amp;lt;- 1 to (n - i)) {&lt;br/&gt;printf(&quot;-&quot;)&lt;br/&gt;}&lt;br/&gt;println()&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;请输入一个整数n(n&amp;gt;=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)：&lt;br/&gt;&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;&lt;br/&gt;----*----&lt;br/&gt;---***---&lt;br/&gt;--*****--&lt;br/&gt;-*******-&lt;br/&gt;*********&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、编写一个函数，从终端输入一个整数(1—9)，打印出对应的乘法表。&lt;br/&gt;示例代码如下：&lt;/p&gt;
&lt;pre readability=&quot;8&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;10&quot;&gt;package com.atguigu.chapter05.exercises&lt;p&gt;import scala.io.StdIn&lt;/p&gt;&lt;p&gt;/**&lt;br/&gt;* 2、编写一个函数，从终端输入一个整数(1—9)，打印出对应的乘法表。&lt;br/&gt;*/&lt;br/&gt;object Exercise01 {&lt;br/&gt;def main(args: Array[String]): Unit = {&lt;br/&gt;println(&quot;请输入数字（1-9）之间：&quot;)&lt;br/&gt;val n = StdIn.readInt()&lt;br/&gt;print99(n)&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;def print99(n: Int): Unit = {&lt;br/&gt;for (i &amp;lt;- 1 to n) {&lt;br/&gt;for (j &amp;lt;- 1 to i) {&lt;br/&gt;printf(&quot;%d * %d = %d\t&quot;, j, i, j * i)&lt;br/&gt;}&lt;br/&gt;println()&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3、编写函数，对给定的一个二维数组 (3×3) 转置，这个题讲数组的时候再完成。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs&quot;&gt;    1 2 3       1 4 7            &lt;br/&gt;4 5 6       2 5 8               &lt;br/&gt;7 8 9       3 6 9&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;h-1&quot;&gt;&lt;span&gt;&lt;strong&gt;第六章 面向对象编程-基础&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;h61&quot;&gt;&lt;span&gt;&lt;strong&gt;6.1 类与对象&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;看一个养猫猫问题：&lt;/strong&gt;&lt;br/&gt;  张老太养了只猫猫：一只名字叫小白，今年3岁，白色。还有一只叫小花，今年10岁，花色。请编写一个程序，当用户输入小猫的名字时，就显示该猫的名字，年龄，颜色。如果用户输入的小猫名错误，则显示张老太没有这只猫猫。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;问题：&lt;/strong&gt;&lt;br/&gt;  1、猫有三个属性，类型不一样。&lt;br/&gt;  2、如果使用普通的变量就不好管理。&lt;br/&gt;  3、使用一种新的数据类型：&lt;br/&gt;    (1) 可以管理多个不同类型的数据 [属性]。&lt;br/&gt;    (2) 可以对属性进行操作 =&amp;gt; 方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;类与对象的关系示意图&lt;/strong&gt;&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/26/Aa9GOx.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h611scala&quot;&gt;&lt;span&gt;&lt;strong&gt;6.1.1 Scala 语言是面向对象的&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;  1、Java 是面向对象的编程语言，由于历史原因，Java 中还存在着非面向对象的内容：基本类型，null，静态方法等。&lt;br/&gt;  2、Scala 语言来自于 Java，所以天生就是面向对象的语言，而且 Scala 是纯粹的面向对象的语言，即在 Scala 中，一切皆为对象。&lt;br/&gt;  3、在面向对象的学习过程中可以对比着 Java 语言学习。&lt;/p&gt;
&lt;h4 id=&quot;h612&quot;&gt;&lt;span&gt;&lt;strong&gt;6.1.2 快速入门-面向对象的方式解决养猫问题&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;示例代码如下：&lt;/p&gt;
&lt;pre readability=&quot;17.5&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;29&quot;&gt;package com.atguigu.chapter06.oop&lt;p&gt;object CatDemo {&lt;br/&gt;def main(args: Array[String]): Unit = {&lt;/p&gt;&lt;p&gt;// 创建一只猫&lt;br/&gt;val cat = new Cat&lt;/p&gt;&lt;p&gt;// 给猫的属性赋值&lt;br/&gt;// 说明&lt;br/&gt;// 1. cat.name = &quot;小白&quot; 其实不是直接访问属性，而是等价于 cat.name_$eq(&quot;小白&quot;)&lt;br/&gt;// 2. cat.name 等价于 cat.name()&lt;br/&gt;cat.name = &quot;小白&quot;&lt;br/&gt;cat.age = 3&lt;br/&gt;cat.color = &quot;白色&quot;&lt;/p&gt;&lt;p&gt;printf(&quot;\n小猫的信息如下：%s %d %s&quot;, cat.name, cat.age, cat.color)&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;/* 反编译查看源码&lt;br/&gt;public void main (String[] args) {&lt;br/&gt;Cat cat = new Cat ();&lt;/p&gt;&lt;p&gt;cat.name_$eq (&quot;小白&quot;);&lt;br/&gt;cat.age_$eq (3);&lt;br/&gt;cat.color_$eq (&quot;白色&quot;);&lt;br/&gt;}&lt;br/&gt;*/&lt;/p&gt;&lt;p&gt;// 定义一个 Cat 类&lt;br/&gt;// 一个class Cat 对应的字节码文件只有一个 Cat.class ，默认是public&lt;br/&gt;class Cat {&lt;br/&gt;// 定义/声明三个属性&lt;br/&gt;// 说明&lt;br/&gt;// 1. 当我们声明了 var name: String 时，同时在底层对应生成 private name&lt;br/&gt;// 2. 同时在底层会生成 两个 public 方法 public String name() 类似 =&amp;gt; getter 和 public void name_$eq(String x$1) =&amp;gt; setter&lt;br/&gt;var name: String = &quot;&quot; // Scala 中定义变量必须给初始值&lt;br/&gt;var age: Int = _ // 下划线表示给 age 一个默认值，如果是 Int 类型，默认就是 0&lt;br/&gt;var color: String = _ // 如果是 String 类型，默认值就是 null&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;/* 反编译查看源码&lt;br/&gt;public class Cat {&lt;br/&gt;private String name = &quot;&quot;;&lt;br/&gt;private int age;&lt;br/&gt;private String color;&lt;/p&gt;&lt;p&gt;public String name() {&lt;br/&gt;return this.name;&lt;br/&gt;}&lt;br/&gt;public void name_$eq(String x$1) {&lt;br/&gt;this.name = x$1;&lt;br/&gt;}&lt;br/&gt;public int age() {&lt;br/&gt;return this.age;&lt;br/&gt;}&lt;br/&gt;public void age_$eq(int x$1) {&lt;br/&gt;this.age = x$1;&lt;br/&gt;}&lt;br/&gt;public String color() {&lt;br/&gt;return this.color;&lt;br/&gt;}&lt;br/&gt;public void color_$eq(String x$1) {&lt;br/&gt;this.color = x$1;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;*/&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs&quot;&gt;小猫的信息如下：小白 3 白色&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;h613&quot;&gt;&lt;span&gt;&lt;strong&gt;6.1.3 类和对象的区别和联系&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;通过上面的案例和讲解我们可以看出：&lt;br/&gt;  1、类是抽象的，概念的，代表一类事物，比如人类，猫类…&lt;br/&gt;  2、对象是具体的，实际的，代表一个具体事物。&lt;br/&gt;  3、类是对象的模板，对象是类的一个个体，对应一个实例。&lt;br/&gt;  4、Scala 中类和对象的区别和联系 和 Java 是一样的。&lt;/p&gt;
&lt;h4 id=&quot;h614&quot;&gt;&lt;span&gt;&lt;strong&gt;6.1.4 如何定义类&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/26/Aa9Ym6.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;我们可以通过&lt;strong&gt;反编译&lt;/strong&gt;来看 scala 的类默认为 public 的特性。
&lt;h4 id=&quot;h615&quot;&gt;&lt;span&gt;&lt;strong&gt;6.1.5 属性&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/26/Aa9t0K.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;示例代码如下：

&lt;pre&gt;
&lt;code class=&quot;scala language-scala&quot;&gt;class Dog {&lt;br/&gt;var name = &quot;jack&quot;&lt;br/&gt;var lover = new Fish&lt;br/&gt;}&lt;p&gt;class Fish {&lt;/p&gt;&lt;p&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;h616&quot;&gt;&lt;span&gt;&lt;strong&gt;6.1.6 属性/成员变量&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/26/Aa9wfH.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;示例代码如下：

&lt;pre readability=&quot;12&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;18&quot;&gt;package com.atguigu.chapter06.oop&lt;p&gt;object PropertyDemo {&lt;br/&gt;def main(args: Array[String]): Unit = {&lt;br/&gt;// val p1 = new Person&lt;br/&gt;// println(p1.Name)     // Null&lt;br/&gt;// println(p1.address)  // String 类型&lt;/p&gt;&lt;p&gt;val a = new A&lt;br/&gt;println(a.var1) // null&lt;br/&gt;println(a.var2) // 0&lt;br/&gt;println(a.var3) // 0.0&lt;br/&gt;println(a.var4) // false&lt;/p&gt;&lt;p&gt;// 不同对象的属性是独立，互不影响，一个对象对属性的更改，不影响另外一个&lt;br/&gt;// 创建两个对象&lt;br/&gt;var worker1 = new Worker&lt;br/&gt;worker1.name = &quot;jack&quot;&lt;br/&gt;var worker2 = new Worker&lt;br/&gt;worker2.name = &quot;tom&quot;&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;class Person3 {&lt;br/&gt;var age: Int = 10   // 给属性赋初值，省略类型，会自动推导&lt;br/&gt;var sal = 8090.9&lt;br/&gt;var Name = null     // Name 是什么类型&lt;br/&gt;var address: String = null // ok&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;class A {&lt;br/&gt;var var1: String = _  // null   String 和 引用类型默认值是 null&lt;br/&gt;var var2: Byte = _    // 0&lt;br/&gt;var var3: Double = _  // 0.0&lt;br/&gt;var var4: Boolean = _ // false&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;class Worker {&lt;br/&gt;var name = &quot;&quot;&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs coffeescript&quot;&gt;&lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-number&quot;&gt;0.0&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;h617&quot;&gt;&lt;span&gt;&lt;strong&gt;6.1.7 属性的高级部分&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;  说明：属性的高级部分和构造器(构造方法/函数) 相关，我们把属性高级部分放到构造器那里讲解。&lt;/p&gt;
&lt;h4 id=&quot;h618&quot;&gt;&lt;span&gt;&lt;strong&gt;6.1.8 如何创建对象&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/26/Aa9NTO.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;示例代码如下：
&lt;pre readability=&quot;7&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;8&quot;&gt;package com.atguigu.chapter06.oop&lt;p&gt;object CreateObjDemo {&lt;br/&gt;def main(args: Array[String]): Unit = {&lt;br/&gt;val emp = new Emp // 此时的 emp 类型就是 Emp&lt;/p&gt;&lt;p&gt;// 如果我们希望将子类对象，交给父类引用，这时就需要写上类型，不能省略！&lt;br/&gt;val emp1: Person = new Emp&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;class Person {&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;class Emp extends Person {&lt;/p&gt;&lt;p&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;h619&quot;&gt;&lt;span&gt;&lt;strong&gt;6.1.9 类和对象的内存分配机制（重要）&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;内存布局图：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/26/Aa9D1A.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;示例代码如下：
&lt;pre readability=&quot;7.5&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;9&quot;&gt;package com.atguigu.chapter06.oop&lt;p&gt;object MemState {&lt;br/&gt;def main(args: Array[String]): Unit = {&lt;br/&gt;val p2 = new Person2&lt;br/&gt;p2.name = &quot;jack&quot;&lt;br/&gt;p2.age= 10&lt;/p&gt;&lt;p&gt;val p1 = p2&lt;br/&gt;println(p1 == p2) // true&lt;br/&gt;println(&quot;p2.age=&quot; + p2.age) // 10&lt;br/&gt;println(&quot;p1.age=&quot; + p1.age) // 10&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;class Person2 {&lt;br/&gt;var name = &quot;&quot;&lt;br/&gt;var age: Int = _ // 如果是用下划线的方式给默认值，则属性必须指定类型，因为这有这样，scala 底层才能够进行类型推断&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h62&quot;&gt;&lt;span&gt;&lt;strong&gt;6.2 方法&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h4 id=&quot;h621&quot;&gt;&lt;span&gt;&lt;strong&gt;6.2.1 基本说明和基本语法&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/26/Aa9dte.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;示例代码如下：
&lt;pre readability=&quot;7.5&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;9&quot;&gt;package com.atguigu.chapter06.method&lt;p&gt;object MethodDemo01 {&lt;br/&gt;def main(args: Array[String]): Unit = {&lt;br/&gt;// 使用一把&lt;br/&gt;val dog = new Dog&lt;br/&gt;println(dog.cal(10, 20))&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;class Dog {&lt;br/&gt;private var sal: Double = _&lt;br/&gt;var food: String = _&lt;/p&gt;&lt;p&gt;def cal(n1: Int, n2: Int): Int = {&lt;br/&gt;return n1 + n2&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;h622&quot;&gt;&lt;span&gt;&lt;strong&gt;6.2.2 方法的调用机制原理&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/26/Aa96nP.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h623&quot;&gt;&lt;span&gt;&lt;strong&gt;6.2.3 方法练习题&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/26/Aa9Bpd.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;1~3题的示例代码如下：
&lt;pre readability=&quot;15.5&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;25&quot;&gt;package com.atguigu.chapter06.method&lt;p&gt;/**&lt;br/&gt;* 1、编写类(MethodExec)，编写一个方法，方法不需要参数，在方法中打印一个10*8的矩形，在main方法中调用该方法。&lt;br/&gt;*&lt;br/&gt;* 2、修改上一个程序，编写一个方法中，方法不需要参数，计算该矩形的面积，并将其作为方法返回值。在main方法中调用该方法，接收返回的面积值并打印(结果保留小数点2位)。&lt;br/&gt;*&lt;br/&gt;* 3、修改上一个程序，编写一个方法，提供m和n两个参数，方法中打印一个m*n的矩形，再编写一个方法计算该矩形的面积(可以接收长len和宽width)， 将其作为方法返回值。在main方法中调用该方法，接收返回的面积值并打印。&lt;br/&gt;*/&lt;br/&gt;object MethodDemo02 {&lt;br/&gt;def main(args: Array[String]): Unit = {&lt;br/&gt;val m = new MethodExec&lt;br/&gt;m.printRect1()&lt;/p&gt;&lt;p&gt;m.len = 1.2&lt;br/&gt;m.width = 3.4&lt;br/&gt;println(&quot;面积=&quot; + m.area1())&lt;/p&gt;&lt;p&gt;m.printRect2(5, 4)&lt;br/&gt;println(&quot;面积=&quot; + m.area2(1.2, 3.4))&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;class MethodExec {&lt;/p&gt;&lt;p&gt;var len = 0.0&lt;br/&gt;var width = 0.0&lt;/p&gt;&lt;p&gt;def printRect1(): Unit = {&lt;br/&gt;for (i &amp;lt;- 0 until 10) {&lt;br/&gt;for (j &amp;lt;- 0 until 8) {&lt;br/&gt;print(&quot;*&quot;)&lt;br/&gt;}&lt;br/&gt;println()&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;def area1(): Double = {&lt;br/&gt;this.len * this.width.formatted(&quot;%.2f&quot;).toDouble&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;def printRect2(m: Int, n: Int): Unit = {&lt;br/&gt;for (i &amp;lt;- 0 until m) {&lt;br/&gt;for (j &amp;lt;- 0 until n) {&lt;br/&gt;printf(&quot;*&quot;)&lt;br/&gt;}&lt;br/&gt;println()&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;def area2(len: Double, width: Double): Double = {&lt;br/&gt;len * width.formatted(&quot;%.2f&quot;).toDouble&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs markdown&quot;&gt;&lt;span class=&quot;hljs-strong&quot;&gt;*****&lt;/span&gt;&lt;span class=&quot;hljs-emphasis&quot;&gt;***&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-strong&quot;&gt;*****&lt;/span&gt;&lt;span class=&quot;hljs-emphasis&quot;&gt;***&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-strong&quot;&gt;*****&lt;/span&gt;&lt;span class=&quot;hljs-emphasis&quot;&gt;***&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-strong&quot;&gt;*****&lt;/span&gt;&lt;span class=&quot;hljs-emphasis&quot;&gt;***&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-strong&quot;&gt;*****&lt;/span&gt;&lt;span class=&quot;hljs-emphasis&quot;&gt;***&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-strong&quot;&gt;*****&lt;/span&gt;&lt;span class=&quot;hljs-emphasis&quot;&gt;***&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-strong&quot;&gt;*****&lt;/span&gt;&lt;span class=&quot;hljs-emphasis&quot;&gt;***&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-strong&quot;&gt;*****&lt;/span&gt;&lt;span class=&quot;hljs-emphasis&quot;&gt;***&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-strong&quot;&gt;*****&lt;/span&gt;&lt;span class=&quot;hljs-emphasis&quot;&gt;***&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-strong&quot;&gt;*****&lt;/span&gt;&lt;span class=&quot;hljs-emphasis&quot;&gt;***&lt;/span&gt;&lt;br/&gt;面积=4.08&lt;br/&gt;&lt;span class=&quot;hljs-emphasis&quot;&gt;***&lt;/span&gt;*&lt;br/&gt;&lt;span class=&quot;hljs-emphasis&quot;&gt;***&lt;/span&gt;*&lt;br/&gt;&lt;span class=&quot;hljs-emphasis&quot;&gt;***&lt;/span&gt;*&lt;br/&gt;&lt;span class=&quot;hljs-emphasis&quot;&gt;***&lt;/span&gt;*&lt;br/&gt;&lt;span class=&quot;hljs-emphasis&quot;&gt;***&lt;/span&gt;*&lt;br/&gt;面积=4.08&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4~6题的示例代码原理同上1~3题，不在赘述！&lt;/p&gt;
&lt;h3 id=&quot;h63&quot;&gt;&lt;span&gt;&lt;strong&gt;6.3 类与对象应用实例&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/26/Aa9r6I.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;景区门票案例&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/26/Aa9sXt.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;小狗案列的示例代码如下：
&lt;pre readability=&quot;8&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;10&quot;&gt;package com.atguigu.chapter06.dogcase&lt;p&gt;/**&lt;br/&gt;* 小狗案例&lt;br/&gt;*&lt;br/&gt;* 编写一个Dog类，包含name(String)、age(Int)、weight(Double)属性。&lt;br/&gt;* 类中声明一个say方法，返回String类型，方法返回信息中包含所有属性值。&lt;br/&gt;* 在另一个DogCaseTest类中的main方法中，创建Dog对象，并访问say方法和所有属性，将调用结果打印输出。&lt;br/&gt;*/&lt;br/&gt;object DogCaseTest {&lt;br/&gt;def main(args: Array[String]): Unit = {&lt;br/&gt;val dog = new Dog&lt;br/&gt;dog.name = &quot;泰斯特&quot;&lt;br/&gt;dog.age = 2&lt;br/&gt;dog.weight = 50&lt;br/&gt;println(dog.say())&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;class Dog {&lt;br/&gt;var name = &quot;&quot;&lt;br/&gt;var age = 0&lt;br/&gt;var weight = 0.0&lt;/p&gt;&lt;p&gt;def say(): String = {&lt;br/&gt;&quot;小狗的信息是：name=&quot; + this.name + &quot;\tage=&quot; + this.age + &quot;\tweight=&quot; + this.weight&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs delphi&quot;&gt;小狗的信息是：&lt;span class=&quot;hljs-keyword&quot;&gt;name&lt;/span&gt;=泰斯特    age=&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;   weight=&lt;span class=&quot;hljs-number&quot;&gt;50.0&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;盒子案列、景区门票案例的示例代码原理同上小狗案例，不在赘述！&lt;/p&gt;
&lt;h3 id=&quot;h64&quot;&gt;&lt;span&gt;&lt;strong&gt;6.4 构造器&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h4 id=&quot;h641&quot;&gt;&lt;span&gt;&lt;strong&gt;6.4.1 看一个需求&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;  前面我们在创建 Person 的对象时，是先把一个对象创建好后，再给他的年龄和姓名属性赋值，如果现在我要求，在创建人类的对象时，就直接指定这个对象的年龄和姓名，该怎么做? 这时就可以使用构造方法/构造器。&lt;/p&gt;
&lt;h4 id=&quot;h642java&quot;&gt;&lt;span&gt;&lt;strong&gt;6.4.2 回顾-Java 构造器的介绍+基本语法+特点+案例&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Java 构造器的介绍&lt;/strong&gt;&lt;br/&gt;  构造器(constructor)又叫构造方法，是类的一种特殊的方法，它的主要作用是&lt;code&gt;完成对新对象的初始化&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Java 构造器的基本语法&lt;/strong&gt;&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/26/Aa951s.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;&lt;strong&gt;Java 构造器的特点&lt;/strong&gt;&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/26/Aa9c0f.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;&lt;strong&gt;Java 构造器的案例&lt;/strong&gt;&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/26/Aa9RAS.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h643scala&quot;&gt;&lt;span&gt;&lt;strong&gt;6.4.3 Scala 构造器的介绍+基本语法+快速入门&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Scala 构造器的介绍&lt;/strong&gt;&lt;br/&gt;  和 Java 一样，Scala 构造对象也需要调用构造方法，并且可以有任意多个构造方法（即 scala 中构造器也支持重载）。&lt;br/&gt;  Scala 类的构造器包括： &lt;code&gt;主构造器&lt;/code&gt; 和 &lt;code&gt;辅助构造器&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Scala 构造器的基本语法&lt;/strong&gt;&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/26/Aa9g78.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;&lt;strong&gt;Scala 构造器的快速入门&lt;/strong&gt;&lt;br/&gt;示例代码如下：&lt;/p&gt;
&lt;pre readability=&quot;8.5&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;11&quot;&gt;package com.atguigu.chapter06.constructor&lt;p&gt;/**&lt;br/&gt;* Scala构造器的快速入门：创建Person对象的同时初始化对象的age属性值和name属性值&lt;br/&gt;*/&lt;br/&gt;object ConstructorDemo01 {&lt;br/&gt;def main(args: Array[String]): Unit = {&lt;br/&gt;val p1 = new Person(&quot;bruce&quot;, 20)&lt;br/&gt;println(p1)&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;class Person(inName: String, inAge: Int) {&lt;br/&gt;var name: String = inName&lt;br/&gt;var age: Int = inAge&lt;/p&gt;&lt;p&gt;// 重写toString方法&lt;br/&gt;override def toString: String = {&lt;br/&gt;&quot;name=&quot; + this.name + &quot;\tage=&quot; + this.age&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs ini&quot;&gt;&lt;span class=&quot;hljs-attr&quot;&gt;name&lt;/span&gt;=bruce    age=&lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;h644scala&quot;&gt;&lt;span&gt;&lt;strong&gt;6.4.4 Scala 构造器注意事项和细节&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;  1、Scala 构造器作用是完成对新对象的初始化，构造器没有返回值。&lt;br/&gt;  2、主构造器的声明直接放置于类名之后。【可以反编译查看】&lt;br/&gt;  3、主构造器会执行类定义中的所有语句(除掉函数部分)，这里可以体会到 Scala 的函数式编程和面向对象编程融合在一起，即：&lt;code&gt;构造器也是方法（函数）&lt;/code&gt;，传递参数和使用方法和前面的函数部分内容没有区别。【案例演示+反编译查看-语法糖】&lt;br/&gt;  4、如果主构造器无参数，小括号可省略，构建对象时调用的构造方法的小括号也可以省略。&lt;br/&gt;  5、辅助构造器名称为 this（这个和 Java 是不一样的），多个辅助构造器通过不同参数列表进行区分， 在底层就是f构造器重载。【案例演示+反编译查看】&lt;br/&gt;示例代码如下：&lt;/p&gt;
&lt;pre readability=&quot;8&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;10&quot;&gt;package com.atguigu.chapter06.constructor&lt;p&gt;object ConstructorDemo02 {&lt;br/&gt;def main(args: Array[String]): Unit = {&lt;br/&gt;// val a = new A&lt;br/&gt;val aa = new A(&quot;jack&quot;)&lt;br/&gt;// 执行顺序：&lt;br/&gt;// 1、bbb  父类构造器&lt;br/&gt;// 2、A    子类主构造器&lt;br/&gt;// 3、aaa  子类辅助构造器&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;class B {&lt;br/&gt;println(&quot;bbb&quot;)&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;class A extends B {&lt;br/&gt;println(&quot;A&quot;)&lt;br/&gt;def this(name: String) {&lt;br/&gt;this // 调用A的主构造器，其根本原因就是实现子类与父类之间的继承关系，不然继承关系就断了！！！&lt;br/&gt;println(&quot;aaa&quot;)&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs nginx&quot;&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;bbb&lt;/span&gt;&lt;br/&gt;A&lt;br/&gt;aaa&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;示例代码如下：&lt;/p&gt;
&lt;pre readability=&quot;13&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;20&quot;&gt;package com.atguigu.chapter06.constructor&lt;p&gt;object ConstructorDemo03 {&lt;br/&gt;def main(args: Array[String]): Unit = {&lt;br/&gt;val p1 = new Person(&quot;scott&quot;)&lt;br/&gt;p1.showInfo()&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;class Person() {&lt;br/&gt;var name: String = _&lt;br/&gt;var age: Int = _&lt;/p&gt;&lt;p&gt;def this(name: String) {&lt;br/&gt;// 辅助构造器无论是直接或间接，最终都一定要调用主构造器，执行主构造器的逻辑&lt;br/&gt;// 而且需要放在辅助构造器的第一行[这点和 java 一样，java 中一个构造器要调用同类的其它构造器，也需要放在第一行]&lt;br/&gt;this() // 直接调用主构造器&lt;br/&gt;this.name = name&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;def this(name: String, age: Int) {&lt;br/&gt;this() // 直接调用主构造器&lt;br/&gt;this.name = name&lt;br/&gt;this.age = age&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;def this(age: Int) {&lt;br/&gt;this(&quot;匿名&quot;) // 间接调用主构造器，因为 def this(name: String) 中直接调用了主构造器&lt;br/&gt;this.age = age&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;def showInfo(): Unit = {&lt;br/&gt;println(&quot;person信息如下:&quot;)&lt;br/&gt;println(&quot;name=&quot; + this.name)&lt;br/&gt;println(&quot;age=&quot; + this.age)&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs makefile&quot;&gt;&lt;span class=&quot;hljs-section&quot;&gt;person信息如下:&lt;/span&gt;&lt;br/&gt;name=scott&lt;br/&gt;age=0&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  6、如果想让主构造器变成私有的，可以在()之前加上 private，这样用户只能通过辅助构造器来构造对象了。【反编译查看】&lt;br/&gt;  7、辅助构造器的声明不能和主构造器的声明(即形参列表)一致，会发生错误(即构造器名重复)。&lt;/p&gt;
&lt;h3 id=&quot;h65&quot;&gt;&lt;span&gt;&lt;strong&gt;6.5 属性高级&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;  前面我们讲过属性了，这里我们再对属性的内容做一个加强。&lt;/p&gt;
&lt;h4 id=&quot;h651&quot;&gt;&lt;span&gt;&lt;strong&gt;6.5.1 构造器参数&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/26/Aa9fhQ.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;示例代码如下：
&lt;pre readability=&quot;10.5&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;15&quot;&gt;package com.atguigu.chapter06.constructor&lt;p&gt;object ConstructorDemo04 {&lt;br/&gt;def main(args: Array[String]): Unit = {&lt;br/&gt;val worker1 = new Worker1(&quot;smith1&quot;)&lt;br/&gt;worker1.name    // 不能访问 inName&lt;/p&gt;&lt;p&gt;val worker2 = new Worker2(&quot;smith2&quot;)&lt;br/&gt;worker2.inName  // 可以访问 inName&lt;br/&gt;println(&quot;hello!&quot;)&lt;/p&gt;&lt;p&gt;val worker3 = new Worker3(&quot;jack&quot;)&lt;br/&gt;worker3.inName = &quot;mary&quot;&lt;br/&gt;println(worker3.inName)&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;// 1. 如果 主构造器是 Worker1(inName: String)，那么 inName 就是一个局部变量。&lt;br/&gt;class Worker1(inName: String) {&lt;br/&gt;var name = inName&lt;br/&gt;}&lt;br/&gt;// 2. 如果 主构造器是 Worker2(val inName: String)，那么 inName 就是 Worker2 的一个 private 的只读属性。&lt;br/&gt;class Worker2(val inName: String) {&lt;br/&gt;var name = inName&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;// 3. 如果 主构造器是 Worker3(var inName: String)，那么 inName 就是 Worker3 的一个 private 的可以读写属性。&lt;br/&gt;class Worker3(var inName: String) {&lt;br/&gt;var name = inName&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;h652bean&quot;&gt;&lt;span&gt;&lt;strong&gt;6.5.2 Bean 属性&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/26/Aa9Wtg.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;示例代码如下：
&lt;pre readability=&quot;8&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;10&quot;&gt;package com.atguigu.chapter06.constructor&lt;p&gt;import scala.beans.BeanProperty&lt;/p&gt;&lt;p&gt;object BeanPropertDemo {&lt;br/&gt;def main(args: Array[String]): Unit = {&lt;br/&gt;val car = new Car&lt;br/&gt;car.name = &quot;宝马&quot;&lt;br/&gt;println(car.name)&lt;/p&gt;&lt;p&gt;// 使用 @BeanProperty 自动生成 getXxx() 和 setXxx()&lt;br/&gt;car.setName(&quot;奔驰&quot;)&lt;br/&gt;println(car.getName())&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;class Car {&lt;br/&gt;@BeanProperty var name: String = null&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h66scala&quot;&gt;&lt;span&gt;&lt;strong&gt;6.6 Scala 对象创建的流程分析&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/26/Aa94pj.png&quot; alt=&quot;&quot;/&gt;&lt;h3 id=&quot;h6703&quot;&gt;&lt;span&gt;&lt;strong&gt;6.7 作业03&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;1、一个数字如果为正数，则它的 signum 为1.0，如果是负数，则 signum 为-1.0，如果为0，则 signum 为0.0。编写一个函数来计算这个值。&lt;br/&gt;示例代码如下：&lt;/p&gt;
&lt;pre readability=&quot;6.5&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;7&quot;&gt;package com.atguigu.chapter06.exercises&lt;p&gt;import scala.io.StdIn&lt;/p&gt;&lt;p&gt;/**&lt;br/&gt;* 1、一个数字如果为正数，则它的 signum 为1，如果是负数，则 signum 为-1，如果为0，则 signum 为0。编写一个函数来计算这个值。&lt;br/&gt;*/&lt;br/&gt;object Exercise01 {&lt;br/&gt;def main(args: Array[String]): Unit = {&lt;br/&gt;println(&quot;请输入一个数字：&quot;)&lt;br/&gt;val n = StdIn.readDouble()&lt;br/&gt;println(&quot;该数的 signum 为：&quot; + signum(n))&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;def signum(n: Double): Double = {&lt;br/&gt;if (n &amp;gt; 0) {&lt;br/&gt;1&lt;br/&gt;} else if (n &amp;lt; 0) {&lt;br/&gt;-1&lt;br/&gt;} else {&lt;br/&gt;0&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果如下：&lt;/p&gt;
&lt;pre readability=&quot;5&quot;&gt;
&lt;code class=&quot;hljs css&quot; readability=&quot;4&quot;&gt;请输入一个数字：&lt;br/&gt;0&lt;br/&gt;该数的 &lt;span class=&quot;hljs-selector-tag&quot;&gt;signum&lt;/span&gt; 为：0&lt;span class=&quot;hljs-selector-class&quot;&gt;.0&lt;/span&gt;&lt;p&gt;请输入一个数字：&lt;br/&gt;5&lt;br/&gt;该数的 &lt;span class=&quot;hljs-selector-tag&quot;&gt;signum&lt;/span&gt; 为：1&lt;span class=&quot;hljs-selector-class&quot;&gt;.0&lt;/span&gt;&lt;/p&gt;&lt;p&gt;请输入一个数字：&lt;br/&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;-3&lt;/span&gt;&lt;br/&gt;该数的 &lt;span class=&quot;hljs-selector-tag&quot;&gt;signum&lt;/span&gt; 为：&lt;span class=&quot;hljs-selector-tag&quot;&gt;-1&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.0&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、一个空的块表达式&lt;code&gt;{}&lt;/code&gt;的值是什么？类型是什么？&lt;br/&gt;示例代码如下：&lt;/p&gt;
&lt;pre readability=&quot;5&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;4&quot;&gt;package com.atguigu.chapter06.exercises&lt;p&gt;/**&lt;br/&gt;* 2、一个空的块表达式 {} 的值是什么？类型是什么？&lt;br/&gt;*/&lt;br/&gt;object Exercise02 {&lt;br/&gt;def main(args: Array[String]): Unit = {&lt;br/&gt;val t = {}&lt;br/&gt;println(&quot;t=&quot; + t) // t=()&lt;br/&gt;println(t.isInstanceOf[Unit]) // true&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3、针对下列 Java 循环编写一个 Scala 版本：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;; i&amp;gt;=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i–-) {&lt;br/&gt;System.out.println(i);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;示例代码如下：&lt;/p&gt;
&lt;pre readability=&quot;10.5&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;15&quot;&gt;package com.atguigu.chapter06.exercises&lt;p&gt;/**&lt;br/&gt;* 3、针对下列 Java 循环编写一个 Scala 版本：&lt;br/&gt;* for (int i=10; i&amp;gt;=0; i–-) {&lt;br/&gt;*   System.out.println(i);&lt;br/&gt;* }&lt;br/&gt;*/&lt;br/&gt;object Exercise03 {&lt;br/&gt;def main(args: Array[String]): Unit = {&lt;br/&gt;// 方式一：&lt;br/&gt;for (i &amp;lt;- 0 to 10) {&lt;br/&gt;println(&quot;i=&quot; + (10 - i))&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;println(&quot;----------&quot;)&lt;/p&gt;&lt;p&gt;// 方式二：&lt;br/&gt;for (i &amp;lt;- 0 to 10 reverse) { // 逆序&lt;br/&gt;println(&quot;i=&quot; + i)&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;// 定义一个 List 集合&lt;br/&gt;val list = List(1, 2, 3)&lt;br/&gt;println(list) // List(1, 2, 3)&lt;br/&gt;println(list.reverse) // List(3, 2, 1)&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4、编写一个过程 countdown(n:Int)，打印从 n 到 0 的数字。&lt;br/&gt;示例代码如下：&lt;/p&gt;
&lt;pre readability=&quot;16&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;26&quot;&gt;package com.atguigu.chapter06.exercises&lt;p&gt;import scala.io.StdIn&lt;/p&gt;&lt;p&gt;/**&lt;br/&gt;* 4、编写一个过程 countdown(n:Int)，打印从 n 到 0 的数字。&lt;br/&gt;*/&lt;br/&gt;object Exercise04 {&lt;br/&gt;def main(args: Array[String]): Unit = {&lt;/p&gt;&lt;p&gt;val m=3&lt;br/&gt;val res1 = (0 to m).reverse&lt;br/&gt;println(res1) // Range(3, 2, 1, 0)&lt;/p&gt;&lt;p&gt;// foreach&lt;br/&gt;// foreach 函数可以接收 (f: Int =&amp;gt; U)，即接收一个输入参数为 Int，输出参数为 Unit 的函数&lt;br/&gt;// 下面这句代码的含义是：&lt;br/&gt;// 1、将 res1 的每个元素依次遍历出来，传递给 println(x)&lt;br/&gt;// 调用系统的 println 函数&lt;br/&gt;res1.foreach(println)&lt;/p&gt;&lt;p&gt;// 调用自定义的 println 函数&lt;br/&gt;res1.foreach(myPrintln)&lt;/p&gt;&lt;p&gt;println(&quot;----------&quot;)&lt;br/&gt;println(&quot;请输入一个数字：&quot;)&lt;br/&gt;val n = StdIn.readInt()&lt;br/&gt;println(&quot;----------&quot;)&lt;br/&gt;countdown(n)&lt;br/&gt;println(&quot;----------&quot;)&lt;br/&gt;countdown2(n)&lt;br/&gt;println(&quot;----------&quot;)&lt;br/&gt;countdown3(n)&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;// 自定义一个 println 函数&lt;br/&gt;def myPrintln(n:Int):Unit = {&lt;br/&gt;println(n)&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;// 方式一：&lt;br/&gt;def countdown(n: Int): Unit = {&lt;br/&gt;for (i &amp;lt;- 0 to n) {&lt;br/&gt;println(n-i)&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;// 方式二：&lt;br/&gt;def countdown2(n: Int): Unit = {&lt;br/&gt;for (i &amp;lt;- 0 to n reverse) {&lt;br/&gt;println(i)&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;// 方式三：&lt;br/&gt;def countdown3(n: Int): Unit = {&lt;br/&gt;// 说明&lt;br/&gt;// 这里使用到高阶函数的特性&lt;br/&gt;(0 to n).reverse.foreach(println)&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;5、编写一个 for 循环，计算字符串中所有字母的 Unicode 代码（toLong 方法）的乘积。举例来说，&quot;Hello&quot; 中所有字符串的乘积为 9415087488L。&lt;br/&gt;示例代码如下：&lt;/p&gt;
&lt;pre readability=&quot;8.5&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;11&quot;&gt;package com.atguigu.chapter06.exercises&lt;p&gt;import scala.io.StdIn&lt;/p&gt;&lt;p&gt;/**&lt;br/&gt;* 5、编写一个 for 循环，计算字符串中所有字母的 Unicode 代码（toLong 方法）的乘积。举例来说，&quot;Hello&quot; 中所有字符串的乘积为 9415087488L。&lt;br/&gt;*/&lt;br/&gt;object Exercise05 {&lt;br/&gt;def main(args: Array[String]): Unit = {&lt;br/&gt;println(&quot;请输入一行字符串：&quot;)&lt;br/&gt;val str = StdIn.readLine()&lt;br/&gt;println(&quot;该字符串中所有字母的 Unicode 代码的乘积为：&quot; + unicode(str))&lt;/p&gt;&lt;p&gt;unicode2()&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;// 方式一：&lt;br/&gt;def unicode(str: String): Long = {&lt;br/&gt;var res:Long = 1&lt;br/&gt;for (i &amp;lt;- 0 to str.length - 1) { // 索引从0开始&lt;br/&gt;var s = str.charAt(i).toLong&lt;br/&gt;res *= s&lt;br/&gt;}&lt;br/&gt;res&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;// 方式二：&lt;br/&gt;def unicode2() = {&lt;br/&gt;var res:Long = 1&lt;br/&gt;for (i &amp;lt;- &quot;Hello&quot;) {&lt;br/&gt;res *= i.toLong&lt;br/&gt;}&lt;br/&gt;println(&quot;res=&quot; + res)&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs makefile&quot;&gt;请输入一行字符串：&lt;br/&gt;Hello&lt;br/&gt;该字符串中所有字母的 Unicode 代码的乘积为：9415087488&lt;br/&gt;res=9415087488&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;6、同样是解决前一个练习的问题，请用 StringOps 的 foreach 方式解决。&lt;br/&gt;示例代码如下：&lt;/p&gt;
&lt;pre readability=&quot;7&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;8&quot;&gt;package com.atguigu.chapter06.exercises&lt;p&gt;import scala.io.StdIn&lt;/p&gt;&lt;p&gt;/**&lt;br/&gt;* 6、同样是解决前一个练习的问题，请用 StringOps 的 foreach 方式解决。&lt;br/&gt;*/&lt;br/&gt;object Exercise06 {&lt;br/&gt;def main(args: Array[String]): Unit = {&lt;br/&gt;var res1: Long = 1&lt;br/&gt;// 说明&lt;br/&gt;// 方式一：&lt;br/&gt;// &quot;Hello&quot;.foreach((_) =&amp;gt; {res *= _.toLong})&lt;br/&gt;&quot;Hello&quot;.foreach(res1 *= _.toLong)&lt;br/&gt;println(&quot;res1=&quot; + res1)&lt;/p&gt;&lt;p&gt;// 方式二：&lt;br/&gt;var res2 = 1L&lt;br/&gt;&quot;Hello&quot;.foreach(myCount)&lt;br/&gt;println(&quot;res1=&quot; + res2)&lt;br/&gt;def myCount(char: Char): Unit = {&lt;br/&gt;res2 *= char.toLong&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs ini&quot;&gt;&lt;span class=&quot;hljs-attr&quot;&gt;res1&lt;/span&gt;=&lt;span class=&quot;hljs-number&quot;&gt;9415087488&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;res1&lt;/span&gt;=&lt;span class=&quot;hljs-number&quot;&gt;9415087488&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;7、编写一个函数 product(str: String)，计算字符串中所有字母的 Unicode 代码（toLong 方法）的乘积。&lt;br/&gt;示例代码如下：&lt;/p&gt;
&lt;pre readability=&quot;8.5&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;11&quot;&gt;package com.atguigu.chapter06.exercises&lt;p&gt;import scala.io.StdIn&lt;/p&gt;&lt;p&gt;/**&lt;br/&gt;* 7、编写一个函数 product(str: String)，计算字符串中所有字母的 Unicode 代码（toLong 方法）的乘积。&lt;br/&gt;*/&lt;br/&gt;object Exercise07 {&lt;br/&gt;def main(args: Array[String]): Unit = {&lt;br/&gt;println(&quot;请输入一行字符串：&quot;)&lt;br/&gt;val str = StdIn.readLine()&lt;br/&gt;println(&quot;该字符串中所有字母的 Unicode 代码的乘积为：&quot; + product1(str))&lt;br/&gt;println(&quot;该字符串中所有字母的 Unicode 代码的乘积为：&quot; + product2(str))&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;// 方式一：&lt;br/&gt;def product1(str: String): Long = {&lt;br/&gt;var multi = 1L&lt;br/&gt;for (i &amp;lt;- 0 to str.length - 1) { // 索引从0开始&lt;br/&gt;var s = str.charAt(i).toLong&lt;br/&gt;multi *= s&lt;br/&gt;}&lt;br/&gt;multi&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;// 方式二：&lt;br/&gt;def product2(str: String): Long = {&lt;br/&gt;var multi = 1L&lt;br/&gt;for (i &amp;lt;- str) {&lt;br/&gt;multi *= i.toLong&lt;br/&gt;}&lt;br/&gt;multi&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs vbnet&quot;&gt;请输入一行字符串：&lt;br/&gt;Hello&lt;br/&gt;该字符串中所有字母的 &lt;span class=&quot;hljs-keyword&quot;&gt;Unicode&lt;/span&gt; 代码的乘积为：&lt;span class=&quot;hljs-number&quot;&gt;9415087488&lt;/span&gt;&lt;br/&gt;该字符串中所有字母的 &lt;span class=&quot;hljs-keyword&quot;&gt;Unicode&lt;/span&gt; 代码的乘积为：&lt;span class=&quot;hljs-number&quot;&gt;9415087488&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;8、把7练习中的函数改成递归函数。&lt;br/&gt;示例代码如下：&lt;/p&gt;
&lt;pre readability=&quot;7.5&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;9&quot;&gt;package com.atguigu.chapter06.exercises&lt;p&gt;/**&lt;br/&gt;* 8、把7练习中的函数改成递归函数。&lt;br/&gt;*/&lt;br/&gt;object Exercise08 {&lt;br/&gt;def main(args: Array[String]): Unit = {&lt;br/&gt;println(&quot;res=&quot; + product(&quot;Hello&quot;)) // res=9415087488&lt;/p&gt;&lt;p&gt;println(&quot;Hello&quot;.take(1)) // H     获取的是该字符串的第一个字符串&lt;br/&gt;println(&quot;Hello&quot;.drop(1)) // ello  获取的是该字符串的除第一个字符串之外的剩余字符串&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;def product(str: String): Long = {&lt;br/&gt;if (str.length == 1) return str.charAt(0).toLong&lt;br/&gt;else str.take(1).charAt(0).toLong * product(str.drop(1))&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs makefile&quot;&gt;res=9415087488&lt;br/&gt;H&lt;br/&gt;ello&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;9、编写函数计算，其中 n 是整数，使用如下的递归定义：&lt;/strong&gt;&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/26/Aa9oXq.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;示例代码如下：
&lt;pre readability=&quot;8&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;10&quot;&gt;package com.atguigu.chapter06.exercises&lt;p&gt;/**&lt;br/&gt;* 9、编写函数计算，其中 n 是整数，使用如下的递归定义：&lt;br/&gt;*/&lt;br/&gt;object Exercise09 {&lt;br/&gt;def main(args: Array[String]): Unit = {&lt;br/&gt;println(mi(2.5, 3))&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;// 递归的妙用：求 x 的 n 次方，厉害啊！！！&lt;br/&gt;def mi(x: Double, n: Int): Double = {&lt;br/&gt;if (n == 0) 1   // x 的 0 次方等于 1&lt;br/&gt;else if (n &amp;gt; 0) x * mi(x, n - 1)&lt;br/&gt;else 1 / mi(x, -n)&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意：本题可以用于好好理解“递归”的妙用！！！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Java 与 Scala 在函数层面上的不同体现：&lt;br/&gt;// 在 Java 中&lt;br/&gt;函数(接收参数)&lt;/p&gt;
&lt;p&gt;// 在 Scala 中&lt;br/&gt;集合.函数(函数)&lt;/p&gt;
&lt;p&gt;如下图所示：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/26/Aa9Icn.png&quot; alt=&quot;&quot;/&gt;</description>
<pubDate>Tue, 26 Mar 2019 15:58:00 +0000</pubDate>
<dc:creator>黑泽君</dc:creator>
<og:description>第五章 函数式编程-基础5.1 函数式编程内容说明5.1.1 函数式编程内容5.1.2 函数式编程授课顺序5.2 函数式编程介绍5.2.1 几个概念的说明5.2.2 方法、函数、函数式编程和面向对象编</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenmingjun/p/10604813.html</dc:identifier>
</item>
<item>
<title>脚本精灵---英文+所有字符 输入脚本 - 我辈年轻</title>
<link>http://www.cnblogs.com/wobeinianqing/p/10604773.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wobeinianqing/p/10604773.html</guid>
<description>&lt;p&gt;之前发过一个 但是脚本丢了 ，正好有个粉丝需要 就花了点时间 搞了一下。&lt;/p&gt;&lt;p&gt;之前的写法完全忘记了 o(╥﹏╥)o 只好重新开始 ，不过应该是优化了写法（印象中之前用的是个笨方法）&lt;/p&gt;&lt;p&gt;这次用上了ASCII码 并对特殊符号进行了分析。不多说 代码很易读。&lt;/p&gt;&lt;p&gt;(不知道这是 lua 还是 vb 所以我就随便传了 下 大家将就看 复制到 脚本精灵就好了)&lt;/p&gt;&lt;div readability=&quot;148&quot;&gt;
&lt;pre class=&quot;brush:vbnet;gutter:true;&quot;&gt;
//读取txt
word = Plugin.File.ReadFileEx(&quot;D:\007\1.txt&quot;)
//TracePrint word
mydelay = 20
//等待2s 将鼠标放到定义位置
Delay 2000
TracePrint Asc(&quot;`&quot;)
TracePrint Asc(&quot;'&quot;)

For i = 0 To len(word)
        //大写字母
        If (Asc(Mid(word, i, 1))&amp;gt;=65 And Asc(Mid(word, i, 1)) &amp;lt;= 90)   Then
                input_ua(Mid(word, i, 1))
        //小写字母
        ElseIf (Asc(Mid(word, i, 1)) &amp;gt;= 97 And Asc(Mid(word, i, 1)) &amp;lt;= 122) Or (Asc(Mid(word, i, 1)) &amp;gt;= 44 And Asc(Mid(word, i, 1)) &amp;lt;= 57) Or (Asc(Mid(word, i, 1)) = 39) Or (Asc(Mid(word, i, 1)) = 59) Or (Asc(Mid(word, i, 1)) = 61) Or (Asc(Mid(word, i, 1)) = 96) Or (Asc(Mid(word, i, 1)) &amp;gt;= 91 And Asc(Mid(word, i, 1)) &amp;lt;= 93) Then
        input_sa(Mid(word, i, 1))
    Else 
        symbols(Asc(Mid(word, i, 1)))
    End If
Next

Function symbols(num)
        If num = 32 Then
                KeyDown &quot;Space&quot;, 1
                Delay mydelay
                KeyUp &quot;Space&quot;, 1
        ElseIf num = 33 Then
                KeyDown &quot;Shift&quot;, 1
                KeyDown &quot;1&quot;, 1
                Delay mydelay
                KeyUp &quot;Shift&quot;, 1
                Delay mydelay
                KeyUp &quot;1&quot;, 1
        ElseIf num = 34 Then
                KeyDown &quot;Shift&quot;, 1
                KeyDown &quot;'&quot;, 1
                Delay mydelay
                KeyUp &quot;Shift&quot;, 1
                Delay mydelay
                KeyUp &quot;'&quot;, 1
        ElseIf num = 35 Then
                KeyDown &quot;Shift&quot;, 1
                KeyDown &quot;3&quot;, 1
                Delay mydelay
                KeyUp &quot;Shift&quot;, 1
                Delay mydelay
                KeyUp &quot;3&quot;, 1
        ElseIf num = 36 Then
                KeyDown &quot;Shift&quot;, 1
                KeyDown &quot;4&quot;, 1
                Delay mydelay
                KeyUp &quot;Shift&quot;, 1
                Delay mydelay
                KeyUp &quot;4&quot;, 1
        ElseIf num = 37 Then
                KeyDown &quot;Shift&quot;, 1
                KeyDown &quot;5&quot;, 1
                Delay mydelay
                KeyUp &quot;Shift&quot;, 1
                Delay mydelay
                KeyUp &quot;5&quot;, 1
        ElseIf num = 38 Then
                KeyDown &quot;Shift&quot;, 1
                KeyDown &quot;7&quot;, 1
                Delay mydelay
                KeyUp &quot;Shift&quot;, 1
                Delay mydelay
                KeyUp &quot;7&quot;, 1
        ElseIf num = 40 Then
                KeyDown &quot;Shift&quot;, 1
                KeyDown &quot;9&quot;, 1
                Delay mydelay
                KeyUp &quot;Shift&quot;, 1
                Delay mydelay
                KeyUp &quot;9&quot;, 1
        ElseIf num = 41 Then
                KeyDown &quot;Shift&quot;, 1
                KeyDown &quot;0&quot;, 1
                Delay mydelay
                KeyUp &quot;Shift&quot;, 1
                Delay mydelay
                KeyUp &quot;0&quot;, 1
        ElseIf num = 42 Then
                KeyDown &quot;Shift&quot;, 1
                KeyDown &quot;8&quot;, 1
                Delay mydelay
                KeyUp &quot;Shift&quot;, 1
                Delay mydelay
                KeyUp &quot;8&quot;, 1    
        ElseIf num = 43 Then
                KeyDown &quot;Shift&quot;, 1
                KeyDown &quot;=&quot;, 1
                Delay mydelay
                KeyUp &quot;Shift&quot;, 1
                Delay mydelay
                KeyUp &quot;=&quot;, 1            
        ElseIf num = 58 Then
                KeyDown &quot;Shift&quot;, 1
                KeyDown &quot;;&quot;, 1
                Delay mydelay
                KeyUp &quot;Shift&quot;, 1
                Delay mydelay
                KeyUp &quot;;&quot;, 1            
        ElseIf num = 60 Then
                KeyDown &quot;Shift&quot;, 1
                KeyDown &quot;,&quot;, 1
                Delay mydelay
                KeyUp &quot;Shift&quot;, 1
                Delay mydelay
                KeyUp &quot;,&quot;, 1            
        ElseIf num = 62 Then
                KeyDown &quot;Shift&quot;, 1
                KeyDown &quot;.&quot;, 1
                Delay mydelay
                KeyUp &quot;Shift&quot;, 1
                Delay mydelay
                KeyUp &quot;.&quot;, 1            
        ElseIf num = 63 Then
                KeyDown &quot;Shift&quot;, 1
                KeyDown &quot;/&quot;, 1
                Delay mydelay
                KeyUp &quot;Shift&quot;, 1
                Delay mydelay
                KeyUp &quot;/&quot;, 1            
        ElseIf num = 64 Then
                KeyDown &quot;Shift&quot;, 1
                KeyDown &quot;2&quot;, 1
                Delay mydelay
                KeyUp &quot;Shift&quot;, 1
                Delay mydelay
                KeyUp &quot;2&quot;, 1            
        ElseIf num = 94 Then
                KeyDown &quot;Shift&quot;, 1
                KeyDown &quot;6&quot;, 1
                Delay mydelay
                KeyUp &quot;Shift&quot;, 1
                Delay mydelay
                KeyUp &quot;6&quot;, 1            
        ElseIf num = 95 Then
                KeyDown &quot;Shift&quot;, 1
                KeyDown &quot;-&quot;, 1
                Delay mydelay
                KeyUp &quot;Shift&quot;, 1
                Delay mydelay
                KeyUp &quot;-&quot;, 1    
        ElseIf num = 126 Then
                KeyDown &quot;Shift&quot;, 1
                KeyDown &quot;`&quot;, 1
                Delay mydelay
                KeyUp &quot;Shift&quot;, 1
                Delay mydelay
                KeyUp &quot;`&quot;, 1
        End If
End Function
//小写输入
Function input_sa(str)
    KeyDown str, 1
        Delay mydelay
        KeyUp str, 1
End Function
//大写输入
Function input_ua(str)
        KeyDown &quot;Shift&quot;, 1
        KeyDown str, 1
        Delay mydelay
        KeyUp &quot;Shift&quot;, 1
        Delay mydelay
        KeyUp str, 1
End Function


//定义一个函数,可以在脚本中调用这个函数，支持参数和返回值
//返回值 = Lib.算法.中文汉字转拼音
&lt;/pre&gt;&lt;/div&gt;</description>
<pubDate>Tue, 26 Mar 2019 15:47:00 +0000</pubDate>
<dc:creator>我辈年轻</dc:creator>
<og:description>脚本蓝奏下载地址 之前发过一个 但是脚本丢了 ，正好有个粉丝需要 就花了点时间 搞了一下。 之前的写法完全忘记了 o(╥﹏╥)o 只好重新开始 ，不过应该是优化了写法（印象中之前用的是个笨方法） 这次</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wobeinianqing/p/10604773.html</dc:identifier>
</item>
<item>
<title>springboot之旅第一篇-springboot初探 - 茶底世界</title>
<link>http://www.cnblogs.com/yuanqinnan/p/10604761.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuanqinnan/p/10604761.html</guid>
<description>&lt;h2&gt;一、&lt;span class=&quot;md-expand&quot;&gt;springboot是什么？&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;微服务，应该是近年来最火的概念，越来越多的公司开始使用微服务架构，面试中被问到的微服务的概率很高，不管对技术的追求，还是为了进更好的公司，微服务都是我们开发人员的必须要学习的知识。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;那么微服务究竟是什么呢？&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;我们通俗的理解方式就是：微服务化的核心就是将传统的一站式应用，根据业务拆分成一个一个的服务，彻底 &lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;地去耦合,每一个微服务提供单个业务功能的服务，一个服务做一件事，从技术角度看就是一种小而独立的处理过程，类似进程概念，能够自行单独启动或销毁，拥有自己独立的数据库。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;想要更好的了解微服务概念的同学可以去看看这篇论文：&lt;span class=&quot;md-link&quot;&gt;&lt;a href=&quot;https://martinfowler.com/articles/microservices.html&quot;&gt;https://martinfowler.com/articles/microservices.html&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;dubbo和springcloud&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;目前比较成熟的微服务架构有两种：dubbo和springcloud，这两种技术各有优劣，他们最大的区别是：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;SpringCloud抛弃了Dubbo的RPC通信，采用的是基于HTTP的REST方式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;为何会选择springcloud，主要是从两个方面考虑：&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;ol-list&quot; start=&quot;&quot; readability=&quot;0.5&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;spring全家桶：作为Spring的拳头项目，springcloud能够与Spring Framework、Spring Boot、Spring Data、Spring Batch等其他Spring项目完美融合，而且springcloud有一整套的微服务架构解决方案，你可以很放心的使用，大家都爱全家桶。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;社区支持与更新力度：DUBBO停止了5年左右的更新，虽然2017.7重启了，但是影响还是有一些的。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;当然，这只是一种技术选择，不需要去争论。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;讲了这么多，还没有说到主题，那springboot又是什么？&lt;span&gt;&lt;strong&gt;SpringBoot专注于快速方便的开发单个个体微服务&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;SpringBoot可以离开SpringCloud独立使用开发项目，但是SpringCloud离不开SpringBoot，属于依赖的关系.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;SpringBoot专注于快速、方便的开发单个微服务个体，SpringCloud关注全局的服务治理框架。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;要学习springcloud，就必须先学习springboot&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;二、&lt;/span&gt;&lt;span class=&quot;md-expand&quot;&gt;springboot的优势&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Spring Boot是来简化Spring应用开发，约定大于配置，去繁从简，just run就能创建一个独立的，产品级别的应用，多数Spring Boot应用需要很少的Spring配置。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;用过spring开发就知道，spring配置繁多、开发效率低下、部署流程复杂、且第三方技术集成难度大。而使用springboot有如下优势：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;快速创建独立运行的Spring项目以及与主流框架集成 &lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;– 使用嵌入式的Servlet容器，应用无需打成WAR包 &lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;– starters自动依赖与版本控制 &lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;– 大量的自动配置，简化开发，也可修改默认值 &lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;– 无需配置XML，无代码生成，开箱即用 &lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;– 准生产环境的运行时应用监控 &lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;– 与云计算的天然集成&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;学习spring是有一定前提的，spring，maven都必须先掌握&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;三、&lt;/span&gt;&lt;span class=&quot;md-expand&quot;&gt;hello world&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;相信大部分开发现在都是使用idea，关于idea的maven配置就不讲了，我们开始第一个springboot项目&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;新建项目：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201903/1113901-20190326232557076-1355704040.png&quot; alt=&quot;&quot; width=&quot;714&quot; height=&quot;658&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;下一步：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201903/1113901-20190326232629422-1284820733.png&quot; alt=&quot;&quot; width=&quot;716&quot; height=&quot;677&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下一步：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201903/1113901-20190326232715756-1384793330.png&quot; alt=&quot;&quot; width=&quot;570&quot; height=&quot;522&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下一步：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201903/1113901-20190326232835800-580500644.png&quot; alt=&quot;&quot; width=&quot;702&quot; height=&quot;498&quot;/&gt;&lt;/p&gt;
&lt;p&gt;只勾选web,这里我们就构建成功了，再删除一些不必要的文件，最终结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201903/1113901-20190326232958114-1410451435.png&quot; alt=&quot;&quot; width=&quot;647&quot; height=&quot;725&quot;/&gt;&lt;/p&gt;
&lt;p&gt;新建一个controller：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201903/1113901-20190326233044364-1454924052.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Controller
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HelloController {

    @ResponseBody
    @RequestMapping(&lt;/span&gt;&quot;/hello&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String hello(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;hello world&quot;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;启动项目：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201903/1113901-20190326233158276-437644756.png&quot; alt=&quot;&quot; width=&quot;787&quot; height=&quot;137&quot;/&gt;&lt;/p&gt;
&lt;p&gt;成功后，&lt;span class=&quot;md-expand&quot;&gt;浏览器中输入：&lt;span class=&quot;md-link md-expand&quot;&gt;&lt;a href=&quot;http://localhost:8080/hello&quot;&gt;http://localhost:8080/hello&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201903/1113901-20190326233232061-189378150.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;结果就出来了，简直太方便了，springboot不仅开发简单，部署也非常容易,直接打包&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201903/1113901-20190326233303981-1212150917.png&quot; alt=&quot;&quot; width=&quot;581&quot; height=&quot;568&quot;/&gt;&lt;/p&gt;
&lt;p&gt;打包后的文件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201903/1113901-20190326233346638-412397241.png&quot; alt=&quot;&quot; width=&quot;691&quot; height=&quot;279&quot;/&gt;&lt;/p&gt;
&lt;p&gt;复制到桌面，然后直接执行命令 java -jar&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201903/1113901-20190326233441358-601006782.png&quot; alt=&quot;&quot; width=&quot;731&quot; height=&quot;290&quot;/&gt;&lt;/p&gt;
&lt;p&gt;刷新刚刚的地址，成功显示，就已经部署完成。&lt;/p&gt;
&lt;h2&gt;四、&lt;span class=&quot;md-expand&quot;&gt;原理探究&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;我们先简单的探究下其中的原理，首先我们看pom包&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;parent&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-parent&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2.1.3.RELEASE&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;relativePath&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt; &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; lookup parent from repository &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;parent&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;进入依赖，发现他还有一个父依赖&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;parent&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-dependencies&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2.1.3.RELEASE&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;relativePath&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;../../spring-boot-dependencies&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;relativePath&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;parent&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在父依赖中我们可以看到里面对组件的版本号进行了写入：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201903/1113901-20190326233658363-2012396482.png&quot; alt=&quot;&quot; width=&quot;759&quot; height=&quot;658&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;我们默认是不需要写版本的，当然，没有在里面的依赖需要我们定义，这就是springboot的版本仲裁中心&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;再看另外的一个依赖：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-web&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个依赖可以分为两个部分：spring-boot-starter说明这个是spring-boot场景启动器，而后面的web会帮我们导入了web模块正常运行所依赖的组件，如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201903/1113901-20190326233802156-531609033.png&quot; alt=&quot;&quot; width=&quot;576&quot; height=&quot;674&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Spring Boot将所有的功能场景都抽取出来，做成一个个的starters（启动器），只需要在项目里面引入这些starter相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器。&lt;/p&gt;
&lt;p&gt;我们在看看主程序类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
@SpringBootApplication &lt;span&gt;//&lt;/span&gt;&lt;span&gt;来标注一个主程序类，说明这是一个Spring Boot应用&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SpringbootLearnApplication {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        SpringApplication.run(SpringbootLearnApplication.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, args);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;@&lt;span&gt;&lt;strong&gt;SpringBootApplication&lt;/strong&gt;&lt;span&gt;: Spring Boot应用标注在某个类上说明这个类是SpringBoot的主配置类，SpringBoot就应该运行这个类的main方法来启动SpringBoot应用，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;进入其中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan(excludeFilters &lt;/span&gt;=&lt;span&gt; {
      @Filter(type &lt;/span&gt;= FilterType.CUSTOM, classes = TypeExcludeFilter.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;),
      @Filter(type &lt;/span&gt;= FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;) })
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt; SpringBootApplication {
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;这里面有个@&lt;span&gt;&lt;strong&gt;SpringBootConfiguration&lt;/strong&gt;&lt;span&gt;: 翻译过来是Spring Boot的配置类，标注在某个类上，就表示这是一个Spring Boot的配置类；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;我们再进入其中，又可以看到一个注解@&lt;span&gt;&lt;strong&gt;Configuration&lt;/strong&gt;&lt;span&gt;: 翻译过来是配置类，上面标注这个注解说明这是一个配置类，相当于一个配置文件，配置类也是容器中的一个组件相当于@Component。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;还有一个@&lt;span&gt;&lt;strong&gt;EnableAutoConfiguration&lt;/strong&gt; &lt;span&gt;这个注解说明开启自动配置功能。这就是为什么我们不需要写任何配置，就可以起项目的原因，以前我们需要配置的东西，Spring Boot帮我们自动配置；@&lt;span&gt;&lt;strong&gt;EnableAutoConfiguration&lt;/strong&gt;&lt;span&gt;告诉SpringBoot开启自动配置功能；这样自动配置才能生效。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;我们不妨再进入到这个注解中：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@AutoConfigurationPackage
@Import({AutoConfigurationImportSelector.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;})
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt; EnableAutoConfiguration {
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;这里面@&lt;span&gt;&lt;strong&gt;&lt;span&gt;AutoConfigurationPackage&lt;/span&gt;&lt;/strong&gt; &lt;span&gt;，翻译过来就是自动配置包，我们再到里面去看看，又有一个注解&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
@Import({Registrar.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;})
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; AutoConfigurationPackage {
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;这个注解我们就比较熟悉了，@&lt;span&gt;&lt;strong&gt;Import&lt;/strong&gt; &lt;span&gt;这个注解是给容器中导入一个组件；导入的组件由Registrar.class，这个 &lt;span class=&quot;md-tab&quot;&gt;&lt;span&gt;Registrar.class中的方法的就是将所在包及下面所有子包里面的所有组件扫描到Spring容器。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;这个要注意必须是其&lt;strong&gt;子包&lt;/strong&gt;，如果我们放在外面将不能被扫描，用个例子说明，假设我们在java路径下增加一个类，&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201903/1113901-20190326234124916-1356067869.png&quot; alt=&quot;&quot; width=&quot;665&quot; height=&quot;240&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Controller
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HelloWorld {
    @ResponseBody
    @RequestMapping(&lt;/span&gt;&quot;/world&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String world(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;hello world&quot;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 再次启动，是找不到这个地址的，因为这个包没有扫入其中，这样我们就明白了包是怎么扫描进去的。&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;下面我们再到@&lt;span&gt;&lt;strong&gt;EnableAutoConfiguration&lt;/strong&gt; &lt;span&gt;找到@Import({AutoConfigurationImportSelector.class})，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;strong&gt;EnableAutoConfigurationImportSelector&lt;/strong&gt; &lt;span&gt;翻译过来是导入哪些组件的选择器，这个类的作用是：将所有需要导入的组件以全类名的方式返回，这些组件就会被添加到容器中。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; String[] selectImports(AnnotationMetadata annotationMetadata) {
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;这个方法会给容器中导入非常多的自动配置类（xxxAutoConfiguration），就是给容器中导入这个场景需要的所有组件，并配置好这些组件。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;这样我们就知道自动配置类是如何导入的，有了自动配置类，免去了我们手动编写配置注入功能组件等的工作。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201903/1113901-20190326234252930-456237894.png&quot; alt=&quot;&quot; width=&quot;674&quot; height=&quot;213&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;去看这个文件，发现里面有大量的注解配置类：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201903/1113901-20190326234319464-698360990.png&quot; alt=&quot;&quot; width=&quot;732&quot; height=&quot;420&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Spring Boot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作；==以前我们需要自己配置的东西，自动配置类都帮我们。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;这样我们就对springboot的原理有个大致的了解，最重要的是springboot将我们之前要做的很多事情都做好了。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 26 Mar 2019 15:45:00 +0000</pubDate>
<dc:creator>茶底世界</dc:creator>
<og:description>一、springboot是什么？ 微服务，应该是近年来最火的概念，越来越多的公司开始使用微服务架构，面试中被问到的微服务的概率很高，不管对技术的追求，还是为了进更好的公司，微服务都是我们开发人员的必须</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuanqinnan/p/10604761.html</dc:identifier>
</item>
<item>
<title>js数组乱序输出 数组乱序排列 - 怒其不争1</title>
<link>http://www.cnblogs.com/Mir-bink/p/10604747.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Mir-bink/p/10604747.html</guid>
<description>&lt;p&gt;&lt;span&gt;网上看的数组乱序输出，要么不合实际，要么代码繁琐。自己试了下，希望能给大家带来帮助。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;重要思想也是Math.random*arr.length随机下标，然后删除取到的元素，继续随机下标。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将数组乱序输出&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; arr = [1,2,3,4,5,6,7,8,9,10&lt;span&gt;];
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; newArr =&lt;span&gt; [];
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0; i&amp;lt;arr.length; i++&lt;span&gt;){
                 &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; index = Math.floor(Math.random()*arr.length);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;随机下标&lt;/span&gt;
                     newArr.push(arr[index]);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将随机出的元素，存放新数组newArr中去&lt;/span&gt;
                     arr.splice(index,1);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    将随机出的元素在arr中删除            &lt;/span&gt;
&lt;span&gt;            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;arr中删除随机出的元素,arr.length-1,同时i++,导致循环不会10次,会是5次.最后得到newArr中只有一半的随机数字,arr中剩下另一半. 将其合并到一起,得到res&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; res =&lt;span&gt;[...newArr,...arr];
            console.log(res)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;结果如下：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1581103/201903/1581103-20190326232504975-238289851.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;随后也有个问题，这个其实只随机了一半的数字，后一半没有随机，只是合并了上去。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;改进后：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; arr = [1,2,3,4,5,6,7,8,9,10&lt;span&gt;];
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; newArr =&lt;span&gt; [];
        var len &lt;/span&gt;=&lt;span&gt; arr.length;
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0; i&amp;lt;len; i++&lt;span&gt;){
                 &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; index = Math.floor(Math.random()*arr.length);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;随机下标&lt;/span&gt;
                     newArr.push(arr[index]);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将随机出的元素，存放新数组newArr中去&lt;/span&gt;
                     arr.splice(index,1);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    将随机出的元素在arr中删除            &lt;/span&gt;
&lt;span&gt;            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;arr中删除随机出的元素,arr.length-1,同时i++,导致循环不会10次,会是5次.最后得到newArr中只有一半的随机数字,arr中剩下另一半. 将其合并到一起,得到res&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; res =&lt;span&gt;[...newArr,...arr];
            console.log(res) &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;把len当成，作为循环条件，最后所有的都是随机的，结果如下：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1581103/201903/1581103-20190326233902400-1332984222.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 26 Mar 2019 15:41:00 +0000</pubDate>
<dc:creator>怒其不争1</dc:creator>
<og:description>js数组乱序输出，数组乱序排列</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Mir-bink/p/10604747.html</dc:identifier>
</item>
<item>
<title>如何成为优秀开发人员（一）：怎样算是优秀的？ - 技术小工</title>
<link>http://www.cnblogs.com/qianpangzi/p/10604726.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qianpangzi/p/10604726.html</guid>
<description>&lt;h2&gt; &lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　有感于国内软件开发人员的素质普遍低下，招聘程序员往往面试了N个人都看不到一个顺眼的（当然这里面有很大原因是教育体制的问题）。因此考虑写一个系列，聊一下“如何成为优秀的开发人员”这个话题。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;何为优秀？&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;要想成为一个优秀的开发人员，先得搞清楚什么样的开发人员才能称得上是优秀的？要给“优秀开发人员”下一个准确的定义有一点点困难，于是我用举例来说明。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　经我多年观察，对于大部分的软件开发团队都有这样的一个现象，那就是团队中的&lt;strong&gt;少数&lt;/strong&gt;（一般来说，小于总人数的20%）开发人员具有更快的开发效率、更好的程序设计、更好的代码质量、更善于 debug、更能够解决技术难题......（总之就是让 team leader 事事省心）。而且这一小撮开发人员的贡献总和可能与另外那一大撮人（大于总人数的80%）的贡献总和不相上下（甚至可能超过）。那么，这一小撮开发人员，就是我所谓的优秀开发人员。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　说到这里，列位看官应该明白我所指的“优秀开发人员”是什么样的了吧？（如果个别读者还是不明白，那只能说明你智商偏低，本系列帖子不适合你）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　如果你觉得自己目前还不属于这一小撮之列，但是希望自己日后成为他们中的一员，你该怎么做呢？我的建议就是：仔细阅读后续的“如何成为优秀的开发人员”系列文章。我会在里面逐一介绍相关的东东，或许有助于你能力的成长。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　反之，如果你自认为已经&lt;strong&gt;完全&lt;/strong&gt;符合我所说的优秀开发人员，那么恭喜你，你可以直接略过该系列文章，去看点别的什么东西吧 :-)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　本系列不会涉及到具体的编程语言技巧、不会涉及到具体的开发工具、不会涉及到具体的软件框架、不会涉及到任何当下时髦的概念（比如什么 OOP、FP、Pattern、SOA、REST、RIA......）。至于我具体会聊些啥，大伙看了以后就知道了。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　最后补充声明一下：这里所说的优秀开发人员和开发大牛（洋文叫做 Guru）不是一回事，看完这个系列文章或许有助于你成为优秀开发人员，但并不能帮助你成为开发大牛。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;未完待续……&lt;/p&gt;

</description>
<pubDate>Tue, 26 Mar 2019 15:39:00 +0000</pubDate>
<dc:creator>技术小工</dc:creator>
<og:description>有感于国内软件开发人员的素质普遍低下，招聘程序员往往面试了N个人都看不到一个顺眼的（当然这里面有很大原因是教育体制的问题）。因此考虑写一个系列，聊一下“如何成为优秀的开发人员”这个话题。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qianpangzi/p/10604726.html</dc:identifier>
</item>
<item>
<title>【RAY TRACING THE REST OF YOUR LIFE 超详解】 光线追踪 3-7 混合概率密度 - 林-兮</title>
<link>http://www.cnblogs.com/lv-anchoret/p/10604712.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lv-anchoret/p/10604712.html</guid>
<description>&lt;p&gt;&lt;span class=&quot;tlid-translation translation&quot; lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;&quot;&gt;但是评估pdf_mixture会稍微有点微妙。 &lt;span title=&quot;&quot;&gt;我们需要同时评估pdf_reflection和pdf_light，因为有一些方向可以生成pdf方向。 &lt;span title=&quot;&quot;&gt;例如，我们可以使用pdf_reflection生成朝向光的方向&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;tlid-translation translation&quot; lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;&quot;&gt;&lt;span title=&quot;&quot;&gt;&lt;span title=&quot;&quot;&gt;如果我们回顾之前的内容，你会发现，这一部分主要解决两个问题：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;tlid-translation translation&quot; lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;&quot;&gt;&lt;span title=&quot;&quot;&gt;&lt;span title=&quot;&quot;&gt;我们抽象出这些操作之后，就可以写一个关于我们的pdf的一个基类：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;div readability=&quot;107.83914608415&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt;&lt;span&gt;pdf.hpp&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; -----------------------------------------------------
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [author]        lv
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [ time ]        2019.3
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [brief ]        In the Monte Carlo system, pdf acts as the
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                most important element of Important-Sample
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; -----------------------------------------------------&lt;/span&gt;


&lt;span&gt;#pragma&lt;/span&gt; once


&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; rt
{

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; the basic class of pdf system&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; pdf
    {
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
    @brief: we get the value of pdf function by this interface
    @param: the direction of location
    @retur: the value of the pdf function
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;virtual&lt;/span&gt; rtvar value(&lt;span&gt;const&lt;/span&gt; rtvec &amp;amp; direction)&lt;span&gt;const&lt;/span&gt; = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
    @brief: generate a random number with a Probability model
    @param: none
    @retur: the Three-dimensional random vector
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;virtual&lt;/span&gt; rtvec generate()&lt;span&gt;const&lt;/span&gt; = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    };


}&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;rt namespace&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;我们来实现关于它的一些子类&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先我们来实现关于cosine 概率密度的模型&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt;&lt;span&gt;cosine_pdf.hpp&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; -----------------------------------------------------
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [author]        lv
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [ time ]        2019.3
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [brief ]        one of the pdf' forms
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; -----------------------------------------------------&lt;/span&gt;


&lt;span&gt;#pragma&lt;/span&gt; once


&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; rt
{

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; cosine_pdf :&lt;span&gt;public&lt;/span&gt;&lt;span&gt; pdf
    {
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;constructor&lt;/span&gt;
    cosine_pdf(&lt;span&gt;const&lt;/span&gt; rtvec&amp;amp;&lt;span&gt; w);            

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
    @brief: we get the value of pdf function by this interface
    @param:    the direction of location
    @retur: the value of the pdf function
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;virtual&lt;/span&gt; rtvar value(&lt;span&gt;const&lt;/span&gt; rtvec&amp;amp; direction)&lt;span&gt;const&lt;/span&gt;&lt;span&gt;;


    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
    @brief: generate a random number with a Probability model
    @param: none
    @retur:    the Three-dimensional random vector
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;virtual&lt;/span&gt; rtvec generate()&lt;span&gt;const&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;:

    onb _uvw;
    };

inline cosine_pdf::cosine_pdf(&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; rtvec&amp;amp;&lt;span&gt; w)
    {
    _uvw.build_from_w(w);
    }

rtvar cosine_pdf::value(&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; rtvec&amp;amp; direction)&lt;span&gt;const&lt;/span&gt;&lt;span&gt;
    {
    rtvar cosine &lt;/span&gt;=&lt;span&gt; dot(direction.ret_unitization(), _uvw.w());
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (cosine &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;.)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; cosine /&lt;span&gt; π;
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;.;
    }

rtvec cosine_pdf::generate()&lt;/span&gt;&lt;span&gt;const&lt;/span&gt;&lt;span&gt;
    {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; _uvw.local(random_cosine_direction());
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这个模型之前细说过，cosine大于0的时候返回cosine/π，反之，则返回0。因为光线反射之后如果和表面法线的夹角为钝角的时候，违反反射规律，不以反射。生成随机数的那个之前也讲过，在&lt;a href=&quot;https://www.cnblogs.com/lv-anchoret/p/10518961.html&quot; target=&quot;_blank&quot;&gt;上上一篇&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其实这些都不是新东西，就是把之前讲的的那一套整合了一下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;得到结果也就是之前的效果&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们把主函数里面的lerp（）也改一下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201903/1316111-20190326194923111-837358898.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;每个像素点采样100次，取均值，即sample 为 100时&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201903/1316111-20190326202956020-1725014225.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; 这是代码敲错了，意外得到的一张图&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201903/1316111-20190326195417442-15109798.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; 现在我们尝试，光源采样，即&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt;&lt;span&gt;hit_pdf.hpp&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; -----------------------------------------------------
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [author]        lv
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [ time ]        2019.3
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [brief ]        toward to the hitable
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; -----------------------------------------------------&lt;/span&gt;

&lt;span&gt;#pragma&lt;/span&gt; once


&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; rt
{

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; hit_pdf :&lt;span&gt;public&lt;/span&gt;&lt;span&gt; pdf
    {
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
    @param: info -&amp;gt; Geometry information
            origion -&amp;gt; the point of intersection
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    hit_pdf(intersect&lt;/span&gt;* info, &lt;span&gt;const&lt;/span&gt; rtvec&amp;amp;&lt;span&gt; origion)
        :_intersectp(info)
        ,_o(origion)
    {
    }


    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
    @brief: we get the value of pdf function by this interface
    @param:    the direction of location
    @retur: the value of the pdf function
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;virtual&lt;/span&gt; rtvar value(&lt;span&gt;const&lt;/span&gt; rtvec&amp;amp; direction)&lt;span&gt;const&lt;/span&gt;&lt;span&gt;
        {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; _intersectp-&amp;gt;&lt;span&gt;pdf_value(_o, direction);
        }
    

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
    @brief: generate a random number with a Probability model
    @param: none
    @retur:    the Three-dimensional random vector
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;virtual&lt;/span&gt; rtvec generate()&lt;span&gt;const&lt;/span&gt;&lt;span&gt;
        {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; _intersectp-&amp;gt;&lt;span&gt;random(_o);
        }

&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;:
        
    rtvec _o;

    intersect &lt;/span&gt;*&lt;span&gt; _intersectp;
    };

}&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; rt namespace&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;对应的intersect类也要改一下&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt;&lt;span&gt; intersect.hpp&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;https://www.cnblogs.com/lv-anchoret/p/10190092.html&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; -----------------------------------------------------
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [author]        lv
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [begin ]        2018.12
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [refre ]        2019.3
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [brief ]        the intersect-class for the ray-tracing project
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                from the 《ray tracing in one week》
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; -----------------------------------------------------&lt;/span&gt;

&lt;span&gt;#pragma&lt;/span&gt; once&lt;span&gt;

#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;E:\OpenGL\光线追踪\code\ray tracing 1-3\ray tracing 1-3\ray.hpp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;


&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; rt
{
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; material;
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; aabb;


&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; the infomation of intersection point&lt;/span&gt;

&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; hitInfo
    {
    lvgm::precision _t;        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ray 中的系数t&lt;/span&gt;
    rtvec _p;                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;相交点、撞击点&lt;/span&gt;
    rtvec _n;                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;_p点的表面法线&lt;/span&gt;
    material* _materialp;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;材质&lt;/span&gt;
    rtvar _u;                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;texture-u&lt;/span&gt;
    rtvar _v;                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;texture-v&lt;/span&gt;
&lt;span&gt;    };


&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; the statement of intersect class&lt;/span&gt;

&lt;span&gt;class&lt;/span&gt;&lt;span&gt; intersect
    {
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
    @brief: 撞击函数，求取撞击点相关记录信息
    @param: sight-&amp;gt;视线
    系数t的上下界-&amp;gt;筛选撞击点
    info-&amp;gt;返回撞击点信息
    @retur: 是否存在合法撞击点
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; hit(&lt;span&gt;const&lt;/span&gt; ray&amp;amp; sight, rtvar t_min, rtvar t_max, hitInfo&amp;amp; info)&lt;span&gt;const&lt;/span&gt; = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
    @brief: get the box of Geometry
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;virtual&lt;/span&gt; aabb getbox()&lt;span&gt;const&lt;/span&gt; = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
    Get the value of pdf function
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;virtual&lt;/span&gt; rtvar pdf_value(&lt;span&gt;const&lt;/span&gt; rtvec&amp;amp; o, &lt;span&gt;const&lt;/span&gt; rtvec&amp;amp; v)&lt;span&gt;const&lt;/span&gt;&lt;span&gt;
        {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;.;
        }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
    generate the random number
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;virtual&lt;/span&gt; rtvec random(&lt;span&gt;const&lt;/span&gt; rtvec&amp;amp; o)&lt;span&gt;const&lt;/span&gt;&lt;span&gt;
        {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; rtvec(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
        }


    };

}&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; rt namespace&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;因为我们现在只是拿区域光源做实验，并不是所有的几何体派生类都要继承pdf相关的方法，所以，它们两个以虚函数的形式存在即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么就剩下xz长方形了&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
rtvar xz_rect::pdf_value(&lt;span&gt;const&lt;/span&gt; rtvec&amp;amp; o, &lt;span&gt;const&lt;/span&gt; rtvec&amp;amp; v)&lt;span&gt;const&lt;/span&gt;&lt;span&gt;
    {
    hitInfo rec;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;-&amp;gt;hit(ray(o, v), 1e-&lt;span&gt;3&lt;/span&gt;&lt;span&gt;, rt::rtInf(), rec))
        {
        rtvar area &lt;/span&gt;= (_x2 - _x1)*(_z2 -&lt;span&gt; _z1);
        rtvar distance_squared &lt;/span&gt;= rec._t * rec._t *&lt;span&gt; v.squar();
        rtvar cosine &lt;/span&gt;= fabs(dot(v, rec._n) /&lt;span&gt; v.normal());
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; distance_squared / (cosine*&lt;span&gt;area);
        }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;.;
    }

rtvec xz_rect::random(&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; rtvec&amp;amp; o)&lt;span&gt;const&lt;/span&gt;&lt;span&gt;
    {
    rtvec random_point &lt;/span&gt;= rtvec(_x1 + lvgm::rand01() * (_x2 - _x1), _other, _z1 + lvgm::rand01()*(_z2 -&lt;span&gt; _z1));
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; random_point -&lt;span&gt; o;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt; 把上一篇写在lerp函数里面的一大堆东西整合到类里面&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么我们的lerp就统一化了：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201903/1316111-20190326203808111-1087094476.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们取sample为10，即可得到很好的效果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201903/1316111-20190326220956704-545685690.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;现在我们将写一个关于混合概率密度的类：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt;&lt;span&gt;mixture_pdf.hpp&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; -----------------------------------------------------
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [author]        lv
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [ time ]        2019.3
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [brief ]        mixture pdfs
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; -----------------------------------------------------&lt;/span&gt;


&lt;span&gt;#pragma&lt;/span&gt; once


&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; rt
{

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; mixture_pdf :&lt;span&gt;public&lt;/span&gt;&lt;span&gt; pdf
    {
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:

    mixture_pdf(pdf &lt;/span&gt;* p1, pdf*&lt;span&gt; p2)
        {
        _p[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;] =&lt;span&gt; p1;
        _p[1&lt;/span&gt;] =&lt;span&gt; p2;
        }


    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
    @brief: we get the value of pdf function by this interface
    @param:    the direction of location
    @retur: the value of the pdf function
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;virtual&lt;/span&gt; rtvar value(&lt;span&gt;const&lt;/span&gt; rtvec&amp;amp; direction)&lt;span&gt;const&lt;/span&gt;&lt;span&gt;
        {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0.5&lt;/span&gt;*_p[&lt;span&gt;0&lt;/span&gt;]-&amp;gt;value(direction) + &lt;span&gt;0.5&lt;/span&gt;*_p[&lt;span&gt;1&lt;/span&gt;]-&amp;gt;&lt;span&gt;value(direction);
        }


    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
    @brief: generate a random number with a Probability model
    @param: none
    @retur:    the Three-dimensional random vector
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;virtual&lt;/span&gt; rtvec generate()&lt;span&gt;const&lt;/span&gt;&lt;span&gt;
        {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (lvgm::rand01() &amp;lt; &lt;span&gt;0.5&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; _p[&lt;span&gt;0&lt;/span&gt;]-&amp;gt;&lt;span&gt;generate();
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; _p[&lt;span&gt;1&lt;/span&gt;]-&amp;gt;&lt;span&gt;generate();
        }

&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;:

    pdf&lt;/span&gt;* _p[&lt;span&gt;2&lt;/span&gt;&lt;span&gt;];

    };


}&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; rt namespace&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;我们的lerp函数如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201903/1316111-20190326221826365-713567498.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;我们采样10次得到：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201903/1316111-20190326223552664-1653431163.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是觉得效果不是很理想，我们来做一些测试&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;1. pdf 方程修改为 mixture_pdf = 1/3 * hit_pdf + 2/3  * cosine_pdf&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201903/1316111-20190326223943779-1325076970.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;2. pdf 方程修改为 mixture_pdf = 2/3 * hit_pdf + 1/3  * cosine_pdf&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201903/1316111-20190326224334596-1698922572.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;3. random修改  2/3 取 hit_pdf产生的随机值， 1/3 取 cosine_pdf 产生的随机值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201903/1316111-20190326224719726-1918203670.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;4. random修改  1/3 取 hit_pdf产生的随机值， 2/3 取 cosine_pdf 产生的随机值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201903/1316111-20190326225240806-1289391468.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;我们去上述方案的3、1，即：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201903/1316111-20190326230101125-119281067.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;得到图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201903/1316111-20190326230133856-581228878.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这张图显然比均分的效果要好&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;这里我们看不出到底是random起作用还是value，我们不妨取2、3组合&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201903/1316111-20190326230436398-493314455.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3把2的彩色噪声消除了些，但是这张图和原始的均分图差不多一样&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以结论，random和value的比例交叉比较好&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;我们采样1000次得到：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 渲染中。。。。（就是清晰了点）&lt;/p&gt;

&lt;p&gt;&lt;span&gt;本书第九章（下一章）介绍了一些关于当前渲染器的看法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;作者在描述阴影光线和混合密度设计时，作者个人更偏向于混合密度设计，所以并没有在渲染器中采用阴影光线&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;作者描述了关于lerp函数中内存问题以及编码的不足&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;作者描述了关于玻璃材质和镜面的一些处理方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;作者还描述了关于HDR的0~1浮点表示以及RGB分组的0~255表示，还说明了这个渲染器是RGB的且基于物理的，还有一种是基于光谱的，以及两者结合的，但做起来很难，所以我们坚持RGB且基于物理的渲染器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201903/1316111-20190326232130050-858795909.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201903/1316111-20190326232244201-723306021.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; 感谢您的阅读，生活愉快~&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Tue, 26 Mar 2019 15:35:00 +0000</pubDate>
<dc:creator>林-兮</dc:creator>
<og:description>Mixture Densities</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lv-anchoret/p/10604712.html</dc:identifier>
</item>
<item>
<title>CTF实验吧让我进去writeup - Yunen的博客</title>
<link>http://www.cnblogs.com/yunen/p/10604681.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yunen/p/10604681.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/10/23/5bcf2b29d3962.png&quot;/&gt;&lt;br/&gt;两个表单，我们用burp抓包试试&lt;br/&gt;&lt;img src=&quot;https://i.loli.net/2018/10/23/5bcf2f8d4e0ca.png&quot;/&gt;&lt;br/&gt;这时候我们发现Cookie值里有个很奇怪的值是source，这个单词有起源的意思，我们就可以猜测这个是判断权限的依据，让我们来修改其值为1，发送得到如下显示：&lt;br/&gt;&lt;img src=&quot;https://i.loli.net/2018/10/23/5bcf3112ab7be.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;发现爆出了源代码，让我们来审计一下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$flag = &quot;XXXXXXXXXXXXXXXXXXXXXXX&quot;;
$secret = &quot;XXXXXXXXXXXXXXX&quot;; // This secret is 15 characters long for security!

$username = $_POST[&quot;username&quot;];
$password = $_POST[&quot;password&quot;];

if (!empty($_COOKIE[&quot;getmein&quot;])) {
    if (urldecode($username) === &quot;admin&quot; &amp;amp;&amp;amp; urldecode($password) != &quot;admin&quot;) {
        if ($COOKIE[&quot;getmein&quot;] === md5($secret . urldecode($username . $password))) {
            echo &quot;Congratulations! You are a registered user.\n&quot;;
            die (&quot;The flag is &quot;. $flag);
        }
        else {
            die (&quot;Your cookies don't match up! STOP HACKING THIS SITE.&quot;);
        }
    }
    else {
        die (&quot;You are not an admin! LEAVE.&quot;);
    }
}

setcookie(&quot;sample-hash&quot;, md5($secret . urldecode(&quot;admin&quot; . &quot;admin&quot;)), time() + (60 * 60 * 24 * 7));

if (empty($_COOKIE[&quot;source&quot;])) {
    setcookie(&quot;source&quot;, 0, time() + (60 * 60 * 24 * 7));
}
else {
    if ($_COOKIE[&quot;source&quot;] != 0) {
        echo &quot;&quot;; // This source code is outputted here
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们如果需要获得flag，需要满足一下条件：&lt;br/&gt;1.Cookie中getmein的值不能为空&lt;br/&gt;2.username必须为admin和password不能为admin&lt;br/&gt;3.Cookie中的getmein必须等于&lt;code&gt;md5($secret.urldecode($username.$password))&lt;/code&gt;&lt;br/&gt;满足这三个条件才可获得flag，可是我们无法得知$secret的值为多少&lt;br/&gt;&lt;code&gt;setcookie(&quot;sample-hash&quot;, md5($secret . urldecode(&quot;admin&quot; . &quot;admin&quot;)), time() + (60 * 60 * 24 * 7));&lt;/code&gt;&lt;br/&gt;发现下面有行代码是这样写的，将输出的&lt;code&gt;md5($secret . urldecode(&quot;admin&quot; . &quot;admin&quot;))&lt;/code&gt;作为cookie输出，结合前面的数据包我们可以知道输出的值为&lt;code&gt;571580b26c65f306376d4f64e53cb5c7&lt;/code&gt; 可是这串md5是由$secret+'adminadmin'转md5而得到的，如果我们在password输入admin将不满足前面所需的三个条件&lt;/p&gt;

&lt;p&gt;我们知道常见的md5是16位的，而这里的md5正是16位，我们的$secret是十五位的,加上'adminadmin'就变成25位了，很明显这里的md5肯定会出现重复，所以我们可以哈希长度拓展攻击绕过这个死局&lt;br/&gt;这里附两个讲述具体原理的链接:&lt;br/&gt;&lt;a href=&quot;http://www.freebuf.com/articles/web/69264.html&quot; class=&quot;uri&quot;&gt;http://www.freebuf.com/articles/web/69264.html&lt;/a&gt; &lt;a href=&quot;https://www.cnblogs.com/p00mj/p/6288337.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/p00mj/p/6288337.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在Kali下用hashpump操作&lt;br/&gt;&lt;img src=&quot;http://image.mamicode.com/info/201810/20181007123528335098.png&quot;/&gt;&lt;br/&gt;最好我们构造数据包，把生成的数据发送即可获得flag&lt;br/&gt;&lt;img src=&quot;http://image.mamicode.com/info/201810/20181007123529050946.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 26 Mar 2019 15:28:00 +0000</pubDate>
<dc:creator>Yunen的博客</dc:creator>
<og:description>初探题目 &lt;! more 两个表单，我们用burp抓包试试 这时候我们发现Cookie值里有个很奇怪的值是source，这个单词有起源的意思，我们就可以猜测这个是判断权限的依据，让我们来修改其值为1，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yunen/p/10604681.html</dc:identifier>
</item>
<item>
<title>OO第一单元总结 - 胖胖的毛毛虫</title>
<link>http://www.cnblogs.com/ring-of-sun/p/10604665.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ring-of-sun/p/10604665.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　第一单元oo的作业已经结束，3次递进式的编程作业和2次实验课作业让我们初步体会到了面向对象的思想，以下对本人在第一单元中的三次作业进行分析和总结。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;　一、三次作业的结构分析&lt;/h2&gt;
&lt;h3&gt;　　1、类个数及长度分析&lt;/h3&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1615693/201903/1615693-20190326215033114-1104893240.png&quot; alt=&quot;&quot; width=&quot;865&quot; height=&quot;125&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一次作业&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1615693/201903/1615693-20190326215127931-67307469.png&quot; alt=&quot;&quot; width=&quot;867&quot; height=&quot;220&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第二次作业&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1615693/201903/1615693-20190326215250575-587869996.png&quot; alt=&quot;&quot; width=&quot;864&quot; height=&quot;264&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第三次作业&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;从图中可以直观的看出，第一次作业中只有两个类，说明当时对面向对象的思想还相当不了解，更多的是像之前一样面向过程，针对给出的问题一步步寻求解决的方案；而第二次作业类的数目就增加到了6个，已经开始尝试去面向对象编程，把多项式求导分解成了对多项式这一类具有相似特征的一系列操作，多项式类、求导类、合并类······还增加了老师建议的InputHandler，已经开始按照面向对象的思想分析问题；第三次作业的这一特征更加明显，递归下降使得类与类之间有了更密切的联系，表达式 -&amp;gt; 项 -&amp;gt; 因子，功能的实现在类的内部，类之间依赖于信息的传递。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　代码的长度由第一次的450行到第二次的720行再到第三次的700行，实现的是越来越复杂的功能，后面的程序支持前面的程序，第三次因为类之间的配合更密切以及优化写的比较粗糙（泪。。。），其长度反而比第二次要短。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;　　2、复杂度分析&lt;/h3&gt;
&lt;p&gt;　　&lt;span&gt;注：　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　ev(G)基本复杂度。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　iv(G)循环复杂度。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　v(G)整体复杂度。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1615693/201903/1615693-20190326221503294-1993049723.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一次作业&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1615693/201903/1615693-20190326221529906-492394521.png&quot; alt=&quot;&quot; width=&quot;661&quot; height=&quot;458&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第二次作业&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1615693/201903/1615693-20190326221555495-902362204.png&quot; alt=&quot;&quot; width=&quot;606&quot; height=&quot;369&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第三次作业&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;　从以上的表格可以看出，我每次作业都有几个方法的复杂度偏高，而且绝大多数都是iv偏高，分析原因，在这些方法中都用了较多的for循环，以及极多的if-else语句，这就可以看出我在分析问题时习惯于穷举可能发生的情况，这就导致了在情况多的时候方法的复杂度会较高，今后可能需要尝试更为有效的解析问题的方法。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;　　3、类图分析&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1615693/201903/1615693-20190326222717195-544754824.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一次作业&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1615693/201903/1615693-20190326222732600-1078260574.png&quot; alt=&quot;&quot; width=&quot;984&quot; height=&quot;515&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第二次作业&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1615693/201903/1615693-20190326222804815-1099908304.png&quot; alt=&quot;&quot; width=&quot;824&quot; height=&quot;829&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第三次作业&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;　三次作业的特点非常鲜明，第一次作业中只用到了两个类，也只是在 main 调用了 poly ，这也直接导致了我第二次作业的完全重构；第二次作业类与类之间的关系也非常不密切，只是通过主类依次调用各个类来实现目的；而第三次作业中，类与类之间就有了联系，通过主类来调度，在 Item 和 Poly 这两个类之间递归直至发现了最基本的因子，再去调用因子对应的类。和其他人的程序比较发现，在我认为我以及很面向对象了的情况下，一些共同的功能（如求导）我没有用接口的方式去解决，也就是我在3次作业中并没有用到接口，可见还是没有熟练的掌握面向对象的思想。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;　二、bug分析&lt;/h2&gt;
&lt;h3&gt;　　1、第一次作业&lt;/h3&gt;
&lt;p&gt;　　　　&lt;span&gt;第一次作业中出现的bug是没有考虑出&amp;lt;space&amp;gt;和&amp;lt;tab&amp;gt;之外的空白字符，这个在修改时只需要把正则中用到 \\s 的地方改为 [\\t ]即可。&lt;/span&gt; &lt;/p&gt;
&lt;h3&gt;　　2、第二次作业&lt;/h3&gt;
&lt;p&gt;　　　　&lt;span&gt;第二次作业中的bug比较严重，没有考虑指数中带 + 号的情况，因为我在分割的过程中用 + 号作为了分割符对项进行分割，就导致了会出现异常，我在修复时采用了在判断合法的前提下把 ^+ 替换为 ^ ；还有一个bug出现在我的优化，我在优化之后可能把一个表达式优化为常数，而常数不可再次优化，这就导致会出现异常（无辜的眼神），我在把优化前的表达式进行了判断，解决了这一问题。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;　　3、第三次作业&lt;/h3&gt;
&lt;p&gt;　　　　&lt;span&gt;这次作业bug未知。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;　三、bug发现策略&lt;/h2&gt;
&lt;p&gt;　　　&lt;span&gt;　前两次作业中，我因为没有使用正则判断表达式是否合法，而是采用了状态机的方式，因此我清楚各种应该输出WF的情况（所有情况：）），在测试的时候我先用这些数据盲测了一波，就能发现几个问题，然后挑两个倒霉的孩子学习他们的代码（找bug），读完的结果就是膜或者发起进攻。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　第三次作业我也用了前两次作业的方法，由于WF被禁止了，并没有发现bug，除此之外还用了评测机的方式，这个就相当有效了，当然，为了做个人，见好就收。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;　四、Applying Creational Pattern&lt;/h2&gt;
&lt;p&gt;　　　&lt;span&gt;　与一份优秀的面向对象的相比，我的还差很多，虽然我大致理解面向对象的思想，但在我3次作业中，都没有用到继承和接口，所以有极大的重构空间，可以使那些相互依赖性强的类从一个父类继承下来，然后把一些共同具备的功能（主要指求导）用接口实现，这样就能使代码更加面向对象了。在面向对象课程的学习上我还有很长的路要走，希望在接下来的过程中，能够对面向对象的思想有更深的理解吧。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 26 Mar 2019 15:24:00 +0000</pubDate>
<dc:creator>胖胖的毛毛虫</dc:creator>
<og:description>第一单元oo的作业已经结束，3次递进式的编程作业和2次实验课作业让我们初步体会到了面向对象的思想，以下对本人在第一单元中的三次作业进行分析和总结。 一、三次作业的结构分析 1、类个数及长度分析 第一次</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ring-of-sun/p/10604665.html</dc:identifier>
</item>
<item>
<title>node 调试相关 - 刘哇勇</title>
<link>http://www.cnblogs.com/Wayou/p/node_debug.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Wayou/p/node_debug.html</guid>
<description>&lt;h2&gt;#0 node 正确的书写方式&lt;/h2&gt;
&lt;p&gt;为了防止后面出现混乱的各种书写，先来了解一下如何正确书写 node 的名称。&lt;/p&gt;
&lt;p&gt;下面使用来自&lt;a href=&quot;https://twitter.com/bitandbang/status/1087359646367731719&quot; rel=&quot;nofollow&quot;&gt;@bitandbang 推文&lt;/a&gt;中的图片展示如何正确书写 node 名称。&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://raw.githubusercontent.com/wayou/wayou.github.io/master/posts/nodejs-debug/assets/node_the_right_way.jpg&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/wayou/wayou.github.io/master/posts/nodejs-debug/assets/node_the_right_way.jpg&quot; alt=&quot;node 名称的正确书写方式&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;em&gt;node 名称的正确书写方式&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;&lt;code&gt;--inspect&lt;/code&gt; 参数&lt;/h3&gt;
&lt;p&gt;本地开发，无论是 web 应用还是命令行工具，使用 &lt;code&gt;--inspect-brk&lt;/code&gt; 参数启动程序，然后结合 Chrome DevTools 调试恐怕能满足大多数场景了。&lt;/p&gt;
&lt;p&gt;具体步骤：&lt;/p&gt;
&lt;p&gt;通过 &lt;code&gt;--inspect-brk&lt;/code&gt; 参数启动程序，会进入调试模式。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
$ &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;node --inspect-brk index.js&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里使用 &lt;code&gt;--inspect-brk&lt;/code&gt; 而非 &lt;code&gt;--inspect&lt;/code&gt; 可保证代码第一时间断在开程序开头。如果使用后者，有可能无法进行后续操作。&lt;/p&gt;
&lt;p&gt;打开 Chrome 新开标签页访问 &lt;code&gt;chrome://inspect&lt;/code&gt;。不出意外会看到刚刚创建的一个调试实例，直接点击 &lt;code&gt;inspect&lt;/code&gt; 即可启动调试。因为是 &lt;code&gt;--inspect-brk&lt;/code&gt; 启动的，调试界面打开后会断在程序开头。后面在哪里加断点就有很大自主权了。&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://raw.githubusercontent.com/wayou/wayou.github.io/master/posts/nodejs-debug/assets/chrome_inspect_panel.png&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/wayou/wayou.github.io/master/posts/nodejs-debug/assets/chrome_inspect_panel.png&quot; alt=&quot;chrome://inspect 界面&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;em&gt;&lt;code&gt;chrome://inspect&lt;/code&gt; 界面&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;需要注意的是，因为此时断在了程序开始，程序中其他文件可能没加载。所以无法看到。这种情况下，可事先在需要加断点的地方写上 &lt;code&gt;debugger&lt;/code&gt;。&lt;/p&gt;
&lt;h3&gt;子进程中代码的调试&lt;/h3&gt;
&lt;p&gt;另一个需要注意的地方就是子进程。对于 &lt;strong&gt;子进程&lt;/strong&gt; 中的代码，是无法断点的，这是调试大多数框架及复杂程序时的痛点。&lt;/p&gt;
&lt;p&gt;一个简单的子进程示例：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;index.js&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; cp &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;child_process&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;);
&lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; child &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;cp&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;fork&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;./child&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;);

&lt;span class=&quot;pl-smi&quot;&gt;child&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;on&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;message&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;m&lt;/span&gt;) {
  &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;received: &lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt; m);
});

&lt;span class=&quot;pl-smi&quot;&gt;child&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;send&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;Please up-case this string&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;child.js&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-c1&quot;&gt;process&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;on&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;message&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;m&lt;/span&gt;) {
  &lt;span class=&quot;pl-k&quot;&gt;debugger&lt;/span&gt;;
  &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; Do work  (in this case just up-case the string&lt;/span&gt;
  m &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;m&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;toUpperCase&lt;/span&gt;();

  &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; Pass results back to parent process&lt;/span&gt;
  &lt;span class=&quot;pl-c1&quot;&gt;process&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;send&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;m&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;toUpperCase&lt;/span&gt;(m));
});
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里，&lt;code&gt;node --inspect-brk index.js&lt;/code&gt; 启动调试后，&lt;code&gt;child.js&lt;/code&gt; 中的 &lt;code&gt;debugger&lt;/code&gt; 并不会生效，因为它的代码在子进程中。&lt;/p&gt;
&lt;p&gt;这也就是为什么，当你想调试 webpack 编译，恰好又用了类似 &lt;a href=&quot;https://github.com/amireh/happypack&quot;&gt;happypack&lt;/a&gt; 这种多进程加速编译的工具时，发现 loader 及 插件中无法断点的原因。&lt;/p&gt;
&lt;p&gt;又比如，调试 eggjs，它也是多进程的模型，业务代码是运行在 worker 进程中的，直接通过 node 的调试参数肯定是不行的。当然框架一般会有自身配套的调试方案，你可以安装 egg 的 vscode 调试插件，或者使用 egg-scripts 来启动调试。&lt;/p&gt;
&lt;p&gt;那是不是就无能为力了？当然不是，只是需要费劲一点。我们需要找到开启子进程的地方，在开启的时候加上调试参数。&lt;/p&gt;
&lt;p&gt;还是上面的示例，改造主文件为如下：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-diff&quot; readability=&quot;12&quot;&gt;
&lt;pre&gt;
var cp = require('child_process');
&lt;span class=&quot;pl-mi1&quot;&gt;&lt;span class=&quot;pl-mi1&quot;&gt;+&lt;/span&gt;var child = cp.fork('./child',[],{execArgv:['--inspect-brk']});&lt;/span&gt;

child.on('message', function(m) {
  console.log('received: ' + m);
});

child.send('Please up-case this string');
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样，就表示以调试模式来运行子进程中的代码，此时启动程序不要加 &lt;code&gt;inspect&lt;/code&gt;，因为那是开启对主进程的调试，直接运行程序即可。&lt;code&gt;node index.js&lt;/code&gt;。然后我们会在 &lt;code&gt;Chrome://inspect&lt;/code&gt; 看到子进程已经 attach 到了调试界面。&lt;/p&gt;
&lt;p&gt;所以，无论是通过 &lt;code&gt;require('child_process'&lt;/code&gt; 的 &lt;code&gt;exec&lt;/code&gt; 还是 &lt;code&gt;spawn&lt;/code&gt;，只需要找到开启子进程的地方，加上调试参数。&lt;/p&gt;
&lt;p&gt;但问题是，就看你能不能正确地找到所使用的框架工具他们开启子进程的地方。&lt;/p&gt;
&lt;h3&gt;善用 npx&lt;/h3&gt;
&lt;p&gt;调试 node 模块时，特别是 npm 包，你需要手动拼出该模块的入口文件的路径，类似 &lt;code&gt;node —inspect node_modules/webpack/bin/webpack.js&lt;/code&gt;, 但通过 &lt;code&gt;npx&lt;/code&gt; 则不用，因为 npx 会自动在项目的 &lt;code&gt;node_modules&lt;/code&gt; 或系统全局中寻找模块的入口文件，甚至如果本机没有安装，它还会自动搜索 registry 自动安装后执行。&lt;/p&gt;
&lt;p&gt;以至于你在初始化一个项目时，可使用如下命令：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
$ npx license mit &lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; LICENSE
$ npx gitignore node
$ npx covgen YOUR_EMAIL_ADDRESS
$ npm init -y
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;即使你本地并没有安装 &lt;code&gt;mit&lt;/code&gt;，&lt;code&gt;gitignore&lt;/code&gt;，&lt;code&gt;covgen&lt;/code&gt; 等 npm 包。&lt;/p&gt;
&lt;p&gt;使用 npx 时可通过 &lt;code&gt;—node-arg&lt;/code&gt; 来传递参数给 node。因为本质上 npx 也是执行 js 文件，与直接使用 &lt;code&gt;node&lt;/code&gt; 命令来启动文件没什么差异。&lt;code&gt;—node-arg&lt;/code&gt; 指定的参数会透传给 node，所以，可以这样来启动一个 npm 包的调试：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
$ npx —node-arg=—inspect-brk webpack
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;node 内建的 debugger&lt;/h3&gt;
&lt;p&gt;node 自带的 v8 调试工具，是个命令行工具。操作起来是难用，但在远端服务器上这种不能使用 Chrome Devtools 进行可视化调试的场景下，就显得很有用了，比如调试路由重定向次数过多这种瞬间发生的问题，它能将代码及时在服务器上断下来，让我们慢慢分析现场。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot;&gt;
&lt;pre&gt;
$ node inspect index.js
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://raw.githubusercontent.com/wayou/wayou.github.io/master/posts/nodejs-debug/assets/node_builtin_debugger.png&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/wayou/wayou.github.io/master/posts/nodejs-debug/assets/node_builtin_debugger.png&quot; alt=&quot;node 自带的 debugger&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;em&gt;node 自带的 debugger&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;进入调试模式后，代码会断在开始处。可通过以下常用命令进行 debug:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;c/cont&lt;/code&gt;：断续执行，类似于 Chrome DevTools 中的 &lt;kbd&gt;F8&lt;/kbd&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;n/next&lt;/code&gt;：步进，类似于 Chrome DevTools 中的 &lt;kbd&gt;F10&lt;/kbd&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;step/s&lt;/code&gt;: 进入，类似于 Chrome DevTools 中的 &lt;kbd&gt;F11&lt;/kbd&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;setBreakpoint()/sb()&lt;/code&gt;: 设置断点。
&lt;ul&gt;&lt;li&gt;通过调用该函数可对代码设置断点。&lt;/li&gt;
&lt;li&gt;直接调用则在当前所处的行设置断点。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sb(line_number)&lt;/code&gt; 传递一个行数，对相应行设置上断点。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sb(file_name,line_number)&lt;/code&gt; 传递文件名及行数，可对非当前文件进行断点的设置。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;clearBreakpoint&lt;/code&gt;: 参数与 &lt;code&gt;setBreakpoint&lt;/code&gt; 类似，作用是清除断点。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;breakpoints&lt;/code&gt;，查看设置的断点。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;观察变量的值。在这种调试模式下，可通过输入 &lt;code&gt;repl&lt;/code&gt; 进入 REPL（Read-Eval-Print-Loop） 模式来查看变量的值。&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://raw.githubusercontent.com/wayou/wayou.github.io/master/posts/nodejs-debug/assets/repl_in_node_debugger.png&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/wayou/wayou.github.io/master/posts/nodejs-debug/assets/repl_in_node_debugger.png&quot; alt=&quot;通过进入 REPL 模式查看断点处的变量值&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;em&gt;通过进入 &lt;code&gt;REPL&lt;/code&gt; 模式查看断点处的变量值&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;实际使用中发现个弊端，就是打印出来的对象是不完整的，如上图。如果想查看没展示出来的属性，那就得记住属性名，然后手动点出来。你当然可以通过 &lt;code&gt;JSON.stringify(variable)&lt;/code&gt; 将变量转字符后打出来。但 JSON 序列化可并不是处处都管用，比如 koa 中的 response, request 对象，如果尝试进行 JSON 序列化，会报 JSON 循环引用的错误。而且在这里的 REPL 环境下，不能调用 node 模块，不然就可以通过自带的 &lt;code&gt;require('util').inspect(variable)&lt;/code&gt; 来打印了。&lt;/p&gt;
&lt;p&gt;如果每次断在某处时，都需要查看某个变量的值，可通过设置 watcher 来更加方便地查看。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;watch&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;my_expression&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;日志加 &lt;code&gt;tail -f&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;服务器上面更加常用的应该还是日志加 &lt;code&gt;tail&lt;/code&gt;，配合 &lt;code&gt;-f&lt;/code&gt; 参数，可时实将最新的 log 输出到命令行。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot;&gt;
&lt;pre&gt;
$ tail -f /your/logs/log
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Remote Debug&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://nodejs.org/en/docs/guides/debugging-getting-started/#enabling-remote-debugging-scenarios&quot; rel=&quot;nofollow&quot;&gt;Remote Debug&lt;/a&gt; 这个就有点厉害了，没配置过，获取相应服务器权限设置好之后，估计没有比这个更便捷的调试服务器上代码的方式了。在有些资源或服务只在服务器环境才有的情况下，本地又不好还原场景。&lt;/p&gt;
&lt;h3&gt;相关资源&lt;/h3&gt;
</description>
<pubDate>Tue, 26 Mar 2019 15:22:00 +0000</pubDate>
<dc:creator>刘哇勇</dc:creator>
<og:description>0 node 正确的书写方式 为了防止后面出现混乱的各种书写，先来了解一下如何正确书写 node 的名称。 下面使用来自@bitandbang 推文中的图片展示如何正确书写 node 名称。 node</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Wayou/p/node_debug.html</dc:identifier>
</item>
</channel>
</rss>