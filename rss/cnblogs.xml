<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>lvs dr 模型配置详解 - 陈扬天</title>
<link>http://www.cnblogs.com/fengwenzhee/p/10520517.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fengwenzhee/p/10520517.html</guid>
<description>&lt;p&gt;前期准备：&lt;/p&gt;
&lt;p&gt;两台服务器 note01(lvs服务器) note02(real sever)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1 首先在note01配置子网卡：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
ifconfig eth0:&lt;span&gt;2&lt;/span&gt; &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;64.100&lt;/span&gt;/&lt;span&gt;24&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;   :2意思是eth0的子接口，随便一个数字就可以，/24意为 255.255.255.0的另一种写法 也可以写成netmask 255.255.255.0&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2 配置note01 转发方式：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
echo &lt;span&gt;1&lt;/span&gt; &amp;gt; /proc/sys/net/ipv4/ip_forward
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;   默认为0 意思为如果没有对应请求的IP，会将数据包丢弃，1为不会丢弃，而是通过路由来去转发请求。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3 配置note02(real sever) 的响应，通告级别，禁止响应对VIP的ARP广播请求&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
echo &lt;span&gt;1&lt;/span&gt; &amp;gt; /proc/sys/net/ipv4/conf/eth0/&lt;span&gt;arp_ignore

echo &lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &amp;gt; /proc/sys/net/ipv4/conf/eth0/arp_announce
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;4 配置note02 的环回IP:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
ifconfig lo:&lt;span&gt;5&lt;/span&gt; &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;64.100&lt;/span&gt; netmask &lt;span&gt;255.255&lt;/span&gt;.&lt;span&gt;255.255&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;  注意，这里:5与上边一样，可以随便写，但是后边必须写成netmask 255.255.255.255&lt;/p&gt;
&lt;p&gt;这里为什么是4个255？  因为网关192.168.64.0 是通过IP和 这个掩码进行云算计算出来的，如果这里也写成3个255，就会出现两个192.168.64.0，而lo环回接口要比eth0接口更为接近os内核，所以请求不会返回，而是直接进入环回接口，所以客户端可以发送请求，但是不会收到响应。&lt;/p&gt;
&lt;p&gt;第3 4 步顺序一定一定一定不能颠倒，否则还没有配置好接口就已经通告出去了，就不会起作用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5 为了检验lvs,我使用httpd服务进行一个简单验证，真实情况肯定就是在realsever上开启项目啦！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在note02 上执行&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
yum install httpd -y
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;安装httpd服务&lt;/p&gt;
&lt;p&gt;进入目录/var/www/html&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
cd /&lt;span&gt;var&lt;/span&gt;/www/&lt;span&gt;html

vi index.html&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在index.html中写入from 192.168.64.134(note02的真实IP)进行验证&lt;/p&gt;
&lt;p&gt;执行命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
service httpd start
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;客户端验证：rip:80 可以正常显示&lt;/p&gt;
&lt;p&gt;　　　　　　vip:80不能正常显示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1167306/201903/1167306-20190312234028131-1557164132.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1167306/201903/1167306-20190312234037854-727469018.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;6&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;配置lvs vip note01&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
yum install ipvsadm -y
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
ipvsadm -A -t &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;64.100&lt;/span&gt;:&lt;span&gt;80&lt;/span&gt; -s rr 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;// rr为轮询机制 如果配置多台realsever 则请求平均分配 -t 基于tcp协议&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
ipvsadm -a -t &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;64.100&lt;/span&gt;:&lt;span&gt;80&lt;/span&gt; -r &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;64.134&lt;/span&gt; -g
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; //-g ：dr 模型 -t基于tcp协议&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
ipvsadm -ln
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1167306/201903/1167306-20190312234126375-2029236889.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;7&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;浏览器刷新，访问vip:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1167306/201903/1167306-20190312234139340-1017605179.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
ipvsadm -lnc
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; //查看note01 会有很多记录  （偷窥）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
netstat -natp
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; //查看note01 没有记录 （说明请求直接跳过lvs 之后客户端会直接与realserver建立连接）&lt;/p&gt;
&lt;p&gt;如果能正常访问 则说明配置lvs成功，其实lvs就相当于一个路由的功能&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1167306/201903/1167306-20190312234150573-1926365741.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 12 Mar 2019 15:53:00 +0000</pubDate>
<dc:creator>陈扬天</dc:creator>
<og:description>前期准备： 两台服务器 note01(lvs服务器) note02(real sever) 1 首先在note01配置子网卡： :2意思是eth0的子接口，随便一个数字就可以，/24意为 255.25</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fengwenzhee/p/10520517.html</dc:identifier>
</item>
<item>
<title>react项目复习总结（2）--react生命周期和组件通信 - 海瑞菌·博客</title>
<link>http://www.cnblogs.com/wuhairui/p/10515918.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wuhairui/p/10515918.html</guid>
<description>&lt;p&gt;这是&lt;span&gt;react&lt;/span&gt;项目复习总结&lt;span&gt;第二讲&lt;/span&gt;，&lt;/p&gt;
&lt;p&gt;第一讲：&lt;a href=&quot;https://www.cnblogs.com/wuhairui/p/10367620.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/wuhairui/p/10367620.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;首先我们来学习下react的&lt;span&gt;生命周期（钩子）&lt;/span&gt;函数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;什么是react生命周期呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;就是指react组件执行时在某个特定的时间点自动调用执行的函数。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ES5&lt;/strong&gt;传统&lt;strong&gt;创建&lt;/strong&gt;组件方式是这样的：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;getDefaultProps&lt;/span&gt;：设置组件默认的&lt;span&gt;props（属性）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;getInitialState&lt;/span&gt;：设置组件默认的&lt;span&gt;state（状态）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/883015/201903/883015-20190312155223186-1380607036.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;执行顺序是：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/883015/201903/883015-20190312162230252-2020946111.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外，&lt;span&gt;getDefaultProps&lt;/span&gt;函数组件未创建实例时就会被执行。&lt;/p&gt;

&lt;p&gt;除了上面的ES5，还有现在大多数被使用的是&lt;strong&gt;ES6模式&lt;/strong&gt;创建组件。&lt;/p&gt;
&lt;p&gt;以类的方式作为组件，使用的组件就是这个组件类的对象。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;static defaultProps&lt;/span&gt;：设置默认属性&lt;/p&gt;
&lt;p&gt;&lt;span&gt;constructor&lt;/span&gt;：用于设置默认状态 初始化。必须使用&lt;strong&gt;super&lt;/strong&gt;，之后才能使用&lt;strong&gt;this&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/883015/201903/883015-20190312163156768-1687404338.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;执行顺序：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/883015/201903/883015-20190312163535247-155035023.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;componentWillMount&lt;/span&gt;、&lt;span&gt;componentDidMount &lt;/span&gt;这2个生命周期是首次进入页面&lt;span&gt;render&lt;/span&gt;前执行的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/883015/201903/883015-20190312190906852-103698274.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;顺序：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/883015/201903/883015-20190312191001455-381118559.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;componentWillReceiveProps&lt;/span&gt; 是组件的传入&lt;strong&gt;属性&lt;/strong&gt;被&lt;strong&gt;父组件&lt;/strong&gt;修改后执行的：&lt;/p&gt;
&lt;p&gt;接收到父组件传入的新&lt;strong&gt;props&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/883015/201903/883015-20190312191710502-2046286892.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;父组件&lt;/strong&gt;修改传入&lt;span&gt;属性&lt;/span&gt;的方式：&lt;/p&gt;
&lt;p&gt;传入的值是个&lt;span&gt;state&lt;/span&gt;就可以。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/883015/201903/883015-20190312191833717-892779925.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（这是&lt;span&gt;组件通信&lt;/span&gt;的一种方式，属于&lt;span&gt;父子&lt;/span&gt;组件关系的通信，这是&lt;span&gt;父传子&lt;/span&gt;）&lt;/p&gt;

&lt;p&gt;要实现&lt;span&gt;子传父&lt;/span&gt;的话，那&lt;span&gt;父组件&lt;/span&gt;调用&lt;span&gt;子组件&lt;/span&gt;时传个&lt;span&gt;回调函数&lt;/span&gt;获取就可以了&lt;/p&gt;
&lt;p&gt;如：&lt;/p&gt;
&lt;p&gt;这是&lt;strong&gt;父组件render&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/883015/201903/883015-20190312192729831-881714016.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;父组件回调函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/883015/201903/883015-20190312192751958-1274986605.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是&lt;strong&gt;子组件属性被修改&lt;/strong&gt;函数，执行这个回调函数即可执行父组件函数&lt;/p&gt;
&lt;p&gt;这里这么用，父组件传值给子组件后，子组件能立即回调父组件，形成有来有回。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/883015/201903/883015-20190312192817755-1017461993.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击按钮，这里输出111。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;直接子传父的方法：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;父：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/883015/201903/883015-20190312234845452-558568961.png&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;&lt;/p&gt;
&lt;p&gt;子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/883015/201903/883015-20190312234916807-364290298.png&quot; alt=&quot;&quot; width=&quot;700&quot;/&gt;&lt;/p&gt;
&lt;p&gt;父组件传个&lt;span&gt;回调&lt;/span&gt;给子组件，子组件通过&lt;span&gt;this.props&lt;/span&gt;可调用到这个函数，&lt;strong&gt;子就可以传值给父组件&lt;/strong&gt;了。&lt;/p&gt;

</description>
<pubDate>Tue, 12 Mar 2019 15:53:00 +0000</pubDate>
<dc:creator>海瑞菌&amp;#183;博客</dc:creator>
<og:description>这是react项目复习总结第二讲， 第一讲：https://www.cnblogs.com/wuhairui/p/10367620.html 首先我们来学习下react的生命周期（钩子）函数。 什么是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wuhairui/p/10515918.html</dc:identifier>
</item>
<item>
<title>[精华]springMVC环境搭建基础入门总汇! - 吸光地球氧气第一天</title>
<link>http://www.cnblogs.com/wsfighting1218/p/10520439.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wsfighting1218/p/10520439.html</guid>
<description>&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;1.SpringMVC概述&lt;/h3&gt;
&lt;p&gt;             SpringMVC 是一种基于 Java 的实现 MVC 设计模型的请求驱动类型的轻量级 Web 框架，属于 Spring       FrameWork 的后续产品，已经融合在 Spring Web Flow 里面。Spring 框架提供了构建 Web 应用程序的全功 能 MVC 模块。使用 Spring 可插入的 MVC 架构，从而在使用 Spring 进行 WEB 开发时，可以选择使用 Spring 的 Spring MVC 框架或集成其他 MVC 开发框架，如 Struts1(现在一般不用)，Struts2 等。 SpringMVC 已经成为目前最主流的 MVC 框架之一，并且随着 Spring3.0 的发布，全面超越 Struts2，成 为最优秀的 MVC 框架。 它通过一套注解，让一个简单的 Java 类成为处理请求的控制器，而无须实现任何接口。同时它还支持 RESTful 编程风格的请求。&lt;/p&gt;
&lt;p&gt;      我们的开发架构一般都是基于两种形式，一种是 C/S 架构，也就是客户端/服务器，另一种是 B/S 架构，也就 是浏览器服务器。在 JavaEE 开发中，几乎全都是基于 B/S架构的开发。那么在 B/S架构中，系统标准的三层架构 包括：表现层、业务层、持久层。三层架构在我们的实际开发中使用的非常多，所以我们课程中的案例也都是基于三层架构设计的。 三层架构中，每一层各司其职，接下来我们就说说每层都负责哪些方面： 表现层：  也就是我们常说的web层。它负责接收客户端请求，向客户端响应结果，通常客户端使用http协议请求 web 层，web 需要接收 http 请求，完成 http 响应。  表现层包括展示层和控制层：控制层负责接收请求，展示层负责结果的展示。  表现层依赖业务层，接收到客户端请求一般会调用业务层进行业务处理，并将处理结果响应给客户端。  表现层的设计一般都使用 MVC 模型。（MVC 是表现层的设计模型，和其他层没有关系） 业务层：  也就是我们常说的 service 层。它负责业务逻辑处理，和我们开发项目的需求息息相关。web 层依赖业 务层，但是业务层不依赖 web 层。  业务层在业务处理时可能会依赖持久层，如果要对数据持久化需要保证事务一致性。（也就是我们说的， 事务应该放到业务层来控制） 持久层：  也就是我们是常说的 dao 层。负责数据持久化，包括数据层即数据库和数据访问层，数据库是对数据进 行持久化的载体，数据访问层是业务层和持久层交互的接口，业务层需要通过数据访问层将数据持久化到数据库&lt;br/&gt;中。通俗的讲，持久层就是和数据库交互，对数据库表进行曾删改查的。&lt;/p&gt;
&lt;p&gt;MVC 全名是 Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写， 是一种用于设计创建 Web 应用程序表现层的模式。MVC 中每个部分各司其职：  Model（模型）：   通常指的就是我们的数据模型。作用一般情况下用于封装数据。  View（视图）：   通常指的就是我们的 jsp 或者 html。作用一般就是展示数据的。   通常视图是依据模型数据创建的。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt; Controller（控制器）：   是应用程序中处理用户交互的部分。作用一般就是处理程序逻辑的。   它相对于前两个不是很好理解，这里举个例子：   例如：    我们要保存一个用户的信息，该用户信息中包含了姓名，性别，年龄等等。    这时候表单输入要求年龄必须是 1~100 之间的整数。姓名和性别不能为空。并且把数据填充 到模型之中。    此时除了 js 的校验之外，服务器端也应该有数据准确性的校验，那么校验就是控制器的该做 的。    当校验失败后，由控制器负责把错误页面展示给使用者。    如果校验成功，也是控制器负责把数据填充到模型，并且调用业务层实现完整的业务需求。&lt;/p&gt;

&lt;h3&gt;2.SpringMVC的环境搭建&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;楼主喜欢用idea ,此文中是在idea工程中创建maven项目 ,在创建页面中选择webapp 点击next即可!如图....&lt;/li&gt;
&lt;li readability=&quot;-0.5&quot;&gt;工程创建好了以后需要导入在pom.xml依赖  代码如下   ....导包过程中可能出现一些小问题  把maven仓库里面相关的jar包文件夹缓存删了就行 idea在联网中会自动重新下载.&lt;br/&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
  &amp;lt;properties&amp;gt;
        &amp;lt;project.build.sourceEncoding&amp;gt;UTF-&lt;span&gt;8&lt;/span&gt;&amp;lt;/project.build.sourceEncoding&amp;gt;
        &amp;lt;maven.compiler.source&amp;gt;&lt;span&gt;1.8&lt;/span&gt;&amp;lt;/maven.compiler.source&amp;gt;
        &amp;lt;maven.compiler.target&amp;gt;&lt;span&gt;1.8&lt;/span&gt;&amp;lt;/maven.compiler.target&amp;gt;
        &amp;lt;spring.version&amp;gt;&lt;span&gt;5.0&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;.RELEASE&amp;lt;/spring.version&amp;gt;
    &amp;lt;/properties&amp;gt;

    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;&lt;span&gt;4.11&lt;/span&gt;&amp;lt;/version&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-context&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${spring.version}&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-web&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${spring.version}&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-webmvc&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${spring.version}&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;javax.servlet&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;servlet-api&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;&lt;span&gt;2.5&lt;/span&gt;&amp;lt;/version&amp;gt;
            &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;javax.servlet.jsp&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;jsp-api&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;&lt;span&gt;2.0&lt;/span&gt;&amp;lt;/version&amp;gt;
            &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;


    &amp;lt;/dependencies&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-0.5&quot;&gt;依赖弄好了以后  ,我们需要在webapp文件下的web.xml中配置 springMVC的核心容器DispatcherServlet 代码如下
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; encoding=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;?&amp;gt;
&amp;lt;web-app xmlns=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://xmlns.jcp.org/xml/ns/javaee&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
         xmlns:xsi&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.w3.org/2001/XMLSchema-instance&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
         xsi:schemaLocation&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
         version&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;3.1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;!--配置核心控制器DispatcherServlet--&amp;gt;
  &amp;lt;servlet&amp;gt;
      &amp;lt;servlet-name&amp;gt;dispatcherServlet&amp;lt;/servlet-name&amp;gt;
      &amp;lt;servlet-&lt;span&gt;class&lt;/span&gt;&amp;gt;org.springframework.web.servlet.DispatcherServlet&amp;lt;/servlet-&lt;span&gt;class&lt;/span&gt;&amp;gt;

      &amp;lt;!--配置servlet初始化参数  读取springmvc配置文件   创建spring容器--&amp;gt;
      &amp;lt;init-param&amp;gt;
          &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt;
          &amp;lt;param-value&amp;gt;classpath:springmvc.xml&amp;lt;/param-value&amp;gt;
      &amp;lt;/init-param&amp;gt;

      &amp;lt;!--配置 servlet启动时的加载对象   --&amp;gt;
      &amp;lt;load-on-startup&amp;gt;&lt;span&gt;1&lt;/span&gt;&amp;lt;/load-on-startup&amp;gt;
  &amp;lt;/servlet&amp;gt;


        &amp;lt;!--配置servlet映射信息--&amp;gt;
    &amp;lt;servlet-mapping&amp;gt;
        &amp;lt;servlet-name&amp;gt;dispatcherServlet&amp;lt;/servlet-name&amp;gt;
        &amp;lt;url-pattern&amp;gt;/&amp;lt;/url-pattern&amp;gt;
    &amp;lt;/servlet-mapping&amp;gt;

      &amp;lt;!--配置过滤器  解决中文乱码的问题 --&amp;gt;
      &amp;lt;filter&amp;gt;
          &amp;lt;filter-name&amp;gt;characterEncodingFilter&amp;lt;/filter-name&amp;gt;
          &amp;lt;filter-&lt;span&gt;class&lt;/span&gt;&amp;gt;org.springframework.web.filter.CharacterEncodingFilter&amp;lt;/filter-&lt;span&gt;class&lt;/span&gt;&amp;gt;

          &amp;lt;!--指定字符集--&amp;gt;
          &amp;lt;init-param&amp;gt;
              &amp;lt;param-name&amp;gt;encoding&amp;lt;/param-name&amp;gt;
              &amp;lt;param-value&amp;gt;UTF-&lt;span&gt;8&lt;/span&gt;&amp;lt;/param-value&amp;gt;
          &amp;lt;/init-param&amp;gt;
      &amp;lt;/filter&amp;gt;
    &amp;lt;!--配置filter映射信息--&amp;gt;
  &amp;lt;filter-mapping&amp;gt;
      &amp;lt;filter-name&amp;gt;characterEncodingFilter&amp;lt;/filter-name&amp;gt;
      &amp;lt;url-pattern&amp;gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;&amp;lt;/url-pattern&amp;gt;
  &amp;lt;/filter-mapping&amp;gt;


&amp;lt;/web-app&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-0.5&quot;&gt;接下来你需要在项目文件夹src/main/创建java ,resources 两个文件夹分别标记为类文件 资源文件, 加上自带的webapp总共三个  是标准的maven项目  在resources文件下新建springMVC.xml文件添加以下代码
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; encoding=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;?&amp;gt;
&amp;lt;beans xmlns=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.springframework.org/schema/beans&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
       xmlns:mvc&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.springframework.org/schema/mvc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
       xmlns:context&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.springframework.org/schema/context&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
       xmlns:xsi&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.w3.org/2001/XMLSchema-instance&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
       xsi:schemaLocation&lt;/span&gt;=&lt;span&gt;&quot;
&lt;/span&gt;        http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/beans&lt;/span&gt;
        http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/beans/spring-beans.xsd&lt;/span&gt;
        http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/mvc&lt;/span&gt;
        http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/mvc/spring-mvc.xsd&lt;/span&gt;
        http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/context&lt;/span&gt;
        http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/context/spring-context.xsd&quot;&amp;gt;&lt;/span&gt;

       &amp;lt;!--&lt;span&gt;1&lt;/span&gt;.配置spring创建容器时要扫描的包--&amp;gt;
    &amp;lt;context:component-scan &lt;span&gt;base&lt;/span&gt;-package=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;com.ws&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/context:component-scan&amp;gt;

       &amp;lt;!--&lt;span&gt;2&lt;/span&gt;.配置视图解析器--&amp;gt;
    &amp;lt;bean id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;viewResolver&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;org.springframework.web.servlet.view.InternalResourceViewResolver&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
         &amp;lt;!--配置路径--&amp;gt;
        &amp;lt;property name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;prefix&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/WEB-INF/pages/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;!--目标文件格式--&amp;gt;
        &amp;lt;property name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;suffix&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;  value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.jsp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;


    &amp;lt;!--&lt;span&gt;3&lt;/span&gt;.配置spring开启注解mvc 的支持--&amp;gt;
    &amp;lt;mvc:annotation-driven&amp;gt;&amp;lt;/mvc:annotation-driven&amp;gt;





&amp;lt;/beans&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;到这里环境配置就ok了  你需要在index.jsp页面中 引入一个Controller控制器类就大功告成了!&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;入门案例的执行过程分析 1. 入门案例的执行流程 1. 当启动Tomcat服务器的时候，因为配置了load-on-startup标签，所以会创建DispatcherServlet对象， 就会加载springmvc.xml配置文件 2. 开启了注解扫描，那么HelloController对象就会被创建 3. 从index.jsp发送请求，请求会先到达DispatcherServlet核心控制器，根据配置@RequestMapping注解 找到执行的具体方法 4. 根据执行方法的返回值，再根据配置的视图解析器，去指定的目录下查找指定名称的JSP文件 5. Tomcat服务器渲染页面，做出响应 2. SpringMVC官方提供图形&lt;/p&gt;&lt;p&gt;入门案例中的组件分析 1. 前端控制器（DispatcherServlet） 2. 处理器映射器（HandlerMapping） 3. 处理器（Handler） 4. 处理器适配器（HandlAdapter） 5. 视图解析器（View Resolver） 6. 视图（View）&lt;/p&gt;



&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1615889/201903/1615889-20190312231046387-1567482334.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 12 Mar 2019 15:34:00 +0000</pubDate>
<dc:creator>吸光地球氧气第一天</dc:creator>
<og:description>1.SpringMVC概述 SpringMVC 是一种基于 Java 的实现 MVC 设计模型的请求驱动类型的轻量级 Web 框架，属于 Spring FrameWork 的后续产品，已经融合在 Sp</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wsfighting1218/p/10520439.html</dc:identifier>
</item>
<item>
<title>Sketch webView方式插件开发技术总结 - jingwhale</title>
<link>http://www.cnblogs.com/jingwhale/p/10520149.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jingwhale/p/10520149.html</guid>
<description>&lt;p&gt;相信大家都对Sketch有一定的了解和认识。除了基础的矢量设计功能以外，插件更是让Sketch保持强大的独门秘籍。Sketch开放了第三方插件接口，设计师可以在几百种的插件中轻松找到适合自己工作方式的插件，并且他们都非常容易获得和安装。这里主要介绍使用Javascript API for Sketch开发Sketch插件。&lt;/p&gt;

&lt;p&gt;Sketch成为梦想中的“设计师工具箱”。但是每个人都有不同的需求，也许你需要一个我们还没有实现的功能。不要担心：插件已经可以满足您的需求，或者你可以轻松创建一个插件。&lt;/p&gt;

&lt;h3 id=&quot;d3638727&quot;&gt;一、Sketch插件可以做什么？&lt;/h3&gt;
&lt;p&gt;Sketch中的插件可以做任何用户可以做的事情（甚至更多！）。例如：&lt;/p&gt;

&lt;h3&gt; &lt;/h3&gt;
&lt;h3 id=&quot;e9bb7231&quot;&gt;二、插件简介&lt;/h3&gt;
&lt;p&gt;Sketch 插件都是 *.sketchplugin 的形式，其实就是一个文件夹，通过右键显示包内容，可以看到最普通的内部结构式是这样的：&lt;/p&gt;


&lt;p&gt;manifest.json用来声明插件配置信息，commands 定义所有可执行命令，每条 command 有唯一标志符，identifier，menu 定义插件菜单，通过 identifier 关联到执行命令。&lt;/p&gt;
&lt;p&gt;my-commond.js是插件逻辑的实现代码实现文件。&lt;/p&gt;

&lt;h3 id=&quot;a147a6d2&quot;&gt;三、Javascript API for Sketch&lt;/h3&gt;
&lt;p&gt;这是Sketch的原型Javascript API。 原生Javascript，Sketch的完整内部结构的一个易于理解的子集。它仍然是一项正在进行中的工作。&lt;/p&gt;

&lt;p&gt;Javascript API for Sketch 原理：&lt;/p&gt;


&lt;h3 id=&quot;ec057dbf&quot;&gt;四、&lt;a href=&quot;https://developer.sketchapp.com/&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;开发文档&lt;/a&gt;&lt;/h3&gt;
&lt;h4 id=&quot;7c591767&quot;&gt;1、开发文档&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.sketchapp.com/&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;https://developer.sketchapp.com/&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;84df8b40&quot;&gt;2、API&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.sketchapp.com/reference/api/&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;https://developer.sketchapp.com/reference/api/&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;cab71bc4&quot;&gt;3、Demo&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/BohemianCoding/SketchAPI/tree/develop/examples&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;https://github.com/BohemianCoding/SketchAPI/tree/develop/examples&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;e3f38545&quot;&gt;五、&lt;a href=&quot;https://github.com/skpm/sketch-module-web-view&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Sketch webView&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Sketch模块，用于使用webview创建复杂的UI。有别于一般的插件页面，可以使用webview模块加载一个复杂的Web应用，使其与Sketch进行交互。&lt;/p&gt;
&lt;h4 id=&quot;516364d7&quot;&gt;&lt;a href=&quot;https://github.com/skpm/sketch-module-web-view/blob/master/docs/browser-window.md&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;1、BrowserWindow&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;在浏览器窗口中创建和控制Sketch：&lt;/p&gt;
&lt;div data-card-type=&quot;block&quot; data-lake-card=&quot;codeblock&quot; data-card-value=&quot;data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20In%20the%20plugin.%5Cnconst%20BrowserWindow%20%3D%20require('sketch-module-web-view')%5Cn%5Cnlet%20win%20%3D%20new%20BrowserWindow(%7B%20width%3A%20800%2C%20height%3A%20600%20%7D)%5Cnwin.on('closed'%2C%20()%20%3D%3E%20%7B%5Cn%20%20win%20%3D%20null%5Cn%7D)%5Cn%5Cn%2F%2F%20Load%20a%20remote%20URL%5Cnwin.loadURL('https%3A%2F%2Fgithub.com')%5Cn%5Cn%2F%2F%20Or%20load%20a%20local%20HTML%20file%5Cnwin.loadURL(require('.%2Findex.html'))%22%7D&quot; readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; In the plugin.&lt;/span&gt;
const BrowserWindow = require('sketch-module-web-view'&lt;span&gt;)

let win &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; BrowserWindow({ width: 800, height: 600&lt;span&gt; })
win.on(&lt;/span&gt;'closed', () =&amp;gt;&lt;span&gt; {
  win &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;
})

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Load a remote URL&lt;/span&gt;
win.loadURL('https://github.com'&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Or load a local HTML file&lt;/span&gt;
win.loadURL(require('./index.html'))
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;h4 id=&quot;57175759&quot;&gt;&lt;a href=&quot;https://github.com/skpm/sketch-module-web-view/blob/master/docs/web-contents.md&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;2、webContents&lt;/a&gt;&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
const BrowserWindow = require('sketch-module-web-view'&lt;span&gt;)

let win &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; BrowserWindow({ width: 800, height: 1500&lt;span&gt; })
win.loadURL(&lt;/span&gt;'http://github.com'&lt;span&gt;)

let contents &lt;/span&gt;=&lt;span&gt; win.webContents
console.log(contents)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4 id=&quot;5e90c6bb&quot;&gt;&lt;a href=&quot;https://github.com/skpm/sketch-module-web-view/blob/master/docs/communication-plugin-webview.md&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;3、skech与webview的通信&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;1）Sending a message to the WebView from your plugin command&lt;/p&gt;
&lt;p&gt;On the WebView:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
window.someGlobalFunctionDefinedInTheWebview = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(arg) {
  console.log(arg)
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;On the plugin:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;browserWindow.webContents
  .executeJavaScript(&lt;/span&gt;'someGlobalFunctionDefinedInTheWebview(&quot;hello&quot;)'&lt;span&gt;)
  .then(res &lt;/span&gt;=&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; do something with the result&lt;/span&gt;
  })
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2）Sending a message to the plugin from the WebView&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-12&quot;&gt;On the plugin:&lt;/span&gt;&lt;/p&gt;
&lt;div data-card-type=&quot;block&quot; data-lake-card=&quot;codeblock&quot; data-card-value=&quot;data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22var%20sketch%20%3D%20require('sketch')%5Cn%5CnbrowserWindow.webContents.on('nativeLog'%2C%20function(s)%20%7B%5Cn%20%20sketch.UI.message(s)%5Cn%7D)%22%7D&quot; readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; sketch = require('sketch'&lt;span&gt;)

browserWindow.webContents.on(&lt;/span&gt;'nativeLog', &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(s) {
  sketch.UI.message(s)
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-12&quot;&gt;On the webview:&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
window.postMessage('nativeLog', 'Called from the webview'&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; you can pass any argument that can be stringified&lt;/span&gt;
window.postMessage('nativeLog'&lt;span&gt;, {
  a: b,
})

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; you can also pass multiple arguments&lt;/span&gt;
window.postMessage('nativeLog', 1, 2, 3)
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&quot;ce9b1845&quot;&gt;&lt;a href=&quot;https://github.com/jingwhale/sketch-webview-kit&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;六、构建开发工程&lt;/a&gt;&lt;/h3&gt;
&lt;h4 id=&quot;cd461fda&quot;&gt;1、确立技术栈&lt;/h4&gt;
&lt;p&gt;使用&lt;a href=&quot;https://github.com/skpm/sketch-module-web-view&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Sketch webView&lt;/a&gt;的方式开发插件。用户通过操作插件界面，webview与Sketch通信解决用户的问题。这样插件界面可以使用现今所有的前端框架与组件库。&lt;/p&gt;
&lt;p&gt;1）&lt;a href=&quot;https://github.com/skpm/sketch-module-web-view&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;webView&lt;/a&gt;框架选择&lt;a href=&quot;https://umijs.org/zh/guide/&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Umi &lt;/a&gt;+ &lt;a href=&quot;https://ant.design/index-cn&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Ant Design&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;注：WebView框架也可以单独的工程与部署。&lt;/p&gt;

&lt;p&gt;2）使用Sketch 官方skpm穿件插件工程&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/skpm/sketch-dev-tools&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;3）调试工具&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;A、使用官方的&lt;a href=&quot;https://github.com/skpm/sketch-dev-tools&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;sketch-dev-tools&lt;/a&gt; sketch内作为调试工具&lt;/p&gt;
&lt;p&gt;下载代码，代码运行安装插件即可：&lt;/p&gt;
&lt;div data-card-type=&quot;block&quot; data-lake-card=&quot;codeblock&quot; data-card-value=&quot;data:%7B%22mode%22%3A%22plain%22%2C%22code%22%3A%22npm%20install%5Cnnpm%20run%20build%22%7D&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;npm install
npm run build&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;B、使用浏览器的开发者模式调试&lt;a href=&quot;https://github.com/skpm/sketch-module-web-view&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;webView&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在sketch webView中右击显示调试器即可：&lt;/p&gt;


&lt;h4 id=&quot;4b61ba56&quot;&gt;2、构建工程&lt;/h4&gt;
&lt;p&gt;1)创建Sketch插件基础工程&lt;/p&gt;
&lt;p&gt;首先，创建sketch-webview-kit插件工程：&lt;/p&gt;
&lt;div data-card-type=&quot;block&quot; data-lake-card=&quot;codeblock&quot; data-card-value=&quot;data:%7B%22mode%22%3A%22bash%22%2C%22code%22%3A%22npm%20install%20-g%20skpm%5Cnskpm%20create%20sketch-webview-kit%20%2F%2F%E5%88%9B%E5%BB%BAsketch-webview-kit%E6%8F%92%E4%BB%B6%E5%B7%A5%E7%A8%8B%22%7D&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
npm install -&lt;span&gt;g skpm
skpm create sketch&lt;/span&gt;-webview-kit &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建sketch-webview-kit插件工程&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;其次，依赖sketch-module-web-view：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
npm install sketch-module-web-view
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2）创建webView工程（&lt;a href=&quot;https://umijs.org/zh/guide/&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Umi &lt;/a&gt;+ &lt;a href=&quot;https://ant.design/index-cn&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Ant Design&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;首先，创建webView工程目录，&lt;/p&gt;
&lt;div data-card-type=&quot;block&quot; data-lake-card=&quot;codeblock&quot; data-card-value=&quot;data:%7B%22mode%22%3A%22bash%22%2C%22code%22%3A%22%24%20mkdir%20webapp%20%26%26%20cd%20webapp%22%7D&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$ mkdir webapp &amp;amp;&amp;amp; cd webapp
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;然后，创建webView工程&lt;/p&gt;
&lt;div data-card-type=&quot;block&quot; data-lake-card=&quot;codeblock&quot; data-card-value=&quot;data:%7B%22mode%22%3A%22bash%22%2C%22code%22%3A%22yarn%20create%20umi%22%7D&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
yarn create umi
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;依次：&lt;/p&gt;
&lt;p&gt;选择 app, 然后回车确认；&lt;/p&gt;
&lt;p&gt;选上 antd 和 dva，然后回车确认；&lt;/p&gt;

&lt;p&gt;最后，安装依赖：&lt;/p&gt;

&lt;p&gt;3）配置webView工程&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://umijs.org/zh/guide/deploy.html#%E9%9D%99%E6%80%81%E5%8C%96&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;A.部署打包配置&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.umirc.js文件中，添加：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
outputPath:'../src/dist', &lt;span&gt;//&lt;/span&gt;&lt;span&gt;打包后的目录&lt;/span&gt;
&lt;span&gt;exportStatic: {
  dynamicRoot: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;静态自由部署&lt;/span&gt;
},
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://umijs.org/zh/guide/html-template.html&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;B.HTML 模板&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;由于Umi生成没有Html文件，可以自己配置。新建 src/pages/document.ejs，umi 约定如果这个文件存在，会作为默认模板，内容上需要保证有 &amp;lt;div id=&quot;root&quot;&amp;gt;&amp;lt;/div&amp;gt;，比如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;doctype html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;utf-8&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Your App&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;root&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;0d10ca43&quot;&gt;3、sketch加载webView工程与联调&lt;/h4&gt;
&lt;p&gt;1）sketch加载webView&lt;/p&gt;
&lt;p&gt;第一种方法：&lt;/p&gt;
&lt;p&gt;直接部署webView工程，通过Url加载：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
win.loadURL('https://github.com')
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第二种方法：&lt;/p&gt;
&lt;p&gt;加载webView工程打包后的文件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
win.loadURL(require('./dist/index.html'))
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;注意：&lt;/p&gt;
&lt;p&gt;此方法，由umi打包后的静态资源（css、js）需要拷贝到&lt;/p&gt;
&lt;p&gt;pannel3/pannel3.sketchplugin/Contents/Resources/_webpack_resources下。&lt;/p&gt;

&lt;p&gt;2）联调加载方法：&lt;/p&gt;
&lt;p&gt;本地启动webView工程，本地webView工程会在8000端口起一个服务，加载此服务即可：&lt;/p&gt;
&lt;div data-card-type=&quot;block&quot; data-lake-card=&quot;codeblock&quot; data-card-value=&quot;data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22const%20Panel%20%3D%20%60http%3A%2F%2Flocalhost%3A8000%23%24%7BMath.random()%7D%60%3B%5Cnwin.loadURL(Panel)%22%7D&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
const Panel = `http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:8000#${Math.random()}`;&lt;/span&gt;
win.loadURL(Panel)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;h4 id=&quot;2116864a&quot;&gt;&lt;a href=&quot;https://github.com/jingwhale/sketch-webview-kit&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;4、项目成果&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;文件目录如下：&lt;/p&gt;

&lt;h3 id=&quot;97c045b5&quot;&gt;七、拓展&lt;/h3&gt;
&lt;h4 id=&quot;ac71f360&quot;&gt;&lt;a href=&quot;https://www.yuque.com/jingwhale/blog/rt5aci&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;1、&lt;/a&gt;&lt;a href=&quot;https://github.com/airbnb/react-sketchapp&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;React - SketchApp &lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;是一个开源库，为设计系统量身定制。它通过将 React 元素渲染到 Sketch 来连接设计和开发之间的鸿沟。&lt;/p&gt;
&lt;p&gt;Sketch Javascript API 是源生代码，React - SketchApp 使用react对Javascript API 进行了二次封装。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://airbnb.io/react-sketchapp/docs/API.html&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;1)API&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://airbnb.io/react-sketchapp/docs/API.html&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;http://airbnb.io/react-sketchapp/docs/API.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.yuque.com/jingwhale/blog/do37mc&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;2)Demo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.yuque.com/jingwhale/blog/do37mc&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;https://www.yuque.com/jingwhale/blog/do37mc&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 12 Mar 2019 15:33:00 +0000</pubDate>
<dc:creator>jingwhale</dc:creator>
<og:description>首发：https://www.yuque.com/jingwhale/blog/rt5aci 相信大家都对Sketch有一定的了解和认识。除了基础的矢量设计功能以外，插件更是让Sketch保持强大的独</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jingwhale/p/10520149.html</dc:identifier>
</item>
<item>
<title>逻辑回归损失函数推导 - shayue111</title>
<link>http://www.cnblogs.com/shayue/p/10520414.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shayue/p/10520414.html</guid>
<description>&lt;h2 id=&quot;引言&quot;&gt;引言&lt;/h2&gt;
&lt;p&gt;假设今天希望将机器学习应用到医院中去，比如对于某一个患了心脏病的病人，求他3个月之后病危的概率。那么我们该选择哪一个模型，或者可以尝试已经学过的线性回归？&lt;/p&gt;
&lt;p&gt;但是很遗憾的是，如果我们要利用线性回归，我们收集到的资料中应当包含病人3个月后病危的概率。这在实际中是很难得到的，因为对于一个患病的病人，你只能知道他3个月后到底是病危或者存活。所以线性回归并不适用这种场景。&lt;/p&gt;
&lt;h2 id=&quot;logistic函数&quot;&gt;logistic函数&lt;/h2&gt;
&lt;p&gt;上面提到我们最终的目标是一个概率值&lt;span class=&quot;math inline&quot;&gt;\(P(y|x)\)&lt;/span&gt;，这里&lt;span class=&quot;math inline&quot;&gt;\(y=+1\)&lt;/span&gt;指代病人3个月后病危这个事件;&lt;span class=&quot;math inline&quot;&gt;\(y=-1\)&lt;/span&gt;指代病人3个月后存活这个事件。显然&lt;span class=&quot;math inline&quot;&gt;\(P(-1|x) = 1 - P(1|x)\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;我们先前学过线性回归，知道可以通过加权的方式求出各项特征的'分数'，那这个分数怎么转换为一个概率值？这里就需要引入一个logistic函数。它的表达式为：&lt;span class=&quot;math display&quot;&gt;\[ \theta(s)=\frac{1}{1+e^{-s}} \]&lt;/span&gt;&lt;br/&gt;它的图像如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1531067/201903/1531067-20190312232659084-1342501547.png&quot; height=&quot;50%&quot; width=&quot;50%&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到这个函数有十分不错的性质：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(\theta(-∞)=0, \ \theta(+∞)=1\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(1-\theta(s)=\theta(-s)\)&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;也就是说我们可以把加权得到的'分数'通过logistic函数转化为一个概率值，并且加权得到的'分数'越大，这个概率值也越大。这真的还蛮有道理的。&lt;/p&gt;
&lt;p&gt;好了，我们的模型已经定义完毕了，称它为逻辑回归模型：&lt;span class=&quot;math display&quot;&gt;\[ \begin{equation} h(x) = \frac{1}{1+e^{-w^Tx}} \ \ \ \ \ w,x都是向量 \end{equation} \]&lt;/span&gt;&lt;br/&gt;也就是说，我们获取到一个病人的特征&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;，将它输入模型，就能知晓这个病人3个月后病危的概率。但是，还有最重要的一步，这个模型的参数&lt;span class=&quot;math inline&quot;&gt;\(w\)&lt;/span&gt;如何确定？不同的参数&lt;span class=&quot;math inline&quot;&gt;\(w\)&lt;/span&gt;会带来不同的模型&lt;span class=&quot;math inline&quot;&gt;\(h(x)\)&lt;/span&gt;.经验告诉我们可以从已获得的资料中找到一些端倪获取最合适的&lt;span class=&quot;math inline&quot;&gt;\(w\)&lt;/span&gt;。&lt;/p&gt;
&lt;h2 id=&quot;损失函数&quot;&gt;损失函数&lt;/h2&gt;
&lt;p&gt;线性回归中，我们定义了一个平方损失函数，通过对损失函数求导数得到最后的参数。那依样画葫芦，我们也为逻辑回归定义一个损失函数，然后试着对损失函数求梯度，是不是能解出最后的参数了。那么想一下，逻辑回归的损失函数如何定义？还用最小二乘法么？这显然不符合场景，毕竟已有的资料只告诉我们每一组数据对应的结果是哪一类的。&lt;/p&gt;
&lt;p&gt;我们还是从数据的产生来分析，现在已有的数据是这些：&lt;span class=&quot;math display&quot;&gt;\[ D = {(x_1, 1), (x_2, 1), (x_3, 1), ... , (x_n, -1)} \]&lt;/span&gt;&lt;br/&gt;当然，这些数据的产生是相互独立的，所以获得&lt;span class=&quot;math inline&quot;&gt;\(D\)&lt;/span&gt;这笔资料的概率就是&lt;span class=&quot;math display&quot;&gt;\[ \begin{equation} P(x_1, 1) * P(x_2, 1) * P(x_3, 1) * ... * P(x_n, -1) \end{equation}\]&lt;/span&gt;&lt;br/&gt;再将(2)式写为条件概率分布&lt;span class=&quot;math display&quot;&gt;\[ \begin{equation} P(x_1)P(1|x_1) * P(x_2)P(1|x_2) * P(x_3)P(1|x_3) * ... * P(x_n)P(-1|x_n) \end{equation}\]&lt;/span&gt;&lt;br/&gt;再者，假设每一笔数据的产生服从0-1分布。&lt;span class=&quot;math display&quot;&gt;\[\begin{equation} P(y|x_i) = \left \{ \begin{array}{lr} f(x_i) \ \ \ \ \ \ \ \ \ \ y=+1 \\ 1 - f(x_i) \ \ \ \ \ y=-1 \end{array} \right. \end{equation}\]&lt;/span&gt;&lt;br/&gt;所以最后写成的形式：&lt;span class=&quot;math display&quot;&gt;\[\begin{equation} P(x_1)f(x_1) * P(x_2)f(x_2) * P(x_3)f(x_3) * ... * P(x_n)(1-f(x_n)) \end{equation}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;也就说这笔资料&lt;span class=&quot;math inline&quot;&gt;\(D\)&lt;/span&gt;由真正的模型&lt;span class=&quot;math inline&quot;&gt;\(f(x)\)&lt;/span&gt;产生的话，概率是(5)这么大。但是我们不知道真正的模型f(x)长什么样子，我们现在只知道我们自己定义了一个模型&lt;span class=&quot;math inline&quot;&gt;\(h(x)\)&lt;/span&gt;，它长成(1)这个样子。所以现在的任务就是从很多的&lt;span class=&quot;math inline&quot;&gt;\(h(x)_1, h(x)_2, h(x)_3, ..., h(x)_m\)&lt;/span&gt;中找到其中一个最接近真正的模型&lt;span class=&quot;math inline&quot;&gt;\(f(x)\)&lt;/span&gt;并将它作为我们最后的&lt;span class=&quot;math inline&quot;&gt;\(h(x)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;所以如何衡量&lt;span class=&quot;math inline&quot;&gt;\(h(x)\)&lt;/span&gt;与&lt;span class=&quot;math inline&quot;&gt;\(f(x)\)&lt;/span&gt;的接近程度？如果我们现在用&lt;span class=&quot;math inline&quot;&gt;\(h(x)\)&lt;/span&gt;代替&lt;span class=&quot;math inline&quot;&gt;\(f(x)\)&lt;/span&gt;去产生这组数据集&lt;span class=&quot;math inline&quot;&gt;\(D\)&lt;/span&gt;也能得到一个概率(6).&lt;span class=&quot;math display&quot;&gt;\[\begin{equation} P(x_1)h(x_1) * P(x_2)h(x_2) * P(x_3)h(x_3) * ... * P(x_n)(1-h(x_n)) \end{equation}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;使得(6)式的概率最大的那个&lt;span class=&quot;math inline&quot;&gt;\(h(x)\)&lt;/span&gt;我们会认为它与&lt;span class=&quot;math inline&quot;&gt;\(f(x)\)&lt;/span&gt;最相似，这就是最大似然的思想。&lt;/strong&gt;&lt;/span&gt;又因为对于所有的&lt;span class=&quot;math inline&quot;&gt;\(h(x)_i\)&lt;/span&gt;产生的概率：&lt;span class=&quot;math display&quot;&gt;\[\begin{equation} P(x_1) * P(x_2) * P(x_3) * ... * P(x_n) \end{equation}\]&lt;/span&gt;&lt;br/&gt;这部分都是相同的，所以我们认为最接近&lt;span class=&quot;math inline&quot;&gt;\(f(x)\)&lt;/span&gt;的&lt;span class=&quot;math inline&quot;&gt;\(h(x)\)&lt;/span&gt;能使(8)最大即可&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\begin{equation} h(x_1) * h(x_2) * h(x_3) * ... * (1-h(x_n)) \end{equation}\]&lt;/span&gt;&lt;br/&gt;再由于logistic函数的第2个性质，可以将(8)变形：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\begin{equation} h(x_1) * h(x_2) * h(x_3) * ... * h(-x_n) \end{equation}\]&lt;/span&gt;&lt;br/&gt;最终的目标是解出下面这个优化问题：&lt;span class=&quot;math display&quot;&gt;\[\begin{equation} \mathop{max}\limits_{w} \ \ \prod_{i=1}^{n}h(y_ix_i) \end{equation}\]&lt;/span&gt;&lt;br/&gt;再次变形，求一个式子的最大值，相当于求它相反数的最小：&lt;span class=&quot;math display&quot;&gt;\[\begin{equation} \mathop{min}\limits_{w} \ \ -\prod_{i=1}^{n}h(y_ix_i) \end{equation}\]&lt;/span&gt;&lt;br/&gt;接下来我们要对(11)式取对数，一方面原因是因为对数函数的单调特性，另一方面是能将原来的连乘简化到连加，所以取对数后：&lt;span class=&quot;math display&quot;&gt;\[\begin{equation} \mathop{min}\limits_{w} \ \ -\sum_{i=1}^{n}\ln{h(y_ix_i)} \end{equation}\]&lt;/span&gt;&lt;br/&gt;将&lt;span class=&quot;math inline&quot;&gt;\(h(x)\)&lt;/span&gt;展开，能得到&lt;span class=&quot;math display&quot;&gt;\[\begin{equation} \mathop{min}\limits_{w} \ \ -\sum_{i=1}^{n}\ln{\frac{1}{1+e^{-y_iw^Tx_i}}} \ \ \ \ \ \ \ \ \ \ w与x_i都是向量,x_i表示第i笔数据 \end{equation}\]&lt;/span&gt;&lt;br/&gt;再一次&lt;span class=&quot;math display&quot;&gt;\[\begin{equation} \mathop{min}\limits_{w} \ \ \sum_{i=1}^{n}\ln{(1+e^{-y_iw^Tx_i})} \ \ \ \ \ \ \ \ \ \ w与x_i都是向量,x_i表示第i笔数据 \end{equation}\]&lt;/span&gt;&lt;br/&gt;大功告成，我们得到了逻辑回归的损失函数,它长成(15)式这个样子&lt;span class=&quot;math display&quot;&gt;\[\begin{equation} J(w)= \sum_{i=1}^{n}\ln{(1+e^{-y_iw^Tx_i})} \ \ \ \ \ \ \ \ \ \ w与x_i都是向量,x_i表示第i笔数据 \end{equation}\]&lt;/span&gt;&lt;br/&gt;我们的目标就是找到最小化&lt;span class=&quot;math inline&quot;&gt;\(J(w)\)&lt;/span&gt;的那个&lt;span class=&quot;math inline&quot;&gt;\(w\)&lt;/span&gt;.就像在线性回归中做的那样，接下来我们要利用链式法则对它求导：&lt;span class=&quot;math display&quot;&gt;\[\begin{equation} \frac{\partial J(w)}{\partial w_j} = \sum_{i=1}^{n}\frac{\partial \ln{(1+e^{-y_iw^Tx_i})}}{\partial (-y_iw^Tx_i)} * \frac{\partial (-y_iw^Tx_i)}{\partial w_j} \end{equation}\]&lt;/span&gt;&lt;br/&gt;化解得到&lt;span class=&quot;math display&quot;&gt;\[\begin{equation} \frac{\partial J(w)}{\partial w_j} = \sum_{i=1}^{n}\frac{e^{-y_iw^Tx_i}}{1+e^{-y_iw^Tx_i}} * (-y_ix_{i,j}) \ \ \ \ x_{i,j}是个标量，是第i笔数据中第j个分量 \end{equation}\]&lt;/span&gt;&lt;br/&gt;所以对于整个向量&lt;span class=&quot;math inline&quot;&gt;\(w\)&lt;/span&gt;的梯度为&lt;span class=&quot;math display&quot;&gt;\[ \begin{equation} \frac{\partial J(w)}{\partial w} = \sum_{i=1}^{n}\frac{e^{-y_iw^Tx_i}}{1+e^{-y_iw^Tx_i}} * (-y_ix_i) \ \ \ \ 想象将对单个w_i的结果笔直堆成一个向量 \end{equation}\]&lt;/span&gt;&lt;br/&gt;而&lt;span class=&quot;math inline&quot;&gt;\(\frac{e^{-y_iww^Tx_i}}{1+e^{-y_iww^Tx_i}}\)&lt;/span&gt;正好是逻辑回归函数，所以最终对&lt;span class=&quot;math inline&quot;&gt;\(w\)&lt;/span&gt;的梯度写成下面这个样子&lt;span class=&quot;math display&quot;&gt;\[ \begin{equation} \frac{\partial J(w)}{\partial w} = \sum_{i=1}^{n}h(-y_iw^Tx_i)(-y_ix_i) \end{equation}\]&lt;/span&gt;&lt;br/&gt;很遗憾，我们令(19)等于0的话，很难求解出&lt;span class=&quot;math inline&quot;&gt;\(w\)&lt;/span&gt;。为此，我们需要用额外的方法求解这个问题。&lt;/p&gt;
&lt;h2 id=&quot;梯度下降&quot;&gt;梯度下降&lt;/h2&gt;
&lt;p&gt;这个可学习的资料太多了，思想就是假设函数上有一个点，它沿着各个方向都有它的方向导数，那么总是沿着方向导数最大的反方向走，也就是梯度的反方向走，这个点总是能走到最低点。每一次移动的距离用一个系数lr来表示，每次更新&lt;span class=&quot;math inline&quot;&gt;\(w\)&lt;/span&gt;，数次迭代之后，&lt;span class=&quot;math inline&quot;&gt;\(w\)&lt;/span&gt;趋近于最优解：&lt;span class=&quot;math display&quot;&gt;\[ \begin{equation} w_{i+1} := w_{i} - lr * \sum_{i=1}^{n}\frac{e^{-y_iw^Tx_i}}{1+e^{-y_iw^Tx_i}} * (-y_ix_i) \ \ \ \ \ lr是大于0的系数 \end{equation}\]&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 12 Mar 2019 15:28:00 +0000</pubDate>
<dc:creator>shayue111</dc:creator>
<og:description>引言 假设今天希望将机器学习应用到医院中去，比如对于某一个患了心脏病的病人，求他3个月之后病危的概率。那么我们该选择哪一个模型，或者可以尝试已经学过的线性回归？ 但是很遗憾的是，如果我们要利用线性回归</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shayue/p/10520414.html</dc:identifier>
</item>
<item>
<title>连载《一个程序猿的生命周期》-《发展篇》- 26.且听风吟，静待花开，慢慢走向人生赢家 - 一个程序猿的生命周期</title>
<link>http://www.cnblogs.com/blog470130547/p/10520408.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/blog470130547/p/10520408.html</guid>
<description>&lt;p&gt;&lt;span&gt;       昨天一早感觉天气很好，完全没有上班的意愿。上午赶到公司处理一些无关紧要的事儿，于是乎下午带着大宝去八大处爬山，在感受自然风光的同时想到一句话：且听风吟，静待花开。&lt;strong&gt;在人生过程中所做出的努力，也需要静静等待开花结果，不过等待是一件很痛苦的事&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/691334/201903/691334-20190312232349127-460146250.png&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;       从去年9月份开始很少在公司，基本上一直处于出差状态，一般是周五晚上回京、周日晚上出差，关键时期周末搭进去了。正值项目推进困难、攻坚克难的时候，老婆怀二宝已经有27周了。&lt;strong&gt;如果说用户和公司层面都认为你是项目具体负责执行的最佳人选，请问还有其他的选择余地吗？&lt;/strong&gt;已经执行两个多月的项目，半路接手后给我的感觉是别人都在退缩，为有牺牲多壮志，鬼才知道日月能否换新天。正式上岗见用户执行负责人时，用户说：你来了呀（大意），我调侃道：我只是来陪葬的。见大领导的时候，让我介绍自己的履历。据听说他们不止一次辞去乙方项目经理了，所以不管是对公司还是对个人来讲都是极大的挑战。这个项目，陆续在外面漂了将近三个月，项目基本上走向正轨，受用户和公司的恩赐，现在安心在家陪护待产。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       在很多公司和家庭的事情都需要你处理的时候，感觉到莫名的烦躁，甚至不想说一句话。由于项目执行的困难，技术的问题、做事合理性的问题、思维方式的问题等等，很严厉的批评过团队的人员，但是都是以事实为依据。人生要适时做出改变，不仅我要改变，他们也必须改变。就像上篇文章写的：&lt;strong&gt;生活中有很多角色，平民、老公、父亲、员工、部门经理、项目经理......，一个人成熟的标准是在众多角色之间平滑转换，就像开车换档没有顿挫感。但是，很难界定众多角色中哪个是主角，而每个角色又要尽可能到位&lt;/strong&gt;。有的人甚至连一个孩子都不要，理由是有困难、没条件......等等，&lt;strong&gt;人无法主动改变自己是内心对自己的恐惧，你怎么知道别人就没有困难、别人就比自己的条件好呢。改变自己而做事，基本上都属于能力不所及，这样人生经历才有很大收获&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       今天用户发来信息：&lt;strong&gt;到底是你带出来的兵，就是不一样&lt;/strong&gt;！人的能力有多大差别呢，首先就是思想问题，其次就是发展方向问题，解决好这两个问题，都有用武之地。我始终相信人是可以改造的，否则革命怎么才能成功呢！我也承认有很多问题需要解决，但是本着惩前毖后、治病救人的原则，实在救治不了癌症，也只能相互放弃了。总体气氛比较和谐，他们有时候也在批评我：情商太低、也不写代码、也不帮着解决问题......，也在调侃：每个开完会落脚点都强调找对象的事......！我感觉和谐的趋势是好的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      从八大处下来的时候，看属相时运：今年犯小人、身体不佳......。从去年底开始，确实身体不太好，但是现在有所好转。二宝降临后，更要求有一个强健的身体。&lt;/span&gt;&lt;/p&gt;
&lt;div&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/691334/201903/691334-20190312232446614-460773808.png&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;&lt;hr/&gt;&lt;div&gt;
&lt;div&gt;
&lt;div&gt;
&lt;div readability=&quot;6.241134751773&quot;&gt;
&lt;div readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一个程序猿的生命周期 微信平台&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;口   号：职业交流，职业规划；面对现实，用心去交流、感悟。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;公众号：iterlifetime&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;strong&gt;百木-ITer职业交流奋斗 群：141588103&lt;/strong&gt;   &lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二维码：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/691334/201606/691334-20160618075950167-974887453.jpg&quot; alt=&quot;&quot; width=&quot;120&quot; height=&quot;120&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;

</description>
<pubDate>Tue, 12 Mar 2019 15:27:00 +0000</pubDate>
<dc:creator>一个程序猿的生命周期</dc:creator>
<og:description>昨天一早感觉天气很好，完全没有上班的意愿。上午赶到公司处理一些无关紧要的事儿，于是乎下午带着大宝去八大处爬山，在感受自然风光的同时想到一句话：且听风吟，静待花开。在人生过程中所做出的努力，也需要静静等</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/blog470130547/p/10520408.html</dc:identifier>
</item>
<item>
<title>C++_类和对象 - 鲸90830</title>
<link>http://www.cnblogs.com/whale90830/p/10520364.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/whale90830/p/10520364.html</guid>
<description>&lt;blockquote&gt;
&lt;p&gt;OOP第二课&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;1 类的构成
&lt;ul&gt;&lt;li&gt;1.1 从结构到类&lt;/li&gt;
&lt;li&gt;1.2 类的构成&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;2 成员函数的声明
&lt;ul&gt;&lt;li&gt;2.1 普通成员函数形式&lt;/li&gt;
&lt;li&gt;2.2 将成员函数以内联函数的形式进行说明&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;3 对象的定义和使用
&lt;ul&gt;&lt;li&gt;3.1 对象的定义&lt;/li&gt;
&lt;li&gt;3.2 对象中成员的访问&lt;/li&gt;
&lt;li&gt;3.3 类成员的访问属性&lt;/li&gt;
&lt;li&gt;3.4 类中成员的访问方式&lt;/li&gt;
&lt;li&gt;3.5 对象赋值语句&lt;/li&gt;
&lt;li&gt;3.6 类的作用域&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;类（class）是面向对象程序设计的最基本的概念，是C++最强有力的特征，是进行封装和数据隐藏的工具，它将一个数据结构与一个操作集紧密地结合起来。类对象是类的实例，用类对象模拟现实世界中的事物比用数据对象更确切。&lt;/p&gt;
&lt;h2 id=&quot;类的构成&quot;&gt;1. 类的构成&lt;/h2&gt;
&lt;h3 id=&quot;从结构到类&quot;&gt;1.1 从结构到类&lt;/h3&gt;
&lt;p&gt;结构是C的一种自定义的数据类型，它把相关联的数据元素组成一个单独的统一体。&lt;/p&gt;
&lt;h5 id=&quot;例2.1有关日期结构的例子&quot;&gt;例2.1有关日期结构的例子&lt;/h5&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;iostream.h&amp;gt;
struct Date {
    int year;
    int month;
    int day;
};
int main()
{
    Date date1;
    date1.year=2003;
    date1.month=8;
    date1.day=25;
    cout&amp;lt;&amp;lt;date1.year&amp;lt;&amp;lt;&quot;.&quot;&amp;lt;&amp;lt;date1.month&amp;lt;&amp;lt;&quot;.&quot;
    &amp;lt;&amp;lt;date1.day&amp;lt;&amp;lt;endl;
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;class与struct的比较&quot;&gt;⭐class与struct的比较&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;类是C++对C中结构的扩展。&lt;/li&gt;
&lt;li&gt;C语言中的struct是数据成员集合，而C++中的类，则是&lt;strong&gt;数据成员&lt;/strong&gt;和&lt;strong&gt;成员函数&lt;/strong&gt;的集合。&lt;/li&gt;
&lt;li&gt;struct是用户定义的数据类型，是一种构造数据类型。类和struct一样，也是一种用户定义的数据类型，是一种&lt;strong&gt;构造数据类型&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;C结构无法对数据&lt;strong&gt;进行保护和权限控制&lt;/strong&gt;，所以结构中的数据是不安全的。C++中的类将数据和与之相关联的数据封装在一起，形成一个整体，具有良好的外部接口可以防止数据未经授权的访问，提供了模块间的独立性。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;类的构成-1&quot;&gt;1.2 类的构成&lt;/h3&gt;
&lt;p&gt;类的成员分两部分：一部分对应数据的状态，称为&lt;strong&gt;数据成员&lt;/strong&gt;，另一部分为作用于该数据状态的函数，称为&lt;strong&gt;成员函数&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;类声明的一般格式如下:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;class 类名 {
public:
    公有数据成员;
    公有成员函数;
protected:
    保护数据成员;
    保护成员函数;
private:
    私有数据成员;
    私有成员函数;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3个关键字： &lt;code&gt;private&lt;/code&gt;、&lt;code&gt;protected&lt;/code&gt;和&lt;code&gt;public&lt;/code&gt;,称为访问权限关键字。每个关键字下面又都可以有数据成员和成员函数。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;private&lt;/code&gt;部分称为类的私有部分，这一部分的数据成员和成员函数称为类的私有成员。私有成员只能由本类的成员函数访问，而类外部的任何访问都是非法的。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public&lt;/code&gt;部分称为类的公有部分，这部分的数据成员和成员函数称为类的公有成员。公有成员可以由程序中的函数访问，它对外是完全开放的。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;protected&lt;/code&gt;部分称为类的保护部分，这部分的数据成员和成员函数称为类的保护成员。保护成员可以由本类的成员函数访问，也可以由本类的派生类的成员函数访问，而类外的任何访问都是非法的。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;注意&quot;&gt;注意：&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;(1) 类声明格式中的3个部分并非一定要全有，但至少要有其中的一个部分。
&lt;ul&gt;&lt;li&gt;一般一个类的&lt;strong&gt;数据&lt;/strong&gt;成员应该声明为&lt;strong&gt;私有&lt;/strong&gt;成员，成员&lt;strong&gt;函数&lt;/strong&gt;声明为&lt;strong&gt;公有&lt;/strong&gt;成员。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;(2) 类声明中的&lt;code&gt;private&lt;/code&gt;、&lt;code&gt;protected&lt;/code&gt;和&lt;code&gt;public&lt;/code&gt;三个关键字可以按任意顺序出现任意次。但是，如果把所有的私有成员、保护成员和公有成员归类放在一起，程序将更加清晰。&lt;/li&gt;
&lt;li&gt;(3) &lt;code&gt;private&lt;/code&gt;处于&lt;strong&gt;类体中第一部分&lt;/strong&gt;时， 关键字&lt;code&gt;private&lt;/code&gt;可以&lt;strong&gt;省略&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;(4) 数据成员可以是任何数据类型，但不能用自动(auto)、寄存器(register)或外部(extern)进行声明。&lt;/li&gt;
&lt;li&gt;(5) &lt;strong&gt;不能在类声明中给数据成员赋值&lt;/strong&gt;。C++规定，只有在类对象定义之后才能给数据成员赋初值&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;用一个类来描述日期,其形式如下:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;class Date {
public:
    void setDate(int y,int m,int d);
    void showDate();
private:
    int m_year;
    int m_month;
    int m_day;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;成员函数的声明&quot;&gt;2. 成员函数的声明&lt;/h2&gt;
&lt;p&gt;成员函数的声明通常采用以下两种方式:&lt;/p&gt;
&lt;h3 id=&quot;普通成员函数形式&quot;&gt;2.1 普通成员函数形式&lt;/h3&gt;
&lt;p&gt;即在类的声明中只给出成员函数的原型，而成员函数体写在类的外部。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;返回类型 成员函数 (参数列表);&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;类外定义的一般形式是:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;返回类型 类名∷成员函数名(参数表)&lt;br/&gt;{&lt;br/&gt;// 函数体&lt;br/&gt;}&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;例如, 以下是表示坐标点的类Coord的声明&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;class Coord {
public:
    void setCoord (int,int); // 设置坐标点
    int getx(); // 取x坐标点
    int gety(); // 取y坐标点
private:
    int x,y;
};
void Coord∷setCoord(int a,int b){ x=a; y=b;}
int Coord::getx(){ return x;}
int Coord::gety(){ return y;}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;内联函数和外联函数&quot;&gt;内联函数和外联函数&lt;/h4&gt;
&lt;p&gt;类的成员函数可以分为内联函数和外联函数。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;内联函数&lt;/strong&gt;是指那些定义在类体内的成员函数，即该函数的函数体放在类体内。而说明在类体内，定义在类体外的成员函数叫&lt;strong&gt;外联函数&lt;/strong&gt;。外联函数的函数体在类的实现部分。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内联函数&lt;/strong&gt;在调用时不是像一般函数那样要转去执行被调用函数的函数体，执行完成后再转回调用函数中，执行其后语句，而是在调用函数处用内联函数体的代码来替换，这样将会节省调用开销，提高运行速度。&lt;/li&gt;
&lt;li&gt;内联函数与带参数的宏定义进行一下比较，它们的代码效率是一样的，但是内联函数要优于宏定义，因为内联函数遵循函数的类型和作用域规则，它与一般函数更相近，在一些编译器中，一旦关上内联扩展，将与一般函数一样进行调用，调试比较方便。&lt;/li&gt;
&lt;li&gt;外联函数变成内联函数的方法很简单，只要在函&lt;br/&gt;数头前面加上关键字inline就可以了。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;将成员函数以内联函数的形式进行说明&quot;&gt;2.2 将成员函数以内联函数的形式进行说明&lt;/h3&gt;
&lt;p&gt;有两种格式将成员函数声明为类的内联函数:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;（1）&lt;strong&gt;隐式声明&lt;/strong&gt; 直接将函数声明在类内部。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;class Coord{
public:
    void setCoord(int a,int b)
    { x=a; y=b;}
    int getx()
    { return x;}
    int gety()
    { retrun y;}
private:
    int x,y;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;（2）&lt;strong&gt;显式声明&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在类声明中只给出成员函数的原型，而成员函数体写在类的外部。为了使它起内联函数的作用，在成员函数返回类型前冠以关键字“inline”。&lt;/p&gt;
&lt;p&gt;这种成员函数在类外定义的一般形式是:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;inline 返回类型 类名::成员函数名(参数表)&lt;br/&gt;{&lt;br/&gt;// 函数体&lt;br/&gt;}&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;class Coord{
public:
    void setCoord(int,int);
    int getx();
    int gety();
private:
    int x,y;
};
inline void Coord::setCoord(int a,int b)
{ x=a; y=b;}
inline int Coord::getx(){ return x;}
inline int Coord::gety(){ return y; }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;说明&quot;&gt;说明&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;(1)使用inline说明内联函数时，&lt;strong&gt;必须使函数体和inline说明结合在一起&lt;/strong&gt;，否则编译器将它作为普通函数处理。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;inline void Coord:: setCoord(int ,int);
// 不能说明这是一个内联函数&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;(2) 通常只有较短的成员函数才定义为内联函数，对较长的成员函数最好作为一般函数处理。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;class Date{
public:
    void showDate();
private:
    int year;
    int month;
    int day;
};
inline void Date::showDate()
{cout&amp;lt;&amp;lt;year&amp;lt;&amp;lt;'.';&amp;lt;&amp;lt;month&amp;lt;&amp;lt;'.'&amp;lt;&amp;lt;day&amp;lt;&amp;lt;endl;}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;对象的定义和使用&quot;&gt;3. 对象的定义和使用&lt;/h2&gt;
&lt;h4 id=&quot;类与对象的关系&quot;&gt;类与对象的关系&lt;/h4&gt;
&lt;p&gt;通常我们把具有&lt;strong&gt;共同属性和行为&lt;/strong&gt;的事物所构成的集合叫做&lt;strong&gt;类&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在C++中,可以把&lt;strong&gt;相同数据结构&lt;/strong&gt;和&lt;strong&gt;相同操作集&lt;/strong&gt;的&lt;strong&gt;对象&lt;/strong&gt;看成属于同一类。&lt;/p&gt;
&lt;p&gt;在C++中，类也是一种用户自定义数据类型，类的对象可以看成是该类类型的一个实例，定义一个对象和定义一个变量相似。类与对象间的关系，可以用数据类型int和整型变量i之间的关系类比。&lt;/p&gt;
&lt;p&gt;C++把类的变量叫做类的对象，对象也称为类的实例。&lt;/p&gt;
&lt;h3 id=&quot;对象的定义&quot;&gt;3.1 对象的定义&lt;/h3&gt;
&lt;p&gt;对象的定义， 也称对象的创建&lt;/p&gt;
&lt;p&gt;在C++中可以用以下两种方法定义对象：&lt;/p&gt;
&lt;h4 id=&quot;在声明类的同时直接定义对象&quot;&gt;(1) 在声明类的同时,直接定义对象。&lt;/h4&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;class Coord {
public:
    void setCoord(int,int);
    int getx();
    int gety();
private:
    int x,y;
} op1,op2;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;声明了类之后在使用时再定义对象&quot;&gt;(2) 声明了类之后,在使用时再定义对象&lt;/h4&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;class Coord {
    //…
};
// …
main()
{
    Coord op1,op2;
    // …
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;说明-1&quot;&gt;说明：&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;在声明类的&lt;strong&gt;同时定义&lt;/strong&gt;的对象是一种&lt;strong&gt;全局对象&lt;/strong&gt;，在它的生存期内任何函数都可以使用它。&lt;/li&gt;
&lt;li&gt;声明了一个类便声明了一种&lt;strong&gt;类型&lt;/strong&gt;，它并不接收和存储具体的值，只作为生成具体对象的一种“样板”，只有定义了对象后，系统才为对象分配存储空间。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;对象中成员的访问&quot;&gt;3.2 对象中成员的访问&lt;/h3&gt;
&lt;p&gt;当定义了一个类的对象后，就可以访问对象的成员了。在类的外部可以通过类的对象对&lt;strong&gt;公有成员&lt;/strong&gt;进行访问,访问对象成员要使用操作符“.”。&lt;/p&gt;
&lt;p&gt;访问的一般形式是:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;对象名.数据成员名&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;对象名.成员函数名(参数表)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其中“.”叫做&lt;strong&gt;对象选择符&lt;/strong&gt;,简称&lt;strong&gt;点运算符&lt;/strong&gt;。&lt;/p&gt;
&lt;h5 id=&quot;例2.2-使用类coord的完整程序&quot;&gt;例2.2 使用类Coord的完整程序&lt;/h5&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include&amp;lt;iostream.h&amp;gt;
class Coord {
public：
    void setCoord(int a,int b)
    { x=a; y=b; }
    int getx()
    { return x; }
    int gety()
    { return y; }
private：
    int x,y;
};
void main()
{
    Coord op1,op2;
    int i,j;
    op1.setCoord(5,6); // 调用op1的setCoord()，初始化对象op1
    op2.setCoord(7,8); // 调用op2的setCoord()，初始化对象op2
    i=op1.getx(); // 调用op1的getx()，取op1的x值
    j=op1.gety(); // 调用op1的gety()，取op1的y值
    cout&amp;lt;&amp;lt;&quot;op1 i= &quot;&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&quot; op1 j= &quot;&amp;lt;&amp;lt;j&amp;lt;&amp;lt;endl;
    i=op2.getx(); // 调用op2的getx()，取op2的x值
    j=op2.gety(); // 调用op2的gety()，取op2的y值
    cout&amp;lt;&amp;lt;&quot;op2 i= &quot;&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&quot; op2 j= &quot;&amp;lt;&amp;lt;j&amp;lt;&amp;lt;endl;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;说明-2&quot;&gt;说明：&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;对象名.成员名实际上是一种缩写形式，它表&lt;br/&gt;达的意义是:&lt;strong&gt;对象名.类名::成员名&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void main( )
{
    Date date1;
    date1.setDate(2006,9,21);
    //……
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;在类的内部所有成员之间都可以通过成员函数直接访问，但是&lt;strong&gt;类的外部不能访问对象的私有成员&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;例2.3-一个存在错误的程序&quot;&gt;例2.3 一个存在错误的程序&lt;/h5&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;iostream.h&amp;gt;
class Date {
public:
    void setDate(int y,int m,int d);
    void showDate();
private:
    int year;
    int month;
    int day;
};
void Date∷setDate(int y,int m,int d)
{
    year=y;
    month=m;
    day=d;
}
inline void Date∷showDate()
{
    cout&amp;lt;&amp;lt;year&amp;lt;&amp;lt;&quot;.&quot;&amp;lt;&amp;lt;month&amp;lt;&amp;lt;&quot;.&quot;&amp;lt;&amp;lt;day&amp;lt;&amp;lt;endl;
}
void main()
{
    Date date1,date2;
    cout&amp;lt;&amp;lt;&quot;Date1 set and output:&quot;&amp;lt;&amp;lt;endl;
    date1.setDate(1998,4,28);
    cout&amp;lt;&amp;lt;date1.year&amp;lt;&amp;lt;&quot;.&quot;&amp;lt;&amp;lt;date1.month&amp;lt;&amp;lt;&quot;.&quot;&amp;lt;&amp;lt;date1.day&amp;lt;&amp;lt;endl; //错误
    date1.showDate();
    cout&amp;lt;&amp;lt;&quot;Date2 set and output： &quot;&amp;lt;&amp;lt;endl;
    date2.setDate(2002,11,14);
    cout&amp;lt;&amp;lt;date2.year&amp;lt;&amp;lt;&quot;.&quot;&amp;lt;&amp;lt;date2.month&amp;lt;&amp;lt;&quot;.&quot;&amp;lt;&amp;lt;date2.day&amp;lt;&amp;lt;endl; //错误
    date2.showDate();•
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;在定义对象时，若定义的是指向对象的&lt;strong&gt;指针&lt;/strong&gt;，则访问此对象的成员时，要用“-&amp;gt;”操作符。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void main( )
{
    Date *date3;
    date3-&amp;gt;setDate(2001,8,15);
    //……
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;类成员的访问属性&quot;&gt;3.3 类成员的访问属性&lt;/h3&gt;
&lt;p&gt;类成员有三种访问属性:&lt;strong&gt;公有（public）&lt;/strong&gt;、 &lt;strong&gt;私有（private）&lt;/strong&gt; 和&lt;strong&gt;保护（protected）&lt;/strong&gt; 。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;说明为公有的成员不但可以被类中成员函数访问;&lt;br/&gt;还可在类的外部,通过类的对象进行访问。&lt;/li&gt;
&lt;li&gt;说明为私有的成员只能被类中成员函数访问,不能&lt;br/&gt;在类的外部,通过类的对象进行访问。&lt;/li&gt;
&lt;li&gt;说明为保护的成员除了类本身的成员函数可以访&lt;br/&gt;问外,该类的派生类的成员也可以访问,但不能在类的&lt;br/&gt;外部,通过类的对象进行访问。类成员的访问属性&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;类的成员对&lt;strong&gt;类对象&lt;/strong&gt;的可见性和对&lt;strong&gt;类的成员函数&lt;/strong&gt;的可见性是不同的。&lt;/p&gt;
&lt;p&gt;类的&lt;strong&gt;成员函数&lt;/strong&gt;可以访问类的&lt;strong&gt;所有成员&lt;/strong&gt;，而&lt;strong&gt;类的对象&lt;/strong&gt;对类的成员的访问是受类成员的&lt;strong&gt;访问属性的制约&lt;/strong&gt;的。&lt;/p&gt;
&lt;h3 id=&quot;类中成员的访问方式&quot;&gt;3.4 类中成员的访问方式&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;类中成员互访：直接使用成员名&lt;/li&gt;
&lt;li&gt;类外访问：使用“&lt;strong&gt;对象名.成员名&lt;/strong&gt;”方式访问 public 属性的成员&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;class Sample{
public:
    int k;
    int geti(){return i;}
    int getj(){return j;}int getk(){return k;}
private:
    int i;
protected:
    int j;
};
//……
Sample a; //定义类Sample的对象a
a.i; //非法，类Sample的对象a不能访问类的私有成员i
a.j; //非法，类Sample的对象a不能访问类的保护成员j
a.k; //合法，类Sample的对象a能访问类的公有成员k
//……&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一般来说，公有成员是类的对外接口，而私有成员和保护成员是类的内部数据和内部实现，不希望外界访问。&lt;/p&gt;
&lt;p&gt;将类的成员划分为不同的访问级别有两个好处：一是&lt;strong&gt;信息隐蔽&lt;/strong&gt;，即实现封装；二是&lt;strong&gt;数据保护&lt;/strong&gt;，即将类的重要信息保护起来，以免其它程序不恰当地修改。&lt;/p&gt;
&lt;h3 id=&quot;对象赋值语句&quot;&gt;3.5 对象赋值语句&lt;/h3&gt;
&lt;p&gt;两个同类型的变量之间可以相互赋值。同类型的对象间也可以进行赋值，当一个对象赋值给另一个对象时，所有的数据成员都会&lt;strong&gt;逐位拷贝&lt;/strong&gt;。&lt;/p&gt;
&lt;h5 id=&quot;例2.5&quot;&gt;例2.5&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;#include&amp;lt;iostream.h&amp;gt;
class abc{
public:
    void init(int i,int j) { a=i; b=j; }
    void show(){ cout&amp;lt;&amp;lt;a&amp;lt;&amp;lt;&quot; &quot;&amp;lt;&amp;lt;b&amp;lt;&amp;lt;endl; }
private:
    int a,b;
};
main()
{
    abc o1,o2;
    o1.init(12,34);
    o2=o1; // 将对象o1数据成员的值赋给对象o2
    o1.show();
    o2.show();
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;说明-3&quot;&gt;说明：&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;在使用对象赋值语句进行对象赋值时，两个对象的&lt;strong&gt;类型必须相同&lt;/strong&gt;，如果对象的类型不同，编译时将出错。&lt;/li&gt;
&lt;li&gt;两个对象之间的赋值，仅仅使这些对象中&lt;strong&gt;数据成员相同&lt;/strong&gt;，而两个对象仍是分离的。&lt;/li&gt;
&lt;li&gt;例2.5的对象赋值是通过缺省的&lt;strong&gt;赋值运算符函数&lt;/strong&gt;实现的。&lt;/li&gt;
&lt;li&gt;当类中存在指针时，使用缺省的赋值运算符进行对象赋值，可能会&lt;strong&gt;产生错误&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;类的作用域&quot;&gt;3.6 类的作用域&lt;/h3&gt;
&lt;p&gt;所谓类的作用域就是指在类声明中的一对花括号所形成的作用域。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一个类的所有成员都在该类的作用域内,&lt;strong&gt;一个类的任何成员可以访问该类的其他成员&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一个类的成员函数可以不受限制地访问类的成员&lt;/strong&gt;，而在类的外部，对该类的数据成员和成员函数的访问则要受到一定的限制，有时甚至是不允许的,这体现了类的封装功能。&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;例2.6-理解类的作用域&quot;&gt;例2.6 理解类的作用域&lt;/h5&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;# include&amp;lt;iostream.h&amp;gt;
class myclass{
public:
    int i;
    void init(int);
    void show(){ cout&amp;lt;&amp;lt;“i=” &amp;lt;&amp;lt;i&amp;lt;&amp;lt;endl;} // 可以访问类中的数据成员i
};
void myclass::init(int si){ i=si;} // 可以访问类中的数据成员i
int fun(){ return i; } // 非法,不能直接访问类中的i
void main()
{
    myclass ob;
    ob.init(5); // 给数据成员i赋初值5
    ob.show();
    i=8; // 非法,不能直接访问类中的i,可改写成ob.i=8
    ob.show();
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 12 Mar 2019 15:18:00 +0000</pubDate>
<dc:creator>鲸90830</dc:creator>
<og:description>类和对象 OOP第二课 1 类的构成 1.1 从结构到类 1.2 类的构成 2 成员函数的声明 2.1 普通成员函数形式 2.2 将成员函数以内联函数的形式进行说明 3 对象的定义和使用 3.1 对象</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/whale90830/p/10520364.html</dc:identifier>
</item>
<item>
<title>往期笔记汇总(第一次呢~) - MaxVen</title>
<link>http://www.cnblogs.com/maxv/p/10520352.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/maxv/p/10520352.html</guid>
<description>
&lt;p&gt;&lt;em&gt; &lt;strong&gt;整形定义:&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　 int（10^9-2^32) long long(10^18-2^64) %-02lld(左对齐2位域不足0补）&lt;br/&gt;&lt;em&gt;&lt;strong&gt;浮点型定义:&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;　　&lt;/em&gt; float double %-.2llf(左对齐保留两位小数)&lt;br/&gt;&lt;em&gt;&lt;strong&gt;字符型:&lt;/strong&gt;&lt;/em&gt; %c(单个字符多则丢失) %s(获取一个字符串) char a='a';字符常量可参与数值运算&lt;br/&gt;&lt;em&gt;&lt;strong&gt;结构体&lt;/strong&gt;&lt;/em&gt; :&lt;/p&gt;
&lt;p&gt;　　struct stdu{inta;char a[100]}a[10];连续_struct stdu{inta;char a[100]};-struct stdu a,b,c;(可不)&lt;br/&gt;&lt;em&gt;&lt;strong&gt;输入:&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　scanf（&quot;%s&quot;，&amp;amp;a);（空格无效） ch=getchar(); gets(a);[空格有效，防止吞掉回车用getchar()]&lt;br/&gt;&lt;em&gt;&lt;strong&gt;输出:&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　printf(&quot;\n \\ %% \' \&quot; &quot;); puthar('\n');puthar(ch); puts(a);&lt;br/&gt;&lt;em&gt;&lt;strong&gt;字符串输入:&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　 cahr a[5]=&quot;sda&quot;;scanf（&quot;%s&quot;,&amp;amp;a）;for-scanf;gets(a);&lt;br/&gt;&lt;em&gt;&lt;strong&gt;字符串输出:&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　printf（&quot;%s&quot;,a）;for-printf; puts(a);&lt;br/&gt;&lt;em&gt;&lt;strong&gt;变量类型转化:&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　(int)a/b;(double)a/b;&lt;br/&gt;&lt;em&gt;&lt;strong&gt;循环输入:&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;　　&lt;/em&gt; while（gets(a)）;while(~scanf())while(scanf()!=EOF) ctrl+z/c结束输入&lt;br/&gt;&lt;em&gt;&lt;strong&gt;另类赋值:&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;　　&lt;/em&gt; a=a&amp;gt;0?a:(-a);&lt;br/&gt;&lt;em&gt;&lt;strong&gt;else，break;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　与最近的一个if成体系，跳出最近for循环；&lt;br/&gt;&lt;em&gt;&lt;strong&gt;嵌套:&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　if-else if-else switch()-case: 均可嵌套&lt;br/&gt;&lt;strong&gt;&lt;em&gt;最大公约数公倍数:&lt;/em&gt;&lt;/strong&gt;  &lt;strong&gt;辗转相除法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　（大取余小 小取余余数 直至余数为0则最大公约数为上一余数，最小公倍数为原数乘积/上一余数）&lt;br/&gt;&lt;em&gt;&lt;strong&gt;冒泡排序:&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　for（i=0;i&amp;lt;n-1;i++）{for(j=0;j&amp;lt;n-1-i;j++)}&lt;br/&gt;&lt;em&gt;&lt;strong&gt;素数优化:&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;　　&lt;/em&gt; for（i=2;i*i&amp;lt;=n;i++）// for(i=2;i&amp;lt;n/2;i++)&lt;br/&gt;&lt;strong&gt;&lt;em&gt;&amp;lt;string.h&amp;gt;  &amp;lt;cstring&amp;gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;　　 &lt;/em&gt;&lt;/strong&gt; strlen(); strcmp(,);strcpy(,);  &lt;strong&gt; 注:&lt;/strong&gt;strlwr(),strupr(),并不是适用于所有系统!~&lt;br/&gt;&lt;em&gt;&lt;strong&gt;&amp;lt;math.h&amp;gt;  &amp;lt;cmath&amp;gt;&lt;/strong&gt;&lt;/em&gt; &lt;/p&gt;
&lt;p&gt;　　 sqrt();&lt;br/&gt;&lt;em&gt;&lt;strong&gt;&amp;lt;strlib.h&amp;gt;&lt;/strong&gt;&lt;/em&gt;&lt;br/&gt;&lt;em&gt;&lt;strong&gt;&amp;lt;algorithm&amp;gt; using namespace std;&lt;/strong&gt;&lt;/em&gt; &lt;/p&gt;
&lt;p&gt;            sort(开始，结束/or直接整体,自定义函数)对区间内所有顺序排序&lt;/p&gt;
&lt;p&gt;            如:int cmp(int a,int b) {  return a&amp;gt;b ;}               按照从大到小排序&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;TX1-F WFU if-else 闰年：&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　if((year%4==0&amp;amp;&amp;amp;year%100!=0)||year%400==0)-2-29&lt;br/&gt;&lt;em&gt;&lt;strong&gt;TX2-F WFU for&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　 for(i=0;i&amp;lt;n-1;i+2)&lt;br/&gt;&lt;em&gt;&lt;strong&gt;TX2-A WFU 素数判定&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/em&gt; for（i=2;i*i&amp;lt;=n;i++）if(n%i==0)return 0；else return 1；&lt;em&gt;&lt;strong&gt;(后文携带素数代码优化版)&lt;/strong&gt;&lt;/em&gt;&lt;br/&gt;&lt;em&gt;&lt;strong&gt;TX4A-I WFU 注意循环与break；&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;　　 ~与！=EOF while(n--) if()break; while(&lt;/strong&gt; gets() &lt;strong&gt;)  while(cin&amp;gt;&amp;gt;a)&lt;/strong&gt;&lt;/em&gt;&lt;br/&gt;&lt;em&gt;&lt;strong&gt;TX4-J WFU&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　 %==0? 优化 某2因子乘积为此数注意sum-1(因子小于本身) int与long long的选择使用否则时间超时&lt;em&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;重点(敲黑板)  :&lt;/em&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;em&gt;异或运算^ 任何数与0^为本身，相同的2个数^为1，不同的2高数^为0；通过这样可以找出一组数中存在唯一的呢个&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;素数优化代码()&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;#include&amp;lt;iostream&amp;gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;#include&amp;lt;cstring&amp;gt;//下文memset(,,)所在头文件 &lt;/strong&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;strong&gt;using namespace std;&lt;/strong&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;strong&gt;int a[100001];//数组之类的开的大必须全局&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;int main()&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;{&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt; 　　int n,m;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;　　memset(a,1,sizeof(a));//常用的数组初始化直接百度&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;　　a[1]=0;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;　　for(int i=2; i*i&amp;lt;=100000; i++)&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;{&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;　　for(int j=2; j*i&amp;lt;=100000; j++)&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;  {&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;　　a[i*j]=0;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;   }&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;} /*素数定义知 不会有多余的因子 反过来 2个数的&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;乘积 一定不是素数标记成0 下文有图感谢他人的分析*/&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;　　cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;　　for(int i=n; i&amp;lt;=m; i++)&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;　　　　if(a[i])&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;　　　　　　cout&amp;lt;&amp;lt;i&amp;lt;&amp;lt;endl;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;　　return 0;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;}&lt;/strong&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1554709/201903/1554709-20190312232101814-1802779928.gif&quot; alt=&quot;&quot; width=&quot;375&quot; height=&quot;249&quot;/&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 12 Mar 2019 15:15:00 +0000</pubDate>
<dc:creator>MaxVen</dc:creator>
<og:description>整形定义: int（10^9-2^32) long long(10^18-2^64) %-02lld(左对齐2位域不足0补） 浮点型定义: float double %-.2llf(左对齐保留两位小数</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/maxv/p/10520352.html</dc:identifier>
</item>
<item>
<title>C++_构造函数与析构函数 - 鲸90830</title>
<link>http://www.cnblogs.com/whale90830/p/10520316.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/whale90830/p/10520316.html</guid>
<description>&lt;blockquote&gt;
&lt;p&gt;OOP第二课&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;1 构造函数
&lt;ul&gt;&lt;li&gt;1.1 构造函数具有一些特殊的性质&lt;/li&gt;
&lt;li&gt;1.2 定义构造函数的一般形式&lt;/li&gt;
&lt;li&gt;1.3 利用构造函数创建对象&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;2 成员初始化表&lt;/li&gt;
&lt;li&gt;3 缺省参数的构造函数&lt;/li&gt;
&lt;li&gt;4 重载构造函数&lt;/li&gt;
&lt;li&gt;5 拷贝构造函数
&lt;ul&gt;&lt;li&gt;5.1 自定义拷贝构造函数&lt;/li&gt;
&lt;li&gt;5.2 缺省的拷贝构造函数&lt;/li&gt;
&lt;li&gt;5.3 调用拷贝构造函数的三种情况&lt;/li&gt;
&lt;li&gt;5.4 浅拷贝和深拷贝&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;6 析构函数&lt;/li&gt;
&lt;li&gt;7 调用构造函数和析构函数的顺序&lt;/li&gt;
&lt;li&gt;8 对象的生存期&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;构造函数和析构函数都是类的成员函数,但它们都是特殊的成员函数,执行特殊的功能,不用调用便&lt;strong&gt;自动执行&lt;/strong&gt;,而且这些&lt;strong&gt;函数的名字&lt;/strong&gt;与&lt;strong&gt;类的名字&lt;/strong&gt;有关。&lt;/p&gt;
&lt;p&gt;C++语言中有一些成员函数性质是特殊的，这些成员函数负责&lt;strong&gt;对象的建立、删除&lt;/strong&gt;。这些函数的特殊性在于可以由编译器&lt;strong&gt;自动地隐含调用&lt;/strong&gt;，其中一些函数调用格式采用运算符函数重载的语法。&lt;/p&gt;
&lt;p&gt;C++引进一个自动完成对象初始化过程的机制，这就是类的构造函数。&lt;/p&gt;
&lt;h4 id=&quot;对象的初始化&quot;&gt;对象的初始化&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;数据成员是不能在声明类时初始化&lt;/li&gt;
&lt;li&gt;类型对象的初始化方法：&lt;br/&gt;1) 调用对外接口（public成员函数）实现：声明类→定义对象→调用接口给成员赋值&lt;br/&gt;2) 应用构造函数（constructor） 实现：声明类→定义对象→同时给成员赋值&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;构造函数&quot;&gt;1. 构造函数&lt;/h2&gt;
&lt;p&gt;构造函数是&lt;strong&gt;一种特殊的成员函数&lt;/strong&gt;,它主要用于&lt;strong&gt;为对象分配空间&lt;/strong&gt;,进行初始化。&lt;/p&gt;
&lt;h4 id=&quot;构造函数具有一些特殊的性质&quot;&gt;1.1 构造函数具有一些特殊的性质:&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;(1) 构造函数的名字必须&lt;strong&gt;与类名相同&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;(2) 构造函数可以有任意类型的参数,但&lt;strong&gt;不能指定返回类型&lt;/strong&gt;。 它有隐含的返回值,该值由系统内部使用。&lt;/li&gt;
&lt;li&gt;(3) 构造函数是特殊的成员函数,函数体可写在类体内,也可写在类体外。&lt;/li&gt;
&lt;li&gt;(4) 构造函数&lt;strong&gt;可以重载&lt;/strong&gt;,即一个类中可以定义多个参数个数或参数类型不同的构造函数。构造函数是不能继承&lt;/li&gt;
&lt;li&gt;(5) 构造函数被声明为&lt;strong&gt;公有函数&lt;/strong&gt;,但它不能像其他成员函数那样被显式地调用,它是在定义对象的同时被调用的。&lt;/li&gt;
&lt;li&gt;(6) 在声明类时如果没有定义类的构造函数，编译系统就会在编译时自动生成一个默认形式的构造函数，&lt;/li&gt;
&lt;li&gt;(7) &lt;strong&gt;默认构造函数&lt;/strong&gt;是构造对象时不提供参数的构造函数。&lt;/li&gt;
&lt;li&gt;(8) 除了无参数构造函数是默认构造函数外，带有全部默认参数值的构造函数也是默认构造函数。&lt;/li&gt;
&lt;li&gt;(9) &lt;strong&gt;自动调用&lt;/strong&gt;：构造函数在定义类对象时自动调用， 不需用户调用，也不能被用户调用。在对象使用前调用。&lt;/li&gt;
&lt;li&gt;(10) &lt;strong&gt;调用顺序&lt;/strong&gt;：在对象进入其作用域时（对象使用前） 调用构造函数。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;定义构造函数的一般形式&quot;&gt;1.2 定义构造函数的一般形式&lt;/h4&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;class 类名
{
public:
    类名（形参表） ; //构造函数的原型
    //类的其它成员
};
类名::类名（形参表） //构造函数的实现
{
    //函数体
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;利用构造函数创建对象&quot;&gt;1.3 利用构造函数创建对象&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;(1) 利用构造函数直接创建对象.其一般形式为：&lt;strong&gt;类名 对象名[(实参表)];&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里的“类名”与构造函数名相同,“实参表”是为构造函数提供的实际参数。&lt;/p&gt;
&lt;h5 id=&quot;例2.7-为类date建立一个构造函数&quot;&gt;例2.7 为类Date建立一个构造函数&lt;/h5&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;iostream.h&amp;gt;
class Date {
public:
    Date(int y,int m,int d); // 构造函数
    void setDate(int y,int m,int d);
    void showDate();
private:
    int year, month, day;
};
Date::Date(int y,int m,int d) // 构造函数的实现
{ year=y; month=m; day=d; }
void Date::setDate(int y,int m,int d)
{ year=y; month=m; day=d; }
inline void Date::showDate()
{ cout&amp;lt;&amp;lt;year&amp;lt;&amp;lt;&quot;.&quot;&amp;lt;&amp;lt;month&amp;lt;&amp;lt;&quot;.&quot;&amp;lt;&amp;lt;day&amp;lt;&amp;lt;endl; }&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;例2.8-利用构造函数直接创建对象&quot;&gt;例2.8 利用构造函数直接创建对象&lt;/h5&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;iostream.h&amp;gt;
class Date {
// 省略， 同例2.7
};
// 省略， 同例2.7
void main()
{
    Date date1(1998,4,28); // 定义类Date的对象date1,
    // 自动调用date1的构造函数,初始化对象date1
    cout&amp;lt;&amp;lt;&quot;Date1 output1:&quot;&amp;lt;&amp;lt;endl;
    date1.showDate(); // 调用date1的showDate(),显示date1的数据
    date1.SetDate(2002,11,14); // 调用date1的setDate(),
    // 重新设置date1的数据
    cout&amp;lt;&amp;lt;&quot;Date1 output2:&quot;&amp;lt;&amp;lt;endl;
    date1.showDate(); // 调用date1的showDate(),显示date1的数据
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;constructing...
Date1 output1:
1998.4.28
Date1 output2:
2002.11.14&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;(2) 利用构造函数创建对象时,通过指针和new来实现。其一般语法形式为:&lt;br/&gt;&lt;strong&gt;类名 *指针变量 = new 类名[(实参表)];&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void main()
{
    Date *date1;
    date1=new Date(1998,4,28);
    //可合写成:Date *date1=new Date(1998,4,28);
    cout&amp;lt;&amp;lt;&quot;Date1 output1:&quot;&amp;lt;&amp;lt;endl;
    date1-&amp;gt;showDate();
    date1-&amp;gt;setDate(2002,11,14);
    cout&amp;lt;&amp;lt;&quot;Date1 output2:&quot;&amp;lt;&amp;lt;endl;
    date1-&amp;gt;showDate();
    delete date1;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;说明&quot;&gt;说明：&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;构造函数的名字必须与类名相同，否则编译器将把它当作一般的成员函数来处理。&lt;/li&gt;
&lt;li&gt;构造函数是不能说明它的返回值类型的，甚至说明为void类型也不行。&lt;/li&gt;
&lt;li&gt;构造函数可以是不带参数的。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;class A{
public:
    A();
    //…
private:
    int x;
};
A∷A()
{
    cout&amp;lt;&amp;lt;&quot;initialized \n&quot;;
    x=50;
}
main()
{
    A a;
    …
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;例&quot;&gt;例&lt;/h5&gt;
&lt;p&gt;有两个长方柱，其长、宽、高分别为：(1)12,25,30；(2)15,30,21。求它们的体积。要求：编一个基于对象的程序，在类中用带参数的构造函数。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;class Box{
public:
    Box(int,int,int);
    int volume( );
private:
    int height;
    int width;
    int length;
};
Box::Box(int h,int w,int len)
{
    height = h;
    width = w;
    length = len;
}
int Box::volume( )
{
    return height*width*length;
}
int main( )
{
    Box box1(12,25,30);
    cout &amp;lt;&amp;lt; box1.volume( ) &amp;lt;&amp;lt; endl;
    Box box2(15,30,21);
    cout &amp;lt;&amp;lt; box2.volume( ) &amp;lt;&amp;lt; endl;
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;成员初始化表&quot;&gt;2. 成员初始化表&lt;/h2&gt;
&lt;p&gt;对于&lt;strong&gt;常量类型&lt;/strong&gt;和&lt;strong&gt;引用类型&lt;/strong&gt;的数据成员,不能在构造函数中用&lt;strong&gt;赋值语句&lt;/strong&gt;直接赋值,C++提供初始化表进行置初值。&lt;/p&gt;
&lt;p&gt;带有成员初始化表的构造函数的一般形式如下:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;类名::构造函数名([参数表])[:(成员初始化表)]&lt;br/&gt;{&lt;br/&gt;// 构造函数体&lt;br/&gt;}&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;成员初始化表的一般形式为:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据成员名1(初始值1),数据成员名2(初始值2),……&lt;/strong&gt;&lt;/p&gt;
&lt;h5 id=&quot;例2.9-成员初始化表的使用&quot;&gt;例2.9 成员初始化表的使用&lt;/h5&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include&amp;lt;iostream.h&amp;gt;
class A{
public:
    A(int x1):x(x1),rx(x),pi(3.14) // rx(x)相当于rx=x, pi(3.14)相当于pi=3.14
    { }
    void print()
    {cout&amp;lt;&amp;lt;&quot;x=&quot;&amp;lt;&amp;lt;x&amp;lt;&amp;lt;&quot; &quot;&amp;lt;&amp;lt;&quot;rx=&quot;&amp;lt;&amp;lt;rx&amp;lt;&amp;lt;&quot; &quot;&amp;lt;&amp;lt;&quot;pi=&quot;&amp;lt;&amp;lt;pi;}
private:
    int x; int&amp;amp; rx; const float pi;
};
main()
{
    A a(10);
    a.print();
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;构造函数采用成员初始化表对数据成员进行初始化，是一些程序员喜欢使用的方法。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;class B{
    int i;
    char j;
    float f;
public：
    B(int I， char J， float F)
    { i=I; j=J; f=F; };
};&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;class B{
public：
    B(int I,char J,float F):i(I),j(J),f(F)
    { }
private:
    int i;
    char j;
    float f;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;说明-1&quot;&gt;说明&lt;/h4&gt;
&lt;p&gt;如果需要将数据成员存放在堆中或数组中，则应在构造函数中使用赋值语句，即使构造函数有成员初始化表也应如此。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;class C{
public:
    C(int I,char Ch,float F,char N[]):i(I),ch(Ch),f(F)
    { strcpy (name,N);}
private:
    int i;
    char ch;
    float f;
    char name[25];
};&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;类成员是按照它们&lt;strong&gt;在类里被声明的顺序&lt;/strong&gt;初始化的,与它们在初始化表中列出的顺序无关。&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;例2.10&quot;&gt;【例2.10】&lt;/h5&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include&amp;lt;iostream.h&amp;gt;
class D {
public:
    D(int i):mem2(i),mem1(mem2+1)
    {
        cout&amp;lt;&amp;lt;&quot;mem1: &quot;&amp;lt;&amp;lt;mem1&amp;lt;&amp;lt;endl;
        cout&amp;lt;&amp;lt;&quot;mem2: &quot;&amp;lt;&amp;lt;mem2&amp;lt;&amp;lt;endl;
    }
private:
    int mem1;
    int mem2;
};
void main()
{
    D d(15);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;mem1: -858993459
mem2: 15&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;缺省参数的构造函数&quot;&gt;3. 缺省参数的构造函数&lt;/h2&gt;
&lt;h5 id=&quot;例2.11&quot;&gt;例2.11&lt;/h5&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include&amp;lt;iostream.h&amp;gt;
class Coord {
public:
    Coord(int a=0,int b=0){ x=a; y=b;} // 带有缺省参数的构造函数
    int getx(){ return x; }
    int gety(){ return y; }
private:
    int x,y;
};
void main()
{
    Coord op1(5,6); Coord op2(5); Coord op3;
    int i,j;
    i=op1.getx();j=op1.gety();
    cout&amp;lt;&amp;lt;&quot;op1 i= &quot;&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&quot; op1 j= &quot;&amp;lt;&amp;lt;j&amp;lt;&amp;lt;endl;
    i=op2.getx();j=op2.gety();
    cout&amp;lt;&amp;lt;&quot;op2 i= &quot;&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&quot; op2 j= &quot;&amp;lt;&amp;lt;j&amp;lt;&amp;lt;endl;
    i=op3.getx();j=op3.gety();
    cout&amp;lt;&amp;lt;&quot;op3 i= &quot;&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&quot; op3 j= &quot;&amp;lt;&amp;lt;j&amp;lt;&amp;lt;endl;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;class Box{
public:
    Box(int h=10,int w=10,int l=10); //在声明构造函数时指定默认参数
    int volume( ){ return(height*width*length); }
private:
    int height;
    int width;
    int length;
};
Box:: Box(int h,int w,int l) //在定义函数时可以不指定默认参数
{
    height=h;
    width=w;
    length=l;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;重载构造函数&quot;&gt;4. 重载构造函数&lt;/h2&gt;
&lt;h4 id=&quot;构造函数的重载&quot;&gt;构造函数的重载&lt;/h4&gt;
&lt;p&gt;在一个类中可以定义多个构造函数，以便对类对象提供不同的初始化的方法，供用户选用。这些构造函数具有相同的名字，而参数的个数或参数的类&lt;br/&gt;型不相同（这称为构造函数的重载）&lt;/p&gt;
&lt;h4 id=&quot;关于构造函数重载的说明&quot;&gt;关于构造函数重载的说明&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;(1) &lt;strong&gt;默认构造函数&lt;/strong&gt;：一个调用构造函数时不必给出实参的构造函数。 显然，无参的构造函数属于默认构造函数。一个类只能有一个默认构造函数。&lt;/li&gt;
&lt;li&gt;(2) 尽管在一个类中可以包含多个构造函数，但是对于每一个对象来说，&lt;strong&gt;建立对象时只执行其中一个构造函数&lt;/strong&gt;，并非每个构造函数都被执行。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;class Box{
public:
    Box(int h, int w, int l): height(h),width(w),length(l) { }
    Box();
    int volume( );
private:
    int height;
    int width;
    int length;
};
Box::Box()
{
    height = 10;
    width = 10;
    lenght = 10;
}
int Box::volume( )
{
    return height*width*length;
}
int main( )
{
    Box box1; // 书上为 box1();
    cout &amp;lt;&amp;lt; box1.volume( ) &amp;lt;&amp;lt; endl;
    Box box2(15,30,25);
    cout &amp;lt;&amp;lt; box2.volume( ) &amp;lt;&amp;lt; endl;
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;例2.17-重载构造函数应用例程&quot;&gt;例2.17 重载构造函数应用例程。&lt;/h5&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;iostream.h&amp;gt;
class Date{
public:
    Date(); // 无参数的构造函数
    Date(int y,int m,int d); // 带有参数的构造函数
    void showDate();
private:
    int year, month, day;
};
Date::Date()
{ year=1998; month=4; day=28; }
Date::Date( int y, int m, int d)
{ year=y; month=m; day=d; }
inline void Date::showDate()
{ cout&amp;lt;&amp;lt;year&amp;lt;&amp;lt;&quot;.&quot;&amp;lt;&amp;lt;month&amp;lt;&amp;lt;&quot;.&quot;&amp;lt;&amp;lt;day&amp;lt;&amp;lt;endl; }
void main()
{
    Date date1; // 声明类Date的对象date1，
    // 调用无参数的构造函数
    cout&amp;lt;&amp;lt;&quot;Date1 output： &quot;&amp;lt;&amp;lt;endl;
    date1.showDate(); // 调用date1的showDate()，显示date1的数据
    Date date2(2002， 11， 14); // 定义类Date的对象date2，
    // 调用带参数的构造函数
    cout&amp;lt;&amp;lt;&quot;Date2 output： &quot;&amp;lt;&amp;lt;endl;
    date2.showDate(); // 调用date2的showDate()，显示date2的数据
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Date1 output：
1998.4.28
Date2 output：
2002.11.14&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;例2.18-关于计时器的例子&quot;&gt;例2.18 关于计时器的例子&lt;/h5&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include&amp;lt;iostream.h&amp;gt;
#include&amp;lt;stdlib.h&amp;gt;
class timer{
public:
    timer() // 无参数构造函数,给seconds清0
    { seconds=0; }
    timer(char* t) // 含一个数字串参数的构造函数
    { seconds=atoi(t); }
    timer(int t) // 含一个整型参数的构造函数
    { seconds=t; }
    timer(int min,int sec) // 含两个整型参数的构造函数
    { seconds=min*60+sec; }
    int gettime()
    { return seconds; }
private：
    int seconds;
};
main()
{
    timer a,b(10),c(&quot;20&quot;),d(1,10);
    cout&amp;lt;&amp;lt;&quot;seconds1=&quot;&amp;lt;&amp;lt;a.gettime()&amp;lt;&amp;lt;endl;
    cout&amp;lt;&amp;lt;&quot;seconds2=&quot;&amp;lt;&amp;lt;b.gettime()&amp;lt;&amp;lt;endl;
    cout&amp;lt;&amp;lt;&quot;seconds3=&quot;&amp;lt;&amp;lt;c.gettime()&amp;lt;&amp;lt;endl;
    cout&amp;lt;&amp;lt;&quot;seconds4=&quot;&amp;lt;&amp;lt;d.gettime()&amp;lt;&amp;lt;endl;
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;class x {
public:
    x(); // 没有参数的构造函数
    x(int i=0); // 带缺省参数的构造函数
};
//…
void main()
{
    x one(10); // 正确,调用x(int i=0)
    x two; // 存在二义性
    //…
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;拷贝构造函数&quot;&gt;5. 拷贝构造函数&lt;/h2&gt;
&lt;p&gt;拷贝构造函数是一种&lt;strong&gt;特殊的构造函数&lt;/strong&gt;,其形参是&lt;strong&gt;本类对象的引用&lt;/strong&gt;。其作用是使用一个已经存在的对象去初始化另一个同类的对象。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通过等于号复制对象时，系统会自动调用拷贝构造函数。&lt;/li&gt;
&lt;li&gt;拷贝构造函数与原来的构造函数实现了函数的重载。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;拷贝构造函数具有以下特点&quot;&gt;拷贝构造函数具有以下特点:&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;(1) 因为该函数也是一种构造函数,所以其函数名与类名相同,并且该函数也没有返回值类型。&lt;/li&gt;
&lt;li&gt;(2) 该函数&lt;strong&gt;只有一个参数&lt;/strong&gt;,并且是&lt;strong&gt;同类对象的引用&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;(3) 每个类都&lt;strong&gt;必须有&lt;/strong&gt;一个拷贝构造函数。程序员可以根据需要定义特定的拷贝构造函数,以实现同类对象之间数据成员的传递。如果程序员没有定义类的拷贝构造函数,系统就会自动生成产生一个缺省的拷贝构造函数。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;自定义拷贝构造函数&quot;&gt;5.1 自定义拷贝构造函数&lt;/h3&gt;
&lt;p&gt;自定义拷贝构造函数的一般形式如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class 类名{
public :
    类名（形参）； //构造函数
    类名（类名 &amp;amp;对象名）； //拷贝构造函数
...
}；
类名:: 类名（类名 &amp;amp;对象名） //拷贝构造函数的实现
{ 函数体 }&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;用户自定义拷贝构造函数&quot;&gt;用户自定义拷贝构造函数&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;class Coord{
    int x,y;
public:
    Coord(int a， int b) // 构造函数
    {
        x=a;
        y=b;
        cout&amp;lt;&amp;lt;&quot;Using normal constructor\n&quot;;
    }
    Coord(const Coord&amp;amp; p) // 拷贝构造函数
    {
        x=2*p.x;
        y=2*p.y;
        cout&amp;lt;&amp;lt;&quot;Using copy constructor\n&quot;;
    }
    //…
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果p1、 p2为类Coord的两个对象，p1已经存在，则coord p2(p1)调用拷贝构造函数来初始化p2&lt;/p&gt;
&lt;h5 id=&quot;例2.19-自定义拷贝构造函数的使用&quot;&gt;例2.19 自定义拷贝构造函数的使用&lt;/h5&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include&amp;lt;iostream.h&amp;gt;
class Coord {
public:
    Coord(int a,int b) // 构造函数
    { x=a; y=b; cout&amp;lt;&amp;lt;&quot;Using normal constructor\n&quot;;}
    Coord(const Coord&amp;amp; p) // 拷贝构造函数
    { x=2*p.x; y=2*p.y; cout&amp;lt;&amp;lt;&quot;Using copy constructor\n&quot;;}
    void print(){ cout&amp;lt;&amp;lt;x&amp;lt;&amp;lt;&quot; &quot;&amp;lt;&amp;lt;y&amp;lt;&amp;lt;endl; }
private:
    int x,y;
};
main()
{
    Coord p1(30,40); // 定义对象p1,调用了普通的构造函数
    Coord p2(p1); // 以“代入” 法调用拷贝构造函数,用对象p1初始化对象p2
    p1.print();
    p2.print();
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;除了用&lt;strong&gt;代入法&lt;/strong&gt;调用拷贝构造函数外，还可以采用&lt;strong&gt;赋值法&lt;/strong&gt;调用拷贝构造函数，如：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;main()
{
    Coord p1(30,40);
    Coord p2=p1; //以&quot;赋值&quot;法调用拷贝构造函数，
    用对象p1初始化对象p2
    //…
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;缺省的拷贝构造函数&quot;&gt;5.2 缺省的拷贝构造函数&lt;/h3&gt;
&lt;p&gt;如果没有编写自定义的拷贝构造函数,C++会自动地将一个已存在的对象复制给新对象,这种&lt;strong&gt;按成员逐一复制&lt;/strong&gt;的过程由是缺省拷贝构造函数自动完成的。&lt;/p&gt;
&lt;h5 id=&quot;例2.20-调用缺省的拷贝构造函数&quot;&gt;例2.20 调用缺省的拷贝构造函数&lt;/h5&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include&amp;lt;iostream.h&amp;gt;
class Coord{
public:
    Coord(int a,int b)
    { x=a; y=b; cout&amp;lt;&amp;lt;&quot;Using normal constructor\n&quot;; }
    void print(){ cout&amp;lt;&amp;lt;x&amp;lt;&amp;lt;&quot; &quot;&amp;lt;&amp;lt;y&amp;lt;&amp;lt;endl;}
private:
    int x,y;
};
main()
{
    Coord p1(30,40); // 定义类Coord的对象p1,
    // 调用了普通构造函数初始化对象p1
    Coord p2(p1); // 以“代入”法调用缺省的拷贝构造函数,
    // 用对象p1初始化对象p2
    Coord p3=p1; // 以“赋值”法调用缺省的拷贝构造函数,
    // 用对象p1初始化对象p3
    p1.print(); p2.print(); p3.print();
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;调用拷贝构造函数的三种情况&quot;&gt;5.3 调用拷贝构造函数的三种情况&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;(1) 当用类的一个对象去初始化该类的另一个对象时。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;Coord p2(p1); // 用对象p1初始化对象p2, 拷贝构造函数被调用(代入法)
Coord p3=p1; // 用对象p1初始化对象p3, 拷贝构造函数被调用(赋值法)&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;(2) 当函数的形参是类的对象,调用函数,进行形参和实参结合时。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;//…
fun1(Coord p) // 函数的形参是类的对象
{
    p.print();
}
main()
{
    Coord p1(10,20);
    fun1(p1); // 当调用函数,进行形参和实参结合时,
    调用拷贝构造函数
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;(3) 当函数的返回值是对象,函数执行完成,返回调用者时。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// …
Coord fun2()
{
    Coord p1(10,30);
    return p1;
} // 函数的返回值是对象
main()
{
    Coord p2;
    P2=fun2(); // 函数执行完成,返回调用者时,调用拷贝构造函数
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;浅拷贝和深拷贝&quot;&gt;5.4 浅拷贝和深拷贝&lt;/h3&gt;
&lt;p&gt;所谓&lt;strong&gt;浅拷贝&lt;/strong&gt;，就是由缺省的拷贝构造函数所实现的数据成员逐一赋值，&lt;strong&gt;若类中含有指针类型数据， 则会产生错误&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;为了解决浅拷贝出现的错误，必须显示地定义一个自己的拷贝构造函数，使之不但拷贝数据成员，而且为对象1和对象2分配各自的内存空间，这就是所谓的&lt;strong&gt;深拷贝&lt;/strong&gt;。&lt;/p&gt;
&lt;h5 id=&quot;例2.23-浅拷贝例子&quot;&gt;例2.23 浅拷贝例子&lt;/h5&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include&amp;lt;iostream.h&amp;gt;
#include&amp;lt;string.h&amp;gt;
class Student {
public:
    Student(char *name1,float score1);
    ~Student();
private:
    char *name; // 学生姓名
    float score; // 学生成绩
};
Student∷Student(char *name1,float score1)
{
    cout&amp;lt;&amp;lt;&quot;Constructing...&quot;&amp;lt;&amp;lt;name1&amp;lt;&amp;lt;endl;
    name=new char[strlen(name1)+1];
    if (name !=0)
    {
        strcpy(name,name1);
        score=score1;
    }
}
Student∷~Student()
{
    cout&amp;lt;&amp;lt;&quot;Destructing...&quot;&amp;lt;&amp;lt;name&amp;lt;&amp;lt;endl;
    name[0]='\0';
    delete name;
}
void main()
{
    Student stu1(&quot;liming&quot;,90); // 定义类Student的对象stu1
    Student stu2=stu1; // 调用缺省的拷贝构造函数
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;Constructing... liming
Destructing... liming
Destructing...&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;浅拷贝示意图&quot;&gt;浅拷贝示意图&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/03/12/AitNi6.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;例2.24-深拷贝例子&quot;&gt;例2.24 深拷贝例子&lt;/h5&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include&amp;lt;iostream.h&amp;gt;
#include&amp;lt;string.h&amp;gt;
class Student {
private:
    char *name; // 学生姓名
    float score; // 学生成绩
public:
    Student(char *name1,float score1);
    Student(Student&amp;amp; stu);
    ~Student();
};
Student∷Student(char *name1,float score1)
{
    cout&amp;lt;&amp;lt;&quot;constructing...&quot;&amp;lt;&amp;lt;name1&amp;lt;&amp;lt;endl;
    name=new char[strlen(name1)+1];
    if (name !=0)
    {
        strcpy(name,name1);
        score=score1;
    }
}
Student∷Student(Student&amp;amp; stu)
{
    cout&amp;lt;&amp;lt;&quot;Copy constructing...&quot;&amp;lt;&amp;lt;stu.name&amp;lt;&amp;lt;endl;
    name=new char[strlen(stu.name)+1];
    if (name !=0)
    {
        strcpy(name,stu.name);
        score=stu.score;
    }
}
Student∷~Student()
{
    cout&amp;lt;&amp;lt;&quot;Destructing...&quot;&amp;lt;&amp;lt;name&amp;lt;&amp;lt;endl;
    name[0]='\0';
    delete name;
}
void main()
{
    Student stu1(&quot;liming&quot;， 90); // 定义类Student的对象stu1，
    Student stu2=stu1; // 调用自定义的拷贝构造函数
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;Constructing…liming
Copy constructing…liming
Destructing…liming
Destructing…liming&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;深拷贝示意图&quot;&gt;深拷贝示意图&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/03/12/AitgFP.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;析构函数&quot;&gt;6. 析构函数&lt;/h2&gt;
&lt;p&gt;析构函数也是一种特殊的成员函数。它执行与构造函数相反的操作,通常用于&lt;strong&gt;撤消对象时的一些清理任务&lt;/strong&gt;,如释放分配给对象的内存空间等。&lt;/p&gt;
&lt;h4 id=&quot;析构函数有以下一些特点&quot;&gt;析构函数有以下一些特点:&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;① 析构函数与构造函数&lt;strong&gt;名字&lt;/strong&gt;相同,但它前面必须加一个&lt;strong&gt;波浪号(~)&lt;/strong&gt;;&lt;/li&gt;
&lt;li&gt;② 析构函数&lt;strong&gt;没有参数,也没有返回值&lt;/strong&gt;,而且&lt;strong&gt;不能重载&lt;/strong&gt;。因此在一个类中只能有&lt;strong&gt;一个&lt;/strong&gt;析构函数;&lt;/li&gt;
&lt;li&gt;③ 当撤消对象时,编译系统会自动地调用析构函数。 如果程序员没有定义析构函数，系统将自动生成和调用一个默认析构函数，默认析构函数只能释放对象的数据成员所占用的空间，但不包括堆内存空间。&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;例2.25-重新说明类date&quot;&gt;例2.25 重新说明类Date&lt;/h5&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;iostream.h&amp;gt;
class Date{
public:
    Date(int y,int m,int d); // 构造函数
    ~Date(); // 析构函数
    void setDate(int y,int m,int d);
    void showDate();
private:
    int year, month, day;
};
Date::Date(int y,int m,int d) // 构造函数的实现
{
    cout&amp;lt;&amp;lt;&quot;constructing...&quot;&amp;lt;&amp;lt;endl;
    year=y;month=m; day=d;
}
Date::~Date() // 析构函数的实现
{ cout&amp;lt;&amp;lt;&quot;destruting...&quot;&amp;lt;&amp;lt;endl; }
void Date::setDate(int y,int m,int d)
{ year=y;month=m;day=d; }
inline void Date::showDate()
{ cout&amp;lt;&amp;lt;year&amp;lt;&amp;lt;&quot;.&quot;&amp;lt;&amp;lt;month&amp;lt;&amp;lt;&quot;.&quot;&amp;lt;&amp;lt;day&amp;lt;&amp;lt;endl; }
void main()
{
    Date date1(1998,4,28); // 定义类Date的对象date1,
    // 调用date1的构造函数,初始化对象date1
    cout&amp;lt;&amp;lt;&quot;Date1 output1:&quot;&amp;lt;&amp;lt;endl;
    date1.showDate(); // 调用date1的showDate(),显示date1的数据
    date1.setDate(2002,11,14); // 调用date1的setDate(),
    // 重新设置date1的数据
    cout&amp;lt;&amp;lt;&quot;Date1 output2:&quot;&amp;lt;&amp;lt;endl;
    date1.showDate(); // 调用date1的showDate(),显示date1的数据
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;析构函数被调用的两种情况&quot;&gt;析构函数被调用的两种情况&lt;/h4&gt;
&lt;p&gt;1) 若一个对象被定义在一个函数体内，当这个函数结束时，析构函数被自动调用。&lt;br/&gt;2) 若一个对象是使用new运算符动态创建，在使用delete释放时，自动调用析构函数。&lt;/p&gt;
&lt;h5 id=&quot;例2.13-较完整的学生类例子&quot;&gt;【例2.13】 较完整的学生类例子&lt;/h5&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include&amp;lt;iostream.h&amp;gt;
#include&amp;lt;string.h&amp;gt;
class Student {
public:
    Student(char *name1,char *stu_no1,float score1); // 构造
    函数
    ~Student(); // 析构函数
    void modify(float score1); // 修改数据
    void show(); // 显示数据
private:
    char *name; // 学生姓名
    char *stu_no; // 学生学号
    float score; // 学生成绩
};
Student∷Student(char *name1,char *stu_no1,float score1)
{
    name=new char[strlen(name1)+1];
    strcpy(name,name1);
    stu_no=new char[strlen(stu_no1)+1];
    strcpy(stu_no,stu_no1);
    score=score1;
}
Student∷~Student()
{
    delete []name;
    delete []stu_no;
}
void Student∷modify(float score1)
{ score=score1; }
void Student∷show()
{
    cout&amp;lt;&amp;lt;&quot;\n name: &quot;&amp;lt;&amp;lt;name;
    cout&amp;lt;&amp;lt;&quot;\n stu_no: &quot;&amp;lt;&amp;lt;stu_no;
    cout&amp;lt;&amp;lt;&quot;\n score: &quot;&amp;lt;&amp;lt;score;
}
void main()
{
    Student stu1(&quot;Liming&quot;,&quot;990201&quot;,90); // 定义类Student的对象stu1,
    // 调用stu1的构造函数,初始化对象stu1
    stu1.show(); // 调用stu1的show(),显示stu1的数据
    stu1.modify(88); // 调用stu1的modify(),修改stu1的数据
    stu1.show(); // 调用stu1的show(),显示stu1修改后的数据
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;name:Liming
stu_no:990201
score:90
name:Liming
stu_no:990201
score:88&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;缺省的析构函数&quot;&gt;缺省的析构函数&lt;/h4&gt;
&lt;p&gt;每个类必须有一个析构函数。&lt;/p&gt;
&lt;p&gt;若没有显式地为一个类定义析构函数，编译系统会自动地生成一个缺省的析构函数&lt;/p&gt;
&lt;p&gt;其格式如下：&lt;strong&gt;类名::析构函数名( ){ }&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class string_data {
public:
    string_data(char *)
    { str=new char[max_len];}
    ~string_data()
    { delete []str;}
    void get_info(char *);
    void sent_info(char *);
private:
    char *str;
    int max_len;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;调用构造函数和析构函数的顺序&quot;&gt;7. 调用构造函数和析构函数的顺序&lt;/h2&gt;
&lt;h4 id=&quot;一般顺序&quot;&gt;1) 一般顺序&lt;/h4&gt;
&lt;p&gt;调用析构函数的次序正好与调用构造函数的次序相反：最先被调用的构造函数，其对应的（同一对象中的）析构函数最后被调用，而最后被调用的构造函数，其对应的析构函数最先被调用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/03/12/AiNASO.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;全局对象&quot;&gt;2) 全局对象&lt;/h4&gt;
&lt;p&gt;在全局范围中定义的对象(即在所有函数之外定义的对象)，它的构造函数在所有函数(包括main函数)执行之前调用。在程序的流程离开其作用域时(如main函数结束或调用exit函数)时，调用该全局对象的析构函数。&lt;/p&gt;
&lt;h4 id=&quot;auto局部对象&quot;&gt;3) auto局部对象&lt;/h4&gt;
&lt;p&gt;局部自动对象(例如在函数中定义的对象)，则在建立对象时调用其构造函数。如果函数被多次调用，则在每次建立对象时都要调用构造函数。在函数调用结束、对象释放时先调用析构函数。&lt;/p&gt;
&lt;h4 id=&quot;static局部对象&quot;&gt;4) static局部对象&lt;/h4&gt;
&lt;p&gt;如果在函数中定义静态局部对象，则只在程序第一次调用此函数建立对象时调用构造函数一次，在调用结束时对象并不释放，因此也不调用析构函数，只在main函数结束或调用exit函数结束程序时，才调用析构函数。&lt;/p&gt;
&lt;h2 id=&quot;对象的生存期&quot;&gt;8. 对象的生存期&lt;/h2&gt;
&lt;h4 id=&quot;对象按生存期的不同分为如下几种&quot;&gt;对象按生存期的不同分为如下几种：&lt;/h4&gt;
&lt;h5 id=&quot;局部对象&quot;&gt;(1) 局部对象&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;当对象被定义时，调用构造函数，该对象被创建；当程序退出该对象所在的函数体或程序块时，调用析构函数，对象被释放。&lt;/li&gt;
&lt;li&gt;局部对象是被&lt;strong&gt;定义在一个函数体或程序块内&lt;/strong&gt;的，它的作用域限定在函数体或程序块内，生存期较短。&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;全局对象-1&quot;&gt;(2) 全局对象&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;当程序开始运行时，调用构造函数，该对象被创建；当程序结束时，调用析构函数，该对象被释放。&lt;/li&gt;
&lt;li&gt;静态对象是被&lt;strong&gt;定义在一个文件中&lt;/strong&gt;，它的作用域从定义是起到文件结束时为止。生存期较长。&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;静态对象&quot;&gt;(3) 静态对象&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;当程序中定义静态对象时，调用构造函数，该对象被创建；当整个程序结束时，调用析构函数，对象被释放。&lt;/li&gt;
&lt;li&gt;全局对象是被&lt;strong&gt;定义在某个文件中&lt;/strong&gt;，它的作用域包含在该文件的整个程序中，生存期是最长的。&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;动态对象&quot;&gt;(4) 动态对象&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;执行new运算符调用构造函数，动态对象被创建；用delete释放对象时，调用析构函数。&lt;/li&gt;
&lt;li&gt;动态对象是&lt;strong&gt;由程序员掌握&lt;/strong&gt;的，它的作用域和生存期是由new和delete之间的间隔决定的。&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;类的应用举例例&quot;&gt;类的应用举例(例)&lt;/h5&gt;
&lt;p&gt;一圆形游泳池如图所示，现在需在其周围建一圆形过道，并在其四周围上栅栏。栅栏价格为35元/米，过道造价为20元/平方米。过道宽度为3米，游泳池半径由键盘输入。要求编程计算并输出过道和栅栏的造价。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;
const float PI = 3.14159;
const float FencePrice = 35;
const float ConcretePrice = 20;
//声明类Circle 及其数据和方法
class Circle{
private:
    float radius;
public:
    Circle(float r); //构造函数
    float Circumference() const; //圆周长
    /*函数后的修饰符const表示该成员函数的执行不会改变类的状态，也就是说不会修改类的数据成员。 */
    float Area() const; //圆面积
};// 类的实现
// 构造函数初始化数据成员radius
Circle::Circle(float r)
{
    radius=r;
}
// 计算圆的周长
float Circle::Circumference() const
{
    return 2 * PI * radius;
}
// 计算圆的面积
float Circle::Area() const
{
    return PI * radius * radius;
}
void main ()
{
    float radius;
    float FenceCost, ConcreteCost;
    
    // 提示用户输入半径
    cout&amp;lt;&amp;lt;&quot;Enter the radius of the pool: &quot;;
    cin&amp;gt;&amp;gt;radius;
    
    // 声明 Circle 对象
    Circle Pool(radius);
    Circle PoolRim(radius + 3);
    
    //计算栅栏造价并输出
    FenceCost=PoolRim.Circumference()*FencePrice;
    cout&amp;lt;&amp;lt;&quot;Fencing Cost is ￥&quot;&amp;lt;&amp;lt;FenceCost&amp;lt;&amp;lt;endl;
    
    //计算过道造价并输出
    ConcreteCost=(PoolRim.Area()-
    Pool.Area())*ConcretePrice;
    cout&amp;lt;&amp;lt;&quot;Concrete Cost is ￥&quot;&amp;lt;&amp;lt;ConcreteCost&amp;lt;&amp;lt;endl;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Enter the radius of the pool: 10
Fencing Cost is ￥2858.85
Concrete Cost is ￥4335.39&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 12 Mar 2019 15:08:00 +0000</pubDate>
<dc:creator>鲸90830</dc:creator>
<og:description>构造函数与析构函数 OOP第二课 1 构造函数 1.1 构造函数具有一些特殊的性质 1.2 定义构造函数的一般形式 1.3 利用构造函数创建对象 2 成员初始化表 3 缺省参数的构造函数 4 重载构造</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/whale90830/p/10520316.html</dc:identifier>
</item>
<item>
<title>解决和排查 &quot;必须使用适当的属性和方法修改 User-Agent&quot;  错误时遇到的一些坑 - BUTTERAPPLE</title>
<link>http://www.cnblogs.com/xiyin/p/10520156.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiyin/p/10520156.html</guid>
<description>&lt;h2 id=&quot;解决-必须使用适当的属性和方法修改-user-agent-错误&quot;&gt;解决 必须使用适当的属性和方法修改 User-Agent 错误&lt;/h2&gt;
&lt;p&gt;问题描述：近在项目中有一个需求为需要在 &lt;code&gt;Http&lt;/code&gt; 的Header里面添加一个User-Agent参数，当请求时。项目本身的目标框架是 &lt;code&gt;.NET Standard 2.0&lt;/code&gt;。于是，在项目源码中发现了，最终调用的请求是使用 &lt;code&gt;HttpWebRequest&lt;/code&gt; 来进行最后的封装和发送的。&lt;/p&gt;
&lt;p&gt;首先是用 &lt;code&gt;HttpRequest&lt;/code&gt; 包装的，代码如下：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;request.Headers[&quot;User-Agent&quot;] = &quot;Windows 10.0.2.4&quot;；&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后到最后发请求时，&lt;code&gt;foreach&lt;/code&gt; 这个Headers 的 Dictionary&amp;lt;string,string&amp;gt; 类型的，然后copy to &lt;code&gt;HttpWebRequest&lt;/code&gt; 的这个Header中&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;foreach (var header in request.Headers)
{
    httpWebRequest.Headers.Add(header.Key, header.Value);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;本地也进行了相关的 UT 和 FT，一切都很完美。然后发布了新版本。&lt;/p&gt;
&lt;p&gt;版本发布后的第三天，接到了用户的一个反馈说：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在调用最新Nuget版本的包后，请求调用一直报错：&lt;strong&gt;必须使用适当的属性和方法修改 User-Agent&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先先让用户回退到上一个版本的包，然后询问了用户的目标框架，用户说是&lt;code&gt;.Net framework 4.6.1&lt;/code&gt;，刚开始我以为是不是我项目中引用的某个包不支持该版本啊，沿着这个思路，果然有所发现。我发现在获取用户当前系统版本的时候使用了这个类&lt;a href=&quot;%5BOSDescription%5D(https://docs.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.runtimeinformation.osdescription?view=netframework-4.7.2#System_Runtime_InteropServices_RuntimeInformation_OSDescription)&quot;&gt;System.Runtime.InteropServices.RuntimeInformation.OSDescription&lt;/a&gt;，然后我发现这个属性可能为空，是不是属性空导致这个错误的呢？抱着试一试的态度，继续往下。&lt;/p&gt;
&lt;p&gt;去官方文档看了看，这个包最低支持的.net framework 框架为 4.7.1 。我想，那如果我在目标框架中也包含了.net framework 4.7.1 会不会就不报错了呢。&lt;/p&gt;
&lt;p&gt;继续沿着这个思路，我去寻找了： 如何在csproj 文件中指定多个 targetframework ，于是也便有了这个提问，&lt;a href=&quot;https://q.cnblogs.com/q/113561/&quot;&gt;如何发布多个 TargetFramework 的nuget 包&lt;/a&gt; 。当我设置完了这个目标框架，测试时发现，怎么还是不行呢。我发现我可能走错路了，可能根本就不是这个地方出现问题了，是不是我问题定位的有问题。而且奇怪的是，&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;为什么如果我本地目标框架是 .netcoreapp2.0 或者 .net standard2.0 时就不会报错呢？好奇怪。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;于是，我继续开始设置断点进行调试，最终发现了，每次走到下面这段代码时就会曝出上面那条错误：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt; httpWebRequest.Headers.Add(header.Key, header.Value);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这到底是为什么呢，为什么添加其他属性时就不会有这个错，终于还是在微软的官方文档上找到了答案：&lt;/p&gt;
&lt;blockquote readability=&quot;11.174085064293&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.net.httpwebrequest?view=netframework-4.7.2&quot;&gt;HttpWebRequest&lt;/a&gt; exposes common HTTP header values sent to the Internet resource as properties, set by methods, or set by the system; the following table contains a complete list. You can set other headers in the &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.net.httpwebrequest.headers?view=netframework-4.7.2&quot;&gt;Headers&lt;/a&gt; property as name/value pairs. Note that servers and caches may change or add headers during the request.&lt;/p&gt;
&lt;p&gt;The following table lists the HTTP headers that are set either by properties or methods or the system.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也就是说呢，如果你的Headers中没有包含上述的12个属性，我就当成它为保留属性把，你都可以用以下命令设置&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;httpWebRequest.Headers.Add(header.Key, header.Value);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然而当涉及到上述的属性的话，你就需要像下面这样&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;if(header.key.contains(&quot;User-Agent&quot;))
{
    httpWebRequest.UserAgent = &quot;Set as you like&quot;;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;总结起来还是经验不够，小问题定位错误导致排查错了方向，一旦找对方向，就很容易解决啦。&lt;/p&gt;
&lt;p&gt;PS：下一篇写一下 httpWebrequest 中的timeout，这个也坑死我了。&lt;/p&gt;
</description>
<pubDate>Tue, 12 Mar 2019 14:33:00 +0000</pubDate>
<dc:creator>BUTTERAPPLE</dc:creator>
<og:description>解决 必须使用适当的属性和方法修改 User Agent 错误 问题描述：近在项目中有一个需求为需要在 的Header里面添加一个User Agent参数，当请求时。项目本身的目标框架是 。于是，在项</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiyin/p/10520156.html</dc:identifier>
</item>
</channel>
</rss>