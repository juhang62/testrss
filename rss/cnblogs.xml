<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>2019年12月我主要的业力对应关系 - Wonder-YYC</title>
<link>http://www.cnblogs.com/chaogex/p/12114115.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chaogex/p/12114115.html</guid>
<description>&lt;p&gt;本文记录12月我的业力因果，分享给大家，愿协助世界意识更加地提升～感谢～&lt;/p&gt;

&lt;p&gt;花了一天时间回顾业力因果，发布了&lt;a href=&quot;https://www.cnblogs.com/chaogex/p/11939749.html&quot;&gt;《2019年9-11月份我主要的业力对应关系》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;第二天上午，我突然想起了年中尝试过的WebGPU。那时在我的电脑上没有跑起来，于是我就放弃了。我突然领悟到，也许是我电脑的操作系统版本太低，需要升级。于是我就升级了系统，结果就能运行WebGPU了！&lt;/p&gt;

&lt;p&gt;在我电脑上能够运行WebGPU&lt;/p&gt;

&lt;p&gt;我开始写&lt;a href=&quot;https://www.cnblogs.com/chaogex/p/12005108.html&quot;&gt;WebGPU学习&lt;/a&gt;系列博文。&lt;br/&gt;我的目的是：&lt;br/&gt;1.通过写文章，来促使自己进一步学习WebGPU&lt;br/&gt;2.把对应的学习记录分享出来，能加深我的理解&lt;br/&gt;3.WebGPU是新技术，目前相关资料很少。我如果能分享一些资料，那么等WebGPU正式发布火起来后，我分享的资料就会对大家很有帮助，这会增加我的影响力&lt;/p&gt;

&lt;p&gt;开始写WebGPU学习系列博文&lt;/p&gt;

&lt;p&gt;考虑写本书来专门介绍WebGPU&lt;/p&gt;

&lt;p&gt;考虑写本书来专门介绍WebGPU&lt;/p&gt;

&lt;p&gt;上午一直思考写这本书，下午在博客园上就收到两个约稿的短信&lt;/p&gt;

&lt;p&gt;花了一个星期写完了WebGPU学习系列第5篇博文&lt;/p&gt;

&lt;p&gt;有个知乎大v关注了我；&lt;br/&gt;第二个星期写不进去了，想打游戏。结果安装2个游戏，全部出错；安装网络游戏，要么人少，要么卡。所以游戏只打了1天半，想必这是我的真我不想要我打游戏，所以给我设置了障碍！这样也好，感谢真我～让我能避免陷入游戏的泥坑中～&lt;/p&gt;

&lt;p&gt;写到WebGPU学习系列第10篇博文&lt;/p&gt;

&lt;p&gt;我突然领悟到，可以继续写《从0开发3D引擎和编辑器》系列博文（之前写了3篇），把目前我正在写的书（不是写WebGPU，而是写“从0开发3D引擎和编辑器”）的内容写到该系列中，作为书的第一遍的稿件。&lt;br/&gt;这样做有以下的好处：&lt;br/&gt;1.可以作为书的第一遍草稿&lt;br/&gt;2.即时给读者看和反馈&lt;br/&gt;3.使我能从写WebGPU学习系列博文，回归到写书的进程中&lt;/p&gt;

&lt;p&gt;领悟到，可以继续写《从0开发3D引擎和编辑器》系列博文&lt;/p&gt;

&lt;p&gt;第二天早上，我看到知乎上有人评论，问我写书的进展，希望我能公开书中更多的内容！&lt;/p&gt;
&lt;p&gt;这不就是真我给我的信息，要我继续写系列博文吗？哈哈！&lt;/p&gt;

&lt;p&gt;看到了别人分享的3个因果案例（&lt;a href=&quot;https://www.jianshu.com/p/6ff963c02751&quot;&gt;因果录：布施钱财后迅速以10倍回报，这样的事我竟经历了三次！&lt;/a&gt;），我感激地赞赏了50元：终于看到有人跟我一样，也从给予钱的行为中加倍获得钱了；&lt;br/&gt;看到了别人分享自己遇到的因果，我感激地赞赏了2元，因为这让我更加看到因果的力量。&lt;/p&gt;

&lt;p&gt;第4天，妈妈给3000元，用于缴费。缴完后剩余250元；&lt;br/&gt;第2天和第4天，陪朋友去医院，朋友请客吃饭等。另外，比较神奇的是发生了同步性：我在蛋糕店等朋友时，用电脑写作。当电脑没电了，我想打电话给朋友问他好久过来，结果他正好完事过来找我了！！！哈哈！同步性！）&lt;/p&gt;

&lt;p&gt;我看了&lt;a href=&quot;https://m.iqiyi.com/search.html?source=related&amp;amp;vfrm=2-3-0-1&amp;amp;key=%E5%9C%B0%E8%97%8F%E7%8E%8B%E8%8F%A9%E8%90%A8%E4%BC%A0%E5%A5%87&quot;&gt;“地藏王传奇”&lt;/a&gt;的最后几集，在这里分析下里面的因果：&lt;br/&gt;以前的妃子此时来找金大师，希望他能跟自己一起回国生活（金大师本来是新罗国的人，后来到中国创办了一个寺庙，当了主持）。这让金大师想起了往事（那时他是太子，武功很高，应该是上过战场杀过人。后来遇上了政变，妈妈被杀，妃子逃跑，然后自己也当和尚了，来到了中国），感到了愧疚（对妃子的愧疚：自己没有照顾好妃子；以及现在不能再和她一起生活，回到从前了。）和愤怒（对政变和母亲被杀的愤怒）&lt;/p&gt;

&lt;p&gt;不久，就有一伙强盗，抢劫了与金大师所在寺庙相关的尼姑庵，杀害了金大师的一些朋友&lt;/p&gt;
&lt;p&gt;分析：这个果之所以在这个时间点显化，应该是金大师想起了往事，感到了愧疚和愤怒，从而使以前的因显化成了果。&lt;br/&gt;我们来看下这个果的对应关系：&lt;br/&gt;这个果表达了愤怒（对强盗的愤怒）和愧疚（金大师对自己受害的朋友的愧疚），也表达了暴力（对应于金大师以前上过战场的经历），这与因是完全对应的！！！&lt;/p&gt;
&lt;p&gt;这让我们再一次看到，种什么因，得什么果！&lt;/p&gt;
&lt;p&gt;如果金大师能完全觉醒，意识到一切都是体验，一切都是来服务他的，彻底原谅往事，也不再感到愧疚和愤怒，意识到我们来这个世界是来享受生活的，是来让自己高兴而不是来受罪的，那么应该就会使这个因不会结果，金大师也不会遭遇强盗这种激烈的事件。而且就算这个因还是会结果，金大师也会经历较温和的事件！&lt;/p&gt;

&lt;p&gt;晚上和朋友、妈妈一起进行了深度交流&lt;/p&gt;

&lt;p&gt;1.晚上回家，阅读《轻而易举的富足2》时，随手翻到的文章是：我敞开自己，去明白眼前事物的真正意义，接收真我的指引，否认“拒绝接收现实”！&lt;/p&gt;
&lt;p&gt;在晚上的交流中，我被建议要接受现实，说我在拒绝接受现实。结果晚上回家就接收到要否认“拒绝接收现实”的信息，哈哈！！！感谢真我的指引！谢谢你！&lt;/p&gt;
&lt;p&gt;2.第二天早上，看到知乎上增加了12个关注者。这是第一次在一天内有这么多增加的粉丝！感谢！&lt;br/&gt;这难道是因为在晚上的交流中，我的一些观点被朋友和妈妈认同，导致他们变成了我的“粉丝”，所以显化在知乎上吗？？？哈哈！&lt;br/&gt;或者准确来说，通过交流，让我对我自己的观点更加认同了，从而使我成了自己的粉丝，所以显化在知乎上！&lt;/p&gt;
</description>
<pubDate>Sat, 28 Dec 2019 23:17:00 +0000</pubDate>
<dc:creator>Wonder-YYC</dc:creator>
<og:description>本文记录12月我的业力因果，分享给大家，愿协助世界意识更加地提升～感谢～</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chaogex/p/12114115.html</dc:identifier>
</item>
<item>
<title>程序写日志文件时该不该加锁 - 毛阳</title>
<link>http://www.cnblogs.com/wudanyang/p/12113348.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wudanyang/p/12113348.html</guid>
<description>&lt;h2&gt;日志（log）&lt;/h2&gt;
&lt;p&gt;为了让自己的思路更加清晰，下面我都会称日志为 log。因为日志这个词有两种含义，详情见&lt;a href=&quot;https://baike.baidu.com/item/%E6%97%A5%E5%BF%97/1678&quot; target=&quot;_blank&quot;&gt;百度百科释义&lt;/a&gt;或者&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%97%A5%E5%BF%97&quot; target=&quot;_blank&quot;&gt;维基百科释义&lt;/a&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;a title=&quot;日记&quot; href=&quot;https://zh.wikipedia.org/wiki/%E6%97%A5%E8%AE%B0&quot; target=&quot;_blank&quot;&gt;日记&lt;/a&gt;的另一种说法。“志”字本身为“记录”的意思，日志就为每日的记录（通常是跟作者有关的）。&lt;/li&gt;
&lt;li&gt;&lt;a title=&quot;服务器日志&quot; href=&quot;https://zh.wikipedia.org/wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%97%A5%E5%BF%97&quot; target=&quot;_blank&quot;&gt;服务器日志&lt;/a&gt;（&lt;span lang=&quot;en&quot;&gt;server log），记录服务器等电脑设备或软件的运作。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;我们这里说的当然是服务器日志，也就是  &lt;span class=&quot;cnblogs_code&quot;&gt;server log&lt;/span&gt; 。&lt;/p&gt;
&lt;h2&gt;写入 log&lt;/h2&gt;
&lt;p&gt;一般写入 log 都会遵循以下步骤：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; fd =&lt;span&gt; open(path)&lt;br/&gt;write(fd, sign_append)
fclose(fd)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;解释一下上面的代码：&lt;/p&gt;
&lt;p&gt;1. int fd = open(path) &lt;/p&gt;
&lt;p&gt;会通过系统调用打开一个文件描述符，或者在其他语言中也可以称作资源描述符，资源类型，或句柄。&lt;/p&gt;

&lt;p&gt;2. write(fd, append = 1)&lt;/p&gt;
&lt;p&gt;write 系统调用，并加上 append 标志，会执行 seek 和 write 两个系统调用，但是这种系统调用是原子性的。&lt;/p&gt;
&lt;p&gt;原子性意味着 seek 和 write 会同时执行，不会有两个线程产生交叉，必须 a 线程执行完 seek 和 write ，b 线程才能继续执行（这里说线程，是因为线程才是 cpu 调度的基本单位）。&lt;/p&gt;
&lt;p&gt;所以在 nginx 中，我们加上 append 标志，就不用对线程上锁了。&lt;/p&gt;

&lt;p&gt;3. fclose(fd)&lt;/p&gt;
&lt;p&gt;关闭描述符。&lt;/p&gt;
&lt;p&gt;linux 一般对打开的文件描述符有一个最大数量的限制，如果不关闭描述符，很有可能造成大 bug。&lt;/p&gt;
&lt;p&gt;查看 linux 中限制的方法如下（其中 open files 代表可以打开的文件数量）:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
$ ulimit -&lt;span&gt;a

core file size (blocks, &lt;/span&gt;-c) &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
data seg size (kbytes, &lt;/span&gt;-&lt;span&gt;d) unlimited
scheduling priority (&lt;/span&gt;-e) &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
file size (blocks, &lt;/span&gt;-&lt;span&gt;f) unlimited
pending signals (&lt;/span&gt;-i) &lt;span&gt;15732&lt;/span&gt;&lt;span&gt;
max locked memory (kbytes, &lt;/span&gt;-l) &lt;span&gt;64&lt;/span&gt;&lt;span&gt;
max memory size (kbytes, &lt;/span&gt;-&lt;span&gt;m) unlimited
&lt;span&gt;open files&lt;/span&gt; (&lt;/span&gt;-n) &lt;span&gt;1024&lt;/span&gt;&lt;span&gt;
pipe size (&lt;/span&gt;&lt;span&gt;512&lt;/span&gt; bytes, -p) &lt;span&gt;8&lt;/span&gt;&lt;span&gt;
POSIX message queues (bytes, &lt;/span&gt;-q) &lt;span&gt;819200&lt;/span&gt;&lt;span&gt;
real&lt;/span&gt;-time priority (-r) &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
stack size (kbytes, &lt;/span&gt;-s) &lt;span&gt;8192&lt;/span&gt;&lt;span&gt;
cpu time (seconds, &lt;/span&gt;-&lt;span&gt;t) unlimited
max user processes (&lt;/span&gt;-u) &lt;span&gt;15732&lt;/span&gt;
&lt;span&gt;virtual&lt;/span&gt; memory (kbytes, -&lt;span&gt;v) unlimited
file locks (&lt;/span&gt;-x) unlimited
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/713751/201912/713751-20191228231858498-880708322.png&quot; alt=&quot;&quot; width=&quot;505&quot; height=&quot;53&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;所以，如果是系统调用，那么 append 不用加锁。&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;

&lt;h2&gt;为什么 php 语言写日志时用了 append 也要加锁？&lt;/h2&gt;
&lt;p&gt;如果根据上面的说法，咱们可以设置好 write 的 append 标志，然后就可以睡大觉去了，文件永远不会冲突。&lt;/p&gt;
&lt;p&gt;但是（一般都有个但是）你去看 php 的框架中都会在 file_put_contents 的 append 之前加锁。&lt;/p&gt;
&lt;p&gt;于是，怀疑是因为 file_put_contents 的底层实现没有实现原子性。&lt;/p&gt;
&lt;p&gt;跟进源码（非 php 程序员或者对 php 底层源码无兴趣的可以跳过了）：&lt;/p&gt;
&lt;p&gt;file_put_contents 底层实现： &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;98&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; file.c&lt;/span&gt;&lt;span&gt;
/*&lt;/span&gt;&lt;span&gt; {{{ proto int|false file_put_contents(string file, mixed data [, int flags [, resource context]])
   Write/Create a file with contents data and return the number of bytes written &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
PHP_FUNCTION(file_put_contents)
{
...
&lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; IS_STRING:
   &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Z_STRLEN_P(data)) {
      numbytes &lt;/span&gt;=&lt;span&gt; php_stream_write(stream, Z_STRVAL_P(data), Z_STRLEN_P(data));
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (numbytes !=&lt;span&gt; Z_STRLEN_P(data)) {
         php_error_docref(NULL, E_WARNING, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Only %zd of %zd bytes written, possibly out of free disk space&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, numbytes, Z_STRLEN_P(data));
         numbytes &lt;/span&gt;= -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
      }
   }
   &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
...
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; php_streams.h&lt;/span&gt;
PHPAPI ssize_t _php_stream_write(php_stream *stream, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;buf, size_t count);
&lt;/span&gt;&lt;span&gt;#define&lt;/span&gt; php_stream_write_string(stream, str)   _php_stream_write(stream, str, strlen(str))
&lt;span&gt;#define&lt;/span&gt; php_stream_write(stream, buf, count)   _php_stream_write(stream, (buf), (count))

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; streams.c&lt;/span&gt;
PHPAPI ssize_t _php_stream_write(php_stream *stream, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;buf, size_t count)
{
　　...
   &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (stream-&amp;gt;&lt;span&gt;writefilters.head) {
      bytes &lt;/span&gt;=&lt;span&gt; _php_stream_write_filtered(stream, buf, count, PSFS_FLAG_NORMAL);
   } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      bytes &lt;/span&gt;=&lt;span&gt; _php_stream_write_buffer(stream, buf, count);
   }

   &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (bytes) {
      stream&lt;/span&gt;-&amp;gt;flags |=&lt;span&gt; PHP_STREAM_FLAG_WAS_WRITTEN;
   }

   &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; bytes;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Writes a buffer directly to a stream, using multiple of the chunk size &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; ssize_t _php_stream_write_buffer(php_stream *stream, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;buf, size_t count){
...
&lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (count &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
   ssize_t justwrote &lt;/span&gt;= stream-&amp;gt;ops-&amp;gt;&lt;span&gt;write(stream, buf, count);
   &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (justwrote &amp;lt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; If we already successfully wrote some bytes and a write error occurred
       * later, report the successfully written bytes. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt; (didwrite == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
         &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; justwrote;
      }
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; didwrite;
   }

   buf &lt;/span&gt;+=&lt;span&gt; justwrote;
   count &lt;/span&gt;-=&lt;span&gt; justwrote;
   didwrite &lt;/span&gt;+=&lt;span&gt; justwrote;

   &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Only screw with the buffer if we can seek, otherwise we lose data
    * buffered from fifos and sockets &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
   &lt;span&gt;if&lt;/span&gt; (stream-&amp;gt;ops-&amp;gt;seek &amp;amp;&amp;amp; (stream-&amp;gt;flags &amp;amp; PHP_STREAM_FLAG_NO_SEEK) == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
      stream&lt;/span&gt;-&amp;gt;position +=&lt;span&gt; justwrote;
   }
}

}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; php_streams.h&lt;/span&gt;&lt;span&gt;
/*&lt;/span&gt;&lt;span&gt; operations on streams that are file-handles &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
typedef &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; _php_stream_ops  {
   &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; stdio like functions - these are mandatory! &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
   ssize_t (&lt;/span&gt;*write)(php_stream *stream, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;buf, size_t count);
   ssize_t (&lt;/span&gt;*read)(php_stream *stream, &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;buf, size_t count);
   &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;    (*close)(php_stream *stream, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; close_handle);
   &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;    (*flush)(php_stream *&lt;span&gt;stream);

   &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *label; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; label for this ops structure &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; these are optional &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
   &lt;span&gt;int&lt;/span&gt; (*seek)(php_stream *stream, zend_off_t offset, &lt;span&gt;int&lt;/span&gt; whence, zend_off_t *&lt;span&gt;newoffset);
   &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; (*cast)(php_stream *stream, &lt;span&gt;int&lt;/span&gt; castas, &lt;span&gt;void&lt;/span&gt; **&lt;span&gt;ret);
   &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; (*stat)(php_stream *stream, php_stream_statbuf *&lt;span&gt;ssb);
   &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; (*set_option)(php_stream *stream, &lt;span&gt;int&lt;/span&gt; option, &lt;span&gt;int&lt;/span&gt; value, &lt;span&gt;void&lt;/span&gt; *&lt;span&gt;ptrparam);
} php_stream_ops;
 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; plain_wrapper.c&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; ssize_t php_stdiop_write(php_stream *stream, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;buf, size_t count)
{
   php_stdio_stream_data &lt;/span&gt;*data = (php_stdio_stream_data*)stream-&amp;gt;&lt;span&gt;abstract&lt;/span&gt;&lt;span&gt;;

   assert(data &lt;/span&gt;!=&lt;span&gt; NULL);

   &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (data-&amp;gt;fd &amp;gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
#ifdef PHP_WIN32
      ssize_t bytes_written;
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ZEND_SIZE_T_UINT_OVFL(count)) {
         count &lt;/span&gt;=&lt;span&gt; UINT_MAX;
      }
      bytes_written &lt;/span&gt;= _write(data-&amp;gt;fd, buf, (unsigned &lt;span&gt;int&lt;/span&gt;&lt;span&gt;)count);
&lt;/span&gt;&lt;span&gt;#else&lt;/span&gt;&lt;span&gt;
      ssize_t bytes_written &lt;/span&gt;= write(data-&amp;gt;&lt;span&gt;fd, buf, count);
&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt; (bytes_written &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
         &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (errno == EWOULDBLOCK || errno ==&lt;span&gt; EAGAIN) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
         }
         &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (errno ==&lt;span&gt; EINTR) {
            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; TODO: Should this be treated as a proper error or not? &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; bytes_written;
         }
         php_error_docref(NULL, E_NOTICE, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;write of %zu bytes failed with errno=%d %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, count, errno, strerror(errno));
      }
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; bytes_written;
   } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {

&lt;/span&gt;&lt;span&gt;#if&lt;/span&gt; HAVE_FLUSHIO
      &lt;span&gt;if&lt;/span&gt; (data-&amp;gt;is_seekable &amp;amp;&amp;amp; data-&amp;gt;last_op == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) {
         zend_fseek(data&lt;/span&gt;-&amp;gt;file, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, SEEK_CUR);
      }
      data&lt;/span&gt;-&amp;gt;last_op = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

      &lt;span&gt;return&lt;/span&gt; (ssize_t) fwrite(buf, &lt;span&gt;1&lt;/span&gt;, count, data-&amp;gt;&lt;span&gt;file);
   }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这个函数最终调用的是函数 php_stdiop_write &lt;/p&gt;
&lt;p&gt;函数 _php_stream_write_buffer 中会将字符串分成多个 chunksize ，每个 chunksize 为 8096 字节，分别进行 write。&lt;/p&gt;
&lt;p&gt;如果不加锁，那么超过 8096 字节之后，多个进程写日志就会出现混乱。&lt;/p&gt;
&lt;p&gt;而且，php 文档也说明了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/713751/201912/713751-20191229014336853-1763999463.png&quot; alt=&quot;&quot; width=&quot;367&quot; height=&quot;114&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/713751/201912/713751-20191229014404263-1029400022.png&quot; alt=&quot;&quot; width=&quot;770&quot; height=&quot;96&quot;/&gt;&lt;/p&gt;


&lt;p&gt; &lt;span&gt;&lt;em id=&quot;__mceDel&quot;&gt;所以，最终需要根据不同的语言，具体分析。&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 28 Dec 2019 17:48:00 +0000</pubDate>
<dc:creator>毛阳</dc:creator>
<og:description>程序写日志文件时该不该加锁 日志（log） 为了让自己的思路更加清晰，下面我都会称日志为 log。因为日志这个词有两种含义，详情见百度百科释义或者维基百科释义。 日记的另一种说法。“志”字本身为“记录</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wudanyang/p/12113348.html</dc:identifier>
</item>
<item>
<title>github 项目搜索技巧-让你更高效精准地搜索项目 - suwanbin</title>
<link>http://www.cnblogs.com/suwanbin/p/12113751.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/suwanbin/p/12113751.html</guid>
<description>&lt;blockquote readability=&quot;6.625&quot;&gt;
&lt;p&gt;参考自 B站 up 主 CodeSheep 的视频【&lt;a href=&quot;https://www.bilibili.com/video/av75587104&quot;&gt;如何高效地在网上找开源项目做！在职程序员实际演示一波视频教程操作&lt;/a&gt;】，然后写着写着一好奇就去看文档了&lt;/p&gt;
&lt;p&gt;现在这篇博客相当于官方文档的翻译版😂&lt;/p&gt;
&lt;p&gt;当然，你也可以去看【&lt;a href=&quot;https://help.github.com/en/github/searching-for-information-on-github/searching-on-github&quot;&gt;官方文档&lt;/a&gt;】体验原汁原味的教程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;干啥的？相当于给搜索结果添加过滤条件，看下下面的案例你就知道啦，过滤 github 的搜索结果，更精确搜索项目&lt;/p&gt;
&lt;h2 id=&quot;案例&quot;&gt;案例&lt;/h2&gt;
&lt;h3 id=&quot;普通搜&quot;&gt;普通搜&lt;/h3&gt;
&lt;p&gt;关键词：&lt;code&gt;python&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1725797/201912/1725797-20191229001422476-1910036534.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;搭配技巧搜&quot;&gt;搭配技巧搜&lt;/h3&gt;
&lt;p&gt;搜索 github 中，项目描述（description）中有 python 并且 2019-12-20 号之后有更新过的项目&lt;/p&gt;
&lt;p&gt;&lt;code&gt;in:description python pushed:&amp;gt;2019-12-20&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;效果&lt;/strong&gt;：加了限制条件后，查出来的项目数有了明显的减少&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1725797/201912/1725797-20191229001434989-1886740901.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;限定词&quot;&gt;限定词&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;可通过指定 &lt;code&gt;仓库名(repository name)、项目描述(description)、内容(contents)、说明文件(readme.md)&lt;/code&gt; 来搜索项目&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;in:name&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;in:name python&lt;/code&gt; 查出仓库名中有 &lt;code&gt;python&lt;/code&gt; 的项目（&lt;code&gt;python in:name&lt;/code&gt; 也是一样的）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&lt;code&gt;in:description&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;in:name,description python&lt;/code&gt; 查出仓库名或者项目描述中有 &lt;code&gt;python&lt;/code&gt; 的项目&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;in:readme&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;in:readme python&lt;/code&gt; 查出 readme.md 文件里有 &lt;code&gt;python&lt;/code&gt; 的项目&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&lt;code&gt;repo:owner/name&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;repo:octocat/hello-world&lt;/code&gt; 查出 octocat 的 hello-world 项目（指定了某个人的某个项目）&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;其他骚操作？自己看官方文档（感觉用不到，就不整理了吧）：【&lt;a href=&quot;https://help.github.com/en/github/searching-for-information-on-github/finding-files-on-github&quot;&gt;找仓库中的某个文件&lt;/a&gt;】、【&lt;a href=&quot;https://help.github.com/en/github/searching-for-information-on-github/searching-code&quot;&gt;在 github 上查找代码片段&lt;/a&gt;】&lt;/p&gt;
&lt;h3 id=&quot;查找某个用户或组织的项目&quot;&gt;查找某个用户或组织的项目&lt;/h3&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;user:USERNAME&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;user:1335951413 stars:&amp;lt;10&lt;/code&gt; 查出用户 1335951413 名下 stars 少于 10 的项目&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;org:ORGNAME&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;org:github&lt;/code&gt; 查出 github 名下的项目&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;辅助限定词&quot;&gt;辅助限定词&lt;/h2&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;可以通过限制 &lt;code&gt;项目大小(size)、拥护者数(followers)、fork数(forks)、stars数(stars)、创建时间(created)、更新时间(pushed)、项目所用语言(language)、topic标签(topic)、topic标签数(topics)...&lt;/code&gt; 来筛选项目&lt;/p&gt;
&lt;p&gt;辅助限定词可以多个并用，用空格隔开就行，可以搭配限定词使用，也可单独使用&lt;/p&gt;
&lt;p&gt;（关于项目是否被 fork 这个点我不是很懂，就不写案例了）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;16.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;stars:n&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;stars:&amp;gt;=5&lt;/code&gt; 查出 &lt;strong&gt;star数大于等于 5 个&lt;/strong&gt; 的项目（支持大于小于区间等）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&lt;code&gt;pushed:YYYY-MM-DD&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;css pushed:&amp;gt;2013-02-01&lt;/code&gt; 查出仓库中&lt;strong&gt;包含 css 关键字，并且在 2013年1月 之后更新过&lt;/strong&gt;的项目&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&lt;code&gt;language:LANGUAGE&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;rails language:javascript&lt;/code&gt; 查出仓库&lt;strong&gt;包含 rails 关键字，并且使用 javscript 语言&lt;/strong&gt;的项目&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&lt;code&gt;created:YYYY-MM-DD&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;webos created:&amp;lt;2011-01-01&lt;/code&gt; 查出仓库中&lt;strong&gt;包含 webos 关键字并且是在 2011 年之前创建&lt;/strong&gt;的项目（也支持时分秒，支持大于小于区间等）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&lt;code&gt;size:n&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;size:1000&lt;/code&gt; 查出仓库大小&lt;strong&gt;等于 1MB&lt;/strong&gt; 的项目&lt;br/&gt;&lt;code&gt;size:&amp;gt;=30000&lt;/code&gt; 查出仓库大小&lt;strong&gt;至少大于 30MB&lt;/strong&gt; 的项目&lt;br/&gt;&lt;code&gt;size:50..120&lt;/code&gt; 查出仓库大小&lt;strong&gt;在 50KB 至 120KB 之间&lt;/strong&gt;的项目&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&lt;code&gt;followers:n&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;followers:1000&lt;/code&gt; 查出&lt;strong&gt;有 1000 个拥护者（followers）&lt;/strong&gt; 的项目（支持大于小于区间等）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;forks:n&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;forks:5&lt;/code&gt; 查出&lt;strong&gt;有 5 个 forks&lt;/strong&gt; 的项目（支持大于小于区间等）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&lt;code&gt;topic:TOPIC&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;topic:jekyll&lt;/code&gt; 查出&lt;strong&gt;含有 jekyll 这个 topic 的项目（项目描述下面的东西，相当于标签、分类）&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;topics:n&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;topics:&amp;gt;5&lt;/code&gt; 查出&lt;strong&gt;有 5 个以上 topic&lt;/strong&gt; 的项目（支持大于小于区间等）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&lt;code&gt;archived:true/false&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;archived:true GNOME&lt;/code&gt; 查出&lt;strong&gt;已经封存了并且含有 GNOME 关键字&lt;/strong&gt;的项目（已经不再维护了的项目）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;is:public/private&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;is:public org:github&lt;/code&gt; 查出&lt;strong&gt;仓库所有组织是 github 并且公开&lt;/strong&gt;的项目&lt;br/&gt;&lt;code&gt;is:private github&lt;/code&gt; 查出&lt;strong&gt;含有 github 关键字并且是私有&lt;/strong&gt;的项目（私有的别人看不到，所以这个是用来搜索自己的私有项目的）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;license:LICENSE_KEYWORD&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;license:apache-2.0&lt;/code&gt; 查出仓库的开源协议是 apache-2.0 的&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;还没搞懂的关于-forksmirrorissues&quot;&gt;还没搞懂的（关于 forks、mirror、issues）&lt;/h3&gt;
&lt;ul readability=&quot;0.80484848484848&quot;&gt;&lt;li readability=&quot;1.4848484848485&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/search?q=stars%3A%3E%3D500+fork%3Atrue+language%3Aphp&amp;amp;type=Repositories&quot;&gt;&lt;strong&gt;stars:&amp;gt;=500 fork:true language:php&lt;/strong&gt;&lt;/a&gt; matches repositories with the at least 500 stars, including forked ones, that are written in PHP.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/search?q=case+pushed%3A%3E%3D2013-03-06+fork%3Aonly&amp;amp;type=Repositories&quot;&gt;&lt;strong&gt;case pushed:&amp;gt;=2013-03-06 fork:only&lt;/strong&gt;&lt;/a&gt; matches repositories with the word &quot;case&quot; that were pushed to on or after March 6th, 2013, and that are forks.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/search?utf8=%E2%9C%93&amp;amp;q=mirror%3Atrue+GNOME&amp;amp;type=&quot;&gt;&lt;strong&gt;mirror:true GNOME&lt;/strong&gt;&lt;/a&gt; matches repositories that are mirrors and contain the word &quot;GNOME.&quot; 查出是镜像并且包含 GNOME 关键字的项目（github 上 mirror 啥意思不太懂）&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/search?utf8=%E2%9C%93&amp;amp;q=mirror%3Afalse+GNOME&amp;amp;type=&quot;&gt;&lt;strong&gt;mirror:false GNOME&lt;/strong&gt;&lt;/a&gt; matches repositories that are not mirrors and contain the word &quot;GNOME.&quot;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/search?utf8=%E2%9C%93&amp;amp;q=javascript+good-first-issues%3A%3E2&amp;amp;type=&quot;&gt;&lt;strong&gt;good-first-issues:&amp;gt;2 javascript&lt;/strong&gt;&lt;/a&gt; matches repositories with more than two issues labeled &lt;code&gt;good-first-issue&lt;/code&gt; and that contain the word &quot;javascript.&quot;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/search?utf8=%E2%9C%93&amp;amp;q=react+help-wanted-issues%3A%3E4&amp;amp;type=&quot;&gt;&lt;strong&gt;help-wanted-issues:&amp;gt;4 react&lt;/strong&gt;&lt;/a&gt; matches repositories with more than four issues labeled &lt;code&gt;help-wanted&lt;/code&gt; and that contain the word &quot;React.&quot;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;排序放的是官网的链接&quot;&gt;排序（放的是官网的链接）&lt;/h2&gt;
&lt;blockquote readability=&quot;5.5461538461538&quot;&gt;
&lt;p&gt;推荐直接在页面上的搜索结果点击排序，何必再去学一手呢？&lt;/p&gt;
&lt;p&gt;官网文档：【&lt;a href=&quot;https://help.github.com/en/github/searching-for-information-on-github/sorting-search-results&quot;&gt;给你的查询结果排序&lt;/a&gt;】&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1725797/201912/1725797-20191229001443284-837886959.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;自己灵活的使用限定词和辅助限定词写出一套规则即可查出你想要的项目&lt;/p&gt;
&lt;p&gt;他们的位置先后、数量都无所谓，加上只是多了一个条件&lt;/p&gt;
&lt;h2 id=&quot;练习案例&quot;&gt;练习案例&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;常用到的其实有就是这些，上面的还是太多了，你有那个需求，又找不到方式的时候可以查查看&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;# 项目名字(name)里有 python 的
in:name python

# 名字(name)里有 python 的并且 stars 大于 3000 的
in:name python starts:&amp;gt;3000

# 名字(name)里有 python 的并且 stars 大于 3000 、forks 大于 200 的
in:name python starts:&amp;gt;3000 forks:&amp;gt;200


# 详情(readme)里面有 python 的并且 stars 大于 3000 的
in:readme python starts:&amp;gt;3000

# 描述(description)里面有 python 的并且 stars 大于 3000 的
in:description python starts:&amp;gt;3000

# 描述(description)里面有 python 的并且是 python 语言的
in:description python language:python

# 描述(description)里面有 python 的并且 2019-12-20 号之后有更新过的
in:description python pushed:&amp;gt;2019-12-20&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 28 Dec 2019 16:15:00 +0000</pubDate>
<dc:creator>suwanbin</dc:creator>
<og:description>[toc] github 搜索技巧 参考自 B站 up 主 CodeSheep 的视频【 &amp;quot;如何高效地在网上找开源项目做！在职程序员实际演示一波视频教程操作&amp;quot; 】，然后写着写着一好</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/suwanbin/p/12113751.html</dc:identifier>
</item>
<item>
<title>JAVA8学习——深入浅出Lambda表达式（学习过程） - dawa大娃bigbaby</title>
<link>http://www.cnblogs.com/bigbaby/p/12113741.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bigbaby/p/12113741.html</guid>
<description>&lt;hr/&gt;
&lt;h2 id=&quot;lambda表达式&quot;&gt;lambda表达式：&lt;/h2&gt;
&lt;h3 id=&quot;我们为什么要用lambda表达式&quot;&gt;我们为什么要用lambda表达式&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;在JAVA中，我们无法将函数作为参数传递给一个方法，也无法声明返回一个函数的方法。&lt;/li&gt;
&lt;li&gt;在JavaScript中，函数参数是一个函数，返回值是另一个函数的情况下非常常见的，JavaScript是一门非常典型的函数式编程语言，面向对象的语言&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;//如，JS中的函数作为参数
a.execute(callback(event){
    event...
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Java匿名内部类实例&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;后面补充一个匿名内部类的代码实例&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我这里Gradle的使用来构建项目&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;需要自行补充对Gradle的学习&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Gradle完全可以使用Maven的所有能力&lt;br/&gt;Maven基于XML的配置文件，Gradle是基于编程式配置.Gradle文件&lt;/p&gt;
&lt;p&gt;自定义匿名内部类&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class SwingTest {
    public static void main(String[] args) {
        JFrame jFrame = new JFrame(&quot;my Frame&quot;);
        JButton jButton = new JButton(&quot;My Button&quot;);
        jButton.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent actionEvent) {
                System.out.println(&quot;Button Pressed&quot;);
            }
        });
        jFrame.add(jButton);
        jFrame.pack();
        jFrame.setVisible(true);
        jFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;改造前：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;jButton.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent actionEvent) {
                System.out.println(&quot;Button Pressed&quot;);
            }
        });&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;改造后：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;jButton.addActionListener(actionEvent -&amp;gt; System.out.println(&quot;Button Pressed&quot;));&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;lambda表达式的基本结构&quot;&gt;Lambda表达式的基本结构&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;会有自动推断参数类型的功能&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;（pram1,pram2,pram3）-&amp;gt;{
    
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;函数式接口&quot;&gt;函数式接口&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;概念后期补(接口文档源码，注解源码)
抽象方法，抽象接口
1个接口里面只有一个抽象方法，可以有几个具体的方法

/**
 * An informative annotation type used to indicate that an interface
 * type declaration is intended to be a &amp;lt;i&amp;gt;functional interface&amp;lt;/i&amp;gt; as
 * defined by the Java Language Specification.
 *
 * Conceptually, a functional interface has exactly one abstract
 * method.  Since {@linkplain java.lang.reflect.Method#isDefault()
 * default methods} have an implementation, they are not abstract.  If
 * an interface declares an abstract method overriding one of the
 * public methods of {@code java.lang.Object}, that also does
 * &amp;lt;em&amp;gt;not&amp;lt;/em&amp;gt; count toward the interface's abstract method count
 * since any implementation of the interface will have an
 * implementation from {@code java.lang.Object} or elsewhere.
 *
 * &amp;lt;p&amp;gt;Note that instances of functional interfaces can be created with
 * lambda expressions, method references, or constructor references.
 *
 * &amp;lt;p&amp;gt;If a type is annotated with this annotation type, compilers are
 * required to generate an error message unless:
 *
 * &amp;lt;ul&amp;gt;
 * &amp;lt;li&amp;gt; The type is an interface type and not an annotation type, enum, or class.
 * &amp;lt;li&amp;gt; The annotated type satisfies the requirements of a functional interface.
 * &amp;lt;/ul&amp;gt;
 *
 * &amp;lt;p&amp;gt;However, the compiler will treat any interface meeting the
 * definition of a functional interface as a functional interface
 * regardless of whether or not a {@code FunctionalInterface}
 * annotation is present on the interface declaration.
 * 
 * @jls 4.3.2. The Class Object
 * @jls 9.8 Functional Interfaces
 * @jls 9.4.3 Interface Method Body
 * @since 1.8
 */
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface FunctionalInterface {}


关于函数式接口：
1.如何一个接口只有一个抽象方法，那么这个接口就是函数式接口
2.如果我们在某个接口上生命了FunctionalInterface注解，那么编译器就会按照函数式接口的定义来要求该注解
3.如果某个接口只有一个抽象方法，但我们没有给该接口生命FunctionalInterface接口，编译器也还会把该接口当做成一个函数是接口。（英文最后一段）&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过对实例对函数式接口深入理解&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;对
@FunctionalInterface
public interface MyInterface {
    void test();
}

错
@FunctionalInterface
public interface MyInterface {
    void test();

    String tostring1();
}

对 (tostring为重写Object类的方法)
@FunctionalInterface
public interface MyInterface {
    void test();

    String toString();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;升级扩展,使用lambda表达式&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@FunctionalInterface
interface MyInterface {
    void test();

    String toString();
}

public class Test2{
    public void myTest(MyInterface myInterface){
        System.out.println(&quot;1&quot;);
        myInterface.test();
        System.out.println(&quot;2&quot;);
    }

    public static void main(String[] args) {
        Test2 test2 = new Test2();
        //1.默认调用接口里面的接口函数。默认调用MyTest接口里面的test方法。
        //2.如果没有参数传入方法，那么可以直接使用（）来表达，如下所示
        test2.myTest(()-&amp;gt; System.out.println(&quot;mytest&quot;));
        
        MyInterface myInterface = () -&amp;gt; {
            System.out.println(&quot;hello&quot;);
        };

        System.out.println(myInterface.getClass()); //查看这个类
        System.out.println(myInterface.getClass().getSuperclass());//查看类的父类
        System.out.println(myInterface.getClass().getInterfaces()[0]);// 查看此类实现的接口
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;默认方法接口里面从1.8开始也可以拥有方法实现了&quot;&gt;默认方法：接口里面，从1.8开始，也可以拥有方法实现了。&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;默认方法既保证了新特性的添加，又保证了老版本的兼容&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;//如，Iterable 中的 forEach方法
public interface Iterable&amp;lt;T&amp;gt; {
    default void forEach(Consumer&amp;lt;? super T&amp;gt; action) {
        Objects.requireNonNull(action);
        for (T t : this) {
            action.accept(t);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;foreach方法详解&quot;&gt;ForEach方法详解&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;比较重要的是行为，//action行为，而不是数据&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;
/**
     * Performs the given action for each element of the {@code Iterable}
     * until all elements have been processed or the action throws an
     * exception.  Unless otherwise specified by the implementing class,
     * actions are performed in the order of iteration (if an iteration order
     * is specified).  Exceptions thrown by the action are relayed to the
     * caller.
     *
     * @implSpec
     * &amp;lt;p&amp;gt;The default implementation behaves as if:
     * &amp;lt;pre&amp;gt;{@code
     *     for (T t : this)
     *         action.accept(t);
     * }&amp;lt;/pre&amp;gt;
     *
     * @param action The action to be performed for each element
     * @throws NullPointerException if the specified action is null
     * @since 1.8
     */
    default void forEach(Consumer&amp;lt;? super T&amp;gt; action) {
        Objects.requireNonNull(action);
        for (T t : this) {
            action.accept(t);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;consumer-类型详解&quot;&gt;Consumer 类型详解&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;名字的由来：消费，只消费，没有返回值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * Represents an operation that accepts a single input argument and returns no
 * result. Unlike most other functional interfaces, {@code Consumer} is expected
 * to operate via side-effects.//接口本身是带有副作用的，会对传入的唯一参数进行修改
 *
 * &amp;lt;p&amp;gt;This is a &amp;lt;a href=&quot;package-summary.html&quot;&amp;gt;functional interface&amp;lt;/a&amp;gt;
 * whose functional method is {@link #accept(Object)}.
 *
 * @param &amp;lt;T&amp;gt; the type of the input to the operation
 *
 * @since 1.8
 */
@FunctionalInterface
public interface Consumer&amp;lt;T&amp;gt; {

    /**
     * Performs this operation on the given argument.
     *
     * @param t the input argument
     */
    void accept(T t);

    /**
     * Returns a composed {@code Consumer} that performs, in sequence, this
     * operation followed by the {@code after} operation. If performing either
     * operation throws an exception, it is relayed to the caller of the
     * composed operation.  If performing this operation throws an exception,
     * the {@code after} operation will not be performed.
     *
     * @param after the operation to perform after this operation
     * @return a composed {@code Consumer} that performs in sequence this
     * operation followed by the {@code after} operation
     * @throws NullPointerException if {@code after} is null
     */
    default Consumer&amp;lt;T&amp;gt; andThen(Consumer&amp;lt;? super T&amp;gt; after) {
        Objects.requireNonNull(after);
        return (T t) -&amp;gt; { accept(t); after.accept(t); };
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;lambda表达式的作用&quot;&gt;Lambda表达式的作用&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;Lambda表达式为JAVA添加了缺失的函数式编程特性，使我们能够将函数当做一等公民看待&lt;/li&gt;
&lt;li&gt;在将函数作为一等公民的语言中，Lambda表达式的类型是函数，但是在JAVA语言中，&lt;strong&gt;lambda表达式是一个对象&lt;/strong&gt;，他们必须依附于一类特别的对象类型——函数是接口（function interface）&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;迭代方式三种&quot;&gt;迭代方式（三种）&lt;/h3&gt;
&lt;p&gt;外部迭代：（之前使用的迭代集合的方式，fori这种的）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;List&amp;lt;Integer&amp;gt; list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);
for (int i = 0; i &amp;lt; list.size(); i++) {
            System.out.println(list.get(i));
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;内部迭代： ForEach（完全通过集合的本身，通过函数式接口拿出来使用Customer的Accept来完成内部迭代）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;List&amp;lt;Integer&amp;gt; list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);
list.forEach(i -&amp;gt; System.out.println(i));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第三种方式：方法引用（method reference）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;List&amp;lt;Integer&amp;gt; list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);
list.forEach(System.out::println);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2019年12月29日00:07:05 要睡觉了。笔记后面持续更新，代码会上传到GitHub，欢迎一起学习讨论。&lt;/p&gt;
</description>
<pubDate>Sat, 28 Dec 2019 16:11:00 +0000</pubDate>
<dc:creator>dawa大娃bigbaby</dc:creator>
<og:description>JAVA8学习——深入浅出Lambda表达式（学习过程） lambda表达式： 我们为什么要用lambda表达式 在JAVA中，我们无法将函数作为参数传递给一个方法，也无法声明返回一个函数的方法。 在</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bigbaby/p/12113741.html</dc:identifier>
</item>
<item>
<title>[Python之路] 内存管理&amp;垃圾回收 - 风间悠香</title>
<link>http://www.cnblogs.com/leokale-zz/p/12113559.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/leokale-zz/p/12113559.html</guid>
<description>&lt;h2&gt;&lt;span&gt;一、python源码&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;1.准备源码&lt;/h3&gt;
&lt;p&gt;下载Python源码：&lt;a href=&quot;https://www.python.org/ftp/python/3.8.0/Python-3.8.0.tgz&quot; target=&quot;_blank&quot;&gt;https://www.python.org/ftp/python/3.8.0/Python-3.8.0.tgz&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;解压得到文件夹：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1244144/201912/1244144-20191228220342109-961192044.png&quot; alt=&quot;&quot; width=&quot;420&quot; height=&quot;336&quot;/&gt;&lt;/p&gt;

&lt;p&gt;我们主要关注Include中的&quot;.h&quot;文件以及Objects目录中的&quot;.c&quot;文件。&lt;/p&gt;
&lt;p&gt;我们从Include和Objects中的文件类型就可以看出Python解释器是C语言编写的。&lt;/p&gt;

&lt;h3&gt;2.object.h&lt;/h3&gt;
&lt;p&gt;在Include文件夹中，全部都是&quot;.h&quot;文件。&lt;/p&gt;
&lt;p&gt;这些C语言头文件中主要存放着宏、函数声明、结构体声明、全局变量等。&lt;/p&gt;

&lt;p&gt;我们在Python中所有的类都继承自Object，所以在这个C语言的object.h中，我们可以看看是如何实现的。&lt;/p&gt;
&lt;p&gt;我们首先看object.h文件内容（小部分）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#define&lt;/span&gt; _PyObject_HEAD_EXTRA            \
    &lt;span&gt;struct&lt;/span&gt; _object *&lt;span&gt;_ob_next;           \
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; _object *&lt;span&gt;_ob_prev;

typedef &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; _object {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 维护双向链表refchain&lt;/span&gt;
&lt;span&gt;    _PyObject_HEAD_EXTRA
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 引用计数&lt;/span&gt;
&lt;span&gt;    Py_ssize_t ob_refcnt;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 数据的类型&lt;/span&gt;
    &lt;span&gt;struct&lt;/span&gt; _typeobject *&lt;span&gt;ob_type;
} PyObject;

typedef &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; {
    PyObject ob_base;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 数据类型为多元素时，维护一个容量个数&lt;/span&gt;
    Py_ssize_t ob_size; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Number of items in variable part &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
} PyVarObject;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们可以从上面的源码中看到，两个结构体PyObject和PyVarObject，区别是PyVarObject多一个ob_size属性，这个属性代表的是元素的个数（例如list、dict中元素的个数）。&lt;/p&gt;
&lt;p&gt;所以，这两个结构体，分别对应不同类型的数据的头（Python中任何数据的定义，都会有这个头）：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PyObject：float&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PyVarObject：list、dict、tuple、set、int、str、bool&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为Python中的int是不限制长度的，所以底层实现是用的str，所以int也属于PyVarObject阵营。Python中的bool实际上是0和1，所以也是int，也属于PyVarObject阵营。&lt;/p&gt;

&lt;h3&gt;3.floatobject.h&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
typedef &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; {
    PyObject_HEAD
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt; ob_fval;
} PyFloatObject;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们以float类型为例，可以看到创建一个float类型的数据，实际上是创建了一个PyFloatObject结构体的实例。&lt;/p&gt;
&lt;p&gt;PyFloatObject结构体中包含了一个PyObject_HEAD（这就是object.h中的PyObject），以及一个double ob_fval，这个double变量就是我们存放的值。&lt;/p&gt;

&lt;p&gt;我们以Python中的实际操作，来看源码中的过程：&lt;/p&gt;
&lt;p&gt;1）python中定义变量v = 0.3：&lt;/p&gt;
&lt;p&gt;源码流程：&lt;/p&gt;
&lt;p&gt;　　　　a.开辟内存（内存大小，是sizeof(PyFloatObject)）&lt;/p&gt;
&lt;p&gt;　　　　b.初始化&lt;/p&gt;
&lt;p&gt;　　　　　　ob_fval=0.3&lt;/p&gt;
&lt;p&gt;　　　　　　ob_type=float&lt;/p&gt;
&lt;p&gt;　　　　　　ob_refcnt=1&lt;/p&gt;
&lt;p&gt;　　　　c.将对象加入双向链表refchain中&lt;/p&gt;
&lt;p&gt;2）python执行操作name=v：&lt;/p&gt;
&lt;p&gt;源码流程：&lt;/p&gt;
&lt;p&gt;　　　　ob_refcnt+=1&lt;/p&gt;
&lt;p&gt;3）python执行操作del v：&lt;/p&gt;
&lt;p&gt;源码流程：&lt;/p&gt;
&lt;p&gt;　　　　ob_refcnt-=1&lt;/p&gt;
&lt;p&gt;4）python执行&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func(arg): 
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(arg)

func(name)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;源码流程：&lt;/p&gt;
&lt;p&gt;　　　　执行时开辟栈：ob_refcnt+=1&lt;/p&gt;
&lt;p&gt;　　　　结束时销毁栈：ob_refcnt-=1&lt;/p&gt;
&lt;p&gt;5）python执行del name：&lt;/p&gt;
&lt;p&gt;源码流程：&lt;/p&gt;
&lt;p&gt;　　　　ob_refcnt-=1&lt;/p&gt;

&lt;p&gt;在这几次操作中，每次进行ob_refcnt-=1的时候都会判断ob_refcnt是否等于0。如果是0，这将其归为垃圾，按理说GC回收器应该将其回收，请看第二节。&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;二、缓存机制&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;在第一节中，如果float变量的引用都被删除，引用计数为0以后，按理说GC回收器应该对其进行回收。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;1.free_list缓存链表&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;但编译器认为，用户经常都要定义float类型的变量，所以他将该PyFloatObject对象从refchain链表中拿出来，并且放到另一个单向链表中，这个单向链表就是&lt;strong&gt;缓存（叫free_list）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们做个验证：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; v = 8.9
&amp;gt;&amp;gt;&amp;gt; name =&lt;span&gt; v
&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; del v
&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; id(name)
1706304905888
&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; del name
&amp;gt;&amp;gt;&amp;gt; xx = 9.0
&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; id(xx)
1706304905888
&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到，name的id为1706304905888，删除name后，由创建了一个float变量xx，结果xx的id还是为170630490588。这就验证了缓存的机制。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为什么要使用缓存（&lt;/strong&gt;free_list）？&lt;/p&gt;
&lt;p&gt;　　因为回收内存空间和开辟内存空间都要消耗时间，所以，如果将空间放到缓存中，有新的float变量被定义的话，直接从缓存中拿到地址，重新进行一次初始化，并将新的值赋给ob_fval即可。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;2.free_list最大长度&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;注意，这里的单向链表（free_list）只是针对PyFloatObject类型的。而且这个链表有最大长度100。可以在floatobject.c中看到相关定义：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#ifndef PyFloat_MAXFREELIST
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义free_list的最大长度&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; PyFloat_MAXFREELIST    100
&lt;span&gt;#endif&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用numfree来表示当前free_list有多长&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; numfree = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; free_list指针&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; PyFloatObject *free_list = NULL;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;例如同时有1000个float变量的引用计数变为0，则归入free_list的只有100个，其余900个可能会被回收。&lt;/p&gt;

&lt;p&gt;在float中，free_list的最大长度是100，而在其他的数据类型中，最大长度可能不一样。&lt;/p&gt;
&lt;p&gt;例如list的free_list的最大长度为80：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#ifndef PyList_MAXFREELIST
&lt;/span&gt;&lt;span&gt;#define&lt;/span&gt; PyList_MAXFREELIST 80
&lt;span&gt;#endif&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; PyListObject *&lt;span&gt;free_list[PyList_MAXFREELIST];
&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; numfree = &lt;span&gt;0&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;dict也为80：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#ifndef PyDict_MAXFREELIST
&lt;/span&gt;&lt;span&gt;#define&lt;/span&gt; PyDict_MAXFREELIST 80
&lt;span&gt;#endif&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; PyDictObject *&lt;span&gt;free_list[PyDict_MAXFREELIST];
&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; numfree = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; PyDictKeysObject *&lt;span&gt;keys_free_list[PyDict_MAXFREELIST];
&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; numfreekeys = &lt;span&gt;0&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;3.其他优化机制&lt;/h3&gt;
&lt;p&gt;也不是所有的数据类型都使用free_list缓存机制，例如int用的是小数据池进行优化：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#ifndef NSMALLPOSINTS
&lt;/span&gt;&lt;span&gt;#define&lt;/span&gt; NSMALLPOSINTS           257
&lt;span&gt;#endif&lt;/span&gt;&lt;span&gt;
#ifndef NSMALLNEGINTS
&lt;/span&gt;&lt;span&gt;#define&lt;/span&gt; NSMALLNEGINTS           5
&lt;span&gt;#endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;span&gt;三、垃圾回收机制&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;Python的GC主要遵循以下原则：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;引用计数器为主，标记清除和分代回收为辅。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;1.引用计数器（同上，略）&lt;/h3&gt;
&lt;h3&gt;2.循环引用&lt;/h3&gt;
&lt;p&gt;循环引用一般发生在列表、字典、对象等容器类对象，他们之间可以互相嵌套，例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
a = [1, 2&lt;span&gt;]
b &lt;/span&gt;= [4, 5&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; b的引用计数会加1，变为2&lt;/span&gt;
&lt;span&gt;a.append(b)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; a的引用计数变为0&lt;/span&gt;
&lt;span&gt;del&lt;/span&gt;&lt;span&gt; a
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; b的引用计数变为1，但是已经无法访问b，所以就形成了内存泄漏&lt;/span&gt;
&lt;span&gt;del&lt;/span&gt; b
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这种情况下， 内存发生了泄漏，就要利用标记清除来解决循环引用的问题。&lt;/p&gt;

&lt;h3&gt;2.标记清除&lt;/h3&gt;
&lt;p&gt;针对那些容器类的对象，在Python中会将他们单独放到一个双向链表（非refchain）中，做定期扫描。&lt;/p&gt;
&lt;p&gt;参考：&lt;a href=&quot;https://www.cnblogs.com/saolv/p/8411993.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/saolv/p/8411993.html&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;第一组循环引用#&lt;/span&gt;
a = [1,2&lt;span&gt;]
b &lt;/span&gt;= [3,4&lt;span&gt;]
a.append(b)
b.append(a)
&lt;/span&gt;&lt;span&gt;del&lt;/span&gt;&lt;span&gt; a

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;第二组循环引用#&lt;/span&gt;
&lt;span&gt;
c &lt;/span&gt;= [4,5&lt;span&gt;]
d &lt;/span&gt;= [5,6&lt;span&gt;]
c.append(d)
d.append(c)
&lt;/span&gt;&lt;span&gt;del&lt;/span&gt;&lt;span&gt; c
&lt;/span&gt;&lt;span&gt;del&lt;/span&gt;&lt;span&gt; d
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;至此，原a和原c和原d所引用的对象的引用计数都为1,b所引用的对象的引用计数为2，&lt;/span&gt;
e [7,8&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;del&lt;/span&gt; e
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在说明一下标记清除:代码运行到上面这块了，此时，我们的本意是想清除掉c和d和e所引用的对象，而保留a和b所引用的对象。但是c和d所引用对象的引用计数都是非零，原来的简单的方法只能清除掉e，c和d所引用对象目前还在内存中。&lt;/p&gt;
&lt;p&gt;　　假设，此时我们预先设定的周期时间到了，此时该标记清除大显身手了。他的任务就是，在a,b,c,d四个可变对象中，找出真正需要清理的c和d，而保留a和b。&lt;/p&gt;
&lt;p&gt;　　首先，他先划分出两拨，一拨叫root object(存活组)，一拨叫unreachable(死亡组)。然后，他把各个对象的引用计数复制出来，对这个副本进行引用环的摘除。&lt;/p&gt;
&lt;p&gt;　　环的摘除：假设两个对象为A、B，我们从A出发，因为它有一个对B的引用，则将B的引用计数减1；然后顺着引用达到B，因为B有一个对A的引用，同样将A的引用减1，这样，就完成了循环引用对象间环摘除。&lt;/p&gt;
&lt;p&gt;　　摘除完毕，此时a的引用计数的副本是0，b的引用计数的副本是1，c和d的引用计数的副本都是0。那么先把副本为非0的放到存活组，副本为0的打入死亡组。如果就这样结束的话，就错杀了a了，因为b还要用，我们把a所引用的对象在内存中清除了b还能用吗？显然还得在审一遍，别把无辜的人也给杀了，于是他就在存活组里，对每个对象都分析一遍，由于目前存活组只有b，那么他只对b分析，因为b要存活，所以b里的元素也要存活，于是在b中就发现了原a所指向的对象，于是就把他从死亡组中解救出来。至此，进过了一审和二审，最终把所有的任然在死亡组中的对象通通杀掉，而root object继续存活。b所指向的对象引用计数任然是2，原a所指向的对象的引用计数仍然是1&lt;/p&gt;

&lt;p&gt;扫描后存活组的对象，将放到另外一个链表中去，一共有3个这样的链表，代表3代。&lt;/p&gt;

&lt;h3&gt;3.分代回收&lt;/h3&gt;
&lt;p&gt;分代回收就是指维护容器类对象的三个链表，3个链表对应三层。对最底层的链表扫描10次，才对上层的链表扫描一次。&lt;/p&gt;
&lt;p&gt;这其实是为了节省性能，尽量少扫描对象。&lt;/p&gt;
&lt;p&gt;认为没有问题经常使用的对象放入上一层，减少扫描次数。&lt;/p&gt;
&lt;p&gt;所以，在Python的内存管理中，一共维护着4个链表，其中一个链表refchain用来管理一般的数据类型，例如float等。而另外3个链表组成分代，管理容器类数据类型。&lt;/p&gt;


&lt;p&gt;参考博客：&lt;a href=&quot;https://www.cnblogs.com/wupeiqi/articles/11507404.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/wupeiqi/articles/11507404.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 28 Dec 2019 15:52:00 +0000</pubDate>
<dc:creator>风间悠香</dc:creator>
<og:description>一、python源码 1.准备源码 下载Python源码：https://www.python.org/ftp/python/3.8.0/Python-3.8.0.tgz 解压得到文件夹： 我们主要关</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/leokale-zz/p/12113559.html</dc:identifier>
</item>
<item>
<title>如何快速融入一个团队？ - 溪源More</title>
<link>http://www.cnblogs.com/xiyuanMore/p/how_to_join_a_team.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiyuanMore/p/how_to_join_a_team.html</guid>
<description>&lt;p&gt;我们难免需要离开一个圈子，加入一个陌生的集体。毋庸置疑，离开熟知的圈子，走向未知的圈子难免会产生许多畏惧甚至情怯，这都是人之常情，但不同的性格驱使我们会做出不同的决定。&lt;/p&gt;
&lt;p&gt;外向者也并非时时刻刻外向，但他们习惯于把自己表现在更多陌生人面前，这使得他们总是看起来易于被人接受。&lt;/p&gt;
&lt;p&gt;而内向者总是纠结于自己可能会犯错，而失去了展示自我的机会。他们纠结于自己的小圈子，总是需要花特别长的时间才能真正融入集体。&lt;/p&gt;

&lt;p&gt;一个人加入一个新团队，就像一滴热水突然坠入一片冰河之中。&lt;/p&gt;
&lt;p&gt;有时候总需要一场破冰行动，说不定这场破冰行动会成为撕裂冰河的关键力量，在类似于蝴蝶效应的作用之下，整个河面最终都会融化，变成一片充满活力的美好世界，那时的你往往会觉得周围的一切是如此的亲切。&lt;/p&gt;
&lt;p&gt;其实往往只需一念之间，不必寻求取悦他人，不必担心自己会不会犯错，只需单纯的选择一个恰当的时间，然后展示出自己，一切无需机遇，无需刻意安排，仅此而已。&lt;/p&gt;
&lt;p&gt;其实人群中的每个人都不见得一定是具有才艺的个体，拥有才艺的往往是那么少数。也很少有喷子或者毒舌，那些习惯于没事嘲讽别人、看不到别人优点的人，其实很难在一个圈子中留下来，往往恰好是自己融不入圈子而逐渐的疏离。&lt;/p&gt;
&lt;p&gt;在一个团队中的大部分人，都是富有包容心的。所以不用担心自己的表现会使自己的形象受损，恰好相反，有时候在展示自己的才艺时一不小心搞砸了这样看起来很没面子的事情，反而会更容易让大家把你记住，并认为你是一个非常有趣的人，而易于跟你打交道。&lt;/p&gt;
&lt;p&gt;其实加入一个新集体就是这样简单，无需矫揉造作，无需刻意讨好，是什么就是什么。&lt;/p&gt;
&lt;p&gt;你当然应该在乎你的形象，但是那是靠经常修剪自己的羽毛来完成的，而不是刻意扮演出一个多么独特的形象。真正决定你的形象的，并非这样的一瞬间，而是平时自己的一点一滴的积累和努力，并能与时俱进，保持进取。做一个专注的人，静下心来沉入到一个事情中，并努力的使自己专业，一定更容易让人重视，并也将使你得以在社会职责中扮演更加重要的责任。&lt;/p&gt;

&lt;p&gt;笔者亲历了一位内向者到社区发起者的成长之路。&lt;/p&gt;
&lt;p&gt;他是长沙互联网社区的领袖唐胡子，他说当他才20几岁时，也是一个非常内向的人，甚至比一般的人还要内向，到29岁时，谈过好几个对象都因为过于内向而未能修成正果。&lt;/p&gt;
&lt;p&gt;直到后来由于一次偶然的机会，他决定做出改变，然后他开始积极的放开自我，以更加积极的心态去接受陌生人，不再畏惧丢脸和面子，而是抓住一切机会表现自我，有圈子就融入圈子，没圈子就创造圈子。&lt;/p&gt;
&lt;p&gt;首先借助于网络，成为网络社区的积极份子，然后把人从线上拉到线下，通过面对面沟通来加强凝聚力，使得虚拟圈子逐渐的变成稳定的大圈子，然后又不断的有新人加入，有人离去，血液不断，细水长流，源远流长。可以说以他为中心的许多圈子都被带活了，数千人为之获益。&lt;/p&gt;
&lt;p&gt;要说他做了什么了不起的事情么，也许许多人会嗤之以鼻，不就是拉人头，搞活动，自我介绍，闲聊，聊技术话题么？&lt;/p&gt;
&lt;p&gt;运营一个社群其实就是这样看似简单，但是却同样不简单，优秀的运营者总是能在一片陌生人的世界中开创出属于自己品牌的小圈子，然后借助于圈子创造出更大的价值。&lt;/p&gt;

&lt;p&gt;有时我们应该积极的去拥抱陌生的领域。因为我们每个人都是独立存在的个体，独立的思维方式和行为的方式决定了我们跟周围人的区别，这恰好是人与人之间相处最大的乐趣，求同存异，在别人的世界中寻找自己，并探寻属于自己的未知领域，从而使自己的知识面进一步扩展。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;“你有一个苹果，我有一个苹果，我们交换一下，一人还是只有一个苹果；你有一个思想，我有一个思想，我们交换一下，一人就有两个思想。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们可以怎么做呢？&lt;/p&gt;
&lt;p&gt;1、利用一切可以利用的资源，例如从网络开始，或者从花名册开始找人交流，寻找一些能够开启话题的方面，例如姓氏或兴趣爱好、或者籍贯等这些看起来无关紧要的东西。当然，有时你挑起的话题可能对方不感兴趣，没关系，至少冰层会一点点的融化开。这次不行，还有下次。&lt;/p&gt;
&lt;p&gt;2、跟你周围的陌生人打招呼。多打招呼，对方将从你的每一次笑容中认识你。&lt;/p&gt;
&lt;p&gt;3、去试图融入他们，从聆听他们的沟通开始，坐在陌生人的周围，营造一些沟通的机会。&lt;/p&gt;
&lt;p&gt;4、抓住每一次团队建设的机会，这就是破冰的良机。优秀的企业都会有团队建设，通过团队建设，你将有希望看到在你所处的组织架构的一维世界之外的另外一层维度，这将使你对组织有更新的认识。&lt;/p&gt;
&lt;p&gt;然后你将逐渐收获特别多的朋友，关键是你掌握了在陌生环境下生存的方法，这将成为你最重要的一种财富。&lt;/p&gt;
</description>
<pubDate>Sat, 28 Dec 2019 14:43:00 +0000</pubDate>
<dc:creator>溪源More</dc:creator>
<og:description>一 我们难免需要离开一个圈子，加入一个陌生的集体。毋庸置疑，离开熟知的圈子，走向未知的圈子难免会产生许多畏惧甚至情怯，这都是人之常情，但不同的性格驱使我们会做出不同的决定。 外向者也并非时时刻刻外向，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiyuanMore/p/how_to_join_a_team.html</dc:identifier>
</item>
<item>
<title>kubernetes实战(三十)：CentOS 8 二进制 高可用 安装 k8s 1.17.x - 杜先生的博客</title>
<link>http://www.cnblogs.com/dukuan/p/12104600.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dukuan/p/12104600.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;1. 基本说明&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　本文章将演示CentOS 8二进制方式安装高可用k8s 1.17.x，相对于其他版本，二进制安装方式并无太大区别。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2. 基本环境配置&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　主机信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
192.168.1.19 k8s-&lt;span&gt;master01
192.168.1.18 k8s-&lt;span&gt;master02
192.168.1.20 k8s-&lt;span&gt;master03
192.168.1.88 k8s-master-&lt;span&gt;lb
192.168.1.21 k8s-&lt;span&gt;node01
192.168.1.22 k8s-node02&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　系统环境&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[root@k8s-master01 ~]# cat /etc/redhat-&lt;span&gt;release 
CentOS Linux release 8.0.1905&lt;span&gt; (Core) 
[root@k8s-master01 ~]# uname -&lt;span&gt;a
Linux k8s-master01 4.18.0-80.el8.x86_64 #1 SMP Tue Jun 4 09:19:46 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　配置所有节点hosts文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@k8s-master01 ~]# cat /etc/&lt;span&gt;hosts
127.0.0.1&lt;span&gt;   localhost localhost.localdomain localhost4 localhost4.localdomain4
::1&lt;span&gt;         localhost localhost.localdomain localhost6 localhost6.localdomain6

192.168.1.19 k8s-&lt;span&gt;master01
192.168.1.18 k8s-&lt;span&gt;master02
192.168.1.20 k8s-&lt;span&gt;master03
192.168.1.88 k8s-master-&lt;span&gt;lb
192.168.1.21 k8s-&lt;span&gt;node01
192.168.1.22 k8s-node02&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　所有节点关闭firewalld 、dnsmasq、selinux&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
systemctl disable --&lt;span&gt;now firewalld 
systemctl disable --&lt;span&gt;now dnsmasq&lt;br/&gt;setenforce 0&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　所有节点关闭swap分区&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@k8s-master01 ~]# swapoff -a &amp;amp;&amp;amp; sysctl -w vm.swappiness=0&lt;span&gt;
vm.swappiness = 0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　所有节点同步时间&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/&lt;span&gt;localtime
echo 'Asia/Shanghai' /etc/&lt;span&gt;timezone
ntpdate time2.aliyun.com&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　Master01节点生成ssh key&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@k8s-master01 ~]# ssh-keygen -&lt;span&gt;t rsa
Generating public/&lt;span&gt;private rsa key pair.
Enter file in which to save the key (/root/.ssh/&lt;span&gt;id_rsa): 
Created directory '/root/.ssh'&lt;span&gt;.
Enter passphrase (empty for&lt;span&gt; no passphrase): 
Enter same passphrase again: 
Your identification has been saved in /root/.ssh/&lt;span&gt;id_rsa.
Your public key has been saved in /root/.ssh/&lt;span&gt;id_rsa.pub.
The key fingerprint is:
SHA256:6uz2kI+jcMJIUQWKqRcDRbvpVxhCW3Tmqn0NKS+lT3U root@k8s-&lt;span&gt;master01
The key's randomart image is:
+---[RSA 2048]----+
|.o++=.o          |
|.+o+ +           |
|oo* . .          |
|. .* + .         |
|..+ + = S E      |
|.= o * * .       |
|. * * B .        |
|   = Bo+         |
|    .+*oo        |
+----[SHA256]-----+&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　Master01配置免密码登录其他节点&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@k8s-master01 ~]# for i in k8s-master01 k8s-master02 k8s-master03 k8s-node01 k8s-node02;do ssh-copy-id -i .ssh/id_rsa.pub $i;done
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　所有节点安装基本工具&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
yum install wget jq psmisc vim net-tools yum-utils device-mapper-persistent-data lvm2 git -y
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　Master01下载安装文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
[root@k8s-master01 ~]# git clone https://github.com/dotbalo/k8s-ha-install.git
Cloning into 'k8s-ha-install'&lt;span&gt;...
remote: Enumerating objects: 12, done&lt;span&gt;.
remote: Counting objects: 100% (12/12), done&lt;span&gt;.
remote: Compressing objects: 100% (11/11), done&lt;span&gt;.
remote: Total 461 (delta 2), reused 5 (delta 1), pack-reused 449&lt;span&gt;
Receiving objects: 100% (461/461), 19.52 MiB | 4.04 MiB/s, done&lt;span&gt;.
Resolving deltas: 100% (163/163), done.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　切换到1.17.x分支&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
git checkout manual-installation-v1.17.x
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;3. 基本组件安装&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　配置Docker yum源（和1.16.x安装步骤一致）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@k8s-master01 k8s-ha-install]# curl  https://download.docker.com/linux/centos/docker-ce.repo -o /etc/yum.repos.d/docker-ce.repo
  % Total    % Received %&lt;span&gt; Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100  2424  100  2424    0     0   3639      0 --:--:-- --:--:-- --:--:--  3645&lt;span&gt;
[root@k8s-master01 k8s-ha-install]# yum&lt;span&gt; makecache
CentOS-8 - AppStream                                                                                                                                                             559 kB/s | 6.3 MB     00:11&lt;span&gt;    
CentOS-8 - Base                                                                                                                                                                  454 kB/s | 7.9 MB     00:17&lt;span&gt;    
CentOS-8 - Extras                                                                                                                                                                592  B/s | 2.1 kB     00:03&lt;span&gt;    
Docker CE Stable - x86_64                                                                                                                                                        5.8 kB/s |  20 kB     00:03&lt;span&gt;    
Last metadata expiration check: 0:00:01 ago on Sat 02 Nov 2019 02:46:29&lt;span&gt; PM CST.
Metadata cache created.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　所有节点安装新版containerd&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
[root@k8s-master01 k8s-ha-install]# wget https://download.docker.com/linux/centos/7/x86_64/edge/Packages/containerd.io-1.2.6-3.3.el7.x86_64.rpm
--2019-11-02 15:00:20--  https://download.docker.com/linux/centos/7/x86_64/edge/Packages/containerd.io-1.2.6-3.3.el7.x86_64.rpm
Resolving download.docker.com (download.docker.com)... 13.225.103.32, 13.225.103.65, 13.225.103.10&lt;span&gt;, ...
Connecting to download.docker.com (download.docker.com)|13.225.103.32|:443&lt;span&gt;... connected.
HTTP request sent, awaiting response... 200&lt;span&gt; OK
Length: 27119348 (26M) [binary/octet-&lt;span&gt;stream]
Saving to: ‘containerd.io-1.2.6-3.3&lt;span&gt;.el7.x86_64.rpm’

containerd.io-1.2.6-3.3.el7.x86_64.rpm               100%[===================================================================================================================]  25.86M  1.55MB/s    in&lt;span&gt; 30s     

2019-11-02 15:00:51 (887 KB/s) - ‘containerd.io-1.2.6-3.3.el7.x86_64.rpm’ saved [27119348/27119348&lt;span&gt;]

[root@k8s-master01 k8s-ha-install]# yum -y install containerd.io-1.2.6-3.3&lt;span&gt;.el7.x86_64.rpm
Last metadata expiration check: 0:14:35 ago on Sat 02 Nov 2019 02:46:29 PM CST.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　所有节点安装最新版Docker&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@k8s-master01 k8s-ha-install]# yum install docker-ce -y
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　所有节点开启Docker并设置开机自启动&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@k8s-master01 k8s-ha-install]# systemctl enable --&lt;span&gt;now docker
Created symlink /etc/systemd/system/multi-user.target.wants/docker.service → /usr/lib/systemd/system/&lt;span&gt;docker.service.
[root@k8s-master01 k8s-ha-install&lt;span&gt;]# docker version
Client: Docker Engine -&lt;span&gt; Community
 Version:           19.03.4&lt;span&gt;
 API version:       1.40&lt;span&gt;
 Go version:        go1.12.10&lt;span&gt;
 Git commit:        9013bf583a
 Built:             Fri Oct 18 15:52:22 2019&lt;span&gt;
 OS/Arch:           linux/&lt;span&gt;amd64
 Experimental:      false&lt;span&gt;

Server: Docker Engine -&lt;span&gt; Community
 Engine:
  Version:          19.03.4&lt;span&gt;
  API version:      1.40 (minimum version 1.12&lt;span&gt;)
  Go version:       go1.12.10&lt;span&gt;
  Git commit:       9013bf583a
  Built:            Fri Oct 18 15:50:54 2019&lt;span&gt;
  OS/Arch:          linux/&lt;span&gt;amd64
  Experimental:     false&lt;span&gt;
 containerd:
  Version:          1.2.6&lt;span&gt;
  GitCommit:        894b81a4b802e4eb2a91d1ce216b8817763c29fb
 runc:
  Version:          1.0.0-&lt;span&gt;rc8
  GitCommit:        425e105d5a03fabd737a126ad93d62a9eeede87f
 docker-&lt;span&gt;init:
  Version:          0.18.0&lt;span&gt;
  GitCommit:        fec3683&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;4. k8s组件安装&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　下载kubernetes 1.17.x安装包&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@k8s-master01 ~]# &lt;span&gt;wget&lt;/span&gt; https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;storage.googleapis.com/kubernetes-release/release/v1.17.0/kubernetes-server-linux-amd64.tar.gz&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　下载etcd 3.3.18安装包&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@k8s-master01 ~]# wget https://github.com/etcd-io/etcd/releases/download/v3.3.18/etcd-v3.3.18-linux-amd64.tar.gz
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　解压kubernetes安装文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
[root@k8s-master01 ~]# tar -xf kubernetes-server-linux-amd64.tar.gz  --strip-components=3 -C /usr/local/bin kubernetes/server/bin/kube{let,ctl,-apiserver,-controller-manager,-scheduler,-proxy}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　解压etcd安装文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[root@k8s-master01 ~]#  tar -zxvf etcd-v3.3.18-linux-amd64.tar.gz --strip-components=1 -C /usr/local/bin etcd-v3.3.18-linux-amd64/etcd{,ctl}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　版本查看&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
[root@k8s-master01 ~&lt;span&gt;]# kubectl version
Client Version: version.Info{Major:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Minor:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, GitVersion:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;v1.17.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, GitCommit:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;70132b0f130acc0bed193d9ba59dd186f0e634cf&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, GitTreeState:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;clean&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, BuildDate:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2019-12-07T21:20:10Z&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, GoVersion:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;go1.13.4&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Compiler:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Platform:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;linux/amd64&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}
The connection to the server localhost:&lt;/span&gt;&lt;span&gt;8080&lt;/span&gt; was refused - did you specify the right host or port?&lt;span&gt;
[root@k8s&lt;/span&gt;-master01 ~]# etcdctl -&lt;span&gt;v
etcdctl version: &lt;/span&gt;&lt;span&gt;3.3&lt;/span&gt;.&lt;span&gt;18&lt;/span&gt;&lt;span&gt;
API version: &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　将组件发送到其他节点&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
MasterNodes='k8s-master02 k8s-master03'&lt;span&gt;
WorkNodes='k8s-node01 k8s-node02'
for NODE in $MasterNodes; do echo $NODE; scp /usr/local/bin/kube{let,ctl,-apiserver,-controller-manager,-scheduler,-proxy} $NODE:/usr/local/bin/; scp /usr/local/bin/etcd* $NODE:/usr/local/bin/; done
for NODE in $WorkNodes; do     scp /usr/local/bin/kube{let,-proxy} $NODE:/usr/local/bin/ ; done&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　CNI安装，下载CNI组件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
wget  https://github.com/containernetworking/plugins/releases/download/v0.7.5/cni-plugins-amd64-v0.7.5.tgz
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　所有节点创建/opt/cni/bin目录&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
mkdir -p /opt/cni/bin
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　解压cni并发送至其他节点&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
tar -zxf cni-plugins-amd64-v0.7.5.tgz -C /opt/cni/&lt;span&gt;bin
for NODE in $MasterNodes; do     ssh $NODE 'mkdir -p /opt/cni/bin';     scp /opt/cni/bin/* $NODE:/opt/cni/bin/; done
for NODE in $WorkNodes; do     ssh $NODE 'mkdir -p /opt/cni/bin';     scp /opt/cni/bin/* $NODE:/opt/cni/bin/; done&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;5. 生成证书&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　下载生成证书工具&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
wget &quot;https://pkg.cfssl.org/R1.2/cfssl_linux-amd64&quot; -O /usr/local/bin/&lt;span&gt;cfssl
wget &quot;https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64&quot; -O /usr/local/bin/&lt;span&gt;cfssljson
chmod +x /usr/local/bin/cfssl /usr/local/bin/cfssljson&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　所有Master节点创建etcd证书目录&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
mkdir /etc/etcd/ssl -p
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　Master01节点生成etcd证书&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
[root@k8s-master01 pki]# pwd
/root/k8s-ha-install/&lt;span&gt;pki

[root@k8s-master01 pki]#  cfssl gencert -initca etcd-ca-csr.json | cfssljson -bare /etc/etcd/ssl/etcd-&lt;span&gt;ca
&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;

[root@k8s-&lt;span&gt;master01 pki]# cfssl gencert \
   -ca=/etc/etcd/ssl/etcd-&lt;span&gt;ca.pem \
   -ca-key=/etc/etcd/ssl/etcd-ca-&lt;span&gt;key.pem \
   -config=ca-&lt;span&gt;config.json \
   -hostname=127.0.0.1,k8s-master01,k8s-master02,k8s-master03,192.168.1.19,192.168.1.18,192.168.1.20&lt;span&gt; \&lt;br/&gt;-profile=&lt;span&gt;kubernetes \
   etcd-csr.json | cfssljson -bare /etc/etcd/ssl/&lt;span&gt;etcd&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;2019/12/26 22:48:00 [INFO] generate received request&lt;br/&gt;2019/12/26 22:48:00 [INFO] received CSR&lt;br/&gt;2019/12/26 22:48:00 [INFO] generating key: rsa-2048&lt;br/&gt;2019/12/26 22:48:01 [INFO] encoded CSR&lt;br/&gt;2019/12/26 22:48:01 [INFO] signed certificate with serial number 250230878926052708909595617022917808304837732033&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;　　将证书复制到其他节点&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@k8s-master01 pki]# MasterNodes='k8s-master02 k8s-master03'&lt;span&gt;
[root@k8s-master01 pki]# WorkNodes='k8s-node01 k8s-node02'&lt;span&gt;
[root@k8s-&lt;span&gt;master01 pki]# 
[root@k8s-&lt;span&gt;master01 pki]# 
[root@k8s-&lt;span&gt;master01 pki]# 
[root@k8s-master01 pki]# for NODE in $MasterNodes; do
     ssh $NODE &quot;mkdir -p /etc/etcd/ssl&quot;
     for FILE in etcd-ca-key.pem  etcd-ca.pem  etcd-key.pem  etcd.pem; do
       scp /etc/etcd/ssl/${FILE} $NODE:/etc/etcd/ssl/&lt;span&gt;${FILE}
     done
 done&lt;span&gt;
etcd-ca-key.pem                                                                                                                                                                100% 1675   424.0KB/s   00:00&lt;span&gt;    

etcd-ca.pem                                                                                                                                                                    100% 1363   334.4KB/s   00:00&lt;span&gt;    
etcd-key.pem                                                                                                                                                                   100% 1679   457.4KB/s   00:00&lt;span&gt;    
etcd.pem                                                                                                                                                                       100% 1505   254.5KB/s   00:00&lt;span&gt;    
etcd-ca-key.pem                                                                                                                                                                100% 1675   308.3KB/s   00:00&lt;span&gt;    
etcd-ca.pem                                                                                                                                                                    100% 1363   479.0KB/s   00:00&lt;span&gt;    
etcd-key.pem                                                                                                                                                                   100% 1679   208.1KB/s   00:00&lt;span&gt;    
etcd.pem                                                                                                                                                                       100% 1505   398.1KB/s   00:00 &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　生成kubernetes证书&lt;/p&gt;
&lt;p&gt;　　所有节点创建kubernetes相关目录&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
mkdir -p /etc/kubernetes/pki
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
[root@k8s-master01 pki]# cfssl gencert -initca ca-csr.json | cfssljson -bare /etc/kubernetes/pki/&lt;span&gt;ca
&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;

[root@k8s-master01 pki]# cfssl gencert   -ca=/etc/kubernetes/pki/ca.pem   -ca-key=/etc/kubernetes/pki/ca-key.pem   -config=ca-config.json   -hostname=10.96.0.1,192.168.1.88,127.0.0.1,kubernetes,kubernetes.default,kubernetes.default.svc,kubernetes.default.svc.cluster,kubernetes.default.svc.cluster.local,192.168.1.19,192.168.1.18,192.168.1.20   -profile=kubernetes   apiserver-csr.json | cfssljson -bare /etc/kubernetes/pki/&lt;span&gt;apiserver
&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;

[root@k8s-master01 pki]# cfssl gencert   -initca front-proxy-ca-csr.json | cfssljson -bare /etc/kubernetes/pki/front-proxy-&lt;span&gt;ca 
&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;
[root@k8s-&lt;span&gt;master01 pki]# 
[root@k8s-master01 pki]# cfssl gencert   -ca=/etc/kubernetes/pki/front-proxy-ca.pem   -ca-key=/etc/kubernetes/pki/front-proxy-ca-key.pem   -config=ca-config.json   -profile=kubernetes   front-proxy-client-csr.json | cfssljson -bare /etc/kubernetes/pki/front-proxy-&lt;span&gt;client
&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;

[root@k8s-&lt;span&gt;master01 pki]# cfssl gencert \
   -ca=/etc/kubernetes/pki/&lt;span&gt;ca.pem \
   -ca-key=/etc/kubernetes/pki/ca-&lt;span&gt;key.pem \
   -config=ca-&lt;span&gt;config.json \
   -profile=&lt;span&gt;kubernetes \
   manager-csr.json | cfssljson -bare /etc/kubernetes/pki/controller-&lt;span&gt;manager
&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;
[root@k8s-master01 pki]# kubectl config set-&lt;span&gt;cluster kubernetes \
     --certificate-authority=/etc/kubernetes/pki/&lt;span&gt;ca.pem \
     --embed-certs=true&lt;span&gt; \
     --server=https://192.168.1.88:8443 \
     --kubeconfig=/etc/kubernetes/controller-&lt;span&gt;manager.kubeconfig


kubectl config set-context system:kube-controller-&lt;span&gt;manager@kubernetes \
    --cluster=&lt;span&gt;kubernetes \
    --user=system:kube-controller-&lt;span&gt;manager \
    --kubeconfig=/etc/kubernetes/controller-&lt;span&gt;manager.kubeconfig

kubectl config use-context system:kube-controller-&lt;span&gt;manager@kubernetes \
    --kubeconfig=/etc/kubernetes/controller-&lt;span&gt;manager.kubeconfig
&lt;span&gt;
[root@k8s-&lt;span&gt;master01 pki]# 
[root@k8s-master01 pki]# kubectl config set-credentials system:kube-controller-&lt;span&gt;manager \
     --client-certificate=/etc/kubernetes/pki/controller-&lt;span&gt;manager.pem \
     --client-key=/etc/kubernetes/pki/controller-manager-&lt;span&gt;key.pem \
     --embed-certs=true&lt;span&gt; \
     --kubeconfig=/etc/kubernetes/controller-&lt;span&gt;manager.kubeconfig
User &quot;system:kube-controller-manager&quot;&lt;span&gt; set.
[root@k8s-&lt;span&gt;master01 pki]# 
[root@k8s-master01 pki]# kubectl config set-context system:kube-controller-&lt;span&gt;manager@kubernetes \
     --cluster=&lt;span&gt;kubernetes \
     --user=system:kube-controller-&lt;span&gt;manager \
     --kubeconfig=/etc/kubernetes/controller-&lt;span&gt;manager.kubeconfig
Context &quot;system:kube-controller-manager@kubernetes&quot;&lt;span&gt; created.
[root@k8s-&lt;span&gt;master01 pki]# 
[root@k8s-master01 pki]# kubectl config use-context system:kube-controller-&lt;span&gt;manager@kubernetes \
     --kubeconfig=/etc/kubernetes/controller-&lt;span&gt;manager.kubeconfig
Switched to context &quot;system:kube-controller-manager@kubernetes&quot;&lt;span&gt;.

[root@k8s-&lt;span&gt;master01 pki]# cfssl gencert \
   -ca=/etc/kubernetes/pki/&lt;span&gt;ca.pem \
   -ca-key=/etc/kubernetes/pki/ca-&lt;span&gt;key.pem \
   -config=ca-&lt;span&gt;config.json \
   -profile=&lt;span&gt;kubernetes \
   scheduler-csr.json | cfssljson -bare /etc/kubernetes/pki/&lt;span&gt;scheduler&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;

[root@k8s-master01 pki]# kubectl config set-&lt;span&gt;cluster kubernetes \
     --certificate-authority=/etc/kubernetes/pki/&lt;span&gt;ca.pem \
     --embed-certs=true&lt;span&gt; \
     --server=https://192.168.1.88:8443 \
     --kubeconfig=/etc/kubernetes/&lt;span&gt;scheduler.kubeconfig&lt;span&gt;
Cluster &quot;kubernetes&quot;&lt;span&gt; set.
[root@k8s-&lt;span&gt;master01 pki]# 
[root@k8s-master01 pki]# kubectl config set-credentials system:kube-&lt;span&gt;scheduler \
     --client-certificate=/etc/kubernetes/pki/&lt;span&gt;scheduler.pem \
     --client-key=/etc/kubernetes/pki/scheduler-&lt;span&gt;key.pem \
     --embed-certs=true&lt;span&gt; \
     --kubeconfig=/etc/kubernetes/&lt;span&gt;scheduler.kubeconfig
User &quot;system:kube-scheduler&quot;&lt;span&gt; set.
[root@k8s-&lt;span&gt;master01 pki]# 
[root@k8s-master01 pki]# kubectl config set-context system:kube-&lt;span&gt;scheduler@kubernetes \
     --cluster=&lt;span&gt;kubernetes \
     --user=system:kube-&lt;span&gt;scheduler \
     --kubeconfig=/etc/kubernetes/&lt;span&gt;scheduler.kubeconfig
Context &quot;system:kube-scheduler@kubernetes&quot;&lt;span&gt; created.
[root@k8s-&lt;span&gt;master01 pki]# 
[root@k8s-master01 pki]# kubectl config use-context system:kube-&lt;span&gt;scheduler@kubernetes \
     --kubeconfig=/etc/kubernetes/&lt;span&gt;scheduler.kubeconfig
Switched to context &quot;system:kube-scheduler@kubernetes&quot;&lt;span&gt;.

[root@k8s-&lt;span&gt;master01 pki]# cfssl gencert \
   -ca=/etc/kubernetes/pki/&lt;span&gt;ca.pem \
   -ca-key=/etc/kubernetes/pki/ca-&lt;span&gt;key.pem \
   -config=ca-&lt;span&gt;config.json \
   -profile=&lt;span&gt;kubernetes \
   admin-csr.json | cfssljson -bare /etc/kubernetes/pki/&lt;span&gt;admin
&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;

[root@k8s-master01 pki]# kubectl config set-cluster kubernetes     --certificate-authority=/etc/kubernetes/pki/ca.pem     --embed-certs=true     --server=https://192.168.1.88:8443     --kubeconfig=/etc/kubernetes/admin.kubeconfig
&lt;span&gt;
Cluster &quot;kubernetes&quot;&lt;span&gt; set.
[root@k8s-&lt;span&gt;master01 pki]# 
[root@k8s-master01 pki]# kubectl config set-credentials kubernetes-admin     --client-certificate=/etc/kubernetes/pki/admin.pem     --client-key=/etc/kubernetes/pki/admin-key.pem     --embed-certs=true     --kubeconfig=/etc/kubernetes/&lt;span&gt;admin.kubeconfig
User &quot;kubernetes-admin&quot;&lt;span&gt; set.
[root@k8s-&lt;span&gt;master01 pki]# 
[root@k8s-master01 pki]# kubectl config set-context kubernetes-admin@kubernetes     --cluster=kubernetes     --user=kubernetes-admin     --kubeconfig=/etc/kubernetes/&lt;span&gt;admin.kubeconfig
Context &quot;kubernetes-admin@kubernetes&quot;&lt;span&gt; created.
[root@k8s-&lt;span&gt;master01 pki]# 
[root@k8s-master01 pki]# kubectl config use-context kubernetes-admin@kubernetes     --kubeconfig=/etc/kubernetes/&lt;span&gt;admin.kubeconfig
Switched to context &quot;kubernetes-admin@kubernetes&quot;&lt;span&gt;.


[root@k8s-master01 pki]# for NODE in k8s-master01 k8s-master02 k8s-master03; do
     \cp kubelet-csr.json kubelet-$NODE-&lt;span&gt;csr.json;
     sed -i &quot;s/\$NODE/$NODE/g&quot; kubelet-$NODE-&lt;span&gt;csr.json;
&lt;span&gt;     cfssl gencert \
       -ca=/etc/kubernetes/pki/&lt;span&gt;ca.pem \
       -ca-key=/etc/kubernetes/pki/ca-&lt;span&gt;key.pem \
       -config=ca-&lt;span&gt;config.json \
       -hostname=&lt;span&gt;$NODE \
       -profile=&lt;span&gt;kubernetes \
       kubelet-$NODE-csr.json | cfssljson -bare /etc/kubernetes/pki/kubelet-&lt;span&gt;$NODE;
     rm -f kubelet-$NODE-&lt;span&gt;csr.json
   done
&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;


[root@k8s-master01 pki]# for NODE in k8s-master01 k8s-master02 k8s-master03; do
     ssh $NODE &quot;mkdir -p /etc/kubernetes/pki&quot;
     scp /etc/kubernetes/pki/ca.pem $NODE:/etc/kubernetes/pki/&lt;span&gt;ca.pem
     scp /etc/kubernetes/pki/kubelet-$NODE-key.pem $NODE:/etc/kubernetes/pki/kubelet-&lt;span&gt;key.pem
     scp /etc/kubernetes/pki/kubelet-$NODE.pem $NODE:/etc/kubernetes/pki/&lt;span&gt;kubelet.pem
     rm -f /etc/kubernetes/pki/kubelet-$NODE-key.pem /etc/kubernetes/pki/kubelet-&lt;span&gt;$NODE.pem
 done&lt;span&gt;
&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;

[root@k8s-master01 pki]# for NODE in k8s-master01 k8s-master02 k8s-master03; do
     ssh $NODE &quot;cd /etc/kubernetes/pki &amp;amp;&amp;amp; \
       kubectl config set-&lt;span&gt;cluster kubernetes \
         --certificate-authority=/etc/kubernetes/pki/&lt;span&gt;ca.pem \
         --embed-certs=true&lt;span&gt; \
         --server=https://192.168.1.88:8443 \
         --kubeconfig=/etc/kubernetes/kubelet.kubeconfig &amp;amp;&amp;amp;&lt;span&gt; \
       kubectl config set-&lt;span&gt;credentials system:node:${NODE} \
         --client-certificate=/etc/kubernetes/pki/&lt;span&gt;kubelet.pem \
         --client-key=/etc/kubernetes/pki/kubelet-&lt;span&gt;key.pem \
         --embed-certs=true&lt;span&gt; \
         --kubeconfig=/etc/kubernetes/kubelet.kubeconfig &amp;amp;&amp;amp;&lt;span&gt; \
       kubectl config set-&lt;span&gt;context system:node:${NODE}@kubernetes \
         --cluster=&lt;span&gt;kubernetes \
         --user=&lt;span&gt;system:node:${NODE} \
         --kubeconfig=/etc/kubernetes/kubelet.kubeconfig &amp;amp;&amp;amp;&lt;span&gt; \
       kubectl config use-&lt;span&gt;context system:node:${NODE}@kubernetes \
         --kubeconfig=/etc/kubernetes/kubelet.kubeconfig&quot;
 done&lt;span&gt;
&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　创建ServiceAccount Key&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
[root@k8s-master01 pki]#  openssl genrsa -out /etc/kubernetes/pki/sa.key 2048&lt;span&gt;
Generating RSA private key, 2048 bit long modulus (2&lt;span&gt; primes)
...................................................................................+++++&lt;span&gt;
...............+++++&lt;span&gt;
e is 65537 (0x010001&lt;span&gt;)
[root@k8s-master01 pki]# openssl rsa -in /etc/kubernetes/pki/sa.key -pubout -out /etc/kubernetes/pki/&lt;span&gt;sa.pub
writing RSA key&lt;p&gt;[root@k8s-master01 pki]# &lt;/p&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;for NODE in k8s-master02 k8s-master03; do &lt;br/&gt;for FILE in $(ls /etc/kubernetes/pki | grep -v etcd); do &lt;br/&gt;scp /etc/kubernetes/pki/${FILE} $NODE:/etc/kubernetes/pki/${FILE};&lt;br/&gt;done; &lt;br/&gt;for FILE in admin.kubeconfig controller-manager.kubeconfig scheduler.kubeconfig; do &lt;br/&gt;scp /etc/kubernetes/${FILE} $NODE:/etc/kubernetes/${FILE};&lt;br/&gt;done;&lt;br/&gt;done&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;6. Kubernetes系统组件配置&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　etcd配置大致相同，注意修改每个Master节点的etcd配置的主机名和IP地址&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
# cat &lt;em id=&quot;__mceDel&quot;&gt;/etc/etcd/etcd.config.yml&lt;/em&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;br/&gt;name: 'k8s-master01'&lt;span&gt;
data-dir: /var/lib/&lt;span&gt;etcd
wal-dir: /var/lib/etcd/&lt;span&gt;wal
snapshot-count: 5000&lt;span&gt;
heartbeat-interval: 100&lt;span&gt;
election-timeout: 1000&lt;span&gt;
quota-backend-bytes: 0&lt;span&gt;
listen-peer-urls: 'https://192.168.1.19:2380'&lt;span&gt;
listen-client-urls: 'https://192.168.1.19:2379,http://127.0.0.1:2379'&lt;span&gt;
max-snapshots: 3&lt;span&gt;
max-wals: 5&lt;span&gt;
cors:
initial-advertise-peer-urls: 'https://192.168.1.19:2380'&lt;span&gt;
advertise-client-urls: 'https://192.168.1.19:2379'&lt;span&gt;
discovery:
discovery-fallback: 'proxy'&lt;span&gt;
discovery-&lt;span&gt;proxy:
discovery-&lt;span&gt;srv:
initial-cluster: 'k8s-master01=https://192.168.1.19:2380,k8s-master02=https://192.168.1.18:2380,k8s-master03=https://192.168.1.20:2380'&lt;span&gt;
initial-cluster-token: 'etcd-k8s-cluster'&lt;span&gt;
initial-cluster-state: 'new'&lt;span&gt;
strict-reconfig-check: false&lt;span&gt;
enable-v2: true&lt;span&gt;
enable-pprof: true&lt;span&gt;
proxy: 'off'&lt;span&gt;
proxy-failure-wait: 5000&lt;span&gt;
proxy-refresh-interval: 30000&lt;span&gt;
proxy-dial-timeout: 1000&lt;span&gt;
proxy-write-timeout: 5000&lt;span&gt;
proxy-read-timeout: 0&lt;span&gt;
client-transport-&lt;span&gt;security:
  ca-file: '/etc/kubernetes/pki/etcd/etcd-ca.pem'&lt;span&gt;
  cert-file: '/etc/kubernetes/pki/etcd/etcd.pem'&lt;span&gt;
  key-file: '/etc/kubernetes/pki/etcd/etcd-key.pem'&lt;span&gt;
  client-cert-auth: true&lt;span&gt;
  trusted-ca-file: '/etc/kubernetes/pki/etcd/etcd-ca.pem'&lt;span&gt;
  auto-tls: true&lt;span&gt;
peer-transport-&lt;span&gt;security:
  ca-file: '/etc/kubernetes/pki/etcd/etcd-ca.pem'&lt;span&gt;
  cert-file: '/etc/kubernetes/pki/etcd/etcd.pem'&lt;span&gt;
  key-file: '/etc/kubernetes/pki/etcd/etcd-key.pem'&lt;span&gt;
  peer-client-cert-auth: true&lt;span&gt;
  trusted-ca-file: '/etc/kubernetes/pki/etcd/etcd-ca.pem'&lt;span&gt;
  auto-tls: true&lt;span&gt;
debug: false&lt;span&gt;
log-package-&lt;span&gt;levels:
log-&lt;span&gt;output: default
force-new-cluster: false&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　所有Master节点创建etcd service并启动&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@k8s-master01 pki]# cat /usr/lib/systemd/system/&lt;span&gt;etcd.service
[Unit]
Description=&lt;span&gt;Etcd Service
Documentation=https://coreos.com/etcd/docs/latest/
After=&lt;span&gt;network.target

[Service]
Type=&lt;span&gt;notify
ExecStart=/usr/local/bin/etcd --config-file=/etc/etcd/&lt;span&gt;etcd.config.yml
Restart=on-&lt;span&gt;failure
RestartSec=10&lt;span&gt;
LimitNOFILE=65536&lt;span&gt;

[Install]
WantedBy=multi-&lt;span&gt;user.target
Alias=&lt;span&gt;etcd3.service

[root@k8s-master01 pki]# mkdir /etc/kubernetes/pki/&lt;span&gt;etcd
[root@k8s-master01 pki]# ln -s /etc/etcd/ssl/* /etc/kubernetes/pki/etcd/
[root@k8s-master01 pki]# systemctl daemon-reload
[root@k8s-master01 pki]# systemctl enable --now etcd
Created symlink /etc/systemd/system/etcd3.service → /usr/lib/systemd/system/etcd.service.
Created symlink /etc/systemd/system/multi-user.target.wants/etcd.service → /usr/lib/systemd/system/etcd.service.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　高可用配置&lt;/p&gt;
&lt;p&gt;　　所有Master节点安装keepalived和haproxy&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
yum install keepalived haproxy -y
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　HAProxy配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@k8s-master01 pki]# cat /etc/haproxy/&lt;span&gt;haproxy.cfg 
global
  maxconn  2000&lt;span&gt;
  ulimit-n  16384&lt;span&gt;
  log  127.0.0.1&lt;span&gt; local0 err
  stats timeout 30s

defaults
  log global
  mode  http
  option  httplog
  timeout connect 5000&lt;span&gt;
  timeout client  50000&lt;span&gt;
  timeout server  50000&lt;span&gt;
  timeout http-&lt;span&gt;request 15s
  timeout http-keep-&lt;span&gt;alive 15s

frontend monitor-in&lt;span&gt;
  bind *:33305&lt;span&gt;
  mode http
  option httplog
  monitor-uri /&lt;span&gt;monitor

listen stats
  bind    *:8006&lt;span&gt;
  mode    http
  stats   enable
  stats   hide-&lt;span&gt;version
  stats   uri       /&lt;span&gt;stats
  stats   refresh   30s
  stats   realm     Haproxy\ Statistics
  stats   auth      admin:admin

frontend k8s-&lt;span&gt;master
  bind 0.0.0.0:8443&lt;span&gt;
  bind 127.0.0.1:8443&lt;span&gt;
  mode tcp
  option tcplog
  tcp-request inspect-&lt;span&gt;delay 5s
  default_backend k8s-&lt;span&gt;master

backend k8s-&lt;span&gt;master
  mode tcp
  option tcplog
  option tcp-&lt;span&gt;check
  balance roundrobin
  default-server inter 10s downinter 5s rise 2 fall 2 slowstart 60s maxconn 250 maxqueue 256 weight 100&lt;span&gt;
  server k8s-master01    192.168.1.19:6443&lt;span&gt;  check
  server k8s-master02    192.168.1.18:6443&lt;span&gt;  check
  server k8s-master03    192.168.1.20:6443  check&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　KeepAlived配置 [root@k8s-master01 pki]# vim /etc/keepalived/keepalived.conf ，注意每个节点的IP和网卡&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
! Configuration File for&lt;span&gt; keepalived
global_defs {
    router_id LVS_DEVEL
}
vrrp_script chk_apiserver {
    script &quot;/etc/keepalived/check_apiserver.sh&quot;&lt;span&gt;
    interval 2&lt;span&gt;
    weight -5&lt;span&gt;
    fall 3&lt;span&gt;  
    rise 2&lt;span&gt;
}
vrrp_instance VI_1 {
    state MASTER
    interface ens160
    mcast_src_ip 192.168.1.19&lt;span&gt;
    virtual_router_id 51&lt;span&gt;
    priority 100&lt;span&gt;
    advert_int 2&lt;span&gt;
    authentication {
        auth_type PASS
        auth_pass K8SHA_KA_AUTH
    }
    virtual_ipaddress {
        192.168.1.88&lt;span&gt;
    }
    track_script {&lt;br/&gt;chk_apiserver &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;} }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　健康检查配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@k8s-master01 keepalived]# cat /etc/keepalived/check_apiserver.sh&lt;span&gt; 
#!/bin/&lt;span&gt;bash

err=0
for k in $(seq 1 5&lt;span&gt;)
do&lt;span&gt;
    check_code=$(pgrep kube-&lt;span&gt;apiserver)
    if [[ $check_code == &quot;&quot; ]]; then&lt;span&gt;
        err=$(expr $err + 1&lt;span&gt;)
        sleep 5&lt;span&gt;
        continue
    else&lt;span&gt;
        err=0&lt;span&gt;
        break
    fi
done

if [[ $err != &quot;0&quot; ]]; then
    echo &quot;systemctl stop keepalived&quot;
    /usr/bin/&lt;span&gt;systemctl stop keepalived
    exit 1
else&lt;span&gt;
    exit 0
fi&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　启动HAProxy和KeepAlived&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@k8s-master01 keepalived]# systemctl enable --&lt;span&gt;now haproxy
[root@k8s-master01 keepalived]# systemctl enable --now keepalived&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　VIP测试&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@k8s-master01 pki]# ping 192.168.1.88&lt;span&gt;
PING 192.168.1.88 (192.168.1.88) 56(84&lt;span&gt;) bytes of data.
64 bytes from 192.168.1.88: icmp_seq=1 ttl=64 time=1.39&lt;span&gt; ms
64 bytes from 192.168.1.88: icmp_seq=2 ttl=64 time=2.46&lt;span&gt; ms
64 bytes from 192.168.1.88: icmp_seq=3 ttl=64 time=1.68&lt;span&gt; ms
64 bytes from 192.168.1.88: icmp_seq=4 ttl=64 time=1.08 ms&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　Kubernetes组件配置&lt;/p&gt;
&lt;p&gt;　　所有节点创建相关目录&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@k8s-master01 pki]# mkdir -p /etc/kubernetes/manifests/ /etc/systemd/system/kubelet.service.d /var/lib/kubelet /var/log/kubernetes
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　所有Master节点创建kube-apiserver service&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
[root@k8s-master01 pki]# cat /usr/lib/systemd/system/kube-&lt;span&gt;apiserver.service 
[Unit]
Description=&lt;span&gt;Kubernetes API Server
Documentation=https://github.com/kubernetes/kubernetes
After=&lt;span&gt;network.target

[Service]
ExecStart=/usr/local/bin/kube-&lt;span&gt;apiserver \
      --v=2&lt;span&gt;  \
      --logtostderr=true&lt;span&gt;  \
      --allow-privileged=true&lt;span&gt;  \
      --bind-address=0.0.0.0&lt;span&gt;  \
      --secure-port=6443&lt;span&gt;  \
      --insecure-port=0&lt;span&gt;  \
      --advertise-address=192.168.1.88&lt;span&gt; \
      --service-cluster-ip-range=10.96.0.0/12&lt;span&gt;  \
      --service-node-port-range=30000-32767&lt;span&gt;  \
      --etcd-servers=https://192.168.1.19:2379,https://192.168.1.18:2379,https://192.168.1.20:2379 \
      --etcd-cafile=/etc/etcd/ssl/etcd-&lt;span&gt;ca.pem  \
      --etcd-certfile=/etc/etcd/ssl/&lt;span&gt;etcd.pem  \
      --etcd-keyfile=/etc/etcd/ssl/etcd-&lt;span&gt;key.pem  \
      --client-ca-file=/etc/kubernetes/pki/&lt;span&gt;ca.pem  \
      --tls-cert-file=/etc/kubernetes/pki/&lt;span&gt;apiserver.pem  \
      --tls-private-key-file=/etc/kubernetes/pki/apiserver-&lt;span&gt;key.pem  \
      --kubelet-client-certificate=/etc/kubernetes/pki/&lt;span&gt;apiserver.pem  \
      --kubelet-client-key=/etc/kubernetes/pki/apiserver-&lt;span&gt;key.pem  \
      --service-account-key-file=/etc/kubernetes/pki/&lt;span&gt;sa.pub  \
      --kubelet-preferred-address-types=&lt;span&gt;InternalIP,ExternalIP,Hostname  \
      --enable-admission-plugins=&lt;span&gt;NamespaceLifecycle,LimitRanger,ServiceAccount,DefaultStorageClass,DefaultTolerationSeconds,NodeRestriction,ResourceQuota  \
      --authorization-mode=&lt;span&gt;Node,RBAC  \
      --enable-bootstrap-token-auth=true&lt;span&gt;  \
      --requestheader-client-ca-file=/etc/kubernetes/pki/front-proxy-&lt;span&gt;ca.pem  \
      --proxy-client-cert-file=/etc/kubernetes/pki/front-proxy-&lt;span&gt;client.pem  \
      --proxy-client-key-file=/etc/kubernetes/pki/front-proxy-client-&lt;span&gt;key.pem  \
      --requestheader-allowed-names=&lt;span&gt;aggregator  \
      --requestheader-group-headers=X-Remote-&lt;span&gt;Group  \
      --requestheader-extra-headers-prefix=X-Remote-Extra-&lt;span&gt;  \
      --requestheader-username-headers=X-Remote-&lt;span&gt;User  \
      --token-auth-file=/etc/kubernetes/&lt;span&gt;token.csv

Restart=on-&lt;span&gt;failure
RestartSec=&lt;span&gt;10s
LimitNOFILE=65535&lt;span&gt;

[Install]
WantedBy=multi-user.target&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
[root@k8s-master01 pki]# vim /etc/kubernetes/&lt;span&gt;token.csv 
[root@k8s-master01 pki]# cat !&lt;span&gt;$
cat /etc/kubernetes/&lt;span&gt;token.csv
d7d356746b508a1a478e49968fba7947,kubelet-bootstrap,10001,&quot;system:kubelet-bootstrap&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　所有Master节点开启kube-apiserver&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@k8s-master01 pki]# systemctl daemon-reload &amp;amp;&amp;amp; systemctl enable --now kube-apiserver
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　所有Master节点配置kube-controller-manager service&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
[root@k8s-master01 pki]# cat /usr/lib/systemd/system/kube-controller-&lt;span&gt;manager.service
[Unit]
Description=&lt;span&gt;Kubernetes Controller Manager
Documentation=https://github.com/kubernetes/kubernetes
After=&lt;span&gt;network.target

[Service]
ExecStart=/usr/local/bin/kube-controller-&lt;span&gt;manager \
      --v=2&lt;span&gt; \
      --logtostderr=true&lt;span&gt; \
      --address=127.0.0.1&lt;span&gt; \
      --root-ca-file=/etc/kubernetes/pki/&lt;span&gt;ca.pem \
      --cluster-signing-cert-file=/etc/kubernetes/pki/&lt;span&gt;ca.pem \
      --cluster-signing-key-file=/etc/kubernetes/pki/ca-&lt;span&gt;key.pem \
      --service-account-private-key-file=/etc/kubernetes/pki/&lt;span&gt;sa.key \
      --kubeconfig=/etc/kubernetes/controller-&lt;span&gt;manager.kubeconfig \
      --leader-elect=true&lt;span&gt; \
      --use-service-account-credentials=true&lt;span&gt; \
      --node-monitor-grace-period=&lt;span&gt;40s \
      --node-monitor-period=&lt;span&gt;5s \
      --pod-eviction-timeout=&lt;span&gt;2m0s \
      --controllers=*&lt;span&gt;,bootstrapsigner,tokencleaner \
      --allocate-node-cidrs=true&lt;span&gt; \
      --cluster-cidr=10.244.0.0/16&lt;span&gt; \
      --requestheader-client-ca-file=/etc/kubernetes/pki/front-proxy-&lt;span&gt;ca.pem \
      --node-cidr-mask-size=24&lt;span&gt;
      
Restart=&lt;span&gt;always
RestartSec=&lt;span&gt;10s

[Install]
WantedBy=multi-user.target&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　所有Master节点启动kube-controller-manager&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[root@k8s-master01 pki]# systemctl daemon-&lt;span&gt;reload

[root@k8s-master01 pki]# systemctl enable --now kube-controller-&lt;span&gt;manager
Created symlink /etc/systemd/system/multi-user.target.wants/kube-controller-manager.service → /usr/lib/systemd/system/kube-controller-manager.service.&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　所有Master节点配置kube-scheduler service&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@k8s-master01 pki]# cat /usr/lib/systemd/system/kube-&lt;span&gt;scheduler.service 
[Unit]
Description=&lt;span&gt;Kubernetes Scheduler
Documentation=https://github.com/kubernetes/kubernetes
After=&lt;span&gt;network.target

[Service]
ExecStart=/usr/local/bin/kube-&lt;span&gt;scheduler \
      --v=2&lt;span&gt; \
      --logtostderr=true&lt;span&gt; \
      --address=127.0.0.1&lt;span&gt; \
      --leader-elect=true&lt;span&gt; \
      --kubeconfig=/etc/kubernetes/&lt;span&gt;scheduler.kubeconfig

Restart=&lt;span&gt;always
RestartSec=&lt;span&gt;10s

[Install]
WantedBy=multi-&lt;span&gt;user.target

[root@k8s-master01 pki]# systemctl daemon-&lt;span&gt;reload

[root@k8s-master01 pki]# systemctl enable --now kube-&lt;span&gt;scheduler
Created symlink /etc/systemd/system/multi-user.target.wants/kube-scheduler.service → /usr/lib/systemd/system/kube-scheduler.service.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;7.  TLS Bootstrapping配置&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　在Master01创建bootstrap&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
kubectl config set-cluster kubernetes     --certificate-authority=/etc/kubernetes/pki/ca.pem     --embed-certs=true     --server=https://192.168.1.88:8443     --kubeconfig=/etc/kubernetes/bootstrap-kubelet.kubeconfig
kubectl config set-credentials tls-bootstrap-token-user     --token=c8ad9c.2e4d610cf3e7426e --kubeconfig=/etc/kubernetes/bootstrap-&lt;span&gt;kubelet.kubeconfig
kubectl config set-context tls-bootstrap-token-user@kubernetes     --cluster=kubernetes     --user=tls-bootstrap-token-user     --kubeconfig=/etc/kubernetes/bootstrap-&lt;span&gt;kubelet.kubeconfig
kubectl config use-context tls-bootstrap-token-user@kubernetes     --kubeconfig=/etc/kubernetes/bootstrap-kubelet.kubeconfig&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@k8s-master01 bootstrap]# &lt;span&gt;cp&lt;/span&gt; /etc/kubernetes/admin.kubeconfig /root/.kube/&lt;span&gt;config
[root@k8s&lt;/span&gt;-master01 bootstrap]# kubectl create -&lt;span&gt;f bootstrap.secret.yaml 
secret&lt;/span&gt;/bootstrap-token-&lt;span&gt;c8ad9c created
clusterrolebinding.rbac.authorization.k8s.io&lt;/span&gt;/kubelet-&lt;span&gt;bootstrap created
clusterrolebinding.rbac.authorization.k8s.io&lt;/span&gt;/node-autoapprove-&lt;span&gt;bootstrap created
clusterrolebinding.rbac.authorization.k8s.io&lt;/span&gt;/node-autoapprove-certificate-&lt;span&gt;rotation created
clusterrole.rbac.authorization.k8s.io&lt;/span&gt;/system:kube-apiserver-to-&lt;span&gt;kubelet created
clusterrolebinding.rbac.authorization.k8s.io&lt;/span&gt;/system:kube-apiserver created
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;8. Node节点配置&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　复制证书至Node节点&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@k8s-master01 bootstrap]# for NODE in k8s-node01 k8s-node02; do
     ssh $NODE mkdir -p /etc/kubernetes/pki /etc/etcd/ssl /etc/etcd/&lt;span&gt;ssl
     for FILE in etcd-ca.pem etcd.pem etcd-key.pem; do
       scp /etc/etcd/ssl/$FILE $NODE:/etc/etcd/ssl/
     done
     for FILE in pki/ca.pem pki/ca-key.pem pki/front-proxy-ca.pem bootstrap-kubelet.kubeconfig; do
       scp /etc/kubernetes/$FILE $NODE:/etc/kubernetes/&lt;span&gt;${FILE}
 done
 done&lt;span&gt;

etcd-ca.pem                                                                                                                                                                    100% 1363   314.0KB/s   00:00&lt;span&gt;    
etcd.pem                                                                                                                                                                       100% 1505   429.1KB/s   00:00&lt;span&gt;    
etcd-key.pem                                                                                                                                                                   100% 1679   361.9KB/s   00:00&lt;span&gt;    
ca.pem                                                                                                                                                                         100% 1407   459.5KB/s   00:00&lt;span&gt;    
ca-key.pem                                                                                                                                                                     100% 1679   475.2KB/s   00:00&lt;span&gt;    
front-proxy-ca.pem                                                                                                                                                             100% 1143   214.5KB/s   00:00&lt;span&gt;    
bootstrap-kubelet.kubeconfig                                                                                                                                                   100% 2291   695.1KB/s   00:00&lt;span&gt;    
etcd-ca.pem                                                                                                                                                                    100% 1363   325.5KB/s   00:00&lt;span&gt;    
etcd.pem                                                                                                                                                                       100% 1505   301.2KB/s   00:00&lt;span&gt;    
etcd-key.pem                                                                                                                                                                   100% 1679   260.9KB/s   00:00&lt;span&gt;    
ca.pem                                                                                                                                                                         100% 1407   420.8KB/s   00:00&lt;span&gt;    
ca-key.pem                                                                                                                                                                     100% 1679   398.0KB/s   00:00&lt;span&gt;    
front-proxy-ca.pem                                                                                                                                                             100% 1143   224.9KB/s   00:00&lt;span&gt;    
bootstrap-kubelet.kubeconfig                                                                                                                                                   100% 2291   685.4KB/s   00:00&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　所有Node节点创建相关目录&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
mkdir -p /var/lib/kubelet /var/log/kubernetes /etc/systemd/system/kubelet.service.d /etc/kubernetes/manifests/
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　所有节点配置kubelet service（Master节点不部署Pod也可无需配置）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@k8s-master01 bootstrap]# vim  /usr/lib/systemd/system/&lt;span&gt;kubelet.service
[root@k8s-master01 bootstrap]# cat !&lt;span&gt;$
cat /usr/lib/systemd/system/&lt;span&gt;kubelet.service
[Unit]
Description=&lt;span&gt;Kubernetes Kubelet
Documentation=https://github.com/kubernetes/kubernetes
After=&lt;span&gt;docker.service
Requires=&lt;span&gt;docker.service

[Service]
ExecStart=/usr/local/bin/&lt;span&gt;kubelet

Restart=&lt;span&gt;always
StartLimitInterval=0&lt;span&gt;
RestartSec=10&lt;span&gt;

[Install]
WantedBy=multi-user.target&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@k8s-master01 bootstrap]# vim  /etc/systemd/system/kubelet.service.d/10-&lt;span&gt;kubelet.conf
[root@k8s-master01 bootstrap]# cat !&lt;span&gt;$
cat /etc/systemd/system/kubelet.service.d/10-&lt;span&gt;kubelet.conf
[Service]
Environment=&quot;KUBELET_KUBECONFIG_ARGS=--bootstrap-kubeconfig=/etc/kubernetes/bootstrap-kubelet.kubeconfig --kubeconfig=/etc/kubernetes/kubelet.kubeconfig&quot;&lt;span&gt;
Environment=&quot;KUBELET_SYSTEM_ARGS=--network-plugin=cni --cni-conf-dir=/etc/cni/net.d --cni-bin-dir=/opt/cni/bin&quot;&lt;span&gt;
Environment=&quot;KUBELET_CONFIG_ARGS=--config=/etc/kubernetes/kubelet-conf.yml&quot;&lt;span&gt;
Environment=&quot;KUBELET_EXTRA_ARGS=--node-labels=node.kubernetes.io/node='' --pod-infra-container-image=registry.cn-hangzhou.aliyuncs.com/google_containers/pause-amd64:3.1&quot;&lt;span&gt;
ExecStart=&lt;span&gt;
ExecStart=/usr/local/bin/kubelet $KUBELET_KUBECONFIG_ARGS $KUBELET_CONFIG_ARGS $KUBELET_SYSTEM_ARGS $KUBELET_EXTRA_ARGS&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@k8s-master01 bootstrap]# vim /etc/kubernetes/kubelet-&lt;span&gt;conf.yml
[root@k8s-master01 bootstrap]# cat !&lt;span&gt;$
cat /etc/kubernetes/kubelet-&lt;span&gt;conf.yml
apiVersion: kubelet.config.k8s.io/&lt;span&gt;v1beta1
kind: KubeletConfiguration
address: 0.0.0.0&lt;span&gt;
port: 10250&lt;span&gt;
readOnlyPort: 10255&lt;span&gt;
authentication:
  anonymous:
    enabled: false&lt;span&gt;
  webhook:
    cacheTTL: 2m0s
    enabled: true&lt;span&gt;
  x509:
    clientCAFile: /etc/kubernetes/pki/&lt;span&gt;ca.pem
authorization:
  mode: Webhook
  webhook:
    cacheAuthorizedTTL: 5m0s
    cacheUnauthorizedTTL: 30s
cgroupDriver: cgroupfs
cgroupsPerQOS: true&lt;span&gt;
clusterDNS:
- 10.96.0.10&lt;span&gt;
clusterDomain: cluster.local
containerLogMaxFiles: 5&lt;span&gt;
containerLogMaxSize: 10Mi
contentType: application/&lt;span&gt;vnd.kubernetes.protobuf
cpuCFSQuota: true&lt;span&gt;
cpuManagerPolicy: none
cpuManagerReconcilePeriod: 10s
enableControllerAttachDetach: true&lt;span&gt;
enableDebuggingHandlers: true&lt;span&gt;
enforceNodeAllocatable:
-&lt;span&gt; pods
eventBurst: 10&lt;span&gt;
eventRecordQPS: 5&lt;span&gt;
evictionHard:
  imagefs.available: 15%&lt;span&gt;
  memory.available: 100Mi
  nodefs.available: 10%&lt;span&gt;
  nodefs.inodesFree: 5%&lt;span&gt;
evictionPressureTransitionPeriod: 5m0s
failSwapOn: true&lt;span&gt;
fileCheckFrequency: 20s
hairpinMode: promiscuous-&lt;span&gt;bridge
healthzBindAddress: 127.0.0.1&lt;span&gt;
healthzPort: 10248&lt;span&gt;
httpCheckFrequency: 20s
imageGCHighThresholdPercent: 85&lt;span&gt;
imageGCLowThresholdPercent: 80&lt;span&gt;
imageMinimumGCAge: 2m0s
iptablesDropBit: 15&lt;span&gt;
iptablesMasqueradeBit: 14&lt;span&gt;
kubeAPIBurst: 10&lt;span&gt;
kubeAPIQPS: 5&lt;span&gt;
makeIPTablesUtilChains: true&lt;span&gt;
maxOpenFiles: 1000000&lt;span&gt;
maxPods: 110&lt;span&gt;
nodeStatusUpdateFrequency: 10s
oomScoreAdj: -999&lt;span&gt;
podPidsLimit: -1&lt;span&gt;
registryBurst: 10&lt;span&gt;
registryPullQPS: 5&lt;span&gt;
resolvConf: /etc/&lt;span&gt;resolv.conf
rotateCertificates: true&lt;span&gt;
runtimeRequestTimeout: 2m0s
serializeImagePulls: true&lt;span&gt;
staticPodPath: /etc/kubernetes/&lt;span&gt;manifests
streamingConnectionIdleTimeout: 4h0m0s
syncFrequency: 1m0s
volumeStatsAggPeriod: 1m0s&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　启动所有节点kubelet&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
systemctl daemon-&lt;span&gt;reload
systemctl enable --now kubelet&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　查看集群状态&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1095387/201912/1095387-20191227221846141-309454373.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;　　Kube-Proxy配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
cd /root/k8s-ha-install&lt;br/&gt;kubectl -n kube-system create serviceaccount kube-&lt;span&gt;proxy
kubectl create clusterrolebinding system:kube-proxy         --clusterrole system:node-proxier         --serviceaccount kube-system:kube-&lt;span&gt;proxy
SECRET=$(kubectl -n kube-system get sa/kube-&lt;span&gt;proxy \
    --output=jsonpath='{.secrets[0].name}'&lt;span&gt;)
JWT_TOKEN=$(kubectl -n kube-system get secret/&lt;span&gt;$SECRET \
--output=jsonpath='{.data.token}' | base64 -&lt;span&gt;d)
PKI_DIR=/etc/kubernetes/&lt;span&gt;pki
K8S_DIR=/etc/&lt;span&gt;kubernetes
kubectl config set-cluster kubernetes     --certificate-authority=/etc/kubernetes/pki/ca.pem     --embed-certs=true     --server=https://192.168.1.88:8443     --kubeconfig=${K8S_DIR}/kube-proxy.kubeconfig
kubectl config set-credentials kubernetes     --token=${JWT_TOKEN}     --kubeconfig=/etc/kubernetes/kube-&lt;span&gt;proxy.kubeconfig
kubectl config set-context kubernetes     --cluster=kubernetes     --user=kubernetes     --kubeconfig=/etc/kubernetes/kube-&lt;span&gt;proxy.kubeconfig
kubectl config use-context kubernetes     --kubeconfig=/etc/kubernetes/kube-proxy.kubeconfig&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　赋值Service文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@k8s-master01 k8s-ha-install]# for NODE in k8s-master01 k8s-master02 k8s-master03; do
     scp ${K8S_DIR}/kube-proxy.kubeconfig $NODE:/etc/kubernetes/kube-&lt;span&gt;proxy.kubeconfig
     scp kube-proxy/kube-proxy.conf $NODE:/etc/kubernetes/kube-&lt;span readability=&quot;2.5&quot;&gt;proxy.conf
     scp kube-proxy/kube-proxy.service $NODE:/usr/lib/systemd/system/kube-&lt;span readability=&quot;5&quot;&gt;proxy.service
 done
&lt;p&gt;&lt;span&gt;
&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; 
[root@k8s-master01 k8s-ha-install&lt;span&gt;]# 
[root@k8s-master01 k8s-ha-install]# for NODE in k8s-node01 k8s-node02; do
     scp /etc/kubernetes/kube-proxy.kubeconfig $NODE:/etc/kubernetes/kube-&lt;span&gt;proxy.kubeconfig
     scp kube-proxy/kube-proxy.conf $NODE:/etc/kubernetes/kube-&lt;span&gt;proxy.conf
     scp kube-proxy/kube-proxy.service $NODE:/usr/lib/systemd/system/kube-&lt;span&gt;proxy.service
 done&lt;span&gt;
&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　所有节点启动kube-proxy&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[root@k8s-master01 k8s-ha-install]# systemctl daemon-&lt;span&gt;reload
[root@k8s-master01 k8s-ha-install]# systemctl enable --now kube-&lt;span&gt;proxy
Created symlink /etc/systemd/system/multi-user.target.wants/kube-proxy.service → /usr/lib/systemd/system/kube-proxy.service.&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;9. 安装calico&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　安装Calico 3.11.1&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@k8s-master01 Calico]# cd /root/k8s-ha-install/Calico/&lt;span&gt;

[root@k8s-master01 Calico]# kubectl create -&lt;span&gt;f calico.yaml 
configmap/calico-&lt;span&gt;config created
customresourcedefinition.apiextensions.k8s.io/&lt;span&gt;felixconfigurations.crd.projectcalico.org created
customresourcedefinition.apiextensions.k8s.io/&lt;span&gt;ipamblocks.crd.projectcalico.org created
customresourcedefinition.apiextensions.k8s.io/&lt;span&gt;blockaffinities.crd.projectcalico.org created
customresourcedefinition.apiextensions.k8s.io/&lt;span&gt;ipamhandles.crd.projectcalico.org created
customresourcedefinition.apiextensions.k8s.io/&lt;span&gt;ipamconfigs.crd.projectcalico.org created
customresourcedefinition.apiextensions.k8s.io/&lt;span&gt;bgppeers.crd.projectcalico.org created
customresourcedefinition.apiextensions.k8s.io/&lt;span&gt;bgpconfigurations.crd.projectcalico.org created
customresourcedefinition.apiextensions.k8s.io/&lt;span&gt;ippools.crd.projectcalico.org created
customresourcedefinition.apiextensions.k8s.io/&lt;span&gt;hostendpoints.crd.projectcalico.org created
customresourcedefinition.apiextensions.k8s.io/&lt;span&gt;clusterinformations.crd.projectcalico.org created
customresourcedefinition.apiextensions.k8s.io/&lt;span&gt;globalnetworkpolicies.crd.projectcalico.org created
customresourcedefinition.apiextensions.k8s.io/&lt;span&gt;globalnetworksets.crd.projectcalico.org created
customresourcedefinition.apiextensions.k8s.io/&lt;span&gt;networkpolicies.crd.projectcalico.org created
customresourcedefinition.apiextensions.k8s.io/&lt;span&gt;networksets.crd.projectcalico.org created
clusterrole.rbac.authorization.k8s.io/calico-kube-&lt;span&gt;controllers created
clusterrolebinding.rbac.authorization.k8s.io/calico-kube-&lt;span&gt;controllers created
clusterrole.rbac.authorization.k8s.io/calico-&lt;span&gt;node created
clusterrolebinding.rbac.authorization.k8s.io/calico-&lt;span&gt;node created
daemonset.apps/calico-&lt;span&gt;node created
serviceaccount/calico-&lt;span&gt;node created
deployment.apps/calico-kube-&lt;span&gt;controllers created
serviceaccount/calico-kube-controllers created&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 　　查看Calico状态&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@k8s-master01 Calico]# kubectl get po -n kube-system -&lt;span&gt;owide
NAME                                       READY   STATUS    RESTARTS   AGE   IP              NODE           NOMINATED NODE   READINESS GATES
calico-kube-controllers-648f4868b8-pvz8k   1/1     Running   0          61s   10.244.85.193   k8s-node01     &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;&lt;span&gt;
calico-node-54fdt                          1/1     Running   0          61s   192.168.1.20    k8s-master03   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;&lt;span&gt;
calico-node-7f9vj                          1/1     Running   0          61s   192.168.1.18    k8s-master02   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;&lt;span&gt;
calico-node-msctk                          1/1     Running   0          61s   192.168.1.19    k8s-master01   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;&lt;span&gt;
calico-node-rbxcr                          1/1     Running   0          61s   192.168.1.22    k8s-node02     &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;&lt;span&gt;
calico-node-s5mb4                          1/1     Running   0          61s   192.168.1.21    k8s-node01     &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;&lt;span&gt;
[root@k8s-&lt;span&gt;master01 Calico]# kubectl get node
NAME           STATUS   ROLES    AGE   VERSION
k8s-master01   Ready    &amp;lt;none&amp;gt;   23h   v1.17.0&lt;span&gt;
k8s-master02   Ready    &amp;lt;none&amp;gt;   23h   v1.17.0&lt;span&gt;
k8s-master03   Ready    &amp;lt;none&amp;gt;   23h   v1.17.0&lt;span&gt;
k8s-node01     Ready    &amp;lt;none&amp;gt;   23h   v1.17.0&lt;span&gt;
k8s-node02     Ready    &amp;lt;none&amp;gt;   23h   v1.17.0&lt;span&gt;
[root@k8s-master01 Calico]# kubectl cluster-info&lt;span&gt;
Kubernetes master is running at https://192.168.1.88:8443&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;10、安装CoreDNS&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@k8s-master01 Calico]# cd /root/k8s-ha-install/CoreDNS/&lt;span&gt;
[root@k8s-master01 CoreDNS]# kubectl create -&lt;span&gt;f coredns.yaml 
serviceaccount/&lt;span&gt;coredns created
clusterrole.rbac.authorization.k8s.io/&lt;span&gt;system:coredns created
clusterrolebinding.rbac.authorization.k8s.io/&lt;span&gt;system:coredns created
configmap/&lt;span&gt;coredns created
deployment.apps/&lt;span&gt;coredns created
service/kube-dns created&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　查看状态&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
[root@k8s-master01 CoreDNS]# kubectl get po -n kube-&lt;span&gt;system
NAME                                       READY   STATUS    RESTARTS   AGE
calico-kube-controllers-648f4868b8-pvz8k   1/1     Running   0&lt;span&gt;          2m25s
calico-node-54fdt                          1/1     Running   0&lt;span&gt;          2m25s
calico-node-7f9vj                          1/1     Running   0&lt;span&gt;          2m25s
calico-node-msctk                          1/1     Running   0&lt;span&gt;          2m25s
calico-node-rbxcr                          1/1     Running   0&lt;span&gt;          2m25s
calico-node-s5mb4                          1/1     Running   0&lt;span&gt;          2m25s
coredns-76b74f549-7znbw                    1/1     Running   0&lt;span&gt;          30s
[root@k8s-master01 CoreDNS]# kubectl logs -f coredns-76b74f549-7znbw -n kube-&lt;span&gt;system
.:53&lt;span&gt;
[INFO] plugin/reload: Running configuration MD5 =&lt;span&gt; 8b19e11d5b2a72fb8e63383b064116a1
CoreDNS-1.6.6&lt;span&gt;
linux/amd64, go1.13.5, 6a7a75e&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;11、 集群验证&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　安装busybox&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
cat&amp;lt;&amp;lt;EOF | kubectl apply -f -&lt;span&gt;
apiVersion: v1
kind: Pod
metadata:
  name: busybox
  namespace: default
spec:
  containers:
  -&lt;span&gt; name: busybox
    image: busybox:1.28&lt;span&gt;
    command:
      - sleep
      - &quot;3600&quot;&lt;span&gt;
    imagePullPolicy: IfNotPresent
  restartPolicy: Always
EOF&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　验证解析&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@k8s-master01 CoreDNS]# kubectl exec  busybox -n default --&lt;span&gt; nslookup kubernetes
Server:    10.96.0.10&lt;span&gt;
Address 1: 10.96.0.10 kube-dns.kube-&lt;span&gt;system.svc.cluster.local

Name:      kubernetes
Address 1: 10.96.0.1&lt;span&gt; kubernetes.default.svc.cluster.local

[root@k8s-master01 CoreDNS]# kubectl exec  busybox -n default -- nslookup kube-dns.kube-&lt;span&gt;system
Server:    10.96.0.10&lt;span&gt;
Address 1: 10.96.0.10 kube-dns.kube-&lt;span&gt;system.svc.cluster.local

Name:      kube-dns.kube-&lt;span&gt;system
Address 1: 10.96.0.10 kube-dns.kube-system.svc.cluster.local&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;&lt;span&gt;　　至此集群安装完毕，其他组件可以参考本博客其他版本安装的文档。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　参考《再也不踩坑的Kubernetes实战指南》&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;赞助作者一杯奶茶:&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1095387/201911/1095387-20191103001629637-1866534736.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 28 Dec 2019 14:19:00 +0000</pubDate>
<dc:creator>杜先生的博客</dc:creator>
<og:description>1. 基本说明 本文章将演示CentOS 8二进制方式安装高可用k8s 1.17.x，相对于其他版本，二进制安装方式并无太大区别。 2. 基本环境配置 主机信息 系统环境 配置所有节点hosts文件</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/dukuan/p/12104600.html</dc:identifier>
</item>
<item>
<title>JVM垃圾回收 - boardMan</title>
<link>http://www.cnblogs.com/CodeMLB/p/12113279.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CodeMLB/p/12113279.html</guid>
<description>&lt;h2 id=&quot;垃圾的定义&quot;&gt;“垃圾”的定义&lt;/h2&gt;
&lt;h3 id=&quot;对象是否为垃圾&quot;&gt;对象是否为“垃圾”&lt;/h3&gt;
&lt;p&gt;判断对象是否已成为“垃圾”的两种方法：&lt;strong&gt;引用计数法&lt;/strong&gt;、&lt;strong&gt;可达性分析算法&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;引用计数法&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;如果一个对象被引用一次，则加1，如果没人引用则被回收；存在问题：如果两个对象循环引用，但是没有任何外部对象引用他们俩，则那两个对象无法被回收。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;可达性分析算法(主流JVM采用)&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;没有被根对象(GC ROOT)直接或简介引用的对象则会被回收&lt;br/&gt;根对象--肯定不能对回收的对象&lt;br/&gt;GC ROOT对象：system class、同步锁、线程类、本地方法类&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;何为引用--四种引用类型&quot;&gt;何为“引用”--四种引用类型&lt;/h3&gt;
&lt;p&gt;JDK1.2以后将引用分为：强引用、软引用、弱引用和虚引用4种，强度依次减弱。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;强引用&lt;br/&gt;被GC ROOT直接引用（等号赋值&lt;/li&gt;
&lt;li&gt;软引用&lt;br/&gt;被GC ROOT间接引用；当内存不足时被回收，内存充足时不会被回收&lt;/li&gt;
&lt;li&gt;弱引用&lt;br/&gt;没有GC ROOT直接引用，当发生垃圾回收时，&lt;strong&gt;不管内存是否充足都会被回收&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;虚引用&lt;br/&gt;没有GC ROOT直接引用，虚引用使用时必须配合引用队列进行管理。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;比如创建一个ByteBuffer实现类对象时，会创建个一个Cleaner对象，当ByteBuffer实现类对象没有再被引用时，ByteBuffer实现类对象会被回收，Cleaner对象则会进入引用队列，这时候一个referencehandles线程会查找引用队列中是否存在cleaner对象，如果有则调用Cleaner.clean方法，clean方法则根据记录的直接内存的地址，调用unsafe.freememory方法释放直接内存&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;补充：引用队列&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;软引用、弱引用本身也要占用一定内存，当软引用、弱引用的引用对象都被回收时，则进入引用队列，会对引用队列进行后续管理；虚引用引用的对象被释放后，虚引用会进入引用队列&lt;/p&gt;
&lt;h3 id=&quot;最后的挣扎--finalize方法&quot;&gt;最后的挣扎--finalize()方法&lt;/h3&gt;
&lt;p&gt;即使可达性分析后，对象被判定为“垃圾”，也并非非死不可。一个对象的死亡至少需要两次标记：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;没有与GC Root的引用链，标记一次&lt;br/&gt;对象没有重写finalize()方法，或finalize()重写但已被调用过一次，标记第二次&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果重写了finalize()方法，且还没有被调用，那么对象会被放置在F-Queue的队列中，会有一条虚拟机自建的、优先度较低的线程Finalizer线程去执行对象的finalize()方法，但为了防止finalize()方法出现死循环等异常，并不会保证等待finalize()方法执行结束。在此期间，若对象建立了引用链，则对象可以存活一次，否则就“死定了”。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;不建议使用该finalize()方法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;回收方法区&quot;&gt;回收方法区&lt;/h3&gt;
&lt;p&gt;方法区的垃圾回收主要包含两部分：废弃的常量、不再使用的类型&lt;/p&gt;
&lt;p&gt;常量的回收类似与Java堆中的对象，当没有引用时，则允许回收&lt;br/&gt;类型的回收相对比较苛刻，需要同时满足以下条件，才&lt;strong&gt;允许&lt;/strong&gt;被回收&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;该类所有实例都已被回收&lt;/li&gt;
&lt;li&gt;该类的类加载器已被回收&lt;/li&gt;
&lt;li&gt;该类对应的java.lang.Class对象没有被引用，且在任何地方都不可以通过反射访问该类方法&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h2 id=&quot;垃圾回收算法&quot;&gt;垃圾回收算法&lt;/h2&gt;
&lt;p&gt;从判定垃圾消亡的角度出发，垃圾回收算法可以划分为“引用计数式垃圾收集”、“追踪式垃圾收集”两类。在Java虚拟机中的讨论都在追踪式垃圾收集的范畴中。&lt;/p&gt;
&lt;h3 id=&quot;回收的前置--分代理论&quot;&gt;回收的前置--分代理论&lt;/h3&gt;
&lt;p&gt;分代设计的理论建立在两个分代假说之上：&lt;/p&gt;
&lt;ol readability=&quot;1.5&quot;&gt;&lt;li&gt;弱分代假说：新生对象都是朝生夕死&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;强分代假说：熬过越多次垃圾回收的对象，就越难以消亡&lt;/p&gt;
&lt;p&gt;设计原则：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;垃圾收集器应该依据对象的年龄，把Java堆划分为不同的区域。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;新生代&lt;br/&gt;朝生夕灭的对象集中在一个区域，每次回收只需关注少量需要存活的对象即可&lt;/li&gt;
&lt;li&gt;老年代&lt;br/&gt;难以消亡的对象集中在一个区域，可以使用较低的频率去触发回收机制&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;但是，在对新生代进行垃圾收集的时候，不免会出现新生代的中的对象被老年代引用的情况。所以，为了确定新生代区域的存活对象，除了GC Root之外还需要遍历整个老年代中所有对象来获得准确的可达性分析。基于此，引入第三条经验法则：&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;跨代引用假说：跨代引用相对于同代引用来说只占少数&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;跨代引用一般倾向于两个对象同时生存或同时消亡的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;设计原则：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;在新生代建立全局数据结构（记忆集），把老年代分为若干小块，记录老年代中哪一块内存存在跨代引用&lt;br/&gt;此后，发生minor gc时只有包含了跨代引用的小块内存中的对象才会被加入到GC Root进行扫描&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;标记-清除算法mark-sweep&quot;&gt;标记-清除算法(Mark Sweep)&lt;/h3&gt;
&lt;p&gt;先标记需要回收的对象，再统一清除&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;效率不稳定，随着对象数量增多，标记、清除两个过程的执行效率降低&lt;br/&gt;内存碎片化，导致存入大对象时无法获得足够的连续内存空间，触发另一次垃圾收集动作&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;标记-复制算法&quot;&gt;标记-复制算法&lt;/h3&gt;
&lt;p&gt;将可用内存划分为两个完全相等空间，每次只使用其中的一块。如果其中的一块内存用完，则将存活的对象完全复制到另一块，再对原来的空间进行统一清除回收。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;缺点&lt;br/&gt;内存空间的浪费&lt;br/&gt;若空间内大量对象都是存活的，复制的开销增大&lt;/li&gt;
&lt;li&gt;优点&lt;br/&gt;简单高效&lt;br/&gt;不用考虑内存空间碎片化&lt;br/&gt;PS.&lt;br/&gt;现商用Java虚拟机多在新生代中采用该方法&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;Appel式回收&lt;br/&gt;HotSpot虚拟机中的Serial、ParNew等新生代收集器均采取该策略。具体如下：&lt;br/&gt;把新生代分为一块较大的Eden空间和两块较小的Survivor空间，每次分配只使用Eden和一块Survivor，发生垃圾回收时，将存活的对象一次性复制给另一块Survivor空间内，然后清理已用的空间。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;HotSpot虚拟机给Eden和Survivor默认大小比例为8:1，也就是说会有10%的空间会被浪费。当预留的10%的内存空间存不下存活的对象时，，就需要依赖其它内存空间（大多为老年代）进行内存分配。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;标记-整理算法mark-compact&quot;&gt;标记-整理算法(Mark Compact)&lt;/h3&gt;
&lt;p&gt;区别与标记--清除算法，标记--整理算法，在标记后将存活的对象移向一端，然后将另一端的空间整体回收，是一种&lt;strong&gt;移动式&lt;/strong&gt;的算法。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;优点&lt;br/&gt;不存在碎片化内存，则无需依赖复杂的内存分配器&lt;/li&gt;
&lt;li&gt;缺点&lt;br/&gt;对象的移动操作需要触发“Stop The World”耗时较久&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;标记清除整理&quot;&gt;标记?清除:整理&lt;/h3&gt;
&lt;p&gt;标记-清除是一种非移动式算法、标记-整理是一种移动式算法，两者比较说明：&lt;/p&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;吞吐量比较&lt;br/&gt;吞吐量定义：赋值器和收集器效率之和&lt;br/&gt;不移动会使得收集器效率增大，但是内存分配和访问会比垃圾回收频率高得多，所以整体吞吐量还是降低的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;举例说明&lt;br/&gt;HotSpot虚拟机中关注吞吐量的Parallel Scavenger收集器基于标记-整理算法；关注低延迟的CMS收集器基于标记-清除算法&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;混合方案&lt;br/&gt;使虚拟机多数时间采用标记-清除算法，暂时容忍碎片的存在，等到碎片化程度开始影响对象的内存分配时，在采用标记-整理算法收集一次（CMS就采取该方式）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;经典垃圾回收器&quot;&gt;经典垃圾回收器&lt;/h2&gt;
&lt;p&gt;所谓“经典”垃圾回收器是指区别于实验室阶段的、已通过应用实践的垃圾回收器。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://139.196.90.125/imgs/JVM_HotSpot_collectors.jpg&quot; alt=&quot;HotSpot垃圾回收器&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;serial收集器&quot;&gt;Serial收集器&lt;/h3&gt;
&lt;p&gt;Serial：新生代：标记-复制算法&lt;br/&gt;Serial Old：老年代：标记-整理算法&lt;br/&gt;HotSpot虚拟机运行在客户端模式下的默认新生代收集器&lt;br/&gt;简单高效、内存消耗最小&lt;/p&gt;
&lt;h3 id=&quot;parnew收集器&quot;&gt;ParNew收集器&lt;/h3&gt;
&lt;p&gt;ParNew：新生代：标记-复制算法&lt;br/&gt;Serial Old：老年代：标记-整理算法&lt;br/&gt;激活CMS后，默认的新生代收集器&lt;br/&gt;Serial的多线程版本，默认开启的线程数与CPU核心数相同&lt;/p&gt;
&lt;h3 id=&quot;parallel-scavenge搜集器&quot;&gt;Parallel Scavenge搜集器&lt;/h3&gt;
&lt;p&gt;标记-复制算法，与ParNew相似&lt;br/&gt;关注点在于达成可控制的吞吐量（吞吐量=用户代码运行时间/总时间；总时间=用户代码运行时间+垃圾回收时间）&lt;/p&gt;
&lt;h4 id=&quot;参数说明&quot;&gt;参数说明&lt;/h4&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;code&gt;-XXMaxGCPauseMillis&lt;/code&gt;更关注停顿时间&lt;br/&gt;一个大于0的毫秒数，尽量使回收时间不超过这个值&lt;br/&gt;实现原理：牺牲吞吐量和新生代空间获取，小内存新生代空间的回收速度一定由于高内存速度，但是回收频率也会增加&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;-XXGCTimeRatio&lt;/code&gt;更关注吞吐量&lt;br/&gt;0到100之间的整数，代表垃圾回收时间占总时间的比率，相当于吞吐量的倒数&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;code&gt;-UserAdaptiveSizePolicy&lt;/code&gt;&lt;br/&gt;开关函数，激活后虚拟机会根据当前运行情况自动调整Eden与Survivor的内存比例、老年代内存大小等参数，已提供合适的停顿时间和最大吞吐量&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;serial-old-收集器&quot;&gt;Serial Old 收集器&lt;/h3&gt;
&lt;p&gt;serial 收集器的老年版本，标记-整理算法&lt;br/&gt;在CMS收集器并发失败时的预备方案&lt;/p&gt;
&lt;h3 id=&quot;parallel-old-收集器&quot;&gt;Parallel Old 收集器&lt;/h3&gt;
&lt;p&gt;Parallel Scavenge 收集器的老年版本，标记-整理算法&lt;br/&gt;在注重吞吐量或处理器资源稀缺时使用&lt;/p&gt;
&lt;h3 id=&quot;cms收集器&quot;&gt;CMS收集器&lt;/h3&gt;
&lt;p&gt;获取最短停顿时间的为目标，采用并发-清除算法&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;工作步骤
&lt;ol readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;初始标记&lt;br/&gt;标记GC Roots能直接关联的对象，速度很快&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;并发标记&lt;br/&gt;从GC Roots直接关联到的对象开始遍历整个对象图，耗时较长&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;重新标记&lt;br/&gt;修正并发标记期间，因用户继续运作导致标记产生变动的部分对象的标记记录&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;并发清除&lt;br/&gt;清除掉标记的已死亡的对象&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;整个过程中，并发标记和并发清除耗时最久&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;关键问题
&lt;ol readability=&quot;4&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;并发过程中会占用部分资源&lt;br/&gt;当处理器核心数大于4时，默认回收线程数不超过25%(处理器核心数+3)/4&lt;br/&gt;但是当处理器核心数小于4时，用户线程执行速度会大幅降低&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;“浮动垃圾”与并发失败&lt;br/&gt;与用户程序运行并发运行就必然产生新的垃圾只有等下一次回收时才清理，这部分垃圾称为“浮动垃圾”，所以需要给用户线程预留足够空间。因此，CMS不能等老年代满了才进行收集，必须预留一部分作为并发时使用。如果CMS运行期间预留的内存无法满足程序分配新对象的需求，就会出现“并发失败”，这时候需要STW，临时启用Serial Old收集器对老年代的垃圾进行收集&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;内存碎片&lt;br/&gt;基于标记-清除算法必然产生内存碎片，导致大对象分配时出现内存不足进而触发Full GC。CMS提供&lt;code&gt;-XX:UseCMSCompactAtFullCollection&lt;/code&gt;开关参数（默认开启），当不得不进行Full GC时进行内存碎片整合，即移动存活对象。会使得停顿时间延长&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;garbage-first-收集器&quot;&gt;Garbage First 收集器&lt;/h3&gt;
&lt;p&gt;建立可预测的停顿时间模型，开创了面向局部收集的内存设计思路，基于Region的内存布局形式。默认停顿时间为200毫秒&lt;/p&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;基于Region的内存布局&lt;br/&gt;把连续的Java堆内存划分为多个大小相等的独立空间，每个空间都可以扮演Eden、Survivor空间或者老年代空间，其中Humongous区域转为收集大对象（大小超过了一个Region的对象，Region的大小可通过参数调整），G1大多会把Humongous当做老年代看待。收集器可以根据不同的角色采取不同的收集策略。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;局部收集思想&lt;br/&gt;Region作为每次回收的最小内存单位，每次收集到的空间都是Region的整倍数，G1会跟踪Region堆积的“价值”大小（回收所获空间/回收所需时间的经验值），再后台维护一个优先级列表，优先回收价值大的Region&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;工作步骤
&lt;ol&gt;&lt;li&gt;初始标记&lt;br/&gt;标记GC Roots能直接关联的对象，并修改TAMS指针的值，是借助Minor GC完成，所以不会造成额外的时间成本。&lt;/li&gt;
&lt;li&gt;并发标记&lt;br/&gt;从GC Roots开始对堆中对象进行可达性分析，可并发执行，扫描完成时重新处理SATB记录的引用变动&lt;/li&gt;
&lt;li&gt;最终标记&lt;br/&gt;处理并发标记时的发生变动的对象，STW，并发完成&lt;/li&gt;
&lt;li&gt;筛选回收&lt;br/&gt;更新Region的统计数据，根据用户期望的停顿时间结合回收价值，确定需要回收Region集合。把需要回收的Region中存活的对象复制到空Region中，再清理需要回收的全部Region区域。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;关键问题
&lt;ol readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;跨Region引用的处理办法&lt;br/&gt;每个Region都维护一张自己的记忆集，记录别的Region指向自己的指针，并标记这些指针在哪些卡页范围之内。其存储结构本质上是一种哈希表，key是别的Region的起始地址，value是一个集合，存储卡表的索引号。G1要耗费大越10%到20%的额外内存来维持收集器的工作。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;并发干扰问题&lt;br/&gt;CMS在并发标记时采用增量更新的算法实现，而G1则通过原始快照(SATB)算法实现。此外，G1在回收过程中创建新对象的内存分配上也做了改动，G1为每个Region设计了两个名为TAMS(Top At Mark Start)的指针，并发标记中新分配的对象都要在这两个指针位置以上。G1收集器默认这部分对象是隐式标记过的，默认为存活&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;可靠地停顿预测&lt;br/&gt;&lt;code&gt;-XX:MaxGCPauseMillis&lt;/code&gt;参数指用户期望的停顿时间，具体实现是以“衰减均值”为理论基础：在垃圾回收过程中，会记录每个Region的回收耗时、记忆集中里的脏卡数量等各个可测量的步骤所花费的成本。“衰减均值”更能体现“最近”一段时间的平均状态，更能在当下使回收不超过预期。（有点活在当下的感觉）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;G1与CMS
&lt;ul&gt;&lt;li&gt;优点：&lt;br/&gt;可以指定最大停顿时间、分Region的内存布局、按收益动态回收、不会产生内存碎片、回收完成后可提供规整的可用内存&lt;/li&gt;
&lt;li&gt;缺点：&lt;br/&gt;内存占用、程序执行的额外负载都较高&lt;br/&gt;G1的卡表更为复杂；运行负载方面，CMS使用写后屏障来更细维护卡表，而G1为了实现原始搜索(SATB)快照算法，还需要写前屏障来跟踪并发时的指针变化情况，G1能减少并发标记和重新标记的消耗，避免像CMS那样在最终标记阶段停顿时间过长。CMS直接同步处理，而G1异步处理&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;总结&lt;br/&gt;小内存上使用CMS有优势，而大内存状态下使用G1有更多优势，而Java堆内存容量平衡点大约在6-8GB之间(经验数据)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;低延迟垃圾收集器&quot;&gt;低延迟垃圾收集器&lt;/h2&gt;
&lt;h3 id=&quot;shenandoah-收集器&quot;&gt;Shenandoah 收集器&lt;/h3&gt;
&lt;h3 id=&quot;zgc-收集器&quot;&gt;ZGC 收集器&lt;/h3&gt;
</description>
<pubDate>Sat, 28 Dec 2019 14:16:00 +0000</pubDate>
<dc:creator>boardMan</dc:creator>
<og:description>垃圾回收与内存分配策略 &amp;quot;垃圾回收与内存分配策略&amp;quot; &amp;quot;“垃圾”的定义&amp;quot; &amp;quot;对象是否为“垃圾”&amp;quot; &amp;quot;何为“引用” 四种引用类型&amp;qu</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/CodeMLB/p/12113279.html</dc:identifier>
</item>
<item>
<title>机器学习 - Python 02 - HappyPuppy</title>
<link>http://www.cnblogs.com/tangxiaobo199181/p/12113244.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tangxiaobo199181/p/12113244.html</guid>
<description>&lt;p&gt;好了，咱们接着上一节的内容，继续学习机器学习中的Python语法部分。这一节算是Python语法的最后一节了。也就是说如果真的看懂了这两节的内容，理论上说就机器学习的领域或者方向，语言已经不是问题了。同时也意味着马上真正的进入机器学习的核心部分了。好了，那咱们接下来正式开始咱们的学习啦。&lt;/p&gt;
&lt;p&gt;Tuples是Python中的一种新的形式的数据collection（至少相对于C++， objective-C，Java是新的。其他的我就不敢肯定了，免得被打脸，哈哈）。其实她和List几乎是一样的，除了2个方面的不同。她和list的区别主要是下面2个方面的不同：1）Tuples 的创建的展现是讲元素element用括号包起来，而List是用的中括号。2）Tuples一旦创建 元素是不可改变的，即它是immutable的，而List的元素是可以改变的，即Mutable的。好了，下面看一下tuples的创建代码展示一下，否则光说不练假把式。哈哈哈&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
t = (1,2,3)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的代码就是创建了一个tuple，他的元素有三个，分别是1,2,3. 那么既然有了list为什么还要Tuples呢？ 这主要是因为Tuple的应用场景主要是用于那些有多个返回值的函数中，想象一下，如果一个函数有多个返回值，你要怎么弄呢？对了，你肯定想到了List对吧？可是List里面的数据可能因为多人协同开发的时候被其他同事修改了，是会有一定Risk的。那么自然而然我们就想到了要用Tuples这个数据结构，因为他是Immutable的，如果有人试图修改她的值，他会报错的。总结起来就是List是可读可写的，而Tuples是只读的。看看下面这个返回多个值的例子吧。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
a = 0.125.as_integer_ratio()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的函数返回了2个值，分别是分子和分母，都是整型数据。返回的数据是（1,8）。&lt;/p&gt;
&lt;p&gt;关于Tuples还有一个点是Individual assignments(翻译过来应该是叫单独赋值，不知道翻译的对不对，容我装个B，哈哈哈)，这里的意思是讲Tuple中的值可以分别赋值给不同的变量，如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
numerator,demonstrater = a
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面代码的运行结果就是：numerator = 1, demonstrater = 8.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Dictionary&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;好了，现在接受最后一种形式的collection，就是字典。这和其他语言都很像，就是key-value键值对。好了，下面先来瞧一瞧咱们dictionary的创建&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
numbers = {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;one&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:1,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;two&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:2,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;three&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:3}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这和其他很多种的语言的都一样，再来看看如何通过Key值来retrieve value。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
numbers[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;one&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面介绍一下dictionary中的比较高级但是在实际中会经常用到的的功能，这些语法特性看起来挺牛逼，其实都是纸老虎，哈哈，心态上我们要藐视他妈，操作上要重视他们哈。&lt;/p&gt;
&lt;p&gt;1） in operator&lt;/p&gt;
&lt;p&gt;in的关键字是Python中最常见的一个关键字，没有之一！！！！在list中用，在dictionary中用，在条件判断时会用，在循环中还是会用的。既然这一节讲的是dictionary，我们就看看她在dictionary中的应用吧。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;create a dictionary&lt;/span&gt;
planets = [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Mercury&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Venus&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Earth&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Mars&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Jupiter&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Saturn&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Uranus&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Neptune&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
plants_to_initial &lt;/span&gt;= {planet:planet[0] &lt;span&gt;for&lt;/span&gt; planet &lt;span&gt;in&lt;/span&gt;&lt;span&gt; planets}
&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mercury&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; plants_to_initial  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; the in operator will tell us whether something is a key in the dictionary&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的创建字典代码现在看不懂没关系，她就是创建了一个字典，这个字典的key值是这些星星的名字，value值就是这些星星的首字母。这里重要的是最后一行代码，判断“Mercury”这个字符串是不是这个字典的key值。如果是key,返回True, 否则返回False。&lt;/p&gt;
&lt;p&gt;2）遍历key值&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;the for loop will loop over its keys&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; key &lt;span&gt;in&lt;/span&gt;&lt;span&gt; plants_to_initial:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(key,end = &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上代码所示，直接对dictionary遍历，返回的是每一个key-value键值对的key值。上面代码就是打印这个字典的所有的key值。&lt;/p&gt;
&lt;p&gt;3） 同事遍历key-value 键值对&lt;/p&gt;
&lt;p&gt;在字典中，如果想要同时遍历键值对，我们必须通过dictionary的一个method，叫做：items(). 这个方法返回一个list，里面的元素是tuples,这些tuples里面的元素就是key,values. 话不多说，直接上代码看&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt; planet, initial &lt;span&gt;in&lt;/span&gt; plants_to_initial.items():&lt;span&gt;#&lt;/span&gt;&lt;span&gt;items()will return its key-value pairs&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(planet,initial)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;好了，终于进入到最最常用的一种基本数据类型了-string。几乎在所用的应用中，产生和消费的数据，几乎字符串占了绝大部分。当然啦，在机器学习中最常用到的数据类型是int和float，但是string类型的也是经常会出现的。其实String可以将它看成一串字符，这一串字符就好比一个list。用英文来说就是 A string is a sequences of characters. (是不是瞬间高大上了，从大蒜变成了咖啡。哈哈哈哈)。 所以在Python中，几乎你在list中看到的方法，都同样适用于String. &lt;/p&gt;
&lt;p&gt;1) String 的创建和index&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
planet = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Pluto&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
planet[0]#return P
planet[&lt;/span&gt;-3&lt;span&gt;:]#return uto
len(planet)#return 5&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2)常用的String方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;string methods&lt;/span&gt;
&lt;span&gt;planet.upper()#return PLUTO
planet.lower()#return pluto
planet.index(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;uto&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)#return 2
planet.startswith(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Plu&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)#return True
planet.endswith(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;asds&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)#return False
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3) List 和 String之间的相互转换&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;going between strings and lists&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;string -&amp;gt; list   split method&lt;/span&gt;
planets = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Pluto is a planet&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
list_planets &lt;/span&gt;=&lt;span&gt; planets.split()#return a list of [&quot;Pluto&quot;,&quot;is&quot;,&quot;a&quot;,&quot;planet&quot;]
dates &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2019-10-08&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
list_dates &lt;/span&gt;= dates.split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)#returns [&quot;2019&quot;,&quot;10&quot;,&quot;08&quot;], the element are also all string types
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;list-&amp;gt;string  join method&lt;/span&gt;
year,month,day =&lt;span&gt; list_dates #individual assignment
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.join([year,month,day]) #returns &quot;2019/10/08&quot;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意无论是String-&amp;gt;List还是List-&amp;gt;String, 他们的基本元素都是String，而不会是Int或者Float或者其他什么稀奇古怪的数据类型。也就是说，无论是Split还是Join, 他们操作的对象都是String。例如：'/'.join([1,2,3]),这句代码就会报错，因为1，2,3都是整型数据而不是string。这里比较抽象哈，自己慢慢体会。&lt;/p&gt;
&lt;p&gt;4）formatting a string&lt;/p&gt;
&lt;p&gt;String是一个非常灵活的数据类型，例如int也可以转换成string，等等。因此我们常常需要将不同数据类型的数据拼接在一起，然后转换成一个string。这种情况下，我们经常需要用到format方法，当然也存在其他方法可以完成这个任务，但是format的牛逼之处不仅仅在于这，她还可以格式化数据的表现格式，例如保留几位小数点，大数字的表现形式等等，具体的可以参考下面的代码。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
position = 9
&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{}, you will be the {}th planet to me&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(planet,position) #returns 'Pluto, you will be the 9th planet to me'
&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{:.2}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;.format(0.123345&lt;span&gt;) #returns &quot;0.12&quot;, the result is converted to string type
&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{:,}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;.format(1234578&lt;span&gt;) #returns '1,234,578' the result is also converted to string type
&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{0},{1},{1},{0},{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;.format(12,55)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;indexing of format the result is '12,55,55,12,12', the result is also string type&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;Loop comprehension&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Loop comprehension 是Python中非常受欢迎的一个特性，她能够快速创建List和dictionary，并且使用起来非常灵活，在将来机器学习的实践中你们会发现非常好用。说了这么多，那么接下来我们来看看到底什么是Loop Comprehension.&lt;/p&gt;
&lt;p&gt;1) 利用Loop Comprehension 来快速创建dictionary。&lt;/p&gt;
&lt;p&gt;其实这已经在前面的代码中有所体现了，如下面的代码所示，快速创建字典。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
plants_to_initial = {planet:planet[0] &lt;span&gt;for&lt;/span&gt; planet &lt;span&gt;in&lt;/span&gt; planets}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其实就是用for in 的循环，然后通过key:value的形式，批量的产生键值对，最后生成一个字典。&lt;/p&gt;
&lt;p&gt;2）利用Loop Comprehension 来创建List&lt;/p&gt;
&lt;p&gt;List的创建也是很灵活的，也可以操作循环的元素，来达到一些个性化或者特殊需求的一些目的。甚至她还可以通过组合条件判断的语句达到更加精细化的控制，创建List的一些常用方式如下所示&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
numbers = [1,2,3,4&lt;span&gt;]
squares &lt;/span&gt;= [n**2 &lt;span&gt;for&lt;/span&gt; n &lt;span&gt;in&lt;/span&gt;&lt;span&gt; numbers] #returns [1,4,9,16]
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(squares)    
short_squares &lt;/span&gt;= [n &lt;span&gt;for&lt;/span&gt; n &lt;span&gt;in&lt;/span&gt; squares &lt;span&gt;if&lt;/span&gt; n&amp;lt;9&lt;span&gt;] #returns [1,4]
count_number_of_squares &lt;/span&gt;= len([n &lt;span&gt;for&lt;/span&gt; n &lt;span&gt;in&lt;/span&gt; squares &lt;span&gt;if&lt;/span&gt; n &amp;lt; 100]) #returns 4
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;总结： 前面一节内容还有这一节内容大体上已经介绍了常用Python的绝大部分特性，如果已经掌握，我觉得仅仅对于机器学习这个领域的学习的话，已经够用了。这两节的内容是给已经有其他语言经验的人准备的（如果一点计算机语言经验都没有，我建议还是从Hello World开始）&lt;/p&gt;
</description>
<pubDate>Sat, 28 Dec 2019 14:07:00 +0000</pubDate>
<dc:creator>HappyPuppy</dc:creator>
<og:description>好了，咱们接着上一节的内容，继续学习机器学习中的Python语法部分。这一节算是Python语法的最后一节了。也就是说如果真的看懂了这两节的内容，理论上说就机器学习的领域或者方向，语言已经不是问题了。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tangxiaobo199181/p/12113244.html</dc:identifier>
</item>
<item>
<title>Django框架之中间件MiddleWare - 老王同鞋</title>
<link>http://www.cnblogs.com/chao666/p/12113206.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chao666/p/12113206.html</guid>
<description>&lt;p&gt;Django中的中间件是一个轻量级、底层的插件系统，可以介入Django的请求和响应处理过程，修改Django的输入或输出。&lt;br/&gt;中间件的设计为开发者提供了一种无侵入式的开发方式，增强了Django框架的健壮性。&lt;br/&gt;我们可以使用中间件，在Django处理视图的不同阶段对输入或输出进行干预。&lt;/p&gt;
&lt;p&gt;中间件的原理其实就是定义了一个装饰器，但是这个装饰器可以对整个项目中的所有方法进行装饰；&lt;/p&gt;
&lt;p&gt;我们可以通过中间件，对请求对象和响应对象进行相应的干预操作。&lt;/p&gt;
&lt;p&gt;实现中间件的流程：&lt;/p&gt;
&lt;p&gt;1.在子应用中编写一个middleware.py的文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; my_middleware(get_response):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;中间件初始化&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; middlewraer(request, *args, **&lt;span&gt;kwargs):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;在执行执行前对请求进行干预&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 加入干预代码, 主要应用白名单黑名单&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; request.META[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;USER&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;KG&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; HttpResponse(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;该用户无法访问&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        ret &lt;/span&gt;= get_response(request, *args,**&lt;span&gt;kwargs)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;在执行后对响应进行干预&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; middlewrae
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2. 在setting文件中注册中间件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
MIDDLEWARE =&lt;span&gt; [
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;django.middleware.security.SecurityMiddleware&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;django.contrib.sessions.middleware.SessionMiddleware&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;django.middleware.common.CommonMiddleware&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 'django.middleware.csrf.CsrfViewMiddleware',&lt;/span&gt;
    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;django.contrib.auth.middleware.AuthenticationMiddleware&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;django.contrib.messages.middleware.MessageMiddleware&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;django.middleware.clickjacking.XFrameOptionsMiddleware&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;br/&gt;　　 &lt;span&gt;#&lt;span&gt; 注册中间件&lt;/span&gt;&lt;/span&gt;
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;users.middleware.my_middleware&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,  
]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意：Django运行在调试模式下，中间件init部分有可能被调用两次。&lt;/p&gt;
&lt;p&gt;多个中间件执行流程：&lt;/p&gt;
&lt;p&gt;1. 中间件会将setting文件中的MIDDLEWARE列表进行逆序，所以初始化的顺序时从下向上的;&lt;/p&gt;
&lt;p&gt;2. 在调用时，即编写顺序上第一个中间件装饰的是编写顺序上的第二个中间件，而编写顺序上的第二个中间件装饰的才是视图函数；&lt;/p&gt;
&lt;p&gt;3. 在调用结束返回时，会先将视图函数的结果返回给编写顺序上的第二个中间件，然后再返回给编写顺序上的第一个中间件。&lt;/p&gt;
&lt;p&gt;代码解读：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@decorator1
@decorator2
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; index(View):   
    &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Sat, 28 Dec 2019 13:58:00 +0000</pubDate>
<dc:creator>老王同鞋</dc:creator>
<og:description>Django中的中间件是一个轻量级、底层的插件系统，可以介入Django的请求和响应处理过程，修改Django的输入或输出。中间件的设计为开发者提供了一种无侵入式的开发方式，增强了Django框架的健</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chao666/p/12113206.html</dc:identifier>
</item>
</channel>
</rss>