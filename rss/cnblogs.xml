<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Springboot 系列（一）Spring Boot 入门篇 - 雪漫士兵</title>
<link>http://www.cnblogs.com/niumoo/p/10374908.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/niumoo/p/10374908.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：本 Spring Boot 系列文章基于 Spring Boot 版本 &lt;strong&gt;v2.1.1.RELEASE&lt;/strong&gt; 进行学习分析，版本不同可能会有细微差别。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2626549-a29354ccc74f5792.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;由于 J2EE 的开发变得笨重，繁多的配置，错乱的依赖管理，低下的开发效率，复杂的部署流程，第三方技术的集成难度较大等。同时随着复杂项目的演进，微服务分布式架构思想逐渐进入开发者的视野。&lt;/p&gt;
&lt;h2 id=&quot;spring-boot-介绍&quot;&gt;1. Spring Boot 介绍&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Spring Boot&lt;/code&gt; 提供了一组工具只需要极少的配置就可以快速的构建并启动基于 Spring 的应用程序。解决了传统 Spring 开发需要配置大量配置文件的痛点，同时 &lt;code&gt;Spring Boot&lt;/code&gt; 对于第三方库设置了合理的默认值，可以快速的构建起应用程序。当然 &lt;code&gt;Spring Boot&lt;/code&gt; 也可以轻松的自定义各种配置，无论是在开发的初始阶段还是投入生成的后期阶段。&lt;/p&gt;
&lt;h2 id=&quot;spring-boot-优点&quot;&gt;2. Spring Boot 优点&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;快速的创建可以独立运行的 Spring 项目以及与主流框架的集成。&lt;/li&gt;
&lt;li&gt;使用嵌入式的 Servlet 容器，用于不需要打成war包。&lt;/li&gt;
&lt;li&gt;使用很多的启动器（Starters）自动依赖与版本控制。&lt;/li&gt;
&lt;li&gt;大量的自动化配置，简化了开发，当然，我们也可以修改默认值。&lt;/li&gt;
&lt;li&gt;不需要配置 XML 文件，无代码生成，开箱即用。&lt;/li&gt;
&lt;li&gt;准生产环境的运行时应用监控。&lt;/li&gt;
&lt;li&gt;与云计算的天然集成。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;spring-boot-前置&quot;&gt;3. Spring Boot 前置&lt;/h2&gt;
&lt;p&gt;说了那么多的 Spring Boot 的好处，那么使用 Spring Boot 需要哪些前置知识呢？我简单列举了一下。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Spring 框架的使用。&lt;/li&gt;
&lt;li&gt;Maven 构建工具的使用。&lt;/li&gt;
&lt;li&gt;IDEA 或其他开发工具的使用。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;spring-boot-体验&quot;&gt;4. Spring Boot 体验&lt;/h2&gt;
&lt;p&gt;现在我们已经了解了 Spring Boot 是什么，下面我们将使用 Spring Boot 开发一个入门案例，来体验 Spring Boot 开发姿势是如何的优雅与迅速。&lt;br/&gt;Spring Boot 官方已经为我们如何快速启动 Spring Boot 应用程序提供了多种方式。&lt;/p&gt;
&lt;p&gt;你可以在 Spring 官方网站直接生成项目下载导入IDE进行开发。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;https://start.spring.io/&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也可以直接克隆 GitHub 上的初始项目进行体验。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;git clone https://github.com/spring-guides/gs-spring-boot.git
cd gs-spring-boot/initial&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我们选择后者，直接克隆进入到 initial 文件夹使用 maven 进行编译启动。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt; mvn package &amp;amp;&amp;amp; java -jar target/gs-spring-boot-0.1.0.jar&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第一次编译需要下载需要的依赖，耗时会比较长，编译完成之后紧接着可以看到 Spring 的启动标志。这时 Spring Boot 的 web程序已经运行在8080端口了。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ curl -s localhost:8080
Greetings from Spring Boot!&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;spring-boot-开发&quot;&gt;5. Spring Boot 开发&lt;/h2&gt;
&lt;p&gt;下面手动编写一个 Spring Boot 入门案例，快速的开发一个 web mvc 应用。&lt;br/&gt;项目结构如下：&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2626549-f6c15aca93b10703.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Spring boot 项目结构&quot;/&gt;&lt;/div&gt;
&lt;h3 id=&quot;依赖项&quot;&gt;5.1 依赖项&lt;/h3&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;
    &amp;lt;parent&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;2.1.1.RELEASE&amp;lt;/version&amp;gt;
        &amp;lt;relativePath/&amp;gt; &amp;lt;!-- lookup parent from repository --&amp;gt;
    &amp;lt;/parent&amp;gt;

    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;

    &amp;lt;/dependencies&amp;gt;

    &amp;lt;build&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;spring-boot-starter-parent&lt;/code&gt; 是Spring Boot 的核心依赖，它里面定义了各种在开发中会用到的第三方 jar 的版本信息，因此我们在引入其他的 Spring Boot 为我们封装的启动器的时候都不在需要指定版本信息。如果我们需要自定义版本信息，可以直接覆盖版本属性值即可。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;spring-boot-starter-web&lt;/code&gt; 提供 web 以及 MVC 和 validator 等web开发框架的支持。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;spring-boot-starter-test&lt;/code&gt; 提供测试模块的支持。如 Junit，Mockito。&lt;/p&gt;
&lt;p&gt;需要说明的是，Spring Boot 为我们提供了很多的已经封装好的称为启动器（starter）的依赖项。让我们在使用的时候不需要再进行复杂的配置就可以迅速的进行应用集成。所有的官方启动器依赖可以在&lt;a href=&quot;https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters&quot;&gt;这里&lt;/a&gt;查看。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;所有&lt;strong&gt;官方&lt;/strong&gt;发布的启动器都遵循类似的命名模式; &lt;code&gt;spring-boot-starter-*&lt;/code&gt;，这里&lt;code&gt;*&lt;/code&gt;是指特定类型的应用程序。此命名结构旨在帮助您寻找启动器。&lt;/p&gt;
&lt;p&gt;注意：编写自己的启动器的时候不应该使用这种命名方式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;启动类&quot;&gt;5.2 启动类&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@SpringBootApplication
public class HelloApplication {

    public static void main(String[] args) {
        SpringApplication.run(HelloApplication.class, args);
    }

    @Bean
    public CommandLineRunner commandLineRunner(ApplicationContext ctx) {
        return args -&amp;gt; {
            // 开始检查spring boot 提供的 beans
            System.out.println(&quot;Let's inspect the beans provided by Spring Boot:&quot;);
            String[] beanNames = ctx.getBeanDefinitionNames();
            Arrays.sort(beanNames);
            for (String beanName : beanNames) {
                System.out.println(beanName);
            }
        };
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;@SpringBootApplication&lt;/code&gt; 注解是一个便利的注解，它包含了以下几个注解。&lt;/p&gt;
&lt;ol readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;@Configuration&lt;/code&gt; 定义配置类。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;@EnableAutoConfiguration&lt;/code&gt; 开启自动配置。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;@EnableWebMvc&lt;/code&gt; 标记为 web应用程序。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;@ComponentScan&lt;/code&gt; 组件扫描。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;控制器&quot;&gt;5.3 控制器&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RestController
public class HelloController {
    @RequestMapping(&quot;/&quot;)
    public String index() {
        return &quot;Greetings from Spring Boot!&quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;@RestController&lt;/code&gt; 是 &lt;code&gt;@RestController&lt;/code&gt; 与 &lt;code&gt;@ResponseBody&lt;/code&gt; 的结合体。&lt;/p&gt;
&lt;h3 id=&quot;访问测试&quot;&gt;5.4 访问测试&lt;/h3&gt;
&lt;p&gt;直接启动 &lt;code&gt;HelloApplication.java&lt;/code&gt; 类就可以在控制台看到启动输出，然后访问8080端口查看启动是否正常。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2626549-c82aefb5192cbefb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Spring boot 项目结构&quot;/&gt;&lt;/div&gt;
&lt;p&gt;经过上面的例子，已经使用 Spring Boot 快速的创建了一个 web 应用并进行了简单的访问测试。&lt;/p&gt;
&lt;h2 id=&quot;spring-boot-单元测试&quot;&gt;6. Spring Boot 单元测试&lt;/h2&gt;
&lt;p&gt;结合上面提到的 Spring Boot 启动器知识，Spring Boot 已经为我们提供了丰富的第三方框架，测试框架也不例外。&lt;/p&gt;
&lt;p&gt;导入单元测试依赖。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;   &lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;模拟请求测试&quot;&gt;6.1 模拟请求测试&lt;/h3&gt;
&lt;p&gt;编写单元测试&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.MediaType;
import org.springframework.test.context.junit4.SpringRunner;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.request.MockMvcRequestBuilders;

import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

/**
 * 单元测试
 */
@RunWith(SpringRunner.class)
@SpringBootTest
@AutoConfigureMockMvc
public class HelloApplicationTests {

    @Autowired
    private MockMvc mvc;

    @Test
    public void contextLoads() throws Exception {
        mvc.perform(MockMvcRequestBuilders.get(&quot;/&quot;).accept(MediaType.APPLICATION_JSON))
                .andExpect(status().isOk())
                .andExpect(content().string(&quot;Greetings from Spring Boot!&quot;));
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关于上面代码的一些说明。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;MockMvc&lt;/strong&gt; 允许我们方便的发送 HTTP 请求。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SpringBootTest&lt;/strong&gt; 方便的创建一个 Spring Boot 项目的测试程序。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;运行没有任何异常说明程序测试通过。&lt;/p&gt;
&lt;h3 id=&quot;spring-boot-集成测试&quot;&gt;6.2 Spring Boot 集成测试&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.web.client.TestRestTemplate;
import org.springframework.boot.web.server.LocalServerPort;
import org.springframework.http.ResponseEntity;
import org.springframework.test.context.junit4.SpringRunner;

import java.net.URL;

/**
 * &amp;lt;p&amp;gt;
 * 嵌入式服务器由随机端口启动webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT
 * 并且在运行时发现实际端口@LocalServerPort
 *
 * @Author niujinpeng
 * @Date 2018/12/4 15:02
 */
@RunWith(SpringRunner.class)
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
public class HelloApplicationTestBySpringBoot {

    @LocalServerPort
    private int port;

    private URL base;

    @Autowired
    private TestRestTemplate template;

    @Before
    public void setup() throws Exception {
        this.base = new URL(&quot;http://localhost:&quot; + port + &quot;/&quot;);
    }

    @Test
    public void getHello() throws Exception {
        ResponseEntity&amp;lt;String&amp;gt; response = template.getForEntity(base.toString(), String.class);
        assert (response.getBody().equals(&quot;Greetings from Spring Boot!&quot;));
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;嵌入式服务器由随机端口启动 &lt;code&gt;webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;并且在运行时使用注解 &lt;code&gt;@LocalServerPort&lt;/code&gt; 发现实际端口。&lt;/p&gt;
&lt;p&gt;运行测试类通过输出。&lt;/p&gt;
&lt;pre class=&quot;log&quot;&gt;
&lt;code&gt;2018-12-06 22:28:01.914  INFO 14320 --- [o-auto-1-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring DispatcherServlet 'dispatcherServlet'
2018-12-06 22:28:01.914  INFO 14320 --- [o-auto-1-exec-1] o.s.web.servlet.DispatcherServlet        : Initializing Servlet 'dispatcherServlet'
2018-12-06 22:28:01.937  INFO 14320 --- [o-auto-1-exec-1] o.s.web.servlet.DispatcherServlet        : Completed initialization in 23 ms&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;文章代码已经上传到 GitHub &lt;a href=&quot;https://github.com/niumoo/springboot/tree/master/springboot-hello&quot;&gt;Spring Boot 入门案例&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&amp;lt;完&amp;gt;&lt;br/&gt;本文原发于个人博客：&lt;a href=&quot;https://www.codingme.net/&quot; class=&quot;uri&quot;&gt;https://www.codingme.net&lt;/a&gt; 转载请注明出处&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2626549-e1b06fdf782b78e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 14 Feb 2019 07:41:00 +0000</pubDate>
<dc:creator>雪漫士兵</dc:creator>
<og:description>注意：本 Spring Boot 系列文章基于 Spring Boot 版本 v2.1.1.RELEASE 进行学习分析，版本不同可能会有细微差别。 前言 由于 J2EE 的开发变得笨重，繁多的配置，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/niumoo/p/10374908.html</dc:identifier>
</item>
<item>
<title>.net webapi 接收 xml 格式数据的三种情况 - 野菊花</title>
<link>http://www.cnblogs.com/Jackyye/p/10374507.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Jackyye/p/10374507.html</guid>
<description>&lt;p&gt;前段时间接到一个任务写一个小接口，要接收java端返回过来的短信xml数据。&lt;/p&gt;
&lt;p&gt;刚拿到项目，我的第一想法是对方会以什么形式发送xml格式的数据给我呢，设想三种情况。&lt;/p&gt;
&lt;p&gt;我一开始拿到手上的是一串xml格式字符串。如下&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;returnForm&amp;gt;
  &amp;lt;type&amp;gt;2&amp;lt;/type&amp;gt;  
  &amp;lt;count&amp;gt;1&amp;lt;/count&amp;gt;  
  &amp;lt;list&amp;gt; 
    &amp;lt;pushSmsForm&amp;gt; 
      &amp;lt;eprId&amp;gt;0&amp;lt;/eprId&amp;gt;  
      &amp;lt;mobile&amp;gt;13560739262&amp;lt;/mobile&amp;gt;  
      &amp;lt;msgId&amp;gt;30217002&amp;lt;/msgId&amp;gt;  
      &amp;lt;content&amp;gt; &amp;lt;![CDATA[回复内容]]&amp;gt; &amp;lt;/content&amp;gt;  
      &amp;lt;userId&amp;gt;id&amp;lt;/userId&amp;gt;  
      &amp;lt;extNum&amp;gt;扩展号&amp;lt;/extNum&amp;gt;  
      &amp;lt;recvNum/&amp;gt; 
    &amp;lt;/pushSmsForm&amp;gt;  
    &amp;lt;pushSmsForm&amp;gt; 
      &amp;lt;eprId&amp;gt;0&amp;lt;/eprId&amp;gt;  
      &amp;lt;mobile&amp;gt;13560739261&amp;lt;/mobile&amp;gt;  
      &amp;lt;msgId&amp;gt;30217001&amp;lt;/msgId&amp;gt;  
      &amp;lt;content&amp;gt; &amp;lt;![CDATA[回复内容]]&amp;gt; &amp;lt;/content&amp;gt;  
      &amp;lt;userId&amp;gt;id&amp;lt;/userId&amp;gt;  
      &amp;lt;extNum&amp;gt;扩展号&amp;lt;/extNum&amp;gt;  
      &amp;lt;recvNum/&amp;gt; 
    &amp;lt;/pushSmsForm&amp;gt; 
  &amp;lt;/list&amp;gt; 
&amp;lt;/returnForm&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;思路&quot;&gt;思路&lt;/h3&gt;
&lt;p&gt;这个xml的基本知识我就不一一介绍了，简单说一下&lt;code&gt;&amp;lt;![CDATA[ ]]&amp;gt;&lt;/code&gt;标志，里面的内容是没有限制的(除了&amp;lt; 和 &amp;gt;)。继续讲思路，文档中只说了是post方法，所以我想到了三种可能：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;对方通过form表单提交了一个xml文件，我需要用文件流（filestream）读取文件，并进行转化为实体类&lt;/li&gt;
&lt;li&gt;对方通过post了一个字符串过来，我接收字符串并转化为实体类。&lt;/li&gt;
&lt;li&gt;对方直接在请求里添加了xml字符串（text/xml）&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;先构建两个xml反序列化的帮助类&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;        /// &amp;lt;summary&amp;gt;  
        /// 反序列化  
        /// &amp;lt;/summary&amp;gt;  
        /// &amp;lt;param name=&quot;type&quot;&amp;gt;类型&amp;lt;/param&amp;gt;  
        /// &amp;lt;param name=&quot;xml&quot;&amp;gt;XML字符串&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;  
        public static object Deserialize(Type type, string xml)
        {
            using (StringReader sr = new StringReader(xml))
            {
                XmlSerializer xmldes = new XmlSerializer(type);
                return xmldes.Deserialize(sr);
            }
        }

        /// &amp;lt;summary&amp;gt;  
        /// 反序列化  
        /// &amp;lt;/summary&amp;gt;  
        /// &amp;lt;param name=&quot;type&quot;&amp;gt;&amp;lt;/param&amp;gt;  
        /// &amp;lt;param name=&quot;xml&quot;&amp;gt;&amp;lt;/param&amp;gt;  
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;  

        public static object Deserialize(Type type, Stream stream)
        {
            XmlSerializer xmldes = new XmlSerializer(type);
            return xmldes.Deserialize(stream);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;利用visual studio自带的功能xml生成类（编辑--&amp;gt;选择性粘贴--&amp;gt;paste xml as classes）&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;    [System.SerializableAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute(&quot;code&quot;)]
    [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true)]
    public partial class returnFormPushSmsForm
    {
        private int eprIdField;
        private string mobileField;
        private string msgIdField;
        private string contentField;
        private string userIdField;
        private string extNumField;
        private string recvNumField;

        /// &amp;lt;remarks/&amp;gt;
        public int eprId
        {
            get
            {
                return this.eprIdField;
            }
            set
            {
                this.eprIdField = value;
            }
        }



        /// &amp;lt;remarks/&amp;gt;
        public string mobile
        {
            get
            {
                return this.mobileField;
            }
            set
            {
                this.mobileField = value;
            }
        }



        /// &amp;lt;remarks/&amp;gt;
        public string msgId
        {
            get
            {
                return this.msgIdField;
            }
            set
            {
                this.msgIdField = value;
            }
        }



        /// &amp;lt;remarks/&amp;gt;
        public string content
        {
            get
            {
                return this.contentField;
            }
            set
            {
                this.contentField = value;
            }
        }

        /// &amp;lt;remarks/&amp;gt;
        public string userId
        {
            get
            {
                return this.userIdField;
            }
            set
            {
                this.userIdField = value;
            }
        }

        /// &amp;lt;remarks/&amp;gt;
        public string extNum
        {
            get
            {
                return this.extNumField;
            }
            set
            {
                this.extNumField = value;
            }
        }

        /// &amp;lt;remarks/&amp;gt;
        public string recvNum
        {
            get
            {
                return this.recvNumField;
            }
            set
            {
                this.recvNumField = value;
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;生成类之后注意一下数据类型需要根据需求做一些修改&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;接下来就开始写第一个接口，最简单的直接接收字符串&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;        [HttpPost, Route(&quot;get/context&quot;)]
        public int getContext(context_ context)
        {
            bool result = false;
            //短信数据
            returnForm context_data = 
XmlSerializeUtil.Deserialize(typeof(returnForm), context.context) as returnForm;
            if (context_data != null &amp;amp;&amp;amp; context_data.count &amp;gt; 0)
            {
                result = UpdateDB(context_data);
            }
            return result ? 100 : 500;
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;code&gt;这里我定义了一个类context_，调用之前写的方法反序列化实体类，再写入数据库&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;第二个接口时接收请求中的xml（text/xml）&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;        [HttpPost, Route(&quot;get/context&quot;)]
        public int getContext(context_ context)
        {
            bool result = false;
            //短信数据
            returnForm context_data = XmlSerializeUtil.Deserialize(typeof(returnForm), 
HttpContext.Current.Request.InputStream) as returnForm;
            if (context_data != null &amp;amp;&amp;amp; context_data.count &amp;gt; 0)
            {
                result = UpdateDB(context_data);
            }
            return result ? 100 : 500;
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;这里读取了请求中的内容，HttpContext.Current.Request.InputStream&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;第三种是读取文件&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;        [HttpPost, Route(&quot;get/context&quot;)]
        public int getContext(context_ context)
        {
            bool result = false;
            HttpFileCollection files = HttpContext.Current.Request.Files;
            foreach (string key in files.AllKeys)
            {
                HttpPostedFile file1 = files[key];
                file1.InputStream.ToString();
                returnForm context_data = 
XmlSerializeUtil.Deserialize(typeof(returnForm), file1.InputStream) as returnForm;
                if (context_data != null &amp;amp;&amp;amp; context_data.count &amp;gt; 0)
                {
                    result = UpdateDB(context_data);
                }
            }
            return result ? 100 : 500;
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;遍历文件内容，获取数据&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 14 Feb 2019 07:32:00 +0000</pubDate>
<dc:creator>野菊花</dc:creator>
<og:description>webapi 接收 xml 的三种方法 前段时间接到一个任务写一个小接口，要接收java端返回过来的短信xml数据。 刚拿到项目，我的第一想法是对方会以什么形式发送xml格式的数据给我呢，设想三种情况</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Jackyye/p/10374507.html</dc:identifier>
</item>
<item>
<title>DotNetty 实现 Modbus TCP 系列 (四) Client &amp; Server - VictorBu</title>
<link>http://www.cnblogs.com/victorbu/p/10371056.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/victorbu/p/10371056.html</guid>
<description>&lt;p&gt;本文已收录至：&lt;a href=&quot;https://www.cnblogs.com/victorbu/p/10342552.html&quot;&gt;开源 DotNetty 实现的 Modbus TCP/IP 协议&lt;/a&gt;&lt;/p&gt;

&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class ModbusClient
{
    public string Ip { get; }
    public int Port { get; }
    public short UnitIdentifier { get; }
    public IChannel Channel { get; private set; }

    private MultithreadEventLoopGroup group;
    private ConnectionState connectionState;
    private ushort transactionIdentifier;
    private readonly string handlerName = &quot;response&quot;;

    public ModbusClient(short unitIdentifier, string ip, int port = 502)
    {
        Ip = ip;
        Port = port;
        UnitIdentifier = unitIdentifier;

        connectionState = ConnectionState.NotConnected;
    }

    public async Task Connect()
    {
        group = new MultithreadEventLoopGroup();

        try
        {
            var bootstrap = new Bootstrap();
            bootstrap
                .Group(group)
                .Channel&amp;lt;TcpSocketChannel&amp;gt;()
                .Option(ChannelOption.TcpNodelay, true)
                .Handler(new ActionChannelInitializer&amp;lt;ISocketChannel&amp;gt;(channel =&amp;gt;
                {
                    IChannelPipeline pipeline = channel.Pipeline;

                    pipeline.AddLast(&quot;encoder&quot;, new ModbusEncoder());
                    pipeline.AddLast(&quot;decoder&quot;, new ModbusDecoder(false));

                    pipeline.AddLast(handlerName, new ModbusResponseHandler());
                }));

            connectionState = ConnectionState.Pending;

            Channel = await bootstrap.ConnectAsync(new IPEndPoint(IPAddress.Parse(Ip), Port));

            connectionState = ConnectionState.Connected;
        }
        catch (Exception exception)
        {
            throw exception;
        }
    }

    public async Task Close()
    {
        if (ConnectionState.Connected == connectionState)
        {
            try
            {
                await Channel.CloseAsync();
            }
            finally
            {
                await group.ShutdownGracefullyAsync(TimeSpan.FromMilliseconds(100), TimeSpan.FromSeconds(1));

                connectionState = ConnectionState.NotConnected;
            }
        }
    }

    public ushort CallModbusFunction(ModbusFunction function)
    {
        if (ConnectionState.Connected != connectionState || Channel == null)
        {
            throw new Exception(&quot;Not connected!&quot;);
        }

        SetTransactionIdentifier();

        ModbusHeader header = new ModbusHeader(transactionIdentifier, UnitIdentifier);
        ModbusFrame frame = new ModbusFrame(header, function);
        Channel.WriteAndFlushAsync(frame);

        return transactionIdentifier;
    }

    public T CallModbusFunctionSync&amp;lt;T&amp;gt;(ModbusFunction function) where T : ModbusFunction
    {
        var transactionIdentifier = CallModbusFunction(function);

        var handler = (ModbusResponseHandler)Channel.Pipeline.Get(handlerName);
        if (handler == null)
        {
            throw new Exception(&quot;Not connected!&quot;);
        }

        return (T)handler.GetResponse(transactionIdentifier).Function;
    }

    private void SetTransactionIdentifier()
    {
        if (transactionIdentifier &amp;lt; ushort.MaxValue)
        {
            transactionIdentifier++;
        }
        else
        {
            transactionIdentifier = 1;
        }
    }

    public ushort ReadHoldingRegistersAsync(ushort startingAddress, ushort quantity)
    {
        var function = new ReadHoldingRegistersRequest(startingAddress, quantity);
        return CallModbusFunction(function);
    }

    public ReadHoldingRegistersResponse ReadHoldingRegisters(ushort startingAddress, ushort quantity)
    {
        var function = new ReadHoldingRegistersRequest(startingAddress, quantity);
        return CallModbusFunctionSync&amp;lt;ReadHoldingRegistersResponse&amp;gt;(function);
    }
}



public enum ConnectionState
{
    NotConnected = 0,
    Connected = 1,
    Pending = 2,
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(文中代码仅添加了 0x03 的方法)&lt;/p&gt;
&lt;p&gt;在 Client 中封装了 Modbus 请求方法，对同一个功能同时有同步方法(ReadHoldingRegistersAsync)和异步方法(ReadHoldingRegisters)。同步方法仅返回 TransactionIdentifier(传输标识)，异步方法返回响应结果。&lt;/p&gt;
&lt;p&gt;ModbusResponseHandler 修改为：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class ModbusResponseHandler : SimpleChannelInboundHandler&amp;lt;ModbusFrame&amp;gt;
{
    private readonly int timeoutMilliseconds = 2000;
    private Dictionary&amp;lt;ushort, ModbusFrame&amp;gt; responses = new Dictionary&amp;lt;ushort, ModbusFrame&amp;gt;();
    protected override void ChannelRead0(IChannelHandlerContext ctx, ModbusFrame msg)
    {
        responses.Add(msg.Header.TransactionIdentifier, msg);
    }

    public ModbusFrame GetResponse(ushort transactionIdentifier)
    {
        ModbusFrame frame = null;
        var timeoutDateTime = DateTime.Now.AddMilliseconds(timeoutMilliseconds);
        do
        {
            Thread.Sleep(1);
            if (responses.ContainsKey(transactionIdentifier))
            {
                frame = responses[transactionIdentifier];
                responses.Remove(transactionIdentifier);
            }
        }
        while (frame == null &amp;amp;&amp;amp; DateTime.Now &amp;lt; timeoutDateTime);

        if(frame == null)
        {
            throw new Exception(&quot;No Response&quot;);
        }
        else if(frame.Function is ExceptionFunction)
        {
            throw new Exception(frame.Function.ToString());
        }

        return frame;
    }

    public override void ExceptionCaught(IChannelHandlerContext context, Exception exception)
    {
        context.CloseAsync();
    }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class ModbusServer
{
    private ModbusResponseService responseService;
    private ServerState serverState;
    public int Port { get; }
    public IChannel Channel { get; private set; }
    private IEventLoopGroup bossGroup;
    private IEventLoopGroup workerGroup;
    public ModbusServer(ModbusResponseService responseService, int port = 502)
    {
        this.responseService = responseService;
        Port = port;
        serverState = ServerState.NotStarted;
    }

    public async Task Start()
    {
        bossGroup = new MultithreadEventLoopGroup(1);
        workerGroup = new MultithreadEventLoopGroup();

        try
        {
            var bootstrap = new ServerBootstrap();
            bootstrap.Group(bossGroup, workerGroup);

            bootstrap
                .Channel&amp;lt;TcpServerSocketChannel&amp;gt;()
                .Option(ChannelOption.SoBacklog, 100)
                .ChildHandler(new ActionChannelInitializer&amp;lt;IChannel&amp;gt;(channel =&amp;gt;
                {
                    IChannelPipeline pipeline = channel.Pipeline;
                    pipeline.AddLast(&quot;encoder&quot;, new ModbusEncoder());
                    pipeline.AddLast(&quot;decoder&quot;, new ModbusDecoder(true));

                    pipeline.AddLast(&quot;request&quot;, new ModbusRequestHandler(responseService));
                }));

            serverState = ServerState.Starting;

            Channel = await bootstrap.BindAsync(Port);

            serverState = ServerState.Started;
        }
        finally
        {
            
        }
    }

    public async Task Stop()
    {
        if (ServerState.Starting == serverState)
        {
            try
            {
                await Channel.CloseAsync();
            }
            finally
            {
                await Task.WhenAll(
                    bossGroup.ShutdownGracefullyAsync(TimeSpan.FromMilliseconds(100), TimeSpan.FromSeconds(1)),
                    workerGroup.ShutdownGracefullyAsync(TimeSpan.FromMilliseconds(100), TimeSpan.FromSeconds(1)));

                serverState = ServerState.NotStarted;
            }
        }
    }
}

public enum ServerState
{
    NotStarted = 0,
    Started = 1,
    Starting = 2,
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实例化 Server 时需要传入 ModbusResponseService 的实现，实现示例：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class ModbusResponse : ModbusResponseService
{
    public override ModbusFunction ReadHoldingRegisters(ReadHoldingRegistersRequest request)
    {
        var registers = ReadRegisters(request.Quantity);
        var response = new ReadHoldingRegistersResponse(registers);

        return response;
    }
    
    private ushort[] ReadRegisters(ushort quantity)
    {
        var registers = new ushort[quantity];

        Random ran = new Random();
        for (int i = 0; i &amp;lt; registers.Length; i++)
        {
            registers[i] = (ushort)ran.Next(ushort.MinValue, ushort.MaxValue);
        }

        return registers;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(文中代码仅添加了 0x03 的方法)&lt;/p&gt;
&lt;p&gt;开源地址：&lt;a href=&quot;https://github.com/VictorBu/modbus-tcp&quot;&gt;modbus-tcp&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 14 Feb 2019 06:53:00 +0000</pubDate>
<dc:creator>VictorBu</dc:creator>
<og:description>本文已收录至： '开源 DotNetty 实现的 Modbus TCP/IP 协议' Client (文中代码仅添加了 0x03 的方法) 在 Client 中封装了 Modbus 请求方法，对同一个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/victorbu/p/10371056.html</dc:identifier>
</item>
<item>
<title>剑指Spring源码（二） - CodeBear</title>
<link>http://www.cnblogs.com/CodeBear/p/10374261.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CodeBear/p/10374261.html</guid>
<description>&lt;p&gt;这是春节后的第一篇博客，我在构思这篇博客的时候，一度想放弃，想想要不要换个东西写，因为毕竟个人水平有限，Spring源码实在博大精深，不是我这个菜的抠脚的菜鸡可以驾驭的，怕误人子弟，还有就是源码分析类的博客实在是太难写了，和一般的博客真心不同，可能写了很多，自己都不知道自己在写些什么，但是还是要坚持，从接触博客的那一天开始，就非常佩服那些大神，乐于分享，无私奉献，我也从那些博客中学到了不少东西，慢慢的从一个嫩嫩的小菜鸡变成了秃头大菜鸡，其中最佩服的就是那些源码分析类的博客，虽然看不懂，但是从博客中，我分明读出了大神们对技术的热爱，对技术的坚持，对技术的执著。坚持！&lt;/p&gt;
&lt;p&gt;在上一篇Spring源码解析中，我们分析了&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    //根据参数类型可以知道，其实可以传入多个annotatedClasses，但是这种情况出现的比较少
    public AnnotationConfigApplicationContext(Class&amp;lt;?&amp;gt;... annotatedClasses) {
        //调用无参构造函数，会先调用父类GenericApplicationContext的构造函数
        //父类的构造函数里面就是初始化DefaultListableBeanFactory，并且赋值给beanFactory
        //本类的构造函数里面，初始化了一个读取器：AnnotatedBeanDefinitionReader read，一个扫描器ClassPathBeanDefinitionScanner scanner
        //scanner的用处不是很大，它仅仅是在我们外部手动调用 .scan 等方法才有用，常规方式是不会用到scanner对象的
        this();
        //把传入的类进行注册，这里有两个情况，
        //传入传统的配置类
        //传入bean（虽然一般没有人会这么做
        //看到后面会知道spring把传统的带上@Configuration的配置类称之为FULL配置类，不带@Configuration的称之为Lite配置类
        //但是我们这里先把带上@Configuration的配置类称之为传统配置类，不带的称之为普通bean
        register(annotatedClasses);
        //刷新
        refresh();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;中的前两行代码，回顾下，这两行代码，主要是把我们的配置类和内置的几个后置处理器放到了两个集合中：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;                //beanDefinitionMap是Map&amp;lt;String, BeanDefinition&amp;gt;，
                //这里就是把beanName作为key，beanDefinition作为value，推到map里面
                this.beanDefinitionMap.put(beanName, beanDefinition);

                //beanDefinitionNames就是一个List&amp;lt;String&amp;gt;,这里就是把beanName放到List中去
                this.beanDefinitionNames.add(beanName);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;今天，我们来分析下第三行代码，即：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        //刷新
        refresh();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个方法做了很多事情，让我们点开这个方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public void refresh() throws BeansException, IllegalStateException {
        synchronized (this.startupShutdownMonitor) {
            // Prepare this context for refreshing.
            //刷新预处理，和主流程关系不大，就是保存了容器的启动时间，启动标志等
            prepareRefresh();

            //DefaultListableBeanFactory
            // Tell the subclass to refresh the internal bean factory.
            //和主流程关系也不大，最终获得了DefaultListableBeanFactory，
            // DefaultListableBeanFactory实现了ConfigurableListableBeanFactory
            ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

            // Prepare the bean factory for use in this context.
            //还是一些准备工作，添加了两个后置处理器：ApplicationContextAwareProcessor，ApplicationListenerDetector
            //还设置了 忽略自动装配 和 允许自动装配 的接口,如果不存在某个bean的时候，spring就自动注册singleton bean
            //还设置了bean表达式解析器 等
            prepareBeanFactory(beanFactory);

            try {
                // Allows post-processing of the bean factory in context subclasses.
                //这是一个空方法
                postProcessBeanFactory(beanFactory);

                // Invoke factory processors registered as beans in the context.
                //执行自定义的BeanFactoryProcessor和内置的BeanFactoryProcessor
                invokeBeanFactoryPostProcessors(beanFactory);

                // Register bean processors that intercept bean creation.
                // 注册BeanPostProcessor
                registerBeanPostProcessors(beanFactory);

                // Initialize message source for this context.
                initMessageSource();

                // Initialize event multicaster for this context.
                initApplicationEventMulticaster();

                // Initialize other special beans in specific context subclasses.
                // 空方法
                onRefresh();

                // Check for listener beans and register them.
                registerListeners();

                // Instantiate all remaining (non-lazy-init) singletons.
                finishBeanFactoryInitialization(beanFactory);

                // Last step: publish corresponding event.
                finishRefresh();
            }

            catch (BeansException ex) {
                if (logger.isWarnEnabled()) {
                    logger.warn(&quot;Exception encountered during context initialization - &quot; +
                            &quot;cancelling refresh attempt: &quot; + ex);
                }

                // Destroy already created singletons to avoid dangling resources.
                destroyBeans();

                // Reset 'active' flag.
                cancelRefresh(ex);

                // Propagate exception to caller.
                throw ex;
            }

            finally {
                // Reset common introspection caches in Spring's core, since we
                // might not ever need metadata for singleton beans anymore...
                resetCommonCaches();
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;里面有很多小方法，我们今天的目标是分析前五个小方法：&lt;/p&gt;
&lt;h3 id=&quot;preparerefresh&quot;&gt;prepareRefresh&lt;/h3&gt;
&lt;p&gt;从命名来看，就知道这个方法主要做了一些刷新前的准备工作，和主流程关系不大，主要是保存了容器的启动时间，启动标志等。&lt;/p&gt;
&lt;h3 id=&quot;configurablelistablebeanfactory-beanfactory-obtainfreshbeanfactory&quot;&gt;ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory()&lt;/h3&gt;
&lt;p&gt;这个方法和主流程关系也不是很大，可以简单的认为，就是把beanFactory取出来而已。&lt;/p&gt;
&lt;h3 id=&quot;preparebeanfactory&quot;&gt;prepareBeanFactory&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;            //还是一些准备工作，添加了两个后置处理器：ApplicationContextAwareProcessor，ApplicationListenerDetector
            //还设置了 忽略自动装配 和 允许自动装配 的接口,如果不存在某个bean的时候，spring就自动注册singleton bean
            //还设置了bean表达式解析器 等
            prepareBeanFactory(beanFactory);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这代码相比前面两个就比较重要了，我们需要点进去好好看看，做了什么操作:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) {
        // Tell the internal bean factory to use the context's class loader etc.
        beanFactory.setBeanClassLoader(getClassLoader());//设置类加载器

        //设置bean表达式解析器
        beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));

        //属性编辑器支持
        beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));

        // Configure the bean factory with context callbacks.
        //添加一个后置处理器：ApplicationContextAwareProcessor，此后置处理处理器实现了BeanPostProcessor接口
        beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));

        //以下接口，忽略自动装配
        beanFactory.ignoreDependencyInterface(EnvironmentAware.class);
        beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);
        beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);
        beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);
        beanFactory.ignoreDependencyInterface(MessageSourceAware.class);
        beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);

        // BeanFactory interface not registered as resolvable type in a plain factory.
        // MessageSource registered (and found for autowiring) as a bean.
        //以下接口，允许自动装配,第一个参数是自动装配的类型，，第二个字段是自动装配的值
        beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);
        beanFactory.registerResolvableDependency(ResourceLoader.class, this);
        beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);
        beanFactory.registerResolvableDependency(ApplicationContext.class, this);

        // Register early post-processor for detecting inner beans as ApplicationListeners.
        //添加一个后置处理器：ApplicationListenerDetector，此后置处理器实现了BeanPostProcessor接口
        beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));

        // Detect a LoadTimeWeaver and prepare for weaving, if found.
        if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {
            beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));
            // Set a temporary ClassLoader for type matching.
            beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
        }

        //如果没有注册过bean名称为XXX，spring就自己创建一个名称为XXX的singleton bean
        //Register default environment beans.

        if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) {
            beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());
        }
        if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) {
            beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());
        }
        if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) {
            beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;主要做了如下的操作：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;设置了一个类加载器&lt;/li&gt;
&lt;li&gt;设置了bean表达式解析器&lt;/li&gt;
&lt;li&gt;添加了属性编辑器的支持&lt;/li&gt;
&lt;li&gt;添加了一个后置处理器：ApplicationContextAwareProcessor，此后置处理器实现了BeanPostProcessor接口&lt;/li&gt;
&lt;li&gt;设置了一些忽略自动装配的接口&lt;/li&gt;
&lt;li&gt;设置了一些允许自动装配的接口，并且进行了赋值操作&lt;/li&gt;
&lt;li&gt;在容器中还没有XX的bean的时候，帮我们注册beanName为XX的singleton bean&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;postprocessbeanfactorybeanfactory&quot;&gt;postProcessBeanFactory(beanFactory)&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;                //这是一个空方法
                postProcessBeanFactory(beanFactory);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是一个空方法，可能以后Spring会进行扩展把。&lt;/p&gt;
&lt;h3 id=&quot;invokebeanfactorypostprocessorsbeanfactory&quot;&gt;invokeBeanFactoryPostProcessors(beanFactory)&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;                //执行自定义的BeanFactoryProcessor和内置的BeanFactoryProcessor
                invokeBeanFactoryPostProcessors(beanFactory);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重点代码终于来了，可以说 这句代码是目前为止最重要，也是内容最多的代码了，我们有必要好好分析下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {

        //getBeanFactoryPostProcessors真是坑，第一次看到这里的时候，愣住了，总觉得获得的永远都是空的集合，掉入坑里，久久无法自拔
        //后来才知道spring允许我们手动添加BeanFactoryPostProcessor
        //即：annotationConfigApplicationContext.addBeanFactoryPostProcessor(XXX);
        PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());

        // Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime
        // (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)
        if (beanFactory.getTempClassLoader() == null &amp;amp;&amp;amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {
            beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));
            beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;让我们看看第一个小方法的第二个参数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public List&amp;lt;BeanFactoryPostProcessor&amp;gt; getBeanFactoryPostProcessors() {
        return this.beanFactoryPostProcessors;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里获得的是BeanFactoryPostProcessor，当我看到这里的时候，愣住了，通过IDEA的查找引用功能，我发现这个集合永远都是空的，根本没有代码为这个集合添加数据，很久都没有想通，后来才知道我们在外部可以手动添加一个后置处理器，而不是交给Spring去扫描，即：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        AnnotationConfigApplicationContext annotationConfigApplicationContext =
                new AnnotationConfigApplicationContext(AppConfig.class);
        annotationConfigApplicationContext.addBeanFactoryPostProcessor(XXX);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;只有这样，这个集合才不会为空，但是应该没有很少会有人这么做吧，当然也有可能是我孤陋寡闻。&lt;/p&gt;
&lt;p&gt;让我们点开invokeBeanFactoryPostProcessors方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public static void invokeBeanFactoryPostProcessors(
            ConfigurableListableBeanFactory beanFactory, List&amp;lt;BeanFactoryPostProcessor&amp;gt; beanFactoryPostProcessors) {

        // Invoke BeanDefinitionRegistryPostProcessors first, if any.
        Set&amp;lt;String&amp;gt; processedBeans = new HashSet&amp;lt;&amp;gt;();

        //beanFactory是DefaultListableBeanFactory，是BeanDefinitionRegistry的实现类，所以肯定满足if
        if (beanFactory instanceof BeanDefinitionRegistry) {
            BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;

            //regularPostProcessors 用来存放BeanFactoryPostProcessor，
            List&amp;lt;BeanFactoryPostProcessor&amp;gt; regularPostProcessors = new ArrayList&amp;lt;&amp;gt;();

            //registryProcessors 用来存放BeanDefinitionRegistryPostProcessor
            //BeanDefinitionRegistryPostProcessor扩展了BeanFactoryPostProcessor
            List&amp;lt;BeanDefinitionRegistryPostProcessor&amp;gt; registryProcessors = new ArrayList&amp;lt;&amp;gt;();

            // 循环传进来的beanFactoryPostProcessors，正常情况下，beanFactoryPostProcessors肯定没有数据
            // 因为beanFactoryPostProcessors是获得手动添加的，而不是spring扫描的
            // 只有手动调用annotationConfigApplicationContext.addBeanFactoryPostProcessor(XXX)才会有数据
            for (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) {
                // 判断postProcessor是不是BeanDefinitionRegistryPostProcessor，因为BeanDefinitionRegistryPostProcessor
                // 扩展了BeanFactoryPostProcessor，所以这里先要判断是不是BeanDefinitionRegistryPostProcessor
                // 是的话，直接执行postProcessBeanDefinitionRegistry方法，然后把对象装到registryProcessors里面去
                if (postProcessor instanceof BeanDefinitionRegistryPostProcessor) {
                    BeanDefinitionRegistryPostProcessor registryProcessor =
                            (BeanDefinitionRegistryPostProcessor) postProcessor;
                    registryProcessor.postProcessBeanDefinitionRegistry(registry);
                    registryProcessors.add(registryProcessor);
                }

                else {//不是的话，就装到regularPostProcessors
                    regularPostProcessors.add(postProcessor);
                }
            }

            // Do not initialize FactoryBeans here: We need to leave all regular beans
            // uninitialized to let the bean factory post-processors apply to them!
            // Separate between BeanDefinitionRegistryPostProcessors that implement
            // PriorityOrdered, Ordered, and the rest.
            //一个临时变量，用来装载BeanDefinitionRegistryPostProcessor
            //BeanDefinitionRegistry继承了PostProcessorBeanFactoryPostProcessor
            List&amp;lt;BeanDefinitionRegistryPostProcessor&amp;gt; currentRegistryProcessors = new ArrayList&amp;lt;&amp;gt;();

            // First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.
            // 获得实现BeanDefinitionRegistryPostProcessor接口的类的BeanName:org.springframework.context.annotation.internalConfigurationAnnotationProcessor
            // 并且装入数组postProcessorNames，我理解一般情况下，只会找到一个
            // 这里又有一个坑，为什么我自己创建了一个实现BeanDefinitionRegistryPostProcessor接口的类，也打上了@Component注解
            // 配置类也加上了@Component注解，但是这里却没有拿到
            // 因为直到这一步，Spring还没有去扫描，扫描是在ConfigurationClassPostProcessor类中完成的，也就是下面的第一个
            // invokeBeanDefinitionRegistryPostProcessors方法
            String[] postProcessorNames =
                    beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);

            for (String ppName : postProcessorNames) {
                if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
                    //获得ConfigurationClassPostProcessor类，并且放到currentRegistryProcessors
                    //ConfigurationClassPostProcessor是很重要的一个类，它实现了BeanDefinitionRegistryPostProcessor接口
                    //BeanDefinitionRegistryPostProcessor接口又实现了BeanFactoryPostProcessor接口
                    //ConfigurationClassPostProcessor是极其重要的类
                    //里面执行了扫描Bean，Import，ImportResouce等各种操作
                    //用来处理配置类（有两种情况 一种是传统意义上的配置类，一种是普通的bean）的各种逻辑
                    currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
                    //把name放到processedBeans，后续会根据这个集合来判断处理器是否已经被执行过了
                    processedBeans.add(ppName);
                }
            }

            //处理排序
            sortPostProcessors(currentRegistryProcessors, beanFactory);

            //合并Processors，为什么要合并，因为registryProcessors是装载BeanDefinitionRegistryPostProcessor的
            //一开始的时候，spring只会执行BeanDefinitionRegistryPostProcessor独有的方法
            //而不会执行BeanDefinitionRegistryPostProcessor父类的方法，即BeanFactoryProcessor的方法
            //所以这里需要把处理器放入一个集合中，后续统一执行父类的方法
            registryProcessors.addAll(currentRegistryProcessors);

            //可以理解为执行ConfigurationClassPostProcessor的postProcessBeanDefinitionRegistry方法
            //Spring热插播的体现，像ConfigurationClassPostProcessor就相当于一个组件，Spring很多事情就是交给组件去管理
            //如果不想用这个组件，直接把注册组件的那一步去掉就可以
            invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);

            //因为currentRegistryProcessors是一个临时变量，所以需要清除
            currentRegistryProcessors.clear();

            // Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.
            // 再次根据BeanDefinitionRegistryPostProcessor获得BeanName，看这个BeanName是否已经被执行过了，有没有实现Ordered接口
            // 如果没有被执行过，也实现了Ordered接口的话，把对象推送到currentRegistryProcessors，名称推送到processedBeans
            // 如果没有实现Ordered接口的话，这里不把数据加到currentRegistryProcessors，processedBeans中，后续再做处理
            // 这里才可以获得我们定义的实现了BeanDefinitionRegistryPostProcessor的Bean
            postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
            for (String ppName : postProcessorNames) {
                if (!processedBeans.contains(ppName) &amp;amp;&amp;amp; beanFactory.isTypeMatch(ppName, Ordered.class)) {
                    currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
                    processedBeans.add(ppName);
                }
            }

            //处理排序
            sortPostProcessors(currentRegistryProcessors, beanFactory);

            //合并Processors
            registryProcessors.addAll(currentRegistryProcessors);

            //执行我们自定义的BeanDefinitionRegistryPostProcessor
            invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);

            //清空临时变量
            currentRegistryProcessors.clear();

            // Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.
            // 上面的代码是执行了实现了Ordered接口的BeanDefinitionRegistryPostProcessor，
            // 下面的代码就是执行没有实现Ordered接口的BeanDefinitionRegistryPostProcessor
            boolean reiterate = true;
            while (reiterate) {
                reiterate = false;
                postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
                for (String ppName : postProcessorNames) {
                    if (!processedBeans.contains(ppName)) {
                        currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
                        processedBeans.add(ppName);
                        reiterate = true;
                    }
                }
                sortPostProcessors(currentRegistryProcessors, beanFactory);
                registryProcessors.addAll(currentRegistryProcessors);
                invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
                currentRegistryProcessors.clear();
            }

            // Now, invoke the postProcessBeanFactory callback of all processors handled so far.
            //registryProcessors集合装载BeanDefinitionRegistryPostProcessor
            //上面的代码是执行子类独有的方法，这里需要再把父类的方法也执行一次
            invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);

            //regularPostProcessors装载BeanFactoryPostProcessor，执行BeanFactoryPostProcessor的方法
            //但是regularPostProcessors一般情况下，是不会有数据的，只有在外面手动添加BeanFactoryPostProcessor，才会有数据
            invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);
        }

        else {
            // Invoke factory processors registered with the context instance.
            invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);
        }

        // Do not initialize FactoryBeans here: We need to leave all regular beans
        // uninitialized to let the bean factory post-processors apply to them!
        //找到BeanFactoryPostProcessor实现类的BeanName数组
        String[] postProcessorNames =
                beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false);

        // Separate between BeanFactoryPostProcessors that implement PriorityOrdered,
        // Ordered, and the rest.
        List&amp;lt;BeanFactoryPostProcessor&amp;gt; priorityOrderedPostProcessors = new ArrayList&amp;lt;&amp;gt;();
        List&amp;lt;String&amp;gt; orderedPostProcessorNames = new ArrayList&amp;lt;&amp;gt;();
        List&amp;lt;String&amp;gt; nonOrderedPostProcessorNames = new ArrayList&amp;lt;&amp;gt;();
        //循环BeanName数组
        for (String ppName : postProcessorNames) {
            //如果这个Bean被执行过了，跳过
            if (processedBeans.contains(ppName)) {
                // skip - already processed in first phase above
            }
            //如果实现了PriorityOrdered接口，加入到priorityOrderedPostProcessors
            else if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
                priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));
            }
            //如果实现了Ordered接口，加入到orderedPostProcessorNames
            else if (beanFactory.isTypeMatch(ppName, Ordered.class)) {
                orderedPostProcessorNames.add(ppName);
            }
            //如果既没有实现PriorityOrdered，也没有实现Ordered。加入到nonOrderedPostProcessorNames
            else {
                nonOrderedPostProcessorNames.add(ppName);
            }
        }

        //排序处理priorityOrderedPostProcessors，即实现了PriorityOrdered接口的BeanFactoryPostProcessor
        // First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.
        sortPostProcessors(priorityOrderedPostProcessors, beanFactory);
        //执行priorityOrderedPostProcessors
        invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);

        //执行实现了Ordered接口的BeanFactoryPostProcessor
        // Next, invoke the BeanFactoryPostProcessors that implement Ordered.
        List&amp;lt;BeanFactoryPostProcessor&amp;gt; orderedPostProcessors = new ArrayList&amp;lt;&amp;gt;();
        for (String postProcessorName : orderedPostProcessorNames) {
            orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));
        }
        sortPostProcessors(orderedPostProcessors, beanFactory);
        invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);

        // 执行既没有实现PriorityOrdered接口，也没有实现Ordered接口的BeanFactoryPostProcessor
        // Finally, invoke all other BeanFactoryPostProcessors.
        List&amp;lt;BeanFactoryPostProcessor&amp;gt; nonOrderedPostProcessors = new ArrayList&amp;lt;&amp;gt;();
        for (String postProcessorName : nonOrderedPostProcessorNames) {
            nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));
        }
        invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);

        // Clear cached merged bean definitions since the post-processors might have
        // modified the original metadata, e.g. replacing placeholders in values...
        beanFactory.clearMetadataCache();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先判断beanFactory是不是BeanDefinitionRegistry的实例，当然肯定是的，然后执行如下操作：&lt;/p&gt;
&lt;ol readability=&quot;29&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;定义了一个Set，装载BeanName，后面会根据这个Set，来判断后置处理器是否被执行过了。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;定义了两个List，一个是regularPostProcessors，用来装载BeanFactoryPostProcessor，一个是registryProcessors用来装载BeanDefinitionRegistryPostProcessor，其中BeanDefinitionRegistryPostProcessor扩展了BeanFactoryPostProcessor。BeanDefinitionRegistryPostProcessor有两个方法，一个是独有的postProcessBeanDefinitionRegistry方法，一个是父类的postProcessBeanFactory方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;循环传进来的beanFactoryPostProcessors，上面已经解释过了，一般情况下，这里永远都是空的，只有手动add beanFactoryPostProcessor，这里才会有数据。我们假设beanFactoryPostProcessors有数据，进入循环，判断postProcessor是不是BeanDefinitionRegistryPostProcessor，因为BeanDefinitionRegistryPostProcessor扩展了BeanFactoryPostProcessor，所以这里先要判断是不是BeanDefinitionRegistryPostProcessor，是的话，执行postProcessBeanDefinitionRegistry方法，然后把对象装到registryProcessors里面去，不是的话，就装到regularPostProcessors。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;定义了一个临时变量：currentRegistryProcessors，用来装载BeanDefinitionRegistryPostProcessor。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;getBeanNamesForType，顾名思义，是根据类型查到BeanNames，这里有一点需要注意，就是去哪里找，点开这个方法的话，就知道是循环beanDefinitionNames去找，这个方法以后也会经常看到。这里传了BeanDefinitionRegistryPostProcessor.class，就是找到类型为BeanDefinitionRegistryPostProcessor的后置处理器，并且赋值给postProcessorNames。一般情况下，只会找到一个，就是org.springframework.context.annotation.internalConfigurationAnnotationProcessor，也就是ConfigurationAnnotationProcessor。这个后置处理器在上一节中已经说明过了，十分重要。这里有一个问题，为什么我自己写了个类，实现了BeanDefinitionRegistryPostProcessor接口，也打上了@Component注解，但是这里没有获得，因为直到这一步，Spring还没有完成扫描，扫描是在ConfigurationClassPostProcessor类中完成的，也就是下面第一个invokeBeanDefinitionRegistryPostProcessors方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;循环postProcessorNames，其实也就是org.springframework.context.annotation.internalConfigurationAnnotationProcessor，判断此后置处理器是否实现了PriorityOrdered接口（ConfigurationAnnotationProcessor也实现了PriorityOrdered接口），&lt;br/&gt;如果实现了，把它添加到currentRegistryProcessors这个临时变量中，再放入processedBeans，代表这个后置处理已经被处理过了。当然现在还没有处理，但是马上就要处理了。。。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;进行排序，PriorityOrdered是一个排序接口，如果实现了它，就说明此后置处理器是有顺序的，所以需要排序。当然目前这里只有一个后置处理器，就是ConfigurationClassPostProcessor。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;把currentRegistryProcessors合并到registryProcessors，为什么需要合并？因为一开始spring只会执行BeanDefinitionRegistryPostProcessor独有的方法，而不会执行BeanDefinitionRegistryPostProcessor父类的方法，即BeanFactoryProcessor接口中的方法，所以需要把这些后置处理器放入一个集合中，后续统一执行BeanFactoryProcessor接口中的方法。当然目前这里只有一个后置处理器，就是ConfigurationClassPostProcessor。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;可以理解为执行currentRegistryProcessors中的ConfigurationClassPostProcessor中的postProcessBeanDefinitionRegistry方法，这就是Spring设计思想的体现了，在这里体现的就是其中的热插拔，插件化开发的思想。Spring中很多东西都是交给插件去处理的，这个后置处理器就相当于一个插件，如果不想用了，直接不添加就是了。这个方法特别重要，我们后面会详细说来。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;清空currentRegistryProcessors，因为currentRegistryProcessors是一个临时变量，已经完成了目前的使命，所以需要清空，当然后面还会用到。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;再次根据BeanDefinitionRegistryPostProcessor获得BeanName，然后进行循环，看这个后置处理器是否被执行过了，如果没有被执行过，也实现了Ordered接口的话，把此后置处理器推送到currentRegistryProcessors和processedBeans中。&lt;br/&gt;这里就可以获得我们定义的，并且打上@Component注解的后置处理器了，因为Spring已经完成了扫描，但是这里需要注意的是，由于ConfigurationClassPostProcessor在上面已经被执行过了，所以虽然可以通过getBeanNamesForType获得，但是并不会加入到currentRegistryProcessors和processedBeans。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;处理排序。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;合并Processors，合并的理由和上面是一样的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;执行我们自定义的BeanDefinitionRegistryPostProcessor。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;清空临时变量。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;在上面的方法中，仅仅是执行了实现了Ordered接口的BeanDefinitionRegistryPostProcessor，这里是执行没有实现Ordered接口的BeanDefinitionRegistryPostProcessor。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;上面的代码是执行子类独有的方法，这里需要再把父类的方法也执行一次。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;执行regularPostProcessors中的后置处理器的方法，需要注意的是，在一般情况下，regularPostProcessors是不会有数据的，只有在外面手动添加BeanFactoryPostProcessor，才会有数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;查找实现了BeanFactoryPostProcessor的后置处理器，并且执行后置处理器中的方法。和上面的逻辑差不多，不再详细说明。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这就是这个方法中做的主要的事情了，可以说是比较复杂的。但是逻辑还是比较清晰的，在第9步的时候，我说有一个方法会详细说来，现在就让我们好好看看这个方法究竟做了什么吧。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {
        List&amp;lt;BeanDefinitionHolder&amp;gt; configCandidates = new ArrayList&amp;lt;&amp;gt;();
        String[] candidateNames = registry.getBeanDefinitionNames();//获得所有的BeanDefinition的Name，放入candidateNames数组

        //循环candidateNames数组
        for (String beanName : candidateNames) {
            BeanDefinition beanDef = registry.getBeanDefinition(beanName);//根据beanName获得BeanDefinition

            // 内部有两个标记位来标记是否已经处理过了
            // 这里会引发一连串知识盲点
            // 当我们注册配置类的时候，可以不加Configuration注解，直接使用Component ComponentScan Import ImportResource注解，称之为Lite配置类
            // 如果加了Configuration注解，就称之为Full配置类
            // 如果我们注册了Lite配置类，我们getBean这个配置类，会发现它就是原本的那个配置类
            // 如果我们注册了Full配置类，我们getBean这个配置类，会发现它已经不是原本那个配置类了，而是已经被cgilb代理的类了
            // 写一个A类，其中有一个构造方法，打印出“你好”
            // 再写一个配置类，里面有两个bean注解的方法
            // 其中一个方法new了A 类，并且返回A的对象，把此方法称之为getA
            // 第二个方法又调用了getA方法
            // 如果配置类是Lite配置类，会发现打印了两次“你好”，也就是说A类被new了两次
            // 如果配置类是Full配置类，会发现只打印了一次“你好”，也就是说A类只被new了一次，因为这个类被cgilb代理了，方法已经被改写
            if (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||
                    ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {
                if (logger.isDebugEnabled()) {
                    logger.debug(&quot;Bean definition has already been processed as a configuration class: &quot; + beanDef);
                }
            }

            //判断是否为配置类（有两种情况 一种是传统意义上的配置类，一种是普通的bean），
            //在这个方法内部，会做判断，这个配置类是Full配置类，还是Lite配置类，并且做上标记
            //满足条件，加入到configCandidates
            else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {
                configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));
            }
        }

        // 如果没有配置类，直接返回
        // Return immediately if no @Configuration classes were found
        if (configCandidates.isEmpty()) {
            return;
        }

        // Sort by previously determined @Order value, if applicable
        //处理排序
        configCandidates.sort((bd1, bd2) -&amp;gt; {
            int i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());
            int i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());
            return Integer.compare(i1, i2);
        });

        // Detect any custom bean name generation strategy supplied through the enclosing application context
        SingletonBeanRegistry sbr = null;
        // DefaultListableBeanFactory最终会实现SingletonBeanRegistry接口，所以可以进入到这个if
        if (registry instanceof SingletonBeanRegistry) {
            sbr = (SingletonBeanRegistry) registry;
            if (!this.localBeanNameGeneratorSet) {
                //spring中可以修改默认的bean命名方式，这里就是看用户有没有自定义bean命名方式，虽然一般没有人会这么做
                BeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);
                if (generator != null) {
                    this.componentScanBeanNameGenerator = generator;
                    this.importBeanNameGenerator = generator;
                }
            }
        }

        if (this.environment == null) {
            this.environment = new StandardEnvironment();
        }

        // Parse each @Configuration class
        ConfigurationClassParser parser = new ConfigurationClassParser(
                this.metadataReaderFactory, this.problemReporter, this.environment,
                this.resourceLoader, this.componentScanBeanNameGenerator, registry);

        Set&amp;lt;BeanDefinitionHolder&amp;gt; candidates = new LinkedHashSet&amp;lt;&amp;gt;(configCandidates);
        Set&amp;lt;ConfigurationClass&amp;gt; alreadyParsed = new HashSet&amp;lt;&amp;gt;(configCandidates.size());
        do {
            //解析配置类（传统意义上的配置类或者是普通bean，核心来了）
            parser.parse(candidates);
            parser.validate();

            Set&amp;lt;ConfigurationClass&amp;gt; configClasses = new LinkedHashSet&amp;lt;&amp;gt;(parser.getConfigurationClasses());
            configClasses.removeAll(alreadyParsed);

            // Read the model and create bean definitions based on its content
            if (this.reader == null) {
                this.reader = new ConfigurationClassBeanDefinitionReader(
                        registry, this.sourceExtractor, this.resourceLoader, this.environment,
                        this.importBeanNameGenerator, parser.getImportRegistry());
            }
            this.reader.loadBeanDefinitions(configClasses);//直到这一步才把Import的类，@Bean @ImportRosource 转换成BeanDefinition
            alreadyParsed.addAll(configClasses);//把configClasses加入到alreadyParsed，代表

            candidates.clear();
            //获得注册器里面BeanDefinition的数量 和 candidateNames进行比较
            //如果大于的话，说明有新的BeanDefinition注册进来了
            if (registry.getBeanDefinitionCount() &amp;gt; candidateNames.length) {
                String[] newCandidateNames = registry.getBeanDefinitionNames();//从注册器里面获得BeanDefinitionNames
                Set&amp;lt;String&amp;gt; oldCandidateNames = new HashSet&amp;lt;&amp;gt;(Arrays.asList(candidateNames));//candidateNames转换set
                Set&amp;lt;String&amp;gt; alreadyParsedClasses = new HashSet&amp;lt;&amp;gt;();
                //循环alreadyParsed。把类名加入到alreadyParsedClasses
                for (ConfigurationClass configurationClass : alreadyParsed) {
                    alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());
                }
                for (String candidateName : newCandidateNames) {
                    if (!oldCandidateNames.contains(candidateName)) {
                        BeanDefinition bd = registry.getBeanDefinition(candidateName);
                        if (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) &amp;amp;&amp;amp;
                                !alreadyParsedClasses.contains(bd.getBeanClassName())) {
                            candidates.add(new BeanDefinitionHolder(bd, candidateName));
                        }
                    }
                }
                candidateNames = newCandidateNames;
            }
        }
        while (!candidates.isEmpty());

        // Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes
        if (sbr != null &amp;amp;&amp;amp; !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {
            sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());
        }

        if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {
            // Clear cache in externally provided MetadataReaderFactory; this is a no-op
            // for a shared cache since it'll be cleared by the ApplicationContext.
            ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;获得所有的BeanName，放入candidateNames数组。&lt;/li&gt;
&lt;li&gt;循环candidateNames数组，根据beanName获得BeanDefinition，判断此BeanDefinition是否已经被处理过了。&lt;/li&gt;
&lt;li&gt;判断是否是配置类，如果是的话。加入到configCandidates数组，在判断的时候，还会标记配置类属于Full配置类，还是Lite配置类，这里会引发一连串的知识盲点：&lt;br/&gt;3.1 当我们注册配置类的时候，可以不加@Configuration注解，直接使用@Component @ComponentScan @Import @ImportResource等注解，Spring把这种配置类称之为Lite配置类， 如果加了@Configuration注解，就称之为Full配置类。&lt;br/&gt;3.2 如果我们注册了Lite配置类，我们getBean这个配置类，会发现它就是原本的那个配置类，如果我们注册了Full配置类，我们getBean这个配置类，会发现它已经不是原本那个配置类了，而是已经被cgilb代理的类了。&lt;br/&gt;3.3 写一个A类，其中有一个构造方法，打印出“你好”，再写一个配置类，里面有两个被@bean注解的方法，其中一个方法new了A类，并且返回A的对象，把此方法称之为getA，第二个方法又调用了getA方法，如果配置类是Lite配置类，会发现打印了两次“你好”，也就是说A类被new了两次，如果配置类是Full配置类，会发现只打印了一次“你好”，也就是说A类只被new了一次，因为这个类被cgilb代理了，方法已经被改写。&lt;br/&gt;3.4 具体的可以看我的这篇博客：https://www.cnblogs.com/CodeBear/p/10304605.html，里面有详细的说明。&lt;/li&gt;
&lt;li&gt;如果没有配置类直接返回。&lt;/li&gt;
&lt;li&gt;处理排序。&lt;/li&gt;
&lt;li&gt;解析配置类，可能是Full配置类，也有可能是Lite配置类，这个小方法是此方法的核心，稍后具体说明。&lt;/li&gt;
&lt;li&gt;在第6步的时候，只是注册了部分Bean，像 @Import @Bean等，是没有被注册的，这里统一对这些进行注册。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;下面是解析配置类的过程：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public void parse(Set&amp;lt;BeanDefinitionHolder&amp;gt; configCandidates) {
        this.deferredImportSelectors = new LinkedList&amp;lt;&amp;gt;();
        //循环传进来的配置类
        for (BeanDefinitionHolder holder : configCandidates) {
            BeanDefinition bd = holder.getBeanDefinition();//获得BeanDefinition
            try {
                //如果获得BeanDefinition是AnnotatedBeanDefinition的实例
                if (bd instanceof AnnotatedBeanDefinition) {
                    parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());
                } else if (bd instanceof AbstractBeanDefinition &amp;amp;&amp;amp; ((AbstractBeanDefinition) bd).hasBeanClass()) {
                    parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());
                } else {
                    parse(bd.getBeanClassName(), holder.getBeanName());
                }
            } catch (BeanDefinitionStoreException ex) {
                throw ex;
            } catch (Throwable ex) {
                throw new BeanDefinitionStoreException(
                        &quot;Failed to parse configuration class [&quot; + bd.getBeanClassName() + &quot;]&quot;, ex);
            }
        }

        //执行DeferredImportSelector
        processDeferredImportSelectors();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为可以有多个配置类，所以需要循环处理。我们的配置类的BeanDefinition是AnnotatedBeanDefinition的实例，所以会进入第一个if：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;protected final void parse(AnnotationMetadata metadata, String beanName) throws IOException {
        processConfigurationClass(new ConfigurationClass(metadata, beanName));
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;    protected void processConfigurationClass(ConfigurationClass configClass) throws IOException {

        //判断是否需要跳过
        if (this.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) {
            return;
        }

        ConfigurationClass existingClass = this.configurationClasses.get(configClass);
        if (existingClass != null) {
            if (configClass.isImported()) {
                if (existingClass.isImported()) {
                    existingClass.mergeImportedBy(configClass);
                }
                // Otherwise ignore new imported config class; existing non-imported class overrides it.
                return;
            } else {
                // Explicit bean definition found, probably replacing an import.
                // Let's remove the old one and go with the new one.
                this.configurationClasses.remove(configClass);
                this.knownSuperclasses.values().removeIf(configClass::equals);
            }
        }

        // Recursively process the configuration class and its superclass hierarchy.
        SourceClass sourceClass = asSourceClass(configClass);
        do {
            sourceClass = doProcessConfigurationClass(configClass, sourceClass);
        }
        while (sourceClass != null);

        this.configurationClasses.put(configClass, configClass);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重点在于doProcessConfigurationClass方法，需要特别注意，最后一行代码，会把configClass放入一个Map，会在上面第7步中用到。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass)
            throws IOException {

        //递归处理内部类，一般不会写内部类
        // Recursively process any member (nested) classes first
        processMemberClasses(configClass, sourceClass);

        // Process any @PropertySource annotations
        //处理@PropertySource注解，@PropertySource注解用来加载properties文件
        for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(
                sourceClass.getMetadata(), PropertySources.class,
                org.springframework.context.annotation.PropertySource.class)) {
            if (this.environment instanceof ConfigurableEnvironment) {
                processPropertySource(propertySource);
            } else {
                logger.warn(&quot;Ignoring @PropertySource annotation on [&quot; + sourceClass.getMetadata().getClassName() +
                        &quot;]. Reason: Environment must implement ConfigurableEnvironment&quot;);
            }
        }

        // Process any @ComponentScan annotations
        //获得ComponentScan注解具体的内容，ComponentScan注解除了最常用的basePackage之外，还有includeFilters，excludeFilters等
        Set&amp;lt;AnnotationAttributes&amp;gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(
                sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);

        //如果没有打上ComponentScan，或者被@Condition条件跳过，就不再进入这个if
        if (!componentScans.isEmpty() &amp;amp;&amp;amp;
                !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {
            //循环处理componentScans
            for (AnnotationAttributes componentScan : componentScans) {
                // The config class is annotated with @ComponentScan -&amp;gt; perform the scan immediately
                //componentScan就是@ComponentScan上的具体内容，sourceClass.getMetadata().getClassName()就是配置类的名称
                Set&amp;lt;BeanDefinitionHolder&amp;gt; scannedBeanDefinitions =
                        this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());
                // Check the set of scanned definitions for any further config classes and parse recursively if needed
                for (BeanDefinitionHolder holder : scannedBeanDefinitions) {
                    BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();
                    if (bdCand == null) {
                        bdCand = holder.getBeanDefinition();
                    }
                    if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) {
                        //递归调用，因为可能组件类有被@Bean标记的方法，或者组件类本身也有ComponentScan等注解
                        parse(bdCand.getBeanClassName(), holder.getBeanName());
                    }
                }
            }
        }

        // Process any @Import annotations
        //处理@Import注解
        //@Import注解是spring中很重要的一个注解，Springboot大量应用这个注解
        //@Import三种类，一种是Import普通类，一种是Import ImportSelector，还有一种是Import ImportBeanDefinitionRegistrar
        //getImports(sourceClass)是获得import的内容，返回的是一个set
        processImports(configClass, sourceClass, getImports(sourceClass), true);

        // Process any @ImportResource annotations
        //处理@ImportResource注解
        AnnotationAttributes importResource =
                AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);
        if (importResource != null) {
            String[] resources = importResource.getStringArray(&quot;locations&quot;);
            Class&amp;lt;? extends BeanDefinitionReader&amp;gt; readerClass = importResource.getClass(&quot;reader&quot;);
            for (String resource : resources) {
                String resolvedResource = this.environment.resolveRequiredPlaceholders(resource);
                configClass.addImportedResource(resolvedResource, readerClass);
            }
        }

        //处理@Bean的方法，可以看到获得了带有@Bean的方法后，不是马上转换成BeanDefinition，而是先用一个set接收
        // Process individual @Bean methods
        Set&amp;lt;MethodMetadata&amp;gt; beanMethods = retrieveBeanMethodMetadata(sourceClass);
        for (MethodMetadata methodMetadata : beanMethods) {
            configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));
        }

        // Process default methods on interfaces
        processInterfaces(configClass, sourceClass);

        // Process superclass, if any
        if (sourceClass.getMetadata().hasSuperClass()) {
            String superclass = sourceClass.getMetadata().getSuperClassName();
            if (superclass != null &amp;amp;&amp;amp; !superclass.startsWith(&quot;java&quot;) &amp;amp;&amp;amp;
                    !this.knownSuperclasses.containsKey(superclass)) {
                this.knownSuperclasses.put(superclass, configClass);
                // Superclass found, return its annotation metadata and recurse
                return sourceClass.getSuperClass();
            }
        }

        // No superclass -&amp;gt; processing is complete
        return null;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;递归处理内部类，一般不会使用内部类。&lt;/li&gt;
&lt;li&gt;处理@PropertySource注解，@PropertySource注解用来加载properties文件。&lt;/li&gt;
&lt;li&gt;获得ComponentScan注解具体的内容，ComponentScan注解除了最常用的basePackage之外，还有includeFilters，excludeFilters等。&lt;/li&gt;
&lt;li&gt;判断有没有被@ComponentScans标记，或者被@Condition条件带过，如果满足条件的话，进入if，进行如下操作：&lt;br/&gt;4.1 执行扫描操作，把扫描出来的放入set，这个方法稍后再详细说明。&lt;br/&gt;4.2 循环set，判断是否是配置类，是的话，递归调用parse方法，因为被扫描出来的类，还是一个配置类，有@ComponentScans注解，或者其中有被@Bean标记的方法 等等，所以需要再次被解析。&lt;/li&gt;
&lt;li&gt;处理@Import注解，@Import是Spring中很重要的一个注解，正是由于它的存在，让Spring非常灵活，不管是Spring内部，还是与Spring整合的第三方技术，都大量的运用了@Import注解，@Import有三种情况，一种是Import普通类，一种是Import ImportSelector，还有一种是Import ImportBeanDefinitionRegistrar，getImports(sourceClass)是获得import的内容，返回的是一个set，这个方法稍后再详细说明。&lt;/li&gt;
&lt;li&gt;处理@ImportResource注解。&lt;/li&gt;
&lt;li&gt;处理@Bean的方法，可以看到获得了带有@Bean的方法后，不是马上转换成BeanDefinition，而是先用一个set接收。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我们先来看4.1中的那个方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public Set&amp;lt;BeanDefinitionHolder&amp;gt; parse(AnnotationAttributes componentScan, final String declaringClass) {
        //扫描器，还记不记在new AnnotationConfigApplicationContext的时候
        //会调用AnnotationConfigApplicationContext的构造方法
        //构造方法里面有一句 this.scanner = new ClassPathBeanDefinitionScanner(this);
        //当时说这个对象不重要，这里就是证明了。常规用法中，实际上执行扫描的只会是这里的scanner对象
        ClassPathBeanDefinitionScanner scanner = new ClassPathBeanDefinitionScanner(this.registry,
                componentScan.getBoolean(&quot;useDefaultFilters&quot;), this.environment, this.resourceLoader);

        //判断是否重写了默认的命名规则
        Class&amp;lt;? extends BeanNameGenerator&amp;gt; generatorClass = componentScan.getClass(&quot;nameGenerator&quot;);
        boolean useInheritedGenerator = (BeanNameGenerator.class == generatorClass);
        scanner.setBeanNameGenerator(useInheritedGenerator ? this.beanNameGenerator :
                BeanUtils.instantiateClass(generatorClass));

        ScopedProxyMode scopedProxyMode = componentScan.getEnum(&quot;scopedProxy&quot;);
        if (scopedProxyMode != ScopedProxyMode.DEFAULT) {
            scanner.setScopedProxyMode(scopedProxyMode);
        }
        else {
            Class&amp;lt;? extends ScopeMetadataResolver&amp;gt; resolverClass = componentScan.getClass(&quot;scopeResolver&quot;);
            scanner.setScopeMetadataResolver(BeanUtils.instantiateClass(resolverClass));
        }

        scanner.setResourcePattern(componentScan.getString(&quot;resourcePattern&quot;));

        //addIncludeFilter addExcludeFilter,最终是往List&amp;lt;TypeFilter&amp;gt;里面填充数据
        //TypeFilter是一个函数式接口，函数式接口在java8的时候大放异彩，只定义了一个虚方法的接口被称为函数式接口
        //当调用scanner.addIncludeFilter  scanner.addExcludeFilter 仅仅把 定义的规则塞进去，并么有真正去执行匹配过程

        //处理includeFilters
        for (AnnotationAttributes filter : componentScan.getAnnotationArray(&quot;includeFilters&quot;)) {
            for (TypeFilter typeFilter : typeFiltersFor(filter)) {
                scanner.addIncludeFilter(typeFilter);
            }
        }

        //处理excludeFilters
        for (AnnotationAttributes filter : componentScan.getAnnotationArray(&quot;excludeFilters&quot;)) {
            for (TypeFilter typeFilter : typeFiltersFor(filter)) {
                scanner.addExcludeFilter(typeFilter);
            }
        }

        boolean lazyInit = componentScan.getBoolean(&quot;lazyInit&quot;);
        if (lazyInit) {
            scanner.getBeanDefinitionDefaults().setLazyInit(true);
        }

        Set&amp;lt;String&amp;gt; basePackages = new LinkedHashSet&amp;lt;&amp;gt;();
        String[] basePackagesArray = componentScan.getStringArray(&quot;basePackages&quot;);
        for (String pkg : basePackagesArray) {
            String[] tokenized = StringUtils.tokenizeToStringArray(this.environment.resolvePlaceholders(pkg),
                    ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);
            Collections.addAll(basePackages, tokenized);
        }
        // 从下面的代码可以看出ComponentScans指定扫描目标，除了最常用的basePackages，还有两种方式
        // 1.指定basePackageClasses，就是指定多个类，只要是与这几个类同级的，或者在这几个类下级的都可以被扫描到，这种方式其实是spring比较推荐的
        // 因为指定basePackages没有IDE的检查，容易出错，但是指定一个类，就有IDE的检查了，不容易出错，经常会用一个空的类来作为basePackageClasses
        // 2.直接不指定，默认会把与配置类同级，或者在配置类下级的作为扫描目标
        for (Class&amp;lt;?&amp;gt; clazz : componentScan.getClassArray(&quot;basePackageClasses&quot;)) {
            basePackages.add(ClassUtils.getPackageName(clazz));
        }
        if (basePackages.isEmpty()) {
            basePackages.add(ClassUtils.getPackageName(declaringClass));
        }

        //把规则填充到排除规则：List&amp;lt;TypeFilter&amp;gt;，这里就把 注册类自身当作排除规则，真正执行匹配的时候，会把自身给排除
        scanner.addExcludeFilter(new AbstractTypeHierarchyTraversingFilter(false, false) {
            @Override
            protected boolean matchClassName(String className) {
                return declaringClass.equals(className);
            }
        });
        //basePackages是一个LinkedHashSet&amp;lt;String&amp;gt;，这里就是把basePackages转为字符串数组的形式
        return scanner.doScan(StringUtils.toStringArray(basePackages));
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;定义了一个扫描器scanner，还记不记在new AnnotationConfigApplicationContext的时候，会调用AnnotationConfigApplicationContext的构造方法，构造方法里面有一句 this.scanner = new ClassPathBeanDefinitionScanner(this);当时说这个对象不重要，这里就是证明了。常规用法中，实际上执行扫描的只会是这里的scanner对象。&lt;/li&gt;
&lt;li&gt;处理includeFilters，就是把规则添加到scanner。&lt;/li&gt;
&lt;li&gt;处理excludeFilters，就是把规则添加到scanner。&lt;/li&gt;
&lt;li&gt;解析basePackages，获得需要扫描哪些包。&lt;/li&gt;
&lt;li&gt;添加一个默认的排除规则：排除自身。&lt;/li&gt;
&lt;li&gt;执行扫描，稍后详细说明。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这里需要做一个补充说明，添加规则的时候，只是把具体的规则放入规则类的集合中去，规则类是一个函数式接口，只定义了一个虚方法的接口被称为函数式接口，函数式接口在java8的时候大放异彩，这里只是把规则方塞进去，并没有真正执行匹配规则。&lt;/p&gt;
&lt;p&gt;我们来看看到底是怎么执行扫描的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    protected Set&amp;lt;BeanDefinitionHolder&amp;gt; doScan(String... basePackages) {
        Assert.notEmpty(basePackages, &quot;At least one base package must be specified&quot;);
        Set&amp;lt;BeanDefinitionHolder&amp;gt; beanDefinitions = new LinkedHashSet&amp;lt;&amp;gt;();
        //循环处理basePackages
        for (String basePackage : basePackages) {
            //根据包名找到符合条件的BeanDefinition集合
            Set&amp;lt;BeanDefinition&amp;gt; candidates = findCandidateComponents(basePackage);
            for (BeanDefinition candidate : candidates) {
                ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate);
                candidate.setScope(scopeMetadata.getScopeName());
                String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry);
                //由findCandidateComponents内部可知，这里的candidate是ScannedGenericBeanDefinition
                //而ScannedGenericBeanDefinition是AbstractBeanDefinition和AnnotatedBeanDefinition的之类
                //所以下面的两个if都会进入
                if (candidate instanceof AbstractBeanDefinition) {
                    //内部会设置默认值
                    postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);
                }
                if (candidate instanceof AnnotatedBeanDefinition) {
                    //如果是AnnotatedBeanDefinition，还会再设置一次值
                    AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);
                }
                if (checkCandidate(beanName, candidate)) {
                    BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName);
                    definitionHolder =
                            AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);
                    beanDefinitions.add(definitionHolder);
                    registerBeanDefinition(definitionHolder, this.registry);
                }
            }
        }
        return beanDefinitions;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为basePackages可能有多个，所以需要循环处理，最终会进行Bean的注册。下面再来看看findCandidateComponents方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public Set&amp;lt;BeanDefinition&amp;gt; findCandidateComponents(String basePackage) {
        //spring支持component索引技术，需要引入一个组件，因为大部分情况不会引入这个组件
        //所以不会进入到这个if
        if (this.componentsIndex != null &amp;amp;&amp;amp; indexSupportsIncludeFilters()) {
            return addCandidateComponentsFromIndex(this.componentsIndex, basePackage);
        }
        else {
            return scanCandidateComponents(basePackage);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Spring支持component索引技术，需要引入一个组件，大部分项目没有引入这个组件，所以会进入scanCandidateComponents方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private Set&amp;lt;BeanDefinition&amp;gt; scanCandidateComponents(String basePackage) {
        Set&amp;lt;BeanDefinition&amp;gt; candidates = new LinkedHashSet&amp;lt;&amp;gt;();
        try {
            //把 传进来的类似 命名空间形式的字符串转换成类似类文件地址的形式，然后在前面加上classpath*:
            //即：com.xx=&amp;gt;classpath*:com/xx/**/*.class
            String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX +
                    resolveBasePackage(basePackage) + '/' + this.resourcePattern;
            //根据packageSearchPath，获得符合要求的文件
            Resource[] resources = getResourcePatternResolver().getResources(packageSearchPath);
            boolean traceEnabled = logger.isTraceEnabled();
            boolean debugEnabled = logger.isDebugEnabled();
            //循环资源
            for (Resource resource : resources) {
                if (traceEnabled) {
                    logger.trace(&quot;Scanning &quot; + resource);
                }

                if (resource.isReadable()) {//判断资源是否可读，并且不是一个目录
                    try {
                        //metadataReader 元数据读取器，解析resource，也可以理解为描述资源的数据结构
                        MetadataReader metadataReader = getMetadataReaderFactory().getMetadataReader(resource);
                        //在isCandidateComponent方法内部会真正执行匹配规则
                        //注册配置类自身会被排除，不会进入到这个if
                        if (isCandidateComponent(metadataReader)) {
                            ScannedGenericBeanDefinition sbd = new ScannedGenericBeanDefinition(metadataReader);
                            sbd.setResource(resource);
                            sbd.setSource(resource);
                            if (isCandidateComponent(sbd)) {
                                if (debugEnabled) {
                                    logger.debug(&quot;Identified candidate component class: &quot; + resource);
                                }
                                candidates.add(sbd);
                            }
                            else {
                                if (debugEnabled) {
                                    logger.debug(&quot;Ignored because not a concrete top-level class: &quot; + resource);
                                }
                            }
                        }
                        else {
                            if (traceEnabled) {
                                logger.trace(&quot;Ignored because not matching any filter: &quot; + resource);
                            }
                        }
                    }
                    catch (Throwable ex) {
                        throw new BeanDefinitionStoreException(
                                &quot;Failed to read candidate component class: &quot; + resource, ex);
                    }
                }
                else {
                    if (traceEnabled) {
                        logger.trace(&quot;Ignored because not readable: &quot; + resource);
                    }
                }
            }
        }
        catch (IOException ex) {
            throw new BeanDefinitionStoreException(&quot;I/O failure during classpath scanning&quot;, ex);
        }
        return candidates;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;把传进来的类似命名空间形式的字符串转换成类似类文件地址的形式，然后在前面加上classpath&lt;em&gt;，即：com.xx=&amp;gt;classpath&lt;/em&gt;:com/xx/**/*.class。&lt;/li&gt;
&lt;li&gt;根据packageSearchPath，获得符合要求的文件。&lt;/li&gt;
&lt;li&gt;循环符合要求的文件，进一步进行判断。&lt;br/&gt;最终会把符合要求的文件，转换为BeanDefinition，并且返回。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;直到这里，上面说的4.1中提到的方法终于分析完毕了，让我们再看看上面提到的第5步中的处理@Import注解方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    //这个方法内部相当相当复杂，importCandidates是Import的内容，调用这个方法的时候，已经说过可能有三种情况
    //这里再说下，1.Import普通类，2.Import ImportSelector，3.Import ImportBeanDefinitionRegistrar
    //循环importCandidates，判断属于哪种情况
    //如果是普通类，会进到else，调用processConfigurationClass方法
    //这个方法是不是很熟悉，没错，processImports这个方法就是在processConfigurationClass方法中被调用的
    //processImports又主动调用processConfigurationClass方法，是一个递归调用，因为Import的普通类，也有可能被加了Import注解，@ComponentScan注解 或者其他注解，所以普通类需要再次被解析
    //如果Import ImportSelector就跑到了第一个if中去，首先执行Aware接口方法，所以我们在实现ImportSelector的同时，还可以实现Aware接口
    //然后判断是不是DeferredImportSelector，DeferredImportSelector扩展了ImportSelector
    //如果不是的话，调用selectImports方法，获得全限定类名数组，在转换成类的数组，然后再调用processImports，又特么的是一个递归调用...
    //可能又有三种情况，一种情况是selectImports的类是一个普通类，第二种情况是selectImports的类是一个ImportBeanDefinitionRegistrar类，第三种情况是还是一个ImportSelector类...
    //所以又需要递归调用
    //如果Import ImportBeanDefinitionRegistrar就跑到了第二个if，还是会执行Aware接口方法，这里终于没有递归了，会把数据放到ConfigurationClass中的Map&amp;lt;ImportBeanDefinitionRegistrar, AnnotationMetadata&amp;gt; importBeanDefinitionRegistrars中去
    private void processImports(ConfigurationClass configClass, SourceClass currentSourceClass,
                                Collection&amp;lt;SourceClass&amp;gt; importCandidates, boolean checkForCircularImports) {

        if (importCandidates.isEmpty()) {
            return;
        }

        if (checkForCircularImports &amp;amp;&amp;amp; isChainedImportOnStack(configClass)) {
            this.problemReporter.error(new CircularImportProblem(configClass, this.importStack));
        } else {
            this.importStack.push(configClass);
            try {
                for (SourceClass candidate : importCandidates) {
                    if (candidate.isAssignable(ImportSelector.class)) {
                        // Candidate class is an ImportSelector -&amp;gt; delegate to it to determine imports
                        Class&amp;lt;?&amp;gt; candidateClass = candidate.loadClass();
                        ImportSelector selector = BeanUtils.instantiateClass(candidateClass, ImportSelector.class);
                        ParserStrategyUtils.invokeAwareMethods(
                                selector, this.environment, this.resourceLoader, this.registry);
                        if (this.deferredImportSelectors != null &amp;amp;&amp;amp; selector instanceof DeferredImportSelector) {
                            this.deferredImportSelectors.add(
                                    new DeferredImportSelectorHolder(configClass, (DeferredImportSelector) selector));
                        } else {
                            String[] importClassNames = selector.selectImports(currentSourceClass.getMetadata());
                            Collection&amp;lt;SourceClass&amp;gt; importSourceClasses = asSourceClasses(importClassNames);
                            processImports(configClass, currentSourceClass, importSourceClasses, false);
                        }
                    } else if (candidate.isAssignable(ImportBeanDefinitionRegistrar.class)) {
                        // Candidate class is an ImportBeanDefinitionRegistrar -&amp;gt;
                        // delegate to it to register additional bean definitions
                        Class&amp;lt;?&amp;gt; candidateClass = candidate.loadClass();
                        ImportBeanDefinitionRegistrar registrar =
                                BeanUtils.instantiateClass(candidateClass, ImportBeanDefinitionRegistrar.class);
                        ParserStrategyUtils.invokeAwareMethods(
                                registrar, this.environment, this.resourceLoader, this.registry);
                        configClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata());
                    } else {
                        // Candidate class not an ImportSelector or ImportBeanDefinitionRegistrar -&amp;gt;
                        // process it as an @Configuration class
                        this.importStack.registerImport(
                                currentSourceClass.getMetadata(), candidate.getMetadata().getClassName());
                        processConfigurationClass(candidate.asConfigClass(configClass));
                    }
                }
            } catch (BeanDefinitionStoreException ex) {
                throw ex;
            } catch (Throwable ex) {
                throw new BeanDefinitionStoreException(
                        &quot;Failed to process import candidates for configuration class [&quot; +
                                configClass.getMetadata().getClassName() + &quot;]&quot;, ex);
            } finally {
                this.importStack.pop();
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个方法大概的作用已经在注释中已经写明了，就不再重复了。&lt;/p&gt;
&lt;p&gt;直到这里，才把ConfigurationClassPostProcessor中的processConfigBeanDefinitions方法简单的过了一下。&lt;/p&gt;
&lt;p&gt;但是这还没有结束，processConfigBeanDefinitions是BeanDefinitionRegistryPostProcessor接口中的方法，BeanDefinitionRegistryPostProcessor扩展了BeanFactoryPostProcessor，还有postProcessBeanFactory方法没有分析，这个方法是干嘛的，简单的来说，就是判断配置类是Lite配置类，还是Full配置类，如果是配置类，就会被Cglib代理，目的就是保证Bean的作用域。关于这个方法实在是比较复杂，限于篇幅原因，这里就不再继续了，有兴趣的朋友可以到我的GitHub看下，里面有简单的分析（当然其实还有很多东西无法在博客中体现，如果都贴出来的话，实在是太长了，但是在GitHub上面都有注释）。&lt;/p&gt;
&lt;p&gt;我们来做一个总结，ConfigurationClassPostProcessor中的processConfigBeanDefinitions方法十分重要，主要是完成扫描，最终注册我们定义的Bean。&lt;/p&gt;
</description>
<pubDate>Thu, 14 Feb 2019 06:05:00 +0000</pubDate>
<dc:creator>CodeBear</dc:creator>
<og:description>这是春节后的第一篇博客，我在构思这篇博客的时候，一度想放弃，想想要不要换个东西写，因为毕竟个人水平有限，Spring源码实在博大精深，不是我这个菜的抠脚的菜鸡可以驾驭的，怕误人子弟，还有就是源码分析类</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CodeBear/p/10374261.html</dc:identifier>
</item>
<item>
<title>#21   Python异常 - MinuteSheep</title>
<link>http://www.cnblogs.com/minutesheep/p/10369568.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/minutesheep/p/10369568.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;运行程序时经常遇到各种错误，例如：ImportError（导入模块错误）、IndexError（索引错误）、NameError（变量错误）、SyntaxError（语法错误）、IndentationError（缩进错误）等，你或许有许多疑问，为什么程序出现这个错误就会打印出相应的错误信息，自己是否可以编写一个错误呢？这些错误在Python中其实是异常，正确的处理异常会让程序跑起来得心应手，那么怎么来处理异常呢？Here we go！&lt;/p&gt;
&lt;h3&gt;Python异常&lt;/h3&gt;
&lt;h4&gt;1.1 异常的名词解释&lt;/h4&gt;
&lt;p&gt;异常其实是一个Python对象，当Python无法正常处理程序时，就会实例化这个对象，从而抛出异常（表示一个错误）&lt;/p&gt;
&lt;h4&gt;1.2 异常捕捉&lt;/h4&gt;
&lt;p&gt;当程序出现异常时，如果不处理则会终止程序的运行，如果不想在发生异常时终止程序，则需要使用try来捕捉它，先来看最简单的使用方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; name = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;MinuteSheep&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 初始化变量name&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(name)   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将变量name打印出来&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(age)    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将变量age打印出来，并没有初始化age，会抛出变量错误异常&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 运行结果：&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; MinuteSheep   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 正确打印出name变量&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; Traceback (most recent call last):       &lt;span&gt;#&lt;/span&gt;&lt;span&gt; age变量抛出变量错误异常&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;   File &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1.py&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, line 4, &lt;span&gt;in&lt;/span&gt; &amp;lt;module&amp;gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(age)   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将变量age打印出来，并没有初始化age，会抛出变量错误异常&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; NameError: name &lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; defined
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; name = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;MinuteSheep&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(name)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;try&lt;/span&gt;:    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 使用try捕捉异常&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(age)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;except&lt;/span&gt; NameError:   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 当NameError出现时，执行下列代码块&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;变量错误异常被捕捉&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)   
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(NameError)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 运行结果：&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;MinuteSheep
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;变量错误异常被捕捉
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &amp;lt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;NameError&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;
&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 可以看到当出现NameError时，并没有终止程序，而是执行出现异常时的代码块&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从上面的代码可以看到，当开始执行一个try语句时，Python将会在当前程序的上下文做标记，当异常出现时，返回这里，执行异常时的代码块，当然也可以捕捉多个异常：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;Traceback (most recent call last):
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; name = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;MinuteSheep&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(name)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(age)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;except&lt;/span&gt;&lt;span&gt; NameError:
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;我是NameError&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;except&lt;/span&gt;&lt;span&gt; KeyError:
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;我是KeyError&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 运行结果：&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;MinuteSheep
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 我是NameError
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;长上面代码可以看出，当有多个except语句时，会从第一个except语句开始匹配，如果匹配到则执行对于的代码块，剩下的except语句则不运行。多个异常的捕捉这样写会使代码变得冗长，为了简化代码也可以这样写：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(age)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;except&lt;/span&gt; (NameError, KeyError):   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将所有异常放在一行一起处理&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;异常被正确捕捉&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 运行结果：&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;异常被正确捕捉
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这样写可以使代码轻量化，但是缺点就是不能单独的处理每一个异常，只能一起处理&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;有时候需要将异常打印出来，但是异常通常是一个很长的单词，可以使用as给异常起别名：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(age)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;except&lt;/span&gt; NameError as e:   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 给异常起一个别名&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;我是NameError&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(e)   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将这个异常打印出来&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 运行结果：&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;我是NameError
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; name &lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; defined
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;1.3 异常的其他语法&lt;/h4&gt;
&lt;p&gt;其他语法一：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    try代码
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;except&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;    except代码
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     else代码
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;解释：先执行try代码，当try代码出现异常时，执行except代码；当try代码没有异常时，执行else代码，看例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(age)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;except&lt;/span&gt;&lt;span&gt; NameError as e:
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(e)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;没有出现异常哦&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 运行结果：&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; name &lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; defined
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 出现异常，执行except代码块，不执行else代码块&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; age = 100
&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(age)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;except&lt;/span&gt;&lt;span&gt; NameError as e:
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(e)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;没有出现异常哦&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 运行结果：&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; 100
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;没有出现异常哦
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 没有出现异常，则执行else代码块&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其他语法二：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    try代码
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;except&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;    except代码
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;    else代码
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;finally&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;     finally代码
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;解释：不管是否有异常，最后都执行finally代码，看例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(age)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;except&lt;/span&gt;&lt;span&gt; NameError as e:
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(e)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;没有出现异常&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;finally&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;最后都得执行我&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 运行结果：&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; name &lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; defined
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 最后都得执行我
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Python异常中，最常使用的就是try......except......，else和finally语句并不常见&lt;/p&gt;
&lt;h4&gt;1.4 异常种类&lt;/h4&gt;
&lt;p&gt;常见的异常种类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SystemExit                   解释器请求退出
KeyboardInterrupt            用户中断执行(通常是输入&lt;/span&gt;^&lt;span&gt;C)
StopIteration                迭代器没有更多的值
GeneratorExit                生成器(generator)发生异常来通知退出
StandardError                所有的内建标准异常的基类
ArithmeticError              所有数值计算错误的基类
FloatingPointError           浮点计算错误
OverflowError                数值运算超出最大限制
ZeroDivisionError            除(或取模)零 (所有数据类型)
AssertionError               断言语句失败
AttributeError               对象没有这个属性
EOFError                     没有内建输入,到达EOF 标记
EnvironmentError             操作系统错误的基类
IOError                      输入&lt;/span&gt;/&lt;span&gt;输出操作失败
OSError                      操作系统错误
WindowsError                 系统调用失败
ImportError                  导入模块&lt;/span&gt;/&lt;span&gt;对象失败
LookupError                  无效数据查询的基类
IndexError                   序列中没有此索引(index)
KeyError                     映射中没有这个键
MemoryError                  内存溢出错误(对于Python 解释器不是致命的)
NameError                    未声明&lt;/span&gt;/&lt;span&gt;初始化对象 (没有属性)
UnboundLocalError            访问未初始化的本地变量
ReferenceError               弱引用(Weak reference)试图访问已经垃圾回收了的对象
RuntimeError                 一般的运行时错误
NotImplementedError          尚未实现的方法
SyntaxError                  Python 语法错误
IndentationError             缩进错误
TabError                     Tab 和空格混用
SystemError                  一般的解释器系统错误
TypeError                    对类型无效的操作
ValueError                   传入无效的参数
UnicodeError                 Unicode 相关的错误
UnicodeDecodeError           Unicode 解码时的错误
UnicodeEncodeError           Unicode 编码时错误
UnicodeTranslateError        Unicode 转换时错误
DeprecationWarning           关于被弃用的特征的警告
FutureWarning                关于构造将来语义会有改变的警告
OverflowWarning              旧的关于自动提升为长整型(long)的警告
PendingDeprecationWarning    关于特性将会被废弃的警告
RuntimeWarning               可疑的运行时行为(runtime behavior)的警告
SyntaxWarning                可疑的语法的警告
UserWarning                  用户代码生成的警告&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到上面这么多异常，怎么可以记得住啊！！！其实，Python中，所有异常都有一个共同的基类BaseException，它包含所有的异常，常规异常的基类是Exception&lt;/p&gt;
&lt;p&gt;当不清楚会出现什么异常的时候，直接捕捉Exception基本上都是可以捕捉到的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(age)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;except&lt;/span&gt; Exception as e:   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 使用常规异常的基类&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(e)
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; 
&lt;span&gt;6&lt;/span&gt; 
&lt;span&gt;7&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 运行结果：&lt;/span&gt;
&lt;span&gt;8&lt;/span&gt; name &lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; defined
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;1.5 主动出发异常&lt;/h4&gt;
&lt;p&gt;异常可以使用raise主动触发，看例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;raise&lt;/span&gt; Exception(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;主动抛出异常&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 使用raise主动触发异常&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception as e:
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(e)
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; 
&lt;span&gt;6&lt;/span&gt; 
&lt;span&gt;7&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 运行结果：&lt;/span&gt;
&lt;span&gt;8&lt;/span&gt; 主动抛出异常
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;1.6 自定义异常&lt;/h4&gt;
&lt;p&gt;Python中所有的异常的基类都是BaseException，常见的异常的基类是Exception，那么自己如果想要自定义异常的话，也要以BaseException或者Exception为基类（关于类的讲解以后会介绍到，这里先看一看）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MSException(Exception):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, content):
    ¦   self.content &lt;/span&gt;=&lt;span&gt; content

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__str__&lt;/span&gt;&lt;span&gt;(self):
    ¦   &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; self.content


&lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;raise&lt;/span&gt; MSException(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;这是MinuteSheep自定义的异常&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 抛出自定义异常&lt;/span&gt;
&lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception as e:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(e)


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 运行结果：&lt;/span&gt;
这是MinuteSheep自定义的异常
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;1.7 断言&lt;/h4&gt;
&lt;p&gt;这是一个新名词，断言是个什么鬼呢？断言是用来检测条件是否正确的。有这么一句话：与其让程序在运行时出错，不如让其出现错误条件时出错。断言语句的关键字为：assert&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基本用法：assert 条件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当条件正确时，什么也不返回；当条件错误时，抛出AssertionError&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
In [5]: &lt;span&gt;assert&lt;/span&gt; 9&amp;gt;5    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 条件正确时，什么也不返回&lt;/span&gt;
&lt;span&gt;
In [&lt;/span&gt;6]: &lt;span&gt;assert&lt;/span&gt; 9&amp;lt;5   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 条件错误时，抛出AssertionError&lt;/span&gt;
---------------------------------------------------------------------------&lt;span&gt;
AssertionError                            Traceback (most recent call last)
&lt;/span&gt;&amp;lt;ipython-input-6-739be7e04005&amp;gt; &lt;span&gt;in&lt;/span&gt; &amp;lt;module&amp;gt;
----&amp;gt; 1 &lt;span&gt;assert&lt;/span&gt; 9&amp;lt;5&lt;span&gt;

AssertionError:&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;断言的错误可以自己填写，&lt;strong&gt;用法：assert 条件，'错误信息'&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
In [7]: &lt;span&gt;assert&lt;/span&gt; 9&amp;lt;5, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Error!!!!!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 自己填写错误信息&lt;/span&gt;
---------------------------------------------------------------------------&lt;span&gt;
AssertionError                            Traceback (most recent call last)
&lt;/span&gt;&amp;lt;ipython-input-7-ea55b9c82b31&amp;gt; &lt;span&gt;in&lt;/span&gt; &amp;lt;module&amp;gt;
----&amp;gt; 1 &lt;span&gt;assert&lt;/span&gt; 9&amp;lt;5, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Error!!!!!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

AssertionError: Error!!!!!&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Python异常到此结束&lt;/p&gt;

</description>
<pubDate>Thu, 14 Feb 2019 05:26:00 +0000</pubDate>
<dc:creator>MinuteSheep</dc:creator>
<og:description>本篇博文主要记录Python异常的各种知识</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/minutesheep/p/10369568.html</dc:identifier>
</item>
<item>
<title>企业级自动化运维工具---puppet详解 - alonghub</title>
<link>http://www.cnblogs.com/along21/p/10369858.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/along21/p/10369858.html</guid>
<description>&lt;h2&gt;1、认识puppet&lt;/h2&gt;
&lt;h4&gt;&lt;strong&gt;1.1 &lt;span&gt;引入&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;　　puppet&lt;span&gt;是什么，咱们先不用专业的名词解释它，咱们先描述一些工作场景，看明白这些工作场景，自然会知道&lt;/span&gt;&lt;span&gt;puppet&lt;/span&gt;&lt;span&gt;是什么。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;（&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;）场景一：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　管理员想要在&lt;/span&gt;100&lt;span&gt;台服务器上同时创建一个名叫&lt;/span&gt;&lt;span&gt;&quot;along&quot;&lt;/span&gt;&lt;span&gt;的用户，怎么办，当然，我们可以&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;手动解决&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;，登录每一台服务器，然后一台一台的创建用户，如果你真的这样干，那么我只能说，算你狠！！！但是，既然我们这篇文章是介绍&lt;/span&gt;&lt;span&gt;puppet&lt;/span&gt;&lt;span&gt;的，我们肯定会推荐你使用&lt;/span&gt;&lt;span&gt;puppet&lt;/span&gt;&lt;span&gt;解决这个问题。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;（&lt;/span&gt;2&lt;span&gt;）场景二：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　公司新买了一堆云服务器，这些服务器最终可能要提供相同的服务，现在需要管理员在这一堆服务器上安装一些相同的应用，而且安装完成后，还需要这些服务器上的应用自动启动，怎么办，当然，手动解决算你狠，兄弟我服了，你说你写脚本解决，嗯，这是个办法，在我没有认识&lt;/span&gt;puppet&lt;span&gt;之前我可能也会写个脚本，但是我们是介绍&lt;/span&gt;&lt;span&gt;puppet&lt;/span&gt;&lt;span&gt;的，我们会推荐你使用&lt;/span&gt;&lt;span&gt;puppet&lt;/span&gt;&lt;span&gt;解决这个问题。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;（&lt;/span&gt;3&lt;span&gt;）场景三：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在一些服务器中，执行大批量的重复操作，我们可以使用&lt;/span&gt;puppet&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　看完上述三个场景，你应该已经大概猜出&lt;/span&gt;puppet&lt;span&gt;是干吗的了，没错，说的糙一点，你可以把它理解成批量处理工具，但是你又不能完全把它理解成批量处理工具，因为除了批量处理，他还有一些别的功能和特性，我们暂且先这么认为，以便我们入门。&lt;/span&gt;&lt;/p&gt;

&lt;h4&gt;&lt;strong&gt;1.2 &lt;span&gt;介绍&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）我自己对&lt;/span&gt;&lt;span&gt;puppet&lt;/span&gt;&lt;span&gt;的了解&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　像&lt;/span&gt;puppet&lt;span&gt;这种工具有几个专业的名词可以用来称呼它们：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;配置管理&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;工具&lt;/span&gt;&lt;/strong&gt;&quot;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;自动化运维&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;管理工具&lt;/span&gt;&lt;/strong&gt;&quot;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　Linux&lt;span&gt;中，常见的配置管理工具有&lt;/span&gt;&lt;span&gt;puppet&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;saltstack&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;a href=&quot;http://www.cnblogs.com/along21/p/8241542.html&quot;&gt;&lt;span&gt;ansible&lt;/span&gt;&lt;/a&gt;&lt;span&gt;（博主之前讲解过）&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;chef&lt;span&gt;等，它们的功能类似，&lt;/span&gt;&lt;span&gt;puppet&lt;/span&gt;&lt;span&gt;算是这个领域里面的老大哥，时间久（我说的是创始时间久，不要想歪了&lt;/span&gt;&lt;span&gt;····&lt;/span&gt;&lt;span&gt;），成熟，被广泛的应用，&lt;/span&gt;&lt;span&gt;google&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;twitter&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;redhat&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;cisco&lt;/span&gt;&lt;span&gt;等大公司都用到了它，功能强大，&lt;/span&gt;&lt;strong&gt;puppet&lt;span&gt;是使用&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;ruby&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;研发的&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，&lt;/span&gt;&lt;strong&gt;saltstack&lt;span&gt;和&lt;/span&gt;&lt;span&gt;ansible&lt;/span&gt;&lt;span&gt;都属于&lt;/span&gt;&lt;span&gt;python&lt;/span&gt;&lt;span&gt;系的&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，&lt;/span&gt; ansible&lt;span&gt;和&lt;/span&gt;&lt;span&gt;saltstack&lt;/span&gt;&lt;span&gt;与&lt;/span&gt;&lt;span&gt;puppet&lt;/span&gt;&lt;span&gt;相比，属于后起之秀，我们以后也可能会对它们进行总结，但是现在，我们只聊&lt;/span&gt;&lt;span&gt;puppet&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;（&lt;/span&gt;2&lt;span&gt;）专业术语介绍&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt; ① puppet&lt;span&gt;是一种&lt;/span&gt;&lt;span&gt;Linux/Unix&lt;/span&gt;&lt;span&gt;平台下的&lt;/span&gt;&lt;strong&gt;&lt;span&gt;集中配置管理系统&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，使用自有的&lt;/span&gt;puppet&lt;span&gt;描述语言，可管理&lt;/span&gt;&lt;strong&gt;&lt;span&gt;配置文件、用户、&lt;/span&gt;cron&lt;span&gt;任务、软件包、系统服务&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;等。&lt;/span&gt;puppet&lt;span&gt;把这些系统实体称之为&lt;/span&gt;&lt;strong&gt;&lt;span&gt;资源&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，&lt;/span&gt;puppet&lt;span&gt;的设计目标是简化对这些资源的管理以及妥善处理资源间的依赖关系。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; ② Puppet&lt;span&gt;是开源的基于&lt;/span&gt;&lt;strong&gt;Ruby&lt;/strong&gt;&lt;span&gt;的系统配置管理工具，&lt;/span&gt;puppet&lt;span&gt;是一个&lt;/span&gt;&lt;strong&gt;C/S&lt;span&gt;结构&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。所有的&lt;/span&gt;puppet&lt;span&gt;客户端同一个服务器端的&lt;/span&gt;&lt;span&gt;puppet&lt;/span&gt;&lt;span&gt;通讯，每个&lt;/span&gt;&lt;span&gt;puppet&lt;/span&gt;&lt;span&gt;客户端每半小时&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;可以设置&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;连接一次服务器端，下载最新的配置文件，并且严格按照配置文件来配置服务器。 配置完成以后&lt;/span&gt;&lt;span&gt;,puppet&lt;/span&gt;&lt;span&gt;客户端可以反馈给服务器端一个消息， 如果出错&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;也会给服务器端反馈一个消息。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; ③ Puppet&lt;span&gt;是用于大规模集群管理的神器。其本身使用&lt;/span&gt;&lt;span&gt;Ruby&lt;/span&gt;&lt;span&gt;语言开发，基于&lt;/span&gt;&lt;span&gt;C/S&lt;/span&gt;&lt;span&gt;架构。在每台机器上部署的客户端每隔一个指定的时间会连接到&lt;/span&gt;&lt;span&gt;Master&lt;/span&gt;&lt;span&gt;检查资源变化情况，若资源发生变化，将按配置动作进行相应的操作。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; ④ &lt;strong&gt;Puppet&lt;span&gt;将所有可操作对象抽象为资源&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，目前涵盖了&lt;/span&gt;40&lt;span&gt;多种，如：&lt;/span&gt;&lt;span&gt;File&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;User&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;Group&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;Host&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;Package&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;Service&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;Cron&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;Exec&lt;/span&gt;&lt;span&gt;等，下面我会一一讲述。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; ⑤ Puppet &lt;span&gt;通过抽象资源的方式，使得每台机器能够&lt;/span&gt;&lt;span&gt;“&lt;/span&gt;&lt;span&gt;清楚&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;span&gt;其本身&lt;/span&gt;&lt;span&gt;“&lt;/span&gt;&lt;span&gt;应该&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;span&gt;是什么&lt;/span&gt;&lt;span&gt;“&lt;/span&gt;&lt;span&gt;状态&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;span&gt;，而客户端根据当前是否达到这个状态决定采取指定的动作。这使得&lt;/span&gt;&lt;span&gt;Puppet&lt;/span&gt; &lt;span&gt;不仅可用于传统的应用部署，而且通过合理的手段，也能够将比应用部署更频繁的配置管理一并解决。甚至可以在&lt;/span&gt;&lt;span&gt;Master&lt;/span&gt;&lt;span&gt;端外接自己开发的平台，通过集中配 置方式管理各项&lt;/span&gt;&lt;span&gt;“&lt;/span&gt;&lt;span&gt;资源&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;span&gt;，实现高度灵活的自动化管理体系。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;1.3 puppet 名词解释&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;资源&lt;/span&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;是&lt;/span&gt;puppet&lt;span&gt;的核心，通过资源申报，定义在资源清单中。相当于&lt;/span&gt;&lt;span&gt;ansible&lt;/span&gt;&lt;span&gt;中的模块，只是抽象的更加彻底。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;类：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;一组资源清单。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;模块：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;包含多个类。相当于&lt;/span&gt;ansible&lt;span&gt;中的角色。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;站点清单：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;以主机为核心，应用哪些模块。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;本篇文章主要讲解资源；类、模块、站点清单都在下篇进行详解。 &lt;/p&gt;

&lt;h4&gt;&lt;strong&gt;1.4 puppet&lt;span&gt;常用资源类型&lt;/span&gt;&lt;/strong&gt; &lt;/h4&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;group&lt;/td&gt;
&lt;td&gt;组&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;user&lt;/td&gt;
&lt;td&gt;用户&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;packge&lt;/td&gt;
&lt;td&gt;程序包&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;service&lt;/td&gt;
&lt;td&gt;服务&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;file&lt;/td&gt;
&lt;td&gt;文件&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;exec&lt;/td&gt;
&lt;td&gt;执行自定义命令&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;cron&lt;/td&gt;
&lt;td&gt;周期性任务计划&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;notify&lt;/td&gt;
&lt;td&gt;通知&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;yumrepo&lt;/td&gt;
&lt;td&gt;源&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;host&lt;/td&gt;
&lt;td&gt;/etc/hosts中主机解析&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h4&gt;&lt;strong&gt;1.5 puppet&lt;span&gt;命令使用&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）查询资源类型和帮助信息&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
puppet describe [-h|--help] [-s|--short] [-p|--providers] [-l|--list] [-m|--meta] [type]
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;-l&lt;span&gt;：列出所有资源类型；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-s&lt;/strong&gt;&lt;span&gt;：显示指定类型的&lt;/span&gt;&lt;strong&gt;&lt;span&gt;简要&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;帮助信息；也就是基本选项&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-m&lt;/strong&gt;&lt;span&gt;：显示指定类型的&lt;/span&gt;&lt;strong&gt;&lt;span&gt;元参数&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，一般与&lt;/span&gt;-s &lt;span&gt;一同使用；这些选项只是来描述这个类型的&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;2&lt;span&gt;）执行资源清单命令&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
puppet apply [-h|--help] [-V|--version] [-d|--debug] [-v|--verbose] [-e|--execute] [--detailed-exitcodes] [-l|--logdest &amp;lt;file&amp;gt;] [--noop] [--catalog &amp;lt;catalog&amp;gt;] [--write-catalog-summary] &amp;lt;file&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;  -d&lt;span&gt;：打开调试信息，会显示很多信息&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;  -v&lt;span&gt;：显示详细信息&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;  -e&lt;span&gt;：直接执行给定的命令&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;  -l&lt;span&gt;：执行结果保存到指定日志的文件中，否则执行结果会输出到标准输出&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;  &lt;strong&gt;--noop&lt;span&gt;：&lt;/span&gt;&lt;span&gt;dry run&lt;/span&gt;&lt;/strong&gt; &lt;span&gt;&lt;strong&gt;干跑&lt;/strong&gt;，只是测试的跑一边，不真正的执行&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;  --catalog：应用JSON目录&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;&lt;strong&gt;1.6 puppet&lt;span&gt;的优缺点&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;　　这类垂直管理系统的使用及活跃，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;极大减轻了运维人员在重复性、批量化操作方面的负担&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，能够非常有效地在各自领域完成既定的运维子目标。但其缺陷在于只能针对某一垂直领域的特定问题进行高效处理，对于它们之间的&lt;/span&gt;&lt;strong&gt;&lt;span&gt;关联性很难应对&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。因为运维的本质是保证服务的可用性，而自动化运维则是在完全保证这一前提下，尽可能将需要人干涉的部分处理掉，所以判断其优劣的标准则是&lt;/span&gt;——&lt;span&gt;与人工处理比，对服务的保证有没有提高。如果仅是解决报警、部署这些单一动作，后续仍然需要人去处理、去关注、去判断的话，就离这个目标还有距离，谈不上真正的自动化，只能算是工具化。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　puppet&lt;span&gt;是一个&lt;/span&gt;&lt;strong&gt;&lt;span&gt;开源&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;的软件自动化配置和部署工具，它&lt;/span&gt;&lt;strong&gt;&lt;span&gt;使用简单且功能强大&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，正得到了越来越多地关注，现在很多大型&lt;/span&gt;IT&lt;span&gt;公司均在使用&lt;/span&gt;&lt;span&gt;puppet&lt;/span&gt;&lt;span&gt;对集群中的软件进行管理和部署，如&lt;/span&gt;&lt;span&gt;google&lt;/span&gt;&lt;span&gt;利用&lt;/span&gt;&lt;span&gt;puppet&lt;/span&gt;&lt;span&gt;管理超过&lt;/span&gt;&lt;span&gt;6000&lt;/span&gt;&lt;span&gt;台地&lt;/span&gt;&lt;span&gt;mac&lt;/span&gt;&lt;span&gt;桌面电脑（&lt;/span&gt;&lt;span&gt;2007&lt;/span&gt;&lt;span&gt;年数据）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　puppet&lt;span&gt;设计架构是基于&lt;/span&gt;&lt;span&gt;c/s&lt;/span&gt;&lt;span&gt;架构的。服务器端保存着所有对客户端服务器的配置代码，在&lt;/span&gt;&lt;span&gt;puppet&lt;/span&gt;&lt;span&gt;里面叫做&lt;/span&gt;&lt;span&gt;manifest.&lt;/span&gt; &lt;span&gt;客户端下载&lt;/span&gt;&lt;span&gt;manifest&lt;/span&gt;&lt;span&gt;之后，可以根据&lt;/span&gt;&lt;span&gt;manifest&lt;/span&gt;&lt;span&gt;对服务器进行配置，例如软件包管理，用户管理和文件管理等等。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;2、puppet的使用模型及工作流程&lt;/h2&gt;
&lt;p&gt;　　puppet&lt;span&gt;的使用模型分为&lt;/span&gt; &lt;strong&gt;&lt;span&gt;单机使用模型&lt;/span&gt;&lt;/strong&gt; &lt;span&gt;和&lt;/span&gt; &lt;strong&gt;master/agent&lt;span&gt;模型&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;；本文主要讲解单机使用模型，便于入门。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;2.1 master/agent&lt;span&gt;模型&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;　　从上述专业的解释中，我们可以得知&lt;/span&gt;puppet&lt;span&gt;是&lt;/span&gt;&lt;strong&gt;C/S&lt;span&gt;架构&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;的，也就是说，它有服务端，也有客户端，管理员可以通过&lt;/span&gt;puppet&lt;span&gt;服务端（&lt;/span&gt;&lt;span&gt;master&lt;/span&gt;&lt;span&gt;），管理每一台被管理的服务器，但是需要&lt;/span&gt;&lt;span&gt;puppet&lt;/span&gt;&lt;span&gt;客户端作为中介，也就是说，&lt;/span&gt;&lt;span&gt;puppet&lt;/span&gt;&lt;span&gt;客户端作为代理（&lt;/span&gt;&lt;span&gt;agent&lt;/span&gt;&lt;span&gt;），接收来自&lt;/span&gt;&lt;span&gt;puppet&lt;/span&gt;&lt;span&gt;服务端的配置信息，按照服务端（&lt;/span&gt;&lt;span&gt;master&lt;/span&gt;&lt;span&gt;）发送过来的配置信息，对被管理服务器进行配置，真正执行配置操作的是&lt;/span&gt;&lt;span&gt;puppet&lt;/span&gt;&lt;span&gt;客户端，&lt;/span&gt;&lt;span&gt;puppet&lt;/span&gt;&lt;span&gt;服务端只负责将配置信息准备好，发送给&lt;/span&gt;&lt;span&gt;puppet&lt;/span&gt;&lt;span&gt;客户端，以便客户端执行具体操作，&lt;/span&gt;&lt;span&gt;puppet&lt;/span&gt;&lt;span&gt;客户端还有另一个作用，就是向&lt;/span&gt;&lt;span&gt;puppet&lt;/span&gt;&lt;span&gt;服务端发送报告，当客户端按照配置信息执行完成相关配置以后，会将执行信息发送到服务端，比如执行成功与否，执行结果等，默认情况下，每&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;&lt;span&gt;分钟，&lt;/span&gt;&lt;span&gt;puppet&lt;/span&gt;&lt;span&gt;客户端会向&lt;/span&gt;&lt;span&gt;puppet&lt;/span&gt;&lt;span&gt;服务端发起一次请求，请求受管理服务器的配置信息，&lt;/span&gt;&lt;span&gt; puppet&lt;/span&gt;&lt;span&gt;服务端将配置信息发送给客户端，客户端根据反回的信息进行判断，判断被管理服务器是否符合管理员定义的配置，&lt;/span&gt;&lt;span&gt;puppet&lt;/span&gt;&lt;span&gt;的这种工作模式就是&lt;/span&gt;&lt;span&gt;C/S&lt;/span&gt;&lt;span&gt;架构的，也可以理解为&lt;/span&gt;&lt;strong&gt;master/agent&lt;span&gt;的工作模式&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，用文字描述显得太无力，我们画个图来看看。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1216496/201902/1216496-20190214111911208-212217973.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　那么，我们把上图中的两台服务器拿出来，详细说说它们之间的具体工作流程，但是此处我们需要说明，在&lt;/span&gt;master/agent&lt;span&gt;模型下工作的&lt;/span&gt;&lt;span&gt;puppet&lt;/span&gt;&lt;span&gt;的工作流程比我们总结的要复杂一点，但是为了入门方便，我们只取出其中的一部分核心的流程进行总结，在后面的实际应用中，我们会不断的丰富这些流程，此处先给出一个简化过的流程图，如下图所示&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1216496/201902/1216496-20190214111924632-1223803372.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;过程分析：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;① &lt;span&gt;客户端&lt;/span&gt;&lt;span&gt;puppet agent&lt;/span&gt;&lt;span&gt;请求&lt;/span&gt;&lt;span&gt;catalog&lt;/span&gt;&lt;span&gt;，我们已经说过，&lt;/span&gt;&lt;span&gt;catalog&lt;/span&gt;&lt;span&gt;其实就是被管理服务器对应的配置文件（经过处理过的配置文件），服务端&lt;/span&gt;&lt;span&gt;master&lt;/span&gt;&lt;span&gt;收到&lt;/span&gt;&lt;span&gt;agent&lt;/span&gt;&lt;span&gt;的请求，然后找到对应被管理服务器的&lt;/span&gt;&lt;strong&gt;&quot;&lt;span&gt;站点清单&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，或者被称为&lt;/span&gt;&quot;&lt;span&gt;主机清单&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;，因为一台&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;被管理服务器&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;可能同时担任多个&lt;/span&gt;&lt;strong&gt;&quot;&lt;span&gt;角色&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，每个角色可能都会对应一个&lt;/span&gt;&lt;strong&gt;&quot;manifest&quot;&lt;span&gt;（也就是清单）&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，所以，我们可以为每一台被管理服务器配置一个&lt;/span&gt;&quot;&lt;span&gt;站点清单&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;，站点清单也可以理解成为一种&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;清单&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;，只是它是针对一台服务器而存在的一种清单。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;② &lt;span&gt;服务端&lt;/span&gt;&lt;span&gt;master&lt;/span&gt;&lt;span&gt;找到被管理服务器的站点清单后，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;根据站点清单，找到对应服务器需要哪些&lt;/span&gt;&quot;&lt;span&gt;清单&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;因为一台服务器可能会需要多张&lt;/span&gt;&quot;&lt;span&gt;清单&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;，上图中为了示例，只画出了一个清单，但是这不代表必定只有一个。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;③ master&lt;span&gt;将找到的所有&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;清单&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;进行处理，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;处理为&lt;/span&gt;catalog&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;④ master&lt;span&gt;将处理过的&lt;/span&gt;&lt;strong&gt;catalog&lt;span&gt;发送到&lt;/span&gt;&lt;span&gt;agent&lt;/span&gt;&lt;span&gt;端&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;⑤ agent&lt;span&gt;收到&lt;/span&gt;&lt;span&gt;master&lt;/span&gt;&lt;span&gt;发送过来的&lt;/span&gt;&lt;span&gt;catalog&lt;/span&gt;&lt;span&gt;，然后，&lt;/span&gt;&lt;span&gt;agent&lt;/span&gt;&lt;span&gt;会&lt;/span&gt;&lt;strong&gt;&lt;span&gt;查询&lt;/span&gt;&quot;&lt;span&gt;被管理服务器的当前状态&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，看看服务器的当前状态是否符合&lt;/span&gt;catalog&lt;span&gt;中定义的目标状态。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;⑥ &lt;span&gt;如果&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;被管理服务器的当前状态&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;与&lt;/span&gt;&lt;span&gt;&quot;catalog&lt;/span&gt;&lt;span&gt;中定义的目标状态&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;一致，那么资源对应的操作将不会执行，如果&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;被管理服务器的当前状态&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;与&lt;/span&gt;&lt;span&gt;&quot;catalog&lt;/span&gt;&lt;span&gt;中定义的目标状态&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;不一致，那么资源对应的操作将会执行，以便&lt;/span&gt;&lt;strong&gt;&lt;span&gt;让&lt;/span&gt;&quot;&lt;span&gt;被管理服务器&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;达到管理员指定的&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;目标状态&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;⑦ &lt;span&gt;经过上一步的&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;状态判断&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;，执行对应操作，不管执行是否成功，都会&lt;/span&gt;&lt;strong&gt;&lt;span&gt;生成对应的报告信息&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;⑧ agent&lt;span&gt;将&lt;/span&gt;&lt;strong&gt;&lt;span&gt;生成的报告信息&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;发送给&lt;/span&gt;master&lt;span&gt;端。&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　上述过程，就是&lt;/span&gt;puppet&lt;span&gt;在&lt;/span&gt;&lt;span&gt;master/agent&lt;/span&gt;&lt;span&gt;模式下的工作流程，我们说过，默认情况下，客户端每隔&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;&lt;span&gt;分钟向服务端请求一次配置信息，然后根据服务端返回的配置信息，判断当前服务器是否处于管理员定义的目标状态，如果被管理的服务器不处于管理员定义的目标状态，则需要执行对应的操作，使得被管理主机最终处于管理员定义的目标状态，我们也可以不必每次都等待&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;&lt;span&gt;分钟，我们可以从&lt;/span&gt;&lt;span&gt;master&lt;/span&gt;&lt;span&gt;端推送&lt;/span&gt;&lt;span&gt;catalog&lt;/span&gt;&lt;span&gt;到&lt;/span&gt;&lt;span&gt;agent&lt;/span&gt;&lt;span&gt;端，主动告诉&lt;/span&gt;&lt;span&gt;agent&lt;/span&gt;&lt;span&gt;端，配置已经发生了改变，请执行对应的操作。这是后话，我们以后再聊。&lt;/span&gt;&lt;/p&gt;

&lt;h4&gt;&lt;strong&gt;2.2 &lt;span&gt;单机使用模型&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;　　当然，&lt;/span&gt;puppet&lt;span&gt;也可以不在&lt;/span&gt;&lt;span&gt;master/agent&lt;/span&gt;&lt;span&gt;模式下工作，我们可以在受管理服务器上&lt;/span&gt;&lt;strong&gt;&lt;span&gt;只安装&lt;/span&gt;puppet&lt;span&gt;客户端&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，使用客户端手动执行对应配置文件，相当于配置文件中的信息并不是通过&lt;/span&gt;puppet&lt;span&gt;服务端发送过来，而是通过本地的配置文件获取，也是可以的，我们暂且称这种不需要&lt;/span&gt;&lt;span&gt;puppet&lt;/span&gt;&lt;span&gt;服务端的工作模式为&lt;/span&gt;&lt;strong&gt;&lt;span&gt;单机模式&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，我们在学习&lt;/span&gt;puppet&lt;span&gt;时，可以使用单机的模式&lt;/span&gt;&lt;strong&gt;&lt;span&gt;进行练习&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，但是在生产环境中，一般都使用&lt;/span&gt;master/agent&lt;span&gt;的方式使用&lt;/span&gt;&lt;span&gt;puppet&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　实现定义多个&lt;/span&gt;manifests --&amp;gt; complier --&amp;gt; catalog --&amp;gt; apply&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1216496/201902/1216496-20190214111949801-849322413.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;3、puppet资源详解&lt;/h2&gt;
&lt;h3&gt;3.1 puppet资源介绍&lt;/h3&gt;
&lt;h4&gt;&lt;strong&gt;3.1.1 &lt;span&gt;程序安装及环境&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;　　首先，我们还是来安装一下&lt;/span&gt;puppet&lt;span&gt;，&lt;/span&gt;&lt;span&gt;puppet&lt;/span&gt;&lt;span&gt;的安装可以使用源码安装，也可以使用&lt;/span&gt;&lt;span&gt;rpm&lt;/span&gt;&lt;span&gt;（官方提供）、&lt;/span&gt;&lt;span&gt;epel&lt;/span&gt;&lt;span&gt;源、官方提供的&lt;/span&gt;&lt;span&gt;yum&lt;/span&gt;&lt;span&gt;仓库来安装（通过下载官方提供的&lt;/span&gt;&lt;span&gt;rpm&lt;/span&gt;&lt;span&gt;包可以指定官方的&lt;/span&gt;&lt;span&gt;yum&lt;/span&gt;&lt;span&gt;仓库）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在这里，我们就是用&lt;/span&gt; yum &lt;span&gt;安装的方式。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@along ~]# yum -y install puppet
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;&lt;strong&gt;3.1.2 puppet&lt;span&gt;资源简介&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）资源抽象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;puppet &lt;span&gt;从以下三个维度来对资源完成抽象：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt; &lt;span&gt;相似的资源被抽象成同一种资源&lt;/span&gt;“&lt;span&gt;类型&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;span&gt;，如程序包资源、用户资源及服务资源等；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; &lt;strong&gt;&lt;span&gt;将资源属性或状态的描述与其实现方式剥离开来&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，如仅说明安装一个程序包而不用关心其具体是通过&lt;/span&gt;yum&lt;span&gt;、&lt;/span&gt;&lt;span&gt;pkgadd&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;ports&lt;/span&gt;&lt;span&gt;或是其它方式实现；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; &lt;strong&gt;&lt;span&gt;仅描述资源的目标状态&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，也即期望其实现的结果，而不是其具体过程，如&lt;/span&gt;“&lt;span&gt;确定&lt;/span&gt;&lt;span&gt;nginx&lt;/span&gt; &lt;span&gt;运行起来&lt;/span&gt;&lt;span&gt;”&lt;/span&gt; &lt;span&gt;而不是具体描述为&lt;/span&gt;&lt;span&gt;“&lt;/span&gt;&lt;span&gt;运行&lt;/span&gt;&lt;span&gt;nginx&lt;/span&gt;&lt;span&gt;命令将其启动起来&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;span&gt;；&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;这三个也被称作&lt;/span&gt;puppet &lt;span&gt;的资源抽象层&lt;/span&gt;&lt;span&gt;(RAL)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;RAL &lt;span&gt;由&lt;/span&gt;&lt;span&gt;type(&lt;/span&gt; &lt;span&gt;类型&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;和&lt;/span&gt;&lt;span&gt;provider(&lt;/span&gt; &lt;span&gt;提供者，即不同&lt;/span&gt;&lt;span&gt;OS&lt;/span&gt; &lt;span&gt;上的特定实现&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;组成。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;2&lt;span&gt;）资源定义&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;① &lt;span&gt;资源定义通过向资源类型的属性赋值来实现，可称为资源类型实例化；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;② &lt;span&gt;定义了资源实例的文件即清单，&lt;/span&gt;&lt;span&gt;manifest&lt;/span&gt;&lt;span&gt;；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;③ &lt;span&gt;定义资源的语法如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
type {'title':
        attribute1      =&amp;gt; value1,
        atrribute2      =&amp;gt; value2,
        ……
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　注意：type必须使用小写字符；title是一个字符串，在同一类型中必须惟一；每一个属性之间需要用“,”隔开，最后一个“,”可省略。&lt;/p&gt;
&lt;p&gt;　　例如，可以同时有名为nginx 的“service”资源和“package”资源，但在“package” 类型的资源中只能有一个名为“nginx”的资源。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;（&lt;/span&gt;3&lt;span&gt;）资源属性中的三个特殊属性：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt; Namevar&lt;span&gt;：可简称为&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; ensure&lt;span&gt;：资源的目标状态；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; Provider&lt;span&gt;：指明资源的管理接口；&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;strong&gt;3.2 group&lt;span&gt;：&lt;/span&gt;&lt;span&gt;Manage groups&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;strong&gt;3.2.1 &lt;span&gt;类型属性选项&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）属性&lt;/span&gt; &lt;span&gt;Parameters&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt; &lt;strong&gt;name&lt;/strong&gt;&lt;span&gt;：组名；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; gid&lt;span&gt;：&lt;/span&gt;&lt;span&gt;GID&lt;/span&gt;&lt;span&gt;；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; system&lt;span&gt;：是否为系统组，&lt;/span&gt;&lt;span&gt;true OR false&lt;/span&gt;&lt;span&gt;；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; &lt;strong&gt;ensure&lt;/strong&gt;&lt;span&gt;：目标状态，&lt;/span&gt;present&lt;span&gt;（创建）&lt;/span&gt;&lt;span&gt;/absent&lt;/span&gt;&lt;span&gt;（删除）；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; members&lt;span&gt;：成员用户&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;（&lt;/span&gt;2&lt;span&gt;）&lt;/span&gt;&lt;span&gt;puppet describe group -s -m   &lt;/span&gt;&lt;span&gt;使用之前，可以查询这个类型的选项&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1216496/201902/1216496-20190214112204450-1608742959.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h4&gt;&lt;strong&gt;3.2.2 &lt;span&gt;演示&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;① &lt;span&gt;编辑&lt;/span&gt;&lt;span&gt;manifest(&lt;/span&gt; &lt;span&gt;清单&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:ruby;gutter:true;&quot;&gt;
[root@along manifest]# vim group.pp
group{'mygrp':
        name =&amp;gt; 'mygrp',
        ensure =&amp;gt; present,
        gid =&amp;gt; 2000,
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;② &lt;span&gt;执行并验证&lt;/span&gt; &lt;span&gt;manifest&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
---先预执行一次，检查是否有语法错误
[root@along manifest]# puppet apply -v --noop group.pp 
Notice: Compiled catalog for along in environment production in 0.18 seconds
Info: Applying configuration version '1550042227'
Notice: /Stage[main]/Main/Group[mygrp]/ensure: current_value absent, should be present (noop)
Notice: Class[Main]: Would have triggered 'refresh' from 1 events
Notice: Stage[main]: Would have triggered 'refresh' from 1 events
Info: Creating state file /var/lib/puppet/state/state.yaml
Notice: Finished catalog run in 0.03 seconds
---真正执行，执行成功
[root@along manifest]# puppet apply -v group.pp
Notice: Compiled catalog for along in environment production in 0.06 seconds
Info: Applying configuration version '1550042298'
Notice: /Stage[main]/Main/Group[mygrp]/ensure: created
Notice: Finished catalog run in 0.09 seconds
---查询验证
[root@along manifest]# cat /etc/group |grep mygrp
mygrp:x:2000:
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;strong&gt;3.3 user&lt;span&gt;：&lt;/span&gt;&lt;span&gt;Manage users&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;strong&gt;3.3.1 &lt;span&gt;类型属性选项&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）属性&lt;/span&gt; &lt;span&gt;Parameters&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt; &lt;strong&gt;name&lt;span&gt;：用户名；&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt; uid: UID;&lt;/li&gt;
&lt;li&gt; gid&lt;span&gt;：基本组&lt;/span&gt;&lt;span&gt;ID&lt;/span&gt;&lt;span&gt;；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; groups&lt;span&gt;：附加组，不能包含基本组；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; comment&lt;span&gt;：注释；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; expiry&lt;span&gt;：过期时间 ；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; home&lt;span&gt;：家目录；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; shell&lt;span&gt;：默认&lt;/span&gt;&lt;span&gt;shell&lt;/span&gt;&lt;span&gt;类型；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; system&lt;span&gt;：是否为系统用户 ；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; &lt;strong&gt;ensure&lt;span&gt;：&lt;/span&gt;&lt;span&gt;present/absent&lt;/span&gt;&lt;/strong&gt; &lt;span&gt;存在&lt;/span&gt;/&lt;span&gt;不存在；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; password&lt;span&gt;：加密后的密码串；&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;（&lt;/span&gt;2&lt;span&gt;）&lt;/span&gt;&lt;span&gt;puppet describe user -s -m   &lt;/span&gt;&lt;span&gt;使用之前，可以查询这个类型的选项&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1216496/201902/1216496-20190214112325716-993216185.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h4&gt;&lt;strong&gt;3.3.2 &lt;span&gt;演示&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;① &lt;span&gt;编辑&lt;/span&gt;&lt;span&gt;manifest(&lt;/span&gt; &lt;span&gt;清单&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;brush:ruby;gutter:true;&quot;&gt;
[root@along manifest]# vim user1.pp
user{'along1':
        ensure =&amp;gt; present,
        system =&amp;gt; false,
        comment =&amp;gt; 'Test user',
        shell =&amp;gt; '/usr/sbin/nologin',
        home =&amp;gt; '/app/along',
        managehome =&amp;gt; true,
        groups =&amp;gt; 'mygrp',
        uid =&amp;gt; 3000,
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;② &lt;span&gt;执行&lt;/span&gt;&lt;span&gt;manifest&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@along manifest]# puppet apply -v --noop user1.pp
[root@along manifest]# puppet apply -v user1.pp
Notice: Compiled catalog for along in environment production in 0.08 seconds
Info: Applying configuration version '1550042932'
Notice: /Stage[main]/Main/User[along1]/ensure: created
Notice: Finished catalog run in 0.12 seconds
[root@along manifest]# cat /etc/passwd |grep along1
along1:x:3000:3000:Test user:/mnt/along:/usr/sbin/nologin
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;strong&gt;3.4 package&lt;span&gt;：&lt;/span&gt;&lt;span&gt;Manage packages&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;strong&gt;3.4.1 &lt;span&gt;类型属性选项&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;① &lt;span&gt;属性：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;  &lt;strong&gt;ensure&lt;span&gt;：&lt;/span&gt;&lt;span&gt;installed&lt;/span&gt;&lt;/strong&gt;, present, &lt;strong&gt;latest, absent,&lt;/strong&gt; any version string (implies present)&lt;/li&gt;
&lt;li&gt;  &lt;strong&gt;name&lt;span&gt;：包名；&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;  ource&lt;span&gt;：程序包来源，仅对不会自动下载相关程序包的&lt;/span&gt;&lt;span&gt;provider&lt;/span&gt;&lt;span&gt;有用，例如&lt;/span&gt;&lt;span&gt;rpm&lt;/span&gt;&lt;span&gt;或&lt;/span&gt;&lt;span&gt;dpkg&lt;/span&gt;&lt;span&gt;；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;  provider&lt;span&gt;：指明安装方式；&lt;/span&gt;&lt;span&gt;rpm/yum/...&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;② puppet describe package -s -m   &lt;span&gt;可以查询这个类型的选项&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1216496/201902/1216496-20190214112420107-952508454.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h4&gt;&lt;strong&gt;3.4.2 &lt;span&gt;演示&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;① &lt;span&gt;创建&lt;/span&gt;&lt;span&gt;manifest&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:ruby;gutter:true;&quot;&gt;
[root@along manifest]# vim pkg.pp 
package{'redis':
        ensure =&amp;gt; installed, 
        provider =&amp;gt; yum
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;② &lt;span&gt;执行&lt;/span&gt;&lt;span&gt;manifest&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@along manifest]# puppet apply --noop -v pkg.pp
[root@along manifest]# puppet apply -v pkg.pp 
Notice: Compiled catalog for along in environment production in 0.26 seconds
Warning: The package type's allow_virtual parameter will be changing its default value from false to true in a future release. If you do not want to allow virtual packages, please explicitly set allow_virtual to false.
   (at /usr/share/ruby/vendor_ruby/puppet/type.rb:816:in `set_default')
Info: Applying configuration version '1550044027'
Notice: /Stage[main]/Main/Package[redis]/ensure: created
Notice: Finished catalog run in 6.09 seconds
[root@along manifest]# rpm -ql redis
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;strong&gt;3.5 service&lt;span&gt;：&lt;/span&gt;&lt;span&gt;Manage running services&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;strong&gt;3.5.1 &lt;span&gt;类型属性选项&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;① &lt;span&gt;属性：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;  &lt;strong&gt;ensure&lt;span&gt;：&lt;/span&gt;&lt;span&gt;running\true&lt;/span&gt;&lt;span&gt;（开启）&lt;/span&gt;&lt;/strong&gt; &lt;span&gt;或&lt;/span&gt; &lt;strong&gt;stopped&lt;/strong&gt;/&lt;strong&gt;false&lt;span&gt;（停止）&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;  enable&lt;span&gt;：是否开机自启：&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;（开机自启）、&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;（不自启）、&lt;/span&gt;&lt;span&gt;manual&lt;/span&gt;&lt;span&gt;（手动）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;  &lt;strong&gt;name&lt;span&gt;：服务名&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;  binary&lt;span&gt;：若服务不是&lt;/span&gt;&lt;span&gt;systemctl/service&lt;/span&gt; &lt;span&gt;启动，则需规定启动命令；如&lt;/span&gt;&lt;span&gt;nginx -s start&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;  path&lt;span&gt;：如果不是&lt;/span&gt;&lt;span&gt;systemctl/service&lt;/span&gt; &lt;span&gt;这样启动服务，而是通过脚本启动，指明&lt;/span&gt;&lt;span&gt;path&lt;/span&gt;&lt;span&gt;路径。多个值应该由冒号分隔，或者作为数组提供。脚本的搜索路径，默认为&lt;/span&gt;&lt;span&gt;/etc/init.d/&lt;/span&gt;&lt;span&gt;；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;  hasrestart&lt;span&gt;：是否支持&lt;/span&gt;&lt;span&gt;restart&lt;/span&gt; &lt;span&gt;这个参数重启；&lt;/span&gt;&lt;span&gt;true/fault&lt;/span&gt; &lt;span&gt;；&lt;/span&gt;&lt;span&gt;true&lt;/span&gt; &lt;span&gt;表示支持&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;  hasstatus&lt;span&gt;：是否支持&lt;/span&gt;&lt;span&gt;status&lt;/span&gt; &lt;span&gt;这个参数查看状态；&lt;/span&gt;&lt;span&gt;true/false&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;  start&lt;span&gt;：手动定义启动命令；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;  stop&lt;span&gt;：手动定义关闭命令；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;  status&lt;span&gt;：若&lt;/span&gt;&lt;span&gt;hasstatus&lt;/span&gt; &lt;span&gt;为&lt;/span&gt;&lt;span&gt;fals&lt;/span&gt; &lt;span&gt;手动定义查看信息命令；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;  restart&lt;span&gt;：若&lt;/span&gt;&lt;span&gt;hasrestart&lt;/span&gt; &lt;span&gt;为&lt;/span&gt;&lt;span&gt;false&lt;/span&gt; &lt;span&gt;手动定义&lt;/span&gt;&lt;span&gt;reload&lt;/span&gt;&lt;span&gt;操作&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;② puppet describe service -s -m   &lt;span&gt;可以查询这个类型的选项&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1216496/201902/1216496-20190214112503756-879372839.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h4&gt;&lt;strong&gt;3.5.2 &lt;span&gt;演示&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;：开启&lt;/span&gt;&lt;span&gt;redis&lt;/span&gt; &lt;span&gt;服务&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;① &lt;span&gt;编写&lt;/span&gt;&lt;span&gt;manifest&lt;/span&gt; &lt;span&gt;资源清单&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:ruby;gutter:true;&quot;&gt;
[root@along manifest]# vim srv1.pp
service{'redis':
        ensure =&amp;gt; running,
        enable =&amp;gt; true,
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;② &lt;span&gt;执行&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@along manifest]# puppet apply -v --noop srv1.pp
[root@along manifest]# puppet apply -v srv1.pp
Notice: Compiled catalog for along in environment production in 0.08 seconds
Info: Applying configuration version '1550044320'
Notice: /Stage[main]/Main/Service[redis]/ensure: ensure changed 'stopped' to 'running'
Info: /Stage[main]/Main/Service[redis]: Unscheduling refresh on Service[redis]
Notice: Finished catalog run in 0.11 seconds
[root@along manifest]# ss -nutl |grep 6379
tcp    LISTEN     0      128    127.0.0.1:6379                  *:*
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;&lt;strong&gt;3.5.2 &lt;span&gt;演示&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;：下载&lt;/span&gt;&lt;span&gt;memcached&lt;/span&gt; &lt;span&gt;包，且开启服务&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;① &lt;span&gt;编写&lt;/span&gt;&lt;span&gt;manifest&lt;/span&gt; &lt;span&gt;资源清单&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
[root@along manifest]&lt;span&gt;#&lt;/span&gt;&lt;span&gt; vim srv2.pp&lt;/span&gt;
package {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;memcached&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
        ensure &lt;/span&gt;=&amp;gt;&lt;span&gt; installed,
}

service{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;memcached&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
        ensure &lt;/span&gt;=&amp;gt;&lt;span&gt; running,
        enable &lt;/span&gt;=&amp;gt;&lt;span&gt; false,
        require &lt;/span&gt;=&amp;gt; Package[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;memcached&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; ② &lt;span&gt;执行&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@along manifest]# puppet apply -v --noop srv2.pp
[root@along manifest]# puppet apply -v srv2.pp
Notice: Compiled catalog for along in environment production in 0.35 seconds
Warning: The package type's allow_virtual parameter will be changing its default value from false to true in a future release. If you do not want to allow virtual packages, please explicitly set allow_virtual to false.
   (at /usr/share/ruby/vendor_ruby/puppet/type.rb:816:in `set_default')
Info: Applying configuration version '1550044434'
Notice: /Stage[main]/Main/Package[memcached]/ensure: created
Notice: /Stage[main]/Main/Service[memcached]/ensure: ensure changed 'stopped' to 'running'
Info: /Stage[main]/Main/Service[memcached]: Unscheduling refresh on Service[memcached]
Notice: Finished catalog run in 3.28 seconds
[root@along manifest]# ss -nutlp |grep memcached
udp    UNCONN     0      0         *:11211                 *:*                   users:((&quot;memcached&quot;,pid=8573,fd=28))
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;strong&gt;3.6 file&lt;span&gt;：管理文件，包括它们的内容、所有权和权限&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;strong&gt;3.6.1 &lt;span&gt;类型属性选项&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）类型的属性、选项&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;① &lt;span&gt;属性&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt; &lt;strong&gt; ensure&lt;span&gt;：&lt;/span&gt;&lt;span&gt;`&lt;/span&gt;&lt;/strong&gt;present`&lt;span&gt;创建&lt;/span&gt;&lt;span&gt;, `absent`&lt;/span&gt;&lt;span&gt;删除&lt;/span&gt;&lt;span&gt;, `file`&lt;/span&gt;&lt;span&gt;创建普通文件&lt;/span&gt;&lt;span&gt;, `directory`&lt;/span&gt;&lt;span&gt;创建目录&lt;/span&gt;&lt;span&gt;, link`&lt;/span&gt;&lt;span&gt;创建软链接&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;  file&lt;span&gt;：类型为普通文件，其内容由&lt;/span&gt;&lt;span&gt;content&lt;/span&gt;&lt;span&gt;属性生成或复制由&lt;/span&gt;&lt;span&gt;source&lt;/span&gt;&lt;span&gt;属性指向的文件路径来创建；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;  link&lt;span&gt;：类型为符号链接文件，必须由&lt;/span&gt;&lt;span&gt;target&lt;/span&gt;&lt;span&gt;属性指明其链接的目标文件；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;  directory&lt;span&gt;：类型为目录，可通过&lt;/span&gt;&lt;span&gt;source&lt;/span&gt;&lt;span&gt;指向的路径复制生成，&lt;/span&gt;&lt;span&gt;recurse&lt;/span&gt;&lt;span&gt;属性指明是否递归复制；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;  &lt;strong&gt;path&lt;span&gt;：文件路径；&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;  source&lt;span&gt;：源文件；当复制文件内容时需要指定&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;  content&lt;span&gt;：文件内容；直接编写文件内容&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;  target&lt;span&gt;：符号链接的目标文件；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;  owner&lt;span&gt;：属主&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;  group&lt;span&gt;：属组&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;  mode&lt;span&gt;：权限；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;  atime/ctime/mtime&lt;span&gt;：时间戳；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; access time&lt;span&gt;：访问时间，&lt;/span&gt;&lt;span&gt;atime&lt;/span&gt;&lt;span&gt;，读取文件内容&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; modify time: &lt;span&gt;修改时间&lt;/span&gt;&lt;span&gt;, mtime&lt;/span&gt;&lt;span&gt;，改变文件内容（数据）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; change time: &lt;span&gt;改变时间&lt;/span&gt;&lt;span&gt;, ctime&lt;/span&gt;&lt;span&gt;，元数据发生改变&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;② puppet describe &lt;strong&gt;file&lt;/strong&gt; -s -m |tail -20&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1216496/201902/1216496-20190214112619728-1999514285.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;&lt;strong&gt;3.6.2 &lt;span&gt;演示&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;：创建&lt;/span&gt;&lt;span&gt;test.txt&lt;/span&gt;&lt;span&gt;，且直接写内容&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;创建&lt;/span&gt;test.txt&lt;span&gt;，且直接写内容&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;① &lt;span&gt;编写&lt;/span&gt;&lt;span&gt;manifest&lt;/span&gt; &lt;span&gt;清单&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
[root@along manifest]&lt;span&gt;#&lt;/span&gt;&lt;span&gt; vim file1.pp&lt;/span&gt;
file{&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/mnt/test.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
        ensure &lt;/span&gt;=&amp;gt;&lt;span&gt; file,
        content &lt;/span&gt;=&amp;gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;How are you?\nHow old are you?\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        owner &lt;/span&gt;=&amp;gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;along1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        group &lt;/span&gt;=&amp;gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;mygrp&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        mode &lt;/span&gt;=&amp;gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;0400&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; ② &lt;span&gt;执行&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@along manifest]# puppet apply -v --noop file1.pp
[root@along manifest]# puppet apply -v file1.pp
Notice: Compiled catalog for along in environment production in 0.07 seconds
Info: Applying configuration version '1550044597'
Notice: /Stage[main]/Main/File[/mnt/test.txt]/ensure: defined content as '{md5}93c1208b855bf27a44bb2eb1b022b8cd'
Notice: Finished catalog run in 0.04 seconds
[root@along manifest]# ll /mnt/test.txt 
-r-------- 1 along1 mygrp 30 Feb 13 15:56 /mnt/test.txt
[root@along manifest]# cat /mnt/test.txt
How are you?
How old are you?
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;&lt;strong&gt;3.6.3 &lt;span&gt;演示&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;：创建一个文件，且复制另一个文件的内容；再对这个文件创建一个软链接文件&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;① &lt;span&gt;编写&lt;/span&gt;&lt;span&gt;manifest&lt;/span&gt; &lt;span&gt;清单&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
[root@along manifest]&lt;span&gt;#&lt;/span&gt;&lt;span&gt; vim file2.pp &lt;/span&gt;
file{&lt;span&gt;'&lt;/span&gt;&lt;span&gt;redis.conf&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
        path &lt;/span&gt;=&amp;gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/mnt/redis.conf&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        ensure &lt;/span&gt;=&amp;gt;&lt;span&gt; file,
        source &lt;/span&gt;=&amp;gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/root/manifest/files/redis.conf&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
}

file{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;symlink.conf&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
        ensure &lt;/span&gt;=&amp;gt;&lt;span&gt; link,
        path &lt;/span&gt;=&amp;gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/mnt/symlink.conf&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        target &lt;/span&gt;=&amp;gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/mnt/redis.conf&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        require &lt;/span&gt;=&amp;gt; File[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;redis.conf&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　提示：若要指定&lt;/span&gt;source &lt;span&gt;，最好先把源文件复制到此目录中，因为在&lt;/span&gt;&lt;span&gt;master-agent&lt;/span&gt; &lt;span&gt;模式中，不能确保&lt;/span&gt;&lt;span&gt;agent&lt;/span&gt; &lt;span&gt;机器上的路径下，一定有要复制的文件；本次操作需要在&lt;/span&gt;&lt;span&gt;/root/manifests/files/&lt;/span&gt;&lt;span&gt;准备好&lt;/span&gt;&lt;span&gt;redis.con&lt;/span&gt;&lt;span&gt;文件。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@along manifest]# mkdir files
[root@along manifest]# cp /etc/redis.conf /root/manifest/files/
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;② &lt;span&gt;执行&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@along manifest]# puppet apply -v --noop file2.pp
[root@along manifest]# puppet apply -v file2.pp
Notice: Compiled catalog for along in environment production in 0.07 seconds
Info: Applying configuration version '1550045858'
Notice: /Stage[main]/Main/File[redis.conf]/ensure: defined content as '{md5}d98629fded012cd2a25b9db0599a9251'
Notice: /Stage[main]/Main/File[symlink.conf]/ensure: created
Notice: Finished catalog run in 0.05 seconds
[root@along manifest]# ll /mnt/redis.conf /mnt/symlink.conf 
-rw-r----- 1  777 root 46729 Feb 13 16:17 /mnt/redis.conf
lrwxrwxrwx 1 root root    15 Feb 13 16:17 /mnt/symlink.conf -&amp;gt; /mnt/redis.conf
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;&lt;strong&gt;3.6.4 &lt;span&gt;演示&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;：创建目录，且递归复制另一个目录&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;创建目录，且递归复制另一个目录&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;① &lt;span&gt;编写&lt;/span&gt;&lt;span&gt;manifest&lt;/span&gt; &lt;span&gt;清单&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
[root@along manifest]&lt;span&gt;#&lt;/span&gt;&lt;span&gt; vim file3.pp&lt;/span&gt;
file{&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test.dir&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
        ensure &lt;/span&gt;=&amp;gt;&lt;span&gt; directory,
        path &lt;/span&gt;=&amp;gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/app/test.dir&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, 
    source &lt;/span&gt;=&amp;gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/etc/httpd&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        recurse &lt;/span&gt;=&amp;gt; true   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;递归复制&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span&gt;注意：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　目录复制目录，是将目录下的所有文件递归复制；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　不要用&lt;/span&gt;path &lt;span&gt;为目录，&lt;/span&gt;&lt;span&gt;source&lt;/span&gt;&lt;span&gt;为文件，不会将此文件复制到目录中；只能是目录复制目录&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;② &lt;span&gt;执行&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@along manifest]# puppet apply -v file3.pp
Notice: Compiled catalog for along in environment production in 0.07 seconds
Info: Applying configuration version '1550046089'
Notice: /Stage[main]/Main/File[test.dir]/ensure: created
Notice: /Stage[main]/Main/File[/mnt/test.dir/along]/ensure: created
Notice: /Stage[main]/Main/File[/mnt/test.dir/along/.bash_logout]/ensure: defined content as '{md5}6a5bc1cc5f80a48b540bc09d082b5855'
Notice: /Stage[main]/Main/File[/mnt/test.dir/symlink.conf]/ensure: created
Notice: /Stage[main]/Main/File[/mnt/test.dir/along/.bash_profile]/ensure: defined content as '{md5}f939eb71a81a9da364410b799e817202'
Notice: /Stage[main]/Main/File[/mnt/test.dir/redis.conf]/ensure: defined content as '{md5}d98629fded012cd2a25b9db0599a9251'
Notice: /Stage[main]/Main/File[/mnt/test.dir/along/.bashrc]/ensure: defined content as '{md5}2f8222b4f275c4f18e69c34f66d2631b'
Notice: /Stage[main]/Main/File[/mnt/test.dir/test.txt]/ensure: defined content as '{md5}93c1208b855bf27a44bb2eb1b022b8cd'
Notice: Finished catalog run in 0.08 seconds
[root@along manifest]# ll /mnt/test.dir/
total 52
drwx------ 2 along1 along1    62 Feb 13 16:21 along
-rw-r----- 1    777 root   46729 Feb 13 16:21 redis.conf
lrwxrwxrwx 1 root   root      15 Feb 13 16:21 symlink.conf -&amp;gt; /mnt/redis.conf
-r-------- 1 along1 mygrp     30 Feb 13 16:21 test.txt
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;&lt;strong&gt;3.6.5 &lt;span&gt;演示&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;：下载&lt;/span&gt;&lt;span&gt;redis&lt;/span&gt; &lt;span&gt;包，复制配置文件，启动&lt;/span&gt;&lt;span&gt;redis&lt;/span&gt; &lt;span&gt;服务&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;下载&lt;/span&gt;redis &lt;span&gt;包，复制配置文件，启动&lt;/span&gt;&lt;span&gt;redis&lt;/span&gt; &lt;span&gt;服务&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;① &lt;span&gt;编写&lt;/span&gt;&lt;span&gt;manifest&lt;/span&gt; &lt;span&gt;清单&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
[root@along manifest]&lt;span&gt;#&lt;/span&gt;&lt;span&gt; vim srv3.pp&lt;/span&gt;
package{&lt;span&gt;'&lt;/span&gt;&lt;span&gt;redis&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
        ensure &lt;/span&gt;=&amp;gt;&lt;span&gt; installed,
}

file{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/etc/redis.conf&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
        ensure  &lt;/span&gt;=&amp;gt;&lt;span&gt; file,
        source  &lt;/span&gt;=&amp;gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/root/manifest/files/redis.conf&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        owner   &lt;/span&gt;=&amp;gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;redis&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        group   &lt;/span&gt;=&amp;gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        mode    &lt;/span&gt;=&amp;gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;0640&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
}

service{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;redis&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
        ensure  &lt;/span&gt;=&amp;gt;&lt;span&gt; running,
        enable  &lt;/span&gt;=&amp;gt;&lt;span&gt; false
}

Package[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;redis&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] -&amp;gt; File[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/etc/redis.conf&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] -&amp;gt; Service[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;redis&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;注意：我事先将&lt;/span&gt;/root/manifest/files/redis.conf&lt;span&gt;配置文件的端口修改为了&lt;/span&gt;&lt;span&gt;6300&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;② &lt;span&gt;执行&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@along manifest]# puppet apply -v --noop srv3.pp 
[root@along manifest]# puppet apply -v srv3.pp
Notice: Compiled catalog for along in environment production in 0.46 seconds
Warning: The package type's allow_virtual parameter will be changing its default value from false to true in a future release. If you do not want to allow virtual packages, please explicitly set allow_virtual to false.
   (at /usr/share/ruby/vendor_ruby/puppet/type.rb:816:in `set_default')
Info: Applying configuration version '1550046351'
Notice: /Stage[main]/Main/Package[redis]/ensure: created
Info: /Stage[main]/Main/File[/etc/redis.conf]: Filebucketed /etc/redis.conf to puppet with sum d98629fded012cd2a25b9db0599a9251
Notice: /Stage[main]/Main/File[/etc/redis.conf]/content: content changed '{md5}d98629fded012cd2a25b9db0599a9251' to '{md5}d3fc0c22e1a90f88a895242b2a251dad'
Notice: /Stage[main]/Main/Service[redis]/ensure: ensure changed 'stopped' to 'running'
Info: /Stage[main]/Main/Service[redis]: Unscheduling refresh on Service[redis]
Notice: Finished catalog run in 3.65 seconds
[root@along manifest]# ss -nutlp |grep 6300
tcp    LISTEN     0      128    127.0.0.1:6300                  *:*                   users:((&quot;redis-server&quot;,pid=11628,fd=4))
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;strong&gt;3.7 exec&lt;span&gt;：执行外部命令&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　注意：&lt;/span&gt;exec&lt;span&gt;资源中的任何命令都必须能够多次运行而不会造成损害&lt;/span&gt;&lt;span&gt;——&lt;/span&gt;&lt;span&gt;也就是说，它必须具有&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;幂等性&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;3.7.1 &lt;span&gt;类型属性选项&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt; command&lt;span&gt;：要运行的命令；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; cwd&lt;span&gt;：用于运行该命令的目录&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; &lt;strong&gt;creates&lt;span&gt;：文件路径，仅此路径表示的文件不存在时，&lt;/span&gt;&lt;span&gt;command&lt;/span&gt;&lt;span&gt;方才执行；&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt; user/group&lt;span&gt;：运行命令的用户身份；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; &lt;strong&gt;path&lt;span&gt;：用于执行命令的搜索路径。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;如果没有指定路径，则命令必须完全限定。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; onlyif&lt;span&gt;：此属性指定一个命令，此命令正常（退出码为&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;）运行时，当前&lt;/span&gt;&lt;span&gt;command&lt;/span&gt;&lt;span&gt;才会运行；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; unless&lt;span&gt;：此属性指定一个命令，此命令非正常（退出码为非&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;）运行时，当前&lt;/span&gt;&lt;span&gt;command&lt;/span&gt;&lt;span&gt;才会运行；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; &lt;strong&gt;refresh&lt;span&gt;：重新执行当前&lt;/span&gt;&lt;span&gt;command&lt;/span&gt;&lt;span&gt;的替代命令&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; refreshonly&lt;span&gt;：仅接收到订阅的资源的通知时方才运行；&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1216496/201902/1216496-20190214112835402-2124993879.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;&lt;strong&gt;3.7.2 &lt;span&gt;演示&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;：创建一个目录&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;创建一个目录&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;① &lt;span&gt;编写&lt;/span&gt;&lt;span&gt;manifest&lt;/span&gt; &lt;span&gt;清单&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
[root@along manifest]&lt;span&gt;#&lt;/span&gt;&lt;span&gt; vim cmd1.pp&lt;/span&gt;
&lt;span&gt;exec&lt;/span&gt;{&lt;span&gt;'&lt;/span&gt;&lt;span&gt;cmd&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
        command &lt;/span&gt;=&amp;gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;[ -e /mnt/testdir ] || mkdir /mnt/testdir&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        path &lt;/span&gt;=&amp;gt; [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/bin&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sbin&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/usr/bin&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/usr/sbin&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;],
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;        creates =&amp;gt; '/mnt/testdir'    判断目录是否存在&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　分析：先判断目录是否存在，不存在再创建目录，使命令具有幂等性；就算是目录已存在，也不会有报错&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;② &lt;span&gt;执行&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@along manifest]# puppet apply -v cmd1.pp
Notice: Compiled catalog for along in environment production in 0.02 seconds
Info: Applying configuration version '1550047003'
Notice: /Stage[main]/Main/Exec[cmd]/returns: executed successfully
Notice: Finished catalog run in 0.03 seconds
[root@along manifest]# ll -d /mnt/testdir/
drwxr-xr-x 2 root root 6 Feb 13 16:36 /mnt/testdir/
[root@along manifest]# puppet apply -v cmd1.pp
Notice: Compiled catalog for along in environment production in 0.02 seconds
Info: Applying configuration version '1550047046'
Notice: /Stage[main]/Main/Exec[cmd]/returns: executed successfully
Notice: Finished catalog run in 0.03 seconds
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;&lt;strong&gt;3.7.3 &lt;span&gt;演示&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;：创建一个用户&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
---编写manifest 清单
[root@along manifest]# vim cmd2.pp
exec{'user':
        command =&amp;gt; 'useradd along',
        path =&amp;gt; '/bin:sbin:/usr/bin:/usr/sbin',
        unless =&amp;gt; 'id along'
}
---执行
[root@along manifest]# puppet apply -v cmd2.pp
Notice: Compiled catalog for along in environment production in 0.02 seconds
Info: Applying configuration version '1550047187'
Notice: Finished catalog run in 0.03 seconds
[root@along manifest]# id along
uid=1000(along) gid=1000(along) groups=1000(along)
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;&lt;strong&gt;3.7.4 &lt;span&gt;演示&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;：下载，开启&lt;/span&gt;&lt;span&gt;redis&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;① &lt;span&gt;编写&lt;/span&gt;&lt;span&gt;manifest&lt;/span&gt; &lt;span&gt;清单&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
[root@along manifest]&lt;span&gt;#&lt;/span&gt;&lt;span&gt; vim cmd3.pp&lt;/span&gt;
package{&lt;span&gt;'&lt;/span&gt;&lt;span&gt;redis&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
        ensure &lt;/span&gt;=&amp;gt;&lt;span&gt; installed,
}

file{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/etc/redis.conf&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
        ensure  &lt;/span&gt;=&amp;gt;&lt;span&gt; file,
        source  &lt;/span&gt;=&amp;gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/root/manifest/files/redis.conf&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        owner   &lt;/span&gt;=&amp;gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;redis&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        group   &lt;/span&gt;=&amp;gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        mode    &lt;/span&gt;=&amp;gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;0640&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
}

&lt;/span&gt;&lt;span&gt;exec&lt;/span&gt;{&lt;span&gt;'&lt;/span&gt;&lt;span&gt;redis&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
        command &lt;/span&gt;=&amp;gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/usr/bin/systemctl start redis&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        refresh &lt;/span&gt;=&amp;gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/usr/bin/systemctl restart redis&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        user    &lt;/span&gt;=&amp;gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;redis&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        group   &lt;/span&gt;=&amp;gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;redis&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
}

Package[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;redis&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] -&amp;gt; File[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/etc/redis.conf&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] ~&amp;gt; Exec[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;redis&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;注意：当配置文件修改，触发动作，会执行&lt;/span&gt;refresh &lt;span&gt;命令替代&lt;/span&gt;&lt;span&gt;command&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;② &lt;span&gt;执行&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@along manifest]# vim files/redis.conf   把redis 端口修改为7777，再执行
port 7777
[root@along manifest]# puppet apply -v cmd3.pp
Notice: Compiled catalog for along in environment production in 0.38 seconds
Warning: The package type's allow_virtual parameter will be changing its default value from false to true in a future release. If you do not want to allow virtual packages, please explicitly set allow_virtual to false.
   (at /usr/share/ruby/vendor_ruby/puppet/type.rb:816:in `set_default')
Info: Applying configuration version '1550109397'
Notice: /Stage[main]/Main/Exec[redis]/returns: executed successfully
Notice: Finished catalog run in 0.12 seconds
[root@along manifest]# ss -nutlp |grep redis
tcp    LISTEN     0      128    127.0.0.1:7777                  *:*                   users:((&quot;redis-server&quot;,pid=4988,fd=4))
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;strong&gt;3.8 cron&lt;span&gt;：安装和管理&lt;/span&gt;&lt;span&gt;cron&lt;/span&gt;&lt;span&gt;作业&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　由&lt;/span&gt;Puppet&lt;span&gt;创建的每个&lt;/span&gt;&lt;span&gt;cron&lt;/span&gt;&lt;span&gt;资源都需要一个命令和至少一个周期属性&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;小时、分钟、月、月、工作日、或特殊&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;3.8.1 &lt;span&gt;类型属性选项&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt; command&lt;span&gt;：要执行的任务；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; ensure&lt;span&gt;：&lt;/span&gt;&lt;span&gt;present/absent&lt;/span&gt;&lt;span&gt;；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; hour&lt;span&gt;：&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; minute:&lt;/li&gt;
&lt;li&gt; monthday:&lt;/li&gt;
&lt;li&gt; month:&lt;/li&gt;
&lt;li&gt; weekday&lt;span&gt;：&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; user&lt;span&gt;：以哪个用户的身份运行命令&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; target&lt;span&gt;：添加为哪个用户的任务&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; name&lt;span&gt;：&lt;/span&gt;&lt;span&gt;cron job&lt;/span&gt;&lt;span&gt;的名称；&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1216496/201902/1216496-20190214113005903-707292165.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;&lt;strong&gt;3.8.2 &lt;span&gt;演示&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;① &lt;span&gt;编写&lt;/span&gt;&lt;span&gt;manifest&lt;/span&gt; &lt;span&gt;清单&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下载&lt;/span&gt;ntpdate&lt;span&gt;包，并制定计划任务，每隔&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;分钟同步一次时间&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
[root@along manifest]&lt;span&gt;#&lt;/span&gt;&lt;span&gt; vim cron.pp &lt;/span&gt;
package{&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ntpdate&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    ensure &lt;/span&gt;=&amp;gt;&lt;span&gt; installed,
}

cron{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;mysync&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
        command &lt;/span&gt;=&amp;gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/usr/sbin/ntpdate 192.168.10.1 &amp;amp;&amp;gt; /dec/null&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        ensure &lt;/span&gt;=&amp;gt;&lt;span&gt; present,
        minute &lt;/span&gt;=&amp;gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*/5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        target &lt;/span&gt;=&amp;gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;② &lt;span&gt;执行&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@along manifest]# puppet apply -v cron.pp
Notice: Compiled catalog for along in environment production in 0.29 seconds
Warning: The package type's allow_virtual parameter will be changing its default value from false to true in a future release. If you do not want to allow virtual packages, please explicitly set allow_virtual to false.
   (at /usr/share/ruby/vendor_ruby/puppet/type.rb:816:in `set_default')
Info: Applying configuration version '1550109974'
Notice: /Stage[main]/Main/Cron[mysync]/ensure: created
Notice: /Stage[main]/Main/Package[ntpdate]/ensure: created
Notice: Finished catalog run in 3.20 seconds
[root@along manifest]# crontab -l
# HEADER: This file was autogenerated at 2019-02-14 10:06:14 +0800 by puppet.
# HEADER: While it can still be managed manually, it is definitely not recommended.
# HEADER: Note particularly that the comments starting with 'Puppet Name' should
# HEADER: not be deleted, as doing so could cause duplicate cron jobs.
# Puppet Name: mysync
*/5 * * * * /usr/sbin/ntpdate 192.168.10.1 &amp;amp;&amp;gt; /dec/null
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;strong&gt;3.9 notify&lt;span&gt;：向代理运行时日志发送一个任意的消息&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;strong&gt;3.9.1 &lt;span&gt;类型属性选项&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt; message&lt;span&gt;：信息内容&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; name&lt;span&gt;：信息名称；&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;&lt;strong&gt;3.9.2 &lt;span&gt;演示&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
---编写manifest 清单
[root@along manifest]# vim notify.pp
notify{'syhi':
        message =&amp;gt; &quot;hi there.&quot;
}
---执行
[root@along manifest]# puppet apply -v notify.pp
Notice: Compiled catalog for along in environment production in 0.01 seconds
Info: Applying configuration version '1550110275'
Notice: hi there.
Notice: /Stage[main]/Main/Notify[syhi]/message: defined 'message' as 'hi there.'
Notice: Finished catalog run in 0.04 seconds
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;strong&gt;3.10 &lt;span&gt;非核心类型的常用资源：&lt;/span&gt;&lt;span&gt;yumrepo, host&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）&lt;/span&gt;&lt;span&gt;yumrepo&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;span&gt;yum&lt;/span&gt;&lt;span&gt;源&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1216496/201902/1216496-20190214113105357-1444295829.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;（&lt;/span&gt;2&lt;span&gt;）&lt;/span&gt;&lt;span&gt;host&lt;/span&gt;&lt;span&gt;：定义&lt;/span&gt;&lt;span&gt;/etc/hosts&lt;/span&gt; &lt;span&gt;中名字解析&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1216496/201902/1216496-20190214113116447-1719448305.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;4、资源的特殊属性&lt;/h2&gt;
&lt;h3&gt;&lt;strong&gt;4.1 &lt;span&gt;资源间依赖和通知关系&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;strong&gt;4.1.1 &lt;span&gt;依赖关系元参数：&lt;/span&gt;&lt;span&gt;before/require&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）格式：&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;中实现方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;① A &lt;strong&gt;before&lt;/strong&gt; B: B&lt;span&gt;依赖于&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;，定义在&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;资源中；&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    ...
    before    &lt;/span&gt;=&amp;gt; Type[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;],
    ...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; ② B &lt;strong&gt;require&lt;/strong&gt; A&lt;span&gt;：&lt;/span&gt; &lt;span&gt;B&lt;/span&gt;&lt;span&gt;依赖于&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;，定义在&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;资源中；&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    ...
    require    &lt;/span&gt;=&amp;gt; Type[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;],
    ...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; ③ A -&amp;gt; B&lt;span&gt;，&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;依赖于&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;（&lt;/span&gt;2&lt;span&gt;）注意：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;① before&lt;span&gt;、&lt;/span&gt; &lt;span&gt;require&lt;/span&gt; &lt;span&gt;和&lt;/span&gt; &lt;span&gt;-&amp;gt;&lt;/span&gt; &lt;span&gt;三者用其一即可&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;② &lt;span&gt;资源引用：&lt;/span&gt;&lt;span&gt;Type['title']&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;类型的&lt;/span&gt;&lt;strong&gt;&lt;span&gt;首字母必须大写&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;（&lt;/span&gt;3&lt;span&gt;）演示：创建一个用户，需要依赖一个组&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;① &lt;span&gt;创建&lt;/span&gt;&lt;span&gt;manifest&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
[root@along manifest]&lt;span&gt;#&lt;/span&gt;&lt;span&gt; vim user2.pp &lt;/span&gt;
[root@along manifest]&lt;span&gt;#&lt;/span&gt;&lt;span&gt; cat user2.pp&lt;/span&gt;
group{&lt;span&gt;'&lt;/span&gt;&lt;span&gt;redhat&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
        ensure &lt;/span&gt;=&amp;gt;&lt;span&gt; present,
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;       before =&amp;gt; User['ilinux'],  #方案1&lt;/span&gt;
&lt;span&gt;}

user{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ilinux&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
        ensure &lt;/span&gt;=&amp;gt;&lt;span&gt; present,
        comment &lt;/span&gt;=&amp;gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ilinux.io&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        groups &lt;/span&gt;=&amp;gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;redhat&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        require &lt;/span&gt;=&amp;gt; Group[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;redhat&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;],   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;方案2&lt;/span&gt;
&lt;span&gt;}

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;Group['redhat'] -&amp;gt; User['ilinux']   #方案3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;② &lt;span&gt;执行，先创建了组&lt;/span&gt;&lt;span&gt;redhat&lt;/span&gt;&lt;span&gt;，再创建了用户&lt;/span&gt;&lt;span&gt;ilinux&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@along manifest]# puppet apply -v user2.pp 
Notice: Compiled catalog for along in environment production in 0.14 seconds
Info: Applying configuration version '1550043297'
Notice: /Stage[main]/Main/Group[redhat]/ensure: created
Notice: /Stage[main]/Main/User[ilinux]/ensure: created
Notice: Finished catalog run in 0.12 seconds
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;&lt;strong&gt;4.1.2 &lt;span&gt;通知关系：通知相关的其它资源进行&lt;/span&gt;&lt;span&gt;“&lt;/span&gt;&lt;span&gt;刷新&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;span&gt;操作&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）格式：&lt;/span&gt;&lt;span&gt;notify/subscribe&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;① notify&lt;span&gt;：&lt;/span&gt;&lt;span&gt;A notify B&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;依赖于&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;，且&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;发生改变后会通知&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;；&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    ...
    notify &lt;/span&gt;=&amp;gt; Type[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;],
    ...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; ② subscribe&lt;span&gt;：&lt;/span&gt;&lt;span&gt;B subscribe A&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;依赖于&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;，且&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;监控&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;资源的变化产生的事件；&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    ...
    subscribe &lt;/span&gt;=&amp;gt; Type[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;],
    ...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; ③ A ~ B &lt;span&gt;，&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;依赖于&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;缩写版&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;（&lt;/span&gt;2&lt;span&gt;）实例：下载&lt;/span&gt;&lt;span&gt;redis&lt;/span&gt; &lt;span&gt;包，复制配置文件，启动&lt;/span&gt;&lt;span&gt;redis&lt;/span&gt; &lt;span&gt;服务&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;① &lt;span&gt;修改&lt;/span&gt;&lt;span&gt;srv3.pp manifest&lt;/span&gt; &lt;span&gt;清单&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
[root@along manifest]&lt;span&gt;#&lt;/span&gt;&lt;span&gt; vim srv3.pp&lt;/span&gt;
package{&lt;span&gt;'&lt;/span&gt;&lt;span&gt;redis&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
        ensure &lt;/span&gt;=&amp;gt;&lt;span&gt; installed,
}

file{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/etc/redis.conf&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
        ensure  &lt;/span&gt;=&amp;gt;&lt;span&gt; file,
        source  &lt;/span&gt;=&amp;gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/root/manifest/files/redis.conf&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        owner   &lt;/span&gt;=&amp;gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;redis&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        group   &lt;/span&gt;=&amp;gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        mode    &lt;/span&gt;=&amp;gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;0640&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;     notify    =&amp;gt; Service['redis']&lt;/span&gt;
&lt;span&gt;}

service{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;redis&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
        ensure  &lt;/span&gt;=&amp;gt;&lt;span&gt; running,
        enable  &lt;/span&gt;=&amp;gt;&lt;span&gt; false,
    hasrestart &lt;/span&gt;=&amp;gt;&lt;span&gt; true,
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;     subscribe =&amp;gt; File['/etc/redis.conf']&lt;/span&gt;
&lt;span&gt;}

Package[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;redis&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] -&amp;gt; File[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/etc/redis.conf&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] ~&amp;gt; Service[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;redis&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;② &lt;span&gt;执行&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@along manifest]# puppet apply -v --noop srv3.pp
[root@along manifest]# puppet apply -v srv3.pp 
Notice: Compiled catalog for along in environment production in 0.42 seconds
Warning: The package type's allow_virtual parameter will be changing its default value from false to true in a future release. If you do not want to allow virtual packages, please explicitly set allow_virtual to false.
   (at /usr/share/ruby/vendor_ruby/puppet/type.rb:816:in `set_default')
Info: Applying configuration version '1550046675'
Notice: /Stage[main]/Main/Package[redis]/ensure: created
Info: FileBucket got a duplicate file {md5}d98629fded012cd2a25b9db0599a9251
Info: /Stage[main]/Main/File[/etc/redis.conf]: Filebucketed /etc/redis.conf to puppet with sum d98629fded012cd2a25b9db0599a9251
Notice: /Stage[main]/Main/File[/etc/redis.conf]/content: content changed '{md5}d98629fded012cd2a25b9db0599a9251' to '{md5}d3fc0c22e1a90f88a895242b2a251dad'
Info: /Stage[main]/Main/File[/etc/redis.conf]: Scheduling refresh of Service[redis]
Notice: /Stage[main]/Main/Service[redis]/ensure: ensure changed 'stopped' to 'running'
Info: /Stage[main]/Main/Service[redis]: Unscheduling refresh on Service[redis]
Notice: Finished catalog run in 5.25 seconds
[root@along manifest]# ss -nutlp |grep redis
tcp    LISTEN     0      128    127.0.0.1:6300                  *:*                   users:((&quot;redis-server&quot;,pid=12492,fd=4))
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;③ &lt;span&gt;修改&lt;/span&gt; &lt;span&gt;/root/manifest/files/redis.conf  &lt;/span&gt;&lt;span&gt;把端口改为&lt;/span&gt;&lt;span&gt;6000&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@along manifest]# vim files/redis.conf
port 6000
[root@along manifest]# puppet apply -v srv3.pp    再执行，因为文件发生了修改，触发了重启服务，端口也确实改为了6000
Notice: Compiled catalog for along in environment production in 0.44 seconds
Warning: The package type's allow_virtual parameter will be changing its default value from false to true in a future release. If you do not want to allow virtual packages, please explicitly set allow_virtual to false.
   (at /usr/share/ruby/vendor_ruby/puppet/type.rb:816:in `set_default')
Info: Applying configuration version '1550046726'
Info: /Stage[main]/Main/File[/etc/redis.conf]: Filebucketed /etc/redis.conf to puppet with sum d3fc0c22e1a90f88a895242b2a251dad
Notice: /Stage[main]/Main/File[/etc/redis.conf]/content: content changed '{md5}d3fc0c22e1a90f88a895242b2a251dad' to '{md5}46e070a908eb1aca5c908e62dd4296b9'
Info: /Stage[main]/Main/File[/etc/redis.conf]: Scheduling refresh of Service[redis]
Notice: /Stage[main]/Main/Service[redis]: Triggered 'refresh' from 1 events
Notice: Finished catalog run in 0.23 seconds
[root@along manifest]# ss -nutlp |grep redis
tcp    LISTEN     0      128    127.0.0.1:6000                  *:*                   users:((&quot;redis-server&quot;,pid=12785,fd=4))
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;strong&gt;4.2 tag &lt;span&gt;标签&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　如同&lt;/span&gt; anssible &lt;span&gt;一样，&lt;/span&gt;&lt;span&gt;puppet&lt;/span&gt; &lt;span&gt;也可以定义&lt;/span&gt;&lt;span&gt;“&lt;/span&gt;&lt;span&gt;标签&lt;/span&gt;&lt;span&gt;”——tag&lt;/span&gt;&lt;span&gt;，打了标签以后，我们在运行资源的时候就可以只运行某个打过标签的部分，而非全部。这样就更方便于我们的操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一个资源中，可以有一个&lt;/span&gt;tag&lt;span&gt;也可以有多个。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）格式：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;资源定义：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
type{&lt;span&gt;'&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
　　...
　　tag &lt;/span&gt;=&amp;gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;TAG1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
}
type{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
　　...
　　tag &lt;/span&gt;=&amp;gt; [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;TAG1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;TAG2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,...],
}      &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; &lt;span&gt;手动调用：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
puppet apply --tags TAG1,TAG2,... FILE.PP
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;（&lt;/span&gt;2&lt;span&gt;）实例：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;① &lt;span&gt;创建&lt;/span&gt;&lt;span&gt;manifest&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@along manifest]# vim srv3.pp
package{'redis':
        ensure =&amp;gt; installed,
}

file{'/etc/redis.conf':
        ensure  =&amp;gt; file,
        source  =&amp;gt; '/root/manifests/files/redis.conf',
        owner   =&amp;gt; 'redis',
        group   =&amp;gt; 'root',
        mode    =&amp;gt; '0640',
        tag     =&amp;gt; 'conf'
}

service{'redis':
        ensure  =&amp;gt; running,
        enable  =&amp;gt; false,
        hasrestart =&amp;gt; true
}

Package['redis'] -&amp;gt; File['/etc/redis.conf'] ~&amp;gt; Service['redis']
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;② &lt;span&gt;执行&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
---先修改files配置文件端口为8888
[root@along manifest]# vim files/redis.conf
port 8888
---再执行
[root@along manifest]# puppet apply -v --tags conf srv3.pp
Notice: Compiled catalog for along in environment production in 0.44 seconds
Warning: The package type's allow_virtual parameter will be changing its default value from false to true in a future release. If you do not want to allow virtual packages, please explicitly set allow_virtual to false.
   (at /usr/share/ruby/vendor_ruby/puppet/type.rb:816:in `set_default')
Info: Applying configuration version '1550113147'
Info: /Stage[main]/Main/File[/etc/redis.conf]: Filebucketed /etc/redis.conf to puppet with sum fe60391ea96c958fe489f86002679ec3
Notice: /Stage[main]/Main/File[/etc/redis.conf]/content: content changed '{md5}fe60391ea96c958fe489f86002679ec3' to '{md5}cb214aa5ead0d70454d957ca9125ad01'
Info: /Stage[main]/Main/File[/etc/redis.conf]: Scheduling refresh of Service[redis]
Notice: /Stage[main]/Main/Service[redis]: Triggered 'refresh' from 1 events
Notice: Finished catalog run in 0.17 seconds
[root@along manifest]# grep &quot;port 8888&quot; /etc/redis.conf 
port 8888
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;5、puppet 变量&lt;/h2&gt;
&lt;p&gt;puppet 变量以“$”开头，赋值操作符为“=”，语法为$variable_name=value。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）数据类型：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt; &lt;span&gt;字符型：引号可有可无；但单引号为强引用，双引号为弱引用；支持转义符；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; &lt;span&gt;数值型：默认均识别为字符串，仅在数值上下文才以数值对待；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; &lt;span&gt;数组：&lt;/span&gt;[]&lt;span&gt;中以逗号分隔元素列表；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; &lt;span&gt;布尔型值：&lt;/span&gt;true, false&lt;span&gt;；不能加引号；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; hash&lt;span&gt;：&lt;/span&gt;&lt;span&gt;{}&lt;/span&gt;&lt;span&gt;中以逗号分隔&lt;/span&gt;&lt;span&gt;k/v&lt;/span&gt;&lt;span&gt;数据列表； 键为字符型，值为任意&lt;/span&gt;&lt;span&gt;puppet&lt;/span&gt;&lt;span&gt;支持的类型；&lt;/span&gt;&lt;span&gt;{ ‘mon’ =&amp;gt; ‘Monday’, ‘tue’ =&amp;gt; ‘Tuesday’, }&lt;/span&gt;&lt;span&gt;；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; undef&lt;span&gt;：从未被声明的变量的值类型；&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;2&lt;span&gt;）正则表达式：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
　　(?&amp;lt;ENABLED OPTION&amp;gt;:&amp;lt;PATTERN&amp;gt;&lt;span&gt;)
　　(?&lt;/span&gt;-&amp;lt;DISABLED OPTION&amp;gt;:&amp;lt;PATTERN&amp;gt;&lt;span&gt;)
　　OPTIONS：
　　　　i：忽略字符大小写；
　　　　m：把.当换行符；
　　　　x：忽略&lt;/span&gt;&amp;lt;PATTERN&amp;gt;中的空白字符；
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;注意：不能赋值给变量，仅能用在接受&lt;/span&gt;=~&lt;span&gt;或&lt;/span&gt;&lt;span&gt;!~&lt;/span&gt;&lt;span&gt;操作符的位置；&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;（&lt;/span&gt;3&lt;span&gt;）&lt;/span&gt;&lt;span&gt;puppet&lt;/span&gt;&lt;span&gt;的变量种类&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;puppet &lt;span&gt;种类有三种，为&lt;/span&gt;&lt;span&gt;facts&lt;/span&gt;&lt;span&gt;，内建变量和用户自定义变量。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt; facts&lt;span&gt;：&lt;/span&gt;
&lt;ul&gt;&lt;li&gt; &lt;span&gt;由&lt;/span&gt;facter&lt;span&gt;提供；&lt;/span&gt;&lt;span&gt;top scope&lt;/span&gt;&lt;span&gt;；&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt; &lt;span&gt;内建变量：&lt;/span&gt;
&lt;ul&gt;&lt;li&gt; master&lt;span&gt;端变量：&lt;/span&gt;&lt;span&gt;$servername, $serverip, $serverversion&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; agent&lt;span&gt;端变量：&lt;/span&gt;&lt;span&gt;$clientcert, $clientversion, $environment&lt;/span&gt;&lt;span&gt;　&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; parser&lt;span&gt;变量&lt;/span&gt;&lt;span&gt;:$module_name&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt; &lt;span&gt;用户自定义变量&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;4&lt;span&gt;）变量的作用域&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt; &lt;span&gt;不同的变量也有其不同的作用域。我们称之为&lt;/span&gt;Scope&lt;span&gt;。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; &lt;span&gt;作用域有三种，&lt;/span&gt;top scope&lt;span&gt;，&lt;/span&gt;&lt;span&gt;node scope&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;class scope&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; &lt;span&gt;其生效范围排序为：&lt;/span&gt;top scope &amp;gt; node scope &amp;gt; class scope&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1216496/201902/1216496-20190214113435675-899383428.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其优先级排序为：&lt;/span&gt;top scope &amp;lt; node scope &amp;lt; class scope&lt;/p&gt;

</description>
<pubDate>Thu, 14 Feb 2019 05:18:00 +0000</pubDate>
<dc:creator>alonghub</dc:creator>
<og:description>1、认识puppet 1.1 引入 puppet是什么，咱们先不用专业的名词解释它，咱们先描述一些工作场景，看明白这些工作场景，自然会知道puppet是什么。 （1）场景一： 管理员想要在100台服务</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/along21/p/10369858.html</dc:identifier>
</item>
<item>
<title>Centos7 nginx 虚拟主机、反向代理服务器及负载均衡，多台主机分离php-fpm实验 - 乐章</title>
<link>http://www.cnblogs.com/zhangxingeng/p/10330735.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangxingeng/p/10330735.html</guid>
<description>&lt;p&gt;　　本章介绍一些架构原理基础知识，&lt;/p&gt;
&lt;p&gt;　&lt;strong&gt;　1.1、LNMP及php-fpm&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　请参考https://www.cnblogs.com/zhangxingeng/p/10242902.html&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;1.2、透明代理、反向代理，正向代理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　请参考https://www.cnblogs.com/zhangxingeng/p/10331318.html&lt;/p&gt;
&lt;p&gt;　　　　贴一张架构图&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1464965/201901/1464965-20190129161722873-318804823.jpg&quot; alt=&quot;&quot; width=&quot;763&quot; height=&quot;334&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;　　1.3、实现反向代理配置&lt;/h4&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;server{
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     listen &lt;span&gt;80&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     location /&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         proxy_pass http:&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;216.52&lt;/span&gt;:&lt;span&gt;8080&lt;/span&gt;&lt;span&gt; #上游的应用服务器
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; 
&lt;span&gt;6&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;　　1.4、负载均衡&lt;/h4&gt;
&lt;p&gt;　　nginx通过反代可以实现负载均衡的效果，上面是通过反向代理实现负载，所以nginx实现的是七层负载均衡，它能够识别http协议，根据http报文将不同类型的请求转发到不同的后端web服务器上，后端的web服务器称为“上游服务器”，即upstream服务器。架构图和上面类似配置如下：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;upstream myweb{
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     server &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;216.53&lt;/span&gt;:&lt;span&gt;8080&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     server &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;216.54&lt;/span&gt;:&lt;span&gt;8080&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;server {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     listen &lt;span&gt;80&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     location /&lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         proxy_pass http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;myweb;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;　　1.5、nginx的反向代理有几种实现方式：&lt;/h4&gt;
&lt;p&gt;　　　　1）仅使用模块ngx_http_proxy_module实现简单的反向代理，指令为proxy_pass。&lt;/p&gt;
&lt;p&gt;　　　　2）使用fastcgi模块提供的功能，反向代理动态内容，指令为fastcgi_pass。&lt;/p&gt;
&lt;p&gt;　　　　3）使用ngx_http_memcached_module模块提供的功能，反向代理mencache缓存内容，指令为memcached_pass。&lt;/p&gt;
&lt;p&gt;　　　　4）结合upstream模块实现更人性化的分组反向代理。　　&lt;/p&gt;
&lt;p&gt;             1.4.1、注意fastcgi_pass与proxy_pass的区别&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1464965/201901/1464965-20190130172546680-622240372.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;　　1.6、虚拟主机&lt;/h4&gt;
&lt;p&gt;　　　　有的网站访问量大，需要负载，然而病逝所有网站都需要，对于访问量太小的可以将多个网站部署再同一台服务器上，比如你可以把www.test1.com 和www.test2.com两个网站部署再同一个服务器上，两个域名解析到同一个ip地址，但是用户通过两个域名却可以打开两个完全不同的网站，互相不影响，就像访问两个服务器一样&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;server {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     listen &lt;span&gt;80&lt;/span&gt;&lt;span&gt; default_server;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    server_name;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     return &lt;span&gt;444&lt;/span&gt;&lt;span&gt;; #过滤其他域名的请求，返回444状态码
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;server {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     
&lt;span&gt; 9&lt;/span&gt;     listen &lt;span&gt;80&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    server_name www.test1.com;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     location /&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         proxy_pass http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:8080&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;server {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     listen &lt;span&gt;80&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    server_name www.test2.com;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     location /&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         proxy_pass http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:8081;&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;　　2.1、配置简单的反代实验&lt;/h4&gt;
&lt;p&gt; 　　　　2.1.1、架构&lt;/p&gt;
&lt;p&gt;　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1464965/201901/1464965-20190131174658829-1786780973.jpg&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;　　反向代理配置挺简单的，nginx-proxy(192.168.216.51)的配置不需要root、index等指令，只需要几个和代理相关的指令即可&lt;/p&gt;
&lt;h4&gt;　　 2.2、部署web1-51，的反向代理配置&lt;/h4&gt;
&lt;p&gt;　　　　yum install nginx -y&lt;/p&gt;
&lt;p&gt;　　修改配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@www ~]# &lt;span&gt;cat&lt;/span&gt; /etc/nginx/conf.d/&lt;span&gt;default.conf 
server {
        listen  &lt;/span&gt;&lt;span&gt;80&lt;/span&gt;&lt;span&gt;;
        server_name www.web1.com;
        location &lt;/span&gt;~ \.(png|jpg|jpeg|bmp|&lt;span&gt;gif)$ {
                proxy_pass http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;192.168.216.53:80;&lt;/span&gt;
&lt;span&gt;        }

        location &lt;/span&gt;/&lt;span&gt; {
                proxy_pass http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;192.168.216.54:80;&lt;/span&gt;
&lt;span&gt;        }

        location &lt;/span&gt;~ \.(php|&lt;span&gt;php5)$ {
                proxy_pass http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;192.168.216.52:80;&lt;/span&gt;
&lt;span&gt;        }

        error_page &lt;/span&gt;&lt;span&gt;500&lt;/span&gt; &lt;span&gt;502&lt;/span&gt; &lt;span&gt;503&lt;/span&gt; &lt;span&gt;504&lt;/span&gt; /&lt;span&gt;50x.html;
        location &lt;/span&gt;= /&lt;span&gt;50x.html {
                root html;
        }
}
[root@www &lt;/span&gt;~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;　　2.3、部署web3，图片服务器&lt;/h4&gt;
&lt;p&gt;　　安装httpd服务&lt;/p&gt;
&lt;p&gt;　　yum install -y httpd&lt;/p&gt;
&lt;p&gt;　　放两张图片后启动服务&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; [root@www html]# &lt;span&gt;pwd&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; /var/www/&lt;span&gt;html
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;[root@www html]# ll 
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; total &lt;span&gt;340&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; -rw-r--r--. &lt;span&gt;1&lt;/span&gt; root root &lt;span&gt;320660&lt;/span&gt; Jun  &lt;span&gt;7&lt;/span&gt;  &lt;span&gt;2018&lt;/span&gt; &lt;span&gt;123&lt;/span&gt;&lt;span&gt;.jpg
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; -rw-r--r--. &lt;span&gt;1&lt;/span&gt; root root  &lt;span&gt;21177&lt;/span&gt; Feb &lt;span&gt;13&lt;/span&gt; &lt;span&gt;12&lt;/span&gt;:&lt;span&gt;45&lt;/span&gt; &lt;span&gt;345&lt;/span&gt;&lt;span&gt;.jpg
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; [root@www html]# systemctl restart httpd
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　验证，出错只显示一个小方块浏览器f12查看一下，文件大小明显不对，查看preview也不正常， 重新上传解决&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1464965/201902/1464965-20190213155626215-134238554.jpg&quot; alt=&quot;&quot; width=&quot;724&quot; height=&quot;428&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1464965/201902/1464965-20190213160241497-1021720131.jpg&quot; alt=&quot;&quot; width=&quot;731&quot; height=&quot;527&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1464965/201902/1464965-20190213160500733-1642199090.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　正确效果图如下&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1464965/201902/1464965-20190213160543723-762981525.jpg&quot; alt=&quot;&quot; width=&quot;773&quot; height=&quot;866&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;　　2.3、web4部署静态服务器，同样是httpd&lt;/h4&gt;
&lt;p&gt;　　web4-54&lt;/p&gt;
&lt;p&gt;　　yum install -y httpd&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; [root@web4 html]# &lt;span&gt;pwd&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; /var/www/&lt;span&gt;html
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; [root@web4 html]# &lt;span&gt;cat&lt;/span&gt;&lt;span&gt; index.html 
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;hi,this is web4,static
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; [root@web4 html]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　systemctl restart httpd&lt;/p&gt;
&lt;p&gt;　　查看一下效果，没问题，下面部署nginx+php-fpm&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1464965/201902/1464965-20190213160746833-1972155276.jpg&quot; alt=&quot;&quot; width=&quot;826&quot; height=&quot;223&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;　　2.3、部署nginx+php-fpm&lt;/h4&gt;
&lt;p&gt;　　两台分离部署&lt;/p&gt;

&lt;p&gt;　　2.3.1、web2-52 &lt;/p&gt;
&lt;p&gt;　　yum install nginx -y &lt;/p&gt;
&lt;p&gt;　　配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; [root@web2 html]# vim /etc/nginx/conf.d/&lt;span&gt;default.conf 
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;server {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         listen &lt;span&gt;80&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         server_name &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;216.52&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        index index.html index.htm index.phpi;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         root /www/&lt;span&gt;web;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         location /&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;                 root /usr/share/nginx/&lt;span&gt;html;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;         location ~.*&lt;span&gt;\.php$ {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;                 fastcgi_pass    &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;216.55&lt;/span&gt;:&lt;span&gt;9000&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;                fastcgi_index   index.php;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;                fastcgi_param   SCRIPT_FILENAME $document_root$fastcgi_script_name;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;                include         fastcgi_params;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　systemctl restart nginx&lt;/p&gt;

&lt;p&gt;　　2.3.2、web5-55&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;  &lt;span&gt;yum&lt;/span&gt; &lt;span&gt;install&lt;/span&gt; -y php php-devel php-fpm php-mysql php-common php-devel php-gd libjpeg* php-imap php-ldap php-odbc php-pear php-xml php-xmlrpc php-mbstring php-mcrypt php-bcmath php-mhash libmcrypt libmcrypt-devel
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
vim   /etc/php-fpm.d/&lt;span&gt;www.conf 

listen &lt;/span&gt;= &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;216.55&lt;/span&gt;:&lt;span&gt;9000&lt;/span&gt;&lt;span&gt;

listen.owner &lt;/span&gt;=&lt;span&gt; nobody
listen.group &lt;/span&gt;=&lt;span&gt; nobody

user &lt;/span&gt;=&lt;span&gt; nginx

group &lt;/span&gt;= nginx
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;  &lt;span&gt;mkdir&lt;/span&gt; -p /www/web/
&lt;span&gt;2&lt;/span&gt;  group -g &lt;span&gt;983&lt;/span&gt;&lt;span&gt; nginx
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;  groupadd -g &lt;span&gt;983&lt;/span&gt;&lt;span&gt; nginx
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;  useradd -u &lt;span&gt;983&lt;/span&gt; -&lt;span&gt;g nginx nginx
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; 
&lt;span&gt;6&lt;/span&gt; &lt;span&gt;chown&lt;/span&gt; -R nginx:nginx /www
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　准备phpinfo文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;[root@web5 web]# ll 
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; total &lt;span&gt;4&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; -rwxrwxrwx &lt;span&gt;1&lt;/span&gt; nginx nginx &lt;span&gt;21&lt;/span&gt; Feb &lt;span&gt;12&lt;/span&gt; &lt;span&gt;12&lt;/span&gt;:&lt;span&gt;35&lt;/span&gt;&lt;span&gt; index.php
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; [root@web5 web]# &lt;span&gt;cat&lt;/span&gt;&lt;span&gt; index.php 
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &amp;lt;?&lt;span&gt;php
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;        phpinfo();
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; ?&amp;gt;
&lt;span&gt;8&lt;/span&gt; [root@web5 web]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　注意：如果测试结果为不运行php，下载php得话，应该是nginx配置文件目录配置不当造成得&lt;/p&gt;
&lt;p&gt; 　 检查结果，成功&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1464965/201902/1464965-20190214114601987-1573617910.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;　　2.4、负载均衡配置&lt;/h4&gt;
&lt;p&gt;　　　　这个实验得负载均衡再nginx主机负载php请求，做两个php-fpm的负载均衡&lt;/p&gt;
&lt;p&gt;　　修改web2-52的nginx配置文件&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; [root@web2 web]# &lt;span&gt;cat&lt;/span&gt; /etc/nginx/conf.d/&lt;span&gt;default.conf 
&lt;/span&gt;&lt;span&gt; 2 upstream php-cluster {
 3         server 127.0.0.1:9000 max_fails=3 fail_timeout=10s;
 4         server 192.168.216.55:9000 max_fails=3 fail_timeout=10s;
 5         }
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;server {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         listen &lt;span&gt;80&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         server_name &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;216.52&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        index index.html index.htm index.phpi;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         root /www/&lt;span&gt;web;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         location /&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;                 root /usr/share/nginx/&lt;span&gt;html;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;         location ~.*&lt;span&gt;\.php$ {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;                 &lt;span&gt;fastcgi_pass    php-cluster;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;                fastcgi_index   index.php;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;                fastcgi_param   SCRIPT_FILENAME $document_root$fastcgi_script_name;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;                include         fastcgi_params;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; [root@web2 web]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　并且安装php，php-fpm&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;  &lt;span&gt;yum&lt;/span&gt; &lt;span&gt;install&lt;/span&gt; -y php php-devel php-fpm php-mysql php-common php-devel php-gd libjpeg* php-imap php-ldap php-odbc php-pear php-xml php-xmlrpc php-mbstring php-mcrypt php-bcmath php-mhash libmcrypt libmcrypt-devel
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　配置php-fpm配置文件&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; [root@web2 web]# vim /etc/php-fpm.d/&lt;span&gt;www.conf 
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; listen = &lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;9000&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; listen.owner =&lt;span&gt; nobody
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; listen.group =&lt;span&gt; nobody
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; user =&lt;span&gt; nginx
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; group = nginx
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　创建index.php文件&lt;/p&gt;
&lt;p&gt;　　mkdir -p /www/web&lt;/p&gt;
&lt;p&gt;　　vim /www/web/index.php&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; [root@web2 web]# &lt;span&gt;cat&lt;/span&gt;&lt;span&gt; index.php 
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &amp;lt;?&lt;span&gt;php
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;        &lt;span&gt; echo (&quot;52&quot;);　　#输出52，测试的时候容易分辨
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;        phpinfo();
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; ?&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　web5-55同样输出55&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;[root@web5 web]# vim index.php 
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt; &amp;lt;?&lt;span&gt;php
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;echo&lt;/span&gt; (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;        phpinfo();
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; ?&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　好了，重启服务测试一把&lt;/p&gt;
&lt;p&gt;　　systemctl restart nginx 　　#web2&lt;/p&gt;
&lt;p&gt;　　systemctl restart php-fpm　　#web2与web5&lt;/p&gt;
&lt;p&gt;　　测试效果如下&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1464965/201902/1464965-20190214124511154-961249972.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　刷新浏览器&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1464965/201902/1464965-20190214124554207-1773075550.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;转载请注明出处：https://www.cnblogs.com/zhangxingeng/p/10330735.html&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7657493.html&quot;&gt;&lt;br/&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 14 Feb 2019 04:50:00 +0000</pubDate>
<dc:creator>乐章</dc:creator>
<og:description>一、简介 本章介绍一些架构原理基础知识， 1.1、LNMP及php-fpm 请参考https://www.cnblogs.com/zhangxingeng/p/10242902.html 1.2、透明</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhangxingeng/p/10330735.html</dc:identifier>
</item>
<item>
<title>Redis之集群环境搭建 - ゞ .邓澎波</title>
<link>http://www.cnblogs.com/dengpengbo/p/10373911.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dengpengbo/p/10373911.html</guid>
<description>&lt;p&gt;前面文章介绍了Redis的主从复制，虽然该模式能够在一定程度上提高系统的稳定性，但是在数据访问量比较大的情况下，单个master应付起来还是比较吃力的，这时我们可以考虑将redis集群部署，本文就来重点给大家介绍下Redis的集群部署操作。&lt;br/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_38526573/article/details/87185691&quot;&gt;Redis之主从复制2&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/qq_38526573/article/details/87181647&quot;&gt;Redis之主从复制1&lt;/a&gt;&lt;br/&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;h2 id=&quot;一redis集群相关概念&quot;&gt;一、Redis集群相关概念&lt;/h2&gt;
&lt;h3 id=&quot;redis集群介绍&quot;&gt;1.Redis集群介绍&lt;/h3&gt;
&lt;p&gt;Redis 集群是一个提供在&lt;strong&gt;多个Redis间节点间&lt;/strong&gt;共享数据的程序集。&lt;/p&gt;
&lt;p&gt;Redis集群&lt;strong&gt;并不支持&lt;/strong&gt;处理多个keys的命令,因为这需要在不同的节点间移动数据,从而达不到像Redis那样的性能,在高负载的情况下可能会导致不可预料的错误.&lt;/p&gt;
&lt;p&gt;Redis 集群通过&lt;strong&gt;分区&lt;/strong&gt;来提供一定程度的可用性,在实际环境中当某个节点宕机或者不可达的情况下继续处理命令. Redis 集群的优势:&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;1.自动分割数据到不同的节点上。&lt;br/&gt;&amp;gt;2.整个集群的部分节点失败或者不可达的情况下能够继续处理命令。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;redis分片策略&quot;&gt;2.Redis分片策略&lt;/h3&gt;
&lt;p&gt;Redis 集群没有使用一致性hash, 而是引入了 哈希槽的概念.&lt;/p&gt;
&lt;p&gt;Redis 集群有==16384==个哈希槽,每个key通过CRC16校验后对16384取模来决定放置哪个槽.集群的每个节点负责一部分hash槽,举个例子,比如当前集群有3个节点,那么:&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;节点 A 包含 0 到 5500号哈希槽.&lt;br/&gt;节点 B 包含5501 到 11000 号哈希槽.&lt;br/&gt;节点 C 包含11001 到 16384号哈希槽.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这种结构很容易添加或者删除节点. 比如如果我想新添加个节点D, 我需要从节点 A, B, C中得部分槽到D上. 如果我想移除节点A,需要将A中的槽移到B和C节点上,然后将没有任何槽的A节点从集群中移除即可. 由于从一个节点将哈希槽移动到另一个节点并不会停止服务,所以无论添加删除或者改变某个节点的哈希槽的数量都不会造成集群不可用的状态.&lt;/p&gt;
&lt;h3 id=&quot;redis的主从复制模型&quot;&gt;3.Redis的主从复制模型&lt;/h3&gt;
&lt;p&gt;为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主从复制模型,每个节点都会有N-1个复制品.&lt;/p&gt;
&lt;p&gt;在我们例子中具有A，B，C三个节点的集群,在没有复制模型的情况下,如果节点B失败了，那么整个集群就会以为缺少5501-11000这个范围的槽而不可用.&lt;/p&gt;
&lt;p&gt;然而如果在集群创建的时候（或者过一段时间）我们为每个节点添加一个从节点A1，B1，C1,那么整个集群便有三个master节点和三个slave节点组成，这样在节点B失败后，集群便会选举B1为新的主节点继续服务，整个集群便不会因为槽找不到而不可用了&lt;/p&gt;
&lt;p&gt;不过当B和B1 都失败后，集群是不可用的.&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190213234127831.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTcz,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;二redis集群搭建&quot;&gt;二、Redis集群搭建&lt;/h2&gt;
&lt;h3 id=&quot;集群的结构&quot;&gt;1.集群的结构&lt;/h3&gt;
&lt;p&gt;根据官网描述要让redis集群环境正常运行我们必须准备至少3个主节点，所以在本文中的集群环境我们准备3个主节点实例及对应的给每个主节点准备一个从节点实例，一共6个redis实例。正常需要6个虚拟机节点，本文我们在一个虚拟机上模拟。&lt;/p&gt;
&lt;h3 id=&quot;集群的环境准备&quot;&gt;2.集群的环境准备&lt;/h3&gt;
&lt;p&gt;搭建集群需要使用到官方提供的ruby脚本。&lt;br/&gt;需要安装ruby的环境。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;安装ruby&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;yum -y install ruby
yum -y install rubygems
gem install redis&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;错误处理&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;[root@hadoop-node01 src]# gem install redis
ERROR:  Error installing redis:
    redis requires Ruby version &amp;gt;= 2.2.2.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解决方式参考此链接:https://blog.csdn.net/qq_38526573/article/details/87220510&lt;/p&gt;
&lt;p&gt;解决完成后再次执行gem install redis命令&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;[root@hadoop-node01 ~]# gem install redis
Fetching: redis-4.1.0.gem (100%)
Successfully installed redis-4.1.0
Parsing documentation for redis-4.1.0
Installing ri documentation for redis-4.1.0
Done installing documentation for redis after 1 seconds
1 gem installed&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意ruby对应的redis版本是4.1.0&lt;br/&gt;各版本下载地址&lt;br/&gt;http://download.redis.io/releases/&lt;/p&gt;
&lt;h3 id=&quot;搭建集群环境&quot;&gt;3.搭建集群环境&lt;/h3&gt;
&lt;h4 id=&quot;创建实例&quot;&gt;3.1创建实例&lt;/h4&gt;
&lt;p&gt;在/opt目录下创建redis-cluster目录，并在该目录下创建6个redis实例&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190214010038543.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190214010103410.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTcz,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;修改配置文件&quot;&gt;3.2修改配置文件&lt;/h4&gt;
&lt;p&gt;分别修改6个实例的配置文件&lt;/p&gt;
&lt;h5 id=&quot;修改端口号&quot;&gt;1.修改端口号&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190214010721655.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;打开cluster-enable前面的注释&quot;&gt;2.打开cluster-enable前面的注释&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2019021401080048.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;注释掉绑定ip&quot;&gt;3.注释掉绑定ip&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2019021401083059.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTcz,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;保护模式修改为no&quot;&gt;4.保护模式修改为no&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190214010908533.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTcz,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;设置日志存储路径&quot;&gt;5.设置日志存储路径&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190214102308154.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;注意重复修改6次。&lt;/p&gt;
&lt;h4 id=&quot;复制ruby脚本&quot;&gt;3.3复制ruby脚本&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190214012146184.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTcz,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;启动6个实例&quot;&gt;3.4启动6个实例&lt;/h4&gt;
&lt;p&gt;启动实例时可能报错&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;Ps: [ERR] Node 172.168.63.202:7001 is not empty. Either the nodealready knows other nodes (check with CLUSTER NODES) or contains some&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解决办法：&lt;br/&gt;将每个节点下aof、rdb、nodes.conf本地备份文件删除；&lt;/p&gt;
&lt;p&gt;编写简单脚本启动&lt;br/&gt;start-all.sh&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;cd /opt/redis-cluster/redis7001
rm -rf dump.rdb nodes.conf appendonly.aof
src/redis-server redis.conf

cd /opt/redis-cluster/redis7002
rm -rf dump.rdb nodes.conf appendonly.aof
src/redis-server redis.conf

cd /opt/redis-cluster/redis7003
rm -rf dump.rdb nodes.conf appendonly.aof
src/redis-server redis.conf

cd /opt/redis-cluster/redis7004
rm -rf dump.rdb nodes.conf appendonly.aof
src/redis-server redis.conf

cd /opt/redis-cluster/redis7005
rm -rf dump.rdb nodes.conf appendonly.aof
src/redis-server redis.conf

cd /opt/redis-cluster/redis7006
rm -rf dump.rdb nodes.conf appendonly.aof
src/redis-server redis.conf&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;改变文件脚本权限模式:&lt;br/&gt;chmod 777 start-all.sh&lt;br/&gt;然后再启动:&lt;br/&gt;./start-all.sh&lt;/p&gt;
&lt;h4 id=&quot;创建集群&quot;&gt;3.5创建集群&lt;/h4&gt;
&lt;p&gt;现在我们已经有了六个正在运行中的 Redis 实例， 接下来我们需要使用这些实例来创建集群， 并为每个节点编写配置文件。&lt;/p&gt;
&lt;p&gt;通过使用 Redis 集群命令行工具 redis-trib ， 编写节点配置文件的工作可以非常容易地完成： redis-trib 位于 Redis 源码的 src 文件夹中， 它是一个 Ruby 程序， 这个程序通过向实例发送特殊命令来完成创建新集群， 检查集群， 或者对集群进行重新分片（reshared）等工作&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;./redis-trib.rb create --replicas 1 192.168.88.121:7001 192.168.88.121:7002 192.168.88.121:7003 192.168.88.121:7004 192.168.88.121:7005 192.168.88.121:7006&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;命令说明&lt;br/&gt;选项–replicas 1 表示我们希望为集群中的每个主节点创建一个从节点&lt;br/&gt;之后跟着的其他参数则是这个集群实例的地址列表,3个master3个slave&lt;br/&gt;redis-trib 会打印出一份预想中的配置给你看， 如果你觉得没问题的话， 就可以输入 ==yes==， redis-trib 就会将这份配置应用到集群当中,让各个节点开始互相通讯,最后可以得到如下信息：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;[root@hadoop-node01 redis-cluster]# ./redis-trib.rb create --replicas 1 192.168.88.121:7001
 192.168.88.121:7002 192.168.88.121:7003 192.168.88.121:7004 192.168.88.121:7005 192.168&amp;gt;&amp;gt;&amp;gt; Creating cluster
Invalid IP or Port (given as 192.168) - use IP:Port format
[root@hadoop-node01 redis-cluster]# ./redis-trib.rb create --replicas 1 192.168.88.121:7001
 192.168.88.121:7002 192.168.88.121:7003 192.168.88.121:7004 192.168.88.121:7005 192.168.88.121:7006&amp;gt;&amp;gt;&amp;gt; Creating cluster
&amp;gt;&amp;gt;&amp;gt; Performing hash slots allocation on 6 nodes...
Using 3 masters:
192.168.88.121:7001
192.168.88.121:7002
192.168.88.121:7003
Adding replica 192.168.88.121:7005 to 192.168.88.121:7001
Adding replica 192.168.88.121:7006 to 192.168.88.121:7002
Adding replica 192.168.88.121:7004 to 192.168.88.121:7003
&amp;gt;&amp;gt;&amp;gt; Trying to optimize slaves allocation for anti-affinity
[WARNING] Some slaves are in the same host as their master
M: f97aa0b15e5a7f51c69f26543e7b785d52479afe 192.168.88.121:7001
   slots:0-5460 (5461 slots) master
M: 8e4a66caac1f738e9d951d212a5ba2a00e675acd 192.168.88.121:7002
   slots:5461-10922 (5462 slots) master
M: 1528779486cb926b11cb996c5682c6b749d26bc1 192.168.88.121:7003
   slots:10923-16383 (5461 slots) master
S: ea08ca738d621c5161a0ecfe838ed8fd89f5c0c5 192.168.88.121:7004
   replicates 8e4a66caac1f738e9d951d212a5ba2a00e675acd
S: 0ac234a10f28e24173ffc4e686073fa7710dd264 192.168.88.121:7005
   replicates 1528779486cb926b11cb996c5682c6b749d26bc1
S: d560e0e3da9a715fb4aae5910cf5533cec2f815f 192.168.88.121:7006
   replicates f97aa0b15e5a7f51c69f26543e7b785d52479afe
Can I set the above configuration? (type 'yes' to accept): yes
&amp;gt;&amp;gt;&amp;gt; Nodes configuration updated
&amp;gt;&amp;gt;&amp;gt; Assign a different config epoch to each node
&amp;gt;&amp;gt;&amp;gt; Sending CLUSTER MEET messages to join the cluster
Waiting for the cluster to join......
&amp;gt;&amp;gt;&amp;gt; Performing Cluster Check (using node 192.168.88.121:7001)
M: f97aa0b15e5a7f51c69f26543e7b785d52479afe 192.168.88.121:7001
   slots:0-5460 (5461 slots) master
   1 additional replica(s)
S: d560e0e3da9a715fb4aae5910cf5533cec2f815f 192.168.88.121:7006
   slots: (0 slots) slave
   replicates f97aa0b15e5a7f51c69f26543e7b785d52479afe
M: 1528779486cb926b11cb996c5682c6b749d26bc1 192.168.88.121:7003
   slots:10923-16383 (5461 slots) master
   1 additional replica(s)
M: 8e4a66caac1f738e9d951d212a5ba2a00e675acd 192.168.88.121:7002
   slots:5461-10922 (5462 slots) master
   1 additional replica(s)
S: 0ac234a10f28e24173ffc4e686073fa7710dd264 192.168.88.121:7005
   slots: (0 slots) slave
   replicates 1528779486cb926b11cb996c5682c6b749d26bc1
S: ea08ca738d621c5161a0ecfe838ed8fd89f5c0c5 192.168.88.121:7004
   slots: (0 slots) slave
   replicates 8e4a66caac1f738e9d951d212a5ba2a00e675acd
[OK] All nodes agree about slots configuration.
&amp;gt;&amp;gt;&amp;gt; Check for open slots...
&amp;gt;&amp;gt;&amp;gt; Check slots coverage...
[OK] All 16384 slots covered.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2019021411241520.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTcz,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这表示集群中的 16384 个槽都有至少一个主节点在处理， 集群运作正常。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2019021411250868.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTcz,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;测试集群&quot;&gt;4.测试集群&lt;/h3&gt;
&lt;p&gt;登录命令&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;redis7001/src/redis-cli -h 192.168.88.121 -p 7001 -c&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190214113032273.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTcz,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;添加一个key被分配到7002节点上，注意连接的端口变为了7002。&lt;/p&gt;
&lt;h3 id=&quot;查看集群环境&quot;&gt;5.查看集群环境&lt;/h3&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;24&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;cluster info&lt;/td&gt;
&lt;td&gt;打印集群的信息&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;cluster nodes&lt;/td&gt;
&lt;td&gt;列出集群当前已知的所有节点（ node），以及这些节点的相关信息。节点&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;cluster meet &amp;lt;ip&amp;gt; &amp;lt;port&amp;gt;&lt;/td&gt;
&lt;td&gt;将 ip 和 port 所指定的节点添加到集群当中，让它成为集群的一份子。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;cluster forget&lt;/td&gt;
&lt;td&gt;从集群中移除 node_id 指定的节点。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;cluster replicate&lt;/td&gt;
&lt;td&gt;将当前节点设置为 node_id 指定的节点的从节点。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;cluster saveconfig&lt;/td&gt;
&lt;td&gt;将节点的配置文件保存到硬盘里面。槽(slot)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;cluster addslots&lt;br/&gt;&amp;lt;slot&amp;gt; [slot ...]&lt;/td&gt;
&lt;td&gt;将一个或多个槽（ slot）指派（ assign）给当前节点。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;cluster delslots&lt;br/&gt;&amp;lt;slot&amp;gt; [slot ...]&lt;/td&gt;
&lt;td&gt;移除一个或多个槽对当前节点的指派。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;cluster flushslots&lt;/td&gt;
&lt;td&gt;移除指派给当前节点的所有槽，让当前节点变成一个没有指派任何槽的节点。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;cluster setslot&lt;br/&gt;&amp;lt;slot&amp;gt; node &amp;lt;node_id&amp;gt;&lt;/td&gt;
&lt;td&gt;将槽 slot 指派给 node_id 指定的节点，如果槽已经指派给另一个节点，那么先让另一个节点删除该槽&amp;gt;，然后再进行指派。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;cluster setslot&lt;br/&gt;&amp;lt;slot&amp;gt; migrating &amp;lt;node_id&amp;gt;&lt;/td&gt;
&lt;td&gt;将本节点的槽 slot 迁移到 node_id 指定的节点中。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;cluster setslot&lt;br/&gt;&amp;lt;slot&amp;gt; importing &amp;lt;node_id&amp;gt;&lt;/td&gt;
&lt;td&gt;从 node_id 指定的节点中导入槽 slot 到本节点。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;cluster setslot &amp;lt;slot&amp;gt; stable&lt;/td&gt;
&lt;td&gt;取消对槽 slot 的导入（ import）或者迁移（ migrate）。键&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;cluster keyslot &amp;lt;key&amp;gt;&lt;/td&gt;
&lt;td&gt;计算键 key 应该被放置在哪个槽上。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;cluster countkeysinslot&lt;br/&gt;&amp;lt;slot&amp;gt;&lt;/td&gt;
&lt;td&gt;返回槽 slot 目前包含的键值对数量。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;cluster getkeysinslot&lt;br/&gt;&amp;lt;slot&amp;gt; &amp;lt;count&amp;gt;&lt;/td&gt;
&lt;td&gt;返回 count 个 slot 槽中的键&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;cluster-info命令&quot;&gt;cluster info命令&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/201902141138049.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTcz,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;cluster-nodes&quot;&gt;cluster nodes&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190214113908698.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTcz,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;增加节点&quot;&gt;6.增加节点&lt;/h3&gt;
&lt;p&gt;添加新的节点的基本过程就是添加一个空的节点然后移动一些数据给它，有两种情况，添加一个主节点和添加一个从节点（添加从节点时需要将这个新的节点设置为集群中某个节点的复制）&lt;br/&gt;&lt;strong&gt;添加一个新的实例&lt;/strong&gt;&lt;br/&gt;启动新的7007节点,使用的配置文件和以前的一样,只要把端口号改一下即可，过程如下:&lt;/p&gt;
&lt;p&gt;在终端打开一个新的标签页.&lt;br/&gt;进入redis-cluster 目录.&lt;br/&gt;复制并进入redis7007文件夹.&lt;br/&gt;和其他节点一样，创建redis.conf文件,需要将端口号改成7007.&lt;br/&gt;最后启动节点 ../redis-server ./redis.conf&lt;br/&gt;如果正常的话，节点会正确的启动.&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190214115150909.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;添加主节点&quot;&gt;1.添加主节点&lt;/h4&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;./redis-trib.rb add-node 192.168.88.121:7007 192.168.88.121:7001&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第一个参数是新节点的地址，第二个参数是任意一个已经存在的节点的IP和端口&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190214115304934.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTcz,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190214115354818.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTcz,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;新节点现在已经连接上了集群， 成为集群的一份子， 并且可以对客户端的命令请求进行转向了， 但是和其他主节点相比， 新节点还有两点区别：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;新节点没有包含任何数据， 因为它没有包含任何哈希槽.&lt;/li&gt;
&lt;li&gt;尽管新节点没有包含任何哈希槽， 但它仍然是一个主节点， 所以在集群需要将某个从节点升级为新的主节点时， 这个新节点不会被选中。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;接下来， 只要使用 redis-trib 程序， 将集群中的某些哈希桶移动到新节点里面， 新节点就会成为真正的主节点了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;重新分配slot&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;./redis-trib.rb reshard 192.168.88.121:7001&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;只需要指定集群中其中一个节点的地址， redis-trib 就会自动找到集群中的其他节点&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190214115937996.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTcz,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190214120001953.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTcz,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;7007节点被分类slot，成了真正意义上的主节点&lt;/p&gt;
&lt;h4 id=&quot;添加从节点&quot;&gt;2.添加从节点&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;添加的从节点被随机的配置任意的主节点&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;./redis-trib.rb add-node --slave 192.168.88.121:7008 192.168.88.121:7001&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;将从节点添加给指定的主节点&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;./redis-trib.rb add-node --slave --master-id 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 127.0.0.1:7006 127.0.0.1:7000&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;删除节点&quot;&gt;7.删除节点&lt;/h3&gt;
&lt;p&gt;使用del-node命令移除节点。&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;./redis-trib.rb del-node 192.168.2.11:7007 &amp;lt;node-id&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第一个参数：任意集群中现有的地址192.168.88.121:7001&lt;br/&gt;第二个参数：你想移除的节点id ab853f5e95f1e32e0ee40543a9687d60fc3bd941 （该id可以在想要移除的节点nodes.conf文件中找到）&lt;/p&gt;
&lt;h2 id=&quot;关闭redis&quot;&gt;关闭redis&lt;/h2&gt;
&lt;p&gt;redis7001/redis-cli -p 7001 shutdown&lt;br/&gt;./redis-cli shutdown&lt;br/&gt;pkill -9 redis-server –关闭所有的redis服务&lt;/p&gt;
&lt;p&gt;~好了redis的集群操作就介绍到此，&lt;br/&gt;更多内容可以查看官网手册:http://www.redis.cn/documentation.html&lt;/p&gt;
</description>
<pubDate>Thu, 14 Feb 2019 04:21:00 +0000</pubDate>
<dc:creator>ゞ .邓澎波</dc:creator>
<og:description>前面文章介绍了Redis的主从复制，虽然该模式能够在一定程度上提高系统的稳定性，但是在数据访问量比较大的情况下，单个master应付起来还是比较吃力的，这时我们可以考虑将redis集群部署，本文就来重</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dengpengbo/p/10373911.html</dc:identifier>
</item>
<item>
<title>产品研发团队如何融合OKR与Scrum敏捷开发？ - IVAN-jsjwk</title>
<link>http://www.cnblogs.com/jsjwk/p/10373902.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jsjwk/p/10373902.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jgOJKOvxkeMDDT2CjUcaaVibhhialTB8DoicDV6M645cpevUSL9B4YIFXBCA4QuF61gw1LfYicYSzk7rgk24ZtY52g/640?wx_fmt=jpeg&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.721875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jgOJKOvxkeMDDT2CjUcaaVibhhialTB8DoicDV6M645cpevUSL9B4YIFXBCA4QuF61gw1LfYicYSzk7rgk24ZtY52g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;p&gt;「 OKR 」现在非常的火爆，很多公司都在使用，不仅国外的 Google、英特尔等大公司在用，国内的一线知名互联网企业今日头条和一些创业团队也都在使用。&lt;/p&gt;
&lt;p&gt;那为什么「 OKR 」这么受欢迎呢，因为把它可以帮助团队 达成共识、加深信任、加强协同。&lt;/p&gt;
&lt;p&gt;并且「 OKR 」这套方法，不仅可以帮助我们开展工作，还可以用它来管理个人生活。例如互联网大牛 吴军 就是固定使用「 OKR 」来管理他个人年度目标和计划的。&lt;/p&gt;
&lt;p&gt;乘着假期，我也仔细读了两本关于「 OKR 」的书籍，《OKR工作法》、《这就是OKR》，好书，确实收益良多，方法很简单，但是确实很实用。所以接下来我也打算把「 OKR 」方法实践在我们的研发团队目标管理和我个人的年度计划中。&lt;/p&gt;
&lt;p&gt;说了这么多「 OKR 」的好，那接下来就该详细的介绍一下它了。&lt;/p&gt;
&lt;p&gt;本文在第三节还会重点讲一下，我们作为产品研发团队，应该怎么将「 OKR 」与「 Scrum 」进行深度结合，打造最完美的团队与项目。&lt;/p&gt;
&lt;h4&gt;一、什么是 OKR？&lt;/h4&gt;
&lt;p&gt;「 OKR 」是一个标准化的目标管理的方法，其中 O 是指 Objectives 目标，KR 是指 Key Results 关键结果，即 目标与关键结果法，它是一套明确和跟踪目标以及其完成情况的管理方法，最初由英特尔公司发明，然后由Google公司发扬光大。&lt;/p&gt;
&lt;p&gt;我们在公司或团队中，经常会制定目标，俗称 KPI ，它是一个自上而下安排的量化指标，它往往是一个从上层往下层责任摊派的过程，并不是由大家自发的去制定去挑战的目标。这种情况会带来什么问题呢，大家对这个KPI虽然压力很大，但是每日里做的工作并不一定是与之高度关联的，甚至很多人不知道自己近期工作的重点，并不清楚自己所做的工作对整体目标的帮助，而且往往对其他人的工作也不甚了解，还不利于团队协同。&lt;/p&gt;
&lt;p&gt;因此，我们需要一个能实现 &lt;strong&gt;聚焦&lt;/strong&gt;、&lt;strong&gt;透明&lt;/strong&gt; 的目标管理方法，这就是「 OKR 」，它能将每个人、每个团队、以及公司的使命关联起来，它是实现协同的首选工具，既能实现“上下同欲”的纵向协同，也能实现“跨职能”的横向协同。&lt;/p&gt;
&lt;p&gt;在工作中， 「 OKR 」明确了大家的预期（需要尽快做什么）、以及具体由谁来执行，能够在不同部门员工之间建立联系，能够让员工的行动与整体的目标保持一致。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;「 OKR 」有四个关键作用：&lt;/strong&gt;&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;2&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;对优先事项能聚焦（明确每季度、每周内的重点事项，大家朝着一个共同的目标）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;有利于人员协作（透明的OKR让大家协同一致，充分实现纵向和横向的协作）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;更有效的责任追踪（每周关注进展、随时调整、每季度回顾评分）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;更能激励大家的自主性（每个人知道自己所做的部分对全局目标的贡献，激发自主性和成就感）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;二、如何使用 OKR？&lt;/h4&gt;
&lt;p&gt;使用OKR没有固定模式，可以根据原则和实际情况自行调整，参考流程如下：&lt;/p&gt;
&lt;ol class=&quot;list-paddingleft-2&quot; readability=&quot;6&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;在公司的关键人员讨论下，制定出公司整体的年度 O（目标）和 KR（关键结果）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;根据年度OKR，确定出下一季度的OKR&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;基于公司顶层的OKR，各部门/团队的关键人员进行讨论后，确定出部门/团队的季度OKR&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;给团队宣讲整体OKR，然后每个员工根据团队的OKR，制定且分享自己的OKR，并与主管确认&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在季度末，员工对各自的OKR进行自我评估&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;每周一团队进行周计划，确定本周的工作任务，需要与OKR对齐&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;每周五团队进行周庆祝，回顾上周周报、明确进展、发现问题，同样需要检查与OKR是否对齐&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;在使用「 OKR 」的时候，有几个原则：&lt;/strong&gt;&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;目标 必须要能鼓舞人心且与长远的计划有关&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;目标 要有时间期限，比如 年度、季度 还是 月度&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;目标 要由独立团队来承担，相互依赖的关系比较吃力&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;关键结果 需要更接地气且是可量化可衡量的指标&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;比如，我们要给一个学习英文的APP设定OKR，一般人可能会想到的目标可能是这类的：&lt;/p&gt;
&lt;p&gt;“在第一季度实现安装量100w”&lt;/p&gt;
&lt;p&gt;“在第一季度实现日活跃用户30w”&lt;/p&gt;
&lt;p&gt;……&lt;/p&gt;
&lt;p&gt;但是上述这些并不符合OKR方法中对目标的描述，它们反而符合OKR中的关键结果。因为它们不够激励人心，没有鼓舞性，在OKR方法中，上面APP产品正确的设定目标的描述方式可以是：&lt;/p&gt;
&lt;p&gt;“在英语学习群体里展示出APP的优秀口碑”&lt;/p&gt;
&lt;p&gt;最好是用“拿下”、“搞定”、“展示出”等能激励人兴奋的词汇，很明显这个目标非常不符合 smart 原则，既没有时间点，也没有可衡量的数值。但是没关系，只要它能鼓舞人就可以了。&lt;/p&gt;
&lt;p&gt;而我们在设定 KR关键结果 的时候，最开始的那些描述“在第一季度实现安装量100w”又正好适用了，我们可以把这个作为关键结果，也就是说，如果要实现“在英语学习群体里展示出APP的优秀口碑”这个具有挑战性的目标的话，我们给自己设定的两项关键结果：“在第一季度实现安装量100w”、“在第一季度实现日活跃用户30w”，我们认为这两项关键结果一旦实现了，上述目标也自然而然就搞定了，是一个顺理成章的事情。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一次实践 OKR 的时候，有几个小技巧：&lt;/strong&gt;&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如果是第一次实践可以全公司/团队只设置一个OKR，这样更容易接受和落实&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;可以先只选一个团队去实践&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;可以尝试用OKR来做项目管理，让员工能快速理解这个方法&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;在OKR实践中，影响目标达成的因素一般有：&lt;/strong&gt;&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;没有给目标设定优先级&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;缺乏充分的承诺与沟通&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;没有做好充分的计划&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;轻易的放弃&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;使用OKR的注意事项：&lt;/strong&gt;&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;尽量设置少的OKR，最好是一个&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;每周盘点的时候先从公司OKR开始、然后沟通部门的、团队的&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;个人的OKR只需要一对一沟通&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;OKR不是你唯一一件要做的事情，而是你必须要做的一件事&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OKR要公开、要透明&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;三、如何将 OKR 与 Scrum 结合？&lt;/h4&gt;
&lt;p&gt;OKR很强大，可以应用的点比较多，甚至还可以直接用作项目管理使用，例如《OKR工作法》一书中提到的OKR四象限方法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jgOJKOvxkeMDDT2CjUcaaVibhhialTB8Doviann0iaTUqibq8VqEicaSDQE2JQW5yT6gicaRRWGLxUrjrH6UnEBsfhSWA/640?wx_fmt=png&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.7376470588235294&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jgOJKOvxkeMDDT2CjUcaaVibhhialTB8Doviann0iaTUqibq8VqEicaSDQE2JQW5yT6gicaRRWGLxUrjrH6UnEBsfhSWA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;850&quot; data-fail=&quot;0&quot;/&gt;（图片来源《OKR工作法》）&lt;/p&gt;
&lt;p&gt;书中提到的四象限方法，右上角的第一象限可以列出当前OKR以及其进展，左上角的第二象限列出本周重点关注的任务，左下角额度第三象限列出未来四周的计划，右下角的第四象限列出除当前OKR以外产品和团队中的其他状态指标。&lt;/p&gt;
&lt;p&gt;每周通过对这个图进行一次讨论和回顾，基本上就可以当做项目管理来使用了，简洁好用。&lt;/p&gt;
&lt;p&gt;但是OKR毕竟不是一个专业的项目管理工具，它的核心目的不在于做项目管理，尤其是对我们产品研发团队而言，平常用的更多的项目开发管理方法一般是 「 Scrum 」敏捷开发方法。&lt;/p&gt;
&lt;p&gt;「 Scrum 」敏捷开发方法可以让项目成员明确阶段性的目标与任务、明确团队分工协作、明确每周应该完成那些任务、明确下周的计划是什么、清楚目前项目研发中的问题和解决办法。因此作为研发的同学们可能更适应这套工作方法。没关系，其实「 OKR 」与「 Scrum 」不仅不冲突，而且还有很多共同点，因此在产品项目中可以将它们组合在一起，用OKR去设定目标，用Scrum去实现目标，结合起来使用会更加有效。&lt;/p&gt;
&lt;p&gt;OKR 其实更多的是从大局角度，目标角度出发去激励团队，它负责的是指导团队朝着什么方向去做、做到什么程度。而Scrum更多的是从任务维度出发去管理团队，它指导着团队具体怎么做。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;「 OKR 」与「 Scrum 」在工作中具体该怎么结合呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;公司或者团队可以先找OKR的流程去创建年度/季度的目标和关键结果。然后将团队当前季度的KR拆分成Scrum中的Sprint计划，然后再细分任务，每天的站会让团队成员对着看板沟通任务情况，每周的Scrum回顾会议中我们需要更新OKR的进度，每季度进行OKR回顾评分。&lt;/p&gt;
&lt;p&gt;正是因为OKR与Scrum中有些流程和会议是类似的，咱们可以合并进行，最终实现OKR来管理目标和方向，Scrum管理任务计划推进。在实际应用中，不同团队可以根据自身实际情况灵活的应用。&lt;/p&gt;
&lt;p&gt;以上，就是对OKR的基本介绍以及与Scrum结合的一些想法，欢迎大家留言交流。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;本文原创发布于微信公众号「 不止思考 」，欢迎关注，交流 互联网认知、工作管理、大数据、架构、Web等技术。 &lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1453917/201902/1453917-20190214121244645-1670894312.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 14 Feb 2019 04:13:00 +0000</pubDate>
<dc:creator>IVAN-jsjwk</dc:creator>
<og:description>「 OKR 」现在非常的火爆，很多公司都在使用，不仅国外的 Google、英特尔等大公司在用，国内的一线知名互联网企业今日头条和一些创业团队也都在使用。 那为什么「 OKR 」这么受欢迎呢，因为把它可</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jsjwk/p/10373902.html</dc:identifier>
</item>
<item>
<title>TeamCity+Rancher+Docker实现.Net Core项目DevOps（目前成本最小的DevOps实践） - Ambre</title>
<link>http://www.cnblogs.com/Ambre/p/10373006.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Ambre/p/10373006.html</guid>
<description>&lt;h2&gt;1.准备项&lt;/h2&gt;
&lt;p&gt;1.1.服务器一台，1H4G（更小内存应该也可以，自行测试），系统：Ubuntu 16.04 64位&lt;/p&gt;
&lt;p&gt;1.2.数据库一个，MYSQL,MSSQL都可以（还有其他的，自行配置）,教程是MSSQL&lt;/p&gt;
&lt;p&gt;1.3.其他软件，Xshell （用于远程Linux服务器），WinSCP（用于管理Linux服务器上的文件）&lt;/p&gt;
&lt;h2&gt;2.装服务器环境&lt;/h2&gt;
&lt;h3&gt;2.1.Docker环境安装：&lt;/h3&gt;
&lt;p&gt;因为墙的原因，这里需要使用国内镜像加速服务，这里使用阿里云的镜像加速服务，阿里云的镜像加速服务，登陆阿里云后，选择[容器镜像服务]-&amp;gt;[镜像加速器]&lt;/p&gt;
&lt;p&gt;2.1.1首先，安装Docker　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
curl -fsSL https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;get.docker.com | bash -s docker --mirror Aliyun&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;装完后输入：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
docker version
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查询docker是否装成功。&lt;/p&gt;
&lt;p&gt;然后配置加速源，这里可以使用阿里云提供的命令，也可以用WinSCP找到/etc/docker目录建立daemon.json&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&lt;span&gt;&quot;registry-mirrors&quot;&lt;/span&gt;: [&lt;span&gt;&quot;https://xxxxxxx.mirror.aliyuncs.com&quot;&lt;/span&gt;&lt;span&gt;]
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;xxxxxxx改为阿里云提供给你的地址&lt;/p&gt;
&lt;p&gt;如果是使用命令添加，请依此输入以下命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
mkdir -p &lt;span&gt;/&lt;/span&gt;etc&lt;span&gt;/&lt;/span&gt;&lt;span&gt;docker

tee &lt;/span&gt;&lt;span&gt;/&lt;/span&gt;etc&lt;span&gt;/&lt;/span&gt;docker&lt;span&gt;/&lt;/span&gt;daemon.json &amp;lt;&amp;lt;-'EOF'
&lt;span&gt;
{
  &lt;/span&gt;&lt;span&gt;&quot;registry-mirrors&quot;&lt;/span&gt;: [&lt;span&gt;&quot;https://xxxxxxx.mirror.aliyuncs.com&quot;&lt;/span&gt;&lt;span&gt;]
}

EOF&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后重启docker服务&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
systemctl daemon-&lt;span&gt;reload

systemctl restart docker&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Docker环境搭建完毕&lt;/p&gt;
&lt;h3&gt;2.1.TeamCity-Server环境安装&lt;/h3&gt;
&lt;p&gt;拉取官方镜像（有点大，建议使用云服务器测试，入站带宽大，下载速度块）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
docker pull jetbrains&lt;span&gt;/&lt;/span&gt;teamcity-server
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;出现&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Status: Downloaded newer image &lt;span&gt;for&lt;/span&gt; jetbrains&lt;span&gt;/&lt;/span&gt;teamcity-server:latest
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;则拉取成功，接下来启动teamcity-server&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
docker run -d -it --name teamcity-ecms -v &lt;span&gt;/&lt;/span&gt;data&lt;span&gt;/&lt;/span&gt;tc&lt;span&gt;/&lt;/span&gt;datadir:&lt;span&gt;/&lt;/span&gt;data&lt;span&gt;/&lt;/span&gt;teamcity_server&lt;span&gt;/&lt;/span&gt;datadir -p 8111:8111 jetbrains&lt;span&gt;/&lt;/span&gt;teamcity-server&lt;p&gt;//然后&lt;br/&gt;docker ps 
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES
7a0a5b60a4b1 jetbrains&lt;/span&gt;/teamcity-server &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/run-services.sh&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;6&lt;/span&gt; seconds ago Up &lt;span&gt;5&lt;/span&gt; seconds &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;:&lt;span&gt;8111&lt;/span&gt;-&amp;gt;&lt;span&gt;8111&lt;/span&gt;/tcp teamcity-ecms
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;出现上述结果就成功了。接下来打开防火墙8111端口（外网的话），访问： &amp;lt;your id&amp;gt;:8111&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/695836/201902/695836-20190214103829205-1723324628.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;出现上述图片则搭建成功！&lt;/p&gt;
&lt;p&gt;点击[Proceed]按钮进入下一步，选择你准备的数据库类型，这里选MSSQL，需要下载JDBC drivers，点击[Downloading JDBC drivers]的按钮就行了，自动下载&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/695836/201902/695836-20190214104531525-2055032992.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;按上面的图片填写，点击[Proceed]，稍等3-10分钟，如果出现报错，请检查你的参数是否填写正确！&lt;/p&gt;
&lt;p&gt;弄完之后会出现一个协议，拉到最下面，勾选Accept license agreement，点击[Continue&amp;gt;]按钮&lt;/p&gt;
&lt;p&gt;然后出现创建账号的页面，自行创建一个管理员账号，登陆~&lt;/p&gt;
&lt;p&gt;到这里为止，如果没出现问题，那么teamcity-server的环境就搭建完毕了。&lt;/p&gt;
&lt;h3&gt;2.2.TeamCity-Agent环境安装&lt;/h3&gt;
&lt;p&gt;有个teamcity-server,还需要agent来做Build,push的工作（类似于编译平台）&lt;/p&gt;
&lt;p&gt;第一步拉取Agent的镜像&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
docker pull jetbrains/teamcity-agent
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第二步启动容器&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
docker run -d -it -e SERVER_URL=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;192.168.0.19:8111&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -v /etc/docker:/data/teamcity_agent/conf  -v /var/run/docker.sock:/var/run/docker.sock -v /opt/buildagent/work:/opt/buildagent/work -v /opt/buildagent/temp:/opt/buildagent/temp -v /opt/buildagent/tools:/opt/buildagent/tools -v /opt/buildagent/plugins:/opt/buildagent/plugins -v /opt/buildagent/system:/opt/buildagent/system jetbrains/teamcity-agent
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;[192.168.0.19:8111]这里最好填内网地址（安装速度快，省流量），如果没有局域网，就要填外网地址，请大家注意！&lt;/p&gt;
&lt;p&gt;并且这个启动方式会和Agent的共享主机的Docker配置和缓存，如果有疑问可以使用另外一个命令，&lt;a href=&quot;https://hub.docker.com/r/jetbrains/teamcity-agent/&quot; target=&quot;_blank&quot;&gt;https://hub.docker.com/r/jetbrains/teamcity-agent/&lt;/a&gt;,自行翻阅&lt;/p&gt;
&lt;p&gt;执行后，可使用&lt;span&gt;docker logs&lt;/span&gt; -f &amp;lt;CONTAINER-ID&amp;gt;查看启动日志，CONTAINER-ID使用docker ps查看&lt;/p&gt;
&lt;p&gt;然后进入Server的WEBUI页面，选择Agents-&amp;gt;Unauthorized&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/695836/201902/695836-20190214110202495-299678851.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;审核它！然后他就会出现在Connected里！&lt;/p&gt;
&lt;p&gt;&lt;span&gt;到这里为准，TeamCity的所有环境就搭好了！！！！！&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;2.3.Rancher环境安装&lt;/h3&gt;
&lt;p&gt;拉取镜像并部署容器&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
docker run -d --restart=unless-stopped -p &lt;span&gt;8080&lt;/span&gt;:&lt;span&gt;8080&lt;/span&gt; rancher/server
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;过3-5分钟后，防火墙打开8080端口，访问&amp;lt;your id&amp;gt;:8080&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/695836/201902/695836-20190214110810372-1727093936.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;出现上述页面，成功，rancher环境安装完毕!!!&lt;/p&gt;
&lt;h3&gt;2.4.docker register环境配置&lt;/h3&gt;
&lt;p&gt;修改之前的daemon.json&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &quot;registry-mirrors&quot;: [&quot;https://xfgphhex.mirror.aliyuncs.com&quot;&lt;span&gt;],
     &quot;insecure-registries&quot;:[&quot;192.168.0.19:5000&quot;&lt;span&gt;]
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;保存。192.168.0.19可以配置成外网（已测试，木有问题），记得打开5000端口！&lt;/p&gt;
&lt;p&gt;重启docker&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
systemctl restart docker
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意，重启docker会把teamcity和rancher的容器关掉，记得重启一下3个容器(ID通过docker ps -a命令查询)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
docker start &amp;lt;Container ID&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;启动register&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
docker run -d -p &lt;span&gt;5000&lt;/span&gt;:&lt;span&gt;5000&lt;/span&gt; --name registry registry:&lt;span&gt;2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;环境到这一步就搭建完毕了~！接下来就是DevOps实现&lt;/p&gt;
&lt;h2&gt;3.DevOps实践&lt;/h2&gt;
&lt;h3&gt;3.1使用TeamCity制作镜像并注册到Docker register中&lt;/h3&gt;
&lt;p&gt;打开TeamCity,点击左上角[projects],点击[create project]&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/695836/201902/695836-20190214112722939-1756884807.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;进入后，选择[Manually]&lt;/p&gt;
&lt;p&gt;填一个名字保存。&lt;/p&gt;
&lt;p&gt;进入下面这个页面，点击[+Create build configuration]&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/695836/201902/695836-20190214113007777-943790949.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;填一个名字保存。&lt;/p&gt;
&lt;p&gt;进入下面这个页面，填写源代码的url，这里使用朋友的一个脚手架项目做演示，你们也可以先用这个做实验，gitee地址：&lt;a href=&quot;https://gitee.com/kitteam/ecms&quot; target=&quot;_blank&quot;&gt;https://gitee.com/kitteam/ecms&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/695836/201902/695836-20190214113157667-191204211.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;保存。返回下图的页面，点击Build Steps ，点击[+Add build step]按钮&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/695836/201902/695836-20190214113409183-1460870704.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 第一步，使用dockerfile制作镜像,参数如下，dockerfile在图上的地址，自行在gitee查看，可以使用后面的选择选出来也行。路径一定要填'/'要不然copy代码会失败&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/695836/201902/695836-20190214113921789-1783041925.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;第二步，将打包好的镜像register到agent的服务器上&lt;/p&gt;
&lt;p&gt;继续[+Add build step]，这次命令选other,具体参数如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/695836/201902/695836-20190214114151748-2006272534.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第三部，把register里的镜像推送上去&lt;/p&gt;
&lt;p&gt;继续[+Add build step]，这次命令选push,具体参数如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/695836/201902/695836-20190214115056822-1451607147.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; OK,到这一步teamcity的配置就完成了！&lt;/p&gt;
&lt;p&gt;接下来run一次把~~~~~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/695836/201902/695836-20190214115611254-2076079088.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;【192.168.1.43的问题是因为内网IP换了~~~，所以跟着换了，大家不用在意这点细节】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;点击后，可以去[Projects]里看日志，稍等片刻把~（第一次build有点慢(5分钟左右)，后续build因为docker缓存的原因会快很多（1分钟））&lt;/p&gt;
&lt;p&gt;出现下图，则teamcity的任务就全部完成了！！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/695836/201902/695836-20190214115326810-1714332960.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3.2使用Rancher管理主机，镜像，容器&lt;/h3&gt;
&lt;h4&gt;3.2.1 添加主机&lt;/h4&gt;
&lt;p&gt; 顶部：基础架构-主机，点击添加主机&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/695836/201902/695836-20190214115532217-1892531831.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击保存&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/695836/201902/695836-20190214115739261-770320857.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;填写IP，复制下面的命令到服务器执行&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/695836/201902/695836-20190214115808843-1272990804.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
 docker run -e CATTLE_AGENT_IP=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;192.168.1.43&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;  --&lt;span&gt;rm&lt;/span&gt; --privileged -v /var/run/docker.sock:/var/run/docker.sock -v /var/lib/rancher:/var/lib/rancher rancher/agent:v1.&lt;span&gt;2.11&lt;/span&gt; http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;xxx.xx.xx.xxx:8080/v1/scripts/4E62331D4DDD7218B2F3:1546214400000:WmLv6AlVT21dW7TheGXE8iRvQ&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后稍等片刻，安装成功后，前往主机页面查看&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/695836/201902/695836-20190214115948758-30834281.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;3.2.2 添加应用&lt;/h4&gt;
&lt;p&gt;点击左上角，选择环境&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/695836/201902/695836-20190214120112928-786247693.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击【添加应用】&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/695836/201902/695836-20190214120136247-718683986.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/695836/201902/695836-20190214120158807-1133077214.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;随便填一下保存！&lt;/p&gt;
&lt;p&gt;跳转后，点击右上角【添加服务】&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/695836/201902/695836-20190214120231086-409776971.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;填写参数如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/695836/201902/695836-20190214120336770-2069990290.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击创建&lt;/p&gt;
&lt;p&gt;然后稍等片刻，打开主机&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/695836/201902/695836-20190214120502305-338913497.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;启动完成，这个时候打开&amp;lt;your ip&amp;gt;:8081访问网站&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/695836/201902/695836-20190214120541679-201106638.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到这里，这个文章就结束了，成功~&lt;/p&gt;

&lt;p&gt;希望文章对有兴趣搭建CI/CD DevOps环境的公司和个人有所帮助，蟹蟹！&lt;/p&gt;
</description>
<pubDate>Thu, 14 Feb 2019 04:07:00 +0000</pubDate>
<dc:creator>Ambre</dc:creator>
<og:description>1.准备项 1.1.服务器一台，1H4G（更小内存应该也可以，自行测试），系统：Ubuntu 16.04 64位 1.2.数据库一个，MYSQL,MSSQL都可以（还有其他的，自行配置）,教程是MSS</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Ambre/p/10373006.html</dc:identifier>
</item>
</channel>
</rss>