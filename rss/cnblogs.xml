<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>如何让文科生5分钟写上Python - dongfanger</title>
<link>http://www.cnblogs.com/df888/p/14050445.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/df888/p/14050445.html</guid>
<description>&lt;p&gt;这篇文章是转型后发表的第一篇文章，有必要先聊一下我的写文计划。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;串行文章和并行文章&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我会按照发文顺序分为串行文章和并行文章。Python 语言本身的内容，我会按照入门、进阶、原理的顺序依次展开。由于我的水平有限，为了保证质量不乱讲，我选择站在巨人的肩膀上进行二次创作。入门篇主要参考菜鸟教程的基础教程部分。进阶篇主要参考《流畅的Python》这本书，我是买了实体书的，计划后面会送出来，虽然有些破旧，还望不要嫌弃（当时买的时候书页就坏了，京东还赔了我 1000 京豆）。原理篇主要参考官方文档以及外网资料，有一说一，国外资料确实更多更专业，只不过都是英文的，还好现在已经适应了。Django、算法、pytest、tep、测试成长小说等系列专题会并行发表，也包括其他单篇文章。这两天了解到 Python 之父 Guido van Rossum 从 Google 退休后，又加入微软继续搞 Python 了。有点意思。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有啥不一样？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Python 文章和视频都非常多，我就在想我写的东西对读者而言价值到底在哪？我不是搞培训的，也不是做教程，内容会更偏向于学习笔记和实用经验。看我的文章，说不定能把以前遗漏或遗忘的知识点再次补上。同时我已经有一段时间的写作经验了，我也尽量深入浅出的把知识讲清楚讲透彻，首先写的文章我要自己都理解透，这样别人看的时候才会觉得一目了然。另外就是认真的态度，见过一些为了流量写的教程，不做评价。只是觉得既然写了，既要对得起自己，也要对得起别人。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;标题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;既为了提高打开率，也是为了新颖，我不会按照比如《Python入门1》、《Python入门2》这种常规的命名，这样的文章实在是太多了。而是会在写完文章后，根据文章内容，选择其中的亮点，作为标题。这个过程也挺有趣，有种点睛之笔的意味。同时我也希望随便摘一篇文章拿出去，也是够看的。&lt;/p&gt;
&lt;p&gt;（突然想起来上学写 2000 多条错题笔记的时候，简单又充实）&lt;/p&gt;

&lt;p&gt;为了把这个开篇写好，我专门在 B 站上面找了最火的 Python 教程，全站排行榜最高第1名的《花了2万多买的Python教程全套》，质量很高，也推荐大家看看。不过我不搞培训，也不需要宣扬 Python 的好处促进就业，就不写那么多背景介绍了。身边学财会的朋友之前让我教教 Python，干脆我就以这个为契机，作为开篇，保证 5 分钟内，即便是文科生，也能用 Python 编起程序来！&lt;/p&gt;

&lt;p&gt;Python 并不神秘，它其实就和 QQ 一样，只是一个运行在电脑上的普普通通的软件。只要有一台电脑，就可以写 Python。&lt;/p&gt;

&lt;p&gt;打开这个下载网址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.python.org/downloads/&quot;&gt;https://www.python.org/downloads/&lt;/a&gt;&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202011/1629545-20201127213136154-684472134.png&quot;/&gt;&lt;/center&gt;
&lt;p&gt;点击 Download Python 进行下载（Mac 土豪请注意选择版本）。下载后傻瓜式一路点击下一步安装就好。&lt;/p&gt;

&lt;p&gt;一般的软件我们都是双击图标打开。Python 在安装以后桌面上不会出现图标。不过可以从开始菜单找到：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202011/1629545-20201127213136852-1175239289.png&quot;/&gt;&lt;/center&gt;
&lt;p&gt;点击后就打开了：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202011/1629545-20201127213137214-1516183903.png&quot;/&gt;&lt;/center&gt;
&lt;p&gt;Python 毕竟是一门编程语言，它也有它自己的尊严，所以它的界面看起来也有专业的一面，比如那一串密密麻麻的英文。&lt;/p&gt;
&lt;p&gt;输入一句话试试：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;print(&quot;hello&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;敲击回车。它马上就会回应一句，hello：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202011/1629545-20201127213137576-1441411140.png&quot;/&gt;&lt;/center&gt;
&lt;p&gt;没错，是的，你已经在用 Python 编程了！&lt;/p&gt;

&lt;p&gt;本文以极其简单的例子，介绍了如何动手用 Python 编程。我试了下，如果网速快的话，5 分钟内完成是妥妥的。哈哈哈。之所以选择这个简单例子，也是想说明 Python 本来就是很简单的，不用听到编程就被吓到了。先动手，一点一点学习就好。不过言归正传，我们工作中并不是这么写 Python 的，而是用一款叫做 PyCharm 的软件。PyCharm 分为社区免费版和专业旗舰版。日常使用社区版就可以了，个人推荐旗舰版。提示一下，破解的时候注意搜索带上 PyCharm 的版本，比如 2020.2.3，成功率会更高。&lt;/p&gt;
</description>
<pubDate>Sat, 28 Nov 2020 01:00:00 +0000</pubDate>
<dc:creator>dongfanger</dc:creator>
<og:description>Python系列开篇。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/df888/p/14050445.html</dc:identifier>
</item>
<item>
<title>【Makefile】5-Makefile变量的基础 - 李柱明</title>
<link>http://www.cnblogs.com/lizhuming/p/14050056.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lizhuming/p/14050056.html</guid>
<description>&lt;hr/&gt;&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;本笔记主要记录Makefile一些概念要点。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;概念&quot;&gt;概念&lt;/h2&gt;
&lt;h2 id=&quot;chapter-5：变量的基础&quot;&gt;Chapter 5：变量的基础&lt;/h2&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;变量可以使用在 &lt;strong&gt;目标&lt;/strong&gt; 、 &lt;strong&gt;依赖目标&lt;/strong&gt; 、 &lt;strong&gt;命令&lt;/strong&gt; 或是 &lt;strong&gt;Makefile的其它部分中&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;变量的名字可以包含 &lt;strong&gt;字符、数字和下划线（可以以数字开头）&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;但是不应该包含有 &lt;strong&gt;: # = 空格 回车&lt;/strong&gt; 等特殊字符。&lt;/li&gt;
&lt;li&gt;变量名具有大小写敏感特性。（推荐大小写搭配使用）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;变量赋值时，会自动删除等号 = 两边的空格，但是，变量值后面的空格会保留，直至遇到 结束符或注释符&lt;/span&gt;&lt;/strong&gt; &lt;strong&gt;**&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;51-变量的基础-&quot;&gt;5.1 变量的基础 *&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;使用变量时需要在变量前面添加 &lt;strong&gt;$&lt;/strong&gt; 符号，表示去该变量的值。
&lt;ul&gt;&lt;li&gt;推荐在取值时给变量添加上 &lt;strong&gt;()&lt;/strong&gt; 或 &lt;strong&gt;{}&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;如果需要使用真实的 &lt;strong&gt;$&lt;/strong&gt; ，就用 &lt;strong&gt;$$&lt;/strong&gt; 即可。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;取变量值其实就是相当于 C/C++ 中的宏展开一样，其实还是字符串替换。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;注：推荐看例子。&lt;/em&gt;*
&lt;ul&gt;&lt;li&gt;赋值时要注意后面的空格和注释符 &lt;strong&gt;#&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;注释符 &lt;strong&gt;#&lt;/strong&gt; 可以表示终止一个变量的定义。&lt;/li&gt;
&lt;li&gt;例子:
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;/foo/bar&lt;/strong&gt; 后面还跟了几个 &lt;strong&gt;空格&lt;/strong&gt;，如果使用到 &lt;code&gt;$(dir)/file&lt;/code&gt; ，那 路径就错误了。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-makefile&quot;&gt;dir := /foo/bar      # directory to put the frobs indir := /foo/bar # directory to put the frobs in
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;空格的定义-&quot;&gt;空格的定义 **&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;先定义一个空变量 &lt;code&gt;empty&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;然后用 &lt;strong&gt;$&lt;/strong&gt; 符号取出 + &lt;em&gt;空格&lt;/em&gt; + &lt;em&gt;注释符&lt;/em&gt; &lt;strong&gt;#&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;因为 &lt;em&gt;注释符&lt;/em&gt; &lt;strong&gt;#&lt;/strong&gt; 可以结束一个变量的赋值。&lt;/li&gt;
&lt;li&gt;不用&lt;em&gt;注释符&lt;/em&gt; &lt;strong&gt;#&lt;/strong&gt; 也可以，只是怕空格的数量不对才用 &lt;em&gt;注释符&lt;/em&gt; &lt;strong&gt;#&lt;/strong&gt; 表示一下而已。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-makefile&quot;&gt;empty:=
a = $(empty) #
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;一些赋值&quot;&gt;一些赋值&lt;/h4&gt;
&lt;p&gt; 变量定义语法：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;形式&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr&gt;&lt;td&gt;A = xxx&lt;/td&gt;
&lt;td&gt;延时变量&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;B ?= xxx&lt;/td&gt;
&lt;td&gt;延时变量，只有第一次定义时赋值才成功，若曾被定义过，则此赋值无效。&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;C := xxx&lt;/td&gt;
&lt;td&gt;立即变量&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;D += yyy&lt;/td&gt;
&lt;td&gt;如果D在前面是延时变量，那么现在它还是&lt;strong&gt;延时变量&lt;/strong&gt;&lt;br/&gt;如果D在前面是立即变量，那么它现在还是&lt;strong&gt;立即变量&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;一些特殊的符号&quot;&gt;一些特殊的符号&lt;/h4&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;符号&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;9.5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;$@&lt;/td&gt;
&lt;td&gt;表示规则中的目标文件集&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;$%&lt;/td&gt;
&lt;td&gt;当目标为函数库的时候，则表示规则中的目标成员名。反之为空。如一个目标为&quot;&lt;em&gt;foo.a(bar.o)&lt;/em&gt;&quot;，那么，&quot;$%&quot;就是&quot;bar.o&quot;，以空格分隔开。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;$&amp;lt;&lt;/td&gt;
&lt;td&gt;依赖文件集合中的第一个文件，如果依赖文件以&quot;&lt;em&gt;%&lt;/em&gt;&quot;形式出现，则表示符合模式的一系列文件集合&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;$?&lt;/td&gt;
&lt;td&gt;所有比目标新的依赖集合，以空格分隔开。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;$^&lt;/td&gt;
&lt;td&gt;所有依赖文件集合，以空格分隔开。如果依赖有相同，则取其一。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;$+&lt;/td&gt;
&lt;td&gt;和 &quot;$^&quot;类同，但是不会把相同的删除掉。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;$*&lt;/td&gt;
&lt;td&gt;这个变量表示目标模式中 &quot;%&quot;及其之前的部分，如果目标是 test/a.test.c,目标模式为 a.%.c, 那么 &quot;$* &quot; 就是 test/a.test。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;52-变量中的变量-&quot;&gt;5.2 变量中的变量 *&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;在 &lt;strong&gt;=&lt;/strong&gt; 号右侧可以是值，也可以是变量*&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;如果 = 右侧是 变量，那么该 变量 可以定义在文件的任何一处&lt;/strong&gt;（就是 延时变量 &lt;strong&gt;=&lt;/strong&gt;）。（&lt;em&gt;&lt;strong&gt;但是不推荐使用该方法&lt;/strong&gt;&lt;/em&gt;）&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;ul&gt;&lt;li&gt;为了避免上面第二点的操作，一般使用 即时变量 &lt;strong&gt;:=&lt;/strong&gt; 来赋值，例子：
&lt;ul&gt;&lt;li&gt;y 的值是 &lt;strong&gt;foo bar&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-makefile&quot;&gt;x := foo
y := $(x) bar
x := later
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;* y 的值是 **bar**
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-makefile&quot;&gt;y := $(x) bar
x := food
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;53-变量高级用法&quot;&gt;5.3 变量高级用法&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;变量值替换&lt;/li&gt;
&lt;li&gt;把变量的值再变成变量&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;变量值替换&quot;&gt;变量值替换&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;替换变量中的共有的部分
&lt;ul&gt;&lt;li&gt;格式
&lt;ul&gt;&lt;li&gt;&lt;code&gt;$(var:a=b)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;${var:a=b}&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;意思是把变量 &lt;strong&gt;var&lt;/strong&gt; 中的所有以 &lt;strong&gt;a 字串结尾的 a&lt;/strong&gt; 替换成 &lt;strong&gt;b&lt;/strong&gt; 字串。
&lt;ul&gt;&lt;li&gt;这里 &lt;strong&gt;结尾&lt;/strong&gt; 的意思是 &lt;strong&gt;空格&lt;/strong&gt; 或 &lt;strong&gt;结束符&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;例子&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-makefile&quot;&gt;foo := a.o b.o c.o
bar := $(foo:.o=.c)
# 或
foo := a.o b.o c.o
bar := $(foo:%.o=%.c)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;把变量的值再当成变量&quot;&gt;把变量的值再当成变量&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;直接上例子：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-makefile&quot;&gt;ifdef do_sort
func := sort
else
func := strip
endif
bar := a d b g q c
foo := $($(func) $(bar))
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;用在操作符左边：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-makefile&quot;&gt;dir = foo
$(dir)_sources := $(wildcard $(dir)/*.c)
define $(dir)_print
lpr $($(dir)_sources)
endef
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;55-override-指示符&quot;&gt;5.5 override 指示符&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;通常在执行 make 时，如果通过命令行定义了一个变量，那么它将替代在 Makefile 中出现的同名变量的定义。&lt;/li&gt;
&lt;li&gt;如果不希望命令行指定的变量值替代在 Makefile 中的变量定义，那么我们需要在 Makefile 中使用指示符 &lt;strong&gt;override&lt;/strong&gt; 来对这个变量进行声明，如：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-makefile&quot;&gt;override &amp;lt;variable&amp;gt;; = &amp;lt;value&amp;gt;;
# 或
override &amp;lt;variable&amp;gt;; := &amp;lt;value&amp;gt;;
# 或
override &amp;lt;variable&amp;gt;; += &amp;lt;more text&amp;gt;;
# 或
override define foo
bar
endef
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;56-多行变量&quot;&gt;5.6 多行变量&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;相当于 C 中的函数&lt;/li&gt;
&lt;li&gt;关键字 &lt;strong&gt;define&lt;/strong&gt;。（&lt;em&gt;使用该该关键字可以有 换行&lt;/em&gt;）&lt;/li&gt;
&lt;li&gt;例子&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-makefile&quot;&gt;define two-lines
echo foo
echo $(bar)
endef
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;57-环境变量&quot;&gt;5.7 环境变量&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;make 运行时的系统环境变量可以在 make 开始运行时被载入到 Makefile 文件中，但是如果 Makefile中已定义了这个变量，或是这个变量由 make 命令行带入，那么系统的环境变量的值将被覆盖。（如果make 指定了“-e”参数，那么，系统环境变量将覆盖 Makefi le 中定义的变量）&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;58-目标变量&quot;&gt;5.8 目标变量&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;为某个目标设置局部变量，这种变量被称为&lt;strong&gt;Target-specifi c Variable&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;范围只在这条规则以及连带规则中&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;语法
&lt;ul&gt;&lt;li&gt;; 可以是前面讲过的各种赋值表达式，如 &lt;strong&gt;= := +=&lt;/strong&gt; 或是 &lt;strong&gt;?=&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-makefile&quot;&gt;&amp;lt;target ...&amp;gt; : &amp;lt;variable-assignment&amp;gt;;
&amp;lt;target ...&amp;gt; : overide &amp;lt;variable-assignment&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;例子
&lt;ul&gt;&lt;li&gt;在这个示例中，不管全局的 &lt;strong&gt;$(CFLAGS)&lt;/strong&gt; 的值是什么，在 &lt;strong&gt;prog&lt;/strong&gt; 目标，以及其所引发的所有规则中（&lt;strong&gt;prog.o foo.o bar.o&lt;/strong&gt; 的规则），&lt;strong&gt;$(CFLAGS)&lt;/strong&gt; 的值都是 &lt;strong&gt;-g&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-makefile&quot;&gt;prog : CFLAGS = -g
prog : prog.o foo.o bar.o
    $(CC) $(CFLAGS) prog.o foo.o bar.o
prog.o : prog.c
    $(CC) $(CFLAGS) prog.c
foo.o : foo.c
    $(CC) $(CFLAGS) foo.c
bar.o : bar.c
    $(CC) $(CFLAGS) bar.c
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;59-模式变量&quot;&gt;5.9 模式变量&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;就是把上面 目标变量 中的具体目标改为一种模式（一条语句（表达一种模式））。&lt;/li&gt;
&lt;li&gt;语法&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-makefile&quot;&gt;&amp;lt;pattern ...&amp;gt;; : &amp;lt;variable-assignment&amp;gt;;
&amp;lt;pattern ...&amp;gt;; : override &amp;lt;variable-assignment&amp;gt;;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;例子：&lt;strong&gt;就是把 prog 改为 %.o&lt;/strong&gt;，&lt;strong&gt;%.o&lt;/strong&gt; 就是一种模式，所有 &lt;strong&gt;.o&lt;/strong&gt; 结尾的都符合该模式。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-makefile&quot;&gt;%.o : CFLAGS = -O
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;参考&quot;&gt;参考&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;《GUN Makefile》&lt;/li&gt;
&lt;li&gt;《跟我一起写Makefile》&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Sat, 28 Nov 2020 00:33:00 +0000</pubDate>
<dc:creator>李柱明</dc:creator>
<og:description>前言 本笔记主要记录Makefile一些概念要点。 概念 Chapter 5：变量的基础 变量可以使用在 目标 、 依赖目标 、 命令 或是 Makefile的其它部分中。 变量的名字可以包含 字符、</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lizhuming/p/14050056.html</dc:identifier>
</item>
<item>
<title>Linux 学习笔记05丨在Ubuntu 20.04配置FTP服务器 - J_StrawHat</title>
<link>http://www.cnblogs.com/J-StrawHat/p/14051520.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/J-StrawHat/p/14051520.html</guid>
<description>&lt;p&gt;感谢 linuxconfig.org 上的&lt;a href=&quot;https://linuxconfig.org/how-to-setup-ftp-server-on-ubuntu-20-04-focal-fossa-linux&quot;&gt;这篇英文教程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;FTP用于访问和传输&lt;strong&gt;本地网络&lt;/strong&gt;上的文件，通过安装 VSFTPD 软件，打开热点，配置相关信息后即能够启动并运行FTP服务器了。&lt;/p&gt;
&lt;img src=&quot;https://gitee.com/j__strawhat/MyImages/raw/master/img/20201128085833.png&quot; width=&quot;600&quot;/&gt;&lt;h2 id=&quot;1-安装和配置vsftpd&quot;&gt;1. 安装和配置VSFTPD&lt;/h2&gt;
&lt;p&gt;在终端中输入指令以安装 VSFTPD&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ sudo apt-get install vsftpd
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;2-设置-ftp-用户账号&quot;&gt;2. 设置 FTP 用户账号&lt;/h2&gt;
&lt;p&gt;首先我们对原配置文件 &lt;code&gt;vsftpd.conf&lt;/code&gt; 进行备份，避免待会的操作中出错。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ sudo mv /etc/vsftpd.conf /etc/vsftpd.conf_orig
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着，我们通过编辑器（这里用vi）打开原来的配置文件。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ sudo vi /etc/vsftpd.conf
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将下面基本配置信息全部复制粘贴到刚打开的配置文件&lt;code&gt;/etc/vsftpd.conf&lt;/code&gt; ，然后保存修改并关闭文件&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;listen=NO
listen_ipv6=YES
anonymous_enable=NO
local_enable=YES
write_enable=YES
local_umask=022
dirmessage_enable=YES
use_localtime=YES
xferlog_enable=YES
connect_from_port_20=YES
chroot_local_user=YES
secure_chroot_dir=/var/run/vsftpd/empty
pam_service_name=vsftpd
rsa_cert_file=/etc/ssl/certs/ssl-cert-snakeoil.pem
rsa_private_key_file=/etc/ssl/private/ssl-cert-snakeoil.key
ssl_enable=NO
pasv_enable=Yes
pasv_min_port=10000
pasv_max_port=10100
allow_writeable_chroot=YES
&lt;/code&gt;
&lt;/pre&gt;
&lt;img src=&quot;https://gitee.com/j__strawhat/MyImages/raw/master/img/20201128003854.png&quot;/&gt;&lt;p&gt;由于Ubuntu的内置防火墙默认会阻止FTP的通信，我们通过下面的指令在UFW中新建个例外以允许通信。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ sudo ufw allow from any to any port 20,21,10000:10100 proto tcp
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重新启动VSFTPD以应用新的更改。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ sudo systemctl restart vsftpd
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;3-创建一个ftp用户&quot;&gt;3. 创建一个FTP用户&lt;/h2&gt;
&lt;p&gt;FTP服务器已经就就绪，可以接受传入的连接了。接下来就需要创建一个新的用户从而连接到FTP服务。&lt;/p&gt;
&lt;p&gt;创建新用户 &lt;code&gt;ftpuser&lt;/code&gt;的同时设置该用户的密码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ sudo useradd -m ftpuser
$ sudo passwd ftpuser
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了保证运行成功，需要在&lt;code&gt;ftpuser&lt;/code&gt;的家目录中保存至少一个文件。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ sudo bash -c &quot;echo FTP TESTING &amp;gt; /home/ftpuser/FTP-TEST&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当我们连接到该FTP服务器时，我们就能够看到这样的文件。&lt;/p&gt;
&lt;h2 id=&quot;3-连结ftp服务器&quot;&gt;3. 连结FTP服务器&lt;/h2&gt;
&lt;p&gt;现在，你用手机开下&lt;strong&gt;热点&lt;/strong&gt;，你的小伙伴通过连接你的热点，然后输入你那边的IP地址或者主机名即能连接到FTP服务器了。接下来介绍两种方法，任意种方法都能够成功连接。&lt;/p&gt;
&lt;h3 id=&quot;31-使用命令行连接到ftp服务器&quot;&gt;3.1 使用命令行连接到FTP服务器&lt;/h3&gt;
&lt;p&gt;打开终端，使用Ubuntu的 &lt;code&gt;ftp&lt;/code&gt; 命令来连接你的 loopback 地址（127.0.0.1）或者 你电脑上特有的IP地址。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;loopback 是一个特殊的网络接口（理解为虚拟网卡），用于本机中各个应用间的网络交互。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;如何查看你电脑上的IP地址？&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ hostname -I
#打印显示的左边那串数字即是你的Ipv4地址了
&lt;/code&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ ftp 127.0.0.1
#或者 ftp 你的电脑IP地址
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来，会显示&lt;code&gt;Connected&lt;/code&gt;并让你输入账号名称与口令（就是第2步创建的账号&lt;code&gt;ftpuser&lt;/code&gt;）&lt;/p&gt;
&lt;img src=&quot;https://gitee.com/j__strawhat/MyImages/raw/master/img/20201128010205.png&quot;/&gt;&lt;p&gt;由此连接成功！通过&lt;code&gt;ls&lt;/code&gt;指令，就能查看该服务器中的文件或者创建目录了😄&lt;/p&gt;
&lt;img src=&quot;https://gitee.com/j__strawhat/MyImages/raw/master/img/20201128010509.png&quot;/&gt;&lt;h3 id=&quot;32-通过gui连接到ftp服务器&quot;&gt;3.2 通过GUI连接到FTP服务器&lt;/h3&gt;
&lt;p&gt;打开文件管理器，点击“其他位置”，在“连接到服务器”那一栏中输入 &lt;code&gt;ftp://127.0.0.1&lt;/code&gt;（使用你的IP地址也可以），点击连接就会弹出窗口，输入你第二步创建的账号就能连接成功了。&lt;/p&gt;
&lt;img src=&quot;https://gitee.com/j__strawhat/MyImages/raw/master/img/20201128010822.png&quot; width=&quot;600&quot;/&gt;&lt;p&gt;成功连接后，就能看到直接所创建的文件了。&lt;/p&gt;
&lt;img src=&quot;https://gitee.com/j__strawhat/MyImages/raw/master/img/20201128011015.png&quot; width=&quot;600&quot;/&gt;&lt;h3 id=&quot;33-使用浏览器连接到ftp服务器&quot;&gt;3.3 使用浏览器连接到FTP服务器&lt;/h3&gt;
&lt;p&gt;打开你的浏览器（以火狐浏览器为例），在地址栏中输入你的 loopback 地址（127.0.0.1）或者 你电脑上特有的IP地址。&lt;/p&gt;
&lt;img src=&quot;https://gitee.com/j__strawhat/MyImages/raw/master/img/20201128085700.png&quot;/&gt;&lt;p&gt;填写第二步所创建的账号名称及密码&lt;/p&gt;
&lt;img src=&quot;https://gitee.com/j__strawhat/MyImages/raw/master/img/20201128085833.png&quot; width=&quot;600&quot;/&gt;&lt;p&gt;成功登录~&lt;/p&gt;
</description>
<pubDate>Sat, 28 Nov 2020 00:26:00 +0000</pubDate>
<dc:creator>J_StrawHat</dc:creator>
<og:description>感谢 linuxconfig.org 上的这篇英文教程 FTP用于访问和传输本地网络上的文件，通过安装 VSFTPD 软件，打开热点，配置相关信息后即能够启动并运行FTP服务器了。 1. 安装和配置V</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/J-StrawHat/p/14051520.html</dc:identifier>
</item>
<item>
<title>【R语言入门】R语言中的变量与基本数据类型 - 弗兰克的猫</title>
<link>http://www.cnblogs.com/mfrank/p/14051513.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mfrank/p/14051513.html</guid>
<description>&lt;h2 id=&quot;说明&quot;&gt;说明&lt;/h2&gt;
&lt;p&gt;在前一篇中，我们介绍了 &lt;code&gt;R&lt;/code&gt; 语言和 &lt;code&gt;R Studio&lt;/code&gt; 的安装，并简单的介绍了一个示例，接下来让我们由浅入深的学习 &lt;code&gt;R&lt;/code&gt; 语言的相关知识。&lt;/p&gt;
&lt;p&gt;本篇将主要介绍 &lt;code&gt;R&lt;/code&gt; 语言的基本操作、变量和几种基本数据类型，好对 &lt;code&gt;R&lt;/code&gt; 语言的使用方法有一个基本的概念。通过本篇的学习，你将了解到：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;R&lt;/code&gt; 语言有哪些基本操作&lt;/li&gt;
&lt;li&gt;什么是变量，以及如何给变量赋值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;R&lt;/code&gt; 语言有哪些基本数据类型，如何确定变量的数据类型&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;r-语言的基本操作&quot;&gt;R 语言的基本操作&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;R&lt;/code&gt; 语言的默认提示符是 &lt;code&gt;&amp;gt;&lt;/code&gt; ，它表示正在等待输入命令，每次输入命令后敲击回车即可执行当前命令。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1043143/202011/1043143-20201128081833879-1555351561.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;R&lt;/code&gt; 语言支持的基本操作主要有加、减、乘、除、取余和幂运算，对应的运算符分别为：+、-、*、/、%%、^。&lt;/p&gt;
&lt;p&gt;加减乘除就不必多说了，但有一点需要提一下，跟许多语言不一样的是，&lt;code&gt;R&lt;/code&gt; 语言中，除法运算得到的不是整数部分，而是包含小数部分的结果。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-R&quot;&gt;&amp;gt; 9/2
[1] 4.5
&amp;gt; 9/4
[1] 2.25
&amp;gt; 11/3
[1] 3.666667
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;取余运算的含义是计算整除后的余数：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-R&quot;&gt;&amp;gt; 9 %% 2
[1] 1
&amp;gt; 9 %% 4
[1] 1
&amp;gt; 9 %% 3
[1] 0
&amp;gt; 11 % 4
错误: unexpected input in &quot;11 % 4&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在使用时需要注意的是有两个百分号组成，输入错误则会得上上述错误提示。&lt;/p&gt;
&lt;p&gt;幂运算跟数学中的幂运算含义一致，&lt;code&gt;2^3&lt;/code&gt; 代表的是2的3次幂：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-R&quot;&gt;&amp;gt; 2 ^ 3
[1] 8
&amp;gt; 3 ^ 2
[1] 9
&amp;gt; 2 ^ 10
[1] 1024
&amp;gt; 2 ^ 100
[1] 1.267651e+30
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;r-语言中的变量&quot;&gt;R 语言中的变量&lt;/h2&gt;
&lt;p&gt;在使用 &lt;code&gt;R&lt;/code&gt; 语言时，我们通常很难一步到位得到最终的结果，需要进行一些复杂的计算。这时我们便需要使用变量来存放计算得到的中间结果。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;R&lt;/code&gt; 语言中，可以将变量想象成一个盒子，我们可以将任何数据暂存到这个盒子里，但同一时刻，这个盒子只能保存一个数据，如果被多次赋值，则只会保存最后一次放入的数据。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;R&lt;/code&gt; 语言中的赋值符号是 &lt;code&gt;-&amp;gt;&lt;/code&gt;，虽然也可以使用 &lt;code&gt;=&lt;/code&gt; 进行赋值，但强烈建议不要这样做，这样不仅显得不专业，而且在一些情况下会出现问题。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-R&quot;&gt;&amp;gt; x &amp;lt;- 3
&amp;gt; x &amp;lt;- 4
&amp;gt; x &amp;lt;- 9
&amp;gt; x
[1] 9
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;R&lt;/code&gt; 语言中的变量不需要事先声明，直接使用即可。如果使用了一个之前没有出现过的变量，则会创建一个新的变量。&lt;code&gt;R&lt;/code&gt; 语言中变量是区分大小写的，&lt;code&gt;x&lt;/code&gt; 与 &lt;code&gt;X&lt;/code&gt; 是两个不同的变量。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-R&quot;&gt;&amp;gt; X
错误: 找不到对象'X'
&amp;gt; X &amp;lt;- 1
&amp;gt; X &amp;lt;- 3
&amp;gt; X
[1] 3
&amp;gt; x
[1] 9
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;变量都是有名字的，比如&lt;code&gt;x&lt;/code&gt;、&lt;code&gt;y&lt;/code&gt;、&lt;code&gt;stu_score&lt;/code&gt;，变量的命名必须满足以下规则：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;只能使用字母（区分大小写）、数字、“_”（下划线）、“.”（英文句号），不能有中文、空格和其它特殊字符存在&lt;/li&gt;
&lt;li&gt;不能以数字、下划线开头，开头必须是英文字母或者点&lt;/li&gt;
&lt;li&gt;可以以点号开头，但点号后面的符号不能是数字&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在 &lt;code&gt;R&lt;/code&gt; 语言中，如果非要搞一些骚操作，用一些奇怪的变量名，也不是不可以，需要用反引号来包裹。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-R&quot;&gt;&amp;gt; `* 90` &amp;lt;- 10
&amp;gt; `* 90`
[1] 10
&amp;gt; `变量` &amp;lt;- 20
&amp;gt; `变量`
[1] 20
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然，不建议这样做，变量取名最好简单且有意义，这样可以减少与其他人的沟通成本以及日后的理解成本。&lt;/p&gt;
&lt;h2 id=&quot;r-语言中的基本数据类型&quot;&gt;R 语言中的基本数据类型&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;R&lt;/code&gt; 语言中主要数据类型有：向量、列表、矩阵、因子、数据框、数组。这些会在后面的文章中进行介绍，本篇只介绍基本的几种数据类型。&lt;/p&gt;
&lt;h3 id=&quot;1-逻辑型logical&quot;&gt;1. 逻辑型(logical)&lt;/h3&gt;
&lt;p&gt;逻辑型数据有两种可能的值，&lt;code&gt;TRUE&lt;/code&gt; 或 &lt;code&gt;FALSE&lt;/code&gt; 。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-R&quot;&gt;&amp;gt; v &amp;lt;- TRUE
&amp;gt; class(v)
[1] &quot;logical&quot;
&amp;gt; y &amp;lt;- FALSE
&amp;gt; class(v)
[1] &quot;logical&quot;
&amp;gt; y &amp;lt;- false
错误: 找不到对象'false'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;class&lt;/code&gt; 函数可以获取变量的类型信息，可以看到，变量 &lt;code&gt;v&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 都是 &lt;code&gt;logical&lt;/code&gt; 类型。需要注意的是 &lt;code&gt;TRUE&lt;/code&gt; 和 &lt;code&gt;FALSE&lt;/code&gt; 必须全部大写，否则会出现上面的错误提示。&lt;/p&gt;
&lt;h3 id=&quot;2-数值型numeric&quot;&gt;2. 数值型(numeric)&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;R&lt;/code&gt; 语言中数字的默认类型为数值型，在运算时需要注意其精度问题，当整数部分大于等于7位时，将舍弃小数部分，当整数部分小于7位时，与小数部分一起最多保留7位数字。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-R&quot;&gt;&amp;gt; i &amp;lt;- 10
&amp;gt; class(i)
[1] &quot;numeric&quot;
&amp;gt; j &amp;lt;- 11.1
&amp;gt; class(j)
[1] &quot;numeric&quot;
&amp;gt; k &amp;lt;- 1.1234567890
&amp;gt; class(k)
[1] &quot;numeric&quot;
&amp;gt; k
[1] 1.123457
&amp;gt; k &amp;lt;- 123456789.123456789
&amp;gt; k
[1] 123456789
&amp;gt; k &amp;lt;- 1234567.123456789
&amp;gt; k
[1] 1234567
&amp;gt; k &amp;lt;- 123456.123456789
&amp;gt; k
[1] 123456.1
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;3-整数型integer&quot;&gt;3. 整数型(integer)&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;R&lt;/code&gt; 语言中，整数型需要使用数字+L来表示，如：&lt;code&gt;2L&lt;/code&gt;、&lt;code&gt;11L&lt;/code&gt;、&lt;code&gt;-10L&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-R&quot;&gt;&amp;gt; i &amp;lt;- 1L
&amp;gt; class(i)
[1] &quot;integer&quot;
&amp;gt; j &amp;lt;- 22L
&amp;gt; class(j)
[1] &quot;integer&quot;
&amp;gt; k &amp;lt;- -10L
&amp;gt; class(k)
[1] &quot;integer&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;4-字符型character&quot;&gt;4. 字符型(character)&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;R&lt;/code&gt; 语言中字符型即字符串类型，通常为用单引号或双引号包围的字符串。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-R&quot;&gt;&amp;gt; name &amp;lt;- &quot;Frank&quot;
&amp;gt; class(name)
[1] &quot;character&quot;
&amp;gt; doc_name &amp;lt;- &quot;study.mp4&quot;
&amp;gt; class(doc_name)
[1] &quot;character&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;5-复数型complex&quot;&gt;5. 复数型(Complex)&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;R&lt;/code&gt; 语言是支持复数计算的，复数也是 &lt;code&gt;R&lt;/code&gt; 语言的基本类型之一。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-R&quot;&gt;&amp;gt; c1 &amp;lt;- 3 + 2i
&amp;gt; class(c1)
[1] &quot;complex&quot;
&amp;gt; c2 &amp;lt;-6 - 3i
&amp;gt; class(c2)
[1] &quot;complex&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;6-原型raw&quot;&gt;6. 原型(Raw)&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;R&lt;/code&gt; 语言还有一种不太常见的基本数据类型，叫原型(&lt;code&gt;raw&lt;/code&gt;)。&lt;code&gt;raw&lt;/code&gt; 类型是直接使用其二进制内容来进行保存和使用的类型。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-R&quot;&gt;&amp;gt; v &amp;lt;- charToRaw(&quot;Hello&quot;)
&amp;gt; class(v)
[1] &quot;raw&quot;
&amp;gt; v
[1] 48 65 6c 6c 6f
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;如何判断变量的类型&quot;&gt;如何判断变量的类型&lt;/h3&gt;
&lt;p&gt;当我们拿到一个变量之后，如何判断它的数据类型呢？上面的例子中，其实已经有所提及，使用 &lt;code&gt;class()&lt;/code&gt; 函数可以简单方便的查看变量的类型，但还有更简单的方式，为了判断某个变量&lt;code&gt;x&lt;/code&gt; 保存的基本类型，可以用 &lt;code&gt;is.xxx()&lt;/code&gt; 类函数，如&lt;code&gt;is.integer(x)&lt;/code&gt;, &lt;code&gt;is.double(x)&lt;/code&gt;, &lt;code&gt;is.numeric(x)&lt;/code&gt;, &lt;code&gt;is.logical(x)&lt;/code&gt;, &lt;code&gt;is.character(x)&lt;/code&gt;, &lt;code&gt;is.complex(x)&lt;/code&gt;, &lt;code&gt;is.raw(x)&lt;/code&gt;。 其中 &lt;code&gt;is.numeric(x)&lt;/code&gt; 对 &lt;code&gt;integer&lt;/code&gt; 和 &lt;code&gt;double&lt;/code&gt; 内容都返回真值。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-R&quot;&gt;&amp;gt; is.character(s)
[1] TRUE
&amp;gt; is.character(v)
[1] FALSE
&amp;gt; is.raw(v)
[1] TRUE
&amp;gt; is.integer(i)
[1] TRUE
&amp;gt; is.numeric(i)
[1] TRUE
&amp;gt; is.complex(c1)
[1] TRUE
&amp;gt; is.integer(c1)
[1] FALSE
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;至此，本篇就告一段落了，相信通过本篇的学习，对 &lt;code&gt;R&lt;/code&gt; 语言的基本数据类型能有一个整体的掌握，别忘了回顾一下之前的问题，这些你都了解了吗：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;R&lt;/code&gt; 语言有哪些基本操作&lt;/li&gt;
&lt;li&gt;什么是变量，以及如何给变量赋值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;R&lt;/code&gt; 语言有哪些基本数据类型，如何确定变量的数据类型&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;之后的篇章中，将会继续介绍 &lt;code&gt;R&lt;/code&gt; 语言的各方各面，让 &lt;code&gt;R&lt;/code&gt; 语言能为我们的数据分析提供更强力的支持！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1043143/202011/1043143-20201128082031108-2075576963.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 28 Nov 2020 00:19:00 +0000</pubDate>
<dc:creator>弗兰克的猫</dc:creator>
<og:description>说明 在前一篇中，我们介绍了 R 语言和 R Studio 的安装，并简单的介绍了一个示例，接下来让我们由浅入深的学习 R 语言的相关知识。 本篇将主要介绍 R 语言的基本操作、变量和几种基本数据类型</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mfrank/p/14051513.html</dc:identifier>
</item>
<item>
<title>[从源码学设计]蚂蚁金服SOFARegistry网络操作之连接管理 - 罗西的思考</title>
<link>http://www.cnblogs.com/rossiXYZ/p/14051509.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rossiXYZ/p/14051509.html</guid>
<description>&lt;p&gt;SOFARegistry 是蚂蚁金服开源的一个生产级、高时效、高可用的服务注册中心。本系列文章重点在于分析设计和架构，即利用多篇文章，从多个角度反推总结 DataServer 或者 SOFARegistry 的实现机制和架构思路，让大家借以学习阿里如何设计。本文为第三篇，介绍SOFARegistry网络操作之连接管理。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;438.11785923182&quot;&gt;


&lt;h2 id=&quot;0x00-摘要&quot;&gt;0x00 摘要&lt;/h2&gt;
&lt;p&gt;SOFARegistry 是蚂蚁金服开源的一个生产级、高时效、高可用的服务注册中心。&lt;/p&gt;
&lt;p&gt;本系列文章重点在于分析设计和架构，即利用多篇文章，从多个角度反推总结 DataServer 或者 SOFARegistry 的实现机制和架构思路，让大家借以学习阿里如何设计。&lt;/p&gt;
&lt;p&gt;本文为第三篇，介绍SOFARegistry网络操作之连接管理。&lt;/p&gt;
&lt;h2 id=&quot;0x01-业务领域&quot;&gt;0x01 业务领域&lt;/h2&gt;
&lt;p&gt;上文我们讲解了SOFARegistry的网络封装和操作，本文继续网络相关部分。&lt;/p&gt;
&lt;p&gt;虽然SOFABolt底层已经做了连接管理，比如有Manager，pool，但是SOFARegistry在上层结合业务也做了连接管理，很有特色，所以我们专文讲解。&lt;/p&gt;
&lt;h3 id=&quot;11-应用场景&quot;&gt;1.1 应用场景&lt;/h3&gt;
&lt;p&gt;这里我们集中从DataServer角度出发讲解，此处和业务紧密结合。&lt;/p&gt;
&lt;p&gt;让我们大致想想DataServer需要管理哪些连接或者类似概念。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;MetaServer Connection：本DataServer与Meta Server的连接，用来和Meta Server交互；&lt;/li&gt;
&lt;li&gt;DataServer Connection：本DataServer与其他dataServer的连接，用来数据同步；&lt;/li&gt;
&lt;li&gt;扩展开来，其他Data Server节点也需要管理；&lt;/li&gt;
&lt;li&gt;SessionServer Connection，本DataServer与Session server的连接，这个非常复杂，这里会重点讲解；&lt;/li&gt;
&lt;li&gt;在SessionServer方面，又需要区分具体每个Publisher；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这就让我们来思考几个问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;究竟什么可以唯一标示一个SessionServer？&lt;/li&gt;
&lt;li&gt;什么可以唯一标示一个Publisher？ip : port？或者其他？&lt;/li&gt;
&lt;li&gt;业务上有没有特殊考虑的需要？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;具体我们在后文会详述阿里的思路。&lt;/p&gt;
&lt;h2 id=&quot;0x02-管理内容&quot;&gt;0x02 管理内容&lt;/h2&gt;
&lt;h3 id=&quot;21-连接管理&quot;&gt;2.1 连接管理&lt;/h3&gt;
&lt;p&gt;首先讲讲普遍意义的连接管理。&lt;/p&gt;
&lt;p&gt;连接管理是网络操作中的核心。我们知道，一次 tcp 请求大致分为三个步骤：建立连接、通信、关闭连接。每次建立新连接都会经历三次握手，中间包含三次网络传输，对于高并发的系统，这是一笔不小的负担；关闭连接同样如此。为了减少每次网络调用请求的开销，对连接进行管理、复用，可以极大的提高系统的性能。&lt;/p&gt;
&lt;p&gt;为了提高通信效率，我们需要考虑复用连接，减少 TCP 三次握手的次数，因此需要有连接管理的机制。&lt;/p&gt;
&lt;p&gt;关于连接管理，&lt;u&gt;SOFARegistry有两维度层次的连接管理，分别是 Connection 和 Node&lt;/u&gt;。&lt;/p&gt;
&lt;h3 id=&quot;22-管理内容&quot;&gt;2.2 管理内容&lt;/h3&gt;
&lt;p&gt;普遍意义的连接管理，通常需要处理：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;连接创建与销毁&lt;/li&gt;
&lt;li&gt;心跳管理&lt;/li&gt;
&lt;li&gt;空闲连接管理&lt;/li&gt;
&lt;li&gt;断线重连&lt;/li&gt;
&lt;li&gt;慢连接处理&lt;/li&gt;
&lt;li&gt;作为一个框架，当然还需要把各种连接事件分派给用户进行定制&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;u&gt;因为SOFABolt底层已经做了底层连接管理，所以SOFARegistry只要做顶层部分连接管理即可，就是从业务角度区分保存连接&lt;/u&gt;。&lt;/p&gt;
&lt;h2 id=&quot;0x03-connection管理&quot;&gt;0x03 Connection管理&lt;/h2&gt;
&lt;h3 id=&quot;31-connection对象&quot;&gt;3.1 Connection对象&lt;/h3&gt;
&lt;p&gt;这里说的Connection我们特指&lt;u&gt;&lt;strong&gt;sofa-bolt的Connection对象&lt;/strong&gt;&lt;/u&gt;&lt;code&gt;com.alipay.remoting.Connection&lt;/code&gt;。前文提到，SOFARegistry把sofa-bolt的Connection对象直接暴露出来。&lt;/p&gt;
&lt;p&gt;面向连接的TCP协议要求每次peer间通信前建立一条TCP连接，该连接可抽象为一个4元组（four-tuple，有时也称socket pair）：&lt;code&gt;socket（localIp, localPort, remoteIp, remotePort ）&lt;/code&gt;，这4个元素唯一地代表一条TCP连接。&lt;/p&gt;
&lt;p&gt;在Netty中用Channel来表示一条TCP连接，&lt;u&gt;在sofa-bolt使用Connection对象来抽象一个连接，一个连接在client跟server端各用一个connection对象表示&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;有了Connection这个抽象之后，自然的需要提供接口来管理Connection, 这个接口就是ConnectionFactory。&lt;/p&gt;
&lt;p&gt;那么Connection是如何跟Netty进行联动呢。我们知道在Netty中，client连接到server后，server会回调&lt;code&gt;initChannel&lt;/code&gt;方法，在这个方法我们会初始化各种事件handler，sofa-bolt就在这里创建Connection，并在Netty的Channel对象上打上Connection标，后续通过Channel就可以直接找到这个Connection。&lt;/p&gt;
&lt;h3 id=&quot;32-connection类定义&quot;&gt;3.2 Connection类定义&lt;/h3&gt;
&lt;p&gt;Connection其删减版定义如下，可以看到&lt;u&gt;其主要成员就是 Netty channel 实例&lt;/u&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Connection {

    private Channel                                                               channel;

    private final ConcurrentHashMap&amp;lt;Integer, InvokeFuture&amp;gt;                        invokeFutureMap  = new ConcurrentHashMap&amp;lt;Integer, InvokeFuture&amp;gt;(4);

    /** Attribute key for connection */
    public static final AttributeKey&amp;lt;Connection&amp;gt;                                  CONNECTION       = AttributeKey.valueOf(&quot;connection&quot;);
  
    /** Attribute key for heartbeat count */
    public static final AttributeKey&amp;lt;Integer&amp;gt;                                     HEARTBEAT_COUNT  = AttributeKey.valueOf(&quot;heartbeatCount&quot;);

    /** Attribute key for heartbeat switch for each connection */
    public static final AttributeKey&amp;lt;Boolean&amp;gt;                                     HEARTBEAT_SWITCH = AttributeKey.valueOf(&quot;heartbeatSwitch&quot;);

    /** Attribute key for protocol */
    public static final AttributeKey&amp;lt;ProtocolCode&amp;gt;                                PROTOCOL         = AttributeKey.valueOf(&quot;protocol&quot;);

    /** Attribute key for version */
    public static final AttributeKey&amp;lt;Byte&amp;gt;                                        VERSION          = AttributeKey.valueOf(&quot;version&quot;);

    private Url                                                                   url;

    private final ConcurrentHashMap&amp;lt;Integer/* id */, String/* poolKey */&amp;gt;       id2PoolKey       = new ConcurrentHashMap&amp;lt;Integer, String&amp;gt;(256);

    private Set&amp;lt;String&amp;gt;                                                           poolKeys         = new ConcurrentHashSet&amp;lt;String&amp;gt;();

    private final ConcurrentHashMap&amp;lt;String/* attr key*/, Object /*attr value*/&amp;gt; attributes       = new ConcurrentHashMap&amp;lt;String, Object&amp;gt;();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;省去 AtributeKey 类型定义以及 Log 配置，以上是Connection中主要的成员变量。包括几个方面:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;连接：Channel、Url&lt;/li&gt;
&lt;li&gt;版本：protocolCode、version&lt;/li&gt;
&lt;li&gt;调用：invokeFutureMap&lt;/li&gt;
&lt;li&gt;附着：attributes&lt;/li&gt;
&lt;li&gt;引用：referenceCount、id2PoolKey、poolKeys&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里提一下 protocolCode 和 version，版本信息会被携带至对端，用于连接的协商。总的来说，&lt;u&gt;通过对于 Channel 的包装，Connection 提供了丰富的上下文及引用信息，是 SOFABolt 连接管理的直接对象&lt;/u&gt;。&lt;/p&gt;
&lt;h3 id=&quot;33-connectionfactory&quot;&gt;3.3 ConnectionFactory&lt;/h3&gt;
&lt;p&gt;SOFARegistry建立了ConnectionFactory 连接工厂，负责创建连接、检测连接等。&lt;/p&gt;
&lt;p&gt;这里我对Connection进行了种类，分类是我从业务角度出发，强行分为三种Connection，只是为了讲解方便。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;MetaServerConnectionFactory，是Meta Server的连接，用来和Meta Server交互。&lt;/li&gt;
&lt;li&gt;DataServerConnectionFactory ，是其他dataServer的连接，用来数据同步；&lt;/li&gt;
&lt;li&gt;SessionServerConnectionFactory，是Session server的连接，这个非常复杂，后续会重点讲解。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;34-metaserverconnectionfactory&quot;&gt;3.4 MetaServerConnectionFactory&lt;/h3&gt;
&lt;p&gt;MetaServerConnectionFactory 就是用来对&lt;code&gt;com.alipay.remoting.Connection&lt;/code&gt;进行连接管理。&lt;/p&gt;
&lt;p&gt;&lt;u&gt;其核心变量是一个双层Map，可以理解为一个矩阵，其维度是 Map&amp;lt;dataCenter, Map&amp;lt;ip, Connection&amp;gt;&amp;gt;&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;其内部函数比较简单，望名生意。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class MetaServerConnectionFactory {

    private final Map&amp;lt;String, Map&amp;lt;String, Connection&amp;gt;&amp;gt; MAP = new ConcurrentHashMap&amp;lt;&amp;gt;();

    /**
     * @param dataCenter
     * @param ip
     * @param connection
     */
    public void register(String dataCenter, String ip, Connection connection) {

        Map&amp;lt;String, Connection&amp;gt; connectionMap = MAP.get(dataCenter);
        if (connectionMap == null) {
            Map&amp;lt;String, Connection&amp;gt; newConnectionMap = new ConcurrentHashMap&amp;lt;&amp;gt;();
            connectionMap = MAP.putIfAbsent(dataCenter, newConnectionMap);
            if (connectionMap == null) {
                connectionMap = newConnectionMap;
            }
        }

        connectionMap.put(ip, connection);
    }

    /**
     * @param dataCenter
     * @param ip
     */
    public Connection getConnection(String dataCenter, String ip) {
        if (MAP.containsKey(dataCenter)) {
            Map&amp;lt;String, Connection&amp;gt; map = MAP.get(dataCenter);
            if (map.containsKey(ip)) {
                return map.get(ip);
            }
        }
        return null;
    }

    /**
     * @param dataCenter
     */
    public Map&amp;lt;String, Connection&amp;gt; getConnections(String dataCenter) {
        if (MAP.containsKey(dataCenter)) {
            return MAP.get(dataCenter);
        }
        return new HashMap&amp;lt;&amp;gt;();
    }

    /**
     * @param dataCenter
     */
    public Set&amp;lt;String&amp;gt; getIps(String dataCenter) {
        if (MAP.containsKey(dataCenter)) {
            Map&amp;lt;String, Connection&amp;gt; map = MAP.get(dataCenter);
            if (map != null) {
                return map.keySet();
            }
        }
        return new HashSet&amp;lt;&amp;gt;();
    }

    /**
     * @param dataCenter
     */
    public void remove(String dataCenter) {
        Map&amp;lt;String, Connection&amp;gt; map = getConnections(dataCenter);
        if (!map.isEmpty()) {
            for (Connection connection : map.values()) {
                if (connection.isFine()) {
                    connection.close();
                }
            }
        }
        MAP.remove(dataCenter);
    }

    /**
     * @param dataCenter
     * @param ip
     */
    public void remove(String dataCenter, String ip) {
        if (MAP.containsKey(dataCenter)) {
            Map&amp;lt;String, Connection&amp;gt; map = MAP.get(dataCenter);
            if (map != null) {
                map.remove(ip);
            }
        }
    }

    public Set&amp;lt;String&amp;gt; getAllDataCenters() {
        return MAP.keySet();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;35-dataserverconnectionfactory&quot;&gt;3.5 DataServerConnectionFactory&lt;/h3&gt;
&lt;p&gt;DataServerConnectionFactory 就是用来对&lt;code&gt;com.alipay.remoting.Connection&lt;/code&gt;进行连接管理。&lt;/p&gt;
&lt;p&gt;&lt;u&gt;其核心变量是以ip:port作为key，Connection作为value的一个Map&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;其内部函数比较简单，望名生意。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;import com.alipay.remoting.Connection;

/**
 * the factory to hold connections that other dataservers connected to local server
 */
public class DataServerConnectionFactory {

    /**
     * collection of connections
     * key:connectId ip:port
     */
    private final Map&amp;lt;String, Connection&amp;gt; MAP = new ConcurrentHashMap&amp;lt;&amp;gt;();

    /**
     * register connection
     *
     * @param connection
     */
    public void register(Connection connection) {
        MAP.put(getConnectId(connection), connection);
    }

    /**
     * remove connection by specific ip+port
     *
     * @param connection
     */
    public void remove(Connection connection) {
        MAP.remove(getConnectId(connection));
    }

    /**
     * get connection by ip
     *
     * @param ip
     * @return
     */
    public Connection getConnection(String ip) {
        return MAP.values().stream().filter(connection -&amp;gt; ip.equals(connection.getRemoteIP()) &amp;amp;&amp;amp; connection.isFine()).findFirst().orElse(null);
    }

    private String getConnectId(Connection connection) {
        return connection.getRemoteIP() + &quot;:&quot; + connection.getRemotePort();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;351-注册&quot;&gt;3.5.1 注册&lt;/h4&gt;
&lt;p&gt;当需要管理连接时候，可以通过如下来进行注册。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void connected(Channel channel) throws RemotingException {
    super.connected(channel);
    dataServerConnectionFactory.register(((BoltChannel) channel).getConnection());
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样往ConcurrentHashMap client放入，是根据IP和port构建了url，然后url作为key。&lt;/p&gt;
&lt;h4 id=&quot;352-获取&quot;&gt;3.5.2 获取&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;com.alipay.remoting.Connection&lt;/code&gt; 可以通过Channel进行获取。&lt;/p&gt;
&lt;p&gt;DataNodeExchanger就采用如下方式获取Client。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;conn = ((BoltChannel) dataNodeExchanger.connect(new URL(ip, dataServerConfig
    .getSyncDataPort()))).getConnection();
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;353-datasyncserverconnectionhandler&quot;&gt;3.5.3 DataSyncServerConnectionHandler&lt;/h4&gt;
&lt;p&gt;有了注册与获取，接下来我们看看连接事件响应。&lt;/p&gt;
&lt;p&gt;DataSyncServerConnectionHandler 是 server 的handler。&lt;/p&gt;
&lt;p&gt;前文提到了，DataSyncServerConnectionHandler是连接事件处理器 (ConnectionEventProcessor)，用来监听建连事件（ConnectionEventType.CONNECT）与断连事件（ConnectionEventType.CLOSE）。&lt;/p&gt;
&lt;p&gt;这里就是针对各种事件，简单的对Connection做相应维护。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class DataSyncServerConnectionHandler extends AbstractServerHandler {
    @Autowired
    private DataServerConnectionFactory dataServerConnectionFactory;

    @Override
    public ChannelHandler.HandlerType getType() {
        return ChannelHandler.HandlerType.LISENTER;
    }

    @Override
    public void connected(Channel channel) throws RemotingException {
        super.connected(channel);
        dataServerConnectionFactory.register(((BoltChannel) channel).getConnection());
    }

    @Override
    public void disconnected(Channel channel) throws RemotingException {
        super.disconnected(channel);
        dataServerConnectionFactory.remove(((BoltChannel) channel).getConnection());
    }

    @Override
    protected Node.NodeType getConnectNodeType() {
        return Node.NodeType.DATA;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;36-sessionserverconnectionfactory&quot;&gt;3.6 SessionServerConnectionFactory&lt;/h3&gt;
&lt;p&gt;SessionServerConnectionFactory 包括复杂的逻辑。&lt;/p&gt;
&lt;h4 id=&quot;361-问题&quot;&gt;3.6.1 问题&lt;/h4&gt;
&lt;p&gt;回顾前面问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;究竟什么可以唯一标示一个SessionServer？&lt;/li&gt;
&lt;li&gt;什么可以唯一标示一个Publisher？&lt;/li&gt;
&lt;li&gt;ip : port？或者其他？&lt;/li&gt;
&lt;li&gt;业务上有没有特殊考虑的需要？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面我们就一一看看阿里如何处理。&lt;/p&gt;
&lt;h4 id=&quot;362-逻辑概念和关系&quot;&gt;3.6.2 逻辑概念和关系&lt;/h4&gt;
&lt;p&gt;首先要讲讲阿里的几个逻辑概念：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;process Id&lt;/strong&gt; 代表了Session Server，格式是类似uid的构建，每个Session Server有一个唯一的process Id，Session Server与process Id是一对一的关系；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Connection&lt;/strong&gt; 就是一个 Session Server 和 Data Server 之间的 Connection；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;connect Id&lt;/strong&gt; 代表了Publisher，格式是 ip : port。connect Id与Publisher是一对一的关系；&lt;/li&gt;
&lt;li&gt;一个Session Server包括许多Publiser，即许多connection id；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Session Server address&lt;/strong&gt; 是一个 ip : port 的组合，代表一个 Connection 的 session server 那一端；&lt;/li&gt;
&lt;li&gt;一个 Session Server 可能对于一个data Server有多个连接；&lt;u&gt;这个目前原因不知，没有发现业务原因&lt;/u&gt;，可能推测如下：因为连接敏感性，网络不稳定性，所以SOFABolt重连时候会选择一个新端口，所以会有多个Connection存在。所以一个processID对应多个sessionConnAddress；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;具体就是，&lt;u&gt;SOFARegistry 将服务数据 （PublisherRegister） 和 服务发布者 （Publisher） 的连接的生命周期绑定在一起&lt;/u&gt;：每个 PublisherRegister 定义属性 connId，connId 由注册本次服务的 Publisher 的连接标识 （IP 和 Port）构成，也就是只要该 Publisher 和 SessionServer 断连，服务信息数据即失效。客户端重新建连成功后重新注册服务数据，重新注册的服务数据会被当成新的数据，考虑更换长连接后 Publisher 的 connId 是 Renew 新生成的。&lt;/p&gt;
&lt;h4 id=&quot;363-示例图&quot;&gt;3.6.3 示例图&lt;/h4&gt;
&lt;p&gt;我们假设一个Session server内部有两个 Publisher，都连接到一个Data Server上。&lt;/p&gt;
&lt;p&gt;这些 address 格式都是 ip : port，举例如下：&lt;/p&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;SessionServer address 1 是 ：1.1.2.3 : 1&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;SessionServer address 2 是 ：1.1.2.3 : 2&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;SessionServer address 3 是 ：1.1.2.3 : 3&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;SessionServer address 4 是 ：1.1.2.3 : 4&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;DataServer address 1 是 ：2.2.2.3 : 1&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;DataServer address 2 是 ：2.2.2.3 : 2&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;具体逻辑如图：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    +----------+                        +----------+
    |  Client  |                        |  Client  |
    +----+-----+                        +----+-----+
         |                                   |
         |                                   |
         |                                   |
         |                                   |
         |  SessionServer address 1          |   SessionServer address 2
         v                                   v
+--------+-----------------------------------+----------------+
|                Session Server(process Id)                   |
|                                                             |
| +------------------------+        +-----------------------+ |
| |  Publisher(connect Id) |  ...   | Publisher(connect Id) | |
| +------------------------+        +-----------------------+ |
+-------------------------------------------------------------+
         | SessionServer address 3                  |  SessionServer address 4
         |                                          |
         |                                          |
         |                                          |
         |                                          |
         +----------&amp;gt;  +---------------+  &amp;lt;---------+
DataServer address 1   |  Data Server  |    DataServer address 2
                       +---------------+

&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;364-主要变量&quot;&gt;3.6.4 主要变量&lt;/h4&gt;
&lt;p&gt;所以，SessionServerConnectionFactory的几个变量就对应了上述这些逻辑关系，具体如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;SESSION_CONN_PROCESS_ID_MAP ： Map&amp;lt;SessionServer address, SessionServer processId&amp;gt;，这个代表了怎么从 SessionServer address 找到 SessionServer processId，是一对一的关系；&lt;/li&gt;
&lt;li&gt;PROCESS_ID_CONNECT_ID_MAP ： Map&amp;lt;SessionServer processId, Set&amp;lt;ip:port of clients&amp;gt; &amp;gt;，这个代表了&lt;u&gt;一个Session Server 包括了哪些Publiser&lt;/u&gt;；&lt;/li&gt;
&lt;li&gt;PROCESS_ID_SESSION_CONN_MAP ： Map&amp;lt;SessionServer processId, pair(SessionServer address, SessionServer connection)&amp;gt;，这代表了&lt;u&gt;一个 Session Server 包括哪些 Connection&lt;/u&gt;，每个Connection 被其Session Server 端的address 唯一确定；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这些都代表了&lt;u&gt;本 Data Server 和 其 Session Server 之间的关系&lt;/u&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;+-----------------------------------------------------------------------------------------+     +--------------------------------+
|  SessionServerConnectionFactory                                                         |     |        SessionServer           |
|                                                                                         |     |                                |
|                                                                                         |     |   +-------------------------+  |
|  +---------------------------------------------------------+                            |     |   |   SessionServer address |  |
|  | SESSION_CONN_PROCESS_ID_MAP                             |                            |     |   |                         |  |
|  |                                                         |                            |     |   |  +----------------+     |  |
|  |                                                         | +-----------------------------------&amp;gt;+  |   process Id   |     |  |
|  |    Map&amp;lt;SessionServer address, SessionServer processId&amp;gt;  |                            |     |   +-------------------------+  |
|  |                                                         |                            |     |      |                |        |
|  +---------------------------------------------------------+                            |     |      |   Publisher    |        |
|                                                                                         |     |      +--+-------------+        |
|                                                                                         |     |         ^                      |
|   +---------------------------------------------------------+                           |     |         |                      |
|   | PROCESS_ID_CONNECT_ID_MAP                               |                           |     +------------------------+-------+
|   |                                                         |                           |               |              ^
|   | Map&amp;lt;SessionServer processId, Set&amp;lt;ip:port of clients&amp;gt; &amp;gt;  +-------------------------------------------+              |
|   |                                                         |                           |                              |
|   +---------------------------------------------------------+                           |                              |
|                                                                                         |                              |
|                                                                                         |                              |
|  +------------------------------------------------------------------------------------+ |       +------------+         |
|  |PROCESS_ID_SESSION_CONN_MAP                                                         +-------&amp;gt; | Connection +---------+
|  |                                                                                    | |       +------------+
|  |                                                                                    | |
|  |Map&amp;lt;SessionServer processId, pair(SessionServer address, SessionServer connection)&amp;gt; | |
|  |                                                                                    | |
|  +------------------------------------------------------------------------------------+ |
+-----------------------------------------------------------------------------------------+
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;手机上如下图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1850883/202011/1850883-20201128080731444-1800054878.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;具体类定义如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class SessionServerConnectionFactory {

    private static final int               DELAY                       = 30 * 1000;
    private static final Map               EMPTY_MAP                   = new HashMap(0);

    /**
     * key  :   SessionServer address
     * value:   SessionServer processId
     */
    private final Map&amp;lt;String, String&amp;gt;      SESSION_CONN_PROCESS_ID_MAP = new ConcurrentHashMap&amp;lt;&amp;gt;();

    /**
     * key  :   SessionServer processId
     * value:   ip:port of clients
     */
    private final Map&amp;lt;String, Set&amp;lt;String&amp;gt;&amp;gt; PROCESS_ID_CONNECT_ID_MAP   = new ConcurrentHashMap&amp;lt;&amp;gt;();

    /**
     * key  :   SessionServer processId
     * value:   pair(SessionServer address, SessionServer connection)
     */
    private final Map&amp;lt;String, Pair&amp;gt;        PROCESS_ID_SESSION_CONN_MAP = new ConcurrentHashMap&amp;lt;&amp;gt;();

    @Autowired
    private DisconnectEventHandler         disconnectEventHandler;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;365-pair&quot;&gt;3.6.5 Pair&lt;/h4&gt;
&lt;p&gt;这是SessionServerConnectionFactory的内部类。&lt;/p&gt;
&lt;p&gt;PROCESS_ID_SESSION_CONN_MAP是 Map&amp;lt;SessionServer processId, &lt;strong&gt;pair&lt;/strong&gt;(SessionServer address, SessionServer connection)&amp;gt;，代表了一个 Session Server 包括哪些Connection，每个Connection 被其Session Server 端的address 唯一确定。&lt;/p&gt;
&lt;p&gt;Pair就是SessionServer address, SessionServer connection的组合，定义如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private static class Pair {
    private AtomicInteger           roundRobin = new AtomicInteger(-1);
    private Map&amp;lt;String, Connection&amp;gt; connections;
    private String                  lastDisconnectedSession;

    private Pair(Map&amp;lt;String, Connection&amp;gt; connections) {
        this.connections = connections;
    }

    @Override
    public boolean equals(Object o) {
        return connections.equals(((Pair) o).getConnections())
               &amp;amp;&amp;amp; (((Pair) o).lastDisconnectedSession.equals(lastDisconnectedSession));
    }

    /**
     * Getter method for property &amp;lt;tt&amp;gt;connections&amp;lt;/tt&amp;gt;.
     * @return property value of connections
     */
    private Map&amp;lt;String, Connection&amp;gt; getConnections() {
        return connections;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当生成时，Session Server 端的address，这是由InetSocketAddress转换而来。此类用于实现 IP 套接字地址 (IP 地址+端口号)，用于socket 通信；&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void registerSession(String processId, Set&amp;lt;String&amp;gt; connectIds, Connection connection) {
    String sessionConnAddress = NetUtil.toAddressString(connection.getRemoteAddress());

    SESSION_CONN_PROCESS_ID_MAP.put(sessionConnAddress, processId);

    Set&amp;lt;String&amp;gt; connectIdSet = PROCESS_ID_CONNECT_ID_MAP
            .computeIfAbsent(processId, k -&amp;gt; ConcurrentHashMap.newKeySet());
    connectIdSet.addAll(connectIds);

    Pair pair = PROCESS_ID_SESSION_CONN_MAP.computeIfAbsent(processId, k -&amp;gt; new Pair(new ConcurrentHashMap&amp;lt;&amp;gt;()));
    pair.getConnections().put(sessionConnAddress, connection);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;366-processid&quot;&gt;3.6.6 processId&lt;/h4&gt;
&lt;p&gt;processId是在Session Server之中生成，可以看出，是IP，时间戳，循环递增整数构建。这样就可以唯一确定一个SessionServer。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;public class SessionProcessIdGenerator {
    /**
     * Generate session processId.
     */
    public static String generate() {
        String localIp = NetUtil.getLocalSocketAddress().getAddress().getHostAddress();
        if (localIp != null &amp;amp;&amp;amp; !localIp.isEmpty()) {
            return getId(getIPHex(localIp), System.currentTimeMillis(), getNextId());
        }
        return EMPTY_STRING;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;37-sessionserverconnectionfactory业务流程&quot;&gt;3.7 SessionServerConnectionFactory业务流程&lt;/h3&gt;
&lt;p&gt;因为高层连接管理与业务密切耦合，所以我们接下来分析业务。看看调用 SessionServerConnectionFactory的业务流程。&lt;/p&gt;
&lt;p&gt;具体registerSession从何处&lt;strong&gt;调用&lt;/strong&gt;，这就涉及到两个消息：SessionServerRegisterRequest 和PublishDataRequest。即有两个途径会调用。而且&lt;u&gt;业务涉及到Session Server与DataServer&lt;/u&gt;。&lt;/p&gt;
&lt;h4 id=&quot;371-sessionserverregisterrequest&quot;&gt;3.7.1 SessionServerRegisterRequest&lt;/h4&gt;
&lt;p&gt;当重新连接的时候，会统一注册 Session Server 本身包含的所有Publisher。&lt;u&gt;对应在Session Server之中&lt;/u&gt;，如下可以看到：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;从sessionServer获取connectIds。&lt;/li&gt;
&lt;li&gt;建立SessionServerRegisterRequest，然后发送。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class SessionRegisterDataTask extends AbstractSessionTask {
    @Override
    public void setTaskEvent(TaskEvent taskEvent) {

        //taskId create from event
        if (taskEvent.getTaskId() != null) {
            setTaskId(taskEvent.getTaskId());
        }

        Object obj = taskEvent.getEventObj();

        if (obj instanceof BoltChannel) {
            this.channel = (BoltChannel) obj;
        } 
        Server sessionServer = boltExchange.getServer(sessionServerConfig.getServerPort());

        if (sessionServer != null) {

            Collection&amp;lt;Channel&amp;gt; chs = sessionServer.getChannels();
            Set&amp;lt;String&amp;gt; connectIds = new HashSet&amp;lt;&amp;gt;();
            chs.forEach(channel -&amp;gt; connectIds.add(NetUtil.toAddressString(channel.getRemoteAddress())));

            sessionServerRegisterRequest = new SessionServerRegisterRequest(
                    SessionProcessIdGenerator.getSessionProcessId(), connectIds);
        } 
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;u&gt;来到DataServer&lt;/u&gt;，SessionServerRegisterHandler会进行处理调用，用到了sessionServerConnectionFactory。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class SessionServerRegisterHandler extends
                                         AbstractServerHandler&amp;lt;SessionServerRegisterRequest&amp;gt; {
    @Override
    public Object doHandle(Channel channel, SessionServerRegisterRequest request) {
        Set&amp;lt;String&amp;gt; connectIds = request.getConnectIds();
        if (connectIds == null) {
            connectIds = new HashSet&amp;lt;&amp;gt;();
        }
        sessionServerConnectionFactory.registerSession(request.getProcessId(), connectIds,
            ((BoltChannel) channel).getConnection());
        return CommonResponse.buildSuccessResponse();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;372-publishdatarequest&quot;&gt;3.7.2 PublishDataRequest&lt;/h4&gt;
&lt;p&gt;当注册Publisher时候。&lt;u&gt;在Session Server之中&lt;/u&gt;，可以看到建立了请求。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private Request&amp;lt;PublishDataRequest&amp;gt; buildPublishDataRequest(Publisher publisher) {
    return new Request&amp;lt;PublishDataRequest&amp;gt;() {
        private AtomicInteger retryTimes = new AtomicInteger();

        @Override
        public PublishDataRequest getRequestBody() {
            PublishDataRequest publishDataRequest = new PublishDataRequest();
            publishDataRequest.setPublisher(publisher);
            publishDataRequest.setSessionServerProcessId(SessionProcessIdGenerator
                .getSessionProcessId());
            return publishDataRequest;
        }

        @Override
        public URL getRequestUrl() {
            return getUrl(publisher.getDataInfoId());
        }

        @Override
        public AtomicInteger getRetryTimes() {
            return retryTimes;
        }
    };
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;u&gt;在data server之中&lt;/u&gt;，会调用处理，用到了sessionServerConnectionFactory。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class PublishDataHandler extends AbstractServerHandler&amp;lt;PublishDataRequest&amp;gt; {
    @Override
    public Object doHandle(Channel channel, PublishDataRequest request) {
        Publisher publisher = Publisher.internPublisher(request.getPublisher());
        if (forwardService.needForward()) {
            CommonResponse response = new CommonResponse();
            response.setSuccess(false);
            response.setMessage(&quot;Request refused, Server status is not working&quot;);
            return response;
        }

        dataChangeEventCenter.onChange(publisher, dataServerConfig.getLocalDataCenter());

        if (publisher.getPublishType() != PublishType.TEMPORARY) {
            String connectId = WordCache.getInstance().getWordCache(
                publisher.getSourceAddress().getAddressString());
            sessionServerConnectionFactory.registerConnectId(request.getSessionServerProcessId(),
                connectId);
            // record the renew timestamp
            datumLeaseManager.renew(connectId);
        }

        return CommonResponse.buildSuccessResponse();
    }  
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;373-datumleasemanager&quot;&gt;3.7.3 DatumLeaseManager&lt;/h4&gt;
&lt;p&gt;上述代码提到了DatumLeaseManager，这里可以看到就是&lt;u&gt;对connectId，即Publisher进行续约&lt;/u&gt;：&lt;/p&gt;
&lt;p&gt;renew 函数记录本次renew时间戳，启动evict task，如果到期没有renew，就去除。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class DatumLeaseManager implements AfterWorkingProcess {
    /** record the latest heartbeat time for each connectId, format: connectId -&amp;gt; lastRenewTimestamp */
    private final Map&amp;lt;String, Long&amp;gt;            connectIdRenewTimestampMap = new ConcurrentHashMap&amp;lt;&amp;gt;();

    /** lock for connectId , format: connectId -&amp;gt; true */
    private ConcurrentHashMap&amp;lt;String, Boolean&amp;gt; locksForConnectId          = new ConcurrentHashMap();
  
    /**
     * record the renew timestamp
     */
    public void renew(String connectId) {

        // record the renew timestamp
        connectIdRenewTimestampMap.put(connectId, System.currentTimeMillis());
        // try to trigger evict task
        scheduleEvictTask(connectId, 0);
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;0x04-节点管理&quot;&gt;0x04 节点管理&lt;/h2&gt;
&lt;p&gt;除了具体连接之外，&lt;u&gt;SOFARegistry也对Data 节点进行另一个维度的连接管理&lt;/u&gt;。具体在DataServerNodeFactory完成。&lt;/p&gt;
&lt;h3 id=&quot;41-dataservernodefactory&quot;&gt;4.1 DataServerNodeFactory&lt;/h3&gt;
&lt;h4 id=&quot;411-dataservernode&quot;&gt;4.1.1 DataServerNode&lt;/h4&gt;
&lt;p&gt;就是简单的数据结构，没有建立Bean。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class DataServerNode implements HashNode {

    private String     ip;

    private String     dataCenter;

    private Connection connection;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;412-dataservernodefactory&quot;&gt;4.1.2 DataServerNodeFactory&lt;/h4&gt;
&lt;p&gt;对应Node的连接管理 则是 DataServerNodeFactory。&lt;/p&gt;
&lt;p&gt;在具体模块控制上，DataServerNodeFactory拥有自己的Bean。DataServerConnectionFactory 则&lt;u&gt;全部是Static类型，直接static使用&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;DataServerNodeFactory的关键变量有两个：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;MAP是以dataCenter和ip作为维度的一个Node矩阵，是数据节点相关数据；&lt;/li&gt;
&lt;li&gt;CONSISTENT_HASH_MAP则是用dataCenter作为key，ConsistentHash作为value的Map；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;具体定义如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class DataServerNodeFactory {
    /**
     * row:     dataCenter
     * column:  ip
     * value    dataServerNode
     */
    private static final Map&amp;lt;String, Map&amp;lt;String, DataServerNode&amp;gt;&amp;gt;    MAP                 = new ConcurrentHashMap&amp;lt;&amp;gt;();

    /**
     * key:     dataCenter
     * value:   consistentHash
     */
    private static final Map&amp;lt;String, ConsistentHash&amp;lt;DataServerNode&amp;gt;&amp;gt; CONSISTENT_HASH_MAP = new ConcurrentHashMap&amp;lt;&amp;gt;();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;42-业务流程&quot;&gt;4.2 业务流程&lt;/h3&gt;
&lt;h4 id=&quot;421-注册&quot;&gt;4.2.1 注册&lt;/h4&gt;
&lt;p&gt;具体在LocalDataServerChangeEventHandler 和 DataServerChangeEventHandler 全都有涉及。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class LocalDataServerChangeEventHandler extends
                                            AbstractEventHandler&amp;lt;LocalDataServerChangeEvent&amp;gt; {
       private void connectDataServer(String dataCenter, String ip) {
            Connection conn = null;
            for (int tryCount = 0; tryCount &amp;lt; TRY_COUNT; tryCount++) {
                try {
                    conn = ((BoltChannel) dataNodeExchanger.connect(new URL(ip, dataServerConfig.getSyncDataPort()))).getConnection();
                    break;
                } 
            }

            //maybe get dataNode from metaServer,current has not start! register dataNode info to factory,wait for connect task next execute
            DataServerNodeFactory.register(new DataServerNode(ip, dataCenter, conn),
                dataServerConfig);
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以及&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class DataServerChangeEventHandler extends AbstractEventHandler&amp;lt;DataServerChangeEvent&amp;gt; {
   private void connectDataServer(String dataCenter, String ip) {
        Connection conn = null;
        for (int tryCount = 0; tryCount &amp;lt; TRY_COUNT; tryCount++) {
            try {
                conn = ((BoltChannel) dataNodeExchanger.connect(new URL(ip, dataServerConfig
                    .getSyncDataPort()))).getConnection();
                break;
            } catch (Exception e) {
                TimeUtil.randomDelay(3000);
            }
        }
        //maybe get dataNode from metaServer,current has not start! register dataNode info to factory,wait for connect task next execute
        DataServerNodeFactory.register(new DataServerNode(ip, dataCenter, conn), dataServerConfig);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;422-使用&quot;&gt;4.2.2 使用&lt;/h4&gt;
&lt;p&gt;使用就是从MAP与CONSISTENT_HASH_MAP中提取Node，这里把从CONSISTENT_HASH_MAP提取的代码摘录如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * get dataserver by specific datacenter and dataInfoId
 *
 * @param dataCenter
 * @param dataInfoId
 * @return
 */
public static DataServerNode computeDataServerNode(String dataCenter, String dataInfoId) {
    ConsistentHash&amp;lt;DataServerNode&amp;gt; consistentHash = CONSISTENT_HASH_MAP.get(dataCenter);
    if (consistentHash != null) {
        return consistentHash.getNodeFor(dataInfoId);
    }
    return null;
}

public static List&amp;lt;DataServerNode&amp;gt; computeDataServerNodes(String dataCenter, String dataInfoId,
                                                          int backupNodes) {
    ConsistentHash&amp;lt;DataServerNode&amp;gt; consistentHash = CONSISTENT_HASH_MAP.get(dataCenter);
    if (consistentHash != null) {
        return consistentHash.getNUniqueNodesFor(dataInfoId, backupNodes);
    }
    return null;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;0x05-总结&quot;&gt;0x05 总结&lt;/h2&gt;
&lt;p&gt;关于连接管理，&lt;u&gt;SOFARegistry有两维度层次的连接管理，分别是 Connection 和 Node&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;&lt;u&gt;因为SOFABolt底层已经做了底层连接管理，所以SOFARegistry只要做顶层部分连接管理即可，就是从业务角度区分注册，保存，获取连接&lt;/u&gt;。具体就是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Connection 就是一个 Session Server 和 Data Server 之间的 Connection；&lt;/li&gt;
&lt;li&gt;一个 Session Server 可能对于一个data Server有多个连接；&lt;/li&gt;
&lt;li&gt;一个Session Server包括许多Publiser；&lt;/li&gt;
&lt;li&gt;Connection与Publiser一一对应；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;u&gt;SOFARegistry 将服务数据 （PublisherRegister） 和 服务发布者 （Publisher） 的连接的生命周期绑定在一起&lt;/u&gt;：每个 PublisherRegister 定义属性 connId，connId 由注册本次服务的 Publisher 的连接标识 （IP 和 Port）构成。&lt;/p&gt;
&lt;p&gt;只要该 Publisher 和 SessionServer 断连，服务信息数据即失效。客户端重新建连成功后重新注册服务数据，重新注册的服务数据会被当成新的数据，考虑更换长连接后 Publisher 的 connId 是 Renew 新生成的。&lt;/p&gt;
&lt;p&gt;如下图所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;                 +----------+                        +----------+
                 |  Client  |                        |  Client  |
                 +----+-----+                        +----+-----+
                      |                                   |
                      |                                   |
                      |                                   |
                      |                                   |
                      |                                   |
                      |                                   |
             +-------------------------------------------------------------+
             |        |       Session Server(process Id)  |                |
             |        v                                   v                |
             | +------+-----------------+        +--------+--------------+ |
             | |  Publisher(connect Id) |  ...   | Publisher(connect Id) | |
             | +------------------------+        +-----------------------+ |
             +-------------------------------------------------------------+
                      |                                          |
                      |                                          |
                      | Connection                    Connection |
                      |                                          |
                      |                                          |
                      |                                          |
                      v                                          v
+---------------------+------------------------------------------+--------------------+
|  Data Server                                                                        |
|                                                                                     |
|                  Map&amp;lt;SessionServer address, SessionServer processId&amp;gt;                |
|                                                                                     |
|                  Map&amp;lt;SessionServer processId, Set&amp;lt;ip:port of clients&amp;gt; &amp;gt;             |
|                                                                                     |
| Map&amp;lt;SessionServer processId, pair(SessionServer address, SessionServer connection)&amp;gt; |
|                                                                                     |
+-------------------------------------------------------------------------------------+
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;0xff-参考&quot;&gt;0xFF 参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://timyang.net/architecture/cell-distributed-system/&quot;&gt;https://timyang.net/architecture/cell-distributed-system/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/0b069f9658ac&quot;&gt;SOFABolt 源码分析12 - Connection 连接管理设计&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/46d281e12880&quot;&gt;SOFABolt 源码分析2 - RpcServer 服务端启动的设计&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/a8bea57a3242&quot;&gt;SOFABolt 源码分析3 - RpcClient 客户端启动的设计&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Sat, 28 Nov 2020 00:17:00 +0000</pubDate>
<dc:creator>罗西的思考</dc:creator>
<og:description>SOFARegistry 是蚂蚁金服开源的一个生产级、高时效、高可用的服务注册中心。本系列文章重点在于分析设计和架构，即利用多篇文章，从多个角度反推总结 DataServer 或者 SOFARegis</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/rossiXYZ/p/14051509.html</dc:identifier>
</item>
<item>
<title>Mac 上超好用的代码对比工具 beyond compare，对比json差异 - 陈彦斌</title>
<link>http://www.cnblogs.com/chenyanbin/p/14051493.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenyanbin/p/14051493.html</guid>
<description>&lt;p&gt;　　昨天下午，公司业务跑不通，然后开发组长让架构师联系我，给我发一个json和部署到dev上的微服务url，让我去测试下，将发来的json放到json.cn上愣是解析不出来，我就用之前的json请求下dev上的微服务，发现是通的，初次判断是json格式的问题，对比下发来的json和之前的json有啥区别，发现json.cn上还有代码对比功能，效果是下面这样的👇&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202011/1504448-20201128070927330-1244597106.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　对比效果不佳，然后百度，发现beyond compare对比代码效果真心不错，如下👇&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202011/1504448-20201128071246123-525986518.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
链接: https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;pan.baidu.com/s/1eCXTzWgKZYTRzNNjDptsHw  密码: nebt&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Fri, 27 Nov 2020 23:14:00 +0000</pubDate>
<dc:creator>陈彦斌</dc:creator>
<og:description>导读 昨天下午，公司业务跑不通，然后开发组长让架构师联系我，给我发一个json和部署到dev上的微服务url，让我去测试下，将发来的json放到json.cn上愣是解析不出来，我就用之前的json请求</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chenyanbin/p/14051493.html</dc:identifier>
</item>
<item>
<title>JS指定音频audio在某个时间点进行播放，获取当前音频audio的长度，音频时长格式转化 - 追逐时光者</title>
<link>http://www.cnblogs.com/Can-daydayup/p/14049190.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Can-daydayup/p/14049190.html</guid>
<description>&lt;h2&gt;前言：&lt;/h2&gt;
&lt;p&gt; 　　今天接到一个需求，需要获取某个.mp3音频文件的时间长度和指定音频audio在某个时间点进行播放（比如说这个视频有4分钟，我要让它默认从第2秒的时候开始播放），这里当然想到了H5中的audio元素，当然我们平时看这个标签上显示的音频时间格式是时:分:秒的格式的因此需要涉及到秒和时间格式的转化。因为刚开始对这块十分的陌生，最后通过查阅了网上的一些资料，最终完美的把这些功能点做好了。在这里分享一下，希望能够帮助有需要的小伙伴。&lt;/p&gt;
&lt;h2&gt;获取音频时长：&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; getAudioDuration(src) {
            let audio &lt;/span&gt;= document.createElement('audio') &lt;span&gt;//&lt;/span&gt;&lt;span&gt;生成一个audio元素 &lt;/span&gt;
            audio.src = src &lt;span&gt;//&lt;/span&gt;&lt;span&gt;音乐的路径 &lt;/span&gt;
            audio.addEventListener(&quot;canplay&quot;, &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
                console.log(&lt;/span&gt;&quot;音频长度=&amp;gt;&amp;gt;&amp;gt;：&quot;, parseInt(audio.duration) + '秒', '音频时分秒格式：'&lt;span&gt;, timeToMinute(parseInt(audio
                    .duration)));
            });
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;指定音频audio在某个时间点进行播放：&lt;/h2&gt;
&lt;p&gt;指定默认从第20s开始播放效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1336199/202011/1336199-20201128005218563-345990149.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 音频加载完成后的一系列操作&lt;/span&gt;
        &lt;span&gt;function&lt;/span&gt;&lt;span&gt; duration() {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; myVid = document.getElementById(&quot;videoDiv&quot;&lt;span&gt;);
            console.log(&lt;/span&gt;&quot;duration  &quot;&lt;span&gt;, myVid);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (myVid != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; duration;
                myVid.load(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;方法重新加载音频/视频元素&lt;/span&gt;
                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; https://www.w3school.com.cn/tags/av_prop_currenttime.asp&lt;/span&gt;
                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; currentTime 属性设置或返回音频/视频播放的当前位置（以秒计）。&lt;/span&gt;
                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当设置该属性时，播放会跳跃到指定的位置。&lt;/span&gt;
                myVid.currentTime = 20; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;默认指定音频默认从20s的时候开始播放（默认时间为s）&lt;/span&gt;
                myVid.oncanplay = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;duration 属性返回当前音频的长度，以秒计。&lt;/span&gt;
                    console.log(&quot;音频时间&quot;&lt;span&gt;, myVid.duration);
                    console.log(&lt;/span&gt;&quot;时分秒格式转化：&quot;&lt;span&gt;, timeToMinute(myVid.duration))
                }
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;秒转换时分钟00:00:00时分秒格式：&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; timeToMinute(times) {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; t;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (times &amp;gt; -1&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; hour = Math.floor(times / 3600&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; min = Math.floor(times / 60) % 60&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; sec = times % 60&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (hour &amp;lt; 10&lt;span&gt;) {
                    t &lt;/span&gt;= '0' + hour + &quot;:&quot;&lt;span&gt;;
                } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    t &lt;/span&gt;= hour + &quot;:&quot;&lt;span&gt;;
                }

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (min &amp;lt; 10&lt;span&gt;) {
                    t &lt;/span&gt;+= &quot;0&quot;&lt;span&gt;;
                }
                t &lt;/span&gt;+= min + &quot;:&quot;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (sec &amp;lt; 10&lt;span&gt;) {
                    t &lt;/span&gt;+= &quot;0&quot;&lt;span&gt;;
                }
                t &lt;/span&gt;+= sec.toFixed(2&lt;span&gt;);
            }
            t &lt;/span&gt;= t.substring(0, t.length - 3&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; t;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;00:00:00时分秒格式转化为秒：&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; timeEvent(e) {
            let time &lt;/span&gt;=&lt;span&gt; e;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; len = time.split(':'&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (len.length == 3&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; hour = time.split(':')[0&lt;span&gt;];
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; min = time.split(':')[1&lt;span&gt;];
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; sec = time.split(':')[2&lt;span&gt;];
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Number(hour * 3600) + Number(min * 60) +&lt;span&gt; Number(sec);
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (len.length == 2&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; min = time.split(':')[0&lt;span&gt;];
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; sec = time.split(':')[1&lt;span&gt;];
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Number(min * 60) +&lt;span&gt; Number(sec);
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (len.length == 1&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; sec = time.split(':')[0&lt;span&gt;];
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Number(sec);
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;完整代码：&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;

&amp;lt;head&amp;gt;

&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;
    &amp;lt;audio controls autoplay start=&quot;01:00&quot; id='videoDiv'&amp;gt;
        &amp;lt;source src=&quot;http://mp3.9ku.com/hot/2005/05-19/65937.mp3&quot; type=&quot;audio/ogg&quot;&amp;gt;
    &amp;lt;/audio&amp;gt;

    &amp;lt;script src=&quot;http://libs.baidu.com/jquery/2.0.0/jquery.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;&lt;span&gt;
        $(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;js获取某个mp3音频文件的播放时长&lt;/span&gt;
            getAudioDuration('http://mp3.9ku.com/hot/2005/05-19/65937.mp3'&lt;span&gt;);

            duration();
            console.log(&lt;/span&gt;&quot;转化为多少秒=》》&quot;, timeEvent(&quot;00:14:36&quot;&lt;span&gt;));
        })

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 音频加载完成后的一系列操作&lt;/span&gt;
        &lt;span&gt;function&lt;/span&gt;&lt;span&gt; duration() {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; myVid = document.getElementById(&quot;videoDiv&quot;&lt;span&gt;);
            console.log(&lt;/span&gt;&quot;duration  &quot;&lt;span&gt;, myVid);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (myVid != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; duration;
                myVid.load(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;方法重新加载音频/视频元素&lt;/span&gt;
                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; https://www.w3school.com.cn/tags/av_prop_currenttime.asp&lt;/span&gt;
                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; currentTime 属性设置或返回音频/视频播放的当前位置（以秒计）。&lt;/span&gt;
                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当设置该属性时，播放会跳跃到指定的位置。&lt;/span&gt;
                myVid.currentTime = 20; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;默认指定音频默认从20s的时候开始播放（默认时间为s）&lt;/span&gt;
                myVid.oncanplay = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;duration 属性返回当前音频的长度，以秒计。&lt;/span&gt;
                    console.log(&quot;音频时间&quot;&lt;span&gt;, myVid.duration);
                    console.log(&lt;/span&gt;&quot;时分秒格式转化：&quot;&lt;span&gt;, timeToMinute(myVid.duration))
                }
            }
        }

        &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; getAudioDuration(src) {
            let audio &lt;/span&gt;= document.createElement('audio') &lt;span&gt;//&lt;/span&gt;&lt;span&gt;生成一个audio元素 &lt;/span&gt;
            audio.src = src &lt;span&gt;//&lt;/span&gt;&lt;span&gt;音乐的路径 &lt;/span&gt;
            audio.addEventListener(&quot;canplay&quot;, &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
                console.log(&lt;/span&gt;&quot;音频长度=&amp;gt;&amp;gt;&amp;gt;：&quot;, parseInt(audio.duration) + '秒', '音频时分秒格式：'&lt;span&gt;, timeToMinute(parseInt(audio
                    .duration)));
            });
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 秒转换时分钟00:00:00格式&lt;/span&gt;
        &lt;span&gt;function&lt;/span&gt;&lt;span&gt; timeToMinute(times) {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; t;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (times &amp;gt; -1&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; hour = Math.floor(times / 3600&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; min = Math.floor(times / 60) % 60&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; sec = times % 60&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (hour &amp;lt; 10&lt;span&gt;) {
                    t &lt;/span&gt;= '0' + hour + &quot;:&quot;&lt;span&gt;;
                } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    t &lt;/span&gt;= hour + &quot;:&quot;&lt;span&gt;;
                }

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (min &amp;lt; 10&lt;span&gt;) {
                    t &lt;/span&gt;+= &quot;0&quot;&lt;span&gt;;
                }
                t &lt;/span&gt;+= min + &quot;:&quot;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (sec &amp;lt; 10&lt;span&gt;) {
                    t &lt;/span&gt;+= &quot;0&quot;&lt;span&gt;;
                }
                t &lt;/span&gt;+= sec.toFixed(2&lt;span&gt;);
            }
            t &lt;/span&gt;= t.substring(0, t.length - 3&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; t;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 00:00:00时分秒格式转化为秒&lt;/span&gt;
        &lt;span&gt;function&lt;/span&gt;&lt;span&gt; timeEvent(e) {
            let time &lt;/span&gt;=&lt;span&gt; e;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; len = time.split(':'&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (len.length == 3&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; hour = time.split(':')[0&lt;span&gt;];
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; min = time.split(':')[1&lt;span&gt;];
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; sec = time.split(':')[2&lt;span&gt;];
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Number(hour * 3600) + Number(min * 60) +&lt;span&gt; Number(sec);
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (len.length == 2&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; min = time.split(':')[0&lt;span&gt;];
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; sec = time.split(':')[1&lt;span&gt;];
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Number(min * 60) +&lt;span&gt; Number(sec);
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (len.length == 1&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; sec = time.split(':')[0&lt;span&gt;];
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Number(sec);
            }
        }
    &lt;/span&gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;

&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;参考文章：&lt;/h2&gt;
&lt;blockquote readability=&quot;0.12406015037594&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://www.zhangxinxu.com/wordpress/2019/07/html-audio-api-guide/%20%20https://developer.mozilla.org/zh-CN/docs/Web/Guide/HTML/Using_HTML5_audio_and_video%20%20https://blog.csdn.net/qq_31984879/article/details/84071245%20%20https://www.w3school.com.cn/tags/av_prop_currenttime.asp&quot; target=&quot;_blank&quot;&gt;https://www.zhangxinxu.com/wordpress/2019/07/html-audio-api-guide/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/Guide/HTML/Using_HTML5_audio_and_video&quot; target=&quot;_blank&quot;&gt;https://developer.mozilla.org/zh-CN/docs/Web/Guide/HTML/Using_HTML5_audio_and_video&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_31984879/article/details/84071245&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/qq_31984879/article/details/84071245&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.w3school.com.cn/tags/av_prop_currenttime.asp&quot; target=&quot;_blank&quot;&gt;https://www.w3school.com.cn/tags/av_prop_currenttime.asp&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 27 Nov 2020 16:55:00 +0000</pubDate>
<dc:creator>追逐时光者</dc:creator>
<og:description>前言： 今天接到一个需求，需要获取某个.mp3音频文件的时间长度和指定音频audio在某个时间点进行播放（比如说这个视频有4分钟，我要让它默认从第2秒的时候开始播放），这里当然想到了H5中的audio</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Can-daydayup/p/14049190.html</dc:identifier>
</item>
<item>
<title>Apache Hudi初学者指南 - leesf</title>
<link>http://www.cnblogs.com/leesf456/p/14050996.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/leesf456/p/14050996.html</guid>
<description>&lt;p&gt;在深入研究Hudi机制之前，让我们首先了解Hudi正在解决的问题。&lt;/p&gt;
&lt;p&gt;客户在使用数据湖时通常会问一个问题：当源记录被更新时，如何更新数据湖？这是一个很难解决的问题，因为一旦你写了CSV或Parquet文件，唯一的选择就是重写它们，没有一种简单的机制可以打开这些文件，找到一条记录并用源代码中的最新值更新该记录，当数据湖中有多层数据集时，问题变得更加严重，数据集的输出将作为下次数据集计算的输入。&lt;/p&gt;
&lt;p&gt;在数据库中用户只需发出一个更新记录命令就可以完成任务了，所以从数据库的思维模式来看很难理解上述限制，为什么不能在数据湖中完成？首先让我们来看看数据库是如何应用记录级更新的，这对于理解Hudi是如何工作的很有价值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RDBMS的更新原理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;RDBMS将数据存储在B-Tree存储模型中，数据存储在数据页中，数据页可以通过在表的列上创建的索引来找到。因此当发出更新命令时，RDBMS引擎会找到包含该记录的确切页面，并在该数据页面中适当地更新数据，这是一个简化的描述，在大多数现代RDBMS引擎中，在多版本并发控制等方面存在额外的复杂性，但基本思想保持不变。&lt;/p&gt;
&lt;p&gt;下图说明了如何通过B树索引找到带有值13的数据页，底层（第三层）是表示数据页的叶节点，顶层（第一层）和中间层（第二层）上的节点是索引值。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/616953/202011/616953-20201127233000829-1137004049.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以下是一些非SQL数据库（如Cassandra）中的更新工作方式：&lt;/p&gt;
&lt;p&gt;许多非SQL数据库将数据存储在LSM树的存储模型中，这是一个基于日志的存储模型，新数据（插入/更新/删除）被添加到append-only的日志中，然后定期将日志合并回数据文件，使数据文件与所有更改的数据保持最新，这种合并过程称为压缩，因此当更新一条记录时，只是将其写入到append-only日志中，根据数据库引擎的优化规则，将组合append-only日志和数据文件来为读取查询提供服务，这也是一个简化的描述，但基本思想相同。&lt;/p&gt;
&lt;p&gt;下图说明了如何将新的和更新的数据添加到append-only日志（级别0）中，并最终合并到更大的文件中（级别1和级别2）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/616953/202011/616953-20201127233017680-2018787229.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在我们已经基本了解了数据库如何处理记录级别的更新，接着看看Hudi如何工作，在Hudi（和类似的框架，如DeltaLake）出现之前，对datalake应用更新的唯一途径是重新计算并重写整个csv/parquet文件，如前所述，没有简单的机制来打开文件并更新其中的单个记录，造成这种限制有很多原因，其中一些主要原因是不知道哪个文件包含要更新的记录，也没有有效的方法来扫描一个文件来找到想要更新的记录，另外Parquet这样的列文件格式不能就地更新，只能重新创建。在数据湖中，通常还有多个被转换的数据层，其中一组文件被输入到下一组文件的计算中，因此在单记录更新期间编写逻辑来管理这种依赖关系几乎是不可能的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HUDI&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;HUDI框架的基本思想是采用数据库更新机制的概念，并将其应用于datalake，这就是Hudi实现的目标，Hudi有两种“更新”机制：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;写时拷贝（COW）-这类似于RDBMS B-Tree更新&lt;/li&gt;
&lt;li&gt;读时合并（MOR）-这类似于No-SQL LSM-Tree更新&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;此外，HUDI还维护以下内容：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;将数据记录映射到文件（类似于数据库索引）&lt;/li&gt;
&lt;li&gt;跟踪到数据湖中的每个逻辑表的最近提交&lt;/li&gt;
&lt;li&gt;能够基于“record_key”在文件中识别单个记录，这在所有Hudi数据集中是必需的，类似于数据库表中的主键&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Hudi使用上述机制以及“precombine_key”机制来保证不会存在重复的记录。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;标准数据文件大小（尽可能）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Copy on Write&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在该模型中，当记录更新时，Hudi会找到包含更新数据的文件，然后使用更新值重写这些文件，包含其他记录的所有其他文件保持不变，因此更新的处理是快速有效的，读取查询通过读取最新的数据文件来查看最新的更新，此模型适用于读性能更为重要的读重负载，这种模型的缺点是突然的写操作会导致大量的文件被重写，从而导致大量的处理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Merge on Read&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在该模型中，当记录更新时，Hudi会将它附加到数据湖表的日志中，随着更多的写入操作进入，它们都会被附加到日志中，通过从日志和数据文件中读取数据并将结果合并在一起，或者根据用户定义的参数只从数据文件中读取数据来服务读取查询，如果用户希望实时查看数据，则从日志中读取数据；否则，如果指定为read optimized表，则从数据文件中读取数据，但数据可能已过时，Hudi会定期将日志合并到数据文件中，以使它们保持最新状态，这是配置为根据用例需求定期运行的压缩过程。&lt;/p&gt;
&lt;p&gt;如果你的数据湖中有多层数据集，每一层都将其输出作为下一个计算的输入，那么只要所有这些数据集都是Hudi数据集，记录级更新可以很好地、自动地在多个处理层中传播，而不必重新编写整个数据集。&lt;/p&gt;
&lt;p&gt;以上所有这些都是从记录更新的角度出发的，同样的Hudi概念也适用于插入和删除，对于删除有软删除和硬删除两个选项，使用软删除，Hudi保留记录键并删除记录数据，使用硬删除，Hudi会为整个记录写空白值，丢弃记录键和记录数据。&lt;/p&gt;
</description>
<pubDate>Fri, 27 Nov 2020 15:31:00 +0000</pubDate>
<dc:creator>leesf</dc:creator>
<og:description>在深入研究Hudi机制之前，让我们首先了解Hudi正在解决的问题。 客户在使用数据湖时通常会问一个问题：当源记录被更新时，如何更新数据湖？这是一个很难解决的问题，因为一旦你写了CSV或Parquet文</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/leesf456/p/14050996.html</dc:identifier>
</item>
<item>
<title>痞子衡嵌入式：一次利用IAR自带CRC完整性校验功能的实践(为KBOOT加BCA) - 痞子衡</title>
<link>http://www.cnblogs.com/henjay724/p/14050783.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/henjay724/p/14050783.html</guid>
<description>&lt;p&gt;痞子衡之前写过两篇关于IAR中自带CRC校验功能的文章，算是把这个功能细节介绍得比较清楚了，但是俗话说得好，理论懂得再多，不能用于实践那等于没学。今天痞子衡就利用这个功能来解决一个实际需求&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;140.72049689441&quot;&gt;
&lt;hr/&gt;&lt;p&gt;　　大家好，我是痞子衡，是正经搞技术的痞子。今天痞子衡给大家分享的是&lt;strong&gt;利用IAR自带CRC完整性校验功能的一次实践(为KBOOT加BCA)&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　痞子衡之前写过两篇关于IAR中自带CRC校验功能的文章 &lt;a href=&quot;https://www.cnblogs.com/henjay724/p/14042538.html&quot;&gt;《在IAR开发环境下为工程开启CRC完整性校验功能的方法》&lt;/a&gt;、&lt;a href=&quot;https://www.cnblogs.com/henjay724/category/1170736.html&quot;&gt;《探析开启CRC完整性校验的IAR工程生成.out和.bin文件先后顺序》&lt;/a&gt;，算是把这个功能细节介绍得比较清楚了，但是俗话说得好，理论懂得再多，不能用于实践那等于没学。今天痞子衡就利用这个功能来解决一个实际需求：&lt;/p&gt;
&lt;h3 id=&quot;一、kboot中bca填入crc校验需求&quot;&gt;一、KBOOT中BCA填入CRC校验需求&lt;/h3&gt;
&lt;p&gt;　　说起这个需求，记得那是2014年的第一场雪，那时候痞子衡正在飞思卡尔软件组参与Kinetis Bootloader项目（简称KBOOT）的研发，痞子衡为这个项目写过一些文章，详见 &lt;a href=&quot;https://www.cnblogs.com/henjay724/p/9305876.html&quot;&gt;《飞思卡尔Kinetis系列MCU开发那些事》&lt;/a&gt; 里的启动篇系列，Kinetis是飞思卡尔当时主推的Cortex-M微控制器，KBOOT就是为Kinetis设计的全功能Bootloader，这可能是嵌入式世界里第一个精心设计的通用架构Bootloader。这个Bootloader包含一个用户配置功能（BCA），简单说就是在用户Application的偏移0x3c0 - 0x3ff这16个word存放一些Bootloader配置，当Bootloader运行时会先尝试从Application区域读出这16个word，获取用户配置（超时时间、外设类型、id、速度选项等），然后根据用户配置再去启动或升级用户Application。&lt;/p&gt;
&lt;p&gt;　　CRC完整性校验功能占据了BCA里的12个byte，是一个很重要的Bootloader特性，其完整功能详见 &lt;a href=&quot;https://www.cnblogs.com/henjay724/p/9355642.html&quot;&gt;《KBOOT特性(完整性检测)》&lt;/a&gt;，今天痞子衡要说的需求就是直接在Application工程编译时生成包含正确CRC相关参数的BCA，而不是像以前那样在最终binary文件里二次编辑添加。&lt;/p&gt;
&lt;p&gt;　　我们以MK64FN1M这颗芯片为例，下载它的软件包，软件包里有KBOOT及其示例Application，找到 \SDK_2.8.2_FRDM-K64F\boards\frdmk64f\bootloader_examples\demo_apps\led_demo_freedom_a000\iar 下的Application工程，工程源文件 startup_MK64F12.s 里定义了__bootloaderConfigurationArea，但是CRC区域是全0xFF（即没有使能），编译生成的bin文件里CRC区域也是全0xFF，我们要做的就是填入正确的CRC。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/cnblogs/IAR_CRCPractice_KBOOT_user_app_default.PNG&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;二、开始动手实践&quot;&gt;二、开始动手实践&lt;/h3&gt;
&lt;h4 id=&quot;21-确定匹配的crc算法参数设置&quot;&gt;2.1 确定匹配的CRC算法参数设置&lt;/h4&gt;
&lt;p&gt;　　在KBOOT用户手册里可以找到其CRC具体算法，它使用的是比较主流的CRC32-MPEG2分支，具体参数如下表所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/cnblogs/Kinetis_Boot_ImageCRC_mpeg2_characteristics.PNG&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　为了方便核对结果，痞子衡找了一个在线CRC计算的网站，利用这个网站，设置与KBOOT一致的CRC参数（下图红色框内），然后我们选取led_demo_freedom_a000.bin的前16个字节（下图蓝色框内）作为测试数据输入，点击Calculate CRC按钮生成结果0x8D96BDF0（下图紫色框内）。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot;&gt;在线网站： http://www.sunshine2k.de/coding/javascript/crc/crc_js.html
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/cnblogs/IAR_CRCPractice_KBOOT_crc_js_web_test.PNG&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　我们现在回到led_demo_freedom_a000工程，在Linker/Checksum下，使能CRC功能，为了与上述测试一致，CRC计算范围设为 0xa000 - 0xa00f（因为程序起始链接地址是0xa000，所以也就是最终.bin里的前16个字节）。查阅IAR development手册，做了如下CRC算法参数设置，编译工程得到结果也是0x8D96BDF0，因此CRC设置是匹配的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/cnblogs/IAR_CRCPractice_KBOOT_iar_checksum_test.PNG&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;22-填充bca的首次尝试&quot;&gt;2.2 填充BCA的首次尝试&lt;/h4&gt;
&lt;p&gt;　　确认了CRC设置，现在就是修改源代码了，在BCA的CRC区域里将初始的0xFF值全部更换为真实的CRC设置值__checksum、__checksum_begin、__checksum_end，代码简单修改如下。重编工程后查看.bin文件，发现起止范围两个参数是对的，但是CRC校验值并不对，填成了0x0000a7fc，查看map文件得知这是__checksum的链接地址，并不是__checksum的值。想想也是，CRC校验值是链接生成bin后才计算的，但源文件是在链接前编译的，不可能在编译时得到链接后的结果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/cnblogs/IAR_CRCPractice_KBOOT_iar_first_try.PNG&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;23-填充bca的最终方案&quot;&gt;2.3 填充BCA的最终方案&lt;/h4&gt;
&lt;p&gt;　　首次尝试失败，事情远没有想象得那么简单，我们需要在工程链接文件上动心思，要直接把__checksum链接到BCA里的具体偏移位置。因此startup_MK64F12.s 里__bootloaderConfigurationArea从crcExpectedValue及其之后全部去掉，并且__FlashConfig也实际不需要（仅对于链接在0地址才有效，这是Kinetis特性）。&lt;/p&gt;
&lt;p&gt;　　然后我们需要重新在main.c里定义一个bca常量数组，把除crcExpectedValue之外缺失的BCA数据全部放进去。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C&quot;&gt;const uint32_t bca[16] @ &quot;.bca_left&quot; = {0x1388ffff, 0xffffffff, 0xffffffff, 0xffffffff,
                                        0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
                                        0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
                                        0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff};
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　最后我们需要修改链接文件MK64FN1M0xxx12_application_0xA000.icf如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot;&gt;//place at address mem:__ICFEDIT_intvec_start__ { readonly section .intvec, readonly section .noinit };
//place in FLASH_region { block ApplicationFlash };
place at address mem:__ICFEDIT_intvec_start__ { readonly section .intvec };
place at address mem:0xa3cc { ro section .checksum };
place at address mem:0xa3d0 { ro section .bca_left };
place in FLASH_region { readonly section .noinit, block ApplicationFlash };
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　经过这么一番操作，让我们重新编译工程再看bin里结果，哈哈，这次BCA果然是正确的CRC校验值了（这次值是0xf62ce2b6，发生了变化，因为源代码的改动，bin前16个字节内容也相应变化了），大功告成。底下的事情就简单了，在CRC设置界面里调整想要的CRC计算范围即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/cnblogs/IAR_CRCPractice_KBOOT_iar_final_solution.PNG&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　至此，利用IAR自带CRC完整性校验功能的一次实践(为KBOOT加BCA)痞子衡便介绍完毕了，掌声在哪里~~~&lt;/p&gt;
&lt;h3 id=&quot;欢迎订阅&quot;&gt;欢迎订阅&lt;/h3&gt;
&lt;p&gt;文章会同时发布到我的 &lt;a href=&quot;https://www.cnblogs.com/henjay724/&quot;&gt;博客园主页&lt;/a&gt;、&lt;a href=&quot;https://blog.csdn.net/henjay724&quot;&gt;CSDN主页&lt;/a&gt;、&lt;a href=&quot;https://www.zhihu.com/people/henjay724&quot;&gt;知乎主页&lt;/a&gt;、&lt;a href=&quot;http://weixin.sogou.com/weixin?type=1&amp;amp;query=%E7%97%9E%E5%AD%90%E8%A1%A1%E5%B5%8C%E5%85%A5%E5%BC%8F&quot;&gt;微信公众号&lt;/a&gt; 平台上。&lt;/p&gt;
&lt;p&gt;微信搜索&quot;&lt;strong&gt;痞子衡嵌入式&lt;/strong&gt;&quot;或者扫描下面二维码，就可以在手机上第一时间看了哦。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/github/pzhMcu_qrcode_258x258.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Fri, 27 Nov 2020 14:40:00 +0000</pubDate>
<dc:creator>痞子衡</dc:creator>
<og:description>痞子衡之前写过两篇关于IAR中自带CRC校验功能的文章，算是把这个功能细节介绍得比较清楚了，但是俗话说得好，理论懂得再多，不能用于实践那等于没学。今天痞子衡就利用这个功能来解决一个实际需求</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/henjay724/p/14050783.html</dc:identifier>
</item>
<item>
<title>Jmeter-记一次AES加密登录实例 - 一加一</title>
<link>http://www.cnblogs.com/Chilam007/p/14050450.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Chilam007/p/14050450.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;　　公司有个网站系统，用户名是明文，密码是加密的，所以搞了好久才登录进去，因此记录下艰辛过程。&lt;/p&gt;
&lt;h2&gt;Part 1   了解加密算法&lt;/h2&gt;
&lt;p&gt;　　找研发同事去了解这个是怎样一个加密过程，最后得到的结论是：后端会生成一个16位的随机数，由前端来加密，而前端是用AES的CBC模式加密的。因为前端是用JS实现的，而jmeter是用java，所以不能直接贴前端代码。&lt;/p&gt;
&lt;h2&gt;Part 2   开始百度之旅&lt;/h2&gt;
&lt;p&gt;　　各种百度，最后参照2篇博文，然后copy了代码过来优化了下，输出的密码密文如下：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/715975/202011/715975-20201127211324936-1707541247.png&quot; alt=&quot;&quot; width=&quot;626&quot; height=&quot;260&quot; loading=&quot;lazy&quot;/&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;参照的博客地址：&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;1.https://www.cnblogs.com/artoftest/p/7277996.html&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2.https://blog.csdn.net/qq_39820860/article/details/95963968&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;Part 3   卡住了，不过解决了&lt;/h2&gt;
&lt;p&gt;　　以为这么容易就结束了吗？不，还有第3part呢，在加密算法搞定后，接口一直提示认证失败，起初以为是网上找的加密算法跟公司用的不一样，但是找研发看了，说是一样的，最后终于在研发同事的提醒下，找到原因了，原来是登录的接口请求时要用到前面那个接口生成的cookie，唉，真心不容易。上面只是简单贴了下资料，下面具体说下运用吧。&lt;/p&gt;
&lt;h2&gt;Part 4    完整实例演示&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;1、添加http请求　　&lt;/span&gt;&lt;span&gt;获取登录的key接口（GET）：http://../login/getSecretKey&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Response Body ：&lt;/strong&gt;{&quot;msg&quot;:&quot;success&quot;,&quot;code&quot;:&quot;0&quot;,&quot;info&quot;:{&quot;key&quot;:&quot;a2c893cfa0684897&quot;}}&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Response headers：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;HTTP/1.1 200 OK
Server: openresty/1.11.2.5
Date: Fri, 27 Nov 2020 13:18:12 GMT
Content-Type: text/plain;charset=UTF-8
Content-Length: 62
Connection: keep-alive
Set-Cookie: PHPSESSID=a4b06bc0-9974-4b22-aa25-efcd4e969d4e; Path=/; HttpOnly; SameSite=lax
X-Application-Context: FspService:test:8001
Access-Control-Allow-Origin: *
Access-Control-Allow-Methods: GET, POST, OPTIONS
Access-Control-Allow-Headers: DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;正则表达式提取：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;key--从Response Body提取-----------&lt;span&gt;--在登录接口会引用到&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;PHPSESSID--从Response headers提取---------------&lt;span&gt;在信息头管理器会引用到&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/715975/202011/715975-20201127212548035-705458829.png&quot; alt=&quot;&quot; width=&quot;899&quot; height=&quot;283&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/715975/202011/715975-20201127212602704-1510744355.png&quot; alt=&quot;&quot; width=&quot;903&quot; height=&quot;288&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2、添加BeanShell 取样器　　对前面接口提取的key进行AES加密，完整代码如下：&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;导入需要的加密包&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.commons.codec.binary.Base64;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.crypto.Cipher;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.crypto.spec.IvParameterSpec;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.crypto.spec.SecretKeySpec;

 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加密&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; String encrypt(String data, String key) {
        String ivString &lt;/span&gt;=&lt;span&gt; key;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;偏移量&lt;/span&gt;
        &lt;span&gt;byte&lt;/span&gt;[] iv =&lt;span&gt; ivString.getBytes();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            Cipher cipher &lt;/span&gt;= Cipher.getInstance(&quot;AES/CBC/NoPadding&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; blockSize =&lt;span&gt; cipher.getBlockSize();
            &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] dataBytes =&lt;span&gt; data.getBytes();
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; length =&lt;span&gt; dataBytes.length;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算需填充长度&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (length % blockSize != 0&lt;span&gt;) {
                length &lt;/span&gt;= length + (blockSize - (length %&lt;span&gt; blockSize));
            }
            &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] plaintext = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[length];
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;填充&lt;/span&gt;
            System.arraycopy(dataBytes, 0, plaintext, 0&lt;span&gt;, dataBytes.length);
            SecretKeySpec keySpec &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; SecretKeySpec(key.getBytes(), &quot;AES&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置偏移量参数&lt;/span&gt;
            IvParameterSpec ivSpec = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IvParameterSpec(iv);
            cipher.init(Cipher.ENCRYPT_MODE, keySpec, ivSpec);
            &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] encryped =&lt;span&gt; cipher.doFinal(plaintext);
 
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Base64.encodeBase64String(encryped);
 
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            e.printStackTrace();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
    }
 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;解密&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; String desEncrypt(String data, String key) {
 
        String ivString &lt;/span&gt;=&lt;span&gt; key;
        &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] iv =&lt;span&gt; ivString.getBytes();
 
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] encryp =&lt;span&gt; Base64.decodeBase64(data);
            Cipher cipher &lt;/span&gt;= Cipher.getInstance(&quot;AES/CBC/NoPadding&quot;&lt;span&gt;);
            SecretKeySpec keySpec &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; SecretKeySpec(key.getBytes(), &quot;AES&quot;&lt;span&gt;);
            IvParameterSpec ivSpec &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IvParameterSpec(iv);
            cipher.init(Cipher.DECRYPT_MODE, keySpec, ivSpec);
            &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] original =&lt;span&gt; cipher.doFinal(encryp);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; String(original);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            e.printStackTrace();
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    String data &lt;/span&gt;= &quot;abcd1234&quot;;&lt;span&gt;//这是明文密码&lt;/span&gt;
        String key = &quot;${key}&quot;;&lt;span&gt;//key引用了变量，即前面接口提取出来的key&lt;/span&gt;
        String encrypt =&lt;span&gt; encrypt(data,key);
        String desencrypt &lt;/span&gt;=&lt;span&gt; desEncrypt(encrypt, key);
        vars.put(&lt;/span&gt;&quot;enString&quot;,encrypt);&lt;span&gt;//把加密的密码设置为变量enString，供后面登录接口使用&lt;/span&gt;
        System.out.println(&quot;加密后:&quot;+&lt;span&gt;encrypt);
        System.out.println(&lt;/span&gt;&quot;解密后:&quot;+&lt;span&gt;desencrypt);
        log.info(&lt;/span&gt;&quot;加密后:&quot;+encrypt);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;打印日志到控制台&lt;/span&gt;
        log.info(&quot;解密后:&quot;+desencrypt);
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;3、添加http请求　　登录接口（POST）：http://../login/login&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;消息体数据：{&quot;password&quot;:&quot;${enString}&quot;,&quot;userName&quot;:&quot;用户名&quot;,&quot;isMobile&quot;:false}&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;4、HTTP信息头管理器&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;Cookie引用第1个接口生成的PHPSESSID值变量，前面就是被这个变量阻塞了好久&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/715975/202011/715975-20201127214610499-2047207286.png&quot; alt=&quot;&quot; width=&quot;783&quot; height=&quot;167&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;5、以上就完结啦，下面展示下线程组框架和debug&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/715975/202011/715975-20201127214301502-404250644.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/715975/202011/715975-20201127215351951-2142719821.png&quot; alt=&quot;&quot; width=&quot;694&quot; height=&quot;472&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 27 Nov 2020 13:55:00 +0000</pubDate>
<dc:creator>一加一</dc:creator>
<og:description>前言 公司有个网站系统，用户名是明文，密码是加密的，所以搞了好久才登录进去，因此记录下艰辛过程。 Part 1 了解加密算法 找研发同事去了解这个是怎样一个加密过程，最后得到的结论是：后端会生成一个1</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Chilam007/p/14050450.html</dc:identifier>
</item>
</channel>
</rss>