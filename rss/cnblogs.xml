<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>2020你还不会Java8新特性？（学习过程记录） - 我不是铁杆啊</title>
<link>http://www.cnblogs.com/wobushitiegan/p/12315653.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wobushitiegan/p/12315653.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言：&lt;/h2&gt;
&lt;p&gt;跟大娃一块看，把原来的电脑拿出来放中间看视频用&lt;/p&gt;
&lt;p&gt;--- 以后会有的课程 难度&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;深入Java 8 难度1&lt;/li&gt;
&lt;li&gt;并发与netty 难度3&lt;/li&gt;
&lt;li&gt;JVM 难度4&lt;/li&gt;
&lt;li&gt;node 难度2&lt;/li&gt;
&lt;li&gt;spring精髓 难度1&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;课程中提到的知识&quot;&gt;课程中提到的知识：&lt;/h3&gt;
&lt;p&gt;前后端分离的开发，是靠node当做中间的&lt;/p&gt;
&lt;p&gt;netty，已经成为国内外互联网公司的标配。会涉及底层的源代码的理解。&lt;/p&gt;
&lt;p&gt;JVM 涉及的东西比较多。虽然天天用，但是没有深入理解过。各种锁，可见性等。与计算机原理息息相关的。&lt;/p&gt;
&lt;p&gt;圣思园主要面对与已经工作的。大部分为一线的开发人员。&lt;br/&gt;课程一定是完整的。由浅入深的。一定要有一种耐心。&lt;br/&gt;对于基础不好的，可以看看以前面授的时候录制的视频。不懂的一定要多查资料。&lt;/p&gt;
&lt;p&gt;在讲课过程中的设计思路：4000块钱的收费标准。&lt;/p&gt;
&lt;h3 id=&quot;jdk8&quot;&gt;jdk8&lt;/h3&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;介绍：Java 8可谓Java语言历史上变化最大的一个版本，其承诺要调整Java编程向着函数式风格迈进，这有助于编写出更为简洁、表达力更强，并且在很多情况下能够利用并行硬件的代码。本门课程将会深入介绍Java 8新特性，学员将会通过本门课程的学习深入掌握Java 8新增特性并能灵活运用在项目中。学习者将学习到如何通过Lambda表达式使用一行代码编写Java函数，如何通过这种功能使用新的Stream API进行编程，如何将冗长的集合处理代码压缩为简单且可读性更好的流程序。学习创建和消费流的机制，分析其性能，能够判断何时应该调用API的并行执行特性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;课程的介绍：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Java 8新特性介绍&lt;/li&gt;
&lt;li&gt;Lambda表达式介绍&lt;/li&gt;
&lt;li&gt;使用Lambda表达式代替匿名内部类&lt;/li&gt;
&lt;li&gt;Lambda表达式的作用&lt;/li&gt;
&lt;li&gt;外部迭代与内部迭代&lt;/li&gt;
&lt;li&gt;Java Lambda表达式语法详解&lt;/li&gt;
&lt;li&gt;函数式接口详解&lt;/li&gt;
&lt;li&gt;传递值与传递行为&lt;/li&gt;
&lt;li&gt;Stream深度解析&lt;/li&gt;
&lt;li&gt;Stream API详解&lt;/li&gt;
&lt;li&gt;串行流与并行流&lt;/li&gt;
&lt;li&gt;Stream构成&lt;/li&gt;
&lt;li&gt;Stream源生成方式&lt;/li&gt;
&lt;li&gt;Stream操作类型&lt;/li&gt;
&lt;li&gt;Stream转换&lt;/li&gt;
&lt;li&gt;Optional详解&lt;/li&gt;
&lt;li&gt;默认方法详解&lt;/li&gt;
&lt;li&gt;方法与构造方法引用&lt;/li&gt;
&lt;li&gt;Predicate接口详解&lt;/li&gt;
&lt;li&gt;Function接口详解&lt;/li&gt;
&lt;li&gt;Consumer接口剖析&lt;/li&gt;
&lt;li&gt;Filter介绍&lt;/li&gt;
&lt;li&gt;Map-Reduce讲解、中间操作与终止操作&lt;/li&gt;
&lt;li&gt;新的Date API分析&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;拉姆达表达式: 函数式编程。以前的叫做命令式的编程。&lt;br/&gt;使用面向对象语言就是来操作数据，封装继承多态。&lt;br/&gt;函数式编程面向的是行为。好处：代码可读性提高。&lt;/p&gt;
&lt;p&gt;开发安卓的时候大量的匿名内部类。&lt;/p&gt;
&lt;p&gt;提到的关键字：&lt;br/&gt;kotlin ，JetBrains 。construction 构造&lt;/p&gt;
&lt;p&gt;他以前在学习的时候，翻代码。&lt;/p&gt;
&lt;p&gt;将要讲解的各个技术的简介、&lt;/p&gt;
&lt;p&gt;课程讲解的时候遇到的工具：&lt;br/&gt;Mac ， jdk8 ,idea（很多功能是通过插件的形式来实现的）&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;java8课程开始&quot;&gt;Java8课程开始&lt;/h2&gt;
&lt;h3 id=&quot;lambda表达式&quot;&gt;lambda表达式&lt;/h3&gt;
&lt;p&gt;为什么要使用lambda表示式&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在Java中无法将函数座位参数传递给一个方法，也无法返回一个函数的方法。&lt;/li&gt;
&lt;li&gt;在js中，函数的参数是一个函数。返回值是另一个函数的情况是非常常见的。是一门经典的函数式语言。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Java匿名内部类。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;匿名内部类的介绍&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Gradle的使用。可以完全使用maven的中央仓库。&lt;br/&gt;进行安卓的开发时，gradle已经成为标配了。&lt;/p&gt;
&lt;p&gt;lambda:&lt;br/&gt;匿名内部类&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; my_jButton.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                System.out.println(&quot;Button Pressed! &quot;);
            }
        });&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;改造后&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        my_jButton.addActionListener(e -&amp;gt; System.out.println(&quot;Button Pressed!&quot;));
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;lambda表达式的基本结构：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;(param1,param2,param3) -&amp;gt;{
    
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;函数式编程: 一个接口里边只有一个抽象方法。&lt;br/&gt;可以通过lambda表达式来实例。&lt;/p&gt;
&lt;p&gt;关于函数式接口：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果一个借口只有一个抽象方法，那么该接口就是一个函数式接口。&lt;/li&gt;
&lt;li&gt;如果我们在某一个接口上声明了functionalInterface注解，那么编译器就会按照函数是借口的定义来要求改接口。&lt;/li&gt;
&lt;li&gt;如果某个接口只有一个抽象方法，但是我们并没有给接口声明functionnaleInterface注解，编译器依旧会给改接口看作是函数式接口。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;通过实例对函数式接口的理解：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.erwa.jdk8;

@FunctionalInterface
interface MyInterface {

    void test();

//    Multiple non-overriding abstract methods found in interface com.erwa.jdk8.MyInterface
//    void te();

    //如果一个接口声明一个抽象方法,但是这个方法重写了 object类中的一个方法.
    //接口的抽象方法不会加一.所以依然是函数方法.
    // Object 类是所有类的父类.
    @Override
    String toString();
}

public class Test2 {

    public void myTest(MyInterface myInterface) {
        System.out.println(1);
        myInterface.test();
        System.out.println(2);
    }

    public static void main(String[] args) {
        Test2 test2 = new Test2();
        test2.myTest(() -&amp;gt; {
            System.out.println(3);
        });
    }

}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接口里边从1.8开始也可以有方法实现了。default&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    默认方法。
   default void forEach(Consumer&amp;lt;? super T&amp;gt; action) {
        Objects.requireNonNull(action);
        for (T t : this) {
            action.accept(t);
        }
    }
 &lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt; * &amp;lt;p&amp;gt;Note that instances of functional interfaces can be created with
 * lambda expressions, method references, or constructor reference&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;lambda表达式的作用：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;lambda表达式为Java添加了确实的函数式编程特性，使我们能将函数当做一等公民看待。&lt;/li&gt;
&lt;li&gt;在将函数座位一等公民的语言中，lambda表达式的类型是函数。但是在Java中，lambda表达式是对象，他们必须依附于一类特别的对象类型-函数式接口（function interface）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;迭代的方式:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;外部迭代：&lt;/li&gt;
&lt;li&gt;内部迭代：&lt;/li&gt;
&lt;li&gt;方法引用：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;list.forEach(System.out::println);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接口中可以有默认方法和静态方法。&lt;/p&gt;
&lt;p&gt;流： stream&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; /**
     * Returns a sequential {@code Stream} with this collection as its source.
     *
     * &amp;lt;p&amp;gt;This method should be overridden when the {@link #spliterator()}
     * method cannot return a spliterator that is {@code IMMUTABLE},
     * {@code CONCURRENT}, or &amp;lt;em&amp;gt;late-binding&amp;lt;/em&amp;gt;. (See {@link #spliterator()}
     * for details.)
     *
     * @implSpec
     * The default implementation creates a sequential {@code Stream} from the
     * collection's {@code Spliterator}.
     *
     * @return a sequential {@code Stream} over the elements in this collection
     * @since 1.8
     */
    default Stream&amp;lt;E&amp;gt; stream() {
        return StreamSupport.stream(spliterator(), false);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关于流方式实现的举例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static void main(String[] args) {
        //函数式接口的实现方式
        MyInterface1 i1 = () -&amp;gt; {};
        System.out.println(i1.getClass().getInterfaces()[0]);
        MyInterface2 i2 = () -&amp;gt; {};
        System.out.println(i2.getClass().getInterfaces()[0]);

        // 没有上下文对象,一定会报错的.
//        () -&amp;gt; {};

        //通过lambda来实现一个线程.
        new Thread(() -&amp;gt; System.out.println(&quot;hello world&quot;)).start();

        //有一个list  ,将内容中的首字母变大写输出.
        List&amp;lt;String&amp;gt; list = Arrays.asList(&quot;hello&quot;,&quot;world&quot;,&quot;hello world&quot;);
        //通过lambda来实现所有字母编程大写输出.
//        list.forEach(item -&amp;gt; System.out.println(item.toUpperCase()));
        //把三个单词放入到新的集合里边.
        List&amp;lt;String&amp;gt; list1 = new ArrayList&amp;lt;&amp;gt;();  //diamond语法. 后边的&amp;lt;&amp;gt;不用再放类型
//        list.forEach(item -&amp;gt; list1.add(item.toUpperCase()));
//        list1.forEach(System.out::println);

        //进一步的改进. 流的方式
//        list.stream();//单线程
//        list.parallelStream(); //多线程
        list.stream().map(item -&amp;gt; item.toUpperCase()).forEach(System.out::println);//单线程
        list.stream().map(String::toUpperCase).forEach(System.out::println);

        //上边的两种方法,都满足函数式接口的方式.
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;lambda表达式的作&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;传递行为，而不仅仅是值
&lt;ul&gt;&lt;li&gt;提升抽象层次&lt;/li&gt;
&lt;li&gt;API重用性更好&lt;/li&gt;
&lt;li&gt;更加灵活&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;lambda基本语法&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;（argument） -&amp;gt; （body）&lt;/li&gt;
&lt;li&gt;如： （arg1,arg2...） -&amp;gt; （body）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Java lambda结构&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一个Lambda表达式可以有0个或者多个参数&lt;/li&gt;
&lt;li&gt;参数的类型既可以明确声明，也可以根据上下文来推断。例如：（int a） 与 （a） 效果相同&lt;/li&gt;
&lt;li&gt;所有参数包含在圆括号内，参数之间用逗号相隔。&lt;/li&gt;
&lt;li&gt;空圆括号代表参数集为空。&lt;/li&gt;
&lt;li&gt;当只有一个参数，且类型可推倒时。圆括号（）可省略。&lt;/li&gt;
&lt;li&gt;lambda表达式的主体可以包含0条或多条语句。&lt;/li&gt;
&lt;li&gt;如果lambda表达式的主体只有一条语句，花括号{}可以省略，匿名函数的返回类型与该主体表达式一致。&lt;/li&gt;
&lt;li&gt;如果lambda表达式的主体包含一条以上语句，则表达式必须包含在花括号中。匿名函数的韩绘制类型与代码块的返回类型一致，诺没有反回则为空。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;高阶函数:&lt;br/&gt;如果一个函数接收一个函数作为参数,或者返回一个函数作为返回值,那么该函数就叫做高阶函数.&lt;/p&gt;
&lt;p&gt;传递行为的举例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  public static void main(String[] args) {
        // 函数的测试
        // 传递行为的一种方式.
        FunctionTest functionTest = new FunctionTest();
        int compute = functionTest.compute(1, value -&amp;gt; 2 * value);

        System.out.println(compute);
        System.out.println(functionTest.compute(2,value -&amp;gt; 5+ value));
        System.out.println(functionTest.compute(3,a -&amp;gt; a * a));

        System.out.println(functionTest.convert(5, a -&amp;gt; a + &quot;hello &quot;));

        /**
         * 高阶函数:
         * 如果一个函数接收一个函数作为参数,或者返回一个函数作为返回值,那么该函数就叫做高阶函数.
         */

    }

    //使用lambda表达式的话,可以直觉预定义行为.用的时候传递.
    // 即 函数式编程.
    public int compute(int a, Function&amp;lt;Integer, Integer&amp;gt; function) {
        return function.apply(a);
    }

    public String convert(int a, Function&amp;lt;Integer, String&amp;gt; function) {
        return function.apply(a);
    }


    // 之前完成行为的做法. 提前把行为定义好,用的时候调用方法. 如:
    public  int method1(int a ){
        return a * 2 ;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Function类中提供的默认方法的讲解：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
     * Returns a composed function that first applies the {@code before}
     * function to its input, and then applies this function to the result.
     * If evaluation of either function throws an exception, it is relayed to
     * the caller of the composed function.
     返回一个组合的函数。对应用完参数后的结果，再次运行apply
     *
     * @param &amp;lt;V&amp;gt; the type of input to the {@code before} function, and to the
     *           composed function  
     * @param before the function to apply before this function is applied
     * @return a composed function that first applies the {@code before}
     * function and then applies this function
     * @throws NullPointerException if before is null
     *
     * @see #andThen(Function)
     */
    default &amp;lt;V&amp;gt; Function&amp;lt;V, R&amp;gt; compose(Function&amp;lt;? super V, ? extends T&amp;gt; before) {
        Objects.requireNonNull(before);
        return (V v) -&amp;gt; apply(before.apply(v));
    }

    /**
     * Returns a composed function that first applies this function to
     * its input, and then applies the {@code after} function to the result.
     * If evaluation of either function throws an exception, it is relayed to
     * the caller of the composed function.
     *
     * @param &amp;lt;V&amp;gt; the type of output of the {@code after} function, and of the
     *           composed function
     * @param after the function to apply after this function is applied
     * @return a composed function that first applies this function and then
     * applies the {@code after} function
     * @throws NullPointerException if after is null
     *
     * @see #compose(Function)
     */
    default &amp;lt;V&amp;gt; Function&amp;lt;T, V&amp;gt; andThen(Function&amp;lt;? super R, ? extends V&amp;gt; after) {
        Objects.requireNonNull(after);
        return (T t) -&amp;gt; after.apply(apply(t));
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;compose : 组合function， 形成两个function的串联。 先执行参数&lt;/p&gt;
&lt;p&gt;andThen ：先应用当前的函数apply，然后再当做参数再次执行apply。 后执行参数。&lt;/p&gt;
&lt;p&gt;identity：输入什么返回什么。&lt;/p&gt;
&lt;p&gt;BiFunction: 整合两个函数的方法。&lt;br/&gt;为什么BiFunction不提供 compose ，只提供andThen呢？&lt;br/&gt;因为如果提供compose方法的话，只能获取一个参数的返回值。不合理。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  public static void main(String[] args) {
        FunctionTest2 functionTest2 = new FunctionTest2();

        // compose
//        System.out.println(functionTest2.compute(2,a -&amp;gt; a * 3,b -&amp;gt; b * b));
        // andThen
//        System.out.println(functionTest2.compute2(2,a -&amp;gt; a * 3,b -&amp;gt; b * b));

        //BiFunction
//        System.out.println(functionTest2.compute3(1,2, (a,b) -&amp;gt; a - b));
//        System.out.println(functionTest2.compute3(1,2, (a,b) -&amp;gt; a * b));
//        System.out.println(functionTest2.compute3(1,2, (a,b) -&amp;gt; a + b));
//        System.out.println(functionTest2.compute3(1,2, (a,b) -&amp;gt; a / b));

        //BiFunction  andThen
        System.out.println(functionTest2.compute4(2,3,(a,b) -&amp;gt;a + b , a -&amp;gt; a * a ));
    }

    //compose : 组合function， 形成两个function的串联。  先执行参数
    //andThen ：先应用当前的函数apply，然后再当做参数再次执行apply。 后执行参数

    public int compute(int a, Function&amp;lt;Integer, Integer&amp;gt; function1, Function&amp;lt;Integer, Integer&amp;gt; function2) {
        return function1.compose(function2).apply(a);
    }

    public int compute2(int a, Function&amp;lt;Integer, Integer&amp;gt; function1, Function&amp;lt;Integer, Integer&amp;gt; function2) {
        return function1.andThen(function2).apply(a);
    }

    //BiFunction
    //求两个参数的和
    //先定义一个抽象的行为.
    public int compute3(int a, int b, BiFunction&amp;lt;Integer, Integer, Integer&amp;gt; biFunction) {
        return biFunction.apply(a, b);
    }

    //BiFunction  andThen 
    public int compute4(int a, int b, BiFunction&amp;lt;Integer, Integer, Integer&amp;gt; biFunction, Function&amp;lt;Integer, Integer&amp;gt; function) {
        return biFunction.andThen(function).apply(a, b);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试 函数式接口的实例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class PersonTest {
    public static void main(String[] args) {


        List&amp;lt;Person&amp;gt; personList = new ArrayList&amp;lt;&amp;gt;();

        personList.add(new Person(&quot;zhangsan&quot;, 20));
        personList.add(new Person(&quot;zhangsan&quot;, 28));
        personList.add(new Person(&quot;lisi&quot;, 30));
        personList.add(new Person(&quot;wangwu&quot;, 40));

        PersonTest test = new PersonTest();

        //测试 getPersonUsername
//        List&amp;lt;Person&amp;gt; personList1 = test.getPersonUsername(&quot;zhangsan&quot;, personList);
//        personList1.forEach(person -&amp;gt; System.out.println(person.getUsername()));


        //测试  getPersonByAge
        List&amp;lt;Person&amp;gt; personByAge = test.getPersonByAge(25, personList);
        personByAge.forEach(person -&amp;gt; System.out.println(person.getAge()));
        
        
        //测试第三种: 自定义输入行为
        List&amp;lt;Person&amp;gt; list = test.getPersonByAge2(20,personList,(age,persons) -&amp;gt;{
            return persons.stream().filter(person -&amp;gt; person.getAge() &amp;gt; age).collect(Collectors.toList());
        });
        list.forEach(person -&amp;gt; System.out.println(person.getAge()));

    }


    public List&amp;lt;Person&amp;gt; getPersonUsername(String username, List&amp;lt;Person&amp;gt; personList) {
        return personList.stream().filter(person -&amp;gt; person.getUsername().equals(username)).collect(Collectors.toList());
    }

    public List&amp;lt;Person&amp;gt; getPersonByAge(int age, List&amp;lt;Person&amp;gt; personList) {
        //使用BiFunction的方式
//        BiFunction&amp;lt;Integer, List&amp;lt;Person&amp;gt;, List&amp;lt;Person&amp;gt;&amp;gt; biFunction = (ageOfPerson, list) -&amp;gt; {
//            return  list.stream().filter(person -&amp;gt; person.getAge() &amp;gt; ageOfPerson ).collect(Collectors.toList());
//        };

        //变换之后:
        BiFunction&amp;lt;Integer, List&amp;lt;Person&amp;gt;, List&amp;lt;Person&amp;gt;&amp;gt; biFunction = (ageOfPerson, list) -&amp;gt;
            list.stream().filter(person -&amp;gt; person.getAge() &amp;gt; ageOfPerson ).collect(Collectors.toList());

        return biFunction.apply(age, personList);
    }
    
     //第三种方式, 动作也让用户自己定义传进来
    public List&amp;lt;Person&amp;gt; getPersonByAge2(int age ,List&amp;lt;Person&amp;gt; list,BiFunction&amp;lt;Integer,List&amp;lt;Person&amp;gt;,List&amp;lt;Person&amp;gt;&amp;gt; biFunction){
        return biFunction.apply(age, list);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;函数式接口的真谛： &lt;code&gt;传递的是行为，而不是数据&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  public static void main(String[] args) {
        //给定一个输入参数,判断是否满足条件,满足的话返回true
        Predicate&amp;lt;String&amp;gt; predicate = p -&amp;gt; p.length() &amp;gt; 5;
        System.out.println(predicate.test(&quot;nnihaoda&quot;));

    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到现在为止，只是讲解了Java.lang.function包下的几个最重要的，经常使用的方法。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;2020年01月01日19:03:33 新的一年开始，记录一下每次学习的时间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Predicate&lt;/strong&gt; 谓语。 类中包含的方法：&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;boolean test(T t);&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;default Predicate&amp;lt;T&amp;gt; or(Predicate&amp;lt;? super T&amp;gt; other) &lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;default Predicate&amp;lt;T&amp;gt; negate()&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;default Predicate&amp;lt;T&amp;gt; and(Predicate&amp;lt;? super T&amp;gt; other)&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;static &amp;lt;T&amp;gt; Predicate&amp;lt;T&amp;gt; isEqual(Object targetRef)&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;函数式编程，注重传递行为，而不是传递值。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class PredicateTest2 {
    /**
     * 测试Predicate中的test方法
     */
    public static void main(String[] args) {
        List&amp;lt;Integer&amp;gt; list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);

        PredicateTest2 predicateTest2 = new PredicateTest2();
        //获取大于5的数字
        predicateTest2.getAllFunction(list,item -&amp;gt; item &amp;gt; 5);
        System.out.println(&quot;--------&quot;);
        //获取所有的偶数
        predicateTest2.getAllFunction(list,item -&amp;gt; item % 2 ==0);
        System.out.println(&quot;--------&quot;);
        //获取所有的数字
        predicateTest2.getAllFunction(list,item -&amp;gt; true);
        //获取大于5并且是偶数的
        System.out.println(&quot;--------&quot;);
        predicateTest2.testAnd(list,item -&amp;gt; item &amp;gt; 5,item -&amp;gt; item % 2 == 0);
    }

    public void getAllFunction(List&amp;lt;Integer&amp;gt; list, Predicate&amp;lt;Integer&amp;gt; predicate){
        for (Integer integer : list) {
            if (predicate.test(integer)) {
                System.out.println(integer);
            }
        }
    }
  
     // test or  and
    public  void testAnd(List&amp;lt;Integer&amp;gt; list,Predicate&amp;lt;Integer&amp;gt;        integerPredicate,Predicate&amp;lt;Integer&amp;gt; integerPredicate1){
        for (Integer integer : list) {
            if (integerPredicate.and(integerPredicate1).test(integer)) {
                System.out.println(integer);
            }  
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;lambda表达式到底给我们带来了什么？原来通过面向对象的时候一个方法只能执行一种功能。现在传递的是行为，一个方法可以多次调用。&lt;/p&gt;
&lt;p&gt;逻辑与或非三种的理解.&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;Supplier类&lt;/strong&gt; 供应厂商；供应者 （不接收参数，返回结果）&lt;/p&gt;
&lt;p&gt;用于什么场合？ 工厂&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;2020年1月3日08:06:28&lt;br/&gt;BinaryOperator 接口&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class SinaryOpertorTest {

    public static void main(String[] args) {

        SinaryOpertorTest sinaryOpertorTest = new SinaryOpertorTest();

        System.out.println(sinaryOpertorTest.compute(1,2,(a,b) -&amp;gt; a+b));

        System.out.println(&quot;-- -- - - - -- -&quot;);

        System.out.println(sinaryOpertorTest.getMax(&quot;hello123&quot;,&quot;world&quot;,(a,b) -&amp;gt; a.length() - b.length()));
    }

    private int compute(int a, int b, BinaryOperator&amp;lt;Integer&amp;gt; binaryOperator) {
        return binaryOperator.apply(a, b);
    }

    private String getMax(String a, String b, Comparator&amp;lt;String&amp;gt; comparator) {
        return BinaryOperator.maxBy(comparator).apply(a, b);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Optional&lt;/strong&gt; final ：Optional 不要试图用来当做参数， 一般只用来接收返回值，来规避值的空指针异常的问题。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;empty()&lt;/li&gt;
&lt;li&gt;of()&lt;/li&gt;
&lt;li&gt;ofNullable()&lt;/li&gt;
&lt;li&gt;isPresent()&lt;/li&gt;
&lt;li&gt;get()&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class OptionalTest {

    public static void main(String[] args) {
        Optional&amp;lt;String&amp;gt; optional = Optional.of(&quot;hello&quot;);

        //不确定是否为 空是 调用和这个方法
//        Optional&amp;lt;String&amp;gt; optional2 = Optional.ofNullable(&quot;hello&quot;);

//        Optional&amp;lt;String&amp;gt; optional1 = Optional.empty();


        //过时
//        if (optional.isPresent()) {
//            System.out.println(optional.get());
//        }

        optional.ifPresent(item -&amp;gt; System.out.println(item));
        System.out.println(optional.orElse(&quot;nihao&quot;));
        System.out.println(optional.orElseGet(() -&amp;gt; &quot;nihao&quot;));

    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class OptionalTest2 {
    public static void main(String[] args) {
        Employee employee = new Employee();
        employee.setName(&quot;dawa&quot;);

        Employee employee1 = new Employee();
        employee1.setName(&quot;erwa&quot;);

        List&amp;lt;Employee&amp;gt; list = Arrays.asList(employee, employee1);
        Company company = new Company(&quot;gongsi&quot;, list);

        Optional&amp;lt;Company&amp;gt; optionalCompany = Optional.ofNullable(company);

        System.out.println(optionalCompany.map(company1 -&amp;gt; company1.getList()).orElse(Collections.emptyList()));
    }
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;2020你还不会Java8新特性？方法引用详解及Stream 流介绍和操作方式详解（三）&lt;/p&gt;
&lt;h2 id=&quot;方法引用详解&quot;&gt;方法引用详解&lt;/h2&gt;
&lt;p&gt;方法引用： method reference&lt;/p&gt;
&lt;p&gt;方法引用实际上是Lambda表达式的一种语法糖&lt;/p&gt;
&lt;p&gt;我们可以将方法引用看作是一个「函数指针」，function pointer&lt;/p&gt;
&lt;h3 id=&quot;方法引用共分为4类&quot;&gt;方法引用共分为4类：&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;类名：：静态方法名&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;引用名（对象名）：：实例方法名&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;类名：：实例方法名&lt;/strong&gt; （比较不好理解，个地方调用的方法只有一个参数,为什么还能正常调用呢? 因为调用比较时,第一个对象来调用getStudentByScore1. 第二个对象来当做参数）&lt;/li&gt;
&lt;li&gt;构造方法引用: &lt;strong&gt;类名：：new&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class StudentTest {

    public static void main(String[] args) {
        Student student = new Student(&quot;zhangsan&quot;,10);
        Student student1 = new Student(&quot;lisi&quot;,40);
        Student student2 = new Student(&quot;wangwu&quot;,30);
        Student student3 = new Student(&quot;zhaoliu&quot;,550);

        List&amp;lt;Student&amp;gt; list = Arrays.asList(student, student2, student3, student1);

//        list.forEach(item -&amp;gt; System.out.println(item.getName()));

        //1. 类名 :: 静态方法
//        list.sort((studentpar1,studentpar2) -&amp;gt; Student.getStudentByScore(studentpar1,studentpar2));
        list.sort(Student::getStudentByScore);
        list.forEach(item -&amp;gt; System.out.println(item.getScore()));
        System.out.println(&quot; - - - - - - - -- &quot;);

        // 2. 引用名（对象名）：：实例方法名
        StudentMethod studentMethod = new StudentMethod();
        list.sort(studentMethod::getStudentBySource);
        list.forEach(item -&amp;gt; System.out.println(item.getScore()));
        System.out.println(&quot; - - - -- -- &quot;);

        // 3. 类名:: 实例方法名
        // 这个地方调用的方法只有一个参数,为什么还能正常调用呢? 因为调用比较时,第一个对象来调用getStudentByScore1. 第二个对象来当做参数
        list.sort(Student::getStudentByScore1);
        list.forEach(item -&amp;gt; System.out.println(item.getScore()));
        System.out.println(&quot;- - - - - - - -&quot;);

        // 原生的sort 来举个例子
        List&amp;lt;String&amp;gt; list1 = Arrays.asList(&quot;da&quot;, &quot;era&quot;, &quot;a&quot;);
//        Collections.sort(list1,(city1,city2) -&amp;gt; city1.compareToIgnoreCase(city2));
        list1.sort(String::compareToIgnoreCase);
        list1.forEach(System.out::println);
        System.out.println(&quot;- - - - - - -- &quot;);

        //4. 构造方法引用
        StudentTest studentTest = new StudentTest();
        System.out.println(studentTest.getString(String::new));
    }

    public String getString(Supplier&amp;lt;String&amp;gt; supplier) {
        return supplier.get()+&quot;hello&quot;;
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h2 id=&quot;默认方法&quot;&gt;默认方法&lt;/h2&gt;
&lt;p&gt;defaute method&lt;/p&gt;
&lt;p&gt;默认方法是指实现此接口时，默认方法已经被默认实现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;引入默认方法最重要的作用就是Java要保证向后兼容。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;情景一： 一个类，实现了两个接口。两个接口中有一个相同名字的默认方法。此时会报错，需要从写这个重名的方法&lt;/p&gt;
&lt;p&gt;情景二： 约定：实现类的优先级比接口的优先级要高。 一个类，实现一个接口，继承一个实现类。接口和实现类中有一个同名的方法，此时，此类会使用实现类中的方法。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;stream-流介绍和操作方式详解&quot;&gt;Stream 流介绍和操作方式详解&lt;/h2&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;Collection提供了新的stream()方法。&lt;/p&gt;
&lt;p&gt;流不存储值，通过管道的方式获取值。&lt;/p&gt;
&lt;p&gt;本质是函数式的，对流的操作会生成一个结果，不过并不会修改底层的数据源，集合可以作为流的底层数据源。&lt;/p&gt;
&lt;p&gt;延迟查找，很多流操作（过滤、映射、排序等）等可以延迟实现。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通过流的方式可以更好的操作集合。使用函数式编程更为流程。与lambda表达式搭配使用。&lt;/p&gt;
&lt;h4 id=&quot;流由3部分构成&quot;&gt;流由3部分构成：&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;源&lt;/li&gt;
&lt;li&gt;零个或多个中间操作（操作的是谁？操作的是源）&lt;/li&gt;
&lt;li&gt;终止操作（得到一个结果）&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;流操作的分类&quot;&gt;流操作的分类：&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;惰性求值（中间操作）&lt;/li&gt;
&lt;li&gt;及早求值（种植操作）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;使用链式的调用方式sunc as : stream.xxx().yyy().zzz().count(); 没有count的时候前边的三个方法不会被调用。后续会进行举例。&lt;/p&gt;
&lt;p&gt;掌握流常用的api，了解底层。&lt;/p&gt;
&lt;p&gt;流支持并行化，可以多线程操作。迭代器不支持并行化。&lt;/p&gt;
&lt;h3 id=&quot;流怎么用&quot;&gt;流怎么用？&lt;/h3&gt;
&lt;h4 id=&quot;流的创建方式&quot;&gt;流的创建方式&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;通过静态方法 ： Stream stream = Stream.of();&lt;/li&gt;
&lt;li&gt;通过数组：Arrays.stream();&lt;/li&gt;
&lt;li&gt;通过集合创建对象：Stream stream = list.stream;&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;流的简单应用&quot;&gt;流的简单应用&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; public static void main(String[] args) {
        IntStream.of(1,2,4,5,6).forEach(System.out::println);
        IntStream.range(3, 8).forEach(System.out::println);
        IntStream.rangeClosed(3, 8).forEach(System.out::println);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;举例将一个数组中的数字都乘以二然后求和&quot;&gt;举例：将一个数组中的数字都乘以二，然后求和。&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; public static void main(String[] args) {
        List&amp;lt;Integer&amp;gt; list = Arrays.asList(1, 2, 3, 4, 5);
        System.out.println(list.stream().map(i -&amp;gt; i*2).reduce(0,Integer::sum));
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;函数式编程和传统面向对象编程根本上有什么不同？&lt;/p&gt;
&lt;p&gt;传统面向对象编程传递的是数据。函数式编程通过方法传递的是一种行为，行为指导了函数的处理，根据行为对数据进行加工。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;举例流转换成list的练习&quot;&gt;举例：流转换成list的练习&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; public static void main(String[] args) {

        Stream&amp;lt;String&amp;gt; stream = Stream.of(&quot;hello&quot;, &quot;world&quot;, &quot;hello world&quot;);
//        String[] stringArray = stream.toArray(length -&amp;gt; new String[length]);
        //替换成方法引用的方式  --&amp;gt; 构造方法引用.
        String[] stringArray = stream.toArray(String[]::new);
        Arrays.asList(stringArray).forEach(System.out::println);
        System.out.println(&quot;- - - - - - - - - - -&quot;);

        //将流转换成list,   有现成的封装好的方法
        Stream&amp;lt;String&amp;gt; stream1 = Stream.of(&quot;hello&quot;, &quot;world&quot;, &quot;hello world&quot;);
        List&amp;lt;String&amp;gt; collect = stream1.collect(Collectors.toList());// 本身是一个终止操作
        collect.forEach(System.out::println);

        System.out.println(&quot;- - - - - - &quot;);

        //使用原生的 collect 来将流转成List
        Stream&amp;lt;String&amp;gt; stream2 = Stream.of(&quot;hello&quot;, &quot;world&quot;, &quot;hello world&quot;);
//        List&amp;lt;String&amp;gt; lis = stream2.collect(() -&amp;gt; new ArrayList(), (theList, item) -&amp;gt; theList.add(item),
//                (theList1, theList2) -&amp;gt; theList1.addAll(theList2));
        // 将上面的转换成方法引用的方式  -- 这种方法不好理解.
        List&amp;lt;String&amp;gt; list = stream2.collect(LinkedList::new, LinkedList::add, LinkedList::addAll);
        //这种方法,如果想要返回ArrayList也可以实现.
//        List&amp;lt;String&amp;gt; list1 = stream2.collect(ArrayList::new, ArrayList::add, ArrayList::addAll);
        list.forEach(System.out::println);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;collectors类中包含了流转换的多个辅助类&quot;&gt;Collectors类中包含了流转换的多个辅助类&lt;/h3&gt;
&lt;h4 id=&quot;举例-将流-转成各种类型的数据&quot;&gt;举例： 将流 转成各种类型的数据。&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void main(String[] args) {
        Stream&amp;lt;String&amp;gt; stream = Stream.of(&quot;hello&quot;, &quot;world&quot;, &quot;hello world&quot;);

        //将流转换成List 另一种方法
//        List&amp;lt;String&amp;gt; list= stream.collect(Collectors.toCollection(ArrayList::new));
//        list.forEach(System.out::println);

        //将流转成set
//        Set&amp;lt;String&amp;gt; set = stream.collect(Collectors.toSet());
        //转成TreeSet
//        TreeSet&amp;lt;String&amp;gt; set = stream.collect(Collectors.toCollection(TreeSet::new));
//        set.forEach(System.out::println);

        //转成字符串
        String string = stream.collect(Collectors.joining());
        System.out.println(string);

        //Collectors 类中有多重辅助的方法.

    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;遇到问题的时候，先思考一下能否用方法引用的方式，使用流的方式来操作。&lt;/strong&gt;因为用起来比较简单。&lt;/p&gt;
&lt;h4 id=&quot;举例将集合中的每一个元素-转换成大写的字母-给输出来&quot;&gt;举例：将集合中的每一个元素 转换成大写的字母, 给输出来。&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void main(String[] args) {
        //将集合中的每一个元素 转换成大写的字母, 给输出来
        List&amp;lt;String&amp;gt; list = Arrays.asList(&quot;hello&quot;,&quot;world&quot;,&quot;hello world&quot;);

        //转成字符串,然后转成大写.
//        System.out.println(list.stream().collect(Collectors.joining()).toUpperCase());
        //上面的代码 可以转换成下边的代码.
//        System.out.println(String.join(&quot;&quot;, list).toUpperCase());

        //视频上给出的   还是List的大写
        list.stream().map(String::toUpperCase).collect(Collectors.toList()).forEach(System.out::println);
  
  //将集合 的数据给平方一下输出.
        List&amp;lt;Integer&amp;gt; list1 = Arrays.asList(1, 2, 3, 4, 5);
        list1.stream().map(item -&amp;gt; item * item).collect(Collectors.toList()).forEach(System.out::println);

}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;流中的 .map () 方法，是对集合中的每一个数据进行一下操作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;stream-的-flat操作-打平操作&quot;&gt;stream 的 flat操作。 打平操作。&lt;/h4&gt;
&lt;pre class=&quot;java &quot;&gt;
&lt;code&gt;public static void main(String[] args) {
// 举例:   flag 的操作, 打平. 一个集合中有三个数组, 打平之后,三个数组的元素依次排列.
Stream&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; stream = Stream.of(Arrays.asList(1), Arrays.asList(2, 3), Arrays.asList(4, 5));
//将里边每一个ArrayList的数据 做一个平方.  然后打平. 输出一个list
stream.flatMap(theList -&amp;gt; theList.stream()).map(item -&amp;gt; item * item).forEach(System.out::println);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;stream-其他方法介绍&quot;&gt;Stream 其他方法介绍：&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void main(String[] args) {
//        stream 其他方法介绍.

        //  generate(). 生成stream对象
        Stream&amp;lt;String&amp;gt; stream = Stream.generate(UUID.randomUUID()::toString);
//        System.out.println(stream.findFirst().get());
// findFirst,找到第一个对象.然后就短路了,会返回一个Optional对象(为了避免NPE),不符合函数式编程
//        stream.findFirst().isPresent(System.out::print);

        // iterate()     会生成 一个 无限的串行流.
        // 一般不会单独使用. 会使用limit  来限制一下总长度.
        Stream.iterate(1, item -&amp;gt; item + 2).limit(6).forEach(System.out::println);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;stream-运算练习stream提供了各种操作符&quot;&gt;Stream 运算练习：（Stream提供了各种操作符）&lt;/h3&gt;
&lt;h4 id=&quot;举例找出该流中大于2的元素然后每个元素2-然后忽略掉流中的前两个元素然后再取流中的前两个元素最后求出流元素中的总和.&quot;&gt;举例：找出该流中大于2的元素,然后每个元素*2 ,然后忽略掉流中的前两个元素,然后再取流中的前两个元素,最后求出流元素中的总和.&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; Stream&amp;lt;Integer&amp;gt; stream = Stream.iterate(1, item -&amp;gt; item + 2).limit(6);
        //找出该流中大于2的元素,先使用filter()过滤.
        //每个元素*2 使用mapToInt 避免重复拆箱.
        //忽略掉流中的前两个元素; 使用 skip(2)
        //再取流中的前两个元素;  使用limit(2)
        //求出流元素中的总和.  使用sum()
System.out.println(stream.filter(item -&amp;gt; item&amp;gt;2).mapToInt(item -&amp;gt; item * 2).skip(2).limit(2).sum());&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;举例找出该流中大于2的元素然后每个元素2-然后忽略掉流中的前两个元素然后再取流中的前两个元素最后找到最小的元素.&quot;&gt;举例：找出该流中大于2的元素,然后每个元素*2 ,然后忽略掉流中的前两个元素,然后再取流中的前两个元素,最后找到最小的元素.&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    // .min() 返回的是IntOptional.
//        System.out.println(stream.filter(item -&amp;gt; item&amp;gt;2).mapToInt(item -&amp;gt; item * 2).skip(2).limit(2).min());
        //应该这样调用. 上边的可能会出NPE异常
        stream.filter(item -&amp;gt; item&amp;gt;2).mapToInt(item -&amp;gt; item * 2).skip(2).limit(2).min().ifPresent(System.out::println);&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;举例获取最大值最小值求和等各种操作-.summarystatistics&quot;&gt;举例：&lt;strong&gt;获取最大值，最小值，求和等各种操作。&lt;/strong&gt; .summaryStatistics();&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gaknkekkh8j31qq0k8afp.jpg&quot; alt=&quot;image-20200104172236805&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在练习的过程中发现了一个问题。如果是这样连续打印两条对流操作之后的结果。会报流未关闭的异常。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gakn57mavbj31pi05wmyl.jpg&quot; alt=&quot;image-20200104170801230&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gakno23qqij31os0amadh.jpg&quot; alt=&quot;image-20200104172608140&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;注意事项流被重复使用了或者流被关闭了就会出异常&quot;&gt;注意事项：&lt;strong&gt;流被重复使用了，或者流被关闭了，就会出异常。&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;如何避免：&lt;strong&gt;使用方法链的方式来处理流&lt;/strong&gt;。 具体出现的原因，后续进行详细的源码讲解。&lt;/p&gt;
&lt;hr/&gt;&lt;h4 id=&quot;举例-中间操作惰性求值-和中止操作及早求值本质的区别&quot;&gt;举例 ：中间操作(惰性求值) 和中止操作(及早求值)本质的区别&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void main(String[] args) {
    List&amp;lt;String&amp;gt; list = Arrays.asList(&quot;hello&quot;, &quot;world&quot;, &quot;hello world&quot;);

    //首字母转大写
    list.stream().map(item -&amp;gt;{
        String s = item.substring(0, 1).toUpperCase() + item.substring(1);
        System.out.println(&quot;test&quot;);
        return s;
    }).forEach(System.out::println);
    //没有遇到中止操作时,是不会执行中间操作的.是延迟的
    // 遇到.forEach() 中止操作时,才会执行中间操作的代码
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;举例流使用顺序不同的区别&quot;&gt;&lt;strong&gt;举例：流使用顺序不同的区别&lt;/strong&gt;&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//程序不会停止
IntStream.iterate(0,i-&amp;gt;(i+1)%2).distinct().limit(6).forEach(System.out::println);
//程序会停止
IntStream.iterate(0,i-&amp;gt;(i+1)%2).limit(6).distinct().forEach(System.out::println);&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h2 id=&quot;stream底层深入&quot;&gt;Stream底层深入&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;和迭代器不同的是，Stream可以并行化操作，迭代器只能命令式地、串行化操作&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;当使用穿行方式去遍历时，每个item读完后再读下一个item&lt;/li&gt;
&lt;li&gt;使用并行去遍历时，数据会被分成多个段，其中每一个都在&lt;strong&gt;不同的线程&lt;/strong&gt;中处理，然后将结果一起输出。&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Stream的并行操作依赖于Java7中引入的Fork/Join框架。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;流stream由3部分构成&quot;&gt;流(Stream)由3部分构成：&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;源（Source）&lt;/li&gt;
&lt;li&gt;零个或多个中间操作(Transforming values)（操作的是谁？操作的是源）&lt;/li&gt;
&lt;li&gt;终止操作（Operations)(得到一个结果）&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;内部迭代和外部迭代&quot;&gt;内部迭代和外部迭代&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;描述性的语言：sql和Stream的对比&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;select name from student where age &amp;gt; 20 and address = 'beijing' order by desc;&lt;/p&gt;
&lt;p&gt;===================================================================================&lt;/p&gt;
&lt;p&gt;Student.stream().filter(student -&amp;gt; student.getAge &amp;gt;20 ).filter(student -&amp;gt; student.getAddress().equals(&quot;beijing&quot;)).sorted(..).forEach(student -&amp;gt; System.out.println(student.getName));&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上述的描述，并没有明确的告诉底层具体要怎么做，只是发出了描述性的信息。这种流的方式就叫做&lt;strong&gt;内部迭代&lt;/strong&gt;。针对于性能来说，流的操作肯定不会降低性能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;外边迭代&lt;/strong&gt;举例： jdk8以前的用的方式。&lt;/p&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;List list = new ArrayList&amp;lt;&amp;gt;();&lt;/p&gt;
&lt;p&gt;for(int i = 0 ;i &amp;lt;= students.size();i++){&lt;/p&gt;
&lt;p&gt;​ Student student = students.get(i);&lt;/p&gt;
&lt;p&gt;If(student.getAge() &amp;gt; 20 )&lt;/p&gt;
&lt;p&gt;​ list.add(student);&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;Collections.sort(list.....)&lt;/p&gt;
&lt;p&gt;list.forEach().....&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Stream的出现和集合是密不可分的。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;集合关注的是数据与数据存储本身，流关注的则是对数据的计算。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;流与迭代器类似的一点是:流是无法重复使用或消费的。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;如何区分中间操作和中止操作&quot;&gt;如何区分中间操作和中止操作：&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;中间操作&lt;/strong&gt;都会返回一个Stream对象，比如说返回Stream,Stream,Stream;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;中止操作&lt;/strong&gt;则不会返回Stream类型，可能不返回值，也可能返回其他类型的单个值。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;并行流的基本使用&quot;&gt;并行流的基本使用&lt;/h3&gt;
&lt;h4 id=&quot;举例-串行流和并行流的简单举例比较&quot;&gt;举例： 串行流和并行流的简单举例比较&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void main(String[] args) {
    // 串行流和并行流的比较
    List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(5000000);

    for (int i = 0; i &amp;lt; 5000000; i++) {
        list.add(UUID.randomUUID().toString());
    }

    System.out.println(&quot;开始排序&quot;);
    long startTime = System.nanoTime();
    //   list.parallelStream().sorted().count(); //串行流
    list.parallelStream().sorted().count(); //并行流
    long endTime = System.nanoTime();
    long millis = TimeUnit.NANOSECONDS.toMillis(endTime - startTime);
    System.out.println(&quot;排序时间为: &quot;+ millis);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gakprha8jaj30l806ewew.jpg&quot; alt=&quot;image-20200104183834756&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gakpsaw5ptj30ic06w3yx.jpg&quot; alt=&quot;image-20200104183924340&quot;/&gt;&lt;/p&gt;
&lt;p&gt;结果如图，并行流和串行流时间上错了4倍。&lt;/p&gt;
&lt;h4 id=&quot;举例-打印出列表中出来第一个长度为5的单词..-同时将长度5打印出来.&quot;&gt;举例： 打印出列表中出来第一个长度为5的单词.. 同时将长度5打印出来.&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; public static void main(String[] args) {
        List&amp;lt;String&amp;gt; list = Arrays.asList(&quot;hello&quot;, &quot;world&quot;, &quot;hello world&quot;);

//        list.stream().mapToInt(item -&amp;gt; item.length()).filter(length -&amp;gt; length ==5)
//                      .findFirst().ifPresent(System.out::println);

        list.stream().mapToInt(item -&amp;gt; {
            int length = item.length();
            System.out.println(item);
            return length;
        }).filter(length -&amp;gt; length == 5).findFirst().ifPresent(System.out::println);
    //返回的是hello  , 不包含 world.  
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回的是hello , 不包含 world.&lt;/p&gt;
&lt;p&gt;流的操作原理： 把流想成一个容器，里边存储的是对每一个元素的操作。操作时，把操作串行化。对同一个元素进行串行的操作。&lt;strong&gt;操作中还包含着短路操作。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;举例-找出-这个集合中所有的单词而且要去重.-flatmap的使用&quot;&gt;举例： 找出 这个集合中所有的单词,而且要去重. flatMap()的使用。&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void main(String[] args) {
        //举例; 找出 这个集合中所有的单词,而且要去重.
        List&amp;lt;String&amp;gt; list = Arrays.asList(&quot;hello welcome&quot;, &quot;world hello&quot;, &quot;hello world&quot;, &quot;hello hello world&quot;);

//        list.stream().map(item -&amp;gt; item.split(&quot; &quot;)).distinct()
//                .collect(Collectors.toList()).forEach(System.out::println);

        //使用map不能满足需求, 使用flatMap
        list.stream().map(item -&amp;gt; item.split(&quot; &quot;)).flatMap(Arrays::stream)
                .distinct().collect(Collectors.toList()).forEach(System.out::println);

        //结果为  hello  welcome world 
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;举例组合起来.-打印出-hi-zhangsan-hi-lisi-hi-wangwu-hello-zhangsan-hello-lisi-....-flatmap的使用&quot;&gt;举例：组合起来. 打印出 hi zhangsan , hi lisi , hi wangwu , hello zhangsan , hello lisi .... flatMap()的使用。&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void main(String[] args) {

    //组合起来. 打印出  hi zhangsan , hi lisi , hi wangwu , hello zhangsan , hello lisi ....
    List&amp;lt;String&amp;gt; list = Arrays.asList(&quot;Hi&quot;, &quot;Hello&quot;, &quot;你好&quot;);
    List&amp;lt;String&amp;gt; list1 = Arrays.asList(&quot;zhangsan&quot;, &quot;lisi&quot;, &quot;wangwu&quot;);

    List&amp;lt;String&amp;gt; collect = list.stream().flatMap(item -&amp;gt; list1.stream().map(item2 -&amp;gt; item + &quot; &quot; +
            item2)).collect(Collectors.toList());

    collect.forEach(System.out::println);

}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;举例-流对分组分区操作的支持.-group-by-protition-by&quot;&gt;举例： 流对分组/分区操作的支持. group by / protition by&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; public static void main(String[] args) {
        //数据准备.
        Student student1 = new Student(&quot;zhangsan&quot;, 100, 20);
        Student student2 = new Student(&quot;lisi&quot;, 90, 20);
        Student student3 = new Student(&quot;wangwu&quot;, 90, 30);
        Student student4 = new Student(&quot;zhangsan&quot;, 80, 40);
        List&amp;lt;Student&amp;gt; students = Arrays.asList(student1, student2, student3, student4);

        //对学生按照姓名分组.
        Map&amp;lt;String, List&amp;lt;Student&amp;gt;&amp;gt; listMap = students.stream().collect(Collectors.groupingBy(Student::getName));
        System.out.println(listMap);

        //对学生按照分数分组.
        Map&amp;lt;Integer, List&amp;lt;Student&amp;gt;&amp;gt; collect = students.stream().collect(Collectors.groupingBy(Student::getScore));
        System.out.println(collect);

        //按照年龄分组.
        Map&amp;lt;Integer, List&amp;lt;Student&amp;gt;&amp;gt; ageMap = students.stream().collect(Collectors.groupingBy(Student::getAge));
        System.out.println(ageMap);

        //按照名字分组后,获取到每个分组的元素的个数.
        Map&amp;lt;String, Long&amp;gt; nameCount = students.stream().collect(Collectors.groupingBy(Student::getName, Collectors.counting()));
        System.out.println(nameCount);

        //按照名字分组,求得每个组的平均值.
        Map&amp;lt;String, Double&amp;gt; doubleMap = students.stream().collect(Collectors.groupingBy(Student::getName, Collectors.averagingDouble(Student::getScore)));
        System.out.println(doubleMap);
   
            //分区,  分组的一种特例. 只能分两个组 true or flase .   partitioning  By
        Map&amp;lt;Boolean, List&amp;lt;Student&amp;gt;&amp;gt; collect1 = students.stream().collect(Collectors.partitioningBy(student -&amp;gt; student.getScore() &amp;gt;= 90));
        System.out.println(collect1);

    }&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;继续学习Java8 新特性。&lt;/p&gt;
&lt;h2 id=&quot;collector类源码分析2020了你还不会java8新特性&quot;&gt;Collector类源码分析2020了你还不会Java8新特性？&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;jdk8是怎么对底层完成支持的。不了解底层，平时用还可以，但是遇到问题的时候就会卡在那里。迟迟灭有解决方案。在学习一门新技术时，先学习怎么去用，不要执着于源码。但是随着用的越来越多，你去了解底层是比较好的一种学习方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;有多种方法可以实现同一个功能.什么方式更好呢? 越具体的方法越好.   减少自动装箱拆箱操作&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;collect : 收集器&lt;/li&gt;
&lt;li&gt;Collector作为collect方法的参数。&lt;/li&gt;
&lt;li&gt;Collector作为一个接口。它是一个可变的汇聚操作，将输入元素累计到一个可变的结果容器中；它会在所有元素都处理完毕后将累计的结果作为一个最终的表示（这是一个可选操作）；它支持串行与并行两种方式执行。（并不是说并行一定比串行快。）&lt;/li&gt;
&lt;li&gt;Collects本身提供了关于Collectoe的常见汇聚实现，Collectors本身实际上是一个工厂。&lt;/li&gt;
&lt;li&gt;为了确保串行和并行的结果一致，需要进行额外的处理。必须要满足两个约束。&lt;br/&gt;identity 同一性&lt;br/&gt;associativity 结合性&lt;/li&gt;
&lt;li&gt;同一性：对于任何一条并行线路来说 ，需要满足a == combiner.apply(a, supplier.get())。举例来说：&lt;br/&gt;（List list1,List list2 -&amp;gt; {list1.addAll(list2);return list1}）&lt;br/&gt;结合性： 下方有举例。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;collector收集器的实现源码详解&quot;&gt;Collector收集器的实现源码详解&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * A &amp;lt;a href=&quot;package-summary.html#Reduction&quot;&amp;gt;mutable reduction operation&amp;lt;/a&amp;gt; that
 * accumulates input elements into a mutable result container, optionally transforming
 * the accumulated result into a final representation after all input elements
 * have been processed.  Reduction operations can be performed either sequentially
 * or in parallel.
 
    Collector作为一个接口。它是一个可变的汇聚操作，将输入元素累计到一个可变的结果容器中；它会在所有元素都处理   完毕后将累计的结果作为一个最终的表示（这是一个可选操作）；它支持串行与并行两种方式执行。（并不是说并行一定比串行快。）
  
 * &amp;lt;p&amp;gt;Examples of mutable reduction operations include:
 * accumulating elements into a {@code Collection}; concatenating
 * strings using a {@code StringBuilder}; computing summary information about
 * elements such as sum, min, max, or average; computing &quot;pivot table&quot; summaries
 * such as &quot;maximum valued transaction by seller&quot;, etc.  The class {@link Collectors}
 * provides implementations of many common mutable reductions.
 
 Collects本身提供了关于Collectoe的常见汇聚实现，Collectors本身实际上是一个工厂。
 
 * &amp;lt;p&amp;gt;A {@code Collector} is specified by four functions that work together to
 * accumulate entries into a mutable result container, and optionally perform
 * a final transform on the result.  They are: &amp;lt;ul&amp;gt;
 *     &amp;lt;li&amp;gt;creation of a new result container ({@link #supplier()})&amp;lt;/li&amp;gt;
 *     &amp;lt;li&amp;gt;incorporating a new data element into a result container ({@link #accumulator()})&amp;lt;/li&amp;gt;
 *     &amp;lt;li&amp;gt;combining two result containers into one ({@link #combiner()})&amp;lt;/li&amp;gt;
 *     &amp;lt;li&amp;gt;performing an optional final transform on the container ({@link #finisher()})&amp;lt;/li&amp;gt;
 * &amp;lt;/ul&amp;gt;
 
    Collector 包含了4个参数
 
 * &amp;lt;p&amp;gt;Collectors also have a set of characteristics, such as
 * {@link Characteristics#CONCURRENT}, that provide hints that can be used by a
 * reduction implementation to provide better performance.
 *
 * &amp;lt;p&amp;gt;A sequential implementation of a reduction using a collector would
 * create a single result container using the supplier function, and invoke the
 * accumulator function once for each input element.  A parallel implementation
 * would partition the input, create a result container for each partition,
 * accumulate the contents of each partition into a subresult for that partition,
 * and then use the combiner function to merge the subresults into a combined
 * result.
 
   举例说明： 
  1，2， 3， 4     四个部分结果。
  1，2 -》 5  
  5，3 -》 6
  6，4 -》 6  
 
 
 ### 同一性和结合性的解析： 
 
 * &amp;lt;p&amp;gt;To ensure that sequential and parallel executions produce equivalent
 * results, the collector functions must satisfy an &amp;lt;em&amp;gt;identity&amp;lt;/em&amp;gt; and an
 * &amp;lt;a href=&quot;package-summary.html#Associativity&quot;&amp;gt;associativity&amp;lt;/a&amp;gt; constraints.
 
 为了确保串行和并行的结果一致，需要进行额外的处理。必须要满足两个约束。
             identity 同一性
                associativity  结合性
 
 * &amp;lt;p&amp;gt;The identity constraint says that for any partially accumulated result,
 * combining it with an empty result container must produce an equivalent
 * result.  That is, for a partially accumulated result {@code a} that is the
 * result of any series of accumulator and combiner invocations, {@code a} must
 * be equivalent to {@code combiner.apply(a, supplier.get())}.
  
    同一性： 对于任何一条并行线路来说,需要满足a == combiner.apply(a, supplier.get())
 
 * &amp;lt;p&amp;gt;The associativity constraint says that splitting the computation must
 * produce an equivalent result.  That is, for any input elements {@code t1}
 * and {@code t2}, the results {@code r1} and {@code r2} in the computation
 * below must be equivalent:
 * &amp;lt;pre&amp;gt;{@code
 *     A a1 = supplier.get();               串行： 
 *     accumulator.accept(a1, t1);  第一个参数，每次累加的中间结果。 第二个参数，下一个要处理的参数
 *     accumulator.accept(a1, t2);
 *     R r1 = finisher.apply(a1);  // result without splitting
 *      
 *     A a2 = supplier.get();               并行： 
 *     accumulator.accept(a2, t1);  第一个参数，每次累加的中间结果。 第二个参数，下一个要处理的参数
 *     A a3 = supplier.get();
 *     accumulator.accept(a3, t2);
 *     R r2 = finisher.apply(combiner.apply(a2, a3));  // result with splitting
 * } &amp;lt;/pre&amp;gt;
 
 结合性： 如上例。  最终要求 r1 == r2 
 
 * &amp;lt;p&amp;gt;For collectors that do not have the {@code UNORDERED} characteristic,
 * two accumulated results {@code a1} and {@code a2} are equivalent if
 * {@code finisher.apply(a1).equals(finisher.apply(a2))}.  For unordered
 * collectors, equivalence is relaxed to allow for non-equality related to
 * differences in order.  (For example, an unordered collector that accumulated
 * elements to a {@code List} would consider two lists equivalent if they
 * contained the same elements, ignoring order.)

 对于无序的收集器来说，等价性就被放松了，会考虑到顺序上的区别对应的不相等性。
 两个集合中包含了相同的元素，但是忽略了顺序。这种情况下两个的集合也是等价的。
 
 
 ### collector复合与注意事项：
 
 * &amp;lt;p&amp;gt;Libraries that implement reduction （汇聚） based on {@code Collector}, such as
 * {@link Stream#collect(Collector)}, must adhere to the following constraints:
 * &amp;lt;ul&amp;gt;  
 *     &amp;lt;li&amp;gt;The first argument passed to the accumulator function, both
 *     arguments passed to the combiner function, and the argument passed to the
 *     finisher function must be the result of a previous invocation of the
 *     result supplier, accumulator, or combiner functions.&amp;lt;/li&amp;gt;
                
 *     &amp;lt;li&amp;gt;The implementation should not do anything with the result of any of
 *     the result supplier, accumulator, or combiner functions other than to
 *     pass them again to the accumulator, combiner, or finisher functions,
 *     or return them to the caller of the reduction operation.&amp;lt;/li&amp;gt;
 
             具体的实现来说，不应该对中间返回的结果进行额外的操作。除了最终的返回的结果。
        
 *     &amp;lt;li&amp;gt;If a result is passed to the combiner or finisher
 *     function, and the same object is not returned from that function, it is
 *     never used again.&amp;lt;/li&amp;gt;
 
            如果一个结果被传递给combiner or finisher，但是并没有返回一个你传递的对象，说明你生成了一个新的结果或者创建了新的对象。这个结果就不会再被使用了。
            
 *     &amp;lt;li&amp;gt;Once a result is passed to the combiner or finisher function, it
 *     is never passed to the accumulator function again.&amp;lt;/li&amp;gt;
 
                一旦一个结果被传递给了 combiner or finisher 函数，他就不会再被传递给了accumulator函数了。
 
 *     &amp;lt;li&amp;gt;For non-concurrent collectors, any result returned from the result
 *     supplier, accumulator, or combiner functions must be serially
 *     thread-confined.  This enables collection to occur in parallel without
 *     the {@code Collector} needing to implement any additional synchronization.
 *     The reduction implementation must manage that the input is properly
 *     partitioned, that partitions are processed in isolation, and combining
 *     happens only after accumulation is complete.&amp;lt;/li&amp;gt;
 
            线程和线程之间的处理都是独立的，最终结束时再进行合并。
            
 *     &amp;lt;li&amp;gt;For concurrent collectors, an implementation is free to (but not
 *     required to) implement reduction concurrently.  A concurrent reduction
 *     is one where the accumulator function is called concurrently from
 *     multiple threads, using the same concurrently-modifiable result container,
 *     rather than keeping the result isolated during accumulation.
 *     A concurrent reduction should only be applied if the collector has the
 *     {@link Characteristics#UNORDERED} characteristics or if the
 *     originating data is unordered.&amp;lt;/li&amp;gt;
    
            如果不是并发收集器，4个线程会生成4个中间结果。
            是并发收集器的话，4个线程会同时调用一个结果容器。
 
 * &amp;lt;/ul&amp;gt;
 *
 * &amp;lt;p&amp;gt;In addition to the predefined implementations in {@link Collectors}, the
 * static factory methods {@link #of(Supplier, BiConsumer, BinaryOperator, Characteristics...)}
 * can be used to construct collectors.  For example, you could create a collector
 * that accumulates widgets into a {@code TreeSet} with:
 *
 * &amp;lt;pre&amp;gt;{@code
 *     Collector&amp;lt;Widget, ?, TreeSet&amp;lt;Widget&amp;gt;&amp;gt; intoSet =
 *         Collector.of(TreeSet::new, TreeSet::add,
 *                      (left, right) -&amp;gt; { left.addAll(right); return left; });
 * }&amp;lt;/pre&amp;gt;
 
 通过Collector.of（传进一个新的要操作的元素，结果容器处理的步骤，多线程处理的操作）
 将流中的每个Widget 添加到TreeSet中
 
 
 * (This behavior is also implemented by the predefined collector
 * {@link Collectors#toCollection(Supplier)}).
 *
 * @apiNote  
 * Performing a reduction operation with a {@code Collector} should produce a
 * result equivalent to:
 * &amp;lt;pre&amp;gt;{@code
 *     R container = collector.supplier().get();
 *     for (T t : data)
 *         collector.accumulator().accept(container, t);
 *     return collector.finisher().apply(container);
 * }&amp;lt;/pre&amp;gt;
 
    api的说明：  collector的finisher汇聚的实现过程。
 
 * &amp;lt;p&amp;gt;However, the library is free to partition the input, perform the reduction
 * on the partitions, and then use the combiner function to combine the partial
 * results to achieve a parallel reduction.  (Depending on the specific reduction
 * operation, this may perform better or worse, depending on the relative cost
 * of the accumulator and combiner functions.)
 
 性能取决于accumulator and combiner的代价。  也就是说 并行流 并不一定比串行流效率高。
 
 * &amp;lt;p&amp;gt;Collectors are designed to be &amp;lt;em&amp;gt;composed&amp;lt;/em&amp;gt;; many of the methods
 * in {@link Collectors} are functions that take a collector and produce
 * a new collector.  For example, given the following collector that computes
 * the sum of the salaries of a stream of employees:
 * &amp;lt;pre&amp;gt;{@code
 *     Collector&amp;lt;Employee, ?, Integer&amp;gt; summingSalaries
 *         = Collectors.summingInt(Employee::getSalary))
 * }&amp;lt;/pre&amp;gt;
 
  搜集器是可以组合的：  take a collector and produce a new collector.  
  搜集器的实现过程。  如  员工的工资的求和。
 
 * If we wanted to create a collector to tabulate the sum of salaries by
 * department, we could reuse the &quot;sum of salaries&quot; logic using
 * {@link Collectors#groupingBy(Function, Collector)}:
 * &amp;lt;pre&amp;gt;{@code
 *     Collector&amp;lt;Employee, ?, Map&amp;lt;Department, Integer&amp;gt;&amp;gt; summingSalariesByDept
 *         = Collectors.groupingBy(Employee::getDepartment, summingSalaries);
 * }&amp;lt;/pre&amp;gt;
 
 如果我们想要新建一个搜集器，我们可以复用之前的搜集器。
 实现过程。
 
 * @see Stream#collect(Collector)
 * @see Collectors
 *
 * @param &amp;lt;T&amp;gt; the type of input elements to the reduction operation
            &amp;lt;T&amp;gt;  代表 流中的每一个元素的类型。
 * @param &amp;lt;A&amp;gt; the mutable accumulation type of the reduction operation (often
 *            hidden as an implementation detail)
            &amp;lt;A&amp;gt;  代表 reduction操作的可变容器的类型。表示中间操作生成的结果的类型（如ArrayList）。
 * @param &amp;lt;R&amp;gt; the result type of the reduction operation
            &amp;lt;R&amp;gt;  代表 结果类型
 * @since 1.8
 */
public interface Collector&amp;lt;T, A, R&amp;gt;{
   /**
     * A function that creates and returns a new mutable result container.
     *  A就代表每一次返回结果的类型
     * @return a function which returns a new, mutable result container
     */
    Supplier&amp;lt;A&amp;gt; supplier();   // 提供一个结果容器
    
    /**
     * A function that folds a value into a mutable result container.
     *  A代表中间操作返回结果的类型。 T是下一个代操作的元素的类型。
     * @return a function which folds a value into a mutable result container
     */
    BiConsumer&amp;lt;A, T&amp;gt; accumulator();    //不断的向结果容器中添加元素。

    /**
     * A function that accepts two partial results and merges them.  The
     * combiner function may fold state from one argument into the other and
     * return that, or may return a new result container.
     *  A 中间操作返回结果的类型。
     * @return a function which combines two partial results into a combined
     * result
     */
    BinaryOperator&amp;lt;A&amp;gt; combiner();   //在多线程中  合并 部分结果。 
  /**
  和并行流紧密相关的
    接收两个结果，将两个部分结果合并到一起。
  combiner函数，有4个线程同时去执行，那么就会有生成4个部分结果。
  
  举例说明： 
  1，2， 3， 4     四个部分结果。
  1，2 -》 5  
  5，3 -》 6
  6，4 -》 6  
   1,2合并返回5  属于return a new result container. 
   6,4合并返回6，属于The combiner function may fold state from one argument into the other and  return that。
   */

    /**
     * Perform the final transformation from the intermediate accumulation type
     * {@code A} to the final result type {@code R}.
     *R 是最终返回结果的类型。
     * &amp;lt;p&amp;gt;If the characteristic {@code IDENTITY_TRANSFORM} is
     * set, this function may be presumed to be an identity transform with an
     * unchecked cast from {@code A} to {@code R}.
     * 
     * @return a function which transforms the intermediate result to the final
     * result
     */
    Function&amp;lt;A, R&amp;gt; finisher();  //  合并中间的值，给出返回值。
  
    /**
     * Returns a {@code Set} of {@code Collector.Characteristics} indicating
     * the characteristics of this Collector.  This set should be immutable.
     *
     * @return an immutable set of collector characteristics
     */
    Set&amp;lt;Characteristics&amp;gt; characteristics();   //特征的集合

    /**
     * Returns a new {@code Collector} described by the given {@code supplier},
     * {@code accumulator}, and {@code combiner} functions.  The resulting
     * {@code Collector} has the {@code Collector.Characteristics.IDENTITY_FINISH}
     * characteristic.
     *
     * @param supplier The supplier function for the new collector
     * @param accumulator The accumulator function for the new collector
     * @param combiner The combiner function for the new collector
     * @param characteristics The collector characteristics for the new
     *                        collector
     * @param &amp;lt;T&amp;gt; The type of input elements for the new collector
     * @param &amp;lt;R&amp;gt; The type of intermediate accumulation result, and final result,
     *           for the new collector
     * @throws NullPointerException if any argument is null
     * @return the new {@code Collector}
     */
    public static&amp;lt;T, R&amp;gt; Collector&amp;lt;T, R, R&amp;gt; of(Supplier&amp;lt;R&amp;gt; supplier,
                                              BiConsumer&amp;lt;R, T&amp;gt; accumulator,
                                              BinaryOperator&amp;lt;R&amp;gt; combiner,
                                              Characteristics... characteristics) {
        Objects.requireNonNull(supplier);
        Objects.requireNonNull(accumulator);
        Objects.requireNonNull(combiner);
        Objects.requireNonNull(characteristics);
        Set&amp;lt;Characteristics&amp;gt; cs = (characteristics.length == 0)
                                  ? Collectors.CH_ID
                                  : Collections.unmodifiableSet(EnumSet.of(Collector.Characteristics.IDENTITY_FINISH,
                                                                           characteristics));
        return new Collectors.CollectorImpl&amp;lt;&amp;gt;(supplier, accumulator, combiner, cs);
    }

    /**
     * Returns a new {@code Collector} described by the given {@code supplier},
     * {@code accumulator}, {@code combiner}, and {@code finisher} functions.
     *
     * @param supplier The supplier function for the new collector
     * @param accumulator The accumulator function for the new collector
     * @param combiner The combiner function for the new collector
     * @param finisher The finisher function for the new collector
     * @param characteristics The collector characteristics for the new
     *                        collector
     * @param &amp;lt;T&amp;gt; The type of input elements for the new collector
     * @param &amp;lt;A&amp;gt; The intermediate accumulation type of the new collector
     * @param &amp;lt;R&amp;gt; The final result type of the new collector
     * @throws NullPointerException if any argument is null
     * @return the new {@code Collector}
     */
    public static&amp;lt;T, A, R&amp;gt; Collector&amp;lt;T, A, R&amp;gt; of(Supplier&amp;lt;A&amp;gt; supplier,
                                                 BiConsumer&amp;lt;A, T&amp;gt; accumulator,
                                                 BinaryOperator&amp;lt;A&amp;gt; combiner,
                                                 Function&amp;lt;A, R&amp;gt; finisher,
                                                 Characteristics... characteristics) {
        Objects.requireNonNull(supplier);
        Objects.requireNonNull(accumulator);
        Objects.requireNonNull(combiner);
        Objects.requireNonNull(finisher);
        Objects.requireNonNull(characteristics);
        Set&amp;lt;Characteristics&amp;gt; cs = Collectors.CH_NOID;
        if (characteristics.length &amp;gt; 0) {
            cs = EnumSet.noneOf(Characteristics.class);
            Collections.addAll(cs, characteristics);
            cs = Collections.unmodifiableSet(cs);
        }
        return new Collectors.CollectorImpl&amp;lt;&amp;gt;(supplier, accumulator, combiner, finisher, cs);
    }

    /**
     * Characteristics indicating properties of a {@code Collector}, which can
     * be used to optimize reduction implementations.
     */
    enum Characteristics {  // 特征 
        /**
         * Indicates that this collector is &amp;lt;em&amp;gt;concurrent&amp;lt;/em&amp;gt;, meaning that
         * the result container can support the accumulator function being
         * called concurrently with the same result container from multiple
         * threads.
         * 并发的，同一个结果容器可以由多个线程同时调用。
         * &amp;lt;p&amp;gt;If a {@code CONCURRENT} collector is not also {@code UNORDERED},
         * then it should only be evaluated concurrently if applied to an
         * unordered data source.
如果不是UNORDERED。只能用于无序的数据源。 
如果不加CONCURRENT，还是可以操作并行流。但是操作的不是一个结果容器，而是多个结果容器。则需要调用finisher.
如果加了CONCURRENT，则是多个线程操作同一结果容器。 则无需调用finisher.
         */  
        CONCURRENT,   

        /**
         * Indicates that the collection operation does not commit to preserving
         * the encounter order of input elements.  (This might be true if the
         * result container has no intrinsic order, such as a {@link Set}.)
         收集操作并不保留顺序。
         */
        UNORDERED,

        /**
         * Indicates that the finisher function is the identity function and
         * can be elided.  If set, it must be the case that an unchecked cast
         * from A to R will succeed.
        如果用和这个参数，表示 Finish函数就是 identity函数。 并且转换一定要是成功的。
         */
        IDENTITY_FINISH
    }
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;收集器用法详解与多级分组和分区&quot;&gt;收集器用法详解与多级分组和分区&lt;/h3&gt;
&lt;h4 id=&quot;为什么在collectors类中定义一个静态内部类&quot;&gt;为什么在collectors类中定义一个静态内部类？&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;static class CollectorImpl&amp;lt;T, A, R&amp;gt; implements Collector&amp;lt;T, A, R&amp;gt; &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;设计上，本身就是一个辅助类，是一个工厂。作用是给开发者提供常见的收集器实现。提供的方法都是静态方法，可以直接调用。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;函数式编程最大的特点：表示做什么，而不是如何做。开发者更注重如做什么，底层实现如何做。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * Implementations of {@link Collector} that implement various useful reduction
 * operations, such as accumulating elements into collections, summarizing
 * elements according to various criteria, etc.
 
   没有实现的方法，可以自己去编写收集器。
   
 * &amp;lt;p&amp;gt;The following are examples of using the predefined collectors to perform
 * common mutable reduction tasks:
 * 举例： 
 * &amp;lt;pre&amp;gt;{@code
 *     // Accumulate names into a List   名字加入到一个集合。
 *     List&amp;lt;String&amp;gt; list = people.stream().map(Person::getName).collect(Collectors.toList());
 *      
 *     // Accumulate names into a TreeSet  名字加入到一个Set。 待排序的集合。
 *     Set&amp;lt;String&amp;gt; set = people.stream().map(Person::getName).collect(Collectors.toCollection(TreeSet::new));
 *
 *     // Convert elements to strings and concatenate them, separated by commas
 *     String joined = things.stream()
 *                           .map(Object::toString)
 *                           .collect(Collectors.joining(&quot;, &quot;));
 *
 *     // Compute sum of salaries of employee      计算员工工资的总数。
 *     int total = employees.stream()
 *                          .collect(Collectors.summingInt(Employee::getSalary)));
 *
 *     // Group employees by department    对员工进行分组。
 *     Map&amp;lt;Department, List&amp;lt;Employee&amp;gt;&amp;gt; byDept
 *         = employees.stream()
 *                    .collect(Collectors.groupingBy(Employee::getDepartment));
 *
 *     // Compute sum of salaries by department    根据部门计算工资的总数。
 *     Map&amp;lt;Department, Integer&amp;gt; totalByDept
 *         = employees.stream()
 *                    .collect(Collectors.groupingBy(Employee::getDepartment,
 *                                                   Collectors.summingInt(Employee::getSalary)));
 *
 *     // Partition students into passing and failing    将学生进行分区。
 *     Map&amp;lt;Boolean, List&amp;lt;Student&amp;gt;&amp;gt; passingFailing =
 *         students.stream()
 *                 .collect(Collectors.partitioningBy(s -&amp;gt; s.getGrade() &amp;gt;= PASS_THRESHOLD));
 *
 * }&amp;lt;/pre&amp;gt;
 *
 * @since 1.8    提供了常见的方法。没有的话可以去自定义。
 */
public final class Collectors {&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;举例collector中的方法应用&quot;&gt;举例。collector中的方法应用：&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; public static void main(String[] args) {
        Student student1 = new Student(&quot;zhangsan&quot;, 80);
        Student student2 = new Student(&quot;lisi&quot;, 90);
        Student student3 = new Student(&quot;wangwu&quot;, 100);
        Student student4 = new Student(&quot;zhaoliu&quot;, 90);
        Student student5 = new Student(&quot;zhaoliu&quot;, 90);

        List&amp;lt;Student&amp;gt; students = Arrays.asList(student1, student2, student3, student4, student5);

        //list 转换成一个流,再转换成一个集合.
        List&amp;lt;Student&amp;gt; students1 = students.stream().collect(Collectors.toList());
        students1.forEach(System.out::println);
        System.out.println(&quot;- - - - - - -&quot;);

        // collect 方法底层原理介绍.

        //有多种方法可以实现同一个功能.什么方式更好呢? 越具体的方法越好.   减少自动装箱拆箱操作.
        System.out.println(&quot;count:&quot; + students.stream().collect(Collectors.counting()));
        System.out.println(&quot;count:&quot; + (Long) students.stream().count());
        System.out.println(&quot;- - - -  - - - -&quot;);

        //举例练习
        //  找出集合中分数最低的学生,打印出来.
        students.stream().collect(minBy(Comparator.comparingInt(Student::getScore))).ifPresent(System.out::println);
        //  找出集合中分数最大成绩
        students.stream().collect(maxBy(Comparator.comparingInt(Student::getScore))).ifPresent(System.out::println);
        //  求平均值
        System.out.println(students.stream().collect(averagingInt(Student::getScore)));
        //  求分数的综合
        System.out.println(students.stream().collect(summingInt(Student::getScore)));
        //  求各种汇总信息  结果为IntSummaryStatistics{count=5, sum=450, min=80, average=90.000000, max=100}
        System.out.println(students.stream().collect(summarizingInt(Student::getScore)));

        System.out.println(&quot; - - - - - &quot;);
        // 字符串的拼接   结果为:zhangsanlisiwangwuzhaoliuzhaoliu
        System.out.println(students.stream().map(Student::getName).collect(joining()));
        //拼接加分隔符    结果为:zhangsan,lisi,wangwu,zhaoliu,zhaoliu
        System.out.println(students.stream().map(Student::getName).collect(joining(&quot;,&quot;)));
        // 拼接加前后缀   结果为:hello  zhangsan,lisi,wangwu,zhaoliu,zhaoliu  world
        System.out.println(students.stream().map(Student::getName).collect(joining(&quot;,&quot;, &quot;hello  &quot;, &quot;  world&quot;)));

        System.out.println(&quot;- - - - - - &quot;);
        // group by 多层分组
        // 根据分数和名字进行分组  输出结果为:
        // {80={zhangsan=[Student{name='zhangsan', score=80}]},
        // 100={wangwu=[Student{name='wangwu', score=100}]},
        // 90={lisi=[Student{name='lisi', score=90}], zhaoliu=[Student{name='zhaoliu', score=90}, Student{name='zhaoliu', score=90}]}}
        Map&amp;lt;Integer, Map&amp;lt;String, List&amp;lt;Student&amp;gt;&amp;gt;&amp;gt; collect = students.stream().collect(groupingBy(Student::getScore, groupingBy(Student::getName)));
        System.out.println(collect);

        System.out.println(&quot;- - - - - - - &quot;);
        // partitioningBy   多级分区   输出结果为:{false=[Student{name='zhangsan', score=80}], true=[Student{name='lisi', score=90}, Student{name='wangwu', score=100}, Student{name='zhaoliu', score=90}, Student{name='zhaoliu', score=90}]}
        Map&amp;lt;Boolean, List&amp;lt;Student&amp;gt;&amp;gt; collect1 = students.stream().collect(partitioningBy(student -&amp;gt; student.getScore() &amp;gt; 80));
        System.out.println(collect1);
        // 按照大于80分区,再按照90分区
        //输出结果为:{false={false=[Student{name='zhangsan', score=80}], true=[]}, true={false=[Student{name='lisi', score=90}, Student{name='zhaoliu', score=90}, Student{name='zhaoliu', score=90}], true=[Student{name='wangwu', score=100}]}}
        Map&amp;lt;Boolean, Map&amp;lt;Boolean, List&amp;lt;Student&amp;gt;&amp;gt;&amp;gt; collect2 = students.stream().collect(partitioningBy(student -&amp;gt; student.getScore() &amp;gt; 80, partitioningBy(student -&amp;gt; student.getScore() &amp;gt; 90)));
        System.out.println(collect2);

        //分区, 然后求出每个分组中的个数.    结果为:{false=1, true=4}
        Map&amp;lt;Boolean, Long&amp;gt; collect3 = students.stream().collect(partitioningBy(student -&amp;gt; student.getScore() &amp;gt; 80, counting()));
        System.out.println(collect3);

        System.out.println(&quot;- - - - - - - &quot;);
        //根据名字分组,得到学生的分数     --, 使用collectingAndThen 求最小值,然后整合起来. 最后Optional.get()一定有值.
        students.stream().collect(groupingBy(Student::getName,collectingAndThen(minBy(Comparator.comparingInt(Student::getScore)), Optional::get)));
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;comparator比较器详解与类型推断特例&quot;&gt;Comparator比较器详解与类型推断特例&lt;/h3&gt;
&lt;p&gt;Comparator 比较器。引用了多个default方法。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;完成一个功能时有多个方法，使用特化的方法。因为效率会更高。减少了装箱拆箱的操作。减少性能损耗。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;举例-简单功能实现&quot;&gt;举例： 简单功能实现&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void main(String[] args) {
        List&amp;lt;String&amp;gt; list = Arrays.asList(&quot;nihao&quot;, &quot;hello&quot;, &quot;world&quot;, &quot;welcome&quot;);

        //对list按照字母的升序排序
//        list.stream().sorted().forEach(System.out::println);

        //按照字符串的长度排序
//        Collections.sort(list, (item1, item2) -&amp;gt; item1.length() - item2.length());
//        Collections.sort(list, Comparator.comparingInt(String::length));

        //字符串的降序排序
//        list.sort(Comparator.comparingInt(String::length).reversed());

        // 下边的形式会报错   item识别成了(Obejct).
        //lambda表达式的类型推断. 如果无法推断类型,需要自己制定类型
//        list.sort(Comparator.comparingInt(item-&amp;gt; item.length()).reversed());
        //这样写就成功了.
        list.sort(Comparator.comparingInt((String item )-&amp;gt; item.length()).reversed());

        //为什么这个地方无法推断类型?
        // 能推断出的 :   list.stream()....    Strean&amp;lt;T&amp;gt;  传递的有参数.   精确的类型可以进行类型推断.
        //这个地方没有明确具体是什么类型.ToIntFunction&amp;lt;? super T&amp;gt;   .可以是String 或者在往上的父类    这个地方看成了Object类了.

//        list.sort(Comparator.comparingInt((Boolean item)-&amp;gt; 1).reversed());
        //这种Boolean 就会报错.编译不通过.

        System.out.println(list);

    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;比较器深入举例练习&quot;&gt;比较器深入举例练习&lt;/h4&gt;
&lt;h4 id=&quot;举例两层的比较.先按照字符串的长度升序排序.-长度相同根据每一个ascii码的顺序排序&quot;&gt;举例：两层的比较.先按照字符串的长度升序排序. 长度相同,根据每一个ASCII码的顺序排序、&lt;/h4&gt;
&lt;p&gt;thenComparing（）多级排序的练习。;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;List&amp;lt;String&amp;gt; list = Arrays.asList(&quot;nihao&quot;, &quot;hello&quot;, &quot;world&quot;, &quot;welcome&quot;);


//两层的比较.先按照字符串的长度升序排序. 长度相同,根据每一个ASCII码的升序排序.     (不区分大小写的 ,按照字母排序的规则)  几种实现的方法。
    list.sort(Comparator.comparingInt(String::length).thenComparing(String.CASE_INSENSITIVE_ORDER));

list.sort(Comparator.comparingInt(String::length).thenComparing((item1,item2) -&amp;gt; item1.toUpperCase().compareTo(item2.toUpperCase())));
       list.sort(Comparator.comparingInt(String::length).thenComparing(Comparator.comparing(String::toUpperCase)));

//排序后将顺序翻转过来. reverseOrder();
list.sort(Comparator.comparingInt(String::length).thenComparing(String::toLowerCase,Comparator.reverseOrder()));

// 按照字符串的长度降序排序, 再根据ASCII的降序排序
list.sort(Comparator.comparingInt(String::length).reversed()
                .thenComparing(String::toLowerCase,Comparator.reverseOrder()));

//多级排序
list.sort(Comparator.comparingInt(String::length).reversed()
                .thenComparing(String::toLowerCase, Comparator.reverseOrder())
                .thenComparing(Comparator.reverseOrder())); 
 // 最后一个thenComparing（）没有发生作用。&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;自定义一个简单的收集器&quot;&gt;自定义一个简单的收集器&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;jdk提供了Collector接口。&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class MySetCollector&amp;lt;T&amp;gt;  implements Collector&amp;lt;T,Set&amp;lt;T&amp;gt;,Set&amp;lt;T&amp;gt;&amp;gt; {

    @Override
    public Supplier&amp;lt;Set&amp;lt;T&amp;gt;&amp;gt; supplier() {
        //用于提供一个空的容器
        System.out.println(&quot;supplier invoked! &quot;);
        return HashSet::new;  // 不接受对象,返回一个Set对象
    }

    @Override
    public BiConsumer&amp;lt;Set&amp;lt;T&amp;gt;, T&amp;gt; accumulator() {
        // 累加器类型.   接收两个参数不返回值.
        //完成的功能: 不断的往set中添加元素
        System.out.println(&quot;accumulator invoked! &quot;);
        return Set&amp;lt;T&amp;gt;::add ;
//        return HashSet&amp;lt;T&amp;gt;::add ;   返回HashSet报错.  原因: 返回的是中间类型的返回类型.  不论返回什么类型的Set ,Set都符合要求.
    }

    @Override
    public BinaryOperator&amp;lt;Set&amp;lt;T&amp;gt;&amp;gt; combiner() {
        //将并行流的多个结果给合并起来.
        System.out.println(&quot;combiner invoked! &quot;);
        return (set1,set2)-&amp;gt;{
            set1.addAll(set2);
            return  set1;
        };
    }

    @Override
    public Function&amp;lt;Set&amp;lt;T&amp;gt;, Set&amp;lt;T&amp;gt;&amp;gt; finisher() {
        //完成器,把所有的结果都合并在一起. 返回一个最终的结果类型
        //如果中间类型 和最终结果类型一致, 不执行此方法;
        System.out.println(&quot;finisher invoked! &quot;);
//        return  t -&amp;gt; t ;
        return Function.identity(); // 总是返回参数.
    }

    @Override
    public Set&amp;lt;Characteristics&amp;gt; characteristics() {
        System.out.println(&quot;characterstics invoked! &quot;);
        return Collections.unmodifiableSet(EnumSet.of(Characteristics.IDENTITY_FINISH,Characteristics.UNORDERED));  // 这个地方 不给参数，IDENTITY_FINISH  . 则会调用finisher()
    }

    public static void main(String[] args) {
        List&amp;lt;String&amp;gt; list = Arrays.asList(&quot;hello&quot;, &quot;world&quot;);
        Set&amp;lt;String&amp;gt; collect = list.stream().collect(new MySetCollector&amp;lt;&amp;gt;());
        System.out.println(collect);
    }
  
  输出结果为： 
supplier invoked! 
accumulator invoked! 
combiner invoked! 
characterstics invoked! 
characterstics invoked! 
[world, hello]

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来跟源码，看一下程序的调用过程。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Override
@SuppressWarnings(&quot;unchecked&quot;)
public final &amp;lt;R, A&amp;gt; R collect(Collector&amp;lt;? super P_OUT, A, R&amp;gt; collector) {
    A container;
    if (isParallel()
            &amp;amp;&amp;amp; (collector.characteristics().contains(Collector.Characteristics.CONCURRENT))
            &amp;amp;&amp;amp; (!isOrdered() || collector.characteristics().contains(Collector.Characteristics.UNORDERED))) {
        container = collector.supplier().get();
        BiConsumer&amp;lt;A, ? super P_OUT&amp;gt; accumulator = collector.accumulator();
        forEach(u -&amp;gt; accumulator.accept(container, u));
    }
    else {
        container = evaluate(ReduceOps.makeRef(collector));
    }
    return collector.characteristics().contains(Collector.Characteristics.IDENTITY_FINISH)
           ? (R) container
           : collector.finisher().apply(container);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h3 id=&quot;自定义收集器的深度剖析与并行缺陷&quot;&gt;自定义收集器的深度剖析与并行缺陷&lt;/h3&gt;
&lt;blockquote readability=&quot;17&quot;&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 举例： 需求：将一个Set,进行一个收集.对结果进行增强,封装在一个map当中.

// 输入:Set&amp;lt;String&amp;gt;
// 输出:Map&amp;lt;String,String&amp;gt;

// 示例输入:   [hello,world,hello world]
// 示例输出:  {[hello,hello],[world,world],[hello world,hello world]}&lt;/code&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class MySetCollector2&amp;lt;T&amp;gt; implements Collector&amp;lt;T, Set&amp;lt;T&amp;gt;, Map&amp;lt;T, T&amp;gt;&amp;gt; {
    @Override
    public Supplier&amp;lt;Set&amp;lt;T&amp;gt;&amp;gt; supplier() {
        System.out.println(&quot;supplier invoked!&quot;);
        return HashSet::new;
    }

    @Override
    public BiConsumer&amp;lt;Set&amp;lt;T&amp;gt;, T&amp;gt; accumulator() {
        System.out.println(&quot;accumlator invoked!&quot;);
        return (set, item) -&amp;gt; {
            set.add(item);
            //每次调用 打印出线程   这里会打印6次,
            System.out.println(&quot;accunlator : &quot; +set+ &quot;, &quot;+  Thread.currentThread().getName());
          
          //出现异常的原因在这里： 
// 一个线程去修改一个集合，同时另外一个线程去迭代它（遍历它）。程序就会抛出并发修改异常。如果是并行操作的话，就不要在操作中额外的添加操作。添加就添加，别再去打印他。 
        };
    }

    @Override
    public BinaryOperator&amp;lt;Set&amp;lt;T&amp;gt;&amp;gt; combiner() {
        System.out.println(&quot;combiner invoked!&quot;);
        //并行流的时候才会被调用. 将并行流的多个结果给合并起来
        return (set1, set2) -&amp;gt; {
            set1.addAll(set2);
            return set2;
        };
    }

    @Override
    public Function&amp;lt;Set&amp;lt;T&amp;gt;, Map&amp;lt;T, T&amp;gt;&amp;gt; finisher() {
        System.out.println(&quot;finisher invoked!&quot;);
        // 中间类型和最终类型 一样,这个是不会被调用的.
        //这里不一样 . 会进行调用

        return set -&amp;gt; {
            Map&amp;lt;T, T&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
//            Map&amp;lt;T, T&amp;gt; map = new TreeMap&amp;lt;&amp;gt;();  直接返回一个排序的Map
            set.forEach(item -&amp;gt; map.put(item,item));
            return map;
        };
    }

    @Override
    public Set&amp;lt;Characteristics&amp;gt; characteristics() {
        System.out.println(&quot; characteristics invoked&quot;);

        return Collections.unmodifiableSet(EnumSet.of(Characteristics.UNORDERED));// 这个参数不能乱写. 要理解每个枚举的具体意思.

//        return Collections.unmodifiableSet(EnumSet.of(Characteristics.UNORDERED,Characteristics.CONCURRENT));// 这个参数不能乱写. 要理解每个枚举的具体意思.
        //加了这个参数 Characteristics.CONCURRENT
        //  会出异常, 会正常运行.  Caused by: java.util.ConcurrentModificationException

//        return Collections.unmodifiableSet(EnumSet.of(Characteristics.UNORDERED,Characteristics.IDENTITY_FINISH));
        // 加了参数Characteristics.IDENTITY_FINISH .  会报错
        // Process 'command '/Library/Java/JavaVirtualMachines/adoptopenjdk-8.jdk/Contents/Home/bin/java'' finished with non-zero exit value 1

        // IDENTITY_FINISH 实际的含义: 如果用和这个参数，表示 Finish函数就是 identity函数。 并且转换一定要是成功的。失败的话会抛异常.
        // 这个收集器具有什么特性 ,由Characteristics 来定义. 就算你赋值的不实际,他也照样执行.
    }

    public static void main(String[] args) {
        List&amp;lt;String&amp;gt; list = Arrays.asList(&quot;hello&quot;,&quot;hello&quot;, &quot;world&quot;, &quot;helloworld&quot;,&quot;1&quot;,&quot;4&quot;,&quot;j&quot;);
        Set&amp;lt;String&amp;gt; set = new HashSet&amp;lt;&amp;gt;(list);

        System.out.println(&quot;set&quot;+set);

//        Map&amp;lt;String, String&amp;gt; collect = set.stream().collect(new MySetCollector2&amp;lt;&amp;gt;());
        Map&amp;lt;String, String&amp;gt; collect = set.parallelStream().collect(new MySetCollector2&amp;lt;&amp;gt;());  //并行流
        System.out.println(collect);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;并行流缺陷详解&quot;&gt;并行流缺陷详解&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;并行： 
accumlator invoked!
accunlator : [j], main
accunlator : [j, hello], main
accunlator : [helloworld, 4, j, hello], ForkJoinPool.commonPool-worker-2
accunlator : [helloworld, 1, 4, j, hello], ForkJoinPool.commonPool-worker-2
accunlator : [helloworld, 1, world, 4, j, hello], ForkJoinPool.commonPool-worker-2&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;串行。
accunlator : [j], main
accunlator : [helloworld], ForkJoinPool.commonPool-worker-11
accunlator : [helloworld, 1], ForkJoinPool.commonPool-worker-11
accunlator : [helloworld, 1, world], ForkJoinPool.commonPool-worker-11
accunlator : [4], ForkJoinPool.commonPool-worker-9
accunlator : [j, hello], main&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
     * Characteristics indicating properties of a {@code Collector}, which can
     * be used to optimize reduction implementations.
     */
    enum Characteristics {  // 特征 
        /**
         * Indicates that this collector is &amp;lt;em&amp;gt;concurrent&amp;lt;/em&amp;gt;, meaning that
         * the result container can support the accumulator function being
         * called concurrently with the same result container from multiple
         * threads.
         * 并发的，同一个结果容器可以由多个线程同时调用。
         * &amp;lt;p&amp;gt;If a {@code CONCURRENT} collector is not also {@code UNORDERED},
         * then it should only be evaluated concurrently if applied to an
         * unordered data source.
如果不是UNORDERED。只能用于无序的数据源。 
如果不加CONCURRENT，还是可以操作并行流。但是操作的不是一个结果容器，而是多个结果容器。则需要调用finisher.
如果加了CONCURRENT，则是多个线程操作同一结果容器。 则无需调用finisher.
         */  
        CONCURRENT,   

        /**
         * Indicates that the collection operation does not commit to preserving
         * the encounter order of input elements.  (This might be true if the
         * result container has no intrinsic order, such as a {@link Set}.)
         收集操作并不保留顺序。无序的。
         */
        UNORDERED,

        /**
         * Indicates that the finisher function is the identity function and
         * can be elided.  If set, it must be the case that an unchecked cast
         * from A to R will succeed.
        如果用和这个参数，表示 Finish函数就是 identity函数。 并且转换一定要是成功的。不会调用Finish方法
         */
        IDENTITY_FINISH
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;出异常的根本原因&quot;&gt;出异常的根本原因：&lt;/h4&gt;
&lt;p&gt;一个线程去修改一个集合，同时另外一个线程去迭代它（遍历它）。程序就会抛出并发修改异常。&lt;/p&gt;
&lt;p&gt;如果是并行操作的话，就不要在操作中额外的添加操作。添加就添加，别再去打印他。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;如果不加CONCURRENT，还是可以操作并行流。但是操作的不是一个结果容器，而是多个结果容器。则需要调用finisher.&lt;br/&gt;如果加了CONCURRENT，则是多个线程操作同一结果容器。 则无需调用finisher.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;超线程介绍&quot;&gt;超线程介绍：&lt;/h4&gt;
&lt;blockquote readability=&quot;11.958397534669&quot;&gt;
&lt;p&gt;超线程（HT, Hyper-Threading）是&lt;a href=&quot;https://baike.baidu.com/item/%E8%8B%B1%E7%89%B9%E5%B0%94&quot;&gt;英特尔&lt;/a&gt;研发的一种技术，于2002年发布。超线程技术原先只应用于&lt;a href=&quot;https://baike.baidu.com/item/Xeon&quot;&gt;Xeon&lt;/a&gt; &lt;a href=&quot;https://baike.baidu.com/item/%E5%A4%84%E7%90%86%E5%99%A8&quot;&gt;处理器&lt;/a&gt;中，当时称为“Super-Threading”。之后陆续应用在Pentium 4 HT中。早期代号为Jackson。 [1]&lt;/p&gt;
&lt;p&gt;通过此技术，英特尔实现在一个&lt;a href=&quot;https://baike.baidu.com/item/%E5%AE%9E%E4%BD%93&quot;&gt;实体&lt;/a&gt;&lt;a href=&quot;https://baike.baidu.com/item/CPU&quot;&gt;CPU&lt;/a&gt;中，提供两个&lt;a href=&quot;https://baike.baidu.com/item/%E9%80%BB%E8%BE%91&quot;&gt;逻辑&lt;/a&gt;&lt;a href=&quot;https://baike.baidu.com/item/%E7%BA%BF%E7%A8%8B&quot;&gt;线程&lt;/a&gt;。之后的&lt;a href=&quot;https://baike.baidu.com/item/Pentium%20D&quot;&gt;Pentium D&lt;/a&gt;纵使不支持超线程技术，但就集成了两个实体核心，所以仍会见到两个线程。超线程的未来发展，是提升处理器的逻辑线程。英特尔于2016年发布的Core i7-6950X便是将10核心的处理器，加上超线程技术，使之成为20个逻辑线程的产品&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;收集器总结&quot;&gt;收集器总结：&lt;/h3&gt;
&lt;p&gt;Collectors类中方法的实现练习。收集器总是有中间的容器。有必要的总结一下收集器中的方法。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;当你具备一些前提的东西之后，你再去看难的东西就会觉得理所当然的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;对于Collectors静态工厂类来说，实现一共分为两种情况：&lt;/strong&gt;&lt;/p&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;通过CollectorImpl来实现。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;通过reducing方法来实现；reducing方法本身又是通过CollectorImpl实现的。&lt;/p&gt;
&lt;p&gt;总的来说，都是通过CollectorImpl来实现的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;1. toCollection（collectionFactory） 。  将集合转成指定的集合。
public static &amp;lt;T, C extends Collection&amp;lt;T&amp;gt;&amp;gt;
Collector&amp;lt;T, ?, C&amp;gt; toCollection(Supplier&amp;lt;C&amp;gt; collectionFactory) {
    return new CollectorImpl&amp;lt;&amp;gt;(collectionFactory, Collection&amp;lt;T&amp;gt;::add,
                               (r1, r2) -&amp;gt; { r1.addAll(r2); return r1; },
                               CH_ID);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;2. toList()是 toCollection（）方法的一种具体实现。
public static &amp;lt;T&amp;gt;
Collector&amp;lt;T, ?, List&amp;lt;T&amp;gt;&amp;gt; toList() {
    return new CollectorImpl&amp;lt;&amp;gt;((Supplier&amp;lt;List&amp;lt;T&amp;gt;&amp;gt;) ArrayList::new, List::add,
                               (left, right) -&amp;gt; { left.addAll(right); return left; },
                               CH_ID);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;3. toSet() 是toCollection（）方法的一种具体实现。
public static &amp;lt;T&amp;gt;
Collector&amp;lt;T, ?, Set&amp;lt;T&amp;gt;&amp;gt; toSet() {
    return new CollectorImpl&amp;lt;&amp;gt;((Supplier&amp;lt;Set&amp;lt;T&amp;gt;&amp;gt;) HashSet::new, Set::add,
                               (left, right) -&amp;gt; { left.addAll(right); return left; },
                               CH_UNORDERED_ID);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;4. joining（）； 融合成一个字符串。还有两个重载的，单参数的和多参数的
public static Collector&amp;lt;CharSequence, ?, String&amp;gt; joining() {
    return new CollectorImpl&amp;lt;CharSequence, StringBuilder, String&amp;gt;(
            StringBuilder::new, StringBuilder::append,
            (r1, r2) -&amp;gt; { r1.append(r2); return r1; },
            StringBuilder::toString, CH_NOID);
}

public static Collector&amp;lt;CharSequence, ?, String&amp;gt; joining(CharSequence delimiter) {
        return joining(delimiter, &quot;&quot;, &quot;&quot;);
    }

public static Collector&amp;lt;CharSequence, ?, String&amp;gt; joining(CharSequence delimiter,
                                                             CharSequence prefix,
                                                             CharSequence suffix) {
        return new CollectorImpl&amp;lt;&amp;gt;(
                () -&amp;gt; new StringJoiner(delimiter, prefix, suffix),
                StringJoiner::add, StringJoiner::merge,
                StringJoiner::toString, CH_NOID);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;5.mapping（）； 将收集器的A 映射成B 
public static &amp;lt;T, U, A, R&amp;gt;
Collector&amp;lt;T, ?, R&amp;gt; mapping(Function&amp;lt;? super T, ? extends U&amp;gt; mapper,
                           Collector&amp;lt;? super U, A, R&amp;gt; downstream) {
    BiConsumer&amp;lt;A, ? super U&amp;gt; downstreamAccumulator = downstream.accumulator();
    return new CollectorImpl&amp;lt;&amp;gt;(downstream.supplier(),
                               (r, t) -&amp;gt; downstreamAccumulator.accept(r, mapper.apply(t)),
                               downstream.combiner(), downstream.finisher(),
                               downstream.characteristics());
}

such as :
Map&amp;lt;City, Set&amp;lt;String&amp;gt;&amp;gt; lastNamesByCity
  = people.stream().collect(groupingBy(Person::getCity, mapping(Person::getLastName, toSet())));&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;6.collectingAndThen（）； 收集处理转换完后， 再去进行一个转换。
public static&amp;lt;T,A,R,RR&amp;gt; Collector&amp;lt;T,A,RR&amp;gt; collectingAndThen(Collector&amp;lt;T,A,R&amp;gt; downstream,
                                                            Function&amp;lt;R,RR&amp;gt; finisher) {
    Set&amp;lt;Collector.Characteristics&amp;gt; characteristics = downstream.characteristics();
    if (characteristics.contains(Collector.Characteristics.IDENTITY_FINISH)) {
        if (characteristics.size() == 1)
            characteristics = Collectors.CH_NOID;
        else {
            characteristics = EnumSet.copyOf(characteristics);
            characteristics.remove(Collector.Characteristics.IDENTITY_FINISH);
           // 这个地方为什么要把IDENTITY_FINISH 去掉。
          // 如果不去掉的话， 最终结果直接返回中间结果的类型
            characteristics = Collections.unmodifiableSet(characteristics);
        }
    }
    return new CollectorImpl&amp;lt;&amp;gt;(downstream.supplier(),
                               downstream.accumulator(),
                               downstream.combiner(),
                               downstream.finisher().andThen(finisher),
                               characteristics);
}

such as : 
 List&amp;lt;String&amp;gt; people
       = people.stream().collect(collectingAndThen(toList(),Collections::unmodifiableList));&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;7. counting（）； 计数。
public static &amp;lt;T&amp;gt; Collector&amp;lt;T, ?, Long&amp;gt;
counting() {
    return reducing(0L, e -&amp;gt; 1L, Long::sum);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;8. 最大值最小值  
    public static &amp;lt;T&amp;gt; Collector&amp;lt;T, ?, Optional&amp;lt;T&amp;gt;&amp;gt;
    minBy(Comparator&amp;lt;? super T&amp;gt; comparator) {
        return reducing(BinaryOperator.minBy(comparator));
    }
 public static &amp;lt;T&amp;gt; Collector&amp;lt;T, ?, Optional&amp;lt;T&amp;gt;&amp;gt;
    maxBy(Comparator&amp;lt;? super T&amp;gt; comparator) {
        return reducing(BinaryOperator.maxBy(comparator));
    }

&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;9. summingInt（）；求和。
public static &amp;lt;T&amp;gt; Collector&amp;lt;T, ?, Integer&amp;gt;
summingInt(ToIntFunction&amp;lt;? super T&amp;gt; mapper) {
    return new CollectorImpl&amp;lt;&amp;gt;(
            () -&amp;gt; new int[1],   // 这个地方为什么不可以用一个0，来当做中间类型呢？数字本身是一个值类型的，不可变的，没法引用。数组本身是一个引用类型，可以进行传递。数组本身是一个容器。                                      
            (a, t) -&amp;gt; { a[0] += mapper.applyAsInt(t); },
            (a, b) -&amp;gt; { a[0] += b[0]; return a; },
            a -&amp;gt; a[0], CH_NOID);
}

public static &amp;lt;T&amp;gt; Collector&amp;lt;T, ?, Long&amp;gt;
    summingLong(ToLongFunction&amp;lt;? super T&amp;gt; mapper) {
        return new CollectorImpl&amp;lt;&amp;gt;(
                () -&amp;gt; new long[1],
                (a, t) -&amp;gt; { a[0] += mapper.applyAsLong(t); },
                (a, b) -&amp;gt; { a[0] += b[0]; return a; },
                a -&amp;gt; a[0], CH_NOID);
    }

public static &amp;lt;T&amp;gt; Collector&amp;lt;T, ?, Double&amp;gt;
    summingDouble(ToDoubleFunction&amp;lt;? super T&amp;gt; mapper) {
        /*
         * In the arrays allocated for the collect operation, index 0
         * holds the high-order bits of the running sum, index 1 holds
         * the low-order bits of the sum computed via compensated
         * summation, and index 2 holds the simple sum used to compute
         * the proper result if the stream contains infinite values of
         * the same sign.
         */
        return new CollectorImpl&amp;lt;&amp;gt;(
                () -&amp;gt; new double[3],  
                (a, t) -&amp;gt; { sumWithCompensation(a, mapper.applyAsDouble(t));
                            a[2] += mapper.applyAsDouble(t);},
                (a, b) -&amp;gt; { sumWithCompensation(a, b[0]);
                            a[2] += b[2];
                            return sumWithCompensation(a, b[1]); },
                a -&amp;gt; computeFinalSum(a),
                CH_NOID);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;10. averagingInt（）； 求平均值。
public static &amp;lt;T&amp;gt; Collector&amp;lt;T, ?, Double&amp;gt;
averagingInt(ToIntFunction&amp;lt;? super T&amp;gt; mapper) {
    return new CollectorImpl&amp;lt;&amp;gt;(
            () -&amp;gt; new long[2],
            (a, t) -&amp;gt; { a[0] += mapper.applyAsInt(t); a[1]++; },
            (a, b) -&amp;gt; { a[0] += b[0]; a[1] += b[1]; return a; },
            a -&amp;gt; (a[1] == 0) ? 0.0d : (double) a[0] / a[1], CH_NOID);
}

public static &amp;lt;T&amp;gt; Collector&amp;lt;T, ?, Double&amp;gt;
    averagingLong(ToLongFunction&amp;lt;? super T&amp;gt; mapper) {
        return new CollectorImpl&amp;lt;&amp;gt;(
                () -&amp;gt; new long[2],
                (a, t) -&amp;gt; { a[0] += mapper.applyAsLong(t); a[1]++; },
                (a, b) -&amp;gt; { a[0] += b[0]; a[1] += b[1]; return a; },
                a -&amp;gt; (a[1] == 0) ? 0.0d : (double) a[0] / a[1], CH_NOID);
    }
public static &amp;lt;T&amp;gt; Collector&amp;lt;T, ?, Double&amp;gt;
    averagingDouble(ToDoubleFunction&amp;lt;? super T&amp;gt; mapper) {
        /*
         * In the arrays allocated for the collect operation, index 0
         * holds the high-order bits of the running sum, index 1 holds
         * the low-order bits of the sum computed via compensated
         * summation, and index 2 holds the number of values seen.
         */
        return new CollectorImpl&amp;lt;&amp;gt;(
                () -&amp;gt; new double[4],
                (a, t) -&amp;gt; { sumWithCompensation(a, mapper.applyAsDouble(t)); a[2]++; a[3]+= mapper.applyAsDouble(t);},
                (a, b) -&amp;gt; { sumWithCompensation(a, b[0]); sumWithCompensation(a, b[1]); a[2] += b[2]; a[3] += b[3]; return a; },
                a -&amp;gt; (a[2] == 0) ? 0.0d : (computeFinalSum(a) / a[2]),
                CH_NOID);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;11.  reducing() ; 详解。
public static &amp;lt;T&amp;gt; Collector&amp;lt;T, ?, T&amp;gt;
    reducing(T identity, BinaryOperator&amp;lt;T&amp;gt; op) {
        return new CollectorImpl&amp;lt;&amp;gt;(
                boxSupplier(identity),
                (a, t) -&amp;gt; { a[0] = op.apply(a[0], t); },
                (a, b) -&amp;gt; { a[0] = op.apply(a[0], b[0]); return a; },
                a -&amp;gt; a[0],
                CH_NOID);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;12. groupingBy（）; 分组方法详解。
public static &amp;lt;T, K&amp;gt; Collector&amp;lt;T, ?, Map&amp;lt;K, List&amp;lt;T&amp;gt;&amp;gt;&amp;gt;   //使用者本身不注重中间类型怎么操作。
groupingBy(Function&amp;lt;? super T, ? extends K&amp;gt; classifier) {  
    return groupingBy(classifier, toList());   //调用两个参数的 groupingBy（）；
}

 * @param &amp;lt;T&amp;gt; the type of the input elements   //T; 接收的类型。
     * @param &amp;lt;K&amp;gt; the type of the keys  //  K，分类器函数中间返回结果的类型。
     * @param &amp;lt;A&amp;gt; the intermediate accumulation type of the downstream collector
     * @param &amp;lt;D&amp;gt; the result type of the downstream reduction
 *
public static &amp;lt;T, K, A, D&amp;gt;  
    Collector&amp;lt;T, ?, Map&amp;lt;K, D&amp;gt;&amp;gt; groupingBy(Function&amp;lt;? super T, ? extends K&amp;gt; classifier,
                                          Collector&amp;lt;? super T, A, D&amp;gt; downstream) {
        return groupingBy(classifier, HashMap::new, downstream); // 调用三参数的 groupingBy（）
    }

//功能最完全的groupingBy();

    /**
     * Returns a {@code Collector} implementing a cascaded &quot;group by&quot; operation
     * on input elements of type {@code T}, grouping elements according to a
     * classification function, and then performing a reduction operation on
     * the values associated with a given key using the specified downstream
     * {@code Collector}.  The {@code Map} produced by the Collector is created
     * with the supplied factory function.
     *
     * &amp;lt;p&amp;gt;The classification function maps elements to some key type {@code K}.
     * The downstream collector operates on elements of type {@code T} and
     * produces a result of type {@code D}. The resulting collector produces a
     * {@code Map&amp;lt;K, D&amp;gt;}.
     *
     * &amp;lt;p&amp;gt;For example, to compute the set of last names of people in each city,
     * where the city names are sorted:
     * &amp;lt;pre&amp;gt;{@code
     *     Map&amp;lt;City, Set&amp;lt;String&amp;gt;&amp;gt; namesByCity
     *         = people.stream().collect(groupingBy(Person::getCity, TreeMap::new,
     *                                              mapping(Person::getLastName, toSet())));
     * }&amp;lt;/pre&amp;gt;
     *
     * @implNote
     * The returned {@code Collector} is not concurrent.  For parallel stream
     * pipelines, the {@code combiner} function operates by merging the keys
     * from one map into another, which can be an expensive operation.  If
     * preservation of the order in which elements are presented to the downstream
     * collector is not required, using {@link #groupingByConcurrent(Function, Supplier, Collector)}
     * may offer better parallel performance.
     *  返回的 并不是并发的。如果顺序并不是很重要的话， 推荐使用groupingByConcurrent（）； 并发的分组函数。
     * @param &amp;lt;T&amp;gt; the type of the input elements
     * @param &amp;lt;K&amp;gt; the type of the keys
     * @param &amp;lt;A&amp;gt; the intermediate accumulation type of the downstream collector
     * @param &amp;lt;D&amp;gt; the result type of the downstream reduction
     * @param &amp;lt;M&amp;gt; the type of the resulting {@code Map}
     * @param classifier a classifier function mapping input elements to keys
     * @param downstream a {@code Collector} implementing the downstream reduction
     * @param mapFactory a function which, when called, produces a new empty
     *                   {@code Map} of the desired type
     * @return a {@code Collector} implementing the cascaded group-by operation
     *
     * @see #groupingBy(Function, Collector)
     * @see #groupingBy(Function)
     * @see #groupingByConcurrent(Function, Supplier, Collector)
     */
public static &amp;lt;T, K, D, A, M extends Map&amp;lt;K, D&amp;gt;&amp;gt;  
    Collector&amp;lt;T, ?, M&amp;gt; groupingBy(Function&amp;lt;? super T, ? extends K&amp;gt; classifier,
                                  Supplier&amp;lt;M&amp;gt; mapFactory,
                                  Collector&amp;lt;? super T, A, D&amp;gt; downstream) {
        Supplier&amp;lt;A&amp;gt; downstreamSupplier = downstream.supplier();
        BiConsumer&amp;lt;A, ? super T&amp;gt; downstreamAccumulator = downstream.accumulator();
        BiConsumer&amp;lt;Map&amp;lt;K, A&amp;gt;, T&amp;gt; accumulator = (m, t) -&amp;gt; {
            K key = Objects.requireNonNull(classifier.apply(t), &quot;element cannot be mapped to a null key&quot;);
            A container = m.computeIfAbsent(key, k -&amp;gt; downstreamSupplier.get());
            downstreamAccumulator.accept(container, t); 
        };
        BinaryOperator&amp;lt;Map&amp;lt;K, A&amp;gt;&amp;gt; merger = Collectors.&amp;lt;K, A, Map&amp;lt;K, A&amp;gt;&amp;gt;mapMerger(downstream.combiner());  //接收两个参数，参会一个结果。
        @SuppressWarnings(&quot;unchecked&quot;)
        Supplier&amp;lt;Map&amp;lt;K, A&amp;gt;&amp;gt; mangledFactory = (Supplier&amp;lt;Map&amp;lt;K, A&amp;gt;&amp;gt;) mapFactory; // 进行一个强制的类型转换。

        if (downstream.characteristics().contains(Collector.Characteristics.IDENTITY_FINISH)) {       
         //如果 IDENTITY_FINISH ， 则不用调用finisher方法。
           return new CollectorImpl&amp;lt;&amp;gt;(mangledFactory, accumulator, merger, CH_ID);
        }
        else {
            @SuppressWarnings(&quot;unchecked&quot;)
            Function&amp;lt;A, A&amp;gt; downstreamFinisher = (Function&amp;lt;A, A&amp;gt;) downstream.finisher();
            Function&amp;lt;Map&amp;lt;K, A&amp;gt;, M&amp;gt; finisher = intermediate -&amp;gt; {
                intermediate.replaceAll((k, v) -&amp;gt; downstreamFinisher.apply(v));
                @SuppressWarnings(&quot;unchecked&quot;)
                M castResult = (M) intermediate;
                return castResult;
            };
            return new CollectorImpl&amp;lt;&amp;gt;(mangledFactory, accumulator, merger, finisher, CH_NOID);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;13. groupingByConcurrent（）； 并发的分组方法。 使用前提是对数据里边的顺序没有要求。
   /**
     * Returns a concurrent {@code Collector} implementing a cascaded &quot;group by&quot;
     * operation on input elements of type {@code T}, grouping elements
     * according to a classification function, and then performing a reduction
     * operation on the values associated with a given key using the specified
     * downstream {@code Collector}.
     */         //  ConcurrentHashMap    是一个支持并发的Map 
  public static &amp;lt;T, K&amp;gt;
    Collector&amp;lt;T, ?, ConcurrentMap&amp;lt;K, List&amp;lt;T&amp;gt;&amp;gt;&amp;gt;
    groupingByConcurrent(Function&amp;lt;? super T, ? extends K&amp;gt; classifier) {
        return groupingByConcurrent(classifier, ConcurrentHashMap::new, toList());
    }

 public static &amp;lt;T, K, A, D&amp;gt;
    Collector&amp;lt;T, ?, ConcurrentMap&amp;lt;K, D&amp;gt;&amp;gt; groupingByConcurrent(Function&amp;lt;? super T, ? extends K&amp;gt; classifier,
                                                              Collector&amp;lt;? super T, A, D&amp;gt; downstream) {
        return groupingByConcurrent(classifier, ConcurrentHashMap::new, downstream);
    }

 public static &amp;lt;T, K, A, D, M extends ConcurrentMap&amp;lt;K, D&amp;gt;&amp;gt;
    Collector&amp;lt;T, ?, M&amp;gt; groupingByConcurrent(Function&amp;lt;? super T, ? extends K&amp;gt; classifier,
                                            Supplier&amp;lt;M&amp;gt; mapFactory,
                                            Collector&amp;lt;? super T, A, D&amp;gt; downstream) {
        Supplier&amp;lt;A&amp;gt; downstreamSupplier = downstream.supplier();
        BiConsumer&amp;lt;A, ? super T&amp;gt; downstreamAccumulator = downstream.accumulator();
        BinaryOperator&amp;lt;ConcurrentMap&amp;lt;K, A&amp;gt;&amp;gt; merger = Collectors.&amp;lt;K, A, ConcurrentMap&amp;lt;K, A&amp;gt;&amp;gt;mapMerger(downstream.combiner());
        @SuppressWarnings(&quot;unchecked&quot;)
        Supplier&amp;lt;ConcurrentMap&amp;lt;K, A&amp;gt;&amp;gt; mangledFactory = (Supplier&amp;lt;ConcurrentMap&amp;lt;K, A&amp;gt;&amp;gt;) mapFactory;
        BiConsumer&amp;lt;ConcurrentMap&amp;lt;K, A&amp;gt;, T&amp;gt; accumulator;
        if (downstream.characteristics().contains(Collector.Characteristics.CONCURRENT)) {
            accumulator = (m, t) -&amp;gt; {
                K key = Objects.requireNonNull(classifier.apply(t), &quot;element cannot be mapped to a null key&quot;);
                A resultContainer = m.computeIfAbsent(key, k -&amp;gt; downstreamSupplier.get());
                downstreamAccumulator.accept(resultContainer, t);
            };
        }
        else {
            accumulator = (m, t) -&amp;gt; {
                K key = Objects.requireNonNull(classifier.apply(t), &quot;element cannot be mapped to a null key&quot;);
                A resultContainer = m.computeIfAbsent(key, k -&amp;gt; downstreamSupplier.get());
                synchronized (resultContainer) {  // 这里有一个同步的操作。虽然是多线程操作同一容器，但是同时还是只有一个线程操作，进行了同步。
                    downstreamAccumulator.accept(resultContainer, t);
                }
            };
        }

        if (downstream.characteristics().contains(Collector.Characteristics.IDENTITY_FINISH)) {
            return new CollectorImpl&amp;lt;&amp;gt;(mangledFactory, accumulator, merger, CH_CONCURRENT_ID);
        }
        else {
            @SuppressWarnings(&quot;unchecked&quot;)
            Function&amp;lt;A, A&amp;gt; downstreamFinisher = (Function&amp;lt;A, A&amp;gt;) downstream.finisher();
            Function&amp;lt;ConcurrentMap&amp;lt;K, A&amp;gt;, M&amp;gt; finisher = intermediate -&amp;gt; {
                intermediate.replaceAll((k, v) -&amp;gt; downstreamFinisher.apply(v));
                @SuppressWarnings(&quot;unchecked&quot;)
                M castResult = (M) intermediate;
                return castResult;
            };
            return new CollectorImpl&amp;lt;&amp;gt;(mangledFactory, accumulator, merger, finisher, CH_CONCURRENT_NOID);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;14. partitioningBy（）； 分区详解。
public static &amp;lt;T&amp;gt;
Collector&amp;lt;T, ?, Map&amp;lt;Boolean, List&amp;lt;T&amp;gt;&amp;gt;&amp;gt; partitioningBy(Predicate&amp;lt;? super T&amp;gt; predicate) {
    return partitioningBy(predicate, toList());
}

public static &amp;lt;T, D, A&amp;gt;
    Collector&amp;lt;T, ?, Map&amp;lt;Boolean, D&amp;gt;&amp;gt; partitioningBy(Predicate&amp;lt;? super T&amp;gt; predicate,
                                                    Collector&amp;lt;? super T, A, D&amp;gt; downstream) {
        BiConsumer&amp;lt;A, ? super T&amp;gt; downstreamAccumulator = downstream.accumulator();
        BiConsumer&amp;lt;Partition&amp;lt;A&amp;gt;, T&amp;gt; accumulator = (result, t) -&amp;gt;
                downstreamAccumulator.accept(predicate.test(t) ? result.forTrue : result.forFalse, t);
        BinaryOperator&amp;lt;A&amp;gt; op = downstream.combiner();
        BinaryOperator&amp;lt;Partition&amp;lt;A&amp;gt;&amp;gt; merger = (left, right) -&amp;gt;
                new Partition&amp;lt;&amp;gt;(op.apply(left.forTrue, right.forTrue),
                                op.apply(left.forFalse, right.forFalse));
        Supplier&amp;lt;Partition&amp;lt;A&amp;gt;&amp;gt; supplier = () -&amp;gt;
                new Partition&amp;lt;&amp;gt;(downstream.supplier().get(),
                                downstream.supplier().get());
        if (downstream.characteristics().contains(Collector.Characteristics.IDENTITY_FINISH)) {
            return new CollectorImpl&amp;lt;&amp;gt;(supplier, accumulator, merger, CH_ID);
        }
        else {
            Function&amp;lt;Partition&amp;lt;A&amp;gt;, Map&amp;lt;Boolean, D&amp;gt;&amp;gt; finisher = par -&amp;gt;
                    new Partition&amp;lt;&amp;gt;(downstream.finisher().apply(par.forTrue),
                                    downstream.finisher().apply(par.forFalse));
            return new CollectorImpl&amp;lt;&amp;gt;(supplier, accumulator, merger, finisher, CH_NOID);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;jdk的代码，就是我们学习的范本。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;讲这么细的原因并不是因为要自己去写，是为了了解内部是具体怎么实现的。调用的时候就信心非常的足。&lt;/p&gt;
&lt;h3 id=&quot;附一个小插曲&quot;&gt;附一个小插曲。&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1galyaqo3pnj310o0ssdqk.jpg&quot; alt=&quot;image-20200105201926874&quot;/&gt;&lt;/p&gt;

&lt;h3 id=&quot;节前小插曲&quot;&gt;节前小插曲&lt;/h3&gt;
&lt;p&gt;AutoCloseable接口： 通过一个例子 举例自动关闭流的实现。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface BaseStream&amp;lt;T, S extends BaseStream&amp;lt;T, S&amp;gt;&amp;gt;
        extends AutoCloseable{}  // BaseStream 继承了这个接口。 Stream继承了Stream&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class AutoCloseableTest implements AutoCloseable {
    public void dosomething() {
        System.out.println(&quot; do something &quot;);
    }

    @Override
    public void close() throws Exception {
        System.out.println(&quot; close invoked &quot;);
    }

    public static void main(String[] args) throws Exception {
        try ( AutoCloseableTest autoCloseableTest = new AutoCloseableTest()){
            autoCloseableTest.dosomething();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果如下： 自动调用了关闭流的方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1galzv6yus8j30rg0eagn0.jpg&quot; alt=&quot;image-20200105211344897&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;stream&quot;&gt;Stream&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * A sequence of elements supporting sequential and parallel aggregate
 * operations.  The following example illustrates an aggregate operation using
 * {@link Stream} and {@link IntStream}:
 *
 * &amp;lt;pre&amp;gt;{@code   // 举例： 
 *     int sum = widgets.stream()
 *                      .filter(w -&amp;gt; w.getColor() == RED)
 *                      .mapToInt(w -&amp;gt; w.getWeight())
 *                      .sum();
 * }&amp;lt;/pre&amp;gt;
 *
 * In this example, {@code widgets} is a {@code Collection&amp;lt;Widget&amp;gt;}.  We create
 * a stream of {@code Widget} objects via {@link Collection#stream Collection.stream()},
 * filter it to produce a stream containing only the red widgets, and then
 * transform it into a stream of {@code int} values representing the weight of
 * each red widget. Then this stream is summed to produce a total weight.
 *
 * &amp;lt;p&amp;gt;In addition to {@code Stream}, which is a stream of object references,
 * there are primitive specializations for {@link IntStream}, {@link LongStream},
 * and {@link DoubleStream}, all of which are referred to as &quot;streams&quot; and
 * conform to the characteristics and restrictions described here.
 jdk提供了平行的 特化的流。
 *
 * &amp;lt;p&amp;gt;To perform a computation, stream
 * &amp;lt;a href=&quot;package-summary.html#StreamOps&quot;&amp;gt;operations&amp;lt;/a&amp;gt; are composed into a
 * &amp;lt;em&amp;gt;stream pipeline&amp;lt;/em&amp;gt;.  A stream pipeline consists of a source (which
 * might be an array, a collection, a generator function, an I/O channel,
 * etc), zero or more &amp;lt;em&amp;gt;intermediate operations&amp;lt;/em&amp;gt; (which transform a
 * stream into another stream, such as {@link Stream#filter(Predicate)}), and a
 * &amp;lt;em&amp;gt;terminal operation&amp;lt;/em&amp;gt; (which produces a result or side-effect, such
 * as {@link Stream#count()} or {@link Stream#forEach(Consumer)}).
 * Streams are lazy; computation on the source data is only performed when the
 * terminal operation is initiated, and source elements are consumed only
 * as needed.
 
 
 为了执行计算，流会被执行到一个流管道当中。
 一个流管道包含了：
 一个源。（数字来的地方）
 0个或多个中间操作（将一个stream转换成另外一个Stream）。
 一个终止操作（会生成一个结果，或者是一个副作用（求和，遍历））。
 
 流是延迟的，只有当终止操作被发起的时候，才会执行中间操作。
 
 * &amp;lt;p&amp;gt;Collections and streams, while bearing some superficial similarities,
 * have different goals.  Collections are primarily concerned with the efficient
 * management of, and access to, their elements.  By contrast, streams do not
 * provide a means to directly access or manipulate their elements, and are
 * instead concerned with declaratively describing their source and the
 * computational operations which will be performed in aggregate on that source.
 * However, if the provided stream operations do not offer the desired
 * functionality, the {@link #iterator()} and {@link #spliterator()} operations
 * can be used to perform a controlled traversal.
 
 集合和流虽然有一些相似性，但是他们的差异是不同的。
 集合是为了高效对于元素的管理和访问。流并不会提供方式去直接操作流里的元素。（集合关注的是数据的管理，流关注的是元素内容的计算）
 如果流操作并没有提供我们需要的功能，那么我们可以使用传统的iterator or spliterator去执行操作。 

 * &amp;lt;p&amp;gt;A stream pipeline, like the &quot;widgets&quot; example above, can be viewed as
 * a &amp;lt;em&amp;gt;query&amp;lt;/em&amp;gt; on the stream source.  Unless the source was explicitly
 * designed for concurrent modification (such as a {@link ConcurrentHashMap}),
 * unpredictable or erroneous behavior may result from modifying the stream
 * source while it is being queried.
 
 一个流管道，可以看做是对流源的查询，除非这个流被显示的设计成可以并发修改的。否则会抛出异常。
 （如一个线程对流进行修改，另一个对流进行查询）
 
 * &amp;lt;p&amp;gt;Most stream operations accept parameters that describe user-specified
 * behavior, such as the lambda expression {@code w -&amp;gt; w.getWeight()} passed to
 * {@code mapToInt} in the example above.  To preserve correct behavior,
 * these &amp;lt;em&amp;gt;behavioral parameters&amp;lt;/em&amp;gt;:
    //为了能满足结果，需满足下边的条件。
 * &amp;lt;ul&amp;gt;
 * &amp;lt;li&amp;gt;must be &amp;lt;a href=&quot;package-summary.html#NonInterference&quot;&amp;gt;non-interfering&amp;lt;/a&amp;gt;
 * (they do not modify the stream source); and&amp;lt;/li&amp;gt;
 * &amp;lt;li&amp;gt;in most cases must be &amp;lt;a href=&quot;package-summary.html#Statelessness&quot;&amp;gt;stateless&amp;lt;/a&amp;gt;
 * (their result should not depend on any state that might change during execution
 * of the stream pipeline).&amp;lt;/li&amp;gt;
 * &amp;lt;/ul&amp;gt;
 
 行为上的参数，大多是无状态的。
 
 * &amp;lt;p&amp;gt;Such parameters are always instances of a
 * &amp;lt;a href=&quot;../function/package-summary.html&quot;&amp;gt;functional interface&amp;lt;/a&amp;gt; such
 * as {@link java.util.function.Function}, and are often lambda expressions or
 * method references.  Unless otherwise specified these parameters must be
 * &amp;lt;em&amp;gt;non-null&amp;lt;/em&amp;gt;.
 
    无一例外的。这种参数总是函数式接口的形式。也就是lambda表达式。除非特别指定，这些参数必须是非空的。
    
 * &amp;lt;p&amp;gt;A stream should be operated on (invoking an intermediate or terminal stream
 * operation) only once.  This rules out, for example, &quot;forked&quot; streams, where
 * the same source feeds two or more pipelines, or multiple traversals of the
 * same stream.  A stream implementation may throw {@link IllegalStateException}
 * if it detects that the stream is being reused. However, since some stream
 * operations may return their receiver rather than a new stream object, it may
 * not be possible to detect reuse in all cases.
 
 一个流只能被使用一次。对相同的流进行多次操作，需要创建多个流管道。
 
 * &amp;lt;p&amp;gt;Streams have a {@link #close()} method and implement {@link AutoCloseable},
 * but nearly all stream instances do not actually need to be closed after use.
 * Generally, only streams whose source is an IO channel (such as those returned
 * by {@link Files#lines(Path, Charset)}) will require closing.  Most streams
 * are backed by collections, arrays, or generating functions, which require no
 * special resource management.  (If a stream does require closing, it can be
 * declared as a resource in a {@code try}-with-resources statement.)
 
 流拥有一个closed方法，实现了AutoCloseable，在他的父类里。 最上面以举例实现。
 但是一个流 除了是I/O流（因为持有句柄等资源）才需要被关闭外，是不需要被关闭的。
 大多数的流底层是集合、数组或者是生成器函数。 他们并不需要特别的资源管理。如果需要被关闭，可以用try（）操作。

 * &amp;lt;p&amp;gt;Stream pipelines may execute either sequentially or in
 * &amp;lt;a href=&quot;package-summary.html#Parallelism&quot;&amp;gt;parallel&amp;lt;/a&amp;gt;.  This
 * execution mode is a property of the stream.  Streams are created
 * with an initial choice of sequential or parallel execution.  (For example,
 * {@link Collection#stream() Collection.stream()} creates a sequential stream,
 * and {@link Collection#parallelStream() Collection.parallelStream()} creates
 * a parallel one.)  This choice of execution mode may be modified by the
 * {@link #sequential()} or {@link #parallel()} methods, and may be queried with
 * the {@link #isParallel()} method.
 
 流管道可以被串行或者并行操作。这种模式只是一个属性而已。 初始化的时候会进行一个选择。
 比如说  stream() 是串行流。parallelStream()是并行流。 
 还可以通过sequential（）or parallel() 来进行修改。 以最后一个被调用的方法为准。
 也可以用isParallel（）来进行查询流是否是并行流。
 
 * @param &amp;lt;T&amp;gt; the type of the stream elements
 * @since 1.8
 * @see IntStream
 * @see LongStream
 * @see DoubleStream
 * @see &amp;lt;a href=&quot;package-summary.html&quot;&amp;gt;java.util.stream&amp;lt;/a&amp;gt;
 */
public interface Stream&amp;lt;T&amp;gt; extends BaseStream&amp;lt;T, Stream&amp;lt;T&amp;gt;&amp;gt; {
  
  // 具体举例， 源码中有例子
    Stream&amp;lt;T&amp;gt; filter(Predicate&amp;lt;? super T&amp;gt; predicate);    // 过滤
  &amp;lt;R&amp;gt; Stream&amp;lt;R&amp;gt; map(Function&amp;lt;? super T, ? extends R&amp;gt; mapper);  //映射
  IntStream mapToInt(ToIntFunction&amp;lt;? super T&amp;gt; mapper);
  LongStream mapToLong(ToLongFunction&amp;lt;? super T&amp;gt; mapper);
  DoubleStream mapToDouble(ToDoubleFunction&amp;lt;? super T&amp;gt; mapper); 
  &amp;lt;R&amp;gt; Stream&amp;lt;R&amp;gt; flatMap(Function&amp;lt;? super T, ? extends Stream&amp;lt;? extends R&amp;gt;&amp;gt; mapper); //压平
  IntStream flatMapToInt(Function&amp;lt;? super T, ? extends IntStream&amp;gt; mapper);
  LongStream flatMapToLong(Function&amp;lt;? super T, ? extends LongStream&amp;gt; mapper);
  DoubleStream flatMapToDouble(Function&amp;lt;? super T, ? extends DoubleStream&amp;gt; mapper);、
  Stream&amp;lt;T&amp;gt; distinct();// 去重
  Stream&amp;lt;T&amp;gt; sorted(); //排序
  Stream&amp;lt;T&amp;gt; sorted(Comparator&amp;lt;? super T&amp;gt; comparator);
  Stream&amp;lt;T&amp;gt; peek(Consumer&amp;lt;? super T&amp;gt; action);  
  Stream&amp;lt;T&amp;gt; limit(long maxSize);  // 截断
  void forEach(Consumer&amp;lt;? super T&amp;gt; action); // 遍历
  void forEachOrdered(Consumer&amp;lt;? super T&amp;gt; action); // 遍历时执行操作
  Object[] toArray();  // 转数组
  T reduce(T identity, BinaryOperator&amp;lt;T&amp;gt; accumulator); //  汇聚， 返回一个汇聚的结果
  &amp;lt;R&amp;gt; R collect(Supplier&amp;lt;R&amp;gt; supplier,
                  BiConsumer&amp;lt;R, ? super T&amp;gt; accumulator,
                  BiConsumer&amp;lt;R, R&amp;gt; combiner);     // 收集器 
  。。。  
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;自行参考父接口中的方法；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;h3 id=&quot;stream中具体方法的详解&quot;&gt;Stream中具体方法的详解&lt;/h3&gt;
&lt;p&gt;分割迭代器：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**

 * Returns a spliterator for the elements of this stream.
 *
 * &amp;lt;p&amp;gt;This is a &amp;lt;a href=&quot;package-summary.html#StreamOps&quot;&amp;gt;terminal
 * operation&amp;lt;/a&amp;gt;.
 *
 * @return the element spliterator for this stream
 */
Spliterator&amp;lt;T&amp;gt; spliterator();&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;在公司的学习笔记。&lt;/p&gt;
&lt;h3 id=&quot;basestream-源码讲解&quot;&gt;baseStream 源码讲解&lt;/h3&gt;
&lt;p&gt;BaseStream 是所有流的父类 。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * Base interface for streams, which are sequences of elements supporting
 * sequential and parallel aggregate operations.  The following example
 * illustrates an aggregate operation using the stream types {@link Stream}
 * and {@link IntStream}, computing the sum of the weights of the red widgets:
 *
 * &amp;lt;pre&amp;gt;{@code
 *     int sum = widgets.stream()
 *                      .filter(w -&amp;gt; w.getColor() == RED)
 *                      .mapToInt(w -&amp;gt; w.getWeight())
 *                      .sum();
 * }&amp;lt;/pre&amp;gt;
 *
 * See the class documentation for {@link Stream} and the package documentation
 * for &amp;lt;a href=&quot;package-summary.html&quot;&amp;gt;java.util.stream&amp;lt;/a&amp;gt; for additional
 * specification of streams, stream operations, stream pipelines, and
 * parallelism, which governs the behavior of all stream types.
 *
 * @param &amp;lt;T&amp;gt; the type of the stream elements
 * @param &amp;lt;S&amp;gt; the type of of the stream implementing {@code BaseStream}
 * @since 1.8
 * @see Stream
 * @see IntStream
 * @see LongStream
 * @see DoubleStream
 * @see &amp;lt;a href=&quot;package-summary.html&quot;&amp;gt;java.util.stream&amp;lt;/a&amp;gt;
 */
public interface BaseStream&amp;lt;T, S extends BaseStream&amp;lt;T, S&amp;gt;&amp;gt; extends AutoCloseable 

public interface Stream&amp;lt;T&amp;gt; extends BaseStream&amp;lt;T, Stream&amp;lt;T&amp;gt;&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;BaseStream(){

 Iterator&amp;lt;T&amp;gt; iterator(); 迭代器
 Spliterator&amp;lt;T&amp;gt; spliterator();  分割迭代器  。 这是一个流的终止操作。
 boolean isParallel();  是否是并行。   
 S sequential();  // 返回一个等价的串行流。   返回S是一个新的流对象
 S parallel();   //返回一个并行流。 
 S unordered();   // 返回一个无序的流。
 S onClose(Runnable closeHandler);   //当前流.onClose、 当close调用时，调用此方法。
 void close();      // 关闭流
 
 }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;关闭处理器的举例&quot;&gt;关闭处理器的举例&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
     * Returns an equivalent stream with an additional close handler.  Close
     * handlers are run when the {@link #close()} method
     * is called on the stream, and are executed in the order they were
     * added.  All close handlers are run, even if earlier close handlers throw
     * exceptions.  If any close handler throws an exception, the first
     * exception thrown will be relayed to the caller of {@code close()}, with
     * any remaining exceptions added to that exception as suppressed exceptions
     * (unless one of the remaining exceptions is the same exception as the
     * first exception, since an exception cannot suppress itself.)  May
     * return itself.
     *
     * &amp;lt;p&amp;gt;This is an &amp;lt;a href=&quot;package-summary.html#StreamOps&quot;&amp;gt;intermediate
     * operation&amp;lt;/a&amp;gt;.
     *
     * @param closeHandler A task to execute when the stream is closed
     * @return a stream with a handler that is run if the stream is closed
     */
    S onClose(Runnable closeHandler);
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; public static void main(String[] args) {

        List&amp;lt;String&amp;gt; list = Arrays.asList(&quot;hello&quot;,&quot;world&quot;);
        NullPointerException nullPointerException = new NullPointerException(&quot;myexception&quot;);
        try (Stream&amp;lt;String&amp;gt; stream = list.stream()){
            stream.onClose(()-&amp;gt;{
                System.out.println(&quot;aaa&quot;);
//                throw new NullPointerException(&quot;first&quot;);
                throw nullPointerException;
            }).onClose(()-&amp;gt;{
                System.out.println(&quot;aaa&quot;);
                throw nullPointerException;
            }).forEach(System.out::println);
        }
        // 出现异常会被压制，
        // 如果是同一个异常对象，只会打印一次异常。 如果是多个异常对象。都会被打印。
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;javadoc 中的介绍比任何资料都详细。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;h3 id=&quot;stream-源码分析&quot;&gt;Stream 源码分析。&lt;/h3&gt;
&lt;h4 id=&quot;stream-1&quot;&gt;stream();&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
     * Returns a sequential {@code Stream} with this collection as its source.
     
     返回一个串行流，把这个集合当做源
     
     * &amp;lt;p&amp;gt;This method should be overridden when the {@link #spliterator()}
     * method cannot return a spliterator that is {@code IMMUTABLE},
     * {@code CONCURRENT}, or &amp;lt;em&amp;gt;late-binding&amp;lt;/em&amp;gt;. (See {@link #spliterator()}
     * for details.)

     当不能返回  三种方法 中的一个时，这个方法应该被重写。
     
     * @implSpec
     * The default implementation creates a sequential {@code Stream} from the
     * collection's {@code Spliterator}.
     
     默认会从集合中创建一个串行流。 返回
     
     * @return a sequential {@code Stream} over the elements in this collection
     * @since 1.8
     */
    default Stream&amp;lt;E&amp;gt; stream() {
        return StreamSupport.stream(spliterator(), false);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;spliterator-分割迭代器&quot;&gt;spliterator(); 分割迭代器&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; /**
     * Creates a {@link Spliterator} over the elements in this collection.
     *
     * Implementations should document characteristic values reported by the
     * spliterator.  Such characteristic values are not required to be reported
     * if the spliterator reports {@link Spliterator#SIZED} and this collection
     * contains no elements.
     
     * &amp;lt;p&amp;gt;The default implementation should be overridden by subclasses that
     * can return a more efficient spliterator.  In order to
     * preserve expected laziness behavior for the {@link #stream()} and
     * {@link #parallelStream()}} methods, spliterators should either have the
     * characteristic of {@code IMMUTABLE} or {@code CONCURRENT}, or be
     * &amp;lt;em&amp;gt;&amp;lt;a href=&quot;Spliterator.html#binding&quot;&amp;gt;late-binding&amp;lt;/a&amp;gt;&amp;lt;/em&amp;gt;.
     
     默认的子类应该被重写。为了保留parallelStream  和 stream的延迟行为。特性需要满足IMMUTABLE 或者CONCURRENT
     
     * If none of these is practical, the overriding class should describe the
     * spliterator's documented policy of binding and structural interference,
     * and should override the {@link #stream()} and {@link #parallelStream()}
     * methods to create streams using a {@code Supplier} of the spliterator,
     * as in:
     * &amp;lt;pre&amp;gt;{@code
     *     Stream&amp;lt;E&amp;gt; s = StreamSupport.stream(() -&amp;gt; spliterator(), spliteratorCharacteristics)
     * }&amp;lt;/pre&amp;gt;
     
     为什么叫分割迭代器。先分割，在迭代。
     如果不能满足上述的要求，则重写的时候应该满足上述的需求、
     
     * &amp;lt;p&amp;gt;These requirements ensure that streams produced by the
     * {@link #stream()} and {@link #parallelStream()} methods will reflect the
     * contents of the collection as of initiation of the terminal stream
     * operation.
     
     这些确保了流会返回的内容。
     
     * @implSpec
     * The default implementation creates a
     * &amp;lt;em&amp;gt;&amp;lt;a href=&quot;Spliterator.html#binding&quot;&amp;gt;late-binding&amp;lt;/a&amp;gt;&amp;lt;/em&amp;gt; spliterator
     * from the collections's {@code Iterator}.  The spliterator inherits the
     * &amp;lt;em&amp;gt;fail-fast&amp;lt;/em&amp;gt; properties of the collection's iterator.
     * &amp;lt;p&amp;gt;
     * The created {@code Spliterator} reports {@link Spliterator#SIZED}.
    
     默认会从集合的迭代器中创建出一个延迟的分割迭代器。 默认的迭代器 会有默认大小的迭代器。
     
     * @implNote
     * The created {@code Spliterator} additionally reports
     * {@link Spliterator#SUBSIZED}.
     *
     * &amp;lt;p&amp;gt;If a spliterator covers no elements then the reporting of additional
     * characteristic values, beyond that of {@code SIZED} and {@code SUBSIZED},
     * does not aid clients to control, specialize or simplify computation.
     * However, this does enable shared use of an immutable and empty
     * spliterator instance (see {@link Spliterators#emptySpliterator()}) for
     * empty collections, and enables clients to determine if such a spliterator
     * covers no elements.
     
     如果分割迭代器不包含任何元素。 其他的属性对客户端是没有任何帮助的。 然而会促进分割迭代器共享的作用。
     
     * @return a {@code Spliterator} over the elements in this collection
     * @since 1.8
     */
    @Override
    default Spliterator&amp;lt;E&amp;gt; spliterator() {
        return Spliterators.spliterator(this, 0);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;spliterator-javadoc&quot;&gt;Spliterator javadoc&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * An object for traversing and partitioning elements of a source.  The source
 * of elements covered by a Spliterator could be, for example, an array, a
 * {@link Collection}, an IO channel, or a generator function.

 * &amp;lt;p&amp;gt;A Spliterator may traverse elements individually ({@link
 * #tryAdvance tryAdvance()}) or sequentially in bulk
 * ({@link #forEachRemaining forEachRemaining()}).   
一个一个去遍历 tryAdvance（） 或者  成块的遍历forEachRemaining（）
 *
 * &amp;lt;p&amp;gt;A Spliterator may also partition off some of its elements (using
 * {@link #trySplit}) as another Spliterator, to be used in
 * possibly-parallel operations.  Operations using a Spliterator that
 * cannot split, or does so in a highly imbalanced or inefficient
 * manner, are unlikely to benefit from parallelism.  Traversal
 * and splitting exhaust elements; each Spliterator is useful for only a single
 * bulk computation.
 
 Spliterator 可以对元素进行分区。 分成新的Spliterator。 并且以并行的操作来实行。    
 如果不能分割这些操作，则不能通过并行操作受益。
 遍历和分割都会对那一小块是有用的、

 * &amp;lt;p&amp;gt;A Spliterator also reports a set of {@link #characteristics()} of its
 * structure, source, and elements from among {@link #ORDERED},
 * {@link #DISTINCT}, {@link #SORTED}, {@link #SIZED}, {@link #NONNULL},
 * {@link #IMMUTABLE}, {@link #CONCURRENT}, and {@link #SUBSIZED}. These may
 * be employed by Spliterator clients to control, specialize or simplify
 * computation.  For example, a Spliterator for a {@link Collection} would
 * report {@code SIZED}, a Spliterator for a {@link Set} would report
 * {@code DISTINCT}, and a Spliterator for a {@link SortedSet} would also
 * report {@code SORTED}.  Characteristics are reported as a simple unioned bit
 * set.

    特性值：ORDERED 有序的， DISTINCT 不同的，SORTED 带排序的，SIZED 确定大小的， 
            NONNULL 非空的， IMMUTABLE，  CONCURRENT  ，SUBSIZED 
    这些特性可以在客户端使用，用来简化计算。是以位操作的形式来表示的。 collector中是以枚举形式来表示的。

 * Some characteristics additionally constrain method behavior; for example if
 * {@code ORDERED}, traversal methods must conform to their documented ordering.
 * New characteristics may be defined in the future, so implementors should not
 * assign meanings to unlisted values.
 
    未来可能会定义一下新的特性。 实现者不应该赋予新的含义。

 * &amp;lt;p&amp;gt;&amp;lt;a name=&quot;binding&quot;&amp;gt;A Spliterator that does not report {@code IMMUTABLE} or
 * {@code CONCURRENT} is expected to have a documented policy concerning:
 * when the spliterator &amp;lt;em&amp;gt;binds&amp;lt;/em&amp;gt; to the element source; and detection of
 * structural interference of the element source detected after binding.&amp;lt;/a&amp;gt;  A
 * &amp;lt;em&amp;gt;late-binding&amp;lt;/em&amp;gt; Spliterator binds to the source of elements at the
 * point of first traversal, first split, or first query for estimated size,
 * rather than at the time the Spliterator is created.  A Spliterator that is
 * not &amp;lt;em&amp;gt;late-binding&amp;lt;/em&amp;gt; binds to the source of elements at the point of
 * construction or first invocation of any method.  Modifications made to the
 * source prior to binding are reflected when the Spliterator is traversed.
 * After binding a Spliterator should, on a best-effort basis, throw
 * {@link ConcurrentModificationException} if structural interference is
 * detected.  Spliterators that do this are called &amp;lt;em&amp;gt;fail-fast&amp;lt;/em&amp;gt;.  The
 * bulk traversal method ({@link #forEachRemaining forEachRemaining()}) of a
 * Spliterator may optimize traversal and check for structural interference
 * after all elements have been traversed, rather than checking per-element and
 * failing immediately.

  当Spliterator 绑定到源上时 ， 要考虑   IMMUTABLE 和 CONCURRENT 。
  延迟迭代器会在第一次遍历或者分割或者查询大小的时候绑定在源上边。而不是在创建的时候就被绑定在源上了。
  非延迟迭代器是在创建的时候就被绑定在源上了。
  在迭代器绑定后对源进行了修改。迭代器就能反应出来抛出异常ConcurrentModificationException。
  forEachRemaining（）会优化遍历，是在所有元素都被操作之后进行操作，而不是一个元素一个元素的检测、

 * &amp;lt;p&amp;gt;Spliterators can provide an estimate of the number of remaining elements
 * via the {@link #estimateSize} method.  Ideally, as reflected in characteristic
 * {@link #SIZED}, this value corresponds exactly to the number of elements
 * that would be encountered in a successful traversal.  However, even when not
 * exactly known, an estimated value value may still be useful to operations
 * being performed on the source, such as helping to determine whether it is
 * preferable to split further or traverse the remaining elements sequentially.
 
    如果 特性值 SIZED 。 那么将要遍历的数量是确定的。
    如果不包含SIZED，一个估算的值对于源的操作也是有帮助的。
 
 * &amp;lt;p&amp;gt;Despite their obvious utility in parallel algorithms, spliterators are not
 * expected to be thread-safe; instead, implementations of parallel algorithms
 * using spliterators should ensure that the spliterator is only used by one
 * thread at a time.  This is generally easy to attain via &amp;lt;em&amp;gt;serial
 * thread-confinement&amp;lt;/em&amp;gt;, which often is a natural consequence of typical
 * parallel algorithms that work by recursive decomposition.  A thread calling
 * {@link #trySplit()} may hand over the returned Spliterator to another thread,
 * which in turn may traverse or further split that Spliterator.  The behaviour
 * of splitting and traversal is undefined if two or more threads operate
 * concurrently on the same spliterator.  If the original thread hands a
 * spliterator off to another thread for processing, it is best if that handoff
 * occurs before any elements are consumed with {@link #tryAdvance(Consumer)
 * tryAdvance()}, as certain guarantees (such as the accuracy of
 * {@link #estimateSize()} for {@code SIZED} spliterators) are only valid before
 * traversal has begun.
 
 分割迭代器并不确保是线程安全的。相反 应该确保分割迭代器一次被一个线程操作、
  可以通过递归的方式来实现。
    
 * &amp;lt;p&amp;gt;Primitive subtype specializations of {@code Spliterator} are provided for
 * {@link OfInt int}, {@link OfLong long}, and {@link OfDouble double} values.
 * The subtype default implementations of
 * {@link Spliterator#tryAdvance(java.util.function.Consumer)}
 * and {@link Spliterator#forEachRemaining(java.util.function.Consumer)} box
 * primitive values to instances of their corresponding wrapper class.  Such
 * boxing may undermine any performance advantages gained by using the primitive
 * specializations.  To avoid boxing, the corresponding primitive-based methods
 * should be used.  For example,
 * {@link Spliterator.OfInt#tryAdvance(java.util.function.IntConsumer)}
 * and {@link Spliterator.OfInt#forEachRemaining(java.util.function.IntConsumer)}
 * should be used in preference to
 * {@link Spliterator.OfInt#tryAdvance(java.util.function.Consumer)} and
 * {@link Spliterator.OfInt#forEachRemaining(java.util.function.Consumer)}.
 * Traversal of primitive values using boxing-based methods
 * {@link #tryAdvance tryAdvance()} and
 * {@link #forEachRemaining(java.util.function.Consumer) forEachRemaining()}
 * does not affect the order in which the values, transformed to boxed values,
 * are encountered.
 
 为了避免重复的装箱和拆箱，我们应该使用巨化的方法。 减少使用通用的方法。
 *
 * @apiNote
 * &amp;lt;p&amp;gt;Spliterators, like {@code Iterator}s, are for traversing the elements of
 * a source.  The {@code Spliterator} API was designed to support efficient
 * parallel traversal in addition to sequential traversal, by supporting
 * decomposition as well as single-element iteration.  In addition, the
 * protocol for accessing elements via a Spliterator is designed to impose
 * smaller per-element overhead than {@code Iterator}, and to avoid the inherent
 * race involved in having separate methods for {@code hasNext()} and
 * {@code next()}.
 
 分割迭代器 就像迭代器一样。 用来遍历源当中的元素的。
 Spliterator也支持并行的操作。方式是通过解耦，分解，单元素的遍历迭代。
 Spliterator相比于Iterator来说，成本更低。tryAdvance（）本质上也避免了hasNext()和next() 的资源上的竞争。
 
 * &amp;lt;p&amp;gt;For mutable sources, arbitrary and non-deterministic behavior may occur if
 * the source is structurally interfered with (elements added, replaced, or
 * removed) between the time that the Spliterator binds to its data source and
 * the end of traversal.  For example, such interference will produce arbitrary,
 * non-deterministic results when using the {@code java.util.stream} framework.

    对于可变源来说，可能会出现问题
    
 * &amp;lt;p&amp;gt;Structural interference of a source can be managed in the following ways
 * (in approximate order of decreasing desirability):
 * &amp;lt;ul&amp;gt;
 * &amp;lt;li&amp;gt;The source cannot be structurally interfered with.
 * &amp;lt;br&amp;gt;For example, an instance of
 * {@link java.util.concurrent.CopyOnWriteArrayList} is an immutable source.
 * A Spliterator created from the source reports a characteristic of
 * {@code IMMUTABLE}.&amp;lt;/li&amp;gt;
 
    CopyOnWriteArrayList 适合于 读多写少的场景。 他是一个不可变的源。会返回一个特性值IMMUTABLE
 
 * &amp;lt;li&amp;gt;The source manages concurrent modifications.
 * &amp;lt;br&amp;gt;For example, a key set of a {@link java.util.concurrent.ConcurrentHashMap}
 * is a concurrent source.  A Spliterator created from the source reports a
 * characteristic of {@code CONCURRENT}.&amp;lt;/li&amp;gt;
 
  创建并发源、 特性值  CONCURRENT
  
 * &amp;lt;li&amp;gt;The mutable source provides a late-binding and fail-fast Spliterator.
 * &amp;lt;br&amp;gt;Late binding narrows the window during which interference can affect
 * the calculation; fail-fast detects, on a best-effort basis, that structural
 * interference has occurred after traversal has commenced and throws
 * {@link ConcurrentModificationException}.  For example, {@link ArrayList},
 * and many other non-concurrent {@code Collection} classes in the JDK, provide
 * a late-binding, fail-fast spliterator.&amp;lt;/li&amp;gt;
 * &amp;lt;li&amp;gt;The mutable source provides a non-late-binding but fail-fast Spliterator.
 * &amp;lt;br&amp;gt;The source increases the likelihood of throwing
 * {@code ConcurrentModificationException} since the window of potential
 * interference is larger.&amp;lt;/li&amp;gt;
 * &amp;lt;li&amp;gt;The mutable source provides a late-binding and non-fail-fast Spliterator.
 * &amp;lt;br&amp;gt;The source risks arbitrary, non-deterministic behavior after traversal
 * has commenced since interference is not detected.
 * &amp;lt;/li&amp;gt;
 * &amp;lt;li&amp;gt;The mutable source provides a non-late-binding and non-fail-fast
 * Spliterator.
 * &amp;lt;br&amp;gt;The source increases the risk of arbitrary, non-deterministic behavior
 * since non-detected interference may occur after construction.
 * &amp;lt;/li&amp;gt;
 * &amp;lt;/ul&amp;gt;
 *
 // 串行的例子：
 * &amp;lt;p&amp;gt;&amp;lt;b&amp;gt;Example.&amp;lt;/b&amp;gt; Here is a class (not a very useful one, except
 * for illustration) that maintains an array in which the actual data
 * are held in even locations, and unrelated tag data are held in odd
 * locations. Its Spliterator ignores the tags.
 *  
 * &amp;lt;pre&amp;gt; {@code
 * class TaggedArray&amp;lt;T&amp;gt; {
 *   private final Object[] elements; // immutable after construction
 *   TaggedArray(T[] data, Object[] tags) {
 *     int size = data.length;
 *     if (tags.length != size) throw new IllegalArgumentException();
 *     this.elements = new Object[2 * size];
 *     for (int i = 0, j = 0; i &amp;lt; size; ++i) {
 *       elements[j++] = data[i];
 *       elements[j++] = tags[i];
 *     }
 *   }
 *
 *   public Spliterator&amp;lt;T&amp;gt; spliterator() {
 *     return new TaggedArraySpliterator&amp;lt;&amp;gt;(elements, 0, elements.length);
 *   }
 *
 *   static class TaggedArraySpliterator&amp;lt;T&amp;gt; implements Spliterator&amp;lt;T&amp;gt; {
 *     private final Object[] array;
 *     private int origin; // current index, advanced on split or traversal
 *     private final int fence; // one past the greatest index
 *
 *     TaggedArraySpliterator(Object[] array, int origin, int fence) {
 *       this.array = array; this.origin = origin; this.fence = fence;
 *     }
 *
 *     public void forEachRemaining(Consumer&amp;lt;? super T&amp;gt; action) {
 *       for (; origin &amp;lt; fence; origin += 2)
 *         action.accept((T) array[origin]);
 *     }
 *
        // 让这个迭代器往前走
 *     public boolean tryAdvance(Consumer&amp;lt;? super T&amp;gt; action) {
 *       if (origin &amp;lt; fence) {
 *         action.accept((T) array[origin]);
 *         origin += 2;
 *         return true;
 *       }
 *       else // cannot advance
 *         return false;
 *     }
 *
        // 尝试进行分割， 尽量均匀的分割成两半. 不成功返回null
 *     public Spliterator&amp;lt;T&amp;gt; trySplit() {
 *       int lo = origin; // divide range in half
 *       int mid = ((lo + fence) &amp;gt;&amp;gt;&amp;gt; 1) &amp;amp; ~1; // force midpoint to be even
 *       if (lo &amp;lt; mid) { // split out left half
 *         origin = mid; // reset this Spliterator's origin
 *         return new TaggedArraySpliterator&amp;lt;&amp;gt;(array, lo, mid);
 *       }
 *       else       // too small to split
 *         return null;
 *     }
 *
 *     public long estimateSize() {
 *       return (long)((fence - origin) / 2);
 *     }
 *
 *     public int characteristics() {
 *       return ORDERED | SIZED | IMMUTABLE | SUBSIZED;
 *     }
 *   }
 * }}&amp;lt;/pre&amp;gt;
 *
 // 并行的例子
 * &amp;lt;p&amp;gt;As an example how a parallel computation framework, such as the
 * {@code java.util.stream} package, would use Spliterator in a parallel
 * computation, here is one way to implement an associated parallel forEach,
 * that illustrates the primary usage idiom of splitting off subtasks until
 * the estimated amount of work is small enough to perform
 * sequentially. Here we assume that the order of processing across
 * subtasks doesn't matter; different (forked) tasks may further split
 * and process elements concurrently in undetermined order.  This
 * example uses a {@link java.util.concurrent.CountedCompleter};
 * similar usages apply to other parallel task constructions.
 *
 * &amp;lt;pre&amp;gt;{@code
 * static &amp;lt;T&amp;gt; void parEach(TaggedArray&amp;lt;T&amp;gt; a, Consumer&amp;lt;T&amp;gt; action) {
 *   Spliterator&amp;lt;T&amp;gt; s = a.spliterator();
 *   long targetBatchSize = s.estimateSize() / (ForkJoinPool.getCommonPoolParallelism() * 8);
 *   new ParEach(null, s, action, targetBatchSize).invoke();
 * }
 *
 * static class ParEach&amp;lt;T&amp;gt; extends CountedCompleter&amp;lt;Void&amp;gt; {
 *   final Spliterator&amp;lt;T&amp;gt; spliterator;
 *   final Consumer&amp;lt;T&amp;gt; action;
 *   final long targetBatchSize;
 *
 *   ParEach(ParEach&amp;lt;T&amp;gt; parent, Spliterator&amp;lt;T&amp;gt; spliterator,
 *           Consumer&amp;lt;T&amp;gt; action, long targetBatchSize) {
 *     super(parent);
 *     this.spliterator = spliterator; this.action = action;
 *     this.targetBatchSize = targetBatchSize;
 *   }
 *
 *   public void compute() {
 *     Spliterator&amp;lt;T&amp;gt; sub;
 *     while (spliterator.estimateSize() &amp;gt; targetBatchSize &amp;amp;&amp;amp;
 *            (sub = spliterator.trySplit()) != null) {
 *       addToPendingCount(1);
 *       new ParEach&amp;lt;&amp;gt;(this, sub, action, targetBatchSize).fork();
 *     }
 *     spliterator.forEachRemaining(action);
 *     propagateCompletion();
 *   }
 * }}&amp;lt;/pre&amp;gt;
 *
 * @implNote
 * If the boolean system property {@code org.openjdk.java.util.stream.tripwire}
 * is set to {@code true} then diagnostic warnings are reported if boxing of
 * primitive values occur when operating on primitive subtype specializations.
 *   如果 {@code org.openjdk.java.util.stream.tripwire} 被设置成true， 则会给出警告。
 * @param &amp;lt;T&amp;gt; the type of elements returned by this Spliterator
 *
 * @see Collection
 * @since 1.8
 */
public interface Spliterator&amp;lt;T&amp;gt; {
      // 。。。  下方列举几个
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;tryadvance&quot;&gt;tryAdvance();&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * If a remaining element exists, performs the given action on it,
 * returning {@code true}; else returns {@code false}.  If this
 * Spliterator is {@link #ORDERED} the action is performed on the
 * next element in encounter order.  Exceptions thrown by the
 * action are relayed to the caller.
 *
 * @param action The action
 * @return {@code false} if no remaining elements existed
 * upon entry to this method, else {@code true}.
 * @throws NullPointerException if the specified action is null
 */
//尝试的去前进。如果有下一个元素，则进行动作。
boolean tryAdvance(Consumer&amp;lt;? super T&amp;gt; action);  &lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;foreachremaining&quot;&gt;forEachRemaining();&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * Performs the given action for each remaining element, sequentially in
 * the current thread, until all elements have been processed or the action
 * throws an exception.  If this Spliterator is {@link #ORDERED}, actions
 * are performed in encounter order.  Exceptions thrown by the action
 * are relayed to the caller.
 *
 * @implSpec
 * The default implementation repeatedly invokes {@link #tryAdvance} until
 * it returns {@code false}.  It should be overridden whenever possible.
 *
 * @param action The action
 * @throws NullPointerException if the specified action is null
 */
// 针对于剩余的元素进行操作。
default void forEachRemaining(Consumer&amp;lt;? super T&amp;gt; action) {
    do { } while (tryAdvance(action));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;trysplit&quot;&gt;trySplit();&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * If this spliterator can be partitioned, returns a Spliterator
 * covering elements, that will, upon return from this method, not
 * be covered by this Spliterator.
 * 如果这个分割迭代器能被分割，则返回一个新的被分割出来的Spliterator对象。
 不会影响当前的spliterator
 * &amp;lt;p&amp;gt;If this Spliterator is {@link #ORDERED}, the returned Spliterator
 * must cover a strict prefix of the elements.
 *如果Spliterator是有序的，则返回的也应该是有序的Spliterator
 * &amp;lt;p&amp;gt;Unless this Spliterator covers an infinite number of elements,
 * repeated calls to {@code trySplit()} must eventually return {@code null}.
  除非Spliterator 返回的是无穷的元素，其余的最终返回一个null . 表示不能再继续分割了。
 * Upon non-null return:
 如果返回不为Null的话， 
 * &amp;lt;ul&amp;gt;
 * &amp;lt;li&amp;gt;the value reported for {@code estimateSize()} before splitting,
 * must, after splitting, be greater than or equal to {@code estimateSize()}
 * for this and the returned Spliterator; and&amp;lt;/li&amp;gt;
 分割前的estimateSize&amp;gt;= 返回的estimateSize
 * &amp;lt;li&amp;gt;if this Spliterator is {@code SUBSIZED}, then {@code estimateSize()}
 * for this spliterator before splitting must be equal to the sum of
 * {@code estimateSize()} for this and the returned Spliterator after
 * splitting.&amp;lt;/li&amp;gt;
 如果大小是固定的。则分割后的 estimateSize 的总和 等于分割前的 estimateSize
 * &amp;lt;/ul&amp;gt;
 *
 * &amp;lt;p&amp;gt;This method may return {@code null} for any reason,
 * including emptiness, inability to split after traversal has
 * commenced, data structure constraints, and efficiency
 * considerations.
 * 
 * @apiNote
 * An ideal {@code trySplit} method efficiently (without
 * traversal) divides its elements exactly in half, allowing
 * balanced parallel computation.  Many departures from this ideal
 * remain highly effective; for example, only approximately
 * splitting an approximately balanced tree, or for a tree in
 * which leaf nodes may contain either one or two elements,
 * failing to further split these nodes.  However, large
 * deviations in balance and/or overly inefficient {@code
 * trySplit} mechanics typically result in poor parallel
 * performance.
 *理想情况下，是从中间分割的，允许并行计算。很多情况下不满足这种的、
 然而没有效率的分割，会降低效率
 * @return a {@code Spliterator} covering some portion of the
 * elements, or {@code null} if this spliterator cannot be split
 */
//尝试分割。
Spliterator&amp;lt;T&amp;gt; trySplit();&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;estimatesize&quot;&gt;estimateSize();&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * Returns an estimate of the number of elements that would be
 * encountered by a {@link #forEachRemaining} traversal, or returns {@link
 * Long#MAX_VALUE} if infinite, unknown, or too expensive to compute.
 *
 * &amp;lt;p&amp;gt;If this Spliterator is {@link #SIZED} and has not yet been partially
 * traversed or split, or this Spliterator is {@link #SUBSIZED} and has
 * not yet been partially traversed, this estimate must be an accurate
 * count of elements that would be encountered by a complete traversal.
 * Otherwise, this estimate may be arbitrarily inaccurate, but must decrease
 * as specified across invocations of {@link #trySplit}.
 * 分的越少，estimateSize要比原来的个数要小。
 * @apiNote
 * Even an inexact estimate is often useful and inexpensive to compute.
 * For example, a sub-spliterator of an approximately balanced binary tree
 * may return a value that estimates the number of elements to be half of
 * that of its parent; if the root Spliterator does not maintain an
 * accurate count, it could estimate size to be the power of two
 * corresponding to its maximum depth.
 *一个不精算的数量也是有用的。   
 * @return the estimated size, or {@code Long.MAX_VALUE} if infinite,
 *         unknown, or too expensive to compute.
 */
//估算大小
long estimateSize();&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;characteristics&quot;&gt;characteristics();&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * Returns a set of characteristics of this Spliterator and its
 * elements. The result is represented as ORed values from {@link
 * #ORDERED}, {@link #DISTINCT}, {@link #SORTED}, {@link #SIZED},
 * {@link #NONNULL}, {@link #IMMUTABLE}, {@link #CONCURRENT},
 * {@link #SUBSIZED}.  Repeated calls to {@code characteristics()} on
 * a given spliterator, prior to or in-between calls to {@code trySplit},
 * should always return the same result.
 
 一个特性值的集合。
 重复的调用characteristics  在spliterator之前或者当中，会返回相同的结果。
 
 * &amp;lt;p&amp;gt;If a Spliterator reports an inconsistent set of
 * characteristics (either those returned from a single invocation
 * or across multiple invocations), no guarantees can be made
 * about any computation using this Spliterator.
 
  如果返回了一个不一致的特性值的集合。结果是不被保障的。
 
 * @apiNote The characteristics of a given spliterator before splitting
 * may differ from the characteristics after splitting.  For specific
 * examples see the characteristic values {@link #SIZED}, {@link #SUBSIZED}
 * and {@link #CONCURRENT}.
 *
 * @return a representation of characteristics
 */
//特性值。
int characteristics();&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;hascharacteristics&quot;&gt;hasCharacteristics();&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * Returns {@code true} if this Spliterator's {@link
 * #characteristics} contain all of the given characteristics.
 *
 * @implSpec
 * The default implementation returns true if the corresponding bits
 * of the given characteristics are set.
 * 默认的话，包含 会返回true
 * @param characteristics the characteristics to check for
 * @return {@code true} if all the specified characteristics are present,
 * else {@code false}
 */
// 判断是否包含给定的特性值。  
default boolean hasCharacteristics(int characteristics) {
    return (characteristics() &amp;amp; characteristics) == characteristics;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;getcomparator&quot;&gt;getComparator（）；&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * If this Spliterator's source is {@link #SORTED} by a {@link Comparator},
 * returns that {@code Comparator}. If the source is {@code SORTED} in
 * {@linkplain Comparable natural order}, returns {@code null}.  Otherwise,
 * if the source is not {@code SORTED}, throws {@link IllegalStateException}.
 *
 * @implSpec
 * The default implementation always throws {@link IllegalStateException}.
 *
 * @return a Comparator, or {@code null} if the elements are sorted in the
 * natural order.
 * @throws IllegalStateException if the spliterator does not report
 *         a characteristic of {@code SORTED}.
 */
//有序的话 返回一个Null。 其他情况 抛异常
default Comparator&amp;lt;? super T&amp;gt; getComparator() {
    throw new IllegalStateException();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;immutable&quot;&gt;IMMUTABLE&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * Characteristic value signifying that the element source cannot be
 * structurally modified; that is, elements cannot be added, replaced, or
 * removed, so such changes cannot occur during traversal. A Spliterator
 * that does not report {@code IMMUTABLE} or {@code CONCURRENT} is expected
 * to have a documented policy (for example throwing
 * {@link ConcurrentModificationException}) concerning structural
 * interference detected during traversal.
 */
public static final int IMMUTABLE  = 0x00000400;   // 不能被修改的&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;concurrent&quot;&gt;CONCURRENT&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * Characteristic value signifying that the element source may be safely
 * concurrently modified (allowing additions, replacements, and/or removals)
 * by multiple threads without external synchronization. If so, the
 * Spliterator is expected to have a documented policy concerning the impact
 * of modifications during traversal.
 *
 * &amp;lt;p&amp;gt;A top-level Spliterator should not report both {@code CONCURRENT} and
 * {@code SIZED}, since the finite size, if known, may change if the source
 * is concurrently modified during traversal. Such a Spliterator is
 * inconsistent and no guarantees can be made about any computation using
 * that Spliterator. Sub-spliterators may report {@code SIZED} if the
 * sub-split size is known and additions or removals to the source are not
 * reflected when traversing.
 *
 * @apiNote Most concurrent collections maintain a consistency policy
 * guaranteeing accuracy with respect to elements present at the point of
 * Spliterator construction, but possibly not reflecting subsequent
 * additions or removals.
 */
public static final int CONCURRENT = 0x00001000;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;ofprimitive&quot;&gt;OfPrimitive&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * A Spliterator specialized for primitive values.
 *
 * @param &amp;lt;T&amp;gt; the type of elements returned by this Spliterator.  The
 * type must be a wrapper type for a primitive type, such as {@code Integer}
 * for the primitive {@code int} type.
 * @param &amp;lt;T_CONS&amp;gt; the type of primitive consumer.  The type must be a
 * primitive specialization of {@link java.util.function.Consumer} for
 * {@code T}, such as {@link java.util.function.IntConsumer} for
 * {@code Integer}.
 * @param &amp;lt;T_SPLITR&amp;gt; the type of primitive Spliterator.  The type must be
 * a primitive specialization of Spliterator for {@code T}, such as
 * {@link Spliterator.OfInt} for {@code Integer}.
 *
 * @see Spliterator.OfInt
 * @see Spliterator.OfLong
 * @see Spliterator.OfDouble
 * @since 1.8
 */
public interface OfPrimitive&amp;lt;T, T_CONS, T_SPLITR extends Spliterator.OfPrimitive&amp;lt;T, T_CONS, T_SPLITR&amp;gt;&amp;gt;
        extends Spliterator&amp;lt;T&amp;gt; {
    @Override
    T_SPLITR trySplit();

    /**
     * If a remaining element exists, performs the given action on it,
     * returning {@code true}; else returns {@code false}.  If this
     * Spliterator is {@link #ORDERED} the action is performed on the
     * next element in encounter order.  Exceptions thrown by the
     * action are relayed to the caller.
     *
     * @param action The action
     * @return {@code false} if no remaining elements existed
     * upon entry to this method, else {@code true}.
     * @throws NullPointerException if the specified action is null
     */
    @SuppressWarnings(&quot;overloads&quot;)
    boolean tryAdvance(T_CONS action);

    /**
     * Performs the given action for each remaining element, sequentially in
     * the current thread, until all elements have been processed or the
     * action throws an exception.  If this Spliterator is {@link #ORDERED},
     * actions are performed in encounter order.  Exceptions thrown by the
     * action are relayed to the caller.
     *
     * @implSpec
     * The default implementation repeatedly invokes {@link #tryAdvance}
     * until it returns {@code false}.  It should be overridden whenever
     * possible.
     *
     * @param action The action
     * @throws NullPointerException if the specified action is null
     */
    @SuppressWarnings(&quot;overloads&quot;)
    default void forEachRemaining(T_CONS action) {
        do { } while (tryAdvance(action));
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;ofint&quot;&gt;OfInt&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * A Spliterator specialized for {@code int} values.
 * @since 1.8
 */
public interface OfInt extends OfPrimitive&amp;lt;Integer, IntConsumer, OfInt&amp;gt; {

    @Override
    OfInt trySplit();

    @Override
    boolean tryAdvance(IntConsumer action);

    @Override
    default void forEachRemaining(IntConsumer action) {
        do { } while (tryAdvance(action));
    }

    /**
     * {@inheritDoc}
     * @implSpec
     * If the action is an instance of {@code IntConsumer} then it is cast
     * to {@code IntConsumer} and passed to
     * {@link #tryAdvance(java.util.function.IntConsumer)}; otherwise
     * the action is adapted to an instance of {@code IntConsumer}, by
     * boxing the argument of {@code IntConsumer}, and then passed to
     * {@link #tryAdvance(java.util.function.IntConsumer)}.
     */
    @Override
    default boolean tryAdvance(Consumer&amp;lt;? super Integer&amp;gt; action) {
        if (action instanceof IntConsumer) {
            return tryAdvance((IntConsumer) action);
        }
        else {
            if (Tripwire.ENABLED)
                Tripwire.trip(getClass(),
                              &quot;{0} calling Spliterator.OfInt.tryAdvance((IntConsumer) action::accept)&quot;);
            return tryAdvance((IntConsumer) action::accept);
        }
    }

    /**
     * {@inheritDoc}
     * @implSpec
     * If the action is an instance of {@code IntConsumer} then it is cast
     * to {@code IntConsumer} and passed to
     * {@link #forEachRemaining(java.util.function.IntConsumer)}; otherwise
     * the action is adapted to an instance of {@code IntConsumer}, by
     * boxing the argument of {@code IntConsumer}, and then passed to
     * {@link #forEachRemaining(java.util.function.IntConsumer)}.
     */
    @Override
    default void forEachRemaining(Consumer&amp;lt;? super Integer&amp;gt; action) {
        if (action instanceof IntConsumer) {
            forEachRemaining((IntConsumer) action);
        }
        else {
            if (Tripwire.ENABLED)
                Tripwire.trip(getClass(),
                              &quot;{0} calling Spliterator.OfInt.forEachRemaining((IntConsumer) action::accept)&quot;);
            forEachRemaining((IntConsumer) action::accept);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;IntConsumer 和 Consumer 是没有任何的关联关系 的。但是为什么能（IntConsumer）Consumer&lt;/p&gt;
&lt;p&gt;因为jdk自带装箱拆箱操作。 int 和 integer 重叠了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;流调用机制与原理大揭秘&quot;&gt;流调用机制与原理大揭秘。&lt;/h3&gt;
&lt;p&gt;流执行操作时，先整理把中间的操作整合，当调用终止操作的时候，对每个元素单个的进行所有的操作。操作中还带有短路操作。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;记录下来，然后给别人再讲，你就掌握了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;学完之后忘记了怎么办？记录下来。 笔记 博客。 死记硬背是没有任何用的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;referencepipeline&quot;&gt;ReferencePipeline&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * Abstract base class for an intermediate pipeline stage or pipeline source
 * stage implementing whose elements are of type {@code U}.
 */
//引用管道   
//ReferencePipeline  表示流的源阶段与中间阶段。
//ReferencePipeline.head表示流中的源阶段。
 abstract class ReferencePipeline&amp;lt;P_IN, P_OUT&amp;gt;
        extends AbstractPipeline&amp;lt;P_IN, P_OUT, Stream&amp;lt;P_OUT&amp;gt;&amp;gt;
        implements Stream&amp;lt;P_OUT&amp;gt;  {  
 }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;abstractpipeline&quot;&gt;AbstractPipeline&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * Abstract base class for &quot;pipeline&quot; classes, which are the core
 * implementations of the Stream interface and its primitive specializations.
 * Manages construction and evaluation of stream pipelines.
 *  
 * &amp;lt;p&amp;gt;An {@code AbstractPipeline} represents an initial portion of a stream
 * pipeline, encapsulating a stream source and zero or more intermediate
 * operations.  The individual {@code AbstractPipeline} objects are often
 * referred to as &amp;lt;em&amp;gt;stages&amp;lt;/em&amp;gt;, where each stage describes either the stream
 * source or an intermediate operation.
 流管道的初始的一部分。
 *
 * &amp;lt;p&amp;gt;A concrete intermediate stage is generally built from an
 * {@code AbstractPipeline}, a shape-specific pipeline class which extends it
 * (e.g., {@code IntPipeline}) which is also abstract, and an operation-specific
 * concrete class which extends that.  {@code AbstractPipeline} contains most of
 * the mechanics of evaluating the pipeline, and implements methods that will be
 * used by the operation; the shape-specific classes add helper methods for
 * dealing with collection of results into the appropriate shape-specific
 * containers.
 *避免自动拆箱和装箱操作。
 * &amp;lt;p&amp;gt;After chaining a new intermediate operation, or executing a terminal
 * operation, the stream is considered to be consumed, and no more intermediate
 * or terminal operations are permitted on this stream instance.
 * 当链接完一个新的中间操作或者执行了终止操作之后， 这个流被认为被消费了。不允许再被操作了。
 * @implNote
 * &amp;lt;p&amp;gt;For sequential streams, and parallel streams without
 * &amp;lt;a href=&quot;package-summary.html#StreamOps&quot;&amp;gt;stateful intermediate
 * operations&amp;lt;/a&amp;gt;, parallel streams, pipeline evaluation is done in a single
 * pass that &quot;jams&quot; all the operations together.  For parallel streams with
 * stateful operations, execution is divided into segments, where each
 * stateful operations marks the end of a segment, and each segment is
 * evaluated separately and the result used as the input to the next
 * segment.  In all cases, the source data is not consumed until a terminal
 * operation begins.
  只有终止操作开始的时候，源数据才会被消费。
 * @param &amp;lt;E_IN&amp;gt;  type of input elements
 * @param &amp;lt;E_OUT&amp;gt; type of output elements
 * @param &amp;lt;S&amp;gt; type of the subclass implementing {@code BaseStream}
 * @since 1.8
 */
abstract class AbstractPipeline&amp;lt;E_IN, E_OUT, S extends BaseStream&amp;lt;E_OUT, S&amp;gt;&amp;gt;
        extends PipelineHelper&amp;lt;E_OUT&amp;gt; implements BaseStream&amp;lt;E_OUT, S&amp;gt; {
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;内部类和lambda表达式之间的关系&quot;&gt;内部类，和lambda表达式之间的关系。&lt;/h4&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;本质上 内部类和lambda不是一回事。只是能完成相同的操作。&lt;/p&gt;
&lt;p&gt;lambda不是匿名内部类的语法糖，或者说是缩写。是一种新的形式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class LambdaTest {
    //内部类，和lambda表达式之间的关系。
    Runnable r1 = () -&amp;gt; System.out.println(this); // this表示当前类的对象

    //匿名内部类
    Runnable r2 = new Runnable() {  //
        @Override
        public void run() {
            System.out.println(this);
            // this 表示匿名内部类的对象
        }
    };


    public static void main(String[] args) {
        LambdaTest lambdaTest = new LambdaTest();

        Thread t1 = new Thread(lambdaTest.r1);
        t1.start();

        System.out.println(&quot;- - -- - &quot;);

        Thread t2 = new Thread(lambdaTest.r2);
        t2.start();
        //输出结果。
        //com.sinosoft.lis.test.LambdaTest@62661526
        //com.sinosoft.lis.test.LambdaTest$1@59a30351
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用了&lt;strong&gt;模板方法模式。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;流是惰性的，是延迟操作的。遇到终止操作时，才会执行操作。&lt;/p&gt;
&lt;p&gt;TerminalOp。 终止操作的接口类。&lt;/p&gt;
&lt;p&gt;终止操作 只有四种类型， findOp foreachOp matchOp reduceOp&lt;/p&gt;
&lt;p&gt;PipelineHelper&lt;/p&gt;
&lt;h3 id=&quot;stream中间操作与终止操作层次体系分析与设计思想分析&quot;&gt;stream中间操作与终止操作层次体系分析与设计思想分析&lt;/h3&gt;
&lt;h4 id=&quot;中间操作&quot;&gt;中间操作&lt;/h4&gt;
&lt;p&gt;BaseStream -》 AbStractpipeline -》ReferencePipeline -》 Head || StatelessOP || statefulOp&lt;/p&gt;
&lt;p&gt;最顶层的源 很多源的成员变量 管道 构造流源 无状态的中间操作 有状态的中间操作&lt;/p&gt;
&lt;p&gt;流是惰性的，是延迟操作的。遇到终止操作时，才会执行操作。再没有终止操作之前，在整合中间操作（Sink）。&lt;/p&gt;
&lt;h4 id=&quot;终止操作&quot;&gt;终止操作&lt;/h4&gt;
&lt;p&gt;TerminalOp -》 FindOp || ForeachOp || MatchOp || reduceOp&lt;/p&gt;
&lt;p&gt;最顶层的&lt;/p&gt;
&lt;p&gt;TerminalSink&lt;/p&gt;
&lt;p&gt;终止的饮水槽。&lt;/p&gt;

&lt;h2 id=&quot;joda-time&quot;&gt;joda-time&lt;/h2&gt;
&lt;p&gt;在开始学习jdk8.time之前，先接触一下joda-time。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void main(String[] args) {
    // 基本使用方式.
    DateTime today = new DateTime();
    DateTime dateTime = today.plusDays(1);
    //今天
    System.out.println(today.toString(&quot;yyyy-MM-dd&quot;));
    //明天
    System.out.println(dateTime.toString(&quot;yyyy-MM-dd&quot;));
    System.out.println(&quot;- - - - -&quot;);
    //当月的第一天
    DateTime dateTime1 = today.withDayOfMonth(1);
    System.out.println(dateTime1.toString(&quot;yyyy-MM-dd&quot;));
    // 当前时间后边三个月的第后一天的日期
    LocalDate localDate = new LocalDate();
    localDate = localDate.plusMonths(3).dayOfMonth().withMaximumValue();
    System.out.println(localDate);
    // 当前时间后边三个月的第一天的日期
    localDate = localDate.plusMonths(3).dayOfMonth().withMinimumValue();
    System.out.println(localDate);
    //计算两年前的第三个月的最后一天的时期
    DateTime localDate1 = new DateTime();
    localDate1.minusYears(2).monthOfYear().setCopy(3).dayOfMonth().withMaximumValue();
    System.out.println(localDate1);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;example：&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class JodaTest2 {
    // 标准UTC时间. 转换成日期类型  2014-11-11T02:22:22.222z

    public static Date to2c(String date) {
        //服务器端转换成客户端的时间
        DateTime parse = DateTime.parse(date, DateTimeFormat.forPattern(&quot;yyyy-MM-dd'T'HH:mm:ss.SSSZ&quot;));
        return parse.toDate();
    }

    public static String toString(Date date) {
//        客户端的时间转成服务器的时间
        DateTime date1 = new DateTime(date, DateTimeZone.UTC);
        return date1.toString();
    }

    public static String date2String(Date date,String dateFort) {
        DateTime dateTime = new DateTime(date);
        return dateTime.toString(dateFort);
    }

    public static void main(String[] args) {
        System.out.println(JodaTest2.to2c(&quot;2014-11-11T02:22:22.222z&quot;));
        System.out.println(JodaTest2.toString(new Date()));  // 标准的时间为 差8个小时
        System.out.println(JodaTest2.date2String(new Date(),&quot;yyyy-MM-dd&quot;));

    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;java中日期时间的api&quot;&gt;Java中日期时间的api&lt;/h2&gt;
&lt;p&gt;Java8中的所有时间都是不可变的，确保了线程安全。&lt;/p&gt;
&lt;p&gt;没有必要去研究源代码。会用就可以了。省下时间去学习更重要，更有价值的事情上。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;{
    public static void main(String[] args) {
        LocalDate localDate = LocalDate.now();
        System.out.println(localDate);
        //获取年
        System.out.println(localDate.getYear());
        //获取月
        System.out.println(localDate.getMonthValue());

        //根据年月日构造
        LocalDate localDate1 = LocalDate.of(2030, 3, 22);
        System.out.println(localDate1);

        //根据是时分秒构造
        LocalDate localDate2 = LocalDate.of(2020,3,25);
        MonthDay monthDay = MonthDay.of(localDate2.getMonth(), localDate2.getDayOfMonth());

        //根据是时分秒构造
        LocalTime localTime = LocalTime.now();
        System.out.println(localTime);

        // + 20分钟, -2个小时
        LocalTime localTime1 = localTime.plusMinutes(20).minusHours(2);
        System.out.println(localTime1);

        System.out.println(&quot;- - - - -&quot;);

        //现在的时间增加两周                                    (增加的长度,增加的单位)
        LocalDate localDate3 = LocalDate.now().plus(2, ChronoUnit.WEEKS);
        System.out.println(localDate3);

        //现在的时间减两周
        LocalDate localDate4 = localDate.minus(2, ChronoUnit.MONTHS);
        System.out.println(localDate4);

        // Clock对象
        Clock clock = Clock.systemDefaultZone();
        System.out.println(clock);

        // 两个日期进行的判断
        LocalDate localDate5 = LocalDate.now();
        LocalDate localDate6 = LocalDate.of(2020,1,21);
        System.out.println(localDate5.isBefore(localDate6));
        System.out.println(localDate5.isAfter(localDate6));
        System.out.println(localDate5.equals(localDate6));

        //关于时区的概念.
        Set&amp;lt;String&amp;gt; availableZoneIds = ZoneId.getAvailableZoneIds();
        availableZoneIds.forEach(System.out::println);

        //将上边的无序的时区set进行排序
        Set treeSet = new TreeSet&amp;lt;String&amp;gt;(){
            {addAll(availableZoneIds);}
        };
        treeSet.stream().forEach(System.out::println);

        //使用时区做一些例子.
        ZoneId zoneId = ZoneId.of(&quot;Asia/Shanghai&quot;);
        LocalDateTime localDateTime = LocalDateTime.now();
        System.out.println(localDateTime);

        ZonedDateTime zonedDateTime = ZonedDateTime.of(localDateTime, zoneId);
        System.out.println(zonedDateTime);

        System.out.println(&quot;- - -- - -&quot;);

         // 年月的对象
        YearMonth yearMonth = YearMonth.now();
        System.out.println(yearMonth);
        System.out.println(yearMonth.lengthOfMonth());
        System.out.println(yearMonth.isLeapYear());

        YearMonth yearMonth1 = YearMonth.of(2019, 2);
        System.out.println(yearMonth1);
        System.out.println(yearMonth1.lengthOfMonth());
        System.out.println(yearMonth1.lengthOfYear());
        System.out.println(yearMonth1.isLeapYear()); // 是否闰年

        LocalDate localDate7 = LocalDate.now();
        LocalDate localDate8 = LocalDate.of(2017, 3, 22);
        // Period 周期性的.. 比较两个年份的差别
        Period period = Period.between(localDate7, localDate8); //
        System.out.println(period);
        System.out.println(period.getDays());

        System.out.println(&quot;- - -- - - &quot;);
        // Instant  获取不带时区的UTC的标准时间.
        System.out.println(Instant.now());

        //,,,  剩下的用到的使用自行Google

    }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;java8的回顾和复盘&quot;&gt;Java8的回顾和复盘&lt;/h2&gt;
&lt;p&gt;总共50节课，从开始到结束。学习到的不止是技术，更多的是学习方法。&lt;/p&gt;
&lt;p&gt;系统的学习jdk8&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Java 8新特性介绍&lt;/li&gt;
&lt;li&gt;Lambda表达式介绍&lt;/li&gt;
&lt;li&gt;使用Lambda表达式代替匿名内部类&lt;/li&gt;
&lt;li&gt;Lambda表达式的作用&lt;/li&gt;
&lt;li&gt;外部迭代与内部迭代&lt;/li&gt;
&lt;li&gt;Java Lambda表达式语法详解&lt;/li&gt;
&lt;li&gt;函数式接口详解&lt;/li&gt;
&lt;li&gt;传递值与传递行为&lt;/li&gt;
&lt;li&gt;Stream深度解析&lt;/li&gt;
&lt;li&gt;Stream API详解&lt;/li&gt;
&lt;li&gt;串行流与并行流&lt;/li&gt;
&lt;li&gt;Stream构成&lt;/li&gt;
&lt;li&gt;Stream源生成方式&lt;/li&gt;
&lt;li&gt;Stream操作类型&lt;/li&gt;
&lt;li&gt;Stream转换&lt;/li&gt;
&lt;li&gt;Optional详解&lt;/li&gt;
&lt;li&gt;默认方法详解&lt;/li&gt;
&lt;li&gt;方法与构造方法引用&lt;/li&gt;
&lt;li&gt;Predicate接口详解&lt;/li&gt;
&lt;li&gt;Function接口详解&lt;/li&gt;
&lt;li&gt;Consumer接口剖析&lt;/li&gt;
&lt;li&gt;Filter介绍&lt;/li&gt;
&lt;li&gt;Map-Reduce讲解、中间操作与终止操作&lt;/li&gt;
&lt;li&gt;新的Date API分析&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;更多的时间是了解底层是怎么实现的。&lt;/p&gt;
&lt;h2 id=&quot;基础的重要性&quot;&gt;基础的重要性&lt;/h2&gt;
&lt;p&gt;2020年02月07日12:03:41 将Java8学习的笔记给整理到了一个文件当中，方便整理。&lt;/p&gt;
</description>
<pubDate>Sat, 15 Feb 2020 23:54:00 +0000</pubDate>
<dc:creator>我不是铁杆啊</dc:creator>
<og:description>Java8（1）新特性介绍及Lambda表达式 前言： 跟大娃一块看，把原来的电脑拿出来放中间看视频用 以后会有的课程 难度 1. 深入Java 8 难度1 2. 并发与netty 难度3 3. JV</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wobushitiegan/p/12315653.html</dc:identifier>
</item>
<item>
<title>MySQL - 萌萌哥的春天</title>
<link>http://www.cnblogs.com/mh20131118/p/11830097.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mh20131118/p/11830097.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;一：概述&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;    &lt;span&gt;一、数据库系统&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;       1. 数据库&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;           1. 概念：&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;数据库是“按照数据结构来组织、存储和管理数据的仓库”，是一个长期存储在计算机内的、有组织的、有共享的、统一管理的数据集合。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;           2. 类型&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;               1. 关系型数据库(SQL)：数据存储的格式可以直观地反映实体间的关系。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;               2. 非关型数据库(NoSQL)：分布式的、非关系型的、不保证遵循&lt;a href=&quot;https://baike.baidu.com/item/ACID/10738&quot; target=&quot;_blank&quot; data-lemmaid=&quot;10738&quot;&gt;ACID&lt;/a&gt;原则的数据存储系统。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;               3. 两者区别&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;                   1. 存储方式不同&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;                       1. &lt;span&gt;&lt;span&gt;&lt;span&gt;SQL&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;数据储在数据表的行和列。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;                       2. &lt;span&gt;&lt;span&gt;&lt;span&gt;NoSQL&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;数据存储在数据集中，像文档、键值对或者图结构。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;                   2. 扩展方式不同&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;                       1. &lt;span&gt;&lt;span&gt;&lt;span&gt;SQL&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;数据库的高并发量比较依赖计算机性能。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;                       2. &lt;span&gt;&lt;span&gt;&lt;span&gt;NoSQL&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;数据库是分布式的，可以通过给资源池添加更多普通的数据库服务器(节点)来分担负载，性能更好。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;                   3. 事务支持不同&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;                       1. SQL数据库支持对事务原子性细粒度控制，并且易于回滚事务。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;                       2. &lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;NoSQL数据库&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;操作的扩展性和大数据量处理方面优势更好。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;       2. 数据库管理系统&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;           1. &lt;span&gt;概念：&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;数据库管理系统(Database Management System)是一种操纵和管理数据库的大型软件，用于建立、使用和维护数据库。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;           2. 功能&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;               1. 数据定义：DBMS提供数据定义语言（Data Definition Language，简称DDL），供用户定义数据库的三级模式结构、两级映像以及完整性约束和保密限制等约束。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;               2. 数据操作：DBMS提供数据操作语言（Data Manipulation Language，简称DML），供用户实现对数据的追加、删除、更新、查询等操作。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;               3. 维护管理：数据库系统的安全，保证事务的原子性。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;         &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;       3. &lt;span&gt;&lt;span&gt;&lt;span&gt;SQL&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;语言&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;           1. 概念：&lt;span&gt;SQL（Structured Query Language，结构化查询语言），用于存取数据以及查询、更新和管理关系数据库系统。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;           2. 组成&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;               1. 数据定义语言（DDL）：DROP、CREATE、ALTER 等语句&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;               2. 数据操作语言（DML）：INSERT（插入）、UPDATE（修改）、DELETE（删除）语句。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;               3. 数据查询语言（DQL）：SELECT 语句。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;               4. 数据控制语言（DCL）: GRANT、REVOKE、COMMIT、ROLLBACK 等语句。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;    二、MySQL&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       1. 概念：&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;Mysql是目前WEB应用最好的RDBMS（Relation Database Mangement System)关系数据库管理系统之一。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;       2. 特点&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;           1. 支持多种操作系统，为多种编程语言提供API。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;           2. 支持多种存储引擎。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;           3. 提供 TCP/IP、ODBC 和 JDBC 等多种数据库连接途径。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;       3. 存储引擎&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;           1.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;MyISAM：MySQL 5.0 之前的默认引擎，拥有较高的插入，查询速度，但不支持事务。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;           2. &lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;InnoDB：&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;MySQL 5.5之后的默认引擎，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;事务型数据库的首选，支持ACID事务，支持行级锁定。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;           3. BDB：源自Berkeley DB，支持Commit 和Rollback 等其他事务特性。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;           4. Federated：将不同的 MySQL 服务器联合起来，逻辑上组成一个完整的数据库，常适合分布式应用。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;           5. Cluster/NDB：高冗余的存储引擎，用多台数据机器联合提供服务以提高整体性能和安全性。适合数据量大，安全和性能要求高的应用。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;       4. 架构&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;            &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1610676/202002/1610676-20200213233453826-618252129.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;           1. Client：提供连接MySQL服务器功能的常用工具集。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;           2. Server：真正提供数据存储和数据处理功能的MySQL服务器进程。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;           3. mysqld：mysqld是一个多线程的守护进程，允许多个会话连接，端口监听连接。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;           4. MySQL memory allocation：动态内存空间&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;           5. SESSION：为每个客户端连接分配一个会话，动态分配和回收。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;           6. Parser：用户认证和为每条SQL语句生成&lt;code&gt;SQL_ID&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;           7. Optimizer：用户权限检查。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;       4. 数据结构&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;           1. 数值类型&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;               &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1610676/202002/1610676-20200214131946817-2048729983.png&quot; alt=&quot;&quot; width=&quot;700&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;                 &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1610676/202002/1610676-20200214132023692-1513342211.png&quot; alt=&quot;&quot; width=&quot;700&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;           2. 字符串类型&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;                &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1610676/202002/1610676-20200214132100418-698007794.png&quot; alt=&quot;&quot; width=&quot;700&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;           3. 时间日期类型&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;                &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1610676/202002/1610676-20200214132133802-363001190.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;       5. 下载安装 &lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;            1. &lt;a href=&quot;https://dev.mysql.com/downloads/windows/installer/&quot; target=&quot;_blank&quot;&gt;下载&lt;/a&gt;(安装版)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;                &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1610676/202002/1610676-20200214125202487-727936535.png&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;            2. 安装&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;                1. 接受&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;                     &lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1610676/202002/1610676-20200214125323109-2134408434.png&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;                2. 自定义安装&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;                     &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1610676/202002/1610676-20200214125541751-1044577264.png&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;                3. 安装服务&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;                     &lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1610676/202002/1610676-20200214125631136-696644943.png&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;                     &lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;接下来一路默认next，直到遇到设置密码&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;                4. 设置密码（&lt;span&gt;最重要&lt;/span&gt;）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;                    &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1610676/202002/1610676-20200214125944113-50324004.png&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;                      &lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;接下来一路默认next&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;，就可安装完成&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;                5. 配置环境变量(&lt;span&gt;安装bin目录路径&lt;/span&gt;)&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;                     &lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1610676/202002/1610676-20200214130241418-241328350.png&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;                6. 测试&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;                    1. 本地登录：&lt;span&gt;mysql -uroot -p密码&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;                    2. 远程登录：&lt;span&gt;mysql -hIP -P端口 -u用户民 -p密码&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;                    &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1610676/202002/1610676-20200214130543678-1212224606.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;二：基本应用&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;    一、&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;数据定义语言（DDL）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;           &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1610676/202002/1610676-20200214135510277-1166123340.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;       1. 操作数据库&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;           &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1610676/202002/1610676-20200214195401410-1997653248.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;       2. 操作数据表&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;           &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1610676/202002/1610676-20200214205157219-672806738.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;    二、&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;数据操作语言（DML）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;            &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1610676/202002/1610676-20200214142703055-242293189.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;             &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1610676/202002/1610676-20200214212435417-1149654250.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;    三、&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;数据查询语言（DQL）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;           &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1610676/202002/1610676-20200214161553104-787314105.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;       1. 单表&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;           1. 条件查询&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;               1. 条件判断&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;                   &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1610676/202002/1610676-20200214214135973-720923544.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;               2. 逻辑判断&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;                   &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1610676/202002/1610676-20200214214843525-1578466060.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;               3. 范围查找&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;                    &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1610676/202002/1610676-20200214215539839-333336416.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;               4. 模糊查找&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;                    &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1610676/202002/1610676-20200214220417862-314816213.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;           2. 分组&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;               &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1610676/202002/1610676-20200214221623931-2014689763.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;           3. 排序&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;                &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1610676/202002/1610676-20200214222208624-1072223981.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;           4. 分页&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;                &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1610676/202002/1610676-20200214232040793-920423895.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;       2. 多表&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;           1. 表与表之间的关系&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;               1. 一对一：唯一外键对应/主键对应&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;               2. 一对多：多方创建外键对应一方的主键&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;               3. 多对多：创建中间表，至少有两个字段分别作为外键指向多对多双方的主键。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;           2. 连接查询&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;               1. &lt;span&gt;&lt;span&gt;方言：过滤的笛卡尔积&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;                   &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1610676/202002/1610676-20200214234734652-1346826782.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;               2. &lt;span&gt;&lt;span&gt;自然连接：属性相同的元组对&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;                    &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1610676/202002/1610676-20200214235941011-510115930.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;               3. 内连接：等值连接&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;                   &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1610676/202002/1610676-20200215000400727-521485115.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;               4. 外连接：注意空值&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;                   &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1610676/202002/1610676-20200215000725893-1268887576.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;           2. 子查询：嵌套查询（select中包含select）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;                  &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1610676/202002/1610676-20200215020213181-619507868.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;    四、&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;数据控制语言（DCL）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;             &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1610676/202002/1610676-20200216010401886-128738071.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;            &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1610676/202002/1610676-20200216010325682-321827297.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;    五、完整性约束&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;       1. 作用：DBMS自动按照一定的约束条件对数据进行监测，防止不符合规范的数据进入数据库，以确保数据库中存储的数据正确、有效、相容。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;       2. 实体完整性&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;           1. 概念：&lt;span&gt;&lt;span&gt;主键的值不能为空或部分为空的约束条件称为实体完整性。&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;           2. 作用：表示每一行数据不重复。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;           3. 分类&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;               1. 主键约束（PRIMARY KEY)：&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;指定该列的值可以唯一地标识该列记录&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;且不能为空&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;                    &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1610676/202002/1610676-20200214180428782-553939274.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;               2. 唯一约束（UNIQUE）：&lt;span&gt;&lt;span&gt;&lt;span&gt;指定某列或者几列组合不能重复&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;                    &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1610676/202002/1610676-20200214181018450-527419694.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;               3. 自动增长列（AUTO-INCREMENT)：主键自增&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;                    &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1610676/202002/1610676-20200214181210182-2111974655.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;       3.&lt;/span&gt; 域完整性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;           1. 概念：域完整性指列的值域的完整性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;           2. 作用：保证表中某些列不能输入无效的值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;           3. 分类&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;               1. 非空约束（NOT NULL）：&lt;span&gt;&lt;span&gt;&lt;span&gt;指定某列不能为空&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;               2. 默认约束（DEFAULT）：设置默认值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;               &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1610676/202002/1610676-20200214181958142-329513949.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;       4. 参照完整性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;           1. 概念：外键约用来在两个表之间建立连接，一对多关系中一方的主键。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;           2. 作用：保持数据的一致性，完整性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;               &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1610676/202002/1610676-20200214183054481-610656671.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; &lt;span&gt;&lt;strong&gt;&lt;span&gt;    六、视图&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;        1. 概念：视图是从一个或多个表中导出的一个虚拟表，用户对视图的&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;各种操作都不会影响源数据，&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;保障数据库系统的安全&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;        2. 作用：简化用户对数据的操作，屏蔽真实表结构变化的影响，保护数据库数据安全。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;        3. 使用&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;             &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1610676/202002/1610676-20200215151539306-1426120698.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;            &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1610676/202002/1610676-20200215153154083-2060660376.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;三：高级应用&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;    一、存储过程&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       1. 概述&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;           1. 概念：存储过程（Stored Procedure）是&lt;span&gt;经编译后存储在数据库中&lt;/span&gt;的一组特定功能的SQL语句集，用户通过存储过程的名字和给定参数来调用并执行它。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;           2. 组成：SQL语句和控制结构组成，是一个可编程的函数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       2. 特点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;           1. 增强SQL语言的功能和灵活性：&lt;span&gt;存储过程可以用控制语句编写，有很强的灵活性，可以完成复杂的判断和较复杂的运算。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;           2. 标准组件式编程：&lt;span&gt;存储过程被创建后，可以在程序中被多次调用，而不必重新编写该存储过程的SQL语句。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;           3. 较快的执行速度：&lt;span&gt;如果某一操作包含大量的Transaction-SQL代码或分别被多次执行，那么存储过程（预编译）要比批处理的执行速度快很多。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;           4. 作为一种安全机制来充分利用：&lt;span&gt;通过对执行某一存储过程的权限进行限制，避免非授权用户对数据的访问，保证了数据的安全。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       3. 使用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;           &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1610676/202002/1610676-20200215165207158-827683884.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;           1. 参数传递&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1610676/202002/1610676-20200215174228747-1863149469.png&quot; alt=&quot;&quot;/&gt;  &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1610676/202002/1610676-20200215174303909-321286359.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1610676/202002/1610676-20200215174334571-1156968903.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;           2. 变量使用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1610676/202002/1610676-20200215190758312-34107901.png&quot; alt=&quot;&quot;/&gt;   &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1610676/202002/1610676-20200215190957161-5477269.png&quot; alt=&quot;&quot;/&gt;   &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1610676/202002/1610676-20200215191025108-1275481193.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;           3. 结构控制语句&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;               1. 判断&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                   &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1610676/202002/1610676-20200215193920609-1435642863.png&quot; alt=&quot;&quot;/&gt;      &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1610676/202002/1610676-20200215194032762-1983385933.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;               2. 循环&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;                      &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1610676/202002/1610676-20200215195702214-1781045206.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1610676/202002/1610676-20200215195552842-5152866.png&quot; alt=&quot;&quot;/&gt;  &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1610676/202002/1610676-20200215195612711-1932465525.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;    二、函数&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       1. 内置函数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;           1. 数学函数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;               &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1610676/202002/1610676-20200215202313651-41229685.png&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;           2. 字符串函数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;               &lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1610676/202002/1610676-20200215202227672-2101225007.png&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;           3. 日期函数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1610676/202002/1610676-20200215202256647-1424800287.png&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;       2. 聚合函数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;            &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1610676/202002/1610676-20200215203948178-950397078.png&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;       3. 自定义函数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;            &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1610676/202002/1610676-20200215205222129-1940057219.png&quot; alt=&quot;&quot;/&gt;     &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1610676/202002/1610676-20200215205245116-777487193.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;    三、触发器&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       1. 概念： &lt;span&gt;触发器是在表中数据发生&lt;span&gt;更改&lt;/span&gt;时自动触发执行的特殊的存储过程。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       2. 作用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;           1. 安全性：可以基于数据库的值使用户具有操作数据库的某种权利。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;           2. 审计：可以跟踪用户对数据库的操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;           3. 实现复杂的非标准的数据库相关完整性规则：触发器可以对数据库中相关的表进行连环更新。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;           4. 同步实时地复制表中的数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;           5. 自动计算数据值，如果数据的值达到了一定的要求，则进行特定的处理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       3. 弊端&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;           1. 增加程序的复杂度：有些业务逻辑在代码中处理，有些业务逻辑用触发器处理，会使后期维护变得困难。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;           2. 如果需要变动整个数据集而数据集数据量又较大时，触发器效果会非常低。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;           3. 对于批量操作并不适合使用触发器，使用触发器实现的业务逻辑在出现问题时很难进行定位。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       4. 使用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;           &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1610676/202002/1610676-20200215234104098-2048133282.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;            &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1610676/202002/1610676-20200215235341220-1219753071.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;    五、索引&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       1. 概念：索引是对数据库表中一个或多个列的值进行排序的结构，加快检索表中数据的方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       2. 特点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;           1. 优点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;               1. 加快数据的查询速度。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;               2. 建立索引的列可以保证行的唯一性，生成唯一的rowId。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;           2. 缺点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;               1. 创建索引和维护索引要耗费时间，并且随着数据量的增加所耗费的时间也会增加。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;               2. 当对表中的数据进行更改时，索引也需要动态的维护，降低了数据的维护速度。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;               3. 创建索引和维护索引需要空间成本，每一条索引都要占据数据库的物理存储空间，数据量越大，占用空间也越大。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       3. 数据结构(没深挖)&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1610676/202002/1610676-20200216011755960-258859163.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;           1. B+树性质&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;               1. 索引字段要尽量的小&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;               2. 索引的最左匹配特性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;           2. 聚集索引：按照每张表的主键构造一个B+树&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;               &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1610676/202002/1610676-20200216011745284-161106053.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt;       4. 使用原则&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;           1. 为经常需要排序、分组和联合操作的字段建立索引。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;           2. 对经常更新的和数据量小的表要避免对其进行过多的索引。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;           3. 限制索引的数目，尽量的扩展索引，不要新建索引。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       5. 分类&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;           1. 普通索引：加速查询&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;           2. 唯一索引：加速查询和唯一约束(可含NULL)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;           3. 主键索引：加速查询和唯一非空约束&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;           4. 全文索引：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       5. 使用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;           &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1610676/202002/1610676-20200216020347669-1927024585.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 15 Feb 2020 18:08:00 +0000</pubDate>
<dc:creator>萌萌哥的春天</dc:creator>
<og:description>一：概述 一、数据库系统 1. 数据库 1. 概念：数据库是“按照数据结构来组织、存储和管理数据的仓库”，是一个长期存储在计算机内的、有组织的、有共享的、统一管理的数据集合。 2. 类型 1. 关系型</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mh20131118/p/11830097.html</dc:identifier>
</item>
<item>
<title> .NET异步程序设计之任务并行库 - shanzm</title>
<link>http://www.cnblogs.com/shanzhiming/p/12315548.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shanzhiming/p/12315548.html</guid>
<description>&lt;p&gt;shanzm-2020年2月16日 00:45:04&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;简介&quot;&gt;1.简介&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;System.Threading.Tasks&lt;/code&gt;中的类型被称为&lt;strong&gt;任务并行库&lt;/strong&gt;（Task Parallel Library，&lt;strong&gt;TPL&lt;/strong&gt;）。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;System.Thread.Tasks&lt;/code&gt; 命名空间是.NET Framework4.0所提供，&lt;/p&gt;
&lt;p&gt;“TPL使用CLR线程池自动将应用程序的工作动态分配到可用的CPU中。TPL还处理工作分区、线程调度、状态管理和其他低级别的细节操作。最终结果是，你可以最大限度地提升.NET应用程序的性能，并且避免直接操作线程所带来的复杂性” --《精通C#》&lt;/p&gt;

&lt;hr/&gt;&lt;h2 id=&quot;parallel类&quot;&gt;2.Parallel类&lt;/h2&gt;

&lt;h3 id=&quot;parallel类简介&quot;&gt;2.0 Parallel类简介&lt;/h3&gt;
&lt;p&gt;在&lt;code&gt;System.Threading.Tasks&lt;/code&gt;命名空间下有一个静态类：Parallel类&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Parallel可以实现对实现了IEnumerable接口的数据集合的每一个元素并行操作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有一点要说明的：并行操作会带来一定的成本，如果任务本身能很快完成，或是循环次数很少，那么并行处理的速度也许会比非并行处理还慢。&lt;/p&gt;
&lt;p&gt;Parallel类就只有有三个方法：&lt;code&gt;Parallel.For()&lt;/code&gt;、&lt;code&gt;Parallel.ForEach()&lt;/code&gt;和&lt;code&gt;Parallel.Invoke()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;但是呢，这每个方法都有大量的重载（F12--&amp;gt;自行查看Parallel定义）&lt;/p&gt;

&lt;h3 id=&quot;parallel.for&quot;&gt;2.1 Parallel.For()&lt;/h3&gt;
&lt;p&gt;使用&lt;code&gt;Parallel.For()&lt;/code&gt;可以对数组中的每一个元素进行&lt;strong&gt;并行操作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;正常的遍历数组是按照索引的顺序执行的,但是并行操作，对数组的每一个元素的操作不一定按照索引顺序操作&lt;/p&gt;
&lt;p&gt;Parallel.For(),第一个参数是循环开始的索引（包含），第二个参数是循环结束的索引（不含）&lt;/p&gt;
&lt;p&gt;Parallel.For()的第三个参数是一个有参数无返回值的委托，其参数是数组的索引&lt;/p&gt;
&lt;p&gt;其实就相当于：&lt;code&gt;for (int i = 0; i &amp;lt; length; i++)&lt;/code&gt;的异步版本,只是在这里是并行操作，所以并不按照数组中元素的顺序执行，&lt;strong&gt;具体的执行顺序是不可控的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;示例&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;static void Main(string[] args)
{
    int[] intArray = new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
    Console.WriteLine(&quot;------------常规，对数组进行循环遍历------------&quot;);
    Array.ForEach(intArray, n =&amp;gt; Console.WriteLine($&quot;当前操作的数组元素是{n}&quot;));//注意这里的参数n是元素而不是索引
    
    Console.WriteLine(&quot;------------并行操作 对数组进行循环遍历------------&quot;);
    
    Parallel.For(0, intArray.Length, (i) =&amp;gt; Console.WriteLine($&quot;当前循环次数{i},当前操作的数组元素是{intArray[i]}&quot;));
    Console.ReadKey();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：可以看出，对数组的元素的操作顺序并不是按照索引的顺序，而是不确定的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1576687/202002/1576687-20200216004628741-27385087.png&quot; alt=&quot;Parallel.For&quot;/&gt;&lt;/p&gt;

&lt;h3 id=&quot;parallel.foreach&quot;&gt;2.2 Parallel.ForEach()&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Parallel.ForEach()&lt;/code&gt;用于对泛型可枚举对象的元素进行&lt;strong&gt;并行操作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其实就相当于：&lt;code&gt;foreach (var item in collection)&lt;/code&gt;的异步版本&lt;/p&gt;
&lt;p&gt;Parallel.ForEach()有大量的重载，这里展示一个简单的操作&lt;/p&gt;
&lt;p&gt;Parallel.ForEach()的第一个参数是待操作的可枚举对象，第二个参数是一个有参数无返回值的委托，&lt;strong&gt;该委托参数是集合的元素（而不是索引）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;示例&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;List&amp;lt;int&amp;gt; intList = new List&amp;lt;int&amp;gt;() { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
Parallel.ForEach(intList, n =&amp;gt; Console.WriteLine(n+100));
Console.ReadKey();&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;parallel.invoke&quot;&gt;2.3 Parallel.Invoke()&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Parallel.Invoke()&lt;/code&gt;对指定一系列操作并行运算&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数是一个Action委托数组(注意只能是Action[],即只能是无返回值的委托数组)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Parallel.Invoke()最常见用于并发请求接口&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;static void Main(string[] args)
{
     Action action1=() =&amp;gt;
     {
         for (int i = 0; i &amp;lt; 5; i++)
         {
             Console.WriteLine($&quot;action-1-操作&quot;);
         }
     };

     Action action2 = () =&amp;gt;
     {
         for (int i = 0; i &amp;lt; 5; i++)
         {
             Console.WriteLine($&quot;action-2-操作&quot;);
         }
     };
     //Parallel.Invoke(action1, action2);
     Action[] actions = { action1, action2 };
     Parallel.Invoke(actions);
     Console.ReadKey();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1576687/202002/1576687-20200216004815076-747809945.png&quot; alt=&quot;Parallel.Invoke&quot;/&gt;&lt;/p&gt;

&lt;h3 id=&quot;补充线程安全集合&quot;&gt;2.4 补充：线程安全集合&lt;/h3&gt;
&lt;p&gt;详细可以参考微软的在线&lt;a href=&quot;https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.generic?view=netframework-4.8&quot;&gt;文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;多线程对同一个数据集合同时读写操作，可能会造成数据的混乱&lt;/p&gt;
&lt;p&gt;.NET4 引入了&lt;code&gt;System.Collections.Concurrent&lt;/code&gt; 命名空间，其中包含多个线程安全的数据集合类型。&lt;/p&gt;
&lt;p&gt;现在的新项目中，只要是对数据集合进行多线程的增删操作，就应该使用并发集合类。&lt;/p&gt;
&lt;p&gt;但是，如果仅从集合进行多线程的读取，则可使用一般的数据集合，即 &lt;a href=&quot;https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.generic?view=netframework-4.8&quot;&gt;System.Collections.Generic&lt;/a&gt; 命名空间中的类。&lt;/p&gt;
&lt;p&gt;.net 中线程安全的数据集合有一下一些：&lt;/p&gt;
&lt;p&gt;一个简单的示例：给一个数据集合添加大批量的数据&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;List&amp;lt;int&amp;gt; list = new List&amp;lt;int&amp;gt;();
Parallel.For(0, 1000000, t =&amp;gt; list.Add(t));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;若是按照上面使用&lt;code&gt;Parallel.For()&lt;/code&gt;的并行方式给List添加数据，&lt;/p&gt;
&lt;p&gt;则会报错：“索引超出了数组界限。”或“ 源数组长度不足。请检查 srcIndex 和长度以及数组的下限。”&lt;/p&gt;
&lt;p&gt;即使没有报错，list中的数据也是有问题的（比可能数量不足）&lt;/p&gt;
&lt;p&gt;当然可以通过加锁的方式进行弥补：&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;List&amp;lt;int&amp;gt; list = new List&amp;lt;int&amp;gt;();
object locker = new object();
Parallel.For(0, 1000000, t =&amp;gt; { lock(locker) { list.Add(t); } });&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样通过对操作的线程枷锁，完全是没有必要的，你可以使用线程安全的集合类型，比如在这里使用ConcurrentBag&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;ConcurrentBag&amp;lt;int&amp;gt; cBag = new ConcurrentBag&amp;lt;int&amp;gt;();
Parallel.For(0, 100000, t =&amp;gt; cBag.Add(t));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然因为是并行操作，所以插入集合中的数据并不是按照0-100000的顺序（仅仅是成段的有序）。&lt;/p&gt;

&lt;hr/&gt;&lt;h2 id=&quot;task类&quot;&gt;3.Task类&lt;/h2&gt;

&lt;h3 id=&quot;task类简介&quot;&gt;3.0 Task类简介&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;System.Threading.Tasks&lt;/code&gt;命名空间中Task类，表示异步操作。&lt;/p&gt;
&lt;p&gt;Task类可以轻松地在次线程中调用方法，可以作为异步委托的简单替代品。&lt;/p&gt;
&lt;p&gt;同时在该命名空间还有一个泛型&lt;code&gt;Task&amp;lt;TResul&amp;gt;&lt;/code&gt;类，TResult 表示异步操作执行完成后返回值的类型。&lt;/p&gt;
&lt;p&gt;创建一个Task操作，只需要使用静态函数&lt;code&gt;Task.Run()&lt;/code&gt;即可，&lt;/p&gt;
&lt;p&gt;Task.Run()是一个.net framework4.5及以上定义的一个默认异步操作，&lt;/p&gt;
&lt;p&gt;Task.Run()参数是委托，即需要异步执行的方法，&lt;/p&gt;
&lt;p&gt;注意&lt;strong&gt;作为Task.Run()的参数的委托都是无参委托&lt;/strong&gt;，&lt;/p&gt;
&lt;p&gt;若Task.Run()参数是无返回值的委托&lt;code&gt;Action&lt;/code&gt;,则Task.Run()返回值是&lt;code&gt;Task&lt;/code&gt;类型&lt;/p&gt;
&lt;p&gt;若Task.Run()参数是有返回值的委托&lt;code&gt;Func&amp;lt;TResult&amp;gt;&lt;/code&gt;,则Task.Run()返回值是&lt;code&gt;Task&amp;lt;TResult&amp;gt;&lt;/code&gt;泛型&lt;/p&gt;
&lt;p&gt;注意：若是低于.net4.5，则可以使用&lt;code&gt;Task.Factory.StartNew()&lt;/code&gt;，和Task.Run()静态方法作用一样&lt;/p&gt;
&lt;p&gt;总而言之，言而总之，show you code ,一切皆明了！&lt;/p&gt;

&lt;h3 id=&quot;创建无返回值的task任务&quot;&gt;3.1 创建无返回值的Task任务&lt;/h3&gt;
&lt;p&gt;示例:无返回值的Task&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;static void Main(string[] args)
{
    //1.使用Task构造函数创建,必须显式的使用.Start()才能开始执行
    //Task task = new Task(() =&amp;gt; { Thread.Sleep(10); Console.WriteLine(&quot;我是Task ,我结束了&quot;); });
    //task.Start();

    //2.使用TaskFactory.StartNew（工厂创建） 方法
    //Task task = Task.Factory.StartNew(() =&amp;gt; { Thread.Sleep(10); Console.WriteLine(&quot;我是Task ,我结束了&quot;); });

    //3.使用Task.Run()
    Task task = Task.Run(() =&amp;gt; { Thread.Sleep(10); Console.WriteLine(&quot;我是Task.Run ,我结束了&quot;); });
    if (!task.IsCompleted)//task.IsCompleted判断当前的任务是否已完成
    {
        Console.WriteLine(&quot;当前的Task.Run()尚未执行完,但是因为异步，返回到调用函数，所以可以先执行后续的代码&quot;);
    }

    Console.WriteLine(&quot;当前Task.Run还没有完成,我们是在他之后的代码但是先执行了&quot;);

    task.Wait();//强行锁定线程，等待task完成
    Console.WriteLine(&quot;终于Task.Run完成了工作&quot;);
    Console.ReadKey();
}&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;创建有返回值的task任务&quot;&gt;3.2 创建有返回值的Task任务&lt;/h3&gt;
&lt;p&gt;若是Task任务有返回值，返回值类型为&lt;code&gt;Task&amp;lt;T&amp;gt;&lt;/code&gt;，使用返回值的&lt;code&gt;Result&lt;/code&gt;属性查询具体值&lt;/p&gt;
&lt;p&gt;调试时注意查看，运行到 &lt;code&gt;Console.WriteLine(task.Result)&lt;/code&gt;的时候，其中Task任务还是在执行Thread.Sleep(1000)&lt;/p&gt;
&lt;p&gt;还没有出结果，我们希望的异步执行也没有发生，而是程序是在一直在等待，这是为什么呢？&lt;/p&gt;
&lt;p&gt;是因为&lt;strong&gt;一但执行了task.Result，即使task任务还没有完成，主线程则停下等待，直到等待task.Result出结果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这种情况和异步委托中调用EndInvoke()是一样的：一旦运行EndInvoke，若是引用方法还没有完成，主线程则停止，直到引用函数运行结束。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所以可以这样理解:task.Result可以看作是一个未来结果（一定有结果但还在运算中）&lt;/p&gt;
&lt;p&gt;示例：有返回值的Task&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;static void Main(string[] args)
{
    Console.WriteLine(&quot;SomeDoBeforeTask&quot;);
    Func&amp;lt;int&amp;gt; Do = () =&amp;gt; { Thread.Sleep(1000); Console.WriteLine(&quot;Task.Run结束&quot;); return 2; };
    Task&amp;lt;int&amp;gt; task = Task.Run(Do);
    Console.WriteLine(task.Status);//使用task.Status查看当前的Task的状态：当前的状态：WaitingToRun
    Console.WriteLine(task.Result);//使用task.result操作Task任务的返回值：返回值是：2
    Console.WriteLine(task.Status);//使用task.Status查看当前的Task的状态：当前的状态：RanToComplation
    Console.WriteLine(&quot;SomeDoAfterTask&quot;);
    Console.ReadKey();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1576687/202002/1576687-20200216004928345-1201527687.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;：&lt;br/&gt;其中我们使用task.Result查看当前的task的状态，其中Task的状态（即其生命周期）只有三种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Created&lt;/strong&gt;(创建Task)：注意只有Task task=new Task(...),此时的Task状态为Created,其他方式创建的Task跳过了Created状态&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;WaitingToRun&lt;/strong&gt;(等待执行Task)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RanToComplation&lt;/strong&gt;(Task完成)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;为task添加延续任务&quot;&gt;3.3 为Task添加延续任务&lt;/h3&gt;
&lt;p&gt;Task任务是在后台执行的同时，主线程的继续执行后续程序&lt;/p&gt;
&lt;p&gt;所以有时候需要在Task结束后，继续执行某个特定的任务，即为Task添加&lt;strong&gt;延续任务&lt;/strong&gt;（也称&lt;strong&gt;接续工作&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;举一个简单的例子，&lt;/p&gt;
&lt;p&gt;求解1-5000能求被3整除的个数，这个过程需要许多时间，我把它定义为一个Task.Run()&lt;/p&gt;
&lt;p&gt;我们需要在求出结果后打印出结果，这里怎么操作呢？&lt;/p&gt;
&lt;p&gt;若是直接使用&lt;code&gt;task.Result&lt;/code&gt;则会阻塞主线程，一直等待运算出结果，这显然不是我们想要的&lt;/p&gt;
&lt;p&gt;若是使用&lt;code&gt;while(!task.IsComplation){//后续操作}&lt;/code&gt;，你无法判断Task何时结束，而且一旦Task结束则会中断后续操作&lt;/p&gt;
&lt;p&gt;这里就是需要为Task加上&lt;strong&gt;接续工作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里你可以明白，&lt;strong&gt;接续本质和异步委托中的回调模式是一样的，回调方法就是接续工作&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;使用task.continuewith&quot;&gt;3.3.1使用task.ContinueWith()&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;task1.ContinueWith(...task2..)&lt;/code&gt;表示当task1结束后接着运行task2任务&lt;/p&gt;
&lt;p&gt;注意这里我们使用Lambda表达式编写接续工作，&lt;strong&gt;接续工作是有一个参数的&lt;/strong&gt;，参数是Task类型，即上一个Task&lt;/p&gt;
&lt;p&gt;即第一个Task完成后自动启动下一个Task，实现Task的延续&lt;/p&gt;
&lt;p&gt;注意:ContinueWith()的返回值亦是Task类型对象，即新创建的任务&lt;/p&gt;
&lt;p&gt;可以为接续工作task2继续添加接续工作task3&lt;/p&gt;
&lt;p&gt;示例5 :&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;  static void Main(string[] args)
  {
      Console.WriteLine(&quot;task执行前...&quot;);
      Task&amp;lt;int&amp;gt; task1 = Task.Run(() =&amp;gt; Enumerable.Range(1, 5000).Count(n =&amp;gt; (n % 3) == 0));
      Task task2 = task1.ContinueWith(t =&amp;gt; Console.WriteLine($&quot;当你看到这句话则task1结束了，1-5000中能被3整除的个数{t.Result}&quot;));//这里的t就是task1
      Task task3 = task2.ContinueWith(t =&amp;gt; Console.WriteLine($&quot;当你看到这句话则task2也结束了&quot;));
      Console.WriteLine($&quot;task1及其接续工作正在执行中,&quot; + &quot;\t\n&quot; + &quot;我们现在正在执行其他的后续代码&quot;);
      Console.ReadKey();
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1576687/202002/1576687-20200216005050052-1853626002.png&quot;/&gt;&lt;/p&gt;

&lt;h4 id=&quot;使用awaiter&quot;&gt;3.3.2使用Awaiter&lt;/h4&gt;
&lt;p&gt;使用&lt;code&gt;task.GetAwaiter()&lt;/code&gt;为相关的task创建一个等待者&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;    static void Main(string[] args)
    {
        Console.WriteLine(&quot;task执行前...&quot;);
        Task&amp;lt;int&amp;gt; task1 = Task.Run(() =&amp;gt; Enumerable.Range(1, 5000).Count(n =&amp;gt; (n % 3) == 0));
        var awaiter = task1.GetAwaiter();//创建一个awaiter对象
        //awaiter.OnCompleted(() =&amp;gt; Console.WriteLine($&quot;当你看到这句话则task1结束了，1-5000中能被3整除的个{task1.Result}&quot;));
        awaiter.OnCompleted(() =&amp;gt; Console.WriteLine($&quot;当你看到这句话则task1结束了，1-5000中能被3整除的个{awaiter.GetResult()}&quot;));
        Console.WriteLine($&quot;task1及其接续工作正在执行中,&quot; + &quot;\t\n&quot; + &quot;我们现在正在执行其他的后续代码&quot;);
        Console.ReadKey();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行效果同上。&lt;/p&gt;
&lt;h4 id=&quot;使用continuewith和awaiter的区别&quot;&gt;3.3.3使用ContinueWith和Awaiter的区别：&lt;/h4&gt;
&lt;p&gt;ContinueWith会返回Task对象，&lt;strong&gt;它非常适合用于增加更多的接续工作&lt;/strong&gt;，不过，如果Task出错，必须直接处理AggregateException。&lt;/p&gt;
&lt;p&gt;使用task.GetAwaiter创建awaiter对象，是在.net4.5之后，其中C#5.0的异步功能就是使用这种方式。&lt;/p&gt;
&lt;p&gt;使用awaiter也是可以使用task.Result直接的查看任务的结果,但是使用awaiter.GetResult()可以在Task出现异常的时候直接抛出,不会封装在AggregateException中。&lt;/p&gt;
&lt;h3 id=&quot;task.delay&quot;&gt;3.4 Task.Delay&lt;/h3&gt;
&lt;p&gt;延时执行Task&lt;/p&gt;
&lt;h4 id=&quot;使用task.delay和continuewith实现延迟工作&quot;&gt;3.4.1 使用Task.Delay()和ContinueWith实现延迟工作&lt;/h4&gt;
&lt;p&gt;其实就相当于实现Thread.Sleep()的异步版本&lt;/p&gt;
&lt;p&gt;若是你使用Thread.Sleep(),则会程序一直在等待(即阻塞线程)，直到等待结束才会运行后续的代码&lt;/p&gt;
&lt;p&gt;而这里就相当于给给Thread.Sleep()一个加了接续工作，且这个接续工作是异步的。&lt;/p&gt;
&lt;p&gt;即使用Task.Delay()不会阻塞主线程，主线程可以继续执行后续代码&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;    //新建异步任务，30毫秒秒后执行
    Task.Delay(30).ContinueWith(c =&amp;gt;
    {
        for (int i = 0; i &amp;lt; 50; i++)
        {
            Console.WriteLine(i + &quot;这是Task在运行&quot;);
        }
    });
    for (int i = 0; i &amp;lt; 100; i++)
    {
        Console.WriteLine(i + &quot;这是Task之后的程序在运行&quot;);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调试的时候你会发现，刚开始的时候的时候是先显示的&quot;i这是Task之后的程序在运行&quot;&lt;/p&gt;
&lt;p&gt;之后在等带了30毫秒，后就会开始显示&quot;i这是Task在运行&quot;和&quot;i这是Task之后的程序在运行&quot;交叉显示&lt;/p&gt;
&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1576687/202002/1576687-20200216005315346-537190864.gif&quot;/&gt;&lt;/p&gt;

&lt;h4 id=&quot;使用task.delay和awaiter实现延迟工作&quot;&gt;3.4.2 使用Task.Delay()和Awaiter实现延迟工作&lt;/h4&gt;
&lt;p&gt;示例:运行效果同上&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;    Task.Delay(30).GetAwaiter().OnCompleted(() =&amp;gt;
    {
        for (int i = 0; i &amp;lt; 50; i++)
        {
            Console.WriteLine(i + &quot;这是Awaiter在运行行&quot;);
        }
    });
    for (int i = 0; i &amp;lt; 100; i++)
    {
        Console.WriteLine(i + &quot;这是Awaiter之后的程序在运行行&quot;);
    }
    Console.ReadKey();    &lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;task对象的其他一些静态方法&quot;&gt;3.5 Task对象的其他一些静态方法&lt;/h3&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Task.Wait&lt;/td&gt;
&lt;td&gt;task1.Wait();就是等待任务执行（task1）完成，task1的状态变为Completed&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Task.WaitAll&lt;/td&gt;
&lt;td&gt;待所有的任务都执行完成&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Task.WaitAny&lt;/td&gt;
&lt;td&gt;发同Task.WaitAll，就是等待任何一个任务完成就继续向下执行&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;CancellationTokenSource&lt;/td&gt;
&lt;td&gt;通过cancellation的tokens来取消一个Task&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h3 id=&quot;取消异步操作&quot;&gt;3.6 取消异步操作&lt;/h3&gt;
&lt;p&gt;异步方法是可以请求终止运行的，&lt;/p&gt;
&lt;p&gt;System.Threading.Tasks命名空间中有两个类是为此目的而设计的：Cance1lationToken和CancellationTokenSource。&lt;/p&gt;
&lt;p&gt;下面看使用CancellationTokenSource和CancellationToken来实现取消某个异步操作。&lt;/p&gt;
&lt;p&gt;这里使用Task.Run()为例，其第一个参数是一个Action委托，第二个参数就是CancellationToken对象&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;static void Main(string[] args)
{
    CancellationTokenSource cts = new CancellationTokenSource();//生成一个CancellationTokenSource对象，该对象可以创建CancellationToken                                                 
    CancellationToken ct = cts.Token;//获取一个令牌（token)
    Task.Run(() =&amp;gt;
    {
        for (int i = 0; i &amp;lt; 20; i++)
        {
            if (ct.IsCancellationRequested)
            {
                return;
            }
            Thread.Sleep(1000);
            Console.WriteLine($&quot;异步程序的的循环：{i}&quot;);
        }
    }, ct);//注意Run()的第二个参数就是终止令牌token
    for (int i = 0; i &amp;lt; 4; i++)
    {

        Thread.Sleep(1000);
        Console.WriteLine($&quot;主线程中循环：{i}&quot;);
    }
    Console.WriteLine(&quot;马上sts.Cancel(),即将要终止异步程序&quot;);
    cts.Cancel();//含有该CancellationTokenSource的token的异步程序，终止！
    Console.ReadKey();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：可以发现异步任务Task.Run()还没有完成，但是因为cst.Cancel()运行，token的属性IsCancellationRequested变为true,异步循环结束。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1576687/202002/1576687-20200216005448471-967485413.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;：取消一个异步操作的过程，注意，该过程是协同的。&lt;/p&gt;
&lt;p&gt;即：调用CancellationTokenSource的Cancel时，它本身并不会执行取消操作。&lt;br/&gt;而是会将CancellationToken的IsCancellationRequested属性设置为true。&lt;br/&gt;包含CancellationToken的代码负责检查该属性，并判断是否需要停止执行并返回。&lt;/p&gt;

&lt;hr/&gt;&lt;h2 id=&quot;并行linqplinq&quot;&gt;4.并行Linq（PLinq）&lt;/h2&gt;

&lt;h3 id=&quot;asparallel&quot;&gt;4.1 AsParallel()&lt;/h3&gt;
&lt;p&gt;System.Linq名称空间中有一个&lt;code&gt;ParallelEnumerable&lt;/code&gt;类，该类中的方法可以分解Linq查询的工作，使其分布在多个线程上,即实现并行查询。&lt;/p&gt;
&lt;p&gt;为并行运行而设计的LINQ查询称为&lt;strong&gt;PLINQ查询&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;下面让我们先简单的理一理：&lt;/p&gt;
&lt;p&gt;首先我们都知道&lt;code&gt;Enumerable&lt;/code&gt;类为&lt;code&gt;IEnumberable&amp;lt;T&amp;gt;&lt;/code&gt;接口扩展了一系列的静态方法。（就是我们使用Linq方法语法的中用的哪些常用的静态方法，自行F12）&lt;/p&gt;
&lt;p&gt;正如MSDN中所说：“ParallelEnumberable是Enumberable的并行等效项”，&lt;code&gt;ParallelEnumberable&lt;/code&gt;类则是&lt;code&gt;Enumerable&lt;/code&gt;类的并行版本，&lt;/p&gt;
&lt;p&gt;F12查看定义可以看到&lt;code&gt;ParallelEnumerable&lt;/code&gt;类中几乎所有的方法都是对&lt;code&gt;ParallelQuery&amp;lt;TSource&amp;gt;&lt;/code&gt;接口的扩展，&lt;/p&gt;
&lt;p&gt;但是，在&lt;code&gt;ParallelEnumberable&lt;/code&gt;类有一个重要的例外，&lt;code&gt;AsParallel()&lt;/code&gt; 方法还对&lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt;接口的扩展，并且返回的是一个&lt;code&gt;ParallelQuery&amp;lt;TSource&amp;gt;&lt;/code&gt;类型的对象，&lt;/p&gt;
&lt;p&gt;所以呢？凡是实现类IEnumberable&amp;lt;T&amp;gt;集合可以通过调用静态方法&lt;code&gt;AsParallel()&lt;/code&gt;,返回一个ParallelQuery类型的对象，之后就可以使用ParallelEnumerable类中的异步版本的静态查询方法了！&lt;/p&gt;
&lt;p&gt;注意在运行PLinq的时候，PLinq会自动的判断如果查询能从并行化中受益，则将同时运行。而如果并行执行查询会损害性能，PLINQ将按顺序运行查询。&lt;/p&gt;
&lt;p&gt;示例：求1到50000000中可以整除3的数，将所求的结果倒序存放在modThreeIsZero[]中&lt;/p&gt;
&lt;p&gt;这是需要非常多的重复运算，所以我们可以对比按照一般Linq查询下方式和PLinq查询，对比一些需要的时间。&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;static void Main(string[] args)
{
    int[] intArray = Enumerable.Range(1, 50000000).ToArray();
    Stopwatch sw = new Stopwatch();

    //顺序查询
    sw.Start();
    int[] modThreeIsZero1 = intArray.Select(n =&amp;gt; n).Where(n =&amp;gt; n % 3 == 0).OrderByDescending(n =&amp;gt; n).ToArray();
    sw.Stop();
    Console.WriteLine($&quot;顺序查询，运行时间：{sw.ElapsedMilliseconds}毫秒,可以整除3的个数:{modThreeIsZero1.Count()}&quot;);

    //使用AsParallel()实现并行查询
    //AsParallel()方法返回ParallelQuery&amp;amp;lt;TSourc&amp;gt;类型对象。因为返回的类型，所以编译器选择的Select()、Where()等方法是ParallelEnumerable.Where()，而不是Enumerable.Where()。
    sw.Restart();
    int[] modThreeIsZero2 = intArray.AsParallel().Select(n =&amp;gt; n).Where(n =&amp;gt; n % 3 == 0).OrderByDescending(n =&amp;gt; n).ToArray();
    sw.Stop();
    Console.WriteLine($&quot;并行查询，运行时间：{sw.ElapsedMilliseconds}毫秒,可以整除3的个数:{modThreeIsZero2.Count()}&quot;);

    Console.ReadKey();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;说明：AsParallel()方法返回ParallelQuery&amp;lt;TSourc&amp;gt;类型对象。因为返回的类型，所以编译器选择的Select()、Where()等方法是ParallelEnumerable.Where()，而不是Enumerable.Where()。&lt;/p&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1576687/202002/1576687-20200216005812606-323025854.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以对比结果，在大规模的Linq查询中，同步查询和并行查询两者的运行时间的差距还是很大的！&lt;/p&gt;
&lt;p&gt;但是小规模的Linq查询二者的效果其实并没有很明显。&lt;/p&gt;
&lt;h3 id=&quot;取消并行查询&quot;&gt;4.2 取消并行查询&lt;/h3&gt;
&lt;p&gt;在3.6取消异步操作中解释了如何取消一个长时间的任务，&lt;/p&gt;
&lt;p&gt;那么对于长时间运行的PLinq也是可以取消的&lt;/p&gt;
&lt;p&gt;同样是使用&lt;code&gt;CancellationTokenSource&lt;/code&gt;生成一个&lt;code&gt;CancellationToken&lt;/code&gt;对象作为token&lt;/p&gt;
&lt;p&gt;怎么把token给PLinq呢？使用&lt;code&gt;ParallelQuery&amp;lt;TSource&amp;gt;&lt;/code&gt;中静态方法&lt;code&gt;WithCancellation(token)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在PLinq中，若是取消了并行操作，则会抛出&lt;code&gt;OperationCanceledException&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;static void Main(string[] args)
{
    //具体的作用和含义可以看0030取消一个异步操作
    CancellationTokenSource cts = new CancellationTokenSource();
    CancellationToken ct = cts.Token;
    int[] intArray = Enumerable.Range(1, 50000000).ToArray();
    Task&amp;lt;int[]&amp;gt; task = Task.Run(() =&amp;gt;
    {
        try
        {
            int[] modThreeIsZero = intArray.AsParallel().WithCancellation(ct).Select(n =&amp;gt; n).Where(n=&amp;gt; n% 3 == 0).OrderByDescending(n =&amp;gt; n).ToArray();
            return modThreeIsZero;
        }
        catch (OperationCanceledException ex)//一旦PLinq中取消查询就会触发OperationCanceledException异常
        {
            Console.WriteLine(ex.Message);//注意：Message的内容就是：已取消该操作
            return null;
        }
    });
       
    Console.WriteLine(&quot;取消PLinq?Y/N&quot;);
    string input = Console.ReadLine();
    if (input.ToLower().Equals(&quot;y&quot;))
    {
        cts.Cancel();//取消并行查询
        Console.WriteLine(&quot;取消了PLinq！&quot;);//undone:怎么验证已经真的取消了
    }
    else
    {
        Console.WriteLine(&quot;Loading……&quot;);
        Console.WriteLine(task.Result.Count());
    }
    Console.ReadKey();
}&lt;/code&gt;
&lt;/pre&gt;

&lt;hr/&gt;&lt;h2 id=&quot;参考源代码下载&quot;&gt;5.参考&amp;amp;源代码下载&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/shanzhiming/p/12315548.html&quot;&gt;书籍：精通C#&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/shanzhiming/p/12315548.html&quot;&gt;书籍：C#高级编程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/shanzhiming/&quot;&gt;书籍：ASP.NET MVC5网站开发之美&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/zh-cn/dotnet/api/?view=netframework-4.8&quot;&gt;文档：.NET API 浏览器&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/shanzm/AsynchronousProgramming&quot;&gt;点击：源代码下载&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;唉，书真是越看越厚，皆是浅尝辄止，先到这里吧！&lt;/p&gt;
</description>
<pubDate>Sat, 15 Feb 2020 17:01:00 +0000</pubDate>
<dc:creator>shanzm</dc:creator>
<og:description>[TOC] shanzm 2020年2月16日 00:45:04 1.简介 中的类型被称为 任务并行库 （Task Parallel Library， TPL ）。 命名空间是.NET Framewo</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/shanzhiming/p/12315548.html</dc:identifier>
</item>
<item>
<title>MySQL 多表查询 - LeeHua</title>
<link>http://www.cnblogs.com/liyihua/p/12315445.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liyihua/p/12315445.html</guid>
<description>&lt;ul&gt;&lt;li&gt;内连接
&lt;ul&gt;&lt;li&gt;隐式内连接&lt;/li&gt;
&lt;li&gt;显式内连接&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;外连接
&lt;ul&gt;&lt;li&gt;左外连接&lt;/li&gt;
&lt;li&gt;右外连接&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p class=&quot;p1&quot;&gt;用左边表的记录去匹配右边表的记录，如果符合条件的则显示。如:从表&lt;span class=&quot;s1&quot;&gt;.外键&lt;span class=&quot;s1&quot;&gt;=主表&lt;span class=&quot;s1&quot;&gt;.主键&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt; &lt;/p&gt;
&lt;h2 class=&quot;p1&quot;&gt;隐式内连接&lt;/h2&gt;
&lt;p class=&quot;p1&quot;&gt;隐式内连接：看不到 &lt;span class=&quot;s1&quot;&gt;JOIN 关键字，条件使用 &lt;span class=&quot;s1&quot;&gt;WHERE 指定&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;SELECT&lt;/span&gt; 字段名 &lt;span&gt;FROM&lt;/span&gt; 左表, 右表 &lt;span&gt;WHERE&lt;/span&gt; 条件
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如：&lt;/p&gt;
&lt;p&gt;创建一个学生个人信息表&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt; students(
    Id &lt;/span&gt;&lt;span&gt;INT&lt;/span&gt;(&lt;span&gt;30&lt;/span&gt;&lt;span&gt;),
    Name &lt;/span&gt;&lt;span&gt;VARCHAR&lt;/span&gt;(&lt;span&gt;10&lt;/span&gt;&lt;span&gt;),
    Age &lt;/span&gt;&lt;span&gt;INT&lt;/span&gt;(&lt;span&gt;4&lt;/span&gt;&lt;span&gt;),
    Gender &lt;/span&gt;&lt;span&gt;VARCHAR&lt;/span&gt;(&lt;span&gt;25&lt;/span&gt;&lt;span&gt;),
    &lt;/span&gt;&lt;span&gt;PRIMARY&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt;&lt;span&gt;(Id)
);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;创建一个学习成绩表&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt; course(
    Id &lt;/span&gt;&lt;span&gt;INT&lt;/span&gt;(&lt;span&gt;30&lt;/span&gt;&lt;span&gt;),
     Java &lt;/span&gt;&lt;span&gt;INT&lt;/span&gt;(&lt;span&gt;5&lt;/span&gt;&lt;span&gt;),
     Python &lt;/span&gt;&lt;span&gt;INT&lt;/span&gt;(&lt;span&gt;5&lt;/span&gt;&lt;span&gt;),
     MySQL &lt;/span&gt;&lt;span&gt;INT&lt;/span&gt;(&lt;span&gt;5&lt;/span&gt;&lt;span&gt;),
     Hadoop &lt;/span&gt;&lt;span&gt;INT&lt;/span&gt;(&lt;span&gt;5&lt;/span&gt;&lt;span&gt;),
     C &lt;/span&gt;&lt;span&gt;INT&lt;/span&gt;(&lt;span&gt;5&lt;/span&gt;&lt;span&gt;),
     PHP &lt;/span&gt;&lt;span&gt;INT&lt;/span&gt;(&lt;span&gt;5&lt;/span&gt;&lt;span&gt;),
     Linux &lt;/span&gt;&lt;span&gt;INT&lt;/span&gt;(&lt;span&gt;5&lt;/span&gt;&lt;span&gt;),
     English &lt;/span&gt;&lt;span&gt;INT&lt;/span&gt;(&lt;span&gt;5&lt;/span&gt;&lt;span&gt;),
     Math &lt;/span&gt;&lt;span&gt;INT&lt;/span&gt;(&lt;span&gt;5&lt;/span&gt;&lt;span&gt;),
     &lt;/span&gt;&lt;span&gt;CONSTRAINT&lt;/span&gt; id_course &lt;span&gt;FOREIGN&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt;(Id) &lt;span&gt;REFERENCES&lt;/span&gt;&lt;span&gt; students(Id)
);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;学习成绩表的外键连接学生个人信息表的主键。这个时候，如果我们想要查询学生的Java成绩，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; name, Java &lt;span&gt;FROM&lt;/span&gt; students, course &lt;span&gt;WHERE&lt;/span&gt; course.Id &lt;span&gt;=&lt;/span&gt; students.Id;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 class=&quot;p1&quot;&gt;显式内连接&lt;/h2&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;显示内连接：使用 INNER JOIN ... ON &lt;span class=&quot;s1&quot;&gt;语句, &lt;span class=&quot;s1&quot;&gt;可以省略 INNER&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; 字段名 &lt;span&gt;FROM&lt;/span&gt; 左表 &lt;span&gt;[&lt;/span&gt;&lt;span&gt;INNER&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;JOIN&lt;/span&gt; 右表 &lt;span&gt;ON&lt;/span&gt; 条件
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如：&lt;/p&gt;
&lt;p&gt;还是上面创建的students表和course表&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt; students &lt;span&gt;INNER&lt;/span&gt; &lt;span&gt;JOIN&lt;/span&gt; course c &lt;span&gt;ON&lt;/span&gt; students.Id &lt;span&gt;=&lt;/span&gt; c.Id;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查询students表的所有信息，按ID插入course表的数据，一并查询出来。&lt;/p&gt;


&lt;h2&gt;左外连接&lt;/h2&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;左外连接：使用 LEFT OUTER JOIN ... ON&lt;span class=&quot;s1&quot;&gt;，OUTER &lt;span class=&quot;s1&quot;&gt;可以省略&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; 字段名 &lt;span&gt;FROM&lt;/span&gt; 左表 &lt;span&gt;LEFT&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;OUTER&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;JOIN&lt;/span&gt; 右表 &lt;span&gt;ON&lt;/span&gt; 条件
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;p1&quot;&gt;用左边表的记录去匹配右边表的记录，如果符合条件的则显示;否则，显示 &lt;span class=&quot;s1&quot;&gt;NULL 。可以理解为：在内连接的基础上保证左表的数据全部显示。&lt;span class=&quot;s1&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt; &lt;/p&gt;
&lt;h2 class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;右外连接&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;右外连接:使用 RIGHT OUTER JOIN ... ON&lt;span class=&quot;s1&quot;&gt;，OUTER &lt;span class=&quot;s1&quot;&gt;可以省略&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; 字段名 &lt;span&gt;FROM&lt;/span&gt; 左表 &lt;span&gt;RIGHT&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;OUTER&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;JOIN&lt;/span&gt; 右表 &lt;span&gt;ON&lt;/span&gt; 条件
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;p1&quot;&gt;用右边表的记录去匹配左边表的记录，如果符合条件的则显示;否则，显示 &lt;span class=&quot;s1&quot;&gt;NULL。&lt;/span&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;可以理解为：在内连接的基础上保证右表的数据全部显示。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt; &lt;/p&gt;
</description>
<pubDate>Sat, 15 Feb 2020 16:10:00 +0000</pubDate>
<dc:creator>LeeHua</dc:creator>
<og:description>多表查询的分类 内连接 隐式内连接 显式内连接 外连接 左外连接 右外连接 内连接 用左边表的记录去匹配右边表的记录，如果符合条件的则显示。如:从表.外键=主表.主键 隐式内连接 隐式内连接：看不到</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/liyihua/p/12315445.html</dc:identifier>
</item>
<item>
<title>【Java并发工具类】Semaphore - sakuraxx</title>
<link>http://www.cnblogs.com/myworld7/p/12315393.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/myworld7/p/12315393.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;1965年，荷兰计算机科学家Dijkstra提出的信号量机制成为一种高效的进程同步机制。这之后的15年，信号量一直都是并发编程领域的终结者。1980年，管程被提出，成为继信号量之后的在并发编程领域的第二个选择。目前几乎所有的语言都支持信号量机制，Java也不例外。Java中提供了&lt;code&gt;Semaphore&lt;/code&gt;并发工具类来支持信号量机制。下面我们就来了解Java实现的信号量机制。&lt;br/&gt;首先介绍信号量模型，然后介绍如何使用，最后使用信号量来实现一个限流器。&lt;/p&gt;
&lt;h2 id=&quot;信号量模型&quot;&gt;信号量模型&lt;/h2&gt;
&lt;p&gt;信号量模型图（图来自参考[1]）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1099419/202002/1099419-20200215235217548-1318002192.png&quot; alt=&quot;image-20200215222026469&quot;/&gt;&lt;/p&gt;
&lt;p&gt;信号量模型总结为：一个计数器、一个等待队列和三个对外调用的方法。&lt;br/&gt;计数器和等待队列时对外透明的，所有我们只能通过三个对外方法来访问计数器和等待队列。&lt;br/&gt;&lt;code&gt;init()&lt;/code&gt;：设置计数器的初始值。&lt;br/&gt;&lt;code&gt;down()&lt;/code&gt;：计数器的值减一。如果此时计数器的值小于0，则当前线程插入等待队列并阻塞，否则当前线程可以继续执行。&lt;br/&gt;&lt;code&gt;up()&lt;/code&gt;：计数器的值加一。如果此时计数器的值小于或者等于0，则唤醒等待队列中的一个线程，并将其从等待队列中移除。&lt;/p&gt;
&lt;p&gt;这三个方法都是原子性的，由实现信号量模型的方法保证。在Java SDK中，信号量模型是由&lt;code&gt;java.util.concurrent.Semaphore&lt;/code&gt;实现。&lt;/p&gt;
&lt;p&gt;信号量模型代码化大致类似如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class Semaphore{
    int count; // 计数器
    Queue queue; // 等待队列
    
    // 初始化操作
    Semaphore(int c){
        this.count=c;
    }
    
    void down(){
        this.count--; // 计数器值减一
        if(this.count &amp;lt; 0){
            // 将当前线程插入等待队列
            // 阻塞当前线程
        }
    }
    
    void up(){
        this.count++; // 计数器值加一
        if(this.count &amp;lt;= 0) {
            // 移除等待队列中的某个线程T
            // 唤醒线程T
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在信号量模型中，&lt;code&gt;down()&lt;/code&gt;和&lt;code&gt;up()&lt;/code&gt;这两个操作也被成为P操作（荷兰语proberen，测试）和V操作（荷荷兰语verhogen，增加）。在我学的操作系统教材中（C语言实现），P操作对应wait()，V操作对应singal()。虽然叫法不同，但是语义都是相同的。在Java SDK并发包中，&lt;code&gt;down()&lt;/code&gt;和&lt;code&gt;up()&lt;/code&gt;分别对应于Semaphore中的&lt;code&gt;acquire()&lt;/code&gt;和&lt;code&gt;release()&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;如何使用信号量&quot;&gt;如何使用信号量&lt;/h2&gt;
&lt;p&gt;信号量有时也被称为红绿灯，我们想想红绿灯时怎么控制交通的，就知道该如何使用信号量。车辆路过十字路时，需要先检查是否为绿灯，如果是则通行，否则就等待。想想和加锁机制有点相似，都是一样的操作，先检查是否符合条件（“尝试获取”），符合（“获取到”）则线程继续运行，否则阻塞线程。&lt;/p&gt;
&lt;p&gt;下面使用累加器的例子来说明如何使用信号量。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;count+=1&lt;/code&gt;操作是个临界区，只允许一个线程执行，即要保证互斥。于是我们在进入临界区之前，使用down()即Java中的acquire()，在退出之后使用up()即Java中的release()。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;static int count;
//初始化信号量
static final Semaphore s = new Semaphore(1); // 构造函数参数为1，表示只允许一个线程进行临界区。可实现一个互斥锁的功能。
//用信号量保证互斥    
static void addOne() {
    s.acquire(); // 获取一个许可(可看作加锁机制中加锁)
    try {
        count+=1;
    } finally {
        s.release(); // 归还许可(可看做加锁机制中解锁)
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;完整代码如下:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.sakura.concrrent;
import java.util.concurrent.Semaphore;
public class SemaphoreTest {
    static int count;
    static final Semaphore s = new Semaphore(1);
    static void addOne() throws InterruptedException {
        //只会有一个线程将信号量中的计数器减为1，而另外一个线程只能将信号量中计数器减为-1，导致被阻塞
        s.acquire();  
        try {
            count +=1;
            System.out.println(&quot;Now thread is &quot; + Thread.currentThread() + &quot;   and count is &quot; + count);
        }finally {
            //进入临界区的线程在执行完临界区代码后将信号量中计数器的值加1然后，此时信号量中计数器的值为0，则从阻塞队列中唤醒被阻塞的进程
            s.release();   
        }
    }

    public static void main(String[] args) {
        // 创建两个线程运行
        MyThread thread1 = new MyThread();
        MyThread thread2 = new MyThread();

        thread1.start();
        thread2.start();
        System.out.println(&quot;main thread&quot;);

    }
}
class MyThread extends Thread{
    @Override
    public void run() {
        super.run();
        for(int i=0; i&amp;lt;10; i++) {                   
            try {
                SemaphoreTest.addOne();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1099419/202002/1099419-20200215235302835-1159131789.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果Semaphore的构造函数参数（许可数量，内置计数器的值）修改一下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;static final Semaphore s = new Semaphore(2);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;则&lt;strong&gt;计数器值的为2，那么就允许有两个线程进入临界区&lt;/strong&gt;，我们的count值就会出现问题&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1099419/202002/1099419-20200215235322937-163898048.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;快速实现一个限流器&quot;&gt;快速实现一个限流器&lt;/h2&gt;
&lt;p&gt;当设置信号量的计数器为1时，可实现一个简单的互斥锁功能。但是，我们前面刚介绍过Java SDK中的&lt;code&gt;Lock&lt;/code&gt;，Semaphore的用途显然不会与Lock一致，不然就重复造轮子了。Semaphore最重要的一个功能便是：&lt;strong&gt;可以允许多个线程访问一个临界区&lt;/strong&gt;。（上述例子我们就设置了计数器的值为2，可发现thread1和thread2都可进入临界区。）&lt;/p&gt;
&lt;p&gt;我们会在什么地方遇见这种需求呢？&lt;br/&gt;各种池化资源，例如连接池、对象池、线程池等等。例如，数据库连接池，在同一时刻，一定是允许多个线程同时使用连接池，当然，每个连接在被释放之前，是不允许其他线程使用的。&lt;/p&gt;
&lt;p&gt;我们设计如下可以允许N个线程使用的对象池，我们将信号量的计数器值设为N，就可以让N个线程同时进行临界区，多余的就会被阻塞。（代码来自参考[1]）&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class ObjPool&amp;lt;T, R&amp;gt; {
    final List&amp;lt;T&amp;gt; pool;    //使用List保存实例对象
    // 用信号量实现限流器
    final Semaphore sem;
    
    // 构造函数
    ObjPool(int size, T t){
        pool = new Vector&amp;lt;T&amp;gt;(){}; 
        for(int i=0; i&amp;lt;size; i++){
            pool.add(t);
        }
        sem = new Semaphore(size);
    }
    
    // 获取对象池的对象，调用 func
    R exec(Function&amp;lt;T,R&amp;gt; func) {
        T t = null;
        sem.acquire();    //允许N个进程同时进入临界区
        try {
            //我们需要注意，因为多个进行可以进入临界区，所以Vector的remove方法是线程安全的
            t = pool.remove(0);    
            return func.apply(t);    //获取对象池汇中的一个对象后，调用func函数
        } finally {
            pool.add(t);    //离开临界区之前，将之前获取的对象放回到池中
            sem.release();    //使得计数器加1，如果信号量中计数器小于等于0，那么说明有线程在等待，此时就会自动唤醒等待线程
        }
    }
}
// 创建对象池
ObjPool&amp;lt;Long, String&amp;gt; pool = new ObjPool&amp;lt;Long, String&amp;gt;(10, 2);

// 通过对象池获取 t，之后执行  
pool.exec(t -&amp;gt; {
    System.out.println(t);
    return t.toString();
});&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;记得学习操作系统时，信号量类型分为了好几种整型信号量、记录型信号量、AND信号量以及“信号量集”（具体了解可戳参考[2]）。我认为Java SDK中Semaphore应该是记录型信号量的实现。不由想起，编程语言是对OS层面操作的一种抽象描述。这句话需要品需要细细品。&lt;/p&gt;
&lt;p&gt;参考：&lt;br/&gt;[1] 极客时间专栏王宝令《Java并发编程实战》&lt;br/&gt;[2] 静水深流.操作系统之信号量机制总结.https://www.cnblogs.com/IamJiangXiaoKun/p/9464336.html&lt;/p&gt;
</description>
<pubDate>Sat, 15 Feb 2020 15:54:00 +0000</pubDate>
<dc:creator>sakuraxx</dc:creator>
<og:description>前言 1965年，荷兰计算机科学家Dijkstra提出的信号量机制成为一种高效的进程同步机制。这之后的15年，信号量一直都是并发编程领域的终结者。1980年，管程被提出，成为继信号量之后的在并发编程领</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/myworld7/p/12315393.html</dc:identifier>
</item>
<item>
<title>TensorFlow中使用GPU - ZingpLiu</title>
<link>http://www.cnblogs.com/zingp/p/12315366.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zingp/p/12315366.html</guid>
<description>&lt;p&gt;TensorFlow默认会占用设备上所有的GPU以及每个GPU的所有显存；如果指定了某块GPU,也会默认一次性占用该GPU的所有显存。可以通过以下方式解决：&lt;/p&gt;
&lt;h2&gt;1 Python代码中设置环境变量，指定GPU&lt;/h2&gt;
&lt;p&gt;本文所有代码在tensorflow 1.12.0中测试通过。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
import os
os.environ[&quot;CUDA_VISIBLE_DEVICES&quot;] = &quot;2&quot;  # 指定只是用第三块GPU
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2 系统环境变量中指定GPU&lt;/h2&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
# 只使用第2块GPU，在demo_code.py，机器上的第二块GPU变成”/gpu:0“，不过在运行时所有的/gpu:0的运算将被放到第二块GPU上
CUDA_VISIBLE_DEVICES=1 python demo_code.py

#只使用第一块GPU和第二块GPU
CUDA_VISIBLE_DEVICES=0,1 python demo_code.py
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3 动态分配GPU显存&lt;/h2&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
# allow_soft_placement=True 没有GPU的话在CPU上运行
config = tf.ConfigProto(allow_soft_placement=True, log_device_placement=True)

config.gpu_options.allow_growth = True   #  按需分配显存

with tf.Session(config=config) as sess:
    sess.run(...)
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;4 按固定比例分配显存&lt;/h2&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
# 按照固定的比例分配。
config = tf.ConfigProto(allow_soft_placement=True, log_device_placement=True)
# 以下代码会占用所有可使用的GPU的40%显存
config.gpu_options.per_process_gpu_memory_fraction = 0.4

with tf.Session(config=config) as sess:
    sess.run(...)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在我的设备中设置后GPU占用情况如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
gz_6237_gpu             Sat Feb 15 23:01:56 2020  418.87.00
[0] GeForce RTX 2080 Ti | 43'C,   0 % |  4691 / 10989 MB | dc:python/1641(4681M)
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;5 通过tf.device将运算指定到特定设备上&lt;/h2&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
with tf.device(&quot;/gpu:0&quot;):
    b = tf.Variable(tf.zeros([1]))
    W = tf.Variable(tf.random_uniform([1, 2], -1.0, 1.0))
    y = tf.matmul(W, x_data) + b
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这种方式&lt;strong&gt;不推荐&lt;/strong&gt;。TF的kernel中国定义了哪些操作可以跑在GPU上，哪些不可以，因此强制指定GPU会降低程序的可移植性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;推荐的做法是&lt;/strong&gt;：在创建会话时，指定参数allow_soft_placement=True；这样如果运算无法在GPU上执行，TF会自动将它放在CPU上执行。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
config = tf.ConfigProto(allow_soft_placement=True)

with tf.Session(config=config) as sess:
    sess.run(...)
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sat, 15 Feb 2020 15:52:00 +0000</pubDate>
<dc:creator>ZingpLiu</dc:creator>
<og:description>TensorFlow默认会占用设备上所有的GPU以及每个GPU的所有显存；如果指定了某块GPU,也会默认一次性占用该GPU的所有显存。可以通过以下方式解决： 1 Python代码中设置环境变量，指定G</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zingp/p/12315366.html</dc:identifier>
</item>
<item>
<title>前端：CSS第四章第一节 - nofeel666</title>
<link>http://www.cnblogs.com/no000000/p/12315318.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/no000000/p/12315318.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;第一部分：样式规则                                                 &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;块级元素一行只有一个，比如P标签&lt;/p&gt;
&lt;p&gt;CSS层叠样式表，意思就是样式是可以叠加的，比如下面的代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    .ok&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
        color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; aqua&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
    .blue&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
        color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; #5283ff&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;br/&gt;/*p名词叫标签选择器*/&lt;br/&gt;&lt;/span&gt;&lt;span&gt;
    p&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
        color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; black&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        font-size&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 30px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
/*#red属于TAG*/
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;#red&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt; color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; #080dff &lt;/span&gt;&lt;span&gt;}&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;red&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;内容1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;blue ok&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;内容2&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;内容3&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;内容4&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;内容5&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
/*
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;优先级从 id&amp;gt;class&amp;gt;标签选择器&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
*/
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1931764/202002/1931764-20200215233334397-1509250687.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;第二部分：盒模型   &lt;/span&gt;      &lt;/span&gt;              &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所有的都是盒子，只是分为块级盒子和行内盒子，转换就是display:block改为块元素  &lt;strong&gt;       &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1931764/202002/1931764-20200215235703751-62982055.png&quot; alt=&quot;&quot;/&gt;               &lt;/strong&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 15 Feb 2020 15:36:00 +0000</pubDate>
<dc:creator>nofeel666</dc:creator>
<og:description>第一部分：样式规则 块级元素一行只有一个，比如P标签 CSS层叠样式表，意思就是样式是可以叠加的，比如下面的代码 &amp;lt;style&amp;gt; .ok{ color: aqua; } .blue{ co</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/no000000/p/12315318.html</dc:identifier>
</item>
<item>
<title>Java并发读书笔记：如何实现线程间正确通信 - 天乔巴夏丶</title>
<link>http://www.cnblogs.com/summerday152/p/12315274.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/summerday152/p/12315274.html</guid>
<description>&lt;p&gt;在并发编程中，保证线程同步，从而&lt;strong&gt;实现线程之间正确通信&lt;/strong&gt;，是一个值得考虑的问题。本篇将参考许多著名书籍，学习如何让多个线程之间相互配合，完成我们指定的任务。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;synchronized&lt;/code&gt;关键字是Java提供的&lt;strong&gt;互斥的内置锁&lt;/strong&gt;，该锁机制&lt;strong&gt;不用显式加锁或者释放锁&lt;/strong&gt;。互斥执行的特性可以确保对整个临界区代码的执行具有原子性，同步机制保证了&lt;strong&gt;共享数据在同一个时刻只被一个线程使用&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;回顾以下synchronized的底层实现：&lt;/p&gt;
&lt;p&gt;我们可以对下面这段代码进行反编译：&lt;code&gt;javap -v TestData.class&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class TestData {
    public static synchronized void m1(){}
    public synchronized void m2(){}
    public static void main(String[] args) {
        synchronized (TestData.class){
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;编译结果如下：&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTc3MTA3Mi8yMDIwMDIvMTc3MTA3Mi0yMDIwMDIxMzIyNTAwMjA0My03Nzk0NDQ0NTYucG5n?x-oss-process=image/format,png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTc3MTA3Mi8yMDIwMDIvMTc3MTA3Mi0yMDIwMDIxMzIyNTAwNjI0NC03Njg2Mjc2NDYucG5n?x-oss-process=image/format,png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;虽然同步方法和代码块的实现细节不同，但是归根结底：JVM对于方法或者代码块的实现是&lt;strong&gt;基于对Monitor对象的进入和退出操作&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;以同步代码块举例：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;monitorenter指令被安排到了&lt;strong&gt;代码块开始位置&lt;/strong&gt;，monitorexit被安排到代码块&lt;strong&gt;正常结束和异常处&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;任何对象都有一个monitor与之相关联，当一个monitor被持有之后，它将会出于锁定状态。&lt;/li&gt;
&lt;li&gt;当JVM执行到monitorenter指令时，将会尝试去获取当前对象对应的monitor的所有权。
&lt;ul&gt;&lt;li&gt;若其他前程已经有monitor的所有权，那么当前线程将会进入同步队列(SynchronizedQueue)，陷入阻塞状态（BLOCKED)，直到monitor被释放。&lt;/li&gt;
&lt;li&gt;若monitor进入数为0，线程可以进入monitor，此时该线程称为monitor的持有者（owner），并计数加一。&lt;/li&gt;
&lt;li&gt;若当前线程已经拥有monitor，是允许重新进入该monitor的，此时计数加一。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;获得锁，锁计数加一。失去锁，计数减一。计数为0，即为释放锁。&lt;strong&gt;释放锁的操作将会唤醒阻塞在同步队列中的的线程&lt;/strong&gt;，使其重新获得尝试对monitor的获取。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下图源自《Java并发编程得艺术》4-2&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTc3MTA3Mi8yMDIwMDIvMTc3MTA3Mi0yMDIwMDIxMzIyNTAxMzk3Ni0xNzY2MDIzOTc3LnBuZw?x-oss-process=image/format,png&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;新Java内存模型中提供了比锁更加轻量级的通信机制，它增强了volatile的内存语义，让volatile拥有和锁一样的语义：告知程序任何对volatile修饰变量的访问都要从共享内存中获取，对它的改变必须同步刷新回共享内存，&lt;strong&gt;保证了线程对变量访问的可见性&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;关于volatile的重点学习，之后再做总结。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;等待/通知&lt;/strong&gt;相关的方法被定义在&lt;code&gt;java.lang.Object&lt;/code&gt;上，这些&lt;strong&gt;方法必须由锁对象来调用&lt;/strong&gt;。同步实例方法为this，静态方法为类对象，代码块的锁是括号里的玩意儿。&lt;/p&gt;
&lt;p&gt;这些方法必须需要获取锁对象之后才能调用，也就是&lt;strong&gt;必须要在同步块中或同步方法中调用&lt;/strong&gt;，否则会抛出&lt;code&gt;IllegalMonitorStateException&lt;/code&gt;的异常。&lt;/p&gt;
&lt;h2 id=&quot;等待&quot;&gt;等待&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;wait()&lt;/code&gt; : 调用该方法的线程进入&lt;code&gt;WAITING&lt;/code&gt;状态，&lt;strong&gt;并释放对象的锁&lt;/strong&gt;，此时当前线程只有被其他线程通知或中断才会返回。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;wait(long)&lt;/code&gt;、&lt;code&gt;wait(long, int)&lt;/code&gt;：进入&lt;code&gt;TIMED_WAITING&lt;/code&gt;状态，释放锁，当前线程有通知或中断会返回，时间到了也会返回。&lt;/p&gt;
&lt;h2 id=&quot;通知&quot;&gt;通知&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;notify()&lt;/code&gt; : 当前线程通知一个在&lt;strong&gt;该对象&lt;/strong&gt;上等待的另一线程，被唤醒的线程从等待队列（WAITING)被移动到同步队列(BLOCKED)中，意思是被唤醒的线程不会立即执行，需要等当前线程释放锁之后，并且在同步队列中的线程得到了锁才能执行。&lt;br/&gt;&lt;code&gt;notifyAll()&lt;/code&gt; ：当前线程&lt;strong&gt;通知所有等待在该对象上的线程&lt;/strong&gt;，将所有在等待队列中的线程全部移到同步队列中。&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTc3MTA3Mi8yMDIwMDIvMTc3MTA3Mi0yMDIwMDIxMzIyNTAyMTY1MC0xNTEzMjY2NzcwLnBuZw?x-oss-process=image/format,png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;假设A和B需要获取&lt;strong&gt;同一把锁&lt;/strong&gt;，A进入之后，B进入同步队列，陷入阻塞（BLOCKED)。&lt;/p&gt;
&lt;p&gt;如果A中调用锁的wait()方法，A释放锁，并陷入等待(WAITING)。此时另外一个线程B获取的当前锁，B运行。&lt;/p&gt;
&lt;p&gt;如果此时B中调用锁的notify()方法，A被唤醒，从等待队列转移到同步队列，只有B运行完毕了，锁被释放了，A拿到锁了，A才出来运行。&lt;/p&gt;
&lt;p&gt;等待/通知机制依托于同步机制，&lt;strong&gt;确保等待线程从wait()方法返回时能够感知到通知线程对变量做出的修改&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;面试常问的几个问题&quot;&gt;面试常问的几个问题&lt;/h2&gt;
&lt;h3 id=&quot;sleep方法和wait方法的区别&quot;&gt;sleep方法和wait方法的区别&lt;/h3&gt;
&lt;p&gt;sleep()和wait()方法都可以让线程放弃CPU一段时间，&lt;strong&gt;进入等待（WAITING）状态&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;sleep()静态方法定义在Thread类中，wait()定义在Object类中。&lt;/p&gt;
&lt;p&gt;如果线程持有某个对象的监视器，&lt;strong&gt;wait()调用之后，当前线程会释放锁，而sleep()则不会释放这个锁&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;关于放弃对象监视器&quot;&gt;关于放弃对象监视器&lt;/h3&gt;
&lt;p&gt;对于放弃对象监视器，wait()方法和notify()/notifyAll()有一定区别：&lt;/p&gt;
&lt;p&gt;锁对象调用wait()方法之后，&lt;strong&gt;会立即释放对象监视器&lt;/strong&gt;。而notify()/notifyAll()则不会立即释放，而是等到线程剩余代码执行完毕之后才会释放监视器。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;通过wait()和notify()/notifyAll()可以有效地协调多个线程之间的工作，提高了线程通信的效率。&lt;/p&gt;
&lt;h2 id=&quot;生产者消费者模型&quot;&gt;生产者消费者模型&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;通过平衡生产者的生产能力和消费者能力来提升整个系统的运行效率。&lt;/li&gt;
&lt;li&gt;减少生产者与消费者之间的联系。实现很好的解耦。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面代码保留主要的思路，具体的视情况而定。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;定义一个简单的产品类Product，里面定义一个判断产品有无的标识位。&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    //产品
    public class Product {
        public boolean exist = false;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;然后定义消费方中的run方法。&lt;/strong&gt;&lt;br/&gt;首先获取对象的锁，如果产品不存在，则等待，否则消费一次，并把标识位置为false，并唤醒生产线程。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    //消费方
    synchronized (product) {
        while (true) {
            TimeUnit.SECONDS.sleep(1);
            while (!product.exist) {
                product.wait();
            }
            System.out.println(&quot;消费一次&quot;);
            product.exist = false;
            product.notifyAll();
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;生产方与消费方对应，依旧是先获取对象的锁，然后对标识位进行判断，如果已经有产品了，就等待，否则就生产一次，并把标识位附为true，最后唤醒正在等待的消费方。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    //生产方
    synchronized (product) {
        while (true) {
            TimeUnit.SECONDS.sleep(1);
            while (product.exist) {
                product.wait();
            }
            System.out.println(&quot;生产一次&quot;);
            product.exist = true;
            product.notifyAll();
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个过程是最基本的，我们更需要理解wait()，notify()等方法带来的便利之处。在真实场景更加复杂的情况下，比如在生产与消费速度不对等的情况下，需要创建缓冲区等等。&lt;/p&gt;
&lt;h2 id=&quot;可能会出错的代码&quot;&gt;可能会出错的代码&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    //T1
    synchronized (product) {
            product.exist = false;
            product.notifyAll();
        }
    }

    //T2
    synchronized(product){
        while(product.exist)
            product.wait();
    }
    
    //T3
    while (product.exist) {
        //A
        synchronized(product){
            product.wait();
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;假设T1和T3是通信双方，这时就可能会产生&lt;strong&gt;通知丢失&lt;/strong&gt;的情况：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;假设T3还没有获得锁，运行到A点，这时线程调度器将资源分给T1线程，此时T3在A点阻塞。&lt;/li&gt;
&lt;li&gt;T1线程中希望阻止T3陷入等待，于是将标识符设置位false，在标识位上出现了竞争。&lt;/li&gt;
&lt;li&gt;但是当T1执行完毕，T3继续执行的时候，并不能知道这个标识位已经发生改变，于是它将会永久陷入等待。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;于是，我们可以学习到一点，为了消除多个线程在标识位上出现的竞争，我们可以&lt;strong&gt;采用T2的形式，给线程上一把锁&lt;/strong&gt;，保证被通知之后先检查条件是否符合。&lt;/p&gt;

&lt;p&gt;我们之前也学习过，使用显式的Lock对象来保证线程同步的话，隐式的监视器就不存在了，也就无法使用wait()和notify()/notifyAll()。&lt;/p&gt;
&lt;p&gt;Java提供了&lt;code&gt;Condition&lt;/code&gt;接口来保持线程之间的协调通信，通过&lt;strong&gt;Condition对象和Lock对象的配合&lt;/strong&gt;，可以完成synchronized同步方法与代码块完成的任务。&lt;/p&gt;
&lt;p&gt;我很好奇Condition和Lock是怎么建立联系的，于是查看了它们的继承关系：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;Condition接口是JDK1.5出现的，该接口提供的方法被ConditionObject类实现，该类是AbstractQueuedSynchronizer（AQS）的内部类，而ReentrantLock类内部维护了一个Sync对象，Sync拥有一个返回ConditionObject实例的方法，Sync继承于AQS。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;condition接口内的方法详解&quot;&gt;Condition接口内的方法详解&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;参考JDK1.8官方文档&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;void await() throws InterruptedException;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当前线程进入等待状态直到被通知或者中断，当前线程进入运行状态且从await()方法返回的四种情况：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;其他线程调用这个条件的signal()方法，且&lt;strong&gt;当前线程被选择为要唤醒的线程&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;其他线程会为此条件调用signalAll()方法。&lt;/li&gt;
&lt;li&gt;其他线程中断当前线程。&lt;/li&gt;
&lt;li&gt;发生”虚假唤醒“现象，参考：&lt;a href=&quot;https://www.jianshu.com/p/0eff666a4875&quot;&gt;虚假唤醒（spurious wakeup）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;需要注意的是：在上面所有情况下，&lt;strong&gt;要想从await()返回，当前线程必须重新获取与此条件关联的锁&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;void awaitUninterruptibly()&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当前线程进入等待状态直到被通知，它对中断不敏感，因此他从等待状态返回的场景区别于await()，仅仅少了第三点中断场景。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;long awaitNanos(long nanosTimeout) throws InterruptedException&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;该方法导致当前线程等待，直到被通知、中断，或超时。该方法根据返回时提供的nanosTimeout值，返回剩余等待的纳秒数的估计值，如果超时，则返回小于或等于零的值。此值可用于确定在等待返回但等待条件仍然无效的情况下是否需要重新等待，以及需要多长时间重新等待。&lt;/p&gt;
&lt;p&gt;还有零一个类似的方法就不赘述了。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;boolean awaitUntil(Date deadline) throws InterruptedException&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;该方法导致当前线程等待，直到被通知或中断，或到了指定的截止日期。如果返回时截止日期已经过了，则为false，否则为true。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;void signal()&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;唤醒一个正在等待的线程，被唤醒的线程想要从await方法返回需要重新获得Condition相关联的锁。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;void signalAll()&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;唤醒所有等待的线程，同样的，想要从await方法返回就必须重新获得Condition相关联锁。&lt;/p&gt;
&lt;h2 id=&quot;condition与lock配合&quot;&gt;Condition与Lock配合&lt;/h2&gt;
&lt;p&gt;Condition接口依赖于Lock，我们可以这样创建特定Lock实例的Condition实例：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Lock lock = new ReentrantLock(); //创建Lock对象
Condition condition = lock.newCondition(); //利用lock对象的newCondition()创建Condition对象&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;既然具有依赖关系，那么只有获取了lock，才可以调用Condition中提供的方法，也就是只能在Lock.lock()与Lock.unlock()之间调用。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;官方文档给出的定义：Condition的存在可以将&lt;strong&gt;对象监视器&lt;/strong&gt;方法(wait、notify和notifyAll)分解到不同的对象中，通过将它们与任意Lock实现结合使用，实现每个对象具有多个等待集的效果。锁代替同步方法和语句的使用，条件代替对象监视器方法的使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一个Lock对象可以关联多个Condition对象，分别作为不同的条件检测，这里给一个简易版生产者消费者模型的Demo：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先定义一个公共产品类，在类中定义相应的生产、消费逻辑。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Product {
    //共享产品编号
    private int count = 0;
    //标识位，标识是否还有产品
    private boolean flag = false;

    //创建Lock锁对象
    private Lock lock = new ReentrantLock();
    //创建两个Condition对象，作为两种条件检测
    private Condition condProducer = lock.newCondition();
    private Condition condConsumer = lock.newCondition();

    //生产方法
    public void produce() {
        lock.lock(); //上锁
        try {
            //驱使线程等待的条件
            while (flag) {
                condProducer.await(); //如果flag为true，则不用生产
            }
            count++;
            System.out.println(Thread.currentThread().getName() + &quot;生产产品一件,产品编号&quot; + count);
            //生产完成，将标识为改为false
            flag = true;
            //唤醒conConsumer条件下的所有线程（当然，这里只有一个）
            condConsumer.signalAll();

        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();//在finally中，保证解锁
        }
    }
    //消费方法
    public void consume() {
        lock.lock();
        try {
            //驱使线程等待的条件
            while (!flag) {
                condConsumer.await(); //如果flag为false，则不用消费
            }

            //消费的逻辑
            System.out.println(Thread.currentThread().getName() + &quot;消费产品一件,产品编号&quot; + count);
            flag = false;
            condProducer.signalAll();

        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;然后创建生产者Producer和消费者Consumer两个线程类，只需将公共产品对象传入构造器中，使其建立联系。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//生产者线程
class Producer implements Runnable {
    private Product product;

    Producer(Product product) {
        this.product = product;
    }

    @Override
    public void run() {
        //每个生产者线程生产会生产五件产品
        for (int i = 0; i &amp;lt; 5; i++) {
            product.produce();
        }
    }
}
//消费者线程
class Consumer implements Runnable {
    private Product product;

    Consumer(Product product) {
        this.product = product;
    }

    @Override
    public void run() {
        //每个消费者线程会消费五件产品
        for (int i = 0; i &amp;lt; 5; i++) {
            product.consume();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还是那个问题：我们需要用wait(）方法需要被包含在while循环语句中，防止过早或意外的通知，保证只有不符合等待的条件才能退出循环。换句话说，使用while循环而不用if判断可以有效防止”虚假唤醒“的现象。&lt;/p&gt;
&lt;h2 id=&quot;condition接口与object监视器&quot;&gt;Condition接口与Object监视器&lt;/h2&gt;
&lt;p&gt;下表参考自《Java并发编程的艺术》方腾飞&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;14&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;前置条件&lt;/td&gt;
&lt;td&gt;获取对象的锁&lt;/td&gt;
&lt;td&gt;Lock.lock()获取锁、Lock.newCondition()获取Condition对象&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;调用方式&lt;/td&gt;
&lt;td&gt;如object.wait()&lt;/td&gt;
&lt;td&gt;如condition.await()&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;等待队列个数&lt;/td&gt;
&lt;td&gt;一个&lt;/td&gt;
&lt;td&gt;多个&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;释放锁、进入等待&lt;/td&gt;
&lt;td&gt;支持、如void wait()&lt;/td&gt;
&lt;td&gt;支持、如void await()&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;6&quot;&gt;&lt;td&gt;释放锁、进入超时等待&lt;/td&gt;
&lt;td&gt;支持、如void wait(long )&lt;/td&gt;
&lt;td&gt;支持long awaitNanos(long)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;释放锁、进入等待状态到将来某个时间&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;支持、例如 long awaitNanos(long)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;等待状态不响应中断&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;支持、例如 void awaitUninterruptibly()&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;6&quot;&gt;&lt;td&gt;唤醒等待队列中的一个线程&lt;/td&gt;
&lt;td&gt;支持、如void notify()&lt;/td&gt;
&lt;td&gt;支持、如 void signal()&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;6&quot;&gt;&lt;td&gt;唤醒等待队列中的所有线程&lt;/td&gt;
&lt;td&gt;支持、如void notifyAll()&lt;/td&gt;
&lt;td&gt;支持、如void signalAll()&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;hr/&gt;&lt;p&gt;关于Condition和Lock，之后会有相关文章对它们进行更详细的系统学习，本篇文章主要理解它们进行线程通信的基本方法。&lt;/p&gt;

&lt;p&gt;管道输入输出流主要用于&lt;strong&gt;线程之间的数据传输&lt;/strong&gt;，传输媒介为内存。&lt;/p&gt;
&lt;p&gt;面向字节：PipedOutputStream、PipedInputStream&lt;br/&gt;面向字符：PipedWriter、PipedReader&lt;/p&gt;
&lt;p&gt;下面是一个通过管道输入输出流完成线程间通信：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Piped {
    public static void main(String[] args) throws IOException {
        //创建管道输入输出流
        PipedWriter out = new PipedWriter();
        PipedReader in = new PipedReader();

        //将输入输出流连结起来，否则在使用的时候会抛出异常
        out.connect(in);
        Thread printThread = new Thread(new Print(in),&quot;PrintThread&quot;);
        printThread.start();
        
        //标准输入流转化到管道输出流
        int receive;
        try{
            while((receive = System.in.read())!=-1){
                out.write(receive);
            }
        }finally {
            out.close();
        }
    }

    //定义线程类，接收管道输入流，写入标准输出流
    static class Print implements Runnable{
        private PipedReader in;
        public Print(PipedReader in){
            this.in = in;
        }
        @Override
        public void run() {
            int receive;
            try{
                while((receive = in.read())!=-1){
                    System.out.print((char)receive);
                }
            }catch (IOException e){
                e.printStackTrace();
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;关于join方法，之前已经做过相应的总结，这边就不再做详细的说明。&lt;/p&gt;
&lt;p&gt;官方解释简洁明了：&lt;code&gt;Waits for this thread to die.&lt;/code&gt;，很明显，针对线程来说，谁调用，等谁死。举个例子：&lt;u&gt;当在A线程中调用B线程的join()方法时，A线程将会陷入等待或超时等待，直到B线程执行完毕消亡才转变为阻塞&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;join()方法具体有三个：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//等待该线程消亡。
public final void join()
//等待该线程消亡，只不过最多等millis毫秒。
public final synchronized void join(long millis)
//等待该线程消亡，只不过最多等millis毫秒+nanos纳秒（毫微秒）。
public final synchronized void join(long millis, int nanos)
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;同样的，关于ThreadLocal更详细的学习会在之后出炉，本篇着重理解通信方法。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ThreadLocal&lt;/code&gt;，是&lt;strong&gt;线程局部变量&lt;/strong&gt;，它是一个以&lt;code&gt;ThreadLocal&lt;/code&gt;对象为键、&lt;strong&gt;任意对象为值&lt;/strong&gt;的存储结构，该结构被附带在线程上，线程可以根据一个Thread对象查询到绑定在这个线程上的值。&lt;/p&gt;
&lt;p&gt;它为每一个使用该变量的线程都提供了一个变量值的副本，使得&lt;strong&gt;每一个线程都可以独立地改变自己的副本&lt;/strong&gt;，而不会产生多个线程在操作共享数据经过主内存时产生的数据竞争的问题。&lt;/p&gt;
&lt;p&gt;我们可以利用set和get，设置和取出局部变量的值。需要明确的是：不管有多少个线程，用ThreadLocal定义了局部变量，就会在线程中各自产生一份副本，自此，&lt;strong&gt;各个线程之间的读和写操作互不相关&lt;/strong&gt;，我们可以利用这一性质，完成我们特殊的需求。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Profiler {
    // 定义一个ThreadLocal类型的变量，该变量是一个线程局部变量
    private static final ThreadLocal&amp;lt;Long&amp;gt; TIME_THREADLOCAL = new ThreadLocal&amp;lt;Long&amp;gt;(){
        //重写方法，为该局部变量赋初始值
        protected Long initialValue(){
            return System.currentTimeMillis();
        }
    };
    //public void set(T value)，设置该局部变量值
    public static  final void begin(){
        TIME_THREADLOCAL.set(System.currentTimeMillis());
    }
    //public T get() ，取出该局部变量的值
    public static final long cost(){
        return System.currentTimeMillis() - TIME_THREADLOCAL.get();
    }
    //测试
    public static void main(String[] args) throws Exception{
        Profiler.begin();
        TimeUnit.SECONDS.sleep(1);
        System.out.println(&quot;Cost: &quot;+ Profiler.cost()+&quot; mills&quot;);

    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面使用案例摘自《Java并发编程的艺术》，关于ThreadLocal更详细的分析，之后会再做总结。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;参考：《Java并发编程的艺术》、JDK官方文档&lt;/p&gt;
</description>
<pubDate>Sat, 15 Feb 2020 15:28:00 +0000</pubDate>
<dc:creator>天乔巴夏丶</dc:creator>
<og:description>[toc] 在并发编程中，保证线程同步，从而 实现线程之间正确通信 ，是一个值得考虑的问题。本篇将参考许多著名书籍，学习如何让多个线程之间相互配合，完成我们指定的任务。 一、synchronized</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/summerday152/p/12315274.html</dc:identifier>
</item>
<item>
<title>微信小程序—Flex布局 - Pam_sh</title>
<link>http://www.cnblogs.com/pam-sh/p/12315257.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pam-sh/p/12315257.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;语法：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;一、Flex 布局是什么？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;Flex 是 Flexible Box 的缩写，意为&quot;弹性布局&quot;，用来为盒状模型提供最大的灵活性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;任何一个容器都可以指定为 Flex 布局。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre class=&quot; language-css&quot;&gt;
&lt;span&gt;&lt;code class=&quot; language-css&quot;&gt;
&lt;span class=&quot;token selector&quot;&gt;.box&lt;span class=&quot;token punctuation&quot;&gt;{
  &lt;span class=&quot;token property&quot;&gt;display&lt;span class=&quot;token punctuation&quot;&gt;: flex&lt;span class=&quot;token punctuation&quot;&gt;;
&lt;span class=&quot;token punctuation&quot;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;行内元素也可以使用 Flex 布局。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;pre class=&quot; language-css&quot;&gt;
&lt;span&gt;&lt;code class=&quot; language-css&quot;&gt;
&lt;span class=&quot;token selector&quot;&gt;.box&lt;span class=&quot;token punctuation&quot;&gt;{
  &lt;span class=&quot;token property&quot;&gt;display&lt;span class=&quot;token punctuation&quot;&gt;: inline-flex&lt;span class=&quot;token punctuation&quot;&gt;;
&lt;span class=&quot;token punctuation&quot;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;Webkit 内核的浏览器 (苹果系统），必须加上&lt;code&gt;-webkit&lt;/code&gt;前缀。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;pre class=&quot; language-css&quot;&gt;
&lt;span&gt;&lt;code class=&quot; language-css&quot;&gt;
&lt;span class=&quot;token selector&quot;&gt;.box&lt;span class=&quot;token punctuation&quot;&gt;{
  &lt;span class=&quot;token property&quot;&gt;display&lt;span class=&quot;token punctuation&quot;&gt;: -webkit-flex&lt;span class=&quot;token punctuation&quot;&gt;; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;注意，设为 Flex 布局以后，子元素的&lt;code&gt;float&lt;/code&gt;、&lt;code&gt;clear&lt;/code&gt;和&lt;code&gt;vertical-align&lt;/code&gt;属性将失效。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;二、基本概念&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;采用 Flex 布局的元素，称为 Flex 容器（flex container），简称&quot;&lt;span&gt;容器&lt;/span&gt;&quot;。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称&quot;&lt;span&gt;项目&lt;/span&gt;&quot;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img title=&quot;&quot; src=&quot;http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071004.png&quot; alt=&quot;&quot; width=&quot;504&quot; height=&quot;298&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做&lt;code&gt;main start&lt;/code&gt;，结束位置叫做&lt;code&gt;main end&lt;/code&gt;；交叉轴的开始位置叫做&lt;code&gt;cross start&lt;/code&gt;，结束位置叫做&lt;code&gt;cross end&lt;/code&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;项目默认沿主轴排列。单个项目占据的主轴空间叫做&lt;code&gt;main size&lt;/code&gt;，占据的交叉轴空间叫做&lt;code&gt;cross size&lt;/code&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;三、容器的属性&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;以下6个属性设置在容器上。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;flex-direction&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;flex-wrap&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;flex-flow&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;justify-content&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;align-items&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;align-content&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3&gt;&lt;span&gt;3.1 flex-direction属性&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;　　flex-direction&lt;/code&gt;属性决定&lt;span&gt;主轴&lt;/span&gt;的方向（即项目的排列方向）。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;pre class=&quot; language-css&quot;&gt;
&lt;span&gt;&lt;code class=&quot; language-css&quot;&gt;
&lt;span class=&quot;token selector&quot;&gt;.box &lt;span class=&quot;token punctuation&quot;&gt;{
  &lt;span class=&quot;token property&quot;&gt;flex-direction&lt;span class=&quot;token punctuation&quot;&gt;: row | row-reverse | column | column-reverse&lt;span class=&quot;token punctuation&quot;&gt;;
&lt;span class=&quot;token punctuation&quot;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;img title=&quot;&quot; src=&quot;http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071005.png&quot; alt=&quot;&quot; width=&quot;545&quot; height=&quot;139&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　它可能有4个值。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;code&gt;row&lt;/code&gt;（默认值）：主轴为水平方向，起点在左端。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;code&gt;row-reverse&lt;/code&gt;：主轴为水平方向，起点在右端。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;code&gt;column&lt;/code&gt;：主轴为垂直方向，起点在上沿。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;code&gt;column-reverse&lt;/code&gt;：主轴为垂直方向，起点在下沿。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3&gt;&lt;span&gt;3.2 flex-wrap属性&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　默认情况下，项目都排在一条线（又称&quot;轴线&quot;）上。&lt;code&gt;flex-wrap&lt;/code&gt;属性定义，如果一条轴线排不下，如何换行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img title=&quot;&quot; src=&quot;http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071006.png&quot; alt=&quot;&quot; width=&quot;543&quot; height=&quot;188&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;pre class=&quot; language-css&quot;&gt;
&lt;span&gt;&lt;code class=&quot; language-css&quot;&gt;
&lt;span class=&quot;token selector&quot;&gt;.box&lt;span class=&quot;token punctuation&quot;&gt;{
  &lt;span class=&quot;token property&quot;&gt;flex-wrap&lt;span class=&quot;token punctuation&quot;&gt;: nowrap | wrap | wrap-reverse&lt;span class=&quot;token punctuation&quot;&gt;;
&lt;span class=&quot;token punctuation&quot;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;　　它可能取三个值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）&lt;code&gt;nowrap&lt;/code&gt;（默认）：不换行（多的则自动调整）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img title=&quot;&quot; src=&quot;http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071007.png&quot; alt=&quot;&quot; width=&quot;521&quot; height=&quot;108&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）&lt;code&gt;wrap&lt;/code&gt;：换行，第一行在上方。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img title=&quot;&quot; src=&quot;http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071008.jpg&quot; alt=&quot;&quot; width=&quot;585&quot; height=&quot;148&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）&lt;code&gt;wrap-reverse&lt;/code&gt;：换行，第一行在下方。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img title=&quot;&quot; src=&quot;http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071009.jpg&quot; alt=&quot;&quot; width=&quot;605&quot; height=&quot;153&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;3.3 flex-flow&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;flex-flow&lt;/code&gt;属性是&lt;code&gt;flex-direction&lt;/code&gt;属性和&lt;code&gt;flex-wrap&lt;/code&gt;属性的简写形式，默认值为&lt;code&gt;row nowrap&lt;/code&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;pre class=&quot; language-css&quot;&gt;
&lt;span&gt;&lt;code class=&quot; language-css&quot;&gt;
&lt;span class=&quot;token selector&quot;&gt;.box &lt;span class=&quot;token punctuation&quot;&gt;{
  &lt;span class=&quot;token property&quot;&gt;flex-flow&lt;span class=&quot;token punctuation&quot;&gt;: &lt;span class=&quot;token ignore&quot;&gt;&amp;lt;flex-direction&amp;gt; || &lt;span class=&quot;token ignore&quot;&gt;&amp;lt;flex-wrap&amp;gt;&lt;span class=&quot;token punctuation&quot;&gt;;
&lt;span class=&quot;token punctuation&quot;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;h3&gt;&lt;span&gt;3.4 justify-content属性&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;justify-content&lt;/code&gt;属性定义了项目在主轴上的对齐方式。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;pre class=&quot; language-css&quot;&gt;
&lt;span&gt;&lt;code class=&quot; language-css&quot;&gt;
&lt;span class=&quot;token selector&quot;&gt;.box &lt;span class=&quot;token punctuation&quot;&gt;{
  &lt;span class=&quot;token property&quot;&gt;justify-content&lt;span class=&quot;token punctuation&quot;&gt;: flex-start | flex-end | center | space-between | space-around&lt;span class=&quot;token punctuation&quot;&gt;;
&lt;span class=&quot;token punctuation&quot;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;img title=&quot;&quot; src=&quot;http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071010.png&quot; alt=&quot;&quot; width=&quot;570&quot; height=&quot;683&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;code&gt;flex-start&lt;/code&gt;（默认值）：左对齐&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;code&gt;flex-end&lt;/code&gt;：右对齐&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;code&gt;center&lt;/code&gt;： 居中&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;code&gt;space-between&lt;/code&gt;：两端对齐，项目之间的间隔都相等。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;code&gt;space-around&lt;/code&gt;：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3&gt;&lt;span&gt;3.5 align-items属性&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;align-items&lt;/code&gt;属性定义项目在交叉轴上如何对齐。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;pre class=&quot; language-css&quot;&gt;
&lt;span&gt;&lt;code class=&quot; language-css&quot;&gt;
&lt;span class=&quot;token selector&quot;&gt;.box &lt;span class=&quot;token punctuation&quot;&gt;{
  &lt;span class=&quot;token property&quot;&gt;align-items&lt;span class=&quot;token punctuation&quot;&gt;: flex-start | flex-end | center | baseline | stretch&lt;span class=&quot;token punctuation&quot;&gt;;
&lt;span class=&quot;token punctuation&quot;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;img title=&quot;&quot; src=&quot;http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071011.png&quot; alt=&quot;&quot; width=&quot;597&quot; height=&quot;760&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;code&gt;flex-start&lt;/code&gt;：交叉轴的起点对齐。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;code&gt;flex-end&lt;/code&gt;：交叉轴的终点对齐。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;code&gt;center&lt;/code&gt;：交叉轴的中点对齐。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;code&gt;baseline&lt;/code&gt;: 项目的第一行文字的基线对齐。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;code&gt;stretch&lt;/code&gt;（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3&gt;&lt;span&gt;3.6 align-content属性&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;align-content&lt;/code&gt;属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;pre class=&quot; language-css&quot;&gt;
&lt;span&gt;&lt;code class=&quot; language-css&quot;&gt;
&lt;span class=&quot;token selector&quot;&gt;.box &lt;span class=&quot;token punctuation&quot;&gt;{
  &lt;span class=&quot;token property&quot;&gt;align-content&lt;span class=&quot;token punctuation&quot;&gt;: flex-start | flex-end | center | space-between | space-around | stretch&lt;span class=&quot;token punctuation&quot;&gt;;
&lt;span class=&quot;token punctuation&quot;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;img title=&quot;&quot; src=&quot;http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071012.png&quot; alt=&quot;&quot; width=&quot;561&quot; height=&quot;711&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;该属性可能取6个值。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;code&gt;flex-start&lt;/code&gt;：与交叉轴的起点对齐。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;code&gt;flex-end&lt;/code&gt;：与交叉轴的终点对齐。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;code&gt;center&lt;/code&gt;：与交叉轴的中点对齐。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;code&gt;space-between&lt;/code&gt;：与交叉轴两端对齐，轴线之间的间隔平均分布。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;code&gt;space-around&lt;/code&gt;：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;code&gt;stretch&lt;/code&gt;（默认值）：轴线占满整个交叉轴。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3&gt;&lt;span&gt;四、项目的属性&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;以下6个属性设置在项目上。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;code&gt;order&lt;/code&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;code&gt;flex-grow&lt;/code&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;code&gt;flex-shrink&lt;/code&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;code&gt;flex-basis&lt;/code&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;code&gt;flex&lt;/code&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;code&gt;align-self&lt;/code&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3&gt;&lt;span&gt;4.1 order属性&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;order&lt;/code&gt;属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;pre class=&quot; language-css&quot;&gt;
&lt;span&gt;&lt;code class=&quot; language-css&quot;&gt;
&lt;span class=&quot;token selector&quot;&gt;.item &lt;span class=&quot;token punctuation&quot;&gt;{
  &lt;span class=&quot;token property&quot;&gt;order&lt;span class=&quot;token punctuation&quot;&gt;: &lt;span class=&quot;token ignore&quot;&gt;&amp;lt;integer&amp;gt;&lt;span class=&quot;token punctuation&quot;&gt;;
&lt;span class=&quot;token punctuation&quot;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;img title=&quot;&quot; src=&quot;http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071013.png&quot; alt=&quot;&quot; width=&quot;594&quot; height=&quot;380&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;4.2 flex-grow属性&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;flex-grow&lt;/code&gt;属性定义项目的放大比例，默认为&lt;code&gt;0&lt;/code&gt;，即如果存在剩余空间，也不放大。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;pre class=&quot; language-css&quot;&gt;
&lt;span&gt;&lt;code class=&quot; language-css&quot;&gt;
&lt;span class=&quot;token selector&quot;&gt;.item &lt;span class=&quot;token punctuation&quot;&gt;{
  &lt;span class=&quot;token property&quot;&gt;flex-grow&lt;span class=&quot;token punctuation&quot;&gt;: &lt;span class=&quot;token ignore&quot;&gt;&amp;lt;number&amp;gt;&lt;span class=&quot;token punctuation&quot;&gt;; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;img title=&quot;&quot; src=&quot;http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071014.png&quot; alt=&quot;&quot; width=&quot;646&quot; height=&quot;170&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果所有项目的&lt;code&gt;flex-grow&lt;/code&gt;属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的&lt;code&gt;flex-grow&lt;/code&gt;属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;4.3 flex-shrink属性&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;flex-shrink&lt;/code&gt;属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;pre class=&quot; language-css&quot;&gt;
&lt;span&gt;&lt;code class=&quot; language-css&quot;&gt;
&lt;span class=&quot;token selector&quot;&gt;.item &lt;span class=&quot;token punctuation&quot;&gt;{
  &lt;span class=&quot;token property&quot;&gt;flex-shrink&lt;span class=&quot;token punctuation&quot;&gt;: &lt;span class=&quot;token ignore&quot;&gt;&amp;lt;number&amp;gt;&lt;span class=&quot;token punctuation&quot;&gt;; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;img title=&quot;&quot; src=&quot;http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071015.jpg&quot; alt=&quot;&quot; width=&quot;603&quot; height=&quot;125&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果所有项目的&lt;code&gt;flex-shrink&lt;/code&gt;属性都为1，当空间不足时，都将等比例缩小。如果一个项目的&lt;code&gt;flex-shrink&lt;/code&gt;属性为0，其他项目都为1，则空间不足时，前者不缩小。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;负值对该属性无效。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;4.4 flex-basis属性&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;flex-basis&lt;/code&gt;属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为&lt;code&gt;auto&lt;/code&gt;，即项目的本来大小。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;pre class=&quot; language-css&quot;&gt;
&lt;span&gt;&lt;code class=&quot; language-css&quot;&gt;
&lt;span class=&quot;token selector&quot;&gt;.item &lt;span class=&quot;token punctuation&quot;&gt;{
  &lt;span class=&quot;token property&quot;&gt;flex-basis&lt;span class=&quot;token punctuation&quot;&gt;: &lt;span class=&quot;token ignore&quot;&gt;&amp;lt;length&amp;gt; | auto&lt;span class=&quot;token punctuation&quot;&gt;; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;它可以设为跟&lt;code&gt;width&lt;/code&gt;或&lt;code&gt;height&lt;/code&gt;属性一样的值（比如350px），则项目将占据固定空间。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;4.5 flex属性&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;flex&lt;/code&gt;属性是&lt;code&gt;flex-grow&lt;/code&gt;, &lt;code&gt;flex-shrink&lt;/code&gt; 和 &lt;code&gt;flex-basis&lt;/code&gt;的简写，默认值为&lt;code&gt;0 1 auto&lt;/code&gt;。后两个属性可选。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;pre class=&quot; language-css&quot;&gt;
&lt;span&gt;&lt;code class=&quot; language-css&quot;&gt;
&lt;span class=&quot;token selector&quot;&gt;.item &lt;span class=&quot;token punctuation&quot;&gt;{
  &lt;span class=&quot;token property&quot;&gt;flex&lt;span class=&quot;token punctuation&quot;&gt;: none | [ &lt;span class=&quot;token ignore&quot;&gt;&amp;lt;&lt;span class=&quot;token string&quot;&gt;'flex-grow'&amp;gt; &lt;span class=&quot;token ignore&quot;&gt;&amp;lt;&lt;span class=&quot;token string&quot;&gt;'flex-shrink'&amp;gt;? || &lt;span class=&quot;token ignore&quot;&gt;&amp;lt;&lt;span class=&quot;token string&quot;&gt;'flex-basis'&amp;gt; ]
&lt;span class=&quot;token punctuation&quot;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;该属性有两个快捷值：&lt;code&gt;auto&lt;/code&gt; (&lt;code&gt;1 1 auto&lt;/code&gt;) 和 none (&lt;code&gt;0 0 auto&lt;/code&gt;)。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;4.6 align-self属性&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;align-self&lt;/code&gt;属性允许单个项目有与其他项目不一样的对齐方式，可覆盖&lt;code&gt;align-items&lt;/code&gt;属性。默认值为&lt;code&gt;auto&lt;/code&gt;，表示继承父元素的&lt;code&gt;align-items&lt;/code&gt;属性，如果没有父元素，则等同于&lt;code&gt;stretch&lt;/code&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;pre class=&quot; language-css&quot;&gt;
&lt;span&gt;&lt;code class=&quot; language-css&quot;&gt;
&lt;span class=&quot;token selector&quot;&gt;.item &lt;span class=&quot;token punctuation&quot;&gt;{
  &lt;span class=&quot;token property&quot;&gt;align-self&lt;span class=&quot;token punctuation&quot;&gt;: auto | flex-start | flex-end | center | baseline | stretch&lt;span class=&quot;token punctuation&quot;&gt;;
&lt;span class=&quot;token punctuation&quot;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;img title=&quot;&quot; src=&quot;http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071016.png&quot; alt=&quot;&quot; width=&quot;574&quot; height=&quot;301&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;该属性可能取6个值，除了auto，其他都与align-items属性完全一致。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 15 Feb 2020 15:24:00 +0000</pubDate>
<dc:creator>Pam_sh</dc:creator>
<og:description>参考教程：http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html https://xluos.github.io/demo/flexbox/</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/pam-sh/p/12315257.html</dc:identifier>
</item>
<item>
<title>c++中的 static 关键字 - PRO_Z</title>
<link>http://www.cnblogs.com/nbk-zyc/p/12305170.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nbk-zyc/p/12305170.html</guid>
<description>&lt;p&gt;注：若没有特指是 静态成员时，默认都是普通成员；&lt;/p&gt;
&lt;p&gt;1 类中的普通成员&lt;/p&gt;
&lt;p&gt;　　类中的成员变量 和 成员函数 是分开存储的。其中，&lt;/p&gt;
&lt;p&gt;　　　　1）每个对象都有&lt;span&gt;独立的成员变量&lt;/span&gt;；成员变量可以存储在 栈空间、堆空间、全局数据区；&lt;/p&gt;
&lt;p&gt;　　　　2）所有对象&lt;span&gt;共享类的成员函数&lt;/span&gt;；成员函数 只能存储在 代码段；&lt;/p&gt;
&lt;p&gt;2 类中的静态成员（&lt;span&gt;static&lt;/span&gt;）&lt;/p&gt;
&lt;p&gt;　　类中的静态成员&lt;/p&gt;
&lt;p&gt;　　　　1、用 &lt;span&gt;static&lt;/span&gt;关键字 修饰；&lt;/p&gt;
&lt;p&gt;　　　　2、可以用 &lt;span&gt;类名::成员名&lt;/span&gt;  访问 静态成员；&lt;/p&gt;
&lt;p&gt;　　　　3、静态成员  属于  整个类；&lt;/p&gt;
&lt;p&gt;　　　　4、静态成员 是所属类的成员，其它类不能访问；&lt;/p&gt;
&lt;p&gt;　　　　5、静态成员的内存分配 是 唯一的；&lt;/p&gt;
&lt;p&gt;　　1) 静态成员变量 &lt;/p&gt;
&lt;p&gt;　　　　特征：1、静态成员变量  属于  &lt;span&gt;整个类所有&lt;/span&gt;；&lt;/p&gt;
&lt;p&gt;　　　　　　　2、静态成员变量的生命周期不依赖任何对象；（静态成员变量的生命周期在程序的运行期）&lt;/p&gt;
&lt;p&gt;　　　　　　　3、所有对象&lt;span&gt;共享&lt;/span&gt;类的静态成员变量；&lt;/p&gt;
&lt;p&gt;　　　　　　　4、可以通过  &lt;span&gt;类名&lt;/span&gt;  直接访问&lt;span&gt;公有的&lt;/span&gt;静态成员变量；&lt;/p&gt;
&lt;p&gt;　　　　　　　5、可以通过 &lt;span&gt;对象名&lt;/span&gt;  访问公有的静态成员变量；&lt;/p&gt;
&lt;p&gt;　　　　　　　6、静态成员变量  需要在&lt;span&gt;类外单独分配空间&lt;/span&gt;；（类内声明、类外定义并初始化）&lt;/p&gt;
&lt;p&gt;　　　　　　    7、静态成员变量  在程序内部位于&lt;span&gt;全局数据区，不计入类的内存计算。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;span&gt;原因/&lt;/span&gt;&lt;span&gt;好处：使用静态成员变量实现多个对象之间的数据共享不会破坏隐藏的原则，保证了安全性还可以节省内存&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;/span&gt;使用方法：&lt;/p&gt;
&lt;p&gt;　　　　　　1、在类的内部，使用 static 修饰普通成员变量；&lt;/p&gt;
&lt;p&gt;　　　　　　2、在类的外部（全局作用域），使用 Type ClassName::VarName = value 初始化，并申请存储空间；&lt;/p&gt;
&lt;p&gt;　　　　　　　&lt;span&gt; &lt;/span&gt; 注：静态成员变量不属于类的任何对象，所以并不是对象建立时被定义的，所以&lt;span&gt;&lt;span&gt;它不能由类的构造函数初始化&lt;/span&gt;，一般也&lt;span&gt;不能在类内初始化&lt;/span&gt;；&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    静态成员变量 只能在类的内部声明，在类的外部（全局区）定义和初始化；
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; #include &amp;lt;iostream&amp;gt;
&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test{
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; GetA() &lt;span&gt;const&lt;/span&gt;{&lt;span&gt;return&lt;/span&gt;&lt;span&gt; a;}
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;private&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; a;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 静态成员变量&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;int Test::a;如果这样定义不赋予初值，则初值为零&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Test::a = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;argv[])
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    Test T;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;     cout &amp;lt;&amp;lt; T.GetA() &amp;lt;&amp;lt;&lt;span&gt; endl;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　静态成员变量 被类的所有对象共享，包括派生类对象；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; #include &amp;lt;iostream&amp;gt;
&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Base{
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; a;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 静态成员变量&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; int Test::a;如果这样定义不赋予初值，则初值为零&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; Base::a;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Derived : &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Base{
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;  
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;argv[])
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    Base B;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    Derived D;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;     B.a++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     cout &amp;lt;&amp;lt; B.a &amp;lt;&amp;lt; endl;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;     D.a++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     cout &amp;lt;&amp;lt; D.a &amp;lt;&amp;lt; endl;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　静态成员变量可以作为普通成员函数的默认形参，而普通成员变量则不可以；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test{
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; a;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;静态成员变量&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; b;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; fun_1(&lt;span&gt;int&lt;/span&gt; i = a); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;正确
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;void fun_2(int i = b); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;报错&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt; };
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　静态成员变量的类型 可以是所属类的类型，而普通成员变量则不可以。普通成员变量只能声明为 所属类类型的 指针或引用；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test{
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt; Test a;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;正确&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;     Test b;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;报错&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;     Test *pTest;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;正确&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt;     Test &amp;amp;m_Test;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;正确&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt; Test *pStaticObject;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;正确&lt;/span&gt;
&lt;span&gt;8&lt;/span&gt; };
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　静态成员变量在const函数中可以修改，而普通的成员变量是万万不能修改的；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; 　　&lt;span&gt;const修饰的是当前this指针所指向的对象是const，但是静态成员变量不属于任何类的对象，它被类的所有对象修改，所以this指针不修饰静态的成员变量，所以可以更改。
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test{
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; a;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; b;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         Test():b(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;){}
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; test() &lt;span&gt;const&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         a++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         //b++;  &lt;span&gt;// err  // &lt;/span&gt;&lt;span&gt;const指的是不能修改当前调用该函数对象的成员变量&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Test::a;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　2）静态成员函数&lt;/p&gt;
&lt;p&gt;　　　　特征：1、静态成员函数  属于  整个类所有；&lt;/p&gt;
&lt;p&gt;　　　　　　　2、所有对象共享类的静态成员函数；&lt;/p&gt;
&lt;p&gt;　　　　　　　2、可以通过  类名  直接访问公有的静态成员函数；&lt;/p&gt;
&lt;p&gt;　　　　　　　3、可以通过 对象名  访问公有的静态成员函数；&lt;/p&gt;
&lt;p&gt;　　　　　　　4、&lt;span&gt;静态成员函数 只能 访问静态成员，不能访问  非静态成员；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　5、&lt;span&gt;静态成员函数没有this指针，也就是说静态成员函数不能使用修饰符(也就是函数后面的const关键字)&lt;/span&gt;；&lt;/p&gt;
&lt;p&gt;　　　　原因：处理静态成员变量；　&lt;/p&gt;
&lt;p&gt;　　　　使用方法：直接用 static 修饰 普通成员函数（类内声明时），不需要 static 修饰（类外定义时）；&lt;/p&gt;
&lt;p&gt;　　　　总结：&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1438401/202002/1438401-20200215210619223-71028230.png&quot; alt=&quot;&quot; width=&quot;617&quot; height=&quot;251&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　　　案例分析：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('f75d9500-5452-49ca-a3fc-ce0cbcf99c6f')&quot; readability=&quot;46&quot;&gt;&lt;img id=&quot;code_img_closed_f75d9500-5452-49ca-a3fc-ce0cbcf99c6f&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_f75d9500-5452-49ca-a3fc-ce0cbcf99c6f&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('f75d9500-5452-49ca-a3fc-ce0cbcf99c6f',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_f75d9500-5452-49ca-a3fc-ce0cbcf99c6f&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;87&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; &lt;span&gt; * 统计某班选修课考试的平均成绩
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;  4&lt;/span&gt; 
&lt;span&gt;  5&lt;/span&gt; #include &amp;lt;iostream&amp;gt;
&lt;span&gt;  6&lt;/span&gt; #include &amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;
&lt;span&gt;  7&lt;/span&gt; 
&lt;span&gt;  8&lt;/span&gt; &lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; 
&lt;span&gt; 10&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Student
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt; &lt;span&gt;private&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt;     &lt;span&gt;string&lt;/span&gt; name;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 姓名&lt;/span&gt;
&lt;span&gt; 14&lt;/span&gt;     &lt;span&gt;string&lt;/span&gt; gender;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 性别&lt;/span&gt;
&lt;span&gt; 15&lt;/span&gt;     &lt;span&gt;float&lt;/span&gt; score;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 分数&lt;/span&gt;
&lt;span&gt; 16&lt;/span&gt;     &lt;span&gt;string&lt;/span&gt; subject; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 课程&lt;/span&gt;
&lt;span&gt; 17&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; total_counts;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 总人数&lt;/span&gt;
&lt;span&gt; 18&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; chinese_scores;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 语文分数&lt;/span&gt;
&lt;span&gt; 19&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; chinese_counts;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 语文课人数&lt;/span&gt;
&lt;span&gt; 20&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; math_scores;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 数学分数&lt;/span&gt;
&lt;span&gt; 21&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; math_counts;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 数学课人数&lt;/span&gt;
&lt;span&gt; 22&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt;     Student(&lt;span&gt;string&lt;/span&gt; name, &lt;span&gt;string&lt;/span&gt; gender, &lt;span&gt;float&lt;/span&gt; score, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; subject);
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt;     ~&lt;span&gt;Student();
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; aveScores(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; subject);
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; printStudentInfo();
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; printAveScores();
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Student::total_counts = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; Student::chinese_scores = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Student::chinese_counts = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; Student::math_scores = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Student::math_counts = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt; 
&lt;span&gt; 35&lt;/span&gt; Student::Student(&lt;span&gt;string&lt;/span&gt; name, &lt;span&gt;string&lt;/span&gt; gender, &lt;span&gt;float&lt;/span&gt; score, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; subject)
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;-&amp;gt;name =&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;-&amp;gt;gender =&lt;span&gt; gender;
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;-&amp;gt;score =&lt;span&gt; score;
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;-&amp;gt;subject =&lt;span&gt; subject;
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt; 
&lt;span&gt; 42&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(subject == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;chinese&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; || subject == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;语文&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt;         chinese_scores +=&lt;span&gt; score;
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt;         chinese_counts++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(subject == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;math&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; || subject == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;数学&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt;         math_scores +=&lt;span&gt; score;
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt;         math_counts++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;
&lt;span&gt; 53&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt;         cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;this is no the subect:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; subject &amp;lt;&amp;lt;&lt;span&gt; endl;
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt;     total_counts += (chinese_counts +&lt;span&gt;  math_counts);
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt; 
&lt;span&gt; 59&lt;/span&gt; Student::~&lt;span&gt;Student()
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt;     total_counts--&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt;     chinese_counts--&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt;     math_counts--&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt; 
&lt;span&gt; 66&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; Student::aveScores(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; subject)
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;     &lt;span&gt;float&lt;/span&gt; ave_score = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt; 
&lt;span&gt; 70&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(chinese_counts &amp;gt; &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; subject == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;chinese&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; || subject == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;语文&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt;        ave_score = (chinese_scores /&lt;span&gt; chinese_counts);
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;cout &amp;lt;&amp;lt; subject &amp;lt;&amp;lt; &quot;\t&quot; &amp;lt;&amp;lt; chinese_counts &amp;lt;&amp;lt; &quot;\t&quot; &amp;lt;&amp;lt; chinese_scores &amp;lt;&amp;lt; endl;&lt;/span&gt;
&lt;span&gt; 74&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(math_counts &amp;gt; &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; subject == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;math&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; || subject == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;数学&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt;        ave_score = (math_scores /&lt;span&gt; math_counts);
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;cout &amp;lt;&amp;lt; subject &amp;lt;&amp;lt; &quot;\t&quot; &amp;lt;&amp;lt;math_counts &amp;lt;&amp;lt; &quot;\t&quot; &amp;lt;&amp;lt; math_scores &amp;lt;&amp;lt; endl;&lt;/span&gt;
&lt;span&gt; 79&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt; 
&lt;span&gt; 81&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ave_score;
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt; 
&lt;span&gt; 84&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Student::printStudentInfo()
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;     cout &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\t&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; gender &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\t&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; score &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\t&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; subject &amp;lt;&amp;lt;&lt;span&gt; endl;
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt; 
&lt;span&gt; 89&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Student::printAveScores()
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt;     cout &amp;lt;&amp;lt;subject  &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; average score: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; aveScores(subject) &amp;lt;&amp;lt;&lt;span&gt; endl;
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt; 
&lt;span&gt; 94&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; *&lt;span&gt;argv[])
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt;     &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; SIZE = &lt;span&gt;5&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt;     Student stu[SIZE] = 
&lt;span&gt; 98&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;             Student(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;10001&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;male&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;92&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;语文&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;             Student(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;10002&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;male&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;91&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;数学&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt;             Student(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;10003&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;male&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;91&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;数学&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt;             Student(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;10004&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;male&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;93&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;语文&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt;             Student(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;10005&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;male&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;92&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;语文&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt; &lt;span&gt;        };
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt; 
&lt;span&gt;106&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; SIZE; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt; &lt;span&gt;        stu[i].printStudentInfo();
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt; 
&lt;span&gt;111&lt;/span&gt;    stu[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;].printAveScores();
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt;    stu[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;].printAveScores();
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt; 
&lt;span&gt;114&lt;/span&gt;    cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;语文&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; average score: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; Student::aveScores(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;语文&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) &amp;lt;&amp;lt;&lt;span&gt; endl;
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt;    cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;数学&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; average score: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; Student::aveScores(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;数学&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) &amp;lt;&amp;lt;&lt;span&gt; endl;
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt; 
&lt;span&gt;117&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;静态成员的案例分析&lt;/span&gt;&lt;/div&gt;

</description>
<pubDate>Sat, 15 Feb 2020 15:24:00 +0000</pubDate>
<dc:creator>PRO_Z</dc:creator>
<og:description>注：若没有特指是 静态成员时，默认都是普通成员； 1 类中的普通成员 类中的成员变量 和 成员函数 是分开存储的。其中， 1）每个对象都有独立的成员变量；成员变量可以存储在 栈空间、堆空间、全局数据区</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/nbk-zyc/p/12305170.html</dc:identifier>
</item>
</channel>
</rss>