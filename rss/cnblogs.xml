<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>IDEA上运行Flink任务 - 程序员欣宸</title>
<link>http://www.cnblogs.com/bolingcavalry/p/13888909.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bolingcavalry/p/13888909.html</guid>
<description>&lt;h3 id=&quot;欢迎访问我的github&quot;&gt;欢迎访问我的GitHub&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;内容：所有原创文章分类汇总及配套源码，涉及Java、Docker、Kubernetes、DevOPS等；&lt;/p&gt;
&lt;p&gt;IDEA是常用的IDE，我们编写的flink任务代码如果能直接在IDEA运行，会给学习和开发带来很大便利，例如改完代码立即运行不用部署、断点、单步调试等；&lt;/p&gt;
&lt;h3 id=&quot;环境信息&quot;&gt;环境信息&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;电脑：2019版13寸MacBook Pro，2.3 GHz 四核Intel Core i5，8 GB 2133 MHz LPDDR3&lt;/li&gt;
&lt;li&gt;操作系统：macOS Catalina 10.15.3&lt;/li&gt;
&lt;li&gt;JDK：1.8.0_211&lt;/li&gt;
&lt;li&gt;Maven：3.6.0&lt;/li&gt;
&lt;li&gt;IDEA：2018.3.5 (Ultimate Edition)&lt;/li&gt;
&lt;li&gt;Flink版本：1.9.2&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;关于正版idea&quot;&gt;关于正版IDEA&lt;/h3&gt;
&lt;p&gt;如何免费使用正版IDEA，可以参考&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/100014835&quot;&gt;《免费申请和使用IntelliJ IDEA商业版License指南》&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;开发&quot;&gt;开发&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;首先确保您电脑上maven已装好；&lt;/li&gt;
&lt;li&gt;创建一个flink任务的maven工程，找个干净目录执行以下命令：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;mvn \
archetype:generate \
-DarchetypeGroupId=org.apache.flink \
-DarchetypeArtifactId=flink-quickstart-java \
-DarchetypeVersion=1.9.2
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;按提示输入groupId、artifactId、version、package等内容：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201028081248083-222856132.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;4. 现在maven工程已生成，用IDEA导入这个工程，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201028081248623-167278231.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;5. 以maven的类型导入：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201028081249012-679088734.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;6. 导入成功后的样子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201028081249393-1757805032.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;7. 修改&lt;span&gt;StreamingJob.java&lt;/span&gt;，加入功能是监听本地&lt;span&gt;18081&lt;/span&gt;端口，得到的字符串做word count操作，完整代码在此下载：&lt;a href=&quot;https://raw.githubusercontent.com/zq2599/blog_demos/master/files/StreamingJob.java&quot;&gt;https://raw.githubusercontent.com/zq2599/blog_demos/master/files/StreamingJob.java&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201028081249994-1399426134.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;8. 现在的代码已经能运行，但flink网页却还不能访问，会显示以下错误信息，需要继续做些设置：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201028081250347-2116898906.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;9. 下载flink-1.9.2安装包，这里面有flink网页服务用到的一个jar，地址是：&lt;a href=&quot;https://www-eu.apache.org/dist/flink/flink-1.9.2/flink-1.9.2-bin-scala_2.11.tgz&quot;&gt;https://www-eu.apache.org/dist/flink/flink-1.9.2/flink-1.9.2-bin-scala_2.11.tgz&lt;/a&gt;&lt;br/&gt;10. &lt;span&gt;flink-1.9.2-bin-scala_2.11.tgz&lt;/span&gt;下载后解压，在lib目录下有个&lt;span&gt;flink-dist_2.11-1.9.2.jar&lt;/span&gt;文件，记住此文件的位置，稍后会用到；&lt;br/&gt;11. 回到IDEA，在项目上点击右键，点击菜单&lt;span&gt;Open Module Settings&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201028081250840-817616565.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;12. 在弹出的窗口做如下操作，目的是给项目中增加jar：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201028081251444-1558545143.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;13. 弹出选择文件的窗口，请选择刚才准备好的文件&lt;span&gt;flink-dist_2.11-1.9.2.jar&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201028081251805-2107651080.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;14. 设置工作已经完成，由于StreamingJob的工作是读取本机18081端口的数据，所以我们要把18081端口的服务启动起来，不然StreamingJob运行时是连不上端口的，打开一个控制台，执行命令：&lt;span&gt;nc -l 18081&lt;/span&gt;&lt;br/&gt;15. 现在可以将StreamingJob运行起来，如下图，右键点击StreamingJob，选择&lt;span&gt;Run 'StreamingJob.main()'：&lt;/span&gt;即可启动flink任务，如果想打断点调试，请选择&lt;span&gt;Debug 'StreamingJob.main()'&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201028081252284-831698064.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;16. 回到刚才执行nc命令的控制台，输入一些字符串，例如&quot;aaa bbb aaa&quot;，然后回车；&lt;br/&gt;17. 再回到IDEA，可见StreamingJob已经从18081端口读到了数据并且输出了统计结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201028081253736-989512197.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;18. 在IDEA的控制台搜索关键字&lt;span&gt;localhost&lt;/span&gt;，如下图红框，可以查到flink网页的端口，我这里是&lt;span&gt;62641&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201028081254647-1377923934.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;19. 浏览器访问&lt;a href=&quot;http://localhost:62641&quot;&gt;&lt;span&gt;http://localhost:62641&lt;/span&gt;&lt;/a&gt;，如下图，可见flink网页已经正常显示，正在运行的任务也能看到：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201028081255053-730977538.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，最简单的IDEA运行flink任务的实战就完成了，如果您也在学习flink，希望本文能给您一些参考；&lt;/p&gt;
&lt;h3 id=&quot;欢迎关注公众号：程序员欣宸&quot;&gt;欢迎关注公众号：程序员欣宸&lt;/h3&gt;
&lt;blockquote readability=&quot;4.258064516129&quot;&gt;
&lt;p&gt;微信搜索「程序员欣宸」，我是欣宸，期待与您一同畅游Java世界...&lt;br/&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 28 Oct 2020 00:13:00 +0000</pubDate>
<dc:creator>程序员欣宸</dc:creator>
<og:description>欢迎访问我的GitHub https://github.com/zq2599/blog_demos 内容：所有原创文章分类汇总及配套源码，涉及Java、Docker、Kubernetes、DevOPS</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bolingcavalry/p/13888909.html</dc:identifier>
</item>
<item>
<title>Java9系列第九篇-对HTTP2协议的支持与非阻塞HTTP-API - 字母哥博客</title>
<link>http://www.cnblogs.com/zimug/p/13888854.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zimug/p/13888854.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202010/1815316-20201028072600030-1616187610.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在HTTP/1.1 发布了16 年之后，IETF在2015年终于通过了HTTP/2 协议。HTTP/2协议旨在降低延迟，满足当今时代对于信息响应时间的要求。在这篇文章中，我会简要的对HTTP/2协议进行介绍，然后我们将重点放在研究Java9中对HTTP/2支持及其HTTP客户端API的变化。&lt;/p&gt;
&lt;h2 id=&quot;一、http2简介&quot;&gt;一、HTTP/2简介&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;HTTP/2 旨在减轻 HTTP/1.1 维护复杂基础结构所造成的痛苦，性能良好。尽管 HTTP/2 仍然与 HTTP/1.1 向后兼容，但它不再是基于文本的协议。&lt;/li&gt;
&lt;li&gt;HTTP/2 多路复用使单个连接可以处理多个双向流，允许客户端通过单个连接同时下载多个资源。&lt;/li&gt;
&lt;li&gt;HTTP 1.x 协议是基于文本的，因此报文很冗长。有的时候，同一组 HTTP Headers被一遍又一遍地交换。HTTP/2 通过跨请求维护 HTTP Headers，消除重复交换的数据，大大减少了数据交互所需的带宽。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;http2数据推送&quot;&gt;HTTP/2数据推送&lt;/h4&gt;
&lt;p&gt;您可能认为HTTP/2的服务端数据推送是对 WebSockets 的某种延续或升级，但情况并非如此。虽然 WebSockets 是客户端和服务器之间全双工通信的一种方法，以便服务器在建立 TCP 连接后将数据发送到客户端，但 HTTP/2 提供了一种不同的解决方案。&lt;/p&gt;
&lt;p&gt;HTTP/2 推送是主动向客户端发送资源，而无需从客户端的角度发起资源请求。这意味着服务器端根据一个请求可能知道网站进一步需要的其他资源，并且早在客户端再次发起请求它们之前，就可以一并（提前）发送所有资源。&lt;/p&gt;
&lt;h4 id=&quot;目前支持-http2-的-java-http-客户端&quot;&gt;目前支持 HTTP/2 的 Java HTTP 客户端&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;Jetty&lt;/li&gt;
&lt;li&gt;Netty&lt;/li&gt;
&lt;li&gt;OkHttp&lt;/li&gt;
&lt;li&gt;Vert.x&lt;/li&gt;
&lt;li&gt;Firefly&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;但是在这篇文章中，我们不会介绍这些Java 客户端软件，而是介绍Java9提供的HTTP/2支持。&lt;/p&gt;
&lt;h2 id=&quot;二、java-9-的-http2-客户端&quot;&gt;二、Java 9 的 HTTP/2 客户端&lt;/h2&gt;
&lt;p&gt;首先使用Java 9的语法进行模块的导入 。&lt;code&gt;jdk.incubator.httpclient&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;module com.springui.echo.client {
    requires jdk.incubator.httpclient;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Java 9 新的 HTTP Cient API 遵循构建器模式。HttpClient是用来操作HTTP请求的入口点，先构建后使用。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;HttpClient client = HttpClient
    .newBuilder()
    .version(Version.HTTP_2)  //支持HTTP2
    .build();
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;在阻塞模式下发送请求&quot;&gt;在阻塞模式下发送请求&lt;/h4&gt;
&lt;p&gt;一旦我们有了一个 HttpClient实例，就可以用它来发送HttpRequest，HttpRequest实例也可以使用构造器创建。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;HttpResponse&amp;lt;String&amp;gt; response = client.send(
    HttpRequest
        .newBuilder(TEST_URI)  //请求地址
        .POST(BodyProcessor.fromString(&quot;Hello world&quot;)) //POST报文数据
        .build(),
    BodyHandler.asString()  //请求响应数据处理，接收字符串
);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;请求发出去之后，线程会一直阻塞直到得到响应数据，这个和JAVA 8及之前的HTTP API是一样的。但是Java 9提供了以异步非阻塞发送处理请求的方法，更适合高并发的HTTP请求与处理。&lt;/p&gt;
&lt;h4 id=&quot;以非阻塞模式发送请求java-9&quot;&gt;以非阻塞模式发送请求(Java 9)&lt;/h4&gt;
&lt;p&gt;在下面的示例中，10 个随机整数以异步方式发送请求。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;List&amp;lt;CompletableFuture&amp;lt;String&amp;gt;&amp;gt; responseFutures = 
        IntStream.of(1,2,3,4,5,6,7,8,9,10)  //10个整数形成IntStream，Java 8的语法
        .mapToObj(String::valueOf) //10个整数转换成字符串，Java 8的语法
        .map(message -&amp;gt; client.sendAsync( //将10个整数字符串作为内容，发送10个异步请求
                HttpRequest.newBuilder(TEST_URI)
                        .POST(HttpRequest.BodyProcessor.fromString(message))
                        .build(),
                HttpResponse.BodyHandler.asString()
             ).thenApply(HttpResponse::body)  //以CompletableFuture&amp;lt;HttpResponse.body()&amp;gt;作为流处理的返回值
        )
        .collect(Collectors.toList());  //将Stream转成List
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的例子大量的使用了Java 8的Stream流式处理的API，如果不熟悉的同学,可以翻看我以前写的一些文章。&lt;br/&gt;sendAsync方法的返回值&lt;code&gt;CompletableFuture&amp;lt;HttpResponse&amp;lt;String&amp;gt;&amp;gt;&lt;/code&gt;,使用&lt;code&gt;thenApply(HttpResponse::body)&lt;/code&gt;作了进一步的处理，最终返回值是&lt;code&gt;CompletableFuture&amp;lt;String&amp;gt;&lt;/code&gt;。&lt;br/&gt;CompletableFuture是Java异步编程的知识，将并发的异步处理结果打印出来。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;responseFutures.stream().forEach(future -&amp;gt; {
    LOGGER.info(&quot;Async response: &quot; + future.getNow(null));
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你会注意到，最终的打印日志&lt;strong&gt;可能不是按照顺序&lt;/strong&gt;1、2、3、4、5、6、7、8、9、10进行处理的，因为所有的请求都是异步发送出去的，返回的结果是CompletableFuture用于异步处理的结果。&lt;/p&gt;
&lt;h2 id=&quot;三、支持http2的push-promise-frames&quot;&gt;三、支持HTTP2的Push-Promise Frames&lt;/h2&gt;
&lt;p&gt;以上所有示例在 HTTP/1.1协议下都可以完成，只是新加了非阻塞的异步API，也没涉及到 HTTP/2 特性啊。别急，Java 9 Client API与HTTP/2结合最紧密的就是：可以使用HTTP2发送一个请求，得到多个异步数据结果。（某些数据提前推送，当然这需要服务端也支持HTTP/2进行配合）&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Map&amp;lt;HttpRequest,CompletableFuture&amp;lt;HttpResponse&amp;lt;String&amp;gt;&amp;gt;&amp;gt; responses =
        client.sendAsync(    //注意这里只发送一次请求
          HttpRequest.newBuilder(TEST_URI)
                  .POST(HttpRequest.BodyProcessor.fromString(TEST_MESSAGE))
                  .build(),
          HttpResponse.MultiProcessor.asMap(    //多个资源的响应结果
                  request -&amp;gt; Optional.of(HttpResponse.BodyHandler.asString())
          )
).join();

responses.forEach((request, responseFuture) -&amp;gt; {
  LOGGER.info(&quot;Async response: &quot; + responseFuture.getNow(null));
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从Java 9的角度来看，新的HTTP/2客户端API看起来不错。但笔者觉得目前相关技术的使用还不是很成熟，我觉得大家暂时尝尝鲜就可以。&lt;/p&gt;
&lt;h2 id=&quot;欢迎关注我的博客，里面有很多精品合集&quot;&gt;欢迎关注我的博客，里面有很多精品合集&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;本文转载注明出处（必须带连接，不能只转文字）：&lt;a href=&quot;http://www.zimug.com&quot;&gt;字母哥博客&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;觉得对您有帮助的话，帮我点赞、分享！您的支持是我不竭的创作动力！&lt;/strong&gt; 。另外，笔者最近一段时间输出了如下的精品内容，期待您的关注。&lt;/p&gt;
</description>
<pubDate>Tue, 27 Oct 2020 23:26:00 +0000</pubDate>
<dc:creator>字母哥博客</dc:creator>
<og:description>在HTTP/1.1 发布了16 年之后，IETF在2015年终于通过了HTTP/2 协议。HTTP/2协议旨在降低延迟，满足当今时代对于信息响应时间的要求。在这篇文章中，我会简要的对HTTP/2协议进</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zimug/p/13888854.html</dc:identifier>
</item>
<item>
<title>RocketMQ消息丢失解决方案：同步刷盘+手动提交 - H.U.C-王子</title>
<link>http://www.cnblogs.com/lm970585581/p/13888820.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lm970585581/p/13888820.html</guid>
<description>&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;前言&lt;/h3&gt;
&lt;p&gt;之前我们一起了解了使用RocketMQ事务消息解决生产者发送消息时消息丢失的问题，但使用了事务消息后消息就一定不会丢失了吗，肯定是不能保证的。&lt;/p&gt;
&lt;p&gt;因为虽然我们解决了生产者发送消息时候的消息丢失问题，但也只是保证Broker正确的接收到了消息，实际上接收到的消息会保存在os cache中，如果此时broker机器突然宕机，os cache中的消息数据就丢失掉了。&lt;/p&gt;
&lt;p&gt;而且就算是os cache中的消息已经刷盘到了磁盘中，如果磁盘突然就坏了，消息是不是也就丢失了。&lt;/p&gt;
&lt;p&gt;所以我们还要考虑Broker如何保证消息不丢失。&lt;/p&gt;

&lt;h3&gt;Broker的消息丢失解决方案&lt;/h3&gt;
&lt;p&gt;说到这里，我们就进入主题了，首先解决临时存在os cache，而未刷新到磁盘导致的消息丢失问题，那么如何解决呢？&lt;/p&gt;
&lt;p&gt;看过之前系列文章的小伙伴都知道，Broker是有两种刷盘机制的，同步刷盘和异步刷盘，详细内容可以回顾一下这篇文章：&lt;a href=&quot;https://mp.weixin.qq.com/s/ief_JQabv1z-WmKdVn5oxw&quot; target=&quot;_blank&quot;&gt;深入研究Broker是如何持久化的&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;解决的方式就是&lt;strong&gt;把异步刷盘改为同步刷盘&lt;/strong&gt;，具体操作就是修改一下broker的配置文件，将其中的flushDiskType配置设置为：SYNC_FLUSH，默认它的值是ASYNC_FLUSH，即异步刷盘。&lt;/p&gt;
&lt;p&gt;调整为同步刷盘后，只要MQ告诉我们消息发送成功了，那么就说明消息已经在磁盘中了。&lt;/p&gt;
&lt;p&gt;接下来就要解决磁盘坏了导致的消息丢失问题了。&lt;/p&gt;
&lt;p&gt;这个问题其实也很好解决，只要我们使用RockerMQ的高可用集群模式就可以了，也就是说如果返回消息发送成功的响应，那就代表Master Broker已经把数据同步到了Slave Broker中，保证数据有多个备份。&lt;/p&gt;
&lt;p&gt;这样一来就算是Master Broker突然宕机 ，也可以通过Dledger技术进行主从的自动切换，使用我们备份的数据，这其中的原理我们已经讲过了，小伙伴们可以自己去复习回顾一下。&lt;a href=&quot;https://mp.weixin.qq.com/s/GIyN0eIjyRkPLVhKniwOKw&quot; target=&quot;_blank&quot;&gt;Dledger是如何实现主从自动切换的&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;Consumer的消息丢失解决方案&lt;/h3&gt;
&lt;p&gt;到这里，我们已经确保了生产者和Broker的消息不会丢失了，那么消费者处理消息的时候会不会导致消息丢失呢？&lt;/p&gt;
&lt;p&gt;答案是肯定的。&lt;/p&gt;
&lt;p&gt;比如说我们的积分系统拿到了消息，还未执行该执行的操作，先返回给broker这条消息的offset，说这条消息已经处理过了。然后突然宕机了，这就导致mq认为这条消息已经处理过了，而实际并没有处理，所以这条消息就丢失掉了。&lt;/p&gt;
&lt;p&gt;对于Kafka和RabbitMQ来讲，默认的消费模式就是上边这种自动提交的模式，所以是有可能导致消息丢失掉的。&lt;/p&gt;
&lt;p&gt;而RocketMQ的消费者有点不一样，它本身就是需要手动返回消息处理成功的响应的。&lt;/p&gt;
&lt;p&gt;所以其实Consumer的消息丢失解决方案也很简单，就是&lt;strong&gt;将自动提交改为手动提交&lt;/strong&gt;。&lt;/p&gt;

&lt;h3&gt;消息零丢失方案的优缺点分析&lt;/h3&gt;
&lt;p&gt;如果在系统中落地一套消息零丢失的方案，无论什么场景都保证消息的可靠性，这似乎听起来不错，这也是它的优点所在，保证系统的数据都是正确的，不会有丢失的情况。&lt;/p&gt;
&lt;p&gt;但它有什么缺点呢？&lt;/p&gt;
&lt;p&gt;首先，引入了这套解决方案之后，系统的复杂度变高了，想想事务消息的实现方式你肯定会这么觉得。&lt;/p&gt;
&lt;p&gt;而且比较严重的缺点是，它会导致系统的性能严重的下降，比如原来每秒可以处理好几万条的消息，结果在引入消息零丢失这套方案之后，可能每秒就只能处理几千条消息了。&lt;/p&gt;
&lt;p&gt;其实只要随便思考一下，就可以想明白这个问题。&lt;/p&gt;
&lt;p&gt;事务消息的复杂性导致生产消息的过程耗时更久了，同步刷盘的策略导致写入磁盘后才返回消息，自然也会增加耗时，而消费者如果异步的处理消息，直接返回成功，整个流程的速度会更快。&lt;/p&gt;
&lt;p&gt;所以说引入这么一套消息零丢失的方案，对于性能的影响还是很大的。&lt;/p&gt;


&lt;h3&gt;总结&lt;/h3&gt;
&lt;p&gt;其实关于消息零丢失的方案无外乎就这么多，所以本篇文章内容不是很多。&lt;/p&gt;
&lt;p&gt;既然我们刚才聊了消息零丢失方案的缺点，那么就继续讨论一下，究竟什么场景下需要引入这套方案吧。&lt;/p&gt;
&lt;p&gt;王子给大家介绍一下自己的想法。&lt;/p&gt;
&lt;p&gt;一般我们对于跟金钱、交易以及核心数据相关的系统和核心链路，可以采用这套方案。&lt;/p&gt;
&lt;p&gt;比如说我们文章中举的例子：支付系统、订单系统、积分系统。&lt;/p&gt;
&lt;p&gt;而对于其他的没那么核心的场景，丢失一些数据问题也不大，就不应该采用这套方案了，或者说可以做一些简化，比如事务消息改成失败重试几次的机制，刷盘策略改为异步刷盘。&lt;/p&gt;
&lt;p&gt;那么小伙伴们在平时的工作中，这套方案是怎么应用到生产环境中的呢？欢迎留言讨论。&lt;/p&gt;


&lt;p&gt;往期文章推荐：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/rftOtxfZ_x3-YofwNiYFsQ&quot; target=&quot;_blank&quot;&gt;深入研究RocketMQ生产者发送消息的底层原理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/ief_JQabv1z-WmKdVn5oxw&quot; target=&quot;_blank&quot;&gt;深入研究Broker是如何持久化的&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/GIyN0eIjyRkPLVhKniwOKw&quot; target=&quot;_blank&quot;&gt;Dledger是如何实现主从自动切换的&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/5lsff0etvlMQ7cR9iV4AbQ&quot; target=&quot;_blank&quot;&gt;深入研究RocketMQ消费者是如何获取消息的&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/4lx-Gb2tMqJ3TybjwIHOjA&quot; target=&quot;_blank&quot;&gt;RocketMQ的消息是怎么丢失的&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/B8XN4bfKCD-SIM1i3YqjRg&quot; target=&quot;_blank&quot;&gt;RocketMQ消息丢失解决方案：事务消息&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1140467/202009/1140467-20200901142419527-2040845842.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 27 Oct 2020 22:26:00 +0000</pubDate>
<dc:creator>H.U.C-王子</dc:creator>
<og:description>前言 之前我们一起了解了使用RocketMQ事务消息解决生产者发送消息时消息丢失的问题，但使用了事务消息后消息就一定不会丢失了吗，肯定是不能保证的。 因为虽然我们解决了生产者发送消息时候的消息丢失问题</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lm970585581/p/13888820.html</dc:identifier>
</item>
<item>
<title>云计算管理平台之OpenStack简介及基础环境搭建 - Linux-1874</title>
<link>http://www.cnblogs.com/qiuhom-1874/p/13886693.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qiuhom-1874/p/13886693.html</guid>
<description>&lt;p&gt;　　一、简介&lt;/p&gt;
&lt;p&gt;　　什么是openstack?它是干嘛用的？&lt;/p&gt;
&lt;p&gt;　　简单说openstack是云计算管理平台，主要对云环境中的虚拟机做增删查改；它能够将多台物理设备的资源（cpu/内存等）整合成一个大的资源池，然后根据openstack提供的api接口向用户提供使用；用户可以根据openstack提供的资源池接口来启动虚拟机，管理虚拟机；openstack 主要组成由控制节点和计算节点组成；其中控制节点由多个组件组成，每个组件都是以api的形式向外提供服务，这多个组件共同组成了控制节点，所以控制节点上运行了很多服务；计算节点通常是指提供物理硬件，用于启动虚拟机的物理设备；&lt;/p&gt;
&lt;p&gt;　　二、架构&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202010/1503305-20201027185520836-2102114768.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：openstack主要把底层的多台server的资源分为了三类，计算，网络和存储；用户可以通过openstack提供的web界面直接在openstack上启动虚拟机实例；&lt;/p&gt;
&lt;p&gt;　　三、openstack基础环境准备&lt;/p&gt;
&lt;p&gt;　　本次实验是以openstack R版为例，其中各服务器角色如下&lt;/p&gt;
&lt;table border=&quot;0&quot; align=&quot;left&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;主机名&lt;/td&gt;
&lt;td&gt;角色&lt;/td&gt;
&lt;td&gt;ip地址&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;node01&lt;/td&gt;
&lt;td&gt;控制节点&lt;/td&gt;
&lt;td&gt;192.168.0.41/24&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;node02&lt;/td&gt;
&lt;td&gt;数据库服务器&lt;/td&gt;
&lt;td&gt;192.168.0.42/24&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;node03&lt;/td&gt;
&lt;td&gt;计算节点&lt;/td&gt;
&lt;td&gt;192.168.0.43/24&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;





&lt;p&gt;　　1、各server上的基础环境配置&lt;/p&gt;
&lt;p&gt;　　　　1）时间同步&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node01 ~]# grep server /etc/chrony.conf
# Use public servers from the pool.ntp.org project.
server time.test.org iburst
# Serve time even if not synchronized to any NTP server.
[root@node01 ~]# scp /etc/chrony.conf node02:/etc/
chrony.conf                                                                                 100% 1141   992.7KB/s   00:00    
[root@node01 ~]# scp /etc/chrony.conf node03:/etc/
chrony.conf                                                                                 100% 1141   663.6KB/s   00:00    
[root@node01 ~]# chronyc sources                  
210 Number of sources = 1
MS Name/IP address         Stratum Poll Reach LastRx Last sample               
===============================================================================
^* time.test.org                 3   6   377    40    -15us[  -86us] +/-   20ms
[root@node01 ~]# ssh node02 'chronyc sources'
210 Number of sources = 1
MS Name/IP address         Stratum Poll Reach LastRx Last sample               
===============================================================================
^* time.test.org                 3   6   377    49  -6552ns[  -15us] +/-   20ms
[root@node01 ~]# ssh node03 'chronyc sources' 
210 Number of sources = 1
MS Name/IP address         Stratum Poll Reach LastRx Last sample               
===============================================================================
^* time.test.org                 3   6   377    52    -30us[ -103us] +/-   20ms
[root@node01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　2）主机名解析&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node01 ~]# cat /etc/hosts
127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
::1         localhost localhost.localdomain localhost6 localhost6.localdomain6
192.168.0.99 time.test.org time-node
192.168.0.41 node01.test.org node01 controller 
192.168.0.42 node02.test.org node02
192.168.0.43 node03.test.org node03
192.168.0.44 node04.test.org node04
192.168.0.45 node05.test.org node05
192.168.0.46 node06.test.org node06
[root@node01 ~]# scp /etc/hosts node02:/etc/
hosts                                                                                       100%  423    29.5KB/s   00:00    
[root@node01 ~]# scp /etc/hosts node03:/etc/
hosts                                                                                       100%  423    46.5KB/s   00:00    
[root@node01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　3）关闭selinux、iptables和NetworkManager&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node01 ~]# sed -i 's@SELINUX=enforcing@SELINUX=disabled@g' /etc/selinux/config 
[root@node01 ~]# setenforce 0
[root@node01 ~]# getenforce 
Permissive
[root@node01 ~]# ssh node02 'sed -i 's@SELINUX=enforcing@SELINUX=disabled@g' /etc/selinux/config'
[root@node01 ~]# ssh node02 'setenforce 0 &amp;amp;&amp;amp; getenforce'
Permissive
[root@node01 ~]# ssh node03 'sed -i 's@SELINUX=enforcing@SELINUX=disabled@g' /etc/selinux/config' 
[root@node01 ~]# ssh node03 'setenforce 0 &amp;amp;&amp;amp; getenforce'                                          
Permissive
[root@node01 ~]# systemctl stop firewalld NetworkManager
[root@node01 ~]# systemctl disable firewalld NetworkManager    
Removed symlink /etc/systemd/system/multi-user.target.wants/NetworkManager.service.
Removed symlink /etc/systemd/system/dbus-org.freedesktop.NetworkManager.service.
Removed symlink /etc/systemd/system/dbus-org.freedesktop.nm-dispatcher.service.
[root@node01 ~]# ssh node02 'systemctl stop firewalld NetworkManager &amp;amp;&amp;amp; systemctl disable firewalld NetworkManager'
Removed symlink /etc/systemd/system/multi-user.target.wants/NetworkManager.service.
Removed symlink /etc/systemd/system/dbus-org.freedesktop.NetworkManager.service.
Removed symlink /etc/systemd/system/dbus-org.freedesktop.nm-dispatcher.service.
[root@node01 ~]# ssh node03 'systemctl stop firewalld NetworkManager &amp;amp;&amp;amp; systemctl disable firewalld NetworkManager' 
Removed symlink /etc/systemd/system/multi-user.target.wants/NetworkManager.service.
Removed symlink /etc/systemd/system/dbus-org.freedesktop.NetworkManager.service.
Removed symlink /etc/systemd/system/dbus-org.freedesktop.nm-dispatcher.service.
[root@node01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：如果你的系统是最小化安装，这里还需要安装一些基础的包；yum install -y vim wget tree  lrzsz gcc gcc-c++ automake pcre pcre-devel zlib zlib-devel openssl openssl-devel iproute net-tools iotop  lsof  ntpdate telnet bridge-utils；&lt;/p&gt;
&lt;p&gt;　　　　4）各服务器配置阿里云的base仓库和epel仓库包&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;44&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node01 ~]# rm -rf /etc/yum.repos.d/*.repo
[root@node01 ~]# wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo
--2020-10-27 22:43:42--  http://mirrors.aliyun.com/repo/Centos-7.repo
Resolving mirrors.aliyun.com (mirrors.aliyun.com)... 118.116.3.238, 118.123.164.244, 118.123.164.119, ...
Connecting to mirrors.aliyun.com (mirrors.aliyun.com)|118.116.3.238|:80... connected.
HTTP request sent, awaiting response... 200 OK
Length: 2523 (2.5K) [application/octet-stream]
Saving to: ‘/etc/yum.repos.d/CentOS-Base.repo’

100%[====================================================================================&amp;gt;] 2,523       --.-K/s   in 0s      

2020-10-27 22:43:42 (180 MB/s) - ‘/etc/yum.repos.d/CentOS-Base.repo’ saved [2523/2523]

[root@node01 ~]# wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo
--2020-10-27 22:43:51--  http://mirrors.aliyun.com/repo/epel-7.repo
Resolving mirrors.aliyun.com (mirrors.aliyun.com)... 118.116.3.248, 118.123.164.120, 125.64.102.239, ...
Connecting to mirrors.aliyun.com (mirrors.aliyun.com)|118.116.3.248|:80... connected.
HTTP request sent, awaiting response... 200 OK
Length: 664 [application/octet-stream]
Saving to: ‘/etc/yum.repos.d/epel.repo’

100%[====================================================================================&amp;gt;] 664         --.-K/s   in 0s      

2020-10-27 22:43:51 (95.0 MB/s) - ‘/etc/yum.repos.d/epel.repo’ saved [664/664]

[root@node01 ~]# ll /etc/yum.repos.d/
total 8
drwxr-xr-x. 2 root root  219 Oct 27 22:42 bak
-rw-r--r--. 1 root root 2523 Jun 16  2018 CentOS-Base.repo
-rw-r--r--. 1 root root  664 May 11  2018 epel.repo
[root@node01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：在node02和node03上都要做以上操作；&lt;/p&gt;
&lt;p&gt;　　2、在各节点上配置openstack R版的yum仓库&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node01 ~]# yum install centos-release-openstack-rocky -y
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：以上操作会在/etc/yum.repos.d/目录下生成很多repo文件；&lt;/p&gt;
&lt;p&gt;　　验证：查看/etcyum.repos.d/目录下是否多了很多repo文件？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node01 ~]# ll /etc/yum.repos.d/
total 56
drwxr-xr-x. 2 root root  219 Oct 27 22:42 bak
-rw-r--r--. 1 root root 2523 Jun 16  2018 CentOS-Base.repo
-rw-r--r--. 1 root root  850 Jul 31  2018 CentOS-Ceph-Luminous.repo
-rw-r--r--. 1 root root 1309 Apr  8  2020 CentOS-CR.repo
-rw-r--r--. 1 root root  649 Apr  8  2020 CentOS-Debuginfo.repo
-rw-r--r--. 1 root root  314 Apr  8  2020 CentOS-fasttrack.repo
-rw-r--r--. 1 root root  630 Apr  8  2020 CentOS-Media.repo
-rw-r--r--. 1 root root 1186 Aug 29  2018 CentOS-OpenStack-rocky.repo
-rw-r--r--. 1 root root  612 Feb  1  2019 CentOS-QEMU-EV.repo
-rw-r--r--. 1 root root 1331 Apr  8  2020 CentOS-Sources.repo
-rw-r--r--. 1 root root  353 Jul 31  2018 CentOS-Storage-common.repo
-rw-r--r--. 1 root root 7577 Apr  8  2020 CentOS-Vault.repo
-rw-r--r--. 1 root root  616 Apr  8  2020 CentOS-x86_64-kernel.repo
-rw-r--r--. 1 root root  664 May 11  2018 epel.repo
[root@node01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：这里面的repo文件仓库地址都是指向centos的官方仓库，如果国内下载速度慢，可以把对应的地址指向阿里云；&lt;/p&gt;
&lt;p&gt;　　把centos-openstack-rocky.repo地址指向阿里云&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202010/1503305-20201027230819760-104611544.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：这里只需要改第一个就行，后面的仓库都是禁用了的，不用更改；&lt;/p&gt;
&lt;p&gt;　　把node01上的centos-openstack-rocky.repo文件复制给node02和node03&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node01 ~]# scp /etc/yum.repos.d/CentOS-OpenStack-rocky.repo node02:/etc/yum.repos.d/CentOS-OpenStack-rocky.repo
CentOS-OpenStack-rocky.repo                                                                 100% 1261   832.6KB/s   00:00    
[root@node01 ~]# scp /etc/yum.repos.d/CentOS-OpenStack-rocky.repo node03:/etc/yum.repos.d/CentOS-OpenStack-rocky.repo
CentOS-OpenStack-rocky.repo                                                                 100% 1261   387.4KB/s   00:00    
[root@node01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：复制要在后两个节点都装了centos-release-openstack-rocky这个包以后，以免后续装包覆盖仓库地址文件；&lt;/p&gt;
&lt;p&gt;　　3、在各节点安装python-openstackclient和openstack-selinux包&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node01 ~]# yum install -y python-openstackclient openstack-selinux 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　4、在node02上部署mariadb-server&lt;/p&gt;
&lt;p&gt;　　先查看mariadb-server这个包是否来自openstack-rocky这个仓库&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202010/1503305-20201027230220299-334865403.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：如果能够看到mariadb-server这个包来自centos-openstack-rocky这个仓库，说明我们配置的仓库没有问题；这里建议尽量使用openstacke-rocky仓库中提供的包，如果其他仓库提供的包可能存在不兼容的问题；&lt;/p&gt;
&lt;p&gt;　　下载安装mairadb-server&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node02 ~]# yum install mariadb-server -y
Loaded plugins: fastestmirror
Loading mirror speeds from cached hostfile
 * base: mirrors.aliyun.com
 * centos-qemu-ev: mirrors.aliyun.com
 * extras: mirrors.aliyun.com
 * updates: mirrors.aliyun.com
Resolving Dependencies
--&amp;gt; Running transaction check
---&amp;gt; Package mariadb-server.x86_64 3:10.1.20-2.el7 will be installed
--&amp;gt; Processing Dependency: mariadb-common(x86-64) = 3:10.1.20-2.el7 for package: 3:mariadb-server-10.1.20-2.el7.x86_64
--&amp;gt; Processing Dependency: mariadb-errmsg(x86-64) = 3:10.1.20-2.el7 for package: 3:mariadb-server-10.1.20-2.el7.x86_64
--&amp;gt; Processing Dependency: mysql(x86-64) for package: 3:mariadb-server-10.1.20-2.el7.x86_64
--&amp;gt; Processing Dependency: mysql-compat-client(x86-64) for package: 3:mariadb-server-10.1.20-2.el7.x86_64
--&amp;gt; Processing Dependency: perl(DBD::mysql) for package: 3:mariadb-server-10.1.20-2.el7.x86_64
--&amp;gt; Processing Dependency: perl(DBI) for package: 3:mariadb-server-10.1.20-2.el7.x86_64
--&amp;gt; Processing Dependency: perl(Data::Dumper) for package: 3:mariadb-server-10.1.20-2.el7.x86_64
--&amp;gt; Processing Dependency: rsync for package: 3:mariadb-server-10.1.20-2.el7.x86_64
--&amp;gt; Processing Dependency: socat for package: 3:mariadb-server-10.1.20-2.el7.x86_64
--&amp;gt; Running transaction check
---&amp;gt; Package mariadb.x86_64 3:10.1.20-2.el7 will be installed
--&amp;gt; Processing Dependency: mariadb-libs(x86-64) = 3:10.1.20-2.el7 for package: 3:mariadb-10.1.20-2.el7.x86_64
……省略部分内容……
Installed:
  mariadb-server.x86_64 3:10.1.20-2.el7                                                                                       

Dependency Installed:
  mariadb.x86_64 3:10.1.20-2.el7                                 mariadb-common.x86_64 3:10.1.20-2.el7                        
  mariadb-config.x86_64 3:10.1.20-2.el7                          mariadb-errmsg.x86_64 3:10.1.20-2.el7                        
  perl-Compress-Raw-Bzip2.x86_64 0:2.061-3.el7                   perl-Compress-Raw-Zlib.x86_64 1:2.061-4.el7                  
  perl-DBD-MySQL.x86_64 0:4.023-6.el7                            perl-DBI.x86_64 0:1.627-4.el7                                
  perl-Data-Dumper.x86_64 0:2.145-3.el7                          perl-IO-Compress.noarch 0:2.061-2.el7                        
  perl-Net-Daemon.noarch 0:0.48-5.el7                            perl-PlRPC.noarch 0:0.2020-14.el7                            
  rsync.x86_64 0:3.1.2-10.el7                                    socat.x86_64 0:1.7.3.2-2.el7                                 

Dependency Updated:
  mariadb-libs.x86_64 3:10.1.20-2.el7                                                                                         

Complete!
[root@node02 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　配置数据库&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node02 ~]# cat /etc/my.cnf.d/openstack.cnf 
[mysqld]
bind-address = 0.0.0.0

default-storage-engine = innodb
innodb_file_per_table = on
max_connections = 4096
collation-server = utf8_general_ci
character-set-server = utf8
[root@node02 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　设置mariadb-server开机启动，并启动mairadb-server&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node02 ~]# systemctl enable mariadb.service 
Created symlink from /etc/systemd/system/multi-user.target.wants/mariadb.service to /usr/lib/systemd/system/mariadb.service.
[root@node02 ~]# systemctl start mariadb.service       
[root@node02 ~]# ss -tnl
State      Recv-Q Send-Q                  Local Address:Port                                 Peer Address:Port              
LISTEN     0      128                                 *:22                                              *:*                  
LISTEN     0      100                         127.0.0.1:25                                              *:*                  
LISTEN     0      128                                 *:3306                                            *:*                  
LISTEN     0      128                                :::22                                             :::*                  
LISTEN     0      100                               ::1:25                                             :::*                  
[root@node02 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　5、在node01上安装python2-PyMySQL包，用于控制节点连接数据库驱动&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node01 ~]# yum install -y python2-PyMySQL
Loaded plugins: fastestmirror
Loading mirror speeds from cached hostfile
 * base: mirrors.aliyun.com
 * centos-qemu-ev: mirrors.aliyun.com
 * extras: mirrors.aliyun.com
 * updates: mirrors.aliyun.com
Resolving Dependencies
--&amp;gt; Running transaction check
---&amp;gt; Package python2-PyMySQL.noarch 0:0.9.3-1.el7 will be installed
--&amp;gt; Finished Dependency Resolution

Dependencies Resolved

==============================================================================================================================
 Package                            Arch                      Version                           Repository               Size
==============================================================================================================================
Installing:
 python2-PyMySQL                    noarch                    0.9.3-1.el7                       epel                     91 k

Transaction Summary
==============================================================================================================================
Install  1 Package

Total download size: 91 k
Installed size: 372 k
Downloading packages:
python2-PyMySQL-0.9.3-1.el7.noarch.rpm                                                                 |  91 kB  00:00:00     
Running transaction check
Running transaction test
Transaction test succeeded
Running transaction
  Installing : python2-PyMySQL-0.9.3-1.el7.noarch                                                                         1/1 
  Verifying  : python2-PyMySQL-0.9.3-1.el7.noarch                                                                         1/1 

Installed:
  python2-PyMySQL.noarch 0:0.9.3-1.el7                                                                                        

Complete!
[root@node01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　6、在node02上部署memcached&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node02 ~]# yum install memcached -y
Loaded plugins: fastestmirror
Loading mirror speeds from cached hostfile
 * base: mirrors.aliyun.com
 * centos-qemu-ev: mirrors.aliyun.com
 * extras: mirrors.aliyun.com
 * updates: mirrors.aliyun.com
Resolving Dependencies
--&amp;gt; Running transaction check
---&amp;gt; Package memcached.x86_64 0:1.5.6-1.el7 will be installed
--&amp;gt; Finished Dependency Resolution

Dependencies Resolved

==============================================================================================================================
 Package                   Arch                   Version                        Repository                              Size
==============================================================================================================================
Installing:
 memcached                 x86_64                 1.5.6-1.el7                    centos-openstack-rocky                 124 k

Transaction Summary
==============================================================================================================================
Install  1 Package

Total download size: 124 k
Installed size: 268 k
Downloading packages:
memcached-1.5.6-1.el7.x86_64.rpm                                                                       | 124 kB  00:00:00     
Running transaction check
Running transaction test
Transaction test succeeded
Running transaction
  Installing : memcached-1.5.6-1.el7.x86_64                                                                               1/1 
  Verifying  : memcached-1.5.6-1.el7.x86_64                                                                               1/1 

Installed:
  memcached.x86_64 0:1.5.6-1.el7                                                                                              

Complete!
[root@node02 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　配置memcached&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node02 ~]# cat /etc/sysconfig/memcached
PORT=&quot;11211&quot;
USER=&quot;memcached&quot;
MAXCONN=&quot;4096&quot;
CACHESIZE=&quot;1024&quot;
OPTIONS=&quot;-l 0.0.0.0,::1&quot;
[root@node02 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　设置memcached开机启动，并启动memcached服务&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node02 ~]# systemctl enable memcached.service
Created symlink from /etc/systemd/system/multi-user.target.wants/memcached.service to /usr/lib/systemd/system/memcached.service.
[root@node02 ~]# systemctl start memcached.service 
[root@node02 ~]# ss -tnl
State      Recv-Q Send-Q                  Local Address:Port                                 Peer Address:Port              
LISTEN     0      128                                 *:11211                                           *:*                  
LISTEN     0      128                                 *:22                                              *:*                  
LISTEN     0      100                         127.0.0.1:25                                              *:*                  
LISTEN     0      128                                 *:3306                                            *:*                  
LISTEN     0      128                               ::1:11211                                          :::*                  
LISTEN     0      128                                :::22                                             :::*                  
LISTEN     0      100                               ::1:25                                             :::*                  
[root@node02 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　7、在node01上安装连接memcached驱动，python-memcached&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node01 ~]# yum install -y python-memcached
Loaded plugins: fastestmirror
Loading mirror speeds from cached hostfile
 * base: mirrors.aliyun.com
 * centos-qemu-ev: mirrors.aliyun.com
 * extras: mirrors.aliyun.com
 * updates: mirrors.aliyun.com
Resolving Dependencies
--&amp;gt; Running transaction check
---&amp;gt; Package python-memcached.noarch 0:1.58-1.el7 will be installed
--&amp;gt; Finished Dependency Resolution

Dependencies Resolved

==============================================================================================================================
 Package                         Arch                  Version                    Repository                             Size
==============================================================================================================================
Installing:
 python-memcached                noarch                1.58-1.el7                 centos-openstack-rocky                 38 k

Transaction Summary
==============================================================================================================================
Install  1 Package

Total download size: 38 k
Installed size: 123 k
Downloading packages:
python-memcached-1.58-1.el7.noarch.rpm                                                                 |  38 kB  00:00:00     
Running transaction check
Running transaction test
Transaction test succeeded
Running transaction
  Installing : python-memcached-1.58-1.el7.noarch                                                                         1/1 
  Verifying  : python-memcached-1.58-1.el7.noarch                                                                         1/1 

Installed:
  python-memcached.noarch 0:1.58-1.el7                                                                                        

Complete!
[root@node01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　8、在node02上部署rabbitmq-server&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node02 ~]# yum install rabbitmq-server -y
Loaded plugins: fastestmirror
Loading mirror speeds from cached hostfile
 * base: mirrors.aliyun.com
 * centos-qemu-ev: mirrors.aliyun.com
 * extras: mirrors.aliyun.com
 * updates: mirrors.aliyun.com
Resolving Dependencies
--&amp;gt; Running transaction check
---&amp;gt; Package rabbitmq-server.noarch 0:3.6.16-1.el7 will be installed
--&amp;gt; Processing Dependency: erlang-eldap &amp;gt;= 18 for package: rabbitmq-server-3.6.16-1.el7.noarch
--&amp;gt; Processing Dependency: erlang-erts &amp;gt;= 18 for package: rabbitmq-server-3.6.16-1.el7.noarch
--&amp;gt; Processing Dependency: erlang-kernel &amp;gt;= 18 for package: rabbitmq-server-3.6.16-1.el7.noarch
--&amp;gt; Processing Dependency: erlang-mnesia &amp;gt;= 18 for package: rabbitmq-server-3.6.16-1.el7.noarch
--&amp;gt; Processing Dependency: erlang-os_mon &amp;gt;= 18 for package: rabbitmq-server-3.6.16-1.el7.noarch
--&amp;gt; Processing Dependency: erlang-public_key &amp;gt;= 18 for package: rabbitmq-server-3.6.16-1.el7.noarch
……省略部分内容……
Installed:
  rabbitmq-server.noarch 0:3.6.16-1.el7                                                                                       

Dependency Installed:
  erlang-asn1.x86_64 0:19.3.6.4-1.el7                             erlang-compiler.x86_64 0:19.3.6.4-1.el7                     
  erlang-crypto.x86_64 0:19.3.6.4-1.el7                           erlang-eldap.x86_64 0:19.3.6.4-1.el7                        
  erlang-erts.x86_64 0:19.3.6.4-1.el7                             erlang-hipe.x86_64 0:19.3.6.4-1.el7                         
  erlang-inets.x86_64 0:19.3.6.4-1.el7                            erlang-kernel.x86_64 0:19.3.6.4-1.el7                       
  erlang-mnesia.x86_64 0:19.3.6.4-1.el7                           erlang-os_mon.x86_64 0:19.3.6.4-1.el7                       
  erlang-otp_mibs.x86_64 0:19.3.6.4-1.el7                         erlang-public_key.x86_64 0:19.3.6.4-1.el7                   
  erlang-runtime_tools.x86_64 0:19.3.6.4-1.el7                    erlang-sasl.x86_64 0:19.3.6.4-1.el7                         
  erlang-sd_notify.x86_64 0:1.0-2.el7                             erlang-snmp.x86_64 0:19.3.6.4-1.el7                         
  erlang-ssl.x86_64 0:19.3.6.4-1.el7                              erlang-stdlib.x86_64 0:19.3.6.4-1.el7                       
  erlang-syntax_tools.x86_64 0:19.3.6.4-1.el7                     erlang-tools.x86_64 0:19.3.6.4-1.el7                        
  erlang-xmerl.x86_64 0:19.3.6.4-1.el7                            lksctp-tools.x86_64 0:1.0.17-2.el7                          

Complete!
[root@node02 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　设置rabbitmq-server开机启动，并启动mabbitmq-server服务&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node02 ~]# systemctl enable rabbitmq-server.service
Created symlink from /etc/systemd/system/multi-user.target.wants/rabbitmq-server.service to /usr/lib/systemd/system/rabbitmq-server.service.
[root@node02 ~]# systemctl start rabbitmq-server.service 
[root@node02 ~]# ss -tnl
State      Recv-Q Send-Q                  Local Address:Port                                 Peer Address:Port              
LISTEN     0      128                                 *:11211                                           *:*                  
LISTEN     0      128                                 *:4369                                            *:*                  
LISTEN     0      128                                 *:22                                              *:*                  
LISTEN     0      100                         127.0.0.1:25                                              *:*                  
LISTEN     0      128                                 *:25672                                           *:*                  
LISTEN     0      128                                 *:3306                                            *:*                  
LISTEN     0      128                               ::1:11211                                          :::*                  
LISTEN     0      128                                :::22                                             :::*                  
LISTEN     0      100                               ::1:25                                             :::*                  
LISTEN     0      128                                :::5672                                           :::*                  
[root@node02 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　创建openstack用户并设置密码为openstack123&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node02 ~]# rabbitmqctl add_user openstack openstack123
Creating user &quot;openstack&quot;
[root@node02 ~]# rabbitmqctl list_users
Listing users
openstack       []
guest   [administrator]
[root@node02 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　授权openstack用户对/下的所有文件有读写&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node02 ~]# rabbitmqctl set_permissions openstack &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;
Setting permissions for user &quot;openstack&quot; in vhost &quot;/&quot;
[root@node02 ~]# rabbitmqctl list_permissions
Listing permissions in vhost &quot;/&quot;
guest   .*      .*      .*
openstack       .*      .*      .*
[root@node02 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　到此，openstack的基础环境和数据库节点就准备ok了，后续我们就可以在逐一安装各个控制节点上的服务和计算节点上的服务；&lt;/p&gt;
</description>
<pubDate>Tue, 27 Oct 2020 15:59:00 +0000</pubDate>
<dc:creator>Linux-1874</dc:creator>
<og:description>一、简介 什么是openstack?它是干嘛用的？ 简单说openstack是云计算管理平台，主要对云环境中的虚拟机做增删查改；它能够将多台物理设备的资源（cpu/内存等）整合成一个大的资源池，然后根</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qiuhom-1874/p/13886693.html</dc:identifier>
</item>
<item>
<title>Jenkins 凭证管理 - 看这一篇就够了~ - IT胖</title>
<link>http://www.cnblogs.com/FLY_DREAM/p/13888423.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/FLY_DREAM/p/13888423.html</guid>
<description>&lt;p&gt;许多三方网站和应用可以与Jenkins交互，如Artifact仓库，基于云的存储系统和服务等. 在Jenkins中添加/配置credentials，Pipeline项目就可以使用 credentials 与三方应用交互&lt;/p&gt;
&lt;h2 id=&quot;credential-类型&quot;&gt;Credential 类型&lt;/h2&gt;
&lt;p&gt;参考： &lt;a href=&quot;https://jenkins.io/zh/doc/book/using/using-credentials/&quot;&gt;https://jenkins.io/zh/doc/book/using/using-credentials/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Jenkins可以存储以下类型的credentials:&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Secret text - API token之类的token (如GitHub个人访问token)&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Username and password - 可以为独立的字段，也可以为冒号分隔的字符串：username:password(更多信息请参照 处理 credentials)&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Secret file - 保存在文件中的加密内容&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;SSH Username with private key - SSH 公钥/私钥对&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Certificate - a PKCS#12 证书文件 和可选密码&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Docker Host Certificate Authentication credentials.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;credential-安全&quot;&gt;Credential 安全&lt;/h2&gt;
&lt;p&gt;为了最大限度地提高安全性，在Jenins中配置的 credentials 以加密形式存储在Jenkins 主节点上（用Jenkins ID加密），并且 &lt;code&gt;只能通过 credentials ID&lt;/code&gt; 在Pipeline项目中获取&lt;/p&gt;
&lt;p&gt;这最大限度地减少了向Jenkins用户公开credentials真实内容的可能性，并且阻止了将credentials复制到另一台Jenkins实例&lt;/p&gt;
&lt;h2 id=&quot;credential-创建&quot;&gt;Credential 创建&lt;/h2&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;选择适合的凭证类型&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/owen2016/pic-hub/raw/master/pics/20201027222335.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;创建 “Username and password” 凭证&lt;br/&gt;&lt;img src=&quot;https://gitee.com/owen2016/pic-hub/raw/master/pics/20201027223010.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;创建 “SSH Username with private key” 凭证&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/owen2016/pic-hub/raw/master/pics/20201027222917.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;credential-id-定义&quot;&gt;Credential ID 定义&lt;/h3&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;在 ID 字段中，必须指定一个有意义的&lt;code&gt;Credential ID&lt;/code&gt;- 例如 jenkins-user-for-xyz-artifact-repository。注意: 该字段是可选的。 如果您没有指定值, Jenkins 则Jenkins会分配一个全局唯一ID（GUID）值。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;请记住：&lt;/strong&gt; 一旦设置了credential ID，就不能再进行更改。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;credential-使用&quot;&gt;Credential 使用&lt;/h2&gt;
&lt;p&gt;参考： &lt;a href=&quot;https://www.jenkins.io/doc/book/pipeline/jenkinsfile/#handling-credentials&quot;&gt;https://www.jenkins.io/doc/book/pipeline/jenkinsfile/#handling-credentials&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;存储在Jenkins中的credentials可以被使用：&lt;/p&gt;
&lt;ol readability=&quot;1.4339378238342&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;适用于Jenkins的任何地方 (即全局 credentials),&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;通过特定的Pipeline项目/项目 (在 处理 credentials 和 使用Jenkinsfile部分了解更多信息),&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-0.92272727272727&quot;&gt;
&lt;p&gt;由特定的Jenkins用户 (如 Pipeline 项目中&lt;a href=&quot;https://jenkins.io/zh/doc/book/blueocean/creating-pipelines/&quot;&gt;创建 Blue Ocean&lt;/a&gt;的情况).&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Blue Ocean 自动生成一个 SSH 公共/私有密钥对, 确保 SSH 公共/私有秘钥对在继续之前已经被注册到你的Git服务器&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;实际使用中，下面几个场景会用到creential&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;gitlab 访问、API调用&lt;/li&gt;
&lt;li&gt;jenkins slave 创建&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;credential-相关插件&quot;&gt;Credential 相关插件&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 上述 Credential 类型都依赖于 jenkins插件，同样jenkins pipeline 也需要这些插件的安装以支持代码片段&lt;/p&gt;
&lt;ul readability=&quot;6.0689655172414&quot;&gt;&lt;li readability=&quot;12.300915331808&quot;&gt;
&lt;p&gt;Credentials Binding： &lt;a href=&quot;https://plugins.jenkins.io/credentials-binding/&quot;&gt;https://plugins.jenkins.io/credentials-binding/&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;For secret text, usernames and passwords, and secret files&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;environment {
MAGE_REPO_CREDENTIALS = credentials('COMPOSER_REPO_MAGENTO')
COMPOSER_AUTH = &quot;&quot;&quot;{
  &quot;http-basic&quot;: {
      &quot;repo.magento.com&quot;: {
          &quot;username&quot;: &quot;${env.MAGE_REPO_CREDENTIALS_USR}&quot;,
          &quot;password&quot;: &quot;${env.MAGE_REPO_CREDENTIALS_PSW}&quot;
      }
  } }&quot;&quot;&quot;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;For other credential types&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;withCredentials([usernamePassword(credentialsId: 'amazon', usernameVariable: 'USERNAME', passwordVariable: 'PASSWORD')]) {
// available as an env variable, but will be masked if you try to print it out any which way
// note: single quotes prevent Groovy interpolation; expansion is by Bourne Shell, which is what you want
sh 'echo $PASSWORD'
// also available as a Groovy variable
echo USERNAME
// or inside double quotes for string interpolation
echo &quot;username is $USERNAME&quot;
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-0.43037974683544&quot;&gt;
&lt;p&gt;Jenkins Plain Credentials Plugin: &lt;a href=&quot;https://plugins.jenkins.io/plain-credentials/&quot;&gt;https://plugins.jenkins.io/plain-credentials/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/owen2016/pic-hub/raw/master/pics/20201027224420.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-0.28333333333333&quot;&gt;
&lt;p&gt;SSH Credentials: &lt;a href=&quot;https://plugins.jenkins.io/ssh-credentials/&quot;&gt;https://plugins.jenkins.io/ssh-credentials/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;最佳实践&quot;&gt;最佳实践&lt;/h2&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;为了便于管理和使用， 强烈建议使用统一的约定来指定credential ID&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;建议使用类似下面的format做为credential ID， 便于jenkinsfile开发时直接使用，同时在”描述“里写清楚credential的作用&lt;/p&gt;
&lt;p&gt;&lt;code&gt;gitlab-api-token、gitlab-private-key、gitlab-userpwd-pair、harbor-xxx-xxx&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/owen2016/pic-hub/raw/master/pics/20201027221956.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;实践：&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;如下所示，将凭证使用统一的ID命名之后，便于复用，凭证定义一次，可多次，多个地方统一使用，无论是后期维护，复用都非常方便！&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;    environment {
        // HARBOR=&quot;harbor.devopsing.site&quot;
        HARBOR_ACCESS_KEY = credentials('harbor-userpwd-pair')
        SERVER_ACCESS_KEY = credentials('deploy-userpwd-pair')
            }
    .....

    docker login --username=${HARBOR_ACCESS_KEY_USR} --password=${HARBOR_ACCESS_KEY_PSW} ${HARBOR}

    sshpass -p &quot;${SERVER_ACCESS_KEY_PSW}&quot; ssh -o StrictHostKeyChecking=no ${SERVER_ACCESS_KEY_USR}@${DEPLOY_SERVER} &quot;$runCmd&quot;
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Tue, 27 Oct 2020 15:19:00 +0000</pubDate>
<dc:creator>IT胖</dc:creator>
<og:description>许多三方网站和应用可以与Jenkins交互，如Artifact仓库，基于云的存储系统和服务等. 在Jenkins中添加/配置credentials，Pipeline项目就可以使用 credential</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/FLY_DREAM/p/13888423.html</dc:identifier>
</item>
<item>
<title>Hadoop框架：HDFS高可用环境配置 - 知了一笑</title>
<link>http://www.cnblogs.com/cicada-smile/p/13888296.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cicada-smile/p/13888296.html</guid>
<description>&lt;p&gt;在单点或者少数节点故障的情况下，集群还可以正常的提供服务，HDFS高可用机制可以通过配置Active/Standby两个NameNodes节点实现在集群中对NameNode的热备来消除单节点故障问题，如果单个节点出现故障，可通过该方式将NameNode快速切换到另外一个节点上。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;173.66887730933&quot;&gt;
&lt;p&gt;本文源码：&lt;a href=&quot;https://github.com/cicadasmile/big-data-parent&quot;&gt;GitHub·点这里&lt;/a&gt; || &lt;a href=&quot;https://gitee.com/cicadasmile/big-data-parent&quot;&gt;GitEE·点这里&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;1、基础描述&quot;&gt;1、基础描述&lt;/h2&gt;
&lt;p&gt;在单点或者少数节点故障的情况下，集群还可以正常的提供服务，HDFS高可用机制可以通过配置Active/Standby两个NameNodes节点实现在集群中对NameNode的热备来消除单节点故障问题，如果单个节点出现故障，可通过该方式将NameNode快速切换到另外一个节点上。&lt;/p&gt;
&lt;h2 id=&quot;2、机制详解&quot;&gt;2、机制详解&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1691717/202010/1691717-20201027223001383-671579148.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;基于两个NameNode做高可用，依赖共享Edits文件和Zookeeper集群；&lt;/li&gt;
&lt;li&gt;每个NameNode节点配置一个ZKfailover进程，负责监控所在NameNode节点状态；&lt;/li&gt;
&lt;li&gt;NameNode与ZooKeeper集群维护一个持久会话；&lt;/li&gt;
&lt;li&gt;如果Active节点故障停机，ZooKeeper通知Standby状态的NameNode节点；&lt;/li&gt;
&lt;li&gt;在ZKfailover进程检测并确认故障节点无法工作后；&lt;/li&gt;
&lt;li&gt;ZKfailover通知Standby状态的NameNode节点切换为Active状态继续服务；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;ZooKeeper在大数据体系中非常重要，协调不同组件的工作，维护并传递数据，例如上述高可用下自动故障转移就依赖于ZooKeeper组件。&lt;/p&gt;

&lt;h2 id=&quot;1、整体配置&quot;&gt;1、整体配置&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;服务列表&lt;/th&gt;
&lt;th&gt;HDFS文件&lt;/th&gt;
&lt;th&gt;YARN调度&lt;/th&gt;
&lt;th&gt;单服务&lt;/th&gt;
&lt;th&gt;共享文件&lt;/th&gt;
&lt;th&gt;Zk集群&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;hop01&lt;/td&gt;
&lt;td&gt;DataNode&lt;/td&gt;
&lt;td&gt;NodeManager&lt;/td&gt;
&lt;td&gt;NameNode&lt;/td&gt;
&lt;td&gt;JournalNode&lt;/td&gt;
&lt;td&gt;ZK-hop01&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;hop02&lt;/td&gt;
&lt;td&gt;DataNode&lt;/td&gt;
&lt;td&gt;NodeManager&lt;/td&gt;
&lt;td&gt;ResourceManager&lt;/td&gt;
&lt;td&gt;JournalNode&lt;/td&gt;
&lt;td&gt;ZK-hop02&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;hop03&lt;/td&gt;
&lt;td&gt;DataNode&lt;/td&gt;
&lt;td&gt;NodeManager&lt;/td&gt;
&lt;td&gt;SecondaryNameNode&lt;/td&gt;
&lt;td&gt;JournalNode&lt;/td&gt;
&lt;td&gt;ZK-hop03&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;2、配置journalnode&quot;&gt;2、配置JournalNode&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;创建目录&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@hop01 opt]# mkdir hopHA
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;拷贝Hadoop目录&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cp -r /opt/hadoop2.7/ /opt/hopHA/
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;配置core-site.xml&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;configuration&amp;gt;
    &amp;lt;!-- NameNode集群模式 --&amp;gt;
        &amp;lt;property&amp;gt;
                &amp;lt;name&amp;gt;fs.defaultFS&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;hdfs://mycluster&amp;lt;/value&amp;gt;
        &amp;lt;/property&amp;gt;
        &amp;lt;!-- 指定hadoop运行时产生文件的存储目录 --&amp;gt;
        &amp;lt;property&amp;gt;
                &amp;lt;name&amp;gt;hadoop.tmp.dir&amp;lt;/name&amp;gt;
           &amp;lt;value&amp;gt;/opt/hopHA/hadoop2.7/data/tmp&amp;lt;/value&amp;gt;
        &amp;lt;/property&amp;gt;
&amp;lt;/configuration&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;配置hdfs-site.xml&lt;/strong&gt;，添加内容如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;!-- 分布式集群名称 --&amp;gt;
&amp;lt;property&amp;gt;
        &amp;lt;name&amp;gt;dfs.nameservices&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;mycluster&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;

&amp;lt;!-- 集群中NameNode节点 --&amp;gt;
&amp;lt;property&amp;gt;
        &amp;lt;name&amp;gt;dfs.ha.namenodes.mycluster&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;nn1,nn2&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;

&amp;lt;!-- NN1 RPC通信地址 --&amp;gt;
&amp;lt;property&amp;gt;
        &amp;lt;name&amp;gt;dfs.namenode.rpc-address.mycluster.nn1&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;hop01:9000&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;

&amp;lt;!-- NN2 RPC通信地址 --&amp;gt;
&amp;lt;property&amp;gt;
        &amp;lt;name&amp;gt;dfs.namenode.rpc-address.mycluster.nn2&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;hop02:9000&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;

&amp;lt;!-- NN1 Http通信地址 --&amp;gt;
&amp;lt;property&amp;gt;
        &amp;lt;name&amp;gt;dfs.namenode.http-address.mycluster.nn1&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;hop01:50070&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;

&amp;lt;!-- NN2 Http通信地址 --&amp;gt;
&amp;lt;property&amp;gt;
        &amp;lt;name&amp;gt;dfs.namenode.http-address.mycluster.nn2&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;hop02:50070&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;

&amp;lt;!-- 指定NameNode元数据在JournalNode上的存放位置 --&amp;gt;
&amp;lt;property&amp;gt;
        &amp;lt;name&amp;gt;dfs.namenode.shared.edits.dir&amp;lt;/name&amp;gt;
    &amp;lt;value&amp;gt;qjournal://hop01:8485;hop02:8485;hop03:8485/mycluster&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;

&amp;lt;!-- 配置隔离机制，即同一时刻只能有一台服务器对外响应 --&amp;gt;
&amp;lt;property&amp;gt;
        &amp;lt;name&amp;gt;dfs.ha.fencing.methods&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;sshfence&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;

&amp;lt;!-- 使用隔离机制时需要ssh无秘钥登录--&amp;gt;
&amp;lt;property&amp;gt;
        &amp;lt;name&amp;gt;dfs.ha.fencing.ssh.private-key-files&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;/root/.ssh/id_rsa&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;

&amp;lt;!-- 声明journalnode服务器存储目录--&amp;gt;
&amp;lt;property&amp;gt;
        &amp;lt;name&amp;gt;dfs.journalnode.edits.dir&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;/opt/hopHA/hadoop2.7/data/jn&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;

&amp;lt;!-- 关闭权限检查--&amp;gt;
&amp;lt;property&amp;gt;
        &amp;lt;name&amp;gt;dfs.permissions.enable&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;false&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;

&amp;lt;!-- 访问代理类失败自动切换实现方式--&amp;gt;
&amp;lt;property&amp;gt;
        &amp;lt;name&amp;gt;dfs.client.failover.proxy.provider.mycluster&amp;lt;/name&amp;gt;
    &amp;lt;value&amp;gt;org.apache.hadoop.hdfs.server.namenode.ha.ConfiguredFailoverProxyProvider&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;依次启动journalnode服务&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@hop01 hadoop2.7]# pwd
/opt/hopHA/hadoop2.7
[root@hop01 hadoop2.7]# sbin/hadoop-daemon.sh start journalnode
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;删除hopHA下数据&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@hop01 hadoop2.7]# rm -rf data/ logs/
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;NN1格式化并启动NameNode&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@hop01 hadoop2.7]# pwd
/opt/hopHA/hadoop2.7
bin/hdfs namenode -format
sbin/hadoop-daemon.sh start namenode
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;NN2同步NN1数据&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@hop02 hadoop2.7]# bin/hdfs namenode -bootstrapStandby
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;NN2启动NameNode&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@hop02 hadoop2.7]# sbin/hadoop-daemon.sh start namenode
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;查看当前状态&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1691717/202010/1691717-20201027223019522-132449956.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在NN1上启动全部DataNode&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@hop01 hadoop2.7]# sbin/hadoop-daemons.sh start datanode
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;NN1切换为Active状态&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@hop01 hadoop2.7]# bin/hdfs haadmin -transitionToActive nn1
[root@hop01 hadoop2.7]# bin/hdfs haadmin -getServiceState nn1
active
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1691717/202010/1691717-20201027223034607-884135953.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;3、故障转移配置&quot;&gt;3、故障转移配置&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;配置hdfs-site.xml&lt;/em&gt;，新增内容如下，同步集群&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;property&amp;gt;
        &amp;lt;name&amp;gt;dfs.ha.automatic-failover.enabled&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;true&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;配置core-site.xml&lt;/strong&gt;，新增内容如下，同步集群&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;property&amp;gt;
        &amp;lt;name&amp;gt;ha.zookeeper.quorum&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;hop01:2181,hop02:2181,hop03:2181&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;关闭全部HDFS服务&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@hop01 hadoop2.7]# sbin/stop-dfs.sh
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;启动Zookeeper集群&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/opt/zookeeper3.4/bin/zkServer.sh start
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;hop01初始化HA在Zookeeper中状态&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@hop01 hadoop2.7]# bin/hdfs zkfc -formatZK
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;hop01启动HDFS服务&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@hop01 hadoop2.7]# sbin/start-dfs.sh
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;NameNode节点启动ZKFailover&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里hop01和hop02先启动的服务状态就是Active，这里先启动hop02。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[hadoop2.7]# sbin/hadoop-daemon.sh start zkfc
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1691717/202010/1691717-20201027223050340-623807402.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;结束hop02的NameNode进程&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;kill -9 14422
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;等待一下查看hop01状态&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@hop01 hadoop2.7]# bin/hdfs haadmin -getServiceState nn1
active
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;1、基础描述-2&quot;&gt;1、基础描述&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1691717/202010/1691717-20201027223103749-592046830.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;基本流程和思路与HDFS机制类似，依赖Zookeeper集群，当Active节点故障时，Standby节点会切换为Active状态持续服务。&lt;/p&gt;
&lt;h2 id=&quot;2、配置详解&quot;&gt;2、配置详解&lt;/h2&gt;
&lt;p&gt;环境同样基于hop01和hop02来演示。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;配置yarn-site.xml&lt;/strong&gt;，同步集群下服务&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;configuration&amp;gt;

    &amp;lt;property&amp;gt;
        &amp;lt;name&amp;gt;yarn.nodemanager.aux-services&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;mapreduce_shuffle&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;

    &amp;lt;!--启用HA机制--&amp;gt;
    &amp;lt;property&amp;gt;
        &amp;lt;name&amp;gt;yarn.resourcemanager.ha.enabled&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;true&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
 
    &amp;lt;!--声明Resourcemanager服务--&amp;gt;
    &amp;lt;property&amp;gt;
        &amp;lt;name&amp;gt;yarn.resourcemanager.cluster-id&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;cluster-yarn01&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;

    &amp;lt;property&amp;gt;
        &amp;lt;name&amp;gt;yarn.resourcemanager.ha.rm-ids&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;rm1,rm2&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;

    &amp;lt;property&amp;gt;
        &amp;lt;name&amp;gt;yarn.resourcemanager.hostname.rm1&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;hop01&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;

    &amp;lt;property&amp;gt;
        &amp;lt;name&amp;gt;yarn.resourcemanager.hostname.rm2&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;hop02&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
 
    &amp;lt;!--Zookeeper集群的地址--&amp;gt; 
    &amp;lt;property&amp;gt;
        &amp;lt;name&amp;gt;yarn.resourcemanager.zk-address&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;hop01:2181,hop02:2181,hop03:2181&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;

    &amp;lt;!--启用自动恢复机制--&amp;gt; 
    &amp;lt;property&amp;gt;
        &amp;lt;name&amp;gt;yarn.resourcemanager.recovery.enabled&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;true&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
 
    &amp;lt;!--指定状态存储Zookeeper集群--&amp;gt; 
    &amp;lt;property&amp;gt;
        &amp;lt;name&amp;gt;yarn.resourcemanager.store.class&amp;lt;/name&amp;gt;     &amp;lt;value&amp;gt;org.apache.hadoop.yarn.server.resourcemanager.recovery.ZKRMStateStore&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;

&amp;lt;/configuration&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;重启journalnode节点&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;sbin/hadoop-daemon.sh start journalnode
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;在NN1服务格式化并启动&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@hop01 hadoop2.7]# bin/hdfs namenode -format
[root@hop01 hadoop2.7]# sbin/hadoop-daemon.sh start namenode
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;NN2上同步NN1元数据&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@hop02 hadoop2.7]# bin/hdfs namenode -bootstrapStandby
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;启动集群下DataNode&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@hop01 hadoop2.7]# sbin/hadoop-daemons.sh start datanode
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;NN1设置为Active状态&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;先启动hop01即可，然后启动hop02。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@hop01 hadoop2.7]# sbin/hadoop-daemon.sh start zkfc
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;hop01启动yarn&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@hop01 hadoop2.7]# sbin/start-yarn.sh
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;hop02启动ResourceManager&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@hop02 hadoop2.7]# sbin/yarn-daemon.sh start resourcemanager
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;查看状态&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@hop01 hadoop2.7]# bin/yarn rmadmin -getServiceState rm1
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1691717/202010/1691717-20201027223121244-1313008439.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;GitHub·地址
https://github.com/cicadasmile/big-data-parent
GitEE·地址
https://gitee.com/cicadasmile/big-data-parent
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;推荐阅读：编程体系整理&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Tue, 27 Oct 2020 14:51:00 +0000</pubDate>
<dc:creator>知了一笑</dc:creator>
<og:description>在单点或者少数节点故障的情况下，集群还可以正常的提供服务，HDFS高可用机制可以通过配置Active/Standby两个NameNodes节点实现在集群中对NameNode的热备来消除单节点故障问题，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cicada-smile/p/13888296.html</dc:identifier>
</item>
<item>
<title>【原创】转管理了（1）：突如其来的“上位” - sfrost</title>
<link>http://www.cnblogs.com/sfrost/p/13887630.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sfrost/p/13887630.html</guid>
<description>&lt;p&gt;这是一篇迟来的系列文章（下图是2018年在博客园写的草稿），原本已打算不写了，毕竟自己没读过什么书，怕大家笑话：）&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/42979/202010/42979-20201027222909922-163269804.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从2017年开始，名义上我已经不是一个纯粹的技术工作者了（职位：信息部&lt;strong&gt;副经理&lt;/strong&gt;），可整个2017年我都呆在项目上，后来又走南闯北地去实施推广，到了2018年回来后才真正意义上接触到部门的管理工作，也开始独自负责一个事业部的信息化工作。&lt;/p&gt;
&lt;h3 id=&quot;台面上发生的故事&quot;&gt;台面上发生的故事&lt;/h3&gt;
&lt;p&gt;所以，我要写的故事是从2018年开始，直到现在正在发生的所有真实事情。当然，这些故事都是&lt;strong&gt;台面上&lt;/strong&gt;的：代表其见光不会死、代表其真实性。&lt;/p&gt;
&lt;h3 id=&quot;为什么又要写了&quot;&gt;为什么又要写了&lt;/h3&gt;
&lt;p&gt;自己已过而立之年，到现在还是&lt;strong&gt;一事无成&lt;/strong&gt;（类似学C#这种事没达成），所以打算把自己的经历分享出来：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;为了看清自己以前SB的地方，然后在未来调整&lt;/li&gt;
&lt;li&gt;找找成就感：分享自己所学、所悟、所做之事&lt;/li&gt;
&lt;li&gt;学markdown语法：我会平移所有文章自己的网站，哈哈，因为用的markdown，连排版都不会乱。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;愿你出走半生，归来仍是少年&quot;&gt;愿你出走半生，归来仍是少年&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;复盘的最重要目的：检讨自己。&lt;/strong&gt;是否仍然坚持”学习“的初心？人生的目标还是10几年前说的”为了实现自我价值“吗？凡事还是喜欢较真吗？还有很多很多自己坚持的标签……&lt;br/&gt;虽然成年人的世界都不容易，可我还是觉得：有舍必有得、凡事没有对错（这句话千万不能对小孩讲）、要懂得选择、要认真的努力、无时无刻都要保持学习心态。&lt;/p&gt;
&lt;h3 id=&quot;故事就从上位开始&quot;&gt;故事就从”上位“开始……&lt;/h3&gt;
&lt;p&gt;很简单，老板说：你要年轻些，能更好地和团队打成一片，要好好协助XXX把团队带好，职位先定个副经理，就放心地在这好好干。&lt;br/&gt;就这样定了。&lt;/p&gt;
&lt;p&gt;然后发生了一个小事，大家感受一下：之前部门有个同事（比我先进公司，年龄比我小），我通常随着大家的几种称呼：小C、C哥、CC，平时都不觉得有什么。当公司大会上宣读了任命文件后（有我），第二天我无意之间又叫了”小C“，这时候隔壁部门就有同事笑话我了：”哟，现在上位了，当领导了，C哥就变成小C了“。&lt;br/&gt;然后这个笑话我的人，一直拿这话笑了我一两年。&lt;/p&gt;
</description>
<pubDate>Tue, 27 Oct 2020 14:45:00 +0000</pubDate>
<dc:creator>sfrost</dc:creator>
<og:description>这是一篇迟来的系列文章（下图是2018年在博客园写的草稿），原本已打算不写了，毕竟自己没读过什么书，怕大家笑话：） 从2017年开始，名义上我已经不是一个纯粹的技术工作者了（职位：信息部副经理），可整</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sfrost/p/13887630.html</dc:identifier>
</item>
<item>
<title>系统从初期到支撑亿级流量，都经历了哪些架构的变迁？ - 冰河团队</title>
<link>http://www.cnblogs.com/binghe001/p/13888022.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/binghe001/p/13888022.html</guid>
<description>&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;随着互联网的发展，互联网企业的业务也在不断的飞速发展，进而导致系统的架构也在不断的发生着变化。总体来说，系统的架构大致经历了：单体应用架构—&amp;gt;垂直应用架构—&amp;gt;分布式架构—&amp;gt;SOA架构—&amp;gt;微服务架构的演变。当然，很多互联网企业的系统架构已经向Service Mesh(服务化网格)演变。今天，我们就一起来聊聊关于系统架构的演变这个话题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;单体应用架构&quot;&gt;单体应用架构&lt;/h2&gt;
&lt;p&gt;在企业发展的初期，一般公司的网站流量都比较小，只需要一个应用，将所有的功能代码打包成一个服务，部署到服务器上就能支撑公司的业务。这样也能够减少开发、部署和维护的成本。&lt;/p&gt;
&lt;p&gt;比如，大家都很熟悉的电商系统，里面涉及的业务主要有：用户管理、商品管理、订单管理、支付管理、库存管理、物流管理等等模块，初期我们会将所有模块写到一个Web项目中，然后统一部署到一个Web服务器中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201027221043179.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这种架构特点有其优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;架构简单，项目开发和维护成本低。&lt;/li&gt;
&lt;li&gt;所有项目模块部署到一起，对于小型项目来说，维护方便。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;但是，其缺点也是比较明显的：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;所有模块耦合在一起，虽然对于小型项目来说，维护方便。但是，对于大型项目来说，却是不易开发和维护的。&lt;/li&gt;
&lt;li&gt;项目的各模块之前过于耦合，如果一旦有一个模块出现问题，则整个项目将不可用。&lt;/li&gt;
&lt;li&gt;无法针对某个具体模块来提升性能。&lt;/li&gt;
&lt;li&gt;无法对项目进行水平扩展。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;正是由于单体应用架构存在着诸多的缺点，才逐渐演变为垂直应用架构。接下来，我们就来看看垂直应用架构。&lt;/p&gt;
&lt;h2 id=&quot;垂直应用架构&quot;&gt;垂直应用架构&lt;/h2&gt;
&lt;p&gt;随着企业业务的不断发展，发现单节点的单体应用不足以支撑业务的发展，于是企业会将单体应用部署多份，分别放在不同的服务器上。但是，此时会发现不是所有的模块都会有比较大的访问量。如果想针对项目中的某些模块进行优化和性能提升，此时对于单体应用来说，是做不到的。于是乎，垂直应用架构诞生了。&lt;/p&gt;
&lt;p&gt;垂直应用架构，就是将原来一个项目应用进行拆分，将其拆分为互不想干的几个应用，以此来提升系统的整体性能。&lt;/p&gt;
&lt;p&gt;这里，我们同样以电商系统为例，在垂直应用架构下，我们可以将整个电商项目拆分为：电商交易系统、后台管理系统、CMS管理系统等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201027221103255.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们将单体应用架构拆分为垂直应用架构之后，一旦访问量变大，我们只需要针对访问量大的业务增加服务器节点即可，无需针对整个项目增加服务器节点了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这种架构的优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;系统进行了拆分，可根据不同系统的访问情况，有针对性的进行优化。&lt;/li&gt;
&lt;li&gt;能够实现应用的水平扩展。&lt;/li&gt;
&lt;li&gt;各系统能够分担整体访问的流量，解决了并发问题。&lt;/li&gt;
&lt;li&gt;一个系统发生了故障，不应用其他系统的运行情况，提高了整体的容错率。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;这种架构的缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;拆分后的各系统之间相对比较独立，无法进行互相调用。&lt;/li&gt;
&lt;li&gt;各系统难免存在重叠的业务，会存在重复开发的业务，后期维护比较困难。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;分布式架构&quot;&gt;分布式架构&lt;/h2&gt;
&lt;p&gt;我们将系统演变为垂直应用架构之后，当垂直应用越来越多，重复编写的业务代码就会越来越多。此时，我们需要将重复的代码抽象出来，形成统一的服务供其他系统或者业务模块来进行调用。此时，系统就会演变为分布式架构。&lt;/p&gt;
&lt;p&gt;在分布式架构中，我们会将系统整体拆分为服务层和表现层。服务层封装了具体的业务逻辑供表现层调用，表现层则负责处理与页面的交互操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201027221115421.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这种架构的优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;将重复的业务代码抽象出来，形成公共的访问服务，提高了代码的复用性。&lt;/li&gt;
&lt;li&gt;可以有针对性的对系统和服务进行性能优化，以提升整体的访问性能。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;这种架构的缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;系统之间的耦合度变高，调用关系变得复杂，难以维护。&lt;/p&gt;
&lt;h2 id=&quot;soa架构&quot;&gt;SOA架构&lt;/h2&gt;
&lt;p&gt;在分布式架构下，当部署的服务越来越多，重复的代码就会越来越多，对于容量的评估，小服务资源的浪费等问题比较严重。此时，我们就需要增加一个统一的调度中心来对集群进行实时管理。此时，系统就会演变为SOA（面向服务）的架构。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201027221127685.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这种架构的优点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用注册中心解决了各个服务之间的服务依赖和调用关系的自动注册与发现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这种架构的缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;微服务架构&quot;&gt;微服务架构&lt;/h2&gt;
&lt;p&gt;随着业务的发展，我们在SOA架构的基础上进一步扩展，将其彻底拆分为微服务架构。在微服务架构下，我们将一个大的项目拆分为一个个小的可以独立部署的微服务，每个微服务都有自己的数据库。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201027221140749.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这种架构的优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;服务彻底拆分，各服务独立打包、独立部署和独立升级。&lt;/li&gt;
&lt;li&gt;每个微服务负责的业务比较清晰，利于后期扩展和维护。&lt;/li&gt;
&lt;li&gt;微服务之间可以采用REST和RPC协议进行通信。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;这种架构的缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;开发的成本比较高。&lt;/li&gt;
&lt;li&gt;涉及到各服务的容错性问题。&lt;/li&gt;
&lt;li&gt;涉及到数据的一致性问题。&lt;/li&gt;
&lt;li&gt;涉及到分布式事务问题（小伙伴们可以参见我后续会持续更新的【&lt;a href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?action=getalbum&amp;amp;__biz=Mzg3MzE1NTIzNA==&amp;amp;scene=1&amp;amp;album_id=1393709600402374656&amp;amp;count=3#wechat_redirect&quot;&gt;分布式事务&lt;/a&gt;】专题）。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;好了，今天我们就到这儿吧，我是冰河，我们下期见！！&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;重磅福利&quot;&gt;重磅福利&lt;/h2&gt;
&lt;p&gt;微信搜一搜【冰河技术】微信公众号，关注这个有深度的程序员，每天阅读超硬核技术干货，公众号内回复【PDF】有我准备的一线大厂面试资料和我原创的超硬核PDF技术文档，以及我为大家精心准备的多套简历模板（不断更新中），希望大家都能找到心仪的工作，学习是一条时而郁郁寡欢，时而开怀大笑的路，加油。如果你通过努力成功进入到了心仪的公司，一定不要懈怠放松，职场成长和新技术学习一样，不进则退。如果有幸我们江湖再见！&lt;/p&gt;
&lt;p&gt;另外，我开源的各个PDF，后续我都会持续更新和维护，感谢大家长期以来对冰河的支持！！&lt;/p&gt;
</description>
<pubDate>Tue, 27 Oct 2020 14:19:00 +0000</pubDate>
<dc:creator>冰河团队</dc:creator>
<og:description>写在前面 随着互联网的发展，互联网企业的业务也在不断的飞速发展，进而导致系统的架构也在不断的发生着变化。总体来说，系统的架构大致经历了：单体应用架构—&amp;amp;gt;垂直应用架构—&amp;amp;gt;分布</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/binghe001/p/13888022.html</dc:identifier>
</item>
<item>
<title>【Flutter 混合开发】添加 Flutter 到 Android Activity - 老孟Flutter</title>
<link>http://www.cnblogs.com/mengqd/p/13887892.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mengqd/p/13887892.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202010/467322-20201027215713180-299329130.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;Flutter 混合开发系列 包含如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;嵌入原生View-Android&lt;/li&gt;
&lt;li&gt;嵌入原生View-iOS&lt;/li&gt;
&lt;li&gt;与原生通信-MethodChannel&lt;/li&gt;
&lt;li&gt;与原生通信-BasicMessageChannel&lt;/li&gt;
&lt;li&gt;与原生通信-EventChannel&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;添加 Flutter 到 Android Activity&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;添加 Flutter 到 Android Fragment&lt;/li&gt;
&lt;li&gt;添加 Flutter 到 iOS&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;每个工作日分享一篇，欢迎关注、点赞及转发。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;创建-flutter-module&quot;&gt;创建 Flutter Module&lt;/h3&gt;
&lt;p&gt;Flutter可以以源代码或AAR的方法嵌入到Android原生项目，集成流程可以使用 Android Studio 完成，也可以手动完成。强烈建议使用 Android Studio。&lt;/p&gt;
&lt;p&gt;首先创建一个 Android 项目，创建一个空的 Activity：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202010/467322-20201027215713769-3263478.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Android 项目创建成功后，使用Android Studio 添加Flutter模块，在Android原生项目中点击“File &amp;gt; New &amp;gt; New Module...”，创建 &lt;strong&gt;Flutter Module&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202010/467322-20201027215714591-2146123315.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：Android Studio 的版本3.5及以上，Flutter IntelliJ plugin版本42及以上。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在弹出的选择Module类型的对话框中选中Flutter Module,然后点击Next，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202010/467322-20201027215715130-1392609478.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;设置Flutter module的Project name、Flutter SDK等，点击Next：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202010/467322-20201027215715658-1536183139.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;设置Flutter module的包名，点击Finish：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202010/467322-20201027215715972-1572526729.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;编译完成后将在当前App目录下生成Flutter模块的代码，目录结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202010/467322-20201027215716267-489261289.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;启动页加载-flutter&quot;&gt;启动页加载 Flutter&lt;/h3&gt;
&lt;p&gt;将 Flutter 页面加载到 MainActivity（默认启动页） 中，修改 MainActivity ：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-kotlin&quot;&gt;package com.flutter.androidflutter

import io.flutter.embedding.android.FlutterActivity

class MainActivity : FlutterActivity()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你没有看错，只需让 MainActivity 继承 &lt;strong&gt;FlutterActivity&lt;/strong&gt; 即可。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：FlutterActivity的包名是io.flutter.embedding.android.FlutterActivity&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202010/467322-20201027215716856-1471829589.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;跳转到-flutter-页面&quot;&gt;跳转到 Flutter 页面&lt;/h3&gt;
&lt;p&gt;MainActivity（默认启动页）添加一个按钮，点击后跳转到新的页面，此页面加载 Flutter ，MainActivity代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-kotlin&quot;&gt;package com.flutter.androidflutter

import android.content.Intent
import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle
import io.flutter.embedding.android.FlutterActivity
import kotlinx.android.synthetic.main.activity_main.*

class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        button.setOnClickListener {
            startActivity(Intent(this,SecondFlutterActivity::class.java))
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;SecondFlutterActivity 代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-kotlin&quot;&gt;package com.flutter.androidflutter

import io.flutter.embedding.android.FlutterActivity

class SecondFlutterActivity:FlutterActivity() 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 &lt;strong&gt;AndroidManifest.xml&lt;/strong&gt; 中注册此 Activity：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    package=&quot;com.flutter.androidflutter&quot;&amp;gt;

    &amp;lt;application
        android:allowBackup=&quot;true&quot;
        android:icon=&quot;@mipmap/ic_launcher&quot;
        android:label=&quot;@string/app_name&quot;
        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;
        android:supportsRtl=&quot;true&quot;
        android:theme=&quot;@style/AppTheme&quot;&amp;gt;
        ...
        &amp;lt;activity android:name=&quot;.SecondFlutterActivity&quot;/&amp;gt;
    &amp;lt;/application&amp;gt;

&amp;lt;/manifest&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202010/467322-20201027215717156-1899099228.gif&quot; alt=&quot;flutter_android_1&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SecondFlutterActivity&lt;/strong&gt; 只是继承了 &lt;strong&gt;FlutterActivity&lt;/strong&gt;，这种情况下，也可以直接使用 &lt;strong&gt;FlutterActivity&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-kotlin&quot;&gt;startActivity(Intent(this, FlutterActivity::class.java))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-kotlin&quot;&gt;startActivity(FlutterActivity.createDefaultIntent(this))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 &lt;strong&gt;AndroidManifest.xml&lt;/strong&gt; 中注册 FlutterActivity：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;activity android:name=&quot;io.flutter.embedding.android.FlutterActivity&quot;/&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果与上面是一样的。&lt;/p&gt;
&lt;p&gt;FlutterActivity 会加载 Flutter Module 中 lib/main.dart 中 main 方法，如果有多个Flutter页面，如何指定跳转，比如现在有 OnePage Flutter 页面，OnePage 代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;class OnePage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(),
      body: Center(
        child: Text('这是 One 页面'),
      ),
    );
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;FlutterActivity 指定加载页面需要使用&lt;strong&gt;命名路由&lt;/strong&gt;，MyApp 修改如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Flutter Demo',
      theme: ThemeData(

        primarySwatch: Colors.blue,
      ),
      routes: {
        'one_page':(context){
          return OnePage();
        },
        'two_page':(context){
          return TwoPage();
        }
      },
      home: MyHomePage(title: 'Flutter Demo Home Page'),
    );
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;MainActivity 页面点击到 Flutter 页面，加载 OnePage 页面：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-kotlin&quot;&gt;class MainActivity : AppCompatActivity() {


    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        button.setOnClickListener {
            startActivity(
                FlutterActivity
                    .withNewEngine()
                    .initialRoute(&quot;one_page&quot;)
                    .build(this)
            )
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202010/467322-20201027215717680-371953703.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;引擎缓存&quot;&gt;引擎缓存&lt;/h3&gt;
&lt;p&gt;加载 FlutterActivity 页面时明显看到一段时间的黑屏，这段时间主要是启动 Flutter 引擎（FlutterEngine），Flutter 引擎启动的时间在不同手机上不同，性能越好的手机越短。同时每一个 FlutterActivity 页面都会启动一个引擎，所以强烈建议不要在一个项目中创建多个 FlutterActivity（或者启动多个 FlutterActivity 实例），否则内存会越来越大，下面是每隔3秒创建一个 FlutterActivity 实例内存变化图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202010/467322-20201027215719465-1146424109.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了减少 FlutterActivity 页面的延迟时间和多个 FlutterActivity 实例内存一直增长问题，我们可以使用 Flutter 引擎（FlutterEngine）缓存，在启动 FlutterActivity 前先启动 Flutter 引擎，然后使用缓存的引擎加载页面，通常将其放在 &lt;strong&gt;Application&lt;/strong&gt; 中：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-kotlin&quot;&gt;class MyApplication : Application() {
    lateinit var flutterEngine: FlutterEngine

    override fun onCreate() {
        super.onCreate()
        flutterEngine = FlutterEngine(this)
        flutterEngine.dartExecutor.executeDartEntrypoint(
            DartExecutor.DartEntrypoint.createDefault()
        )
        FlutterEngineCache
            .getInstance()
            .put(&quot;engine_id&quot;, flutterEngine)
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用缓存的引擎：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-kotlin&quot;&gt;startActivity(
    FlutterActivity
        .withCachedEngine(&quot;engine_id&quot;)
        .build(this)
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在同一台手机上效果非常明显，黑屏时间大大减少，不过还是有一个短暂的黑屏。&lt;/p&gt;
&lt;p&gt;这里要注意，使用缓存引擎时，其生命周期不在是 FlutterActivity（或者 FlutterFragment）的生命周期，而是整个 App 的生命周期（在Application 中的创建和销毁）。当然也可以提前销毁：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-kotlin&quot;&gt;flutterEngine.destroy()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另外项目的 debug 和 release 版本对性能的影响非常大，如果要&lt;strong&gt;测试其性能一定在要 release 下测试&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;上面使用新的引擎可以指定 FlutterActivity（或者 FlutterFragment）配置初始路由，但使用缓存引擎时无法在 FlutterActivity（或者 FlutterFragment）配置初始路由，因为缓存引擎已经启动并运行，不过可以在启动缓存引擎时指定其初始路由：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-kotlin&quot;&gt;flutterEngine = FlutterEngine(this)

flutterEngine.navigationChannel.setInitialRoute(&quot;one_page&quot;)

flutterEngine.dartExecutor.executeDartEntrypoint(
    DartExecutor.DartEntrypoint.createDefault()
)
FlutterEngineCache
    .getInstance()
    .put(&quot;engine_id&quot;, flutterEngine)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果使用缓存引擎在FlutterActivity（或 FlutterFragment）指定不同路由，如何处理？这时需要创建一个 &lt;strong&gt;method channel&lt;/strong&gt;，flutter 接收具体消息从而切换不同的路由。&lt;/p&gt;
&lt;h2 id=&quot;交流&quot;&gt;交流&lt;/h2&gt;
&lt;p&gt;老孟Flutter博客（330个控件用法+实战入门系列文章）：&lt;a href=&quot;http://laomengit.com&quot;&gt;http://laomengit.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎加入Flutter交流群（微信：laomengit）、关注公众号【老孟Flutter】：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th/&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202010/467322-20201027215721786-1174248521.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202010/467322-20201027215722286-1039051127.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</description>
<pubDate>Tue, 27 Oct 2020 13:57:00 +0000</pubDate>
<dc:creator>老孟Flutter</dc:creator>
<og:description>Flutter 混合开发系列 包含如下： 嵌入原生View-Android 嵌入原生View-iOS 与原生通信-MethodChannel 与原生通信-BasicMessageChannel 与原生</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mengqd/p/13887892.html</dc:identifier>
</item>
<item>
<title>痞子衡嵌入式：基于恩智浦i.MXRT1010的MP3音乐播放器(RT-Mp3Player)设计 - 痞子衡</title>
<link>http://www.cnblogs.com/henjay724/p/13887875.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/henjay724/p/13887875.html</guid>
<description>&lt;p&gt;为了让大家见识到i.MXRT1011的能量，特给大家分享一个基于i.MXRT1011-EVK开发板的MP3播放器设计，mp3源文件从U盘获取，使用Helix MP3库进行软解码，最后将解码出的pcm数据通过板载Codec（WM8960）连耳机进行播放。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;82.888535031847&quot;&gt;
&lt;hr/&gt;&lt;p&gt;　　大家好，我是痞子衡，是正经搞技术的痞子。今天痞子衡给大家介绍的是&lt;strong&gt;基于i.MXRT1011的MP3播放器参考设计&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　i.MXRT1011是恩智浦i.MXRT四位数系列的入门型号，虽然是入门级，可也是500MHz主频的大杀器。&lt;/p&gt;
&lt;p&gt;　　为了让大家见识到i.MXRT1011的能量，特给大家分享一个基于i.MXRT1011-EVK开发板的MP3播放器设计，mp3源文件从U盘获取，使用Helix MP3库进行软解码，最后将解码出的pcm数据通过板载Codec（WM8960）连耳机进行播放。&lt;/p&gt;
&lt;p&gt;　　功能模块简图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/github/RT-Mp3Player_BlockDiagram_v0.1.PNG&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这个设计目前还处于初级阶段，但已经实现了最核心的mp3文件解码与播放。设计主要参考了SDK包里的两个例程：通过USB读取U盘中的音频源文件（usb_host_msd_fatfs），使用I2C对Codec进行设置后使用SAI和DMA进行数据的传输（sai）.&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot;&gt;SDK\boards\evkmimxrt1010\usb_examples\usb_host_msd_fatfs\bm
SDK\boards\evkmimxrt1010\demo_apps\sai
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　此外，核心mp3解码功能是使用了正点原子移植好的Helix MP3解码库。因为一些历史原因，我们在Helix Community官网下载不到源码了，这里感谢原子哥的开源。&lt;/p&gt;
&lt;p&gt;　　全部硬件清单：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot;&gt;1. MIMXRT1010-EVK (Rev.C)
2. U盘 (Micro-USB接口)
3. 耳机（3.5mm接口），或音箱
4. USB线（连主机供电）
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　实物连接图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/github/RT-Mp3Player_View_v1.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　代码是开源的，会持续添加功能（考虑加入Arduino接口的触摸屏，实现GUI），欢迎感兴趣的小伙伴加入一起开发！&lt;/p&gt;
&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;/div&gt;</description>
<pubDate>Tue, 27 Oct 2020 13:55:00 +0000</pubDate>
<dc:creator>痞子衡</dc:creator>
<og:description>为了让大家见识到i.MXRT1011的能量，特给大家分享一个基于i.MXRT1011-EVK开发板的MP3播放器设计，mp3源文件从U盘获取，使用Helix MP3库进行软解码，最后将解码出的pcm数</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/henjay724/p/13887875.html</dc:identifier>
</item>
</channel>
</rss>