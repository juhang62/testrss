<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>PowerJob 在线日志饱受好评的秘诀：小但实用的分布式日志系统 - 削微寒</title>
<link>http://www.cnblogs.com/xueweihan/p/13561303.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xueweihan/p/13561303.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;本文适合有 Java 基础知识的人群&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202008/759200-20200825184459250-1419420948.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;作者：HelloGitHub-&lt;strong&gt;Salieri&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;HelloGitHub 推出的&lt;a href=&quot;https://github.com/HelloGitHub-Team/Article&quot;&gt;《讲解开源项目》&lt;/a&gt;系列。&lt;/p&gt;
&lt;blockquote readability=&quot;1.5686274509804&quot;&gt;
&lt;p&gt;项目地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/KFCFans/PowerJob&quot;&gt;https://github.com/KFCFans/PowerJob&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;PowerJob 的在线日志一直是饱受好评的一个功能，它能在前端界面实时展示开发者在任务处理过程中输出的日志，帮助开发者更好的监控任务的执行情况。其功能展示如下图所示（前端界面略丑，请自动忽略～）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202008/759200-20200825184514007-2041607318.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在线日志这个功能，乍一听很简单，无非 worker 向 server 发日志数据，server 接受后前端展示。但对于 PowerJob 这种任意节点都支持分布式部署且支持分布式计算的系统来说，还是存在着不少难点的，简单来说，有以下几点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;多对多问题：在 PowerJob 的理想部署模式中，会存在多个 server 和多个 worker，当某个任务开始分布式计算时，其日志散布于各台机器上，要想在前端统一展示，需要有收集器将分散的日志汇集到一起。&lt;/li&gt;
&lt;li&gt;并发问题：当 worker 集群规模较大时，一旦执行分布式计算任务，其产生的日志 QPS 也是一个不小的数目，要想轻松支持百万量级的分布式任务，需要解决并发情况下 QPS 过高的问题。&lt;/li&gt;
&lt;li&gt;排序问题：分布式计算时，日志散布在不同机器，即便收集汇总到同一台机器，由于网络延迟等原因，不能保证日志的有序性，而日志按时间排序是强需求（否则根本没法看啊...），因此，还需要解决大规模日志数据的排序问题。&lt;/li&gt;
&lt;li&gt;数据的存储问题：当日志数据量非常大时，如何高效的存储和读取这一批数据，也是需要解决的问题。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;因此，为了完美实现在线日志功能，PowerJob 在内部实现了一个麻雀虽小五脏俱全的&lt;strong&gt;分布式日志系统&lt;/strong&gt;。话不多说，下面正式开始逐一分析～&lt;/p&gt;
&lt;h2 id=&quot;一、多对多问题&quot;&gt;一、多对多问题&lt;/h2&gt;
&lt;p&gt;这个问题，其实在 PowerJob 解决多 worker 多 server 的选主问题时顺带着解决了。简单来说，PowerJob 系统中，某一个分组下的所有 worker，在运行时都只会连接到某一台 server。因此，日志数据上报时，选择当前 worker 进行上报即可。由于任务不可能跨分组执行，因此某个任务在运行过程中产生的所有日志数据都会上报给该分组当前连接的 server，这样就做到了日志的收集，即日志会汇总到负责当前分组调度的 powerjob-server，由该 server 统一处理。&lt;/p&gt;
&lt;h2 id=&quot;二、并发问题&quot;&gt;二、并发问题&lt;/h2&gt;
&lt;p&gt;并发问题的解决也不难。&lt;/p&gt;
&lt;p&gt;大家一定都听说过消息中间件，也知道消息中间件的一大功能为削峰。引入消息中间件后，把原来同步式的调用转化为异步的间接推送，中间通过一个队列在一端承接瞬时的流量洪峰，在另一端平滑地将消息推送出去。消息中间件就像水库一样，拦蓄上游的洪水，削减进入下游河道的洪峰流量，从而达到减免洪水灾害的目的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202008/759200-20200825184520621-1016599017.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;PowerJob 在处理日志的高并发问题时也采用了类似的方式，通过引入本地队列，对需要发送给 server 的消息进行缓存，再定时将消息批量发送给 server，化同步为异步，并引入批量发送的机制，充分利用每一次数据传输的机会发送尽可能多的数据，从而降低对 server 的冲击。&lt;/p&gt;
&lt;h2 id=&quot;三、排序问题&quot;&gt;三、排序问题&lt;/h2&gt;
&lt;h3 id=&quot;31-日志的存储&quot;&gt;3.1 日志的存储&lt;/h3&gt;
&lt;p&gt;将排序问题之前，先来聊一聊 server 怎么处理接收到的日志数据，也就是如何&lt;strong&gt;存储&lt;/strong&gt;日志。&lt;/p&gt;
&lt;p&gt;这个抉择其实并不难，用一下简单的排除法就能获取正确答案：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;存内部还是存外部？PowerJob 作为任务调度中间件，最小依赖一直是需要牢牢把控的指导思想。因此，在已知最小依赖仅为数据库的情况下，似乎不太可能使用外部的存储介质，至少不能把收到的日志直接发送到外部存储介质，否则又是一波庞大的 QPS，会对依赖的外部组件有非常高的性能要求，不符合框架设计原则。因此，在线日志的第一级存储介质应该由 server 本身来承担。&lt;/li&gt;
&lt;li&gt;存内存还是磁盘？既然确定了由 server 来存储原始数据，那么就面临内存和磁盘二选一的问题了。但，这还用选吗？成百上千万的文本数据存内存，这不妥妥的 OutOfMemory 吗？显然，存磁盘。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;经过一波简单的排除法，日志的一级存储方案确定了：server 的本机磁盘。那么，存磁盘会带来什么问题呢？&lt;/p&gt;
&lt;p&gt;且不说文件操作的复杂性和难度，一个最简单的需求就能让这个方案跌入万丈深渊，那就是：排序。&lt;/p&gt;
&lt;p&gt;众所周知，日志必须按时间排序，否则根本没法看。而 PowerJob 又是一个纯粹的分布式系统，显然不可能指望所有的日志数据按顺序发到 server，因此对日志的再排序是一件必须要做的事情。但让我们来考虑一下难度。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先，日志是纯文本数据，要想做排序，首先要将整个日志文件变为一堆日志记录，即分行。&lt;/li&gt;
&lt;li&gt;其次，分完行后，由于日志是给人看的，时间肯定已经被转化为 yyyy-MM-dd HH:mm:ss.SSS 这种方便人阅读的格式，那么将它反解析回可排序的时间戳又是一件麻烦事。&lt;/li&gt;
&lt;li&gt;最后，也是最终 BOSS，就是排序了。要知道，之所以会选择磁盘存储这个方案，是因为没有足够的内存。这也就意味着，这个排序没办法在内存完成。外部排序的难度和效率，想必不用我多说了吧。同时，我也相信，大部分程序员（包括我在内）应该从来没有接触过外部排序，这趟浑水，我又何必去趟呢？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202008/759200-20200825184527331-976216322.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;32-h2-数据库简介&quot;&gt;3.2 H2 数据库简介&lt;/h3&gt;
&lt;p&gt;那么，有没有什么既能使用磁盘做存储，又有排序能力的框架/软件呢？世上会有这等好事吗？你别说，还真有。而且是远在天边，近在眼前，可以说是和程序员形影不离的一样东西——数据库。&lt;/p&gt;
&lt;p&gt;“等等，你刚才不是说，不拿数据库作为一级存储介质吗？怎么滴，出尔反尔？”&lt;/p&gt;
&lt;p&gt;“哼，年轻人。此数据库非彼数据库，这个数据库啊，是 powerjob-server 内置的嵌入式数据库 H2”&lt;/p&gt;
&lt;p&gt;H2 是一个用 Java 开发的嵌入式数据库，它本身只是一个类库，即只有一个 jar 文件，可以直接嵌入到应用项目中。嵌入式模式下，应用在 JVM 中启动 H2 数据库并通过 JDBC 连接。该模式同时支持数据持久化和内存两种方式。&lt;/p&gt;
&lt;p&gt;H2 的使用很简单，在项目中引入依赖后，便会自动随 JVM 启动，应用可以通过 JDBC URL 进行连接，并在 JDBC URL 中指定所使用的模式，比如对于 powerjob-server 来说，需要使用嵌入式磁盘持久化模式，因此使用以下 JDBC URL 进行连接：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;jdbc:h2:file:~/powerjob-server/powerjob_server_db
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同时，H2 支持相当标准的 SQL 规范，也和 Spring Data Jpa、MyBatis 等 ORM 框架完美兼容，因此使用非常方便。在 powerjob-server 中，我便通过 Spring Data Jpa 来使用 H2，用户体验非常友好（当然，多数据源的配置很不友好！）。&lt;/p&gt;
&lt;p&gt;综上，有了内置的 H2 数据库，日志的存储和排序也就不再是难以解决的问题了～&lt;/p&gt;
&lt;h3 id=&quot;33-存储与排序&quot;&gt;3.3 存储与排序&lt;/h3&gt;
&lt;p&gt;引入 H2 之后，powerjob-server 处理在线日志的流程如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;接收来自 worker 的日志数据，直接写入内嵌数据库 H2 中&lt;/li&gt;
&lt;li&gt;在线调用时，通过 SQL 查询语句的 order by log_time 功能，完成日志的排序和输出&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;可见，合适的技术选型能让问题的解决简单很多～&lt;/p&gt;
&lt;h2 id=&quot;四、一些其他的优化&quot;&gt;四、一些其他的优化&lt;/h2&gt;
&lt;p&gt;以上介绍了 PowerJob 分布式日志组件的核心原理和实现，当然，在实际使用中，还引入了许多优化，限于篇幅，这里简单提一下，有兴趣的同学可以自己去看源码～&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;高频率在线访问降压：如果每次用户查看日志，都需要从数据库中查询并输出，这个效率和速度都会非常慢。毕竟当数据量达到一定程度时，光是磁盘 I/O 就得花去不少时间。因此，powerjob-server 会为每次查询生成缓存文件，一定时间范围内的日志查询，会通过文件缓存直接返回，而不是每次都走 DB 查询方案。&lt;/li&gt;
&lt;li&gt;日志分页：成百上千万条数据的背后，生成的文件大小也以及远远高于正常网络带宽所能轻松承载的范围了。因此，为了在前端控制台快速显示在线日志，需要引入分页功能，一次显示部分日志数据。这也是一项较为复杂的文件操作。&lt;/li&gt;
&lt;li&gt;远程存储：所有日志都存在 server 本地显然不符合高可用的设计目标，毕竟换一台 server 就意味着所有的日志数据都丢了，因此 PowerJob 引入了 mongoDB 作为日志的持久化存储介质。mongodb 支持用户直接使用其底层的分布式文件系统 GridFS，经过我仔细的考量，认为这是一个可接受且较为强大的扩展依赖，因此选择引入。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;五、最后&quot;&gt;五、最后&lt;/h2&gt;
&lt;p&gt;好了，本期的内容就到这里结束了，下一期，我将会大家讲述 PowerJob 作为一个各个节点时刻需要进行通讯的框架，底层序列化框架该如何选择，具体的序列化方案又该如何设计～&lt;/p&gt;
&lt;p&gt;那么我们下期再见喽～&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202008/759200-20200825184537931-2074943966.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关注 HelloGitHub 公众号&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 26 Aug 2020 00:55:00 +0000</pubDate>
<dc:creator>削微寒</dc:creator>
<og:description>本文适合有 Java 基础知识的人群 作者：HelloGitHub-Salieri HelloGitHub 推出的《讲解开源项目》系列。 项目地址： https://github.com/KFCFan</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xueweihan/p/13561303.html</dc:identifier>
</item>
<item>
<title>非功能性约束之性能（1）-性能银弹：缓存 - IvanEye</title>
<link>http://www.cnblogs.com/ivaneye/p/13563113.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ivaneye/p/13563113.html</guid>
<description>&lt;p&gt;在《&lt;a class=&quot;pgc-link&quot; href=&quot;https://www.toutiao.com/i6614960777184936456/?group_id=6614960777184936456&quot; target=&quot;_blank&quot;&gt;什么是架构属性&lt;/a&gt;》一文中提到提高「性能」的主要方式是优化，而优化的其中一个主要手段就是添加缓存！&lt;/p&gt;
&lt;p&gt;在软件工程里有这么一句话：「没有银弹」！就是说由于软件工程的复杂性，没有任何一种技术或方法能解决所有问题！软件工程是复杂的，没有银弹！但是，软件工程中的某一个问题，是有银弹的！&lt;/p&gt;
&lt;p&gt;在《&lt;a class=&quot;pgc-link&quot; href=&quot;https://www.toutiao.com/i6617556147081576967/?group_id=6617556147081576967&quot; target=&quot;_blank&quot;&gt;架构风格：万金油CS与分层&lt;/a&gt;》一文中提到过，「 计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决」！而「缓存层」可以说是添加得最多的层！主要目的就是为了提高性能！所以，缓存可以说是「性能银弹」！&lt;/p&gt;
&lt;p&gt;本文将探讨如下内容：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;缓存的作用&lt;/li&gt;
&lt;li&gt;缓存的种类&lt;/li&gt;
&lt;li&gt;缓存算法&lt;/li&gt;
&lt;li&gt;分布式缓存&lt;/li&gt;
&lt;li&gt;缓存的使用&lt;/li&gt;
&lt;li class=&quot;ql-indent-1&quot;&gt;网络中的缓存&lt;/li&gt;
&lt;li class=&quot;ql-indent-1&quot;&gt;应用缓存&lt;/li&gt;
&lt;li class=&quot;ql-indent-1&quot;&gt;数据库缓存&lt;/li&gt;
&lt;li class=&quot;ql-indent-1&quot;&gt;计算机中的缓存&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;
fn longRunningOperations(){&lt;br/&gt;... // 很耗时&lt;br/&gt;}&lt;br/&gt;let result = longRunningOperations();&lt;br/&gt;// do other thing
&lt;/pre&gt;
&lt;p&gt;我们来看上面这段伪代码，longRunningOperations是个很耗时的方法（调用一次要几十秒甚至几分钟），比如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;复杂的业务逻辑计算&lt;/li&gt;
&lt;li&gt;复杂的数据查询&lt;/li&gt;
&lt;li&gt;耗时的网络操作等&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于这个方法，如果每次都去调用一次的话，会非常的影响性能，用户体验也非常的不好。&lt;/p&gt;
&lt;p&gt;那我们该如何处理呢？&lt;/p&gt;
&lt;p&gt;一般有几种优化方案：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;优化业务代码，比如：更快的数据结构和算法，更快的IO模型，建立数据库索引等&lt;/li&gt;
&lt;li&gt;简化业务逻辑，导致耗时的原因可能是业务过于复杂，可以通过简化业务逻辑的方式来减少耗时&lt;/li&gt;
&lt;li&gt;将操作的结果存储起来。例如：对于某些统计类的结果，可以先用日终定时的去执行，将结果存储到统计结果表中，查找时，直接从结果中查询即可；对于某些临时操作，可以将结果存储在内存中，再次调用时，直接从内存中获取即可。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;本文主要聊聊第三种方案：使用「缓存」！&lt;/p&gt;

&lt;p&gt;一般我们使用缓存来存储一些内容，这些内容有如下一些特点（符合一条或多条）：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用较频繁&lt;/li&gt;
&lt;li&gt;变更不频繁&lt;/li&gt;
&lt;li&gt;获取较耗时&lt;/li&gt;
&lt;li&gt;多系统访问&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;比如，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;字典数据：系统很多地方都会使用字典数据，而字典数据配置完成后一般不会修改，虽然从数据库中直接获取字典数据不是很耗时，但是多了查询和网络传输，性能上还是不如直接从缓存里面取快速&lt;/li&gt;
&lt;li&gt;秒杀商品信息：在秒杀时访问量很大，从缓存（静态文件、CDN等）获取要比从数据库查询要快得多&lt;/li&gt;
&lt;li&gt;其它访问频次较多的信息：此处的其它信息是因为其缓存的处理方式与上面的字典处理有差异，下面详细说明。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于字典数据来说，一般我们的做法是在系统启动时，将字典数据直接加载到缓存中，此类缓存数据一般没有过期时间；当修改字典时，会同时更新缓存中的内容。此类缓存称为「主动缓存」，因为其缓存数据是由用户的主动修改来触发更新的。&lt;/p&gt;
&lt;p&gt;而对于某些信息来说，因为信息量太大，不能一次性全部加载到缓存中，且也不是太清楚哪些数据访问频次高、哪些数据访问频次低。对于这样的数据，一般的做法是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;先到缓存中查找是否有访问的数据，如果有则直接返回给用户&lt;/li&gt;
&lt;li&gt;如果没有，则去溯源查找&lt;/li&gt;
&lt;li&gt;找到后将其添加到缓存中&lt;/li&gt;
&lt;li&gt;最后返回给用户&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;此类缓存称为「被动缓存」！其缓存的数据的过期由系统来控制。那系统如何控制呢？这就涉及到缓存置换算法！&lt;/p&gt;

&lt;p&gt;上面说了，对于被动缓存来说，由于信息量太大，数据不能一次全部加载到缓存中，当缓存满了以后，需要新增数据时，就需要确定哪些数据要从缓存里清除，给新数据腾出空间。&lt;/p&gt;
&lt;p&gt;用于判断哪些数据优先从缓存中剔除的算法称为「缓存(页面)置换算法」！&lt;/p&gt;
&lt;p&gt;Wiki中列出了如下置换算法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;RR（Random replacement）&lt;/li&gt;
&lt;li&gt;FIFO（First in first out）&lt;/li&gt;
&lt;li&gt;LIFO（Last in first out）&lt;/li&gt;
&lt;li&gt;MRU（Most recently used）&lt;/li&gt;
&lt;li&gt;LFU（Least-frequently used）&lt;/li&gt;
&lt;li&gt;LRU（Least recently used）&lt;/li&gt;
&lt;li&gt;TLRU（Time aware least recently used）&lt;/li&gt;
&lt;li&gt;PLRU（Pseudo-LRU）&lt;/li&gt;
&lt;li&gt;LRU-K&lt;/li&gt;
&lt;li&gt;SLRU（Segmented LRU）&lt;/li&gt;
&lt;li&gt;MQ（Multi queue）&lt;/li&gt;
&lt;li&gt;LFRU（Least frequent recently used）&lt;/li&gt;
&lt;li&gt;LFUDA（LFU with dynamic aging）&lt;/li&gt;
&lt;li&gt;LIRS（Low inter-reference recency set）&lt;/li&gt;
&lt;li&gt;ARC（Adaptive replacement cache）&lt;/li&gt;
&lt;li&gt;CAR（Clock with adaptive replacement）&lt;/li&gt;
&lt;li&gt;Pannier（Container-based caching algorithm for compound objects）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;一般情况下我们不会自己去实现个缓存，市面上有不少开源的缓存中间件，比如：redis,memcached。这里只简单的梳理几个常用的置换算法。&lt;/p&gt;
&lt;p&gt;FIFO&lt;/p&gt;
&lt;p&gt;FIFO应该算是最简单的置换算法了：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;它使用一个队列来维护数据&lt;/li&gt;
&lt;li&gt;数据按照加载到缓存的顺序进行排列，先加载的数据在队列头部，后加载的数据在队列尾部&lt;/li&gt;
&lt;li&gt;当缓存满了以后，从队列头部清除数据，给需要加载的数据腾出空间&lt;/li&gt;
&lt;li&gt;新数据加到队列的尾部&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;FIFO的实现很简单，但是其性能并不总是很好。举个简单的例子，假设一个系统需要10个缓存数据，恰巧此时5个数据在队列头部，另外5个数据不在缓存中，又恰巧此时队列又满了。按照FIFO算法，5条不在内存中的数据被加载到了缓存中，而之前的5条数据被清除了。这就需要再次将被清除的5条数据加载到缓存中。这就影响了性能。&lt;/p&gt;
&lt;p&gt;这个问题可能会随着所分配的缓存大小的增加而增加，原本我们使用缓存是为了提高性能的，现在可能会影响性能，这种现象称为「Belady现象」！&lt;/p&gt;
&lt;p&gt;LIFO和FIFO很类似，这里就不赘述了。&lt;/p&gt;
&lt;p&gt;LRU&lt;/p&gt;
&lt;p&gt;目前比较常用的置换算法称为LRU置换算法：优先替换掉「最近最少使用」的数据&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;每个数据都被关联了该数据上次使用的时间&lt;/li&gt;
&lt;li&gt;当需要置换数据的时候，LRU选择最长时间没有使用的数据&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;LRU的变体有很多，例如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;TLRU（Time aware least recently used）：大部分缓存数据是有过期时间的。PLRU从最少使用和过期时间两个维度来置换数据&lt;/li&gt;
&lt;li&gt;LRU-K：多维护一个队列，用于记录所有缓存数据被访问的次数。当数据的访问次数达到K次的时候，才将数据放入缓存。当需要淘汰数据时，LRU-K会淘汰第K次访问时间距当前时间最大的数据。&lt;/li&gt;
&lt;li&gt;SLRU（Segmented LRU）2Queue？：一个FIFO队列，一个LRU队列。当数据第一次访问时，将数据缓存在FIFO队列里面，当数据第二次被访问时，则将数据从FIFO队列移到LRU队列里面，两个队列各自按照自己的方法淘汰数据。&lt;/li&gt;
&lt;li&gt;PLRU（Pseudo-LRU）：LRU需要维护数据访问时间，占用了额外的空间，对于空间很小的设备来说，此算法太过浪费空间了。PLRU每个缓存数据只需要1bit来存储数据信息，可以达到LRU的效果。具体流程见下图：&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;https://p1-tt.byteimg.com/origin/pgc-image/27411dbc9fd14e79ad3040f68bd21139?from=pc&quot; alt=&quot;非功能性约束之性能（1）-性能银弹：缓存&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;还有和LRU类似的MRU,LFU这里不在赘述！&lt;/p&gt;

&lt;p&gt;为了提高缓存的可用性，一般我们至少会对缓存做个主备，即一个主缓存，一个从缓存。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;缓存的写入只可以写到主缓存&lt;/li&gt;
&lt;li&gt;主缓存同步数据到从缓存中&lt;/li&gt;
&lt;li&gt;可以从主缓存读取数据。也可以从从缓存读取数据（不必须）&lt;/li&gt;
&lt;li&gt;当主缓存挂掉了，从缓存升级为主缓存&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;再安全一点的做法就是做缓存集群：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;多台机器缓存了相同的数据，其中一台为主缓存&lt;/li&gt;
&lt;li&gt;缓存的写入只可以写到主缓存&lt;/li&gt;
&lt;li&gt;主缓存同步数据到其它缓存&lt;/li&gt;
&lt;li&gt;可以从主缓存读取数据。也可以从其它缓存中读取数据（不必须）&lt;/li&gt;
&lt;li&gt;当主缓存挂掉了，会从其它缓存服务中选择一个作为新的主缓存&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;无论是单机缓存，主从备份还是缓存集群，都没法解决缓存大小限制的问题。因为一般缓存会使用内存，而一台机器的内存大小是有限的。当需要缓存的数据远远超过一台机器的内存大小的时候，就需要将缓存的数据分布到多台机器上。每台机器只缓存一部分数据，这就是分布式缓存。&lt;/p&gt;
&lt;p&gt;分布式缓存可以解决一台机器缓存数据有限的问题，但是也引入了新的问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;哪些数据该缓存在哪台服务器上&lt;/li&gt;
&lt;li&gt;如何保证每台服务器缓存的数据量基本相同&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;一般做法是对key进行hash，然后对服务器数量进行取余，来确定数据在哪台服务器上。这解决了「哪些数据该缓存在哪台服务器上」的问题，但是却无法保证「每台服务器缓存的数据量基本相同」，因为可能多个key的hash取余后都落到了同一个服务器上，这就可能导致其中一台服务器缓存的数量很多，其它服务器缓存的数据量很少。缓存数据量多的服务器可能会内存不够用，触发数据置换，进而导致性能下降。&lt;/p&gt;
&lt;p&gt;可以使用一致性hash环来保证服务器缓存的数据量基本相同，大致逻辑如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;将0~2^32个点均匀分配到一个圆上&lt;/li&gt;
&lt;li&gt;每个点对应一台缓存服务器&lt;/li&gt;
&lt;li&gt;缓存服务器数量是远小于2^32个的，所以多个节点对应一台缓存服务器，多出来的节点称为虚拟节点&lt;/li&gt;
&lt;li&gt;确保缓存服务器的分布均匀&lt;/li&gt;
&lt;li&gt;同样是对key进行hash&lt;/li&gt;
&lt;li&gt;对2^32进行求余&lt;/li&gt;
&lt;li&gt;结果对应到hash环上&lt;/li&gt;
&lt;li&gt;如果正好落到节点上，则数据就缓存到对应的缓存服务器上&lt;/li&gt;
&lt;li&gt;否则就存到落点前面的那个节点所对应的缓存服务器上&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面聊的主要是应用缓存，实际上，缓存无处不在。&lt;/p&gt;
&lt;p&gt;下面通过我们访问网站的流程，来简单梳理一下，整个过程中，哪些地方可能会用到缓存。&lt;/p&gt;
&lt;p&gt;网络缓存&lt;/p&gt;
&lt;p&gt;当我们在浏览器中输入URL，按下回车后。&lt;/p&gt;
&lt;p&gt;首先，需要查找域名所对应的IP！这里就有各种缓存！&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;浏览器缓存：浏览器会缓存DNS记录一段时间，首先会从浏览器缓存里去找对应的IP。&lt;/li&gt;
&lt;li&gt;系统缓存：如果在浏览器缓存里没有找到需要的记录，就会到系统缓存中查找记录&lt;/li&gt;
&lt;li&gt;路由器缓存：如果系统缓存中也没找到，就会到路由器缓存中查找记录&lt;/li&gt;
&lt;li&gt;ISP DNS 缓存：如果还是找不到，就到ISP缓存DNS的服务器里查找。在这一般都能找到相应的缓存记录。&lt;/li&gt;
&lt;li&gt;递归搜索：如果上面的缓存都找不到，就需要从根域名服务器开始递归查找了&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;找到IP后，还不一定要发请求，因为你访问的资源可能之前已经访问过，已经被缓存到了浏览器缓存中。此时，浏览器直接返回缓存，而不会发送请求。&lt;/p&gt;
&lt;p&gt;如果没有缓存，则发送请求获取资源。&lt;/p&gt;
&lt;p&gt;后面可能会达到CDN。CDN是一种边缘缓存。在用户访问网站时，利用GSLB（Global Server Load Balance，全局负载均衡）技术将用户的访问指向距离最近的工作正常的缓存服务器上，由缓存服务器直接响应用户请求。如果CDN中找不到需要的资源，则请求可能就到了反向代理。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;某些反向代理能够做到和用户来自同一个网络，那么用户访问反向代理服务器的时候，就会得到很高质量的响应速度，这样的反向代理缓存一般称为边缘缓存，而CDN在边缘缓存的基础上，使用了GSLB&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一般反向代理有两个功能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;隐藏源服务器，防止服务器恶意攻击。客户端感知不到代理服务器和源服务器的区别&lt;/li&gt;
&lt;li&gt;缓存，将原始服务器数据进行缓存，减少源服务器的访问压力&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果反向代理中也找不到需要的资源，请求才到达源服务器来获取资源。&lt;/p&gt;
&lt;p&gt;服务端与数据库缓存&lt;/p&gt;
&lt;p&gt;一般情况下，Server接收到请求后，会根据请求，组装出响应，进行返回。这个过程可能需要查询数据库、进行业务逻辑计算、页面渲染等操作。这里的每一步都可以引入缓存。&lt;/p&gt;
&lt;p&gt;对于数据库查询来说，目前一般的持久化框架都会提供查询缓存。即对于相同的sql，第二次查询开始，可以不用再查询数据库，直接从缓存中获取第一次查询所返回的数据。节省了调用数据库查询的时间消耗。对于某些访问量很大的数据，也可以将其缓存到缓存中间件中。后续直接从缓存中间件中获取。&lt;/p&gt;
&lt;p&gt;而数据库本身也有缓存！&lt;/p&gt;
&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;https://p1-tt.byteimg.com/origin/pgc-image/14ea23a939de43d3b7d0c161c9de4f1b?from=pc&quot; alt=&quot;非功能性约束之性能（1）-性能银弹：缓存&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;客户端发送一条查询给服务端&lt;/li&gt;
&lt;li&gt;服务端检查查询缓存，如果命中缓存，则立刻返回缓存中的结果。如果没找到，则&lt;/li&gt;
&lt;li&gt;进行sql解析、预处理、再由优化器生成对应的执行计划&lt;/li&gt;
&lt;li&gt;根据执行计划，调用存储引擎的API执行查询&lt;/li&gt;
&lt;li&gt;将结果返回给客户端&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;mysql的查询缓存可能会降低效率。首先，写缓存是独占模式写入。其次，假设一个查询结果被缓存了，当涉及到的其中一张表数据更新，该缓存都会被置为无效。对于频繁修改的数据，使用缓存就会降低效率。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于业务逻辑计算来说，如果某些业务逻辑很复杂，那么可以针对结果进行缓存。可以将结果缓存到数据库或缓存中间件中。对于相同的参数的请求，第二次请求时，就不必进行计算，直接从缓存中返回结果即可。&lt;/p&gt;
&lt;p&gt;对于页面渲染来说，某些访问量很大的页面，且数据基本不变的情况下，可以对页面进行静态化。即生成静态的页面，不必每次访问的时候都动态生成页面进行返回，而是预先生成好页面，将其存到磁盘上，当访问该页面的时候，直接从磁盘获取页面进行返回即可。或者直接将页面内容缓存到缓存中间件中，进一步提高性能。&lt;/p&gt;
&lt;p&gt;另外，对于需要登录的Server来说，用户信息其实也是缓存下来的。不论是存到服务器Session中，还是存到了缓存中间件中。否则，每次用户访问Server都需要到数据库获取用户信息，会影响Server端性能！&lt;/p&gt;
&lt;p&gt;计算机缓存&lt;/p&gt;
&lt;p&gt;最后，运行系统的计算机本身也有很多的缓存！&lt;/p&gt;
&lt;p&gt;我们都知道，一般计算机由CPU、内存、主板、硬盘、显卡、显示器、鼠标、键盘、网卡等组成！其中存储类设备包括了：云存储（例如：百度云盘，NAS等）、本地硬盘、内存、CPU中的高速缓存（我们常说的一级缓存、二级缓存和三级缓存）以及CPU寄存器。它们的速度各异，差异达数个量级。下图显示了各个设备的访问速率。&lt;/p&gt;
&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;https://p3-tt.byteimg.com/origin/pgc-image/d6c8ccf82f6f49fd9fb04ae7750c181c?from=pc&quot; alt=&quot;非功能性约束之性能（1）-性能银弹：缓存&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;CPU寄存器最快，达到1ns，但只能存储几百个字节，造价也最贵&lt;/li&gt;
&lt;li&gt;高速缓存次之，也达到了10ns，可存储几十兆，造价次之。其中L1，L2，L3速度越来越慢。&lt;/li&gt;
&lt;li&gt;然后是内存，为100ns，可达GB级别，造价比缓存便宜（不过这两年的内存价格贵得离谱）&lt;/li&gt;
&lt;li&gt;硬盘访问速率为10ms级别，可达TB级别，造价可以说是白菜价了&lt;/li&gt;
&lt;li&gt;而云存储则达到了秒级，基本可以无限扩展，只要钱够&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们都知道CPU的高速缓存是「缓存」，实际上上面的设备，上层设备都可以说是下层设备的「缓存」！&lt;/p&gt;
&lt;p&gt;在《深入理解计算机》一书中，简单的介绍了计算机执行C语言的hello world程序时的计算机流程。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通过鼠标、键盘输入执行命令'./hello'&lt;/li&gt;
&lt;li&gt;输入的内容从键盘通过总线，进入寄存器，在进入内存&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;https://p6-tt.byteimg.com/origin/pgc-image/665f9e5f109041888dd09cccd9fafd5e?from=pc&quot; alt=&quot;非功能性约束之性能（1）-性能银弹：缓存&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;当按下回车后&lt;/li&gt;
&lt;li&gt;通过DMA技术，将目标文件，从硬盘中直接读取到内存中&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;https://p3-tt.byteimg.com/origin/pgc-image/40991d8f6a8e4ae2b620e315970a7cb5?from=pc&quot; alt=&quot;非功能性约束之性能（1）-性能银弹：缓存&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;最后执行程序&lt;/li&gt;
&lt;li&gt;将hello world拷贝到寄存器&lt;/li&gt;
&lt;li&gt;再从寄存器拷贝到显示器显示&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;https://p3-tt.byteimg.com/origin/pgc-image/f7792c8968bc4cb389b11a77a6500aa2?from=pc&quot; alt=&quot;非功能性约束之性能（1）-性能银弹：缓存&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;可以看到，绝大部分的操作，都是数据的拷贝！最终被CPU执行，为了数据能更快的到达CPU，就有了一层一层的「缓存」！&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;CPU寄存器里的数据是直接给CPU使用的，相当于是L1的缓存&lt;/li&gt;
&lt;li&gt;L1又是L2的缓存，L2又是L3的缓存&lt;/li&gt;
&lt;li&gt;L3是内存的缓存&lt;/li&gt;
&lt;li&gt;内存又是硬盘的缓存。例如：一般硬盘中的数据，都需要先加载到内存中才能被CPU使用。另外硬盘的“HMB内存缓冲技术”，可以借用内存作为硬盘的缓存。&lt;/li&gt;
&lt;li&gt;硬盘本身也是有缓存的，这是为了减少IO操作，批量的进行读写。&lt;/li&gt;
&lt;li&gt;硬盘也可以是云存储的缓存。例如在网络不太好的情况下，我们可以把电影先下载下来再看，这样就不会有卡顿的情况&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;性能是架构设计时需要着重考虑的一个非功能性约束，而引入缓存是提高系统性能的一个简单且直接的方法。&lt;/p&gt;
&lt;p&gt;本文从一个简单的伪代码开始，简单阐述了，缓存的作用，涉及的技术以及目前缓存的使用场景，以期能对架构设计提供一些参考。&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;《深入理解计算机系统》&lt;/li&gt;
&lt;li&gt;《图解TCP/IP》&lt;/li&gt;
&lt;li&gt;《高性能MySQL》&lt;/li&gt;
&lt;li&gt;《操作系统概念》&lt;/li&gt;
&lt;li&gt;What really happens when you navigate to a URLCache replacement policies&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Wed, 26 Aug 2020 00:55:00 +0000</pubDate>
<dc:creator>IvanEye</dc:creator>
<og:description>在《什么是架构属性》一文中提到提高「性能」的主要方式是优化，而优化的其中一个主要手段就是添加缓存！ 在软件工程里有这么一句话：「没有银弹」！就是说由于软件工程的复杂性，没有任何一种技术或方法能解决所有</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ivaneye/p/13563113.html</dc:identifier>
</item>
<item>
<title>Docker 之常见应用部署 - 哈喽沃德先生</title>
<link>http://www.cnblogs.com/mrhelloworld/p/docker5.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mrhelloworld/p/docker5.html</guid>
<description>&lt;p&gt;本文教大家如何将常见的应用使用 Docker 进行部署，巩固大家 Docker 命令的学习，下文教大家如何构建属于我们自己的 Docker 镜像。&lt;/p&gt;

&lt;h2 id=&quot;tomcat&quot;&gt;Tomcat&lt;/h2&gt;

&lt;p&gt;　　拉取镜像。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;docker pull tomcat
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　创建容器。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;docker run -di --name tomcat -p 8080:8080 tomcat
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　进入容器。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;docker exec -it tomcat /bin/bash
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　查看 &lt;code&gt;webapps&lt;/code&gt; 目录下是否有 &lt;code&gt;ROOT&lt;/code&gt; 项目，我们熟悉的 Tomcat 猫页面一般就在这个项目中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mrhelloworld.com/resources/articles/docker/image-20200812190025868.png&quot; alt=&quot;&quot; title=&quot; &quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　如上图所示，该目录下空空如也，其实 Tomcat 在比较新的版本中将默认的 &lt;code&gt;ROOT&lt;/code&gt; 项目放在了 &lt;code&gt;webapps.dist&lt;/code&gt; 中，如果你真想访问 &lt;a href=&quot;http://192.168.10.10:8080/&quot;&gt;http://192.168.10.10:8080/&lt;/a&gt; 看到 Tomcat 猫，将其复制至 &lt;code&gt;webapps&lt;/code&gt; 即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mrhelloworld.com/resources/articles/docker/image-20200812190507577.png&quot; alt=&quot;&quot; title=&quot; &quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　访问：&lt;a href=&quot;http://192.168.10.10:8080/&quot;&gt;http://192.168.10.10:8080/&lt;/a&gt; 即可看到熟悉的面孔。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mrhelloworld.com/resources/articles/docker/image-20200812190553942.png&quot; alt=&quot;&quot; title=&quot; &quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;nginx&quot;&gt;Nginx&lt;/h2&gt;

&lt;p&gt;　　拉取镜像。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;docker pull nginx
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　创建 Nginx 容器。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;docker run -di --name nginx -p 80:80 nginx
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　将容器内的配置文件拷贝到指定目录（请先提前创建好目录）。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;docker cp nginx:/etc/nginx /mydata/docker_nginx
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　重命名宿主机 &lt;code&gt;/mydata/docker_nginx/nginx&lt;/code&gt; 为 &lt;code&gt;/mydata/docker_nginx/conf&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;mv /mydata/docker_nginx/nginx/ /mydata/docker_nginx/conf
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　终止并删除容器（目录挂载操作只能在创建容器时设置）。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;docker stop nginx
docker rm nginx
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　创建 Nginx 容器，并将容器中的 &lt;code&gt;/etc/nginx&lt;/code&gt; 目录和宿主机的 &lt;code&gt;/mydata/nginx/conf&lt;/code&gt; 目录进行挂载。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;docker run -di --name nginx -p 80:80 -v /mydata/docker_nginx/conf:/etc/nginx nginx
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　访问宿主机：&lt;a href=&quot;http://192.168.10.10:80/&quot;&gt;http://192.168.10.10:80/&lt;/a&gt; 结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mrhelloworld.com/resources/articles/docker/image-20200812183235528.png&quot; alt=&quot;&quot; title=&quot; &quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;mysql&quot;&gt;MySQL&lt;/h2&gt;

&lt;p&gt;　　拉取镜像。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;docker pull mysql:8.0.21
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　创建容器。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;docker run -di --name mysql8 -p 3306:3306 -v /mydata/docker_mysql/conf:/etc/mysql/conf.d -v /mydata/docker_mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=1234 mysql:8.0.21
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;-p&lt;/code&gt;：代表端口映射，格式为 宿主机映射端口:容器运行端口。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-e&lt;/code&gt;：代表添加环境变量 &lt;code&gt;MYSQL_ROOT_PASSWORD&lt;/code&gt; 是 root 用户的登陆密码。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　连接容器中的 MySQL 时，只需要连接宿主机的 IP + 指定的映射端口即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mrhelloworld.com/resources/articles/docker/image-20200812183927191.png&quot; alt=&quot;&quot; title=&quot; &quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　也可以进入容器并使用 MySQL 命令打开客户端。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# 进入容器
docker exec -it mysql8 /bin/bash
# 使用 MySQL 命令打开客户端
mysql -uroot -p1234 --default-character-set=utf8
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;redis&quot;&gt;Redis&lt;/h2&gt;

&lt;p&gt;　　拉取镜像。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;docker pull redis
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　创建容器。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;docker run -di --name redis -p 6379:6379 redis
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　连接容器中的 Redis 时，只需要连接宿主机的 IP + 指定的映射端口即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mrhelloworld.com/resources/articles/docker/image-20200812191215218.png&quot; alt=&quot;&quot; title=&quot; &quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;mongodb&quot;&gt;MongoDB&lt;/h2&gt;

&lt;p&gt;　　拉取镜像。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;docker pull mongo
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　创建容器。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;docker run -di --name mongo -p 27017:27017 mongo
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　连接容器中的 MongoDB 时，只需要连接宿主机的 IP + 指定的映射端口即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mrhelloworld.com/resources/articles/docker/image-20200812205454858.png&quot; alt=&quot;&quot; title=&quot; &quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;elasticsearch&quot;&gt;Elasticsearch&lt;/h2&gt;

&lt;p&gt;　　拉取镜像。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;docker pull elasticsearch:7.8.1
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　创建容器，为了方便演示，修改 ES 启动占用内存大小。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;docker run -e ES_JAVA_OPTS=&quot;-Xms256m -Xmx512m&quot; -e &quot;discovery.type=single-node&quot; -di --name es -p 9200:9200 -p 9300:9300 -p 5601:5601 -v /mydata/docker_es/plugins:/usr/share/elasticsearch/plugins elasticsearch:7.8.1
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　安装中文分词器。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# 进入容器
docker exec -it es /bin/bash
# 安装中文分词器
elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.8.1/elasticsearch-analysis-ik-7.8.1.zip
# 重启 es
docker restart es
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　访问：&lt;a href=&quot;http://192.168.10.10:9200/&quot;&gt;http://192.168.10.10:9200/&lt;/a&gt; 结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mrhelloworld.com/resources/articles/docker/image-20200812221830337.png&quot; alt=&quot;&quot; title=&quot; &quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h3 id=&quot;安装-head-插件&quot;&gt;安装 head 插件&lt;/h3&gt;

&lt;p&gt;　　拉取镜像。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;docker pull mobz/elasticsearch-head:5
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　创建容器。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;docker run -di --name es-head -p 9100:9100 mobz/elasticsearch-head:5
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　在浏览器中打开 elasticsearch-head 页面，填入 Elasticsearch 地址。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mrhelloworld.com/resources/articles/docker/image-20200814201247072.png&quot; alt=&quot;&quot; title=&quot; &quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这里会出现跨域拒绝访问的问题，进入 elasticsearch 容器内部，修改配置文件 &lt;code&gt;elasticsearch.yml&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# 进入容器
docker exec -it 容器ID或名称 /bin/bash
# 修改配置文件
vi config/elasticsearch.yml
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　在 &lt;code&gt;elasticsearch.yml&lt;/code&gt; 中添加如下内容。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# 跨域请求配置（为了让类似 head 的第三方插件可以请求 es）
http.cors.enabled: true
http.cors.allow-origin: &quot;*&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　重启容器。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;docker restart es
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://mrhelloworld.com/resources/articles/docker/image-20200814201950953.png&quot; alt=&quot;&quot; title=&quot; &quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;solr&quot;&gt;Solr&lt;/h2&gt;

&lt;p&gt;　　拉取镜像。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;docker pull solr
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　创建容器。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;docker run -di --name=solr -p 8983:8983 solr
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　访问：&lt;a href=&quot;http://192.168.10.10:8983/solr/#/&quot;&gt;http://192.168.10.10:8983/solr/#/&lt;/a&gt; 结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mrhelloworld.com/resources/articles/docker/image-20200812222857902.png&quot; alt=&quot;&quot; title=&quot; &quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;rabbitmq&quot;&gt;RabbitMQ&lt;/h2&gt;

&lt;p&gt;　　拉取镜像。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;docker pull rabbitmq
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　创建容器。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;docker run -di --name rabbitmq -p 4369:4369 -p 5671:5671 -p 5672:5672 -p 15671:15671 -p 15672:15672 -p 25672:25672 rabbitmq
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　进入容器并开启管理功能。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# 进入容器
docker exec -it rabbitmq /bin/bash
# 开启 RabbitMQ 管理功能
rabbitmq-plugins enable rabbitmq_management
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　访问：&lt;a href=&quot;http://192.168.10.10:15672/&quot;&gt;http://192.168.10.10:15672/&lt;/a&gt; 使用 &lt;code&gt;guest&lt;/code&gt; 登录账号密码，结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mrhelloworld.com/resources/articles/docker/image-20200812200109882.png&quot; alt=&quot;&quot; title=&quot; &quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;应用部署的练习就到这里，接下来该学习学习如何构建属于我们自己的 Docker 镜像啦。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/5/1/171cf87f564bc82e?w=433&amp;amp;h=133&amp;amp;f=gif&amp;amp;s=333013&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本文采用 &lt;a href=&quot;http://creativecommons.org/licenses/by-nc-nd/4.0/&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;知识共享「署名-非商业性使用-禁止演绎 4.0 国际」许可协议&lt;/code&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;大家可以通过 &lt;a href=&quot;https://mrhelloworld.com/categories&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;分类&lt;/code&gt;&lt;/a&gt; 查看更多关于 &lt;a href=&quot;https://mrhelloworld.com/categories/docker&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;Docker&lt;/code&gt;&lt;/a&gt; 的文章。&lt;/p&gt;

&lt;p&gt;🤗 您的&lt;code&gt;点赞&lt;/code&gt;和&lt;code&gt;转发&lt;/code&gt;是对我最大的支持。&lt;/p&gt;
&lt;p&gt;📢 扫码关注 &lt;code&gt;哈喽沃德先生&lt;/code&gt;「文档 + 视频」每篇文章都配有专门视频讲解，学习更轻松噢 ~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/4/27/171b91f4ae03d737?w=500&amp;amp;h=500&amp;amp;f=gif&amp;amp;s=126591&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 26 Aug 2020 00:32:00 +0000</pubDate>
<dc:creator>哈喽沃德先生</dc:creator>
<og:description>本文教大家如何将常见的应用使用 Docker 进行部署，巩固大家 Docker 命令的学习，下文教大家如何构建属于我们自己的 Docker 镜像。 Tomcat 拉取镜像。 docker pull t</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mrhelloworld/p/docker5.html</dc:identifier>
</item>
<item>
<title>代理？哦，就是那个赚差价中间商啊！ - 程序员cxuan</title>
<link>http://www.cnblogs.com/cxuanBlog/p/13563059.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cxuanBlog/p/13563059.html</guid>
<description>&lt;p&gt;说在前面：今天我们来聊一聊 Java 中的代理，先来聊聊故事背景：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;小明想购买法国某个牌子的香水送给女朋友，但是在国内没有货源售卖，亲自去法国又大费周章了，而小红现在正在法国玩耍，她和小明是好朋友，可以帮小明买到这个牌子的香水，于是小明就找到小红，答应给她多加 5% 的辛苦费，小红答应了，小明成功在中国买到了法国的香水。之后小红开启了疯狂的代购模式，赚到了很多手续费。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在故事中，&lt;strong&gt;小明是一个客户&lt;/strong&gt;，它让小红帮忙购买香水，&lt;strong&gt;小红就成了一个代理对象&lt;/strong&gt;，而&lt;strong&gt;香水提供商是一个真实的对象&lt;/strong&gt;，可以售卖香水，小明通过代理商小红，购买到法国的香水，这就是一个代购的例子。我画了一幅图帮助理解这个故事的整个结构。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.smallpineapple.top/image-20200819211449689.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个故事是最典型的代理模式，代购从供应商购买货物后返回给调用者，也就是需要代理的小明。&lt;/p&gt;
&lt;p&gt;代理可以分为&lt;code&gt;静态代理&lt;/code&gt;和&lt;code&gt;动态代理&lt;/code&gt;两大类：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;静态代理&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;优点：代码结构简单，较容易实现&lt;/li&gt;
&lt;li&gt;缺点：无法适配所有代理场景，如果有新的需求，需要修改代理类，&lt;strong&gt;不符合软件工程的开闭原则&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;小红现在只是代理香水，如果小明需要找小红买法国红酒，那小红就需要代理法国红酒了，但是静态代理去扩展代理功能&lt;strong&gt;必须修改小红内部的逻辑，这会让小红内部代码越来越臃肿&lt;/strong&gt;，后面会详细分析。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;动态代理&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;优点：能够动态适配特定的代理场景，扩展性较好，&lt;strong&gt;符合软件工程的开闭原则&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;缺点：动态代理需要利用到反射机制和动态生成字节码，导致其性能会比静态代理稍差一些，&lt;strong&gt;但是相比于优点，这些劣势几乎可以忽略不计&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果小明需要找小红代理红酒，我们&lt;strong&gt;无需修改代理类小红的内部逻辑&lt;/strong&gt;，只需要关注扩展的功能点：&lt;strong&gt;代理红酒&lt;/strong&gt;，实例化新的类，通过一些转换即可让小红&lt;strong&gt;既能够代理香水也能够代理红酒&lt;/strong&gt;了。&lt;/p&gt;
&lt;p&gt;本文将会通过以下几点，尽可能让你理解 Java 代理中所有重要的知识点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;学习代理模式（实现故事的代码，解释代理模式的类结构特点）&lt;/li&gt;
&lt;li&gt;比较静态代理与动态代理二者的异同&lt;/li&gt;
&lt;li&gt;Java 中常见的两种动态代理实现（JDK Proxy 和 Cglib）&lt;/li&gt;
&lt;li&gt;动态代理的应用（Spring AOP）&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;代理模式&quot;&gt;代理模式&lt;/h2&gt;
&lt;p&gt;（1）我们定义好一个&lt;strong&gt;售卖香水&lt;/strong&gt;的接口，定义好售卖香水的方法并传入该香水的价格。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface SellPerfume {
    void sellPerfume(double price);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（2）定义香奈儿（Chanel）香水提供商，实现接口。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class ChanelFactory implements SellPerfume {
    @Override
    public void sellPerfume(double price) {
        System.out.println(&quot;成功购买香奈儿品牌的香水，价格是：&quot; + price + &quot;元&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（3）定义&lt;strong&gt;小红&lt;/strong&gt;代理类，她需要代购去售卖香奈儿香水，所以她是香奈儿香水提供商的代理对象，同样实现接口，并在内部保存对目标对象（香奈儿提供商）的引用，控制其它对象对目标对象的访问。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class XiaoHongSellProxy implements SellPerfume {
        private SellPerfume sellPerfumeFactory;
    public XiaoHongSellProxy(SellPerfume sellPerfumeFactory) {
        this.sellPerfumeFactory = sellPerfumeFactory;
    }
    @Override
    public void sellPerfume(double price) {
        doSomethingBeforeSell(); // 前置增强
        sellPerfumeFactory.sellPerfume(price);
        doSomethingAfterSell(); // 后置增强
    }
    private void doSomethingBeforeSell() {
        System.out.println(&quot;小红代理购买香水前的额外操作...&quot;);
    }
    private void doSomethingAfterSell() {
        System.out.println(&quot;小红代理购买香水后的额外操作...&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（4）小明是一个需求者，他需要去购买香水，只能通过小红去购买，所以他去找小红购买&lt;code&gt;1999.99&lt;/code&gt;的香水。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class XiaoMing {
    public static void main(String[] args) {
        ChanelFactory factory = new ChanelFactory();
        XiaoHongSellProxy proxy = new XiaoHongSellProxy(factory);
        proxy.sellPerfume(1999.99);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们来看看运行结果，小红在向小明售卖香水前可以执行额外的其它操作，如果良心点的代购就会&lt;strong&gt;打折、包邮···&lt;/strong&gt;，如果黑心点的代购就会&lt;strong&gt;加手续费、售出不退还···&lt;/strong&gt;，是不是很刺激。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.smallpineapple.top/image-20200819212607989.png&quot; alt=&quot;image-20200819212607989&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们来看看上面 4 个类组成的类图关系结构，可以发现&lt;strong&gt;小红&lt;/strong&gt;和&lt;strong&gt;香奈儿提供商&lt;/strong&gt;都实现了&lt;strong&gt;售卖香水&lt;/strong&gt;这一接口，而小红内部增加了对提供商的引用，用于调用提供商的售卖香水功能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.smallpineapple.top/image-20200819214058888.png&quot; alt=&quot;image-20200819214058888&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;实现代理模式，需要走以下几个步骤：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;定义真实对象和代理对象的公共接口&lt;/strong&gt;（售卖香水接口）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;代理对象内部保存对真实目标对象的引用&lt;/strong&gt;（小红引用提供商）&lt;/li&gt;
&lt;li&gt;访问者仅能通过代理对象访问真实目标对象，&lt;strong&gt;不可直接访问目标对象&lt;/strong&gt;（小明只能通过小红去购买香水，不能直接到香奈儿提供商购买）&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;代理模式很容易产生错误思维的一个地方：代理对象并不是真正提供服务的一个对象，它只是替访问者访问目标对象的一个&lt;strong&gt;中间人&lt;/strong&gt;，真正提供服务的还是目标对象，而代理对象的作用就是在目标对象提供服务之前和之后能够执行额外的逻辑。&lt;/p&gt;
&lt;p&gt;从故事来说，小红并不是真正卖香水的，卖香水的还是香奈儿提供商，而小红只不过是在让香奈儿卖香水之前和之后执行了一些自己额外加上去的操作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;讲完这个代理模式的代码实现，我们来系统地学习它究竟是如何定义的，以及实现它需要注意什么规范。&lt;/p&gt;
&lt;p&gt;代理模式的定义：&lt;strong&gt;给目标对象提供一个代理对象，代理对象包含该目标对象，并控制对该目标对象的访问。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;代理模式的目的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通过代理对象的隔离，可以在对目标对象访问前后&lt;strong&gt;增加额外的业务逻辑，实现功能增强。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;通过代理对象访问目标对象，可以&lt;strong&gt;防止系统大量地直接对目标对象进行不正确地访问&lt;/strong&gt;，出现不可预测的后果&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;静态代理与动态代理&quot;&gt;静态代理与动态代理&lt;/h2&gt;
&lt;p&gt;你是否会有我一样的疑惑：代理为什么还要分静态和动态的？它们两个有啥不同吗？&lt;/p&gt;
&lt;p&gt;很明显，所有人都会有这样的疑惑，我们先来看看它们的相同点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;都能够实现代理模式（这不废话吗...）&lt;/li&gt;
&lt;li&gt;无论是静态代理还是动态代理，代理对象和目标对象都需要实现一个&lt;strong&gt;公共接口&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;重点当然是它们的不同之处，动态代理在静态代理的基础上做了改进，极大地提高了程序的&lt;strong&gt;可维护性&lt;/strong&gt;和&lt;strong&gt;可扩展性&lt;/strong&gt;。我先列出它们俩的不同之处，再详细解释为何静态代理不具备这两个特性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;动态代理产生代理对象的时机是&lt;strong&gt;运行时动态生成&lt;/strong&gt;，它没有 Java 源文件，&lt;strong&gt;直接生成字节码文件实例化代理对象&lt;/strong&gt;；而静态代理的代理对象，在&lt;strong&gt;程序编译时&lt;/strong&gt;已经写好 Java 文件了，直接 new 一个代理对象即可。&lt;/li&gt;
&lt;li&gt;动态代理比静态代理更加稳健，对程序的可维护性和可扩展性更加友好&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;目前来看，代理对象小红已经能够代理购买香水了，但有一天，小红的另外一个朋友小何来了，&lt;strong&gt;他想购买最纯正的法国红酒&lt;/strong&gt;，国内没有这样的购买渠道，小红刚巧也在法国，于是小何就想找小红帮他买红酒啦，这和小明找小红是一个道理的，都是想让小红做代理。&lt;/p&gt;
&lt;p&gt;但问题是：在程序中，小红只能代理购买香水，&lt;strong&gt;如果要代理购买红酒&lt;/strong&gt;，要怎么做呢？&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;创建售卖红酒的接口&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;售卖红酒提供商和代理对象小红都需要实现该接口&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;小何访问小红，让小红卖给他红酒&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://cdn.smallpineapple.top/image-20200820082820488.png&quot; alt=&quot;image-20200820082820488&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;OK，事已至此，代码就不重复写了，我们来探讨一下，面对这种新增的场景，上面的这种实现方法有没有什么缺陷呢？&lt;/p&gt;
&lt;p&gt;我们不得不提的是软件工程中的&lt;strong&gt;开闭原则&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;开闭原则：在编写程序的过程中，软件的所有对象应该是对扩展是开放的，而对修改是关闭的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;静态代理违反了开闭原则，原因是：面对新的需求时，需要修改代理类，增加实现新的接口和方法，导致代理类越来越庞大，变得难以维护。&lt;/p&gt;
&lt;p&gt;虽然说目前代理类只是实现了2个接口，&lt;strong&gt;如果日后小红不只是代理售卖红酒，还需要代理售卖电影票、代购日本寿司······&lt;/strong&gt;实现的接口会变得越来越多，内部的结构变得越来越复杂，&lt;strong&gt;整个类显得愈发臃肿&lt;/strong&gt;，变得不可维护，之后的扩展也会成问题，只要任意一个接口有改动，就会牵扯到这个代理类，维护的代价很高。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以，为了提高类的可扩展性和可维护性，满足开闭原则，Java 提供了动态代理机制。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;常见的动态代理实现&quot;&gt;常见的动态代理实现&lt;/h2&gt;
&lt;p&gt;动态代理最重要的当然是&lt;strong&gt;动态&lt;/strong&gt;两个字，学习动态代理的过程，最重要的就是理解何为动态，话不多说，马上开整。&lt;/p&gt;
&lt;p&gt;我们来明确一点：&lt;strong&gt;动态代理解决的问题是面对新的需求时，不需要修改代理对象的代码，只需要新增接口和真实对象，在客户端调用即可完成新的代理。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这样做的目的：满足软件工程的开闭原则，提高类的可维护性和可扩展性。&lt;/p&gt;
&lt;h3 id=&quot;jdk-proxy&quot;&gt;JDK Proxy&lt;/h3&gt;
&lt;p&gt;JDK Proxy 是 JDK 提供的一个动态代理机制，它涉及到两个核心类，分别是&lt;code&gt;Proxy&lt;/code&gt;和&lt;code&gt;InvocationHandler&lt;/code&gt;，我们先来了解如何使用它们。&lt;/p&gt;
&lt;p&gt;以小红代理卖香水的故事为例，香奈儿香水提供商依旧是真实对象，实现了&lt;code&gt;SellPerfume&lt;/code&gt;接口，这里不再重新写了，重点是&lt;strong&gt;小红代理&lt;/strong&gt;，这里的代理对象不再是小红一个人，而是一个&lt;strong&gt;代理工厂&lt;/strong&gt;，里面会有许多的代理对象。我画了一幅图，你看了之后会很好理解：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.smallpineapple.top/image-20200820085642788.png&quot; alt=&quot;image-20200820085642788&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;小明来到代理工厂，需要购买一款法国在售的香奈儿香水，那么工厂就会&lt;strong&gt;找一个可以实际的代理对象（动态实例化）&lt;/strong&gt;分配给小明，例如小红或者小花，让该代理对象完成小明的需求。&lt;strong&gt;该代理工厂含有无穷无尽的代理对象可以分配，且每个对象可以代理的事情可以根据程序的变化而动态变化，无需修改代理工厂。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果有一天小明需要招待一个可以&lt;strong&gt;代购红酒&lt;/strong&gt;的代理对象，该代理工厂依旧可以满足他的需求，无论日后需要什么代理，都可以满足，是不是觉得很神奇？我们来学习如何使用它。&lt;/p&gt;
&lt;p&gt;我们看一下动态代理的 UML 类图结构长什么样子。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.smallpineapple.top/image-20200821113009611.png&quot; alt=&quot;image-20200820090834069&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到和静态代理区别不大，唯一的变动是代理对象，我做了标注：&lt;strong&gt;由代理工厂生产&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这句话的意思是：&lt;strong&gt;代理对象是在程序运行过程中，由代理工厂动态生成，代理对象本身不存在 Java 源文件&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;那么，我们的关注点有&lt;code&gt;2&lt;/code&gt;个：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如何实现一个代理工厂&lt;/li&gt;
&lt;li&gt;如何通过代理工厂动态生成代理对象&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;首先，代理工厂需要实现&lt;code&gt;InvocationHanlder&lt;/code&gt;接口并实现其&lt;code&gt;invoke()&lt;/code&gt;方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class SellProxyFactory implements InvocationHandler {
        /** 代理的真实对象 */
    private Object realObject;

    public SellProxyFactory(Object realObject) {
        this.realObject = realObject;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        doSomethingBefore();
        Object obj = method.invoke(realObject, args);
        doSomethingAfter();
        return obj;
    }

    private void doSomethingAfter() {
        System.out.println(&quot;执行代理后的额外操作...&quot;);
    }

    private void doSomethingBefore() {
        System.out.println(&quot;执行代理前的额外操作...&quot;);
    }
    
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;invoke() 方法有&lt;code&gt;3&lt;/code&gt;个参数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Object proxy&lt;/code&gt;：代理对象&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Method method&lt;/code&gt;：真正执行的方法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Object[] agrs&lt;/code&gt;：调用第二个参数 method 时传入的参数列表值&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;invoke() 方法是一个代理方法，也就是说最后客户端请求代理时，执行的就是该方法。代理工厂类到这里为止已经结束了，我们接下来看第二点：&lt;strong&gt;如何通过代理工厂动态生成代理对象&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;生成代理对象需要用到&lt;code&gt;Proxy&lt;/code&gt;类，它可以帮助我们生成任意一个代理对象，里面提供一个静态方法&lt;code&gt;newProxyInstance&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt; Proxy.newProxyInstance(ClassLoader loader, Class&amp;lt;?&amp;gt;[] interfaces, InvocationHandler h);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实例化代理对象时，需要传入&lt;code&gt;3&lt;/code&gt;个参数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ClassLoader loader：加载动态代理类的类加载器&lt;/li&gt;
&lt;li&gt;Class&amp;lt;?&amp;gt;[] interfaces：代理类实现的接口，可以传入多个接口&lt;/li&gt;
&lt;li&gt;InvocationHandler h：指定代理类的&lt;strong&gt;调用处理程序&lt;/strong&gt;，即调用接口中的方法时，会找到该代理工厂&lt;code&gt;h&lt;/code&gt;，执行&lt;code&gt;invoke()&lt;/code&gt;方法&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们在客户端请求代理时，就需要用到上面这个方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class XiaoMing {
    public static void main(String[] args) {
        ChanelFactory chanelFactory = new ChanelFactory();
        SellProxyFactory sellProxyFactory = new SellProxyFactory(chanelFactory);
        SellPerfume sellPerfume = (SellPerfume) Proxy.newProxyInstance(chanelFactory.getClass().getClassLoader(),
                chanelFactory.getClass().getInterfaces(),
                sellProxyFactory);
        sellPerfume.sellPerfume(1999.99);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果和静态代理的结果相同，但二者的思想是不一样的，一个是静态，一个是动态。那又如何体现出动态代理的优势呢？别急，往下看就知道了。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;注意看下图，相比&lt;code&gt;静态代理&lt;/code&gt;的前置增强和后置增强，少了&lt;strong&gt;小红&lt;/strong&gt;二字，实际上代理工厂分配的代理对象是随机的，不会针对某一个具体的代理对象，所以每次生成的代理对象都不一样，也就不确定是不是小红了，但是能够唯一确定的是，&lt;strong&gt;这个代理对象能和小红一样帮小明买到香水！&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.smallpineapple.top/image-20200820104319179.png&quot; alt=&quot;image-20200820104319179&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;按照之前的故事线发展，小红去代理红酒，而&lt;strong&gt;小明又想买法国的名牌红酒&lt;/strong&gt;，所以去找代理工厂，让它再分配一个人帮小明买红酒，代理工厂说：“当然没问题！我们是专业的！等着！”&lt;/p&gt;
&lt;p&gt;我们需要实现两个类：红酒提供商类 和 售卖红酒接口。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Java&quot;&gt;/** 售卖红酒接口 */
public interface SellWine {
    void sellWine(double price);
}

/** 红酒供应商 */
public class RedWineFactory implements SellWine {

    @Override
    public void sellWine(double price) {
        System.out.println(&quot;成功售卖一瓶红酒，价格：&quot; + price + &quot;元&quot;);    
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们的小明在请求代理工厂时，就可以&lt;strong&gt;实例化一个可以售卖红酒的代理&lt;/strong&gt;了。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class XiaoMing {
    public static void main(String[] args) {
        // 实例化一个红酒销售商
        RedWineFactory redWineFactory = new RedWineFactory();
        // 实例化代理工厂，传入红酒销售商引用控制对其的访问
        SellProxyFactory sellProxyFactory = new SellProxyFactory(redWineFactory);
        // 实例化代理对象，该对象可以代理售卖红酒
        SellWine sellWineProxy = (SellWine) Proxy.newProxyInstance(redWineFactory.getClass().getClassLoader(),
                redWineFactory.getClass().getInterfaces(),
                sellProxyFactory);
        // 代理售卖红酒
        sellWineProxy.sellWine(1999.99);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;期待一下执行结果，你会很惊喜地发现，居然也能够代理售卖红酒了，但是我们&lt;strong&gt;没有修改代理工厂&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.smallpineapple.top/image-20200820105337247.png&quot; alt=&quot;image-20200820105337247&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;回顾一下我们新增红酒代理功能时，需要&lt;code&gt;2&lt;/code&gt;个步骤：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;创建新的红酒提供商&lt;code&gt;SellWineFactory&lt;/code&gt;和售卖红酒接口&lt;code&gt;SellWine&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在客户端实例化一个代理对象，然后向该代理对象购买红酒&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;再回想&lt;strong&gt;开闭原则：面向扩展开放，面向修改关闭&lt;/strong&gt;。动态代理正是满足了这一重要原则，在面对功能需求扩展时，只需要关注扩展的部分，不需要修改系统中原有的代码。&lt;/p&gt;
&lt;p&gt;如果感兴趣想深究的朋友，把注意力放在&lt;code&gt;Proxy.newProxyInstance()&lt;/code&gt;这个方法上，这是整个 JDK 动态代理起飞的一个方法。&lt;/p&gt;
&lt;p&gt;讲到这里，JDK 提供的动态代理已经到尾声了，我们来总结一下 JDK 的动态代理：&lt;/p&gt;
&lt;p&gt;（1）JDK 动态代理的使用方法&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;代理工厂需要实现 &lt;code&gt;InvocationHandler&lt;/code&gt;接口，调用代理方法时会转向执行&lt;code&gt;invoke()&lt;/code&gt;方法&lt;/li&gt;
&lt;li&gt;生成代理对象需要使用&lt;code&gt;Proxy&lt;/code&gt;对象中的&lt;code&gt;newProxyInstance()&lt;/code&gt;方法，返回对象可强转成传入的其中一个接口，然后调用接口方法即可实现代理&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;（2）JDK 动态代理的特点&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;目标对象强制需要实现一个接口，否则无法使用 JDK 动态代理&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;（以下为扩展内容，如果不想看可跳过）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Proxy.newProxyInstance() 是生成动态代理对象的关键，我们可来看看它里面到底干了些什么，我把重要的代码提取出来，一些对分析无用的代码就省略掉了。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private static final Class&amp;lt;?&amp;gt;[] constructorParams ={ InvocationHandler.class };
public static Object newProxyInstance(ClassLoader loader,
                                          Class&amp;lt;?&amp;gt;[] interfaces,
                                          InvocationHandler h) {
    // 获取代理类的 Class 对象
    Class&amp;lt;?&amp;gt; cl = getProxyClass0(loader, intfs);
    // 获取代理对象的显示构造器，参数类型是 InvocationHandler
    final Constructor&amp;lt;?&amp;gt; cons = cl.getConstructor(constructorParams);
    // 反射，通过构造器实例化动态代理对象
    return cons.newInstance(new Object[]{h});
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们看到第 &lt;code&gt;6&lt;/code&gt; 行获取了一个动态代理对象，那么是如何生成的呢？接着往下看。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private static Class&amp;lt;?&amp;gt; getProxyClass0(ClassLoader loader,
                                       Class&amp;lt;?&amp;gt;... interfaces) {
    // 去代理类对象缓存中获取代理类的 Class 对象
    return proxyClassCache.get(loader, interfaces);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;发现里面用到一个缓存 &lt;strong&gt;proxyClassCache&lt;/strong&gt;，从结构来看类似于是一个 &lt;code&gt;map&lt;/code&gt; 结构，根据类加载器&lt;code&gt;loader&lt;/code&gt;和真实对象实现的接口&lt;code&gt;interfaces&lt;/code&gt;查找是否有对应的 Class 对象，我们接着往下看 &lt;code&gt;get()&lt;/code&gt; 方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt; public V get(K key, P parameter) {
     // 先从缓存中查询是否能根据 key 和 parameter 查询到 Class 对象
     // ...
     // 生成一个代理类
     Object subKey = Objects.requireNonNull(subKeyFactory.apply(key, parameter));
 }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 get() 方法中，如果没有从缓存中获取到 Class 对象，则需要利用 &lt;strong&gt;subKeyFactory&lt;/strong&gt; 去实例化一个动态代理对象，而在 &lt;strong&gt;Proxy&lt;/strong&gt; 类中包含一个 &lt;strong&gt;ProxyClassFactory&lt;/strong&gt; 内部类，由它来创建一个动态代理类，所以我们接着去看 ProxyClassFactory 中的 &lt;code&gt;apply()&lt;/code&gt; 方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private static final class ProxyClassFactory
    implements BiFunction&amp;lt;ClassLoader, Class&amp;lt;?&amp;gt;[], Class&amp;lt;?&amp;gt;&amp;gt; {
    // 非常重要，这就是我们看到的动态代理的对象名前缀！
        private static final String proxyClassNamePrefix = &quot;$Proxy&quot;;

    @Override
    public Class&amp;lt;?&amp;gt; apply(ClassLoader loader, Class&amp;lt;?&amp;gt;[] interfaces) {
        Map&amp;lt;Class&amp;lt;?&amp;gt;, Boolean&amp;gt; interfaceSet = new IdentityHashMap&amp;lt;&amp;gt;(interfaces.length);
        // 一些状态校验
                
        // 计数器，该计数器记录了当前已经实例化多少个代理对象
        long num = nextUniqueNumber.getAndIncrement();
        // 动态代理对象名拼接！包名 + &quot;$Proxy&quot; + 数字
        String proxyName = proxyPkg + proxyClassNamePrefix + num;

        // 生成字节码文件，返回一个字节数组
        byte[] proxyClassFile = ProxyGenerator.generateProxyClass(
            proxyName, interfaces, accessFlags);
        try {
            // 利用字节码文件创建该字节码的 Class 类对象
            return defineClass0(loader, proxyName,
                                proxyClassFile, 0, proxyClassFile.length);
        } catch (ClassFormatError e) {
            throw new IllegalArgumentException(e.toString());
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;apply() 方法中注意有&lt;strong&gt;两个非常重要的方法&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;ProxyGenerator.generateProxyClass()&lt;/strong&gt;：它是生成字节码文件的方法，它返回了一个字节数组，字节码文件本质上就是一个字节数组，所以 &lt;code&gt;proxyClassFile&lt;/code&gt;数组就是一个字节码文件&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;defineClass0()&lt;/strong&gt;：生成字节码文件的 Class 对象，它是一个 &lt;code&gt;native&lt;/code&gt; 本地方法，调用操作系统底层的方法创建类对象&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;而 &lt;code&gt;proxyName&lt;/code&gt; 是代理对象的名字，我们可以看到它利用了 &lt;strong&gt;proxyClassNamePrefix + 计数器&lt;/strong&gt; 拼接成一个新的名字。所以在 DEBUG 时，停留在代理对象变量上，你会发现变量名是&lt;code&gt;$Proxy0&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.smallpineapple.top/image-20200821110425359.png&quot; alt=&quot;image-20200821110425359&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到了这里，源码分析完了，是不是感觉被掏空了？哈哈哈哈，其实我当时也有这种感觉，不过现在你也感觉到，JDK 的动态代理其实并不是特别复杂吧（只要你有毅力）&lt;/p&gt;
&lt;h3 id=&quot;cglib&quot;&gt;CGLIB&lt;/h3&gt;
&lt;p&gt;CGLIB（Code generation Library） 不是 JDK 自带的动态代理，它需要导入第三方依赖，它是一个字节码生成类库，能够在运行时动态生成代理类对 &lt;strong&gt;Java类 和 Java接口&lt;/strong&gt; 扩展。&lt;/p&gt;
&lt;p&gt;CGLIB不仅能够为 Java接口 做代理，而且&lt;strong&gt;能够为普通的 Java类 做代理&lt;/strong&gt;，而 JDK Proxy &lt;strong&gt;只能为实现了接口&lt;/strong&gt;的 Java类 做代理，所以 CGLIB 为 Java 的代理做了很好的扩展。&lt;strong&gt;如果需要代理的类没有实现接口，可以选择 Cglib 作为实现动态代理的工具。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;废话太多，一句话概括：&lt;strong&gt;CGLIB 可以代理没有实现接口的 Java 类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面我们来学习它的使用方法，以&lt;strong&gt;小明找代理工厂买法国香水&lt;/strong&gt;这个故事背景为例子。&lt;/p&gt;
&lt;p&gt;（1）导入依赖&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;cglib&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;cglib-nodep&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;3.3.0&amp;lt;/version&amp;gt;
    &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;还有另外一个 CGLIB 包，二者的区别是带有&lt;code&gt;-nodep&lt;/code&gt;的依赖内部已经包括了&lt;code&gt;ASM&lt;/code&gt;字节码框架的相关代码，无需额外依赖&lt;code&gt;ASM&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;（2）CGLIB 代理中有两个核心的类：&lt;code&gt;MethodInterceptor&lt;/code&gt;接口 和 &lt;code&gt;Enhancer&lt;/code&gt;类，前者是实现一个代理工厂的根接口，后者是创建动态代理对象的类，在这里我再贴一次故事的结构图，帮助你们理解。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.smallpineapple.top/image-20200821113009611.png&quot; alt=&quot;image-20200821113009611&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先我们来定义代理工厂&lt;code&gt;SellProxyFactory&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class SellProxyFactory implements MethodInterceptor {
    // 关联真实对象，控制对真实对象的访问
    private Object realObject;
    /** 从代理工厂中获取一个代理对象实例，等价于创建小红代理 */
    public Object getProxyInstance(Object realObject) {
        this.realObject = realObject;
        Enhancer enhancer = new Enhancer();
        // 设置需要增强类的类加载器
        enhancer.setClassLoader(realObject.getClass().getClassLoader());
        // 设置被代理类，真实对象
        enhancer.setSuperclass(realObject.getClass());
        // 设置方法拦截器，代理工厂
        enhancer.setCallback(this);
        // 创建代理类
        return enhancer.create();
    }
    
    @Override
    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
        doSomethingBefore(); // 前置增强
        Object object = methodProxy.invokeSuper(o, objects);
        doSomethingAfter(); // 后置增强
        return object;
    }

    private void doSomethingBefore() {
        System.out.println(&quot;执行方法前额外的操作...&quot;);
    }

    private void doSomethingAfter() {
        System.out.println(&quot;执行方法后额外的操作...&quot;);
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;intercept() 方法涉及到 4 个参数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Object o：被代理对象&lt;/li&gt;
&lt;li&gt;Method method：被拦截的方法&lt;/li&gt;
&lt;li&gt;Object[] objects：被拦截方法的所有入参值&lt;/li&gt;
&lt;li&gt;MethodProxy methodProxy：方法代理，用于调用原始的方法&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5.6118143459916&quot;&gt;
&lt;p&gt;对于 &lt;code&gt;methodProxy&lt;/code&gt; 参数调用的方法，在其内部有两种选择：&lt;code&gt;invoke()&lt;/code&gt; 和 &lt;code&gt;invokeSuper()&lt;/code&gt; ，二者的区别不在本文展开说明，感兴趣的读者可以参考本篇文章：&lt;a href=&quot;https://blog.csdn.net/makecontral/article/details/79593732?utm_medium=distribute.pc_relevant.none-task-blog-baidulandingword-4&amp;amp;spm=1001.2101.3001.4242&quot;&gt;Cglib源码分析 invoke和invokeSuper的差别&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在 &lt;code&gt;getInstance()&lt;/code&gt; 方法中，利用 &lt;code&gt;Enhancer&lt;/code&gt; 类实例化代理对象（可以看作是小红）返回给调用者小明，即可完成代理操作。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class XiaoMing {
    public static void main(String[] args) {
        SellProxyFactory sellProxyFactory = new SellProxyFactory();
        // 获取一个代理实例
        SellPerfumeFactory proxyInstance =
                (SellPerfumeFactory) sellProxyFactory.getProxyInstance(new SellPerfumeFactory());
        // 创建代理类
        proxyInstance.sellPerfume(1999.99);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们关注点依旧放在可扩展性和可维护性上，Cglib 依旧符合&lt;strong&gt;开闭原则&lt;/strong&gt;，如果小明需要小红代理购买红酒，该如何做呢？这里碍于篇幅原因，我不再将完整的代码贴出来了，可以自己试着手动实现一下，或者在心里有一个大概的实现思路即可。&lt;/p&gt;
&lt;p&gt;我们来总结一下 CGLIB 动态代理：&lt;/p&gt;
&lt;p&gt;（1）CGLIB 的使用方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;代理工厂需要&lt;strong&gt;实现 MethodInterceptor 接口&lt;/strong&gt;，并重写方法，&lt;strong&gt;内部关联真实对象&lt;/strong&gt;，控制第三者对真实对象的访问；代理工厂内部暴露 &lt;code&gt;getInstance(Object realObject)&lt;/code&gt; 方法，&lt;strong&gt;用于从代理工厂中获取一个代理对象实例&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Enhancer&lt;/code&gt; 类用于从代理工厂中实例化一个代理对象，给调用者提供代理服务。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;jdk-proxy-和-cglib-的对比&quot;&gt;JDK Proxy 和 CGLIB 的对比&lt;/h3&gt;
&lt;p&gt;（2）仔细对比一下，JDK Proxy 和 CGLIB 具有相似之处：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th&gt;JDK Proxy&lt;/th&gt;
&lt;th&gt;CGLIB&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;代理工厂实现接口&lt;/td&gt;
&lt;td&gt;InvocationHandler&lt;/td&gt;
&lt;td&gt;MethodInterceptor&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;构造代理对象给 Client 服务&lt;/td&gt;
&lt;td&gt;Proxy&lt;/td&gt;
&lt;td&gt;Enhancer&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;二者都是用到了两个核心的类，它们也有不同：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;最明显的不同：CGLIB 可以代理&lt;strong&gt;大部分类&lt;/strong&gt;（第二点说到）；而 JDK Proxy &lt;strong&gt;仅能够代理实现了接口的类&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;CGLIB 采用动态创建被代理类的子类实现方法拦截，子类内部重写被拦截的方法，所以 CGLIB 不能代理被 &lt;code&gt;final&lt;/code&gt; 关键字修饰的类和方法&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;细心的读者会发现，讲的东西都是&lt;strong&gt;浅尝辄止&lt;/strong&gt;&lt;s&gt;（你都没有给我讲源码，水文实锤）&lt;/s&gt;，动态代理的精髓在于&lt;strong&gt;程序在运行时动态生成代理类对象，拦截调用方法，在调用方法前后扩展额外的功能&lt;/strong&gt;，而生成动态代理对象的原理就是&lt;strong&gt;反射机制&lt;/strong&gt;，在上一篇文章中，我详细讲到了如何利用反射实例化对象，调用方法······在代理中运用得淋漓尽致，所以反射和代理也是天生的一对，谈到其中一个，必然会涉及另外一个。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;动态代理的实际应用&quot;&gt;动态代理的实际应用&lt;/h2&gt;
&lt;p&gt;传统的 OOP 编程符合从上往下的编码关系，却不符合从左往右的编码关系，如果你看不懂，可以参考下面的动图，OOP 满足我们一个方法一个方法从上往下地执行，但是却不能&lt;strong&gt;从左往右嵌入代码&lt;/strong&gt;，而 AOP 的出现很好地弥补了这一点，它&lt;strong&gt;允许我们将重复的代码逻辑抽取出来形成一个单独的覆盖层&lt;/strong&gt;，在执行代码时可以将该覆盖层毫无知觉的嵌入到原代码逻辑里面去。&lt;/p&gt;
&lt;h3 id=&quot;spring-aop&quot;&gt;Spring AOP&lt;/h3&gt;
&lt;p&gt;如下图所示，method1 和 method2 都需要在方法执行前后&lt;strong&gt;记录日志&lt;/strong&gt;，实际上会有更多的方法需要记录日志，传统的 OOP 只能够让我们在每个方法前后手动记录日志，大量的&lt;code&gt;Log.info&lt;/code&gt;存在于方法内部，导致代码阅读性下降，方法内部无法专注于自己的逻辑。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AOP 可以将这些重复性的代码包装到额外的一层，监听方法的执行，当方法被调用时，通用的日志记录层会拦截掉该方法，在该方法调用前后记录日志，这样可以让方法专注于自己的业务逻辑而无需关注其它不必要的信息。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.smallpineapple.top/2-1597982180559.gif&quot; alt=&quot;2&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Spring AOP 有许多功能：提供缓存、提供日志环绕、事务处理······在这里，我会以&lt;strong&gt;事务&lt;/strong&gt;作为例子向你讲解 Spring 底层是如何使用动态代理的。&lt;/p&gt;
&lt;p&gt;Spring 的事务涉及到一个核心注解&lt;code&gt;@Transactional&lt;/code&gt;，相信很多人在项目中都用到过，加上这个注解之后，在执行方法时如果发生异常，该方法内所有的事务都回滚，否则全部提交生效，这是最宏观的表现，它内部是如何实现的呢？今天就来简单分析一下。&lt;/p&gt;
&lt;p&gt;每个有关数据库的操作都要保证一个事务内的所有操作，要么全部执行成功，要么全部执行失败，传统的事务失败回滚和成功提交是使用&lt;code&gt;try...catch&lt;/code&gt;代码块完成的&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;SqlSession session = null;
try{
    session = getSqlSessionFactory().openSession(false);
    session.update(&quot;...&quot;, new Object());
    // 事务提交
    session.commit();
}catch(Exception e){
    // 事务回滚
    session.rollback();
    throw e;
}finally{
    // 关闭事务
    session.close();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果多个方法都需要写这一段逻辑非常冗余，所以 Spring 给我们封装了一个注解 @Transactional，使用它后，调用方法时会监视方法，如果方法上含有该注解，就会自动帮我们把数据库相关操作的代码包裹起来，最终形成类似于上面的一段代码原理，当然这里并不准确，只是给你们一个大概的总览，了解Spring AOP 的本质在干什么，这篇文章讲解到这里，知识量应该也非常多了，好好消化上面的知识点，为后面的 Spring AOP 专题学习打下坚实的基础。&lt;/p&gt;
&lt;p&gt;你好，我是 cxuan，我自己手写了四本 PDF，分别是 Java基础总结、HTTP 核心总结、计算机基础知识，操作系统核心总结，我已经整理成为 PDF，可以关注公众号 Java建设者 回复 PDF 领取优质资料。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202008/1515111-20200826082925259-639682511.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 26 Aug 2020 00:30:00 +0000</pubDate>
<dc:creator>程序员cxuan</dc:creator>
<og:description>说在前面：今天我们来聊一聊 Java 中的代理，先来聊聊故事背景： 小明想购买法国某个牌子的香水送给女朋友，但是在国内没有货源售卖，亲自去法国又大费周章了，而小红现在正在法国玩耍，她和小明是好朋友，可</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cxuanBlog/p/13563059.html</dc:identifier>
</item>
<item>
<title>【Flutter 实战】自定义动画-涟漪和雷达扫描 - 老孟Flutter</title>
<link>http://www.cnblogs.com/mengqd/p/13562995.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mengqd/p/13562995.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202008/467322-20200826065915000-1924599008.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;老孟导读：此篇文章是 Flutter 动画系列文章第五篇，本文介绍2个自定义动画：&lt;strong&gt;涟漪&lt;/strong&gt;和&lt;strong&gt;雷达扫描&lt;/strong&gt;效果。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;涟漪&quot;&gt;涟漪&lt;/h2&gt;
&lt;p&gt;实现涟漪动画效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202008/467322-20200826065915564-455910868.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此动画通过 &lt;strong&gt;CustomPainter&lt;/strong&gt; 绘制配合 &lt;strong&gt;AnimationController&lt;/strong&gt; 动画控制实现，定义动画控制部分：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;class WaterRipple extends StatefulWidget {
  final int count;
  final Color color;

  const WaterRipple({Key key, this.count = 3, this.color = const Color(0xFF0080ff)}) : super(key: key);

  @override
  _WaterRippleState createState() =&amp;gt; _WaterRippleState();
}

class _WaterRippleState extends State&amp;lt;WaterRipple&amp;gt;
    with SingleTickerProviderStateMixin {
  AnimationController _controller;

  @override
  void initState() {
    _controller =
        AnimationController(vsync: this, duration: Duration(milliseconds: 2000))
          ..repeat();
    super.initState();
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return AnimatedBuilder(
      animation: _controller,
      builder: (context, child) {
        return CustomPaint(
          painter: WaterRipplePainter(_controller.value,count: widget.count,color: widget.color),
        );
      },
    );
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;count&lt;/strong&gt; 和 &lt;strong&gt;color&lt;/strong&gt; 分别代表水波纹的数量和颜色。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;WaterRipplePainter&lt;/strong&gt; 定义如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;class WaterRipplePainter extends CustomPainter {
  final double progress;
  final int count;
  final Color color;

  Paint _paint = Paint()..style = PaintingStyle.fill;

  WaterRipplePainter(this.progress,
      {this.count = 3, this.color = const Color(0xFF0080ff)});

  @override
  void paint(Canvas canvas, Size size) {
    double radius = min(size.width / 2, size.height / 2);

    for (int i = count; i &amp;gt;= 0; i--) {
      final double opacity = (1.0 - ((i + progress) / (count + 1)));
      final Color _color = color.withOpacity(opacity);
      _paint..color = _color;

      double _radius = radius * ((i + progress) / (count + 1));

      canvas.drawCircle(
          Offset(size.width / 2, size.height / 2), _radius, _paint);
    }
  }

  @override
  bool shouldRepaint(CustomPainter oldDelegate) {
    return true;
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重点是 &lt;strong&gt;paint&lt;/strong&gt; 方法，根据动画进度计算颜色的透明度和半径。&lt;/p&gt;
&lt;p&gt;使用如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;class WaterRipplePage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Center(
          child: Container(height: 200, width: 200, child: WaterRipple())),
    );
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;雷达扫描&quot;&gt;雷达扫描&lt;/h2&gt;
&lt;p&gt;实现雷达扫描效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202008/467322-20200826065915794-1497419610.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此效果分为两部分：中间的 logo 图片和扫描部分。&lt;/p&gt;
&lt;h3 id=&quot;中间的-logo-图片&quot;&gt;中间的 logo 图片&lt;/h3&gt;
&lt;p&gt;中间的 logo 图片边缘有阴影效果，像是太阳发光一样，实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;Container(
  height: 70.0,
  width: 70.0,
  decoration: BoxDecoration(
      color: Colors.grey,
      image: DecorationImage(
          image: AssetImage('assets/images/logo.png')),
      shape: BoxShape.circle,
      boxShadow: [
        BoxShadow(
          color: Colors.white.withOpacity(.5),
          blurRadius: 5.0,
          spreadRadius: 3.0,
        ),
      ]),
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/Users/mengqingdong/Downloads/13/img/Radar/image-20200825162736921.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;扫描&quot;&gt;扫描&lt;/h3&gt;
&lt;p&gt;定义雷达扫描的动画控制器：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;class RadarView extends StatefulWidget {
  @override
  _RadarViewState createState() =&amp;gt; _RadarViewState();
}

class _RadarViewState extends State&amp;lt;RadarView&amp;gt;
    with SingleTickerProviderStateMixin {
  AnimationController _controller;
  Animation&amp;lt;double&amp;gt; _animation;

  @override
  void initState() {
    _controller =
        AnimationController(vsync: this, duration: Duration(seconds: 5));
    _animation = Tween(begin: .0, end: pi * 2).animate(_controller);
    _controller.repeat();
    super.initState();
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return AnimatedBuilder(
      animation: _animation,
      builder: (context, child) {
        return CustomPaint(
          painter: RadarPainter(_animation.value),
        );
      },
    );
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;RadarPainter&lt;/strong&gt; 定义如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;class RadarPainter extends CustomPainter {
  final double angle;

  Paint _bgPaint = Paint()
    ..color = Colors.white
    ..strokeWidth = 1
    ..style = PaintingStyle.stroke;

  Paint _paint = Paint()..style = PaintingStyle.fill;

  int circleCount = 3;

  RadarPainter(this.angle);

  @override
  void paint(Canvas canvas, Size size) {
    var radius = min(size.width / 2, size.height / 2);

    canvas.drawLine(Offset(size.width / 2, size.height / 2 - radius),
        Offset(size.width / 2, size.height / 2 + radius), _bgPaint);
    canvas.drawLine(Offset(size.width / 2 - radius, size.height / 2),
        Offset(size.width / 2 + radius, size.height / 2), _bgPaint);

    for (var i = 1; i &amp;lt;= circleCount; ++i) {
      canvas.drawCircle(Offset(size.width / 2, size.height / 2),
          radius * i / circleCount, _bgPaint);
    }

    _paint.shader = ui.Gradient.sweep(
        Offset(size.width / 2, size.height / 2),
        [Colors.white.withOpacity(.01), Colors.white.withOpacity(.5)],
        [.0, 1.0],
        TileMode.clamp,
        .0,
        pi / 12);

    canvas.save();
    double r = sqrt(pow(size.width, 2) + pow(size.height, 2));
    double startAngle = atan(size.height / size.width);
    Point p0 = Point(r * cos(startAngle), r * sin(startAngle));
    Point px = Point(r * cos(angle + startAngle), r * sin(angle + startAngle));
    canvas.translate((p0.x - px.x) / 2, (p0.y - px.y) / 2);
    canvas.rotate(angle);

    canvas.drawArc(
        Rect.fromCircle(
            center: Offset(size.width / 2, size.height / 2), radius: radius),
        0,
        pi / 12,
        true,
        _paint);
    canvas.restore();
  }

  @override
  bool shouldRepaint(CustomPainter oldDelegate) {
    return true;
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将两者结合在一起：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;class RadarPage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
        backgroundColor: Color(0xFF0F1532),
        body: Stack(
          children: [
            Positioned.fill(
              left: 10,
              right: 10,
              child: Center(
                child: Stack(children: [
                  Positioned.fill(
                    child: RadarView(),
                  ),
                  Positioned(
                    child: Center(
                      child: Container(
                        height: 70.0,
                        width: 70.0,
                        decoration: BoxDecoration(
                            color: Colors.grey,
                            image: DecorationImage(
                                image: AssetImage('assets/images/logo.png')),
                            shape: BoxShape.circle,
                            boxShadow: [
                              BoxShadow(
                                color: Colors.white.withOpacity(.5),
                                blurRadius: 5.0,
                                spreadRadius: 3.0,
                              ),
                            ]),
                      ),
                    ),
                  ),
                ]),
              ),
            )
          ],
        ));
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;交流&quot;&gt;交流&lt;/h2&gt;
&lt;p&gt;老孟Flutter博客地址（330个控件用法）：&lt;a href=&quot;http://laomengit.com&quot;&gt;http://laomengit.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎加入Flutter交流群（微信：laomengit）、关注公众号【老孟Flutter】：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th/&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202008/467322-20200826065916006-84243168.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202008/467322-20200826065916304-679558316.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</description>
<pubDate>Tue, 25 Aug 2020 22:59:00 +0000</pubDate>
<dc:creator>老孟Flutter</dc:creator>
<og:description>老孟导读：此篇文章是 Flutter 动画系列文章第五篇，本文介绍2个自定义动画：涟漪和雷达扫描效果。 涟漪 实现涟漪动画效果如下： 此动画通过 CustomPainter 绘制配合 Animatio</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mengqd/p/13562995.html</dc:identifier>
</item>
<item>
<title>OMG，12 个精致的 Java 字符串操作小技巧，学它 - 沉默王二</title>
<link>http://www.cnblogs.com/qing-gee/p/13562974.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qing-gee/p/13562974.html</guid>
<description>&lt;p&gt;字符串可以说是 Java 中最具有代表性的类了，似乎没有之一哈，这就好像直播界的李佳琪，脱口秀中的李诞，一等一的大哥地位。不得不承认，最近吐槽大会刷多了，脑子里全是那些段子，写文章都有点不由自主，真的是，手不由己啊。&lt;/p&gt;
&lt;p&gt;字符串既然最常用，那就意味着面试官好这一口，就喜欢问一些字符串方面的编码技巧，来测试应聘者是否技术过硬，底子扎实，对吧？&lt;/p&gt;
&lt;p&gt;那这次，我就来盘点 12 个精致的 Java 字符串操作小技巧，来帮助大家提高一下下。在查看我给出的答案之前，最好自己先动手尝试一遍，写不出来答案没关系，先思考一遍，看看自己的知识库里是不是已经有解决方案，有的话，就当是温故复习了，没有的话，也不要担心，刚好学一遍。&lt;/p&gt;
&lt;h3 id=&quot;h01&quot;&gt;&lt;span&gt;01、如何在字符串中获取不同的字符及其数量？&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;这道题可以拆解为两个步骤，第一步，找出不同的字符，第二步，统计出它们的数量。好像有点废话，是不是？那我先来一个答案吧。&lt;/p&gt;
&lt;pre readability=&quot;9&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;12&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;DistinctCharsCount&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;printDistinctCharsWithCount(&lt;span class=&quot;hljs-string&quot;&gt;&quot;itwanger&quot;&lt;/span&gt;);&lt;br/&gt;printDistinctCharsWithCount(&lt;span class=&quot;hljs-string&quot;&gt;&quot;chenmowanger&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;printDistinctCharsWithCount&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String input)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;Map&amp;lt;Character, Integer&amp;gt; charsWithCountMap = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; LinkedHashMap&amp;lt;&amp;gt;();&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;char&lt;/span&gt; c : input.toCharArray()) {&lt;br/&gt;Integer oldValue = charsWithCountMap.get(c);&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; newValue = (oldValue == &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;) ? &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; :&lt;br/&gt;Integer.sum(oldValue, &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;);&lt;/p&gt;&lt;p&gt;charsWithCountMap.put(c, newValue);&lt;br/&gt;}&lt;br/&gt;System.out.println(charsWithCountMap);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;程序输出的结果是：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs delphi&quot;&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;说一下我的思路：&lt;/p&gt;
&lt;p&gt;1）声明一个 &lt;a href=&quot;https://mp.weixin.qq.com/s/yI6mMIjddKnAOjOfwzjlXw&quot;&gt;LinkedHashMap&lt;/a&gt;，也可以用 HashMap，不过前者可以保持字符串拆分后的顺序，结果看起来更一目了然。&lt;/p&gt;
&lt;p&gt;为什么要用 Map 呢？因为 Map 的 key 是不允许重复的，刚好可以对重复的字符进行数量的累加。&lt;/p&gt;
&lt;p&gt;2）把字符串拆分成字符，进行遍历。&lt;/p&gt;
&lt;p&gt;3）如果 key 为 null 的话，就表明它的数量要 +1；否则的话，就在之前的值上 +1，然后重新 put 到 Map 中，这样就覆盖了之前的字符数量。&lt;/p&gt;
&lt;p&gt;思路很清晰，对不对？忍不住给自己鼓个掌。&lt;/p&gt;
&lt;p&gt;那，JDK 8 之后，Map 新增了一个很厉害的方法 &lt;code&gt;merge()&lt;/code&gt;，一次性为多个键赋值：&lt;/p&gt;
&lt;pre readability=&quot;5.5&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;5&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;printDistinctCharsWithCountMerge&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String input)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;Map&amp;lt;Character, Integer&amp;gt; charsWithCountMap = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; LinkedHashMap&amp;lt;&amp;gt;();&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;char&lt;/span&gt; c : input.toCharArray()) {&lt;br/&gt;charsWithCountMap.merge(c, &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, Integer::sum);&lt;br/&gt;}&lt;br/&gt;System.out.println(charsWithCountMap);&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有没有很厉害？一行代码就搞定。第一个参数为键，第二个参数为值，第三个参数是一个 BiFunction，意思是，如果键已经存在了，就重新根据 BiFunction 计算新的值。&lt;/p&gt;
&lt;p&gt;如果字符是第一次出现，就赋值为 1；否则，就把之前的值 sum 1。&lt;/p&gt;
&lt;h3 id=&quot;h02&quot;&gt;&lt;span&gt;02、如何反转字符串？&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;如果同学们对 StringBuilder 和 StringBuffer 很熟悉的话，这道题就很简单，直接 &lt;code&gt;reverse()&lt;/code&gt; 就完事，对不对？&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;ReverseAString&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;reverseInputString(&lt;span class=&quot;hljs-string&quot;&gt;&quot;沉默王二&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;reverseInputString&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String input)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;StringBuilder sb = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; StringBuilder(input);&lt;br/&gt;String result = sb.reverse().toString();&lt;br/&gt;System.out.println(result);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs&quot;&gt;二王默沉&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;多说一句，StringBuffer 和 StringBuilder 很相似，前者是同步的，所有 public 方法都加了 &lt;code&gt;synchronized&lt;/code&gt; 关键字，可以在多线程中使用；后者是不同步的，没有 &lt;code&gt;synchronized&lt;/code&gt; 关键字，所以性能更佳，没有并发要求的话，就用 StringBuilder。&lt;/p&gt;
&lt;h3 id=&quot;h03&quot;&gt;&lt;span&gt;03、如何判断一个字符串是前后对称的？&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;什么意思呢？就好像一个字符串，前后一折，是对称的。就像你站在镜子前，看到了一个玉树临风、闭月羞花的自己。&lt;/p&gt;
&lt;pre readability=&quot;6&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;6&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;PalindromeString&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;p&gt;checkPalindromeString(&lt;span class=&quot;hljs-string&quot;&gt;&quot;沉默王二&quot;&lt;/span&gt;);&lt;br/&gt;checkPalindromeString(&lt;span class=&quot;hljs-string&quot;&gt;&quot;沉默王二 二王默沉&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;checkPalindromeString&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String input)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;boolean&lt;/span&gt; result = &lt;span class=&quot;hljs-keyword&quot;&gt;true&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; length = input.length();&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; length / &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;; i++) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (input.charAt(i) != input.charAt(length - i - &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)) {&lt;br/&gt;result = &lt;span class=&quot;hljs-keyword&quot;&gt;false&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;break&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;System.out.println(input + &lt;span class=&quot;hljs-string&quot;&gt;&quot; 对称吗？ &quot;&lt;/span&gt; + result);&lt;/p&gt;&lt;p&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot;&gt;沉默王二 对称吗？ &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;&lt;br/&gt;沉默王二 二王默沉 对称吗？ &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;说一下我的思路：要判断字符串对折后是否对称，很简单，从中间劈开，第一个字符对照最后一个字符，一旦找到不等的那个，就返回 false。&lt;/p&gt;
&lt;p&gt;注意三点：&lt;/p&gt;
&lt;p&gt;1）for 循环的下标从 0 开始，到 &lt;code&gt;length/2&lt;/code&gt; 结束。&lt;/p&gt;
&lt;p&gt;2）下标 i 和 length-i-1 是对称的。&lt;/p&gt;
&lt;p&gt;3）一旦 false 就 break。&lt;/p&gt;
&lt;h3 id=&quot;h04&quot;&gt;&lt;span&gt;04、如何删除所有出现的指定字符？&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;字符串类没有提供 &lt;code&gt;remove()&lt;/code&gt; 方法，但提供了 &lt;code&gt;replaceAll()&lt;/code&gt; 方法，通过将指定的字符替换成空白字符就可以办得到，对吧？&lt;/p&gt;
&lt;pre readability=&quot;5.5&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;5&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;RemoveCharFromString&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;removeCharFromString(&lt;span class=&quot;hljs-string&quot;&gt;&quot;沉默王二&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;'二'&lt;/span&gt;);&lt;br/&gt;removeCharFromString(&lt;span class=&quot;hljs-string&quot;&gt;&quot;chenmowanger&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;'n'&lt;/span&gt;);&lt;p&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;removeCharFromString&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String input, &lt;span class=&quot;hljs-keyword&quot;&gt;char&lt;/span&gt; c)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;String result = input.replaceAll(String.valueOf(c), &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&lt;/span&gt;);&lt;br/&gt;System.out.println(result);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs&quot;&gt;沉默王&lt;br/&gt;chemowager&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h05&quot;&gt;&lt;span&gt;05、如何证明字符串是不可变的？&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;字符串不可变的这个事我曾写过两篇文章，写到最后我都要吐了。但是仍然会有一些同学弄不明白，隔段时间就有人私信我，我就不得不把之前的文章放到收藏夹，问的时候我就把链接发给他。&lt;/p&gt;
&lt;p&gt;之所以造成这个混乱，有很多因素，比如说，Java 到底是值传递还是引用传递？字符串常量池是个什么玩意？&lt;/p&gt;
&lt;p&gt;这次又不得不谈，虽然烦透了，但仍然要证明啊！&lt;/p&gt;
&lt;pre readability=&quot;5&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;4&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;StringImmutabilityTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;String s1 = &lt;span class=&quot;hljs-string&quot;&gt;&quot;沉默王二&quot;&lt;/span&gt;;&lt;br/&gt;String s2 = s1;&lt;br/&gt;System.out.println(s1 == s2);&lt;p&gt;s1 = &lt;span class=&quot;hljs-string&quot;&gt;&quot;沉默王三&quot;&lt;/span&gt;;&lt;br/&gt;System.out.println(s1 == s2);&lt;/p&gt;&lt;p&gt;System.out.println(s2);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot;&gt;&lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;&lt;br/&gt;沉默王二&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;1）&lt;code&gt;String s1 = &quot;沉默王二&quot;&lt;/code&gt;，Java 在字符串常量池中创建“沉默王二”这串字符的对象，并且把地址引用赋值给 s1&lt;/p&gt;
&lt;p&gt;2）&lt;code&gt;String s2 = s1&lt;/code&gt;，s2 和 s1 指向了同一个地址引用——常量池中的那个“沉默王二”。&lt;/p&gt;
&lt;p&gt;所以，此时 s1 == s2 为 true。&lt;/p&gt;
&lt;p&gt;3）&lt;code&gt;s1 = &quot;沉默王三&quot;&lt;/code&gt;，Java 在字符串常量池中创建“沉默王三”这串字符的对象，并且把地址引用赋值给 s1，但 s2 仍然指向的是“沉默王二”那串字符对象的地址引用。&lt;/p&gt;
&lt;p&gt;所以，此时 s1 == s2 为 false，s2 的输出结果为“沉默王二”就证明了字符串是不可变的。&lt;/p&gt;
&lt;h3 id=&quot;h06&quot;&gt;&lt;span&gt;06、如何统计字符串中的单词数？&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;这道题呢？主要针对的是英文字符串的情况。虽然中文字符串中也可以有空白字符，但不存在单词这一说。&lt;/p&gt;
&lt;pre readability=&quot;5.5&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;5&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;CountNumberOfWordsInString&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;countNumberOfWords(&lt;span class=&quot;hljs-string&quot;&gt;&quot;My name is Wanger&quot;&lt;/span&gt;);&lt;br/&gt;countNumberOfWords(&lt;span class=&quot;hljs-string&quot;&gt;&quot;I Love Java Programming&quot;&lt;/span&gt;);&lt;br/&gt;countNumberOfWords(&lt;span class=&quot;hljs-string&quot;&gt;&quot; Java    is  very   important &quot;&lt;/span&gt;);&lt;br/&gt;}&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;countNumberOfWords&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String line)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;String trimmedLine = line.trim();&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; count = trimmedLine.isEmpty() ? &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; : trimmedLine.split(&lt;span class=&quot;hljs-string&quot;&gt;&quot;\\s+&quot;&lt;/span&gt;).length;&lt;/p&gt;&lt;p&gt;System.out.println(count);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs&quot;&gt;4&lt;br/&gt;4&lt;br/&gt;4&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;split()&lt;/code&gt; 方法可以对字符串进行拆分，参数不仅可以是空格，也可以使正则表达式代替的空白字符（多个空格、制表符）；返回的是一个数组，通过 &lt;code&gt;length&lt;/code&gt; 就可以获得单词的个数了。&lt;/p&gt;
&lt;p&gt;如果对 &lt;code&gt;split()&lt;/code&gt; 方法很感兴趣的话，可以查看我之前写的一篇文章，很饱满，很丰富。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/P0HOlgREXqUWIDKgKxr-MA&quot;&gt;咦，拆分个字符串都这么讲究&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;h07&quot;&gt;&lt;span&gt;07、如何检查两个字符串中的字符是相同的？&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;如何理解这道题呢？比如说，字符串“沉默王二”和“沉王二默”就用了同样的字符，对吧？比如说，字符串“沉默王二”和“沉默王三”用的字符就不同，理解了吧？&lt;/p&gt;
&lt;pre readability=&quot;6&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;6&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;CheckSameCharsInString&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;sameCharsStrings(&lt;span class=&quot;hljs-string&quot;&gt;&quot;沉默王二&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;沉王二默&quot;&lt;/span&gt;);&lt;br/&gt;sameCharsStrings(&lt;span class=&quot;hljs-string&quot;&gt;&quot;沉默王二&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;沉默王三&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;sameCharsStrings&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String s1, String s2)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;Set&amp;lt;Character&amp;gt; set1 = s1.chars().mapToObj(c -&amp;gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;char&lt;/span&gt;) c).collect(Collectors.toSet());&lt;br/&gt;System.out.println(set1);&lt;br/&gt;Set&amp;lt;Character&amp;gt; set2 = s2.chars().mapToObj(c -&amp;gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;char&lt;/span&gt;) c).collect(Collectors.toSet());&lt;br/&gt;System.out.println(set2);&lt;br/&gt;System.out.println(set1.equals(set2));&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cs&quot;&gt;[&lt;span class=&quot;hljs-meta&quot;&gt;默, 沉, 王, 二&lt;/span&gt;]&lt;br/&gt;[&lt;span class=&quot;hljs-meta&quot;&gt;默, 沉, 王, 二&lt;/span&gt;]&lt;br/&gt;&lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;&lt;br/&gt;[&lt;span class=&quot;hljs-meta&quot;&gt;默, 沉, 王, 二&lt;/span&gt;]&lt;br/&gt;[&lt;span class=&quot;hljs-meta&quot;&gt;默, 沉, 三, 王&lt;/span&gt;]&lt;br/&gt;&lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码用到了 Stream 流，看起来很陌生，但很好理解，就是把字符串拆成字符，然后收集到 Set 中，Set 是一个不允许有重复元素的集合，所以就把字符串中的不同字符收集起来了。&lt;/p&gt;
&lt;h3 id=&quot;h08&quot;&gt;&lt;span&gt;08、如何判断一个字符串包含了另外一个字符串？&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;这道题有点简单，对吧？上一道还用 Stream 流，这道题就直接送分了？不用怀疑自己，就用字符串类的 &lt;code&gt;contains()&lt;/code&gt; 方法。&lt;/p&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;2&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;StringContainsSubstring&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;String s1 = &lt;span class=&quot;hljs-string&quot;&gt;&quot;沉默王二&quot;&lt;/span&gt;;&lt;br/&gt;String s2 = &lt;span class=&quot;hljs-string&quot;&gt;&quot;沉默&quot;&lt;/span&gt;;&lt;p&gt;System.out.println(s1.contains(s2));&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot;&gt;&lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;contains()&lt;/code&gt; 方法内部其实调用的是 &lt;code&gt;indexOf()&lt;/code&gt; 方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;contains&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(CharSequence s)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; indexOf(s.toString()) &amp;gt;= &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h09&quot;&gt;&lt;span&gt;09、如何在不用第三个变量的情况下交换两个字符串？&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;这道题就有点意思了，对吧？尤其是前提条件，不使用第三个变量。&lt;/p&gt;
&lt;pre readability=&quot;5.5&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;5&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;SwapTwoStrings&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;String s1 = &lt;span class=&quot;hljs-string&quot;&gt;&quot;沉默&quot;&lt;/span&gt;;&lt;br/&gt;String s2 = &lt;span class=&quot;hljs-string&quot;&gt;&quot;王二&quot;&lt;/span&gt;;&lt;p&gt;s1 = s1.concat(s2);&lt;br/&gt;s2 = s1.substring(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;,s1.length()-s2.length());&lt;br/&gt;s1 = s1.substring(s2.length());&lt;/p&gt;&lt;p&gt;System.out.println(s1);&lt;br/&gt;System.out.println(s2);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs&quot;&gt;王二&lt;br/&gt;沉默&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;说一下我的思路：&lt;/p&gt;
&lt;p&gt;1）通过 &lt;code&gt;concat()&lt;/code&gt; 方法把两个字符串拼接到一块。&lt;/p&gt;
&lt;p&gt;2）然后通过 &lt;code&gt;substring()&lt;/code&gt; 方法分别取出第二个字符串和第一个字符串。&lt;/p&gt;
&lt;h3 id=&quot;h10&quot;&gt;&lt;span&gt;10、如何从字符串中找出第一个不重复的字符？&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;来，上个例子来理解一下这道题。比如说字符串“沉默王沉沉默二”，第一个不重复的字符是“王”，对吧？因为“沉”重复了，“默”重复了。&lt;/p&gt;
&lt;pre readability=&quot;9&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;12&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;FindNonRepeatingChar&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;System.out.println(printFirstNonRepeatingChar(&lt;span class=&quot;hljs-string&quot;&gt;&quot;沉默王沉沉默二&quot;&lt;/span&gt;));&lt;br/&gt;System.out.println(printFirstNonRepeatingChar(&lt;span class=&quot;hljs-string&quot;&gt;&quot;沉默王沉&quot;&lt;/span&gt;));&lt;br/&gt;System.out.println(printFirstNonRepeatingChar(&lt;span class=&quot;hljs-string&quot;&gt;&quot;沉沉沉&quot;&lt;/span&gt;));&lt;br/&gt;}&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; Character &lt;span class=&quot;hljs-title&quot;&gt;printFirstNonRepeatingChar&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String string)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;char&lt;/span&gt;[] chars = string.toCharArray();&lt;/p&gt;&lt;p&gt;List&amp;lt;Character&amp;gt; discardedChars = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; chars.length; i++) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;char&lt;/span&gt; c = chars[i];&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (discardedChars.contains(c))&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;continue&lt;/span&gt;;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; j = i + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;; j &amp;lt; chars.length; j++) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (c == chars[j]) {&lt;br/&gt;discardedChars.add(c);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;break&lt;/span&gt;;&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (j == chars.length - &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; c;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs coffeescript&quot;&gt;王&lt;br/&gt;默&lt;br/&gt;&lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;说一下我的思路：&lt;/p&gt;
&lt;p&gt;1）把字符串拆分成字符数组。&lt;/p&gt;
&lt;p&gt;2）声明一个 List，把重复的字符放进去。&lt;/p&gt;
&lt;p&gt;3）外层的 for 循环，从第一个字符开始，如果已经在 List 中，继续下一轮。&lt;/p&gt;
&lt;p&gt;4）嵌套的 for 循环，从第一个字符的下一个字符（&lt;code&gt;j = i + 1&lt;/code&gt;）开始遍历，如果找到和之前字符重复的，就加入到 List 中，跳出内层的循环；如果找到最后（&lt;code&gt;j == chars.length - 1&lt;/code&gt;）也没有找到，就是第一个不重复的字符，对吧？&lt;/p&gt;
&lt;h3 id=&quot;h11&quot;&gt;&lt;span&gt;11、如何检查字符串中只包含数字？&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;有一种很傻的解法，就是用 &lt;code&gt;Long.parseLong(string)&lt;/code&gt; 对字符串强转，如果转不成整形，那肯定不是只包含数字，对吧？&lt;/p&gt;
&lt;p&gt;但这种方法也太不可取了，所以还得换一种巧妙的，就是使用正则表达式。&lt;/p&gt;
&lt;pre readability=&quot;4.5&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;3&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;CheckIfStringContainsDigitsOnly&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;digitsOnlyString(&lt;span class=&quot;hljs-string&quot;&gt;&quot;123 沉默王二&quot;&lt;/span&gt;);&lt;br/&gt;digitsOnlyString(&lt;span class=&quot;hljs-string&quot;&gt;&quot;123&quot;&lt;/span&gt;);&lt;p&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;digitsOnlyString&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String string)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (string.matches(&lt;span class=&quot;hljs-string&quot;&gt;&quot;\\d+&quot;&lt;/span&gt;)) {&lt;br/&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;只包含数字的字符串：&quot;&lt;/span&gt; + string);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs&quot;&gt;只包含数字：123&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h12&quot;&gt;&lt;span&gt;12、如何实现字符串的深度拷贝?&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;由于字符串是不可变的，所以可以直接使用“=”操作符将一个字符串拷贝到另外一个字符串，并且互不影响。&lt;/p&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;2&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;JavaStringCopy&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String args[])&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;String str = &lt;span class=&quot;hljs-string&quot;&gt;&quot;沉默王二&quot;&lt;/span&gt;;&lt;br/&gt;String strCopy = str;&lt;p&gt;str = &lt;span class=&quot;hljs-string&quot;&gt;&quot;沉默王三&quot;&lt;/span&gt;;&lt;br/&gt;System.out.println(strCopy);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs&quot;&gt;沉默王二&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个例子和之前证明字符串是不可变的例子几乎没什么差别，对吧？这的确是因为字符串是不可变的，如果是可变对象的话，深度拷贝就要注意了，最好使用 new 关键字返回新的对象。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; Book &lt;span class=&quot;hljs-title&quot;&gt;getBook&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;Book clone = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Book();&lt;br/&gt;clone.setPrice(&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.book.getPrice());&lt;br/&gt;clone.setName(&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.book.getName());&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; clone;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关于不可变对象，请点击下面的链接查看我之前写了一篇文章。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/wbdV9rV60AwWiiTEBYPP7g&quot;&gt;这次要说不明白immutable类，我就怎么地&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;h&quot;&gt;&lt;span&gt;最后&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;希望这 12 个精致的字符串操作小技巧可以帮助大家巩固一波基础，反正我自己已经重新巩固了一波，很有收获的样子，感觉就像是“一群小精灵在我脑子里跳舞一样”，学它就对了！&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;我是沉默王二，一枚在九朝古都洛阳苟且偷生的程序员。&lt;strong&gt;关注即可提升学习效率，感谢你的三连支持，奥利给🌹&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;注：如果文章有任何问题，欢迎毫不留情地指正。&lt;/p&gt;
&lt;p&gt;如果你觉得文章对你有些帮助，欢迎微信搜索「&lt;strong&gt;沉默王二&lt;/strong&gt;」第一时间阅读，回复关键字「&lt;strong&gt;小白&lt;/strong&gt;」可以免费获取我肝了 4 万+字的 《Java 小白从入门到放肆》2.0 版；本文 &lt;strong&gt;GitHub&lt;/strong&gt; &lt;a href=&quot;https://github.com/itwanger/itwanger.github.io&quot;&gt;github.com/itwanger&lt;/a&gt; 已收录，欢迎 star。&lt;/p&gt;
</description>
<pubDate>Tue, 25 Aug 2020 21:45:00 +0000</pubDate>
<dc:creator>沉默王二</dc:creator>
<og:description>字符串可以说是 Java 中最具有代表性的类了，似乎没有之一哈，这就好像直播界的李佳琪，脱口秀中的李诞，一等一的大哥地位。不得不承认，最近吐槽大会刷多了，脑子里全是那些段子，写文章都有点不由自主，真的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qing-gee/p/13562974.html</dc:identifier>
</item>
<item>
<title>Redis秒杀系统架构设计-微信抢红包 - 陈彦斌</title>
<link>http://www.cnblogs.com/chenyanbin/p/13551352.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenyanbin/p/13551352.html</guid>
<description>&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;前二天&lt;/strong&gt;&lt;/span&gt;我&lt;span&gt;&lt;strong&gt;写&lt;/strong&gt;&lt;/span&gt;了一篇，&lt;span&gt;&lt;strong&gt;Redis高级项目实战&lt;/strong&gt;&lt;/span&gt;(&lt;a href=&quot;https://www.cnblogs.com/chenyanbin/p/13506946.html&quot; target=&quot;_blank&quot;&gt;点我直达&lt;/a&gt;)，&lt;strong&gt;&lt;span&gt;SpringBoot整合Redis附源码&lt;/span&gt;&lt;/strong&gt;(&lt;a href=&quot;https://www.cnblogs.com/chenyanbin/p/13515268.html&quot; target=&quot;_blank&quot;&gt;点我直达&lt;/a&gt;)，&lt;span&gt;&lt;strong&gt;今天&lt;/strong&gt;&lt;/span&gt;我们来&lt;span&gt;&lt;strong&gt;做&lt;/strong&gt;&lt;/span&gt;一下&lt;span&gt;&lt;strong&gt;Redis秒杀&lt;/strong&gt;&lt;/span&gt;系统的设计。当然啦，&lt;span&gt;&lt;strong&gt;Redis基础&lt;/strong&gt;&lt;/span&gt;知识&lt;span&gt;&lt;strong&gt;还不过关的&lt;/strong&gt;&lt;/span&gt;，&lt;span&gt;&lt;strong&gt;先去加强下自身内功&lt;/strong&gt;&lt;/span&gt;，然后在回来看这篇，&lt;span&gt;&lt;strong&gt;Redis基础知识&lt;/strong&gt;&lt;/span&gt;&lt;a href=&quot;https://www.cnblogs.com/chenyanbin/p/12073107.html&quot; target=&quot;_blank&quot;&gt;(点我直达&lt;/a&gt;)。为啥写这个微信抢红包项目呢，公司0202年08月22日，公司周年庆，抢了100多红包🧧，O(∩_∩)O哈哈~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200823234751230-70487411.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;业务流程分析&lt;/h2&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200823231516978-1835079871.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;功能拆解&lt;/h2&gt;
&lt;h3&gt;新建红包&lt;/h3&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;在DB&lt;/strong&gt;&lt;/span&gt;、&lt;strong&gt;&lt;span&gt;Redis&lt;/span&gt;&lt;/strong&gt;分别&lt;span&gt;&lt;strong&gt;新增一条记录&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;抢红包(&lt;span&gt;并发&lt;/span&gt;)&lt;/h3&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;请求Redis&lt;/strong&gt;&lt;/span&gt;，&lt;span&gt;&lt;strong&gt;红包剩余个数&lt;/strong&gt;&lt;/span&gt;，&lt;span&gt;&lt;strong&gt;大于0&lt;/strong&gt;&lt;/span&gt;才可以&lt;span&gt;&lt;strong&gt;拆&lt;/strong&gt;&lt;/span&gt;，&lt;span&gt;&lt;strong&gt;等会0&lt;/strong&gt;&lt;/span&gt;时，提示用户，&lt;span&gt;&lt;strong&gt;红包已抢完&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;拆红包(&lt;span&gt;并发&lt;/span&gt;)&lt;/h3&gt;
&lt;h4&gt;用到技术&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　Redis&lt;/strong&gt;&lt;/span&gt;中数据类型的&lt;span&gt;&lt;strong&gt;String特性&lt;/strong&gt;&lt;/span&gt;的&lt;span&gt;&lt;strong&gt;原子递减&lt;/strong&gt;&lt;span&gt;（&lt;/span&gt;&lt;strong&gt;DECR key&lt;/strong&gt;&lt;span&gt;）&lt;/span&gt;&lt;/span&gt;和&lt;span&gt;&lt;strong&gt;减少指定值&lt;/strong&gt;&lt;span&gt;（&lt;/span&gt;&lt;strong&gt;DECRBY key decrement&lt;/strong&gt;&lt;span&gt;）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;业务&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;请求Redis&lt;/span&gt;&lt;/strong&gt;，当&lt;span&gt;&lt;strong&gt;剩余红包个数大于0&lt;/strong&gt;&lt;/span&gt;，&lt;span&gt;&lt;strong&gt;红包个数&lt;/strong&gt;&lt;/span&gt;原子&lt;span&gt;&lt;strong&gt;递减&lt;/strong&gt;&lt;/span&gt;，随机&lt;span&gt;&lt;strong&gt;获取红包&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;计算金额&lt;/strong&gt;&lt;/span&gt;，当最后一个红包时，最后一个红包金额=总金额-总已抢红包金额&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;更新数据库&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;查看红包记录&lt;/h3&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;查询DB&lt;/strong&gt;&lt;/span&gt;即可&lt;/p&gt;
&lt;h2&gt;数据库表设计&lt;/h2&gt;
&lt;p&gt;红包流水表&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt; `red_packet_info` (
 `id` &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt; AUTO_INCREMENT, 
 `red_packet_id` &lt;/span&gt;&lt;span&gt;bigint&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;红包id，采⽤
timestamp+5位随机数&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, 
 `total_amount` &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;红包总⾦额，单位分&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
 `total_packet` &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;红包总个数&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
 `remaining_amount` &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;剩余红包⾦额，单位
分&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
 `remaining_packet` &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;剩余红包个数&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
 `uid` &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;(&lt;span&gt;20&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;新建红包⽤户的⽤户标识&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
 `create_time` &lt;/span&gt;&lt;span&gt;timestamp&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;创建时间&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
 `update_time` &lt;/span&gt;&lt;span&gt;timestamp&lt;/span&gt; &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;CURRENT_TIMESTAMP&lt;/span&gt; &lt;span&gt;ON&lt;/span&gt; &lt;span&gt;UPDATE&lt;/span&gt;
&lt;span&gt;CURRENT_TIMESTAMP&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;更新时间&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
 &lt;/span&gt;&lt;span&gt;PRIMARY&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt;&lt;span&gt; (`id`)
) ENGINE&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;InnoDB AUTO_INCREMENT&lt;span&gt;=&lt;/span&gt;&lt;span&gt;1&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; CHARSET&lt;span&gt;=&lt;/span&gt;utf8mb4 COMMENT&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;红包信息
表，新建⼀个红包插⼊⼀条记录&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;红包记录表&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt; `red_packet_record` (
 `id` &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt; AUTO_INCREMENT, 
 `amount` &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;抢到红包的⾦额&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
 `nick_name` &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;32&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;抢到红包的⽤户的⽤户
名&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
 `img_url` &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;255&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;抢到红包的⽤户的头像&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
 `uid` &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;(&lt;span&gt;20&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;抢到红包⽤户的⽤户标识&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
 `red_packet_id` &lt;/span&gt;&lt;span&gt;bigint&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;红包id，采⽤
timestamp+5位随机数&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, 
 `create_time` &lt;/span&gt;&lt;span&gt;timestamp&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;创建时间&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
 `update_time` &lt;/span&gt;&lt;span&gt;timestamp&lt;/span&gt; &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;CURRENT_TIMESTAMP&lt;/span&gt; &lt;span&gt;ON&lt;/span&gt; &lt;span&gt;UPDATE&lt;/span&gt;
&lt;span&gt;CURRENT_TIMESTAMP&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;更新时间&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
 &lt;/span&gt;&lt;span&gt;PRIMARY&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt;&lt;span&gt; (`id`)
) ENGINE&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;InnoDB AUTO_INCREMENT&lt;span&gt;=&lt;/span&gt;&lt;span&gt;1&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; CHARSET&lt;span&gt;=&lt;/span&gt;utf8mb4 COMMENT&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;抢红包记
录表，抢⼀个红包插⼊⼀条记录&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200824215520831-273722339.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200824215539597-2123635438.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;发红包API&lt;/h2&gt;
&lt;h3&gt;发红包接口开发&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;新增一条红包记录&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;往mysql&lt;/strong&gt;&lt;/span&gt;里面添&lt;span&gt;&lt;strong&gt;加一条红包记录&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;往redis&lt;/strong&gt;&lt;/span&gt;里面添&lt;span&gt;&lt;strong&gt;加一条红包数量记录&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;往redis&lt;/strong&gt;&lt;/span&gt;里面添&lt;span&gt;&lt;strong&gt;加一条红包金额记录&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200825221041111-1539712425.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　注意，往db中就单纯存入一条记录，Service层和Mapper层，就简单的一条sql语句，主要是提供思路，下面会附案例源码，不要慌&lt;/p&gt;
&lt;h2&gt;抢红包API&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;抢红包&lt;/strong&gt;&lt;/span&gt;功能属于&lt;span&gt;&lt;strong&gt;原子减&lt;/strong&gt;&lt;/span&gt;操作&lt;/li&gt;
&lt;li&gt;当大小小于0时原子减失败&lt;/li&gt;
&lt;li&gt;当&lt;span&gt;&lt;strong&gt;红包个数为0&lt;/strong&gt;&lt;/span&gt;时，&lt;span&gt;&lt;strong&gt;后&lt;/strong&gt;&lt;/span&gt;面&lt;span&gt;&lt;strong&gt;进来&lt;/strong&gt;&lt;/span&gt;的用户&lt;span&gt;&lt;strong&gt;全部抢红包失败&lt;/strong&gt;&lt;/span&gt;，并不会进入拆红包环节&lt;/li&gt;
&lt;li&gt;抢红包功能设计
&lt;ul&gt;&lt;li&gt;将红包ID的请求放入请求队列中，如果发现超过红包的个数，直接返回&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;注意事项
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;抢到红包不一定能拆成功&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt; 抢红包算法拆解&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200825225651119-2111039266.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　通过&lt;span&gt;&lt;strong&gt;上图算法得出&lt;/strong&gt;&lt;/span&gt;，&lt;span&gt;&lt;strong&gt;靠前&lt;/strong&gt;&lt;/span&gt;面的人，&lt;span&gt;&lt;strong&gt;手气最佳几率小&lt;/strong&gt;&lt;/span&gt;，&lt;span&gt;&lt;strong&gt;手气最佳，往往在后面&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;发100元，共10个红包，那么平均值是10元一个，那么发出来的红包金额在0.01~20元之间波动&lt;/li&gt;
&lt;li&gt;当前面4个红包总共被领了30元时，剩下70元，总共6个红包，那么这6个红包的金额在0.01~23.3元之间波动&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;抢红包接口开发&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200826003430520-814368941.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;测试&lt;/h2&gt;
&lt;h3&gt;发红包&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200826003712834-1793224326.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;模拟高并发抢红包(&lt;span&gt;Jmeter压测工具&lt;/span&gt;)&lt;/h3&gt;
&lt;p&gt;　　因为我发了&lt;span&gt;&lt;strong&gt;10个红包&lt;/strong&gt;&lt;/span&gt;，&lt;span&gt;&lt;strong&gt;金额是20000&lt;/strong&gt;&lt;/span&gt;，使用压测工具，&lt;span&gt;&lt;strong&gt;模拟50个请求&lt;/strong&gt;&lt;/span&gt;，&lt;span&gt;&lt;strong&gt;只允许前10个请求能抢到红包&lt;/strong&gt;&lt;/span&gt;，&lt;span&gt;&lt;strong&gt;并且金额等于20000&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200826004251579-174033303.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200826010229396-1071712151.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200826010257741-1322162855.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
链接: https://pan.baidu.com/s/1knmVMKBldVe46cmXqqfGpw  密码: a7o7
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　微信上有个小伙伴刚好要做一个秒杀的系统，催我赶紧把博客更新出来。过2天继续往下更新，布隆过滤器。&lt;/p&gt;

</description>
<pubDate>Tue, 25 Aug 2020 17:17:00 +0000</pubDate>
<dc:creator>陈彦斌</dc:creator>
<og:description>导读 前二天我写了一篇，Redis高级项目实战(点我直达)，SpringBoot整合Redis附源码(点我直达)，今天我们来做一下Redis秒杀系统的设计。当然啦，Redis基础知识还不过关的，先去加</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chenyanbin/p/13551352.html</dc:identifier>
</item>
<item>
<title>消息型中间件之RabbitMQ基础使用 - Linux-1874</title>
<link>http://www.cnblogs.com/qiuhom-1874/p/13561245.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qiuhom-1874/p/13561245.html</guid>
<description>&lt;p&gt;　　1、概念&lt;/p&gt;
&lt;p&gt;　　RabbitMQ是AMQP（高级消息队列协议）协议的实现主要功能用于分布式应用当中的各组件间解耦。在传统C/S架构中，如果客户端发送一个请求消息，服务端必须得在线，有了中间件，客户端不是非得要服务端在线才可发送请求，客户端只需将请求消息发送给中间件，中间件负责存储和转发请求消息，此时如果服务端不在线，依然不妨碍客户端的请求可以发出，而客户端的请求此时有可能还会被正常服务；而对于消息型中间件最核心的组件有3个，分别是exchange（交换器）、binding（绑定器）、queue（队列）；其中交换器的作用是把消息发出一方（简称生产者）发出的消息，通过交换器把消息发送给绑定器，绑定器根据匹配路由规则把消息路由给后端队列，然后订阅者再到对应的队列上取出消息进行消费，通常一个订阅者（消息消费者，或者叫用户也行）对应一个或多个队列；而订阅者与队列之间的信道（传递消息的通道）我们称之为channel（频道）；也就说订阅者可以订阅一个或多个频道，一旦对应频道有消息产生，对应订阅者都会收到；一个消息该如何发送到对应的队列，这取决于我们的路由模式，路由模式通常我们通过绑定器进行定义；也就是说绑定器的主要作用就是用来定义交换器收到消息后该把消息发送到那个给队列；而对于路由模式来讲，它有多种，常见的有direct（点到点的直接路由）、topic（话题型过滤）、fan-out（删除）、headers（基于消息首部过滤）；这些路由模式主要是用来过滤消息的，把符合我们定义的路由规则的消息过滤出来，发送到指定队列，所以我们也可以把路由模式称之为消息过滤器；简单点讲路由规则就是把交换器上的某一类消息绑定一个或多个队列；对于AMQP来讲，除了上面的4中路由模式以外，它还定义一个virtualhost的概念，所谓virtualhost就是虚拟主机，这里的虚拟主机主要是用来应用隔离，一个虚拟主机内部可以有exchange、binding、queue；它相当于一个单独broker，所以虚拟主机它可以将一个物理的broker划分成多个不同应用的broker；&lt;/p&gt;
&lt;p&gt;　　2、RabbitMQ架构&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202008/1503305-20200825205328999-1983132030.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：上图主要描述了生产者把消息通过交换器匹配路由规则（绑定器）把不同类型的消息通过绑定器把消息路由到不同的队列上，然后消费者根据自身订阅的频道，到不同频道对应的队列上取出消息进行消费的一个过程；&lt;/p&gt;
&lt;p&gt;　　3、RabbitMQ的安装配置&lt;/p&gt;
&lt;p&gt;　　在centos7上rabbitmq的安装非常简单，我们只需要配置好epel源，然后yum安装即可；&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node1 ~]# yum repolist
已加载插件：fastestmirror, langpacks
Loading mirror speeds from cached hostfile
 * base: mirrors.aliyun.com
 * extras: mirrors.aliyun.com
 * updates: mirrors.aliyun.com
源标识                                       源名称                                                              状态
!base/7/x86_64                               CentOS-7 - Base - mirrors.aliyun.com                                10,070
!docker-ce-stable/x86_64                     Docker CE Stable - x86_64                                               79
!epel/x86_64                                 Extra Packages for Enterprise Linux 7 - x86_64                      13,426
!extras/7/x86_64                             CentOS-7 - Extras - mirrors.aliyun.com                                 413
!updates/7/x86_64                            CentOS-7 - Updates - mirrors.aliyun.com                              1,112
repolist: 25,100
[root@node1 ~]# yum install rabbitmq-server
已加载插件：fastestmirror, langpacks
base                                                                                            | 3.6 kB  00:00:00     
docker-ce-stable                                                                                | 3.5 kB  00:00:00     
epel                                                                                            | 4.7 kB  00:00:00     
extras                                                                                          | 2.9 kB  00:00:00     
updates                                                                                         | 2.9 kB  00:00:00     
(1/2): epel/x86_64/updateinfo                                                                   | 1.0 MB  00:00:00     
(2/2): epel/x86_64/primary_db                                                                   | 6.9 MB  00:00:01     
Loading mirror speeds from cached hostfile
 * base: mirrors.aliyun.com
 * extras: mirrors.aliyun.com
 * updates: mirrors.aliyun.com
正在解决依赖关系
--&amp;gt; 正在检查事务
---&amp;gt; 软件包 rabbitmq-server.noarch.0.3.3.5-34.el7 将被 安装
--&amp;gt; 正在处理依赖关系 erlang-erts &amp;gt;= R12B-3，它被软件包 rabbitmq-server-3.3.5-34.el7.noarch 需要
……省略部分内容……
已安装:
  rabbitmq-server.noarch 0:3.3.5-34.el7                                                                                

作为依赖被安装:
  erlang-asn1.x86_64 0:R16B-03.18.el7                      erlang-compiler.x86_64 0:R16B-03.18.el7                    
  erlang-crypto.x86_64 0:R16B-03.18.el7                    erlang-erts.x86_64 0:R16B-03.18.el7                        
  erlang-hipe.x86_64 0:R16B-03.18.el7                      erlang-inets.x86_64 0:R16B-03.18.el7                       
  erlang-kernel.x86_64 0:R16B-03.18.el7                    erlang-mnesia.x86_64 0:R16B-03.18.el7                      
  erlang-os_mon.x86_64 0:R16B-03.18.el7                    erlang-otp_mibs.x86_64 0:R16B-03.18.el7                    
  erlang-public_key.x86_64 0:R16B-03.18.el7                erlang-runtime_tools.x86_64 0:R16B-03.18.el7               
  erlang-sasl.x86_64 0:R16B-03.18.el7                      erlang-sd_notify.x86_64 0:0.1-1.el7                        
  erlang-snmp.x86_64 0:R16B-03.18.el7                      erlang-ssl.x86_64 0:R16B-03.18.el7                         
  erlang-stdlib.x86_64 0:R16B-03.18.el7                    erlang-syntax_tools.x86_64 0:R16B-03.18.el7                
  erlang-tools.x86_64 0:R16B-03.18.el7                     erlang-xmerl.x86_64 0:R16B-03.18.el7                       

完毕！
[root@node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：rabbitmq是erlang语言研发，所以安装rabbitmq-server这个包，它会依赖很多erlang包，而这些包都来自epel仓库，所以安装之前一定要先配置好epel源；&lt;/p&gt;
&lt;p&gt;　　查看rabbitmq-server安装生成了哪些文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node1 ~]# rpm -ql rabbitmq-server
/etc/logrotate.d/rabbitmq-server
/etc/rabbitmq
/etc/rabbitmq/rabbitmq.config
/usr/lib/ocf/resource.d/rabbitmq/rabbitmq-server
/usr/lib/rabbitmq/bin
/usr/lib/rabbitmq/bin/rabbitmq-defaults
/usr/lib/rabbitmq/bin/rabbitmq-env
/usr/lib/rabbitmq/bin/rabbitmq-plugins
/usr/lib/rabbitmq/bin/rabbitmq-server
/usr/lib/rabbitmq/bin/rabbitmqctl
/usr/lib/rabbitmq/lib/rabbitmq_server-3.3.5
/usr/lib/rabbitmq/lib/rabbitmq_server-3.3.5/ebin
/usr/lib/rabbitmq/lib/rabbitmq_server-3.3.5/ebin/app_utils.beam
/usr/lib/rabbitmq/lib/rabbitmq_server-3.3.5/ebin/background_gc.beam
/usr/lib/rabbitmq/lib/rabbitmq_server-3.3.5/ebin/credit_flow.beam
/usr/lib/rabbitmq/lib/rabbitmq_server-3.3.5/ebin/delegate.beam
/usr/lib/rabbitmq/lib/rabbitmq_server-3.3.5/ebin/delegate_sup.beam
……省略部分内容……
/usr/lib/rabbitmq/lib/rabbitmq_server-3.3.5/sbin
/usr/lib/rabbitmq/lib/rabbitmq_server-3.3.5/sbin/rabbitmq-defaults
/usr/lib/rabbitmq/lib/rabbitmq_server-3.3.5/sbin/rabbitmq-env
/usr/lib/rabbitmq/lib/rabbitmq_server-3.3.5/sbin/rabbitmq-plugins
/usr/lib/rabbitmq/lib/rabbitmq_server-3.3.5/sbin/rabbitmq-server
/usr/lib/rabbitmq/lib/rabbitmq_server-3.3.5/sbin/rabbitmqctl
/usr/lib/systemd/system/rabbitmq-server.service
/usr/lib/tmpfiles.d/rabbitmq-server.conf
/usr/sbin/rabbitmq-plugins
/usr/sbin/rabbitmq-server
/usr/sbin/rabbitmqctl
……省略部分内容……
/var/log/rabbitmq
/var/run/rabbitmq
[root@node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：/usr/sbin/rabbitmqctl 这个工具是命令行工具，主要用来管理rabbitmq；/usr/sbin/rabbitmq-plugins用来管理rabbitmq插件的命令行工具；/usr/sbin/rabbitmq-server服务器二进制主程序；/usr/lib/systemd/system/rabbitmq-server.service这个文件是它的基于systemd启动的unit file；/usr/lib/rabbitmq/bin/rabbitmq-defaults这个文件用于定义默认环境变量配置；/var/log/rabbitmq用于存放rabbitmq日志目录；/etc/rabbitmq/rabbitmq.config这个是rabbitmq的主配置文件，主要定义个组件访问权限，资源限制，插件及集群相关配置；rabbitmq的配置方式分3中，第一种是环境变量的方式，该方式主要用来定义网络参数以及配置文件路径相关配置；其次是配置文件的方式，配置文件主要定义服务器各组件间的访问权限，资源限制，插件以及集群相关配置；最后一种是运行时参数，这种方式主要用于定义rabbitmq集群的运行时参数；&lt;/p&gt;
&lt;p&gt;　　比较常用的环境变量&lt;/p&gt;
&lt;p&gt;　　　　RABBITMQ_BASE：用来指定rabbitmq的安装目录，这个目录主要存放rabbitmq数据库和日志相关文件。（一般用于windows,类unix上不常用）&lt;/p&gt;
&lt;p&gt;　　　　RABBITMQ_CONFIG_FILE：用于指定配置文件路径；&lt;/p&gt;
&lt;p&gt;　　　　RABBITMQ_LOGS：用于单独指定日志文件；&lt;/p&gt;
&lt;p&gt;　　　　RABBITMQ_NODE_IP_ADDRESS：用于指定节点监听的ip地址；&lt;/p&gt;
&lt;p&gt;　　　　RABBITMQ_NODE_PORT：用于指定节点监听的端口；&lt;/p&gt;
&lt;p&gt;　　　　RABBITMQ_NODE_NAME：用于指定节点名称；&lt;/p&gt;
&lt;p&gt;　　　　RABBITMQ_PLUGINS_DIR：用于指定插件目录；&lt;/p&gt;
&lt;p&gt;　　rabbitmq默认配置文件相关变量说明&lt;/p&gt;
&lt;p&gt;　　　　auth_mechanisms：用于定义rabbitmq的认证机制；&lt;/p&gt;
&lt;p&gt;　　　　default_user：定义默认用户；默认是guest；&lt;/p&gt;
&lt;p&gt;　　　　default_pass：定义默认用户的默认密码；默认是guest；&lt;/p&gt;
&lt;p&gt;　　　　default_premission：定义默认用户的默认权限；默认是&quot;.*&quot; &quot;.*&quot; &quot;.*&quot;；&lt;/p&gt;
&lt;p&gt;　　　　default_user_tags：定义默认用户的标签，默认是administrator；&lt;/p&gt;
&lt;p&gt;　　　　default_vhost：定义默认虚拟主机；默认是“/”；&lt;/p&gt;
&lt;p&gt;　　　　disk_free_limit：定义磁盘最少预留空间；默认50M；&lt;/p&gt;
&lt;p&gt;　　　　hearbeat：定义检测各组件存活的消息时长（心跳值）；默认600秒；&lt;/p&gt;
&lt;p&gt;　　　　hipe_compile：用于指定是否使用hipe编译器编译程序；默认是true，表示使用hipe编译器；&lt;/p&gt;
&lt;p&gt;　　　　log_levels：用于指定日志级别，这里的日志级别只有四种，分别是none,error,warning,info；&lt;/p&gt;
&lt;p&gt;　　　　tcp_listeners：定义监听的地址和端口；默认是本机的所有地址的5672；&lt;/p&gt;
&lt;p&gt;　　　　ssl_listeners：定义基于ssl协议通信监听的地址和端口；默认是本机的所有地址的5672；&lt;/p&gt;
&lt;p&gt;　　　　vm_memory_high_watermark：定义内存的高水位标记，所谓高水位标记，就是用来指定内存的最少空闲内存空间；&lt;/p&gt;
&lt;p&gt;　　启动rabbitmq-server&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202008/1503305-20200825220811271-2097858506.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：以默认配置文件启动rabbitmq，它会监听5672和25672，25672是用来集群通信的端口；5672是rabbitmq的管理接口；除了这两个端口，如果开启了rabbitmq-management插件，它还会监听15672；rabbitmq-management这个插件主要提供了web图形化管理界面；&lt;/p&gt;
&lt;p&gt;　　4、rabbitmqctl使用&lt;/p&gt;
&lt;p&gt;　　rabbitmqctl帮助信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;109&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node1 ~]# rabbitmqctl -h
Error: could not recognise command
Usage:
rabbitmqctl [-n &amp;lt;node&amp;gt;] [-q] &amp;lt;command&amp;gt; [&amp;lt;command options&amp;gt;] 

Options:
    -n node
    -q

Default node is &quot;rabbit@server&quot;, where server is the local host. On a host 
named &quot;server.example.com&quot;, the node name of the RabbitMQ Erlang node will 
usually be rabbit@server (unless RABBITMQ_NODENAME has been set to some 
non-default value at broker startup time). The output of hostname -s is usually 
the correct suffix to use after the &quot;@&quot; sign. See rabbitmq-server(1) for 
details of configuring the RabbitMQ broker.

Quiet output mode is selected with the &quot;-q&quot; flag. Informational messages are 
suppressed when quiet mode is in effect.

Commands:
    stop [&amp;lt;pid_file&amp;gt;]
    stop_app
    start_app
    wait &amp;lt;pid_file&amp;gt;
    reset
    force_reset
    rotate_logs &amp;lt;suffix&amp;gt;

    join_cluster &amp;lt;clusternode&amp;gt; [--ram]
    cluster_status
    change_cluster_node_type disc | ram
    forget_cluster_node [--offline]
    update_cluster_nodes clusternode
    sync_queue queue
    cancel_sync_queue queue
    set_cluster_name name

    add_user &amp;lt;username&amp;gt; &amp;lt;password&amp;gt;
    delete_user &amp;lt;username&amp;gt;
    change_password &amp;lt;username&amp;gt; &amp;lt;newpassword&amp;gt;
    clear_password &amp;lt;username&amp;gt;
    set_user_tags &amp;lt;username&amp;gt; &amp;lt;tag&amp;gt; ...
    list_users

    add_vhost &amp;lt;vhostpath&amp;gt;
    delete_vhost &amp;lt;vhostpath&amp;gt;
    list_vhosts [&amp;lt;vhostinfoitem&amp;gt; ...]
    set_permissions [-p &amp;lt;vhostpath&amp;gt;] &amp;lt;user&amp;gt; &amp;lt;conf&amp;gt; &amp;lt;write&amp;gt; &amp;lt;read&amp;gt;
    clear_permissions [-p &amp;lt;vhostpath&amp;gt;] &amp;lt;username&amp;gt;
    list_permissions [-p &amp;lt;vhostpath&amp;gt;]
    list_user_permissions &amp;lt;username&amp;gt;

    set_parameter [-p &amp;lt;vhostpath&amp;gt;] &amp;lt;component_name&amp;gt; &amp;lt;name&amp;gt; &amp;lt;value&amp;gt;
    clear_parameter [-p &amp;lt;vhostpath&amp;gt;] &amp;lt;component_name&amp;gt; &amp;lt;key&amp;gt;
    list_parameters [-p &amp;lt;vhostpath&amp;gt;]

    set_policy [-p &amp;lt;vhostpath&amp;gt;] [--priority &amp;lt;priority&amp;gt;] [--apply-to &amp;lt;apply-to&amp;gt;] 
&amp;lt;name&amp;gt; &amp;lt;pattern&amp;gt;  &amp;lt;definition&amp;gt;
    clear_policy [-p &amp;lt;vhostpath&amp;gt;] &amp;lt;name&amp;gt;
    list_policies [-p &amp;lt;vhostpath&amp;gt;]

    list_queues [-p &amp;lt;vhostpath&amp;gt;] [&amp;lt;queueinfoitem&amp;gt; ...]
    list_exchanges [-p &amp;lt;vhostpath&amp;gt;] [&amp;lt;exchangeinfoitem&amp;gt; ...]
    list_bindings [-p &amp;lt;vhostpath&amp;gt;] [&amp;lt;bindinginfoitem&amp;gt; ...]
    list_connections [&amp;lt;connectioninfoitem&amp;gt; ...]
    list_channels [&amp;lt;channelinfoitem&amp;gt; ...]
    list_consumers [-p &amp;lt;vhostpath&amp;gt;]
    status
    environment
    report
    eval &amp;lt;expr&amp;gt;

    close_connection &amp;lt;connectionpid&amp;gt; &amp;lt;explanation&amp;gt;
    trace_on [-p &amp;lt;vhost&amp;gt;]
    trace_off [-p &amp;lt;vhost&amp;gt;]
    set_vm_memory_high_watermark &amp;lt;fraction&amp;gt;

&amp;lt;vhostinfoitem&amp;gt; must be a member of the list [name, tracing].

The list_queues, list_exchanges and list_bindings commands accept an optional 
virtual host parameter for which to display results. The default value is &quot;/&quot;.

&amp;lt;queueinfoitem&amp;gt; must be a member of the list [name, durable, auto_delete, 
arguments, policy, pid, owner_pid, exclusive_consumer_pid, 
exclusive_consumer_tag, messages_ready, messages_unacknowledged, messages, 
consumers, consumer_utilisation, memory, slave_pids, synchronised_slave_pids, 
status].

&amp;lt;exchangeinfoitem&amp;gt; must be a member of the list [name, type, durable, 
auto_delete, internal, arguments, policy].

&amp;lt;bindinginfoitem&amp;gt; must be a member of the list [source_name, source_kind, 
destination_name, destination_kind, routing_key, arguments].

&amp;lt;connectioninfoitem&amp;gt; must be a member of the list [pid, name, port, host, 
peer_port, peer_host, ssl, ssl_protocol, ssl_key_exchange, ssl_cipher, 
ssl_hash, peer_cert_subject, peer_cert_issuer, peer_cert_validity, state, 
channels, protocol, auth_mechanism, user, vhost, timeout, frame_max, 
channel_max, client_properties, recv_oct, recv_cnt, send_oct, send_cnt, 
send_pend].

&amp;lt;channelinfoitem&amp;gt; must be a member of the list [pid, connection, name, number, 
user, vhost, transactional, confirm, consumer_count, messages_unacknowledged, 
messages_uncommitted, acks_uncommitted, messages_unconfirmed, prefetch_count, 
global_prefetch_count].


[root@node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：从上面的帮助信息可以了解到rabbitmqctl这个工具有很多子命令；主要有对应用到管理相关子命令，对虚拟主机相关管理的，权限，用户，集群，策略等等；&lt;/p&gt;
&lt;p&gt;　　stop [&amp;lt;pid_file&amp;gt;]：停止rabbitmq-server；&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node1 ~]# rabbitmqctl stop
Stopping and halting node rabbit@node1 ...
...done.
[root@node1 ~]# ss -tnl
State       Recv-Q Send-Q              Local Address:Port                             Peer Address:Port              
LISTEN      0      5                   192.168.122.1:53                                          *:*                  
LISTEN      0      128                             *:22                                          *:*                  
LISTEN      0      128                     127.0.0.1:631                                         *:*                  
LISTEN      0      100                     127.0.0.1:25                                          *:*                  
LISTEN      0      100                     127.0.0.1:64667                                       *:*                  
LISTEN      0      128                             *:8000                                        *:*                  
LISTEN      0      128                             *:8001                                        *:*                  
LISTEN      0      5                       127.0.0.1:8010                                        *:*                  
LISTEN      0      128                             *:111                                         *:*                  
LISTEN      0      128                             *:80                                          *:*                  
LISTEN      0      128                            :::22                                         :::*                  
LISTEN      0      128                           ::1:631                                        :::*                  
LISTEN      0      100                           ::1:25                                         :::*                  
LISTEN      0      128                            :::111                                        :::*                  
LISTEN      0      128                            :::80                                         :::*                  
[root@node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：rabbitmqctl stop 就相当于把rabbitmq服务给杀死，停止服务；&lt;/p&gt;
&lt;p&gt;　　stop_app：停止rabbitmq-server上的所有应用；&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;184&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node1 ~]# rabbitmqctl status   
Status of node rabbit@node1 ...
[{pid,18223},
 {running_applications,[{rabbit,&quot;RabbitMQ&quot;,&quot;3.3.5&quot;},
                        {os_mon,&quot;CPO  CXC 138 46&quot;,&quot;2.2.14&quot;},
                        {mnesia,&quot;MNESIA  CXC 138 12&quot;,&quot;4.11&quot;},
                        {xmerl,&quot;XML parser&quot;,&quot;1.3.6&quot;},
                        {sasl,&quot;SASL  CXC 138 11&quot;,&quot;2.3.4&quot;},
                        {stdlib,&quot;ERTS  CXC 138 10&quot;,&quot;1.19.4&quot;},
                        {kernel,&quot;ERTS  CXC 138 10&quot;,&quot;2.16.4&quot;}]},
 {os,{unix,linux}},
 {erlang_version,&quot;Erlang R16B03-1 (erts-5.10.4) [source] [64-bit] [smp:4:4] [async-threads:30] [hipe] [kernel-poll:true]\n&quot;},
 {memory,[{total,36262168},
          {connection_procs,2800},
          {queue_procs,5600},
          {plugins,0},
          {other_proc,13729216},
          {mnesia,60144},
          {mgmt_db,0},
          {msg_index,21880},
          {other_ets,756824},
          {binary,19048},
          {code,16707498},
          {atom,602729},
          {other_system,4356429}]},
 {alarms,[]},
 {listeners,[{clustering,25672,&quot;::&quot;},{amqp,5672,&quot;::&quot;}]},
 {vm_memory_high_watermark,0.4},
 {vm_memory_limit,1581588480},
 {disk_free_limit,50000000},
 {disk_free,39834275840},
 {file_descriptors,[{total_limit,924},
                    {total_used,3},
                    {sockets_limit,829},
                    {sockets_used,1}]},
 {processes,[{limit,1048576},{used,127}]},
 {run_queue,0},
 {uptime,367}]
...done.
[root@node1 ~]# rabbitmqctl stop_app
Stopping node rabbit@node1 ...
...done.
[root@node1 ~]# rabbitmqctl status  
Status of node rabbit@node1 ...
[{pid,18223},
 {running_applications,[{xmerl,&quot;XML parser&quot;,&quot;1.3.6&quot;},
                        {sasl,&quot;SASL  CXC 138 11&quot;,&quot;2.3.4&quot;},
                        {stdlib,&quot;ERTS  CXC 138 10&quot;,&quot;1.19.4&quot;},
                        {kernel,&quot;ERTS  CXC 138 10&quot;,&quot;2.16.4&quot;}]},
 {os,{unix,linux}},
 {erlang_version,&quot;Erlang R16B03-1 (erts-5.10.4) [source] [64-bit] [smp:4:4] [async-threads:30] [hipe] [kernel-poll:true]\n&quot;},
 {memory,[{total,35566624},
          {connection_procs,0},
          {queue_procs,0},
          {plugins,0},
          {other_proc,13300856},
          {mnesia,0},
          {mgmt_db,0},
          {msg_index,0},
          {other_ets,607888},
          {binary,12600},
          {code,16707498},
          {atom,602729},
          {other_system,4335053}]},
 {alarms,[]},
 {listeners,[]},
 {processes,[{limit,1048576},{used,46}]},
 {run_queue,0},
 {uptime,384}]
...done.
[root@node1 ~]# ss -tnl
State       Recv-Q Send-Q              Local Address:Port                             Peer Address:Port              
LISTEN      0      5                   192.168.122.1:53                                          *:*                  
LISTEN      0      128                             *:22                                          *:*                  
LISTEN      0      128                     127.0.0.1:631                                         *:*                  
LISTEN      0      100                     127.0.0.1:25                                          *:*                  
LISTEN      0      100                     127.0.0.1:64667                                       *:*                  
LISTEN      0      128                             *:8000                                        *:*                  
LISTEN      0      128                             *:8001                                        *:*                  
LISTEN      0      128                             *:25672                                       *:*                  
LISTEN      0      5                       127.0.0.1:8010                                        *:*                  
LISTEN      0      128                             *:111                                         *:*                  
LISTEN      0      128                             *:80                                          *:*                  
LISTEN      0      128                             *:4369                                        *:*                  
LISTEN      0      128                            :::22                                         :::*                  
LISTEN      0      128                           ::1:631                                        :::*                  
LISTEN      0      100                           ::1:25                                         :::*                  
LISTEN      0      128                            :::111                                        :::*                  
LISTEN      0      128                            :::80                                         :::*                  
LISTEN      0      128                            :::4369                                       :::*                  
[root@node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：rabbitmqctl stop_app这个命令只是停止rabbitmq上的应用，而非停止rabbitmq服务；所以监听的端口信息都还在；rabbitmqctl status是查看rabbitmq的状态信息；&lt;/p&gt;
&lt;p&gt;　　start_app：启动已有应用；&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;184&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node1 ~]# rabbitmqctl status
Status of node rabbit@node1 ...
[{pid,18223},
 {running_applications,[{xmerl,&quot;XML parser&quot;,&quot;1.3.6&quot;},
                        {sasl,&quot;SASL  CXC 138 11&quot;,&quot;2.3.4&quot;},
                        {stdlib,&quot;ERTS  CXC 138 10&quot;,&quot;1.19.4&quot;},
                        {kernel,&quot;ERTS  CXC 138 10&quot;,&quot;2.16.4&quot;}]},
 {os,{unix,linux}},
 {erlang_version,&quot;Erlang R16B03-1 (erts-5.10.4) [source] [64-bit] [smp:4:4] [async-threads:30] [hipe] [kernel-poll:true]\n&quot;},
 {memory,[{total,35564488},
          {connection_procs,0},
          {queue_procs,0},
          {plugins,0},
          {other_proc,13299600},
          {mnesia,0},
          {mgmt_db,0},
          {msg_index,0},
          {other_ets,607888},
          {binary,12600},
          {code,16707498},
          {atom,602729},
          {other_system,4334173}]},
 {alarms,[]},
 {listeners,[]},
 {processes,[{limit,1048576},{used,46}]},
 {run_queue,0},
 {uptime,495}]
...done.
[root@node1 ~]# rabbitmqctl start_app
Starting node rabbit@node1 ...
...done.
[root@node1 ~]# rabbitmqctl status   
Status of node rabbit@node1 ...
[{pid,18223},
 {running_applications,[{rabbit,&quot;RabbitMQ&quot;,&quot;3.3.5&quot;},
                        {os_mon,&quot;CPO  CXC 138 46&quot;,&quot;2.2.14&quot;},
                        {mnesia,&quot;MNESIA  CXC 138 12&quot;,&quot;4.11&quot;},
                        {xmerl,&quot;XML parser&quot;,&quot;1.3.6&quot;},
                        {sasl,&quot;SASL  CXC 138 11&quot;,&quot;2.3.4&quot;},
                        {stdlib,&quot;ERTS  CXC 138 10&quot;,&quot;1.19.4&quot;},
                        {kernel,&quot;ERTS  CXC 138 10&quot;,&quot;2.16.4&quot;}]},
 {os,{unix,linux}},
 {erlang_version,&quot;Erlang R16B03-1 (erts-5.10.4) [source] [64-bit] [smp:4:4] [async-threads:30] [hipe] [kernel-poll:true]\n&quot;},
 {memory,[{total,36211968},
          {connection_procs,2800},
          {queue_procs,5600},
          {plugins,0},
          {other_proc,13678784},
          {mnesia,60144},
          {mgmt_db,0},
          {msg_index,21928},
          {other_ets,756792},
          {binary,19048},
          {code,16707530},
          {atom,602729},
          {other_system,4356613}]},
 {alarms,[]},
 {listeners,[{clustering,25672,&quot;::&quot;},{amqp,5672,&quot;::&quot;}]},
 {vm_memory_high_watermark,0.4},
 {vm_memory_limit,1581588480},
 {disk_free_limit,50000000},
 {disk_free,39833972736},
 {file_descriptors,[{total_limit,924},
                    {total_used,3},
                    {sockets_limit,829},
                    {sockets_used,1}]},
 {processes,[{limit,1048576},{used,127}]},
 {run_queue,0},
 {uptime,513}]
...done.
[root@node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到application中多了mnesia，rabbit，os_mon这3个app的信息；&lt;/p&gt;
&lt;p&gt;　　reset：重置；&lt;/p&gt;
&lt;p&gt;　　force_reset：强制重置；&lt;/p&gt;
&lt;p&gt;　　用户管理相关子命令&lt;/p&gt;
&lt;p&gt;　　　　list_users：查看用户列表；&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node1 ~]# rabbitmqctl list_users
Listing users ...
guest   [administrator]
...done.
[root@node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：默认只有grest用户，这个用户的标签是administrator，表示这是一个管理员；&lt;/p&gt;
&lt;p&gt;　　　　add_user &amp;lt;username&amp;gt; &amp;lt;password&amp;gt;：添加用户；&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node1 ~]# rabbitmqctl add_user qiuhom test
Creating user &quot;qiuhom&quot; ...
...done.
[root@node1 ~]# rabbitmqctl list_users          
Listing users ...
guest   [administrator]
qiuhom  []
...done.
[root@node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：添加用户必须指定用户名和密码；默认添加到用户都是普通用户，就是没有任何标签的用户；&lt;/p&gt;
&lt;p&gt;　　　　delete_user &amp;lt;username&amp;gt;：删除指定用户；&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node1 ~]# rabbitmqctl delete_user qiuhom
Deleting user &quot;qiuhom&quot; ...
...done.
[root@node1 ~]# rabbitmqctl list_users        
Listing users ...
guest   [administrator]
...done.
[root@node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：删除用户只需指定用户名即可；&lt;/p&gt;
&lt;p&gt;　　　　change_password &amp;lt;username&amp;gt; &amp;lt;newpassword&amp;gt;：修改指定用户密码；&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node1 ~]# rabbitmqctl change_password guest admin
Changing password for user &quot;guest&quot; ...
...done.
[root@node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：以上表示修改guest用户的命名为admin；如果我们开启了web管理界面就可以来测试guest用户的密码，如果使用admin能够登录到管理界面说明密码修改成功了，不能说明没有修改成功，guest用户的默认密码是guest；&lt;/p&gt;
&lt;p&gt;　　验证：开启rabbitmq-management插件，看看对应guest用户的密码是否更改了？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node1 ~]# rabbitmq-plugins list
[ ] amqp_client                       3.3.5
[ ] cowboy                            0.5.0-rmq3.3.5-git4b93c2d
[ ] eldap                             3.3.5-gite309de4
[ ] mochiweb                          2.7.0-rmq3.3.5-git680dba8
[ ] rabbitmq_amqp1_0                  3.3.5
[ ] rabbitmq_auth_backend_ldap        3.3.5
[ ] rabbitmq_auth_mechanism_ssl       3.3.5
[ ] rabbitmq_consistent_hash_exchange 3.3.5
[ ] rabbitmq_federation               3.3.5
[ ] rabbitmq_federation_management    3.3.5
[ ] rabbitmq_management               3.3.5
[ ] rabbitmq_management_agent         3.3.5
[ ] rabbitmq_management_visualiser    3.3.5
[ ] rabbitmq_mqtt                     3.3.5
[ ] rabbitmq_shovel                   3.3.5
[ ] rabbitmq_shovel_management        3.3.5
[ ] rabbitmq_stomp                    3.3.5
[ ] rabbitmq_test                     3.3.5
[ ] rabbitmq_tracing                  3.3.5
[ ] rabbitmq_web_dispatch             3.3.5
[ ] rabbitmq_web_stomp                3.3.5
[ ] rabbitmq_web_stomp_examples       3.3.5
[ ] sockjs                            0.3.4-rmq3.3.5-git3132eb9
[ ] webmachine                        1.10.3-rmq3.3.5-gite9359c7
[root@node1 ~]# rabbitmq-plugins enable rabbitmq_management
The following plugins have been enabled:
  mochiweb
  webmachine
  rabbitmq_web_dispatch
  amqp_client
  rabbitmq_management_agent
  rabbitmq_management
Plugin configuration has changed. Restart RabbitMQ for changes to take effect.
[root@node1 ~]# rabbitmq-plugins list
[e] amqp_client                       3.3.5
[ ] cowboy                            0.5.0-rmq3.3.5-git4b93c2d
[ ] eldap                             3.3.5-gite309de4
[e] mochiweb                          2.7.0-rmq3.3.5-git680dba8
[ ] rabbitmq_amqp1_0                  3.3.5
[ ] rabbitmq_auth_backend_ldap        3.3.5
[ ] rabbitmq_auth_mechanism_ssl       3.3.5
[ ] rabbitmq_consistent_hash_exchange 3.3.5
[ ] rabbitmq_federation               3.3.5
[ ] rabbitmq_federation_management    3.3.5
[E] rabbitmq_management               3.3.5
[e] rabbitmq_management_agent         3.3.5
[ ] rabbitmq_management_visualiser    3.3.5
[ ] rabbitmq_mqtt                     3.3.5
[ ] rabbitmq_shovel                   3.3.5
[ ] rabbitmq_shovel_management        3.3.5
[ ] rabbitmq_stomp                    3.3.5
[ ] rabbitmq_test                     3.3.5
[ ] rabbitmq_tracing                  3.3.5
[e] rabbitmq_web_dispatch             3.3.5
[ ] rabbitmq_web_stomp                3.3.5
[ ] rabbitmq_web_stomp_examples       3.3.5
[ ] sockjs                            0.3.4-rmq3.3.5-git3132eb9
[e] webmachine                        1.10.3-rmq3.3.5-gite9359c7
[root@node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：启用插件需要用rabbitmq-plugins命令，enable表示启用指定插件，disable表示禁用指定插件，list表示列出插件列表；其中列出插件列表前边中括号中的大写E表示手动开启的插件，小写e表示手动开启插件依赖的插件，自动开启的；&lt;/p&gt;
&lt;p&gt;　　重启rabbitmq-server服务&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202008/1503305-20200825224925872-1063449355.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：启用了插件，必须要重启服务才能够正常使用插件，从上的信息可以看到我们启用了rabbitmq-mangement插件，重启rabbitmq-server服务后，对应的15672端口就处于监听状态了；&lt;/p&gt;
&lt;p&gt;　　登录宿主机的15672端口，访问web管理界面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202008/1503305-20200825225435378-987215212.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202008/1503305-20200825225518533-1689472879.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：用guest用户使用admin密码是能够登录到管理界面，说明我们更改密码成功了；其实很多命令行能够管理的，我们都可以基于这个web管理界面进行管理；&lt;/p&gt;
&lt;p&gt;　　　　set_user_tags &amp;lt;username&amp;gt; &amp;lt;tag&amp;gt; ...：设置指定用户的标签；&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node1 ~]# rabbitmqctl add_user qiuhom test
Creating user &quot;qiuhom&quot; ...
...done.
[root@node1 ~]# rabbitmqctl list_users
Listing users ...
guest   [administrator]
qiuhom  []
...done.
[root@node1 ~]# rabbitmqctl set_user_tags qiuhom administrator
Setting tags for user &quot;qiuhom&quot; to [administrator] ...
...done.
[root@node1 ~]# rabbitmqctl list_users
Listing users ...
guest   [administrator]
qiuhom  [administrator]
...done.
[root@node1 ~]# rabbitmqctl set_user_tags qiuhom 
Setting tags for user &quot;qiuhom&quot; to [] ...
...done.
[root@node1 ~]# rabbitmqctl list_users           
Listing users ...
guest   [administrator]
qiuhom  []
...done.
[root@node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：如果用户名后面不指定任何标签，相当于把原有的标签信息清空；标签为administrator的用户拥有登录web管理界面的权限；&lt;/p&gt;
&lt;p&gt;　　　　clear_password &amp;lt;username&amp;gt;：清空指定用户的密码；&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node1 ~]# rabbitmqctl clear_password qiuhom
Clearing password for user &quot;qiuhom&quot; ...
...done.
[root@node1 ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　虚拟主机相关管理子命令&lt;/p&gt;
&lt;p&gt;　　　　list_vhosts [&amp;lt;vhostinfoitem&amp;gt; ...]：列出虚拟主机列表；&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node1 ~]# rabbitmqctl list_vhosts
Listing vhosts ...
/
...done.
[root@node1 ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：默认只有“/”这个虚拟主机；&lt;/p&gt;
&lt;p&gt;　　　　add_vhost &amp;lt;vhostpath&amp;gt;：添加虚拟主机；&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node1 ~]# rabbitmqctl add_vhost /qiuhom/test
Creating vhost &quot;/qiuhom/test&quot; ...
...done.
[root@node1 ~]# rabbitmqctl list_vhosts           
Listing vhosts ...
/
/qiuhom/test
...done.
[root@node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　delete_vhost &amp;lt;vhostpath&amp;gt;：删除虚拟主机；&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node1 ~]# rabbitmqctl delete_vhost /qiuhom/test
Deleting vhost &quot;/qiuhom/test&quot; ...
...done.
[root@node1 ~]# rabbitmqctl list_vhosts              
Listing vhosts ...
/
...done.
[root@node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　权限相关管理子命令&lt;/p&gt;
&lt;p&gt;　　　　list_permissions [-p &amp;lt;vhostpath&amp;gt;]：列出指定虚拟主机权限，不指定表示查看默认虚拟主机的权限（这个是以虚拟主机查看权限）；&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node1 ~]# rabbitmqctl list_permissions
Listing permissions in vhost &quot;/&quot; ...
guest   .*      .*      .*
...done.
[root@node1 ~]# rabbitmqctl add_vhost /qiuhom/test
Creating vhost &quot;/qiuhom/test&quot; ...
...done.
[root@node1 ~]# rabbitmqctl list_permissions      
Listing permissions in vhost &quot;/&quot; ...
guest   .*      .*      .*
...done.
[root@node1 ~]# rabbitmqctl list_permissions -p /qiuhom/test
Listing permissions in vhost &quot;/qiuhom/test&quot; ...
...done.
[root@node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：默认虚拟主机上“/”，guest用户对“/”这个虚拟主机以下的所有组件有访问权限；其中第一个.*表示配置文件，第二个.*表示写权限，第三个是读权限；&lt;/p&gt;
&lt;p&gt;　　　　list_user_permissions &amp;lt;username&amp;gt;：列出指定用户的权限（能够对那些虚拟主机进行哪些操作，这个是以用户名去查看权限）&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node1 ~]# rabbitmqctl list_user_permissions guest
Listing permissions for user &quot;guest&quot; ...
/       .*      .*      .*
...done.
[root@node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：以上表示查看guest这个用户所有虚拟主机上的权限；这里需要注意一点虚拟主机都是以/开始的树状结构，且支持继承，所谓继承就表示一某个虚拟主机开始一下所有子虚拟主机都有相同的权限；以上guest就对所有虚拟主机有访问权限；&lt;/p&gt;
&lt;p&gt;　　　　set_permissions [-p &amp;lt;vhostpath&amp;gt;] &amp;lt;user&amp;gt; &amp;lt;conf&amp;gt; &amp;lt;write&amp;gt; &amp;lt;read&amp;gt;：设置权限，不指定虚拟主机表示给默认虚拟主机设定权限；&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node1 ~]# rabbitmqctl list_users
Listing users ...
guest   [administrator]
qiuhom  []
...done.
[root@node1 ~]# rabbitmqctl list_vhosts
Listing vhosts ...
/
/qiuhom/test
...done.
[root@node1 ~]# rabbitmqctl set_permissions qiuhom &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;  
Setting permissions for user &quot;qiuhom&quot; in vhost &quot;/&quot; ...
...done.
[root@node1 ~]# rabbitmqctl list_permissions  
Listing permissions in vhost &quot;/&quot; ...
guest   .*      .*      .*
qiuhom  .*      .*      .*
...done.
[root@node1 ~]# rabbitmqctl set_permissions -p /qiuhom/test qiuhom &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;
Setting permissions for user &quot;qiuhom&quot; in vhost &quot;/qiuhom/test&quot; ...
...done.
[root@node1 ~]# rabbitmqctl list_permissions                                     
Listing permissions in vhost &quot;/&quot; ...
guest   .*      .*      .*
qiuhom  .*      .*      .*
...done.
[root@node1 ~]#rabbitmqctl list_permissions  -p /qiuhom/test
Listing permissions in vhost &quot;/qiuhom/test&quot; ...
qiuhom  .*      .*      .*
...done.
[root@node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　clear_permissions [-p &amp;lt;vhostpath&amp;gt;] &amp;lt;username&amp;gt;：清空指定用户对某虚拟主机的权限，默认不指定虚拟主机表示默认虚拟主机；&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node1 ~]# rabbitmqctl list_permissions  -p /qiuhom/test
Listing permissions in vhost &quot;/qiuhom/test&quot; ...
qiuhom  .*      .*      .*
...done.
[root@node1 ~]# rabbitmqctl list_user_permissions  qiuhom    
Listing permissions for user &quot;qiuhom&quot; ...
/       .*      .*      .*
/qiuhom/test    .*      .*      .*
...done.
[root@node1 ~]# rabbitmqctl clear_permissions -p / qiuhom
Clearing permissions for user &quot;qiuhom&quot; in vhost &quot;/&quot; ...
...done.
[root@node1 ~]# rabbitmqctl list_user_permissions  qiuhom    
Listing permissions for user &quot;qiuhom&quot; ...
/qiuhom/test    .*      .*      .*
...done.
[root@node1 ~]# rabbitmqctl list_permissions  -p /
Listing permissions in vhost &quot;/&quot; ...
guest   .*      .*      .*
...done.
[root@node1 ~]# rabbitmqctl clear_permissions -p /qiuhom/test qiuhom 
Clearing permissions for user &quot;qiuhom&quot; in vhost &quot;/qiuhom/test&quot; ...
...done.
[root@node1 ~]# rabbitmqctl list_permissions  -p /qiuhom/test       
Listing permissions in vhost &quot;/qiuhom/test&quot; ...
...done.
[root@node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　组件查看类子命令&lt;/p&gt;
&lt;p&gt;　　　　list_queues [-p &amp;lt;vhostpath&amp;gt;] [&amp;lt;queueinfoitem&amp;gt; ...]：列出队列；&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node1 ~]# rabbitmqctl list_queues     
Listing queues ...
...done.
[root@node1 ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　list_exchanges [-p &amp;lt;vhostpath&amp;gt;] [&amp;lt;exchangeinfoitem&amp;gt; ...]：列出交换器；&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node1 ~]# rabbitmqctl list_exchanges  
Listing exchanges ...
        direct
amq.direct      direct
amq.fanout      fanout
amq.headers     headers
amq.match       headers
amq.rabbitmq.log        topic
amq.rabbitmq.trace      topic
amq.topic       topic
...done.
[root@node1 ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　list_bindings [-p &amp;lt;vhostpath&amp;gt;] [&amp;lt;bindinginfoitem&amp;gt; ...]：列出绑定器；&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node1 ~]# rabbitmqctl list_bindings   
Listing bindings ...
...done.
[root@node1 ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　list_connections [&amp;lt;connectioninfoitem&amp;gt; ...]：列出连接列表&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node1 ~]# rabbitmqctl list_connections
Listing connections ...
...done.
[root@node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　list_channels [&amp;lt;channelinfoitem&amp;gt; ...]：列出频道&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node1 ~]# rabbitmqctl list_channels   
Listing channels ...
...done.
[root@node1 ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：上面这些组件我们除了可以在命令行通过子命令的方式查看，其实在web管理界面也给我们提供了一个api访问接口；&lt;/p&gt;
&lt;p&gt;　　在web界面访问api接口查看虚拟主机&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202008/1503305-20200826005007886-834887727.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在web界面查看用户列表&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202008/1503305-20200826005051414-323405891.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：需要查看某类组件的信息，可以在api后面加上对应组件的名称作为rui即可访问，当然有了这个api接口，程序员就可以调用这个接口从而对rabbitmq进行操作；具体操作文档可访问对应宿主机的15672/api查看示例；&lt;/p&gt;
&lt;p&gt;　　　　list_consumers [-p &amp;lt;vhostpath&amp;gt;]：列出消费者&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node1 ~]# rabbitmqctl list_consumers  
Listing consumers ...
...done.
[root@node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　status：查看rabbitmq的状态信息；&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;146&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node1 ~]# rabbitmqctl status
Status of node rabbit@node1 ...
[{pid,20202},
 {running_applications,
     [{rabbitmq_management,&quot;RabbitMQ Management Console&quot;,&quot;3.3.5&quot;},
      {rabbitmq_web_dispatch,&quot;RabbitMQ Web Dispatcher&quot;,&quot;3.3.5&quot;},
      {webmachine,&quot;webmachine&quot;,&quot;1.10.3-rmq3.3.5-gite9359c7&quot;},
      {mochiweb,&quot;MochiMedia Web Server&quot;,&quot;2.7.0-rmq3.3.5-git680dba8&quot;},
      {rabbitmq_management_agent,&quot;RabbitMQ Management Agent&quot;,&quot;3.3.5&quot;},
      {rabbit,&quot;RabbitMQ&quot;,&quot;3.3.5&quot;},
      {os_mon,&quot;CPO  CXC 138 46&quot;,&quot;2.2.14&quot;},
      {inets,&quot;INETS  CXC 138 49&quot;,&quot;5.9.8&quot;},
      {mnesia,&quot;MNESIA  CXC 138 12&quot;,&quot;4.11&quot;},
      {amqp_client,&quot;RabbitMQ AMQP Client&quot;,&quot;3.3.5&quot;},
      {xmerl,&quot;XML parser&quot;,&quot;1.3.6&quot;},
      {sasl,&quot;SASL  CXC 138 11&quot;,&quot;2.3.4&quot;},
      {stdlib,&quot;ERTS  CXC 138 10&quot;,&quot;1.19.4&quot;},
      {kernel,&quot;ERTS  CXC 138 10&quot;,&quot;2.16.4&quot;}]},
 {os,{unix,linux}},
 {erlang_version,
     &quot;Erlang R16B03-1 (erts-5.10.4) [source] [64-bit] [smp:4:4] [async-threads:30] [hipe] [kernel-poll:true]\n&quot;},
 {memory,
     [{total,40816096},
      {connection_procs,5600},
      {queue_procs,5600},
      {plugins,432624},
      {other_proc,13494248},
      {mnesia,64144},
      {mgmt_db,45376},
      {msg_index,34528},
      {other_ets,1085424},
      {binary,119600},
      {code,20229052},
      {atom,711569},
      {other_system,4588331}]},
 {alarms,[]},
 {listeners,[{clustering,25672,&quot;::&quot;},{amqp,5672,&quot;::&quot;}]},
 {vm_memory_high_watermark,0.4},
 {vm_memory_limit,1581588480},
 {disk_free_limit,50000000},
 {disk_free,39831085056},
 {file_descriptors,
     [{total_limit,924},{total_used,3},{sockets_limit,829},{sockets_used,1}]},
 {processes,[{limit,1048576},{used,181}]},
 {run_queue,0},
 {uptime,5271}]
...done.
[root@node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　environment：查看环境变量；&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;197&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node1 ~]# rabbitmqctl environment
Application environment of node rabbit@node1 ...
[{auth_backends,[rabbit_auth_backend_internal]},
 {auth_mechanisms,['PLAIN','AMQPLAIN']},
 {backing_queue_module,rabbit_variable_queue},
 {channel_max,0},
 {channel_operation_timeout,70000},
 {cluster_nodes,{[],disc}},
 {cluster_partition_handling,ignore},
 {collect_statistics,fine},
 {collect_statistics_interval,5000},
 {default_permissions,[&amp;lt;&amp;lt;&quot;.*&quot;&amp;gt;&amp;gt;,&amp;lt;&amp;lt;&quot;.*&quot;&amp;gt;&amp;gt;,&amp;lt;&amp;lt;&quot;.*&quot;&amp;gt;&amp;gt;]},
 {default_user,&amp;lt;&amp;lt;&quot;guest&quot;&amp;gt;&amp;gt;},
 {default_user_tags,[administrator]},
 {default_vhost,&amp;lt;&amp;lt;&quot;/&quot;&amp;gt;&amp;gt;},
 {delegate_count,16},
 {disk_free_limit,50000000},
 {enabled_plugins_file,&quot;/etc/rabbitmq/enabled_plugins&quot;},
 {error_logger,{file,&quot;/var/log/rabbitmq/rabbit@node1.log&quot;}},
 {frame_max,131072},
 {halt_on_upgrade_failure,true},
 {heartbeat,580},
 {hipe_compile,false},
 {hipe_modules,[rabbit_reader,rabbit_channel,gen_server2,rabbit_exchange,
                rabbit_command_assembler,rabbit_framing_amqp_0_9_1,
                rabbit_basic,rabbit_event,lists,queue,priority_queue,
                rabbit_router,rabbit_trace,rabbit_misc,rabbit_binary_parser,
                rabbit_exchange_type_direct,rabbit_guid,rabbit_net,
                rabbit_amqqueue_process,rabbit_variable_queue,
                rabbit_binary_generator,rabbit_writer,delegate,gb_sets,lqueue,
                sets,orddict,rabbit_amqqueue,rabbit_limiter,gb_trees,
                rabbit_queue_index,rabbit_exchange_decorator,gen,dict,ordsets,
                file_handle_cache,rabbit_msg_store,array,
                rabbit_msg_store_ets_index,rabbit_msg_file,
                rabbit_exchange_type_fanout,rabbit_exchange_type_topic,mnesia,
                mnesia_lib,rpc,mnesia_tm,qlc,sofs,proplists,credit_flow,pmon,
                ssl_connection,tls_connection,ssl_record,tls_record,gen_fsm,
                ssl]},
 {included_applications,[]},
 {log_levels,[{connection,info}]},
 {loopback_users,[]},
 {msg_store_file_size_limit,16777216},
 {msg_store_index_module,rabbit_msg_store_ets_index},
 {plugins_dir,&quot;/usr/lib/rabbitmq/lib/rabbitmq_server-3.3.5/sbin/../plugins&quot;},
 {plugins_expand_dir,&quot;/var/lib/rabbitmq/mnesia/rabbit@node1-plugins-expand&quot;},
 {queue_index_max_journal_entries,65536},
 {reverse_dns_lookups,false},
 {sasl_error_logger,{file,&quot;/var/log/rabbitmq/rabbit@node1-sasl.log&quot;}},
 {server_properties,[]},
 {ssl_apps,[asn1,crypto,public_key,ssl]},
 {ssl_cert_login_from,distinguished_name},
 {ssl_listeners,[]},
 {ssl_options,[]},
 {tcp_listen_options,[binary,
                      {packet,raw},
                      {reuseaddr,true},
                      {backlog,128},
                      {nodelay,true},
                      {linger,{true,0}},
                      {exit_on_close,false}]},
 {tcp_listeners,[5672]},
 {trace_vhosts,[]},
 {vm_memory_high_watermark,0.4},
 {vm_memory_high_watermark_paging_ratio,0.5}]
...done.
[root@node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　report：生成系统状态报告；&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;321&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node1 ~]# rabbitmqctl report
Reporting server status on {{2020,8,25},{16,18,8}}

 ...
Status of node rabbit@node1 ...
[{pid,20202},
 {running_applications,
     [{rabbitmq_management,&quot;RabbitMQ Management Console&quot;,&quot;3.3.5&quot;},
      {rabbitmq_web_dispatch,&quot;RabbitMQ Web Dispatcher&quot;,&quot;3.3.5&quot;},
      {webmachine,&quot;webmachine&quot;,&quot;1.10.3-rmq3.3.5-gite9359c7&quot;},
      {mochiweb,&quot;MochiMedia Web Server&quot;,&quot;2.7.0-rmq3.3.5-git680dba8&quot;},
      {rabbitmq_management_agent,&quot;RabbitMQ Management Agent&quot;,&quot;3.3.5&quot;},
      {rabbit,&quot;RabbitMQ&quot;,&quot;3.3.5&quot;},
      {os_mon,&quot;CPO  CXC 138 46&quot;,&quot;2.2.14&quot;},
      {inets,&quot;INETS  CXC 138 49&quot;,&quot;5.9.8&quot;},
      {mnesia,&quot;MNESIA  CXC 138 12&quot;,&quot;4.11&quot;},
      {amqp_client,&quot;RabbitMQ AMQP Client&quot;,&quot;3.3.5&quot;},
      {xmerl,&quot;XML parser&quot;,&quot;1.3.6&quot;},
      {sasl,&quot;SASL  CXC 138 11&quot;,&quot;2.3.4&quot;},
      {stdlib,&quot;ERTS  CXC 138 10&quot;,&quot;1.19.4&quot;},
      {kernel,&quot;ERTS  CXC 138 10&quot;,&quot;2.16.4&quot;}]},
 {os,{unix,linux}},
 {erlang_version,
     &quot;Erlang R16B03-1 (erts-5.10.4) [source] [64-bit] [smp:4:4] [async-threads:30] [hipe] [kernel-poll:true]\n&quot;},
 {memory,
     [{total,40510448},
      {connection_procs,5600},
      {queue_procs,5600},
      {plugins,208520},
      {other_proc,13407608},
      {mnesia,64144},
      {mgmt_db,50256},
      {msg_index,34528},
      {other_ets,1085424},
      {binary,119648},
      {code,20229052},
      {atom,711569},
      {other_system,4588499}]},
 {alarms,[]},
 {listeners,[{clustering,25672,&quot;::&quot;},{amqp,5672,&quot;::&quot;}]},
 {vm_memory_high_watermark,0.4},
 {vm_memory_limit,1581588480},
 {disk_free_limit,50000000},
 {disk_free,39831064576},
 {file_descriptors,
     [{total_limit,924},{total_used,3},{sockets_limit,829},{sockets_used,1}]},
 {processes,[{limit,1048576},{used,181}]},
 {run_queue,0},
 {uptime,5347}]

Cluster status of node rabbit@node1 ...
[{nodes,[{disc,[rabbit@node1]}]},
 {running_nodes,[rabbit@node1]},
 {cluster_name,&amp;lt;&amp;lt;&quot;rabbit@node1&quot;&amp;gt;&amp;gt;},
 {partitions,[]}]

Application environment of node rabbit@node1 ...
[{auth_backends,[rabbit_auth_backend_internal]},
 {auth_mechanisms,['PLAIN','AMQPLAIN']},
 {backing_queue_module,rabbit_variable_queue},
 {channel_max,0},
 {channel_operation_timeout,70000},
 {cluster_nodes,{[],disc}},
 {cluster_partition_handling,ignore},
 {collect_statistics,fine},
 {collect_statistics_interval,5000},
 {default_permissions,[&amp;lt;&amp;lt;&quot;.*&quot;&amp;gt;&amp;gt;,&amp;lt;&amp;lt;&quot;.*&quot;&amp;gt;&amp;gt;,&amp;lt;&amp;lt;&quot;.*&quot;&amp;gt;&amp;gt;]},
 {default_user,&amp;lt;&amp;lt;&quot;guest&quot;&amp;gt;&amp;gt;},
 {default_user_tags,[administrator]},
 {default_vhost,&amp;lt;&amp;lt;&quot;/&quot;&amp;gt;&amp;gt;},
 {delegate_count,16},
 {disk_free_limit,50000000},
 {enabled_plugins_file,&quot;/etc/rabbitmq/enabled_plugins&quot;},
 {error_logger,{file,&quot;/var/log/rabbitmq/rabbit@node1.log&quot;}},
 {frame_max,131072},
 {halt_on_upgrade_failure,true},
 {heartbeat,580},
 {hipe_compile,false},
 {hipe_modules,[rabbit_reader,rabbit_channel,gen_server2,rabbit_exchange,
                rabbit_command_assembler,rabbit_framing_amqp_0_9_1,
                rabbit_basic,rabbit_event,lists,queue,priority_queue,
                rabbit_router,rabbit_trace,rabbit_misc,rabbit_binary_parser,
                rabbit_exchange_type_direct,rabbit_guid,rabbit_net,
                rabbit_amqqueue_process,rabbit_variable_queue,
                rabbit_binary_generator,rabbit_writer,delegate,gb_sets,lqueue,
                sets,orddict,rabbit_amqqueue,rabbit_limiter,gb_trees,
                rabbit_queue_index,rabbit_exchange_decorator,gen,dict,ordsets,
                file_handle_cache,rabbit_msg_store,array,
                rabbit_msg_store_ets_index,rabbit_msg_file,
                rabbit_exchange_type_fanout,rabbit_exchange_type_topic,mnesia,
                mnesia_lib,rpc,mnesia_tm,qlc,sofs,proplists,credit_flow,pmon,
                ssl_connection,tls_connection,ssl_record,tls_record,gen_fsm,
                ssl]},
 {included_applications,[]},
 {log_levels,[{connection,info}]},
 {loopback_users,[]},
 {msg_store_file_size_limit,16777216},
 {msg_store_index_module,rabbit_msg_store_ets_index},
 {plugins_dir,&quot;/usr/lib/rabbitmq/lib/rabbitmq_server-3.3.5/sbin/../plugins&quot;},
 {plugins_expand_dir,&quot;/var/lib/rabbitmq/mnesia/rabbit@node1-plugins-expand&quot;},
 {queue_index_max_journal_entries,65536},
 {reverse_dns_lookups,false},
 {sasl_error_logger,{file,&quot;/var/log/rabbitmq/rabbit@node1-sasl.log&quot;}},
 {server_properties,[]},
 {ssl_apps,[asn1,crypto,public_key,ssl]},
 {ssl_cert_login_from,distinguished_name},
 {ssl_listeners,[]},
 {ssl_options,[]},
 {tcp_listen_options,[binary,
                      {packet,raw},
                      {reuseaddr,true},
                      {backlog,128},
                      {nodelay,true},
                      {linger,{true,0}},
                      {exit_on_close,false}]},
 {tcp_listeners,[5672]},
 {trace_vhosts,[]},
 {vm_memory_high_watermark,0.4},
 {vm_memory_high_watermark_paging_ratio,0.5}]

Connections:

Channels:

Queues on /qiuhom/test:

Queues on /:

Exchanges on /qiuhom/test:
name    type    durable auto_delete     internal        arguments       policy
        direct  true    false   false   []
amq.direct      direct  true    false   false   []
amq.fanout      fanout  true    false   false   []
amq.headers     headers true    false   false   []
amq.match       headers true    false   false   []
amq.rabbitmq.trace      topic   true    false   true    []
amq.topic       topic   true    false   false   []

Exchanges on /:
name    type    durable auto_delete     internal        arguments       policy
        direct  true    false   false   []
amq.direct      direct  true    false   false   []
amq.fanout      fanout  true    false   false   []
amq.headers     headers true    false   false   []
amq.match       headers true    false   false   []
amq.rabbitmq.log        topic   true    false   true    []
amq.rabbitmq.trace      topic   true    false   true    []
amq.topic       topic   true    false   false   []

Bindings on /qiuhom/test:

Bindings on /:

Consumers on /qiuhom/test:

Consumers on /:

Permissions on /qiuhom/test:

Permissions on /:
user    configure       write   read
guest   .*      .*      .*

Policies on /qiuhom/test:

Policies on /:

Parameters on /qiuhom/test:

Parameters on /:

...done.
[root@node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　策略相关管理子命令&lt;/p&gt;
&lt;p&gt;　　　　list_policies [-p &amp;lt;vhostpath&amp;gt;]：列出指定虚拟主机的策略；默认不指定是列出默认虚拟主机；&lt;/p&gt;
&lt;p&gt;　　　　set_policy [-p &amp;lt;vhostpath&amp;gt;] [--priority &amp;lt;priority&amp;gt;] [--apply-to &amp;lt;apply-to&amp;gt;] &amp;lt;name&amp;gt; &amp;lt;pattern&amp;gt; &amp;lt;definition&amp;gt;：对指定虚拟主机设置策略，没有指定虚拟主机表示默认虚拟主机；&lt;/p&gt;
&lt;p&gt;　　　　clear_policy [-p &amp;lt;vhostpath&amp;gt;] &amp;lt;name&amp;gt;：清楚指定虚拟主机的策略，没有指定虚拟主机表示对默认虚拟主机操作；&lt;/p&gt;
&lt;p&gt;　　集群相关子命令&lt;/p&gt;
&lt;p&gt;　　　　join_cluster &amp;lt;clusternode&amp;gt; [--ram]：加入指定节点集群；&lt;/p&gt;
&lt;p&gt;　　　　cluster_status：查看集群状态&lt;/p&gt;
&lt;p&gt;　　　　change_cluster_node_type disc | ram：更改节点存储类型，disc表示磁盘，ram表示内存；一个集群中必须有一个节点为disc类型；&lt;/p&gt;
&lt;p&gt;　　　　forget_cluster_node [--offline]：离开集群；&lt;/p&gt;
&lt;p&gt;　　　　update_cluster_nodes clusternode：更新集群节点；&lt;/p&gt;
&lt;p&gt;　　　　sync_queue queue：同步指定队列；&lt;/p&gt;
&lt;p&gt;　　　　cancel_sync_queue queue：取消指定队列同步&lt;/p&gt;
&lt;p&gt;　　　　set_cluster_name name：设置集群名称；&lt;/p&gt;
&lt;p&gt;　　设置参数相关子命令&lt;/p&gt;
&lt;p&gt;　　　　list_parameters [-p &amp;lt;vhostpath&amp;gt;]：查看指定虚拟主机运行时参数配置，默认不指定虚拟主机，表示查看默认虚拟主机的参数配置；&lt;/p&gt;
&lt;p&gt;　　　　set_parameter [-p &amp;lt;vhostpath&amp;gt;] &amp;lt;component_name&amp;gt; &amp;lt;name&amp;gt; &amp;lt;value&amp;gt;：设置指定参数的配置；不指定虚拟主机表示操作默认虚拟主机；&lt;/p&gt;
&lt;p&gt;　　　　clear_parameter [-p &amp;lt;vhostpath&amp;gt;] &amp;lt;component_name&amp;gt; &amp;lt;key&amp;gt;：删除指定配置项；&lt;/p&gt;
&lt;p&gt;　　其他子命令&lt;/p&gt;
&lt;p&gt;　　　　eval &amp;lt;expr&amp;gt;：执行erlang表达式&lt;/p&gt;
&lt;p&gt;　　　　close_connection &amp;lt;connectionpid&amp;gt; &amp;lt;explanation&amp;gt;：关闭指定连接；&lt;/p&gt;
&lt;p&gt;　　　　trace_on [-p &amp;lt;vhost&amp;gt;]：开启指定虚拟主机的追踪功能；&lt;/p&gt;
&lt;p&gt;　　　　trace_off [-p &amp;lt;vhost&amp;gt;]：关闭指定虚拟主机的追踪功能；&lt;/p&gt;
&lt;p&gt;　　　　set_vm_memory_high_watermark &amp;lt;fraction&amp;gt;：设置内存高水位标记；&lt;/p&gt;
&lt;p&gt;　　以上就是rabbitmq的简单介绍和安装配置相关参数的说明，以及rabbitmqctl这个工具的常用子命令的用法；&lt;/p&gt;
</description>
<pubDate>Tue, 25 Aug 2020 16:58:00 +0000</pubDate>
<dc:creator>Linux-1874</dc:creator>
<og:description>1、概念 RabbitMQ是AMQP（高级消息队列协议）协议的实现主要功能用于分布式应用当中的各组件间解耦。在传统C/S架构中，如果客户端发送一个请求消息，服务端必须得在线，有了中间件，客户端不是非得</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qiuhom-1874/p/13561245.html</dc:identifier>
</item>
<item>
<title>Java并发必知必会第三弹：用积木讲解ABA原理 ｜老婆居然又听懂了！ - 悟空聊架构</title>
<link>http://www.cnblogs.com/jackson0714/p/ABA.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jackson0714/p/ABA.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;http://cdn.jayh.club/blog/20200825/f0IhlK4RmutQ.png?imageslim&quot; alt=&quot;封面图&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可落地的 Spring Cloud项目：&lt;a href=&quot;https://github.com/Jackson0714/PassJava-Platform&quot;&gt;PassJava&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;本篇主要内容如下&quot;&gt;本篇主要内容如下&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.jayh.club/blog/20200825/MlRROUaMYKIV.png?imageslim&quot; alt=&quot;本篇主要内容&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、背景&quot;&gt;一、背景&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.jayh.club/blog/20200821/b5JUIpeSuH7E.png?imageslim&quot; alt=&quot;4个A&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上一节我们讲了&lt;a href=&quot;https://juejin.im/post/6863799243182702599&quot;&gt;程序员深夜惨遭老婆鄙视，原因竟是CAS原理太简单？&lt;/a&gt;，留了一个彩蛋给大家，ABA问题是怎么出现的，为什么不是AAB拖拉机，AAA金花，4个A炸弹 ？这一篇我们再来揭开ABA的神秘面纱。&lt;/p&gt;
&lt;h2 id=&quot;二、面试连环炮&quot;&gt;二、面试连环炮&lt;/h2&gt;
&lt;p&gt;面试的时候我们也经常遭遇面试官的连环追问：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;CAS概念？&lt;/li&gt;
&lt;li&gt;Unsafe类是干啥用的？&lt;/li&gt;
&lt;li&gt;CAS底层实现是怎么样的&lt;/li&gt;
&lt;li&gt;ABA问题什么场景下会出现？&lt;/li&gt;
&lt;li&gt;ABA有什么危害？&lt;/li&gt;
&lt;li&gt;原子引用更新是啥？&lt;/li&gt;
&lt;li&gt;如何避免ABA问题？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://cdn.jayh.club/blog/20200825/94FgHlKLDUno.png?imageslim&quot; alt=&quot;面试连环炮&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;三、用积木讲解aba问题&quot;&gt;三、用积木讲解ABA问题&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;案例：甲看见一个三角形积木，觉得不好看，想替换成五边形，但是乙想把积木替换成四边形。（前提条件，只能被替换一次）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.jayh.club/blog/20200825/ue3sNCylBMHT.png?imageslim&quot; alt=&quot;用积木讲解ABA过程&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可能出现的过程如上图所示：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一步：乙先抢到了积木，将&lt;code&gt;三角形A&lt;/code&gt;积木替换成&lt;code&gt;五角星B1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;第二步：乙将&lt;code&gt;五角星B1&lt;/code&gt;替换成&lt;code&gt;五边形B2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;第三步：乙将&lt;code&gt;五边形B2&lt;/code&gt;替换成&lt;code&gt;棱形B3&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;第四步：乙将&lt;code&gt;棱形B3&lt;/code&gt;替换成&lt;code&gt;六边形B4&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;第五步：乙将&lt;code&gt;六边形B4&lt;/code&gt;替换成&lt;code&gt;三角形A&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;第六步：甲看到积木还是三角形，认为乙没有替换，甲可以进行替换&lt;/li&gt;
&lt;li&gt;第七步：甲将&lt;code&gt;三角形V&lt;/code&gt;替换成了&lt;code&gt;五边形B&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;讲解：&lt;/strong&gt;第一步道第五步，都是乙在替换，但最后还是替换成了三角形（即是不是同一个三角形），这个就是ABA，A指最开始是三角形，B指中间被替换的B1/B2/B3/B4，第二个A就是第五步中的A，中间不论经过怎么样的形状替换，最后还是变成了三角形。然后甲再将A2和A1进行形状比较，发现都是三角形，所以认为乙没有动过积木，甲可以进行替换。&lt;strong&gt;这个就是比较并替换（CAS）中的ABA问题。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;小结：&lt;/strong&gt;CAS只管开头和结尾，中间过程不关心，只要头尾相同，则认为可以进行修改，而中间过程很可能被其他人改过。&lt;/p&gt;
&lt;h2 id=&quot;四、用原子引用类演示aba问题&quot;&gt;四、用原子引用类演示ABA问题&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;AtomicReference&lt;/code&gt;：原子引用类&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1.首先我们需要定义一个积木类&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 积木类
 * @author: 悟空聊架构
 * @create: 2020-08-25
 */
class BuildingBlock {
    String shape;
    public BuildingBlock(String shape) {
        this.shape = shape;
    }
    @Override
    public String toString() {
        return &quot;BuildingBlock{&quot; + &quot;shape='&quot; + shape + '}';
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;2.定义3个积木：三角形A，四边形B，五边形D&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;static BuildingBlock A = new BuildingBlock(&quot;三角形&quot;);
// 初始化一个积木对象B，形状为四边形
static BuildingBlock B = new BuildingBlock(&quot;四边形&quot;);
// 初始化一个积木对象D，形状为五边形
static BuildingBlock D = new BuildingBlock(&quot;五边形&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;初始化原子引用类&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;static AtomicReference&amp;lt;BuildingBlock&amp;gt; atomicReference = new AtomicReference&amp;lt;&amp;gt;(A);
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;4.线程“乙”执行ABA操作&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;new Thread(() -&amp;gt; {// 初始化一个积木对象A，形状为三角形
           atomicReference.compareAndSet(A, B); // A-&amp;gt;B
           atomicReference.compareAndSet(B, A); // B-&amp;gt;A
        }, 
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;5.线程“甲”执行比较并替换&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;new Thread(() -&amp;gt; {// 初始化一个积木对象A，形状为三角形
           try {
               // 睡眠一秒，保证t1线程，完成了ABA操作
               TimeUnit.SECONDS.sleep(1);
           } catch (InterruptedException e) {
               e.printStackTrace();
           }
           // 可以替换成功，因为乙线程执行了A-&amp;gt;B-&amp;gt;A，形状没变，所以甲可以进行替换。
           System.out.println(atomicReference.compareAndSet(A, D) + &quot;\t&quot; + atomicReference.get()); // true    BuildingBlock{shape='五边形}
       }, &quot;甲&quot;).start();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出结果：&lt;/strong&gt;true BuildingBlock{shape='五边形}&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;小结：&lt;/strong&gt;当线程“乙”执行ABA之后，线程“甲”比较后，发现预期值和当前值一致，将三角形替换成了五边形。&lt;/p&gt;
&lt;h2 id=&quot;五、那aba到底有什么危害？&quot;&gt;五、那ABA到底有什么危害？&lt;/h2&gt;
&lt;p&gt;我们看到乙不管怎么进行操作，甲看到的还是三角形，那甲当成乙没有改变积木形状 又有什么问题呢？&lt;/p&gt;
&lt;p&gt;出现的问题场景通常是带有消耗类的场景，比如库存减少，商品卖出。&lt;/p&gt;
&lt;h3 id=&quot;1我们想象一下生活中的这个喝水场景：&quot;&gt;1.我们想象一下生活中的这个喝水场景：&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.jayh.club/blog/20200825/GtyE8wQAad1Y.png?imageslim&quot; alt=&quot;ABA喝水场景&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（1）一家三口人，爸爸、妈妈、儿子。&lt;/p&gt;
&lt;p&gt;（2）一天早上6点，妈妈给儿子的水杯灌满了水（水量为A），儿子先喝了一半（水量变成B）。&lt;/p&gt;
&lt;p&gt;（3）然后妈妈把水杯又灌满了（水量为A），等中午再喝（妈妈执行了一个ABA操作）。&lt;/p&gt;
&lt;p&gt;（4）爸爸7点看到水杯还是满的（不知道是妈妈又灌满的），于是给儿子喝了1/3（水量变成D）&lt;/p&gt;
&lt;p&gt;（5）那在中午之前，儿子喝了1/2+1/3= 5/6的水，这不是妈妈期望的，因为妈妈只想让儿子中午之前喝半杯水。&lt;/p&gt;
&lt;p&gt;这个场景的ABA问题带来的后果就是本来只用喝1/2的水，结果喝了5/6的水。&lt;/p&gt;
&lt;h3 id=&quot;2我们再想象一下电商中的场景&quot;&gt;2.我们再想象一下电商中的场景&lt;/h3&gt;
&lt;p&gt;（1）商品Y的库存是10（A）&lt;/p&gt;
&lt;p&gt;（2）用户m购买了5件（B）&lt;/p&gt;
&lt;p&gt;（3）运营人员乙补货5件（A）（乙执行了一个ABA操作）&lt;/p&gt;
&lt;p&gt;（4）运营人员甲看到库存还是10，就认为一件也没有卖出去（不考虑交易记录），其实已经卖出去了5件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那我们怎么解决原子引用的问题呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以用加版本号的方式来解决两个A相同的问题，比如上面的积木案例，我们可以给两个三角形都打上一个版本号的标签，如A1和A2，在第六步中，形状和版本号一致甲才可以进行替换，因形状都是三角形，而版本号一个1，一个是2，所以不能进行替换。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.jayh.club/blog/20200825/kv9iMSh6GdN5.png?imageslim&quot; alt=&quot;ABA问题的解决方案&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在Java代码中，我们可以用原子时间戳引用类型：&lt;code&gt;AtomicStampedReference&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;六、带版本号的原子引用类型&quot;&gt;六、带版本号的原子引用类型&lt;/h2&gt;
&lt;h3 id=&quot;1我们看一看这个原子类atomicstampedreference的底层代码&quot;&gt;1.我们看一看这个原子类&lt;code&gt;AtomicStampedReference&lt;/code&gt;的底层代码&lt;/h3&gt;
&lt;p&gt;比较并替换方法&lt;code&gt;compareAndSet&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public boolean compareAndSet(V   expectedReference,
                             V   newReference,
                             int expectedStamp,
                             int newStamp) {
    Pair&amp;lt;V&amp;gt; current = pair;
    return
        expectedReference == current.reference &amp;amp;&amp;amp;
        expectedStamp == current.stamp &amp;amp;&amp;amp;
        ((newReference == current.reference &amp;amp;&amp;amp;
          newStamp == current.stamp) ||
         casPair(current, Pair.of(newReference, newStamp)));
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;expectedReference&lt;/code&gt;：期望值&lt;/p&gt;
&lt;p&gt;&lt;code&gt;newReference&lt;/code&gt;：替换值&lt;/p&gt;
&lt;p&gt;&lt;code&gt;expectedStamp&lt;/code&gt;：期望版本号&lt;/p&gt;
&lt;p&gt;&lt;code&gt;newStamp&lt;/code&gt;：替换版本号&lt;/p&gt;
&lt;p&gt;先比较期望值expectedReference和当前值是否相等，以及期望版本号和当前版本号是否相等，如果两者都相等，则表示没有被修改过，可以进行替换。&lt;/p&gt;
&lt;h3 id=&quot;2如何使用atomicstampedreference？&quot;&gt;2.如何使用AtomicStampedReference？&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.jayh.club/blog/20200825/yH6eiQtp089J.png?imageslim&quot; alt=&quot;代码示例的原理图&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）先定义3个积木：三角形A，四边形B，五边形D&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 初始化一个积木对象A，形状为三角形
BuildingBlock A = new BuildingBlock(&quot;三角形&quot;);

// 初始化一个积木对象B，形状为四边形，乙会将三角形替换成四边形
BuildingBlock B = new BuildingBlock(&quot;四边形&quot;);

// 初始化一个积木对象B，形状为四边形，乙会将三边形替换成五边形
BuildingBlock D = new BuildingBlock(&quot;五边形&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;（2）创建一个原子引用类型的实例 atomicReference&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt; // 传递两个值，一个是初始值，一个是初始版本号
 AtomicStampedReference&amp;lt;BuildingBlock&amp;gt; atomicStampedReference = new AtomicStampedReference&amp;lt;&amp;gt;(A, 1);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;（3）创建一个线程“乙”执行ABA操作&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;new Thread(() -&amp;gt; {
    // 获取版本号
    int stamp = atomicStampedReference.getStamp();
    System.out.println(Thread.currentThread().getName() + &quot;\t 第一次版本号&quot; + stamp);
    // 暂停线程“乙”1秒钟，使线程“甲”可以获取到原子引用的版本号
    try {
        TimeUnit.SECONDS.sleep(1);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    /*
    * 乙线程开始ABA替换
    * */
    // 1.比较并替换，传入4个值，期望值A，更新值B，期望版本号，更新版本号
    atomicStampedReference.compareAndSet(A, B, atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + 1);
    System.out.println(Thread.currentThread().getName() + &quot;\t 第二次版本号&quot; + atomicStampedReference.getStamp()); //乙        第一次版本号1
    // 2.比较并替换，传入4个值，期望值B，更新值A，期望版本号，更新版本号
    atomicStampedReference.compareAndSet(B, A, atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + 1); // 乙   第二次版本号2
    System.out.println(Thread.currentThread().getName() + &quot;\t 第三次版本号&quot; + atomicStampedReference.getStamp()); // 乙       第三次版本号3
}, &quot;乙&quot;).start();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;1）乙先获取原子类的版本号，第一次获取到的版本号为1&lt;/p&gt;
&lt;p&gt;2）暂停线程“乙”1秒钟，使线程“甲”可以获取到原子引用的版本号&lt;/p&gt;
&lt;p&gt;3）比较并替换，传入4个值，期望值A，更新值B，期望版本号stamp，更新版本号stamp+1。A被替换为B，当前版本号为2&lt;/p&gt;
&lt;p&gt;4）比较并替换，传入4个值，期望值B，更新值A，期望版本号getStamp()，更新版本号getStamp()+1。B替换为A，当前版本号为3&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（4）创建一个线程“甲”执行D替换A操作&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;new Thread(() -&amp;gt; {
     // 获取版本号
     int stamp = atomicStampedReference.getStamp();
     System.out.println(Thread.currentThread().getName() + &quot;\t 第一次版本号&quot; + stamp); // 甲   第一次版本号1
     // 暂停线程“甲”3秒钟，使线程“乙”进行一次ABA替换操作
     try {
     TimeUnit.SECONDS.sleep(3);
     } catch (InterruptedException e) {
         e.printStackTrace();
     }
     boolean result = atomicStampedReference.compareAndSet(A,D,stamp,stamp + 1);
     System.out.println(Thread.currentThread().getName() + &quot;\t 修改成功否&quot; + result + &quot;\t 当前最新实际版本号：&quot; + atomicStampedReference.getStamp()); // 甲     修改成功否false     当前最新实际版本号：3
     System.out.println(Thread.currentThread().getName() + &quot;\t 当前实际最新值：&quot; + atomicStampedReference.getReference()); // 甲     当前实际最新值：BuildingBlock{shape='三角形}

}, &quot;甲&quot;).start();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（1）甲先获取原子类的版本号，版本号为1，因为乙线程还未执行ABA，所以甲获取到的版本号和乙获取到的版本号一致。&lt;/p&gt;
&lt;p&gt;（2）暂停线程“甲”3秒钟，使线程“乙”进行一次ABA替换操作&lt;/p&gt;
&lt;p&gt;（3）乙执行完ABA操作后，线程甲执行比较替换，期望为A，实际是A，版本号期望值是1，实际版本号是3&lt;/p&gt;
&lt;p&gt;（4）虽然期望值和实际值都是A，但是版本号不一致，所以甲不能将A替换成D，这个就避免了ABA的问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;小结：&lt;/strong&gt; 带版本号的原子引用类可以利用CAS+版本号来比较变量是否被修改。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;本篇分析了ABA产生的原因，然后又列举了生活中的两个案例来分析ABA的危害。然后提出了怎么解决ABA问题：用带版本号的原子引用类AtomicStampedReference。&lt;/p&gt;
&lt;p&gt;限于篇幅和侧重点，CAS的优化并没有涉及到，后续再倒腾这一块吧。另外AtomicStampedReference的缺点本篇本没有进行讲解，限于笔者的技术水平原因，并没有一一作答，期待后续能补上这一块的解答。&lt;/p&gt;
&lt;p&gt;我是悟空，一只努力变强的码农！我要变身超级赛亚人啦！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.jayh.club/blog/20200821/wp5kwn5UEWaJ.png?imageslim&quot; alt=&quot;悟空&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;4.9054054054054&quot;&gt;
&lt;p&gt;另外可以搜索「悟空聊架构」或者PassJava666，一起进步！&lt;br/&gt;我的&lt;a href=&quot;https://github.com/Jackson0714&quot;&gt;GitHub主页&lt;/a&gt;，关注我的&lt;code&gt;Spring Cloud&lt;/code&gt; 实战项目&lt;a href=&quot;https://github.com/Jackson0714/PassJava-Platform&quot;&gt;《佳必过》&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;http://cdn.jayh.club/blog/20200404/GU60Sv47XT7J.png?imageslim&quot; alt=&quot;mark&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 25 Aug 2020 16:21:00 +0000</pubDate>
<dc:creator>悟空聊架构</dc:creator>
<og:description>Java并发必知必会第三弹：用积木讲解ABA原理 可落地的 Spring Cloud项目：PassJava 本篇主要内容如下 一、背景 上一节我们讲了程序员深夜惨遭老婆鄙视，原因竟是CAS原理太简单？</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jackson0714/p/ABA.html</dc:identifier>
</item>
<item>
<title>Spring是如何解决循环依赖的 - 纪莫</title>
<link>http://www.cnblogs.com/jimoer/p/13562707.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jimoer/p/13562707.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;在面试的时候这两年有一个非常高频的关于spring的问题，那就是spring是如何解决循环依赖的。这个问题听着就是轻描淡写的一句话，其实考察的内容还是非常多的，主要还是考察的应聘者有没有研究过spring的源码。但是说实话，spring的源码其实非常复杂的，研究起来并不是个简单的事情，所以我们此篇文章只是为了解释清楚Spring是如何解决循环依赖的这个问题。&lt;/p&gt;
&lt;h3 id=&quot;什么样的依赖算是循环依赖？&quot;&gt;什么样的依赖算是循环依赖？&lt;/h3&gt;
&lt;p&gt;用过Spring框架的人都对&lt;strong&gt;依赖注入&lt;/strong&gt;这个词不陌生，一个Java类A中存在一个属性是类B的一个对象，那么我们就说类A的对象依赖类B，而在Spring中是依靠的IOC来实现的对象注入，也就是说创建对象的过程是IOC容器来实现的，并不需要自己在使用的时候通过new关键字来创建对象。&lt;br/&gt;那么当类A中依赖类B的对象，而类B中又依赖类C的对象，最后类C中又依赖类A的对象的时候，这种情况最终的依赖关系会形成一个环，这就是循环依赖。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200823170033101.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,size_25,color_c8cae6,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;循环依赖的类型&quot;&gt;循环依赖的类型&lt;/h3&gt;
&lt;p&gt;根据注入的时机可以分为两种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;构造器循环依赖&lt;/strong&gt;&lt;br/&gt;依赖的对象是通过构造方法传入的，在实例化bean的时候发生。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;赋值属性循环依赖&lt;/strong&gt;&lt;br/&gt;依赖的对象是通过setter方法传入的，对象已经实例化，在属性赋值和依赖注入的时候发生。&lt;br/&gt;&lt;strong&gt;构造器循环依赖，本质上是无解的&lt;/strong&gt;，实例化A的时候调用A的构造器，发现依赖了B，又去实例化B，然后调用B的构造器，发现又依赖的C，然后调用C的构造器去实例化，结果发起C的构造器里依赖了A，这就是个死循环无解。所以Spring也是不支持构造器循环依赖的，当发现存在构造器循环依赖时，会直接抛出&lt;code&gt;BeanCurrentlyInCreationException&lt;/code&gt; 异常。&lt;br/&gt;&lt;strong&gt;赋值属性循环依赖，Spring只支持bean在单例模式下的循环依赖&lt;/strong&gt;，其他模式下的循环依赖Spring也是会抛出&lt;code&gt;BeanCurrentlyInCreationException&lt;/code&gt; 异常的。&lt;mark&gt;Spring通过对还在创建过程中的单例bean，进行缓存并提前暴露该单例，使得其他实例可以提前引用到该单例bean。&lt;/mark&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;spring为什么只支持单例模式下的bean的赋值情况下的循环依赖&quot;&gt;Spring为什么只支持单例模式下的bean的赋值情况下的循环依赖&lt;/h3&gt;
&lt;p&gt;在prototype的模式下的bean，使用了一个ThreadLocal变量&lt;code&gt;prototypesCurrentlyInCreation&lt;/code&gt;来记录当前线程正在创建中的bean，这个变量在&lt;code&gt;AbtractBeanFactory&lt;/code&gt;类里。在创建前用beanName记录bean，在创建完成后删除bean。在&lt;code&gt;prototypesCurrentlyInCreation&lt;/code&gt;里采用了一个Set对象来存储正在创建中的bean。我们都知道Set是不允许存在重复对象的，这样就能保证同一个bean在一个线程中只能有一个正在创建。&lt;br/&gt;下面是&lt;code&gt;prototypesCurrentlyInCreation&lt;/code&gt;变量在删除bean时的操作，在&lt;code&gt;AbtractBeanFactory&lt;/code&gt;的&lt;code&gt;beforePrototypeCreation&lt;/code&gt;操作里。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;protected void afterPrototypeCreation(String beanName) {
      Object curVal = this.prototypesCurrentlyInCreation.get();
      if (curVal instanceof String) {
          this.prototypesCurrentlyInCreation.remove();
      }
      else if (curVal instanceof Set) {
          Set&amp;lt;String&amp;gt; beanNameSet = (Set&amp;lt;String&amp;gt;) curVal;
          beanNameSet.remove(beanName);
          if (beanNameSet.isEmpty()) {
              this.prototypesCurrentlyInCreation.remove();
          }
      }
  }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面的代码中看出，当变量为一个的时候采用了一个String对象来存储，节省了一些内存空间。&lt;br/&gt;在&lt;code&gt;AbstractBeanFactory&lt;/code&gt;类的&lt;code&gt;doGetBean&lt;/code&gt;方法里先判断是否为单例对象，不是单例对象，则直接判断当前线程是否已经存在了正在创建的bean。存在的话直接抛出异常。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200824225946260.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,size_60,color_c8cae6,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;这个&lt;code&gt;isPrototypeCurrentlyInCreation（）&lt;/code&gt;方法的实现代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;protected boolean isPrototypeCurrentlyInCreation(String beanName) {
        Object curVal = this.prototypesCurrentlyInCreation.get();
        return curVal != null &amp;amp;&amp;amp; (curVal.equals(beanName) || curVal instanceof Set &amp;amp;&amp;amp; ((Set)curVal).contains(beanName));
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为有了这个机制，spring在原型模式下是解决不了bean的循环依赖的，当发现有循环依赖的时候会直接抛出&lt;code&gt;BeanCurrentlyInCreationException&lt;/code&gt;异常的。&lt;/p&gt;
&lt;h3 id=&quot;那么为什么spring在单例模式下的构造赋值也不支持循环依赖呢？&quot;&gt;那么为什么spring在单例模式下的构造赋值也不支持循环依赖呢？&lt;/h3&gt;
&lt;p&gt;其实原理和原型模式下的情况类似，在单例模式下，bean也会用一个Set集合来保存正在创建中的bean，在创建前保存，创建完成后删除。&lt;br/&gt;这个对象在&lt;code&gt;DefaultSingletonBeanRegistry&lt;/code&gt;类下变量名为：&lt;code&gt;singletonsCurrentlyInCreation&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class DefaultSingletonBeanRegistry extends SimpleAliasRegistry implements SingletonBeanRegistry {
         private final Set&amp;lt;String&amp;gt; singletonsCurrentlyInCreation = Collections.newSetFromMap(new ConcurrentHashMap(16));
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;判定代码在&lt;code&gt;DefaultSingletonBeanRegistry&lt;/code&gt;类的&lt;code&gt;beforeSingletonCreation&lt;/code&gt;方法下。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;protected void beforeSingletonCreation(String beanName) {
    if (!this.inCreationCheckExclusions.contains(beanName) &amp;amp;&amp;amp; !this.singletonsCurrentlyInCreation.add(beanName)) {
        throw new BeanCurrentlyInCreationException(beanName);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上面这个方法中，判定&lt;code&gt;singletonsCurrentlyInCreation&lt;/code&gt;是否能成功的保存一个单例bean。如果不能成功保存，那么就会直接抛出&lt;code&gt;BeanCurrentlyInCreationException&lt;/code&gt;异常。&lt;/p&gt;
&lt;h3 id=&quot;单例模式下的setter赋值循环依赖&quot;&gt;单例模式下的Setter赋值循环依赖&lt;/h3&gt;
&lt;p&gt;终于到了我们的重点，Spring是如何解决单例模式下的Setter赋值的循环依赖了。&lt;br/&gt;其实主要的就是靠&lt;strong&gt;提前暴露创建中的单例实例&lt;/strong&gt;。&lt;br/&gt;那么具体是一个怎样的过程呢？&lt;br/&gt;例如：上面那个图的例子，A依赖B，B依赖C，C又依赖B。&lt;br/&gt;过程如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;创建A，调用构造方法，完成构造，进行属性赋值注入，发现依赖B，去实例化B&lt;/code&gt;&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;创建B，调用构造方法，完成构造，进行属性赋值注入，发现依赖C，去实例化C&lt;/code&gt;&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;创建C，调用构造方法，完成构造，进行属性赋值注入，发现依赖A。&lt;br/&gt;&lt;strong&gt;&lt;mark&gt;这个时候就是解决循环依赖的关键了，因为A已经通过构造方法已经构造完成了，也就是说已经将Bean的在堆中分配好了内存，这样即使A再填充属性值也不会更改内存地址了，所以此时可以提前拿出来A的引用，来完成C的实例化。&lt;/mark&gt;&lt;/strong&gt;&lt;br/&gt;这样上面创建C过程就会变成了：&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;创建C，调用构造方法，完成构造，进行属性赋值注入，发现依赖A，A已经构造完成，直接引用，完成C的实例化&lt;/code&gt;&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;C完成实例化后，注入B，B也完成了实例化，然后B注入A，A也完成了实例化&lt;/code&gt;&lt;/strong&gt;。&lt;br/&gt;为了能获取到创建中单例bean，spring提供了三级缓存来将正在创建中的bean提前暴露。&lt;br/&gt;在类&lt;code&gt;DefaultSingletonBeanRegistry&lt;/code&gt;下，即下图红框中的三个Map对象。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200825222038424.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,size_40,color_c8cae6,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;这三个缓存Map的作用如下：&lt;/li&gt;
&lt;li&gt;一级缓存，&lt;code&gt;singletonObjects&lt;/code&gt; 单例缓存，存储已经实例化的单例bean。&lt;/li&gt;
&lt;li&gt;二级缓存，&lt;code&gt;earlySingletonObjects&lt;/code&gt; 提前暴露的单例缓存，这里存储的bean是刚刚构造完成，但还会通过属性注入bean。&lt;/li&gt;
&lt;li&gt;三级缓存，&lt;code&gt;singletonFactories&lt;/code&gt; 生产单例的工厂缓存，存储工厂。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;首先在创建bean的时候会先创建一个和bean同名的单例工厂，并将bean先放入到单例工厂中。代码在&lt;code&gt;AbstractAutowireCapableBeanFactory&lt;/code&gt;类的&lt;code&gt;doCreateBean&lt;/code&gt;方法中。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, Object[] args) throws BeanCreationException {
        ......
        this.addSingletonFactory(beanName, new ObjectFactory&amp;lt;Object&amp;gt;() {
        public Object getObject() throws BeansException {
            return AbstractAutowireCapableBeanFactory.this.getEarlyBeanReference(beanName, mbd, bean);
        }
    });
        .....
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而上面的代码中的&lt;code&gt;addSingletonFactory&lt;/code&gt;方法的代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;protected void addSingletonFactory(String beanName, ObjectFactory&amp;lt;?&amp;gt; singletonFactory) {
    Assert.notNull(singletonFactory, &quot;Singleton factory must not be null&quot;);
    Map var3 = this.singletonObjects;
    synchronized(this.singletonObjects) {
        if (!this.singletonObjects.containsKey(beanName)) {
            this.singletonFactories.put(beanName, singletonFactory);
            this.earlySingletonObjects.remove(beanName);
            this.registeredSingletons.add(beanName);
        }

    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;addSingletonFactory&lt;/code&gt;方法的作用通过代码就可以看到是将存在了正在创建中的bean的单例工厂，放在三级缓存里，这样保证了在循环依赖查找的时候是可以找到bean的引用的。&lt;br/&gt;具体读取缓存获取bean的过程在类&lt;code&gt;DefaultSingletonBeanRegistry&lt;/code&gt;的&lt;code&gt;getSingleton&lt;/code&gt;方法里。&lt;br/&gt;如下源码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;protected Object getSingleton(String beanName, boolean allowEarlyReference) {
     Object singletonObject = this.singletonObjects.get(beanName);
     if (singletonObject == null &amp;amp;&amp;amp; this.isSingletonCurrentlyInCreation(beanName)) {
         Map var4 = this.singletonObjects;
         synchronized(this.singletonObjects) {
             singletonObject = this.earlySingletonObjects.get(beanName);
             if (singletonObject == null &amp;amp;&amp;amp; allowEarlyReference) {
                 ObjectFactory&amp;lt;?&amp;gt; singletonFactory = (ObjectFactory)this.singletonFactories.get(beanName);
                 if (singletonFactory != null) {
                     singletonObject = singletonFactory.getObject();
                     this.earlySingletonObjects.put(beanName, singletonObject);
                     this.singletonFactories.remove(beanName);
                 }
             }
         }
     }

     return singletonObject != NULL_OBJECT ? singletonObject : null;
 }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过上面的源码我们可以看到，在获取单例Bean的时候，会先从一级缓存&lt;code&gt;singletonObjects&lt;/code&gt;里获取，如果没有获取到（说明不存在或没有实例化完成），会去第二级缓存&lt;code&gt;earlySingletonObjects&lt;/code&gt;中去找，如果还是没有找到的话，就会三级缓存中获取单例工厂&lt;code&gt;singletonFactory&lt;/code&gt;，通过从&lt;code&gt;singletonFactory&lt;/code&gt;中获取正在创建中的引用，将&lt;code&gt;singletonFactory&lt;/code&gt;存储在&lt;code&gt;earlySingletonObjects&lt;/code&gt; 二级缓存中，这样就将创建中的单例引用从三级缓存中升级到了二级缓存中，二级缓存&lt;code&gt;earlySingletonObjects&lt;/code&gt;，是会提前暴露已完成构造，还可以执行属性注入的单例bean的。&lt;br/&gt;这个时候如何还有其他的bean也是需要属性注入，那么就可以直接从&lt;code&gt;earlySingletonObjects&lt;/code&gt;中获取了。&lt;/p&gt;
&lt;p&gt;上面的例子中的过程中的A，在注入C的时候，其实并没有真正的初始化完成，等到顺利的注入了B才算是真正的初始化完成。&lt;br/&gt;整个过程如下图：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200825233756793.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,size_60,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 25 Aug 2020 15:55:00 +0000</pubDate>
<dc:creator>纪莫</dc:creator>
<og:description>前言 在面试的时候这两年有一个非常高频的关于spring的问题，那就是spring是如何解决循环依赖的。这个问题听着就是轻描淡写的一句话，其实考察的内容还是非常多的，主要还是考察的应聘者有没有研究过s</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jimoer/p/13562707.html</dc:identifier>
</item>
</channel>
</rss>