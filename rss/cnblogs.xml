<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>SQL Server GUID 数据迁移至MongoDB后怎样查看？ - 东山絮柳仔</title>
<link>http://www.cnblogs.com/xuliuzai/p/10257695.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuliuzai/p/10257695.html</guid>
<description>&lt;p&gt;关键字：SQL Server NEWID（）；BSON；MongoDB UUID&lt;/p&gt;
&lt;h2&gt;1.遇到的问题和困惑&lt;/h2&gt;
&lt;p&gt; SQL Server中的NEWID数据存储到MongoDB中会是什么样子呢？发现不能简单的通过此数据查询了。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;例如我们将SQL Server 数据库中的QQStatements2019表迁移至MongoDB 中，集合命名也为QQStatements2019。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;在SQL Server中选择4个OrderId,数据作为演示实例，查看如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201901/780228-20190111215550494-1725521771.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;经过程序转换后，在mongodb的客户端工具nosqlbooster上查看。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201901/780228-20190111215704371-42241327.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;此时没有文档。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;但是查看文档数据量，SQL Server 和 MongoDB 二者一致，说明确实导入成功了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;问题出在哪儿？难得数据失真了？&lt;/strong&gt;如果是失真的话？是只有这一个字段失真还是全部字段失真？&lt;/p&gt;
&lt;p&gt;我们用这些Orderid对应的SerialNumber数据去MongoDB中查询验证下。&lt;/p&gt;
&lt;p&gt;现在SQL Server数据库中查看，数据显示如下：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201901/780228-20190111215428637-1193687769.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后去MongoDB查看，&lt;strong&gt;此条件查询竟然有数据&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201901/780228-20190111220041492-356296330.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;但仔细查看确实失真了，两者显示的不一样。例如：SerialNumber为XX41107960HEZE的Orderid，在SQL Server中是 32C8C3A1-3444-4440-9AE4-9B7631968080，但是在MongoDB中，就变成了如下模样，点击打开又是另外一个样子。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201901/780228-20190111214907013-772490714.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;JSON Viewer的界面显示的OrderId数据就是二进制类型。&lt;/p&gt;
&lt;p&gt;如上所示，MongoDB查询显示的数据有LUUID（），那我们在每个orderid数据上加上一个LUUID（），是不是就可以查找到了呢？&lt;/p&gt;
&lt;p&gt;以SQL Server 的Orderid查看（失真前 32C8C3A1-3444-4440-9AE4-9B7631968080），没有数据。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201901/780228-20190111220229986-1270655286.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以MongoDB”失真”后的a1c3c832-4434-4044-9ae4-9b7631968080去查看。&lt;/p&gt;
&lt;p&gt;直接查看没有。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201901/780228-20190111220925631-1176210189.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;加上 LUUID(）查看有了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201901/780228-20190111220720662-1484973501.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;但验证到这儿，还是不能根据SQL Server 中OrderID 去关联查看 MongoDB中的数据啊！！！&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt; 并且仔细查看 32C8C3A1-3444-4440-9AE4-9B7631968080（SQL Server中数据） 和 a1c3c832-4434-4044-9ae4-9b7631968080（MongoDB数据） 相似度很高。后面的几个字节9AE4-9B7631968080 都是一样的。前面的几个字节，也都是在每个段内 以2位为单位重新排列组合。&lt;/p&gt;
&lt;p&gt;这看着应该和数据的存储 和类型有关，并且这个变化的只是GUID类型的”失真”了。&lt;/p&gt;
&lt;p&gt;回头再比较看看&quot;失真&quot;OrderId和没失真的 SerialNumber在SQL Server 数据库中是怎么定义的。&lt;/p&gt;
&lt;p&gt;OrderID在SQL Server数据中的数据类型是  [OrderId] [uniqueidentifier] NOT NULL，而 SerialNumber的类型如下： [SerialNumber] [varchar](50) NULL &lt;/p&gt;
&lt;p&gt;现在回头去看看MongoDB存储和SQL Server uniqueidentifier类型相关的知识。争取从这方面找到突破口。&lt;/p&gt;

&lt;h2&gt;2. MongoDB存储格式和SQL Server uniqueidentifier类型相关的知识&lt;/h2&gt;
&lt;h3&gt;2.1 MongoDB 存储格式&lt;/h3&gt;
&lt;p&gt;从内部讲，MongoDB以二进制JSON格式存储文档数据或者叫BSON。BSON有相似的数据结构，但是专门为文档存储设计。当查询MongoDB并返回结果时，这些数据就会转换为易于阅读的数据格式。MongoDB Shell使用JavaScript获取JSON格式的文档数据。所有的MongoDB驱动都执行三个主要的功能：首先，生成MongoDB对象ID。默认都存储在所有文档的_id字段里。其次，驱动会把任意语言表示的文档对象转换为BSON或者从BSON转换回来，BSON是MongoDB使用的二进制JSON格式。最后，使用TCP socket与数据库连接通信，此时使用的是MongoDB自定义协议。&lt;/p&gt;
&lt;p&gt;所有的文档在发送给MongoDB之前都序列化为BSON格式，以后再从BSON反序列化。驱动库会处理底层的数据类型转换工作。绝大部分驱动都提供了从BSON序列化的简单接口，当读/写文档的时候会自动完成。二进制数据是一个任意字节的字符串。它不能直接在shell中使用。如果要将非UTF-8字符保存到数据库中，二进制数据是唯一的方式。&lt;/p&gt;
&lt;p&gt; 2.2 SQL Server uniqueidentifier类型&lt;/p&gt;
&lt;p&gt;uniqueidentifier 全局唯一标识符 (GUID)。&lt;/p&gt;
&lt;p&gt;使用 NEWID 函数。&lt;/p&gt;
&lt;p&gt;将字符串常量转换为如下形式（xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx，其中每个 x 是 0-9 或 a-f 范围内的一个十六进制的数字）。例如，6F9619FF-8B86-D011-B42D-00C04FC964FF 即为有效的 uniqueidentifier 值。 &lt;br/&gt; &lt;/p&gt;
&lt;h2&gt;3. 解决小窍门&lt;/h2&gt;
&lt;p&gt;通过以上知识了解，我们可能定位到数据“失真”应该和 BSON格式和驱动有关，那么可以推测，这个工具（nosqlbooster）应该也有类似的驱动。&lt;/p&gt;
&lt;p&gt;皇天不负苦心人，找找就找到了。&lt;/p&gt;
&lt;p&gt;如下操作    管理设置图标--&amp;gt;Display Legacy UUID in --&amp;gt;.NET Format&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201901/780228-20190111214603104-411126698.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;然后，执行点击查看，结果变成了如下格式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201901/780228-20190111214714936-2023358023.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个MongoDB结果中的数据和SQL Server 中的数据长的比较像了。&lt;/p&gt;
&lt;p&gt;此时再次以SQL Server 数据库中的一个OrderId 查看。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201901/780228-20190111222553712-162862686.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时还是没有数据&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;添加CSUUID(）函数，再次查看有数据了&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201901/780228-20190111222809976-834523888.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 到此，我们可以松口气了，总算可以，拿到 SQL Server 中的某个Order Id，也可以去转换后的MongoDB查看了。&lt;/p&gt;


&lt;p&gt; &lt;strong&gt;本文版权归作者所有，未经作者同意不得转载,谢谢配合！！！&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 11 Jan 2019 19:39:00 +0000</pubDate>
<dc:creator>东山絮柳仔</dc:creator>
<og:description>关键字：SQL Server NEWID（）；BSON；MongoDB UUID 1.遇到的问题和困惑 SQL Server中的NEWID数据存储到MongoDB中会是什么样子呢？发现不能简单的通过此</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xuliuzai/p/10257695.html</dc:identifier>
</item>
<item>
<title>架构师成长之路2.4-Kickstart文件剖析 - CARLOS_CHIANG</title>
<link>http://www.cnblogs.com/yaoyaojcy/p/10251285.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yaoyaojcy/p/10251285.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/yaoyaojcy/p/9946235.html&quot; target=&quot;_blank&quot;&gt;点击返回架构师成长之路&lt;/a&gt;&lt;/p&gt;

&lt;p&gt; kickstart文件是一个简单的文本文件,它包含了一个项目列表,每个项目由一个关键字来识别。&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;创建kickstart文件注意:&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;每节必须按顺序指定.除非特别申明,每节内的项目则不必按序排列.小节的顺序为:&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;          命令部分,这里应该包括必需的选项.&lt;br/&gt;           %packages部分,这部分选择需要安装的软件包.&lt;br/&gt;           %pre和%post部分,这两个部分可以按任何顺序排列而且不是必需的.前者是预安装脚本，后者是系统安装完成后脚本&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;不必需的项目可以被省略.&lt;/li&gt;
&lt;li&gt;如果忽略任何必需的项目,安装程序会提示用户输入相关的项目的选择,就象用户在典型的安装过程中所遇到的一样.一旦用户进行了选择,安装会以非交互的方式(unattended)继续(除非找到另外一个没有指定的项目).&lt;/li&gt;
&lt;li&gt;以井号(&quot;#&quot;)开头的行被当作注释行并被忽略.&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;kickstart 升级,下列项目是必需的:&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;语言&lt;/li&gt;
&lt;li&gt;安装方法&lt;/li&gt;
&lt;li&gt;设备规格(如果这个设备是在安装过程中所需要的)&lt;/li&gt;
&lt;li&gt;键盘设置&lt;/li&gt;
&lt;li&gt;upgrade 关键字&lt;/li&gt;
&lt;li&gt;引导装载程序配置&lt;/li&gt;
&lt;li&gt;如果任何其他的项目被指定为upgrade,这些项目将被忽略(注意这包括了软件包选择).&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;以下为一个Centos7示列：&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
#version=DEVEL
install
auth --enableshadow --passalgo=sha512
text
lang en_US.UTF-8
keyboard --vckeymap=us --xlayouts='us'
network --onboot=on --device=ens33  --bootproto=dhcp --activate --ipv6=auto
rootpw newpassword
firewall --service=ssh
url --url=http://172.18.20.225/Centos7.5
selinux --disabled
timezone Asia/Shanghai --isUtc
bootloader --location=mbr --driveorder=sda --append=&quot;crashkernel=auto&quot;
zerombr
clearpart --none --initlabel
reboot
part /boot --fstype=ext4 --ondisk=sda --size=400
part swap  --ondisk=sda --size=4000
part / --fstype=ext4 --ondisk=sda --grow --size=200
 
%packages
@^minimal
@core
%end
 
%addon com_redhat_kdump --disable --reserve-mb='auto'
 
%end
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;kickstart选项指令段的说明：&lt;/span&gt;&lt;/h3&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;【必须的选项】：&lt;/span&gt;
&lt;/strong&gt;
&lt;strong&gt;1.auth或者authconfig&lt;/strong&gt; :验证选项
    --useshadow或者--enableshadow启用shadow文件来验证
    --passalgo=sha512使用sha512算法
&lt;strong&gt;2.bootloader:&lt;/strong&gt; 指定如何安装引导程序，要求必须已选择分区、已选择引导程序、已选择软件包，如果没选择将会停止而不会询问
    --location=mbr 指定引导程序的位置，默认为mbr，还可以指定none或者包含bootloader的引导块所在分区
    --driveorder=sda 指定grub安装在哪个分区以及指定寻找顺序，--driverorder=sda sdc sdb
    --append=&quot;crashkernel=auto rhgb quiet&quot; 指定内核参数
&lt;strong&gt;3.keyboard：&lt;/strong&gt;指定键盘类型，一般使用美式键盘&quot;keyboard us&quot;，新版的kickstart的格式有所变化，但也支持&quot;keyboard us&quot;这样的老格式
&lt;strong&gt;4.lang：&lt;/strong&gt;指定语言，如&quot;lang en_US.UTF-8&quot;5.rootpw：设置root用户的密码
    --iscrypted:使用加密密码，可以使用MD5,SHA-256,sha-512等。
        如：rootpw  --iscrypted $6$kxEBpy0HqHiY2Tsx$FTAqbjHs6x0VruChfYKxVeKLlxPuY0LXK7RxAVdu3uUivGclMUEz.i4ARlsMpqe1bf379uEgWOSFqGtZxqrwg.
        其中SHA-512位的加密密码在CentOS 6上可以使用&quot;grub-crypt --sha-512&quot;生成，CentOS7上可以使用python等工具来生成，如下：
        python -c 'import crypt,getpass;pw=getpass.getpass();print(crypt.crypt(pw) if (pw==getpass.getpass(&quot;Confirm: &quot;)) else exit())'     
&lt;strong&gt;&lt;span&gt;【可选的选项】：&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;
&lt;strong&gt;1.selinux：&lt;/strong&gt;设置selinux，值为enforcing,permissice,disable之一
&lt;strong&gt;2.autostep:&lt;/strong&gt; 交互式，和interactive类似
&lt;strong&gt;3.interactive:&lt;/strong&gt; 使用kickstart文件指定的参数交互式安装，但仍会给出每一步的选择项，如果直接下一步就使用kickstart参数
&lt;strong&gt;4.cmdline：&lt;/strong&gt;在完全非交互的命令行模式下进行安装
&lt;strong&gt;5.driverdisk：&lt;/strong&gt;指定驱动程序所在位置
    drvierdisk --source=
&lt;strong&gt;6.firewall&lt;/strong&gt;：设置firewall
    --disable禁用防火墙
&lt;strong&gt;7.firstboot：&lt;/strong&gt;
    --disable：安装后第一次启动默认会给出很多需要手动配置的界面，禁用它
&lt;strong&gt;8.graphical：&lt;/strong&gt;在图形模式下根据kickstart执行安装，默认该选项
&lt;strong&gt;9.text：&lt;/strong&gt;文本模式下根据kickstart执行安装（既然使用kickstart了，当然建议选择使用纯文本模式而不是图形模式了）
 9.1 skipx：不安装图形工具
&lt;strong&gt;10.halt/reboot：&lt;/strong&gt;安装完成后关机还是reboot，默认是halt
&lt;strong&gt;11.ignoredisk：&lt;/strong&gt;指定忽略的磁盘
&lt;strong&gt;12.install/upgrade：&lt;/strong&gt;指定是安装还是升级系统
    对于install，还必须指定下面几种安装方式之一：
        cdrom：指定从第一个光盘驱动器安装
        harddrive：指定从本地硬盘安装，要求硬盘必须是vfat或者ext2文件系统格式
            --biospart：指定从bios类型的分区来安装，如82文件系统类型号的分区
            --partition：从某个分区安装
            --dir：指定从包含install-tree（安装树）的目录安装
                例如：harddrive --partition=hdb2 --dir=/tmp/install-tree
        nfs：指定从nfs路径安装
            --server:指定nfs服务器主机名或IP
            --dir:指定包含install-tree的目录
            --opts:指定挂载NFS的mount选项            如：nfs --server=172.16.10.10 --dir=/export_path
        url：指定从ftp、http、https安装
             例如：url --url ftp://172.16.10.10
&lt;strong&gt;13.loggin：&lt;/strong&gt;指定安装过程中的错误日志位置
    --host:指定日志将发送到那台主机上
    --port:如果远程主机的rsyslog使用非默认端口，则应该指定该端口选项
    --levle:指定日志级别
&lt;strong&gt;14.network：&lt;/strong&gt;为系统配置网络信息，并在安装过程中激活该网络设备。可多次使用network指令，例如既设置网络，又设置主机名
    --bootproto:dhcp或static；对于static则必须指定IP地址、子网掩码、网关和DNS
    --device：网卡名，可以使用eth0类似的名称来指定
    --hostname:指定主机名
    --onboot：是否在引导系统时启用指定的设备
        如：
        network --bootproto=static --ip=192.168.100.2 --netmask=255.255.255.0 --gateway=192.168.100.254 --nameserver=8.8.8.8
        network --bootproto=dhcp --device=eth0 --noipv6
        network --hostname=node1.xuexi.com
&lt;strong&gt;15.autopart:&lt;/strong&gt; 自动创建几个分区：大于1G的根分区，250M的boot分区和swap分区
&lt;strong&gt;16.zerombr：&lt;/strong&gt;清除磁盘的mbr
&lt;strong&gt;17.clearpart:&lt;/strong&gt; 在安装系统前清除分区，如果指定该选项则必须指定正确
    --all:清除所有分区
    --Linux：清除Linux分区
    --none：不清除分区
    --initlabel：创建标签，对于没有MBR或者GPT的新硬盘，该选项是必须的
    --drivers=sdb：清除指定的分区
    所以，clearpart --all --initlabel是常见的方式
&lt;strong&gt;18.part&lt;/strong&gt;：创建分区
    --asprimary:强制指定为主分区
    --grow：使用所有可用空间，即为其分配所有剩余空间。对于根分区至少需要3G空间（即使是--grow，也还是需要指定--size）
    --ondisk：指定在哪块磁盘上创建分区。如果有多块磁盘，则需要指定在哪块磁盘上创建哪个分区，只有一块硬盘时可以省略该选项
        如：
            #part /boot --fstype=ext4 --asprimary --size=200     #boot分区200-250M足以
            #part swap --fstype=swap --asprimary --size=2048             
            #part / --fstype=ext4 --grow --asprimary  --size=2000
&lt;strong&gt;LVM的分区方法：&lt;/strong&gt;
part /boot --fstype ext4 --size=100
part swap --fstype=swap --size=2048
part pv26 --size=100 --grow
volgroup VG00 --pesize=32768 pv26
logvol / --fstype ext4 --name=LVroot --vgname=VG00 --size=29984
logvol /data --fstype ext4 --name=LVdata --vgname=VG00 --size=100 --grow        
            
&lt;strong&gt;19.repo：&lt;/strong&gt;指定除自带的yum源外的其他yum源，可以指定多行yum源（既然是第一次装系统，基本都不会去加这项）
    如：repo --name=&quot;CentOS&quot;  --baseurl=cdrom:sr0 --cost=100
&lt;strong&gt;20.services：&lt;/strong&gt;设置默认运行级别下开机自启动的服务
    --disable
    --enable
        disable先处理enable后处理
        如services --disable auditd,cups,atd
&lt;strong&gt;21.timezone&lt;/strong&gt;：指定时区
    如：Asia/Shanghai
&lt;strong&gt;22.user：&lt;/strong&gt;在系统中生成一个新用户
    --name：指定用户名
    --groups：指定辅助组，非默认组
    --homedir：用户家目录，如果不指定则默认为/home/&amp;lt;username&amp;gt;
    --password：该用户的密码，如果不指定或省略则创建后该用户处于锁定状态
    --shell：用户的shell，不指定则默认
    --uid：用户UID，不指定则自动分配一个非系统用户的UID
&lt;strong&gt;23.key：&lt;/strong&gt;输入序列号，只在RedHat中有，CentOS系统没有该项
    --skip  跳过key选项

&lt;span&gt;&lt;strong&gt;【kickstart软件包或包组选项】
&lt;/strong&gt;&lt;/span&gt;
使用&quot;%packages&quot;表示该段内容,@表示选择的包组，最前面使用横杠表示取反，即不选择的包或包组。
@base和@core两个包组总是被默认选择，所以不必在%packages中指定它们
&lt;/pre&gt;

</description>
<pubDate>Fri, 11 Jan 2019 18:38:00 +0000</pubDate>
<dc:creator>CARLOS_CHIANG</dc:creator>
<og:description>点击返回架构师成长之路 架构师成长之路2.4-Kickstart文件剖析 kickstart文件是一个简单的文本文件,它包含了一个项目列表,每个项目由一个关键字来识别。 创建kickstart文件注意</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yaoyaojcy/p/10251285.html</dc:identifier>
</item>
<item>
<title>从源码中学习设计模式系列——单例模式序/反序列化以及反射攻击的问题（二） - 菠萝吹雪—Code</title>
<link>http://www.cnblogs.com/runningsmallguo/p/10256677.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/runningsmallguo/p/10256677.html</guid>
<description>&lt;p&gt;这篇文章是学习单例模式的第二篇，之前的文章一下子就给出来看起来很高大上的实现方法，但是这种模式还是存在漏洞的，具体有什么问题，大家可以停顿一会儿，思考一下。好了，不卖关子了，下面我们来看看每种单例模式存在的问题以及解决办法。&lt;/p&gt;

&lt;ul&gt;&lt;li&gt; 模式一&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LazySingleton
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; LazySingleton lazySingleton = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; LazySingleton()
        {

        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; LazySingleton GetInstance()
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (lazySingleton == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                lazySingleton &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LazySingleton();
            }

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; lazySingleton;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;问题：该模式下在多线程下就会存在问题，因为你不知道线程执行的先后顺序，不信看下面的调试，如下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/896449/201901/896449-20190111190706766-2141505171.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/896449/201901/896449-20190111191016166-1936750544.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们现在让线程Two执行，它会进入到if里面，因为线程one已经被冻结，调试结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/896449/201901/896449-20190111191209634-350867041.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接着，我们把冻结的线程one解冻，执行完成的结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/896449/201901/896449-20190111191417914-1615795998.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;发现，竟然产生了两个实例，这也就说明了上面实现单例模式在多线程下确实存在问题，为了解决在多线程的问题，引出了下面的单例模式。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;模式二：DoubleCheck双重检查&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/896449/201901/896449-20190111193447229-1018118823.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;问题：上面的代码已经加上了lock，可以解决多线程的问题，但是这样还是会出现问题，出现问题的地方在上面的两处断点处。多线程在多核CPU上执行时寄存器缓存和指令的重新排序【也就是new关键字步骤2和步骤3交换】虽然出现的概率很小，但是这种隐患一定要消除。如果出现指令重排的话，一个线程还没来得及把分配对象的指针复制给变量lazySingleton，另外一个线程就会进入到第一个断点的if逻辑里面。下面分别贴出寄存器缓存和指令重新排序的示意图：&lt;/p&gt;
&lt;p&gt;缓存数据示意图：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/896449/201901/896449-20190111221721040-390295702.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（注意：图片来源自https://theburningmonk.com/2010/03/threading-understanding-the-volatile-modifier-in-csharp/）&lt;/p&gt;
&lt;p&gt;现代计算机中的内存很复杂，有多级缓存，处理器寄存器和多个处理器共享主内存等。处理器可能会从主内存中读取数据缓存到寄存器中，另一个线程可能会使用缓存的数据，并且如果修改仅更新主内存，再次期间并发运行在另外一个CPU上的线程，可能读取的还是之前的值。 在此期间，在另一个CPU上并发运行的另一个线程可能已经从主存储器中读取了相同的数据位并使用了过时的数据版本。&lt;/p&gt;
&lt;p&gt;指令重排示意图（下面的示意图来自：geely老师的Java设计模式课程）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/896449/201901/896449-20190111224119507-1164645440.png&quot; alt=&quot;&quot; width=&quot;396&quot; height=&quot;313&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 对于单线程来说既是指令重排也不会影响，但是对于多线程就会有影响，如下图所示：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/896449/201901/896449-20190111224632116-1561201044.png&quot; alt=&quot;&quot; width=&quot;644&quot; height=&quot;306&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了解决上面的问题有两种做法：1）不允许2和3进行指令重排序。2）允许线程0可以重排序但是不允许线程1重排序。&lt;/p&gt;
&lt;p&gt;对于解决办法1：可以使用volatile关键字，它可以禁止重排序以及缓存的问题。&lt;/p&gt;
&lt;p&gt;对于解决办法2：静态内部类-基于类初始化的延迟加。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;模式三：解决办法1示例代码：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/896449/201901/896449-20190111225701945-892369164.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;模式四：解决办法2示例代码：&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; StaticInnerClassSingleton
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; InnerClass
        {
            &lt;/span&gt;&lt;span&gt;internal&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; StaticInnerClassSingleton staticInnerClassSingleton = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StaticInnerClassSingleton();
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; StaticInnerClassSingleton GetInstance()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; InnerClass.staticInnerClassSingleton;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; GetInstancev5()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; hashCode =&lt;span&gt; StaticInnerClassSingleton.GetInstance().GetHashCode();

            Console.WriteLine(hashCode);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;10&lt;/span&gt;; i++&lt;span&gt;)
            {
                Thread thread &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(GetInstancev5);
                thread.Start();

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i%&lt;span&gt;2&lt;/span&gt;==&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                {
                    Thread.Sleep(&lt;/span&gt;&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;);
                }
            }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;验证结果：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/896449/201901/896449-20190111231543811-626397546.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;模式五：饿汉模式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CurrentSingleton
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; CurrentSingleton uniqueInstance = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CurrentSingleton();
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; CurrentSingleton() {
           
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; CurrentSingleton Instance
        {
            &lt;/span&gt;&lt;span&gt;get&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; uniqueInstance; }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt; 聊到这里，关于单例模式的几种模式已经差不多了，该聊的已经聊完了，大多小伙伴们可能就了解到这里就结束了，先舒口气，再继续往下看，你会有意向不到的收获。&lt;/p&gt;


&lt;ul&gt;&lt;li&gt; 问题一：反射攻击单例模式三&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;单例模式三（懒汉模式）代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LazyDoubleCheckSingleton
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; LazyDoubleCheckSingleton lazySingleton = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; _threadSafetyLock = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt;();

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; LazyDoubleCheckSingleton(){}

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; LazyDoubleCheckSingleton GetInstance()
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (lazySingleton == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;lock&lt;/span&gt;&lt;span&gt;(_threadSafetyLock)
                {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (lazySingleton == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                    {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注意：new关键字做了下面三步的工作：
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1、分配内存给这个对象
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2、初始化对象
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3、设置lazySingleton指向刚分配的内存地址&lt;/span&gt;
                        lazySingleton = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LazyDoubleCheckSingleton();
                    }
                }
            }

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; lazySingleton;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/896449/201901/896449-20190112002441501-1078518770.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看到没，我们通过反射也可以创建类的实例，那怕你的构造函数是private的，我通过反射都可以来创建对象的实例。同理你可以尝试使用该方法来攻击模式五（饿汉模式）。&lt;/p&gt;
&lt;p&gt;那我们该如何防御？对于饿汉模式、基于静态类模式的单例，我们可以通过下面的方法来防御：&lt;/p&gt;
&lt;p&gt;在对应的private构造函数中添加一下代码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/896449/201901/896449-20190112004427982-1805298397.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/896449/201901/896449-20190112004700868-2081429382.png&quot; alt=&quot;&quot; width=&quot;722&quot; height=&quot;317&quot;/&gt;&lt;/p&gt;

&lt;p&gt;对于懒汉模式的单例这种方法还适用吗？不一定，请看下面的代码：&lt;/p&gt;
&lt;p&gt;基于模式三【见上】的代码修改：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/896449/201901/896449-20190112005720560-600904108.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/896449/201901/896449-20190112005821362-657391218.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;验证结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/896449/201901/896449-20190112005917551-2031364253.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;发现该方式处理不起作用。对于这个问题我们该怎么解决？尝试的方法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LazyDoubleCheckSingleton
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; LazyDoubleCheckSingleton lazySingleton = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; _threadSafetyLock = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;private static bool flag = true;

        private LazyDoubleCheckSingleton(){
            if (flag)
            {
                flag = false;
            }
            else
            {
                throw new Exception(&quot;单例构造器进制反射调用&quot;);
            }
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; LazyDoubleCheckSingleton GetInstance()
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (lazySingleton == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;lock&lt;/span&gt;&lt;span&gt;(_threadSafetyLock)
                {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (lazySingleton == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                    {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注意：new关键字做了下面三步的工作：
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1、分配内存给这个对象
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2、初始化对象
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3、设置lazySingleton指向刚分配的内存地址&lt;/span&gt;
                        lazySingleton = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LazyDoubleCheckSingleton();
                    }
                }
            }

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; lazySingleton;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
Type type = &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(LazyDoubleCheckSingleton);
            &lt;/span&gt;&lt;span&gt;object&lt;/span&gt; sobj = Activator.CreateInstance(type, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);

            
            Console.WriteLine(LazyDoubleCheckSingleton.GetInstance().GetHashCode());
            Console.WriteLine(sobj.GetHashCode());&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;验证结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/896449/201901/896449-20190112010750529-2117107657.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这种方法看似解决了懒汉模式的问题，但是！它真的能解决这个问题吗？大家可以想一下，为什么解决不了？我也就不卖关子了，原因就是反射，反射的威力太强了，上面演示的，即使你的构造函数是private我也能创建对象，区区一个字段，反射修改你的值不是很轻松吗。&lt;/p&gt;
&lt;p&gt;反射攻击演示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/896449/201901/896449-20190112012706864-440224609.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以懒汉模式的单例，是防御不了反射攻击的，至于Java中有一个叫枚举模式的单例，可以解决这个问题，至于C#目前我还没想出好的解决办法，如果大家有好的解决办法可以贡献到评论区。好了问题一讲到这里已经差不多了，下面我们来介绍问题二。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;问题：序列化破坏单例模式&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;背景：在某些场景下我们需要把类序列化到文件当中，正好这个类是单例的，正常的情况应该是：序列化到文件中，再从文件反序列化，应该是同一个类，但一般的处理方法真的能得到同一个类吗？&lt;/p&gt;
&lt;p&gt;实例代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[Serializable]&lt;br/&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; StaticInnerClassSingleton
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; InnerClass
        {
            &lt;/span&gt;&lt;span&gt;internal&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; StaticInnerClassSingleton staticInnerClassSingleton = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StaticInnerClassSingleton();
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; StaticInnerClassSingleton GetInstance()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; InnerClass.staticInnerClassSingleton;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;序列化到文件：&lt;/span&gt;

            &lt;span&gt;var&lt;/span&gt; obj =&lt;span&gt; StaticInnerClassSingleton.GetInstance();
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; formatter = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BinaryFormatter();
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; stream = &lt;span&gt;new&lt;/span&gt; FileStream(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D:\\Example.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, FileMode.Create, FileAccess.Write);

            formatter.Serialize(stream, obj);
            stream.Close();


            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从文件读取出来反序列化&lt;/span&gt;
&lt;span&gt;
            stream &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; FileStream(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D:\\Example.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, FileMode.Open, FileAccess.Read);

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; obj2 =&lt;span&gt; (StaticInnerClassSingleton)formatter.Deserialize(stream);

            Console.WriteLine(obj.GetHashCode());
            Console.WriteLine(obj2.GetHashCode());&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;验证结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/896449/201901/896449-20190112014003748-1106098007.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看到没，竟然是两个不同的实例，如果大家遇到这样的场景可以使用下面的方法来保障反序列化出来的是同一个对象，我们只需要修改单例模式的类。代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;[Serializable]
    &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; StaticInnerClassSingleton: &lt;strong&gt;&lt;span&gt;ISerializable
    {
        &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; StaticInnerClassSingleton()
        {

        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; InnerClass
        {
            &lt;/span&gt;&lt;span&gt;internal&lt;/span&gt;  &lt;span&gt;static&lt;/span&gt; StaticInnerClassSingleton staticInnerClassSingleton = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StaticInnerClassSingleton();
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; StaticInnerClassSingleton GetInstance()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; InnerClass.staticInnerClassSingleton;
        }

       
        &lt;/span&gt;&lt;strong&gt;&lt;span&gt;public void GetObjectData(SerializationInfo info, StreamingContext context)
        {
            info.SetType(typeof(SingletonHelper));
        }

        [Serializable]
        private class SingletonHelper : IObjectReference
        {
            public object GetRealObject(StreamingContext context)
            {
                return&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; InnerClass.staticInnerClassSingleton;
            }
        }&lt;/span&gt;&lt;/strong&gt;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt; 如果想知道为什么要这样写我就不在解释了，大家可以参考这篇文章：http://geekswithblogs.net/maziar/archive/2012/07/19/serializing-singleton-objects-c.aspx   好了讲到这里基本上单例这种设计模式，你已经掌握的非常好了，希望对你有帮助，谢谢，如果觉得不错的话，可以推荐一下。之前一直想写这个系列的博客，希望把自己平时学的和工作中的经验分享出来，共同进步，这个系列的标题是“从源码中学习设计模式&lt;/p&gt;
&lt;p&gt; 这里的源码主要就是ASP.Net Core2.1的源码，现在.Net Core 3.0已经是预览版，还没有正式版，也希望.Net Core 越来越好。也希望我的文章能对你有帮助。&lt;/p&gt;


&lt;p&gt; 单例这种设计模式，具体使用哪种要看你的使用场景，并不是那种模式一定就好，这是需要权衡的，希望看完本篇文章，你在使用该模式能得心应手。另外大家不要和依赖注入中的单例混淆，之前再介绍依赖注入最佳实践的文章中有园友就混淆了。&lt;/p&gt;



&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;geely老师的《Java设计模式精讲》&lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span&gt;作者：郭峥&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;出处：http://www.cnblogs.com/runningsmallguo/&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Fri, 11 Jan 2019 18:00:00 +0000</pubDate>
<dc:creator>菠萝吹雪—Code</dc:creator>
<og:description>一、前言 这篇文章是学习单例模式的第二篇，之前的文章一下子就给出来看起来很高大上的实现方法，但是这种模式还是存在漏洞的，具体有什么问题，大家可以停顿一会儿，思考一下。好了，不卖关子了，下面我们来看看每</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/runningsmallguo/p/10256677.html</dc:identifier>
</item>
<item>
<title>循环控制结构程序（初学者） - 巫师笔记</title>
<link>http://www.cnblogs.com/lvfengkun/p/10258329.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lvfengkun/p/10258329.html</guid>
<description>&lt;p&gt;循环结构是程序中一种很重要的结构，其特点是在给定条件成立时，反复执行某程序段，直到条件不成立为止。给定的条件称为循环条件，反复执行的程序段称为循环体。C语言提供了多种循环语句，可以组成各种不同形式的循环结构。&lt;/p&gt;
&lt;p&gt;（1）用goto语句和if语句构成循环；&lt;/p&gt;
&lt;p&gt;（2）用while语句；&lt;/p&gt;
&lt;p&gt;（3）用do-while语句；&lt;/p&gt;
&lt;p&gt;（4）用for语句；&lt;/p&gt;
&lt;p&gt;1、goto语句及goto语句构成循环&lt;/p&gt;
&lt;p&gt;goto语句是一种无条件转移语句。使用格式为：goto 语句标号；&lt;/p&gt;
&lt;p&gt;其中标号是一个有效的标识符加上一个“：”一起出现在函数内某处，执行goto后，程序将跳转到该标号处并执行其后语句。另外标号必须与goto语句同处一个函数中，但可以不在一个循环层中。通常goto语句与if语句连用，当满足某一条件时，程序跳到标号处运行。&lt;/p&gt;
&lt;p&gt;注意：goto语句通常不用，主要因为它将使程序层次不清，且不易读，但在多层嵌套退出时，用goto语句则比较合理。&lt;/p&gt;
&lt;p&gt;例：用goto语句和if语句构成循环&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
#include&amp;lt;stdio.h&amp;gt;

&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i,sum=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    i&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
loop:&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(i&amp;lt;=&lt;span&gt;100&lt;/span&gt;&lt;span&gt;)
     {
         sum&lt;/span&gt;=sum+&lt;span&gt;i;
         i&lt;/span&gt;++&lt;span&gt;;
         &lt;/span&gt;&lt;span&gt;goto&lt;/span&gt;&lt;span&gt; loop;
     }
     printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,sum);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;while语句&lt;/p&gt;
&lt;p&gt;while语句一般形式为：while（表达式）语句&lt;/p&gt;
&lt;p&gt;其中表达式是循环条件，语句为循环体。&lt;/p&gt;
&lt;p&gt;while语句语义为：计算表达式的值，当值为真（非0）时，执行循环体语句。其执行过程如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1565269/201901/1565269-20190112001553625-1564849867.jpg&quot; alt=&quot;&quot; width=&quot;150&quot; height=&quot;150&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注：如果表达式的值一开始就为0，则语句一次也不会被执行。&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
include&amp;lt;stdio.h&amp;gt;

&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i,sum=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    i&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(i&amp;lt;=&lt;span&gt;100&lt;/span&gt;&lt;span&gt;)
    {
        sum&lt;/span&gt;=sum+&lt;span&gt;i;
        i&lt;/span&gt;++&lt;span&gt;;
    }
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,sum);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;错误示例：死循环&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
#include&amp;lt;stdio.h&amp;gt;

&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i,sum=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    i&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(i&amp;lt;=&lt;span&gt;100&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;
        sum=sum+&lt;span&gt;i;
        i&lt;/span&gt;++&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;
    printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,sum);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;原因：加了//后，sum=sum+i变为循环语句，则i&amp;lt;=100永远为真，陷入死循环。&lt;/p&gt;
&lt;p&gt;补例：统计从键盘输入一行字符的个数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
#include&amp;lt;stdio.h&amp;gt;

&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; n=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;input a string:\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(getchar()!=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    {
        n&lt;/span&gt;++&lt;span&gt;;
    }
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,n);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Fri, 11 Jan 2019 16:32:00 +0000</pubDate>
<dc:creator>巫师笔记</dc:creator>
<og:description>循环结构是程序中一种很重要的结构，其特点是在给定条件成立时，反复执行某程序段，直到条件不成立为止。给定的条件称为循环条件，反复执行的程序段称为循环体。C语言提供了多种循环语句，可以组成各种不同形式的循</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lvfengkun/p/10258329.html</dc:identifier>
</item>
<item>
<title>【爬虫】听故事的故事人 - 正版乔</title>
<link>http://www.cnblogs.com/qiaohaoforever/p/10258271.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qiaohaoforever/p/10258271.html</guid>
<description>&lt;p&gt;&lt;strong&gt;　　“&lt;/strong&gt; 我每天上班都会经过一个地铁出站口，这个出口平常人不多，有一台长长的扶梯，扶梯下面经常站着一个地铁站务员，她的任务就是看着这列扶梯。每天经过的时候，我都看到她满脸的无聊和困惑，可能她自己也搞不清楚到底为什么要站在这里。&lt;strong&gt;”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;——故事FM&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　昨天看支付宝年度账单，全年出行次数至少335次。来北京两年半，已经不知道多少次走过同一个地铁站，同一个人挤人的地下通道，经过同一个忙碌的人潮。&lt;/p&gt;
&lt;p&gt;　　有时候，疲劳的抬起头可以看到电梯扶手旁的站务员也在满脸疲惫的看着你，眼神中透露出不可言喻的感情，迷惘的人要么埋头前行，要么默念希望，在拥挤的地铁站里，每个人都有自己的故事，每个人也都在为别人的故事增添了些许精彩。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;01&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;—&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;地铁里消失的年轻人&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　“&lt;/strong&gt; 我每天上班都会经过一个地铁出站口，这个出口平常人不多，有一台长长的扶梯，扶梯下面经常站着一个地铁站务员，她的任务就是看着这列扶梯。每天经过的时候，我都看到她满脸的无聊和困惑，可能她自己也搞不清楚到底为什么要站在这里。&lt;strong&gt;”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　一直对熟悉又陌生的地铁站务员的故事充满兴趣，一直也在故事FM聆听别人分享的好故事，《地铁里消失的年轻人》带我认识了这群有故事的人。感兴趣的话，你也可以听听他们的故事，故事里可能也藏着你我。。。&lt;/p&gt;

&lt;p&gt;&lt;span id=&quot;qqmusic_main_219113665_0&quot; class=&quot;db qqmusic_area&quot;&gt;&lt;span class=&quot;db qqmusic_wrp appmsg_card_context appmsg_card_active&quot;&gt;&lt;span class=&quot;db qqmusic_bd&quot;&gt;&lt;span id=&quot;qqmusic_play_219113665_0&quot; class=&quot;play_area&quot;&gt;&lt;img class=&quot;qqmusic_thumb&quot; src=&quot;https://y.gtimg.cn/music/photo_new/T002R90x90M0000019gC8M1TU7ME.jpg&quot; alt=&quot;&quot; data-autourl=&quot;http://isure.stream.qqmusic.qq.com/C200004efMF30jmMhO.m4a?guid=2000001731&amp;amp;vkey=B1BE3D94207C32D28B54B10C28CAB769502CE054601BD7D9D56E40C5A0C546B341D783AE343ED770D6F9D8C01598E0B3A58289632CD86E1C&amp;amp;uin=&amp;amp;fromtag=50&quot; data-musicid=&quot;219113665&quot;/&gt;&lt;span class=&quot;qqmusic_songname&quot;&gt;地铁里消失的年轻人：一个站务员的自述&lt;span class=&quot;qqmusic_singername&quot;&gt;故事FM - 故事FM&lt;span class=&quot;qqmusic_source&quot;&gt;&lt;img src=&quot;https://res.wx.qq.com/mmbizwap/zh_CN/htmledition/images/icon/appmsg/qqmusic/icon_qqmusic_source42f400.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;02&lt;/p&gt;
&lt;p&gt;—&lt;/p&gt;
&lt;p&gt;听故事的故事人&lt;/p&gt;

&lt;p&gt;　　作为《故事FM》的网易云听众，在故事听到“过于真实”的时候，我常常会看看网易云音乐评论，看看有没有人和我一样感同身受，和我一样为故事而感动、喝彩或同情。&lt;/p&gt;
&lt;p&gt;最近将以前的学习的代码整理了一下，增加了网易云音乐电台的评论爬取，看看那些听故事的故事评论人是怎样的人！&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;网易云音乐评论截图&quot; src=&quot;https://img2018.cnblogs.com/blog/1548394/201901/1548394-20190111234816774-1231612078.png&quot; alt=&quot;网易云音乐评论截图&quot; width=&quot;342&quot; height=&quot;352&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　在网易云音乐评论爬取中，值得注意的一点是动态页面加载。&lt;/p&gt;
&lt;p&gt;　　网易云音乐评论采用动态加载的方式翻页更新，打开Chrome的“&lt;span&gt;&lt;code&gt;检查&lt;/code&gt;&lt;/span&gt;”功能切换到“&lt;span&gt;&lt;code&gt;Network&lt;/code&gt;&lt;/span&gt;”,点击“&lt;span&gt;下一页&lt;/span&gt;”会发现地址栏的网址没有变化，但是出现了一条貌似评论API的&lt;code&gt;post&lt;/code&gt;请求，多次点击“下一页”，你会发现&lt;span&gt;&lt;code&gt;Request URL&lt;/code&gt;&lt;/span&gt;没有变化，变化的是&lt;span&gt;&lt;code&gt;Form Data&lt;/code&gt;&lt;/span&gt;，这里就是网易云音乐评论爬虫的精髓了，通过加密页面参数生成新的Form Data，post获取下一页的评论数据，关于网易云音乐评论&lt;code&gt;&lt;span&gt;加密&lt;/span&gt;算法&lt;/code&gt;，网络上有大量文章有进行相关介绍研究，我整理的是来自会讲故事的知乎大佬的加密讲解。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1548394/201901/1548394-20190111235324548-585280405.png&quot; alt=&quot;&quot; width=&quot;1037&quot; height=&quot;620&quot;/&gt;&lt;/p&gt;
&lt;p&gt;网易云音乐评论翻页，Chrome检查页面&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;网易云音乐评论爬虫截图&quot; src=&quot;https://img2018.cnblogs.com/blog/1548394/201901/1548394-20190111235121242-175054547.png&quot; alt=&quot;网易云音乐评论爬虫截图&quot; width=&quot;1548&quot; height=&quot;849&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　通过爬取评论用户ID，用户名，用户头像，评论时间，点赞数和评论详情为下一步数据分析部分做准备。&lt;/p&gt;
&lt;p&gt;　　爬虫部分今天就先说这么多，关注微信公众号：&lt;span&gt;正版乔&lt;/span&gt;，持续了解听故事的故事人，一步一步了解python爬虫，数据库存储，数据分析，数据可视化的全过程。回复「故事评论」查看你想看的细节～&lt;/p&gt;

&lt;p&gt;    同时，大家也可以关注《故事FM》，听听这个世界其他人相同或不同，有趣或无趣的人生故事。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;推荐阅读：&lt;/strong&gt;&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;一个学统计的程序员&lt;/p&gt;
&lt;p&gt;喜欢Coding&lt;/p&gt;
&lt;p&gt;喜欢硬件&lt;/p&gt;
&lt;p&gt;喜欢树莓派&lt;/p&gt;
&lt;p&gt;喜欢深度学习&lt;/p&gt;
&lt;p&gt;喜欢你&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/UlzWLGVsMeaOBBZWR9Nz0bjf504YSm7qbKTRiclhTV2Baf0v6icIUXH15IHZ2CNDGDgo6ycBtTpM3wNlia4PYenwA/640?wx_fmt=jpeg&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-backh=&quot;536&quot; data-backw=&quot;536&quot; data-before-oversubscription-url=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/UlzWLGVsMeaOBBZWR9Nz0bjf504YSm7qbKTRiclhTV2Baf0v6icIUXH15IHZ2CNDGDgo6ycBtTpM3wNlia4PYenwA/0?wx_fmt=jpeg&quot; data-copyright=&quot;0&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;536&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;209&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/UlzWLGVsMeaOBBZWR9Nz0bjf504YSm7qbKTRiclhTV2Baf0v6icIUXH15IHZ2CNDGDgo6ycBtTpM3wNlia4PYenwA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot; data-fail=&quot;0&quot;/&gt; &lt;/p&gt;
</description>
<pubDate>Fri, 11 Jan 2019 15:57:00 +0000</pubDate>
<dc:creator>正版乔</dc:creator>
<og:description>“ 我每天上班都会经过一个地铁出站口，这个出口平常人不多，有一台长长的扶梯，扶梯下面经常站着一个地铁站务员，她的任务就是看着这列扶梯。每天经过的时候，我都看到她满脸的无聊和困惑，可能她自己也</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qiaohaoforever/p/10258271.html</dc:identifier>
</item>
<item>
<title>asp.net core microservices 架构之 分布式自动计算（一） - 无为有道</title>
<link>http://www.cnblogs.com/ck0074451665/p/10258224.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ck0074451665/p/10258224.html</guid>
<description>&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.Logging;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.Options;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; org.apache.zookeeper;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; org.apache.zookeeper.data;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; org.apache.zookeeper.ZooKeeper;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq.Expressions;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; org.apache.zookeeper.Watcher.Event;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Newtonsoft.Json;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Concurrent;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt;  Walt.Framework.Service.Zookeeper
{

    &lt;/span&gt;&lt;span&gt;internal&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt;  WaitLockWatch:Watcher
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; AutoResetEvent _autoResetEvent;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; ILogger _logger;

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; _path;

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; ZookeeperService _zookeeperService;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; _tempNode;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; WaitLockWatch(AutoResetEvent autoResetEvent
        ,ZookeeperService zookeeperService
        ,ILogger logger,&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt; path
        ,&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt; tempNode)
        {
            _autoResetEvent&lt;/span&gt;=&lt;span&gt;autoResetEvent;
            _zookeeperService&lt;/span&gt;=&lt;span&gt;zookeeperService;
            _logger&lt;/span&gt;=&lt;span&gt;logger;
            _path&lt;/span&gt;=&lt;span&gt;path;
            _tempNode&lt;/span&gt;=&lt;span&gt;tempNode;
        }

       &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt;&lt;span&gt; Task process(WatchedEvent @event)
       {
           _logger.LogDebug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{0}节点下子节点发生改变，激发监视方法。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,_path);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; childList=_zookeeperService.GetChildrenAsync(_path,&lt;span&gt;null&lt;/span&gt;,&lt;span&gt;true&lt;/span&gt;&lt;span&gt;).Result;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(childList==&lt;span&gt;null&lt;/span&gt;||childList.Children==&lt;span&gt;null&lt;/span&gt;||childList.Children.Count&amp;lt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
                   {
                        _logger.LogDebug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;获取子序列失败，计数为零.path:{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,_path);
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Task.FromResult(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
                   }
                   &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; top=childList.Children.OrderBy(or=&amp;gt;&lt;span&gt;or).First();
                   &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(_path+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+top==&lt;span&gt;_tempNode)
                   {
                        _logger.LogDebug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;释放阻塞&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                        _autoResetEvent.Set();
                   }
           
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Task.FromResult(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
       }
    }


    &lt;/span&gt;&lt;span&gt;internal&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WaitConnWatch : Watcher
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; AutoResetEvent _autoResetEvent;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; ILogger _logger;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; WaitConnWatch(AutoResetEvent autoResetEvent
        ,ILogger logger)
        {
            _autoResetEvent&lt;/span&gt;=&lt;span&gt;autoResetEvent;
            _logger&lt;/span&gt;=&lt;span&gt;logger;
        }

       &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt;&lt;span&gt; Task process(WatchedEvent @event)
       {
           _logger.LogDebug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;watch激发,回掉状态：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,@event.getState().ToString());
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(@event.getState()==&lt;span&gt; KeeperState.SyncConnected
            &lt;/span&gt;||@event.getState()==&lt;span&gt; KeeperState.ConnectedReadOnly)
            {
                _logger.LogDebug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;释放阻塞&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                _autoResetEvent.Set();
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Task.FromResult(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
       }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ZookeeperService : IZookeeperService
    {

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; requestLockSequence=&lt;span&gt;new&lt;/span&gt; List&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; _lock=&lt;span&gt;new&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; ZookeeperOptions _zookeeperOptions;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; ZooKeeper _zookeeper;

         &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] NO_PASSWORD = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];

         &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Watcher Wathcer {&lt;span&gt;get&lt;/span&gt;;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;;}

         &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ILoggerFactory LoggerFac { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

         &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; ILogger _logger;

         AutoResetEvent[] autoResetEvent&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; AutoResetEvent[&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]
         {&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; AutoResetEvent(&lt;span&gt;false&lt;/span&gt;),&lt;span&gt;new&lt;/span&gt; AutoResetEvent(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;)};

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ZookeeperService(IOptionsMonitor&amp;lt;ZookeeperOptions&amp;gt;&lt;span&gt;  zookeeperOptions
        ,ILoggerFactory loggerFac)
        {
            LoggerFac&lt;/span&gt;=&lt;span&gt;loggerFac;
            _logger&lt;/span&gt;=LoggerFac.CreateLogger&amp;lt;ZookeeperService&amp;gt;&lt;span&gt;();
            _zookeeperOptions&lt;/span&gt;=&lt;span&gt;zookeeperOptions.CurrentValue; 
            _logger.LogDebug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;配置参数：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,JsonConvert.SerializeObject(_zookeeperOptions));
             zookeeperOptions.OnChange((zookopt,s)&lt;/span&gt;=&amp;gt;&lt;span&gt;{
                _zookeeperOptions&lt;/span&gt;=&lt;span&gt;zookopt; 
            });
            _logger.LogDebug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;开始连接&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Conn(_zookeeperOptions); 
        }

       

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Conn(ZookeeperOptions zookeeperOptions)
        {
            &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; isReadOnly=&lt;span&gt;default&lt;/span&gt;&lt;span&gt;(Boolean);
            Wathcer&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; WaitConnWatch(autoResetEvent[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;],_logger);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(isReadOnly!=&lt;span&gt;zookeeperOptions.IsReadOnly)
            {
                isReadOnly&lt;/span&gt;=&lt;span&gt;zookeeperOptions.IsReadOnly;
            }

            
            &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] pwd=&lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果没有密码和sessionId&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(zookeeperOptions.SessionPwd)
            &lt;/span&gt;&amp;amp;&amp;amp;_zookeeperOptions.SessionId==&lt;span&gt;default&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;))
            {
             _zookeeper&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ZooKeeper(zookeeperOptions.Connectstring,zookeeperOptions.SessionTimeout,Wathcer,isReadOnly);
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(zookeeperOptions.SessionPwd))
            {
                pwd&lt;/span&gt;=&lt;span&gt;System.Text.Encoding.Default.GetBytes(zookeeperOptions.SessionPwd);
                 _zookeeper&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; ZooKeeper(zookeeperOptions.Connectstring,zookeeperOptions.SessionTimeout,Wathcer,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,pwd,isReadOnly);
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                 _zookeeper&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ZooKeeper(zookeeperOptions.Connectstring
                 ,zookeeperOptions.SessionTimeout,Wathcer,zookeeperOptions.SessionId,pwd,isReadOnly);
            }
             &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(_zookeeper.getState()==&lt;span&gt;States.CONNECTING)
            {
                _logger.LogDebug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;当前状态：CONNECTING。阻塞等待&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                autoResetEvent[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;].WaitOne();
            }
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Task&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; CreateZNode(&lt;span&gt;string&lt;/span&gt; path,&lt;span&gt;string&lt;/span&gt; data,CreateMode createMode,List&amp;lt;ACL&amp;gt;&lt;span&gt; aclList)
        {
            ReConn();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt;.IsNullOrEmpty(path)||!path.StartsWith(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
            {
                _logger.LogDebug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;path路径非法，参数：path：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,path);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] dat=&lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(data))
            { 
                dat&lt;/span&gt;=&lt;span&gt;System.Text.Encoding.Default.GetBytes(data);
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(createMode==&lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                 _logger.LogDebug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;createMode为null,默认使用CreateMode.PERSISTENT&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                createMode&lt;/span&gt;=&lt;span&gt;CreateMode.PERSISTENT;
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; _zookeeper.createAsync(path,dat,aclList,createMode);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Task&amp;lt;DataResult&amp;gt; GetDataAsync(&lt;span&gt;string&lt;/span&gt; path,Watcher watcher,&lt;span&gt;bool&lt;/span&gt;&lt;span&gt; isSync)
        {
            ReConn();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(_zookeeper.existsAsync(path).Result==&lt;span&gt;null&lt;/span&gt;&lt;span&gt; )
            {
                _logger.LogDebug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;path不存在&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(isSync)
            {
                 _logger.LogDebug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;即将进行同步。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;); 
                 &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; task=Task.Run(&lt;span&gt;async&lt;/span&gt; ()=&amp;gt;&lt;span&gt;{
                    &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; _zookeeper.sync(path);  
                 }); 
                task.Wait();
            }
           

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; _zookeeper.getDataAsync(path,watcher);
        }

         &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Task&amp;lt;Stat&amp;gt; SetDataAsync(&lt;span&gt;string&lt;/span&gt; path,&lt;span&gt;string&lt;/span&gt; data,&lt;span&gt;bool&lt;/span&gt;&lt;span&gt; isSync)
        {
            ReConn();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(_zookeeper.existsAsync(path).Result==&lt;span&gt;null&lt;/span&gt;&lt;span&gt; )
            {
                 _logger.LogDebug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;path不存在&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] dat=&lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(data))
            { 
                dat&lt;/span&gt;=&lt;span&gt;System.Text.Encoding.Default.GetBytes(data);
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; _zookeeper.setDataAsync(path,dat);
        }

         &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;ChildrenResult&amp;gt; GetChildrenAsync(&lt;span&gt;string&lt;/span&gt; path,Watcher watcher,&lt;span&gt;bool&lt;/span&gt;&lt;span&gt; isSync) 
         {
             ReConn();
              &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(_zookeeper.existsAsync(path).Result==&lt;span&gt;null&lt;/span&gt;&lt;span&gt; )
            {
                 _logger.LogDebug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;path不存在&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            }
             &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(isSync)
            {
                 _logger.LogDebug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;即将进行同步。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                 &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; task=Task.Run(&lt;span&gt;async&lt;/span&gt;  ()=&amp;gt;&lt;span&gt;{
                      _logger.LogDebug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;开始同步&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                      &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; _zookeeper.sync(path);  
                 });
                task.Wait();
            }
             &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;await&lt;/span&gt;&lt;span&gt; _zookeeper.getChildrenAsync(path,watcher);
         }

         &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; DeleteNode(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; path,String tempNode)
         {
             &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(tempNode))
             {
                requestLockSequence.Remove(tempNode); 
             }
             ReConn();
              &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(_zookeeper.existsAsync(path).Result==&lt;span&gt;null&lt;/span&gt;&lt;span&gt; )
            {
                 _logger.LogDebug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;path不存在&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;  task=Task.Run(&lt;span&gt;async&lt;/span&gt; ()=&amp;gt;&lt;span&gt;{
                 _logger.LogDebug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;删除node：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,path);
                  &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; _zookeeper.deleteAsync(path);
            });
            task.Wait();
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; sequencePath=requestLockSequence.Where(w=&amp;gt;path==&lt;span&gt;w).FirstOrDefault();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(sequencePath!=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                requestLockSequence.Remove(sequencePath);
            }
         }

         &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;  &lt;span&gt;string&lt;/span&gt; GetDataByLockNode(&lt;span&gt;string&lt;/span&gt; path,&lt;span&gt;string&lt;/span&gt; sequenceName,List&amp;lt;ACL&amp;gt; aclList,&lt;span&gt;out&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; tempNodeOut)
         {
             _logger.LogInformation(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;获取分布式锁开始。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
             ReConn();
             &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; tempNode=&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.Empty;
             tempNodeOut&lt;/span&gt;=&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.Empty;

              &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(_zookeeper.existsAsync(path).Result==&lt;span&gt;null&lt;/span&gt;&lt;span&gt; )
            {
                 _logger.LogDebug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;path不存在&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            }

            
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                _logger.LogDebug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;开始锁定语句块&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;lock&lt;/span&gt;&lt;span&gt;(_lock)
                {
                     _logger.LogDebug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;锁定，访问requestLockSequence的代码应该同步。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    tempNode&lt;/span&gt;=&lt;span&gt;requestLockSequence
                    .Where(w&lt;/span&gt;=&amp;gt;w.StartsWith(path+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+&lt;span&gt;sequenceName)).FirstOrDefault();
                   
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(tempNode==&lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                    {
                        tempNode&lt;/span&gt;=CreateZNode(path+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+sequenceName,&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;,CreateMode.EPHEMERAL_SEQUENTIAL,aclList).Result;
                        _logger.LogDebug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;创建节点：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,tempNode);
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(tempNode==&lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                        {
                            _logger.LogDebug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;创建临时序列节点失败。详细参数:path:{0},data:{1},CreateMode:{2}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                            ,path&lt;/span&gt;+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/squence&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;,CreateMode.EPHEMERAL_SEQUENTIAL);
                            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                        }
                         _logger.LogInformation(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;创建成功，加入requestLockSequence列表。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                        requestLockSequence.Add(tempNode);
                    }
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                    {
                        _logger.LogDebug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;已经存在的锁节点，返回null&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                    }
                }

                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; childList= GetChildrenAsync(path,&lt;span&gt;null&lt;/span&gt;,&lt;span&gt;true&lt;/span&gt;&lt;span&gt;).Result;
                   &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(childList==&lt;span&gt;null&lt;/span&gt;||childList.Children==&lt;span&gt;null&lt;/span&gt;||childList.Children.Count&amp;lt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
                   {
                        _logger.LogDebug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;获取子序列失败，计数为零.path:{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,path);
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                   }
                   _logger.LogDebug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;获取path:{0}的子节点：{1}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,path,Newtonsoft.Json.JsonConvert.SerializeObject(childList.Children));
                   &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; top=childList.Children.OrderBy(or=&amp;gt;&lt;span&gt;or).First();
                   &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] da=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                   &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(path+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+top==&lt;span&gt;tempNode)
                   {
                       tempNodeOut &lt;/span&gt;=&lt;span&gt;tempNode;
                       da&lt;/span&gt;= GetDataAsync(path,&lt;span&gt;null&lt;/span&gt;,&lt;span&gt;true&lt;/span&gt;&lt;span&gt;).Result.Data;
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(da==&lt;span&gt;null&lt;/span&gt;||da.Length&amp;lt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
                        {
                            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;.Empty;
                        } 
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; System.Text.Encoding.Default.GetString(da);
                   }
                   &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                   {
                    childList&lt;/span&gt;= GetChildrenAsync(path,&lt;span&gt;new&lt;/span&gt; WaitLockWatch(autoResetEvent[&lt;span&gt;1&lt;/span&gt;],&lt;span&gt;this&lt;/span&gt;,_logger,path,tempNode),&lt;span&gt;true&lt;/span&gt;&lt;span&gt;).Result;
                    autoResetEvent[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;].WaitOne();
                   }
                    _logger.LogDebug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;继续执行。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    tempNodeOut &lt;/span&gt;=&lt;span&gt;tempNode;
                    da&lt;/span&gt;= GetDataAsync(path,&lt;span&gt;null&lt;/span&gt;,&lt;span&gt;true&lt;/span&gt;&lt;span&gt;).Result.Data;
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(da==&lt;span&gt;null&lt;/span&gt;||da.Length&amp;lt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
                    {
                         &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;.Empty;
                    }
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; System.Text.Encoding.Default.GetString(da);
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(Exception ep)
            {
                 _logger.LogError(ep,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;获取同步锁出现错误。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(tempNode))
                {
                    DeleteNode(tempNode,tempNode);  
                }
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
         }

         &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ReConn()
         {
             _logger.LogInformation(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;检查连接状态&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
             &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(_zookeeper.getState()==&lt;span&gt;States.CLOSED
             &lt;/span&gt;||_zookeeper.getState()==&lt;span&gt; States.NOT_CONNECTED)
             {
                 _logger.LogInformation(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;连接为关闭，开始重新连接。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                Conn(_zookeeperOptions);
             }
         }

         &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Close(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; tempNode)
         {
             &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; task=Task.Run(&lt;span&gt;async&lt;/span&gt; ()=&amp;gt;&lt;span&gt;{ 
             requestLockSequence.Remove(tempNode); 
              &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; _zookeeper.closeAsync();
             });
             task.Wait(); 
         }
 
    }
}&lt;/span&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 11 Jan 2019 15:29:00 +0000</pubDate>
<dc:creator>无为有道</dc:creator>
<og:description>一：简介 自动计算都是常驻内存的，没有人机交互。我们经常用到的就是console job和sql job了。sqljob有自己的宿主，与数据库产品有很关联，暂时不提。console job使用quar</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ck0074451665/p/10258224.html</dc:identifier>
</item>
<item>
<title>全景图转局部平面视图原理详解 - 一度逍遥</title>
<link>http://www.cnblogs.com/riddick/p/10258216.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/riddick/p/10258216.html</guid>
<description>&lt;p&gt;前面两篇博客主要讲了如何从全景图转到小行星、水晶球视图。今天来说下如何从全景图中取一块儿平面视图出来。&lt;/p&gt;
&lt;p&gt;当然最简单的是直接从全景图里画一个ROI，然后扣一块儿区域出来。但是很多时候这样的操作并不方便，如果要是截取的区域跨越了拼接缝的话就麻烦了。&lt;/p&gt;
&lt;p&gt;一劳永逸的方法当然还是将全景图贴到球面去做，假设观察者（比如我）在球内部贴着球面观看，只能看到球的一部分区域。那我不断转动这个球，我就能看到这个球不同位置的局部区域图，因为我贴的很近，我真是闲得慌。&lt;/p&gt;
&lt;p&gt;依然使用下面这张风景秀丽的全景图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1138496/201901/1138496-20190111225735617-449894968.jpg&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;

&lt;p&gt;1.  还是将全景图贴到球面，经纬展开法应该是老方法了。建立球面坐标系，x轴向右，y轴垂直向内，z轴向上，符合右手坐标系。&lt;/p&gt;
&lt;p&gt;2. 仍然采用反向映射的方法，首先在球的南极点放置一张与南极点相切的平面（也就是我们要获取的局部平面图）。&lt;/p&gt;
&lt;p&gt;3.设定视场角FOV，设定要获取的局部平面图的大小（W,H）。我们可以粗略计算出一个归一化的焦距f = (0.5*W)/tan(fov *0.5)。&lt;/p&gt;
&lt;p&gt;4.局部视图上的坐标（u,v），转换到球面坐标系坐标为(x,y,z)：&lt;/p&gt;
&lt;p&gt;　　其中x = u - W*0.5,    y = H*0.5 - v,     z =f&lt;/p&gt;
&lt;p&gt;5. 得到(x, y, z)后就好办了，转换到球坐标（theta, fi）：&lt;/p&gt;
&lt;p&gt;   theta = acos( z/sqrt(x*x+y*y+z*z) ) &lt;/p&gt;
&lt;p&gt;   fi = acos( x/sqrt(x*x+y*y) )   if (y&amp;lt;0)    fi=2*pi - fi&lt;/p&gt;
&lt;p&gt;6.  得到球坐标后就可以获取全景图的坐标（U, V），如果全景图的尺寸是（panoW, panoH）：&lt;/p&gt;
&lt;p&gt; U = fi * panoW/ (2 * pi);&lt;/p&gt;
&lt;p&gt; V = theta * panoH / pi;&lt;/p&gt;
&lt;p&gt;7. 老样子，双线性插值，从(U,V)周围四个点插值得到（u,v）。&lt;/p&gt;
&lt;p&gt;这样就获取了南极点一小片区域的平面图。那如果我需要观看其他位置，我又懒地跑过去贴上去，我只用转动球就行。也就是在第5步中，对x, y, z施加一个旋转矩阵R，得到新的X, Y, Z 后再投影即可。&lt;/p&gt;

&lt;p&gt;利用上述方法再也不担心跨越拼接缝的问题了，想看哪里看哪里。生成一段环视赤道的局部平面图，fov为75度，如下图所示，头好晕：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1138496/201901/1138496-20190111232530736-847435360.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 11 Jan 2019 15:28:00 +0000</pubDate>
<dc:creator>一度逍遥</dc:creator>
<og:description>前面两篇博客主要讲了如何从全景图转到小行星、水晶球视图。今天来说下如何从全景图中取一块儿平面视图出来。 当然最简单的是直接从全景图里画一个ROI，然后扣一块儿区域出来。但是很多时候这样的操作并不方便，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/riddick/p/10258216.html</dc:identifier>
</item>
<item>
<title>mysql 和 sqlserver中备份一张表的区别 - 夏天里的Jasmine</title>
<link>http://www.cnblogs.com/qianjinyan/p/10258196.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qianjinyan/p/10258196.html</guid>
<description>&lt;p&gt;&lt;span&gt;sqlserver中备份一张表&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SELECT * into qa_buglist_bak FROM qa_buglist &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不管表的数据有多大，速度很快；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;mysql中上述语句就无效了，须得新建一张表，然后让此长表中新增数据&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;create table qa_buglist_bak like qa_buglist;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;insert qa_buglist_bak select * from qa_buglist;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果原表中数据量大，就特别慢，很吃硬盘和CPU&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1064427/201901/1064427-20190111231804470-1978696633.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;刚刚看了下，也就800万行的数据。。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1064427/201901/1064427-20190111233001861-757517177.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 我应该先导出到sql文件中，再新增到备份表中的。。。(┬＿┬)&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 11 Jan 2019 15:19:00 +0000</pubDate>
<dc:creator>夏天里的Jasmine</dc:creator>
<og:description>sqlserver中备份一张表 SELECT * into qa_buglist_bak FROM qa_buglist 不管表的数据有多大，速度很快； mysql中上述语句就无效了，须得新建一张表，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qianjinyan/p/10258196.html</dc:identifier>
</item>
<item>
<title>2018年终总结--修身篇 - 虚生</title>
<link>http://www.cnblogs.com/dylancao/p/10258145.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dylancao/p/10258145.html</guid>
<description>&lt;p&gt;　　其实，每个人在不同的人生阶段都有不同的想法和梦想。曾经的我，就想一直念到博士，在高校当一个老师，享受自由自在的生活。曾经的我，是多么的喜欢国学和历史，有很长一段时间，我就只是想当一个国学老师。命运往往会让人遇到很多无法规划的意外和改变。等毕业的时候，发现自己的家境，拿着大学里那么一点点薪水，生存都是问题。还谈什么研究历史呢。在再三权衡后，还是选择了江湖，选择了以写代码为生的码农。读了那么多年的书，虽然是浪迹江湖，仍然把自己当成一个知识分子，一个深受儒家思想影响的中国人。&lt;br/&gt;　　在过去的几年中，陆陆续续读了一些儒家经典，特别是对儒学中的慎独的知行合一深信不已，并把这些奉为人生的信条，在生活中，也越来越体味到儒家文化的厉害之处。所以在过去的2018年中，针对自己遇事慌乱，学习容易急躁的问题。定了一些修身方面的目标的，希望在日常的修为中改变一些自己的毛病。其中最重要的一项就是静，古人云，静以修身，意思就是修身的第一步就是静。　　&lt;br/&gt;　　针对自己遇到的问题，我定制了时刻检讨自己是否达到静的境界。经过一年的自我检讨，容易激动的情况是少了很多，面对很多事情，也不再喜怒无常，焦虑万分，很多时候，学会了保持一份平静和淡然。&lt;br/&gt;　　当遇到家庭变故时，不再像以前那样感觉天塌地陷一样。而是冷静的安顿现场，有条不紊的打理家中的大大小小事情，承担起来一个长子应该承担的责任和义务。不再为一些家庭琐事而争吵。&lt;br/&gt;　　当工作遇到重大危机，我不再像以前那样寝食难安。而是平静的面对现实，接受失败，找出自身的不足，改成并迎接下一次的挑战。&lt;br/&gt;修身的终极目标是慎独，这两个字的分量，可以称得上是儒家修身的终极目标。能达到这样修为的人的确是少数，从去年接触到这个信条之后，我也一直揣摩这个词的含义，拿生活中的一切起丈量，发现这方面还是一时半会很难做到的。自己承认在这方面做的不够好，很多时候，以为别人不知道，就可以自欺欺人，这算是什么慎独啊。在过去的2018中，针对这方面我还是做的不够好，特别是没人监督的时候，不能够把握好度。在接下来的2019中，要时刻不忘修身的慎独。每周都要写一下这方面的自身那些地方做的不好。&lt;br/&gt;所谓修身，我的理解不仅仅是精神，身体的素质同样重要，其实，在2018年，自己在身体锻炼方面做的要比2017好，很长一段时间，都坚持练太极拳，打篮球，长跑，身体素质明显好转，可是随着冬季的到来还下雨，以及后面的生活不规律，就容易把身体锻炼丢掉。这点在未来的2019年中要想一想办法，看看怎么达到一个身体锻炼要保持的频度。就像写日记一样，都不能丢。要把它当成每日的功课来做。以后要分两个时间锻炼，早上和晚上，早上没锻炼就还要把事情放到晚上，这点坚决不能丢。&lt;br/&gt;　　慎独则心安、主敬则身强、求仁则人悦、习劳则神钦。修身是一辈子要做的事情。2018就这样在懵懂中过去了，接下来的2019，要用更严厉的方法来要求自己，在追求慎独的境界上一路前行。&lt;br/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 11 Jan 2019 14:55:00 +0000</pubDate>
<dc:creator>虚生</dc:creator>
<og:description>其实，每个人在不同的人生阶段都有不同的想法和梦想。曾经的我，就想一直念到博士，在高校当一个老师，享受自由自在的生活。曾经的我，是多么的喜欢国学和历史，有很长一段时间，我就只是想当一个国学老师。命运往往</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dylancao/p/10258145.html</dc:identifier>
</item>
<item>
<title>iOS 微信支付SDK与微信友盟分享两者同时集成时，出现的问题与解决之路。 - 滴水微澜</title>
<link>http://www.cnblogs.com/zhou--fei/p/10257730.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhou--fei/p/10257730.html</guid>
<description>&lt;p&gt;这两天改版一个旧的APP，要旧貌换新颜，拿到app后进行编译，一直报下面的错误。&lt;/p&gt;
&lt;p&gt;报不认识的符号名PayReq错误。奇怪，啥也没动就这样，真不知道给的包是不是本来就是个报错的工程。&lt;/p&gt;
&lt;p&gt;不管怎样，要对它修改就先要跑起来啊。&lt;/p&gt;

&lt;div readability=&quot;10&quot;&gt;
&lt;p&gt;根据错误提示，判断是libwechatsdk.a里面没有这个方法。顺藤摸瓜按照下面的步骤开始了解决旅途。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;阶段一&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;18&quot;&gt;
&lt;p&gt;1. 手动添加了微信支付SDK源码到工程 &lt;/p&gt;
&lt;p&gt;2. pod 'UMengUShare/Social/WeChat’添加了微信分享，&lt;/p&gt;
&lt;p&gt;编译时报错如下：&lt;/p&gt;
&lt;div readability=&quot;28.5&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/826860/201901/826860-20190111223740034-934149889.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;说明导入的微信支付SDK中并没有微信支付调用接口的实现。这可能是复制的微信支付SDK有问题（老项目中带的，不知道来源是哪里）。那用pod方式就换成最新的吧。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;阶段二&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1. pod ‘WechatOpenSDK' 添加最新的微信支付sdk&lt;/p&gt;
&lt;p&gt;2. pod 'UMengUShare/Social/WeChat’添加了微信分享&lt;/p&gt;
&lt;p&gt;Pod时报错如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/826860/201901/826860-20190111223900995-447833341.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;提示libwechatsdk.a已经存储。&lt;/p&gt;
&lt;p&gt;于是在工程搜一下：&lt;/p&gt;
&lt;div readability=&quot;14&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/826860/201901/826860-20190111223919575-1096350579.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;果然libwechatsdk.a已经被友盟分享下载过了，可不是要报这个错吗。&lt;/p&gt;
&lt;p&gt;步骤走到这里，看上去基本无解了，两者都包含，肯定无法都下载啊，这可咋办呢，喝杯水冷静下。&lt;/p&gt;

&lt;div readability=&quot;13&quot;&gt;
&lt;p&gt;我可以搜一下“如何用pod集成微信支付与友盟分享”啊.&lt;/p&gt;
&lt;p&gt;在网上搜了一下，果然发现了有相似问题的文章。&lt;/p&gt;
&lt;p&gt;发现友盟微信分享是分完整版和精简版的，感情我现在下的是完整版啊，所以才产生了冲突，那要找不包含libwechatsdk.a的版本，其实就是找精简版的了。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;那就在网上找找友盟微信分享精简版的pod地址，贴上去就好了。&lt;/p&gt;
&lt;p&gt;赶紧google一下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/826860/201901/826860-20190111224052991-273997483.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;果然，看到了胜利的曙光。&lt;/p&gt;
&lt;p&gt;于是迫不及待的替换掉pod 'UMengUShare/Social/WeChat’试一下。&lt;/p&gt;

&lt;div readability=&quot;12&quot;&gt;
&lt;p&gt;&lt;strong&gt;阶段三&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1. pod ‘WechatOpenSDK' 添加最新的微信支付sdk&lt;/p&gt;
&lt;p&gt;2. pod 'UMengUShare/Social/ReducedWeChat' 添加友盟精简版微信分享&lt;/p&gt;

&lt;p&gt;Pod install 结果如下：&lt;/p&gt;
&lt;div readability=&quot;16.5&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/826860/201901/826860-20190111224407966-914321404.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;OK了&lt;/p&gt;

&lt;p&gt;builde一下，success通过。&lt;/p&gt;

&lt;div readability=&quot;24&quot;&gt;
&lt;p&gt;通过查看WXApiObject.h文件声明发现&lt;/p&gt;
&lt;p&gt;'WechatOpenSDK' 库其实 和‘UMengUShare/Social/WeChat’这个库很类似，里面暴露的接口几乎一样。&lt;/p&gt;
&lt;p&gt;说明两种重复定义实现了大部分内容。&lt;/p&gt;

&lt;p&gt;两者的区别是'WechatOpenSDK'库中的WXApiObject类多了一个第三方向微信终端发起支付的消息结构体，&lt;/p&gt;
&lt;p&gt;在这个类中声明了个 @interface PayReq : BaseReq&lt;/p&gt;
&lt;p&gt;来唤起微信的支付功能。&lt;/p&gt;

&lt;p&gt;所以要同时实现微信支付和友盟微信分享&lt;/p&gt;
&lt;p&gt;需要用友盟微信分享的精简版pod 'UMengUShare/Social/ReducedWeChat’与微信支付SDK pod ‘WechatOpenSDK’。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Fri, 11 Jan 2019 14:47:00 +0000</pubDate>
<dc:creator>滴水微澜</dc:creator>
<og:description>这两天改版一个旧的APP，要旧貌换新颜，拿到app后进行编译，一直报下面的错误。 报不认识的符号名PayReq错误。奇怪，啥也没动就这样，真不知道给的包是不是本来就是个报错的工程。 不管怎样，要对它修</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhou--fei/p/10257730.html</dc:identifier>
</item>
</channel>
</rss>