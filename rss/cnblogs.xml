<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>sap abap 流水号设置 - 木子水皮</title>
<link>http://www.cnblogs.com/libo2019/p/10733362.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/libo2019/p/10733362.html</guid>
<description>&lt;p&gt;1.TCODE:SNRO，进入如图所示界面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1588083/201904/1588083-20190418233832808-1224605140.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1588083/201904/1588083-20190418233846325-967875565.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1588083/201904/1588083-20190418233854432-16409932.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.&lt;/p&gt;
&lt;p&gt;　　短文本和长文本用来说明这个编号范围对象，输入任意描述即可。     &lt;/p&gt;
&lt;p&gt;　　子对象数据元素我们这里不填。这里需要说明一下，所谓子对象，多数指一个组织结构，比如公司代码、销售组织、工厂等，这样编号就在对应的每个组织下面独立编号，最典型的例子是财务凭证，每个公司代码下的财务凭证都是独立编号的（其对应的数据表 BKPF，也必定把公司代码做为一个键字段）。而我们这个调度单对应于销售订单，销售订单没有按照组织级别分别编号，因此相应的调度单也就不需要了。      到期年标记是指编号按年度归零，每当开始一个新年度时，相应的编号也需要从头开始，比如财务凭证和物料凭证都是这样（比如表BKPF 和MKPF，都把年度做为一个键字段） ，而我们的调度单不需要对应年度，因此这里也不打勾。 &lt;/p&gt;
&lt;p&gt;　　编号长度域就填创建的域，但是一定要先激活。指定这个编号范围对象 YLBPP001的长度，我们定义域长度为 10，因此这个编号范围对象生成的编号长度也是 10 位。  无滚动是指如果编号达到最大，是否自动从头开始，勾上就不从头开始，而在获取编号的时候提示出错。我们这里应该打勾。  &lt;/p&gt;
&lt;p&gt;　　 编号范围处理，属于翻译问题，实际就是编号范围的事务码，如果指定这个事务码，就可以不需要通过 SNUM 或者 SNRO 的主屏幕然后输入编号范围对象的名字来维护这个编号范围，而可以输入事务码直接进入它的号码范围维护屏幕。   &lt;/p&gt;
&lt;p&gt;　　 警告百分比是指如果编号使用到一定比例，就发出系统警告，提示管理人员增大范围或者进行历史数据归档，避免编号全部用完后影响正常业务，这里我们填写 95，就是95%的时候提示。   &lt;/p&gt;
&lt;p&gt;　　 主内存缓冲是指系统为了提高性能而预先取出一些编号放在应用服务器上，当程序取用编号时直接从应用服务器获取，而无需再读取数据库了。通常，如果对号码的连续性要求不高的情况下可以使用这种方式，而如果是财务凭证等要求连续的编号，则应该把主内存缓冲关闭。&lt;/p&gt;

&lt;p&gt;3. 程序读取：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
      &lt;span&gt;CALL&lt;/span&gt; &lt;span&gt;FUNCTION&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;NUMBER_RANGE_ENQUEUE&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
        &lt;span&gt;EXPORTING&lt;/span&gt;
          &lt;span&gt;object&lt;/span&gt;           = &lt;span&gt;'YLBPP001&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;这个就是流水号对象&lt;/span&gt;
        &lt;span&gt;EXCEPTIONS&lt;/span&gt;&lt;span&gt;
          foreign_lock     &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;
          object_not_found &lt;/span&gt;= &lt;span&gt;2&lt;/span&gt;&lt;span&gt;
          system_failure   &lt;/span&gt;= &lt;span&gt;3&lt;/span&gt;&lt;span&gt;
          OTHERS           &lt;/span&gt;= &lt;span&gt;4&lt;/span&gt;&lt;span&gt;.
      &lt;/span&gt;&lt;span&gt;IF&lt;/span&gt; sy-subrc &lt;span&gt;EQ&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;.


        &lt;/span&gt;&lt;span&gt;CALL&lt;/span&gt; &lt;span&gt;FUNCTION&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;NUMBER_GET_NEXT&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
          &lt;span&gt;EXPORTING&lt;/span&gt;&lt;span&gt;
            nr_range_nr             &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;                &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;这个就是维护的间隔号&lt;/span&gt;
            &lt;span&gt;object&lt;/span&gt;                  = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;YLBPP001&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;          &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;这个就是流水号对象&lt;/span&gt;&lt;span&gt;
*&lt;/span&gt;&lt;span&gt;           QUANTITY                = '1'&lt;/span&gt;&lt;span&gt;
*&lt;/span&gt;&lt;span&gt;           SUBOBJECT               = ' '&lt;/span&gt;&lt;span&gt;
*&lt;/span&gt;&lt;span&gt;           TOYEAR                  = '0000'&lt;/span&gt;&lt;span&gt;
*&lt;/span&gt;&lt;span&gt;           IGNORE_BUFFER           = ' '&lt;/span&gt;
          &lt;span&gt;IMPORTING&lt;/span&gt;&lt;span&gt;
            number                  &lt;/span&gt;= wa_data-zz_code           &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;获得的流水号&lt;/span&gt;&lt;span&gt;
*&lt;/span&gt;&lt;span&gt;           QUANTITY                =&lt;/span&gt;&lt;span&gt;
*&lt;/span&gt;&lt;span&gt;           RETURNCODE              =&lt;/span&gt;
          &lt;span&gt;EXCEPTIONS&lt;/span&gt;&lt;span&gt;
            interval_not_found      &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;
            number_range_not_intern &lt;/span&gt;= &lt;span&gt;2&lt;/span&gt;&lt;span&gt;
            object_not_found        &lt;/span&gt;= &lt;span&gt;3&lt;/span&gt;&lt;span&gt;
            quantity_is_0           &lt;/span&gt;= &lt;span&gt;4&lt;/span&gt;&lt;span&gt;
            quantity_is_not_1       &lt;/span&gt;= &lt;span&gt;5&lt;/span&gt;&lt;span&gt;
            interval_overflow       &lt;/span&gt;= &lt;span&gt;6&lt;/span&gt;&lt;span&gt;
            buffer_overflow         &lt;/span&gt;= &lt;span&gt;7&lt;/span&gt;&lt;span&gt;
            OTHERS                  &lt;/span&gt;= &lt;span&gt;8&lt;/span&gt;&lt;span&gt;.

        &lt;/span&gt;&lt;span&gt;IF&lt;/span&gt; sy-subrc &amp;lt;&amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;.
&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt; Implement suitable error handling here&lt;/span&gt;
        &lt;span&gt;ENDIF&lt;/span&gt;&lt;span&gt;.

&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;      *  ***将号码累加&lt;/span&gt;
        &lt;span&gt;CALL&lt;/span&gt; &lt;span&gt;FUNCTION&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;NUMBER_RANGE_DEQUEUE &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
          &lt;span&gt;EXPORTING&lt;/span&gt;
            &lt;span&gt;object&lt;/span&gt;           = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;YLBPP001&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
          &lt;span&gt;EXCEPTIONS&lt;/span&gt;&lt;span&gt;
            object_not_found &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;
            OTHERS           &lt;/span&gt;= &lt;span&gt;2&lt;/span&gt;.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;很容易理解，首先判断是否有这个number range，如果存在的话，就获得下个序号，&lt;/p&gt;
&lt;p&gt;最后一个函数估计是释放这个全局变量的内存(资源)。&lt;span data-mce-=&quot;&quot;&gt;'&lt;span data-mce-=&quot;&quot;&gt;YLBPP001&lt;span data-mce-=&quot;&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;就是我们创建的number range。如此就可以像会计凭证编号那样每次都可以自动生成流水号了！&lt;/p&gt;
&lt;p&gt;流水号可以在自建表中用作主键。&lt;/p&gt;

</description>
<pubDate>Thu, 18 Apr 2019 15:43:00 +0000</pubDate>
<dc:creator>木子水皮</dc:creator>
<og:description>1.TCODE:SNRO，进入如图所示界面 2. 短文本和长文本用来说明这个编号范围对象，输入任意描述即可。 子对象数据元素我们这里不填。这里需要说明一下，所谓子对象，多数指一个组织结构，比如公司代码</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/libo2019/p/10733362.html</dc:identifier>
</item>
<item>
<title>理解 Node.js 的 Event loop - 刘哇勇</title>
<link>http://www.cnblogs.com/Wayou/p/understanding_event_loop.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Wayou/p/understanding_event_loop.html</guid>
<description>
&lt;h2&gt;问题&lt;/h2&gt;
&lt;p&gt;考察如下代码，脑回路中运行并输出结果：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;1&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);

&lt;span class=&quot;pl-c1&quot;&gt;setTimeout&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;setTimeout1&lt;/span&gt;() {
  &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;2&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
  &lt;span class=&quot;pl-c1&quot;&gt;process&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;nextTick&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;nextTick1&lt;/span&gt;() {
    &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;3&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
  });
  &lt;span class=&quot;pl-k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Promise&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;promise1&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;resolve&lt;/span&gt;) {
    &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;4&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
    &lt;span class=&quot;pl-en&quot;&gt;resolve&lt;/span&gt;();
  }).&lt;span class=&quot;pl-c1&quot;&gt;then&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;promiseThen1&lt;/span&gt;() {
    &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;5&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
  });
  &lt;span class=&quot;pl-en&quot;&gt;setImmediate&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;immediate1&lt;/span&gt;() {
    &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;immediate&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
  });
});

&lt;span class=&quot;pl-c1&quot;&gt;process&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;nextTick&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;nextTick2&lt;/span&gt;() {
  &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;6&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
});

&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;bar&lt;/span&gt;() {
  &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;bar&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
}

&lt;span class=&quot;pl-k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;foo&lt;/span&gt;() {
  &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;async start&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
  &lt;span class=&quot;pl-k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;bar&lt;/span&gt;();
  &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;async end&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
}

&lt;span class=&quot;pl-en&quot;&gt;foo&lt;/span&gt;();

&lt;span class=&quot;pl-k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Promise&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;promise2&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;resolve&lt;/span&gt;) {
  &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;7&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
  &lt;span class=&quot;pl-en&quot;&gt;resolve&lt;/span&gt;();
}).&lt;span class=&quot;pl-c1&quot;&gt;then&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;promiseThen2&lt;/span&gt;() {
  &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;8&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
});

&lt;span class=&quot;pl-c1&quot;&gt;setTimeout&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;setTimeout2&lt;/span&gt;() {
  &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;9&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
  
  &lt;span class=&quot;pl-k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Promise&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;promise3&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;resolve&lt;/span&gt;) {
    &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;11&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
    &lt;span class=&quot;pl-en&quot;&gt;resolve&lt;/span&gt;();
  }).&lt;span class=&quot;pl-c1&quot;&gt;then&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;promiseThen3&lt;/span&gt;() {
    &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;12&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
  });

  &lt;span class=&quot;pl-c1&quot;&gt;process&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;nextTick&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;nextTick3&lt;/span&gt;() {
    &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;10&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
  });
});
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;JS 事件循环&lt;/h2&gt;
&lt;p&gt;JS 是单线程，朴素地讲，同时只能完成一件事件。如果有耗时的任务，那后续的所有任务都要等待其完成才能执行。&lt;/p&gt;
&lt;p&gt;为了避免这种阻塞，引入了事件循环。即，将代码的执行分成一个个很小的阶段（一次循环），每个阶段重复相应的事情，直到所有任务都完成。&lt;/p&gt;
&lt;p&gt;一个阶段包含以下部分：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Timers：到期的定时器任务，&lt;code&gt;setTimeout&lt;/code&gt;，&lt;code&gt;setInterval&lt;/code&gt; 等注册的任务。&lt;/li&gt;
&lt;li&gt;IO Callbacks：IO 操作，比如网络请求，文件读写。&lt;/li&gt;
&lt;li&gt;IO Polling：IO 任务的注册&lt;/li&gt;
&lt;li&gt;Set Immediate：通过 &lt;code&gt;setImmediate&lt;/code&gt; 注册的任务&lt;/li&gt;
&lt;li&gt;Close：&lt;code&gt;close&lt;/code&gt; 事件的回调，比如 TCP 的断开。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://user-images.githubusercontent.com/3783096/51124121-80498000-1858-11e9-8c69-33c760b08904.png&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/3783096/51124121-80498000-1858-11e9-8c69-33c760b08904.png&quot; alt=&quot;image&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;Ticks and Phases of the Node.js Event Loop &lt;em&gt;图片来自 Daniel Khan 的 Medium 博客，见文末&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;同步代码及上面每个环节结束时都会清空一遍微任务队列，记住这点很重要！&lt;/p&gt;
&lt;h2&gt;代码执行流程&lt;/h2&gt;
&lt;p&gt;执行的流程是，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;将代码顺序执行。&lt;/li&gt;
&lt;li&gt;遇到异步任务，将任务压入待执行队列后继续往下。&lt;/li&gt;
&lt;li&gt;完成同步代码后，检查是否有微任务（通过 &lt;code&gt;Promise&lt;/code&gt;，&lt;code&gt;process.nextTick&lt;/code&gt;，&lt;code&gt;async/await&lt;/code&gt; 等注册），如果有，则清空。&lt;/li&gt;
&lt;li&gt;清空微任务队列后，从待执行队列中取出最先压入的任务顺序执行，重复步骤一。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;另，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;async/await&lt;/code&gt; 本质上是 &lt;code&gt;Promise&lt;/code&gt;，所以其表现会和 Promise 一致。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;process.nextTick&lt;/code&gt; 注册的回调优先级高于定时器。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;setImmediate&lt;/code&gt; 可看成 Node 版本的 &lt;code&gt;setTimeout&lt;/code&gt;，所以可与后者同等对待。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;示例代码分析&lt;/h2&gt;
&lt;h3&gt;Round 1&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;首先遇到同步代码 &lt;code&gt;console.log(1)&lt;/code&gt;，立即执行输出 &lt;code&gt;1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;接下来是一个 &lt;code&gt;setTimeout&lt;/code&gt; 定时器，将其回调压入待执行队列 &lt;code&gt;[setTimeout1]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;遇到 &lt;code&gt;process.nextTick&lt;/code&gt;，将其回调 &lt;code&gt;nextTick2&lt;/code&gt; 压入微任务队列 &lt;code&gt;[nextTick2]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;然后是 async 函数 &lt;code&gt;foo&lt;/code&gt; 的调用，立即执行并输出 &lt;code&gt;async start&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;然后是 &lt;code&gt;await&lt;/code&gt; 语句，这所在的地方会创建并返回 Promise，所以这里会执行其后面的表达式，也就是 &lt;code&gt;bar()&lt;/code&gt; 函数的调用。&lt;/li&gt;
&lt;li&gt;执行 &lt;code&gt;bar&lt;/code&gt; 函数，输出 &lt;code&gt;bar&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在执行了 &lt;code&gt;await&lt;/code&gt; 后面的语句后，它所代表的 Promise 就创建完成了，&lt;code&gt;foo&lt;/code&gt; 函数体后续的代码相当于 promise 的 &lt;code&gt;then&lt;/code&gt;，放入微任务队列 &lt;code&gt;[nextTick2, rest_of_foo]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;继续往下遇到 &lt;code&gt;new Promise&lt;/code&gt;，执行 Promise 的创建输出 &lt;code&gt;7&lt;/code&gt;，将它的 &lt;code&gt;then&lt;/code&gt; 回调压入微任务队列 &lt;code&gt;[nextTick2, rest_of_foo,promiseThen2]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;遇到另一个 &lt;code&gt;setTimeout&lt;/code&gt;，回调压入待执行队列 &lt;code&gt;[setTimeout1，setTimeout2]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;至此，代码执行完了一轮。此时的输出应该是 &lt;code&gt;1, async start, bar,7&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;Round 2&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;查看微任务队列，并清空。所以依次执行 &lt;code&gt;[nextTick2, rest_of_foo,promiseThen2]&lt;/code&gt;，输出 &lt;code&gt;6,async end,8&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;Round 3&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;查看待执行队列 &lt;code&gt;[setTimeout1，setTimeout2]&lt;/code&gt;，先执行 &lt;code&gt;setTimout1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;遇到 &lt;code&gt;console.log(2)&lt;/code&gt; 输出2&lt;/li&gt;
&lt;li&gt;遇到 &lt;code&gt;process.nextTick&lt;/code&gt; 将 &lt;code&gt;nextTick1&lt;/code&gt; 压入微任务队列 &lt;code&gt;[nextTick1]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;遇到 &lt;code&gt;new Promise&lt;/code&gt; 立即执行 输出 &lt;code&gt;4&lt;/code&gt;，执行 &lt;code&gt;resolve()&lt;/code&gt; 后将 &lt;code&gt;promiseThen1&lt;/code&gt; 压入微任务队列 &lt;code&gt;[nextTick1,promiseThen1]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;遇到 &lt;code&gt;setImmediate&lt;/code&gt; 将回调压入待执行队列 &lt;code&gt;[setTimeout2,immediate1]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;此时 &lt;code&gt;setTimeout1&lt;/code&gt; 执行完毕，此时的输出应该为 &lt;code&gt;2,4&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;Round 4&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;检查微任务队列 &lt;code&gt;[nextTick1,promiseThen1]&lt;/code&gt; 依次执行并输出 &lt;code&gt;3,5&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;Round 5&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;检查待执行队列 &lt;code&gt;[setTimeout2,immediate1]&lt;/code&gt;,执行 &lt;code&gt;setTimeout2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;遇到 &lt;code&gt;console&lt;/code&gt;输出 &lt;code&gt;9&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;遇到 &lt;code&gt;new Promise&lt;/code&gt; 执行并输出 &lt;code&gt;11&lt;/code&gt;,将 &lt;code&gt;promiseThen3&lt;/code&gt; 压入微任务队列 &lt;code&gt;[promiseThen3]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;遇到 &lt;code&gt;process.nextTick&lt;/code&gt; 将 &lt;code&gt;nextTick3&lt;/code&gt; 压入微执行队列。注意，因为 &lt;code&gt;process.nextTick&lt;/code&gt; 的优化级高于 Promise，所以压入后的结果是： &lt;code&gt;[nextTick3,promiseThen3]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;此时 &lt;code&gt;setTimeout2&lt;/code&gt; 执行完毕，输出为 &lt;code&gt;9,11&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;Round 6&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;检查微任务队列 &lt;code&gt;[nextTick3，promiseThen3]&lt;/code&gt; 执行并输出 &lt;code&gt;10,12&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;Round 7&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;检查待执行队列 &lt;code&gt;[immediate1]&lt;/code&gt;，执行并输出 &lt;code&gt;immediate&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;至此，走完了所有代码。&lt;/p&gt;
&lt;h2&gt;结果&lt;/h2&gt;
&lt;p&gt;以下是文章开头的结果：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
1
async start
bar
7
6
async end
8
2
4
3
5
9
11
10
12
immediate
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;参考&lt;/h3&gt;
</description>
<pubDate>Thu, 18 Apr 2019 15:33:00 +0000</pubDate>
<dc:creator>刘哇勇</dc:creator>
<og:description>问题 考察如下代码，脑回路中运行并输出结果： console.log('1'); setTimeout(function setTimeout1() { console.log('2'); proce</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Wayou/p/understanding_event_loop.html</dc:identifier>
</item>
<item>
<title>MyDAL - .Where() 之 .WhereSegment 根据条件 动态设置 Select查询条件 使用 - Meng.NET</title>
<link>http://www.cnblogs.com/Meng-NET/p/10733275.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Meng-NET/p/10733275.html</guid>
<description>&lt;p&gt;&lt;strong&gt;索引：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/Meng-NET/p/8963476.html&quot; target=&quot;_blank&quot;&gt;目录索引&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一.API 列表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　1.WhereSegment 属性，指示 &lt;strong&gt;根据条件 动态拼接&lt;/strong&gt; where 查询过滤条件&lt;/p&gt;
&lt;p&gt;　　　　见如下示例.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二.API 单表-完整 方法 举例&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 上下文条件 变量&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; userId = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;08d6036b-0a7e-b07d-b9bd-af03841b3baa&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; firstName = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;伏&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; = Conn.Queryer&amp;lt;Agent&amp;gt;&lt;span&gt;()&lt;strong&gt;.WhereSegment&lt;/strong&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据条件 判断 是否 拼接 UserId 字段 的 过滤条件&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;userId.IsNullStr())
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 &lt;span&gt;where&lt;/span&gt; = &lt;span&gt;where&lt;/span&gt;.And(it =&amp;gt; it.UserId ==&lt;span&gt; Guid.Parse(userId));
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据条件 判断 是否 拼接 Name 字段 的 过滤条件&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;firstName.IsNullStr())
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                 &lt;span&gt;where&lt;/span&gt; = &lt;span&gt;where&lt;/span&gt;.And(it =&amp;gt;&lt;span&gt; it.Name.StartsWith(firstName));
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对 WhereSegment 设定的条件 进行 select 动作&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; res1 = &lt;span&gt;await&lt;/span&gt; &lt;span&gt;where&lt;/span&gt;&lt;span&gt;.QueryListAsync();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;             Assert.True(res1.Count==&lt;span&gt;1&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　以 MySQL 为例，生成 SQL 如下，其中 ?Name_2 的值自动生成为 【伏%】 ：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; `agent` &lt;span&gt;where&lt;/span&gt;&lt;span&gt; true 
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;and&lt;/span&gt;  `UserId`&lt;span&gt;=&lt;/span&gt;&lt;span&gt;?UserId_1
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;and&lt;/span&gt;  `Name` &lt;span&gt;like&lt;/span&gt;  ?Name_2;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;三.API 多表-连接 方法 举例&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 上下文 分页 变量&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; pageIndex = &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; pageSize = &lt;span&gt;10&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 上下文 条件 变量&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; level = (Nullable&amp;lt;AgentLevel&amp;gt;&lt;span&gt;)AgentLevel.DistiAgent;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; pk1 = Guid.Parse(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fbad4af4-c160-4e66-a8fc-0165443b4db0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 可 自由混合书写 多个 inner join 或 left join &lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; =&lt;span&gt; Conn
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 .Queryer(&lt;span&gt;out&lt;/span&gt; Agent agent, &lt;span&gt;out&lt;/span&gt;&lt;span&gt; AgentInventoryRecord record)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 .From(() =&amp;gt;&lt;span&gt; agent)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                     .LeftJoin(() =&amp;gt;&lt;span&gt; record)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                         .On(() =&amp;gt; agent.Id ==&lt;span&gt; record.AgentId)&lt;strong&gt;.WhereSegment&lt;/strong&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据条件 判断 是否 拼接 AgentLevel 字段 的 过滤条件&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (level != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                 &lt;span&gt;where&lt;/span&gt; = &lt;span&gt;where&lt;/span&gt;.And(() =&amp;gt; agent.AgentLevel == level);   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; and demo&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据条件 判断 是否 拼接 Id 字段 的 过滤条件&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (pk1 !=&lt;span&gt; Guid.Empty)
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                 &lt;span&gt;where&lt;/span&gt; = &lt;span&gt;where&lt;/span&gt;.Or(() =&amp;gt; agent.Id == pk1);   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;  or demo&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对 WhereSegment 设定的条件 进行 select 动作&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; res1 = &lt;span&gt;await&lt;/span&gt; &lt;span&gt;where&lt;/span&gt;.QueryPagingAsync&amp;lt;Agent&amp;gt;&lt;span&gt;(pageIndex, pageSize);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt;             Assert.True(res1.Data.Count == &lt;span&gt;10&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             Assert.True(res1.TotalCount == &lt;span&gt;575&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　以 MySQL 为例，生成 SQL 如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 总数据量 sql&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;select&lt;/span&gt; &lt;span&gt;count&lt;/span&gt;(&lt;span&gt;*&lt;/span&gt;&lt;span&gt;) 
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;from&lt;/span&gt;&lt;span&gt; (
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;select&lt;/span&gt;  agent.`&lt;span&gt;*&lt;/span&gt;&lt;span&gt;`
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; `agent` &lt;span&gt;as&lt;/span&gt;&lt;span&gt; agent 
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;left&lt;/span&gt; &lt;span&gt;join&lt;/span&gt; `agentinventoryrecord` &lt;span&gt;as&lt;/span&gt;&lt;span&gt; record
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;on&lt;/span&gt; agent.`Id`&lt;span&gt;=&lt;/span&gt;record.`AgentId` &lt;span&gt;where&lt;/span&gt;&lt;span&gt; true 
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;and&lt;/span&gt;  agent.`AgentLevel`&lt;span&gt;=&lt;/span&gt;&lt;span&gt;?AgentLevel_4
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;or&lt;/span&gt;  agent.`Id`&lt;span&gt;=&lt;/span&gt;&lt;span&gt;?Id_5
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;          ) &lt;span&gt;temp&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 分页数据 sql&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;select&lt;/span&gt; agent.`&lt;span&gt;*&lt;/span&gt;&lt;span&gt;`
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; `agent` &lt;span&gt;as&lt;/span&gt;&lt;span&gt; agent 
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;left&lt;/span&gt; &lt;span&gt;join&lt;/span&gt; `agentinventoryrecord` &lt;span&gt;as&lt;/span&gt;&lt;span&gt; record
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;on&lt;/span&gt; agent.`Id`&lt;span&gt;=&lt;/span&gt;record.`AgentId` &lt;span&gt;where&lt;/span&gt;&lt;span&gt; true 
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;and&lt;/span&gt;  agent.`AgentLevel`&lt;span&gt;=&lt;/span&gt;&lt;span&gt;?AgentLevel_4
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;or&lt;/span&gt;  agent.`Id`&lt;span&gt;=&lt;/span&gt;&lt;span&gt;?Id_5
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; agent.`Id` &lt;span&gt;desc&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; limit &lt;span&gt;10&lt;/span&gt;,&lt;span&gt;10&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;




&lt;p&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　蒙&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　2019-04-18 23:30 周四&lt;/p&gt;

</description>
<pubDate>Thu, 18 Apr 2019 15:30:00 +0000</pubDate>
<dc:creator>Meng.NET</dc:creator>
<og:description>索引： 目录索引 一.API 列表 1.WhereSegment 属性，指示 根据条件 动态拼接 where 查询过滤条件 见如下示例. 二.API 单表-完整 方法 举例 以 MySQL 为例，生成</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Meng-NET/p/10733275.html</dc:identifier>
</item>
<item>
<title>死磕 java集合之ConcurrentSkipListSet源码分析——Set大汇总 - 彤哥读源码</title>
<link>http://www.cnblogs.com/tong-yuan/p/ConcurrentSkipListSet.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tong-yuan/p/ConcurrentSkipListSet.html</guid>
<description>&lt;h2 id=&quot;问题&quot;&gt;问题&lt;/h2&gt;
&lt;p&gt;（1）ConcurrentSkipListSet的底层是ConcurrentSkipListMap吗？&lt;/p&gt;
&lt;p&gt;（2）ConcurrentSkipListSet是线程安全的吗？&lt;/p&gt;
&lt;p&gt;（3）ConcurrentSkipListSet是有序的吗？&lt;/p&gt;
&lt;p&gt;（4）ConcurrentSkipListSet和之前讲的Set有何不同？&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;ConcurrentSkipListSet底层是通过ConcurrentNavigableMap来实现的，它是一个有序的线程安全的集合。&lt;/p&gt;
&lt;h2 id=&quot;源码分析&quot;&gt;源码分析&lt;/h2&gt;
&lt;p&gt;它的源码比较简单，跟通过Map实现的Set基本是一致，只是多了一些取最近的元素的方法。&lt;/p&gt;
&lt;p&gt;为了保持专栏的完整性，我还是贴一下源码，最后会对Set的整个家族作一个对比，有兴趣的可以直接拉到最下面。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 实现了NavigableSet接口，并没有所谓的ConcurrentNavigableSet接口
public class ConcurrentSkipListSet&amp;lt;E&amp;gt;
    extends AbstractSet&amp;lt;E&amp;gt;
    implements NavigableSet&amp;lt;E&amp;gt;, Cloneable, java.io.Serializable {

    private static final long serialVersionUID = -2479143111061671589L;

    // 存储使用的map
    private final ConcurrentNavigableMap&amp;lt;E,Object&amp;gt; m;

    // 初始化
    public ConcurrentSkipListSet() {
        m = new ConcurrentSkipListMap&amp;lt;E,Object&amp;gt;();
    }

    // 传入比较器
    public ConcurrentSkipListSet(Comparator&amp;lt;? super E&amp;gt; comparator) {
        m = new ConcurrentSkipListMap&amp;lt;E,Object&amp;gt;(comparator);
    }
    
    // 使用ConcurrentSkipListMap初始化map
    // 并将集合c中所有元素放入到map中
    public ConcurrentSkipListSet(Collection&amp;lt;? extends E&amp;gt; c) {
        m = new ConcurrentSkipListMap&amp;lt;E,Object&amp;gt;();
        addAll(c);
    }
    
    // 使用ConcurrentSkipListMap初始化map
    // 并将有序Set中所有元素放入到map中
    public ConcurrentSkipListSet(SortedSet&amp;lt;E&amp;gt; s) {
        m = new ConcurrentSkipListMap&amp;lt;E,Object&amp;gt;(s.comparator());
        addAll(s);
    }
    
    // ConcurrentSkipListSet类内部返回子set时使用的
    ConcurrentSkipListSet(ConcurrentNavigableMap&amp;lt;E,Object&amp;gt; m) {
        this.m = m;
    }
    
    // 克隆方法
    public ConcurrentSkipListSet&amp;lt;E&amp;gt; clone() {
        try {
            @SuppressWarnings(&quot;unchecked&quot;)
            ConcurrentSkipListSet&amp;lt;E&amp;gt; clone =
                (ConcurrentSkipListSet&amp;lt;E&amp;gt;) super.clone();
            clone.setMap(new ConcurrentSkipListMap&amp;lt;E,Object&amp;gt;(m));
            return clone;
        } catch (CloneNotSupportedException e) {
            throw new InternalError();
        }
    }

    /* ---------------- Set operations -------------- */
    // 返回元素个数
    public int size() {
        return m.size();
    }

    // 检查是否为空
    public boolean isEmpty() {
        return m.isEmpty();
    }
    
    // 检查是否包含某个元素
    public boolean contains(Object o) {
        return m.containsKey(o);
    }
    
    // 添加一个元素
    // 调用map的putIfAbsent()方法
    public boolean add(E e) {
        return m.putIfAbsent(e, Boolean.TRUE) == null;
    }
    
    // 移除一个元素
    public boolean remove(Object o) {
        return m.remove(o, Boolean.TRUE);
    }

    // 清空所有元素
    public void clear() {
        m.clear();
    }
    
    // 迭代器
    public Iterator&amp;lt;E&amp;gt; iterator() {
        return m.navigableKeySet().iterator();
    }

    // 降序迭代器
    public Iterator&amp;lt;E&amp;gt; descendingIterator() {
        return m.descendingKeySet().iterator();
    }


    /* ---------------- AbstractSet Overrides -------------- */
    // 比较相等方法
    public boolean equals(Object o) {
        // Override AbstractSet version to avoid calling size()
        if (o == this)
            return true;
        if (!(o instanceof Set))
            return false;
        Collection&amp;lt;?&amp;gt; c = (Collection&amp;lt;?&amp;gt;) o;
        try {
            // 这里是通过两次两层for循环来比较
            // 这里是有很大优化空间的，参考上篇文章CopyOnWriteArraySet中的彩蛋
            return containsAll(c) &amp;amp;&amp;amp; c.containsAll(this);
        } catch (ClassCastException unused) {
            return false;
        } catch (NullPointerException unused) {
            return false;
        }
    }
    
    // 移除集合c中所有元素
    public boolean removeAll(Collection&amp;lt;?&amp;gt; c) {
        // Override AbstractSet version to avoid unnecessary call to size()
        boolean modified = false;
        for (Object e : c)
            if (remove(e))
                modified = true;
        return modified;
    }

    /* ---------------- Relational operations -------------- */
    
    // 小于e的最大元素
    public E lower(E e) {
        return m.lowerKey(e);
    }

    // 小于等于e的最大元素
    public E floor(E e) {
        return m.floorKey(e);
    }
    
    // 大于等于e的最小元素
    public E ceiling(E e) {
        return m.ceilingKey(e);
    }

    // 大于e的最小元素
    public E higher(E e) {
        return m.higherKey(e);
    }

    // 弹出最小的元素
    public E pollFirst() {
        Map.Entry&amp;lt;E,Object&amp;gt; e = m.pollFirstEntry();
        return (e == null) ? null : e.getKey();
    }

    // 弹出最大的元素
    public E pollLast() {
        Map.Entry&amp;lt;E,Object&amp;gt; e = m.pollLastEntry();
        return (e == null) ? null : e.getKey();
    }


    /* ---------------- SortedSet operations -------------- */

    // 取比较器
    public Comparator&amp;lt;? super E&amp;gt; comparator() {
        return m.comparator();
    }

    // 最小的元素
    public E first() {
        return m.firstKey();
    }

    // 最大的元素
    public E last() {
        return m.lastKey();
    }
    
    // 取两个元素之间的子set
    public NavigableSet&amp;lt;E&amp;gt; subSet(E fromElement,
                                  boolean fromInclusive,
                                  E toElement,
                                  boolean toInclusive) {
        return new ConcurrentSkipListSet&amp;lt;E&amp;gt;
            (m.subMap(fromElement, fromInclusive,
                      toElement,   toInclusive));
    }
    
    // 取头子set
    public NavigableSet&amp;lt;E&amp;gt; headSet(E toElement, boolean inclusive) {
        return new ConcurrentSkipListSet&amp;lt;E&amp;gt;(m.headMap(toElement, inclusive));
    }

    // 取尾子set
    public NavigableSet&amp;lt;E&amp;gt; tailSet(E fromElement, boolean inclusive) {
        return new ConcurrentSkipListSet&amp;lt;E&amp;gt;(m.tailMap(fromElement, inclusive));
    }

    // 取子set，包含from，不包含to
    public NavigableSet&amp;lt;E&amp;gt; subSet(E fromElement, E toElement) {
        return subSet(fromElement, true, toElement, false);
    }
    
    // 取头子set，不包含to
    public NavigableSet&amp;lt;E&amp;gt; headSet(E toElement) {
        return headSet(toElement, false);
    }
    
    // 取尾子set，包含from
    public NavigableSet&amp;lt;E&amp;gt; tailSet(E fromElement) {
        return tailSet(fromElement, true);
    }
    
    // 降序set
    public NavigableSet&amp;lt;E&amp;gt; descendingSet() {
        return new ConcurrentSkipListSet&amp;lt;E&amp;gt;(m.descendingMap());
    }

    // 可分割的迭代器
    @SuppressWarnings(&quot;unchecked&quot;)
    public Spliterator&amp;lt;E&amp;gt; spliterator() {
        if (m instanceof ConcurrentSkipListMap)
            return ((ConcurrentSkipListMap&amp;lt;E,?&amp;gt;)m).keySpliterator();
        else
            return (Spliterator&amp;lt;E&amp;gt;)((ConcurrentSkipListMap.SubMap&amp;lt;E,?&amp;gt;)m).keyIterator();
    }

    // 原子更新map，给clone方法使用
    private void setMap(ConcurrentNavigableMap&amp;lt;E,Object&amp;gt; map) {
        UNSAFE.putObjectVolatile(this, mapOffset, map);
    }

    // 原子操作相关内容
    private static final sun.misc.Unsafe UNSAFE;
    private static final long mapOffset;
    static {
        try {
            UNSAFE = sun.misc.Unsafe.getUnsafe();
            Class&amp;lt;?&amp;gt; k = ConcurrentSkipListSet.class;
            mapOffset = UNSAFE.objectFieldOffset
                (k.getDeclaredField(&quot;m&quot;));
        } catch (Exception e) {
            throw new Error(e);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，ConcurrentSkipListSet基本上都是使用ConcurrentSkipListMap实现的，虽然取子set部分是使用ConcurrentSkipListMap中的内部类，但是这些内部类其实也是和ConcurrentSkipListMap相关的，它们返回ConcurrentSkipListMap的一部分数据。&lt;/p&gt;
&lt;p&gt;另外，这里的equals()方法实现的相当敷衍，有很大的优化空间，作者这样实现，应该也是知道几乎没有人来调用equals()方法吧。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;（1）ConcurrentSkipListSet底层是使用ConcurrentNavigableMap实现的；&lt;/p&gt;
&lt;p&gt;（2）ConcurrentSkipListSet有序的，基于元素的自然排序或者通过比较器确定的顺序；&lt;/p&gt;
&lt;p&gt;（3）ConcurrentSkipListSet是线程安全的；&lt;/p&gt;
&lt;h2 id=&quot;彩蛋&quot;&gt;彩蛋&lt;/h2&gt;
&lt;p&gt;Set大汇总：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;HashSet&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;HashMap&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;简单&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;LinkedHashSet&lt;/td&gt;
&lt;td&gt;有&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;LinkedHashMap&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;插入顺序&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;TreeSet&lt;/td&gt;
&lt;td&gt;有&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;NavigableMap&lt;/td&gt;
&lt;td&gt;NavigableSet&lt;/td&gt;
&lt;td&gt;自然顺序&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;CopyOnWriteArraySet&lt;/td&gt;
&lt;td&gt;有&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;CopyOnWriteArrayList&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;插入顺序，读写分离&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;ConcurrentSkipListSet&lt;/td&gt;
&lt;td&gt;有&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;ConcurrentNavigableMap&lt;/td&gt;
&lt;td&gt;NavigableSet&lt;/td&gt;
&lt;td&gt;自然顺序&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;从中我们可以发现一些规律：&lt;/p&gt;
&lt;p&gt;（1）除了HashSet其它Set都是有序的；&lt;/p&gt;
&lt;p&gt;（2）实现了NavigableSet或者SortedSet接口的都是自然顺序的；&lt;/p&gt;
&lt;p&gt;（3）使用并发安全的集合实现的Set也是并发安全的；&lt;/p&gt;
&lt;p&gt;（4）TreeSet虽然不是全部都是使用的TreeMap实现的，但其实都是跟TreeMap相关的（TreeMap的子Map中组合了TreeMap）；&lt;/p&gt;
&lt;p&gt;（5）ConcurrentSkipListSet虽然不是全部都是使用的ConcurrentSkipListMap实现的，但其实都是跟ConcurrentSkipListMap相关的（ConcurrentSkipListeMap的子Map中组合了ConcurrentSkipListMap）；&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;欢迎关注我的公众号“彤哥读源码”，查看更多源码系列文章, 与彤哥一起畅游源码的海洋。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/alan-tang-tt/yuan/raw/master/%E6%AD%BB%E7%A3%95%20java%E9%9B%86%E5%90%88%E7%B3%BB%E5%88%97/resource/qrcode_ss.jpg&quot; alt=&quot;qrcode&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 18 Apr 2019 15:27:00 +0000</pubDate>
<dc:creator>彤哥读源码</dc:creator>
<og:description>ConcurrentSkipListSet的底层是ConcurrentSkipListMap吗？ ConcurrentSkipListSet是线程安全的吗？ ConcurrentSkipListS</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tong-yuan/p/ConcurrentSkipListSet.html</dc:identifier>
</item>
<item>
<title>Postgresql 10 自带扩展模块功能说明 - lightyear</title>
<link>http://www.cnblogs.com/dbalightyear/p/10733152.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dbalightyear/p/10733152.html</guid>
<description>&lt;p&gt;adminpack&lt;br/&gt;adminpack提供了许多支持功能，pgAdmin 和其他管理和管理工具可以使用它们来提供其他功能，例如远程管理服务器日志文件。所有这些功能的使用仅限于超级用户。&lt;/p&gt;
&lt;p&gt;citext&lt;br/&gt;该citext模块提供不区分大小写的字符串类型citext。本质上，它lower在比较值时内部调用。否则，它的行为几乎完全一样text。&lt;/p&gt;
&lt;p&gt;fuzzystrmatch&lt;br/&gt;该fuzzystrmatch模块提供了几个函数来确定字符串之间的相似性和距离。&lt;/p&gt;
&lt;p&gt;ltree&lt;br/&gt;该模块实现了一种数据类型ltree， 用于表示以分层树状结构存储的数据标签。提供广泛的标签树搜索设施。&lt;/p&gt;
&lt;p&gt;pg_freespacemap&lt;br/&gt;该pg_freespacemap模块提供了一种检查自由空间图（FSM）的方法。它pg_freespace准确地提供了一个称为函数或两个重载函数。这些函数显示给定页面的自由空间映射中记录的值，或者显示关系中所有页面的值。&lt;br/&gt;默认情况下，使用仅限于超级用户和pg_stat_scan_tables角色成员 。可以使用其他人授予访问权限GRANT。&lt;/p&gt;
&lt;p&gt;postgres_fdw&lt;br/&gt;pg的外部数据包装器&lt;/p&gt;
&lt;p&gt;tcn&lt;br/&gt;该tcn模块提供触发器功能，通知侦听器对其所连接的任何表的更改。它必须用作AFTER触发器FOR EACH ROW。&lt;/p&gt;
&lt;p&gt;在CREATE TRIGGER语句中只能向函数提供一个参数 ，这是可选的。如果提供，它将用于通知的通道名称。如果省略tcn则将用于通道名称。&lt;/p&gt;
&lt;p&gt;通知的有效负载包括表名，用于指示执行了哪种操作的字母以及主键列的列名/值对。每个部分用逗号分隔。为了便于使用正则表达式进行解析，表和列名称始终用双引号括起来，并且数据值始终用单引号括起来。嵌入式报价加倍。&lt;/p&gt;
&lt;p&gt;amcheck&lt;br/&gt;支持btree索引的DEBUG&lt;/p&gt;&lt;p&gt;hstore&lt;br/&gt;JSON类型操作符&lt;/p&gt;&lt;p&gt;ltree_plpython&lt;/p&gt;
&lt;p&gt;pg_prewarm&lt;br/&gt;该pg_prewarm模块提供了一种将关系数据加载到操作系统缓冲区缓存或PostgreSQL缓冲区缓存中的便捷方法。&lt;/p&gt;
&lt;p&gt;test_decoding&lt;br/&gt;test_decoding是逻辑解码输出插件的示例。它没有做任何特别有用的事情，但可以作为开发自己的解码器的起点。&lt;br/&gt;test_decoding 通过逻辑解码机制接收WAL并将其解码为所执行操作的文本表示。&lt;/p&gt;
&lt;p&gt;auth_delay&lt;br/&gt;auth_delay导致服务器在报告身份验证失败之前暂停，以使对数据库密码的暴力攻击更加困难。请注意，它不会阻止拒绝服务攻击，甚至可能会加剧它们，因为在报告身份验证失败之前等待的进程仍将消耗连接槽。&lt;/p&gt;
&lt;p&gt;cube&lt;br/&gt;此模块实现cube用于表示多维立方体的数据类型。&lt;/p&gt;&lt;p&gt;hstore_plperl&lt;/p&gt;
&lt;p&gt;pgrowlocks&lt;br/&gt;该pgrowlocks模块提供了显示指定表的行锁定信息的功能。&lt;br/&gt;默认情况下，使用仅限于超级用户，pg_stat_scan_tables角色成员 以及SELECT对表具有权限的用户。&lt;/p&gt;
&lt;p&gt;seg&lt;br/&gt;此模块实现seg 用于表示线段或浮点间隔的数据类型。 seg可以表示间隔端点的不确定性，使其对表示实验室测量特别有用。&lt;/p&gt;&lt;p&gt;tsm_system_rows&lt;/p&gt;
&lt;p&gt;auto_explain&lt;br/&gt;该auto_explain模块提供了一种自动记录慢速语句执行计划的方法，而无需手动运行EXPLAIN。这对于在大型应用程序中跟踪未优化的查询特别有用。&lt;/p&gt;
&lt;p&gt;dblink&lt;br/&gt;数据库之间访问&lt;/p&gt;
&lt;p&gt;hstore_plpython&lt;/p&gt;
&lt;p&gt;oid2name&lt;br/&gt;oid2name - 解析PostgreSQL数据目录中的OID和文件节点&lt;/p&gt;&lt;p&gt;pg_standby&lt;br/&gt;pg_standby - 支持创建PostgreSQL热备份服务器&lt;/p&gt;&lt;p&gt;sepgsql&lt;br/&gt;sepgsql是一个可加载模块，支持基于SELinux安全策略的基于标签的强制访问控制（MAC） 。&lt;/p&gt;
&lt;p&gt;tsm_system_time&lt;/p&gt;
&lt;p&gt;bloom&lt;br/&gt;Bloom过滤器是一种节省空间的数据结构，用于测试元素是否是集合的成员。在索引访问方法的情况下，它允许通过在索引创建时确定大小的签名快速排除不匹配的元组。&lt;/p&gt;
&lt;p&gt;dict_int&lt;br/&gt;dict_int是用于全文搜索的附加字典模板的示例。此示例字典的动机是控制整数的索引（有符号和无符号），允许对这些数字进行索引，同时防止唯一字数量的过度增长，这极大地影响了搜索的性能。&lt;/p&gt;&lt;p&gt;intagg&lt;br/&gt;该intagg模块提供整数聚合器和枚举器。intagg现在已经过时，因为有内置函数可以提供其功能的超集。但是，该模块仍然作为内置函数的兼容性包装提供。&lt;/p&gt;
&lt;p&gt;pageinspect&lt;br/&gt;该pageinspect模块提供的功能允许您以较低级别检查数据库页面的内容，这对于调试非常有用。所有这些功能只能由超级用户使用。&lt;/p&gt;
&lt;p&gt;pg_stat_statements&lt;br/&gt;该pg_stat_statements模块提供了一种跟踪服务器执行的所有SQL语句的执行统计信息的方法。&lt;/p&gt;
&lt;p&gt;spi&lt;br/&gt;在SPI模块提供了使用的几种可行的实施例中服务器编程接口（SPI）和触发器。虽然这些功能本身具有一定的价值，但它们作为示例更有用，可以根据自己的需要进行修改。这些函数足以与任何表一起使用，但您必须在创建触发器时指定表和字段名称。&lt;/p&gt;
&lt;p&gt;unaccent&lt;br/&gt;unaccent是一个文本搜索词典，用于从词法中删除重音符号（变音符号）。它是一个过滤字典，这意味着它的输出总是传递给下一个字典（如果有的话），这与字典的正常行为不同。这允许对全文搜索进行重音不敏感处理。&lt;br/&gt;unaccent的当前实现 不能用作同义词词典的规范化字典。&lt;/p&gt;
&lt;p&gt;btree_gin&lt;br/&gt;btree_gin提供了实现对数据类型B树等效行为样品GIN算子类int2，int4，int8，float4，float8， timestamp with time zone，timestamp without time zone，time with time zone，time without time zone，date，interval，oid，money，&quot;char&quot;，varchar，text，bytea，bit，varbit，macaddr， macaddr8，inet， cidr，和所有enum类型。&lt;br/&gt;通常，这些运算符类不会胜过等效的标准B树索引方法，并且它们缺少标准B树代码的一个主要特征：强制唯一性的能力。但是，它们对GIN测试很有用，也可用作开发其他GIN运算符类的基础。此外，对于同时测试GIN可索引列和B树可索引列的查询，创建使用这些运算符类之一的多列GIN索引可能比创建必须使用的两个单独索引更有效通过位图ANDing组合。&lt;/p&gt;
&lt;p&gt;dict_xsyn&lt;br/&gt;dict_xsyn（扩展同义词词典）是用于全文搜索的附加词典模板的示例。此字典类型用其同义词的组替换单词，因此可以使用其任何同义词搜索单词。&lt;/p&gt;
&lt;p&gt;intarray&lt;br/&gt;该intarray模块提供了许多有用的函数和操作符，用于操作无null的整数数组。还支持使用某些运算符进行索引搜索。&lt;br/&gt;如果提供的数组包含任何NULL元素，则所有这些操作都将引发错误。&lt;br/&gt;许多这些操作仅对一维阵列有效。虽然它们将接受更多维度的输入数组，但数据被视为存储顺序中的线性数组。&lt;/p&gt;
&lt;p&gt;passwordcheck&lt;br/&gt;该passwordcheck模块检查用户的密码时，他们都设置有CREATE ROLE或ALTER ROLE。如果密码被认为太弱，它将被拒绝，命令将以错误终止。&lt;br/&gt;要启用这个模块，添加'$libdir/passwordcheck'到shared_preload_libraries 中postgresql.conf，然后重新启动服务器。&lt;br/&gt;您可以通过更改源代码来调整此模块以满足您的需求。例如，您可以使用CrackLib来检查密码 - 这只需要取消注释Makefile并重建模块中的两行。（出于许可证原因，我们默认不包括CrackLib。）如果没有CrackLib，模块会强制执行一些简单的密码强度规则，您可以根据需要进行修改或扩展。&lt;/p&gt;
&lt;p&gt;pgstattuple&lt;br/&gt;该pgstattuple模块提供各种函数来获取元组级统计信息。&lt;br/&gt;由于这些函数返回详细的页面级信息，因此只有超级用户在安装时才具有EXECUTE特权。安装这些功能后，用户可以发出 GRANT命令来更改功能的权限，以允许非超级用户执行它们。pg_stat_scan_tables默认情况下，该角色的成员被授予访问权限。&lt;/p&gt;
&lt;p&gt;sslinfo&lt;br/&gt;该sslinfo模块提供有关当前客户端在连接到PostgreSQL时提供的SSL证书的信息。如果当前连接不使用SSL，则该模块无用（大多数函数将返回NULL）。&lt;br/&gt;除非安装配置，否则此扩展根本不会构建--with-openssl。&lt;/p&gt;
&lt;p&gt;uuid-ossp&lt;br/&gt;UUID唯一主键&lt;/p&gt;
&lt;p&gt;btree_gist&lt;br/&gt;btree_gist提供了实现对数据类型的B-tree相当于行为的GiST索引操作符类int2，int4，int8，float4，float8， numeric，timestamp with time zone，timestamp without time zone，time with time zone， time without time zone，date，interval， oid，money， char，varchar， text，bytea， bit，varbit， macaddr，macaddr8，inet， cidr，uuid，和所有enum类型。&lt;br/&gt;通常，这些运算符类不会胜过等效的标准B树索引方法，并且它们缺少标准B树代码的一个主要特征：强制唯一性的能力。但是，它们提供了B树索引不具备的一些其他功能，如下所述。此外，当需要多列GiST索引时，这些运算符类很有用，其中一些列的数据类型只能用GiST索引，但其他列只是简单的数据类型。最后，这些运算符类对GiST测试很有用，也可用作开发其他GiST运算符类的基础。&lt;br/&gt;除了典型的B树搜索运算符之外，btree_gist还为&amp;lt;&amp;gt;（“ not equals ”）提供索引支持 。如下所述，这可以与排除约束结合使用。&lt;br/&gt;此外，对于存在自然距离度量的数据类型，btree_gist定义距离运算符&amp;lt;-&amp;gt;，并使用此运算符为最近邻搜索提供GiST索引支持。提供了运营商的距离int2， int4，int8， float4，float8， timestamp with time zone，timestamp without time zone，time without time zone，date， interval，oid，和money。&lt;/p&gt;
&lt;p&gt;earthdistance&lt;br/&gt;该earthdistance模块提供了两种不同的方法来计算地球表面的大圆距离。首先描述的cube模块取决于 模块（必须在安装之前earthdistance安装）。第二个是基于内置point数据类型，使用坐标的经度和纬度。&lt;/p&gt;&lt;p&gt;isn&lt;/p&gt;&lt;p&gt;pg_buffercache&lt;br/&gt;该pg_buffercache模块提供了一种实时检查共享缓冲区缓存中发生的情况的方法。&lt;br/&gt;该模块提供了一个C函数pg_buffercache_pages，它返回一组记录，以及一个pg_buffercache 包装函数以便于使用的视图。&lt;br/&gt;默认情况下，使用仅限于超级用户和pg_read_all_stats角色成员 。可以使用其他人授予访问权限GRANT。&lt;/p&gt;
&lt;p&gt;pg_trgm&lt;br/&gt;该pg_trgm模块提供函数和运算符，用于基于trigram匹配确定字母数字文本的相似性，以及支持快速搜索类似字符串的索引运算符类。&lt;/p&gt;
&lt;p&gt;vacuumlo&lt;br/&gt;vacuumlo - 从PostgreSQL数据库中删除孤立的大对象&lt;/p&gt;
&lt;p&gt;chkpass&lt;br/&gt;此模块实现了chkpass用于存储加密密码的数据类型。每个密码在进入时自动转换为加密形式，并始终以加密方式存储。要进行比较，只需与明文密码进行比较，比较函数将在比较之前对其进行加密。&lt;br/&gt;如果确定密码容易破解，则代码中有规定报告错误。但是，这只是一个什么都不做的存根。&lt;br/&gt;如果您在输入字符串前面加冒号，则假定它是一个已加密的密码，并且无需进一步加密即可存储。这允许输入先前加密的密码。&lt;br/&gt;输出时，前面有一个冒号。这使得可以转储和重新加载密码而无需重新加密密码。如果您想要没有冒号的加密密码，请使用该raw()功能。这允许您将类型与Apache的Auth_PostgreSQL模块一起使用。&lt;br/&gt;加密使用标准的Unix函数crypt()，因此它受到该函数的所有常见限制; 值得注意的是，只考虑密码的前八个字符。&lt;/p&gt;&lt;p&gt;file_fdw&lt;br/&gt;文件外部数据包装器&lt;/p&gt;&lt;p&gt;lo&lt;/p&gt;&lt;p&gt;pgcrypto&lt;br/&gt;该pgcrypto模块为PostgreSQL提供加密功能。&lt;/p&gt;
&lt;p&gt;pg_visibility&lt;br/&gt;该pg_visibility模块提供了一种检查表的可见性映射（VM）和页面级可见性信息的方法。它还提供了检查可见性图的完整性并强制重建的功能。&lt;/p&gt;
&lt;p&gt;三个不同的位用于存储有关页面级可见性的信息。可见性映射中的全部可见位指示关系的相应页面中的每个元组对于每个当前和将来的事务是可见的。可见性图中的全冻结位表示页面中的每个元组都被冻结; 也就是说，在该页面上插入，更新，删除或锁定元组之前，不需要修改页面。页面标题PD_ALL_VISIBLEbit与可见性映射中的全可见位具有相同的含义，但是存储在数据页本身中而不是存储在单独的数据结构中。这两个位通常是一致的，但有时可以设置页面的全部可见位，同时在崩溃恢复后可见性映射位清零。报告的值也可能不一致，因为在pg_visibility 检查可见性映射之后以及在检查数据页之前发生了更改。任何导致数据损坏的事件也可能导致这些位不一致。&lt;/p&gt;
&lt;p&gt;显示有关PD_ALL_VISIBLE位信息的函数比仅查阅可见性映射的函数要昂贵得多，因为它们必须读取关系的数据块而不是仅读取（小得多）可见性映射。检查关系数据块的函数同样昂贵。&lt;/p&gt;&lt;p&gt;tablefunc&lt;br/&gt;该tablefunc模块包括返回表的各种函数（即多行）。这些函数本身和作为返回多行的C函数的示例都很有用。&lt;/p&gt;
&lt;p&gt;xml2&lt;br/&gt;该xml2模块提供XPath查询和XSLT功能。&lt;/p&gt;
</description>
<pubDate>Thu, 18 Apr 2019 15:16:00 +0000</pubDate>
<dc:creator>lightyear</dc:creator>
<og:description>adminpackadminpack提供了许多支持功能，pgAdmin 和其他管理和管理工具可以使用它们来提供其他功能，例如远程管理服务器日志文件。所有这些功能的使用仅限于超级用户。 citext 该</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dbalightyear/p/10733152.html</dc:identifier>
</item>
<item>
<title>Build SSH for Development on Windows Subsystem for Linux - nczitzk</title>
<link>http://www.cnblogs.com/nczitzk/p/build-ssh-for-development-on-windows-subsystem-for-linux.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nczitzk/p/build-ssh-for-development-on-windows-subsystem-for-linux.html</guid>
<description>&lt;p&gt;It seems that &lt;strong&gt;Windows Subsystem for Linux&lt;/strong&gt; (WSL) is getting much more mature than the time when it first came out. Fewer and fewer people keep questioning its fitness for daily development. Tuning &lt;strong&gt;WSL&lt;/strong&gt; to be a neat developing environment and how to &lt;strong&gt;SSH&lt;/strong&gt; into &lt;strong&gt;WSL&lt;/strong&gt; the topic I am going to share with.&lt;/p&gt;
&lt;h3&gt;One-Click installation&lt;/h3&gt;
&lt;p&gt;The installation entry of several Linux distributions available for &lt;strong&gt;WSL &lt;/strong&gt;has been moved to &lt;strong&gt;Microsoft Store&lt;/strong&gt; since &lt;strong&gt;the Fall Creators&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;It means you can install a Linux distribution as simple as installing an app from the store. The moment I am writing this, &lt;strong&gt;Ubuntu&lt;/strong&gt;, &lt;strong&gt;Debian&lt;/strong&gt;, &lt;strong&gt;OpenSUSE&lt;/strong&gt;and &lt;strong&gt;Kali Linux&lt;/strong&gt; are officially collected into the &lt;strong&gt;WSL&lt;/strong&gt; family.&lt;/p&gt;
&lt;p&gt;I choose &lt;strong&gt;Debian&lt;/strong&gt; as my first trial for &lt;strong&gt;WSL&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;If nothing goes wrong, the familiar icon will show up in the start menu after the installation. Click it, boot it on and create your Linux user account.&lt;/p&gt;
&lt;p&gt;As you can see in the &lt;strong&gt;Task Manager&lt;/strong&gt;, required few seconds to get ready, &lt;strong&gt;WSL &lt;/strong&gt;have very small demand for resource and please don't forget that it is able to offer almost full Linux experience to you. So that is pretty good enough as a subsystem.&lt;/p&gt;
&lt;p&gt;By the way, this command can lead you to your &lt;strong&gt;C:/&lt;/strong&gt;.&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;plaintext hljs bash&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;cd /mnt/c&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Similarly, &lt;strong&gt;/mnt/d&lt;/strong&gt; for &lt;strong&gt;D:/&lt;/strong&gt; and so on.&lt;/p&gt;
&lt;h3&gt;Simple configuration&lt;/h3&gt;
&lt;p&gt;You can tweak it in the same way as you play with Linux as usual when you have got this far. The following are things I have done just after the installation.&lt;/p&gt;
&lt;h4&gt;Update sources.list&lt;/h4&gt;
&lt;p&gt;Replacing &lt;strong&gt;stable&lt;/strong&gt; to &lt;strong&gt;testing&lt;/strong&gt; will let your Debian have access to the latest version of software updates.&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;bash hljs&quot;&gt;sudo nano /etc/apt/sources.list&lt;/code&gt;
&lt;/pre&gt;
&lt;h4&gt;Configure locale&lt;/h4&gt;
&lt;p&gt;Select your language to add UTF8 locales support by doing this.&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;bash hljs&quot;&gt;sudo dpkg-reconfigure locales&lt;/code&gt;
&lt;/pre&gt;
&lt;h4&gt;Create a shortcut on the desktop&lt;/h4&gt;
&lt;p&gt;The path to &lt;strong&gt;Debian(WSL)&lt;/strong&gt; root follows the format:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;plaintext hljs css&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;C:\&lt;span class=&quot;hljs-selector-tag&quot;&gt;Users\&lt;span class=&quot;hljs-selector-tag&quot;&gt;username\&lt;span class=&quot;hljs-selector-tag&quot;&gt;AppData\&lt;span class=&quot;hljs-selector-tag&quot;&gt;Local\&lt;span class=&quot;hljs-selector-tag&quot;&gt;Packages\&lt;span class=&quot;hljs-selector-tag&quot;&gt;TheDebianProject&lt;span class=&quot;hljs-selector-class&quot;&gt;.DebianGNULinux_xxxxxxxxxxxxx\&lt;span class=&quot;hljs-selector-tag&quot;&gt;LocalState\&lt;span class=&quot;hljs-selector-tag&quot;&gt;rootfs&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4&gt;However, do not move or delete or do anything else on files in &lt;strong&gt;WSL&lt;/strong&gt; with &lt;strong&gt;Windows File Explorer&lt;/strong&gt; which might mess up the &lt;strong&gt;file permission&lt;/strong&gt; on Linux File System. That causes tons of problems. Here it can only be used as a single-function graphical File Explorer.&lt;/h4&gt;
&lt;h3&gt;SSH to WSL&lt;/h3&gt;
&lt;p&gt;Considering that it is a kind of awkward experience to run bash in &lt;strong&gt;CMD&lt;/strong&gt;, so here I introduce &lt;strong&gt;MobaXterm&lt;/strong&gt; to you. Next, we are about to build up an SSH server on &lt;strong&gt;WSL&lt;/strong&gt; and pair it with &lt;strong&gt;MobaXterm&lt;/strong&gt; through SSH connection.&lt;/p&gt;
&lt;h4&gt;Install OpenSSH server&lt;/h4&gt;
&lt;p&gt;OpenSSH is the premier connectivity tool for remote login with the SSH protocol.&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;bash hljs&quot;&gt;sudo apt-get install openssh-server&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Edit the configuration and change the listening port for the reason that Port 22 as the default setting has been already taken by SSH service running on Windows.&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;bash hljs&quot;&gt;sudo nano /etc/ssh/sshd_config&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;To make sure SSH server on &lt;strong&gt;WSL&lt;/strong&gt; works well, change &lt;strong&gt;Port 22&lt;/strong&gt; into &lt;strong&gt;Port 2018 &lt;/strong&gt;or whatever you prefer.&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;apache hljs&quot;&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;Port 2018
&lt;span class=&quot;hljs-attribute&quot;&gt;ListenAddress 0.0.0.0
&lt;span class=&quot;hljs-attribute&quot;&gt;PermitRootLogin prohibit-password&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;the above is the scanty lines you have to deal with in the &lt;strong&gt;sshd_config&lt;/strong&gt;. Then start the SSH service.&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;bash hljs&quot;&gt;sudo service ssh start&lt;/code&gt;
&lt;/pre&gt;
&lt;h4&gt;Use MobaXterm to SSH&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://mobaxterm.mobatek.net/&quot;&gt;MobaXterm&lt;/a&gt; has not only SSH support but also full X-Server support if you need. Two editions (Home Edition and Professional Edition) are provided with free one and paid one.&lt;/p&gt;
&lt;p&gt;I download &lt;strong&gt;MobaXterm&lt;/strong&gt; Home Edition (Portable edition) which already fulfils my demand.&lt;/p&gt;
&lt;p&gt;Create a new session and edit its configuration. &lt;strong&gt;Remote host&lt;/strong&gt; is set as&lt;strong&gt;127.0.0.1&lt;/strong&gt;. Remember that &lt;strong&gt;Port&lt;/strong&gt; should be &lt;strong&gt;2018&lt;/strong&gt; or the same port you decided several minutes ago. You can tweak other settings catered for your appetite.&lt;/p&gt;
&lt;p&gt;If your &lt;strong&gt;Debian&lt;/strong&gt; is running well with SSH enabled, it must work. Select &lt;strong&gt;Remember the Password&lt;/strong&gt; to save the time you type in your password whenever booting the &lt;strong&gt;WSL&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Now enjoy &lt;strong&gt;WSL&lt;/strong&gt; with the excellent terminal experience supplied by &lt;strong&gt;MobaXterm&lt;/strong&gt;.&lt;/p&gt;
&lt;h3&gt;Auto-boot WSL with SSH started&lt;/h3&gt;
&lt;p&gt;It is so unpleasant to manually start &lt;strong&gt;SSH&lt;/strong&gt; service each time you turn &lt;strong&gt;WSL &lt;/strong&gt;on and the bot to boot &lt;strong&gt;WSL&lt;/strong&gt; at the same time as you log in Windows can be the thing what you want.&lt;/p&gt;
&lt;p&gt;Also, you will soon notice that the &lt;strong&gt;SSH&lt;/strong&gt; connection goes bad when you shut down the CMD window which is quite bothering.&lt;/p&gt;
&lt;p&gt;Here comes the solution to the three so-called problems.&lt;/p&gt;
&lt;h4&gt;Auto-start SSH service&lt;/h4&gt;
&lt;p&gt;Write a shell script named &lt;strong&gt;init.sh&lt;/strong&gt; placed in &lt;strong&gt;/home&lt;/strong&gt;.&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;bash hljs&quot;&gt;sudo -S service ssh start &amp;lt;&amp;lt; EOF
&amp;lt;your_password&amp;gt;
EOF&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Replace &amp;lt;your_password&amp;gt; to your root password.&lt;/p&gt;
&lt;p&gt;The object of the tiny script is to start &lt;strong&gt;SSH&lt;/strong&gt; service in &lt;strong&gt;sudo&lt;/strong&gt; mode when you execute this shell.&lt;/p&gt;
&lt;p&gt;Write a &lt;strong&gt;VBS&lt;/strong&gt; script on your Windows host.&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;VBScript hljs javascript&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;Set ws = CreateObject(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Wscript.Shell&quot;) 
ws.run &lt;span class=&quot;hljs-string&quot;&gt;&quot;bash /home/init.sh&quot;,vbhide&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;To mention that, &lt;strong&gt;WSL&lt;/strong&gt; can be start up by typing &lt;strong&gt;bash&lt;/strong&gt; in &lt;strong&gt;CMD&lt;/strong&gt; or &lt;strong&gt;Powershell&lt;/strong&gt;. The script is so self-explain that it will obviously run the &lt;strong&gt;init.sh&lt;/strong&gt; as well after booting &lt;strong&gt;WSL&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;vbhide&lt;/strong&gt; at the end of the line tells that it runs silently in the background.&lt;/p&gt;
&lt;p&gt;Actually, it doesn't matter that what sort of name you give to the shell above and where you place it. Just to be sure the path-to-the-shell has to be identical in two scripts.&lt;/p&gt;
&lt;h3&gt;Auto-boot WSL in background&lt;/h3&gt;
&lt;p&gt;It is much easier to achieve this goal since the big steps have got settled in the previous move.&lt;/p&gt;
&lt;p&gt;Set the &lt;strong&gt;VBS&lt;/strong&gt; script into the scheduled tasks performing when Windows host logins.&lt;/p&gt;
&lt;p&gt;Reboot Windows and keep an eye on the &lt;strong&gt;Task Manager&lt;/strong&gt;. if two processes named&lt;strong&gt;init&lt;/strong&gt; (depends on the name of the shell) and &lt;strong&gt;sshd&lt;/strong&gt; exist, then you can immediately start &lt;strong&gt;MobaXterm&lt;/strong&gt; to &lt;strong&gt;SSH&lt;/strong&gt; into &lt;strong&gt;WSL&lt;/strong&gt; without any other keyboard job.&lt;/p&gt;
&lt;h3&gt;Job done&lt;/h3&gt;
&lt;p&gt;Now, the complete &lt;strong&gt;WSL&lt;/strong&gt; with &lt;strong&gt;SSH&lt;/strong&gt; workflow has been set up.&lt;/p&gt;
&lt;p&gt;Thanks for reading :)&lt;/p&gt;
</description>
<pubDate>Thu, 18 Apr 2019 15:11:00 +0000</pubDate>
<dc:creator>nczitzk</dc:creator>
<og:description>It seems that Windows Subsystem for Linux (WSL) is getting much more mature than the time when it fi</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nczitzk/p/build-ssh-for-development-on-windows-subsystem-for-linux.html</dc:identifier>
</item>
<item>
<title>[NewLife.XCode]数据层缓存（网站性能翻10倍） - 大石头</title>
<link>http://www.cnblogs.com/nnhy/p/xcode_dbcache.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nnhy/p/xcode_dbcache.html</guid>
<description>&lt;p&gt;NewLife.XCode是一个有10多年历史的开源数据中间件，支持nfx/netcore，由新生命团队(2002~2019)开发完成并维护至今，以下简称XCode。&lt;/p&gt;
&lt;p&gt;整个系列教程会大量结合示例代码和运行日志来进行深入分析，蕴含多年开发经验于其中，代表作有百亿级大数据实时计算项目。&lt;/p&gt;
&lt;p&gt;开源地址：&lt;a href=&quot;https://github.com/NewLifeX/X&quot; target=&quot;_blank&quot;&gt;https://github.com/NewLifeX/X &lt;/a&gt;（求star, 760+）&lt;/p&gt;

&lt;p&gt;缓存是一把尖刀，合理使用可大大提升吞吐率！&lt;/p&gt;


&lt;p&gt;2006年，某某省电网门户卒！&lt;/p&gt;
&lt;p&gt;经查，首页某个sql先后执行了8次，正好对应页面上8大块新闻列表。&lt;/p&gt;
&lt;p&gt;实在忍无可忍，于是在底层用Hashtable做了一层sql/DataSet缓存，当时.NET1.1好像还没有泛型字典。&lt;/p&gt;
&lt;p&gt;于是世界清静了，效果还不错，特别对于访问量很大的门户网站。&lt;/p&gt;

&lt;p&gt;XCode的数据层缓存设计于2003年，那时候只做网站和普通MIS系统，数据库性能还很差……&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;数据层缓存：以查询sql为key，把查询结果缓存起来，提升系统性能！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;经过16年的发展，XCode里面数据层缓存曾经一度被干掉，若干年后又请回来，现在是这个样子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/19592/201904/19592-20190418222422174-1596062212.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;数据层DAL内，所有查询类方法 Query/Select/SelectCount 都先走一趟缓存（默认配置关闭）；&lt;/p&gt;
&lt;p&gt;所有添删改操作类方法 Execute 都清空本DAL连接的所有缓存；&lt;/p&gt;

&lt;p&gt;** 多年前，查询方法指定要用到的表名，添删改方法指定会影响到的表名，做到部分表缓存过期。现在数据库性能大有提升，为了“简约”设计理念，简化了缓存设计。&lt;/p&gt;


&lt;p&gt;数据层缓存只有一个缓存时间的设置DataCacheExpire，位于配置文件 config/xcode.config 中，默认0秒表示不启用。&lt;/p&gt;
&lt;p&gt;设置缓存时间的方式有多种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;修改配置文件 config/xcode.config 中的DataCacheExpire&lt;/li&gt;
&lt;li&gt;魔方，魔方设置页面，修改数据中间件页的“数据层缓存”&lt;/li&gt;
&lt;li&gt;直接修改DAL类的Expire属性&lt;/li&gt;
&lt;li&gt;连接字符串中配置DataCache参数，如 DataCache=60&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;前面两者的本质相同，也是最常见用法。&lt;/p&gt;
&lt;p&gt;连接字符串配置提供了个性化，针对部分连接需要打开数据层缓存，或者不同连接采用不能缓存时间的场景。&lt;/p&gt;


&lt;p&gt;2016年起，XCode采取了“简约”且稍微“保守”的理念，于是数据层缓存默认配置0秒，大部分场景推荐使用10~60秒。&lt;/p&gt;
&lt;p&gt;各种网站，推荐过期时间60秒起，经实际线上项目压测，吞吐率可轻易从300rps提升到10000rps以上，命中率99.99%。&lt;/p&gt;
&lt;p&gt;每一个应用系统，总会有那么一些表或数据很少改变，非常适合使用数据层缓存，建议在实践中获得最优缓存时间！&lt;/p&gt;



&lt;p&gt;NewLife.XCode教程系列[2019版]&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_curd.html&quot; target=&quot;_blank&quot;&gt;增删改查入门&lt;/a&gt;。快速展现用法，代码配置连接字符串&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_model.html&quot; target=&quot;_blank&quot;&gt;数据模型文件&lt;/a&gt;。建立表格字段和索引，名字以及数据类型规范，推荐字段（时间，用户，IP）&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_entity.html&quot; target=&quot;_blank&quot;&gt;实体类详解&lt;/a&gt;。数据类业务类，泛型基类，接口&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_setting.html&quot; target=&quot;_blank&quot;&gt;功能设置&lt;/a&gt;。连接字符串，调试开关，SQL日志，慢日志，参数化，执行超时。代码与配置文件设置，连接字符串局部设置&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_negative.html&quot; target=&quot;_blank&quot;&gt;反向工程&lt;/a&gt;。自动建立数据库数据表&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_initdata.html&quot; target=&quot;_blank&quot;&gt;数据初始化&lt;/a&gt;。InitData写入初始化数据&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_curd_adv.html&quot; target=&quot;_blank&quot;&gt;高级增删改&lt;/a&gt;。重载拦截，自增字段，Valid验证，实体模型（时间，用户，IP）&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_dirty.html&quot; target=&quot;_blank&quot;&gt;脏数据&lt;/a&gt;。如何产生，怎么利用&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_additional.html&quot; target=&quot;_blank&quot;&gt;增量累加&lt;/a&gt;。高并发统计&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_transaction.html&quot; target=&quot;_blank&quot;&gt;事务处理&lt;/a&gt;。单表和多表，不同连接，多种写法&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_extend.html&quot; target=&quot;_blank&quot;&gt;扩展属性&lt;/a&gt;。多表关联，Map映射&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_search.html&quot; target=&quot;_blank&quot;&gt;高级查询&lt;/a&gt;。复杂条件，分页，自定义扩展FieldItem，查总记录数，查汇总统计&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_dbcache.html&quot; target=&quot;_blank&quot;&gt;数据层缓存&lt;/a&gt;。Sql缓存，更新机制&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_entitycache.html&quot; target=&quot;_blank&quot;&gt;实体缓存&lt;/a&gt;。全表整理缓存，更新机制&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_singlecache.html&quot; target=&quot;_blank&quot;&gt;对象缓存&lt;/a&gt;。字典缓存，适用用户等数据较多场景。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_100billion.html&quot; target=&quot;_blank&quot;&gt;百亿级性能&lt;/a&gt;。字段精炼，索引完备，合理查询，充分利用缓存&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_factory.html&quot; target=&quot;_blank&quot;&gt;实体工厂&lt;/a&gt;。元数据，通用处理程序&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_membership.html&quot; target=&quot;_blank&quot;&gt;角色权限&lt;/a&gt;。Membership&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_import_export.html&quot; target=&quot;_blank&quot;&gt;导入导出&lt;/a&gt;。Xml，Json，二进制，网络或文件&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_division.html&quot; target=&quot;_blank&quot;&gt;分表分库&lt;/a&gt;。常见拆分逻辑&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_stat.html&quot; target=&quot;_blank&quot;&gt;高级统计&lt;/a&gt;。聚合统计，分组统计&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_batch.html&quot; target=&quot;_blank&quot;&gt;批量写入&lt;/a&gt;。批量插入，批量Upsert，异步保存&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_queue.html&quot; target=&quot;_blank&quot;&gt;实体队列&lt;/a&gt;。写入级缓存，提升性能。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_backup.html&quot; target=&quot;_blank&quot;&gt;备份同步&lt;/a&gt;。备份数据，恢复数据，同步数据&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_service.html&quot; target=&quot;_blank&quot;&gt;数据服务&lt;/a&gt;。提供RPC接口服务，远程执行查询，例如SQLite网络版&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_bigdata.html&quot; target=&quot;_blank&quot;&gt;大数据分析&lt;/a&gt;。ETL抽取，调度计算处理，结果持久化&lt;/li&gt;
&lt;/ol&gt;
</description>
<pubDate>Thu, 18 Apr 2019 14:57:00 +0000</pubDate>
<dc:creator>大石头</dc:creator>
<og:description>缓存是一把尖刀，合理使用可大大提升吞吐率！</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nnhy/p/xcode_dbcache.html</dc:identifier>
</item>
<item>
<title>带着新人看java虚拟机02 - java小新人</title>
<link>http://www.cnblogs.com/wyq1995/p/10726998.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wyq1995/p/10726998.html</guid>
<description>&lt;p&gt;　　上一节是把大概的流程给过了一遍，但是还有很多地方没有说到，后续的慢慢会涉及到，敬请期待！&lt;/p&gt;
&lt;p&gt;　　这次我们说说垃圾收集器，又名gc，顾名思义，就是收集垃圾的容器，那什么是垃圾呢？在我们这里指的就是堆中那些没人要的对象。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.垃圾收集器的由来&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　为什么要有垃圾收集器啊？不知道有没有想过这个问题，你说我运行一个程序要什么垃圾收集器啊？&lt;/p&gt;
&lt;p&gt;　　随意看一下下面两行代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
User user = &lt;span&gt;new&lt;/span&gt; User(&quot;root&quot;,&quot;123456&quot;&lt;span&gt;)
user &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; User(&quot;lisi&quot;,&quot;123123&quot;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　简单画一下内存图，可以看到user这个局部变量本来是指向root这个对象，现在改为指向lisi这个对象，那么此时这个root对象没有人用，假如类似root这样的对象非常多的话，那么jvm性能就会越来越低，直至最后创建个对象可能都要十几秒，而且堆内存总有一天会装满就会报内存溢出异常；&lt;/p&gt;
&lt;p&gt;　　所以我们就要想办法把类似root这种对象给清理掉，这样才能保证jvm高效的运行；&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201904/1368608-20190417221802398-1431377779.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　假如虚拟机没有提供gc你觉得会怎么样？其实也行，只不过你每次需要你用代码手动释放不需要的对象，关于这点有好处有坏处，好处就是有利于我们对堆内存的控制，坏处就是我们在一些比较复杂的程序之中由于手动释放内存难免会出错，但是这中错误还不怎么明显，可能要你去慢慢调试好久才能看到！&lt;/p&gt;
&lt;p&gt;　　所以java就把这种工作自己处理了，让一个gc线程一直在后台运行，随时准备清理不需要用的对象，虽然相当程度上会对jvm性能造成一些影响，但是由于gc太好用了，我们不用再人为的去关心垃圾对象的释放，简化了我们编写程序的难度，所以这种影响程度完全可以接受！&lt;/p&gt;

&lt;p&gt;　　这里顺便一提两个基本概念，内存泄漏和内存溢出：&lt;/p&gt;
&lt;p&gt;　　内存溢出（Memory Overflow）比较好理解，就是我们保存对象需要的空间太大了，但是申请内存比较小，于是装不下，于是就会报内存溢出异常，比如说你申请了一个integer,但给它存了long才能存下的数，那就是内存溢出；专业点的说法就是：你要求分配的内存超出了系统能给你的，系统不能满足需求，于是产生溢出。&lt;/p&gt;
&lt;p&gt;　　内存泄漏（Memory Leak）指的就是我们new出来的对象保存在堆中但是没有释放，于是堆中内存会越来越少，会导致系统运行速度减慢，严重情况会使程序卡死；专业点的说法就是：你用malloc或new申请了一块内存，但是没有通过free或delete将内存释放，导致这块内存一直处于占用状态。&lt;/p&gt;
&lt;p&gt;　　对于我们jvm来说，通常情况下我们不用担心内存泄漏，因为有一个强大的gc在我们程序的背后默默地为我们清理，但是也会有特殊情况，比如当被分配的对象可达但已无用（未对作废数据内存单元的赋值null）即会引起，至于这个可达是什么意思，后面会慢慢说到；&lt;/p&gt;
&lt;p&gt;　　相对而言内存溢出我们比较常见，还有gc只会对堆内存进行回收，所以静态变量是不会回收的；&lt;/p&gt;

&lt;p&gt;　　再顺便提一下另外两个小概念，非守护线程（也叫用户线程）和守护线程，看下面这个丑陋的程序运行会有几个线程啊？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; User{
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
      System.out.println(&lt;/span&gt;&quot;我是java小新人&quot;&lt;span&gt;);
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　两个线程，一个是执行main方法的线程，后台还有gc执行gc的线程，在这里，用户线程就是执行main方法的那个线程，执行gc的线程就是守护线程，默默地守护者jvm，假如jvm是雅典娜，那么守护线程就是黄金圣斗士；&lt;/p&gt;
&lt;p&gt;　　当用户线程停止之后整个程序直接停止，守护线程也会终止；但是黄金圣斗士挂了雅典娜还是可以好好活着的继续愉快的玩耍的；&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.堆内存结构&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　哎，内存中的结构如果真的要通过源代码去看，简直让人崩溃，除了专业搞这方面的不然真的很难懂，本来我想自己画一下草图了，发现太丑陋了，于是去顺手借了一张图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201904/1368608-20190418111633617-1571949442.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　途中可以很清楚的看到，整块堆内存分为年轻人聚集的地方和老年人聚集的地方，年轻人比较少趋势占用1/3空间（新生代），老年人比较多就占用2/3的空间（老年代），然而啊，年轻人又要分分类，分别是Eden区占新生代8/10，From Survivor区占新生代1/10，To Survivor区占新生代1/10，emmm。。。我特意查了一下百度翻译，Eden----&amp;gt;乐园，Survivor-----&amp;gt;幸存者；哦~~~我感觉我仿佛明白了命名人的意图！&lt;/p&gt;
&lt;p&gt;　　 那么新生代和老年代到底是干什么的呢？我们创建的对象是放在哪里啊？&lt;/p&gt;
&lt;p&gt;　　新生代：java对象申请内存和存放对象的地方，而且存放的对象都是那种死的比较快的对象，很多时候创建没多久就清理掉了，那些活的时间比较长的对象都被移动到了老年代。&lt;/p&gt;
&lt;p&gt;　　老年代：存大对象比如长字符串、数组由于需要大量连续的内存空间，可以直接进入老年代；还有长期存活的对象也会进入老年代，具体是多长时间呢，其实默认就是经过15 对新生代的清理（Minor Gc）还能活着的对象。&lt;/p&gt;
&lt;p&gt; 　　而垃圾收集器对这两块内存有两种行为，&lt;span&gt;一种是对新生代的清理，叫做Minor Gc，另外一种是对老年代的清理被叫做Major Gc。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　顺便提一点：很多博客中都把Major GC和Full GC说成是一种，其实还是有区别的，因为很多java虚拟机的实现不一样，所以就有各种各样的名称，比如Minor Gc又叫做Young GC，Major GC也可以叫做Old GC，但是Full GC却有点不同，Full GC 是清理整个堆空间 —— 包括年轻代、老年代和永久代（也叫做方法区）。因此 Full GC 可以说是 Minor GC 和 Major GC 的结合。当然在我们这里，为了好理解我们也就把Full GC当作Major GC就可以了。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.筛选清理对象&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　GC要工作的话，必须首先知道哪些对象要被清理，你想一下，在新生代和老年代有这么多对象，怎么筛选会又快又省事呢？可以有以下两种方法&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;1.引用计数算法&lt;/span&gt;，相当于给你创建的对象偷偷的添加一个计数器，每引用一次这个对象，计数器就加一，引用失效就减一，当这个计数器为0的时候，说明这个对象没有变量引用了，于是我们就可以说这个对象可以被清理了&lt;/p&gt;
&lt;p&gt; 　　&lt;span&gt;2.根搜索算法（jvm用的就是这个）&lt;/span&gt;，这个怎么理解呢？你可以想象现在有一个数组，这个数组里面包含了一些东西的引用，我们将这个数组叫做”GC Root“，然后我们根据这个数组中的引用去找到对应的对象，看看这个对象中又引用了哪些对象，一直往下找，这样就形成了很多线路，在这个线路上的对象就叫做”可达对象“，不在这个线路上的对象就是不可达对象，而不可达对象也就是我们要清理的对象；&lt;/p&gt;
&lt;p&gt;　　其中可以作为GC Root的对象：&lt;/p&gt;
&lt;p&gt;   &lt;strong&gt;   &lt;/strong&gt;&lt;span&gt;（1）.类中的静态变量，当它持有一个指向一个对象的引用时，它就作为root&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      （2）.活动着的线程，可以作为root&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      （3）.一个Java方法的参数或者该方法中的局部变量，这两种对象可以作为root&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      （4）.JNI方法中的局部变量或者参数，这两种对象可以作为root&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      （5）.其它。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　关于这个根搜索算法专业一点的说法就是：通过一系列的名为“GC Root”的对象作为起始点，从这些节点开始向下搜索，搜索所有走过的路径称为引用链（Reference Chain）,当一个对象到GC Root没有任何引用链相连时（用图论来说就是GC Root到这个对象不可达时），证明该对象是可以被回收的。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.进行垃圾回收&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　前面已经筛选出了我们要清理的对象，但是怎么清理比较快呢？难道要一个一个对象慢慢删除嘛？就好像你要清理手机中的垃圾，你会一个应用一个应用去慢慢清理数据吗？当然不可能，这也太浪费时间了！我们当然是用手机管家或者360管家先把要清理的东西给收集起来放在一起，然后我们一清理就是全部，一个字，爽！&lt;/p&gt;
&lt;p&gt;　　ok，在这里也一样，我们要想办法把所有的要清理的对象给放在一起清理，有什么办法呢？&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;1.标记-----清除算法&lt;/strong&gt;：这种方法分为两步，先标记然后清除，其实就是需要回收的对象标记一下，然后就是把有标记的对象全部清理即可；这种方式比较适合对象比较少的内存，假如对象太多标记都要好半天，更别说清除了，而且用这种方法清除的内存空间会东一块西一块，下次再创建一个大的对象可能会出问题1&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;2.复制算法&lt;/strong&gt;：按内存容量将内存划分为等大小的两块。每次只使用其中一块，当这一块内存满后将尚&lt;span&gt;存活的对象&lt;/span&gt;复制到另一块上去，把已经使用的那块内存直接全部清理掉；这种方法最大的缺陷就是耗内存啊，只能用总内存的一半，而且如果对象很多复制都要花很多时间。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;3.标记----整理算法&lt;/strong&gt;：结合以上两种方法优缺点进行改良的一种方法，标记和第一种方法一样把要清理的对象做好标记，然后把所有标记的对象移动到本内存的一个小角落，最后集中力量对那个小角落进行消灭&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;4.分代收集算法&lt;/strong&gt;：这是集中了上面三种方法的优点所实现的一种最好的方法，是目前大部分JVM所采用的方法，这种算法的核心思想是根据对象存活的时间不同将内存划分为不同的域，一般情况下将GC堆划分为新生代和老年代；新生代的特点是每次垃圾回收时都有大量垃圾需要被回收，少数对象存活，因此可以使用复制算法；老年代的特点是每次垃圾回收时只有少量对象需要被回收，可以选用”标记--清除方法“”或者标记--整理算法“&lt;/p&gt;
&lt;p&gt;　　所以目前大部分JVM的GC都是使用分代收集算法。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;5.执行GC的步骤&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　前面说了这么多无非是介绍堆的内部结构，然后怎么找到要被清理的对象，然后为了提高效率怎么清理最快！&lt;/p&gt;
&lt;p&gt;　　现在我们就大概说说GC的清理步骤（&lt;span&gt;详细版&lt;/span&gt;）：&lt;/p&gt;
&lt;p&gt;　　1.我们创建对象的时候会进行一个判断，极少数很大的对象直接放进老年代中，除此之外所有新创建的对象都放进新生代的Eden区中；&lt;/p&gt;
&lt;p&gt;　　2.此时新生代中只有Eden区中有对象，两个Survivor区中是空的；当我们创建了很多对象，使得Eden区快满的时候第一次GC发生（就是执行了一次Minior GC），Eden区和”From“区（此时“From”区是空的）存活的对象将会被移动到Surviver区的“To”区，并且为每个对象设置一个计数器记录年龄，初始值为1；每进行一次GC，会给那些存活的对象设置一个年龄+1 的操作，默认是当年龄达到15岁，下次GC就会直接把这种”老油条“丢到老年代中。&lt;/p&gt;
&lt;p&gt;　　3.Minior GC之后，会进行一个比较厉害的操作，就是将”To“区和”From“换个名字，没错，就是换个名字，然后进行下一次Minior GC。&lt;/p&gt;
&lt;p&gt;　　4.由于又创建了很多对象使得Eden区要满了，于是又一次Minior GC，Eden区还存活的对象会直接移动到Surviver区的“To”区，此时”From“区（这里就是交换名字之前的”To“区）中的对象有两个地方可以去，要么年龄满15岁了去老年代，要么就移动到”To“区&lt;/p&gt;
&lt;p&gt;　　5.此时我们看一下，只有”To“区的对象是活着的，Eden区都是垃圾对象可以直接全部清理，”From“区是空的；不管怎样，在进行下一次Minior GC之前保证名为”To“的Survivor区域是空的就ok了&lt;/p&gt;
&lt;p&gt;　　6.当老年代中快要装满之后，就会进行一次Major GC，这个清理事件很慢，至少比Minior GC慢十几倍，甚至更多，所以我们尽量要少执行Major GC&lt;/p&gt;
&lt;p&gt;　　注意：如果在移动过程中”To“ 区被填满了，剩余的对象会被直接移动到老年代中。还有在每次Minior GC之前会先进性判断，只要老年代里面的连续空间大于新生代对象总大小或者历次晋升的平均大小进行Minor GC，否则进行Major GC。&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;简化版：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;17&quot;&gt;
&lt;p&gt;　　（1）Eden 区活着的对象 ＋ From Survivor 存储的对象被复制到 To Survivor ；&lt;/p&gt;
&lt;p&gt;　　（2)清空 Eden 和 From Survivor ；&lt;/p&gt;
&lt;p&gt;　　（3)颠倒 From Survivor 和 To Survivor 的逻辑关系： From 变 To ， To 变 From 。&lt;/p&gt;
&lt;p&gt;　　（4）老年代的Major GC执行时间很长，尽量少执行&lt;/p&gt;
&lt;p&gt;　　只有在Eden空间快满的时候才会触发 Minor GC 。而 Eden 空间占新生代的绝大部分，所以 Minor GC 的频率得以降低。当然，使用两个 Survivor 这种方式我们也付出了一定的代价，如 10% 的空间浪费、复制对象的开销等。&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;6.知识点补充&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　通过查看了很多大佬的博客看到的很多有关的东西还是挺有趣的，于是简单做个小笔记：&lt;/p&gt;
&lt;p&gt;　　6.1.新创建的对象是在堆中的新生代的Eden区，由于堆中内存是所有线程共享，所以在堆中分配内存需要加锁。而Sun JDK为提升效率，会为每个新建的线程在Eden上分配一块独立的空间由该线程独享，这块空间称为TLAB（Thread Local Allocation Buffer）。在TLAB上分配内存不需要加锁，因此JVM在给线程中的对象分配内存时会尽量在TLAB上分配。如果对象过大或TLAB用完，则仍然在堆上Eden区或者老年代进行分配。如果Eden区内存也用完了，则会进行一次Minor GC（young GC）。&lt;/p&gt;
&lt;p&gt;　　6.2.很多人认为方法区（或者HotSpot虚拟机中的永久代）是没有垃圾收集的，Java虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾收集，而且在方法区进行垃圾收集的“性价比”一般比较低：在堆中，尤其是在新生代中，常规应用进行一次垃圾收集一般可以回收70%~95%的空间，而永久代的垃圾收集效率远低于此。&lt;/p&gt;
&lt;p&gt;　　6.3对象调用.finalize方法被调用后，对象一定会被回收吗？&lt;/p&gt;
&lt;p&gt;　　在经过可达性分析后，到GC Roots不可达的对象可以被回收（但并不是一定会被回收，至少要经过两次标记），此时对象被第一次标记，并进行一次判断，如果该对象没有调用过或者没有重写finalize()方法，那么在第二次标记后可以被回收了；否则，该对象会进入一个FQueue中，稍后由JVM建立的一个Finalizer线程中去执行回收，此时若对象中finalize中“自救”，即和引用链上的任意一个对象建立引用关系，到GC Roots又可达了，在第二次标记时它会被移除“即将回收”的集合；如果finalize中没有逃脱，那就面临被回收。因此finalize方法被调用后，对象不一定会被回收。&lt;/p&gt;
&lt;p&gt;　　6.4.如果在Survivor空间中相同年龄所有对象大小总和大于Survivor空间的一半，年龄大于或者等于该年龄的对象直接进入老年代。不需要等到15岁。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　这篇说的就是java虚拟机怎么去收集对内存的垃圾，首先是要通过可达性分析判断哪些对象是可达的，哪些是不可达的，那些不可达的对象就是我们要处理的对象！这些不可达对象可能在新生代和老年代都有，在新生代用复制算法去处理垃圾，老年代用标记整理算法处理垃圾，这种处理方式也可以叫做分代收集算法！而且还简单说了一下Minor GC和Major GC的触发方式！&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　基本的东西就这么多，假如要深入的话可以深入很多，比如我们可以控制新生代的大小，还有很多种垃圾处理器的实现产品等等，都是可以去慢慢了解的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 18 Apr 2019 14:44:00 +0000</pubDate>
<dc:creator>java小新人</dc:creator>
<og:description>上一节是把大概的流程给过了一遍，但是还有很多地方没有说到，后续的慢慢会涉及到，敬请期待！ 这次我们说说垃圾收集器，又名gc，顾名思义，就是收集垃圾的容器，那什么是垃圾呢？在我们这里指的就是堆中那些没人</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wyq1995/p/10726998.html</dc:identifier>
</item>
<item>
<title>xamarin.forms之实现ListView列表倒计时 - 社会主义接班人</title>
<link>http://www.cnblogs.com/5ishare/p/10732899.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/5ishare/p/10732899.html</guid>
<description>&lt;p&gt;   做商城类APP时经常会遇到抢购倒计时的功能，之前做小区宝iOS的时候也有类似的功能，想着参考iOS做的思路，自定义一个Cell，在Cell中每秒刷新一下控件的文本值，但使用xamarin.forms实现时，自定义cell的方式并不可行，小伙伴上周给发了一个倒计时功能的demo：https://github.com/jsuarezruiz/MyTripCountdown，demo是如下图实现的是一个时间的倒计时效果，需要将一个倒计时的功能放在列表中，实现多个倒计时的效果， 看了源码也一直没思路，昨天也是没思路报着试一试的心态动手操作了下，没想到成功了，还是非常有成就感的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733213/201904/733213-20190418220441069-2124758670.png&quot; alt=&quot;&quot; width=&quot;251&quot; height=&quot;351&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一、定义计时器&lt;/p&gt;
&lt;p&gt;xamarin.forms提供了Device.StartTimer来实现定时任务，每隔一秒需要触发事件改变剩余时间。这里定义了两个Action，Completed是在倒计时结束时触发，Ticked是每秒触发一次。RemainTime是剩余时间timespan，EndDate为结束时间。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Xamarin.Forms;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; TimeCountDown
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CountDown : BindableObject
    {
        TimeSpan _remainTime;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;event&lt;/span&gt;&lt;span&gt; Action Completed;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;event&lt;/span&gt;&lt;span&gt; Action Ticked;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DateTime EndDate { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; TimeSpan RemainTime
        {
            &lt;/span&gt;&lt;span&gt;get&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; _remainTime; }

            &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;
            {
                _remainTime &lt;/span&gt;=&lt;span&gt; value;
                OnPropertyChanged();
            }
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Start(&lt;span&gt;int&lt;/span&gt; seconds = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
        {
            Device.StartTimer(TimeSpan.FromSeconds(seconds), () &lt;/span&gt;=&amp;gt;&lt;span&gt;
            {
                RemainTime &lt;/span&gt;= (EndDate -&lt;span&gt; DateTime.Now);

                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; ticked = RemainTime.TotalSeconds &amp;gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ticked)
                {
                    Ticked&lt;/span&gt;?&lt;span&gt;.Invoke();
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                {
                    Completed&lt;/span&gt;?&lt;span&gt;.Invoke();
                }

                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ticked;
            });
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;二、设置BaseViewModel&lt;/p&gt;
&lt;p&gt;这里创建了一个BaseViewModel，并有2个方法，LoadAsync()、UnloadAsync()，而且继承了ExtendedBindableObject。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; TimeCountDown
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BaseViewModel : ExtendedBindableObject
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt;&lt;span&gt; Task LoadAsync()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Task.CompletedTask;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt;&lt;span&gt; Task UnloadAsync()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Task.CompletedTask;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在ExtendedBindableObject中扩展了BindableObject，增加了SetProperty方法，SetProperty方法使用ref引用改变属性的值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Runtime.CompilerServices;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Xamarin.Forms;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; TimeCountDown
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ExtendedBindableObject : BindableObject
    {
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; SetProperty&amp;lt;T&amp;gt;(&lt;span&gt;ref&lt;/span&gt; T backingStore, T value, [CallerMemberName]&lt;span&gt;string&lt;/span&gt; propertyName = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (EqualityComparer&amp;lt;T&amp;gt;&lt;span&gt;.Default.Equals(backingStore, value))
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }

            backingStore &lt;/span&gt;=&lt;span&gt; value;
            OnPropertyChanged(propertyName);

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;三、设置ViewModel&lt;/p&gt;
&lt;p&gt;新建继承BaseViewModel的类CountDownViewModel，在CountDownViewModel中定义了倒计时类CountDown，当CountDownViewModel调用构造函数时实例化倒计时CountDown，EndDate通过时间戳获得，之后调用LoadAsync()方法，启动计时器，并为计时器绑定具体Actio，在Ticked的Action中每秒定时刷新绑定到界面的数值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; TimeCountDown
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CountDownViewModel : BaseViewModel
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; Tick { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; _countDownTitle;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; CountDownTitle
        {
            &lt;/span&gt;&lt;span&gt;get&lt;/span&gt; =&amp;gt;&lt;span&gt; _countDownTitle;
            &lt;/span&gt;&lt;span&gt;set&lt;/span&gt; =&amp;gt; SetProperty(&lt;span&gt;ref&lt;/span&gt;&lt;span&gt; _countDownTitle, value);
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; CountDown _countDown;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; CountDownViewModel(&lt;span&gt;long&lt;/span&gt;&lt;span&gt; ticks)
        {
            Tick &lt;/span&gt;=&lt;span&gt; ticks;
            _countDown &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; CountDown() { EndDate = DateTime.Now.Add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; TimeSpan(ticks)) };
            LoadAsync();

        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt;&lt;span&gt; Task LoadAsync()
        {
            _countDown.Start();
            _countDown.Ticked &lt;/span&gt;+=&lt;span&gt; OnCountdownTicked;
            _countDown.Completed &lt;/span&gt;+=&lt;span&gt; OnCountdownCompleted;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;base&lt;/span&gt;&lt;span&gt;.LoadAsync();
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt;&lt;span&gt; Task UnloadAsync()
        {
            _countDown.Ticked &lt;/span&gt;-=&lt;span&gt; OnCountdownTicked;
            _countDown.Completed &lt;/span&gt;-=&lt;span&gt; OnCountdownCompleted;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;base&lt;/span&gt;&lt;span&gt;.UnloadAsync();
        }

        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnCountdownTicked()
        {
            CountDownTitle &lt;/span&gt;= &lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{0}:{1}:{2}后开抢&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, _countDown.RemainTime.Hours, _countDown.RemainTime.Minutes, _countDown.RemainTime.Seconds);
        }

        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnCountdownCompleted()
        {
            CountDownTitle &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;抢购进行中&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            UnloadAsync();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;四、测试&lt;/p&gt;
&lt;p&gt;在MainPage中设置了一个ListView，ViewCell模板中设置了一个Label，Text值绑定了CountDownTitle。在MainPage的构造方法中设置listview的ItemsSource。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; encoding=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ?&amp;gt;
&amp;lt;ContentPage xmlns=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://xamarin.com/schemas/2014/forms&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
             xmlns:x&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://schemas.microsoft.com/winfx/2009/xaml&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
             xmlns:local&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;clr-namespace:TimeCountDown&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
             x:Class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TimeCountDown.MainPage&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;StackLayout&amp;gt;
        &amp;lt;ListView x:Name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;listView&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;  VerticalOptions=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;FillAndExpand&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; HorizontalOptions=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;FillAndExpand&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
            &amp;lt;ListView.ItemTemplate&amp;gt;
                &amp;lt;DataTemplate&amp;gt;
                    &amp;lt;ViewCell&amp;gt;
                        &amp;lt;Label Text=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{Binding CountDownTitle}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; FontSize=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; TextColor=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Black&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; HorizontalOptions=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;FillAndExpand&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; VerticalOptions=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;FillAndExpand&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/Label&amp;gt;
                    &amp;lt;/ViewCell&amp;gt;
                &amp;lt;/DataTemplate&amp;gt;
            &amp;lt;/ListView.ItemTemplate&amp;gt;
        &amp;lt;/ListView&amp;gt;
    &amp;lt;/StackLayout&amp;gt;
&amp;lt;/ContentPage&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; MainPage()
        {
            InitializeComponent();
            List&lt;/span&gt;&amp;lt;CountDownViewModel&amp;gt; countDownVMs = &lt;span&gt;new&lt;/span&gt; List&amp;lt;CountDownViewModel&amp;gt;&lt;span&gt;() {
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; CountDownViewModel(&lt;span&gt;11111111111&lt;/span&gt;&lt;span&gt;),
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; CountDownViewModel(&lt;span&gt;2222222222&lt;/span&gt;&lt;span&gt;),
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; CountDownViewModel(&lt;span&gt;3333333333333&lt;/span&gt;&lt;span&gt;),
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; CountDownViewModel(&lt;span&gt;444444444444&lt;/span&gt;&lt;span&gt;),
            };
            listView.ItemsSource &lt;/span&gt;=&lt;span&gt; countDownVMs;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;效果图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733213/201904/733213-20190418223301782-335013866.png&quot; alt=&quot;&quot; width=&quot;452&quot; height=&quot;904&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733213/201904/733213-20190418223221510-1159738894.png&quot; alt=&quot;&quot; width=&quot;445&quot; height=&quot;890&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 18 Apr 2019 14:34:00 +0000</pubDate>
<dc:creator>社会主义接班人</dc:creator>
<og:description>做商城类APP时经常会遇到抢购倒计时的功能，之前做小区宝iOS的时候也有类似的功能，想着参考iOS做的思路，自定义一个Cell，在Cell中每秒刷新一下控件的文本值，但使用xamarin.forms实</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/5ishare/p/10732899.html</dc:identifier>
</item>
<item>
<title>基于redis的分布式锁实现 - 小熊餐馆</title>
<link>http://www.cnblogs.com/xiaoxiongcanguan/p/10718202.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaoxiongcanguan/p/10718202.html</guid>
<description>&lt;p&gt;　　在计算机系统中，锁作为一种控制并发的机制无处不在。&lt;/p&gt;
&lt;p&gt;　　单机环境下，操作系统能够在进程或线程之间通过本地的锁来控制并发程序的行为。而在如今的大型复杂系统中，通常采用的是分布式架构提供服务。&lt;/p&gt;
&lt;p&gt;　　分布式环境下，基于本地单机的锁无法控制分布式系统中分开部署客户端的并发行为，此时&lt;strong&gt;分布式锁&lt;/strong&gt;就应运而生了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一个可靠的分布式锁应该具备以下特性：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　1.互斥性：&lt;/strong&gt;作为锁，需要保证任何时刻只能有一个客户端(用户)持有锁&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　2.可重入： &lt;/strong&gt;同一个客户端在获得锁后，可以再次进行加锁&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　3.高可用：&lt;/strong&gt;获取锁和释放锁的效率较高，不会出现单点故障&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;4.自动重试机制：&lt;/strong&gt;当客户端加锁失败时，能够提供一种机制让客户端自动重试&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 分布式锁 api接口
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; DistributeLock {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 尝试加锁
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; lockKey 锁的key
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 加锁成功 返回uuid
     *         加锁失败 返回null
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    String lock(String lockKey);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 尝试加锁 (requestID相等 可重入)
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; lockKey 锁的key
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; expireTime 过期时间 单位：秒
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 加锁成功 返回uuid
     *         加锁失败 返回null
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    String lock(String lockKey, &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; expireTime);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 尝试加锁 (requestID相等 可重入)
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; lockKey 锁的key
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; requestID 用户ID
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 加锁成功 返回uuid
     *         加锁失败 返回null
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    String lock(String lockKey, String requestID);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 尝试加锁 (requestID相等 可重入)
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; lockKey 锁的key
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; requestID 用户ID
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; expireTime 过期时间 单位：秒
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 加锁成功 返回uuid
     *         加锁失败 返回null
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    String lock(String lockKey, String requestID, &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; expireTime);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 尝试加锁，失败自动重试 会阻塞当前线程
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; lockKey 锁的key
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 加锁成功 返回uuid
     *         加锁失败 返回null
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    String lockAndRetry(String lockKey);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 尝试加锁，失败自动重试 会阻塞当前线程 (requestID相等 可重入)
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; lockKey 锁的key
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; requestID 用户ID
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 加锁成功 返回uuid
     *         加锁失败 返回null
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    String lockAndRetry(String lockKey, String requestID);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 尝试加锁 (requestID相等 可重入)
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; lockKey 锁的key
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; expireTime 过期时间 单位：秒
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 加锁成功 返回uuid
     *         加锁失败 返回null
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    String lockAndRetry(String lockKey, &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; expireTime);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 尝试加锁 (requestID相等 可重入)
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; lockKey 锁的key
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; expireTime 过期时间 单位：秒
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; retryCount 重试次数
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 加锁成功 返回uuid
     *         加锁失败 返回null
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    String lockAndRetry(String lockKey, &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; expireTime, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; retryCount);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 尝试加锁 (requestID相等 可重入)
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; lockKey 锁的key
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; requestID 用户ID
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; expireTime 过期时间 单位：秒
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 加锁成功 返回uuid
     *         加锁失败 返回null
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    String lockAndRetry(String lockKey, String requestID, &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; expireTime);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 尝试加锁 (requestID相等 可重入)
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; lockKey 锁的key
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; expireTime 过期时间 单位：秒
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; requestID 用户ID
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; retryCount 重试次数
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 加锁成功 返回uuid
     *         加锁失败 返回null
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    String lockAndRetry(String lockKey, String requestID, &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; expireTime, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; retryCount);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 释放锁
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; lockKey 锁的key
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; requestID 用户ID
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; true     释放自己所持有的锁 成功
     *         false    释放自己所持有的锁 失败
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; unLock(String lockKey, String requestID);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;3.1 基础代码 &lt;/h2&gt;
&lt;p&gt;　　当前实现版本的分布式锁基于redis实现，使用的是jedis连接池来和redis进行交互，并将其封装为&lt;strong&gt;redisClient工具类&lt;/strong&gt;(仅封装了demo所需的少数接口)&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;redisClient工具类：&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('f203037c-b06c-4567-b3af-3bf754a7775f')&quot; readability=&quot;45&quot;&gt;&lt;img id=&quot;code_img_closed_f203037c-b06c-4567-b3af-3bf754a7775f&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_f203037c-b06c-4567-b3af-3bf754a7775f&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('f203037c-b06c-4567-b3af-3bf754a7775f',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_f203037c-b06c-4567-b3af-3bf754a7775f&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;85&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RedisClient {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Logger LOGGER = LoggerFactory.getLogger(RedisClient.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; JedisPool pool;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; RedisClient instance = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RedisClient();

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; RedisClient() {
        init();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; RedisClient getInstance(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; instance;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Object eval(String script, List&amp;lt;String&amp;gt; keys, List&amp;lt;String&amp;gt;&lt;span&gt; args) {
        Jedis jedis &lt;/span&gt;=&lt;span&gt; getJedis();
        Object result &lt;/span&gt;=&lt;span&gt; jedis.eval(script, keys, args);
        jedis.close();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String get(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; String key){
        Jedis jedis &lt;/span&gt;=&lt;span&gt; getJedis();
        String result &lt;/span&gt;=&lt;span&gt; jedis.get(key);
        jedis.close();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String set(&lt;span&gt;final&lt;/span&gt; String key, &lt;span&gt;final&lt;/span&gt; String value, &lt;span&gt;final&lt;/span&gt; String nxxx, &lt;span&gt;final&lt;/span&gt; String expx, &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; time) {
        Jedis jedis &lt;/span&gt;=&lt;span&gt; getJedis();
        String result &lt;/span&gt;=&lt;span&gt; jedis.set(key, value, nxxx, expx, time);
        jedis.close();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; init(){
        Properties redisConfig &lt;/span&gt;= PropsUtil.loadProps(&quot;redis.properties&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; maxTotal = PropsUtil.getInt(redisConfig,&quot;maxTotal&quot;,10&lt;span&gt;);
        String ip &lt;/span&gt;= PropsUtil.getString(redisConfig,&quot;ip&quot;,&quot;127.0.0.1&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; port = PropsUtil.getInt(redisConfig,&quot;port&quot;,6379&lt;span&gt;);

        JedisPoolConfig jedisPoolConfig &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JedisPoolConfig();
        jedisPoolConfig.setMaxTotal(maxTotal);
        pool &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JedisPool(jedisPoolConfig, ip,port);
        LOGGER.info(&lt;/span&gt;&quot;连接池初始化成功 ip={}, port={}, maxTotal={}&quot;&lt;span&gt;,ip,port,maxTotal);
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Jedis getJedis(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; pool.getResource();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;&lt;strong&gt;所依赖的工具类：&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('ed49f027-aafa-4bef-9972-252684ca77f0')&quot; readability=&quot;46.5&quot;&gt;&lt;img id=&quot;code_img_closed_ed49f027-aafa-4bef-9972-252684ca77f0&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_ed49f027-aafa-4bef-9972-252684ca77f0&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('ed49f027-aafa-4bef-9972-252684ca77f0',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_ed49f027-aafa-4bef-9972-252684ca77f0&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;88&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; util;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.slf4j.Logger;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.slf4j.LoggerFactory;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.FileNotFoundException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.InputStream;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Properties;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * @Author xiongyx
 * @Create 2018/4/11.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; PropsUtil {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Logger LOGGER = LoggerFactory.getLogger(PropsUtil.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 读取配置文件
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Properties loadProps(String fileName){
        Properties props &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        InputStream is &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::绝对路径获得输入流&lt;/span&gt;
            is =&lt;span&gt; Thread.currentThread().getContextClassLoader().getResourceAsStream(fileName);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(is == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::没找到文件,抛出异常&lt;/span&gt;
                &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; FileNotFoundException(fileName + &quot; is not found&quot;&lt;span&gt;);
            }
            props &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Properties();
            props.load(is);
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(IOException e){
            LOGGER.error(&lt;/span&gt;&quot;load propertis file fail&quot;&lt;span&gt;,e);
        }&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(is != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::关闭io流&lt;/span&gt;
&lt;span&gt;                    is.close();
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                    LOGGER.error(&lt;/span&gt;&quot;close input Stream fail&quot;&lt;span&gt;,e);
                }
            }
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; props;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获取字符串属性(默认为空字符串)
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; String getString(Properties properties,String key){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::调用重载函数 默认值为:空字符串&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; getString(properties,key,&quot;&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获取字符串属性
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; String getString(Properties properties,String key,String defaultValue){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::key对应的value数据是否存在&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(properties.containsKey(key)){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; properties.getProperty(key);
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; defaultValue;
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获取int属性 默认值为0
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getInt(Properties properties,String key){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::调用重载函数，默认为:0&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; getInt(properties,key,0&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获取int属性
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; getInt(Properties properties,String key,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; defaultValue){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::key对应的value数据是否存在&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(properties.containsKey(key)){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; CastUtil.castToInt(properties.getProperty(key));
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; defaultValue;
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获取boolean属性，默认值为false
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; getBoolean(Properties properties,String key){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; getBoolean(properties,key,&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获取boolean属性
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; getBoolean(Properties properties,String key,&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; defaultValue){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::key对应的value数据是否存在&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(properties.containsKey(key)){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; CastUtil.castToBoolean(properties.getProperty(key));
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; defaultValue;
        }
    }
}


&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CastUtil {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 转为 string
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; String castToString(Object obj){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; castToString(obj,&quot;&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 转为 string 提供默认值
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; String castToString(Object obj,String defaultValue){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(obj == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; defaultValue;
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; obj.toString();
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 转为 int
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; castToInt(Object obj){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; castToInt(obj,0&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 转为 int 提供默认值
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; castToInt(Object obj,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; defaultValue){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(obj == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; defaultValue;
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Integer.parseInt(obj.toString());
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 转为 double
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; castToDouble(Object obj){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; castToDouble(obj,0&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 转为 double 提供默认值
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; castToDouble(Object obj,&lt;span&gt;double&lt;/span&gt;&lt;span&gt; defaultValue){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(obj == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; defaultValue;
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Double.parseDouble(obj.toString());
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 转为 long
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; castToLong(Object obj){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; castToLong(obj,0&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 转为 long 提供默认值
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; castToLong(Object obj,&lt;span&gt;long&lt;/span&gt;&lt;span&gt; defaultValue){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(obj == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; defaultValue;
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Long.parseLong(obj.toString());
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 转为 boolean
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; castToBoolean(Object obj){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;  castToBoolean(obj,&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 转为 boolean 提供默认值
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; castToBoolean(Object obj,&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; defaultValue){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(obj == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; defaultValue;
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Boolean.parseBoolean(obj.toString());
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;&lt;strong&gt;初始化lua脚本 LuaScript.java：&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　在分布式锁初始化时，使用init方法读取lua脚本&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('48f2d952-d99d-4b6c-9433-92ef3787cb84')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_48f2d952-d99d-4b6c-9433-92ef3787cb84&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_48f2d952-d99d-4b6c-9433-92ef3787cb84&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('48f2d952-d99d-4b6c-9433-92ef3787cb84',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_48f2d952-d99d-4b6c-9433-92ef3787cb84&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LuaScript {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 加锁脚本 lock.lua
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String LOCK_SCRIPT = &quot;&quot;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 解锁脚本 unlock.lua
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String UN_LOCK_SCRIPT = &quot;&quot;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; init(){
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            initLockScript();
            initUnLockScript();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RuntimeException(e);
        }
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; initLockScript() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
        String filePath &lt;/span&gt;= Objects.requireNonNull(LuaScript.&lt;span&gt;class&lt;/span&gt;.getClassLoader().getResource(&quot;lock.lua&quot;&lt;span&gt;)).getPath();
        LOCK_SCRIPT &lt;/span&gt;=&lt;span&gt; readFile(filePath);
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; initUnLockScript() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
        String filePath &lt;/span&gt;= Objects.requireNonNull(LuaScript.&lt;span&gt;class&lt;/span&gt;.getClassLoader().getResource(&quot;unlock.lua&quot;&lt;span&gt;)).getPath();
        UN_LOCK_SCRIPT &lt;/span&gt;=&lt;span&gt; readFile(filePath);
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String readFile(String filePath) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; (
            FileReader reader &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileReader(filePath);
            BufferedReader br &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BufferedReader(reader)
        ) {
            String line;
            StringBuilder stringBuilder &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuilder();
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; ((line = br.readLine()) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                stringBuilder.append(line).append(System.lineSeparator());
            }

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; stringBuilder.toString();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;单例的RedisDistributeLock基础属性&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; RedisDistributeLock &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; DistributeLock {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 无限重试
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; UN_LIMIT_RETRY = -1&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; RedisDistributeLock() {
        LuaScript.init();
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; DistributeLock instance = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RedisDistributeLock();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 持有锁 成功标识
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Long ADD_LOCK_SUCCESS = 1L&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 释放锁 失败标识
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Integer RELEASE_LOCK_SUCCESS = 1&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 默认过期时间 单位：秒
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEFAULT_EXPIRE_TIME_SECOND = 300&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 默认加锁重试时间 单位：毫秒
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEFAULT_RETRY_FIXED_TIME = 3000&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 默认的加锁浮动时间区间 单位：毫秒
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEFAULT_RETRY_TIME_RANGE = 1000&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 默认的加锁重试次数
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEFAULT_RETRY_COUNT = 30&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * lockCount Key前缀
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String LOCK_COUNT_KEY_PREFIX = &quot;lock_count:&quot;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; DistributeLock getInstance(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; instance;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3.2 加锁实现&lt;/h2&gt;
&lt;p&gt;　　使用redis实现分布式锁时，加锁操作必须是原子操作，否则多客户端并发操作时会导致各种各样的问题。详情请见：&lt;a href=&quot;http://wudashan.com/2017/10/23/Redis-Distributed-Lock-Implement/&quot; target=&quot;_blank&quot;&gt;Redis分布式锁的正确实现方式&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;　　由于我们实现的是可重入锁，加锁过程中需要判断客户端ID的正确与否。而redis原生的简单接口没法保证一系列逻辑的原子性执行，因此采用了lua脚本来实现加锁操作。lua脚本可以让redis在执行时将一连串的操作以原子化的方式执行。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;加锁lua脚本 lock.lua&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 获取参数&lt;/span&gt;
&lt;span&gt;local&lt;/span&gt; requestIDKey = KEYS[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;local&lt;/span&gt; lockCountKey = KEYS[&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]

&lt;/span&gt;&lt;span&gt;local&lt;/span&gt; currentRequestID = ARGV[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;local&lt;/span&gt; expireTimeTTL = ARGV[&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]

&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt; setnx 尝试加锁&lt;/span&gt;
&lt;span&gt;local&lt;/span&gt; lockSet = redis.call(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;setnx&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,requestIDKey,currentRequestID)

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; lockSet == &lt;span&gt;1&lt;/span&gt;
&lt;span&gt;then&lt;/span&gt;
    &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 加锁成功 设置过期时间和重入次数&lt;/span&gt;
    redis.call(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;expire&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,requestIDKey,expireTimeTTL)
    redis.call(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,lockCountKey,&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
    redis.call(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;expire&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,lockCountKey,expireTimeTTL)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;
&lt;span&gt;else&lt;/span&gt;
    &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 判断是否是重入加锁&lt;/span&gt;
    &lt;span&gt;local&lt;/span&gt; oldRequestID = redis.call(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,requestIDKey)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; currentRequestID ==&lt;span&gt; oldRequestID
    &lt;/span&gt;&lt;span&gt;then&lt;/span&gt;
        &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 是重入加锁&lt;/span&gt;
        redis.call(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;incr&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,lockCountKey)
        &lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 重置过期时间&lt;/span&gt;
        redis.call(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;expire&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,requestIDKey,expireTimeTTL)
        redis.call(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;expire&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,lockCountKey,expireTimeTTL)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;
    &lt;span&gt;else&lt;/span&gt;
        &lt;span&gt;--&lt;/span&gt;&lt;span&gt; requestID不一致，加锁失败&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;
    &lt;span&gt;end&lt;/span&gt;
&lt;span&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;strong&gt;加锁方法实现：&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;加锁时，通过判断eval的返回值来判断加锁是否成功。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;   @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String lock(String lockKey) {
        String uuid &lt;/span&gt;=&lt;span&gt; UUID.randomUUID().toString();

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; lock(lockKey,uuid);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String lock(String lockKey, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; expireTime) {
        String uuid &lt;/span&gt;=&lt;span&gt; UUID.randomUUID().toString();

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; lock(lockKey,uuid,expireTime);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String lock(String lockKey, String requestID) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; lock(lockKey,requestID,DEFAULT_EXPIRE_TIME_SECOND);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String lock(String lockKey, String requestID, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; expireTime) {
        RedisClient redisClient &lt;/span&gt;=&lt;span&gt; RedisClient.getInstance();

        List&lt;/span&gt;&amp;lt;String&amp;gt; keyList =&lt;span&gt; Arrays.asList(
                lockKey,
                LOCK_COUNT_KEY_PREFIX &lt;/span&gt;+&lt;span&gt; lockKey
        );

        List&lt;/span&gt;&amp;lt;String&amp;gt; argsList =&lt;span&gt; Arrays.asList(
                requestID,
                expireTime &lt;/span&gt;+ &quot;&quot;&lt;span&gt;
        );
        Long result &lt;/span&gt;=&lt;span&gt; (Long)redisClient.eval(LuaScript.LOCK_SCRIPT, keyList, argsList);

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(result.equals(ADD_LOCK_SUCCESS)){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; requestID;
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;3.3 解锁实现&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;解锁操作同样需要一连串的操作，由于原子化操作的需求，因此同样使用lua脚本实现解锁功能。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;解锁lua脚本 unlock.lua&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 获取参数&lt;/span&gt;
&lt;span&gt;local&lt;/span&gt; requestIDKey = KEYS[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;local&lt;/span&gt; lockCountKey = KEYS[&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]

&lt;/span&gt;&lt;span&gt;local&lt;/span&gt; currentRequestID = ARGV[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]

&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 判断requestID一致性&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; redis.call(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, requestIDKey) ==&lt;span&gt; currentRequestID
&lt;/span&gt;&lt;span&gt;then&lt;/span&gt;
    &lt;span&gt;--&lt;/span&gt;&lt;span&gt; requestID相同，重入次数自减&lt;/span&gt;
    &lt;span&gt;local&lt;/span&gt; currentCount = redis.call(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;decr&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,lockCountKey)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; currentCount == &lt;span&gt;0&lt;/span&gt;
    &lt;span&gt;then&lt;/span&gt;
        &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 重入次数为0，删除锁&lt;/span&gt;
        redis.call(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;del&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,requestIDKey)
        redis.call(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;del&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,lockCountKey)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;
    &lt;span&gt;else&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;end&lt;/span&gt;
&lt;span&gt;else&lt;/span&gt; 
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;strong&gt;解锁方法实现：&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;   @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; unLock(String lockKey, String requestID) {
        List&lt;/span&gt;&amp;lt;String&amp;gt; keyList =&lt;span&gt; Arrays.asList(
                lockKey,
                LOCK_COUNT_KEY_PREFIX &lt;/span&gt;+&lt;span&gt; lockKey
        );

        List&lt;/span&gt;&amp;lt;String&amp;gt; argsList =&lt;span&gt; Collections.singletonList(requestID);

        Object result &lt;/span&gt;=&lt;span&gt; RedisClient.getInstance().eval(LuaScript.UN_LOCK_SCRIPT, keyList, argsList);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 释放锁成功&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; RELEASE_LOCK_SUCCESS.equals(result);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3.4 自动重试机制实现&lt;/h2&gt;
&lt;p&gt;　　调用lockAndRetry方法进行加锁时，如果加锁失败，则当前客户端线程会短暂的休眠一段时间，并进行重试。在重试了一定的次数后，会终止重试加锁操作，从而加锁失败。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;需要注意的是&lt;/strong&gt;，加锁失败之后的线程休眠时长是&lt;strong&gt;&quot;固定值 + 随机值&quot;，&lt;/strong&gt;引入随机值的主要目的是防止高并发时大量的客户端在几乎同一时间被唤醒并进行加锁重试，给redis服务器带来周期性的、不必要的瞬时压力。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String lockAndRetry(String lockKey) {
        String uuid &lt;/span&gt;=&lt;span&gt; UUID.randomUUID().toString();

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; lockAndRetry(lockKey,uuid);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String lockAndRetry(String lockKey, String requestID) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; lockAndRetry(lockKey,requestID,DEFAULT_EXPIRE_TIME_SECOND);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String lockAndRetry(String lockKey, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; expireTime) {
        String uuid &lt;/span&gt;=&lt;span&gt; UUID.randomUUID().toString();

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; lockAndRetry(lockKey,uuid,expireTime);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String lockAndRetry(String lockKey, &lt;span&gt;int&lt;/span&gt; expireTime, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; retryCount) {
        String uuid &lt;/span&gt;=&lt;span&gt; UUID.randomUUID().toString();

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; lockAndRetry(lockKey,uuid,expireTime,retryCount);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String lockAndRetry(String lockKey, String requestID, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; expireTime) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; lockAndRetry(lockKey,requestID,expireTime,DEFAULT_RETRY_COUNT);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String lockAndRetry(String lockKey, String requestID, &lt;span&gt;int&lt;/span&gt; expireTime, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; retryCount) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(retryCount &amp;lt;= 0&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; retryCount小于等于0 无限循环，一直尝试加锁&lt;/span&gt;
            &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;){
                String result &lt;/span&gt;=&lt;span&gt; lock(lockKey,requestID,expireTime);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(result != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
                }

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 休眠一会&lt;/span&gt;
&lt;span&gt;                sleepSomeTime();
            }
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; retryCount大于0 尝试指定次数后，退出&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0; i&amp;lt;retryCount; i++&lt;span&gt;){
                String result &lt;/span&gt;=&lt;span&gt; lock(lockKey,requestID,expireTime);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(result != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
                }

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 休眠一会&lt;/span&gt;
&lt;span&gt;                sleepSomeTime();
            }

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　通过在方法上引入RedisLock注解切面，让对应方法被redis分布式锁管理起来，可以简化redis分布式锁的使用。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;切面注解 RedisLock &lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; RedisLock {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 无限重试
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; UN_LIMIT_RETRY =&lt;span&gt; RedisDistributeLock.UN_LIMIT_RETRY;

    String lockKey();
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; expireTime();
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; retryCount();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;strong&gt;RedisLock 切面实现&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Component
@Aspect
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RedisLockAspect {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Logger LOGGER = LoggerFactory.getLogger(RedisLockAspect.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ThreadLocal&amp;lt;String&amp;gt; REQUEST_ID_MAP = &lt;span&gt;new&lt;/span&gt; ThreadLocal&amp;lt;&amp;gt;&lt;span&gt;();

    @Pointcut(&lt;/span&gt;&quot;@annotation(annotation.RedisLock)&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; annotationPointcut() {
    }

    @Around(&lt;/span&gt;&quot;annotationPointcut()&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Object around(ProceedingJoinPoint joinPoint) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
        MethodSignature methodSignature &lt;/span&gt;=&lt;span&gt; (MethodSignature)joinPoint.getSignature();
        Method method &lt;/span&gt;=&lt;span&gt; methodSignature.getMethod();
        RedisLock annotation &lt;/span&gt;= method.getAnnotation(RedisLock.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; lockSuccess =&lt;span&gt; lock(annotation);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(lockSuccess){
            Object result &lt;/span&gt;=&lt;span&gt; joinPoint.proceed();
            unlock(annotation);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 加锁
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; lock(RedisLock annotation){
        DistributeLock distributeLock &lt;/span&gt;=&lt;span&gt; RedisDistributeLock.getInstance();

        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; retryCount =&lt;span&gt; annotation.retryCount();

        String requestID &lt;/span&gt;=&lt;span&gt; REQUEST_ID_MAP.get();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(requestID != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当前线程 已经存在requestID&lt;/span&gt;
&lt;span&gt;            distributeLock.lockAndRetry(annotation.lockKey(),requestID,annotation.expireTime(),retryCount);
            LOGGER.info(&lt;/span&gt;&quot;重入加锁成功 requestID=&quot; +&lt;span&gt; requestID);

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当前线程 不存在requestID&lt;/span&gt;
            String newRequestID =&lt;span&gt; distributeLock.lockAndRetry(annotation.lockKey(),annotation.expireTime(),retryCount);

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(newRequestID != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 加锁成功，设置新的requestID&lt;/span&gt;
&lt;span&gt;                REQUEST_ID_MAP.set(newRequestID);
                LOGGER.info(&lt;/span&gt;&quot;加锁成功 newRequestID=&quot; +&lt;span&gt; newRequestID);

                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                LOGGER.info(&lt;/span&gt;&quot;加锁失败，超过重试次数，直接返回 retryCount={}&quot;&lt;span&gt;,retryCount);

                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 解锁
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; unlock(RedisLock annotation){
        DistributeLock distributeLock &lt;/span&gt;=&lt;span&gt; RedisDistributeLock.getInstance();
        String requestID &lt;/span&gt;=&lt;span&gt; REQUEST_ID_MAP.get();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(requestID != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 解锁成功&lt;/span&gt;
            &lt;span&gt;boolean&lt;/span&gt; unLockSuccess =&lt;span&gt; distributeLock.unLock(annotation.lockKey(),requestID);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(unLockSuccess){
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 移除 ThreadLocal中的数据&lt;/span&gt;
&lt;span&gt;                REQUEST_ID_MAP.remove();
                LOGGER.info(&lt;/span&gt;&quot;解锁成功 requestID=&quot; +&lt;span&gt; requestID);
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;strong&gt;使用例子&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
@Service(&quot;testService&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; TestServiceImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; TestService {

    @Override
    @RedisLock(lockKey &lt;/span&gt;= &quot;lockKey&quot;, expireTime = 100, retryCount =&lt;span&gt; RedisLock.UN_LIMIT_RETRY)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String method1() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;method1&quot;&lt;span&gt;;
    }

    @Override
    @RedisLock(lockKey &lt;/span&gt;= &quot;lockKey&quot;, expireTime = 100, retryCount = 3&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String method2() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;method2&quot;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;5.1 当前版本缺陷&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;主从同步可能导致锁的互斥性失效&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　在redis主从结构下，出于性能的考虑，redis采用的是主从异步复制的策略，这会导致短时间内主库和从库数据短暂的不一致。&lt;/p&gt;
&lt;p&gt;　　试想，当某一客户端刚刚加锁完毕，redis主库还没有来得及和从库同步就挂了，之后从库中&lt;strong&gt;新选拔出的主库是没有对应锁记录&lt;/strong&gt;的，这就可能导致多个客户端加锁成功，破坏了锁的互斥性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;休眠并反复尝试加锁效率较低&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;strong&gt;lockAndRetry&lt;/strong&gt;方法在客户端线程加锁失败后，会休眠一段时间之后再进行重试。当锁的持有者持有锁的时间很长时，其它客户端会有大量无效的重试操作，造成系统资源的浪费。&lt;/p&gt;
&lt;p&gt;　　进一步优化时，可以使用发布订阅的方式。这时加锁失败的客户端会监听锁被释放的信号，在锁真正被释放时才会进行新的加锁操作，从而避免不必要的轮询操作，以提高效率。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不是一个公平的锁&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　当前实现版本中，多个客户端同时对锁进行抢占时，是完全随机的，既不遵循先来后到的顺序，客户端之间也没有加锁的优先级区别。&lt;/p&gt;
&lt;p&gt;　　后续优化时可以提供一个创建公平锁的接口，能指定加锁的优先级，内部使用一个优先级队列维护加锁客户端的顺序。公平锁虽然效率稍低，但在一些场景能更好的控制并发行为。&lt;/p&gt;
&lt;h2&gt;5.2 经验总结&lt;/h2&gt;
&lt;p&gt;　　前段时间看了一篇关于redis分布式锁的技术文章，发现自己对于分布式锁的了解还很有限。纸上得来终觉浅，为了更好的掌握相关知识，决定尝试着自己实现一个demo级别的redis分布式锁，通过这次实践，更进一步的学习了lua语言和redis相关内容。&lt;/p&gt;
&lt;p&gt;　　这篇博客的完整代码在我的github上：&lt;a href=&quot;https://github.com/1399852153/RedisDistributedLock&quot;&gt;https://github.com/1399852153/RedisDistributedLock&lt;/a&gt;，存在许多不足之处，请多多指教。&lt;/p&gt;
</description>
<pubDate>Thu, 18 Apr 2019 14:06:00 +0000</pubDate>
<dc:creator>小熊餐馆</dc:creator>
<og:description>1.分布式锁介绍 在计算机系统中，锁作为一种控制并发的机制无处不在。 单机环境下，操作系统能够在进程或线程之间通过本地的锁来控制并发程序的行为。而在如今的大型复杂系统中，通常采用的是分布式架构提供服务</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaoxiongcanguan/p/10718202.html</dc:identifier>
</item>
</channel>
</rss>