<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Newbe.ObjectVisitor 0.4.4 发布，模型验证器上线 - Newbe36524</title>
<link>http://www.cnblogs.com/newbe36524/p/14105833.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/newbe36524/p/14105833.html</guid>
<description>&lt;p&gt;Newbe.Claptrap 0.4.4 发布，模型验证器上线。&lt;/p&gt;
&lt;h2 id=&quot;更新内容&quot;&gt;更新内容&lt;/h2&gt;
&lt;h3 id=&quot;完全基于表达式树的模型验证器&quot;&gt;完全基于表达式树的模型验证器&lt;/h3&gt;
&lt;p&gt;本版本，我们带来了基于表达式树实现的模型验证器。并实现了很多内置的验证方法。&lt;/p&gt;
&lt;p&gt;我们罗列了与 FluentValidation 比较的情况：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Build in Validators&lt;/th&gt;
&lt;th&gt;FluentValidation 9.X&lt;/th&gt;
&lt;th&gt;Newbe.ObjectVistor&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;19&quot;&gt;&lt;tr&gt;&lt;td&gt;NotNull&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;td&gt;✔️ NotNull; class&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;NotEmpty&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;td&gt;✔️ NotEmpty; string,enumerable&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;NotEqual&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;td&gt;✔️ NotEqual; all&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Equal&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;td&gt;✔️ Equal; all&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;Length&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;td&gt;✔️ Length; string,enumerable&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;MaxLength&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;td&gt;✔️ MaxLength; string,enumerable&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;MinLength&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;td&gt;✔️ MinLength; string,enumerable&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Less Than&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;td&gt;✔️ LessThan; number&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Less Than Or Equal&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;td&gt;✔️ LessThanOrEqual; number&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Greater Than&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;td&gt;✔️ GreaterThan; number&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Greater Than Or Equal&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;td&gt;✔️ GreaterThanOrEqual; number&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Predicate&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;td&gt;✔️ Validate; all&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;Regular Expression&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;td&gt;✔️ MatchRegex,NotMatchRegex; string&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Email&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;td&gt;💭 MatchRegex; string&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Credit Card&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;td&gt;💭 MatchRegex; string&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;Enum&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;td&gt;✔️ IsInEnum; number,string,enum&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Enum Name&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;td&gt;✔️ IsEnumName; string&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;Empty&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;td&gt;✔️ Empty; string,enumerable&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Null&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;td&gt;✔️ Null; class&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;ExclusiveBetween&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;td&gt;✔️ IsInRange; number,enum&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;InclusiveBetween&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;td&gt;✔️ IsInRange; number,enum&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;ScalePrecision&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;td&gt;✔️ ScalePrecision; number&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Or&lt;/td&gt;
&lt;td&gt;❌&lt;/td&gt;
&lt;td&gt;✔️ Or; all&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;IsInSet&lt;/td&gt;
&lt;td&gt;❌&lt;/td&gt;
&lt;td&gt;✔️ IsInSet; all&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;IsNotInSet&lt;/td&gt;
&lt;td&gt;❌&lt;/td&gt;
&lt;td&gt;✔️ IsNotInSet; all&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;CanParse&lt;/td&gt;
&lt;td&gt;❌&lt;/td&gt;
&lt;td&gt;🚧 CanParse; all&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;fluentapi-生成器重构的代码&quot;&gt;FluentAPI 生成器重构的代码&lt;/h3&gt;
&lt;p&gt;我们基于 0.3 已经发布的 FluentAPI 进行了核心代码重构，现在一些特定场景下需要您指定的泛型参数更少了，但是功能没有减少，更有利您进行开发。&lt;/p&gt;
&lt;p&gt;类似的，例如下面这个变更：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;  // create a data visitor to cover sensitive data
  _visitor = default(UserModel).V()
-     .ForEach&amp;lt;UserModel, string&amp;gt;(x =&amp;gt; CoverSensitiveData(x))
+     .ForEach&amp;lt;string&amp;gt;(x =&amp;gt; CoverSensitiveData(x))
      .Cache();
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;同时支持英文与简体中文方法注释&quot;&gt;同时支持英文与简体中文方法注释&lt;/h3&gt;
&lt;p&gt;在热心网友 &lt;a href=&quot;https://github.com/EventHorizon1024&quot;&gt;EventHorizon1024&lt;/a&gt; 的帮助下，我们在保留英文作为原始注释的情况下，对使用简体中文 IDE 的开发者们提供了全简中的方法说明。&lt;/p&gt;
&lt;p&gt;开发者无需特殊操作，便可以在 IDE 中直接查看到简体中文的方法注释。&lt;/p&gt;
&lt;p&gt;如何实现的详细操作方法，开发者也可以通过以下链接借鉴使用：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/dotnet/roslyn/issues/3371#issuecomment-737623706&quot;&gt;https://github.com/dotnet/roslyn/issues/3371#issuecomment-737623706&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;开发文章站点正式上线&quot;&gt;开发文章站点正式上线&lt;/h3&gt;
&lt;p&gt;我们非常顺利的上线了开发文档站点：&lt;/p&gt;
&lt;p&gt;后续所有关于本工具包相关的文章除了在博客 &lt;a href=&quot;https://www.newbe.pro&quot;&gt;https://www.newbe.pro&lt;/a&gt; 及相关博客公布之外，我们将会更新以上站点，丰富其中的文档。&lt;/p&gt;
&lt;p&gt;目前，我们已经上线了几篇简单的文档：&lt;/p&gt;
</description>
<pubDate>Wed, 09 Dec 2020 00:53:00 +0000</pubDate>
<dc:creator>Newbe36524</dc:creator>
<og:description>Newbe.Claptrap 0.4.4 发布，模型验证器上线。 更新内容 完全基于表达式树的模型验证器 本版本，我们带来了基于表达式树实现的模型验证器。并实现了很多内置的验证方法。 我们罗列了与 F</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/newbe36524/p/14105833.html</dc:identifier>
</item>
<item>
<title>spring框架半自动注解 - 农家肥</title>
<link>http://www.cnblogs.com/huasshuai/p/14106712.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huasshuai/p/14106712.html</guid>
<description>&lt;p&gt;   为了简便我们的开发，让我们一起来学习半自动注解吧。&lt;/p&gt;

&lt;pre&gt;
让Spring管理某些类&lt;br/&gt;1、在需要被SpringIOC容器管理的类上打上相应的注解&lt;br/&gt;@Component:任意组件&lt;br/&gt;@Controller:控制层组件注解&lt;br/&gt;@Service:服务层组件注解&lt;br/&gt;@Repository:持久层组件注解&lt;br/&gt;value:如果不指定该属性，则被注解的类在SpringIOC容器默认的注册名称为类名首字母小写，如果指定之后则不使用默认名称注册&lt;br/&gt;2、在XML文件中开启注解驱动&lt;br/&gt;&amp;lt;context:component-scan&amp;gt;:配置扫描器扫描的包，扫描器会自动扫描包下被打上了组件注解的类，并加入到SpringIOC容器中&lt;br/&gt;设置该类在被SpringIOC容器创建时的初始值&lt;br/&gt;@Value:设置该属性的初始值，如果注入引用值，则需要使用SpEL&lt;br/&gt;懒加载&lt;br/&gt;@Lazy:打上该注解之后，默认值为true，进行懒加载，只有在使用的时候才回去初始化，如果没打该注解，则会在SpringIOC容器初始化时一并初始化&lt;br/&gt;作用域(默认是单例的)&lt;br/&gt;@Scope:作用域，指定该类的对象创建出来是单例的还是非单例的的singleton,prototype&lt;br/&gt;自动注入属性&lt;br/&gt;@Autowired:自动注入属性，前提是被注入的内容也需要被SpringIOC容器管理&lt;br/&gt;根据名称注入&lt;br/&gt;@Qualifier:设置引用的Bean的name&lt;br/&gt;vlaue:指定name
&lt;/pre&gt;</description>
<pubDate>Wed, 09 Dec 2020 00:52:00 +0000</pubDate>
<dc:creator>农家肥</dc:creator>
<og:description>为了简便我们的开发，让我们一起来学习半自动注解吧。 让Spring管理某些类 1、在需要被SpringIOC容器管理的类上打上相应的注解 @Component:任意组件 @Controller:控制层</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/huasshuai/p/14106712.html</dc:identifier>
</item>
<item>
<title>代码整洁之道的 7 个方法 - 削微寒</title>
<link>http://www.cnblogs.com/xueweihan/p/14106697.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xueweihan/p/14106697.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202012/759200-20201209084138032-1659169409.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5.1111111111111&quot;&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;https://dev.to/joachimzeelmaekers/clean-up-your-code-by-applying-these-7-rules-35ee&quot;&gt;Clean up your code by applying these 7 rules ⚡️&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原文作者：&lt;a href=&quot;https://twitter.com/JoachimZeelmae1&quot;&gt;Joachim Zeelmaekers&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者 &amp;amp; 校正：HelloGitHub-小鱼干 &amp;amp; HelloGitHub-鸭鸭&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;可读的代码是可维护的&quot;&gt;可读的代码是可维护的&lt;/h2&gt;
&lt;p&gt;在这篇短文中，我将介绍一些你可以用来改进你的代码的方法。本文代码示例均使用 JavaScript。&lt;/p&gt;
&lt;p&gt;我发现但凡是可读的代码必定是可维护的。&lt;/p&gt;
&lt;p&gt;作为一名开发人员，我的目标是编写高质量的代码。团队中的每个开发人员，不管他/她的技术水平如何，都必须能够通过阅读理解我所写的代码。代码的可读性有助于年轻的开发人员编写代码时更加自信。&lt;/p&gt;
&lt;h2 id=&quot;删除-不必要的-代码注释&quot;&gt;删除 &lt;s&gt;不必要的&lt;/s&gt; 代码注释&lt;/h2&gt;
&lt;p&gt;当然，有些代码可以非常复杂。我深知这一点且见过很多次。在复杂的代码中，我会写些适当的文档和代码注释。&lt;/p&gt;
&lt;p&gt;别误会。我不是代码注释或 JavaScript JSdoc 的爱好者，而且基本上我能不用它们便不用。&lt;/p&gt;
&lt;p&gt;我不需要任何注释来解释这个接收 X 个数组并将它们合并到一个新的数组中的函数。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;function mergeArrays(...arrays) {
  let mergedArray = []

  arrays.forEach(array =&amp;gt; {
      mergedArray = [...mergedArray, ...array]
  })

  return mergedArray
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;像示例代码，如果增添文档并不能提高可读性。我希望团队成员知道展开操作符是什么。如果他们不清楚，他们应该在代码审查 code review 时来问我。&lt;/p&gt;
&lt;p&gt;当然，我们不要忘记注释的代码块。如果我们忘记了，这里只有一个解决方案：&lt;strong&gt;删除代码&lt;/strong&gt;。既然了不起的 git 可以检出旧代码，那么为什么还要把它留在注释中呢？&lt;/p&gt;
&lt;p&gt;请停止把你的代码库变成垃圾场。&lt;/p&gt;
&lt;h2 id=&quot;重视命名&quot;&gt;重视命名&lt;/h2&gt;
&lt;p&gt;如果你看到函数名 mergeArrays，就应该很清楚地知道这是一个将 X 个数组组合成一个新的数组的函数。&lt;/p&gt;
&lt;p&gt;我知道命名是件难事。函数越复杂，命名就越难… 我有个法子让命名更容易，举个例子：有一个函数，它会合并两个数组并生成一个新的唯一的数字列表。你会怎么命名？是下面这样吗？&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;function mergeNumberListIntoUniqueList(listOne, listTwo) {
  return [...new Set([...listOne, ...listTwo])]
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;mergeNumberListIntoUniqueList&lt;/code&gt; 这个名字并没有那么糟糕，至少功能如其名。命名的难点在于这个函数要做两件事：一个函数做的事情越多，命名它就越困难。将这个函数拆分为两个单独的函数，命名会更容易且函数复用更容易。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;function mergeLists(listOne, listTwo) {
  return [...listOne, ...listTwo]
}

function createUniqueList(list) {
  return [...new Set(list)]
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然，不需要调用新函数就可以很容易地创建美观的一行代码。但有时，一行代码的可读性并不高。&lt;/p&gt;
&lt;h2 id=&quot;if-语句&quot;&gt;If 语句&lt;/h2&gt;
&lt;p&gt;我对这个问题的命名无力… 看！命名不易…&lt;/p&gt;
&lt;p&gt;但我经常看到这种情况。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;问题&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;if(value === 'duck' || value === 'dog' || value === 'cat') {
  // ...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;解决方法&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;const options = ['duck', 'dog', 'cat'];
if (options.includes(value)) {
  // ...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样做，你创建了一段像是英语句子般的可读代码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果选项包含值，那么&lt;/strong&gt; ...&lt;/p&gt;
&lt;h3 id=&quot;提前退出机制&quot;&gt;提前退出机制&lt;/h3&gt;
&lt;p&gt;这个准则有很多种命名方式，但我选择了 “提前退出 Early exit” 这个名字。&lt;/p&gt;
&lt;p&gt;让我给你们看一段代码。我相信你们以前见过这样的东西。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;function handleEvent(event) {
  if (event) {
    const target = event.target;
    if (target) {
      // Your awesome piece of code that uses target
    }
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;来我们检查下对象 &lt;code&gt;event&lt;/code&gt; 是否为真，以及属性 &lt;code&gt;target&lt;/code&gt; 是否可用。问题是上面代码我们已经用了两个 &lt;code&gt;if&lt;/code&gt; 语句。&lt;/p&gt;
&lt;p&gt;让我们看看如何在这里实现 “提前退出”。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;function handleEvent(event) {
  if (!event || !event.target) {
    return;
  }
  // Your awesome piece of code that uses target
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这里用 “提前退出”，你可以检查是否 &lt;code&gt;event&lt;/code&gt; 和 &lt;code&gt;event.target&lt;/code&gt; 同时非假 。很明显，我们确信这一事件 &lt;code&gt;event.target&lt;/code&gt; 非假。因为如果这个语句为假，程序就不会执行其他代码。&lt;/p&gt;
&lt;h3 id=&quot;解构赋值&quot;&gt;解构赋值&lt;/h3&gt;
&lt;p&gt;在 JavaScript 中，我们可以解构数据和对象。&lt;/p&gt;
&lt;p&gt;根据 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment&quot;&gt;developer.mozilla.org&lt;/a&gt; 上的文档，&lt;code&gt;解构赋值语法是一种 JavaScript 表达式。通过解构赋值，可以将值从数组、属性从对象中取出，赋值给其他变量&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;一些代码示例&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;// Destructuring an object
const numbers = {one: 1, two: 2};
const {one, two} = numbers;
console.log(one); // 1
console.log(two); // 2

// Destructuring an array
const numbers = [1, 2, 3, 4, 5];
const [one, two] = numbers;
console.log(one); // 1
console.log(two); // 2
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解构的问题在于，它有时会为属性创建一个不好的命名。最好的例子是从 API 获取数据并接收具有 data 属性的响应对象。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;const url = &quot;http://localhost:8080/api/v1/organizers/1&quot;
const response = await axios.get(url)
const {name} = response.data
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个代码示例说明你正在获取 id 为 1 的 organizer。organizer 对象有一个名字，你可以解构它。这样做没什么问题。&lt;/p&gt;
&lt;p&gt;这段代码可以正常运行。但是为什么属性名还是 &lt;code&gt;name&lt;/code&gt;? 那将是整个范围中唯一的 &lt;code&gt;name&lt;/code&gt; 属性吗？属性名又来自哪个对象？&lt;/p&gt;
&lt;p&gt;通过重命名属性可避免这些问题。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;const url = &quot;http://localhost:8080/api/v1/organizers/1&quot;
const response = await axios.get(url)
const {name: organizerName} = response.data
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码变得更具可读性。每个人都知道变量是 organizer 的名字。&lt;/p&gt;
&lt;h2 id=&quot;童子军规则&quot;&gt;童子军规则&lt;/h2&gt;
&lt;p&gt;听过这样一句话吗：“永远保持离开时的露营地比你发现它时更整洁”？&lt;/p&gt;
&lt;p&gt;这就是童子军的规则。让代码比发现时更好。你发现代码异味 code smell？重构它！你发现一个未使用的变量？删除它！&lt;/p&gt;
&lt;p&gt;我喜欢把童子军规则和打扫房间的情况进行类比。想象一下，你家里的每个人都把盘子放在水槽上，把所有垃圾都放在走廊上，把所有要洗的衣服都放在浴室里。但是每个星期天，你必须花费 4 个多小时清理整个房子。你会钟意吗？&lt;/p&gt;
&lt;p&gt;我肯定答案是 NO。所以如果每个人都立即清理房间的小部分，星期天的工作量会小一些。&lt;/p&gt;
&lt;p&gt;代码库同理。如果每个小的代码异味 code smell 都留在代码库中，没有人删除未使用的变量，linter 就会抓狂且有大约 77 个 warning。而且代码库将会有很多清洁工作要做，但是如果每个人都承担起自己的责任并遵守童子军法则，很多问题将会得到解决。&lt;/p&gt;
&lt;h2 id=&quot;代码风格&quot;&gt;代码风格&lt;/h2&gt;
&lt;p&gt;同样重要的还有确定团队中的代码风格。&lt;/p&gt;
&lt;p&gt;我不 care 你是喜欢单引号还是双引号，空格还是 tab，结尾逗号还是不用。选择一种风格并坚持下去。你可以用 Linter 或者 Prettier 来做这件事。&lt;/p&gt;
&lt;p&gt;有很多工具可以用来解决代码风格问题。我最钟意的是使用 &lt;a href=&quot;https://github.com/typicode/husky&quot;&gt;Husky&lt;/a&gt; 预提交钩子。&lt;a href=&quot;https://prettier.io/docs/en/precommit.html&quot;&gt;Prettier&lt;/a&gt; 的文档中也有一个关于预提交钩子的页面。&lt;/p&gt;
&lt;p&gt;这个预提交钩子总是在每次提交之前运行配置好的命令。如果你正确地配置它，它会运行得更漂亮，并对所有文件应用所有规则。这确保了团队总是拥有统一的代码风格，而没有任何糟糕的代码。&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;我知道有些方法显而易见，有些则不是。但作为一名全职开发人员，我在不同的代码库上工作。这些规则的重要性只有在较大的代码库中才会突显。但这并不意味着你不应该将这些方法用在小项目中，提高你的代码质量让小项目更高效。它让团队成员方便地阅读你的代码并合并你的 pull 请求。正如我所说的，可读的代码更容易维护，当然可读的代码还有其他更多的好处。&lt;/p&gt;
&lt;p&gt;如果你想了解更多关于代码整洁之道的知识，可以尝试阅读罗伯特・马丁的《代码整洁之道》。&lt;/p&gt;
&lt;p&gt;最后，欢迎优秀的你加入 HelloGitHub 的「译文亦舞」系列，让你的才华舞动起来！把优秀的文章分享给更多的人。要求：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;平时浏览 GitHub、开源、编程、程序员等英文资讯和文章&lt;/li&gt;
&lt;li&gt;想把自己阅读到优秀的英文文章分享给更多的人&lt;/li&gt;
&lt;li&gt;翻译准确但不是直翻或机翻&lt;/li&gt;
&lt;li&gt;保证每月至少翻译或校正 1 篇高质量文章&lt;/li&gt;
&lt;li&gt;了解 Markdown 和排版规则&lt;/li&gt;
&lt;li&gt;联系我（备注：翻译和从那个平台来的）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;封面图来自 Unsplash 由 Kevin Ku 拍摄&lt;/p&gt;
</description>
<pubDate>Wed, 09 Dec 2020 00:42:00 +0000</pubDate>
<dc:creator>削微寒</dc:creator>
<og:description>原文地址：Clean up your code by applying these 7 rules ⚡️ 原文作者：Joachim Zeelmaekers 译者 &amp;amp;amp; 校正：HelloG</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xueweihan/p/14106697.html</dc:identifier>
</item>
<item>
<title>数据库读写分离这个坑，你应该踩过吧？ - 楼下小黑哥</title>
<link>http://www.cnblogs.com/goodAndyxublog/p/14106692.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/goodAndyxublog/p/14106692.html</guid>
<description>&lt;p&gt;Hello,大家好！我是楼下小黑哥，我又来了~&lt;/p&gt;
&lt;p&gt;今天分享一下刚入职公司第一次发布项目遇到的一个问题，一个数据库读写分离的坑。&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;事情是这样的，刚入职的时候接到了这样的一个业务需求：&lt;/p&gt;
&lt;p&gt;每个支付通道支付失败的时候都会返回特定的错误码，业务内部需要将通道特定的错误码转义成内部的错误码，这样对外就可以统一返回我们自己的错误码。&lt;/p&gt;
&lt;p&gt;这个需求其实不难，当时设计的系统架构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202012/1419561-20201209083820197-394028336.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;新增规则的流程简单分为三步：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;业务人员通过管理后台新增映射规则&lt;/li&gt;
&lt;li&gt;数据库新增、修改这条映射规则&lt;/li&gt;
&lt;li&gt;删除缓存&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这里之所以增加缓存，是因为这个场景每次支付都需要使用，使用缓存可以避免每次都去数据库读取，增加读取速度。&lt;/p&gt;
&lt;p&gt;后续支付请求业务流程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202012/1419561-20201209083820588-54902412.jpg&quot; alt=&quot;数据库读写分离-用户操作&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当缓存内映射规则不存在的时候，将会查询数据库，然后加载到缓存中。如果缓存内映射规则已存在，将会直接使用缓存内映射规则。&lt;/p&gt;
&lt;p&gt;这个业务流程其实比较简单，当时在测试环境测试也没问题，后续发布线上环境的却碰到奇怪的问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;新增规则之后，一段时间内，映射规则并没有生效。查看日志发现，查询数据库的时候，没有数据。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;这就很奇怪了，日志显示新增是成功，但是查询却没有数据。但是过了一段时间，再次查询却又有了数据。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;走查了下代码，发现并没有什么问题，第二天上班的时候请教了一下同事，才知道问题的原因：&lt;/p&gt;
&lt;p&gt;原来线上的数据库采用主从架构，数据读写分离，数据查询走的是从库。数据写入都是直接操作主库，后续再同步到从库。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;由于数据库同步存在延时，这就导致数据同步的这段时间，主从数据将会不一致，从库无法查询到最新的数据。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你之前的数据库系统架构是单库或者主备结构，当你第一次转到数据读写分离架构，这个坑大概率也会踩到。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202012/1419561-20201209083820851-1443471275.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;数据库系统架构发展&quot;&gt;数据库系统架构发展&lt;/h2&gt;
&lt;p&gt;下面我们首先了解一下数据库系统架构，最后再来看下如何解决主从同步延时的导致数据不一致。&lt;/p&gt;
&lt;h3 id=&quot;主备架构&quot;&gt;主备架构&lt;/h3&gt;
&lt;p&gt;业务发展的前期，数据访问量小，这时我们可以直接采用单库的架构。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202012/1419561-20201209083821024-1449770584.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不过我们一般不使用的上面的架构，因为存在单点的问题。若数据库出现故障，这段期间业务将会不可用。我们除了等待重启，其他没什么解决办法。&lt;/p&gt;
&lt;p&gt;所以我们会增加一个备库，实时同步主库的数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202012/1419561-20201209083821262-546067713.jpg&quot; alt=&quot;主备架构&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一旦「主库」出了故障，通过人工的方式，手动的将「主机」踢下线，将「备机」改为「主机」来继续提供服务。&lt;/p&gt;
&lt;p&gt;这种架构，部署维护简单，业务开发也无需任何改造。&lt;/p&gt;
&lt;p&gt;不过缺点也很明显，备库只有在主库有问题的时候才会被启用，存在一定的资源浪费的情况。&lt;/p&gt;
&lt;h3 id=&quot;主从架构&quot;&gt;主从架构&lt;/h3&gt;
&lt;p&gt;随着业务发展，请求量不断变大，数据量也不断变大，业务变得更加复杂，很快数据将会到达瓶颈。&lt;/p&gt;
&lt;p&gt;由于大多数业务都是读多写少，所以数据库读的最容易成为系统瓶颈。&lt;/p&gt;
&lt;p&gt;这时候我们可以提高读的性能，这时我们的可以采用的方案，增加从实例，主从同步，数据读写分离。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202012/1419561-20201209083821488-800471723.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到这个架构与主备没什么区别，主要区别在于主从架构下，从库与主库一样，时刻需要干活，主库提供写服务，从库只提供读服务。&lt;/p&gt;
&lt;p&gt;如果后续读的压力还是太大，我们还可以增加从库的数量，水平扩充读的能力。&lt;/p&gt;
&lt;p&gt;虽然主从架构帮我们解决读的瓶颈，但是由于主从之间需要数据同步，这天然就存在一定延时。&lt;/p&gt;
&lt;p&gt;在这延时窗口期内，从库的读只能读到一个旧数据，这也是上面案例问题的真正的原因。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202012/1419561-20201209083821688-426335741.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来我们来看下有什么办法可以优化这种情况。&lt;/p&gt;
&lt;h2 id=&quot;主从延时解决办法&quot;&gt;主从延时解决办法&lt;/h2&gt;
&lt;h3 id=&quot;忍受大法&quot;&gt;忍受大法&lt;/h3&gt;
&lt;p&gt;第一种解决办法，很简单，无他，不管他，没有读到也没事。这时业务不需要任何改造，你好，我好，她也好~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202012/1419561-20201209083821830-1997945577.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果业务对于数据一致性要求不高，我们就可以采用这种方案。&lt;/p&gt;
&lt;h3 id=&quot;数据同步写方案&quot;&gt;数据同步写方案&lt;/h3&gt;
&lt;p&gt;主从数据同步方案，一般都是采用的异步方式同步给备库。&lt;/p&gt;
&lt;p&gt;我们可以将其修改为同步方案，主从同步完成，主库上的写才能返回。&lt;/p&gt;
&lt;p&gt;​ &lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202012/1419561-20201209083822080-778670159.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;业务系统发起写操作，数据写主库&lt;/li&gt;
&lt;li&gt;写请求需要等待主从同步完成才能返回&lt;/li&gt;
&lt;li&gt;数据读从库，主从同步完成就能读到最新数据&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这种方案，我们只需要修改数据库之间同步配置即可，业务层无需修改，相对简单。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不过，由于主库写需要等待主从完成，写请求的时延将会增加，吞吐量将会降低。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这一点对于现在在线业务，可能无法接受。&lt;/p&gt;
&lt;h3 id=&quot;选择性强制读主&quot;&gt;选择性强制读主&lt;/h3&gt;
&lt;p&gt;对于需要强一致的场景，我们可以将其的读请求都操作主库，这样&lt;strong&gt;读写都在主库&lt;/strong&gt;，就没有不一致的情况。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202012/1419561-20201209083822530-453820426.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这种方案业务层需要改造一下，将其强制性读主，相对改造难度较低。&lt;/p&gt;
&lt;p&gt;不过这种方案相对于浪费了另一个数据库，增加主库的压力。&lt;/p&gt;
&lt;h3 id=&quot;中间件选择路由法&quot;&gt;中间件选择路由法&lt;/h3&gt;
&lt;p&gt;这种方案需要使用一个中间件，所有数据库操作都先发到中间件，由中间件再分发到相应的数据库。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202012/1419561-20201209083822784-934136814.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这时流程如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;写请求，中间件将会发到主库，同时记录一下此时写请求的 key（&lt;em&gt;操作表加主键等&lt;/em&gt;）&lt;/li&gt;
&lt;li&gt;读请求，如果此时 key 存在，将会路由到主库&lt;/li&gt;
&lt;li&gt;一定时间后（&lt;em&gt;经验值&lt;/em&gt;），中间件认为主从同步完成，删除这个 key，后续读将会读从库&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这种方案，可以保持数据读写的一致。&lt;/p&gt;
&lt;p&gt;但是系统架构增加了一个中间件，整体复杂度变高，业务开发也变得复杂，学习成本也比较高。&lt;/p&gt;
&lt;h3 id=&quot;缓存路由大法&quot;&gt;缓存路由大法&lt;/h3&gt;
&lt;p&gt;这种方案与中间件的方案流程比较类似，不过改造成本相对较低，不需要增加任何中间件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202012/1419561-20201209083823056-165921563.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这时流程如下:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;写请求发往主库，同时缓存记录操作的 key，缓存的失效时间设置为主从的延时&lt;/li&gt;
&lt;li&gt;读请求首先判断缓存是否存在
&lt;ul&gt;&lt;li&gt;若存在，代表刚发生过写操作，读请求操作主库&lt;/li&gt;
&lt;li&gt;若不存在，代表近期没发生写操作，读请求操作从库&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这种方案相对中间件的方案成本较低，但是呢我们此时又引入一个缓存组件，所有读写之间就又多了一步缓存操作。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;我们引入主从架构，数据读写分离，目的是为了解决业务快速发展,请求量变大，并发量变大，从而引发的数据库的读瓶颈。&lt;/p&gt;
&lt;p&gt;不过当引入新一个架构解决问题时，势必会带来另外一个问题，数据库读写分离之后，主从延迟从而导致数据不一致的情况。，&lt;/p&gt;
&lt;p&gt;为了解决主从延迟，数据不一致的情况，我们可以采用以下这几种方案：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;忍受大法&lt;/li&gt;
&lt;li&gt;数据库同步写方案&lt;/li&gt;
&lt;li&gt;选择性强制读主&lt;/li&gt;
&lt;li&gt;中间件选择路由法&lt;/li&gt;
&lt;li&gt;缓存路由大法&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;上面的方案都有各自的优点，当然也有相应的缺点，我们需要根据自己的业务情况，选择相应的解决方案。&lt;/p&gt;
&lt;p&gt;好了，今天的文章就到此。&lt;/p&gt;
&lt;p&gt;我是楼下小黑哥，下周见~&lt;/p&gt;
&lt;h2 id=&quot;参考链接&quot;&gt;参考链接&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/5JYtta9aMGcic7o_ejna-A&quot;&gt;数据库主从不一致，怎么解？&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;5.5555555555556&quot;&gt;
&lt;p&gt;欢迎关注我的公众号：小黑十一点半，获得日常干货推送。如果您对我的专题内容感兴趣，也可以关注我的博客：&lt;a href=&quot;https://studyidea.cn&quot;&gt;studyidea.cn&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 09 Dec 2020 00:38:00 +0000</pubDate>
<dc:creator>楼下小黑哥</dc:creator>
<og:description>Hello,大家好！我是楼下小黑哥，我又来了~ 今天分享一下刚入职公司第一次发布项目遇到的一个问题，一个数据库读写分离的坑。 前言 事情是这样的，刚入职的时候接到了这样的一个业务需求： 每个支付通道支</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/goodAndyxublog/p/14106692.html</dc:identifier>
</item>
<item>
<title>「生产事故」MongoDB复合索引引发的灾难 - Super-Kerwin</title>
<link>http://www.cnblogs.com/kkzhilu/p/14106687.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kkzhilu/p/14106687.html</guid>
<description>&lt;h2 id=&quot;前情提要&quot;&gt;前情提要&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;11月末&lt;code&gt;我司商品服务&lt;/code&gt;的&lt;code&gt;MongoDB主库&lt;/code&gt;曾出现过严重抖动、频繁锁库等情况。&lt;/li&gt;
&lt;li&gt;由于诸多业务存在插入&lt;code&gt;MongoDB&lt;/code&gt;、然后立即查询等逻辑，因此项目并未开启读写分离。&lt;/li&gt;
&lt;li&gt;最终定位问题是由于：服务器自身磁盘 + 大量&lt;code&gt;慢查询&lt;/code&gt;导致&lt;/li&gt;
&lt;li&gt;基于上述情况，运维同学后续着重增强了对&lt;code&gt;MongoDB慢查询&lt;/code&gt;的监控和告警&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;幸运的一点&lt;/strong&gt;：在出事故之前刚好完成了缓存过期时间的升级且过期时间为一个月，&lt;code&gt;C端查询&lt;/code&gt;都落在缓存上，因此没有造成&lt;code&gt;P0级&lt;/code&gt;事故，仅仅阻塞了部分&lt;code&gt;B端逻辑&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;br/&gt;&lt;h2 id=&quot;事故回放&quot;&gt;事故回放&lt;/h2&gt;
&lt;p&gt;我司的各种监控做的比较到位，当天突然收到了数据库服务器负载较高的告警通知，于是我和同事们就赶紧登录了&lt;code&gt;Zabbix监控&lt;/code&gt;，如下图所示，截图的时候是正常状态，当时事故期间忘记留图了，可以想象当时的数据曲线反正是该高的很低，该低的很高就是了。&lt;/p&gt;
&lt;blockquote readability=&quot;3.0172413793103&quot;&gt;
&lt;p&gt;Zabbix 分布式监控系统官网:&lt;a href=&quot;https://www.zabbix.com/&quot;&gt;https://www.zabbix.com/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/013f0fe90cab3635f64721fc20e33841.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;开始分析&quot;&gt;开始分析&lt;/h2&gt;
&lt;p&gt;我们研发是没有操控服务器权限的，因此委托运维同学帮助我们抓取了部分查询记录，如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;---------------------------------------------------------------------------------------------------------------------------+
Op          | Duration | Query                                                                                                                   ---------------------------------------------------------------------------------------------------------------------------+
query       | 5 s      | {&quot;filter&quot;: {&quot;orgCode&quot;: 350119, &quot;fixedStatus&quot;: {&quot;$in&quot;: [1, 2]}}, &quot;sort&quot;: {&quot;_id&quot;: -1}, &quot;find&quot;: &quot;sku_main&quot;}               
query       | 5 s      | {&quot;filter&quot;: {&quot;orgCode&quot;: 350119, &quot;fixedStatus&quot;: {&quot;$in&quot;: [1, 2]}}, &quot;sort&quot;: {&quot;_id&quot;: -1}, &quot;find&quot;: &quot;sku_main&quot;}               query       | 4 s      | {&quot;filter&quot;: {&quot;orgCode&quot;: 346814, &quot;fixedStatus&quot;: {&quot;$in&quot;: [1, 2]}}, &quot;sort&quot;: {&quot;_id&quot;: -1}, &quot;find&quot;: &quot;sku_main&quot;}               query       | 4 s      | {&quot;filter&quot;: {&quot;orgCode&quot;: 346814, &quot;fixedStatus&quot;: {&quot;$in&quot;: [1, 2]}}, &quot;sort&quot;: {&quot;_id&quot;: -1}, &quot;find&quot;: &quot;sku_main&quot;}              query       | 4 s      | {&quot;filter&quot;: {&quot;orgCode&quot;: 346814, &quot;fixedStatus&quot;: {&quot;$in&quot;: [1, 2]}}, &quot;sort&quot;: {&quot;_id&quot;: -1}, &quot;find&quot;: &quot;sku_main&quot;}
...
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查询很慢的话所有研发应该第一时间想到的就是&lt;code&gt;索引&lt;/code&gt;的使用问题，所以立即检查了一遍索引，如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;### 当时的索引

db.sku_main.ensureIndex({&quot;orgCode&quot;: 1, &quot;_id&quot;: -1},{background:true});
db.sku_main.ensureIndex({&quot;orgCode&quot;: 1, &quot;upcCode&quot;: 1},{background:true});
....
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我屏蔽了干扰项，反正能很明显的看出来，这个查询是完全可以命中索引的，所以就需要直面第一个问题：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;上述查询记录中排首位的慢查询到底是不是出问题的根源？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我的判断是：它应该不是数据库整体缓慢的根源，因为第一它的查询条件足够简单暴力，完全命中索引，在索引之上有一点其他的查询条件而已，第二在查询记录中也存在相同结构不同条件的查询，耗时非常短。&lt;/p&gt;
&lt;p&gt;在运维同学继续排查查询日志时，发现了另一个比较惊爆的查询，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;### 当时场景日志

query: { $query: { shopCategories.0: { $exists: false }, orgCode: 337451, fixedStatus: { $in: [ 1, 2 ] }, _id: { $lt: 2038092587 } }, $orderby: { _id: -1 } } planSummary: IXSCAN { _id: 1 } ntoreturn:1000 ntoskip:0 keysExamined:37567133 docsExamined:37567133 cursorExhausted:1 keyUpdates:0 writeConflicts:0 numYields:293501 nreturned:659 reslen:2469894 locks:{ Global: { acquireCount: { r: 587004 } }, Database: { acquireCount: { r: 293502 } }, Collection: { acquireCount: { r: 293502 } } } 

# 耗时
179530ms
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;耗时180秒且基于查询的&lt;code&gt;执行计划&lt;/code&gt;可以看出，它走的是&lt;code&gt;_id_&lt;/code&gt;索引，进行了全表扫描，扫描的数据总量为：37567133，不慢才怪。&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;迅速解决&quot;&gt;迅速解决&lt;/h2&gt;
&lt;p&gt;定位到问题后，没办法立即修改，第一要务是：&lt;code&gt;止损&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;结合当时的时间也比较晚了，因此我们发了公告，禁止了上述查询的功能并短暂暂停了部分业务，，过了一会之后进行了&lt;code&gt;主从切换&lt;/code&gt;，再去看&lt;code&gt;Zabbix监控&lt;/code&gt;就一切安好了。&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;分析根源&quot;&gt;分析根源&lt;/h2&gt;
&lt;p&gt;我们回顾一下查询的语句和我们预期的索引，如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;### 原始Query
db.getCollection(&quot;sku_main&quot;).find({ 
        &quot;orgCode&quot; : NumberLong(337451), 
        &quot;fixedStatus&quot; : { 
            &quot;$in&quot; : [
                1.0, 
                2.0
            ]
        }, 
        &quot;shopCategories&quot; : { 
            &quot;$exists&quot; : false
        }, 
        &quot;_id&quot; : { 
            &quot;$lt&quot; : NumberLong(2038092587)
        }
    }
).sort(
    { 
        &quot;_id&quot; : -1.0
    }
).skip(1000).limit(1000);

### 期望的索引
db.sku_main.ensureIndex({&quot;orgCode&quot;: 1, &quot;_id&quot;: -1},{background:true});
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;乍一看，好像一切都很Nice啊，字段&lt;code&gt;orgCode&lt;/code&gt;等值查询，字段&lt;code&gt;_id&lt;/code&gt;按照创建索引的方向进行倒序排序，为啥会这么慢？&lt;/p&gt;
&lt;p&gt;但是，关键的一点就在 &lt;code&gt;$lt&lt;/code&gt; 上&lt;/p&gt;
&lt;h3 id=&quot;知识点一：索引、方向及排序&quot;&gt;知识点一：索引、方向及排序&lt;/h3&gt;
&lt;p&gt;在MongoDB中，排序操作可以通过从索引中按照索引的顺序获取文档的方式，来保证结果的有序性。&lt;/p&gt;
&lt;p&gt;如果MongoDB的查询计划器没法从索引中得到排序顺序，那么它就需要在内存中对结果排序。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：不用索引的排序操作，会在内存超过32MB时终止，也就是说MongoDB只能支持32MB以内的非索引排序&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;知识点二：单列索引不在乎方向&quot;&gt;知识点二：单列索引不在乎方向&lt;/h3&gt;
&lt;p&gt;无论是MongoDB还是MySQL都是用的树结构作为索引，如果&lt;code&gt;排序方向&lt;/code&gt;和&lt;code&gt;索引方向&lt;/code&gt;相反，只需要从另一头开始遍历即可，如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# 索引
db.records.createIndex({a:1}); 

# 查询
db.records.find().sort({a:-1});

# 索引为升序，但是我查询要按降序，我只需要从右端开始遍历即可满足需求，反之亦然
MIN 0 1 2 3 4 5 6 7 MAX
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;mongodb的复合索引结构&quot;&gt;MongoDB的复合索引结构&lt;/h3&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;官方介绍：MongoDB supports &lt;em&gt;compound indexes&lt;/em&gt;, where a single index structure holds references to multiple fields within a collection’s documents.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;复合索引结构示意图如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/c44d4923bc9d1c9822fe4c3ac1996833.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;该索引刚好和我们讨论的是一样的，&lt;code&gt;userid顺序&lt;/code&gt;，&lt;code&gt;score倒序&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;我们需要直面第二个问题：&lt;strong&gt;&lt;span&gt;复合索引在使用时需不需要在乎方向？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设两个查询条件：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# 查询 一
db.getCollection(&quot;records&quot;).find({ 
  &quot;userid&quot; : &quot;ca2&quot;
}).sort({&quot;score&quot; : -1.0});


# 查询 二
db.getCollection(&quot;records&quot;).find({ 
  &quot;userid&quot; : &quot;ca2&quot;
}).sort({&quot;score&quot; : 1.0});
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述的查询没有任何问题，因为受到&lt;code&gt;score&lt;/code&gt;字段排序的影响，只是数据从左侧还是从右侧遍历的问题，那么下面的一个查询呢？&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# 错误示范
db.getCollection(&quot;records&quot;).find({ 
  &quot;userid&quot; : &quot;ca2&quot;,
  &quot;score&quot; : { 
    &quot;$lt&quot; : NumberLong(2038092587)
  }
}).sort({&quot;score&quot; : -1.0});
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;错误原因如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;由于score字段按照倒序排序，因此为了使用该索引，所以需要从左侧开始遍历&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;从倒序顺序中找小于某个值的数据，势必会扫描很多无用数据，然后丢弃，当前场景下找大于某个值才是最佳方案&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;所以MongoDB为了更多场景考虑，在该种情况下，放弃了复合索引，选用其他的索引，如 score 的单列索引&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;针对性修改&quot;&gt;针对性修改&lt;/h2&gt;
&lt;p&gt;仔细阅读了根源之后，再回顾线上的查询语句，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;### 原始Query
db.getCollection(&quot;sku_main&quot;).find({ 
        &quot;orgCode&quot; : NumberLong(337451), 
        &quot;fixedStatus&quot; : { 
            &quot;$in&quot; : [
                1.0, 
                2.0
            ]
        }, 
        &quot;shopCategories&quot; : { 
            &quot;$exists&quot; : false
        }, 
        &quot;_id&quot; : { 
            &quot;$lt&quot; : NumberLong(2038092587)
        }
    }
).sort(
    { 
        &quot;_id&quot; : -1.0
    }
).skip(1000).limit(1000);

### 期望的索引
db.sku_main.ensureIndex({&quot;orgCode&quot;: 1, &quot;_id&quot;: -1},{background:true});
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;犯的错误一模一样，所以&lt;code&gt;MongoDB&lt;/code&gt;放弃了复合索引的使用，该为单列索引，因此进行针对性修改，把 &lt;code&gt;$lt&lt;/code&gt; 条件改为 &lt;code&gt;$gt&lt;/code&gt; 观察优化结果:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# 原始查询
[TEMP INDEX] =&amp;gt; lt: {&quot;limit&quot;:1000,&quot;queryObject&quot;:{&quot;_id&quot;:{&quot;$lt&quot;:2039180008},&quot;categoryId&quot;:23372,&quot;orgCode&quot;:351414,&quot;fixedStatus&quot;:{&quot;$in&quot;:[1,2]}},&quot;restrictedTypes&quot;:[],&quot;skip&quot;:0,&quot;sortObject&quot;:{&quot;_id&quot;:-1}}

# 原始耗时
[TEMP LT] =&amp;gt; 超时 （超时时间10s）

# 优化后查询
[TEMP INDEX] =&amp;gt; gt: {&quot;limit&quot;:1000,&quot;queryObject&quot;:{&quot;_id&quot;:{&quot;$gt&quot;:2039180008},&quot;categoryId&quot;:23372,&quot;orgCode&quot;:351414,&quot;fixedStatus&quot;:{&quot;$in&quot;:[1,2]}},&quot;restrictedTypes&quot;:[],&quot;skip&quot;:0,&quot;sortObject&quot;:{&quot;_id&quot;:-1}}

# 优化后耗时
[TEMP GT] =&amp;gt; 耗时: 383ms , List Size: 999
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;分析了小2000字，其实改动就是两个字符而已，当然真正的改动需要考虑业务的需要，但是问题既然已经定位，修改什么的就不难了，回顾上述内容总结如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;学习数据库知识的时候可以用类比的方式，但是需要额外注意其不同的地方（MySQL、MongoDB索引、索引的方向）&lt;/li&gt;
&lt;li&gt;MongoDB数据库单列索引可以不在乎方向，如对无索引字段排序需要控制数据量级（32M）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MongoDB数据库复合索引在使用中一定要注意其方向&lt;/code&gt;，要完全理解其逻辑，避免索引失效&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;最后&quot;&gt;最后&lt;/h2&gt;
&lt;p&gt;如果你觉得这篇内容对你挺有帮助的话：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;当然要点赞支持一下啦~&lt;/li&gt;
&lt;li&gt;搜索并关注公众号「&lt;strong&gt;是Kerwin啊&lt;/strong&gt;」，一起唠唠嗑~&lt;/li&gt;
&lt;li&gt;再来看看最近几篇的「&lt;strong&gt;查漏补缺&lt;/strong&gt;」系列吧，该系列会持续输出~
&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Wed, 09 Dec 2020 00:35:00 +0000</pubDate>
<dc:creator>Super-Kerwin</dc:creator>
<og:description>前情提要 11月末我司商品服务的MongoDB主库曾出现过严重抖动、频繁锁库等情况。 由于诸多业务存在插入MongoDB、然后立即查询等逻辑，因此项目并未开启读写分离。 最终定位问题是由于：服务器自身</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kkzhilu/p/14106687.html</dc:identifier>
</item>
<item>
<title>小齐读者拿到快手、百度、网易等 offer 的独门秘籍！ - 码农田小齐</title>
<link>http://www.cnblogs.com/nycsde/p/14106653.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nycsde/p/14106653.html</guid>
<description>&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小齐说：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这篇文章来自读者冰红茶，他刚结束了秋招，拿了很多家 offer。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和他聊完之后，我觉得他的备考思路也完全适用于美国的面试，只是分值要调整一下，但是具体每一块的内容，地球村通用。所以分享给大家一起学习一下～&lt;/p&gt;
&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;长达一年的实习、秋招之路终于落下了尾声，我最终收获了快手、百度、网易等互联网大厂的开发岗offer。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大学我学的专业是通信工程，也算是半个非科班出身，一路走就像是打怪升级的过程，不断地纠错尝试，一点经验分享给准备参加秋招的你。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大学时候每次期末考试我们都会等老师划重点，目的就是想确认考试的范围和形式以及各部分出题的分值，做到心里有数、合理分配时间。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我认为其实秋招面试的本质和平时期末考试是一回事。秋招考什么（考试范围）、秋招有哪些题型（考试形式）、以及各部分出题分值（考试各部分比重）？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;我自己常常把秋招面试考察范围划分为三个部分，算法题、基础知识题、过硬的项目或实习经历。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;一、算法（40分）&lt;/span&gt;&lt;/h2&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;&lt;strong&gt;分值说明：&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以我熟悉的开发岗位来说，对于大厂面试，我觉得算法题占了40分。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;这个分数很微妙，你会发现再需要20分就可以及格了，能勉强通过这次考试。但是如果40分完全丢掉那么靠其他方面力挽狂澜就会非常吃力。&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;特别是对于字节跳动这种业界内对算法题出了名重视的公司，撕出算法题是对话的基础。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我个人也认为考察算法题，是一个相对比较公平的考察形式。&lt;strong&gt;没有撕出算法题不代表你没有能力，但是能撕出算法题起码能证明你要么是天赋型选手，要么是努力型选手&lt;/strong&gt;(刷了够多的题，做了准备)，面试官筛选人的目的已经达到了。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;&lt;strong&gt;考察形式：&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果是线下面试，会直接给你一张白纸，写伪代码或者是全部。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今年因为疫情影响很多面试搬到了线上，我觉得以后线上面试会变得越来越常见。国内很多大厂用的都是牛客网作为平台，整个屏幕分为两块，一块是代码考察区，一块是和面试官视频交流区。面试官给出题目后，你写代码的过程会实时在面试官屏幕前同步，这个就要求你想清楚了再动手。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般来说整个考察过程是这样的，从面试官给出题目起。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，看了题目之后你先不要着急动手，进行短暂思考后。&lt;strong&gt;务必要和面试官进行交流，得到面试官的同意后再动手写代码。&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常见的交流内容就是你解题思路的时间复杂度、空间复杂度，得到面试官首肯之后就可以进行代码书写。最后一步，代码写完后可能会让你跑测试用例看看是否通过，或者跟面试官解释你是如何组织代码的。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;算法题的考察，除了考察你的写题能力外，更多的也是展示你的沟通表达能力，一个题目往往只是提供了一个大概。你应当去提问，某些极端边界条件下题目的输出会是什么？或者根据面试官的提示，去改进自己解题思路的时间、空间复杂度。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这部分我参考了齐姐之前的两篇文章，对我帮助非常大：&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;点击这里👉：&lt;a href=&quot;https://t.1yb.co/3p0S&quot;&gt;从 LRU Cache 带你看面试的本质&lt;/a&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;点击这里👉：&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzIzNDQ3MzgxMw==&amp;amp;mid=100000171&amp;amp;idx=1&amp;amp;sn=4e38e67791f3f67e15aea2e666f6d308&amp;amp;chksm=68f491915f831887f943356c45dac6c8ebacd1bef31432d0aec509ec3a3b835fe0c1f5c5cc4a#rd&quot;&gt;有关 HashMap 面试会问的一切&lt;/a&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;点击这里👉：&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzIzNDQ3MzgxMw==&amp;amp;mid=100000222&amp;amp;idx=1&amp;amp;sn=2882975d5ed764368ba09d352a1c3c36&amp;amp;chksm=68f491e45f8318f2140d980c6b73b1318e3ef8be31194f4cf3bce054bfe93dc433dcb19be2a9#rd&quot;&gt;这才是面试官想听的：详解「递归」正确的打开方式&lt;/a&gt;&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;&lt;strong&gt;如何准备：&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我个人感觉，对于秋招来说，算法题一般在力扣刷200道左右的简单、中等题目就足够了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;刷题的顺序我觉得可以先从《剑指offer》入手，上面大概有六十道左右的经典算法题，而且教材的作者也从面试官角度指出了我们可能会犯的错误和一些沟通的思路，一道算法题就是一个案例。如果从来没有接触过算法题的同学，这里可能会花两个月左右的时间。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你能把这本书刷完，接下来我建议是去刷高频考点题目。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如何能获知什么是高频考点题目呢？&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;一类是力扣网站本身就给你总结的很好，比如腾讯专题、字节专题，这些你面试遇到的可能性非常的大，很可能是原题或者变种。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;再者就是牛客网上的各个公司算法题面经，总结帖非常的多，可以帮助我们快速锁定重点题目。&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外要多注意复盘和总结。一道题往往有多种解题思路，一种思路往往可以解多道题目。很多题目的解题思路是大同小异的，只要坚持练习，最后绝大多数题目你都能做到快速反应。练习和复盘是一体两面的，相辅相成的，你既要知晓各种各样的解题思路，也要增强动手能力。这是我力扣复盘时候对题目的一些分类收藏。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwly1gkzu9onot3j30b20c80tf.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一开始有些同学觉得会很难，各种题目想不出来，我建议是直接看答案。只有你了解了足够多的解题思路之后才能有所输出，就像我们做乘除之前，先要学点加减法一样。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;二、基础知识题（30分）&lt;/span&gt;&lt;/h2&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;&lt;strong&gt;分值说明：&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体基础知识要求，每个岗位的侧重点会有所偏差，以开发为例，常见的考察内容有：Linux、Mysql、Redis、计算机网络、操作系统、语言本身特性等。由于这部分问的问题因面试官而异，所以自己还是要多准备，尽可能的去覆盖。这部分往往回旋的余地比较大，只要你能把面试官的问题答个七八成，再加上算法题撕出来基本上就能通过本轮面试。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;&lt;strong&gt;考察形式：&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你学过计算机网络，但是并不是所有问题都会问到，自己私下钻研怎么深入都不过分。但是对于秋招来说，你需要的是抓住&lt;strong&gt;核心考点&lt;/strong&gt;。所有的考点前人都已经用血泪教训给你总结好了，牛客网上的面经专栏有大把的内容。你只需要关注其中高频的，有扩展性的考点就行。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;面试时候，面试官往往抛出的问题有两种。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一种相对比较死板，比如讲一讲快速排序的原理，只要你对各个细节掌握的够清楚，能跟面试官讲明白，这题就算过了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另一种，是一些扩展类题目，比如很经典的从输入一个URL到出现页面这个过程发生了什么？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个问题根本没有所谓的准确答案，只有相对符合面试官胃口的答案。比如我一般就是，先从宏观上讲整个过程发生了什么，细节一笔带过。然后再跟面试官交流，我觉得哪块比较重要，可以展开聊一聊，或者您觉得哪块比较重要，我可以跟您展开说一说。面试是交流的过程，你要注意面试官的反应，看看是否要继续还是点到为止。不要自己像背作文一样，只顾背诵。一言以蔽之就是你要足够清晰的思路向面试官证明你确实懂这个东西，但讲多少，讲到什么程度要跟面试官交流。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;&lt;strong&gt;如何准备：&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对不同的基础问题，可以上网搜不同类型的回答，然后自己总结一套答题的模板。这个不是让你跟面试官照本宣科，而是作为你面试答题的基本依据。我们面试时候其实都或多或少有点紧张是正常的，你心里有个大纲，阐述起来时候清晰很多。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有几个常见的面试技巧，一个是如果题目你一点都不懂，千万别和面试官含含糊糊。这会让面试官以为你懂一点，但是讲不清楚或者不懂装懂，这很减分。你可以大方的说，不好意思，这一块我并不太了解。面试官一般来说就会换个话题，他没有必要跟你谈论一些你不懂的问题。面试官目的就是考察你知识的广度和深度。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外就是，很多同学常见误区是以为，简历上写的东西越多越好，这其实是个误区。面试官面试你之前基本上就是花几分钟看你的简历，提问的基本上就是简历上的内容，如果你写了很多精通某某，一问三不知就很减分了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;要学会引导面试官去问你很有把握、很熟悉的内容。&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;面试时间是有限的，面试官不可能所有的知识点都问一遍。所以有限的时间里面，谈论你会的，基本上就能给面试官留下很好的印象。比如我个人就对Mysql这块了解的很多。所以每次自我介绍的时候，我都会故意说，我个人对Mysql、计算机网络方面了解的相对比较多一些，主动给面试官一些引导。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;或者在聊别的话题时候，适当时候你也可以跟面试官说哪块我用的比较多，自然而然的让面试官跟着你的思路走。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;三、过硬的项目或者实习经历&lt;/span&gt;&lt;/h2&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;&lt;strong&gt;分值说明：&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我是强烈建议大家秋招之前去找一份与岗位相关的实习，如果能拿到大厂实习，秋招时候就是如虎添翼。虽然对于校招生来说，在面试官眼里都是白纸一张，但是如果你具备一些实践经验，绝对是加分项，团队培养你和融合成本就低很多。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;&lt;strong&gt;考察形式：&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基本上很多面试官都会主动的问你的项目或者实习经历，无非是问这些问题：实习时候你做了什么？用了什么技术？解决了什么样的问题？你觉得你解决的最难的问题是什么？面试官问这些问题的目的就是发掘你的知识深度怎么样，比如最难的问题，你遇到的到底是什么样的问题？可以看出你知识接触的深度。你是怎么解决的？考察你解决问题的思路手段。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;&lt;strong&gt;如何准备：&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在面对实习经历和项目的考察时候。我建议是自己要想明白自己项目中的亮点是什么？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;自己先做一个提炼，比如说我觉得我项目中两点一是引入了缓存降低响应时间，二是做了高并发的处理…最好这些亮点是和你的基础知识紧密结合的，而且要想清楚你为什么要这么做。比如你说引入了缓存降低响应耗时，那面试官就可以问Redis的相关基础知识，或者问你为什么要引入换成在这个项目里，用别的手段可以吗？引入缓存会有什么危害呢？如何解决带来的负面效应呢？这些东西都是我们日常实践时候也应该思考的东西。&lt;strong&gt;就是工具你不仅知道怎么用，还要知道为什么这么用？知其然，也只所以然。&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有些同学会说，确实没有过硬的项目经历或者实习经历怎么办。我建议是去Github上找点跟岗位相关项目做一做，改一改，看看能不能提炼出一点什么。其次，最后还是没有的话，可以跟面试官如实的说，其实一般来说面试官也不是要求非得有实习项目经历。但是你的基础知识就要准备扎实，因为面试官能跟你聊的就只有这些了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上内容只是从面试知识考察层面做了一些介绍。除此之外我们还需要做的是，有良好的心态，准备好从刚开始面试时候的忐忑不安到后来的游刃有余，给自己犯错成长的机会。&lt;/p&gt;
&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实准备面试无论校招还是社招思路都大同小异，分值略微不同，多在群里和大家交流、利用各种资源去学习，拿几个 offer 还是没问题的～&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，以上就是本文的所有内容了，如果你也有想和大家分享的经历和经验，欢迎到后台来找我，有稿费的那种～&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我是小齐，纽约程序媛，我们下期见！&lt;/p&gt;
</description>
<pubDate>Wed, 09 Dec 2020 00:18:00 +0000</pubDate>
<dc:creator>码农田小齐</dc:creator>
<og:description>小齐说： 这篇文章来自读者冰红茶，他刚结束了秋招，拿了很多家 offer。 和他聊完之后，我觉得他的备考思路也完全适用于美国的面试，只是分值要调整一下，但是具体每一块的内容，地球村通用。所以分享给大家</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/nycsde/p/14106653.html</dc:identifier>
</item>
<item>
<title>Django官方为什么没有标准项目结构 - dongfanger</title>
<link>http://www.cnblogs.com/df888/p/14105350.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/df888/p/14105350.html</guid>
<description>&lt;p&gt;Django官方并没有提供标准的项目结构，于是网上众说纷纭，百花齐放，一千个读者有一千个哈姆雷特。那我们该怎么设计项目结构呢？在回答这个问题之前，先了解一下Django原生的目录和文件都是干嘛的。&lt;/p&gt;

&lt;p&gt;在使用&lt;code&gt;django-admin startproject&lt;/code&gt;命令后就会创建这样的目录文件，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysite/
    manage.py
    mysite/
        __init__.py
        settings.py
        urls.py
        asgi.py
        wsgi.py
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;根目录mysite&quot;&gt;根目录mysite/&lt;/h2&gt;
&lt;p&gt;根目录的mysite/，仅仅是个目录而已，Django不会拿它做什么，它的名字可以随意修改。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;带短横线的根目录&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;分享一个踩坑经验，有时候我们想把项目名命名为带短横线的，如 hello-world，通过命令直接创建会报错：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;...\&amp;gt; django-admin startproject hello-world
CommandError: 'hello-world' is not a valid project name. Please make sure the name is a valid identifier.
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;startproject&lt;/code&gt;不支持直接创建带短横线的项目名。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法1 加参数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其实！它是支持的，只是我们漏了一个参数。&lt;code&gt;startproject&lt;/code&gt;的完整格式为&lt;code&gt;django-admin startproject name [directory]&lt;/code&gt;，可以在后面追加一个目录参数：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;...\&amp;gt; django-admin startproject helloworld hello-world
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;就可以了。根目录是&lt;code&gt;hello-world&lt;/code&gt;，里面的project是&lt;code&gt;helloworld&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法2 改名字&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;先用helloworld创建，然后再修改，可以①在资源管理器中直接修改文件夹，②也可以在 PyCharm 中修改：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202012/1629545-20201208201855296-2110877111.png&quot;/&gt;&lt;/center&gt;
&lt;p&gt;选择Rename directory：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202012/1629545-20201208201855642-1886246348.png&quot;/&gt;&lt;/center&gt;
&lt;p&gt;注意去掉勾选Search，不修改其他位置：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202012/1629545-20201208201855892-271272051.png&quot;/&gt;&lt;/center&gt;
&lt;p&gt;只修改这个根目录的名字即可。&lt;/p&gt;
&lt;h2 id=&quot;managepy&quot;&gt;manage.py&lt;/h2&gt;
&lt;p&gt;Django的命令行工具，使用频繁，格式为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;python manage.py &amp;lt;command&amp;gt; [options]
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;内部mysitepy&quot;&gt;内部mysite.py/&lt;/h2&gt;
&lt;p&gt;Django项目实际使用到的Python包，存放项目配置、URL路由等。&lt;/p&gt;
&lt;h2 id=&quot;mysite__init__py&quot;&gt;mysite/__init__.py&lt;/h2&gt;
&lt;p&gt;表明这个目录是Python包。&lt;/p&gt;
&lt;h2 id=&quot;mysitesettingspy&quot;&gt;mysite/settings.py&lt;/h2&gt;
&lt;p&gt;Django项目配置。&lt;/p&gt;
&lt;h2 id=&quot;mysiteurlspy&quot;&gt;mysite/urls.py&lt;/h2&gt;
&lt;p&gt;URL路由。&lt;/p&gt;
&lt;h2 id=&quot;mysiteasgipy&quot;&gt;mysite/asgi.py&lt;/h2&gt;
&lt;p&gt;兼容ASGI Web服务器的入口。&lt;/p&gt;
&lt;h2 id=&quot;mysitewsgipy&quot;&gt;mysite/wsgi.py&lt;/h2&gt;
&lt;p&gt;兼容WSGI Web服务器的入口。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;ASGI和WSGI，都是一种Python的Web服务网关接口协议，是在CGI通用网关接口，Common Gateway Interface）的标准上构建的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;app是Django项目的应用，一个project可以包含多个app。在使用&lt;code&gt;django-admin startapp&lt;/code&gt;命令后就会创建这样的目录文件，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;polls/
    __init__.py
    admin.py
    apps.py
    migrations/
        __init__.py
    models.py
    tests.py
    views.py
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;polls&quot;&gt;polls/&lt;/h2&gt;
&lt;p&gt;app的Python包，可以放在任意路径。修改存放路径，相关配置中的路径也需要修改。&lt;/p&gt;
&lt;h2 id=&quot;adminpy&quot;&gt;admin.py&lt;/h2&gt;
&lt;p&gt;存放Django自带后台管理的models。&lt;/p&gt;
&lt;h2 id=&quot;appspy&quot;&gt;apps.py&lt;/h2&gt;
&lt;p&gt;app配置信息，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from django.apps import AppConfig


class PollsConfig(AppConfig):
    name = 'polls'

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;存放路径不同，name的值也不同。&lt;/p&gt;
&lt;h2 id=&quot;migrations&quot;&gt;migrations/&lt;/h2&gt;
&lt;p&gt;Django数据迁移生成的迁移记录文件。&lt;/p&gt;
&lt;h2 id=&quot;modelspy&quot;&gt;models.py&lt;/h2&gt;
&lt;p&gt;存放app的models。&lt;/p&gt;
&lt;h2 id=&quot;testspy&quot;&gt;tests.py&lt;/h2&gt;
&lt;p&gt;单元测试。&lt;/p&gt;
&lt;h2 id=&quot;viewspy&quot;&gt;views.py&lt;/h2&gt;
&lt;p&gt;视图函数（类）。&lt;/p&gt;
&lt;h2 id=&quot;urlspy&quot;&gt;urls.py&lt;/h2&gt;
&lt;p&gt;app的路由配置，需要手动添加，可通过&lt;code&gt;include()&lt;/code&gt;函数导入到&lt;code&gt;mysite/urls.py&lt;/code&gt;中，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from django.contrib import admin
from django.urls import include, path

urlpatterns = [
    path('admin/', admin.site.urls),
    path('polls/', include('polls.urls')),
]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;polls/urls.py：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from django.urls import path

from . import views

urlpatterns = [
    path('', views.index),
]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;访问&lt;code&gt;xxx/polls/&lt;/code&gt;就会路由到&lt;code&gt;views.index&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;虽说是百家争鸣，但也有公认的工程化实践。我找了GitHub上star最多的叫做Django Edge的project skeleton，它的设计如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Top-directory
├── docs
├── logs
├── README.md
├── requirements
│   ├── base.txt
│   ├── development.txt
│   └── production.txt
├── requirements.txt
└── src
    ├── Your project name
    │   ├── __init__.py
    │   ├── logger.py
    │   ├── settings
    │   │   ├── base.py
    │   │   ├── development.py
    │   │   ├── local.sample.env
    │   │   └── production.py
    │   ├── urls.py
    │   ├── views.py
    │   └── wsgi.py
    ├── accounts
    │   ├── admin.py
    │   ├── forms.py
    │   ├── migrations
    │   ├── models.py
    │   ├── templates
    │   ├── tests.py
    │   ├── urls.py
    │   └── views.py
    ├── manage.py
    ├── media
    ├── profiles
    │   ├── admin.py
    │   ├── apps.py
    │   ├── forms.py
    │   ├── migrations
    │   ├── models.py
    │   ├── signals.py
    │   ├── templates
    │   ├── tests.py
    │   ├── urls.py
    │   └── views.py
    ├── static
    │   ├── bootstrap
    │   │   ├── css
    │   │   ├── fonts
    │   │   └── js
    │   └── site
    │       ├── css
    │       ├── ico
    │       ├── img
    │       └── js
    └── templates
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;非常的像那么回事。我又搜了其他实践的文章，找到了这张图：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202012/1629545-20201208201856256-437104103.png&quot;/&gt;&lt;/center&gt;
&lt;p&gt;国内的文章也有提到类似这2种项目结构的设计，特点是①app放置在单独目录统一管理，②requirements和settings按环境做拆分，等等等。我说说我的观点，一开始没有必要就按照这种标准的工程化实践来写项目，我更倾向于先凭自己的能力写一版，再不断重构和优化的方式。业务不同，能力不同，经验不同，写出来的代码自然也不同。不过在碰到问题时，可以参考借鉴，很可能别人已经提供了解决方案。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;我看了一些Django开源项目代码，很少见到真像这么设计项目结构的，所以不必过分在意。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;本文介绍了Django startproject和startapp命令产生的目录文件的结构和作用。然后给出了工程化项目参考。项目结构没有标准，只有适用于当前的最佳实践，可能这就是官方没有给出标准项目结构的原因吧。&lt;/p&gt;
&lt;blockquote readability=&quot;0.72321428571429&quot;&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.djangoproject.com/en/3.1/intro/tutorial01/&quot;&gt;https://docs.djangoproject.com/en/3.1/intro/tutorial01/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://django-edge.readthedocs.io/en/latest/Architecture/&quot;&gt;https://django-edge.readthedocs.io/en/latest/Architecture/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://studygyaan.com/django/best-practice-to-structure-django-project-directories-and-files&quot;&gt;https://studygyaan.com/django/best-practice-to-structure-django-project-directories-and-files&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 08 Dec 2020 23:47:00 +0000</pubDate>
<dc:creator>dongfanger</dc:creator>
<og:description>Django官方并没有提供标准的项目结构，于是网上众说纷纭，百花齐放，一千个读者有一千个哈姆雷特。那我们该怎么设计项目结构呢？在回答这个问题之前，先了解一下Django原生的目录和文件都是干嘛的。 p</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/df888/p/14105350.html</dc:identifier>
</item>
<item>
<title>基于.NET的程序读取Excel文件的解决方案 - shanzm</title>
<link>http://www.cnblogs.com/shanzhiming/p/14103854.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shanzhiming/p/14103854.html</guid>
<description>&lt;p&gt;shanzm-2020年12月8日 23:48:11&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;0-前言&quot;&gt;0. 前言&lt;/h3&gt;
&lt;p&gt;以前基于 .NET 开发的程序，我一般都是使用NPOI操作Excel文件，&lt;/p&gt;
&lt;p&gt;因为我的程序读取的是另外一个成品WMS导出的Excel文件（至于为什么不直接从数据库获取该WMS导出到Excel的数据，此中原因，一言难尽！），在使用NPOI读取Excel的时候，提示错误：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Initialisation of record 0x203(NumberRecord) left 4 bytes remaining still to be read.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;StackOverFlow一个高赞答案就是升级NPOI版本，或使用Office Excel将Excel文件&lt;code&gt;另存为&lt;/code&gt;，保存为新的Excel文件再使用NPOI读取该Excel文件。&lt;/p&gt;
&lt;p&gt;虽已使用最新的NPOI，但是依旧出现该错误，让用户&lt;code&gt;另存为&lt;/code&gt;不合适，但是我又尚未找到一个简单有效快速的处理方法。&lt;/p&gt;
&lt;p&gt;考虑到服务器上已经安装的Office套件，所以使用Com组件的方法操作Excel文件，但是读取速度较慢。&lt;/p&gt;
&lt;p&gt;最终尝试使用ADO .NET 中的OleDbConnection类读取Excel文件，读取速度，且相对方便，简单记录如下。&lt;/p&gt;
&lt;br/&gt;&lt;hr/&gt;&lt;h3 id=&quot;1-使用npoi库读取excel文件&quot;&gt;1. 使用NPOI库读取Excel文件&lt;/h3&gt;
&lt;p&gt;在.NET程序中需要操作Excel文件，不论xls格式还是xlsx格式都是可以使用NPOI&lt;/p&gt;
&lt;p&gt;Nuget获取该扩展：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-txt&quot;&gt;PM&amp;gt; Install-Package NPOI -Version 2.5.2
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;简单的一个示例，读取用户上传的Excel文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;    /// &amp;lt;summary&amp;gt;
    /// 读取Excel导入DataTable
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;filepath&quot;&amp;gt;导入的文件路径（包括文件名）&amp;lt;/   param&amp;gt;
    /// &amp;lt;param name=&quot;sheetName&quot;&amp;gt;工作表名称&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&quot;isFirstRowColumn&quot;&amp;gt;第一行是否是DataTable的列    名&amp;lt;/param&amp;gt;
    /// &amp;lt;returns&amp;gt;DataTable&amp;lt;/returns&amp;gt;
    public static DataTable ExcelToDataTable(string filePath,string sheetName,bool isFirstRowColumn)
    {
        DataTable data = new DataTable();
        FileStream fs;
        int startRow = 0;
        using (fs = new FileStream(filePath, FileMode.Open,     FileAccess.Read))
        {
            try
            {
                IWorkbook workbook = filePath.Contains(&quot;.xlsx&quot;) ? (IWorkbook)new XSSFWorkbook(fs) :newHSSFWorkbook(fs);//xlsx使用XSSFWorkbook， xls使用HSSFWorkbokk
                ISheet sheet = workbook.GetSheet(sheetName) ?? workbook.GetSheetAt(0);//如果没有找到指sheetName 对应的sheet，则尝试获取第一个sheet
                if (sheet != null)
                {
                    IRow firstrow = sheet.GetRow(0);//第一行
                    int firstCellNum = firstrow.FirstCellNum;// 行第一个cell的编号,从0开始
                    int lastCellNum = firstrow.LastCellNum; //  行最后一个cell的编号 即总的列数,（不忽略中间某    列空格）
                    if (isFirstRowColumn)//如果第一行是表格列头
                    {
                        for (int i = firstCellNum; i &amp;lt; lastCellNum; i++)
                        {
                            ICell cell = firstrow.GetCell(i);
                            if (cell != null)
                            {
                                string cellValue = cell.StringCellValue;
                                if (cellValue != null)
                                {
                                    DataColumn column = new DataColumn(cellValue);
                                    data.Columns.Add(column);
                                }
                            }
                        }
                        startRow = sheet.FirstRowNum + 1;
                    }
                    else
                    {
                        startRow = sheet.FirstRowNum;
                    }
                    //读数据行
                    int rowCont = sheet.LastRowNum;
                    for (int i = startRow; i &amp;lt;=rowCont; i++)
                    {
                        IRow row = sheet.GetRow(i);
                        DataRow dataRow = data.NewRow();
                        //判断需要读取的最后一行
                        if (row != null &amp;amp;&amp;amp; (row.GetCell(row.FirstCellNum) != null &amp;amp;&amp;amp; row.GetCel (rowFirstCellNum).ToString() != &quot;合计&quot;)  )
                        {
                            for (int j = row.FirstCellNum; j &amp;lt; lastCellNum; j++)
                            {
                                dataRow[j] = row.GetCell(j).ToString();
                            }
                            data.Rows.Add(dataRow);
                        }
                        else
                        {
                            break;
                        }
                    }
                }
                return data;
            }
            catch (Exception ex)
            {
                Debug.WriteLine(&quot;Exception: &quot; + ex.Message);
                return null;
            }
            finally 
            { 
                fs.Close(); 
                fs.Dispose(); 
            }
        }
    }

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;读取到Excel表格中的数据到DataTable 中，可以使用&lt;code&gt;SqlBulkCopy&lt;/code&gt;批量插入的方式将DataTable数据存储到数据库表中，关于ADO .NET 针对SQL Server的批量插入的各种方法以及比较，可以参考文末给出的参考连接&lt;/p&gt;
&lt;p&gt;简单示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;        /// &amp;lt;summary&amp;gt; 
        /// 使用SqlBulkCopy将DataTable中的数据批量插入数据库中
        /// 注意：DataTable中的列需要与数据库表中的列完全一致。
        /// &amp;lt;/summary&amp;gt; 
        /// &amp;lt;param name=&quot;conStr&quot;&amp;gt;数据库连接串&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;dbTableName&quot;&amp;gt;数据库中对应的表名&amp;lt;/param&amp;gt; 
        /// &amp;lt;param name=&quot;dtData&quot;&amp;gt;数据集&amp;lt;/param&amp;gt; 
        public static void SqlBulkCopyInsert(string dbTableName, DataTable dataTable)
        {
                using (SqlBulkCopy sqlRevdBulkCopy = new SqlBulkCopy(connStr))//引用SqlBulkCopy 
                {
                    sqlRevdBulkCopy.DestinationTableName = dbTableName;//数据库中对应的表名 
                    sqlRevdBulkCopy.NotifyAfter = dataTable.Rows.Count;//有几行数据 
                    sqlRevdBulkCopy.WriteToServer(dataTable);//数据导入数据库 
                    sqlRevdBulkCopy.Close();//关闭连接 
                }
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;br/&gt;&lt;hr/&gt;&lt;h3 id=&quot;2-使用oledbconnection&quot;&gt;2. 使用OleDbConnection&lt;/h3&gt;
&lt;p&gt;使用ADO .NET 中的OleDbConnection类连接查询。简单示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;        /// &amp;lt;summary&amp;gt;
        /// 读取Excel返回DataTable
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;filePath&quot;&amp;gt;Excel文件路径&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;tableName&quot;&amp;gt;Excel文件中Sheet名称&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public static DataSet ExcelToDataSet(string filePath, string tableName)
        {
            //获取文件扩展名
            string strExtension = System.IO.Path.GetExtension(filePath);
            OleDbConnection myConn = null;
            switch (strExtension)
            {
                case &quot;.xls&quot;:
                    myConn = new OleDbConnection(&quot;Provider=Microsoft.Jet.OLEDB.4.0;Data Source=&quot; + filePath + &quot;;&quot; + &quot;Extended Properties=\&quot;Excel 8.0;HDR=yes;IMEX=1;\&quot;&quot;);
                    break;
                case &quot;.xlsx&quot;:
                    myConn = new OleDbConnection(&quot;Provider=Microsoft.ACE.OLEDB.12.0;Data Source=&quot; + filePath + &quot;;&quot; + &quot;Extended Properties=\&quot;Excel 12.0;HDR=yes;IMEX=1;\&quot;&quot;);
                    //此连接可以操作.xls与.xlsx文件 (支持Excel2003 和 Excel2007 的连接字符串) 
                    //&quot;HDR=yes;&quot;是说Excel文件的第一行是列名而不是数，&quot;HDR=No;&quot;正好与前面的相反。&quot;IMEX=1 &quot;如果列中的数据类型不一致，使用&quot;IMEX=1&quot;可必免数据类型冲突。 
                    break;
                default:
                    myConn = null;
                    break;
            }
            if (myConn == null)
            {
                return null;
            }
            string strCom = &quot; SELECT * FROM [&quot; + tableName + &quot;$]&quot;;
            myConn.Open();
            //获取Excel指定Sheet表中的信息
            OleDbDataAdapter myCommand = new OleDbDataAdapter(strCom, myConn);
            DataSet ds;
            ds = new DataSet();
            myCommand.Fill(ds, tableName);
            myConn.Close();
            return ds.Tables[0];
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用OleDbConnection在本地测试没有问题，在发布部署在服务器后出现了一个异常：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;未在本地计算机上注册“Microsoft.Jet.OLEDB.4.0”提供程序&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;解决方法：IIS--&amp;gt;应用程序池--&amp;gt;选中部署的项目右键--&amp;gt;高级设置--&amp;gt;启用32位应用程序--&amp;gt;True&lt;/p&gt;
&lt;br/&gt;&lt;hr/&gt;&lt;h3 id=&quot;3-相关参考&quot;&gt;3. 相关参考&lt;/h3&gt;
</description>
<pubDate>Tue, 08 Dec 2020 15:54:00 +0000</pubDate>
<dc:creator>shanzm</dc:creator>
<og:description>shanzm-2020年12月8日 23:48:11 0. 前言 以前基于 .NET 开发的程序，我一般都是使用NPOI操作Excel文件， 因为我的程序读取的是另外一个成品WMS导出的Excel文件</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/shanzhiming/p/14103854.html</dc:identifier>
</item>
<item>
<title>Linux内核源码分析之setup_arch (二) - 机器感知</title>
<link>http://www.cnblogs.com/jiau/p/14106361.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jiau/p/14106361.html</guid>
<description>&lt;h3 id=&quot;1-概述&quot;&gt;1. 概述&lt;/h3&gt;
&lt;p&gt;接着上一篇《Linux内核源码分析之setup_arch (一)》继续分析，本文首先分析arm_memblock_init函数，然后分析内核启动阶段的是如何进行内存管理的。&lt;/p&gt;
&lt;h3 id=&quot;2-arm_memblock_init&quot;&gt;2. arm_memblock_init&lt;/h3&gt;
&lt;p&gt;该函数的功能比较简单，主要就是把meminfo中记录的内存条信息添加到memblock.memory中，然后把内核镜像所在内存区域添加到memblock.reserved中，arm_mm_memblock_reserve把页表所在内存区域添加到memblock.reserved中；如果使用了设备树，则使用arm_dt_memblock_reserve来保留所占用的内存，最后则是调用CPU相关的mdesc-&amp;gt;reserve，其对应的调用为cpu_mem_reserve，该函数定义在cpu.c中。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;/* arch/arm/mm/init.c */
void __init arm_memblock_init(...) {
  for (i = 0; i &amp;lt; mi-&amp;gt;nr_banks; i++)
    memblock_add(mi-&amp;gt;bank[i].start, mi-&amp;gt;bank[i].size);

  memblock_reserve(__pa(_stext), _end - _stext);
  arm_mm_memblock_reserve();
  arm_dt_memblock_reserve();

  if (mdesc-&amp;gt;reserve)
    mdesc-&amp;gt;reserve();

  arm_memblock_steal_permitted = false;
  memblock_allow_resize();
  memblock_dump_all();
}
/* include/kernel/memblock.h */
struct memblock {
 phys_addr_t current_limit;
 struct memblock_type memory;
 struct memblock_type reserved;
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;3-memblock_alloc&quot;&gt;3. memblock_alloc&lt;/h3&gt;
&lt;p&gt;接下来就该执行paging_init函数了，在分析paging_init之前先来点内核启动阶段的内存管理相关的内容。从arm_memblock_init开始引入memblock数据结构，其作用是实现内核启动初期的内存管理功能，严格来说，其生命周期到paging_init::bootmem_init为止，memblock_alloc调用流程如下。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1822536/202012/1822536-20201208233835480-1200910554.png&quot;/&gt;&lt;/div&gt;
&lt;p&gt;实际查找空闲内存的函数为memblock_find_in_range_node，而该函数中真正实现空闲内存查找的是for_each_free_mem_range_reverse这个宏定义。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;/* mm/memblock.c */
phys_addr_t memblock_find_in_range_node(...)
{
 ...
 for_each_free_mem_range_reverse(i, nid, &amp;amp;this_start, &amp;amp;this_end, NULL) {
      ...
      if (cand &amp;gt;= this_start)
        return cand;
 }
 return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该宏定义如下，然而其中又嵌套了一个函数Orz...&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;/* include/linux/memblock.h */
#define for_each_free_mem_range_reverse(i, nid, p_start, p_end, p_nid) \
 for (i = (u64)ULLONG_MAX,                                             \
      __next_free_mem_range_rev(&amp;amp;i, nid, p_start, p_end, p_nid);       \
      i != (u64)ULLONG_MAX;                                            \
      __next_free_mem_range_rev(&amp;amp;i, nid, p_start, p_end, p_nid))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先需要说明的是，memblock.reserved标识的区域表示的是已被占用的内存区域，memblock.memory中记录的是内存条信息。现在回到__next_free_mem_range_rev函数，代码段(1)&lt;sub&gt;(2)的目的是找出内存条上两个reserved区域之间的内存区域，即空闲区域。找到之后再经过代码段(3)对空闲区域的起始地址和结束地址进行修正，因为代码段(1)&lt;/sub&gt;(2)只能保证空闲区与当前内存条存在交集，并不能保证该空闲区域完全处于当前内存条之中，主要原因在于无法保证这两个reserved区域都在当前内存条上。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;/* mm/memblock.c */
void __init_memblock __next_free_mem_range_rev(...)
{
 struct memblock_type *mem = &amp;amp;memblock.memory;
 struct memblock_type *rsv = &amp;amp;memblock.reserved;
 ...
 /* (1) */
 for ( ; mi &amp;gt;= 0; mi--) {
  struct memblock_region *m = &amp;amp;mem-&amp;gt;regions[mi];
  phys_addr_t m_start = m-&amp;gt;base;
  phys_addr_t m_end = m-&amp;gt;base + m-&amp;gt;size;
  ...
  /* (2) */
  for ( ; ri &amp;gt;= 0; ri--) {
   struct memblock_region *r = &amp;amp;rsv-&amp;gt;regions[ri];
   phys_addr_t r_start = ri ? r[-1].base + r[-1].size : 0;
   phys_addr_t r_end = ri &amp;lt; rsv-&amp;gt;cnt ? r-&amp;gt;base : ULLONG_MAX;
   ...
   /* (3) */
   if (m_end &amp;gt; r_start) {
    if (out_start)
     *out_start = max(m_start, r_start);
    if (out_end)
     *out_end = min(m_end, r_end);
    if (out_nid)
     *out_nid = memblock_get_region_node(m);

    ...
    return;
   }
  }
 }

 *idx = ULLONG_MAX;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至此，空闲区域的查找基本就结束了，回到memblock_find_in_range_node函数中，再检查一下该区域的起始地址和结束地址是否合法等等，最终就申请到了所请求大小的内存区域，最后只需要将这块内存区域标记为reserved状态就结束了内存分配的整个过程了。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;/* mm/memblock.c */
int memblock_reserve(phys_addr_t base, phys_addr_t size)
{
 struct memblock_type *_rgn = &amp;amp;memblock.reserved;
 return memblock_add_region(_rgn, base, size, MAX_NUMNODES);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;4-总结&quot;&gt;4. 总结&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;arm_memblock_init函数首先把记录在meminfo记录的内存条信息转移到memblock.memory中，然后把已经使用的内存区域记录到memblock.reserved中，主要包括内核镜像所占用区域、页表区域以及设备树；&lt;/li&gt;
&lt;li&gt;memblock_alloc通过memblock中的memory和reserved中记录的信息进行内存管理，每次申请到内存之后都在memblock.reserved中进行记录。&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Tue, 08 Dec 2020 15:40:00 +0000</pubDate>
<dc:creator>机器感知</dc:creator>
<og:description>1. 概述 接着上一篇《Linux内核源码分析之setup_arch (一)》继续分析，本文首先分析arm_memblock_init函数，然后分析内核启动阶段的是如何进行内存管理的。 2. arm_</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jiau/p/14106361.html</dc:identifier>
</item>
<item>
<title>c++11-17 模板核心知识（十五）—— 解析模板之依赖型类型名称与typename Dependent Names of Types - 张雅宸</title>
<link>http://www.cnblogs.com/zhangyachen/p/14106282.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangyachen/p/14106282.html</guid>
<description>&lt;p&gt;上篇文章&lt;a href=&quot;https://github.com/zhangyachen/zhangyachen.github.io/issues/164&quot;&gt;c++11-17 模板核心知识（十四）—— 解析模板之依赖型模板名称 Dependent Names of Templates(.template/-&amp;gt;template/::template)&lt;/a&gt; 介绍了依赖型模板名称，提到关于模板解析有六个大方面：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;非模板中的上下文相关性 Context Sensitivity in Nontemplates&lt;/li&gt;
&lt;li&gt;依赖型类型名称 Dependent Names of Types &amp;lt;-----&lt;/li&gt;
&lt;li&gt;依赖型模板名称 Dependent Names of Templates&lt;/li&gt;
&lt;li&gt;using-declaration中的依赖型名称 Dependent Names in Using Declarations&lt;/li&gt;
&lt;li&gt;ADL和显式模板实参 ADL and Explicit Template Arguments&lt;/li&gt;
&lt;li&gt;依赖性表达式 Dependent Expressions&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这篇文章介绍下依赖型类型名称（Dependent Names of Types）。&lt;/p&gt;
&lt;h2 id=&quot;模板名称的问题及解决&quot;&gt;模板名称的问题及解决&lt;/h2&gt;
&lt;p&gt;模板中的名称存在一个问题：它们有的时候不能被很好的分类，比如一个模板引用其他模板的名称，因为模板特化的存在，会让问题变得复杂一些。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;template &amp;lt;typename T&amp;gt; class Trap {
public:
  enum { x }; // #1 x is not a type here
};

template &amp;lt;typename T&amp;gt; class Victim {
public:
  int y;
  void poof() {
    Trap&amp;lt;T&amp;gt;::x *y; // #2 declaration or multiplication?
  }
};

template &amp;lt;&amp;gt; class Trap&amp;lt;void&amp;gt; { // evil specialization!
public:
  using x = int; // #3 x is a type here
};

void boom(Victim&amp;lt;void&amp;gt; &amp;amp;bomb) { bomb.poof(); }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果你直接编译，会报错：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;main.cc:30:14: error: unexpected type name 'x': expected expression
    Trap&amp;lt;T&amp;gt;::x *y; // #2 declaration or multiplication?
             ^
main.cc:39:38: note: in instantiation of member function 'Victim&amp;lt;void&amp;gt;::poof' requested here
void boom(Victim&amp;lt;void&amp;gt; &amp;amp;bomb) { bomb.poof(); }
                                     ^
1 error generated.
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个问题和解决方案在&lt;a href=&quot;https://github.com/zhangyachen/zhangyachen.github.io/issues/152#%E5%85%B3%E9%94%AE%E5%AD%97typename&quot;&gt;c++11-17 模板核心知识（二）—— 类模板&lt;/a&gt;涉及过，这篇文章再展开说一下相关规则。&lt;/p&gt;
&lt;p&gt;回到上面的例子，当编译器解析到#2处时，它需要决定&lt;code&gt;Trap&amp;lt;T&amp;gt;::x&lt;/code&gt;是一个类型还是一个值，这决定了&lt;code&gt;Trap&amp;lt;T&amp;gt;::x *y&lt;/code&gt;是声明一个指针还是做乘法。&lt;/p&gt;
&lt;p&gt;问题是，在Trap中，&lt;code&gt;Trap&amp;lt;T&amp;gt;::x&lt;/code&gt;是一个值，但是在全特化版本&lt;code&gt;Trap&amp;lt;void&amp;gt;&lt;/code&gt;中，&lt;code&gt;Trap&amp;lt;T&amp;gt;::x&lt;/code&gt;是一个类型。所以，这种情况实际是依赖模板参数T的，也就是依赖型类型名称（Dependent Names of Types）。&lt;/p&gt;
&lt;p&gt;C++规定，只有当加上typename关键字后，&lt;strong&gt;依赖型类型名称&lt;/strong&gt;才会被当做类型，否则会被当做一个值。这里typename的意义和声明一个模板时使用的typename是两个意思，所以不能用class来替换typename.&lt;/p&gt;
&lt;h2 id=&quot;typename规则&quot;&gt;typename规则&lt;/h2&gt;
&lt;p&gt;当一个名称具备以下性质时，需要在名称前面加typename：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;是qualified name。&lt;/li&gt;
&lt;li&gt;不是&lt;a href=&quot;https://en.cppreference.com/w/cpp/language/elaborated_type_specifier&quot;&gt;Elaborated type specifier&lt;/a&gt;的一部分（例如，以class、struct、union、enum为开头的类型）&lt;/li&gt;
&lt;li&gt;名称不是&lt;strong&gt;用于指定基类继承的列表&lt;/strong&gt;中，也不是位于&lt;strong&gt;引入构造函数的成员初始化列表&lt;/strong&gt;中。&lt;/li&gt;
&lt;li&gt;依赖于模板参数。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;template &amp;lt;typename(1) T&amp;gt; 
struct S : typename(2) X&amp;lt;T&amp;gt;::Base {
  S() : typename(3) X&amp;lt;T&amp;gt;::Base(typename(4) X&amp;lt;T&amp;gt;::Base(0)) {}
  
  typename(5) X&amp;lt;T&amp;gt; f() {
    typename(6) X&amp;lt;T&amp;gt;::C *p; // declaration of pointer p
    X&amp;lt;T&amp;gt;::D *q;           // multiplication!
  }
  typename(7) X&amp;lt;int&amp;gt;::C *s;

  using Type = T;
  using OtherType = typename(8) S&amp;lt;T&amp;gt;::Type;
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面逐一说下上面各个typename的使用场景(&lt;strong&gt;有的使用方式是错误的&lt;/strong&gt;)：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一个typename代表一个模板参数，不在此文章讨论范围内。&lt;/li&gt;
&lt;li&gt;第二和第三个typename是错误的使用方式，不需要添加，违反了上面的第3条规则。第二个出现在了指定基类继承的列表中，第三个出现在了构造函数的成员初始化列表。如果加上typename编译，会报如下错误：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;main.cc:30:12: error: 'typename' is redundant; base classes are implicitly types
struct S : typename X&amp;lt;T&amp;gt;::Base {
           ^~~~~~~~~
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;第四个typename是必须的，它满足上面第3条规则，且其他规则也满足。&lt;/li&gt;
&lt;li&gt;第五个typename是错误的，因为X不是一个qualified name，如果加上typename编译，会报：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;main.cc:33:12: error: expected a qualified name after 'typename'
  typename X&amp;lt;T&amp;gt; f() {
           ^
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;第六个typename是必须的，上面讲过，代表一个类型。&lt;/li&gt;
&lt;li&gt;第七个typename是可有可无的，因为&lt;code&gt;X&amp;lt;int&amp;gt;::C&lt;/code&gt;不依赖模板参数，即不是Dependent Name.&lt;/li&gt;
&lt;li&gt;第八个typename也是可有可无的，因为它指向的是&lt;code&gt;current instantiation&lt;/code&gt;，这个概念下篇文章会讲到。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;c20-typename&quot;&gt;C++20 typename&lt;/h2&gt;
&lt;p&gt;是了，这一大堆乱七八糟的规则，谁也不想去记。C++20对typename的规则做了一些改善，有一些场景不再需要typename。详情大家可以参考 ： &lt;a href=&quot;https://en.cppreference.com/w/cpp/language/dependent_name#The_typename_disambiguator_for_dependent_names&quot;&gt;The typename disambiguator for dependent names&lt;br/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/14103319/101493260-cfdf4a80-39a0-11eb-9c5c-954f06b3a2b2.png&quot; alt=&quot;image&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（完）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;朋友们可以关注下我的公众号，获得最及时的更新：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/14103319/92430320-11583200-f1c7-11ea-940d-1e297d2f394b.png&quot; alt=&quot;image&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 08 Dec 2020 15:22:00 +0000</pubDate>
<dc:creator>张雅宸</dc:creator>
<og:description>模板名称的问题及解决 typename规则 C++20 typename 上篇文章c++11-17 模板核心知识（十四）—— 解析模板之依赖型模板名称 Dependent Names of Templ</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhangyachen/p/14106282.html</dc:identifier>
</item>
</channel>
</rss>