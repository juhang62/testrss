<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>基于SDF渲染字体 - 落单的毛毛虫</title>
<link>http://www.cnblogs.com/mmc1206x/p/11965064.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mmc1206x/p/11965064.html</guid>
<description>&lt;p&gt;18号字体&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/596122/201912/596122-20191201001741981-1285190885.png&quot; alt=&quot;18号字体.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;18号字体放大15倍&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/596122/201912/596122-20191201001756233-1730872467.png&quot; alt=&quot;位图字体_放大15倍.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;基于sdf渲染字体放大15倍&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/596122/201912/596122-20191201001809104-173107399.png&quot; alt=&quot;矢量字体_放大15倍.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;相比常规的渲染方式，基于ＳＤＦ渲染文字可无限放大并保持清晰，几乎没有开销就可实现描边，发光，抗锯齿等效果．且它只需要很小的纹理缓存ＳＤＦ信息即可．&lt;/p&gt;
&lt;p&gt;所谓ＳＤＦ（Signed-distance-field），就是将每个像素存储的颜色值换成距离文字轮廓最短距离，当像素在文字内，则用正数距离，在文字外则用负数距离，文字轮廓距离则是零，因此只要判断像素如果是正数，就输出颜色，否则丢弃颜色即可．&lt;/p&gt;
&lt;p&gt;该技术由&lt;a href=&quot;https://baike.baidu.com/item/Valve/5053718?fr=aladdin&quot;&gt;Valve&lt;/a&gt;开发&lt;a href=&quot;https://baike.baidu.com/item/%E5%8D%8A%E6%9D%A1%E5%91%BD2/195751?fr=aladdin&quot;&gt;半条命2&lt;/a&gt;时提出，当时主要用于渲染图片，之后被广泛用于其他技术中，用于渲染字体仅是其中一项．&lt;/p&gt;
&lt;p&gt;相对比常规的渲染方式，除了片段着色器的差别外，主要差别在于生成的纹理缓存．&lt;/p&gt;
&lt;p&gt;常规渲染方式的纹理缓存大致如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一个纹理只存一个字号&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/596122/201912/596122-20191201001830394-238825595.png&quot; alt=&quot;fnt36.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一个纹理存储多个字号&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/596122/201912/596122-20191201001844679-1382654549.png&quot; alt=&quot;fnt_atlas.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;它们都有一个共同点：每个像素存储的信息都是颜色．而ｓｄｆ每个像素存储的是距离，因此它能提供矢量信息．(怎么存储多个字号, 可查看&lt;a href=&quot;https://www.cnblogs.com/mmc1206x/p/11741656.html&quot;&gt;合并图集&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ＳＤＦ纹理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/596122/201912/596122-20191201001856862-323980699.png&quot; alt=&quot;sdf.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ＳＤＦ渲染字体在网上有很多资料，但我翻遍了百度，只找到一个可运行的文字ＳＤＦ生成工具，在我反复调试后，发现这个工具生成的ＳＤＦ是错的，迫不得已我只好花２０分钟重写了一个，算法也简单，无非就是暴搜+阀值控制，生成4096*4096的SDF，i7 7700k大概需要1分钟.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;描边&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/596122/201912/596122-20191201001910145-565900762.png&quot; alt=&quot;描边.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;内发光&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/596122/201912/596122-20191201001921795-33754766.png&quot; alt=&quot;内发光.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;外发光&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/596122/201912/596122-20191201001932880-1680981368.png&quot; alt=&quot;外发光.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;效果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/596122/201912/596122-20191201001948751-14514195.gif&quot; alt=&quot;动态图.gif&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 30 Nov 2019 23:11:00 +0000</pubDate>
<dc:creator>落单的毛毛虫</dc:creator>
<og:description>18号字体 18号字体放大15倍 基于sdf渲染字体放大15倍 相比常规的渲染方式，基于ＳＤＦ渲染文字可无限放大并保持清晰，几乎没有开销就可实现描边，发光，抗锯齿等效果．且它只需要很小的纹理缓存ＳＤＦ</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mmc1206x/p/11965064.html</dc:identifier>
</item>
<item>
<title>Redis开发与运维：SDS与44字节深入理解 - K战神</title>
<link>http://www.cnblogs.com/sunchong/p/11924295.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sunchong/p/11924295.html</guid>
<description>&lt;p&gt;对于上一篇文章，我又自己总结归纳并补充了一下，有了第二篇。&lt;/p&gt;
&lt;h3 id=&quot;概览&quot;&gt;概览&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/406456/201911/406456-20191130162154264-1873306821.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;左移&quot;&gt;&amp;lt;&amp;lt;左移&lt;/h3&gt;
&lt;p&gt;开始之前，我们先准备点东西：位运算&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;i&amp;lt;&amp;lt;n 总结为  i*2^n&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以&lt;/p&gt;
&lt;p&gt;１&amp;lt;&amp;lt;5 = 2^5&lt;/p&gt;
&lt;p&gt;１&amp;lt;&amp;lt;8 = 2^8&lt;/p&gt;
&lt;p&gt;１&amp;lt;&amp;lt;16 = 2^16&lt;/p&gt;
&lt;p&gt;１&amp;lt;&amp;lt;32 = 2^32&lt;/p&gt;
&lt;p&gt;１&amp;lt;&amp;lt;64 = 2^64&lt;/p&gt;
&lt;h3 id=&quot;sds种数据类型&quot;&gt;SDS　５种数据类型&lt;/h3&gt;
&lt;p&gt;Ｒｅｄｉｓ 3.2 以后ＳＤＳ数据类型有５个&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#define SDS_TYPE_5  0
#define SDS_TYPE_8  1
#define SDS_TYPE_16 2
#define SDS_TYPE_32 3
#define SDS_TYPE_64 4&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结合上面的位运算，我们也能理解这５个数据类型的命名规则。&lt;/p&gt;
&lt;h3 id=&quot;外部类型string-找sds结构&quot;&gt;外部类型String 找　SDS结构&lt;/h3&gt;
&lt;p&gt;我们现在有定义了５种ＳＤＳ数据类型，那么如何根据字符串长度找这些类型呢？&lt;/p&gt;
&lt;p&gt;或者说输入的字符串长度和类型有什么关系？下面我们来看一看他们之间的关系。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/406456/201911/406456-20191130235641291-839881224.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再来看看源码：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;static inline char sdsReqType(size_t string_size) {
    if (string_size &amp;lt; 1&amp;lt;&amp;lt;5)
        return SDS_TYPE_5;
    if (string_size &amp;lt; 1&amp;lt;&amp;lt;8)
        return SDS_TYPE_8;
    if (string_size &amp;lt; 1&amp;lt;&amp;lt;16)
        return SDS_TYPE_16;
#if (LONG_MAX == LLONG_MAX)
    if (string_size &amp;lt; 1ll&amp;lt;&amp;lt;32)
        return SDS_TYPE_32;
    return SDS_TYPE_64;
#else
    return SDS_TYPE_32;
#endif
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据位运算左移公式，我可以得知　1&amp;lt;&amp;lt;8　= 2^8 = 256&lt;/p&gt;
&lt;p&gt;那么这里的　２５６是指什么？这里的２５６就是字节&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/406456/201911/406456-20191130131524262-1024905405.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/406456/201911/406456-20191130131606560-1293087503.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也就是说：&lt;br/&gt;SDS_TYPE_5　-- 32 Byte&lt;br/&gt;SDS_TYPE_8　-- 256 Byte&lt;br/&gt;SDS_TYPE_16 -- 64KＢ&lt;br/&gt;SDS_TYPE_32 -- ...&lt;br/&gt;SDS_TYPE_64 -- ...&lt;/p&gt;
&lt;p&gt;现在数据类型找到了，我们再来看看比较典型的几种操作。&lt;/p&gt;
&lt;h3 id=&quot;追加字符串&quot;&gt;　追加字符串&lt;/h3&gt;
&lt;p&gt;从使用角度讲，追加一般用的频率很少。所以有多大分配多大。&lt;/p&gt;
&lt;p&gt;所以这里追加的话，有两种大情况：还有剩余　或　不够用&lt;/p&gt;
&lt;p&gt;主要讲一下不够用就要重新申请内存，那么我们如何去申请内存呢？&lt;/p&gt;
&lt;p&gt;这里提供了两种分配策略：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;1M ，新空间 = ２倍扩容；

&amp;gt;1M , 新空间 = 累加1M&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;空间有了，那么我们需要根据最新的空间长度占用，再找到对应的新的ＳＤＳ数据类型。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/406456/201911/406456-20191130152635801-1654993902.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看一下源码，增加一下印象：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;/* 追加字符串*/
sds sdscatlen(sds s, const void *t, size_t len) {
    // 当前字符串长度
    size_t curlen = sdslen(s); 
    // 按需调整空间（原来字符串，要追加的长度）
    s = sdsMakeRoomFor(s,len);
    // 内存不足
    if (s == NULL) return NULL;
    // 追加目标字符串到字节数组中
    memcpy(s+curlen, t, len);
    // 设置追加后的长度
    sdssetlen(s, curlen+len);
    // 追加结束符
    s[curlen+len] = '\0';
    return s;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;/*空间调整，注意只是调整空间，后续自己组装字符串*/
sds sdsMakeRoomFor(sds s, size_t addlen) {
    void *sh, *newsh;
    // 当前剩下的空间
    size_t avail = sdsavail(s);
    size_t len, newlen;
    char type, oldtype = s[-1] &amp;amp; SDS_TYPE_MASK;
    int hdrlen;

    /* 空间足够 */
    if (avail &amp;gt;= addlen) return s;
    // 长度
    len = sdslen(s);
    // 真正的数据体
    sh = (char*)s-sdsHdrSize(oldtype);
    // 新长度
    newlen = (len+addlen);
    // &amp;lt; 1M 2倍扩容
    if (newlen &amp;lt; SDS_MAX_PREALLOC)
        newlen *= 2;
    // &amp;gt; 1M 扩容1M
    else
        newlen += SDS_MAX_PREALLOC;
    // 获取sds 结构类型
    type = sdsReqType(newlen);

    // type5 默认转成 type8
    if (type == SDS_TYPE_5) type = SDS_TYPE_8;
    // 头长度
    hdrlen = sdsHdrSize(type);
    if (oldtype==type) { // 长度够用 并且 数据结构不变 
        newsh = s_realloc(sh, hdrlen+newlen+1);
        if (newsh == NULL) return NULL;
        s = (char*)newsh+hdrlen;
    } else {
        // 重新申请内存
        newsh = s_malloc(hdrlen+newlen+1);
        if (newsh == NULL) return NULL;
        memcpy((char*)newsh+hdrlen, s, len+1);
        s_free(sh);
        s = (char*)newsh+hdrlen;
        s[-1] = type;
        sdssetlen(s, len);
    }
    sdssetalloc(s, newlen);
    return s;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;sds-和内部类型&quot;&gt;SDS 和　内部类型&lt;/h3&gt;
&lt;p&gt;外部字符串类型，找到了SDS结构，现在到了SDS转内部结构&lt;/p&gt;
&lt;p&gt;对于字符串类型为什么会分　embstr 和　raw呢？&lt;/p&gt;
&lt;p&gt;我们先说一下内存分配器：jemalloc、tcmalloc&lt;/p&gt;
&lt;p&gt;这来能为仁兄呢分配内存的大小都是　２／４／８／１６／３２／６４　字节&lt;/p&gt;
&lt;p&gt;对于redis 来讲如何利用并适配好内存分配器依然需要好好计算一下。&lt;/p&gt;
&lt;p&gt;Redis 给我们实现了很多内部数据结构，这些内部数据结构得有自己的字描述文件－内部结构头对象&lt;br/&gt;不同对象有不同的ｔｙｐｅ,同一个对象有不同的存储形式，还有ｌｒｕ缓存淘汰机制信息，引用计数器，指向数据体的指针。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;typedef struct redisObject {
    unsigned type:4;       
    unsigned encoding:4;    
    unsigned lru:LRU_BITS;  
    int refcount;　　　　　　
    void *ptr;            
} robj;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以ＳＤＳ和　内部类型的关系类似于这样的：&lt;/p&gt;
&lt;p&gt;连续内存，和非连续内存&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/406456/201912/406456-20191201000021898-324744488.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;字节&quot;&gt;44 字节&lt;/h3&gt;
&lt;p&gt;ＳＤＳ为什么会是这样的两种内部结构呢？&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;回忆一下上面提到的：ＳＤＳ结构，最小的应该是　SDS_TYPE_8（SDS_TYPE_５默认转成８）&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;struc SDS{
    int8 capacity;  // 1字节
    int8 len;       // 1字节
    int8 flags;     // 1字节
    byte[] content; // 内容
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以从上代码看出，一个最小的ＳＤＳ，至少占用３字节.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;还有内部结构头：RedisObject&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;typedef struct redisObject {
    unsigned type:4;        // 4bit
    unsigned encoding:4;    // 4bit
    unsigned lru:LRU_BITS;  // 24bit
    int refcount;　　　　　　 // ４字节
    void *ptr;              // 8字节
} robj;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;16字节　＝　32bit(4字节) + ４字节　+ 8字节&lt;/p&gt;
&lt;p&gt;所以一个内部类型头指针大小为：16字节&lt;/p&gt;
&lt;p&gt;再加上最小ＳＤＳ的３字节，一共　19字节。也就是说一个最小的字符串所占用的内存空间是19字节&lt;/p&gt;
&lt;p&gt;还记得上面我们提到过的内存分配器么？（２／４／８／１６／３２／６４　字节）&lt;/p&gt;
&lt;p&gt;对，如果要给这个最小19字节分配内存，至少要分配一个32字节的内存。当然如果字符串长一点，再往下就可以分配到64字节的内存。&lt;/p&gt;
&lt;p&gt;以上这种形式被叫做：embstr，这种形式使得 RedisObject和SDS 内存地址是连续的。&lt;/p&gt;
&lt;p&gt;那么一旦大于64字节，形式就变成了raw，这种形式使得内存不连续，因为SDS已经变大，取得大的连续内存得不偿失。&lt;/p&gt;
&lt;p&gt;再回来讨论一下 embstr, 最大64字节内存分配下来，我们实际可以真正存储字符串的长度是多少呢？--44字节&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/406456/201912/406456-20191201001855305-1852600125.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;64字节，减去RedisObject头信息19字节，再减去３字节SDS头信息，剩下45字节，再去除\0结尾。这样最后可以存储44字节。&lt;/p&gt;
&lt;p&gt;所以　embstr　形式，可以存储最大字符串长度是44字节。&lt;/p&gt;
&lt;h3 id=&quot;关于字符串最大是ｍ&quot;&gt;关于字符串最大是５１２Ｍ&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;Strings
Strings are the most basic kind of Redis value. Redis Strings are binary safe, 

this means that a Redis string can contain any kind of data, 

for instance a JPEG image or a serialized Ruby object.

A String value can be at max 512 Megabytes in length.&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;出个题redis-5.0.5版本&quot;&gt;　出个题（redis 5.0.5版本）&lt;/h3&gt;
&lt;p&gt;SET q sc&lt;/p&gt;
&lt;p&gt;encoding:embstr，长度为３&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/406456/201912/406456-20191201004315653-974202970.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在做追加操作，APPEND q scadd ，encoding:raw，长度８&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/406456/201912/406456-20191201004547839-907998501.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;为什么从 sc  ----&amp;gt;  scscadd 简单的追加操作内部类型会从　embstr　-----&amp;gt;   raw  ，如何解释？&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;喜欢的欢迎加公众号或者留言评论探讨&lt;/p&gt;
</description>
<pubDate>Sat, 30 Nov 2019 16:58:00 +0000</pubDate>
<dc:creator>K战神</dc:creator>
<og:description>对于上一篇文章，我又自己总结归纳并补充了一下，有了第二篇。 概览 1M , 新空间 = 累加1M 空间有了，那么我们需要根据最新的空间长度占用，再找到对应的新的ＳＤＳ数据类型。 看一下源码，增加一下印</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sunchong/p/11924295.html</dc:identifier>
</item>
<item>
<title>Java并发之synchronized关键字和Lock接口 - 布尔bl</title>
<link>http://www.cnblogs.com/chenzhuantou/p/11964787.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenzhuantou/p/11964787.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/30/16ebcfc680237d02?w=800&amp;amp;h=533&amp;amp;f=jpeg&amp;amp;s=180511&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5.5045871559633&quot;&gt;
&lt;p&gt;欢迎点赞阅读，一同学习交流，有疑问请留言 。&lt;br/&gt;GitHub上也有开源 &lt;a href=&quot;https://github.com/buerbl/JavaHouse&quot;&gt;JavaHouse&lt;/a&gt;，欢迎star&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;引用&quot;&gt;引用&lt;/h3&gt;
&lt;p&gt;当开发过程中,我们遇到并发问题。怎么解决？&lt;/p&gt;
&lt;p&gt;一种解决方式，简单粗暴：上锁。将千军万马都给拦下来，只允许一个人过独木桥。书面意思就是将并行的程序变成串行的程序。现实的锁有门锁、挂锁和抽屉锁等等。在Java中，我们的锁就是synchronized关键字和Lock接口。&lt;/p&gt;
&lt;h3 id=&quot;synchronized关键字&quot;&gt;synchronized关键字&lt;/h3&gt;
&lt;p&gt;synchronized也叫同步锁，是Java里面的关键字。我们可以猜测到synchronized原理也JVM虚拟机有关联。&lt;/p&gt;
&lt;p&gt;synchronized锁的是对象。对象里面有一个叫做监视锁(monitor)的东西，监视锁依赖操作系统的互斥锁（Mutex Lock）。操作系统切换线程其实就是从用户态编程核心态（cpu的两种状态）。这个代价有点高，所以synchronized这个重量级锁后面也引进了偏向锁和轻量级锁。&lt;/p&gt;
&lt;p&gt;加锁(监视锁monitor)过程分析()：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;当monitor的进入数为0，线程A进入&lt;/li&gt;
&lt;li&gt;monitor的进入数为1&lt;/li&gt;
&lt;li&gt;线程B想进入该monitor就会被阻塞。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;线程A可以重复进入该monitor，所以synchronized是可重入锁，和Lock实现的锁一样。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;程序验证&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class SynchronizedTest {
    private static  int i = 0;
    public static void main(String[] args) {
        test();
    }

    public static void test(){
        synchronized (SynchronizedTest.class){
            synchronized (SynchronizedTest.class){
                i++;
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;运行结果&lt;br/&gt;程序正常运行，没有报错&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;synchronized可以修饰方法以及代码块，代码块就是上面重入锁的例子。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;修饰方法&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class SynchronizedTest {
    static int n = 100;
    final static CountDownLatch start = new CountDownLatch(n);
    private static  int i = 0;
    public static void main(String[] args) throws InterruptedException {
        for (int j = 0; j &amp;lt; n; j++) {
            Thread thread = new Thread(new addNoSynchronized());
            thread.start();
        }
        start.await();
        System.out.println(i);
    }

    public static class addSynchronized implements Runnable{
        @Override
        public void run() {
            addSynchronized();
        }
        public static synchronized void addSynchronized(){
            for (int j = 0; j &amp;lt; 1000; j++) {
                i++;
            }
            start.countDown();
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;运行结果&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;100000&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果去掉 synchronized 关键字的话，运行结果大概率不是 100000，因为线程不安全问题。&lt;/p&gt;
&lt;h3 id=&quot;lock接口&quot;&gt;Lock接口&lt;/h3&gt;
&lt;p&gt;一般我们使用 ReentrantLock 类作为重入锁，实现Lock接口。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用方法&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ReentranLockTest {
    private static int j;
    private static int n = 100;
    private static CountDownLatch latch = new CountDownLatch(n);
    public static void main(String[] args) throws InterruptedException {
        for (int i = 0; i &amp;lt; n; i++) {
            new Thread(new LockTest()).start();
        }
        latch.await();
        System.out.println(&quot;结果为：&quot;+j);
    }

    public static class LockTest implements Runnable{
        static Lock lock = new ReentrantLock();
        @Override
        public void run() {
            lockTest();
            latch.countDown();
        }
        private void lockTest() {
            lock.lock();
            try {
                for (int i = 0; i &amp;lt; 1000; i++) {
                        j++;
                }
            }finally {
                lock.unlock();
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;运行结果&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;结果为：100000&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我们锁住的 j++ 这块资源区（公共资源），lock 是 static 关键字修饰的，是类对象，思考一下如果不是类对象会怎么样？那就是连环锁了（看图）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://q1rr6rhl9.bkt.clouddn.com/%E8%BF%9E%E7%8E%AF%E9%94%81.png&quot; alt=&quot;连环锁.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每一个线程都对可以用钥匙解开这把锁，对于程序而言，加锁操作就没有意义了。因为我们需要的是一个锁。&lt;/p&gt;
&lt;h3 id=&quot;欢迎关注我的微信公众号&quot;&gt;欢迎关注我的微信公众号&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://q1rr6rhl9.bkt.clouddn.com/%E5%85%AC%E4%BC%97%E5%8F%B7.jpg&quot; alt=&quot;公众号.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 30 Nov 2019 16:34:00 +0000</pubDate>
<dc:creator>布尔bl</dc:creator>
<og:description>欢迎点赞阅读，一同学习交流，有疑问请留言 。 GitHub上也有开源 'JavaHouse' ，欢迎star 引用 当开发过程中,我们遇到并发问题。怎么解决？ 一种解决方式，简单粗暴：上锁。将千军万马</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chenzhuantou/p/11964787.html</dc:identifier>
</item>
<item>
<title>Docker从门外到入门使用 - 嘘，小点声</title>
<link>http://www.cnblogs.com/bai2018/p/11964778.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bai2018/p/11964778.html</guid>
<description>&lt;h2&gt;取材&lt;/h2&gt;
&lt;p&gt;第一本Docker书。原作者：James Turnbull&lt;/p&gt;

&lt;h2&gt;安装&lt;/h2&gt;
&lt;p&gt;这里只说明Windows环境的安装（Windows7以上）&lt;/p&gt;
&lt;p&gt;使用Docker Toolbox工具即可：&lt;a href=&quot;http://mirrors.aliyun.com/docker-toolbox/windows/docker-toolbox/?spm=5176.8351553.0.0.58a71991lwK6LZ&quot; target=&quot;_blank&quot;&gt;http://mirrors.aliyun.com/docker-toolbox/windows/docker-toolbox/?spm=5176.8351553.0.0.58a71991lwK6LZ&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;然后点击下一步安装完毕，&lt;/p&gt;
&lt;p&gt;出现三个图标，ToolBox是Docker组件的集合，包括了一个极小的虚拟机，在Windows下安装了一个支持命令行的工具。&lt;/p&gt;
&lt;p&gt;而其中的Docker Quickstart Terminal，提供了一个命令行操作的平台，Kitematic (Alpha)提供了一个GUI客户端的平台。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1325410/201911/1325410-20191130213613178-1424223574.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 需要注意的是：使用-v的docker run命令在Windows下无法工作，因为无法挂载本地目录。&lt;/p&gt;


&lt;h2&gt;Docker组件说明&lt;/h2&gt;
&lt;h3&gt;1.Docker客户端和服务端&lt;/h3&gt;
&lt;p&gt;Docker客户端位于外界，各个客户端通过Docker守护进程作为中介，连接到Docker容器中。Docker容器和Docker守护进程，属于Docker主机中的内容。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1325410/201911/1325410-20191130215100987-1977323820.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h3&gt;2.Docker镜像&lt;/h3&gt;
&lt;p&gt;打开Docker Quickstart Terminal输入命令：docker images，即可查看本地的镜像。镜像是存储在本地的一个位置的（在/var/lib/docker中）&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
docker images
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;用户基于镜像，创建容器。&lt;/p&gt;
&lt;p&gt;在Docker里，root文件系统永远只读状态，并会通过root文件系统价值更多的只读文件系统。这样的文件系统称为镜像。&lt;/p&gt;
&lt;p&gt;容器将镜像的层层堆叠和覆盖，形成新的镜像，下面的镜像称为父镜像，最底层为基础镜像。在最上层是一个可读写的文件系统，用于Docker程序在该读写层执行。&lt;/p&gt;
&lt;p&gt;这种堆叠称为写时复制，因此说，当在最上层进行修改后，覆盖了原有的一部分，又可以构成新的镜像，然后发布（快速构建）。&lt;/p&gt;

&lt;h3&gt;3.Registry&lt;/h3&gt;
&lt;p&gt;Registry保存用户的镜像，下载，上传镜像。Docker公司是Docker Hub上存储了不少官方和私人的镜像。如MySQL数据库的镜像。用户也可以自己架设Registry，Registry也有共有和私有之分。&lt;/p&gt;
&lt;h3&gt;4.Docker容器&lt;/h3&gt;
&lt;p&gt;使用镜像创建容器container。我觉得是镜像的实例化。使用命令：docker run -i -t ubuntu /bin/bash之类的命令可以根据镜像创建容器，镜像不存在则自动下载镜像&lt;/p&gt;
&lt;p&gt;位置在（/var/lib/docker/containers）。在Toolbox中查看需要使用：docker-machine ssh进入到虚拟机中才可以查看。如图，有时候需要sudo，或者切换到管理员才能进入目录下：&lt;/p&gt;
&lt;p&gt;第二种图为容器的ID号码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1325410/201911/1325410-20191130232734427-721746320.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1325410/201911/1325410-20191130232658104-1312970830.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h2&gt;更改镜像源&lt;/h2&gt;
&lt;p&gt;有时候，一个良好的下载速度是必要的。和其它人一样，这里提供一个更改下载镜像源的方案。&lt;/p&gt;
&lt;p&gt;使用阿里云加速，也许可以打开参阅：&lt;a href=&quot;https://cr.console.aliyun.com/cn-shenzhen/instances/mirrors&quot; target=&quot;_blank&quot;&gt;https://cr.console.aliyun.com/cn-shenzhen/instances/mirrors&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;注册账号，找到容器镜像服务，打开，找到自己专属的地址，对应系统，然后输入到控制台中即可。可以用docker info 查看镜像源是否更改。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1325410/201911/1325410-20191130220207836-1122181451.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;h2&gt;查看docker信息&lt;/h2&gt;
&lt;p&gt;在终端输入docker info，可以查看到当前容器数量，镜像数量，还有更改的镜像源等&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1325410/201911/1325410-20191130220547618-1543735925.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1325410/201911/1325410-20191130220718987-2010345554.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;h2&gt;运行第一个容器&lt;/h2&gt;
&lt;p&gt;运行如下代码，-i保证容器中的STDIN开启，-t创建伪tty终端，这样可以交互。该代码使用的镜像为Ubuntu，当该镜像不存在则会自动pull然后下载，保存到本地。该镜像是一个基础镜像。&lt;/p&gt;
&lt;p&gt;创建的容器，是一个剪裁的Ubuntu系统，有自己的网络和IP地址，和宿主机通信的网络接口。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
docker run -i -t ubuntu /bin/bash
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行该行会进入到容器中，并自动为该容器创建一个名字和一个ID。&lt;/p&gt;
&lt;p&gt;名字可以在run的时候指定，指定的方式为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
docker run --name my_container -i -t ubuntu /bin/bash
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;输入后直接进入该容器中，输入hostname可以查看到ID。&lt;/p&gt;
&lt;p&gt;通过&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
apt update
apt install net-tools
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;命令安装完ifconfig的程序时候，可以通过ifconfig -a查看到该容器的IP地址。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1325410/201911/1325410-20191130221639422-1816882800.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 可以通过以下代码在容器中，查看进程，安装vim等&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
ps aux
apt install vim
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;输入exit退出容器，或者ctrl+d退出。退出容器，/bin/bash命令结束，容器停止。&lt;/p&gt;
&lt;p&gt;通过以下代码查看创建的容器详细信息，包括ID，名字。在引用的时候，可以使用ID，也可以使用名字引用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
docker ps -a
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1325410/201911/1325410-20191130222252353-1799160647.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;启动，创建，和附着容器&lt;/h2&gt;
&lt;p&gt;如下命令即可&lt;strong&gt;启动&lt;/strong&gt;：（对应到上图中ID的第一个，也可以使用NAMES的值代替ID，这里ID没有写全了，不过能用）&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
docker start 6d47
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用如下代码查看STATUS，可以看到启动了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
docker ps -a
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1325410/201911/1325410-20191130223031440-1283286891.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 容器&lt;strong&gt;创建&lt;/strong&gt;使用docker create命令，创建却不运行它。&lt;/p&gt;
&lt;p&gt;虽然容器启动了，可是没有进到容器中，不能进行交互式会话。&lt;/p&gt;
&lt;p&gt;使用如下命令，&lt;strong&gt;附着&lt;/strong&gt;到正在运行的容器，进行会话。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
docker attach 6d47
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样就又回到交互式环境中了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1325410/201911/1325410-20191130223824554-828589140.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h2&gt;创建和使用守护式容器&lt;/h2&gt;
&lt;p&gt;守护式容器没有交互式会话，长期运行在后台，提供服务即可。使用的命令还是run命令。&lt;/p&gt;
&lt;p&gt;运行如下命令，即可创建一个守护式容器。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
docker run --name my_container -d ubuntu /bin/sh -c &quot;while true;do echo hello world;sleep 1;done&quot;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行完以后，通过docker ps -a可以查看状态，它在后台运行。会在每秒中输出一个hello world。&lt;/p&gt;
&lt;p&gt;因为使用了-d参数，所以才能够放到后台运行。&lt;/p&gt;
&lt;p&gt;查看该容器中的输出效果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
docker logs my_container
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1325410/201911/1325410-20191130224505735-1542855514.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用如下跟踪守护式进程日志（ctrl +c退出跟踪（容器不会停止））：&lt;/p&gt;
&lt;p&gt;另外，-t可以增加日志的时间戳信息，如--tail 4，可以只显示最后四条信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
docker logs -f my_container
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Docker日志驱动，使用&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
docker run --log-driver=&quot;syslog&quot; --name container -d ubuntu /bin/sh -c &quot;while true;do echo hello world;sleep 1;done&quot;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;创建，但是在Docker Toolbox中，需要使用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
docker-machine ssh
syslogd
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;命令进入Docker Toolbox虚拟机，然后运行syslogd，来启动syslog守护进程&lt;/p&gt;

&lt;h2&gt;容器进程查看、统计信息&lt;/h2&gt;
&lt;p&gt;在终端查看守护式容器中的进程：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
docker top my_container
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1325410/201911/1325410-20191130225156101-988402827.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h2&gt;在容器中运行进程&lt;/h2&gt;
&lt;p&gt;后台命令示例使用代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
docker exec -d my_container touch /etc/new_file
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;则在该容器中（-d表示后台执行），创建一个新文件&lt;/p&gt;
&lt;p&gt;交互式命令示例使用代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
docker exec -t -i my_container /bin/bash
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该代码可以进去与之前创建的守护式容器进行交互（当然我之前使用了 docker exec -d my_container kill -9 xxx结束了容器中的循环echo的代码了）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1325410/201911/1325410-20191130230454601-1604004467.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h2&gt;停止、自重启守护式容器&lt;/h2&gt;
&lt;p&gt;使用如下（发送SIGTERM信号），停止正在运行的该容器：（也可以使用docker kill 发送SIGKILL信号更快停止）&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
docker stop my_container
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;创建守护式容器中使用了：docker run --name my_container -d ubuntu /bin/sh -c &quot;while true;do echo hello world;sleep 1;done&quot;，这里添加--restart部分即可&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
docker run --restart=always --name my_container -d ubuntu /bin/sh -c &quot;while true;do echo hello world;sleep 1;done&quot;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以使用always表示是否正常退出都重启，使用参数为on-failure:5表示失败重启，次数为5次。&lt;/p&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;查看容器详细信息与删除容器&lt;/h2&gt;
&lt;p&gt;查看详细信息如下，其中第二条用于过滤信息。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
docker inspect my_container
docker inspect --format='{{.State.Running}}' my_container
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;删除容器使用rm命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
docker rm my_container
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用-f选项，可以删除正在运行中的容器。&lt;/p&gt;
&lt;p&gt;删除所有容器的方法是：&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
docker rm `docker ps -a -q`
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中的子句列出了所有容器的id。&lt;/p&gt;

&lt;h2&gt;拉取、查找镜像&lt;/h2&gt;
&lt;h3&gt;拉取：&lt;/h3&gt;
&lt;p&gt;之前通过run获取的是自动获取，这里手动下载镜像示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
docker pull ubuntu:12.04
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该命令会从Docker Hub上拉取镜像&lt;/p&gt;
&lt;p&gt;之后可以通过docker images查看本地镜像。在拉取过程中，不指定则使用标签为latest，这里指定了标签为12.04.&lt;/p&gt;
&lt;p&gt;这种标签机制可以存活多个相同名字不同标签的镜像。&lt;/p&gt;
&lt;p&gt;在run的过程中，指定基础镜像时候，需要加上该标签更合适（默认latest）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
docker run --name my_container -i -t ubuntu:12.04 /bin/bash
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从用户那里拉取镜像时候，：需要包含：用户名，仓库名。&lt;/p&gt;
&lt;p&gt;之前拉取只有仓库名，是因为其为顶级仓库，由优质厂商提供的镜像。&lt;/p&gt;
&lt;h3&gt;查找镜像：&lt;/h3&gt;
&lt;p&gt;使用代码示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
docker search puppet
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1325410/201911/1325410-20191130234603043-1677973862.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;会提示一些信息，排名等&lt;/p&gt;
&lt;p&gt;然后通过以下拉取镜像即可&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
docker pull xxx/xxxx
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;前面是用户名，后面是仓库名。&lt;/p&gt;

&lt;h2&gt;构建镜像--commit&lt;/h2&gt;
&lt;p&gt;这里指代的是在原有镜像的基础上，进行修改，然后重新生成新的镜像。&lt;/p&gt;
&lt;p&gt;创建容器，进行修改后退出容器，提交即可：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
docker run -i -t ubuntu /bin/bash

apt update
apt -y install apache2

docker commit $ID $用户名/$仓库名
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中，提交参数有 -a 后面添加作者，-m后面添加提交说明，仓库名后添加    :$标签   ，表示提交使用的标签。&lt;/p&gt;
&lt;p&gt;提交后成为镜像，又可以拿来产生容器。&lt;/p&gt;

&lt;h2&gt;构建镜像--build与Dockerfile&lt;/h2&gt;
&lt;p&gt;使用build和Dockerfile创建镜像。其中Dockerfile中填写了一些说明信息。下面构建了文件夹作为环境上下文，然后在该环境中创建文件。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
mkdir static_web
cd static_web
touch Dockerfile
nano Dockerfile
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;文件中写入的内容例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
FROM ubuntu:14.04
MAINTAINER Bai &quot;1872040489@qq.com&quot;
RUN apt-get update &amp;amp;&amp;amp; apt-get install -y nginx
RUN echo 'Hi I am in your container ' &amp;gt; /usr/share/nginx/html/index.html
EXPOSE 80
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这里的每一个作为一个控制说明。分别说明了基础镜像，作者，邮箱，运行命令和向外公布的端口。&lt;/p&gt;
&lt;p&gt;当然其还有如CMD，ENTRYPOINT，WORKDIR等等的标记，用于构建Dockerfile。#表示注释&lt;/p&gt;
&lt;p&gt;其中run的命令在有时候需要写成如下格式(exec格式的RUN指令)：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
RUN [&quot;apt-get&quot;, &quot;install&quot;,&quot;-y&quot;,&quot;nginx&quot;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;进行保存后，在该路径下执行命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
docker build -t=&quot;jamtur01/static_web:v1&quot; .
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;进行在该路径下构建镜像，每一步会形成一个新的镜像，中途失败，下次会冲上次失败的地方开始（镜像堆叠效果）。&lt;/p&gt;
&lt;p&gt;使用docker history + 镜像可以查看堆叠过程。&lt;/p&gt;
&lt;p&gt;以上构建代码指明了用户名，仓库名，标签。&lt;/p&gt;
&lt;p&gt;另外，也可以在git仓库中构建镜像。&lt;/p&gt;

&lt;h2&gt;Docker运行nginx&lt;/h2&gt;
&lt;p&gt;在构建一个nginx镜像成功以后，通过以下命令，进行端口映射，然后创建容器：以下代码使用了地址加随机端口的方式，进行了映射。当然还有其它各种映射方案。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
sudo docker run -d -p 127.0.0.1::80 --name static jm/static_web_1 nginx -g &quot;daemon off;&quot;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过以下查看端口映射情况（都可）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
docker ps -l 
docker port + ID + 被映射端口
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;上传镜像&lt;/h2&gt;
&lt;p&gt;使用：docker push username/image&lt;/p&gt;
&lt;p&gt;可能需要登录：&lt;/p&gt;
&lt;p&gt;docker login命令即可&lt;/p&gt;

&lt;h2&gt;删除镜像&lt;/h2&gt;
&lt;p&gt;使用docker rmi +镜像即可&lt;/p&gt;

</description>
<pubDate>Sat, 30 Nov 2019 16:29:00 +0000</pubDate>
<dc:creator>嘘，小点声</dc:creator>
<og:description>取材 第一本Docker书。原作者：James Turnbull 安装 这里只说明Windows环境的安装（Windows7以上） 使用Docker Toolbox工具即可：http://mirror</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bai2018/p/11964778.html</dc:identifier>
</item>
<item>
<title>Android View 的测量流程详解 - huansky</title>
<link>http://www.cnblogs.com/huansky/p/11920454.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huansky/p/11920454.html</guid>
<description>&lt;p&gt;上一篇 &lt;span&gt;&lt;strong&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/huansky/p/11911549.html&quot;&gt;&lt;span&gt;Android DecorView 与 Activity 绑定原理分析&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt; 分析了在调用 setContentView 之后，DecorView 是如何与 activity 关联在一起的，最后讲到了 ViewRootImpl 开始绘制的逻辑。本文接着上篇，继续往下讲，开始分析 view 的绘制流程。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上文说到了调用 performTraversals 进行绘制，由于 performTraversals 方法比较长，看一个简化版：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ViewRootImpl 类&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; performTraversals() {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这个方法代码非常多，但是重点就是执行这三个方法
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行测量&lt;/span&gt;
&lt;span&gt;    performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行布局（ViewGroup）中才会有&lt;/span&gt;
&lt;span&gt;    performLayout(lp, mWidth, mHeight);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行绘制&lt;/span&gt;
&lt;span&gt;    performDraw();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其流程具体如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/916005/201911/916005-20191123221335699-216981443.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; View的整个绘制流程可以分为以下三个阶段：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;measure: 判断是否需要重新计算 View 的大小，需要的话则计算；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;layout: 判断是否需要重新计算 View 的位置，需要的话则计算；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;draw: 判断是否需要重新绘制 View，需要的话则重绘制。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在介绍绘制前，先了解下 MeasureSpec。MeasureSpec 封装了父布局传递给子布局的布局要求，它通过一个 32 位 int 类型的值来表示，该值包含了两种信息，高两位表示的是 &lt;code&gt;SpecMode&lt;/code&gt;（测量模式），低 30 位表示的是 &lt;code&gt;SpecSize&lt;/code&gt;（测量的具体大小）。下面通过注释的方式来分析来类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;  
 * 三种SpecMode： 
 * 1.UNSPECIFIED 
 * 父 ViewGroup 没有对子View施加任何约束，子 view 可以是任意大小。这种情况比较少见,主要用于系统内部多次measure的情形，&lt;br/&gt;* 用到的一般都是可以滚动的容器中的子view，比如ListView、GridView、RecyclerView中某些情况下的子view就是这种模式。&lt;br/&gt;* 一般来说，我们不需要关注此模式。
 * 2.EXACTLY 
 * 该 view 必须使用父 ViewGroup 给其指定的尺寸。对应 match_parent 或者具体数值（比如30dp）
 * 3.AT_MOST 
 * 该 View 最大可以取父ViewGroup给其指定的尺寸。对应wrap_content
 *  
 * MeasureSpec使用了二进制去减少对象的分配。 
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;  
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MeasureSpec {  
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 进位大小为2的30次方(int的大小为32位，所以进位30位就是要使用int的最高位和第二高位也就是32和31位做标志位)  &lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; MODE_SHIFT = 30&lt;span&gt;;  
 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 运算遮罩，0x3为16进制，10进制为3，二进制为11。3向左进位30，就是11 00000000000(11后跟30个0)  
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; (遮罩的作用是用1标注需要的值，0标注不要的值。因为1与任何数做与运算都得任何数，0与任何数做与运算都得0）  &lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; MODE_MASK  = 0x3 &amp;lt;&amp;lt;&lt;span&gt; MODE_SHIFT;  
 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 0向左进位30，就是00 00000000000(00后跟30个0)  &lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; UNSPECIFIED = 0 &amp;lt;&amp;lt;&lt;span&gt; MODE_SHIFT;  
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1向左进位30，就是01 00000000000(01后跟30个0)  &lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; EXACTLY     = 1 &amp;lt;&amp;lt;&lt;span&gt; MODE_SHIFT;  
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2向左进位30，就是10 00000000000(10后跟30个0)  &lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; AT_MOST     = 2 &amp;lt;&amp;lt;&lt;span&gt; MODE_SHIFT;  
 
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 
         * 根据提供的size和mode得到一个详细的测量结果 
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;  
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第一个return：
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; measureSpec = size + mode；   (注意：二进制的加法，不是十进制的加法！)  
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里设计的目的就是使用一个32位的二进制数，32和31位代表了mode的值，后30位代表size的值  
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 例如size=100(4)，mode=AT_MOST，则measureSpec=100+10000...00=10000..00100  
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第二个return：
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; size &amp;amp;; ~MODE_MASK就是取size 的后30位，mode &amp;amp;amp; MODE_MASK就是取mode的前两位，最后执行或运算，得出来的数字，前面2位包含代表mode，后面30位代表size&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; makeMeasureSpec(&lt;span&gt;int&lt;/span&gt; size, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; mode) {  
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (sUseBrokenMakeMeasureSpec) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; size +&lt;span&gt; mode;
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (size &amp;amp; ~MODE_MASK) | (mode &amp;amp; &lt;span&gt; MODE_MASK);
            }
        }  
 
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 
         * 获得SpecMode
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;  
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; mode = measureSpec &amp;amp;amp; MODE_MASK;  
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; MODE_MASK = 11 00000000000(11后跟30个0)，原理是用MODE_MASK后30位的0替换掉measureSpec后30位中的1,再保留32和31位的mode值。  
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 例如10 00..00100 &amp;amp; 11 00..00(11后跟30个0) = 10 00..00(AT_MOST)，这样就得到了mode的值  &lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; getMode(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; measureSpec) {  
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (measureSpec &amp;amp; &lt;span&gt;MODE_MASK);  
        }  
 
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 
         * 获得SpecSize 
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;  
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; size = measureSpec &amp;amp;  ~MODE_MASK;  
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 原理同上，不过这次是将MODE_MASK取反，也就是变成了00 111111(00后跟30个1)，将32,31替换成0也就是去掉mode，保留后30位的size  &lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; getSize(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; measureSpec) {  
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (measureSpec &amp;amp;  ~&lt;span&gt;MODE_MASK);  
        }  
}  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;顺便提下 MATCH_PARENT 和 WRAP_CONTENT 这两个代表的值，分别是 -1 和 -2。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
       &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * Special value for the height or width requested by a View.
         * MATCH_PARENT means that the view wants to be as big as its parent,
         * minus the parent's padding, if any. Introduced in API Level 8.
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; MATCH_PARENT = -1&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * Special value for the height or width requested by a View.
         * WRAP_CONTENT means that the view wants to be just large enough to fit
         * its own internal content, taking its own padding into account.
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; WRAP_CONTENT = -2;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在 performTraversals 中，首先是要确定 DecorView 的尺寸。只有当 DecorView 尺寸确定了，其子 View 才可以知道自己能有多大。具体是如何去确定的，可以看下面的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Activity窗口的宽度和高度&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt;&lt;span&gt; desiredWindowWidth;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; desiredWindowHeight;
...
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用来保存窗口宽度和高度，来自于全局变量mWinFrame，这个mWinFrame保存了窗口最新尺寸&lt;/span&gt;
Rect frame =&lt;span&gt; mWinFrame;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;构造方法里mFirst赋值为true，意思是第一次执行遍历吗    &lt;/span&gt;
&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (mFirst) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否需要重绘&lt;/span&gt;
    mFullRedrawNeeded = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否需要重新确定Layout&lt;/span&gt;
    mLayoutRequested = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    
&lt;span&gt;    // 这里又包含两种情况：是否包括状态栏
    
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断要绘制的窗口是否包含状态栏，有就去掉，然后确定要绘制的Decorview的高度和宽度&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (shouldUseDisplaySize(lp)) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; NOTE -- system code, won't try to do compat mode.&lt;/span&gt;
        Point size = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Point();
        mDisplay.getRealSize(size);
        desiredWindowWidth &lt;/span&gt;=&lt;span&gt; size.x;
        desiredWindowHeight &lt;/span&gt;=&lt;span&gt; size.y;
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;宽度和高度为整个屏幕的值&lt;/span&gt;
        Configuration config =&lt;span&gt; mContext.getResources().getConfiguration();
        desiredWindowWidth &lt;/span&gt;=&lt;span&gt; dipToPx(config.screenWidthDp);
        desiredWindowHeight &lt;/span&gt;=&lt;span&gt; dipToPx(config.screenHeightDp);
    }
    ...
&lt;/span&gt;&lt;span&gt; else&lt;/span&gt;&lt;span&gt;{
    
&lt;span&gt;        // 这是window的长和宽改变了的情况，需要对改变的进行数据记录
    
        &lt;/span&gt;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果不是第一次进来这个方法，它的当前宽度和高度就从之前的mWinFrame获取&lt;/span&gt;
        desiredWindowWidth =&lt;span&gt; frame.width();
        desiredWindowHeight &lt;/span&gt;=&lt;span&gt; frame.height();
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * mWidth和mHeight是由WindowManagerService服务计算出的窗口大小，
         * 如果这次测量的窗口大小与这两个值不同，说明WMS单方面改变了窗口的尺寸
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (desiredWindowWidth != mWidth || desiredWindowHeight !=&lt;span&gt; mHeight) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (DEBUG_ORIENTATION) Log.v(mTag, &quot;View &quot; + host + &quot; resized to: &quot; +&lt;span&gt; frame);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;需要进行完整的重绘以适应新的窗口尺寸&lt;/span&gt;
            mFullRedrawNeeded = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;需要对控件树进行重新布局&lt;/span&gt;
            mLayoutRequested = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;window窗口大小改变&lt;/span&gt;
            windowSizeMayChange = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }
 }
    ...
    &lt;/span&gt;&lt;span&gt;// &lt;/span&gt;&lt;span&gt;进行预测量&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (layoutRequested){
        ...
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (mFirst) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 视图窗口当前是否处于触摸模式。&lt;/span&gt;
            mAttachInfo.mInTouchMode = !&lt;span&gt;mAddedTouchMode;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;确保这个Window的触摸模式已经被设置&lt;/span&gt;
&lt;span&gt;            ensureTouchModeLocally(mAddedTouchMode);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;六个if语句，判断insects值和上一次比有什么变化，不同的话就改变insetsChanged
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;insects值包括了一些屏幕需要预留的区域、记录一些被遮挡的区域等信息&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;mPendingOverscanInsets.equals(mAttachInfo.mOverscanInsets)) {
                    insetsChanged &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }
            ...
            
&lt;span&gt;          //  这里有一种情况，我们在写dialog时，会手动添加布局，当设定宽高为Wrap_content时，会把屏幕的宽高进行赋值，给出尽量长的宽度
            
            &lt;/span&gt;&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
             * 如果当前窗口的根布局的width或height被指定为 WRAP_CONTENT 时，
             * 比如Dialog，那我们还是给它尽量大的长宽，这里是将屏幕长宽赋值给它
             &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (lp.width ==&lt;span&gt; ViewGroup.LayoutParams.WRAP_CONTENT
                    &lt;/span&gt;|| lp.height ==&lt;span&gt; ViewGroup.LayoutParams.WRAP_CONTENT) {
                windowSizeMayChange &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断要绘制的窗口是否包含状态栏，有就去掉，然后确定要绘制的Decorview的高度和宽度&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (shouldUseDisplaySize(lp)) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; NOTE -- system code, won't try to do compat mode.&lt;/span&gt;
                    Point size = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Point();
                    mDisplay.getRealSize(size);
                    desiredWindowWidth &lt;/span&gt;=&lt;span&gt; size.x;
                    desiredWindowHeight &lt;/span&gt;=&lt;span&gt; size.y;
                } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    Configuration config &lt;/span&gt;=&lt;span&gt; res.getConfiguration();
                    desiredWindowWidth &lt;/span&gt;=&lt;span&gt; dipToPx(config.screenWidthDp);
                    desiredWindowHeight &lt;/span&gt;=&lt;span&gt; dipToPx(config.screenHeightDp);
                }
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里主要是分两步走：&lt;/p&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;如果是第一次测量，那么根据是否有状态栏，来确定是直接使用屏幕的高度，还是真正的显示区高度。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;如果不是第一次，那么从 mWinFrame 获取，并和之前保存的长宽高进行比较，不相等的话就需要重新测量确定高度。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;当确定了 DecorView 的具体尺寸之后，然后就会调用 measureHierarchy 来确定其 MeasureSpec ：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Ask host how big it wants to be&lt;/span&gt;
  windowSizeMayChange |=&lt;span&gt; measureHierarchy(host, lp, res,
        desiredWindowWidth, desiredWindowHeight);&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中 host 就是 DecorView，lp 是 wm 在添加时候传给 DecorView 的，最后两个就是刚刚确定显示宽高 ，看下方法的具体逻辑 ：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; measureHierarchy(&lt;span&gt;final&lt;/span&gt; View host, &lt;span&gt;final&lt;/span&gt;&lt;span&gt; WindowManager.LayoutParams lp,
            &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Resources res, &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; desiredWindowWidth, &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; desiredWindowHeight) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; childWidthMeasureSpec;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; childHeightMeasureSpec;
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; windowSizeMayChange = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; goodMeasure = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;&lt;span&gt;　　　　　// 说明是 dialog
        &lt;/span&gt;&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (lp.width ==&lt;span&gt; ViewGroup.LayoutParams.WRAP_CONTENT) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; On large screens, we don't want to allow dialogs to just
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; stretch to fill the entire width of the screen to display
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; one line of text.  First try doing the layout at a smaller
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; size to see if it will fit.&lt;/span&gt;
            &lt;span&gt;final&lt;/span&gt; DisplayMetrics packageMetrics =&lt;span&gt; res.getDisplayMetrics();
            res.getValue(com.android.internal.R.dimen.config_prefDialogWidth, mTmpValue, &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; baseSize = 0&lt;span&gt;;&lt;br/&gt;&lt;span&gt;　　　　　　　// 获取一个基本的尺寸 
            &lt;/span&gt;&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mTmpValue.type ==&lt;span&gt; TypedValue.TYPE_DIMENSION) {
                baseSize &lt;/span&gt;= (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)mTmpValue.getDimension(packageMetrics);
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (DEBUG_DIALOG) Log.v(mTag, &quot;Window &quot; + mView + &quot;: baseSize=&quot; +&lt;span&gt; baseSize
                    &lt;/span&gt;+ &quot;, desiredWindowWidth=&quot; +&lt;span&gt; desiredWindowWidth);&lt;br/&gt;&lt;span&gt;　　　　　　　// 如果大于基本尺寸
            &lt;/span&gt;&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (baseSize != 0 &amp;amp;&amp;amp; desiredWindowWidth &amp;gt;&lt;span&gt; baseSize) {
                childWidthMeasureSpec &lt;/span&gt;=&lt;span&gt; getRootMeasureSpec(baseSize, lp.width);
                childHeightMeasureSpec &lt;/span&gt;=&lt;span&gt; getRootMeasureSpec(desiredWindowHeight, lp.height);
&lt;span&gt;                performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);
                &lt;/span&gt;&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (DEBUG_DIALOG) Log.v(mTag, &quot;Window &quot; + mView + &quot;: measured (&quot;
                        + host.getMeasuredWidth() + &quot;,&quot; +&lt;span&gt; host.getMeasuredHeight()
                        &lt;/span&gt;+ &quot;) from width spec: &quot; +&lt;span&gt; MeasureSpec.toString(childWidthMeasureSpec)
                        &lt;/span&gt;+ &quot; and height spec: &quot; +&lt;span&gt; MeasureSpec.toString(childHeightMeasureSpec));&lt;br/&gt;&lt;span&gt;　　　　　　　　　　// 判断测量是否准确
                &lt;/span&gt;&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((host.getMeasuredWidthAndState()&amp;amp;View.MEASURED_STATE_TOO_SMALL) == 0&lt;span&gt;) {
                    goodMeasure &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Didn't fit in that size... try expanding a bit.&lt;/span&gt;
                    baseSize = (baseSize+desiredWindowWidth)/2&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (DEBUG_DIALOG) Log.v(mTag, &quot;Window &quot; + mView + &quot;: next baseSize=&quot;
                            +&lt;span&gt; baseSize);
                    childWidthMeasureSpec &lt;/span&gt;=&lt;span&gt; getRootMeasureSpec(baseSize, lp.width);
&lt;span&gt;                    performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);
                    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (DEBUG_DIALOG) Log.v(mTag, &quot;Window &quot; + mView + &quot;: measured (&quot;
                            + host.getMeasuredWidth() + &quot;,&quot; + host.getMeasuredHeight() + &quot;)&quot;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((host.getMeasuredWidthAndState()&amp;amp;View.MEASURED_STATE_TOO_SMALL) == 0&lt;span&gt;) {
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (DEBUG_DIALOG) Log.v(mTag, &quot;Good!&quot;&lt;span&gt;);
                        goodMeasure &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                    }
                }
            }
        }
&lt;span&gt;　　　　　// 这里就是一般 DecorView 会走的逻辑
        &lt;/span&gt;&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;goodMeasure) {
            childWidthMeasureSpec &lt;/span&gt;=&lt;span&gt; getRootMeasureSpec(desiredWindowWidth, lp.width);
            childHeightMeasureSpec &lt;/span&gt;=&lt;span&gt; getRootMeasureSpec(desiredWindowHeight, lp.height);
&lt;span&gt;            performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);&lt;br/&gt;&lt;span&gt;　　　　　　　// 与之前的尺寸进行对比，看看是否相等，不想等，说明尺寸可能发生了变化
            &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mWidth != host.getMeasuredWidth() || mHeight !=&lt;span&gt; host.getMeasuredHeight()) {
                windowSizeMayChange &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }
        }
&lt;/span&gt;&lt;span&gt;      return&lt;/span&gt;&lt;span&gt; windowSizeMayChange;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面主要主要做的就是来确定父 View 的 MeasureSpec。但是分了两种不同类型：&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;如果宽是 WRAP_CONTENT 类型，说明这是 dialog，会有一些针对 dialog 的处理，最终会调用 performMeasure 进行测量；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;对于一般 Activity 的尺寸，会调用  getRootMeasureSpec MeasureSpec 。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面看下 DecorView MeasureSpec 的计算方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; getRootMeasureSpec(&lt;span&gt;int&lt;/span&gt; windowSize, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; rootDimension) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; measureSpec;
        &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (rootDimension) {

        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; ViewGroup.LayoutParams.MATCH_PARENT:
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Window can't resize. Force root view to be windowSize.&lt;/span&gt;
            measureSpec =&lt;span&gt; MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; ViewGroup.LayoutParams.WRAP_CONTENT:
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Window can resize. Set max size for root view.&lt;/span&gt;
            measureSpec =&lt;span&gt; MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Window wants to be an exact size. Force root view to be that size.&lt;/span&gt;
            measureSpec =&lt;span&gt; MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; measureSpec;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 该方法主要&lt;span&gt;是根据 View 的 MeasureSpec 是根据宽高的参数来划分的。&lt;/span&gt;&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;MATCH_PARENT ：精确模式，大小就是窗口的大小；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;WRAP_CONTENT ：最大模式，大小不定，但是不能超过窗口的大小；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;固定大小：精确模式，大小就是指定的具体宽高，比如100dp。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;对于 DecorView 来说就是走第一个 &lt;code&gt;case，到这里 DecorView 的 MeasureSpec 就确定了，从 MeasureSpec 可以得出 DecorView 的宽高的约束信息。&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;当父 ViewGroup 对子 View 进行测量时，会调用 View 类的 &lt;code&gt;measure &lt;/code&gt;方法，这是一个 final 方法，无法被重写。ViewGroup 会传入自己的 &lt;code&gt;widthMeasureSpec &lt;/code&gt;和  &lt;code&gt;heightMeasureSpec&lt;/code&gt;，分别表示父 View 对子 View 的宽度和高度的一些限制条件。尤其是当 ViewGroup 是 WRAP_CONTENT 的时候，需要优先测量子 View，只有子 View 宽高确定，ViewGroup 才能确定自己到底需要多大的宽高。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当 DecorView 的 MeasureSpec 确定以后，ViewRootImpl 内部会调用 performMeasure 方法：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; performMeasure(&lt;span&gt;int&lt;/span&gt; childWidthMeasureSpec, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; childHeightMeasureSpec) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mView == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        Trace.traceBegin(Trace.TRACE_TAG_VIEW, &lt;/span&gt;&quot;measure&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            Trace.traceEnd(Trace.TRACE_TAG_VIEW);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该方法传入的是对 DecorView 的 MeasureSpec，其中 mView 就是 DecorView 的实例，接下来看 measure() 的具体逻辑：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;72&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 调用这个方法来算出一个View应该为多大。参数为父View对其宽高的约束信息。
 * 实际的测量工作在onMeasure()方法中进行
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; measure(&lt;span&gt;int&lt;/span&gt; widthMeasureSpec, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; heightMeasureSpec) {
  ......&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;  // Suppress sign extension for the low bytes
&lt;/span&gt;   &lt;span&gt;long&lt;/span&gt; key = (&lt;span&gt;long&lt;/span&gt;) widthMeasureSpec &amp;lt;&amp;lt; 32 | (&lt;span&gt;long&lt;/span&gt;) heightMeasureSpec &amp;amp; 0xffffffffL&lt;span&gt;;
   &lt;span&gt;if&lt;/span&gt; (mMeasureCache == null) mMeasureCache = new LongSparseLongArray(2);&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 若mPrivateFlags中包含PFLAG_FORCE_LAYOUT标记，则强制重新布局
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 比如调用View.requestLayout()会在mPrivateFlags中加入此标记&lt;/span&gt;
  &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; forceLayout = (mPrivateFlags &amp;amp; PFLAG_FORCE_LAYOUT) ==&lt;span&gt; PFLAG_FORCE_LAYOUT;
  &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; specChanged = widthMeasureSpec !=&lt;span&gt; mOldWidthMeasureSpec
      &lt;/span&gt;|| heightMeasureSpec !=&lt;span&gt; mOldHeightMeasureSpec;
  &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; isSpecExactly = MeasureSpec.getMode(widthMeasureSpec) ==&lt;span&gt; MeasureSpec.EXACTLY
      &lt;/span&gt;&amp;amp;&amp;amp; MeasureSpec.getMode(heightMeasureSpec) ==&lt;span&gt; MeasureSpec.EXACTLY;
  &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; matchesSpecSize = getMeasuredWidth() ==&lt;span&gt; MeasureSpec.getSize(widthMeasureSpec)
      &lt;/span&gt;&amp;amp;&amp;amp; getMeasuredHeight() ==&lt;span&gt; MeasureSpec.getSize(heightMeasureSpec);
  &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; needsLayout =&lt;span&gt; specChanged
      &lt;/span&gt;&amp;amp;&amp;amp; (sAlwaysRemeasureExactly || !isSpecExactly || !&lt;span&gt;matchesSpecSize);

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 需要重新布局  &lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt; (forceLayout ||&lt;span&gt; needsLayout) {&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;    // first clears the measured dimension flag 标记为未测量状态&lt;/span&gt;&lt;br/&gt;mPrivateFlags &amp;amp;= ~PFLAG_MEASURED_DIMENSION_SET;&lt;br/&gt;&lt;span&gt;    &lt;/span&gt;&lt;br/&gt;resolveRtlPropertiesIfNeeded();
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 先尝试从缓从中获取，若forceLayout为true或是缓存中不存在或是
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 忽略缓存，则调用onMeasure()重新进行测量工作&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; cacheIndex = forceLayout ? -1&lt;span&gt; : mMeasureCache.indexOfKey(key);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (cacheIndex &amp;lt; 0 ||&lt;span&gt; sIgnoreMeasureCache) {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; measure ourselves, this should set the measured dimension flag back&lt;/span&gt;
&lt;span&gt;      onMeasure(widthMeasureSpec, heightMeasureSpec);
      . . .
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 缓存命中，直接从缓存中取值即可，不必再测量&lt;/span&gt;
      &lt;span&gt;long&lt;/span&gt; value =&lt;span&gt; mMeasureCache.valueAt(cacheIndex);
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Casting a long to int drops the high 32 bits, no mask needed&lt;/span&gt;
      setMeasuredDimensionRaw((&lt;span&gt;int&lt;/span&gt;) (value &amp;gt;&amp;gt; 32), (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;) value);&lt;br/&gt;mPrivateFlags3 |= PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;    }&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;　　 &lt;span&gt;// 如果自定义的View重写了onMeasure方法，但是没有调用setMeasuredDimension()方法就会在这里抛出错误；&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;　　 // flag not set, setMeasuredDimension() was not invoked, we raise&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　 // an exception to warn the developer&lt;/span&gt;&lt;br/&gt;　　 &lt;span&gt;if&lt;/span&gt; ((mPrivateFlags &amp;amp; PFLAG_MEASURED_DIMENSION_SET) != PFLAG_MEASURED_DIMENSION_SET) {&lt;br/&gt;　　 throw new IllegalStateException(&quot;View with id &quot; + getId() + &quot;: &quot;&lt;br/&gt;　　+ getClass().getName() + &quot;#onMeasure() did not set the&quot;&lt;br/&gt;　　+ &quot; measured dimension by calling&quot;&lt;br/&gt;　　+ &quot; setMeasuredDimension()&quot;);&lt;br/&gt;　　 }
&lt;/pre&gt;

&lt;div class=&quot;hljs-ln-code&quot;&gt;
&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;pre&gt;
　　 mPrivateFlags |= PFLAG_LAYOUT_REQUIRED;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;  }
  mOldWidthMeasureSpec &lt;/span&gt;=&lt;span&gt; widthMeasureSpec;
  mOldHeightMeasureSpec &lt;/span&gt;=&lt;span&gt; heightMeasureSpec;&lt;br/&gt;&lt;span&gt; // 保存到缓存中
&lt;/span&gt;  mMeasureCache.put(key, ((&lt;/span&gt;&lt;span&gt;long&lt;/span&gt;) mMeasuredWidth) &amp;lt;&amp;lt; 32 |&lt;span&gt;
      (&lt;/span&gt;&lt;span&gt;long&lt;/span&gt;) mMeasuredHeight &amp;amp; 0xffffffffL); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; suppress sign extension&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 这里要注意的是，这是一个 final 方法，不能被继承。这个方法只在 View 类里面。总结一下 &lt;code&gt;measure() &lt;/code&gt;都干了什么事:&lt;/span&gt;&lt;/p&gt;
&lt;ul readability=&quot;7&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;调用 &lt;code&gt;View.measure()&lt;/code&gt;方法时 View 并不是立即就去测量，而是先判断一下要不要进行测量操作，如果没必要，那么 View 就不需要重新测量了，避免浪费时间资源&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;如果需要测量，在测量之前，会先判断是否存在缓存，存在直接从缓存中获取就可以了，再调用一下 &lt;code&gt;setMeasuredDimensionRaw &lt;/code&gt;方法，将从缓存中读到的测量结果保存到成员变量 &lt;code&gt;mMeasuredWidth &lt;/code&gt;和 &lt;code&gt;mMeasuredHeight &lt;/code&gt;中。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;如果不能从 &lt;code&gt;mMeasureCache &lt;/code&gt;中读到缓存过的测量结果，调用 &lt;code&gt;onMeasure() &lt;/code&gt;方法去完成实际的测量工作，并且将尺寸限制条件 &lt;code&gt;widthMeasureSpec &lt;/code&gt;和 &lt;code&gt;heightMeasureSpec &lt;/code&gt;传递给 &lt;code&gt;onMeasure() &lt;/code&gt;方法。关于 &lt;code&gt;onMeasure() &lt;/code&gt;方法，会在下面详细介绍。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;将结果保存到 &lt;code&gt;mMeasuredWidth &lt;/code&gt;和 &lt;code&gt;mMeasuredHeight &lt;/code&gt;这两个成员变量中，同时缓存到成员变量 &lt;code&gt;mMeasureCache &lt;/code&gt;中，以便下次执行 &lt;code&gt;measure() &lt;/code&gt;方法时能够从其中读取缓存值。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;需要说明的是，View 有一个成员变量 &lt;code&gt;mPrivateFlags&lt;/code&gt;，用以保存 View 的各种状态位，在测量开始前，会将其设置为未测量状态，在测量完成后会将其设置为已测量状态。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;DecorView 是 FrameLayout 子类，这时候应该去看 FrameLayout 中的 onMeasure() 方法，代码具体如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; onMeasure(&lt;span&gt;int&lt;/span&gt; widthMeasureSpec, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; heightMeasureSpec) {&lt;br/&gt;&lt;span&gt;　　　　  // 获取子view的个数
        &lt;/span&gt;&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; count =&lt;span&gt; getChildCount();

        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; measureMatchParentChildren =&lt;span&gt;
                MeasureSpec.getMode(widthMeasureSpec) &lt;/span&gt;!= MeasureSpec.EXACTLY ||&lt;span&gt;
                MeasureSpec.getMode(heightMeasureSpec) &lt;/span&gt;!=&lt;span&gt; MeasureSpec.EXACTLY;
        mMatchParentChildren.clear();

        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; maxHeight = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; maxWidth = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; childState = 0&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; count; i++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; View child =&lt;span&gt; getChildAt(i);&lt;br/&gt;&lt;span&gt;　　　　　　　// mMeasureAllChildren 默认为FALSE，表示是否全部子 view 都要测量，子view不为GONE就要测量
            &lt;/span&gt;&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mMeasureAllChildren || child.getVisibility() !=&lt;span&gt; GONE) {&lt;br/&gt;&lt;span&gt;                // 测量子view
&lt;/span&gt;                measureChildWithMargins(child, widthMeasureSpec, &lt;/span&gt;0, heightMeasureSpec, 0&lt;span&gt;);&lt;br/&gt;&lt;span&gt;                // 获取子view的布局参数
                &lt;/span&gt;&lt;/span&gt;&lt;span&gt;final&lt;/span&gt; LayoutParams lp =&lt;span&gt; (LayoutParams) child.getLayoutParams();&lt;br/&gt;&lt;span&gt;                // 记录子view的最大宽度和高度
&lt;/span&gt;                maxWidth &lt;/span&gt;=&lt;span&gt; Math.max(maxWidth,
                        child.getMeasuredWidth() &lt;/span&gt;+ lp.leftMargin +&lt;span&gt; lp.rightMargin);
                maxHeight &lt;/span&gt;=&lt;span&gt; Math.max(maxHeight,
                        child.getMeasuredHeight() &lt;/span&gt;+ lp.topMargin +&lt;span&gt; lp.bottomMargin);
                childState &lt;/span&gt;=&lt;span&gt; combineMeasuredStates(childState, child.getMeasuredState());&lt;br/&gt;&lt;span&gt;                // 记录所有跟父布局有着相同宽或高的子view
                &lt;/span&gt;&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (measureMatchParentChildren) {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (lp.width == LayoutParams.MATCH_PARENT ||&lt;span&gt;
                            lp.height &lt;/span&gt;==&lt;span&gt; LayoutParams.MATCH_PARENT) {
                        mMatchParentChildren.add(child);
                    }
                }
            }
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Account for padding too  子view的最大宽高计算出来后，还要加上父View自身的padding&lt;/span&gt;
        maxWidth += getPaddingLeftWithForeground() +&lt;span&gt; getPaddingRightWithForeground();
        maxHeight &lt;/span&gt;+= getPaddingTopWithForeground() +&lt;span&gt; getPaddingBottomWithForeground();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Check against our minimum height and width&lt;/span&gt;
        maxHeight =&lt;span&gt; Math.max(maxHeight, getSuggestedMinimumHeight());
        maxWidth &lt;/span&gt;=&lt;span&gt; Math.max(maxWidth, getSuggestedMinimumWidth());

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Check against our foreground's minimum height and width&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; Drawable drawable =&lt;span&gt; getForeground();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (drawable != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            maxHeight &lt;/span&gt;=&lt;span&gt; Math.max(maxHeight, drawable.getMinimumHeight());
            maxWidth &lt;/span&gt;=&lt;span&gt; Math.max(maxWidth, drawable.getMinimumWidth());
        }
&lt;span&gt;　　　　　// 确定父 view 的宽高
&lt;/span&gt;        setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState),
                resolveSizeAndState(maxHeight, heightMeasureSpec,
                        childState &lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt; MEASURED_HEIGHT_STATE_SHIFT));

        count &lt;/span&gt;=&lt;span&gt; mMatchParentChildren.size();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (count &amp;gt; 1&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; count; i++&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; View child =&lt;span&gt; mMatchParentChildren.get(i);
                &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; MarginLayoutParams lp =&lt;span&gt; (MarginLayoutParams) child.getLayoutParams();

                &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; childWidthMeasureSpec;&lt;br/&gt;&lt;span&gt;　　　　　　　　　　// 如果子view的宽是MATCH_PARENT,那么宽度 = 父view的宽 - 父Padding - 子Margin
                &lt;/span&gt;&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (lp.width ==&lt;span&gt; LayoutParams.MATCH_PARENT) {
                    &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; width = Math.max(0&lt;span&gt;, getMeasuredWidth()
                            &lt;/span&gt;- getPaddingLeftWithForeground() -&lt;span&gt; getPaddingRightWithForeground()
                            &lt;/span&gt;- lp.leftMargin -&lt;span&gt; lp.rightMargin);
                    childWidthMeasureSpec &lt;/span&gt;=&lt;span&gt; MeasureSpec.makeMeasureSpec(
                            width, MeasureSpec.EXACTLY);
                } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    childWidthMeasureSpec &lt;/span&gt;=&lt;span&gt; getChildMeasureSpec(widthMeasureSpec,
                            getPaddingLeftWithForeground() &lt;/span&gt;+ getPaddingRightWithForeground() +&lt;span&gt;
                            lp.leftMargin &lt;/span&gt;+&lt;span&gt; lp.rightMargin,
                            lp.width);
                }

                &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; childHeightMeasureSpec;&lt;br/&gt;&lt;span&gt;　　　　　　　　　　// 同理
                &lt;/span&gt;&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (lp.height ==&lt;span&gt; LayoutParams.MATCH_PARENT) {
                    &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; height = Math.max(0&lt;span&gt;, getMeasuredHeight()
                            &lt;/span&gt;- getPaddingTopWithForeground() -&lt;span&gt; getPaddingBottomWithForeground()
                            &lt;/span&gt;- lp.topMargin -&lt;span&gt; lp.bottomMargin);
                    childHeightMeasureSpec &lt;/span&gt;=&lt;span&gt; MeasureSpec.makeMeasureSpec(
                            height, MeasureSpec.EXACTLY);
                } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    childHeightMeasureSpec &lt;/span&gt;=&lt;span&gt; getChildMeasureSpec(heightMeasureSpec,
                            getPaddingTopWithForeground() &lt;/span&gt;+ getPaddingBottomWithForeground() +&lt;span&gt;
                            lp.topMargin &lt;/span&gt;+&lt;span&gt; lp.bottomMargin,
                            lp.height);
                }

                child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;FrameLayout 是 ViewGroup 的子类，后者有一个 View[] 类型的成员变量 mChildren，代表了其子 View 集合。通过 getChildAt(i) 能获取指定索引处的子 View，通过 getChildCount() 可以获得子 View 的总数。&lt;/p&gt;
&lt;p&gt;在上面的源码中，首先调用 measureChildWithMargins() 方法对所有子 View 进行了一遍测量，并计算出所有子View的最大宽度和最大高度。而后将得到的最大高度和宽度加上padding，这里的padding包括了父View的padding和前景区域的padding。然后会检查是否设置了最小宽高，并与其比较，将两者中较大的设为最终的最大宽高。最后，若设置了前景图像，我们还要检查前景图像的最小宽高。&lt;/p&gt;
&lt;p&gt;经过了以上一系列步骤后，我们就得到了 maxHeight 和 maxWidth 的最终值，表示当前容器 View 用这个尺寸就能够正常显示其所有子View（同时考虑了 padding 和 margin ）。而后我们需要调用 resolveSizeAndState() 方法来结合传来的 MeasureSpec 来获取最终的测量宽高，并保存到 mMeasuredWidth 与 mMeasuredHeight 成员变量中。&lt;/p&gt;
&lt;p&gt;如果存在一些子 View 的宽或高是 MATCH_PARENT，那么需要等父 View 的尺寸计算出来后，再来决定这些子 view 的宽高。&lt;/p&gt;
&lt;p&gt;下面看看 measureChildWithMargins() 方法具体逻辑：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Ask one of the children of this view to measure itself, taking into
     * account both the MeasureSpec requirements for this view and its padding
     * and margins. The child must have MarginLayoutParams The heavy lifting is
     * done in getChildMeasureSpec.
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; child The child to measure
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; parentWidthMeasureSpec The width requirements for this view
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; widthUsed Extra space that has been used up by the parent
     *        horizontally (possibly by other children of the parent)
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; parentHeightMeasureSpec The height requirements for this view
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; heightUsed Extra space that has been used up by the parent
     *        vertically (possibly by other children of the parent)
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; measureChildWithMargins(View child,
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; parentWidthMeasureSpec, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; widthUsed,
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; parentHeightMeasureSpec, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; heightUsed) {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; MarginLayoutParams lp =&lt;span&gt; (MarginLayoutParams) child.getLayoutParams();

        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; childWidthMeasureSpec =&lt;span&gt; getChildMeasureSpec(parentWidthMeasureSpec,
                mPaddingLeft &lt;/span&gt;+ mPaddingRight + lp.leftMargin +&lt;span&gt; lp.rightMargin
                        &lt;/span&gt;+&lt;span&gt; widthUsed, lp.width);
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; childHeightMeasureSpec =&lt;span&gt; getChildMeasureSpec(parentHeightMeasureSpec,
                mPaddingTop &lt;/span&gt;+ mPaddingBottom + lp.topMargin +&lt;span&gt; lp.bottomMargin
                        &lt;/span&gt;+&lt;span&gt; heightUsed, lp.height);

        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 该方法主要是获取子 view 的 MeasureSpec，然后调用 child.measure() 来完成子 View 的测量。下面看看子 View 获取 MeasureSpec 的具体逻辑：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; getChildMeasureSpec(&lt;span&gt;int&lt;/span&gt; spec, &lt;span&gt;int&lt;/span&gt; padding, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; childDimension) {&lt;br/&gt;&lt;span&gt;        // 父 view 的 mode 和 size
        &lt;/span&gt;&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; specMode =&lt;span&gt; MeasureSpec.getMode(spec);
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; specSize =&lt;span&gt; MeasureSpec.getSize(spec);
&lt;span&gt;　　　　　// 去掉 padding
        &lt;/span&gt;&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; size = Math.max(0, specSize -&lt;span&gt; padding);

        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; resultSize = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; resultMode = 0&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (specMode) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Parent has imposed an exact size on us&lt;/span&gt;
        &lt;span&gt;case&lt;/span&gt;&lt;span&gt; MeasureSpec.EXACTLY:
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (childDimension &amp;gt;= 0&lt;span&gt;) {
                resultSize &lt;/span&gt;=&lt;span&gt; childDimension;
                resultMode &lt;/span&gt;=&lt;span&gt; MeasureSpec.EXACTLY;
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (childDimension ==&lt;span&gt; LayoutParams.MATCH_PARENT) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Child wants to be our size. So be it.&lt;/span&gt;
                resultSize =&lt;span&gt; size;
                resultMode &lt;/span&gt;=&lt;span&gt; MeasureSpec.EXACTLY;
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (childDimension ==&lt;span&gt; LayoutParams.WRAP_CONTENT) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Child wants to determine its own size. It can't be
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; bigger than us.&lt;/span&gt;
                resultSize =&lt;span&gt; size;
                resultMode &lt;/span&gt;=&lt;span&gt; MeasureSpec.AT_MOST;
            }
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Parent has imposed a maximum size on us&lt;/span&gt;
        &lt;span&gt;case&lt;/span&gt;&lt;span&gt; MeasureSpec.AT_MOST:
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (childDimension &amp;gt;= 0&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Child wants a specific size... so be it&lt;/span&gt;
                resultSize =&lt;span&gt; childDimension;
                resultMode &lt;/span&gt;=&lt;span&gt; MeasureSpec.EXACTLY;
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (childDimension ==&lt;span&gt; LayoutParams.MATCH_PARENT) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Child wants to be our size, but our size is not fixed.
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Constrain child to not be bigger than us.&lt;/span&gt;
                resultSize =&lt;span&gt; size;
                resultMode &lt;/span&gt;=&lt;span&gt; MeasureSpec.AT_MOST;
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (childDimension ==&lt;span&gt; LayoutParams.WRAP_CONTENT) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Child wants to determine its own size. It can't be
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; bigger than us.&lt;/span&gt;
                resultSize =&lt;span&gt; size;
                resultMode &lt;/span&gt;=&lt;span&gt; MeasureSpec.AT_MOST;
            }
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Parent asked to see how big we want to be&lt;/span&gt;
        &lt;span&gt;case&lt;/span&gt;&lt;span&gt; MeasureSpec.UNSPECIFIED:
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (childDimension &amp;gt;= 0&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Child wants a specific size... let him have it&lt;/span&gt;
                resultSize =&lt;span&gt; childDimension;
                resultMode &lt;/span&gt;=&lt;span&gt; MeasureSpec.EXACTLY;
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (childDimension ==&lt;span&gt; LayoutParams.MATCH_PARENT) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Child wants to be our size... find out how big it should
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; be&lt;/span&gt;
                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0&lt;span&gt; : size;
                resultMode &lt;/span&gt;=&lt;span&gt; MeasureSpec.UNSPECIFIED;
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (childDimension ==&lt;span&gt; LayoutParams.WRAP_CONTENT) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Child wants to determine its own size.... find out how
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; big it should be&lt;/span&gt;
                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0&lt;span&gt; : size;
                resultMode &lt;/span&gt;=&lt;span&gt; MeasureSpec.UNSPECIFIED;
            }
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;noinspection ResourceType&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; MeasureSpec.makeMeasureSpec(resultSize, resultMode);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;code&gt;该&lt;/code&gt;方法清楚展示了普通 View 的 MeasureSpec 的创建规则，每个 View 的 MeasureSpec 状态量由其直接父 View 的 MeasureSpec 和 View 自身的属性 LayoutParams （LayoutParams 有宽高尺寸值等信息）共同决定。&lt;/p&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div readability=&quot;8&quot;&gt;从上面的代码可以知道，返回 View 的 MeasureSpec 大致可以分为一下机制情况：
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;子 View 为&lt;code&gt;具体的宽/高&lt;/code&gt;，那么 View 的 MeasureSpec 都为 LayoutParams 中大小。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;子 View 为 &lt;code&gt;match_parent&lt;/code&gt;，父元素为精度模式(EXACTLY)，那么 View 的 MeasureSpec 也是精准模式他的大小不会超过父容器的剩余空间。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;子 View 为 &lt;code&gt;wrap_content&lt;/code&gt;，不管父元素是精准模式还是最大化模式(AT_MOST)，View 的 MeasureSpec 总是为最大化模式并且大小不超过父容器的剩余空间。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;父容器为 UNSPECIFIED 模式主要用于系统多次 Measure 的情形，一般我们不需要关心。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;总结为下表:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/916005/201911/916005-20191124132031968-549108072.png&quot; alt=&quot;&quot; width=&quot;539&quot; height=&quot;191&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; View.measure()  代码逻辑前面已经分析过了，最终会调用 onMeasuere 方法，下面看下 View.onMeasuere() 的代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; onMeasure(&lt;span&gt;int&lt;/span&gt; widthMeasureSpec, &lt;span&gt;int&lt;/span&gt; heightMeasureSpec) {
        setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),
                getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;上面方法中调用了 方法中调用了 &lt;code&gt;setMeasuredDimension()&lt;/code&gt;方法，&lt;code&gt;setMeasuredDimension()&lt;/code&gt;又调用了 &lt;code&gt;getDefaultSize() &lt;/code&gt;方法。&lt;code&gt;getDefaultSize() &lt;/code&gt;又调用了&lt;code&gt;getSuggestedMinimumWidth()&lt;/code&gt;和 &lt;code&gt;getSuggestedMinimumHeight()，&lt;/code&gt;那反向研究一下，先看下 &lt;code&gt;getSuggestedMinimumWidth() &lt;/code&gt;方法  (&lt;code&gt;getSuggestedMinimumHeight() &lt;/code&gt;原理 &lt;code&gt;getSuggestedMinimumWidth() &lt;/code&gt;跟一样)。 &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getSuggestedMinimumWidth() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (mBackground == &lt;span&gt;null&lt;/span&gt;) ?&lt;span&gt; mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 源码很简单,如果 View 没有背景,就直接返回 View 本身的最小宽度 &lt;code&gt;mMinWidth；&lt;/code&gt;如果给 View 设置了背景,就取 View 本身的最小宽度 &lt;code&gt;mMinWidth &lt;/code&gt;和背景的最小宽度的最大值.&lt;/p&gt;
&lt;p&gt;那么 &lt;code&gt;mMinWidth &lt;/code&gt;是哪里来的？搜索下源码就可以知道，View 的最小宽度 &lt;code&gt;mMinWidth &lt;/code&gt;可以有两种方式进行设置：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;第一种是在 View 的构造方法中进行赋值的，View 通过读取 XML 文件中View设置的 &lt;code&gt;minWidth &lt;/code&gt;属性来为 &lt;code&gt;mMinWidth &lt;/code&gt;赋值&lt;/span&gt;：&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;hljs-ln-numbers&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;case&lt;/span&gt;&lt;span&gt; R.styleable.View_minWidth:
     mMinWidth &lt;/span&gt;= a.getDimensionPixelSize(attr, 0&lt;span&gt;);
     &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt; 第二种是在调用 View 的 &lt;code&gt;setMinimumWidth &lt;/code&gt;方法为 &lt;code&gt;mMinWidth &lt;/code&gt;赋值&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setMinimumWidth(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; minWidth) {
    mMinWidth &lt;/span&gt;=&lt;span&gt; minWidth;
    requestLayout();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 下面看下 getDefaultSize() 的代码逻辑：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; getDefaultSize(&lt;span&gt;int&lt;/span&gt; size, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; measureSpec) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; result =&lt;span&gt; size;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; specMode =&lt;span&gt; MeasureSpec.getMode(measureSpec);
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; specSize =&lt;span&gt; MeasureSpec.getSize(measureSpec);

        &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (specMode) {
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; MeasureSpec.UNSPECIFIED:
            result &lt;/span&gt;=&lt;span&gt; size;
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; MeasureSpec.AT_MOST:
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; MeasureSpec.EXACTLY:
            result &lt;/span&gt;=&lt;span&gt; specSize;
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;从注释可以看&lt;/span&gt;&lt;span&gt;出，&lt;code&gt;getDefaultSize()&lt;/code&gt;这个测量方法并没有适配 &lt;code&gt;wrap_content &lt;/code&gt;这一种布局模式，只是简单地将 &lt;code&gt;wrap_content &lt;/code&gt;跟 &lt;code&gt;match_parent &lt;/code&gt;等同起来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;到了这里，我们要注意一个问题：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;code&gt;getDef&lt;span&gt;aultSize()&lt;/span&gt;&lt;/code&gt;&lt;span&gt;方法中 &lt;code&gt;wrap_content &lt;/code&gt;和 &lt;code&gt;match_parent &lt;/code&gt;属性的效果是一样的，而该方法是 View 的 &lt;code&gt;onMeasure()&lt;/code&gt;中默认调用的，也就是说，对于一个直接继承自 View 的自定义 View 来说，它的 wrap_content 和 match_parent 属性是一样的效果，因此如果要实现自定义 View 的 &lt;code&gt;wrap_content&lt;/code&gt;，则要重写 &lt;code&gt;onMeasure() &lt;/code&gt;方法，对 &lt;code&gt;wrap_content &lt;/code&gt;属性进行处理。&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;如何处理呢？也很简单，代码如下所示：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; onMeasure(&lt;span&gt;int&lt;/span&gt; widthMeasureSpec, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; heightMeasureSpec){
  &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onMeasure(widthMeasureSpec, heightMeasureSpec);
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取得父ViewGroup指定的宽高测量模式和尺寸&lt;/span&gt;
  &lt;span&gt;int&lt;/span&gt; widthSpecMode =&lt;span&gt; MeasureSpec.getMode(widthMeasureSpec);
  &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; widthSpecSize =&lt;span&gt; MeasureSpec.getSize(widthMeasureSpec);
  &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; heightSpecMode =&lt;span&gt; MeasureSpec.getMode(heightMeasureSpec);
  &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; heightSpecSize =&lt;span&gt; MeasureSpec.getSize(heightMeasureSpec);
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (widthSpecMode == MeasureSpec.AT_MOST &amp;amp;&amp;amp; heightSpecMode ==&lt;span&gt; MeasureSpec.AT_MOST) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果宽高都是AT_MOST的话，即都是wrap_content布局模式，就用View自己想要的宽高值&lt;/span&gt;
&lt;span&gt;        setMeasuredDimension(mWidth, mHeight);
  }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (widthSpecMode ==&lt;span&gt; MeasureSpec.AT_MOST) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果只有宽度都是AT_MOST的话，即只有宽度是wrap_content布局模式，宽度就用View自己想要的宽度值，高度就用父ViewGroup指定的高度值&lt;/span&gt;
&lt;span&gt;        setMeasuredDimension(mWidth, heightSpecSize);
  }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (heightSpecMode ==&lt;span&gt; MeasureSpec.AT_MOST) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果只有高度都是AT_MOST的话，即只有高度是wrap_content布局模式，高度就用View自己想要的宽度值，宽度就用父ViewGroup指定的高度值&lt;/span&gt;
&lt;span&gt;        setMeasuredDimension(widthSpecSize, mHeight);
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 在上面的代码中，我们要给 View 指定一个默认的内部宽/高（&lt;code&gt;mWidth &lt;/code&gt;和 &lt;code&gt;mHeight&lt;/code&gt;），并在 &lt;code&gt;wrap_content &lt;/code&gt;时设置此宽/高即可。最后将在将宽高设置到 View 上：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    //&lt;/span&gt;&lt;span&gt; View    &lt;/span&gt;
&lt;span&gt;    protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setMeasuredDimension(&lt;span&gt;int&lt;/span&gt; measuredWidth, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; measuredHeight) {
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; optical = isLayoutModeOptical(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (optical !=&lt;span&gt; isLayoutModeOptical(mParent)) {
            Insets insets &lt;/span&gt;=&lt;span&gt; getOpticalInsets();
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; opticalWidth  = insets.left +&lt;span&gt; insets.right;
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; opticalHeight = insets.top  +&lt;span&gt; insets.bottom;
 
            measuredWidth  &lt;/span&gt;+= optical ? opticalWidth  : -&lt;span&gt;opticalWidth;
            measuredHeight &lt;/span&gt;+= optical ? opticalHeight : -&lt;span&gt;opticalHeight;
        }
        setMeasuredDimensionRaw(measuredWidth, measuredHeight);
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setMeasuredDimensionRaw(&lt;span&gt;int&lt;/span&gt; measuredWidth, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; measuredHeight) {
        mMeasuredWidth &lt;/span&gt;=&lt;span&gt; measuredWidth;
        mMeasuredHeight &lt;/span&gt;=&lt;span&gt; measuredHeight;
        mPrivateFlags &lt;/span&gt;|=&lt;span&gt; PFLAG_MEASURED_DIMENSION_SET;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这里就是把测量完的宽高值赋值给 &lt;code&gt;mMeasuredWidth&lt;/code&gt;、&lt;code&gt;mMeasuredHeight &lt;/code&gt;这两个 View 的属性，然后将标志位置为已测量状态。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;子 View 测量完成以后，会计算 childState，看下 combineMeasuredStates 方法 ：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; combineMeasuredStates(&lt;span&gt;int&lt;/span&gt; curState, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; newState) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; curState |&lt;span&gt; newState;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 当前 curState 为 0， newState 是调用 child.getMeasuredState() 方法得到的，来看下这个方法的具体逻辑：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Return only the state bits of {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #getMeasuredWidthAndState()}
     * and {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #getMeasuredHeightAndState()}, combined into one integer.
     * The width component is in the regular bits {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #MEASURED_STATE_MASK}
     * and the height component is at the shifted bits
     * {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #MEASURED_HEIGHT_STATE_SHIFT}&amp;gt;&amp;gt;{&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #MEASURED_STATE_MASK}.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getMeasuredState() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (mMeasuredWidth&amp;amp;&lt;span&gt;MEASURED_STATE_MASK)
                &lt;/span&gt;| ((mMeasuredHeight&amp;gt;&amp;gt;&lt;span&gt;MEASURED_HEIGHT_STATE_SHIFT)
                        &lt;/span&gt;&amp;amp; (MEASURED_STATE_MASK&amp;gt;&amp;gt;&lt;span&gt;MEASURED_HEIGHT_STATE_SHIFT));
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 该方法返回一个 int 值，该值同时包含宽度的 state 以及高度的 state 信息，不包含任何的尺寸信息。&lt;/p&gt;
&lt;ul readability=&quot;5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;MEASURED_STATE_MASK&lt;/strong&gt; 的值为 &lt;strong&gt;0xff000000&lt;/strong&gt;，其高字节的 8 位全部为 1，低字节的 24 位全部为 0。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;MEASURED_HEIGHT_STATE_SHIFT&lt;/strong&gt; 值为 16。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;将 &lt;strong&gt;MEASURED_STATE_MASK&lt;/strong&gt; 与 &lt;code&gt;&lt;strong&gt;mMeasuredWidth&lt;/strong&gt; &lt;/code&gt;做与操作之后就取出了存储在宽度首字节中的 state 信息，过滤掉低位三个字节的尺寸信息。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;span&gt;由于 int 有四个字节，首字节已经存了宽度的 state 信息，那么高度的 &lt;strong&gt;state&lt;/strong&gt; 信息就不能存在首位字节。&lt;strong&gt;MEASURED_STATE_MASK&lt;/strong&gt; 向右移 16 位，变成了 &lt;strong&gt;0x0000ff00&lt;/strong&gt;，这个值与高度值 &lt;code&gt;&lt;strong&gt;mMeasuredHeight&lt;/strong&gt; &lt;/code&gt;做与操作就取出了 &lt;code&gt;&lt;strong&gt;mMeasuredHeight&lt;/strong&gt; &lt;/code&gt;第三个字节中的信息。而 &lt;code&gt;&lt;strong&gt;mMeasuredHeight&lt;/strong&gt; &lt;/code&gt;的 state 信息是存在首字节中，所以也得对&lt;code&gt;&lt;strong&gt;mMeasuredHeight&lt;/strong&gt; &lt;/code&gt;向右移相同的位置，这样就把 state 信息移到了第三个字节中。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;最后，将得到的宽度 &lt;strong&gt;state&lt;/strong&gt; 与高度 state 按位或操作，这样就拼接成一个 int 值，该值首个字节存储宽度的 &lt;strong&gt;state&lt;/strong&gt; 信息，第三个字节存储高度的 state 信息。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这些都得到之后，就可以开始去计算父 View 的尺寸了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;        //&lt;/span&gt;&lt;span&gt; 确定父 View 的宽高&lt;/span&gt;
&lt;span&gt;&lt;span&gt;        setMeasuredDimension&lt;/span&gt;(&lt;span&gt;resolveSizeAndState&lt;/span&gt;(maxWidth, widthMeasureSpec, childState),
                &lt;span&gt;resolveSizeAndState&lt;/span&gt;(maxHeight, heightMeasureSpec,
                        childState &lt;/span&gt;&amp;lt;&amp;lt; MEASURED_HEIGHT_STATE_SHIFT));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 下面开始看 resolveSizeAndState 具体逻辑：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; View 的静态方法&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; resolveSizeAndState(&lt;span&gt;int&lt;/span&gt; size, &lt;span&gt;int&lt;/span&gt; measureSpec, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; childMeasuredState) {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; specMode =&lt;span&gt; MeasureSpec.getMode(measureSpec);
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; specSize =&lt;span&gt; MeasureSpec.getSize(measureSpec);
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; result;
        &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (specMode) {
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; MeasureSpec.AT_MOST:
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (specSize &amp;lt;&lt;span&gt; size) {
                    result &lt;/span&gt;= specSize |&lt;span&gt; MEASURED_STATE_TOO_SMALL;
                } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    result &lt;/span&gt;=&lt;span&gt; size;
                }
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; MeasureSpec.EXACTLY:
                result &lt;/span&gt;=&lt;span&gt; specSize;
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; MeasureSpec.UNSPECIFIED:
            &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
                result &lt;/span&gt;=&lt;span&gt; size;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; result | (childMeasuredState &amp;amp;&lt;span&gt; MEASURED_STATE_MASK);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这个方法的代码结构跟前文提到的 &lt;code&gt;getDefaultSize()&lt;/code&gt;方法很相似，主要的区别在于 &lt;code&gt;specMode &lt;/code&gt;为 AT_MOST 的情况。我们当时说 &lt;code&gt;getDefaultSize() &lt;/code&gt;方法是没有适配&lt;code&gt;wrap_content &lt;/code&gt;这种情况，而这个 &lt;code&gt;resolveSizeAndState() &lt;/code&gt;方法是已经适配了 &lt;code&gt;wrap_content &lt;/code&gt;的布局方式，那具体怎么实现 AT_MOST 测量逻辑的呢？有两种情况：&lt;/span&gt;&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;span&gt;当父 ViewGroup 指定的最大尺寸比 View 想要的尺寸还要小时，会给这个父 ViewGroup  的指定的最大值 &lt;code&gt;specSize &lt;/code&gt;加入一个尺寸太小的标志  MEASURED_STATE_TOO_SMALL，然后将这个带有标志的尺寸返回，父 ViewGroup 通过该标志就可以知道分配给 View 的空间太小了，在窗口协商测量的时候会根据这个标志位来做窗口大小的决策。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;当父 ViewGroup 指定的最大尺寸比没有比 View 想要的尺寸小时（相等或者 View 想要的尺寸更小），直接取 View 想要的尺寸，然后返回该尺寸。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;code&gt;getDefaultSize() &lt;/code&gt;方法只是 &lt;code&gt;onMeasure() &lt;/code&gt;方法中获取最终尺寸的默认实现，其返回的信息比 &lt;code&gt;resolveSizeAndState() &lt;/code&gt;要少，那么什么时候才会调用 &lt;code&gt;resolveSizeAndState() &lt;/code&gt;方法呢？ 主要有两种情况：&lt;/span&gt;&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;Android 中的大部分 ViewGroup 类都调用了 &lt;code&gt;resolveSizeAndState() &lt;/code&gt;方法，比如 LinearLayout 在测量过程中会调用 &lt;code&gt;resolveSizeAndState() &lt;/code&gt;方法而非 &lt;code&gt;getDefaultSize()&lt;/code&gt;方法。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;我们自己在实现自定义的 View 或 ViewGroup 时，我们可以重写 &lt;code&gt;onMeasure() &lt;/code&gt;方法，并在该方法内调用 &lt;code&gt;resolveSizeAndState() &lt;/code&gt;方法。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;到此，终于把 View 测量过程讲完了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;下一篇开始讲 View 的 layout 和 draw 过程。&lt;/p&gt;

&lt;h2&gt;参考文章&lt;/h2&gt;
&lt;h3 class=&quot;title-article&quot;&gt;&lt;a href=&quot;https://blog.csdn.net/renhaijuniryfe/article/details/88977258&quot; target=&quot;_blank&quot;&gt;Android源码完全解析——View的Measure过程&lt;/a&gt;&lt;/h3&gt;

</description>
<pubDate>Sat, 30 Nov 2019 15:40:00 +0000</pubDate>
<dc:creator>huansky</dc:creator>
<og:description>概述 上一篇&amp;#160;Android DecorView 与 Activity 绑定原理分析&amp;#160;分析了在调用 setContentView 之后，DecorView 是如何与 activit</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/huansky/p/11920454.html</dc:identifier>
</item>
<item>
<title>Redis系列（三）：Redis集群的水平扩展与伸缩 - toby.xu</title>
<link>http://www.cnblogs.com/toby-xu/p/11964409.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/toby-xu/p/11964409.html</guid>
<description>&lt;h2&gt;一、Redis集群的水平扩展&lt;/h2&gt;
&lt;p&gt;　　Redis3.0版本以后，有了集群的功能，提供了比之前版本的哨兵模式更高的性能与可用性，但是集群的水平扩展却比较麻烦，接下来介绍下Redis高可用集群如何做水平扩展，在原集群的6个节点的基础上新增2个节点，由原来的3主3从变成4主4从，原先的3主3从部署详见&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/toby-xu/p/11960971.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;Redis系列（二）：Redis高可用集群&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1761778/201911/1761778-20191130214226682-1980179140.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt; 二、水平扩展具体操作&lt;/h2&gt;
&lt;p&gt;　　&lt;strong&gt;①&lt;/strong&gt; 将redis-5.0.2文件夹拷贝到新的主机192.168.160.154上去，（1）scp -r /usr/local/redis-5.0.2 root@192.168.160.154:/usr/local/ 进去到192.168.160.154主机 （2）cd /usr/local&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1761778/201911/1761778-20191130214918005-1447892361.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;strong&gt;②&lt;/strong&gt; 新启动2个redis实例，然后检查是否启动成功 （1）/usr/local/redis-5.0.2/bin/redis-server /usr/local/redis-5.0.2/redis-cluster/700*/redis.conf （2）ps -ef | grep redis 查看是否启动成功&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1761778/201911/1761778-20191130215134054-1330767141.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;strong&gt;③ &lt;/strong&gt;查看redis集群的命令帮助 （1）cd /usr/local/redis-5.0.2 （2）bin/redis-cli --cluster help&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1761778/201911/1761778-20191130215603942-1845745274.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;create：创建一个集群host1:port1 ... hostN:portN
call：可以执行redis命令
add&lt;/span&gt;-&lt;span&gt;node：将一个节点添加到集群里，第一个参数为新节点的ip:port，第二个参数为集群中任意一个已经存在的节点的ip:port
del&lt;/span&gt;-&lt;span&gt;node：移除一个节点
reshard：重新分片
check：检查集群状态&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;strong&gt;④ &lt;/strong&gt;使用add-node命令新增一个主节点192.168.160.154:7001(master)，前面的ip:port为新增节点，后面的ip:port为集群中已存在节点（1）/usr/local/redis-5.0.2/bin/redis-cli --cluster add-node 192.168.160.154:7001 192.168.160.146:7001&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1761778/201911/1761778-20191130221134601-397950265.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;strong&gt;⑤&lt;/strong&gt;（1）连接任意一个客户端即可：./redis-cli -c -h -p (-a访问服务端密码，-c表示集群模式，指定ip地址和端口号）如：/usr/local/redis-5.0.2/bin/redis-cli -c -h 192.168.160.146 -p 700* （2）进行验证： cluster info（查看集群信息）、cluster nodes（查看节点列表）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1761778/201911/1761778-20191130222402254-36775487.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;strong&gt;⑥&lt;/strong&gt; 使用redis-cli命令为192.168.160.154:7001分配slots槽位，找到集群中的任意一个主节点，对其进行重新分片工作。（1）/usr/local/redis-5.0.2/bin/redis-cli --cluster reshard 192.168.160.146:7001&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
How many slots &lt;span&gt;do&lt;/span&gt; you want to move (from 1 to 16384)? 4000&lt;span&gt;
(ps:需要多少个槽移动到新的节点上，自己设置，比如4000个hash槽)
What is the receiving node ID&lt;/span&gt;?&lt;span&gt; 44b0bd6cf056af7dbbfa0dd9497def1cfc21eb6d
(ps:把这4000个hash槽移动到哪个节点上去，需要指定节点id)
Please enter all the source node IDs.
Type &lt;/span&gt;'all' to use all the nodes as source nodes &lt;span&gt;for&lt;/span&gt;&lt;span&gt; the hash slots.
Type &lt;/span&gt;'done'&lt;span&gt; once you entered all the source nodes IDs.
Source node &lt;/span&gt;1&lt;span&gt;:all
(ps:输入all为从所有主节点中分别抽取相应的槽数指定到新节点中，抽取的总槽数为4000个;或者输入原节点ID然后输入done，意思将输入的节点ID，抽取的总槽数为4000个)
Do you want to proceed with the proposed reshard plan (yes&lt;/span&gt;/no)?&lt;span&gt; yes
(ps:输入yes确认开始执行分片任务)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;strong&gt;⑦ &lt;/strong&gt;查看下最新的集群状态&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1761778/201911/1761778-20191130224505251-707888360.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;strong&gt;⑧&lt;/strong&gt; 添加从节点192.168.160.154:7002到集群中去并查看集群状态&lt;/p&gt;
&lt;p&gt;　　（1）/usr/local/redis-5.0.2/bin/redis-cli --cluster add-node 192.168.160.154:7002 192.168.160.146:7001&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1761778/201911/1761778-20191130224724934-1437715629.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　（2）cluster nodes&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1761778/201911/1761778-20191130224804207-886172845.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　（3）如上图所示，还是一个master节点，没有被分配任何的hash槽。我们需要执行replicate命令来指定当前节点(从节点)的主节点id为哪个,首先需要连接新加的192.168.160.154:7002节点的客户端，然后使用集群命令进行操作，把当前的192.168.160.154:7002(slave)节点指定到一个主节点下(这里使用之前创建的192.168.160.154:7001主节点)&lt;/p&gt;
&lt;p&gt;　　（3-1）/usr/local/redis-5.0.2/bin/redis-cli -c -h 192.168.160.154 -p 7002&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1761778/201911/1761778-20191130225435484-206846418.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　（3-2）cluster replicate 44b0bd6cf056af7dbbfa0dd9497def1cfc21eb6d #后面这串id为192.168.160.154:7001的节点id&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1761778/201911/1761778-20191130225706634-1972451892.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　（3-2）cluster nodes&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1761778/201911/1761778-20191130225743838-979759253.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt; 三、水平伸缩具体操作&lt;/h2&gt;
&lt;p&gt;　　目的还原成原始集群，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1761778/201911/1761778-20191130231115497-861253827.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;strong&gt;①&lt;/strong&gt; 删除192.168.160.154:7002从节点，用del-node删除从节点192.168.160.154:7002，指定删除节点ip和端口，以及节点id(192.168.160.154:7002节点id) &lt;/p&gt;
&lt;p&gt;　　（1）/usr/local/redis-5.0.2/bin/redis-cli --cluster del-node 192.168.160.154:7002 564963541c243365cbb20aed69e98048d21d68fd&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1761778/201911/1761778-20191130231451108-2058158341.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　（2）cluster nodes&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1761778/201911/1761778-20191130231600761-1443151188.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;strong&gt;②&lt;/strong&gt; 删除192.168.160.154:7001主节点，这个步骤相对麻烦一些，因为主节点的里面是有分配了slots槽位，所以必须先把192.168.160.154:7001里的slots槽位放入到其他的可用主节点中去，然后再进行移除节点操作，不然会出现数据丢失问题(目前只能把master的数据迁移到一个节点上，暂时做不了平均分配功能)&lt;/p&gt;
&lt;p&gt;　　（1）/usr/local/redis-5.0.2/bin/redis-cli --cluster reshard 192.168.160.154:7001&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
How many slots &lt;span&gt;do&lt;/span&gt; you want to move (from 1 to 16384)? 4000&lt;span&gt;
(ps:需要多少个槽移动到新的节点上，自己设置，比如4000个hash槽)
What is the receiving node ID&lt;/span&gt;?&lt;span&gt; e7f80ba80749904838b6d779a0646e7f22313624
(ps:把这4000个hash槽移动到哪个节点上去，需要指定节点id)
Please enter all the source node IDs.
Type &lt;/span&gt;'all' to use all the nodes as source nodes &lt;span&gt;for&lt;/span&gt;&lt;span&gt; the hash slots.
Type &lt;/span&gt;'done'&lt;span&gt; once you entered all the source nodes IDs.
Source node &lt;/span&gt;1&lt;span&gt;:44b0bd6cf056af7dbbfa0dd9497def1cfc21eb6d
Source node &lt;/span&gt;1&lt;span&gt;:done
(ps:输入all为从所有主节点中分别抽取相应的槽数指定到新节点中，抽取的总槽数为4000个;或者输入原节点ID然后输入done，意思将输入的节点ID，抽取的总槽数为4000个)
Do you want to proceed with the proposed reshard plan (yes&lt;/span&gt;/no)?&lt;span&gt; yes
(ps:输入yes确认开始执行分片任务)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　（2）cluster nodes 已经成功的把192.168.160.154:7001主节点的数据迁移到192.168.160.146:7001上去了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1761778/201911/1761778-20191130232447904-1139465162.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　　（3）最后我们直接使用del-node命令删除192.168.160.154:7001主节点即可&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1761778/201911/1761778-20191130232710101-1151147311.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　（4）最后执行cluster nodes&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1761778/201911/1761778-20191130232749682-939056987.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 30 Nov 2019 15:31:00 +0000</pubDate>
<dc:creator>toby.xu</dc:creator>
<og:description>一、Redis集群的水平扩展 Redis3.0版本以后，有了集群的功能，提供了比之前版本的哨兵模式更高的性能与可用性，但是集群的水平扩展却比较麻烦，接下来介绍下Redis高可用集群如何做水平扩展，在原</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/toby-xu/p/11964409.html</dc:identifier>
</item>
<item>
<title>动态规划--矿工挖矿 - 西西嘛呦</title>
<link>http://www.cnblogs.com/xiximayou/p/11964509.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiximayou/p/11964509.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;动态规划三要素：边界、最优子问题、状态转移方程；&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;问题描述：现有10个矿工，5个金矿，每个金矿有对应金子和需要开采的人数，问你最多能够获得多少金子？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1503039/201911/1503039-20191130222520707-1175905293.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是一个典型的动态规划问题，动态规划的核心是如何将问题转换为重叠的子问题，并且写出状态转移方程。&lt;/p&gt;
&lt;p&gt;首先我们定义相应的参数：&lt;/p&gt;
&lt;p&gt;矿工个数：n=10&lt;/p&gt;
&lt;p&gt;金矿个数：w=5&lt;/p&gt;
&lt;p&gt;金子数量：g=[400,500,200,300,350]&lt;/p&gt;
&lt;p&gt;需要人数：p=[5,5,3,4,4]&lt;/p&gt;
&lt;p&gt;p[i]代表挖了第i个金矿所需人数，g[i]代表挖了第 i个金矿得到的金子数。令F(n,w)表示n个人挖w个金矿能够得到的最大金子数。&lt;/p&gt;
&lt;p&gt;当n&amp;lt;p[i]时，也就是说挖第i个金矿的人数不够，那么此时可以获得的最大金子数就是挖第i-1个金矿时的金子：&lt;/p&gt;
&lt;p&gt;F(n,w)=F(n,w-1)&lt;/p&gt;
&lt;p&gt;那么我们当n&amp;gt;p[i]时，有以下方程：&lt;/p&gt;
&lt;p&gt;F(n,w)=max(F(n,w-1),F(n-p[i],w-1)+g[i])&lt;/p&gt;

&lt;p&gt;表示n个人挖w个金矿能够得到的最大金子数=最大值(n个人挖w-1个金矿，((n-p[i])个人挖w-1个金矿)+g[i]))&lt;/p&gt;
&lt;p&gt;最终代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
n=10&lt;span&gt;
w&lt;/span&gt;=5&lt;span&gt;
g&lt;/span&gt;=[400,500,200,300,350&lt;span&gt;]
p&lt;/span&gt;=[5,5,3,4,3&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; goldMining(n,w,g,p):
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;初始化数组，用于存储信息，注意为了更好计算，共有11列，第一列作为辅助位&lt;/span&gt;
    dp = [[0 &lt;span&gt;for&lt;/span&gt; _ &lt;span&gt;in&lt;/span&gt; range(n+1)] &lt;span&gt;for&lt;/span&gt; _ &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(w)]
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;边界就是10个人只挖第1个金矿&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;[0, 0, 0, 0, 0, 400, 400, 400, 400, 400, 400]&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(1,n+1&lt;span&gt;):
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; i&amp;lt;&lt;span&gt;p[0]:
            dp[0][i]&lt;/span&gt;=&lt;span&gt;0
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            dp[0][i]&lt;/span&gt;=&lt;span&gt;g[0]
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;依次遍历金矿，人数&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(1&lt;span&gt;,w):
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; j &lt;span&gt;in&lt;/span&gt; range(1,n+1&lt;span&gt;):
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;如果当前人数小于挖这座金矿的人数&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; j&amp;lt;&lt;span&gt;p[i]:
                &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;则当前最大金矿就是挖前一个金矿的相应人数的值&lt;/span&gt;
                dp[i][j]=dp[i-1&lt;span&gt;][j]
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;否则就用如下公式计算&lt;/span&gt;
                dp[i][j]=max(dp[i-1][j],dp[i-1][j-p[i]]+&lt;span&gt;g[i])
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; dp

dp&lt;/span&gt;=&lt;span&gt;goldMining(n,w,g,p)
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(len(dp)):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(dp[i])
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最终结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1503039/201911/1503039-20191130231629960-1868807653.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;可以看到，我们最终可以获得的最大金子数是900，也就是挖第一个和第二个金矿。 &lt;/p&gt;
</description>
<pubDate>Sat, 30 Nov 2019 15:21:00 +0000</pubDate>
<dc:creator>西西嘛呦</dc:creator>
<og:description>动态规划三要素：边界、最优子问题、状态转移方程； 问题描述：现有10个矿工，5个金矿，每个金矿有对应金子和需要开采的人数，问你最多能够获得多少金子？ 这是一个典型的动态规划问题，动态规划的核心是如何将</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiximayou/p/11964509.html</dc:identifier>
</item>
<item>
<title>实现自定义的参数解析器——HandlerMethodArgumentResolver - 白露非霜</title>
<link>http://www.cnblogs.com/nijunyang/p/11964399.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nijunyang/p/11964399.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1.为什么需要自己实现参数解析器&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们都知道在有注解的接口方法中加上@RequestBody等注解，springMVC会自动的将消息体等地方的里面参数解析映射到请求的方法参数中。&lt;/p&gt;
&lt;p&gt;如果我们想要的信息不完全是来自消息体等地方，比如说一部分是消息体，一部分是消息头，甚至一部分从配置中获取。这个时候我们又希望在方法入参进来就将这些信息组装好。或者说是需要从消息头里面去进行token解析认证的时候。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2. HandlerMethodArgumentResolver接口&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;实现HandlerMethodArgumentResolver来扩展自己的参数解析器。该接口有两个方法supportsParameter和resolveArgument我们需要重写这两个方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1216484/201911/1216484-20191130223903358-1083946672.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;supportsParameter是条件，只有这个方法返回true的时候。才会在调用resolveArgument方法进行参数解析。&lt;/p&gt;
&lt;p&gt;Spring源码中对这两个方法的调用：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1216484/201911/1216484-20191130224058584-254153768.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3.实现自己的参数解析器：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.nijunyang.springboot.argsresolver;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.core.MethodParameter;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.lang.Nullable;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.support.WebDataBinderFactory;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.context.request.NativeWebRequest;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.method.support.HandlerMethodArgumentResolver;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.method.support.ModelAndViewContainer;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.servlet.http.HttpServletRequest;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt;: create by nijunyang
 * @date:2019/11/30
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DefArgumentResolver &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; HandlerMethodArgumentResolver {
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; supportsParameter(MethodParameter methodParameter) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;方法参数是User 则使用此解析器&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; User.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.isAssignableFrom(methodParameter.getParameterType());
    }

    @Nullable
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object resolveArgument(
            MethodParameter methodParameter,
            @Nullable ModelAndViewContainer modelAndViewContainer,
            NativeWebRequest nativeWebRequest,
            @Nullable WebDataBinderFactory webDataBinderFactory) &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        HttpServletRequest servletRequest &lt;/span&gt;= nativeWebRequest.getNativeRequest(HttpServletRequest.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        String info &lt;/span&gt;= (String) nativeWebRequest.getAttribute(&quot;params&quot;&lt;span&gt;, NativeWebRequest.SCOPE_REQUEST);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取消息头认证信息，没有后续操作了，根据业务实际来解析校验该token&lt;/span&gt;
        String token = servletRequest.getHeader(&quot;Authorization&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;自己塞数据进去，也可以从配置文件获取数据&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; User(&quot;zhangsan&quot;,18&lt;span&gt;);


    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;4.将自己的解析器加入到容器的解析器集合中&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.nijunyang.springboot.argsresolver;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Component;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.method.support.HandlerMethodArgumentResolver;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt;: create by nijunyang
 * @date:2019/11/30
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Component
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;一定要将自己的扩展类加到容器中&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DefWebMvcConfigurer &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; WebMvcConfigurer {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; addArgumentResolvers(List&amp;lt;HandlerMethodArgumentResolver&amp;gt;&lt;span&gt; resolvers) {
        resolvers.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefArgumentResolver());
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然也可以用注解的形式注入到DefWebMvcConfigurer 中在添加到集合中，同时还可以在DefArgumentResolver 中获取配置的信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;5.Test&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.nijunyang.springboot.argsresolver;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.GetMapping;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.RestController;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt;: create by nijunyang
 * @date:2019/11/30
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@RestController
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Controller {

    @GetMapping(&lt;/span&gt;&quot;/test&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String test(User user){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; user.toString();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;6.效果：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1216484/201911/1216484-20191130224849215-697273957.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;直接可以获取到我们自定返回的对象。&lt;/p&gt;

</description>
<pubDate>Sat, 30 Nov 2019 14:55:00 +0000</pubDate>
<dc:creator>白露非霜</dc:creator>
<og:description>1.为什么需要自己实现参数解析器 我们都知道在有注解的接口方法中加上@RequestBody等注解，springMVC会自动的将消息体等地方的里面参数解析映射到请求的方法参数中。 如果我们想要的信息不</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/nijunyang/p/11964399.html</dc:identifier>
</item>
<item>
<title>CSS中如何使用背景样式属性，看这篇文章就够用了 - 微笑是最初的信仰</title>
<link>http://www.cnblogs.com/lq0001/p/11964273.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lq0001/p/11964273.html</guid>
<description>&lt;h2 id=&quot;css背景样式属性介绍&quot;&gt;css背景样式属性介绍&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;背景样式就是自定义&lt;code&gt;HTML&lt;/code&gt;标签的背景颜色或背景图像。&lt;/li&gt;
&lt;li&gt;背景属性说明表&lt;/li&gt;
&lt;/ul&gt;&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;9&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;background-color&lt;/td&gt;
&lt;td&gt;#f00、red、rgb(255,0,0)&lt;/td&gt;
&lt;td&gt;设置背景颜色。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;background-image&lt;/td&gt;
&lt;td&gt;url(背景图片路径)&lt;/td&gt;
&lt;td&gt;设置背景图像。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;background-repeat&lt;/td&gt;
&lt;td&gt;repeat、repeat-x、repeat-y、no-repeat&lt;/td&gt;
&lt;td&gt;设置背景图片是否平铺和平铺方向。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;background-position&lt;/td&gt;
&lt;td&gt;left、center、right、top、bottom、固定值、百分比&lt;/td&gt;
&lt;td&gt;设置背景图片位置。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;background-attachment&lt;/td&gt;
&lt;td&gt;scroll、fixed&lt;/td&gt;
&lt;td&gt;设置背景图片位置是否是固定或滚动。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;background&lt;/td&gt;
&lt;td&gt;属性值就是以上的所有值&lt;/td&gt;
&lt;td&gt;设置背景的缩写形式。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;属性为background-color使用方式&quot;&gt;属性为background-color使用方式&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;让我们进入属性为&lt;code&gt;background-color&lt;/code&gt;实践，实践内容如：将&lt;code&gt;HTML&lt;/code&gt;页面中的&lt;code&gt;div&lt;/code&gt;背景设置为红色。&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;代码块&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;

&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;
    &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&amp;gt;
    &amp;lt;title&amp;gt;background-color属性使用&amp;lt;/title&amp;gt;
    &amp;lt;style&amp;gt;
      div{
          background-color: red;
      }
       
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
  
&amp;lt;body&amp;gt;
   &amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1781381/201911/1781381-20191130221320378-482410500.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;为什么我们给&lt;code&gt;div&lt;/code&gt;标签设置了&lt;code&gt;background-color&lt;/code&gt;属性，还有属性值为&lt;code&gt;red&lt;/code&gt;，&lt;code&gt;div&lt;/code&gt;标签背景没有发生任何变化呢？&lt;/li&gt;
&lt;li&gt;原因有2点如： &lt;code&gt;div&lt;/code&gt;标签里面没有任何内容、 &lt;code&gt;div&lt;/code&gt;标签没有设置宽高度。&lt;/li&gt;
&lt;li&gt;接下来我们在实践，将&lt;code&gt;div&lt;/code&gt;标签放置一些内容。&lt;/li&gt;
&lt;li&gt;代码块&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;

&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;
    &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&amp;gt;
    &amp;lt;title&amp;gt;background-color属性使用&amp;lt;/title&amp;gt;
    &amp;lt;style&amp;gt;
      div{
          background-color: red;
      }
       
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
  
&amp;lt;body&amp;gt;
   &amp;lt;div&amp;gt;成功不是打败别人，而是改变自己。&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1781381/201911/1781381-20191130221350138-567632469.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;现在属性为&lt;code&gt;background-color&lt;/code&gt;和属性值为&lt;code&gt;red&lt;/code&gt;才真正的被渲染出来。&lt;/li&gt;
&lt;li&gt;现在让我们将&lt;code&gt;div&lt;/code&gt;内容消除掉，然后我们给&lt;code&gt;div&lt;/code&gt;设置宽高度为&lt;code&gt;200px&lt;/code&gt;像素，看看属性为&lt;code&gt;background-color&lt;/code&gt;和属性值为&lt;code&gt;red&lt;/code&gt;，能否被渲染出来呢？&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;代码块&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;

&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;
    &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&amp;gt;
    &amp;lt;title&amp;gt;background-color属性使用&amp;lt;/title&amp;gt;
    &amp;lt;style&amp;gt;
      div{
           width: 200px;
           height: 200px;
          background-color: red;
      }
       
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
  
&amp;lt;body&amp;gt;
   &amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1781381/201911/1781381-20191130221409613-188601325.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li readability=&quot;-1.5&quot;&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：现在大家应该明白了属性为&lt;code&gt;background-color&lt;/code&gt;，只有设置了宽高度的元素或者元素里面有内容，才能被渲染出来。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;属性为background-image使用方式&quot;&gt;属性为background-image使用方式&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;

&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;
    &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&amp;gt;
    &amp;lt;title&amp;gt;background-image属性使用&amp;lt;/title&amp;gt;
    &amp;lt;style&amp;gt;
      div{
           width: 400px;
           height: 400px;
           background-image: url(./img/001.png);
      }
       
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
  
&amp;lt;body&amp;gt;
   &amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1781381/201911/1781381-20191130221430517-1036551371.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li readability=&quot;-1.5&quot;&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：属性为&lt;code&gt;background-image&lt;/code&gt;默认图片是平铺的，所以这个结果图并不奇怪哈。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h2 id=&quot;属性为background-repeat使用方式&quot;&gt;属性为background-repeat使用方式&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;属性为&lt;code&gt;background-repeat&lt;/code&gt;有2种作用如：&lt;/li&gt;
&lt;li&gt;1、元素的背景图片是否平铺。&lt;/li&gt;
&lt;li&gt;2、设置背景图片的水平方向平铺或垂直方向平铺。&lt;/li&gt;
&lt;li&gt;属性为&lt;code&gt;background-repeat&lt;/code&gt;的属性值有4种如： &lt;code&gt;repeat&lt;/code&gt;、&lt;code&gt;repeat-x&lt;/code&gt;、&lt;code&gt;repeat-y&lt;/code&gt;、&lt;code&gt;no-repeat&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;background-repeat&lt;/code&gt;属性值说明表：&lt;/li&gt;
&lt;/ul&gt;&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;repeat&lt;/td&gt;
&lt;td&gt;background-repeat属性的默认值，作用表示背景图片平铺。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;repeat-x&lt;/td&gt;
&lt;td&gt;作用：将背景图片设置为水平方向平铺。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;repeat-y&lt;/td&gt;
&lt;td&gt;作用：将背景图片设置为垂直方向平铺。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;no-repeat&lt;/td&gt;
&lt;td&gt;作用：将背景图片设置为不平铺。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;属性值为repeat实践&quot;&gt;属性值为repeat实践&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;让我们进入属性为&lt;code&gt;background-repeat&lt;/code&gt;并且属性值为&lt;code&gt;repeat&lt;/code&gt;实践，实践内容如：将&lt;code&gt;div&lt;/code&gt;标签背景图片设置为平铺。&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;代码块&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;

&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;
    &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&amp;gt;
    &amp;lt;title&amp;gt;background-repeat属性使用&amp;lt;/title&amp;gt;
    &amp;lt;style&amp;gt;
      div{
           width: 400px;
           height: 400px;
           background-image: url(./img/001.png);
           background-repeat: repeat;
      }
       
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
  
&amp;lt;body&amp;gt;
   &amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1781381/201911/1781381-20191130221500169-1321749689.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li readability=&quot;-1.5&quot;&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：假设我们不设置属性为&lt;code&gt;background-repeat&lt;/code&gt;并且属性值为&lt;code&gt;repeat&lt;/code&gt;，也没有关系的默认就是平铺。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h3 id=&quot;属性值为repeat-x实践&quot;&gt;属性值为repeat-x实践&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;让我们进入属性为&lt;code&gt;background-repeat&lt;/code&gt;并且属性值为&lt;code&gt;repeat-x&lt;/code&gt;实践，实践内容如：将&lt;code&gt;div&lt;/code&gt;标签背景图片设置为水平方向平铺，为了给初学者一个直观的印象，笔者将&lt;code&gt;div&lt;/code&gt;标签添加了一个边框样式。&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;代码块&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;

&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;
    &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&amp;gt;
    &amp;lt;title&amp;gt;background-repeat属性使用&amp;lt;/title&amp;gt;
    &amp;lt;style&amp;gt;
      div{
           width: 400px;
           height: 400px;
           border: 1px solid red;
           background-image: url(./img/001.png);
           background-repeat:repeat-x;
      }
       
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
  
&amp;lt;body&amp;gt;
   &amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1781381/201911/1781381-20191130221521353-1875737448.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;属性值为repeat-y实践&quot;&gt;属性值为repeat-y实践&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;让我们进入属性为&lt;code&gt;background-repeat&lt;/code&gt;并且属性值为&lt;code&gt;repeat-y&lt;/code&gt;实践，实践内容如：将&lt;code&gt;div&lt;/code&gt;标签背景图片设置为垂直方向平铺，为了给初学者一个直观的印象，笔者将&lt;code&gt;div&lt;/code&gt;标签添加了一个边框样式。&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;代码块&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;

&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;
    &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&amp;gt;
    &amp;lt;title&amp;gt;background-repeat属性使用&amp;lt;/title&amp;gt;
    &amp;lt;style&amp;gt;
      div{
           width: 400px;
           height: 400px;
           border: 1px solid red;
           background-image: url(./img/001.png);
           background-repeat:repeat-y;
      }
       
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
  
&amp;lt;body&amp;gt;
   &amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1781381/201911/1781381-20191130221609413-1407528470.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;属性值为no-repeat实践&quot;&gt;属性值为no-repeat实践&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;让我们进入属性为&lt;code&gt;background-repeat&lt;/code&gt;并且属性值&lt;code&gt;no-repeat&lt;/code&gt;实践，实践内容如：将&lt;code&gt;div&lt;/code&gt;标签背景图片设置为不平铺，为了给初学者一个直观的印象，笔者将&lt;code&gt;div&lt;/code&gt;标签添加了一个边框样式。&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;代码块&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;

&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;
    &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&amp;gt;
    &amp;lt;title&amp;gt;background-repeat属性使用&amp;lt;/title&amp;gt;
    &amp;lt;style&amp;gt;
      div{
           width: 400px;
           height: 400px;
           border: 1px solid red;
           background-image: url(./img/001.png);
           background-repeat:no-repeat;
      }
       
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
  
&amp;lt;body&amp;gt;
   &amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1781381/201911/1781381-20191130221659265-1965598869.png&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;属性为background-position使用方式&quot;&gt;属性为background-position使用方式&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;属性为&lt;code&gt;background-position&lt;/code&gt;作用：设置背景图片的位置在哪。&lt;/li&gt;
&lt;li&gt;属性为&lt;code&gt;background-position&lt;/code&gt;的属性值分为3种使用方式如：英文单词、固定值、百分比。&lt;/li&gt;
&lt;li&gt;英文单词的表示说明如：&lt;code&gt;left&lt;/code&gt;（居左）、&lt;code&gt;right&lt;/code&gt;（居右）、&lt;code&gt;top&lt;/code&gt;（居上）、&lt;code&gt;bottom&lt;/code&gt;（居下）、&lt;code&gt;center&lt;/code&gt;（居中）&lt;/li&gt;
&lt;li&gt;让我们进入属性为&lt;code&gt;background-position&lt;/code&gt;使用英文单词设置背景的位置实践。&lt;/li&gt;
&lt;li&gt;默认就是居上和居左我们就不实践了，如果是初学者可以尝试下。&lt;/li&gt;
&lt;li&gt;设置背景图片位置为居上和居右实践。&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;代码块&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;

&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;
    &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&amp;gt;
    &amp;lt;title&amp;gt;background-position属性使用&amp;lt;/title&amp;gt;
    &amp;lt;style&amp;gt;
      div{
           width: 400px;
           height: 400px;
           border: 1px solid red;
           background-image: url(./img/001.png);
           background-repeat:no-repeat;
           background-position:center;
           background-position: top right;
      }
       
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
  
&amp;lt;body&amp;gt;
   &amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1781381/201911/1781381-20191130221719887-913223702.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;设置背景图片位置为居下和居左实践。&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;代码块&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;

&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;
    &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&amp;gt;
    &amp;lt;title&amp;gt;background-position属性使用&amp;lt;/title&amp;gt;
    &amp;lt;style&amp;gt;
      div{
           width: 400px;
           height: 400px;
           border: 1px solid red;
           background-image: url(./img/001.png);
           background-repeat:no-repeat;
           background-position:center;
           background-position: bottom left;
      }
       
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
  
&amp;lt;body&amp;gt;
   &amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1781381/201911/1781381-20191130221739651-1757915250.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;设置背景图片位置为居下和居右实践。&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;代码块&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;

&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;
    &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&amp;gt;
    &amp;lt;title&amp;gt;background-position属性使用&amp;lt;/title&amp;gt;
    &amp;lt;style&amp;gt;
      div{
           width: 400px;
           height: 400px;
           border: 1px solid red;
           background-image: url(./img/001.png);
           background-repeat:no-repeat;
           background-position:center;
           background-position: bottom right;
      }
       
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
  
&amp;lt;body&amp;gt;
   &amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1781381/201911/1781381-20191130221802061-1826473957.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;设置背景图片位置为居中实践。&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;代码块&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;

&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;
    &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&amp;gt;
    &amp;lt;title&amp;gt;background-position属性使用&amp;lt;/title&amp;gt;
    &amp;lt;style&amp;gt;
      div{
           width: 400px;
           height: 400px;
           border: 1px solid red;
           background-image: url(./img/001.png);
           background-repeat:no-repeat;
           background-position:center;
            background-position: center center;
      }
       
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
  
&amp;lt;body&amp;gt;
   &amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1781381/201911/1781381-20191130221824243-2135814952.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;以上就是英文单词设置背景图片的位置内容。&lt;/li&gt;
&lt;li&gt;现在我们进入固定值和百分比设置&lt;code&gt;div&lt;/code&gt;标签背景图片的位置实践。&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;代码块&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;

&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;
    &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&amp;gt;
    &amp;lt;title&amp;gt;background-position属性使用&amp;lt;/title&amp;gt;
    &amp;lt;style&amp;gt;
      div{
           width: 400px;
           height: 400px;
           border: 1px solid red;
           background-image: url(./img/001.png);
           background-repeat:no-repeat;
           background-position:center;
           background-position: 100px;
      }
       
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
  
&amp;lt;body&amp;gt;
   &amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1781381/201911/1781381-20191130221843328-1929694301.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;由于简单百分比就不进行代码实践了，&lt;code&gt;px&lt;/code&gt;单位换成&lt;code&gt;%&lt;/code&gt;百分号就是按照元素的宽高度进行百分比计算背景图片的位置。&lt;/li&gt;
&lt;li&gt;其实英文单词和固定值或百分比可以混合使用呢，笔者将背景图片位置设置为居下并且是水平向右&lt;code&gt;20px&lt;/code&gt;像素。&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;代码块&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;

&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;
    &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&amp;gt;
    &amp;lt;title&amp;gt;background-position属性使用&amp;lt;/title&amp;gt;
    &amp;lt;style&amp;gt;
      div{
           width: 400px;
           height: 400px;
           border: 1px solid red;
           background-image: url(./img/001.png);
           background-repeat:no-repeat;
           background-position:center;
           background-position: 20px bottom;
      }
       
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
  
&amp;lt;body&amp;gt;
   &amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1781381/201911/1781381-20191130221906281-477888677.png&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;属性为background-attachment使用方式&quot;&gt;属性为background-attachment使用方式&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;属性为&lt;code&gt;background-attachment&lt;/code&gt;作用：就是设置背景图片位置是否是固定或者是滚动的。&lt;/li&gt;
&lt;li&gt;属性为&lt;code&gt;background-attachment&lt;/code&gt;属性值说明表：&lt;/li&gt;
&lt;/ul&gt;&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;scroll&lt;/td&gt;
&lt;td&gt;设置背景图片滚动。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;fixed&lt;/td&gt;
&lt;td&gt;设置背景图片固定。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;ul&gt;&lt;li&gt;让我进入属性为&lt;code&gt;background-attachment&lt;/code&gt;实践，实践内容将&lt;code&gt;div&lt;/code&gt;标签背景图片位置滚动和固定位置，方便大家理解滚动和固定笔者将在&lt;code&gt;div&lt;/code&gt;标签中放置一些内容。&lt;/li&gt;
&lt;li&gt;属性为&lt;code&gt;background-attachment&lt;/code&gt;默认属性值就是&lt;code&gt;scroll&lt;/code&gt;滚动的。&lt;/li&gt;
&lt;li&gt;背景图片位置滚动的实践&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;代码块&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;

&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;
    &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&amp;gt;
    &amp;lt;title&amp;gt;background-position属性使用&amp;lt;/title&amp;gt;
    &amp;lt;style&amp;gt;
      div{
           width: 400px;
           height: 400px;
           border: 1px solid red;
           background-image: url(./img/001.png);
           background-repeat:no-repeat;
           background-attachment:scroll;
           
      }
       
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
  
&amp;lt;body&amp;gt;
   &amp;lt;div&amp;gt;
     微笑是最初的信仰，微笑是最初的信仰，微笑是最初的信仰，
     微笑是最初的信仰，微笑是最初的信仰，微笑是最初的信仰，
     微笑是最初的信仰，微笑是最初的信仰，微笑是最初的信仰，
     微笑是最初的信仰，微笑是最初的信仰，微笑是最初的信仰，
     微笑是最初的信仰，微笑是最初的信仰，微笑是最初的信仰，
     微笑是最初的信仰，微笑是最初的信仰，微笑是最初的信仰，
     微笑是最初的信仰，微笑是最初的信仰，微笑是最初的信仰，
     微笑是最初的信仰，微笑是最初的信仰，微笑是最初的信仰，
     微笑是最初的信仰，微笑是最初的信仰，微笑是最初的信仰，
     微笑是最初的信仰，微笑是最初的信仰，微笑是最初的信仰，
     微笑是最初的信仰，微笑是最初的信仰，微笑是最初的信仰，
     微笑是最初的信仰，微笑是最初的信仰，微笑是最初的信仰，
     微笑是最初的信仰，微笑是最初的信仰，微笑是最初的信仰。
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1781381/201911/1781381-20191130221932913-812652056.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;背景图片位置固定实践&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;代码块&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;

&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;
    &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&amp;gt;
    &amp;lt;title&amp;gt;background-position属性使用&amp;lt;/title&amp;gt;
    &amp;lt;style&amp;gt;
      div{
           width: 400px;
           height: 400px;
           border: 1px solid red;
           background-image: url(./img/001.png);
           background-repeat:no-repeat;
           background-attachment:fixed;
           
      }
       
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
  
&amp;lt;body&amp;gt;
   &amp;lt;div&amp;gt;
     微笑是最初的信仰，微笑是最初的信仰，微笑是最初的信仰，
     微笑是最初的信仰，微笑是最初的信仰，微笑是最初的信仰，
     微笑是最初的信仰，微笑是最初的信仰，微笑是最初的信仰，
     微笑是最初的信仰，微笑是最初的信仰，微笑是最初的信仰，
     微笑是最初的信仰，微笑是最初的信仰，微笑是最初的信仰，
     微笑是最初的信仰，微笑是最初的信仰，微笑是最初的信仰，
     微笑是最初的信仰，微笑是最初的信仰，微笑是最初的信仰，
     微笑是最初的信仰，微笑是最初的信仰，微笑是最初的信仰，
     微笑是最初的信仰，微笑是最初的信仰，微笑是最初的信仰，
     微笑是最初的信仰，微笑是最初的信仰，微笑是最初的信仰，
     微笑是最初的信仰，微笑是最初的信仰，微笑是最初的信仰，
     微笑是最初的信仰，微笑是最初的信仰，微笑是最初的信仰，
     微笑是最初的信仰，微笑是最初的信仰，微笑是最初的信仰。
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1781381/201911/1781381-20191130221956032-354439452.png&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;属性为background使用方式&quot;&gt;属性为background使用方式&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;属性为&lt;code&gt;background&lt;/code&gt;就是设置背景的一个缩写。本章内容大家都掌握了这个就如小菜一点不值一提哈，废话就不多说了直接上代码块咯。&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;代码块&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;

&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;
    &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&amp;gt;
    &amp;lt;title&amp;gt;background属性使用&amp;lt;/title&amp;gt;
    &amp;lt;style&amp;gt;
      div{
           width: 400px;
           height: 400px;
           border: 1px solid red;
           background: url(./img/001.png) no-repeat top right scroll;   
      }
       
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
  
&amp;lt;body&amp;gt;
   &amp;lt;div&amp;gt;
     微笑是最初的信仰，微笑是最初的信仰，微笑是最初的信仰，
     微笑是最初的信仰，微笑是最初的信仰，微笑是最初的信仰，
     微笑是最初的信仰，微笑是最初的信仰，微笑是最初的信仰，
     微笑是最初的信仰，微笑是最初的信仰，微笑是最初的信仰，
     微笑是最初的信仰，微笑是最初的信仰，微笑是最初的信仰，
     微笑是最初的信仰，微笑是最初的信仰，微笑是最初的信仰，
     微笑是最初的信仰，微笑是最初的信仰，微笑是最初的信仰，
     微笑是最初的信仰，微笑是最初的信仰，微笑是最初的信仰，
     微笑是最初的信仰，微笑是最初的信仰，微笑是最初的信仰，
     微笑是最初的信仰，微笑是最初的信仰，微笑是最初的信仰，
     微笑是最初的信仰，微笑是最初的信仰，微笑是最初的信仰，
     微笑是最初的信仰，微笑是最初的信仰，微笑是最初的信仰，
     微笑是最初的信仰，微笑是最初的信仰，微笑是最初的信仰。
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1781381/201911/1781381-20191130222024989-1867893458.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 30 Nov 2019 14:22:00 +0000</pubDate>
<dc:creator>微笑是最初的信仰</dc:creator>
<og:description>css背景样式属性介绍 背景样式就是自定义 标签的背景颜色或背景图像。 背景属性说明表 属性名 | 属性值|描述 | | background color | f00、red、rgb(255,0,0)</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lq0001/p/11964273.html</dc:identifier>
</item>
<item>
<title>Python 0基础开发游戏：打地鼠（详细教程）VS code版本 - CoXie带你学编程</title>
<link>http://www.cnblogs.com/CoXieLearnPython/p/11964266.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CoXieLearnPython/p/11964266.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;如果你没有任何编程经验，而且想尝试一下学习编程开发，这个系列教程一定适合你，它将带你学习最基本的Python语法，并让你掌握小游戏的开发技巧。你所需要的，就是付出一些时间和耐心来尝试这些代码和操作。&lt;br/&gt;@[top]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;1 下载安装 &lt;code&gt;python&lt;/code&gt;&lt;br/&gt;2 下载安装&lt;code&gt;VS code&lt;/code&gt;编辑器&lt;br/&gt;安装时，要注意勾选 &lt;code&gt;添加到path&lt;/code&gt;&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/19067920-0d74c8b39041ca80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;br/&gt;3 安装pygame模块&lt;/p&gt;
&lt;ol readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;在桌面上创建一个文件夹&lt;code&gt;mygame&lt;/code&gt;，然后在VSCode中使用菜单【File-Open Folder】，选择&lt;code&gt;mygame&lt;/code&gt;文件夹，VSCode左侧将会出现EXPLORER导航栏。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在左侧导航栏中，【右键-New File】创建文件&lt;code&gt;main.py&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4324074-8200d7940aec5d6a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/748/format/webp&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;- 将下面的代码粘贴到右侧`main.py`文件中。
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;import pygame
import sys
pygame.display.set_mode([600,400])
while 1:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            sys.exit()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这里我还是要说一下，文中素材以及可执行代码可以加群：456926667，获取，这个是我创建的一个针对0基础的伙伴一个交流群，下个文章我会更新关于pycharm版本的打地鼠。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;运行代码。&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;*   仍然【Terminal-New terminal】终端中输入命令`python main.py`，这将运行我们上面的代码，看到弹出一个黑色窗口。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4324074-7bf38b4276ec6e04.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp&quot;/&gt;&lt;/p&gt;

&lt;ol readability=&quot;1&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;执行上面的操作的时候，VSCode的右下角会经常弹出一些提示，如果有【Install】字样，可以放心的点击它进行安装更多内容。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;也可以从左侧栏点击图标打开【EXTENSIONS】，然后搜索&lt;code&gt;@id:ms-python.python&lt;/code&gt;，点击找到的结果，右侧再点击【Install】按钮进行安装。安装之后&lt;code&gt;main.py&lt;/code&gt;文件的右上角就会出现三角形运行按钮，点击它同样可以运行代码，相当于终端中输入&lt;code&gt;python main.py&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4324074-80e200bf65416c92.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1180/format/webp&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4324074-4fea7af8684198ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;ol readability=&quot;1&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;code&gt;pip install ...&lt;/code&gt;安装命令太慢。Windows用户，可以从上面的网盘中下载&lt;code&gt;pip.ini&lt;/code&gt;文件，然后在【C盘-用户-用户名】文件夹下面创建&lt;code&gt;pip&lt;/code&gt;文件夹，再把下载的&lt;code&gt;pip.ini&lt;/code&gt;文件拷贝进去，此后再运行&lt;code&gt;pip install ...&lt;/code&gt;安装速度就会快很多。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;对于苹果用户就麻烦很多。先在终端执行&lt;code&gt;cd ~&lt;/code&gt;切换到用户文件夹，然后执行&lt;code&gt;mkdir .pip&lt;/code&gt;创建&lt;code&gt;.pip&lt;/code&gt;文件夹，它是隐身的，我们打开访达，从菜单执行【前往-前往文件夹...】，前往&lt;code&gt;~/.test&lt;/code&gt;目录，把下载的&lt;code&gt;pip.conf&lt;/code&gt;文件粘贴进去，搞定。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;code&gt;pip.ini&lt;/code&gt;或者&lt;code&gt;pip.conf&lt;/code&gt;文件是把原来&lt;code&gt;pip&lt;/code&gt;默认从国外下载安装改成了从国内下载，所以速度会变快很多。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul readability=&quot;7.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;其中&lt;code&gt;import&lt;/code&gt;是导入我们要使用的外部代码模块，&lt;code&gt;pygame&lt;/code&gt;当然是必须的，&lt;code&gt;sys&lt;/code&gt;是&lt;code&gt;system系统&lt;/code&gt;的简写，因为我们的游戏要运行在系统(windows或者苹果macOS）上面，所以我们会用到系统的一些命令，比如下面的&lt;code&gt;sys.exit()&lt;/code&gt;这个命令。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;pyagme.display.set_mode([600,400])&lt;/code&gt;，这里的&lt;code&gt;[600,400]&lt;/code&gt;是一对数字组合在一起的，叫二元数组，这里它表示宽600，高400的一个矩形。整句话就是设置要弹出的窗口的大小，&lt;code&gt;display显示&lt;/code&gt;,&lt;code&gt;set设置&lt;/code&gt;,&lt;code&gt;mode模式&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;code&gt;while 1：...当是1的时候，就...&lt;/code&gt;,1在代码里面表示正确的、真的、存在的，相反，0表示错误、假的、不存在的。&lt;code&gt;while 1:do something&lt;/code&gt;那么something就会做，如果&lt;code&gt;while 0: do something&lt;/code&gt;那么就不会做了。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;code&gt;for ... sys.exit()&lt;/code&gt;这一段暂时可以不深究，只是固定格式。只要知道它表示游戏程序运行结束的时候系统把窗口也关掉，清理好计算机不要留痕迹，&lt;code&gt;exit退出&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;游戏开发都有固定的套路，无论是打地鼠、愤怒的小鸟，还是西瓜忍者，甚至是王者荣耀这样的大型游戏，他们大致都遵循下面几个思路：&lt;/p&gt;
&lt;ol readability=&quot;7&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;创建一个地图场景，上面可能有些道具。&lt;/p&gt;
&lt;p&gt;比如几个地鼠洞，一些可以放小猪的木盒子，甚至非常复杂的山谷地形，上面还有很多野怪。&lt;br/&gt;这些地图上的元素一般都是被动的，就是你不去靠近或招惹野怪的话，它们不会互相打起来自相残杀，同样，小鸟还没发射的时候，木盒子也不会自己倒塌。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;创建至少一个玩家可以控制的元素，它可以和地图场景发生交互。&lt;/p&gt;
&lt;p&gt;这个可以被控制的元素我们称为玩家角色。在打地鼠游戏中这个角色就是一个锤子，愤怒的小鸟中这个角色其实是弹弓，弹出的小鸟其实是个道具，在王者荣耀游戏中玩家的角色就是自己的英雄。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;必须要有评判标准，用来衡量输赢胜败。&lt;/p&gt;
&lt;p&gt;玩家控制的角色和地图场景进行交互，发生反应，对应的也必须要有一个评判标准，比如计算3分钟内击中地鼠的次数，或者计算砸死的绿猪的数量，或者是打野怪获得的经验，这些规则一定要清晰而且不能互相矛盾。&lt;br/&gt;大多数游戏都有输赢胜败，而胜败往往本质上只是谁的积分首先达到某个临界点。可以是某个关键道具的变化，比如对战游戏中塔被摧毁，也可以是玩家角色的属性变化，比如格斗游戏中被击杀；也可以只是纯粹的某项积分评比，用排行榜代替输赢。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ol readability=&quot;7.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;要能够在窗口内绘制图形。&lt;/p&gt;
&lt;p&gt;可以是直接用代码绘制几何图形，也可以是载入图片显示内容。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;要能用代码控制每个元素（道具和角色）的动画。&lt;/p&gt;
&lt;p&gt;动画就是一组图片不停地轮番变化。要能用代码控制播放和停止每个元素的动画，还能在不同动画之间快速切换。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;能够接收用户的控制，并借此影响游戏中的元素。&lt;/p&gt;
&lt;p&gt;知道用户什么时候按了键盘，什么时候点了鼠标，按了哪个按键，鼠标左键还是右键？我们经常把这些操作称之为交互事件。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;能够对游戏中各种元素产生的有效数据进行计算和管理。&lt;/p&gt;
&lt;p&gt;玩家角色一刀砍下去，怪物的血量减少了100点，这个就是数据，而且是很有用的数据，没有这个数据的话怪物可能永远砍不死了。&lt;br/&gt;有时候这些数据要保存好，让用户下一次打开游戏的时候仍然看到自己的等级和装备都还存在。有些时候这些数据要及时清理，比如新的一局又开始了，地图上的道具和角色都要恢复原样。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们可以把经典的打地鼠游戏简化概括为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;地图和道具：随机位置出现地鼠图形&lt;/li&gt;
&lt;li&gt;交互角色：控制锤子图形，点击地鼠图形使其消失&lt;/li&gt;
&lt;li&gt;积分输赢：限定时间内击中地鼠图形的次数&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;核心玩法简化成一句话就是：点击随机出现图形。&lt;/p&gt;
&lt;h2 id=&quot;绘制地鼠&quot;&gt;绘制地鼠&lt;/h2&gt;
&lt;p&gt;我们用一个蓝色的圆形代表地鼠。那怎么在窗口中绘制一个圆形呢？&lt;/p&gt;
&lt;p&gt;可以百度【pygame 画圆圈】类似的关键字，可以查到要使用&lt;code&gt;pygame.draw.circle&lt;/code&gt;语句，它的具体语法可以从官方说明文档中找到，&lt;a href=&quot;https://links.jianshu.com/go?to=http%3A%2F%2Fwww.pygame.org%2Fdocs%2Fref%2Fdraw.html&quot;&gt;英文版详细说明点这里。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我们查到它的语法是:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;pygame.draw.circle()
circle(surface, color, center, radius) -&amp;gt; Rect
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这表示&lt;code&gt;draw.circle()&lt;/code&gt;需要四个参数，分别是&lt;code&gt;surface表面,color颜色,center中心点,radius半径&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;我们继续看&lt;code&gt;surface&lt;/code&gt;参数的说明：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;surface (Surface) -- surface to draw on
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;听上去像是画布，——先要有个画布才能在上面画圆。&lt;br/&gt;点击Surface链接，找到更进一步说明：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Surface((width, height), flags=0, depth=0, masks=None) -&amp;gt; Surface
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结尾的&lt;code&gt;-&amp;gt;Surface&lt;/code&gt;表示&lt;code&gt;Surface((width....)&lt;/code&gt;这句话可以生成一个Surface表面，我们可以用下面的语句捕捉到这个生成的表面：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;sur=pygame.Surface((600, 400)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样，&lt;code&gt;sur&lt;/code&gt;就是我们生成的表面了。&lt;/p&gt;
&lt;h2 id=&quot;颜色和位置&quot;&gt;颜色和位置&lt;/h2&gt;
&lt;p&gt;再返回来看&lt;code&gt;color&lt;/code&gt;参数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;color (Color or int or tuple(int, int, int, [int])) 
-- color to draw with, 
the alpha value is optional if using a tuple (RGB[A])
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;很明显它是表示画什么颜色的圆。&lt;code&gt;tuple(int, int, int, [int])&lt;/code&gt;表示这里需要三个整数&lt;code&gt;int&lt;/code&gt;一起表示颜色，&lt;code&gt;RGB&lt;/code&gt;是指&lt;code&gt;red红，green绿，blue蓝，alpha透明度&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;clr=(0,0,255) #蓝色
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于&lt;code&gt;center&lt;/code&gt;中心位置我们也可以用同样的方法得到，这里的&lt;code&gt;Vector2&lt;/code&gt;表示二元向量，及横向x和竖向y的位置：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;pos=pygame.vector2(300,200) #窗口中央
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;绘制圆形&quot;&gt;绘制圆形&lt;/h2&gt;
&lt;p&gt;参数都具备了，那么就可以开始画圆了。运行下面的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import pygame
import sys

pygame.init()  # 初始化
window = pygame.display.set_mode([600, 400])  # 设定窗口

sur = pygame.Surface([600, 400])  # 绘制背景容器
clr = (0, 0, 255)
pos = (300,200)
rad = 100

while 1:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            sys.exit()

    # 每帧循环执行的代码
    pygame.draw.circle(sur, clr, pos, 100# 绘制圆

    # 刷新画面
    window.blit(sur, (0, 0))
    pygame.display.flip()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意这里最底部刷新画面的两行，其中&lt;code&gt;window.blit(sur, (0, 0))&lt;/code&gt;表示把我们绘制好的表面&lt;code&gt;sur&lt;/code&gt;刷新到&lt;code&gt;window&lt;/code&gt;窗口中；&lt;code&gt;pygame.display.flip()&lt;/code&gt;表示进行窗口刷新。&lt;/p&gt;
&lt;h2 id=&quot;随机出现&quot;&gt;随机出现&lt;/h2&gt;
&lt;p&gt;随机出现就是随机位置，我们必须确保每一次花圆的&lt;code&gt;pos&lt;/code&gt;位置都不同，而且应该是固定的几个地鼠洞位置。——别忘了我们要做打地鼠游戏。&lt;/p&gt;
&lt;p&gt;假设有6个地鼠位置&lt;code&gt;pos&lt;/code&gt;分别是&lt;code&gt;[200,200],[300,200],[400,200],[200,300],[300,300],[400,300]&lt;/code&gt;，那么如何随机取到6个中一个呢？也就是如何随机取到1~6其中的一个数字即可。&lt;/p&gt;
&lt;p&gt;我们可以百度【python 随机数】查到需要使用&lt;code&gt;random&lt;/code&gt;模块，这是python自带的模块，不需要再重新&lt;code&gt;pip install&lt;/code&gt;。&lt;br/&gt;如果搜索【python random document】可以查找到&lt;a href=&quot;https://links.jianshu.com/go?to=https%3A%2F%2Fdocs.python.org%2F3%2Flibrary%2Frandom.html&quot;&gt;官方的语法说明&lt;/a&gt;，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;random.randint(a, b)
Return a random integer N such that a &amp;lt;= N &amp;lt;= b. 
Alias for randrange(a, b+1).
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是说可以随机生成&lt;code&gt;a&lt;/code&gt;和&lt;code&gt;b&lt;/code&gt;之间的一个数字。也可以从&lt;a href=&quot;https://links.jianshu.com/go?to=https%3A%2F%2Fwww.runoob.com%2Fpython%2Ffunc-number-random.html&quot;&gt;中文的菜鸟教程网&lt;/a&gt;&lt;br/&gt;学习到这个知识。&lt;/p&gt;
&lt;p&gt;新建一个&lt;code&gt;test.py&lt;/code&gt;文件，我们进行测试：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import random
a = random.randint(0, 5)
print(a)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;每次运行都能生成不同的数字。&lt;/p&gt;
&lt;p&gt;继续测试：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import random
a = random.randint(0, 6)
pos6=[[200,200],[300,200],[400,200],[200,300],[300,300],[400,300]]
print(pos6[a])
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的&lt;code&gt;pos6[a]&lt;/code&gt;表示&lt;code&gt;pos6&lt;/code&gt;的六个位置中的第&lt;code&gt;a&lt;/code&gt;个。运行这个代码就会每次生成不同的位置。&lt;/p&gt;
&lt;p&gt;测试成功之后我们把它拷贝到刚才的画圆代码中，得到：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import pygame
import sys
import random

pygame.init()  # 初始化
window = pygame.display.set_mode([600, 400])  # 设定窗口

sur = pygame.Surface([600, 400])  # 绘制背景容器
clr = (0, 0, 255)
pos6 = [[200, 200], [300, 200], [400, 200], [
    200, 300], [300, 300], [400, 300]]  # !!六个位置
rad = 100

while 1:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            sys.exit()

    # 每帧循环执行的代码
    sur.fill((0, 0, 0))  # !!用黑色覆盖前一帧的画面，实现刷新
    a = random.randint(0, 5)  # !!随机0到5
    pygame.draw.circle(sur, clr, pos6[a], 100)  # !!使用随机位置

    # 刷新画面
    window.blit(sur, (0, 0))
    pygame.display.flip()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意新增了&lt;code&gt;sur.fill...&lt;/code&gt;一行，这是用黑色&lt;code&gt;(0,0,0)&lt;/code&gt;来清理掉上一帧的内容，避免出现多个圆。&lt;/p&gt;
&lt;h2 id=&quot;隔n帧刷新&quot;&gt;隔n帧刷新&lt;/h2&gt;
&lt;p&gt;上面的代码运行之后会看到蓝色的圆四处乱跳，太快了，我们希望改变位置之后能停一下，等我们锤它。&lt;/p&gt;
&lt;p&gt;我们需要画面的圆每隔n帧再随机变换一次，而不是现在的每帧都随机变。思路是这样的：我们设定一个计数器，开始是0，每帧都给它增加1，就是&lt;code&gt;0,1,2,3,4...&lt;/code&gt;直到它增到到超过50，这时候我们就改变圆的位置并同时把计数器重置为0。&lt;/p&gt;
&lt;p&gt;代码如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import pygame
import sys
import random

pygame.init()  # 初始化
window = pygame.display.set_mode([600, 400])  # 设定窗口

sur = pygame.Surface([600, 400])  # 绘制背景容器
clr = (0, 0, 255)
pos6 = [[200, 200], [300, 200], [400, 200], [
    200, 300], [300, 300], [400, 300]]  # 六个位置
rad = 100
tick=0 #!!计数器

while 1:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            sys.exit()

    # 每帧循环执行的代码
    if tick&amp;gt;50: #每50次刷新变换一次
        sur.fill((0, 0, 0))  # 用黑色覆盖前一帧的画面，实现刷新
        a = random.randint(0, 5)  # 随机0到5
        pygame.draw.circle(sur, clr, pos6[a], 100)  # 使用随机位置
        tick=0
    else: #!!不刷新变换的时候
        tick=tick+1 #!!增加计数器

    # 刷新画面
    window.blit(sur, (0, 0))
    pygame.display.flip()
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;增加交互点击&quot;&gt;增加交互点击&lt;/h2&gt;
&lt;p&gt;当用户点击画面的时候，我们要知道它点击了哪里，是否点击到了我们画的圆上面。&lt;/p&gt;
&lt;p&gt;百度搜索【pygame 点击】可以找到相关资源，也可以&lt;a href=&quot;https://links.jianshu.com/go?to=https%3A%2F%2Fwww.pygame.org%2Fdocs%2Fref%2Fmouse.html%23pygame.mouse.set_pos&quot;&gt;直接在官方说明文档中找到&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;思路是我们添加对&lt;code&gt;event.type&lt;/code&gt;事件类型的实时监测，一旦发现点击事件就获取位置坐标。代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import pygame
import sys
import random
from pygame.locals import *  # 引入鼠标事件类型

pygame.init()  # 初始化
window = pygame.display.set_mode([600, 400])  # 设定窗口

sur = pygame.Surface([600, 400])  # 绘制背景容器
clr = (0, 0, 255)
pos6 = [[200, 200], [300, 200], [400, 200], [
    200, 300], [300, 300], [400, 300]]  # 六个位置
rad = 100
tick = 0  # !!计数器
pos = pos6[0]  # !!在外面记录圆的位置

while 1:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            sys.exit()
        elif event.type == MOUSEBUTTONDOWN:  # ！！如果是鼠标按下事件
            mpos = pygame.mouse.get_pos()  # ！！获取鼠标位置
            print(mpos)

    # 每帧循环执行的代码
    if tick &amp;gt; 50:  # 每50次刷新变换一次
        sur.fill((0, 0, 0))  # 用黑色覆盖前一帧的画面，实现刷新
        a = random.randint(0, 5)  # 随机0到5
        pos = pos6[a]  # !!更新外部记录的圆的位置
        pygame.draw.circle(sur, clr, pos, 100)  # !!使用随机位置
        tick = 0  # 重置计数器
    else:  # !!不刷新变换的时候
        tick = tick+1  # !!增加计数器

    # 刷新画面
    window.blit(sur, (0, 0))
    pygame.display.flip()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行这个代码，任意点击屏幕上的时候就会打印出档期鼠标点击的位置。&lt;/p&gt;
&lt;h2 id=&quot;距离测量&quot;&gt;距离测量&lt;/h2&gt;
&lt;p&gt;知道当前圆的位置&lt;code&gt;pos&lt;/code&gt;，也知道当前点击的位置&lt;code&gt;mpos&lt;/code&gt;,这样我们就可以计算出两点之间的距离，距离大于圆半径的就是没有点到地鼠，距离小于半径的就是点到地鼠了。&lt;/p&gt;
&lt;p&gt;百度搜索【pygame 两点距离】可以搜到一些计算距离的方法，我们这里使用&lt;code&gt;pygame&lt;/code&gt;官方提供的方法，测试下面代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import pygame
a=pygame.math.Vector2.length(pygame.math.Vector2(3,4))
print(a)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它会输出5（勾三股四玄五）。这里的&lt;code&gt;(3,4)&lt;/code&gt;是&lt;code&gt;pos&lt;/code&gt;和&lt;code&gt;mpos&lt;/code&gt;相减得到的差。&lt;br/&gt;把这个思路带入原来的代码，得到：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import pygame
import sys
import random
from pygame.locals import *  # 引入鼠标事件类型

pygame.init()  # 初始化
window = pygame.display.set_mode([600, 400])  # 设定窗口

sur = pygame.Surface([600, 400])  # 绘制背景容器
clr = (0, 0, 255)
pos6 = [[200, 200], [300, 200], [400, 200], [
    200, 300], [300, 300], [400, 300]]  # 六个位置
rad = 50
tick = 0  # 计数器
pos = pos6[0]  # 外面记录圆的位置

while 1:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            sys.exit()
        elif event.type == MOUSEBUTTONDOWN:  # 如果是鼠标按下事件
            mpos = pygame.mouse.get_pos()  # 获取鼠标位置
            dis = pygame.math.Vector2(
                mpos[0]-pos[0], mpos[1]-pos[1])  # !!计算坐标差
            len = pygame.math.Vector2.length(dis)  # !!计算距离
            if len &amp;lt; rad:
                tick = 51  # !!立即变换位置

    # 每帧循环执行的代码
    if tick &amp;gt; 50:  # 每50次刷新变换一次
        sur.fill((0, 0, 0))  # 用黑色覆盖前一帧的画面，实现刷新
        a = random.randint(0, 5)  # 随机0到5
        pos = pos6[a]  # 更新外部记录的圆的位置
        pygame.draw.circle(sur, clr, pos, 100)  # 使用随机位置
        tick = 0  # 重置计数器
    else:  # 不刷新变换的时候
        tick = tick+1  # 增加计数器

    # 刷新画面
    window.blit(sur, (0, 0))
    pygame.display.flip()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这里我们设定如果距离长度&lt;code&gt;len&lt;/code&gt;小于圆半径&lt;code&gt;rad&lt;/code&gt;，那么就立即设置&lt;code&gt;tick=51&lt;/code&gt;使它大于50，立即进行随机位置变换。&lt;/p&gt;
&lt;p&gt;截止到这里运行上面的代码，可以实现随机出现地鼠（圆）并能够点击使它消失，这也实现了游戏的最基本逻辑功能。后续我们将进一步编写更多内容，让它更完善一些。&lt;/p&gt;
&lt;h2 id=&quot;记录分数&quot;&gt;记录分数&lt;/h2&gt;
&lt;p&gt;计算数字增加很容易，设定一个&lt;code&gt;score=0&lt;/code&gt;，然后击中地鼠的时候增加1就可以了。但是，如何把它显示到屏幕上呢？&lt;/p&gt;
&lt;p&gt;可以百度搜索【pygame 显示文字】然后就可以找到大致方法，我们先进行一些测试：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import pygame

pygame.init()  # 初始化
window = pygame.display.set_mode([600, 400])  # 设定窗口

# 显示文字
pygame.font.init()  # ！！初始化文字
font = pygame.font.SysFont('微软雅黑', 30)  # ！！设定字体和字号
sur = font.render(&quot;Hello World!!{}&quot;.format(999), False, (255, 0, 0))  # ！！生成w文字表面

while 1:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            sys.exit()

    window.blit(sur, (200, 10))  # ！！增加分数表面
    pygame.display.flip()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码中可以看到pygame绘制文字分三步：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;pygame.font.init()&lt;/code&gt;先要初始化&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pygame.font.SysFont('微软雅黑', 30)&lt;/code&gt;设定字体和字号大小&lt;/li&gt;
&lt;li&gt;&lt;code&gt;font.render(&quot;Hello World!!{}&quot;.format(999), False, (255, 0, 0))&lt;/code&gt;生成一个Surface表面&lt;br/&gt;当然，最后别忘了把表面放到窗口里&lt;code&gt;window.blit(sur, (200, 10))&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;运行上面的代码得到一个窗口如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4324074-53d12623d715afd1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们根据这个经验改进的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import pygame
import sys
import random
from pygame.locals import *  # 引入鼠标事件类型

pygame.init()  # 初始化
window = pygame.display.set_mode([600, 400])  # 设定窗口

sur = pygame.Surface([600, 400])  # 绘制背景容器
clr = (0, 0, 255)
pos6 = [[200, 200], [300, 200], [400, 200], [
    200, 300], [300, 300], [400, 300]]  # 六个位置
rad = 50
tick = 0  # 计数器
pos = pos6[0]  # 外面记录圆的位置

# 分数
score = 0  # ！！分数计数
pygame.font.init()  # ！！初始化文字
score_font = pygame.font.SysFont('微软雅黑', 30)  # ！！设定字体和字号
score_sur = score_font.render(str(score), False, (255, 0, 0))  # ！！生成计数表面

while 1:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            sys.exit()
        elif event.type == MOUSEBUTTONDOWN:  # 如果是鼠标按下事件
            mpos = pygame.mouse.get_pos()  # 获取鼠标位置
            dis = pygame.math.Vector2(
                mpos[0]-pos[0], mpos[1]-pos[1])  # 计算坐标差
            len = pygame.math.Vector2.length(dis)  # 计算距离
            if len &amp;lt; rad:
                tick = 1000  # 立即变换位置
                score = score+1  # 计分增加

    # 每帧循环执行的代码
    if tick &amp;gt; 50:  # 每50次刷新变换一次
        score_sur = score_font.render(
            str(score), False, (255, 0, 0))  # ！！重新生成分数文字表面
        sur.fill((0, 0, 0))  # 用黑色覆盖前一帧的画面，实现刷新
        a = random.randint(0, 5)  # 随机0到5
        pos = pos6[a]  # 更新外部记录的圆的位置
        pygame.draw.circle(sur, clr, pos, 50)  # 使用随机位置
        tick = 0  # 重置计数器
    else:  # 不刷新变换的时候
        tick = tick+1  # 增加计数器

    # 刷新画面
    window.blit(sur, (0, 0))
    window.blit(score_sur, (200, 10))  # ！！增加分数表面
    pygame.display.flip()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行上面的代码，可以用鼠标点击跳动的蓝色圆，每次击中就能获得1分，实时显示在顶部。&lt;/p&gt;
&lt;p&gt;关于文字的更多内容&lt;a href=&quot;https://links.jianshu.com/go?to=https%3A%2F%2Fwww.pygame.org%2Fdocs%2Fref%2Ffont.html%3Fhighlight%3Dtext&quot;&gt;可以参考官方文档说明&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;鼠标指针变锤子&quot;&gt;鼠标指针变锤子&lt;/h2&gt;
&lt;p&gt;现在窗口中显示的仍然是鼠标，而不是锤子，下面我们来看如何把鼠标变为一个特定的图形。&lt;/p&gt;
&lt;p&gt;pygame关于鼠标控制的模块是&lt;code&gt;pygame.mouse&lt;/code&gt;，&lt;a href=&quot;https://links.jianshu.com/go?to=http%3A%2F%2Fwww.pygame.org%2Fdocs%2Fref%2Fmouse.html&quot;&gt;官方说明文档&lt;/a&gt;看这里。&lt;/p&gt;
&lt;p&gt;我们可以用&lt;code&gt;pygame.mouse.set_visible(False)&lt;/code&gt;来隐藏鼠标，但这样一来我们就看不到鼠标无法操作了。&lt;/p&gt;
&lt;p&gt;不过不要紧，我们之前还记得当鼠标点击的时候有一个&lt;code&gt;mpos = pygame.mouse.get_pos()&lt;/code&gt;可以获取当前鼠标的位置，同样我们可以在鼠标移动的时候获取鼠标的位置，然后在这个位置上画一个红色圆圈代表鼠标。&lt;/p&gt;
&lt;p&gt;测试下面的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import pygame
from pygame.locals import *

pygame.init()
window = pygame.display.set_mode([600, 400])

pygame.mouse.set_visible(False)  # 隐藏鼠标
sur = pygame.Surface([600, 400])
mpos = [300, 200]  # 记录鼠标位置

while 1:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            sys.exit()
        elif event.type == MOUSEMOTION:  # 当鼠标移动的时候
            mpos = pygame.mouse.get_pos()  # 更新鼠标位置

    sur.fill((0, 0, 0))  # 填充黑色
    pygame.draw.circle(sur, (255, 0, 0), mpos, 10)  # 在鼠标位置画红色圆
    window.blit(sur, (0, 0))
    pygame.display.flip()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行这个代码将，当鼠标划到窗口上面的时候就会有一个红点跟着鼠标移动，红点代替了原来的指针。&lt;/p&gt;
&lt;p&gt;我们把这个红点鼠标代码放入到游戏中，得到下面的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import pygame
import sys
import random
from pygame.locals import *  # 引入鼠标事件类型

pygame.init()  # 初始化
window = pygame.display.set_mode([600, 400])  # 设定窗口

sur = pygame.Surface([600, 400])  # 绘制背景容器
clr = (0, 0, 255)
pos6 = [[200, 200], [300, 200], [400, 200], [
    200, 300], [300, 300], [400, 300]]  # 六个位置
rad = 50
tick = 0  # 计数器
pos = pos6[0]  # 外面记录圆的位置

# 分数
score = 0  # 分数计数
pygame.font.init()  # 初始化文字
score_font = pygame.font.SysFont('微软雅黑', 30)  # ！！设定字体和字号
score_sur = score_font.render(str(score), False, (255, 0, 0))  # ！！生成计数表面

# 鼠标
pygame.mouse.set_visible(False)  # !!隐藏鼠标
mpos = [300, 200]  # !!记录鼠标位置

while 1:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            sys.exit()
        elif event.type == MOUSEBUTTONDOWN:  # 如果是鼠标按下事件
            mpos = pygame.mouse.get_pos()  # 获取鼠标位置
            dis = pygame.math.Vector2(
                mpos[0]-pos[0], mpos[1]-pos[1])  # 计算坐标差
            len = pygame.math.Vector2.length(dis)  # 计算距离
            if len &amp;lt; rad:
                tick = 1000  # 立即变换位置
                score = score+1  # 计分增加
        elif event.type == MOUSEMOTION:  # !!当鼠标移动的时候
            mpos = pygame.mouse.get_pos()  # !!更新鼠标位置

    # 每帧循环执行的代码
    if tick &amp;gt; 50:  # 每50次刷新变换一次
        score_sur = score_font.render(
            str(score), False, (255, 0, 0))  # 重新生成分数文字表面        
        a = random.randint(0, 5)  # 随机0到5
        pos = pos6[a]  # 更新外部记录的圆的位置        
        tick = 0  # 重置计数器
    else:  # 不刷新变换的时候
        tick = tick+1  # 增加计数器

    # 绘制鼠标
    sur.fill((0, 0, 0))  # !用黑色覆盖前一帧的画面，实现刷新
    pygame.draw.circle(sur, clr, pos, 50)  # !使用随机位置画地鼠
    pygame.draw.circle(sur, (255, 0, 0), mpos, 10)  # !!在鼠标位置画红色圆

    # 刷新画面
    window.blit(sur, (0, 0))
    window.blit(score_sur, (200, 10))  # 增加分数表面
    pygame.display.flip()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;主义者了把&lt;code&gt;sur.fill&lt;/code&gt;和原来画地鼠蓝圆的代码移到了下面，和画鼠标红点的代码放在了一起，这样把绘图内容放在一起更加合理。&lt;/p&gt;
&lt;h2 id=&quot;限定每局时间&quot;&gt;限定每局时间&lt;/h2&gt;
&lt;p&gt;我们有很多办法限定每局的长度，比如计时限定1分钟，或者限定地鼠跳出总计100次。我们这里使用第二种限制，跳出100次就结束并统计分数。&lt;/p&gt;
&lt;p&gt;添加一个计数器&lt;code&gt;times=0&lt;/code&gt;，然后每次随机位置都给它增加1，当&lt;code&gt;times&amp;gt;100&lt;/code&gt;的时候，我们就结束游戏并显示结束画面统计战果。&lt;/p&gt;
&lt;p&gt;具体的代码没有新的内容，不多解释，直接上结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import pygame
import sys
import random
from pygame.locals import *  # 引入鼠标事件类型

pygame.init()  # 初始化
window = pygame.display.set_mode([600, 400])  # 设定窗口

sur = pygame.Surface([600, 400])  # 绘制背景容器
clr = (0, 0, 255)
pos6 = [[200, 200], [300, 200], [400, 200], [
    200, 300], [300, 300], [400, 300]]  # 六个位置
rad = 50
tick = 0  # 计数器
pos = pos6[0]  # 外面记录圆的位置

# 分数
score = 0  # 分数计数
pygame.font.init()  # 初始化文字
score_font = pygame.font.SysFont('微软雅黑', 30)  # ！！设定字体和字号
score_sur = score_font.render(str(score), False, (255, 0, 0))  # ！！生成计数表面

# 鼠标
pygame.mouse.set_visible(False)  # !!隐藏鼠标
mpos = [300, 200]  # !!记录鼠标位置

times = 0  # 地鼠跳出的次数
times_max=10 #最多次数
tick_max=15 #地鼠每次跳多少帧

while 1:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            sys.exit()
        elif event.type == MOUSEBUTTONDOWN:  # 如果是鼠标按下事件
            mpos = pygame.mouse.get_pos()  # 获取鼠标位置
            dis = pygame.math.Vector2(
                mpos[0]-pos[0], mpos[1]-pos[1])  # 计算坐标差
            len = pygame.math.Vector2.length(dis)  # 计算距离
            if len &amp;lt; rad:
                tick = 1000  # 立即变换位置
                score = score+1  # 计分增加
        elif event.type == MOUSEMOTION:  # !!当鼠标移动的时候
            mpos = pygame.mouse.get_pos()  # !!更新鼠标位置

        if times &amp;gt; times_max:
            # 显示结束画面
            sur.fill((0, 0, 0))
            pygame.mouse.set_visible(True) 
            sur.fill((0, 0, 0)) 
            end_font = pygame.font.SysFont('微软雅黑', 80)  # ！！设定字体和字号
            end_sur = score_font.render(&quot;Your Score is:{}/{}！&quot;.format(score,times_max), False, (255, 0, 0))  # ！！生成计数表面
            window.blit(sur, (0, 0))
            window.blit(end_sur, (100, 100))  # 增加分数表面
            pygame.display.flip()
        else:
            # 每帧循环执行的代码
            if tick &amp;gt; tick_max:  # 每50次刷新变换一次
                times=times+1 #增加计次
                score_sur = score_font.render(
                    str(score), False, (255, 0, 0))  # 重新生成分数文字表面        
                a = random.randint(0, 5)  # 随机0到5
                pos = pos6[a]  # 更新外部记录的圆的位置        
                tick = 0  # 重置计数器
            else:  # 不刷新变换的时候
                tick = tick+1  # 增加计数器

            # 绘制鼠标
            sur.fill((0, 0, 0))  # !用黑色覆盖前一帧的画面，实现刷新
            pygame.draw.circle(sur, clr, pos, 50)  # !使用随机位置画地鼠
            pygame.draw.circle(sur, (255, 0, 0), mpos, 10)  # !!在鼠标位置画红色圆

            # 刷新画面
            window.blit(sur, (0, 0))
            window.blit(score_sur, (200, 10))  # 增加分数表面
            pygame.display.flip()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行这个代码，用鼠标点击蓝圆，蓝圆跳动10次之后结束，然后显示击中的次数。你可以通过调整&lt;code&gt;tick_max&lt;/code&gt;的数字让圆跳动的更快或更慢，调整&lt;code&gt;times_max=100&lt;/code&gt;来让地鼠跳动100次后再结束。&lt;/p&gt;
&lt;p&gt;现在我们的地鼠游戏已经有些模样了，但还都是蓝色红色的圆圈和圆点，下一篇我们来改变成为图片。&lt;/p&gt;
&lt;h2 id=&quot;中文字体&quot;&gt;中文字体&lt;/h2&gt;
&lt;p&gt;在上一节中我们只使用了英文字体，怎么显示中文字体呢？&lt;/p&gt;
&lt;p&gt;直接下载网盘里面的文件，放在你的&lt;code&gt;main.py&lt;/code&gt;一起，将原来的&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;score_font = pygame.font.SysFont('微软雅黑', 30)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;score_font = pygame.font.Font('MicrosoftYaqiHeiLight-2.ttf', 30) 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在&lt;code&gt;render&lt;/code&gt;里面使用中文就可以正常显示了：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;end_sur = score_font.render(&quot;你的得分:{}/{}！&quot;.format(score,times_max), False, (255, 0, 0))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4324074-01eca4c466d8c07b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;另外，也可以使用系统的中文字体，但是我们不清楚系统里面到底装了哪些字体，可以用&lt;code&gt;print(pygame.font.get_fonts())&lt;/code&gt;将所有系统字体都打印出来，然后只能从名字猜出哪些是中文字体了，注意系统字体还是要用&lt;code&gt;font.SysFont&lt;/code&gt;而不只是&lt;code&gt;font.Font&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;显示背景图片&quot;&gt;显示背景图片&lt;/h2&gt;
&lt;p&gt;这是我们的背景图片&lt;code&gt;dds-map.jpg&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4324074-532d3e4fcc2a384c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/600/format/webp&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以用&lt;code&gt;map=pygame.image.load('dds-map.jpg')&lt;/code&gt;把图片读取到代码里面。&lt;br/&gt;&lt;a href=&quot;https://links.jianshu.com/go?to=https%3A%2F%2Fwww.pygame.org%2Fdocs%2Fref%2Fimage.html&quot;&gt;更多官方关于图片的操作说明看这里&lt;/a&gt;&lt;br/&gt;注意&lt;code&gt;pygame.image.load()&lt;/code&gt;得到的是一个表面&lt;code&gt;surface&lt;/code&gt;，我们可以直接把它&lt;code&gt;blit&lt;/code&gt;到窗口&lt;code&gt;wind&lt;/code&gt;，也可以把它&lt;code&gt;blit&lt;/code&gt;到。&lt;/p&gt;
&lt;p&gt;这里是完整代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import pygame
import sys
import random
from pygame.locals import *  # 引入鼠标事件类型

pygame.init()  # 初始化
window = pygame.display.set_mode([600, 400])  # 设定窗口

sur = pygame.Surface([600, 400])  # 绘制背景容器
clr = (0, 0, 255)
posAll = [[100, 150], [300, 150], [500, 150], [
    200, 300], [400, 300]]  # 六个位置
rad = 50
tick = 0  # 计数器
pos = posAll[0]  # 外面记录圆的位置

# 分数
score = 0  # 分数计数
pygame.font.init()  # 初始化文字
score_font = pygame.font.Font('MicrosoftYaqiHeiLight-2.ttf', 30)  # ！！设定字体和字号
score_sur = score_font.render(str(score), False, (255, 0, 0))  # ！！生成计数表面

# 鼠标
pygame.mouse.set_visible(False)  # !!隐藏鼠标
mpos = [300, 200]  # !!记录鼠标位置

times = 0  # 地鼠跳出的次数
times_max=10 #最多次数
tick_max=30 #地鼠每次跳多少帧
map=pygame.image.load('dds-map.jpg')#！！读取图片

while 1:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            sys.exit()
        elif event.type == MOUSEBUTTONDOWN:  # 如果是鼠标按下事件
            dis = pygame.math.Vector2(
                mpos[0]-pos[0], mpos[1]-pos[1])  # 计算坐标差
            len = pygame.math.Vector2.length(dis)  # 计算距离
            if len &amp;lt; rad:
                tick = 1000  # 立即变换位置
                score = score+1  # 计分增加
        elif event.type == MOUSEMOTION:  # 当鼠标移动的时候
            mpos = pygame.mouse.get_pos()  # 更新鼠标位置        

    if times &amp;gt;= times_max:
        # 显示结束画面
        sur.fill((0, 0, 0)) #！！结束时候仍然用黑色清空画面
        pygame.mouse.set_visible(True) 
        end_font = pygame.font.Font('MicrosoftYaqiHeiLight-2.ttf',48) # ！！设定字体和字号
        end_sur = score_font.render(&quot;你的分数是:{}/{}！&quot;.format(score,times_max), True, (255, 0, 0))  # ！！生成计数表面
        window.blit(sur, (0, 0))
        window.blit(end_sur, (100, 100))  # 增加分数表面
    else:
        sur.blit(map, (0, 0)) #！！添加背景图片
        # 每帧循环执行的代码
        if tick &amp;gt; tick_max:  # 每50次刷新变换一次
            times=times+1 #增加计次
            score_sur = score_font.render(
                &quot;分数:{}/{}！&quot;.format(score,times), False, (255, 0, 0))  # 重新生成分数文字表面        
            a = random.randint(0, 4)  # 随机0到4
            pos = posAll[a]  # 更新外部记录的圆的位置        
            tick = 0  # 重置计数器
        else:  # 不刷新变换的时候
            tick = tick+1  # 增加计数器      

        # 绘制鼠标
        pygame.draw.circle(sur, clr, pos, 50)  # 使用随机位置画地鼠            
        pygame.draw.circle(sur, (255, 0, 0), mpos, 10)  # !在鼠标位置画红色圆

    # 刷新画面            
    window.blit(sur, (0, 0))
    window.blit(score_sur, (200, 10))  # 增加分数表面
    pygame.display.flip() #刷新画面
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意我们先把图片读取，然后在每帧里面决定是否使用。运行后如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4324074-88e5babd75636df8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1196/format/webp&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;使用动态图片&quot;&gt;使用动态图片&lt;/h2&gt;
&lt;p&gt;地鼠和锤子各有两个状态，正常的地鼠和被击打的地鼠，正常的锤子和砸下的锤子，如下图所示（下图无法直接使用，请从网盘下载）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4324074-3a5a83ffbcdb288d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以先把四个图片都&lt;code&gt;load&lt;/code&gt;读取进来成为&lt;code&gt;rat1,rat2,ham1,ham2&lt;/code&gt;，然后我们使用&lt;code&gt;ratsur&lt;/code&gt;和&lt;code&gt;hamsur&lt;/code&gt;表示真正要使用的表面，当鼠标按下的时候我们设定&lt;code&gt;hamsur=ham2&lt;/code&gt;是砸下图片，当鼠标点击位置距离地鼠小于地鼠半径的时候我们使用&lt;code&gt;ratsur=rat2&lt;/code&gt;被砸中的图片。最后我们再分别把地鼠和锤头&lt;code&gt;blit&lt;/code&gt;到&lt;code&gt;sur&lt;/code&gt;上面。&lt;/p&gt;
&lt;p&gt;改造后的代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import pygame
import sys
import random
from pygame.locals import *  # 引入鼠标事件类型
import time

pygame.init()  # 初始化
window = pygame.display.set_mode([600, 400])  # 设定窗口

sur = pygame.Surface([600, 400])  # 绘制背景容器
clr = (0, 0, 255)
posAll = [[100, 150], [300, 150], [500, 150], [
    200, 300], [400, 300]]  # 六个位置
rad = 50
tick = 0  # 计数器
pos = posAll[0]  # 外面记录圆的位置

# 分数
score = 0  # 分数计数
pygame.font.init()  # 初始化文字
score_font = pygame.font.Font('MicrosoftYaqiHeiLight-2.ttf', 30)  # ！！设定字体和字号
score_sur = score_font.render(str(score), False, (255, 0, 0))  # ！！生成计数表面

# 鼠标
pygame.mouse.set_visible(False)  # !!隐藏鼠标
mpos = [300, 200]  # !!记录鼠标位置

times = 0  # 地鼠跳出的次数
times_max=10 #最多次数
tick_max=30 #地鼠每次跳多少帧
map=pygame.image.load('dds-map.jpg')#！！读取图片
rat1=pygame.image.load('rat1.png')#！！读取地鼠图片
rat2=pygame.image.load('rat2.png')#！！读取被砸地鼠图片
ham1=pygame.image.load('hammer1.png')#！！读取锤子图片
ham2=pygame.image.load('hammer2.png')#！！读取砸下锤子图片

while 1:
    hamsur=ham1
    ratsur=rat1
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            sys.exit()
        elif event.type == MOUSEBUTTONDOWN:  # 如果是鼠标按下事件
            hamsur=ham2 #！！使用下落锤子
            mpos = pygame.mouse.get_pos()  # 获取鼠标位置
            dis = pygame.math.Vector2(
                mpos[0]-pos[0], mpos[1]-pos[1])  # 计算坐标差
            len = pygame.math.Vector2.length(dis)  # 计算距离
            if len &amp;lt; rad:
                tick = 1000  # 立即变换位置
                score = score+1  # 计分增加
                ratsur=rat2 #！！使用被砸地鼠
        elif event.type == MOUSEMOTION:  # 当鼠标移动的时候
            mpos = pygame.mouse.get_pos()  # 更新鼠标位置        

    if times &amp;gt;= times_max:
        # 显示结束画面
        sur.fill((0, 0, 0)) #结束时候仍然用黑色清空画面
        pygame.mouse.set_visible(True) 
        end_font = pygame.font.Font('MicrosoftYaqiHeiLight-2.ttf',48) # ！！设定字体和字号
        end_sur = score_font.render(&quot;你的分数是:{}/{}！&quot;.format(score,times_max), True, (255, 0, 0))  # ！！生成计数表面
        window.blit(sur, (0, 0))
        window.blit(end_sur, (100, 100))  # 增加分数表面
    else:
        sur.blit(map, (0, 0)) #添加背景图片
        # 每帧循环执行的代码
        if tick &amp;gt; tick_max:  # 每50次刷新变换一次
            times=times+1 #增加计次
            score_sur = score_font.render(
                &quot;分数:{}/{}！&quot;.format(score,times), False, (255, 0, 0))  # 重新生成分数文字表面        
            a = random.randint(0, 4)  # 随机0到4
            pos = posAll[a]  # 更新外部记录的圆的位置        
            tick = 0  # 重置计数器
        else:  # 不刷新变换的时候
            tick = tick+1  # 增加计数器

        sur.blit(ratsur,(pos[0]-50,pos[1]-70)) #绘制地鼠
        sur.blit(hamsur,(mpos[0]-50,mpos[1]-100)) #绘制锤头

    # 刷新画面            
    window.blit(sur, (0, 0))
    window.blit(score_sur, (200, 10))  # 增加分数表面
    pygame.display.flip() #刷新画面
    time.sleep(0.04) #！！保持画面一点时间
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意这里的&lt;code&gt;import time&lt;/code&gt;和&lt;code&gt;time.sleep(0.04)&lt;/code&gt;这是让每一帧停留一点点时间，0.04秒，每秒25帧（假设每帧画图不需要时间的话）。&lt;br/&gt;另外我们再&lt;code&gt;blit&lt;/code&gt;的时候使用了&lt;code&gt;(pos[0]-50,pos[1]-50)&lt;/code&gt;这样的偏移，因为图片总是用左上角作为位置的起点，这样偏移之后就变到了图片中心，实际上我们又故意让地鼠和锤子更高一些，就使用了&lt;code&gt;(pos[0]-50,pos[1]-70)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;运行之后的样子如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4324074-a0f6065e77146cb5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;让游戏重新开始&quot;&gt;让游戏重新开始&lt;/h2&gt;
&lt;p&gt;每次显示最终成绩之后，能不能让游戏3秒后重新开始呢？&lt;/p&gt;
&lt;p&gt;我们设定一个&lt;code&gt;gameover=0&lt;/code&gt;，游戏结束后每帧都增加这个数字，如果&lt;code&gt;gameover&amp;gt;100&lt;/code&gt;，就是过了100帧，那么我们就重新开始。&lt;br/&gt;重新开始必须意味着各种数据（分数，计时什么的）和画面都要重置到原来的状态。&lt;br/&gt;修改后的整体代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import pygame
import sys
import random
from pygame.locals import *  # 引入鼠标事件类型
import time

pygame.init()  # 初始化
window = pygame.display.set_mode([600, 400])  # 设定窗口

sur = pygame.Surface([600, 400])  # 绘制背景容器
clr = (0, 0, 255)
posAll = [[100, 150], [300, 150], [500, 150], [200, 300], [400, 300]]  # 六个位置
rad = 50
tick = 0  # 计数器
pos = posAll[0]  # 外面记录圆的位置

# 分数
score = 0  # 分数计数
pygame.font.init()  # 初始化文字
score_font = pygame.font.Font(&quot;MicrosoftYaqiHeiLight-2.ttf&quot;, 30)  # ！！设定字体和字号
score_sur = score_font.render(str(score), False, (255, 0, 0))  # ！！生成计数表面

# 鼠标
pygame.mouse.set_visible(False)  # !!隐藏鼠标
mpos = [300, 200]  # !!记录鼠标位置

times = 0  # 地鼠跳出的次数
times_max = 10  # 最多次数
tick_max = 30  # 地鼠每次跳多少帧
map = pygame.image.load(&quot;dds-map.jpg&quot;)  # ！！读取图片
rat1 = pygame.image.load(&quot;rat1.png&quot;)  # ！！读取地鼠图片
rat2 = pygame.image.load(&quot;rat2.png&quot;)  # ！！读取被砸地鼠图片
ham1 = pygame.image.load(&quot;hammer1.png&quot;)  # ！！读取锤子图片
ham2 = pygame.image.load(&quot;hammer2.png&quot;)  # ！！读取砸下锤子图片

gameover = 0 #！！结束计时
gameover_max = 100 #！！结束计时最大值，超过这个值就重新开始

while 1:
    hamsur = ham1
    ratsur = rat1
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            sys.exit()
        elif event.type == MOUSEBUTTONDOWN:  # 如果是鼠标按下事件
            hamsur = ham2  # ！！使用下落锤子
            mpos = pygame.mouse.get_pos()  # 获取鼠标位置
            dis = pygame.math.Vector2(mpos[0] - pos[0], mpos[1] - pos[1])  # 计算坐标差
            len = pygame.math.Vector2.length(dis)  # 计算距离
            if len &amp;lt; rad:
                tick = 1000  # 立即变换位置
                score = score + 1  # 计分增加
                ratsur = rat2  # ！！使用被砸地鼠
        elif event.type == MOUSEMOTION:  # 当鼠标移动的时候
            mpos = pygame.mouse.get_pos()  # 更新鼠标位置

    if times &amp;gt;= times_max:
        # 显示结束画面
        sur.fill((0, 0, 0))  # 结束时候仍然用黑色清空画面
        pygame.mouse.set_visible(True)
        end_font = pygame.font.Font(&quot;MicrosoftYaqiHeiLight-2.ttf&quot;, 48)  # ！！设定字体和字号
        end_sur = score_font.render(
            &quot;你的分数是:{}/{}！&quot;.format(score, times_max), True, (255, 0, 0)
        )  # ！！生成计数表面
        sur.blit(end_sur, (100, 150))
        cd = int((gameover_max - gameover) / 10)
        cd_sur = score_font.render(
            &quot;重新开始倒计时{}&quot;.format(cd), True, (255, 0, 0)
        )  # ！！生成计数表面
        sur.blit(cd_sur, (100, 200))  # 增加分数表面
        gameover = gameover + 1 #！！增加结束计时
    else:
        sur.blit(map, (0, 0))  # 添加背景图片
        score_sur = score_font.render(
            &quot;分数:{}/{}！&quot;.format(score, times + 1), False, (255, 0, 0)
        )  # 重新生成分数文字表面
        sur.blit(score_sur, (200, 10))  # 增加分数表面
        if tick &amp;gt; tick_max:  # 每50次刷新变换一次
            times = times + 1  # 增加计次
            a = random.randint(0, 4)  # 随机0到4
            pos = posAll[a]  # 更新外部记录的圆的位置
            tick = 0  # 重置计数器
        else:  # 不刷新变换的时候
            tick = tick + 1  # 增加计数器
        if tick &amp;gt; 5:  # 开始几帧不显示地鼠
            sur.blit(ratsur, (pos[0] - 50, pos[1] - 70))  # 绘制地鼠
        sur.blit(hamsur, (mpos[0] - 50, mpos[1] - 100))  # 绘制锤头

    # 刷新画面
    window.blit(sur, (0, 0))
    pygame.display.flip()  # 刷新画面
    time.sleep(0.04)  # ！！保持画面一点时间

    # ！！重置游戏
    if gameover &amp;gt; gameover_max:
        pygame.mouse.set_visible(False)
        times = 0
        score = 0
        gameover = 0
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行这个代码就能反复玩游戏了。&lt;br/&gt;到这里游戏看上去好了很多，但是还没有背景音乐，打地鼠的时候也没有音效，下一节我们继续添加声音。&lt;/p&gt;
&lt;h2 id=&quot;添加音效&quot;&gt;添加音效&lt;/h2&gt;
&lt;p&gt;游戏里面的声音分为两种，一种叫音乐music，另一种叫音效sound。背景音乐是music，游戏里面的击打声点击声都是音效。同一时间播放的音乐一般只有一个，但音效可以有很多个同时播放。&lt;/p&gt;
&lt;p&gt;pygame可以使用&lt;code&gt;pygame.mixer.music.load('bg.mp3')&lt;/code&gt;来载入foo.mp3音乐，然后&lt;code&gt;pygame.mixer.music.play(0)&lt;/code&gt;就可以播放，这里0表示播放1次，如果要无限次的播放则要改为-1.&lt;/p&gt;
&lt;p&gt;但是如果要播放音效sound，那么pygame里面只能使用wav格式（并且不支持32位深，只支持16位深）。载入音效的方法是&lt;code&gt;sd=pygame.mixer.Sound(&quot;hit.wav&quot;)&lt;/code&gt;，播放是&lt;code&gt;sd.play(0)&lt;/code&gt;，这里0也是1次，一般音效不需要连续播放。&lt;/p&gt;
&lt;p&gt;我们在游戏一开始就可以播放背景音乐了，但只有在点击鼠标&lt;code&gt;event.type == MOUSEBUTTONDOWN&lt;/code&gt;的时候才播放锤子的声音，只有在击中地鼠的时候才播放地鼠的叫声。&lt;/p&gt;
&lt;p&gt;修改之后的代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import pygame
import sys
import random
from pygame.locals import *  # 引入鼠标事件类型
import time

pygame.init()  # 初始化
window = pygame.display.set_mode([600, 400])  # 设定窗口

sur = pygame.Surface([600, 400])  # 绘制背景容器
clr = (0, 0, 255)
posAll = [[100, 150], [300, 150], [500, 150], [200, 300], [400, 300]]  # 六个位置
rad = 50
tick = 0  # 计数器
pos = posAll[0]  # 外面记录圆的位置

# 分数
score = 0  # 分数计数
pygame.font.init()  # 初始化文字
score_font = pygame.font.Font(&quot;MicrosoftYaqiHeiLight-2.ttf&quot;, 30)  # ！！设定字体和字号
score_sur = score_font.render(str(score), False, (255, 0, 0))  # ！！生成计数表面

# 鼠标
pygame.mouse.set_visible(False)  # !!隐藏鼠标
mpos = [300, 200]  # !!记录鼠标位置

times = 0  # 地鼠跳出的次数
times_max = 10  # 最多次数
tick_max = 30  # 地鼠每次跳多少帧
map = pygame.image.load(&quot;dds-map.jpg&quot;)  # ！！读取图片
rat1 = pygame.image.load(&quot;rat1.png&quot;)  # ！！读取地鼠图片
rat2 = pygame.image.load(&quot;rat2.png&quot;)  # ！！读取被砸地鼠图片
ham1 = pygame.image.load(&quot;hammer1.png&quot;)  # ！！读取锤子图片
ham2 = pygame.image.load(&quot;hammer2.png&quot;)  # ！！读取砸下锤子图片

gameover = 0  # ！！结束计时
gameover_max = 100  # ！！结束计时最大值，超过这个值就重新开始

# 音乐和音效
pygame.mixer.music.load(&quot;bg.mp3&quot;)  # ！！载入背景音乐
pygame.mixer.music.play(-1)  # ！！无限播放背景音乐
hitsound = pygame.mixer.Sound(&quot;hit.wav&quot;)  # ！！载入击打声音
hurtsound = pygame.mixer.Sound(&quot;aiyo2.wav&quot;)  # ！！载入地鼠叫声

while 1:
    hamsur = ham1
    ratsur = rat1
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            sys.exit()
        elif event.type == MOUSEBUTTONDOWN:  # 如果是鼠标按下事件
            hamsur = ham2  # 使用下落锤子
            hitsound.play()  # ！！播放击打声音
            mpos = pygame.mouse.get_pos()  # 获取鼠标位置
            dis = pygame.math.Vector2(mpos[0] - pos[0], mpos[1] - pos[1])  # 计算坐标差
            len = pygame.math.Vector2.length(dis)  # 计算距离
            if len &amp;lt; rad:
                tick = 1000  # 立即变换位置
                score = score + 1  # 计分增加
                ratsur = rat2  # 使用被砸地鼠
                hurtsound.play()  # ！！播放地鼠声音
        elif event.type == MOUSEMOTION:  # 当鼠标移动的时候
            mpos = pygame.mouse.get_pos()  # 更新鼠标位置

    if times &amp;gt;= times_max:
        # 显示结束画面
        sur.fill((0, 0, 0))  # 结束时候仍然用黑色清空画面
        pygame.mouse.set_visible(True)
        end_font = pygame.font.Font(&quot;MicrosoftYaqiHeiLight-2.ttf&quot;, 48)  # 设定字体和字号
        end_sur = score_font.render(
            &quot;你的分数是:{}/{}！&quot;.format(score, times_max), True, (255, 0, 0)
        )  # 生成计数表面
        sur.blit(end_sur, (100, 150))
        cd = int((gameover_max - gameover) / 10)
        cd_sur = score_font.render(
            &quot;重新开始倒计时{}&quot;.format(cd), True, (255, 0, 0)
        )  # 生成计数表面
        sur.blit(cd_sur, (100, 200))  # 增加分数表面
        gameover = gameover + 1  # ！！增加结束计时
    else:
        sur.blit(map, (0, 0))  # 添加背景图片
        score_sur = score_font.render(
            &quot;分数:{}/{}！&quot;.format(score, times + 1), False, (255, 0, 0)
        )  # 重新生成分数文字表面
        sur.blit(score_sur, (200, 10))  # 增加分数表面
        if tick &amp;gt; tick_max:  # 每50次刷新变换一次
            times = times + 1  # 增加计次
            a = random.randint(0, 4)  # 随机0到4
            pos = posAll[a]  # 更新外部记录的圆的位置
            tick = 0  # 重置计数器
        else:  # 不刷新变换的时候
            tick = tick + 1  # 增加计数器
        if tick &amp;gt; 5:  # 开始几帧不显示地鼠
            sur.blit(ratsur, (pos[0] - 50, pos[1] - 70))  # 绘制地鼠
        sur.blit(hamsur, (mpos[0] - 50, mpos[1] - 100))  # 绘制锤头

    # 刷新画面
    window.blit(sur, (0, 0))
    pygame.display.flip()  # 刷新画面
    time.sleep(0.04)  # 保持画面一点时间

    # 重置游戏
    if gameover &amp;gt; gameover_max:
        pygame.mouse.set_visible(False)
        times = 0
        score = 0
        gameover = 0
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行上面的代码，可以听到欢快的背景音乐，点击鼠标时候会有捶地声音，打中地鼠会有哎呦的叫声。&lt;/p&gt;
&lt;h2 id=&quot;发布软件&quot;&gt;发布软件&lt;/h2&gt;
&lt;p&gt;我们写的代码目前只能在自己的电脑上运行，因为我们先要安装python，然后还要安装pygame才行，这和我们平常下载的软件不同，下载的软件可以直接运行（或者安装自身后运行）。&lt;/p&gt;
&lt;p&gt;Python给我们提供了自动把代码打包成软件的工具，Windows下推荐使用auto-py-to-exe工具。同样先安装&lt;code&gt;pip install auto-py-to-exe&lt;/code&gt;,然后只要执行&lt;code&gt;auto-py-to-exe&lt;/code&gt;就会打开一个窗口。&lt;/p&gt;
&lt;p&gt;基本设置如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4324074-a1c7eb2d49fe4c76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/634/format/webp&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意几个地方：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Script Location要指向你的主要.py文件，这里是&lt;code&gt;main.py&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Onefile选One Directory，这会把生产的所有文件放在一个文件夹中&lt;/li&gt;
&lt;li&gt;Console Window选Console Based，因为我们的pygame是基于控制台的&lt;/li&gt;
&lt;li&gt;Icon图标，你可以在网上下载&lt;code&gt;.ico&lt;/code&gt;文件，比如&lt;a href=&quot;https://links.jianshu.com/go?to=https%3A%2F%2Fwww.easyicon.net%2F&quot;&gt;easyicon&lt;/a&gt;有很多，网盘里面有一个地鼠图标&lt;code&gt;icon.ico&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Additional Files附加文件，点击Add Files按钮要把全部用到的字体、图片、声音都选择&lt;/li&gt;
&lt;li&gt;CONVERT .PY TO .EXE点击这个按钮进行生成，生成后会变为两个蓝色按钮&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4324074-60c0b8b58346ab7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/634/format/webp&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击OPEN OUTPUT FOLDER打开生产的软件目录（默认在你的代码文件夹下面的output文件夹内），找到那个和你的Script Location同名的文件，点击它就可以运行游戏了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4324074-25566871b37fa91a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/639/format/webp&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也可以把这个MAIN.exe复制然后在桌面上粘贴快捷方式，以后只要点这个快捷方式就可以了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4324074-6fd83c6592f0710b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/460/format/webp&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在网盘文件中包含一个main.rar文件，下载它然后解压就可以得到我打包生成的软件了。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;关于Mac苹果电脑下面生成软件的方法暂时遇到一点麻烦，搞定之后再更新，敬请关注。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;第一个小游戏似乎开发完成了，但是还有很多内容，我们的代码也有很多不合理的地方，下一篇我们一起来回顾和整理，并且继续介绍更多小游戏的开发方法。&lt;/p&gt;
&lt;h2 id=&quot;添加音效-1&quot;&gt;添加音效&lt;/h2&gt;
&lt;p&gt;游戏里面的声音分为两种，一种叫音乐music，另一种叫音效sound。背景音乐是music，游戏里面的击打声点击声都是音效。同一时间播放的音乐一般只有一个，但音效可以有很多个同时播放。&lt;/p&gt;
&lt;p&gt;pygame可以使用&lt;code&gt;pygame.mixer.music.load('bg.mp3')&lt;/code&gt;来载入foo.mp3音乐，然后&lt;code&gt;pygame.mixer.music.play(0)&lt;/code&gt;就可以播放，这里0表示播放1次，如果要无限次的播放则要改为-1.&lt;/p&gt;
&lt;p&gt;但是如果要播放音效sound，那么pygame里面只能使用wav格式（并且不支持32位深，只支持16位深）。载入音效的方法是&lt;code&gt;sd=pygame.mixer.Sound(&quot;hit.wav&quot;)&lt;/code&gt;，播放是&lt;code&gt;sd.play(0)&lt;/code&gt;，这里0也是1次，一般音效不需要连续播放。&lt;/p&gt;
&lt;p&gt;我们在游戏一开始就可以播放背景音乐了，但只有在点击鼠标&lt;code&gt;event.type == MOUSEBUTTONDOWN&lt;/code&gt;的时候才播放锤子的声音，只有在击中地鼠的时候才播放地鼠的叫声。&lt;/p&gt;
&lt;p&gt;修改之后的代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import pygame
import sys
import random
from pygame.locals import *  # 引入鼠标事件类型
import time

pygame.init()  # 初始化
window = pygame.display.set_mode([600, 400])  # 设定窗口

sur = pygame.Surface([600, 400])  # 绘制背景容器
clr = (0, 0, 255)
posAll = [[100, 150], [300, 150], [500, 150], [200, 300], [400, 300]]  # 六个位置
rad = 50
tick = 0  # 计数器
pos = posAll[0]  # 外面记录圆的位置

# 分数
score = 0  # 分数计数
pygame.font.init()  # 初始化文字
score_font = pygame.font.Font(&quot;MicrosoftYaqiHeiLight-2.ttf&quot;, 30)  # ！！设定字体和字号
score_sur = score_font.render(str(score), False, (255, 0, 0))  # ！！生成计数表面

# 鼠标
pygame.mouse.set_visible(False)  # !!隐藏鼠标
mpos = [300, 200]  # !!记录鼠标位置

times = 0  # 地鼠跳出的次数
times_max = 10  # 最多次数
tick_max = 30  # 地鼠每次跳多少帧
map = pygame.image.load(&quot;dds-map.jpg&quot;)  # ！！读取图片
rat1 = pygame.image.load(&quot;rat1.png&quot;)  # ！！读取地鼠图片
rat2 = pygame.image.load(&quot;rat2.png&quot;)  # ！！读取被砸地鼠图片
ham1 = pygame.image.load(&quot;hammer1.png&quot;)  # ！！读取锤子图片
ham2 = pygame.image.load(&quot;hammer2.png&quot;)  # ！！读取砸下锤子图片

gameover = 0  # ！！结束计时
gameover_max = 100  # ！！结束计时最大值，超过这个值就重新开始

# 音乐和音效
pygame.mixer.music.load(&quot;bg.mp3&quot;)  # ！！载入背景音乐
pygame.mixer.music.play(-1)  # ！！无限播放背景音乐
hitsound = pygame.mixer.Sound(&quot;hit.wav&quot;)  # ！！载入击打声音
hurtsound = pygame.mixer.Sound(&quot;aiyo2.wav&quot;)  # ！！载入地鼠叫声

while 1:
    hamsur = ham1
    ratsur = rat1
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            sys.exit()
        elif event.type == MOUSEBUTTONDOWN:  # 如果是鼠标按下事件
            hamsur = ham2  # 使用下落锤子
            hitsound.play()  # ！！播放击打声音
            mpos = pygame.mouse.get_pos()  # 获取鼠标位置
            dis = pygame.math.Vector2(mpos[0] - pos[0], mpos[1] - pos[1])  # 计算坐标差
            len = pygame.math.Vector2.length(dis)  # 计算距离
            if len &amp;lt; rad:
                tick = 1000  # 立即变换位置
                score = score + 1  # 计分增加
                ratsur = rat2  # 使用被砸地鼠
                hurtsound.play()  # ！！播放地鼠声音
        elif event.type == MOUSEMOTION:  # 当鼠标移动的时候
            mpos = pygame.mouse.get_pos()  # 更新鼠标位置

    if times &amp;gt;= times_max:
        # 显示结束画面
        sur.fill((0, 0, 0))  # 结束时候仍然用黑色清空画面
        pygame.mouse.set_visible(True)
        end_font = pygame.font.Font(&quot;MicrosoftYaqiHeiLight-2.ttf&quot;, 48)  # 设定字体和字号
        end_sur = score_font.render(
            &quot;你的分数是:{}/{}！&quot;.format(score, times_max), True, (255, 0, 0)
        )  # 生成计数表面
        sur.blit(end_sur, (100, 150))
        cd = int((gameover_max - gameover) / 10)
        cd_sur = score_font.render(
            &quot;重新开始倒计时{}&quot;.format(cd), True, (255, 0, 0)
        )  # 生成计数表面
        sur.blit(cd_sur, (100, 200))  # 增加分数表面
        gameover = gameover + 1  # ！！增加结束计时
    else:
        sur.blit(map, (0, 0))  # 添加背景图片
        score_sur = score_font.render(
            &quot;分数:{}/{}！&quot;.format(score, times + 1), False, (255, 0, 0)
        )  # 重新生成分数文字表面
        sur.blit(score_sur, (200, 10))  # 增加分数表面
        if tick &amp;gt; tick_max:  # 每50次刷新变换一次
            times = times + 1  # 增加计次
            a = random.randint(0, 4)  # 随机0到4
            pos = posAll[a]  # 更新外部记录的圆的位置
            tick = 0  # 重置计数器
        else:  # 不刷新变换的时候
            tick = tick + 1  # 增加计数器
        if tick &amp;gt; 5:  # 开始几帧不显示地鼠
            sur.blit(ratsur, (pos[0] - 50, pos[1] - 70))  # 绘制地鼠
        sur.blit(hamsur, (mpos[0] - 50, mpos[1] - 100))  # 绘制锤头

    # 刷新画面
    window.blit(sur, (0, 0))
    pygame.display.flip()  # 刷新画面
    time.sleep(0.04)  # 保持画面一点时间

    # 重置游戏
    if gameover &amp;gt; gameover_max:
        pygame.mouse.set_visible(False)
        times = 0
        score = 0
        gameover = 0
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行上面的代码，可以听到欢快的背景音乐，点击鼠标时候会有捶地声音，打中地鼠会有哎呦的叫声。&lt;/p&gt;
</description>
<pubDate>Sat, 30 Nov 2019 14:20:00 +0000</pubDate>
<dc:creator>CoXie带你学编程</dc:creator>
<og:description>如果你没有任何编程经验，而且想尝试一下学习编程开发，这个系列教程一定适合你，它将带你学习最基本的Python语法，并让你掌握小游戏的开发技巧。你所需要的，就是付出一些时间和耐心来尝试这些代码和操作。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/CoXieLearnPython/p/11964266.html</dc:identifier>
</item>
</channel>
</rss>