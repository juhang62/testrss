<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>老牌开源Office操作组件NPOI现已支持.NET Core - 依乐祝</title>
<link>http://www.cnblogs.com/yilezhu/p/10269281.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yilezhu/p/10269281.html</guid>
<description>&lt;p&gt;昨天在微信群里听到老牌Excel开发利器NPOI的作者瞿总说4.6.1版本的NPOI已经支持.NET Standard 2.0了，这也就意味着你可以在.NET Core中使用NPOI了。&lt;/p&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;p&gt;曾经的.NET Framework时代就很喜欢使用这个组件来对Excel的进行操作，可是随着.NET Core时代的到来以及NPOI不支持.NET Core所以就找到了园子里的大神杨晓东对NPOI的.NET Core的移植版，可是使用的过程中的如果对这个移植的插件进行深入的使用的话还是有部分问题，可能正如杨晓东大神自己所说：“去年的那个版本是针对于 .NET Core 1.0 的，从发布截止现在在 NuGet 大概有 2K 多的下载量，说明还是有很多同学在使用 NPOI 的，社区中也得到了很多同学的推广。 但是上一个移植的版本也有诸多缺陷和 bug，在 Github 上也收到了一些 Issue 进行反馈，很多 Bug 可能是移植过程中的bug，但是对于这些 Bug 可能我也无能为力，因为 NPOI 的代码是非常庞大和复杂的。”&lt;br/&gt;不过也再次特别感谢下杨晓东大神对NPOI的.NET Core版本的移植也才能让我们在.NET Core1.0以及.NET Core2.0的一段时间内继续使用这个NPOI。&lt;/p&gt;
&lt;p&gt;因此在得知NPOI的作者瞿总已经完成对NPOI的升级并支持.NET Standard 2.0后特此把这个好消息告诉全体.NET Core开发者们。自此我们又可以尽情的在.NET Core中继续使用这个开源的老牌Office组件了！反正我表示挺开心的！而且如果你在使用的过程中有任何问题都可以在GitHub上对作者提issue，作者也会以迅雷不及掩耳之势之势进行修复&lt;/p&gt;
&lt;h2 id=&quot;什么是npoi&quot;&gt;什么是NPOI&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201901/1377250-20190114215319632-207605111.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;说了半天NPOI已经可以在.NET Core中使用了，可能对于新手朋友还是不知道这玩意究竟是什么？其实你可以看看百度百科《&lt;a href=&quot;https://baike.baidu.com/item/NPOI/10374941&quot;&gt;NPOI&lt;/a&gt;》里面有详细的讲述。我只能跟你说使用 NPOI 你就可以在没有安装 Office 或者相应环境的机器上对 WORD/EXCEL 文档进行读写操作，十分方便。&lt;/p&gt;
&lt;p&gt;另外NPOI的原作者的GitHub地址是：https://github.com/tonyqus/npoi&lt;/p&gt;
&lt;p&gt;里面也有详尽的描述&lt;/p&gt;
&lt;h2 id=&quot;如何使用&quot;&gt;如何使用&lt;/h2&gt;
&lt;p&gt;通过Nuget直接添加NPOI的最新引用即可使用&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;Install-Package NPOI -Version 2.4.1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后你就可用像之前一样进行操作了！&lt;/p&gt;
&lt;p&gt;但是如果你想运行在Linux上可能需要注意一下：&lt;/p&gt;
&lt;p&gt;由于NPOI使用System.Drawing.Common，因此必须在Linux系统上安装libgdiplus和libc6。&lt;/p&gt;
&lt;p&gt;Ubuntu 16.04及以上&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;apt-get install libgdiplus libc6-dev

ln -s /usr/lib/libgdiplus.so /usr/lib/gdiplus.dll&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后就可以在Linux系统上跑起来了！&lt;/p&gt;
&lt;h2 id=&quot;例子&quot;&gt;例子&lt;/h2&gt;
&lt;p&gt;我们有很多例子可供您学习如何使用NPOI。&lt;/p&gt;
&lt;p&gt;请查看&lt;a href=&quot;https://github.com/tonyqus/npoi/tree/master/examples&quot; class=&quot;uri&quot;&gt;https://github.com/tonyqus/npoi/tree/master/examples&lt;/a&gt;。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;HSSF&lt;/td&gt;
&lt;td&gt;有关Excel 97-2003格式的示例（* .xls）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;XSSF&lt;/td&gt;
&lt;td&gt;有关Excel 2007+格式的示例（* .xlsx）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;XWPF&lt;/td&gt;
&lt;td&gt;有关Word 2007+格式（* .docx）的示例&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;POIFS&lt;/td&gt;
&lt;td&gt;关于OLE2文档/ ActiveX文档的示例&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;OOXML&lt;/td&gt;
&lt;td&gt;有关OpenXML文件的示例&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;第三方博客&quot;&gt;第三方博客&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.codeproject.com/Articles/1241654/Export-to-Excel-using-NPOI-Csharp-and-WEB-API&quot;&gt;使用NPOI - C＃和WEB API导出到Excel&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.zachhunter.com/2010/05/getting-started-with-npoi/&quot;&gt;使用NPOI在.NET中构建漂亮的XLS文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.kunal-chowdhury.com/2017/07/npoi-excel-2007.html&quot;&gt;如何使用NPOI阅读Excel 2007文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://steemit.com/utopian-io/@haig/how-to-create-excel-spreadsheets-using-npoi&quot;&gt;如何使用NPOI创建Excel电子表格&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.leniel.net/2014/04/npoi-2.0-converting-transforming-excel-xls-documents-to-html-format.html&quot;&gt;NPOI 2.0 - 将Excel XLS文档转换为HTML格式&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.leniel.net/2009/10/npoi-with-excel-table-and-dynamic-chart.html&quot;&gt;NPOI与Excel表和动态图表&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;今天给大家介绍了一款.NET Core Office开发利器NPOI已经支持.NET Core了！希望对大家有所帮助！今后我们的实战教程之CMS系统里面对Excel的操作也将使用这个组件，届时我讲实战讲解如何使用这个组件，最后感谢大家的阅读。&lt;/p&gt;
</description>
<pubDate>Mon, 14 Jan 2019 23:30:00 +0000</pubDate>
<dc:creator>依乐祝</dc:creator>
<og:description>昨天在微信群里听到老牌Excel开发利器NPOI的作者瞿总说4.6.1版本的NPOI已经支持.NET Standard 2.0了，这也就意味着你可以在.NET Core中使用NPOI了。 写在前面 曾</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yilezhu/p/10269281.html</dc:identifier>
</item>
<item>
<title>bzoj 2724【蒲公英】 - UnicornXi</title>
<link>http://www.cnblogs.com/kgxw0430/p/10269175.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kgxw0430/p/10269175.html</guid>
<description>&lt;p&gt;　　啊，题目比较冗余，直接一句题意：求任意区间众数。&lt;/p&gt;
&lt;p&gt;　　俗话说得好，面向数据编程。这道题在洛谷和bzoj上的数据都是比较友好的，n&amp;lt;=40000，m&amp;lt;=50000。那不是挺容易吗！&lt;/p&gt;
&lt;p&gt;　　首先确定一点，本题强制在线，所以就不要去想一些乱七八糟的离线算法了。区间众数这种不满足区间加减性质的，又不能写线段树合并这类数据结构，很显然是暴力分块啊。我们先假设n这个序列平均分为T个块，然后对于每一个块（这个块也可以是任意一段连续块组成的）存一个块内众数以及每个数在块内出现的次数，显然复杂度是NT^2的，并且空间也是一样。然后考虑任意一个区间l，r我们怎么求区间众数。首先我们找到l，r包含的一段最长连续块，这个块内的众数我们直接知道了，然后左边和右边会残留有一些不在块内的多余部分，其实区间l，r的众数只有可能是当前块内众数或者这些多余的数中的某一个，所以我们只需要把多余的数依次扫一遍，累加到块内每个数出现的次数上，看能否更新众数。在求得答案之后，再重新扫一遍把修改的次数改回来。这样的话，因为左右两边多余的数不可能超过N/T个，那么查询的复杂度是N/T*M的，然后总的复杂度就是NT^2+N/T*M，然后我们利用一点均值不等式的思路，让两个尽量相等达到最优复杂度，求得T≈M^(1/3)，整个算法复杂度就是O（N^(5/3)）级别的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;81&quot;&gt;
&lt;pre&gt;
#include&amp;lt;iostream&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;cstdio&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;cstring&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;algorithm&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;cmath&amp;gt;
&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; N=&lt;span&gt;41000&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; T=&lt;span&gt;1600&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; t,n,m,lan,pos,ans,maxx,S,p,q,a[&lt;span&gt;41000&lt;/span&gt;],b[&lt;span&gt;41000&lt;/span&gt;],c[&lt;span&gt;40&lt;/span&gt;],sum[&lt;span&gt;1600&lt;/span&gt;][&lt;span&gt;41000&lt;/span&gt;],most[&lt;span&gt;1600&lt;/span&gt;],temp[&lt;span&gt;41000&lt;/span&gt;],maxn[&lt;span&gt;1600&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; discrete(){
    sort(b&lt;/span&gt;+&lt;span&gt;1&lt;/span&gt;,b+n+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; sz=unique(b+&lt;span&gt;1&lt;/span&gt;,b+n+&lt;span&gt;1&lt;/span&gt;)-b-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=n;++i) a[i]=lower_bound(b+&lt;span&gt;1&lt;/span&gt;,b+sz+&lt;span&gt;1&lt;/span&gt;,a[i])-&lt;span&gt;b;
}
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; ask(&lt;span&gt;int&lt;/span&gt; l,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; r){
    l&lt;/span&gt;=(l+lan-&lt;span&gt;1&lt;/span&gt;)%n+&lt;span&gt;1&lt;/span&gt;;r=(r+lan-&lt;span&gt;1&lt;/span&gt;)%n+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(l&amp;gt;&lt;span&gt;r) swap(l,r);
    p&lt;/span&gt;=l/S,q=r/&lt;span&gt;S;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(l%S==&lt;span&gt;1&lt;/span&gt;) p++&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(l%S) p+=&lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; p++&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(q-p&amp;lt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;){
        maxx&lt;/span&gt;=&lt;span&gt;0&lt;/span&gt;,ans=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=l;i&amp;lt;=r;++&lt;span&gt;i){
            temp[a[i]]&lt;/span&gt;++&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(temp[a[i]]&amp;gt;maxx) maxx=temp[a[i]],ans=&lt;span&gt;a[i];
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(temp[a[i]]==maxx&amp;amp;&amp;amp;b[a[i]]&amp;lt;b[ans]) ans=&lt;span&gt;a[i];
        }
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=l;i&amp;lt;=r;++i) temp[a[i]]--&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; b[ans];
    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
        pos&lt;/span&gt;=c[p-&lt;span&gt;1&lt;/span&gt;]+q-p+&lt;span&gt;1&lt;/span&gt;;ans=most[pos],maxx=&lt;span&gt;maxn[pos];
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=l;i&amp;lt;=S*(p-&lt;span&gt;1&lt;/span&gt;);++&lt;span&gt;i){
            sum[pos][a[i]]&lt;/span&gt;++&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(sum[pos][a[i]]&amp;gt;maxx) maxx=sum[pos][a[i]],ans=&lt;span&gt;a[i];
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(sum[pos][a[i]]==maxx&amp;amp;&amp;amp;b[ans]&amp;gt;b[a[i]]) ans=&lt;span&gt;a[i];
        }
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=S*q+&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=r;++&lt;span&gt;i){
            sum[pos][a[i]]&lt;/span&gt;++&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(sum[pos][a[i]]&amp;gt;maxx) maxx=sum[pos][a[i]],ans=&lt;span&gt;a[i];
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(sum[pos][a[i]]==maxx&amp;amp;&amp;amp;b[ans]&amp;gt;b[a[i]]) ans=&lt;span&gt;a[i];
        }
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=l;i&amp;lt;=S*(p-&lt;span&gt;1&lt;/span&gt;);++i) sum[pos][a[i]]--&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=S*q+&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=r;++i) sum[pos][a[i]]--&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; b[ans];
    }
}
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main(){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;freopen(&quot;h.in&quot;,&quot;r&quot;,stdin);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;freopen(&quot;h.out&quot;,&quot;w&quot;,stdout);&lt;/span&gt;
    scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;n,&amp;amp;&lt;span&gt;m);
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=n;++i) scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;a[i]),b[i]=&lt;span&gt;a[i];
    discrete();
    t&lt;/span&gt;=pow(&lt;span&gt;1.0&lt;/span&gt;*n,&lt;span&gt;1.0&lt;/span&gt;/&lt;span&gt;3.0&lt;/span&gt;);S=n/&lt;span&gt;t;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=t;++i) c[i]=c[i-&lt;span&gt;1&lt;/span&gt;],c[i]+=t-i+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=t;++&lt;span&gt;i){
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; j=&lt;span&gt;1&lt;/span&gt;;j&amp;lt;=t-i+&lt;span&gt;1&lt;/span&gt;;++&lt;span&gt;j){
            pos&lt;/span&gt;=c[i-&lt;span&gt;1&lt;/span&gt;]+j;maxx=&lt;span&gt;0&lt;/span&gt;,ans=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; k=(i-&lt;span&gt;1&lt;/span&gt;)*S+&lt;span&gt;1&lt;/span&gt;;k&amp;lt;=S*(i+j-&lt;span&gt;1&lt;/span&gt;);++&lt;span&gt;k){
                sum[pos][a[k]]&lt;/span&gt;++&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(sum[pos][a[k]]&amp;gt;maxx) maxx=sum[pos][a[k]],ans=&lt;span&gt;a[k];
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(sum[pos][a[k]]==maxx&amp;amp;&amp;amp;b[a[k]]&amp;lt;b[ans]) ans=&lt;span&gt;a[k];
            }
            most[pos]&lt;/span&gt;=ans,maxn[pos]=&lt;span&gt;maxx;
        }
    }
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=m;++&lt;span&gt;i){
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; l,r;scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;l,&amp;amp;&lt;span&gt;r);
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,lan=&lt;span&gt;ask(l,r));
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　但是比较鬼畜的是，这道题在loj模板里面数据范围加强了。长度为n的序列，询问次数为n，n&amp;lt;=1e5。这个复杂度，好像上面那种算法不管怎么调都过不去啊。。我们考虑换一种思路，还和上面一样，我们每一个块需要处理出区间众数，然后对于边缘的每个数，我们考虑怎么快速查询它在块内出现的次数。我们可以对每个数值建立一个vector，存储的是这个数值所在的所有位置，那么我们此时可以通过两次二分求出这个数在当前块内出现的次数。复杂度应该是NT+N*N/T*log N，取T=sqrt（NlogN），整个复杂度为O（N*sqrt（N logN）），空间复杂度为N logN。足以通过这道题。&lt;/p&gt;
</description>
<pubDate>Mon, 14 Jan 2019 23:12:00 +0000</pubDate>
<dc:creator>UnicornXi</dc:creator>
<og:description>啊，题目比较冗余，直接一句题意：求任意区间众数。 俗话说得好，面向数据编程。这道题在洛谷和bzoj上的数据都是比较友好的，n&lt;=40000，m&lt;=50000。那不是挺容易吗！ 首先确定一点</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kgxw0430/p/10269175.html</dc:identifier>
</item>
<item>
<title>设计模式——组合模式（文件夹与文件） - cdream</title>
<link>http://www.cnblogs.com/cdream-zs/p/10269962.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cdream-zs/p/10269962.html</guid>
<description>&lt;blockquote readability=&quot;6.6347826086957&quot;&gt;
&lt;p&gt;本文首发于&lt;a href=&quot;https://icdream.github.io/2018/12/20/designpattern06/&quot;&gt;cdream&lt;/a&gt;的个人博客，点击获得更好的阅读体验！&lt;/p&gt;
&lt;p&gt;欢迎转载，转载请注明出处。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文简单介绍组合模式，以系统文件和文件夹为例。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws3.sinaimg.cn/large/006tNbRwly1fyhft3twcoj311k06ujsm.jpg&quot; alt=&quot;image-20181223141136417&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;一概述&quot;&gt;一、概述&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt;：组合模式(Composite pattern)将对象整合到树状结构中来表示整体/部分的层次关系,在树状结构中包括对象和对象组合。组合模式能让客户用一致的方式处理个别对象的对象组合。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;组合模式主要解决两个问题&lt;/strong&gt;：&lt;br/&gt;1.部分-整体的层级结构以树状结构来表现&lt;br/&gt;2.部分整体的层级结构中，对象和对象组合要以一致方式处理&lt;/p&gt;
&lt;h2 id=&quot;二结构&quot;&gt;二、结构&lt;/h2&gt;
&lt;p&gt;UML:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws3.sinaimg.cn/large/006tNbRwly1fye02sxcbej30qy0i475x.jpg&quot; alt=&quot;image-20181221071228741&quot;/&gt;&lt;/p&gt;
&lt;p&gt;主要角色：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;抽象构件类&lt;/strong&gt;（&lt;em&gt;Compnent&lt;/em&gt;）:为所有对象定义了一个接口，无论是叶节点还是组合。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;叶构件类&lt;/strong&gt;（Leaf）：继承了抽象构件类，但是没有子构件了，虽然继承了add,remove,getChildren方法，但是对于叶节点来说没什么意义，不过为了保持透明性，我们坚持这么做。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;树枝构件类&lt;/strong&gt;（Component）：继承了抽象构件类，持有一个子构件类容器口。&lt;/p&gt;
&lt;h2 id=&quot;三系统文件目录&quot;&gt;三、系统文件目录&lt;/h2&gt;
&lt;p&gt;系统文件目录是一个典型的包括叶构件(文件)和树枝构件(文件夹)的组合模式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws3.sinaimg.cn/large/006tNbRwly1fyemnr068vj316u0ciabk.jpg&quot; alt=&quot;image-20181221201327097&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然文件夹和文件操作上还是有区别的，不过，我在这里就让文件夹和文件都实现相同的接口，完成最理想的组合的组合模式——放弃安全性，追求透明性。&lt;/p&gt;
&lt;p&gt;定义一个抽象接口，为了保证可以使用户不关心究竟是什么，所有文件/文件夹都要实现这个接口。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public abstract class FileInterface {
    // 添加文件
    void add(FileInterface file) {
        throw new UnsupportedOperationException();
    }

    // 删除文件
    void remove(String fileName) {
        throw new UnsupportedOperationException();
    }

    // 获取文件
    Set&amp;lt;FileInterface&amp;gt; getChildren() {
        throw new UnsupportedOperationException();
    }

    // 获取文件名字
    String getName(){
        throw new UnsupportedOperationException();
    }

    // 获取文件描述
    String getDescription(){
        throw new UnsupportedOperationException();
    };

    // 运行程序
    void run(){
        throw new UnsupportedOperationException();
    };

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;写一个文件夹类&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Directory implements FileInterface {
    private String name;
    private String desc;
    // 文件夹要持有文件列表
    private Set&amp;lt;FileInterface&amp;gt; set = new HashSet&amp;lt;&amp;gt;();

    public Directory(String name, String desc) {
        this.name = name;
        this.desc = desc;
    }

    @Override
    public void add(FileInterface file) {
        set.add(file);
    }

    @Override
    public void remove(String fileName) {
        if (fileName==null)
            throw new UnsupportedOperationException(&quot;请输入文件名&quot;);
        Iterator&amp;lt;FileInterface&amp;gt; iterator = this.set.iterator();
        while (iterator.hasNext()){
            FileInterface next = iterator.next();
            if (fileName.equals(next.getName())){
                iterator.remove();
            }
        }
    }

    @Override
    public Set&amp;lt;FileInterface&amp;gt; getChildren() {
        return this.set;
    }

    @Override
    public String getName() {
        return this.name;
    }

    @Override
    public String getDescription() {
        return this.desc;
    }
    // 重写了equals和hashcode方法，不允许出现重名文件
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof FileInterface)) return false;

        FileInterface directory = (FileInterface) o;

        return name.equals(directory.getName());
    }

    @Override
    public int hashCode() {
        return name.hashCode();
    }

    @Override
    public String toString() {
        return &quot;Directory{&quot; +
                &quot;name='&quot; + name + '\'' +
                &quot;, desc='&quot; + desc + '\'' +
                &quot;, set=&quot; + set +
                '}';
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;写一个exe文件类&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ExeFile implements FileInterface {
    private String name;
    private String desc;

    public ExeFile(String name, String desc) {
        this.name = name;
        this.desc = desc;
    }

    @Override
    public String getName() {
        return this.name;
    }

    @Override
    public String getDescription() {
        return this.desc;
    }

    @Override
    public void run() {
        System.out.println(&quot;运行程序&quot;);
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof FileInterface)) return false;

        FileInterface directory = (FileInterface) o;

        return name.equals(directory.getName());
    }

    @Override
    public int hashCode() {
        return name.hashCode();
    }

    @Override
    public String toString() {
        return &quot;ExeFile{&quot; +
                &quot;name='&quot; + name + '\'' +
                &quot;, desc='&quot; + desc + '\'' +
                '}';
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这两个类都继承了FileIntercepter抽象类并实现了所有方法，可以等同看待，虽然有些方法并不是两个类都能用的，一定程度上丧失了安全性(程序员调用时需要指到方法的具体实现)，不过为了保持透明性(方法同等看待)，我们仍选择了全部实现，对于个别方法使用抛出不支持操作异常处理！&lt;/p&gt;
&lt;p&gt;下面看测试类&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Test {
    public static void main(String[] args) {
        Directory c = new Directory(&quot;C:&quot;, &quot;C盘啊&quot;);
        ExeFile system = new ExeFile(&quot;system.exe&quot;, &quot;系统程序&quot;);
        c.add(system);

        Directory animals = new Directory(&quot;animals&quot;, &quot;动物程序文件夹&quot;);
        ExeFile dog = new ExeFile(&quot;dog.exe&quot;, &quot;小狗程序&quot;);
        ExeFile pig = new ExeFile(&quot;pig.exe&quot;,&quot;小猪程序&quot;);

        animals.add(dog);
        animals.add(pig);

        c.add(animals);

        animals.remove(&quot;dog.exe&quot;);
        System.out.println(c);
    }
}
----&amp;gt;结果
Directory{name='C:', desc='C盘啊', set=[ExeFile{name='system.exe', desc='系统程序'}, Directory{name='animals', desc='动物程序文件夹', set=[ExeFile{name='pig.exe', desc='小猪程序'}]}]}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;四优缺点&quot;&gt;四、优缺点&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;组合模式可以很容易的增加新的构件。&lt;/li&gt;
&lt;li&gt;使用组合模式可以使客户端变的很容易设计，因为客户端可以对组合和叶节点一视同仁。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;使用组合模式后，控制树枝构件的类型不太容易。&lt;/li&gt;
&lt;li&gt;用继承的方法来增加新的行为很困难。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;组合的适用场合：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;你想表示对象的部分-整体层次结构。&lt;/li&gt;
&lt;li&gt;你希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;五总结&quot;&gt;五、总结&lt;/h2&gt;
&lt;p&gt;组合模式是对象的结构模式，重点掌握树状结构和将叶节点和组合节点同等看待。&lt;/p&gt;
&lt;p&gt;当组合模式与迭代器模式结合时，调用者甚至可以忽略掉组合模式的结构，这里我必须推荐&lt;span&gt;&lt;em&gt;Head First 设计模式&lt;/em&gt;&lt;/span&gt;中迭代器模式与组合模式这一章，你会发现组合模式与迭代器结合的巨大威力！&lt;/p&gt;
&lt;p&gt;此外也有人会为了安全性，将非共性方法不在抽象类中声明，这样虽然安全了，但是调用者就不能将组合模式的叶节点与组合节点同等看待，这并不符合我们的目的，所以我们还是选择本文这种实现方式。&lt;/p&gt;
&lt;hr/&gt;&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;http://product.dangdang.com/20021171.html&quot;&gt;Head First 设计模式,Eric Freeman &amp;amp;Elisabeth Freeman with Kathy Sierra &amp;amp; Bert Bates&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Composite_pattern&quot;&gt;Composite pattern，wiki&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/java-my-life/archive/2012/04/17/2453861.html&quot;&gt;《JAVA与模式》之合成模式&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Mon, 14 Jan 2019 22:56:00 +0000</pubDate>
<dc:creator>cdream</dc:creator>
<og:description>本文首发于 'cdream' 的个人博客，点击获得更好的阅读体验！ 欢迎转载，转载请注明出处。 本文简单介绍组合模式，以系统文件和文件夹为例。 &lt;! more 一、概述 定义 ：组合模式(Compos</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cdream-zs/p/10269962.html</dc:identifier>
</item>
<item>
<title>PHP之ThinkPHP框架（会话） - 东小东</title>
<link>http://www.cnblogs.com/dongxiaodong/p/10269788.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dongxiaodong/p/10269788.html</guid>
<description>&lt;p&gt;    网页会话即是实现页面跳转及数据传递，在web开发中，Cookie和Session的使用是极其重要的，GET和POST是最常使用的页面间数据传递的方法，相对于PHP脚本基础，在ThinkPHP中对网页会话都进行了上层封装。&lt;/p&gt;

&lt;p&gt;脚本的会话基础：&lt;a href=&quot;https://www.cnblogs.com/dongxiaodong/p/10123103.html&quot;&gt;PHP的会话控制&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;页面跳转：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在控制器或模板中要做页面跳转时使用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;exit&lt;/span&gt;(&lt;span&gt;header&lt;/span&gt;(&quot;Location: ../控制器/方法&quot;));
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;超链接：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在视图的HTML里如果要超链接到本地的控制器则需要使用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; href=&quot;{:url('控制器/方法')}&quot;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;JS传递参数：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;利用其传递GET数据到后台，实现数据交互&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; window.location.href=&quot;../控制器/方法?u_id=&quot;+u_id+&quot;&amp;amp;u_state=停用&quot;;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;GET和POST的数据获取：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &amp;lt;?&lt;span&gt;php
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;namespace app\index\controller;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;use&lt;/span&gt;&lt;span&gt; think\Request;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Xiao
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; xiao2(){
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取到访问信息&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;$re&lt;/span&gt;=Request::&lt;span&gt;instance();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;echo&lt;/span&gt; &quot;当前域名：&quot;.&lt;span&gt;$re&lt;/span&gt;-&amp;gt;&lt;span&gt;domain();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;echo&lt;/span&gt; &quot;获取 GET 或者 POST 参数值：&quot;.&lt;span&gt;$re&lt;/span&gt;-&amp;gt;param(&quot;name&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;也可以为input(&quot;name&quot;);&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;     dump(input());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;$也可以为：re-&amp;gt;param() 打印所有获取的值&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;$methodx&lt;/span&gt;=&lt;span&gt;$re&lt;/span&gt;-&amp;gt;&lt;span&gt;method();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;echo&lt;/span&gt; &quot;当前的请求方法：&quot;.&lt;span&gt;$methodx&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取get数据&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;$methodx&lt;/span&gt;==&quot;GET&quot;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;$re&lt;/span&gt;-&amp;gt;get(&quot;getn&quot;).&quot;&amp;lt;br/&amp;gt;&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         dump(&lt;span&gt;$re&lt;/span&gt;-&amp;gt;&lt;span&gt;get());
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取post数据&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;$methodx&lt;/span&gt;==&quot;POST&quot;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;$re&lt;/span&gt;-&amp;gt;post(&quot;postn&quot;).&quot;&amp;lt;br/&amp;gt;&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         dump(&lt;span&gt;$re&lt;/span&gt;-&amp;gt;&lt;span&gt;post());
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         
&lt;span&gt;32&lt;/span&gt; &lt;span&gt;         }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Session的基本使用：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &amp;lt;?&lt;span&gt;php
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;namespace app\index\controller;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;导入必要的模块&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;use&lt;/span&gt;&lt;span&gt; think\Session;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Xiao
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; xiao2(){
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置值&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     Session::set('name1','thinkphp'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断session值是否存在&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(Session::has(&quot;name1&quot;&lt;span&gt;)){
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;echo&lt;/span&gt; &quot;--------------------------&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取某个值&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;echo&lt;/span&gt; Session::get('name1'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除某个值
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    //Session::delete('name1');
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    //清空所有&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;     Session::&lt;span&gt;clear();
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     
&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;session数组的设置&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;     Session::set(&quot;n2.nn1&quot;,&quot;aa1&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     Session::set(&quot;n2.nn2&quot;,&quot;aa2&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取某个值&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;echo&lt;/span&gt; Session::get(&quot;n2.nn1&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;打印数组中所有值&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;     dump(Session::get(&quot;n2&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Cookie的基本使用：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &amp;lt;?&lt;span&gt;php
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;namespace app\index\controller;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;导入必要的模块&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;use&lt;/span&gt;&lt;span&gt; think\Cookie;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Xiao
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; xiao2(){
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;cookie单值，时间单位为秒    &lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     Cookie::set('name1','value',3600&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;cookie数组&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;     Cookie::set('name',[1,2,3&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断是否存在&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(Cookie::has(&quot;name&quot;&lt;span&gt;)){
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;打印出数组&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;         dump(Cookie::get(&quot;name&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除某个&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;     Cookie::delete('name'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;清空所有&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;     Cookie::&lt;span&gt;clear();
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;利用Session的登入判断：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;      Session的值是保存在WEB服务器中的，利用其来做当次的登入判断是常用的一种方式，首先应该在用户名密码匹配成功后进行Session的写操作,接下来是验证Session内容，进行登入判断。&lt;/p&gt;
&lt;p&gt;     本来觉得验证写在控制器中就好了，结果发现一旦程序庞大后每个控制器中的方法就多了，因为每个方法就代表着一个入口，所以这是不可取的。如果把Session判断写在模板的构造函数中，因为模板表示这一个数据库的数据表且基本上控制器中的方法都会设计到数据表的操作，这样整体下来很好的实现了登入验证功能。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;strong&gt;先导入必要模块：&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;use&lt;/span&gt; think\Session;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;&lt;strong&gt;模板的构造函数编写：&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;构造函数    &lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;  类名(){
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断session    &lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt;(!Session::get(&quot;username&quot;&lt;span&gt;)){
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;非登入，跳转页面    &lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;       &lt;span&gt;exit&lt;/span&gt;(&lt;span&gt;header&lt;/span&gt;(&quot;Location: ../控制器/登入的方法名&quot;&lt;span&gt;));    
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;构造函数需要与类同名，经过测试发现PHP自带的万能类构造方法__construct()是不能使用的&lt;/p&gt;


&lt;hr/&gt;
</description>
<pubDate>Mon, 14 Jan 2019 17:28:00 +0000</pubDate>
<dc:creator>东小东</dc:creator>
<og:description>网页会话即是实现页面跳转及数据传递，在web开发中，Cookie和Session的使用是极其重要的，GET和POST是最常使用的页面间数据传递的方法，相对于PHP脚本基础，在ThinkPHP中对网页会</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dongxiaodong/p/10269788.html</dc:identifier>
</item>
<item>
<title>如何用Nginx解决前端跨域问题？ - 海角在眼前</title>
<link>http://www.cnblogs.com/lovesong/p/10269793.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lovesong/p/10269793.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在开发静态页面时，类似Vue的应用，我们常会调用一些接口，这些接口极可能是跨域，然后浏览器就会报cross-origin问题不给调。&lt;/p&gt;
&lt;p&gt;最简单的解决方法，就是把浏览器设为忽略安全问题，设置--disable-web-security。不过这种方式开发PC页面到还好，如果是移动端页面就不行了。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;解决办法&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;使用Nginx转发请求。把跨域的接口写成调本域的接口，然后将这些接口转发到真正的请求地址。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;举个栗子&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;例如我们在开发一个Vue应用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;原先：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;调试页面是：&lt;a href=&quot;http://192.168.1.100:8080/&quot;&gt;http://192.168.1.100:8080/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;请求的接口是：&lt;a href=&quot;http://ni.hao.sao/api/get/info&quot;&gt;http://ni.hao.sao/api/get/info&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;步骤一：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;请求的接口是：&lt;a href=&quot;http://192.168.1.100:8080/api/get/info&quot; target=&quot;_blank&quot;&gt;http://192.168.1.100:8080/api/get/info&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;PS：这样就解决了跨域问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;步骤二：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;安装好Nginx后，去到/usr/local/etc/nginx/目录（这是Mac的），修改nginx.conf文件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;步骤三：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;把默认的server配置注释掉。&lt;/p&gt;
&lt;p&gt;在下面增加：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    server{
        listen &lt;/span&gt;8888;&lt;span&gt;
        server_name  &lt;/span&gt;192.168.1.100;&lt;span&gt;
 
        location &lt;/span&gt;/&lt;span&gt;{
            proxy_pass http:&lt;/span&gt;//192.168.1.100:8080;&lt;span&gt;
        }
 
        location &lt;/span&gt;/&lt;span&gt;api{
            proxy_pass http:&lt;/span&gt;//ni.hao.sao/api;&lt;span&gt;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;保存后，启动Nginx。&lt;/p&gt;
&lt;p&gt;PS：并不需要太了解Nginx的配置，很简单的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;步骤四：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;访问：&lt;a href=&quot;http://192.168.1.100:8888/&quot;&gt;http://192.168.1.100:8888/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;搞定。&lt;/p&gt;
&lt;p&gt;PS：注意访问的端口是‘8888’，有其他域的地址继续加location就行了。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;错误示范&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我一开始不太懂Nginx的配置，以为可以如下配置。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    server{
        listen &lt;/span&gt;8080;&lt;span&gt;
        server_name  &lt;/span&gt;192.168.1.100;&lt;span&gt;
 
        location &lt;/span&gt;/&lt;span&gt;api{
            proxy_pass http:&lt;/span&gt;//ni.hao.sao/api;&lt;span&gt;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;之所以这么写，是我认为这样可以让Nginx帮我监听8080的请求，然后只转发匹配的请求。我没有意识到的是Nginx这么写后，是需要占用8080端口的。&lt;/p&gt;
&lt;p&gt;既然需要占用端口，那也就不能再被其他相同协议的进程占用，就导致开发的页面无法以8080端口启用。经同事提点，才想起这事情，换下思路，就有了最上面的方法。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其实不仅是在开发调试时候能这么干，在生产环境也能这么玩。利用Nginx转发请求之后，就能够让所要部署的静态页面不需要放在跟请求接口同域的地方。&lt;/p&gt;

&lt;p&gt;本文为原创文章，转载请保留原出处，方便溯源，如有错误地方，谢谢指正。&lt;/p&gt;
&lt;p&gt;本文地址 ：&lt;a href=&quot;http://www.cnblogs.com/lovesong/p/10269793.html&quot;&gt;http://www.cnblogs.com/lovesong/p/10269793.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 14 Jan 2019 16:16:00 +0000</pubDate>
<dc:creator>海角在眼前</dc:creator>
<og:description>前言 在开发静态页面时，类似Vue的应用，我们常会调用一些接口，这些接口极可能是跨域，然后浏览器就会报cross-origin问题不给调。 最简单的解决方法，就是把浏览器设为忽略安全问题，设置--di</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lovesong/p/10269793.html</dc:identifier>
</item>
<item>
<title>创建型模式：单例模式 - LieBrother</title>
<link>http://www.cnblogs.com/liebrother/p/10269746.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liebrother/p/10269746.html</guid>
<description>&lt;p&gt;个人博客原文：&lt;br/&gt;&lt;a href=&quot;http://www.liebrother.com/singleton-pattern&quot;&gt;创建型模式：单例模式&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.liebrother.com/upload/b7fd2732860944f4a31c82566e96cdca_0020_01.jpg&quot; alt=&quot;月&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;姓名&lt;/strong&gt;：单例模式&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;英文名&lt;/strong&gt;：Singleton Pattern&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;价值观&lt;/strong&gt;：我的生活我主宰（只允许自己实例化，不愿意被其他对象实例化）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;个人介绍&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;Ensure a class has only one instance, and provide a global point of access to it.（确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。）&lt;br/&gt;(来自《设计模式之禅》)&lt;/p&gt;
&lt;p&gt;这里的关注点有 3 个，分别是：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;只有一个实例&lt;/li&gt;
&lt;li&gt;自行实例化（也就是主动实例化）&lt;/li&gt;
&lt;li&gt;向整个系统提供这个实例&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;你要的故事&quot;&gt;你要的故事&lt;/h2&gt;
&lt;p&gt;我们脑洞大开来用一个故事讲解一番。&lt;/p&gt;
&lt;p&gt;小明家里有一辆小汽车，具体什么牌子就不知道了，咱也不关注，反正他家里就这么一辆车，小明比较懒，只要一出门都会开车，例如去旅游、去学校、去聚会都会开车去。下面模拟小明出去的场景。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class Car {
    public void run() {
        System.out.println(&quot;走。。。。&quot;);
    }
}


class XiaoMing {
    public Car travel() {
        System.out.println(&quot;小明去旅游&quot;);
        Car car = new Car();
        car.run();
        return car;
    }

    public Car goToSchool() {
        System.out.println(&quot;小明去学校&quot;);
        Car car = new Car();
        car.run();
        return car;
    }

    public Car getTogether() {
        System.out.println(&quot;小明参加聚会&quot;);
        Car car = new Car();
        car.run();
        return car;
    }
}

public class SingletonErrorTest {

    public static void main(String[] args) {
        XiaoMing xiaoMing = new XiaoMing();
        Car car1 = xiaoMing.travel();
        Car car2 = xiaoMing.goToSchool();
        Car car3 = xiaoMing.getTogether();
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面小汽车只有一个方法，就是走。小明去旅游、去学校、参加聚会都开着他唯一的一辆汽车车去。是不是有人有疑问？为什么每个方法都返回 Car 对象？其实只是想在下面做一次检查，检查小明去旅游、去学校和参加聚会的车是不是同一辆。下面是检查代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;System.out.println(&quot;car1 == car2 ? &quot; + (car1 == car2));
System.out.println(&quot;car2 == car3 ? &quot; + (car2 == car3));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最终结果是啥？很明显是 2 个 false。小明去旅游、去学校和参加聚会的车都不相同，小明不是只有 1 辆车？关键在于 &lt;code&gt;Car car = new Car();&lt;/code&gt; 这一句代码，其实这一句是创建一辆车，每次都重新创建一辆。那应该怎么实现小明只有一辆车呢？这时候就引入了&lt;strong&gt;单例模式&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;上面我们说到了单例模式需要具备的 3 个点：&lt;strong&gt;只有 1 个实例&lt;/strong&gt;，很显然，上面的代码不止 1 个实例，而是有 3 个 Car 实例；&lt;strong&gt;自行实例化&lt;/strong&gt;，Car 本身没有主动实例化，而是在小明需要用到的时候才实例化；&lt;strong&gt;向整个系统提供这个实例&lt;/strong&gt;，因为 Car 没有主动实例化，所以它没法向外部暴露提供自己出来。&lt;/p&gt;
&lt;p&gt;我们的代码完全不符合单例模式的要求。我们要通过修改，使之符合单例模式的 3 个要点。首先需要实现的是第 2 点，把 Car 实例化从小明转为 Car 本身，如下代码&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class Car1{

    private static Car1 car1 = new Car1();

    private Car1() {

    }

    public void run(){
        System.out.println(&quot;走。。。。&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面代码使用 private 修饰构造方法，使得 Car1 不能被其他使用方实例化，通过 &lt;code&gt;Car1 car1 = new Car1();&lt;/code&gt; 主动实例化自己。&lt;/p&gt;
&lt;p&gt;接下来再实现第 3 点，向整个系统暴露这个实例，也就是暴露它自己。每个使用方都调用 &lt;code&gt;Car1.getInstance()&lt;/code&gt; 方法来获取实例。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class Car1{

    private static Car1 car1 = new Car1();

    public static Car1 getInstance() {
        return car1;
    }
    
    private Car1() {

    }

    public void run(){
        System.out.println(&quot;走。。。。&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面代码就实现了单例模式的 2 和 3 要点，第 1 要点要怎么实现呢？告诉你，不用实现，只要满足了 2 和 3 要点就可以，第 1 要点是用来检验是否是单例模式的好思路。我们检验一下&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class Car1{

    private static Car1 car1 = new Car1();

    public static Car1 getInstance() {
        return car1;
    }

    private Car1() {

    }

    public void run(){
        System.out.println(&quot;走。。。。&quot;);
    }
}

class XiaoMing1 {
    public Car1 travel() {
        System.out.println(&quot;小明去旅游&quot;);
        Car1 car = Car1.getInstance();
        car.run();
        return car;
    }

    public Car1 goToSchool() {
        System.out.println(&quot;小明去学校&quot;);
        Car1 car = Car1.getInstance();
        car.run();
        return car;
    }

    public Car1 getTogether() {
        System.out.println(&quot;小明参加聚会&quot;);
        Car1 car = Car1.getInstance();
        car.run();
        return car;
    }
}

public class SingletonRightHungryTest {

    public static void main(String[] args) {
        XiaoMing1 xiaoMing1 = new XiaoMing1();
        Car1 car1 = xiaoMing1.travel();
        Car1 car2 = xiaoMing1.goToSchool();
        Car1 car3 = xiaoMing1.getTogether();

        System.out.println(&quot;car1 == car2 ? &quot; + (car1 == car2));
        System.out.println(&quot;car2 == car3 ? &quot; + (car2 == car3));
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面代码最后两行打印出来的结果是啥？是我们想要的：2 个 true。说明小明这几次外出开的车都是同一辆。这是最简单的单例模式的实现方式，我们经常称作&lt;strong&gt;饿汉式单例模式&lt;/strong&gt;。为什么起这么古怪的名字呢？其实和对应的&lt;strong&gt;懒汉式单例模式&lt;/strong&gt;有关，这是 2 个实现方式的差别，饿汉式单例模式实现方式在类加载到内存的时候，就创建好对象了，而懒汉式则是在第一次使用的时候才创建对象，也就是把创建对象的时机从加载延迟到第一次使用，所以才有懒饿之分。&lt;/p&gt;
&lt;p&gt;下面我们来看怎么实现懒汉式单例模式。先描述一下场景：小明还没有汽车，他也不知道什么时候要买汽车，突然某一天，他想去旅游，觉得是时候买辆车了，然后他就买车去旅游了，旅游回来又开车去学校和参加聚会。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class Car2{

    private static Car2 car2;

    public static synchronized Car2 getInstance() {
        if (null == car2) {
            System.out.println(&quot;买车啦。。。&quot;);
            car2 = new Car2();
        }
        return car2;
    }

    private Car2() {

    }

    public void run(){
        System.out.println(&quot;走。。。。&quot;);
    }
}

class XiaoMing2
{
    public Car2 travel() {
        System.out.println(&quot;小明去旅游&quot;);
        Car2 car = Car2.getInstance();
        car.run();
        return car;
    }

    public Car2 goToSchool() {
        System.out.println(&quot;小明去学校&quot;);
        Car2 car = Car2.getInstance();
        car.run();
        return car;
    }

    public Car2 getTogether() {
        System.out.println(&quot;小明参加聚会&quot;);
        Car2 car = Car2.getInstance();
        car.run();
        return car;
    }
}

public class SingletonRightLazyTest {

    public static void main(String[] args) {
        XiaoMing2 xiaoMing2 = new XiaoMing2();
        Car2 car1 = xiaoMing2.travel();
        Car2 car2 = xiaoMing2.goToSchool();
        Car2 car3 = xiaoMing2.getTogether();

        System.out.println(&quot;car1 == car2 ? &quot; + (car1 == car2));
        System.out.println(&quot;car2 == car3 ? &quot; + (car2 == car3));
    }

}

小明去旅游
买车啦。。。
走。。。。
小明去学校
走。。。。
小明参加聚会
走。。。。
car1 == car2 ? true
car2 == car3 ? true&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面附带了打印出来的结果，小明要去旅游的时候，才去买车。这就是&lt;strong&gt;懒汉式单例模式&lt;/strong&gt;的实现方式。&lt;/p&gt;
&lt;p&gt;要注意懒汉式单例模式有个很关键的一点就是 getInstance() 方法带上了 synchronized，这个是为什么呢？&lt;/p&gt;
&lt;p&gt;首先得了解关键字 synchronized 的作用是什么：用于修饰执行方法同步，也就是说多线程并发的情况下，在一个时间点，只允许一个线程执行这个方法。&lt;/p&gt;
&lt;p&gt;不加上这个会有什么结果？在多线程并发情况下，如果有 2 个线程同时执行到 if(null == car2)，那么都判断为 true，这时 2 个线程都会执行 car2 = new Car2()，这样子就不是单例了。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;单例模式可以说是设计模式中最简单的一个，也是在工作中很多场景下经常用到的，比如：项目的配置文件加载、各种工具类等等。我们对于单例模式最重要的一点就是要考虑&lt;strong&gt;多线程并发&lt;/strong&gt;，没有考虑这点就容易引发单例对象不单例的情况。而单例给我们带来最大的好处就是&lt;strong&gt;节约内存&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;上面实现的两种方法是单例模式中最最最简单的 2 种实现，相信也是用得最多的实现方式。网上有不少网友分享了单例模式的很多种实现方法，大家也可以去了解，在了解之前务必已经搞懂文中这 2 种最简单的实现方式，不然会头晕的。&lt;/p&gt;
&lt;p&gt;参考资料：《大话设计模式》、《Java设计模式》、《设计模式之禅》、《研磨设计模式》、《Head First 设计模式》&lt;/p&gt;
&lt;p&gt;希望文章对您有所帮助，设计模式系列会持续更新，感兴趣的同学可以关注公众号，第一时间获取文章推送阅读，也可以一起交流，交个朋友。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/mp/homepage?__biz=MzIxMzgwMTAyMg==&amp;amp;hid=2&amp;amp;sn=c97b64288d92312f57d3c8298f8d8888&quot;&gt;公众号之设计模式系列文章&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.liebrother.com/upload/df81ac224abe46b38131a0e78f4dcf9c_wechat.jpg&quot; alt=&quot;公众号&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 14 Jan 2019 15:59:00 +0000</pubDate>
<dc:creator>LieBrother</dc:creator>
<og:description>五大创建型模式之一：单例模式</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liebrother/p/10269746.html</dc:identifier>
</item>
<item>
<title>EF6学习笔记八：实体状态以及实现IEnumerable和实现IQueryable接口数据集查询方法的支持差异 - 张四海</title>
<link>http://www.cnblogs.com/jinshan-go/p/10269731.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jinshan-go/p/10269731.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;要专业系统地学习EF前往《你必须掌握的Entity Framework 6.x与Core 2.0》这本书的作者（汪鹏，Jeffcky）的博客：https://www.cnblogs.com/CreateMyself/&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;实体状态&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;通过EF上下文与数据库交互的实体，都会被EF跟踪，并且实体会被分配状态。&lt;/p&gt;
&lt;p&gt;我们在添加修改删除数据的时候没有注意到这个实体状态，是因为在我们调用Add()、Remove()这些方法时，其实就是对实体的状态进行改变&lt;/p&gt;
&lt;p&gt;实体状态都有五种，在System.Data.Entity命名空间下的EntityState类里面&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_fbf4ed4f-b289-4e51-ba34-6d3e233e80e0&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_fbf4ed4f-b289-4e51-ba34-6d3e233e80e0&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_fbf4ed4f-b289-4e51-ba34-6d3e233e80e0&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; EntityState
    {
        Detached &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
        Unchanged &lt;/span&gt;= &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,
        Added &lt;/span&gt;= &lt;span&gt;4&lt;/span&gt;&lt;span&gt;,
        Deleted &lt;/span&gt;= &lt;span&gt;8&lt;/span&gt;&lt;span&gt;,
        Modified &lt;/span&gt;= &lt;span&gt;16&lt;/span&gt;&lt;span&gt;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;1.Added状态针对添加操作，当标记为此状态时，表明实体被上下文所追踪但是不存在与数据库中&lt;/p&gt;
&lt;p&gt;　　　　　　什么意思？就是在调用SaveChanges时，如果发现有实体是这个状态，就会将该实体添加到数据库中&lt;/p&gt;
&lt;p&gt;2.Unchanged  实体被上下文追踪，但是存在于数据库中的值未发生改变&lt;/p&gt;
&lt;p&gt;　　　　　　这说的是，你从数据库中查出的数据就是Unchanged状态，可不是值没有改变嘛？可不就是被跟踪了吗？&lt;/p&gt;
&lt;p&gt;3.Modified   实体被上下文跟踪并存在于数据库中，同时部分或者所有属性值已经被更改&lt;/p&gt;
&lt;p&gt;　　　　　　这个还是好理解的，不过要注意，这些状态都说了，要被上下文追踪。&lt;/p&gt;
&lt;p&gt;4.Deleted   实体被上下文跟踪并存在于数据库中，当标记为Deleted状态时，SaveChanges时数据将在数据库中被删除&lt;/p&gt;
&lt;p&gt;5.Detached  这个就是表示没有被上下文追踪，只有通过上下文得到的实体对象才会有被跟踪，才会有其他状态，否则就是Detached&lt;/p&gt;
&lt;p&gt;我们来把各种被操作的实体的状态打印出来看看,查看实体状态，用Entry()方法&lt;/p&gt;
&lt;p&gt;我们现在凭空new 一个对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_6bb63199-0945-4417-81f9-52be2b5a5786&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_6bb63199-0945-4417-81f9-52be2b5a5786&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_6bb63199-0945-4417-81f9-52be2b5a5786&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt; (EFDbContext db = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EFDbContext())
            {
                Book book1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Book { Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;演员自我修养&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Number = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;NO8973424&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Price = &lt;span&gt;21.5m&lt;/span&gt;&lt;span&gt; };
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; state =&lt;span&gt; db.Entry(book1).State;
                Console.WriteLine(state);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  Detached&lt;/span&gt;
            }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;当我们调用Add方法，实体状态变为Added&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_30750eb3-84bc-4a11-8e6e-cc4a5be046ee&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_30750eb3-84bc-4a11-8e6e-cc4a5be046ee&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_30750eb3-84bc-4a11-8e6e-cc4a5be046ee&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
Book book1 = &lt;span&gt;new&lt;/span&gt; Book { Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;演员自我修养&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Number = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;NO8973424&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Price = &lt;span&gt;21.5m&lt;/span&gt;&lt;span&gt; };
                db.Books.Add(book1);
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; state =&lt;span&gt; db.Entry(book1).State;
                Console.WriteLine(state);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  Added&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;然后将这个实体添加到数据库，然后查询出来，这个查询出来的实体状态为Unchanged&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_ba47af09-b18c-4a8a-91d2-624aca32fd00&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_ba47af09-b18c-4a8a-91d2-624aca32fd00&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_ba47af09-b18c-4a8a-91d2-624aca32fd00&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
Book book1 = &lt;span&gt;new&lt;/span&gt; Book { Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;演员自我修养&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Number = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;NO8973424&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Price = &lt;span&gt;21.5m&lt;/span&gt;&lt;span&gt; };
                db.Books.Add(book1);
                db.SaveChanges();
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; state =&lt;span&gt; db.Entry(book1).State;
                Console.WriteLine(state);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  Unchanged&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;让我想不到的是，我不用查询，直接查看他的状态就是Unchanged，有点神奇&lt;/p&gt;
&lt;p&gt;我们查询出一个实体，然后修改某个属性值，状态变为Modified&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_be9e0593-5910-454c-a568-803272e4bc37&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_be9e0593-5910-454c-a568-803272e4bc37&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_be9e0593-5910-454c-a568-803272e4bc37&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; res =&lt;span&gt; db.Books.ToList().FirstOrDefault();
                res.Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;新华字典&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; state =&lt;span&gt; db.Entry(res).State;
                Console.WriteLine(state);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  Modified&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;我们调用Remove方法，实体状态变为Deleted。我刚刚还为Unchanged状态感到神奇呢，现在看来我居然只有通过这种方式来获得Deleted状态&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_bcbc8527-c677-4786-86fc-4d633ed5c7a6&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_bcbc8527-c677-4786-86fc-4d633ed5c7a6&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_bcbc8527-c677-4786-86fc-4d633ed5c7a6&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; res =&lt;span&gt; db.Books.ToList().FirstOrDefault();
                db.Books.Remove(res);
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; state =&lt;span&gt; db.Entry(res).State;
                Console.WriteLine(state);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  Deleted&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;上下文没有提供Update方法，所以我们要通过更改实体状态的方式来更新数据&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_65d8560e-937b-46ba-b2f4-98083c8f351d&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_65d8560e-937b-46ba-b2f4-98083c8f351d&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_65d8560e-937b-46ba-b2f4-98083c8f351d&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; res =&lt;span&gt; db.Books.ToList().FirstOrDefault();
                res.Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;新华字典&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                db.Entry(res).State &lt;/span&gt;=&lt;span&gt; System.Data.Entity.EntityState.Modified;
                db.SaveChanges();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;关于实体状态就先浅尝辄止了&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;实现IEnumerable&amp;lt;&amp;gt;接口和IQueryable&amp;lt;&amp;gt;接口数据集支持查询方法的差异&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;我在学LINQ（语言集成查询）时对这两个接口稍微有点了解，之后看别人的博客，详解IQueryable&amp;lt;&amp;gt;接口，我看不太明白，很气馁&lt;/p&gt;
&lt;p&gt;LINQ是什么，他是想对查询语法做一个统一，我们在数据库中查询数据要写SQL语句，查询XML用DOM操作，那能不能来个统一的方式，不要让我去学习那么多的查询语句了，那么LINQ就来了&lt;/p&gt;
&lt;p&gt;写LINQ有两种方法，一个是写查询语句，像什么from a in list  select a;这样的，还一个就是调用方法，像Where()、Select()……&lt;/p&gt;
&lt;p&gt;这两种方式没什么区别，只不过一些聚合查询必须得调用方法才行，大部分的查询语句和方法都能来&lt;/p&gt;
&lt;p&gt;还有一点，LINQ里面有延迟加载，聚合查询会立即执行，官网上面写了有，什么方法会立即执行查询&lt;/p&gt;
&lt;p&gt;LINQ的那些查询方法都是扩展在IEnumberable类上的，所以我们也可以通过扩展这个类来扩展LINQ&lt;/p&gt;
&lt;p&gt;我来说一下IEnumberable&amp;lt;&amp;gt;和IQueryable&amp;lt;&amp;gt;这两个接口，查询内存中的数据都是实现的IEnumberable接口，查询远程数据是实现的IQueryable&amp;lt;&amp;gt;接口&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_7d5c9791-f300-4b41-89bc-07ef500dac31&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_7d5c9791-f300-4b41-89bc-07ef500dac31&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_7d5c9791-f300-4b41-89bc-07ef500dac31&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
List&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; list = &lt;span&gt;new&lt;/span&gt; List&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; { &lt;span&gt;12&lt;/span&gt;, &lt;span&gt;32&lt;/span&gt;, &lt;span&gt;34&lt;/span&gt;, &lt;span&gt;55&lt;/span&gt;, &lt;span&gt;66&lt;/span&gt;&lt;span&gt; };
                list.Where();
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; res = db.Books.Where();
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;他们之间很多方法都匹配，但是有一些方法不行,上面的两个Where方法不是一样的，一个返回的是IEnumberable,一个返回的IQueryable&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Last 和LastOrDefault&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这两个方法在IQueryable中不支持，我也就搞不明白了，算了，反正这两方法我真是一次都没用过&lt;/p&gt;
&lt;p&gt;当我对上下文的数据集调用LastOrDefault方法时，报错，NotSupportedException  不支持异常&lt;/p&gt;
&lt;p&gt;&lt;span&gt;System.NotSupportedException: LINQ to Entities does not recognize the method '_2019011402.Entity.Book LastOrDefault[Book](System.Linq.IQueryable`1[_2019011402.Entity.Book])' method, and this method cannot be translated into a store expression.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Contains方法&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_5d1842cb-0f90-421d-b4a4-3ce69f7102fb&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_5d1842cb-0f90-421d-b4a4-3ce69f7102fb&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_5d1842cb-0f90-421d-b4a4-3ce69f7102fb&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
Book book1 = &lt;span&gt;new&lt;/span&gt; Book { Id = Guid.NewGuid().ToString(), Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;自我修养&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Price =&lt;span&gt; 30m };
                Book book2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Book { Id = Guid.NewGuid().ToString(), Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;新华字典&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Price =&lt;span&gt; 30m };
                Book book3 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Book { Id = Guid.NewGuid().ToString(), Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;天国之秋&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Price =&lt;span&gt; 30m };
                List&lt;/span&gt;&amp;lt;Book&amp;gt; bookList = &lt;span&gt;new&lt;/span&gt; List&amp;lt;Book&amp;gt;&lt;span&gt;();
                bookList.Add(book1);
                bookList.Add(book2);
                bookList.Add(book3);
                &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; boo =&lt;span&gt; bookList.Contains(book1);  
                Console.WriteLine(boo);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  True&lt;/span&gt;

                &lt;span&gt;var&lt;/span&gt; frist =&lt;span&gt; db.Books.FirstOrDefault();
                db.Books.Contains(frist);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  报错 NotSupportedException&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;我对内存中的数据进行查询，和远程查询数据库中的数据，得到上面的结果。 EF不支持Contains方法，虽然这个方法我几乎不使用，感觉甚至都不想去了解这些差异的东西了。但是刚刚想到，万一我使用到了呢？然后我发现在IEnumberable中是可以的，但是查询EF上下文的数据集为什么又不行呢？&lt;/p&gt;
&lt;p&gt;然后我就只会怀疑是不是自己写错了，然后我能想到我怎么想都不知道错在哪里，然后独自抓耳挠腮，其实现在知道是系统的问题，那么就不会动不动就怀疑人生了。&lt;/p&gt;
&lt;p&gt;但是如果你对上下文中的数据集进行Select(x=&amp;gt;x.Name)查询之后，得出的List&amp;lt;string&amp;gt;集合再调用Contains方法又是可以的，所以对于简答类型的集合可以，复杂类型的不行&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_fb374295-d6db-43e1-a2a1-e13444dd1ab6&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_fb374295-d6db-43e1-a2a1-e13444dd1ab6&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_fb374295-d6db-43e1-a2a1-e13444dd1ab6&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; res = db.Books.Select(x =&amp;gt;&lt;span&gt; x.Name);
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; res2 = res.Contains(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;新华字典&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;  True&lt;/span&gt;
                Console.WriteLine(res2);
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Case和OfType&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这两方法主要查询集合里面指定类型的数据&lt;/p&gt;
&lt;p&gt;case方法主要针对基元类型进行查询（int、string……），总之相当不好用，它是全盘转换，类型不匹配，就抛出异常，这有什么用？可以判断一个集合中的数据是不是都是同一类型，但是现在都使用泛型集合List&amp;lt;T&amp;gt;,哪还使用List&amp;lt;object&amp;gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_fa61b3d9-3008-4a6e-a3c7-f4dc27cae35f&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_fa61b3d9-3008-4a6e-a3c7-f4dc27cae35f&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_fa61b3d9-3008-4a6e-a3c7-f4dc27cae35f&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
List&amp;lt;&lt;span&gt;object&lt;/span&gt;&amp;gt; list = &lt;span&gt;new&lt;/span&gt; List&amp;lt;&lt;span&gt;object&lt;/span&gt;&amp;gt; { &lt;span&gt;12&lt;/span&gt;, &lt;span&gt;34&lt;/span&gt;, &lt;span&gt;35&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;32.4&lt;/span&gt;&lt;span&gt; };
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; res = list.Cast&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;();
                Console.WriteLine(JsonConvert.SerializeObject(res)); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  报错 无法将System.Int32强制转换为System.String&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;OfType 就友好地多，满足条件才转换，上面的cast换成OfType得到的结果是：[&quot;55&quot;,&quot;33&quot;]&lt;/p&gt;
&lt;p&gt;OfType查询内存中的数据，对于基元类型和复杂类型都是Ok的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39.5&quot;&gt;&lt;img id=&quot;code_img_closed_ee45e299-aea6-4ad4-b4e6-46c24ffe006b&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_ee45e299-aea6-4ad4-b4e6-46c24ffe006b&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_ee45e299-aea6-4ad4-b4e6-46c24ffe006b&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;74&quot;&gt;
&lt;pre&gt;
List&amp;lt;&lt;span&gt;object&lt;/span&gt;&amp;gt; list3 = &lt;span&gt;new&lt;/span&gt; List&amp;lt;&lt;span&gt;object&lt;/span&gt;&amp;gt; { &lt;span&gt;12&lt;/span&gt;, &lt;span&gt;34&lt;/span&gt;, &lt;span&gt;35&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;32.4&lt;/span&gt;&lt;span&gt; };
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; res3 = list3.OfType&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;();
                Console.WriteLine(JsonConvert.SerializeObject(res3));  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  [&quot;55&quot;,&quot;33&quot;]&lt;/span&gt;
&lt;span&gt;
                Book book1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Book { Id = Guid.NewGuid().ToString(),Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;西游记&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;};
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; teacher = &lt;span&gt;new&lt;/span&gt; { Name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;张老师&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,Salary = &lt;span&gt;4543.5&lt;/span&gt;&lt;span&gt;};
                List&lt;/span&gt;&amp;lt;&lt;span&gt;object&lt;/span&gt;&amp;gt; list = &lt;span&gt;new&lt;/span&gt; List&amp;lt;&lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt;();
                list.Add(book1);
                list.Add(teacher);
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; res = list.OfType&amp;lt;Book&amp;gt;&lt;span&gt;();
                Console.WriteLine(JsonConvert.SerializeObject(res));
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  [{&quot;Name&quot;:&quot;西游记&quot;,&quot;Number&quot;:null,&quot;Price&quot;:0.0,&quot;Id&quot;:&quot;1c9d0a8a-b62b-40df-a995-409b828c3714&quot;,&quot;AddTime&quot;:&quot;2019-01-14T22:53:15.5019894+08:00&quot;}]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;然后我们查询上下文中的数据集&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_40724694-47ec-4f94-bdbd-7c4313f0ed71&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_40724694-47ec-4f94-bdbd-7c4313f0ed71&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_40724694-47ec-4f94-bdbd-7c4313f0ed71&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; res2 = db.Books.Select(x =&amp;gt; x.Name).OfType&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;();
                Console.WriteLine(JsonConvert.SerializeObject(res2));
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  报错 NotSupportedException&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;这说明EF不支持OfType针对基元类型进行查询，但是，如果我们对数据集调用ToList()方法，再来看看&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_0dac7b70-b7e2-40ba-9b29-2540f0bc353c&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_0dac7b70-b7e2-40ba-9b29-2540f0bc353c&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_0dac7b70-b7e2-40ba-9b29-2540f0bc353c&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; res2 = db.Books.ToList().Select(x =&amp;gt; x.Name).OfType&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;();
                Console.WriteLine(JsonConvert.SerializeObject(res2));  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  [&quot;新华字典&quot;,&quot;演员自我修养&quot;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;现在居然查出来了，为什么，这是因为ToList()方法，我们在没有使用ToList()方法之前，都是远程查询，然后调用ToList方法，数据被拿到内存里面来了，这中间变化就大了&lt;/p&gt;
&lt;p&gt;ToList()把数据拿到了内存里面，所以就不会延迟查询了，他是对内存中的数据进行查询的，所以IEumberable&amp;lt;&amp;gt;和IQueryable之间是可以转换的，这个要相当注意&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Skip方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对上下文数据集使用Skip方法之前必须要排序，不然报错&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31&quot;&gt;&lt;img id=&quot;code_img_closed_b342ba76-0c09-4daf-91fc-cfa751648004&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_b342ba76-0c09-4daf-91fc-cfa751648004&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_b342ba76-0c09-4daf-91fc-cfa751648004&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; res = db.Books.Skip(&lt;span&gt;1&lt;/span&gt;).ToList();
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;System.NotSupportedException: The method 'Skip' is only supported for sorted input in LINQ to Entities. The method 'OrderBy' must be called before the method 'Skip'.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;但是对于内存中的数据集调用Skip方法之前，不排序就可以&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;&lt;img id=&quot;code_img_closed_0e52b505-7213-4249-876e-3e46e222111f&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_0e52b505-7213-4249-876e-3e46e222111f&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_0e52b505-7213-4249-876e-3e46e222111f&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;75&quot;&gt;
&lt;pre&gt;
Book book1 = &lt;span&gt;new&lt;/span&gt; Book { Id = Guid.NewGuid().ToString(), Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;自我修养&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Price =&lt;span&gt; 30m };
                Book book2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Book { Id = Guid.NewGuid().ToString(), Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;新华字典&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Price =&lt;span&gt; 30m };
                Book book3 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Book { Id = Guid.NewGuid().ToString(), Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;天国之秋&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Price =&lt;span&gt; 30m };
                List&lt;/span&gt;&amp;lt;Book&amp;gt; bookList = &lt;span&gt;new&lt;/span&gt; List&amp;lt;Book&amp;gt;&lt;span&gt;();
                bookList.Add(book1);
                bookList.Add(book2);
                bookList.Add(book3);
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; res = bookList.Skip(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;).ToList();
                Console.WriteLine(JsonConvert.SerializeObject(res));
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  [{&quot;Name&quot;:&quot;新华字典&quot;,&quot;Number&quot;:null,&quot;Price&quot;:30.0,&quot;Id&quot;:&quot;3b890089-5046-4aae-9a30-2d6bf97f2160&quot;,&quot;AddTime&quot;:&quot;2019-01-14T23:23:33.2341685+08:00&quot;},{&quot;Name&quot;:&quot;天国之秋&quot;,&quot;Number&quot;:null,&quot;Price&quot;:30.0,&quot;Id&quot;:&quot;542fa82b-4a6a-41dd-97df-bb4876cdbc52&quot;,&quot;AddTime&quot;:&quot;2019-01-14T23:23:33.2341685+08:00&quot;}]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Take方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果单单调用Take方法，生成的SQL语句，使用的是SQL里面的TOP关键字&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31&quot;&gt;&lt;img id=&quot;code_img_closed_f045d7e3-a86c-429f-90b2-fd9da4816044&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_f045d7e3-a86c-429f-90b2-fd9da4816044&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_f045d7e3-a86c-429f-90b2-fd9da4816044&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; res = db.Books.Take(&lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
                Console.WriteLine(res);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_19c72a25-200e-4816-81de-2fbc3136e5ca&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_19c72a25-200e-4816-81de-2fbc3136e5ca&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_19c72a25-200e-4816-81de-2fbc3136e5ca&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;TOP&lt;/span&gt; (&lt;span&gt;2&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;.&lt;span&gt;[&lt;/span&gt;&lt;span&gt;Id&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;AS&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;Id&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;.&lt;span&gt;[&lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;AS&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;.&lt;span&gt;[&lt;/span&gt;&lt;span&gt;Number&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;AS&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;Number&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;.&lt;span&gt;[&lt;/span&gt;&lt;span&gt;Price&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;AS&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;Price&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;.&lt;span&gt;[&lt;/span&gt;&lt;span&gt;AddTime&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;AS&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;AddTime&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
    &lt;span&gt;FROM&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;dbo&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;.&lt;span&gt;[&lt;/span&gt;&lt;span&gt;Book&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;AS&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;这里可以看到，我直接打印的查询语句，这就是延迟查询，上面的语句根本就没有执行查询，如果我调用ToList()方法就不一样了，打印出来的就直接是数据了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以如果你没有调用那些导致立即执行查询的方法，那么就可以打印看看SQL语句是什么，就不用取跟踪查询EF生成的SQL语句了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;然后我们对内存中的数据集单单调用Take方法看看&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;&lt;img id=&quot;code_img_closed_a4d81775-d009-4e5f-a920-3048698b12fb&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_a4d81775-d009-4e5f-a920-3048698b12fb&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_a4d81775-d009-4e5f-a920-3048698b12fb&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;75&quot;&gt;
&lt;pre&gt;
Book book1 = &lt;span&gt;new&lt;/span&gt; Book { Id = Guid.NewGuid().ToString(), Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;自我修养&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Price =&lt;span&gt; 30m };
                Book book2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Book { Id = Guid.NewGuid().ToString(), Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;新华字典&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Price =&lt;span&gt; 30m };
                Book book3 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Book { Id = Guid.NewGuid().ToString(), Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;天国之秋&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Price =&lt;span&gt; 30m };
                List&lt;/span&gt;&amp;lt;Book&amp;gt; bookList = &lt;span&gt;new&lt;/span&gt; List&amp;lt;Book&amp;gt;&lt;span&gt;();
                bookList.Add(book1);
                bookList.Add(book2);
                bookList.Add(book3);
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; res = bookList.Take(&lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
                Console.WriteLine(JsonConvert.SerializeObject(res));
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  [{&quot;Name&quot;:&quot;自我修养&quot;,&quot;Number&quot;:null,&quot;Price&quot;:30.0,&quot;Id&quot;:&quot;2b4b85c6-109a-485f-9e4f-95b4e5da2ee9&quot;,&quot;AddTime&quot;:&quot;2019-01-14T23:38:07.5226753+08:00&quot;},{&quot;Name&quot;:&quot;新华字典&quot;,&quot;Number&quot;:null,&quot;Price&quot;:30.0,&quot;Id&quot;:&quot;b51e5e61-097b-4fe5-89ca-5283abd16332&quot;,&quot;AddTime&quot;:&quot;2019-01-14T23:38:07.526798+08:00&quot;}]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;出来的就直接是数据了，对于内存中的数据集查询也就不用生成SQL语句了&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Select投影转换为实体类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;针对内存中的数据集查询，没问题&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42.5&quot;&gt;&lt;img id=&quot;code_img_closed_ac0ecc40-a5d2-431b-96ac-abd7ff82846e&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_ac0ecc40-a5d2-431b-96ac-abd7ff82846e&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_ac0ecc40-a5d2-431b-96ac-abd7ff82846e&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;80&quot;&gt;
&lt;pre&gt;
Book book1 = &lt;span&gt;new&lt;/span&gt; Book { Id = Guid.NewGuid().ToString(), Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;自我修养&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Price =&lt;span&gt; 30m };
                Book book2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Book { Id = Guid.NewGuid().ToString(), Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;新华字典&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Price =&lt;span&gt; 30m };
                Book book3 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Book { Id = Guid.NewGuid().ToString(), Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;天国之秋&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Price =&lt;span&gt; 30m };
                List&lt;/span&gt;&amp;lt;Book&amp;gt; bookList = &lt;span&gt;new&lt;/span&gt; List&amp;lt;Book&amp;gt;&lt;span&gt;();
                bookList.Add(book1);
                bookList.Add(book2);
                bookList.Add(book3);
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; res = bookList.Select(x =&amp;gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Book
                {
                    Name &lt;/span&gt;=&lt;span&gt; x.Name
                });
                Console.WriteLine(JsonConvert.SerializeObject(res));
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[{&quot;Name&quot;:&quot;自我修养&quot;,&quot;Number&quot;:null,&quot;Price&quot;:0.0,&quot;Id&quot;:&quot;3f261e85-0bae-45e2-8b59-7694df8bf602&quot;,&quot;AddTime&quot;:&quot;2019-01-14T23:43:01.8446418+08:00&quot;},{&quot;Name&quot;:&quot;新华字典&quot;,&quot;Number&quot;:null,&quot;Price&quot;:0.0,&quot;Id&quot;:&quot;9657f6c5-ce19-43ef-b86f-4a0db6c803de&quot;,&quot;AddTime&quot;:&quot;2019-01-14T23:43:01.8748982+08:00&quot;},{&quot;Name&quot;:&quot;天国之秋&quot;,&quot;Number&quot;:null,&quot;Price&quot;:0.0,&quot;Id&quot;:&quot;a654a851-2f96-4934-9720-a2add7861061&quot;,&quot;AddTime&quot;:&quot;2019-01-14T23:43:01.8748982+08:00&quot;}]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;但是针对上下文的数据集，报错 NotSupportedException&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_b8dee2e9-5926-4dba-8b4d-415842a7ce28&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_b8dee2e9-5926-4dba-8b4d-415842a7ce28&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_b8dee2e9-5926-4dba-8b4d-415842a7ce28&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; res = db.Books.Select(x =&amp;gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Book
                {
                    Name &lt;/span&gt;=&lt;span&gt; x.Name
                });
                Console.WriteLine(JsonConvert.SerializeObject(res));  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  报错 NotSupportedException&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;我们换成匿名类型，可以的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;&lt;img id=&quot;code_img_closed_054f9b1a-a7df-42c8-88ee-97b67a0562a2&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_054f9b1a-a7df-42c8-88ee-97b67a0562a2&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_054f9b1a-a7df-42c8-88ee-97b67a0562a2&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; res = db.Books.Select(x =&amp;gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt;
                {
                    Name &lt;/span&gt;=&lt;span&gt; x.Name
                });
                Console.WriteLine(JsonConvert.SerializeObject(res)); 
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  [{&quot;Name&quot;:&quot;三国演义&quot;},{&quot;Name&quot;:&quot;天国之秋&quot;},{&quot;Name&quot;:&quot;新华字典&quot;},{&quot;Name&quot;:&quot;堂吉诃德&quot;},{&quot;Name&quot;:&quot;演员自我修养&quot;},{&quot;Name&quot;:&quot;水浒传&quot;},{&quot;Name&quot;:&quot;红楼梦过&quot;}]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

</description>
<pubDate>Mon, 14 Jan 2019 15:49:00 +0000</pubDate>
<dc:creator>张四海</dc:creator>
<og:description>要专业系统地学习EF前往《你必须掌握的Entity Framework 6.x与Core 2.0》这本书的作者（汪鹏，Jeffcky）的博客：https://www.cnblogs.com/Creat</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jinshan-go/p/10269731.html</dc:identifier>
</item>
<item>
<title>springmvc的面试知识点总结 - 云间独步</title>
<link>http://www.cnblogs.com/yunjiandubu/p/10269713.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yunjiandubu/p/10269713.html</guid>
<description>&lt;p&gt;新的一年,开启新的篇章,欧气满满,迎接未来.&lt;br/&gt;前几天回顾了spring相关的知识点,现在再来回顾下springmvc相关的知识点做一下总结.&lt;/p&gt;
&lt;h3 id=&quot;问题总结&quot;&gt;问题总结&lt;/h3&gt;
&lt;p&gt;之前面试问题总结的那篇文章中,与springmvc相关的有哪些问题:&lt;/p&gt;
&lt;ol readability=&quot;-2&quot;&gt;&lt;li&gt;springmvc的工作流程?&lt;/li&gt;
&lt;li&gt;springmvc dispatcherservlet与handleradapter如何关联？&lt;/li&gt;
&lt;li&gt;有了springmvc的IOC容器,还需要spring的IOC容器吗?为什么?如何处理兼容问题?&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;tomcat容器如何与springmvc的dispatcherservlet通信的？&lt;/p&gt;
&lt;h3 id=&quot;问题梳理&quot;&gt;问题梳理&lt;/h3&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;springmvc的工作流程&lt;/strong&gt;&lt;br/&gt;我根据springmvc的流程将流程图画了出来:&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3975098-58f33691fab32bbe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;springmvc流程图&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;请求过来之后,dispatcherServlet的url-pattern拦截请求;&lt;/li&gt;
&lt;li&gt;判断在springmvc中是否存在对应映射;&lt;/li&gt;
&lt;li&gt;若不存在,判断是否配置&lt;/li&gt;
&lt;li&gt;如果配置,就会找到目标资源,没有则显示404页面;&lt;/li&gt;
&lt;li&gt;如果映射存在,则由handlerMapping获handlerExecutionChain对象;&lt;code&gt;(注意两点:&lt;/code&gt;&lt;br/&gt;&lt;code&gt;① handlerMapping定义了请求到处理器之间的映射,如果发送的请求是没有映射的,那么得到的handlerExecutionChain也不为空,而是默认的defaultServletHTTPRequestHandler,用来处理静态资源等(配置了default-servlet-handler,否则报为404);&lt;/code&gt;&lt;br/&gt;&lt;code&gt;② handlerExecutionChain实际上包含了拦截器和目标方法.)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;获取HandlerAdapter对象;&lt;code&gt;(包含表单类型的校验,数据类型的转换,格式换等功能)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;调用 interceptor拦截器的preHandle方法;&lt;/li&gt;
&lt;li&gt;调用目标方法;&lt;/li&gt;
&lt;li&gt;调用拦截器的postHandle方法;&lt;/li&gt;
&lt;li&gt;处理视图时候,观察是否存在异常,存在异常,则由HandlerExceptionResolver来处理异常,并得到新的ModelAndView对象;不存在异常,则由ViewResolver视图解析器来解析视图;&lt;/li&gt;
&lt;li&gt;调用拦截器的afterComplettion方法;&lt;/li&gt;
&lt;/ol&gt;&lt;ul readability=&quot;9&quot;&gt;&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;springmvc DispatcherServlet与handlerAdapter如何关联?&lt;/strong&gt;&lt;br/&gt;DispatcherServlet拦截到请求之后,根据handlerMapping获取到handlerExecutionChain对象,然后,在handlerExecutionChain对象不为null的情况下,根据handlerExecutionChain中的handler对象获取HandlerAdapter对象;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;有了springmvc的IOC容器,还需要spring的IOC容器吗?为什么?如何处理兼容问题?&lt;/strong&gt;&lt;br/&gt;这个问题再进一步,换个方式提问即是否还需要在web.xml方法里面配置启动springIOC容器的ContextLoaderListener?&lt;br/&gt;可以从正反两方面来回答,首先是需要,通常情况下,类似于数据源,事务,整合其他框架等都是放在spring的配置文件中,而不是springmvc的配置文件中, 一般情况下,开发过程中的Service,Dao也都是放在spring的IOC容器当中;其次可以是不需要的,也可以都放在springmvc的配置文件当中,当然需要分多个spring的配置文件,然后通过import节点导入到springmvc的配置文件当中.&lt;br/&gt;&lt;code&gt;几点要注意的地方:&lt;/code&gt;&lt;br/&gt;&lt;code&gt;1. springIOC容器和springmvc的IOC容器 扫描的部分有重合的地方,就会导致bean被创建2次,解决方案:使用 exclude-filter和include-filter配合来区分哪些bean交给springIOC容器,哪些bean交给springmvcIOC容器;&lt;/code&gt;&lt;br/&gt;&lt;code&gt;2. springmvc IOC容器里面的bean可以引用springIOC容器的bean,反之则不行,多个springIOC 容器之间可以设置为父子关系,以实现良好的解耦.举个栗子,springIOC容器好比是全局作用域,springmvcIOC容器好比是局部作用域,局部的可以引用全局的,而全局的却不能引用局部的.&lt;/code&gt;&lt;/li&gt;
&lt;li readability=&quot;13&quot;&gt;
&lt;p&gt;&lt;strong&gt;tomcat容器如何与springmvc的dispatcherservlet通信的？&lt;/strong&gt;&lt;br/&gt;Apache Tomcat软件是JavaServlet，JavaServerPages，Java ExpressionLanguage和JavaWebSocket技术的开源实现,SpringMVC则是spring推出的基于servlet标准的MVC框架实现,由此可知,SpringMvc和Tomcat 的结合点就是Servlet.SpringMVC的DispatcherServlet继承了HttpServlet,那么对于tomcat来说,springmvc实际就是一个Servlet.&lt;br/&gt;&lt;code&gt;一个http请求的具体处理流程:&lt;/code&gt;&lt;br/&gt;&lt;code&gt;1. 用户向tomcat容器发送一个请求;&lt;/code&gt;&lt;br/&gt;&lt;code&gt;2. tomcat容器接收到请求之后,分析客户的请求信息;&lt;/code&gt;&lt;br/&gt;&lt;code&gt;3. tomcat创建一个Httprequest对象,将用户的请求信息封装到该对象中;&lt;/code&gt;&lt;br/&gt;&lt;code&gt;4. tomcat创建一个HttpResponse对象;&lt;/code&gt;&lt;br/&gt;&lt;code&gt;5. tomcat调用HttpServlet的Service方法,将Httprequest,HTTPResponse传递给Httpservlet对象;&lt;/code&gt;&lt;br/&gt;&lt;code&gt;6. HttpServlet调用HttpRequest对象的有关方法,获取Http请求信息,HttpServlet调用HttpResponse对象的有关方法，生成响应数据;&lt;/code&gt;&lt;br/&gt;&lt;code&gt;7. tomcat把HttpServlet的响应结果传给Web客户.&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;要注意的几点东西:&lt;/code&gt;&lt;br/&gt;&lt;code&gt;①:web.xml配置文件的作用其实就是配置http请求和servlet之间的映射关系,通过这个配置文件,Tomcat可以把请求转发给不同的servlet实例;&lt;/code&gt;&lt;br/&gt;&lt;code&gt;②:springmvc也是servlet标准的一个实现,所有的http请求都映射到DispatcherServlet上去,这个时候,请求就已经由Tomcat转发到springmvc框架中去了,接着再由DispatcherServlet将请求转发到各个Controller当中去.&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;小结&quot;&gt;小结&lt;/h3&gt;
&lt;p&gt;这篇文章主要回顾了springmvc框架的如何处理http请求的过程,以及其和Tomcat容器之间的请发转发是如何实现的,如果能够熟练掌握,面试碰到相关的问题,也能够侃侃而谈了,同时也是在平时CURD之余,对框架有一个更深层次的理解,不但要会用,还要懂得其原理.&lt;/p&gt;
</description>
<pubDate>Mon, 14 Jan 2019 15:41:00 +0000</pubDate>
<dc:creator>云间独步</dc:creator>
<og:description>新的一年,开启新的篇章,欧气满满,迎接未来. 前几天回顾了spring相关的知识点,现在再来回顾下springmvc相关的知识点做一下总结. 问题总结 之前面试问题总结的那篇文章中,与springmv</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yunjiandubu/p/10269713.html</dc:identifier>
</item>
<item>
<title>Django的Admin站点管理 - 哈撒king</title>
<link>http://www.cnblogs.com/Rain2017/p/10269665.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Rain2017/p/10269665.html</guid>
<description>&lt;h3&gt;一、概述&lt;/h3&gt;
&lt;p&gt;　　内容发布：负责添加、修改、删除内容&lt;/p&gt;
&lt;p&gt;　　公告访问&lt;/p&gt;
&lt;h3&gt;二、配置Admin应用&lt;/h3&gt;
&lt;p&gt;　　在settings.py文件中的INSTALLED_APPS中添加'django.contrib.admin'，&lt;span&gt;默认&lt;/span&gt;是添加好的&lt;/p&gt;
&lt;h3&gt;三、创建管理员用户&lt;/h3&gt;
&lt;p&gt;　　在项目的根目录下，执行命令：python manage.py createsuperuser&lt;/p&gt;
&lt;p&gt;依次输入用户名、邮箱、密码（密码不能太复杂）&lt;/p&gt;
&lt;h3&gt;四、汉化&lt;/h3&gt;
&lt;p&gt;　　修改setting.py&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
LANGUAGE_CODE = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;zh-Hans&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
TIME_ZONE &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Asia/Shanghai&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;五、管理数据表&lt;/h3&gt;

</description>
<pubDate>Mon, 14 Jan 2019 15:23:00 +0000</pubDate>
<dc:creator>哈撒king</dc:creator>
<og:description>一、概述 内容发布：负责添加、修改、删除内容 公告访问 二、配置Admin应用 在settings.py文件中的INSTALLED_APPS中添加'django.contrib.admin</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Rain2017/p/10269665.html</dc:identifier>
</item>
<item>
<title>设计模式第七篇-适配器模式 - 茶底世界</title>
<link>http://www.cnblogs.com/yuanqinnan/p/10217368.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuanqinnan/p/10217368.html</guid>
<description>&lt;h2&gt;一、引言&lt;/h2&gt;
&lt;p&gt;最近懒劲又上来了，隔了几天没有学习，最近的博文阅读量也比较少，不过还是希望自己坚持下去，相信水滴石穿，量变总会引起质变的。&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;今天要学习的是适配器模式，顾名思义，适配器模式是将两个不兼容的接口进行适配，类似转换器的功能。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;先看一个例子，我们一个播放器，它有一个播放功能（继承一个播放接口，只有一个播放方法），最开始的时候它只支持播放MP3功能，现随着播放源的增多，我们想让它支持播放更多的文件类型。有一个厂商提供了其他的播放接口，但是其中的方法并不是叫做播放方法，这个时候我们必须把新厂商的接口转换成开始继承的播放接口，也就是把现在厂商的接口伪装成最先继承的播放接口，让它能够适配原先的方法&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;实际目的是让将一个接口转换成客户想要的另一个接口，适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;二、适配器模式&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;定义：&lt;/strong&gt;&lt;span&gt;适配器模式把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;意图：&lt;/strong&gt;&lt;span&gt;将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;主要解决：&lt;/strong&gt;&lt;span&gt;主要解决在软件系统中，常常要将一些&quot;现存的对象&quot;放到新的环境中，而新环境要求的接口是现对象不能满足的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;何时使用：&lt;/strong&gt; &lt;span&gt;1、系统需要使用现有的类，而此类的接口不符合系统的需要。 2、想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。 3、通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;strong&gt;如何解决：&lt;/strong&gt;&lt;span&gt;继承或依赖&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;strong&gt;类图：&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201901/1113901-20190114231519262-321141700.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;三、代码实现&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;原先的播放器接口&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; MediaPlayer {
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; play(String audioType, String fileName);
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;新的高级播放器接口&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; AdvancedMediaPlayer {
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; playVlc(String fileName);
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; playMp4(String fileName);
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;继承高级播放接口的MP4播放器&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Mp4Player &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; AdvancedMediaPlayer {
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; playVlc(String fileName) {
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; playMp4(String fileName) {
        System.out.println(&lt;/span&gt;&quot;Playing mp4 file. Name: &quot;+&lt;span&gt; fileName);
    }
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;继承高级播放接口的VlC播放器&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; VlcPlayer &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; AdvancedMediaPlayer {
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; playVlc(String fileName) {
        System.out.println(&lt;/span&gt;&quot;Playing vlc file. Name: &quot;+&lt;span&gt; fileName);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; playMp4(String fileName) {

    }
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;适配器类&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MediaAdapter &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; MediaPlayer {
    MediaAdapter mediaAdapter; 
    AdvancedMediaPlayer advancedMediaPlayer;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; MediaAdapter(String audioType){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(audioType.equalsIgnoreCase(&quot;vlc&quot;&lt;span&gt;)){
            advancedMediaPlayer&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; VlcPlayer();
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            advancedMediaPlayer&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Mp4Player();
        }
    }

    @Override
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将现在的接口方法转换成原先接口的方法&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; play(String audioType, String fileName) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(audioType.equalsIgnoreCase(&quot;vlc&quot;&lt;span&gt;)){
            advancedMediaPlayer.playVlc(fileName);
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            advancedMediaPlayer.playMp4(fileName);
        }
    }
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;播放器&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; AudioPlayer &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; MediaPlayer  {
    MediaAdapter mediaAdapter;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; play(String audioType, String fileName) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;播放 mp3 音乐文件的内置支持&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(audioType.equalsIgnoreCase(&quot;mp3&quot;&lt;span&gt;)){
            System.out.println(&lt;/span&gt;&quot;Playing mp3 file. Name: &quot;+&lt;span&gt; fileName);
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;mediaAdapter 提供了播放其他文件格式的支持&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(audioType.equalsIgnoreCase(&quot;vlc&quot;&lt;span&gt;)
                &lt;/span&gt;|| audioType.equalsIgnoreCase(&quot;mp4&quot;&lt;span&gt;)){
            mediaAdapter &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MediaAdapter(audioType);
            mediaAdapter.play(audioType, fileName);
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            System.out.println(&lt;/span&gt;&quot;Invalid media. &quot;+&lt;span&gt;
                    audioType &lt;/span&gt;+ &quot; format not supported&quot;&lt;span&gt;);
        }
    }
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; adapter() {
        AudioPlayer audioPlayer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AudioPlayer();
        audioPlayer.play(&lt;/span&gt;&quot;mp3&quot;, &quot;beyond the horizon.mp3&quot;&lt;span&gt;);
        audioPlayer.play(&lt;/span&gt;&quot;mp4&quot;, &quot;alone.mp4&quot;&lt;span&gt;);
        audioPlayer.play(&lt;/span&gt;&quot;vlc&quot;, &quot;far far away.vlc&quot;&lt;span&gt;);
        audioPlayer.play(&lt;/span&gt;&quot;avi&quot;, &quot;mind me.avi&quot;&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;结果：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201901/1113901-20190114231949497-185740072.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;四、总结&lt;/h2&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;优点：&lt;/strong&gt; &lt;span&gt;1、可以让任何两个没有关联的类一起运行。 2、提高了类的复用。 3、增加了类的透明度。 4、灵活性好。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;缺点：&lt;/strong&gt; &lt;span&gt;1、过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 2.由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;使用场景：&lt;/strong&gt;&lt;span&gt;有动机地修改一个正常运行的系统的接口，这时应该考虑使用适配器模式。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;strong&gt;注意事项：&lt;/strong&gt;&lt;span&gt;适配器不是在详细设计时添加的，而是解决正在服役的项目的问题。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;span&gt;源代码地址：&lt;a title=&quot;源码地址&quot; href=&quot;https://gitee.com/yuanqinnan/pattern&quot; target=&quot;_blank&quot;&gt;https://gitee.com/yuanqinnan/pattern&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 14 Jan 2019 15:18:00 +0000</pubDate>
<dc:creator>茶底世界</dc:creator>
<og:description>一、引言 最近懒劲又上来了，隔了几天没有学习，最近的博文阅读量也比较少，不过还是希望自己坚持下去，相信水滴石穿，量变总会引起质变的。 今天要学习的是适配器模式，顾名思义，适配器模式是将两个不兼容的接口</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuanqinnan/p/10217368.html</dc:identifier>
</item>
</channel>
</rss>