<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>💕《给产品经理讲JVM》：垃圾收集器 - Vi的技术博客</title>
<link>http://www.cnblogs.com/viyoung/p/12742241.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/viyoung/p/12742241.html</guid>
<description>&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;前言&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上篇中，我们把 JVM 中的垃圾收集算法有了一个大概的了解，又是一个阴雨连绵的周末，宅在家里的我们又开始了新一轮的学习：&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;产品大大：上周末我们说了垃圾收集算法，下面是不是要讲一下这些算法的应用呢？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我：当然，如果说垃圾收集算法是打狗棒法，那么垃圾收集器就是历届的丐帮帮主们，不同的帮主领悟到的自然也就不同，我先对这些帮主进行一个简单的介绍，看图！&lt;/p&gt;
&lt;img src=&quot;http://viyoungblog.oss-cn-beijing.aliyuncs.com/viyoung/2020-03-26-142045.png&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我：我从回收的区域去对垃圾收集器进行了一个简单的划分，大致可以分为这样九种，下面就且听我为你一一道来。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;产品大大：好哒&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;Serial 收集器&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我：下面要说的就是一款非常古老的&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;新生代收集器&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;—— Serial 收集器，它的历史可以追溯到 JDK 还是以1.x命名的时代（大概时间在我五岁的时候？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;产品大大：从 Serial 这个名字上可以看的出，这应该是一款串行（单线程）收集器，对吧？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我：没错，Serial 收集器是一款单线程的收集器，它的收集过程也很简单（如下图），虽然它只会使用一个处理器或一条线程去收集垃圾，但是这里我不喜欢称之为单线程收集器，它更适合&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;串行&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;这个词，因为它在进行 GC 的时候，必须暂停掉其他的线程（Stop The World，STW）&lt;/p&gt;
&lt;img src=&quot;http://viyoungblog.oss-cn-beijing.aliyuncs.com/viyoung/2020-03-29-120946.png&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;产品大大：那么这个收集器是不是已经废弃掉了啊，仅仅停留在历史中，作为一个值得去纪念的东西？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我：其实也并不能这么说，虽然它简单，但是简单有简单的好处，因为单线程，所以没有切换线程的资源开销，所以在单核CPU的环境下，它的表现反而会显得更加优秀，只能说是没有最好的收集器，只有最适合的收集器～&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;产品大大：酱紫哦，那么我们来说下一个收集器吧，这个我已经有一个大概的了解了～&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;ParNew 收集器&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我：下一个收集器啊，叫做 ParNew 收集器，这个收集器和上面我们所说的 Serial 收集器基本上一模一样，除了它会启动多个GC线程去进行垃圾的收集（并行收集）&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;产品大大：并行？我只听过并发哦。。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我：并发指的是工作线程与垃圾收集线程之间的关系，而并行指的是多条垃圾收集线程之间的关系，这两个的概念是不一样的，并行的时候，工作线程处于等待状态。而并发的时候，工作线程处于活动状态。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;产品大大：那么它和 Serial 收集器比起来有什么区别呢？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我：在单线程环境下，Serial 的 GC 效率是要优于它的，但是在多线程环境下，它对于垃圾收集时系统资源的高效利用还是很是颇有成效的。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;产品大大：那么它现在还好嘛～&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我：它在 HotSpot 虚拟机中是第一款退出了历史舞台的收集器，在 JDK 9 的时候，把它等于并入了 CMS 收集器中，而且来一个小小的剧透。。在 JDK 14 中 CMS也被删除掉，从辉煌到落幕，正式结束了在服务端称霸的生涯。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;产品大大：好可怜，呜呜呜呜&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我：？？？停止你的表演，我们继续&lt;/p&gt;
&lt;img src=&quot;http://viyoungblog.oss-cn-beijing.aliyuncs.com/viyoung/2020-03-29-121132.png&quot; alt=&quot;&quot;/&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;Parallel Scavenge 收集器&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我：下面要说的这个也是一个新生代的收集器——Parallel Scavenge 收集器，从表面上来看，它好像和 ParNew 收集器之间没有太大的区别，但是为什么我们要它单独列出来呢？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;产品大大：这是在考我嘛？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我：说说看咯&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;产品大大：虽然这俩货看起来差不多，但是我觉得就像微信和 QQ 的区别一样，这俩货虽然看起来也是很类似，但是它们的区别就在于侧重点不一样，细分市场的不同会让它们虽然有所冲突，但是不会有你死我活的那样恶性的竞争关系，而更偏向于互补，阴阳相生。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我：说的真好，这嘴真能忽悠，怪不得天天开发写不完的需求（默默碎碎念一百句&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我：它更侧重于吞吐量，吞吐量的意思是什么呢，它并不是非常 Care 每次STW的间隔时间，而是更看重对资源的一个整体利用率。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;产品大大：那么我们如何去控制吞吐量呢？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我：有这么两个参数：-XX：MaxGCPauseMillis 和 -XX：GCTimeRatio。第一个是用来控制每次 STW 的时间，第二个是直接设置吞吐量的大小，还有一个参数：-XX：+UseAdaptiveSizePolicy，这个参数是一个布尔值，如果开启这个开关，虚拟机会自动的去调节前两个参数的大小，可以达到一个自适应的效果。这个参数也是一个具有Parallel Scavenge特色的，区别于 ParNew 的所在。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;Serial Old 收集器&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我：新生代的收集到这就告一段落了，下面说一下老年代的三个收集器，第一个是 Serial 收集器的老年代版本——Serial Old 收集器，如其名那样，它和它的新生代收集器—— Serial 收集器一样，是一个单线程的收集器，和新生代的 Serial 不同，它采用的是标记整理算法。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;产品大大：这情侣 id 啧啧，我已经想象到了看到这俩名字的程序猿，冷冷的狗粮往嘴里胡乱的塞&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我：咳咳，虽然这俩是情侣 id ，但是它可以和 Parallel Scavenge 组cp，而且它还是 CMS 的一个备胎。。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;产品大大：？？hetui，男人没有一个好东西，下一个吧下一个&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我：？？（关我毛事儿。。人在家中坐，锅从天上来&lt;/p&gt;
&lt;img src=&quot;http://viyoungblog.oss-cn-beijing.aliyuncs.com/viyoung/2020-03-29-121219.png&quot; alt=&quot;&quot;/&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;Parallel Old 收集器&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我：好了，我们不提刚刚的那个小插曲，下面我们来说一下 Parellel Old 这款老年代的收集器，看这个名字，我们可以知道这款收集器和 Parellel Scavenge 收集器是一家子，它正是 Parallel Scanvenge 的老年代版本，在它出现之前，Serial Old 一直充当着他的角色与 Parallel Scanvenge 进行配合，但是它出来之后，算是把那个小三给赶走了，后来居上的成为了原配。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;产品大大：原来这个就是原配哦，也就是说如果我们看重吞吐量的话，就可以使用它们的 ‘夫妻’ 组合去完成（夫妻搭配，干活不累&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我：是这样的，没错呢，下面我们来介绍一个重量级的收集器，它在 JVM 的垃圾收集器历史中划下了一个浓墨重彩的一笔。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;产品大大：好啊好啊～&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;CMS 收集器&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我：下面要介绍的这款收集器叫做—— CMS（Concurrent Mark Sweep）收集器，为什么说它是一款划时代意义的收集器呢，它是第一款将并发这个词诠释出意义并获得大范围的应用和推广的收集器，就是说，它可以做到一边丢垃圾，一边收垃圾。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;产品大大：那么它的运行流程是什么呢，一定和其他有所不同吧～&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我：看图～&lt;/p&gt;
&lt;img src=&quot;http://viyoungblog.oss-cn-beijing.aliyuncs.com/viyoung/2020-04-13-131933.png&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我：首先由它的名字我们可以知道，它是基于标记——清除算法的，而它分为了四步走：&lt;/p&gt;
&lt;ol data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;初始标记（这一过程耗时很短，只是标记一下GC Roots 能直接关联到的对象&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;并发标记（和用户线程一起运行，虽然耗时较长，但是不会造成STW&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;重新标记（修正在并发标记过程中的变动，耗时比初始长，但是远小于并发标记时间&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;并发清除（和用户线程一起运行，进行并发的清除&lt;/section&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;产品大大：那么 CMS 既然这么优秀，是不是我们一直都在使用这个呢？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我：并不然，一般划时代的下场都不会很好，因为它存在了三个问题：&lt;/p&gt;
&lt;ol data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;对处理器的资源耗费较大，比较敏感&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;在GC的过程中，容易产生新的垃圾，浮动垃圾的产生如果导致并发失败，就会启用Serial Old来进行，这样就很慢很慢了&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;由于它是基于标记——清除算法实现的，所以会产生一些碎片空间，当碎片空间不足以放下对象的时候，就会触发 Full GC&lt;/section&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;产品大大：那么它现在这么样了&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我：它啊，在 JDK 9 中被标记为Deprecate，而在最新更新的 JDK 14 中彻底的退出了历史的舞台，此情可待成追忆，只是当时已惘然啊～&lt;/p&gt;
&lt;img src=&quot;http://viyoungblog.oss-cn-beijing.aliyuncs.com/viyoung/2020-03-26-143035.png&quot; alt=&quot;image-20200326223034422&quot;/&gt;image-20200326223034422 &lt;img src=&quot;http://viyoungblog.oss-cn-beijing.aliyuncs.com/viyoung/2020-03-26-142929.png&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我：下面我来介绍一款当下我们在用的收集器吧，也就是鼎鼎大名的 G1 收集器 ～&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;G1 收集器&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我：Garbage First 也称 G1，冷酷的外表，无情的性能，超前的设计，简直就是一个木得感情的杀手（biu～&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;产品大大：说人话（手动微笑脸&lt;/p&gt;
&lt;img src=&quot;http://viyoungblog.oss-cn-beijing.aliyuncs.com/viyoung/2020-04-18-093247.png&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我： G1 收集器是又一个里程碑意义的收集器，它开创了收集器面向局部收集的设计思路和基于Region的内存布局方式。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;产品大大：此话怎解？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我：在我们之前所了解的收集器中，我们都是基于内存分代理论，把内存区域分为老年代和新生代，不同区域的采用不同的收集器去完成，而G1颠覆了这个概念，它不再去区分所谓的老年代和新生代，而是面向全堆进行收集，把 Java 堆划分为多个大小相等的独立区域，在进行垃圾回收的时候，会将需要回收的区域组合成回收集（Collection Set），哪块儿内存存放的垃圾数量最多，回收收益最大，优先去回收那些收益最大的区域，这也是Garbage First 这个名字的由来～&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;产品大大：那么我有一个疑问，如果对象的大小过于庞大，一个区域无法放下这个对象的时候该怎么办呢？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我：首先说明一下，虽然化整为零，但是仍然保存了老年代和新生代的概念，只不过这一块儿不是一个固定的区域了，而是一系列区域的动态集合，而这些大对象会被存放在 N 个连续的 Humongous Region 中，这些 Region 被视为老年代的一部分～&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;产品大大：那么和CMS相比起来，它的优势在于什么地方呢？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我：相对于CMS来说，最根本的一点，CMS是基于「标记——清除」算法实现的，而 G1 是通过「标记——整理」算法，每个区域之间又是通过「标记——复制」算法，这样的做法不会产生大量的内存碎片，可以使程序更加长时间的稳定运行，省的因为出现大对象无法分配而去进行下一次 Full GC。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;产品大大：那么 G1 的缺点其实也很明显，它的功能很强大，带来的是对内存的负荷和对CPU的压力，毕竟世界上没有免费的午餐～&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我：没错呢，因为在处理跨 Region 引用的时候使用的卡表技术，标记——复制算法这些都会导致它的内存压力要比CMS高20%，但是不论是对于它所带来的提升和红利来说，还是对于一代新人换旧人的历史发展来说，我们无疑是更倾向于去选择 G1 的～&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;产品大大：嗯呐，下面还有嘛～&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我：下面简单的介绍两款实验过程中的收集器吧，虽然不知道未来它们会怎么样，但是它们就像当年的 G1 的一样，未来可期～&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;产品大大：好的呢～&lt;/p&gt;
&lt;img src=&quot;http://viyoungblog.oss-cn-beijing.aliyuncs.com/viyoung/2020-04-18-093640.png&quot; alt=&quot;&quot;/&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;Shenandoah 收集器 &amp;amp;&amp;amp; ZGC 收集器&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我：下面简单介绍一下这两款低延迟收集器，在我们的收集器中，一般主要评判的标准有三种：内存占用。吞吐量。延迟，在这三者之中，我们最多可以在两个之间做到极致，随着我们计算机硬件的发展，内存占用慢慢没有那么重要，人们越来越看重延迟，所以低延迟就称为我们追求的目标，而这两款收集器就是为了达到GC只需 10ms 的目标去的～&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;产品大大：那么它们到底是什么呢？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我：一个叫做Shenandoah收集器，一个叫做ZGC收集器，它们两个功能非常相似，只不过 ZGC 是亲生的，而Shenandoah是抱养的，它们都可以看作是 G1 的继承者，G1 在一定程度上也对这两个代码有所借鉴和改进。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我：ZGC 收集器是一款基于 Region 内存布局的，（暂时）不设分代的，使用了读屏障，染色指针和内存多重映射等技术来实现可并发的标记——整理算法的，以低延迟为首要目标的一款垃圾收集器。它的技术实现，我这里就不再详细去讲了，等到它应用的比较广泛的时候，再去研究也不晚～&lt;/p&gt;
&lt;img src=&quot;http://viyoungblog.oss-cn-beijing.aliyuncs.com/viyoung/2020-04-18-093327.png&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;产品大大：行吧～ 那我们今天到这里，下次我们继续，我们现在出去撸串～&lt;/p&gt;
</description>
<pubDate>Tue, 21 Apr 2020 00:56:00 +0000</pubDate>
<dc:creator>Vi的技术博客</dc:creator>
<og:description>前言 在上篇中，我们把 JVM 中的垃圾收集算法有了一个大概的了解，又是一个阴雨连绵的周末，宅在家里的我们又开始了新一轮的学习： 产品大大：上周末我们说了垃圾收集算法，下面是不是要讲一下这些算法的应用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/viyoung/p/12742241.html</dc:identifier>
</item>
<item>
<title>正则表达式的点星匹配 - 郑州大学老大叔</title>
<link>http://www.cnblogs.com/zzalovelyq/p/12742243.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zzalovelyq/p/12742243.html</guid>
<description>&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;Created on Mon Apr 20 22:51:44 2020
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;@author: 49594
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; re
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; a =&lt;span&gt; input()
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; b =&lt;span&gt; input()
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; m = re.search(b,a,re.I|&lt;span&gt;re.M)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; m!=&lt;span&gt; None:
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;True&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;False&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;个人原创，知道很多人需要，百度上没有，望不再被移出首页推荐区，谢谢博客园后台程序小哥哥&lt;/p&gt;
&lt;p&gt;转载请注明出处&lt;/p&gt;
</description>
<pubDate>Tue, 21 Apr 2020 00:56:00 +0000</pubDate>
<dc:creator>郑州大学老大叔</dc:creator>
<og:description>1 # -*- coding: utf-8 -*- 2 &amp;quot;&amp;quot;&amp;quot; 3 Created on Mon Apr 20 22:51:44 2020 4 5 @author: 49</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zzalovelyq/p/12742243.html</dc:identifier>
</item>
<item>
<title>asp.net mvc 接收jquery ajax发送的数组对象 - JxpStar</title>
<link>http://www.cnblogs.com/jxp0202/p/12742244.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jxp0202/p/12742244.html</guid>
<description>[unable to retrieve full-text content]&lt;script type=&quot;text/javascript&quot;&gt; $(function () { var obj = { name: &quot;军需品&quot;, myclass: [{ one: 1, two: 2, three: 3 }, { one: 11, two: 22, three: 33 }, { on</description>
<pubDate>Tue, 21 Apr 2020 00:56:00 +0000</pubDate>
<dc:creator>JxpStar</dc:creator>
<dc:identifier>https://www.cnblogs.com/jxp0202/p/12742244.html</dc:identifier>
</item>
<item>
<title>【简单了解系列】从基础的使用来深挖HashMap - detectiveHLH</title>
<link>http://www.cnblogs.com/detectiveHLH/p/12742202.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/detectiveHLH/p/12742202.html</guid>
<description>&lt;h2 id=&quot;hhashmap&quot;&gt;&lt;span&gt;HashMap定义&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;说的专业一点，HashMap是常用的用于存储key-value键值对数据的一个&lt;strong&gt;集合&lt;/strong&gt;，底层是基于对&lt;strong&gt;Map&lt;/strong&gt;的接口实现。每一个键值对又叫&lt;strong&gt;Entry&lt;/strong&gt;，这些&lt;strong&gt;Entry&lt;/strong&gt;分散的存储在一个由&lt;strong&gt;数组和链表&lt;/strong&gt;组成的集合中。当然在Java8中，Entry变成了&lt;strong&gt;Node&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;说的通俗一点，就像你去住酒店，你下单提供了你的手机号，然后到酒店了给你一个房卡，你知道了你的房号之后再根据这个房号去找对应的房间一样。&lt;/p&gt;
&lt;p&gt;房号就是key，房间里就是value。你通过手机号下单到酒店给你房号可以理解为对key哈希的过程。你找的过程就是HashMap根据key取到对应value的过程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;hhashmap-1&quot;&gt;&lt;span&gt;HashMap底层结构&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;htable&quot;&gt;&lt;span&gt;table数组&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;首先我们要知道，我们存在HashMap中的数据最终是存了什么地方，就是如下的结构。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;bash language-bash hljs&quot;&gt;transient HashMap.Node&amp;lt;K, V&amp;gt;[] table;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可能有人看到transient有些陌生，被这个关键字修饰的变量将不会被序列化。简单来说，就是序列化之后这个字段的值就会被干掉，用于一些不需要传递给第三方的字段。&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;例如一个矩形，在本地使用的时候，有长、宽和面积三个属性，但是你要把这个对象给第三方用，但是由于面积可以通过另外两个属性推导出来，这个key就不需要传递给第三方了。&lt;/p&gt;
&lt;p&gt;这种情况就可以用transient关键字修饰。总的来说就是，被transient修饰的变量将不再参与序列化。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;hnode&quot;&gt;&lt;span&gt;Node节点&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;下面是Node节点的定义。&lt;/p&gt;
&lt;pre readability=&quot;8.5&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;11&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Node&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;K&lt;/span&gt;, &lt;span class=&quot;hljs-title&quot;&gt;V&lt;/span&gt;&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Entry&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;K&lt;/span&gt;, &lt;span class=&quot;hljs-title&quot;&gt;V&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; hash;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;final&lt;/span&gt; K key;&lt;br/&gt;V value;&lt;br/&gt;Node&amp;lt;K,V&amp;gt; next;&lt;p&gt;Node(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; hash, K key, V value, Node&amp;lt;K,V&amp;gt; next) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.hash = hash;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.key = key;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.value = value;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.next = next;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;......&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;final&lt;/span&gt; V &lt;span class=&quot;hljs-title&quot;&gt;getValue&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; value;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;final&lt;/span&gt; V &lt;span class=&quot;hljs-title&quot;&gt;setValue&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(V newValue)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;V oldValue = value;&lt;br/&gt;value = newValue;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; oldValue;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;......&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码省略了一些&lt;strong&gt;Getter&lt;/strong&gt;和&lt;strong&gt;Setter&lt;/strong&gt;，结构还是非常清晰和简单。可以看到这个节点存储了下一个节点的对象的引用，形成了一个链表的结构。&lt;/p&gt;
&lt;p&gt;为什么要用链表？用数组不行吗？刚刚上面提到过，这个集合是由链表和数组组成的。因为再完美的hash算法都有可能产生哈希冲突，所以两个不同key的元素可以被放在同一个地方。&lt;/p&gt;
&lt;p&gt;而单用数组明显不能满足这个需求，而在数组的槽位上存一个链表就可以解决这个问题。&lt;/p&gt;
&lt;h2 id=&quot;hhashmap-2&quot;&gt;&lt;span&gt;HashMap的使用&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;上面简单了解了HashMap的定义和基本的底层数据结构，接下来通过HashMap在平常开发中的使用来具体看看怎么实现的。&lt;/p&gt;
&lt;pre readability=&quot;4.5&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;3&quot;&gt;Map&amp;lt;String, String&amp;gt; map = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();&lt;p&gt;map.put(&lt;span class=&quot;hljs-string&quot;&gt;&quot;搜索关注公众号&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;SH的全栈笔记&quot;&lt;/span&gt;); &lt;br/&gt;map.get(&lt;span class=&quot;hljs-string&quot;&gt;&quot;搜索关注公众号&quot;&lt;/span&gt;);               &lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;h&quot;&gt;&lt;span&gt;赋值&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;hput&quot;&gt;&lt;span&gt;put函数&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;上面的Put方法，我们传入了两个参数，Key和Value，函数的定义如下。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;java public V put(K key, V value) { return this.putVal(hash(key), key, value, false, true); }&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;应该跟大多数人YY的put方法差不多，put方法再调用了&lt;code&gt;putVal&lt;/code&gt; 方法。&lt;/p&gt;
&lt;p&gt;首先经过了hash之后的key，是一个整型的hashcode，其次是我们传入的key和value。&lt;strong&gt;最后两个布尔值，后面会提到。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先一进入putVal就会声明存放数据的table，如果这个HashMap是首次设置值，就会被初始化一个默认size的table，且所有元素的初始值都是NULL，下面是初始化这块的核心代码，我省略掉了一些无关的变量声明。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;有趣的是，初始化调用的是&lt;code&gt;resize&lt;/code&gt;方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;2&quot;&gt;Node&amp;lt;K,V&amp;gt;[] tab; &lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; n;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; ((tab = table) == &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt; || (n = tab.length) == &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;) {&lt;br/&gt;n = (tab = resize()).length;&lt;br/&gt;}&lt;p&gt;newCap = &lt;span class=&quot;hljs-number&quot;&gt;16&lt;/span&gt;; &lt;br/&gt;newThr = &lt;span class=&quot;hljs-number&quot;&gt;12&lt;/span&gt;; &lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h16&quot;&gt;&lt;span&gt;默认值为啥是16&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;上面初始化table的默认size给的是16，当然我们也可以自己定义，但是建议是最好是2的幂。有的朋（杠）友（精）就要问了，为什么是16呢？我13，14不他不香吗？我们接下来就要分析为什么不香。&lt;/p&gt;
&lt;p&gt;当我们放元素进入map的时候，它是如何确定元素在table数组中的位置的呢？我们拿&lt;code&gt;搜索关注公众号&lt;/code&gt;这个key举例。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;hash = (h = key.hashCode()) ^ h &amp;gt;&amp;gt;&amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;16&lt;/span&gt;&lt;br/&gt;p = tab[i = n - &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; &amp;amp; hash]&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，是将hash之后key和数组的length-1做与运算得到了一个数组下标。而且，hash值的二进制的位数，大多数情况下都会比table的长度的二进制位数多。换句话说，与运算之后得到的数组下标index完全取决于hash值的后几位。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;d language-d&quot;&gt;16 // n   10000&lt;br/&gt;15 // n-1 1111&lt;br/&gt;14 //     1110&lt;br/&gt;13 //     1101&lt;br/&gt;12 //     1100&lt;br/&gt;11 //     1011&lt;br/&gt;10 //     1010&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从13、14的二进制值可以看出来，存在0和1在二进制位数上分布不均匀的情况，这样一来就会造成一个问题，那就是会存在某些&lt;strong&gt;不同的hash值&lt;/strong&gt;经过与运算得到的值是&lt;strong&gt;一样的&lt;/strong&gt;。这样就会导致hash到的index&lt;strong&gt;不均匀&lt;/strong&gt;，换句话说有些index可能永远都不会被hash到，而有些index也被频繁的hash到。&lt;/p&gt;
&lt;p&gt;本来hash算法是要求计算的结果要均匀分布的，但是上述的结果明显不符合均匀分布的要求。用n-1而不用n也是因为同样的道理。如果这个值是2的幂，那么2的幂的值-1的所有二进制位数都是1，这样有利于hash计算的均匀分布。&lt;/p&gt;
&lt;p&gt;综上所述，不一定是16，&lt;strong&gt;2的幂&lt;/strong&gt;都可以，16只是一个经验值。&lt;/p&gt;
&lt;h3 id=&quot;h-1&quot;&gt;&lt;span&gt;自动扩容&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;除了size，初始化的时候还会设定一个阈值，值为12，&lt;code&gt;newThr = 12&lt;/code&gt;，这里需要提到一个概念&lt;strong&gt;负载因子&lt;/strong&gt;，HashMap的实现里默认给的是0.75。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;HashMap&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.loadFactor = &lt;span class=&quot;hljs-number&quot;&gt;0.75F&lt;/span&gt;; &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;负载因子是用来干嘛的呢？最开始我们提到了，最开始存储的数据结构是数组，这种基础结构是有size设定的。当我们不停的往map里存数据的时候，总会存满，当元素快存满的时候，我们就需要扩大map的容量，来容纳更多的元素，这就需要一个&lt;strong&gt;自动扩容&lt;/strong&gt;的机制了。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;不是扩容弹匣，想啥呢&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在当数据量大于超过设定的阈值的时候（容量*负载因子），自动对map进行扩容，以存放更多的数据。&lt;/p&gt;
&lt;p&gt;自动扩容做了什么事情呢？总结来说就是两件事。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;创建新的数组，大小是原来数组的一倍。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;将元素rehash到新的数组&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;为什么要&lt;strong&gt;rehash&lt;/strong&gt;呢？上面我们提到过了，当元素被放进map时，确认下标的方法是&lt;strong&gt;table的长度-1&lt;/strong&gt;和&lt;strong&gt;hash值&lt;/strong&gt;做与运算，现在table的长度发生了变化，那么自然而然，元素获取下标的运算结果也就跟之前的不一样了， 所以需要将老的map中的元素再按照新的table长度&lt;strong&gt;rehash&lt;/strong&gt;到扩容后的table中。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;所以在当你对性能有一定要求，且你知道你创建map的时候size的时候，可以指定size，这样一来就不会因为数据量持续的增大而去频繁的自动扩容了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;hput-1&quot;&gt;&lt;span&gt;put的过程中到底发生了什么&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;了解了&lt;strong&gt;底层数据结构&lt;/strong&gt;和&lt;strong&gt;自动扩容机制&lt;/strong&gt;，接下来我们来看一下put过程中究竟发生了什么。我们上面说过了，会通过&lt;strong&gt;数组的长度-1&lt;/strong&gt;和&lt;strong&gt;hash值&lt;/strong&gt;与运算得到一个数组下标。&lt;/p&gt;
&lt;p&gt;如果该位置没有元素，那么就很简单，直接新建一个节点即可然后放置在数据的具体位置即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;tab[i] = &lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.newNode(hash, key, value, (HashMap.Node)&lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是如果该下标已经有元素了，这种情况HashMap是怎么处理的呢？这也要看情况。&lt;/p&gt;
&lt;ul readability=&quot;5&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;如果是跟当前槽位相同的key，就直接覆盖。这就是我们修改某个key的值会发生的情况。那HashMap怎么来判断是不是同一个key呢？就像下面这样。&lt;code&gt;p&lt;/code&gt;就是当前槽位上已经有的元素，如果新、老元素的key的&lt;strong&gt;hashCode&lt;/strong&gt;和&lt;strong&gt;值&lt;/strong&gt;都相同&lt;strong&gt;且key不为空&lt;/strong&gt;，那么就能证明这两个key是相同的，那么此时只需要&lt;strong&gt;覆盖&lt;/strong&gt;即可。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;p.hash == hash &amp;amp;&amp;amp; ((k = p.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k)))&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;而如果p是&lt;code&gt;TreeNode&lt;/code&gt;的实例，那么就代表当前槽位已经是一个&lt;strong&gt;红黑树&lt;/strong&gt;了，此时只需要往这个树里&lt;code&gt;putTreeVal&lt;/code&gt;即可。至于为什么是红黑树，哪儿来的红黑树，下面马上就要讲到了。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;最后一种情况就是，既不是已经存在的元素也不是TreeNode的实例，也不是&lt;strong&gt;红黑树&lt;/strong&gt;。这种情况下，它就是一个普通的Node。你可以理解为链表，如果hash冲突了，就把这个Node放到该位置的&lt;strong&gt;链表末尾&lt;/strong&gt;。Java8之前采用的&lt;strong&gt;头插法&lt;/strong&gt;，而Java8换成了&lt;strong&gt;尾插法&lt;/strong&gt;，至于为什么要换，后面会讲。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当该位置的链表中的元素超过了&lt;code&gt;TREEIFY_THRESHOLD&lt;/code&gt;所设置的数量时，就会触发树化，将其转化为&lt;strong&gt;红黑树&lt;/strong&gt;。Java8里给的默认值是&lt;strong&gt;8。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;h-2&quot;&gt;&lt;span&gt;为啥要转化成红黑树&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;首先我们要知道为什么要树化。当大量的数据放入Map中，Hash冲突会越来越多，某些位置就会出现一个很长的链表的情况。这种情况下，查询时间复杂度是O(n) ，删除的时间复杂度也是O(n)，查询、删除的效率会大大降低。而同样的数据情况下，平衡二叉树的时间复杂度都是O(logn)。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;有的朋（杠）友（精）看到这个小标题不乐意了，怎么就直接用红黑树了？我用&lt;strong&gt;二叉查找树&lt;/strong&gt;它不香吗？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不了解二叉查找树的，我把它的特点列在了下面。&lt;/p&gt;
&lt;p&gt;再精简一下就是，&lt;strong&gt;左小右大&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;但是，如果数据大量的趋近于有序，例如所有的节点都比根节点大，那这个时候&lt;strong&gt;二叉查找树&lt;/strong&gt;就退化成了&lt;strong&gt;链表&lt;/strong&gt;，查询效率就会急剧下降。看到这是不是觉得有点不对，我才从链表树化，你这又给我退化成了链表？&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;朋友看到这又不乐意了，好好好，就算二叉查找树不行，那AVL树它也不行？用了AVL树就不会出现上面所描述的效率急剧退化的情况了不是吗？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;的确是这样，AVL也可以叫&lt;strong&gt;平衡二叉搜索树&lt;/strong&gt;。AVL树会在其有退化成链表的趋势的时候（左右子树的高度差超过某个阈值）调整树的结构，也就是通过左旋和右旋来使其左右子树的高度尽量平衡。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;OK，OK，就算你解释清楚了为什么要树化，那为什么一定要用&lt;strong&gt;红黑树&lt;/strong&gt;？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;具体的细节也就不在这里赘述，不知不觉已经写了这么多了，直接说结论吧。AVL树的查找速度更快，但是相应的插入和修改的速度较慢。而红黑树则在插入和修改操作较为密集的时候表现更好。&lt;/p&gt;
&lt;p&gt;而总结我们日常的HashMap使用，大多数情况下插入和修改应该是比查找更频繁一些的。而在这种情况下，红黑树的综合表现会更好一些。&lt;/p&gt;
&lt;p&gt;至于红黑树的相关细节，涉及的东西还是挺多，我之后会单独拿一个篇幅来讲。&lt;/p&gt;
&lt;h3 id=&quot;h-3&quot;&gt;&lt;span&gt;为什么要用尾插法&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;我们目前用的最多的是Java8，在Java8中采用的是&lt;strong&gt;尾插法&lt;/strong&gt;，Java8之前采用的是头插法。&lt;/p&gt;
&lt;p&gt;那为什么后面又变成了&lt;strong&gt;尾插法&lt;/strong&gt;呢？放心，肯定不是设计者闲的蛋疼，没事来改个设计。这样做一定是有一定的道理的。在解释这个问题之前，我们先来看看，如果采取头插法在&lt;strong&gt;多线程&lt;/strong&gt;下的情况下会出现什么问题。&lt;/p&gt;
&lt;p&gt;我们讲过，假设数组中index=1的位置已经有了元素&lt;code&gt;A&lt;/code&gt;，之后又有元素&lt;code&gt;B&lt;/code&gt;被分配到了index=1的位置。那么在下标为1的槽位上的链表就变成了B -&amp;gt; A。&lt;/p&gt;
&lt;p&gt;此时再分配了一个新元素&lt;code&gt;C&lt;/code&gt;，链表又被更新成了C -&amp;gt; B -&amp;gt; A。这也是为什么叫&lt;strong&gt;头插法&lt;/strong&gt;，新的元素会被放在链表的头节点，因为当时设计的时候考虑到后被放入map的元素被访问的可能性更大。&lt;/p&gt;
&lt;p&gt;上面讲到了在当不停的往map中放置元素后，超过了设定的阈值，就会触发&lt;strong&gt;自动扩容&lt;/strong&gt;。此时会触发两个操作，一是创建一个容量为之前两倍的底层数组，并且将老的数组中的元素&lt;strong&gt;rehash&lt;/strong&gt;到新的数组中。&lt;/p&gt;
&lt;p&gt;而由于数组的长度发生了变化，这就导致了元素的rehash结果跟之前在老数组中的位置不一样。&lt;/p&gt;
&lt;p&gt;首先我们来模拟一下rehash的过程，假设新的数组中下标为2的槽位是空的。&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;首先元素C，被放置在了其他位置。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;然后元素B，被rehash到了下标为2的槽位， 至此都没有问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;最后元素A，同样被rehash到了下标为2的槽位，此时链表变成了A -&amp;gt; B。到这就有问题了，最开始B的next指向的是A节点。但是rehash之后A的next又指向B，看到这你应该就能明白发生了什么。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我看到很多的对JDK1.7版的HashMap在多线程的情况下扩容会出现死锁的解释都只到了环形链表。但是其实就算是环形链表，只要找到了对应的元素，就会直接退出循环的逻辑，也不会造成死循环。&lt;/p&gt;
&lt;p&gt;实际情况是，当自动扩容形成了环形链表后，当你去Get了一个在entry链上&lt;strong&gt;不存在的元素时&lt;/strong&gt;，就会出现死循环的情况。&lt;/p&gt;
&lt;h2 id=&quot;h-4&quot;&gt;&lt;span&gt;取值&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;上面聊了给HashMap赋值的大概过程，接下来聊一下从HashMap获取值会发生什么。get方法的开始，跟put一样很简单。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; V &lt;span class=&quot;hljs-title&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Object key)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;Node&amp;lt;K,V&amp;gt; e;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; (e = getNode(hash(key), key)) == &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt; ? &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt; : e.value;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，取值的核心操作是&lt;code&gt;getNode&lt;/code&gt;来负责完成的。&lt;/p&gt;
&lt;p&gt;首先第一件事就是去check的第一个元素是不是当前查找的元素。&lt;/p&gt;
&lt;p&gt;如果不是，而且当前槽位已经被树化成了红黑树，就走红黑树的&lt;code&gt;getTreeNode&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;如果还没有被树化，只是普通的链表，则顺着next一路找下去。&lt;/p&gt;
&lt;p&gt;由于get方法逻辑和实现都比较容易理解，就不贴太多源码了。&lt;/p&gt;
&lt;h2 id=&quot;h-5&quot;&gt;&lt;span&gt;结尾&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;由于最近太忙了，工作和生活中的事都巨多，这篇文章是几周利用零零散散的时间写出来的，如果有什么问题，欢迎大家在评论区讨论。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;如果你觉得这篇文章对你有帮助，还麻烦&lt;strong&gt;点个赞&lt;/strong&gt;，&lt;strong&gt;关个注&lt;/strong&gt;，&lt;strong&gt;分个享&lt;/strong&gt;，&lt;strong&gt;留个言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;也可以微信搜索公众号【SH的全栈笔记】，当然也可以直接扫描二维码关注&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/4/20/17196831e5529ff2?w=430&amp;amp;h=430&amp;amp;f=jpeg&amp;amp;s=27150&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;/blockquote&gt;
&lt;p&gt;拜了个拜&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/4/20/17196831e988d422?w=1000&amp;amp;h=744&amp;amp;f=jpeg&amp;amp;s=132135&quot; align=&quot;center&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 21 Apr 2020 00:45:00 +0000</pubDate>
<dc:creator>detectiveHLH</dc:creator>
<og:description>HashMap定义 说的专业一点，HashMap是常用的用于存储key value键值对数据的一个集合，底层是基于对Map的接口实现。每一个键值对又叫Entry，这些Entry分散的存储在一个由数组和</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/detectiveHLH/p/12742202.html</dc:identifier>
</item>
<item>
<title>设计模式杂谈 - muggle1</title>
<link>http://www.cnblogs.com/muggle0/p/12742188.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/muggle0/p/12742188.html</guid>
<description>&lt;h2 id=&quot;关于设计的个人看法&quot;&gt;关于设计的个人看法&lt;/h2&gt;
&lt;p&gt;我们设计一个功能的时候，要考虑的无非是那些问题：可靠性，鲁棒性，解耦性，扩展性，可读性等等。&lt;/p&gt;
&lt;p&gt;我们对代码和功能的设计过程，从面相对象的角度来讲就是一个拟物或者拟人化的一个过程——我们先确定某个功能需要什么样的角色或者“零部件”参与，然后创建对应的类，指定类的角色职能；然后各个类各司其职；然后再考虑类的扩展性相关的问题，做出优化。&lt;/p&gt;
&lt;p&gt;设计功能的第一步当然是明确需求，但是功能落地的重要过程我认为就是拟物拟人化的这个过程。&lt;/p&gt;
&lt;h2 id=&quot;设计案例分析&quot;&gt;设计案例分析&lt;/h2&gt;
&lt;p&gt;现在我们有个需求，异步模块——将要执行的数据放到后台异步去执行，使用场景有数据导入导出，数据库间数据同步等。&lt;/p&gt;
&lt;p&gt;现在我们进行拟物拟人化的过程（角色划分）我将这个功能划分成一下几个角色&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;任务 指要处理的数据等&lt;/li&gt;
&lt;li&gt;资源 这里单指线程池&lt;/li&gt;
&lt;li&gt;任务处理器 处理任务的具体逻辑。&lt;/li&gt;
&lt;li&gt;管理器 负责调度线程，安排任务，将任务分发给各个处理器&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;功能设计到这，这个框架只能满足使用要求，通用性不强；就是说，能用但是比较垃圾。为什么这么说，&lt;/p&gt;
&lt;p&gt;首先，我们任务应该以什么样的形式获取？又以什么样的形式去发布一个一个任务？框架中未做说明，也没有角色来干这个事情，所以我们要在管理器中定义一个命令模式，这个命令就是任务，命令方法就是发布任务，再在其内部使用模板方法模式固定一些算法。再添加一个任务工厂来获取和管理任务。&lt;/p&gt;
&lt;p&gt;然后任务处理器这一端，任务处理逻辑肯定是使用者自己实现的，因此要具有适配性，这个适配性的支持，可以通过接口也可以通过注解，这都无所谓，所以我们还要添加一个任务处理器适配器。&lt;/p&gt;
&lt;p&gt;最后框架就成了这个样子：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;任务（命令）&lt;/li&gt;
&lt;li&gt;任务工厂&lt;/li&gt;
&lt;li&gt;任务处理器&lt;/li&gt;
&lt;li&gt;任务处理器适配器&lt;/li&gt;
&lt;li&gt;管理器&lt;/li&gt;
&lt;li&gt;资源（线程池）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;OK，实话告诉你吧，这个框架和 &lt;code&gt;springmvc&lt;/code&gt; 的原理是一个意思：request 对应任务、 dispatchServlet对应的是管理者，Maphandler 对应的是处理器适配器，controller对应任务处理器， 任务工厂充当一个前端用户角色发送一个个请求。我这里多了个命令发送方的角色让管理器充当了，你也可以在添加一个命令发送器类。这个异步框架流程就如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;调用命令发送器发送一个命令（任务）； 命令发送器根据具体实现来决定这个命令是应该放入到内存中还是放入到数据库里还是直接执行。&lt;/li&gt;
&lt;li&gt;任务工厂从数据库，或者内存或者别的什么地方读取出任务，排根据任务优先级序任务，然后将任务交给管理器。&lt;/li&gt;
&lt;li&gt;管理器根据任务类型匹配到对应的任务处理器，交给任务处理器去处理&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;任务处理器的实现就像springmvc那样，我们可以定义一个处理器接口，然后所有实现该接口的并注入到spring容器的对象都是处理器。也可以定义一个像&lt;code&gt;@requestMaoing&lt;/code&gt;那样的注解，所有加上该注解的方法都会被适配成一个处理，实现起来也很容易。为了方便使用，我们还可以再对任务加一个监听器，我们想发布任务的时候只要抛出一个事件即可，当然这只是附带功能，非必须的功能。&lt;/p&gt;
&lt;h2 id=&quot;关于代码可读性的思考&quot;&gt;关于代码可读性的思考&lt;/h2&gt;
&lt;p&gt;一个好的设计模式还好说，一个使用糟糕的设计模式简直是灾难，作者就经历过这种灾难：设计模式用的莫名其妙，不暗2套路来，命名也无迹可寻，这样的代码可读性就很差。因为设计模式之间类关系本身就很复杂，在少一点注释，真的很难去读懂。那么我们要怎么让一段代码能让别人读懂呢？第一就是加注释，第二就是命名规范。下面我们就来说说设计模式的命名规范吧。&lt;/p&gt;
&lt;p&gt;基本的一些命名：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;模板方法模式的类一般以 &lt;code&gt;template&lt;/code&gt; 结尾&lt;/li&gt;
&lt;li&gt;工厂模式一般以 &lt;code&gt;factory&lt;/code&gt; 结尾&lt;/li&gt;
&lt;li&gt;代理模式一般以 &lt;code&gt;proxy&lt;/code&gt; 结尾，代理方法一般命名为&lt;code&gt;invoke()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;执行命令的方法一般叫&lt;code&gt;execute()&lt;/code&gt; ，命令类一般以 &lt;code&gt;Command&lt;/code&gt; 结尾&lt;/li&gt;
&lt;li&gt;观察者模式中，监听器一般以 &lt;code&gt;listener&lt;/code&gt; 结尾&lt;/li&gt;
&lt;li&gt;建造者一般以 &lt;code&gt;builder&lt;/code&gt; 结尾&lt;/li&gt;
&lt;li&gt;适配器 &lt;code&gt;Adapter&lt;/code&gt; 结尾&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;一些常用的“拟物” 结尾名词&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;处理器/执行器&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Resolver
Processor
Handler
Executor
Performer
Runner
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;管理器控制器&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Controller
Manager
Ordinator
Leader
Master
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;转换器&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Encoder/Decoder
Transformer
Converter
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;映射器&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;Mapper/Mapping
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;Chooser
Selector
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;对于许多源码而言，设计模式都是杂糅在一起的，许多类你不能片面的划为哪一个设计模式，它可能在许多模式里面都充当着角色。我们阅读源码的时候要有通过命名去猜设计模式能力；同时我们也要有一定的联想能力，能够在实战中联想到相关源码，要学会 “抄作业” 。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://muggle.javaboy.org/2019/03/20/home/&quot;&gt;点击关注我的博客&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 21 Apr 2020 00:40:00 +0000</pubDate>
<dc:creator>muggle1</dc:creator>
<og:description>关于设计的个人看法 我们设计一个功能的时候，要考虑的无非是那些问题：可靠性，鲁棒性，解耦性，扩展性，可读性等等。 我们对代码和功能的设计过程，从面相对象的角度来讲就是一个拟物或者拟人化的一个过程——我</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/muggle0/p/12742188.html</dc:identifier>
</item>
<item>
<title>Netty 中的异步编程 Future 和 Promise - rickiyang</title>
<link>http://www.cnblogs.com/rickiyang/p/12742091.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rickiyang/p/12742091.html</guid>
<description>&lt;p&gt;Netty 中大量 I/O 操作都是异步执行，本篇博文来聊聊 Netty 中的异步编程。&lt;/p&gt;
&lt;h4 id=&quot;java--future-提供的异步模型&quot;&gt;Java Future 提供的异步模型&lt;/h4&gt;
&lt;p&gt;JDK 5 引入了 Future 模式。Future 接口是 Java 多线程 Future 模式的实现，在 &lt;code&gt;java.util.concurrent&lt;/code&gt;包中，可以来进行异步计算。&lt;/p&gt;
&lt;p&gt;对于异步编程，我们想要的实现是：提交一个任务，在任务执行期间提交者可以做别的事情，这个任务是在异步执行的，当任务执行完毕通知提交者任务完成获取结果。&lt;/p&gt;
&lt;p&gt;那么在 Future 中是怎么实现的呢？我们先看接口定义：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface Future&amp;lt;V&amp;gt; {

    boolean cancel(boolean mayInterruptIfRunning);

    boolean isCancelled();

    boolean isDone();

    V get() throws InterruptedException, ExecutionException;

    V get(long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们看一个示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class FutureTest {

    public static void main(String[] args) {
        ExecutorService executorService = Executors.newFixedThreadPool(2);
        System.out.println(&quot;start&quot;);
        Future&amp;lt;Integer&amp;gt; submit = executorService.submit(() -&amp;gt; {
            try {
                Thread.sleep(3000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            return 1;
        });
        Integer value = null;
        try {
            value = submit.get();
        } catch (Exception e) {
            e.printStackTrace();
        } 
        System.out.println(value);
        System.out.println(&quot;end&quot;);
        
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Futrue 的使用方式是：投递一个任务到 Future 中执行，操作完之后调用 &lt;code&gt;Future#get()&lt;/code&gt; 或者 &lt;code&gt;Future#isDone()&lt;/code&gt; 方法判断是否执行完毕。从这个逻辑上看， Future 提供的功能是：用户线程需要主动轮询 Future 线程是否完成当前任务，如果不通过轮询是否完成而是同步等待获取则会阻塞直到执行完毕为止。所以从这里看，Future并不是真正的异步，因为它少了一个&lt;strong&gt;回调&lt;/strong&gt;，充其量只能算是一个同步非阻塞模式。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;executorService.submit()&lt;/code&gt;方法获取带返回值的 Future 结果有两种方式：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;一种是通过实现 &lt;code&gt;Callable&lt;/code&gt;接口；&lt;/li&gt;
&lt;li&gt;第二种是中间变量返回。继承 Future 的子类: FutureTask，通过 FutureTask 返回异步结果而不是在主线程中获取（FutureTask 本质也是使用 &lt;code&gt;Callable&lt;/code&gt; 进行创建）。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;上面两种方式的代码就变为这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class FutureTest {

    public static void main(String[] args) {
        ExecutorService executorService = Executors.newFixedThreadPool(2);
        System.out.println(&quot;start&quot;);
        //方式1 通过 executorService 提交一个异步线程
        //Future&amp;lt;Integer&amp;gt; submit = executorService.submit(new NewCallableTask());

        //方式2 通过 FutureTask 包装异步线程的返回，返回结果在 FutureTask 中获取而不是 在提交线程中
        FutureTask&amp;lt;Integer&amp;gt; task = new FutureTask&amp;lt;&amp;gt;(new NewCallableTask());
        executorService.submit(task);
        //-------------方式2--------------

        Integer value = null;
        try {
            value = task.get();
        } catch (Exception e) {
            e.printStackTrace();
        }
        System.out.println(value);
        System.out.println(&quot;end&quot;);

    }

    /**
     * 通过实现 Callable 接口
     */
     static class NewCallableTask implements Callable&amp;lt;Integer&amp;gt; {

        @Override
        public Integer call() throws Exception {
            try {
                Thread.sleep(3000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            return 1;
        }
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一般在使用线程池创建线程执行任务的时候会有两种方式，要么实现 Runnable 接口，要么实现 Callable 接口，它们的区别在于：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Callable 可以在任务结束的时候提供一个返回值，Runnable 无法提供这个功能；&lt;/li&gt;
&lt;li&gt;Callable 的 call 方法分可以抛出异常，而 Runnable 的 run 方法不能抛出异常。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;而我们的异步返回自然是使用 Callable 方式。那么 Callable 是如何实现的呢？&lt;/p&gt;
&lt;p&gt;从 Callable 被提交的地方入手：&lt;code&gt;executorService.submit(task)&lt;/code&gt;, ExecutorService 是一个接口，他的默认实现类是：AbstractExecutorService，我们看这里的 &lt;code&gt;submit()&lt;/code&gt;实现方式：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public &amp;lt;T&amp;gt; Future&amp;lt;T&amp;gt; submit(Callable&amp;lt;T&amp;gt; task) {
  if (task == null) throw new NullPointerException();
  RunnableFuture&amp;lt;T&amp;gt; ftask = newTaskFor(task);
  execute(ftask);
  return ftask;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到将 Callable 又包装成了 RunnableFuture。而这个 &lt;code&gt;RunnableFuture&lt;/code&gt; 就比较神奇，它同时继承了 Runnable 和 Future ，既有线程的能力又有可携带返回值的功能。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface RunnableFuture&amp;lt;V&amp;gt; extends Runnable, Future&amp;lt;V&amp;gt; {
    /**
     * Sets this Future to the result of its computation
     * unless it has been cancelled.
     */
    void run();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以再看 &lt;code&gt;submit()&lt;/code&gt;方法，其实是将 RunnableFuture 线程送入线程池执行，执行是一个新线程，只是这个执行的对象提供了 &lt;code&gt;get()&lt;/code&gt;方法来获取执行结果。&lt;/p&gt;
&lt;p&gt;那么 Callable 优势如何变为 RunnableFuture 的呢？我们看 &lt;code&gt;newTaskFor(task)&lt;/code&gt;方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;protected &amp;lt;T&amp;gt; RunnableFuture&amp;lt;T&amp;gt; newTaskFor(Callable&amp;lt;T&amp;gt; callable) {
  return new FutureTask&amp;lt;T&amp;gt;(callable);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将 Callable 包装为 FutureTask 对象，看到这里又关联到 FutureTask ， ：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class FutureTask&amp;lt;V&amp;gt; implements RunnableFuture&amp;lt;V&amp;gt; {
  
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到 FutureTask 是 RunnableFuture 的子类，这也就解释了上面的示例为什么在线程池中可以提交 FutureTask 实例。&lt;/p&gt;
&lt;p&gt;更详细的执行过程这里就不再分析，重点剖析 Future 的实现过程，它并不是真正的异步，没有实现回调。所以在Java8 中又新增了一个真正的异步函数：CompletableFuture。&lt;/p&gt;
&lt;h4 id=&quot;completablefuture-非阻塞异步编程模型&quot;&gt;CompletableFuture 非阻塞异步编程模型&lt;/h4&gt;
&lt;p&gt;Java 8 中新增加了一个类：CompletableFuture，它提供了非常强大的 Future 的扩展功能，最重要的是实现了回调的功能。&lt;/p&gt;
&lt;p&gt;使用示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class CallableFutureTest {

                
    public static void main(String[] args) {
        System.out.println(&quot;start&quot;);
        /**
         * 异步非阻塞
         */
        CompletableFuture.runAsync(() -&amp;gt; {
            try {
                Thread.sleep(3000);
                System.out.println(&quot;sleep done&quot;);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        
        try {
            Thread.sleep(4000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        
        System.out.println(&quot;done&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;CompletableFuture.runAsync()&lt;/code&gt;方法提供了异步执行无返回值任务的功能。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;ExecutorService executorService = Executors.newFixedThreadPool(100);

CompletableFuture&amp;lt;String&amp;gt; future = CompletableFuture.supplyAsync(() -&amp;gt; {
    // do something
    return &quot;result&quot;;
}, executorService);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;CompletableFuture.supplyAsync()&lt;/code&gt;方法提供了异步执行有返回值任务的功能。&lt;/p&gt;
&lt;p&gt;CompletableFuture源码中有四个静态方法用来执行异步任务：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static &amp;lt;U&amp;gt; CompletableFuture&amp;lt;U&amp;gt; supplyAsync(Supplier&amp;lt;U&amp;gt; supplier){..}

public static &amp;lt;U&amp;gt; CompletableFuture&amp;lt;U&amp;gt; supplyAsync(Supplier&amp;lt;U&amp;gt; supplier,Executor executor){..}

public static CompletableFuture&amp;lt;Void&amp;gt; runAsync(Runnable runnable){..}

public static CompletableFuture&amp;lt;Void&amp;gt; runAsync(Runnable runnable,
Executor executor){..}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;前面两个可以看到是带返回值的方法，后面两个是不带返回值的方法。同时支持传入自定义的线程池，如果不传入线程池的话默认是使用 &lt;code&gt;ForkJoinPool.commonPool()&lt;/code&gt; 作为它的线程池执行异步代码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;合并两个异步任务&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果有两个任务需要异步执行，且后面需要对这两个任务的结果进行合并处理，CompletableFuture 也支持这种处理：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;ExecutorService executorService = Executors.newFixedThreadPool(100);

CompletableFuture&amp;lt;String&amp;gt; future1 = CompletableFuture.supplyAsync(() -&amp;gt; {
    return &quot;Task1&quot;;
}, executorService);
CompletableFuture&amp;lt;String&amp;gt; future2 = CompletableFuture.supplyAsync(() -&amp;gt; {
    return &quot;Task2&quot;;
}, executorService);
CompletableFuture&amp;lt;String&amp;gt; future = future1.thenCombineAsync(future2, (task1, task2) -&amp;gt; {
    return task1 + task2; // return &quot;Task1Task2&quot; String
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过 &lt;code&gt;CompletableFuture.thenCombineAsync()&lt;/code&gt;方法获取两个任务的结果然后进行相应的操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;下一个依赖上一个的结果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果第二个任务依赖第一个任务的结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;ExecutorService executorService = Executors.newFixedThreadPool(100);

CompletableFuture&amp;lt;String&amp;gt; future1 = CompletableFuture.supplyAsync(() -&amp;gt; {
    return &quot;Task1&quot;;
}, executorService);
CompletableFuture&amp;lt;String&amp;gt; future = future1.thenComposeAsync(task1 -&amp;gt; {
    return CompletableFuture.supplyAsync(() -&amp;gt; {
        return task1 + &quot;Task2&quot;; // return &quot;Task1Task2&quot; String
    });
}, executorService);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;CompletableFuture.thenComposeAsync()&lt;/code&gt;支持将第一个任务的结果传入第二个任务中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;常用 API 介绍&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;拿到上一个任务的结果做后续操作，上一个任务完成后的动作&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public CompletableFuture&amp;lt;T&amp;gt;     whenComplete(BiConsumer&amp;lt;? super T,? super Throwable&amp;gt; action)
public CompletableFuture&amp;lt;T&amp;gt;     whenCompleteAsync(BiConsumer&amp;lt;? super T,? super Throwable&amp;gt; action)
public CompletableFuture&amp;lt;T&amp;gt;     whenCompleteAsync(BiConsumer&amp;lt;? super T,? super Throwable&amp;gt; action, Executor executor)
public CompletableFuture&amp;lt;T&amp;gt;     exceptionally(Function&amp;lt;Throwable,? extends T&amp;gt; fn)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面四个方法表示在当前阶段任务完成之后下一步要做什么。whenComplete 表示在当前线程内继续做下一步，带 Async 后缀的表示使用新线程去执行。&lt;/p&gt;
&lt;ol start=&quot;2&quot; readability=&quot;20.5&quot;&gt;&lt;li readability=&quot;18&quot;&gt;
&lt;p&gt;拿到上一个任务的结果做后续操作，使用 handler 来处理逻辑，可以返回与第一阶段处理的返回类型不一样的返回类型。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public &amp;lt;U&amp;gt; CompletableFuture&amp;lt;U&amp;gt;  handle(BiFunction&amp;lt;? super T,Throwable,? extends U&amp;gt; fn)
public &amp;lt;U&amp;gt; CompletableFuture&amp;lt;U&amp;gt;  handleAsync(BiFunction&amp;lt;? super T,Throwable,? extends U&amp;gt; fn)
public &amp;lt;U&amp;gt; CompletableFuture&amp;lt;U&amp;gt;  handleAsync(BiFunction&amp;lt;? super T,Throwable,? extends U&amp;gt; fn, Executor executor)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Handler 与 whenComplete 的区别是 handler 是可以返回一个新的 CompletableFuture 类型的。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;CompletableFuture&amp;lt;Integer&amp;gt; f1 = CompletableFuture.supplyAsync(() -&amp;gt; {
    return &quot;hahaha&quot;;
}).handle((r, e) -&amp;gt; {
    return 1;
});
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;11&quot;&gt;
&lt;p&gt;拿到上一个任务的结果做后续操作， thenApply方法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public &amp;lt;U&amp;gt; CompletableFuture&amp;lt;U&amp;gt;  thenApply(Function&amp;lt;? super T,? extends U&amp;gt; fn)
public &amp;lt;U&amp;gt; CompletableFuture&amp;lt;U&amp;gt;  thenApplyAsync(Function&amp;lt;? super T,? extends U&amp;gt; fn)
public &amp;lt;U&amp;gt; CompletableFuture&amp;lt;U&amp;gt;  thenApplyAsync(Function&amp;lt;? super T,? extends U&amp;gt; fn, Executor executor)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意到 thenApply 方法的参数中是没有 Throwable，这就意味着如有有异常就会立即失败，不能在处理逻辑内处理。且 thenApply 返回的也是新的 CompletableFuture。 这就是它与前面两个的区别。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;9&quot;&gt;
&lt;p&gt;拿到上一个任务的结果做后续操作，可以不返回任何值，thenAccept方法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public CompletableFuture&amp;lt;Void&amp;gt;  thenAccept(Consumer&amp;lt;? super T&amp;gt; action)
public CompletableFuture&amp;lt;Void&amp;gt;  thenAcceptAsync(Consumer&amp;lt;? super T&amp;gt; action)
public CompletableFuture&amp;lt;Void&amp;gt;  thenAcceptAsync(Consumer&amp;lt;? super T&amp;gt; action, Executor executor)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看这里的示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;CompletableFuture.supplyAsync(() -&amp;gt; {
  return &quot;result&quot;;
}).thenAccept(r -&amp;gt; {
  System.out.println(r);
}).thenAccept(r -&amp;gt; {
  System.out.println(r);
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行完毕是不会返回任何值的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;CompletableFuture 的特性提现在执行完 runAsync 或者 supplyAsync 之后的操作上。CompletableFuture 能够将回调放到与任务不同的线程中执行，也能将回调作为继续执行的同步函数，在与任务相同的线程中执行。它避免了传统回调最大的问题，那就是能够将控制流分离到不同的事件处理器中。&lt;/p&gt;
&lt;p&gt;另外当你依赖 CompletableFuture 的计算结果才能进行下一步的时候，无需手动判断当前计算是否完成，可以通过 CompletableFuture 的事件监听自动去完成。&lt;/p&gt;
&lt;h4 id=&quot;netty-中的异步编程&quot;&gt;Netty 中的异步编程&lt;/h4&gt;
&lt;p&gt;说 Netty 中的异步编程之前先说一个异步编程模型：Future/Promise异步模型。&lt;/p&gt;
&lt;blockquote readability=&quot;12.089810017271&quot;&gt;
&lt;p&gt;future和promise起源于&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B8%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80&quot;&gt;函数式编程&lt;/a&gt;和相关范例（如&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%82%8F%E8%BC%AF%E7%B7%A8%E7%A8%8B&quot;&gt;逻辑编程&lt;/a&gt; ），目的是将值（future）与其计算方式（promise）分离，从而允许更灵活地进行计算，特别是通过并行化。&lt;/p&gt;
&lt;p&gt;Future 表示目标计算的返回值，Promise 表示计算的方式，这个模型将返回结果和计算逻辑分离，目的是为了让计算逻辑不影响返回结果，从而抽象出一套异步编程模型。那计算逻辑如何与结果关联呢？它们之间的纽带就是 callback。&lt;/p&gt;
&lt;p&gt;引用自：&lt;a href=&quot;https://zh.wikipedia.org/wiki/Future%E4%B8%8Epromise&quot;&gt;https://zh.wikipedia.org/wiki/Future%E4%B8%8Epromise&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在 Netty 中的异步编程就是基于该模型来实现。Netty 中非常多的异步调用，最简单的例子就是我们 Server 和 Client 端启动的例子：&lt;/p&gt;
&lt;p&gt;Server：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1607781/202004/1607781-20200421074338686-31875767.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Client：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1607781/202004/1607781-20200421074349869-1906798285.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Netty 中使用了一个 ChannelFuture 来实现异步操作，看似与 Java 中的 Future 相似，我们看一下代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface ChannelFuture extends Future&amp;lt;Void&amp;gt; {
  
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里 ChannelFuture 继承了一个 Future，这是 Java 中的 Future 吗？跟下去发现并不是 JDK 的，而是 Netty 自己实现的。该类位于：&lt;code&gt;io.netty.util.concurrent&lt;/code&gt;包中：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface Future&amp;lt;V&amp;gt; extends java.util.concurrent.Future&amp;lt;V&amp;gt; {
  
  // 只有IO操作完成时才返回true
  boolean isSuccess();
  // 只有当cancel(boolean)成功取消时才返回true
  boolean isCancellable();
  // IO操作发生异常时，返回导致IO操作以此的原因，如果没有异常，返回null
  Throwable cause();
  // 向Future添加事件，future完成时，会执行这些事件，如果add时future已经完成，会立即执行监听事件
  Future&amp;lt;V&amp;gt; addListener(GenericFutureListener&amp;lt;? extends Future&amp;lt;? super V&amp;gt;&amp;gt; listener);
  Future&amp;lt;V&amp;gt; addListeners(GenericFutureListener&amp;lt;? extends Future&amp;lt;? super V&amp;gt;&amp;gt;... listeners);
  // 移除监听事件，future完成时，不会触发
  Future&amp;lt;V&amp;gt; removeListener(GenericFutureListener&amp;lt;? extends Future&amp;lt;? super V&amp;gt;&amp;gt; listener);
  Future&amp;lt;V&amp;gt; removeListeners(GenericFutureListener&amp;lt;? extends Future&amp;lt;? super V&amp;gt;&amp;gt;... listeners);
  // 等待future done
  Future&amp;lt;V&amp;gt; sync() throws InterruptedException;
  // 等待future done，不可打断
  Future&amp;lt;V&amp;gt; syncUninterruptibly();
  // 等待future完成
  Future&amp;lt;V&amp;gt; await() throws InterruptedException;
  // 等待future 完成，不可打断
  Future&amp;lt;V&amp;gt; awaitUninterruptibly();
  boolean await(long timeout, TimeUnit unit) throws InterruptedException;
  boolean await(long timeoutMillis) throws InterruptedException;
  boolean awaitUninterruptibly(long timeout, TimeUnit unit);
  boolean awaitUninterruptibly(long timeoutMillis);
  // 立刻获得结果，如果没有完成，返回null
  V getNow();
  // 如果成功取消，future会失败，导致CancellationException
  @Override
  boolean cancel(boolean mayInterruptIfRunning);
  
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Netty 自己实现的 Future 继承了 JDK 的 Future，新增了 &lt;code&gt;sync()&lt;/code&gt; 和 &lt;code&gt;await()&lt;/code&gt; 用于阻塞等待，还加了 Listeners，只要任务结束去回调 Listener 就可以了，那么我们就不一定要主动调用 &lt;code&gt;isDone()&lt;/code&gt; 来获取状态，或通过 &lt;code&gt;get()&lt;/code&gt; 阻塞方法来获取值。&lt;/p&gt;
&lt;p&gt;Netty的 Future 与 Java 的 Future 虽然类名相同，但功能上略有不同，Netty 中引入了 Promise 机制。在 Java 的 Future 中，业务逻辑为一个 Callable 或 Runnable 实现类，该类的 &lt;code&gt;call()&lt;/code&gt;或 &lt;code&gt;run()&lt;/code&gt;执行完毕意味着业务逻辑的完结，在 Promise 机制中，可以在业务逻辑中人工设置业务逻辑的成功与失败，这样更加方便的监控自己的业务逻辑。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface Promise&amp;lt;V&amp;gt; extends Future&amp;lt;V&amp;gt; {
        // 设置future执行结果为成功
    Promise&amp;lt;V&amp;gt; setSuccess(V result);
        
        // 尝试设置future执行结果为成功,返回是否设置成功
    boolean trySuccess(V result);
        // 设置失败
    Promise&amp;lt;V&amp;gt; setFailure(Throwable cause);
        // 尝试设置future执行结果为失败,返回是否设置成功 
    boolean tryFailure(Throwable cause);
    // 设置为不能取消
    boolean setUncancellable();
        
        // 源码中，以下为覆盖了Future的方法，例如；
        
        Future&amp;lt;V&amp;gt; addListener(GenericFutureListener&amp;lt;? extends Future&amp;lt;? super V&amp;gt;&amp;gt; listener);
        
        @Override
    Promise&amp;lt;V&amp;gt; addListener(GenericFutureListener&amp;lt;? extends Future&amp;lt;? super V&amp;gt;&amp;gt; listener);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Promise 接口继承自 Future 接口，重点添加了上述几个方法，可以人工设置 future 的执行成功与失败，并通知所有监听的 listener。&lt;/p&gt;
&lt;p&gt;从 Future 和 Promise 提供的方法来看，Future 都是 get 类型的方法，主要用来判断当前任务的状态。而 Promise 中是 set 类型的方法，主要来对任务的状态来进行操作。这里就体现出来将 结果和操作过程分离的设计。&lt;/p&gt;
&lt;p&gt;Promise 实现类是DefaultPromise类，该类十分重要，Future 的 listener 机制也是由它实现的，所以我们先来分析一下该类。先来看一下它的重要属性：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 可以嵌套的Listener的最大层数，可见最大值为8
private static final int MAX_LISTENER_STACK_DEPTH = Math.min(8,
                                                           SystemPropertyUtil.getInt(&quot;io.netty.defaultPromise.maxListenerStackDepth&quot;, 8));
// result字段由使用RESULT_UPDATER更新
@SuppressWarnings(&quot;rawtypes&quot;)
private static final AtomicReferenceFieldUpdater&amp;lt;DefaultPromise, Object&amp;gt; RESULT_UPDATER;
private static final Signal SUCCESS = Signal.valueOf(DefaultPromise.class, &quot;SUCCESS&quot;);
// 异步操作不可取消
private static final Signal UNCANCELLABLE = Signal.valueOf(DefaultPromise.class, &quot;UNCANCELLABLE&quot;);
// 异步操作失败时保存异常原因
private static final CauseHolder CANCELLATION_CAUSE_HOLDER = new CauseHolder(ThrowableUtil.unknownStackTrace(
  new CancellationException(), DefaultPromise.class, &quot;cancel(...)&quot;));
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第一个套 listener，是指在 listener 的 &lt;code&gt;operationComplete()&lt;/code&gt; 方法中，可以再次使用 &lt;code&gt;future.addListener()&lt;/code&gt; 继续添加 listener，Netty 限制的最大层数是8，用户可使用系统变量&lt;code&gt;io.netty.defaultPromise.maxListenerStackDepth&lt;/code&gt;设置。&lt;/p&gt;
&lt;p&gt;为了更好的说明，先写了一个示例，Netty 中的 Future/Promise模型是可以单独拿出来使用的。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.util.concurrent.DefaultPromise;
import io.netty.util.concurrent.Promise;

import java.util.concurrent.TimeUnit;

/**
 * @author rickiyang
 * @date 2020-04-19
 * @Desc TODO
 */
public class PromiseTest {

    public static void main(String[] args) {
        PromiseTest testPromise = new PromiseTest();
        Promise&amp;lt;String&amp;gt; promise = testPromise.doSomething(&quot;哈哈&quot;);
        promise.addListener(future -&amp;gt; System.out.println(promise.get()+&quot;, something is done&quot;));

    }

    /**
     * 创建一个DefaultPromise并返回，将业务逻辑放入线程池中执行
     * @param value
     * @return
     */
    private Promise&amp;lt;String&amp;gt; doSomething(String value) {
        NioEventLoopGroup loop = new NioEventLoopGroup();
        DefaultPromise&amp;lt;String&amp;gt; promise = new DefaultPromise&amp;lt;&amp;gt;(loop.next());
        loop.schedule(() -&amp;gt; {
            try {
                Thread.sleep(1000);
                promise.setSuccess(&quot;执行成功。&quot; + value);
                return promise;
            } catch (InterruptedException ignored) {
                promise.setFailure(ignored);
            }
            return promise;
        }, 0, TimeUnit.SECONDS);
        return promise;
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过这个例子可以看到，Promise 能够在业务逻辑线程中通知 Future 成功或失败，由于 Promise 继承了 Netty 的 Future，因此可以加入监听事件。而 Future 和 Promise 的好处在于，获取到 Promise 对象后可以为其设置异步调用完成后的操作，然后立即继续去做其他任务。&lt;/p&gt;
&lt;p&gt;来看一下 addListener() 方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Override
public Promise&amp;lt;V&amp;gt; addListener(GenericFutureListener&amp;lt;? extends Future&amp;lt;? super V&amp;gt;&amp;gt; listener) {
  checkNotNull(listener, &quot;listener&quot;);
        //并发控制，保证多线程情况下只有一个线程执行添加操作
  synchronized (this) {
    addListener0(listener);
  }
        // 操作完成，通知监听者
  if (isDone()) {
    notifyListeners();
  }

  return this;
}



private void addListener0(GenericFutureListener&amp;lt;? extends Future&amp;lt;? super V&amp;gt;&amp;gt; listener) {
  if (listeners == null) {
    listeners = listener;
  } else if (listeners instanceof DefaultFutureListeners) {
    // 如果当前Promise实例持有listeners的是DefaultFutureListeners类型，则调用它的add()方法进行添加
    ((DefaultFutureListeners) listeners).add(listener);
  } else {
    // 步入这里说明当前Promise实例持有listeners为单个GenericFutureListener实例，需要转换为DefaultFutureListeners实例
    listeners = new DefaultFutureListeners((GenericFutureListener&amp;lt;? extends Future&amp;lt;V&amp;gt;&amp;gt;) listeners, listener);
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里看到有一个全局变量 &lt;code&gt;listeners&lt;/code&gt;，我们看到他的定义：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private Object listeners;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为啥会是一个 Object 类型的对象呢，不是应该是 List 或者是数组才对嘛。Netty之所以这样设计，是因为大多数情况下 listener 只有一个，用集合和数组都会造成浪费。当只有一个 listener 时，该字段为一个 GenericFutureListener 对象；当多于一个 listener 时，该字段为 DefaultFutureListeners ，可以储存多个 listener。&lt;/p&gt;
&lt;p&gt;我们再来看 &lt;code&gt;notifyListeners()&lt;/code&gt; 方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private void notifyListeners() {
  EventExecutor executor = executor();
  //当前EventLoop线程需要检查listener嵌套
  if (executor.inEventLoop()) {
    final InternalThreadLocalMap threadLocals = InternalThreadLocalMap.get();
    //这里是当前listener的嵌套层数
    final int stackDepth = threadLocals.futureListenerStackDepth();
    if (stackDepth &amp;lt; MAX_LISTENER_STACK_DEPTH) {
      threadLocals.setFutureListenerStackDepth(stackDepth + 1);
      try {
        notifyListenersNow();
      } finally {
        threadLocals.setFutureListenerStackDepth(stackDepth);
      }
      return;
    }
  }
        //外部线程直接提交给新线程执行
  safeExecute(executor, new Runnable() {
    @Override
    public void run() {
      notifyListenersNow();
    }
  });
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里有个疑问就是为什么要设置当前的调用栈深度+1。&lt;/p&gt;
&lt;p&gt;接着看真正执行通知的方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private void notifyListenersNow() {
  Object listeners;
  synchronized (this) {
     // 正在通知或已没有监听者（外部线程删除）直接返回
    if (notifyingListeners || this.listeners == null) {
      return;
    }
    notifyingListeners = true;
    listeners = this.listeners;
    this.listeners = null;
  }
  for (;;) {
    //只有一个listener
    if (listeners instanceof DefaultFutureListeners) {
      notifyListeners0((DefaultFutureListeners) listeners);
    } else {
      //有多个listener
      notifyListener0(this, (GenericFutureListener&amp;lt;? extends Future&amp;lt;V&amp;gt;&amp;gt;) listeners);
    }
    synchronized (this) {
      if (this.listeners == null) {
        // 执行完毕且外部线程没有再添加监听者
        notifyingListeners = false;
        return;
      }
      //外部线程添加了新的监听者继续执行
      listeners = this.listeners;
      this.listeners = null;
    }
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Netty 中 DefalutPromise 是一个非常常用的类，这是 Promise 实现的基础。DefaultChannelPromise DefalutPromise 的子类，加入了 channel 这个属性。&lt;/p&gt;
&lt;p&gt;Promise 目前支持两种类型的监听器：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;GenericFutureListener：支持泛型的 Future ；&lt;/li&gt;
&lt;li&gt;GenericProgressiveFutureListener：它是&lt;code&gt;GenericFutureListener&lt;/code&gt;的子类，支持进度表示和支持泛型的Future 监听器（有些场景需要多个步骤实现，类似于进度条那样）。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;为了让 Promise 支持多个监听器，Netty 添加了一个默认修饰符修饰的&lt;code&gt;DefaultFutureListeners&lt;/code&gt;类用于保存监听器实例数组：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;final class DefaultFutureListeners {

    private GenericFutureListener&amp;lt;? extends Future&amp;lt;?&amp;gt;&amp;gt;[] listeners;
    private int size;
    private int progressiveSize; // the number of progressive listeners
    
    // 这个构造相对特别，是为了让Promise中的listeners（Object类型）实例由单个GenericFutureListener实例转换为DefaultFutureListeners类型
    @SuppressWarnings(&quot;unchecked&quot;)
    DefaultFutureListeners(GenericFutureListener&amp;lt;? extends Future&amp;lt;?&amp;gt;&amp;gt; first, GenericFutureListener&amp;lt;? extends Future&amp;lt;?&amp;gt;&amp;gt; second) {
        listeners = new GenericFutureListener[2];
        listeners[0] = first;
        listeners[1] = second;
        size = 2;
        if (first instanceof GenericProgressiveFutureListener) {
            progressiveSize ++;
        }
        if (second instanceof GenericProgressiveFutureListener) {
            progressiveSize ++;
        }
    }

    public void add(GenericFutureListener&amp;lt;? extends Future&amp;lt;?&amp;gt;&amp;gt; l) {
        GenericFutureListener&amp;lt;? extends Future&amp;lt;?&amp;gt;&amp;gt;[] listeners = this.listeners;
        final int size = this.size;
        // 注意这里，每次扩容数组长度是原来的2倍
        if (size == listeners.length) {
            this.listeners = listeners = Arrays.copyOf(listeners, size &amp;lt;&amp;lt; 1);
        }
        // 把当前的GenericFutureListener加入数组中
        listeners[size] = l;
        // 监听器总数量加1
        this.size = size + 1;
        // 如果为GenericProgressiveFutureListener，则带进度指示的监听器总数量加1
        if (l instanceof GenericProgressiveFutureListener) {
            progressiveSize ++;
        }
    }

    public void remove(GenericFutureListener&amp;lt;? extends Future&amp;lt;?&amp;gt;&amp;gt; l) {
        final GenericFutureListener&amp;lt;? extends Future&amp;lt;?&amp;gt;&amp;gt;[] listeners = this.listeners;
        int size = this.size;
        for (int i = 0; i &amp;lt; size; i ++) {
            if (listeners[i] == l) {
                // 计算需要需要移动的监听器的下标
                int listenersToMove = size - i - 1;
                if (listenersToMove &amp;gt; 0) {
                    // listenersToMove后面的元素全部移动到数组的前端
                    System.arraycopy(listeners, i + 1, listeners, i, listenersToMove);
                }
                // 当前监听器总量的最后一个位置设置为null，数量减1
                listeners[-- size] = null;
                this.size = size;
                // 如果监听器是GenericProgressiveFutureListener，则带进度指示的监听器总数量减1
                if (l instanceof GenericProgressiveFutureListener) {
                    progressiveSize --;
                }
                return;
            }
        }
    }
    
    // 返回监听器实例数组
    public GenericFutureListener&amp;lt;? extends Future&amp;lt;?&amp;gt;&amp;gt;[] listeners() {
        return listeners;
    }
    
    // 返回监听器总数量
    public int size() {
        return size;
    }
    
    // 返回带进度指示的监听器总数量
    public int progressiveSize() {
        return progressiveSize;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上就是关于 Promise 和监听器相关的实现分析，再回到之前的启动类，是不是还有一个 sync() 方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Override
public Promise&amp;lt;V&amp;gt; sync() throws InterruptedException {
  await();
  rethrowIfFailed();
  return this;
}


public Promise&amp;lt;V&amp;gt; await() throws InterruptedException {
  // 异步操作已经完成，直接返回
  if (isDone()) {
    return this;    
  }
  if (Thread.interrupted()) {
    throw new InterruptedException(toString());
  }
  // 死锁检测
  checkDeadLock();
  // 同步使修改waiters的线程只有一个
  synchronized (this) {
    while (!isDone()) { // 等待直到异步操作完成
      incWaiters();   // ++waiters;
      try {
        wait(); // JDK方法
      } finally {
        decWaiters(); // --waiters
      }
    }
  }
  return this;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里其实就是一个同步检测当前事件是否完成的过程。&lt;/p&gt;
&lt;p&gt;以上就是 Netty 中实现的 Future/Promise 异步回调机制。实现并不是很难懂，代码很值得学习。除了 Netty 中实现了 Future/Promise模型，在Guava中也有相关的实现，大家日常使用可以看习惯引用相关的包。&lt;/p&gt;
&lt;p&gt;Guava实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;&amp;lt;dependency&amp;gt;
   &amp;lt;groupId&amp;gt;com.google.guava&amp;lt;/groupId&amp;gt;
   &amp;lt;artifactId&amp;gt;guava&amp;lt;/artifactId&amp;gt;
   &amp;lt;version&amp;gt;21.0&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
  
ListeningExecutorService service = MoreExecutors.listeningDecorator(Executors.newSingleThreadExecutor());
ListenableFuture&amp;lt;Integer&amp;gt; future = service.submit(new Callable&amp;lt;Integer&amp;gt;() {
    public Integer call() throws Exception {
        TimeUnit.SECONDS.sleep(5);
        return 100;
    }
});
Futures.addCallback(future, new FutureCallback&amp;lt;Integer&amp;gt;() {
    public void onSuccess(Integer result) {
        System.out.println(&quot;success:&quot; + result);
    }

    public void onFailure(Throwable throwable) {
        System.out.println(&quot;fail, e = &quot; + throwable);
    }
});

Thread.currentThread().join();
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 20 Apr 2020 23:45:00 +0000</pubDate>
<dc:creator>rickiyang</dc:creator>
<og:description>Netty 中的异步编程 Future 和 Promise</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/rickiyang/p/12742091.html</dc:identifier>
</item>
<item>
<title>从零开始开发和搭建直播平台-教程汇总篇 - eguid</title>
<link>http://www.cnblogs.com/eguid/p/12741787.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/eguid/p/12741787.html</guid>
<description>&lt;div class=&quot;toc&quot;&gt;
&lt;h3&gt;从零开始开发和搭建直播平台-教程汇总篇&lt;/h3&gt;
&lt;/div&gt;

&lt;div class=&quot;cl-preview-section&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;之前也分享过不少零散的技术文章，包括&lt;strong&gt;音视频、图像处理和流媒体服务&lt;/strong&gt;相关的技术都略有涉猎。但是，都写得比较偏具体功能的实现，不够系统。因此也让很多读者产生迷惑和不解。需要读者对流媒体相关的架构和知识有一定的了解之后才能上手。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cl-preview-section&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;对于开发者而言，这些都还好说。但是对于非技术型读者来说，可以说是直接劝退了，因此本系列文章分为面向开发者得&lt;strong&gt;技术向&lt;/strong&gt; 和 &lt;strong&gt;非技术向&lt;/strong&gt;两种教程分别更新，对于“非技术向”系列教程将不会出现代码编写，力求通俗易懂；对于开发者得“技术向”系列教程将会出现大量得代码开发和优化教程。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cl-preview-section&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;本系列文章将以具体的应用场景作为实战教程，系统的讲解整个直播平台的架构是如何设计的，如何开发这些子系统或者模块功能，从而搭建一套完整的直播平台。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cl-preview-section&quot; readability=&quot;7&quot;&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;补充：本教程也适用于&lt;strong&gt;视频会议&lt;/strong&gt;，&lt;strong&gt;视频监控&lt;/strong&gt;等应用场景。视频会议与直播中的连麦原理是相同的，视频监控与直播平台的差别是没有主动推流端，多了拉流或者转流端。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;p&gt;
&lt;h2&gt;直播平台结构&lt;/h2&gt;
&lt;/p&gt;
&lt;div class=&quot;cl-preview-section&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;为了防止出现盲人摸象的问题。以我们将由面到点的从整体了解整个直播平台的结构，然后把这个面分解成一个个子系统或者具体模块功能，这样，我们才能够清晰的了解直播平台下每个系统模块的功能是做什么的，如何运行的。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cl-preview-section&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;最简单的直播平台结构：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020042023071833.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VndWlkXzE=,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;最简单的直播平台架构&quot; width=&quot;300&quot; height=&quot;300&quot;/&gt;事实上我们只要搭建了流媒体服务，就已经完成最简单的直播平台了。剩下的就是等直播UP主推流，然后用户观看就可以了，是不是很简单。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cl-preview-section&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;当然了，光是这样还不行，用户不知道如何获取和播放你得直播地址，直播UP主也不知道往哪里推流，直播平台就是帮助用户显示直播UP主的房间，方便筛选和观看，也方便用户发弹幕能够和正在直播的up主交流。至于直播UP主这块的推流，还是需要知道直播地址并使用OBS等推流工具进行推流才可以直播。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cl-preview-section&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;CDN分发&lt;/strong&gt;：&lt;br/&gt;为什么会用到CDN分发，这是因为使用直播平台观看直播的用户多了以后出现了一个重大问题，那就是带宽不够了。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cl-preview-section&quot; readability=&quot;7.5&quot;&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;举个例子：假设你只有一个直播UP主在推一路1080P高清直播，码率是4Mbps/s（每秒512KB），现在有一千个用户同时在观看，每个用户拉流也是4Mbps/s（每秒512KB），那么一千人同时就需要4000Mbp/s（每秒500MB的实时流量）的带宽，也就是说不到三千的用户就需要一万兆的带宽了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class=&quot;cl-preview-section&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;怎么办？可想而知，光靠带宽硬抗肯定是不现实的。而且国内带宽费用可不便宜。所以这时候需要CDN来帮助缓解流媒体中心服务器的带宽压力了，CDN分发一般会按照流量收费，天下没有免费的午餐。&lt;br/&gt;这时候直播平台的结构变成了这样：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200420234214259.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VndWlkXzE=,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; width=&quot;350&quot; height=&quot;300&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;
&lt;h2&gt;推流端&lt;/h2&gt;
&lt;/p&gt;
&lt;div class=&quot;cl-preview-section&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;推流端一般使用的软件是&lt;strong&gt;OBS&lt;/strong&gt;推流工具。这个工具就不多赘述了，用的实在很广泛。&lt;br/&gt;当然了，对于开发者而言，肯定需要的是&lt;strong&gt;FFmpeg&lt;/strong&gt; 和 &lt;strong&gt;opencv&lt;/strong&gt;了，&lt;strong&gt;FFmpeg&lt;/strong&gt;是做音视频编码推流，opencv当然是用来实现&lt;strong&gt;美颜&lt;/strong&gt;。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;
&lt;h2&gt;流媒体服务&lt;/h2&gt;
&lt;/p&gt;
&lt;div class=&quot;cl-preview-section&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;流媒体服务就是实时视频的中转站。&lt;br/&gt;流媒体服务一般而言：&lt;strong&gt;nginx&lt;/strong&gt;，&lt;strong&gt;srs&lt;/strong&gt;，&lt;strong&gt;red5&lt;/strong&gt;等等，这个系列的后续教程会主要涉及&lt;strong&gt;nginx&lt;/strong&gt;和&lt;strong&gt;srs&lt;/strong&gt;。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;
&lt;h2&gt;拉流播放端&lt;/h2&gt;
&lt;/p&gt;
&lt;div class=&quot;cl-preview-section&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;PC端：VLC&lt;br/&gt;web端：videojs，flv.js，hls.js，ckplayer等等&lt;br/&gt;移动端：ijkplayer&lt;br/&gt;微信小程序：最好用企鹅云的播放，否则会出现兼容性问题，&lt;strong&gt;亲测&lt;/strong&gt;只有企鹅自己的网页播放器才可以同时兼容QQ微信小程序和公众号。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cl-preview-section&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;系列教程后续会主要使用VLC测试拉流播放，虽然VLC延迟很大，但是兼容性是最好的，网页端测试主要使用videojs和flv.js以及企鹅的播放器&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;
&lt;h2&gt;CDN分发&lt;/h2&gt;
&lt;/p&gt;
&lt;div class=&quot;cl-preview-section&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;很多CDN服务商都支持rtmp，flv，hls等流媒体的分发，由于涉及具体厂家，不打广告，这里就不列举了。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;
&lt;h2&gt;下一章&lt;/h2&gt;
&lt;/p&gt;
&lt;div class=&quot;cl-preview-section&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;从零开始开发和搭建直播平台-流媒体服务搭建之1-nginx流媒体服务搭建&lt;br/&gt;从零开始开发和搭建直播平台-流媒体服务搭建之2-srs流媒体服务搭建&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;
&lt;h2&gt;javacv系列&lt;/h2&gt;
&lt;/p&gt;


&lt;p&gt;
&lt;h2&gt;以前写的流媒体服务搭建&lt;/h2&gt;
&lt;/p&gt;

&lt;div class=&quot;cl-preview-section&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;感谢支持eguid原创文章。欢迎转载文章，但还请注明出处，创作不易，万分感谢！&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Mon, 20 Apr 2020 16:39:00 +0000</pubDate>
<dc:creator>eguid</dc:creator>
<og:description>从零开始开发和搭建直播平台-教程汇总篇 写在开始之前 直播平台结构 推流端 流媒体服务 拉流播放端 CDN分发 下一章 javacv系列 以前写的流媒体服务搭建 写在开始之前 之前也分享过不少零散的技</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/eguid/p/12741787.html</dc:identifier>
</item>
<item>
<title>「日常开发」记一次因使用Date引起的线上BUG处理 - Coder小明</title>
<link>http://www.cnblogs.com/coderxx/p/12741716.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/coderxx/p/12741716.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;生活中，我们需要掌控自己的时间，减少加班，提高效率；日常开发中，我们需要操作时间API，保证效率、安全、稳定。现在都2020年了，了解如何在JDK8及以后的版本中更好地操控时间就很有必要，尤其是一次线上BUG的发生，让小明更是深有体会。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;
&lt;p&gt;在&lt;strong&gt;Java8&lt;/strong&gt;以前，每每操控时间，我们经常使用的类库就是&lt;strong&gt;Date&lt;/strong&gt;，并且会通过&lt;strong&gt;SimpleDateFormat&lt;/strong&gt;类对时间进行格式化。你可知道？&lt;strong&gt;Date&lt;/strong&gt;类是一个可变类，&lt;strong&gt;SimpleDateFormat&lt;/strong&gt;类也是线程不安全的，因此在多线程的场景下执行格式化操作时，就会发生意想不到的情况。下面我们看一下使用&lt;strong&gt;Date&lt;/strong&gt;、&lt;strong&gt;SimpleDateFormat&lt;/strong&gt;在多线程下可能发生的问题以及使用&lt;strong&gt;LocalDateTime&lt;/strong&gt;、&lt;strong&gt;DateTimeFormatter&lt;/strong&gt;的方法和优势。&lt;/p&gt;
&lt;h2 id=&quot;问题来了&quot;&gt;问题来了&lt;/h2&gt;
&lt;p&gt;多线程环境下，使用&lt;strong&gt;Date&lt;/strong&gt;、&lt;strong&gt;SimpleDateFormat&lt;/strong&gt;时，如果我们将它定义为一个静态变量使用，虽然会避免重复创建实例， 但是会出现个别线程获取时间失败的现象，我们通过代码模拟这个场景：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1669068/202004/1669068-20200421001826974-841536309.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;运行&lt;strong&gt;main&lt;/strong&gt;方法，查看控制台会发现有个别线程会报&lt;strong&gt;java.lang.NumberFormatException&lt;/strong&gt;异常。类似下图所示:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1669068/202004/1669068-20200421001827449-621115762.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;问题分析&quot;&gt;问题分析&lt;/h2&gt;
&lt;p&gt;接下来，我们通过查看源码进一步分析（多图预警），可以看到&lt;strong&gt;SimpleDateFormat&lt;/strong&gt;是直接继承的&lt;strong&gt;DateFormat&lt;/strong&gt;类：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1669068/202004/1669068-20200421001827766-2111805676.png&quot; alt=&quot;&quot;/&gt;并重写了&lt;strong&gt;parse()&lt;/strong&gt;（字符串转日期）和 &lt;strong&gt;format()&lt;/strong&gt;（日期转字符串）方法，因此我们重点从这两个方法来分析。&lt;/p&gt;
&lt;p&gt;首先是&lt;strong&gt;SimpleDateFormat&lt;/strong&gt;的&lt;strong&gt;parse()&lt;/strong&gt;方法，该方法中创建了一个&lt;strong&gt;CalendarBuilder&lt;/strong&gt;对象，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1669068/202004/1669068-20200421001827963-1131645465.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再往下看，会看到&lt;strong&gt;CalendarBuilder&lt;/strong&gt;使用&lt;strong&gt;establish&lt;/strong&gt;方法将变量&lt;strong&gt;calendar&lt;/strong&gt;设值到其属性中，&lt;/p&gt;
&lt;p&gt;![image-20200420012213545](/Users/xin/Library/Application Support/typora-user-images/image-20200420012213545.png)&lt;/p&gt;
&lt;p&gt;而&lt;strong&gt;calendar&lt;/strong&gt;是父类&lt;strong&gt;DateFormat&lt;/strong&gt;类的共享变量，可以被多个线程访问到&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1669068/202004/1669068-20200421001828201-1197511607.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因此当&lt;strong&gt;SimpleDateFormat&lt;/strong&gt;声明为&lt;strong&gt;static&lt;/strong&gt;时，线程并不安全，多个线程同时操作访问就会抛出异常。&lt;/p&gt;
&lt;p&gt;同样地通过查看&lt;strong&gt;format()&lt;/strong&gt;，我们发现&lt;strong&gt;format&lt;/strong&gt;方法中有一行&lt;code&gt;calendar.setTime(date)&lt;/code&gt;;也是操作的该共享变量&lt;strong&gt;calendar&lt;/strong&gt;，线程也是不安全的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1669068/202004/1669068-20200421001828425-1011297624.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有趣的是，在&lt;strong&gt;DateFormat&lt;/strong&gt;源码注释上作者也已经给出醒目的提示:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1669068/202004/1669068-20200421001828781-1985902101.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用Google翻译过来就是&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;日期格式不同步。 建议为每个线程创建单独的格式实例。 如果多个线程同时访问一种格式，则必须在外部同步该格式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;解决方案&quot;&gt;解决方案&lt;/h2&gt;
&lt;p&gt;小明有一句座右铭，方法总比问题多。我们来看几个小明认为不错的解决方案。&lt;/p&gt;
&lt;h5 id=&quot;1、仅在需要用到的地方创建一个新的实例，就没有线程安全问题。&quot;&gt;1、仅在需要用到的地方创建一个新的实例，就没有线程安全问题。&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;点评&lt;/strong&gt;：加重了创建对象的负担，频繁地创建和销毁对象，消耗资源，效率较低。&lt;/p&gt;
&lt;h5 id=&quot;2、通过synchronized解决线程安全问题；&quot;&gt;2、通过&lt;strong&gt;synchronized&lt;/strong&gt;解决线程安全问题；&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;点评&lt;/strong&gt;：并发量大的时候会对性能有影响，容易造成线程阻塞。&lt;/p&gt;
&lt;h5 id=&quot;3、通过threadlocal保证线程之间变量不共享&quot;&gt;3、通过ThreadLocal保证线程之间变量不共享&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;点评：&lt;/strong&gt;ThreadLocal可以确保每个线程都可以得到单独的一个&lt;strong&gt;SimpleDateFormat&lt;/strong&gt;的对象，那么自然也就不存在竞争问题了。就是有点大材小用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1669068/202004/1669068-20200421001829009-1232715182.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以上就是小明能够提供的所有方案。什么，都不满意？我们来看一下2020年JDK8的解决方案。&lt;/p&gt;
&lt;h2 id=&quot;使用localdatetime&quot;&gt;使用&lt;strong&gt;LocalDateTime&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;在&lt;strong&gt;Java8&lt;/strong&gt;以后，我们有了新的选择，使用&lt;strong&gt;LocalDateTime&lt;/strong&gt;时间类。首先，&lt;strong&gt;LocalDateTime&lt;/strong&gt;本身是线程安全的，其对应的格式化工具类&lt;strong&gt;DateTimeFormatter&lt;/strong&gt;也是线程安全的，不存在变量共享，每一个属性字段都用了final关键字修饰，因此每次操作后都是返回的copy对象。并且&lt;strong&gt;LocalDateTime&lt;/strong&gt;类本身也有很多操作时间的API来替代传统的&lt;strong&gt;Calendar&lt;/strong&gt;类。&lt;/p&gt;
&lt;p&gt;基于&lt;strong&gt;Java8&lt;/strong&gt;的&lt;strong&gt;DateTimeFormatter&lt;/strong&gt;的解决方案，我们对之前的代码进行改造，多线程环境下，运行代码，并未发现任何异常，稳定高效:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1669068/202004/1669068-20200421001829256-2075652766.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以看到&lt;strong&gt;在DateTimeFormatter&lt;/strong&gt;源码上作者也贴心的加注释说明，该类是不可变的，并且是线程安全的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1669068/202004/1669068-20200421001829411-2007552397.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同理，这点我们也可以从&lt;strong&gt;LocalDateTime&lt;/strong&gt;的官方源码中看出。&lt;/p&gt;
&lt;h2 id=&quot;其他骚操作&quot;&gt;其他骚操作&lt;/h2&gt;
&lt;p&gt;为了让大家忘掉之前使用&lt;strong&gt;Calendar&lt;/strong&gt;操作时间的笨拙，我们来切实感受一下&lt;strong&gt;LocalDateTime&lt;/strong&gt;给实际开发中带来的便利:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1669068/202004/1669068-20200421001829676-1800491573.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;4.1481481481481&quot;&gt;
&lt;p&gt;更多举例说明，请点击文末阅读原文&lt;/p&gt;
&lt;p&gt;代码地址：&lt;a href=&quot;https://github.com/WhenCoding/coder-xiaoming&quot;&gt;https://github.com/WhenCoding/coder-xiaoming&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;综上，小明推荐小伙伴们使用JDK8的&lt;strong&gt;LocalDateTime&lt;/strong&gt;系列来取代&lt;strong&gt;Date&lt;/strong&gt;系列，这样做不仅能够保证线上项目平稳运行，而且通过其自带的API还能操作时间，还能提高开发效率，今晚可以不加班！&lt;/p&gt;
&lt;p&gt;欢迎大家访问我的个人博客网站：&lt;a href=&quot;https://mynamecoder.com&quot;&gt;https://mynamecoder.com&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 20 Apr 2020 16:18:00 +0000</pubDate>
<dc:creator>Coder小明</dc:creator>
<og:description>生活中，我们需要掌控自己的时间，减少加班，提高效率；日常开发中，我们需要操作时间API，保证效率、安全、稳定。现在都2020年了，了解如何在JDK8及以后的版本中更好地操控时间就很有必要，尤其是一次线</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/coderxx/p/12741716.html</dc:identifier>
</item>
<item>
<title>负载均衡服务之HAProxy基础入门 - Linux-1874</title>
<link>http://www.cnblogs.com/qiuhom-1874/p/12741018.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qiuhom-1874/p/12741018.html</guid>
<description>&lt;p&gt;　　首先我们来了解下haproxy是干嘛的？haproxy是一个法国人名叫Willy Tarreau开发的一个开源软件；这款软件主要用于解决客户端10000以上的同时连接的高性能的TCP和HTTP负载均衡器。其功能是用来提供基于cookie的持久性，基于内容的交换，过载保护的高级流量管制，自动故障切换，以正则表达式为基础的控制运行时间，基于web的报表，高级日志记录以帮助排除故障的应用或网络及其他功能；简单说它就是基于tcp或http协议的负载均衡器；对于负载均衡器这个概率相信大家了解nginx的都知道吧，其实haproxy类似nginx的upstream功能；它可以基于tcp做四层负载，也可用基于http做七层负载，这一点和nginx一样（nginx是1.9.0后才支持四层代理）；有关nginx的负载均衡功能的使用说明，有兴趣的朋友可以参考下本人的博客&lt;a href=&quot;https://www.cnblogs.com/qiuhom-1874/p/12458159.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/qiuhom-1874/p/12458159.html&lt;/a&gt;和&lt;a href=&quot;https://www.cnblogs.com/qiuhom-1874/p/12468946.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/qiuhom-1874/p/12468946.html&lt;/a&gt;；&lt;/p&gt;
&lt;p&gt;　　有关haproxy的介绍这里就不过多阐述，有兴趣的朋友可以去参考官方网站的介绍&lt;a href=&quot;http://www.haproxy.org&quot; target=&quot;_blank&quot;&gt;http://www.haproxy.org&lt;/a&gt;；&lt;/p&gt;
&lt;p&gt;　　前面聊nginx的时候我们有聊到过nginx的一个重要的功能反向代理，这里再简单回顾下，所谓代理就是“一手托两边”，什么意思呢？就是代理服务器它面向客户端一侧它扮演服务器角色，面向服务器一侧它扮演客户端角色；而反向代理就是代理服务端响应客户端的请求；我们把这种用于代理服务器响应客户端角色叫反向代理；haproxy就是一反向代理实现的软件，在基于反代的模式下，可以对后端服务器做四层或七层的负载均衡；通常情况下haproxy工作在一个流量入口的节点上，用于接收并把客户端的请求分发给不同应用的后端服务器；&lt;/p&gt;
&lt;p&gt;　　简单阐述了haproxy的功能后，我们来看看haproxy的程序组成部分和配置文件；&lt;/p&gt;
&lt;p&gt;　　在redhat系列的Linux上安装haproxy可以yum安装，只不过这种安装方式安装的版本比较旧，如果要使用比较新的版本的haproxy可以选择编辑安装；我们这里先用yum安装先看看haproxy怎么用吧&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@docker_node1 ~]# yum info haproxy
Loaded plugins: fastestmirror
Loading mirror speeds from cached hostfile
 * base: mirrors.aliyun.com
 * extras: mirrors.cn99.com
 * updates: mirrors.aliyun.com
Installed Packages
Name        : haproxy
Arch        : x86_64
Version     : 1.5.18
Release     : 9.el7
Size        : 2.6 M
Repo        : installed
From repo   : base
Summary     : TCP/HTTP proxy and load balancer for high availability environments
URL         : http://www.haproxy.org/
License     : GPLv2+
Description : HAProxy is a TCP/HTTP reverse proxy which is particularly suited for high
            : availability environments. Indeed, it can:
            :  - route HTTP requests depending on statically assigned cookies
            :  - spread load among several servers while assuring server persistence
            :    through the use of HTTP cookies
            :  - switch to backup servers in the event a main server fails
            :  - accept connections to special ports dedicated to service monitoring
            :  - stop accepting connections without breaking existing ones
            :  - add, modify, and delete HTTP headers in both directions
            :  - block requests matching particular patterns
            :  - report detailed status to authenticated users from a URI
            :    intercepted by the application

[root@docker_node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：haproxy在base参考的版本是1.5.18；从上面的信息可以看到haproxy的介绍和功能，有兴趣的朋友自行翻译下；yum安装这里就不多说了，接下来我们来看看haproxy的程序组成；&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@docker_node1 ~]# rpm -ql haproxy
/etc/haproxy
/etc/haproxy/haproxy.cfg
/etc/logrotate.d/haproxy
/etc/sysconfig/haproxy
/usr/bin/halog
/usr/bin/iprange
/usr/lib/systemd/system/haproxy.service
/usr/sbin/haproxy
/usr/sbin/haproxy-systemd-wrapper
/usr/share/doc/haproxy-1.5.18
……省略部分内容……
/usr/share/haproxy
/usr/share/haproxy/400.http
/usr/share/haproxy/403.http
/usr/share/haproxy/408.http
/usr/share/haproxy/500.http
/usr/share/haproxy/502.http
/usr/share/haproxy/503.http
/usr/share/haproxy/504.http
/usr/share/haproxy/README
/usr/share/man/man1/halog.1.gz
/usr/share/man/man1/haproxy.1.gz
/var/lib/haproxy
[root@docker_node1 ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：haproxy的主程序文件是/usr/sbin/haproxy，配置文件是/etc/haproxy/haproxy.cfg，Unit file：/usr/lib/systemd/system/haproxy.service；接下来我们来看看配置文件；&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@docker_node1 ~]# cat /etc/haproxy/haproxy.cfg
#---------------------------------------------------------------------
# Example configuration for a possible web application.  See the
# full configuration options online.
#
#   http://haproxy.1wt.eu/download/1.4/doc/configuration.txt
#
#---------------------------------------------------------------------

#---------------------------------------------------------------------
# Global settings
#---------------------------------------------------------------------
global
    # to have these messages end up in /var/log/haproxy.log you will
    # need to:
    #
    # 1) configure syslog to accept network log events.  This is done
    #    by adding the '-r' option to the SYSLOGD_OPTIONS in
    #    /etc/sysconfig/syslog
    #
    # 2) configure local2 events to go to the /var/log/haproxy.log
    #   file. A line like the following can be added to
    #   /etc/sysconfig/syslog
    #
    #    local2.*                       /var/log/haproxy.log
    #
    log         127.0.0.1 local2

    chroot      /var/lib/haproxy
    pidfile     /var/run/haproxy.pid
    maxconn     4000
    user        haproxy
    group       haproxy
    daemon

    # turn on stats unix socket
    stats socket /var/lib/haproxy/stats

#---------------------------------------------------------------------
# common defaults that all the 'listen' and 'backend' sections will
# use if not designated in their block
#---------------------------------------------------------------------
defaults
    mode                    http
    log                     global
    option                  httplog
    option                  dontlognull
    option http-server-close
    option forwardfor       except 127.0.0.0/8
    option                  redispatch
    retries                 3
    timeout http-request    10s
    timeout queue           1m
    timeout connect         10s
    timeout client          1m
    timeout server          1m
    timeout http-keep-alive 10s
    timeout check           10s
    maxconn                 3000

#---------------------------------------------------------------------
#main frontend which proxys to the backends
#---------------------------------------------------------------------
frontend  main *:5000
    acl url_static       path_beg       -i /static /images /javascript /stylesheets
    acl url_static       path_end       -i .jpg .gif .png .css .js

    use_backend static          if url_static
    default_backend             app

#---------------------------------------------------------------------
# static backend for serving up images, stylesheets and such
#---------------------------------------------------------------------
backend static
    balance     roundrobin
    server      static 127.0.0.1:4331 check

#---------------------------------------------------------------------
# round robin balancing between the various backends
#---------------------------------------------------------------------
backend app
    balance     roundrobin
    server  app1 127.0.0.1:5001 check
    server  app2 127.0.0.1:5002 check
    server  app3 127.0.0.1:5003 check
    server  app4 127.0.0.1:5004 check

[root@docker_node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：以上是haproxy yum安装的配置文件，其中配置文件大致分全局配置段和代理配置段，全局配置段主要配置进程及安全配置相关的参数以及性能调整相关参数；代理配置段主要有defaults配置段，该配置段主要配置frontend,backend,listen配置段默认配置，如果在后面的frontend、backend、listen中配置段有defaults配置段参数，后者生效，没有配置则继承defaults配置段的参数配置；frontend配置段主要配置前端面向客户端提供访问的接口，比如监听在那个地址的那个端口呀，相当于nginx中的server的概念；backend配置段用于定义后端服务器主机的，相当于nginx里的upstream配置段概念；而listen是同时配置前端监听端口信息和后端被代理服务器；&lt;/p&gt;
&lt;p&gt;　　了解了上面配置文件的大概配置，我们接下来配置下，让haproxy代理三台web服务响应客户端请求；&lt;/p&gt;
&lt;p&gt;　　首先说下实验环境，宿主机haproxy的地址是192.168.0.22：80代理172.17.0.2、3、4这三台主机（为了节省虚拟机资源，我们这里分别用docker容器来模拟三台web服务器）&lt;/p&gt;
&lt;p&gt;　　后端服务器环境搭建&lt;/p&gt;
&lt;p&gt;　　1、安装docker-ce&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@docker_node1 ~]# yum install -y docker-ce
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：安装之前需要去配置好docker的yum源参考，推荐去阿里云yum仓库&lt;/p&gt;
&lt;p&gt;　　2、拉取镜像&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@docker_node1 ~]# docker pull httpd:2.4.37-alpine
Error response from daemon: Get https://registry-1.docker.io/v2/library/httpd/manifests/2.4.37-alpine: net/http: TLS handshake timeout
[root@docker_node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：这是没有配置docker加速，所以导致超时；&lt;/p&gt;
&lt;p&gt;　　3、配置docker加速器&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202004/1503305-20200420214155615-782587861.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　提示：登录自己的账号去阿里云控制台里找容器镜像服务--&amp;gt;镜像加速，右边有个操作文档，根据自己的系统选择相应的配置，然后复制下来到你自己的Linux上执行即可；配置好加速器后，在拉取镜像就比较快了；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202004/1503305-20200420214633195-647177093.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　4、运行三个不同名称的容器&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202004/1503305-20200420214850754-372950256.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　提示：可以看到三个不同名称的实例运行起来了，为了区分各容器我们故意把主页的内容更改为不同的名称以示区分；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202004/1503305-20200420215138335-767511188.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　提示：把三个容器的主页更改后，需要在docker宿主机上测试是否能够访问&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202004/1503305-20200420215339420-464216532.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　提示：容器运行的服务已经能够正常访问，到此后端server就准备就绪，接下来就是配置haproxy来反代这三个容器就可以了；&lt;/p&gt;
&lt;p&gt;　　配置haproxy反代后端服务器&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202004/1503305-20200420220113416-570926319.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　提示：以上红框中的名字必须相同，什么意思呢？就是前端调用哪个后端服务器组，后端服务器组必须得存在，否则haproxy起不来；这里说一下以上配置，以上配置表示前端myweb这个服务监听在该主机的所有地址的80端口，并把客户端的请求反代至webservers这个后端服务器组上进行响应；后端服务器webservers，定义了三个server分别是172.17.0.2、3、4;如果前端监听端口和后端服务器监听端口相同的情况下，后端服务器上可以不用谢端口的；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202004/1503305-20200420220310369-1356583443.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　提示：启动haproxy后，为了验证配置文件是否有问题，需要查看下对应监听的端口是否起来了，如果配置文件有问题，启动haproxy是不会有任何提示的，我们只有查看端口来判断haproxy是否配置正确和成功启动；从上面的的信息看，我们配置的haproxy没有问题，对应80端口都启动起来了；&lt;/p&gt;
&lt;p&gt;　　测试：用浏览器对192.168.0.22：80进行访问，看看是否能够响应后端服务器的主页？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202004/1503305-20200420221510981-1887714351.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　提示：可以看到haproxy能够正常的把客户端的请求以轮询的方式向后端服务器反代；&lt;/p&gt;
&lt;p&gt;　　以上就是haproxy最简单的使用方式，作为反代服务器代理服务端响应客户端的请求；接下来我们来说说编译安装haproxy&lt;/p&gt;
&lt;p&gt;　　1、首先我们要把自己的编译环境搭建好&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@haproxy_node1 ~]# yum groupinstall &quot;development tools&quot; -y
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：通常编译环境所需要的包，在development tools这个包组中都有，所以通常我们源码编译安装都是把这个包组装上，然后编译，如果中途有报错提示我们没有哪个包，我们在安装相应的包就可以了&lt;/p&gt;
&lt;p&gt;　　2、下载haproxy源码包&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202004/1503305-20200420223512383-1613650015.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　提示：我这个是从官网上下载后，然后上传上来的，官网是国外的一个网站，想要访问它，我们需要翻墙出去才可以；&lt;/p&gt;
&lt;p&gt;　　3、解压源码包，并进入到源码目录查看编译手册&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@haproxy_node1 src]# tar xf haproxy-1.8.20.tar.gz 
  oot@haproxy_node1 src]# cd haproxy-1.8.20
[root@haproxy_node1 haproxy-1.8.20]# ls
CHANGELOG  CONTRIBUTING  ebtree    include  MAINTAINERS  README     ROADMAP  src      tests    VERSION
contrib    doc           examples  LICENSE  Makefile     reg-tests  scripts  SUBVERS  VERDATE
[root@haproxy_node1 haproxy-1.8.20]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：README就是编译手册，里面告诉我们怎么去编译安装haproxy，需要指定的那些参数等等说明；我们需要关心的是我们系统上什么架构，内核版本信息；编译的时候我们需要用ARCH来指定系统架构，用TARGET来指定内核版本，Linux2.6以上的内核版本需要指定TARGET=linux2628；其他版本信息可以对照README里的说明信息对照来指定对应的参数；除此以外我们还需要指定是否支持openssl、zip压缩、以及是否使用systemd的方式来管理服务等等信息，根据自己的需要定制编译参数；&lt;/p&gt;
&lt;p&gt;　　4、指定编译参数，编译haproxy&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@haproxy_node1 haproxy-1.8.20]#  make ARCH=x86_64 TARGET=linux2628 USE_PCRE=1 USE_OPENSSL=1 USE_ZLIB=1 USE_SYSTEMD=1 USE_CPU_AFFINITY=1
gcc -Iinclude -Iebtree -Wall -m64 -march=x86-64 -O2 -g -fno-strict-aliasing -Wdeclaration-after-statement -fwrapv    -Wno-unused-label       -DCONFIG_HAP_LINUX_SPLICE -DTPROXY -DCONFIG_HAP_LINUX_TPROXY -DCONFIG_HAP_CRYPT -DUSE_ZLIB  -DENABLE_POLL -DENABLE_EPOLL -DUSE_CPU_AFFINITY -DASSUME_SPLICE_WORKS -DUSE_ACCEPT4 -DNETFILTER -DUSE_THREAD -DUSE_OPENSSL  -DUSE_SYSCALL_FUTEX -DUSE_SYSTEMD -DUSE_PCRE -I/usr/local/include  -DCONFIG_HAPROXY_VERSION=\&quot;1.8.20\&quot; -DCONFIG_HAPROXY_DATE=\&quot;2019/04/25\&quot; -c -o src/ev_poll.o src/ev_poll.c
In file included from include/types/global.h:32:0,
                 from src/ev_poll.c:26:
include/types/listener.h:29:25: fatal error: openssl/ssl.h: No such file or directory
 #include &amp;lt;openssl/ssl.h&amp;gt;
                         ^
compilation terminated.
make: *** [src/ev_poll.o] Error 1
[root@haproxy_node1 haproxy-1.8.20]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：以上报错说没有openssl这个头文件，我们需要安装openssl-devel这个包即可&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@haproxy_node1 haproxy-1.8.20]# yum install -y openssl-devel
Loaded plugins: fastestmirror
Loading mirror speeds from cached hostfile
 * base: mirrors.aliyun.com
 * extras: mirrors.huaweicloud.com
 * updates: mirrors.aliyun.com
Resolving Dependencies
--&amp;gt; Running transaction check
---&amp;gt; Package openssl-devel.x86_64 1:1.0.2k-19.el7 will be installed
--&amp;gt; Processing Dependency: openssl-libs(x86-64) = 1:1.0.2k-19.el7 for package: 1:openssl-devel-1.0.2k-19.el7.x86_64
--&amp;gt; Processing Dependency: zlib-devel(x86-64) for package: 1:openssl-devel-1.0.2k-19.el7.x86_64
--&amp;gt; Processing Dependency: krb5-devel(x86-64) for package: 1:openssl-devel-1.0.2k-19.el7.x86_64
……省略部分信息……
Installed:
  openssl-devel.x86_64 1:1.0.2k-19.el7                                                                              

Dependency Installed:
  keyutils-libs-devel.x86_64 0:1.5.8-3.el7                   krb5-devel.x86_64 0:1.15.1-37.el7_7.2                  
  libcom_err-devel.x86_64 0:1.42.9-16.el7                    libkadm5.x86_64 0:1.15.1-37.el7_7.2                    
  libselinux-devel.x86_64 0:2.5-14.1.el7                     libsepol-devel.x86_64 0:2.5-10.el7                     
  libverto-devel.x86_64 0:0.2.5-4.el7                        pcre-devel.x86_64 0:8.32-17.el7                        
  zlib-devel.x86_64 0:1.2.7-18.el7                          

Dependency Updated:
  e2fsprogs.x86_64 0:1.42.9-16.el7                         e2fsprogs-libs.x86_64 0:1.42.9-16.el7                    
  krb5-libs.x86_64 0:1.15.1-37.el7_7.2                     libcom_err.x86_64 0:1.42.9-16.el7                        
  libselinux.x86_64 0:2.5-14.1.el7                         libselinux-python.x86_64 0:2.5-14.1.el7                  
  libselinux-utils.x86_64 0:2.5-14.1.el7                   libsepol.x86_64 0:2.5-10.el7                             
  libss.x86_64 0:1.42.9-16.el7                             openssl.x86_64 1:1.0.2k-19.el7                           
  openssl-libs.x86_64 1:1.0.2k-19.el7                      zlib.x86_64 0:1.2.7-18.el7                               

Complete!
[root@haproxy_node1 haproxy-1.8.20]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：通常编译的时候报错，我们要注意看它提示我们什么，通常都是缺少某些包引起的，对应我们安装devel版包都能够解决；安装了openssl-devel这个包后，再次编译，上面的报错就不会有了；&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
APROXY_DATE=\&quot;2019/04/25\&quot; \
      -DBUILD_TARGET='&quot;linux2628&quot;' \
      -DBUILD_ARCH='&quot;x86_64&quot;' \
      -DBUILD_CPU='&quot;generic&quot;' \
      -DBUILD_CC='&quot;gcc&quot;' \
      -DBUILD_CFLAGS='&quot;-m64 -march=x86-64 -O2 -g -fno-strict-aliasing -Wdeclaration-after-statement -fwrapv -Wno-unused-label&quot;' \
      -DBUILD_OPTIONS='&quot;USE_ZLIB=1 USE_CPU_AFFINITY=1 USE_OPENSSL=1 USE_SYSTEMD=1 USE_PCRE=1&quot;' \
       -c -o src/haproxy.o src/haproxy.c
src/haproxy.c:66:31: fatal error: systemd/sd-daemon.h: No such file or directory
 #include &amp;lt;systemd/sd-daemon.h&amp;gt;
                               ^
compilation terminated.
make: *** [src/haproxy.o] Error 1
[root@haproxy_node1 haproxy-1.8.20]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：以上报错提示我们缺少systemd/sd-daemon.h，我们安装systemd-devel即可解决&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@haproxy_node1 ~]# yum install -y systemd-devel
Loaded plugins: fastestmirror
Loading mirror speeds from cached hostfile
 * base: mirrors.aliyun.com
 * extras: mirrors.huaweicloud.com
 * updates: mirrors.aliyun.com
Resolving Dependencies
--&amp;gt; Running transaction check
---&amp;gt; Package systemd-devel.x86_64 0:219-67.el7_7.4 will be installed
--&amp;gt; Processing Dependency: systemd-libs = 219-67.el7_7.4 for package: systemd-devel-219-67.el7_7.4.x86_64
--&amp;gt; Processing Dependency: systemd = 219-67.el7_7.4 for package: systemd-devel-219-67.el7_7.4.x86_64
--&amp;gt; Running transaction check
---&amp;gt; Package systemd.x86_64 0:219-42.el7 will be updated
--&amp;gt; Processing Dependency: systemd = 219-42.el7 for package: systemd-sysv-219-42.el7.x86_64
---&amp;gt; Package systemd.x86_64 0:219-67.el7_7.4 will be an update
--&amp;gt; Processing Dependency: libcryptsetup.so.12(CRYPTSETUP_2.0)(64bit) for package: systemd-219-67.el7_7.4.x86_64
--&amp;gt; Processing Dependency: liblz4.so.1()(64bit) for package: systemd-219-67.el7_7.4.x86_64
--&amp;gt; Processing Dependency: libcryptsetup.so.12()(64bit) for package: systemd-219-67.el7_7.4.x86_64
---&amp;gt; Package systemd-libs.x86_64 0:219-42.el7 will be updated
---&amp;gt; Package systemd-libs.x86_64 0:219-67.el7_7.4 will be an update
--&amp;gt; Running transaction check
---&amp;gt; Package cryptsetup-libs.x86_64 0:1.7.4-3.el7 will be updated
---&amp;gt; Package cryptsetup-libs.x86_64 0:2.0.3-5.el7 will be an update
---&amp;gt; Package lz4.x86_64 0:1.7.5-3.el7 will be installed
---&amp;gt; Package systemd-sysv.x86_64 0:219-42.el7 will be updated
---&amp;gt; Package systemd-sysv.x86_64 0:219-67.el7_7.4 will be an update
--&amp;gt; Finished Dependency Resolution

Dependencies Resolved

====================================================================================================================
 Package                        Arch                  Version                          Repository              Size
====================================================================================================================
Installing:
 systemd-devel                  x86_64                219-67.el7_7.4                   updates                208 k
Installing for dependencies:
 lz4                            x86_64                1.7.5-3.el7                      base                    99 k
Updating for dependencies:
 cryptsetup-libs                x86_64                2.0.3-5.el7                      base                   338 k
 systemd                        x86_64                219-67.el7_7.4                   updates                5.1 M
 systemd-libs                   x86_64                219-67.el7_7.4                   updates                411 k
 systemd-sysv                   x86_64                219-67.el7_7.4                   updates                 89 k

Transaction Summary
====================================================================================================================
Install  1 Package  (+1 Dependent package)
Upgrade             ( 4 Dependent packages)

Total download size: 6.2 M
Downloading packages:
Delta RPMs disabled because /usr/bin/applydeltarpm not installed.
(1/6): systemd-libs-219-67.el7_7.4.x86_64.rpm                                                | 411 kB  00:00:00     
(2/6): systemd-devel-219-67.el7_7.4.x86_64.rpm                                               | 208 kB  00:00:00     
(3/6): cryptsetup-libs-2.0.3-5.el7.x86_64.rpm                                                | 338 kB  00:00:00     
(4/6): lz4-1.7.5-3.el7.x86_64.rpm                                                            |  99 kB  00:00:00     
(5/6): systemd-sysv-219-67.el7_7.4.x86_64.rpm                                                |  89 kB  00:00:00     
(6/6): systemd-219-67.el7_7.4.x86_64.rpm                                                     | 5.1 MB  00:00:01     
--------------------------------------------------------------------------------------------------------------------
Total                                                                               5.4 MB/s | 6.2 MB  00:00:01     
Running transaction check
Running transaction test
Transaction test succeeded
Running transaction
  Installing : lz4-1.7.5-3.el7.x86_64                                                                          1/10 
  Updating   : systemd-libs-219-67.el7_7.4.x86_64                                                              2/10 
  Updating   : cryptsetup-libs-2.0.3-5.el7.x86_64                                                              3/10 
  Updating   : systemd-219-67.el7_7.4.x86_64                                                                   4/10 
  Installing : systemd-devel-219-67.el7_7.4.x86_64                                                             5/10 
  Updating   : systemd-sysv-219-67.el7_7.4.x86_64                                                              6/10 
  Cleanup    : systemd-sysv-219-42.el7.x86_64                                                                  7/10 
  Cleanup    : systemd-219-42.el7.x86_64                                                                       8/10 
  Cleanup    : cryptsetup-libs-1.7.4-3.el7.x86_64                                                              9/10 
  Cleanup    : systemd-libs-219-42.el7.x86_64                                                                 10/10 
  Verifying  : systemd-libs-219-67.el7_7.4.x86_64                                                              1/10 
  Verifying  : systemd-devel-219-67.el7_7.4.x86_64                                                             2/10 
  Verifying  : cryptsetup-libs-2.0.3-5.el7.x86_64                                                              3/10 
  Verifying  : systemd-219-67.el7_7.4.x86_64                                                                   4/10 
  Verifying  : lz4-1.7.5-3.el7.x86_64                                                                          5/10 
  Verifying  : systemd-sysv-219-67.el7_7.4.x86_64                                                              6/10 
  Verifying  : systemd-libs-219-42.el7.x86_64                                                                  7/10 
  Verifying  : systemd-sysv-219-42.el7.x86_64                                                                  8/10 
  Verifying  : systemd-219-42.el7.x86_64                                                                       9/10 
  Verifying  : cryptsetup-libs-1.7.4-3.el7.x86_64                                                             10/10 

Installed:
  systemd-devel.x86_64 0:219-67.el7_7.4                                                                             

Dependency Installed:
  lz4.x86_64 0:1.7.5-3.el7                                                                                          

Dependency Updated:
  cryptsetup-libs.x86_64 0:2.0.3-5.el7    systemd.x86_64 0:219-67.el7_7.4    systemd-libs.x86_64 0:219-67.el7_7.4   
  systemd-sysv.x86_64 0:219-67.el7_7.4   

Complete!
[root@haproxy_node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　再次编译&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
-Wno-unused-label       -DCONFIG_HAP_LINUX_SPLICE -DTPROXY -DCONFIG_HAP_LINUX_TPROXY -DCONFIG_HAP_CRYPT -DUSE_ZLIB  -DENABLE_POLL -DENABLE_EPOLL -DUSE_CPU_AFFINITY -DASSUME_SPLICE_WORKS -DUSE_ACCEPT4 -DNETFILTER -DUSE_THREAD -DUSE_OPENSSL  -DUSE_SYSCALL_FUTEX -DUSE_SYSTEMD -DUSE_PCRE -I/usr/include  -DCONFIG_HAPROXY_VERSION=\&quot;1.8.20\&quot; -DCONFIG_HAPROXY_DATE=\&quot;2019/04/25\&quot; -c -o src/hash.o src/hash.c
gcc -m64 -march=x86-64 -g -o haproxy src/ev_poll.o src/ev_epoll.o src/ssl_sock.o ebtree/ebtree.o ebtree/eb32sctree.o ebtree/eb32tree.o ebtree/eb64tree.o ebtree/ebmbtree.o ebtree/ebsttree.o ebtree/ebimtree.o ebtree/ebistree.o src/proto_http.o src/cfgparse.o src/server.o src/stream.o src/flt_spoe.o src/stick_table.o src/stats.o src/mux_h2.o src/checks.o src/haproxy.o src/log.o src/dns.o src/peers.o src/standard.o src/sample.o src/cli.o src/stream_interface.o src/proto_tcp.o src/backend.o src/proxy.o src/tcp_rules.o src/listener.o src/flt_http_comp.o src/pattern.o src/cache.o src/filters.o src/vars.o src/acl.o src/payload.o src/connection.o src/raw_sock.o src/proto_uxst.o src/flt_trace.o src/session.o src/ev_select.o src/channel.o src/task.o src/queue.o src/applet.o src/map.o src/frontend.o src/freq_ctr.o src/lb_fwlc.o src/mux_pt.o src/auth.o src/fd.o src/hpack-dec.o src/memory.o src/lb_fwrr.o src/lb_chash.o src/lb_fas.o src/hathreads.o src/chunk.o src/lb_map.o src/xxhash.o src/regex.o src/shctx.o src/buffer.o src/action.o src/h1.o src/compression.o src/pipe.o src/namespace.o src/sha1.o src/hpack-tbl.o src/hpack-enc.o src/uri_auth.o src/time.o src/proto_udp.o src/arg.o src/signal.o src/protocol.o src/lru.o src/hdr_idx.o src/hpack-huff.o src/mailers.o src/h2.o src/base64.o src/hash.o   -lcrypt  -lz -ldl -lpthread  -lssl -lcrypto -ldl -lsystemd -L/usr/lib -lpcreposix -lpcre 
[root@haproxy_node1 haproxy-1.8.20]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：再次编译就没有提示任何错误了，说明我们的编译通过了，接下来我们就可以make install 了&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@haproxy_node1 haproxy-1.8.20]# make install PREFIX=/usr/local/haproxy
install -d &quot;/usr/local/haproxy/sbin&quot;
install haproxy  &quot;/usr/local/haproxy/sbin&quot;
install -d &quot;/usr/local/haproxy/share/man&quot;/man1
install -m 644 doc/haproxy.1 &quot;/usr/local/haproxy/share/man&quot;/man1
install -d &quot;/usr/local/haproxy/doc/haproxy&quot;
for x in configuration management architecture peers-v2.0 cookie-options lua WURFL-device-detection proxy-protocol linux-syn-cookies network-namespaces DeviceAtlas-device-detection 51Degrees-device-detection netscaler-client-ip-insertion-protocol peers close-options SPOE intro; do \
        install -m 644 doc/$x.txt &quot;/usr/local/haproxy/doc/haproxy&quot; ; \
done
[root@haproxy_node1 haproxy-1.8.20]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：安装的时候我们需要用PREFIX来指定安装的目录，其实安装的过程不外乎就是把编译好的二进制文件拷本到我们指定的目录；到此编译安装就完成了，接下来据说创建UNIT 文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202004/1503305-20200420231125993-852518514.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　提示：该unit file 可以参考haproxy的用法来写，主要是看haproxy的选项，-f表示指定配置文件，-c表示检查模式，-q表示静默模式，之所以我们即便配置文件有错我们启动的时候都不报错的原因就是启用了静默模式，我们可以不用指定该参数；-Ws表示master-worker支持单主多子进程；-p表示指定pid文件；根据上面的脚本信息，我们还需要在对应目录下创建一个配置文件，并根据haproxy的配置文件指定的用户来创建用户；&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@haproxy_node1 haproxy]# cat haproxy.cfg
global
        maxconn 100000
        chroot /usr/local/haproxy
        user    haproxy
        group   haproxy
        daemon
#       nbproc 4
#       cpu-map 1 0
#       cpu-map 2 1
#       cpu-map 3 2
#       cpu-map 4 3
        pidfile /run/haproxy.pid
        log 127.0.0.1 local3 info

defaults
        option http-keep-alive
        option  forwardfor
        maxconn 100000
        mode http
        timeout http-request    10s
        timeout queue           1m
        timeout connect         10s
        timeout client          1m
        timeout server          1m
        timeout http-keep-alive 10s


listen  web_port
        bind 0.0.0.0:80
        mode http
        log global
        server web1  192.168.0.22:80  check inter 3000 fall 2 rise 5
[root@haproxy_node1 haproxy]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：以上配置信息，在后续的博客中会着重去说，这里先不解释，先把服务跑起来再说；从上面的配置看，我们还需要在系统上创建一个haproxy的用户；当然如果你不想创建用户你可以选择一个你系统上现有用户即可；建议用haproxy用户去启动haproxy;并且把haproxy用户的shell类型设置成/sbin/nologin&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@haproxy_node1 haproxy]# useradd -s /sbin/nologin haproxy
[root@haproxy_node1 haproxy]# id haproxy
uid=1000(haproxy) gid=1000(haproxy) groups=1000(haproxy)
[root@haproxy_node1 haproxy]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　接下来我们尝试用systemctl start haproxy来启动服务看看对应的80服务是否能够起来&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202004/1503305-20200420235243571-263600384.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　提示：在启动前，我们还需要把/usr/local/haproxy/sbin/haproxy 给软连接至/usr/sbin/下，因为我们在unit file里写的是这个路径；除此之外还要执行systemctl daemon-reload 让systemctl 把haproxy加载到systemd管理；&lt;/p&gt;
&lt;p&gt;　　测试：我们用浏览器访问192.168.0.21：80，看看是否访问得到我们之前的三台httpd服务？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202004/1503305-20200420235957911-1198110174.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　提示：以上能够访问到的原因是，我在上面的配置文件中用listen 指令指定了监听*:80对应的后端主机上192.168.0.22：80;在最开始的时候我们就用192.168.0.22：80反代后面三台容器；这里相当于是两层反代结构，用户请求发送到192.168.0.21：80,然后192.168.0.21把用户请求反代之192.168.0.22：80，然后192.168.0.22把请求反代之后端的172.17.0.2、3、4这三台容器上，所以我们在浏览器看到的就是后端容器响应的结果；到此haproxy编译安装就完成了；后续我会持续更新haproxy的其他配置相关博客，有兴趣的朋友可以点点关注，共同学习；&lt;/p&gt;
</description>
<pubDate>Mon, 20 Apr 2020 16:11:00 +0000</pubDate>
<dc:creator>Linux-1874</dc:creator>
<og:description>首先我们来了解下haproxy是干嘛的？haproxy是一个法国人名叫Willy Tarreau开发的一个开源软件；这款软件主要用于解决客户端10000以上的同时连接的高性能的TCP和HTTP负载均衡</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qiuhom-1874/p/12741018.html</dc:identifier>
</item>
<item>
<title>RxHttp ，比Retrofit 更优雅的协程体验  - 刘敬兴</title>
<link>http://www.cnblogs.com/liujingxing/p/12741525.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liujingxing/p/12741525.html</guid>
<description>&lt;p&gt;Hello，各位小伙伴，又见面了，回首过去，&lt;a href=&quot;https://github.com/liujingxing/okhttp-RxHttp&quot;&gt;RxHttp&lt;/a&gt; 就要迎来一周年生日了(19年4月推出)，这一年，走过来真心....真心不容易，代码维护、写文章、写文档等等，经常都是干到零点之后，也是我首次花费大部分业余时间来维护一个开源项目，全程一个人维护，要知道，网络请求库不同于其它开源项目，各位同僚对这类项目的要求都非常高，而且前面有一座大山Retrofit，如何在这种情况下，杀出重围？那就只有死磕细节，做到&lt;code&gt;人无我有，人有我精&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;幸运的是，RxHttp它做到了，截止本文发表，在Github上，已达到&lt;a href=&quot;https://github.com/liujingxing/okhttp-RxHttp&quot;&gt;1600+star&lt;/a&gt;，在RxHttp$RxLife交流群（群号：378530627，经常会有技术交流，欢迎进群）也有了300+人，这次，&lt;a href=&quot;https://github.com/liujingxing/okhttp-RxHttp&quot;&gt;RxHttp&lt;/a&gt; 更新到了2.x版本，给大家带来不一样的协程体验，为啥不一样？看完本文你会有答案&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;gradle依赖&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;dependencies {
   //必须
   implementation 'com.ljx.rxhttp:rxhttp:2.2.0'
   annotationProcessor 'com.ljx.rxhttp:rxhttp-compiler:2.2.0' //生成RxHttp类

   //以下均为非必须
   implementation 'com.ljx.rxlife:rxlife-coroutine:2.0.0'  //管理协程生命周期，页面销毁，关闭请求
   implementation 'com.ljx.rxlife2:rxlife-rxjava:2.0.0'    //管理RxJava2生命周期，页面销毁，关闭请求
   implementation 'com.ljx.rxlife3:rxlife-rxjava:3.0.0'    //管理RxJava3生命周期，页面销毁，关闭请求

   //Converter 根据自己需求选择 RxHttp默认内置了GsonConverter
   implementation 'com.ljx.rxhttp:converter-jackson:2.2.0'
   implementation 'com.ljx.rxhttp:converter-fastjson:2.2.0'
   implementation 'com.ljx.rxhttp:converter-protobuf:2.2.0'
   implementation 'com.ljx.rxhttp:converter-simplexml:2.2.0'
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;注：纯Java项目，请使用annotationProcessor替代kapt；依赖完，记得rebuild，才会生成RxHttp类&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;RxHttp2.2.0版本起，已完全剔除了RxJava，采用外挂的方法替代，支持RxJava2、RxJava3，详情查看&lt;a href=&quot;https://github.com/liujingxing/okhttp-RxHttp&quot;&gt;RxHttp上手&lt;/a&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/liujingxing/okhttp-RxHttp/wiki/FAQ&quot;&gt;遇到问题，点这里，点这里，点这里，99%的问题都能自己解决&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文只介绍RxHttp与协程相关的部分，如果你之前没有了解过RxHttp，建议先阅读&lt;a href=&quot;https://juejin.im/post/5ded221a518825125d14a1d4&quot;&gt;RxHttp 让你眼前一亮的Http请求框架&lt;/a&gt;一文&lt;/p&gt;
&lt;p&gt;如果你现在对协程还一知半解，没有关系，那是因为你还没有找到运用场景，而网络请求正是一个很好的切入场景，本文会教你如何优雅，并且安全的开启协程，以及用协程处理多任务，用着用着你就会了。&lt;/p&gt;

&lt;p&gt;用过RxHttp的同学知道，RxHttp发送任意请求都遵循请求三部曲，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/4/19/17192f499ff7c4f6?w=860&amp;amp;h=688&amp;amp;f=jpeg&amp;amp;s=76163&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码表示&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-kotlin&quot;&gt;RxHttp.get(&quot;/service/...&quot;) //第一步，确定请求方式，可以选择postForm、postJson等方法
    .asString()            //第二步，使用asXXX系列方法确定返回类型
    .subscribe(s -&amp;gt; {      //第三步, 订阅观察者
        //成功回调
    }, throwable -&amp;gt; {
        //失败回调
    });
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这使得初学者非常容易上手，掌握了请求三部曲，就掌握了RxHttp的精髓，而协程，亦遵循请求三部曲，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/4/19/17191eeb8a281d9b?w=700&amp;amp;h=704&amp;amp;f=png&amp;amp;s=87287&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;代码表示&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-kotlin&quot;&gt;val str = RxHttp.get(&quot;/service/...&quot;) //第一步，确定请求方式，可以选择postForm、postJson等方法
    .toStr()    //第二步，确认返回类型，这里代表返回String类型
    .await()    //第二步，使用await方法拿到返回值
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;注: &lt;code&gt;await()&lt;/code&gt;是suspend挂断方法，需要在另一个suspend方法或协程环境中调用&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;接着，如果我们要获取一个&lt;code&gt;Student&lt;/code&gt;对象或者&lt;code&gt;List&amp;lt;Student&amp;gt;&lt;/code&gt;集合对象等等任意数据类型，也是通过&lt;code&gt;await()&lt;/code&gt;方法，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-kotlin&quot;&gt;//Student对象
val student = RxHttp.get(&quot;/service/...&quot;)
    .toClass&amp;lt;Student&amp;gt;()
    .await()
    
//List&amp;lt;Student&amp;gt; 对象   
val students = RxHttp.get(&quot;/service/...&quot;)
    .toClass&amp;lt;List&amp;lt;Student&amp;gt;&amp;gt;()
    .await()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;toClass()&lt;/code&gt;方法是万能的，它可以拿到任意数据类型，我们来看下&lt;code&gt;toClass()&lt;/code&gt;方法的完整签名&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-kotlin&quot;&gt;inline fun &amp;lt;reified T : Any&amp;gt; IRxHttp.toClass() : IAwait&amp;lt;T&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，它没有任何参数，只是声明了一个泛型&lt;code&gt;T&lt;/code&gt;，并将它作为了返回类型，所以通过该方法，就可以拿到任意数据类型。&lt;/p&gt;
&lt;p&gt;以上就是RxHttp在协程中最常规的操作，接下来，上真正的干货&lt;/p&gt;
&lt;h2 id=&quot;21、业务code统一判断&quot;&gt;2.1、业务code统一判断&lt;/h2&gt;
&lt;p&gt;我想大部分人的接口返回格式都是这样的&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-kotlin&quot;&gt;class Response&amp;lt;T&amp;gt; {
    var code = 0
    var msg : String? = null
    var data : T 
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;拿到该对象的第一步就是对code做判断，如果&lt;code&gt;code != 200&lt;/code&gt;(假设200代码数据正确)，就会拿到msg字段给用户一些错误提示，如果等于200，就拿到data字段去更新UI，常规的操作是这样的&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-kotlin&quot;&gt;val response = RxHttp.get(&quot;/service/...&quot;)
    .toClass&amp;lt;Response&amp;lt;Student&amp;gt;&amp;gt;()
    .await()
if (response.code == 200) {
    //拿到data字段(Student)刷新UI
} else {
    //拿到msg字段给出错误提示
} 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;试想一下，一个项目少说也有30+个这样的接口，如果每个接口读取这么判断，就显得不够优雅，也可以说是灾难，相信也没有人会这么干。而且对于UI来说，只需要data字段即可，错误提示啥的我管不着。&lt;/p&gt;
&lt;p&gt;那有没有什么办法，能直接拿到data字段，并且对code做出统一判断呢？有的，直接上代码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-kotlin&quot;&gt;val student = RxHttp.get(&quot;/service/...&quot;)
    .toResponse&amp;lt;Student&amp;gt;() //调用此方法，直接拿到data字段，也就是Student对象   
    .await()  
//直接开始更新UI
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，这里调用了&lt;code&gt;toResponse()&lt;/code&gt;方法，就直接拿到了data字段，也就是Student对象。&lt;/p&gt;
&lt;p&gt;此时，相信很多人会有疑问，&lt;/p&gt;
&lt;p&gt;为此，先来回答第一个问题，业务code哪里判断的？&lt;/p&gt;
&lt;p&gt;其实&lt;code&gt;toResponse()&lt;/code&gt;方法并不是RxHttp内部提供的，而是用户通过自定义解析器，并用&lt;code&gt;@Parser&lt;/code&gt;注解标注，最后由注解处理器&lt;code&gt;rxhttp-compiler&lt;/code&gt;自动生成的，听不懂？没关系，直接看代码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-kotlin&quot;&gt;@Parser(name = &quot;Response&quot;)
open class ResponseParser&amp;lt;T&amp;gt; : AbstractParser&amp;lt;T&amp;gt; {
    
    //以下两个构造方法是必须的
    protected constructor() : super()
    constructor(type: Class&amp;lt;T&amp;gt;) : super(type)

    @Throws(IOException::class)
    override fun onParse(response: okhttp3.Response): T {
        val type: Type = ParameterizedTypeImpl[Response::class.java, mType] //获取泛型类型
        val data: Response&amp;lt;T&amp;gt; = convert(response, type)   //获取Response对象
        val t = data.data                             //获取data字段
        if (data.code != 200 || t == null) { //code不等于200，说明数据不正确，抛出异常
            throw ParseException(data.code.toString(), data.msg, response)
        }
        return t
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面代码只需要关注两点即可，&lt;/p&gt;
&lt;p&gt;第一点，我们在类开头使用了&lt;code&gt;@Parser&lt;/code&gt;注解，并为解析器取名为&lt;code&gt;Response&lt;/code&gt;，所以就有了&lt;code&gt;toResponse()&lt;/code&gt;方法（命名方式为：to + Parser注解里设置的名字）；&lt;/p&gt;
&lt;p&gt;第二点，我们在&lt;code&gt;if&lt;/code&gt;语句里，对code做了判断，非200或者data为空时，就抛出异常，并带上了code及msg字段，所以我们在异常回调的地方就能拿到这两个字段&lt;/p&gt;
&lt;p&gt;接着回答第二个问题，code非200时，如何拿到msg字段？直接上代码，看一个使用协程发送请求的完整案例&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-kotlin&quot;&gt;//当前环境在Fragment中
fun getStudent() {   
    //rxLifeScope在rxLife-coroutine库中，需要单独依赖                                 
    rxLifeScope.launch({    //通过launch方法开启一个协程                           
        val student = RxHttp.get(&quot;/service/...&quot;) 
            .toResponse&amp;lt;Student&amp;gt;()
            .await()                 
    }, {                                               
        //异常回调，这里的it为Throwable类型                                        
        val code = it.code                            
        val msg = it.msg                              
    })                                                
}                                                     
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注：RxLifeScope 是 &lt;a href=&quot;https://github.com/liujingxing/RxLife-Coroutine&quot;&gt;RxLife-Coroutine&lt;/a&gt;库中的类，本文后续会详细介绍&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上面的代码，在异常回调中便可拿到code及msg字段，需要注意的是，&lt;code&gt;it.code&lt;/code&gt;及&lt;code&gt;it.msg&lt;/code&gt;是我为Throwable类扩展的两个属性，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-kotlin&quot;&gt;val Throwable.code: Int
    get() {
        val errorCode = when (this) {
            is HttpStatusCodeException -&amp;gt; this.statusCode //Http状态码异常
            is ParseException -&amp;gt; this.errorCode     //业务code异常
            else -&amp;gt; &quot;-1&quot;
        }
        return try {
            errorCode.toInt()
        } catch (e: Exception) {
            -1
        }
    }

val Throwable.msg: String
    get() {
        return if (this is UnknownHostException) { //网络异常
            &quot;当前无网络，请检查你的网络设置&quot;
        } else if (
            this is SocketTimeoutException  //okhttp全局设置超时
            || this is TimeoutException     //rxjava中的timeout方法超时
            || this is TimeoutCancellationException  //协程超时
        ) {
            &quot;连接超时,请稍后再试&quot;
        } else if (this is ConnectException) {
            &quot;网络不给力，请稍候重试！&quot;
        } else if (this is HttpStatusCodeException) {               //请求失败异常
            &quot;Http状态码异常&quot;
        } else if (this is JsonSyntaxException) {  //请求成功，但Json语法异常,导致解析失败
            &quot;数据解析失败,请检查数据是否正确&quot;
        } else if (this is ParseException) {       // ParseException异常表明请求成功，但是数据不正确
            this.message ?: errorCode   //msg为空，显示code
        } else {
            &quot;请求失败，请稍后再试&quot;
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到这，业务code统一判断就介绍完毕，上面的代码，大部分人都可以简单修改后，直接用到自己的项目上，如&lt;code&gt;ResponseParser&lt;/code&gt;解析器，只需要改下&lt;code&gt;if&lt;/code&gt;语句的判断条件即可&lt;/p&gt;
&lt;h2 id=&quot;22、retry-失败重试&quot;&gt;2.2、retry 失败重试&lt;/h2&gt;
&lt;p&gt;OkHttp为我们提供了全局的失败重试机制，然而，这远远不能满足我们的需求，比如，我就部分接口需要失败重试，而不是全局的；我需要根据某些条件来判断是否需要重试；亦或者我需要周期性重试，即间隔几秒后重试等等&lt;/p&gt;
&lt;p&gt;那RxHttp协程是如何解决这些问题的呢？RxHttp提供了一个&lt;code&gt;retry()&lt;/code&gt;方法来解决这些难题，来看下完整的方法签名&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-kotlin&quot;&gt;/**
 * 失败重试，该方法仅在使用协程时才有效
 * @param times  重试次数, 默认Int.MAX_VALUE 代表不断重试
 * @param period 重试周期, 默认为0, 单位: milliseconds
 * @param test   重试条件, 默认为空，即无条件重试
 */
fun retry(
    times: Int = Int.MAX_VALUE,
    period: Long = 0,
    test: ((Throwable) -&amp;gt; Boolean)? = null
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;retry()&lt;/code&gt;方法共有3个参数，分别是重试次数、重试周期、重试条件，都有默认值，3个参数可以随意搭配，如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-kotlin&quot;&gt;retry()    //无条件、不间断、一直重试
retry(2)   //无条件、不间断、重试两次
retry(2, 1000)   //无条件 间隔1s 重试2此
retry { it is ConnectException } //有条件、不间断、一直重试
retry(2) { it is ConnectException }  //有条件、不间断、重试2次
retry(2, 1000) { it is ConnectException }  //有条件、间隔1s、重试2次
retry(period = 1000) { it is ConnectException } //有条件、间断1s、一直重试
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;前两个参数相信大家一看就能明白，这里对第3个参数额外说一下，通过第三个参数，我们可以拿到&lt;code&gt;Throwable&lt;/code&gt;异常对象，我们可以对异常做判断，如果需要重试，就返回true，不需要就返回false，下面看看具体代码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-kotlin&quot;&gt;val student = RxHttp.postForm(&quot;/service/...&quot;)
    .toResponse&amp;lt;Student&amp;gt;()
    .retry(2, 1000) {       //重试2次，每次间隔1s                       
        it is ConnectException   //如果是网络异常就重试     
    }                                             
    .await()                     
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;23、timeout-超时&quot;&gt;2.3、timeout 超时&lt;/h2&gt;
&lt;p&gt;OkHttp提供了全局的读、写及连接超时，有时我们也需要为某个请求设置不同的超时时长，此时就可以用到RxHttp的&lt;code&gt;timeout(Long)&lt;/code&gt;方法，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-kotlin&quot;&gt;val student = RxHttp.postForm(&quot;/service/...&quot;)
    .toResponse&amp;lt;Student&amp;gt;()
    .timeout(3000)      //超时时长为3s                           
    .await()                       
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;24、async-异步操作符&quot;&gt;2.4、async 异步操作符&lt;/h2&gt;
&lt;p&gt;如果我们由两个请求需要并行时，就可以使用该操作符，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-kotlin&quot;&gt;//同时获取两个学生信息
suspend void initData() {
  val asyncStudent1 = RxHttp.postForm(&quot;/service/...&quot;)
    .toResponse&amp;lt;Student&amp;gt;()
    .async()   //这里会返回Deferred&amp;lt;Student&amp;gt;  
    
  val asyncStudent2 = RxHttp.postForm(&quot;/service/...&quot;)
    .toResponse&amp;lt;Student&amp;gt;()
    .async()   //这里会返回Deferred&amp;lt;Student&amp;gt;  

  //随后调用await方法获取对象    
  val student1 = asyncStudent1.await()
  val student2 = asyncStudent2.await()
} 
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;25、delay、startdelay-延迟&quot;&gt;2.5、delay、startDelay 延迟&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;delay&lt;/code&gt;操作符是请求结束后，延迟一段时间返回；而&lt;code&gt;startDelay&lt;/code&gt;操作符则是延迟一段时间后再发送请求，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-kotlin&quot;&gt;val student = RxHttp.postForm(&quot;/service/...&quot;)
    .toResponse&amp;lt;Student&amp;gt;()
    .delay(1000)      //请求回来后，延迟1s返回                         
    .await()       
    
val student = RxHttp.postForm(&quot;/service/...&quot;)
    .toResponse&amp;lt;Student&amp;gt;()
    .startDelay(1000)     //延迟1s后再发送请求       
    .await()     
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;26、onerrorreturn、onerrorreturnitem异常默认值&quot;&gt;2.6、onErrorReturn、onErrorReturnItem异常默认值&lt;/h2&gt;
&lt;p&gt;有些情况，我们不希望请求出现异常时，直接走异常回调，此时我们就可以通过两个操作符，给出默认的值，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-kotlin&quot;&gt;//根据异常给出默认值
val student = RxHttp.postForm(&quot;/service/...&quot;)
    .toResponse&amp;lt;Student&amp;gt;()
    .timeout(100)      //超时时长为100毫秒  
    .onErrorReturn {
        //如果时超时异常，就给出默认值，否则，抛出原异常
        return@onErrorReturn if (it is TimeoutCancellationException)
            Student()                                              
        else                                                        
            throw it                                                
    }
    .await()
    
//只要出现异常，就返回默认值
val student = RxHttp.postForm(&quot;/service/...&quot;)
    .toResponse&amp;lt;Student&amp;gt;()
    .timeout(100)      //超时时长为100毫秒  
    .onErrorReturnItem(Student())
    .await()
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;27、tryawait-异常返回null&quot;&gt;2.7、tryAwait 异常返回null&lt;/h2&gt;
&lt;p&gt;如果你不想在异常时返回默认值，又不想异常是影响程序的执行，&lt;code&gt;tryAwait&lt;/code&gt;就派上用场了，它会在异常出现时，返回null，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-kotlin&quot;&gt;val student = RxHttp.postForm(&quot;/service/...&quot;)
    .toResponse&amp;lt;Student&amp;gt;()
    .timeout(100)      //超时时长为100毫秒                        
    .tryAwait()     //这里返回 Student? 对象，即有可能为空  
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;28-map-转换符号&quot;&gt;2.8 map 转换符号&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;map&lt;/code&gt;操作符很好理解，RxJava即协程的Flow都有该操作符，功能都是一样，用于转换对象，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-kotlin&quot;&gt;val student = RxHttp.postForm(&quot;/service/...&quot;)
    .toStr()
    .map { it.length }  //String转Int                        
    .tryAwait()     //这里返回 Student? 对象，即有可能为空  
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;29、以上操作符随意搭配&quot;&gt;2.9、以上操作符随意搭配&lt;/h2&gt;
&lt;p&gt;以上操作符，可随意搭配使用，但调用顺序的不同，产生的效果也不一样，这里先告诉大家，以上操作符只会对上游代码产生影响。&lt;/p&gt;
&lt;p&gt;如&lt;code&gt;timeout及retry&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-kotlin&quot;&gt;val student = RxHttp.postForm(&quot;/service/...&quot;)
    .toResponse&amp;lt;Student&amp;gt;()
    .timeout(50)
    .retry(2, 1000) { it is TimeoutCancellationException }                                  
    .await()                       
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上代码，只要出现超时，就会重试，并且最多重试两次。&lt;/p&gt;
&lt;p&gt;但如果&lt;code&gt;timeout&lt;/code&gt;、&lt;code&gt;retry&lt;/code&gt;互换下位置，就不一样了，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-kotlin&quot;&gt;val student = RxHttp.postForm(&quot;/service/...&quot;)
    .toResponse&amp;lt;Student&amp;gt;()
    .retry(2, 1000) { it is TimeoutCancellationException }       
    .timeout(50)                                  
    .await()                       
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时，如果50毫秒内请求没有完成，就会触发超时异常，并且直接走异常回调，不会重试。为什么会这样？原因很简单，&lt;code&gt;timeout及retry&lt;/code&gt;操作符，仅对上游代码生效。如retry操作符，下游的异常是捕获不到的，这就是为什么timeout在retry下，超时时，重试机制没有触发的原因。&lt;/p&gt;
&lt;p&gt;在看&lt;code&gt;timeout&lt;/code&gt;和&lt;code&gt;startDelay&lt;/code&gt;操作符&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-kotlin&quot;&gt;val student = RxHttp.postForm(&quot;/service/...&quot;)
    .toResponse&amp;lt;Student&amp;gt;()
    .startDelay(2000)       
    .timeout(1000)                                  
    .await()                       
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上代码，必定会触发超时异常，因为startDelay，延迟了2000毫秒，而超时时长只有1000毫秒，所以必定触发超时。&lt;br/&gt;但互换下位置，又不一样了，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-kotlin&quot;&gt;val student = RxHttp.postForm(&quot;/service/...&quot;)
    .toResponse&amp;lt;Student&amp;gt;()
    .timeout(1000)    
    .startDelay(2000)       
    .await()                       
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上代码正常情况下，都能正确拿到返回值，为什么？原因很简单，上面说过，操作符只会对上游产生影响，下游的&lt;code&gt;startDelay&lt;/code&gt;延迟，它是不管的，也管不到。&lt;/p&gt;

&lt;p&gt;RxHttp对文件的优雅操作是与生俱来的，在协程的环境下，依然如此，没有什么比代码更具有说服力，直接上代码&lt;/p&gt;
&lt;h2 id=&quot;31、文件上传&quot;&gt;3.1、文件上传&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-kotlin&quot;&gt; val result = RxHttp.postForm(&quot;/service/...&quot;)  
     .addFile(&quot;file&quot;, File(&quot;xxx/1.png&quot;))        //添加单个文件   
     .addFile(&quot;fileList&quot;, ArrayList&amp;lt;File&amp;gt;())    //添加多个文件
     .toResponse&amp;lt;String&amp;gt;()
     .await()                   
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;只需要通过&lt;code&gt;addFile&lt;/code&gt;系列方法添加File对象即可，就是这么简单粗暴，想监听上传进度？简单，再加一个&lt;code&gt;upload&lt;/code&gt;操作符即可，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-kotlin&quot;&gt;val result = RxHttp.postForm(&quot;/service/...&quot;)                               
    .addFile(&quot;file&quot;, File(&quot;xxx/1.png&quot;))                                     
    .addFile(&quot;fileList&quot;, ArrayList&amp;lt;File&amp;gt;())                                 
    .upload(this) {    //此this为CoroutineScope对象，即当前协程对象  
        //it为Progress对象                                                
        val process = it.progress         //已上传进度  0-100                       
        val currentSize = it.currentSize  //已上传size，单位：byte                 
        val totalSize = it.totalSize      //要上传的总size  单位：byte           
    }                                                               
    .toResponse&amp;lt;String&amp;gt;()        
    .await()                                                                                                                       
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们来看下&lt;code&gt;upload&lt;/code&gt;方法的完整签名，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-kotlin&quot;&gt;/**
 * 调用此方法监听上传进度                                                    
 * @param coroutine  CoroutineScope对象，用于开启协程，回调进度，进度回调所在线程取决于协程所在线程
 * @param progress 进度回调  
 * 注意：此方法仅在协程环境下才生效                                         
 */
fun RxHttpFormParam.upload(
    coroutine: CoroutineScope? = null, 
    progress: (Progress) -&amp;gt; Unit
):RxHttpFormParam
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;32、文件下载&quot;&gt;3.2、文件下载&lt;/h2&gt;
&lt;p&gt;接着再来看看下载，直接贴代码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-kotlin&quot;&gt;val localPath = &quot;sdcard//android/data/..../1.apk&quot; 
val student = RxHttp.postForm(&quot;/service/...&quot;)     
    .toDownload(localPath)  //下载需要传入本地文件路径   
    .await()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下载调用&lt;code&gt;toDownload(String)&lt;/code&gt;方法，传入本地文件路径即可，要监听下载进度？也简单，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-kotlin&quot;&gt;val localPath = &quot;sdcard//android/data/..../1.apk&quot;  
val student = RxHttp.postForm(&quot;/service/...&quot;)      
    .toDownload(localPath, this) {   //此this为CoroutineScope对象     
        //it为Progress对象
        val process = it.progress        //已下载进度 0-100
        val currentSize = it.currentSize //已下载size，单位：byte
        val totalSize = it.totalSize     //要下载的总size 单位：byte                                           
    }     
    .await()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看下&lt;code&gt;toDownload&lt;/code&gt;方法完整签名&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-kotlin&quot;&gt;/**
 * @param destPath 本地存储路径
 * @param coroutine CoroutineScope对象，用于开启协程，回调进度，进度回调所在线程取决于协程所在线程
 * @param progress 进度回调
 */
fun IRxHttp.toDownload(
    destPath: String,
    coroutine: CoroutineScope? = null,
    progress: (Progress) -&amp;gt; Unit
): IAwait&amp;lt;String&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果你需要断点下载，也是可以的，一行代码的事，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-kotlin&quot;&gt;val localPath = &quot;sdcard//android/data/..../1.apk&quot;                        
val student = RxHttp.postForm(&quot;/service/...&quot;)                            
    .setRangeHeader(1000, 300000)   //断点下载，设置下载起始/结束位置                                     
    .toDownload(localPath, this) { //此this为CoroutineScope对象           
        //it为Progress对象                                                  
        val process = it.progress        //已下载进度 0-100                          
        val currentSize = it.currentSize //已下size，单位：byte               
        val totalSize = it.totalSize     //要下的总size 单位：byte                 
    }      
    .await()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;老规则，看下&lt;code&gt;setRangeHeader&lt;/code&gt;完整签名&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-kotlin&quot;&gt;/**                                                                                      
 * 设置断点下载开始/结束位置                                                                         
 * @param startIndex 断点下载开始位置                                                            
 * @param endIndex 断点下载结束位置，默认为-1，即默认结束位置为文件末尾                                           
 * @param connectLastProgress 是否衔接上次的下载进度，该参数仅在带进度断点下载时生效                                
 */                                                                                      
fun setRangeHeader (
    startIndex: Long, 
    endIndex: Long = 0L, 
    connectLastProgress: Boolean = false
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到这，RxHttp协程的基础Api基本介绍完毕，那么问题了，以上介绍的Api都依赖与协程环境，那我这么开启协程呢？亦或者说，我对协程不是很懂，你只要保证安全的前提下，告诉怎么用就行了，ok，那下面如何安全的开启一个协程，做到自动异常捕获，且页面销毁时，自动关闭协程及请求&lt;/p&gt;

&lt;p&gt;此时就要引入本人开源的另一个库&lt;a href=&quot;https://github.com/liujingxing/RxLife-Coroutine&quot;&gt;RxLife-Coroutine&lt;/a&gt;，用于开启/关闭协程，并自动异常捕获，依赖如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-kotlin&quot;&gt;implementation 'com.ljx.rxlife:rxlife-coroutine:2.0.0'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;本文在介绍业务code统一处理的时候，我们用到rxLifeScope属性开启协程，那这个是什么类型呢？看代码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-kotlin&quot;&gt;val ViewModel.rxLifeScope: RxLifeScope
    get() {
        val scope: RxLifeScope? = this.getTag(JOB_KEY)
        if (scope != null) {
            return scope
        }
        return setTagIfAbsent(JOB_KEY, RxLifeScope())
    }

val LifecycleOwner.rxLifeScope: RxLifeScope
    get() = lifecycle.rxLifeScope
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，我们为&lt;code&gt;ViewModel&lt;/code&gt;及&lt;code&gt;LifecycleOwner&lt;/code&gt;都扩展了一个名为&lt;code&gt;rxLifeScope&lt;/code&gt;的属性，类型为&lt;code&gt;RxLifeScope&lt;/code&gt;，ViewModel相信大家都知道了，这里就简单讲一下LifecycleOwner接口，我们的Fragment及FragmentActivity都实现了&lt;code&gt;LifecycleOwner&lt;/code&gt;接口，而我们的Activity一般继承于AppCompatActivity，而AppCompatActivity继承于FragmentActivity，所以我们在&lt;code&gt;FragmentActivity/Fragment/ViewModel&lt;/code&gt;环境下，可以直接使用&lt;code&gt;rxLifeScope&lt;/code&gt;开启协程，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;rxLifeScope.lanuch({
    //协程代码块，运行在UI线程
}, {
    //异常回调，协程代码块出现任何异常，都会直接走这里    
})
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过这种方式开启的协程，会在页面销毁时，会自动关闭协程，当然，如果你的协程代码块里还有RxHttp请求的代码，协程关闭的同时，也是关闭请求，所以在这种情况下，只需要知道如何开启协程就行，其它一律不管。&lt;/p&gt;
&lt;p&gt;现在，我们来看下&lt;code&gt;rxLifeScope.lanuch&lt;/code&gt;方法的完整签名&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-kotlin&quot;&gt;/**                                                         
 * @param block     协程代码块，运行在UI线程                           
 * @param onError   异常回调，运行在UI线程                            
 * @param onStart   协程开始回调，运行在UI线程                          
 * @param onFinally 协程结束回调，不管成功/失败，都会回调，运行在UI线程             
 */                                                         
fun launch(                                                 
    block: suspend CoroutineScope.() -&amp;gt; Unit,               
    onError: ((Throwable) -&amp;gt; Unit)? = null,                 
    onStart: (() -&amp;gt; Unit)? = null,                          
    onFinally: (() -&amp;gt; Unit)? = null                         
): Job                                                    
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，不仅有失败回调，还有开始及结束回调，这对于我们发请求来说，真的非常方便，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-kotlin&quot;&gt;rxLifeScope.launch({                                      
    //协程代码块                                              
    val students = RxHttp.postJson(&quot;/service/...&quot;)
        .toResponse&amp;lt;List&amp;lt;Student&amp;gt;&amp;gt;()
        .await()   
    //可以直接更新UI                   
}, {                                                      
    //异常回调，这里可以拿到Throwable对象                             
}, {                                                     
    //开始回调，可以开启等待弹窗                                      
}, {                                                     
    //结束回调，可以销毁等待弹窗                                      
})                                                       
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上代码均运行在UI线程中，请求回来后，便可直接更新UI&lt;/p&gt;
&lt;p&gt;也许你还有疑问，我在非&lt;code&gt;FragmentActivity/Fragment/ViewModel&lt;/code&gt;环境下，如何开启协程，又如何关闭，其实也很简单，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-kotlin&quot;&gt;val job = RxLifeScope().launch({                                        
    val students = RxHttp.postJson(&quot;/service/...&quot;)
        .toResponse&amp;lt;List&amp;lt;Student&amp;gt;&amp;gt;()
        .await()            
}, {                                                
    //异常回调，这里可以拿到Throwable对象                       
}, {                                               
    //开始回调，可以开启等待弹窗                                
}, {                                               
    //结束回调，可以销毁等待弹窗                                
})                                                 
job.cancel()  //关闭协程                                                                                        
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上代码，需要注意两点，第一，我们需要手动创建&lt;code&gt;RxLifeScope()&lt;/code&gt;对象，随后开启协程；第二，开启协程后，可以拿到&lt;code&gt;Job&lt;/code&gt;对象，我们需要通过该对象手动关闭协程。其它就没啥区别了。&lt;/p&gt;

&lt;p&gt;我们知道，协程最大的优势就是：&lt;code&gt;能以看起来同步的代码，写出异步的逻辑&lt;/code&gt;，这使得我们可以非常优雅的实现多任务场景，比如多请求的并行/串行&lt;/p&gt;
&lt;h2 id=&quot;51、协程串行多个请求&quot;&gt;5.1、协程串行多个请求&lt;/h2&gt;
&lt;p&gt;假设，我们有这么一种场景，首先获取Student对象，随后通过studentId获取学生的家庭成员列表，后者依赖于前者，这是典型的串行场景&lt;/p&gt;
&lt;p&gt;看看通过协程如何解决这个问题，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-kotlin&quot;&gt;class MainActivity : AppCompatActivity() {
    //启动协程，发送请求
    fun sendRequest() {
        rxLifeScope.launch({
            //当前运行在协程中，且在主线程运行
            val student = getStudent()
            val personList = getFamilyPersons(student.id) //通过学生Id，查询家庭成员信息
            //拿到相关信息后，便可直接更新UI，如：
            tvName.text = student.name
        }, {
                //出现异常，就会到这里，这里的it为Throwable类型
            it.show(&quot;发送失败,请稍后再试!&quot;) //show方法是在Demo中扩展的方法
        })
    }

    //挂断方法，获取学生信息
    suspend fun getStudent(): Student {
        return RxHttp.get(&quot;/service/...&quot;)
            .add(&quot;key&quot;, &quot;value&quot;)
            .addHeader(&quot;headKey&quot;, &quot;headValue&quot;)
            .toClass&amp;lt;Student&amp;gt;()
            .await()
    }

    //挂断方法，获取家庭成员信息
    suspend fun getFamilyPersons(studentId: Int): List&amp;lt;Person&amp;gt; {
        return RxHttp.get(&quot;/service/...&quot;)
            .add(&quot;studentId&quot;, &quot;studentId&quot;)
            .toClass&amp;lt;List&amp;lt;Person&amp;gt;&amp;gt;()
            .await()
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们重点看下协程代码块，首先通过第一个请求拿到Student对象，随后拿到studentId，发送第二个请求获取学习家庭成员列表，拿到后，便可以直接更新UI，怎么样，是不是看起来同步的代码，写出了异步的逻辑。&lt;/p&gt;
&lt;p&gt;串行请求中，只要其中一个请求出现异常，协程便会关闭（同时也会关闭请求），停止执行剩下的代码，接着走异常回调&lt;/p&gt;
&lt;h2 id=&quot;52、协程并行多个请求&quot;&gt;5.2、协程并行多个请求&lt;/h2&gt;
&lt;p&gt;请求并行，在现实开发中，也是家常便饭，在一个Activity中，我们往往需要拿到多种数据来展示给用户，而这些数据，都是不同接口下发的。&lt;/p&gt;
&lt;p&gt;如我们有这样一个页面，顶部是横向滚动的Banner条，Banner条下面展示学习列表，此时就有两个接口，一个获取Banner条列表，一个获取学习列表，它们两个互不依赖，便可以并行执行，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-kotlin&quot;&gt;class MainActivity : AppCompatActivity() {
    //启动协程，发送请求
    fun sendRequest() {
        rxLifeScope.launch({
            //当前运行在协程中，且在主线程运行
            val asyncBanner = getBanners() //这里返回Deferred&amp;lt;List&amp;lt;Banner&amp;gt;&amp;gt;对象
            val asyncPersons = getStudents() //这里返回Deferred&amp;lt;List&amp;lt;Student&amp;gt;&amp;gt;对象
            val banners = asyncBanner.await()           //这里返回List&amp;lt;Banner&amp;gt;对象
            val students = asyncPersons.await()         //这里返回List&amp;lt;Student&amp;gt;对象
            //开始更新UI

        }, {
                //出现异常，就会到这里，这里的it为Throwable类型
            it.show(&quot;发送失败,请稍后再试!&quot;) //show方法是在Demo中扩展的方法
        })
    }

    //挂断方法，获取学生信息
    suspend fun getBanners(): Deferred&amp;lt;List&amp;lt;Banner&amp;gt;&amp;gt; {
        return RxHttp.get(&quot;/service/...&quot;)
            .add(&quot;key&quot;, &quot;value&quot;)
            .addHeader(&quot;headKey&quot;, &quot;headValue&quot;)
            .toClass&amp;lt;List&amp;lt;Banner&amp;gt;&amp;gt;()
            .async()  //注意这里使用async异步操作符
    }

    //挂断方法，获取家庭成员信息
    suspend fun getStudents(): Deferred&amp;lt;List&amp;lt;Student&amp;gt;&amp;gt; {
        return RxHttp.get(&quot;/service/...&quot;)
            .add(&quot;key&quot;, &quot;value&quot;)
            .toClass&amp;lt;List&amp;lt;Student&amp;gt;&amp;gt;()
            .async() //注意这里使用async异步操作符
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上述代码的两个挂断方法中，均使用了&lt;code&gt;async&lt;/code&gt;异步操作符，此时这两个请求就并行发送请求，随后拿到&lt;code&gt;Deferred&amp;lt;T&amp;gt;&lt;/code&gt;对象，调用其&lt;code&gt;await()&lt;/code&gt;方法，最终拿到Banner列表及Student列表，最后便可以直接更新UI。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;划重点&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;并行跟串行一样，如果其中一个请求出现了异常，协程便会自动关闭（同时关闭请求），停止执行剩下的代码，接着走异常回调。如果想多个请求互不影响，就可以使用上面介绍的&lt;code&gt;onErrorReturn&lt;/code&gt;、&lt;code&gt;onErrorReturnItem&lt;/code&gt;操作符，出现异常时，给出一个默认对象，又或者使用&lt;code&gt;tryAwait&lt;/code&gt;操作符获取返回值，出现异常时，返回null，这样就不会影响其它请求的执行。&lt;/p&gt;

&lt;p&gt;看完本文，相信你已经领悟到了RxHttp优雅及简便，业务code的统一处理，失败重试、超时、文件上传/下载及进度监听，到后面&lt;code&gt;rxLifeScope&lt;/code&gt;协程的开启/关闭/异常处理/多任务处理，一切都是那么的优雅。&lt;/p&gt;
&lt;p&gt;其实，RxHttp远不止这些，本文只是讲解了RxHttp与协程相关的东西，更多优雅的功能，如：多/动态baseUrl的处理、公共参数/请求头的添加、请求加解密、缓存等等，请查看&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5ded221a518825125d14a1d4&quot;&gt;RxHttp 让你眼前一亮的Http请求框架&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5dff3c2de51d45582c27cea6&quot;&gt;RxHttp 全网Http缓存最优解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最后，开源不易，写文章更不易，还需要劳烦大家给本文点个赞，可以的话，再给个&lt;a href=&quot;https://github.com/liujingxing/okhttp-RxHttp&quot;&gt;star&lt;/a&gt;，感觉不尽，🙏🙏🙏🙏🙏🙏🙏🙏🙏🙏🙏🙏&lt;/p&gt;
</description>
<pubDate>Mon, 20 Apr 2020 15:34:00 +0000</pubDate>
<dc:creator>刘敬兴</dc:creator>
<og:description>1、前言 Hello，各位小伙伴，又见面了，回首过去， &amp;quot;RxHttp&amp;quot; 就要迎来一周年生日了(19年4月推出)，这一年，走过来真心....真心不容易，代码维护、写文章、写文档等等</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/liujingxing/p/12741525.html</dc:identifier>
</item>
</channel>
</rss>