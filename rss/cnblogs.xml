<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Python获得百度统计API的数据并发送邮件 - 段小辉</title>
<link>http://www.cnblogs.com/xiaohuiduan/p/10322479.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaohuiduan/p/10322479.html</guid>
<description>&lt;div class=&quot;preview html_preview&quot; readability=&quot;60.655204898728&quot;&gt;

&lt;p&gt;&lt;span class=&quot;tag blue label&quot;&gt;小工具&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;本来这么晚是不准备写博客的，当是想到了那个狗子绝对会在开学的时候跟我逼逼这个事情，所以，还是老老实实地写一下吧。&lt;/p&gt;

&lt;div class=&quot;story_image_container story_block_image&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://img2018.cnblogs.com/blog/1439869/201901/1439869-20190126032119036-207317025.jpg&quot; alt=&quot;&quot; name=&quot;images/3.jpeg&quot; data-src=&quot;images/3.jpeg&quot;/&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;h2&gt;Baidu统计API的使用&lt;/h2&gt;
&lt;p&gt;系统环境：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Python2
&lt;ul&gt;&lt;li&gt;requests库：发出请求&lt;/li&gt;
&lt;li&gt;json库：json处理&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;getSiteList的使用&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://tongji.baidu.com/open/api/more?p=tongjiapi_getSiteList.tpl&quot; target=&quot;_blank&quot;&gt;官方文档&lt;/a&gt;在此,说实话，这是我使用百BaiduAPI最坑的一次，在这个官方文档的getSiteList中，完全不告诉你请求参数是什么。&lt;/p&gt;
&lt;p&gt;首先，需要获得百度统计API的token，在这&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img title=&quot;里面&quot; src=&quot;https://tongji.baidu.com/open/api/more?p=tongjiapi_guide.tpl&quot; alt=&quot;里面&quot; name=&quot;&quot; data-src=&quot;https://tongji.baidu.com/open/api/more?p=tongjiapi_guide.tpl&quot;/&gt;&lt;/span&gt;写了token获得的流程。&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;14&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python hljs&quot; data-info=&quot;python&quot;&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; requests
&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; json

siteListUrl = &lt;span class=&quot;hljs-string&quot;&gt;&quot;https://api.baidu.com/json/tongji/v1/ReportService/getSiteList&quot;&lt;/span&gt;


data = {
    &lt;span class=&quot;hljs-string&quot;&gt;&quot;header&quot;&lt;/span&gt;: {
        &lt;span class=&quot;hljs-string&quot;&gt;'username'&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;你的用户名&quot;&lt;/span&gt;,
        &lt;span class=&quot;hljs-string&quot;&gt;'password'&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;你的密码&quot;&lt;/span&gt;,
        &lt;span class=&quot;hljs-string&quot;&gt;'token'&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;'前面所获得的token'&lt;/span&gt;,
        &lt;span class=&quot;hljs-string&quot;&gt;'Content-type'&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;'application/json'&lt;/span&gt;
    }
}

data = json.dumps(data)

r = requests.post(url,data=data)


&lt;span class=&quot;hljs-keyword&quot;&gt;print&lt;/span&gt; r.text

&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;getData的使用&lt;/h3&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;20&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python hljs&quot; data-info=&quot;python&quot;&gt;

getDataUrl = &lt;span class=&quot;hljs-string&quot;&gt;&quot;https://api.baidu.com/json/tongji/v1/ReportService/getData&quot;&lt;/span&gt;


data = {
    &lt;span class=&quot;hljs-string&quot;&gt;&quot;header&quot;&lt;/span&gt;: {
        &lt;span class=&quot;hljs-string&quot;&gt;'username'&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;你的用户名&quot;&lt;/span&gt;,
        &lt;span class=&quot;hljs-string&quot;&gt;'password'&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;你的密码&quot;&lt;/span&gt;,
        &lt;span class=&quot;hljs-string&quot;&gt;'token'&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;'前面所获得的token'&lt;/span&gt;,
        &lt;span class=&quot;hljs-string&quot;&gt;'Content-type'&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;'application/json'&lt;/span&gt;
    },

    
    &lt;span class=&quot;hljs-string&quot;&gt;&quot;body&quot;&lt;/span&gt;: {
        &lt;span class=&quot;hljs-string&quot;&gt;'site_id'&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;12914021&lt;/span&gt;,
        &lt;span class=&quot;hljs-string&quot;&gt;'method'&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;'trend/time/a'&lt;/span&gt;,
        
        &lt;span class=&quot;hljs-string&quot;&gt;'start_date'&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;'20190125'&lt;/span&gt;,
        
        &lt;span class=&quot;hljs-string&quot;&gt;'end_date'&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;'20190126'&lt;/span&gt;,
        
        &lt;span class=&quot;hljs-string&quot;&gt;'metrics'&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;'pv_count,visitor_count'&lt;/span&gt;
    }
}

r = requests.post(getDataUrl,data=json.dumps(data))
result = json.loads(r.text)
pv_uv  = result[&lt;span class=&quot;hljs-string&quot;&gt;&quot;body&quot;&lt;/span&gt;][&lt;span class=&quot;hljs-string&quot;&gt;&quot;data&quot;&lt;/span&gt;][&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;][&lt;span class=&quot;hljs-string&quot;&gt;&quot;result&quot;&lt;/span&gt;][&lt;span class=&quot;hljs-string&quot;&gt;&quot;pageSum&quot;&lt;/span&gt;][&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]

pv = pv_uv[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]

uv = pv_uv[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]

&lt;span class=&quot;hljs-keyword&quot;&gt;print&lt;/span&gt; pv_uv 
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时，我们就已经获得了pv和nv的数据。&lt;/p&gt;

&lt;h2&gt;使用Python发送邮件&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Python2
&lt;ul&gt;&lt;li&gt;requests库：发出请求&lt;/li&gt;
&lt;li&gt;json库：json处理&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在这里，我使用的是SMTP协议去发送邮件，使用的是QQ邮箱，QQ邮箱的开启，参考&lt;a href=&quot;https://jingyan.baidu.com/article/b0b63dbf1b2ef54a49307054.html&quot; target=&quot;_blank&quot;&gt;百度经验&lt;/a&gt;。&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;16&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python hljs&quot; data-info=&quot;python&quot;&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; email.mime.text &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; MIMEText
&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; email.header &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; Header
&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; smtplib &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; SMTP_SSL


hostServer = &lt;span class=&quot;hljs-string&quot;&gt;'smtp.qq.com'&lt;/span&gt;

sendMail = &lt;span class=&quot;hljs-string&quot;&gt;'你的QQ邮箱'&lt;/span&gt;
receiveMail = &lt;span class=&quot;hljs-string&quot;&gt;'接收方的邮件地址'&lt;/span&gt;


smtp = SMTP_SSL(hostServer)


smtp.login(&lt;span class=&quot;hljs-string&quot;&gt;'你的qq'&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;'授权码'&lt;/span&gt;)


msg = MIMEText(&lt;span class=&quot;hljs-string&quot;&gt;&quot;你要发送的内容&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;plain&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;'utf-8'&lt;/span&gt;)

msg[&lt;span class=&quot;hljs-string&quot;&gt;&quot;Subject&quot;&lt;/span&gt;] = Header(&lt;span class=&quot;hljs-string&quot;&gt;&quot;帅哥的邮件&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;'utf-8'&lt;/span&gt;)


msg[&lt;span class=&quot;hljs-string&quot;&gt;&quot;From&quot;&lt;/span&gt;] = sendMail

msg[&lt;span class=&quot;hljs-string&quot;&gt;&quot;To&quot;&lt;/span&gt;] = receiveMail

smtp.sendmail(sendMail, receiveMail, msg.as_string())

smtp.quit()
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;结合使用&lt;/h2&gt;
&lt;p&gt;代码写的耦合度比较高，如果使用的话，需要根据自己的实际情况去修改&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;28&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python hljs&quot; data-info=&quot;python&quot;&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; time
&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; requests
&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; json
&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; email.mime.text &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; MIMEText
&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; email.header &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; Header
&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; smtplib &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; SMTP_SSL


nowTime = time.strftime(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%Y%m%d&quot;&lt;/span&gt;, time.localtime())

sendQQ = &lt;span class=&quot;hljs-string&quot;&gt;&quot;xxx&quot;&lt;/span&gt;

receiveMail = &lt;span class=&quot;hljs-string&quot;&gt;&quot;xxx&quot;&lt;/span&gt;

token = &lt;span class=&quot;hljs-string&quot;&gt;&quot;xxx&quot;&lt;/span&gt;

siteId = xxx

mailCode = &lt;span class=&quot;hljs-string&quot;&gt;&quot;xxx&quot;&lt;/span&gt;


&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;get_pv_uv&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;

    dataUrl = &lt;span class=&quot;hljs-string&quot;&gt;&quot;https://api.baidu.com/json/tongji/v1/ReportService/getData&quot;&lt;/span&gt;

    body = {
        &lt;span class=&quot;hljs-string&quot;&gt;&quot;header&quot;&lt;/span&gt;: {
            &lt;span class=&quot;hljs-string&quot;&gt;'username'&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;xxx&quot;&lt;/span&gt;,
            &lt;span class=&quot;hljs-string&quot;&gt;'password'&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;xxx&quot;&lt;/span&gt;,
            &lt;span class=&quot;hljs-string&quot;&gt;'token'&lt;/span&gt;: token,
            &lt;span class=&quot;hljs-string&quot;&gt;'Content-type'&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;'application/json'&lt;/span&gt;
        },
        &lt;span class=&quot;hljs-string&quot;&gt;&quot;body&quot;&lt;/span&gt;: {
            &lt;span class=&quot;hljs-string&quot;&gt;'site_id'&lt;/span&gt;: siteId,
            &lt;span class=&quot;hljs-string&quot;&gt;'method'&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;'trend/time/a'&lt;/span&gt;,
            &lt;span class=&quot;hljs-string&quot;&gt;'start_date'&lt;/span&gt;: nowTime,
            &lt;span class=&quot;hljs-string&quot;&gt;'end_date'&lt;/span&gt;: nowTime,
            &lt;span class=&quot;hljs-string&quot;&gt;'metrics'&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;'pv_count,visitor_count'&lt;/span&gt;
        }

    }

    r = requests.post(dataUrl, data=json.dumps(body))
    result = json.loads(r.text)
    pv_uv = result[&lt;span class=&quot;hljs-string&quot;&gt;&quot;body&quot;&lt;/span&gt;][&lt;span class=&quot;hljs-string&quot;&gt;&quot;data&quot;&lt;/span&gt;][&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;][&lt;span class=&quot;hljs-string&quot;&gt;&quot;result&quot;&lt;/span&gt;][&lt;span class=&quot;hljs-string&quot;&gt;&quot;pageSum&quot;&lt;/span&gt;][&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; pv_uv


&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;sendMail&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(pv_uv)&lt;/span&gt;:&lt;/span&gt;


    
    mailContent = &lt;span class=&quot;hljs-string&quot;&gt;&quot;小主，晚上好，这是昨天的统计数据，昨天的博客园一共有%s个人访问了小主你的博客，其中独立访客有%s位。\n小主你要加油写博客哦，有朝一日，你总会成为大佬的！(*^__^*) 嘻嘻……&quot;&lt;/span&gt; % (pv_uv[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;],pv_uv[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;])
    
    
    hostServer = &lt;span class=&quot;hljs-string&quot;&gt;'smtp.qq.com'&lt;/span&gt;
    sendEmail = sendQQ+&lt;span class=&quot;hljs-string&quot;&gt;'@qq.com'&lt;/span&gt;

    
    smtp = SMTP_SSL(hostServer)

    smtp.login(sendQQ, mailCode)
    msg = MIMEText(mailContent, &lt;span class=&quot;hljs-string&quot;&gt;&quot;plain&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;'utf-8'&lt;/span&gt;)
    msg[&lt;span class=&quot;hljs-string&quot;&gt;&quot;Subject&quot;&lt;/span&gt;] = Header(&lt;span class=&quot;hljs-string&quot;&gt;&quot;博客园统计邮件&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;'utf-8'&lt;/span&gt;)
    msg[&lt;span class=&quot;hljs-string&quot;&gt;&quot;From&quot;&lt;/span&gt;] = sendEmail
    msg[&lt;span class=&quot;hljs-string&quot;&gt;&quot;To&quot;&lt;/span&gt;] = receiveMail
    smtp.sendmail(sendEmail, receiveMail, msg.as_string())
    smtp.quit()

sendMail(get_pv_uv())
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这时候，我们就可以将我们的python程序部署在Linux云服务器上面，那么我们怎么能够让这个程序在每天的23.30分运行呢？这时候我们就可以使用Linux上面的crontab了。&lt;/p&gt;
&lt;p&gt;进入linux,输入&lt;code&gt;crontab -e&lt;/code&gt;，然后在里面&lt;code&gt;30 23 * * * python ~/Home/tongji.py【你的Python文件地址】 &amp;gt;&amp;gt; tongji.txt&lt;/code&gt;就可以设置为，在晚上的11.30分发送该邮件。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;晚上还是不适合写博客，不然写着写着就饿了,/(ㄒoㄒ)/~~&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;story_image_container story_block_image&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://img2018.cnblogs.com/blog/1439869/201901/1439869-20190126032119319-374254050.jpg&quot; alt=&quot;&quot; name=&quot;images/4.jpeg&quot; data-src=&quot;images/4.jpeg&quot;/&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
</description>
<pubDate>Fri, 25 Jan 2019 19:21:00 +0000</pubDate>
<dc:creator>段小辉</dc:creator>
<og:description>Python获得百度统计API的数据并发送邮件 小工具 本来这么晚是不准备写博客的，当是想到了那个狗子绝对会在开学的时候跟我逼逼这个事情，所以，还是老老实实地写一下吧。 &lt;!-- more --</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaohuiduan/p/10322479.html</dc:identifier>
</item>
<item>
<title>日访问量百亿级的应用如何做缓存架构设计 - SimpleWu</title>
<link>http://www.cnblogs.com/SimpleWu/p/10322360.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/SimpleWu/p/10322360.html</guid>
<description>&lt;p&gt;微博日活跃用户1.6亿+，每日访问量达百亿级，面对庞大用户群的海量访问，良好架构且不断改进的缓存体系具有非常重要的支撑作用。&lt;/p&gt;
&lt;p&gt;4月21日，中生代技术走进盒子科技的现场技术交流活动上，新浪微博技术专家陈波为大家讲解了微博Cache架构的设计实践过程。&lt;/p&gt;
&lt;p&gt;刷微博吗？跟我们一起听听那些庞大的数据是如何呈现的吧！&lt;/p&gt;
&lt;h5 id=&quot;数据挑战&quot;&gt;数据挑战&lt;/h5&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/450255266/courses/blob/master/DesignOfTenBillionLevelCacheArchitecture/1.jpg&quot;&gt;&lt;img src=&quot;https://github.com/450255266/courses/raw/master/DesignOfTenBillionLevelCacheArchitecture/1.jpg&quot; alt=&quot;日访问量百亿级的应用如何做缓存架构设计&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h5 id=&quot;feed平台系统架构&quot;&gt;Feed平台系统架构&lt;/h5&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/450255266/courses/blob/master/DesignOfTenBillionLevelCacheArchitecture/2.jpg&quot;&gt;&lt;img src=&quot;https://github.com/450255266/courses/raw/master/DesignOfTenBillionLevelCacheArchitecture/2.jpg&quot; alt=&quot;日访问量百亿级的应用如何做缓存架构设计&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;总共分为五层，最上层是端层，比如web端，客户端，大家用的ios或安卓的一些客户端，还有一些开放平台，第三方接入的一些接口。下面是平台接入层，不同的池子，主要是为了把好的资源集中调配给重要的核心接口，这样突发流量的时候，有更好的弹性来服务，提高服务稳定性。再下面是平台服务层，主要是Feed算法，关系等等。接下来是中间层，通过各种中间介质提供一些服务。最下面一层就是存储层，平台架构大概是这样。&lt;/p&gt;
&lt;h5 id=&quot;feed-timeline&quot;&gt;Feed timeline&lt;/h5&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/450255266/courses/blob/master/DesignOfTenBillionLevelCacheArchitecture/3.jpg&quot;&gt;&lt;img src=&quot;https://github.com/450255266/courses/raw/master/DesignOfTenBillionLevelCacheArchitecture/3.jpg&quot; alt=&quot;日访问量百亿级的应用如何做缓存架构设计&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;大家日常刷微博的时候，比如在主站或客户端点一下刷新，最新获得了十到十五条微博，它这个是怎么构建出来的呢？刷新之后，首先会获得用户的关注关系，比如她有一千个关注，会把这一千个ID拿到，根据这一千个UID，拿到每个用户发表的一些微博，同时会获取这个用户的Inbox，就是她收到的特殊的一些消息，比如分组的一些微博，群的微博，下面她的关注关系，她关注人的微博列表，拿到这一系列微博列表之后进行集合、排序，拿到所需要的那些ID，再对这些ID去取每一条微博ID对应的微博内容，如果这些微博是转发过来的，它还有一个原微博，会进一步取原微博内容，通过原微博取用户信息，进一步根据用户的过滤词，对这些微博进行过滤，过滤掉用户不想看到的微博，留下这些微博后，再进一步来看，用户对这些微博有没有收藏、赞，做一些flag设置，最后还会对这些微博各种计数，转发、评论、赞数进行组装，最后才把这十几条微博返回给用户的各种端。这样看，用户一次请求，最终得到十几条记录，后端服务器大概要对几百甚至几千条数据进行实时组装，再返回给用户，整个过程对Cache体系强度依赖。所以Cache架构设计优劣直接会影响到微博体系表现的好坏。&lt;/p&gt;
&lt;h5 id=&quot;feed-cache架构&quot;&gt;Feed Cache架构&lt;/h5&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/450255266/courses/blob/master/DesignOfTenBillionLevelCacheArchitecture/4.jpg&quot;&gt;&lt;img src=&quot;https://github.com/450255266/courses/raw/master/DesignOfTenBillionLevelCacheArchitecture/4.jpg&quot; alt=&quot;日访问量百亿级的应用如何做缓存架构设计&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;然后我们看一下Cache架构，它主要分为6层，首先是Inbox，主要是分组的一些微博，然后直接对群主的一些微博，Inbox比较少，主要是推的方式。然后对于Outbox，每个用户都会发常规的微博，都会在它Outbox里面去，根据存的ID的数量，实际上分成多个Cache，普通的大概是200多，如果是长的大概是2000条。第三组就是一些关系，它的关注、粉丝、用户。第四个就是内容，每一条微博一些内容存在这里。下面就是一些存在性判断，比如微博里面，这条微博有没有赞过，之前有一些明星就说我没有点赞这条微博怎么显示我点赞了，引发一些新闻，这种就是记录，实际上她在某个时候点赞忘记了。最下面还有比较大的一块——计数。一条微博评论转发等计数，对用户来说，她的关注数粉丝数这些数据。&lt;/p&gt;
&lt;h5 id=&quot;cache架构及演进&quot;&gt;Cache架构及演进&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;1.简单KV数据类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/450255266/courses/blob/master/DesignOfTenBillionLevelCacheArchitecture/5.jpg&quot;&gt;&lt;img src=&quot;https://github.com/450255266/courses/raw/master/DesignOfTenBillionLevelCacheArchitecture/5.jpg&quot; alt=&quot;日访问量百亿级的应用如何做缓存架构设计&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;接下来我们着重讲一些微博Cache架构演进过程，最开始微博上线的时候，都是把它作为一个简单的KV证人数据类型来存储，我们主要采取哈希分片存储在MC池子里，上线几个月之后发现一些问题，有一些节点机器宕机或者其它方面原因，大量的请求会穿透Cache层达到DB上去，导致整个请求变慢，甚至DB僵死。于是我们很快给它改造增加一个HA层，这样即便Main层出现某些节点宕机情况或者挂掉之后，这些请求会进一步穿透到HA层，不会穿透DB层，这样的话可以保证在任何情况下，整个系统命中率不会降低，系统服务稳定性比较大提升。对于这种，现在业界用得比较多，然后很多人说我直接用哈希，但这里面也有一些坑，比如我有一个节点，节点3它宕机了，Main把它给摘掉了，节点3的一些QA分给其他几个节点，这个业务量还不是很大，穿透DB，DB可以抗住。如果后面这个节点3又恢复了，它又加进来，加进来之后，节点3的访问又会回来，如果节点3因为网络原因或者机器本身的原因，它又宕机了，一些节点3的请求又会分给其他节点，这个时候就会出现问题，之前分散给其他节点写回来的数据已经没有人更新了，如果它没有被剔除掉就会出现混插数据。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/450255266/courses/blob/master/DesignOfTenBillionLevelCacheArchitecture/6.jpg&quot;&gt;&lt;img src=&quot;https://github.com/450255266/courses/raw/master/DesignOfTenBillionLevelCacheArchitecture/6.jpg&quot; alt=&quot;日访问量百亿级的应用如何做缓存架构设计&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;微博和微信很大的区别，实际上微博是一个广场型的业务，比如突发事件，某明星找个女朋友，瞬间流量就30%，突发事件后，大量的请求会出现在某一些节点，会导致这个节点非常热，即便是MC也没办法满足这么大的请求量。这时候整个MC就会变成瓶颈，导致整个系统变慢，基于这个原因我们引入L1层，还是一个Main关系池，每一个L1大概是Main层的N分之一，六分之一、八分之一、十分之一这样一个内存量，根据请求量我会增加4到8个L1，这样所有的请求来了之后首先会访问L1，L1命中的话就会直接访，如果没有命中再来访问Main-HA层，这样在一些突发流量的时候，可以由L1来抗住大部分热的请求。对微博本身来说，新的数据就会越热，只用增加很少一部分内存就会抗住更大的量。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/450255266/courses/blob/master/DesignOfTenBillionLevelCacheArchitecture/7.jpg&quot;&gt;&lt;img src=&quot;https://github.com/450255266/courses/raw/master/DesignOfTenBillionLevelCacheArchitecture/7.jpg&quot; alt=&quot;日访问量百亿级的应用如何做缓存架构设计&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;简单总结一下，通过简单KV数据类型的存储，我们实际上以MC为主的，层内HASH节点不漂移，Miss穿透到下一层去读取。通过多组L1读取性能提升，对峰值、突发流量能够抗住，而且成本会大大降低。对读写策略，采取多写，读的话采用逐层穿透，如果Miss的话就进行回写，对存在里面的数据，我们最初采用Json/xml，12年之后就直接采用Protocol| Buffer格式，对一些比较大的用QuickL进行压缩。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;集合类数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/450255266/courses/blob/master/DesignOfTenBillionLevelCacheArchitecture/8.jpg&quot;&gt;&lt;img src=&quot;https://github.com/450255266/courses/raw/master/DesignOfTenBillionLevelCacheArchitecture/8.jpg&quot; alt=&quot;日访问量百亿级的应用如何做缓存架构设计&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;刚才讲到简单的QA数据，对于复杂的集合类数据怎么来处理，比如我关注了2000人，新增一个人，这就涉及到部分修改。有一种方式把2000个ID全部拿下来进行修改，这种对带宽、机器压力会更大。还有一些分页获取，我存了2000个，只需要取其中的第几页，比如第二页，也就是第十到第二十个，能不能不要全量把所有数据取回去。还有一些资源的联动计算，会计算到我关注的某些人里面ABC也关注了用户D，这种涉及到部分数据的修改、获取，包括计算，对MC来说它实际上是不太擅长的。各种关注关系都存在Redis里面取，通过Hash分布、储存，一组多存的方式来进行读写分离。现在Redis的内存大概有30个T，每天都有2-3万亿的请求。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/450255266/courses/blob/master/DesignOfTenBillionLevelCacheArchitecture/9.jpg&quot;&gt;&lt;img src=&quot;https://github.com/450255266/courses/raw/master/DesignOfTenBillionLevelCacheArchitecture/9.jpg&quot; alt=&quot;日访问量百亿级的应用如何做缓存架构设计&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在使用Redis的过程中实际上还是遇到其他一些问题，比如从关注关系，我关注了2000个UID，有一种方式是全量存储，但微博有大量的用户，有些用户登陆比较少，有些用户特别活跃，这样全部放在内存里面成本开销是比较大的。所以我们就把Redis使用改成Cache，比如只存活跃的用户，如果你最近一段时间没有活跃之后，会把你从Redis里面踢掉，再次有访问到你的时候把你加进来。这时候存在一个问题，Redis工作机制是单线程模式，如果它加某一个UV，关注2000个用户，可能扩展到两万个UID，两万个UID塞回去基本上Redis就卡住了，没办法提供其他服务。所以我们扩展一种新的数据结构，两万个UID直接开了端，写的时候直接依次把它写到Redis里面去，读写的整个效率就会非常高，它的实现是一个long型的开放数组，通过Double Hash进行寻址。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/450255266/courses/blob/master/DesignOfTenBillionLevelCacheArchitecture/10.jpg&quot;&gt;&lt;img src=&quot;https://github.com/450255266/courses/raw/master/DesignOfTenBillionLevelCacheArchitecture/10.jpg&quot; alt=&quot;日访问量百亿级的应用如何做缓存架构设计&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对Redis来说我们进行了一些其他的扩展，之前的一些分享，大家在网上也会看到，把数据放到公共变量里面，整个升级过程，我们测试1G的话加载要10分钟，10G大概要十几分钟以上，现在是毫秒级升级。对于AOF，我们采用滚动的AOF，每个AOF是带一个ID的，达到一定的量再滚动到下一个AOF里面去。对RDB落地的时候，我们会记录构建这个RDB时，AOF文件以及它所在的位置，通过新的RDB、AOF扩展模式，实现全增量复制。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其他数据类型-计数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/450255266/courses/blob/master/DesignOfTenBillionLevelCacheArchitecture/11.jpg&quot;&gt;&lt;img src=&quot;https://github.com/450255266/courses/raw/master/DesignOfTenBillionLevelCacheArchitecture/11.jpg&quot; alt=&quot;日访问量百亿级的应用如何做缓存架构设计&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;接下来还有一些其他的数据类型，比如一个计数，实际上计数在每个互联网公司都可能会遇到，对一些中小型的业务来说，实际上MC和Redis足够用的，但在微博里面计数出现了一些特点，单条Key有多条计数，比如一条微博，有转发数、评论数、还有点赞，一个用户有粉丝数、关注数等各种各样的数字，因为是计数，它的Value size是比较小的，根据它的各种业务场景，大概就是2-8个字节，一般4个字节为多，然后每日新增的微博大概十亿条记录，总记录就更可观了，然后一次请求，可能几百条计数要返回去。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/450255266/courses/blob/master/DesignOfTenBillionLevelCacheArchitecture/12.jpg&quot;&gt;&lt;img src=&quot;https://github.com/450255266/courses/raw/master/DesignOfTenBillionLevelCacheArchitecture/12.jpg&quot; alt=&quot;日访问量百亿级的应用如何做缓存架构设计&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;计数器-Counter Service&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最初是可以采取Memcached，但它有个问题，如果计数超过它内容容量的时候，它会导致一些计数的剔除，宕机或重启后计数就没有了。另外可能有很多计数它是为零，那这个时候怎么存，要不要存，存的话就占很多内存。微博每天上十亿的计数，光存0都要占大量的内存，如果不存又会导致穿透到DB里面去，对服务的可溶性就会存在影响。2010年之后我们又采用Redis访问，随着数据量越来越大之后，发现Redis内存有效负荷还是比较低的，它一条KV大概需要至少65个字节，但实际上我们一个计数需要8个字节，然后Value大概4个字节，实际上有效只有12个字节，其他还有四十多个字节都是被浪费掉的，这还只是单个KV，如果一条Key有多个计数的情况下，它就浪费得更多了，比如说四个计数，一个Key8个字节，四个计数每个计数是4个字节，16个字节大概需要26个字节就行了。但是用Redis存大概需要200多个字节。后来通过自己研发Counter Service，内存降至Redis的五分之一到十五分之一以下，而且进行冷热分离，热数据存在内存里面，冷数据如果重新变热，就把它放到LRU里面去。落地RDB、AOF，实现全增量复制，通过这种方式，热数据单机可以存百亿级，冷数据可以存千亿级。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/450255266/courses/blob/master/DesignOfTenBillionLevelCacheArchitecture/13.jpg&quot;&gt;&lt;img src=&quot;https://github.com/450255266/courses/raw/master/DesignOfTenBillionLevelCacheArchitecture/13.jpg&quot; alt=&quot;日访问量百亿级的应用如何做缓存架构设计&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;整个存储架构大概是这样子，上面是内存，下面是SSD，在内存里面是预先把它分成N个Table，每个Table根据ID的指针序列，划出一定范围，任何一个ID过来先找到它所在的Table，如果有直接对它增增减减，有新的计数过来，发现内存不够的时候，就会把一个小的Table Dump到SSD里面去，留着新的位置放在最上面供新的ID来使用。有些人疑问说，如果在某个范围内，我的ID本来设的计数是4个字节，但是微博特别热，超过了4个字节，变成很大的一个计数怎么处理，对于超过限制的把它放在Aux dict进行存放，对于落在SSD里面的Table，我们有专门的IndAux进行访问，通过RDB方式进行复制。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其他数据类型-存在性判断&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/450255266/courses/blob/master/DesignOfTenBillionLevelCacheArchitecture/14.jpg&quot;&gt;&lt;img src=&quot;https://github.com/450255266/courses/raw/master/DesignOfTenBillionLevelCacheArchitecture/14.jpg&quot; alt=&quot;日访问量百亿级的应用如何做缓存架构设计&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;然后除了计数的话，微博还有一些业务，一些存在性判断，比如一条微博展现的，有没有点赞、阅读、推荐，如果这个用户已经读过这个微博了，就不要再显示给他，这种有个很大的特点，它检查是否存在，每条记录非常小，比如Value1个bit就可以了，但总数据量巨大。比如微博每天新发表微博1亿左右，读的可能有上百亿、上千亿这种总的数据需要判断，怎么来存储是个很大的问题，而且这里面很多存在性就是0，还是前面说的，0要不要存，如果存了，每天就存上千亿的记录，如果不存，那大量的请求最终会穿透Cache层到DB层，任何DB都没有办法抗住那么大的流量。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/450255266/courses/blob/master/DesignOfTenBillionLevelCacheArchitecture/15.jpg&quot;&gt;&lt;img src=&quot;https://github.com/450255266/courses/raw/master/DesignOfTenBillionLevelCacheArchitecture/15.jpg&quot; alt=&quot;日访问量百亿级的应用如何做缓存架构设计&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我们也进行了一些选型，首先直接考虑我们能不能用Redis，单条KV65个字节，一个KV可以8个字节的话，Value只有1个bit，这样算下来我每日新增内存有效率是非常低的。第二种我们新开发的Counter Service，单条KV Value1个bit，我就存1个byt，总共9个byt就可以了，这样每日新增内存900G，存的话可能就只能存最新若干天的，存个三天差不多快3个T了，压力也挺大，但比Redis已经好很多。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/450255266/courses/blob/master/DesignOfTenBillionLevelCacheArchitecture/16.jpg&quot;&gt;&lt;img src=&quot;https://github.com/450255266/courses/raw/master/DesignOfTenBillionLevelCacheArchitecture/16.jpg&quot; alt=&quot;日访问量百亿级的应用如何做缓存架构设计&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我们最终方案采用自己开发Phantom，先采用把共享内存分段分配，最终使用的内存只用120G就可以，算法很简单，对每个Key可以进行N次哈希，如果哈希的某一个位它是1，如果进行3次哈希，三个数字把它设为1，把X2也进行三次哈希，后面来判断X1是否存在的时候，进行三次哈希来看，如果都为1就认为它是存在的，如果某一个哈希X3，它的位算出来是0，那就百分百肯定不存在的。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/450255266/courses/blob/master/DesignOfTenBillionLevelCacheArchitecture/17.jpg&quot;&gt;&lt;img src=&quot;https://github.com/450255266/courses/raw/master/DesignOfTenBillionLevelCacheArchitecture/17.jpg&quot; alt=&quot;日访问量百亿级的应用如何做缓存架构设计&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;它的实现架构比较简单，把共享内存预先拆分到不同Table里面，在里面进行开方式计算，然后读写，落地的话采用AOF+RDB的方式进行处理。整个过程因为放在共享内存里面，进程要升级重启数据也不会丢失。对外访问的时候，建Redis协议，它直接扩展新的协议就可以访问我们这个服务了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/450255266/courses/blob/master/DesignOfTenBillionLevelCacheArchitecture/18.jpg&quot;&gt;&lt;img src=&quot;https://github.com/450255266/courses/raw/master/DesignOfTenBillionLevelCacheArchitecture/18.jpg&quot; alt=&quot;日访问量百亿级的应用如何做缓存架构设计&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;小结一下，到目前为止，关注Cache集群内高可用、它的扩展性，包括它的性能，还有一个特别重要就是存储成本，还有一些我们没有关注到，比如21运维性如何，微博现在已经有几千差不多上万台服务器等等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;进一步优化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/450255266/courses/blob/master/DesignOfTenBillionLevelCacheArchitecture/19.jpg&quot;&gt;&lt;img src=&quot;https://github.com/450255266/courses/raw/master/DesignOfTenBillionLevelCacheArchitecture/19.jpg&quot; alt=&quot;日访问量百亿级的应用如何做缓存架构设计&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;服务化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/450255266/courses/blob/master/DesignOfTenBillionLevelCacheArchitecture/20.jpg&quot;&gt;&lt;img src=&quot;https://github.com/450255266/courses/raw/master/DesignOfTenBillionLevelCacheArchitecture/20.jpg&quot; alt=&quot;日访问量百亿级的应用如何做缓存架构设计&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;采取的方案首先就是对整个Cache进行服务化管理，对配置进行服务化管理，避免频繁重启，另外如果配置发生变更，直接用一个脚本修改一下。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/450255266/courses/blob/master/DesignOfTenBillionLevelCacheArchitecture/21.jpg&quot;&gt;&lt;img src=&quot;https://github.com/450255266/courses/raw/master/DesignOfTenBillionLevelCacheArchitecture/21.jpg&quot; alt=&quot;日访问量百亿级的应用如何做缓存架构设计&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;服务化还引入Cluster Manager，实现对外部的管理，通过一个界面来进行管理，可以进行服务校验。服务治理方面，可以做到扩容、缩容，SLA也可以得到很好保障。另外对于开发来说，现在就可以屏蔽Cache资源。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结与展望&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/450255266/courses/blob/master/DesignOfTenBillionLevelCacheArchitecture/22.jpg&quot;&gt;&lt;img src=&quot;https://github.com/450255266/courses/raw/master/DesignOfTenBillionLevelCacheArchitecture/22.jpg&quot; alt=&quot;日访问量百亿级的应用如何做缓存架构设计&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最后简单总结一下，对于微博Cache架构来说，从它数据架构、性能、储存成本、服务化不同方面进行优化增强。&lt;/p&gt;
</description>
<pubDate>Fri, 25 Jan 2019 15:59:00 +0000</pubDate>
<dc:creator>SimpleWu</dc:creator>
<og:description>微博日活跃用户1.6亿+，每日访问量达百亿级，面对庞大用户群的海量访问，良好架构且不断改进的缓存体系具有非常重要的支撑作用。 4月21日，中生代技术走进盒子科技的现场技术交流活动上，新浪微博技术专家陈</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/SimpleWu/p/10322360.html</dc:identifier>
</item>
<item>
<title>使用c语言计算分期贷款折算年化收益率（内部收益率IRR*12） - 皇家救星</title>
<link>http://www.cnblogs.com/kingstarer/p/10322343.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kingstarer/p/10322343.html</guid>
<description>&lt;p&gt;　　众所周知，现在银行的分期贷款利率是很有诱惑性人。表面看利率是很低的，例如招行的闪电贷有时给我的利率是4.3%&lt;/p&gt;
&lt;p&gt;但是，由于贷款是分期还本的，我手上的本金每月都在减少，到最后一个月时手上只有少量本金，但是还的利息却还是跟第一个月一样。&lt;/p&gt;
&lt;p&gt;　　excel提供了一个公式叫irr，专门用来计算这种分期贷款实际利率的。&lt;/p&gt;
&lt;p&gt;irr函数有两个参数，第一个是现金流，第二个是预估值。只要我们根据贷款情况填好总贷款金额和每月还款金额就可以算出每月的内部收益率。&lt;/p&gt;
&lt;p&gt;月内部收益率*12就是我们的实际贷款利率。预估值一般不用填，只有irr计算失败返回&lt;span&gt;#NUM!&lt;/span&gt;才要考虑填，具体可见office官方说明。&lt;/p&gt;
&lt;p&gt;　　https://support.office.com/zh-cn/article/IRR-%E5%87%BD%E6%95%B0-64925eaa-9988-495b-b290-3ad0c163c1bc&lt;/p&gt;
&lt;p&gt;　　为方便计算，我做了一个excel表格，有兴趣大家可以去下载。只要输入下面图片黄底黑体列，即可自动得出折算年利率。招行的闪电贷利率表面看是4.3%,实际年化利率是7.84%。&lt;/p&gt;
&lt;p&gt;　　如果你把钱投理财产品，没有7.84%以上你实际是亏本的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/781609/201901/781609-20190125233617973-12250114.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　当然，本文重点不是介绍irr函数，而是我写（抄）的一个计算irr的程序（函数）。使用的是二分迭代法（网上看还有牛顿迭代法和加速迭代法，这两种需要用到数学知识）&lt;/p&gt;
&lt;p&gt;之所以用c语言写一个，原因是我们最近项目组有一个c程序需要计算内部收益率。我从网上找了一个程序改了一下，变成一个函数，并加上注释，方便理解和调用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/781609/201901/781609-20190125234221301-700408013.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　程序和代码还有前面提到的表格我都已经上传，有需要可以去下载。实现代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;78&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; testirr.cpp : 定义控制台应用程序的入口点。
&lt;/span&gt;&lt;span&gt;//
&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;stdafx.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;math.h&amp;gt;


&lt;span&gt;//&lt;/span&gt;&lt;span&gt;const double zero = 1e-5;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;int n;&lt;/span&gt;

&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
//代码是在csdn上找到的 我拿下来改了一下
//&lt;/span&gt;&lt;span&gt;https://blog.csdn.net/dinghaoseu/article/details/50322117&lt;/span&gt;&lt;span&gt;
//这是原来的代码
double quickpow(double a, int b)
{
    double ans = 1;
    while(b)
    {
        if(b &amp;amp; 1) ans = ans * a;
        a = a * a;
        b &amp;gt;&amp;gt;= 1;
    }
    return ans;
}

double makeans(double irr)
{
    double ans = 0;
    for(int i = 1; i &amp;lt;= n; i++)
        ans += ( a[i] / (quickpow(1 + irr, i)) );
    return ans;
}
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算流出Npv&lt;/span&gt;
&lt;span&gt;double&lt;/span&gt; getNpvOut(&lt;span&gt;double&lt;/span&gt; irr, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; arrOutMoney[], &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n)
{
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; npv = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; denominator = &lt;span&gt;1&lt;/span&gt; + irr; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;分母&lt;/span&gt;
    &lt;span&gt;double&lt;/span&gt; multiplier = denominator; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;乘数&lt;/span&gt;

    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt;= n; ++&lt;span&gt;i)
    {
        npv &lt;/span&gt;+= arrOutMoney[i] / denominator; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;即：arrOutMoney[i] / (quickpow(1 + irr, i)&lt;/span&gt;
        denominator *=&lt;span&gt; multiplier;
    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; npv;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;最小最大IRR（内部收益率） 用于折算年化率计算
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;最小值必须大于-1 最大值1其实就足够了，折算成年化收益率是120%（国家规定利率不能超过30%）
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数字越小计算速度越快，为保险计这里填10&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; IRR_MIN -1.0f
&lt;span&gt;#define&lt;/span&gt; IRR_MAX 10.0f

&lt;span&gt;//&lt;/span&gt;&lt;span&gt;二分迭代寻找合适的irr值（如果存在多个irr，取第一次找到的值，不保证大小顺序）
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;arrInOutMoney是分期现金流 nArrLen是arrInOutMoney元素个数
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;arrInOutMoney[0]必须是负数，代表总分期金额（负数），后面是每期还款金额（正数）
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回[IRR_MIN, IRR_MAX]之间的数字代表符合要求的IRR值，&amp;lt;IRR_MIN代表找不到合适的IRR&lt;/span&gt;
&lt;span&gt;double&lt;/span&gt; binarySearchGetIrr(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; arrInOutMoney[], &lt;span&gt;int&lt;/span&gt;&lt;span&gt; nArrLen)
{
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; l = IRR_MIN, r = IRR_MAX; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;irr取值-1~10之间 &lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; n = nArrLen - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;int nCnt = 0;&lt;/span&gt;

    &lt;span&gt;while&lt;/span&gt; (l &amp;lt;&lt;span&gt; r)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;每次从最大和最小期望IRR中间取一个数值进行npv测算&lt;/span&gt;
        &lt;span&gt;double&lt;/span&gt; mid = (l + r) / &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;现在是用除法求Npv，其实可以改成用乘法求，效率会高一点
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;因为计算机处理乘法速度比较快&lt;/span&gt;
        &lt;span&gt;double&lt;/span&gt; npvOut =&lt;span&gt; getNpvOut(mid, arrInOutMoney, n);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;++nCnt;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果结果等于0说明找到符合要求的IRR&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (fabs(npvOut + arrInOutMoney[&lt;span&gt;0&lt;/span&gt;]) &amp;lt;= 1e-&lt;span&gt;5&lt;/span&gt;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;double类型不能直接与0比较判断是否相等&lt;/span&gt;
&lt;span&gt;        {    
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;printf(&quot;nCnt = %d\n&quot;, nCnt); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;经测试，一般分12期迭代次数在30~60之间&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; mid;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;irr越大，npvOut越小，故npvOut太大时irr就应该落在mid和r之间，反之则反之&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (npvOut &amp;gt; -arrInOutMoney[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]) 
        {
            l &lt;/span&gt;=&lt;span&gt; mid;
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        {
            r &lt;/span&gt;=&lt;span&gt; mid;
        }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;printf(&quot;nCnt = %d\n&quot;, nCnt);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;找不到返回比IRR_MIN还小的值&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; IRR_MIN - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输入按月分期现金流，输出对应irr和折算年化收益率
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;arrInOutMoney是分期现金流 nArrLen是arrInOutMoney元素个数（一般是7或者13）
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;arrInOutMoney[0]必须是负数，代表总分期金额，后面是每期还款金额（正数）
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;nCheckFlag = 0，代表直接计算irr，否则会先对数据合法性做检查
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回0代表成功 其它代表失败 失败原因存放在errBuf（调用者需要保证至少有256个字节空间）&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; GetIrrAndAnnualizedRate(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; arrInOutMoney[], &lt;span&gt;int&lt;/span&gt;&lt;span&gt; nArrLen,
    OUT &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; *pIrr, OUT &lt;span&gt;double&lt;/span&gt; *&lt;span&gt;pAnnualizedRate, 
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; nCheckFlag, OUT &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;errBuf)
{
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; irr = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (nCheckFlag != &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt; inMoney, outMoney;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i;

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (arrInOutMoney == NULL || nArrLen &amp;lt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)
        {
            strcpy(errBuf, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;arrInOutMoney需要非空并且元素个数大于2个&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -&lt;span&gt;10&lt;/span&gt;&lt;span&gt;;
        }

        inMoney &lt;/span&gt;= arrInOutMoney[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];
        outMoney &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt; nArrLen; ++&lt;span&gt;i)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (arrInOutMoney[i] &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不支持多次现金流入（因为没这个需求，不要浪费计算力）&lt;/span&gt;
                outMoney = -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }
            outMoney &lt;/span&gt;+=&lt;span&gt; arrInOutMoney[i];
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (inMoney &amp;gt;= &lt;span&gt;0&lt;/span&gt; || (-inMoney &amp;gt;&lt;span&gt; outMoney))
        {
            strcpy(errBuf, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;第一个元素必须是负现金流，之后每个元素均是正现金流，&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
                &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;并且正现金流之和要大于负现金流&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -&lt;span&gt;20&lt;/span&gt;&lt;span&gt;;
        }
    }

    irr &lt;/span&gt;=&lt;span&gt; binarySearchGetIrr(arrInOutMoney, nArrLen);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (irr &amp;lt;&lt;span&gt; IRR_MIN)
    {
        sprintf(errBuf, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%.5f(%.2f%%)~%.5f(%.2f%%)之间无法找到合适的irr，请检查现金流是否输入异常&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            IRR_MIN, IRR_MIN &lt;/span&gt;* &lt;span&gt;12&lt;/span&gt; * &lt;span&gt;100&lt;/span&gt;, IRR_MAX, IRR_MAX * &lt;span&gt;12&lt;/span&gt; * &lt;span&gt;100&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -&lt;span&gt;30&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;*pIrr =&lt;span&gt; irr;
    &lt;/span&gt;*pAnnualizedRate = irr * &lt;span&gt;12&lt;/span&gt; * &lt;span&gt;100&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; getIrrDemo()
{
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt; irr, annualizedRate;
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; a[&lt;span&gt;100&lt;/span&gt; * &lt;span&gt;12&lt;/span&gt; + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n, nRet;
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; errBuf[&lt;span&gt;256&lt;/span&gt;&lt;span&gt;];

    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;**************如果要退出，请在还款期数填0**************\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; ((printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;input 还款期数 n（0代表退出）:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)) &amp;amp;&amp;amp; ~scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &amp;amp;n) &amp;amp;&amp;amp;&lt;span&gt; n)
    {
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;n = %d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, n);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (n &amp;gt;= &lt;span&gt;sizeof&lt;/span&gt;(a) / &lt;span&gt;sizeof&lt;/span&gt;(a[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]))
        {
            printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;n值太大，不支持\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
        }

        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;输入分期金额（负数）:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%lf&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &amp;amp;a[&lt;span&gt;0&lt;/span&gt;]) != &lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
            printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;输入的金额不能包含非数字和小数点\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            getchar();
            &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
        }

        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;输入%d期还款金额（正数），每输入一期按一次回车:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, n);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt;= n; i++&lt;span&gt;)
        {
            scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%lf&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &amp;amp;&lt;span&gt;a[i]);
        }

        nRet &lt;/span&gt;= GetIrrAndAnnualizedRate(a, n + &lt;span&gt;1&lt;/span&gt;, &amp;amp;irr, &amp;amp;annualizedRate, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;, errBuf);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (nRet != &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
        {
            printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;error:[%s]\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, errBuf);
            &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算irr常用的方法是迭代计算，即不断尝试可能值，根据尝试结果缩小范围，直到找到符合要求的值
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;网上能找到的迭代算法有二分迭代，牛顿迭代，加速迭代，其中二分迭代最好理解，最容易开发&lt;/span&gt;
        irr = binarySearchGetIrr(a, n + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (irr &amp;lt;&lt;span&gt; IRR_MIN)
        {
            printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;找不到合适的irr\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        {
            printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;irr = %.6f  年化收益率(12 * irr) = %.4f%%\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, irr, annualizedRate);
        }
    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}


&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;argv[])
{
    getIrrDemo();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;system(&quot;pause&quot;);&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;




</description>
<pubDate>Fri, 25 Jan 2019 15:50:00 +0000</pubDate>
<dc:creator>皇家救星</dc:creator>
<og:description>众所周知，现在银行的分期贷款利率是很有诱惑性人。表面看利率是很低的，例如招行的闪电贷有时给我的利率是4.3% 但是，由于贷款是分期还本的，我手上的本金每月都在减少，到最后一个月时手上只有少量本金，但是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kingstarer/p/10322343.html</dc:identifier>
</item>
<item>
<title>开源工具软件XMusicDownloader——音乐下载神器 - JadePeng</title>
<link>http://www.cnblogs.com/xiaoqi/p/xmusicdownloader.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaoqi/p/xmusicdownloader.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://github.com/jadepeng/XMusicDownloader&quot;&gt;XMusicDownloader&lt;/a&gt;，一款 支持从百度、网易、qq和酷狗等音乐网站搜索并下载歌曲的程序。&lt;/p&gt;
&lt;p&gt;缘起：&lt;/p&gt;
&lt;p&gt;一直用网易音乐听歌，但是诸如李健、周杰伦的不少歌曲，网易都没有版权，要从QQ等音乐去下载，因此一直想写一个小程序，可以从其他音乐网站下载相关歌曲，趁放假，花了几小时做了这样一个程序。&lt;/p&gt;
&lt;p&gt;BTW: 之前写过一个&lt;a href=&quot;https://github.com/jadepeng/musicDecryptor&quot;&gt;从酷狗和网易音乐提取缓存文件的程序&lt;/a&gt;，感兴趣的可以查看。&lt;/p&gt;
&lt;h2 id=&quot;功能&quot;&gt;功能&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;聚合搜索多家音乐网站&lt;/li&gt;
&lt;li&gt;支持音乐批量下载&lt;/li&gt;
&lt;li&gt;搜索结果综合排序&lt;/li&gt;
&lt;li&gt;可以编写Provider程序，支持其他音乐网站&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;实现IMusicProvider即可，主要是搜索和获取下载链接的方法。&lt;/p&gt;
&lt;pre class=&quot;csharp?linenums&quot;&gt;
&lt;code&gt;    public interface IMusicProvider
    {
        string Name { get; }

        string getDownloadUrl(Song song);
        List&amp;lt;Song&amp;gt; SearchSongs(string keyword, int page, int pageSize);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;界面截图&quot;&gt;界面截图&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://www.github.com/jadepeng/blogpic/raw/master/images/2019/1-25/1548431781568.png&quot; alt=&quot;预览&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;下载程序&quot;&gt;下载程序&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/jadepeng/XMusicDownloader/releases&quot; class=&quot;uri&quot;&gt;https://github.com/jadepeng/XMusicDownloader/releases&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;实现方案介绍&quot;&gt;实现方案介绍&lt;/h2&gt;
&lt;h3 id=&quot;定义song实体&quot;&gt;定义song实体&lt;/h3&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;public class Song
    {
        public string id { get; set; }
        public string name { get; set; }
        public string singer { get; set; }
        public string album { get; set; }
        public string source { get; set; }
        public double duration { get; set; }
        public double size { get; set; }
        public string url { get; set; }
        public int rate { get; set; }
        public int index { get; set; }

        public string getFileName()
        {
            return singer + &quot;-&quot; + name + &quot;.mp3&quot;;
        }

        public string getMergedKey()
        {
            return singer.Replace(&quot; &quot;, &quot;&quot;) + name.Replace(&quot; &quot;, &quot;&quot;);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;封装各个音乐网站&quot;&gt;封装各个音乐网站&lt;/h3&gt;
&lt;p&gt;抽象为MusicProvider，音乐提供方:)，定义Name为名称，SearchSongs搜索歌曲，getDownloadUrl获取音乐下载地址。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;
    public interface IMusicProvider
    {
        string Name { get; }

        string getDownloadUrl(Song song);
        List&amp;lt;Song&amp;gt; SearchSongs(string keyword, int page, int pageSize);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后就是依次实现百度、网易等音乐网站，以QQ为例。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt; public class QQProvider : IMusicProvider
    {
        static HttpConfig DEFAULT_CONFIG = new HttpConfig
        {
            Referer = &quot;http://m.y.qq.com&quot;,

        };

        public string Name { get; } = &quot;QQ&quot;;

        static string[] prefixes = new string[] { &quot;M800&quot;, &quot;M500&quot;, &quot;C400&quot; };

        public List&amp;lt;Song&amp;gt; SearchSongs(string keyword,int page,int pageSize)
        {
            var searchResult = HttpHelper.GET(string.Format(&quot;http://c.y.qq.com/soso/fcgi-bin/search_for_qq_cp?w={0}&amp;amp;format=json&amp;amp;p={1}&amp;amp;n={2}&quot;, keyword, page,pageSize), DEFAULT_CONFIG);
            var searchResultJson = JsonParser.Deserialize(searchResult).data.song;
            var result = new List&amp;lt;Song&amp;gt;();

            var index = 1;
            foreach(var songItem in searchResultJson.list)
            {
                var song = new Song
                {
                    id = songItem[&quot;songmid&quot;],
                    name = songItem[&quot;songname&quot;],
                    album = songItem[&quot;albumname&quot;],
                    rate = 128,
                    size = songItem[&quot;size128&quot;],
                    source = Name,
                    index = index++,
                    duration = songItem[&quot;interval&quot;]
                };
                song.singer = &quot;&quot;;
                foreach (var ar in songItem[&quot;singer&quot;])
                {
                    song.singer += ar[&quot;name&quot;] + &quot; &quot;;
                }
                result.Add(song);
            }

            return result;

        }

        public string getDownloadUrl(Song song)
        {
            var guid = new Random().Next(1000000000, 2000000000);

            var key = JsonParser.Deserialize(HttpHelper.GET(string.Format(&quot;http://base.music.qq.com/fcgi-bin/fcg_musicexpress.fcg?guid={0}&amp;amp;format=json&amp;amp;json=3&quot;,guid), DEFAULT_CONFIG)).key;
            foreach(var prefix in prefixes)
            {
               
                var musicUrl = string.Format(&quot;http://dl.stream.qqmusic.qq.com/{0}{1}.mp3?vkey={2}&amp;amp;guid={3}&amp;amp;fromtag=1&quot;, prefix, song.id, key, guid);
                if (HttpHelper.GetUrlContentLength(musicUrl) &amp;gt; 0)
                {
                    return musicUrl;
                }
            }

            return null;

        }
    
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;搜索调用&lt;code&gt;http://c.y.qq.com/soso/fcgi-bin/search_for_qq_cp?w={0}&amp;amp;format=json&amp;amp;p={1}&amp;amp;n={2}&lt;/code&gt;接口，获取下载地址调用&lt;code&gt;http://base.music.qq.com/fcgi-bin/fcg_musicexpress.fcg?guid={0}&amp;amp;format=json&amp;amp;json=3&lt;/code&gt;,然后再组合。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;聚合搜索&quot;&gt;聚合搜索&lt;/h3&gt;
&lt;p&gt;设计一个MusicProviders，加载所有的IMusicProvider，提供一个SearchSongs方法，并发调用各个网站的搜索，然后merge到一起。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;
  public List&amp;lt;MergedSong&amp;gt; SearchSongs(string keyword, int page, int pageSize)
        {
            var songs = new List&amp;lt;Song&amp;gt;();
            Providers.AsParallel().ForAll(provider =&amp;gt;
            {
                var currentSongs = provider.SearchSongs(keyword, page, pageSize);
                songs.AddRange(currentSongs);
            });

            // merge

            return songs.GroupBy(s =&amp;gt; s.getMergedKey()).Select(g =&amp;gt; new MergedSong(g.ToList())).OrderByDescending(s =&amp;gt; s.score).ToList();
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关于merge，核心就是将相同的歌曲合并到一起，我们暂且认为歌手+歌曲名相同的为同一首歌曲：&lt;/p&gt;
&lt;pre class=&quot;csharp?linenums&quot;&gt;
&lt;code&gt;   public string getMergedKey()
        {
            return singer.Replace(&quot; &quot;, &quot;&quot;) + name.Replace(&quot; &quot;, &quot;&quot;);
        }
        &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因此按megekey分组，就能实现聚合。我们设计一个&lt;code&gt;MergedSong&lt;/code&gt;来包裹。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class MergedSong
    {
        public List&amp;lt;Song&amp;gt; items
        {
            get; set;
        }

        public MergedSong(List&amp;lt;Song&amp;gt; items)
        {
            this.items = items;
        }

        public string name
        {
            get
            {
                return this.items[0].name;
            }
        }
        public string singer
        {
            get
            {
                return this.items[0].singer;
            }
        }
        public string album
        {
            get
            {
                return this.items[0].album;
            }
        }

        public string source
        {
            get
            {
                return string.Join(&quot;,&quot;, this.items.Select(i =&amp;gt; i.source).ToArray());
            }
        }


        public double duration
        {
            get
            {
                return this.items[0].duration;
            }
        }

        public double size
        {
            get
            {
                return this.items[0].size;
            }
        }

        public double rate
        {
            get
            {
                return this.items[0].rate;
            }
        }


        public double score
        {
            get
            {
                // 投票+排序加权  (各50%）
                return this.items.Count / (MusicProviders.Instance.Providers.Count - 1) + (20 - this.items.Average(i =&amp;gt; i.index)) / 20;
            }
        }

    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;MergedSong的核心是定义了一个score，我们通过投票+搜索结果排序，用来决定合并结果的排序。&lt;/p&gt;
&lt;h3 id=&quot;下载&quot;&gt;下载&lt;/h3&gt;
&lt;p&gt;下载主要是通过provider获取真实url，然后下载即可。&lt;/p&gt;
&lt;pre class=&quot;csharp?linenums&quot;&gt;
&lt;code&gt;public class SongItemDownloader
    {
        MusicProviders musicProviders;
        string target;
        MergedSong song;

        public event DownloadFinishEvent DownloadFinish;

        public SongItemDownloader(MusicProviders musicProviders, string target, MergedSong song)
        {
            this.musicProviders = musicProviders;
            this.target = target;
            this.song = song;
        }

        public long totalBytes;

        public long bytesReceived;

        public double ReceiveProgress;


        public double receiveSpeed;

        DateTime lastTime = DateTime.Now;

        public void Download()
        {
            WebClient client = new WebClient();
            client.DownloadProgressChanged += Client_DownloadProgressChanged;
            new Thread(() =&amp;gt;
            {
                // 多来源，防止单个来源出错
                foreach (var item in song.items)
                {
                    try
                    {
                        client.DownloadFile(musicProviders.getDownloadUrl(item), target + &quot;\\&quot; + item.getFileName());
                        DownloadFinish?.Invoke(this, this);
                        break;

                    }
                    catch
                    {
                    }
                }

            }).Start();
        }

        private void Client_DownloadProgressChanged(object sender, DownloadEventArgs e)
        {
            this.bytesReceived = e.bytesReceived;
            this.totalBytes = e.totalBytes;
            this.receiveSpeed = e.receiveSpeed;
            this.ReceiveProgress = e.ReceiveProgress;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;7.3156342182891&quot;&gt;
&lt;p&gt;作者：Jadepeng&lt;br/&gt;出处：jqpeng的技术记事本--&lt;a href=&quot;http://www.cnblogs.com/xiaoqi&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/xiaoqi&lt;/a&gt;&lt;br/&gt;您的支持是对博主最大的鼓励，感谢您的认真阅读。&lt;br/&gt;本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 25 Jan 2019 15:46:00 +0000</pubDate>
<dc:creator>JadePeng</dc:creator>
<og:description>一款 支持从百度、网易、qq和酷狗等音乐网站搜索并下载歌曲的开源c# windows程序。聚合搜索多家音乐网站，支持音乐批量下载，搜索结果综合排序，可以编写Provider程序，扩展支持其他音乐网站</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaoqi/p/xmusicdownloader.html</dc:identifier>
</item>
<item>
<title>如何学习新技术 - 和牛</title>
<link>http://www.cnblogs.com/heniu/p/10322118.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/heniu/p/10322118.html</guid>
<description>&lt;p&gt;&lt;span&gt;我总是感觉自己在盲目的学习一些看上去很火热的技术。比如 React Native，Flutter 等等。我家里堆了各种编程语言的入门书籍，有 Go 的，有 Erlang 的，有 c++ 的，还有 JavaScript 和 CSS。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我到现在都搞不懂这个事情。我连主流的 Python 语言都没有掌握清楚为什么要去看这么多语言的入门书呢？我在工作和生活中根本就用不到他们。只是因为在某一篇文章中看到 Go 语言是趋势，Erlang 的稳定性无人能敌，c++ 你永远都让不开等等。这些东西我都研究过，可是到现在为止还没有用他们写过一行有用的代码。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;相信很多童鞋都有类似的情况。程序员学习新技术的想法是件大好事，总比不思进取的思想状态要好，可结果却并不一定比原地踏步强，因为不一定有用，会造成技术浪费。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;浪费的事情我们生活中做得很多。我们想要买更贵的手机，因为 cpu 更强，可是很多人并不一定需要那么强的 cpu。本来只需要买个上网本看看电视却要买个工作站。我们的理由自然也很充足：万一有一天要用到呢？万一有一天我需要玩游戏呢？万一有一天我要 3D 渲染呢？追求新技术的理由也同样：万一以后它火了，我就走在了时代的前面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这种情况确实有可能发生，前提是你能将这门新技术研究得很透彻，比别人更懂，否则那些基础更强的能用很短的时间就能超越你。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我想在学习新技术之前应该做几件事情：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;先了解自己的需求是什么？在未来 3-5 年内的主要工作是 python 开发，那就应该围绕这个需求来学习。首先是 Python 的高级特性和工程设计思想，这些都落实在具体的实践上，需要积累大量项目经验，可以自己选择一些 side project 练习。自己做的时候还应该参考优秀的开源框架，看看别人的设计思路和实现方式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;需要了解 web 原理。像 HTTP 协议、TCP/IP 协议都需要精通，这样才能站在更基础的层面来进行开发，不是在网上找几套解决方案就能做出一套好的系统。看完基本经典书籍以后，要学会用抓包工具来分析流量走向，定位问题的能力。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;需要性能优化。要熟练掌握各种算法和数据结构，知道常用算法的应用场景和复杂度。学好算法基础就要去看 python 的各种内置函数实现他们的性能如何，你写出来的代码性能如何。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;性能还需要涉猎并发和异步知识。这些东西往往是操作层面的，可以先熟悉多进程、多线程和协程等在 python 的应用，消息队列等各种异步操作的实现，但是迟早还是要深入研究操作系统是怎么去进行资源调度的，《深入理解计算机系统》就该去看一看了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在这个过程中，还应该看一看《重构》《程序员修炼之道》这样的方法论书籍，争取能形成一套自己的编码和改进体系。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在工作中应该尽量避免的问题是原地踏步、google 编程，这次搜索完一套方案下次还是不知道，几年做的都是重复的事情。盲目追求新技术，拼命加班改 bug 都是技术领域尽力要避免的陷阱，看起来非常努力，实际上是在原地不动。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;学习应该是有目的的，不是看着哪个火就去学哪个。小时候都学过捡了芝麻丢了西瓜的课文，现在正是不停的在重蹈覆辙，学这个，学那个，最后自己的真正专业都没有做好了。一门技术的探究最终都会落到基础知识上，编译原理、操作系统、算法和数据结构。如果学好了一门技术真正落实到了基础上，去学另一门技术不应该是很难的事情。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在确定了方向以后把重心放在自己的方向上，平时可以花少量的时间来关注新技术，看看他们的应用领域和简单实现。喜欢玩手机并不代表每个品牌的手机都要买回来天天使用，那是职业测评师干的事，我们的思路是买一个牌子的当主力机，一个当备用机，其他的偶尔去专卖店感受一下就可以了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在项目的技术选型上也应该遵循以需求为重心的原则。如果不是高并发的项目为什么要使用热门语言 Go 呢？用 python 快速实现行不行？现在的技术团队有几个人懂这门语言，外面招人好招吗？现有人员培训需要多久呢？一定要用微服务吗？一定要用docker吗？很多都没有必要的！只是自己给自己挖的一个一个陷阱，把整个团队推进去。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接下来是怎么实现的问题。如果要突然去学非常枯燥和底层的操作系统原理，肯定会两眼一抹黑。突然从 windows 系统换到 linux 系统也会让人手足无措。一个可行性很高的方案就是渐进式改变。和菜头在一篇文章中写道：如果一家餐厅几十年的口味都不变，那肯定逃不过关门的命运。那些说自己坚持不变的人或者产品往往在发生悄无声息的改变，他们的变化如此微小，以至于你根本察觉不到，多少年以来，微信添加了多少微小的功能，很多都隐藏在 UI 之下，我们像寻宝一样一点点的发现，用习惯了以后就感觉它们从一开始就被设计出来了一样。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;要学好操作系统不一定要全心全意去攻克每一个知识点，在工作中接触到了多线程，先看看线程消耗，锁机制和信号量行不行？一点一点来，每天进步一点。人往往会高估短期能力而低估长期能力，这是思维和眼光的局限性导致的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;学习是个非常讲究方法论的事情，盲目的学习是不行的。都是参加高考，为什么那些看上去努力的学生大多成绩平平，天天打篮球、约会的就考上清华北大呢？智商是一方面，不过我到现在都不相信高考能到达人类平均智商的极限，估计方法是更加重要的一面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;万维钢关于学习的话题我觉得是很有意思的，概括几个要点是：循序渐进、逃离舒适区、重复的基础训练。最重要的是要形成整个体系和思维，不然学到的知识都不是自己的。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 25 Jan 2019 14:40:00 +0000</pubDate>
<dc:creator>和牛</dc:creator>
<og:description>我总是感觉自己在盲目的学习一些看上去很火热的技术。比如 React Native，Flutter 等等。我家里堆了各种编程语言的入门书籍，有 Go 的，有 Erlang 的，有 c++ 的，还有 Ja</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/heniu/p/10322118.html</dc:identifier>
</item>
<item>
<title>自定义Token的CAS登录 - lichdr</title>
<link>http://www.cnblogs.com/lichdr/p/10316972.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lichdr/p/10316972.html</guid>
<description>&lt;p&gt;工作中实际遇到的需求，我们有一个旧系统，用了CAS的单点登录，现在有一个外部系统，准备从它那里单点进来，这个外部系统提供了一个token参数来标记这是哪一个用户，我们用他们提供的方式解析出对应的用户，以这个用户从CAS登录进系统。&lt;/p&gt;
&lt;p&gt;有关CAS登录的分析网上多如牛毛，这里不准备多作分析了，直接上解决过程。&lt;/p&gt;
&lt;p&gt;这里实现是基于我们以前系统的，是CAS 3.5.2&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先在登录流程文件login-webflow.xml里在on-start节点后面插入&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;box&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;code&quot; readability=&quot;9.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;decision-state &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;tokenCheck&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;if &lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;=&quot;requestParameters.token != null and requestParameters.token != ''&quot;&lt;/span&gt;&lt;span&gt; then&lt;/span&gt;&lt;span&gt;=&quot;tokenValidate&quot;&lt;/span&gt;&lt;span&gt; else&lt;/span&gt;&lt;span&gt;=&quot;ticketGrantingTicketExistsCheck&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;decision-state&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这里检查是否有token参数，有的话执行token验证，没有的话走正常流程，ticketGrantingTicketExistsCheck就是原有的正常流程。&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;定义token验证节点&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;box&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;code&quot; readability=&quot;10&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;action-state &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;tokenValidate&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;evaluate &lt;/span&gt;&lt;span&gt;expression&lt;/span&gt;&lt;span&gt;=&quot;tokenLoginAction.doExecute(flowRequestContext)&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;transition &lt;/span&gt;&lt;span&gt;on&lt;/span&gt;&lt;span&gt;=&quot;error&quot;&lt;/span&gt;&lt;span&gt; to&lt;/span&gt;&lt;span&gt;=&quot;generateLoginTicket&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;transition &lt;/span&gt;&lt;span&gt;on&lt;/span&gt;&lt;span&gt;=&quot;success&quot;&lt;/span&gt;&lt;span&gt; to&lt;/span&gt;&lt;span&gt;=&quot;sendTicketGrantingTicket&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;action-state&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;失败则走generateLoginTicket分支，会生成一个LT，并重定向到登录页面，这也是通常页面登录失败后的路径&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;成功则走sendTicketGrantingTicket分支，即页面正常登录成功时走的路径&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;实现token验证流程节点&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在cas-servlet.xml里添加添加tokenLoginAction Bean&lt;/p&gt;
&lt;div class=&quot;box&quot;&gt;
&lt;div class=&quot;code&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;tokenLoginAction&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;org.jasig.cas.web.flow.TokenLoginAction&quot;&lt;/span&gt;&lt;span&gt;
    p:centralAuthenticationService-ref&lt;/span&gt;&lt;span&gt;=&quot;centralAuthenticationService&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;实现TokenLoginAction&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;这里主要解析token，并生成TGT。主要代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('771b1669-12d2-4244-b47f-52971f7e21b4')&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_771b1669-12d2-4244-b47f-52971f7e21b4&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_771b1669-12d2-4244-b47f-52971f7e21b4&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('771b1669-12d2-4244-b47f-52971f7e21b4',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_771b1669-12d2-4244-b47f-52971f7e21b4&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
HttpServletRequest request =&lt;span&gt; WebUtils.getHttpServletRequest(context);
String token &lt;/span&gt;= request.getParameter(&quot;token&quot;&lt;span&gt;);

 &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;解析Token,略。。。。。。&lt;/span&gt;
&lt;span&gt;
   CasCredentials credentials &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CasCredentials();
   credentials.setUsername(userName);
   credentials.setPassword(&lt;/span&gt;&quot;&quot;&lt;span&gt;);
   credentials.setNoAuth(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
  
   String tgt &lt;/span&gt;=&lt;span&gt; centralAuthenticationService.createTicketGrantingTicket(credentials);
   WebUtils.putTicketGrantingTicketInRequestScope(context,tgt);
  
 } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
   e.printStackTrace();
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;error&quot;&lt;span&gt;;
 }
 
 &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;success&quot;;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;TokenLoginAction的主要逻辑代码&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;上面centralAuthenticationService是注入的属性，&lt;/p&gt;
&lt;p&gt;CasCredentials则是继承自&lt;strong&gt;UsernamePasswordCredentials&lt;/strong&gt;的一个自定义Credentials，在用户名、密码基础上添加了一个&lt;strong&gt;noAuth&lt;/strong&gt;属性，用来标记是不是需要验证密码。这里由外系统提供的token保证安全性，把noAuth设为true。&lt;/p&gt;
&lt;p&gt;而登录验证逻辑在createTicketGrantingTicket这个方法里，验证未通过会抛出异常。&lt;/p&gt;
&lt;p&gt;真正验证的地方则是在authenticationManager里，里面有authenticationHandlers定义了验证方法&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;修改登录验证逻辑&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;login-webflow.xml顶部把credentials的定义先改了&lt;/p&gt;
&lt;div class=&quot;box&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;code&quot; readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;var &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;credentials&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;com.cas.util.CasCredentials&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;deployerConfigContext.xml找到自定义登录验证所在&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;box&quot;&gt;
&lt;div class=&quot;code&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;authenticationManager&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;authenticationHandlers&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;com.cas.util.QueryUserAuthenticationHandler&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
......
                           &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                       &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;在这个QueryUserAuthenticationHandler class里，验证密码之前加入&lt;/p&gt;
&lt;div class=&quot;box&quot;&gt;
&lt;div class=&quot;code&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;if&lt;/span&gt; (CasCredentials.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.isInstance(credentials)) {
   &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (((CasCredentials)credentials).isNoAuth())
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;这样就完成了传入第三方token的CAS登录。&lt;/p&gt;
&lt;p&gt;似乎是完成了，但其实还有一些东西，&lt;/p&gt;
&lt;p&gt;比如第三方进来的时候是不用他们传&lt;strong&gt;Service&lt;/strong&gt;这个参数的，而这个参数是在CAS登录初始化时处理掉的，后面没有地方自己往request里加这个参数让CAS来处理它，自己写requestscope里写Service对象又很麻烦，看了下代码，得注入很多东西才行。这样就在进入CAS流程前，自己往请求里塞一个&lt;strong&gt;Service&lt;/strong&gt;参数，然后重定向到CAS登录的url。&lt;/p&gt;
&lt;p&gt;再比如，这次是别人提供Token用他们的方法解；以后有需求是我们提供一个Token出去，接收进来后用我们的方法自己解。所以其实TokenLoginAction那里解析Token其实是解本方提供出去的Token。解别人的Token呢前置到塞&lt;strong&gt;Service&lt;/strong&gt;参数那个地方，那里解析出来用户名后，再用自己的方法生成一个Token发给CAS。这样就把第三方的Token解析分离出去了，CAS登录的地方不会跟别人的实现绑在一起。&lt;/p&gt;

</description>
<pubDate>Fri, 25 Jan 2019 14:12:00 +0000</pubDate>
<dc:creator>lichdr</dc:creator>
<og:description>工作中实际遇到的需求，我们有一个旧系统，用了CAS的单点登录，现在有一个外部系统，准备从它那里单点进来，这个外部系统提供了一个token参数来标记这是哪一个用户，我们用他们提供的方式解析出对应的用户，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lichdr/p/10316972.html</dc:identifier>
</item>
<item>
<title>Gradle中的闭包 - HappyCorn</title>
<link>http://www.cnblogs.com/lwbqqyumidi/p/10322034.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lwbqqyumidi/p/10322034.html</guid>
<description>&lt;div readability=&quot;165&quot;&gt;
&lt;p&gt;Gradle是基于Groovy的DSL基础上的构建工具，Gradle中的闭包，其原型上实际上即Groovy中闭包。而在表现形式上，其实，Gradle更多的是以&lt;code&gt;约定&lt;/code&gt;和基于约定基础上的&lt;code&gt;配置&lt;/code&gt;去展现。但本质上，大多数&lt;code&gt;配置&lt;/code&gt;，实际上都对应着闭包以及闭包的具体使用。&lt;/p&gt;
&lt;p&gt;例如，实际Android项目中，我们经常看到类似如下的所谓配置项：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash copyable&quot; lang=&quot;bash&quot;&gt;allprojects {
    repositories {
        mavenLocal()
        maven {
            url &lt;span class=&quot;hljs-string&quot;&gt;'http://maven.aliyun.com/nexus/content/groups/public/'
        }
        google()
        jcenter()
    }

    configurations.all {
        resolutionStrategy.cacheChangingModulesFor 1, &lt;span class=&quot;hljs-string&quot;&gt;'seconds'
    }
}

task clean(&lt;span class=&quot;hljs-built_in&quot;&gt;type: Delete) {
    delete rootProject.buildDir
    delete &lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;${rootProject.rootDir}/jenkinsOut&quot;
}
&lt;span class=&quot;copy-code-btn&quot;&gt;复制代码&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当我们在&lt;code&gt;allprojects&lt;/code&gt;上按住command键时，发现有如下图所示的提示。&lt;/p&gt;
&lt;div align=&quot;left&quot;&gt;&lt;img class=&quot;lazyload inited loaded&quot; src=&quot;https://user-gold-cdn.xitu.io/2019/1/25/16884d7d318c5118?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot; data-src=&quot;https://user-gold-cdn.xitu.io/2019/1/25/16884d7d318c5118?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; data-width=&quot;390&quot; data-height=&quot;105&quot;/&gt;&lt;/div&gt;
&lt;p&gt;出现的提示指的是此配置项所对应的Gradle中原型，可以点击直接进入对应的Gradle API。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash copyable&quot; lang=&quot;bash&quot;&gt;/**
     * &amp;lt;p&amp;gt;Configures this project and each of its sub-projects.&amp;lt;/p&amp;gt;
     *
     * &amp;lt;p&amp;gt;This method executes the given closure against this project and its sub-projects. The target {@link Project}
     * is passed to the closure as the closure&lt;span class=&quot;hljs-string&quot;&gt;'s delegate.&amp;lt;/p&amp;gt;
     *
     * @param configureClosure The closure to execute.
     */
    void allprojects(Closure configureClosure);
&lt;span class=&quot;copy-code-btn&quot;&gt;复制代码&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们发现，我们常用的&lt;code&gt;allprojects&lt;/code&gt;配置，实际上真正对应着的，是一个&lt;code&gt;void allprojects(Closure configureClosure)&lt;/code&gt;Java方法，而其后&lt;code&gt;{}&lt;/code&gt;中的配置，实际上整体是一个&lt;code&gt;Closure&lt;/code&gt;类型的参数，在方法说明中，指出&lt;code&gt;这个方法是为当前项目及其子项目执行给定的闭包，目标@Project作为闭包的委托传递给闭包&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;于是，到底什么是闭包，闭包具体的运作机制是怎么样的，有必要实际窥探一番。&lt;/p&gt;
&lt;p&gt;点击Gradle API中的Closure，可以进入对应的Closure类型声明，实际上对应的是Groovy jar包中的class文件声明。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash copyable&quot; lang=&quot;bash&quot;&gt;package groovy.lang;

import ...

public abstract class Closure&amp;lt;V&amp;gt; extends GroovyObjectSupport implements Cloneable, Runnable, GroovyCallable&amp;lt;V&amp;gt;, Serializable {
&lt;span class=&quot;copy-code-btn&quot;&gt;复制代码&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Closure&lt;/code&gt;，翻译过来是&lt;code&gt;闭包&lt;/code&gt;，在JS等语言中也存在闭包的概念，但是，不同语言中，对于闭包的具体描述或实际的应用，不同语言，可能还有所不同。&lt;/p&gt;
&lt;p&gt;先了解一下&lt;code&gt;Groovy&lt;/code&gt;中&lt;code&gt;闭包&lt;/code&gt;的描述：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash copyable&quot; lang=&quot;bash&quot;&gt;闭包，是一个代码块，或可以理解成一个匿名函数，在外部方法调用时，可以将其作为方法的实参传递给方法的形参，并在方法内部回调此匿名函数，且回调此匿名函数时可以传递实参给到匿名函数的内部去接收，并执行此匿名函数。
同时，此代码块或匿名函数也可以赋值给一个变量，使其具有自执行的能力，且最后一行的执行语句作为匿名函数的返回。
&lt;span class=&quot;copy-code-btn&quot;&gt;复制代码&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看着好像不太容易理解，可以具体看几个实际例子。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash copyable&quot; lang=&quot;bash&quot;&gt;// 1,定义一个闭包，赋值给一个变量，并进行显示的自我调用。
def t = {
    println &lt;span class=&quot;hljs-string&quot;&gt;&quot;Hello  Closure&quot;
}
// 此处也可以写成t.call()
t()

// 运行后，输出结果为：
Hello  Closure
&lt;span class=&quot;copy-code-btn&quot;&gt;复制代码&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中，以变量的方式调用闭包&lt;code&gt;t()&lt;/code&gt;与&lt;code&gt;t.call()&lt;/code&gt;是等价的。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash copyable&quot; lang=&quot;bash&quot;&gt;// 2,定义一个闭包，赋值给一个变量，并进行显示的自我调用，并检测其返回值
def t = {
    println &lt;span class=&quot;hljs-string&quot;&gt;&quot;Hello  Closure&quot;
    &lt;span class=&quot;hljs-string&quot;&gt;&quot;ttt&quot;
}
println &lt;span class=&quot;hljs-string&quot;&gt;&quot;closure return: &quot; + t.call()

// 运行后，输出结果为：
Hello  Closure
closure &lt;span class=&quot;hljs-built_in&quot;&gt;return: ttt
&lt;span class=&quot;copy-code-btn&quot;&gt;复制代码&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash copyable&quot; lang=&quot;bash&quot;&gt;// 3,定义一个闭包，赋值给一个变量，并进行显示的自我调用，调用时向闭包传递实参
def t = {
    println &lt;span class=&quot;hljs-string&quot;&gt;&quot;Hello  Closure, the param value is: &quot; + it
}

t(&lt;span class=&quot;hljs-string&quot;&gt;&quot;mm&quot;)

// 运行后，输出结果为：
Hello  Closure, the param value is: mm
&lt;span class=&quot;copy-code-btn&quot;&gt;复制代码&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用闭包时，如果向闭包传递实参，闭包内部如果没有声明形参接收，默认是以it的变量的一个形参去接收实参。&lt;/p&gt;
&lt;p&gt;因此，例3实际上是等价于：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash copyable&quot; lang=&quot;bash&quot;&gt;def t = {
    it -&amp;gt;
        println &lt;span class=&quot;hljs-string&quot;&gt;&quot;Hello  Closure, the param value is: &quot; + it
}

t(&lt;span class=&quot;hljs-string&quot;&gt;&quot;mm&quot;)
&lt;span class=&quot;copy-code-btn&quot;&gt;复制代码&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash copyable&quot; lang=&quot;bash&quot;&gt;// 4,如果闭包中显示的声明了形参，则以显示的声明的形参去接收实参
def t = {
    x, y -&amp;gt;
        println &lt;span class=&quot;hljs-string&quot;&gt;&quot;Hello  Closure, the param value is: &quot; + x + &lt;span class=&quot;hljs-string&quot;&gt;&quot;, &quot; + y
}

t(&lt;span class=&quot;hljs-string&quot;&gt;&quot;mm&quot;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;nn&quot;)

// 运行后，输出结果为：
Hello  Closure, the param value is: mm, nn
&lt;span class=&quot;copy-code-btn&quot;&gt;复制代码&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上，都是将闭包赋值给一个变量后，进行的闭包的调用行为。&lt;/p&gt;
&lt;p&gt;同时，我们也可以将闭包作为一个方法实参，在方法调用时传递给方法形参，然后方法内部形成对此闭包的回调。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash copyable&quot; lang=&quot;bash&quot;&gt;// 5,将闭包作为一个方法实参，在方法调用时传递给方法形参，然后方法内部形成对此闭包的回调
class Person {

    String getName(Closure closure) {
        closure(&lt;span class=&quot;hljs-string&quot;&gt;&quot;cc&quot;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;dd&quot;)
    }
}

def t = {
    x, y -&amp;gt;
        println &lt;span class=&quot;hljs-string&quot;&gt;&quot;Hello  Closure, the param value is: &quot; + x + &lt;span class=&quot;hljs-string&quot;&gt;&quot;, &quot; + y
}

new Person().getName(t)

// 运行后，输出结果为：
Hello  Closure, the param value is: cc, dd
&lt;span class=&quot;copy-code-btn&quot;&gt;复制代码&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例5中的闭包如果没有事先赋值给变量&lt;code&gt;t&lt;/code&gt;，而也可以直接使用，效果等价于：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash copyable&quot; lang=&quot;bash&quot;&gt;class Person {

    String getName(Closure closure) {
        closure(&lt;span class=&quot;hljs-string&quot;&gt;&quot;cc&quot;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;dd&quot;)
    }
}


new Person().getName({
    x, y -&amp;gt;
        println &lt;span class=&quot;hljs-string&quot;&gt;&quot;Hello  Closure, the param value is: &quot; + x + &lt;span class=&quot;hljs-string&quot;&gt;&quot;, &quot; + y
})
&lt;span class=&quot;copy-code-btn&quot;&gt;复制代码&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;闭包作为方法中的最后一个参数，可以从&lt;code&gt;()&lt;/code&gt;中拿出来，则等价于：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash copyable&quot; lang=&quot;bash&quot;&gt;new Person().&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;getName(){
    x, y -&amp;gt;
        println &lt;span class=&quot;hljs-string&quot;&gt;&quot;Hello  Closure, the param value is: &quot; + x + &lt;span class=&quot;hljs-string&quot;&gt;&quot;, &quot; + y
}
&lt;span class=&quot;copy-code-btn&quot;&gt;复制代码&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同时，方法后的&lt;code&gt;()&lt;/code&gt;可以去掉，则等价于：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash copyable&quot; lang=&quot;bash&quot;&gt;new Person().getName {
    x, y -&amp;gt;
        println &lt;span class=&quot;hljs-string&quot;&gt;&quot;Hello  Closure, the param value is: &quot; + x + &lt;span class=&quot;hljs-string&quot;&gt;&quot;, &quot; + y
}
&lt;span class=&quot;copy-code-btn&quot;&gt;复制代码&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果外部调用闭包的方法传递实参时，没有传递实参或只传递了一个参数（如果没有传递实参，则it为null），则进一步演化成：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash copyable&quot; lang=&quot;bash&quot;&gt;class Person {

    String getName(Closure closure) {
        closure(&lt;span class=&quot;hljs-string&quot;&gt;&quot;cc&quot;)
    }
}


new Person().getName {
    println &lt;span class=&quot;hljs-string&quot;&gt;&quot;Hello  Closure, the param value is: &quot; + it
}
&lt;span class=&quot;copy-code-btn&quot;&gt;复制代码&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这也就是我们在Gradle中经常见到的闭包形式，即表面上只有&lt;code&gt;{}&lt;/code&gt;的配置形式。&lt;/p&gt;
&lt;p&gt;将闭包理解成一个特殊的匿名函数，无论是通过变量的自调用，还是作为方法实参的传递后，在方法内部被回调，闭包的最后一行执行被当做匿名函数的整体返回，都可以很好的得以理解。同时，也能容易的理解闭包可以嵌套使用等（即当做匿名函数的嵌套）。&lt;/p&gt;
&lt;p&gt;闭包在&lt;code&gt;Gradle&lt;/code&gt;中的配置中，被大量使用。理解&lt;code&gt;Gradle&lt;/code&gt;中的闭包，对一些特殊的写法，如Gradle构建生命周期中的闭包回调中的实参使用等，可以有很好的运用。&lt;/p&gt;
&lt;p&gt;如常见的在&lt;code&gt;Gradle&lt;/code&gt;构建的&lt;code&gt;配置阶段&lt;/code&gt;中的&lt;code&gt;afterEvaluate&lt;/code&gt; &lt;code&gt;hook&lt;/code&gt;中，可以设置相关&lt;code&gt;task&lt;/code&gt;的依赖关系等。此时，&lt;code&gt;it&lt;/code&gt;接收的是回传进来的当前&lt;code&gt;project&lt;/code&gt;实参。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash copyable&quot; lang=&quot;bash&quot;&gt;afterEvaluate {
    ...

    Task assembleJenkinsTask = rootProject.tasks.getByName(&lt;span class=&quot;hljs-string&quot;&gt;'assembleJenkins')

    Task unitTestTask = it.tasks.findByName(&lt;span class=&quot;hljs-string&quot;&gt;'testDebugUnitTest')

    &lt;span class=&quot;hljs-keyword&quot;&gt;if (unitTestTask != null) {
        assembleJenkinsTask.dependsOn unitTestTask

    }

    ...
}
&lt;span class=&quot;copy-code-btn&quot;&gt;复制代码&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在一定意义上，&lt;code&gt;Groovy&lt;/code&gt;中闭包的概念，以及其实际的用法上，实质上根&lt;code&gt;Java 8&lt;/code&gt;中的&lt;code&gt;lambda&lt;/code&gt;表达式具有很相近的含义。&lt;/p&gt;
&lt;/div&gt;&lt;p&gt;
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。&lt;/p&gt;</description>
<pubDate>Fri, 25 Jan 2019 14:09:00 +0000</pubDate>
<dc:creator>HappyCorn</dc:creator>
<og:description>Gradle是基于Groovy的DSL基础上的构建工具，Gradle中的闭包，其原型上实际上即Groovy中闭包。而在表现形式上，其实，Gradle更多的是以约定和基于约定基础上的配置去展现。但本质上</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lwbqqyumidi/p/10322034.html</dc:identifier>
</item>
<item>
<title>找到bug的根源，问五次为什么 - owenandhisfriends</title>
<link>http://www.cnblogs.com/owenandhisfriends/p/10322015.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/owenandhisfriends/p/10322015.html</guid>
<description>&lt;div class=&quot;markdown-here-wrapper&quot; data-md-url=&quot;https://i.cnblogs.com/EditPosts.aspx?opt=1&quot; readability=&quot;20&quot;&gt;
&lt;p&gt;在学习《问题分析与解决》时学到了一种找到问题根源的方法——问五次为什么。具体内容是：当遇到一个问题，不要只看当前答案，要继续往下问，为什么，连问五次，就能够找到更深层次的问题。&lt;br/&gt;最近在复盘bug的时候，也使用了这种方法，屡试不爽。&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;案例&lt;/h2&gt;
&lt;p&gt;前端发布后，页面按钮点击失效，用户反馈问题，前端回滚代码后恢复。&lt;br/&gt;问题一、为什么按钮点击会失效？&lt;br/&gt;因为前端代码写出了一个bug，没有对空对象进行判空，导致页面js抛出异常，按钮失效。&lt;br/&gt;一般到这里就结束了，把代码加上对象判空，继续发布就完成了。&lt;br/&gt;但是大家集思广益，问五次为什么，看看是否有新的发现。&lt;br/&gt;之后又问了几个为什么，果真有收获。&lt;br/&gt;问题二、为什么是用户反馈，而不是告警发现？&lt;br/&gt;因为当时发现了告警，但是看日志没有查出什么异常，就忽略了。&lt;br/&gt;问题三、为什么没有查出日志，是没写日志，还是写了没查到？&lt;br/&gt;有写日志，但是当时查日志系统特别慢，平时要十多分钟才能查出来，那天一个小时都没出来。&lt;br/&gt;问题四、为什么系统会查不出日志？&lt;br/&gt;不知道。后来找维护系统的人查了下，发现硬盘有问题，紧急更换了磁盘。&lt;br/&gt;问题五、为什么平时要十多分钟才能查出来日志，这么慢？&lt;br/&gt;因为查询日志没有用主key查询，日志量太多，导致查询慢。改进：记录日志时把key值写好，精简不需要的日志。&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;经过问五个为什么，把一个看似简单的线上bug，挖出了更多可以修改的点。为以后及时发现问题，少出事故，做了很大的贡献。&lt;br/&gt;如果只问一个为什么，那么修改的只有表象问题，把代码判断空加上就结束了。&lt;br/&gt;问了五个为什么之后，做了这几件事：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;修复代码判空的bug。&lt;/li&gt;
&lt;li&gt;发现了日志系统的磁盘问题。&lt;/li&gt;
&lt;li&gt;发现了系统的冗余日志，要精简掉。&lt;/li&gt;
&lt;li&gt;发现记录日志的方式不对，修改。&lt;br/&gt;特别是2，如果不找出来，其他系统也会掉到这个坑里，也算是举一反三。发现一个问题，把关联问题，和根本问题都解决了&lt;br/&gt;很多时候，我们遇到的问题都有更深层次的原因。一个问题出现，也都是多个问题同时发生的结果。在大问题发生之前，一定有很多次小问题出现。问5个为什么，就像进行了5次深度和广度的搜索，把问题又向四周和更深的地方挖掘。&lt;br/&gt;每次出问题时都能多问几次为什么？才是从根本上消除问题的一个好方法！&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;​&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Fri, 25 Jan 2019 14:04:00 +0000</pubDate>
<dc:creator>owenandhisfriends</dc:creator>
<og:description>在学习《问题分析与解决》时学到了一种找到问题根源的方法——问五次为什么。具体内容是：当遇到一个问题，不要只看当前答案，要继续往下问，为什么，连问五次，就能够找到更深层次的问题。最近在复盘bug的时候，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/owenandhisfriends/p/10322015.html</dc:identifier>
</item>
<item>
<title>STM32串口接收中断——基于HAL库 - 山无言</title>
<link>http://www.cnblogs.com/UnfriendlyARM/p/10321838.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/UnfriendlyARM/p/10321838.html</guid>
<description>&lt;p&gt;　　最近需要使用一款STM32L4系列的芯片进行开发，需要学习使用HAL库。在进行串口中断使用的时候遇到了一些小麻烦，写下解决方案供大家参考。&lt;/p&gt;
&lt;div readability=&quot;52&quot;&gt;

 　　由于本人直接使用MDK进行开发，没有使用CubeMX，所以一些初始化需要手动进行。在引用UART相关的头文件时，记得将&quot;stm32l4xx_hal_conf.h&quot;文件中的相关宏定义取消注释，如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503563/201901/1503563-20190125213300900-1697140903.png&quot; alt=&quot;&quot;/&gt;
　　接收字符串主要有两种方法，一种是对中断函数进行改造，另一种是对接收回调函数进行改造。&lt;br/&gt;　　在阐述这两种方法之前，需要介绍函数“HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)”。该函数的作用是用户自定义一个缓冲区（即参数pData），接受一定数量（由参数Size决定）的字符存入缓冲区中。同时，参数Size还决定着进入回调函数的频率，即每接收Size个字符，就进入一次回调函数。需要注意的是，Size只决定进入回调函数的频率，而不能影响进入接收中断的频率，无论Size是多少，每接收完成一个字符都会进入一次接收中断。
&lt;h2&gt;方法1：改造回调函数&lt;/h2&gt;
　　①首先在主函数中进入主循环前的位置调用一次 HAL_UART_Receive_IT函数，定义一个字符数组getBuffer[]作为缓冲区，参数Size设定为10。即每接收10个字符，就进入一次回调函数。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503563/201901/1503563-20190125221743988-858096354.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;　　②注册中断函数 　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;  &lt;span&gt;void&lt;/span&gt; USART1_IRQHandler(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt; {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;    HAL_UART_IRQHandler(&amp;amp;UartHandle); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;该函数会清空中断标志，取消中断使能，并间接调用回调函数&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;  }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　③在文件“stm32l4xx_hal_uart.h”中，我们可以看到串口接收回调函数的定义。使用“_weak”关键字定义的函数，其具有如下特性： 一般情况下和一般函数相同。但是当有一个同名函数但是不带__weak被定义时，所有对这个函数的调用都是指向后者(不带__weak那个)。也就是说，ST官方提供的这个回调函数需要我们自己进行改写。　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    * @brief Rx Transfer completed callback.
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    * @param huart UART handle.
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    * @retval None
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;   __weak &lt;span&gt;void&lt;/span&gt; HAL_UART_RxCpltCallback(UART_HandleTypeDef *&lt;span&gt;huart)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;  {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Prevent unused argument(s) compilation warning &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    UNUSED(huart);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;       
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; NOTE : This function should not be modified, when the callback is needed,
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;              the HAL_UART_RxCpltCallback can be implemented in the user file.
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;   }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我们在主函数所在的文件中对回调函数进行改写：  &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;   uint8_t myBuffer[] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;I have gotten your message: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;用户提示信息&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;   uint8_t Enter[] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;回车换行&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;   uint8_t getBuffer[&lt;span&gt;100&lt;/span&gt;]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;用户自定义的缓冲区&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;   &lt;span&gt;void&lt;/span&gt; HAL_UART_RxCpltCallback(UART_HandleTypeDef *&lt;span&gt;UartHandle)
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;  {
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;    &lt;span&gt;while&lt;/span&gt;(HAL_UART_Transmit(UartHandle, (uint8_t*)myBuffer, COUNTOF(myBuffer), &lt;span&gt;5000&lt;/span&gt;)!= HAL_OK); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送字符串，用户提示信息&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt;    &lt;span&gt;while&lt;/span&gt;(HAL_UART_Transmit(UartHandle, (uint8_t*)getBuffer, &lt;span&gt;10&lt;/span&gt;, &lt;span&gt;5000&lt;/span&gt;)!= HAL_OK); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送用户自定义缓冲区中的数据&lt;/span&gt;
&lt;span&gt;8&lt;/span&gt;    &lt;span&gt;while&lt;/span&gt;(HAL_UART_Transmit(UartHandle, (uint8_t*)Enter, COUNTOF(Enter), &lt;span&gt;5000&lt;/span&gt;)!= HAL_OK); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送回车换行&lt;/span&gt;
&lt;span&gt;9&lt;/span&gt;   }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　以上代码的作用是把用户发送给单片机数据再返回给用户。运行效果如下图：&lt;/p&gt;
 &lt;img src=&quot;https://img2018.cnblogs.com/blog/1503563/201901/1503563-20190125213347889-30868576.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;　　我们可以看到，用户向单片机发送了10个字符，单片机向串口助手返回了这10个数据。但是以上程序只能实现一次，当我们再次向单片机发送数据时，单片机却不再返回数据。这是因为我们在中断函数中取消了中断使能，所以导致了进入一次中断后，中断被关闭，无法再次进入中断的现象。为了实现多次数据返回，我们要在中断处理函数中添加一行代码： &lt;/div&gt;
&lt;div readability=&quot;39&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;  &lt;span&gt;void&lt;/span&gt; USART1_IRQHandler(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt; {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;    HAL_UART_IRQHandler(&amp;amp;UartHandle); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;该函数会清空中断标志，取消中断使能，并间接调用回调函数&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;    HAL_UART_Receive_IT(&amp;amp;UartHandle, (uint8_t *)&amp;amp;value,&lt;span&gt;1&lt;/span&gt;);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加的一行代码&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;  }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这样就可以实现多次数据返回了，新的执行结果如下图：&lt;/p&gt;
　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503563/201901/1503563-20190125213446538-72463262.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;　　可见，函数HAL_UART_Receive_IT还有中断使能的作用。这一功能的实现我们可以在HAL_UART_Receive_IT函数中找到。&lt;/p&gt;
&lt;h2&gt; 方法2：改造中断处理函数&lt;/h2&gt;
　　①首先在主函数中进入主循环前的位置调用一次 HAL_UART_Receive_IT函数，定义一个字符value作为缓冲区，参数Size设定为1。即每接收1个字符，就进入一次回调函数。使得进入回调函数的频率与进入中断处理函数的频率相同。这样，我们就可以直接在中断函数中对接收的数据进行处理了。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503563/201901/1503563-20190125221646891-309900616.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;　　②注册中断函数  　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;   uint8_t myBuffer[] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;I have gotten your message: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;   uint8_t getBuffer[&lt;span&gt;10&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;   uint8_t Enter[] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;   &lt;span&gt;void&lt;/span&gt; USARTx_IRQHandler(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;  {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;    HAL_UART_IRQHandler(&amp;amp;UartHandle); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;该函数会清空中断标志，取消中断使能，并间接调用回调函数&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;    
&lt;span&gt; 8&lt;/span&gt;    getBuffer[countOfGetBuffer++] =&lt;span&gt; value; 
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;    &lt;span&gt;if&lt;/span&gt;(countOfGetBuffer == &lt;span&gt;10&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;   {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(HAL_UART_Transmit(&amp;amp;UartHandle, (uint8_t*)myBuffer, COUNTOF(myBuffer), &lt;span&gt;5000&lt;/span&gt;)!=&lt;span&gt; HAL_OK);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(HAL_UART_Transmit(&amp;amp;UartHandle, (uint8_t*)getBuffer, countOfGetBuffer, &lt;span&gt;5000&lt;/span&gt;)!=&lt;span&gt; HAL_OK);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(HAL_UART_Transmit(&amp;amp;UartHandle, (uint8_t*)Enter, COUNTOF(Enter), &lt;span&gt;5000&lt;/span&gt;)!=&lt;span&gt; HAL_OK);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     countOfGetBuffer = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;    HAL_UART_Receive_IT(&amp;amp;UartHandle, (uint8_t *)&amp;amp;value,&lt;span&gt;1&lt;/span&gt;);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;由于接收中断是每接收一个字符便进入一次，所以这一行代码必须添加，否则只能接收一个字符，而无法接收整个字符串&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;   }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　以上代码的作用是接收每个来自用户的字符，并依次存入用户自定义的缓冲区中，数量达到10个后，将缓冲区中的所有数据返回给用户，同时清空计数，准备接下来10个字符的接收。运行效果如下图：&lt;/p&gt;
 &lt;img src=&quot;https://img2018.cnblogs.com/blog/1503563/201901/1503563-20190125213518301-89568796.png&quot; alt=&quot;&quot;/&gt;
&lt;p&gt;　　看完本文，大家可能对&lt;span&gt;回调函数&lt;/span&gt;和&lt;span&gt;中断处理函数&lt;/span&gt;的关系产生了疑问。其实是这样的，单片机每完成接收一个字符，就会进入一次&lt;span&gt;中断处理函数&lt;/span&gt;，而在&lt;span&gt;中断处理函数&lt;/span&gt;中，我们又调用了函数“void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)”，该函数会间接调用&lt;span&gt;回调函数&lt;/span&gt;，也就是说&lt;span&gt;回调函数&lt;/span&gt;是由&lt;span&gt;中断处理函数&lt;/span&gt;间接调用的。而函数“HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)”决定了&lt;span&gt;中断处理函数&lt;/span&gt;调用&lt;span&gt;回调函数&lt;/span&gt;的频率，若Size为1，则每进入一次&lt;span&gt;中断处理函数&lt;/span&gt;都会调用一次&lt;span&gt;回调函数&lt;/span&gt;；若Size为10，则每第十次进入&lt;span&gt;中断处理函数&lt;/span&gt;时，才会调用&lt;span&gt;回调函数&lt;/span&gt;。方法2使用了标准库中断处理数据的思想。&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Fri, 25 Jan 2019 13:52:00 +0000</pubDate>
<dc:creator>山无言</dc:creator>
<og:description>写在前面 最近需要使用一款STM32L4系列的芯片进行开发，需要学习使用HAL库。在进行串口中断使用的时候遇到了一些小麻烦，写下解决方案供大家参考。 1.UART相关的头文件引用错误 由于本人直接使用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/UnfriendlyARM/p/10321838.html</dc:identifier>
</item>
<item>
<title>初识Redux的Middleware - Raion</title>
<link>http://www.cnblogs.com/raion/p/10312056.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/raion/p/10312056.html</guid>
<description>&lt;h2&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;原先改变store是通过dispatch(action) = &amp;gt; reducer；那Redux的Middleware是什么呢？就是dispatch(action) = &amp;gt; reducer过程中搞点事情，既不更改原代码，还能扩展原有功能，这就是Redux的中间件。&lt;/p&gt;
&lt;p&gt;至于Redux的Middleware是怎么演变来的，推荐去看看&lt;a href=&quot;https://www.redux.org.cn/docs/advanced/Middleware.html&quot; target=&quot;_blank&quot;&gt;Redux的官网文档&lt;/a&gt;，讲得很不错，诸位一定要多看几遍。如果你发现还是不好理解，那请你花点时间，细心看看这篇文章。文章内容比较多，希望你跟着我一步一步敲着代码学习，这样收获更多，要是有什么疑惑或者不对的地方，请指出！🤝🤝🤝&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;基础环境&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里使用create-react-app搭建环境，方便快速。注意请先自行安装node。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
sudo npm i -g create-react-app (如果已经安装过，请忽略；期间根据提示输入密码即可。window用户执行npm i -g create-react-app) &lt;br/&gt;create-react-app redux-&lt;span&gt;middleware
cd redux&lt;/span&gt;-&lt;span&gt;middleware
yarn add redux react-redux mockjs axios（create-react-app默认使用yarn作为包管理，这里就照着用）&lt;p&gt;// 下面是版本号&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&quot;dependencies&quot;: {&lt;br/&gt;&quot;axios&quot;: &quot;^0.18.0&quot;,&lt;br/&gt;&quot;mockjs&quot;: &quot;^1.0.1-beta3&quot;,&lt;br/&gt;&quot;react&quot;: &quot;^16.7.0&quot;,&lt;br/&gt;&quot;react-dom&quot;: &quot;^16.7.0&quot;,&lt;br/&gt;&quot;react-redux&quot;: &quot;^6.0.0&quot;,&lt;br/&gt;&quot;react-scripts&quot;: &quot;2.1.3&quot;,&lt;br/&gt;&quot;redux&quot;: &quot;^4.0.1&quot;&lt;br/&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;一个小例子&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;为了方便，使用mock拦截，模仿后台接口，根据输入内容，返回模拟数据。现在改写App.js，其余不变。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
import React, { Component } from 'react'&lt;span&gt;;
import axios from &lt;/span&gt;'axios'&lt;span&gt;;
import Mock from &lt;/span&gt;'mockjs'&lt;span&gt;;

Mock.mock(&lt;/span&gt;'http://test.com/search'&lt;span&gt;, {
  &lt;/span&gt;'list|0-5'&lt;span&gt;: [{
    &lt;/span&gt;'id|+1': 1&lt;span&gt;,
    name: &lt;/span&gt;'@character(&quot;lower&quot;)'&lt;span&gt;,
    &lt;/span&gt;'version': '@float(1, 10, 2, 2)'&lt;span&gt;,
    publisher: &lt;/span&gt;'@cname'&lt;span&gt;
  }]
});

class App extends Component {
  state &lt;/span&gt;=&lt;span&gt; {
    data: [],
    searchValue: &lt;/span&gt;''&lt;span&gt;
  };
  handleSearch &lt;/span&gt;= e =&amp;gt;&lt;span&gt; {
    e.preventDefault();
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.state.searchValue) {
      axios.get(`http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;test.com/search`).then(result =&amp;gt; {&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (result.status === 200&lt;span&gt;) {
          &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.setState({ data: result.data.list.map(item =&amp;gt; ({...item, name: `${&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.state.searchValue}${item.name}`})) });
        }
      })
    }
  };
  changeValue &lt;/span&gt;= e =&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setState({ searchValue: e.target.value });
  };
  render() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (
      &lt;/span&gt;&amp;lt;div style={{ textAlign: 'center', margin: '40px' }}&amp;gt;
        &amp;lt;form onSubmit={&lt;span&gt;this&lt;/span&gt;.handleSearch}&amp;gt;
          &amp;lt;input type=&quot;text&quot; value={&lt;span&gt;this&lt;/span&gt;.state.searchValue} onChange={&lt;span&gt;this&lt;/span&gt;.changeValue} /&amp;gt;
          &amp;lt;button type=&quot;submit&quot;&amp;gt;搜索&amp;lt;/button&amp;gt;
        &amp;lt;/form&amp;gt;
        &amp;lt;ul&amp;gt;&lt;span&gt;
        {&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.state.data.map(item =&amp;gt;&lt;span&gt; (
          &lt;/span&gt;&amp;lt;li key={item.id} style={{ listStyle: 'none' }}&amp;gt;
            &amp;lt;p&amp;gt;{item.name}&amp;lt;/p&amp;gt;
            &amp;lt;p&amp;gt;&lt;span&gt;
              {item.publisher} publish {item.version}
            &lt;/span&gt;&amp;lt;/p&amp;gt;
          &amp;lt;/li&amp;gt;
&lt;span&gt;          ))}
        &lt;/span&gt;&amp;lt;/ul&amp;gt;
      &amp;lt;/div&amp;gt;
&lt;span&gt;    );
  }
}

export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; App;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;开始redux中间件之旅&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;现在将App组件与redux关联起来，数据存入state中。&lt;/p&gt;
&lt;p&gt;更改index.js。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
import React from 'react'&lt;span&gt;;
import ReactDOM from &lt;/span&gt;'react-dom'&lt;span&gt;;
import { createStore } from &lt;/span&gt;'redux'&lt;span&gt;;
import { Provider } from &lt;/span&gt;'react-redux'&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
import App from &lt;/span&gt;'./App'&lt;span&gt;;
import &lt;/span&gt;* as serviceWorker from './serviceWorker'&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt; listReducer(state =&lt;span&gt; { list: [] }, action) {
  &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (action.type) {
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; 'receive'&lt;span&gt;:
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
        list: action.data
      };
    &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; state;
  }
}

const store &lt;/span&gt;=&lt;span&gt; createStore(listReducer);

ReactDOM.render(
  &lt;/span&gt;&amp;lt;Provider store={store}&amp;gt;
    &amp;lt;App /&amp;gt;
  &amp;lt;/Provider&amp;gt;, document.getElementById('root'));
&lt;span&gt;
serviceWorker.unregister();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;更改App.js。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
import React, { Component } from 'react'&lt;span&gt;;
import { connect } from &lt;/span&gt;'react-redux'&lt;span&gt;;
import axios from &lt;/span&gt;'axios'&lt;span&gt;;
import Mock from &lt;/span&gt;'mockjs'&lt;span&gt;;

Mock.mock(&lt;/span&gt;'http://test.com/search'&lt;span&gt;, {
  &lt;/span&gt;'list|0-5'&lt;span&gt;: [{
    &lt;/span&gt;'id|+1': 1&lt;span&gt;,
    name: &lt;/span&gt;'@character(&quot;lower&quot;)'&lt;span&gt;,
    &lt;/span&gt;'version': '@float(1, 10, 2, 2)'&lt;span&gt;,
    publisher: &lt;/span&gt;'@cname'&lt;span&gt;
  }]
});

class App extends Component {
  state &lt;/span&gt;=&lt;span&gt; {
    searchValue: &lt;/span&gt;''&lt;span&gt;
  };
  handleSearch &lt;/span&gt;= e =&amp;gt;&lt;span&gt; {
    e.preventDefault();
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.state.searchValue) {
      axios.get(`http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;test.com/search`).then(result =&amp;gt; {&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (result.status === 200&lt;span&gt;) {
          &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.props.changeList(result.data.list.map(item =&amp;gt; ({...item, name: `${&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.state.searchValue}${item.name}`})));
        }
      })
    }
  };
  changeValue &lt;/span&gt;= e =&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setState({ searchValue: e.target.value });
  };
  render() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (
      &lt;/span&gt;&amp;lt;div style={{ textAlign: 'center', margin: '40px' }}&amp;gt;
        &amp;lt;form onSubmit={&lt;span&gt;this&lt;/span&gt;.handleSearch}&amp;gt;
          &amp;lt;input type=&quot;text&quot; value={&lt;span&gt;this&lt;/span&gt;.state.searchValue} onChange={&lt;span&gt;this&lt;/span&gt;.changeValue} /&amp;gt;
          &amp;lt;button type=&quot;submit&quot;&amp;gt;搜索&amp;lt;/button&amp;gt;
        &amp;lt;/form&amp;gt;
        &amp;lt;ul&amp;gt;&lt;span&gt;
        {&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.props.list.map(item =&amp;gt;&lt;span&gt; (
          &lt;/span&gt;&amp;lt;li key={item.id} style={{ listStyle: 'none' }}&amp;gt;
            &amp;lt;p&amp;gt;{item.name}&amp;lt;/p&amp;gt;
            &amp;lt;p&amp;gt;&lt;span&gt;
              {item.publisher} publish {item.version}
            &lt;/span&gt;&amp;lt;/p&amp;gt;
          &amp;lt;/li&amp;gt;
&lt;span&gt;          ))}
        &lt;/span&gt;&amp;lt;/ul&amp;gt;
      &amp;lt;/div&amp;gt;
&lt;span&gt;    );
  }
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; mapStateToProps(state) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
    list: state.list
  }
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; mapDispatchToProps(dispatch) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
    changeList: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (data) {
      dispatch({ type: &lt;/span&gt;'receive'&lt;span&gt;, data });
    }
  }
}

export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; connect(mapStateToProps, mapDispatchToProps)(App);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试一下，我们搜索rxjs，结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1300457/201901/1300457-20190124202702706-1904644043.png&quot; alt=&quot;&quot; width=&quot;253&quot; height=&quot;265&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不错，现在是时候了解下redux的中间件了。首先，我想实现一个日志记录的中间件，在dispatch(action) =&amp;gt; reducer的过程中能打印派发的action和更改后的store。在没有中间件时，我们来更改下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; MapStateToProps(state) {
  &lt;span&gt;console.log(&lt;/span&gt;&lt;/span&gt;&lt;span&gt;'nextState: ', state);
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
    list: state.list
  }
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; mapDispatchToProps(dispatch) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
    changeList: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (data) {
      &lt;span&gt;const action &lt;/span&gt;&lt;/span&gt;&lt;span&gt;= { type: 'receive', data };
      console.log('dispatch: '&lt;/span&gt;&lt;span&gt;&lt;span&gt;, action);
      dispatch(action);&lt;/span&gt;
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1300457/201901/1300457-20190124203307608-797035085.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;很可惜，虽然实现了，但在组件初始化时，却打印了初始化的state。原因在于mapStateToProps方法无法判断是初始化返回的数据还是dispatch(action) =&amp;gt; reducer引发的state更改。当然这里你可以用一个变量去保存是不是初始化组件（即第一次调用mapStateToProps），但是加入了额外的开销不说，还手动更改了mapStateToProps和mapDispatchToProps方法，代码一下子不好看了。这该怎么办呢？先回溯到更改state过程：dispatch(action) =&amp;gt; reducer =&amp;gt; state。由于reducer是一个纯函数，只要函数参数唯一，返回结果必定唯一。通过reducer来实现日志当然可以，但是感觉reducer不纯了。你本来只负责生成新state，不能有自己的小心思。那只好把目光放到dispatch上，先来看看dispatch内部实现。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; dispatch(action) {
    ...&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 数据校验&lt;/span&gt;
    &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
      isDispatching &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
      currentState &lt;/span&gt;=&lt;span&gt; currentReducer(currentState, action)
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 哈哈，新state在此&lt;/span&gt;
    } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
      isDispatching &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;
    }

    const listeners &lt;/span&gt;= (currentListeners =&lt;span&gt; nextListeners)
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (let i = 0; i &amp;lt; listeners.length; i++&lt;span&gt;) {
      const listener &lt;/span&gt;=&lt;span&gt; listeners[i]
      listener()
    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; action
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;dispatch是store提供的一个方法，要访问只能在调用dispatch时做些文章。那我试试替换dispatch方法呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; logMiddleware(action) {
    console.log(&lt;/span&gt;'dispatch: '&lt;span&gt;, action);
    dispatch(action);
    console.log(&lt;/span&gt;'nextState: '&lt;span&gt;, currentState);
}

&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
    dispatch: &lt;span&gt;logMiddleware&lt;/span&gt;,
    subscribe,
    getState,
    replaceReducer,
    [$$observable]: observable
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样明目张胆改了源码不好，换一种方式。更改index.js。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
import React from 'react'&lt;span&gt;;
import ReactDOM from &lt;/span&gt;'react-dom'&lt;span&gt;;
import { createStore } from &lt;/span&gt;'redux'&lt;span&gt;;
import { Provider } from &lt;/span&gt;'react-redux'&lt;span&gt;;
import App from &lt;/span&gt;'./App'&lt;span&gt;;
import &lt;/span&gt;* as serviceWorker from './serviceWorker'&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt; listReducer(state =&lt;span&gt; { list: [] }, action) {
  &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (action.type) {
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; 'receive'&lt;span&gt;:
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
        list: action.data
      };
    &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; state;
  }
}

const store &lt;/span&gt;=&lt;span&gt; createStore(listReducer);

&lt;span&gt;let next &lt;/span&gt;&lt;/span&gt;&lt;span&gt;= store.dispatch;
store.dispatch = function logMiddleware(action) {
  console.log('dispatch: ', action);
  next(action);
  console.log('nextState: '&lt;/span&gt;&lt;span&gt;&lt;span&gt;, store.getState());
};&lt;/span&gt;

ReactDOM.render(
  &lt;/span&gt;&amp;lt;Provider store={store}&amp;gt;
    &amp;lt;App /&amp;gt;
  &amp;lt;/Provider&amp;gt;, document.getElementById('root'));
&lt;span&gt;
serviceWorker.unregister();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;删除App.js中我们加入的日志记录代码。再次搜索如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1300457/201901/1300457-20190124222637918-1189734121.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样乍一看好像可行，如果再加一个中间件呢？再次更改index.js。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
...&lt;br/&gt;let next =&lt;span&gt; store.dispatch;
store.dispatch &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt; logMiddleware(action) {
  console.log(&lt;/span&gt;'dispatch: '&lt;span&gt;, action);
  next(action);
  console.log(&lt;/span&gt;'nextState: '&lt;span&gt;, store.getState());
};
&lt;span&gt;let next2 &lt;/span&gt;&lt;/span&gt;&lt;span&gt;= store.dispatch;&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里的store.dispatch是logMiddleware&lt;/span&gt;
&lt;span&gt;store.dispatch = function logMiddleware2(action) {
  console.log('logMiddleware2 start');
  next2(action);
  console.log('logMiddleware2 end');
};&lt;br/&gt;&lt;span&gt;...&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1300457/201901/1300457-20190124223937880-1170202398.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;糟糕，每次加入一个中间件都得用个变量去存吗？这样的代码太滑稽了，那该如何优雅的获取上一个中间件呢？换个角度思考下，如果将中间件作为参数传递，那效果是不是不一样呢？更改后的index.js如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;...&lt;/span&gt;&lt;br/&gt;&lt;span&gt;function&lt;/span&gt;&lt;/span&gt;&lt;span&gt; logMiddleware(dispatch, action) {
  console.log('dispatch: ', action);
  let next = dispatch(action);
  console.log('nextState: ', store.getState());
  return next;
}
function logMiddleware2(dispatch, action) {
  console.log('logMiddleware2 start');
  let next = dispatch(action);
  console.log('logMiddleware2 end');
  return next;
}

let dispatch = logMiddleware2(logMiddleware(store.dispatch, action), action);
store.dispatch = dispatch;&lt;/span&gt;&lt;br/&gt;...
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里action这样传递是有问题的，得琢磨琢磨。既然是dispatch(action)，那中间件返回一个函数，函数的参数就是action呢？修改index.js如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;...&lt;/span&gt;&lt;br/&gt;function&lt;/span&gt;&lt;span&gt; logMiddleware(&lt;span&gt;dispatch&lt;/span&gt;) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;&lt;span&gt; (action)&lt;/span&gt; {
    console.log(&lt;/span&gt;'dispatch: '&lt;span&gt;, action);
    let next &lt;/span&gt;=&lt;span&gt; dispatch(action);
    console.log(&lt;/span&gt;'nextState: '&lt;span&gt;, store.getState());
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; next;
  }
}
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; logMiddleware2(&lt;span&gt;dispatch&lt;/span&gt;) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;&lt;span&gt; (action)&lt;/span&gt; {
    console.log(&lt;/span&gt;'logMiddleware2 start'&lt;span&gt;);
    let next &lt;/span&gt;=&lt;span&gt; dispatch(action);
    console.log(&lt;/span&gt;'logMiddleware2 end'&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; next;
  }
}

&lt;span&gt;let dispatch &lt;/span&gt;&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&lt;span&gt; logMiddleware2(logMiddleware(store.dispatch));&lt;/span&gt;
store.dispatch &lt;/span&gt;= dispatch;&lt;br/&gt;...
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1300457/201901/1300457-20190124225715056-2107009500.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Yes，we can！！！但是细看代码还是不完美，logMiddleware中store是直接获取的，严重耦合在一起。如果将logMiddleware单独放入一个模块文件中，代码就不能正常运行了。那还不简单，将store导出，再导入到logMiddleware模块中不就完了。可是这样还是严重耦合，只是换了一种方式而已(你写的中间件应该是其他小伙伴拿来即用的，不应该有其他骚操作)。骚年，还得再想想办法。index.js，不要抱怨，还得再改改你。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;...&lt;/span&gt;&lt;br/&gt;function&lt;/span&gt;&lt;span&gt;&lt;span&gt; logMiddleware(store)&lt;/span&gt; {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (dispatch) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (action) {
      console.log(&lt;/span&gt;'dispatch: '&lt;span&gt;, action);
      let next &lt;/span&gt;=&lt;span&gt; dispatch(action);
      console.log(&lt;/span&gt;'nextState: '&lt;span&gt;, store.getState());
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; next;
    }
  }
}
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;&lt;span&gt; logMiddleware2(store)&lt;/span&gt; {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (dispatch) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (action) {
      console.log(&lt;/span&gt;'logMiddleware2 start'&lt;span&gt;);
      let next &lt;/span&gt;=&lt;span&gt; dispatch(action);
      console.log(&lt;/span&gt;'logMiddleware2 end'&lt;span&gt;);
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; next;
    }
  }
}

&lt;/span&gt;&lt;span&gt;let dispatch = logMiddleware2(store)(logMiddleware(store)(store.dispatch));&lt;/span&gt;&lt;span&gt;&lt;span&gt;
store.dispatch&lt;/span&gt; &lt;/span&gt;= dispatch;&lt;br/&gt;...
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们可以发现logMiddleware中dispatch是store.dispatch，logMiddleware2中的dispatch是logMiddleware中间件。既然如此，那换个名称，以免误会。这里统一改成next。最后let dispatch = ...只是为了让大家看懂过程，现在也改一下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;...&lt;/span&gt;&lt;br/&gt;function&lt;/span&gt;&lt;span&gt; logMiddleware(store) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (&lt;span&gt;next&lt;/span&gt;) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (action) {
      console.log(&lt;/span&gt;'dispatch: '&lt;span&gt;, action);
      &lt;span&gt;let result &lt;/span&gt;&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&lt;span&gt; next(action);&lt;/span&gt;
      console.log(&lt;/span&gt;'nextState: '&lt;span&gt;, store.getState());
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;&lt;span&gt; result&lt;/span&gt;;
    }
  }
}
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; logMiddleware2(store) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (&lt;span&gt;next&lt;/span&gt;) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (action) {
      console.log(&lt;/span&gt;'logMiddleware2 start'&lt;span&gt;);
      &lt;span&gt;let result &lt;/span&gt;&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&lt;span&gt; next(action);&lt;/span&gt;
      console.log(&lt;/span&gt;'logMiddleware2 end'&lt;span&gt;);
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;&lt;span&gt; result&lt;/span&gt;;
    }
  }
}

&lt;span&gt;const middlewares &lt;/span&gt;&lt;/span&gt;&lt;span&gt;= [logMiddleware2, logMiddleware];
const chain = middlewares.map(middleware =&amp;gt; middleware(store));
const chains = chain.reduce((a, b) =&amp;gt; (...args) =&amp;gt; a(b(...args)));
let dispatch =&lt;/span&gt;&lt;span&gt;&lt;span&gt; chains(store.dispatch);&lt;/span&gt;
store.dispatch &lt;/span&gt;= dispatch;&lt;br/&gt;...
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1300457/201901/1300457-20190125002734378-244848742.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;讲到这里，基础也差不多讲完了，希望你能对redux中间件有一个比较初步的认识。&lt;/p&gt;

</description>
<pubDate>Fri, 25 Jan 2019 13:41:00 +0000</pubDate>
<dc:creator>Raion</dc:creator>
<og:description>前言 原先改变store是通过dispatch(action) = &gt; reducer；那Redux的Middleware是什么呢？就是dispatch(action) = &gt; reduc</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/raion/p/10312056.html</dc:identifier>
</item>
</channel>
</rss>